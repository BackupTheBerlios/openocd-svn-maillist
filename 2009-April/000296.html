<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1512 - trunk/src/target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1512%20-%20trunk/src/target&In-Reply-To=%3C200904221840.n3MIe24q023930%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000295.html">
   <LINK REL="Next"  HREF="000297.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1512 - trunk/src/target</H1>
    <B>oharboe at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1512%20-%20trunk/src/target&In-Reply-To=%3C200904221840.n3MIe24q023930%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1512 - trunk/src/target">oharboe at mail.berlios.de
       </A><BR>
    <I>Wed Apr 22 20:40:02 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000295.html">[Openocd-svn] r1511 - trunk/src/server
</A></li>
        <LI>Next message: <A HREF="000297.html">[Openocd-svn] r1513 - trunk/src/helper
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#296">[ date ]</a>
              <a href="thread.html#296">[ thread ]</a>
              <a href="subject.html#296">[ subject ]</a>
              <a href="author.html#296">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: oharboe
Date: 2009-04-22 20:39:59 +0200 (Wed, 22 Apr 2009)
New Revision: 1512

Modified:
   trunk/src/target/arm11.c
   trunk/src/target/arm11.h
   trunk/src/target/arm11_dbgtap.c
Log:
Michael Bruck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">mbruck at digenius.de</A>&gt; ARM11 various updates + fix formatting.

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-04-22 17:36:00 UTC (rev 1511)
+++ trunk/src/target/arm11.c	2009-04-22 18:39:59 UTC (rev 1512)
@@ -50,9 +50,11 @@
 
 static void arm11_on_enter_debug_state(arm11_common_t * arm11);
 
-bool	arm11_config_memwrite_burst		= true;
-bool	arm11_config_memwrite_error_fatal	= true;
-u32	arm11_vcr				= 0;
+bool	arm11_config_memwrite_burst				= true;
+bool	arm11_config_memwrite_error_fatal		= true;
+u32		arm11_vcr								= 0;
+bool	arm11_config_memrw_no_increment			= false;
+bool	arm11_config_step_irq_enable			= false;
 
 #define ARM11_HANDLER(x)	\
 	.x				= arm11_##x
@@ -131,9 +133,9 @@
 
 typedef struct arm11_reg_defs_s
 {
-	char *			name;
-	u32				num;
-	int				gdb_num;
+	char *					name;
+	u32						num;
+	int						gdb_num;
 	enum arm11_regtype		type;
 } arm11_reg_defs_t;
 
@@ -308,8 +310,8 @@
  *
  * \param arm11		Target state variable.
  * \param dscr		If the current DSCR content is
- *				available a pointer to a word holding the
- *				DSCR can be passed. Otherwise use NULL.
+ *					available a pointer to a word holding the
+ *					DSCR can be passed. Otherwise use NULL.
  */
 void arm11_check_init(arm11_common_t * arm11, u32 * dscr)
 {
@@ -319,37 +321,37 @@
 
 	if (!dscr)
 	{
-	dscr = &amp;dscr_local_tmp_copy;
-	*dscr = arm11_read_DSCR(arm11);
+		dscr = &amp;dscr_local_tmp_copy;
+		*dscr = arm11_read_DSCR(arm11);
 	}
 
 	if (!(*dscr &amp; ARM11_DSCR_MODE_SELECT))
 	{
-	LOG_DEBUG(&quot;Bringing target into debug mode&quot;);
+		LOG_DEBUG(&quot;Bringing target into debug mode&quot;);
 
-	*dscr |= ARM11_DSCR_MODE_SELECT;		/* Halt debug-mode */
-	arm11_write_DSCR(arm11, *dscr);
+		*dscr |= ARM11_DSCR_MODE_SELECT;		/* Halt debug-mode */
+		arm11_write_DSCR(arm11, *dscr);
 
-	/* add further reset initialization here */
+		/* add further reset initialization here */
 
-	arm11-&gt;simulate_reset_on_next_halt = true;
+		arm11-&gt;simulate_reset_on_next_halt = true;
 
-	if (*dscr &amp; ARM11_DSCR_CORE_HALTED)
-	{
-		/** \todo TODO: this needs further scrutiny because
-		  * arm11_on_enter_debug_state() never gets properly called
-		  */
+		if (*dscr &amp; ARM11_DSCR_CORE_HALTED)
+		{
+			/** \todo TODO: this needs further scrutiny because
+			  * arm11_on_enter_debug_state() never gets properly called
+			  */
 
-		arm11-&gt;target-&gt;state	= TARGET_HALTED;
-		arm11-&gt;target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(*dscr);
-	}
-	else
-	{
-		arm11-&gt;target-&gt;state	= TARGET_RUNNING;
-		arm11-&gt;target-&gt;debug_reason	= DBG_REASON_NOTHALTED;
-	}
+			arm11-&gt;target-&gt;state	= TARGET_HALTED;
+			arm11-&gt;target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(*dscr);
+		}
+		else
+		{
+			arm11-&gt;target-&gt;state	= TARGET_RUNNING;
+			arm11-&gt;target-&gt;debug_reason	= DBG_REASON_NOTHALTED;
+		}
 
-	arm11_sc7_clear_vbw(arm11);
+		arm11_sc7_clear_vbw(arm11);
 	}
 }
 
@@ -371,8 +373,8 @@
 	{size_t i;
 	for(i = 0; i &lt; asizeof(arm11-&gt;reg_values); i++)
 	{
-	arm11-&gt;reg_list[i].valid	= 1;
-	arm11-&gt;reg_list[i].dirty	= 0;
+		arm11-&gt;reg_list[i].valid	= 1;
+		arm11-&gt;reg_list[i].dirty	= 0;
 	}}
 
 	/* Save DSCR */
@@ -383,21 +385,21 @@
 
 	if (R(DSCR) &amp; ARM11_DSCR_WDTR_FULL)
 	{
-	arm11_add_debug_SCAN_N(arm11, 0x05, TAP_INVALID);
+		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
-	arm11_add_IR(arm11, ARM11_INTEST, TAP_INVALID);
+		arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
-	scan_field_t	chain5_fields[3];
+		scan_field_t	chain5_fields[3];
 
-	arm11_setup_field(arm11, 32, NULL, &amp;R(WDTR),	chain5_fields + 0);
-	arm11_setup_field(arm11,  1, NULL, NULL,	chain5_fields + 1);
-	arm11_setup_field(arm11,  1, NULL, NULL,	chain5_fields + 2);
+		arm11_setup_field(arm11, 32, NULL, &amp;R(WDTR),	chain5_fields + 0);
+		arm11_setup_field(arm11,  1, NULL, NULL,	chain5_fields + 1);
+		arm11_setup_field(arm11,  1, NULL, NULL,	chain5_fields + 2);
 
-	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 	else
 	{
-	arm11-&gt;reg_list[ARM11_RC_WDTR].valid	= 0;
+		arm11-&gt;reg_list[ARM11_RC_WDTR].valid	= 0;
 	}
 
 
@@ -413,35 +415,35 @@
 
 
 	/* From the spec:
-	Before executing any instruction in debug state you have to drain the write buffer.
-		This ensures that no imprecise Data Aborts can return at a later point:*/
+	   Before executing any instruction in debug state you have to drain the write buffer.
+	   This ensures that no imprecise Data Aborts can return at a later point:*/
 
 	/** \todo TODO: Test drain write buffer. */
 
 #if 0
 	while (1)
 	{
-	/* MRC p14,0,R0,c5,c10,0 */
-//	arm11_run_instr_no_data1(arm11, /*0xee150e1a*/0xe320f000);
+		/* MRC p14,0,R0,c5,c10,0 */
+		//	arm11_run_instr_no_data1(arm11, /*0xee150e1a*/0xe320f000);
 
-	/* mcr	   15, 0, r0, cr7, cr10, {4} */
-	arm11_run_instr_no_data1(arm11, 0xee070f9a);
+		/* mcr	   15, 0, r0, cr7, cr10, {4} */
+		arm11_run_instr_no_data1(arm11, 0xee070f9a);
 
-	u32 dscr = arm11_read_DSCR(arm11);
+		u32 dscr = arm11_read_DSCR(arm11);
 
-	LOG_DEBUG(&quot;DRAIN, DSCR %08x&quot;, dscr);
+		LOG_DEBUG(&quot;DRAIN, DSCR %08x&quot;, dscr);
 
-	if (dscr &amp; ARM11_DSCR_STICKY_IMPRECISE_DATA_ABORT)
-	{
-		arm11_run_instr_no_data1(arm11, 0xe320f000);
+		if (dscr &amp; ARM11_DSCR_STICKY_IMPRECISE_DATA_ABORT)
+		{
+			arm11_run_instr_no_data1(arm11, 0xe320f000);
 
-		dscr = arm11_read_DSCR(arm11);
+			dscr = arm11_read_DSCR(arm11);
 
-		LOG_DEBUG(&quot;DRAIN, DSCR %08x (DONE)&quot;, dscr);
+			LOG_DEBUG(&quot;DRAIN, DSCR %08x (DONE)&quot;, dscr);
 
-		break;
+			break;
+		}
 	}
-	}
 #endif
 
 	arm11_run_instr_data_prepare(arm11);
@@ -453,8 +455,8 @@
 	{size_t i;
 	for (i = 0; i &lt; 15; i++)
 	{
-	/* MCR p14,0,R?,c0,c5,0 */
-	arm11_run_instr_data_from_core(arm11, 0xEE000E15 | (i &lt;&lt; 12), &amp;R(RX + i), 1);
+		/* MCR p14,0,R?,c0,c5,0 */
+		arm11_run_instr_data_from_core(arm11, 0xEE000E15 | (i &lt;&lt; 12), &amp;R(RX + i), 1);
 	}}
 
 	/* save rDTR */
@@ -463,12 +465,12 @@
 
 	if (R(DSCR) &amp; ARM11_DSCR_RDTR_FULL)
 	{
-	/* MRC p14,0,R0,c0,c5,0 (move rDTR -&gt; r0 (-&gt; wDTR -&gt; local var)) */
-	arm11_run_instr_data_from_core_via_r0(arm11, 0xEE100E15, &amp;R(RDTR));
+		/* MRC p14,0,R0,c0,c5,0 (move rDTR -&gt; r0 (-&gt; wDTR -&gt; local var)) */
+		arm11_run_instr_data_from_core_via_r0(arm11, 0xEE100E15, &amp;R(RDTR));
 	}
 	else
 	{
-	arm11-&gt;reg_list[ARM11_RC_RDTR].valid	= 0;
+		arm11-&gt;reg_list[ARM11_RC_RDTR].valid	= 0;
 	}
 
 	/* save CPSR */
@@ -485,27 +487,27 @@
 
 	if (R(CPSR) &amp; ARM11_CPSR_J)	/* Java state */
 	{
-	arm11-&gt;reg_values[ARM11_RC_PC] -= 0;
+		arm11-&gt;reg_values[ARM11_RC_PC] -= 0;
 	}
 	else if (R(CPSR) &amp; ARM11_CPSR_T)	/* Thumb state */
 	{
-	arm11-&gt;reg_values[ARM11_RC_PC] -= 4;
+		arm11-&gt;reg_values[ARM11_RC_PC] -= 4;
 	}
 	else					/* ARM state */
 	{
-	arm11-&gt;reg_values[ARM11_RC_PC] -= 8;
+		arm11-&gt;reg_values[ARM11_RC_PC] -= 8;
 	}
 
 	if (arm11-&gt;simulate_reset_on_next_halt)
 	{
-	arm11-&gt;simulate_reset_on_next_halt = false;
+		arm11-&gt;simulate_reset_on_next_halt = false;
 
-	LOG_DEBUG(&quot;Reset c1 Control Register&quot;);
+		LOG_DEBUG(&quot;Reset c1 Control Register&quot;);
 
-	/* Write 0 (reset value) to Control register 0 to disable MMU/Cache etc. */
+		/* Write 0 (reset value) to Control register 0 to disable MMU/Cache etc. */
 
-	/* MCR p15,0,R0,c1,c0,0 */
-	arm11_run_instr_data_to_core_via_r0(arm11, 0xee010f10, 0);
+		/* MCR p15,0,R0,c1,c0,0 */
+		arm11_run_instr_data_to_core_via_r0(arm11, 0xee010f10, 0);
 
 	}
 
@@ -519,23 +521,23 @@
 	{size_t i;
 	for(i = 0; i &lt; ARM11_REGCACHE_COUNT; i++)
 	{
-	if (!arm11-&gt;reg_list[i].valid)
-	{
-		if (arm11-&gt;reg_history[i].valid)
-		LOG_INFO(&quot;%8s INVALID	 (%08x)&quot;, arm11_reg_defs[i].name, arm11-&gt;reg_history[i].value);
-	}
-	else
-	{
-		if (arm11-&gt;reg_history[i].valid)
+		if (!arm11-&gt;reg_list[i].valid)
 		{
-		if (arm11-&gt;reg_history[i].value != arm11-&gt;reg_values[i])
-			LOG_INFO(&quot;%8s %08x (%08x)&quot;, arm11_reg_defs[i].name, arm11-&gt;reg_values[i], arm11-&gt;reg_history[i].value);
+			if (arm11-&gt;reg_history[i].valid)
+				LOG_INFO(&quot;%8s INVALID	 (%08x)&quot;, arm11_reg_defs[i].name, arm11-&gt;reg_history[i].value);
 		}
 		else
 		{
-		LOG_INFO(&quot;%8s %08x (INVALID)&quot;, arm11_reg_defs[i].name, arm11-&gt;reg_values[i]);
+			if (arm11-&gt;reg_history[i].valid)
+			{
+				if (arm11-&gt;reg_history[i].value != arm11-&gt;reg_values[i])
+					LOG_INFO(&quot;%8s %08x (%08x)&quot;, arm11_reg_defs[i].name, arm11-&gt;reg_values[i], arm11-&gt;reg_history[i].value);
+			}
+			else
+			{
+				LOG_INFO(&quot;%8s %08x (INVALID)&quot;, arm11_reg_defs[i].name, arm11-&gt;reg_values[i]);
+			}
 		}
-	}
 	}}
 }
 
@@ -556,28 +558,27 @@
 	{size_t i;
 	for (i = 1; i &lt; 15; i++)
 	{
-	if (!arm11-&gt;reg_list[ARM11_RC_RX + i].dirty)
-		continue;
+		if (!arm11-&gt;reg_list[ARM11_RC_RX + i].dirty)
+			continue;
 
-	/* MRC p14,0,r?,c0,c5,0 */
-	arm11_run_instr_data_to_core1(arm11, 0xee100e15 | (i &lt;&lt; 12), R(RX + i));
+		/* MRC p14,0,r?,c0,c5,0 */
+		arm11_run_instr_data_to_core1(arm11, 0xee100e15 | (i &lt;&lt; 12), R(RX + i));
 
-//	LOG_DEBUG(&quot;RESTORE R&quot; ZU &quot; %08x&quot;, i, R(RX + i));
+		//	LOG_DEBUG(&quot;RESTORE R&quot; ZU &quot; %08x&quot;, i, R(RX + i));
 	}}
 
 	arm11_run_instr_data_finish(arm11);
 
 	/* spec says clear wDTR and rDTR; we assume they are clear as
 	   otherwise our programming would be sloppy */
-
 	{
-	u32 DSCR = arm11_read_DSCR(arm11);
+		u32 DSCR = arm11_read_DSCR(arm11);
 
-	if (DSCR &amp; (ARM11_DSCR_RDTR_FULL | ARM11_DSCR_WDTR_FULL))
-	{
-		LOG_ERROR(&quot;wDTR/rDTR inconsistent (DSCR %08x)&quot;, DSCR);
+		if (DSCR &amp; (ARM11_DSCR_RDTR_FULL | ARM11_DSCR_WDTR_FULL))
+		{
+			LOG_ERROR(&quot;wDTR/rDTR inconsistent (DSCR %08x)&quot;, DSCR);
+		}
 	}
-	}
 
 	arm11_run_instr_data_prepare(arm11);
 
@@ -585,8 +586,8 @@
 
 	if ((R(DSCR) &amp; ARM11_DSCR_WDTR_FULL) || arm11-&gt;reg_list[ARM11_RC_WDTR].dirty)
 	{
-	/* MCR p14,0,R0,c0,c5,0 */
-	arm11_run_instr_data_to_core_via_r0(arm11, 0xee000e15, R(WDTR));
+		/* MCR p14,0,R0,c0,c5,0 */
+		arm11_run_instr_data_to_core_via_r0(arm11, 0xee000e15, R(WDTR));
 	}
 
 	/* restore CPSR */
@@ -614,20 +615,20 @@
 
 	if (R(DSCR) &amp; ARM11_DSCR_RDTR_FULL || arm11-&gt;reg_list[ARM11_RC_RDTR].dirty)
 	{
-	arm11_add_debug_SCAN_N(arm11, 0x05, TAP_INVALID);
+		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
-	arm11_add_IR(arm11, ARM11_EXTEST, TAP_INVALID);
+		arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
 
-	scan_field_t	chain5_fields[3];
+		scan_field_t	chain5_fields[3];
 
-	u8			Ready		= 0;	/* ignored */
-	u8			Valid		= 0;	/* ignored */
+		u8			Ready		= 0;	/* ignored */
+		u8			Valid		= 0;	/* ignored */
 
-	arm11_setup_field(arm11, 32, &amp;R(RDTR),	NULL, chain5_fields + 0);
-	arm11_setup_field(arm11,  1, &amp;Ready,	NULL, chain5_fields + 1);
-	arm11_setup_field(arm11,  1, &amp;Valid,	NULL, chain5_fields + 2);
+		arm11_setup_field(arm11, 32, &amp;R(RDTR),	NULL, chain5_fields + 0);
+		arm11_setup_field(arm11,  1, &amp;Ready,	NULL, chain5_fields + 1);
+		arm11_setup_field(arm11,  1, &amp;Valid,	NULL, chain5_fields + 2);
 
-	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 
 	arm11_record_register_history(arm11);
@@ -638,11 +639,11 @@
 	{size_t i;
 	for(i = 0; i &lt; ARM11_REGCACHE_COUNT; i++)
 	{
-	arm11-&gt;reg_history[i].value	= arm11-&gt;reg_values[i];
-	arm11-&gt;reg_history[i].valid	= arm11-&gt;reg_list[i].valid;
+		arm11-&gt;reg_history[i].value	= arm11-&gt;reg_values[i];
+		arm11-&gt;reg_history[i].valid	= arm11-&gt;reg_list[i].valid;
 
-	arm11-&gt;reg_list[i].valid	= 0;
-	arm11-&gt;reg_list[i].dirty	= 0;
+		arm11-&gt;reg_list[i].valid	= 0;
+		arm11-&gt;reg_list[i].dirty	= 0;
 	}}
 }
 
@@ -655,7 +656,7 @@
 	arm11_common_t * arm11 = target-&gt;arch_info;
 
 	if (arm11-&gt;trst_active)
-	return ERROR_OK;
+		return ERROR_OK;
 
 	u32	dscr = arm11_read_DSCR(arm11);
 
@@ -665,28 +666,28 @@
 
 	if (dscr &amp; ARM11_DSCR_CORE_HALTED)
 	{
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		enum target_state old_state = target-&gt;state;
+		if (target-&gt;state != TARGET_HALTED)
+		{
+			enum target_state old_state = target-&gt;state;
 
-		LOG_DEBUG(&quot;enter TARGET_HALTED&quot;);
-		target-&gt;state		= TARGET_HALTED;
-		target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(dscr);
-		arm11_on_enter_debug_state(arm11);
+			LOG_DEBUG(&quot;enter TARGET_HALTED&quot;);
+			target-&gt;state		= TARGET_HALTED;
+			target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(dscr);
+			arm11_on_enter_debug_state(arm11);
 
-		target_call_event_callbacks(target,
-		old_state == TARGET_DEBUG_RUNNING ? TARGET_EVENT_DEBUG_HALTED : TARGET_EVENT_HALTED);
+			target_call_event_callbacks(target,
+				old_state == TARGET_DEBUG_RUNNING ? TARGET_EVENT_DEBUG_HALTED : TARGET_EVENT_HALTED);
+		}
 	}
-	}
 	else
 	{
-	if (target-&gt;state != TARGET_RUNNING &amp;&amp; target-&gt;state != TARGET_DEBUG_RUNNING)
-	{
-		LOG_DEBUG(&quot;enter TARGET_RUNNING&quot;);
-		target-&gt;state		= TARGET_RUNNING;
-		target-&gt;debug_reason	= DBG_REASON_NOTHALTED;
+		if (target-&gt;state != TARGET_RUNNING &amp;&amp; target-&gt;state != TARGET_DEBUG_RUNNING)
+		{
+			LOG_DEBUG(&quot;enter TARGET_RUNNING&quot;);
+			target-&gt;state		= TARGET_RUNNING;
+			target-&gt;debug_reason	= DBG_REASON_NOTHALTED;
+		}
 	}
-	}
 
 	return ERROR_OK;
 }
@@ -716,11 +717,11 @@
 	arm11_common_t * arm11 = target-&gt;arch_info;
 
 	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
-		  Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
+		Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
 
 	if (target-&gt;state == TARGET_UNKNOWN)
 	{
-	arm11-&gt;simulate_reset_on_next_halt = true;
+		arm11-&gt;simulate_reset_on_next_halt = true;
 	}
 
 	if (target-&gt;state == TARGET_HALTED)
@@ -731,8 +732,8 @@
 
 	if (arm11-&gt;trst_active)
 	{
-	arm11-&gt;halt_requested = true;
-	return ERROR_OK;
+		arm11-&gt;halt_requested = true;
+		return ERROR_OK;
 	}
 
 	arm11_add_IR(arm11, ARM11_HALT, TAP_IDLE);
@@ -746,10 +747,10 @@
 
 	while (1)
 	{
-	dscr = arm11_read_DSCR(arm11);
+		dscr = arm11_read_DSCR(arm11);
 
-	if (dscr &amp; ARM11_DSCR_CORE_HALTED)
-		break;
+		if (dscr &amp; ARM11_DSCR_CORE_HALTED)
+			break;
 	}
 
 	arm11_on_enter_debug_state(arm11);
@@ -760,7 +761,7 @@
 	target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(dscr);
 
 	if((retval = target_call_event_callbacks(target,
-			old_state == TARGET_DEBUG_RUNNING ? TARGET_EVENT_DEBUG_HALTED : TARGET_EVENT_HALTED)) != ERROR_OK)
+		old_state == TARGET_DEBUG_RUNNING ? TARGET_EVENT_DEBUG_HALTED : TARGET_EVENT_HALTED)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -773,14 +774,14 @@
 	int retval = ERROR_OK;
 
 	FNC_INFO;
+	
+	//	  LOG_DEBUG(&quot;current %d  address %08x  handle_breakpoints %d  debug_execution %d&quot;,
+	//	current, address, handle_breakpoints, debug_execution);
 
-//	  LOG_DEBUG(&quot;current %d  address %08x  handle_breakpoints %d  debug_execution %d&quot;,
-//	current, address, handle_breakpoints, debug_execution);
-
 	arm11_common_t * arm11 = target-&gt;arch_info;
 
 	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
-		  Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
+		Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
 
 
 	if (target-&gt;state != TARGET_HALTED)
@@ -790,7 +791,7 @@
 	}
 
 	if (!current)
-	R(PC) = address;
+		R(PC) = address;
 
 	LOG_INFO(&quot;RESUME PC %08x%s&quot;, R(PC), !current ? &quot;!&quot; : &quot;&quot;);
 
@@ -800,43 +801,43 @@
 	/* Set up breakpoints */
 	if (!debug_execution)
 	{
-	/* check if one matches PC and step over it if necessary */
+		/* check if one matches PC and step over it if necessary */
 
-	breakpoint_t *	bp;
+		breakpoint_t *	bp;
 
-	for (bp = target-&gt;breakpoints; bp; bp = bp-&gt;next)
-	{
-		if (bp-&gt;address == R(PC))
+		for (bp = target-&gt;breakpoints; bp; bp = bp-&gt;next)
 		{
-		LOG_DEBUG(&quot;must step over %08x&quot;, bp-&gt;address);
-		arm11_step(target, 1, 0, 0);
-		break;
+			if (bp-&gt;address == R(PC))
+			{
+				LOG_DEBUG(&quot;must step over %08x&quot;, bp-&gt;address);
+				arm11_step(target, 1, 0, 0);
+				break;
+			}
 		}
-	}
 
-	/* set all breakpoints */
+		/* set all breakpoints */
 
-	size_t		brp_num = 0;
+		size_t		brp_num = 0;
 
-	for (bp = target-&gt;breakpoints; bp; bp = bp-&gt;next)
-	{
-		arm11_sc7_action_t	brp[2];
+		for (bp = target-&gt;breakpoints; bp; bp = bp-&gt;next)
+		{
+			arm11_sc7_action_t	brp[2];
 
-		brp[0].write	= 1;
-		brp[0].address	= ARM11_SC7_BVR0 + brp_num;
-		brp[0].value	= bp-&gt;address;
-		brp[1].write	= 1;
-		brp[1].address	= ARM11_SC7_BCR0 + brp_num;
-		brp[1].value	= 0x1 | (3 &lt;&lt; 1) | (0x0F &lt;&lt; 5) | (0 &lt;&lt; 14) | (0 &lt;&lt; 16) | (0 &lt;&lt; 20) | (0 &lt;&lt; 21);
+			brp[0].write	= 1;
+			brp[0].address	= ARM11_SC7_BVR0 + brp_num;
+			brp[0].value	= bp-&gt;address;
+			brp[1].write	= 1;
+			brp[1].address	= ARM11_SC7_BCR0 + brp_num;
+			brp[1].value	= 0x1 | (3 &lt;&lt; 1) | (0x0F &lt;&lt; 5) | (0 &lt;&lt; 14) | (0 &lt;&lt; 16) | (0 &lt;&lt; 20) | (0 &lt;&lt; 21);
 
-		arm11_sc7_run(arm11, brp, asizeof(brp));
+			arm11_sc7_run(arm11, brp, asizeof(brp));
 
-		LOG_DEBUG(&quot;Add BP &quot; ZU &quot; at %08x&quot;, brp_num, bp-&gt;address);
+			LOG_DEBUG(&quot;Add BP &quot; ZU &quot; at %08x&quot;, brp_num, bp-&gt;address);
 
-		brp_num++;
-	}
+			brp_num++;
+		}
 
-	arm11_sc7_set_vcr(arm11, arm11_vcr);
+		arm11_sc7_set_vcr(arm11, arm11_vcr);
 	}
 
 	arm11_leave_debug_state(arm11);
@@ -850,18 +851,19 @@
 
 	while (1)
 	{
-	u32 dscr = arm11_read_DSCR(arm11);
+		u32 dscr = arm11_read_DSCR(arm11);
 
-	LOG_DEBUG(&quot;DSCR %08x&quot;, dscr);
+		LOG_DEBUG(&quot;DSCR %08x&quot;, dscr);
 
-	if (dscr &amp; ARM11_DSCR_CORE_RESTARTED)
-		break;
+		if (dscr &amp; ARM11_DSCR_CORE_RESTARTED)
+			break;
 	}
 
 	if (!debug_execution)
 	{
-		target-&gt;state		= TARGET_RUNNING;
+		target-&gt;state			= TARGET_RUNNING;
 		target-&gt;debug_reason	= DBG_REASON_NOTHALTED;
+
 		if((retval = target_call_event_callbacks(target, TARGET_EVENT_RESUMED)) != ERROR_OK)
 		{
 			return retval;
@@ -869,7 +871,7 @@
 	}
 	else
 	{
-		target-&gt;state		= TARGET_DEBUG_RUNNING;
+		target-&gt;state			= TARGET_DEBUG_RUNNING;
 		target-&gt;debug_reason	= DBG_REASON_NOTHALTED;
 		if((retval = target_call_event_callbacks(target, TARGET_EVENT_RESUMED)) != ERROR_OK)
 		{
@@ -887,18 +889,18 @@
 	FNC_INFO;
 
 	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
-		  Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
+		Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
-	LOG_WARNING(&quot;target was not halted&quot;);
-	return ERROR_TARGET_NOT_HALTED;
+		LOG_WARNING(&quot;target was not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
 	}
 
 	arm11_common_t * arm11 = target-&gt;arch_info;
 
 	if (!current)
-	R(PC) = address;
+		R(PC) = address;
 
 	LOG_INFO(&quot;STEP PC %08x%s&quot;, R(PC), !current ? &quot;!&quot; : &quot;&quot;);
 
@@ -911,81 +913,92 @@
 	/* skip over BKPT */
 	if ((next_instruction &amp; 0xFFF00070) == 0xe1200070)
 	{
-	R(PC) += 4;
-	arm11-&gt;reg_list[ARM11_RC_PC].valid = 1;
-	arm11-&gt;reg_list[ARM11_RC_PC].dirty = 0;
-	LOG_INFO(&quot;Skipping BKPT&quot;);
+		R(PC) += 4;
+		arm11-&gt;reg_list[ARM11_RC_PC].valid = 1;
+		arm11-&gt;reg_list[ARM11_RC_PC].dirty = 0;
+		LOG_INFO(&quot;Skipping BKPT&quot;);
 	}
 	/* skip over Wait for interrupt / Standby */
 	/* mcr	15, 0, r?, cr7, cr0, {4} */
 	else if ((next_instruction &amp; 0xFFFF0FFF) == 0xee070f90)
 	{
-	R(PC) += 4;
-	arm11-&gt;reg_list[ARM11_RC_PC].valid = 1;
-	arm11-&gt;reg_list[ARM11_RC_PC].dirty = 0;
-	LOG_INFO(&quot;Skipping WFI&quot;);
+		R(PC) += 4;
+		arm11-&gt;reg_list[ARM11_RC_PC].valid = 1;
+		arm11-&gt;reg_list[ARM11_RC_PC].dirty = 0;
+		LOG_INFO(&quot;Skipping WFI&quot;);
 	}
 	/* ignore B to self */
 	else if ((next_instruction &amp; 0xFEFFFFFF) == 0xeafffffe)
 	{
-	LOG_INFO(&quot;Not stepping jump to self&quot;);
+		LOG_INFO(&quot;Not stepping jump to self&quot;);
 	}
 	else
 	{
-	/** \todo TODO: check if break-/watchpoints make any sense at all in combination
-	  * with this. */
+		/** \todo TODO: check if break-/watchpoints make any sense at all in combination
+		* with this. */
 
-	/** \todo TODO: check if disabling IRQs might be a good idea here. Alternatively
-	  * the VCR might be something worth looking into. */
+		/** \todo TODO: check if disabling IRQs might be a good idea here. Alternatively
+		* the VCR might be something worth looking into. */
 
 
-	/* Set up breakpoint for stepping */
+		/* Set up breakpoint for stepping */
 
-	arm11_sc7_action_t	brp[2];
+		arm11_sc7_action_t	brp[2];
 
-	brp[0].write	= 1;
-	brp[0].address	= ARM11_SC7_BVR0;
-	brp[0].value	= R(PC);
-	brp[1].write	= 1;
-	brp[1].address	= ARM11_SC7_BCR0;
-	brp[1].value	= 0x1 | (3 &lt;&lt; 1) | (0x0F &lt;&lt; 5) | (0 &lt;&lt; 14) | (0 &lt;&lt; 16) | (0 &lt;&lt; 20) | (2 &lt;&lt; 21);
+		brp[0].write	= 1;
+		brp[0].address	= ARM11_SC7_BVR0;
+		brp[0].value	= R(PC);
+		brp[1].write	= 1;
+		brp[1].address	= ARM11_SC7_BCR0;
+		brp[1].value	= 0x1 | (3 &lt;&lt; 1) | (0x0F &lt;&lt; 5) | (0 &lt;&lt; 14) | (0 &lt;&lt; 16) | (0 &lt;&lt; 20) | (2 &lt;&lt; 21);
 
-	arm11_sc7_run(arm11, brp, asizeof(brp));
+		arm11_sc7_run(arm11, brp, asizeof(brp));
 
-	/* resume */
+		/* resume */
 
-	arm11_leave_debug_state(arm11);
 
-	arm11_add_IR(arm11, ARM11_RESTART, TAP_IDLE);
+		if (arm11_config_step_irq_enable)
+			R(DSCR) &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;		/* should be redundant */
+		else
+			R(DSCR) |= ARM11_DSCR_INTERRUPTS_DISABLE;
+			
 
-	if((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		return retval;
-	}
+		arm11_leave_debug_state(arm11);
 
-	/** \todo TODO: add a timeout */
+		arm11_add_IR(arm11, ARM11_RESTART, TAP_IDLE);
 
-	/* wait for halt */
+		if((retval = jtag_execute_queue()) != ERROR_OK)
+		{
+			return retval;
+		}
 
-	while (1)
-	{
-		u32 dscr = arm11_read_DSCR(arm11);
+		/** \todo TODO: add a timeout */
 
-		LOG_DEBUG(&quot;DSCR %08x&quot;, dscr);
+		/* wait for halt */
 
-		if ((dscr &amp; (ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED)) ==
-		(ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED))
-		break;
-	}
+		while (1)
+		{
+			u32 dscr = arm11_read_DSCR(arm11);
 
-	/* clear breakpoint */
-	arm11_sc7_clear_vbw(arm11);
+			LOG_DEBUG(&quot;DSCR %08x&quot;, dscr);
 
-	/* save state */
-	arm11_on_enter_debug_state(arm11);
+			if ((dscr &amp; (ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED)) ==
+				(ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED))
+				break;
+		}
+
+		/* clear breakpoint */
+		arm11_sc7_clear_vbw(arm11);
+
+		/* save state */
+		arm11_on_enter_debug_state(arm11);
+
+	    /* restore default state */
+		R(DSCR) &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;
+
 	}
 
-//	  target-&gt;state		= TARGET_HALTED;
+	//	  target-&gt;state		= TARGET_HALTED;
 	target-&gt;debug_reason	= DBG_REASON_SINGLESTEP;
 
 	if((retval = target_call_event_callbacks(target, TARGET_EVENT_HALTED)) != ERROR_OK)
@@ -1028,7 +1041,7 @@
 
 #if 0
 	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
-		  Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
+		Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name );
 
 
 	/* deassert reset lines */
@@ -1038,7 +1051,7 @@
 	arm11-&gt;trst_active = false;
 
 	if (arm11-&gt;halt_requested)
-	return arm11_halt(target);
+		return arm11_halt(target);
 #endif
 
 	return ERROR_OK;
@@ -1064,7 +1077,7 @@
 	{size_t i;
 	for (i = 16; i &lt; 24; i++)
 	{
-	(*reg_list)[i] = &amp;arm11_gdb_dummy_fp_reg;
+		(*reg_list)[i] = &amp;arm11_gdb_dummy_fp_reg;
 	}}
 
 	(*reg_list)[24] = &amp;arm11_gdb_dummy_fps_reg;
@@ -1072,19 +1085,19 @@
 	{size_t i;
 	for (i = 0; i &lt; ARM11_REGCACHE_COUNT; i++)
 	{
-	if (arm11_reg_defs[i].gdb_num == -1)
-		continue;
+		if (arm11_reg_defs[i].gdb_num == -1)
+			continue;
 
-	(*reg_list)[arm11_reg_defs[i].gdb_num] = arm11-&gt;reg_list + i;
+		(*reg_list)[arm11_reg_defs[i].gdb_num] = arm11-&gt;reg_list + i;
 	}}
 
 	return ERROR_OK;
 }
 
 /* target memory access
-* size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
-* count: number of items of &lt;size&gt;
-*/
+ * size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
+ * count: number of items of &lt;size&gt;
+ */
 int arm11_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
 {
 	/** \todo TODO: check if buffer cast to u32* and u16* might cause alignment problems */
@@ -1093,8 +1106,8 @@
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
-	LOG_WARNING(&quot;target was not halted&quot;);
-	return ERROR_TARGET_NOT_HALTED;
+		LOG_WARNING(&quot;target was not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
 	}
 
 	LOG_DEBUG(&quot;ADDR %08x  SIZE %08x  COUNT %08x&quot;, address, size, count);
@@ -1109,52 +1122,58 @@
 	switch (size)
 	{
 	case 1:
-	/** \todo TODO: check if dirty is the right choice to force a rewrite on arm11_resume() */
-	arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
+		/** \todo TODO: check if dirty is the right choice to force a rewrite on arm11_resume() */
+		arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
 
-	{size_t i;
-	for (i = 0; i &lt; count; i++)
-	{
-		/* ldrb    r1, [r0], #1 */
-		arm11_run_instr_no_data1(arm11, 0xe4d01001);
+		{size_t i;
+		for (i = 0; i &lt; count; i++)
+		{
+			/* ldrb    r1, [r0], #1 */
+			/* ldrb    r1, [r0] */
+			arm11_run_instr_no_data1(arm11,
+					!arm11_config_memrw_no_increment ? 0xe4d01001 : 0xe5d01000);
 
-		u32 res;
-		/* MCR p14,0,R1,c0,c5,0 */
-		arm11_run_instr_data_from_core(arm11, 0xEE001E15, &amp;res, 1);
+			u32 res;
+			/* MCR p14,0,R1,c0,c5,0 */
+			arm11_run_instr_data_from_core(arm11, 0xEE001E15, &amp;res, 1);
 
-		*buffer++ = res;
-	}}
+			*buffer++ = res;
+		}}
 
-	break;
+		break;
 
 	case 2:
-	{
-	arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
+		{
+			arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
 
-	u16 * buf16 = (u16*)buffer;
+			u16 * buf16 = (u16*)buffer;
 
-	{size_t i;
-	for (i = 0; i &lt; count; i++)
-	{
-		/* ldrh    r1, [r0], #2 */
-		arm11_run_instr_no_data1(arm11, 0xe0d010b2);
+			{size_t i;
+			for (i = 0; i &lt; count; i++)
+			{
+				/* ldrh    r1, [r0], #2 */
+				arm11_run_instr_no_data1(arm11,
+					!arm11_config_memrw_no_increment ? 0xe0d010b2 : 0xe1d010b0);
 
-		u32 res;
+				u32 res;
 
-		/* MCR p14,0,R1,c0,c5,0 */
-		arm11_run_instr_data_from_core(arm11, 0xEE001E15, &amp;res, 1);
+				/* MCR p14,0,R1,c0,c5,0 */
+				arm11_run_instr_data_from_core(arm11, 0xEE001E15, &amp;res, 1);
 
-		*buf16++ = res;
-	}}
+				*buf16++ = res;
+			}}
 
-	break;
-	}
+			break;
+		}
 
 	case 4:
 
-	/* LDC p14,c5,[R0],#4 */
-	arm11_run_instr_data_from_core(arm11, 0xecb05e01, (u32 *)buffer, count);
-	break;
+		/* LDC p14,c5,[R0],#4 */
+		/* LDC p14,c5,[R0] */
+		arm11_run_instr_data_from_core(arm11,
+			(!arm11_config_memrw_no_increment ? 0xecb05e01 : 0xed905e00),
+			(u32 *)buffer, count);
+		break;
 	}
 
 	arm11_run_instr_data_finish(arm11);
@@ -1168,8 +1187,8 @@
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
-	LOG_WARNING(&quot;target was not halted&quot;);
-	return ERROR_TARGET_NOT_HALTED;
+		LOG_WARNING(&quot;target was not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
 	}
 
 	LOG_DEBUG(&quot;ADDR %08x  SIZE %08x  COUNT %08x&quot;, address, size, count);
@@ -1184,77 +1203,88 @@
 	switch (size)
 	{
 	case 1:
-	{
-	arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
+		{
+			arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
 
-	{size_t i;
-	for (i = 0; i &lt; count; i++)
-	{
-		/* MRC p14,0,r1,c0,c5,0 */
-		arm11_run_instr_data_to_core1(arm11, 0xee101e15, *buffer++);
+			{size_t i;
+			for (i = 0; i &lt; count; i++)
+			{
+				/* MRC p14,0,r1,c0,c5,0 */
+				arm11_run_instr_data_to_core1(arm11, 0xee101e15, *buffer++);
 
-		/* strb    r1, [r0], #1 */
-		arm11_run_instr_no_data1(arm11, 0xe4c01001);
-	}}
+				/* strb    r1, [r0], #1 */
+				/* strb    r1, [r0] */
+				arm11_run_instr_no_data1(arm11,
+					!arm11_config_memrw_no_increment ? 0xe4c01001 : 0xe5c01000);
+			}}
 
-	break;
-	}
+			break;
+		}
 
 	case 2:
-	{
-	arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
+		{
+			arm11-&gt;reg_list[ARM11_RC_R1].dirty = 1;
 
-	u16 * buf16 = (u16*)buffer;
+			u16 * buf16 = (u16*)buffer;
 
-	{size_t i;
-	for (i = 0; i &lt; count; i++)
-	{
-		/* MRC p14,0,r1,c0,c5,0 */
-		arm11_run_instr_data_to_core1(arm11, 0xee101e15, *buf16++);
+			{size_t i;
+			for (i = 0; i &lt; count; i++)
+			{
+				/* MRC p14,0,r1,c0,c5,0 */
+				arm11_run_instr_data_to_core1(arm11, 0xee101e15, *buf16++);
 
-		/* strh    r1, [r0], #2 */
-		arm11_run_instr_no_data1(arm11, 0xe0c010b2);
-	}}
+				/* strh    r1, [r0], #2 */
+				/* strh    r1, [r0] */
+				arm11_run_instr_no_data1(arm11,
+					!arm11_config_memrw_no_increment ? 0xe0c010b2 : 0xe1c010b0);
+			}}
 
-	break;
-	}
+			break;
+		}
 
 	case 4:
-	/** \todo TODO: check if buffer cast to u32* might cause alignment problems */
+		/** \todo TODO: check if buffer cast to u32* might cause alignment problems */
 
-	if (!arm11_config_memwrite_burst)
-	{
-		/* STC p14,c5,[R0],#4 */
-		arm11_run_instr_data_to_core(arm11, 0xeca05e01, (u32 *)buffer, count);
-	}
-	else
-	{
-		/* STC p14,c5,[R0],#4 */
-		arm11_run_instr_data_to_core_noack(arm11, 0xeca05e01, (u32 *)buffer, count);
-	}
+		if (!arm11_config_memwrite_burst)
+		{
+			/* STC p14,c5,[R0],#4 */
+			/* STC p14,c5,[R0]*/
+			arm11_run_instr_data_to_core(arm11,
+				(!arm11_config_memrw_no_increment ? 0xeca05e01 : 0xed805e00),
+				(u32 *)buffer, count);
+		}
+		else
+		{
+			/* STC p14,c5,[R0],#4 */
+			/* STC p14,c5,[R0]*/
+			arm11_run_instr_data_to_core_noack(arm11,
+				(!arm11_config_memrw_no_increment ? 0xeca05e01 : 0xed805e00),
+				(u32 *)buffer, count);
+		}
 
-	break;
+		break;
 	}
 
 #if 1
 	/* r0 verification */
+	if (!arm11_config_memrw_no_increment)
 	{
-	u32 r0;
+		u32 r0;
 
-	/* MCR p14,0,R0,c0,c5,0 */
-	arm11_run_instr_data_from_core(arm11, 0xEE000E15, &amp;r0, 1);
+		/* MCR p14,0,R0,c0,c5,0 */
+		arm11_run_instr_data_from_core(arm11, 0xEE000E15, &amp;r0, 1);
 
-	if (address + size * count != r0)
-	{
-		LOG_ERROR(&quot;Data transfer failed. (%d)&quot;, (r0 - address) - size * count);
+		if (address + size * count != r0)
+		{
+			LOG_ERROR(&quot;Data transfer failed. (%d)&quot;, (r0 - address) - size * count);
 
-		if (arm11_config_memwrite_burst)
-		LOG_ERROR(&quot;use 'arm11 memwrite burst disable' to disable fast burst mode&quot;);
+			if (arm11_config_memwrite_burst)
+				LOG_ERROR(&quot;use 'arm11 memwrite burst disable' to disable fast burst mode&quot;);
 
-		if (arm11_config_memwrite_error_fatal)
-			return ERROR_FAIL;
+			if (arm11_config_memwrite_error_fatal)
+				return ERROR_FAIL;
+		}
 	}
-	}
 #endif
 
 	arm11_run_instr_data_finish(arm11);
@@ -1270,8 +1300,8 @@
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
-	LOG_WARNING(&quot;target was not halted&quot;);
-	return ERROR_TARGET_NOT_HALTED;
+		LOG_WARNING(&quot;target was not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
 	}
 
 	return arm11_write_memory(target, address, 4, count, buffer);
@@ -1296,21 +1326,21 @@
 #if 0
 	if (breakpoint-&gt;type == BKPT_SOFT)
 	{
-	LOG_INFO(&quot;sw breakpoint requested, but software breakpoints not enabled&quot;);
-	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		LOG_INFO(&quot;sw breakpoint requested, but software breakpoints not enabled&quot;);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 #endif
 
 	if (!arm11-&gt;free_brps)
 	{
-	LOG_INFO(&quot;no breakpoint unit available for hardware breakpoint&quot;);
-	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		LOG_INFO(&quot;no breakpoint unit available for hardware breakpoint&quot;);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
 	if (breakpoint-&gt;length != 4)
 	{
-	LOG_INFO(&quot;only breakpoints of four bytes length supported&quot;);
-	return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		LOG_INFO(&quot;only breakpoints of four bytes length supported&quot;);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
 	arm11-&gt;free_brps--;
@@ -1552,7 +1582,6 @@
 {
 	/* Initialize anything we can set up without talking to the target */
 	return arm11_build_reg_cache(target);
-
 }
 
 /* talk to the target and set things up */
@@ -1565,7 +1594,7 @@
 
 	/* check IDCODE */
 
-	arm11_add_IR(arm11, ARM11_IDCODE, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_IDCODE, ARM11_TAP_DEFAULT);
 
 	scan_field_t		idcode_field;
 
@@ -1575,9 +1604,9 @@
 
 	/* check DIDR */
 
-	arm11_add_debug_SCAN_N(arm11, 0x00, TAP_INVALID);
+	arm11_add_debug_SCAN_N(arm11, 0x00, ARM11_TAP_DEFAULT);
 
-	arm11_add_IR(arm11, ARM11_INTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
 	scan_field_t		chain0_fields[2];
 
@@ -1605,13 +1634,12 @@
 	arm11-&gt;debug_version = (arm11-&gt;didr &gt;&gt; 16) &amp; 0x0F;
 
 	if (arm11-&gt;debug_version != ARM11_DEBUG_V6 &amp;&amp;
-	arm11-&gt;debug_version != ARM11_DEBUG_V61)
+		arm11-&gt;debug_version != ARM11_DEBUG_V61)
 	{
-	LOG_ERROR(&quot;Only ARMv6 v6 and v6.1 architectures supported.&quot;);
-	return ERROR_FAIL;
+		LOG_ERROR(&quot;Only ARMv6 v6 and v6.1 architectures supported.&quot;);
+		return ERROR_FAIL;
 	}
 
-
 	arm11-&gt;brp	= ((arm11-&gt;didr &gt;&gt; 24) &amp; 0x0F) + 1;
 	arm11-&gt;wrp	= ((arm11-&gt;didr &gt;&gt; 28) &amp; 0x0F) + 1;
 
@@ -1620,9 +1648,9 @@
 	arm11-&gt;free_wrps = arm11-&gt;wrp;
 
 	LOG_DEBUG(&quot;IDCODE %08x IMPLEMENTOR %02x DIDR %08x&quot;,
-	arm11-&gt;device_id,
-	arm11-&gt;implementor,
-	arm11-&gt;didr);
+		arm11-&gt;device_id,
+		arm11-&gt;implementor,
+		arm11-&gt;didr);
 
 	/* as a side-effect this reads DSCR and thus
 	 * clears the ARM11_DSCR_STICKY_PRECISE_DATA_ABORT / Sticky Precise Data Abort Flag
@@ -1652,8 +1680,8 @@
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
-	LOG_WARNING(&quot;target was not halted&quot;);
-	return ERROR_TARGET_NOT_HALTED;
+		LOG_WARNING(&quot;target was not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
 	}
 
 	/** \todo TODO: Check this. We assume that all registers are fetched at debug entry. */
@@ -1686,8 +1714,8 @@
 {
 	arm11_common_t *arm11 = target-&gt;arch_info;
 
-	NEW(reg_cache_t,		cache,			1);
-	NEW(reg_t,			reg_list,		ARM11_REGCACHE_COUNT);
+	NEW(reg_cache_t,		cache,				1);
+	NEW(reg_t,				reg_list,			ARM11_REGCACHE_COUNT);
 	NEW(arm11_reg_state_t,	arm11_reg_states,	ARM11_REGCACHE_COUNT);
 
 	if (arm11_regs_arch_type == -1)
@@ -1714,32 +1742,33 @@
 
 	/* Not very elegant assertion */
 	if (ARM11_REGCACHE_COUNT != asizeof(arm11-&gt;reg_values) ||
-	ARM11_REGCACHE_COUNT != asizeof(arm11_reg_defs) ||
-	ARM11_REGCACHE_COUNT != ARM11_RC_MAX)
+		ARM11_REGCACHE_COUNT != asizeof(arm11_reg_defs) ||
+		ARM11_REGCACHE_COUNT != ARM11_RC_MAX)
 	{
-	LOG_ERROR(&quot;BUG: arm11-&gt;reg_values inconsistent (%d &quot; ZU &quot; &quot; ZU &quot; %d)&quot;, ARM11_REGCACHE_COUNT, asizeof(arm11-&gt;reg_values), asizeof(arm11_reg_defs), ARM11_RC_MAX);
-	exit(-1);
+		LOG_ERROR(&quot;BUG: arm11-&gt;reg_values inconsistent (%d &quot; ZU &quot; &quot; ZU &quot; %d)&quot;, ARM11_REGCACHE_COUNT, asizeof(arm11-&gt;reg_values), asizeof(arm11_reg_defs), ARM11_RC_MAX);
+		exit(-1);
 	}
 
 	for (i = 0; i &lt; ARM11_REGCACHE_COUNT; i++)
 	{
-	reg_t *				r	= reg_list		+ i;
-	const arm11_reg_defs_t *	rd	= arm11_reg_defs	+ i;
-	arm11_reg_state_t *		rs	= arm11_reg_states	+ i;
+		reg_t *						r	= reg_list			+ i;
+		const arm11_reg_defs_t *	rd	= arm11_reg_defs	+ i;
+		arm11_reg_state_t *			rs	= arm11_reg_states	+ i;
 
-	r-&gt;name			= rd-&gt;name;
-	r-&gt;size			= 32;
-	r-&gt;value		= (u8 *)(arm11-&gt;reg_values + i);
-	r-&gt;dirty		= 0;
-	r-&gt;valid		= 0;
-	r-&gt;bitfield_desc	= NULL;
-	r-&gt;num_bitfields	= 0;
-	r-&gt;arch_type		= arm11_regs_arch_type;
-	r-&gt;arch_info		= rs;
+		r-&gt;name				= rd-&gt;name;
+		r-&gt;size				= 32;
+		r-&gt;value			= (u8 *)(arm11-&gt;reg_values + i);
+		r-&gt;dirty			= 0;
+		r-&gt;valid			= 0;
+		r-&gt;bitfield_desc	= NULL;
+		r-&gt;num_bitfields	= 0;
+		r-&gt;arch_type		= arm11_regs_arch_type;
+		r-&gt;arch_info		= rs;
 
-	rs-&gt;def_index		= i;
-	rs-&gt;target		= target;
+		rs-&gt;def_index		= i;
+		rs-&gt;target			= target;
 	}
+
 	return ERROR_OK;
 }
 
@@ -1747,12 +1776,12 @@
 {
 	if (argc == 0)
 	{
-	LOG_INFO(&quot;%s is %s.&quot;, name, *var ? &quot;enabled&quot; : &quot;disabled&quot;);
-	return ERROR_OK;
+		LOG_INFO(&quot;%s is %s.&quot;, name, *var ? &quot;enabled&quot; : &quot;disabled&quot;);
+		return ERROR_OK;
 	}
 
 	if (argc != 1)
-	return ERROR_COMMAND_SYNTAX_ERROR;
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	switch (args[0][0])
 	{
@@ -1761,16 +1790,16 @@
 	case 'F':
 	case 'd':	/* disable */
 	case 'D':
-	*var = false;
-	break;
+		*var = false;
+		break;
 
 	case '1':	/* 1 */
 	case 't':	/* true */
 	case 'T':
 	case 'e':	/* enable */
 	case 'E':
-	*var = true;
-	break;
+		*var = true;
+		break;
 	}
 
 	LOG_INFO(&quot;%s %s.&quot;, *var ? &quot;Enabled&quot; : &quot;Disabled&quot;, name);
@@ -1797,18 +1826,20 @@
 #define RC_FINAL_BOOL(name, descr, var)  \
 	register_command(cmd_ctx, top_cmd, name, arm11_handle_bool_##var, COMMAND_ANY, descr);
 
-BOOL_WRAPPER(memwrite_burst,		&quot;memory write burst mode&quot;)
-BOOL_WRAPPER(memwrite_error_fatal,	&quot;fatal error mode for memory writes&quot;)
+BOOL_WRAPPER(memwrite_burst,			&quot;memory write burst mode&quot;)
+BOOL_WRAPPER(memwrite_error_fatal,		&quot;fatal error mode for memory writes&quot;)
+BOOL_WRAPPER(memrw_no_increment,		&quot;\&quot;no increment\&quot; mode for memory transfers&quot;)
+BOOL_WRAPPER(step_irq_enable,			&quot;IRQs while stepping&quot;)
 
 int arm11_handle_vcr(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 1)
 	{
-	arm11_vcr = strtoul(args[0], NULL, 0);
+		arm11_vcr = strtoul(args[0], NULL, 0);
 	}
 	else if (argc != 0)
 	{
-	return ERROR_COMMAND_SYNTAX_ERROR;
+		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
 	LOG_INFO(&quot;VCR 0x%08X&quot;, arm11_vcr);
@@ -1817,11 +1848,11 @@
 
 const u32 arm11_coproc_instruction_limits[] =
 {
-	15,			/* coprocessor */
-	7,			/* opcode 1 */
-	15,			/* CRn */
-	15,			/* CRm */
-	7,			/* opcode 2 */
+	15,				/* coprocessor */
+	7,				/* opcode 1 */
+	15,				/* CRn */
+	15,				/* CRm */
+	7,				/* opcode 2 */
 	0xFFFFFFFF,		/* value */
 };
 
@@ -1830,22 +1861,24 @@
 
 arm11_common_t * arm11_find_target(const char * arg)
 {
-	jtag_tap_t *tap;
-	target_t * t;
+	jtag_tap_t *	tap;
+	target_t *		t;
 
-	tap = jtag_TapByString( arg );
-	if( !tap ){
-		return NULL;
+	tap = jtag_TapByString(arg);
+
+	if (!tap)
+		return 0;
+
+	for (t = all_targets; t; t = t-&gt;next)
+	{
+		if (t-&gt;tap != tap)
+			continue;
+
+		/* if (t-&gt;type == arm11_target) */
+		if (0 == strcmp(t-&gt;type-&gt;name, &quot;arm11&quot;))
+			return t-&gt;arch_info;
 	}
 
-	for (t = all_targets; t; t = t-&gt;next){
-		if( t-&gt;tap == tap ){
-			if( 0 == strcmp(t-&gt;type-&gt;name,&quot;arm11&quot;)){
-				arm11_common_t * arm11 = t-&gt;arch_info;
-				return arm11;
-			}
-		}
-	}
 	return 0;
 }
 
@@ -1853,25 +1886,24 @@
 {
 	if (argc != (read ? 6 : 7))
 	{
-	LOG_ERROR(&quot;Invalid number of arguments. %s&quot;, read ? arm11_mrc_syntax : arm11_mcr_syntax);
-	return -1;
+		LOG_ERROR(&quot;Invalid number of arguments. %s&quot;, read ? arm11_mrc_syntax : arm11_mcr_syntax);
+		return -1;
 	}
 
 	arm11_common_t * arm11 = arm11_find_target(args[0]);
 
 	if (!arm11)
 	{
-	LOG_ERROR(&quot;Parameter 1 is not a the JTAG chain position of an ARM11 device. %s&quot;,
-		read ? arm11_mrc_syntax : arm11_mcr_syntax);
+		LOG_ERROR(&quot;Parameter 1 is not a the JTAG chain position of an ARM11 device. %s&quot;,
+			read ? arm11_mrc_syntax : arm11_mcr_syntax);
 
-	return -1;
-
+		return -1;
 	}
 
 	if (arm11-&gt;target-&gt;state != TARGET_HALTED)
 	{
-	LOG_WARNING(&quot;target was not halted&quot;);
-	return ERROR_TARGET_NOT_HALTED;
+		LOG_WARNING(&quot;target was not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
 	}
 
 	u32	values[6];
@@ -1879,45 +1911,45 @@
 	{size_t i;
 	for (i = 0; i &lt; (read ? 5 : 6); i++)
 	{
-	values[i] = strtoul(args[i + 1], NULL, 0);
+		values[i] = strtoul(args[i + 1], NULL, 0);
 
-	if (values[i] &gt; arm11_coproc_instruction_limits[i])
-	{
-		LOG_ERROR(&quot;Parameter %ld out of bounds (%d max). %s&quot;,
-			  (long)(i + 2), arm11_coproc_instruction_limits[i],
-		read ? arm11_mrc_syntax : arm11_mcr_syntax);
-		return -1;
-	}
+		if (values[i] &gt; arm11_coproc_instruction_limits[i])
+		{
+			LOG_ERROR(&quot;Parameter %ld out of bounds (%d max). %s&quot;,
+				(long)(i + 2), arm11_coproc_instruction_limits[i],
+				read ? arm11_mrc_syntax : arm11_mcr_syntax);
+			return -1;
+		}
 	}}
 
 	u32 instr = 0xEE000010	|
-	(values[0] &lt;&lt;  8) |
-	(values[1] &lt;&lt; 21) |
-	(values[2] &lt;&lt; 16) |
-	(values[3] &lt;&lt;  0) |
-	(values[4] &lt;&lt;  5);
+		(values[0] &lt;&lt;  8) |
+		(values[1] &lt;&lt; 21) |
+		(values[2] &lt;&lt; 16) |
+		(values[3] &lt;&lt;  0) |
+		(values[4] &lt;&lt;  5);
 
 	if (read)
-	instr |= 0x00100000;
+		instr |= 0x00100000;
 
 	arm11_run_instr_data_prepare(arm11);
 
 	if (read)
 	{
-	u32 result;
-	arm11_run_instr_data_from_core_via_r0(arm11, instr, &amp;result);
+		u32 result;
+		arm11_run_instr_data_from_core_via_r0(arm11, instr, &amp;result);
 
-	LOG_INFO(&quot;MRC p%d, %d, R0, c%d, c%d, %d = 0x%08x (%d)&quot;,
-		values[0], values[1], values[2], values[3], values[4], result, result);
+		LOG_INFO(&quot;MRC p%d, %d, R0, c%d, c%d, %d = 0x%08x (%d)&quot;,
+			values[0], values[1], values[2], values[3], values[4], result, result);
 	}
 	else
 	{
-	arm11_run_instr_data_to_core_via_r0(arm11, instr, values[5]);
+		arm11_run_instr_data_to_core_via_r0(arm11, instr, values[5]);
 
-	LOG_INFO(&quot;MRC p%d, %d, R0 (#0x%08x), c%d, c%d, %d&quot;,
-		values[0], values[1],
-		values[5],
-		values[2], values[3], values[4]);
+		LOG_INFO(&quot;MRC p%d, %d, R0 (#0x%08x), c%d, c%d, %d&quot;,
+			values[0], values[1],
+			values[5],
+			values[2], values[3], values[4]);
 	}
 
 	arm11_run_instr_data_finish(arm11);
@@ -1942,25 +1974,30 @@
 
 	command_t * top_cmd = NULL;
 
-	RC_TOP(			&quot;arm11&quot;,	&quot;arm11 specific commands&quot;,
+	RC_TOP(				&quot;arm11&quot;,				&quot;arm11 specific commands&quot;,
 
-	RC_TOP(			&quot;memwrite&quot;,	&quot;Control memory write transfer mode&quot;,
+	RC_TOP(				&quot;memwrite&quot;,				&quot;Control memory write transfer mode&quot;,
 
-		RC_FINAL_BOOL(	&quot;burst&quot;,	&quot;Enable/Disable non-standard but fast burst mode (default: enabled)&quot;,
+		RC_FINAL_BOOL(	&quot;burst&quot;,				&quot;Enable/Disable non-standard but fast burst mode (default: enabled)&quot;,
 						memwrite_burst)
 
-		RC_FINAL_BOOL(	&quot;error_fatal&quot;,
-						&quot;Terminate program if transfer error was found (default: enabled)&quot;,
+		RC_FINAL_BOOL(	&quot;error_fatal&quot;,			&quot;Terminate program if transfer error was found (default: enabled)&quot;,
 						memwrite_error_fatal)
 	)
 
-	RC_FINAL(		&quot;vcr&quot;,		&quot;Control (Interrupt) Vector Catch Register&quot;,
+	RC_FINAL_BOOL(		&quot;no_increment&quot;,			&quot;Don't increment address on multi-read/-write (default: disabled)&quot;,
+						memrw_no_increment)
+						
+	RC_FINAL_BOOL(		&quot;step_irq_enable&quot;,		&quot;Enable interrupts while stepping (default: disabled)&quot;,
+						step_irq_enable)
+
+	RC_FINAL(			&quot;vcr&quot;,					&quot;Control (Interrupt) Vector Catch Register&quot;,
 						arm11_handle_vcr)
 
-	RC_FINAL(		&quot;mrc&quot;,		&quot;Read Coprocessor register&quot;,
+	RC_FINAL(			&quot;mrc&quot;,					&quot;Read Coprocessor register&quot;,
 						arm11_handle_mrc)
 
-	RC_FINAL(		&quot;mcr&quot;,		&quot;Write Coprocessor register&quot;,
+	RC_FINAL(			&quot;mcr&quot;,					&quot;Write Coprocessor register&quot;,
 						arm11_handle_mcr)
 	)
 

Modified: trunk/src/target/arm11.h
===================================================================
--- trunk/src/target/arm11.h	2009-04-22 17:36:00 UTC (rev 1511)
+++ trunk/src/target/arm11.h	2009-04-22 18:39:59 UTC (rev 1512)
@@ -45,9 +45,12 @@
 #define ARM11_REGCACHE_FREGS		0
 
 #define ARM11_REGCACHE_COUNT		(20 +					\
-					 23 * ARM11_REGCACHE_MODEREGS +		\
+					 23 * ARM11_REGCACHE_MODEREGS +			\
 					  9 * ARM11_REGCACHE_FREGS)
 
+#define ARM11_TAP_DEFAULT			TAP_INVALID
+
+
 typedef struct arm11_register_history_s
 {
 	u32		value;
@@ -56,17 +59,17 @@
 
 enum arm11_debug_version
 {
-	ARM11_DEBUG_V6	= 0x01,
-	ARM11_DEBUG_V61	= 0x02,
-	ARM11_DEBUG_V7	= 0x03,
-	ARM11_DEBUG_V7_CP14	= 0x04,
+	ARM11_DEBUG_V6			= 0x01,
+	ARM11_DEBUG_V61			= 0x02,
+	ARM11_DEBUG_V7			= 0x03,
+	ARM11_DEBUG_V7_CP14		= 0x04,
 };
 
 typedef struct arm11_common_s
 {
-	target_t *	target;
+	target_t *	target;		/**&lt; Reference back to the owner */
 
-	arm_jtag_t	jtag_info;
+	arm_jtag_t	jtag_info;	/**&lt; Handler to access assigned JTAG device */
 
 	/** \name Processor type detection */
 	/*@{*/
@@ -83,11 +86,13 @@
 	/*@}*/
 
 	u32		last_dscr;		/**&lt; Last retrieved DSCR value;
-							 * Can be used to detect changes		*/
+							     Use only for debug message generation		*/
 
 	bool	trst_active;
-	bool	halt_requested;
-	bool	simulate_reset_on_next_halt;
+	bool	halt_requested;					/**&lt; Keep track if arm11_halt() calls occured
+												 during reset. Otherwise do it ASAP. */
+												 
+	bool	simulate_reset_on_next_halt;	/**&lt; Perform cleanups of the ARM state on next halt */
 
 	/** \name Shadow registers to save processor state */
 	/*@{*/
@@ -127,23 +132,24 @@
 
 enum arm11_dscr
 {
-	ARM11_DSCR_CORE_HALTED				= 1 &lt;&lt; 0,
-	ARM11_DSCR_CORE_RESTARTED				= 1 &lt;&lt; 1,
+	ARM11_DSCR_CORE_HALTED									= 1 &lt;&lt; 0,
+	ARM11_DSCR_CORE_RESTARTED								= 1 &lt;&lt; 1,
 
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK		= 0x0F &lt;&lt; 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_HALT		= 0x00 &lt;&lt; 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BREAKPOINT		= 0x01 &lt;&lt; 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_WATCHPOINT		= 0x02 &lt;&lt; 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BKPT_INSTRUCTION	= 0x03 &lt;&lt; 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_EDBGRQ		= 0x04 &lt;&lt; 2,
-	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_VECTOR_CATCH	= 0x05 &lt;&lt; 2,
+	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK					= 0x0F &lt;&lt; 2,
+	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_HALT					= 0x00 &lt;&lt; 2,
+	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BREAKPOINT				= 0x01 &lt;&lt; 2,
+	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_WATCHPOINT				= 0x02 &lt;&lt; 2,
+	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BKPT_INSTRUCTION		= 0x03 &lt;&lt; 2,
+	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_EDBGRQ					= 0x04 &lt;&lt; 2,
+	ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_VECTOR_CATCH			= 0x05 &lt;&lt; 2,
 
-	ARM11_DSCR_STICKY_PRECISE_DATA_ABORT		= 1 &lt;&lt; 6,
-	ARM11_DSCR_STICKY_IMPRECISE_DATA_ABORT		= 1 &lt;&lt; 7,
-	ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE		= 1 &lt;&lt; 13,
-	ARM11_DSCR_MODE_SELECT				= 1 &lt;&lt; 14,
-	ARM11_DSCR_WDTR_FULL				= 1 &lt;&lt; 29,
-	ARM11_DSCR_RDTR_FULL				= 1 &lt;&lt; 30,
+	ARM11_DSCR_STICKY_PRECISE_DATA_ABORT					= 1 &lt;&lt; 6,
+	ARM11_DSCR_STICKY_IMPRECISE_DATA_ABORT					= 1 &lt;&lt; 7,
+	ARM11_DSCR_INTERRUPTS_DISABLE							= 1 &lt;&lt; 11,
+	ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE				= 1 &lt;&lt; 13,
+	ARM11_DSCR_MODE_SELECT									= 1 &lt;&lt; 14,
+	ARM11_DSCR_WDTR_FULL									= 1 &lt;&lt; 29,
+	ARM11_DSCR_RDTR_FULL									= 1 &lt;&lt; 30,
 };
 
 enum arm11_cpsr
@@ -229,23 +235,23 @@
 
 /* internals */
 
-void arm11_setup_field		(arm11_common_t * arm11, int num_bits, void * in_data, void * out_data, scan_field_t * field);
-void arm11_add_IR		(arm11_common_t * arm11, u8 instr, tap_state_t state);
-void arm11_add_debug_SCAN_N	(arm11_common_t * arm11, u8 chain, tap_state_t state);
-void arm11_add_debug_INST	(arm11_common_t * arm11, u32 inst, u8 * flag, tap_state_t state);
-u32  arm11_read_DSCR		(arm11_common_t * arm11);
-void arm11_write_DSCR		(arm11_common_t * arm11, u32 dscr);
+void arm11_setup_field			(arm11_common_t * arm11, int num_bits, void * in_data, void * out_data, scan_field_t * field);
+void arm11_add_IR				(arm11_common_t * arm11, u8 instr, tap_state_t state);
+void arm11_add_debug_SCAN_N		(arm11_common_t * arm11, u8 chain, tap_state_t state);
+void arm11_add_debug_INST		(arm11_common_t * arm11, u32 inst, u8 * flag, tap_state_t state);
+u32  arm11_read_DSCR			(arm11_common_t * arm11);
+void arm11_write_DSCR			(arm11_common_t * arm11, u32 dscr);
 
 enum target_debug_reason arm11_get_DSCR_debug_reason(u32 dscr);
 
-void arm11_run_instr_data_prepare		(arm11_common_t * arm11);
-void arm11_run_instr_data_finish		(arm11_common_t * arm11);
-void arm11_run_instr_no_data			(arm11_common_t * arm11, u32 * opcode, size_t count);
-void arm11_run_instr_no_data1			(arm11_common_t * arm11, u32 opcode);
-void arm11_run_instr_data_to_core		(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
+void arm11_run_instr_data_prepare			(arm11_common_t * arm11);
+void arm11_run_instr_data_finish			(arm11_common_t * arm11);
+void arm11_run_instr_no_data				(arm11_common_t * arm11, u32 * opcode, size_t count);
+void arm11_run_instr_no_data1				(arm11_common_t * arm11, u32 opcode);
+void arm11_run_instr_data_to_core			(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
 void arm11_run_instr_data_to_core_noack		(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
-void arm11_run_instr_data_to_core1		(arm11_common_t * arm11, u32 opcode, u32 data);
-void arm11_run_instr_data_from_core		(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
+void arm11_run_instr_data_to_core1			(arm11_common_t * arm11, u32 opcode, u32 data);
+void arm11_run_instr_data_from_core			(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
 void arm11_run_instr_data_from_core_via_r0	(arm11_common_t * arm11, u32 opcode, u32 * data);
 void arm11_run_instr_data_to_core_via_r0	(arm11_common_t * arm11, u32 opcode, u32 data);
 
@@ -259,10 +265,10 @@
 typedef struct arm11_sc7_action_s
 {
 	bool	write;				/**&lt; Access mode: true for write, false for read.	*/
-	u8		address;				/**&lt; Register address mode. Use enum #arm11_sc7		*/
+	u8		address;			/**&lt; Register address mode. Use enum #arm11_sc7		*/
 	u32		value;				/**&lt; If write then set this to value to be written.
-								In read mode this receives the read value when the
-								function returns.					*/
+									 In read mode this receives the read value when the
+									 function returns.					*/
 } arm11_sc7_action_t;
 
 void arm11_sc7_run(arm11_common_t * arm11, arm11_sc7_action_t * actions, size_t count);

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-04-22 17:36:00 UTC (rev 1511)
+++ trunk/src/target/arm11_dbgtap.c	2009-04-22 18:39:59 UTC (rev 1512)
@@ -44,83 +44,79 @@
 
 int arm11_add_ir_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state)
 {
-    if (cmd_queue_cur_state == TAP_IRPAUSE)
-	jtag_add_pathmove(asizeof(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
+	if (cmd_queue_cur_state == TAP_IRPAUSE)
+		jtag_add_pathmove(asizeof(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
-    jtag_add_ir_scan(num_fields, fields, state);
-    return ERROR_OK;
+	jtag_add_ir_scan(num_fields, fields, state);
+	return ERROR_OK;
 }
 
 tap_state_t arm11_move_pd_to_sd_via_cd[] =
 {
-    TAP_DREXIT2, TAP_DRUPDATE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+	TAP_DREXIT2, TAP_DRUPDATE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };
 
 int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state)
 {
-    if (cmd_queue_cur_state == TAP_DRPAUSE)
-	jtag_add_pathmove(asizeof(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
+	if (cmd_queue_cur_state == TAP_DRPAUSE)
+		jtag_add_pathmove(asizeof(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
 
-    jtag_add_dr_scan(num_fields, fields, state);
-    return ERROR_OK;
+	jtag_add_dr_scan(num_fields, fields, state);
+	return ERROR_OK;
 }
 
 
 /** Code de-clutter: Construct scan_field_t to write out a value
  *
- * \param arm11		Target state variable.
- * \param num_bits	Length of the data field
- * \param out_data	pointer to the data that will be sent out
- *			&lt;em&gt;(data is read when it is added to the JTAG queue)&lt;/em&gt;
- * \param in_data	pointer to the memory that will receive data that was clocked in
- *			&lt;em&gt;(data is written when the JTAG queue is executed)&lt;/em&gt;
- * \param field target data structure that will be initialized
+ * \param arm11			Target state variable.
+ * \param num_bits		Length of the data field
+ * \param out_data		pointer to the data that will be sent out
+ *						&lt;em&gt;(data is read when it is added to the JTAG queue)&lt;/em&gt;
+ * \param in_data		pointer to the memory that will receive data that was clocked in
+ *						&lt;em&gt;(data is written when the JTAG queue is executed)&lt;/em&gt;
+ * \param field			target data structure that will be initialized
  */
 void arm11_setup_field(arm11_common_t * arm11, int num_bits, void * out_data, void * in_data, scan_field_t * field)
 {
-    field-&gt;tap   		= arm11-&gt;jtag_info.tap;
-    field-&gt;num_bits		= num_bits;
-    field-&gt;out_mask		= NULL;
-    field-&gt;in_check_mask	= NULL;
-    field-&gt;in_check_value	= NULL;
-    field-&gt;in_handler		= NULL;
-    field-&gt;in_handler_priv	= NULL;
+	field-&gt;tap   			= arm11-&gt;jtag_info.tap;
+	field-&gt;num_bits			= num_bits;
+	field-&gt;out_mask			= NULL;
+	field-&gt;in_check_mask	= NULL;
+	field-&gt;in_check_value	= NULL;
+	field-&gt;in_handler		= NULL;
+	field-&gt;in_handler_priv	= NULL;
 
-    field-&gt;out_value		= out_data;
-    field-&gt;in_value		= in_data;
+	field-&gt;out_value		= out_data;
+	field-&gt;in_value			= in_data;
 }
 
 
 /** Write JTAG instruction register
  *
- * \param arm11 Target state variable.
- * \param instr An ARM11 DBGTAP instruction. Use enum #arm11_instructions.
- * \param state Pass the final TAP state or TAP_INVALID for the default value (Pause-IR).
+ * \param arm11		Target state variable.
+ * \param instr		An ARM11 DBGTAP instruction. Use enum #arm11_instructions.
+ * \param state		Pass the final TAP state or ARM11_TAP_DEFAULT for the default value (Pause-IR).
  *
- * \remarks This adds to the JTAG command queue but does \em not execute it.
+ * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
 void arm11_add_IR(arm11_common_t * arm11, u8 instr, tap_state_t state)
 {
 	jtag_tap_t *tap;
 	tap = arm11-&gt;jtag_info.tap;
-	if(  tap == NULL ){
-	/* FIX!!!! error is logged, but not propagated back up the call stack... */
-		LOG_ERROR( &quot;tap is null here! This is bad!&quot;);
-		return;
-    }
 
-    if (buf_get_u32(tap-&gt;cur_instr, 0, 5) == instr){
+	if (buf_get_u32(tap-&gt;cur_instr, 0, 5) == instr)
+	{
 		JTAG_DEBUG(&quot;IR &lt;= 0x%02x SKIPPED&quot;, instr);
 		return;
-    }
+	}
 
-    JTAG_DEBUG(&quot;IR &lt;= 0x%02x&quot;, instr);
+	JTAG_DEBUG(&quot;IR &lt;= 0x%02x&quot;, instr);
 
-    scan_field_t field;
+	scan_field_t field;
 
-    arm11_setup_field(arm11, 5, &amp;instr, NULL, &amp;field);
+	arm11_setup_field(arm11, 5, &amp;instr, NULL, &amp;field);
 
-    arm11_add_ir_scan_vc(1, &amp;field, state == TAP_INVALID ? TAP_IRPAUSE : state);
+	arm11_add_ir_scan_vc(1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
 }
 
 /** Verify shifted out data from Scan Chain Register (SCREG)
@@ -130,17 +126,17 @@
  */
 static int arm11_in_handler_SCAN_N(u8 *in_value, void *priv, struct scan_field_s *field)
 {
-    /** \todo TODO: clarify why this isnt properly masked in jtag.c jtag_read_buffer() */
-    u8 v = *in_value &amp; 0x1F;
+	/** \todo TODO: clarify why this isnt properly masked in jtag.c jtag_read_buffer() */
+	u8 v = *in_value &amp; 0x1F;
 
-    if (v != 0x10)
-    {
-	LOG_ERROR(&quot;'arm11 target' JTAG communication error SCREG SCAN OUT 0x%02x (expected 0x10)&quot;, v);
-	return ERROR_FAIL;
-    }
+	if (v != 0x10)
+	{
+		LOG_ERROR(&quot;'arm11 target' JTAG communication error SCREG SCAN OUT 0x%02x (expected 0x10)&quot;, v);
+		return ERROR_FAIL;
+	}
 
-    JTAG_DEBUG(&quot;SCREG SCAN OUT 0x%02x&quot;, v);
-    return ERROR_OK;
+	JTAG_DEBUG(&quot;SCREG SCAN OUT 0x%02x&quot;, v);
+	return ERROR_OK;
 }
 
 /** Select and write to Scan Chain Register (SCREG)
@@ -152,165 +148,165 @@
  *
  * \param arm11	    Target state variable.
  * \param chain	    Scan chain that will be selected.
- * \param state	    Pass the final TAP state or TAP_INVALID for the default
- *		    value (Pause-DR).
+ * \param state	    Pass the final TAP state or ARM11_TAP_DEFAULT for the default
+ *					value (Pause-DR).
  *
  * The chain takes effect when Update-DR is passed (usually when subsequently
  * the INTEXT/EXTEST instructions are written).
  *
- * \warning (Obsolete) Using this twice in a row will \em fail. The first call will end
- *          in Pause-DR. The second call, due to the IR caching, will not
- *	    go through Capture-DR when shifting in the new scan chain number.
- *	    As a result the verification in arm11_in_handler_SCAN_N() must
- *	    fail.
+ * \warning			(Obsolete) Using this twice in a row will \em fail. The first
+ *					call will end in Pause-DR. The second call, due to the IR
+ *					caching, will not go through Capture-DR when shifting in the
+ *					new scan chain number. As a result the verification in
+ *					arm11_in_handler_SCAN_N() must fail.
  *
- * \remarks This adds to the JTAG command queue but does \em not execute it.
+ * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
 
 void arm11_add_debug_SCAN_N(arm11_common_t * arm11, u8 chain, tap_state_t state)
 {
-    JTAG_DEBUG(&quot;SCREG &lt;= 0x%02x&quot;, chain);
+	JTAG_DEBUG(&quot;SCREG &lt;= 0x%02x&quot;, chain);
 
-    arm11_add_IR(arm11, ARM11_SCAN_N, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_SCAN_N, ARM11_TAP_DEFAULT);
 
-    scan_field_t		field;
+	scan_field_t		field;
 
-    arm11_setup_field(arm11, 5, &amp;chain, NULL, &amp;field);
+	arm11_setup_field(arm11, 5, &amp;chain, NULL, &amp;field);
 
-    field.in_handler = arm11_in_handler_SCAN_N;
+	field.in_handler = arm11_in_handler_SCAN_N;
 
-    arm11_add_dr_scan_vc(1, &amp;field, state == TAP_INVALID ? TAP_DRPAUSE : state);
+	arm11_add_dr_scan_vc(1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_DRPAUSE : state);
 }
 
 /** Write an instruction into the ITR register
  *
- * \param arm11	Target state variable.
- * \param inst	An ARM11 processor instruction/opcode.
- * \param flag	Optional parameter to retrieve the InstCompl flag
- *		(this will be written when the JTAG chain is executed).
- * \param state	Pass the final TAP state or TAP_INVALID for the default
- *		value (Run-Test/Idle).
+ * \param arm11		Target state variable.
+ * \param inst		An ARM11 processor instruction/opcode.
+ * \param flag		Optional parameter to retrieve the InstCompl flag
+ *					(this will be written when the JTAG chain is executed).
+ * \param state		Pass the final TAP state or ARM11_TAP_DEFAULT for the default
+ *					value (Run-Test/Idle).
  *
- * \remarks By default this ends with Run-Test/Idle state
- * and causes the instruction to be executed. If
- * a subsequent write to DTR is needed before
- * executing the instruction then TAP_DRPAUSE should be
- * passed to \p state.
+ * \remarks			By default this ends with Run-Test/Idle state
+ *					and causes the instruction to be executed. If
+ *					a subsequent write to DTR is needed before
+ *					executing the instruction then TAP_DRPAUSE should be
+ *					passed to \p state.
  *
- * \remarks This adds to the JTAG command queue but does \em not execute it.
+ * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
 void arm11_add_debug_INST(arm11_common_t * arm11, u32 inst, u8 * flag, tap_state_t state)
 {
-    JTAG_DEBUG(&quot;INST &lt;= 0x%08x&quot;, inst);
+	JTAG_DEBUG(&quot;INST &lt;= 0x%08x&quot;, inst);
 
-    scan_field_t		itr[2];
+	scan_field_t		itr[2];
 
-    arm11_setup_field(arm11, 32,    &amp;inst,	NULL, itr + 0);
-    arm11_setup_field(arm11, 1,	    NULL,	flag, itr + 1);
+	arm11_setup_field(arm11, 32,    &amp;inst,	NULL, itr + 0);
+	arm11_setup_field(arm11, 1,	    NULL,	flag, itr + 1);
 
-    arm11_add_dr_scan_vc(asizeof(itr), itr, state == TAP_INVALID ? TAP_IDLE : state);
+	arm11_add_dr_scan_vc(asizeof(itr), itr, state == ARM11_TAP_DEFAULT ? TAP_IDLE : state);
 }
 
 /** Read the Debug Status and Control Register (DSCR)
  *
  * same as CP14 c1
  *
- * \param arm11 Target state variable.
- * \return DSCR content
+ * \param arm11		Target state variable.
+ * \return			DSCR content
  *
- * \remarks This is a stand-alone function that executes the JTAG command queue.
+ * \remarks			This is a stand-alone function that executes the JTAG command queue.
  */
 u32 arm11_read_DSCR(arm11_common_t * arm11)
 {
-    arm11_add_debug_SCAN_N(arm11, 0x01, TAP_INVALID);
+	arm11_add_debug_SCAN_N(arm11, 0x01, ARM11_TAP_DEFAULT);
 
-    arm11_add_IR(arm11, ARM11_INTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
-    u32			dscr;
-    scan_field_t	chain1_field;
+	u32				dscr;
+	scan_field_t	chain1_field;
 
-    arm11_setup_field(arm11, 32, NULL, &amp;dscr, &amp;chain1_field);
+	arm11_setup_field(arm11, 32, NULL, &amp;dscr, &amp;chain1_field);
 
-    arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
 
-    jtag_execute_queue();
+	jtag_execute_queue();
 
-    if (arm11-&gt;last_dscr != dscr)
-	JTAG_DEBUG(&quot;DSCR  = %08x (OLD %08x)&quot;, dscr, arm11-&gt;last_dscr);
+	if (arm11-&gt;last_dscr != dscr)
+		JTAG_DEBUG(&quot;DSCR  = %08x (OLD %08x)&quot;, dscr, arm11-&gt;last_dscr);
 
-    arm11-&gt;last_dscr = dscr;
+	arm11-&gt;last_dscr = dscr;
 
-    return dscr;
+	return dscr;
 }
 
 /** Write the Debug Status and Control Register (DSCR)
  *
  * same as CP14 c1
  *
- * \param arm11 Target state variable.
- * \param dscr DSCR content
+ * \param arm11		Target state variable.
+ * \param dscr		DSCR content
  *
- * \remarks This is a stand-alone function that executes the JTAG command queue.
+ * \remarks			This is a stand-alone function that executes the JTAG command queue.
  */
 void arm11_write_DSCR(arm11_common_t * arm11, u32 dscr)
 {
-    arm11_add_debug_SCAN_N(arm11, 0x01, TAP_INVALID);
+	arm11_add_debug_SCAN_N(arm11, 0x01, ARM11_TAP_DEFAULT);
 
-    arm11_add_IR(arm11, ARM11_EXTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
 
-    scan_field_t		    chain1_field;
+	scan_field_t		    chain1_field;
 
-    arm11_setup_field(arm11, 32, &amp;dscr, NULL, &amp;chain1_field);
+	arm11_setup_field(arm11, 32, &amp;dscr, NULL, &amp;chain1_field);
 
-    arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
 
-    jtag_execute_queue();
+	jtag_execute_queue();
 
-    JTAG_DEBUG(&quot;DSCR &lt;= %08x (OLD %08x)&quot;, dscr, arm11-&gt;last_dscr);
+	JTAG_DEBUG(&quot;DSCR &lt;= %08x (OLD %08x)&quot;, dscr, arm11-&gt;last_dscr);
 
-    arm11-&gt;last_dscr = dscr;
+	arm11-&gt;last_dscr = dscr;
 }
 
 
 
 /** Get the debug reason from Debug Status and Control Register (DSCR)
  *
- * \param dscr DSCR value to analyze
- * \return Debug reason
+ * \param dscr		DSCR value to analyze
+ * \return			Debug reason
  *
  */
 enum target_debug_reason arm11_get_DSCR_debug_reason(u32 dscr)
 {
-    switch (dscr &amp; ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK)
-    {
-    case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_HALT:
-	LOG_INFO(&quot;Debug entry: JTAG HALT&quot;);
-	return DBG_REASON_DBGRQ;
+	switch (dscr &amp; ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK)
+	{
+	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_HALT:
+		LOG_INFO(&quot;Debug entry: JTAG HALT&quot;);
+		return DBG_REASON_DBGRQ;
 
-    case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BREAKPOINT:
-	LOG_INFO(&quot;Debug entry: breakpoint&quot;);
-	return DBG_REASON_BREAKPOINT;
+	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BREAKPOINT:
+		LOG_INFO(&quot;Debug entry: breakpoint&quot;);
+		return DBG_REASON_BREAKPOINT;
 
-    case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_WATCHPOINT:
-	LOG_INFO(&quot;Debug entry: watchpoint&quot;);
-	return DBG_REASON_WATCHPOINT;
+	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_WATCHPOINT:
+		LOG_INFO(&quot;Debug entry: watchpoint&quot;);
+		return DBG_REASON_WATCHPOINT;
 
-    case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BKPT_INSTRUCTION:
-	LOG_INFO(&quot;Debug entry: BKPT instruction&quot;);
-	return DBG_REASON_BREAKPOINT;
+	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_BKPT_INSTRUCTION:
+		LOG_INFO(&quot;Debug entry: BKPT instruction&quot;);
+		return DBG_REASON_BREAKPOINT;
 
-    case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_EDBGRQ:
-	LOG_INFO(&quot;Debug entry: EDBGRQ signal&quot;);
-	return DBG_REASON_DBGRQ;
+	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_EDBGRQ:
+		LOG_INFO(&quot;Debug entry: EDBGRQ signal&quot;);
+		return DBG_REASON_DBGRQ;
 
-    case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_VECTOR_CATCH:
-	LOG_INFO(&quot;Debug entry: VCR vector catch&quot;);
-	return DBG_REASON_BREAKPOINT;
+	case ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_VECTOR_CATCH:
+		LOG_INFO(&quot;Debug entry: VCR vector catch&quot;);
+		return DBG_REASON_BREAKPOINT;
 
-    default:
-	LOG_INFO(&quot;Debug entry: unknown&quot;);
-	return DBG_REASON_DBGRQ;
-    }
+	default:
+		LOG_INFO(&quot;Debug entry: unknown&quot;);
+		return DBG_REASON_DBGRQ;
+	}
 };
 
 
@@ -326,12 +322,12 @@
  * shortcut is used instead of actually changing the Scan_N
  * register.
  *
- * \param arm11 Target state variable.
+ * \param arm11		Target state variable.
  *
  */
 void arm11_run_instr_data_prepare(arm11_common_t * arm11)
 {
-    arm11_add_debug_SCAN_N(arm11, 0x05, TAP_INVALID);
+	arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 }
 
 /** Cleanup after ITR/DTR operations
@@ -345,12 +341,12 @@
  * INTEST or EXTEST. So we must disable that before
  * any following activities lead to an IDLE.
  *
- * \param arm11 Target state variable.
+ * \param arm11		Target state variable.
  *
  */
 void arm11_run_instr_data_finish(arm11_common_t * arm11)
 {
-    arm11_add_debug_SCAN_N(arm11, 0x00, TAP_INVALID);
+	arm11_add_debug_SCAN_N(arm11, 0x00, ARM11_TAP_DEFAULT);
 }
 
 
@@ -365,24 +361,24 @@
  */
 void arm11_run_instr_no_data(arm11_common_t * arm11, u32 * opcode, size_t count)
 {
-    arm11_add_IR(arm11, ARM11_ITRSEL, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
-    while (count--)
-    {
-	arm11_add_debug_INST(arm11, *opcode++, NULL, TAP_IDLE);
-
-	while (1)
+	while (count--)
 	{
-	    u8 flag;
+		arm11_add_debug_INST(arm11, *opcode++, NULL, TAP_IDLE);
 
-	    arm11_add_debug_INST(arm11, 0, &amp;flag, count ? TAP_IDLE : TAP_DRPAUSE);
+		while (1)
+		{
+			u8 flag;
 
-	    jtag_execute_queue();
+			arm11_add_debug_INST(arm11, 0, &amp;flag, count ? TAP_IDLE : TAP_DRPAUSE);
 
-	    if (flag)
-		break;
+			jtag_execute_queue();
+
+			if (flag)
+				break;
+		}
 	}
-    }
 }
 
 /** Execute one instruction via ITR
@@ -395,7 +391,7 @@
  */
 void arm11_run_instr_no_data1(arm11_common_t * arm11, u32 opcode)
 {
-    arm11_run_instr_no_data(arm11, &amp;opcode, 1);
+	arm11_run_instr_no_data(arm11, &amp;opcode, 1);
 }
 
 
@@ -414,50 +410,50 @@
  */
 void arm11_run_instr_data_to_core(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count)
 {
-    arm11_add_IR(arm11, ARM11_ITRSEL, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
-    arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
+	arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
 
-    arm11_add_IR(arm11, ARM11_EXTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
 
-    scan_field_t	chain5_fields[3];
+	scan_field_t	chain5_fields[3];
 
-    u32			Data;
-    u8			Ready;
-    u8			nRetry;
+	u32				Data;
+	u8				Ready;
+	u8				nRetry;
 
-    arm11_setup_field(arm11, 32,    &amp;Data,  NULL,	chain5_fields + 0);
-    arm11_setup_field(arm11,  1,    NULL,   &amp;Ready,	chain5_fields + 1);
-    arm11_setup_field(arm11,  1,    NULL,   &amp;nRetry,	chain5_fields + 2);
+	arm11_setup_field(arm11, 32,    &amp;Data,  NULL,		chain5_fields + 0);
+	arm11_setup_field(arm11,  1,    NULL,   &amp;Ready,		chain5_fields + 1);
+	arm11_setup_field(arm11,  1,    NULL,   &amp;nRetry,	chain5_fields + 2);
 
-    while (count--)
-    {
-	do
+	while (count--)
 	{
-	    Data	    = *data;
+		do
+		{
+			Data	    = *data;
 
-	    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_IDLE);
-	    jtag_execute_queue();
+			arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_IDLE);
+			jtag_execute_queue();
 
-	    JTAG_DEBUG(&quot;DTR  Ready %d  nRetry %d&quot;, Ready, nRetry);
+			JTAG_DEBUG(&quot;DTR  Ready %d  nRetry %d&quot;, Ready, nRetry);
+		}
+		while (!Ready);
+
+		data++;
 	}
-	while (!Ready);
 
-	data++;
-    }
+	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
-    arm11_add_IR(arm11, ARM11_INTEST, TAP_INVALID);
+	do
+	{
+		Data	    = 0;
 
-    do
-    {
-	Data	    = 0;
+		arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		jtag_execute_queue();
 
-	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
-	jtag_execute_queue();
-
-	JTAG_DEBUG(&quot;DTR  Data %08x  Ready %d  nRetry %d&quot;, Data, Ready, nRetry);
-    }
-    while (!Ready);
+		JTAG_DEBUG(&quot;DTR  Data %08x  Ready %d  nRetry %d&quot;, Data, Ready, nRetry);
+	}
+	while (!Ready);
 }
 
 /** JTAG path for arm11_run_instr_data_to_core_noack
@@ -473,7 +469,7 @@
  */
 tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
 {
-    TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+	TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };
 
 
@@ -495,60 +491,60 @@
  */
 void arm11_run_instr_data_to_core_noack(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count)
 {
-    arm11_add_IR(arm11, ARM11_ITRSEL, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
-    arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
+	arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
 
-    arm11_add_IR(arm11, ARM11_EXTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
 
-    scan_field_t	chain5_fields[3];
+	scan_field_t	chain5_fields[3];
 
-    arm11_setup_field(arm11, 32,    NULL/*&amp;Data*/,  NULL,	chain5_fields + 0);
-    arm11_setup_field(arm11,  1,    NULL,   NULL /*&amp;Ready*/,	chain5_fields + 1);
-    arm11_setup_field(arm11,  1,    NULL,   NULL,	chain5_fields + 2);
+	arm11_setup_field(arm11, 32,    NULL/*&amp;Data*/,  NULL,				chain5_fields + 0);
+	arm11_setup_field(arm11,  1,    NULL,			NULL /*&amp;Ready*/,	chain5_fields + 1);
+	arm11_setup_field(arm11,  1,    NULL,			NULL,				chain5_fields + 2);
 
-    u8			Readies[count + 1];
-    u8	*		ReadyPos	    = Readies;
+	u8			Readies[count + 1];
+	u8	*		ReadyPos			= Readies;
 
-    while (count--)
-    {
-	chain5_fields[0].out_value	= (void *)(data++);
-	chain5_fields[1].in_value	= ReadyPos++;
-
-	if (count)
+	while (count--)
 	{
-	    jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
-	    jtag_add_pathmove(asizeof(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
-		arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
+		chain5_fields[0].out_value	= (void *)(data++);
+		chain5_fields[1].in_value	= ReadyPos++;
+
+		if (count)
+		{
+			jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+			jtag_add_pathmove(asizeof(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
+				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
+		}
+		else
+		{
+			jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_IDLE);
+		}
 	}
-	else
-	{
-	    jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_IDLE);
-	}
-    }
 
-    arm11_add_IR(arm11, ARM11_INTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
-    chain5_fields[0].out_value	= 0;
-    chain5_fields[1].in_value   = ReadyPos++;
+	chain5_fields[0].out_value	= 0;
+	chain5_fields[1].in_value   = ReadyPos++;
 
-    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
-    jtag_execute_queue();
+	jtag_execute_queue();
 
-    size_t error_count = 0;
+	size_t error_count = 0;
 
-    {size_t i;
-    for (i = 0; i &lt; asizeof(Readies); i++)
-    {
-	if (Readies[i] != 1)
+	{size_t i;
+	for (i = 0; i &lt; asizeof(Readies); i++)
 	{
-	    error_count++;
-	}
-    }}
+		if (Readies[i] != 1)
+		{
+			error_count++;
+		}
+	}}
 
-    if (error_count)
-	LOG_ERROR(&quot;Transfer errors &quot; ZU, error_count);
+	if (error_count)
+		LOG_ERROR(&quot;Transfer errors &quot; ZU, error_count);
 }
 
 
@@ -565,7 +561,7 @@
  */
 void arm11_run_instr_data_to_core1(arm11_common_t * arm11, u32 opcode, u32 data)
 {
-    arm11_run_instr_data_to_core(arm11, opcode, &amp;data, 1);
+	arm11_run_instr_data_to_core(arm11, opcode, &amp;data, 1);
 }
 
 
@@ -584,35 +580,35 @@
  */
 void arm11_run_instr_data_from_core(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count)
 {
-    arm11_add_IR(arm11, ARM11_ITRSEL, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
-    arm11_add_debug_INST(arm11, opcode, NULL, TAP_IDLE);
+	arm11_add_debug_INST(arm11, opcode, NULL, TAP_IDLE);
 
-    arm11_add_IR(arm11, ARM11_INTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
-    scan_field_t	chain5_fields[3];
+	scan_field_t	chain5_fields[3];
 
-    u32			Data;
-    u8			Ready;
-    u8			nRetry;
+	u32			Data;
+	u8			Ready;
+	u8			nRetry;
 
-    arm11_setup_field(arm11, 32,    NULL,	&amp;Data,	    chain5_fields + 0);
-    arm11_setup_field(arm11,  1,    NULL,	&amp;Ready,	    chain5_fields + 1);
-    arm11_setup_field(arm11,  1,    NULL,	&amp;nRetry,    chain5_fields + 2);
+	arm11_setup_field(arm11, 32,    NULL,	&amp;Data,	    chain5_fields + 0);
+	arm11_setup_field(arm11,  1,    NULL,	&amp;Ready,	    chain5_fields + 1);
+	arm11_setup_field(arm11,  1,    NULL,	&amp;nRetry,    chain5_fields + 2);
 
-    while (count--)
-    {
-	do
+	while (count--)
 	{
-	    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
-	    jtag_execute_queue();
+		do
+		{
+			arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
+			jtag_execute_queue();
 
-	    JTAG_DEBUG(&quot;DTR  Data %08x  Ready %d  nRetry %d&quot;, Data, Ready, nRetry);
-	}
-	while (!Ready);
+			JTAG_DEBUG(&quot;DTR  Data %08x  Ready %d  nRetry %d&quot;, Data, Ready, nRetry);
+		}
+		while (!Ready);
 
-	*data++ = Data;
-    }
+		*data++ = Data;
+	}
 }
 
 /** Execute one instruction via ITR
@@ -629,10 +625,10 @@
  */
 void arm11_run_instr_data_from_core_via_r0(arm11_common_t * arm11, u32 opcode, u32 * data)
 {
-    arm11_run_instr_no_data1(arm11, opcode);
+	arm11_run_instr_no_data1(arm11, opcode);
 
-    /* MCR p14,0,R0,c0,c5,0 (move r0 -&gt; wDTR -&gt; local var) */
-    arm11_run_instr_data_from_core(arm11, 0xEE000E15, data, 1);
+	/* MCR p14,0,R0,c0,c5,0 (move r0 -&gt; wDTR -&gt; local var) */
+	arm11_run_instr_data_from_core(arm11, 0xEE000E15, data, 1);
 }
 
 /** Load data into core via DTR then move it to r0 then
@@ -649,10 +645,10 @@
  */
 void arm11_run_instr_data_to_core_via_r0(arm11_common_t * arm11, u32 opcode, u32 data)
 {
-    /* MRC p14,0,r0,c0,c5,0 */
-    arm11_run_instr_data_to_core1(arm11, 0xEE100E15, data);
+	/* MRC p14,0,r0,c0,c5,0 */
+	arm11_run_instr_data_to_core1(arm11, 0xEE100E15, data);
 
-    arm11_run_instr_no_data1(arm11, opcode);
+	arm11_run_instr_no_data1(arm11, opcode);
 }
 
 /** Apply reads and writes to scan chain 7
@@ -666,76 +662,76 @@
  */
 void arm11_sc7_run(arm11_common_t * arm11, arm11_sc7_action_t * actions, size_t count)
 {
-    arm11_add_debug_SCAN_N(arm11, 0x07, TAP_INVALID);
+	arm11_add_debug_SCAN_N(arm11, 0x07, ARM11_TAP_DEFAULT);
 
-    arm11_add_IR(arm11, ARM11_EXTEST, TAP_INVALID);
+	arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
 
-    scan_field_t	chain7_fields[3];
+	scan_field_t	chain7_fields[3];
 
-    u8		nRW;
-    u32		DataOut;
-    u8		AddressOut;
-    u8		Ready;
-    u32		DataIn;
-    u8		AddressIn;
+	u8				nRW;
+	u32				DataOut;
+	u8				AddressOut;
+	u8				Ready;
+	u32				DataIn;
+	u8				AddressIn;
 
-    arm11_setup_field(arm11,  1, &amp;nRW,		&amp;Ready,		chain7_fields + 0);
-    arm11_setup_field(arm11, 32, &amp;DataOut,	&amp;DataIn,	chain7_fields + 1);
-    arm11_setup_field(arm11,  7, &amp;AddressOut,	&amp;AddressIn,	chain7_fields + 2);
+	arm11_setup_field(arm11,  1, &amp;nRW,			&amp;Ready,		chain7_fields + 0);
+	arm11_setup_field(arm11, 32, &amp;DataOut,		&amp;DataIn,	chain7_fields + 1);
+	arm11_setup_field(arm11,  7, &amp;AddressOut,	&amp;AddressIn,	chain7_fields + 2);
 
-    {size_t i;
-    for (i = 0; i &lt; count + 1; i++)
-    {
-	if (i &lt; count)
+	{size_t i;
+	for (i = 0; i &lt; count + 1; i++)
 	{
-	    nRW		= actions[i].write ? 1 : 0;
-	    DataOut	= actions[i].value;
-	    AddressOut	= actions[i].address;
-	}
-	else
-	{
-	    nRW		= 0;
-	    DataOut	= 0;
-	    AddressOut	= 0;
-	}
+		if (i &lt; count)
+		{
+			nRW			= actions[i].write ? 1 : 0;
+			DataOut		= actions[i].value;
+			AddressOut	= actions[i].address;
+		}
+		else
+		{
+			nRW			= 0;
+			DataOut		= 0;
+			AddressOut	= 0;
+		}
 
-	do
-	{
-	    JTAG_DEBUG(&quot;SC7 &lt;= Address %02x  Data %08x    nRW %d&quot;, AddressOut, DataOut, nRW);
+		do
+		{
+			JTAG_DEBUG(&quot;SC7 &lt;= Address %02x  Data %08x    nRW %d&quot;, AddressOut, DataOut, nRW);
 
-	    arm11_add_dr_scan_vc(asizeof(chain7_fields), chain7_fields, TAP_DRPAUSE);
-	    jtag_execute_queue();
+			arm11_add_dr_scan_vc(asizeof(chain7_fields), chain7_fields, TAP_DRPAUSE);
+			jtag_execute_queue();
 
-	    JTAG_DEBUG(&quot;SC7 =&gt; Address %02x  Data %08x  Ready %d&quot;, AddressIn, DataIn, Ready);
-	}
-	while (!Ready); /* 'nRW' is 'Ready' on read out */
+			JTAG_DEBUG(&quot;SC7 =&gt; Address %02x  Data %08x  Ready %d&quot;, AddressIn, DataIn, Ready);
+		}
+		while (!Ready); /* 'nRW' is 'Ready' on read out */
 
-	if (i &gt; 0)
-	{
-	    if (actions[i - 1].address != AddressIn)
-	    {
-		LOG_WARNING(&quot;Scan chain 7 shifted out unexpected address&quot;);
-	    }
-
-	    if (!actions[i - 1].write)
-	    {
-		actions[i - 1].value = DataIn;
-	    }
-	    else
-	    {
-		if (actions[i - 1].value != DataIn)
+		if (i &gt; 0)
 		{
-		    LOG_WARNING(&quot;Scan chain 7 shifted out unexpected data&quot;);
+			if (actions[i - 1].address != AddressIn)
+			{
+				LOG_WARNING(&quot;Scan chain 7 shifted out unexpected address&quot;);
+			}
+
+			if (!actions[i - 1].write)
+			{
+				actions[i - 1].value = DataIn;
+			}
+			else
+			{
+				if (actions[i - 1].value != DataIn)
+				{
+					LOG_WARNING(&quot;Scan chain 7 shifted out unexpected data&quot;);
+				}
+			}
 		}
-	    }
-	}
-    }}
+	}}
 
-    {size_t i;
-    for (i = 0; i &lt; count; i++)
-    {
-	JTAG_DEBUG(&quot;SC7 %02d: %02x %s %08x&quot;, i, actions[i].address, actions[i].write ? &quot;&lt;=&quot; : &quot;=&gt;&quot;, actions[i].value);
-    }}
+	{size_t i;
+	for (i = 0; i &lt; count; i++)
+	{
+		JTAG_DEBUG(&quot;SC7 %02d: %02x %s %08x&quot;, i, actions[i].address, actions[i].write ? &quot;&lt;=&quot; : &quot;=&gt;&quot;, actions[i].value);
+	}}
 }
 
 /** Clear VCR and all breakpoints and watchpoints via scan chain 7
@@ -745,29 +741,29 @@
  */
 void arm11_sc7_clear_vbw(arm11_common_t * arm11)
 {
-    arm11_sc7_action_t		clear_bw[arm11-&gt;brp + arm11-&gt;wrp + 1];
-    arm11_sc7_action_t *	pos = clear_bw;
+	arm11_sc7_action_t		clear_bw[arm11-&gt;brp + arm11-&gt;wrp + 1];
+	arm11_sc7_action_t *	pos = clear_bw;
 
-    {size_t i;
-    for (i = 0; i &lt; asizeof(clear_bw); i++)
-    {
-	clear_bw[i].write	= true;
-	clear_bw[i].value	= 0;
-    }}
+	{size_t i;
+	for (i = 0; i &lt; asizeof(clear_bw); i++)
+	{
+		clear_bw[i].write	= true;
+		clear_bw[i].value	= 0;
+	}}
 
-    {size_t i;
-    for (i = 0; i &lt; arm11-&gt;brp; i++)
-	(pos++)-&gt;address = ARM11_SC7_BCR0 + i;
-    }
+	{size_t i;
+	for (i = 0; i &lt; arm11-&gt;brp; i++)
+		(pos++)-&gt;address = ARM11_SC7_BCR0 + i;
+	}
 
-    {size_t i;
-    for (i = 0; i &lt; arm11-&gt;wrp; i++)
-	(pos++)-&gt;address = ARM11_SC7_WCR0 + i;
-    }
+	{size_t i;
+	for (i = 0; i &lt; arm11-&gt;wrp; i++)
+		(pos++)-&gt;address = ARM11_SC7_WCR0 + i;
+	}
 
-    (pos++)-&gt;address = ARM11_SC7_VCR;
+	(pos++)-&gt;address = ARM11_SC7_VCR;
 
-    arm11_sc7_run(arm11, clear_bw, asizeof(clear_bw));
+	arm11_sc7_run(arm11, clear_bw, asizeof(clear_bw));
 }
 
 /** Write VCR register
@@ -777,14 +773,14 @@
  */
 void arm11_sc7_set_vcr(arm11_common_t * arm11, u32 value)
 {
-    arm11_sc7_action_t		set_vcr;
+	arm11_sc7_action_t		set_vcr;
 
-    set_vcr.write		= true;
-    set_vcr.address		= ARM11_SC7_VCR;
-    set_vcr.value		= value;
+	set_vcr.write		= true;
+	set_vcr.address		= ARM11_SC7_VCR;
+	set_vcr.value		= value;
 
 
-    arm11_sc7_run(arm11, &amp;set_vcr, 1);
+	arm11_sc7_run(arm11, &amp;set_vcr, 1);
 }
 
 
@@ -798,15 +794,15 @@
  */
 void arm11_read_memory_word(arm11_common_t * arm11, u32 address, u32 * result)
 {
-    arm11_run_instr_data_prepare(arm11);
+	arm11_run_instr_data_prepare(arm11);
 
-    /* MRC p14,0,r0,c0,c5,0 (r0 = address) */
-    arm11_run_instr_data_to_core1(arm11, 0xee100e15, address);
+	/* MRC p14,0,r0,c0,c5,0 (r0 = address) */
+	arm11_run_instr_data_to_core1(arm11, 0xee100e15, address);
 
-    /* LDC p14,c5,[R0],#4 (DTR = [r0]) */
-    arm11_run_instr_data_from_core(arm11, 0xecb05e01, result, 1);
+	/* LDC p14,c5,[R0],#4 (DTR = [r0]) */
+	arm11_run_instr_data_from_core(arm11, 0xecb05e01, result, 1);
 
-    arm11_run_instr_data_finish(arm11);
+	arm11_run_instr_data_finish(arm11);
 }
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000295.html">[Openocd-svn] r1511 - trunk/src/server
</A></li>
	<LI>Next message: <A HREF="000297.html">[Openocd-svn] r1513 - trunk/src/helper
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#296">[ date ]</a>
              <a href="thread.html#296">[ thread ]</a>
              <a href="subject.html#296">[ subject ]</a>
              <a href="author.html#296">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
