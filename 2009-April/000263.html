<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1479 - trunk/src/jtag
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1479%20-%20trunk/src/jtag&In-Reply-To=%3C200904210529.n3L5TfLQ007390%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000262.html">
   <LINK REL="Next"  HREF="000264.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1479 - trunk/src/jtag</H1>
    <B>oharboe at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1479%20-%20trunk/src/jtag&In-Reply-To=%3C200904210529.n3L5TfLQ007390%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1479 - trunk/src/jtag">oharboe at mail.berlios.de
       </A><BR>
    <I>Tue Apr 21 07:29:41 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000262.html">[Openocd-svn] r1478 - in trunk/src: jtag target/target
</A></li>
        <LI>Next message: <A HREF="000264.html">[Openocd-svn] r1480 - in trunk: . src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#263">[ date ]</a>
              <a href="thread.html#263">[ thread ]</a>
              <a href="subject.html#263">[ subject ]</a>
              <a href="author.html#263">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: oharboe
Date: 2009-04-21 07:29:23 +0200 (Tue, 21 Apr 2009)
New Revision: 1479

Modified:
   trunk/src/jtag/amt_jtagaccel.c
   trunk/src/jtag/arm-jtag-ew.c
   trunk/src/jtag/at91rm9200.c
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/bitq.c
   trunk/src/jtag/dummy.c
   trunk/src/jtag/ep93xx.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/gw16012.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/jtag.c
   trunk/src/jtag/parport.c
   trunk/src/jtag/presto.c
   trunk/src/jtag/usbprog.c
   trunk/src/jtag/vsllink.c
Log:
Zach Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt; use static keyword in jtag layer and drivers

Modified: trunk/src/jtag/amt_jtagaccel.c
===================================================================
--- trunk/src/jtag/amt_jtagaccel.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/amt_jtagaccel.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -56,7 +56,7 @@
 #include &quot;log.h&quot;
 
 /* configuration */
-u16 amt_jtagaccel_port;
+static u16 amt_jtagaccel_port;
 
 /* interface variables
  */
@@ -68,28 +68,33 @@
 
 #if PARPORT_USE_PPDEV == 1
 static int device_handle;
-int addr_mode = IEEE1284_MODE_EPP | IEEE1284_ADDR ;
-int data_mode = IEEE1284_MODE_EPP | IEEE1284_DATA ;
+
+static int addr_mode = IEEE1284_MODE_EPP | IEEE1284_ADDR ;
 #define AMT_AW(val)	do { ioctl(device_handle, PPSETMODE, &amp;addr_mode); write(device_handle, &amp;val, 1); } while (0)
 #define AMT_AR(val)	do { ioctl(device_handle, PPSETMODE, &amp;addr_mode); read(device_handle, &amp;val, 1); } while (0)
+
+static int data_mode = IEEE1284_MODE_EPP | IEEE1284_DATA ;
 #define AMT_DW(val)	do { ioctl(device_handle, PPSETMODE, &amp;data_mode); write(device_handle, &amp;val, 1); } while (0)
 #define AMT_DR(val)	do { ioctl(device_handle, PPSETMODE, &amp;data_mode); read(device_handle, &amp;val, 1); } while (0)
+
 #else
+
 #define AMT_AW(val)	do { outb(val, amt_jtagaccel_port + 3); } while (0)
 #define AMT_AR(val)	do { val = inb(amt_jtagaccel_port + 3); } while (0)
 #define AMT_DW(val)	do { outb(val, amt_jtagaccel_port + 4); } while (0)
 #define AMT_DR(val)	do { val = inb(amt_jtagaccel_port + 4); } while (0)
-#endif
 
-int amt_jtagaccel_execute_queue(void);
-int amt_jtagaccel_register_commands(struct command_context_s *cmd_ctx);
-int amt_jtagaccel_speed(int speed);
-int amt_jtagaccel_init(void);
-int amt_jtagaccel_quit(void);
+#endif // PARPORT_USE_PPDEV
 
-int amt_jtagaccel_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int amt_jtagaccel_handle_rtck_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int amt_jtagaccel_execute_queue(void);
+static int amt_jtagaccel_register_commands(struct command_context_s *cmd_ctx);
+static int amt_jtagaccel_speed(int speed);
+static int amt_jtagaccel_init(void);
+static int amt_jtagaccel_quit(void);
 
+static int amt_jtagaccel_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int amt_jtagaccel_handle_rtck_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+
 /* tap_move[i][j]: tap movement command to go from state i to state j
  * 0: Test-Logic-Reset
  * 1: Run-Test/Idle
@@ -98,7 +103,7 @@
  * 4: Shift-IR
  * 5: Pause-IR
  */
-u8 amt_jtagaccel_tap_move[6][6][2] =
+static u8 amt_jtagaccel_tap_move[6][6][2] =
 {
 	/*	   RESET         IDLE        DRSHIFT       DRPAUSE       IRSHIFT       IRPAUSE             */
 	{{0x1f, 0x00}, {0x0f, 0x00}, {0x8a, 0x04}, {0x0a, 0x00}, {0x06, 0x00}, {0x96, 0x00}},	/* RESET */
@@ -122,7 +127,7 @@
 	.quit = amt_jtagaccel_quit,
 };
 
-int amt_jtagaccel_register_commands(struct command_context_s *cmd_ctx)
+static int amt_jtagaccel_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;parport_port&quot;, amt_jtagaccel_handle_parport_port_command,
 					 COMMAND_CONFIG, NULL);
@@ -132,7 +137,7 @@
 	return ERROR_OK;
 }
 
-void amt_jtagaccel_reset(int trst, int srst)
+static void amt_jtagaccel_reset(int trst, int srst)
 {
 	if (trst == 1)
 		aw_control_rst |= 0x4;
@@ -147,7 +152,7 @@
 	AMT_AW(aw_control_rst);
 }
 
-int amt_jtagaccel_speed(int speed)
+static int amt_jtagaccel_speed(int speed)
 {
 	aw_control_baudrate &amp;= 0xf0;
 	aw_control_baudrate |= speed &amp; 0x0f;
@@ -156,7 +161,7 @@
 	return ERROR_OK;
 }
 
-void amt_jtagaccel_end_state(tap_state_t state)
+static void amt_jtagaccel_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
 		tap_set_end_state(state);
@@ -167,7 +172,7 @@
 	}
 }
 
-void amt_wait_scan_busy(void)
+static void amt_wait_scan_busy(void)
 {
 	int timeout = 4096;
 	u8 ar_status;
@@ -183,7 +188,7 @@
 	}
 }
 
-void amt_jtagaccel_state_move(void)
+static void amt_jtagaccel_state_move(void)
 {
 	u8 aw_scan_tms_5;
 	u8 tms_scan[2];
@@ -210,7 +215,7 @@
 	tap_set_state(end_state);
 }
 
-void amt_jtagaccel_runtest(int num_cycles)
+static void amt_jtagaccel_runtest(int num_cycles)
 {
 	int i = 0;
 	u8 aw_scan_tms_5;
@@ -243,7 +248,7 @@
 		amt_jtagaccel_state_move();
 }
 
-void amt_jtagaccel_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void amt_jtagaccel_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
 	int bits_left = scan_size;
 	int bit_count = 0;
@@ -325,7 +330,7 @@
 	tap_set_state(tap_get_end_state());
 }
 
-int amt_jtagaccel_execute_queue(void)
+static int amt_jtagaccel_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
@@ -431,7 +436,7 @@
 }
 #endif
 
-int amt_jtagaccel_init(void)
+static int amt_jtagaccel_init(void)
 {
 #if PARPORT_USE_PPDEV == 1
 	char buffer[256];
@@ -536,13 +541,13 @@
 	return ERROR_OK;
 }
 
-int amt_jtagaccel_quit(void)
+static int amt_jtagaccel_quit(void)
 {
 
 	return ERROR_OK;
 }
 
-int amt_jtagaccel_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int amt_jtagaccel_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 0)
 		return ERROR_OK;
@@ -554,7 +559,7 @@
 	return ERROR_OK;
 }
 
-int amt_jtagaccel_handle_rtck_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int amt_jtagaccel_handle_rtck_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 0)
 	{

Modified: trunk/src/jtag/arm-jtag-ew.c
===================================================================
--- trunk/src/jtag/arm-jtag-ew.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/arm-jtag-ew.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -77,32 +77,32 @@
 static u8 usb_out_buffer[ARMJTAGEW_OUT_BUFFER_SIZE];
 
 /* External interface functions */
-int armjtagew_execute_queue(void);
-int armjtagew_speed(int speed);
-int armjtagew_khz(int khz, int *jtag_speed);
-int armjtagew_register_commands(struct command_context_s *cmd_ctx);
-int armjtagew_init(void);
-int armjtagew_quit(void);
+static int armjtagew_execute_queue(void);
+static int armjtagew_speed(int speed);
+static int armjtagew_khz(int khz, int *jtag_speed);
+static int armjtagew_register_commands(struct command_context_s *cmd_ctx);
+static int armjtagew_init(void);
+static int armjtagew_quit(void);
 
 /* CLI command handler functions */
-int armjtagew_handle_armjtagew_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int armjtagew_handle_armjtagew_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 /* Queue command functions */
-void armjtagew_end_state(tap_state_t state);
-void armjtagew_state_move(void);
-void armjtagew_path_move(int num_states, tap_state_t *path);
-void armjtagew_runtest(int num_cycles);
-void armjtagew_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
-void armjtagew_reset(int trst, int srst);
-void armjtagew_simple_command(u8 command);
-int armjtagew_get_status(void);
+static void armjtagew_end_state(tap_state_t state);
+static void armjtagew_state_move(void);
+static void armjtagew_path_move(int num_states, tap_state_t *path);
+static void armjtagew_runtest(int num_cycles);
+static void armjtagew_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void armjtagew_reset(int trst, int srst);
+//static void armjtagew_simple_command(u8 command);
+static int armjtagew_get_status(void);
 
 /* tap buffer functions */
-void armjtagew_tap_init(void);
-int armjtagew_tap_execute(void);
-void armjtagew_tap_ensure_space(int scans, int bits);
-void armjtagew_tap_append_step(int tms, int tdi);
-void armjtagew_tap_append_scan(int length, u8 *buffer, scan_command_t *command);
+static void armjtagew_tap_init(void);
+static int armjtagew_tap_execute(void);
+static void armjtagew_tap_ensure_space(int scans, int bits);
+static void armjtagew_tap_append_step(int tms, int tdi);
+static void armjtagew_tap_append_scan(int length, u8 *buffer, scan_command_t *command);
 
 /* ARM-JTAG-EW lowlevel functions */
 typedef struct armjtagew_jtag
@@ -110,20 +110,20 @@
 	struct usb_dev_handle* usb_handle;
 } armjtagew_jtag_t;
 
-armjtagew_jtag_t *armjtagew_usb_open(void);
-void armjtagew_usb_close(armjtagew_jtag_t *armjtagew_jtag);
-int armjtagew_usb_message(armjtagew_jtag_t *armjtagew_jtag, int out_length, int in_length);
-int armjtagew_usb_write(armjtagew_jtag_t *armjtagew_jtag, int out_length);
-int armjtagew_usb_read(armjtagew_jtag_t *armjtagew_jtag, int exp_in_length);
+static armjtagew_jtag_t *armjtagew_usb_open(void);
+static void armjtagew_usb_close(armjtagew_jtag_t *armjtagew_jtag);
+static int armjtagew_usb_message(armjtagew_jtag_t *armjtagew_jtag, int out_length, int in_length);
+static int armjtagew_usb_write(armjtagew_jtag_t *armjtagew_jtag, int out_length);
+static int armjtagew_usb_read(armjtagew_jtag_t *armjtagew_jtag, int exp_in_length);
 
 /* helper functions */
-int armjtagew_get_version_info(void);
+static int armjtagew_get_version_info(void);
 
 #ifdef _DEBUG_USB_COMMS_
-void armjtagew_debug_buffer(u8 *buffer, int length);
+static void armjtagew_debug_buffer(u8 *buffer, int length);
 #endif
 
-armjtagew_jtag_t* armjtagew_jtag_handle;
+static armjtagew_jtag_t* armjtagew_jtag_handle;
 
 
 
@@ -142,7 +142,7 @@
 };
 
 
-int armjtagew_execute_queue(void)
+static int armjtagew_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue;
 	int scan_size;
@@ -239,7 +239,7 @@
 
 
 /* Sets speed in kHz. */
-int armjtagew_speed(int speed)
+static int armjtagew_speed(int speed)
 {
     int result;
     int speed_real;
@@ -273,21 +273,21 @@
 }
 
 
-int armjtagew_khz(int khz, int *jtag_speed)
+static int armjtagew_khz(int khz, int *jtag_speed)
 {
 	*jtag_speed = khz;
 
 	return ERROR_OK;
 }
 
-int armjtagew_register_commands(struct command_context_s *cmd_ctx)
+static int armjtagew_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;armjtagew_info&quot;, armjtagew_handle_armjtagew_info_command, COMMAND_EXEC,
 		&quot;query armjtagew info&quot;);
 	return ERROR_OK;
 }
 
-int armjtagew_init(void)
+static int armjtagew_init(void)
 {
 	int check_cnt;
 
@@ -325,7 +325,7 @@
 	return ERROR_OK;
 }
 
-int armjtagew_quit(void)
+static int armjtagew_quit(void)
 {
 	armjtagew_usb_close(armjtagew_jtag_handle);
 	return ERROR_OK;
@@ -334,7 +334,7 @@
 /***************************************************************************/
 /* Queue command implementations */
 
-void armjtagew_end_state(tap_state_t state)
+static void armjtagew_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
 	{
@@ -348,7 +348,7 @@
 }
 
 /* Goes to the end state. */
-void armjtagew_state_move(void)
+static void armjtagew_state_move(void)
 {
 	int i;
 	int tms = 0;
@@ -363,7 +363,7 @@
 	tap_set_state(tap_get_end_state());
 }
 
-void armjtagew_path_move(int num_states, tap_state_t *path)
+static void armjtagew_path_move(int num_states, tap_state_t *path)
 {
 	int i;
 
@@ -394,7 +394,7 @@
 	tap_set_end_state(tap_get_state());
 }
 
-void armjtagew_runtest(int num_cycles)
+static void armjtagew_runtest(int num_cycles)
 {
 	int i;
 
@@ -421,7 +421,7 @@
 	}
 }
 
-void armjtagew_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void armjtagew_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
 
@@ -449,7 +449,7 @@
 	}
 }
 
-void armjtagew_reset(int trst, int srst)
+static void armjtagew_reset(int trst, int srst)
 {
 	const u8 trst_mask = (1u&lt;&lt;5);
 	const u8 srst_mask = (1u&lt;&lt;6);
@@ -498,7 +498,7 @@
 }
 
 
-int armjtagew_get_status(void)
+static int armjtagew_get_status(void)
 {
 	int result;
 
@@ -530,7 +530,7 @@
 	return ERROR_OK;
 }
 
-int armjtagew_get_version_info(void)
+static int armjtagew_get_version_info(void)
 {
 	int result;
 	char sn[16];
@@ -559,7 +559,7 @@
 	return ERROR_OK;
 }
 
-int armjtagew_handle_armjtagew_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int armjtagew_handle_armjtagew_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (armjtagew_get_version_info() == ERROR_OK)
 	{
@@ -596,13 +596,13 @@
 
 static int last_tms;
 
-void armjtagew_tap_init(void)
+static void armjtagew_tap_init(void)
 {
 	tap_length = 0;
 	pending_scan_results_length = 0;
 }
 
-void armjtagew_tap_ensure_space(int scans, int bits)
+static void armjtagew_tap_ensure_space(int scans, int bits)
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bits = ARMJTAGEW_TAP_BUFFER_SIZE * 8 - tap_length;
@@ -613,7 +613,7 @@
 	}
 }
 
-void armjtagew_tap_append_step(int tms, int tdi)
+static void armjtagew_tap_append_step(int tms, int tdi)
 {
 	last_tms = tms;
 	int index = tap_length / 8;
@@ -668,7 +668,7 @@
 
 /* Pad and send a tap sequence to the device, and receive the answer.
  * For the purpose of padding we assume that we are in idle or pause state. */
-int armjtagew_tap_execute(void)
+static int armjtagew_tap_execute(void)
 {
 	int byte_length;
 	int tms_offset;
@@ -764,7 +764,7 @@
 /*****************************************************************************/
 /* JLink USB low-level functions */
 
-armjtagew_jtag_t* armjtagew_usb_open()
+static armjtagew_jtag_t* armjtagew_usb_open()
 {
 	struct usb_bus *busses;
 	struct usb_bus *bus;
@@ -812,14 +812,14 @@
 	return NULL;
 }
 
-void armjtagew_usb_close(armjtagew_jtag_t *armjtagew_jtag)
+static void armjtagew_usb_close(armjtagew_jtag_t *armjtagew_jtag)
 {
 	usb_close(armjtagew_jtag-&gt;usb_handle);
 	free(armjtagew_jtag);
 }
 
 /* Send a message and receive the reply. */
-int armjtagew_usb_message(armjtagew_jtag_t *armjtagew_jtag, int out_length, int in_length)
+static int armjtagew_usb_message(armjtagew_jtag_t *armjtagew_jtag, int out_length, int in_length)
 {
 	int result;
 
@@ -842,7 +842,7 @@
 }
 
 /* Write data from out_buffer to USB. */
-int armjtagew_usb_write(armjtagew_jtag_t *armjtagew_jtag, int out_length)
+static int armjtagew_usb_write(armjtagew_jtag_t *armjtagew_jtag, int out_length)
 {
 	int result;
 
@@ -864,7 +864,7 @@
 }
 
 /* Read data from USB into in_buffer. */
-int armjtagew_usb_read(armjtagew_jtag_t *armjtagew_jtag, int exp_in_length)
+static int armjtagew_usb_read(armjtagew_jtag_t *armjtagew_jtag, int exp_in_length)
 {
 	int result = usb_bulk_read(armjtagew_jtag-&gt;usb_handle, ARMJTAGEW_EPT_BULK_IN, \
 		(char*)usb_in_buffer, exp_in_length, ARMJTAGEW_USB_TIMEOUT);
@@ -881,7 +881,7 @@
 #ifdef _DEBUG_USB_COMMS_
 #define BYTES_PER_LINE  16
 
-void armjtagew_debug_buffer(u8 *buffer, int length)
+static void armjtagew_debug_buffer(u8 *buffer, int length)
 {
 	char line[81];
 	char s[4];

Modified: trunk/src/jtag/at91rm9200.c
===================================================================
--- trunk/src/jtag/at91rm9200.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/at91rm9200.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -119,14 +119,14 @@
 
 /* low level command set
  */
-int at91rm9200_read(void);
-void at91rm9200_write(int tck, int tms, int tdi);
-void at91rm9200_reset(int trst, int srst);
+static int at91rm9200_read(void);
+static void at91rm9200_write(int tck, int tms, int tdi);
+static void at91rm9200_reset(int trst, int srst);
 
-int at91rm9200_speed(int speed);
-int at91rm9200_register_commands(struct command_context_s *cmd_ctx);
-int at91rm9200_init(void);
-int at91rm9200_quit(void);
+static int at91rm9200_speed(int speed);
+static int at91rm9200_register_commands(struct command_context_s *cmd_ctx);
+static int at91rm9200_init(void);
+static int at91rm9200_quit(void);
 
 jtag_interface_t at91rm9200_interface =
 {
@@ -140,7 +140,7 @@
 	.quit = at91rm9200_quit,
 };
 
-bitbang_interface_t at91rm9200_bitbang =
+static bitbang_interface_t at91rm9200_bitbang =
 {
 	.read = at91rm9200_read,
 	.write = at91rm9200_write,
@@ -148,12 +148,12 @@
 	.blink = 0
 };
 
-int at91rm9200_read(void)
+static int at91rm9200_read(void)
 {
 	return (pio_base[device-&gt;TDO_PIO + PIO_PDSR] &amp; device-&gt;TDO_MASK) != 0;
 }
 
-void at91rm9200_write(int tck, int tms, int tdi)
+static void at91rm9200_write(int tck, int tms, int tdi)
 {
 	if (tck)
 		pio_base[device-&gt;TCK_PIO + PIO_SODR] = device-&gt;TCK_MASK;
@@ -172,7 +172,7 @@
 }
 
 /* (1) assert or (0) deassert reset lines */
-void at91rm9200_reset(int trst, int srst)
+static void at91rm9200_reset(int trst, int srst)
 {
 	if (trst == 0)
 		pio_base[device-&gt;TRST_PIO + PIO_SODR] = device-&gt;TRST_MASK;
@@ -185,13 +185,13 @@
 		pio_base[device-&gt;SRST_PIO + PIO_CODR] = device-&gt;SRST_MASK;
 }
 
-int at91rm9200_speed(int speed)
+static int at91rm9200_speed(int speed)
 {
 
 	return ERROR_OK;
 }
 
-int at91rm9200_handle_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int at91rm9200_handle_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 0)
 		return ERROR_OK;
@@ -206,14 +206,14 @@
 	return ERROR_OK;
 }
 
-int at91rm9200_register_commands(struct command_context_s *cmd_ctx)
+static int at91rm9200_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;at91rm9200_device&quot;, at91rm9200_handle_device_command,
 		COMMAND_CONFIG, NULL);
 	return ERROR_OK;
 }
 
-int at91rm9200_init(void)
+static int at91rm9200_init(void)
 {
 	struct device_t *cur_device;
 
@@ -284,7 +284,7 @@
 	return ERROR_OK;
 }
 
-int at91rm9200_quit(void)
+static int at91rm9200_quit(void)
 {
 
 	return ERROR_OK;

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/bitbang.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -71,12 +71,9 @@
  */
 #define CLOCK_IDLE() 0
 
-int bitbang_execute_queue(void);
 
-
 /* The bitbang driver leaves the TCK 0 when in idle */
-
-void bitbang_end_state(tap_state_t state)
+static void bitbang_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
 		tap_set_end_state(state);
@@ -87,7 +84,7 @@
 	}
 }
 
-void bitbang_state_move(void)
+static void bitbang_state_move(void)
 {
 	int i=0, tms=0;
 	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
@@ -103,7 +100,7 @@
 	tap_set_state(tap_get_end_state());
 }
 
-void bitbang_path_move(pathmove_command_t *cmd)
+static void bitbang_path_move(pathmove_command_t *cmd)
 {
 	int num_states = cmd-&gt;num_states;
 	int state_count;
@@ -139,7 +136,7 @@
 	tap_set_end_state(tap_get_state());
 }
 
-void bitbang_runtest(int num_cycles)
+static void bitbang_runtest(int num_cycles)
 {
 	int i;
 
@@ -182,7 +179,7 @@
 
 
 
-void bitbang_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void bitbang_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 	int bit_cnt;

Modified: trunk/src/jtag/bitq.c
===================================================================
--- trunk/src/jtag/bitq.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/bitq.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -36,10 +36,10 @@
 
 bitq_interface_t* bitq_interface;       /* low level bit queue interface */
 
-bitq_state_t      bitq_in_state;        /* state of input queue */
+static bitq_state_t      bitq_in_state;        /* state of input queue */
 
-u8* bitq_in_buffer;                     /* buffer dynamically reallocated as needed */
-int     bitq_in_bufsize = 32; /* min. buffer size */
+static u8* bitq_in_buffer;                     /* buffer dynamically reallocated as needed */
+static int     bitq_in_bufsize = 32; /* min. buffer size */
 
 /*
  * input queue processing does not use jtag_read_buffer() to avoid unnecessary overhead

Modified: trunk/src/jtag/dummy.c
===================================================================
--- trunk/src/jtag/dummy.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/dummy.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -37,10 +37,10 @@
 static u32 dummy_data;
 
 
-int dummy_speed(int speed);
-int dummy_register_commands(struct command_context_s *cmd_ctx);
-int dummy_init(void);
-int dummy_quit(void);
+static int dummy_speed(int speed);
+static int dummy_register_commands(struct command_context_s *cmd_ctx);
+static int dummy_init(void);
+static int dummy_quit(void);
 static int dummy_khz(int khz, int *jtag_speed);
 static int dummy_speed_div(int speed, int *khz);
 
@@ -63,12 +63,12 @@
 	.quit = dummy_quit,
 };
 
-int dummy_read(void);
-void dummy_write(int tck, int tms, int tdi);
-void dummy_reset(int trst, int srst);
-void dummy_led(int on);
+static int dummy_read(void);
+static void dummy_write(int tck, int tms, int tdi);
+static void dummy_reset(int trst, int srst);
+static void dummy_led(int on);
 
-bitbang_interface_t dummy_bitbang =
+static bitbang_interface_t dummy_bitbang =
 {
 	.read = dummy_read,
 	.write = dummy_write,
@@ -76,7 +76,7 @@
 	.blink = dummy_led
 };
 
-int dummy_read(void)
+static int dummy_read(void)
 {
 	int data = 1 &amp; dummy_data;
 	dummy_data = (dummy_data &gt;&gt; 1) | (1&lt;&lt;31);
@@ -84,7 +84,7 @@
 }
 
 
-void dummy_write(int tck, int tms, int tdi)
+static void dummy_write(int tck, int tms, int tdi)
 {
 	/* TAP standard: &quot;state transitions occur on rising edge of clock&quot; */
 	if( tck != dummy_clock )
@@ -121,7 +121,7 @@
 	}
 }
 
-void dummy_reset(int trst, int srst)
+static void dummy_reset(int trst, int srst)
 {
 	dummy_clock = 0;
 
@@ -158,29 +158,29 @@
 	return ERROR_OK;
 }
 
-int dummy_speed(int speed)
+static int dummy_speed(int speed)
 {
 	return ERROR_OK;
 }
 
-int dummy_register_commands(struct command_context_s *cmd_ctx)
+static int dummy_register_commands(struct command_context_s *cmd_ctx)
 {
 	return ERROR_OK;
 }
 
-int dummy_init(void)
+static int dummy_init(void)
 {
 	bitbang_interface = &amp;dummy_bitbang;
 
 	return ERROR_OK;
 }
 
-int dummy_quit(void)
+static int dummy_quit(void)
 {
 	return ERROR_OK;
 }
 
-void dummy_led(int on)
+static void dummy_led(int on)
 {
 }
 

Modified: trunk/src/jtag/ep93xx.c
===================================================================
--- trunk/src/jtag/ep93xx.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/ep93xx.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -50,14 +50,14 @@
 
 /* low level command set
  */
-int ep93xx_read(void);
-void ep93xx_write(int tck, int tms, int tdi);
-void ep93xx_reset(int trst, int srst);
+static int ep93xx_read(void);
+static void ep93xx_write(int tck, int tms, int tdi);
+static void ep93xx_reset(int trst, int srst);
 
-int ep93xx_speed(int speed);
-int ep93xx_register_commands(struct command_context_s *cmd_ctx);
-int ep93xx_init(void);
-int ep93xx_quit(void);
+static int ep93xx_speed(int speed);
+static int ep93xx_register_commands(struct command_context_s *cmd_ctx);
+static int ep93xx_init(void);
+static int ep93xx_quit(void);
 
 struct timespec ep93xx_zzzz;
 
@@ -73,7 +73,7 @@
 	.quit = ep93xx_quit,
 };
 
-bitbang_interface_t ep93xx_bitbang =
+static bitbang_interface_t ep93xx_bitbang =
 {
 	.read = ep93xx_read,
 	.write = ep93xx_write,
@@ -81,12 +81,12 @@
 	.blink = 0,
 };
 
-int ep93xx_read(void)
+static int ep93xx_read(void)
 {
 	return !!(*gpio_data_register &amp; TDO_BIT);
 }
 
-void ep93xx_write(int tck, int tms, int tdi)
+static void ep93xx_write(int tck, int tms, int tdi)
 {
 	if (tck)
 		output_value |= TCK_BIT;
@@ -108,7 +108,7 @@
 }
 
 /* (1) assert or (0) deassert reset lines */
-void ep93xx_reset(int trst, int srst)
+static void ep93xx_reset(int trst, int srst)
 {
 	if (trst == 0)
 		output_value |= TRST_BIT;
@@ -124,13 +124,13 @@
 	nanosleep(&amp;ep93xx_zzzz, NULL);
 }
 
-int ep93xx_speed(int speed)
+static int ep93xx_speed(int speed)
 {
 
 	return ERROR_OK;
 }
 
-int ep93xx_register_commands(struct command_context_s *cmd_ctx)
+static int ep93xx_register_commands(struct command_context_s *cmd_ctx)
 {
 
 	return ERROR_OK;
@@ -157,7 +157,7 @@
 	return ERROR_OK;
 }
 
-int ep93xx_init(void)
+static int ep93xx_init(void)
 {
 	int ret;
 
@@ -231,7 +231,7 @@
 	return ERROR_OK;
 }
 
-int ep93xx_quit(void)
+static int ep93xx_quit(void)
 {
 
 	return ERROR_OK;

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/ft2232.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -70,20 +70,20 @@
 #define _DEBUG_USB_COMMS_
 #endif
 
-int ft2232_execute_queue(void);
+static int ft2232_execute_queue(void);
 
-int ft2232_speed(int speed);
-int ft2232_speed_div(int speed, int* khz);
-int ft2232_khz(int khz, int* jtag_speed);
-int ft2232_register_commands(struct command_context_s* cmd_ctx);
-int ft2232_init(void);
-int ft2232_quit(void);
+static int ft2232_speed(int speed);
+static int ft2232_speed_div(int speed, int* khz);
+static int ft2232_khz(int khz, int* jtag_speed);
+static int ft2232_register_commands(struct command_context_s* cmd_ctx);
+static int ft2232_init(void);
+static int ft2232_quit(void);
 
-int ft2232_handle_device_desc_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
-int ft2232_handle_serial_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
-int ft2232_handle_layout_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
-int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
-int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+static int ft2232_handle_device_desc_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+static int ft2232_handle_serial_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+static int ft2232_handle_layout_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+static int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
+static int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc);
 
 
 /**
@@ -97,11 +97,11 @@
 static int ft2232_stableclocks(int num_cycles, jtag_command_t* cmd);
 
 
-char *        ft2232_device_desc_A = NULL;
-char*         ft2232_device_desc = NULL;
-char*         ft2232_serial  = NULL;
-char*         ft2232_layout  = NULL;
-unsigned char ft2232_latency = 2;
+static char *        ft2232_device_desc_A = NULL;
+static char*         ft2232_device_desc = NULL;
+static char*         ft2232_serial  = NULL;
+static char*         ft2232_layout  = NULL;
+static unsigned char ft2232_latency = 2;
 
 #define MAX_USB_IDS 8
 /* vid = pid = 0 marks the end of the list */
@@ -117,31 +117,31 @@
 } ft2232_layout_t;
 
 /* init procedures for supported layouts */
-int  usbjtag_init(void);
-int  jtagkey_init(void);
-int  olimex_jtag_init(void);
-int  flyswatter_init(void);
-int  turtle_init(void);
-int  comstick_init(void);
-int  stm32stick_init(void);
-int  axm0432_jtag_init(void);
-int sheevaplug_init(void);
+static int  usbjtag_init(void);
+static int  jtagkey_init(void);
+static int  olimex_jtag_init(void);
+static int  flyswatter_init(void);
+static int  turtle_init(void);
+static int  comstick_init(void);
+static int  stm32stick_init(void);
+static int  axm0432_jtag_init(void);
+static int sheevaplug_init(void);
 
 /* reset procedures for supported layouts */
-void usbjtag_reset(int trst, int srst);
-void jtagkey_reset(int trst, int srst);
-void olimex_jtag_reset(int trst, int srst);
-void flyswatter_reset(int trst, int srst);
-void turtle_reset(int trst, int srst);
-void comstick_reset(int trst, int srst);
-void stm32stick_reset(int trst, int srst);
-void axm0432_jtag_reset(int trst, int srst);
-void sheevaplug_reset(int trst, int srst);
+static void usbjtag_reset(int trst, int srst);
+static void jtagkey_reset(int trst, int srst);
+static void olimex_jtag_reset(int trst, int srst);
+static void flyswatter_reset(int trst, int srst);
+static void turtle_reset(int trst, int srst);
+static void comstick_reset(int trst, int srst);
+static void stm32stick_reset(int trst, int srst);
+static void axm0432_jtag_reset(int trst, int srst);
+static void sheevaplug_reset(int trst, int srst);
 
 /* blink procedures for layouts that support a blinking led */
-void olimex_jtag_blink(void);
-void flyswatter_jtag_blink(void);
-void turtle_jtag_blink(void);
+static void olimex_jtag_blink(void);
+static void flyswatter_jtag_blink(void);
+static void turtle_jtag_blink(void);
 
 ft2232_layout_t            ft2232_layouts[] =
 {
@@ -200,7 +200,7 @@
 	.quit = ft2232_quit,
 };
 
-int ft2232_write(u8* buf, int size, u32* bytes_written)
+static int ft2232_write(u8* buf, int size, u32* bytes_written)
 {
 #if BUILD_FT2232_FTD2XX == 1
 	FT_STATUS status;
@@ -233,7 +233,7 @@
 }
 
 
-int ft2232_read(u8* buf, u32 size, u32* bytes_read)
+static int ft2232_read(u8* buf, u32 size, u32* bytes_read)
 {
 #if BUILD_FT2232_FTD2XX == 1
 	DWORD     dw_bytes_read;
@@ -281,7 +281,7 @@
 }
 
 
-int ft2232_speed(int speed)
+static int ft2232_speed(int speed)
 {
 	u8  buf[3];
 	int retval;
@@ -302,7 +302,7 @@
 }
 
 
-int ft2232_speed_div(int speed, int* khz)
+static int ft2232_speed_div(int speed, int* khz)
 {
 	/* Take a look in the FT2232 manual,
 	 * AN2232C-01 Command Processor for
@@ -314,7 +314,7 @@
 }
 
 
-int ft2232_khz(int khz, int* jtag_speed)
+static int ft2232_khz(int khz, int* jtag_speed)
 {
 	if (khz==0)
 	{
@@ -355,7 +355,7 @@
 }
 
 
-int ft2232_register_commands(struct command_context_s* cmd_ctx)
+static int ft2232_register_commands(struct command_context_s* cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;ft2232_device_desc&quot;, ft2232_handle_device_desc_command,
 			COMMAND_CONFIG, &quot;the USB device description of the FTDI FT2232 device&quot;);
@@ -383,7 +383,7 @@
 }
 
 
-void ft2232_read_scan(enum scan_type type, u8* buffer, int scan_size)
+static void ft2232_read_scan(enum scan_type type, u8* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
@@ -407,7 +407,7 @@
 }
 
 
-void ft2232_debug_dump_buffer(void)
+static void ft2232_debug_dump_buffer(void)
 {
 	int   i;
 	char  line[256];
@@ -428,7 +428,7 @@
 }
 
 
-int ft2232_send_and_recv(jtag_command_t* first, jtag_command_t* last)
+static int ft2232_send_and_recv(jtag_command_t* first, jtag_command_t* last)
 {
 	jtag_command_t* cmd;
 	u8*             buffer;
@@ -546,7 +546,7 @@
 }
 
 
-void ft2232_add_pathmove(pathmove_command_t* cmd)
+static void ft2232_add_pathmove(pathmove_command_t* cmd)
 {
 	int num_states = cmd-&gt;num_states;
 	int state_count = 0;
@@ -742,7 +742,7 @@
 }
 
 
-int ft2232_large_scan(scan_command_t* cmd, enum scan_type type, u8* buffer, int scan_size)
+static int ft2232_large_scan(scan_command_t* cmd, enum scan_type type, u8* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
@@ -952,7 +952,7 @@
 }
 
 
-int ft2232_predict_scan_out(int scan_size, enum scan_type type)
+static int ft2232_predict_scan_out(int scan_size, enum scan_type type)
 {
 	int predicted_size = 3;
 	int num_bytes = (scan_size - 1) / 8;
@@ -979,7 +979,7 @@
 }
 
 
-int ft2232_predict_scan_in(int scan_size, enum scan_type type)
+static int ft2232_predict_scan_in(int scan_size, enum scan_type type)
 {
 	int predicted_size = 0;
 
@@ -1001,7 +1001,7 @@
 }
 
 
-void usbjtag_reset(int trst, int srst)
+static void usbjtag_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
@@ -1040,7 +1040,7 @@
 }
 
 
-void jtagkey_reset(int trst, int srst)
+static void jtagkey_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
@@ -1081,7 +1081,7 @@
 }
 
 
-void olimex_jtag_reset(int trst, int srst)
+static void olimex_jtag_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
@@ -1116,7 +1116,7 @@
 }
 
 
-void axm0432_jtag_reset(int trst, int srst)
+static void axm0432_jtag_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
@@ -1146,7 +1146,7 @@
 }
 
 
-void flyswatter_reset(int trst, int srst)
+static void flyswatter_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
@@ -1174,7 +1174,7 @@
 }
 
 
-void turtle_reset(int trst, int srst)
+static void turtle_reset(int trst, int srst)
 {
 	trst = trst;
 
@@ -1195,7 +1195,7 @@
 }
 
 
-void comstick_reset(int trst, int srst)
+static void comstick_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
@@ -1224,7 +1224,7 @@
 }
 
 
-void stm32stick_reset(int trst, int srst)
+static void stm32stick_reset(int trst, int srst)
 {
 	if (trst == 1)
 	{
@@ -1259,7 +1259,7 @@
 
 
 
-void sheevaplug_reset(int trst, int srst)
+static void sheevaplug_reset(int trst, int srst)
 {
 	if (trst == 1)
 		high_output &amp;= ~nTRST;
@@ -1278,7 +1278,7 @@
 	LOG_DEBUG(&quot;trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x&quot;, trst, srst, high_output, high_direction);
 }
 
-int ft2232_execute_queue()
+static int ft2232_execute_queue()
 {
 	jtag_command_t* cmd = jtag_command_queue;   /* currently processed command */
 	u8*             buffer;
@@ -1755,7 +1755,7 @@
 
 #endif /* BUILD_FT2232_LIBFTDI == 1 */
 
-int ft2232_init(void)
+static int ft2232_init(void)
 {
 	u8  buf[1];
 	int retval;
@@ -1837,7 +1837,7 @@
 }
 
 
-int usbjtag_init(void)
+static int usbjtag_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -1912,7 +1912,7 @@
 }
 
 
-int axm0432_jtag_init(void)
+static int axm0432_jtag_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -1982,7 +1982,7 @@
 }
 
 
-int jtagkey_init(void)
+static int jtagkey_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -2064,7 +2064,7 @@
 }
 
 
-int olimex_jtag_init(void)
+static int olimex_jtag_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -2131,7 +2131,7 @@
 }
 
 
-int flyswatter_init(void)
+static int flyswatter_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -2178,7 +2178,7 @@
 }
 
 
-int turtle_init(void)
+static int turtle_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -2219,7 +2219,7 @@
 }
 
 
-int comstick_init(void)
+static int comstick_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -2263,7 +2263,7 @@
 }
 
 
-int stm32stick_init(void)
+static int stm32stick_init(void)
 {
 	u8  buf[3];
 	u32 bytes_written;
@@ -2307,7 +2307,7 @@
 }
 
 
-int sheevaplug_init(void)
+static int sheevaplug_init(void)
 {
 	u8 buf[3];
 	u32 bytes_written;
@@ -2358,7 +2358,7 @@
 	return ERROR_OK;
 }
 
-void olimex_jtag_blink(void)
+static void olimex_jtag_blink(void)
 {
 	/* Olimex ARM-USB-OCD has a LED connected to ACBUS3
 	 * ACBUS3 is bit 3 of the GPIOH port
@@ -2380,7 +2380,7 @@
 }
 
 
-void flyswatter_jtag_blink(void)
+static void flyswatter_jtag_blink(void)
 {
 	/*
 	 * Flyswatter has two LEDs connected to ACBUS2 and ACBUS3
@@ -2393,7 +2393,7 @@
 }
 
 
-void turtle_jtag_blink(void)
+static void turtle_jtag_blink(void)
 {
 	/*
 	 * Turtelizer2 has two LEDs connected to ACBUS2 and ACBUS3
@@ -2413,7 +2413,7 @@
 }
 
 
-int ft2232_quit(void)
+static int ft2232_quit(void)
 {
 #if BUILD_FT2232_FTD2XX == 1
 	FT_STATUS status;
@@ -2434,7 +2434,7 @@
 }
 
 
-int ft2232_handle_device_desc_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
+static int ft2232_handle_device_desc_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	char *cp;
 	char buf[200];
@@ -2469,7 +2469,7 @@
 }
 
 
-int ft2232_handle_serial_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
+static int ft2232_handle_serial_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 1)
 	{
@@ -2484,7 +2484,7 @@
 }
 
 
-int ft2232_handle_layout_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
+static int ft2232_handle_layout_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 0)
 		return ERROR_OK;
@@ -2496,7 +2496,7 @@
 }
 
 
-int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
+static int ft2232_handle_vid_pid_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	int i;
 
@@ -2529,7 +2529,7 @@
 }
 
 
-int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
+static int ft2232_handle_latency_command(struct command_context_s* cmd_ctx, char* cmd, char** args, int argc)
 {
 	if (argc == 1)
 	{

Modified: trunk/src/jtag/gw16012.c
===================================================================
--- trunk/src/jtag/gw16012.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/gw16012.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -89,13 +89,13 @@
 static int device_handle;
 #endif
 
-int gw16012_execute_queue(void);
-int gw16012_register_commands(struct command_context_s *cmd_ctx);
-int gw16012_speed(int speed);
-int gw16012_init(void);
-int gw16012_quit(void);
+static int gw16012_execute_queue(void);
+static int gw16012_register_commands(struct command_context_s *cmd_ctx);
+static int gw16012_speed(int speed);
+static int gw16012_init(void);
+static int gw16012_quit(void);
 
-int gw16012_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int gw16012_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 jtag_interface_t gw16012_interface =
 {
@@ -109,7 +109,7 @@
 	.quit = gw16012_quit,
 };
 
-int gw16012_register_commands(struct command_context_s *cmd_ctx)
+static int gw16012_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;parport_port&quot;, gw16012_handle_parport_port_command,
 					 COMMAND_CONFIG, NULL);
@@ -117,7 +117,7 @@
 	return ERROR_OK;
 }
 
-void gw16012_data(u8 value)
+static void gw16012_data(u8 value)
 {
 	value = (value &amp; 0x7f) | gw16012_msb;
 	gw16012_msb ^= 0x80; /* toggle MSB */
@@ -137,7 +137,7 @@
 	#endif
 }
 
-void gw16012_control(u8 value)
+static void gw16012_control(u8 value)
 {
 	if (value != gw16012_control_value)
 	{
@@ -159,7 +159,7 @@
 	}
 }
 
-void gw16012_input(u8 *value)
+static void gw16012_input(u8 *value)
 {
 	#if PARPORT_USE_PPDEV == 1
 		ioctl(device_handle, PPRSTATUS, value);
@@ -173,7 +173,7 @@
 }
 
 /* (1) assert or (0) deassert reset lines */
-void gw16012_reset(int trst, int srst)
+static void gw16012_reset(int trst, int srst)
 {
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
 
@@ -188,13 +188,13 @@
 		gw16012_control(0x0b);
 }
 
-int gw16012_speed(int speed)
+static int gw16012_speed(int speed)
 {
 
 	return ERROR_OK;
 }
 
-void gw16012_end_state(tap_state_t state)
+static void gw16012_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
 		tap_set_end_state(state);
@@ -205,7 +205,7 @@
 	}
 }
 
-void gw16012_state_move(void)
+static void gw16012_state_move(void)
 {
 	int i=0, tms=0;
 	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
@@ -221,7 +221,7 @@
 	tap_set_state(tap_get_end_state());
 }
 
-void gw16012_path_move(pathmove_command_t *cmd)
+static void gw16012_path_move(pathmove_command_t *cmd)
 {
 	int num_states = cmd-&gt;num_states;
 	int state_count;
@@ -252,7 +252,7 @@
 	tap_set_end_state(tap_get_state());
 }
 
-void gw16012_runtest(int num_cycles)
+static void gw16012_runtest(int num_cycles)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 	int i;
@@ -275,7 +275,7 @@
 		gw16012_state_move();
 }
 
-void gw16012_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void gw16012_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
 	int bits_left = scan_size;
 	int bit_count = 0;
@@ -348,7 +348,7 @@
 	}
 }
 
-int gw16012_execute_queue(void)
+static int gw16012_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
@@ -436,7 +436,7 @@
 }
 
 #if PARPORT_USE_GIVEIO == 1
-int gw16012_get_giveio_access()
+static int gw16012_get_giveio_access()
 {
 	HANDLE h;
 	OSVERSIONINFO version;
@@ -461,7 +461,7 @@
 }
 #endif
 
-int gw16012_init(void)
+static int gw16012_init(void)
 {
 #if PARPORT_USE_PPDEV == 1
 	char buffer[256];
@@ -555,13 +555,13 @@
 	return ERROR_OK;
 }
 
-int gw16012_quit(void)
+static int gw16012_quit(void)
 {
 
 	return ERROR_OK;
 }
 
-int gw16012_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int gw16012_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 0)
 		return ERROR_OK;

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/jlink.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -77,33 +77,33 @@
 #define JLINK_MAX_SPEED 12000
 
 /* External interface functions */
-int jlink_execute_queue(void);
-int jlink_speed(int speed);
-int jlink_speed_div(int speed, int* khz);
-int jlink_khz(int khz, int *jtag_speed);
-int jlink_register_commands(struct command_context_s *cmd_ctx);
-int jlink_init(void);
-int jlink_quit(void);
+static int jlink_execute_queue(void);
+static int jlink_speed(int speed);
+static int jlink_speed_div(int speed, int* khz);
+static int jlink_khz(int khz, int *jtag_speed);
+static int jlink_register_commands(struct command_context_s *cmd_ctx);
+static int jlink_init(void);
+static int jlink_quit(void);
 
 /* CLI command handler functions */
-int jlink_handle_jlink_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int jlink_handle_jlink_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 /* Queue command functions */
-void jlink_end_state(tap_state_t state);
-void jlink_state_move(void);
-void jlink_path_move(int num_states, tap_state_t *path);
-void jlink_runtest(int num_cycles);
-void jlink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
-void jlink_reset(int trst, int srst);
-void jlink_simple_command(u8 command);
-int jlink_get_status(void);
+static void jlink_end_state(tap_state_t state);
+static void jlink_state_move(void);
+static void jlink_path_move(int num_states, tap_state_t *path);
+static void jlink_runtest(int num_cycles);
+static void jlink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void jlink_reset(int trst, int srst);
+static void jlink_simple_command(u8 command);
+static int jlink_get_status(void);
 
 /* J-Link tap buffer functions */
-void jlink_tap_init(void);
-int jlink_tap_execute(void);
-void jlink_tap_ensure_space(int scans, int bits);
-void jlink_tap_append_step(int tms, int tdi);
-void jlink_tap_append_scan(int length, u8 *buffer, scan_command_t *command);
+static void jlink_tap_init(void);
+static int jlink_tap_execute(void);
+static void jlink_tap_ensure_space(int scans, int bits);
+static void jlink_tap_append_step(int tms, int tdi);
+static void jlink_tap_append_scan(int length, u8 *buffer, scan_command_t *command);
 
 /* Jlink lowlevel functions */
 typedef struct jlink_jtag
@@ -111,21 +111,21 @@
 	struct usb_dev_handle* usb_handle;
 } jlink_jtag_t;
 
-jlink_jtag_t *jlink_usb_open(void);
-void jlink_usb_close(jlink_jtag_t *jlink_jtag);
-int jlink_usb_message(jlink_jtag_t *jlink_jtag, int out_length, int in_length);
-int jlink_usb_write(jlink_jtag_t *jlink_jtag, int out_length);
-int jlink_usb_read(jlink_jtag_t *jlink_jtag, int expected_size);
-int jlink_usb_read_emu_result(jlink_jtag_t *jlink_jtag);
+static jlink_jtag_t *jlink_usb_open(void);
+static void jlink_usb_close(jlink_jtag_t *jlink_jtag);
+static int jlink_usb_message(jlink_jtag_t *jlink_jtag, int out_length, int in_length);
+static int jlink_usb_write(jlink_jtag_t *jlink_jtag, int out_length);
+static int jlink_usb_read(jlink_jtag_t *jlink_jtag, int expected_size);
+static int jlink_usb_read_emu_result(jlink_jtag_t *jlink_jtag);
 
 /* helper functions */
-int jlink_get_version_info(void);
+static int jlink_get_version_info(void);
 
 #ifdef _DEBUG_USB_COMMS_
-void jlink_debug_buffer(u8 *buffer, int length);
+static void jlink_debug_buffer(u8 *buffer, int length);
 #endif
 
-jlink_jtag_t* jlink_jtag_handle;
+static jlink_jtag_t* jlink_jtag_handle;
 
 /***************************************************************************/
 /* External interface implementation */
@@ -142,7 +142,7 @@
 	.quit = jlink_quit
 };
 
-int jlink_execute_queue(void)
+static int jlink_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue;
 	int scan_size;
@@ -238,7 +238,7 @@
 }
 
 /* Sets speed in kHz. */
-int jlink_speed(int speed)
+static int jlink_speed(int speed)
 {
 	int result;
 
@@ -272,28 +272,28 @@
 	return ERROR_OK;
 }
 
-int jlink_speed_div(int speed, int* khz)
+static int jlink_speed_div(int speed, int* khz)
 {
 	*khz = speed;
 
 	return ERROR_OK;
 }
 
-int jlink_khz(int khz, int *jtag_speed)
+static int jlink_khz(int khz, int *jtag_speed)
 {
 	*jtag_speed = khz;
 
 	return ERROR_OK;
 }
 
-int jlink_register_commands(struct command_context_s *cmd_ctx)
+static int jlink_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;jlink_info&quot;, jlink_handle_jlink_info_command, COMMAND_EXEC,
 		&quot;query jlink info&quot;);
 	return ERROR_OK;
 }
 
-int jlink_init(void)
+static int jlink_init(void)
 {
 	int check_cnt;
 
@@ -331,7 +331,7 @@
 	return ERROR_OK;
 }
 
-int jlink_quit(void)
+static int jlink_quit(void)
 {
 	jlink_usb_close(jlink_jtag_handle);
 	return ERROR_OK;
@@ -340,7 +340,7 @@
 /***************************************************************************/
 /* Queue command implementations */
 
-void jlink_end_state(tap_state_t state)
+static void jlink_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
 	{
@@ -354,7 +354,7 @@
 }
 
 /* Goes to the end state. */
-void jlink_state_move(void)
+static void jlink_state_move(void)
 {
 	int i;
 	int tms = 0;
@@ -369,7 +369,7 @@
 	tap_set_state(tap_get_end_state());
 }
 
-void jlink_path_move(int num_states, tap_state_t *path)
+static void jlink_path_move(int num_states, tap_state_t *path)
 {
 	int i;
 
@@ -395,7 +395,7 @@
 	tap_set_end_state(tap_get_state());
 }
 
-void jlink_runtest(int num_cycles)
+static void jlink_runtest(int num_cycles)
 {
 	int i;
 
@@ -422,7 +422,7 @@
 	}
 }
 
-void jlink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void jlink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
 
@@ -453,7 +453,7 @@
 	}
 }
 
-void jlink_reset(int trst, int srst)
+static void jlink_reset(int trst, int srst)
 {
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
 
@@ -477,7 +477,7 @@
 	}
 }
 
-void jlink_simple_command(u8 command)
+static void jlink_simple_command(u8 command)
 {
 	int result;
 
@@ -492,7 +492,7 @@
 	}
 }
 
-int jlink_get_status(void)
+static int jlink_get_status(void)
 {
 	int result;
 
@@ -520,7 +520,7 @@
 	return ERROR_OK;
 }
 
-int jlink_get_version_info(void)
+static int jlink_get_version_info(void)
 {
 	int result;
 	int len = 0;
@@ -546,7 +546,7 @@
 	return ERROR_JTAG_DEVICE_ERROR;
 }
 
-int jlink_handle_jlink_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int jlink_handle_jlink_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (jlink_get_version_info() == ERROR_OK)
 	{
@@ -583,13 +583,13 @@
 
 static int last_tms;
 
-void jlink_tap_init(void)
+static void jlink_tap_init(void)
 {
 	tap_length = 0;
 	pending_scan_results_length = 0;
 }
 
-void jlink_tap_ensure_space(int scans, int bits)
+static void jlink_tap_ensure_space(int scans, int bits)
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bits = JLINK_TAP_BUFFER_SIZE * 8 - tap_length;
@@ -600,7 +600,7 @@
 	}
 }
 
-void jlink_tap_append_step(int tms, int tdi)
+static void jlink_tap_append_step(int tms, int tdi)
 {
 	last_tms = tms;
 	int index = tap_length / 8;
@@ -636,7 +636,7 @@
 	}
 }
 
-void jlink_tap_append_scan(int length, u8 *buffer, scan_command_t *command)
+static void jlink_tap_append_scan(int length, u8 *buffer, scan_command_t *command)
 {
 	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 	int i;
@@ -655,7 +655,7 @@
 
 /* Pad and send a tap sequence to the device, and receive the answer.
  * For the purpose of padding we assume that we are in idle or pause state. */
-int jlink_tap_execute(void)
+static int jlink_tap_execute(void)
 {
 	int byte_length;
 	int tms_offset;
@@ -745,7 +745,7 @@
 /*****************************************************************************/
 /* JLink USB low-level functions */
 
-jlink_jtag_t* jlink_usb_open()
+static jlink_jtag_t* jlink_usb_open()
 {
 	struct usb_bus *busses;
 	struct usb_bus *bus;
@@ -791,14 +791,14 @@
 	return NULL;
 }
 
-void jlink_usb_close(jlink_jtag_t *jlink_jtag)
+static void jlink_usb_close(jlink_jtag_t *jlink_jtag)
 {
 	usb_close(jlink_jtag-&gt;usb_handle);
 	free(jlink_jtag);
 }
 
 /* Send a message and receive the reply. */
-int jlink_usb_message(jlink_jtag_t *jlink_jtag, int out_length, int in_length)
+static int jlink_usb_message(jlink_jtag_t *jlink_jtag, int out_length, int in_length)
 {
 	int result;
 	int result2;
@@ -859,7 +859,7 @@
 	}
 }
 
-int usb_bulk_write_ex(usb_dev_handle *dev, int ep, char *bytes, int size,
+static int usb_bulk_write_ex(usb_dev_handle *dev, int ep, char *bytes, int size,
                       int timeout) {
 
 	int rc = 0, tries = 3, this_size;
@@ -883,7 +883,7 @@
 
 }
 
-int usb_bulk_read_ex(usb_dev_handle *dev, int ep, char *bytes, int size,
+static int usb_bulk_read_ex(usb_dev_handle *dev, int ep, char *bytes, int size,
                   int timeout) {
 
 	int rc = 0, tries = 3, this_size;
@@ -908,7 +908,7 @@
 
 
 /* Write data from out_buffer to USB. */
-int jlink_usb_write(jlink_jtag_t *jlink_jtag, int out_length)
+static int jlink_usb_write(jlink_jtag_t *jlink_jtag, int out_length)
 {
 	int result;
 
@@ -930,7 +930,7 @@
 }
 
 /* Read data from USB into in_buffer. */
-int jlink_usb_read(jlink_jtag_t *jlink_jtag, int expected_size)
+static int jlink_usb_read(jlink_jtag_t *jlink_jtag, int expected_size)
 {
 	int result = usb_bulk_read_ex(jlink_jtag-&gt;usb_handle, JLINK_READ_ENDPOINT,
 		(char *)usb_in_buffer, expected_size, JLINK_USB_TIMEOUT);
@@ -944,7 +944,7 @@
 }
 
 /* Read the result from the previous EMU cmd into result_buffer. */
-int jlink_usb_read_emu_result(jlink_jtag_t *jlink_jtag)
+static int jlink_usb_read_emu_result(jlink_jtag_t *jlink_jtag)
 {
 	int result = usb_bulk_read_ex(jlink_jtag-&gt;usb_handle, JLINK_READ_ENDPOINT,
 		(char *)usb_emu_result_buffer, 1 /* JLINK_EMU_RESULT_BUFFER_SIZE */,
@@ -961,7 +961,7 @@
 #ifdef _DEBUG_USB_COMMS_
 #define BYTES_PER_LINE  16
 
-void jlink_debug_buffer(u8 *buffer, int length)
+static void jlink_debug_buffer(u8 *buffer, int length)
 {
 	char line[81];
 	char s[4];

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/jtag.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -80,8 +80,8 @@
 int jtag_verify_capture_ir = 1;
 
 /* how long the OpenOCD should wait before attempting JTAG communication after reset lines deasserted (in ms) */
-int jtag_nsrst_delay = 0; /* default to no nSRST delay */
-int jtag_ntrst_delay = 0; /* default to no nTRST delay */
+static int jtag_nsrst_delay = 0; /* default to no nSRST delay */
+static int jtag_ntrst_delay = 0; /* default to no nTRST delay */
 
 /* maximum number of JTAG devices expected in the chain
  */
@@ -210,35 +210,35 @@
 jtag_interface_t *jtag = NULL;
 
 /* configuration */
-jtag_interface_t *jtag_interface = NULL;
+static jtag_interface_t *jtag_interface = NULL;
 int jtag_speed = 0;
 
 /* forward declarations */
-void jtag_add_pathmove(int num_states, tap_state_t *path);
-void jtag_add_runtest(int num_cycles, tap_state_t endstate);
-void jtag_add_end_state(tap_state_t endstate);
-void jtag_add_sleep(u32 us);
-int jtag_execute_queue(void);
-tap_state_t tap_state_by_name(const char *name);
+//void jtag_add_pathmove(int num_states, tap_state_t *path);
+//void jtag_add_runtest(int num_cycles, tap_state_t endstate);
+//void jtag_add_end_state(tap_state_t endstate);
+//void jtag_add_sleep(u32 us);
+//int jtag_execute_queue(void);
+static tap_state_t tap_state_by_name(const char *name);
 
 /* jtag commands */
-int handle_interface_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_jtag_speed_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_jtag_khz_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_jtag_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_reset_config_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_jtag_nsrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_jtag_ntrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_interface_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_speed_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_khz_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_reset_config_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_nsrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_ntrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-int handle_scan_chain_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_scan_chain_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-int handle_endstate_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_jtag_reset_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_runtest_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int handle_irscan_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
+static int handle_endstate_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_reset_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_runtest_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_irscan_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
 
-int handle_verify_ircapture_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_verify_ircapture_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 jtag_tap_t *jtag_AllTaps(void)
 {
@@ -2305,7 +2305,7 @@
 	return ERROR_OK;
 }
 
-int handle_interface_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_interface_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int i;
 	int retval;
@@ -2368,7 +2368,7 @@
 	return ERROR_JTAG_INVALID_INTERFACE;
 }
 
-int handle_jtag_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_jtag_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int e;
 	char buf[1024];
@@ -2429,7 +2429,7 @@
 	return e;
 }
 
-int handle_scan_chain_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_scan_chain_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	jtag_tap_t *tap;
 
@@ -2466,7 +2466,7 @@
 	return ERROR_OK;
 }
 
-int handle_reset_config_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_reset_config_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc &lt; 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -2542,7 +2542,7 @@
 	return ERROR_OK;
 }
 
-int handle_jtag_nsrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_jtag_nsrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc &lt; 1)
 	{
@@ -2557,7 +2557,7 @@
 	return ERROR_OK;
 }
 
-int handle_jtag_ntrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_jtag_ntrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc &lt; 1)
 	{
@@ -2572,7 +2572,7 @@
 	return ERROR_OK;
 }
 
-int handle_jtag_speed_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_jtag_speed_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int retval=ERROR_OK;
 
@@ -2600,7 +2600,7 @@
 	return retval;
 }
 
-int handle_jtag_khz_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_jtag_khz_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int retval=ERROR_OK;
 	LOG_DEBUG(&quot;handle jtag khz&quot;);
@@ -2650,7 +2650,7 @@
 
 }
 
-int handle_endstate_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_endstate_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	tap_state_t state;
 
@@ -2673,7 +2673,7 @@
 	return ERROR_OK;
 }
 
-int handle_jtag_reset_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_jtag_reset_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int trst = -1;
 	int srst = -1;
@@ -2710,7 +2710,7 @@
 	return ERROR_OK;
 }
 
-int handle_runtest_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_runtest_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc &lt; 1)
 	{
@@ -2724,7 +2724,7 @@
 
 }
 
-int handle_irscan_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_irscan_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int i;
 	scan_field_t *fields;
@@ -2799,7 +2799,7 @@
 	return ERROR_OK;
 }
 
-int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args)
+static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args)
 {
 	int retval;
 	scan_field_t *fields;
@@ -2936,7 +2936,7 @@
 	return JIM_OK;
 }
 
-int handle_verify_ircapture_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_verify_ircapture_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 1)
 	{
@@ -3269,7 +3269,7 @@
 	return ret;
 }
 
-tap_state_t tap_state_by_name( const char *name )
+static tap_state_t tap_state_by_name( const char *name )
 {
 	tap_state_t x;
 

Modified: trunk/src/jtag/parport.c
===================================================================
--- trunk/src/jtag/parport.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/parport.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -96,7 +96,7 @@
 	u8 LED_MASK;	/* data port bit for LED */
 } cable_t;
 
-cable_t cables[] = 
+static cable_t cables[] = 
 {	
 	/* name					tdo   trst  tms   tck   tdi   srst  o_inv i_inv init  exit  led */
 	{ &quot;wiggler&quot;,			0x80, 0x10, 0x02, 0x04, 0x08, 0x01, 0x01, 0x80, 0x80, 0x80, 0x00 },
@@ -123,8 +123,8 @@
 };
 
 /* configuration */
-char* parport_cable = NULL;
-u16 parport_port;
+static char* parport_cable = NULL;
+static u16 parport_port;
 static int parport_exit = 0;
 
 /* interface variables
@@ -141,20 +141,20 @@
 
 /* low level command set
  */
-int parport_read(void);
-void parport_write(int tck, int tms, int tdi);
-void parport_reset(int trst, int srst);
-void parport_led(int on);
+static int parport_read(void);
+static void parport_write(int tck, int tms, int tdi);
+static void parport_reset(int trst, int srst);
+static void parport_led(int on);
 
-int parport_speed(int speed);
-int parport_register_commands(struct command_context_s *cmd_ctx);
-int parport_init(void);
-int parport_quit(void);
+static int parport_speed(int speed);
+static int parport_register_commands(struct command_context_s *cmd_ctx);
+static int parport_init(void);
+static int parport_quit(void);
 
 /* interface commands */
-int parport_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int parport_handle_parport_cable_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int parport_handle_write_on_exit_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int parport_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int parport_handle_parport_cable_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int parport_handle_write_on_exit_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 jtag_interface_t parport_interface = 
 {
@@ -168,7 +168,7 @@
 	.quit = parport_quit,
 };
 
-bitbang_interface_t parport_bitbang =
+static bitbang_interface_t parport_bitbang =
 {
 	.read = parport_read,
 	.write = parport_write,
@@ -176,7 +176,7 @@
 	.blink = parport_led
 };
 
-int parport_read(void)
+static int parport_read(void)
 {
 	int data = 0;
 	
@@ -208,7 +208,7 @@
 #endif
 }
 
-void parport_write(int tck, int tms, int tdi)
+static void parport_write(int tck, int tms, int tdi)
 {
 	int i = jtag_speed + 1;
 	
@@ -232,7 +232,7 @@
 }
 
 /* (1) assert or (0) deassert reset lines */
-void parport_reset(int trst, int srst)
+static void parport_reset(int trst, int srst)
 {
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
 
@@ -250,7 +250,7 @@
 }
 	
 /* turn LED on parport adapter on (1) or off (0) */
-void parport_led(int on)
+static void parport_led(int on)
 {
 	if (on)
 		dataport_value |= cable-&gt;LED_MASK;
@@ -260,12 +260,12 @@
 	parport_write_data();
 }
 
-int parport_speed(int speed)
+static int parport_speed(int speed)
 {
 	return ERROR_OK;
 }
 
-int parport_register_commands(struct command_context_s *cmd_ctx)
+static int parport_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;parport_port&quot;, parport_handle_parport_port_command,
 		COMMAND_CONFIG, &quot;either the address of the I/O port or the number of the &#145;/dev/parport&#146; device&quot;);
@@ -278,7 +278,7 @@
 }
 
 #if PARPORT_USE_GIVEIO == 1
-int parport_get_giveio_access(void)
+static int parport_get_giveio_access(void)
 {
 	HANDLE h;
 	OSVERSIONINFO version;
@@ -303,7 +303,7 @@
 }
 #endif
 
-int parport_init(void)
+static int parport_init(void)
 {
 	cable_t *cur_cable;
 #if PARPORT_USE_PPDEV == 1
@@ -429,7 +429,7 @@
 	return ERROR_OK;
 }
 
-int parport_quit(void)
+static int parport_quit(void)
 {
 	parport_led(0);
 
@@ -448,7 +448,7 @@
 	return ERROR_OK;
 }
 
-int parport_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int parport_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 0)
 		return ERROR_OK;
@@ -460,7 +460,7 @@
 	return ERROR_OK;
 }
 
-int parport_handle_parport_cable_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int parport_handle_parport_cable_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 0)
 		return ERROR_OK;
@@ -475,7 +475,7 @@
 	return ERROR_OK;
 }
 
-int parport_handle_write_on_exit_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int parport_handle_write_on_exit_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1)
 	{

Modified: trunk/src/jtag/presto.c
===================================================================
--- trunk/src/jtag/presto.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/presto.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -49,12 +49,12 @@
 #error &quot;BUG: either FTD2XX and LIBFTDI has to be used&quot;
 #endif
 
-int presto_jtag_speed(int speed);
-int presto_jtag_khz(int khz, int *jtag_speed);
-int presto_jtag_speed_div(int speed, int *khz);
-int presto_jtag_register_commands(struct command_context_s *cmd_ctx);
-int presto_jtag_init(void);
-int presto_jtag_quit(void);
+static int presto_jtag_speed(int speed);
+static int presto_jtag_khz(int khz, int *jtag_speed);
+static int presto_jtag_speed_div(int speed, int *khz);
+static int presto_jtag_register_commands(struct command_context_s *cmd_ctx);
+static int presto_jtag_init(void);
+static int presto_jtag_quit(void);
 
 jtag_interface_t presto_interface =
 {
@@ -68,14 +68,14 @@
 	.quit = presto_jtag_quit,
 };
 
-int presto_bitq_out(int tms, int tdi, int tdo_req);
-int presto_bitq_flush(void);
-int presto_bitq_sleep(unsigned long us);
-int presto_bitq_reset(int trst, int srst);
-int presto_bitq_in_rdy(void);
-int presto_bitq_in(void);
+static int presto_bitq_out(int tms, int tdi, int tdo_req);
+static int presto_bitq_flush(void);
+static int presto_bitq_sleep(unsigned long us);
+static int presto_bitq_reset(int trst, int srst);
+static int presto_bitq_in_rdy(void);
+static int presto_bitq_in(void);
 
-bitq_interface_t presto_bitq =
+static bitq_interface_t presto_bitq =
 {
 	.out = presto_bitq_out,
 	.flush = presto_bitq_flush,
@@ -130,15 +130,15 @@
 	
 } presto_t;
 
-presto_t presto_state;
-presto_t *presto = &amp;presto_state;
+static presto_t presto_state;
+static presto_t *presto = &amp;presto_state;
 
-u8 presto_init_seq[] =
+static u8 presto_init_seq[] =
 {
 	0x80, 0xA0, 0xA8, 0xB0, 0xC0, 0xE0
 };
 
-int presto_write(u8 *buf, u32 size)
+static int presto_write(u8 *buf, u32 size)
 {
 #if BUILD_PRESTO_FTD2XX == 1
 	DWORD ftbytes;
@@ -167,7 +167,7 @@
 	return ERROR_OK;
 }
 
-int presto_read(u8* buf, u32 size)
+static int presto_read(u8* buf, u32 size)
 {
 #if BUILD_PRESTO_FTD2XX == 1
 	DWORD ftbytes;
@@ -210,7 +210,7 @@
 }
 
 #if BUILD_PRESTO_FTD2XX == 1
-int presto_open_ftd2xx(char *req_serial)
+static int presto_open_ftd2xx(char *req_serial)
 {
 	u32 i;
 	DWORD numdevs;
@@ -340,7 +340,7 @@
 }
 
 #elif BUILD_PRESTO_LIBFTDI == 1
-int presto_open_libftdi(char *req_serial)
+static int presto_open_libftdi(char *req_serial)
 {
 	u8 presto_data;
 
@@ -413,7 +413,7 @@
 }
 #endif /* BUILD_PRESTO_LIBFTDI == 1 */
 
-int presto_open(char *req_serial)
+static int presto_open(char *req_serial)
 {
 	presto-&gt;buff_out_pos=0;
 	presto-&gt;buff_in_pos=0;
@@ -438,7 +438,7 @@
 #endif
 }
 
-int presto_close(void)
+static int presto_close(void)
 {
 
 	int result = ERROR_OK;
@@ -482,7 +482,7 @@
 	return result;
 }
 
-int presto_flush(void)
+static int presto_flush(void)
 {
 	if (presto-&gt;buff_out_pos == 0)
 		return ERROR_OK;
@@ -525,7 +525,7 @@
 	return ERROR_OK;
 }
 
-int presto_sendbyte(int data)
+static int presto_sendbyte(int data)
 {
 	if (data == EOF) return presto_flush();
 
@@ -549,7 +549,8 @@
 	return ERROR_OK;
 }
 
-int presto_getbyte(void)
+#if 0
+static int presto_getbyte(void)
 {
 	if (presto-&gt;buff_in_pos &lt; presto-&gt;buff_in_len)
 		return presto-&gt;buff_in[presto-&gt;buff_in_pos++];
@@ -565,10 +566,11 @@
 
 	return -1;
 }
+#endif
 
 /* -------------------------------------------------------------------------- */
 
-int presto_tdi_flush(void)
+static int presto_tdi_flush(void)
 {
 	if (presto-&gt;jtag_tdi_count == 0)
 		return 0;
@@ -587,7 +589,7 @@
 	return 0;
 }
 
-int presto_tck_idle(void)
+static int presto_tck_idle(void)
 {
 	if (presto-&gt;jtag_tck == 1)
 	{
@@ -600,7 +602,7 @@
 
 /* -------------------------------------------------------------------------- */
 
-int presto_bitq_out(int tms, int tdi, int tdo_req)
+static int presto_bitq_out(int tms, int tdi, int tdo_req)
 {
 	int i;
 	unsigned char cmd;
@@ -646,7 +648,7 @@
 	return 0;
 }
 
-int presto_bitq_flush(void)
+static int presto_bitq_flush(void)
 {
 	presto_tdi_flush();
 	presto_tck_idle();
@@ -656,14 +658,14 @@
 	return presto_flush();
 }
 
-int presto_bitq_in_rdy(void)
+static int presto_bitq_in_rdy(void)
 {
 	if (presto-&gt;buff_in_pos&gt;=presto-&gt;buff_in_len)
 		return 0;
 	return presto-&gt;buff_in_len-presto-&gt;buff_in_pos;
 }
 
-int presto_bitq_in(void)
+static int presto_bitq_in(void)
 {
 	if (presto-&gt;buff_in_pos&gt;=presto-&gt;buff_in_len)
 		return -1;
@@ -671,7 +673,7 @@
 	return 0;
 }
 
-int presto_bitq_sleep(unsigned long us)
+static int presto_bitq_sleep(unsigned long us)
 {
 	long waits;
 
@@ -692,7 +694,7 @@
 	return 0;
 }
 
-int presto_bitq_reset(int trst, int srst)
+static int presto_bitq_reset(int trst, int srst)
 {
 	presto_tdi_flush();
 	presto_tck_idle();
@@ -709,7 +711,7 @@
 
 /* -------------------------------------------------------------------------- */
 
-int presto_jtag_khz(int khz, int *jtag_speed)
+static int presto_jtag_khz(int khz, int *jtag_speed)
 {
 	if (khz &lt; 0)
 	{
@@ -723,7 +725,7 @@
 	return 0;
 }
 
-int presto_jtag_speed_div(int speed, int *khz)
+static int presto_jtag_speed_div(int speed, int *khz)
 {
 	if ((speed &lt; 0) || (speed &gt; 1000))
 	{
@@ -737,7 +739,7 @@
 	return 0;
 }
 
-int presto_jtag_speed(int speed)
+static int presto_jtag_speed(int speed)
 {
 	int khz;
 	
@@ -756,9 +758,9 @@
 	return 0;
 }
 
-char *presto_serial;
+static char *presto_serial;
 
-int presto_handle_serial_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int presto_handle_serial_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc == 1)
 	{
@@ -774,14 +776,14 @@
 	return ERROR_OK;
 }
 
-int presto_jtag_register_commands(struct command_context_s *cmd_ctx)
+static int presto_jtag_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;presto_serial&quot;, presto_handle_serial_command,
 		COMMAND_CONFIG, NULL);
 	return ERROR_OK;
 }
 
-int presto_jtag_init(void)
+static int presto_jtag_init(void)
 {
 	if (presto_open(presto_serial) != ERROR_OK)
 	{
@@ -801,7 +803,7 @@
 	return ERROR_OK;
 }
 
-int presto_jtag_quit(void)
+static int presto_jtag_quit(void)
 {
 	bitq_cleanup();
 	presto_close();

Modified: trunk/src/jtag/usbprog.c
===================================================================
--- trunk/src/jtag/usbprog.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/usbprog.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -52,17 +52,17 @@
 #define TCK_BIT			2
 #define TMS_BIT			1
 
-int usbprog_execute_queue(void);
-int usbprog_speed(int speed);
-int usbprog_register_commands(struct command_context_s *cmd_ctx);
-int usbprog_init(void);
-int usbprog_quit(void);
+static int usbprog_execute_queue(void);
+static int usbprog_speed(int speed);
+static int usbprog_register_commands(struct command_context_s *cmd_ctx);
+static int usbprog_init(void);
+static int usbprog_quit(void);
 
-void usbprog_end_state(tap_state_t state);
-void usbprog_state_move(void);
-void usbprog_path_move(pathmove_command_t *cmd);
-void usbprog_runtest(int num_cycles);
-void usbprog_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size);
+static void usbprog_end_state(tap_state_t state);
+static void usbprog_state_move(void);
+static void usbprog_path_move(pathmove_command_t *cmd);
+static void usbprog_runtest(int num_cycles);
+static void usbprog_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size);
 
 jtag_interface_t usbprog_interface =
 {
@@ -91,43 +91,44 @@
 	struct usb_dev_handle* usb_handle;
 };
 
-struct usbprog_jtag * usbprog_jtag_handle;
+static struct usbprog_jtag * usbprog_jtag_handle;
 
-struct usbprog_jtag* usbprog_jtag_open(void);
-void usbprog_jtag_close(struct usbprog_jtag *usbprog_jtag);
-void usbprog_jtag_init(struct usbprog_jtag *usbprog_jtag);
-unsigned char usbprog_jtag_message(struct usbprog_jtag *usbprog_jtag, char *msg, int msglen);
+static struct usbprog_jtag* usbprog_jtag_open(void);
+//static void usbprog_jtag_close(struct usbprog_jtag *usbprog_jtag);
+static void usbprog_jtag_init(struct usbprog_jtag *usbprog_jtag);
+static unsigned char usbprog_jtag_message(struct usbprog_jtag *usbprog_jtag, char *msg, int msglen);
 
-void usbprog_jtag_read_tdo(struct usbprog_jtag *usbprog_jtag, char * buffer, int size);
-void usbprog_jtag_write_tdi(struct usbprog_jtag *usbprog_jtag, char * buffer, int size);
-void usbprog_jtag_write_and_read(struct usbprog_jtag *usbprog_jtag, char * buffer, int size);
-void usbprog_jtag_write_tms(struct usbprog_jtag *usbprog_jtag, char tms_scan);
+static void usbprog_jtag_read_tdo(struct usbprog_jtag *usbprog_jtag, char * buffer, int size);
+static void usbprog_jtag_write_tdi(struct usbprog_jtag *usbprog_jtag, char * buffer, int size);
+static void usbprog_jtag_write_and_read(struct usbprog_jtag *usbprog_jtag, char * buffer, int size);
+static void usbprog_jtag_write_tms(struct usbprog_jtag *usbprog_jtag, char tms_scan);
 
-char tms_chain[64];
-int tms_chain_index;
-void usbprog_jtag_tms_collect(char tms_scan);
-void usbprog_jtag_tms_send(struct usbprog_jtag *usbprog_jtag);
+static char tms_chain[64];
+static int tms_chain_index;
 
-void usbprog_write(int tck, int tms, int tdi);
-void usbprog_reset(int trst, int srst);
+static void usbprog_jtag_tms_collect(char tms_scan);
+static void usbprog_jtag_tms_send(struct usbprog_jtag *usbprog_jtag);
 
-void usbprog_jtag_set_direction(struct usbprog_jtag *usbprog_jtag, unsigned char direction);
-void usbprog_jtag_write_slice(struct usbprog_jtag *usbprog_jtag,unsigned char value);
-unsigned char usbprog_jtag_get_port(struct usbprog_jtag *usbprog_jtag);
-void usbprog_jtag_set_bit(struct usbprog_jtag *usbprog_jtag,int bit, int value);
-int usbprog_jtag_get_bit(struct usbprog_jtag *usbprog_jtag, int bit);
+static void usbprog_write(int tck, int tms, int tdi);
+static void usbprog_reset(int trst, int srst);
 
-int usbprog_speed(int speed)
+static void usbprog_jtag_set_direction(struct usbprog_jtag *usbprog_jtag, unsigned char direction);
+static void usbprog_jtag_write_slice(struct usbprog_jtag *usbprog_jtag,unsigned char value);
+//static unsigned char usbprog_jtag_get_port(struct usbprog_jtag *usbprog_jtag);
+static void usbprog_jtag_set_bit(struct usbprog_jtag *usbprog_jtag,int bit, int value);
+//static int usbprog_jtag_get_bit(struct usbprog_jtag *usbprog_jtag, int bit);
+
+static int usbprog_speed(int speed)
 {
 	return ERROR_OK;
 }
 
-int usbprog_register_commands(struct command_context_s *cmd_ctx)
+static int usbprog_register_commands(struct command_context_s *cmd_ctx)
 {
 	return ERROR_OK;
 }
 
-int usbprog_execute_queue(void)
+static int usbprog_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
@@ -209,7 +210,7 @@
 	return ERROR_OK;
 }
 
-int usbprog_init(void)
+static int usbprog_init(void)
 {
 	usbprog_jtag_handle = usbprog_jtag_open();
 
@@ -229,13 +230,13 @@
 	return ERROR_OK;
 }
 
-int usbprog_quit(void)
+static int usbprog_quit(void)
 {
 	return ERROR_OK;
 }
 
 /*************** jtag execute commands **********************/
-void usbprog_end_state(tap_state_t state)
+static void usbprog_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
 		tap_set_end_state(state);
@@ -246,7 +247,7 @@
 	}
 }
 
-void usbprog_state_move(void)
+static void usbprog_state_move(void)
 {
 	int i = 0, tms = 0;
 	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
@@ -260,7 +261,7 @@
 	tap_set_state(tap_get_end_state());
 }
 
-void usbprog_path_move(pathmove_command_t *cmd)
+static void usbprog_path_move(pathmove_command_t *cmd)
 {
 	int num_states = cmd-&gt;num_states;
 	int state_count;
@@ -298,7 +299,7 @@
 	tap_set_end_state(tap_get_state());
 }
 
-void usbprog_runtest(int num_cycles)
+static void usbprog_runtest(int num_cycles)
 {
 	int i;
 
@@ -339,7 +340,7 @@
 	*/
 }
 
-void usbprog_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void usbprog_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 
@@ -379,7 +380,7 @@
 
 /*************** jtag wrapper functions *********************/
 
-void usbprog_write(int tck, int tms, int tdi)
+static void usbprog_write(int tck, int tms, int tdi)
 {
 	unsigned char output_value=0x00;
 
@@ -394,7 +395,7 @@
 }
 
 /* (1) assert or (0) deassert reset lines */
-void usbprog_reset(int trst, int srst)
+static void usbprog_reset(int trst, int srst)
 {
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
 
@@ -449,13 +450,15 @@
 	return 0;
 }
 
-void usbprog_jtag_close(struct usbprog_jtag *usbprog_jtag)
+#if 0
+static void usbprog_jtag_close(struct usbprog_jtag *usbprog_jtag)
 {
 	usb_close(usbprog_jtag-&gt;usb_handle);
 	free(usbprog_jtag);
 }
+#endif
 
-unsigned char usbprog_jtag_message(struct usbprog_jtag *usbprog_jtag, char *msg, int msglen)
+static unsigned char usbprog_jtag_message(struct usbprog_jtag *usbprog_jtag, char *msg, int msglen)
 {
 	int res = usb_bulk_write(usbprog_jtag-&gt;usb_handle, 3, msg,msglen, 100);
 	if ((msg[0] == 2) || (msg[0] == 1) || (msg[0] == 4) || (msg[0] == 0) || \
@@ -475,12 +478,12 @@
 	return 0;
 }
 
-void usbprog_jtag_init(struct usbprog_jtag *usbprog_jtag)
+static void usbprog_jtag_init(struct usbprog_jtag *usbprog_jtag)
 {
 	usbprog_jtag_set_direction(usbprog_jtag, 0xFE);
 }
 
-void usbprog_jtag_write_and_read(struct usbprog_jtag *usbprog_jtag, char * buffer, int size)
+static void usbprog_jtag_write_and_read(struct usbprog_jtag *usbprog_jtag, char * buffer, int size)
 {
 	char tmp[64];	/* fastes packet size for usb controller */
 	int send_bits, bufindex = 0, fillindex = 0, i, loops;
@@ -535,7 +538,7 @@
 	}
 }
 
-void usbprog_jtag_read_tdo(struct usbprog_jtag *usbprog_jtag, char * buffer, int size)
+static void usbprog_jtag_read_tdo(struct usbprog_jtag *usbprog_jtag, char * buffer, int size)
 {
 	char tmp[64];	/* fastes packet size for usb controller */
 	int send_bits, fillindex = 0, i, loops;
@@ -582,7 +585,7 @@
 	}
 }
 
-void usbprog_jtag_write_tdi(struct usbprog_jtag *usbprog_jtag, char * buffer, int size)
+static void usbprog_jtag_write_tdi(struct usbprog_jtag *usbprog_jtag, char * buffer, int size)
 {
 	char tmp[64];	/* fastes packet size for usb controller */
 	int send_bits, bufindex = 0, i, loops;
@@ -618,12 +621,12 @@
 	}
 }
 
-void usbprog_jtag_write_tms(struct usbprog_jtag *usbprog_jtag, char tms_scan)
+static void usbprog_jtag_write_tms(struct usbprog_jtag *usbprog_jtag, char tms_scan)
 {
 	usbprog_jtag_tms_collect(tms_scan);
 }
 
-void usbprog_jtag_set_direction(struct usbprog_jtag *usbprog_jtag, unsigned char direction)
+static void usbprog_jtag_set_direction(struct usbprog_jtag *usbprog_jtag, unsigned char direction)
 {
 	char tmp[2];
 	tmp[0] = PORT_DIRECTION;
@@ -631,7 +634,7 @@
 	usbprog_jtag_message(usbprog_jtag, tmp, 2);
 }
 
-void usbprog_jtag_write_slice(struct usbprog_jtag *usbprog_jtag,unsigned char value)
+static void usbprog_jtag_write_slice(struct usbprog_jtag *usbprog_jtag,unsigned char value)
 {
 	char tmp[2];
 	tmp[0] = PORT_SET;
@@ -639,15 +642,17 @@
 	usbprog_jtag_message(usbprog_jtag, tmp, 2);
 }
 
-unsigned char usbprog_jtag_get_port(struct usbprog_jtag *usbprog_jtag)
+#if 0
+static unsigned char usbprog_jtag_get_port(struct usbprog_jtag *usbprog_jtag)
 {
 	char tmp[2];
 	tmp[0] = PORT_GET;
 	tmp[1] = 0x00;
 	return usbprog_jtag_message(usbprog_jtag, tmp, 2);
 }
+#endif
 
-void usbprog_jtag_set_bit(struct usbprog_jtag *usbprog_jtag,int bit, int value)
+static void usbprog_jtag_set_bit(struct usbprog_jtag *usbprog_jtag,int bit, int value)
 {
 	char tmp[3];
 	tmp[0] = PORT_SETBIT;
@@ -659,7 +664,8 @@
 	usbprog_jtag_message(usbprog_jtag, tmp, 3);
 }
 
-int usbprog_jtag_get_bit(struct usbprog_jtag *usbprog_jtag, int bit)
+#if 0
+static int usbprog_jtag_get_bit(struct usbprog_jtag *usbprog_jtag, int bit)
 {
 	char tmp[2];
 	tmp[0] = PORT_GETBIT;
@@ -670,14 +676,15 @@
 	else
 		return 0;
 }
+#endif
 
-void usbprog_jtag_tms_collect(char tms_scan)
+static void usbprog_jtag_tms_collect(char tms_scan)
 {
 	tms_chain[tms_chain_index] = tms_scan;
 	tms_chain_index++;
 }
 
-void usbprog_jtag_tms_send(struct usbprog_jtag *usbprog_jtag)
+static void usbprog_jtag_tms_send(struct usbprog_jtag *usbprog_jtag)
 {
 	int i;
 	/* LOG_INFO(&quot;TMS SEND&quot;); */

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-04-20 22:38:27 UTC (rev 1478)
+++ trunk/src/jtag/vsllink.c	2009-04-21 05:29:23 UTC (rev 1479)
@@ -49,10 +49,10 @@
 #define DEBUG_JTAG_IO(expr ...)
 #endif
 
-u16 vsllink_vid;
-u16 vsllink_pid;
-u8 vsllink_bulkout;
-u8 vsllink_bulkin;
+static u16 vsllink_vid;
+static u16 vsllink_pid;
+static u8 vsllink_bulkout;
+static u8 vsllink_bulkin;
 
 #define VSLLINK_USB_TIMEOUT			10000
 
@@ -104,7 +104,7 @@
  *
  * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
  */
-u8 VSLLINK_tap_move[6][6] =
+static u8 VSLLINK_tap_move[6][6] =
 {
 /*	  TLR   RTI   SD    PD    SI    PI             */
 	{0xff, 0x7f, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
@@ -121,7 +121,7 @@
 	unsigned char insert_position;
 }insert_insignificant_operation_t;
 
-insert_insignificant_operation_t VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[6][6] =
+static insert_insignificant_operation_t VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[6][6] =
 {
 /*	 stuff	offset   */
 	{/*	TLR	*/
@@ -168,7 +168,7 @@
 	{0,		0,}},	/* PI  */
 };
 
-u8 VSLLINK_BIT_MSK[8] =
+static u8 VSLLINK_BIT_MSK[8] =
 {
 	0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f
 };
@@ -187,35 +187,35 @@
 static pending_scan_result_t pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
 
 /* External interface functions */
-int vsllink_execute_queue(void);
-int vsllink_speed(int speed);
-int vsllink_khz(int khz, int *jtag_speed);
-int vsllink_speed_div(int jtag_speed, int *khz);
-int vsllink_register_commands(struct command_context_s *cmd_ctx);
-int vsllink_init(void);
-int vsllink_quit(void);
+static int vsllink_execute_queue(void);
+static int vsllink_speed(int speed);
+static int vsllink_khz(int khz, int *jtag_speed);
+static int vsllink_speed_div(int jtag_speed, int *khz);
+static int vsllink_register_commands(struct command_context_s *cmd_ctx);
+static int vsllink_init(void);
+static int vsllink_quit(void);
 
 /* CLI command handler functions */
-int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 /* Queue command functions */
-void vsllink_end_state(tap_state_t state);
-void vsllink_state_move(void);
-void vsllink_path_move(int num_states, tap_state_t *path);
-void vsllink_runtest(int num_cycles);
-void vsllink_stableclocks(int num_cycles, int tms);
-void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
-void vsllink_reset(int trst, int srst);
-void vsllink_simple_command(u8 command);
+static void vsllink_end_state(tap_state_t state);
+static void vsllink_state_move(void);
+static void vsllink_path_move(int num_states, tap_state_t *path);
+static void vsllink_runtest(int num_cycles);
+static void vsllink_stableclocks(int num_cycles, int tms);
+static void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void vsllink_reset(int trst, int srst);
+static void vsllink_simple_command(u8 command);
 
 /* VSLLink tap buffer functions */
-void vsllink_tap_init(void);
-int vsllink_tap_execute(void);
-void vsllink_tap_ensure_space(int scans, int bytes);
-void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset);
+static void vsllink_tap_init(void);
+static int vsllink_tap_execute(void);
+static void vsllink_tap_ensure_space(int scans, int bytes);
+static void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset);
 
 /* VSLLink lowlevel functions */
 typedef struct vsllink_jtag
@@ -223,18 +223,20 @@
 	struct usb_dev_handle* usb_handle;
 } vsllink_jtag_t;
 
-vsllink_jtag_t *vsllink_usb_open(void);
-void vsllink_usb_close(vsllink_jtag_t *vsllink_jtag);
-int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length);
-int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length);
-int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag);
+static vsllink_jtag_t *vsllink_usb_open(void);
+static void vsllink_usb_close(vsllink_jtag_t *vsllink_jtag);
+static int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length);
+static int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length);
+static int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag);
 
-void vsllink_debug_buffer(u8 *buffer, int length);
+#ifdef _DEBUG_USB_COMMS_
+static void vsllink_debug_buffer(u8 *buffer, int length);
+#endif
 
 static int vsllink_tms_data_len = 0;
 static u8* vsllink_tms_cmd_pos;
 
-vsllink_jtag_t* vsllink_jtag_handle;
+static vsllink_jtag_t* vsllink_jtag_handle;
 
 /***************************************************************************/
 /* External interface implementation */
@@ -251,7 +253,7 @@
 	.quit = vsllink_quit
 };
 
-int vsllink_execute_queue(void)
+static int vsllink_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue;
 	int scan_size;
@@ -384,7 +386,7 @@
 	return vsllink_tap_execute();
 }
 
-int vsllink_speed(int speed)
+static int vsllink_speed(int speed)
 {
 	int result;
 
@@ -407,21 +409,21 @@
 	return ERROR_OK;
 }
 
-int vsllink_khz(int khz, int *jtag_speed)
+static int vsllink_khz(int khz, int *jtag_speed)
 {
 	*jtag_speed = khz;
 
 	return ERROR_OK;
 }
 
-int vsllink_speed_div(int jtag_speed, int *khz)
+static int vsllink_speed_div(int jtag_speed, int *khz)
 {
 	*khz = jtag_speed;
 
 	return ERROR_OK;
 }
 
-int vsllink_register_commands(struct command_context_s *cmd_ctx)
+static int vsllink_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command,
 					COMMAND_CONFIG, NULL);
@@ -435,7 +437,7 @@
 	return ERROR_OK;
 }
 
-int vsllink_init(void)
+static int vsllink_init(void)
 {
 	int check_cnt;
 	int result;
@@ -521,7 +523,7 @@
 	return ERROR_OK;
 }
 
-int vsllink_quit(void)
+static int vsllink_quit(void)
 {
 	if ((vsllink_usb_in_buffer != NULL) &amp;&amp; (vsllink_usb_out_buffer != NULL))
 	{
@@ -553,7 +555,7 @@
 
 // when vsllink_tms_data_len &gt; 0, vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] is the byte that need to be appended.
 // length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set it here.
-void vsllink_append_tms(void)
+static void vsllink_append_tms(void)
 {
 	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	u16 tms2;
@@ -587,7 +589,7 @@
 /***************************************************************************/
 /* Queue command implementations */
 
-void vsllink_end_state(tap_state_t state)
+static void vsllink_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
 	{
@@ -601,7 +603,7 @@
 }
 
 /* Goes to the end state. */
-void vsllink_state_move(void)
+static void vsllink_state_move(void)
 {
 	if (vsllink_tms_data_len &gt; 0)
 	{
@@ -619,7 +621,7 @@
 }
 
 // write tms from current vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx]
-void vsllink_add_path(int start, int num, tap_state_t *path)
+static void vsllink_add_path(int start, int num, tap_state_t *path)
 {
 	int i;
 
@@ -658,7 +660,7 @@
 	tap_set_end_state(tap_get_state());
 }
 
-void vsllink_path_move(int num_states, tap_state_t *path)
+static void vsllink_path_move(int num_states, tap_state_t *path)
 {
 	int i, tms_len, tms_cmd_pos, path_idx = 0;
 
@@ -778,7 +780,7 @@
 	}
 }
 
-void vsllink_stableclocks(int num_cycles, int tms)
+static void vsllink_stableclocks(int num_cycles, int tms)
 {
 	int tms_len;
 	u16 tms_append_byte;
@@ -933,7 +935,7 @@
 	}
 }
 
-void vsllink_runtest(int num_cycles)
+static void vsllink_runtest(int num_cycles)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 
@@ -956,7 +958,7 @@
 	}
 }
 
-void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
 	u8 bits_left, tms_tmp, tdi_len;
@@ -1073,7 +1075,7 @@
 	tap_set_state(tap_get_end_state());
 }
 
-void vsllink_reset(int trst, int srst)
+static void vsllink_reset(int trst, int srst)
 {
 	int result;
 
@@ -1099,7 +1101,7 @@
 	}
 }
 
-void vsllink_simple_command(u8 command)
+static void vsllink_simple_command(u8 command)
 {
 	int result;
 
@@ -1114,7 +1116,7 @@
 	}
 }
 
-int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
 		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
@@ -1126,7 +1128,7 @@
 	return ERROR_OK;
 }
 
-int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
 		LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
@@ -1138,7 +1140,7 @@
 	return ERROR_OK;
 }
 
-int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
 		LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN endpoint&quot;);
@@ -1150,7 +1152,7 @@
 	return ERROR_OK;
 }
 
-int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	if (argc != 1) {
 		LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT endpoint&quot;);
@@ -1165,14 +1167,14 @@
 /***************************************************************************/
 /* VSLLink tap functions */
 
-void vsllink_tap_init(void)
+static void vsllink_tap_init(void)
 {
 	vsllink_usb_out_buffer_idx = 0;
 	vsllink_usb_in_want_length = 0;
 	pending_scan_results_length = 0;
 }
 
-void vsllink_tap_ensure_space(int scans, int bytes)
+static void vsllink_tap_ensure_space(int scans, int bytes)
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bytes = VSLLINK_BufferSize - vsllink_usb_out_buffer_idx;
@@ -1183,7 +1185,7 @@
 	}
 }
 
-void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset)
+static void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset)
 {
 	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 	int i;
@@ -1211,7 +1213,7 @@
 
 /* Pad and send a tap sequence to the device, and receive the answer.
  * For the purpose of padding we assume that we are in reset or idle or pause state. */
-int vsllink_tap_execute(void)
+static int vsllink_tap_execute(void)
 {
 	int i;
 	int result;
@@ -1350,14 +1352,14 @@
 	return NULL;
 }
 
-void vsllink_usb_close(vsllink_jtag_t *vsllink_jtag)
+static void vsllink_usb_close(vsllink_jtag_t *vsllink_jtag)
 {
 	usb_close(vsllink_jtag-&gt;usb_handle);
 	free(vsllink_jtag);
 }
 
 /* Send a message and receive the reply. */
-int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length)
+static int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length)
 {
 	int result;
 
@@ -1387,7 +1389,7 @@
 }
 
 /* Write data from out_buffer to USB. */
-int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length)
+static int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length)
 {
 	int result;
 
@@ -1415,7 +1417,7 @@
 }
 
 /* Read data from USB into in_buffer. */
-int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag)
+static int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag)
 {
 	int result = usb_bulk_read(vsllink_jtag-&gt;usb_handle, vsllink_bulkin, \
 		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize, VSLLINK_USB_TIMEOUT);
@@ -1431,7 +1433,8 @@
 
 #define BYTES_PER_LINE  16
 
-void vsllink_debug_buffer(u8 *buffer, int length)
+#ifdef _DEBUG_USB_COMMS_
+static void vsllink_debug_buffer(u8 *buffer, int length)
 {
 	char line[81];
 	char s[4];
@@ -1449,3 +1452,4 @@
 		LOG_DEBUG(line);
 	}
 }
+#endif // _DEBUG_USB_COMMS_


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000262.html">[Openocd-svn] r1478 - in trunk/src: jtag target/target
</A></li>
	<LI>Next message: <A HREF="000264.html">[Openocd-svn] r1480 - in trunk: . src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#263">[ date ]</a>
              <a href="thread.html#263">[ thread ]</a>
              <a href="subject.html#263">[ subject ]</a>
              <a href="author.html#263">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
