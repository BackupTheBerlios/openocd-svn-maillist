<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1535 - trunk/src/target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1535%20-%20trunk/src/target&In-Reply-To=%3C200904270821.n3R8LbJ5003005%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000318.html">
   <LINK REL="Next"  HREF="000320.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1535 - trunk/src/target</H1>
    <B>mlu at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1535%20-%20trunk/src/target&In-Reply-To=%3C200904270821.n3R8LbJ5003005%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1535 - trunk/src/target">mlu at mail.berlios.de
       </A><BR>
    <I>Mon Apr 27 10:21:37 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000318.html">[Openocd-svn] r1534 - trunk/src/flash
</A></li>
        <LI>Next message: <A HREF="000320.html">[Openocd-svn] r1536 - trunk/src/target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#319">[ date ]</a>
              <a href="thread.html#319">[ thread ]</a>
              <a href="subject.html#319">[ subject ]</a>
              <a href="author.html#319">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mlu
Date: 2009-04-27 10:21:35 +0200 (Mon, 27 Apr 2009)
New Revision: 1535

Added:
   trunk/src/target/arm_adi_v5.c
   trunk/src/target/arm_adi_v5.h
Log:
Added arm_adi_v5.c/h, to replace cortex_swjdp.c/h. Better conformance to ARM Debug Interface rev 5 documentation and remoed code specific to the Cortex-M3 targets.

Added: trunk/src/target/arm_adi_v5.c
===================================================================
--- trunk/src/target/arm_adi_v5.c	2009-04-27 05:40:52 UTC (rev 1534)
+++ trunk/src/target/arm_adi_v5.c	2009-04-27 08:21:35 UTC (rev 1535)
@@ -0,0 +1,1121 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Magnus Lundin                                   *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
+ *                                                                         *
+ *   Copyright (C) 2009 by Oyvind Harboe                                   *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
+ *																		   *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ * This file implements support for the ARM Debug Interface v5  (ADI_V5)   *
+ *                                                                         *
+ * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A  *
+ *                                                                         *
+ * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316A                               *
+ * Cortex-M3(tm) TRM, ARM DDI 0337C                                        *
+ *                                                                         *
+***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;replacements.h&quot;
+
+#include &quot;arm_adi_v5.h&quot;
+#include &quot;jtag.h&quot;
+#include &quot;log.h&quot;
+#include &quot;time_support.h&quot;
+#include &lt;stdlib.h&gt;
+
+/*
+ * Transaction Mode:
+ * swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+ * Uses Overrun checking mode and does not do actual JTAG send/receive or transaction
+ * result checking until swjdp_end_transaction()
+ * This must be done before using or deallocating any return variables.
+ * swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC
+ * All reads and writes to the AHB bus are checked for valid completion, and return values
+ * are immediatley available.
+*/
+
+/***************************************************************************
+ *                                                                         *
+ * DPACC and APACC scanchain access through JTAG-DP                        *
+ *                                                                         *
+***************************************************************************/
+
+/* Scan out and in from target ordered u8 buffers */
+int adi_jtag_dp_scan(arm_jtag_t *jtag_info, u8 instr, u8 reg_addr, u8 RnW, u8 *outvalue, u8 *invalue, u8 *ack)
+{
+	scan_field_t fields[2];
+	u8 out_addr_buf;
+
+	jtag_add_end_state(TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, instr, NULL);
+
+	fields[0].tap = jtag_info-&gt;tap;
+	fields[0].num_bits = 3;
+	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
+	fields[0].out_value = &amp;out_addr_buf;
+	fields[0].out_mask = NULL;
+	fields[0].in_value = ack;
+	fields[0].in_check_value = NULL;
+	fields[0].in_check_mask = NULL;
+	fields[0].in_handler = NULL;
+	fields[0].in_handler_priv = NULL;
+
+	fields[1].tap = jtag_info-&gt;tap;
+	fields[1].num_bits = 32;
+	fields[1].out_value = outvalue;
+	fields[1].out_mask = NULL;
+	fields[1].in_value = invalue;
+	fields[1].in_handler = NULL;
+	fields[1].in_handler_priv = NULL;
+	fields[1].in_check_value = NULL;
+	fields[1].in_check_mask = NULL;
+
+	jtag_add_dr_scan(2, fields, TAP_INVALID);
+
+	return ERROR_OK;
+}
+
+/* Scan out and in from host ordered u32 variables */
+int adi_jtag_dp_scan_u32(arm_jtag_t *jtag_info, u8 instr, u8 reg_addr, u8 RnW, u32 outvalue, u32 *invalue, u8 *ack)
+{
+	scan_field_t fields[2];
+	u8 out_value_buf[4];
+	u8 out_addr_buf;
+
+	jtag_add_end_state(TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, instr, NULL);
+
+	fields[0].tap = jtag_info-&gt;tap;
+	fields[0].num_bits = 3;
+	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
+	fields[0].out_value = &amp;out_addr_buf;
+	fields[0].out_mask = NULL;
+	fields[0].in_value = ack;
+	fields[0].in_check_value = NULL;
+	fields[0].in_check_mask = NULL;
+	fields[0].in_handler = NULL;
+	fields[0].in_handler_priv = NULL;
+
+	fields[1].tap = jtag_info-&gt;tap;
+	fields[1].num_bits = 32;
+	buf_set_u32(out_value_buf, 0, 32, outvalue);
+	fields[1].out_value = out_value_buf;
+	fields[1].out_mask = NULL;
+	fields[1].in_value = NULL;
+	if (invalue)
+	{
+		fields[1].in_handler = arm_jtag_buf_to_u32;
+		fields[1].in_handler_priv = invalue;
+	}
+	else
+	{
+		fields[1].in_handler = NULL;
+		fields[1].in_handler_priv = NULL;
+	}
+	fields[1].in_check_value = NULL;
+	fields[1].in_check_mask = NULL;
+
+	jtag_add_dr_scan(2, fields, TAP_INVALID);
+
+	return ERROR_OK;
+}
+
+/* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */
+int scan_inout_check(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u8 *outvalue, u8 *invalue)
+{
+	adi_jtag_dp_scan(swjdp-&gt;jtag_info, instr, reg_addr, RnW, outvalue, NULL, NULL);
+	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
+	{
+		adi_jtag_dp_scan(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
+	}
+
+	/* In TRANS_MODE_ATOMIC all SWJDP_IR_APACC transactions wait for ack=OK/FAULT and the check CTRL_STAT */
+	if ((instr == SWJDP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
+	{
+		return swjdp_transaction_endcheck(swjdp);
+	}
+
+	return ERROR_OK;
+}
+
+int scan_inout_check_u32(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u32 outvalue, u32 *invalue)
+{
+	adi_jtag_dp_scan_u32(swjdp-&gt;jtag_info, instr, reg_addr, RnW, outvalue, NULL, NULL);
+	if ((RnW==DPAP_READ) &amp;&amp; (invalue != NULL))
+	{
+		adi_jtag_dp_scan_u32(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
+	}
+
+	/* In TRANS_MODE_ATOMIC all SWJDP_IR_APACC transactions wait for ack=OK/FAULT and then check CTRL_STAT */
+	if ((instr == SWJDP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
+	{
+		return swjdp_transaction_endcheck(swjdp);
+	}
+
+	return ERROR_OK;
+}
+
+int swjdp_transaction_endcheck(swjdp_common_t *swjdp)
+{
+	int retval;
+	u32 ctrlstat;
+
+	/* too expensive to call keep_alive() here */
+
+#if 0
+	/* Danger!!!! BROKEN!!!! */
+	scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
+	R956 introduced the check on return value here and now Michael Schwingen reports
+	that this code no longer works....
+
+	<A HREF="https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html">https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html</A>
+	*/
+	if ((retval=jtag_execute_queue())!=ERROR_OK)
+	{
+		LOG_ERROR(&quot;BUG: Why does this fail the first time????&quot;);
+	}
+	/* Why??? second time it works??? */
+#endif
+
+	scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+	if ((retval=jtag_execute_queue())!=ERROR_OK)
+		return retval;
+
+	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
+
+	if (swjdp-&gt;ack != 2)
+	{
+		long long then=timeval_ms();
+		while (swjdp-&gt;ack != 2)
+		{
+			if (swjdp-&gt;ack == 1)
+			{
+				if ((timeval_ms()-then) &gt; 1000)
+				{
+					LOG_WARNING(&quot;Timeout (1000ms) waiting for ACK = OK/FAULT in SWJDP transaction&quot;);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+			else
+			{
+				LOG_WARNING(&quot;Invalid ACK in SWJDP transaction&quot;);
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+			if ((retval=jtag_execute_queue())!=ERROR_OK)
+				return retval;
+			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
+		}
+	} else
+	{
+		/* common code path avoids fn to timeval_ms() */
+	}
+
+	/* Check for STICKYERR and STICKYORUN */
+	if (ctrlstat &amp; (SSTICKYORUN | SSTICKYERR))
+	{
+		LOG_DEBUG(&quot;swjdp: CTRL/STAT error 0x%x&quot;, ctrlstat);
+		/* Check power to debug regions */
+		if ((ctrlstat &amp; 0xf0000000) != 0xf0000000)
+		{
+			 ahbap_debugport_init(swjdp);
+		}
+		else
+		{
+			u32 mem_ap_csw;
+
+			/* Print information about last AHBAP access */
+			LOG_ERROR(&quot;AHBAP Cached values: dp_select 0x%x, ap_csw 0x%x, ap_tar 0x%x&quot;, swjdp-&gt;dp_select_value, swjdp-&gt;ap_csw_value, swjdp-&gt;ap_tar_value);
+			if (ctrlstat &amp; SSTICKYORUN)
+				LOG_ERROR(&quot;SWJ-DP OVERRUN - check clock or reduce jtag speed&quot;);
+
+			if (ctrlstat &amp; SSTICKYERR)
+				LOG_ERROR(&quot;SWJ-DP STICKY ERROR&quot;);
+
+			/* Clear Sticky Error Bits */
+			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_WRITE, swjdp-&gt;dp_ctrl_stat | SSTICKYORUN | SSTICKYERR, NULL);
+			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+			if ((retval=jtag_execute_queue())!=ERROR_OK)
+				return retval;
+
+			LOG_DEBUG(&quot;swjdp: status 0x%x&quot;, ctrlstat);
+
+			dap_ap_read_reg_u32(swjdp, AP_REG_CSW, &amp;mem_ap_csw);
+			if ((retval=jtag_execute_queue())!=ERROR_OK)
+				return retval;
+			LOG_ERROR(&quot;Read MEM_AP_CSW 0x%x&quot;, mem_ap_csw);
+
+		}
+		if ((retval=jtag_execute_queue())!=ERROR_OK)
+			return retval;
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+
+	return ERROR_OK;
+}
+
+/***************************************************************************
+ *                                                                         *
+ * DP and MEM-AP  register access  through APACC and DPACC                 *
+ *                                                                         *
+***************************************************************************/
+
+int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, u8 reg_addr)
+{
+	return scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, reg_addr, DPAP_WRITE, value, NULL);
+}
+
+int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, u8 reg_addr)
+{
+	return scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, reg_addr, DPAP_READ, 0, value);
+}
+ 
+int dap_ap_select(swjdp_common_t *swjdp,u8 apsel)
+{
+	u32 select;
+	select = (apsel&lt;&lt;24) &amp; 0xFF000000;
+
+	if (select != swjdp-&gt;apsel)
+	{
+		swjdp-&gt;apsel = select;
+		/* Switchin AP invalidates cached values */
+		swjdp-&gt;dp_select_value = -1;
+		swjdp-&gt;ap_csw_value = -1;
+		swjdp-&gt;ap_tar_value = -1;
+	}
+
+	return ERROR_OK;
+}
+
+int dap_dp_bankselect(swjdp_common_t *swjdp,u32 ap_reg)
+{
+	u32 select;
+	select = (ap_reg &amp; 0x000000F0);
+
+	if (select != swjdp-&gt;dp_select_value)
+	{
+		dap_dp_write_reg(swjdp, select | swjdp-&gt;apsel, DP_SELECT);
+		swjdp-&gt;dp_select_value = select;
+	}
+
+	return ERROR_OK;
+}
+
+int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, u8* out_value_buf)
+{
+	dap_dp_bankselect(swjdp, reg_addr);
+	scan_inout_check(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
+
+	return ERROR_OK;
+}
+
+int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, u8 *in_value_buf)
+{
+	dap_dp_bankselect(swjdp, reg_addr);
+	scan_inout_check(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_READ, 0, in_value_buf);
+
+	return ERROR_OK;
+}
+int dap_ap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value)
+{
+	u8 out_value_buf[4];
+
+	buf_set_u32(out_value_buf, 0, 32, value);
+	dap_dp_bankselect(swjdp, reg_addr);
+	scan_inout_check(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
+
+	return ERROR_OK;
+}
+
+int dap_ap_read_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 *value)
+{
+	dap_dp_bankselect(swjdp, reg_addr);
+	scan_inout_check_u32(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_READ, 0, value);
+
+	return ERROR_OK;
+}
+
+/***************************************************************************
+ *                                                                         *
+ * AHB-AP access to memory and system registers on AHB bus                 *
+ *                                                                         *
+***************************************************************************/
+
+int dap_setup_accessport(swjdp_common_t *swjdp, u32 csw, u32 tar)
+{
+	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
+	if (csw != swjdp-&gt;ap_csw_value)
+	{
+		/* LOG_DEBUG(&quot;swjdp : Set CSW %x&quot;,csw); */
+		dap_ap_write_reg_u32(swjdp, AP_REG_CSW, csw );
+		swjdp-&gt;ap_csw_value = csw;
+	}
+	if (tar != swjdp-&gt;ap_tar_value)
+	{
+		/* LOG_DEBUG(&quot;swjdp : Set TAR %x&quot;,tar); */
+		dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar );
+		swjdp-&gt;ap_tar_value = tar;
+	}
+	if (csw &amp; CSW_ADDRINC_MASK)
+	{
+		/* Do not cache TAR value when autoincrementing */
+		swjdp-&gt;ap_tar_value = -1;
+	}
+	return ERROR_OK;
+}
+
+/*****************************************************************************
+*                                                                            *
+* mem_ap_read_u32(swjdp_common_t *swjdp, u32 address, u32 *value)      *
+*                                                                            *
+* Read a u32 value from memory or system register                            *
+* Functionally equivalent to target_read_u32(target, address, u32 *value),   *
+* but with less overhead                                                     *
+*****************************************************************************/
+int mem_ap_read_u32(swjdp_common_t *swjdp, u32 address, u32 *value)
+{
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, address &amp; 0xFFFFFFF0);
+	dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (address &amp; 0xC), value );
+
+	return ERROR_OK;
+}
+
+int mem_ap_read_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 *value)
+{
+	mem_ap_read_u32(swjdp, address, value);
+
+	return swjdp_transaction_endcheck(swjdp);
+}
+
+/*****************************************************************************
+*                                                                            *
+* mem_ap_write_u32(swjdp_common_t *swjdp, u32 address, u32 value)      *
+*                                                                            *
+* Write a u32 value to memory or memory mapped register                              *
+*                                                                            *
+*****************************************************************************/
+int mem_ap_write_u32(swjdp_common_t *swjdp, u32 address, u32 value)
+{
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, address &amp; 0xFFFFFFF0);
+	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (address &amp; 0xC), value );
+
+	return ERROR_OK;
+}
+
+int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value)
+{
+	mem_ap_write_u32(swjdp, address, value);
+
+	return swjdp_transaction_endcheck(swjdp);
+}
+
+/*****************************************************************************
+*                                                                            *
+* mem_ap_write_buf(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address) *
+*                                                                            *
+* Write a buffer in target order (little endian)                             *
+*                                                                            *
+*****************************************************************************/
+int mem_ap_write_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 outvalue;
+	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
+	u32 adr = address;
+	u8* pBuffer = buffer;
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	count &gt;&gt;= 2;
+	wcount = count;
+
+	/* if we have an unaligned access - reorder data */
+	if (adr &amp; 0x3u)
+	{
+		for (writecount = 0; writecount &lt; count; writecount++)
+		{
+			int i;
+			outvalue = *((u32*)pBuffer);
+
+			for (i = 0; i &lt; 4; i++ )
+			{
+				*((u8*)pBuffer + (adr &amp; 0x3)) = outvalue;
+				outvalue &gt;&gt;= 8;
+				adr++;
+			}
+			pBuffer += 4;
+		}
+	}
+
+	while (wcount &gt; 0)
+	{
+		/* Adjust to write blocks within 4K aligned boundaries */
+		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 2;
+		if (wcount &lt; blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+
+		for (writecount = 0; writecount &lt; blocksize; writecount++)
+		{
+			dap_ap_write_reg(swjdp, AP_REG_DRW, buffer + 4 * writecount );
+		}
+
+		if (swjdp_transaction_endcheck(swjdp) == ERROR_OK)
+		{
+			wcount = wcount - blocksize;
+			address = address + 4 * blocksize;
+			buffer = buffer + 4 * blocksize;
+		}
+		else
+		{
+			errorcount++;
+		}
+
+		if (errorcount &gt; 1)
+		{
+			LOG_WARNING(&quot;Block write error address 0x%x, wcount 0x%x&quot;, address, wcount);
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_packed_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 outvalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, writecount, i;
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	wcount = count &gt;&gt; 1;
+
+	while (wcount &gt; 0)
+	{
+		int nbytes;
+
+		/* Adjust to read within 4K block boundaries */
+		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 1;
+
+		if (wcount &lt; blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		writecount = blocksize;
+
+		do
+		{
+			nbytes = MIN((writecount &lt;&lt; 1), 4);
+
+			if (nbytes &lt; 4 )
+			{
+				if (mem_ap_write_buf_u16(swjdp, buffer, nbytes, address) != ERROR_OK)
+				{
+					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+
+				address += nbytes &gt;&gt; 1;
+			}
+			else
+			{
+				outvalue = *((u32*)buffer);
+
+				for (i = 0; i &lt; nbytes; i++ )
+				{
+					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
+					outvalue &gt;&gt;= 8;
+					address++;
+				}
+
+				outvalue = *((u32*)buffer);
+				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
+				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
+				{
+					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+
+			buffer += nbytes &gt;&gt; 1;
+			writecount -= nbytes &gt;&gt; 1;
+
+		} while (writecount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 outvalue;
+	int retval = ERROR_OK;
+
+	if (count &gt;= 4)
+		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	while (count &gt; 0)
+	{
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		outvalue = *((u16*)buffer) &lt;&lt; 8 * (address &amp; 0x3);
+		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue );
+		retval = swjdp_transaction_endcheck(swjdp);
+		count -= 2;
+		address += 2;
+		buffer += 2;
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_packed_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 outvalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, writecount, i;
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	wcount = count;
+
+	while (wcount &gt; 0)
+	{
+		int nbytes;
+
+		/* Adjust to read within 4K block boundaries */
+		blocksize = (0x1000 - (0xFFF &amp; address));
+
+		if (wcount &lt; blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		writecount = blocksize;
+
+		do
+		{
+			nbytes = MIN(writecount, 4);
+
+			if (nbytes &lt; 4 )
+			{
+				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
+				{
+					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+
+				address += nbytes;
+			}
+			else
+			{
+				outvalue = *((u32*)buffer);
+
+				for (i = 0; i &lt; nbytes; i++ )
+				{
+					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
+					outvalue &gt;&gt;= 8;
+					address++;
+				}
+
+				outvalue = *((u32*)buffer);
+				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
+				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
+				{
+					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+
+			buffer += nbytes;
+			writecount -= nbytes;
+
+		} while (writecount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 outvalue;
+	int retval = ERROR_OK;
+
+	if (count &gt;= 4)
+		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	while (count &gt; 0)
+	{
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		outvalue = *((u8*)buffer) &lt;&lt; 8 * (address &amp; 0x3);
+		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue );
+		retval = swjdp_transaction_endcheck(swjdp);
+		count--;
+		address++;
+		buffer++;
+	}
+
+	return retval;
+}
+
+/*********************************************************************************
+*                                                                                *
+* mem_ap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)  *
+*                                                                                *
+* Read block fast in target order (little endian) into a buffer                  *
+*                                                                                *
+**********************************************************************************/
+int mem_ap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
+	u32 adr = address;
+	u8* pBuffer = buffer;
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	count &gt;&gt;= 2;
+	wcount = count;
+
+	while (wcount &gt; 0)
+	{
+		/* Adjust to read within 4K block boundaries */
+		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 2;
+		if (wcount &lt; blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+
+		/* Scan out first read */
+		adi_jtag_dp_scan(swjdp-&gt;jtag_info, SWJDP_IR_APACC, AP_REG_DRW, DPAP_READ, 0, NULL, NULL);
+		for (readcount = 0; readcount &lt; blocksize - 1; readcount++)
+		{
+			/* Scan out read instruction and scan in previous value */
+			adi_jtag_dp_scan(swjdp-&gt;jtag_info, SWJDP_IR_APACC, AP_REG_DRW, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
+		}
+
+		/* Scan in last value */
+		adi_jtag_dp_scan(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
+		if (swjdp_transaction_endcheck(swjdp) == ERROR_OK)
+		{
+			wcount = wcount - blocksize;
+			address += 4 * blocksize;
+			buffer += 4 * blocksize;
+		}
+		else
+		{
+			errorcount++;
+		}
+
+		if (errorcount &gt; 1)
+		{
+			LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+	}
+
+	/* if we have an unaligned access - reorder data */
+	if (adr &amp; 0x3u)
+	{
+		for (readcount = 0; readcount &lt; count; readcount++)
+		{
+			int i;
+			u32 data = *((u32*)pBuffer);
+
+			for (i = 0; i &lt; 4; i++ )
+			{
+				*((u8*)pBuffer) = (data &gt;&gt; 8 * (adr &amp; 0x3));
+				pBuffer++;
+				adr++;
+			}
+		}
+	}
+
+	return retval;
+}
+
+int mem_ap_read_buf_packed_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 invalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, readcount, i;
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	wcount = count &gt;&gt; 1;
+
+	while (wcount &gt; 0)
+	{
+		int nbytes;
+
+		/* Adjust to read within 4K block boundaries */
+		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 1;
+		if (wcount &lt; blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+		readcount = blocksize;
+
+		do
+		{
+			dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &amp;invalue );
+			if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
+			{
+				LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			nbytes = MIN((readcount &lt;&lt; 1), 4);
+
+			for (i = 0; i &lt; nbytes; i++ )
+			{
+				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+				buffer++;
+				address++;
+			}
+
+			readcount -= (nbytes &gt;&gt; 1);
+		} while (readcount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_read_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 invalue, i;
+	int retval = ERROR_OK;
+
+	if (count &gt;= 4)
+		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	while (count &gt; 0)
+	{
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &amp;invalue );
+		retval = swjdp_transaction_endcheck(swjdp);
+		if (address &amp; 0x1)
+		{
+			for (i = 0; i &lt; 2; i++ )
+			{
+				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+				buffer++;
+				address++;
+			}
+		}
+		else
+		{
+			*((u16*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+			address += 2;
+			buffer += 2;
+		}
+		count -= 2;
+	}
+
+	return retval;
+}
+
+int mem_ap_read_buf_packed_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 invalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, readcount, i;
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	wcount = count;
+
+	while (wcount &gt; 0)
+	{
+		int nbytes;
+
+		/* Adjust to read within 4K block boundaries */
+		blocksize = (0x1000 - (0xFFF &amp; address));
+
+		if (wcount &lt; blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		readcount = blocksize;
+
+		do
+		{
+			dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &amp;invalue );
+			if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
+			{
+				LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			nbytes = MIN(readcount, 4);
+
+			for (i = 0; i &lt; nbytes; i++ )
+			{
+				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+				buffer++;
+				address++;
+			}
+
+			readcount -= nbytes;
+		} while (readcount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_read_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+{
+	u32 invalue;
+	int retval = ERROR_OK;
+
+	if (count &gt;= 4)
+		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
+
+	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
+
+	while (count &gt; 0)
+	{
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &amp;invalue );
+		retval = swjdp_transaction_endcheck(swjdp);
+		*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+		count--;
+		address++;
+		buffer++;
+	}
+
+	return retval;
+}
+
+int ahbap_debugport_init(swjdp_common_t *swjdp)
+{
+	u32 idreg, romaddr, dummy;
+	u32 ctrlstat;
+	int cnt = 0;
+	int retval;
+
+	LOG_DEBUG(&quot; &quot;);
+
+	swjdp-&gt;apsel = 0;
+	swjdp-&gt;ap_csw_value = -1;
+	swjdp-&gt;ap_tar_value = -1;
+	swjdp-&gt;trans_mode = TRANS_MODE_ATOMIC;
+	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
+	dap_dp_write_reg(swjdp, SSTICKYERR, DP_CTRL_STAT);
+	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
+
+	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
+
+	dap_dp_write_reg(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
+	dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
+	if ((retval=jtag_execute_queue())!=ERROR_OK)
+		return retval;
+
+	/* Check that we have debug power domains activated */
+	while (!(ctrlstat &amp; CDBGPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
+	{
+		LOG_DEBUG(&quot;swjdp: wait CDBGPWRUPACK&quot;);
+		dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
+		if ((retval=jtag_execute_queue())!=ERROR_OK)
+			return retval;
+		alive_sleep(10);
+	}
+
+	while (!(ctrlstat &amp; CSYSPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
+	{
+		LOG_DEBUG(&quot;swjdp: wait CSYSPWRUPACK&quot;);
+		dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
+		if ((retval=jtag_execute_queue())!=ERROR_OK)
+			return retval;
+		alive_sleep(10);
+	}
+
+	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
+	/* With debug power on we can activate OVERRUN checking */
+	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
+	dap_dp_write_reg(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
+	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
+
+	dap_ap_read_reg_u32(swjdp, 0xFC, &amp;idreg);
+	dap_ap_read_reg_u32(swjdp, 0xF8, &amp;romaddr);
+
+	LOG_DEBUG(&quot;AHB-AP ID Register 0x%x, Debug ROM Address 0x%x&quot;, idreg, romaddr);
+
+	return ERROR_OK;
+}
+
+
+char * class_description[16] ={
+	&quot;Reserved&quot;,
+	&quot;ROM table&quot;,&quot;Reserved&quot;,&quot;Reserved&quot;,&quot;Reserved&quot;,&quot;Reserved&quot;,&quot;Reserved&quot;,&quot;Reserved&quot;,&quot;Reserved&quot;,
+	&quot;CoreSight component&quot;,&quot;Reserved&quot;,&quot;Peripheral Test Block&quot;,&quot;Reserved&quot;,&quot;DESS&quot;,&quot;Generic IP component&quot;,&quot;Non standard layout&quot;};
+
+int dap_info_command(struct command_context_s *cmd_ctx, swjdp_common_t *swjdp, int apsel)
+{
+
+	u32 dbgbase,apid;
+	int romtable_present = 0;
+	u8 mem_ap; 
+	u32 apselold;
+
+	apselold = swjdp-&gt;apsel;
+	dap_ap_select(swjdp, apsel);
+	dap_ap_read_reg_u32(swjdp, 0xF8, &amp;dbgbase);
+	dap_ap_read_reg_u32(swjdp, 0xFC, &amp;apid);
+	swjdp_transaction_endcheck(swjdp);
+	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
+	mem_ap = ((apid&amp;0x10000)&amp;&amp;((apid&amp;0x0F)!=0));
+	command_print(cmd_ctx, &quot;ap identification register 0x%8.8x&quot;, apid);
+	if (apid)
+	{
+		switch (apid&amp;0x0F)
+		{
+			case 0:
+				command_print(cmd_ctx, &quot;\tType is jtag-ap&quot;);		
+				break;
+			case 1:
+				command_print(cmd_ctx, &quot;\tType is mem-ap AHB&quot;);		
+				break;
+			case 2:
+				command_print(cmd_ctx, &quot;\tType is mem-ap APB&quot;);				
+				break;
+			default:
+				command_print(cmd_ctx, &quot;\tUnknown AP-type&quot;);	
+			break;
+		}
+		command_print(cmd_ctx, &quot;ap debugbase 0x%8.8x&quot;, dbgbase);
+	}
+	else
+	{
+		command_print(cmd_ctx, &quot;No AP found at this apsel 0x%x&quot;, apsel);	
+	}
+
+	romtable_present = ((mem_ap)&amp;&amp;(dbgbase != 0xFFFFFFFF));
+	if (romtable_present)
+	{
+		u32 cid0,cid1,cid2,cid3,memtype,romentry;
+		u16 entry_offset;
+		/* bit 16 of apid indicates a memory access port */
+		if (dbgbase&amp;0x02)
+		{
+			command_print(cmd_ctx, &quot;\tValid ROM table present&quot;);
+		}
+		else
+		{
+			command_print(cmd_ctx, &quot;\tROM table in legacy format&quot; );
+		}
+		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
+		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000)|0xFF0, &amp;cid0);		
+		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000)|0xFF4, &amp;cid1);		
+		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000)|0xFF8, &amp;cid2);		
+		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000)|0xFFC, &amp;cid3);		
+		mem_ap_read_u32(swjdp, (dbgbase&amp;0xFFFFF000)|0xFCC, &amp;memtype);		
+		swjdp_transaction_endcheck(swjdp);
+		command_print(cmd_ctx, &quot;\tCID3 0x%x, CID2 0x%x, CID1 0x%x, CID0, 0x%x&quot;,cid3,cid2,cid1,cid0);
+		if (memtype&amp;0x01)
+		{
+			command_print(cmd_ctx, &quot;\tMEMTYPE system memory present on bus&quot;);
+		}
+		else
+		{
+			command_print(cmd_ctx, &quot;\tMEMTYPE system memory not present. Dedicated debug bus&quot; );
+		}
+		
+		/* Now we read ROM table entries from dbgbase&amp;0xFFFFF000)|0x000 until we get 0x00000000 */
+		entry_offset = 0;
+		do 
+		{
+			mem_ap_read_atomic_u32(swjdp, (dbgbase&amp;0xFFFFF000)|entry_offset, &amp;romentry);
+			command_print(cmd_ctx, &quot;\tROMTABLE[0x%x] = 0x%x&quot;,entry_offset,romentry);
+			if (romentry&amp;0x01)
+			{
+				u32 c_cid0,c_cid1,c_cid2,c_cid3,c_pid0,c_pid1,c_pid2,c_pid3,c_pid4,component_start;
+				u32 component_base = (u32)((dbgbase&amp;0xFFFFF000)+(int)(romentry&amp;0xFFFFF000));
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE0, &amp;c_pid0);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE4, &amp;c_pid1);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE8, &amp;c_pid2);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFEC, &amp;c_pid3);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFD0, &amp;c_pid4);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFF0, &amp;c_cid0);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFF4, &amp;c_cid1);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFF8, &amp;c_cid2);
+				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFFC, &amp;c_cid3);
+				component_start = component_base - 0x1000*(c_pid4&gt;&gt;4);
+				command_print(cmd_ctx, &quot;\t\tComponent base address 0x%x, pid4 0x%x, start address 0x%x&quot;,component_base,c_pid4,component_start);
+				command_print(cmd_ctx, &quot;\t\tComponent cid1 0x%x, class is %s&quot;,c_cid1,class_description[(c_cid1&gt;&gt;4)&amp;0xF]); /* Se ARM DDI 0314 C Table 2.2 */
+				command_print(cmd_ctx, &quot;\t\tCID3 0x%x, CID2 0x%x, CID1 0x%x, CID0, 0x%x&quot;,c_cid3,c_cid2,c_cid1,c_cid0);
+				command_print(cmd_ctx, &quot;\t\tPID3 0x%x, PID2 0x%x, PID1 0x%x, PID0, 0x%x&quot;,c_pid3,c_pid2,c_pid1,c_pid0);
+				/* For CoreSight components,  (c_cid1&gt;&gt;4)&amp;0xF==9 , we also read 0xFC8 DevId and 0xFCC DevType */
+			}
+			else
+			{
+				if (romentry)
+					command_print(cmd_ctx, &quot;\t\tComponent not present&quot;);		
+				else
+					command_print(cmd_ctx, &quot;\t\tEnd of ROM table&quot;);							
+			}
+			entry_offset += 4;
+		} while (romentry&gt;0);
+	}
+	else
+	{
+		command_print(cmd_ctx, &quot;\tNo ROM table present&quot;);		
+	}
+	dap_ap_select(swjdp, apselold);
+
+	return ERROR_OK;
+}
+

Added: trunk/src/target/arm_adi_v5.h
===================================================================
--- trunk/src/target/arm_adi_v5.h	2009-04-27 05:40:52 UTC (rev 1534)
+++ trunk/src/target/arm_adi_v5.h	2009-04-27 08:21:35 UTC (rev 1535)
@@ -0,0 +1,142 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Magnus Lundin                                   *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef ARM_ADI_V5_H
+#define ARM_ADI_V5_H
+
+#include &quot;target.h&quot;
+#include &quot;register.h&quot;
+#include &quot;arm_jtag.h&quot;
+
+#define SWJDP_IR_DPACC	0xA
+#define SWJDP_IR_APACC	0xB
+
+#define DPAP_WRITE		0
+#define DPAP_READ		1
+#define DP_ZERO			0
+#define DP_CTRL_STAT	0x4
+#define DP_SELECT		0x8
+#define DP_RDBUFF		0xC
+
+#define CORUNDETECT		(1&lt;&lt;0)
+#define SSTICKYORUN		(1&lt;&lt;1)
+#define SSTICKYERR		(1&lt;&lt;5)
+#define CDBGRSTREQ		(1&lt;&lt;26)
+#define CDBGRSTACK		(1&lt;&lt;27)
+#define CDBGPWRUPREQ	(1&lt;&lt;28)
+#define CDBGPWRUPACK	(1&lt;&lt;29)
+#define CSYSPWRUPREQ	(1&lt;&lt;30)
+#define CSYSPWRUPACK	(1&lt;&lt;31)
+
+#define	AP_REG_CSW		0x00
+#define AP_REG_TAR		0x04
+#define AP_REG_DRW		0x0C
+#define AP_REG_BD0		0x10
+#define AP_REG_BD1		0x14
+#define AP_REG_BD2		0x18
+#define AP_REG_BD3		0x1C
+#define AP_REG_DBGROMA	0xF8
+#define AP_REG_IDR		0xFC
+
+#define CSW_8BIT		0
+#define CSW_16BIT		1
+#define CSW_32BIT		2
+
+#define CSW_ADDRINC_MASK	(3&lt;&lt;4)
+#define CSW_ADDRINC_OFF		0
+#define CSW_ADDRINC_SINGLE	(1&lt;&lt;4)
+#define CSW_ADDRINC_PACKED	(2&lt;&lt;4)
+#define CSW_HPROT			(1&lt;&lt;25)
+#define CSW_MASTER_DEBUG	(1&lt;&lt;29)
+#define CSW_DBGSWENABLE		(1&lt;&lt;31)
+
+/* transaction mode */
+#define TRANS_MODE_NONE			0
+/* Transaction waits for previous to complete */
+#define TRANS_MODE_ATOMIC		1
+/* Freerunning transactions with delays and overrun checking */
+#define TRANS_MODE_COMPOSITE	2
+
+typedef struct swjdp_reg_s
+{
+	int addr;
+	arm_jtag_t *jtag_info;
+} swjdp_reg_t;
+
+typedef struct swjdp_common_s
+{
+	arm_jtag_t *jtag_info;
+	/* Control config */
+	u32 dp_ctrl_stat;
+	/* Support for several AP's in one DAP */
+	u32 apsel;
+	/* Register select cache */
+	u32 dp_select_value;
+	u32 ap_csw_value;
+	u32 ap_tar_value;
+	/* information about current pending SWjDP-AHBAP transaction */
+	u8  trans_mode;
+	u8  trans_rw;
+	u8  ack;
+} swjdp_common_t;
+
+/* Internal functions used in the module, partial transactions, use with caution */
+extern int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, u8 reg_addr);
+/* extern int swjdp_write_apacc(swjdp_common_t *swjdp, u32 value, u8 reg_addr); */
+extern int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, u8 reg_addr);
+/* extern int swjdp_read_apacc(swjdp_common_t *swjdp, u32 *value, u8 reg_addr); */
+extern int dap_setup_accessport(swjdp_common_t *swjdp, u32 csw, u32 tar);
+extern int dap_ap_select(swjdp_common_t *swjdp,u8 apsel);
+
+extern int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, u8* out_value_buf);
+extern int dap_ap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value);
+extern int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, u8 *in_value_buf);
+extern int dap_ap_read_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 *value);
+
+/* External interface, partial operations must be completed with swjdp_transaction_endcheck() */
+extern int swjdp_transaction_endcheck(swjdp_common_t *swjdp);
+
+/* MEM-AP memory mapped bus single u32 register transfers, without endcheck */
+extern int mem_ap_read_u32(swjdp_common_t *swjdp, u32 address, u32 *value);
+extern int mem_ap_write_u32(swjdp_common_t *swjdp, u32 address, u32 value);
+
+/* MEM-AP memory mapped bus transfers, single registers, complete transactions */
+extern int mem_ap_read_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 *value);
+extern int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value);
+
+/* MEM-AP memory mapped bus block transfers */
+extern int mem_ap_read_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
+extern int mem_ap_read_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
+extern int mem_ap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
+extern int mem_ap_write_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
+extern int mem_ap_write_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
+extern int mem_ap_write_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
+
+/* Initialisation of the debug system, power domains and registers */
+extern int ahbap_debugport_init(swjdp_common_t *swjdp);
+
+extern int dap_info_command(struct command_context_s *cmd_ctx, swjdp_common_t *swjdp, int apsel);
+/* Commands for user dap access */
+extern int handle_dap_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+extern int handle_dap_apsel_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000318.html">[Openocd-svn] r1534 - trunk/src/flash
</A></li>
	<LI>Next message: <A HREF="000320.html">[Openocd-svn] r1536 - trunk/src/target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#319">[ date ]</a>
              <a href="thread.html#319">[ thread ]</a>
              <a href="subject.html#319">[ subject ]</a>
              <a href="author.html#319">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
