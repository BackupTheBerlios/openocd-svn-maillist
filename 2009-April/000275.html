<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1491 - in trunk/src: jtag target/interface
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1491%20-%20in%20trunk/src%3A%20jtag%20target/interface&In-Reply-To=%3C200904210908.n3L98kXj025283%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000274.html">
   <LINK REL="Next"  HREF="000276.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1491 - in trunk/src: jtag target/interface</H1>
    <B>ntfreak at BerliOS</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1491%20-%20in%20trunk/src%3A%20jtag%20target/interface&In-Reply-To=%3C200904210908.n3L98kXj025283%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1491 - in trunk/src: jtag target/interface">ntfreak at mail.berlios.de
       </A><BR>
    <I>Tue Apr 21 11:08:46 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000274.html">[Openocd-svn] r1490 - trunk
</A></li>
        <LI>Next message: <A HREF="000276.html">[Openocd-svn] r1492 - trunk/src/jtag
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#275">[ date ]</a>
              <a href="thread.html#275">[ thread ]</a>
              <a href="subject.html#275">[ subject ]</a>
              <a href="author.html#275">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ntfreak
Date: 2009-04-21 11:08:43 +0200 (Tue, 21 Apr 2009)
New Revision: 1491

Added:
   trunk/src/target/interface/vsllink.cfg
Modified:
   trunk/src/jtag/vsllink.c
Log:
- vsllink update from SimonQian [<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">simonqian at SimonQian.com</A>]

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-04-21 09:05:02 UTC (rev 1490)
+++ trunk/src/jtag/vsllink.c	2009-04-21 09:08:43 UTC (rev 1491)
@@ -49,12 +49,16 @@
 #define DEBUG_JTAG_IO(expr ...)
 #endif
 
-static u16 vsllink_vid;
-static u16 vsllink_pid;
-static u8 vsllink_bulkout;
-static u8 vsllink_bulkin;
+#define VSLLINK_MODE_NORMAL			0
+#define VSLLINK_MODE_DMA			1
 
-#define VSLLINK_USB_TIMEOUT			10000
+static u16 vsllink_usb_vid;
+static u16 vsllink_usb_pid;
+static u8 vsllink_usb_bulkout;
+static u8 vsllink_usb_bulkin;
+static u8 vsllink_usb_interface;
+static u8 vsllink_mode = VSLLINK_MODE_NORMAL;
+static int VSLLINK_USB_TIMEOUT = 10000;
 
 static int VSLLINK_BufferSize = 1024;
 
@@ -74,6 +78,7 @@
 #define VSLLINK_CMD_HW_JTAGSEQCMD	0xA0
 #define VSLLINK_CMD_HW_JTAGHLCMD	0xA1
 #define VSLLINK_CMD_HW_SWDCMD		0xA2
+#define VSLLINK_CMD_HW_JTAGRAWCMD	0xA3
 
 #define VSLLINK_CMDJTAGSEQ_TMSBYTE	0x00
 #define VSLLINK_CMDJTAGSEQ_TMSCLOCK	0x40
@@ -101,7 +106,7 @@
  * 3: Pause-DR
  * 4: Shift-IR
  * 5: Pause-IR
- *
+ * 
  * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
  */
 static u8 VSLLINK_tap_move[6][6] =
@@ -110,9 +115,9 @@
 	{0xff, 0x7f, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
 	{0xff, 0x00, 0x45, 0x05, 0x4b, 0x0b},	/* RTI */
 	{0xff, 0x61, 0x00, 0x01, 0x0f, 0x2f},	/* SD  */
-	{0xff, 0x60, 0x40, 0x5c, 0x3c, 0x5e},	/* PD  */
+	{0xfe, 0x60, 0x40, 0x5c, 0x3c, 0x5e},	/* PD  */
 	{0xff, 0x61, 0x07, 0x17, 0x00, 0x01},	/* SI  */
-	{0xff, 0x60, 0x38, 0x5c, 0x40, 0x5e}	/* PI  */
+	{0xfe, 0x60, 0x38, 0x5c, 0x40, 0x5e}	/* PI  */
 };
 
 typedef struct insert_insignificant_operation
@@ -175,8 +180,8 @@
 
 typedef struct
 {
+	int offset;
 	int length; /* Number of bits to read */
-	int offset;
 	scan_command_t *command; /* Corresponding scan command */
 	u8 *buffer;
 } pending_scan_result_t;
@@ -200,22 +205,42 @@
 static int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int vsllink_handle_usb_interface_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int vsllink_handle_mode_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 /* Queue command functions */
 static void vsllink_end_state(tap_state_t state);
-static void vsllink_state_move(void);
-static void vsllink_path_move(int num_states, tap_state_t *path);
+static void vsllink_state_move_dma(void);
+static void vsllink_state_move_normal(void);
+static void (*vsllink_state_move)(void);
+static void vsllink_path_move_dma(int num_states, tap_state_t *path);
+static void vsllink_path_move_normal(int num_states, tap_state_t *path);
+static void (*vsllink_path_move)(int num_states, tap_state_t *path);
 static void vsllink_runtest(int num_cycles);
-static void vsllink_stableclocks(int num_cycles, int tms);
-static void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void vsllink_stableclocks_dma(int num_cycles, int tms);
+static void vsllink_stableclocks_normal(int num_cycles, int tms);
+static void (*vsllink_stableclocks)(int num_cycles, int tms);
+static void vsllink_scan_dma(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void vsllink_scan_normal(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void (*vsllink_scan)(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
 static void vsllink_reset(int trst, int srst);
 static void vsllink_simple_command(u8 command);
+static int vsllink_connect(void);
+static int vsllink_disconnect(void);
 
 /* VSLLink tap buffer functions */
-static void vsllink_tap_init(void);
-static int vsllink_tap_execute(void);
-static void vsllink_tap_ensure_space(int scans, int bytes);
-static void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset);
+static void vsllink_tap_append_step(int tms, int tdi);
+static void vsllink_tap_init_dma(void);
+static void vsllink_tap_init_normal(void);
+static void (*vsllink_tap_init)(void);
+static int vsllink_tap_execute_dma(void);
+static int vsllink_tap_execute_normal(void);
+static int (*vsllink_tap_execute)(void);
+static void vsllink_tap_ensure_space_dma(int scans, int length);
+static void vsllink_tap_ensure_space_normal(int scans, int length);
+static void (*vsllink_tap_ensure_space)(int scans, int length);
+static void vsllink_tap_append_scan_dma(int length, u8 *buffer, scan_command_t *command);
+static void vsllink_tap_append_scan_normal(int length, u8 *buffer, scan_command_t *command, int offset);
 
 /* VSLLink lowlevel functions */
 typedef struct vsllink_jtag
@@ -236,8 +261,15 @@
 static int vsllink_tms_data_len = 0;
 static u8* vsllink_tms_cmd_pos;
 
-static vsllink_jtag_t* vsllink_jtag_handle;
+static int tap_length = 0;
+static int tap_buffer_size = 0;
+static u8 *tms_buffer = NULL;
+static u8 *tdi_buffer = NULL;
+static u8 *tdo_buffer = NULL;
+static int last_tms;
 
+static vsllink_jtag_t* vsllink_jtag_handle = NULL;
+
 /***************************************************************************/
 /* External interface implementation */
 
@@ -253,6 +285,19 @@
 	.quit = vsllink_quit
 };
 
+static void reset_command_pointer(void)
+{
+	if (vsllink_mode == VSLLINK_MODE_NORMAL)
+	{
+		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
+		vsllink_usb_out_buffer_idx = 3;
+	}
+	else
+	{
+		tap_length = 0;
+	}
+}
+
 static int vsllink_execute_queue(void)
 {
 	jtag_command_t *cmd = jtag_command_queue;
@@ -262,56 +307,55 @@
 
 	DEBUG_JTAG_IO(&quot;--------------------------------- vsllink -------------------------------------&quot;);
 
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
-	vsllink_usb_out_buffer_idx = 3;
+	reset_command_pointer();
 	while (cmd != NULL)
 	{
 		switch (cmd-&gt;type)
 		{
 			case JTAG_END_STATE:
 				DEBUG_JTAG_IO(&quot;end_state: %s&quot;, tap_state_name(cmd-&gt;cmd.end_state-&gt;end_state));
-
+			
 				if (cmd-&gt;cmd.end_state-&gt;end_state != TAP_INVALID)
 				{
 					vsllink_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
 				}
 				break;
-
+				
 			case JTAG_RUNTEST:
 				DEBUG_JTAG_IO( &quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, \
 					tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
-
+					
 				if (cmd-&gt;cmd.runtest-&gt;end_state != TAP_INVALID)
 				{
 					vsllink_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
 				}
 				vsllink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
 				break;
-
+				
 			case JTAG_STATEMOVE:
 				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, tap_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
-
+				
 				if (cmd-&gt;cmd.statemove-&gt;end_state != TAP_INVALID)
 				{
 					vsllink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
 				}
 				vsllink_state_move();
 				break;
-
+				
 			case JTAG_PATHMOVE:
 				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %s&quot;, \
 					cmd-&gt;cmd.pathmove-&gt;num_states, \
 					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
-
+					
 				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path);
 				break;
-
+				
 			case JTAG_SCAN:
 				if (cmd-&gt;cmd.scan-&gt;end_state != TAP_INVALID)
 				{
 					vsllink_end_state(cmd-&gt;cmd.scan-&gt;end_state);
 				}
-
+				
 				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
 				if (cmd-&gt;cmd.scan-&gt;ir_scan)
 				{
@@ -321,37 +365,34 @@
 				{
 					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;, scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
 				}
-
+				
 #ifdef _DEBUG_JTAG_IO_
 				vsllink_debug_buffer(buffer, (scan_size + 7) &gt;&gt; 3);
 #endif
-
+				
 				type = jtag_scan_type(cmd-&gt;cmd.scan);
-
+				
 				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size, cmd-&gt;cmd.scan);
 				break;
-
+				
 			case JTAG_RESET:
 				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
-
+				
 				vsllink_tap_execute();
-
+				
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
 					tap_set_state(TAP_RESET);
 				}
 				vsllink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
-
-				vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
-				vsllink_usb_out_buffer_idx = 3;
 				break;
-
+				
 			case JTAG_SLEEP:
 				DEBUG_JTAG_IO(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
 				vsllink_tap_execute();
 				jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
 				break;
-
+				
 			case JTAG_STABLECLOCKS:
 				DEBUG_JTAG_IO(&quot;add %d clocks&quot;, cmd-&gt;cmd.stableclocks-&gt;num_cycles);
 				switch(tap_get_state())
@@ -375,27 +416,27 @@
 				}
 				vsllink_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, scan_size);
 				break;
-
+				
 			default:
 				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered: %d&quot;, cmd-&gt;type);
 				exit(-1);
 		}
 		cmd = cmd-&gt;next;
 	}
-
+	
 	return vsllink_tap_execute();
 }
 
 static int vsllink_speed(int speed)
 {
 	int result;
-
+	
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_SPEED;
 	vsllink_usb_out_buffer[1] = (speed &gt;&gt; 0) &amp; 0xff;
 	vsllink_usb_out_buffer[2] = (speed &gt;&gt; 8) &amp; 0xFF;
-
+	
 	result = vsllink_usb_write(vsllink_jtag_handle, 3);
-
+	
 	if (result == 3)
 	{
 		return ERROR_OK;
@@ -405,44 +446,30 @@
 		LOG_ERROR(&quot;VSLLink setting speed failed (%d)&quot;, result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
-
+	
 	return ERROR_OK;
 }
 
 static int vsllink_khz(int khz, int *jtag_speed)
 {
 	*jtag_speed = khz;
-
+	
 	return ERROR_OK;
 }
 
 static int vsllink_speed_div(int jtag_speed, int *khz)
 {
 	*khz = jtag_speed;
-
+	
 	return ERROR_OK;
 }
 
-static int vsllink_register_commands(struct command_context_s *cmd_ctx)
-{
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command,
-					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;, vsllink_handle_usb_pid_command,
-					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;, vsllink_handle_usb_bulkin_command,
-					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;, vsllink_handle_usb_bulkout_command,
-					COMMAND_CONFIG, NULL);
-
-	return ERROR_OK;
-}
-
 static int vsllink_init(void)
 {
-	int check_cnt;
+	int check_cnt, to_tmp;
 	int result;
 	char version_str[100];
-
+	
 	vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
 	vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
 	if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
@@ -450,34 +477,37 @@
 		LOG_ERROR(&quot;Not enough memory&quot;);
 		exit(-1);
 	}
-
+	
 	vsllink_jtag_handle = vsllink_usb_open();
-
+	
 	if (vsllink_jtag_handle == 0)
 	{
 		LOG_ERROR(&quot;Can't find USB JTAG Interface! Please check connection and permissions.&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-
+	LOG_DEBUG(&quot;vsllink found on %04X:%04X&quot;, vsllink_usb_vid, vsllink_usb_pid);
+	
+	to_tmp = VSLLINK_USB_TIMEOUT;
+	VSLLINK_USB_TIMEOUT = 100;
 	check_cnt = 0;
-	while (check_cnt &lt; 3)
+	while (check_cnt &lt; 5)
 	{
-		vsllink_simple_command(VSLLINK_CMD_CONN);
+		vsllink_simple_command(0x00);
 		result = vsllink_usb_read(vsllink_jtag_handle);
-
+		
 		if (result &gt; 2)
 		{
 			vsllink_usb_in_buffer[result] = 0;
 			VSLLINK_BufferSize = vsllink_usb_in_buffer[0] + (vsllink_usb_in_buffer[1] &lt;&lt; 8);
 			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, sizeof(version_str));
 			LOG_INFO(&quot;%s&quot;, version_str);
-
+			
 			// free the pre-alloc memroy
 			free(vsllink_usb_in_buffer);
 			free(vsllink_usb_out_buffer);
 			vsllink_usb_in_buffer = NULL;
 			vsllink_usb_out_buffer = NULL;
-
+			
 			// alloc new memory
 			vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
 			vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
@@ -490,20 +520,64 @@
 			{
 				LOG_INFO(&quot;buffer size for USB is %d bytes&quot;, VSLLINK_BufferSize);
 			}
+			// alloc memory for dma mode
+			if (vsllink_mode == VSLLINK_MODE_DMA)
+			{
+				tap_buffer_size = (VSLLINK_BufferSize - 3) / 2;
+				tms_buffer = (u8*)malloc(tap_buffer_size);
+				tdi_buffer = (u8*)malloc(tap_buffer_size);
+				tdo_buffer = (u8*)malloc(tap_buffer_size);
+				if ((tms_buffer == NULL) || (tdi_buffer == NULL) || (tdo_buffer == NULL))
+				{
+					LOG_ERROR(&quot;Not enough memory&quot;);
+					exit(-1);
+				}
+			}
 			break;
 		}
 		vsllink_simple_command(VSLLINK_CMD_DISCONN);
-
 		check_cnt++;
 	}
-
 	if (check_cnt == 3)
 	{
 		// It's dangerout to proced
 		LOG_ERROR(&quot;VSLLink initial failed&quot;);
 		exit(-1);
 	}
-
+	VSLLINK_USB_TIMEOUT = to_tmp;
+	
+	// connect to vsllink
+	vsllink_connect();
+	// initialize function pointers
+	if (vsllink_mode == VSLLINK_MODE_NORMAL)
+	{
+		// normal mode
+		vsllink_state_move = vsllink_state_move_normal;
+		vsllink_path_move = vsllink_path_move_normal;
+		vsllink_stableclocks = vsllink_stableclocks_normal;
+		vsllink_scan = vsllink_scan_normal;
+		
+		vsllink_tap_init = vsllink_tap_init_normal;
+		vsllink_tap_execute = vsllink_tap_execute_normal;
+		vsllink_tap_ensure_space = vsllink_tap_ensure_space_normal;
+		
+		LOG_INFO(&quot;vsllink run in NORMAL mode&quot;);
+	}
+	else
+	{
+		// dma mode
+		vsllink_state_move = vsllink_state_move_dma;
+		vsllink_path_move = vsllink_path_move_dma;
+		vsllink_stableclocks = vsllink_stableclocks_dma;
+		vsllink_scan = vsllink_scan_dma;
+		
+		vsllink_tap_init = vsllink_tap_init_dma;
+		vsllink_tap_execute = vsllink_tap_execute_dma;
+		vsllink_tap_ensure_space = vsllink_tap_ensure_space_dma;
+		
+		LOG_INFO(&quot;vsllink run in DMA mode&quot;);
+	}
+	
 	// Set SRST and TRST to output, Set USR1 and USR2 to input
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
@@ -513,13 +587,13 @@
 		LOG_ERROR(&quot;VSLLink USB send data error&quot;);
 		exit(-1);
 	}
-
+	
 	vsllink_reset(0, 0);
-
+	
 	LOG_INFO(&quot;VSLLink JTAG Interface ready&quot;);
-
+	
 	vsllink_tap_init();
-
+	
 	return ERROR_OK;
 }
 
@@ -536,31 +610,60 @@
 			LOG_ERROR(&quot;VSLLink USB send data error&quot;);
 			exit(-1);
 		}
-
+		
 		// disconnect
-		vsllink_simple_command(VSLLINK_CMD_DISCONN);
+		vsllink_disconnect();
 		vsllink_usb_close(vsllink_jtag_handle);
+		vsllink_jtag_handle = NULL;
 	}
-
+	
 	if (vsllink_usb_in_buffer != NULL)
 	{
 		free(vsllink_usb_in_buffer);
+		vsllink_usb_in_buffer = NULL;
 	}
 	if (vsllink_usb_out_buffer != NULL)
 	{
 		free(vsllink_usb_out_buffer);
+		vsllink_usb_out_buffer = NULL;
 	}
+	
 	return ERROR_OK;
 }
 
+/***************************************************************************/
+/* Queue command implementations */
+static int vsllink_disconnect(void)
+{
+	vsllink_simple_command(VSLLINK_CMD_DISCONN);
+	return ERROR_OK;
+}
+
+static int vsllink_connect(void)
+{
+	char vsllink_str[100];
+	
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
+	vsllink_usb_out_buffer[1] = vsllink_mode;
+	vsllink_usb_message(vsllink_jtag_handle, 2, 0);
+	if (vsllink_usb_read(vsllink_jtag_handle) &gt; 2)
+	{
+		strncpy(vsllink_str, (char *)vsllink_usb_in_buffer + 2, sizeof(vsllink_str));
+		LOG_INFO(&quot;%s&quot;, vsllink_str);
+	}
+	
+	return ERROR_OK;
+}
+
 // when vsllink_tms_data_len &gt; 0, vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] is the byte that need to be appended.
 // length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set it here.
 static void vsllink_append_tms(void)
 {
 	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	u16 tms2;
-	tap_state_t	end_state = tap_get_end_state();
-
+	insert_insignificant_operation_t *insert = \
+		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
+		
 	if (((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE)) || \
 			(vsllink_tms_data_len &lt;= 0) || (vsllink_tms_data_len &gt;= 8) || \
 			(vsllink_tms_cmd_pos == NULL))
@@ -568,27 +671,24 @@
 		LOG_ERROR(&quot;There MUST be some bugs in the driver&quot;);
 		exit(-1);
 	}
-
-	tms2 = (tms_scan &amp; VSLLINK_BIT_MSK[VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position]) &lt;&lt; \
+	
+	tms2 = (tms_scan &amp; VSLLINK_BIT_MSK[insert-&gt;insert_position]) &lt;&lt; \
 				vsllink_tms_data_len;
-	if (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_value == 1)
+	if (insert-&gt;insert_value == 1)
 	{
 		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] &lt;&lt; \
-				(vsllink_tms_data_len + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position);
+				(vsllink_tms_data_len + insert-&gt;insert_position);
 	}
-	tms2 |= (tms_scan &gt;&gt; VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position) &lt;&lt; \
-				(8 + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(end_state)].insert_position);
-
+	tms2 |= (tms_scan &gt;&gt; insert-&gt;insert_position) &lt;&lt; \
+				(8 + insert-&gt;insert_position);
+				
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 &gt;&gt; 0) &amp; 0xff;
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 &gt;&gt; 8) &amp; 0xff;
-
+	
 	vsllink_tms_data_len = 0;
 	vsllink_tms_cmd_pos = NULL;
 }
 
-/***************************************************************************/
-/* Queue command implementations */
-
 static void vsllink_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
@@ -603,7 +703,7 @@
 }
 
 /* Goes to the end state. */
-static void vsllink_state_move(void)
+static void vsllink_state_move_normal(void)
 {
 	if (vsllink_tms_data_len &gt; 0)
 	{
@@ -612,19 +712,65 @@
 	else
 	{
 		vsllink_tap_ensure_space(0, 2);
-
+		
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	}
-
+	
 	tap_set_state(tap_get_end_state());
 }
+static void vsllink_state_move_dma(void)
+{
+	int i, insert_length = (tap_length % 8) ? (8 - (tap_length % 8)) : 0;
+	insert_insignificant_operation_t *insert = \
+		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
+	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
+	
+	vsllink_tap_ensure_space(0, 8);
+	
+	if (tap_get_state() == TAP_RESET)
+	{
+		for (i = 0; i &lt; 8; i++)
+		{
+			vsllink_tap_append_step(1, 0);
+		}
+	}
+	
+	if (insert_length &gt; 0)
+	{
+		vsllink_tap_ensure_space(0, 16);
+		
+		for (i = 0; i &lt; insert-&gt;insert_position; i++)
+		{
+			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
+		}
+		for (i = 0; i &lt; insert_length; i++)
+		{
+			vsllink_tap_append_step(insert-&gt;insert_value, 0);
+		}
+		for (i = insert-&gt;insert_position; i &lt; 8; i++)
+		{
+			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
+		}
+	}
+	else
+	{
+		vsllink_tap_ensure_space(0, 8);
+		
+		for (i = 0; i &lt; 8; i++)
+		{
+			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
+		}
+	}
+	
+	tap_set_state(tap_get_end_state());
+}
 
 // write tms from current vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx]
 static void vsllink_add_path(int start, int num, tap_state_t *path)
 {
 	int i;
-
+	
 	for (i = start; i &lt; (start + num); i++)
 	{
 		if ((i &amp; 7) == 0)
@@ -635,7 +781,7 @@
 			}
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 		}
-
+		
 		if (path[i - start] == tap_state_transition(tap_get_state(), true))
 		{
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 &lt;&lt; (i &amp; 7);
@@ -656,14 +802,14 @@
 		vsllink_usb_out_buffer_idx++;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 	}
-
+	
 	tap_set_end_state(tap_get_state());
 }
 
-static void vsllink_path_move(int num_states, tap_state_t *path)
+static void vsllink_path_move_normal(int num_states, tap_state_t *path)
 {
 	int i, tms_len, tms_cmd_pos, path_idx = 0;
-
+	
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		// there are vsllink_tms_data_len more tms bits to be shifted
@@ -714,7 +860,7 @@
 				// end last tms shift command
 				vsllink_add_path(vsllink_tms_data_len, num_states, path);
 			}
-
+			
 			vsllink_tms_data_len = (vsllink_tms_data_len + num_states) &amp; 7;
 			if (vsllink_tms_data_len == 0)
 			{
@@ -725,19 +871,19 @@
 		else
 		{
 			vsllink_add_path(vsllink_tms_data_len, 16 - vsllink_tms_data_len, path);
-
+			
 			path += 16 - vsllink_tms_data_len;
 			num_states -= 16 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
 			vsllink_tms_cmd_pos = NULL;
 		}
 	}
-
+	
 	if (num_states &gt; 0)
 	{
 		// Normal operation, don't need to append tms data
 		vsllink_tms_data_len = num_states &amp; 7;
-
+		
 		while (num_states &gt; 0)
 		{
 			if (num_states &gt; ((VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8))
@@ -752,13 +898,13 @@
 			vsllink_tap_ensure_space(0, tms_len + 2);
 			tms_cmd_pos = vsllink_usb_out_buffer_idx;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | (tms_len - 1);
-
+			
 			vsllink_add_path(0, i, path + path_idx);
-
+			
 			path_idx += i;
 			num_states -= i;
 		}
-
+		
 		if (vsllink_tms_data_len &gt; 0)
 		{
 			if (tms_len &lt; (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
@@ -769,7 +915,7 @@
 			else
 			{
 				vsllink_usb_out_buffer[tms_cmd_pos]--;
-
+				
 				tms_len = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 				vsllink_tap_ensure_space(0, 3);
 				vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
@@ -779,12 +925,71 @@
 		}
 	}
 }
+static void vsllink_path_move_dma(int num_states, tap_state_t *path)
+{
+	int i, j = 0;
+	
+	if (tap_length &amp; 7)
+	{
+		if ((8 - (tap_length &amp; 7)) &lt; num_states)
+		{
+			j = 8 - (tap_length &amp; 7);
+		}
+		else
+		{
+			j = num_states;
+		}
+		for (i = 0; i &lt; j; i++)
+		{
+			if (path[i] == tap_state_transition(tap_get_state(), false))
+			{
+				vsllink_tap_append_step(0, 0);
+			}
+			else if (path[i] == tap_state_transition(tap_get_state(), true))
+			{
+				vsllink_tap_append_step(1, 0);
+			}
+			else
+			{
+				LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(path[i]));
+				exit(-1);
+			}
+			tap_set_state(path[i]);
+		}
+		num_states -= j;
+	}
+	
+	if (num_states &gt; 0)
+	{
+		vsllink_tap_ensure_space(0, num_states);
+		
+		for (i = 0; i &lt; num_states; i++)
+		{
+			if (path[j + i] == tap_state_transition(tap_get_state(), false))
+			{
+				vsllink_tap_append_step(0, 0);
+			}
+			else if (path[j + i] == tap_state_transition(tap_get_state(), true))
+			{
+				vsllink_tap_append_step(1, 0);
+			}
+			else
+			{
+				LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_name(tap_get_state()), tap_state_name(path[i]));
+				exit(-1);
+			}
+			tap_set_state(path[j + i]);
+		}
+	}
+	
+	tap_set_end_state(tap_get_state());
+}
 
-static void vsllink_stableclocks(int num_cycles, int tms)
+static void vsllink_stableclocks_normal(int num_cycles, int tms)
 {
 	int tms_len;
 	u16 tms_append_byte;
-
+	
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		// there are vsllink_tms_data_len more tms bits to be shifted
@@ -850,7 +1055,7 @@
 				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
 				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte &gt;&gt; 8);
 			}
-
+			
 			vsllink_tms_data_len = tms_len &amp; 7;
 			if (vsllink_tms_data_len == 0)
 			{
@@ -863,14 +1068,14 @@
 			// more shifts will be needed
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte &gt;&gt; 8);
-
+			
 			num_cycles -= 16 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
 			vsllink_tms_cmd_pos = NULL;
 		}
 	}
 	// from here vsllink_tms_data_len == 0 or num_cycles == 0
-
+	
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		// num_cycles == 0
@@ -903,17 +1108,17 @@
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 8) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 16) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 24) &amp; 0xff;
-
+			
 			vsllink_usb_in_want_length += 1;
 			pending_scan_results_buffer[pending_scan_results_length].buffer = NULL;
 			pending_scan_results_length++;
-
+			
 			if (tms_len &gt; 0xFFFF)
 			{
 				vsllink_tap_execute();
 			}
 		}
-
+		
 		// post-process
 		vsllink_tms_data_len = num_cycles &amp; 7;
 		if (vsllink_tms_data_len &gt; 0)
@@ -934,20 +1139,62 @@
 		}
 	}
 }
+static void vsllink_stableclocks_dma(int num_cycles, int tms)
+{
+	int i, cur_cycles;
+	
+	if (tap_length &amp; 7)
+	{
+		if ((8 - (tap_length &amp; 7)) &lt; num_cycles)
+		{
+			cur_cycles = 8 - (tap_length &amp; 7);
+		}
+		else
+		{
+			cur_cycles = num_cycles;
+		}
+		for (i = 0; i &lt; cur_cycles; i++)
+		{
+			vsllink_tap_append_step(tms, 0);
+		}
+		num_cycles -= cur_cycles;
+	}
+	
+	while (num_cycles &gt; 0)
+	{
+		if (num_cycles &gt; 8 * tap_buffer_size)
+		{
+			cur_cycles = 8 * tap_buffer_size;
+		}
+		else
+		{
+			cur_cycles = num_cycles;
+		}
+		
+		vsllink_tap_ensure_space(0, cur_cycles);
+		
+		for (i = 0; i &lt; cur_cycles; i++)
+		{
+			vsllink_tap_append_step(tms, 0);
+		}
+		
+		num_cycles -= cur_cycles;
+	}
+}
 
 static void vsllink_runtest(int num_cycles)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
-
+	
 	if (tap_get_state() != TAP_IDLE)
 	{
 		// enter into IDLE state
 		vsllink_end_state(TAP_IDLE);
 		vsllink_state_move();
 	}
-
+	
 	vsllink_stableclocks(num_cycles, 0);
-
+	
 	// post-process
 	// set end_state
 	vsllink_end_state(saved_end_state);
@@ -958,29 +1205,29 @@
 	}
 }
 
-static void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void vsllink_scan_normal(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
 	u8 bits_left, tms_tmp, tdi_len;
 	int i;
-
+	
 	if (0 == scan_size )
 	{
 		return;
 	}
-
+	
 	tdi_len = ((scan_size + 7) &gt;&gt; 3);
 	if ((tdi_len + 7) &gt; VSLLINK_BufferSize)
 	{
 		LOG_ERROR(&quot;Your implementation of VSLLink has not enough buffer&quot;);
 		exit(-1);
 	}
-
+	
 	saved_end_state = tap_get_end_state();
-
+	
 	/* Move to appropriate scan state */
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
-
+	
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		if (tap_get_state() == tap_get_end_state())
@@ -1002,16 +1249,16 @@
 				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 				*vsllink_tms_cmd_pos -= 2;
 			}
-
+			
 			vsllink_tap_ensure_space(1, tdi_len + 7);
-			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid
+			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid 
 			// which is merged from the last tms shift command
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)&gt;&gt; 8) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = tms_tmp;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[0] &lt;&lt; (8 - vsllink_tms_data_len);
-
+			
 			for (i = 0; i &lt; tdi_len; i++)
 			{
 				buffer[i] &gt;&gt;= 8 - vsllink_tms_data_len;
@@ -1020,40 +1267,40 @@
 					buffer[i] += buffer[i + 1] &lt;&lt; vsllink_tms_data_len;
 				}
 			}
-
-			vsllink_tap_append_scan(scan_size - vsllink_tms_data_len, buffer, command, vsllink_tms_data_len);
+			
+			vsllink_tap_append_scan_normal(scan_size - vsllink_tms_data_len, buffer, command, vsllink_tms_data_len);
 			scan_size -= 8 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
 		}
 		else
 		{
-			vsllink_append_tms();
+			vsllink_state_move();
 			vsllink_tap_ensure_space(1, tdi_len + 5);
-
+			
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 0) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 8) &amp; 0xff;
-
-			vsllink_tap_append_scan(scan_size, buffer, command, 0);
+			
+			vsllink_tap_append_scan_normal(scan_size, buffer, command, 0);
 		}
 	}
 	else
 	{
 		vsllink_tap_ensure_space(1, tdi_len + 7);
-
+		
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)&gt;&gt; 8) &amp; 0xff;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-
-		vsllink_tap_append_scan(scan_size, buffer, command, 8);
+		
+		vsllink_tap_append_scan_normal(scan_size, buffer, command, 8);
 	}
 	vsllink_end_state(saved_end_state);
-
+	
 	bits_left = scan_size &amp; 0x07;
 	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
-
+	
 	if (bits_left &gt; 0)
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; (bits_left - 1);
@@ -1062,7 +1309,7 @@
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; 7;
 	}
-
+	
 	if (tap_get_state() != tap_get_end_state())
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
@@ -1071,16 +1318,44 @@
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
 	}
-
+	
 	tap_set_state(tap_get_end_state());
 }
+static void vsllink_scan_dma(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+{
+	tap_state_t saved_end_state;
+	
+	saved_end_state = tap_get_end_state();
+	
+	/* Move to appropriate scan state */
+	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
+	
+	vsllink_state_move();
+	vsllink_end_state(saved_end_state);
+	
+	/* Scan */
+	vsllink_tap_ensure_space(1, (scan_size + 7) &amp; ~0x00000007);
+	vsllink_tap_append_scan_dma(scan_size, buffer, command);
+	
+	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
+	while (tap_length % 8 != 0)
+	{
+		// more 0s in Pause
+		vsllink_tap_append_step(0, 0);
+	}
+	
+	if (tap_get_state() != tap_get_end_state())
+	{
+		vsllink_state_move();
+	}
+}
 
 static void vsllink_reset(int trst, int srst)
 {
 	int result;
-
+	
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
-
+	
 	/* Signals are active low */
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORT;
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
@@ -1093,7 +1368,7 @@
 	{
 		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_TRST;
 	}
-
+	
 	result = vsllink_usb_write(vsllink_jtag_handle, 3);
 	if (result != 3)
 	{
@@ -1104,92 +1379,202 @@
 static void vsllink_simple_command(u8 command)
 {
 	int result;
-
+	
 	DEBUG_JTAG_IO(&quot;0x%02x&quot;, command);
-
+	
 	vsllink_usb_out_buffer[0] = command;
 	result = vsllink_usb_write(vsllink_jtag_handle, 1);
-
+	
 	if (result != 1)
 	{
 		LOG_ERROR(&quot;VSLLink command 0x%02x failed (%d)&quot;, command, result);
 	}
 }
 
-static int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int vsllink_register_commands(struct command_context_s *cmd_ctx)
 {
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;, vsllink_handle_usb_pid_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;, vsllink_handle_usb_bulkin_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;, vsllink_handle_usb_bulkout_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_interface&quot;, vsllink_handle_usb_interface_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_mode&quot;, vsllink_handle_mode_command, 
+					COMMAND_CONFIG, NULL);
+					
+	return ERROR_OK;
+}
+
+static int vsllink_handle_mode_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
 	if (argc != 1) {
 		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
+		return ERROR_FAIL;
+	}
+	
+	if (!strcmp(args[0], &quot;normal&quot;))
+	{
+		vsllink_mode = VSLLINK_MODE_NORMAL;
+	}
+	else if (!strcmp(args[0], &quot;dma&quot;))
+	{
+		vsllink_mode = VSLLINK_MODE_DMA;
+	}
+	else
+	{
+		LOG_ERROR(&quot;invalid vsllink_mode: %s&quot;, args[0]);
+		return ERROR_FAIL;
+	}
+	
+	return ERROR_OK;
+}
+
+static int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc != 1)
+	{
+		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
 		return ERROR_OK;
 	}
-
-	vsllink_vid = strtol(args[0], NULL, 0);
-
+	
+	vsllink_usb_vid = strtol(args[0], NULL, 0);
+	
 	return ERROR_OK;
 }
 
 static int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	if (argc != 1) {
+	if (argc != 1)
+	{
 		LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
 		return ERROR_OK;
 	}
-
-	vsllink_pid = strtol(args[0], NULL, 0);
-
+	
+	vsllink_usb_pid = strtol(args[0], NULL, 0);
+	
 	return ERROR_OK;
 }
 
 static int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	if (argc != 1) {
+	if (argc != 1)
+	{
 		LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN endpoint&quot;);
 		return ERROR_OK;
 	}
-
-	vsllink_bulkin = strtol(args[0], NULL, 0) | 0x80;
-
+	
+	vsllink_usb_bulkin = strtol(args[0], NULL, 0) | 0x80;
+	
 	return ERROR_OK;
 }
 
 static int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	if (argc != 1) {
+	if (argc != 1)
+	{
 		LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT endpoint&quot;);
 		return ERROR_OK;
 	}
+	
+	vsllink_usb_bulkout = strtol(args[0], NULL, 0);
+	
+	return ERROR_OK;
+}
 
-	vsllink_bulkout = strtol(args[0], NULL, 0);
-
+static int vsllink_handle_usb_interface_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc != 1)
+	{
+		LOG_ERROR(&quot;parameter error, should be one parameter for interface number&quot;);
+		return ERROR_OK;
+	}
+	
+	vsllink_usb_interface = strtol(args[0], NULL, 0);
+	
 	return ERROR_OK;
 }
 
 /***************************************************************************/
 /* VSLLink tap functions */
 
-static void vsllink_tap_init(void)
+static void vsllink_tap_init_normal(void)
 {
 	vsllink_usb_out_buffer_idx = 0;
 	vsllink_usb_in_want_length = 0;
 	pending_scan_results_length = 0;
 }
+static void vsllink_tap_init_dma(void)
+{
+	tap_length = 0;
+	pending_scan_results_length = 0;
+}
 
-static void vsllink_tap_ensure_space(int scans, int bytes)
+static void vsllink_tap_ensure_space_normal(int scans, int length)
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bytes = VSLLINK_BufferSize - vsllink_usb_out_buffer_idx;
-
-	if (scans &gt; available_scans || bytes &gt; available_bytes)
+	
+	if (scans &gt; available_scans || length &gt; available_bytes)
 	{
 		vsllink_tap_execute();
 	}
 }
+static void vsllink_tap_ensure_space_dma(int scans, int length)
+{
+	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
+	int available_bytes = tap_buffer_size * 8 - tap_length;
+	
+	if (scans &gt; available_scans || length &gt; available_bytes)
+	{
+		vsllink_tap_execute();
+	}
+}
 
-static void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset)
+static void vsllink_tap_append_step(int tms, int tdi)
 {
+	last_tms = tms;
+	int index = tap_length / 8;
+	
+	if (index &lt; tap_buffer_size)
+	{
+		int bit_index = tap_length % 8;
+		u8 bit = 1 &lt;&lt; bit_index;
+		
+		if (tms)
+		{
+			tms_buffer[index] |= bit;
+		}
+		else
+		{
+			tms_buffer[index] &amp;= ~bit;
+		}
+		
+		if (tdi)
+		{
+			tdi_buffer[index] |= bit;
+		}
+		else
+		{
+			tdi_buffer[index] &amp;= ~bit;
+		}
+		
+		tap_length++;
+	}
+	else
+	{
+		LOG_ERROR(&quot;buffer overflow, tap_length=%d&quot;, tap_length);
+	}
+}
+
+static void vsllink_tap_append_scan_normal(int length, u8 *buffer, scan_command_t *command, int offset)
+{
 	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 	int i;
-
+	
 	if (offset &gt; 0)
 	{
 		vsllink_usb_in_want_length += ((length + 7) &gt;&gt; 3) + 1;
@@ -1202,30 +1587,47 @@
 	pending_scan_result-&gt;offset = offset;
 	pending_scan_result-&gt;command = command;
 	pending_scan_result-&gt;buffer = buffer;
-
+	
 	for (i = 0; i &lt; ((length + 7) &gt;&gt; 3); i++)
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[i];
 	}
-
+	
 	pending_scan_results_length++;
 }
+static void vsllink_tap_append_scan_dma(int length, u8 *buffer, scan_command_t *command)
+{
+	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
+	int i;
+	
+	pending_scan_result-&gt;offset = tap_length;
+	pending_scan_result-&gt;length = length;
+	pending_scan_result-&gt;command = command;
+	pending_scan_result-&gt;buffer = buffer;
+	
+	for (i = 0; i &lt; length; i++)
+	{
+		vsllink_tap_append_step((i &lt; length-1 ? 0 : 1), (buffer[i/8] &gt;&gt; (i%8)) &amp; 1);
+	}
+	
+	pending_scan_results_length++;
+}
 
 /* Pad and send a tap sequence to the device, and receive the answer.
  * For the purpose of padding we assume that we are in reset or idle or pause state. */
-static int vsllink_tap_execute(void)
+static int vsllink_tap_execute_normal(void)
 {
 	int i;
 	int result;
 	int first = 0;
-
+	
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		if((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE))
 		{
 			LOG_WARNING(&quot;%s is not in RESET or IDLE or PAUSR state&quot;, tap_state_name(tap_get_state()));
 		}
-
+		
 		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] &amp; (1 &lt;&lt; (vsllink_tms_data_len - 1)))
 		{
 			// last tms bit is '1'
@@ -1241,7 +1643,7 @@
 			vsllink_tms_data_len = 0;
 		}
 	}
-
+	
 	if (vsllink_usb_out_buffer_idx &gt; 3)
 	{
 		if (vsllink_usb_out_buffer[0] == VSLLINK_CMD_HW_JTAGSEQCMD)
@@ -1249,9 +1651,9 @@
 			vsllink_usb_out_buffer[1] = (vsllink_usb_out_buffer_idx &gt;&gt; 0) &amp; 0xff;
 			vsllink_usb_out_buffer[2] = (vsllink_usb_out_buffer_idx &gt;&gt; 8) &amp; 0xff;
 		}
-
+		
 		result = vsllink_usb_message(vsllink_jtag_handle, vsllink_usb_out_buffer_idx, vsllink_usb_in_want_length);
-
+		
 		if (result == vsllink_usb_in_want_length)
 		{
 			for (i = 0; i &lt; pending_scan_results_length; i++)
@@ -1261,24 +1663,24 @@
 				int length = pending_scan_result-&gt;length;
 				int offset = pending_scan_result-&gt;offset;
 				scan_command_t *command = pending_scan_result-&gt;command;
-
+				
 				if (buffer != NULL)
 				{
 					// IRSHIFT or DRSHIFT
 					buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
 					first += (length + offset + 7) &gt;&gt; 3;
-
+					
 					DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits):&quot;, length);
 #ifdef _DEBUG_JTAG_IO_
 					vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
 #endif
-
+					
 					if (jtag_read_buffer(buffer, command) != ERROR_OK)
 					{
 						vsllink_tap_init();
 						return ERROR_JTAG_QUEUE_FAILED;
 					}
-
+					
 					free(pending_scan_result-&gt;buffer);
 					pending_scan_result-&gt;buffer = NULL;
 				}
@@ -1293,68 +1695,162 @@
 			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, vsllink_usb_in_want_length);
 			return ERROR_JTAG_QUEUE_FAILED;
 		}
-
+		
 		vsllink_tap_init();
 	}
-
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
-	vsllink_usb_out_buffer_idx = 3;
-
+	reset_command_pointer();
+	
 	return ERROR_OK;
 }
+static int vsllink_tap_execute_dma(void)
+{
+	int byte_length;
+	int i;
+	int result;
+	
+	if (tap_length &gt; 0)
+	{
+		/* Pad last byte so that tap_length is divisible by 8 */
+		while (tap_length % 8 != 0)
+		{
+			/* More of the last TMS value keeps us in the same state,
+			 * analogous to free-running JTAG interfaces. */
+			vsllink_tap_append_step(last_tms, 0);
+		}
+		byte_length = tap_length / 8;
+		
+		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGRAWCMD;
+		vsllink_usb_out_buffer[1] = ((byte_length * 2 + 3) &gt;&gt; 0) &amp; 0xff;		// package size
+		vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) &gt;&gt; 8) &amp; 0xff;
+		
+		memcpy(&amp;vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
+		memcpy(&amp;vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
+		
+		result = vsllink_usb_message(vsllink_jtag_handle, 3 + 2 * byte_length, byte_length);
+		if (result == byte_length)
+		{
+			for (i = 0; i &lt; pending_scan_results_length; i++)
+			{
+				pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[i];
+				u8 *buffer = pending_scan_result-&gt;buffer;
+				int length = pending_scan_result-&gt;length;
+				int first = pending_scan_result-&gt;offset;
+				
+				scan_command_t *command = pending_scan_result-&gt;command;
+				buf_set_buf(vsllink_usb_in_buffer, first, buffer, 0, length);
+				
+				DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits, from %d bits):&quot;, length, first);
+#ifdef _DEBUG_JTAG_IO_
+				vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
+#endif
+				
+				if (jtag_read_buffer(buffer, command) != ERROR_OK)
+				{
+					vsllink_tap_init();
+					return ERROR_JTAG_QUEUE_FAILED;
+				}
+				
+				if (pending_scan_result-&gt;buffer != NULL)
+				{
+					free(pending_scan_result-&gt;buffer);
+				}
+			}
+		}
+		else
+		{
+			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, byte_length);
+			return ERROR_JTAG_QUEUE_FAILED;
+		}
+		
+		vsllink_tap_init();
+	}
+	
+	return ERROR_OK;
+}
 
 /*****************************************************************************/
 /* VSLLink USB low-level functions */
 
-vsllink_jtag_t* vsllink_usb_open(void)
+static vsllink_jtag_t* vsllink_usb_open(void)
 {
 	struct usb_bus *busses;
 	struct usb_bus *bus;
 	struct usb_device *dev;
-
+	int ret;
+	
 	vsllink_jtag_t *result;
-
+	
 	result = (vsllink_jtag_t*) malloc(sizeof(vsllink_jtag_t));
-
+	
 	usb_init();
 	usb_find_busses();
 	usb_find_devices();
-
+	
 	busses = usb_get_busses();
-
+	
 	/* find vsllink_jtag device in usb bus */
-
+	
 	for (bus = busses; bus; bus = bus-&gt;next)
 	{
 		for (dev = bus-&gt;devices; dev; dev = dev-&gt;next)
 		{
-			if ((dev-&gt;descriptor.idVendor == vsllink_vid) &amp;&amp; (dev-&gt;descriptor.idProduct == vsllink_pid))
+			if ((dev-&gt;descriptor.idVendor == vsllink_usb_vid) &amp;&amp; (dev-&gt;descriptor.idProduct == vsllink_usb_pid))
 			{
 				result-&gt;usb_handle = usb_open(dev);
-
+				if (NULL == result-&gt;usb_handle)
+				{
+					LOG_ERROR(&quot;failed to open %04X:%04X, not enough permissions?&quot;, vsllink_usb_vid, vsllink_usb_pid);
+					exit(-1);
+				}
+				
 				/* usb_set_configuration required under win32 */
-				usb_set_configuration(result-&gt;usb_handle, dev-&gt;config[0].bConfigurationValue);
-				usb_claim_interface(result-&gt;usb_handle, 0);
-
+				ret = usb_set_configuration(result-&gt;usb_handle, dev-&gt;config[0].bConfigurationValue);
+				if (ret != 0)
+				{
+					LOG_ERROR(&quot;fail to set configuration to %d, %d returned, not enough permissions?&quot;, dev-&gt;config[0].bConfigurationValue, ret);
+					exit(-1);
+				}
+				ret = usb_claim_interface(result-&gt;usb_handle, vsllink_usb_interface);
+				if (ret != 0)
+				{
+					LOG_ERROR(&quot;fail to claim interface %d, %d returned&quot;, vsllink_usb_interface, ret);
+					exit(-1);
+				}
+				
 #if 0
-				/*
+				/* 
 				 * This makes problems under Mac OS X. And is not needed
 				 * under Windows. Hopefully this will not break a linux build
 				 */
 				usb_set_altinterface(result-&gt;usb_handle, 0);
-#endif
+#endif				
 				return result;
 			}
 		}
 	}
-
+	
 	free(result);
 	return NULL;
 }
 
 static void vsllink_usb_close(vsllink_jtag_t *vsllink_jtag)
 {
-	usb_close(vsllink_jtag-&gt;usb_handle);
+	int ret;
+
+	ret = usb_release_interface(vsllink_jtag-&gt;usb_handle, vsllink_usb_interface);
+	if (ret != 0)
+	{
+		LOG_ERROR(&quot;fail to release interface %d, %d returned&quot;, vsllink_usb_interface, ret);
+		exit(-1);
+	}
+
+	ret = usb_close(vsllink_jtag-&gt;usb_handle);
+	if (ret != 0)
+	{
+		LOG_ERROR(&quot;fail to close usb, %d returned&quot;, ret);
+		exit(-1);
+	}
+
 	free(vsllink_jtag);
 }
 
@@ -1362,7 +1858,7 @@
 static int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length)
 {
 	int result;
-
+	
 	result = vsllink_usb_write(vsllink_jtag, out_length);
 	if (result == out_length)
 	{
@@ -1392,18 +1888,18 @@
 static int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length)
 {
 	int result;
-
+	
 	if (out_length &gt; VSLLINK_BufferSize)
 	{
 		LOG_ERROR(&quot;vsllink_jtag_write illegal out_length=%d (max=%d)&quot;, out_length, VSLLINK_BufferSize);
 		return -1;
 	}
-
-	result = usb_bulk_write(vsllink_jtag-&gt;usb_handle, vsllink_bulkout, \
+	
+	result = usb_bulk_write(vsllink_jtag-&gt;usb_handle, vsllink_usb_bulkout, \
 		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
-
+	
 	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;, out_length, result);
-
+	
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG(&quot;USB out:&quot;);
 	vsllink_debug_buffer(vsllink_usb_out_buffer, out_length);
@@ -1419,11 +1915,11 @@
 /* Read data from USB into in_buffer. */
 static int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag)
 {
-	int result = usb_bulk_read(vsllink_jtag-&gt;usb_handle, vsllink_bulkin, \
+	int result = usb_bulk_read(vsllink_jtag-&gt;usb_handle, vsllink_usb_bulkin, \
 		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize, VSLLINK_USB_TIMEOUT);
-
+		
 	DEBUG_JTAG_IO(&quot;vsllink_usb_read, result = %d&quot;, result);
-
+	
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG(&quot;USB in:&quot;);
 	vsllink_debug_buffer(vsllink_usb_in_buffer, result);
@@ -1440,7 +1936,7 @@
 	char s[4];
 	int i;
 	int j;
-
+	
 	for (i = 0; i &lt; length; i += BYTES_PER_LINE)
 	{
 		snprintf(line, 5, &quot;%04x&quot;, i);

Added: trunk/src/target/interface/vsllink.cfg
===================================================================
--- trunk/src/target/interface/vsllink.cfg	2009-04-21 09:05:02 UTC (rev 1490)
+++ trunk/src/target/interface/vsllink.cfg	2009-04-21 09:08:43 UTC (rev 1491)
@@ -0,0 +1,25 @@
+#
+# Versaloon Link -- VSLLink
+#
+# <A HREF="http://www.simonqian.com/en/Versaloon">http://www.simonqian.com/en/Versaloon</A>
+#
+
+interface vsllink
+
+#vsllink_usb_vid		0x03EB
+#vsllink_usb_pid		0x2103
+#vsllink_usb_bulkin	0x02
+#vsllink_usb_bulkout	0x02
+#vsllink_usb_interface	0
+
+vsllink_usb_vid		0x0483
+vsllink_usb_pid		0x5740
+vsllink_usb_bulkin	0x02
+vsllink_usb_bulkout	0x03
+vsllink_usb_interface	1
+
+# vsllink mode, dma or normal
+# for low jtag_khz, use normal
+# for high jtag_khz, use dma
+#vsllink_mode dma
+vsllink_mode normal


Property changes on: trunk/src/target/interface/vsllink.cfg
___________________________________________________________________
Name: svn:eol-style
   + native


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000274.html">[Openocd-svn] r1490 - trunk
</A></li>
	<LI>Next message: <A HREF="000276.html">[Openocd-svn] r1492 - trunk/src/jtag
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#275">[ date ]</a>
              <a href="thread.html#275">[ thread ]</a>
              <a href="subject.html#275">[ subject ]</a>
              <a href="author.html#275">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
