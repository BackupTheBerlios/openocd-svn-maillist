<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1538 - trunk/src/target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1538%20-%20trunk/src/target&In-Reply-To=%3C200904271005.n3RA5GUJ011938%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000321.html">
   <LINK REL="Next"  HREF="000323.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1538 - trunk/src/target</H1>
    <B>mlu at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1538%20-%20trunk/src/target&In-Reply-To=%3C200904271005.n3RA5GUJ011938%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1538 - trunk/src/target">mlu at mail.berlios.de
       </A><BR>
    <I>Mon Apr 27 12:05:16 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000321.html">[Openocd-svn] r1537 - trunk/src/jtag
</A></li>
        <LI>Next message: <A HREF="000323.html">[Openocd-svn] r1539 - trunk/src/target/target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#322">[ date ]</a>
              <a href="thread.html#322">[ thread ]</a>
              <a href="subject.html#322">[ subject ]</a>
              <a href="author.html#322">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mlu
Date: 2009-04-27 12:05:15 +0200 (Mon, 27 Apr 2009)
New Revision: 1538

Removed:
   trunk/src/target/cortex_swjdp.c
   trunk/src/target/cortex_swjdp.h
Log:
Deleted depreciated files ( new versions are arm_adi_v5.c/h )

Deleted: trunk/src/target/cortex_swjdp.c
===================================================================
--- trunk/src/target/cortex_swjdp.c	2009-04-27 09:12:18 UTC (rev 1537)
+++ trunk/src/target/cortex_swjdp.c	2009-04-27 10:05:15 UTC (rev 1538)
@@ -1,1029 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Oyvind Harboe                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *																		   *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-/***************************************************************************
- *                                                                         *
- * CoreSight (Light?) SerialWireJtagDebugPort                              *
- *                                                                         *
- * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316A                                *
- * Cortex-M3(tm) TRM, ARM DDI 0337C                                         *
- *                                                                         *
-***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;replacements.h&quot;
-
-#include &quot;cortex_m3.h&quot;
-#include &quot;cortex_swjdp.h&quot;
-#include &quot;jtag.h&quot;
-#include &quot;log.h&quot;
-#include &quot;time_support.h&quot;
-#include &lt;stdlib.h&gt;
-
-/*
- * Transaction Mode:
- * swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
- * Uses Overrun checking mode and does not do actual JTAG send/receive or transaction
- * result checking until swjdp_end_transaction()
- * This must be done before using or deallocating any return variables.
- * swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC
- * All reads and writes to the AHB bus are checked for valid completion, and return values
- * are immediatley available.
-*/
-
-/***************************************************************************
- *                                                                         *
- * DPACC and APACC scanchain access through JTAG-DR                        *
- *                                                                         *
-***************************************************************************/
-
-/* Scan out and in from target ordered u8 buffers */
-int swjdp_scan(arm_jtag_t *jtag_info, u8 instr, u8 reg_addr, u8 RnW, u8 *outvalue, u8 *invalue, u8 *ack)
-{
-	scan_field_t fields[2];
-	u8 out_addr_buf;
-
-	jtag_add_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	fields[0].tap = jtag_info-&gt;tap;
-	fields[0].num_bits = 3;
-	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
-	fields[0].out_value = &amp;out_addr_buf;
-	fields[0].out_mask = NULL;
-	fields[0].in_value = ack;
-	fields[0].in_check_value = NULL;
-	fields[0].in_check_mask = NULL;
-	fields[0].in_handler = NULL;
-	fields[0].in_handler_priv = NULL;
-
-	fields[1].tap = jtag_info-&gt;tap;
-	fields[1].num_bits = 32;
-	fields[1].out_value = outvalue;
-	fields[1].out_mask = NULL;
-	fields[1].in_value = invalue;
-	fields[1].in_handler = NULL;
-	fields[1].in_handler_priv = NULL;
-	fields[1].in_check_value = NULL;
-	fields[1].in_check_mask = NULL;
-
-	jtag_add_dr_scan(2, fields, TAP_INVALID);
-
-	return ERROR_OK;
-}
-
-/* Scan out and in from host ordered u32 variables */
-int swjdp_scan_u32(arm_jtag_t *jtag_info, u8 instr, u8 reg_addr, u8 RnW, u32 outvalue, u32 *invalue, u8 *ack)
-{
-	scan_field_t fields[2];
-	u8 out_value_buf[4];
-	u8 out_addr_buf;
-
-	jtag_add_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	fields[0].tap = jtag_info-&gt;tap;
-	fields[0].num_bits = 3;
-	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
-	fields[0].out_value = &amp;out_addr_buf;
-	fields[0].out_mask = NULL;
-	fields[0].in_value = ack;
-	fields[0].in_check_value = NULL;
-	fields[0].in_check_mask = NULL;
-	fields[0].in_handler = NULL;
-	fields[0].in_handler_priv = NULL;
-
-	fields[1].tap = jtag_info-&gt;tap;
-	fields[1].num_bits = 32;
-	buf_set_u32(out_value_buf, 0, 32, outvalue);
-	fields[1].out_value = out_value_buf;
-	fields[1].out_mask = NULL;
-	fields[1].in_value = NULL;
-	if (invalue)
-	{
-		fields[1].in_handler = arm_jtag_buf_to_u32;
-		fields[1].in_handler_priv = invalue;
-	}
-	else
-	{
-		fields[1].in_handler = NULL;
-		fields[1].in_handler_priv = NULL;
-	}
-	fields[1].in_check_value = NULL;
-	fields[1].in_check_mask = NULL;
-
-	jtag_add_dr_scan(2, fields, TAP_INVALID);
-
-	return ERROR_OK;
-}
-
-/* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */
-int scan_inout_check(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u8 *outvalue, u8 *invalue)
-{
-	swjdp_scan(swjdp-&gt;jtag_info, instr, reg_addr, RnW, outvalue, NULL, NULL);
-	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-	{
-		swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
-	}
-
-	/* In TRANS_MODE_ATOMIC all SWJDP_IR_APACC transactions wait for ack=OK/FAULT and the check CTRL_STAT */
-	if ((instr == SWJDP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
-	{
-		return swjdp_transaction_endcheck(swjdp);
-	}
-
-	return ERROR_OK;
-}
-
-int scan_inout_check_u32(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u32 outvalue, u32 *invalue)
-{
-	swjdp_scan_u32(swjdp-&gt;jtag_info, instr, reg_addr, RnW, outvalue, NULL, NULL);
-	if ((RnW==DPAP_READ) &amp;&amp; (invalue != NULL))
-	{
-		swjdp_scan_u32(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
-	}
-
-	/* In TRANS_MODE_ATOMIC all SWJDP_IR_APACC transactions wait for ack=OK/FAULT and then check CTRL_STAT */
-	if ((instr == SWJDP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
-	{
-		return swjdp_transaction_endcheck(swjdp);
-	}
-
-	return ERROR_OK;
-}
-
-int swjdp_transaction_endcheck(swjdp_common_t *swjdp)
-{
-	int retval;
-	u32 ctrlstat;
-
-	/* too expensive to call keep_alive() here */
-
-#if 0
-	/* Danger!!!! BROKEN!!!! */
-	scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
-	R956 introduced the check on return value here and now Michael Schwingen reports
-	that this code no longer works....
-
-	<A HREF="https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html">https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html</A>
-	*/
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
-	{
-		LOG_ERROR(&quot;BUG: Why does this fail the first time????&quot;);
-	}
-	/* Why??? second time it works??? */
-#endif
-
-	scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
-		return retval;
-
-	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
-
-	if (swjdp-&gt;ack != 2)
-	{
-		long long then=timeval_ms();
-		while (swjdp-&gt;ack != 2)
-		{
-			if (swjdp-&gt;ack == 1)
-			{
-				if ((timeval_ms()-then) &gt; 1000)
-				{
-					LOG_WARNING(&quot;Timeout (1000ms) waiting for ACK = OK/FAULT in SWJDP transaction&quot;);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-			else
-			{
-				LOG_WARNING(&quot;Invalid ACK in SWJDP transaction&quot;);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval=jtag_execute_queue())!=ERROR_OK)
-				return retval;
-			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
-		}
-	} else
-	{
-		/* common code path avoids fn to timeval_ms() */
-	}
-
-	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat &amp; (SSTICKYORUN | SSTICKYERR))
-	{
-		LOG_DEBUG(&quot;swjdp: CTRL/STAT error 0x%x&quot;, ctrlstat);
-		/* Check power to debug regions */
-		if ((ctrlstat &amp; 0xf0000000) != 0xf0000000)
-		{
-			 ahbap_debugport_init(swjdp);
-		}
-		else
-		{
-			u32 dcb_dhcsr,nvic_shcsr, nvic_bfar, nvic_cfsr;
-
-			/* Print information about last AHBAP access */
-			LOG_ERROR(&quot;AHBAP: dp_select 0x%x, ap_csw 0x%x, ap_tar 0x%x&quot;, swjdp-&gt;dp_select_value, swjdp-&gt;ap_csw_value, swjdp-&gt;ap_tar_value);
-			if (ctrlstat &amp; SSTICKYORUN)
-				LOG_ERROR(&quot;SWJ-DP OVERRUN - check clock or reduce jtag speed&quot;);
-
-			if (ctrlstat &amp; SSTICKYERR)
-				LOG_ERROR(&quot;SWJ-DP STICKY ERROR&quot;);
-
-			/* Clear Sticky Error Bits */
-			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_WRITE, swjdp-&gt;dp_ctrl_stat | SSTICKYORUN | SSTICKYERR, NULL);
-			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval=jtag_execute_queue())!=ERROR_OK)
-				return retval;
-
-			LOG_DEBUG(&quot;swjdp: status 0x%x&quot;, ctrlstat);
-
-			/* Can we find out the reason for the error ?? */
-			ahbap_read_system_atomic_u32(swjdp, DCB_DHCSR, &amp;dcb_dhcsr);
-			ahbap_read_system_atomic_u32(swjdp, NVIC_SHCSR, &amp;nvic_shcsr);
-			ahbap_read_system_atomic_u32(swjdp, NVIC_CFSR, &amp;nvic_cfsr);
-			ahbap_read_system_atomic_u32(swjdp, NVIC_BFAR, &amp;nvic_bfar);
-			LOG_ERROR(&quot;dcb_dhcsr 0x%x, nvic_shcsr 0x%x, nvic_cfsr 0x%x, nvic_bfar 0x%x&quot;, dcb_dhcsr, nvic_shcsr, nvic_cfsr, nvic_bfar);
-		}
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-/***************************************************************************
- *                                                                         *
- * DP and AHB-AP  register access  through APACC and DPACC                 *
- *                                                                         *
-***************************************************************************/
-
-int swjdp_write_dpacc(swjdp_common_t *swjdp, u32 value, u8 reg_addr)
-{
-	return scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, reg_addr, DPAP_WRITE, value, NULL);
-}
-
-int swjdp_read_dpacc(swjdp_common_t *swjdp, u32 *value, u8 reg_addr)
-{
-	return scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, reg_addr, DPAP_READ, 0, value);
-}
-
-int swjdp_bankselect_apacc(swjdp_common_t *swjdp,u32 reg_addr)
-{
-	u32 select;
-	select = (reg_addr &amp; 0xFF0000F0);
-
-	if (select != swjdp-&gt;dp_select_value)
-	{
-		swjdp_write_dpacc(swjdp, select, DP_SELECT);
-		swjdp-&gt;dp_select_value = select;
-	}
-
-	return ERROR_OK;
-}
-
-int ahbap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, u8* out_value_buf)
-{
-	swjdp_bankselect_apacc(swjdp, reg_addr);
-	scan_inout_check(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
-
-	return ERROR_OK;
-}
-
-int ahbap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, u8 *in_value_buf)
-{
-	swjdp_bankselect_apacc(swjdp, reg_addr);
-	scan_inout_check(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_READ, 0, in_value_buf);
-
-	return ERROR_OK;
-}
-int ahbap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value)
-{
-	u8 out_value_buf[4];
-
-	buf_set_u32(out_value_buf, 0, 32, value);
-	swjdp_bankselect_apacc(swjdp, reg_addr);
-	scan_inout_check(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
-
-	return ERROR_OK;
-}
-
-int ahbap_read_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 *value)
-{
-	swjdp_bankselect_apacc(swjdp, reg_addr);
-	scan_inout_check_u32(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_READ, 0, value);
-
-	return ERROR_OK;
-}
-
-/***************************************************************************
- *                                                                         *
- * AHB-AP access to memory and system registers on AHB bus                 *
- *                                                                         *
-***************************************************************************/
-
-int ahbap_setup_accessport(swjdp_common_t *swjdp, u32 csw, u32 tar)
-{
-	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
-	if (csw != swjdp-&gt;ap_csw_value)
-	{
-		/* LOG_DEBUG(&quot;swjdp : Set CSW %x&quot;,csw); */
-		ahbap_write_reg_u32(swjdp, AHBAP_CSW, csw );
-		swjdp-&gt;ap_csw_value = csw;
-	}
-	if (tar != swjdp-&gt;ap_tar_value)
-	{
-		/* LOG_DEBUG(&quot;swjdp : Set TAR %x&quot;,tar); */
-		ahbap_write_reg_u32(swjdp, AHBAP_TAR, tar );
-		swjdp-&gt;ap_tar_value = tar;
-	}
-	if (csw &amp; CSW_ADDRINC_MASK)
-	{
-		/* Do not cache TAR value when autoincrementing */
-		swjdp-&gt;ap_tar_value = -1;
-	}
-	return ERROR_OK;
-}
-
-/*****************************************************************************
-*                                                                            *
-* ahbap_read_system_u32(swjdp_common_t *swjdp, u32 address, u32 *value)      *
-*                                                                            *
-* Read a u32 value from memory or system register                            *
-* Functionally equivalent to target_read_u32(target, address, u32 *value),   *
-* but with less overhead                                                     *
-*****************************************************************************/
-int ahbap_read_system_u32(swjdp_common_t *swjdp, u32 address, u32 *value)
-{
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, address &amp; 0xFFFFFFF0);
-	ahbap_read_reg_u32(swjdp, AHBAP_BD0 | (address &amp; 0xC), value );
-
-	return ERROR_OK;
-}
-
-int ahbap_read_system_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 *value)
-{
-	ahbap_read_system_u32(swjdp, address, value);
-
-	return swjdp_transaction_endcheck(swjdp);
-}
-
-/*****************************************************************************
-*                                                                            *
-* ahbap_write_system_u32(swjdp_common_t *swjdp, u32 address, u32 value)      *
-*                                                                            *
-* Write a u32 value to memory or system register                             *
-*                                                                            *
-*****************************************************************************/
-int ahbap_write_system_u32(swjdp_common_t *swjdp, u32 address, u32 value)
-{
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, address &amp; 0xFFFFFFF0);
-	ahbap_write_reg_u32(swjdp, AHBAP_BD0 | (address &amp; 0xC), value );
-
-	return ERROR_OK;
-}
-
-int ahbap_write_system_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value)
-{
-	ahbap_write_system_u32(swjdp, address, value);
-
-	return swjdp_transaction_endcheck(swjdp);
-}
-
-/*****************************************************************************
-*                                                                            *
-* ahbap_write_buf(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address) *
-*                                                                            *
-* Write a buffer in target order (little endian)                             *
-*                                                                            *
-*****************************************************************************/
-int ahbap_write_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 outvalue;
-	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
-	u32 adr = address;
-	u8* pBuffer = buffer;
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	count &gt;&gt;= 2;
-	wcount = count;
-
-	/* if we have an unaligned access - reorder data */
-	if (adr &amp; 0x3u)
-	{
-		for (writecount = 0; writecount &lt; count; writecount++)
-		{
-			int i;
-			outvalue = *((u32*)pBuffer);
-
-			for (i = 0; i &lt; 4; i++ )
-			{
-				*((u8*)pBuffer + (adr &amp; 0x3)) = outvalue;
-				outvalue &gt;&gt;= 8;
-				adr++;
-			}
-			pBuffer += 4;
-		}
-	}
-
-	while (wcount &gt; 0)
-	{
-		/* Adjust to write blocks within 4K aligned boundaries */
-		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 2;
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-
-		for (writecount = 0; writecount &lt; blocksize; writecount++)
-		{
-			ahbap_write_reg(swjdp, AHBAP_DRW, buffer + 4 * writecount );
-		}
-
-		if (swjdp_transaction_endcheck(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address = address + 4 * blocksize;
-			buffer = buffer + 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount &gt; 1)
-		{
-			LOG_WARNING(&quot;Block write error address 0x%x, wcount 0x%x&quot;, address, wcount);
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	return retval;
-}
-
-int ahbap_write_buf_packed_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 outvalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	wcount = count &gt;&gt; 1;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read within 4K block boundaries */
-		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 1;
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN((writecount &lt;&lt; 1), 4);
-
-			if (nbytes &lt; 4 )
-			{
-				if (ahbap_write_buf_u16(swjdp, buffer, nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes &gt;&gt; 1;
-			}
-			else
-			{
-				outvalue = *((u32*)buffer);
-
-				for (i = 0; i &lt; nbytes; i++ )
-				{
-					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
-					outvalue &gt;&gt;= 8;
-					address++;
-				}
-
-				outvalue = *((u32*)buffer);
-				ahbap_write_reg_u32(swjdp, AHBAP_DRW, outvalue);
-				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes &gt;&gt; 1;
-			writecount -= nbytes &gt;&gt; 1;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int ahbap_write_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 outvalue;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return ahbap_write_buf_packed_u16(swjdp, buffer, count, address);
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	while (count &gt; 0)
-	{
-		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		outvalue = *((u16*)buffer) &lt;&lt; 8 * (address &amp; 0x3);
-		ahbap_write_reg_u32(swjdp, AHBAP_DRW, outvalue );
-		retval = swjdp_transaction_endcheck(swjdp);
-		count -= 2;
-		address += 2;
-		buffer += 2;
-	}
-
-	return retval;
-}
-
-int ahbap_write_buf_packed_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 outvalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read within 4K block boundaries */
-		blocksize = (0x1000 - (0xFFF &amp; address));
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN(writecount, 4);
-
-			if (nbytes &lt; 4 )
-			{
-				if (ahbap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes;
-			}
-			else
-			{
-				outvalue = *((u32*)buffer);
-
-				for (i = 0; i &lt; nbytes; i++ )
-				{
-					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
-					outvalue &gt;&gt;= 8;
-					address++;
-				}
-
-				outvalue = *((u32*)buffer);
-				ahbap_write_reg_u32(swjdp, AHBAP_DRW, outvalue);
-				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes;
-			writecount -= nbytes;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int ahbap_write_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 outvalue;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return ahbap_write_buf_packed_u8(swjdp, buffer, count, address);
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	while (count &gt; 0)
-	{
-		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		outvalue = *((u8*)buffer) &lt;&lt; 8 * (address &amp; 0x3);
-		ahbap_write_reg_u32(swjdp, AHBAP_DRW, outvalue );
-		retval = swjdp_transaction_endcheck(swjdp);
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/*********************************************************************************
-*                                                                                *
-* ahbap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)  *
-*                                                                                *
-* Read block fast in target order (little endian) into a buffer                  *
-*                                                                                *
-**********************************************************************************/
-int ahbap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
-	u32 adr = address;
-	u8* pBuffer = buffer;
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	count &gt;&gt;= 2;
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		/* Adjust to read within 4K block boundaries */
-		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 2;
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-
-		/* Scan out first read */
-		swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_APACC, AHBAP_DRW, DPAP_READ, 0, NULL, NULL);
-		for (readcount = 0; readcount &lt; blocksize - 1; readcount++)
-		{
-			/* Scan out read instruction and scan in previous value */
-			swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_APACC, AHBAP_DRW, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
-		}
-
-		/* Scan in last value */
-		swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
-		if (swjdp_transaction_endcheck(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address += 4 * blocksize;
-			buffer += 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount &gt; 1)
-		{
-			LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	/* if we have an unaligned access - reorder data */
-	if (adr &amp; 0x3u)
-	{
-		for (readcount = 0; readcount &lt; count; readcount++)
-		{
-			int i;
-			u32 data = *((u32*)pBuffer);
-
-			for (i = 0; i &lt; 4; i++ )
-			{
-				*((u8*)pBuffer) = (data &gt;&gt; 8 * (adr &amp; 0x3));
-				pBuffer++;
-				adr++;
-			}
-		}
-	}
-
-	return retval;
-}
-
-int ahbap_read_buf_packed_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	wcount = count &gt;&gt; 1;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read within 4K block boundaries */
-		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 1;
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-		readcount = blocksize;
-
-		do
-		{
-			ahbap_read_reg_u32(swjdp, AHBAP_DRW, &amp;invalue );
-			if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN((readcount &lt;&lt; 1), 4);
-
-			for (i = 0; i &lt; nbytes; i++ )
-			{
-				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= (nbytes &gt;&gt; 1);
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int ahbap_read_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 invalue, i;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return ahbap_read_buf_packed_u16(swjdp, buffer, count, address);
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	while (count &gt; 0)
-	{
-		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		ahbap_read_reg_u32(swjdp, AHBAP_DRW, &amp;invalue );
-		retval = swjdp_transaction_endcheck(swjdp);
-		if (address &amp; 0x1)
-		{
-			for (i = 0; i &lt; 2; i++ )
-			{
-				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-		}
-		else
-		{
-			*((u16*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-			address += 2;
-			buffer += 2;
-		}
-		count -= 2;
-	}
-
-	return retval;
-}
-
-int ahbap_read_buf_packed_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	wcount = count;
-
-	while (wcount &gt; 0)
-	{
-		int nbytes;
-
-		/* Adjust to read within 4K block boundaries */
-		blocksize = (0x1000 - (0xFFF &amp; address));
-
-		if (wcount &lt; blocksize)
-			blocksize = wcount;
-
-		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		readcount = blocksize;
-
-		do
-		{
-			ahbap_read_reg_u32(swjdp, AHBAP_DRW, &amp;invalue );
-			if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN(readcount, 4);
-
-			for (i = 0; i &lt; nbytes; i++ )
-			{
-				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= nbytes;
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int ahbap_read_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
-{
-	u32 invalue;
-	int retval = ERROR_OK;
-
-	if (count &gt;= 4)
-		return ahbap_read_buf_packed_u8(swjdp, buffer, count, address);
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	while (count &gt; 0)
-	{
-		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		ahbap_read_reg_u32(swjdp, AHBAP_DRW, &amp;invalue );
-		retval = swjdp_transaction_endcheck(swjdp);
-		*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-int ahbap_read_coreregister_u32(swjdp_common_t *swjdp, u32 *value, int regnum)
-{
-	int retval;
-	u32 dcrdr;
-
-	/* because the DCB_DCRDR is used for the emulated dcc channel
-	 * we gave to save/restore the DCB_DCRDR when used */
-
-	ahbap_read_system_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	/* ahbap_write_system_u32(swjdp, DCB_DCRSR, regnum); */
-	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
-	ahbap_write_reg_u32(swjdp, AHBAP_BD0 | (DCB_DCRSR &amp; 0xC), regnum );
-
-	/* ahbap_read_system_u32(swjdp, DCB_DCRDR, value); */
-	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
-	ahbap_read_reg_u32(swjdp, AHBAP_BD0 | (DCB_DCRDR &amp; 0xC), value );
-
-	ahbap_write_system_u32(swjdp, DCB_DCRDR, dcrdr);
-	retval = swjdp_transaction_endcheck(swjdp);
-	return retval;
-}
-
-int ahbap_write_coreregister_u32(swjdp_common_t *swjdp, u32 value, int regnum)
-{
-	int retval;
-	u32 dcrdr;
-
-	/* because the DCB_DCRDR is used for the emulated dcc channel
-	 * we gave to save/restore the DCB_DCRDR when used */
-
-	ahbap_read_system_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
-
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
-	/* ahbap_write_system_u32(swjdp, DCB_DCRDR, core_regs[i]); */
-	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
-	ahbap_write_reg_u32(swjdp, AHBAP_BD0 | (DCB_DCRDR &amp; 0xC), value );
-
-	/* ahbap_write_system_u32(swjdp, DCB_DCRSR, i | DCRSR_WnR	); */
-	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
-	ahbap_write_reg_u32(swjdp, AHBAP_BD0 | (DCB_DCRSR &amp; 0xC), regnum | DCRSR_WnR );
-
-	ahbap_write_system_u32(swjdp, DCB_DCRDR, dcrdr);
-	retval = swjdp_transaction_endcheck(swjdp);
-	return retval;
-}
-
-int ahbap_debugport_init(swjdp_common_t *swjdp)
-{
-	u32 idreg, romaddr, dummy;
-	u32 ctrlstat;
-	int cnt = 0;
-	int retval;
-
-	LOG_DEBUG(&quot; &quot;);
-
-	swjdp-&gt;ap_csw_value = -1;
-	swjdp-&gt;ap_tar_value = -1;
-	swjdp-&gt;trans_mode = TRANS_MODE_ATOMIC;
-	swjdp_read_dpacc(swjdp, &amp;dummy, DP_CTRL_STAT);
-	swjdp_write_dpacc(swjdp, SSTICKYERR, DP_CTRL_STAT);
-	swjdp_read_dpacc(swjdp, &amp;dummy, DP_CTRL_STAT);
-
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-
-	swjdp_write_dpacc(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
-	swjdp_read_dpacc(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
-		return retval;
-
-	/* Check that we have debug power domains activated */
-	while (!(ctrlstat &amp; CDBGPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
-	{
-		LOG_DEBUG(&quot;swjdp: wait CDBGPWRUPACK&quot;);
-		swjdp_read_dpacc(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	while (!(ctrlstat &amp; CSYSPWRUPACK) &amp;&amp; (cnt++ &lt; 10))
-	{
-		LOG_DEBUG(&quot;swjdp: wait CSYSPWRUPACK&quot;);
-		swjdp_read_dpacc(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	swjdp_read_dpacc(swjdp, &amp;dummy, DP_CTRL_STAT);
-	/* With debug power on we can activate OVERRUN checking */
-	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	swjdp_write_dpacc(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
-	swjdp_read_dpacc(swjdp, &amp;dummy, DP_CTRL_STAT);
-
-	ahbap_read_reg_u32(swjdp, 0xFC, &amp;idreg);
-	ahbap_read_reg_u32(swjdp, 0xF8, &amp;romaddr);
-
-	LOG_DEBUG(&quot;AHB-AP ID Register 0x%x, Debug ROM Address 0x%x&quot;, idreg, romaddr);
-
-	return ERROR_OK;
-}

Deleted: trunk/src/target/cortex_swjdp.h
===================================================================
--- trunk/src/target/cortex_swjdp.h	2009-04-27 09:12:18 UTC (rev 1537)
+++ trunk/src/target/cortex_swjdp.h	2009-04-27 10:05:15 UTC (rev 1538)
@@ -1,133 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef CORTEX_SWJDP_H
-#define CORTEX_SWJDP_H
-
-#include &quot;target.h&quot;
-#include &quot;register.h&quot;
-#include &quot;arm_jtag.h&quot;
-
-#define SWJDP_IR_DPACC	0xA
-#define SWJDP_IR_APACC	0xB
-
-#define DPAP_WRITE		0
-#define DPAP_READ		1
-#define DP_ZERO			0
-#define DP_CTRL_STAT	0x4
-#define DP_SELECT		0x8
-#define DP_RDBUFF		0xC
-
-#define CORUNDETECT		(1&lt;&lt;0)
-#define SSTICKYORUN		(1&lt;&lt;1)
-#define SSTICKYERR		(1&lt;&lt;5)
-#define CDBGRSTREQ		(1&lt;&lt;26)
-#define CDBGRSTACK		(1&lt;&lt;27)
-#define CDBGPWRUPREQ	(1&lt;&lt;28)
-#define CDBGPWRUPACK	(1&lt;&lt;29)
-#define CSYSPWRUPREQ	(1&lt;&lt;30)
-#define CSYSPWRUPACK	(1&lt;&lt;31)
-
-#define	AHBAP_CSW		0x00
-#define AHBAP_TAR		0x04
-#define AHBAP_DRW		0x0C
-#define AHBAP_BD0		0x10
-#define AHBAP_BD1		0x14
-#define AHBAP_BD2		0x18
-#define AHBAP_BD3		0x1C
-#define AHBAP_DBGROMA	0xF8
-#define AHBAP_IDR		0xFC
-
-#define CSW_8BIT		0
-#define CSW_16BIT		1
-#define CSW_32BIT		2
-
-#define CSW_ADDRINC_MASK	(3&lt;&lt;4)
-#define CSW_ADDRINC_OFF		0
-#define CSW_ADDRINC_SINGLE	(1&lt;&lt;4)
-#define CSW_ADDRINC_PACKED	(2&lt;&lt;4)
-#define CSW_HPROT			(1&lt;&lt;25)
-#define CSW_MASTER_DEBUG	(1&lt;&lt;29)
-#define CSW_DBGSWENABLE		(1&lt;&lt;31)
-
-/* transaction mode */
-#define TRANS_MODE_NONE			0
-/* Transaction waits for previous to complete */
-#define TRANS_MODE_ATOMIC		1
-/* Freerunning transactions with delays and overrun checking */
-#define TRANS_MODE_COMPOSITE	2
-
-typedef struct swjdp_reg_s
-{
-	int addr;
-	arm_jtag_t *jtag_info;
-} swjdp_reg_t;
-
-typedef struct swjdp_common_s
-{
-	arm_jtag_t *jtag_info;
-	/* Control config */
-	u32 dp_ctrl_stat;
-	/* Register select cache */
-	u32 dp_select_value;
-	u32 ap_csw_value;
-	u32 ap_tar_value;
-	/* information about current pending SWjDP-AHBAP transaction */
-	u8  trans_mode;
-	u8  trans_rw;
-	u8  ack;
-} swjdp_common_t;
-
-/* Internal functions used in the module, partial transactions, use with caution */
-extern int swjdp_write_dpacc(swjdp_common_t *swjdp, u32 value, u8 reg_addr);
-/* extern int swjdp_write_apacc(swjdp_common_t *swjdp, u32 value, u8 reg_addr); */
-extern int swjdp_read_dpacc(swjdp_common_t *swjdp, u32 *value, u8 reg_addr);
-/* extern int swjdp_read_apacc(swjdp_common_t *swjdp, u32 *value, u8 reg_addr); */
-extern int ahbap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, u8* out_value_buf);
-extern int ahbap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, u8 *in_value_buf);
-
-/* External interface, partial operations must be completed with swjdp_transaction_endcheck() */
-extern int ahbap_read_system_u32(swjdp_common_t *swjdp, u32 address, u32 *value);
-extern int ahbap_write_system_u32(swjdp_common_t *swjdp, u32 address, u32 value);
-extern int swjdp_transaction_endcheck(swjdp_common_t *swjdp);
-
-/* External interface, complete atomic operations  */
-/* Host endian word transfer of single memory and system registers */
-extern int ahbap_read_system_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 *value);
-extern int ahbap_write_system_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value);
-
-/* Host endian word transfers of processor core registers */
-extern int ahbap_read_coreregister_u32(swjdp_common_t *swjdp, u32 *value, int regnum);
-extern int ahbap_write_coreregister_u32(swjdp_common_t *swjdp, u32 value, int regnum);
-
-extern int ahbap_read_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int ahbap_read_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int ahbap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-
-extern int ahbap_write_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int ahbap_write_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int ahbap_write_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-
-/* Initialisation of the debug system, power domains and registers */
-extern int ahbap_debugport_init(swjdp_common_t *swjdp);
-
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000321.html">[Openocd-svn] r1537 - trunk/src/jtag
</A></li>
	<LI>Next message: <A HREF="000323.html">[Openocd-svn] r1539 - trunk/src/target/target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#322">[ date ]</a>
              <a href="thread.html#322">[ thread ]</a>
              <a href="subject.html#322">[ subject ]</a>
              <a href="author.html#322">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
