<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-170-gbef37ce
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-rc1-170-gbef37ce&In-Reply-To=%3CE1NbxUt-0003sw-K1%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002079.html">
   <LINK REL="Next"  HREF="002082.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-170-gbef37ce</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-rc1-170-gbef37ce&In-Reply-To=%3CE1NbxUt-0003sw-K1%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-170-gbef37ce">gowinex at users.sourceforge.net
       </A><BR>
    <I>Mon Feb  1 15:43:24 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002079.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-169-g91e3268
</A></li>
        <LI>Next message: <A HREF="002082.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-171-g3d2d5dc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2080">[ date ]</a>
              <a href="thread.html#2080">[ thread ]</a>
              <a href="subject.html#2080">[ subject ]</a>
              <a href="author.html#2080">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  bef37ceba2bde6a34d003762bced007bed894bc7 (commit)
      from  91e3268737b578a182cb661d60551657f799ab3c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bef37ceba2bde6a34d003762bced007bed894bc7
Author: Edgar Grimberg &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">edgar.grimberg at zylin.com</A>&gt;
Date:   Fri Jan 29 09:46:11 2010 +0100

    Test cases ran on v0.4.0-rc1
    
    Test cases ran on v0.4.0-rc1 for a number of targets:
    AT91FR40162
    LPC2148
    SAM7
    STR710
    STR912
    
    The goal of the testing session was to prove basic functionality of OpenOCD for different targets.
    
    Signed-off-by: Edgar Grimberg &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">edgar.grimberg at zylin.com</A>&gt;

diff --git a/testing/results/v0.4.0-rc1/AT91FR40162.html b/testing/results/v0.4.0-rc1/AT91FR40162.html
new file mode 100755
index 0000000..0baa31e
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/AT91FR40162.html
@@ -0,0 +1,856 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;title&gt;Test results for revision 1.62&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;H1&gt;SAM7&lt;/H1&gt;
+
+&lt;H2&gt;Connectivity&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON001&quot;/&gt;CON001&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Telnet connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On console, type&lt;br&gt;&lt;code&gt;telnet ip port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON002&quot;/&gt;CON002&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;GDB server connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On GDB console, type&lt;br&gt;&lt;code&gt;target remote ip:port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Remote debugging using 10.0.0.73:3333&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) tar remo 10.0.0.138:3333&lt;br&gt;
+			Remote debugging using 10.0.0.138:3333&lt;br&gt;
+			0x000155b8 in ?? ()&lt;br&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Reset&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES001&quot;/&gt;RES001&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; mdw  0x01000000 32&lt;br&gt;                    
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				&gt; reset halt&lt;br&gt;
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x600000d3 pc: 0x00008a70&lt;br&gt;
+				&gt; &lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES002&quot;/&gt;RES002&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset init on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset init&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain &lt;br&gt;&lt;code&gt;executing reset script 'name_of_the_script'&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset init&lt;br&gt;
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x600000d3 pc: 0x00008ea4&lt;br&gt;
+				&gt; &lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;br&gt;
+		NOTE! Even if there is no message, the reset script is being executed (proved by side effects)&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES003&quot;/&gt;RES003&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset after a power cycle of the target&lt;/td&gt;
+		&lt;td&gt;Reset the target then power cycle the target&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt; after the power was detected&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				Sensed nSRST asserted&lt;br&gt;
+				Sensed power dropout.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0xd5dff7e6&lt;br&gt;
+				Sensed power restore.&lt;br&gt;
+				Sensed nSRST deasserted&lt;br&gt;
+				&gt; reset halt&lt;br&gt;
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0x0000072c&lt;br&gt;
+				&gt;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES004&quot;/&gt;RES004&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target where reset halt is supported&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;br&gt;pc = 0&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&gt; reset halt&lt;br&gt;
+			JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0xf00000d3 pc: 0x00008b38&lt;br&gt;
+			&gt; &lt;br&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES005&quot;/&gt;RES005&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target using return clock&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash, set the configuration script to use RCLK&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				N/A, At91EB40A does &lt;bold&gt;NOT&lt;/bold&gt; have support for RCLK
+			&lt;/code&gt;	
+		&lt;/td&gt;
+		&lt;td&gt;N/A&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;JTAG Speed&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD001&quot;/&gt;SPD001&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset halt&lt;br&gt;
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0x00008ae8&lt;br&gt;
+				&gt; jtag_khz 16000  &lt;br&gt;
+				jtag_speed 4 =&gt; JTAG clk=16.000000&lt;br&gt;
+				16000 kHz&lt;br&gt;
+				&gt; mdw 0 32   &lt;br&gt;   
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD002&quot;/&gt;SPD002&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset halt    &lt;br&gt;
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0x00008c14&lt;br&gt;
+				&gt; jtag_khz 8000 &lt;br&gt;
+				jtag_speed 8 =&gt; JTAG clk=8.000000&lt;br&gt;
+				8000 kHz&lt;br&gt;
+				&gt; mdw 0 32  &lt;br&gt;   
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				&gt; &lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD003&quot;/&gt;SPD003&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;4MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset halt   &lt;br&gt;
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0x00008bc4&lt;br&gt;
+				&gt; jtag_khz 4000&lt;br&gt;
+				jtag_speed 16 =&gt; JTAG clk=4.000000&lt;br&gt;
+				4000 kHz&lt;br&gt;
+				&gt; mdw 0 32  &lt;br&gt;   
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				&gt; &lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD004&quot;/&gt;SPD004&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;2MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset halt&lt;br&gt;
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0x00009678&lt;br&gt;
+				&gt; jtag_khz 2000&lt;br&gt;
+				jtag_speed 32 =&gt; JTAG clk=2.000000&lt;br&gt;
+				2000 kHz&lt;br&gt;
+				&gt; mdw 0 32     &lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				&gt; &lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD005&quot;/&gt;SPD005&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;RCLK on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 0&lt;br&gt;
+				RCLK - adaptive&lt;br&gt;
+				RCLK timeout&lt;br&gt;
+			&lt;/code&gt;
+			N/A for this target
+		&lt;/td&gt;
+		&lt;td&gt;N/A for this target&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Debugging&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG001&quot;/&gt;DBG001&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Load is working&lt;/td&gt;
+		&lt;td&gt;Reset init is working, RAM is accesible, GDB server is started&lt;/td&gt;
+		&lt;td&gt;On the console of the OS: &lt;br&gt;
+			&lt;code&gt;$ arm-none-eabi-gdb redboot_ram.elf&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) target remote ip:port&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) load&lt;/load&gt;
+		&lt;/td&gt;
+		&lt;td&gt;Load should return without error, typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				Loading section .text, size 0x14c lma 0x0&lt;br&gt;
+				Start address 0x40, load size 332&lt;br&gt;
+				Transfer rate: 180 bytes/sec, 332 bytes/write.&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) load&lt;br&gt;
+			Loading section .rom_vectors, size 0x40 lma 0xc000&lt;br&gt;
+			Loading section .text, size 0x103e8 lma 0xc040&lt;br&gt;
+			Loading section .rodata, size 0x1a84 lma 0x1c428&lt;br&gt;
+			Loading section .data, size 0x3ec lma 0x1deac&lt;br&gt;
+			Start address 0xc040, load size 74392&lt;br&gt;
+			Transfer rate: 572 KB/sec, 9299 bytes/write.&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG002&quot;/&gt;DBG002&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software breakpoint&lt;/td&gt;
+		&lt;td&gt;Load the redboot_ram.elf application, use instructions from GDB001&lt;/td&gt;
+		&lt;td&gt;In the GDB console:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor arm7_9 dbgrq enable&lt;br&gt;
+				software breakpoints enabled&lt;br&gt;
+				(gdb) break cyg_start&lt;br&gt;
+				Breakpoint 1 at 0xec: file src/main.c, line 71.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The software breakpoint should be reached, a typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69	  DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) monitor arm7_9 dbgrq enable&lt;br&gt;
+				use of EmbeddedICE dbgrq instead of breakpoint for target halt enabled&lt;br&gt;
+				(gdb) break cyg_start&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1 at 0x155b8: file /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c, line 264.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, cyg_start ()&lt;br&gt;
+				    at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264&lt;br&gt;
+				264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);&lt;br&gt;
+				(gdb) &lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG003&quot;/&gt;DBG003&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in a RAM application&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;(gdb) step&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The next instruction should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				70	  DWORD b = 2;
+
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				266	    CYGACC_CALL_IF_MONITOR_RETURN_SET(return_to_redboot);&lt;br&gt;
+				(gdb)&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG004&quot;/&gt;DBG004&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software break points are working after a reset&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69	  DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) moni reset init&lt;br&gt;
+			JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x600000d3 pc: 0x00008ae8&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			Loading section .rom_vectors, size 0x40 lma 0xc000&lt;br&gt;
+			Loading section .text, size 0x103e8 lma 0xc040&lt;br&gt;
+			Loading section .rodata, size 0x1a84 lma 0x1c428&lt;br&gt;
+			Loading section .data, size 0x3ec lma 0x1deac&lt;br&gt;
+			Start address 0xc040, load size 74392&lt;br&gt;
+			Transfer rate: 576 KB/sec, 9299 bytes/write.&lt;br&gt;
+			(gdb) c&lt;br&gt;
+			Continuing.&lt;br&gt;
+			&lt;br&gt;
+			Breakpoint 1, cyg_start ()&lt;br&gt;
+			    at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264&lt;br&gt;
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);&lt;br&gt;
+			(gdb) &lt;br&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG005&quot;/&gt;DBG005&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint&lt;/td&gt;
+		&lt;td&gt;Flash the redboot_rom.elf application. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset init&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor arm7_9  force_hw_bkpts enable&lt;br&gt;
+				force hardware breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			(gdb) load&lt;br&gt;
+			Loading section .rom_vectors, size 0x40 lma 0x1000000&lt;br&gt;
+			Loading section .text, size 0x10638 lma 0x1000040&lt;br&gt;
+			Loading section .rodata, size 0x1a84 lma 0x1010678&lt;br&gt;
+			Loading section .data, size 0x428 lma 0x10120fc&lt;br&gt;
+			Start address 0x1000040, load size 75044&lt;br&gt;
+			Transfer rate: 33 KB/sec, 9380 bytes/write.&lt;br&gt;
+			(gdb) break cyg_start&lt;br&gt;
+			Breakpoint 1 at 0x100979c: file /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c, line 264.&lt;br&gt;
+			(gdb) c&lt;br&gt;
+			Continuing.&lt;br&gt;
+			Note: automatically using hardware breakpoints for read-only addresses.&lt;br&gt;
+			&lt;br&gt;
+			Breakpoint 1, cyg_start () at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264&lt;br&gt;
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);&lt;br&gt;
+			(gdb) &lt;br&gt;
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG006&quot;/&gt;DBG006&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint is set after a reset&lt;/td&gt;
+		&lt;td&gt;Follow the instructions to flash and insert a hardware breakpoint from DBG005&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) monitor reg pc 0x100000&lt;br&gt;
+				pc (/32): 0x00100000&lt;br&gt;
+				(gdb) continue
+			&lt;/code&gt;&lt;br&gt;
+			where the value inserted in PC is the start address of the application
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			(gdb) moni reset init&lt;br&gt;
+			JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x200000d3 pc: 0x01000200&lt;br&gt;
+			(gdb) moni reg pc 0x1000000&lt;br&gt;
+			pc (/32): 0x01000000&lt;br&gt;
+			(gdb) c&lt;br&gt;
+			Continuing.&lt;br&gt;
+			&lt;br&gt;
+			Breakpoint 1, cyg_start () at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264&lt;br&gt;
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);&lt;br&gt;
+			(gdb) &lt;br&gt;
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG007&quot;/&gt;DBG007&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in ROM&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor arm7_9  force_hw_bkpts enable&lt;br&gt;
+				force hardware breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+				(gdb) step
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x60000013 pc: 0x0010013c&lt;br&gt;
+				70        DWORD b = 2;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			Breakpoint 1, cyg_start () at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264&lt;br&gt;
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);&lt;br&gt;
+			(gdb) step&lt;br&gt;
+			266	    CYGACC_CALL_IF_MONITOR_RETURN_SET(return_to_redboot);&lt;br&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;RAM access&lt;/H2&gt;
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM001&quot;/&gt;RAM001&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;32 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mww ram_address 0xdeadbeef 16&lt;br&gt;
+					&gt; mdw ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mww 0x0 0xdeadbeef 16&lt;br&gt;
+				&gt; mdw 0x0 32&lt;br&gt;
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388&lt;br&gt;
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; mww 0 0xdeadbeef 16&lt;br&gt;
+			&gt; mdw 0x0 32         &lt;br&gt;
+			0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+			0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef &lt;br&gt;
+			0x00000040: 15aadc6d 425b6f33 e789f955 d390dcc2 00080017 010067b4 010067b4 010067b4 &lt;br&gt;
+			0x00000060: 010067b4 00006e74 00006e74 010067b4 010067b4 010067b4 010067b4 010067b4 &lt;br&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM002&quot;/&gt;RAM002&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwh ram_address 0xbeef 16&lt;br&gt;
+					&gt; mdh ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwh 0x0 0xbeef 16&lt;br&gt;
+				&gt; mdh 0x0 32&lt;br&gt;
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt;
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+				&gt; mwh 0 0xbeef 16&lt;br&gt;    
+				&gt; mdh 0x0 32&lt;br&gt;
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt; 
+				0x00000020:   00   00   00   00   00   00   00   00   00   00   00   00   00   00   00   00 &lt;br&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;br&gt;There is a problem with the formatting of the output&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM003&quot;/&gt;RAM003&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwb ram_address 0xab 16&lt;br&gt;
+					&gt; mdb ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwb ram_address 0xab 16&lt;br&gt;
+				&gt; mdb ram_address 32&lt;br&gt;
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; mwb 0x0 0xab 16&lt;br&gt;
+			&gt; mdb 0x0 32     &lt;br&gt;
+			0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;br&gt; 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+
+
+&lt;H2&gt;Flash access&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA001&quot;/&gt;FLA001&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash probe&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface:&lt;br&gt;
+			&lt;code&gt;	&gt; flash probe 0&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The command should execute without error. The output should state the name of the flash and the starting address. An example of output:&lt;br&gt;
+			&lt;code&gt;flash 'ecosflash' found at 0x01000000&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			&gt; flash probe 0
+			flash 'ecosflash' found at 0x01000000
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA002&quot;/&gt;FLA002&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;flash fillw&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; flash fillw 0x100000 0xdeadbeef 16
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. The output looks like:&lt;br&gt;
+			&lt;code&gt;
+				wrote 64 bytes to 0x0100000 in 11.610000s (0.091516 kb/s)
+			&lt;/code&gt;&lt;br&gt;
+			To verify the contents of the flash:&lt;br&gt;
+			&lt;code&gt;
+				&gt; mdw 0x100000 32&lt;br&gt;
+				0x0100000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x0100020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+				&gt; flash fillw 0x01000000 0xdeadbeef 16 &lt;br&gt;  
+				wrote 64 bytes to 0x01000000 in 0.010000s (6.250 kb/s)&lt;br&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef &lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+				&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA003&quot;/&gt;FLA003&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash erase&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt;  flash erase_address 0x100000 0x2000
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error.&lt;br&gt;
+			&lt;code&gt;
+				erased address 0x0100000 length 8192 in 4.970000s
+			&lt;/code&gt;
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			&lt;code&gt;
+				&gt; mdw 0x100000 32&lt;br&gt;
+				0x0100000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; flash erase_address 0x1000000 0x10000&lt;br&gt;
+			erased address 0x01000000 (length 65536) in 0.840000s (76.190 kb/s)&lt;br&gt;
+			&gt; mdw 0x1000000 32                     &lt;br&gt;
+			0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+			0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+			0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+			0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff &lt;br&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA004&quot;/&gt;FLA004&lt;/td&gt;
+		&lt;td&gt;AT91FR40162&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Loading to flash from GDB&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed, connectivity to GDB server is working&lt;/td&gt;
+		&lt;td&gt;Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. &lt;br&gt;
+				&lt;code&gt;
+					(gdb) target remote ip:port&lt;br&gt;
+					(gdb) monitor reset halt&lt;br&gt;
+					(gdb) load&lt;br&gt;
+					Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+					Start address 0x100040, load size 404&lt;br&gt;
+					Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+					(gdb) monitor verify_image path_to_elf_file		
+				&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The output should look like:&lt;br&gt;
+			&lt;code&gt;
+				verified 404 bytes in 5.060000s
+			&lt;/code&gt;&lt;br&gt;
+			The failure message is something like:&lt;br&gt;
+			&lt;code&gt;Verify operation failed address 0x00200000. Was 0x00 instead of 0x18&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .rom_vectors, size 0x40 lma 0x1000000&lt;br&gt;
+				Loading section .text, size 0x10638 lma 0x1000040&lt;br&gt;
+				Loading section .rodata, size 0x1a84 lma 0x1010678&lt;br&gt;
+				Loading section .data, size 0x428 lma 0x10120fc&lt;br&gt;
+				Start address 0x1000040, load size 75044&lt;br&gt;
+				Transfer rate: 34 KB/sec, 9380 bytes/write.&lt;br&gt;
+				(gdb) moni verify_image /tftp/10.0.0.190/redboot_rom.elf&lt;br&gt;
+				keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not sent! (1820). Workaround: increase &quot;set remotetimeout&quot; in GDB&lt;br&gt;
+				verified 75044 bytes in 1.960000s (37.390 kb/s)&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;	
+&lt;/table&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/LPC2148.html b/testing/results/v0.4.0-rc1/LPC2148.html
new file mode 100755
index 0000000..425b524
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/LPC2148.html
@@ -0,0 +1,933 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;title&gt;Test results for revision 1.62&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;H1&gt;LPC2148&lt;/H1&gt;
+
+&lt;H2&gt;Connectivity&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON001&quot;/&gt;CON001&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Telnet connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On console, type&lt;br&gt;&lt;code&gt;telnet ip port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON002&quot;/&gt;CON002&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;GDB server connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On GDB console, type&lt;br&gt;&lt;code&gt;target remote ip:port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Remote debugging using 10.0.0.73:3333&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) tar remo 10.0.0.73:3333&lt;br&gt;
+			Remote debugging using 10.0.0.73:3333&lt;br&gt;
+			0x00000000 in ?? ()&lt;br&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Reset&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES001&quot;/&gt;RES001&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				&gt; reset halt&lt;br&gt;
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xa00000f3 pc: 0x7fffd2d6&lt;br&gt;
+				&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES002&quot;/&gt;RES002&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset init on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset init&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain &lt;br&gt;&lt;code&gt;executing reset script 'name_of_the_script'&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset init&lt;br&gt;
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xa00000f3 pc: 0x7fffd2da&lt;br&gt;
+				core state: ARM&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;br&gt;
+		NOTE! Even if there is no message, the reset script is being executed (proved by side effects)&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES003&quot;/&gt;RES003&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset after a power cycle of the target&lt;/td&gt;
+		&lt;td&gt;Reset the target then power cycle the target&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt; after the power was detected&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				nsed nSRST asserted.&lt;br&gt;
+				nsed power dropout.&lt;br&gt;
+				nsed power restore.&lt;br&gt;
+				SRST took 186ms to deassert&lt;br&gt;
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xa00000f3 pc: 0x7fffd2d6&lt;br&gt;
+				core state: ARM&lt;br&gt;
+				&gt; reset halt&lt;br&gt;
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xa00000f3 pc: 0x7fffd2d6&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES004&quot;/&gt;RES004&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target where reset halt is supported&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;br&gt;pc = 0&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+			&gt; reset halt&lt;br&gt;
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0xa00000f3 pc: 0x7fffd2d6&lt;br&gt;
+			&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES005&quot;/&gt;RES005&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target using return clock&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash, set the configuration script to use RCLK&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+			&gt; jtag_khz 0&lt;br&gt;
+			RCLK - adaptive&lt;br&gt;
+			&gt; reset init&lt;br&gt;
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0xa00000f3 pc: 0x7fffd2d6&lt;br&gt;
+			core state: ARM&lt;br&gt;
+			&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;JTAG Speed&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD001&quot;/&gt;SPD001&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 16000&lt;br&gt;
+				jtag_speed 4 =&gt; JTAG clk=16.000000&lt;br&gt;
+				16000 kHz&lt;br&gt;
+				&gt; reset halt&lt;br&gt;    
+				JTAG scan chain interrogation failed: all zeroes&lt;br&gt;
+				Check JTAG interface, timings, target power, etc.&lt;br&gt;
+				error: -100&lt;br&gt;
+				Command handler execution failed&lt;br&gt;
+				in procedure 'reset' called at file &quot;command.c&quot;, line 638&lt;br&gt;
+				called at file &quot;/home/laurentiu/workspace/zy1000/build/../openocd/src/helper/command.c&quot;, line 352&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				ThumbEE -- incomplete support&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ThumbEE state due to debug-request, current mode: System&lt;br&gt;
+				cpsr: 0x1fffffff pc: 0xfffffffa&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in Thumb state due to debug-request, current mode: System&lt;br&gt;
+				cpsr: 0xc00003ff pc: 0xfffffff0&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				ThumbEE -- incomplete support&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ThumbEE state due to debug-request, current mode: System&lt;br&gt;
+				cpsr: 0xffffffff pc: 0xfffffffa&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;&lt;b&gt;FAIL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD002&quot;/&gt;SPD002&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 8000&lt;br&gt; 
+				jtag_speed 8 =&gt; JTAG clk=8.000000&lt;br&gt;
+				8000 kHz&lt;br&gt;
+				&gt; reset halt&lt;br&gt;   
+				JTAG scan chain interrogation failed: all zeroes&lt;br&gt;
+				Check JTAG interface, timings, target power, etc.&lt;br&gt;
+				error: -100&lt;br&gt;
+				Command handler execution failed&lt;br&gt;
+				in procedure 'reset' called at file &quot;command.c&quot;, line 638&lt;br&gt;
+				called at file &quot;/home/laurentiu/workspace/zy1000/build/../openocd/src/helper/command.c&quot;, line 352&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				invalid mode value encountered 0&lt;br&gt;
+				cpsr contains invalid mode value - communication failure&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;&lt;b&gt;FAIL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD003&quot;/&gt;SPD003&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;4MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 4000&lt;br&gt;
+				jtag_speed 16 =&gt; JTAG clk=4.000000&lt;br&gt;
+				4000 kHz&lt;br&gt;
+				&gt; reset halt&lt;br&gt;   
+				JTAG tap: lpc2148.cpu tap/device found: 0xc79f0f87 (mfg: 0x7c3, part: 0x79f0, ver: 0xc)&lt;br&gt;
+				JTAG tap: lpc2148.cpu       UNEXPECTED: 0xc79f0f87 (mfg: 0x7c3, part: 0x79f0, ver: 0xc)&lt;br&gt;
+				JTAG tap: lpc2148.cpu  expected 1 of 1: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+				Unexpected idcode after end of chain: 64 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 160 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 192 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 320 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 352 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 384 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 480 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 512 0x0000007f&lt;br&gt;
+				Unexpected idcode after end of chain: 544 0x0000007f&lt;br&gt;
+				double-check your JTAG setup (interface, speed, missing TAPs, ...)&lt;br&gt;
+				error: -100&lt;br&gt;
+				Command handler execution failed&lt;br&gt;
+				in procedure 'reset' called at file &quot;command.c&quot;, line 638&lt;br&gt;
+				called at file &quot;/home/laurentiu/workspace/zy1000/build/../openocd/src/helper/command.c&quot;, line 352&lt;br&gt;
+				&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;&lt;b&gt;FAIL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD004&quot;/&gt;SPD004&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;2MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 2000&lt;br&gt;
+				jtag_speed 32 =&gt; JTAG clk=2.000000&lt;br&gt;
+				2000 kHz&lt;br&gt;
+				&gt; reset halt&lt;br&gt;
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xa00000f3 pc: 0x7fffd2da&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: e59f4034 e3a05002 e5845000 e3a05003 e5845004 e59f201c e3a03000 e1020093&lt;br&gt; 
+				0x00000020: e2822028 e1021093 e3c03007 e5023028 e51ff004 7fffd1c4 e002c014 e01fc000&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD005&quot;/&gt;SPD005&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;RCLK on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 0&lt;br&gt;
+				RCLK - adaptive&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: e59f4034 e3a05002 e5845000 e3a05003 e5845004 e59f201c e3a03000 e1020093&lt;br&gt; 
+				0x00000020: e2822028 e1021093 e3c03007 e5023028 e51ff004 7fffd1c4 e002c014 e01fc000&lt;br&gt; 
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Debugging&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG001&quot;/&gt;DBG001&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Load is working&lt;/td&gt;
+		&lt;td&gt;Reset init is working, RAM is accesible, GDB server is started&lt;/td&gt;
+		&lt;td&gt;On the console of the OS: &lt;br&gt;
+			&lt;code&gt;arm-elf-gdb test_ram.elf&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) target remote ip:port&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) load&lt;/load&gt;
+		&lt;/td&gt;
+		&lt;td&gt;Load should return without error, typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				Loading section .text, size 0x14c lma 0x0&lt;br&gt;
+				Start address 0x40, load size 332&lt;br&gt;
+				Transfer rate: 180 bytes/sec, 332 bytes/write.&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) load&lt;br&gt;
+			Loading section .text, size 0x16c lma 0x40000000&lt;br&gt;
+			Start address 0x40000040, load size 364&lt;br&gt;
+			Transfer rate: 32 KB/sec, 364 bytes/write.&lt;br&gt;
+			(gdb) 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG002&quot;/&gt;DBG002&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software breakpoint&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001&lt;/td&gt;
+		&lt;td&gt;In the GDB console:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor gdb_breakpoint_override soft&lt;br&gt;
+				software breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0xec: file src/main.c, line 71.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The software breakpoint should be reached, a typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x000000d3 pc: 0x000000ec&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71        DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) monitor gdb_breakpoint_override soft&lt;br&gt;
+				force soft breakpoints&lt;br&gt;
+				Current language:  auto&lt;br&gt;
+				The current source language is &quot;auto; currently asm&quot;.&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x4000010c: file src/main.c, line 71.&lt;br&gt;
+				(gdb) c&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71	  DWORD a = 1;&lt;br&gt;
+				Current language:  auto&lt;br&gt;
+				The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+				(gdb) 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG003&quot;/&gt;DBG003&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in a RAM application&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;(gdb) step&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The next instruction should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Abort&lt;br&gt;
+				cpsr: 0x20000097 pc: 0x000000f0&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Abort&lt;br&gt;
+				cpsr: 0x20000097 pc: 0x000000f4&lt;br&gt;
+				72        DWORD b = 2;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				72	  DWORD b = 2;&lt;br&gt;
+				(gdb) 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG004&quot;/&gt;DBG004&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software break points are working after a reset&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x000000d3 pc: 0x000000ec&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71        DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) moni reset init&lt;br&gt;
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in Thumb state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0xa00000f3 pc: 0x7fffd2d6&lt;br&gt;
+			core state: ARM&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			Loading section .text, size 0x16c lma 0x40000000&lt;br&gt;
+			Start address 0x40000040, load size 364&lt;br&gt;
+			Transfer rate: 27 KB/sec, 364 bytes/write.&lt;br&gt;
+			(gdb) c&lt;br&gt;
+			Continuing.&lt;br&gt;
+			&lt;br&gt;
+			Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+			71	  DWORD a = 1;&lt;br&gt;
+			(gdb) 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG005&quot;/&gt;DBG005&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset init&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor gdb_breakpoint_override hard&lt;br&gt;
+				force hard breakpoints&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			(gdb) monitor gdb_breakpoint_override hard&lt;br&gt;
+			force hard breakpoints&lt;br&gt;
+			(gdb) break main&lt;br&gt;
+			Breakpoint 1 at 0x10c: file src/main.c, line 71.&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			Continuing.&lt;br&gt;
+			Note: automatically using hardware breakpoints for read-only addresses.&lt;br&gt;
+			&lt;br&gt;
+			Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+			71	  DWORD a = 1;&lt;br&gt;
+			Current language:  auto&lt;br&gt;
+			The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+			(gdb) 
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS &lt;font color=red&gt;NOTE: This test is failing from time to time, not able to describe a cause&lt;/font&gt;&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG006&quot;/&gt;DBG006&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint is set after a reset&lt;/td&gt;
+		&lt;td&gt;Follow the instructions to flash and insert a hardware breakpoint from DBG005&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) monitor reg pc 0x100000&lt;br&gt;
+				pc (/32): 0x00100000&lt;br&gt;
+				(gdb) continue
+			&lt;/code&gt;&lt;br&gt;
+			where the value inserted in PC is the start address of the application
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x60000013 pc: 0x00000160&lt;br&gt;
+			core state: ARM&lt;br&gt;
+			(gdb) monitor reg pc 0x40&lt;br&gt;
+			pc (/32): 0x00000040&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			Continuing.&lt;br&gt;
+			&lt;br&gt;
+			Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+			71	  DWORD a = 1;&lt;br&gt;
+			(gdb) 
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG007&quot;/&gt;DBG007&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in ROM&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor gdb_breakpoint_override hard&lt;br&gt;
+				force hard breakpoints&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+				(gdb) step
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x60000013 pc: 0x0010013c&lt;br&gt;
+				70        DWORD b = 2;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x16c lma 0x0&lt;br&gt;
+				Start address 0x40, load size 364&lt;br&gt;
+				Transfer rate: 637 bytes/sec, 364 bytes/write.&lt;br&gt;
+				(gdb)  monitor gdb_breakpoint_override hard&lt;br&gt;
+				force hard breakpoints&lt;br&gt;
+				Current language:  auto&lt;br&gt;
+				The current source language is &quot;auto; currently asm&quot;.&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x10c: file src/main.c, line 71.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.&lt;br&gt;
+				Note: automatically using hardware breakpoints for read-only addresses.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71	  DWORD a = 1;&lt;br&gt;
+				Current language:  auto&lt;br&gt;
+				The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+				(gdb) step&lt;br&gt;
+				72	  DWORD b = 2;&lt;br&gt;
+				(gdb)
+			
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;RAM access&lt;/H2&gt;
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM001&quot;/&gt;RAM001&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;32 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mww ram_address 0xdeadbeef 16&lt;br&gt;
+					&gt; mdw ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mww 0x0 0xdeadbeef 16&lt;br&gt;
+				&gt; mdw 0x0 32&lt;br&gt;
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388&lt;br&gt;
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; mww 0x40000000 0xdeadbeef 16&lt;br&gt;
+			&gt; mdw 0x40000000 32&lt;br&gt;
+			0x40000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+			0x40000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+			0x40000040: e1a00000 e1a00000 e1a00000 e1a00000 e1a00000 e1a00000 e1a00000 e1a00000&lt;br&gt; 
+			0x40000060: e321f0db e59fd07c e321f0d7 e59fd078 e321f0d1 e59fd074 e321f0d2 e59fd070&lt;br&gt; 
+			&gt; 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM002&quot;/&gt;RAM002&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwh ram_address 0xbeef 16&lt;br&gt;
+					&gt; mdh ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwh 0x0 0xbeef 16&lt;br&gt;
+				&gt; mdh 0x0 32&lt;br&gt;
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt;
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; mwh 0x40000000 0xbeef 16&lt;br&gt;
+			&gt; mdh 0x40000000 32&lt;br&gt;       
+			0x40000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt; 
+			0x40000020: beef dead beef dead beef dead beef dead beef dead beef dead beef dead beef dead&lt;br&gt; 
+			&gt; 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM003&quot;/&gt;RAM003&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwb ram_address 0xab 16&lt;br&gt;
+					&gt; mdb ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwb ram_address 0xab 16&lt;br&gt;
+				&gt; mdb ram_address 32&lt;br&gt;
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; mwb 0x40000000 0xab 16
+			&gt; mdb 0x40000000 32     
+			0x40000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ef be ef be ef be ef be ef be ef be ef be ef be 
+			&gt;
+
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+
+
+&lt;H2&gt;Flash access&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA001&quot;/&gt;FLA001&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash probe&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface:&lt;br&gt;
+			&lt;code&gt;	&gt; flash probe 0&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The command should execute without error. The output should state the name of the flash and the starting address. An example of output:&lt;br&gt;
+			&lt;code&gt;flash 'ecosflash' found at 0x01000000&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			&gt; flash probe 0&lt;br&gt;
+			flash 'lpc2000' found at 0x00000000
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA002&quot;/&gt;FLA002&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;flash fillw&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; flash fillw 0x1000000 0xdeadbeef 16
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. The output looks like:&lt;br&gt;
+			&lt;code&gt;
+				wrote 64 bytes to 0x01000000 in 11.610000s (0.091516 kb/s)
+			&lt;/code&gt;&lt;br&gt;
+			To verify the contents of the flash:&lt;br&gt;
+			&lt;code&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+				&gt; flash fillw 0x0 0xdeadbeef 16&lt;br&gt;
+				Verification will fail since checksum in image (0xdeadbeef) to be written to flash is different from calculated vector checksum (0xe93fc777).&lt;br&gt;
+				To remove this warning modify build tools on developer PC to inject correct LPC vector checksum.&lt;br&gt;
+				wrote 64 bytes to 0x00000000 in 0.040000s (1.563 kb/s)&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef e93fc777 deadbeef deadbeef&lt;br&gt; 
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				&gt; 
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;FAIL&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA003&quot;/&gt;FLA003&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash erase&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt;  flash erase_address 0x1000000 0x2000
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error.&lt;br&gt;
+			&lt;code&gt;
+				erased address 0x01000000 length 8192 in 4.970000s
+			&lt;/code&gt;
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			&lt;code&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; flash erase_address 0 0x2000&lt;br&gt;
+			erased address 0x00000000 (length 8192) in 0.510000s (15.686 kb/s)&lt;br&gt;
+			&gt; mdw 0 32&lt;br&gt;
+			0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+			0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+			0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+			0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+			&gt; 
+		&lt;/code&gt;&lt;/td&gt;				
+		&lt;td&gt;PASS&lt;/td&gt;
+
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA004&quot;/&gt;FLA004&lt;/td&gt;
+		&lt;td&gt;LPC2148&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Loading to flash from GDB&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed, connectivity to GDB server is working&lt;/td&gt;
+		&lt;td&gt;Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. &lt;br&gt;
+				&lt;code&gt;
+					(gdb) target remote ip:port&lt;br&gt;
+					(gdb) monitor reset&lt;br&gt;
+					(gdb) load&lt;br&gt;
+					Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+					Start address 0x100040, load size 404&lt;br&gt;
+					Transfer rate: 179 bytes/sec, 404 bytes/write.
+					(gdb) monitor verify_image path_to_elf_file		
+				&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The output should look like:&lt;br&gt;
+			&lt;code&gt;
+				verified 404 bytes in 5.060000s
+			&lt;/code&gt;&lt;br&gt;
+			The failure message is something like:&lt;br&gt;
+			&lt;code&gt;Verify operation failed address 0x00200000. Was 0x00 instead of 0x18&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) moni verify_image /tftp/10.0.0.194/test_rom.elf&lt;br&gt;
+				checksum mismatch - attempting binary compare&lt;br&gt;
+				Verify operation failed address 0x00000014. Was 0x58 instead of 0x60&lt;br&gt;
+				&lt;br&gt;
+				Command handler execution failed&lt;br&gt;
+				in procedure 'verify_image' called at file &quot;command.c&quot;, line 647&lt;br&gt;
+				called at file &quot;command.c&quot;, line 361&lt;br&gt;
+				(gdb) 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;FAIL&lt;/font&gt;&lt;/td&gt;
+	&lt;/tr&gt;	
+&lt;/table&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/SAM7.html b/testing/results/v0.4.0-rc1/SAM7.html
new file mode 100755
index 0000000..a400a47
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/SAM7.html
@@ -0,0 +1,853 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;title&gt;Test results for revision 1.62&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;H1&gt;SAM7&lt;/H1&gt;
+
+&lt;H2&gt;Connectivity&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON001&quot;/&gt;CON001&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Telnet connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On console, type&lt;br&gt;&lt;code&gt;telnet ip port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON002&quot;/&gt;CON002&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;GDB server connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On GDB console, type&lt;br&gt;&lt;code&gt;target remote ip:port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Remote debugging using 10.0.0.73:3333&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) tar remo 10.0.0.73:3333&lt;br&gt;
+			Remote debugging using 10.0.0.73:3333&lt;br&gt;
+			0x00100174 in ?? ()&lt;br&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Reset&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES001&quot;/&gt;RES001&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				&gt; reset halt&lt;br&gt;
+				SRST took 2ms to deassert&lt;br&gt;
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x600000d3 pc: 0x000003c4&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES002&quot;/&gt;RES002&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset init on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset init&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain &lt;br&gt;&lt;code&gt;executing reset script 'name_of_the_script'&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset init&lt;br&gt;
+				SRST took 2ms to deassert&lt;br&gt;
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x600000d3 pc: 0x000003c0&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;br&gt;
+		NOTE! Even if there is no message, the reset script is being executed (proved by side effects)&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES003&quot;/&gt;RES003&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset after a power cycle of the target&lt;/td&gt;
+		&lt;td&gt;Reset the target then power cycle the target&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt; after the power was detected&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				Sensed nSRST asserted&lt;br&gt;
+				Sensed power dropout.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0xd5dff7e6&lt;br&gt;
+				Sensed power restore.&lt;br&gt;
+				Sensed nSRST deasserted&lt;br&gt;
+				&gt; reset halt&lt;br&gt;
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0xf00000d3 pc: 0x0000072c&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES004&quot;/&gt;RES004&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target where reset halt is supported&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;br&gt;pc = 0&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; reset halt&lt;br&gt;
+				SRST took 2ms to deassert&lt;br&gt;
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x300000d3 pc: 0x000003c0
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES005&quot;/&gt;RES005&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target using return clock&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash, set the configuration script to use RCLK&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 0&lt;br&gt;
+				jtag_khz: 0&lt;br&gt;
+				&gt; reset init&lt;br&gt;
+				SRST took 2ms to deassert&lt;br&gt;
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)&lt;br&gt;
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x300000d3 pc: 0x000003c0&lt;br&gt;
+				executing event/sam7s256_reset.script&lt;br&gt;
+				&gt;
+			&lt;/code&gt;	
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;JTAG Speed&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD001&quot;/&gt;SPD001&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 16000&lt;br&gt;
+				jtag_speed 4 =&gt; JTAG clk=16.000000&lt;br&gt;
+				jtag_khz: 16000&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD002&quot;/&gt;SPD002&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 8000&lt;br&gt;
+				jtag_speed 8 =&gt; JTAG clk=8.000000&lt;br&gt;
+				jtag_khz: 8000&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD003&quot;/&gt;SPD003&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;4MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 4000&lt;br&gt;
+				jtag_speed 16 =&gt; JTAG clk=4.000000&lt;br&gt;
+				jtag_khz: 4000&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD004&quot;/&gt;SPD004&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;2MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 2000&lt;br&gt;
+				jtag_speed 32 =&gt; JTAG clk=2.000000&lt;br&gt;
+				jtag_khz: 2000&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD005&quot;/&gt;SPD005&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;RCLK on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				&gt; jtag_khz 0&lt;br&gt;
+				jtag_khz: 0&lt;br&gt;
+				&gt; mdw 0 32&lt;br&gt;
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Debugging&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG001&quot;/&gt;DBG001&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Load is working&lt;/td&gt;
+		&lt;td&gt;Reset init is working, RAM is accesible, GDB server is started&lt;/td&gt;
+		&lt;td&gt;On the console of the OS: &lt;br&gt;
+			&lt;code&gt;arm-elf-gdb test_ram.elf&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) target remote ip:port&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) load&lt;/load&gt;
+		&lt;/td&gt;
+		&lt;td&gt;Load should return without error, typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				Loading section .text, size 0x14c lma 0x0&lt;br&gt;
+				Start address 0x40, load size 332&lt;br&gt;
+				Transfer rate: 180 bytes/sec, 332 bytes/write.&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) load&lt;br&gt;
+			Loading section .text, size 0x194 lma 0x200000&lt;br&gt;
+			Start address 0x200040, load size 404&lt;br&gt;
+			Transfer rate: 443 bytes/sec, 404 bytes/write.&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG002&quot;/&gt;DBG002&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software breakpoint&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001&lt;/td&gt;
+		&lt;td&gt;In the GDB console:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor arm7_9 dbgrq enable&lt;br&gt;
+				software breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0xec: file src/main.c, line 71.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The software breakpoint should be reached, a typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69	  DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) monitor arm7_9 dbgrq enable&lt;br&gt;
+				use of EmbeddedICE dbgrq instead of breakpoint for target halt enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x200134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) c&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69	  DWORD a = 1;&lt;br&gt;
+				Current language:  auto&lt;br&gt;
+				The current source language is &quot;auto; currently c&quot;.&lt;br&gt;				
+				(gdb)
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG003&quot;/&gt;DBG003&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in a RAM application&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;(gdb) step&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The next instruction should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				70	  DWORD b = 2;
+
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				70	  DWORD b = 2;
+				(gdb)
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG004&quot;/&gt;DBG004&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software break points are working after a reset&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69	  DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			JTAG tap: sam7x256.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x600000d3 pc: 0x0000031c&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			Loading section .text, size 0x194 lma 0x200000&lt;br&gt;
+			Start address 0x200040, load size 404&lt;br&gt;
+			Transfer rate: 26 KB/sec, 404 bytes/write.&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			Continuing.&lt;br&gt;
+			&lt;br&gt;
+			Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+			69	  DWORD a = 1;&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG005&quot;/&gt;DBG005&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset init&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor arm7_9  force_hw_bkpts enable&lt;br&gt;
+				force hardware breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			(gdb) monitor arm7_9  force_hw_bkpts enable&lt;br&gt;
+			force hardware breakpoints enabled&lt;br&gt;
+			(gdb) break main&lt;br&gt;
+			Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			Continuing.&lt;br&gt;
+			Note: automatically using hardware breakpoints for read-only addresses.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x60000013 pc: 0x00100134&lt;br&gt;
+&lt;br&gt;
+			Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+			69        DWORD a = 1;&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG006&quot;/&gt;DBG006&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint is set after a reset&lt;/td&gt;
+		&lt;td&gt;Follow the instructions to flash and insert a hardware breakpoint from DBG005&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) monitor reg pc 0x100000&lt;br&gt;
+				pc (/32): 0x00100000&lt;br&gt;
+				(gdb) continue
+			&lt;/code&gt;&lt;br&gt;
+			where the value inserted in PC is the start address of the application
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			SRST took 3ms to deassert&lt;br&gt;
+			JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)&lt;br&gt;
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to debug request, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x60000013 pc: 0x00100168&lt;br&gt;
+			executing event/sam7s256_reset.script&lt;br&gt;
+			(gdb) monitor reg pc 0x100000&lt;br&gt;
+			pc (/32): 0x00100000&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			Continuing.&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x60000013 pc: 0x00100040&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x60000013 pc: 0x00100134&lt;br&gt;
+&lt;br&gt;
+			Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+			69        DWORD a = 1;&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG007&quot;/&gt;DBG007&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in ROM&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor arm7_9  force_hw_bkpts enable&lt;br&gt;
+				force hardware breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+				(gdb) step
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x60000013 pc: 0x0010013c&lt;br&gt;
+				70        DWORD b = 2;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+			69        DWORD a = 1;&lt;br&gt;
+			(gdb) step&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x60000013 pc: 0x00100138&lt;br&gt;
+			target state: halted&lt;br&gt;
+			target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+			cpsr: 0x60000013 pc: 0x0010013c&lt;br&gt;
+			70        DWORD b = 2;&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;RAM access&lt;/H2&gt;
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM001&quot;/&gt;RAM001&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;32 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mww ram_address 0xdeadbeef 16&lt;br&gt;
+					&gt; mdw ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mww 0x0 0xdeadbeef 16&lt;br&gt;
+				&gt; mdw 0x0 32&lt;br&gt;
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388&lt;br&gt;
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; mww 0x00200000 0xdeadbeef 16&lt;br&gt;
+			&gt; mdw 0x00200000 32&lt;br&gt;
+			0x00200000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+			0x00200020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+			0x00200040: e59f10b4 e3a00902 e5810004 e59f00ac e59f10ac e5810000 e3e010ff e59f00a4&lt;br&gt;
+			0x00200060: e5810060 e59f10a0 e3e00000 e5810130 e5810124 e321f0db e59fd090 e321f0d7
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM002&quot;/&gt;RAM002&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwh ram_address 0xbeef 16&lt;br&gt;
+					&gt; mdh ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwh 0x0 0xbeef 16&lt;br&gt;
+				&gt; mdh 0x0 32&lt;br&gt;
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt;
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; mwh 0x00200000 0xbeef 16&lt;br&gt;
+			&gt; mdh 0x00200000 32&lt;br&gt;
+			0x00200000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt;
+			0x00200020: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM003&quot;/&gt;RAM003&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwb ram_address 0xab 16&lt;br&gt;
+					&gt; mdb ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwb ram_address 0xab 16&lt;br&gt;
+				&gt; mdb ram_address 32&lt;br&gt;
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt;  mwb 0x00200000 0xab 16&lt;br&gt;
+			&gt; mdb 0x00200000 32&lt;br&gt;
+			0x00200000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+
+
+&lt;H2&gt;Flash access&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA001&quot;/&gt;FLA001&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash probe&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface:&lt;br&gt;
+			&lt;code&gt;	&gt; flash probe 0&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The command should execute without error. The output should state the name of the flash and the starting address. An example of output:&lt;br&gt;
+			&lt;code&gt;flash 'ecosflash' found at 0x01000000&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			&gt; flash probe 0&lt;br&gt;
+			flash 'at91sam7' found at 0x00100000
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA002&quot;/&gt;FLA002&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;flash fillw&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; flash fillw 0x100000 0xdeadbeef 16
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. The output looks like:&lt;br&gt;
+			&lt;code&gt;
+				wrote 64 bytes to 0x0100000 in 11.610000s (0.091516 kb/s)
+			&lt;/code&gt;&lt;br&gt;
+			To verify the contents of the flash:&lt;br&gt;
+			&lt;code&gt;
+				&gt; mdw 0x100000 32&lt;br&gt;
+				0x0100000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x0100020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+				&gt; flash fillw 0x100000 0xdeadbeef 16&lt;br&gt;
+				wrote 64 bytes to 0x00100000 in 0.040000s (26.562500 kb/s)&lt;br&gt;
+				&gt; mdw 0x100000 32&lt;br&gt;
+				0x00100000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00100020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x00100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA003&quot;/&gt;FLA003&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash erase&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt;  flash erase_address 0x100000 0x2000
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error.&lt;br&gt;
+			&lt;code&gt;
+				erased address 0x0100000 length 8192 in 4.970000s
+			&lt;/code&gt;
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			&lt;code&gt;
+				&gt; mdw 0x100000 32&lt;br&gt;
+				0x0100000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			&gt; flash erase_address 0x100000 0x2000&lt;br&gt;
+			erased address 0x00100000 length 8192 in 0.020000s&lt;br&gt;
+			&gt; mdw 0x100000 32&lt;br&gt;
+			0x00100000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+			0x00100020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+			0x00100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+			0x00100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+			&gt;
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA004&quot;/&gt;FLA004&lt;/td&gt;
+		&lt;td&gt;SAM7S64&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Loading to flash from GDB&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed, connectivity to GDB server is working&lt;/td&gt;
+		&lt;td&gt;Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. &lt;br&gt;
+				&lt;code&gt;
+					(gdb) target remote ip:port&lt;br&gt;
+					(gdb) monitor reset halt&lt;br&gt;
+					(gdb) load&lt;br&gt;
+					Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+					Start address 0x100040, load size 404&lt;br&gt;
+					Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+					(gdb) monitor verify_image path_to_elf_file		
+				&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The output should look like:&lt;br&gt;
+			&lt;code&gt;
+				verified 404 bytes in 5.060000s
+			&lt;/code&gt;&lt;br&gt;
+			The failure message is something like:&lt;br&gt;
+			&lt;code&gt;Verify operation failed address 0x00200000. Was 0x00 instead of 0x18&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 4 KB/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) moni verify_image /tftp/10.0.0.9/c:/temp/testing/examples/SAM7S256Test/test_rom.elf&lt;br&gt;
+				verified 404 bytes in 0.570000s
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;	
+&lt;/table&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/STR710.html b/testing/results/v0.4.0-rc1/STR710.html
new file mode 100755
index 0000000..1a18ad0
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/STR710.html
@@ -0,0 +1,907 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;title&gt;Test results for version 1.62&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;H1&gt;STR710&lt;/H1&gt;
+
+&lt;H2&gt;Connectivity&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON001&quot;/&gt;CON001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Telnet connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On console, type&lt;br&gt;&lt;code&gt;telnet ip port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;&gt; telnet 10.0.0.142&lt;br&gt;
+					Trying 10.0.0.142...&lt;br&gt;
+					Connected to 10.0.0.142.&lt;br&gt;
+					Escape character is '^]'.&lt;br&gt;
+					Open On-Chip Debugger&lt;br&gt;
+					&gt;
+&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON002&quot;/&gt;CON002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;GDB server connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On GDB console, type&lt;br&gt;&lt;code&gt;target remote ip:port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Remote debugging using 10.0.0.73:3333&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) tar remo 10.0.0.142:3333&lt;br&gt;
+			Remote debugging using 10.0.0.142:3333&lt;br&gt;
+			0x00016434 in ?? ()&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Reset&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES001&quot;/&gt;RES001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; mdw 0 32&lt;br&gt;
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e&lt;br&gt; 
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292&lt;br&gt; 
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18&lt;br&gt;
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8&lt;br&gt;
+&gt; reset&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+&gt;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES002&quot;/&gt;RES002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset init on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset init&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain &lt;br&gt;&lt;code&gt;executing reset script 'name_of_the_script'&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; reset init&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Undefined instruction&lt;br&gt;
+cpsr: 0xf00000db pc: 0x00000004&lt;br&gt;
+jtag_speed 10 =&gt; JTAG clk=6.400000&lt;br&gt;
+6400 kHz
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES003&quot;/&gt;RES003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset after a power cycle of the target&lt;/td&gt;
+		&lt;td&gt;Reset the target then power cycle the target&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt; after the power was detected&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+  nsed power dropout.&lt;br&gt;
+  nsed power dropout.&lt;br&gt;
+  nsed nSRST deasserted.&lt;br&gt;
+  invalid mode value encountered 0&lt;br&gt;
+cpsr contains invalid mode value - communication failure&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x100000d3 pc: 0x0000001c&lt;br&gt;
+jtag_speed 10 =&gt; JTAG clk=6.400000&lt;br&gt;
+6400 kHz&lt;br&gt;
+  nsed power restore.&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x500000d3 pc: 0x00000000&lt;br&gt;
+jtag_speed 10 =&gt; JTAG clk=6.400000&lt;br&gt;
+6400 kHz&lt;br&gt;
+&gt; reset init&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x500000d3 pc: 0x00000000&lt;br&gt;
+jtag_speed 10 =&gt; JTAG clk=6.400000&lt;br&gt;
+6400 kHz&lt;br&gt;
+&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES004&quot;/&gt;RES004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target where reset halt is supported&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; reset halt&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x200000d3 pc: 0xfe50cba4&lt;br&gt;
+&gt;
+&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES005&quot;/&gt;RES005&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target using return clock&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash, set the configuration script to use RCLK&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+			&gt; jtag_khz 0&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+RCLK timeout&lt;br&gt;
+RCLK timeout&lt;br&gt;
+RCLK timeout&lt;br&gt;
+			&gt; reset halt&lt;br&gt;
+ RCLK timeout&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x200000d3 pc: 0xfe50cb50&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;&lt;b&gt;FAIL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;JTAG Speed&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD001&quot;/&gt;SPD001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 16000&lt;br&gt;
+jtag_speed 4 =&gt; JTAG clk=16.000000&lt;br&gt;
+16000 kHz&lt;br&gt;
+&gt; mdw 0 32&lt;br&gt;
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e&lt;br&gt; 
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292&lt;br&gt; 
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18&lt;br&gt; 
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8&lt;br&gt; 
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD002&quot;/&gt;SPD002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 8000&lt;br&gt;  
+jtag_speed 8 =&gt; JTAG clk=8.000000&lt;br&gt; 
+8000 kHz&lt;br&gt; 
+&gt; mdw 0 32&lt;br&gt;      
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e&lt;br&gt;  
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292&lt;br&gt;  
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18&lt;br&gt;  
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8&lt;br&gt;  
+&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD003&quot;/&gt;SPD003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;4MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 4000&lt;br&gt; 
+jtag_speed 16 =&gt; JTAG clk=4.000000&lt;br&gt; 
+4000 kHz&lt;br&gt; 
+&gt; mdw 0 32&lt;br&gt;      
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e&lt;br&gt;  
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292&lt;br&gt;  
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18&lt;br&gt;  
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8&lt;br&gt;  
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD004&quot;/&gt;SPD004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;2MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; &gt; jtag_khz 2000&lt;br&gt; 
+jtag_speed 32 =&gt; JTAG clk=2.000000&lt;br&gt;
+2000 kHz&lt;br&gt;
+&gt; mdw 0 32&lt;br&gt;     
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e&lt;br&gt; 
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292&lt;br&gt; 
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18&lt;br&gt; 
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8&lt;br&gt; 
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD005&quot;/&gt;SPD005&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;RCLK on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 0&lt;br&gt;   
+RCLK - adaptive&lt;br&gt;
+RCLK timeout&lt;br&gt;
+RCLK timeout&lt;br&gt;
+RCLK timeout
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;&lt;b&gt;FAIL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Debugging&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG001&quot;/&gt;DBG001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Load is working&lt;/td&gt;
+		&lt;td&gt;Reset init is working, RAM is accesible, GDB server is started&lt;/td&gt;
+		&lt;td&gt;On the console of the OS: &lt;br&gt;
+			&lt;code&gt;arm-elf-gdb test_ram.elf&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) target remote ip:port&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) load&lt;/load&gt;
+		&lt;/td&gt;
+		&lt;td&gt;Load should return without error, typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				Loading section .text, size 0x14c lma 0x0&lt;br&gt;
+				Start address 0x40, load size 332&lt;br&gt;
+				Transfer rate: 180 bytes/sec, 332 bytes/write.&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+(gdb) load&lt;br&gt;
+Loading section .text, size 0x1cc lma 0x20000000&lt;br&gt;
+Loading section .vectors, size 0x40 lma 0x200001cc&lt;br&gt;
+Loading section .rodata, size 0x4 lma 0x2000020c&lt;br&gt;
+Start address 0x20000000, load size 528&lt;br&gt;
+Transfer rate: 64 KB/sec, 176 bytes/write.&lt;br&gt;
+(gdb) 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG002&quot;/&gt;DBG002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software breakpoint&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001&lt;/td&gt;
+		&lt;td&gt;In the GDB console:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor gdb_breakpoint_override soft&lt;br&gt;
+				force soft breakpoints&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0xec: file src/main.c, line 71.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The software breakpoint should be reached, a typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x000000d3 pc: 0x000000ec&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71        DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+(gdb) monitor gdb_breakpoint_override soft&lt;br&gt;
+force soft breakpoints&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently asm&quot;.&lt;br&gt;
+(gdb) break main&lt;br&gt;
+Breakpoint 1 at 0x20000170: file src/main.c, line 69.&lt;br&gt;
+(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+(gdb) 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG003&quot;/&gt;DBG003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in a RAM application&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;(gdb) step&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The next instruction should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Abort&lt;br&gt;
+				cpsr: 0x20000097 pc: 0x000000f0&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Abort&lt;br&gt;
+				cpsr: 0x20000097 pc: 0x000000f4&lt;br&gt;
+				72        DWORD b = 2;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				70        DWORD b = 2;&lt;br&gt;
+				(gdb)
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG004&quot;/&gt;DBG004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software break points are working after a reset&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x000000d3 pc: 0x000000ec&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71        DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+((gdb) monitor reset init&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x60000013 pc: 0x200001bc&lt;br&gt;
+jtag_speed 10 =&gt; JTAG clk=6.400000&lt;br&gt;
+6400 kHz&lt;br&gt;
+(gdb) load&lt;br&gt;
+Loading section .text, size 0x1cc lma 0x20000000&lt;br&gt;
+Loading section .vectors, size 0x40 lma 0x200001cc&lt;br&gt;
+Loading section .rodata, size 0x4 lma 0x2000020c&lt;br&gt;
+Start address 0x20000000, load size 528&lt;br&gt;
+Transfer rate: 64 KB/sec, 176 bytes/write.&lt;br&gt;
+(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG005&quot;/&gt;DBG005&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset init&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor gdb_breakpoint_override hard&lt;br&gt;
+				force hard breakpoints&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+(gdb) monitor gdb_breakpoint_override hard&lt;br&gt;
+force hard breakpoints&lt;br&gt;
+(gdb) break main&lt;br&gt;
+Breakpoint 1 at 0x40000170: file src/main.c, line 69.&lt;br&gt;
+(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+Note: automatically using hardware breakpoints for read-only addresses.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+(gdb) 
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG006&quot;/&gt;DBG006&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint is set after a reset&lt;/td&gt;
+		&lt;td&gt;Follow the instructions to flash and insert a hardware breakpoint from DBG005&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) monitor reg pc 0x100000&lt;br&gt;
+				pc (/32): 0x00100000&lt;br&gt;
+				(gdb) continue
+			&lt;/code&gt;&lt;br&gt;
+			where the value inserted in PC is the start address of the application
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+(gdb) monitor reset init&lt;br&gt;
+jtag_speed 6400 =&gt; JTAG clk=0.010000&lt;br&gt;
+10 kHz&lt;br&gt;
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)&lt;br&gt;
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Undefined instruction&lt;br&gt;
+cpsr: 0x400000db pc: 0x010aea80&lt;br&gt;
+jtag_speed 10 =&gt; JTAG clk=6.400000&lt;br&gt;
+6400 kHz&lt;br&gt;
+(gdb) monitor reg pc 0x40000000&lt;br&gt;
+pc (/32): 0x40000000&lt;br&gt;
+(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+(gdb)
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG007&quot;/&gt;DBG007&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in ROM&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor arm7_9  force_hw_bkpts enable&lt;br&gt;
+				force hardware breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+				(gdb) step
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x60000013 pc: 0x0010013c&lt;br&gt;
+				70        DWORD b = 2;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+Breakpoint 2, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+(gdb) step&lt;br&gt;
+70	  DWORD b = 2;&lt;br&gt;
+(gdb) 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;RAM access&lt;/H2&gt;
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM001&quot;/&gt;RAM001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;32 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mww ram_address 0xdeadbeef 16&lt;br&gt;
+					&gt; mdw ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mww 0x0 0xdeadbeef 16&lt;br&gt;
+				&gt; mdw 0x0 32&lt;br&gt;
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388&lt;br&gt;
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; mww 0x20000000 0xdeadbeef 16&lt;br&gt;
+&gt; mdw 0x20000000 32&lt;br&gt;
+0x20000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+0x20000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+0x20000040: e3a0020a e3a01073 e5801018 e5901008 e3110002 0afffffc e3a0020a e59f10d0&lt;br&gt; 
+0x20000060: e5801008 e321f0db e59fd0c8 e321f0d7 e59fd0c4 e321f0d1 e59fd0c0 e321f0d2&lt;br&gt; 
+&gt; 
+&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM002&quot;/&gt;RAM002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwh ram_address 0xbeef 16&lt;br&gt;
+					&gt; mdh ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwh 0x0 0xbeef 16&lt;br&gt;
+				&gt; mdh 0x0 32&lt;br&gt;
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt;
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; mwh 0x20000000 0xbeef 16&lt;br&gt;
+&gt; mdh 0x20000000 32&lt;br&gt;       
+0x20000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt; 
+0x20000020: beef dead beef dead beef dead beef dead beef dead beef dead beef dead beef dead&lt;br&gt; 
+&gt; 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM003&quot;/&gt;RAM003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwb ram_address 0xab 16&lt;br&gt;
+					&gt; mdb ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwb ram_address 0xab 16&lt;br&gt;
+				&gt; mdb ram_address 32&lt;br&gt;
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; mwb 0x20000000 0xab 16&lt;br&gt;  
+&gt; mdb 0x20000000 32&lt;br&gt;     
+0x20000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ef be ef be ef be ef be ef be ef be ef be ef be&lt;br&gt; 
+&gt; 
+ 		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+
+
+&lt;H2&gt;Flash access&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA001&quot;/&gt;FLA001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash probe&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface:&lt;br&gt;
+			&lt;code&gt;	&gt; flash probe 0&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The command should execute without error. The output should state the name of the flash and the starting address. An example of output:&lt;br&gt;
+			&lt;code&gt;flash 'ecosflash' found at 0x01000000&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			&gt; flash probe 0&lt;br&gt;
+			flash 'str7x' found at 0x40000000&lt;br&gt;
+			&gt; 
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA002&quot;/&gt;FLA002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;flash fillw&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; flash fillw 0x1000000 0xdeadbeef 16
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. The output looks like:&lt;br&gt;
+			&lt;code&gt;
+				wrote 64 bytes to 0x01000000 in 11.610000s (0.091516 kb/s)
+			&lt;/code&gt;&lt;br&gt;
+			To verify the contents of the flash:&lt;br&gt;
+			&lt;code&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+				&gt; flash fillw 0x40000000 0xdeadbeef 16&lt;br&gt;
+				wrote 64 bytes to 0x40000000 in 0.000000s (inf kb/s)&lt;br&gt;
+				&gt; mdw 0x40000000 32&lt;br&gt;
+				0x40000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+				0x40000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+				0x40000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				0x40000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+				&gt; 
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA003&quot;/&gt;FLA003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash erase&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt;  flash erase_address 0x1000000 0x2000
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error.&lt;br&gt;
+			&lt;code&gt;
+				erased address 0x01000000 length 8192 in 4.970000s
+			&lt;/code&gt;
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			&lt;code&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; flash erase_address 0x40000000 0x2000&lt;br&gt;
+erased address 0x40000000 (length 8192) in 0.270000s (29.630 kb/s)&lt;br&gt;
+&gt; mdw 0x40000000 32                    &lt;br&gt;
+0x40000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x40000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x40000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x40000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+&gt; 
+&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA004&quot;/&gt;FLA004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Loading to flash from GDB&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed, connectivity to GDB server is working&lt;/td&gt;
+		&lt;td&gt;Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. &lt;br&gt;
+				&lt;code&gt;
+					(gdb) target remote ip:port&lt;br&gt;
+					(gdb) monitor reset&lt;br&gt;
+					(gdb) load&lt;br&gt;
+					Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+					Start address 0x100040, load size 404&lt;br&gt;
+					Transfer rate: 179 bytes/sec, 404 bytes/write.
+					(gdb) monitor verify_image path_to_elf_file		
+				&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The output should look like:&lt;br&gt;
+			&lt;code&gt;
+				verified 404 bytes in 5.060000s
+			&lt;/code&gt;&lt;br&gt;
+			The failure message is something like:&lt;br&gt;
+			&lt;code&gt;Verify operation failed address 0x00200000. Was 0x00 instead of 0x18&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+(gdb) load&lt;br&gt;
+Loading section .text, size 0x1cc lma 0x40000000&lt;br&gt;
+Loading section .vectors, size 0x40 lma 0x400001cc&lt;br&gt;
+Loading section .rodata, size 0x4 lma 0x4000020c&lt;br&gt;
+Start address 0x40000000, load size 528&lt;br&gt;
+Transfer rate: 53 bytes/sec, 176 bytes/write.&lt;br&gt;
+(gdb) monitor verify_image /tftp/10.0.0.194/test_rom.elf&lt;br&gt;
+verified 528 bytes in 4.760000s (0.108 kb/s)&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently asm&quot;.&lt;br&gt;
+(gdb) 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;	
+&lt;/table&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/STR912.html b/testing/results/v0.4.0-rc1/STR912.html
new file mode 100755
index 0000000..c8df034
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/STR912.html
@@ -0,0 +1,1008 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;title&gt;Test results for version 1.62&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body&gt;
+
+&lt;H1&gt;STR912&lt;/H1&gt;
+
+&lt;H2&gt;Connectivity&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON001&quot;/&gt;CON001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Telnet connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On console, type&lt;br&gt;&lt;code&gt;telnet ip port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Open On-Chip Debugger&lt;br&gt;&gt;&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;&gt; telnet 10.0.0.142&lt;br&gt;
+					Trying 10.0.0.142...&lt;br&gt;
+					Connected to 10.0.0.142.&lt;br&gt;
+					Escape character is '^]'.&lt;br&gt;
+					Open On-Chip Debugger&lt;br&gt;
+					&gt;
+&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;CON002&quot;/&gt;CON002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;GDB server connection&lt;/td&gt;
+		&lt;td&gt;Power on, jtag target attached&lt;/td&gt;
+		&lt;td&gt;On GDB console, type&lt;br&gt;&lt;code&gt;target remote ip:port&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;Remote debugging using 10.0.0.73:3333&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) tar remo 10.0.0.142:3333&lt;br&gt;
+			Remote debugging using 10.0.0.142:3333&lt;br&gt;
+			0x00016434 in ?? ()&lt;br&gt;
+			(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Reset&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES001&quot;/&gt;RES001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; reset halt&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES002&quot;/&gt;RES002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset init on a blank target&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset init&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain &lt;br&gt;&lt;code&gt;executing reset script 'name_of_the_script'&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; reset init&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+cleared protection for sectors 0 through 7 on flash bank 0&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES003&quot;/&gt;RES003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset after a power cycle of the target&lt;/td&gt;
+		&lt;td&gt;Reset the target then power cycle the target&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt; after the power was detected&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+      nsed nSRST asserted.&lt;br&gt;
+  nsed power dropout.&lt;br&gt;
+  nsed power restore.&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 85ms to deassert&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+cleared protection for sectors 0 through 7 on flash bank 0&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+&gt; reset halt&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES004&quot;/&gt;RES004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target where reset halt is supported&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;br&gt;pc = 0&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; reset halt&lt;br&gt;
+ RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (Manufacturer: 0x020, Part: 0x4570, Version: 0x0)&lt;br&gt;
+JTAG Tap/device matched&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (Manufacturer: 0x020, Part: 0x5966, Version: 0x2)&lt;br&gt;
+JTAG Tap/device matched&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (Manufacturer: 0x020, Part: 0x457f, Version: 0x2)&lt;br&gt;
+JTAG Tap/device matched&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RES005&quot;/&gt;RES005&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Reset halt on a blank target using return clock&lt;/td&gt;
+		&lt;td&gt;Erase all the content of the flash, set the configuration script to use RCLK&lt;/td&gt;
+		&lt;td&gt;Connect via the telnet interface and type &lt;br&gt;&lt;code&gt;reset halt&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;Reset should return without error and the output should contain&lt;br&gt;&lt;code&gt;target state: halted&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+			&gt; reset halt&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;JTAG Speed&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD001&quot;/&gt;SPD001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 16000&lt;br&gt;
+jtag_speed 4 =&gt; JTAG clk=16.000000&lt;br&gt;
+16000 kHz&lt;br&gt;
+ThumbEE -- incomplete support&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ThumbEE state due to debug-request, current mode: System&lt;br&gt;
+cpsr: 0xfdfdffff pc: 0xfdfdfff9&lt;br&gt;
+&gt; mdw 0 32      &lt;br&gt;
+0x00000000: 00000000 00000000 ffffffff ffffffff 00000001 ffffffff 00000001 ffffffff&lt;br&gt; 
+0x00000020: 00000001 00000001 00000001 00000001 00000001 fffffffe fffffffe 00000001&lt;br&gt; 
+0x00000040: fffffffe 00000000 00000000 00000000 00000000 00000000 00000000 00000000&lt;br&gt; 
+0x00000060: 00000000 00000000 00000000 00000000 ffffffff ffffffff 00000001 00000000&lt;br&gt; 
+invalid mode value encountered 0&lt;br&gt;
+cpsr contains invalid mode value - communication failure&lt;br&gt;
+ThumbEE -- incomplete support&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ThumbEE state due to debug-request, current mode: System&lt;br&gt;
+cpsr: 0xffffffff pc: 0xfffffff8&lt;br&gt;
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;&lt;b&gt;FAIL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD002&quot;/&gt;SPD002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 8000&lt;br&gt;
+jtag_speed 8 =&gt; JTAG clk=8.000000&lt;br&gt;
+8000 kHz&lt;br&gt;
+&gt; halt      &lt;br&gt;   
+invalid mode value encountered 0&lt;br&gt;
+cpsr contains invalid mode value - communication failure&lt;br&gt;
+Command handler execution failed&lt;br&gt;
+in procedure 'halt' called at file &quot;command.c&quot;, line 647&lt;br&gt;
+called at file &quot;command.c&quot;, line 361&lt;br&gt;
+Halt timed out, wake up GDB.&lt;br&gt;
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;font color=red&gt;&lt;b&gt;FAIL&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD003&quot;/&gt;SPD003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;4MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 4000&lt;br&gt;
+jtag_speed 16 =&gt; JTAG clk=4.000000&lt;br&gt;
+4000 kHz&lt;br&gt;
+&gt; halt      &lt;br&gt;   
+&gt; mdw 0 32     &lt;br&gt;
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD004&quot;/&gt;SPD004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;2MHz on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 2000&lt;br&gt;
+jtag_speed 32 =&gt; JTAG clk=2.000000&lt;br&gt;
+2000 kHz&lt;br&gt;
+&gt; halt&lt;br&gt;
+&gt; mdw 0 32&lt;br&gt;     
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;SPD005&quot;/&gt;SPD005&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;RCLK on normal operation&lt;/td&gt;
+		&lt;td&gt;Reset init the target according to RES002 &lt;/td&gt;
+		&lt;td&gt;Change speed and exercise a memory access over the JTAG, for example &lt;br&gt;&lt;code&gt;mdw 0x0 32&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The command should run without any errors. If any JTAG checking errors happen, the test failed&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+&gt; jtag_khz 0&lt;br&gt;   
+RCLK - adaptive&lt;br&gt;
+&gt; halt      &lt;br&gt;
+&gt; mdw 0 32  &lt;br&gt;
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+&gt; 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;Debugging&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG001&quot;/&gt;DBG001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Load is working&lt;/td&gt;
+		&lt;td&gt;Reset init is working, RAM is accesible, GDB server is started&lt;/td&gt;
+		&lt;td&gt;On the console of the OS: &lt;br&gt;
+			&lt;code&gt;arm-elf-gdb test_ram.elf&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) target remote ip:port&lt;/code&gt;&lt;br&gt;
+			&lt;code&gt;(gdb) load&lt;/load&gt;
+		&lt;/td&gt;
+		&lt;td&gt;Load should return without error, typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				Loading section .text, size 0x14c lma 0x0&lt;br&gt;
+				Start address 0x40, load size 332&lt;br&gt;
+				Transfer rate: 180 bytes/sec, 332 bytes/write.&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+(gdb) load&lt;br&gt;
+Loading section .text, size 0x1a0 lma 0x4000000&lt;br&gt;
+Loading section .rodata, size 0x4 lma 0x40001a0&lt;br&gt;
+Start address 0x4000000, load size 420&lt;br&gt;
+Transfer rate: 29 KB/sec, 210 bytes/write.&lt;br&gt;
+(gdb) 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG002&quot;/&gt;DBG002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software breakpoint&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001&lt;/td&gt;
+		&lt;td&gt;In the GDB console:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor gdb_breakpoint_override soft&lt;br&gt;
+				force soft breakpoints&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0xec: file src/main.c, line 71.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The software breakpoint should be reached, a typical output looks like:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x000000d3 pc: 0x000000ec&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71        DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+(gdb) monitor gdb_breakpoint_override soft&lt;br&gt;
+force soft breakpoints&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently asm&quot;.&lt;br&gt;
+(gdb) break main&lt;br&gt;
+Breakpoint 1 at 0x4000144: file src/main.c, line 69.&lt;br&gt;
+(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+warning: Source file is more recent than executable.&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+(gdb) 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG003&quot;/&gt;DBG003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in a RAM application&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;(gdb) step&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The next instruction should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Abort&lt;br&gt;
+				cpsr: 0x20000097 pc: 0x000000f0&lt;br&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Abort&lt;br&gt;
+				cpsr: 0x20000097 pc: 0x000000f4&lt;br&gt;
+				72        DWORD b = 2;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+				(gdb) step&lt;br&gt;
+				70	  DWORD b = 2;&lt;br&gt;
+				(gdb)&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG004&quot;/&gt;DBG004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Software break points are working after a reset&lt;/td&gt;
+		&lt;td&gt;Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;&lt;code&gt;
+			(gdb) monitor reset init&lt;br&gt;
+			(gdb) load&lt;br&gt;
+			(gdb) continue&lt;br&gt;
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to breakpoint, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x000000d3 pc: 0x000000ec&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:71&lt;br&gt;
+				71        DWORD a = 1;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+(gdb) monitor reset init&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+cleared protection for sectors 0 through 7 on flash bank 0&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+(gdb) load&lt;br&gt;
+Loading section .text, size 0x1a0 lma 0x4000000&lt;br&gt;
+Loading section .rodata, size 0x4 lma 0x40001a0&lt;br&gt;
+Start address 0x4000000, load size 420&lt;br&gt;
+Transfer rate: 25 KB/sec, 210 bytes/write.&lt;br&gt;
+(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+(gdb)
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG005&quot;/&gt;DBG005&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset init&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor gdb_breakpoint_override hard&lt;br&gt;
+				force hard breakpoints&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+(gdb) monitor reset init&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+cleared protection for sectors 0 through 7 on flash bank 0&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+(gdb) load&lt;br&gt;
+Loading section .text, size 0x1a0 lma 0x0&lt;br&gt;
+Loading section .rodata, size 0x4 lma 0x1a0&lt;br&gt;
+Start address 0x0, load size 420&lt;br&gt;
+Transfer rate: 426 bytes/sec, 210 bytes/write.&lt;br&gt;
+(gdb) monitor gdb_breakpoint_override hard&lt;br&gt;
+force hard breakpoints&lt;br&gt;
+(gdb) break main&lt;br&gt;
+Breakpoint 1 at 0x144: file src/main.c, line 69.&lt;br&gt;
+(gdb) continue&lt;br&gt;
+Continuing.&lt;br&gt;
+Note: automatically using hardware breakpoints for read-only addresses.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+warning: Source file is more recent than executable.&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+(gdb) 
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG006&quot;/&gt;DBG006&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Hardware breakpoint is set after a reset&lt;/td&gt;
+		&lt;td&gt;Follow the instructions to flash and insert a hardware breakpoint from DBG005&lt;/td&gt;
+		&lt;td&gt;In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) monitor reg pc 0x100000&lt;br&gt;
+				pc (/32): 0x00100000&lt;br&gt;
+				(gdb) continue
+			&lt;/code&gt;&lt;br&gt;
+			where the value inserted in PC is the start address of the application
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+(gdb) monitor reset init&lt;br&gt;
+RCLK - adaptive&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)&lt;br&gt;
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)&lt;br&gt;
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)&lt;br&gt;
+Trying to use configured scan chain anyway...&lt;br&gt;
+Bypassing JTAG setup events due to errors&lt;br&gt;
+SRST took 2ms to deassert&lt;br&gt;
+target state: halted&lt;br&gt;
+target halted in ARM state due to debug-request, current mode: Supervisor&lt;br&gt;
+cpsr: 0x000000d3 pc: 0x00000000&lt;br&gt;
+cleared protection for sectors 0 through 7 on flash bank 0&lt;br&gt;
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.&lt;br&gt;
+(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+(gdb)
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;DBG007&quot;/&gt;DBG007&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Single step in ROM&lt;/td&gt;
+		&lt;td&gt;Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed&lt;/td&gt;
+		&lt;td&gt;Be sure that &lt;code&gt;gdb_memory_map&lt;/code&gt; and &lt;code&gt;gdb_flash_program&lt;/code&gt; are enabled. In GDB, type &lt;br&gt;
+			&lt;code&gt;
+				(gdb) monitor reset&lt;br&gt;
+				(gdb) load&lt;br&gt;
+				Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+				Start address 0x100040, load size 404&lt;br&gt;
+				Transfer rate: 179 bytes/sec, 404 bytes/write.&lt;br&gt;
+				(gdb) monitor arm7_9  force_hw_bkpts enable&lt;br&gt;
+				force hardware breakpoints enabled&lt;br&gt;
+				(gdb) break main&lt;br&gt;
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.&lt;br&gt;
+				(gdb) continue&lt;br&gt;
+				Continuing.&lt;br&gt;
+				&lt;br&gt;
+				Breakpoint 1, main () at src/main.c:69&lt;br&gt;
+				69        DWORD a = 1;&lt;br&gt;
+				(gdb) step
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The breakpoint should be reached, typical output:&lt;br&gt;
+			&lt;code&gt;
+				target state: halted&lt;br&gt;
+				target halted in ARM state due to single step, current mode: Supervisor&lt;br&gt;
+				cpsr: 0x60000013 pc: 0x0010013c&lt;br&gt;
+				70        DWORD b = 2;&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+			(gdb) c&lt;br&gt;
+Continuing.&lt;br&gt;
+&lt;br&gt;
+Breakpoint 2, main () at src/main.c:69&lt;br&gt;
+69	  DWORD a = 1;&lt;br&gt;
+Current language:  auto&lt;br&gt;
+The current source language is &quot;auto; currently c&quot;.&lt;br&gt;
+(gdb) step&lt;br&gt;
+70	  DWORD b = 2;&lt;br&gt;
+(gdb) 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+&lt;H2&gt;RAM access&lt;/H2&gt;
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM001&quot;/&gt;RAM001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;32 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mww ram_address 0xdeadbeef 16&lt;br&gt;
+					&gt; mdw ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mww 0x0 0xdeadbeef 16&lt;br&gt;
+				&gt; mdw 0x0 32&lt;br&gt;
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388&lt;br&gt;
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388&lt;br&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; mww 0x4000000 0xdeadbeef 16&lt;br&gt;
+&gt; mdw 0x4000000 32            &lt;br&gt;
+0x04000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+0x04000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+0x04000040: e580100c e3a01802 e5801010 e3a01018 e5801018 e59f00a8 e59f10a8 e5801000&lt;br&gt; 
+0x04000060: e3a00806 ee2f0f11 e321f0d7 e59fd098 e321f0db e59fd094 e321f0d3 e59fd090&lt;br&gt; 
+&gt; 
+&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM002&quot;/&gt;RAM002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;16 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwh ram_address 0xbeef 16&lt;br&gt;
+					&gt; mdh ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwh 0x0 0xbeef 16&lt;br&gt;
+				&gt; mdh 0x0 32&lt;br&gt;
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt;
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; mwh 0x4000000 0xbeef 16&lt;br&gt;    
+&gt; mdh 0x4000000 32&lt;br&gt;           
+0x04000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef&lt;br&gt; 
+0x04000020: beef dead beef dead beef dead beef dead beef dead beef dead beef dead beef dead&lt;br&gt; 
+&gt; 
+		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;RAM003&quot;/&gt;RAM003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;8 bit Write/read RAM&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; mwb ram_address 0xab 16&lt;br&gt;
+					&gt; mdb ram_address 32
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.&lt;br&gt;
+			&lt;code&gt;
+				&gt; mwb ram_address 0xab 16&lt;br&gt;
+				&gt; mdb ram_address 32&lt;br&gt;
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&lt;br&gt;
+				&gt;
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; mwb 0x4000000 0xab 16&lt;br&gt;  
+&gt; mdb 0x4000000 32&lt;br&gt;     
+0x04000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ef be ef be ef be ef be ef be ef be ef be ef be&lt;br&gt; 
+&gt; 
+ 		&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+&lt;/table&gt;
+
+
+
+&lt;H2&gt;Flash access&lt;/H2&gt;
+&lt;table border=1&gt;
+	&lt;tr&gt;
+		&lt;td&gt;ID&lt;/td&gt;
+		&lt;td&gt;Target&lt;/td&gt;
+		&lt;td&gt;Interface&lt;/td&gt;
+		&lt;td&gt;Description&lt;/td&gt;
+		&lt;td&gt;Initial state&lt;/td&gt;
+		&lt;td&gt;Input&lt;/td&gt;
+		&lt;td&gt;Expected output&lt;/td&gt;
+		&lt;td&gt;Actual output&lt;/td&gt;
+		&lt;td&gt;Pass/Fail&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA001&quot;/&gt;FLA001&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash probe&lt;/td&gt;
+		&lt;td&gt;Reset init is working&lt;/td&gt;
+		&lt;td&gt;On the telnet interface:&lt;br&gt;
+			&lt;code&gt;	&gt; flash probe 0&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The command should execute without error. The output should state the name of the flash and the starting address. An example of output:&lt;br&gt;
+			&lt;code&gt;flash 'ecosflash' found at 0x01000000&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+		&lt;code&gt;
+			&gt; flash probe 0&lt;br&gt;
+			flash 'str9x' found at 0x00000000&lt;br&gt;
+			&gt; 
+		&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA002&quot;/&gt;FLA002&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;flash fillw&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt; flash fillw 0x1000000 0xdeadbeef 16
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error. The output looks like:&lt;br&gt;
+			&lt;code&gt;
+				wrote 64 bytes to 0x01000000 in 11.610000s (0.091516 kb/s)
+			&lt;/code&gt;&lt;br&gt;
+			To verify the contents of the flash:&lt;br&gt;
+			&lt;code&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; flash fillw 0x0 0xdeadbeef 16 &lt;br&gt;    
+wrote 64 bytes to 0x00000000 in 0.020000s (3.125 kb/s)&lt;br&gt;
+&gt; mdw 0 32&lt;br&gt;
+0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef&lt;br&gt; 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+&gt; 
+			&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA003&quot;/&gt;FLA003&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Flash erase&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt;  flash erase_address 0x1000000 0x20000
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error.&lt;br&gt;
+			&lt;code&gt;
+				erased address 0x01000000 length 131072 in 4.970000s&lt;br&gt;
+			&lt;/code&gt;
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff.&lt;br&gt; 
+			&lt;code&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; flash erase_address 0 0x20000&lt;br&gt;
+erased address 0x00000000 (length 131072) in 1.970000s (64.975 kb/s)&lt;br&gt;
+&gt; mdw 0 32&lt;br&gt;
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt; 
+&gt; 
+&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+		&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA004&quot;/&gt;FLA004&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Entire flash erase&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed&lt;/td&gt;
+		&lt;td&gt;On the telnet interface&lt;br&gt;
+			&lt;code&gt;	&gt;  flash erase_address 0x0 0x80000
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The commands should execute without error.&lt;br&gt;
+			&lt;code&gt;
+				erased address 0x01000000 length 8192 in 4.970000s&lt;br&gt;
+			&lt;/code&gt;
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff.&lt;br&gt; 
+			&lt;code&gt;
+				&gt; mdw 0x1000000 32&lt;br&gt;
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;&lt;code&gt;
+&gt; flash erase_address 0 0x80000&lt;br&gt;
+ erased address 0x00000000 length 524288 in 1.020000s&lt;br&gt;
+&lt;br&gt;
+&gt; mdw 0 32&lt;br&gt;
+ 0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff&lt;br&gt;
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+&lt;/code&gt;&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;
+	&lt;tr&gt;
+		&lt;td&gt;&lt;a name=&quot;FLA005&quot;/&gt;FLA005&lt;/td&gt;
+		&lt;td&gt;STR912&lt;/td&gt;
+		&lt;td&gt;ZY1000&lt;/td&gt;
+		&lt;td&gt;Loading to flash from GDB&lt;/td&gt;
+		&lt;td&gt;Reset init is working, flash is probed, connectivity to GDB server is working&lt;/td&gt;
+		&lt;td&gt;Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. &lt;br&gt;
+				&lt;code&gt;
+					(gdb) target remote ip:port&lt;br&gt;
+					(gdb) monitor reset&lt;br&gt;
+					(gdb) load&lt;br&gt;
+					Loading section .text, size 0x194 lma 0x100000&lt;br&gt;
+					Start address 0x100040, load size 404&lt;br&gt;
+					Transfer rate: 179 bytes/sec, 404 bytes/write.
+					(gdb) monitor verify_image path_to_elf_file		
+				&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;The output should look like:&lt;br&gt;
+			&lt;code&gt;
+				verified 404 bytes in 5.060000s
+			&lt;/code&gt;&lt;br&gt;
+			The failure message is something like:&lt;br&gt;
+			&lt;code&gt;Verify operation failed address 0x00200000. Was 0x00 instead of 0x18&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;
+			&lt;code&gt;
+(gdb) load&lt;br&gt;
+Loading section .text, size 0x1a0 lma 0x0&lt;br&gt;
+Loading section .rodata, size 0x4 lma 0x1a0&lt;br&gt;
+Start address 0x0, load size 420&lt;br&gt;
+Transfer rate: 425 bytes/sec, 210 bytes/write.&lt;br&gt;
+(gdb) moni verify_image /tftp/10.0.0.194/test_rom.elf&lt;br&gt;
+verified 420 bytes in 0.350000s (1.172 kb/s)&lt;br&gt;
+(gdb) 
+			&lt;/code&gt;
+		&lt;/td&gt;
+		&lt;td&gt;PASS&lt;/td&gt;	
+	&lt;/tr&gt;	
+&lt;/table&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file

-----------------------------------------------------------------------

Summary of changes:
 testing/results/v0.4.0-rc1/AT91FR40162.html |  856 +++++++++++++++++++++++
 testing/results/v0.4.0-rc1/LPC2148.html     |  933 +++++++++++++++++++++++++
 testing/results/v0.4.0-rc1/SAM7.html        |  853 ++++++++++++++++++++++
 testing/results/v0.4.0-rc1/STR710.html      |  907 ++++++++++++++++++++++++
 testing/results/v0.4.0-rc1/STR912.html      | 1008 +++++++++++++++++++++++++++
 5 files changed, 4557 insertions(+), 0 deletions(-)
 create mode 100755 testing/results/v0.4.0-rc1/AT91FR40162.html
 create mode 100755 testing/results/v0.4.0-rc1/LPC2148.html
 create mode 100755 testing/results/v0.4.0-rc1/SAM7.html
 create mode 100755 testing/results/v0.4.0-rc1/STR710.html
 create mode 100755 testing/results/v0.4.0-rc1/STR912.html


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002079.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-169-g91e3268
</A></li>
	<LI>Next message: <A HREF="002082.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-rc1-171-g3d2d5dc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2080">[ date ]</a>
              <a href="thread.html#2080">[ thread ]</a>
              <a href="subject.html#2080">[ subject ]</a>
              <a href="author.html#2080">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
