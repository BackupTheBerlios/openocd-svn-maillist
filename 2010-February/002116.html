<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-13-gc21c740
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-13-gc21c740&In-Reply-To=%3CE1NjMzg-0003QI-4P%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002115.html">
   <LINK REL="Next"  HREF="002117.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-13-gc21c740</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-13-gc21c740&In-Reply-To=%3CE1NjMzg-0003QI-4P%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-13-gc21c740">dbrownell at users.sourceforge.net
       </A><BR>
    <I>Mon Feb 22 02:21:51 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002115.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-1-gb853b9d
</A></li>
        <LI>Next message: <A HREF="002117.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-14-g90efc40
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2116">[ date ]</a>
              <a href="thread.html#2116">[ thread ]</a>
              <a href="subject.html#2116">[ subject ]</a>
              <a href="author.html#2116">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  c21c740a895438832ed7e945ee4943da3eb733f9 (commit)
       via  dc342f45f6c8ec02431495863687b3638f1646d5 (commit)
       via  c8ea748dc22660dad934537384d35903dfcc492e (commit)
       via  3b68a708c2b039d9b091608eccb2206725742a47 (commit)
       via  ecff73043c1ddcc97d4d1ea1c87f251a850b22d4 (commit)
       via  39cfe6279616a69b858ddd3493d61ed7133ff081 (commit)
       via  a97bb67543eacde38f093610982812f714e7a050 (commit)
       via  249263d29da11b0ec981c2e0d520cd7dcf08939b (commit)
       via  1aac72d24339380f6e98c50dec4c96ab30537749 (commit)
       via  a299371a9ec109da3851cb43aed3e9157d095358 (commit)
       via  27c068c1f82423a2492899d1632caaa6f8261810 (commit)
       via  ce1feaa7322affd3b979c9fe93dd8f7462ea9eca (commit)
      from  b853b9dbc0ba3d68a501d8badc4491f8108cd11b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c21c740a895438832ed7e945ee4943da3eb733f9
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 17:19:08 2010 -0800

    ft2232 table init cleanup
    
    Use labeled initializers in the table of layouts instead of
    positional ones.  This ls cleaner and less error prone, plus
    it simplifies patches which add members to these structure.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 82132d3..5042a22 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -185,25 +185,84 @@ static void ktlink_blink(void);
 
 static const struct ft2232_layout  ft2232_layouts[] =
 {
-	{ &quot;usbjtag&quot;,              usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ &quot;jtagkey&quot;,              jtagkey_init,              jtagkey_reset,      NULL                    },
-	{ &quot;jtagkey_prototype_v1&quot;, jtagkey_init,              jtagkey_reset,      NULL                    },
-	{ &quot;oocdlink&quot;,             jtagkey_init,              jtagkey_reset,      NULL                    },
-	{ &quot;signalyzer&quot;,           usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ &quot;evb_lm3s811&quot;,          usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ &quot;luminary_icdi&quot;,        usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ &quot;olimex-jtag&quot;,          olimex_jtag_init,          olimex_jtag_reset,  olimex_jtag_blink       },
-	{ &quot;flyswatter&quot;,           flyswatter_init,           flyswatter_reset,   flyswatter_jtag_blink   },
-	{ &quot;turtelizer2&quot;,          turtle_init,               turtle_reset,       turtle_jtag_blink       },
-	{ &quot;comstick&quot;,             comstick_init,             comstick_reset,     NULL                    },
-	{ &quot;stm32stick&quot;,           stm32stick_init,           stm32stick_reset,   NULL                    },
-	{ &quot;axm0432_jtag&quot;,         axm0432_jtag_init,         axm0432_jtag_reset, NULL                    },
-	{ &quot;sheevaplug&quot;,           sheevaplug_init,           sheevaplug_reset,   NULL                    },
-	{ &quot;icebear&quot;,              icebear_jtag_init,         icebear_jtag_reset, NULL                    },
-	{ &quot;cortino&quot;,              cortino_jtag_init,         comstick_reset, NULL                        },
-	{ &quot;signalyzer-h&quot;,         signalyzer_h_init,         signalyzer_h_reset, signalyzer_h_blink      },
-	{ &quot;ktlink&quot;,               ktlink_init,               ktlink_reset,       ktlink_blink            },
-	{ NULL,                   NULL,                      NULL,               NULL                    },
+	{ .name = &quot;usbjtag&quot;,
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = &quot;jtagkey&quot;,
+		.init = jtagkey_init,
+		.reset = jtagkey_reset,
+	},
+	{ .name = &quot;jtagkey_prototype_v1&quot;,
+		.init = jtagkey_init,
+		.reset = jtagkey_reset,
+	},
+	{ .name = &quot;oocdlink&quot;,
+		.init = jtagkey_init,
+		.reset = jtagkey_reset,
+	},
+	{ .name = &quot;signalyzer&quot;,
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = &quot;evb_lm3s811&quot;,
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = &quot;luminary_icdi&quot;,
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = &quot;olimex-jtag&quot;,
+		.init = olimex_jtag_init,
+		.reset = olimex_jtag_reset,
+		.blink = olimex_jtag_blink
+	},
+	{ .name = &quot;flyswatter&quot;,
+		.init = flyswatter_init,
+		.reset = flyswatter_reset,
+		.blink = flyswatter_jtag_blink
+	},
+	{ .name = &quot;turtelizer2&quot;,
+		.init = turtle_init,
+		.reset = turtle_reset,
+		.blink = turtle_jtag_blink
+	},
+	{ .name = &quot;comstick&quot;,
+		.init = comstick_init,
+		.reset = comstick_reset,
+	},
+	{ .name = &quot;stm32stick&quot;,
+		.init = stm32stick_init,
+		.reset = stm32stick_reset,
+	},
+	{ .name = &quot;axm0432_jtag&quot;,
+		.init = axm0432_jtag_init,
+		.reset = axm0432_jtag_reset,
+	},
+	{ .name = &quot;sheevaplug&quot;,
+		.init = sheevaplug_init,
+		.reset = sheevaplug_reset,
+	},
+	{ .name = &quot;icebear&quot;,
+		.init = icebear_jtag_init,
+		.reset = icebear_jtag_reset,
+	},
+	{ .name = &quot;cortino&quot;,
+		.init = cortino_jtag_init,
+		.reset = comstick_reset,
+	},
+	{ .name = &quot;signalyzer-h&quot;,
+		.init = signalyzer_h_init,
+		.reset = signalyzer_h_reset,
+		.blink = signalyzer_h_blink
+	},
+	{ .name = &quot;ktlink&quot;,
+		.init = ktlink_init,
+		.reset = ktlink_reset,
+		.blink = ktlink_blink
+	},
+	{ .name = NULL, /* END OF TABLE */ },
 };
 
 static uint8_t                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;

commit dc342f45f6c8ec02431495863687b3638f1646d5
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 16:55:17 2010 -0800

    Developer's Guide: refresh release procedures
    
    Be a closer match to what I've actually done for the past few cycles.
    
    In particular, hold off pushing repository updates until after the
    packages are published, as part of opening the merge window, and
    mention the utility commands which actually create the archives.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/doc/manual/release.txt b/doc/manual/release.txt
index 70a22ff..056628e 100644
--- a/doc/manual/release.txt
+++ b/doc/manual/release.txt
@@ -84,8 +84,8 @@ the minor version will @a also be zero (&lt;code&gt;y = 0, z = 0&lt;/code&gt;).
 After these required numeric components, release version strings
 may contain tags such as as &lt;em&gt;-rc1&lt;/em&gt; or &lt;em&gt;-rc2&lt;/em&gt;.
 These 'rc' tags indicate &quot;release candidate&quot; versions of the package.
-Like the major/minor/micro numbers, these tags will be manipulated
-by the automated release process.
+Like major/minor/micro numbers, these are updated
+as part of the release process.
 
 The release process includes version number manipulations to the tree
 being released, ensuring that all numbers are incremented (or rolled
@@ -277,22 +277,34 @@ support; the Release Manager isn't the only participant.
 
 The following steps should be followed to produce each release:
 
--# Produce final patches to mainline (or a release branch).  Nobody
-   except the RM should be committing anything.
-  -# Finalize @c NEWS file to describe the changes in the release
+-# Produce final patches using a local clone of mainline.  Nobody
+   except the RM should be committing anything.  &lt;em&gt;Everyone with commit
+   privileges needs to know and agree to this in advance!&lt;/em&gt;  Even the RM
+   only commits a handful of updates as part of the release process
+   itself ... to files which are part of the version identification scheme
+   or release process; and to create the version tag; and then to open the
+   merge window for the next release cycle.
+  -# Finalize @c the NEWS file to describe the changes in the release
     - This file is used to automatically post &quot;blurbs&quot; about the project.
-    - This material should be produced during the development cycle.
-    - Add a new item for each @c NEWS-worthy contribution, when committed.
+    - This material should have been produced during the development cycle,
+      by adding items for each @c NEWS-worthy contribution, when committed
+      during the merge window.  (One part of closing the merge window, by
+      opening the RC phase of the release, is the commitment to hold all
+      further such contributions until the next merge window opens.)
+    - The RM should make sure nothing important was omitted, as part of
+      the RC1 cycle.  From then on, no more updates to NEWS content should
+      be needed (except to seed the process for the next release, or maybe
+      if a significant and longstanding bug is fixed late in the RC phase).
   -# Bump library version if our API changed (not yet required)
   -# Update and commit the final package version in @c configure.in:
-     &lt;code&gt;tools/release/version.sh&lt;/code&gt; may help ensure the versions
-     are named consistently:
+     (The &lt;code&gt;tools/release/version.sh&lt;/code&gt; script might help ensure
+     the versions are named properly.):
     -# Remove @c -dev tag.
-    -# Update the @c -rc tag:
+    -# Update any @c -rc tag:
       - If producing the final release from an -rc series, remove it
       - If producing the first RC in a series, add rc1
       - If producing the next RC in a series, bump the rc number
-    -# Commit that version change.
+    -# Commit that version change, with a good descriptive comment.
   -# Create a git tag for the final commit, with a tag name matching
      the version string in &lt;code&gt;configure.in&lt;/code&gt; (including &lt;em&gt;-rcN&lt;/em&gt;
      where relevant):
@@ -301,49 +313,92 @@ PACKAGE_VERSION=&quot;x.y.z&quot;
 PACKAGE_TAG=&quot;v${PACKAGE_VERSION}&quot;
 git tag -m &quot;The openocd-${PACKAGE_VERSION} release.&quot; &quot;${PACKAGE_TAG}&quot;
 @endverbatim
--# Prepare to resume normal development on mainline (major or minor release)
-  - Update the version label
-     - Restore @c -dev version tag.
-     - For a new minor release cycle, increment the release's minor number
-     - For a new major release cycle, increment the release's major number
-       and zero its minor number
-  - Archive @c NEWS file as &quot;&lt;code&gt;doc/news/NEWS-${PACKAGE_VERSION}&lt;/code&gt;&quot;.
-  - Create a new @c NEWS file for the next release
-  - Commit those changes, and push the commit and the release tag
-    to mainline.
--# Produce the package source archives:
-  -# &lt;em&gt;Start with a new clone of the source tree&lt;/em&gt;, with the
-     release's tag.  This is used only for producing these packages.
-  -# Checkout the appropriate tag:
-&lt;code&gt;git checkout &quot;${PACKAGE_VERSION}&quot;&lt;/code&gt;
-  -# @c bootstrap, @c configure, and @c make the package.
-  -# Run &lt;code&gt;make distcheck&lt;/code&gt; to produce the distribution archives.
-  -# Run &lt;code&gt;make maintainer-clean&lt;/code&gt; verify the repository is empty.
-  -# Create signature files using @c md5sum, @c sha1sum, etc.
--# Publish documentation for the release:
-  - Allow users to access the documentation for each of our releases.
-  - Place static copies of the following files on the project website:
-    - @c NEWS: to provide a blurb for each release
-    - User's Guide, Developer Manual: to allow easy on-line viewing
+  -# Do not push those changes to mainline yet; only builds using the
+     source archives you will be creating should ever be labeled as
+     official releases (with no &quot;-dev&quot; suffix).  Since mainline is a
+     development tree, these will be pushed later, as part of opening
+     the merge window for the next release cycle (restoring the &quot;-dev&quot;
+     suffix for that next release.)  Those version and tag updates are
+     the last ones to be included in the release being made.
+-# Produce the release files, using the local clone of the source
+  tree which holds the release's tag and updated version in
+  @c configure.in ... this is used only to produce the release, and
+  all files should already be properly checked out.
+  -# Run &lt;code&gt;tools/release.sh package&lt;/code&gt; to produce the
+	source archives.  This automatically bootstraps and
+	configures the process.
+  -# Run &lt;code&gt;tools/release.sh stage&lt;/code&gt; to create an @c archives
+	directory with the release data, including MD5 and SHA1
+	checksum files (which are used with Berlios).
+  -# Sanity check at least one of those archives, by extracting and
+     configuring its contents, using them to build a copy of OpenOCD,
+     and verifying that the result prints the correct release version
+     in its startup banner.  (For example,
+     &quot;configure --enable-ft2232_libftdi --enable-parport&quot;
+     then &quot;make&quot; and run &quot;src/openocd -v&quot; as a sanity check.)
+  -# Run &lt;code&gt;make docs&lt;/code&gt; to create the
+     documentation which will be published.
 -# Upload packages and post announcements of their availability:
   -# Release packages into files section of project sites:
     - SF.net:
-     -# Create a new folder named &quot;${PACKAGE_VERSION}&quot;
-     -# Select new folder as the target for uploads.
-     -# Upload files via Web interface into new
-     -# Set platform types for each archive:
+     -# Under &quot;Project Admin&quot;, use the &quot;File Manager&quot;
+     -# Create a new folder under &quot;openocd&quot; named &quot;${PACKAGE_VERSION}&quot;
+     -# Upload the @c NEWS file and mark it as the release notes.
+     -# Upload the three source archive files, using the Web interface,
+     	into that folder.  Verify the upload worked OK by checking the
+	MD5 and SHA1 checksums computed by SourceForge against the
+	versions created as part of staging the release.
+     -# Also upload doc/openocd.pdf (the User's Guide) so the version
+        matching each release will be easily available.
+     -# Select each file in the release, and use the property panel
+        to set its type and select the right release notes.
        - .tar.bz2: Linux, Mac
        - .tar.gz: BSD, Solaris, Others
        - .zip: Windows
+       - For openocd.pdf just associate it with the right release notes.
+     -# Create an SF.net project news update.
     - Berlios:
-     -# Create the new release for the new version.
      -# Provide @c NEWS file, as requested.
-     -# Upload files via FTP to <A HREF="ftp://ftp.berlios.de/incoming/">ftp://ftp.berlios.de/incoming/</A>
-     -# Edit descriptions for each file.
+     -# Upload the release files via FTP to <A HREF="ftp://ftp.berlios.de/incoming/">ftp://ftp.berlios.de/incoming/</A>
+     -# Edit descriptions for each file (one at a time)  Note that Berlios
+	does not automatically checksum files, and it uses a very old
+	version of the SourceForge code with user interface issues.
      -# Click button to send E-mail Release Notice.
+  -# Depending on how paranoid you're feeling today, verify the images by
+     downloading them from the websites and making sure there are no
+     differences between the downloaded copies and your originals.
+  -# Publish User's and Developer's Guides to the project web sites:
+     -# Use SCP to update the SF.net web site with PDF and HTML for the
+          User's Guide, and HTML for the developer's guide ... you can
+	  instantiate a shell.sourceforge.net instance and set up symlinks
+	  from your home directory, to simplify this process.
+     -# (How to update the Berlios web site with the same data?)
   -# Post announcement e-mail to the openocd-development list.
-  -# Announce updates on freshmeat.net and other trackers.
-  -# Submit big updates to news feeds (e.g. Digg, Reddit, etc.).
+  -# optionally:
+     -# Post an update on the Berlios blog (if it lets you)
+     -# Announce updates on freshmeat.net and other trackers.
+     -# Submit updates to news feeds (e.g. Digg, Reddit, etc.).
+-# Resume normal development on mainline, by opening the merge window for
+  the next major or minor release cycle.  (You might want to do this
+  before all the release bits are fully published.)
+  - Update the version label in the @c configure.in file:
+     - Restore @c -dev version tag.
+     - For a new minor release cycle, increment the release's minor number
+     - For a new major release cycle, increment the release's major number
+       and zero its minor number
+  - Archive @c NEWS file as &quot;&lt;code&gt;doc/news/NEWS-${PACKAGE_VERSION}&lt;/code&gt;&quot;.
+  - Create a new @c NEWS file for the next release
+  - Commit those changes.
+  - Push all the updates to mainline.
+     - Last updates for the release, including the release tag (you
+       will need to &quot;git push --tags&quot;).
+     - Updates opening the merge window
+  - At this point, it's OK for commiters to start pushing changes
+    which have been held off until the next release.  (Any bugfixes to
+    this release will be against a bug-fix release branch starting from
+    the commit you tagged as this release, not mainline.)
+  - Announce to the openocd-development list.  Ideally, you will also
+    be able to say who is managing the next release cycle.
 
 To start a bug-fix release branch:
 -# Create a new branch, starting from a major or

commit c8ea748dc22660dad934537384d35903dfcc492e
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:58:16 2010 -0800

    ADIv5: relocate memacess_tck cycles
    
    When using an AP to access a memory (or a memory-mapped register),
    some extra TCK (assuming JTAG) cycles should be added to ensure
    the AP has enugh time to complete that access before trying to
    collect the response.
    
    The previous code was adding these cycles *before* trying to
    access (read or write) data to that address, not *after*.  Fix
    by putting the delays in the right location.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 819dd29..d30dd50 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -119,18 +119,6 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, instr, NULL);
 
-	/* Add specified number of tck clocks before accessing memory bus */
-
-	/* REVISIT these TCK cycles should be *AFTER*  updating APACC, since
-	 * they provide more time for the (MEM) AP to complete the read ...
-	 * See &quot;Minimum Response Time&quot; for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&amp;&amp; ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
-			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
-		jtag_add_runtest(swjdp-&gt;memaccess_tck, jtag_set_end_state(TAP_IDLE));
-
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
 	 */
@@ -152,6 +140,18 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
 
 	jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
+	/* Add specified number of tck clocks after starting memory bus
+	 * access, giving the hardware time to complete the access.
+	 * They provide more time for the (MEM) AP to complete the read ...
+	 * See &quot;Minimum Response Time&quot; for JTAG-DP, in the ADIv5 spec.
+	 */
+	if ((instr == JTAG_DP_APACC)
+			&amp;&amp; ((reg_addr == AP_REG_DRW)
+				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
+			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
+		jtag_add_runtest(swjdp-&gt;memaccess_tck,
+				jtag_set_end_state(TAP_IDLE));
+
 	return jtag_get_error();
 }
 

commit 3b68a708c2b039d9b091608eccb2206725742a47
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:56:56 2010 -0800

    ADIv5: remove ATOMIC/COMPOSITE interface mode
    
    This removes context-sensitivity from the programming interface and makes
    it possible to know what a block of code does without needing to know the
    previous history (specifically, the DAP's &quot;trans_mode&quot; setting).
    
    The mode was only set to ATOMIC briefly after DAP initialization, making
    this patch be primarily cleanup; almost everything depends on COMPOSITE.
    The transactions which shouldn't have been queued were already properly
    flushing the queue.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 66b947e..819dd29 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -43,11 +43,16 @@
  * is used to access memory mapped resources and is called a MEM-AP.  Also a
  * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
  *
- * @todo Remove modality (queued/nonqueued, via DAP trans_mode) from all
- * procedure interfaces.  Modal programming interfaces are very error prone.
- * Procedures should be either queued, or synchronous.  Otherwise input
- * and output constraints are context-sensitive, and it's hard to know
- * what a block of code will do just by reading it.
+ * This programming interface allows DAP pipelined operations through a
+ * transaction queue.  This primarily affects AP operations (such as using
+ * a MEM-AP to access memory or registers).  If the current transaction has
+ * not finished by the time the next one must begin, and the ORUNDETECT bit
+ * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
+ * further AP operations will fail.  There are two basic methods to avoid
+ * such overrun errors.  One involves polling for status instead of using
+ * transaction piplining.  The other involves adding delays to ensure the
+ * AP has enough time to complete one operation before starting the next
+ * one.  (For JTAG these delays are controlled by memaccess_tck.)
  */
 
 /*
@@ -67,17 +72,6 @@
 #include &quot;arm_adi_v5.h&quot;
 #include &lt;helper/time_support.h&gt;
 
-/*
- * Transaction Mode:
- * swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
- * Uses Overrun checking mode and does not do actual JTAG send/receive or transaction
- * result checking until swjdp_end_transaction()
- * This must be done before using or deallocating any return variables.
- * swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC
- * All reads and writes to the AHB bus are checked for valid completion, and return values
- * are immediatley available.
-*/
-
 
 /* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
 
@@ -191,47 +185,32 @@ static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 /**
  * Utility to write AP registers.
  */
-static int ap_write_check(struct swjdp_common *dap,
+static inline int ap_write_check(struct swjdp_common *dap,
 		uint8_t reg_addr, uint8_t *outvalue)
 {
-	adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
+	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
 			outvalue, NULL, NULL);
-
-	/* REVISIT except in dap_setup_accessport() almost all call paths
-	 * set up COMPOSITE.  Probably worth just inlining the scan...
-	 */
-
-	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
-	 * ack = OK/FAULT and the check CTRL_STAT
-	 */
-	if (dap-&gt;trans_mode == TRANS_MODE_ATOMIC)
-		return jtagdp_transaction_endcheck(dap);
-
-	return ERROR_OK;
 }
 
 static int scan_inout_check_u32(struct swjdp_common *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue)
 {
+	int retval;
+
 	/* Issue the read or write */
-	adi_jtag_dp_scan_u32(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
+	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
+			RnW, outvalue, NULL, NULL);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* For reads,  collect posted value; RDBUFF has no other effect.
 	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says &quot;OK&quot;.
 	 */
 	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-		adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
+		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
 				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
-
-	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
-	 * ack = OK/FAULT and then check CTRL_STAT
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
-		return jtagdp_transaction_endcheck(swjdp);
-
-	return ERROR_OK;
+	return retval;
 }
 
 int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
@@ -437,17 +416,13 @@ static int dap_ap_write_reg(struct swjdp_common *swjdp,
 }
 
 /**
- * Write an AP register value.
- * This is synchronous iff the mode is set to ATOMIC, in which
- * case any queued transactions are flushed.
+ * Asynchronous (queued) AP register write.
  *
  * @param swjdp The DAP whose currently selected AP will be written.
  * @param reg_addr Eight bit AP register address.
  * @param value Word to be written at reg_addr
  *
- * @return In synchronous mode: ERROR_OK for success, and the register holds
- * the specified value; else a fault code.  In asynchronous mode, a status
- * code reflecting whether the transaction was properly queued.
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
 int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t value)
@@ -460,17 +435,13 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 }
 
 /**
- * Read an AP register value.
- * This is synchronous iff the mode is set to ATOMIC, in which
- * case any queued transactions are flushed.
+ * Asynchronous (queued) AP register eread.
  *
  * @param swjdp The DAP whose currently selected AP will be read.
  * @param reg_addr Eight bit AP register address.
  * @param value Points to where the 32-bit (little-endian) word will be stored.
  *
- * @return In synchronous mode: ERROR_OK for success, and *value holds
- * the specified value; else a fault code.  In asynchronous mode, a status
- * code reflecting whether the transaction was properly queued.
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t *value)
@@ -486,9 +457,8 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 }
 
 /**
- * Set up transfer parameters for the currently selected MEM-AP.
- * This is synchronous iff the mode is set to ATOMIC, in which
- * case any queued transactions are flushed.
+ * Queue transactions setting up transfer parameters for the
+ * currently selected MEM-AP.
  *
  * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
  * initiate data reads or writes using memory or peripheral addresses.
@@ -503,9 +473,7 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
  * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
  *	matches the cached address, the register is not changed.
  *
- * @return In synchronous mode: ERROR_OK for success, and the AP is set
- * up as requested else a fault code.  In asynchronous mode, a status
- * code reflecting whether the transaction was properly queued.
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
 int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 {
@@ -550,8 +518,6 @@ int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
 {
 	int retval;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
@@ -603,8 +569,6 @@ int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
 {
 	int retval;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
@@ -652,8 +616,6 @@ int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	uint32_t adr = address;
 	uint8_t* pBuffer = buffer;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	count &gt;&gt;= 2;
 	wcount = count;
 
@@ -721,8 +683,6 @@ static int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count &gt;&gt; 1;
 
 	while (wcount &gt; 0)
@@ -799,8 +759,6 @@ int mem_ap_write_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	if (count &gt;= 4)
 		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count &gt; 0)
 	{
 		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
@@ -823,8 +781,6 @@ static int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count;
 
 	while (wcount &gt; 0)
@@ -896,8 +852,6 @@ int mem_ap_write_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	if (count &gt;= 4)
 		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count &gt; 0)
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
@@ -925,8 +879,6 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	uint32_t adr = address;
 	uint8_t* pBuffer = buffer;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	count &gt;&gt;= 2;
 	wcount = count;
 
@@ -1009,8 +961,6 @@ static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count &gt;&gt; 1;
 
 	while (wcount &gt; 0)
@@ -1063,8 +1013,6 @@ int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	if (count &gt;= 4)
 		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count &gt; 0)
 	{
 		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
@@ -1105,8 +1053,6 @@ static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count;
 
 	while (wcount &gt; 0)
@@ -1156,8 +1102,6 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, u
 	if (count &gt;= 4)
 		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count &gt; 0)
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
@@ -1203,7 +1147,6 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	dap_ap_select(swjdp, 0);
 
 	/* DP initialization */
-	swjdp-&gt;trans_mode = TRANS_MODE_ATOMIC;
 	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
 	dap_dp_write_reg(swjdp, SSTICKYERR, DP_CTRL_STAT);
 	dap_dp_read_reg(swjdp, &amp;dummy, DP_CTRL_STAT);
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 746f1cb..316701e 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -118,13 +118,6 @@
 #define CSW_MASTER_DEBUG	(1 &lt;&lt; 29)		/* ? */
 #define CSW_DBGSWENABLE		(1 &lt;&lt; 31)
 
-/* transaction mode */
-#define TRANS_MODE_NONE			0
-/* Transaction waits for previous to complete */
-#define TRANS_MODE_ATOMIC		1
-/* Freerunning transactions with delays and overrun checking */
-#define TRANS_MODE_COMPOSITE	2
-
 /**
  * This represents an ARM Debug Interface (v5) Debug Access Port (DAP).
  * A DAP has two types of component:  one Debug Port (DP), which is a
@@ -170,9 +163,8 @@ struct swjdp_common
 	uint32_t ap_tar_value;
 
 	/* information about current pending SWjDP-AHBAP transaction */
-	uint8_t  trans_mode;
-	uint8_t  trans_rw;
 	uint8_t  ack;
+
 	/**
 	 * Configures how many extra tck clocks are added after starting a
 	 * MEM-AP access before we try to read its status (and/or result).
@@ -192,7 +184,7 @@ static inline uint8_t dap_ap_get_select(struct swjdp_common *swjdp)
 /* AP selection applies to future AP transactions */
 void dap_ap_select(struct swjdp_common *dap,uint8_t apsel);
 
-/* AP transactions ... synchronous given TRANS_MODE_ATOMIC */
+/* Queued AP transactions */
 int dap_setup_accessport(struct swjdp_common *swjdp,
 		uint32_t csw, uint32_t tar);
 int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 3dd9468..3ebc34a 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -70,8 +70,6 @@ static int cortexm3_dap_read_coreregister_u32(struct swjdp_common *swjdp,
 
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, regnum); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
 	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRSR &amp; 0xC), regnum);
@@ -101,8 +99,6 @@ static int cortexm3_dap_write_coreregister_u32(struct swjdp_common *swjdp,
 
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
 
-	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* mem_ap_write_u32(swjdp, DCB_DCRDR, core_regs[i]); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
 	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRDR &amp; 0xC), value);

commit ecff73043c1ddcc97d4d1ea1c87f251a850b22d4
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:54:54 2010 -0800

    ARM: ADIv5, deadcode cleanup
    
    I have no idea what the scan_inout_check() was *expecting* to achieve by
    issuing a read of the DP_RDBUFF register.  But in any case, that code was
    clearly never being called (&quot;invalue&quot; always NULL) ... so remove it, and
    the associated comment.
    
    Also rename it as ap_write_check(), facilitating a cleanup of its single
    call site by removing constant parameters.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index d7afb58..66b947e 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -188,23 +188,24 @@ static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 	return retval;
 }
 
-/* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */
-static int scan_inout_check(struct swjdp_common *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue)
+/**
+ * Utility to write AP registers.
+ */
+static int ap_write_check(struct swjdp_common *dap,
+		uint8_t reg_addr, uint8_t *outvalue)
 {
-	adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
+	adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
+			outvalue, NULL, NULL);
 
-	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
+	/* REVISIT except in dap_setup_accessport() almost all call paths
+	 * set up COMPOSITE.  Probably worth just inlining the scan...
+	 */
 
 	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
 	 * ack = OK/FAULT and the check CTRL_STAT
 	 */
-	if ((instr == JTAG_DP_APACC)
-			&amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
-		return jtagdp_transaction_endcheck(swjdp);
+	if (dap-&gt;trans_mode == TRANS_MODE_ATOMIC)
+		return jtagdp_transaction_endcheck(dap);
 
 	return ERROR_OK;
 }
@@ -432,8 +433,7 @@ static int dap_ap_write_reg(struct swjdp_common *swjdp,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_WRITE, out_value_buf, NULL);
+	return ap_write_check(swjdp, reg_addr, out_value_buf);
 }
 
 /**

commit 39cfe6279616a69b858ddd3493d61ed7133ff081
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:53:15 2010 -0800

    ARM: ADIv5 code shrinkage, cleanup
    
    adi_jtag_dp_scan_u32() now wraps adi_jtag_dp_scan(), removing
    code duplication.  Include doxygen for the former.  Comment
    some particularly relevant points.  Minor fault handling fixes
    for both routines:  don't register a callback that can't run,
    or return ERROR_OK after an error.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 1eff335..d7afb58 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -158,58 +158,34 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
 
 	jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
-	return ERROR_OK;
+	return jtag_get_error();
 }
 
-/* Scan out and in from host ordered uint32_t variables */
+/**
+ * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
+ * This is exactly like adi_jtag_dp_scan(), except that endianness
+ * conversions are performed (so the types of invalue and outvalue
+ * must be different).
+ */
 static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
 {
-	struct arm_jtag *jtag_info = swjdp-&gt;jtag_info;
-	struct scan_field fields[2];
 	uint8_t out_value_buf[4];
-	uint8_t out_addr_buf;
-
-	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	/* Add specified number of tck clocks before accessing memory bus */
-
-	/* REVISIT these TCK cycles should be *AFTER*  updating APACC, since
-	 * they provide more time for the (MEM) AP to complete the read ...
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&amp;&amp; ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr &amp; 0xF0) == AP_REG_BD0))
-			&amp;&amp; (swjdp-&gt;memaccess_tck != 0))
-		jtag_add_runtest(swjdp-&gt;memaccess_tck, jtag_set_end_state(TAP_IDLE));
-
-	fields[0].tap = jtag_info-&gt;tap;
-	fields[0].num_bits = 3;
-	buf_set_u32(&amp;out_addr_buf, 0, 3, ((reg_addr &gt;&gt; 1) &amp; 0x6) | (RnW &amp; 0x1));
-	fields[0].out_value = &amp;out_addr_buf;
-	fields[0].in_value = ack;
+	int retval;
 
-	fields[1].tap = jtag_info-&gt;tap;
-	fields[1].num_bits = 32;
 	buf_set_u32(out_value_buf, 0, 32, outvalue);
-	fields[1].out_value = out_value_buf;
-	fields[1].in_value = NULL;
-
-	if (invalue)
-	{
-		fields[1].in_value = (uint8_t *)invalue;
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
-		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t) invalue);
-	} else
-	{
+	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
+			out_value_buf, (uint8_t *)invalue, ack);
+	if (retval != ERROR_OK)
+		return retval;
 
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
-	}
+	if (invalue)
+		jtag_add_callback(arm_le_to_h_u32,
+				(jtag_callback_data_t) invalue);
 
-	return ERROR_OK;
+	return retval;
 }
 
 /* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */

commit a97bb67543eacde38f093610982812f714e7a050
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:51:19 2010 -0800

    ADIv5 clean up AP fault handling
    
    Pass up fault codes from various routines, so their callers
    can clean up after failures, and remove the FIXME comments
    highlighting those previously goofy code paths.
    
     dap_ap_{read,write}_reg_u32()
     dap_ap_write_reg()
     mem_ap_{read,write}_u32()
     mem_ap_{read,write}_atomic_u32()
     dap_setup_accessport()
    
    Make dap_ap_write_reg_u32() just wrap dap_ap_write_reg(),
    instead of cloning its core code (and broken fault handling).
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 2e3dafb..1eff335 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -450,12 +450,14 @@ static int dap_ap_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 static int dap_ap_write_reg(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint8_t *out_value_buf)
 {
-	dap_ap_bankselect(swjdp, reg_addr);
-	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_WRITE, out_value_buf, NULL);
+	int retval;
 
-	/* FIXME return fault code from above calls */
-	return ERROR_OK;
+	retval = dap_ap_bankselect(swjdp, reg_addr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
+			DPAP_WRITE, out_value_buf, NULL);
 }
 
 /**
@@ -477,12 +479,8 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 	uint8_t out_value_buf[4];
 
 	buf_set_u32(out_value_buf, 0, 32, value);
-	dap_ap_bankselect(swjdp, reg_addr);
-	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_WRITE, out_value_buf, NULL);
-
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	return dap_ap_write_reg(swjdp,
+			reg_addr, out_value_buf);
 }
 
 /**
@@ -501,12 +499,14 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t *value)
 {
-	dap_ap_bankselect(swjdp, reg_addr);
-	scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_READ, 0, value);
+	int retval;
 
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	retval = dap_ap_bankselect(swjdp, reg_addr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
+			DPAP_READ, 0, value);
 }
 
 /**
@@ -533,19 +533,23 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
  */
 int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 {
+	int retval;
+
 	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
 	if (csw != swjdp-&gt;ap_csw_value)
 	{
 		/* LOG_DEBUG(&quot;DAP: Set CSW %x&quot;,csw); */
-		/* FIXME if this call fails, fail this procedure! */
-		dap_ap_write_reg_u32(swjdp, AP_REG_CSW, csw);
+		retval = dap_ap_write_reg_u32(swjdp, AP_REG_CSW, csw);
+		if (retval != ERROR_OK)
+			return retval;
 		swjdp-&gt;ap_csw_value = csw;
 	}
 	if (tar != swjdp-&gt;ap_tar_value)
 	{
 		/* LOG_DEBUG(&quot;DAP: Set TAR %x&quot;,tar); */
-		/* FIXME if this call fails, fail this procedure! */
-		dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar);
+		retval = dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar);
+		if (retval != ERROR_OK)
+			return retval;
 		swjdp-&gt;ap_tar_value = tar;
 	}
 	/* Disable TAR cache when autoincrementing */
@@ -568,17 +572,19 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t *value)
 {
+	int retval;
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
 
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
 			address &amp; 0xFFFFFFF0);
-	dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (address &amp; 0xC), value);
+	if (retval != ERROR_OK)
+		return retval;
 
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	return dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (address &amp; 0xC), value);
 }
 
 /**
@@ -596,8 +602,11 @@ int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
 int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t *value)
 {
-	mem_ap_read_u32(swjdp, address, value);
-	/* FIXME return any fault code from above call */
+	int retval;
+
+	retval = mem_ap_read_u32(swjdp, address, value);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return jtagdp_transaction_endcheck(swjdp);
 }
@@ -616,17 +625,20 @@ int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t value)
 {
+	int retval;
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
 
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
 			address &amp; 0xFFFFFFF0);
-	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (address &amp; 0xC), value);
+	if (retval != ERROR_OK)
+		return retval;
 
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	return dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (address &amp; 0xC),
+			value);
 }
 
 /**
@@ -643,8 +655,10 @@ int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
 int mem_ap_write_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t value)
 {
-	mem_ap_write_u32(swjdp, address, value);
-	/* FIXME return any fault code from above call */
+	int retval = mem_ap_write_u32(swjdp, address, value);
+
+	if (retval != ERROR_OK)
+		return retval;
 
 	return jtagdp_transaction_endcheck(swjdp);
 }

commit 249263d29da11b0ec981c2e0d520cd7dcf08939b
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:48:04 2010 -0800

    ADIv5 clean up AP selection and register caching
    
    Handling of AP (and AP register bank) selection, and cached AP
    registers, is pretty loose ... start tightening it:
    
     - It's &quot;AP bank&quot; select support ... there are no DP banks.  Rename.
       + dap_dp_bankselect() becomes dap_ap_bankselect()
       + &quot;dp_select_value&quot; struct field becomes &quot;ap_bank_value&quot;
    
     - Remove duplicate AP cache init paths ... only use dap_ap_select(),
     and don't make Cortex (A8 or M3) cores roll their own code.
    
     - For dap_ap_bankselect(), pass up any fault code from writing
     the SELECT register.  (Nothing yet checks those codes.)
    
     - Add various bits of Doxygen
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 94c8ed8..2e3dafb 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -349,7 +349,7 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 					&quot;ap_bank 0x%&quot; PRIx32
 					&quot;, ap_csw 0x%&quot; PRIx32
 					&quot;, ap_tar 0x%&quot; PRIx32,
-					swjdp-&gt;dp_select_value,
+					swjdp-&gt;ap_bank_value,
 					swjdp-&gt;ap_csw_value,
 					swjdp-&gt;ap_tar_value);
 
@@ -419,38 +419,38 @@ static int dap_dp_read_reg(struct swjdp_common *swjdp,
  */
 void dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
 {
-	uint32_t select;
-	select = (apsel &lt;&lt; 24) &amp; 0xFF000000;
+	uint32_t select = (apsel &lt;&lt; 24) &amp; 0xFF000000;
 
 	if (select != swjdp-&gt;apsel)
 	{
 		swjdp-&gt;apsel = select;
-		/* Switching AP invalidates cached values */
-		swjdp-&gt;dp_select_value = -1;
+		/* Switching AP invalidates cached values.
+		 * Values MUST BE UPDATED BEFORE AP ACCESS.
+		 */
+		swjdp-&gt;ap_bank_value = -1;
 		swjdp-&gt;ap_csw_value = -1;
 		swjdp-&gt;ap_tar_value = -1;
 	}
 }
 
-static int dap_dp_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
+/** Select the AP register bank matching bits 7:4 of ap_reg. */
+static int dap_ap_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 {
-	uint32_t select;
-	select = (ap_reg &amp; 0x000000F0);
+	uint32_t select = (ap_reg &amp; 0x000000F0);
 
-	if (select != swjdp-&gt;dp_select_value)
+	if (select != swjdp-&gt;ap_bank_value)
 	{
-		dap_dp_write_reg(swjdp, select | swjdp-&gt;apsel, DP_SELECT);
-		swjdp-&gt;dp_select_value = select;
-	}
-
-	/* FIXME return any fault code from write() call */
-	return ERROR_OK;
+		swjdp-&gt;ap_bank_value = select;
+		select |= swjdp-&gt;apsel;
+		return dap_dp_write_reg(swjdp, select, DP_SELECT);
+	} else
+		return ERROR_OK;
 }
 
 static int dap_ap_write_reg(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint8_t *out_value_buf)
 {
-	dap_dp_bankselect(swjdp, reg_addr);
+	dap_ap_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_WRITE, out_value_buf, NULL);
 
@@ -477,7 +477,7 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 	uint8_t out_value_buf[4];
 
 	buf_set_u32(out_value_buf, 0, 32, value);
-	dap_dp_bankselect(swjdp, reg_addr);
+	dap_ap_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_WRITE, out_value_buf, NULL);
 
@@ -501,7 +501,7 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t *value)
 {
-	dap_dp_bankselect(swjdp, reg_addr);
+	dap_ap_bankselect(swjdp, reg_addr);
 	scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_READ, 0, value);
 
@@ -1206,12 +1206,11 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	/* Default MEM-AP setup.
 	 *
 	 * REVISIT AP #0 may be an inappropriate default for this.
-	 * Should we probe, or receve a hint from the caller?
+	 * Should we probe, or take a hint from the caller?
 	 * Presumably we can ignore the possibility of multiple APs.
 	 */
-	swjdp-&gt;apsel = 0;
-	swjdp-&gt;ap_csw_value = -1;
-	swjdp-&gt;ap_tar_value = -1;
+	swjdp-&gt;apsel = !0;
+	dap_ap_select(swjdp, 0);
 
 	/* DP initialization */
 	swjdp-&gt;trans_mode = TRANS_MODE_ATOMIC;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 759f233..746f1cb 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -138,17 +138,45 @@ struct swjdp_common
 	struct arm_jtag *jtag_info;
 	/* Control config */
 	uint32_t dp_ctrl_stat;
-	/* Support for several AP's in one DAP */
+
+	/**
+	 * Cache for DP_SELECT bits identifying the current AP.  A DAP may
+	 * connect to multiple APs, such as one MEM-AP for general access,
+	 * another reserved for accessing debug modules, and a JTAG-DP.
+	 * &quot;-1&quot; indicates no cached value.
+	 */
 	uint32_t apsel;
-	/* Register select cache */
-	uint32_t dp_select_value;
+
+	/**
+	 * Cache for DP_SELECT bits identifying the current four-word AP
+	 * register bank.  This caches AP register addresss bits 7:4; JTAG
+	 * and SWD access primitves pass address bits 3:2; bits 1:0 are zero.
+	 * &quot;-1&quot; indicates no cached value.
+	 */
+	uint32_t ap_bank_value;
+
+	/**
+	 * Cache for (MEM-AP) AP_REG_CSW register value.  This is written to
+	 * configure an access mode, such as autoincrementing AP_REG_TAR during
+	 * word access.  &quot;-1&quot; indicates no cached value.
+	 */
 	uint32_t ap_csw_value;
+
+	/**
+	 * Cache for (MEM-AP) AP_REG_TAR register value This is written to
+	 * configure the address being read or written
+	 * &quot;-1&quot; indicates no cached value.
+	 */
 	uint32_t ap_tar_value;
+
 	/* information about current pending SWjDP-AHBAP transaction */
 	uint8_t  trans_mode;
 	uint8_t  trans_rw;
 	uint8_t  ack;
-	/* extra tck clocks for memory bus access */
+	/**
+	 * Configures how many extra tck clocks are added after starting a
+	 * MEM-AP access before we try to read its status (and/or result).
+	 */
 	uint32_t	memaccess_tck;
 	/* Size of TAR autoincrement block, ARM ADI Specification requires at least 10 bits */
 	uint32_t tar_autoincr_block;
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 050238c..f4818f8 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -53,7 +53,9 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 		uint32_t value, int regnum);
 /*
  * FIXME do topology discovery using the ROM; don't
- * assume this is an OMAP3.
+ * assume this is an OMAP3.   Also, allow for multiple ARMv7-A
+ * cores, with different AP numbering ... don't use a #define
+ * for these numbers, use per-core armv7a state.
  */
 #define swjdp_memoryap 0
 #define swjdp_debugap 1
@@ -1570,9 +1572,7 @@ static int cortex_a8_init_arch_info(struct target *target,
 	cortex_a8-&gt;jtag_info.tap = tap;
 	cortex_a8-&gt;jtag_info.scann_size = 4;
 
-	swjdp-&gt;dp_select_value = -1;
-	swjdp-&gt;ap_csw_value = -1;
-	swjdp-&gt;ap_tar_value = -1;
+	/* Leave (only) generic DAP stuff for debugport_init() */
 	swjdp-&gt;jtag_info = &amp;cortex_a8-&gt;jtag_info;
 	swjdp-&gt;memaccess_tck = 80;
 
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index a3b3d42..3dd9468 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -1848,12 +1848,11 @@ static int cortex_m3_init_arch_info(struct target *target,
 	cortex_m3-&gt;jtag_info.tap = tap;
 	cortex_m3-&gt;jtag_info.scann_size = 4;
 
-	armv7m-&gt;swjdp_info.dp_select_value = -1;
-	armv7m-&gt;swjdp_info.ap_csw_value = -1;
-	armv7m-&gt;swjdp_info.ap_tar_value = -1;
+	/* Leave (only) generic DAP stuff for debugport_init(); */
 	armv7m-&gt;swjdp_info.jtag_info = &amp;cortex_m3-&gt;jtag_info;
 	armv7m-&gt;swjdp_info.memaccess_tck = 8;
-	armv7m-&gt;swjdp_info.tar_autoincr_block = (1 &lt;&lt; 12);	/* Cortex-M3 has 4096 bytes autoincrement range */
+	/* Cortex-M3 has 4096 bytes autoincrement range */
+	armv7m-&gt;swjdp_info.tar_autoincr_block = (1 &lt;&lt; 12);
 
 	/* register arch-specific functions */
 	armv7m-&gt;examine_debug_reason = cortex_m3_examine_debug_reason;

commit 1aac72d24339380f6e98c50dec4c96ab30537749
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:34:33 2010 -0800

    ARM: keep a handle to the PC
    
    Keep a handle to the PC in &quot;struct arm&quot;, and use it.
    This register is used a fair amount, so this is a net
    minor code shrink (other than some line length fixes),
    but mostly it's to make things more readable.
    
    For XScale, fix a dodgy sequence while stepping.  It
    was initializing a variable to a non-NULL value, then
    updating it to handle the step-over-active-breakpoint
    case, and then later testing for non-NULL to see if
    it should reverse that step-over-active logic.  It
    should have done like ARM7/ARM9 does: init to NULL.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm.h b/src/target/arm.h
index c72b194..6b304e9 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -95,6 +95,9 @@ struct arm {
 	int common_magic;
 	struct reg_cache *core_cache;
 
+	/** Handle to the PC; valid in all core modes. */
+	struct reg *pc;
+
 	/** Handle to the CPSR; valid in all core modes. */
 	struct reg *cpsr;
 
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 678d8ac..51be701 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -451,7 +451,7 @@ static int arm11_halt(struct target *target)
 static uint32_t
 arm11_nextpc(struct arm11_common *arm11, int current, uint32_t address)
 {
-	void *value = arm11-&gt;arm.core_cache-&gt;reg_list[15].value;
+	void *value = arm11-&gt;arm.pc-&gt;value;
 
 	if (!current)
 		buf_set_u32(value, 0, 32, address);
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index efafa5e..2275935 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -361,9 +361,9 @@ static int arm720t_soft_reset_halt(struct target *target)
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, 0x0);
+	armv4_5-&gt;pc-&gt;dirty = 1;
+	armv4_5-&gt;pc-&gt;valid = 1;
 
 	arm720t_disable_mmu_caches(target, 1, 1, 1);
 	arm720t-&gt;armv4_5_mmu.mmu_enabled = 0;
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 509e91e..2176729 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1235,9 +1235,9 @@ int arm7_9_soft_reset_halt(struct target *target)
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, 0x0);
+	armv4_5-&gt;pc-&gt;dirty = 1;
+	armv4_5-&gt;pc-&gt;valid = 1;
 
 	/* reset registers */
 	for (i = 0; i &lt;= 14; i++)
@@ -1721,9 +1721,10 @@ int arm7_9_restore_context(struct target *target)
 	}
 
 	/* restore PC */
-	LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
-	arm7_9-&gt;write_pc(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 0;
+	LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32,
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+	arm7_9-&gt;write_pc(target, buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+	armv4_5-&gt;pc-&gt;dirty = 0;
 
 	if (arm7_9-&gt;post_restore_context)
 		arm7_9-&gt;post_restore_context(target);
@@ -1815,15 +1816,17 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
 	if (!current)
-		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, address);
 
 	uint32_t current_pc;
-	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
 	{
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))))
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+		if (breakpoint != NULL)
 		{
 			LOG_DEBUG(&quot;unset breakpoint at 0x%8.8&quot; PRIx32 &quot; (id: %d)&quot;, breakpoint-&gt;address, breakpoint-&gt;unique_id );
 			if ((retval = arm7_9_unset_breakpoint(target, breakpoint)) != ERROR_OK)
@@ -1881,7 +1884,8 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 			}
 
 			arm7_9_debug_entry(target);
-			LOG_DEBUG(&quot;new PC after step: 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
+			LOG_DEBUG(&quot;new PC after step: 0x%8.8&quot; PRIx32,
+					buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
 
 			LOG_DEBUG(&quot;set breakpoint at 0x%8.8&quot; PRIx32 &quot;&quot;, breakpoint-&gt;address);
 			if ((retval = arm7_9_set_breakpoint(target, breakpoint)) != ERROR_OK)
@@ -1957,7 +1961,7 @@ void arm7_9_enable_eice_step(struct target *target, uint32_t next_pc)
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm *armv4_5 = &amp;arm7_9-&gt;armv4_5_common;
 	uint32_t current_pc;
-	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	if (next_pc != current_pc)
 	{
@@ -2019,18 +2023,18 @@ int arm7_9_step(struct target *target, int current, uint32_t address, int handle
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
 	if (!current)
-		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, address);
 
-	uint32_t current_pc;
-	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	uint32_t current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))))
-			if ((retval = arm7_9_unset_breakpoint(target, breakpoint)) != ERROR_OK)
-			{
-				return retval;
-			}
+		breakpoint = breakpoint_find(target, current_pc);
+	if (breakpoint != NULL) {
+		retval = arm7_9_unset_breakpoint(target, breakpoint);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	target-&gt;debug_reason = DBG_REASON_SINGLESTEP;
 
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 16f16b0..530a675 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -598,7 +598,8 @@ static void arm7tdmi_branch_resume_thumb(struct target *target)
 	/* fetch NOP, LDM in EXECUTE stage (1st cycle) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (2nd cycle) */
-	arm7tdmi_clock_out(jtag_info, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32) | 1, NULL, 0);
+	arm7tdmi_clock_out(jtag_info,
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32) | 1, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (3rd cycle) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 3e61545..152edcf 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -777,9 +777,9 @@ int arm920t_soft_reset_halt(struct target *target)
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, 0x0);
+	armv4_5-&gt;pc-&gt;dirty = 1;
+	armv4_5-&gt;pc-&gt;valid = 1;
 
 	arm920t_disable_mmu_caches(target, 1, 1, 1);
 	arm920t-&gt;armv4_5_mmu.mmu_enabled = 0;
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 32ecf72..d811196 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -569,9 +569,9 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, 0x0);
+	armv4_5-&gt;pc-&gt;dirty = 1;
+	armv4_5-&gt;pc-&gt;valid = 1;
 
 	arm926ejs_disable_mmu_caches(target, 1, 1, 1);
 	arm926ejs-&gt;armv4_5_mmu.mmu_enabled = 0;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 761e7cf..77b01b1 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -677,7 +677,8 @@ static void arm9tdmi_branch_resume_thumb(struct target *target)
 	/* fetch NOP, LDM in EXECUTE stage (1st cycle) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (2nd cycle) */
-	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32) | 1, NULL, 0);
+	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP,
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32) | 1, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (3rd cycle) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 0b5e255..8e8cc17 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -453,8 +453,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	retval = dpm_modeswitch(dpm, ARM_MODE_ANY);
 	arm-&gt;cpsr-&gt;dirty = false;
 
-	retval = dpm_write_reg(dpm, &amp;cache-&gt;reg_list[15], 15);
-	cache-&gt;reg_list[15].dirty = false;
+	retval = dpm_write_reg(dpm, arm-&gt;pc, 15);
+	arm-&gt;pc-&gt;dirty = false;
 
 	/* flush R0 -- it's *very* dirty by now */
 	retval = dpm_write_reg(dpm, &amp;cache-&gt;reg_list[0], 0);
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 9b853d9..24a4de5 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -393,8 +393,8 @@ static int do_semihosting(struct target *target)
 	armv4_5-&gt;core_cache-&gt;reg_list[0].dirty = 1;
 
 	/* LR --&gt; PC */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, lr);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, lr);
+	armv4_5-&gt;pc-&gt;dirty = 1;
 
 	/* saved PSR --&gt; current PSR */
 	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32, spsr);
@@ -429,7 +429,7 @@ int arm_semihosting(struct target *target, int *retval)
 		return 0;
 
 	/* Check for PC == 0x00000008 or 0xffff0008: Supervisor Call vector. */
-	r = arm-&gt;core_cache-&gt;reg_list + 15;
+	r = arm-&gt;pc;
 	pc = buf_get_u32(r-&gt;value, 0, 32);
 	if (pc != 0x00000008 &amp;&amp; pc != 0xffff0008)
 		return 0;
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 8d3a891..a4a15b4 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -577,6 +577,7 @@ struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm)
 		cache-&gt;num_regs++;
 	}
 
+	arm-&gt;pc = reg_list + 15;
 	arm-&gt;cpsr = reg_list + ARMV4_5_CPSR;
 	arm-&gt;core_cache = cache;
 	return cache;
@@ -598,8 +599,7 @@ int arm_arch_state(struct target *target)
 			debug_reason_name(target),
 			arm_mode_name(armv4_5-&gt;core_mode),
 			buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32),
-			buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value,
-					0, 32),
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32),
 			armv4_5-&gt;is_semihosting ? &quot;, semihosting&quot; : &quot;&quot;);
 
 	return ERROR_OK;
@@ -1018,11 +1018,10 @@ static int armv4_5_run_algorithm_completion(struct target *target, uint32_t exit
 	}
 
 	/* fast exit: ARMv5+ code can use BKPT */
-	if (exit_point &amp;&amp; buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value,
-				0, 32) != exit_point)
+	if (exit_point &amp;&amp; buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32) != exit_point)
 	{
 		LOG_WARNING(&quot;target reentered debug state, but not at the desired exit point: 0x%4.4&quot; PRIx32 &quot;&quot;,
-			buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
 		return ERROR_TARGET_TIMEOUT;
 	}
 
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index faa886b..466c0b2 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -282,7 +282,7 @@ int armv7m_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int
 
 	/* ARMV7M is always in thumb mode, try to make GDB understand this
 	 * if it does not support this arch */
-	*((char*)armv7m-&gt;core_cache-&gt;reg_list[15].value) |= 1;
+	*((char*)armv7m-&gt;arm.pc-&gt;value) |= 1;
 #else
 	(*reg_list)[25] = &amp;armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_xPSR];
 #endif
@@ -485,7 +485,7 @@ int armv7m_arch_state(struct target *target)
 		armv7m_mode_strings[armv7m-&gt;core_mode],
 		armv7m_exception_string(armv7m-&gt;exception_number),
 		buf_get_u32(arm-&gt;cpsr-&gt;value, 0, 32),
-		buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_PC].value, 0, 32),
+		buf_get_u32(arm-&gt;pc-&gt;value, 0, 32),
 		(ctrl &amp; 0x02) ? 'p' : 'm',
 		sp);
 
@@ -535,6 +535,7 @@ struct reg_cache *armv7m_build_reg_cache(struct target *target)
 	}
 
 	arm-&gt;cpsr = reg_list + ARMV7M_xPSR;
+	arm-&gt;pc = reg_list + ARMV7M_PC;
 	arm-&gt;core_cache = cache;
 	return cache;
 }
@@ -708,7 +709,7 @@ int armv7m_blank_check_memory(struct target *target,
 int armv7m_maybe_skip_bkpt_inst(struct target *target, bool *inst_found)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct reg *r = armv7m-&gt;core_cache-&gt;reg_list + 15;
+	struct reg *r = armv7m-&gt;arm.pc;
 	bool result = false;
 
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index bcdb526..050238c 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -695,9 +695,7 @@ static int cortex_a8_resume(struct target *target, int current,
 #endif
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
-	resume_pc = buf_get_u32(
-			armv4_5-&gt;core_cache-&gt;reg_list[15].value,
-			0, 32);
+	resume_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 	if (!current)
 		resume_pc = address;
 
@@ -721,10 +719,9 @@ static int cortex_a8_resume(struct target *target, int current,
 		return ERROR_FAIL;
 	}
 	LOG_DEBUG(&quot;resume pc = 0x%08&quot; PRIx32, resume_pc);
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value,
-			0, 32, resume_pc);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, resume_pc);
+	armv4_5-&gt;pc-&gt;dirty = 1;
+	armv4_5-&gt;pc-&gt;valid = 1;
 
 	cortex_a8_restore_context(target, handle_breakpoints);
 
@@ -869,7 +866,7 @@ static int cortex_a8_debug_entry(struct target *target)
 			regfile[ARM_PC] -= 8;
 		}
 
-		reg = armv4_5-&gt;core_cache-&gt;reg_list + 15;
+		reg = armv4_5-&gt;pc;
 		buf_set_u32(reg-&gt;value, 0, 32, regfile[ARM_PC]);
 		reg-&gt;dirty = reg-&gt;valid;
 	}
@@ -952,7 +949,7 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	}
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
-	r = armv4_5-&gt;core_cache-&gt;reg_list + 15;
+	r = armv4_5-&gt;pc;
 	if (!current)
 	{
 		buf_set_u32(r-&gt;value, 0, 32, address);
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index fbc879f..a3b3d42 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -427,7 +427,7 @@ static int cortex_m3_debug_entry(struct target *target)
 
 	LOG_DEBUG(&quot;entered debug state in core mode: %s at PC 0x%&quot; PRIx32 &quot;, target-&gt;state: %s&quot;,
 		armv7m_mode_strings[armv7m-&gt;core_mode],
-		*(uint32_t*)(armv7m-&gt;core_cache-&gt;reg_list[15].value),
+		*(uint32_t*)(arm-&gt;pc-&gt;value),
 		target_state_name(target));
 
 	if (armv7m-&gt;post_debug_entry)
@@ -680,7 +680,7 @@ static int cortex_m3_resume(struct target *target, int current,
 	}
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
-	r = armv7m-&gt;core_cache-&gt;reg_list + 15;
+	r = armv7m-&gt;arm.pc;
 	if (!current)
 	{
 		buf_set_u32(r-&gt;value, 0, 32, address);
@@ -749,7 +749,7 @@ static int cortex_m3_step(struct target *target, int current,
 	struct armv7m_common *armv7m = &amp;cortex_m3-&gt;armv7m;
 	struct swjdp_common *swjdp = &amp;armv7m-&gt;swjdp_info;
 	struct breakpoint *breakpoint = NULL;
-	struct reg *pc = armv7m-&gt;core_cache-&gt;reg_list + 15;
+	struct reg *pc = armv7m-&gt;arm.pc;
 	bool bkpt_inst_found = false;
 
 	if (target-&gt;state != TARGET_HALTED)
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 19ed0cd..e0c3c39 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -337,7 +337,7 @@ void feroceon_branch_resume_thumb(struct target *target)
 	struct arm7_9_common *arm7_9 = armv4_5-&gt;arch_info;
 	struct arm_jtag *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	uint32_t r0 = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[0].value, 0, 32);
-	uint32_t pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	uint32_t pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -519,7 +519,7 @@ int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 	/* backup clobbered processor state */
 	for (i = 0; i &lt;= 5; i++)
 		save[i] = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[i].value, 0, 32);
-	save[i] = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	save[i] = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	/* set up target address in r0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[0].value, 0, 32, address);
@@ -572,9 +572,9 @@ int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 		armv4_5-&gt;core_cache-&gt;reg_list[i].valid = 1;
 		armv4_5-&gt;core_cache-&gt;reg_list[i].dirty = 1;
 	}
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, save[i]);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, save[i]);
+	armv4_5-&gt;pc-&gt;valid = 1;
+	armv4_5-&gt;pc-&gt;dirty = 1;
 	armv4_5-&gt;core_state = core_state;
 
 	return retval;
diff --git a/src/target/xscale.c b/src/target/xscale.c
index fc71ea3..48dbc47 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -941,9 +941,9 @@ static int xscale_debug_entry(struct target *target)
 	LOG_DEBUG(&quot;r0: 0x%8.8&quot; PRIx32 &quot;&quot;, buffer[0]);
 
 	/* move pc from buffer to register cache */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, buffer[1]);
-	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, buffer[1]);
+	armv4_5-&gt;pc-&gt;dirty = 1;
+	armv4_5-&gt;pc-&gt;valid = 1;
 	LOG_DEBUG(&quot;pc: 0x%8.8&quot; PRIx32 &quot;&quot;, buffer[1]);
 
 	/* move data from buffer to register cache */
@@ -995,7 +995,7 @@ static int xscale_debug_entry(struct target *target)
 	moe = buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value, 2, 3);
 
 	/* stored PC (for calculating fixup) */
-	pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	switch (moe)
 	{
@@ -1042,7 +1042,7 @@ static int xscale_debug_entry(struct target *target)
 	}
 
 	/* apply PC fixup */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, pc);
+	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, pc);
 
 	/* on the first debug entry, identify cache type */
 	if (xscale-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
@@ -1212,21 +1212,23 @@ static int xscale_resume(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
 	if (!current)
-		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, address);
 
-	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	/* if we're at the reset vector, we have to simulate the branch */
 	if (current_pc == 0x0)
 	{
 		arm_simulate_step(target, NULL);
-		current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+		current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 	}
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
 	{
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))))
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+		if (breakpoint != NULL)
 		{
 			uint32_t next_pc;
 
@@ -1272,8 +1274,10 @@ static int xscale_resume(struct target *target, int current,
 			}
 
 			/* send PC */
-			xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
-			LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
+			xscale_send_u32(target,
+					buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+			LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32,
+					buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
 
 			/* wait for and process debug entry */
 			xscale_debug_entry(target);
@@ -1316,8 +1320,9 @@ static int xscale_resume(struct target *target, int current,
 	}
 
 	/* send PC */
-	xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
-	LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
+	xscale_send_u32(target, buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+	LOG_DEBUG(&quot;wrote PC with value 0x%8.8&quot; PRIx32,
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
 
 	target-&gt;debug_reason = DBG_REASON_NOTHALTED;
 
@@ -1354,7 +1359,7 @@ static int xscale_step_inner(struct target *target, int current,
 	if ((retval = arm_simulate_step(target, &amp;next_pc)) != ERROR_OK)
 	{
 		uint32_t current_opcode, current_pc;
-		current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+		current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 		target_read_u32(target, current_pc, &amp;current_opcode);
 		LOG_ERROR(&quot;BUG: couldn't calculate PC of next instruction, current opcode was 0x%8.8&quot; PRIx32 &quot;&quot;, current_opcode);
@@ -1399,9 +1404,12 @@ static int xscale_step_inner(struct target *target, int current,
 	}
 
 	/* send PC */
-	if ((retval = xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))) != ERROR_OK)
+	retval = xscale_send_u32(target,
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
+	LOG_DEBUG(&quot;wrote PC with value 0x%8.8&quot; PRIx32,
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
 
 	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 
@@ -1425,7 +1433,7 @@ static int xscale_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints)
 {
 	struct arm *armv4_5 = target_to_arm(target);
-	struct breakpoint *breakpoint = target-&gt;breakpoints;
+	struct breakpoint *breakpoint = NULL;
 
 	uint32_t current_pc;
 	int retval;
@@ -1438,16 +1446,16 @@ static int xscale_step(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
 	if (!current)
-		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, address);
 
-	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 	/* if we're at the reset vector, we have to simulate the step */
 	if (current_pc == 0x0)
 	{
 		if ((retval = arm_simulate_step(target, NULL)) != ERROR_OK)
 			return retval;
-		current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+		current_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 
 		target-&gt;debug_reason = DBG_REASON_SINGLESTEP;
 		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
@@ -1457,11 +1465,13 @@ static int xscale_step(struct target *target, int current,
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))))
-		{
-			if ((retval = xscale_unset_breakpoint(target, breakpoint)) != ERROR_OK)
-				return retval;
-		}
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
+	if (breakpoint != NULL) {
+		retval = xscale_unset_breakpoint(target, breakpoint);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	retval = xscale_step_inner(target, current, address, handle_breakpoints);
 
@@ -2568,7 +2578,8 @@ static int xscale_read_trace(struct target *target)
 	(*trace_data_p)-&gt;next = NULL;
 	(*trace_data_p)-&gt;chkpt0 = trace_buffer[256];
 	(*trace_data_p)-&gt;chkpt1 = trace_buffer[257];
-	(*trace_data_p)-&gt;last_instruction = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	(*trace_data_p)-&gt;last_instruction =
+			buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 	(*trace_data_p)-&gt;entries = malloc(sizeof(struct xscale_trace_entry) * (256 - j));
 	(*trace_data_p)-&gt;depth = 256 - j;
 
@@ -3375,7 +3386,8 @@ COMMAND_HANDLER(xscale_handle_trace_buffer_command)
 		/* if we enable the trace buffer in fill-once
 		 * mode we know the address of the first instruction */
 		xscale-&gt;trace.pc_ok = 1;
-		xscale-&gt;trace.current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+		xscale-&gt;trace.current_pc =
+				buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 	}
 	else
 	{

commit a299371a9ec109da3851cb43aed3e9157d095358
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:32:34 2010 -0800

    ARM DPM: support adding/removing HW breakpoints
    
    Generalize the core of watchpoint setup so that it can handle
    breakpoints too.  Create breakpoint add/remove routines which
    will use that, and hook them up to target types which don't
    provide their own breakpoint support (nothing, yet).
    
    This suffices for hardware-only breakpoint support.  The ARM11
    code will be able to switch over to this without much trouble,
    since it doesn't yet handle software breakpoints.  Switching
    Cortex-A8 will be a bit more involved.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 3c18e63..0b5e255 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -320,14 +320,17 @@ static int dpm_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
 				xp-&gt;address, xp-&gt;control);
 
 	if (retval != ERROR_OK)
-		LOG_ERROR(&quot;%s: can't %s HW bp/wp %d&quot;,
+		LOG_ERROR(&quot;%s: can't %s HW %spoint %d&quot;,
 				disable ? &quot;disable&quot; : &quot;enable&quot;,
 				target_name(dpm-&gt;arm-&gt;target),
-				xp-&gt;number);
+				(xp-&gt;number &lt; 16) ? &quot;break&quot; : &quot;watch&quot;,
+				xp-&gt;number &amp; 0xf);
 done:
 	return retval;
 }
 
+static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp);
+
 /**
  * Writes all modified core registers for all processor modes.  In normal
  * operation this is called on exit from halting debug state.
@@ -354,7 +357,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * we should be able to assume we handle them; but until then,
 	 * cope with the hand-crafted breakpoint code.
 	 */
-	if (0) {
+	if (arm-&gt;target-&gt;type-&gt;add_breakpoint == dpm_add_breakpoint) {
 		for (unsigned i = 0; i &lt; dpm-&gt;nbp; i++) {
 			struct dpm_bp *dbp = dpm-&gt;dbp + i;
 			struct breakpoint *bp = dbp-&gt;bp;
@@ -665,43 +668,26 @@ done:
  * fact isn't currently leveraged.
  */
 
-static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
-		struct watchpoint *wp)
+static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
+		uint32_t addr, uint32_t length)
 {
-	uint32_t addr = wp-&gt;address;
 	uint32_t control;
 
-	/* this hardware doesn't support data value matching or masking */
-	if (wp-&gt;value || wp-&gt;mask != ~(uint32_t)0) {
-		LOG_DEBUG(&quot;watchpoint values and masking not supported&quot;);
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
-
 	control = (1 &lt;&lt; 0)	/* enable */
 		| (3 &lt;&lt; 1);	/* both user and privileged access */
 
-	switch (wp-&gt;rw) {
-	case WPT_READ:
-		control |= 1 &lt;&lt; 3;
-		break;
-	case WPT_WRITE:
-		control |= 2 &lt;&lt; 3;
-		break;
-	case WPT_ACCESS:
-		control |= 3 &lt;&lt; 3;
-		break;
-	}
-
 	/* Match 1, 2, or all 4 byte addresses in this word.
 	 *
-	 * FIXME:  v7 hardware allows lengths up to 2 GB, and has eight
-	 * byte address select bits.  Support larger wp-&gt;length, if addr
-	 * is suitably aligned.
+	 * FIXME:  v7 hardware allows lengths up to 2 GB for BP and WP.
+	 * Support larger length, when addr is suitably aligned.  In
+	 * particular, allow watchpoints on 8 byte &quot;double&quot; values.
+	 *
+	 * REVISIT allow watchpoints on unaligned 2-bit values; and on
+	 * v7 hardware, unaligned 4-byte ones too.
 	 */
-	switch (wp-&gt;length) {
+	switch (length) {
 	case 1:
 		control |= (1 &lt;&lt; (addr &amp; 3)) &lt;&lt; 5;
-		addr &amp;= ~3;
 		break;
 	case 2:
 		/* require 2-byte alignment */
@@ -718,26 +704,110 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
 		}
 		/* FALL THROUGH */
 	default:
-		LOG_DEBUG(&quot;bad watchpoint length or alignment&quot;);
+		LOG_ERROR(&quot;unsupported {break,watch}point length/alignment&quot;);
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	/* other control bits:
-	 * bits 9:12 == 0 ... only checking up to four byte addresses (v7 only)
+	/* other shared control bits:
 	 * bits 15:14 == 0 ... both secure and nonsecure states (v6.1+ only)
 	 * bit 20 == 0 ... not linked to a context ID
 	 * bit 28:24 == 0 ... not ignoring N LSBs (v7 only)
 	 */
 
-	dpm-&gt;dwp[index].wp = wp;
-	dpm-&gt;dwp[index].bpwp.address = addr &amp; ~3;
-	dpm-&gt;dwp[index].bpwp.control = control;
-	dpm-&gt;dwp[index].bpwp.dirty = true;
+	xp-&gt;address = addr &amp; ~3;
+	xp-&gt;control = control;
+	xp-&gt;dirty = true;
+
+	LOG_DEBUG(&quot;BPWP: addr %8.8x, control %x, number %d&quot;,
+			xp-&gt;address, control, xp-&gt;number);
 
 	/* hardware is updated in write_dirty_registers() */
 	return ERROR_OK;
 }
 
+static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm-&gt;dpm;
+	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
+	if (bp-&gt;length &lt; 2)
+		return ERROR_INVALID_ARGUMENTS;
+	if (!dpm-&gt;bpwp_enable)
+		return retval;
+
+	/* FIXME we need a generic solution for software breakpoints. */
+	if (bp-&gt;type == BKPT_SOFT)
+		LOG_DEBUG(&quot;using HW bkpt, not SW...&quot;);
+
+	for (unsigned i = 0; i &lt; dpm-&gt;nbp; i++) {
+		if (!dpm-&gt;dbp[i].bp) {
+			retval = dpm_bpwp_setup(dpm, &amp;dpm-&gt;dbp[i].bpwp,
+					bp-&gt;address, bp-&gt;length);
+			if (retval == ERROR_OK)
+				dpm-&gt;dbp[i].bp = bp;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_remove_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm-&gt;dpm;
+	int retval = ERROR_INVALID_ARGUMENTS;
+
+	for (unsigned i = 0; i &lt; dpm-&gt;nbp; i++) {
+		if (dpm-&gt;dbp[i].bp == bp) {
+			dpm-&gt;dbp[i].bp = NULL;
+			dpm-&gt;dbp[i].bpwp.dirty = true;
+
+			/* hardware is updated in write_dirty_registers() */
+			retval = ERROR_OK;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
+		struct watchpoint *wp)
+{
+	int retval;
+	struct dpm_wp *dwp = dpm-&gt;dwp + index;
+	uint32_t control;
+
+	/* this hardware doesn't support data value matching or masking */
+	if (wp-&gt;value || wp-&gt;mask != ~(uint32_t)0) {
+		LOG_DEBUG(&quot;watchpoint values and masking not supported&quot;);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	retval = dpm_bpwp_setup(dpm, &amp;dwp-&gt;bpwp, wp-&gt;address, wp-&gt;length);
+	if (retval != ERROR_OK)
+		return retval;
+
+	control = dwp-&gt;bpwp.control;
+	switch (wp-&gt;rw) {
+	case WPT_READ:
+		control |= 1 &lt;&lt; 3;
+		break;
+	case WPT_WRITE:
+		control |= 2 &lt;&lt; 3;
+		break;
+	case WPT_ACCESS:
+		control |= 3 &lt;&lt; 3;
+		break;
+	}
+	dwp-&gt;bpwp.control = control;
+
+	dpm-&gt;dwp[index].wp = wp;
+
+	return retval;
+}
 
 static int dpm_add_watchpoint(struct target *target, struct watchpoint *wp)
 {
@@ -865,11 +935,16 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 	arm-&gt;mrc = dpm_mrc;
 	arm-&gt;mcr = dpm_mcr;
 
-	/* breakpoint and watchpoint setup */
+	/* breakpoint setup -- optional until it works everywhere */
+	if (!target-&gt;type-&gt;add_breakpoint) {
+		target-&gt;type-&gt;add_breakpoint = dpm_add_breakpoint;
+		target-&gt;type-&gt;remove_breakpoint = dpm_remove_breakpoint;
+	}
+
+	/* watchpoint setup */
 	target-&gt;type-&gt;add_watchpoint = dpm_add_watchpoint;
 	target-&gt;type-&gt;remove_watchpoint = dpm_remove_watchpoint;
 
-	/* FIXME add breakpoint support */
 	/* FIXME add vector catch support */
 
 	dpm-&gt;nbp = 1 + ((dpm-&gt;didr &gt;&gt; 24) &amp; 0xf);

commit 27c068c1f82423a2492899d1632caaa6f8261810
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:30:27 2010 -0800

    ARM11: per-core options should not be global
    
    Address some FIXME comments by getting rid of globals, moving
    per-core parameters in the existing per-core data structure.
    
    This will matter most whenever there are multiple ARM11 cores,
    e.g. ARM11 MPcore chips, but in general is just cleanup.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 671943f..678d8ac 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -44,15 +44,6 @@
 #endif
 
 
-/* FIXME none of these flags should be global to all ARM11 cores!
- * Most of them shouldn't exist at all, once the code works...
- */
-static bool arm11_config_memwrite_burst = true;
-static bool arm11_config_memwrite_error_fatal = true;
-static uint32_t arm11_vcr = 0;
-static bool arm11_config_step_irq_enable = false;
-static bool arm11_config_hardware_step = false;
-
 static int arm11_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints);
 
@@ -537,8 +528,8 @@ static int arm11_resume(struct target *target, int current,
 			brp_num++;
 		}
 
-		if (arm11_vcr)
-			arm11_sc7_set_vcr(arm11, arm11_vcr);
+		if (arm11-&gt;vcr)
+			arm11_sc7_set_vcr(arm11, arm11-&gt;vcr);
 	}
 
 	/* activate all watchpoints and breakpoints */
@@ -646,7 +637,7 @@ static int arm11_step(struct target *target, int current,
 		brp[1].write	= 1;
 		brp[1].address	= ARM11_SC7_BCR0;
 
-		if (arm11_config_hardware_step)
+		if (arm11-&gt;hardware_step)
 		{
 			/* Hardware single stepping (&quot;instruction address
 			 * mismatch&quot;) is used if enabled.  It's not quite
@@ -690,7 +681,7 @@ static int arm11_step(struct target *target, int current,
 		/* resume */
 
 
-		if (arm11_config_step_irq_enable)
+		if (arm11-&gt;step_irq_enable)
 			/* this disable should be redundant ... */
 			arm11-&gt;dscr &amp;= ~DSCR_INT_DIS;
 		else
@@ -756,8 +747,8 @@ static int arm11_assert_reset(struct target *target)
 	struct arm11_common *arm11 = target_to_arm11(target);
 
 	/* optionally catch reset vector */
-	if (target-&gt;reset_halt &amp;&amp; !(arm11_vcr &amp; 1))
-		arm11_sc7_set_vcr(arm11, arm11_vcr | 1);
+	if (target-&gt;reset_halt &amp;&amp; !(arm11-&gt;vcr &amp; 1))
+		arm11_sc7_set_vcr(arm11, arm11-&gt;vcr | 1);
 
 	/* Issue some kind of warm reset. */
 	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
@@ -816,8 +807,8 @@ static int arm11_deassert_reset(struct target *target)
 	}
 
 	/* maybe restore vector catch config */
-	if (target-&gt;reset_halt &amp;&amp; !(arm11_vcr &amp; 1))
-		arm11_sc7_set_vcr(arm11, arm11_vcr);
+	if (target-&gt;reset_halt &amp;&amp; !(arm11-&gt;vcr &amp; 1))
+		arm11_sc7_set_vcr(arm11, arm11-&gt;vcr);
 
 	return ERROR_OK;
 }
@@ -966,7 +957,7 @@ static int arm11_write_memory_inner(struct target *target,
 	 * now exercise both burst and non-burst code paths with the
 	 * default settings, increasing code coverage.
 	 */
-	bool burst = arm11_config_memwrite_burst &amp;&amp; (count &gt; 1);
+	bool burst = arm11-&gt;memwrite_burst &amp;&amp; (count &gt; 1);
 
 	switch (size)
 	{
@@ -1071,7 +1062,7 @@ static int arm11_write_memory_inner(struct target *target,
 			if (burst)
 				LOG_ERROR(&quot;use 'arm11 memwrite burst disable' to disable fast burst mode&quot;);
 
-			if (arm11_config_memwrite_error_fatal)
+			if (arm11-&gt;memwrite_error_fatal)
 				return ERROR_FAIL;
 		}
 	}
@@ -1171,6 +1162,9 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 	arm11-&gt;jtag_info.cur_scan_chain = ~0;	/* invalid/unknown */
 	arm11-&gt;jtag_info.intest_instr = ARM11_INTEST;
 
+	arm11-&gt;memwrite_burst = true;
+	arm11-&gt;memwrite_error_fatal = true;
+
 	return ERROR_OK;
 }
 
@@ -1231,6 +1225,7 @@ static int arm11_examine(struct target *target)
 		break;
 	case 0x7B76:
 		arm11-&gt;arm.core_type = ARM_MODE_MON;
+		/* NOTE: could default arm11-&gt;hardware_step to true */
 		type = &quot;ARM1176&quot;;
 		break;
 	default:
@@ -1286,38 +1281,41 @@ static int arm11_examine(struct target *target)
 }
 
 
-/* FIXME all these BOOL_WRAPPER things should be modifying
- * per-instance state, not shared state; ditto the vector
- * catch register support.  Scan chains with multiple cores
- * should be able to say &quot;work with this core like this,
- * that core like that&quot;.  Example, ARM11 MPCore ...
- */
-
 #define ARM11_BOOL_WRAPPER(name, print_name)	\
-		COMMAND_HANDLER(arm11_handle_bool_##name) \
-		{ \
-			return CALL_COMMAND_HANDLER(handle_command_parse_bool, \
-					&amp;arm11_config_##name, print_name); \
-		}
+	COMMAND_HANDLER(arm11_handle_bool_##name) \
+	{ \
+		struct target *target = get_current_target(CMD_CTX); \
+		struct arm11_common *arm11 = target_to_arm11(target); \
+		\
+		return CALL_COMMAND_HANDLER(handle_command_parse_bool, \
+				&amp;arm11-&gt;name, print_name); \
+	}
 
 ARM11_BOOL_WRAPPER(memwrite_burst, &quot;memory write burst mode&quot;)
 ARM11_BOOL_WRAPPER(memwrite_error_fatal, &quot;fatal error mode for memory writes&quot;)
 ARM11_BOOL_WRAPPER(step_irq_enable, &quot;IRQs while stepping&quot;)
 ARM11_BOOL_WRAPPER(hardware_step, &quot;hardware single step&quot;)
 
+/* REVISIT handle the VCR bits like other ARMs:  use symbols for
+ * input and output values.
+ */
+
 COMMAND_HANDLER(arm11_handle_vcr)
 {
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm11_common *arm11 = target_to_arm11(target);
+
 	switch (CMD_ARGC) {
 	case 0:
 		break;
 	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], arm11_vcr);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], arm11-&gt;vcr);
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	LOG_INFO(&quot;VCR 0x%08&quot; PRIx32 &quot;&quot;, arm11_vcr);
+	LOG_INFO(&quot;VCR 0x%08&quot; PRIx32 &quot;&quot;, arm11-&gt;vcr);
 	return ERROR_OK;
 }
 
@@ -1376,6 +1374,7 @@ static const struct command_registration arm11_any_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 static const struct command_registration arm11_command_handlers[] = {
 	{
 		.chain = arm_command_handlers,
diff --git a/src/target/arm11.h b/src/target/arm11.h
index dd2f3a2..9edadee 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -69,6 +69,18 @@ struct arm11_common
 
 	bool	simulate_reset_on_next_halt;	/**&lt; Perform cleanups of the ARM state on next halt */
 
+	/* Per-core configurable options.
+	 * NOTE that several of these boolean options should not exist
+	 * once the relevant code is known to work correctly.
+	 */
+	bool memwrite_burst;
+	bool memwrite_error_fatal;
+	bool step_irq_enable;
+	bool hardware_step;
+
+	/** Configured Vector Catch Register settings. */
+	uint32_t vcr;
+
 	struct arm_jtag jtag_info;
 };
 

commit ce1feaa7322affd3b979c9fe93dd8f7462ea9eca
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Feb 21 14:28:53 2010 -0800

    ARMv7-M: start using &quot;struct arm&quot;
    
    This sets up a few of the core &quot;struct arm&quot; data structures so they
    can be used with ARMv7-M cores.  Specifically, it:
    
     - defines new ARM core_modes to match the microcontroller modes
       (e.g. HANDLER not IRQ, and two types of thread mode);
    
     - Establishes a new microcontroller &quot;core_type&quot;, which can be
       used to make sure v7-M (and v6-M) cores are handled right;
    
     - adds &quot;struct arm&quot; to &quot;struct armv7m&quot; and arranges for the
       target_to_armv7m() converter to use it;
    
     - sets up the arm.core_cache and arm.cpsr values
    
     - makes the Cortex-M3 code maintain arm.map and arm.core_mode.
    
    This is currently set up as a parallel data structure, primarily to
    minimize special cases for the semihosting support with microcontroller
    profile cores.
    
    Later patches can rip out the duplicative ARMv7-M support and start
    reusing core ARM code.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm.h b/src/target/arm.h
index 988266e..c72b194 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -40,9 +40,17 @@
  */
 
 /**
- * These numbers match the five low bits of the *PSR registers on
+ * Represent state of an ARM core.
+ *
+ * Most numbers match the five low bits of the *PSR registers on
  * &quot;classic ARM&quot; processors, which build on the ARMv4 processor
  * modes and register set.
+ *
+ * ARM_MODE_ANY is a magic value, often used as a wildcard.
+ *
+ * Only the microcontroller cores (ARMv6-M, ARMv7-M) support ARM_MODE_THREAD,
+ * ARM_MODE_USER_THREAD, and ARM_MODE_HANDLER.  Those are the only modes
+ * they support.
  */
 enum arm_mode {
 	ARM_MODE_USR = 16,
@@ -53,6 +61,11 @@ enum arm_mode {
 	ARM_MODE_MON = 26,
 	ARM_MODE_UND = 27,
 	ARM_MODE_SYS = 31,
+
+	ARM_MODE_THREAD,
+	ARM_MODE_USER_THREAD,
+	ARM_MODE_HANDLER,
+
 	ARM_MODE_ANY = -1
 };
 
@@ -96,6 +109,8 @@ struct arm {
 	 * ARM_MODE_ANY indicates the standard set of 37 registers,
 	 * seen on for example ARM7TDMI cores.  ARM_MODE_MON indicates three
 	 * more registers are shadowed, for &quot;Secure Monitor&quot; mode.
+	 * ARM_MODE_THREAD indicates a microcontroller profile core,
+	 * which only shadows SP.
 	 */
 	enum arm_mode core_type;
 
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index c7b7367..8d3a891 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -1426,10 +1426,12 @@ int arm_init_arch_info(struct target *target, struct arm *armv4_5)
 	armv4_5-&gt;target = target;
 
 	armv4_5-&gt;common_magic = ARM_COMMON_MAGIC;
-	arm_set_cpsr(armv4_5, ARM_MODE_USR);
 
 	/* core_type may be overridden by subtype logic */
-	armv4_5-&gt;core_type = ARM_MODE_ANY;
+	if (armv4_5-&gt;core_type != ARM_MODE_THREAD) {
+		armv4_5-&gt;core_type = ARM_MODE_ANY;
+		arm_set_cpsr(armv4_5, ARM_MODE_USR);
+	}
 
 	/* default full_context() has no core-specific optimizations */
 	if (!armv4_5-&gt;full_context &amp;&amp; armv4_5-&gt;read_core_reg)
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 9fe705a..faa886b 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -473,6 +473,7 @@ int armv7m_run_algorithm(struct target *target,
 int armv7m_arch_state(struct target *target)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
+	struct arm *arm = &amp;armv7m-&gt;arm;
 	uint32_t ctrl, sp;
 
 	ctrl = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_CONTROL].value, 0, 32);
@@ -483,7 +484,7 @@ int armv7m_arch_state(struct target *target)
 		debug_reason_name(target),
 		armv7m_mode_strings[armv7m-&gt;core_mode],
 		armv7m_exception_string(armv7m-&gt;exception_number),
-		buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_xPSR].value, 0, 32),
+		buf_get_u32(arm-&gt;cpsr-&gt;value, 0, 32),
 		buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_PC].value, 0, 32),
 		(ctrl &amp; 0x02) ? 'p' : 'm',
 		sp);
@@ -499,6 +500,7 @@ static const struct reg_arch_type armv7m_reg_type = {
 struct reg_cache *armv7m_build_reg_cache(struct target *target)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
+	struct arm *arm = &amp;armv7m-&gt;arm;
 	int num_regs = ARMV7M_NUM_REGS;
 	struct reg_cache **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
 	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
@@ -532,19 +534,28 @@ struct reg_cache *armv7m_build_reg_cache(struct target *target)
 		reg_list[i].arch_info = &amp;arch_info[i];
 	}
 
+	arm-&gt;cpsr = reg_list + ARMV7M_xPSR;
+	arm-&gt;core_cache = cache;
 	return cache;
 }
 
 /** Sets up target as a generic ARMv7-M core */
 int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m)
 {
+	struct arm *arm = &amp;armv7m-&gt;arm;
+
 	armv7m-&gt;common_magic = ARMV7M_COMMON_MAGIC;
 
-	target-&gt;arch_info = armv7m;
+	arm-&gt;core_type = ARM_MODE_THREAD;
+	arm-&gt;arch_info = armv7m;
+
+	/* FIXME remove v7m-specific r/w core_reg functions;
+	 * use the generic ARM core support..
+	 */
 	armv7m-&gt;read_core_reg = armv7m_read_core_reg;
 	armv7m-&gt;write_core_reg = armv7m_write_core_reg;
 
-	return ERROR_OK;
+	return arm_init_arch_info(target, arm);
 }
 
 /** Generates a CRC32 checksum of a memory region. */
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index b6be1d2..89c5064 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -100,6 +100,8 @@ enum
 
 struct armv7m_common
 {
+	struct arm	arm;
+
 	int common_magic;
 	struct reg_cache *core_cache;
 	enum armv7m_mode core_mode;
@@ -128,7 +130,7 @@ struct armv7m_common
 static inline struct armv7m_common *
 target_to_armv7m(struct target *target)
 {
-	return target-&gt;arch_info;
+	return container_of(target-&gt;arch_info, struct armv7m_common, arm);
 }
 
 static inline bool is_armv7m(struct armv7m_common *armv7m)
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 3f34769..fbc879f 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -323,6 +323,24 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 	return ERROR_OK;
 }
 
+/* PSP is used in some thread modes */
+static const int armv7m_psp_reg_map[17] = {
+	ARMV7M_R0, ARMV7M_R1, ARMV7M_R2, ARMV7M_R3,
+	ARMV7M_R4, ARMV7M_R5, ARMV7M_R6, ARMV7M_R7,
+	ARMV7M_R8, ARMV7M_R9, ARMV7M_R10, ARMV7M_R11,
+	ARMV7M_R12, ARMV7M_PSP, ARMV7M_R14, ARMV7M_PC,
+	ARMV7M_xPSR,
+};
+
+/* MSP is used in handler and some thread modes */
+static const int armv7m_msp_reg_map[17] = {
+	ARMV7M_R0, ARMV7M_R1, ARMV7M_R2, ARMV7M_R3,
+	ARMV7M_R4, ARMV7M_R5, ARMV7M_R6, ARMV7M_R7,
+	ARMV7M_R8, ARMV7M_R9, ARMV7M_R10, ARMV7M_R11,
+	ARMV7M_R12, ARMV7M_MSP, ARMV7M_R14, ARMV7M_PC,
+	ARMV7M_xPSR,
+};
+
 static int cortex_m3_debug_entry(struct target *target)
 {
 	int i;
@@ -330,6 +348,7 @@ static int cortex_m3_debug_entry(struct target *target)
 	int retval;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &amp;cortex_m3-&gt;armv7m;
+	struct arm *arm = &amp;armv7m-&gt;arm;
 	struct swjdp_common *swjdp = &amp;armv7m-&gt;swjdp_info;
 	struct reg *r;
 
@@ -377,11 +396,27 @@ static int cortex_m3_debug_entry(struct target *target)
 	{
 		armv7m-&gt;core_mode = ARMV7M_MODE_HANDLER;
 		armv7m-&gt;exception_number = (xPSR &amp; 0x1FF);
+
+		arm-&gt;core_mode = ARM_MODE_HANDLER;
+		arm-&gt;map = armv7m_msp_reg_map;
 	}
 	else
 	{
-		armv7m-&gt;core_mode = buf_get_u32(armv7m-&gt;core_cache
-				-&gt;reg_list[ARMV7M_CONTROL].value, 0, 1);
+		unsigned control = buf_get_u32(armv7m-&gt;core_cache
+				-&gt;reg_list[ARMV7M_CONTROL].value, 0, 2);
+
+		/* is this thread privileged? */
+		armv7m-&gt;core_mode = control &amp; 1;
+		arm-&gt;core_mode = armv7m-&gt;core_mode
+				? ARM_MODE_USER_THREAD
+				: ARM_MODE_THREAD;
+
+		/* which stack is it using? */
+		if (control &amp; 2)
+			arm-&gt;map = armv7m_psp_reg_map;
+		else
+			arm-&gt;map = armv7m_msp_reg_map;
+
 		armv7m-&gt;exception_number = 0;
 	}
 

-----------------------------------------------------------------------

Summary of changes:
 doc/manual/release.txt       |  143 ++++++++++++++------
 src/jtag/drivers/ft2232.c    |   97 +++++++++++---
 src/target/arm.h             |   20 +++-
 src/target/arm11.c           |   67 +++++-----
 src/target/arm11.h           |   12 ++
 src/target/arm720t.c         |    6 +-
 src/target/arm7_9_common.c   |   42 +++---
 src/target/arm7tdmi.c        |    3 +-
 src/target/arm920t.c         |    6 +-
 src/target/arm926ejs.c       |    6 +-
 src/target/arm9tdmi.c        |    3 +-
 src/target/arm_adi_v5.c      |  310 ++++++++++++++++-------------------------
 src/target/arm_adi_v5.h      |   48 +++++--
 src/target/arm_dpm.c         |  155 ++++++++++++++++------
 src/target/arm_semihosting.c |    6 +-
 src/target/armv4_5.c         |   15 +-
 src/target/armv7m.c          |   24 +++-
 src/target/armv7m.h          |    4 +-
 src/target/cortex_a8.c       |   23 ++--
 src/target/cortex_m3.c       |   56 ++++++--
 src/target/feroceon.c        |   10 +-
 src/target/xscale.c          |   66 ++++++----
 22 files changed, 676 insertions(+), 446 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002115.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-1-gb853b9d
</A></li>
	<LI>Next message: <A HREF="002117.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-14-g90efc40
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2116">[ date ]</a>
              <a href="thread.html#2116">[ thread ]</a>
              <a href="subject.html#2116">[ subject ]</a>
              <a href="author.html#2116">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
