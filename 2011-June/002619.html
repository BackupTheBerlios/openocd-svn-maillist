<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-918-g5227ae7
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-918-g5227ae7&In-Reply-To=%3Cmailman.104.1331736155.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002618.html">
   <LINK REL="Next"  HREF="002620.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-918-g5227ae7</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-918-g5227ae7&In-Reply-To=%3Cmailman.104.1331736155.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-918-g5227ae7">gowinex at users.sourceforge.net
       </A><BR>
    <I>Sun Jun 12 11:25:39 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002618.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-906-ge899fca
</A></li>
        <LI>Next message: <A HREF="002620.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-919-g1b0862c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2619">[ date ]</a>
              <a href="thread.html#2619">[ thread ]</a>
              <a href="subject.html#2619">[ subject ]</a>
              <a href="author.html#2619">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  5227ae7162732c89fbf2e5eb547c4b1bee03bb58 (commit)
       via  47aa65b3e8499ab17bc0bff05c2eae27b39457a3 (commit)
       via  d343941386bfa274cd64f8f384fc51a695f9f626 (commit)
       via  cbe201fe6bb2f004957ff8174b53c6d4ecd5bae6 (commit)
       via  7b0ead520dcf6969954f42255a01e63b89f96cd6 (commit)
       via  f4b9a2fc8bbc682e957276a0012199a606c919b0 (commit)
       via  ca76e4a4231e665309c7f11a6be741067ef3b09c (commit)
       via  c4bcb0b95a8d3ee9baf7046b6768976d8a4eb134 (commit)
       via  d539fc856f4c09e3a3b683c2b1b5766652ab9d7a (commit)
       via  f42353d82137d0a3f5e2433bae931c82b8407c74 (commit)
       via  f4a3db0d4a353ccc6d701a2645390ef9039e0d02 (commit)
       via  56d3927abf2d2c6c49f3ae6ad6c2f353168d5a60 (commit)
      from  e899fcaca0d207eadea569b9dd9b2d54afafcfd4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5227ae7162732c89fbf2e5eb547c4b1bee03bb58
Author: rlrosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigo at evolution.com</A>&gt;
Date:   Fri Jun 10 13:26:47 2011 -0700

    added minimodule interface

diff --git a/tcl/interface/minimodule.cfg b/tcl/interface/minimodule.cfg
new file mode 100644
index 0000000..c8f9ba1
--- /dev/null
+++ b/tcl/interface/minimodule.cfg
@@ -0,0 +1,10 @@
+#
+# FTDI MiniModule
+#
+# <A HREF="http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf">http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf</A>
+#
+
+interface ft2232
+ft2232_device_desc &quot;FT2232H MiniModule&quot;
+ft2232_layout &quot;minimodule&quot;
+ft2232_vid_pid 0x0403 0x6010

commit 47aa65b3e8499ab17bc0bff05c2eae27b39457a3
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:24:55 2011 -0700

    doxy more

diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index a574724..3fbe90e 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -226,10 +226,11 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
 /** 
  * Writes to flash memory.
  * Does not check if flash is erased, it's up to the user to erase the flash before running this function.
+ * The flashing algorithm runs from RAM, reading from a register to which this function writes to. The algorithm is open loop, there is no control to verify that the FM read the register before writing the next data. A closed loop approach was much slower, and the current implementation does not fail, and if it did the crc check would detect it, allowing to flash again.
  * 
  * @param target 
  * @param buffer 
- * @param address 
+ * @param address Word addressing.
  * @param count In bytes. 
  * 
  * @return 
@@ -259,7 +260,7 @@ int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased, uint32_t se
 int dsp5680xx_f_erase(struct target * target, int first, int last);
 
 /** 
- * Reads the memory mapped protection register.
+ * Reads the memory mapped protection register. A 1 implies the sector is protected, a 0 implies the sector is not protected.
  * 
  * @param target 
  * @param protected Data read from the protection register.

commit d343941386bfa274cd64f8f384fc51a695f9f626
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:24:27 2011 -0700

    doxy &amp; cleanup

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index b919f56..4ed7206 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -23,6 +23,19 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
+/**
+ * @file   dsp5680xx_flash.c
+ * @author Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
+ * @date   Thu Jun  9 18:21:58 2011
+ * 
+ * @brief  This file implements the basic functions to run flashing commands
+ * from the TCL interface.
+ * It allows the user to flash the Freescale 5680xx DSP.
+ * 
+ * 
+ */
+
+
 #ifdef HAVE_CONFIG_H
 #include &quot;config.h&quot;
 #endif
@@ -71,6 +84,15 @@ FLASH_BANK_COMMAND_HANDLER(dsp5680xx_flash_bank_command){
   return ERROR_OK;
 }
 
+/** 
+ * A memory mapped register (PROT) holds information regarding sector protection.
+ * Protection refers to undesired core access.
+ * The value in this register is loaded from flash upon reset.
+ * 
+ * @param bank 
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
   int retval = ERROR_OK;
   uint16_t protected = 0;
@@ -93,6 +115,18 @@ static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
   return retval;
 }
 
+/** 
+ * Protection funcionality is not implemented.
+ * The current implementation applies/removes security on the chip.
+ * The chip is effectively secured/unsecured after the first reset following the execution of this function.
+ * 
+ * @param bank 
+ * @param set Apply or remove security on the chip.
+ * @param first This parameter is ignored.
+ * @param last This parameter is ignored.
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first, int last){
   // This applies security to flash module after next reset, it does not actually apply protection (protection refers to undesired access from the core)
   int retval;
@@ -103,24 +137,16 @@ static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first,
   return retval;
 }
 
-/*
-static int dsp5680xx_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
-  LOG_USER(&quot;%s not implemented&quot;,__FUNCTION__);
-  return ERROR_OK;
-}
-
-static int dsp5680xx_write_single(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
-  LOG_USER(&quot;%s not implemented&quot;,__FUNCTION__);
-  return ERROR_OK;
-}
-*/
-
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-//  Flash stuff test
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-
+/** 
+ * The dsp5680xx use word addressing. The &quot;/2&quot; that appear in the following code are a workaround for the fact that OpenOCD uses byte addressing.
+ * 
+ * @param bank 
+ * @param buffer Data to write to flash.
+ * @param offset 
+ * @param count In bytes (2 bytes per address).
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
   int retval;
   if((offset + count/2)&gt;bank-&gt;size){
@@ -151,19 +177,17 @@ static int dsp5680xx_flash_info(struct flash_bank *bank, char *buf, int buf_size
 	snprintf(buf, buf_size, &quot;\ndsp5680xx flash driver info:\n - Currently only full erase/lock/unlock are implemented. \n - Call with bank==0 and sector 0 to 0.\n - Protect requires arp_init-reset to complete. \n - Before removing protection the master tap must be selected, and arp_init-reset is required to complete unlocking.&quot;);
 	return ERROR_OK;
 }
-/*
-static int dsp5680xx_set_write_enable(struct target *target, int enable){
-	LOG_USER(&quot;%s not implemented&quot;,__FUNCTION__);
-        return ERROR_OK;
-}
-
-
-static int dsp5680xx_check_flash_completion(struct target* target, unsigned int timeout_ms){
-  LOG_USER(&quot;%s not implemented&quot;,__FUNCTION__);
-  return ERROR_OK;
-}
-*/
 
+/** 
+ * The flash module (FM) on the dsp5680xx supports both individual sector and mass erase of the flash memory.
+ * If this function is called with @first == @last == 0 or if @first is the first sector (#0) and @last is the last sector then the mass erase command is executed (much faster than erasing each sector individually).
+ * 
+ * @param bank 
+ * @param first 
+ * @param last 
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_erase(struct flash_bank * bank, int first, int last){
   int retval;
   retval = dsp5680xx_f_erase(bank-&gt;target, (uint32_t) first, (uint32_t) last);
@@ -177,6 +201,14 @@ static int dsp5680xx_flash_erase(struct flash_bank * bank, int first, int last){
   return retval;
 }
 
+/** 
+ * The flash module (FM) on the dsp5680xx support a blank check function.
+ * This function executes the FM's blank check functionality on each and every sector.
+ * 
+ * @param bank 
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_erase_check(struct flash_bank * bank){
   int retval = ERROR_OK;
   uint8_t erased = 0;
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index f3f25a1..9afda42 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -31,18 +31,6 @@
 #define err_check(retval,err_msg) if(retval != ERROR_OK){LOG_ERROR(&quot;%s: %d %s.&quot;,__FUNCTION__,__LINE__,err_msg);return retval;}
 #define err_check_propagate(retval) if(retval!=ERROR_OK){return retval;}
 
-// Forward declarations, could try to optimize this.
-static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex, uint8_t * eonce_status);
-static int eonce_load_TX_RX_to_r0(struct target * target);
-static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status);
-static int eonce_read_status_reg(struct target * target, uint16_t * data);
-static int eonce_pc_store(struct target * target);
-static int eonce_move_value_to_pc(struct target * target, uint32_t value);
-static int dsp5680xx_jtag_status(struct target *target, uint8_t * status);
-static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution);
-static int dsp5680xx_halt(struct target *target);
-static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer);
-
 int dsp5680xx_execute_queue(void){
   int retval;
   retval = jtag_execute_queue();
@@ -50,14 +38,6 @@ int dsp5680xx_execute_queue(void){
   return retval;
 }
 
-static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
-  int retval;
-  retval = eonce_instruction_exec(target,0x1F,0,0,1,eonce_status);
-  err_check_propagate(retval);
-  return retval;
-}
-
-
 static int dsp5680xx_drscan(struct target * target, uint8_t * data_to_shift_into_dr, uint8_t * data_shifted_out_of_dr, int len){
 // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 //
@@ -115,116 +95,12 @@ static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_int
   //is the casting necessary?
   jtag_add_plain_ir_scan(ir_len,(uint8_t *)data_to_shift_into_ir,(uint8_t *)data_shifted_out_of_ir, TAP_IDLE);
   if(context.flush){
-	retval = dsp5680xx_execute_queue();
-	err_check_propagate(retval);
+    retval = dsp5680xx_execute_queue();
+    err_check_propagate(retval);
   }
   return retval;
 }
 
-static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uint16_t * data_read)
-{
-  //TODO implement a general version of this which matches what openocd uses.
-  int retval;
-  uint32_t dummy_data_to_shift_into_dr;
-  retval = eonce_instruction_exec(target,reg_addr,1,0,0,NULL);
-  err_check_propagate(retval);
-  retval = dsp5680xx_drscan(target,(uint8_t *)&amp; dummy_data_to_shift_into_dr,(uint8_t *) data_read, 8);
-  err_check_propagate(retval);
-  LOG_DEBUG(&quot;Reg. data: 0x%02X.&quot;,*data_read);
-  return retval;
-}
-
-static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
-  struct dsp5680xx_common *dsp5680xx = calloc(1, sizeof(struct dsp5680xx_common));
-  target-&gt;arch_info = dsp5680xx;
-  return ERROR_OK;
-}
-
-static int dsp5680xx_init_target(struct command_context *cmd_ctx, struct target *target){
-  context.stored_pc = 0;
-  context.flush = 1;
-  LOG_DEBUG(&quot;target initiated!&quot;);
-  //TODO core tap must be enabled before running these commands, currently this is done in the .cfg tcl script.
-  return ERROR_OK;
-}
-
-static int dsp5680xx_arch_state(struct target *target){
-  LOG_USER(&quot;%s not implemented yet.&quot;,__FUNCTION__);
-  return ERROR_OK;
-}
-
-int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t * eonce_st){
-  return target-&gt;state;
-}
-
-static int dsp5680xx_assert_reset(struct target *target){
-  target-&gt;state = TARGET_RESET;
-  return ERROR_OK;
-}
-
-static int dsp5680xx_deassert_reset(struct target *target){
-  target-&gt;state = TARGET_RUNNING;
-  return ERROR_OK;
-}
-
-static int dsp5680xx_poll(struct target *target){
-  int retval;
-  uint8_t jtag_status;
-  uint8_t eonce_status;
-  uint16_t read_tmp;
-  retval = dsp5680xx_jtag_status(target,&amp;jtag_status);
-  err_check_propagate(retval);
-  if (jtag_status == JTAG_STATUS_DEBUG)
-    if (target-&gt;state != TARGET_HALTED){
-      retval = eonce_enter_debug_mode(target,&amp;read_tmp);
-	  err_check_propagate(retval);
-      eonce_status = (uint8_t) read_tmp;
-      if((eonce_status&amp;EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_DEBUG_M){
-		LOG_WARNING(&quot;%s: Failed to put EOnCE in debug mode. Is flash locked?...&quot;,__FUNCTION__);
-		return ERROR_TARGET_FAILURE;
-      }else{
-		target-&gt;state = TARGET_HALTED;
-		return ERROR_OK;
-      }
-    }
-  if (jtag_status == JTAG_STATUS_NORMAL){
-    if(target-&gt;state == TARGET_RESET){
-      retval = dsp5680xx_halt(target);
-	  err_check_propagate(retval);
-      retval = eonce_exit_debug_mode(target,&amp;eonce_status);
-	  err_check_propagate(retval);
-      if((eonce_status&amp;EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
-		LOG_WARNING(&quot;%s: JTAG running, but cannot make EOnCE run. Try resetting...&quot;,__FUNCTION__);
-		return ERROR_TARGET_FAILURE;
-      }else{
-		target-&gt;state = TARGET_RUNNING;
-		return ERROR_OK;
-      }
-    }
-    if(target-&gt;state != TARGET_RUNNING){
-      retval = eonce_read_status_reg(target,&amp;read_tmp);
-	  err_check_propagate(retval);
-      eonce_status = (uint8_t) read_tmp;
-      if((eonce_status&amp;EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
-		LOG_WARNING(&quot;Inconsistent target status. Restart!&quot;);
-		return ERROR_TARGET_FAILURE;
-      }
-    }
-    target-&gt;state = TARGET_RUNNING;
-    return ERROR_OK;
-  }
-  if(jtag_status == JTAG_STATUS_DEAD){
-    LOG_ERROR(&quot;%s: Cannot communicate with JTAG. Check connection...&quot;,__FUNCTION__);
-    target-&gt;state = TARGET_UNKNOWN;
-    return ERROR_TARGET_FAILURE;
-  };
-  if (target-&gt;state == TARGET_UNKNOWN){
-    LOG_ERROR(&quot;%s: Target status invalid - communication failure&quot;,__FUNCTION__);
-    return ERROR_TARGET_FAILURE;
-  };
-  return ERROR_OK;
-}
-
 static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
   uint32_t read_from_ir;
   uint32_t instr;
@@ -237,57 +113,6 @@ static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
   return ERROR_OK;
 }
 
-static int eonce_read_status_reg(struct target * target, uint16_t * data){
-  int retval;
-  retval = dsp5680xx_read_core_reg(target,DSP5680XX_ONCE_OSR,data);
-  err_check_propagate(retval);
-  return retval;
-}
-
-static int dsp5680xx_halt(struct target *target){
-  int retval;
-  uint16_t eonce_status;
-  if(target-&gt;state == TARGET_HALTED){
-    LOG_USER(&quot;Target already halted.&quot;);
-    return ERROR_OK;
-  }
-  retval = eonce_enter_debug_mode(target,&amp;eonce_status);
-  err_check_propagate(retval);
-  retval = eonce_pc_store(target);
-  err_check_propagate(retval);
-  //TODO is it useful to store the pc?
-  return retval;
-}
-
-static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution){
-  if(target-&gt;state == TARGET_RUNNING){
-    LOG_USER(&quot;Target already running.&quot;);
-    return ERROR_OK;
-  }
-  int retval;
-  uint8_t eonce_status;
-  if(!current){
-    retval = eonce_move_value_to_pc(target,address);
-    err_check_propagate(retval);
-  }
-
-  int retry = 20;
-  while(retry-- &gt; 1){
-    retval = eonce_exit_debug_mode(target,&amp;eonce_status );
-	err_check_propagate(retval);
-    if(eonce_status == DSP5680XX_ONCE_OSCR_NORMAL_M)
-      break;
-  }
-  if(retry == 0){
-    retval = ERROR_TARGET_FAILURE;
-	err_check(retval,&quot;Failed to resume...&quot;);
-  }else{
-    target-&gt;state = TARGET_RUNNING;
-  }
-  LOG_DEBUG(&quot;EOnCE status: 0x%02X.&quot;,eonce_status);
-  return ERROR_OK;
-}
-
 static int jtag_data_read(struct target * target, uint32_t * data_read, int num_bits){
   uint32_t bogus_instr;
   int retval = dsp5680xx_drscan(target,(uint8_t *) &amp; bogus_instr,(uint8_t *) data_read,num_bits);
@@ -314,37 +139,18 @@ static int jtag_data_write(struct target * target, uint32_t instr,int num_bits,
 #define jtag_data_write24(target,instr,data_read) jtag_data_write(target,instr,24,data_read)
 #define jtag_data_write32(target,instr,data_read) jtag_data_write(target,instr,32,data_read)
 
-static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
-  int retval;
-  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
-  uint32_t ir_out;//not used, just to make jtag happy.
-  // Debug request #1
-  retval = dsp5680xx_irscan(target,&amp; instr,&amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-
-  // Enable EOnCE module
-  instr = JTAG_INSTR_ENABLE_ONCE;
-  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
-  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-  // Verify that debug mode is enabled
-  uint16_t data_read_from_dr;
-  retval = eonce_read_status_reg(target,&amp;data_read_from_dr);
-  err_check_propagate(retval);
-  if((data_read_from_dr&amp;0x30) == 0x30){
-    LOG_DEBUG(&quot;EOnCE successfully entered debug mode.&quot;);
-    target-&gt;state = TARGET_HALTED;
-    return ERROR_OK;
-  }else{
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,&quot;Failed to set EOnCE module to debug mode.&quot;);
-  }
-  if(eonce_status!=NULL)
-    *eonce_status = data_read_from_dr;
-  return ERROR_OK;
-}
+/** 
+ * Executes DSP instruction.
+ * 
+ * @param target 
+ * @param instr Instruction to execute.
+ * @param rw 
+ * @param go 
+ * @param ex 
+ * @param eonce_status Value read from the EOnCE status register.
+ * 
+ * @return 
+ */
 
 static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex,uint8_t * eonce_status){
   int retval;
@@ -357,15 +163,14 @@ static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t
   return retval;
 }
 
-/* Executes DSP instruction */
-/* wrappers for parameter conversion between eonce_execute_instruction and eonce_execute_instructionX */
+///wrappers for parameter conversion between eonce_execute_instruction and eonce_execute_instructionX
+
 #define eonce_execute_instruction_1(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction1(target,opcode1)
 #define eonce_execute_instruction_2(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction2(target,opcode1,opcode2)
 #define eonce_execute_instruction_3(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction3(target,opcode1,opcode2,opcode3)
-/* the macro itself */
 #define eonce_execute_instruction(target,words,opcode1,opcode2,opcode3) eonce_execute_instruction_##words(target,opcode1,opcode2,opcode3)
 
-/* Executes one word DSP instruction */
+/// Executes one word DSP instruction
 static int eonce_execute_instruction1(struct target * target, uint16_t opcode){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
@@ -375,7 +180,7 @@ static int eonce_execute_instruction1(struct target * target, uint16_t opcode){
   return retval;
 }
 
-/* Executes two word DSP instruction */
+/// Executes two word DSP instruction
 static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, uint16_t opcode2){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
@@ -389,7 +194,7 @@ static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, u
   return retval;
 }
 
-/* Executes three word DSP instruction */
+/// Executes three word DSP instruction
 static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,uint16_t opcode2,uint16_t opcode3){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
@@ -407,15 +212,16 @@ static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,u
   return retval;
 }
 
-/* --------------- Real-time data exchange --------------- */
-/*
-  The EOnCE Transmit (OTX) and Receive (ORX) registers are data memory mapped, each with an upper and lower 16 bit word.
-  Transmit and receive directions are defined from the core&#226;&#128;&#153;s perspective.
-  The core writes to the Transmit register and reads the Receive register, and the host through JTAG writes to the Receive register and reads the Transmit register.
-  Both registers have a combined data memory mapped OTXRXSR which provides indication when each may be accessed.
-ref: <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">eonce_rev.1.0_0208081.pdf at 36</A>
+/**
+ * --------------- Real-time data exchange ---------------
+ * The EOnCE Transmit (OTX) and Receive (ORX) registers are data memory mapped, each with an upper and lower 16 bit word.
+ * Transmit and receive directions are defined from the core&#226;&#128;&#153;s perspective.
+ * The core writes to the Transmit register and reads the Receive register, and the host through JTAG writes to the Receive register and reads the Transmit register.
+ * Both registers have a combined data memory mapped OTXRXSR which provides indication when each may be accessed.
+ *ref: <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">eonce_rev.1.0_0208081.pdf at 36</A>
 */
 
+/// writes data into upper ORx register of the target
 static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t * eonce_status_low){
   int retval;
   retval = eonce_instruction_exec(target,DSP5680XX_ONCE_ORX1,0,0,0,NULL);
@@ -425,7 +231,7 @@ static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t *
   return retval;
 }
 
-/* writes data into lower ORx register of the target */
+/// writes data into lower ORx register of the target
 #define eonce_tx_lower_data(target,data) eonce_instruction_exec(target,DSP5680XX_ONCE_ORX,0,0,0,NULL);\
 								  jtag_data_write16(target,data)
 
@@ -461,119 +267,124 @@ static int eonce_rx_lower_data(struct target * target,uint16_t * data_read)
   return retval;
 }
 
-/* -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -*/
-/* -- -- -- -- --- -- -- -Core Instructions- -- -- -- --- -- -- -- --- -- -*/
-/* -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -*/
-/* move.l #value,r0 */
+/**
+ * -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- --
+ * -- -- -- -- --- -- -- -Core Instructions- -- -- -- --- -- -- -- --- --
+ * -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- --
+ */
+
+/// move.l #value,r0
 #define eonce_move_long_to_r0(target,value)	eonce_execute_instruction(target,3,0xe418,value&amp;0xffff,value&gt;&gt;16)
 
-/* move.l #value,n */
+/// move.l #value,n
 #define eonce_move_long_to_n(target,value)		eonce_execute_instruction(target,3,0xe41e,value&amp;0xffff,value&gt;&gt;16)
 
-/* move x:(r0),y0 */
+/// move x:(r0),y0
 #define eonce_move_at_r0_to_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
 
-/* move x:(r0),y1 */
+/// move x:(r0),y1
 #define eonce_move_at_r0_to_y1(target)			eonce_execute_instruction(target,1,0xF714,0,0)
 
-/* move.l x:(r0),y */
+/// move.l x:(r0),y
 #define eonce_move_long_at_r0_y(target) eonce_execute_instruction(target,1,0xF734,0,0)
 
-/* move y0,x:(r0) */
+/// move y0,x:(r0)
 #define eonce_move_y0_at_r0(target)			eonce_execute_instruction(target,1,0xd514,0,0)
 
-/* bfclr #value,x:(r0) */
+/// bfclr #value,x:(r0)
 #define eonce_bfclr_at_r0(target,value)		eonce_execute_instruction(target,2,0x8040,value,0)
 
-/* move #value,y0 */
+/// move #value,y0
 #define eonce_move_value_to_y0(target,value)	eonce_execute_instruction(target,2,0x8745,value,0)
 
-/* move.w y0,x:(r0)+ */
+/// move.w y0,x:(r0)+
 #define eonce_move_y0_at_r0_inc(target)		eonce_execute_instruction(target,1,0xd500,0,0)
 
-/* move.w y0,p:(r0)+ */
+/// move.w y0,p:(r0)+
 #define eonce_move_y0_at_pr0_inc(target)		eonce_execute_instruction(target,1,0x8560,0,0)
 
-/* move.w p:(r0)+,y0 */
+/// move.w p:(r0)+,y0
 #define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
 
-/* move.w p:(r0)+,y1 */
+/// move.w p:(r0)+,y1
 #define eonce_move_at_pr0_inc_to_y1(target)	eonce_execute_instruction(target,1,0x8768,0,0)
 
-/* move.l #value,r2 */
+/// move.l #value,r2
 #define eonce_move_long_to_r2(target,value)	eonce_execute_instruction(target,3,0xe41A,value&amp;0xffff,value&gt;&gt;16)
 
-/* move y0,x:(r2) */
+/// move y0,x:(r2)
 #define eonce_move_y0_at_r2(target)             eonce_execute_instruction(target,1,0xd516,0,0)
 
-/* move.w #&lt;value&gt;,x:(r2) */
+/// move.w #&lt;value&gt;,x:(r2)
 #define eonce_move_value_at_r2(target,value)	eonce_execute_instruction(target,2,0x8642,value,0)
 
-/* move.w #&lt;value&gt;,x:(r0) */
+/// move.w #&lt;value&gt;,x:(r0)
 #define eonce_move_value_at_r0(target,value)	eonce_execute_instruction(target,2,0x8640,value,0)
 
-/* move.w #&lt;value&gt;,x:(R2+&lt;disp&gt;) */
+/// move.w #&lt;value&gt;,x:(R2+&lt;disp&gt;)
 #define eonce_move_value_at_r2_disp(target,value,disp)	eonce_execute_instruction(target,3,0x8646,value,disp)
 
-/* move.w x:(r2),Y0 */
+/// move.w x:(r2),Y0
 #define eonce_move_at_r2_to_y0(target)		eonce_execute_instruction(target,1,0xF516,0,0)
 
-/* move.w p:(r2)+,y0 */
+/// move.w p:(r2)+,y0
 #define eonce_move_at_pr2_inc_to_y0(target)	eonce_execute_instruction(target,1,0x856A,0,0)
 
-/* move.l #value,r3 */
+/// move.l #value,r3
 #define eonce_move_long_to_r1(target,value)	eonce_execute_instruction(target,3,0xE419,value&amp;0xffff,value&gt;&gt;16)
 
-/* move.l #value,r3 */
+/// move.l #value,r3
 #define eonce_move_long_to_r3(target,value)	eonce_execute_instruction(target,3,0xE41B,value&amp;0xffff,value&gt;&gt;16)
 
-/* move.w y0,p:(r3)+ */
+/// move.w y0,p:(r3)+
 #define eonce_move_y0_at_pr3_inc(target)		eonce_execute_instruction(target,1,0x8563,0,0)
 
-/* move.w y0,x:(r3) */
+/// move.w y0,x:(r3)
 #define eonce_move_y0_at_r3(target)			eonce_execute_instruction(target,1,0xD503,0,0)
 
-/* move pc,r4 */
+/// move.l #value,r4
+#define eonce_move_long_to_r4(target,value)	eonce_execute_instruction(target,3,0xE41C,value&amp;0xffff,value&gt;&gt;16)
+
+/// move pc,r4
 #define eonce_move_pc_to_r4(target)			eonce_execute_instruction(target,1,0xE716,0,0)
 
-/* move.l r4,y */
+/// move.l r4,y
 #define eonce_move_r4_to_y(target)			eonce_execute_instruction(target,1,0xe764,0,0)
 
-/* move.w p:(r0)+,y0 */
+/// move.w p:(r0)+,y0
 #define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
 
-/* move.w x:(r0)+,y0 */
+/// move.w x:(r0)+,y0
 #define eonce_move_at_r0_inc_to_y0(target)	eonce_execute_instruction(target,1,0xf500,0,0)
 
-/* move x:(r0),y0 */
+/// move x:(r0),y0
 #define eonce_move_at_r0_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
 
-/* nop */
+/// nop
 #define eonce_nop(target)		eonce_execute_instruction(target,1,0xe700,0,0)
 
-/* move.w x:(R2+&lt;disp&gt;),Y0 */
+/// move.w x:(R2+&lt;disp&gt;),Y0
 #define eonce_move_at_r2_disp_to_y0(target,disp) eonce_execute_instruction(target,2,0xF542,disp,0)
 
-/* move.w y1,x:(r2) */
+/// move.w y1,x:(r2)
 #define eonce_move_y1_at_r2(target) eonce_execute_instruction(target,1,0xd716,0,0)
 
-/* move.w y1,x:(r0) */
+/// move.w y1,x:(r0)
 #define eonce_move_y1_at_r0(target) eonce_execute_instruction(target,1,0xd714,0,0)
 
-/* move.bp y0,x:(r0)+ */
+/// move.bp y0,x:(r0)+
 #define eonce_move_byte_y0_at_r0(target) eonce_execute_instruction(target,1,0xd5a0,0,0)
 
-/* move.w y1,p:(r0)+ */
+/// move.w y1,p:(r0)+
 #define eonce_move_y1_at_pr0_inc(target) eonce_execute_instruction(target,1,0x8760,0,0)
 
-/* move.w y1,x:(r0)+ */
+/// move.w y1,x:(r0)+
 #define eonce_move_y1_at_r0_inc(target) eonce_execute_instruction(target,1,0xD700,0,0)
 
-/* move.l #value,y */
+/// move.l #value,y
 #define eonce_move_long_to_y(target,value) eonce_execute_instruction(target,3,0xe417,value&amp;0xffff,value&gt;&gt;16)
 
-static int eonce_move_value_to_pc(struct target * target, uint32_t value)
-{
+static int eonce_move_value_to_pc(struct target * target, uint32_t value){
   if (!(target-&gt;state == TARGET_HALTED)){
     LOG_ERROR(&quot;Target must be halted to move PC. Target state = %d.&quot;,target-&gt;state);
     return ERROR_TARGET_NOT_HALTED;
@@ -598,6 +409,88 @@ static int eonce_load_TX_RX_high_to_r0(struct target * target)
   return retval;
 }
 
+static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uint16_t * data_read)
+{
+  //TODO implement a general version of this which matches what openocd uses.
+  int retval;
+  uint32_t dummy_data_to_shift_into_dr;
+  retval = eonce_instruction_exec(target,reg_addr,1,0,0,NULL);
+  err_check_propagate(retval);
+  retval = dsp5680xx_drscan(target,(uint8_t *)&amp; dummy_data_to_shift_into_dr,(uint8_t *) data_read, 8);
+  err_check_propagate(retval);
+  LOG_DEBUG(&quot;Reg. data: 0x%02X.&quot;,*data_read);
+  return retval;
+}
+
+static int eonce_read_status_reg(struct target * target, uint16_t * data){
+  int retval;
+  retval = dsp5680xx_read_core_reg(target,DSP5680XX_ONCE_OSR,data);
+  err_check_propagate(retval);
+  return retval;
+}
+
+/** 
+ * Takes the core out of debug mode.
+ * 
+ * @param target 
+ * @param eonce_status Data read from the EOnCE status register.
+ * 
+ * @return 
+ */
+static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
+  int retval;
+  retval = eonce_instruction_exec(target,0x1F,0,0,1,eonce_status);
+  err_check_propagate(retval);
+  return retval;
+}
+
+/** 
+ * Puts the core into debug mode, enabling the EOnCE module.
+ * 
+ * @param target 
+ * @param eonce_status Data read from the EOnCE status register.
+ * 
+ * @return 
+ */
+static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
+  int retval;
+  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  // Debug request #1
+  retval = dsp5680xx_irscan(target,&amp; instr,&amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+
+  // Enable EOnCE module
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  // Verify that debug mode is enabled
+  uint16_t data_read_from_dr;
+  retval = eonce_read_status_reg(target,&amp;data_read_from_dr);
+  err_check_propagate(retval);
+  if((data_read_from_dr&amp;0x30) == 0x30){
+    LOG_DEBUG(&quot;EOnCE successfully entered debug mode.&quot;);
+    target-&gt;state = TARGET_HALTED;
+    return ERROR_OK;
+  }else{
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,&quot;Failed to set EOnCE module to debug mode.&quot;);
+  }
+  if(eonce_status!=NULL)
+    *eonce_status = data_read_from_dr;
+  return ERROR_OK;
+}
+
+/** 
+ * Reads the current value of the program counter and stores it.
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 static int eonce_pc_store(struct target * target){
   uint32_t tmp = 0;
   int retval;
@@ -616,6 +509,155 @@ static int eonce_pc_store(struct target * target){
   return ERROR_OK;
 }
 
+static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
+  struct dsp5680xx_common *dsp5680xx = calloc(1, sizeof(struct dsp5680xx_common));
+  target-&gt;arch_info = dsp5680xx;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_init_target(struct command_context *cmd_ctx, struct target *target){
+  context.stored_pc = 0;
+  context.flush = 1;
+  LOG_DEBUG(&quot;target initiated!&quot;);
+  //TODO core tap must be enabled before running these commands, currently this is done in the .cfg tcl script.
+  return ERROR_OK;
+}
+
+static int dsp5680xx_arch_state(struct target *target){
+  LOG_USER(&quot;%s not implemented yet.&quot;,__FUNCTION__);
+  return ERROR_OK;
+}
+
+int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t * eonce_st){
+  return target-&gt;state;
+}
+
+static int dsp5680xx_assert_reset(struct target *target){
+  target-&gt;state = TARGET_RESET;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_deassert_reset(struct target *target){
+  target-&gt;state = TARGET_RUNNING;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_halt(struct target *target){
+  int retval;
+  uint16_t eonce_status;
+  if(target-&gt;state == TARGET_HALTED){
+    LOG_USER(&quot;Target already halted.&quot;);
+    return ERROR_OK;
+  }
+  retval = eonce_enter_debug_mode(target,&amp;eonce_status);
+  err_check_propagate(retval);
+  retval = eonce_pc_store(target);
+  err_check_propagate(retval);
+  //TODO is it useful to store the pc?
+  return retval;
+}
+
+static int dsp5680xx_poll(struct target *target){
+  int retval;
+  uint8_t jtag_status;
+  uint8_t eonce_status;
+  uint16_t read_tmp;
+  retval = dsp5680xx_jtag_status(target,&amp;jtag_status);
+  err_check_propagate(retval);
+  if (jtag_status == JTAG_STATUS_DEBUG)
+    if (target-&gt;state != TARGET_HALTED){
+      retval = eonce_enter_debug_mode(target,&amp;read_tmp);
+	  err_check_propagate(retval);
+      eonce_status = (uint8_t) read_tmp;
+      if((eonce_status&amp;EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_DEBUG_M){
+		LOG_WARNING(&quot;%s: Failed to put EOnCE in debug mode. Is flash locked?...&quot;,__FUNCTION__);
+		return ERROR_TARGET_FAILURE;
+      }else{
+		target-&gt;state = TARGET_HALTED;
+		return ERROR_OK;
+      }
+    }
+  if (jtag_status == JTAG_STATUS_NORMAL){
+    if(target-&gt;state == TARGET_RESET){
+      retval = dsp5680xx_halt(target);
+	  err_check_propagate(retval);
+      retval = eonce_exit_debug_mode(target,&amp;eonce_status);
+	  err_check_propagate(retval);
+      if((eonce_status&amp;EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
+		LOG_WARNING(&quot;%s: JTAG running, but cannot make EOnCE run. Try resetting...&quot;,__FUNCTION__);
+		return ERROR_TARGET_FAILURE;
+      }else{
+		target-&gt;state = TARGET_RUNNING;
+		return ERROR_OK;
+      }
+    }
+    if(target-&gt;state != TARGET_RUNNING){
+      retval = eonce_read_status_reg(target,&amp;read_tmp);
+	  err_check_propagate(retval);
+      eonce_status = (uint8_t) read_tmp;
+      if((eonce_status&amp;EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
+		LOG_WARNING(&quot;Inconsistent target status. Restart!&quot;);
+		return ERROR_TARGET_FAILURE;
+      }
+    }
+    target-&gt;state = TARGET_RUNNING;
+    return ERROR_OK;
+  }
+  if(jtag_status == JTAG_STATUS_DEAD){
+    LOG_ERROR(&quot;%s: Cannot communicate with JTAG. Check connection...&quot;,__FUNCTION__);
+    target-&gt;state = TARGET_UNKNOWN;
+    return ERROR_TARGET_FAILURE;
+  };
+  if (target-&gt;state == TARGET_UNKNOWN){
+    LOG_ERROR(&quot;%s: Target status invalid - communication failure&quot;,__FUNCTION__);
+    return ERROR_TARGET_FAILURE;
+  };
+  return ERROR_OK;
+}
+
+static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution){
+  if(target-&gt;state == TARGET_RUNNING){
+    LOG_USER(&quot;Target already running.&quot;);
+    return ERROR_OK;
+  }
+  int retval;
+  uint8_t eonce_status;
+  if(!current){
+    retval = eonce_move_value_to_pc(target,address);
+    err_check_propagate(retval);
+  }
+
+  int retry = 20;
+  while(retry-- &gt; 1){
+    retval = eonce_exit_debug_mode(target,&amp;eonce_status );
+	err_check_propagate(retval);
+    if(eonce_status == DSP5680XX_ONCE_OSCR_NORMAL_M)
+      break;
+  }
+  if(retry == 0){
+    retval = ERROR_TARGET_FAILURE;
+	err_check(retval,&quot;Failed to resume...&quot;);
+  }else{
+    target-&gt;state = TARGET_RUNNING;
+  }
+  LOG_DEBUG(&quot;EOnCE status: 0x%02X.&quot;,eonce_status);
+  return ERROR_OK;
+}
+
+
+
+
+
+
+/** 
+ * The value of @address determines if it corresponds to P: (program) or X: (data) memory. If the address is over 0x200000 then it is considered X: memory, and @pmem = 0.
+ * The special case of 0xFFXXXX is not modified, since it allows to read out the memory mapped EOnCE registers.
+ * 
+ * @param address 
+ * @param pmem 
+ * 
+ * @return 
+ */
 static int dsp5680xx_convert_address(uint32_t * address, int * pmem){
   // Distinguish data memory (x:) from program memory (p:) by the address.
   // Addresses over S_FILE_DATA_OFFSET are considered (x:) memory.
@@ -679,7 +721,7 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
   uint16_t tmp;
   retval = eonce_rx_upper_data(target,&amp;tmp);
   err_check_propagate(retval);
-  *data_read = ((tmp&lt;&lt;16) | (*data_read));//This enables opencd crc to succeed, even though it's very slow.
+  *data_read = ((tmp&lt;&lt;16) | (*data_read));//This enables OpenOCD crc to succeed (when it should)
   return retval;
 }
 
@@ -734,7 +776,6 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   return retval;
 }
 
-//TODO doxy
 static int dsp5680xx_write_16_single(struct target *target, uint32_t address, uint16_t data, uint8_t w_pmem){
   int retval = 0;
   retval = eonce_move_long_to_r0(target,address);
@@ -751,7 +792,6 @@ static int dsp5680xx_write_16_single(struct target *target, uint32_t address, ui
   return retval;
 }
 
-//TODO doxy
 static int dsp5680xx_write_32_single(struct target *target, uint32_t address, uint32_t data, int w_pmem){
   int retval = 0;
   retval = eonce_move_long_to_r0(target,address);
@@ -864,7 +904,18 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
   return retval;
 }
 
-//TODO doxy
+/** 
+ * Writes @buffer to memory.
+ * The parameter @address determines whether @buffer should be written to P: (program) memory or X: (data) memory.
+ * 
+ * @param target 
+ * @param address
+ * @param size Bytes (1), Half words (2), Words (4).
+ * @param count In bytes.
+ * @param buffer 
+ * 
+ * @return 
+ */
 static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer){
   //TODO Cannot write 32bit to odd address, will write 0x12345678  as 0x5678 0x0012
   if(target-&gt;state != TARGET_HALTED){
@@ -888,7 +939,7 @@ static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t siz
     break;
   default:
 	retval = ERROR_TARGET_DATA_ABORT;
-	err_check(retval,&quot;Invalid data size.&quot;)
+	err_check(retval,&quot;Invalid data size.&quot;);
 	break;
   }
   return retval;
@@ -907,21 +958,49 @@ static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint
   return dsp5680xx_write(target, address, 1, size, buffer);
 }
 
+/** 
+ * This function is called by verify_image, it is used to read data from memory.
+ * 
+ * @param target 
+ * @param address Word addressing.
+ * @param size In bytes.
+ * @param buffer 
+ * 
+ * @return 
+ */
 static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){
   if(target-&gt;state != TARGET_HALTED){
     LOG_USER(&quot;Target must be halted.&quot;);
     return ERROR_OK;
   }
-  // read_buffer is called when the verify_image command is executed.
   // The &quot;/2&quot; solves the byte/word addressing issue.
   return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
+/** 
+ * This function is not implemented.
+ * It returns an error in order to get OpenOCD to do read out the data and calculate the CRC, or try a binary comparison.
+ * 
+ * @param target 
+ * @param address Start address of the image.
+ * @param size In bytes.
+ * @param checksum 
+ * 
+ * @return 
+ */
 static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
-  return ERROR_FAIL;// This will make OpenOCD do the read out the data and verify it.
+  return ERROR_FAIL;
 }
 
-// Data signature algorithm used by the core FM (flash module)
+/** 
+ * Calculates a signature over @word_count words in the data from @buff16. The algorithm used is the same the FM uses, so the @return may be used to compare with the one generated by the FM module, and check if flashing was successful.
+ * This algorithm is based on the perl script available from the Freescale website at FAQ 25630.
+ * 
+ * @param buff16 
+ * @param word_count 
+ * 
+ * @return 
+ */
 static int perl_crc(uint16_t * buff16,uint32_t  word_count){
   uint16_t checksum = 0xffff;
   uint16_t data,fbmisr;
@@ -940,6 +1019,13 @@ static int perl_crc(uint16_t * buff16,uint32_t  word_count){
   return checksum;
 }
 
+/** 
+ * Resets the SIM. (System Integration Module).
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_SIM_reset(struct target * target){
   int retval = ERROR_OK;
   uint16_t sim_cmd = SIM_CMD_RESET;
@@ -952,7 +1038,13 @@ int dsp5680xx_f_SIM_reset(struct target * target){
   return retval;
 }
 
-//TODO doxy
+/** 
+ * Halts the core and resets the SIM. (System Integration Module).
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 static int dsp5680xx_soft_reset_halt(struct target *target){
   //TODO is this what this function is expected to do...?
   int retval;
@@ -979,6 +1071,18 @@ int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
   return retval;
 }
 
+/** 
+ * Executes a command on the FM module. Some commands use the parameters @address and @data, others ignore them.
+ * 
+ * @param target 
+ * @param command Command to execute.
+ * @param address Command parameter.
+ * @param data Command parameter.
+ * @param hfm_ustat FM status register.
+ * @param pmem Address is P: (program) memory (@pmem==1) or X: (data) memory (@pmem==0)
+ * 
+ * @return 
+ */
 static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint32_t data, uint16_t * hfm_ustat, int pmem){
   int retval;
   retval = eonce_load_TX_RX_high_to_r0(target);
@@ -1055,6 +1159,13 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   return ERROR_OK;
 }
 
+/** 
+ * Prior to the execution of any Flash module command, the Flash module Clock Divider (CLKDIV) register must be initialized. The values of this register determine the speed of the internal Flash Clock (FCLK). FCLK must be in the range of 150kHz &#226;&#137;&#164; FCLK &#226;&#137;&#164; 200kHz for proper operation of the Flash module. (Running FCLK too slowly wears out the module, while running it too fast under programs Flash leading to bit errors.) 
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 static int eonce_set_hfmdiv(struct target * target){
   uint16_t i;
   int retval;
@@ -1093,6 +1204,16 @@ static int eonce_set_hfmdiv(struct target * target){
   return ERROR_OK;
 }
 
+/** 
+ * Executes the FM calculate signature command. The FM will calculate over the data from @address to @address + @words -1. The result is written to a register, then read out by this function and returned in @signature. The value @signature may be compared to the the one returned by perl_crc to verify the flash was written correctly.
+ * 
+ * @param target 
+ * @param address Start of flash array where the signature should be calculated.
+ * @param words Number of words over which the signature should be calculated.
+ * @param signature Value calculated by the FM.
+ * 
+ * @return 
+ */
 static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint32_t words, uint16_t * signature){
   int retval;
   uint16_t hfm_ustat;
@@ -1121,6 +1242,15 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
   return retval;
 }
 
+/** 
+ * Executes the FM page erase command.
+ * 
+ * @param target 
+ * @param sector Page to erase.
+ * @param hfm_ustat FM module status register.
+ * 
+ * @return 
+ */
 static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_PAGE_ERASE,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,hfm_ustat,1);
@@ -1128,6 +1258,14 @@ static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat
   return retval;
 }
 
+/** 
+ * Executes the FM mass erase command. Erases the flash array completely.
+ * 
+ * @param target 
+ * @param hfm_ustat FM module status register.
+ * 
+ * @return 
+ */
 static int mass_erase(struct target * target, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_MASS_ERASE,0,0,hfm_ustat,1);
@@ -1161,49 +1299,51 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
   }else{
     for(int i = first;i&lt;=last;i++){
       retval = erase_sector(target,i,&amp;hfm_ustat);
-	err_check_propagate(retval);
-  }
+      err_check_propagate(retval);
+    }
   }
   return ERROR_OK;
 }
 
-// Algorithm for programming normal p: flash
-// Follow state machine from &quot;56F801x Peripheral Reference Manual&quot;@163.
-// Registers to set up before calling:
-//  r0: TX/RX high address.
-//  r2: FM module base address.
-//  r3: Destination address in flash.
-//
-//		hfm_wait:                                           // wait for command to finish
-//			brclr	#0x40,x:(r2+0x13),hfm_wait
-//		rx_check:					    // wait for input buffer full
-//			brclr	#0x01,x:(r0-2),rx_check
-//			move.w	x:(r0),y0		   	    // read from Rx buffer
-//			move.w	y0,p:(r3)+
-//			move.w	#0x20,x:(r2+0x14)		    // write PGM command
-//			move.w	#0x80,x:(r2+0x13)		    // start the command
-//                      brclr       #0x20,X:(R2+0x13),accerr_check  // protection violation check
-//                      bfset       #0x20,X:(R2+0x13)               // clear pviol
-//                      bra         hfm_wait
-//              accerr_check:
-//                      brclr       #0x10,X:(R2+0x13),hfm_wait      // access error check
-//                      bfset       #0x10,X:(R2+0x13)               // clear accerr
-//			bra	    hfm_wait		            // loop
-//0x00000073  0x8A460013407D         brclr       #0x40,X:(R2+0x13),*+0
-//0x00000076  0xE700                 nop
-//0x00000077  0xE700                 nop
-//0x00000078  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
-//0x0000007B  0xE700                 nop
-//0x0000007C  0xF514                 move.w      X:(R0),Y0
-//0x0000007D  0x8563                 move.w      Y0,P:(R3)+
-//0x0000007E  0x864600200014         move.w      #0x20,X:(R2+0x14)
-//0x00000081  0x864600800013         move.w      #0x80,X:(R2+0x13)
-//0x00000084  0x8A4600132004         brclr       #0x20,X:(R2+0x13),*+7
-//0x00000087  0x824600130020         bfset       #0x20,X:(R2+0x13)
-//0x0000008A  0xA968                 bra         *-23
-//0x0000008B  0x8A4600131065         brclr       #0x10,X:(R2+0x13),*-24
-//0x0000008E  0x824600130010         bfset       #0x10,X:(R2+0x13)
-//0x00000091  0xA961                 bra         *-30
+/**
+ * Algorithm for programming normal p: flash
+ * Follow state machine from &quot;56F801x Peripheral Reference Manual&quot;@163.
+ * Registers to set up before calling:
+*  r0: TX/RX high address.
+*  r2: FM module base address.
+*  r3: Destination address in flash.
+*
+*		hfm_wait:                                           // wait for command to finish
+*			brclr	#0x40,x:(r2+0x13),hfm_wait
+*		rx_check:					    // wait for input buffer full
+*			brclr	#0x01,x:(r0-2),rx_check
+*			move.w	x:(r0),y0		   	    // read from Rx buffer
+*			move.w	y0,p:(r3)+
+*			move.w	#0x20,x:(r2+0x14)		    // write PGM command
+*			move.w	#0x80,x:(r2+0x13)		    // start the command
+*                      brclr       #0x20,X:(R2+0x13),accerr_check  // protection violation check
+*                      bfset       #0x20,X:(R2+0x13)               // clear pviol
+*                      bra         hfm_wait
+*              accerr_check:
+*                      brclr       #0x10,X:(R2+0x13),hfm_wait      // access error check
+*                      bfset       #0x10,X:(R2+0x13)               // clear accerr
+*			bra	    hfm_wait		            // loop
+*0x00000073  0x8A460013407D         brclr       #0x40,X:(R2+0x13),*+0
+*0x00000076  0xE700                 nop
+*0x00000077  0xE700                 nop
+*0x00000078  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
+*0x0000007B  0xE700                 nop
+*0x0000007C  0xF514                 move.w      X:(R0),Y0
+*0x0000007D  0x8563                 move.w      Y0,P:(R3)+
+*0x0000007E  0x864600200014         move.w      #0x20,X:(R2+0x14)
+*0x00000081  0x864600800013         move.w      #0x80,X:(R2+0x13)
+*0x00000084  0x8A4600132004         brclr       #0x20,X:(R2+0x13),*+7
+*0x00000087  0x824600130020         bfset       #0x20,X:(R2+0x13)
+*0x0000008A  0xA968                 bra         *-23
+*0x0000008B  0x8A4600131065         brclr       #0x10,X:(R2+0x13),*-24
+*0x0000008E  0x824600130010         bfset       #0x10,X:(R2+0x13)
+*0x00000091  0xA961                 bra         *-30
+*/
 const uint16_t pgm_write_pflash[] = {0x8A46,0x0013,0x407D,0xE700,0xE700,0x8A44,0xFFFE,0x017B,0xE700,0xF514,0x8563,0x8646,0x0020,0x0014,0x8646,0x0080,0x0013,0x8A46,0x0013,0x2004,0x8246,0x0013,0x0020,0xA968,0x8A46,0x0013,0x1065,0x8246,0x0013,0x0010,0xA961};
 const uint32_t pgm_write_pflash_length = 31;
 
@@ -1211,8 +1351,8 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   int retval = ERROR_OK;
   uint16_t* buff16 = (uint16_t *) buffer;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
-    retval = dsp5680xx_halt(target);
-	err_check_propagate(retval);
+    retval = eonce_enter_debug_mode(target,NULL);
+    err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Download the pgm that flashes.
@@ -1302,8 +1442,6 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   return retval;
 }
 
-
-
 int dsp5680xx_f_unlock(struct target * target){
   int retval;
   if(target-&gt;tap-&gt;enabled){
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 50ab990..a574724 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -25,6 +25,19 @@
 
 #include &lt;jtag/jtag.h&gt;
 
+/**
+ * @file   dsp5680xx.h
+ * @author Rodrigo Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
+ * @date   Thu Jun  9 18:54:38 2011
+ * 
+ * @brief  Basic support for the 5680xx DSP from Freescale.
+ * The chip has two taps in the JTAG chain, the Master tap and the Core tap.
+ * In this code the Master tap is only used to unlock the flash memory by executing a JTAG instruction.
+ * 
+ * 
+ */
+
+
 #define S_FILE_DATA_OFFSET 0x200000
 
 //----------------------------------------------------------------
@@ -160,6 +173,11 @@
 #define HFM_USTAT_MASK_BLANK 0x4
 #define HFM_USTAT_MASK_PVIOL_ACCER 0x30
 
+/**
+ * The value used on for the FM clock is important to prevent flashing errors and to prevent deterioration of the FM.
+ * This value was calculated using a spreadsheet tool available on the Freescale website under FAQ 25464.
+ * 
+ */
 #define HFM_CLK_DEFAULT	0x40
 #define HFM_FLASH_BASE_ADDR 0x0
 #define HFM_SIZE_BYTES 0x4000 // bytes
@@ -168,10 +186,12 @@
 #define HFM_SECTOR_COUNT 0x20
 // A 16K block in pages of 256 words.
 
+/**
+ * Writing HFM_LOCK_FLASH to HFM_LOCK_ADDR_L and HFM_LOCK_ADDR_H will enable security on flash after the next reset.
+ */
 #define HFM_LOCK_FLASH 0xE70A
 #define HFM_LOCK_ADDR_L 0x1FF7
 #define HFM_LOCK_ADDR_H 0x1FF8
-// Writing HFM_LOCK_FLASH to HFM_LOCK_ADDR_L and HFM_LOCK_ADDR_H will enable security on flash after the next reset.
 //----------------------------------------------------------------
 
 //----------------------------------------------------------------
@@ -203,12 +223,69 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
   return target-&gt;arch_info;
 }
 
+/** 
+ * Writes to flash memory.
+ * Does not check if flash is erased, it's up to the user to erase the flash before running this function.
+ * 
+ * @param target 
+ * @param buffer 
+ * @param address 
+ * @param count In bytes. 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
 
+/** 
+ * The FM has the funcionality of checking if the flash array is erased. This function executes it. It does not support individual sector analysis.
+ * 
+ * @param target 
+ * @param erased 
+ * @param sector This parameter is ignored because the FM does not support checking if individual sectors are erased.
+ * 
+ * @return 
+ */
 int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased, uint32_t sector);
+
+/** 
+ * Erases either a sector or the complete flash array. If either the range first-last covers the complete array or if @first == 0 and @last == 0 then a mass erase command is executed on the FM. If not, then individual sectors are erased.
+ * 
+ * @param target 
+ * @param first 
+ * @param last 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_erase(struct target * target, int first, int last);
+
+/** 
+ * Reads the memory mapped protection register.
+ * 
+ * @param target 
+ * @param protected Data read from the protection register.
+ * 
+ * @return 
+ */
 int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected);
+
+/** 
+ * Writes the flash security words with a specific value. The chip's security will be enabled after the first reset following the execution of this function.
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_lock(struct target * target);
+
+/** 
+ * Executes a mass erase command. The must be done from the Master tap.
+ * It is up to the user to select the master tap (jtag tapenable dsp5680xx.chp) before running this function.
+ * The flash array will be unsecured (and erased) after the first reset following the execution of this function.
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_unlock(struct target * target);
 
 #endif // dsp5680xx.h

commit cbe201fe6bb2f004957ff8174b53c6d4ecd5bae6
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:23:52 2011 -0700

    fix protection behavior

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 9fa7b06..b919f56 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -96,18 +96,10 @@ static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
 static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first, int last){
   // This applies security to flash module after next reset, it does not actually apply protection (protection refers to undesired access from the core)
   int retval;
-  if(set){
+  if(set)
     retval = dsp5680xx_f_lock(bank-&gt;target);
-    if(retval == ERROR_OK){
-      for(int i = first;i&lt;last;i++)
-	bank-&gt;sectors[i].is_protected = 1;
-    }
-  }else{
+  else
     retval = dsp5680xx_f_unlock(bank-&gt;target);
-    if(retval == ERROR_OK)
-      for(int i = first;i&lt;last;i++)
-	bank-&gt;sectors[i].is_protected = 0;
-  }
   return retval;
 }
 
@@ -140,10 +132,13 @@ static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint3
     return ERROR_FAIL;
   }
   retval = dsp5680xx_f_wr(bank-&gt;target,  buffer, bank-&gt;base + offset/2,  count);
-  if(retval == ERROR_OK)
-    bank-&gt;sectors[0].is_erased = 0;
-  else
-    bank-&gt;sectors[0].is_erased = -1;
+  uint32_t addr_word;
+  for(addr_word = bank-&gt;base + offset/2;addr_word&lt;count/2;addr_word+=(HFM_SECTOR_SIZE/2)){
+    if(retval == ERROR_OK)
+      bank-&gt;sectors[addr_word/(HFM_SECTOR_SIZE/2)].is_erased = 0;
+    else
+      bank-&gt;sectors[addr_word/(HFM_SECTOR_SIZE/2)].is_erased = -1;
+  }
   return retval;
 }
 

commit 7b0ead520dcf6969954f42255a01e63b89f96cd6
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:23:34 2011 -0700

    cleanup trailing whitespaces

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 4e7a0b6..9fa7b06 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -3,7 +3,7 @@
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>                                              *
  *                                                                         *
  *   Based on a file written by:                                           *
- *   Kevin McGuire                                                         * 
+ *   Kevin McGuire                                                         *
  *   Marcel Wijlaars                                                       *
  *   Michael Ashton                                                        *
  *                                                                         *
@@ -102,7 +102,7 @@ static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first,
       for(int i = first;i&lt;last;i++)
 	bank-&gt;sectors[i].is_protected = 1;
     }
-  }else{    
+  }else{
     retval = dsp5680xx_f_unlock(bank-&gt;target);
     if(retval == ERROR_OK)
       for(int i = first;i&lt;last;i++)
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 7c28327..bde1700 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2935,7 +2935,7 @@ static int minimodule_init(void)
 		LOG_ERROR(&quot;couldn't initialize FT2232 with 'minimodule' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 
 	nSRST    = 0x20;
 
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 3db31d3..f3f25a1 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -726,11 +726,11 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
 	err_check_propagate(retval);
     context.flush = 0;
   }
-  
+
   context.flush = 1;
   retval = dsp5680xx_execute_queue();
   err_check_propagate(retval);
-  
+
   return retval;
 }
 
@@ -913,7 +913,7 @@ static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint3
     return ERROR_OK;
   }
   // read_buffer is called when the verify_image command is executed.
-  // The &quot;/2&quot; solves the byte/word addressing issue. 
+  // The &quot;/2&quot; solves the byte/word addressing issue.
   return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
@@ -1120,14 +1120,14 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
     *erased = (uint8_t)(hfm_ustat&amp;HFM_USTAT_MASK_BLANK);
   return retval;
 }
-  
+
 static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_PAGE_ERASE,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,hfm_ustat,1);
   err_check_propagate(retval);
   return retval;
 }
- 
+
 static int mass_erase(struct target * target, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_MASS_ERASE,0,0,hfm_ustat,1);
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index da494c9..50ab990 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -114,13 +114,13 @@
 #define DSP5680XX_ONCE_OPDBR    0x08 /* EOnCE Program Data Bus Register (OPDBR) */
 #define DSP5680XX_ONCE_OTX1     0x09 /* EOnCE Upper Transmit register (OTX1) */
 #define DSP5680XX_ONCE_OPABFR   0x0A /* OnCE Program Address Register&#226;&#128;&#148;Fetch cycle */
-#define DSP5680XX_ONCE_ORX      0x0B /* EOnCE Receive register (ORX) */ 
+#define DSP5680XX_ONCE_ORX      0x0B /* EOnCE Receive register (ORX) */
 #define DSP5680XX_ONCE_OCNTR_C  0x0C /* Clear OCNTR */
 #define DSP5680XX_ONCE_ORX1     0x0D /* EOnCE Upper Receive register (ORX1) */
 #define DSP5680XX_ONCE_OTBCR    0x0E /* EOnCE Trace Buffer Control Reg (OTBCR) */
 #define DSP5680XX_ONCE_OPABER   0x10 /* OnCE Program Address Register&#226;&#128;&#148;Execute cycle */
 #define DSP5680XX_ONCE_OPFIFO   0x11 /* OnCE Program address FIFO */
-#define DSP5680XX_ONCE_OBAR1    0x12 /* EOnCE Breakpoint 1 Unit 0 Address Reg.(OBAR1) */ 
+#define DSP5680XX_ONCE_OBAR1    0x12 /* EOnCE Breakpoint 1 Unit 0 Address Reg.(OBAR1) */
 #define DSP5680XX_ONCE_OPABDR   0x13 /* OnCE Program Address Register&#226;&#128;&#148;Decode cycle (OPABDR) */
 //----------------------------------------------------------------
 
@@ -179,7 +179,7 @@
 //----------------------------------------------------------------
 #define MC568013_EONCE_OBASE_ADDR 0xFF
 // The following are relative to EONCE_OBASE_ADDR (EONCE_OBASE_ADDR&lt;&lt;16 + ...)
-#define MC568013_EONCE_TX_RX_ADDR    0xFFFE // 
+#define MC568013_EONCE_TX_RX_ADDR    0xFFFE //
 #define MC568013_EONCE_TX1_RX1_HIGH_ADDR  0xFFFF // Relative to EONCE_OBASE_ADDR
 #define MC568013_EONCE_OCR 0xFFA0 // Relative to EONCE_OBASE_ADDR
 //----------------------------------------------------------------

commit f4b9a2fc8bbc682e957276a0012199a606c919b0
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:23:17 2011 -0700

    flash speed improved

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 1f26b69..3db31d3 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -1230,6 +1230,9 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Setup registers needed by pgm_write_pflash
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+
+  context.flush = 0;
+
   retval = eonce_move_long_to_r3(target,address);  // Destination address to r3
   err_check_propagate(retval);
   eonce_load_TX_RX_high_to_r0(target);  // TX/RX reg address to r0
@@ -1256,6 +1259,11 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	retval = ERROR_FAIL;
 	err_check(retval,&quot;Cannot handle odd number of words.&quot;);
   }
+
+  context.flush = 1;
+  retval = dsp5680xx_execute_queue();
+  err_check_propagate(retval);
+
   uint32_t drscan_data;
   retval = eonce_tx_upper_data(target,buff16[0],&amp;drscan_data);
   err_check_propagate(retval);

commit ca76e4a4231e665309c7f11a6be741067ef3b09c
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:21:49 2011 -0700

    removed unnecessary actions/controls

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index d1c1d19..1f26b69 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -246,7 +246,6 @@ static int eonce_read_status_reg(struct target * target, uint16_t * data){
 
 static int dsp5680xx_halt(struct target *target){
   int retval;
-  uint8_t jtag_status;
   uint16_t eonce_status;
   if(target-&gt;state == TARGET_HALTED){
     LOG_USER(&quot;Target already halted.&quot;);
@@ -254,8 +253,6 @@ static int dsp5680xx_halt(struct target *target){
   }
   retval = eonce_enter_debug_mode(target,&amp;eonce_status);
   err_check_propagate(retval);
-  retval = dsp5680xx_jtag_status(target,&amp;jtag_status);
-  err_check_propagate(retval);
   retval = eonce_pc_store(target);
   err_check_propagate(retval);
   //TODO is it useful to store the pc?
@@ -268,17 +265,7 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
     return ERROR_OK;
   }
   int retval;
-  uint8_t jtag_status;
-  uint16_t eonce_status;
-
-  // Verify that EOnCE is enabled (enable it if necessary)
-  uint16_t data_read_from_dr = 0;
-  retval = eonce_read_status_reg(target,&amp;data_read_from_dr);
-  err_check_propagate(retval);
-  if((data_read_from_dr&amp;DSP5680XX_ONCE_OSCR_DEBUG_M) != DSP5680XX_ONCE_OSCR_DEBUG_M){
-    retval = eonce_enter_debug_mode(target,NULL);
-	err_check_propagate(retval);
-  }
+  uint8_t eonce_status;
   if(!current){
     retval = eonce_move_value_to_pc(target,address);
     err_check_propagate(retval);
@@ -286,21 +273,17 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
 
   int retry = 20;
   while(retry-- &gt; 1){
-    retval = eonce_exit_debug_mode(target,(uint8_t *)&amp;eonce_status );
-	err_check_propagate(retval);
-    retval = dsp5680xx_jtag_status(target,&amp;jtag_status);
+    retval = eonce_exit_debug_mode(target,&amp;eonce_status );
 	err_check_propagate(retval);
-    if((jtag_status &amp; 0xff) == JTAG_STATUS_NORMAL){
+    if(eonce_status == DSP5680XX_ONCE_OSCR_NORMAL_M)
       break;
-    }
   }
   if(retry == 0){
     retval = ERROR_TARGET_FAILURE;
 	err_check(retval,&quot;Failed to resume...&quot;);
   }else{
     target-&gt;state = TARGET_RUNNING;
-  };
-  LOG_DEBUG(&quot;JTAG status: 0x%02X.&quot;,jtag_status);
+  }
   LOG_DEBUG(&quot;EOnCE status: 0x%02X.&quot;,eonce_status);
   return ERROR_OK;
 }
@@ -916,25 +899,12 @@ static int dsp5680xx_bulk_write_memory(struct target * target,uint32_t address,
   return ERROR_FAIL;
 }
 
-// Writes to pram at address
-// r3 holds the destination address-&gt; p:(r3)
-// r2 hold 0xf151 to flash a led (probably cannot see it due to high freq.)
-// r0 holds TX/RX address.
-//0x00000073  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
-//0x00000076  0xE700                 nop
-//0x00000077  0xF514                 move.w      X:(R0),Y0
-//0x00000078  0xE700                 nop
-//0x00000079  0x8563                 move.w      Y0,P:(R3)+
-//0x0000007A  0x84420003             bfchg       #3,X:(R2)
-//0x0000007C  0xA976                 bra         *-9
-uint16_t pgm_write_pram[] = {0x8A44,0xFFFE,0x017D,0xE700,0xF514,0xE700,0x8563,0x8442,0x0003,0xA976};
-uint16_t pgm_write_pram_length = 10;
-
 static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint32_t size, const uint8_t * buffer){
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // this solution works, but it's slow. it flushes USB all the time.
+  if(target-&gt;state != TARGET_HALTED){
+    LOG_USER(&quot;Target must be halted.&quot;);
+    return ERROR_OK;
+  }
   return dsp5680xx_write(target, address, 1, size, buffer);
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 }
 
 static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){

commit c4bcb0b95a8d3ee9baf7046b6768976d8a4eb134
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:21:22 2011 -0700

    cleanup flash module command

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index da9ba46..d1c1d19 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -1029,6 +1029,9 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
       err_check(retval,&quot;FM execute command failed.&quot;);
     }
   }while (!(i&amp;0x40));				// wait until current command is complete
+
+  context.flush = 0;
+
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG);	// write to HFM_CNFG (lock=0, select bank) -- flash_desc.bank&amp;0x03,0x01 == 0x00,0x01 ???
   err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);		// write to HMF_USTAT, clear PVIOL, ACCERR &amp; BLANK bits
@@ -1056,6 +1059,11 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x80,HFM_USTAT);		// start the command
   err_check_propagate(retval);
+
+  context.flush = 1;
+  retval = dsp5680xx_execute_queue();
+  err_check_propagate(retval);
+
   watchdog = 100;
   do{
     retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
@@ -1070,6 +1078,10 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
     }
   }while (!(i&amp;0x40));	    // wait until the command is complete
   *hfm_ustat = i;
+  if (i&amp;HFM_USTAT_MASK_PVIOL_ACCER){
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,&quot;pviol and/or accer bits set. HFM command execution error&quot;);
+  }
   return ERROR_OK;
 }
 
@@ -1120,10 +1132,6 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   }
   retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&amp;hfm_ustat,1);
   err_check_propagate(retval);
-  if (hfm_ustat&amp;HFM_USTAT_MASK_PVIOL_ACCER){
-    retval = ERROR_TARGET_FAILURE;
-    err_check(retval,&quot;HFM exec error:pviol and/or accer bits set.&quot;);
-  }
   retval = dsp5680xx_read_16_single(target, HFM_BASE_ADDR|HFM_DATA, signature, 0);
   return retval;
 }
@@ -1138,10 +1146,6 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
   // Check if chip is already erased.
   retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,&amp;hfm_ustat,1); // blank check
   err_check_propagate(retval);
-  if (hfm_ustat&amp;HFM_USTAT_MASK_PVIOL_ACCER){
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,&quot;pviol and/or accer bits set. EraseVerify HFM command execution error&quot;);;
-  }
   if(erased!=NULL)
     *erased = (uint8_t)(hfm_ustat&amp;HFM_USTAT_MASK_BLANK);
   return retval;

commit d539fc856f4c09e3a3b683c2b1b5766652ab9d7a
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:20:59 2011 -0700

    fix read for verify_image

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index f503e08..da9ba46 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -942,35 +942,13 @@ static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint3
     LOG_USER(&quot;Target must be halted.&quot;);
     return ERROR_OK;
   }
-  // byte addressing!
-  int retval = ERROR_OK;
-  int pmem = 1;
-  uint16_t tmp_wrd= 0;
-
-  retval = dsp5680xx_convert_address(&amp;address, &amp;pmem);
-  err_check_propagate(retval);
-
-  for (unsigned i=0; i&lt;size; i++)
-    if(!(i%2)){
-      retval = dsp5680xx_read_16_single(target, address + i/2, &amp;tmp_wrd, pmem);
-	  err_check_propagate(retval);
-      //TODO find a better solution. endiannes differs from normal read, otherwise the openocd crc would do weird stuff.
-      buffer[i+1] = (uint8_t) (tmp_wrd&gt;&gt;8);
-      buffer[i] = (uint8_t) (tmp_wrd&amp;0xff);
-   }
-  return retval;
+  // read_buffer is called when the verify_image command is executed.
+  // The &quot;/2&quot; solves the byte/word addressing issue. 
+  return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
 static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
- //TODO implement.
-  //This will make openocd do the work, but it will fail because of the word/byte addressing issues.
-  int retval;
-  struct working_area * crc_algorithm;
-  retval = target_alloc_working_area(target, 20, &amp;crc_algorithm);
-  if(retval != ERROR_OK)
-    return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-  retval = target_free_working_area(target, crc_algorithm);
-  return ERROR_FAIL;
+  return ERROR_FAIL;// This will make OpenOCD do the read out the data and verify it.
 }
 
 // Data signature algorithm used by the core FM (flash module)

commit f42353d82137d0a3f5e2433bae931c82b8407c74
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:20:18 2011 -0700

    fix read speed improved by queueing commands

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index c79ee3a..f503e08 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -714,7 +714,14 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   retval = dsp5680xx_convert_address(&amp;address, &amp;pmem);
   err_check_propagate(retval);
 
+  context.flush = 0;
+  int counter = FLUSH_COUNT_READ_WRITE;
+
   for (unsigned i=0; i&lt;count; i++){
+    if(--counter==0){
+      context.flush = 1;
+      counter = FLUSH_COUNT_FLASH;
+    }
     switch (size){
     case 1:
       if(!(i%2)){
@@ -734,7 +741,13 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
       break;
     }
 	err_check_propagate(retval);
+    context.flush = 0;
   }
+  
+  context.flush = 1;
+  retval = dsp5680xx_execute_queue();
+  err_check_propagate(retval);
+  
   return retval;
 }
 

commit f4a3db0d4a353ccc6d701a2645390ef9039e0d02
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:19:58 2011 -0700

    fix flash driver size, sector erase

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index e9c4e82..4e7a0b6 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -41,17 +41,13 @@ struct dsp5680xx_flash_bank {
 };
 
 static int dsp5680xx_build_sector_list(struct flash_bank *bank){
-  //LOG_USER(&quot;%s not implemented&quot;,__FUNCTION__);
-  //return ERROR_OK;
-
-  // sector size is 512
-  // bank-&gt;num_sectors = bank-&gt;size / 512; // Bank size is actually 0x2000, but it is set much higher as part of the workaround for byte/word addressing issues.
+  uint32_t offset = HFM_FLASH_BASE_ADDR;
   bank-&gt;sectors = malloc(sizeof(struct flash_sector) * bank-&gt;num_sectors);
   int i;
   for (i = 0; i &lt; bank-&gt;num_sectors; ++i){
-    bank-&gt;sectors[i].offset = 0;// not implemented.
+    bank-&gt;sectors[i].offset = i*HFM_SECTOR_SIZE;
     bank-&gt;sectors[i].size = HFM_SECTOR_SIZE;
-    //offset += bank-&gt;sectors[i].size;
+    offset += bank-&gt;sectors[i].size;
     bank-&gt;sectors[i].is_erased = -1;
     bank-&gt;sectors[i].is_protected = -1;
   }
@@ -67,9 +63,9 @@ FLASH_BANK_COMMAND_HANDLER(dsp5680xx_flash_bank_command){
   nbank = malloc(sizeof(struct dsp5680xx_flash_bank));
 
   bank-&gt;base = HFM_FLASH_BASE_ADDR;
-  bank-&gt;size = HFM_SIZE; // top 4k not accessible
+  bank-&gt;size = HFM_SIZE_BYTES; // top 4k not accessible
   bank-&gt;driver_priv = nbank;
-  bank-&gt;num_sectors = HFM_SECTOR_COUNT;// This number is anything &gt;0. not really used.
+  bank-&gt;num_sectors = HFM_SECTOR_COUNT;
   dsp5680xx_build_sector_list(bank);
 
   return ERROR_OK;
@@ -77,30 +73,40 @@ FLASH_BANK_COMMAND_HANDLER(dsp5680xx_flash_bank_command){
 
 static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
   int retval = ERROR_OK;
-  uint8_t protected = 0; 
-  if(bank-&gt;sectors[0].is_protected == -1){
+  uint16_t protected = 0;
     retval = dsp5680xx_f_protect_check(bank-&gt;target,&amp;protected);
-    if(retval == ERROR_OK)
-      if(protected)
-	bank-&gt;sectors[0].is_protected = 1;
-      else
-	bank-&gt;sectors[0].is_protected = 0;
-    else
-      bank-&gt;sectors[0].is_protected = -1;
+  if(retval != ERROR_OK){
+    for(int i = 0;i&lt;HFM_SECTOR_COUNT;i++)
+      bank-&gt;sectors[i].is_protected = -1;
+    return ERROR_OK;
+  }
+  for(int i = 0;i&lt;HFM_SECTOR_COUNT/2;i++){
+    if(protected &amp; 1){
+      bank-&gt;sectors[2*i].is_protected = 1;
+      bank-&gt;sectors[2*i+1].is_protected = 1;
+    }else{
+      bank-&gt;sectors[2*i].is_protected = 0;
+      bank-&gt;sectors[2*i+1].is_protected = 0;
+    }
+    protected = (protected &gt;&gt; 1);
   }
   return retval;
 }
 
 static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first, int last){
+  // This applies security to flash module after next reset, it does not actually apply protection (protection refers to undesired access from the core)
   int retval;
   if(set){
     retval = dsp5680xx_f_lock(bank-&gt;target);
-    if(retval == ERROR_OK)
-      bank-&gt;sectors[0].is_protected = 1;
+    if(retval == ERROR_OK){
+      for(int i = first;i&lt;last;i++)
+	bank-&gt;sectors[i].is_protected = 1;
+    }
   }else{    
     retval = dsp5680xx_f_unlock(bank-&gt;target);
     if(retval == ERROR_OK)
-      bank-&gt;sectors[0].is_protected = 0;
+      for(int i = first;i&lt;last;i++)
+	bank-&gt;sectors[i].is_protected = 0;
   }
   return retval;
 }
@@ -167,24 +173,30 @@ static int dsp5680xx_flash_erase(struct flash_bank * bank, int first, int last){
   int retval;
   retval = dsp5680xx_f_erase(bank-&gt;target, (uint32_t) first, (uint32_t) last);
   if(retval == ERROR_OK)
-    bank-&gt;sectors[0].is_erased = 1;
+    for(int i = first;i&lt;=last;i++)
+      bank-&gt;sectors[i].is_erased = 1;
   else
-    bank-&gt;sectors[0].is_erased = -1;
+	// If an error occurred unknown status is set even though some sector could have been correctly erased.
+    for(int i = first;i&lt;=last;i++)
+      bank-&gt;sectors[i].is_erased = -1;
   return retval;
 }
 
 static int dsp5680xx_flash_erase_check(struct flash_bank * bank){
   int retval = ERROR_OK;
   uint8_t erased = 0;
-  if(bank-&gt;sectors[0].is_erased == -1){
-    retval = dsp5680xx_f_erase_check(bank-&gt;target,&amp;erased);
+  uint32_t i;
+  for(i=0;i&lt;HFM_SECTOR_COUNT;i++){
+    if(bank-&gt;sectors[i].is_erased == -1){
+      retval = dsp5680xx_f_erase_check(bank-&gt;target,&amp;erased,i);
     if (retval != ERROR_OK){
-      bank-&gt;sectors[0].is_erased = -1;
+	bank-&gt;sectors[i].is_erased = -1;
     }else{
       if(erased)
-	bank-&gt;sectors[0].is_erased = 1;
+	bank-&gt;sectors[i].is_erased = 1;
       else
-	bank-&gt;sectors[0].is_erased = 0;
+	bank-&gt;sectors[i].is_erased = 0;
+      }
     }
   }
   return retval;
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 9eba374..c79ee3a 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -244,17 +244,6 @@ static int eonce_read_status_reg(struct target * target, uint16_t * data){
   return retval;
 }
 
-static int dsp5680xx_obase_addr(struct target * target, uint32_t * addr){
-  // Finds out the default value of the OBASE register address.
-  int retval;
-  uint32_t data_to_shift_into_dr;// just to make jtag happy
-  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OBASE,1,0,0,NULL);
-  err_check_propagate(retval);
-  retval = dsp5680xx_drscan(target,(uint8_t *)&amp; data_to_shift_into_dr,(uint8_t *) addr, 8);
-  err_check_propagate(retval);
-  return retval;
-}
-
 static int dsp5680xx_halt(struct target *target){
   int retval;
   uint8_t jtag_status;
@@ -614,24 +603,15 @@ static int eonce_move_value_to_pc(struct target * target, uint32_t value)
 
 static int eonce_load_TX_RX_to_r0(struct target * target)
 {
-  uint32_t obase_addr;
-  int retval = dsp5680xx_obase_addr(target,&amp; obase_addr);
-  err_check_propagate(retval);
-  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(obase_addr&lt;&lt;16)));
+  int retval;
+  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(MC568013_EONCE_OBASE_ADDR&lt;&lt;16)));
   return retval;
 }
 
 static int eonce_load_TX_RX_high_to_r0(struct target * target)
 {
-  uint32_t obase_addr;
-  int retval = dsp5680xx_obase_addr(target,&amp; obase_addr);
-  err_check_propagate(retval);
-  if(!(obase_addr &amp;&amp; 0xff)){
-	LOG_USER(&quot;%s: OBASE address read as 0x%04X instead of 0xFF.&quot;,__FUNCTION__,obase_addr);
-	return ERROR_FAIL;
-  }
-  eonce_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(obase_addr&lt;&lt;16)));
-  err_check_propagate(retval);
+  int retval = 0;
+  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(MC568013_EONCE_OBASE_ADDR&lt;&lt;16)));
   return retval;
 }
 
@@ -804,11 +784,11 @@ static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t
   uint16_t * data_w = (uint16_t *)data;
   uint32_t iter;
 
-  int counter = FLUSH_COUNT_WRITE;
+  int counter = FLUSH_COUNT_READ_WRITE;
   for(iter = 0; iter&lt;count/2; iter++){
     if(--counter==0){
       context.flush = 1;
-      counter = FLUSH_COUNT_WRITE;
+      counter = FLUSH_COUNT_READ_WRITE;
     }
     retval = dsp5680xx_write_16_single(target,address+iter,data_w[iter], pmem);
     if(retval != ERROR_OK){
@@ -843,14 +823,12 @@ static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t
 	err_check(retval,&quot;Target must be halted.&quot;);
   };
   uint32_t iter;
-
-  int counter_reset = FLUSH_COUNT_WRITE;
-  int counter = counter_reset;
+  int counter = FLUSH_COUNT_READ_WRITE;
 
   for(iter = 0; iter&lt;count; iter++){
 	if(--counter==0){
 	  context.flush = 1;
-	  counter = counter_reset;
+      counter = FLUSH_COUNT_READ_WRITE;
 	}
     retval = dsp5680xx_write_16_single(target,address+iter,data[iter], pmem);
     if(retval != ERROR_OK){
@@ -871,14 +849,12 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
 	err_check(retval,&quot;Target must be halted.&quot;);
   };
   uint32_t iter;
-
-  int counter_reset = FLUSH_COUNT_WRITE;
-  int counter = counter_reset;
+  int counter = FLUSH_COUNT_READ_WRITE;
 
   for(iter = 0; iter&lt;count; iter++){
 	if(--counter==0){
 	  context.flush = 1;
-	  counter = counter_reset;
+      counter = FLUSH_COUNT_READ_WRITE;
 	}
     retval = dsp5680xx_write_32_single(target,address+(iter&lt;&lt;1),data[iter], pmem);
     if(retval != ERROR_OK){
@@ -1026,29 +1002,19 @@ static int dsp5680xx_soft_reset_halt(struct target *target){
   return retval;
 }
 
-int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected) {
-  uint16_t i,j;
+int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
+  uint16_t aux;
   int retval;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
 	err_check_propagate(retval);
   }
-  retval = eonce_load_TX_RX_high_to_r0(target);
-  err_check_propagate(retval);
-  retval = eonce_move_value_to_y0(target,0x1234);
-  err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
-  err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,&amp;i);
-  err_check_propagate(retval);
-  retval = eonce_move_value_to_y0(target,0x4321);
-  err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
-  err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,&amp;j);
+  if(protected == NULL){
+    err_check(ERROR_FAIL,&quot;NULL pointer not valid.&quot;);
+  }
+  retval = dsp5680xx_read_16_single(target,HFM_BASE_ADDR|HFM_PROT,&amp;aux,0);
   err_check_propagate(retval);
-  if(protected!=NULL)
-    *protected = (uint8_t) ((i!=0x1234)||(j!=0x4321));
+  *protected = aux;
   return retval;
 }
 
@@ -1171,32 +1137,15 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   return retval;
 }
 
-int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
+int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t sector){
   int retval;
   uint16_t hfm_ustat;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
     err_check_propagate(retval);
   }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Check security
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint8_t protected;
-  retval = dsp5680xx_f_protect_check(target,&amp;protected);
-  err_check_propagate(retval);
-  if(protected){
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,&quot;Failed to erase, flash is still protected.&quot;);
-  }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Set hfmdiv
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  retval = eonce_set_hfmdiv(target);
-  err_check_propagate(retval);
-
   // Check if chip is already erased.
-  // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
-  retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,0,&amp;hfm_ustat,1); // blank check
+  retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,&amp;hfm_ustat,1); // blank check
   err_check_propagate(retval);
   if (hfm_ustat&amp;HFM_USTAT_MASK_PVIOL_ACCER){
 	retval = ERROR_TARGET_FAILURE;
@@ -1206,17 +1155,25 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
     *erased = (uint8_t)(hfm_ustat&amp;HFM_USTAT_MASK_BLANK);
   return retval;
 }
+  
+static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
+  int retval;
+  retval = dsp5680xx_f_execute_command(target,HFM_PAGE_ERASE,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,hfm_ustat,1);
+  err_check_propagate(retval);
+  return retval;
+}
+ 
+static int mass_erase(struct target * target, uint16_t * hfm_ustat){
+  int retval;
+  retval = dsp5680xx_f_execute_command(target,HFM_MASS_ERASE,0,0,hfm_ustat,1);
+  return retval;
+}
 
 int dsp5680xx_f_erase(struct target * target, int first, int last){
-  //TODO implement erasing individual sectors.
   int retval;
-  if(first||last){
-	retval = ERROR_FAIL;
-	err_check(retval,&quot;Sector erasing not implemented. Call with first=last=0.&quot;);
-  }
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
-	err_check_propagate(retval);
+    err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Reset SIM
@@ -1224,49 +1181,25 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
   retval = dsp5680xx_f_SIM_reset(target);
   err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Check security
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint8_t protected;
-  retval = dsp5680xx_f_protect_check(target,&amp;protected);
-  err_check_propagate(retval);
-  if(protected){
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,&quot;Cannot flash, security is still enabled.&quot;);
-  }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = eonce_set_hfmdiv(target);
   err_check_propagate(retval);
 
-  // Check if chip is already erased.
-  // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
-  uint8_t erased;
-  retval = dsp5680xx_f_erase_check(target,&amp;erased);
-  err_check_propagate(retval);
-  if (erased)
-    LOG_USER(&quot;Flash blank - mass erase skipped.&quot;);
-  else{
-    // Execute mass erase command.
-	uint16_t hfm_ustat;
-	uint16_t hfm_cmd = HFM_MASS_ERASE;
-	retval = dsp5680xx_f_execute_command(target,hfm_cmd,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,0,&amp;hfm_ustat,1);
-	err_check_propagate(retval);
-    if (hfm_ustat&amp;HFM_USTAT_MASK_PVIOL_ACCER){
-	  retval = ERROR_TARGET_FAILURE;
-	  err_check(retval,&quot;pviol and/or accer bits set. HFM command execution error&quot;);
-    }
-    // Verify flash was successfully erased.
-    retval = dsp5680xx_f_erase_check(target,&amp;erased);
+  uint16_t hfm_ustat;
+  int do_mass_erase = ((!(first|last)) || ((first==0)&amp;&amp;(last == (HFM_SECTOR_COUNT-1))));
+  if(do_mass_erase){
+    //Mass erase
+    retval = mass_erase(target,&amp;hfm_ustat);
+    err_check_propagate(retval);
+    last = HFM_SECTOR_COUNT-1;
+  }else{
+    for(int i = first;i&lt;=last;i++){
+      retval = erase_sector(target,i,&amp;hfm_ustat);
 	err_check_propagate(retval);
-	if(retval == ERROR_OK){
-      if (erased)
-		LOG_USER(&quot;Flash mass erased and checked blank.&quot;);
-      else
-		LOG_WARNING(&quot;Flash mass erased, but still not blank!&quot;);
-    }
   }
-  return retval;
+  }
+  return ERROR_OK;
 }
 
 // Algorithm for programming normal p: flash
@@ -1317,16 +1250,6 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Check if flash is erased
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint8_t erased;
-  retval = dsp5680xx_f_erase_check(target,&amp;erased);
-  err_check_propagate(retval);
-  if(!erased){
-	retval = ERROR_FAIL;
-	err_check(retval,&quot;Flash must be erased before flashing.&quot;);
-  }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Download the pgm that flashes.
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint32_t my_favourite_ram_address = 0x8700; // This seems to be a safe address. This one is the one used by codewarrior in 56801x_flash.cfg
@@ -1375,14 +1298,13 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   retval = dsp5680xx_resume(target,0,my_favourite_ram_address,0,0);
   err_check_propagate(retval);
 
-  int counter_reset = FLUSH_COUNT_FLASH;
-  int counter = counter_reset;
+  int counter = FLUSH_COUNT_FLASH;
   context.flush = 0;
   uint32_t i;
-  for(i=1; (i&lt;count/2)&amp;&amp;(i&lt;HFM_SIZE_REAL); i++){
+  for(i=1; (i&lt;count/2)&amp;&amp;(i&lt;HFM_SIZE_WORDS); i++){
     if(--counter==0){
       context.flush = 1;
-      counter = counter_reset;
+      counter = FLUSH_COUNT_FLASH;
     }
     retval = eonce_tx_upper_data(target,buff16[i],&amp;drscan_data);
 	if(retval!=ERROR_OK){
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 9f66ee7..da494c9 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -124,8 +124,8 @@
 #define DSP5680XX_ONCE_OPABDR   0x13 /* OnCE Program Address Register&#226;&#128;&#148;Decode cycle (OPABDR) */
 //----------------------------------------------------------------
 
-#define FLUSH_COUNT_WRITE 4095 // This value works, higher values (and lower...) may work as well.
-#define FLUSH_COUNT_FLASH 7 // Waiting for longer queues will cause flashing errors.
+#define FLUSH_COUNT_READ_WRITE 8192 // This value works, higher values (and lower...) may work as well.
+#define FLUSH_COUNT_FLASH 8192
 //----------------------------------------------------------------
 // HFM (flash module) Commands (ref:<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">MC56F801xRM.pdf at 159</A>)
 //----------------------------------------------------------------
@@ -160,12 +160,13 @@
 #define HFM_USTAT_MASK_BLANK 0x4
 #define HFM_USTAT_MASK_PVIOL_ACCER 0x30
 
-#define HFM_CLK_DEFAULT	0x29
+#define HFM_CLK_DEFAULT	0x40
 #define HFM_FLASH_BASE_ADDR 0x0
-#define HFM_SIZE 0x8000 // This is not true for 56F8013, but it is necessary to get the byte/word addressing workaround to actually work.
-#define HFM_SIZE_REAL 0x2000
-#define HFM_SECTOR_SIZE 0x8000 // 512 bytes pages.
-#define HFM_SECTOR_COUNT 1
+#define HFM_SIZE_BYTES 0x4000 // bytes
+#define HFM_SIZE_WORDS 0x2000 // words
+#define HFM_SECTOR_SIZE 0x200 // Size in bytes
+#define HFM_SECTOR_COUNT 0x20
+// A 16K block in pages of 256 words.
 
 #define HFM_LOCK_FLASH 0xE70A
 #define HFM_LOCK_ADDR_L 0x1FF7
@@ -204,9 +205,9 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
 
 int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
 
-int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased);
+int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased, uint32_t sector);
 int dsp5680xx_f_erase(struct target * target, int first, int last);
-int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected);
+int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected);
 int dsp5680xx_f_lock(struct target * target);
 int dsp5680xx_f_unlock(struct target * target);
 

commit 56d3927abf2d2c6c49f3ae6ad6c2f353168d5a60
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.lg at gmail.com</A>&gt;
Date:   Fri Jun 10 12:19:32 2011 -0700

    Added minimodule (ftdi) interface

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 8c2382a..7c28327 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -177,6 +177,7 @@ static int lm3s811_jtag_init(void);
 static int icdi_jtag_init(void);
 static int olimex_jtag_init(void);
 static int flyswatter_init(void);
+static int minimodule_init(void);
 static int turtle_init(void);
 static int comstick_init(void);
 static int stm32stick_init(void);
@@ -197,6 +198,7 @@ static void ftx23_reset(int trst, int srst);
 static void jtagkey_reset(int trst, int srst);
 static void olimex_jtag_reset(int trst, int srst);
 static void flyswatter_reset(int trst, int srst);
+static void minimodule_reset(int trst, int srst);
 static void turtle_reset(int trst, int srst);
 static void comstick_reset(int trst, int srst);
 static void stm32stick_reset(int trst, int srst);
@@ -261,6 +263,10 @@ static const struct ft2232_layout  ft2232_layouts[] =
 		.reset = flyswatter_reset,
 		.blink = flyswatter_jtag_blink
 	},
+	{ .name = &quot;minimodule&quot;,
+		.init = minimodule_init,
+		.reset = minimodule_reset,
+	},
 	{ .name = &quot;turtelizer2&quot;,
 		.init = turtle_init,
 		.reset = turtle_reset,
@@ -1565,6 +1571,24 @@ static void flyswatter_reset(int trst, int srst)
 	LOG_DEBUG(&quot;trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x&quot;, trst, srst, low_output, low_direction);
 }
 
+static void minimodule_reset(int trst, int srst)
+{
+	if (srst == 1)
+	{
+		low_output &amp;= ~nSRST;
+	}
+	else if (srst == 0)
+	{
+		low_output |= nSRST;
+	}
+
+	/* command &quot;set data bits low byte&quot; */
+	buffer_write(0x80);
+	buffer_write(low_output);
+	buffer_write(low_direction);
+	LOG_DEBUG(&quot;trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x&quot;, trst, srst, low_output, low_direction);
+}
+
 static void turtle_reset(int trst, int srst)
 {
 	trst = trst;
@@ -2900,6 +2924,37 @@ static int flyswatter_init(void)
 	return ERROR_OK;
 }
 
+static int minimodule_init(void)
+{
+	low_output    = 0x18;//check if srst should be 1 or 0 initially. (0x08) (flyswatter was 0x18)
+	low_direction = 0xfb;//0xfb;
+
+	/* initialize low byte for jtag */
+	if (ft2232_set_data_bits_low_byte(low_output,low_direction) != ERROR_OK)
+	{
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'minimodule' layout&quot;);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	
+
+	nSRST    = 0x20;
+
+	high_output    = 0x00;
+	high_direction = 0x05;
+
+	/* turn red LED3 on, LED2 off */
+	//high_output |= 0x08;
+
+	/* initialize high byte for jtag */
+	if (ft2232_set_data_bits_high_byte(high_output,high_direction) != ERROR_OK)
+	{
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'minimodule' layout&quot;);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
 static int turtle_init(void)
 {
 	low_output    = 0x08;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/dsp5680xx_flash.c |  173 ++++---
 src/jtag/drivers/ft2232.c       |   55 ++
 src/target/dsp5680xx.c          | 1037 ++++++++++++++++++++-------------------
 src/target/dsp5680xx.h          |  105 ++++-
 tcl/interface/minimodule.cfg    |   10 +
 5 files changed, 798 insertions(+), 582 deletions(-)
 create mode 100644 tcl/interface/minimodule.cfg


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002618.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-906-ge899fca
</A></li>
	<LI>Next message: <A HREF="002620.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-919-g1b0862c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2619">[ date ]</a>
              <a href="thread.html#2619">[ thread ]</a>
              <a href="subject.html#2619">[ subject ]</a>
              <a href="author.html#2619">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
