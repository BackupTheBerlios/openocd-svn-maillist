From gowinex at users.sourceforge.net  Wed Mar  2 19:07:30 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  2 Mar 2011 18:07:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-776-g0eed61b
Message-ID: <mailman.18.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0eed61b7c4cb31338562db426cea0d1a999e0d9f (commit)
       via  b992dd58f1bef87c35e942efef6070915dc74a37 (commit)
       via  99cd373019c51af9f623b71fa17b3f3aa29e1b73 (commit)
       via  2ed3f5554768791d29e017825a8866677ed4a533 (commit)
      from  e5677ce9e523550f0de36d77b46461645a764cb3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0eed61b7c4cb31338562db426cea0d1a999e0d9f
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Feb 28 20:40:47 2011 +0100

    jlink: add jlink_pid to specify the pid to use
    
    this will allow us to use multiple jlink at the same time as when
    the USB-Address is specified the PID change from 0x0101 to
    (0x101 + usb_adress)
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 5b12386..353daa4 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2323,6 +2323,8 @@ Segger jlink USB adapter
 @c     dumps status
 @c command:	jlink hw_jtag (2|3)
 @c     sets version 2 or 3
+ at c command:	 jlink pid
+ at c     set the pid of the interface we want to use
 @end deffn
 
 @deffn {Interface Driver} {parport}
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 8a2c5ab..faecab2 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -136,6 +136,10 @@ static enum tap_state jlink_last_state = TAP_RESET;
 
 static struct jlink* jlink_handle;
 
+/* pid could be specified at runtime */
+static uint16_t vids[] = { VID, 0 };
+static uint16_t pids[] = { PID, 0 };
+
 /***************************************************************************/
 /* External interface implementation */
 
@@ -621,6 +625,21 @@ static int jlink_get_version_info(void)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(jlink_pid_command)
+{
+	if (CMD_ARGC != 1)
+	{
+		LOG_ERROR("Need exactly one argument to jlink_pid");
+		return ERROR_FAIL;
+	}
+
+	pids[0] = strtoul(CMD_ARGV[0], NULL, 16);
+	pids[1] = 0;
+	vids[1] = 0;
+
+	return ERROR_OK;
+}
+
 COMMAND_HANDLER(jlink_handle_jlink_info_command)
 {
 	if (jlink_get_version_info() == ERROR_OK)
@@ -670,6 +689,12 @@ static const struct command_registration jlink_subcommand_handlers[] = {
 		.help = "access J-Link HW JTAG command version",
 		.usage = "[2|3]",
 	},
+	{
+		.name = "pid",
+		.handler = &jlink_pid_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set the pid of the interface we want to use",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -871,8 +896,6 @@ static struct jlink* jlink_usb_open()
 {
 	usb_init();
 
-	const uint16_t vids[] = { VID, 0 };
-	const uint16_t pids[] = { PID, 0 };
 	struct usb_dev_handle *dev;
 	if (jtag_usb_open(vids, pids, &dev) != ERROR_OK)
 		return NULL;

commit b992dd58f1bef87c35e942efef6070915dc74a37
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Feb 28 20:40:46 2011 +0100

    jlink: switch commands to subcommands
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 7772d78..5b12386 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2319,9 +2319,9 @@ This is a write-once setting.
 
 @deffn {Interface Driver} {jlink}
 Segger jlink USB adapter
- at c command:	jlink_info
+ at c command:	jlink info
 @c     dumps status
- at c command:	jlink_hw_jtag (2|3)
+ at c command:	jlink hw_jtag (2|3)
 @c     sets version 2 or 3
 @end deffn
 
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index b182b61..8a2c5ab 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -656,15 +656,15 @@ COMMAND_HANDLER(jlink_handle_jlink_hw_jtag_command)
 	return ERROR_OK;
 }
 
-static const struct command_registration jlink_command_handlers[] = {
+static const struct command_registration jlink_subcommand_handlers[] = {
 	{
-		.name = "jlink_info",
+		.name = "info",
 		.handler = &jlink_handle_jlink_info_command,
 		.mode = COMMAND_EXEC,
 		.help = "show jlink info",
 	},
 	{
-		.name = "jlink_hw_jtag",
+		.name = "hw_jtag",
 		.handler = &jlink_handle_jlink_hw_jtag_command,
 		.mode = COMMAND_EXEC,
 		.help = "access J-Link HW JTAG command version",
@@ -673,6 +673,16 @@ static const struct command_registration jlink_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static const struct command_registration jlink_command_handlers[] = {
+	{
+		.name = "jlink",
+		.mode = COMMAND_ANY,
+		.help = "perform jlink management",
+		.chain = jlink_subcommand_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
 struct jtag_interface jlink_interface = {
 	.name = "jlink",
 	.commands = jlink_command_handlers,

commit 99cd373019c51af9f623b71fa17b3f3aa29e1b73
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Feb 28 20:40:45 2011 +0100

    jlink: harmonise the device name to J-Link
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index f1b9711..b182b61 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -580,7 +580,7 @@ static int jlink_get_version_info(void)
 	}
 
 	jlink_caps = buf_get_u32(usb_in_buffer, 0, 32);
-	LOG_INFO("JLink caps 0x%x", (unsigned)jlink_caps);
+	LOG_INFO("J-Link caps 0x%x", (unsigned)jlink_caps);
 
 	if (jlink_caps & (1 << EMU_CAP_GET_HW_VERSION))
 	{
@@ -599,7 +599,7 @@ static int jlink_get_version_info(void)
 		if (major_revision >= 5)
 			jlink_hw_jtag_version = 3;
 
-		LOG_INFO("JLink hw version %i", (int)jlink_hw_version);
+		LOG_INFO("J-Link hw version %i", (int)jlink_hw_version);
 	}
 
 	if (jlink_caps & (1 << EMU_CAP_GET_MAX_BLOCK_SIZE))
@@ -615,7 +615,7 @@ static int jlink_get_version_info(void)
 		}
 
 		jlink_max_size = buf_get_u32(usb_in_buffer, 0, 32);
-		LOG_INFO("JLink max mem block %i", (int)jlink_max_size);
+		LOG_INFO("J-Link max mem block %i", (int)jlink_max_size);
 	}
 
 	return ERROR_OK;
@@ -636,7 +636,7 @@ COMMAND_HANDLER(jlink_handle_jlink_hw_jtag_command)
 {
 	switch (CMD_ARGC) {
 	case 0:
-		command_print(CMD_CTX, "jlink hw jtag  %i", jlink_hw_jtag_version);
+		command_print(CMD_CTX, "J-Link hw jtag  %i", jlink_hw_jtag_version);
 		break;
 	case 1: {
 		int request_version = atoi(CMD_ARGV[0]);

commit 2ed3f5554768791d29e017825a8866677ed4a533
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Feb 28 20:40:44 2011 +0100

    jlink: add new PID and VID
    
    The default pid of the segger is 0x0101
    But when you change the USB Address it will also
    
    pid = ( usb_address > 0x4) ? 0x0101 : (0x101 + usb_address)
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index bc5448d..f1b9711 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -37,8 +37,14 @@
 http://www.segger.com/cms/admin/uploads/productDocs/RM08001_JLinkUSBProtocol.pdf
  */
 
-#define VID 0x1366
-#define PID 0x0101
+/*
+ * The default pid of the segger is 0x0101
+ * But when you change the USB Address it will also
+ *
+ * pid = ( usb_address > 0x4) ? 0x0101 : (0x101 + usb_address)
+ */
+#define VID 0x1366, 0x1366, 0x1366, 0x1366
+#define PID 0x0101, 0x0102, 0x0103, 0x0104
 
 #define JLINK_WRITE_ENDPOINT	0x02
 #define JLINK_READ_ENDPOINT		0x81

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi         |    6 +++-
 src/jtag/drivers/jlink.c |   61 +++++++++++++++++++++++++++++++++++++--------
 2 files changed, 54 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar  3 22:49:59 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  3 Mar 2011 21:49:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-782-gdf500c5
Message-ID: <mailman.19.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  df500c5a0494decd708ddebe8ed1efed081ded55 (commit)
       via  a4bf71386b2fce8864363c64c2ce2584ad2d1907 (commit)
       via  aebc0d5556089a4f1df9b0281685534386e9cea7 (commit)
       via  f6783d4465fb3cbde06239b9e2e071ec105e99a0 (commit)
       via  26db0a6bef8444d5d3e03a7576014494c506d0a2 (commit)
       via  e941805713fd2ad8b7f9740ae789b8a1f5b645ff (commit)
      from  0eed61b7c4cb31338562db426cea0d1a999e0d9f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit df500c5a0494decd708ddebe8ed1efed081ded55
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Wed Mar 2 12:57:08 2011 +0100

    at91: add at91sam9g45 support
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/target/at91sam9g45.cfg b/tcl/target/at91sam9g45.cfg
new file mode 100644
index 0000000..7323679
--- /dev/null
+++ b/tcl/target/at91sam9g45.cfg
@@ -0,0 +1,16 @@
+######################################
+# Target:    Atmel AT91SAM9G45
+######################################
+
+if { [info exists CHIPNAME] } {
+	set AT91_CHIPNAME $CHIPNAME
+} else {
+	set AT91_CHIPNAME at91sam9g45
+}
+
+source [find target/at91sam9.cfg]
+
+# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
+# AT91SAM9G45 has one SRAM area starting at 0x00300000 of 64 KiB.
+
+$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x200000 -work-area-backup 1

commit a4bf71386b2fce8864363c64c2ce2584ad2d1907
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Wed Mar 2 12:57:07 2011 +0100

    at91: add at91sam9g10 support
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/target/at91sam9g10.cfg b/tcl/target/at91sam9g10.cfg
new file mode 100644
index 0000000..b49f3d9
--- /dev/null
+++ b/tcl/target/at91sam9g10.cfg
@@ -0,0 +1,16 @@
+######################################
+# Target:    Atmel AT91SAM9G10
+######################################
+
+if { [info exists CHIPNAME] } {
+	set AT91_CHIPNAME $CHIPNAME
+} else {
+	set AT91_CHIPNAME at91sam9g10
+}
+
+source [find target/at91sam9.cfg]
+
+# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
+# AT91SAM9G10 has one SRAM area at 0x00300000 of 16KiB
+
+$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x4000 -work-area-backup 1

commit aebc0d5556089a4f1df9b0281685534386e9cea7
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Wed Mar 2 12:57:06 2011 +0100

    at91sam9260: update sram information
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/target/at91sam9260.cfg b/tcl/target/at91sam9260.cfg
index 9f79dfa..c5a07fd 100644
--- a/tcl/target/at91sam9260.cfg
+++ b/tcl/target/at91sam9260.cfg
@@ -10,5 +10,10 @@ if { [info exists CHIPNAME] } {
 
 source [find target/at91sam9.cfg]
 
-# Internal sram1 memory
+
+# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
+# AT91SAM9260 has two SRAM areas, one starting at 0x00200000 and the other starting at 0x00300000.
+# Both areas are 4 kB long.
+
+#$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x1000 -work-area-backup 1
 $_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1

commit f6783d4465fb3cbde06239b9e2e071ec105e99a0
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Wed Mar 2 12:57:05 2011 +0100

    at91: add at91sam9263 support
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/target/at91sam9263.cfg b/tcl/target/at91sam9263.cfg
new file mode 100644
index 0000000..d2ee113
--- /dev/null
+++ b/tcl/target/at91sam9263.cfg
@@ -0,0 +1,20 @@
+######################################
+# Target:    Atmel AT91SAM9263
+######################################
+
+if { [info exists CHIPNAME] } {
+	set AT91_CHIPNAME $CHIPNAME
+} else {
+	set AT91_CHIPNAME at91sam9263
+}
+
+source [find target/at91sam9.cfg]
+
+# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
+# AT91SAM9263 has two SRAM areas,
+# one starting at 0x00300000 of 80KiB
+# and the other  starting at 0x00500000 of 16KiB.
+
+# Internal sram1 memory
+$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x14000 -work-area-backup 1
+#$_TARGETNAME configure -work-area-phys 0x00500000 -work-area-size 0x4000 -work-area-backup 1

commit 26db0a6bef8444d5d3e03a7576014494c506d0a2
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Wed Mar 2 12:57:04 2011 +0100

    at91: add at91sam9261 support
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/target/at91sam9261.cfg b/tcl/target/at91sam9261.cfg
new file mode 100644
index 0000000..3ad1411
--- /dev/null
+++ b/tcl/target/at91sam9261.cfg
@@ -0,0 +1,14 @@
+######################################
+# Target:    Atmel AT91SAM9261
+######################################
+
+if { [info exists CHIPNAME] } {
+	set AT91_CHIPNAME $CHIPNAME
+} else {
+	set AT91_CHIPNAME at91sam9261
+}
+
+source [find target/at91sam9.cfg]
+
+# Internal sram1 memory
+$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x28000 -work-area-backup 1

commit e941805713fd2ad8b7f9740ae789b8a1f5b645ff
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Wed Mar 2 12:57:03 2011 +0100

    at91sam9: factorise cpu support
    
    all at91sam9 are nearly the same except sram and soc name
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index deb4da1..741d601 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -9,13 +9,9 @@
 #
 #	source [find target/...cfg]
 
-# Define basic characteristics for the CPU.  The AT91SAM9G20 processor is a subtle variant of
-# the AT91SAM9260 and shares the same tap ID as it.
+source [find target/at91sam9g20.cfg]
 
-set _CHIPNAME at91sam9g20
 set _FLASHTYPE nandflash_cs3
-set _ENDIAN little
-set _CPUTAPID 0x0792603f
 
 # Set reset type.  Note that the AT91SAM9G20-EK board has the trst signal disconnected.  Therefore
 # the reset needs to be configured for "srst_only".  If for some reason, a zero-ohm jumper is
@@ -23,31 +19,9 @@ set _CPUTAPID 0x0792603f
 
 reset_config srst_only
 
-# Set up the CPU and generate a new jtag tap for AT91SAM9G20.
-
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-# Use caution changing the delays listed below.  These seem to be
-# affected by the board and type of JTAG adapter.  A value of 200 ms seems
-# to work reliably for the configuration listed in the file header above.
-
 adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
-# Set fallback clock to 1/6 of worst-case clock speed (which would be the 32.768 kHz slow clock).
-
-jtag_rclk 5
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME
-
-# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
-# AT91SAM9G20 has two SRAM areas, one starting at 0x00200000 and the other starting at 0x00300000.
-# Both areas are 16 kB long.
-
-#$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 1
-$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x4000 -work-area-backup 1
-
 # If you don't want to execute built-in boot rom code (and there are good reasons at times not to do that) in the
 # AT91SAM9 family, the microcontroller is a lump on a log without initialization.  Because this family has
 # some powerful features, we want to have a special function that handles "reset init".  To do this we declare
diff --git a/tcl/target/at91sam9rl.cfg b/tcl/target/at91sam9.cfg
similarity index 60%
copy from tcl/target/at91sam9rl.cfg
copy to tcl/target/at91sam9.cfg
index 5ee5c49..ba0197d 100644
--- a/tcl/target/at91sam9rl.cfg
+++ b/tcl/target/at91sam9.cfg
@@ -1,24 +1,24 @@
 ######################################
-# Target:    Atmel AT91SAM9RL
+# Target:    Atmel AT91SAM9
 ######################################
 
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
+if { [info exists AT91_CHIPNAME] } {
+	set _CHIPNAME $AT91_CHIPNAME
 } else {
-   set  _CHIPNAME at91sam9rl
+	error "you must specify a chip name"
 }
 
 if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
+	set _ENDIAN $ENDIAN
 } else {
-   set  _ENDIAN little
+	set _ENDIAN little
 }
 
 if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
+	set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
-   set _CPUTAPID 0x0792603f
+	# force an error till we get a good number
+	set _CPUTAPID 0x0792603f
 }
 
 reset_config trst_and_srst separate trst_push_pull srst_open_drain
@@ -37,8 +37,3 @@ jtag_rclk 3
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
-
-# Internal sram1 memory
-$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x10000 -work-area-backup 1
-
-
diff --git a/tcl/target/at91sam9260.cfg b/tcl/target/at91sam9260.cfg
index 86258c6..9f79dfa 100644
--- a/tcl/target/at91sam9260.cfg
+++ b/tcl/target/at91sam9260.cfg
@@ -3,42 +3,12 @@
 ######################################
 
 if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
+	set AT91_CHIPNAME $CHIPNAME
 } else {
-   set  _CHIPNAME at91sam9260
+	set AT91_CHIPNAME at91sam9260
 }
 
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0x0792603f
-}
-
-reset_config trst_and_srst separate trst_push_pull srst_open_drain
-
-#
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-adapter_nsrst_delay 300
-jtag_ntrst_delay 200
-
-jtag_rclk 3
-
-######################
-# Target configuration
-######################
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+source [find target/at91sam9.cfg]
 
 # Internal sram1 memory
 $_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
-
-
diff --git a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
index 8acdebd..8df2852 100644
--- a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
+++ b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
@@ -1,48 +1,16 @@
-jtag_rclk 4
-
 ######################################
 # Target:    Atmel AT91SAM9260
 ######################################
 
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME at91sam9260
-}
-
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0x0792603f
-}
+source [find target/at91sam9261.cfg]
 
 reset_config trst_and_srst
 
+jtag_rclk 4
 
 adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
-
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-
-######################
-# Target configuration
-######################
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
-
-# Internal sram1 memory
-$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
-
 scan_chain
 $_TARGETNAME configure -event reset-start {
 	# at reset chip runs at 32khz
diff --git a/tcl/target/at91sam9g20.cfg b/tcl/target/at91sam9g20.cfg
new file mode 100644
index 0000000..8a2e69b
--- /dev/null
+++ b/tcl/target/at91sam9g20.cfg
@@ -0,0 +1,22 @@
+######################################
+# Target:    Atmel AT91SAM9G20
+######################################
+
+if { [info exists CHIPNAME] } {
+	set AT91_CHIPNAME $CHIPNAME
+} else {
+	set AT91_CHIPNAME at91sam9g20
+}
+
+source [find target/at91sam9.cfg]
+
+# Set fallback clock to 1/6 of worst-case clock speed (which would be the 32.768 kHz slow clock).
+
+jtag_rclk 5
+
+# Establish internal SRAM memory work areas that are important to pre-bootstrap loaders, etc.  The
+# AT91SAM9G20 has two SRAM areas, one starting at 0x00200000 and the other starting at 0x00300000.
+# Both areas are 16 kB long.
+
+#$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 1
+$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x4000 -work-area-backup 1
diff --git a/tcl/target/at91sam9rl.cfg b/tcl/target/at91sam9rl.cfg
index 5ee5c49..769c4f7 100644
--- a/tcl/target/at91sam9rl.cfg
+++ b/tcl/target/at91sam9rl.cfg
@@ -3,42 +3,12 @@
 ######################################
 
 if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
+   set  AT91_CHIPNAME $CHIPNAME
 } else {
-   set  _CHIPNAME at91sam9rl
+   set  AT91_CHIPNAME at91sam9rl
 }
 
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-  # force an error till we get a good number
-   set _CPUTAPID 0x0792603f
-}
-
-reset_config trst_and_srst separate trst_push_pull srst_open_drain
-
-#
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-adapter_nsrst_delay 300
-jtag_ntrst_delay 200
-
-jtag_rclk 3
-
-######################
-# Target configuration
-######################
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+source [find target/at91sam9.cfg]
 
 # Internal sram1 memory
 $_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x10000 -work-area-backup 1
-
-

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/at91sam9g20-ek.cfg                 |   28 +------------------
 tcl/target/{at91sam9rl.cfg => at91sam9.cfg}  |   23 ++++++---------
 tcl/target/at91sam9260.cfg                   |   39 ++++---------------------
 tcl/target/at91sam9260_ext_RAM_ext_flash.cfg |   36 +----------------------
 tcl/target/at91sam9261.cfg                   |   14 +++++++++
 tcl/target/at91sam9263.cfg                   |   20 +++++++++++++
 tcl/target/at91sam9g10.cfg                   |   16 ++++++++++
 tcl/target/at91sam9g20.cfg                   |   22 ++++++++++++++
 tcl/target/at91sam9g45.cfg                   |   16 ++++++++++
 tcl/target/at91sam9rl.cfg                    |   36 ++----------------------
 10 files changed, 110 insertions(+), 140 deletions(-)
 copy tcl/target/{at91sam9rl.cfg => at91sam9.cfg} (60%)
 create mode 100644 tcl/target/at91sam9261.cfg
 create mode 100644 tcl/target/at91sam9263.cfg
 create mode 100644 tcl/target/at91sam9g10.cfg
 create mode 100644 tcl/target/at91sam9g20.cfg
 create mode 100644 tcl/target/at91sam9g45.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar  3 23:04:03 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  3 Mar 2011 22:04:03 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-783-g0123985
Message-ID: <mailman.20.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0123985abc88876ca8ecd03e9a5462cc8e911693 (commit)
      from  df500c5a0494decd708ddebe8ed1efed081ded55 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0123985abc88876ca8ecd03e9a5462cc8e911693
Author: Mathias K <kesmtp at freenet.de>
Date:   Thu Mar 3 10:28:21 2011 +0100

    ft2232: fix log message and change log output to debug

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index a84d069..fdabb64 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2100,7 +2100,7 @@ static int ft2232_execute_queue(void)
 		if (ft2232_expect_read >= FT2232_BUFFER_READ_QUEUE_SIZE )
 		{
 			if (ft2232_expect_read > (FT2232_BUFFER_READ_QUEUE_SIZE+1) )
-				LOG_WARNING("read buffer size looks to high");
+				LOG_DEBUG("read buffer size looks too high %d/%d",ft2232_expect_read,(FT2232_BUFFER_READ_QUEUE_SIZE+1));
 			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
 				retval = ERROR_JTAG_QUEUE_FAILED;
 			first_unsent = cmd;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Mar 13 14:56:45 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 13 Mar 2011 13:56:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-787-g8e85bb4
Message-ID: <mailman.21.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8e85bb4eea739c4945190a76f7c0f4f13ebf2a21 (commit)
       via  2c4f7f1dd4b75f8d958ca66f971ead3adc81d24f (commit)
       via  bce76b80ccc1eca1f71327f27febf5c52b69b3ad (commit)
       via  952de89bfeac60bdca55add6ef0f7835ae00e66a (commit)
      from  0123985abc88876ca8ecd03e9a5462cc8e911693 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8e85bb4eea739c4945190a76f7c0f4f13ebf2a21
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Mar 7 15:11:29 2011 +0100

    jlink: add Emulator configuration support
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 48297ab..1749034 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2321,6 +2321,24 @@ This is a write-once setting.
 Segger jlink USB adapter
 @c command:	jlink caps
 @c     dumps jlink capabilities
+ at c command:	jlink config
+ at c     access J-Link configurationif no argument this will dump the config
+ at c command:	jlink config kickstart [val]
+ at c     set Kickstart power on JTAG-pin 19.
+ at c command:	jlink config mac_address [ff:ff:ff:ff:ff:ff]
+ at c     set the MAC Address
+ at c command:	jlink config ip [A.B.C.D[/E] [F.G.H.I]]
+ at c     set the ip address of the J-Link Pro, "
+ at c     where A.B.C.D is the ip,
+ at c     E the bit of the subnet mask
+ at c     F.G.H.I the subnet mask
+ at c command:	jlink config reset
+ at c     reset the current config
+ at c command:	jlink config save
+ at c     save the current config
+ at c command:	jlink config usb_address [0x00 to 0x03 or 0xff]
+ at c     set the USB-Address,
+ at c     This will change the product id
 @c command:	jlink info
 @c     dumps status
 @c command:	jlink hw_jtag (2|3)
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 174f7b3..aa5c359 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -5,6 +5,9 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   spen at spen-soft.co.uk                                                  *
  *                                                                         *
+ *   Copyright (C) 2011 by Jean-Christophe PLAGNIOL-VIILARD                *
+ *   plagnioj at jcrosoft.com                                                 *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -86,6 +89,8 @@ static uint8_t usb_emu_result_buffer[JLINK_EMU_RESULT_BUFFER_SIZE];
 #define EMU_CMD_HW_TRST1		0xdf
 #define EMU_CMD_GET_CAPS		0xe8
 #define EMU_CMD_GET_HW_VERSION	0xf0
+#define EMU_CMD_READ_CONFIG		0xf2
+#define EMU_CMD_WRITE_CONFIG		0xf3
 
 /* bits return from EMU_CMD_GET_CAPS */
 #define EMU_CAP_RESERVED_1		0
@@ -222,6 +227,25 @@ static uint16_t pids[] = { PID, 0 };
 static uint32_t jlink_caps;
 static uint32_t jlink_hw_type;
 
+/* 256 byte non-volatile memory */
+struct jlink_config {
+	uint8_t	usb_address;
+	/* 0ffset 0x01 to 0x03 */
+	uint8_t	reserved_1[3];
+	uint32_t kickstart_power_on_jtag_pin_19;
+	/* 0ffset 0x08 to 0x1f */
+	uint8_t reserved_2[24];
+	/* IP only for J-Link Pro */
+	uint8_t ip_address[4];
+	uint8_t subnet_mask[4];
+	/* 0ffset 0x28 to 0x2f */
+	uint8_t reserved_3[8];
+	uint8_t mac_address[6];
+	/* 0ffset 0x36 to 0xff */
+	uint8_t reserved_4[202];
+} __attribute__ ((packed));
+struct jlink_config jlink_cfg;
+
 /***************************************************************************/
 /* External interface implementation */
 
@@ -642,6 +666,107 @@ static void jlink_caps_dump(struct command_context *ctx)
 			jlink_dump_printf(ctx, "%s", jlink_cap_str[i]);
 }
 
+static void jlink_config_usb_address_dump(struct command_context *ctx, struct jlink_config *cfg)
+{
+	if (!cfg)
+		return;
+
+	jlink_dump_printf(ctx, "USB-Address: 0x%x", cfg->usb_address);
+}
+
+static void jlink_config_kickstart_dump(struct command_context *ctx, struct jlink_config *cfg)
+{
+	if (!cfg)
+		return;
+
+	jlink_dump_printf(ctx, "Kickstart power on JTAG-pin 19: 0x%x",
+		cfg->kickstart_power_on_jtag_pin_19);
+}
+
+static void jlink_config_mac_address_dump(struct command_context *ctx, struct jlink_config *cfg)
+{
+	if (!cfg)
+		return;
+
+	jlink_dump_printf(ctx, "MAC Address: %.02x:%.02x:%.02x:%.02x:%.02x:%.02x",
+		cfg->mac_address[5], cfg->mac_address[4],
+		cfg->mac_address[3], cfg->mac_address[2],
+		cfg->mac_address[1], cfg->mac_address[0]);
+}
+
+static void jlink_config_ip_dump(struct command_context *ctx, struct jlink_config *cfg)
+{
+	if (!cfg)
+		return;
+
+	jlink_dump_printf(ctx, "IP Address: %d.%d.%d.%d",
+		cfg->ip_address[3], cfg->ip_address[2],
+		cfg->ip_address[1], cfg->ip_address[0]);
+	jlink_dump_printf(ctx, "Subnet Mask: %d.%d.%d.%d",
+		cfg->subnet_mask[3], cfg->subnet_mask[2],
+		cfg->subnet_mask[1], cfg->subnet_mask[0]);
+}
+
+static void jlink_config_dump(struct command_context *ctx, struct jlink_config *cfg)
+{
+	if (!cfg)
+		return;
+
+	jlink_dump_printf(ctx, "J-Link configuration");
+	jlink_config_usb_address_dump(ctx, cfg);
+	jlink_config_kickstart_dump(ctx, cfg);
+
+	if (jlink_hw_type == JLINK_HW_TYPE_JLINK_PRO)
+	{
+		jlink_config_ip_dump(ctx, cfg);
+		jlink_config_mac_address_dump(ctx, cfg);
+	}
+}
+
+static int jlink_get_config(struct jlink_config *cfg)
+{
+	int result;
+	int size = sizeof(struct jlink_config);
+
+	jlink_simple_command(EMU_CMD_READ_CONFIG);
+
+	result = jlink_usb_read(jlink_handle, size);
+	if (size != result)
+	{
+		LOG_ERROR("jlink_usb_read failed (requested=%d, result=%d)", size, result);
+		return ERROR_FAIL;
+	}
+
+	memcpy(cfg, usb_in_buffer, size);
+
+	/*
+	 * Section 4.2.4 IN-transaction
+	 * read dummy 0-byte packet
+	 */
+	jlink_usb_read(jlink_handle, 1);
+
+	return ERROR_OK;
+}
+
+static int jlink_set_config(struct jlink_config *cfg)
+{
+	int result;
+	int size = sizeof(struct jlink_config);
+
+	jlink_simple_command(EMU_CMD_WRITE_CONFIG);
+
+	memcpy(usb_out_buffer, cfg, size);
+
+	result = jlink_usb_write(jlink_handle, size);
+	if (result != size)
+	{
+		LOG_ERROR("jlink_usb_write failed (requested=%d, result=%d)", 256, result);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
 static int jlink_get_version_info(void)
 {
 	int result;
@@ -730,6 +855,14 @@ static int jlink_get_version_info(void)
 		LOG_INFO("J-Link max mem block %i", (int)jlink_max_size);
 	}
 
+	if (jlink_caps & (1 << EMU_CAP_READ_CONFIG))
+	{
+		if (jlink_get_config(&jlink_cfg) != ERROR_OK)
+			return ERROR_JTAG_DEVICE_ERROR;
+
+		jlink_config_dump(NULL, &jlink_cfg);
+	}
+
 	return ERROR_OK;
 }
 
@@ -790,6 +923,262 @@ COMMAND_HANDLER(jlink_handle_jlink_hw_jtag_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(jlink_handle_jlink_kickstart_command)
+{
+	uint32_t kickstart;
+
+	if (CMD_ARGC < 1)
+	{
+		jlink_config_kickstart_dump(CMD_CTX, &jlink_cfg);
+		return ERROR_OK;
+	}
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], kickstart);
+
+	jlink_cfg.kickstart_power_on_jtag_pin_19 = kickstart;
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(jlink_handle_jlink_mac_address_command)
+{
+	uint8_t addr[6];
+	int i;
+	char *e;
+	const char *str;
+
+	if (CMD_ARGC < 1)
+	{
+		jlink_config_mac_address_dump(CMD_CTX, &jlink_cfg);
+		return ERROR_OK;
+	}
+
+	str = CMD_ARGV[0];
+
+	if ((strlen(str) != 17) || (str[2] != ':' || str[5] != ':' || str[8] != ':' ||
+		str[11] != ':' || str[14] != ':'))
+	{
+		command_print(CMD_CTX, "ethaddr miss format ff:ff:ff:ff:ff:ff");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	for (i = 5; i >= 0; i--)
+	{
+		addr[i] = strtoul(str, &e, 16);
+		str = e + 1;
+	}
+
+	if (!(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]))
+	{
+		command_print(CMD_CTX, "invalid it's zero mac_address");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (!(0x01 & addr[0]))
+	{
+		command_print(CMD_CTX, "invalid it's a multicat mac_address");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	memcpy(jlink_cfg.mac_address, addr, sizeof(addr));
+
+	return ERROR_OK;
+}
+
+static int string_to_ip(const char *s, uint8_t *ip, int *pos)
+{
+	uint8_t lip[4];
+	char *e;
+	const char *s_save = s;
+	int i;
+
+	if (!s)
+		return -EINVAL;
+
+	for (i = 0; i < 4; i++) {
+		lip[i] = strtoul(s, &e, 10);
+
+		if (*e != '.' && i != 3)
+			return -EINVAL;
+
+		s = e + 1;
+	}
+
+	*pos = e - s_save;
+
+	memcpy(ip, lip, sizeof(lip));
+	return ERROR_OK;
+}
+
+static void cpy_ip(uint8_t *dst, uint8_t *src)
+{
+	int i, j;
+
+	for (i = 0, j = 3; i < 4; i++, j--)
+		dst[i] = src[j];
+}
+
+COMMAND_HANDLER(jlink_handle_jlink_ip_command)
+{
+	uint32_t ip_address;
+	uint32_t subnet_mask = 0;
+	int i, len;
+	int ret;
+	uint8_t subnet_bits = 24;
+
+	if (CMD_ARGC < 1)
+	{
+		jlink_config_ip_dump(CMD_CTX, &jlink_cfg);
+		return ERROR_OK;
+	}
+
+	ret = string_to_ip(CMD_ARGV[0], (uint8_t*)&ip_address, &i);
+	if (ret != ERROR_OK)
+		return ret;
+
+	len = strlen(CMD_ARGV[0]);
+
+	/* check for this format A.B.C.D/E */
+
+	if (i < len)
+	{
+		if (CMD_ARGV[0][i] != '/')
+			return ERROR_COMMAND_SYNTAX_ERROR;
+
+		COMMAND_PARSE_NUMBER(u8, CMD_ARGV[0] + i + 1, subnet_bits);
+	}
+	else
+	{
+		if (CMD_ARGC > 1)
+		{
+			ret = string_to_ip(CMD_ARGV[1], (uint8_t*)&subnet_mask, &i);
+			if (ret != ERROR_OK)
+				return ret;
+		}
+	}
+
+	if (!subnet_mask)
+		subnet_mask = (uint32_t)(subnet_bits < 32 ?
+				((1ULL << subnet_bits) -1) : 0xffffffff);
+
+	cpy_ip(jlink_cfg.ip_address, (uint8_t*)&ip_address);
+	cpy_ip(jlink_cfg.subnet_mask, (uint8_t*)&subnet_mask);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(jlink_handle_jlink_reset_command)
+{
+	memset(&jlink_cfg, 0xff, sizeof(jlink_cfg));
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(jlink_handle_jlink_save_command)
+{
+	if (!(jlink_caps & (1 << EMU_CAP_WRITE_CONFIG)))
+	{
+		command_print(CMD_CTX, "J-Link write emulator configuration not supported");
+		return ERROR_OK;
+	}
+
+	command_print(CMD_CTX, "The J-Link need to be unpluged and repluged ta have the config effective");
+	return jlink_set_config(&jlink_cfg);
+}
+
+COMMAND_HANDLER(jlink_handle_jlink_usb_address_command)
+{
+	uint32_t address;
+
+	if (CMD_ARGC < 1)
+	{
+		jlink_config_usb_address_dump(CMD_CTX, &jlink_cfg);
+		return ERROR_OK;
+	}
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+
+	if (address > 0x3 && address != 0xff)
+	{
+		command_print(CMD_CTX, "USB Address must be between 0x00 and 0x03 or 0xff");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	jlink_cfg.usb_address = address;
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(jlink_handle_jlink_config_command)
+{
+	struct jlink_config cfg;
+	int ret = ERROR_OK;
+
+	if (CMD_ARGC == 0)
+	{
+		if (!(jlink_caps & (1 << EMU_CAP_READ_CONFIG)))
+		{
+			command_print(CMD_CTX, "J-Link read emulator configuration not supported");
+			goto exit;
+		}
+
+		ret = jlink_get_config(&cfg);
+
+		if ( ret != ERROR_OK)
+			command_print(CMD_CTX, "J-Link read emulator configuration failled");
+		else
+			jlink_config_dump(CMD_CTX, &jlink_cfg);
+	}
+
+exit:
+	return ret;
+}
+
+static const struct command_registration jlink_config_subcommand_handlers[] = {
+	{
+		.name = "kickstart",
+		.handler = &jlink_handle_jlink_kickstart_command,
+		.mode = COMMAND_EXEC,
+		.help = "set Kickstart power on JTAG-pin 19.",
+		.usage = "[val]",
+	},
+	{
+		.name = "mac_address",
+		.handler = &jlink_handle_jlink_mac_address_command,
+		.mode = COMMAND_EXEC,
+		.help = "set the MAC Address",
+		.usage = "[ff:ff:ff:ff:ff:ff]",
+	},
+	{
+		.name = "ip",
+		.handler = &jlink_handle_jlink_ip_command,
+		.mode = COMMAND_EXEC,
+		.help = "set the ip address of the J-Link Pro, "
+			"where A.B.C.D is the ip, "
+			"E the bit of the subnet mask, "
+			"F.G.H.I the subnet mask",
+		.usage = "[A.B.C.D[/E] [F.G.H.I]]",
+	},
+	{
+		.name = "reset",
+		.handler = &jlink_handle_jlink_reset_command,
+		.mode = COMMAND_EXEC,
+		.help = "reset the current config",
+	},
+	{
+		.name = "save",
+		.handler = &jlink_handle_jlink_save_command,
+		.mode = COMMAND_EXEC,
+		.help = "save the current config",
+	},
+	{
+		.name = "usb_address",
+		.handler = &jlink_handle_jlink_usb_address_command,
+		.mode = COMMAND_EXEC,
+		.help = "set the USB-Address, "
+			"This will change the product id",
+		.usage = "[0x00 to 0x03 or 0xff]",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
 static const struct command_registration jlink_subcommand_handlers[] = {
 	{
 		.name = "caps",
@@ -811,6 +1200,14 @@ static const struct command_registration jlink_subcommand_handlers[] = {
 		.usage = "[2|3]",
 	},
 	{
+		.name = "config",
+		.handler = &jlink_handle_jlink_config_command,
+		.mode = COMMAND_EXEC,
+		.help = "access J-Link configuration, "
+			"if no argument this will dump the config",
+		.chain = jlink_config_subcommand_handlers,
+	},
+	{
 		.name = "pid",
 		.handler = &jlink_pid_command,
 		.mode = COMMAND_CONFIG,

commit 2c4f7f1dd4b75f8d958ca66f971ead3adc81d24f
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Mar 7 15:11:28 2011 +0100

    jlink: add detect hw type
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 6507403..174f7b3 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -159,6 +159,20 @@ static char *jlink_cap_str[] = {
 /* max speed 12MHz v5.0 jlink */
 #define JLINK_MAX_SPEED 12000
 
+/* J-Link hardware versions */
+#define JLINK_HW_TYPE_JLINK	0
+#define JLINK_HW_TYPE_JTRACE	1
+#define JLINK_HW_TYPE_FLASHER	2
+#define JLINK_HW_TYPE_JLINK_PRO	3
+#define JLINK_HW_TYPE_MAX	4
+
+static char *jlink_hw_type_str[] = {
+	"J-Link",
+	"J-Trace",
+	"Flasher",
+	"J-Link Pro",
+};
+
 /* Queue command functions */
 static void jlink_end_state(tap_state_t state);
 static void jlink_state_move(void);
@@ -206,6 +220,7 @@ static uint16_t vids[] = { VID, 0 };
 static uint16_t pids[] = { PID, 0 };
 
 static uint32_t jlink_caps;
+static uint32_t jlink_hw_type;
 
 /***************************************************************************/
 /* External interface implementation */
@@ -687,10 +702,16 @@ static int jlink_get_version_info(void)
 
 		uint32_t jlink_hw_version = buf_get_u32(usb_in_buffer, 0, 32);
 		uint32_t major_revision = (jlink_hw_version / 10000) % 100;
+		jlink_hw_type = (jlink_hw_version / 1000000) % 100;
 		if (major_revision >= 5)
 			jlink_hw_jtag_version = 3;
 
 		LOG_INFO("J-Link hw version %i", (int)jlink_hw_version);
+
+		if (jlink_hw_type >= JLINK_HW_TYPE_MAX)
+			LOG_INFO("J-Link hw type uknown 0x%x", jlink_hw_type);
+		else
+			LOG_INFO("J-Link hw type %s", jlink_hw_type_str[jlink_hw_type]);
 	}
 
 	if (jlink_caps & (1 << EMU_CAP_GET_MAX_BLOCK_SIZE))

commit bce76b80ccc1eca1f71327f27febf5c52b69b3ad
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Mar 7 15:11:27 2011 +0100

    jlink: use tap buffer as 2k
    
    as said in the datasheet Section 3.3.2 Organization of buffers
    
    All buffers are big enough to hold 2 KByte of data.
    
    this will double the speed of download
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index d0ce658..6507403 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -55,10 +55,10 @@ static unsigned int jlink_hw_jtag_version = 2;
 
 #define JLINK_USB_TIMEOUT		1000
 
-// See Section 1.3.2 of the Segger JLink USB protocol manual
+// See Section 3.3.2 of the Segger JLink USB protocol manual
 /* 2048 is the max value we can use here */
-//#define JLINK_TAP_BUFFER_SIZE 2048
-#define JLINK_TAP_BUFFER_SIZE 256
+#define JLINK_TAP_BUFFER_SIZE 2048
+//#define JLINK_TAP_BUFFER_SIZE 256
 //#define JLINK_TAP_BUFFER_SIZE 384
 
 #define JLINK_IN_BUFFER_SIZE			2048

commit 952de89bfeac60bdca55add6ef0f7835ae00e66a
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Mar 7 15:11:26 2011 +0100

    jlink: add capability dumper and command
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 353daa4..48297ab 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2319,6 +2319,8 @@ This is a write-once setting.
 
 @deffn {Interface Driver} {jlink}
 Segger jlink USB adapter
+ at c command:	jlink caps
+ at c     dumps jlink capabilities
 @c command:	jlink info
 @c     dumps status
 @c command:	jlink hw_jtag (2|3)
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index faecab2..d0ce658 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -88,8 +88,73 @@ static uint8_t usb_emu_result_buffer[JLINK_EMU_RESULT_BUFFER_SIZE];
 #define EMU_CMD_GET_HW_VERSION	0xf0
 
 /* bits return from EMU_CMD_GET_CAPS */
+#define EMU_CAP_RESERVED_1		0
 #define EMU_CAP_GET_HW_VERSION		1
+#define EMU_CAP_WRITE_DCC		2
+#define EMU_CAP_ADAPTIVE_CLOCKING	3
+#define EMU_CAP_READ_CONFIG		4
+#define EMU_CAP_WRITE_CONFIG		5
+#define EMU_CAP_TRACE			6
+#define EMU_CAP_WRITE_MEM		7
+#define EMU_CAP_READ_MEM		8
+#define EMU_CAP_SPEED_INFO		9
+#define EMU_CAP_EXEC_CODE		10
 #define EMU_CAP_GET_MAX_BLOCK_SIZE	11
+#define EMU_CAP_GET_HW_INFO		12
+#define EMU_CAP_SET_KS_POWER		13
+#define EMU_CAP_RESET_STOP_TIMED	14
+#define EMU_CAP_RESERVED_2		15
+#define EMU_CAP_MEASURE_RTCK_REACT	16
+#define EMU_CAP_SELECT_IF		17
+#define EMU_CAP_RW_MEM_ARM79		18
+#define EMU_CAP_GET_COUNTERS		19
+#define EMU_CAP_READ_DCC		20
+#define EMU_CAP_GET_CPU_CAPS		21
+#define EMU_CAP_EXEC_CPU_CMD		22
+#define EMU_CAP_SWO			23
+#define EMU_CAP_WRITE_DCC_EX		24
+#define EMU_CAP_UPDATE_FIRMWARE_EX	25
+#define EMU_CAP_FILE_IO			26
+#define EMU_CAP_REGISTER		27
+#define EMU_CAP_INDICATORS		28
+#define EMU_CAP_TEST_NET_SPEED		29
+#define EMU_CAP_RAWTRACE		30
+#define EMU_CAP_RESERVED_3		31
+
+static char *jlink_cap_str[] = {
+	"Always 1.",
+	"Supports command EMU_CMD_GET_HARDWARE_VERSION",
+	"Supports command EMU_CMD_WRITE_DCC",
+	"Supports adaptive clocking",
+	"Supports command EMU_CMD_READ_CONFIG",
+	"Supports command EMU_CMD_WRITE_CONFIG",
+	"Supports trace commands",
+	"Supports command EMU_CMD_WRITE_MEM",
+	"Supports command EMU_CMD_READ_MEM",
+	"Supports command EMU_CMD_GET_SPEED",
+	"Supports command EMU_CMD_CODE_...",
+	"Supports command EMU_CMD_GET_MAX_BLOCK_SIZE",
+	"Supports command EMU_CMD_GET_HW_INFO",
+	"Supports command EMU_CMD_SET_KS_POWER",
+	"Supports command EMU_CMD_HW_RELEASE_RESET_STOP_TIMED",
+	"Reserved",
+	"Supports command EMU_CMD_MEASURE_RTCK_REACT",
+	"Supports command EMU_CMD_HW_SELECT_IF",
+	"Supports command EMU_CMD_READ/WRITE_MEM_ARM79",
+	"Supports command EMU_CMD_GET_COUNTERS",
+	"Supports command EMU_CMD_READ_DCC",
+	"Supports command EMU_CMD_GET_CPU_CAPS",
+	"Supports command EMU_CMD_EXEC_CPU_CMD",
+	"Supports command EMU_CMD_SWO",
+	"Supports command EMU_CMD_WRITE_DCC_EX",
+	"Supports command EMU_CMD_UPDATE_FIRMWARE_EX",
+	"Supports command EMU_CMD_FILE_IO",
+	"Supports command EMU_CMD_REGISTER",
+	"Supports command EMU_CMD_INDICATORS",
+	"Supports command EMU_CMD_TEST_NET_SPEED",
+	"Supports command EMU_CMD_RAWTRACE",
+	"Reserved",
+};
 
 /* max speed 12MHz v5.0 jlink */
 #define JLINK_MAX_SPEED 12000
@@ -140,6 +205,8 @@ static struct jlink* jlink_handle;
 static uint16_t vids[] = { VID, 0 };
 static uint16_t pids[] = { PID, 0 };
 
+static uint32_t jlink_caps;
+
 /***************************************************************************/
 /* External interface implementation */
 
@@ -540,11 +607,31 @@ static int jlink_get_status(void)
 	return ERROR_OK;
 }
 
+#define jlink_dump_printf(context, expr ...)	\
+	do {					\
+	if (context)				\
+		command_print(context, expr);	\
+	else					\
+		LOG_INFO(expr);			\
+	} while(0);
+
+
+static void jlink_caps_dump(struct command_context *ctx)
+{
+	int i;
+
+	jlink_dump_printf(ctx, "J-Link Capabilities");
+
+	for (i = 1; i < 31; i++)
+		if (jlink_caps & (1 << i))
+			jlink_dump_printf(ctx, "%s", jlink_cap_str[i]);
+}
+
 static int jlink_get_version_info(void)
 {
 	int result;
 	int len;
-	uint32_t jlink_caps, jlink_max_size;
+	uint32_t jlink_max_size;
 
 	/* query hardware version */
 	jlink_simple_command(EMU_CMD_VERSION);
@@ -651,6 +738,13 @@ COMMAND_HANDLER(jlink_handle_jlink_info_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(jlink_handle_jlink_caps_command)
+{
+	jlink_caps_dump(CMD_CTX);
+
+	return ERROR_OK;
+}
+
 COMMAND_HANDLER(jlink_handle_jlink_hw_jtag_command)
 {
 	switch (CMD_ARGC) {
@@ -677,6 +771,12 @@ COMMAND_HANDLER(jlink_handle_jlink_hw_jtag_command)
 
 static const struct command_registration jlink_subcommand_handlers[] = {
 	{
+		.name = "caps",
+		.handler = &jlink_handle_jlink_caps_command,
+		.mode = COMMAND_EXEC,
+		.help = "show jlink capabilities",
+	},
+	{
 		.name = "info",
 		.handler = &jlink_handle_jlink_info_command,
 		.mode = COMMAND_EXEC,

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi         |   20 ++
 src/jtag/drivers/jlink.c |  526 +++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 542 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Mar 13 15:03:43 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 13 Mar 2011 14:03:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-789-g59a6380
Message-ID: <mailman.22.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  59a6380a1701e0a270ad0fa08c6636f30705ba0c (commit)
       via  cc9939879cbb847a9f6c405082106be824ebf5ff (commit)
      from  8e85bb4eea739c4945190a76f7c0f4f13ebf2a21 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 59a6380a1701e0a270ad0fa08c6636f30705ba0c
Author: Aaron Carroll <aaronc at ok-labs.com>
Date:   Thu Mar 10 06:39:56 2011 +1100

    omap4430: add Blaze config
    
    Signed-off-by: Aaron Carroll <aaronc at ok-labs.com>

diff --git a/tcl/board/ti_blaze.cfg b/tcl/board/ti_blaze.cfg
new file mode 100644
index 0000000..c9bbe25
--- /dev/null
+++ b/tcl/board/ti_blaze.cfg
@@ -0,0 +1,6 @@
+jtag_rclk 6000
+
+source [find target/omap4430.cfg]
+
+reset_config trst_and_srst
+

commit cc9939879cbb847a9f6c405082106be824ebf5ff
Author: Aaron Carroll <aaronc at ok-labs.com>
Date:   Thu Mar 10 06:39:55 2011 +1100

    omap4430: force hardware breakpoints for GDB
    
    Soft breakpoints are currently broken if the MMU is enabled due to incorrect
    cache flushing.  Until this is fixed, force the use of hardware breakpoints.
    
    Signed-off-by: Aaron Carroll <aaronc at ok-labs.com>

diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
index 19b2d70..5bdb9d6 100644
--- a/tcl/target/omap4430.cfg
+++ b/tcl/target/omap4430.cfg
@@ -109,3 +109,6 @@ $_TARGETNAME configure -event reset-assert "$_TARGETNAME mww phys $PRM_RSTCTRL 0
 $_CHIPNAME.m30 configure -event reset-assert { }
 $_CHIPNAME.m31 configure -event reset-assert { }
 
+# Soft breakpoints don't currently work due to broken cache handling
+gdb_breakpoint_override hard
+

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/{ti_pandaboard.cfg => ti_blaze.cfg} |    2 +-
 tcl/target/omap4430.cfg                       |    3 +++
 2 files changed, 4 insertions(+), 1 deletions(-)
 copy tcl/board/{ti_pandaboard.cfg => ti_blaze.cfg} (65%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 15 10:19:24 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Mar 2011 09:19:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-790-g689c244
Message-ID: <mailman.23.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  689c244389798ef7fc041693831ae114b3063d36 (commit)
      from  59a6380a1701e0a270ad0fa08c6636f30705ba0c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 689c244389798ef7fc041693831ae114b3063d36
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 15 09:39:20 2011 +0100

    zy1000: reduce memory usage for fw upgrade fn
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 69fa4dc..3344e0e 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -438,24 +438,10 @@ struct cyg_upgrade_info firmware_info =
 		report_info,
 };
 
+// File written to /ram/firmware.phi before arriving at this fn
 static int jim_zy1000_writefirmware(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
-	if (argc != 2)
-		return JIM_ERR;
-
-	int length;
-	const char *str = Jim_GetString(argv[1], &length);
-
-	/* */
-	int tmpFile;
-	if ((tmpFile = open(firmware_info.file, O_RDWR | O_CREAT | O_TRUNC)) <= 0)
-	{
-		return JIM_ERR;
-	}
-	bool success;
-	success = write(tmpFile, str, length) == length;
-	close(tmpFile);
-	if (!success)
+	if (argc != 1)
 		return JIM_ERR;
 
 	if (!cyg_firmware_upgrade(NULL, firmware_info))

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   18 ++----------------
 1 files changed, 2 insertions(+), 16 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 15 10:37:31 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Mar 2011 09:37:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-791-gbb0d11c
Message-ID: <mailman.24.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bb0d11cba989832c0f27c2e5b664bfdc26b98cc9 (commit)
      from  689c244389798ef7fc041693831ae114b3063d36 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bb0d11cba989832c0f27c2e5b664bfdc26b98cc9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 3 09:14:30 2011 +0100

    jtag: clean up jtag_sleep, handle short sleeps correctly via usleep
    
    short sleeps are handled via usleep, longer sleeps we round up
    to nearest ms.
    
    There was a bug in jtag_sleep() in that it would round *down*
    to nearest ms, thus making all <1ms sleeps 0. Found by inspection
    rather than symptom.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index d7e1cce..68c1257 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -871,9 +871,16 @@ static int jtag_reset_callback(enum jtag_event event, void *priv)
 	return ERROR_OK;
 }
 
+/* sleep at least us microseconds. When we sleep more than 1000ms we
+ * do an alive sleep, i.e. keep GDB alive. Note that we could starve
+ * GDB if we slept for <1000ms many times.
+ */
 void jtag_sleep(uint32_t us)
 {
-	alive_sleep(us/1000);
+	if (us < 1000)
+		usleep(us);
+	else
+		alive_sleep((us+999)/1000);
 }
 
 /* Maximum number of enabled JTAG devices we expect in the scan chain,

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c |    9 ++++++++-
 1 files changed, 8 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 15 10:38:46 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Mar 2011 09:38:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-794-g9eeb02c
Message-ID: <mailman.25.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9eeb02c16510629f2431cf78c0fec00667db4fe6 (commit)
       via  2321bb3c42b1d47374e51d9e5aa548a37a70b53a (commit)
       via  4da640563b95939cd3fe9275053ba3181de723c4 (commit)
      from  bb0d11cba989832c0f27c2e5b664bfdc26b98cc9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9eeb02c16510629f2431cf78c0fec00667db4fe6
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 3 10:16:17 2011 +0100

    zy1000: switch to pthread
    
    pthreads work under Linux and eCos.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index f972191..71ae6f4 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -45,6 +45,8 @@
 #include "config.h"
 #endif
 
+#include <pthread.h>
+
 #include <target/embeddedice.h>
 #include <jtag/minidriver.h>
 #include <jtag/interface.h>
@@ -1026,7 +1028,6 @@ static const struct command_registration zy1000_commands[] = {
 };
 
 
-#if !BUILD_ZY1000_MASTER || BUILD_ECOSBOARD
 static int tcp_ip = -1;
 
 /* Write large packets if we can */
@@ -1098,7 +1099,6 @@ static bool readLong(uint32_t *out_data)
 	*out_data = data;
 	return true;
 }
-#endif
 
 enum ZY1000_CMD
 {
@@ -1353,14 +1353,15 @@ static void writeShiftValue(uint8_t *data, int bits)
 
 #endif
 
-#if BUILD_ECOSBOARD
-static char tcpip_stack[2048];
-static cyg_thread tcpip_thread_object;
-static cyg_handle_t tcpip_thread_handle;
+#if BUILD_ZY1000_MASTER
+
+pthread_t thread;
 
+#if BUILD_ECOSBOARD
 static char watchdog_stack[2048];
 static cyg_thread watchdog_thread_object;
 static cyg_handle_t watchdog_thread_handle;
+#endif
 
 /* Infinite loop peeking & poking */
 static void tcpipserver(void)
@@ -1412,7 +1413,7 @@ static void tcpipserver(void)
 }
 
 
-static void tcpip_server(cyg_addrword_t data)
+static void *tcpip_server(void *data)
 {
 	int so_reuseaddr_option = 1;
 
@@ -1474,8 +1475,10 @@ static void tcpip_server(cyg_addrword_t data)
 		close(tcp_ip);
 
 	}
+	/* Never reached actually */
 	close(fd);
 
+	return NULL;
 }
 
 #ifdef WATCHDOG_BASE
@@ -1616,12 +1619,10 @@ int zy1000_init(void)
 		return retval;
 	zy1000_speed(jtag_speed_var);
 
+#if BUILD_ZY1000_MASTER
+	pthread_create(&thread, NULL, tcpip_server, NULL);
 
 #if BUILD_ECOSBOARD
-	cyg_thread_create(1, tcpip_server, (cyg_addrword_t) 0, "tcip/ip server",
-			(void *) tcpip_stack, sizeof(tcpip_stack),
-			&tcpip_thread_handle, &tcpip_thread_object);
-	cyg_thread_resume(tcpip_thread_handle);
 #ifdef WATCHDOG_BASE
 	cyg_thread_create(1, watchdog_server, (cyg_addrword_t) 0, "watchdog tcip/ip server",
 			(void *) watchdog_stack, sizeof(watchdog_stack),
@@ -1629,6 +1630,7 @@ int zy1000_init(void)
 	cyg_thread_resume(watchdog_thread_handle);
 #endif
 #endif
+#endif
 
 	return ERROR_OK;
 }

commit 2321bb3c42b1d47374e51d9e5aa548a37a70b53a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 3 09:22:25 2011 +0100

    zy1000: fix JTAG over TCP/IP performance problem
    
    only flush write queue just before waiting for more data,
    rather than when fetching more data from the buffer.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index a8f7ffc..f972191 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1063,14 +1063,6 @@ static bool writeLong(uint32_t l)
 
 static bool readLong(uint32_t *out_data)
 {
-	if (out_pos > 0)
-	{
-		if (!flush_writes())
-		{
-			return false;
-		}
-	}
-
 	uint32_t data = 0;
 	int i;
 	for (i = 0; i < 4; i++)
@@ -1078,6 +1070,17 @@ static bool readLong(uint32_t *out_data)
 		uint8_t c;
 		if (in_pos == in_write)
 		{
+			/* If we have some data that we can send, send them before
+			 * we wait for more data
+			 */
+			if (out_pos > 0)
+			{
+				if (!flush_writes())
+				{
+					return false;
+				}
+			}
+
 			/* read more */
 			int t;
 			t = read(tcp_ip, in_buffer, sizeof(in_buffer));

commit 4da640563b95939cd3fe9275053ba3181de723c4
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 3 09:16:11 2011 +0100

    zy1000: fix incorrect usage of jtag_sleep()
    
    Found by inspection: the correct thing in the context is to use
    usleep() rather than jtag_sleep(). Relates to JTAG over TCP/IP
    only.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 3344e0e..a8f7ffc 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1393,7 +1393,8 @@ static void tcpipserver(void)
 				uint32_t data;
 				if (!readLong(&data))
 					return;
-				jtag_sleep(data);
+				/* Wait for some us */
+				usleep(data);
 				break;
 			}
 			case ZY1000_CMD_WAITIDLE:

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   46 ++++++++++++++++++++++++++--------------------
 1 files changed, 26 insertions(+), 20 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 17 07:26:32 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Mar 2011 06:26:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-797-g33a17fd
Message-ID: <mailman.26.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  33a17fd35995a7f679f92600055a8f55ae380022 (commit)
       via  582b4195a99a21caa9522713fae659621137e0f9 (commit)
       via  9b1d38707c1d407a72c5b6d8bfd30240a9d7dd34 (commit)
      from  9eeb02c16510629f2431cf78c0fec00667db4fe6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 33a17fd35995a7f679f92600055a8f55ae380022
Author: Uwe Hermann <uwe at hermann-uwe.de>
Date:   Thu Mar 17 03:22:12 2011 +0100

    Fix a bunch of typos.
    
    Fix a bunch of typos.
    
    Most are in code comments, so nothing should break. UNKOWN_COMMAND and
    CMD_UNKOWN are not used elsewhere, so correcting the spelling should
    also not break anything.

diff --git a/src/flash/nand/mx2.c b/src/flash/nand/mx2.c
index 6bad4aa..77ae138 100644
--- a/src/flash/nand/mx2.c
+++ b/src/flash/nand/mx2.c
@@ -105,7 +105,7 @@ NAND_DEVICE_COMMAND_HANDLER(imx27_nand_device_command)
 	mx2_nf_info->flags.target_little_endian =
 	(nand->target->endianness == TARGET_LITTLE_ENDIAN);
 	/*
-	 * testing host endianess
+	 * testing host endianness
 	 */
 	x = 1;
 	if (*(char *) &x == 1)
diff --git a/src/flash/nand/mx3.c b/src/flash/nand/mx3.c
index 41f08b5..45591e3 100644
--- a/src/flash/nand/mx3.c
+++ b/src/flash/nand/mx3.c
@@ -100,7 +100,7 @@ NAND_DEVICE_COMMAND_HANDLER(imx31_nand_device_command)
 	mx3_nf_info->flags.target_little_endian =
 	(nand->target->endianness == TARGET_LITTLE_ENDIAN);
 	/*
-	* testing host endianess
+	* testing host endianness
 	*/
 	{
 	int x = 1;
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index f895935..0b71e81 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -2684,7 +2684,7 @@ showall:
 			   (0 == strcmp("clear", CMD_ARGV[0]))) { // quietly accept both
 		r = FLASHD_ClrGPNVM(&(pChip->details.bank[0]), who);
 	} else {
-		command_print(CMD_CTX, "Unkown command: %s", CMD_ARGV[0]);
+		command_print(CMD_CTX, "Unknown command: %s", CMD_ARGV[0]);
 		r = ERROR_COMMAND_SYNTAX_ERROR;
 	}
 	return r;
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 6a81047..e57943c 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -841,7 +841,7 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 	 * REVISIT DustDevil-A0 parts have an erratum making FMPPE commits
 	 * inadvisable ... it makes future mass erase operations fail.
 	 */
-	LOG_WARNING("Flash protection cannot be removed once commited, commit is NOT executed !");
+	LOG_WARNING("Flash protection cannot be removed once committed, commit is NOT executed !");
 	/* target_write_u32(target, FLASH_FMC, FMC_WRKEY | FMC_COMT); */
 
 	/* Wait until erase complete */
diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
index 836a4d1..7813f33 100644
--- a/src/jtag/drivers/buspirate.c
+++ b/src/jtag/drivers/buspirate.c
@@ -45,7 +45,7 @@ static void buspirate_scan(bool ir_scan, enum scan_type type,
 	uint8_t *buffer, int scan_size, struct scan_command *command);
 
 
-#define CMD_UNKOWN        0x00
+#define CMD_UNKNOWN       0x00
 #define CMD_PORT_MODE     0x01
 #define CMD_FEATURE       0x02
 #define CMD_READ_ADCS     0x03
diff --git a/src/jtag/drivers/usbprog.c b/src/jtag/drivers/usbprog.c
index cc78555..17b0116 100644
--- a/src/jtag/drivers/usbprog.c
+++ b/src/jtag/drivers/usbprog.c
@@ -54,7 +54,7 @@ static void usbprog_path_move(struct pathmove_command *cmd);
 static void usbprog_runtest(int num_cycles);
 static void usbprog_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size);
 
-#define UNKOWN_COMMAND	0x00
+#define UNKNOWN_COMMAND	0x00
 #define PORT_DIRECTION	0x01
 #define PORT_SET		0x02
 #define PORT_GET		0x03
diff --git a/src/server/startup.tcl b/src/server/startup.tcl
index 7801d1b..64ace40 100644
--- a/src/server/startup.tcl
+++ b/src/server/startup.tcl
@@ -1,6 +1,6 @@
 # Defines basic Tcl procs for OpenOCD server modules
 
-# Handle GDB 'R' packet. Can be overriden by configuration script,
+# Handle GDB 'R' packet. Can be overridden by configuration script,
 # but it's not something one would expect target scripts to do
 # normally
 proc ocd_gdb_restart {target_id} {
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 6acf032..0cca768 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -402,7 +402,7 @@ COMMAND_HANDLER(handle_svf_command)
 
 	svf_buffer_index = 0;
 	// double the buffer size
-	// in case current command cannot be commited, and next command is a bit scan command
+	// in case current command cannot be committed, and next command is a bit scan command
 	// here is 32K bits for this big scan command, it should be enough
 	// buffer will be reallocated if buffer size is not enough
 	svf_tdi_buffer = (uint8_t *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 4fcde16..fff5dd8 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -315,7 +315,7 @@ static int armv7m_run_and_wait(struct target *target, uint32_t entry_point, int
 	armv7m->load_core_reg_u32(target, ARMV7M_REGISTER_CORE_GP, 15, &pc);
 	if (exit_point && (pc != exit_point))
 	{
-		LOG_DEBUG("failed algoritm halted at 0x%" PRIx32 " ", pc);
+		LOG_DEBUG("failed algorithm halted at 0x%" PRIx32 " ", pc);
 		return ERROR_TARGET_TIMEOUT;
 	}
 
diff --git a/src/target/image.c b/src/target/image.c
index b0d957f..454fc6c 100644
--- a/src/target/image.c
+++ b/src/target/image.c
@@ -431,7 +431,7 @@ static int image_elf_read_headers(struct image *image)
 	if ((elf->endianness != ELFDATA2LSB)
 		 &&(elf->endianness != ELFDATA2MSB))
 	{
-		LOG_ERROR("invalid ELF file, unknown endianess setting");
+		LOG_ERROR("invalid ELF file, unknown endianness setting");
 		return ERROR_IMAGE_FORMAT_ERROR;
 	}
 
diff --git a/src/target/mips32.c b/src/target/mips32.c
index e48a040..79215b5 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -351,7 +351,7 @@ static int mips32_run_and_wait(struct target *target, uint32_t entry_point,
 	pc = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32);
 	if (exit_point && (pc != exit_point))
 	{
-		LOG_DEBUG("failed algoritm halted at 0x%" PRIx32 " ", pc);
+		LOG_DEBUG("failed algorithm halted at 0x%" PRIx32 " ", pc);
 		return ERROR_TARGET_TIMEOUT;
 	}
 
diff --git a/src/target/target.c b/src/target/target.c
index 3a6c6bb..be42b33 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1522,7 +1522,7 @@ int target_checksum_memory(struct target *target, uint32_t address, uint32_t siz
 			return retval;
 		}
 
-		/* convert to target endianess */
+		/* convert to target endianness */
 		for (i = 0; i < (size/sizeof(uint32_t)); i++)
 		{
 			uint32_t target_data;
diff --git a/src/target/target.h b/src/target/target.h
index 2bf9668..d6e7431 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -84,7 +84,7 @@ enum target_debug_reason
 	DBG_REASON_UNDEFINED = 6
 };
 
-enum target_endianess
+enum target_endianness
 {
 	TARGET_ENDIAN_UNKNOWN = 0,
 	TARGET_BIG_ENDIAN = 1, TARGET_LITTLE_ENDIAN = 2
@@ -139,7 +139,7 @@ struct target
 	uint32_t backup_working_area;			/* whether the content of the working area has to be preserved */
 	struct working_area *working_areas;/* list of allocated working areas */
 	enum target_debug_reason debug_reason;/* reason why the target entered debug state */
-	enum target_endianess endianness;	/* target endianess */
+	enum target_endianness endianness;	/* target endianness */
 	// also see: target_state_name()
 	enum target_state state;			/* the current backend-state (running, halted, ...) */
 	struct reg_cache *reg_cache;		/* the first register cache of the target (core regs) */

commit 582b4195a99a21caa9522713fae659621137e0f9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 14 15:32:14 2011 +0100

    dsp563xx: fix alignment warnings
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index cdfa79b..6cde152 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -1393,7 +1393,7 @@ static int dsp563xx_read_memory_core(struct target *target, int mem_type, uint32
 			return err;
 		if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0, 0x08D13C)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_reg_read(target->tap, 0, DSP563XX_ONCE_OGDBR, (uint32_t*)b)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_read(target->tap, 0, DSP563XX_ONCE_OGDBR, (uint32_t*)(void *)b)) != ERROR_OK)
 			return err;
 		b += 4;
 	}
@@ -1409,7 +1409,7 @@ static int dsp563xx_read_memory_core(struct target *target, int mem_type, uint32
 
 	for (i = 0; i < x; i++)
 	{
-		data = *((uint32_t*)b) & 0x00FFFFFF;
+		data = buf_get_u32(b, 0, 32) & 0x00FFFFFF;
 //		LOG_DEBUG("R: %08X", *((uint32_t*)b));
 		target_buffer_set_u32(target, b, data);
 		b += 4;
@@ -1466,8 +1466,8 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 
 	for(i=0,i1=0;i<count;i+=2,i1++)
 	{
-		((uint32_t*)buffer)[i] = ((uint32_t*)buffer_y)[i1];
-		((uint32_t*)buffer)[i+1] = ((uint32_t*)buffer_x)[i1];
+		buf_set_u32(buffer + i*sizeof(uint32_t), 0, 32, buf_get_u32(buffer_y+i1*sizeof(uint32_t), 0, 32));
+		buf_set_u32(buffer + (i + 1) *sizeof(uint32_t), 0, 32, buf_get_u32(buffer_x+i1*sizeof(uint32_t), 0, 32));
 	}
 
 	free(buffer_y);
@@ -1587,8 +1587,8 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 
 	for(i=0,i1=0;i<count;i+=2,i1++)
 	{
-		((uint32_t*)buffer_y)[i1] = ((uint32_t*)buffer)[i];
-		((uint32_t*)buffer_x)[i1] = ((uint32_t*)buffer)[i+1];
+		buf_set_u32(buffer_y + i1*sizeof(uint32_t), 0, 32, buf_get_u32(buffer+i*sizeof(uint32_t), 0, 32));
+		buf_set_u32(buffer_x + i1*sizeof(uint32_t), 0, 32, buf_get_u32(buffer+(i+1)*sizeof(uint32_t), 0, 32));
 	}
 
 	err = dsp563xx_write_memory_core(target,MEM_Y,address,size,count/2,buffer_y);

commit 9b1d38707c1d407a72c5b6d8bfd30240a9d7dd34
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 15 10:43:45 2011 +0100

    dsp563xx: fix bug in x buffer handling
    
    found by inspection.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index cb2025e..cdfa79b 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -1467,7 +1467,7 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 	for(i=0,i1=0;i<count;i+=2,i1++)
 	{
 		((uint32_t*)buffer)[i] = ((uint32_t*)buffer_y)[i1];
-		((uint32_t*)buffer)[i] = ((uint32_t*)buffer_x)[i1];
+		((uint32_t*)buffer)[i+1] = ((uint32_t*)buffer_x)[i1];
 	}
 
 	free(buffer_y);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/mx2.c         |    2 +-
 src/flash/nand/mx3.c         |    2 +-
 src/flash/nor/at91sam3.c     |    2 +-
 src/flash/nor/stellaris.c    |    2 +-
 src/jtag/drivers/buspirate.c |    2 +-
 src/jtag/drivers/usbprog.c   |    2 +-
 src/server/startup.tcl       |    2 +-
 src/svf/svf.c                |    2 +-
 src/target/armv7m.c          |    2 +-
 src/target/dsp563xx.c        |   12 ++++++------
 src/target/image.c           |    2 +-
 src/target/mips32.c          |    2 +-
 src/target/target.c          |    2 +-
 src/target/target.h          |    4 ++--
 14 files changed, 20 insertions(+), 20 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 17 07:35:39 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Mar 2011 06:35:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-798-g9f17b30
Message-ID: <mailman.27.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9f17b30f8847ba50e7a8ef03ca37cc116e915740 (commit)
      from  33a17fd35995a7f679f92600055a8f55ae380022 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9f17b30f8847ba50e7a8ef03ca37cc116e915740
Author: John and Tina Peterson <jpfp at byu.edu>
Date:   Thu Mar 17 07:34:44 2011 +0100

    SYS_WRITE0 fix
    
    Problem is, trying to print "Hello, world!\n" just prints endless H's, because r1 is never incremented.
    
    One way to fix it would be to add a "++" after "r1".

diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index a247cc8..903145c 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -139,7 +139,7 @@ static int do_semihosting(struct target *target)
 	case 0x04:	/* SYS_WRITE0 */
 		do {
 			unsigned char c;
-			retval = target_read_memory(target, r1, 1, 1, &c);
+			retval = target_read_memory(target, r1++, 1, 1, &c);
 			if (retval != ERROR_OK)
 				return retval;
 			if (!c)

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_semihosting.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar 18 10:52:39 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Mar 2011 09:52:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-799-g4332bc3
Message-ID: <mailman.28.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4332bc32e4a65b0b5b169a143febeb02e6517f39 (commit)
      from  9f17b30f8847ba50e7a8ef03ca37cc116e915740 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4332bc32e4a65b0b5b169a143febeb02e6517f39
Author: Mathias K <kesmtp at freenet.de>
Date:   Thu Mar 3 11:01:46 2011 +0100

    target: allow targets to override memory alignment
    
    Targets can implement read/write_buffer to handle
    alignment.

diff --git a/src/target/target.c b/src/target/target.c
index be42b33..13d358d 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -46,6 +46,10 @@
 #include "image.h"
 
 
+static int target_read_buffer_default(struct target *target, uint32_t address,
+		uint32_t size, uint8_t *buffer);
+static int target_write_buffer_default(struct target *target, uint32_t address,
+		uint32_t size, uint8_t *buffer);
 static int target_array2mem(Jim_Interp *interp, struct target *target,
 		int argc, Jim_Obj *const *argv);
 static int target_mem2array(Jim_Interp *interp, struct target *target,
@@ -865,6 +869,13 @@ static int target_init_one(struct command_context *cmd_ctx,
 		type->read_phys_memory = type->read_memory;
 		type->virt2phys = identity_virt2phys;
 	}
+
+	if (target->type->read_buffer == NULL)
+		target->type->read_buffer = target_read_buffer_default;
+
+	if (target->type->write_buffer == NULL)
+		target->type->write_buffer = target_write_buffer_default;
+
 	return ERROR_OK;
 }
 
@@ -1333,7 +1344,6 @@ int target_arch_state(struct target *target)
  */
 int target_write_buffer(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
 {
-	int retval;
 	LOG_DEBUG("writing buffer of %i byte at 0x%8.8x",
 		  (int)size, (unsigned)address);
 
@@ -1356,6 +1366,13 @@ int target_write_buffer(struct target *target, uint32_t address, uint32_t size,
 		return ERROR_FAIL;
 	}
 
+	return target->type->write_buffer(target, address, size, buffer);
+}
+
+static int target_write_buffer_default(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+
 	if (((address % 2) == 0) && (size == 2))
 	{
 		return target_write_memory(target, address, 2, 1, buffer);
@@ -1406,7 +1423,7 @@ int target_write_buffer(struct target *target, uint32_t address, uint32_t size,
 			return retval;
 	}
 
-	return ERROR_OK;
+	return retval;
 }
 
 /* Single aligned words are guaranteed to use 16 or 32 bit access
@@ -1415,7 +1432,6 @@ int target_write_buffer(struct target *target, uint32_t address, uint32_t size,
  */
 int target_read_buffer(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
 {
-	int retval;
 	LOG_DEBUG("reading buffer of %i byte at 0x%8.8x",
 			  (int)size, (unsigned)address);
 
@@ -1438,6 +1454,13 @@ int target_read_buffer(struct target *target, uint32_t address, uint32_t size, u
 		return ERROR_FAIL;
 	}
 
+	return target->type->read_buffer(target, address, size, buffer);
+}
+
+static int target_read_buffer_default(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
+{
+	int retval = ERROR_OK;
+
 	if (((address % 2) == 0) && (size == 2))
 	{
 		return target_read_memory(target, address, 2, 1, buffer);
@@ -3695,7 +3718,6 @@ static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-variant",          .value = TCFG_VARIANT },
 	{ .name = "-coreid",           .value = TCFG_COREID },
 	{ .name = "-chain-position",   .value = TCFG_CHAIN_POSITION },
-
 	{ .name = NULL, .value = -1 }
 };
 
diff --git a/src/target/target_type.h b/src/target/target_type.h
index bfa7f93..15598b2 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -119,6 +119,12 @@ struct target_type
 	 */
 	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
+	/* Default implementation will do some fancy alignment to improve performance, target can override */
+	int (*read_buffer)(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer);
+
+	/* Default implementation will do some fancy alignment to improve performance, target can override */
+	int (*write_buffer)(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer);
+
 	/**
 	 * Write target memory in multiples of 4 bytes, optimized for
 	 * writing large quantities of data.  Do @b not call this

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c      |   30 ++++++++++++++++++++++++++----
 src/target/target_type.h |    6 ++++++
 2 files changed, 32 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar 18 14:26:03 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Mar 2011 13:26:03 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-800-g558f760
Message-ID: <mailman.29.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  558f760ff06c499b4525dcb4ba731f585256dacb (commit)
      from  4332bc32e4a65b0b5b169a143febeb02e6517f39 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 558f760ff06c499b4525dcb4ba731f585256dacb
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 3 11:00:14 2011 +0100

    zy1000: add code to check that SRST asserts
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 71ae6f4..f2db47b 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -172,6 +172,45 @@ static int zy1000_power_dropout(int *dropout)
 	return ERROR_OK;
 }
 
+/* Wait for SRST to assert or deassert */
+static void waitSRST(bool asserted)
+{
+	bool first = true;
+	long long start = 0;
+	long total = 0;
+	const char *mode = asserted ? "assert" : "deassert";
+
+	for (;;)
+	{
+		bool srstAsserted = readSRST();
+		if ( (asserted && srstAsserted) || (!asserted && !srstAsserted) )
+		{
+			if (total > 1)
+			{
+				LOG_USER("SRST took %dms to %s", (int)total, mode);
+			}
+			break;
+		}
+
+		if (first)
+		{
+			first = false;
+			start = timeval_ms();
+		}
+
+		total = timeval_ms() - start;
+
+		keep_alive();
+
+		if (total > 5000)
+		{
+			LOG_ERROR("SRST took too long to %s: %dms", mode, (int)total);
+			break;
+		}
+	}
+}
+
+
 void zy1000_reset(int trst, int srst)
 {
 	LOG_DEBUG("zy1000 trst=%d, srst=%d", trst, srst);
@@ -192,6 +231,8 @@ void zy1000_reset(int trst, int srst)
 		 * idle in TAP_IDLE, reset halt on str912 will fail.
 		 */
 		ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x00000001);
+
+		waitSRST(true);
 	}
 
 	if (!trst)
@@ -218,40 +259,7 @@ void zy1000_reset(int trst, int srst)
 	if ((!srst && ((jtag_get_reset_config() & RESET_TRST_PULLS_SRST) == 0))||
 		(!srst && !trst && (jtag_get_reset_config() & RESET_TRST_PULLS_SRST)))
 	{
-		bool first = true;
-		long long start = 0;
-		long total = 0;
-		for (;;)
-		{	
-			// We don't want to sense our own reset, so we clear here.
-			// There is of course a timing hole where we could loose
-			// a "real" reset.
-			if (!readSRST())
-			{
-				if (total > 1)
-				{
-				  LOG_USER("SRST took %dms to deassert", (int)total);
-				}
-				break;
-			}
-
-			if (first)
-			{
-			    first = false;
-			    start = timeval_ms();
-			}
-
-			total = timeval_ms() - start;
-
-			keep_alive();
-
-			if (total > 5000)
-			{
-				LOG_ERROR("SRST took too long to deassert: %dms", (int)total);
-			    break;
-			}
-		}
-
+		waitSRST(false);
 	}
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   76 +++++++++++++++++++++++++--------------------
 1 files changed, 42 insertions(+), 34 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Mar 20 19:49:24 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 20 Mar 2011 18:49:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-801-g17201b5
Message-ID: <mailman.30.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  17201b584776704c80ac5089874f244757b3744e (commit)
      from  558f760ff06c499b4525dcb4ba731f585256dacb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 17201b584776704c80ac5089874f244757b3744e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Mar 20 19:44:48 2011 +0100

    dsp563xx_once: fix warning and potential bug
    
    I don't think dsp563xx_once_read_register() would ever
    be called with len==0, but it would have been broken in
    that case.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
index d95dcdf..267f475 100644
--- a/src/target/dsp563xx_once.c
+++ b/src/target/dsp563xx_once.c
@@ -188,7 +188,7 @@ int dsp563xx_once_request_debug(struct jtag_tap *tap, int reset_state)
 int dsp563xx_once_read_register(struct jtag_tap *tap, int flush, struct once_reg *regs, int len)
 {
 	int i;
-	int err;
+	int err = ERROR_OK;
 
 	for (i = 0; i < len; i++)
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx_once.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar 21 08:41:52 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 21 Mar 2011 07:41:52 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-802-ga343570
Message-ID: <mailman.31.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a34357019545b1b449cbc52de99e52e68c3dbcb1 (commit)
      from  17201b584776704c80ac5089874f244757b3744e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a34357019545b1b449cbc52de99e52e68c3dbcb1
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Mar 18 13:47:17 2011 +0100

    zy1000: removed JTAG master TCP/IP server
    
    Move ZY1000 OpenOCD driver more in the direction of being
    a client to simplify code.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index f2db47b..ee61003 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1036,6 +1036,8 @@ static const struct command_registration zy1000_commands[] = {
 };
 
 
+#if !BUILD_ZY1000_MASTER
+
 static int tcp_ip = -1;
 
 /* Write large packets if we can */
@@ -1116,9 +1118,6 @@ enum ZY1000_CMD
 	ZY1000_CMD_WAITIDLE = 2
 };
 
-
-#if !BUILD_ZY1000_MASTER
-
 #include <sys/socket.h> /* for socket(), connect(), send(), and recv() */
 #include <arpa/inet.h>  /* for sockaddr_in and inet_addr() */
 
@@ -1363,132 +1362,12 @@ static void writeShiftValue(uint8_t *data, int bits)
 
 #if BUILD_ZY1000_MASTER
 
-pthread_t thread;
-
 #if BUILD_ECOSBOARD
 static char watchdog_stack[2048];
 static cyg_thread watchdog_thread_object;
 static cyg_handle_t watchdog_thread_handle;
 #endif
 
-/* Infinite loop peeking & poking */
-static void tcpipserver(void)
-{
-	for (;;)
-	{
-		uint32_t address;
-		if (!readLong(&address))
-			return;
-		enum ZY1000_CMD c = (address >> 24) & 0xff;
-		address &= 0xffffff;
-		switch (c)
-		{
-			case ZY1000_CMD_POKE:
-			{
-				uint32_t data;
-				if (!readLong(&data))
-					return;
-				address &= ~0x80000000;
-				ZY1000_POKE(address + ZY1000_JTAG_BASE, data);
-				break;
-			}
-			case ZY1000_CMD_PEEK:
-			{
-				uint32_t data;
-				ZY1000_PEEK(address + ZY1000_JTAG_BASE, data);
-				if (!writeLong(data))
-					return;
-				break;
-			}
-			case ZY1000_CMD_SLEEP:
-			{
-				uint32_t data;
-				if (!readLong(&data))
-					return;
-				/* Wait for some us */
-				usleep(data);
-				break;
-			}
-			case ZY1000_CMD_WAITIDLE:
-			{
-				waitIdle();
-				break;
-			}
-			default:
-				return;
-		}
-	}
-}
-
-
-static void *tcpip_server(void *data)
-{
-	int so_reuseaddr_option = 1;
-
-	int fd;
-	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
-	{
-		LOG_ERROR("error creating socket: %s", strerror(errno));
-		exit(-1);
-	}
-
-	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void*) &so_reuseaddr_option,
-			sizeof(int));
-
-	struct sockaddr_in sin;
-	unsigned int address_size;
-	address_size = sizeof(sin);
-	memset(&sin, 0, sizeof(sin));
-	sin.sin_family = AF_INET;
-	sin.sin_addr.s_addr = INADDR_ANY;
-	sin.sin_port = htons(7777);
-
-	if (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) == -1)
-	{
-		LOG_ERROR("couldn't bind to socket: %s", strerror(errno));
-		exit(-1);
-	}
-
-	if (listen(fd, 1) == -1)
-	{
-		LOG_ERROR("couldn't listen on socket: %s", strerror(errno));
-		exit(-1);
-	}
-
-
-	for (;;)
-	{
-		tcp_ip = accept(fd, (struct sockaddr *) &sin, &address_size);
-		if (tcp_ip < 0)
-		{
-			continue;
-		}
-
-		int flag = 1;
-		setsockopt(tcp_ip,	/* socket affected */
-				IPPROTO_TCP,		/* set option at TCP level */
-				TCP_NODELAY,		/* name of option */
-				(char *)&flag,		/* the cast is historical cruft */
-				sizeof(int));		/* length of option value */
-
-		bool save_poll = jtag_poll_get_enabled();
-
-		/* polling will screw up the "connection" */
-		jtag_poll_set_enabled(false);
-
-		tcpipserver();
-
-		jtag_poll_set_enabled(save_poll);
-
-		close(tcp_ip);
-
-	}
-	/* Never reached actually */
-	close(fd);
-
-	return NULL;
-}
-
 #ifdef WATCHDOG_BASE
 /* If we connect to port 8888 we must send a char every 10s or the board resets itself */
 static void watchdog_server(cyg_addrword_t data)
@@ -1628,8 +1507,6 @@ int zy1000_init(void)
 	zy1000_speed(jtag_speed_var);
 
 #if BUILD_ZY1000_MASTER
-	pthread_create(&thread, NULL, tcpip_server, NULL);
-
 #if BUILD_ECOSBOARD
 #ifdef WATCHDOG_BASE
 	cyg_thread_create(1, watchdog_server, (cyg_addrword_t) 0, "watchdog tcip/ip server",

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |  127 +---------------------------------------------
 1 files changed, 2 insertions(+), 125 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar 21 13:47:59 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 21 Mar 2011 12:47:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-803-gec2b8d7
Message-ID: <mailman.32.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ec2b8d71ac1fb2e8d6c8057a5e1d0a27bd7bd110 (commit)
      from  a34357019545b1b449cbc52de99e52e68c3dbcb1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ec2b8d71ac1fb2e8d6c8057a5e1d0a27bd7bd110
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 21 13:30:09 2011 +0100

    zy1000: fix bug in ir scan handling
    
    set cur_instr to BYPASS as optimisation code will
    rely on checking the cached value.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index ee61003..5416c6b 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -618,6 +618,11 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field
 			assert(scan_size <= 32);
 			shiftValueInner(TAP_IRSHIFT, pause_state, scan_size, 0xffffffff);
 
+			/* Optimization code will check what the cur_instr is set to, so
+			 * we must set it to bypass value.
+			 */
+			buf_set_ones(tap->cur_instr, tap->ir_length);
+
 			tap->bypass = 1;
 		}
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 22 09:23:16 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 22 Mar 2011 08:23:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-806-ga843789
Message-ID: <mailman.33.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a843789ede3b01dfaf199e1fcfbfd09ac681cf8f (commit)
       via  fc574c64bb259814ccbf51d74057873bd5649ea3 (commit)
       via  6c5e1781a102424353bf237386e7443b2ce3e4d3 (commit)
      from  ec2b8d71ac1fb2e8d6c8057a5e1d0a27bd7bd110 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a843789ede3b01dfaf199e1fcfbfd09ac681cf8f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 22 09:21:16 2011 +0100

    omap4430: tried to add in workaround for broken dbgbase query
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 480472f..53cf615 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1091,6 +1091,7 @@ struct broken_cpu {
 	char		*model;
 } broken_cpus[] = {
 	{ 0x80000000, 0x04770002, 0x1ba00477, 0x60000000, "imx51" },
+	{ 0x80040000, 0x04770002, 0x3b95c02f, 0x80000000, "omap4430" },
 };
 
 int dap_get_debugbase(struct adiv5_dap *dap, int ap,

commit fc574c64bb259814ccbf51d74057873bd5649ea3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 21 14:10:57 2011 +0100

    cortex a9: merge cortex a9 and a8 code
    
    better to keep this in a single file.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index b6e8d4b..537c8c3 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -73,8 +73,7 @@ ARMV7_SRC = \
 	armv7m.c \
 	cortex_m3.c \
 	armv7a.c \
-	cortex_a8.c \
-	cortex_a9.c
+	cortex_a8.c
 
 ARM_DEBUG_SRC = \
 	arm_dpm.c \
@@ -137,7 +136,6 @@ noinst_HEADERS = \
 	breakpoints.h \
 	cortex_m3.h \
 	cortex_a8.h \
-	cortex_a9.h \
 	embeddedice.h \
 	etb.h \
 	etm.h \
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 7815522..88b3db4 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -30,6 +30,7 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  *                                                                         *
  *   Cortex-A8(tm) TRM, ARM DDI 0344H                                      *
+ *   Cortex-A9(tm) TRM, ARM DDI 0407F                                      *
  *                                                                         *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
@@ -692,7 +693,7 @@ static int cortex_a8_poll(struct target *target)
 	}
 	cortex_a8->cpudbg_dscr = dscr;
 
-	if ((dscr & 0x3) == 0x3)
+	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
 	{
 		if (prev_target_state != TARGET_HALTED)
 		{
@@ -722,7 +723,7 @@ static int cortex_a8_poll(struct target *target)
 			}
 		}
 	}
-	else if ((dscr & 0x3) == 0x2)
+	else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
 	{
 		target->state = TARGET_RUNNING;
 	}
@@ -747,7 +748,7 @@ static int cortex_a8_halt(struct target *target)
 	 * and then wait for the core to be halted.
 	 */
 	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DRCR, 0x1);
+			armv7a->debug_base + CPUDBG_DRCR, DRCR_HALT);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -870,14 +871,30 @@ static int cortex_a8_resume(struct target *target, int current,
 	}
 
 #endif
-	/* Restart core and wait for it to be started
-	 * NOTE: this clears DSCR_ITR_EN and other bits.
+
+	/*
+	 * Restart core and wait for it to be started.  Clear ITRen and sticky
+	 * exception flags: see ARMv7 ARM, C5.9.
 	 *
 	 * REVISIT: for single stepping, we probably want to
 	 * disable IRQs by default, with optional override...
 	 */
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((dscr & DSCR_INSTR_COMP) == 0)
+		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
+
 	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DRCR, 0x2);
+		armv7a->debug_base + CPUDBG_DSCR, dscr & ~DSCR_ITR_EN);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
+			armv7a->debug_base + CPUDBG_DRCR, DRCR_RESTART | DRCR_CLEAR_EXCEPTIONS);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1443,32 +1460,101 @@ static int cortex_a8_read_phys_memory(struct target *target,
                 uint32_t address, uint32_t size,
                 uint32_t count, uint8_t *buffer)
 {
-        struct armv7a_common *armv7a = target_to_armv7a(target);
-        struct adiv5_dap *swjdp = &armv7a->dap;
-        int retval = ERROR_INVALID_ARGUMENTS;
-
-        /* cortex_a8 handles unaligned memory access */
-
-// ???  dap_ap_select(swjdp, swjdp_memoryap);
-        LOG_DEBUG("Reading memory at real address 0x%x; size %d; count %d", address, size, count);
-        if (count && buffer) {
-                switch (size) {
-                case 4:
-                        retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
-								buffer, 4 * count, address);
-                        break;
-                case 2:
-                        retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
-								buffer, 2 * count, address);
-                        break;
-                case 1:
-                        retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
-								 buffer, count, address);
-                        break;
-                }
-        }
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval = ERROR_INVALID_ARGUMENTS;
+	uint8_t apsel = swjdp->apsel;
+
+	LOG_DEBUG("Reading memory at real address 0x%x; size %d; count %d", address, size, count);
+
+	if (count && buffer) {
+
+		if ( apsel == swjdp_memoryap ) {
+
+			/* read memory through AHB-AP */
+
+			switch (size) {
+				case 4:
+					retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
+							buffer, 4 * count, address);
+					break;
+				case 2:
+					retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
+							buffer, 2 * count, address);
+					break;
+				case 1:
+					retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
+							buffer, count, address);
+					break;
+			}
 
-        return retval;
+		} else {
+
+			/* read memory through APB-AP */
+
+			uint32_t saved_r0, saved_r1;
+			int nbytes = count * size;
+			uint32_t data;
+			int enabled = 0;
+
+			if (target->state != TARGET_HALTED)
+			{
+				LOG_WARNING("target not halted");
+				return ERROR_TARGET_NOT_HALTED;
+			}
+
+			retval = cortex_a8_mmu(target, &enabled);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if (enabled)
+			{
+				LOG_WARNING("Reading physical memory through APB with MMU enabled is not yet implemented");
+				return ERROR_TARGET_FAILURE;
+			}
+
+			/* save registers r0 and r1, we are going to corrupt them  */
+			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			while (nbytes > 0) {
+
+				/* execute instruction LDRB r1, [r0], 1 (0xe4d01001) */
+				retval = cortex_a8_exec_opcode(target, ARMV4_5_LDRB_IP(1, 0) , NULL);
+				if (retval != ERROR_OK)
+						return retval;
+
+				retval = cortex_a8_dap_read_coreregister_u32(target, &data, 1);
+				if (retval != ERROR_OK)
+					return retval;
+
+				*buffer++ = data;
+				--nbytes;
+
+			}
+
+			/* restore corrupted registers r0 and r1 */
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+		}
+	}
+
+	return retval;
 }
 
 static int cortex_a8_read_memory(struct target *target, uint32_t address,
@@ -1480,7 +1566,6 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 
 	/* cortex_a8 handles unaligned memory access */
 
-// ???	dap_ap_select(swjdp, swjdp_memoryap);
         LOG_DEBUG("Reading memory at address 0x%x; size %d; count %d", address, size, count);
         retval = cortex_a8_mmu(target, &enabled);
         if (retval != ERROR_OK)
@@ -1504,88 +1589,162 @@ static int cortex_a8_write_phys_memory(struct target *target,
                 uint32_t address, uint32_t size,
                 uint32_t count, uint8_t *buffer)
 {
-        struct armv7a_common *armv7a = target_to_armv7a(target);
-        struct adiv5_dap *swjdp = &armv7a->dap;
-        int retval = ERROR_INVALID_ARGUMENTS;
-
-// ???  dap_ap_select(swjdp, swjdp_memoryap);
-
-        LOG_DEBUG("Writing memory to real address 0x%x; size %d; count %d", address, size, count);
-        if (count && buffer) {
-                switch (size) {
-                case 4:
-                        retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,
-								buffer, 4 * count, address);
-                        break;
-                case 2:
-                        retval = mem_ap_sel_write_buf_u16(swjdp, swjdp_memoryap,
-								buffer, 2 * count, address);
-                        break;
-                case 1:
-                        retval = mem_ap_sel_write_buf_u8(swjdp, swjdp_memoryap,
-								buffer, count, address);
-                        break;
-                }
-        }
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval = ERROR_INVALID_ARGUMENTS;
+	uint8_t apsel = swjdp->apsel;
+
+	LOG_DEBUG("Writing memory to real address 0x%x; size %d; count %d", address, size, count);
+
+	if (count && buffer) {
+
+		if ( apsel == swjdp_memoryap ) {
+
+			/* write memory through AHB-AP */
+
+			switch (size) {
+				case 4:
+					retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,
+							buffer, 4 * count, address);
+					break;
+				case 2:
+					retval = mem_ap_sel_write_buf_u16(swjdp, swjdp_memoryap,
+							buffer, 2 * count, address);
+					break;
+				case 1:
+					retval = mem_ap_sel_write_buf_u8(swjdp, swjdp_memoryap,
+							buffer, count, address);
+					break;
+			}
 
-        /* REVISIT this op is generic ARMv7-A/R stuff */
-        if (retval == ERROR_OK && target->state == TARGET_HALTED)
-        {
-                struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
-
-                retval = dpm->prepare(dpm);
-                if (retval != ERROR_OK)
-                        return retval;
-
-                /* The Cache handling will NOT work with MMU active, the
-                 * wrong addresses will be invalidated!
-                 *
-                 * For both ICache and DCache, walk all cache lines in the
-                 * address range. Cortex-A8 has fixed 64 byte line length.
-                 *
-                 * REVISIT per ARMv7, these may trigger watchpoints ...
-                 */
-
-                /* invalidate I-Cache */
-                if (armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
-                {
-                        /* ICIMVAU - Invalidate Cache single entry
-                         * with MVA to PoU
-                         *      MCR p15, 0, r0, c7, c5, 1
-                         */
-                        for (uint32_t cacheline = address;
-                                        cacheline < address + size * count;
-                                        cacheline += 64) {
-                                retval = dpm->instr_write_data_r0(dpm,
-                                        ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
-                                        cacheline);
-                                if (retval != ERROR_OK)
-                                	return retval;
-                        }
-                }
-
-                /* invalidate D-Cache */
-                if (armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-                {
-                        /* DCIMVAC - Invalidate data Cache line
-                         * with MVA to PoC
-                         *      MCR p15, 0, r0, c7, c6, 1
-                         */
-                        for (uint32_t cacheline = address;
-                                        cacheline < address + size * count;
-                                        cacheline += 64) {
-                                retval = dpm->instr_write_data_r0(dpm,
-                                        ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
-                                        cacheline);
-                                if (retval != ERROR_OK)
-                                	return retval;
-                        }
-                }
-
-                /* (void) */ dpm->finish(dpm);
-        }
+		} else {
 
-        return retval;
+			/* write memory through APB-AP */
+
+			uint32_t saved_r0, saved_r1;
+			int nbytes = count * size;
+			uint32_t data;
+			int enabled = 0;
+
+			if (target->state != TARGET_HALTED)
+			{
+				LOG_WARNING("target not halted");
+				return ERROR_TARGET_NOT_HALTED;
+			}
+
+			retval = cortex_a8_mmu(target, &enabled);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if (enabled)
+			{
+				LOG_WARNING("Writing physical memory through APB with MMU enabled is not yet implemented");
+				return ERROR_TARGET_FAILURE;
+			}
+
+			/* save registers r0 and r1, we are going to corrupt them  */
+			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_read_coreregister_u32(target, &saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			while (nbytes > 0) {
+
+				data = *buffer++;
+
+				retval = cortex_a8_dap_write_coreregister_u32(target, data, 1);
+				if (retval != ERROR_OK)
+					return retval;
+
+					/* execute instruction STRB r1, [r0], 1 (0xe4c01001) */
+				retval = cortex_a8_exec_opcode(target, ARMV4_5_STRB_IP(1, 0) , NULL);
+				if (retval != ERROR_OK)
+						return retval;
+
+				--nbytes;
+			}
+
+			/* restore corrupted registers r0 and r1 */
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+			/* we can return here without invalidating D/I-cache because */
+			/* access through APB maintains cache coherency              */
+			return retval;
+		}
+	}
+
+
+	/* REVISIT this op is generic ARMv7-A/R stuff */
+	if (retval == ERROR_OK && target->state == TARGET_HALTED)
+	{
+		struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
+
+		retval = dpm->prepare(dpm);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* The Cache handling will NOT work with MMU active, the
+		 * wrong addresses will be invalidated!
+		 *
+		 * For both ICache and DCache, walk all cache lines in the
+		 * address range. Cortex-A8 has fixed 64 byte line length.
+		 *
+		 * REVISIT per ARMv7, these may trigger watchpoints ...
+		 */
+
+		/* invalidate I-Cache */
+		if (armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
+		{
+			/* ICIMVAU - Invalidate Cache single entry
+			 * with MVA to PoU
+			 *      MCR p15, 0, r0, c7, c5, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline < address + size * count;
+					cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* invalidate D-Cache */
+		if (armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
+		{
+			/* DCIMVAC - Invalidate data Cache line
+			 * with MVA to PoC
+			 *      MCR p15, 0, r0, c7, c6, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline < address + size * count;
+					cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* (void) */ dpm->finish(dpm);
+	}
+
+	return retval;
 }
 
 static int cortex_a8_write_memory(struct target *target, uint32_t address,
@@ -1595,8 +1754,6 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
         uint32_t virt, phys;
         int retval;
 
-// ???  dap_ap_select(swjdp, swjdp_memoryap);
-
         LOG_DEBUG("Writing memory to address 0x%x; size %d; count %d", address, size, count);
         retval = cortex_a8_mmu(target, &enabled);
         if (retval != ERROR_OK)
@@ -1724,6 +1881,21 @@ static int cortex_a8_examine_first(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
+#if 0
+	/*
+	 * FIXME: assuming omap4430
+	 *
+	 * APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
+	 * 0x80000000 is cpu0 coresight region
+	 */
+	if (target->coreid > 3) {
+		LOG_ERROR("cortex_a8 supports up to 4 cores");
+		return ERROR_INVALID_ARGUMENTS;
+	}
+	armv7a->debug_base = 0x80000000 |
+			((target->coreid & 0x3) << CORTEX_A8_PADDRDBG_CPU_SHIFT);
+#endif
+
 	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK)
diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index 7e116e4..b49e670 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -33,7 +33,6 @@
 
 #define CORTEX_A8_COMMON_MAGIC 0x411fc082
 
-/* See Cortex-A8 TRM section 12.5 */
 #define CPUDBG_CPUID	0xD00
 #define CPUDBG_CTYPR	0xD04
 #define CPUDBG_TTYPR	0xD0C
@@ -43,6 +42,8 @@
 #define BRP_NORMAL 0
 #define BRP_CONTEXT 1
 
+#define CORTEX_A8_PADDRDBG_CPU_SHIFT 13
+
 struct cortex_a8_brp
 {
 	int used;
diff --git a/src/target/cortex_a9.c b/src/target/cortex_a9.c
deleted file mode 100644
index ce72ecd..0000000
--- a/src/target/cortex_a9.c
+++ /dev/null
@@ -1,2303 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   lundin at mlu.mine.nu                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Dirk Behme                                      *
- *   dirk.behme at gmail.com - copy from cortex_m3                            *
- *                                                                         *
- *   Copyright (C) 2010 ??yvind Harboe                                      *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                         *
- *   Cortex-A9(tm) TRM, ARM DDI 0407F                                      *
- *                                                                         *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "breakpoints.h"
-#include "cortex_a9.h"
-#include "register.h"
-#include "target_request.h"
-#include "target_type.h"
-#include "arm_opcodes.h"
-#include <helper/time_support.h>
-
-static int cortex_a9_poll(struct target *target);
-static int cortex_a9_debug_entry(struct target *target);
-static int cortex_a9_restore_context(struct target *target, bool bpwp);
-static int cortex_a9_set_breakpoint(struct target *target,
-		struct breakpoint *breakpoint, uint8_t matchmode);
-static int cortex_a9_unset_breakpoint(struct target *target,
-		struct breakpoint *breakpoint);
-static int cortex_a9_dap_read_coreregister_u32(struct target *target,
-		uint32_t *value, int regnum);
-static int cortex_a9_dap_write_coreregister_u32(struct target *target,
-		uint32_t value, int regnum);
-static int cortex_a9_mmu(struct target *target, int *enabled);
-static int cortex_a9_virt2phys(struct target *target,
-                uint32_t virt, uint32_t *phys);
-static int cortex_a9_disable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache);
-static int cortex_a9_enable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache);
-static int cortex_a9_get_ttb(struct target *target, uint32_t *result);
-
-
-/*
- * FIXME do topology discovery using the ROM; don't
- * assume this is an OMAP3.   Also, allow for multiple ARMv7-A
- * cores, with different AP numbering ... don't use a #define
- * for these numbers, use per-core armv7a state.
- */
-#define swjdp_memoryap 0
-#define swjdp_debugap 1
-
-/*
- * Cortex-A9 Basic debug access, very low level assumes state is saved
- */
-static int cortex_a9_init_debug_access(struct target *target)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	int retval;
-	uint32_t dummy;
-
-	LOG_DEBUG(" ");
-
-	/* Unlocking the debug registers for modification */
-	/* The debugport might be uninitialised so try twice */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
-	if (retval != ERROR_OK)
-	{
-		/* try again */
-		retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
-		if (retval == ERROR_OK)
-		{
-			LOG_USER("Locking debug access failed on first, but succeeded on second try.");
-		}
-	}
-	if (retval != ERROR_OK)
-		return retval;
-	/* Clear Sticky Power Down status Bit in PRSR to enable access to
-	   the registers in the Core Power Domain */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_PRSR, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Enabling of instruction execution in debug mode is done in debug_entry code */
-
-	/* Resync breakpoint registers */
-
-	/* Since this is likely called from init or reset, update target state information*/
-	return cortex_a9_poll(target);
-}
-
-/* To reduce needless round-trips, pass in a pointer to the current
- * DSCR value.  Initialize it to zero if you just need to know the
- * value on return from this function; or DSCR_INSTR_COMP if you
- * happen to know that no instruction is pending.
- */
-static int cortex_a9_exec_opcode(struct target *target,
-		uint32_t opcode, uint32_t *dscr_p)
-{
-	uint32_t dscr;
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-
-	dscr = dscr_p ? *dscr_p : 0;
-
-	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
-
-	/* Wait for InstrCompl bit to be set */
-	long long then = timeval_ms();
-	while ((dscr & DSCR_INSTR_COMP) == 0)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-		if (retval != ERROR_OK)
-		{
-			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
-			return retval;
-		}
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("Timeout waiting for cortex_a9_exec_opcode");
-			return ERROR_FAIL;
-		}
-	}
-
-	retval = mem_ap_sel_write_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_ITR, opcode);
-	if (retval != ERROR_OK)
-		return retval;
-
-	then = timeval_ms();
-	do
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-		if (retval != ERROR_OK)
-		{
-			LOG_ERROR("Could not read DSCR register");
-			return retval;
-		}
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("Timeout waiting for cortex_a9_exec_opcode");
-			return ERROR_FAIL;
-		}
-	}
-	while ((dscr & DSCR_INSTR_COMP) == 0); /* Wait for InstrCompl bit to be set */
-
-	if (dscr_p)
-		*dscr_p = dscr;
-
-	return retval;
-}
-
-/**************************************************************************
-Read core register with very few exec_opcode, fast but needs work_area.
-This can cause problems with MMU active.
-**************************************************************************/
-static int cortex_a9_read_regs_through_mem(struct target *target, uint32_t address,
-		uint32_t * regfile)
-{
-	int retval = ERROR_OK;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-
-	retval = cortex_a9_dap_read_coreregister_u32(target, regfile, 0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a9_dap_write_coreregister_u32(target, address, 0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a9_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
-			(uint8_t *)(&regfile[1]), 4*15, address);
-
-	return retval;
-}
-
-static int cortex_a9_dap_read_coreregister_u32(struct target *target,
-		uint32_t *value, int regnum)
-{
-	int retval = ERROR_OK;
-	uint8_t reg = regnum&0xFF;
-	uint32_t dscr = 0;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-
-	if (reg > 17)
-		return retval;
-
-	if (reg < 15)
-	{
-		/* Rn to DCCTX, "MCR p14, 0, Rn, c0, c5, 0"  0xEE00nE15 */
-		retval = cortex_a9_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else if (reg == 15)
-	{
-		/* "MOV r0, r15"; then move r0 to DCCTX */
-		retval = cortex_a9_exec_opcode(target, 0xE1A0000F, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		/* "MRS r0, CPSR" or "MRS r0, SPSR"
-		 * then move r0 to DCCTX
-		 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	/* Wait for DTRRXfull then read DTRRTX */
-	long long then = timeval_ms();
-	while ((dscr & DSCR_DTR_TX_FULL) == 0)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("Timeout waiting for cortex_a9_exec_opcode");
-			return ERROR_FAIL;
-		}
-	}
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DTRTX, value);
-	LOG_DEBUG("read DCC 0x%08" PRIx32, *value);
-
-	return retval;
-}
-
-static int cortex_a9_dap_write_coreregister_u32(struct target *target,
-		uint32_t value, int regnum)
-{
-	int retval = ERROR_OK;
-	uint8_t Rd = regnum&0xFF;
-	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-
-	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
-
-	/* Check that DCCRX is not full */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (retval != ERROR_OK)
-		return retval;
-	if (dscr & DSCR_DTR_RX_FULL)
-	{
-		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
-		/* Clear DCCRX with MRC(p14, 0, Rd, c0, c5, 0), opcode  0xEE100E15 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	if (Rd > 17)
-		return retval;
-
-	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
-	LOG_DEBUG("write DCC 0x%08" PRIx32, value);
-	retval = mem_ap_sel_write_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DTRRX, value);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (Rd < 15)
-	{
-		/* DCCRX to Rn, "MRC p14, 0, Rn, c0, c5, 0", 0xEE10nE15 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else if (Rd == 15)
-	{
-		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
-		 * then "mov r15, r0"
-		 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target, 0xE1A0F000, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
-		 * then "MSR CPSR_cxsf, r0" or "MSR SPSR_cxsf, r0" (all fields)
-		 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, Rd & 1),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* "Prefetch flush" after modifying execution status in CPSR */
-		if (Rd == 16)
-		{
-			retval = cortex_a9_exec_opcode(target,
-					ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
-					&dscr);
-			if (retval != ERROR_OK)
-				return retval;
-		}
-	}
-
-	return retval;
-}
-
-/* Write to memory mapped registers directly with no cache or mmu handling */
-static int cortex_a9_dap_write_memap_register_u32(struct target *target, uint32_t address, uint32_t value)
-{
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap, address, value);
-
-	return retval;
-}
-
-/*
- * Cortex-A9 implementation of Debug Programmer's Model
- *
- * NOTE the invariant:  these routines return with DSCR_INSTR_COMP set,
- * so there's no need to poll for it before executing an instruction.
- *
- * NOTE that in several of these cases the "stall" mode might be useful.
- * It'd let us queue a few operations together... prepare/finish might
- * be the places to enable/disable that mode.
- */
-
-static inline struct cortex_a9_common *dpm_to_a9(struct arm_dpm *dpm)
-{
-	return container_of(dpm, struct cortex_a9_common, armv7a_common.dpm);
-}
-
-static int cortex_a9_write_dcc(struct cortex_a9_common *a9, uint32_t data)
-{
-	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
-	return mem_ap_sel_write_u32(&a9->armv7a_common.dap, swjdp_debugap,
-			a9->armv7a_common.debug_base + CPUDBG_DTRRX, data);
-}
-
-static int cortex_a9_read_dcc(struct cortex_a9_common *a9, uint32_t *data,
-		uint32_t *dscr_p)
-{
-	struct adiv5_dap *swjdp = &a9->armv7a_common.dap;
-	uint32_t dscr = DSCR_INSTR_COMP;
-	int retval;
-
-	if (dscr_p)
-		dscr = *dscr_p;
-
-	/* Wait for DTRRXfull */
-	long long then = timeval_ms();
-	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				a9->armv7a_common.debug_base + CPUDBG_DSCR,
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("Timeout waiting for read dcc");
-			return ERROR_FAIL;
-		}
-	}
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			a9->armv7a_common.debug_base + CPUDBG_DTRTX, data);
-	if (retval != ERROR_OK)
-		return retval;
-	//LOG_DEBUG("read DCC 0x%08" PRIx32, *data);
-
-	if (dscr_p)
-		*dscr_p = dscr;
-
-	return retval;
-}
-
-static int cortex_a9_dpm_prepare(struct arm_dpm *dpm)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	struct adiv5_dap *swjdp = &a9->armv7a_common.dap;
-	uint32_t dscr;
-	int retval;
-
-	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
-	long long then = timeval_ms();
-	for (;;)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				a9->armv7a_common.debug_base + CPUDBG_DSCR,
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((dscr & DSCR_INSTR_COMP) != 0)
-			break;
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("Timeout waiting for dpm prepare");
-			return ERROR_FAIL;
-		}
-	}
-
-	/* this "should never happen" ... */
-	if (dscr & DSCR_DTR_RX_FULL) {
-		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
-		/* Clear DCCRX */
-		retval = cortex_a9_exec_opcode(
-				a9->armv7a_common.armv4_5_common.target,
-				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return retval;
-}
-
-static int cortex_a9_dpm_finish(struct arm_dpm *dpm)
-{
-	/* REVISIT what could be done here? */
-	return ERROR_OK;
-}
-
-static int cortex_a9_instr_write_data_dcc(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	int retval;
-	uint32_t dscr = DSCR_INSTR_COMP;
-
-	retval = cortex_a9_write_dcc(a9, data);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return cortex_a9_exec_opcode(
-			a9->armv7a_common.armv4_5_common.target,
-			opcode,
-			&dscr);
-}
-
-static int cortex_a9_instr_write_data_r0(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t dscr = DSCR_INSTR_COMP;
-	int retval;
-
-	retval = cortex_a9_write_dcc(a9, data);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15 */
-	retval = cortex_a9_exec_opcode(
-			a9->armv7a_common.armv4_5_common.target,
-			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-			&dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* then the opcode, taking data from R0 */
-	retval = cortex_a9_exec_opcode(
-			a9->armv7a_common.armv4_5_common.target,
-			opcode,
-			&dscr);
-
-	return retval;
-}
-
-static int cortex_a9_instr_cpsr_sync(struct arm_dpm *dpm)
-{
-	struct target *target = dpm->arm->target;
-	uint32_t dscr = DSCR_INSTR_COMP;
-
-	/* "Prefetch flush" after modifying execution status in CPSR */
-	return cortex_a9_exec_opcode(target,
-			ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
-			&dscr);
-}
-
-static int cortex_a9_instr_read_data_dcc(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t *data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	int retval;
-	uint32_t dscr = DSCR_INSTR_COMP;
-
-	/* the opcode, writing data to DCC */
-	retval = cortex_a9_exec_opcode(
-			a9->armv7a_common.armv4_5_common.target,
-			opcode,
-			&dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return cortex_a9_read_dcc(a9, data, &dscr);
-}
-
-
-static int cortex_a9_instr_read_data_r0(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t *data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t dscr = DSCR_INSTR_COMP;
-	int retval;
-
-	/* the opcode, writing data to R0 */
-	retval = cortex_a9_exec_opcode(
-			a9->armv7a_common.armv4_5_common.target,
-			opcode,
-			&dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write R0 to DCC */
-	retval = cortex_a9_exec_opcode(
-			a9->armv7a_common.armv4_5_common.target,
-			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-			&dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return cortex_a9_read_dcc(a9, data, &dscr);
-}
-
-static int cortex_a9_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
-		uint32_t addr, uint32_t control)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t vr = a9->armv7a_common.debug_base;
-	uint32_t cr = a9->armv7a_common.debug_base;
-	int retval;
-
-	switch (index_t) {
-	case 0 ... 15:		/* breakpoints */
-		vr += CPUDBG_BVR_BASE;
-		cr += CPUDBG_BCR_BASE;
-		break;
-	case 16 ... 31:		/* watchpoints */
-		vr += CPUDBG_WVR_BASE;
-		cr += CPUDBG_WCR_BASE;
-		index_t -= 16;
-		break;
-	default:
-		return ERROR_FAIL;
-	}
-	vr += 4 * index_t;
-	cr += 4 * index_t;
-
-	LOG_DEBUG("A9: bpwp enable, vr %08x cr %08x",
-			(unsigned) vr, (unsigned) cr);
-
-	retval = cortex_a9_dap_write_memap_register_u32(dpm->arm->target,
-			vr, addr);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a9_dap_write_memap_register_u32(dpm->arm->target,
-			cr, control);
-	return retval;
-}
-
-static int cortex_a9_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t cr;
-
-	switch (index_t) {
-	case 0 ... 15:
-		cr = a9->armv7a_common.debug_base + CPUDBG_BCR_BASE;
-		break;
-	case 16 ... 31:
-		cr = a9->armv7a_common.debug_base + CPUDBG_WCR_BASE;
-		index_t -= 16;
-		break;
-	default:
-		return ERROR_FAIL;
-	}
-	cr += 4 * index_t;
-
-	LOG_DEBUG("A9: bpwp disable, cr %08x", (unsigned) cr);
-
-	/* clear control register */
-	return cortex_a9_dap_write_memap_register_u32(dpm->arm->target, cr, 0);
-}
-
-static int cortex_a9_dpm_setup(struct cortex_a9_common *a9, uint32_t didr)
-{
-	struct arm_dpm *dpm = &a9->armv7a_common.dpm;
-	int retval;
-
-	dpm->arm = &a9->armv7a_common.armv4_5_common;
-	dpm->didr = didr;
-
-	dpm->prepare = cortex_a9_dpm_prepare;
-	dpm->finish = cortex_a9_dpm_finish;
-
-	dpm->instr_write_data_dcc = cortex_a9_instr_write_data_dcc;
-	dpm->instr_write_data_r0 = cortex_a9_instr_write_data_r0;
-	dpm->instr_cpsr_sync = cortex_a9_instr_cpsr_sync;
-
-	dpm->instr_read_data_dcc = cortex_a9_instr_read_data_dcc;
-	dpm->instr_read_data_r0 = cortex_a9_instr_read_data_r0;
-
-	dpm->bpwp_enable = cortex_a9_bpwp_enable;
-	dpm->bpwp_disable = cortex_a9_bpwp_disable;
-
-	retval = arm_dpm_setup(dpm);
-	if (retval == ERROR_OK)
-		retval = arm_dpm_initialize(dpm);
-
-	return retval;
-}
-
-
-/*
- * Cortex-A9 Run control
- */
-
-static int cortex_a9_poll(struct target *target)
-{
-	int retval = ERROR_OK;
-	uint32_t dscr;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	enum target_state prev_target_state = target->state;
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (retval != ERROR_OK)
-	{
-		return retval;
-	}
-	cortex_a9->cpudbg_dscr = dscr;
-
-	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
-	{
-		if (prev_target_state != TARGET_HALTED)
-		{
-			/* We have a halting debug event */
-			LOG_DEBUG("Target halted");
-			target->state = TARGET_HALTED;
-			if ((prev_target_state == TARGET_RUNNING)
-					|| (prev_target_state == TARGET_RESET))
-			{
-				retval = cortex_a9_debug_entry(target);
-				if (retval != ERROR_OK)
-					return retval;
-
-				target_call_event_callbacks(target,
-						TARGET_EVENT_HALTED);
-			}
-			if (prev_target_state == TARGET_DEBUG_RUNNING)
-			{
-				LOG_DEBUG(" ");
-
-				retval = cortex_a9_debug_entry(target);
-				if (retval != ERROR_OK)
-					return retval;
-
-				target_call_event_callbacks(target,
-						TARGET_EVENT_DEBUG_HALTED);
-			}
-		}
-	}
-	else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
-	{
-		target->state = TARGET_RUNNING;
-	}
-	else
-	{
-		LOG_DEBUG("Unknown target state dscr = 0x%08" PRIx32, dscr);
-		target->state = TARGET_UNKNOWN;
-	}
-
-	return retval;
-}
-
-static int cortex_a9_halt(struct target *target)
-{
-	int retval = ERROR_OK;
-	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-
-	/*
-	 * Tell the core to be halted by writing DRCR with 0x1
-	 * and then wait for the core to be halted.
-	 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DRCR, DRCR_HALT);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * enter halting debug mode
-	 */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-		armv7a->debug_base + CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
-	if (retval != ERROR_OK)
-		return retval;
-
-	long long then = timeval_ms();
-	for (;;)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((dscr & DSCR_CORE_HALTED) != 0)
-		{
-			break;
-		}
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("Timeout waiting for halt");
-			return ERROR_FAIL;
-		}
-	}
-
-	target->debug_reason = DBG_REASON_DBGRQ;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	int retval;
-
-//	struct breakpoint *breakpoint = NULL;
-	uint32_t resume_pc, dscr;
-
-	if (!debug_execution)
-		target_free_all_working_areas(target);
-
-#if 0
-	if (debug_execution)
-	{
-		/* Disable interrupts */
-		/* We disable interrupts in the PRIMASK register instead of
-		 * masking with C_MASKINTS,
-		 * This is probably the same issue as Cortex-M3 Errata 377493:
-		 * C_MASKINTS in parallel with disabled interrupts can cause
-		 * local faults to not be taken. */
-		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_PRIMASK].value, 0, 32, 1);
-		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].dirty = 1;
-		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].valid = 1;
-
-		/* Make sure we are in Thumb mode */
-		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32,
-			buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32) | (1 << 24));
-		armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty = 1;
-		armv7m->core_cache->reg_list[ARMV7M_xPSR].valid = 1;
-	}
-#endif
-
-	/* current = 1: continue on current pc, otherwise continue at <address> */
-	resume_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
-	if (!current)
-		resume_pc = address;
-
-	/* Make sure that the Armv7 gdb thumb fixups does not
-	 * kill the return address
-	 */
-	switch (armv4_5->core_state)
-	{
-	case ARM_STATE_ARM:
-		resume_pc &= 0xFFFFFFFC;
-		break;
-	case ARM_STATE_THUMB:
-	case ARM_STATE_THUMB_EE:
-		/* When the return address is loaded into PC
-		 * bit 0 must be 1 to stay in Thumb state
-		 */
-		resume_pc |= 0x1;
-		break;
-	case ARM_STATE_JAZELLE:
-		LOG_ERROR("How do I resume into Jazelle state??");
-		return ERROR_FAIL;
-	}
-	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
-	buf_set_u32(armv4_5->pc->value, 0, 32, resume_pc);
-	armv4_5->pc->dirty = 1;
-	armv4_5->pc->valid = 1;
-
-	retval = cortex_a9_restore_context(target, handle_breakpoints);
-	if (retval != ERROR_OK)
-		return retval;
-
-#if 0
-	/* the front-end may request us not to handle breakpoints */
-	if (handle_breakpoints)
-	{
-		/* Single step past breakpoint at current address */
-		if ((breakpoint = breakpoint_find(target, resume_pc)))
-		{
-			LOG_DEBUG("unset breakpoint at 0x%8.8x", breakpoint->address);
-			cortex_m3_unset_breakpoint(target, breakpoint);
-			cortex_m3_single_step_core(target);
-			cortex_m3_set_breakpoint(target, breakpoint);
-		}
-	}
-
-#endif
-
-	/*
-	 * Restart core and wait for it to be started.  Clear ITRen and sticky
-	 * exception flags: see ARMv7 ARM, C5.9.
-	 *
-	 * REVISIT: for single stepping, we probably want to
-	 * disable IRQs by default, with optional override...
-	 */
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if ((dscr & DSCR_INSTR_COMP) == 0)
-		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-		armv7a->debug_base + CPUDBG_DSCR, dscr & ~DSCR_ITR_EN);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DRCR, DRCR_RESTART | DRCR_CLEAR_EXCEPTIONS);
-	if (retval != ERROR_OK)
-		return retval;
-
-	long long then = timeval_ms();
-	for (;;)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((dscr & DSCR_CORE_RESTARTED) != 0)
-			break;
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("Timeout waiting for resume");
-			return ERROR_FAIL;
-		}
-	}
-
-	target->debug_reason = DBG_REASON_NOTHALTED;
-	target->state = TARGET_RUNNING;
-
-	/* registers are now invalid */
-	register_cache_invalidate(armv4_5->core_cache);
-
-	if (!debug_execution)
-	{
-		target->state = TARGET_RUNNING;
-		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%" PRIx32, resume_pc);
-	}
-	else
-	{
-		target->state = TARGET_DEBUG_RUNNING;
-		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%" PRIx32, resume_pc);
-	}
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_debug_entry(struct target *target)
-{
-	int i;
-	uint32_t regfile[16], cpsr, dscr;
-	int retval = ERROR_OK;
-	struct working_area *regfile_working_area = NULL;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	struct reg *reg;
-
-	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a9->cpudbg_dscr);
-
-	/* REVISIT surely we should not re-read DSCR !! */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* REVISIT see A9 TRM 12.11.4 steps 2..3 -- make sure that any
-	 * imprecise data aborts get discarded by issuing a Data
-	 * Synchronization Barrier:  ARMV4_5_MCR(15, 0, 0, 7, 10, 4).
-	 */
-
-	/* Enable the ITR execution once we are in debug mode */
-	dscr |= DSCR_ITR_EN;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Examine debug reason */
-	arm_dpm_report_dscr(&armv7a->dpm, cortex_a9->cpudbg_dscr);
-
-	/* save address of instruction that triggered the watchpoint? */
-	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
-		uint32_t wfar;
-
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a->debug_base + CPUDBG_WFAR,
-				&wfar);
-		if (retval != ERROR_OK)
-			return retval;
-		arm_dpm_report_wfar(&armv7a->dpm, wfar);
-	}
-
-	/* REVISIT fast_reg_read is never set ... */
-
-	/* Examine target state and mode */
-	if (cortex_a9->fast_reg_read)
-		target_alloc_working_area(target, 64, &regfile_working_area);
-
-	/* First load register acessible through core debug port*/
-	if (!regfile_working_area)
-	{
-		retval = arm_dpm_read_current_registers(&armv7a->dpm);
-	}
-	else
-	{
-		retval = cortex_a9_read_regs_through_mem(target,
-				regfile_working_area->address, regfile);
-
-		target_free_working_area(target, regfile_working_area);
-		if (retval != ERROR_OK)
-		{
-			return retval;
-		}
-
-		/* read Current PSR */
-		retval = cortex_a9_dap_read_coreregister_u32(target, &cpsr, 16);
-		if (retval != ERROR_OK)
-			return retval;
-
-		LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
-
-		arm_set_cpsr(armv4_5, cpsr);
-
-		/* update cache */
-		for (i = 0; i <= ARM_PC; i++)
-		{
-			reg = arm_reg_current(armv4_5, i);
-
-			buf_set_u32(reg->value, 0, 32, regfile[i]);
-			reg->valid = 1;
-			reg->dirty = 0;
-		}
-
-		/* Fixup PC Resume Address */
-		if (cpsr & (1 << 5))
-		{
-			// T bit set for Thumb or ThumbEE state
-			regfile[ARM_PC] -= 4;
-		}
-		else
-		{
-			// ARM state
-			regfile[ARM_PC] -= 8;
-		}
-
-		reg = armv4_5->pc;
-		buf_set_u32(reg->value, 0, 32, regfile[ARM_PC]);
-		reg->dirty = reg->valid;
-	}
-
-#if 0
-/* TODO, Move this */
-	uint32_t cp15_control_register, cp15_cacr, cp15_nacr;
-	cortex_a9_read_cp(target, &cp15_control_register, 15, 0, 1, 0, 0);
-	LOG_DEBUG("cp15_control_register = 0x%08x", cp15_control_register);
-
-	cortex_a9_read_cp(target, &cp15_cacr, 15, 0, 1, 0, 2);
-	LOG_DEBUG("cp15 Coprocessor Access Control Register = 0x%08x", cp15_cacr);
-
-	cortex_a9_read_cp(target, &cp15_nacr, 15, 0, 1, 1, 2);
-	LOG_DEBUG("cp15 Nonsecure Access Control Register = 0x%08x", cp15_nacr);
-#endif
-
-	/* Are we in an exception handler */
-//	armv4_5->exception_number = 0;
-	if (armv7a->post_debug_entry)
-	{
-		retval = armv7a->post_debug_entry(target);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return retval;
-}
-
-static int cortex_a9_post_debug_entry(struct target *target)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	int retval;
-
-	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-	retval = armv7a->armv4_5_common.mrc(target, 15,
-			0, 0,	/* op1, op2 */
-			1, 0,	/* CRn, CRm */
-			&cortex_a9->cp15_control_reg);
-	if (retval != ERROR_OK)
-		return retval;
-	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a9->cp15_control_reg);
-
-	if (armv7a->armv4_5_mmu.armv4_5_cache.ctype == -1)
-	{
-		uint32_t cache_type_reg;
-
-		/* MRC p15,0,<Rt>,c0,c0,1 ; Read CP15 Cache Type Register */
-		retval = armv7a->armv4_5_common.mrc(target, 15,
-				0, 1,	/* op1, op2 */
-				0, 0,	/* CRn, CRm */
-				&cache_type_reg);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG("cp15 cache type: %8.8x", (unsigned) cache_type_reg);
-
-		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A9 */
-		armv4_5_identify_cache(cache_type_reg,
-				&armv7a->armv4_5_mmu.armv4_5_cache);
-	}
-
-	armv7a->armv4_5_mmu.mmu_enabled =
-			(cortex_a9->cp15_control_reg & 0x1U) ? 1 : 0;
-	armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled =
-			(cortex_a9->cp15_control_reg & 0x4U) ? 1 : 0;
-	armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled =
-			(cortex_a9->cp15_control_reg & 0x1000U) ? 1 : 0;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_step(struct target *target, int current, uint32_t address,
-		int handle_breakpoints)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct breakpoint *breakpoint = NULL;
-	struct breakpoint stepbreakpoint;
-	struct reg *r;
-	int retval;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* current = 1: continue on current pc, otherwise continue at <address> */
-	r = armv4_5->pc;
-	if (!current)
-	{
-		buf_set_u32(r->value, 0, 32, address);
-	}
-	else
-	{
-		address = buf_get_u32(r->value, 0, 32);
-	}
-
-	/* The front-end may request us not to handle breakpoints.
-	 * But since Cortex-A9 uses breakpoint for single step,
-	 * we MUST handle breakpoints.
-	 */
-	handle_breakpoints = 1;
-	if (handle_breakpoints) {
-		breakpoint = breakpoint_find(target, address);
-		if (breakpoint)
-			cortex_a9_unset_breakpoint(target, breakpoint);
-	}
-
-	/* Setup single step breakpoint */
-	stepbreakpoint.address = address;
-	stepbreakpoint.length = (armv4_5->core_state == ARM_STATE_THUMB)
-			? 2 : 4;
-	stepbreakpoint.type = BKPT_HARD;
-	stepbreakpoint.set = 0;
-
-	/* Break on IVA mismatch */
-	cortex_a9_set_breakpoint(target, &stepbreakpoint, 0x04);
-
-	target->debug_reason = DBG_REASON_SINGLESTEP;
-
-	retval = cortex_a9_resume(target, 1, address, 0, 0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	long long then = timeval_ms();
-	while (target->state != TARGET_HALTED)
-	{
-		retval = cortex_a9_poll(target);
-		if (retval != ERROR_OK)
-			return retval;
-		if (timeval_ms() > then + 1000)
-		{
-			LOG_ERROR("timeout waiting for target halt");
-			return ERROR_FAIL;
-		}
-	}
-
-	cortex_a9_unset_breakpoint(target, &stepbreakpoint);
-
-	target->debug_reason = DBG_REASON_BREAKPOINT;
-
-	if (breakpoint)
-		cortex_a9_set_breakpoint(target, breakpoint, 0);
-
-	if (target->state != TARGET_HALTED)
-		LOG_DEBUG("target stepped");
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_restore_context(struct target *target, bool bpwp)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	LOG_DEBUG(" ");
-
-	if (armv7a->pre_restore_context)
-		armv7a->pre_restore_context(target);
-
-	return arm_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
-}
-
-
-/*
- * Cortex-A9 Breakpoint and watchpoint functions
- */
-
-/* Setup hardware Breakpoint Register Pair */
-static int cortex_a9_set_breakpoint(struct target *target,
-		struct breakpoint *breakpoint, uint8_t matchmode)
-{
-	int retval;
-	int brp_i=0;
-	uint32_t control;
-	uint8_t byte_addr_select = 0x0F;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	struct cortex_a9_brp * brp_list = cortex_a9->brp_list;
-
-	if (breakpoint->set)
-	{
-		LOG_WARNING("breakpoint already set");
-		return ERROR_OK;
-	}
-
-	if (breakpoint->type == BKPT_HARD)
-	{
-		while (brp_list[brp_i].used && (brp_i < cortex_a9->brp_num))
-			brp_i++ ;
-		if (brp_i >= cortex_a9->brp_num)
-		{
-			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-		breakpoint->set = brp_i + 1;
-		if (breakpoint->length == 2)
-		{
-			byte_addr_select = (3 << (breakpoint->address & 0x02));
-		}
-		control = ((matchmode & 0x7) << 20)
-				| (byte_addr_select << 5)
-				| (3 << 1) | 1;
-		brp_list[brp_i].used = 1;
-		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
-		brp_list[brp_i].control = control;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].value);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].control);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-				brp_list[brp_i].control,
-				brp_list[brp_i].value);
-	}
-	else if (breakpoint->type == BKPT_SOFT)
-	{
-		uint8_t code[4];
-		if (breakpoint->length == 2)
-		{
-			buf_set_u32(code, 0, 32, ARMV5_T_BKPT(0x11));
-		}
-		else
-		{
-			buf_set_u32(code, 0, 32, ARMV5_BKPT(0x11));
-		}
-		retval = target->type->read_memory(target,
-				breakpoint->address & 0xFFFFFFFE,
-				breakpoint->length, 1,
-				breakpoint->orig_instr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target->type->write_memory(target,
-				breakpoint->address & 0xFFFFFFFE,
-				breakpoint->length, 1, code);
-		if (retval != ERROR_OK)
-			return retval;
-		breakpoint->set = 0x11; /* Any nice value but 0 */
-	}
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
-{
-	int retval;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	struct cortex_a9_brp * brp_list = cortex_a9->brp_list;
-
-	if (!breakpoint->set)
-	{
-		LOG_WARNING("breakpoint not set");
-		return ERROR_OK;
-	}
-
-	if (breakpoint->type == BKPT_HARD)
-	{
-		int brp_i = breakpoint->set - 1;
-		if ((brp_i < 0) || (brp_i >= cortex_a9->brp_num))
-		{
-			LOG_DEBUG("Invalid BRP number in breakpoint");
-			return ERROR_OK;
-		}
-		LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-				brp_list[brp_i].control, brp_list[brp_i].value);
-		brp_list[brp_i].used = 0;
-		brp_list[brp_i].value = 0;
-		brp_list[brp_i].control = 0;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].control);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		/* restore original instruction (kept in target endianness) */
-		if (breakpoint->length == 4)
-		{
-			retval = target->type->write_memory(target,
-					breakpoint->address & 0xFFFFFFFE,
-					4, 1, breakpoint->orig_instr);
-			if (retval != ERROR_OK)
-				return retval;
-		}
-		else
-		{
-			retval = target->type->write_memory(target,
-					breakpoint->address & 0xFFFFFFFE,
-					2, 1, breakpoint->orig_instr);
-			if (retval != ERROR_OK)
-				return retval;
-		}
-	}
-	breakpoint->set = 0;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_add_breakpoint(struct target *target,
-		struct breakpoint *breakpoint)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-
-	if ((breakpoint->type == BKPT_HARD) && (cortex_a9->brp_num_available < 1))
-	{
-		LOG_INFO("no hardware breakpoint available");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
-
-	if (breakpoint->type == BKPT_HARD)
-		cortex_a9->brp_num_available--;
-
-	return cortex_a9_set_breakpoint(target, breakpoint, 0x00); /* Exact match */
-}
-
-static int cortex_a9_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-
-#if 0
-/* It is perfectly possible to remove breakpoints while the target is running */
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-#endif
-
-	if (breakpoint->set)
-	{
-		cortex_a9_unset_breakpoint(target, breakpoint);
-		if (breakpoint->type == BKPT_HARD)
-			cortex_a9->brp_num_available++ ;
-	}
-
-
-	return ERROR_OK;
-}
-
-
-
-/*
- * Cortex-A9 Reset functions
- */
-
-static int cortex_a9_assert_reset(struct target *target)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	LOG_DEBUG(" ");
-
-	/* FIXME when halt is requested, make it work somehow... */
-
-	/* Issue some kind of warm reset. */
-	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
-		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
-	} else if (jtag_get_reset_config() & RESET_HAS_SRST) {
-		/* REVISIT handle "pulls" cases, if there's
-		 * hardware that needs them to work.
-		 */
-		jtag_add_reset(0, 1);
-	} else {
-		LOG_ERROR("%s: how to reset?", target_name(target));
-		return ERROR_FAIL;
-	}
-
-	/* registers are now invalid */
-	register_cache_invalidate(armv7a->armv4_5_common.core_cache);
-
-	target->state = TARGET_RESET;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_deassert_reset(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG(" ");
-
-	/* be certain SRST is off */
-	jtag_add_reset(0, 0);
-
-	retval = cortex_a9_poll(target);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (target->reset_halt) {
-		if (target->state != TARGET_HALTED) {
-			LOG_WARNING("%s: ran after reset and before halt ...",
-					target_name(target));
-			if ((retval = target_halt(target)) != ERROR_OK)
-				return retval;
-		}
-	}
-
-	return ERROR_OK;
-}
-
-/*
- * Cortex-A9 Memory access
- *
- * This is same Cortex M3 but we must also use the correct
- * ap number for every access.
- */
-
-static int cortex_a9_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	int retval = ERROR_INVALID_ARGUMENTS;
-	uint8_t apsel = swjdp->apsel;
-
-	LOG_DEBUG("Reading memory at real address 0x%x; size %d; count %d", address, size, count);
-
-	if (count && buffer) {
-
-		if ( apsel == swjdp_memoryap ) {
-
-			/* read memory through AHB-AP */
-
-			switch (size) {
-				case 4:
-					retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
-							buffer, 4 * count, address);
-					break;
-				case 2:
-					retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
-							buffer, 2 * count, address);
-					break;
-				case 1:
-					retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
-							buffer, count, address);
-					break;
-			}
-
-		} else {
-
-			/* read memory through APB-AP */
-
-			uint32_t saved_r0, saved_r1;
-			int nbytes = count * size;
-			uint32_t data;
-			int enabled = 0;
-
-			if (target->state != TARGET_HALTED)
-			{
-				LOG_WARNING("target not halted");
-				return ERROR_TARGET_NOT_HALTED;
-			}
-
-			retval = cortex_a9_mmu(target, &enabled);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if (enabled)
-			{
-				LOG_WARNING("Reading physical memory through APB with MMU enabled is not yet implemented");
-				return ERROR_TARGET_FAILURE;
-			}
-
-			/* save registers r0 and r1, we are going to corrupt them  */
-			retval = cortex_a9_dap_read_coreregister_u32(target, &saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_read_coreregister_u32(target, &saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, address, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			while (nbytes > 0) {
-
-				/* execute instruction LDRB r1, [r0], 1 (0xe4d01001) */
-				retval = cortex_a9_exec_opcode(target, ARMV4_5_LDRB_IP(1, 0) , NULL);
-				if (retval != ERROR_OK)
-						return retval;
-
-				retval = cortex_a9_dap_read_coreregister_u32(target, &data, 1);
-				if (retval != ERROR_OK)
-					return retval;
-
-				*buffer++ = data;
-				--nbytes;
-
-			}
-
-			/* restore corrupted registers r0 and r1 */
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-		}
-	}
-
-	return retval;
-}
-
-static int cortex_a9_read_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
-{
-	int enabled = 0;
-	uint32_t virt, phys;
-	int retval;
-
-	/* cortex_a9 handles unaligned memory access */
-
-	LOG_DEBUG("Reading memory at address 0x%x; size %d; count %d", address, size, count);
-	retval = cortex_a9_mmu(target, &enabled);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (enabled)
-	{
-		virt = address;
-		retval = cortex_a9_virt2phys(target, virt, &phys);
-		if (retval != ERROR_OK)
-			return retval;
-
-		LOG_DEBUG("Reading at virtual address. Translating v:0x%x to r:0x%x", virt, phys);
-		address = phys;
-	}
-
-	return cortex_a9_read_phys_memory(target, address, size, count, buffer);
-}
-
-static int cortex_a9_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	int retval = ERROR_INVALID_ARGUMENTS;
-	uint8_t apsel = swjdp->apsel;
-
-	LOG_DEBUG("Writing memory to real address 0x%x; size %d; count %d", address, size, count);
-
-	if (count && buffer) {
-
-		if ( apsel == swjdp_memoryap ) {
-
-			/* write memory through AHB-AP */
-
-			switch (size) {
-				case 4:
-					retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,
-							buffer, 4 * count, address);
-					break;
-				case 2:
-					retval = mem_ap_sel_write_buf_u16(swjdp, swjdp_memoryap,
-							buffer, 2 * count, address);
-					break;
-				case 1:
-					retval = mem_ap_sel_write_buf_u8(swjdp, swjdp_memoryap,
-							buffer, count, address);
-					break;
-			}
-
-		} else {
-
-			/* write memory through APB-AP */
-
-			uint32_t saved_r0, saved_r1;
-			int nbytes = count * size;
-			uint32_t data;
-			int enabled = 0;
-
-			if (target->state != TARGET_HALTED)
-			{
-				LOG_WARNING("target not halted");
-				return ERROR_TARGET_NOT_HALTED;
-			}
-
-			retval = cortex_a9_mmu(target, &enabled);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if (enabled)
-			{
-				LOG_WARNING("Writing physical memory through APB with MMU enabled is not yet implemented");
-				return ERROR_TARGET_FAILURE;
-			}
-
-			/* save registers r0 and r1, we are going to corrupt them  */
-			retval = cortex_a9_dap_read_coreregister_u32(target, &saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_read_coreregister_u32(target, &saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, address, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			while (nbytes > 0) {
-
-				data = *buffer++;
-
-				retval = cortex_a9_dap_write_coreregister_u32(target, data, 1);
-				if (retval != ERROR_OK)
-					return retval;
-
-					/* execute instruction STRB r1, [r0], 1 (0xe4c01001) */
-				retval = cortex_a9_exec_opcode(target, ARMV4_5_STRB_IP(1, 0) , NULL);
-				if (retval != ERROR_OK)
-						return retval;
-
-				--nbytes;
-			}
-
-			/* restore corrupted registers r0 and r1 */
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			/* we can return here without invalidating D/I-cache because */
-			/* access through APB maintains cache coherency              */
-			return retval;
-		}
-	}
-
-
-	/* REVISIT this op is generic ARMv7-A/R stuff */
-	if (retval == ERROR_OK && target->state == TARGET_HALTED)
-	{
-		struct arm_dpm *dpm = armv7a->armv4_5_common.dpm;
-
-		retval = dpm->prepare(dpm);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* The Cache handling will NOT work with MMU active, the
-		 * wrong addresses will be invalidated!
-		 *
-		 * For both ICache and DCache, walk all cache lines in the
-		 * address range. Cortex-A9 has fixed 64 byte line length.
-		 *
-		 * REVISIT per ARMv7, these may trigger watchpoints ...
-		 */
-
-		/* invalidate I-Cache */
-		if (armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
-		{
-			/* ICIMVAU - Invalidate Cache single entry
-			 * with MVA to PoU
-			 *      MCR p15, 0, r0, c7, c5, 1
-			 */
-			for (uint32_t cacheline = address;
-					cacheline < address + size * count;
-					cacheline += 64) {
-				retval = dpm->instr_write_data_r0(dpm,
-						ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
-						cacheline);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-		}
-
-		/* invalidate D-Cache */
-		if (armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-		{
-			/* DCIMVAC - Invalidate data Cache line
-			 * with MVA to PoC
-			 *      MCR p15, 0, r0, c7, c6, 1
-			 */
-			for (uint32_t cacheline = address;
-					cacheline < address + size * count;
-					cacheline += 64) {
-				retval = dpm->instr_write_data_r0(dpm,
-						ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
-						cacheline);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-		}
-
-		/* (void) */ dpm->finish(dpm);
-	}
-
-	return retval;
-}
-
-static int cortex_a9_write_memory(struct target *target, uint32_t address,
-                uint32_t size, uint32_t count, uint8_t *buffer)
-{
-	int enabled = 0;
-	uint32_t virt, phys;
-	int retval;
-
-	LOG_DEBUG("Writing memory to address 0x%x; size %d; count %d", address, size, count);
-	retval = cortex_a9_mmu(target, &enabled);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (enabled)
-	{
-		virt = address;
-		retval = cortex_a9_virt2phys(target, virt, &phys);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG("Writing to virtual address. Translating v:0x%x to r:0x%x", virt, phys);
-		address = phys;
-	}
-
-	return cortex_a9_write_phys_memory(target, address, size,
-			count, buffer);
-}
-
-static int cortex_a9_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer)
-{
-	return cortex_a9_write_memory(target, address, 4, count, buffer);
-}
-
-static int cortex_a9_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
-{
-#if 0
-	u16 dcrdr;
-
-	mem_ap_read_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
-	*ctrl = (uint8_t)dcrdr;
-	*value = (uint8_t)(dcrdr >> 8);
-
-	LOG_DEBUG("data 0x%x ctrl 0x%x", *value, *ctrl);
-
-	/* write ack back to software dcc register
-	 * signify we have read data */
-	if (dcrdr & (1 << 0))
-	{
-		dcrdr = 0;
-		mem_ap_write_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
-	}
-#endif
-	return ERROR_OK;
-}
-
-
-static int cortex_a9_handle_target_request(void *priv)
-{
-	struct target *target = priv;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	int retval;
-
-	if (!target_was_examined(target))
-		return ERROR_OK;
-	if (!target->dbg_msg_enabled)
-		return ERROR_OK;
-
-	if (target->state == TARGET_RUNNING)
-	{
-		uint8_t data = 0;
-		uint8_t ctrl = 0;
-
-		retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* check if we have data */
-		if (ctrl & (1 << 0))
-		{
-			uint32_t request;
-
-			/* we assume target is quick enough */
-			request = data;
-			retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data << 8);
-			retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data << 16);
-			retval = cortex_a9_dcc_read(swjdp, &data, &ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data << 24);
-			target_request(target, request);
-		}
-	}
-
-	return ERROR_OK;
-}
-
-/*
- * Cortex-A9 target information and configuration
- */
-
-static int cortex_a9_examine_first(struct target *target)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	struct adiv5_dap *swjdp = &armv7a->dap;
-	int i;
-	int retval = ERROR_OK;
-	uint32_t didr, ctypr, ttypr, cpuid;
-
-	/* We do one extra read to ensure DAP is configured,
-	 * we call ahbap_debugport_init(swjdp) instead
-	 */
-	retval = ahbap_debugport_init(swjdp);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * FIXME: assuming omap4430
-	 *
-	 * APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
-	 * 0x80000000 is cpu0 coresight region
-	 */
-	if (target->coreid > 3) {
-		LOG_ERROR("cortex_a9 supports up to 4 cores");
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	armv7a->debug_base = 0x80000000 |
-			((target->coreid & 0x3) << CORTEX_A9_PADDRDBG_CPU_SHIFT);
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid)) != ERROR_OK)
-	{
-		LOG_DEBUG("Examine %s failed", "CPUID");
-		return retval;
-	}
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_CTYPR, &ctypr)) != ERROR_OK)
-	{
-		LOG_DEBUG("Examine %s failed", "CTYPR");
-		return retval;
-	}
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_TTYPR, &ttypr)) != ERROR_OK)
-	{
-		LOG_DEBUG("Examine %s failed", "TTYPR");
-		return retval;
-	}
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a->debug_base + CPUDBG_DIDR, &didr)) != ERROR_OK)
-	{
-		LOG_DEBUG("Examine %s failed", "DIDR");
-		return retval;
-	}
-
-	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
-	LOG_DEBUG("ctypr = 0x%08" PRIx32, ctypr);
-	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);
-	LOG_DEBUG("didr = 0x%08" PRIx32, didr);
-
-	armv7a->armv4_5_common.core_type = ARM_MODE_MON;
-	retval = cortex_a9_dpm_setup(cortex_a9, didr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Setup Breakpoint Register Pairs */
-	cortex_a9->brp_num = ((didr >> 24) & 0x0F) + 1;
-	cortex_a9->brp_num_context = ((didr >> 20) & 0x0F) + 1;
-	cortex_a9->brp_num_available = cortex_a9->brp_num;
-	cortex_a9->brp_list = calloc(cortex_a9->brp_num, sizeof(struct cortex_a9_brp));
-//	cortex_a9->brb_enabled = ????;
-	for (i = 0; i < cortex_a9->brp_num; i++)
-	{
-		cortex_a9->brp_list[i].used = 0;
-		if (i < (cortex_a9->brp_num-cortex_a9->brp_num_context))
-			cortex_a9->brp_list[i].type = BRP_NORMAL;
-		else
-			cortex_a9->brp_list[i].type = BRP_CONTEXT;
-		cortex_a9->brp_list[i].value = 0;
-		cortex_a9->brp_list[i].control = 0;
-		cortex_a9->brp_list[i].BRPn = i;
-	}
-
-	LOG_DEBUG("Configured %i hw breakpoints", cortex_a9->brp_num);
-
-	target_set_examined(target);
-	return ERROR_OK;
-}
-
-static int cortex_a9_examine(struct target *target)
-{
-	int retval = ERROR_OK;
-
-	/* don't re-probe hardware after each reset */
-	if (!target_was_examined(target))
-		retval = cortex_a9_examine_first(target);
-
-	/* Configure core debug access */
-	if (retval == ERROR_OK)
-		retval = cortex_a9_init_debug_access(target);
-
-	return retval;
-}
-
-/*
- *	Cortex-A9 target creation and initialization
- */
-
-static int cortex_a9_init_target(struct command_context *cmd_ctx,
-		struct target *target)
-{
-	/* examine_first() does a bunch of this */
-	return ERROR_OK;
-}
-
-static int cortex_a9_init_arch_info(struct target *target,
-		struct cortex_a9_common *cortex_a9, struct jtag_tap *tap)
-{
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *dap = &armv7a->dap;
-
-	armv7a->armv4_5_common.dap = dap;
-
-	/* Setup struct cortex_a9_common */
-	cortex_a9->common_magic = CORTEX_A9_COMMON_MAGIC;
-	armv4_5->arch_info = armv7a;
-
-	/* prepare JTAG information for the new target */
-	cortex_a9->jtag_info.tap = tap;
-	cortex_a9->jtag_info.scann_size = 4;
-
-	/* Leave (only) generic DAP stuff for debugport_init() */
-	dap->jtag_info = &cortex_a9->jtag_info;
-	dap->memaccess_tck = 80;
-
-	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
-	dap->tar_autoincr_block = (1 << 10);
-
-	cortex_a9->fast_reg_read = 0;
-
-	/* Set default value */
-	cortex_a9->current_address_mode = ARM_MODE_ANY;
-
-	/* register arch-specific functions */
-	armv7a->examine_debug_reason = NULL;
-
-	armv7a->post_debug_entry = cortex_a9_post_debug_entry;
-
-	armv7a->pre_restore_context = NULL;
-	armv7a->armv4_5_mmu.armv4_5_cache.ctype = -1;
-	armv7a->armv4_5_mmu.get_ttb = cortex_a9_get_ttb;
-	armv7a->armv4_5_mmu.read_memory = cortex_a9_read_phys_memory;
-	armv7a->armv4_5_mmu.write_memory = cortex_a9_write_phys_memory;
-	armv7a->armv4_5_mmu.disable_mmu_caches = cortex_a9_disable_mmu_caches;
-	armv7a->armv4_5_mmu.enable_mmu_caches = cortex_a9_enable_mmu_caches;
-	armv7a->armv4_5_mmu.has_tiny_pages = 1;
-	armv7a->armv4_5_mmu.mmu_enabled = 0;
-
-
-//	arm7_9->handle_target_request = cortex_a9_handle_target_request;
-
-	/* REVISIT v7a setup should be in a v7a-specific routine */
-	arm_init_arch_info(target, armv4_5);
-	armv7a->common_magic = ARMV7_COMMON_MAGIC;
-
-	target_register_timer_callback(cortex_a9_handle_target_request, 1, 1, target);
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_target_create(struct target *target, Jim_Interp *interp)
-{
-	struct cortex_a9_common *cortex_a9 = calloc(1, sizeof(struct cortex_a9_common));
-
-	return cortex_a9_init_arch_info(target, cortex_a9, target->tap);
-}
-
-static int cortex_a9_get_ttb(struct target *target, uint32_t *result)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-    struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-    uint32_t ttb = 0, retval = ERROR_OK;
-
-    /* current_address_mode is set inside cortex_a9_virt2phys()
-       where we can determine if address belongs to user or kernel */
-    if(cortex_a9->current_address_mode == ARM_MODE_SVC)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 1,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    else if(cortex_a9->current_address_mode == ARM_MODE_USR)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    /* we don't know whose address is: user or kernel
-       we assume that if we are in kernel mode then
-       address belongs to kernel else if in user mode
-       - to user */
-    else if(armv7a->armv4_5_common.core_mode == ARM_MODE_SVC)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 1,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    else if(armv7a->armv4_5_common.core_mode == ARM_MODE_USR)
-    {
-        /* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a->armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    /* finally we don't know whose ttb to use: user or kernel */
-    else
-        LOG_ERROR("Don't know how to get ttb for current mode!!!");
-
-    ttb &= 0xffffc000;
-
-    *result = ttb;
-
-    return ERROR_OK;
-}
-
-static int cortex_a9_disable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	uint32_t cp15_control;
-	int retval;
-
-	/* read cp15 control register */
-	retval = armv7a->armv4_5_common.mrc(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			&cp15_control);
-	if (retval != ERROR_OK)
-		return retval;
-
-
-	if (mmu)
-		cp15_control &= ~0x1U;
-
-	if (d_u_cache)
-		cp15_control &= ~0x4U;
-
-	if (i_cache)
-		cp15_control &= ~0x1000U;
-
-	retval = armv7a->armv4_5_common.mcr(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			cp15_control);
-	return retval;
-}
-
-static int cortex_a9_enable_mmu_caches(struct target *target, int mmu,
-		int d_u_cache, int i_cache)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	uint32_t cp15_control;
-	int retval;
-
-	/* read cp15 control register */
-	retval = armv7a->armv4_5_common.mrc(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			&cp15_control);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (mmu)
-		cp15_control |= 0x1U;
-
-	if (d_u_cache)
-		cp15_control |= 0x4U;
-
-	if (i_cache)
-		cp15_control |= 0x1000U;
-
-	retval = armv7a->armv4_5_common.mcr(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			cp15_control);
-	return retval;
-}
-
-
-static int cortex_a9_mmu(struct target *target, int *enabled)
-{
-	if (target->state != TARGET_HALTED) {
-		LOG_ERROR("%s: target not halted", __func__);
-		return ERROR_TARGET_INVALID;
-	}
-
-	*enabled = target_to_cortex_a9(target)->armv7a_common.armv4_5_mmu.mmu_enabled;
-	return ERROR_OK;
-}
-
-static int cortex_a9_virt2phys(struct target *target,
-		uint32_t virt, uint32_t *phys)
-{
-	uint32_t cb;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	// struct armv7a_common *armv7a = &cortex_a9->armv7a_common;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-    /* We assume that virtual address is separated
-       between user and kernel in Linux style:
-       0x00000000-0xbfffffff - User space
-       0xc0000000-0xffffffff - Kernel space */
-    if( virt < 0xc0000000 ) /* Linux user space */
-        cortex_a9->current_address_mode = ARM_MODE_USR;
-    else /* Linux kernel */
-        cortex_a9->current_address_mode = ARM_MODE_SVC;
-	uint32_t ret;
-	int retval = armv4_5_mmu_translate_va(target,
-			&armv7a->armv4_5_mmu, virt, &cb, &ret);
-	if (retval != ERROR_OK)
-		return retval;
-    /* Reset the flag. We don't want someone else to use it by error */
-    cortex_a9->current_address_mode = ARM_MODE_ANY;
-
-	*phys = ret;
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(cortex_a9_handle_cache_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	return armv4_5_handle_cache_info_command(CMD_CTX,
-			&armv7a->armv4_5_mmu.armv4_5_cache);
-}
-
-
-COMMAND_HANDLER(cortex_a9_handle_dbginit_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	if (!target_was_examined(target))
-	{
-		LOG_ERROR("target not examined yet");
-		return ERROR_FAIL;
-	}
-
-	return cortex_a9_init_debug_access(target);
-}
-
-static const struct command_registration cortex_a9_exec_command_handlers[] = {
-	{
-		.name = "cache_info",
-		.handler = cortex_a9_handle_cache_info_command,
-		.mode = COMMAND_EXEC,
-		.help = "display information about target caches",
-	},
-	{
-		.name = "dbginit",
-		.handler = cortex_a9_handle_dbginit_command,
-		.mode = COMMAND_EXEC,
-		.help = "Initialize core debug",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-static const struct command_registration cortex_a9_command_handlers[] = {
-	{
-		.chain = arm_command_handlers,
-	},
-	{
-		.chain = armv7a_command_handlers,
-	},
-	{
-		.name = "cortex_a9",
-		.mode = COMMAND_ANY,
-		.help = "Cortex-A9 command group",
-		.chain = cortex_a9_exec_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-struct target_type cortexa9_target = {
-	.name = "cortex_a9",
-
-	.poll = cortex_a9_poll,
-	.arch_state = armv7a_arch_state,
-
-	.target_request_data = NULL,
-
-	.halt = cortex_a9_halt,
-	.resume = cortex_a9_resume,
-	.step = cortex_a9_step,
-
-	.assert_reset = cortex_a9_assert_reset,
-	.deassert_reset = cortex_a9_deassert_reset,
-	.soft_reset_halt = NULL,
-
-	/* REVISIT allow exporting VFP3 registers ... */
-	.get_gdb_reg_list = arm_get_gdb_reg_list,
-
-	.read_memory = cortex_a9_read_memory,
-	.write_memory = cortex_a9_write_memory,
-	.bulk_write_memory = cortex_a9_bulk_write_memory,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
-	.add_breakpoint = cortex_a9_add_breakpoint,
-	.remove_breakpoint = cortex_a9_remove_breakpoint,
-	.add_watchpoint = NULL,
-	.remove_watchpoint = NULL,
-
-	.commands = cortex_a9_command_handlers,
-	.target_create = cortex_a9_target_create,
-	.init_target = cortex_a9_init_target,
-	.examine = cortex_a9_examine,
-
-	.read_phys_memory = cortex_a9_read_phys_memory,
-	.write_phys_memory = cortex_a9_write_phys_memory,
-	.mmu = cortex_a9_mmu,
-	.virt2phys = cortex_a9_virt2phys,
-};
diff --git a/src/target/cortex_a9.h b/src/target/cortex_a9.h
deleted file mode 100644
index 82f04f8..0000000
--- a/src/target/cortex_a9.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   Dominic.Rath at gmx.de                                                   *
- *                                                                         *
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   lundin at mlu.mine.nu                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Dirk Behme                                      *
- *   dirk.behme at gmail.com - copy from cortex_m3                            *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef CORTEX_A9_H
-#define CORTEX_A9_H
-
-#include "armv7a.h"
-
-#define CORTEX_A9_COMMON_MAGIC 0x411fc082
-
-#define CPUDBG_CPUID	0xD00
-#define CPUDBG_CTYPR	0xD04
-#define CPUDBG_TTYPR	0xD0C
-#define CPUDBG_LOCKACCESS 0xFB0
-#define CPUDBG_LOCKSTATUS 0xFB4
-
-#define BRP_NORMAL 0
-#define BRP_CONTEXT 1
-
-#define CORTEX_A9_PADDRDBG_CPU_SHIFT 13
-
-struct cortex_a9_brp
-{
-	int used;
-	int type;
-	uint32_t value;
-	uint32_t control;
-	uint8_t BRPn;
-};
-
-struct cortex_a9_common
-{
-	int common_magic;
-	struct arm_jtag jtag_info;
-
-	/* Context information */
-	uint32_t cpudbg_dscr;
-
-	/* Saved cp15 registers */
-	uint32_t cp15_control_reg;
-
-	/* Breakpoint register pairs */
-	int brp_num_context;
-	int brp_num;
-	int brp_num_available;
-	struct cortex_a9_brp *brp_list;
-
-	/* Use cortex_a9_read_regs_through_mem for fast register reads */
-	int fast_reg_read;
-
-	/* Flag that helps to resolve what ttb to use: user or kernel */
-	int current_address_mode;
-
-	struct armv7a_common armv7a_common;
-};
-
-static inline struct cortex_a9_common *
-target_to_cortex_a9(struct target *target)
-{
-	return container_of(target->arch_info, struct cortex_a9_common,
-			armv7a_common.armv4_5_common);
-}
-
-#endif /* CORTEX_A9_H */
diff --git a/src/target/target.c b/src/target/target.c
index 13d358d..00d4309 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -70,7 +70,6 @@ extern struct target_type dragonite_target;
 extern struct target_type xscale_target;
 extern struct target_type cortexm3_target;
 extern struct target_type cortexa8_target;
-extern struct target_type cortexa9_target;
 extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
@@ -93,7 +92,6 @@ static struct target_type *target_types[] =
 	&xscale_target,
 	&cortexm3_target,
 	&cortexa8_target,
-	&cortexa9_target,
 	&arm11_target,
 	&mips_m4k_target,
 	&avr_target,

commit 6c5e1781a102424353bf237386e7443b2ce3e4d3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 21 14:13:09 2011 +0100

    omap4430: cortex a9 and a8 are now merged again
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
index 5bdb9d6..13ed80c 100644
--- a/tcl/target/omap4430.cfg
+++ b/tcl/target/omap4430.cfg
@@ -82,7 +82,7 @@ jtag configure $_CHIPNAME.jrc -event post-reset "runtest 200"
 # second core.
 #
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_a9 -chain-position $_CHIPNAME.dap -coreid 0
+target create $_TARGETNAME cortex_a8 -chain-position $_CHIPNAME.dap -coreid 0
 
 # SRAM: 56KiB at 0x4030.0000
 $_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x1000

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am  |    4 +-
 src/target/arm_adi_v5.c |    1 +
 src/target/cortex_a8.c  |  400 ++++++---
 src/target/cortex_a8.h  |    3 +-
 src/target/cortex_a9.c  | 2303 -----------------------------------------------
 src/target/cortex_a9.h  |   89 --
 src/target/target.c     |    2 -
 tcl/target/omap4430.cfg |    2 +-
 8 files changed, 291 insertions(+), 2513 deletions(-)
 delete mode 100644 src/target/cortex_a9.c
 delete mode 100644 src/target/cortex_a9.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 23 13:00:15 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 23 Mar 2011 12:00:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-807-gdec80e1
Message-ID: <mailman.34.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  dec80e1cffa162ba0e1cd8e6ee66c7784fe79b87 (commit)
      from  a843789ede3b01dfaf199e1fcfbfd09ac681cf8f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dec80e1cffa162ba0e1cd8e6ee66c7784fe79b87
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 22 11:29:10 2011 +0100

    cortex_a: rename cortex_a8.c/h to cortex_a.c/h
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 537c8c3..5907e83 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -73,7 +73,7 @@ ARMV7_SRC = \
 	armv7m.c \
 	cortex_m3.c \
 	armv7a.c \
-	cortex_a8.c
+	cortex_a.c
 
 ARM_DEBUG_SRC = \
 	arm_dpm.c \
@@ -135,7 +135,7 @@ noinst_HEADERS = \
 	dsp563xx_once.h \
 	breakpoints.h \
 	cortex_m3.h \
-	cortex_a8.h \
+	cortex_a.h \
 	embeddedice.h \
 	etb.h \
 	etm.h \
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a.c
similarity index 99%
rename from src/target/cortex_a8.c
rename to src/target/cortex_a.c
index 88b3db4..82f719a 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a.c
@@ -38,7 +38,7 @@
 #endif
 
 #include "breakpoints.h"
-#include "cortex_a8.h"
+#include "cortex_a.h"
 #include "register.h"
 #include "target_request.h"
 #include "target_type.h"
diff --git a/src/target/cortex_a8.h b/src/target/cortex_a.h
similarity index 100%
rename from src/target/cortex_a8.h
rename to src/target/cortex_a.h

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am                 |    4 ++--
 src/target/{cortex_a8.c => cortex_a.c} |    2 +-
 src/target/{cortex_a8.h => cortex_a.h} |    0
 3 files changed, 3 insertions(+), 3 deletions(-)
 rename src/target/{cortex_a8.c => cortex_a.c} (99%)
 rename src/target/{cortex_a8.h => cortex_a.h} (100%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Mar 27 23:54:25 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 27 Mar 2011 21:54:25 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-808-g68bd107
Message-ID: <mailman.35.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  68bd107c6db941ec7b22f3e491e314041a95224b (commit)
      from  dec80e1cffa162ba0e1cd8e6ee66c7784fe79b87 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 68bd107c6db941ec7b22f3e491e314041a95224b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Mar 27 23:50:53 2011 +0200

    command: fix leak when executing commands
    
    found via valgrind, not observed/reported.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.c b/src/helper/command.c
index 85d9463..b00a231 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -723,6 +723,7 @@ int command_run_linef(struct command_context *context, const char *format, ...)
 	if (string != NULL)
 	{
 		retval = command_run_line(context, string);
+		free(string);
 	}
 	va_end(ap);
 	return retval;

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 29 12:51:53 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 29 Mar 2011 10:51:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-809-gbe14e8c
Message-ID: <mailman.36.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  be14e8cbb0883a1fbb2a77ce74b7080a5ad323a3 (commit)
      from  68bd107c6db941ec7b22f3e491e314041a95224b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit be14e8cbb0883a1fbb2a77ce74b7080a5ad323a3
Author: Andrew Lyon <andrew.lyon at gmail.com>
Date:   Mon Mar 28 11:28:13 2011 +0100

    bugfix for step <address> mips_m4k
    
    The patch below fixes step <address> on mips_m4k.
    
    Spencer Oliver <spen at spen-soft.co.uk>:
    
    The current code is used on all other arch's - is
    there a underlying issue with those aswell ?

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 8afee9c..3a79273 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -421,7 +421,11 @@ static int mips_m4k_step(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current)
+	{
 		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
+		mips32->core_cache->reg_list[MIPS32_PC].dirty = 1;
+		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
+	}
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints) {

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips_m4k.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 30 08:05:09 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 30 Mar 2011 06:05:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-811-g56f7055
Message-ID: <mailman.37.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  56f705525cd64b78d34edc3012790ecf01025073 (commit)
       via  54ec0c4a8a215cfc636d93ff8f99fe5d003d6f66 (commit)
      from  be14e8cbb0883a1fbb2a77ce74b7080a5ad323a3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 56f705525cd64b78d34edc3012790ecf01025073
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Tue Mar 29 16:19:47 2011 -0300

    Clarify LPC32XX address cycles message
    
    Hi,
    
    This is a more descriptive message about LPC32XX error, when the nand
    chip needs 5 address cycles.
    
    Thanks.

diff --git a/src/flash/nand/lpc32xx.c b/src/flash/nand/lpc32xx.c
index 5cde90c..963dd13 100644
--- a/src/flash/nand/lpc32xx.c
+++ b/src/flash/nand/lpc32xx.c
@@ -215,7 +215,7 @@ static int lpc32xx_init(struct nand_device *nand)
 	nand->bus_width = bus_width;
 
 	if ((address_cycles != 3) && (address_cycles != 4)) {
-		LOG_ERROR("LPC32xx driver doesn't support %i", address_cycles);
+		LOG_ERROR("LPC32xx driver doesn't support %i address cycles", address_cycles);
 		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 	}
 

commit 54ec0c4a8a215cfc636d93ff8f99fe5d003d6f66
Author: Alexandre Pereira da Silva <aletes.xgr at gmail.com>
Date:   Tue Mar 29 16:17:11 2011 -0300

    Add Micron 2GiB nand
    
    Hi,
    
    This will add support for a new nand chip device.
    
    Thanks.

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 88a16cc..7c20ca5 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -125,6 +125,8 @@ static struct nand_info nand_flash_ids[] =
 	{"NAND 2GiB 1.8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
 	{"NAND 2GiB 3.3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
 
+	{"NAND 2GiB 3.3V 8-bit",	0x48, 0, 2048, 0, LP_OPTIONS},
+
 	{NULL, 0, 0, 0, 0, 0 }
 };
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/core.c    |    2 ++
 src/flash/nand/lpc32xx.c |    2 +-
 2 files changed, 3 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 30 15:58:41 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 30 Mar 2011 13:58:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-812-g3e83991
Message-ID: <mailman.38.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3e839915609f207439fd7dfe32d95acb025770ab (commit)
      from  56f705525cd64b78d34edc3012790ecf01025073 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3e839915609f207439fd7dfe32d95acb025770ab
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Mar 30 13:08:39 2011 +0200

    docs: add HACKING file to help users get started with patches
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/HACKING b/HACKING
new file mode 100644
index 0000000..5718798
--- /dev/null
+++ b/HACKING
@@ -0,0 +1,49 @@
+Submitting patches to the OpenOCD mailing list:
+
+By the time you have read this, one supposes that 
+you have figured out how to clone the OpenOCD git
+repository.
+
+Below is a basic workflow and specific instructions 
+to get you going with git and patches.
+
+0. Clone the git repository, rather than just
+download the source. 
+
+git clone git://openocd.git.sourceforge.net/gitroot/openocd/openocd
+
+or if you have problems with the "git:" protocol, use
+the slower http protocol:
+
+git clone http://repo.or.cz/r/openocd.git
+
+1. Set up git with your name and email:
+
+git config --global user.name "John Smith"
+git config --global user.email "john at smith.org"
+
+2. Work on your patches. Split the work into 
+multiple small patches that can be reviewed and
+applied seperately and safely to the OpenOCD
+repository.
+
+while(!done) {
+  work - edit files using your favorite editor.
+  run "git commit -a" to commit all changes. 
+}
+
+TIP! use "git add ." before commit to add new files.
+
+3. Next you need to make sure that your patches
+are on top of the latest stuff on the server and
+that there are no conflicts.
+
+git pull --rebase
+
+4. Generate the patch files. This will generate
+patches for all commits that are on top of
+the latest stuff on the server:
+
+git format-patch origin/master
+
+5. Email the patches to openocd-development at lists.berlios.de  

-----------------------------------------------------------------------

Summary of changes:
 HACKING |   49 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 49 insertions(+), 0 deletions(-)
 create mode 100644 HACKING


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 30 16:01:40 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 30 Mar 2011 14:01:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-813-gac6f8f9
Message-ID: <mailman.39.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ac6f8f9616aada403c52254738096ec43888ca42 (commit)
      from  3e839915609f207439fd7dfe32d95acb025770ab (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ac6f8f9616aada403c52254738096ec43888ca42
Author: Olivier Schonken <olivier.schonken at gmail.com>
Date:   Mon Mar 28 19:31:17 2011 +0200

    at91sam3: Modified cidr comparisson to ignore version bits
    
    production processor versions increment, thus the version
    bits should be ignored for future proofing. e.g.
    Engineering sample version == 0x00, production version 0x01

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 0b71e81..40ff3aa 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -1999,7 +1999,8 @@ sam3_GetDetails(struct sam3_bank_private *pPrivate)
 	LOG_DEBUG("Begin");
 	pDetails = all_sam3_details;
 	while (pDetails->name) {
-		if (pDetails->chipid_cidr == pPrivate->pChip->cfg.CHIPID_CIDR) {
+		// Compare cidr without version bits
+		if (pDetails->chipid_cidr == (pPrivate->pChip->cfg.CHIPID_CIDR & 0xFFFFFFE0)) {
 			break;
 		} else {
 			pDetails++;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/at91sam3.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 31 09:32:36 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 31 Mar 2011 07:32:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-815-g8d338f3
Message-ID: <mailman.40.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8d338f3296d87f3b0aa40b6f60a0ca393e435b36 (commit)
       via  b75bdb7b0428add602c2e4beb7e059da5d4a6c95 (commit)
      from  ac6f8f9616aada403c52254738096ec43888ca42 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8d338f3296d87f3b0aa40b6f60a0ca393e435b36
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Mar 30 13:34:50 2011 +0200

    cortex-a: use -dbgbase option
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 82f719a..5ff6bac 100644
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -1861,7 +1861,7 @@ static int cortex_a8_examine_first(struct target *target)
 	int i;
 	int retval = ERROR_OK;
 	uint32_t didr, ctypr, ttypr, cpuid;
-	uint32_t dbgbase, apid;
+	uint32_t dbgbase;
 
 	/* We do one extra read to ensure DAP is configured,
 	 * we call ahbap_debugport_init(swjdp) instead
@@ -1870,10 +1870,17 @@ static int cortex_a8_examine_first(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	/* Get ROM Table base */
-	retval = dap_get_debugbase(swjdp, 1, &dbgbase, &apid);
-	if (retval != ERROR_OK)
-		return retval;
+	if (!target->dbgbase_set)
+	{
+		/* Get ROM Table base */
+		uint32_t apid;
+		retval = dap_get_debugbase(swjdp, 1, &dbgbase, &apid);
+		if (retval != ERROR_OK)
+			return retval;
+	} else
+	{
+		dbgbase = target->dbgbase;
+	}
 
 	/* Lookup 0x15 -- Processor DAP */
 	retval = dap_lookup_cs_component(swjdp, 1, dbgbase, 0x15,

commit b75bdb7b0428add602c2e4beb7e059da5d4a6c95
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Mar 30 13:32:47 2011 +0200

    target: add -dbgbase option to target configuration
    
    Really a Cortex-A specific option, but there is no
    system in place to support target specific options
    currently and there has been no need for such a system
    until now.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 00d4309..df38c83 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3703,6 +3703,7 @@ enum target_cfg_param {
 	TCFG_VARIANT,
 	TCFG_COREID,
 	TCFG_CHAIN_POSITION,
+	TCFG_DBGBASE,
 };
 
 static Jim_Nvp nvp_config_opts[] = {
@@ -3716,6 +3717,7 @@ static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-variant",          .value = TCFG_VARIANT },
 	{ .name = "-coreid",           .value = TCFG_COREID },
 	{ .name = "-chain-position",   .value = TCFG_CHAIN_POSITION },
+	{ .name = "-dbgbase",          .value = TCFG_DBGBASE },
 	{ .name = NULL, .value = -1 }
 };
 
@@ -4006,6 +4008,22 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 			Jim_SetResultString(goi->interp, target->tap->dotted_name, -1);
 			/* loop for more e*/
 			break;
+		case TCFG_DBGBASE:
+			if (goi->isconfigure) {
+				e = Jim_GetOpt_Wide(goi, &w);
+				if (e != JIM_OK) {
+					return e;
+				}
+				target->dbgbase = (uint32_t)w;
+				target->dbgbase_set = true;
+			} else {
+				if (goi->argc != 0) {
+					goto no_params;
+				}
+			}
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->dbgbase));
+			/* loop for more */
+			break;
 		}
 	} /* while (goi->argc) */
 
diff --git a/src/target/target.h b/src/target/target.h
index d6e7431..32fa87a 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -155,6 +155,11 @@ struct target
 										 * lots of halted/resumed info when stepping in debugger. */
 	bool halt_issued;					/* did we transition to halted state? */
 	long long halt_issued_time;			/* Note time when halt was issued */
+
+	bool dbgbase_set;					/* By default the debug base is not set */
+	uint32_t dbgbase;					/* Really a Cortex-A specific option, but there is no
+	 	 	 	 	 	 	 	 	 	   system in place to support target specific options
+	 	 	 	 	 	 	 	 	 	   currently. */
 };
 
 /** Returns the instance-specific name of the specified target. */

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a.c |   17 ++++++++++++-----
 src/target/target.c   |   18 ++++++++++++++++++
 src/target/target.h   |    5 +++++
 3 files changed, 35 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 31 18:49:38 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 31 Mar 2011 16:49:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-816-gf169f86
Message-ID: <mailman.41.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f169f86bd10c4dfdab6088e233647bb6d42b5c26 (commit)
      from  8d338f3296d87f3b0aa40b6f60a0ca393e435b36 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f169f86bd10c4dfdab6088e233647bb6d42b5c26
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 18:46:14 2011 +0200

    xscale: fix gaffe in phys write
    
    it would *read* instead of *write* to memory
    when the MMU was disabled.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index 9511be0..d1e33b7 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2022,7 +2022,7 @@ static int xscale_write_phys_memory(struct target *target, uint32_t address,
 
 	/* with MMU inactive, there are only physical addresses */
 	if (!xscale->armv4_5_mmu.mmu_enabled)
-		return xscale_read_memory(target, address, size, count, buffer);
+		return xscale_write_memory(target, address, size, count, buffer);
 
 	/** \todo: provide a non-stub implementation of this routine. */
 	LOG_ERROR("%s: %s is not implemented.  Disable MMU?",

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 31 23:12:44 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 31 Mar 2011 21:12:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-817-ge1f5055
Message-ID: <mailman.42.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e1f5055bb089d1f854777da1d200e7551cdd3a4f (commit)
      from  f169f86bd10c4dfdab6088e233647bb6d42b5c26 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e1f5055bb089d1f854777da1d200e7551cdd3a4f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 23:07:55 2011 +0200

    mips: fix error handling for jtag_execute_queue()
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 9a9b427..0ee5715 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -176,9 +176,7 @@ static int mips32_pracc_exec_read(struct mips32_pracc_context *ctx, uint32_t add
 	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
 
 	jtag_add_clocks(5);
-	jtag_execute_queue();
-
-	return ERROR_OK;
+	return jtag_execute_queue();
 }
 
 static int mips32_pracc_exec_write(struct mips32_pracc_context *ctx, uint32_t address)
@@ -196,7 +194,7 @@ static int mips32_pracc_exec_write(struct mips32_pracc_context *ctx, uint32_t ad
 	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
 
 	jtag_add_clocks(5);
-	jtag_execute_queue();
+	return jtag_execute_queue();
 
 	if ((address >= MIPS32_PRACC_PARAM_IN)
 		&& (address <= MIPS32_PRACC_PARAM_IN + ctx->num_iparam * 4))
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index e381063..6ce702f 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -64,11 +64,12 @@ int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 
 	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
 
-	if (jtag_execute_queue() != ERROR_OK)
+	int retval;
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		LOG_ERROR("register read failed");
+		return retval;
 	}
-
 	return ERROR_OK;
 }
 
@@ -84,11 +85,12 @@ static int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impco
 
 	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
 
-	if (jtag_execute_queue() != ERROR_OK)
+	int retval;
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		LOG_ERROR("register read failed");
+		return retval;
 	}
-
 	return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32_pracc.c |    6 ++----
 src/target/mips_ejtag.c   |   10 ++++++----
 2 files changed, 8 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 31 23:51:32 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 31 Mar 2011 21:51:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-820-g0c1ebf2
Message-ID: <mailman.43.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0c1ebf2673ef02c5fef7677cbf09d4ad4fa3c533 (commit)
       via  83ab5ad2408c7d67ea490986f887c432f229e0ef (commit)
       via  667c65552e56aeb4d08aa1ec8b1fb9fc29117201 (commit)
      from  e1f5055bb089d1f854777da1d200e7551cdd3a4f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0c1ebf2673ef02c5fef7677cbf09d4ad4fa3c533
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 23:46:32 2011 +0200

    mips: mips32_pracc_exec error propagation fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 0ee5715..54274ab 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -446,7 +446,7 @@ static int mips32_pracc_read_mem16(struct mips_ejtag *ejtag_info, uint32_t addr,
 	uint32_t *param_out = malloc(count * sizeof(uint32_t));
 	int i;
 
-//	int retval;
+	int retval = ERROR_OK;
 	int blocksize;
 	int bytesread;
 	uint32_t param_in[2];
@@ -462,7 +462,7 @@ static int mips32_pracc_read_mem16(struct mips_ejtag *ejtag_info, uint32_t addr,
 		param_in[0] = addr;
 		param_in[1] = blocksize;
 
-		mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+		retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 			ARRAY_SIZE(param_in), param_in, count, param_out, 1);
 
 //		count -= blocksize;
@@ -477,7 +477,7 @@ static int mips32_pracc_read_mem16(struct mips_ejtag *ejtag_info, uint32_t addr,
 
 	free(param_out);
 
-	return ERROR_OK;
+	return retval;
 }
 
 static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr, int count, uint8_t *buf)
@@ -523,7 +523,7 @@ static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 	uint32_t *param_out = malloc(count * sizeof(uint32_t));
 	int i;
 
-//	int retval;
+	int retval = ERROR_OK;
 	int blocksize;
 	int bytesread;
 	uint32_t param_in[2];
@@ -539,7 +539,7 @@ static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 		param_in[0] = addr;
 		param_in[1] = blocksize;
 
-		mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+		retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 			ARRAY_SIZE(param_in), param_in, count, param_out, 1);
 
 //		count -= blocksize;
@@ -554,7 +554,7 @@ static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 
 	free(param_out);
 
-	return ERROR_OK;
+	return retval;
 }
 
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, void *buf)
@@ -616,12 +616,13 @@ static int mips32_pracc_write_mem32(struct mips_ejtag *ejtag_info, uint32_t addr
 
 	memcpy(&param_in[2], buf, count * sizeof(uint32_t));
 
-	mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	int retval;
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 		count + 2, param_in, 0, NULL, 1);
 
 	free(param_in);
 
-	return ERROR_OK;
+	return retval;
 }
 
 static int mips32_pracc_write_u32(struct mips_ejtag *ejtag_info, uint32_t addr, uint32_t *buf)
@@ -650,10 +651,8 @@ static int mips32_pracc_write_u32(struct mips_ejtag *ejtag_info, uint32_t addr,
 	param_in[0] = addr;
 	param_in[1] = *buf;
 
-	mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	return mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 		ARRAY_SIZE(param_in), param_in, 0, NULL, 1);
-
-	return ERROR_OK;
 }
 
 static int mips32_pracc_write_mem16(struct mips_ejtag *ejtag_info, uint32_t addr, int count, uint16_t *buf)
@@ -706,12 +705,13 @@ static int mips32_pracc_write_mem16(struct mips_ejtag *ejtag_info, uint32_t addr
 		param_in[i + 2] = buf[i];
 	}
 
-	mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	int retval;
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 		count + 2, param_in, 0, NULL, 1);
 
 	free(param_in);
 
-	return ERROR_OK;
+	return retval;
 }
 
 static int mips32_pracc_write_mem8(struct mips_ejtag *ejtag_info, uint32_t addr, int count, uint8_t *buf)
@@ -765,7 +765,7 @@ static int mips32_pracc_write_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 		param_in[i + 2] = buf[i];
 	}
 
-	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 		count + 2, param_in, 0, NULL, 1);
 
 	free(param_in);
@@ -837,7 +837,7 @@ int mips32_pracc_write_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 
 	int retval;
 
-	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 			MIPS32NUMCOREREGS, regs, 0, NULL, 1);
 
 	return retval;
@@ -912,7 +912,7 @@ int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
 
 	int retval;
 
-	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 		0, NULL, MIPS32NUMCOREREGS, regs, 1);
 
 	return retval;
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index f9eaef1..9df8a02 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -162,10 +162,8 @@ static int mips_ejtag_step_enable(struct mips_ejtag *ejtag_info)
 			MIPS32_MFC0(1,31,0),			/* move COP0 DeSave to $1 */
 	};
 
-	mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
-		0, NULL, 0, NULL, 1);
-
-	return ERROR_OK;
+	return mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
+			0, NULL, 0, NULL, 1);
 }
 
 static int mips_ejtag_step_disable(struct mips_ejtag *ejtag_info)
@@ -187,10 +185,8 @@ static int mips_ejtag_step_disable(struct mips_ejtag *ejtag_info)
 			MIPS32_MFC0(15,31,0),							/* move COP0 DeSave to $15 */
 	};
 
-	mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	return mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 		0, NULL, 0, NULL, 1);
-
-	return ERROR_OK;
 }
 
 int mips_ejtag_config_step(struct mips_ejtag *ejtag_info, int enable_step)
@@ -228,9 +224,7 @@ int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info)
 	inst = MIPS32_DRET;
 
 	/* execute our dret instruction */
-	mips32_pracc_exec(ejtag_info, 1, &inst, 0, NULL, 0, NULL, 0);
-
-	return ERROR_OK;
+	return mips32_pracc_exec(ejtag_info, 1, &inst, 0, NULL, 0, NULL, 0);
 }
 
 int mips_ejtag_read_debug(struct mips_ejtag *ejtag_info, uint32_t* debug_reg)
@@ -252,10 +246,8 @@ int mips_ejtag_read_debug(struct mips_ejtag *ejtag_info, uint32_t* debug_reg)
 			MIPS32_MFC0(15,31,0),							/* move COP0 DeSave to $15 */
 	};
 
-	mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, \
+	return mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code,
 		0, NULL, 1, debug_reg, 1);
-
-	return ERROR_OK;
 }
 
 int mips_ejtag_init(struct mips_ejtag *ejtag_info)

commit 83ab5ad2408c7d67ea490986f887c432f229e0ef
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 23:39:10 2011 +0200

    mips: mips_ejtag_get_impcode error propagation added
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 8e1404f..f9eaef1 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -261,8 +261,11 @@ int mips_ejtag_read_debug(struct mips_ejtag *ejtag_info, uint32_t* debug_reg)
 int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 {
 	uint32_t ejtag_version;
+	int retval;
 
-	mips_ejtag_get_impcode(ejtag_info, &ejtag_info->impcode);
+	retval = mips_ejtag_get_impcode(ejtag_info, &ejtag_info->impcode);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG("impcode: 0x%8.8" PRIx32 "", ejtag_info->impcode);
 
 	/* get ejtag version */
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 3a79273..0508c35 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -940,7 +940,9 @@ static int mips_m4k_examine(struct target *target)
 
 	if (!target_was_examined(target))
 	{
-		mips_ejtag_get_idcode(ejtag_info, &idcode);
+		retval = mips_ejtag_get_idcode(ejtag_info, &idcode);
+		if (retval != ERROR_OK)
+			return retval;
 		ejtag_info->idcode = idcode;
 
 		if (((idcode >> 1) & 0x7FF) == 0x29)

commit 667c65552e56aeb4d08aa1ec8b1fb9fc29117201
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 31 23:31:37 2011 +0200

    mips: fix mips_ejtag_set_instr error handling
    
    this fn does not fail, it queues data.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 6ce702f..8e1404f 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -28,13 +28,12 @@
 #include "mips32.h"
 #include "mips_ejtag.h"
 
-int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
+void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
 {
 	struct jtag_tap *tap;
 
 	tap = ejtag_info->tap;
-	if (tap == NULL)
-		return ERROR_FAIL;
+	assert(tap != NULL);
 
 	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != (uint32_t)new_instr)
 	{
@@ -48,8 +47,6 @@ int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
 
 		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 	}
-
-	return ERROR_OK;
 }
 
 int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
@@ -98,9 +95,8 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 {
 	struct jtag_tap *tap;
 	tap  = ejtag_info->tap;
+	assert(tap != NULL);
 
-	if (tap == NULL)
-		return ERROR_FAIL;
 	struct scan_field field;
 	uint8_t t[4], r[4];
 	int retval;
@@ -129,9 +125,8 @@ int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 {
 	struct jtag_tap *tap;
 	tap  = ejtag_info->tap;
+	assert(tap != NULL);
 
-	if (tap == NULL)
-		return ERROR_FAIL;
 	struct scan_field field;
 	uint8_t t[4] = {0, 0, 0, 0}, r[4];
 	int retval;
@@ -219,7 +214,10 @@ int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info)
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	LOG_DEBUG("ejtag_ctrl: 0x%8.8" PRIx32 "", ejtag_ctrl);
 	if ((ejtag_ctrl & EJTAG_CTRL_BRKST) == 0)
-		LOG_DEBUG("Failed to enter Debug Mode!");
+	{
+		LOG_ERROR("Failed to enter Debug Mode!");
+		return ERROR_FAIL;
+	}
 
 	return ERROR_OK;
 }
@@ -311,9 +309,7 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_
 {
 	struct jtag_tap *tap;
 	tap = ejtag_info->tap;
-
-	if (tap == NULL)
-		return ERROR_FAIL;
+	assert(tap != NULL);
 
 	struct scan_field fields[2];
 	uint8_t spracc = 0;
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 0db0504..63b6093 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -131,7 +131,7 @@ struct mips_ejtag
 	int fast_access_save;
 };
 
-int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info,
+void mips_ejtag_set_instr(struct mips_ejtag *ejtag_info,
 		int new_instr);
 int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info);

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32_pracc.c |   32 ++++++++++++++++----------------
 src/target/mips_ejtag.c   |   45 ++++++++++++++++++---------------------------
 src/target/mips_ejtag.h   |    2 +-
 src/target/mips_m4k.c     |    4 +++-
 4 files changed, 38 insertions(+), 45 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


