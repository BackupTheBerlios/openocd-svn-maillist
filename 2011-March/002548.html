<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-806-ga843789
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-March/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-806-ga843789&In-Reply-To=%3Cmailman.33.1331736153.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002547.html">
   <LINK REL="Next"  HREF="002549.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-806-ga843789</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-806-ga843789&In-Reply-To=%3Cmailman.33.1331736153.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-806-ga843789">gowinex at users.sourceforge.net
       </A><BR>
    <I>Tue Mar 22 09:23:16 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002547.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-803-gec2b8d7
</A></li>
        <LI>Next message: <A HREF="002549.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-807-gdec80e1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2548">[ date ]</a>
              <a href="thread.html#2548">[ thread ]</a>
              <a href="subject.html#2548">[ subject ]</a>
              <a href="author.html#2548">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  a843789ede3b01dfaf199e1fcfbfd09ac681cf8f (commit)
       via  fc574c64bb259814ccbf51d74057873bd5649ea3 (commit)
       via  6c5e1781a102424353bf237386e7443b2ce3e4d3 (commit)
      from  ec2b8d71ac1fb2e8d6c8057a5e1d0a27bd7bd110 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a843789ede3b01dfaf199e1fcfbfd09ac681cf8f
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Tue Mar 22 09:21:16 2011 +0100

    omap4430: tried to add in workaround for broken dbgbase query
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 480472f..53cf615 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1091,6 +1091,7 @@ struct broken_cpu {
 	char		*model;
 } broken_cpus[] = {
 	{ 0x80000000, 0x04770002, 0x1ba00477, 0x60000000, &quot;imx51&quot; },
+	{ 0x80040000, 0x04770002, 0x3b95c02f, 0x80000000, &quot;omap4430&quot; },
 };
 
 int dap_get_debugbase(struct adiv5_dap *dap, int ap,

commit fc574c64bb259814ccbf51d74057873bd5649ea3
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Mar 21 14:10:57 2011 +0100

    cortex a9: merge cortex a9 and a8 code
    
    better to keep this in a single file.
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index b6e8d4b..537c8c3 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -73,8 +73,7 @@ ARMV7_SRC = \
 	armv7m.c \
 	cortex_m3.c \
 	armv7a.c \
-	cortex_a8.c \
-	cortex_a9.c
+	cortex_a8.c
 
 ARM_DEBUG_SRC = \
 	arm_dpm.c \
@@ -137,7 +136,6 @@ noinst_HEADERS = \
 	breakpoints.h \
 	cortex_m3.h \
 	cortex_a8.h \
-	cortex_a9.h \
 	embeddedice.h \
 	etb.h \
 	etm.h \
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 7815522..88b3db4 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -30,6 +30,7 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  *                                                                         *
  *   Cortex-A8(tm) TRM, ARM DDI 0344H                                      *
+ *   Cortex-A9(tm) TRM, ARM DDI 0407F                                      *
  *                                                                         *
  ***************************************************************************/
 #ifdef HAVE_CONFIG_H
@@ -692,7 +693,7 @@ static int cortex_a8_poll(struct target *target)
 	}
 	cortex_a8-&gt;cpudbg_dscr = dscr;
 
-	if ((dscr &amp; 0x3) == 0x3)
+	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
 	{
 		if (prev_target_state != TARGET_HALTED)
 		{
@@ -722,7 +723,7 @@ static int cortex_a8_poll(struct target *target)
 			}
 		}
 	}
-	else if ((dscr &amp; 0x3) == 0x2)
+	else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
 	{
 		target-&gt;state = TARGET_RUNNING;
 	}
@@ -747,7 +748,7 @@ static int cortex_a8_halt(struct target *target)
 	 * and then wait for the core to be halted.
 	 */
 	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DRCR, 0x1);
+			armv7a-&gt;debug_base + CPUDBG_DRCR, DRCR_HALT);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -870,14 +871,30 @@ static int cortex_a8_resume(struct target *target, int current,
 	}
 
 #endif
-	/* Restart core and wait for it to be started
-	 * NOTE: this clears DSCR_ITR_EN and other bits.
+
+	/*
+	 * Restart core and wait for it to be started.  Clear ITRen and sticky
+	 * exception flags: see ARMv7 ARM, C5.9.
 	 *
 	 * REVISIT: for single stepping, we probably want to
 	 * disable IRQs by default, with optional override...
 	 */
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+			armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((dscr &amp; DSCR_INSTR_COMP) == 0)
+		LOG_ERROR(&quot;DSCR InstrCompl must be set before leaving debug!&quot;);
+
 	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DRCR, 0x2);
+		armv7a-&gt;debug_base + CPUDBG_DSCR, dscr &amp; ~DSCR_ITR_EN);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
+			armv7a-&gt;debug_base + CPUDBG_DRCR, DRCR_RESTART | DRCR_CLEAR_EXCEPTIONS);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1443,32 +1460,101 @@ static int cortex_a8_read_phys_memory(struct target *target,
                 uint32_t address, uint32_t size,
                 uint32_t count, uint8_t *buffer)
 {
-        struct armv7a_common *armv7a = target_to_armv7a(target);
-        struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-        int retval = ERROR_INVALID_ARGUMENTS;
-
-        /* cortex_a8 handles unaligned memory access */
-
-// ???  dap_ap_select(swjdp, swjdp_memoryap);
-        LOG_DEBUG(&quot;Reading memory at real address 0x%x; size %d; count %d&quot;, address, size, count);
-        if (count &amp;&amp; buffer) {
-                switch (size) {
-                case 4:
-                        retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
-								buffer, 4 * count, address);
-                        break;
-                case 2:
-                        retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
-								buffer, 2 * count, address);
-                        break;
-                case 1:
-                        retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
-								 buffer, count, address);
-                        break;
-                }
-        }
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
+	int retval = ERROR_INVALID_ARGUMENTS;
+	uint8_t apsel = swjdp-&gt;apsel;
+
+	LOG_DEBUG(&quot;Reading memory at real address 0x%x; size %d; count %d&quot;, address, size, count);
+
+	if (count &amp;&amp; buffer) {
+
+		if ( apsel == swjdp_memoryap ) {
+
+			/* read memory through AHB-AP */
+
+			switch (size) {
+				case 4:
+					retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
+							buffer, 4 * count, address);
+					break;
+				case 2:
+					retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
+							buffer, 2 * count, address);
+					break;
+				case 1:
+					retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
+							buffer, count, address);
+					break;
+			}
 
-        return retval;
+		} else {
+
+			/* read memory through APB-AP */
+
+			uint32_t saved_r0, saved_r1;
+			int nbytes = count * size;
+			uint32_t data;
+			int enabled = 0;
+
+			if (target-&gt;state != TARGET_HALTED)
+			{
+				LOG_WARNING(&quot;target not halted&quot;);
+				return ERROR_TARGET_NOT_HALTED;
+			}
+
+			retval = cortex_a8_mmu(target, &amp;enabled);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if (enabled)
+			{
+				LOG_WARNING(&quot;Reading physical memory through APB with MMU enabled is not yet implemented&quot;);
+				return ERROR_TARGET_FAILURE;
+			}
+
+			/* save registers r0 and r1, we are going to corrupt them  */
+			retval = cortex_a8_dap_read_coreregister_u32(target, &amp;saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_read_coreregister_u32(target, &amp;saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			while (nbytes &gt; 0) {
+
+				/* execute instruction LDRB r1, [r0], 1 (0xe4d01001) */
+				retval = cortex_a8_exec_opcode(target, ARMV4_5_LDRB_IP(1, 0) , NULL);
+				if (retval != ERROR_OK)
+						return retval;
+
+				retval = cortex_a8_dap_read_coreregister_u32(target, &amp;data, 1);
+				if (retval != ERROR_OK)
+					return retval;
+
+				*buffer++ = data;
+				--nbytes;
+
+			}
+
+			/* restore corrupted registers r0 and r1 */
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+		}
+	}
+
+	return retval;
 }
 
 static int cortex_a8_read_memory(struct target *target, uint32_t address,
@@ -1480,7 +1566,6 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 
 	/* cortex_a8 handles unaligned memory access */
 
-// ???	dap_ap_select(swjdp, swjdp_memoryap);
         LOG_DEBUG(&quot;Reading memory at address 0x%x; size %d; count %d&quot;, address, size, count);
         retval = cortex_a8_mmu(target, &amp;enabled);
         if (retval != ERROR_OK)
@@ -1504,88 +1589,162 @@ static int cortex_a8_write_phys_memory(struct target *target,
                 uint32_t address, uint32_t size,
                 uint32_t count, uint8_t *buffer)
 {
-        struct armv7a_common *armv7a = target_to_armv7a(target);
-        struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-        int retval = ERROR_INVALID_ARGUMENTS;
-
-// ???  dap_ap_select(swjdp, swjdp_memoryap);
-
-        LOG_DEBUG(&quot;Writing memory to real address 0x%x; size %d; count %d&quot;, address, size, count);
-        if (count &amp;&amp; buffer) {
-                switch (size) {
-                case 4:
-                        retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,
-								buffer, 4 * count, address);
-                        break;
-                case 2:
-                        retval = mem_ap_sel_write_buf_u16(swjdp, swjdp_memoryap,
-								buffer, 2 * count, address);
-                        break;
-                case 1:
-                        retval = mem_ap_sel_write_buf_u8(swjdp, swjdp_memoryap,
-								buffer, count, address);
-                        break;
-                }
-        }
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
+	int retval = ERROR_INVALID_ARGUMENTS;
+	uint8_t apsel = swjdp-&gt;apsel;
+
+	LOG_DEBUG(&quot;Writing memory to real address 0x%x; size %d; count %d&quot;, address, size, count);
+
+	if (count &amp;&amp; buffer) {
+
+		if ( apsel == swjdp_memoryap ) {
+
+			/* write memory through AHB-AP */
+
+			switch (size) {
+				case 4:
+					retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,
+							buffer, 4 * count, address);
+					break;
+				case 2:
+					retval = mem_ap_sel_write_buf_u16(swjdp, swjdp_memoryap,
+							buffer, 2 * count, address);
+					break;
+				case 1:
+					retval = mem_ap_sel_write_buf_u8(swjdp, swjdp_memoryap,
+							buffer, count, address);
+					break;
+			}
 
-        /* REVISIT this op is generic ARMv7-A/R stuff */
-        if (retval == ERROR_OK &amp;&amp; target-&gt;state == TARGET_HALTED)
-        {
-                struct arm_dpm *dpm = armv7a-&gt;armv4_5_common.dpm;
-
-                retval = dpm-&gt;prepare(dpm);
-                if (retval != ERROR_OK)
-                        return retval;
-
-                /* The Cache handling will NOT work with MMU active, the
-                 * wrong addresses will be invalidated!
-                 *
-                 * For both ICache and DCache, walk all cache lines in the
-                 * address range. Cortex-A8 has fixed 64 byte line length.
-                 *
-                 * REVISIT per ARMv7, these may trigger watchpoints ...
-                 */
-
-                /* invalidate I-Cache */
-                if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled)
-                {
-                        /* ICIMVAU - Invalidate Cache single entry
-                         * with MVA to PoU
-                         *      MCR p15, 0, r0, c7, c5, 1
-                         */
-                        for (uint32_t cacheline = address;
-                                        cacheline &lt; address + size * count;
-                                        cacheline += 64) {
-                                retval = dpm-&gt;instr_write_data_r0(dpm,
-                                        ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
-                                        cacheline);
-                                if (retval != ERROR_OK)
-                                	return retval;
-                        }
-                }
-
-                /* invalidate D-Cache */
-                if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-                {
-                        /* DCIMVAC - Invalidate data Cache line
-                         * with MVA to PoC
-                         *      MCR p15, 0, r0, c7, c6, 1
-                         */
-                        for (uint32_t cacheline = address;
-                                        cacheline &lt; address + size * count;
-                                        cacheline += 64) {
-                                retval = dpm-&gt;instr_write_data_r0(dpm,
-                                        ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
-                                        cacheline);
-                                if (retval != ERROR_OK)
-                                	return retval;
-                        }
-                }
-
-                /* (void) */ dpm-&gt;finish(dpm);
-        }
+		} else {
 
-        return retval;
+			/* write memory through APB-AP */
+
+			uint32_t saved_r0, saved_r1;
+			int nbytes = count * size;
+			uint32_t data;
+			int enabled = 0;
+
+			if (target-&gt;state != TARGET_HALTED)
+			{
+				LOG_WARNING(&quot;target not halted&quot;);
+				return ERROR_TARGET_NOT_HALTED;
+			}
+
+			retval = cortex_a8_mmu(target, &amp;enabled);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if (enabled)
+			{
+				LOG_WARNING(&quot;Writing physical memory through APB with MMU enabled is not yet implemented&quot;);
+				return ERROR_TARGET_FAILURE;
+			}
+
+			/* save registers r0 and r1, we are going to corrupt them  */
+			retval = cortex_a8_dap_read_coreregister_u32(target, &amp;saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_read_coreregister_u32(target, &amp;saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			while (nbytes &gt; 0) {
+
+				data = *buffer++;
+
+				retval = cortex_a8_dap_write_coreregister_u32(target, data, 1);
+				if (retval != ERROR_OK)
+					return retval;
+
+					/* execute instruction STRB r1, [r0], 1 (0xe4c01001) */
+				retval = cortex_a8_exec_opcode(target, ARMV4_5_STRB_IP(1, 0) , NULL);
+				if (retval != ERROR_OK)
+						return retval;
+
+				--nbytes;
+			}
+
+			/* restore corrupted registers r0 and r1 */
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r0, 0);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = cortex_a8_dap_write_coreregister_u32(target, saved_r1, 1);
+			if (retval != ERROR_OK)
+				return retval;
+
+			/* we can return here without invalidating D/I-cache because */
+			/* access through APB maintains cache coherency              */
+			return retval;
+		}
+	}
+
+
+	/* REVISIT this op is generic ARMv7-A/R stuff */
+	if (retval == ERROR_OK &amp;&amp; target-&gt;state == TARGET_HALTED)
+	{
+		struct arm_dpm *dpm = armv7a-&gt;armv4_5_common.dpm;
+
+		retval = dpm-&gt;prepare(dpm);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* The Cache handling will NOT work with MMU active, the
+		 * wrong addresses will be invalidated!
+		 *
+		 * For both ICache and DCache, walk all cache lines in the
+		 * address range. Cortex-A8 has fixed 64 byte line length.
+		 *
+		 * REVISIT per ARMv7, these may trigger watchpoints ...
+		 */
+
+		/* invalidate I-Cache */
+		if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled)
+		{
+			/* ICIMVAU - Invalidate Cache single entry
+			 * with MVA to PoU
+			 *      MCR p15, 0, r0, c7, c5, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline &lt; address + size * count;
+					cacheline += 64) {
+				retval = dpm-&gt;instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* invalidate D-Cache */
+		if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
+		{
+			/* DCIMVAC - Invalidate data Cache line
+			 * with MVA to PoC
+			 *      MCR p15, 0, r0, c7, c6, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline &lt; address + size * count;
+					cacheline += 64) {
+				retval = dpm-&gt;instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* (void) */ dpm-&gt;finish(dpm);
+	}
+
+	return retval;
 }
 
 static int cortex_a8_write_memory(struct target *target, uint32_t address,
@@ -1595,8 +1754,6 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
         uint32_t virt, phys;
         int retval;
 
-// ???  dap_ap_select(swjdp, swjdp_memoryap);
-
         LOG_DEBUG(&quot;Writing memory to address 0x%x; size %d; count %d&quot;, address, size, count);
         retval = cortex_a8_mmu(target, &amp;enabled);
         if (retval != ERROR_OK)
@@ -1724,6 +1881,21 @@ static int cortex_a8_examine_first(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
+#if 0
+	/*
+	 * FIXME: assuming omap4430
+	 *
+	 * APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
+	 * 0x80000000 is cpu0 coresight region
+	 */
+	if (target-&gt;coreid &gt; 3) {
+		LOG_ERROR(&quot;cortex_a8 supports up to 4 cores&quot;);
+		return ERROR_INVALID_ARGUMENTS;
+	}
+	armv7a-&gt;debug_base = 0x80000000 |
+			((target-&gt;coreid &amp; 0x3) &lt;&lt; CORTEX_A8_PADDRDBG_CPU_SHIFT);
+#endif
+
 	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a-&gt;debug_base + CPUDBG_CPUID, &amp;cpuid);
 	if (retval != ERROR_OK)
diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index 7e116e4..b49e670 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -33,7 +33,6 @@
 
 #define CORTEX_A8_COMMON_MAGIC 0x411fc082
 
-/* See Cortex-A8 TRM section 12.5 */
 #define CPUDBG_CPUID	0xD00
 #define CPUDBG_CTYPR	0xD04
 #define CPUDBG_TTYPR	0xD0C
@@ -43,6 +42,8 @@
 #define BRP_NORMAL 0
 #define BRP_CONTEXT 1
 
+#define CORTEX_A8_PADDRDBG_CPU_SHIFT 13
+
 struct cortex_a8_brp
 {
 	int used;
diff --git a/src/target/cortex_a9.c b/src/target/cortex_a9.c
deleted file mode 100644
index ce72ecd..0000000
--- a/src/target/cortex_a9.c
+++ /dev/null
@@ -1,2303 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Dirk Behme                                      *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dirk.behme at gmail.com</A> - copy from cortex_m3                            *
- *                                                                         *
- *   Copyright (C) 2010 &#195;&#152;yvind Harboe                                      *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- *                                                                         *
- *   Cortex-A9(tm) TRM, ARM DDI 0407F                                      *
- *                                                                         *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;breakpoints.h&quot;
-#include &quot;cortex_a9.h&quot;
-#include &quot;register.h&quot;
-#include &quot;target_request.h&quot;
-#include &quot;target_type.h&quot;
-#include &quot;arm_opcodes.h&quot;
-#include &lt;helper/time_support.h&gt;
-
-static int cortex_a9_poll(struct target *target);
-static int cortex_a9_debug_entry(struct target *target);
-static int cortex_a9_restore_context(struct target *target, bool bpwp);
-static int cortex_a9_set_breakpoint(struct target *target,
-		struct breakpoint *breakpoint, uint8_t matchmode);
-static int cortex_a9_unset_breakpoint(struct target *target,
-		struct breakpoint *breakpoint);
-static int cortex_a9_dap_read_coreregister_u32(struct target *target,
-		uint32_t *value, int regnum);
-static int cortex_a9_dap_write_coreregister_u32(struct target *target,
-		uint32_t value, int regnum);
-static int cortex_a9_mmu(struct target *target, int *enabled);
-static int cortex_a9_virt2phys(struct target *target,
-                uint32_t virt, uint32_t *phys);
-static int cortex_a9_disable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache);
-static int cortex_a9_enable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache);
-static int cortex_a9_get_ttb(struct target *target, uint32_t *result);
-
-
-/*
- * FIXME do topology discovery using the ROM; don't
- * assume this is an OMAP3.   Also, allow for multiple ARMv7-A
- * cores, with different AP numbering ... don't use a #define
- * for these numbers, use per-core armv7a state.
- */
-#define swjdp_memoryap 0
-#define swjdp_debugap 1
-
-/*
- * Cortex-A9 Basic debug access, very low level assumes state is saved
- */
-static int cortex_a9_init_debug_access(struct target *target)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	int retval;
-	uint32_t dummy;
-
-	LOG_DEBUG(&quot; &quot;);
-
-	/* Unlocking the debug registers for modification */
-	/* The debugport might be uninitialised so try twice */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
-	if (retval != ERROR_OK)
-	{
-		/* try again */
-		retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
-		if (retval == ERROR_OK)
-		{
-			LOG_USER(&quot;Locking debug access failed on first, but succeeded on second try.&quot;);
-		}
-	}
-	if (retval != ERROR_OK)
-		return retval;
-	/* Clear Sticky Power Down status Bit in PRSR to enable access to
-	   the registers in the Core Power Domain */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_PRSR, &amp;dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Enabling of instruction execution in debug mode is done in debug_entry code */
-
-	/* Resync breakpoint registers */
-
-	/* Since this is likely called from init or reset, update target state information*/
-	return cortex_a9_poll(target);
-}
-
-/* To reduce needless round-trips, pass in a pointer to the current
- * DSCR value.  Initialize it to zero if you just need to know the
- * value on return from this function; or DSCR_INSTR_COMP if you
- * happen to know that no instruction is pending.
- */
-static int cortex_a9_exec_opcode(struct target *target,
-		uint32_t opcode, uint32_t *dscr_p)
-{
-	uint32_t dscr;
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-
-	dscr = dscr_p ? *dscr_p : 0;
-
-	LOG_DEBUG(&quot;exec opcode 0x%08&quot; PRIx32, opcode);
-
-	/* Wait for InstrCompl bit to be set */
-	long long then = timeval_ms();
-	while ((dscr &amp; DSCR_INSTR_COMP) == 0)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-		if (retval != ERROR_OK)
-		{
-			LOG_ERROR(&quot;Could not read DSCR register, opcode = 0x%08&quot; PRIx32, opcode);
-			return retval;
-		}
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;Timeout waiting for cortex_a9_exec_opcode&quot;);
-			return ERROR_FAIL;
-		}
-	}
-
-	retval = mem_ap_sel_write_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_ITR, opcode);
-	if (retval != ERROR_OK)
-		return retval;
-
-	then = timeval_ms();
-	do
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-		if (retval != ERROR_OK)
-		{
-			LOG_ERROR(&quot;Could not read DSCR register&quot;);
-			return retval;
-		}
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;Timeout waiting for cortex_a9_exec_opcode&quot;);
-			return ERROR_FAIL;
-		}
-	}
-	while ((dscr &amp; DSCR_INSTR_COMP) == 0); /* Wait for InstrCompl bit to be set */
-
-	if (dscr_p)
-		*dscr_p = dscr;
-
-	return retval;
-}
-
-/**************************************************************************
-Read core register with very few exec_opcode, fast but needs work_area.
-This can cause problems with MMU active.
-**************************************************************************/
-static int cortex_a9_read_regs_through_mem(struct target *target, uint32_t address,
-		uint32_t * regfile)
-{
-	int retval = ERROR_OK;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-
-	retval = cortex_a9_dap_read_coreregister_u32(target, regfile, 0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a9_dap_write_coreregister_u32(target, address, 0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a9_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
-			(uint8_t *)(&amp;regfile[1]), 4*15, address);
-
-	return retval;
-}
-
-static int cortex_a9_dap_read_coreregister_u32(struct target *target,
-		uint32_t *value, int regnum)
-{
-	int retval = ERROR_OK;
-	uint8_t reg = regnum&amp;0xFF;
-	uint32_t dscr = 0;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-
-	if (reg &gt; 17)
-		return retval;
-
-	if (reg &lt; 15)
-	{
-		/* Rn to DCCTX, &quot;MCR p14, 0, Rn, c0, c5, 0&quot;  0xEE00nE15 */
-		retval = cortex_a9_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else if (reg == 15)
-	{
-		/* &quot;MOV r0, r15&quot;; then move r0 to DCCTX */
-		retval = cortex_a9_exec_opcode(target, 0xE1A0000F, &amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		/* &quot;MRS r0, CPSR&quot; or &quot;MRS r0, SPSR&quot;
-		 * then move r0 to DCCTX
-		 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRS(0, reg &amp; 1), &amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	/* Wait for DTRRXfull then read DTRRTX */
-	long long then = timeval_ms();
-	while ((dscr &amp; DSCR_DTR_TX_FULL) == 0)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;Timeout waiting for cortex_a9_exec_opcode&quot;);
-			return ERROR_FAIL;
-		}
-	}
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DTRTX, value);
-	LOG_DEBUG(&quot;read DCC 0x%08&quot; PRIx32, *value);
-
-	return retval;
-}
-
-static int cortex_a9_dap_write_coreregister_u32(struct target *target,
-		uint32_t value, int regnum)
-{
-	int retval = ERROR_OK;
-	uint8_t Rd = regnum&amp;0xFF;
-	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-
-	LOG_DEBUG(&quot;register %i, value 0x%08&quot; PRIx32, regnum, value);
-
-	/* Check that DCCRX is not full */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-	if (dscr &amp; DSCR_DTR_RX_FULL)
-	{
-		LOG_ERROR(&quot;DSCR_DTR_RX_FULL, dscr 0x%08&quot; PRIx32, dscr);
-		/* Clear DCCRX with MRC(p14, 0, Rd, c0, c5, 0), opcode  0xEE100E15 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	if (Rd &gt; 17)
-		return retval;
-
-	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
-	LOG_DEBUG(&quot;write DCC 0x%08&quot; PRIx32, value);
-	retval = mem_ap_sel_write_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DTRRX, value);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (Rd &lt; 15)
-	{
-		/* DCCRX to Rn, &quot;MRC p14, 0, Rn, c0, c5, 0&quot;, 0xEE10nE15 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else if (Rd == 15)
-	{
-		/* DCCRX to R0, &quot;MRC p14, 0, R0, c0, c5, 0&quot;, 0xEE100E15
-		 * then &quot;mov r15, r0&quot;
-		 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target, 0xE1A0F000, &amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		/* DCCRX to R0, &quot;MRC p14, 0, R0, c0, c5, 0&quot;, 0xEE100E15
-		 * then &quot;MSR CPSR_cxsf, r0&quot; or &quot;MSR SPSR_cxsf, r0&quot; (all fields)
-		 */
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, Rd &amp; 1),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* &quot;Prefetch flush&quot; after modifying execution status in CPSR */
-		if (Rd == 16)
-		{
-			retval = cortex_a9_exec_opcode(target,
-					ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
-					&amp;dscr);
-			if (retval != ERROR_OK)
-				return retval;
-		}
-	}
-
-	return retval;
-}
-
-/* Write to memory mapped registers directly with no cache or mmu handling */
-static int cortex_a9_dap_write_memap_register_u32(struct target *target, uint32_t address, uint32_t value)
-{
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap, address, value);
-
-	return retval;
-}
-
-/*
- * Cortex-A9 implementation of Debug Programmer's Model
- *
- * NOTE the invariant:  these routines return with DSCR_INSTR_COMP set,
- * so there's no need to poll for it before executing an instruction.
- *
- * NOTE that in several of these cases the &quot;stall&quot; mode might be useful.
- * It'd let us queue a few operations together... prepare/finish might
- * be the places to enable/disable that mode.
- */
-
-static inline struct cortex_a9_common *dpm_to_a9(struct arm_dpm *dpm)
-{
-	return container_of(dpm, struct cortex_a9_common, armv7a_common.dpm);
-}
-
-static int cortex_a9_write_dcc(struct cortex_a9_common *a9, uint32_t data)
-{
-	LOG_DEBUG(&quot;write DCC 0x%08&quot; PRIx32, data);
-	return mem_ap_sel_write_u32(&amp;a9-&gt;armv7a_common.dap, swjdp_debugap,
-			a9-&gt;armv7a_common.debug_base + CPUDBG_DTRRX, data);
-}
-
-static int cortex_a9_read_dcc(struct cortex_a9_common *a9, uint32_t *data,
-		uint32_t *dscr_p)
-{
-	struct adiv5_dap *swjdp = &amp;a9-&gt;armv7a_common.dap;
-	uint32_t dscr = DSCR_INSTR_COMP;
-	int retval;
-
-	if (dscr_p)
-		dscr = *dscr_p;
-
-	/* Wait for DTRRXfull */
-	long long then = timeval_ms();
-	while ((dscr &amp; DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				a9-&gt;armv7a_common.debug_base + CPUDBG_DSCR,
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;Timeout waiting for read dcc&quot;);
-			return ERROR_FAIL;
-		}
-	}
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			a9-&gt;armv7a_common.debug_base + CPUDBG_DTRTX, data);
-	if (retval != ERROR_OK)
-		return retval;
-	//LOG_DEBUG(&quot;read DCC 0x%08&quot; PRIx32, *data);
-
-	if (dscr_p)
-		*dscr_p = dscr;
-
-	return retval;
-}
-
-static int cortex_a9_dpm_prepare(struct arm_dpm *dpm)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	struct adiv5_dap *swjdp = &amp;a9-&gt;armv7a_common.dap;
-	uint32_t dscr;
-	int retval;
-
-	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
-	long long then = timeval_ms();
-	for (;;)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				a9-&gt;armv7a_common.debug_base + CPUDBG_DSCR,
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((dscr &amp; DSCR_INSTR_COMP) != 0)
-			break;
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;Timeout waiting for dpm prepare&quot;);
-			return ERROR_FAIL;
-		}
-	}
-
-	/* this &quot;should never happen&quot; ... */
-	if (dscr &amp; DSCR_DTR_RX_FULL) {
-		LOG_ERROR(&quot;DSCR_DTR_RX_FULL, dscr 0x%08&quot; PRIx32, dscr);
-		/* Clear DCCRX */
-		retval = cortex_a9_exec_opcode(
-				a9-&gt;armv7a_common.armv4_5_common.target,
-				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return retval;
-}
-
-static int cortex_a9_dpm_finish(struct arm_dpm *dpm)
-{
-	/* REVISIT what could be done here? */
-	return ERROR_OK;
-}
-
-static int cortex_a9_instr_write_data_dcc(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	int retval;
-	uint32_t dscr = DSCR_INSTR_COMP;
-
-	retval = cortex_a9_write_dcc(a9, data);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return cortex_a9_exec_opcode(
-			a9-&gt;armv7a_common.armv4_5_common.target,
-			opcode,
-			&amp;dscr);
-}
-
-static int cortex_a9_instr_write_data_r0(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t dscr = DSCR_INSTR_COMP;
-	int retval;
-
-	retval = cortex_a9_write_dcc(a9, data);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* DCCRX to R0, &quot;MCR p14, 0, R0, c0, c5, 0&quot;, 0xEE000E15 */
-	retval = cortex_a9_exec_opcode(
-			a9-&gt;armv7a_common.armv4_5_common.target,
-			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-			&amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* then the opcode, taking data from R0 */
-	retval = cortex_a9_exec_opcode(
-			a9-&gt;armv7a_common.armv4_5_common.target,
-			opcode,
-			&amp;dscr);
-
-	return retval;
-}
-
-static int cortex_a9_instr_cpsr_sync(struct arm_dpm *dpm)
-{
-	struct target *target = dpm-&gt;arm-&gt;target;
-	uint32_t dscr = DSCR_INSTR_COMP;
-
-	/* &quot;Prefetch flush&quot; after modifying execution status in CPSR */
-	return cortex_a9_exec_opcode(target,
-			ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
-			&amp;dscr);
-}
-
-static int cortex_a9_instr_read_data_dcc(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t *data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	int retval;
-	uint32_t dscr = DSCR_INSTR_COMP;
-
-	/* the opcode, writing data to DCC */
-	retval = cortex_a9_exec_opcode(
-			a9-&gt;armv7a_common.armv4_5_common.target,
-			opcode,
-			&amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return cortex_a9_read_dcc(a9, data, &amp;dscr);
-}
-
-
-static int cortex_a9_instr_read_data_r0(struct arm_dpm *dpm,
-		uint32_t opcode, uint32_t *data)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t dscr = DSCR_INSTR_COMP;
-	int retval;
-
-	/* the opcode, writing data to R0 */
-	retval = cortex_a9_exec_opcode(
-			a9-&gt;armv7a_common.armv4_5_common.target,
-			opcode,
-			&amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* write R0 to DCC */
-	retval = cortex_a9_exec_opcode(
-			a9-&gt;armv7a_common.armv4_5_common.target,
-			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-			&amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return cortex_a9_read_dcc(a9, data, &amp;dscr);
-}
-
-static int cortex_a9_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
-		uint32_t addr, uint32_t control)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t vr = a9-&gt;armv7a_common.debug_base;
-	uint32_t cr = a9-&gt;armv7a_common.debug_base;
-	int retval;
-
-	switch (index_t) {
-	case 0 ... 15:		/* breakpoints */
-		vr += CPUDBG_BVR_BASE;
-		cr += CPUDBG_BCR_BASE;
-		break;
-	case 16 ... 31:		/* watchpoints */
-		vr += CPUDBG_WVR_BASE;
-		cr += CPUDBG_WCR_BASE;
-		index_t -= 16;
-		break;
-	default:
-		return ERROR_FAIL;
-	}
-	vr += 4 * index_t;
-	cr += 4 * index_t;
-
-	LOG_DEBUG(&quot;A9: bpwp enable, vr %08x cr %08x&quot;,
-			(unsigned) vr, (unsigned) cr);
-
-	retval = cortex_a9_dap_write_memap_register_u32(dpm-&gt;arm-&gt;target,
-			vr, addr);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a9_dap_write_memap_register_u32(dpm-&gt;arm-&gt;target,
-			cr, control);
-	return retval;
-}
-
-static int cortex_a9_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
-{
-	struct cortex_a9_common *a9 = dpm_to_a9(dpm);
-	uint32_t cr;
-
-	switch (index_t) {
-	case 0 ... 15:
-		cr = a9-&gt;armv7a_common.debug_base + CPUDBG_BCR_BASE;
-		break;
-	case 16 ... 31:
-		cr = a9-&gt;armv7a_common.debug_base + CPUDBG_WCR_BASE;
-		index_t -= 16;
-		break;
-	default:
-		return ERROR_FAIL;
-	}
-	cr += 4 * index_t;
-
-	LOG_DEBUG(&quot;A9: bpwp disable, cr %08x&quot;, (unsigned) cr);
-
-	/* clear control register */
-	return cortex_a9_dap_write_memap_register_u32(dpm-&gt;arm-&gt;target, cr, 0);
-}
-
-static int cortex_a9_dpm_setup(struct cortex_a9_common *a9, uint32_t didr)
-{
-	struct arm_dpm *dpm = &amp;a9-&gt;armv7a_common.dpm;
-	int retval;
-
-	dpm-&gt;arm = &amp;a9-&gt;armv7a_common.armv4_5_common;
-	dpm-&gt;didr = didr;
-
-	dpm-&gt;prepare = cortex_a9_dpm_prepare;
-	dpm-&gt;finish = cortex_a9_dpm_finish;
-
-	dpm-&gt;instr_write_data_dcc = cortex_a9_instr_write_data_dcc;
-	dpm-&gt;instr_write_data_r0 = cortex_a9_instr_write_data_r0;
-	dpm-&gt;instr_cpsr_sync = cortex_a9_instr_cpsr_sync;
-
-	dpm-&gt;instr_read_data_dcc = cortex_a9_instr_read_data_dcc;
-	dpm-&gt;instr_read_data_r0 = cortex_a9_instr_read_data_r0;
-
-	dpm-&gt;bpwp_enable = cortex_a9_bpwp_enable;
-	dpm-&gt;bpwp_disable = cortex_a9_bpwp_disable;
-
-	retval = arm_dpm_setup(dpm);
-	if (retval == ERROR_OK)
-		retval = arm_dpm_initialize(dpm);
-
-	return retval;
-}
-
-
-/*
- * Cortex-A9 Run control
- */
-
-static int cortex_a9_poll(struct target *target)
-{
-	int retval = ERROR_OK;
-	uint32_t dscr;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	enum target_state prev_target_state = target-&gt;state;
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-	if (retval != ERROR_OK)
-	{
-		return retval;
-	}
-	cortex_a9-&gt;cpudbg_dscr = dscr;
-
-	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
-	{
-		if (prev_target_state != TARGET_HALTED)
-		{
-			/* We have a halting debug event */
-			LOG_DEBUG(&quot;Target halted&quot;);
-			target-&gt;state = TARGET_HALTED;
-			if ((prev_target_state == TARGET_RUNNING)
-					|| (prev_target_state == TARGET_RESET))
-			{
-				retval = cortex_a9_debug_entry(target);
-				if (retval != ERROR_OK)
-					return retval;
-
-				target_call_event_callbacks(target,
-						TARGET_EVENT_HALTED);
-			}
-			if (prev_target_state == TARGET_DEBUG_RUNNING)
-			{
-				LOG_DEBUG(&quot; &quot;);
-
-				retval = cortex_a9_debug_entry(target);
-				if (retval != ERROR_OK)
-					return retval;
-
-				target_call_event_callbacks(target,
-						TARGET_EVENT_DEBUG_HALTED);
-			}
-		}
-	}
-	else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
-	{
-		target-&gt;state = TARGET_RUNNING;
-	}
-	else
-	{
-		LOG_DEBUG(&quot;Unknown target state dscr = 0x%08&quot; PRIx32, dscr);
-		target-&gt;state = TARGET_UNKNOWN;
-	}
-
-	return retval;
-}
-
-static int cortex_a9_halt(struct target *target)
-{
-	int retval = ERROR_OK;
-	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-
-	/*
-	 * Tell the core to be halted by writing DRCR with 0x1
-	 * and then wait for the core to be halted.
-	 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DRCR, DRCR_HALT);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * enter halting debug mode
-	 */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-		armv7a-&gt;debug_base + CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
-	if (retval != ERROR_OK)
-		return retval;
-
-	long long then = timeval_ms();
-	for (;;)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((dscr &amp; DSCR_CORE_HALTED) != 0)
-		{
-			break;
-		}
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;Timeout waiting for halt&quot;);
-			return ERROR_FAIL;
-		}
-	}
-
-	target-&gt;debug_reason = DBG_REASON_DBGRQ;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *armv4_5 = &amp;armv7a-&gt;armv4_5_common;
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	int retval;
-
-//	struct breakpoint *breakpoint = NULL;
-	uint32_t resume_pc, dscr;
-
-	if (!debug_execution)
-		target_free_all_working_areas(target);
-
-#if 0
-	if (debug_execution)
-	{
-		/* Disable interrupts */
-		/* We disable interrupts in the PRIMASK register instead of
-		 * masking with C_MASKINTS,
-		 * This is probably the same issue as Cortex-M3 Errata 377493:
-		 * C_MASKINTS in parallel with disabled interrupts can cause
-		 * local faults to not be taken. */
-		buf_set_u32(armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_PRIMASK].value, 0, 32, 1);
-		armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_PRIMASK].dirty = 1;
-		armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_PRIMASK].valid = 1;
-
-		/* Make sure we are in Thumb mode */
-		buf_set_u32(armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_xPSR].value, 0, 32,
-			buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_xPSR].value, 0, 32) | (1 &lt;&lt; 24));
-		armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_xPSR].dirty = 1;
-		armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_xPSR].valid = 1;
-	}
-#endif
-
-	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
-	resume_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
-	if (!current)
-		resume_pc = address;
-
-	/* Make sure that the Armv7 gdb thumb fixups does not
-	 * kill the return address
-	 */
-	switch (armv4_5-&gt;core_state)
-	{
-	case ARM_STATE_ARM:
-		resume_pc &amp;= 0xFFFFFFFC;
-		break;
-	case ARM_STATE_THUMB:
-	case ARM_STATE_THUMB_EE:
-		/* When the return address is loaded into PC
-		 * bit 0 must be 1 to stay in Thumb state
-		 */
-		resume_pc |= 0x1;
-		break;
-	case ARM_STATE_JAZELLE:
-		LOG_ERROR(&quot;How do I resume into Jazelle state??&quot;);
-		return ERROR_FAIL;
-	}
-	LOG_DEBUG(&quot;resume pc = 0x%08&quot; PRIx32, resume_pc);
-	buf_set_u32(armv4_5-&gt;pc-&gt;value, 0, 32, resume_pc);
-	armv4_5-&gt;pc-&gt;dirty = 1;
-	armv4_5-&gt;pc-&gt;valid = 1;
-
-	retval = cortex_a9_restore_context(target, handle_breakpoints);
-	if (retval != ERROR_OK)
-		return retval;
-
-#if 0
-	/* the front-end may request us not to handle breakpoints */
-	if (handle_breakpoints)
-	{
-		/* Single step past breakpoint at current address */
-		if ((breakpoint = breakpoint_find(target, resume_pc)))
-		{
-			LOG_DEBUG(&quot;unset breakpoint at 0x%8.8x&quot;, breakpoint-&gt;address);
-			cortex_m3_unset_breakpoint(target, breakpoint);
-			cortex_m3_single_step_core(target);
-			cortex_m3_set_breakpoint(target, breakpoint);
-		}
-	}
-
-#endif
-
-	/*
-	 * Restart core and wait for it to be started.  Clear ITRen and sticky
-	 * exception flags: see ARMv7 ARM, C5.9.
-	 *
-	 * REVISIT: for single stepping, we probably want to
-	 * disable IRQs by default, with optional override...
-	 */
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if ((dscr &amp; DSCR_INSTR_COMP) == 0)
-		LOG_ERROR(&quot;DSCR InstrCompl must be set before leaving debug!&quot;);
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-		armv7a-&gt;debug_base + CPUDBG_DSCR, dscr &amp; ~DSCR_ITR_EN);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DRCR, DRCR_RESTART | DRCR_CLEAR_EXCEPTIONS);
-	if (retval != ERROR_OK)
-		return retval;
-
-	long long then = timeval_ms();
-	for (;;)
-	{
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((dscr &amp; DSCR_CORE_RESTARTED) != 0)
-			break;
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;Timeout waiting for resume&quot;);
-			return ERROR_FAIL;
-		}
-	}
-
-	target-&gt;debug_reason = DBG_REASON_NOTHALTED;
-	target-&gt;state = TARGET_RUNNING;
-
-	/* registers are now invalid */
-	register_cache_invalidate(armv4_5-&gt;core_cache);
-
-	if (!debug_execution)
-	{
-		target-&gt;state = TARGET_RUNNING;
-		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG(&quot;target resumed at 0x%&quot; PRIx32, resume_pc);
-	}
-	else
-	{
-		target-&gt;state = TARGET_DEBUG_RUNNING;
-		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG(&quot;target debug resumed at 0x%&quot; PRIx32, resume_pc);
-	}
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_debug_entry(struct target *target)
-{
-	int i;
-	uint32_t regfile[16], cpsr, dscr;
-	int retval = ERROR_OK;
-	struct working_area *regfile_working_area = NULL;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *armv4_5 = &amp;armv7a-&gt;armv4_5_common;
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	struct reg *reg;
-
-	LOG_DEBUG(&quot;dscr = 0x%08&quot; PRIx32, cortex_a9-&gt;cpudbg_dscr);
-
-	/* REVISIT surely we should not re-read DSCR !! */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* REVISIT see A9 TRM 12.11.4 steps 2..3 -- make sure that any
-	 * imprecise data aborts get discarded by issuing a Data
-	 * Synchronization Barrier:  ARMV4_5_MCR(15, 0, 0, 7, 10, 4).
-	 */
-
-	/* Enable the ITR execution once we are in debug mode */
-	dscr |= DSCR_ITR_EN;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DSCR, dscr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Examine debug reason */
-	arm_dpm_report_dscr(&amp;armv7a-&gt;dpm, cortex_a9-&gt;cpudbg_dscr);
-
-	/* save address of instruction that triggered the watchpoint? */
-	if (target-&gt;debug_reason == DBG_REASON_WATCHPOINT) {
-		uint32_t wfar;
-
-		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-				armv7a-&gt;debug_base + CPUDBG_WFAR,
-				&amp;wfar);
-		if (retval != ERROR_OK)
-			return retval;
-		arm_dpm_report_wfar(&amp;armv7a-&gt;dpm, wfar);
-	}
-
-	/* REVISIT fast_reg_read is never set ... */
-
-	/* Examine target state and mode */
-	if (cortex_a9-&gt;fast_reg_read)
-		target_alloc_working_area(target, 64, &amp;regfile_working_area);
-
-	/* First load register acessible through core debug port*/
-	if (!regfile_working_area)
-	{
-		retval = arm_dpm_read_current_registers(&amp;armv7a-&gt;dpm);
-	}
-	else
-	{
-		retval = cortex_a9_read_regs_through_mem(target,
-				regfile_working_area-&gt;address, regfile);
-
-		target_free_working_area(target, regfile_working_area);
-		if (retval != ERROR_OK)
-		{
-			return retval;
-		}
-
-		/* read Current PSR */
-		retval = cortex_a9_dap_read_coreregister_u32(target, &amp;cpsr, 16);
-		if (retval != ERROR_OK)
-			return retval;
-
-		LOG_DEBUG(&quot;cpsr: %8.8&quot; PRIx32, cpsr);
-
-		arm_set_cpsr(armv4_5, cpsr);
-
-		/* update cache */
-		for (i = 0; i &lt;= ARM_PC; i++)
-		{
-			reg = arm_reg_current(armv4_5, i);
-
-			buf_set_u32(reg-&gt;value, 0, 32, regfile[i]);
-			reg-&gt;valid = 1;
-			reg-&gt;dirty = 0;
-		}
-
-		/* Fixup PC Resume Address */
-		if (cpsr &amp; (1 &lt;&lt; 5))
-		{
-			// T bit set for Thumb or ThumbEE state
-			regfile[ARM_PC] -= 4;
-		}
-		else
-		{
-			// ARM state
-			regfile[ARM_PC] -= 8;
-		}
-
-		reg = armv4_5-&gt;pc;
-		buf_set_u32(reg-&gt;value, 0, 32, regfile[ARM_PC]);
-		reg-&gt;dirty = reg-&gt;valid;
-	}
-
-#if 0
-/* TODO, Move this */
-	uint32_t cp15_control_register, cp15_cacr, cp15_nacr;
-	cortex_a9_read_cp(target, &amp;cp15_control_register, 15, 0, 1, 0, 0);
-	LOG_DEBUG(&quot;cp15_control_register = 0x%08x&quot;, cp15_control_register);
-
-	cortex_a9_read_cp(target, &amp;cp15_cacr, 15, 0, 1, 0, 2);
-	LOG_DEBUG(&quot;cp15 Coprocessor Access Control Register = 0x%08x&quot;, cp15_cacr);
-
-	cortex_a9_read_cp(target, &amp;cp15_nacr, 15, 0, 1, 1, 2);
-	LOG_DEBUG(&quot;cp15 Nonsecure Access Control Register = 0x%08x&quot;, cp15_nacr);
-#endif
-
-	/* Are we in an exception handler */
-//	armv4_5-&gt;exception_number = 0;
-	if (armv7a-&gt;post_debug_entry)
-	{
-		retval = armv7a-&gt;post_debug_entry(target);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return retval;
-}
-
-static int cortex_a9_post_debug_entry(struct target *target)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	int retval;
-
-	/* MRC p15,0,&lt;Rt&gt;,c1,c0,0 ; Read CP15 System Control Register */
-	retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-			0, 0,	/* op1, op2 */
-			1, 0,	/* CRn, CRm */
-			&amp;cortex_a9-&gt;cp15_control_reg);
-	if (retval != ERROR_OK)
-		return retval;
-	LOG_DEBUG(&quot;cp15_control_reg: %8.8&quot; PRIx32, cortex_a9-&gt;cp15_control_reg);
-
-	if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
-	{
-		uint32_t cache_type_reg;
-
-		/* MRC p15,0,&lt;Rt&gt;,c0,c0,1 ; Read CP15 Cache Type Register */
-		retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-				0, 1,	/* op1, op2 */
-				0, 0,	/* CRn, CRm */
-				&amp;cache_type_reg);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG(&quot;cp15 cache type: %8.8x&quot;, (unsigned) cache_type_reg);
-
-		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A9 */
-		armv4_5_identify_cache(cache_type_reg,
-				&amp;armv7a-&gt;armv4_5_mmu.armv4_5_cache);
-	}
-
-	armv7a-&gt;armv4_5_mmu.mmu_enabled =
-			(cortex_a9-&gt;cp15_control_reg &amp; 0x1U) ? 1 : 0;
-	armv7a-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled =
-			(cortex_a9-&gt;cp15_control_reg &amp; 0x4U) ? 1 : 0;
-	armv7a-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled =
-			(cortex_a9-&gt;cp15_control_reg &amp; 0x1000U) ? 1 : 0;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_step(struct target *target, int current, uint32_t address,
-		int handle_breakpoints)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *armv4_5 = &amp;armv7a-&gt;armv4_5_common;
-	struct breakpoint *breakpoint = NULL;
-	struct breakpoint stepbreakpoint;
-	struct reg *r;
-	int retval;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_WARNING(&quot;target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
-	r = armv4_5-&gt;pc;
-	if (!current)
-	{
-		buf_set_u32(r-&gt;value, 0, 32, address);
-	}
-	else
-	{
-		address = buf_get_u32(r-&gt;value, 0, 32);
-	}
-
-	/* The front-end may request us not to handle breakpoints.
-	 * But since Cortex-A9 uses breakpoint for single step,
-	 * we MUST handle breakpoints.
-	 */
-	handle_breakpoints = 1;
-	if (handle_breakpoints) {
-		breakpoint = breakpoint_find(target, address);
-		if (breakpoint)
-			cortex_a9_unset_breakpoint(target, breakpoint);
-	}
-
-	/* Setup single step breakpoint */
-	stepbreakpoint.address = address;
-	stepbreakpoint.length = (armv4_5-&gt;core_state == ARM_STATE_THUMB)
-			? 2 : 4;
-	stepbreakpoint.type = BKPT_HARD;
-	stepbreakpoint.set = 0;
-
-	/* Break on IVA mismatch */
-	cortex_a9_set_breakpoint(target, &amp;stepbreakpoint, 0x04);
-
-	target-&gt;debug_reason = DBG_REASON_SINGLESTEP;
-
-	retval = cortex_a9_resume(target, 1, address, 0, 0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	long long then = timeval_ms();
-	while (target-&gt;state != TARGET_HALTED)
-	{
-		retval = cortex_a9_poll(target);
-		if (retval != ERROR_OK)
-			return retval;
-		if (timeval_ms() &gt; then + 1000)
-		{
-			LOG_ERROR(&quot;timeout waiting for target halt&quot;);
-			return ERROR_FAIL;
-		}
-	}
-
-	cortex_a9_unset_breakpoint(target, &amp;stepbreakpoint);
-
-	target-&gt;debug_reason = DBG_REASON_BREAKPOINT;
-
-	if (breakpoint)
-		cortex_a9_set_breakpoint(target, breakpoint, 0);
-
-	if (target-&gt;state != TARGET_HALTED)
-		LOG_DEBUG(&quot;target stepped&quot;);
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_restore_context(struct target *target, bool bpwp)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	LOG_DEBUG(&quot; &quot;);
-
-	if (armv7a-&gt;pre_restore_context)
-		armv7a-&gt;pre_restore_context(target);
-
-	return arm_dpm_write_dirty_registers(&amp;armv7a-&gt;dpm, bpwp);
-}
-
-
-/*
- * Cortex-A9 Breakpoint and watchpoint functions
- */
-
-/* Setup hardware Breakpoint Register Pair */
-static int cortex_a9_set_breakpoint(struct target *target,
-		struct breakpoint *breakpoint, uint8_t matchmode)
-{
-	int retval;
-	int brp_i=0;
-	uint32_t control;
-	uint8_t byte_addr_select = 0x0F;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	struct cortex_a9_brp * brp_list = cortex_a9-&gt;brp_list;
-
-	if (breakpoint-&gt;set)
-	{
-		LOG_WARNING(&quot;breakpoint already set&quot;);
-		return ERROR_OK;
-	}
-
-	if (breakpoint-&gt;type == BKPT_HARD)
-	{
-		while (brp_list[brp_i].used &amp;&amp; (brp_i &lt; cortex_a9-&gt;brp_num))
-			brp_i++ ;
-		if (brp_i &gt;= cortex_a9-&gt;brp_num)
-		{
-			LOG_ERROR(&quot;ERROR Can not find free Breakpoint Register Pair&quot;);
-			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-		}
-		breakpoint-&gt;set = brp_i + 1;
-		if (breakpoint-&gt;length == 2)
-		{
-			byte_addr_select = (3 &lt;&lt; (breakpoint-&gt;address &amp; 0x02));
-		}
-		control = ((matchmode &amp; 0x7) &lt;&lt; 20)
-				| (byte_addr_select &lt;&lt; 5)
-				| (3 &lt;&lt; 1) | 1;
-		brp_list[brp_i].used = 1;
-		brp_list[brp_i].value = (breakpoint-&gt;address &amp; 0xFFFFFFFC);
-		brp_list[brp_i].control = control;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a-&gt;debug_base
-				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].value);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a-&gt;debug_base
-				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].control);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG(&quot;brp %i control 0x%0&quot; PRIx32 &quot; value 0x%0&quot; PRIx32, brp_i,
-				brp_list[brp_i].control,
-				brp_list[brp_i].value);
-	}
-	else if (breakpoint-&gt;type == BKPT_SOFT)
-	{
-		uint8_t code[4];
-		if (breakpoint-&gt;length == 2)
-		{
-			buf_set_u32(code, 0, 32, ARMV5_T_BKPT(0x11));
-		}
-		else
-		{
-			buf_set_u32(code, 0, 32, ARMV5_BKPT(0x11));
-		}
-		retval = target-&gt;type-&gt;read_memory(target,
-				breakpoint-&gt;address &amp; 0xFFFFFFFE,
-				breakpoint-&gt;length, 1,
-				breakpoint-&gt;orig_instr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target-&gt;type-&gt;write_memory(target,
-				breakpoint-&gt;address &amp; 0xFFFFFFFE,
-				breakpoint-&gt;length, 1, code);
-		if (retval != ERROR_OK)
-			return retval;
-		breakpoint-&gt;set = 0x11; /* Any nice value but 0 */
-	}
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
-{
-	int retval;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	struct cortex_a9_brp * brp_list = cortex_a9-&gt;brp_list;
-
-	if (!breakpoint-&gt;set)
-	{
-		LOG_WARNING(&quot;breakpoint not set&quot;);
-		return ERROR_OK;
-	}
-
-	if (breakpoint-&gt;type == BKPT_HARD)
-	{
-		int brp_i = breakpoint-&gt;set - 1;
-		if ((brp_i &lt; 0) || (brp_i &gt;= cortex_a9-&gt;brp_num))
-		{
-			LOG_DEBUG(&quot;Invalid BRP number in breakpoint&quot;);
-			return ERROR_OK;
-		}
-		LOG_DEBUG(&quot;rbp %i control 0x%0&quot; PRIx32 &quot; value 0x%0&quot; PRIx32, brp_i,
-				brp_list[brp_i].control, brp_list[brp_i].value);
-		brp_list[brp_i].used = 0;
-		brp_list[brp_i].value = 0;
-		brp_list[brp_i].control = 0;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a-&gt;debug_base
-				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].control);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a9_dap_write_memap_register_u32(target, armv7a-&gt;debug_base
-				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		/* restore original instruction (kept in target endianness) */
-		if (breakpoint-&gt;length == 4)
-		{
-			retval = target-&gt;type-&gt;write_memory(target,
-					breakpoint-&gt;address &amp; 0xFFFFFFFE,
-					4, 1, breakpoint-&gt;orig_instr);
-			if (retval != ERROR_OK)
-				return retval;
-		}
-		else
-		{
-			retval = target-&gt;type-&gt;write_memory(target,
-					breakpoint-&gt;address &amp; 0xFFFFFFFE,
-					2, 1, breakpoint-&gt;orig_instr);
-			if (retval != ERROR_OK)
-				return retval;
-		}
-	}
-	breakpoint-&gt;set = 0;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_add_breakpoint(struct target *target,
-		struct breakpoint *breakpoint)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-
-	if ((breakpoint-&gt;type == BKPT_HARD) &amp;&amp; (cortex_a9-&gt;brp_num_available &lt; 1))
-	{
-		LOG_INFO(&quot;no hardware breakpoint available&quot;);
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
-
-	if (breakpoint-&gt;type == BKPT_HARD)
-		cortex_a9-&gt;brp_num_available--;
-
-	return cortex_a9_set_breakpoint(target, breakpoint, 0x00); /* Exact match */
-}
-
-static int cortex_a9_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-
-#if 0
-/* It is perfectly possible to remove breakpoints while the target is running */
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_WARNING(&quot;target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-#endif
-
-	if (breakpoint-&gt;set)
-	{
-		cortex_a9_unset_breakpoint(target, breakpoint);
-		if (breakpoint-&gt;type == BKPT_HARD)
-			cortex_a9-&gt;brp_num_available++ ;
-	}
-
-
-	return ERROR_OK;
-}
-
-
-
-/*
- * Cortex-A9 Reset functions
- */
-
-static int cortex_a9_assert_reset(struct target *target)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	LOG_DEBUG(&quot; &quot;);
-
-	/* FIXME when halt is requested, make it work somehow... */
-
-	/* Issue some kind of warm reset. */
-	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
-		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
-	} else if (jtag_get_reset_config() &amp; RESET_HAS_SRST) {
-		/* REVISIT handle &quot;pulls&quot; cases, if there's
-		 * hardware that needs them to work.
-		 */
-		jtag_add_reset(0, 1);
-	} else {
-		LOG_ERROR(&quot;%s: how to reset?&quot;, target_name(target));
-		return ERROR_FAIL;
-	}
-
-	/* registers are now invalid */
-	register_cache_invalidate(armv7a-&gt;armv4_5_common.core_cache);
-
-	target-&gt;state = TARGET_RESET;
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_deassert_reset(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG(&quot; &quot;);
-
-	/* be certain SRST is off */
-	jtag_add_reset(0, 0);
-
-	retval = cortex_a9_poll(target);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (target-&gt;reset_halt) {
-		if (target-&gt;state != TARGET_HALTED) {
-			LOG_WARNING(&quot;%s: ran after reset and before halt ...&quot;,
-					target_name(target));
-			if ((retval = target_halt(target)) != ERROR_OK)
-				return retval;
-		}
-	}
-
-	return ERROR_OK;
-}
-
-/*
- * Cortex-A9 Memory access
- *
- * This is same Cortex M3 but we must also use the correct
- * ap number for every access.
- */
-
-static int cortex_a9_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	int retval = ERROR_INVALID_ARGUMENTS;
-	uint8_t apsel = swjdp-&gt;apsel;
-
-	LOG_DEBUG(&quot;Reading memory at real address 0x%x; size %d; count %d&quot;, address, size, count);
-
-	if (count &amp;&amp; buffer) {
-
-		if ( apsel == swjdp_memoryap ) {
-
-			/* read memory through AHB-AP */
-
-			switch (size) {
-				case 4:
-					retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
-							buffer, 4 * count, address);
-					break;
-				case 2:
-					retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
-							buffer, 2 * count, address);
-					break;
-				case 1:
-					retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
-							buffer, count, address);
-					break;
-			}
-
-		} else {
-
-			/* read memory through APB-AP */
-
-			uint32_t saved_r0, saved_r1;
-			int nbytes = count * size;
-			uint32_t data;
-			int enabled = 0;
-
-			if (target-&gt;state != TARGET_HALTED)
-			{
-				LOG_WARNING(&quot;target not halted&quot;);
-				return ERROR_TARGET_NOT_HALTED;
-			}
-
-			retval = cortex_a9_mmu(target, &amp;enabled);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if (enabled)
-			{
-				LOG_WARNING(&quot;Reading physical memory through APB with MMU enabled is not yet implemented&quot;);
-				return ERROR_TARGET_FAILURE;
-			}
-
-			/* save registers r0 and r1, we are going to corrupt them  */
-			retval = cortex_a9_dap_read_coreregister_u32(target, &amp;saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_read_coreregister_u32(target, &amp;saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, address, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			while (nbytes &gt; 0) {
-
-				/* execute instruction LDRB r1, [r0], 1 (0xe4d01001) */
-				retval = cortex_a9_exec_opcode(target, ARMV4_5_LDRB_IP(1, 0) , NULL);
-				if (retval != ERROR_OK)
-						return retval;
-
-				retval = cortex_a9_dap_read_coreregister_u32(target, &amp;data, 1);
-				if (retval != ERROR_OK)
-					return retval;
-
-				*buffer++ = data;
-				--nbytes;
-
-			}
-
-			/* restore corrupted registers r0 and r1 */
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-		}
-	}
-
-	return retval;
-}
-
-static int cortex_a9_read_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
-{
-	int enabled = 0;
-	uint32_t virt, phys;
-	int retval;
-
-	/* cortex_a9 handles unaligned memory access */
-
-	LOG_DEBUG(&quot;Reading memory at address 0x%x; size %d; count %d&quot;, address, size, count);
-	retval = cortex_a9_mmu(target, &amp;enabled);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (enabled)
-	{
-		virt = address;
-		retval = cortex_a9_virt2phys(target, virt, &amp;phys);
-		if (retval != ERROR_OK)
-			return retval;
-
-		LOG_DEBUG(&quot;Reading at virtual address. Translating v:0x%x to r:0x%x&quot;, virt, phys);
-		address = phys;
-	}
-
-	return cortex_a9_read_phys_memory(target, address, size, count, buffer);
-}
-
-static int cortex_a9_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	int retval = ERROR_INVALID_ARGUMENTS;
-	uint8_t apsel = swjdp-&gt;apsel;
-
-	LOG_DEBUG(&quot;Writing memory to real address 0x%x; size %d; count %d&quot;, address, size, count);
-
-	if (count &amp;&amp; buffer) {
-
-		if ( apsel == swjdp_memoryap ) {
-
-			/* write memory through AHB-AP */
-
-			switch (size) {
-				case 4:
-					retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,
-							buffer, 4 * count, address);
-					break;
-				case 2:
-					retval = mem_ap_sel_write_buf_u16(swjdp, swjdp_memoryap,
-							buffer, 2 * count, address);
-					break;
-				case 1:
-					retval = mem_ap_sel_write_buf_u8(swjdp, swjdp_memoryap,
-							buffer, count, address);
-					break;
-			}
-
-		} else {
-
-			/* write memory through APB-AP */
-
-			uint32_t saved_r0, saved_r1;
-			int nbytes = count * size;
-			uint32_t data;
-			int enabled = 0;
-
-			if (target-&gt;state != TARGET_HALTED)
-			{
-				LOG_WARNING(&quot;target not halted&quot;);
-				return ERROR_TARGET_NOT_HALTED;
-			}
-
-			retval = cortex_a9_mmu(target, &amp;enabled);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if (enabled)
-			{
-				LOG_WARNING(&quot;Writing physical memory through APB with MMU enabled is not yet implemented&quot;);
-				return ERROR_TARGET_FAILURE;
-			}
-
-			/* save registers r0 and r1, we are going to corrupt them  */
-			retval = cortex_a9_dap_read_coreregister_u32(target, &amp;saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_read_coreregister_u32(target, &amp;saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, address, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			while (nbytes &gt; 0) {
-
-				data = *buffer++;
-
-				retval = cortex_a9_dap_write_coreregister_u32(target, data, 1);
-				if (retval != ERROR_OK)
-					return retval;
-
-					/* execute instruction STRB r1, [r0], 1 (0xe4c01001) */
-				retval = cortex_a9_exec_opcode(target, ARMV4_5_STRB_IP(1, 0) , NULL);
-				if (retval != ERROR_OK)
-						return retval;
-
-				--nbytes;
-			}
-
-			/* restore corrupted registers r0 and r1 */
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r0, 0);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = cortex_a9_dap_write_coreregister_u32(target, saved_r1, 1);
-			if (retval != ERROR_OK)
-				return retval;
-
-			/* we can return here without invalidating D/I-cache because */
-			/* access through APB maintains cache coherency              */
-			return retval;
-		}
-	}
-
-
-	/* REVISIT this op is generic ARMv7-A/R stuff */
-	if (retval == ERROR_OK &amp;&amp; target-&gt;state == TARGET_HALTED)
-	{
-		struct arm_dpm *dpm = armv7a-&gt;armv4_5_common.dpm;
-
-		retval = dpm-&gt;prepare(dpm);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* The Cache handling will NOT work with MMU active, the
-		 * wrong addresses will be invalidated!
-		 *
-		 * For both ICache and DCache, walk all cache lines in the
-		 * address range. Cortex-A9 has fixed 64 byte line length.
-		 *
-		 * REVISIT per ARMv7, these may trigger watchpoints ...
-		 */
-
-		/* invalidate I-Cache */
-		if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled)
-		{
-			/* ICIMVAU - Invalidate Cache single entry
-			 * with MVA to PoU
-			 *      MCR p15, 0, r0, c7, c5, 1
-			 */
-			for (uint32_t cacheline = address;
-					cacheline &lt; address + size * count;
-					cacheline += 64) {
-				retval = dpm-&gt;instr_write_data_r0(dpm,
-						ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
-						cacheline);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-		}
-
-		/* invalidate D-Cache */
-		if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-		{
-			/* DCIMVAC - Invalidate data Cache line
-			 * with MVA to PoC
-			 *      MCR p15, 0, r0, c7, c6, 1
-			 */
-			for (uint32_t cacheline = address;
-					cacheline &lt; address + size * count;
-					cacheline += 64) {
-				retval = dpm-&gt;instr_write_data_r0(dpm,
-						ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
-						cacheline);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-		}
-
-		/* (void) */ dpm-&gt;finish(dpm);
-	}
-
-	return retval;
-}
-
-static int cortex_a9_write_memory(struct target *target, uint32_t address,
-                uint32_t size, uint32_t count, uint8_t *buffer)
-{
-	int enabled = 0;
-	uint32_t virt, phys;
-	int retval;
-
-	LOG_DEBUG(&quot;Writing memory to address 0x%x; size %d; count %d&quot;, address, size, count);
-	retval = cortex_a9_mmu(target, &amp;enabled);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (enabled)
-	{
-		virt = address;
-		retval = cortex_a9_virt2phys(target, virt, &amp;phys);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_DEBUG(&quot;Writing to virtual address. Translating v:0x%x to r:0x%x&quot;, virt, phys);
-		address = phys;
-	}
-
-	return cortex_a9_write_phys_memory(target, address, size,
-			count, buffer);
-}
-
-static int cortex_a9_bulk_write_memory(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer)
-{
-	return cortex_a9_write_memory(target, address, 4, count, buffer);
-}
-
-static int cortex_a9_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
-{
-#if 0
-	u16 dcrdr;
-
-	mem_ap_read_buf_u16(swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
-	*ctrl = (uint8_t)dcrdr;
-	*value = (uint8_t)(dcrdr &gt;&gt; 8);
-
-	LOG_DEBUG(&quot;data 0x%x ctrl 0x%x&quot;, *value, *ctrl);
-
-	/* write ack back to software dcc register
-	 * signify we have read data */
-	if (dcrdr &amp; (1 &lt;&lt; 0))
-	{
-		dcrdr = 0;
-		mem_ap_write_buf_u16(swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
-	}
-#endif
-	return ERROR_OK;
-}
-
-
-static int cortex_a9_handle_target_request(void *priv)
-{
-	struct target *target = priv;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	int retval;
-
-	if (!target_was_examined(target))
-		return ERROR_OK;
-	if (!target-&gt;dbg_msg_enabled)
-		return ERROR_OK;
-
-	if (target-&gt;state == TARGET_RUNNING)
-	{
-		uint8_t data = 0;
-		uint8_t ctrl = 0;
-
-		retval = cortex_a9_dcc_read(swjdp, &amp;data, &amp;ctrl);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* check if we have data */
-		if (ctrl &amp; (1 &lt;&lt; 0))
-		{
-			uint32_t request;
-
-			/* we assume target is quick enough */
-			request = data;
-			retval = cortex_a9_dcc_read(swjdp, &amp;data, &amp;ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data &lt;&lt; 8);
-			retval = cortex_a9_dcc_read(swjdp, &amp;data, &amp;ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data &lt;&lt; 16);
-			retval = cortex_a9_dcc_read(swjdp, &amp;data, &amp;ctrl);
-			if (retval != ERROR_OK)
-				return retval;
-			request |= (data &lt;&lt; 24);
-			target_request(target, request);
-		}
-	}
-
-	return ERROR_OK;
-}
-
-/*
- * Cortex-A9 target information and configuration
- */
-
-static int cortex_a9_examine_first(struct target *target)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	struct adiv5_dap *swjdp = &amp;armv7a-&gt;dap;
-	int i;
-	int retval = ERROR_OK;
-	uint32_t didr, ctypr, ttypr, cpuid;
-
-	/* We do one extra read to ensure DAP is configured,
-	 * we call ahbap_debugport_init(swjdp) instead
-	 */
-	retval = ahbap_debugport_init(swjdp);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * FIXME: assuming omap4430
-	 *
-	 * APB DBGBASE reads 0x80040000, but this points to an empty ROM table.
-	 * 0x80000000 is cpu0 coresight region
-	 */
-	if (target-&gt;coreid &gt; 3) {
-		LOG_ERROR(&quot;cortex_a9 supports up to 4 cores&quot;);
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	armv7a-&gt;debug_base = 0x80000000 |
-			((target-&gt;coreid &amp; 0x3) &lt;&lt; CORTEX_A9_PADDRDBG_CPU_SHIFT);
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_CPUID, &amp;cpuid);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_CPUID, &amp;cpuid)) != ERROR_OK)
-	{
-		LOG_DEBUG(&quot;Examine %s failed&quot;, &quot;CPUID&quot;);
-		return retval;
-	}
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_CTYPR, &amp;ctypr)) != ERROR_OK)
-	{
-		LOG_DEBUG(&quot;Examine %s failed&quot;, &quot;CTYPR&quot;);
-		return retval;
-	}
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_TTYPR, &amp;ttypr)) != ERROR_OK)
-	{
-		LOG_DEBUG(&quot;Examine %s failed&quot;, &quot;TTYPR&quot;);
-		return retval;
-	}
-
-	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DIDR, &amp;didr)) != ERROR_OK)
-	{
-		LOG_DEBUG(&quot;Examine %s failed&quot;, &quot;DIDR&quot;);
-		return retval;
-	}
-
-	LOG_DEBUG(&quot;cpuid = 0x%08&quot; PRIx32, cpuid);
-	LOG_DEBUG(&quot;ctypr = 0x%08&quot; PRIx32, ctypr);
-	LOG_DEBUG(&quot;ttypr = 0x%08&quot; PRIx32, ttypr);
-	LOG_DEBUG(&quot;didr = 0x%08&quot; PRIx32, didr);
-
-	armv7a-&gt;armv4_5_common.core_type = ARM_MODE_MON;
-	retval = cortex_a9_dpm_setup(cortex_a9, didr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Setup Breakpoint Register Pairs */
-	cortex_a9-&gt;brp_num = ((didr &gt;&gt; 24) &amp; 0x0F) + 1;
-	cortex_a9-&gt;brp_num_context = ((didr &gt;&gt; 20) &amp; 0x0F) + 1;
-	cortex_a9-&gt;brp_num_available = cortex_a9-&gt;brp_num;
-	cortex_a9-&gt;brp_list = calloc(cortex_a9-&gt;brp_num, sizeof(struct cortex_a9_brp));
-//	cortex_a9-&gt;brb_enabled = ????;
-	for (i = 0; i &lt; cortex_a9-&gt;brp_num; i++)
-	{
-		cortex_a9-&gt;brp_list[i].used = 0;
-		if (i &lt; (cortex_a9-&gt;brp_num-cortex_a9-&gt;brp_num_context))
-			cortex_a9-&gt;brp_list[i].type = BRP_NORMAL;
-		else
-			cortex_a9-&gt;brp_list[i].type = BRP_CONTEXT;
-		cortex_a9-&gt;brp_list[i].value = 0;
-		cortex_a9-&gt;brp_list[i].control = 0;
-		cortex_a9-&gt;brp_list[i].BRPn = i;
-	}
-
-	LOG_DEBUG(&quot;Configured %i hw breakpoints&quot;, cortex_a9-&gt;brp_num);
-
-	target_set_examined(target);
-	return ERROR_OK;
-}
-
-static int cortex_a9_examine(struct target *target)
-{
-	int retval = ERROR_OK;
-
-	/* don't re-probe hardware after each reset */
-	if (!target_was_examined(target))
-		retval = cortex_a9_examine_first(target);
-
-	/* Configure core debug access */
-	if (retval == ERROR_OK)
-		retval = cortex_a9_init_debug_access(target);
-
-	return retval;
-}
-
-/*
- *	Cortex-A9 target creation and initialization
- */
-
-static int cortex_a9_init_target(struct command_context *cmd_ctx,
-		struct target *target)
-{
-	/* examine_first() does a bunch of this */
-	return ERROR_OK;
-}
-
-static int cortex_a9_init_arch_info(struct target *target,
-		struct cortex_a9_common *cortex_a9, struct jtag_tap *tap)
-{
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	struct arm *armv4_5 = &amp;armv7a-&gt;armv4_5_common;
-	struct adiv5_dap *dap = &amp;armv7a-&gt;dap;
-
-	armv7a-&gt;armv4_5_common.dap = dap;
-
-	/* Setup struct cortex_a9_common */
-	cortex_a9-&gt;common_magic = CORTEX_A9_COMMON_MAGIC;
-	armv4_5-&gt;arch_info = armv7a;
-
-	/* prepare JTAG information for the new target */
-	cortex_a9-&gt;jtag_info.tap = tap;
-	cortex_a9-&gt;jtag_info.scann_size = 4;
-
-	/* Leave (only) generic DAP stuff for debugport_init() */
-	dap-&gt;jtag_info = &amp;cortex_a9-&gt;jtag_info;
-	dap-&gt;memaccess_tck = 80;
-
-	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
-	dap-&gt;tar_autoincr_block = (1 &lt;&lt; 10);
-
-	cortex_a9-&gt;fast_reg_read = 0;
-
-	/* Set default value */
-	cortex_a9-&gt;current_address_mode = ARM_MODE_ANY;
-
-	/* register arch-specific functions */
-	armv7a-&gt;examine_debug_reason = NULL;
-
-	armv7a-&gt;post_debug_entry = cortex_a9_post_debug_entry;
-
-	armv7a-&gt;pre_restore_context = NULL;
-	armv7a-&gt;armv4_5_mmu.armv4_5_cache.ctype = -1;
-	armv7a-&gt;armv4_5_mmu.get_ttb = cortex_a9_get_ttb;
-	armv7a-&gt;armv4_5_mmu.read_memory = cortex_a9_read_phys_memory;
-	armv7a-&gt;armv4_5_mmu.write_memory = cortex_a9_write_phys_memory;
-	armv7a-&gt;armv4_5_mmu.disable_mmu_caches = cortex_a9_disable_mmu_caches;
-	armv7a-&gt;armv4_5_mmu.enable_mmu_caches = cortex_a9_enable_mmu_caches;
-	armv7a-&gt;armv4_5_mmu.has_tiny_pages = 1;
-	armv7a-&gt;armv4_5_mmu.mmu_enabled = 0;
-
-
-//	arm7_9-&gt;handle_target_request = cortex_a9_handle_target_request;
-
-	/* REVISIT v7a setup should be in a v7a-specific routine */
-	arm_init_arch_info(target, armv4_5);
-	armv7a-&gt;common_magic = ARMV7_COMMON_MAGIC;
-
-	target_register_timer_callback(cortex_a9_handle_target_request, 1, 1, target);
-
-	return ERROR_OK;
-}
-
-static int cortex_a9_target_create(struct target *target, Jim_Interp *interp)
-{
-	struct cortex_a9_common *cortex_a9 = calloc(1, sizeof(struct cortex_a9_common));
-
-	return cortex_a9_init_arch_info(target, cortex_a9, target-&gt;tap);
-}
-
-static int cortex_a9_get_ttb(struct target *target, uint32_t *result)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-    struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-    uint32_t ttb = 0, retval = ERROR_OK;
-
-    /* current_address_mode is set inside cortex_a9_virt2phys()
-       where we can determine if address belongs to user or kernel */
-    if(cortex_a9-&gt;current_address_mode == ARM_MODE_SVC)
-    {
-        /* MRC p15,0,&lt;Rt&gt;,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-                    0, 1,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &amp;ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    else if(cortex_a9-&gt;current_address_mode == ARM_MODE_USR)
-    {
-        /* MRC p15,0,&lt;Rt&gt;,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &amp;ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    /* we don't know whose address is: user or kernel
-       we assume that if we are in kernel mode then
-       address belongs to kernel else if in user mode
-       - to user */
-    else if(armv7a-&gt;armv4_5_common.core_mode == ARM_MODE_SVC)
-    {
-        /* MRC p15,0,&lt;Rt&gt;,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-                    0, 1,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &amp;ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    else if(armv7a-&gt;armv4_5_common.core_mode == ARM_MODE_USR)
-    {
-        /* MRC p15,0,&lt;Rt&gt;,c1,c0,0 ; Read CP15 System Control Register */
-        retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-                    0, 0,   /* op1, op2 */
-                    2, 0,   /* CRn, CRm */
-                    &amp;ttb);
-		if (retval != ERROR_OK)
-			return retval;
-    }
-    /* finally we don't know whose ttb to use: user or kernel */
-    else
-        LOG_ERROR(&quot;Don't know how to get ttb for current mode!!!&quot;);
-
-    ttb &amp;= 0xffffc000;
-
-    *result = ttb;
-
-    return ERROR_OK;
-}
-
-static int cortex_a9_disable_mmu_caches(struct target *target, int mmu,
-                int d_u_cache, int i_cache)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	uint32_t cp15_control;
-	int retval;
-
-	/* read cp15 control register */
-	retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			&amp;cp15_control);
-	if (retval != ERROR_OK)
-		return retval;
-
-
-	if (mmu)
-		cp15_control &amp;= ~0x1U;
-
-	if (d_u_cache)
-		cp15_control &amp;= ~0x4U;
-
-	if (i_cache)
-		cp15_control &amp;= ~0x1000U;
-
-	retval = armv7a-&gt;armv4_5_common.mcr(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			cp15_control);
-	return retval;
-}
-
-static int cortex_a9_enable_mmu_caches(struct target *target, int mmu,
-		int d_u_cache, int i_cache)
-{
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	uint32_t cp15_control;
-	int retval;
-
-	/* read cp15 control register */
-	retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			&amp;cp15_control);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (mmu)
-		cp15_control |= 0x1U;
-
-	if (d_u_cache)
-		cp15_control |= 0x4U;
-
-	if (i_cache)
-		cp15_control |= 0x1000U;
-
-	retval = armv7a-&gt;armv4_5_common.mcr(target, 15,
-			0, 0,   /* op1, op2 */
-			1, 0,   /* CRn, CRm */
-			cp15_control);
-	return retval;
-}
-
-
-static int cortex_a9_mmu(struct target *target, int *enabled)
-{
-	if (target-&gt;state != TARGET_HALTED) {
-		LOG_ERROR(&quot;%s: target not halted&quot;, __func__);
-		return ERROR_TARGET_INVALID;
-	}
-
-	*enabled = target_to_cortex_a9(target)-&gt;armv7a_common.armv4_5_mmu.mmu_enabled;
-	return ERROR_OK;
-}
-
-static int cortex_a9_virt2phys(struct target *target,
-		uint32_t virt, uint32_t *phys)
-{
-	uint32_t cb;
-	struct cortex_a9_common *cortex_a9 = target_to_cortex_a9(target);
-	// struct armv7a_common *armv7a = &amp;cortex_a9-&gt;armv7a_common;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-    /* We assume that virtual address is separated
-       between user and kernel in Linux style:
-       0x00000000-0xbfffffff - User space
-       0xc0000000-0xffffffff - Kernel space */
-    if( virt &lt; 0xc0000000 ) /* Linux user space */
-        cortex_a9-&gt;current_address_mode = ARM_MODE_USR;
-    else /* Linux kernel */
-        cortex_a9-&gt;current_address_mode = ARM_MODE_SVC;
-	uint32_t ret;
-	int retval = armv4_5_mmu_translate_va(target,
-			&amp;armv7a-&gt;armv4_5_mmu, virt, &amp;cb, &amp;ret);
-	if (retval != ERROR_OK)
-		return retval;
-    /* Reset the flag. We don't want someone else to use it by error */
-    cortex_a9-&gt;current_address_mode = ARM_MODE_ANY;
-
-	*phys = ret;
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(cortex_a9_handle_cache_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	return armv4_5_handle_cache_info_command(CMD_CTX,
-			&amp;armv7a-&gt;armv4_5_mmu.armv4_5_cache);
-}
-
-
-COMMAND_HANDLER(cortex_a9_handle_dbginit_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	if (!target_was_examined(target))
-	{
-		LOG_ERROR(&quot;target not examined yet&quot;);
-		return ERROR_FAIL;
-	}
-
-	return cortex_a9_init_debug_access(target);
-}
-
-static const struct command_registration cortex_a9_exec_command_handlers[] = {
-	{
-		.name = &quot;cache_info&quot;,
-		.handler = cortex_a9_handle_cache_info_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;display information about target caches&quot;,
-	},
-	{
-		.name = &quot;dbginit&quot;,
-		.handler = cortex_a9_handle_dbginit_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;Initialize core debug&quot;,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-static const struct command_registration cortex_a9_command_handlers[] = {
-	{
-		.chain = arm_command_handlers,
-	},
-	{
-		.chain = armv7a_command_handlers,
-	},
-	{
-		.name = &quot;cortex_a9&quot;,
-		.mode = COMMAND_ANY,
-		.help = &quot;Cortex-A9 command group&quot;,
-		.chain = cortex_a9_exec_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-struct target_type cortexa9_target = {
-	.name = &quot;cortex_a9&quot;,
-
-	.poll = cortex_a9_poll,
-	.arch_state = armv7a_arch_state,
-
-	.target_request_data = NULL,
-
-	.halt = cortex_a9_halt,
-	.resume = cortex_a9_resume,
-	.step = cortex_a9_step,
-
-	.assert_reset = cortex_a9_assert_reset,
-	.deassert_reset = cortex_a9_deassert_reset,
-	.soft_reset_halt = NULL,
-
-	/* REVISIT allow exporting VFP3 registers ... */
-	.get_gdb_reg_list = arm_get_gdb_reg_list,
-
-	.read_memory = cortex_a9_read_memory,
-	.write_memory = cortex_a9_write_memory,
-	.bulk_write_memory = cortex_a9_bulk_write_memory,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
-	.add_breakpoint = cortex_a9_add_breakpoint,
-	.remove_breakpoint = cortex_a9_remove_breakpoint,
-	.add_watchpoint = NULL,
-	.remove_watchpoint = NULL,
-
-	.commands = cortex_a9_command_handlers,
-	.target_create = cortex_a9_target_create,
-	.init_target = cortex_a9_init_target,
-	.examine = cortex_a9_examine,
-
-	.read_phys_memory = cortex_a9_read_phys_memory,
-	.write_phys_memory = cortex_a9_write_phys_memory,
-	.mmu = cortex_a9_mmu,
-	.virt2phys = cortex_a9_virt2phys,
-};
diff --git a/src/target/cortex_a9.h b/src/target/cortex_a9.h
deleted file mode 100644
index 82f04f8..0000000
--- a/src/target/cortex_a9.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">lundin at mlu.mine.nu</A>                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Dirk Behme                                      *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dirk.behme at gmail.com</A> - copy from cortex_m3                            *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef CORTEX_A9_H
-#define CORTEX_A9_H
-
-#include &quot;armv7a.h&quot;
-
-#define CORTEX_A9_COMMON_MAGIC 0x411fc082
-
-#define CPUDBG_CPUID	0xD00
-#define CPUDBG_CTYPR	0xD04
-#define CPUDBG_TTYPR	0xD0C
-#define CPUDBG_LOCKACCESS 0xFB0
-#define CPUDBG_LOCKSTATUS 0xFB4
-
-#define BRP_NORMAL 0
-#define BRP_CONTEXT 1
-
-#define CORTEX_A9_PADDRDBG_CPU_SHIFT 13
-
-struct cortex_a9_brp
-{
-	int used;
-	int type;
-	uint32_t value;
-	uint32_t control;
-	uint8_t BRPn;
-};
-
-struct cortex_a9_common
-{
-	int common_magic;
-	struct arm_jtag jtag_info;
-
-	/* Context information */
-	uint32_t cpudbg_dscr;
-
-	/* Saved cp15 registers */
-	uint32_t cp15_control_reg;
-
-	/* Breakpoint register pairs */
-	int brp_num_context;
-	int brp_num;
-	int brp_num_available;
-	struct cortex_a9_brp *brp_list;
-
-	/* Use cortex_a9_read_regs_through_mem for fast register reads */
-	int fast_reg_read;
-
-	/* Flag that helps to resolve what ttb to use: user or kernel */
-	int current_address_mode;
-
-	struct armv7a_common armv7a_common;
-};
-
-static inline struct cortex_a9_common *
-target_to_cortex_a9(struct target *target)
-{
-	return container_of(target-&gt;arch_info, struct cortex_a9_common,
-			armv7a_common.armv4_5_common);
-}
-
-#endif /* CORTEX_A9_H */
diff --git a/src/target/target.c b/src/target/target.c
index 13d358d..00d4309 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -70,7 +70,6 @@ extern struct target_type dragonite_target;
 extern struct target_type xscale_target;
 extern struct target_type cortexm3_target;
 extern struct target_type cortexa8_target;
-extern struct target_type cortexa9_target;
 extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
@@ -93,7 +92,6 @@ static struct target_type *target_types[] =
 	&amp;xscale_target,
 	&amp;cortexm3_target,
 	&amp;cortexa8_target,
-	&amp;cortexa9_target,
 	&amp;arm11_target,
 	&amp;mips_m4k_target,
 	&amp;avr_target,

commit 6c5e1781a102424353bf237386e7443b2ce3e4d3
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Mar 21 14:13:09 2011 +0100

    omap4430: cortex a9 and a8 are now merged again
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
index 5bdb9d6..13ed80c 100644
--- a/tcl/target/omap4430.cfg
+++ b/tcl/target/omap4430.cfg
@@ -82,7 +82,7 @@ jtag configure $_CHIPNAME.jrc -event post-reset &quot;runtest 200&quot;
 # second core.
 #
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_a9 -chain-position $_CHIPNAME.dap -coreid 0
+target create $_TARGETNAME cortex_a8 -chain-position $_CHIPNAME.dap -coreid 0
 
 # SRAM: 56KiB at 0x4030.0000
 $_TARGETNAME configure -work-area-phys 0x40300000 -work-area-size 0x1000

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am  |    4 +-
 src/target/arm_adi_v5.c |    1 +
 src/target/cortex_a8.c  |  400 ++++++---
 src/target/cortex_a8.h  |    3 +-
 src/target/cortex_a9.c  | 2303 -----------------------------------------------
 src/target/cortex_a9.h  |   89 --
 src/target/target.c     |    2 -
 tcl/target/omap4430.cfg |    2 +-
 8 files changed, 291 insertions(+), 2513 deletions(-)
 delete mode 100644 src/target/cortex_a9.c
 delete mode 100644 src/target/cortex_a9.h


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002547.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-803-gec2b8d7
</A></li>
	<LI>Next message: <A HREF="002549.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-807-gdec80e1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2548">[ date ]</a>
              <a href="thread.html#2548">[ thread ]</a>
              <a href="subject.html#2548">[ subject ]</a>
              <a href="author.html#2548">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
