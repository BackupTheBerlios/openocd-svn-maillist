From gowinex at users.sourceforge.net  Thu Jul  1 09:34:11 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  1 Jul 2010 07:34:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-393-gdd88b46
Message-ID: <E1OUEHt-000853-70@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  dd88b461da1cb8642200dd5c96fb1ff384ca9f7b (commit)
       via  cd7f4431036355213f8d3daa12c95be978f9e64a (commit)
      from  2986320cde399b0b0ee006a4fecbdec83bebc248 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dd88b461da1cb8642200dd5c96fb1ff384ca9f7b
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Thu Jun 17 10:07:22 2010 +0200

    ft2232: simplify ft2232_read_scan

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index bc8463e..9d40b1c 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -714,23 +714,24 @@ static void ft2232_end_state(tap_state_t state)
 
 static void ft2232_read_scan(enum scan_type type, uint8_t* buffer, int scan_size)
 {
-	int num_bytes = (scan_size + 7) / 8;
-	int bits_left = scan_size;
-	int cur_byte  = 0;
+	int num_bytes = scan_size / 8;
+	int bits_left = scan_size % 8;
+	int cur_byte;
 
-	while (num_bytes-- > 1)
+	for (cur_byte = 0; cur_byte < num_bytes; cur_byte++)
 	{
-		buffer[cur_byte++] = buffer_read();
-		bits_left -= 8;
+		buffer[cur_byte] = buffer_read();
 	}
 
-	buffer[cur_byte] = 0x0;
-
-	/* There is one more partial byte left from the clock data in/out instructions */
+	/* Manage partial byte left from the clock data in/out instructions, if any */
 	if (bits_left > 1)
 	{
 		buffer[cur_byte] = buffer_read() >> 1;
 	}
+	else
+	{
+		buffer[cur_byte] = 0x0;
+	}
 	/* This shift depends on the length of the clock data to tms instruction, insterted at end of the scan, now fixed to a two step transition in ft2232_add_scan */
 	buffer[cur_byte] = (buffer[cur_byte] | (((buffer_read()) << 1) & 0x80)) >> (8 - bits_left);
 }

commit cd7f4431036355213f8d3daa12c95be978f9e64a
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Thu Jun 17 09:54:34 2010 +0200

    ft2232: cleanup ft2232_write
    
    * Include the size check into ft2232_write, so calling it is simpler.
    * Use sizeof(buffer) when possible

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 2ac410a..bc8463e 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -480,7 +480,6 @@ static int ft2232_write(uint8_t* buf, int size, uint32_t* bytes_written)
 	else
 	{
 		*bytes_written = dw_bytes_written;
-		return ERROR_OK;
 	}
 #elif BUILD_FT2232_LIBFTDI == 1
 	int retval;
@@ -493,9 +492,15 @@ static int ft2232_write(uint8_t* buf, int size, uint32_t* bytes_written)
 	else
 	{
 		*bytes_written = retval;
-		return ERROR_OK;
 	}
 #endif
+
+	if (*bytes_written != (uint32_t)size)
+	{
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+
+	return ERROR_OK;
 }
 
 static int ft2232_read(uint8_t* buf, uint32_t size, uint32_t* bytes_read)
@@ -569,8 +574,9 @@ static int ft2232h_ft4232h_adaptive_clocking(bool enable)
 	LOG_DEBUG("%2.2x", buf);
 
 	uint32_t bytes_written;
-	int retval = ft2232_write(&buf, 1, &bytes_written);
-	if ((ERROR_OK != retval) || (bytes_written != 1))
+	int retval;
+
+	if ((retval = ft2232_write(&buf, sizeof(buf), &bytes_written)) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't write command to %s adaptive clocking"
 			, enable ? "enable" : "disable");
@@ -589,8 +595,8 @@ static int ft2232h_ft4232h_clk_divide_by_5(bool enable)
 {
 	uint32_t bytes_written;
 	uint8_t buf = enable ?  0x8b : 0x8a;
-	int retval = ft2232_write(&buf, 1, &bytes_written);
-	if ((ERROR_OK != retval) || (bytes_written != 1))
+
+	if (ft2232_write(&buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't write command to %s clk divide by 5"
 			, enable ? "enable" : "disable");
@@ -627,7 +633,7 @@ static int ft2232_speed(int speed)
 	buf[2] = (speed >> 8) & 0xff;	/* valueH */
 
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
-	if (((retval = ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if ((retval = ft2232_write(buf, sizeof(buf), &bytes_written)) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't set FT2232 TCK speed");
 		return retval;
@@ -737,7 +743,7 @@ static void ft2232_debug_dump_buffer(void)
 
 	for (i = 0; i < ft2232_buffer_size; i++)
 	{
-		line_p += snprintf(line_p, 256 - (line_p - line), "%2.2x ", ft2232_buffer[i]);
+		line_p += snprintf(line_p, sizeof(line) - (line_p - line), "%2.2x ", ft2232_buffer[i]);
 		if (i % 16 == 15)
 		{
 			LOG_DEBUG("%s", line);
@@ -2369,7 +2375,7 @@ static int ft2232_init(void)
 	ft2232_speed(jtag_get_speed());
 
 	buf[0] = 0x85; /* Disconnect TDI/DO to TDO/DI for Loopback */
-	if (((retval = ft2232_write(buf, 1, &bytes_written)) != ERROR_OK) || (bytes_written != 1))
+	if ((retval = ft2232_write(buf, 1, &bytes_written)) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't write to FT2232 to disable loopback");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2431,7 +2437,7 @@ static int ftx232_init_tail(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 DBUS");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2517,7 +2523,7 @@ static int axm0432_jtag_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'JTAGkey' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2564,7 +2570,7 @@ static int axm0432_jtag_init(void)
 	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'Dicarlo' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2590,8 +2596,7 @@ static int redbee_init(void)
 	buf[1] = low_output;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK)
-			|| (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'redbee' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2630,8 +2635,7 @@ static int redbee_init(void)
 	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK)
-			|| (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'redbee' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2654,7 +2658,7 @@ static int jtagkey_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'JTAGkey' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2713,7 +2717,7 @@ static int jtagkey_init(void)
 	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'JTAGkey' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2736,7 +2740,7 @@ static int olimex_jtag_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'Olimex' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2780,7 +2784,7 @@ static int olimex_jtag_init(void)
 	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if ((ft2232_write(buf, 3, &bytes_written) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'Olimex' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2803,7 +2807,7 @@ static int flyswatter_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE[12]=out, n[ST]srst = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'flyswatter' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2826,7 +2830,7 @@ static int flyswatter_init(void)
 	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'flyswatter' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2849,7 +2853,7 @@ static int turtle_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'turtelizer2' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2866,7 +2870,7 @@ static int turtle_init(void)
 	buf[2] = high_direction;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'turtelizer2' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2889,7 +2893,7 @@ static int comstick_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'comstick' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2909,7 +2913,7 @@ static int comstick_init(void)
 	buf[2] = high_direction;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'comstick' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2932,7 +2936,7 @@ static int stm32stick_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'stm32stick' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2952,7 +2956,7 @@ static int stm32stick_init(void)
 	buf[2] = high_direction;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'stm32stick' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -2975,7 +2979,7 @@ static int sheevaplug_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'sheevaplug' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -3003,7 +3007,7 @@ static int sheevaplug_init(void)
 	buf[2] = high_direction;   /* all outputs - xRST */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'sheevaplug' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -3026,7 +3030,7 @@ static int cortino_jtag_init(void)
 	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'cortino' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -3046,7 +3050,7 @@ static int cortino_jtag_init(void)
 	buf[2] = high_direction;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'stm32stick' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -3341,7 +3345,7 @@ static int icebear_jtag_init(void) {
 	buf[2] = low_direction;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3)) {
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK) {
 		LOG_ERROR("couldn't initialize FT2232 with 'IceBear' layout (low)");
 		return ERROR_JTAG_INIT_FAILED;
 	}
@@ -3356,7 +3360,7 @@ static int icebear_jtag_init(void) {
 	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3)) {
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK) {
 		LOG_ERROR("couldn't initialize FT2232 with 'IceBear' layout (high)");
 		return ERROR_JTAG_INIT_FAILED;
 	}
@@ -4003,8 +4007,7 @@ static int signalyzer_h_init(void)
 	buf[1] = low_output;
 	buf[2] = low_direction;
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK)
-			|| (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize Signalyzer-H layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -4018,8 +4021,7 @@ static int signalyzer_h_init(void)
 		buf[1] = high_output;
 		buf[2] = high_direction;
 
-		if ((ft2232_write(buf, 3, &bytes_written) != ERROR_OK)
-				|| (bytes_written != 3))
+		if ((retval = ft2232_write(buf, sizeof(buf), &bytes_written)) != ERROR_OK)
 		{
 			LOG_ERROR("couldn't initialize Signalyzer-H layout");
 			return ERROR_JTAG_INIT_FAILED;
@@ -4033,8 +4035,7 @@ static int signalyzer_h_init(void)
 		buf[1] = high_output;
 		buf[2] = high_direction;
 
-		if ((ft2232_write(buf, 3, &bytes_written) != ERROR_OK)
-				|| (bytes_written != 3))
+		if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 		{
 			LOG_ERROR("couldn't initialize Signalyzer-H layout");
 			return ERROR_JTAG_INIT_FAILED;
@@ -4218,7 +4219,7 @@ static int ktlink_init(void)
 	buf[2] = low_direction;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'ktlink' layout");
 		return ERROR_JTAG_INIT_FAILED;
@@ -4256,7 +4257,7 @@ static int ktlink_init(void)
 	buf[2] = high_direction;
 	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
 
-	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 	{
 		LOG_ERROR("couldn't initialize FT2232 with 'ktlink' layout");
 		return ERROR_JTAG_INIT_FAILED;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |  104 +++++++++++++++++++++++----------------------
 1 files changed, 53 insertions(+), 51 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Jul  1 20:44:44 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu,  1 Jul 2010 18:44:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-394-gf97b6b5
Message-ID: <E1OUOkh-0004KT-FF@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f97b6b59abc878745bb54e8f44ec82897bacaf7d (commit)
      from  dd88b461da1cb8642200dd5c96fb1ff384ca9f7b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f97b6b59abc878745bb54e8f44ec82897bacaf7d
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Jul 1 19:43:58 2010 +0100

    ft2232: bugfix from previous commit
    
    fix build error with commit dd88b461da1cb8642200dd5c96fb1ff384ca9f7b
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 9d40b1c..90516a0 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -4022,7 +4022,7 @@ static int signalyzer_h_init(void)
 		buf[1] = high_output;
 		buf[2] = high_direction;
 
-		if ((retval = ft2232_write(buf, sizeof(buf), &bytes_written)) != ERROR_OK)
+		if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
 		{
 			LOG_ERROR("couldn't initialize Signalyzer-H layout");
 			return ERROR_JTAG_INIT_FAILED;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Jul  2 18:01:31 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri,  2 Jul 2010 16:01:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-395-gdeb176d
Message-ID: <E1OUigM-0008MR-8M@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  deb176d33514eb6b702b14043c338b2d0053f11d (commit)
      from  f97b6b59abc878745bb54e8f44ec82897bacaf7d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit deb176d33514eb6b702b14043c338b2d0053f11d
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jul 2 17:00:57 2010 +0100

    ft2232: revert ft2232_read_scan changes
    
    Revert change made in commit dd88b461da1cb8642200dd5c96fb1ff384ca9f7b.
    Caused segfaults when using ftdi driver under win32.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 90516a0..f315d69 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -714,24 +714,23 @@ static void ft2232_end_state(tap_state_t state)
 
 static void ft2232_read_scan(enum scan_type type, uint8_t* buffer, int scan_size)
 {
-	int num_bytes = scan_size / 8;
-	int bits_left = scan_size % 8;
-	int cur_byte;
+	int num_bytes = (scan_size + 7) / 8;
+	int bits_left = scan_size;
+	int cur_byte  = 0;
 
-	for (cur_byte = 0; cur_byte < num_bytes; cur_byte++)
+	while (num_bytes-- > 1)
 	{
-		buffer[cur_byte] = buffer_read();
+		buffer[cur_byte++] = buffer_read();
+		bits_left -= 8;
 	}
 
-	/* Manage partial byte left from the clock data in/out instructions, if any */
+	buffer[cur_byte] = 0x0;
+
+	/* There is one more partial byte left from the clock data in/out instructions */
 	if (bits_left > 1)
 	{
 		buffer[cur_byte] = buffer_read() >> 1;
 	}
-	else
-	{
-		buffer[cur_byte] = 0x0;
-	}
 	/* This shift depends on the length of the clock data to tms instruction, insterted at end of the scan, now fixed to a two step transition in ft2232_add_scan */
 	buffer[cur_byte] = (buffer[cur_byte] | (((buffer_read()) << 1) & 0x80)) >> (8 - bits_left);
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |   19 +++++++++----------
 1 files changed, 9 insertions(+), 10 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Jul  2 22:52:47 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  2 Jul 2010 20:52:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-396-g93f2afa
Message-ID: <E1OUnEC-0003EC-SJ@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  93f2afa45f4cfcb8afd08dae5a17996dba5c7a9c (commit)
      from  deb176d33514eb6b702b14043c338b2d0053f11d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 93f2afa45f4cfcb8afd08dae5a17996dba5c7a9c
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Jul 2 16:45:28 2010 -0400

    initial "transport" framework
    
    This adds the guts of a transport framework with initialization,
    which should work with current JTAG-only configurations (tested
    with FT2232).
    
    Each debug adapter can declare the transports it supports, and
    exactly one transport is initialized.  (with its commands) in
    any given OpenOCD session.
    
      * Define a new "struct transport with init hooks and a few
     "transport"  subcommands to support it:
    
         "list" ... list the transports configured (just "jtag" for now)
         "select" ... makes the debug session use that transport
         "init" ... initializes the selected transport (internal)
    
      * "interface_transports" ... declares transports the current interface
        can support.  (Some will do this from C code instead, when there are
        no hardware versioning (or other) issues to prevent it.
    
    Plus some FT2232 tweaks, including a few to streamline upcoming
    support for an SWD transport (initially for Luminary adapters).
    
    Eventually src/jtag should probably become src/transport, moving
    jtag-specific stuff  to transport/jtag.
    
    Signed-off-by: David Brownell <db at helium.(none)>

diff --git a/NEWS b/NEWS
index db4485d..2dd14cc 100644
--- a/NEWS
+++ b/NEWS
@@ -17,6 +17,9 @@ JTAG Layer:
 
 Boundary Scan:
 
+Transport framework core ... supporting future work for SWD, SPI, and other
+non-JTAG ways to debug targets or program flash.
+
 Target Layer:
 	ARM:
 		- basic semihosting support (ARMv7M).
diff --git a/doc/openocd.texi b/doc/openocd.texi
index a3ca124..a765727 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2096,6 +2096,14 @@ target.
 List the debug adapter drivers that have been built into
 the running copy of OpenOCD.
 @end deffn
+ at deffn Command {interface transports} transport_name+
+Specifies the transports supported by this debug adapter.
+The adapter driver builds-in similar knowledge; use this only
+when external configuration (such as jumpering) changes what
+the hardware can support.
+ at end deffn
+
+
 
 @deffn Command {adapter_name}
 Returns the name of the debug adapter driver being used.
@@ -2428,7 +2436,41 @@ Turn power switch to target on/off.
 No arguments: print status.
 @end deffn
 
- at end deffn
+ at section Transport Configuration
+As noted earlier, depending on the version of OpenOCD you use,
+and the debug adapter you are using,
+several transports may be available to
+communicate with debug targets (or perhaps to program flash memory).
+ at deffn Command {transport list}
+displays the names of the transports supported by this
+version of OpenOCD.
+ at end deffn
+
+ at deffn Command {transport select} transport_name
+Select which of the supported transports to use in this OpenOCD session.
+The transport must be supported by the debug adapter hardware  and by the
+version of OPenOCD you are using (including the adapter's driver).
+No arguments: print selected transport..
+ at end deffn
+
+ at subsection JTAG Transport
+JTAG is the original transport supported by OpenOCD, and most
+of the OpenOCD commands support it.
+JTAG transports expose a chain of one or more Test Access Points (TAPs),
+each of which must be explicitly declared.
+JTAG supports both debugging and boundary scan testing.
+Flash programming support is built on top of debug support.
+ at subsection SWD ransport
+SWD (Serial Wire Debug) is an ARM-specific transport which exposes one
+Debug Access Point (DAP, which must be explicitly declared.
+(SWD uses fewer signal wires than JTAG.)
+SWD is debug-oriented, and does not support  boundary scan testing.
+Flash programming support is built on top of debug support.
+(Some processors support both JTAG and SWD.)
+ at subsection SPI ransport
+The Serial Peripheral Interface (SPI) is a general purpose transport
+which uses four wire signaling.  Some processors use it as part of a
+solution for flash programming.
 
 @anchor{JTAG Speed}
 @section JTAG Speed
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 910affc..59cd8ff 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -58,6 +58,7 @@ libjtag_la_SOURCES = \
 	interface.c \
 	interfaces.c \
 	tcl.c \
+	transport.c \
 	$(DRIVERFILES)
 
 noinst_HEADERS = \
@@ -67,6 +68,7 @@ noinst_HEADERS = \
 	interfaces.h \
 	minidriver.h \
 	jtag.h \
+	transport.h \
 	minidriver/minidriver_imp.h \
 	minidummy/jtag_minidriver.h
 
diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index 50e2a02..15b3ddc 100644
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -35,6 +35,7 @@
 #include "minidriver.h"
 #include "interface.h"
 #include "interfaces.h"
+#include "transport.h"
 
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
@@ -92,6 +93,25 @@ static int default_srst_asserted(int *srst_asserted)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(interface_transport_command)
+{
+	char **transports;
+	int retval;
+
+	retval = CALL_COMMAND_HANDLER(transport_list_parse, &transports);
+	if (retval != ERROR_OK) {
+		return retval;
+
+	retval = allow_transports(CMD_CTX, (const char **)transports);
+	if (retval != ERROR_OK) {
+		for (unsigned i = 0; transports[i]; i++)
+			free(transports[i]);
+		free(transports);
+	}
+	}
+	return retval;
+}
+
 COMMAND_HANDLER(handle_interface_list_command)
 {
 	if (strcmp(CMD_NAME, "interface_list") == 0 && CMD_ARGC > 0)
@@ -452,6 +472,13 @@ static const struct command_registration interface_command_handlers[] = {
 		.usage = "driver_name",
 	},
 	{
+		.name = "interface_transports",
+		.handler = interface_transport_command,
+		.mode = COMMAND_CONFIG,
+		.help = "Declare transports the interface supports.",
+		.usage = "transport ... ",
+	},
+	{
 		.name = "interface_list",
 		.handler = handle_interface_list_command,
 		.mode = COMMAND_ANY,
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 782f10f..1643d9b 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -33,11 +33,15 @@
 
 #include "jtag.h"
 #include "interface.h"
+#include "transport.h"
 
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
 #endif
 
+/* SVF and XSVF are higher level JTAG command sets (for boundary scan) */
+#include "svf/svf.h"
+#include "xsvf/xsvf.h"
 
 /// The number of JTAG queue flushes (for profiling and debugging purposes).
 static int jtag_flush_queue_count;
@@ -1348,6 +1352,21 @@ int adapter_init(struct command_context *cmd_ctx)
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
+	/* LEGACY SUPPORT ... adapter drivers  must declare what
+	 * transports they allow.  Until they all do so, assume
+	 * the legacy drivers are JTAG-only
+	 */
+	if (!transports_are_declared()) {
+		static const char *jtag_only[] = { "jtag", NULL, };
+		LOG_ERROR("Adapter driver '%s' did not declare "
+			"which transports it allows; assuming"
+			"JTAG-only", jtag->name);
+		int retval = allow_transports(cmd_ctx, jtag_only);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+
 	int requested_khz = jtag_get_speed_khz();
 	int actual_khz = requested_khz;
 	int retval = jtag_get_speed_readable(&actual_khz);
@@ -1706,3 +1725,45 @@ unsigned jtag_get_ntrst_assert_width(void)
 {
 	return jtag_ntrst_assert_width;
 }
+
+static int jtag_select(struct command_context *ctx)
+{
+	int retval;
+
+	/* NOTE:  interface init must already have been done.
+	 * That works with only C code ... no Tcl glue required.
+	 */
+
+
+	retval = jtag_register_commands(ctx);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = svf_register_commands(ctx);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	return xsvf_register_commands(ctx);
+}
+
+static struct transport jtag_transport = {
+	.name = "jtag",
+	.select = jtag_select,
+	.init = jtag_init,
+};
+
+static void jtag_constructor(void) __attribute__((constructor));
+static void jtag_constructor(void)
+{
+	transport_register(&jtag_transport);
+}
+
+/** Returns true if the current debug session
+ * is using JTAG as its transport.
+ */
+bool transport_is_jtag(void)
+{
+	return get_current_transport() == &jtag_transport;
+}
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index f315d69..f02ae62 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -81,6 +81,7 @@
 
 /* project specific includes */
 #include <jtag/interface.h>
+#include <jtag/transport.h>
 #include <helper/time_support.h>
 
 #if IS_CYGWIN == 1
@@ -167,6 +168,7 @@ struct ft2232_layout {
 	void (*reset)(int trst, int srst);
 	void (*blink)(void);
 	int channel;
+	const char **transports;
 };
 
 /* init procedures for supported layouts */
@@ -210,6 +212,13 @@ static void turtle_jtag_blink(void);
 static void signalyzer_h_blink(void);
 static void ktlink_blink(void);
 
+/* common transport support options */
+static const char *jtag_only[] = { "jtag", NULL };
+
+
+//static const char *jtag_and_swd[] = { "jtag", "swd", NULL };
+#define jtag_and_swd NULL
+
 static const struct ft2232_layout  ft2232_layouts[] =
 {
 	{ .name = "usbjtag",
@@ -235,10 +244,12 @@ static const struct ft2232_layout  ft2232_layouts[] =
 	{ .name = "evb_lm3s811",
 		.init = lm3s811_jtag_init,
 		.reset = ftx23_reset,
+		.transports = jtag_and_swd,
 	},
 	{ .name = "luminary_icdi",
 		.init = icdi_jtag_init,
 		.reset = ftx23_reset,
+		.transports = jtag_and_swd,
 	},
 	{ .name = "olimex-jtag",
 		.init = olimex_jtag_init,
@@ -2393,7 +2404,7 @@ static int ft2232_init(void)
 /** Updates defaults for DBUS signals:  the four JTAG signals
  * (TCK, TDI, TDO, TMS) and * the four GPIOL signals.
  */
-static inline void ftx232_init_head(void)
+static inline void ftx232_dbus_init(void)
 {
 	low_output    = 0x08;
 	low_direction = 0x0b;
@@ -2403,7 +2414,7 @@ static inline void ftx232_init_head(void)
  * the four GPIOL signals.  Initialization covers value and direction,
  * as customized for each layout.
  */
-static int ftx232_init_tail(void)
+static int ftx232_dbus_write(void)
 {
 	uint8_t  buf[3];
 	uint32_t bytes_written;
@@ -2452,19 +2463,19 @@ static int usbjtag_init(void)
 	 * NOTE:  This is now _specific_ to the "usbjtag" layout.
 	 * Don't try cram any more layouts into this.
 	 */
-	ftx232_init_head();
+	ftx232_dbus_init();
 
 	nTRST    = 0x10;
 	nTRSTnOE = 0x10;
 	nSRST    = 0x40;
 	nSRSTnOE = 0x40;
 
-	return ftx232_init_tail();
+	return ftx232_dbus_write();
 }
 
 static int lm3s811_jtag_init(void)
 {
-	ftx232_init_head();
+	ftx232_dbus_init();
 
 	/* There are multiple revisions of LM3S811 eval boards:
 	 * - Rev B (and older?) boards have no SWO trace support.
@@ -2478,12 +2489,12 @@ static int lm3s811_jtag_init(void)
 	low_output    = 0x88;
 	low_direction = 0x8b;
 
-	return ftx232_init_tail();
+	return ftx232_dbus_write();
 }
 
 static int icdi_jtag_init(void)
 {
-	ftx232_init_head();
+	ftx232_dbus_init();
 
 	/* Most Luminary eval boards support SWO trace output,
 	 * and should use this "luminary_icdi" layout.
@@ -2495,18 +2506,18 @@ static int icdi_jtag_init(void)
 	low_output    = 0x88;
 	low_direction = 0xcb;
 
-	return ftx232_init_tail();
+	return ftx232_dbus_write();
 }
 
 static int signalyzer_init(void)
 {
-	ftx232_init_head();
+	ftx232_dbus_init();
 
 	nTRST    = 0x10;
 	nTRSTnOE = 0x10;
 	nSRST    = 0x20;
 	nSRSTnOE = 0x20;
-	return ftx232_init_tail();
+	return ftx232_dbus_write();
 }
 
 static int axm0432_jtag_init(void)
@@ -3195,7 +3206,11 @@ COMMAND_HANDLER(ft2232_handle_layout_command)
 	for (const struct ft2232_layout *l = ft2232_layouts; l->name; l++) {
 		if (strcmp(l->name, CMD_ARGV[0]) == 0) {
 			layout = l;
-			return ERROR_OK;
+			/* This may also select the transport
+			 * if we only suppport one of them.
+			 */
+			return allow_transports(CMD_CTX,
+				l->transports ? : jtag_only);
 		}
 	}
 
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 97ceb01..3b0a145 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -689,4 +689,6 @@ void jtag_poll_set_enabled(bool value);
  * level APIs that are used in inner loops. */
 #include <jtag/minidriver.h>
 
+bool transport_is_jtag(void);
+
 #endif /* JTAG_H */
diff --git a/src/jtag/transport.c b/src/jtag/transport.c
new file mode 100644
index 0000000..cee8ffb
--- /dev/null
+++ b/src/jtag/transport.c
@@ -0,0 +1,373 @@
+/*
+ * Copyright (c) 2010 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+/** @file
+ * Infrastructure for specifying and managing the transport protocol
+ * used in a given debug or programming session.
+ *
+ * Examples of "debug-capable" transports are JTAG or SWD.
+ * Additionally, JTAG supports boundary scan testing.
+ *
+ * Examples of "programming-capable" transports include SPI or UART;
+ * those are used (often mediated by a ROM bootloader) for ISP style
+ * programming, to perform an initial load of code into flash, or
+ * sometimes into SRAM.  Target code could use "variant" options to
+ * decide how to use such protocols.  For example, Cortex-M3 cores
+ * from TI/Luminary and from NXP use different protocols for for
+ * UART or SPI based firmware loading.
+ *
+ * As a rule, there are protocols layered on top of the transport.
+ * For example, different chip families use JTAG in different ways
+ * for debugging.  Also, each family that supports programming over
+ * a UART link for initial firmware loading tends to define its own
+ * messaging and error handling.
+ */
+
+#include <helper/log.h>
+
+#include "transport.h"
+
+/*-----------------------------------------------------------------------*/
+
+/*
+ * Infrastructure internals
+ */
+
+/** List of transports known to OpenOCD. */
+static struct transport *transport_list;
+
+/**
+ * NULL-terminated Vector of names of transports which the
+ * currently selected debug adapter supports.  This is declared
+ * by the time that adapter is fully set up.
+ */
+static const char **allowed_transports;
+
+/** * The transport being used for the current OpenOCD session.  */
+static struct transport *session;
+
+static  int transport_select(struct command_context *ctx, const char *name)
+{
+	/* name may only identify a known transport;
+	 * caller guarantees session's transport isn't yet set.*/
+	for (struct transport *t = transport_list; t; t = t->next) {
+			if (strcmp(t->name, name) == 0) {
+				int retval = t->select(ctx);
+			/* select() registers commands specific to this
+			 * transport, and may also reset the link, e.g.
+			 * forcing it to JTAG or SWD mode.
+			 */
+			if (retval == ERROR_OK)
+				session = t;
+			else
+				LOG_ERROR("Error %d selecting '%s' as "
+					"transport", retval, t->name);
+			return retval;
+		}
+	}
+
+	LOG_ERROR("No transport named '%s' is available.", name);
+	return ERROR_FAIL;
+}
+
+/**
+ * Called by debug adapter drivers, or affiliated Tcl config scripts,
+ * to declare the set of transports supported by an adapter.  When
+ * there is only one member of that set, it is automatically selected.
+ */
+int allow_transports(struct command_context *ctx, const char **vector)
+{
+	/* NOTE:  caller is required to provide only a list
+	 * of *valid* transport names
+	 *
+	 * REVISIT should we validate that?  and insist there's
+	 * at least one non-NULL element in that list?
+	 */
+	if (allowed_transports != NULL || session) {
+		LOG_ERROR("Can't modify the set of allowed transports.");
+		return ERROR_FAIL;
+	}
+
+
+	allowed_transports = vector;
+
+	/* autoselect if there's no choice ... */
+	if (!vector[1]) {
+		LOG_INFO("only one transport option; autoselect '%s'",
+				vector[0]);
+		return transport_select(ctx, vector [0]);
+	} else {
+		while (*vector)
+			LOG_DEBUG("allow transport '%s'", *vector++);
+		return ERROR_OK;
+	}
+}
+
+
+/**
+ * Used to verify corrrect adapter driver initialization.
+ *
+ * @returns true iff the adapter declared one or more transports.
+ */
+bool transports_are_declared(void)
+{
+	return allowed_transports != NULL;
+}
+
+/**
+ * Registers a transport.  There are general purpose transports
+ * (such as JTAG), as well as relatively proprietary ones which are
+ * specific to a given chip (or chip family).
+ *
+ * Code implementing a transport needs to register it before it can
+ * be selected and then activated.  This is a dynamic process, so
+ * that chips (and families) can define transports as needed (without
+ * nneeding error-prone static tables).
+ *
+ * @param new_transport the transport being registered.  On a
+ * successful return, this memory is owned by the transport framework.
+ *
+ * @returns ERROR_OK on success, else a fault code.
+ */
+int transport_register(struct transport *new_transport)
+{
+	struct transport *t;
+
+	for (t = transport_list; t; t = t->next) {
+		if (strcmp(t->name, new_transport->name) == 0) {
+			LOG_ERROR("transport name already used");
+			return ERROR_FAIL;
+		}
+	}
+
+	if (!new_transport->select || !new_transport->init) {
+		LOG_ERROR("invalid transport %s", new_transport->name);
+	}
+
+	/* splice this into the list */
+	new_transport->next = transport_list;
+	transport_list = new_transport;
+	LOG_DEBUG("register '%s'", t->name);
+
+	return ERROR_OK;
+}
+
+/**
+ * Returns the transport currently being used by this debug or
+ * programming session.
+ *
+ * @returns handle to the read-only transport entity.
+ */
+struct transport *get_current_transport(void)
+{
+
+	/* REVISIT -- constify */
+	return session;
+}
+
+
+/*-----------------------------------------------------------------------*/
+
+/*
+ * Infrastructure for Tcl interface to transports.
+ */
+
+/**
+ * Makes and stores a copy of a set of transports passed as
+ * parameters to a command.
+ *
+ * @param vector where the resulting copy is stored, as an argv-style
+ *	NULL-terminated vector.
+ */
+COMMAND_HELPER(transport_list_parse, char ***vector)
+{
+	char **argv;
+	unsigned n = CMD_ARGC;
+	unsigned j = 0;
+
+	*vector = NULL;
+
+	if (n < 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	/* our return vector must be NULL terminated */
+	argv = (char **) calloc(n + 1, sizeof(char *));
+	if (argv == NULL)
+		return ERROR_FAIL;
+
+	for (unsigned i = 0; i < n; i++) {
+		struct transport *t;
+
+		for (t = transport_list; t; t = t->next) {
+			if (strcmp(t->name, CMD_ARGV[i]) != 0)
+				continue;
+			argv[j++] = strdup(CMD_ARGV[i]);
+			break;
+		}
+		if (!t) {
+			LOG_ERROR("no such transport '%s'", CMD_ARGV[i]);
+			goto fail;
+		}
+	}
+
+	*vector = argv;
+	return ERROR_OK;
+
+fail:
+	for (unsigned i = 0; i < n; i++)
+		free(argv[i]);
+	free(argv);
+	return ERROR_FAIL;
+}
+
+COMMAND_HANDLER(handle_transport_init)
+{
+	LOG_DEBUG("%s", __func__);
+	if (!session) {
+		LOG_ERROR("session's transport is not selected.");
+		return ERROR_FAIL;
+	}
+
+	return session->init(CMD_CTX);
+}
+
+COMMAND_HANDLER(handle_transport_list)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	command_print(CMD_CTX, "The following transports are available:");
+
+	for (struct transport *t = transport_list; t; t = t->next)
+		command_print(CMD_CTX, "\t%s", t->name);
+
+	return ERROR_OK;
+}
+
+/**
+ * Implements the Tcl "transport select" command, choosing the
+ * transport to be used in this debug session from among the
+ * set supported by the debug adapter being used.
+ */
+COMMAND_HANDLER(handle_transport_select)
+{
+	int retval = ERROR_OK;;
+
+	switch (CMD_ARGC) {
+	case 0:			/* "select" */
+		if (session) {
+			goto show;
+		}
+		LOG_ERROR("session's transport is not selected.");
+		return ERROR_FAIL;
+
+	case 1:			/* "select FOO" */
+		if(strcmp(session->name, CMD_ARGV[0]) == 0) {
+			/* NOP */
+			LOG_DEBUG("transport '%s' is already selected",
+					CMD_ARGV[0]);
+			return ERROR_OK;
+		} else {
+
+		/* we can't change this session's transport after-the-fact */
+		if (session) {
+			LOG_ERROR("session's transport is already selected.");
+			return ERROR_FAIL;
+		}
+		}
+		break;
+
+	default:		/* select FOO BAR */
+		/* we only select *one* transport per session */
+		LOG_ERROR("may only select one transport!");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Is this transport supported by our debug adapter?
+	 * Example, "JTAG-only" means SWD is not supported.
+	 *
+	 * NOTE:  requires adapter to have been set up, including
+	 * declaring transport via C code or Tcl script.
+	 */
+	if (!allowed_transports) {
+		LOG_ERROR("Debug adapter doesn't support any transports?");
+		return ERROR_FAIL;
+	}
+	for (unsigned i = 0; allowed_transports[i]; i++) {
+
+		if (strcmp(allowed_transports[i], CMD_ARGV[0]) == 0)
+			return transport_select(CMD_CTX, CMD_ARGV[0]);
+	}
+
+	LOG_ERROR("Debug adapter doesn't support '%s' "
+			"transport?", CMD_ARGV[0]);
+	return ERROR_FAIL;
+
+
+show:
+	/* report the current transport selection */
+	command_print(CMD_CTX, "%s", session->name);
+	return retval;
+}
+
+static const struct command_registration transport_commands[] = {
+	{
+		.name = "init",
+		.handler = handle_transport_init,
+		/* this would be COMMAND_CONFIG ... except that
+		 * it needs to trigger event handlers that may
+		 * require COMMAND_EXEC ...
+		 */
+		.mode = COMMAND_ANY,
+		.help = "Initialize this session's transport",
+	},
+	{
+		.name = "list",
+		.handler = handle_transport_list,
+		.mode = COMMAND_ANY,
+		.help = "list all built-in transports",
+	},
+	{
+		.name = "select",
+		.handler = handle_transport_select,
+		.mode = COMMAND_ANY,
+		.help = "Select this session's transport",
+		.usage = "[transport_name]",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration transport_group[] = {
+	{
+		.name = "transport",
+		.mode = COMMAND_ANY,
+		.help = "Transport command group",
+		.chain = transport_commands,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+
+int transport_register_commands(struct command_context *ctx)
+{
+	return register_commands(ctx, NULL, transport_group);
+}
diff --git a/src/jtag/transport.h b/src/jtag/transport.h
new file mode 100644
index 0000000..d2d38ec
--- /dev/null
+++ b/src/jtag/transport.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2010 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "helper/command.h"
+
+/**
+ * Wrapper for transport lifecycle operations.
+ *
+ * OpenOCD talks to targets through some kind of debugging
+ * or programming adapter, using some protocol that probably
+ * has target-specific aspects.
+ *
+ * A "transport" reflects electrical protocol to the target,
+ * e..g jtag, swd, spi, uart, ... NOT the messaging protocols
+ * layered over it (e.g. JTAG has eICE, CoreSight, Nexus, OnCE,
+ * and more).
+ *
+ * In addition to the lifecycle operations packaged by this
+ * structure, a transport also involves  an interface supported
+ * by debug adapters and used by components such as debug targets.
+ * For non-debug transports,  there may be interfaces used to
+ * write to flash chips.
+ */
+struct transport {
+	/**
+	 * Each transport has a unique name, used to select it
+	 * from among the alternatives.  Examples might include
+	 * "jtag", * "swd", "AVR_ISP" and more.
+	 */
+	const char *name;
+
+	/**
+	 * When a transport is selected, this method registers
+	 * its commands and activates the transport (e.g. resets
+	 * the link).
+	 *
+	 * After those commands are registered, they will often
+	 * be used for further configuration of the debug link.
+	 */
+	int (*select)(struct command_context *ctx);
+
+	/**
+	 * server startup uses this method to validate transport
+	 * configuration.  (For example, with JTAG this interrogates
+	 * the scan chain against the list of expected TAPs.)
+	 */
+	int (*init)(struct command_context *ctx);
+
+	/**
+	 * Transports are stored in a singly linked list.
+	 */
+	struct transport *next;
+};
+
+int transport_register(struct transport *new_transport);
+
+struct transport *get_current_transport(void);
+
+int transport_register_commands(struct command_context *ctx);
+
+COMMAND_HELPER(transport_list_parse, char ***vector);
+
+int allow_transports(struct command_context *ctx, const char **vector);
+
+bool transports_are_declared(void);
diff --git a/src/openocd.c b/src/openocd.c
index 96de50c..bba1e0b 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -31,10 +31,9 @@
 #include "openocd.h"
 #include <jtag/driver.h>
 #include <jtag/jtag.h>
+#include <jtag/transport.h>
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
-#include <xsvf/xsvf.h>
-#include <svf/svf.h>
 #include <flash/nor/core.h>
 #include <flash/nand/core.h>
 #include <pld/pld.h>
@@ -120,22 +119,24 @@ COMMAND_HANDLER(handle_init_command)
 		/* we must be able to set up the debug adapter */
 		return retval;
 	}
+
 	LOG_DEBUG("Debug Adapter init complete");
 
-	/* Try to initialize & examine the JTAG chain at this point,
-	 * but continue startup regardless.  Note that platforms
-	 * need to be able to provide JTAG event handlers that use
-	 * a variety of JTAG operations in order to do that...
+	/* "transport init" verifies the expected devices are present;
+	 * for JTAG, it checks the list of configured TAPs against
+	 * what's discoverable, possibly with help from the platform's
+	 * JTAG event handlers.  (which require COMMAND_EXEC)
 	 */
 	command_context_mode(CMD_CTX, COMMAND_EXEC);
-	if (command_run_line(CMD_CTX, "jtag init") == ERROR_OK)
-	{
-		LOG_DEBUG("Examining targets...");
-		if (target_examine() != ERROR_OK)
-			LOG_DEBUG("target examination failed");
-	}
-	else
-		LOG_WARNING("jtag initialization failed; try 'jtag init' again.");
+
+	retval = command_run_line(CMD_CTX, "transport init");
+	if (ERROR_OK != retval)
+		return ERROR_FAIL;
+
+	LOG_DEBUG("Examining targets...");
+	if (target_examine() != ERROR_OK)
+		LOG_DEBUG("target examination failed");
+
 	command_context_mode(CMD_CTX, COMMAND_CONFIG);
 
 	if (command_run_line(CMD_CTX, "flash init") != ERROR_OK)
@@ -227,16 +228,13 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 		&server_register_commands,
 		&gdb_register_commands,
 		&log_register_commands,
+		&transport_register_commands,
 		&interface_register_commands,
-		&jtag_register_commands,
-		&xsvf_register_commands,
-		&svf_register_commands,
 		&target_register_commands,
 		&flash_register_commands,
 		&nand_register_commands,
 		&pld_register_commands,
 		&mflash_register_commands,
-		NULL
 	};
 	for (unsigned i = 0; NULL != command_registrants[i]; i++)
 	{

-----------------------------------------------------------------------

Summary of changes:
 NEWS                      |    3 +
 doc/openocd.texi          |   42 +++++
 src/jtag/Makefile.am      |    2 +
 src/jtag/adapter.c        |   27 ++++
 src/jtag/core.c           |   61 ++++++++
 src/jtag/drivers/ft2232.c |   37 +++--
 src/jtag/jtag.h           |    2 +
 src/jtag/transport.c      |  373 +++++++++++++++++++++++++++++++++++++++++++++
 src/jtag/transport.h      |   80 ++++++++++
 src/openocd.c             |   34 ++---
 10 files changed, 632 insertions(+), 29 deletions(-)
 create mode 100644 src/jtag/transport.c
 create mode 100644 src/jtag/transport.h


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Jul  2 23:17:47 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  2 Jul 2010 21:17:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-397-gdb8b99a
Message-ID: <E1OUncL-0002DB-6K@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  db8b99aed6b4e6c046bf51853dacd8d511607984 (commit)
      from  93f2afa45f4cfcb8afd08dae5a17996dba5c7a9c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit db8b99aed6b4e6c046bf51853dacd8d511607984
Author: David Brownell <db at helium.(none)>
Date:   Fri Jul 2 17:14:52 2010 -0400

    Fix minor openocd.texi bug
    ::X
    Signed-off-by: David Brownell <db at helium.(none)>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index a765727..9feee03 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2425,6 +2425,7 @@ which are not currently documented here.
 
 @deffn {Interface Driver} {ZY1000}
 This is the Zylin ZY1000 JTAG debugger.
+ at end deffn
 
 @quotation Note
 This defines some driver-specific commands,

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jul  5 09:37:54 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  5 Jul 2010 07:37:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-398-g1e0f898
Message-ID: <E1OVgFZ-0005Rz-S7@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1e0f89841575de2b8b6313825ec8edd8bc7910a0 (commit)
      from  db8b99aed6b4e6c046bf51853dacd8d511607984 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1e0f89841575de2b8b6313825ec8edd8bc7910a0
Author: Stacey Sheldon <stac at solidgoldbomb.org>
Date:   Sun Jul 4 16:19:02 2010 -0400

    transport: fix segfault in setup_command_handler()
    
    Commit 93f2afa45f4c dropped the sentinel off the end
    of the command_registrants[] array.  The loop immediately
    following the initialization will walk right off the end.
    
    Signed-off-by: Stacey Sheldon <stac at solidgoldbomb.org>

diff --git a/src/openocd.c b/src/openocd.c
index bba1e0b..04a6307 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -235,6 +235,7 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 		&nand_register_commands,
 		&pld_register_commands,
 		&mflash_register_commands,
+		NULL
 	};
 	for (unsigned i = 0; NULL != command_registrants[i]; i++)
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Jul  5 18:14:12 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon,  5 Jul 2010 16:14:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-399-g3099858
Message-ID: <E1OVoJE-0002kj-PX@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3099858c68fd3a5f9960daea429198c0fc5a0f10 (commit)
      from  1e0f89841575de2b8b6313825ec8edd8bc7910a0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3099858c68fd3a5f9960daea429198c0fc5a0f10
Author: sb-sf <sb-sf at users.sourceforge.net>
Date:   Mon Jul 5 14:06:34 2010 +0100

    gdbserver: incorrect memory map for multiple targets (bug #24)
    
    The gdb server incorrectly reports the memory map if we have
    multiple targets with multiple flash banks.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index e97839d..1d1d836 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -1682,6 +1682,7 @@ static int gdb_memory_map(struct connection *connection,
 	char *separator;
 	uint32_t ram_start = 0;
 	int i;
+	int target_flash_banks = 0;
 
 	/* skip command character */
 	packet += 23;
@@ -1708,10 +1709,11 @@ static int gdb_memory_map(struct connection *connection,
 			gdb_error(connection, retval);
 			return retval;
 		}
-		banks[i] = p;
+		if(p->target == target)
+			banks[target_flash_banks++] = p;
 	}
 
-	qsort(banks, flash_get_bank_count(), sizeof(struct flash_bank *),
+	qsort(banks, target_flash_banks, sizeof(struct flash_bank *),
 			compare_bank);
 
 	for (i = 0; i < flash_get_bank_count(); i++) {

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c |    6 ++++--
 1 files changed, 4 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jul  7 17:35:52 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  7 Jul 2010 15:35:52 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-401-gdaa02f7
Message-ID: <E1OWWfD-0004x8-8S@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  daa02f7d84017f21c3ffa2be9997560d353a8829 (commit)
       via  ccaa9edf295e2c763c5a3c32a3f901b1637b99c5 (commit)
      from  3099858c68fd3a5f9960daea429198c0fc5a0f10 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit daa02f7d84017f21c3ffa2be9997560d353a8829
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jul 7 14:56:56 2010 +0200

    transport: fix segfault in transport select
    
    String compare against addresses in range 0 or so due
    to not checking if there was an active session first.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/transport.c b/src/jtag/transport.c
index cee8ffb..e431fee 100644
--- a/src/jtag/transport.c
+++ b/src/jtag/transport.c
@@ -281,18 +281,17 @@ COMMAND_HANDLER(handle_transport_select)
 		return ERROR_FAIL;
 
 	case 1:			/* "select FOO" */
-		if(strcmp(session->name, CMD_ARGV[0]) == 0) {
+		if ((session!= NULL) && strcmp(session->name, CMD_ARGV[0]) == 0) {
 			/* NOP */
 			LOG_DEBUG("transport '%s' is already selected",
 					CMD_ARGV[0]);
 			return ERROR_OK;
 		} else {
-
-		/* we can't change this session's transport after-the-fact */
-		if (session) {
-			LOG_ERROR("session's transport is already selected.");
-			return ERROR_FAIL;
-		}
+			/* we can't change this session's transport after-the-fact */
+			if (session) {
+				LOG_ERROR("session's transport is already selected.");
+				return ERROR_FAIL;
+			}
 		}
 		break;
 

commit ccaa9edf295e2c763c5a3c32a3f901b1637b99c5
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jul 7 14:31:07 2010 +0200

    transport: fix bug/typo in interface_transports command
    
    Classic manifestation of weakness of dangling {
    formatting :-) Hard to spot these sort of mistakes visually.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index 15b3ddc..37e6ee9 100644
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -101,14 +101,15 @@ COMMAND_HANDLER(interface_transport_command)
 	retval = CALL_COMMAND_HANDLER(transport_list_parse, &transports);
 	if (retval != ERROR_OK) {
 		return retval;
+	}
 
 	retval = allow_transports(CMD_CTX, (const char **)transports);
+
 	if (retval != ERROR_OK) {
 		for (unsigned i = 0; transports[i]; i++)
 			free(transports[i]);
 		free(transports);
 	}
-	}
 	return retval;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/adapter.c   |    3 ++-
 src/jtag/transport.c |   13 ++++++-------
 2 files changed, 8 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Jul  9 23:03:35 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri,  9 Jul 2010 21:03:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-402-gac5ad4a
Message-ID: <E1OXKjV-0001Yf-UO@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ac5ad4ad8d0312259974d4aeb947a43fa815c3a8 (commit)
      from  daa02f7d84017f21c3ffa2be9997560d353a8829 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ac5ad4ad8d0312259974d4aeb947a43fa815c3a8
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jul 9 22:02:52 2010 +0100

    transport: fix bug/typo in transport_register cmd
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 1643d9b..f7bbe8d 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1359,14 +1359,13 @@ int adapter_init(struct command_context *cmd_ctx)
 	if (!transports_are_declared()) {
 		static const char *jtag_only[] = { "jtag", NULL, };
 		LOG_ERROR("Adapter driver '%s' did not declare "
-			"which transports it allows; assuming"
+			"which transports it allows; assuming "
 			"JTAG-only", jtag->name);
 		int retval = allow_transports(cmd_ctx, jtag_only);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
-
 	int requested_khz = jtag_get_speed_khz();
 	int actual_khz = requested_khz;
 	int retval = jtag_get_speed_readable(&actual_khz);
@@ -1734,7 +1733,6 @@ static int jtag_select(struct command_context *ctx)
 	 * That works with only C code ... no Tcl glue required.
 	 */
 
-
 	retval = jtag_register_commands(ctx);
 
 	if (retval != ERROR_OK)
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index f02ae62..f06e13b 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -3207,7 +3207,7 @@ COMMAND_HANDLER(ft2232_handle_layout_command)
 		if (strcmp(l->name, CMD_ARGV[0]) == 0) {
 			layout = l;
 			/* This may also select the transport
-			 * if we only suppport one of them.
+			 * if we only support one of them.
 			 */
 			return allow_transports(CMD_CTX,
 				l->transports ? : jtag_only);
diff --git a/src/jtag/transport.c b/src/jtag/transport.c
index e431fee..cce45fb 100644
--- a/src/jtag/transport.c
+++ b/src/jtag/transport.c
@@ -166,7 +166,7 @@ int transport_register(struct transport *new_transport)
 	/* splice this into the list */
 	new_transport->next = transport_list;
 	transport_list = new_transport;
-	LOG_DEBUG("register '%s'", t->name);
+	LOG_DEBUG("register '%s'", new_transport->name);
 
 	return ERROR_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c           |    4 +---
 src/jtag/drivers/ft2232.c |    2 +-
 src/jtag/transport.c      |    2 +-
 3 files changed, 3 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Jul 10 00:35:06 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  9 Jul 2010 22:35:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-403-ge8445c9
Message-ID: <E1OXMA0-0008Eo-Sw@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e8445c9c9f02e82ea417776fa27fbe793ae22f83 (commit)
      from  ac5ad4ad8d0312259974d4aeb947a43fa815c3a8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e8445c9c9f02e82ea417776fa27fbe793ae22f83
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Jul 9 18:34:31 2010 -0400

    transport selection tweaks
    
    * Bugfix and simplify legacy jtag-only defaulting
    * Make "dummy" declare its jtag-only nature
    * likewise update ft2232
    * warn if selection is _required_ (multi-transport adapters),
    
    fixes the "only ft2232 works" bug for at least dummy, with
    other drivers going the "legacy" path (submit patches).
    
    Signed-off-by: David Brownell <db at helium.(none)>

diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index 37e6ee9..2d95e18 100644
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -93,6 +93,9 @@ static int default_srst_asserted(int *srst_asserted)
 	return ERROR_OK;
 }
 
+const char *jtag_only[] = { "jtag", NULL, };
+
+
 COMMAND_HANDLER(interface_transport_command)
 {
 	char **transports;
@@ -130,6 +133,8 @@ COMMAND_HANDLER(handle_interface_list_command)
 
 COMMAND_HANDLER(handle_interface_command)
 {
+	int retval;
+
 	/* check whether the interface is already configured */
 	if (jtag_interface)
 	{
@@ -148,7 +153,7 @@ COMMAND_HANDLER(handle_interface_command)
 
 		if (NULL != jtag_interfaces[i]->commands)
 		{
-			int retval = register_commands(CMD_CTX, NULL,
+			retval = register_commands(CMD_CTX, NULL,
 					jtag_interfaces[i]->commands);
 			if (ERROR_OK != retval)
 				return retval;
@@ -156,6 +161,20 @@ COMMAND_HANDLER(handle_interface_command)
 
 		jtag_interface = jtag_interfaces[i];
 
+	/* LEGACY SUPPORT ... adapter drivers  must declare what
+	 * transports they allow.  Until they all do so, assume
+	 * the legacy drivers are JTAG-only
+	 */
+	if (!jtag_interface->transports)
+		LOG_WARNING("Adapter driver '%s' did not declare "
+			"which transports it allows; assuming"
+			"legacy JTAG-only", jtag_interface->name);
+		retval = allow_transports(CMD_CTX,
+					jtag_interface->transports
+						? : jtag_only);
+			if (ERROR_OK != retval)
+				return retval;
+
 		if (jtag_interface->khz == NULL)
 			jtag_interface->khz = default_khz;
 		if (jtag_interface->speed_div == NULL)
@@ -171,7 +190,8 @@ COMMAND_HANDLER(handle_interface_command)
 	/* no valid interface was found (i.e. the configuration option,
 	 * didn't match one of the compiled-in interfaces
 	 */
-	LOG_ERROR("The specified debug interface was not found (%s)", CMD_ARGV[0]);
+	LOG_ERROR("The specified debug interface was not found (%s)",
+				CMD_ARGV[0]);
 	CALL_COMMAND_HANDLER(handle_interface_list_command);
 	return ERROR_JTAG_INVALID_INTERFACE;
 }
diff --git a/src/jtag/drivers/dummy.c b/src/jtag/drivers/dummy.c
index 7cb0e33..8b1e5ec 100644
--- a/src/jtag/drivers/dummy.c
+++ b/src/jtag/drivers/dummy.c
@@ -166,6 +166,7 @@ struct jtag_interface dummy_interface = {
 
 		.supported = DEBUG_CAP_TMS_SEQ,
 		.commands = dummy_command_handlers,
+		.transports = jtag_only,
 
 		.execute_queue = &bitbang_execute_queue,
 
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index f06e13b..bf71fa3 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -168,7 +168,6 @@ struct ft2232_layout {
 	void (*reset)(int trst, int srst);
 	void (*blink)(void);
 	int channel;
-	const char **transports;
 };
 
 /* init procedures for supported layouts */
@@ -213,11 +212,8 @@ static void signalyzer_h_blink(void);
 static void ktlink_blink(void);
 
 /* common transport support options */
-static const char *jtag_only[] = { "jtag", NULL };
-
 
 //static const char *jtag_and_swd[] = { "jtag", "swd", NULL };
-#define jtag_and_swd NULL
 
 static const struct ft2232_layout  ft2232_layouts[] =
 {
@@ -244,12 +240,10 @@ static const struct ft2232_layout  ft2232_layouts[] =
 	{ .name = "evb_lm3s811",
 		.init = lm3s811_jtag_init,
 		.reset = ftx23_reset,
-		.transports = jtag_and_swd,
 	},
 	{ .name = "luminary_icdi",
 		.init = icdi_jtag_init,
 		.reset = ftx23_reset,
-		.transports = jtag_and_swd,
 	},
 	{ .name = "olimex-jtag",
 		.init = olimex_jtag_init,
@@ -3206,11 +3200,7 @@ COMMAND_HANDLER(ft2232_handle_layout_command)
 	for (const struct ft2232_layout *l = ft2232_layouts; l->name; l++) {
 		if (strcmp(l->name, CMD_ARGV[0]) == 0) {
 			layout = l;
-			/* This may also select the transport
-			 * if we only support one of them.
-			 */
-			return allow_transports(CMD_CTX,
-				l->transports ? : jtag_only);
+			return ERROR_OK;
 		}
 	}
 
@@ -4372,6 +4362,7 @@ struct jtag_interface ft2232_interface = {
 	.name = "ft2232",
 	.supported = DEBUG_CAP_TMS_SEQ,
 	.commands = ft2232_command_handlers,
+	.transports = jtag_only,
 
 	.init = ft2232_init,
 	.quit = ft2232_quit,
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
index 0d47404..3226944 100644
--- a/src/jtag/interface.h
+++ b/src/jtag/interface.h
@@ -206,6 +206,9 @@ struct jtag_interface {
 	unsigned supported;
 #define DEBUG_CAP_TMS_SEQ	(1 << 0)
 
+	/** transports supported in C code (NULL terminated vector) */
+	const char **transports;
+
 	/**
 	 * Execute queued commands.
 	 * @returns ERROR_OK on success, or an error code on failure.
@@ -289,4 +292,6 @@ struct jtag_interface {
 };
 
 
+extern const char *jtag_only[];
+
 #endif // OPENOCD_JTAG_INTERFACE_H
diff --git a/src/jtag/transport.c b/src/jtag/transport.c
index cce45fb..d290bd2 100644
--- a/src/jtag/transport.c
+++ b/src/jtag/transport.c
@@ -101,6 +101,10 @@ int allow_transports(struct command_context *ctx, const char **vector)
 	 *
 	 * REVISIT should we validate that?  and insist there's
 	 * at least one non-NULL element in that list?
+	 *
+	 * ... allow removals, e.g. external strapping prevents use
+	 * of one transport; C code should be definitive about what
+	 * can be used when all goes well.
 	 */
 	if (allowed_transports != NULL || session) {
 		LOG_ERROR("Can't modify the set of allowed transports.");
@@ -116,6 +120,8 @@ int allow_transports(struct command_context *ctx, const char **vector)
 				vector[0]);
 		return transport_select(ctx, vector [0]);
 	} else {
+		/* guard against user config errors */
+		LOG_WARNING("must select a transport.");
 		while (*vector)
 			LOG_DEBUG("allow transport '%s'", *vector++);
 		return ERROR_OK;
@@ -304,13 +310,14 @@ COMMAND_HANDLER(handle_transport_select)
 	/* Is this transport supported by our debug adapter?
 	 * Example, "JTAG-only" means SWD is not supported.
 	 *
-	 * NOTE:  requires adapter to have been set up, including
-	 * declaring transport via C code or Tcl script.
+	 * NOTE:  requires adapter to have been set up, with
+	 * transports declared via C.
 	 */
 	if (!allowed_transports) {
 		LOG_ERROR("Debug adapter doesn't support any transports?");
 		return ERROR_FAIL;
 	}
+
 	for (unsigned i = 0; allowed_transports[i]; i++) {
 
 		if (strcmp(allowed_transports[i], CMD_ARGV[0]) == 0)

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/adapter.c        |   24 ++++++++++++++++++++++--
 src/jtag/drivers/dummy.c  |    1 +
 src/jtag/drivers/ft2232.c |   13 ++-----------
 src/jtag/interface.h      |    5 +++++
 src/jtag/transport.c      |   11 +++++++++--
 5 files changed, 39 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Jul 12 10:34:29 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 12 Jul 2010 08:34:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-404-g1c79432
Message-ID: <E1OYET9-0005Hc-H2@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1c794320615d917d0e8fb4c40d096fd22f9a824f (commit)
      from  e8445c9c9f02e82ea417776fa27fbe793ae22f83 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1c794320615d917d0e8fb4c40d096fd22f9a824f
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 12 09:34:03 2010 +0100

    adapter.c: missing space in handle_interface_command
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index 2d95e18..e16f756 100644
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -167,7 +167,7 @@ COMMAND_HANDLER(handle_interface_command)
 	 */
 	if (!jtag_interface->transports)
 		LOG_WARNING("Adapter driver '%s' did not declare "
-			"which transports it allows; assuming"
+			"which transports it allows; assuming "
 			"legacy JTAG-only", jtag_interface->name);
 		retval = allow_transports(CMD_CTX,
 					jtag_interface->transports

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/adapter.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Jul 12 21:11:38 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 12 Jul 2010 19:11:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-407-gf129ef6
Message-ID: <E1OYOPo-00014p-DC@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f129ef67dcd96bdd98bf27c13ffbf23b7ca5ee66 (commit)
       via  e521f6415b3ca293ab496d303e092d5312f6e83d (commit)
       via  dc4df8bb974580946c46c0aac82a54dfb2256cc9 (commit)
      from  1c794320615d917d0e8fb4c40d096fd22f9a824f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f129ef67dcd96bdd98bf27c13ffbf23b7ca5ee66
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 12 20:04:57 2010 +0100

    jtag: fix shadow issues in adapter_init
    
    Use global jtag_only rather than local static.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index f7bbe8d..352985f 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1357,7 +1357,6 @@ int adapter_init(struct command_context *cmd_ctx)
 	 * the legacy drivers are JTAG-only
 	 */
 	if (!transports_are_declared()) {
-		static const char *jtag_only[] = { "jtag", NULL, };
 		LOG_ERROR("Adapter driver '%s' did not declare "
 			"which transports it allows; assuming "
 			"JTAG-only", jtag->name);

commit e521f6415b3ca293ab496d303e092d5312f6e83d
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 12 19:48:45 2010 +0100

    arm9: revert change arm9tdmi cmd group name to arm9
    
    This reverts the incorrect change made to the arm9 cmd group in commit
    d1eca9a74c7c57ba6a3210c51b2a10cc5adb22e1.
    
    The code now matches the docs and the release notes.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 744ee76..0749a56 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -912,9 +912,9 @@ const struct command_registration arm9tdmi_command_handlers[] = {
 		.chain = arm7_9_command_handlers,
 	},
 	{
-		.name = "arm9tdmi",
+		.name = "arm9",
 		.mode = COMMAND_ANY,
-		.help = "arm9tdmi command group",
+		.help = "arm9 command group",
 		.chain = arm9tdmi_exec_command_handlers,
 	},
 	COMMAND_REGISTRATION_DONE

commit dc4df8bb974580946c46c0aac82a54dfb2256cc9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 12 19:36:19 2010 +0100

    docs: fix transport typo
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 9feee03..8f47cd1 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2461,14 +2461,14 @@ JTAG transports expose a chain of one or more Test Access Points (TAPs),
 each of which must be explicitly declared.
 JTAG supports both debugging and boundary scan testing.
 Flash programming support is built on top of debug support.
- at subsection SWD ransport
+ at subsection SWD Transport
 SWD (Serial Wire Debug) is an ARM-specific transport which exposes one
 Debug Access Point (DAP, which must be explicitly declared.
 (SWD uses fewer signal wires than JTAG.)
 SWD is debug-oriented, and does not support  boundary scan testing.
 Flash programming support is built on top of debug support.
 (Some processors support both JTAG and SWD.)
- at subsection SPI ransport
+ at subsection SPI Transport
 The Serial Peripheral Interface (SPI) is a general purpose transport
 which uses four wire signaling.  Some processors use it as part of a
 solution for flash programming.

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi      |    4 ++--
 src/jtag/core.c       |    1 -
 src/target/arm9tdmi.c |    4 ++--
 3 files changed, 4 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Jul 13 15:25:06 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 13 Jul 2010 13:25:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-408-g1619fac
Message-ID: <E1OYfTy-0002a9-Q4@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1619facb5ebce060c2cb35035e7801a8898a6296 (commit)
      from  f129ef67dcd96bdd98bf27c13ffbf23b7ca5ee66 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1619facb5ebce060c2cb35035e7801a8898a6296
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Jul 13 14:17:00 2010 +0100

    cfg: add Avalue RSC-W910 config
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/rsc-w910.cfg b/tcl/board/rsc-w910.cfg
new file mode 100644
index 0000000..f7095a6
--- /dev/null
+++ b/tcl/board/rsc-w910.cfg
@@ -0,0 +1,62 @@
+# Avalue RSC-W8910 sbc
+# http://www.avalue.com.tw/products/RSC-W910.cfm
+# 2MB NOR Flash
+# 64MB SDRAM
+# 128MB NAND Flash
+
+# Based on Nuvoton nuc910
+source [find target/nuc910.cfg]
+
+#
+# reset only behaves correctly if we use srst_pulls_trst
+#
+reset_config trst_and_srst srst_pulls_trst
+
+adapter_khz 1000
+adapter_nsrst_delay 100
+jtag_ntrst_delay 100
+
+$_TARGETNAME configure -work-area-phys 0x00000000 -work-area-size 0x04000000 -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME cfi 0x20000000 0x00200000 2 2 $_TARGETNAME
+
+#
+# Target events
+#
+
+$_TARGETNAME configure -event reset-start {adapter_khz 1000}
+
+$_TARGETNAME configure -event reset-init {
+	# switch on PLL for 200MHz operation
+	# running from 15MHz input clock
+	
+	mww 0xB0000200 0x45180bb1 # CLKEN
+	mww 0xB0000204 0x00000f3c # CLKSEL
+	mww 0xB0000208 0x05007000 # CLKDIV
+	mww 0xB000020C 0x00004f24 # PLLCON0
+	mww 0xB0000210 0x00002b63 # PLLCON1
+	sleep 10
+	
+	# we are now running @ 200MHz
+	# enable all openocd speed tweaks
+	
+	arm7_9 dcc_downloads enable
+	arm7_9 fast_memory_access enable
+	adapter_khz 15000
+	
+	# map nor flash to 0x20000000
+	# map sdram to 0x00000000
+	
+	mww 0xb0001000 0x000530c1 # EBICON
+	mww 0xb0001004 0x40030084 # ROMCON
+	mww 0xb0001008 0x000010ee # SDCONF0
+	mww 0xb000100C 0x00000000 # SDCONF1
+	mww 0xb0001010 0x0000015b # SDTIME0
+	mww 0xb0001014 0x0000015b # SDTIME1
+	mww 0xb0001018 0x00000000 # EXT0CON
+	mww 0xb000101C 0x00000000 # EXT1CON
+	mww 0xb0001020 0x00000000 # EXT2CON
+	mww 0xb0001024 0x00000000 # EXT3CON
+	mww 0xb000102c 0x00ff0048 # CKSKEW
+}
diff --git a/tcl/target/nuc910.cfg b/tcl/target/nuc910.cfg
new file mode 100644
index 0000000..7fe91fe
--- /dev/null
+++ b/tcl/target/nuc910.cfg
@@ -0,0 +1,27 @@
+#
+# Nuvoton nuc910 (previously W90P910) based soc
+#
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME nuc910
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # set useful default
+   set _CPUTAPID 0x07926f0f
+}
+
+set _TARGETNAME $_CHIPNAME.cpu
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/rsc-w910.cfg                 |   62 ++++++++++++++++++++++++++++++++
 tcl/target/{netx500.cfg => nuc910.cfg} |   19 ++++------
 2 files changed, 69 insertions(+), 12 deletions(-)
 create mode 100644 tcl/board/rsc-w910.cfg
 copy tcl/target/{netx500.cfg => nuc910.cfg} (63%)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Jul 14 01:36:18 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue, 13 Jul 2010 23:36:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-409-g0672a64
Message-ID: <E1OYp1S-0007UW-8U@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0672a6497ec1ea59905487c01a65ffad79449538 (commit)
      from  1619facb5ebce060c2cb35035e7801a8898a6296 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0672a6497ec1ea59905487c01a65ffad79449538
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Jul 13 19:34:04 2010 -0400

    ARM ADI-V5: PIDs and CIDs are 8 bits
    
    Mask the upper bits after 32-bit reads.
    
    Alsoo revert the ugly changes to use PRIx32; just cast to unsized
    integers when printing (two chars not eight).
    
    Signed-off-by: David Brownell <db at helium.(none)>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index b4f49e7..d6cc938 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1076,11 +1076,12 @@ static int dap_info_command(struct command_context *cmd_ctx,
 			return retval;
 
 		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-			command_print(cmd_ctx, "\tCID3 0x%2.2" PRIx32
-					", CID2 0x%2.2" PRIx32
-					", CID1 0x%2.2" PRIx32
-					", CID0 0x%2.2" PRIx32,
-					cid3, cid2, cid1, cid0);
+			command_print(cmd_ctx, "\tCID3 0x%2.2x"
+					", CID2 0x%2.2x"
+					", CID1 0x%2.2x"
+					", CID0 0x%2.2x",
+					(unsigned) cid3, (unsigned)cid2,
+					(unsigned) cid1, (unsigned) cid0);
 		if (memtype & 0x01)
 			command_print(cmd_ctx, "\tMEMTYPE system memory present on bus");
 		else
@@ -1104,23 +1105,38 @@ static int dap_info_command(struct command_context *cmd_ctx,
 				component_base = (uint32_t)((dbgbase & 0xFFFFF000)
 						+ (int)(romentry & 0xFFFFF000));
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFE0, &c_pid0);
+						(component_base & 0xFFFFF000)
+							| 0xFE0, &c_pid0);
+				c_pid0 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFE4, &c_pid1);
+						(component_base & 0xFFFFF000)
+							| 0xFE4, &c_pid1);
+				c_pid1 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFE8, &c_pid2);
+						(component_base & 0xFFFFF000)
+							| 0xFE8, &c_pid2);
+				c_pid2 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFEC, &c_pid3);
+						(component_base & 0xFFFFF000)
+							| 0xFEC, &c_pid3);
+				c_pid3 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFD0, &c_pid4);
+						(component_base & 0xFFFFF000)
+							| 0xFD0, &c_pid4);
+				c_pid4 &= 0xff;
+
 				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFF0, &c_cid0);
+				c_cid0 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFF4, &c_cid1);
+				c_cid1 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFF8, &c_cid2);
+				c_cid2 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFFC, &c_cid3);
+				c_cid3 &= 0xff;
 				component_start = component_base - 0x1000*(c_pid4 >> 4);
 
 				command_print(cmd_ctx, "\t\tComponent base address 0x%" PRIx32
@@ -1243,23 +1259,27 @@ static int dap_info_command(struct command_context *cmd_ctx,
 				}
 
 				if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-					command_print(cmd_ctx, "\t\tCID3 0x%2.2" PRIx32
-							", CID2 0x%2.2" PRIx32
-							", CID1 0x%2.2" PRIx32
-							", CID0 0x%2.2" PRIx32,
-							c_cid3, c_cid2, c_cid1, c_cid0);
-				command_print(cmd_ctx, "\t\tPeripheral ID[4..0] = hex "
-						"%2.2x %2.2x %2.2x %2.2x %2.2x",
-						(int) c_pid4,
-						(int) c_pid3, (int) c_pid2,
-						(int) c_pid1, (int) c_pid0);
+					command_print(cmd_ctx,
+						      "\t\tCID3 0%2.2x"
+							", CID2 0%2.2x"
+							", CID1 0%2.2x"
+							", CID0 0%2.2x",
+							(int) c_cid3,
+							(int) c_cid2,
+							(int)c_cid1,
+							(int)c_cid0);
+				command_print(cmd_ctx,
+				"\t\tPeripheral ID[4..0] = hex "
+				"%2.2x %2.2x %2.2x %2.2x %2.2x",
+				(int) c_pid4, (int) c_pid3, (int) c_pid2,
+				(int) c_pid1, (int) c_pid0);
 
 				/* Part number interpretations are from Cortex
 				 * core specs, the CoreSight components TRM
 				 * (ARM DDI 0314H), and ETM specs; also from
 				 * chip observation (e.g. TI SDTI).
 				 */
-				part_num = c_pid0 & 0xff;
+				part_num = (c_pid0 & 0xff);
 				part_num |= (c_pid1 & 0x0f) << 8;
 				switch (part_num) {
 				case 0x000:

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   62 +++++++++++++++++++++++++++++++----------------
 1 files changed, 41 insertions(+), 21 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jul 16 12:20:39 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 16 Jul 2010 10:20:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-411-g01b2a30
Message-ID: <E1OZi25-0001O1-OS@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  01b2a3091a4ef5df1a18d1142d6c63477cf9d08f (commit)
       via  bb588bdaec2acb6898c1f86f674b829ee2098642 (commit)
      from  0672a6497ec1ea59905487c01a65ffad79449538 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 01b2a3091a4ef5df1a18d1142d6c63477cf9d08f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Jul 16 10:57:28 2010 +0200

    debug feature: jtagtcpip, improve performance
    
    waiting for ZY1000 fifo to idle is now queued as
    an asynchronous command. This radically improves
    performance when waitIdle() is interspersed with
    writes as no readback is required over TCP/IP.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index d556699..f3fe5a6 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -48,6 +48,7 @@ extern uint32_t zy1000_tcpin(uint32_t address);
 
 
 
+#if BUILD_ECOSBOARD
 // FIFO empty?
 static __inline__ void waitIdle(void)
 {
@@ -57,6 +58,9 @@ static __inline__ void waitIdle(void)
 		ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
 	} while ((empty & 0x100) == 0);
 }
+#else
+extern void waitIdle(void);
+#endif
 
 static __inline__ void waitQueue(void)
 {
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index a1104ef..97c94f7 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1107,6 +1107,7 @@ enum ZY1000_CMD
 	ZY1000_CMD_POKE = 0x0,
 	ZY1000_CMD_PEEK = 0x8,
 	ZY1000_CMD_SLEEP = 0x1,
+	ZY1000_CMD_WAITIDLE = 2
 };
 
 
@@ -1167,6 +1168,22 @@ void zy1000_tcpout(uint32_t address, uint32_t data)
 	}
 }
 
+/* By sending the wait to the server, we avoid a readback
+ * of status. Radically improves performance for this operation
+ * with long ping times.
+ */
+void waitIdle(void)
+{
+	tcpip_open();
+	if (!writeLong((ZY1000_CMD_WAITIDLE << 24)))
+	{
+		fprintf(stderr, "Could not write to zy1000 server\n");
+		exit(-1);
+	}
+}
+
+
+
 uint32_t zy1000_tcpin(uint32_t address)
 {
 	tcpip_open();
@@ -1241,6 +1258,11 @@ static void tcpipserver(void)
 				jtag_sleep(data);
 				break;
 			}
+			case ZY1000_CMD_WAITIDLE:
+			{
+				waitIdle();
+				break;
+			}
 			default:
 				return;
 		}

commit bb588bdaec2acb6898c1f86f674b829ee2098642
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Jul 16 10:51:14 2010 +0200

    debug feature: jtagtcpip, improved performance
    
    only check error flag when rclk is actually enabled.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 013d865..a1104ef 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -72,6 +72,10 @@
 
 #endif
 
+
+/* The software needs to check if it's in RCLK mode or not */
+static bool zy1000_rclk = false;
+
 static int zy1000_khz(int khz, int *jtag_speed)
 {
 	if (khz == 0)
@@ -222,11 +226,13 @@ int zy1000_speed(int speed)
 	/* flush JTAG master FIFO before setting speed */
 	waitIdle();
 
+	zy1000_rclk = false;
+
 	if (speed == 0)
 	{
 		/*0 means RCLK*/
-		speed = 0;
 		ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x100);
+		zy1000_rclk = true;
 		LOG_DEBUG("jtag_speed using RCLK");
 	}
 	else
@@ -456,17 +462,24 @@ int interface_jtag_execute_queue(void)
 	uint32_t empty;
 
 	waitIdle();
-	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
-	/* clear JTAG error register */
-	ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x400);
 
-	if ((empty&0x400) != 0)
+	if (zy1000_rclk)
 	{
-		LOG_WARNING("RCLK timeout");
-		/* the error is informative only as we don't want to break the firmware if there
-		 * is a false positive.
+		/* Only check for errors when using RCLK to speed up
+		 * jtag over TCP/IP
 		 */
-//		return ERROR_FAIL;
+		ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
+		/* clear JTAG error register */
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x400);
+
+		if ((empty&0x400) != 0)
+		{
+			LOG_WARNING("RCLK timeout");
+			/* the error is informative only as we don't want to break the firmware if there
+			 * is a false positive.
+			 */
+	//		return ERROR_FAIL;
+		}
 	}
 	return ERROR_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/jtag_minidriver.h |    4 +++
 src/jtag/zy1000/zy1000.c          |   53 ++++++++++++++++++++++++++++++------
 2 files changed, 48 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jul 16 16:10:10 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 16 Jul 2010 14:10:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-413-gd16f925
Message-ID: <E1OZlcB-0001qH-SB@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d16f9259c2aa0be1ffde9c6faa04a6463819bb8e (commit)
       via  9cbf0723d5a2978998b541aa2942b7fadc69e9ee (commit)
      from  01b2a3091a4ef5df1a18d1142d6c63477cf9d08f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d16f9259c2aa0be1ffde9c6faa04a6463819bb8e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Jul 16 16:02:42 2010 +0200

    fix warnings
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 015db2a..a2b8891 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -865,7 +865,7 @@ int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opc
 
 	if ((pre_bits > 32) || (post_bits > 32))
 	{
-		int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count);
+		int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap *, uint32_t, uint32_t *, size_t);
 		return arm11_run_instr_data_to_core_noack_inner_default(tap, opcode, data, count);
 	} else
 	{
@@ -1526,4 +1526,3 @@ struct jtag_interface zy1000_interface =
 	.power_dropout = zy1000_power_dropout,
 	.srst_asserted = zy1000_srst_asserted,
 };
-

commit 9cbf0723d5a2978998b541aa2942b7fadc69e9ee
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Jul 16 15:44:12 2010 +0200

    debug-feature: jtagtcpip, reduce performance impact of ping times
    
    queue read back of data
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index f3fe5a6..0f2b46a 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -58,8 +58,14 @@ static __inline__ void waitIdle(void)
 		ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
 	} while ((empty & 0x100) == 0);
 }
+
+static __inline__ void zy1000_flush_readqueue(void)
+{
+	/* Not used w/hardware fifo */
+}
 #else
 extern void waitIdle(void);
+void zy1000_flush_readqueue(void);
 #endif
 
 static __inline__ void waitQueue(void)
@@ -222,6 +228,6 @@ static __inline__ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 	}
 }
 
-#define interface_jtag_add_callback(callback, in) callback(in)
-
-#define interface_jtag_add_callback4(callback, in, data1, data2, data3) jtag_set_error(callback(in, data1, data2, data3))
+/* Must flush any read queue before we can invoke callback */
+#define interface_jtag_add_callback(callback, in) {zy1000_flush_readqueue(); callback(in);}
+#define interface_jtag_add_callback4(callback, in, data1, data2, data3) {zy1000_flush_readqueue(); jtag_set_error(callback(in, data1, data2, data3));}
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 97c94f7..015db2a 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -463,6 +463,11 @@ int interface_jtag_execute_queue(void)
 
 	waitIdle();
 
+	/* We must make sure to write data read back to memory location before we return
+	 * from this fn
+	 */
+	zy1000_flush_readqueue();
+
 	if (zy1000_rclk)
 	{
 		/* Only check for errors when using RCLK to speed up
@@ -487,38 +492,7 @@ int interface_jtag_execute_queue(void)
 
 
 
-
-static uint32_t getShiftValue(void)
-{
-	uint32_t value;
-	waitIdle();
-	ZY1000_PEEK(ZY1000_JTAG_BASE + 0xc, value);
-	VERBOSE(LOG_INFO("getShiftValue %08x", value));
-	return value;
-}
-#if 0
-static uint32_t getShiftValueFlip(void)
-{
-	uint32_t value;
-	waitIdle();
-	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x18, value);
-	VERBOSE(LOG_INFO("getShiftValue %08x (flipped)", value));
-	return value;
-}
-#endif
-
-#if 0
-static void shiftValueInnerFlip(const tap_state_t state, const tap_state_t endState, int repeat, uint32_t value)
-{
-	VERBOSE(LOG_INFO("shiftValueInner %s %s %d %08x (flipped)", tap_state_name(state), tap_state_name(endState), repeat, value));
-	uint32_t a,b;
-	a = state;
-	b = endState;
-	ZY1000_POKE(ZY1000_JTAG_BASE + 0xc, value);
-	ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (1 << 15) | (repeat << 8) | (a << 4) | b);
-	VERBOSE(getShiftValueFlip());
-}
-#endif
+static void writeShiftValue(uint8_t *data, int bits);
 
 // here we shuffle N bits out/in
 static __inline void scanBits(const uint8_t *out_value, uint8_t *in_value, int num_bits, bool pause_now, tap_state_t shiftState, tap_state_t end_state)
@@ -562,15 +536,7 @@ static __inline void scanBits(const uint8_t *out_value, uint8_t *in_value, int n
 
 		if (in_value != NULL)
 		{
-			// data in, LSB to MSB
-			value = getShiftValue();
-			// we're shifting in data to MSB, shift data to be aligned for returning the value
-			value >>= 32-k;
-
-			for (int l = 0; l < k; l += 8)
-			{
-				in_value[(j + l)/8]=(value >> l)&0xff;
-			}
+			writeShiftValue(in_value + (j/8), k);
 		}
 	}
 }
@@ -1182,11 +1148,12 @@ void waitIdle(void)
 	}
 }
 
-
-
 uint32_t zy1000_tcpin(uint32_t address)
 {
 	tcpip_open();
+
+	zy1000_flush_readqueue();
+
 	uint32_t data;
 	if (!writeLong((ZY1000_CMD_PEEK << 24) | address)||
 			!readLong(&data))
@@ -1209,6 +1176,90 @@ int interface_jtag_add_sleep(uint32_t us)
 	return ERROR_OK;
 }
 
+/* queue a readback */
+#define readqueue_size 16384
+static struct
+{
+	uint8_t *dest;
+	int bits;
+} readqueue[readqueue_size];
+
+static int readqueue_pos = 0;
+
+/* flush the readqueue, this means reading any data that
+ * we're expecting and store them into the final position
+ */
+void zy1000_flush_readqueue(void)
+{
+	if (readqueue_pos == 0)
+	{
+		/* simply debugging by allowing easy breakpoints when there
+		 * is something to do. */
+		return;
+	}
+	int i;
+	tcpip_open();
+	for (i = 0; i < readqueue_pos; i++)
+	{
+		uint32_t value;
+		if (!readLong(&value))
+		{
+			fprintf(stderr, "Could not read from zy1000 server\n");
+			exit(-1);
+		}
+
+		uint8_t *in_value = readqueue[i].dest;
+		int k = readqueue[i].bits;
+
+		// we're shifting in data to MSB, shift data to be aligned for returning the value
+		value >>= 32-k;
+
+		for (int l = 0; l < k; l += 8)
+		{
+			in_value[l/8]=(value >> l)&0xff;
+		}
+	}
+	readqueue_pos = 0;
+}
+
+static void writeShiftValue(uint8_t *data, int bits)
+{
+	waitIdle();
+
+	if (!writeLong((ZY1000_CMD_PEEK << 24) | (ZY1000_JTAG_BASE + 0xc)))
+	{
+		fprintf(stderr, "Could not read from zy1000 server\n");
+		exit(-1);
+	}
+
+	if (readqueue_pos >= readqueue_size)
+	{
+		zy1000_flush_readqueue();
+	}
+
+	readqueue[readqueue_pos].dest = data;
+	readqueue[readqueue_pos].bits = bits;
+	readqueue_pos++;
+}
+
+#else
+
+static void writeShiftValue(uint8_t *data, int bits)
+{
+	uint32_t value;
+	waitIdle();
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0xc, value);
+	VERBOSE(LOG_INFO("getShiftValue %08x", value));
+
+	// data in, LSB to MSB
+	// we're shifting in data to MSB, shift data to be aligned for returning the value
+	value >>= 32 - bits;
+
+	for (int l = 0; l < bits; l += 8)
+	{
+		data[l/8]=(value >> l)&0xff;
+	}
+}
 
 #endif
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/jtag_minidriver.h |   12 +++-
 src/jtag/zy1000/zy1000.c          |  140 +++++++++++++++++++++++++------------
 2 files changed, 104 insertions(+), 48 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Jul 16 23:53:40 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri, 16 Jul 2010 21:53:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-414-gb05ae41
Message-ID: <E1OZsqo-0002bO-OT@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b05ae413314f48832dd12c994b85c9aad8632967 (commit)
      from  d16f9259c2aa0be1ffde9c6faa04a6463819bb8e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b05ae413314f48832dd12c994b85c9aad8632967
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jul 16 22:52:49 2010 +0100

    flash: use bkpt for str9 flash algo algorithm
    
    STR9 is ARMv5 arch so use bkpt instruction rather than
    waste a breakpoint.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 103af16..528e52e 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -369,7 +369,7 @@ static int str9x_write_block(struct flash_bank *bank,
 		0xe2522001,	/*	subs r2, r2, #1		*/
 		0x1affffed,	/*	bne write			*/
 					/* exit:				*/
-		0xeafffffe,	/*	b exit				*/
+		0xe1200070,	/*	bkpt #0				*/
 	};
 
 	/* flash write code */
@@ -421,8 +421,7 @@ static int str9x_write_block(struct flash_bank *bank,
 
 		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
 				str9x_info->write_algorithm->address,
-				str9x_info->write_algorithm->address + (sizeof(str9x_flash_write_code) - 4),
-				10000, &armv4_5_info)) != ERROR_OK)
+				0, 10000, &armv4_5_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing str9x flash write algorithm");
 			retval = ERROR_FLASH_OPERATION_FAILED;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9x.c |    5 ++---
 1 files changed, 2 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Jul 17 01:22:25 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 16 Jul 2010 23:22:25 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-415-ga4dace3
Message-ID: <E1OZuEc-0007eL-TG@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a4dace3122749991136d9d50ef685f5d641d3295 (commit)
      from  b05ae413314f48832dd12c994b85c9aad8632967 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a4dace3122749991136d9d50ef685f5d641d3295
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Jul 16 19:22:15 2010 -0400

    ARM ADI-V5: cleanup CID/PID addressing
    
    Use addition for offsetting, not masking.  Shorten some lines.
    Make "component_start" print-only (unused otherwise; don't save).
    
    Still doesn't resolve the issue where multiple components
    are wrongly displaying as NVICs on some Cortex-M3 parts because
    many PIDs appear to be zeroes ... maybe adapter related??
    
    Signed-off-by: David Brownell <db at helium.(none)>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index d6cc938..dfb45b4 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1098,50 +1098,52 @@ static int dap_info_command(struct command_context *cmd_ctx,
 			{
 				uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
 				uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
-				uint32_t component_start, component_base;
+				uint32_t component_base;
 				unsigned part_num;
 				char *type, *full;
 
-				component_base = (uint32_t)((dbgbase & 0xFFFFF000)
-						+ (int)(romentry & 0xFFFFF000));
+				component_base = (dbgbase & 0xFFFFF000)
+						+ (romentry & 0xFFFFF000);
+
+				/* IDs are in last 4K section */
+
+
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000)
-							| 0xFE0, &c_pid0);
+					component_base + 0xFE0, &c_pid0);
 				c_pid0 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000)
-							| 0xFE4, &c_pid1);
+					component_base + 0xFE4, &c_pid1);
 				c_pid1 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000)
-							| 0xFE8, &c_pid2);
+					component_base + 0xFE8, &c_pid2);
 				c_pid2 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000)
-							| 0xFEC, &c_pid3);
+					component_base + 0xFEC, &c_pid3);
 				c_pid3 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000)
-							| 0xFD0, &c_pid4);
+					component_base + 0xFD0, &c_pid4);
 				c_pid4 &= 0xff;
 
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFF0, &c_cid0);
+					component_base + 0xFF0, &c_cid0);
 				c_cid0 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFF4, &c_cid1);
+					component_base + 0xFF4, &c_cid1);
 				c_cid1 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFF8, &c_cid2);
+					component_base + 0xFF8, &c_cid2);
 				c_cid2 &= 0xff;
 				mem_ap_read_atomic_u32(dap,
-						(component_base & 0xFFFFF000) | 0xFFC, &c_cid3);
+					component_base + 0xFFC, &c_cid3);
 				c_cid3 &= 0xff;
-				component_start = component_base - 0x1000*(c_pid4 >> 4);
 
-				command_print(cmd_ctx, "\t\tComponent base address 0x%" PRIx32
-						", start address 0x%" PRIx32,
-						component_base, component_start);
+
+				command_print(cmd_ctx,
+				"\t\tComponent base address 0x%" PRIx32
+					", start address 0x%" PRIx32,
+						component_base,
+				/* component may take multiple 4K pages */
+				component_base - 0x1000*(c_pid4 >> 4));
 				command_print(cmd_ctx, "\t\tComponent class is 0x%x, %s",
 						(int) (c_cid1 >> 4) & 0xf,
 						/* See ARM IHI 0029B Table 3-3 */

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   44 +++++++++++++++++++++++---------------------
 1 files changed, 23 insertions(+), 21 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Jul 17 09:04:32 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 17 Jul 2010 07:04:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-416-g2fdc1db
Message-ID: <E1Oa1Rq-00087w-9N@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2fdc1db30481279e39cdb1928a7455f75e34eb3f (commit)
      from  a4dace3122749991136d9d50ef685f5d641d3295 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2fdc1db30481279e39cdb1928a7455f75e34eb3f
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Jul 17 02:59:23 2010 -0400

    lm3s811-ek uses generic stellaris target config
    
    There's no point in an lm3s811-specific target file,
    so remove it in favor of the generic "stellaris.cfg".
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 2dd14cc..bb746fa 100644
--- a/NEWS
+++ b/NEWS
@@ -49,6 +49,7 @@ Board, Target, and Interface Configuration Scripts:
 	Support Voipac PXA270/PXA270M module.
 	New $PARPORTADDR tcl variable used to change default
 		parallel port address used.
+	Remove lm3s811.cfg; use "stellaris.cfg" instead
 
 Core Jim/TCL Scripting:
 	New "add_script_search_dir" command, behaviour is the same
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s811.cfg
index 7d3f2ce..66519f6 100644
--- a/tcl/board/ek-lm3s811.cfg
+++ b/tcl/board/ek-lm3s811.cfg
@@ -4,13 +4,14 @@
 # http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
 
 # include the FT2232 interface config for on-board JTAG interface
+# NOTE:  older '811-EK boards (before rev C) shouldn't use this.
 source [find interface/luminary.cfg]
 
+   set  CHIPNAME lm3s811
+
 # include the target config
-source [find target/lm3s811.cfg]
+source [find target/stellaris.cfg]
 
-# jtag speed
-adapter_khz 500
 
 adapter_nsrst_delay 100
 
diff --git a/tcl/target/lm3s811.cfg b/tcl/target/lm3s811.cfg
deleted file mode 100644
index 49879d0..0000000
--- a/tcl/target/lm3s811.cfg
+++ /dev/null
@@ -1,29 +0,0 @@
-# Script for TI/Luminary Stellaris LM3S811
-
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lm3s811
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x3ba00477
-}
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0xf -expected-id $_CPUTAPID
-
-# the luminary variant causes a software reset rather than asserting SRST
-# this stops the debug registers from being cleared
-# this will be fixed in later revisions of silicon
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
-
-# 8k working area at base of ram, not backed up
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
-
-#flash configuration
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME stellaris 0 0 0 0 $_TARGETNAME

-----------------------------------------------------------------------

Summary of changes:
 NEWS                     |    1 +
 tcl/board/ek-lm3s811.cfg |    7 ++++---
 tcl/target/lm3s811.cfg   |   29 -----------------------------
 3 files changed, 5 insertions(+), 32 deletions(-)
 delete mode 100644 tcl/target/lm3s811.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jul 18 22:57:18 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 18 Jul 2010 20:57:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-418-gb85dcae
Message-ID: <E1OaavP-0005he-4S@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b85dcae447581d06013cb7d68f582a8708c3cc50 (commit)
      from  495ef923ef6eaced194bf17ce9080b66a7fee4ea (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b85dcae447581d06013cb7d68f582a8708c3cc50
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jul 18 22:56:01 2010 +0200

    spelling fixes in comments
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index afe5b6c..90e1a00 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -109,7 +109,7 @@ static int cortex_a8_init_debug_access(struct target *target)
 
 	/* Resync breakpoint registers */
 
-	/* Since this is likley called from init or reset, update targtet state information*/
+	/* Since this is likely called from init or reset, update target state information*/
 	retval = cortex_a8_poll(target);
 
 	return retval;
@@ -1101,7 +1101,7 @@ static int cortex_a8_restore_context(struct target *target, bool bpwp)
 
 
 /*
- * Cortex-A8 Breakpoint and watchpoint fuctions
+ * Cortex-A8 Breakpoint and watchpoint functions
  */
 
 /* Setup hardware Breakpoint Register Pair */
@@ -1261,7 +1261,7 @@ static int cortex_a8_remove_breakpoint(struct target *target, struct breakpoint
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 
 #if 0
-/* It is perfectly possible to remove brakpoints while the taget is running */
+/* It is perfectly possible to remove breakpoints while the target is running */
 	if (target->state != TARGET_HALTED)
 	{
 		LOG_WARNING("target not halted");
@@ -1283,7 +1283,7 @@ static int cortex_a8_remove_breakpoint(struct target *target, struct breakpoint
 
 
 /*
- * Cortex-A8 Reset fuctions
+ * Cortex-A8 Reset functions
  */
 
 static int cortex_a8_assert_reset(struct target *target)
@@ -1803,7 +1803,7 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     2, 0,   /* CRn, CRm */
                     &ttb);
     }
-    /* finaly we don't know whose ttb to use: user or kernel */
+    /* finally we don't know whose ttb to use: user or kernel */
     else
         LOG_ERROR("Don't know how to get ttb for current mode!!!");
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a8.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Jul 18 23:31:12 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 18 Jul 2010 21:31:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-419-gd10f0de
Message-ID: <E1OabS6-0002Vl-JM@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d10f0def80f8837398b9176388ed6110fcebfd2d (commit)
      from  b85dcae447581d06013cb7d68f582a8708c3cc50 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d10f0def80f8837398b9176388ed6110fcebfd2d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Jul 18 17:29:25 2010 -0400

    comments for Luminary ICDI layout
    
    Provide $defines for more of the signals involved in the
    Luminary ICDI hardware, and comment some of what's going on.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index bf71fa3..4dcc045 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -318,6 +318,9 @@ static const struct ft2232_layout *layout;
 
 /** default bitmask values ddriven on DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
 static uint8_t                  low_output     = 0x0;
+
+/* note that direction bit == 1 means that signal is an output */
+
 /** default direction bitmask for DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
 static uint8_t                  low_direction  = 0x0;
 /** default value bitmask for CBUS GPIOH(0..4) */
@@ -2492,13 +2495,34 @@ static int icdi_jtag_init(void)
 
 	/* Most Luminary eval boards support SWO trace output,
 	 * and should use this "luminary_icdi" layout.
+	 *
+	 * DBUS 0..3 are used for JTAG as usual.  GPIOs are used
+	 * to switch between JTAG and SWD, or switch the ft2232 UART
+	 * between (i) the target UART or (ii) SWO trace data.
+	 *
+	 * We come up in JTAG mode and may switch to SWD later (with
+	 * SWO/trace option if SWD is active).
+	 *
+	 * DBUS == GPIO-Lx
+	 * CBUS == GPIO-Hx
 	 */
+
+
+#define ICDI_JTAG_EN (1 << 7)		/* ADBUS 7 (a.k.a. DBGMOD) */
+#define ICDI_DBG_ENn (1 << 6)		/* ADBUS 6 */
+#define ICDI_SRST (1 << 5)		/* ADBUS 5 */
+#define ICDI_TDI (1 << 2)		/* ADBUS 2 (INPUT) */
+
+#define ICDI_SWO_EN (1 << 4)		/* BDBUS 4 */
+#define ICDI_TX_SWO (1 << 1)	 	/* BDBUS 1 */
+
 	nTRST = 0x0;
 	nTRSTnOE = 0x00;
-	nSRST = 0x20;
+	nSRST = ICDI_SRST;
 	nSRSTnOE = 0x20;
-	low_output    = 0x88;
-	low_direction = 0xcb;
+
+	low_output    = 0x08 | ICDI_JTAG_EN;
+	low_direction = 0xcb | ICDI_JTAG_EN;
 
 	return ftx232_dbus_write();
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |   30 +++++++++++++++++++++++++++---
 1 files changed, 27 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jul 19 08:37:05 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 19 Jul 2010 06:37:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-425-g20c1d4c
Message-ID: <E1OajyN-00087h-Jm@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  20c1d4cc9a2ce8864b59ef6414f9cf5649b9f046 (commit)
       via  221ce7c89b2c8792be4099687ed23f04f4e5018d (commit)
       via  8249261b88644c4b6809bf01c2285f27c97ff434 (commit)
       via  a2d5b0ef77944f2bca5aaf8615e61bdc70ff8c6a (commit)
       via  ad02493cf2e4e201636d963503a1a2f5c7b0820e (commit)
       via  19fc52f00869a4c607483d96c459a51f3979c8db (commit)
      from  d10f0def80f8837398b9176388ed6110fcebfd2d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 20c1d4cc9a2ce8864b59ef6414f9cf5649b9f046
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jul 18 23:30:31 2010 +0200

    cortex a8: lots of error propagation fixes
    
    found by code inspection
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index a2f3ea0..bd14016 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -468,6 +468,8 @@ static int cortex_a8_instr_write_data_dcc(struct arm_dpm *dpm,
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	retval = cortex_a8_write_dcc(a8, data);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return cortex_a8_exec_opcode(
 			a8->armv7a_common.armv4_5_common.target,
@@ -483,6 +485,8 @@ static int cortex_a8_instr_write_data_r0(struct arm_dpm *dpm,
 	int retval;
 
 	retval = cortex_a8_write_dcc(a8, data);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15 */
 	retval = cortex_a8_exec_opcode(
@@ -837,7 +841,9 @@ static int cortex_a8_resume(struct target *target, int current,
 	armv4_5->pc->dirty = 1;
 	armv4_5->pc->valid = 1;
 
-	cortex_a8_restore_context(target, handle_breakpoints);
+	retval = cortex_a8_restore_context(target, handle_breakpoints);
+	if (retval != ERROR_OK)
+		return retval;
 
 #if 0
 	/* the front-end may request us not to handle breakpoints */
@@ -965,10 +971,14 @@ static int cortex_a8_debug_entry(struct target *target)
 	else
 	{
 		dap_ap_select(swjdp, swjdp_memoryap);
-		cortex_a8_read_regs_through_mem(target,
+		retval = cortex_a8_read_regs_through_mem(target,
 				regfile_working_area->address, regfile);
 		dap_ap_select(swjdp, swjdp_memoryap);
 		target_free_working_area(target, regfile_working_area);
+		if (retval != ERROR_OK)
+		{
+			return retval;
+		}
 
 		/* read Current PSR */
 		retval = cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
@@ -1156,9 +1166,7 @@ static int cortex_a8_restore_context(struct target *target, bool bpwp)
 	if (armv7a->pre_restore_context)
 		armv7a->pre_restore_context(target);
 
-	arm_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
-
-	return ERROR_OK;
+	return arm_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
 }
 
 
@@ -1204,12 +1212,16 @@ static int cortex_a8_set_breakpoint(struct target *target,
 		brp_list[brp_i].used = 1;
 		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
 		brp_list[brp_i].control = control;
-		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].value);
-		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
+		if (retval != ERROR_OK)
+			return retval;
 		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
 				brp_list[brp_i].control,
 				brp_list[brp_i].value);
@@ -1268,12 +1280,16 @@ static int cortex_a8_unset_breakpoint(struct target *target, struct breakpoint *
 		brp_list[brp_i].used = 0;
 		brp_list[brp_i].value = 0;
 		brp_list[brp_i].control = 0;
-		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
-		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].value);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	else
 	{
@@ -1456,7 +1472,10 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
         if(enabled)
         {
             virt = address;
-            cortex_a8_virt2phys(target, virt, &phys);
+            retval = cortex_a8_virt2phys(target, virt, &phys);
+            if (retval != ERROR_OK)
+            	return retval;
+
             LOG_DEBUG("Reading at virtual address. Translating v:0x%x to r:0x%x", virt, phys);
             address = phys;
         }
@@ -1520,6 +1539,8 @@ static int cortex_a8_write_phys_memory(struct target *target,
                                 retval = dpm->instr_write_data_r0(dpm,
                                         ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
                                         cacheline);
+                                if (retval != ERROR_OK)
+                                	return retval;
                         }
                 }
 
@@ -1536,6 +1557,8 @@ static int cortex_a8_write_phys_memory(struct target *target,
                                 retval = dpm->instr_write_data_r0(dpm,
                                         ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
                                         cacheline);
+                                if (retval != ERROR_OK)
+                                	return retval;
                         }
                 }
 
@@ -1561,7 +1584,9 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
         if(enabled)
         {
             virt = address;
-            cortex_a8_virt2phys(target, virt, &phys);
+            retval = cortex_a8_virt2phys(target, virt, &phys);
+            if (retval != ERROR_OK)
+            	return retval;
             LOG_DEBUG("Writing to virtual address. Translating v:0x%x to r:0x%x", virt, phys);
             address = phys;
         }
@@ -1605,6 +1630,7 @@ static int cortex_a8_handle_target_request(void *priv)
 	struct target *target = priv;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval;
 
 	if (!target_was_examined(target))
 		return ERROR_OK;
@@ -1616,7 +1642,9 @@ static int cortex_a8_handle_target_request(void *priv)
 		uint8_t data = 0;
 		uint8_t ctrl = 0;
 
-		cortex_a8_dcc_read(swjdp, &data, &ctrl);
+		retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* check if we have data */
 		if (ctrl & (1 << 0))
@@ -1625,11 +1653,17 @@ static int cortex_a8_handle_target_request(void *priv)
 
 			/* we assume target is quick enough */
 			request = data;
-			cortex_a8_dcc_read(swjdp, &data, &ctrl);
+			retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
+			if (retval != ERROR_OK)
+				return retval;
 			request |= (data << 8);
-			cortex_a8_dcc_read(swjdp, &data, &ctrl);
+			retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
+			if (retval != ERROR_OK)
+				return retval;
 			request |= (data << 16);
-			cortex_a8_dcc_read(swjdp, &data, &ctrl);
+			retval = cortex_a8_dcc_read(swjdp, &data, &ctrl);
+			if (retval != ERROR_OK)
+				return retval;
 			request |= (data << 24);
 			target_request(target, request);
 		}
@@ -1816,11 +1850,10 @@ static int cortex_a8_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct cortex_a8_common *cortex_a8 = calloc(1, sizeof(struct cortex_a8_common));
 
-	cortex_a8_init_arch_info(target, cortex_a8, target->tap);
-
-	return ERROR_OK;
+	return cortex_a8_init_arch_info(target, cortex_a8, target->tap);
 }
 
+/* FIX! error propagation missing from this fn */
 static uint32_t cortex_a8_get_ttb(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
@@ -1874,6 +1907,7 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
     return ttb;
 }
 
+/* FIX! error propagation missing from this fn */
 static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache)
 {
@@ -1903,6 +1937,7 @@ static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                     cp15_control);
 }
 
+/* FIX! error propagation missing from this fn */
 static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache)
 {

commit 221ce7c89b2c8792be4099687ed23f04f4e5018d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jul 18 23:12:25 2010 +0200

    cortex a8: mem_ap_read_buf_u32() error handling
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 0f5c742..a2f3ea0 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -191,7 +191,9 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 		return retval;
 
 	dap_ap_select(swjdp, swjdp_memoryap);
-	mem_ap_read_buf_u32(swjdp, (uint8_t *)(&regfile[1]), 4*15, address);
+	retval = mem_ap_read_buf_u32(swjdp, (uint8_t *)(&regfile[1]), 4*15, address);
+	if (retval != ERROR_OK)
+		return retval;
 	dap_ap_select(swjdp, swjdp_debugap);
 
 	return retval;

commit 8249261b88644c4b6809bf01c2285f27c97ff434
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jul 18 23:10:50 2010 +0200

    cortex a8: add missing error handling for cortex_a8_dap_write/read_coreregister_u32()
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index d092223..0f5c742 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -180,8 +180,12 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
 
-	cortex_a8_dap_read_coreregister_u32(target, regfile, 0);
-	cortex_a8_dap_write_coreregister_u32(target, address, 0);
+	retval = cortex_a8_dap_read_coreregister_u32(target, regfile, 0);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a8_dap_write_coreregister_u32(target, address, 0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = cortex_a8_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
 	if (retval != ERROR_OK)
 		return retval;
@@ -965,7 +969,9 @@ static int cortex_a8_debug_entry(struct target *target)
 		target_free_working_area(target, regfile_working_area);
 
 		/* read Current PSR */
-		cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
+		retval = cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
+		if (retval != ERROR_OK)
+			return retval;
 		dap_ap_select(swjdp, swjdp_debugap);
 		LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
 

commit a2d5b0ef77944f2bca5aaf8615e61bdc70ff8c6a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jul 18 23:08:26 2010 +0200

    cortex a8: add missing error handling from cortex_a8_exec_opcode()
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 441c93b..d092223 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -182,7 +182,10 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 
 	cortex_a8_dap_read_coreregister_u32(target, regfile, 0);
 	cortex_a8_dap_write_coreregister_u32(target, address, 0);
-	cortex_a8_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
+	retval = cortex_a8_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
 	dap_ap_select(swjdp, swjdp_memoryap);
 	mem_ap_read_buf_u32(swjdp, (uint8_t *)(&regfile[1]), 4*15, address);
 	dap_ap_select(swjdp, swjdp_debugap);
@@ -205,27 +208,37 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	if (reg < 15)
 	{
 		/* Rn to DCCTX, "MCR p14, 0, Rn, c0, c5, 0"  0xEE00nE15 */
-		cortex_a8_exec_opcode(target,
+		retval = cortex_a8_exec_opcode(target,
 				ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	else if (reg == 15)
 	{
 		/* "MOV r0, r15"; then move r0 to DCCTX */
-		cortex_a8_exec_opcode(target, 0xE1A0000F, &dscr);
-		cortex_a8_exec_opcode(target,
+		retval = cortex_a8_exec_opcode(target, 0xE1A0000F, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_exec_opcode(target,
 				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	else
 	{
 		/* "MRS r0, CPSR" or "MRS r0, SPSR"
 		 * then move r0 to DCCTX
 		 */
-		cortex_a8_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
-		cortex_a8_exec_opcode(target,
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_exec_opcode(target,
 				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	/* Wait for DTRRXfull then read DTRRTX */
@@ -264,8 +277,10 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	{
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX with MCR(p14, 0, Rd, c0, c5, 0), opcode  0xEE000E15 */
-		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	if (Rd > 17)
@@ -281,33 +296,47 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	if (Rd < 15)
 	{
 		/* DCCRX to Rn, "MCR p14, 0, Rn, c0, c5, 0", 0xEE00nE15 */
-		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	else if (Rd == 15)
 	{
 		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
 		 * then "mov r15, r0"
 		 */
-		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
-		cortex_a8_exec_opcode(target, 0xE1A0F000, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_exec_opcode(target, 0xE1A0F000, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	else
 	{
 		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
 		 * then "MSR CPSR_cxsf, r0" or "MSR SPSR_cxsf, r0" (all fields)
 		 */
-		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
-		cortex_a8_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, Rd & 1),
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a8_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, Rd & 1),
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* "Prefetch flush" after modifying execution status in CPSR */
 		if (Rd == 16)
-			cortex_a8_exec_opcode(target,
+		{
+			retval = cortex_a8_exec_opcode(target,
 					ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
 					&dscr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
 	}
 
 	return retval;
@@ -412,6 +441,8 @@ static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 				a8->armv7a_common.armv4_5_common.target,
 				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	return retval;
@@ -452,6 +483,8 @@ static int cortex_a8_instr_write_data_r0(struct arm_dpm *dpm,
 			a8->armv7a_common.armv4_5_common.target,
 			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* then the opcode, taking data from R0 */
 	retval = cortex_a8_exec_opcode(
@@ -485,6 +518,8 @@ static int cortex_a8_instr_read_data_dcc(struct arm_dpm *dpm,
 			a8->armv7a_common.armv4_5_common.target,
 			opcode,
 			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return cortex_a8_read_dcc(a8, data, &dscr);
 }
@@ -502,12 +537,16 @@ static int cortex_a8_instr_read_data_r0(struct arm_dpm *dpm,
 			a8->armv7a_common.armv4_5_common.target,
 			opcode,
 			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* write R0 to DCC */
 	retval = cortex_a8_exec_opcode(
 			a8->armv7a_common.armv4_5_common.target,
 			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return cortex_a8_read_dcc(a8, data, &dscr);
 }

commit ad02493cf2e4e201636d963503a1a2f5c7b0820e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jul 18 23:03:05 2010 +0200

    cortex a8: add missing error handling for mem_ap_atomic_write_u32()
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 82ce9a1..441c93b 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -147,7 +147,9 @@ static int cortex_a8_exec_opcode(struct target *target,
 		}
 	}
 
-	mem_ap_write_u32(swjdp, armv7a->debug_base + CPUDBG_ITR, opcode);
+	retval = mem_ap_write_u32(swjdp, armv7a->debug_base + CPUDBG_ITR, opcode);
+	if (retval != ERROR_OK)
+		return retval;
 
 	do
 	{
@@ -273,6 +275,8 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	LOG_DEBUG("write DCC 0x%08" PRIx32, value);
 	retval = mem_ap_write_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DTRRX, value);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (Rd < 15)
 	{

commit 19fc52f00869a4c607483d96c459a51f3979c8db
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jul 18 23:01:16 2010 +0200

    cortex a8: add missing error handling for mem_ap_read_atomic_u32()
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 90e1a00..82ce9a1 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -11,6 +11,9 @@
  *   Copyright (C) 2009 by Dirk Behme                                      *
  *   dirk.behme at gmail.com - copy from cortex_m3                            *
  *                                                                         *
+ *   Copyright (C) 2010 ??yvind Harboe                                      *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -228,6 +231,8 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	retval = mem_ap_read_atomic_u32(swjdp,
@@ -251,6 +256,8 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	/* Check that DCCRX is not full */
 	retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
 	if (dscr & DSCR_DTR_RX_FULL)
 	{
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
@@ -352,10 +359,14 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		retval = mem_ap_read_atomic_u32(swjdp,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	retval = mem_ap_read_atomic_u32(swjdp,
 			a8->armv7a_common.debug_base + CPUDBG_DTRTX, data);
+	if (retval != ERROR_OK)
+		return retval;
 	//LOG_DEBUG("read DCC 0x%08" PRIx32, *data);
 
 	if (dscr_p)

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a8.c |  169 +++++++++++++++++++++++++++++++++++++----------
 1 files changed, 133 insertions(+), 36 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Jul 19 17:21:16 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 19 Jul 2010 15:21:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-429-g4611f87
Message-ID: <E1Oas9h-0004Ki-T1@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4611f87f0aeba42d21fc6c197e904a0c97731bf7 (commit)
       via  0345667642e13ef2c78dc904677541d2b935d831 (commit)
       via  8f5e84bf8dabfddc6b853c522fdc29be90c93746 (commit)
       via  d249057adfeb3f652df86ad321577744910b6e21 (commit)
      from  20c1d4cc9a2ce8864b59ef6414f9cf5649b9f046 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4611f87f0aeba42d21fc6c197e904a0c97731bf7
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 19 12:22:18 2010 +0100

    flash: add nuc910 nand driver
    
    This adds a nand driver support for the nuc910 target.
    Note that ECC is not currently supported by this driver, although
    it is supported by the peripheral.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 259a9cb..8ea7b36 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -27,7 +27,8 @@ NAND_DRIVERS = \
 	s3c2440.c \
 	s3c2443.c \
 	s3c6400.c \
-	at91sam9.c
+	at91sam9.c \
+	nuc910.c
 
 noinst_HEADERS = \
 	arm_io.h \
@@ -39,6 +40,7 @@ noinst_HEADERS = \
 	mx2.h \
 	mx3.h \
 	s3c24xx.h \
-	s3c24xx_regs.h
+	s3c24xx_regs.h \
+	nuc910.h
 
 MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
index 597d78a..522dfa4 100644
--- a/src/flash/nand/driver.c
+++ b/src/flash/nand/driver.c
@@ -40,6 +40,7 @@ extern struct nand_flash_controller s3c6400_nand_controller;
 extern struct nand_flash_controller imx27_nand_flash_controller;
 extern struct nand_flash_controller imx31_nand_flash_controller;
 extern struct nand_flash_controller at91sam9_nand_controller;
+extern struct nand_flash_controller nuc910_nand_controller;
 
 /* extern struct nand_flash_controller boundary_scan_nand_controller; */
 
@@ -57,6 +58,7 @@ static struct nand_flash_controller *nand_flash_controllers[] =
 	&imx27_nand_flash_controller,
 	&imx31_nand_flash_controller,
 	&at91sam9_nand_controller,
+	&nuc910_nand_controller,
 /*	&boundary_scan_nand_controller, */
 	NULL
 };
diff --git a/src/flash/nand/nuc910.c b/src/flash/nand/nuc910.c
new file mode 100644
index 0000000..26d377f
--- /dev/null
+++ b/src/flash/nand/nuc910.c
@@ -0,0 +1,240 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/*
+ * NAND controller interface for Nuvoton NUC910
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include "nuc910.h"
+#include "arm_io.h"
+#include <target/arm.h>
+
+struct nuc910_nand_controller
+{
+	struct target *target;
+	struct arm_nand_data io;
+};
+
+static int validate_target_state(struct nand_device *nand)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	struct target *target = nuc910_nand->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+static int nuc910_nand_command(struct nand_device *nand, uint8_t command)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	struct target *target = nuc910_nand->target;
+	int result;
+
+	if ((result = validate_target_state(nand)) != ERROR_OK)
+		return result;
+
+	target_write_u8(target, NUC910_SMCMD, command);
+	return ERROR_OK;
+}
+
+static int nuc910_nand_address(struct nand_device *nand, uint8_t address)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	struct target *target = nuc910_nand->target;
+	int result;
+
+	if ((result = validate_target_state(nand)) != ERROR_OK)
+		return result;
+
+	target_write_u32(target, NUC910_SMADDR, ((address & 0xff) | NUC910_SMADDR_EOA));
+	return ERROR_OK;
+}
+
+static int nuc910_nand_read(struct nand_device *nand, void *data)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	struct target *target = nuc910_nand->target;
+	int result;
+
+	if ((result = validate_target_state(nand)) != ERROR_OK)
+		return result;
+
+	target_read_u8(target, NUC910_SMDATA, data);
+	return ERROR_OK;
+}
+
+static int nuc910_nand_write(struct nand_device *nand, uint16_t data)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	struct target *target = nuc910_nand->target;
+	int result;
+
+	if ((result = validate_target_state(nand)) != ERROR_OK)
+		return result;
+
+	target_write_u8(target, NUC910_SMDATA, data);
+	return ERROR_OK;
+}
+
+static int nuc910_nand_read_block_data(struct nand_device *nand,
+		uint8_t *data, int data_size)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	int result;
+
+	if ((result = validate_target_state(nand)) != ERROR_OK)
+		return result;
+
+	nuc910_nand->io.chunk_size = nand->page_size;
+
+	/* try the fast way first */
+	result = arm_nandread(&nuc910_nand->io, data, data_size);
+	if (result != ERROR_NAND_NO_BUFFER)
+		return result;
+
+	/* else do it slowly */
+	while (data_size--)
+		nuc910_nand_read(nand, data++);
+
+	return ERROR_OK;
+}
+
+static int nuc910_nand_write_block_data(struct nand_device *nand,
+		uint8_t *data, int data_size)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	int result;
+
+	if ((result = validate_target_state(nand)) != ERROR_OK)
+		return result;
+
+	nuc910_nand->io.chunk_size = nand->page_size;
+
+	/* try the fast way first */
+	result = arm_nandwrite(&nuc910_nand->io, data, data_size);
+	if (result != ERROR_NAND_NO_BUFFER)
+		return result;
+
+	/* else do it slowly */
+	while (data_size--)
+		nuc910_nand_write(nand, *data++);
+
+	return ERROR_OK;
+}
+
+static int nuc910_nand_reset(struct nand_device *nand)
+{
+	return nuc910_nand_command(nand, NAND_CMD_RESET);
+}
+
+static int nuc910_nand_ready(struct nand_device *nand, int timeout)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	struct target *target = nuc910_nand->target;
+	uint32_t status;
+
+	do {
+		target_read_u32(target, NUC910_SMISR, &status);
+		if (status & NUC910_SMISR_RB_) {
+			return 1;
+		}
+		alive_sleep(1);
+	} while (timeout-- > 0);
+
+	return 0;
+}
+
+NAND_DEVICE_COMMAND_HANDLER(nuc910_nand_device_command)
+{
+	struct nuc910_nand_controller *nuc910_nand;
+
+	nuc910_nand = calloc(1, sizeof(struct nuc910_nand_controller));
+	if (!nuc910_nand) {
+		LOG_ERROR("no memory for nand controller\n");
+		return ERROR_NAND_DEVICE_INVALID;
+	}
+
+	nand->controller_priv = nuc910_nand;
+	nuc910_nand->target = get_target(CMD_ARGV[1]);
+	if (!nuc910_nand->target) {
+		LOG_ERROR("target '%s' not defined", CMD_ARGV[1]);
+		free(nuc910_nand);
+		return ERROR_NAND_DEVICE_INVALID;
+	}
+
+	return ERROR_OK;
+}
+
+static int nuc910_nand_init(struct nand_device *nand)
+{
+	struct nuc910_nand_controller *nuc910_nand = nand->controller_priv;
+	struct target *target = nuc910_nand->target;
+	int bus_width = nand->bus_width ? : 8;
+	int result;
+
+	if ((result = validate_target_state(nand)) != ERROR_OK)
+		return result;
+
+	/* nuc910 only supports 8bit */
+	if (bus_width != 8)
+	{
+		LOG_ERROR("nuc910 only supports 8 bit bus width, not %i", bus_width);
+		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+	}
+
+	/* inform calling code about selected bus width */
+	nand->bus_width = bus_width;
+
+	nuc910_nand->io.target = target;
+	nuc910_nand->io.data = NUC910_SMDATA;
+	nuc910_nand->io.op = ARM_NAND_NONE;
+
+	/* configure nand controller */
+	target_write_u32(target, NUC910_FMICSR, NUC910_FMICSR_SM_EN);
+	target_write_u32(target, NUC910_SMCSR, 0x010000a8);	/* 2048 page size */
+	target_write_u32(target, NUC910_SMTCR, 0x00010204);
+	target_write_u32(target, NUC910_SMIER, 0x00000000);
+
+	return ERROR_OK;
+}
+
+struct nand_flash_controller nuc910_nand_controller =
+{
+	.name = "nuc910",
+	.command = nuc910_nand_command,
+	.address = nuc910_nand_address,
+	.read_data = nuc910_nand_read,
+	.write_data	= nuc910_nand_write,
+	.write_block_data = nuc910_nand_write_block_data,
+	.read_block_data = nuc910_nand_read_block_data,
+	.nand_ready = nuc910_nand_ready,
+	.reset = nuc910_nand_reset,
+	.nand_device_command = nuc910_nand_device_command,
+	.init = nuc910_nand_init,
+};
diff --git a/src/flash/nand/nuc910.h b/src/flash/nand/nuc910.h
new file mode 100644
index 0000000..644502f
--- /dev/null
+++ b/src/flash/nand/nuc910.h
@@ -0,0 +1,60 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/*
+ * NAND controller interface for Nuvoton NUC910
+ */
+
+#ifndef NUC910_H
+#define NUC910_H
+
+#define NUC910_FMICSR	0xB000D000
+#define NUC910_SMCSR	0xB000D0A0
+#define NUC910_SMTCR	0xB000D0A4
+#define NUC910_SMIER	0xB000D0A8
+#define NUC910_SMISR	0xB000D0AC
+#define NUC910_SMCMD	0xB000D0B0
+#define NUC910_SMADDR	0xB000D0B4
+#define NUC910_SMDATA	0xB000D0B8
+
+#define NUC910_SMECC0	0xB000D0BC
+#define NUC910_SMECC1	0xB000D0C0
+#define NUC910_SMECC2	0xB000D0C4
+#define NUC910_SMECC3	0xB000D0C8
+#define NUC910_ECC4ST	0xB000D114
+
+/* Global Control and Status Register (FMICSR) */
+#define NUC910_FMICSR_SM_EN	(1<<3)
+
+/* NAND Flash Address Port Register (SMADDR) */
+#define NUC910_SMADDR_EOA (1<<31)
+
+/* NAND Flash Control and Status Register (SMCSR) */
+#define NUC910_SMCSR_PSIZE	(1<<3)
+#define NUC910_SMCSR_DBW	(1<<4)
+
+/* NAND Flash Interrupt Status Register (SMISR) */
+#define NUC910_SMISR_ECC_IF	(1<<2)
+#define NUC910_SMISR_RB_	(1<<18)
+
+/* ECC4 Correction Status (ECC4ST) */
+
+#endif /* NUC910_H */
+
diff --git a/tcl/board/rsc-w910.cfg b/tcl/board/rsc-w910.cfg
index eba44f6..423fb8f 100644
--- a/tcl/board/rsc-w910.cfg
+++ b/tcl/board/rsc-w910.cfg
@@ -21,6 +21,9 @@ $_TARGETNAME configure -work-area-phys 0x00000000 -work-area-size 0x04000000 -wo
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME cfi 0x20000000 0x00200000 2 2 $_TARGETNAME
 
+set _NANDNAME $_CHIPNAME.nand
+nand device $_NANDNAME nuc910 $_TARGETNAME
+
 #
 # Target events
 #

commit 0345667642e13ef2c78dc904677541d2b935d831
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jul 16 17:01:32 2010 +0100

    nand: nand probe also outputs manufacturer
    
    The nand probe now outputs the manufacturer if found.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 592277e..7b84888 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -147,7 +147,8 @@ COMMAND_HANDLER(handle_nand_probe_command)
 
 	if ((retval = nand_probe(p)) == ERROR_OK)
 	{
-		command_print(CMD_CTX, "NAND flash device '%s' found", p->device->name);
+		command_print(CMD_CTX, "NAND flash device '%s (%s)' found",
+				p->device->name, p->manufacturer->name);
 	}
 	else if (retval == ERROR_NAND_OPERATION_FAILED)
 	{

commit 8f5e84bf8dabfddc6b853c522fdc29be90c93746
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jul 16 16:59:35 2010 +0100

    cfg: update rsc-w910 script
    
     - Only enable the FMI (NAND) and DMA clocks.
     - Select NAND interface on the MFSEL.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/rsc-w910.cfg b/tcl/board/rsc-w910.cfg
index f7095a6..eba44f6 100644
--- a/tcl/board/rsc-w910.cfg
+++ b/tcl/board/rsc-w910.cfg
@@ -31,11 +31,12 @@ $_TARGETNAME configure -event reset-init {
 	# switch on PLL for 200MHz operation
 	# running from 15MHz input clock
 	
-	mww 0xB0000200 0x45180bb1 # CLKEN
+	mww 0xB0000200 0x00000030 # CLKEN
 	mww 0xB0000204 0x00000f3c # CLKSEL
 	mww 0xB0000208 0x05007000 # CLKDIV
 	mww 0xB000020C 0x00004f24 # PLLCON0
 	mww 0xB0000210 0x00002b63 # PLLCON1
+	mww 0xB000000C 0x08817fa6 # MFSEL
 	sleep 10
 	
 	# we are now running @ 200MHz

commit d249057adfeb3f652df86ad321577744910b6e21
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jul 16 16:56:41 2010 +0100

    docs: missing parameter from nand check_bad_blocks
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 8f47cd1..08578fa 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -5160,7 +5160,7 @@ be removed in a future release.
 @section Other NAND commands
 @cindex NAND other commands
 
- at deffn Command {nand check_bad_blocks} [offset length]
+ at deffn Command {nand check_bad_blocks} num [offset length]
 Checks for manufacturer bad block markers on the specified NAND
 device.  If no parameters are provided, checks the whole
 device; otherwise, starts at the specified @var{offset} and

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi                                   |    2 +-
 src/flash/nand/Makefile.am                         |    6 +-
 src/flash/nand/driver.c                            |    2 +
 src/flash/nand/nuc910.c                            |  240 ++++++++++++++++++++
 .../libdcc/example.c => src/flash/nand/nuc910.h    |   80 ++++----
 src/flash/nand/tcl.c                               |    3 +-
 tcl/board/rsc-w910.cfg                             |    6 +-
 7 files changed, 295 insertions(+), 44 deletions(-)
 create mode 100644 src/flash/nand/nuc910.c
 copy contrib/libdcc/example.c => src/flash/nand/nuc910.h (57%)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Jul 19 18:33:15 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 19 Jul 2010 16:33:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-430-g8dbe367
Message-ID: <E1OatHL-0007qu-H7@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8dbe367c53682b1217f0f5d599a7a79bf0415796 (commit)
      from  4611f87f0aeba42d21fc6c197e904a0c97731bf7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8dbe367c53682b1217f0f5d599a7a79bf0415796
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 19 17:31:38 2010 +0100

    cfg: add Amontec JTAGkey2p interface config (Issue #26)
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/interface/jtagkey2p.cfg b/tcl/interface/jtagkey2p.cfg
new file mode 100644
index 0000000..98a9417
--- /dev/null
+++ b/tcl/interface/jtagkey2p.cfg
@@ -0,0 +1,11 @@
+#
+# Amontec JTAGkey2P
+#
+# http://www.amontec.com/jtagkey2p.shtml
+#
+
+interface ft2232
+ft2232_device_desc "Amontec JTAGkey-2P"
+ft2232_layout jtagkey
+ft2232_vid_pid 0x0403 0xCFF8
+

-----------------------------------------------------------------------

Summary of changes:
 tcl/interface/jtagkey2p.cfg |   11 +++++++++++
 1 files changed, 11 insertions(+), 0 deletions(-)
 create mode 100644 tcl/interface/jtagkey2p.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Jul 19 22:09:08 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 19 Jul 2010 20:09:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-431-g6121841
Message-ID: <E1OaweJ-0003SB-8P@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  612184176fee6333e5372c4637e3cf54628ee416 (commit)
      from  8dbe367c53682b1217f0f5d599a7a79bf0415796 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 612184176fee6333e5372c4637e3cf54628ee416
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Jul 19 16:08:09 2010 -0400

    more careful luminary init
    
    Set up more of the Luminary-specific signals, and stop cloning
    a few of the JTAG defaults.  More comments too.
    
    Still leaves the "dap info 0" bugs unresolved (presumably coupled
    to this particular adapter family) where TPIU, ITM, DWT, and other
    debug modules wrongly display as extra NVICs.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 4dcc045..1a0eb4b 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -316,7 +316,7 @@ static uint8_t                  nSRSTnOE;
 /** the layout being used with this debug session */
 static const struct ft2232_layout *layout;
 
-/** default bitmask values ddriven on DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
+/** default bitmask values driven on DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
 static uint8_t                  low_output     = 0x0;
 
 /* note that direction bit == 1 means that signal is an output */
@@ -2496,9 +2496,11 @@ static int icdi_jtag_init(void)
 	/* Most Luminary eval boards support SWO trace output,
 	 * and should use this "luminary_icdi" layout.
 	 *
-	 * DBUS 0..3 are used for JTAG as usual.  GPIOs are used
+	 * ADBUS 0..3 are used for JTAG as usual.  GPIOs are used
 	 * to switch between JTAG and SWD, or switch the ft2232 UART
-	 * between (i) the target UART or (ii) SWO trace data.
+	 * on the second MPSSE channel/interface (BDBUS)
+	 * between (i) the stellaris UART (on Luminary boards)
+	 * or (ii) SWO trace data (generic).
 	 *
 	 * We come up in JTAG mode and may switch to SWD later (with
 	 * SWO/trace option if SWD is active).
@@ -2511,18 +2513,21 @@ static int icdi_jtag_init(void)
 #define ICDI_JTAG_EN (1 << 7)		/* ADBUS 7 (a.k.a. DBGMOD) */
 #define ICDI_DBG_ENn (1 << 6)		/* ADBUS 6 */
 #define ICDI_SRST (1 << 5)		/* ADBUS 5 */
-#define ICDI_TDI (1 << 2)		/* ADBUS 2 (INPUT) */
 
+
+	/* GPIOs on second channel/interface (UART) ... */
 #define ICDI_SWO_EN (1 << 4)		/* BDBUS 4 */
 #define ICDI_TX_SWO (1 << 1)	 	/* BDBUS 1 */
+#define ICDI_VCP_RX (1 << 0)	 	/* BDBUS 0 (to stellaris UART) */
 
 	nTRST = 0x0;
 	nTRSTnOE = 0x00;
 	nSRST = ICDI_SRST;
-	nSRSTnOE = 0x20;
+	nSRSTnOE = ICDI_SRST;
 
-	low_output    = 0x08 | ICDI_JTAG_EN;
-	low_direction = 0xcb | ICDI_JTAG_EN;
+	low_direction |= ICDI_JTAG_EN | ICDI_DBG_ENn;
+	low_output    |= ICDI_JTAG_EN;
+	low_output    &= ~ICDI_DBG_ENn;
 
 	return ftx232_dbus_write();
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |   19 ++++++++++++-------
 1 files changed, 12 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jul 19 23:02:21 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 19 Jul 2010 21:02:21 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-443-ga9761c9
Message-ID: <E1OaxTi-0005zk-WD@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a9761c90931101d280b9443126db017f96d92e3d (commit)
       via  441ea95f693316052f04486b927abb2b152ca547 (commit)
       via  4333840ee3d6d79299bf90b719a3c1628c688690 (commit)
       via  5164fe55639877be4dd6a7c0a504aa1bc279d64d (commit)
       via  b62c8d600995638081f9a34c358db58337df7bdb (commit)
       via  a7315891eff5ed84dbd88e950321c6ff2a58e867 (commit)
       via  7dcde11b459f60d40db9ca53f038cd200c852064 (commit)
       via  e7a1ec64bface364305e9c355811838e9f310bf3 (commit)
       via  44ef0327dd97c1893afc63cd7fd8025cb1b57827 (commit)
       via  6c573df11d1c1bc76c897d0688adfd00ec56ca8e (commit)
       via  6a237c23c1adb0be91a82a44d2cf13ff158b3ee2 (commit)
       via  70fee9207b5fd1c6f499b790591446adc4d4467c (commit)
      from  612184176fee6333e5372c4637e3cf54628ee416 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a9761c90931101d280b9443126db017f96d92e3d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 14:49:41 2010 +0200

    arm_dpm: error propagation fixes
    
    found by inspection
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 4fbe5e3..012316b 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -123,6 +123,8 @@ static int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
 		cpsr = mode;
 
 	retval = dpm->instr_write_data_r0(dpm, ARMV4_5_MSR_GP(0, 0xf, 0), cpsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (dpm->instr_cpsr_sync)
 		retval = dpm->instr_cpsr_sync(dpm);
@@ -211,6 +213,8 @@ static int dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 		retval = dpm->instr_write_data_r0(dpm,
 				ARMV4_5_MSR_GP(0, 0xf, regnum & 1),
 				value);
+		if (retval != ERROR_OK)
+			return retval;
 
 		if (regnum == 16 && dpm->instr_cpsr_sync)
 			retval = dpm->instr_cpsr_sync(dpm);
@@ -364,6 +368,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 			retval = dpm_maybe_update_bpwp(dpm, bpwp, &dbp->bpwp,
 					bp ? &bp->set : NULL);
+			if (retval != ERROR_OK)
+				goto done;
 		}
 	}
 
@@ -374,6 +380,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 		retval = dpm_maybe_update_bpwp(dpm, bpwp, &dwp->bpwp,
 				wp ? &wp->set : NULL);
+		if (retval != ERROR_OK)
+			goto done;
 	}
 
 	/* NOTE:  writes to breakpoint and watchpoint registers might
@@ -433,7 +441,11 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 				/* REVISIT error checks */
 				if (tmode != ARM_MODE_ANY)
+				{
 					retval = dpm_modeswitch(dpm, tmode);
+					if (retval != ERROR_OK)
+						goto done;
+				}
 			}
 			if (r->mode != mode)
 				continue;
@@ -441,7 +453,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 			retval = dpm_write_reg(dpm,
 					&cache->reg_list[i],
 					regnum);
-
+			if (retval != ERROR_OK)
+				goto done;
 		}
 
 	} while (did_write);
@@ -451,13 +464,19 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * defined, and must not write it before CPSR.
 	 */
 	retval = dpm_modeswitch(dpm, ARM_MODE_ANY);
+	if (retval != ERROR_OK)
+		goto done;
 	arm->cpsr->dirty = false;
 
 	retval = dpm_write_reg(dpm, arm->pc, 15);
+	if (retval != ERROR_OK)
+		goto done;
 	arm->pc->dirty = false;
 
 	/* flush R0 -- it's *very* dirty by now */
 	retval = dpm_write_reg(dpm, &cache->reg_list[0], 0);
+	if (retval != ERROR_OK)
+		goto done;
 	cache->reg_list[0].dirty = false;
 
 	/* (void) */ dpm->finish(dpm);
@@ -540,6 +559,8 @@ static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
 	}
 
 	retval = dpm_read_reg(dpm, r, regnum);
+	if (retval != ERROR_OK)
+		goto fail;
 	/* always clean up, regardless of error */
 
 	if (mode != ARM_MODE_ANY)
@@ -636,6 +657,8 @@ static int arm_dpm_full_context(struct target *target)
 
 				/* REVISIT error checks */
 				retval = dpm_modeswitch(dpm, mode);
+				if (retval != ERROR_OK)
+					goto done;
 			}
 			if (r->mode != mode)
 				continue;
@@ -644,7 +667,8 @@ static int arm_dpm_full_context(struct target *target)
 			retval = dpm_read_reg(dpm,
 					&cache->reg_list[i],
 					(r->num == 16) ? 17 : r->num);
-
+			if (retval != ERROR_OK)
+				goto done;
 		}
 
 	} while (did_read);

commit 441ea95f693316052f04486b927abb2b152ca547
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 14:42:54 2010 +0200

    adi_jtag_ error propagation
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 185bd54..8731a1a 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -211,8 +211,10 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 	/* Post CTRL/STAT read; discard any previous posted read value
 	 * but collect its ACK status.
 	 */
-	adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+	retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+	if (retval != ERROR_OK)
+		return retval;
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
@@ -246,8 +248,10 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
-			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if (retval != ERROR_OK)
+				return retval;
 			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 			dap->ack = dap->ack & 0x7;
@@ -292,12 +296,16 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 				LOG_ERROR("JTAG-DP STICKY ERROR");
 
 			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_WRITE,
 					dap->dp_ctrl_stat | SSTICKYORUN
 						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			if (retval != ERROR_OK)
+				return retval;
+			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if (retval != ERROR_OK)
+				return retval;
 			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 

commit 4333840ee3d6d79299bf90b719a3c1628c688690
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 14:37:45 2010 +0200

    arm: error propagation of arm_jtag_set_instr
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 0a374be..185bd54 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -86,8 +86,11 @@ int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	struct arm_jtag *jtag_info = dap->jtag_info;
 	struct scan_field fields[2];
 	uint8_t out_addr_buf;
+	int retval;
 
-	arm_jtag_set_instr(jtag_info, instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index b742dae..abfb21b 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -690,9 +690,13 @@ int arm7_9_execute_sys_speed(struct target *target)
 	/* set RESTART instruction */
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		if (retval != ERROR_OK)
+			return retval;
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	long long then = timeval_ms();
 	int timeout;
@@ -738,13 +742,18 @@ static int arm7_9_execute_fast_sys_speed(struct target *target)
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm_jtag *jtag_info = &arm7_9->jtag_info;
 	struct reg *dbg_stat = &arm7_9->eice_cache->reg_list[EICE_DBG_STAT];
+	int retval;
 
 	/* set RESTART instruction */
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		if (retval != ERROR_OK)
+			return retval;
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (!set)
 	{
@@ -1744,13 +1753,19 @@ static int arm7_9_restart_core(struct target *target)
 {
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm_jtag *jtag_info = &arm7_9->jtag_info;
+	int retval;
 
 	/* set RESTART instruction */
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+
+		retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		if (retval != ERROR_OK)
+			return retval;
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	jtag_add_runtest(1, TAP_IDLE);
 	return jtag_execute_queue();
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 541adc8..8befe2b 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -68,7 +68,9 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		{
 			return retval;
 		}
-		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		retval = arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		if (retval != ERROR_OK)
+			return retval;
 
 		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -117,8 +119,11 @@ static __inline int arm7tdmi_clock_out_inner(struct arm_jtag *jtag_info, uint32_
 static __inline int arm7tdmi_clock_out(struct arm_jtag *jtag_info,
 		uint32_t out, uint32_t *deprecated, int breakpoint)
 {
+	int retval;
 	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return arm7tdmi_clock_out_inner(jtag_info, out, breakpoint);
 }
@@ -133,7 +138,9 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
@@ -217,7 +224,9 @@ static int arm7tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 7627b25..c5064c1 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -89,11 +89,14 @@ static int arm920t_read_cp15_physical(struct target *target,
 	uint8_t access_type_buf = 1;
 	uint8_t reg_addr_buf = reg_addr & 0x3f;
 	uint8_t nr_w_buf = 0;
+	int retval;
 
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = &access_type_buf;
@@ -137,13 +140,16 @@ static int arm920t_write_cp15_physical(struct target *target,
 	uint8_t reg_addr_buf = reg_addr & 0x3f;
 	uint8_t nr_w_buf = 1;
 	uint8_t value_buf[4];
+	int retval;
 
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
 	buf_set_u32(value_buf, 0, 32, value);
 
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = &access_type_buf;
@@ -192,7 +198,9 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	buf_set_u32(cp15_opcode_buf, 0, 32, cp15_opcode);
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index aa38d27..3765f23 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -67,7 +67,9 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -120,7 +122,9 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	LOG_DEBUG("addr: 0x%x value: %8.8x", address, *value);
 #endif
 
-	arm_jtag_set_instr(jtag_info, 0xc, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0xc, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return ERROR_OK;
 }
@@ -155,7 +159,9 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
@@ -205,7 +211,9 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	LOG_DEBUG("addr: 0x%x value: %8.8x", address, value);
 #endif
 
-	arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index b4207c8..170e3cc 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -88,7 +88,9 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	/* REVISIT: table 7-2 shows that bits 31-31 need to be
@@ -142,7 +144,9 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 0749a56..fd50703 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -103,7 +103,9 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		{
 			return retval;
 		}
-		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		retval = arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		if (retval != ERROR_OK)
+			return retval;
 
 		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -157,7 +159,9 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
@@ -215,7 +219,9 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -281,7 +287,9 @@ int arm9tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 7ef4ac4..965260c 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -344,10 +344,13 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	struct scan_field fields[3];
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
+	int retval;
 
 	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
-	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* bits 31:0 -- data (ignored here) */
 	fields[0].num_bits = 32;
@@ -405,9 +408,12 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	struct scan_field fields[3];
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
+	int retval;
 
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -487,12 +493,13 @@ static int embeddedice_set_reg_w_exec(struct reg *reg, uint8_t *buf)
 void embeddedice_write_reg(struct reg *reg, uint32_t value)
 {
 	struct embeddedice_reg *ice_reg = reg->arch_info;
+	int retval;
 
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", ice_reg->addr, value);
 
 	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
-	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	uint8_t reg_addr = ice_reg->addr & 0x1f;
 	embeddedice_write_reg_inner(ice_reg->jtag_info->tap, reg_addr, value);
@@ -521,9 +528,12 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	uint8_t field0_out[4];
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
+	int retval;
 
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = field0_out;
@@ -575,7 +585,9 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 		return ERROR_INVALID_ARGUMENTS;
 
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
diff --git a/src/target/etm.c b/src/target/etm.c
index 61ee99a..5c42fb5 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -496,6 +496,7 @@ static int etm_read_reg_w_check(struct reg *reg,
 	const struct etm_reg_info *r = etm_reg->reg_info;
 	uint8_t reg_addr = r->addr & 0x7f;
 	struct scan_field fields[3];
+	int retval;
 
 	if (etm_reg->reg_info->mode == WO) {
 		LOG_ERROR("BUG: can't read write-only register %s", r->name);
@@ -505,7 +506,9 @@ static int etm_read_reg_w_check(struct reg *reg,
 	LOG_DEBUG("%s (%u)", r->name, reg_addr);
 
 	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
-	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg->value;
@@ -577,6 +580,7 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	const struct etm_reg_info *r = etm_reg->reg_info;
 	uint8_t reg_addr = r->addr & 0x7f;
 	struct scan_field fields[3];
+	int retval;
 
 	if (etm_reg->reg_info->mode == RO) {
 		LOG_ERROR("BUG: can't write read--only register %s", r->name);
@@ -586,7 +590,9 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	LOG_DEBUG("%s (%u): 0x%8.8" PRIx32 "", r->name, reg_addr, value);
 
 	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
-	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	uint8_t tmp1[4];
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index ea22ca0..6ca432a 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -78,6 +78,7 @@ static int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 	uint8_t out_buf[4];
 	uint8_t instr_buf[4];
 	uint8_t sysspeed_buf = 0x0;
+	int retval;
 
 	/* prepare buffer */
 	buf_set_u32(out_buf, 0, 32, 0);
@@ -86,7 +87,9 @@ static int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 
 	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;

commit 5164fe55639877be4dd6a7c0a504aa1bc279d64d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 14:22:35 2010 +0200

    arm_adi_v5: dap_run() error propagation
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 39d8bde..b26175b 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -321,7 +321,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 				break;
 		}
 
-		if (dap_run(dap) == ERROR_OK)
+		if ((retval = dap_run(dap)) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address = address + 4 * blocksize;
@@ -335,8 +335,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 		if (errorcount > 1)
 		{
 			LOG_WARNING("Block write error address 0x%" PRIx32 ", wcount 0x%x", address, wcount);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
+			return retval;
 		}
 	}
 
@@ -406,13 +405,12 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(dap) != ERROR_OK)
+				if ((retval = dap_run(dap)) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
 						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 			}
 
@@ -515,13 +513,12 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(dap) != ERROR_OK)
+				if ((retval = dap_run(dap)) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
 						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 			}
 
@@ -712,11 +709,12 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *dap,
 		do
 		{
 			retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
-			if (dap_run(dap) != ERROR_OK)
+			if (retval != ERROR_OK)
+				return retval;
+			if ((retval = dap_run(dap)) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
+				return retval;
 			}
 
 			nbytes = MIN((readcount << 1), 4);
@@ -821,11 +819,12 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *dap,
 		do
 		{
 			retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
-			if (dap_run(dap) != ERROR_OK)
+			if (retval != ERROR_OK)
+				return retval;
+			if ((retval = dap_run(dap)) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
+				return retval;
 			}
 
 			nbytes = MIN(readcount, 4);
@@ -993,7 +992,11 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	 * place to scan the table and do any topology detection?
 	 */
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &idreg);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &romaddr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((retval = dap_run(dap)) != ERROR_OK)
 		return retval;
@@ -1039,7 +1042,11 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	apselold = dap->apsel;
 	dap_ap_select(dap, apsel);
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &dbgbase);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1490,6 +1497,8 @@ COMMAND_HANDLER(dap_baseaddr_command)
 	 * use the ID register to verify it's a MEM-AP.
 	 */
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &baseaddr);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1553,6 +1562,8 @@ COMMAND_HANDLER(dap_apsel_command)
 
 	dap_ap_select(dap, apsel);
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1591,6 +1602,8 @@ COMMAND_HANDLER(dap_apid_command)
 		dap_ap_select(dap, apsel);
 
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;

commit b62c8d600995638081f9a34c358db58337df7bdb
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 14:03:33 2010 +0200

    arm_adi_v5: mem_ap_write error propagation
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 194865e..39d8bde 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -376,13 +376,14 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 
 			if (nbytes < 4)
 			{
-				if (mem_ap_write_buf_u16(dap, buffer,
-						nbytes, address) != ERROR_OK)
+				retval = mem_ap_write_buf_u16(dap, buffer,
+						nbytes, address);
+				if (retval != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
 						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 
 				address += nbytes >> 1;
@@ -485,12 +486,13 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 
 			if (nbytes < 4)
 			{
-				if (mem_ap_write_buf_u8(dap, buffer, nbytes, address) != ERROR_OK)
+				retval = mem_ap_write_buf_u8(dap, buffer, nbytes, address);
+				if (retval != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
 						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 
 				address += nbytes;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 7bdf7d5..2a58f5b 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -166,7 +166,9 @@ static int cortex_m3_clear_halt(struct target *target)
 		return retval;
 
 	/* Clear Debug Fault Status */
-	mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3->nvic_dfsr);
+	retval = mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3->nvic_dfsr);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(" NVIC_DFSR 0x%" PRIx32 "", cortex_m3->nvic_dfsr);
 
 	return ERROR_OK;
@@ -177,6 +179,7 @@ static int cortex_m3_single_step_core(struct target *target)
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 	uint32_t dhcsr_save;
+	int retval;
 
 	/* backup dhcsr reg */
 	dhcsr_save = cortex_m3->dcb_dhcsr;
@@ -186,10 +189,16 @@ static int cortex_m3_single_step_core(struct target *target)
 	 * HALT can put the core into an unknown state.
 	 */
 	if (!(cortex_m3->dcb_dhcsr & C_MASKINTS))
-		mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+	{
+		retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
 				DBGKEY | C_MASKINTS | C_HALT | C_DEBUGEN);
-	mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
 				DBGKEY | C_MASKINTS | C_STEP | C_DEBUGEN);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(" ");
 
 	/* restore dhcsr reg */
@@ -217,14 +226,20 @@ static int cortex_m3_endreset_event(struct target *target)
 	LOG_DEBUG("DCB_DEMCR = 0x%8.8" PRIx32 "",dcb_demcr);
 
 	/* this register is used for emulated dcc channel */
-	mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	retval = mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Enable debug requests */
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m3->dcb_dhcsr & C_DEBUGEN))
-		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+	{
+		retval = mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	/* clear any interrupt masking */
 	cortex_m3_write_debug_halt_mask(target, 0, C_MASKINTS);
@@ -236,31 +251,44 @@ static int cortex_m3_endreset_event(struct target *target)
 	 * choices *EXCEPT* explicitly scripted overrides like "vector_catch"
 	 * or manual updates to the NVIC SHCSR and CCR registers.
 	 */
-	mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | armv7m->demcr);
+	retval = mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | armv7m->demcr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Paranoia: evidently some (early?) chips don't preserve all the
 	 * debug state (including FBP, DWT, etc) across reset...
 	 */
 
 	/* Enable FPB */
-	target_write_u32(target, FP_CTRL, 3);
+	retval = target_write_u32(target, FP_CTRL, 3);
+	if (retval != ERROR_OK)
+		return retval;
+
 	cortex_m3->fpb_enabled = 1;
 
 	/* Restore FPB registers */
 	for (i = 0; i < cortex_m3->fp_num_code + cortex_m3->fp_num_lit; i++)
 	{
-		target_write_u32(target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
+		retval = target_write_u32(target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	/* Restore DWT registers */
 	for (i = 0; i < cortex_m3->dwt_num_comp; i++)
 	{
-		target_write_u32(target, dwt_list[i].dwt_comparator_address + 0,
+		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 0,
 				dwt_list[i].comp);
-		target_write_u32(target, dwt_list[i].dwt_comparator_address + 4,
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 4,
 				dwt_list[i].mask);
-		target_write_u32(target, dwt_list[i].dwt_comparator_address + 8,
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 8,
 				dwt_list[i].function);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	retval = dap_run(swjdp);
 	if (retval != ERROR_OK)
@@ -639,12 +667,16 @@ static int cortex_m3_soft_reset_halt(struct target *target)
 	int retval, timeout = 0;
 
 	/* Enter debug state on reset; restore DEMCR in endreset_event() */
-	mem_ap_write_u32(swjdp, DCB_DEMCR,
+	retval = mem_ap_write_u32(swjdp, DCB_DEMCR,
 			TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Request a core-only reset */
-	mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+	retval = mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
 			AIRCR_VECTKEY | AIRCR_VECTRESET);
+	if (retval != ERROR_OK)
+		return retval;
 	target->state = TARGET_RESET;
 
 	/* registers are now invalid */
@@ -902,16 +934,26 @@ static int cortex_m3_assert_reset(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m3->dcb_dhcsr & C_DEBUGEN))
-		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+	{
+		retval = mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
-	mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	retval = mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (!target->reset_halt)
 	{
 		/* Set/Clear C_MASKINTS in a separate operation */
 		if (cortex_m3->dcb_dhcsr & C_MASKINTS)
-			mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+		{
+			retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
 					DBGKEY | C_DEBUGEN | C_HALT);
+			if (retval != ERROR_OK)
+				return retval;
+		}
 
 		/* clear any debug flags before resuming */
 		cortex_m3_clear_halt(target);
@@ -927,8 +969,10 @@ static int cortex_m3_assert_reset(struct target *target)
 		 * bad vector table entries.  Should this include MMERR or
 		 * other flags too?
 		 */
-		mem_ap_write_atomic_u32(swjdp, DCB_DEMCR,
+		retval = mem_ap_write_atomic_u32(swjdp, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	/*
@@ -992,8 +1036,10 @@ static int cortex_m3_assert_reset(struct target *target)
 		 * core, like watchdog timers, if the SoC wires it up
 		 * correctly.  Else VECRESET can reset just the core.
 		 */
-		mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+		retval = mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
 				AIRCR_VECTKEY | AIRCR_SYSRESETREQ);
+		if (retval != ERROR_OK)
+			return retval;
 		LOG_DEBUG("Using Cortex-M3 SYSRESETREQ");
 
 		{
@@ -1834,6 +1880,7 @@ static int cortex_m3_examine(struct target *target)
 static int cortex_m3_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
 {
 	uint16_t dcrdr;
+	int retval;
 
 	mem_ap_read_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
 	*ctrl = (uint8_t)dcrdr;
@@ -1846,7 +1893,9 @@ static int cortex_m3_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *
 	if (dcrdr & (1 << 0))
 	{
 		dcrdr = 0;
-		mem_ap_write_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
+		retval = mem_ap_write_buf_u16(swjdp, (uint8_t*)&dcrdr, 1, DCB_DCRDR);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	return ERROR_OK;
@@ -2041,7 +2090,9 @@ write:
 		demcr |= catch;
 
 		/* write, but don't assume it stuck (why not??) */
-		mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
+		retval = mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
 		if (retval != ERROR_OK)
 			return retval;

commit a7315891eff5ed84dbd88e950321c6ff2a58e867
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 13:56:59 2010 +0200

    arm_adi_v5: error propagation of mem_ap_read_atomic_u32 failure
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 496360f..194865e 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1124,7 +1124,9 @@ static int dap_info_command(struct command_context *cmd_ctx,
 		entry_offset = 0;
 		do
 		{
-			mem_ap_read_atomic_u32(dap, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
+			retval = mem_ap_read_atomic_u32(dap, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
+			if (retval != ERROR_OK)
+				return retval;
 			command_print(cmd_ctx, "\tROMTABLE[0x%x] = 0x%" PRIx32 "",entry_offset,romentry);
 			if (romentry&0x01)
 			{
@@ -1140,33 +1142,51 @@ static int dap_info_command(struct command_context *cmd_ctx,
 				/* IDs are in last 4K section */
 
 
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFE0, &c_pid0);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid0 &= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFE4, &c_pid1);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid1 &= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFE8, &c_pid2);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid2 &= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFEC, &c_pid3);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid3 &= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFD0, &c_pid4);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid4 &= 0xff;
 
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFF0, &c_cid0);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid0 &= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFF4, &c_cid1);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid1 &= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFF8, &c_cid2);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid2 &= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFFC, &c_cid3);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid3 &= 0xff;
 
 
@@ -1187,9 +1207,11 @@ static int dap_info_command(struct command_context *cmd_ctx,
 					unsigned minor;
 					char *major = "Reserved", *subtype = "Reserved";
 
-					mem_ap_read_atomic_u32(dap,
+					retval = mem_ap_read_atomic_u32(dap,
 							(component_base & 0xfffff000) | 0xfcc,
 							&devtype);
+					if (retval != ERROR_OK)
+						return retval;
 					minor = (devtype >> 4) & 0x0f;
 					switch (devtype & 0x0f) {
 					case 0:
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 6939890..7bdf7d5 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -155,12 +155,15 @@ static int cortex_m3_clear_halt(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
+	int retval;
 
 	/* clear step if any */
 	cortex_m3_write_debug_halt_mask(target, C_HALT, C_STEP);
 
 	/* Read Debug Fault Status Register */
-	mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &cortex_m3->nvic_dfsr);
+	retval = mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &cortex_m3->nvic_dfsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Clear Debug Fault Status */
 	mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3->nvic_dfsr);
@@ -208,14 +211,18 @@ static int cortex_m3_endreset_event(struct target *target)
 	struct cortex_m3_dwt_comparator *dwt_list = cortex_m3->dwt_comparator_list;
 
 	/* REVISIT The four debug monitor bits are currently ignored... */
-	mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &dcb_demcr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &dcb_demcr);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG("DCB_DEMCR = 0x%8.8" PRIx32 "",dcb_demcr);
 
 	/* this register is used for emulated dcc channel */
 	mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
 
 	/* Enable debug requests */
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 	if (!(cortex_m3->dcb_dhcsr & C_DEBUGEN))
 		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
 
@@ -262,7 +269,7 @@ static int cortex_m3_endreset_event(struct target *target)
 	register_cache_invalidate(cortex_m3->armv7m.core_cache);
 
 	/* make sure we have latest dhcsr flags */
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
 
 	return retval;
 }
@@ -396,7 +403,9 @@ static int cortex_m3_debug_entry(struct target *target)
 	LOG_DEBUG(" ");
 
 	cortex_m3_clear_halt(target);
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((retval = armv7m->examine_debug_reason(target)) != ERROR_OK)
 		return retval;
@@ -508,13 +517,17 @@ static int cortex_m3_poll(struct target *target)
 		target->debug_reason = DBG_REASON_DBGRQ;
 
 		/* refresh status bits */
-		mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	if (cortex_m3->dcb_dhcsr & S_RESET_ST)
 	{
 		/* check if still in reset */
-		mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+		if (retval != ERROR_OK)
+			return retval;
 
 		if (cortex_m3->dcb_dhcsr & S_RESET_ST)
 		{
@@ -642,8 +655,10 @@ static int cortex_m3_soft_reset_halt(struct target *target)
 		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &dcb_dhcsr);
 		if (retval == ERROR_OK)
 		{
-			mem_ap_read_atomic_u32(swjdp, NVIC_DFSR,
+			retval = mem_ap_read_atomic_u32(swjdp, NVIC_DFSR,
 					&cortex_m3->nvic_dfsr);
+			if (retval != ERROR_OK)
+				return retval;
 			if ((dcb_dhcsr & S_HALT)
 					&& (cortex_m3->nvic_dfsr & DFSR_VCATCH))
 			{
@@ -835,7 +850,10 @@ static int cortex_m3_step(struct target *target, int current,
 		cortex_m3_write_debug_halt_mask(target, C_STEP, C_HALT);
 	}
 
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	int retval;
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* registers are now invalid */
 	register_cache_invalidate(cortex_m3->armv7m.core_cache);
@@ -847,7 +865,6 @@ static int cortex_m3_step(struct target *target, int current,
 			" nvic_icsr = 0x%" PRIx32,
 			cortex_m3->dcb_dhcsr, cortex_m3->nvic_icsr);
 
-	int retval;
 	retval = cortex_m3_debug_entry(target);
 	if (retval != ERROR_OK)
 		return retval;
@@ -880,7 +897,10 @@ static int cortex_m3_assert_reset(struct target *target)
 		assert_srst = 0;
 
 	/* Enable debug requests */
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	int retval;
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 	if (!(cortex_m3->dcb_dhcsr & C_DEBUGEN))
 		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
 
@@ -982,7 +1002,9 @@ static int cortex_m3_assert_reset(struct target *target)
 			 * after reset) on LM3S6918 -- Michael Schwingen
 			 */
 			uint32_t tmp;
-			mem_ap_read_atomic_u32(swjdp, NVIC_AIRCR, &tmp);
+			retval = mem_ap_read_atomic_u32(swjdp, NVIC_AIRCR, &tmp);
+			if (retval != ERROR_OK)
+				return retval;
 		}
 	}
 
@@ -993,7 +1015,6 @@ static int cortex_m3_assert_reset(struct target *target)
 
 	if (target->reset_halt)
 	{
-		int retval;
 		if ((retval = target_halt(target)) != ERROR_OK)
 			return retval;
 	}
@@ -1982,7 +2003,9 @@ COMMAND_HANDLER(handle_cortex_m3_vector_catch_command)
 	if (retval != ERROR_OK)
 		return retval;
 
-	mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (CMD_ARGC > 0) {
 		unsigned catch = 0;
@@ -2019,7 +2042,9 @@ write:
 
 		/* write, but don't assume it stuck (why not??) */
 		mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
-		mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+		retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* FIXME be sure to clear DEMCR on clean server shutdown.
 		 * Otherwise the vector catch hardware could fire when there's

commit 7dcde11b459f60d40db9ca53f038cd200c852064
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 13:50:28 2010 +0200

    mem_ap_read_u32 error propagation
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 9a33d82..496360f 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1088,11 +1088,21 @@ static int dap_info_command(struct command_context *cmd_ctx,
 			command_print(cmd_ctx, "\tROM table in legacy format");
 
 		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
-		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
-		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
-		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
-		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
+		retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			return retval;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index d6090f5..6939890 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -68,7 +68,9 @@ static int cortexm3_dap_read_coreregister_u32(struct adiv5_dap *swjdp,
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we have to save/restore the DCB_DCRDR when used */
 
-	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
+	retval = mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, regnum); */
 	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
@@ -107,7 +109,9 @@ static int cortexm3_dap_write_coreregister_u32(struct adiv5_dap *swjdp,
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we have to save/restore the DCB_DCRDR when used */
 
-	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
+	retval = mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRDR, core_regs[i]); */
 	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
@@ -297,33 +301,51 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 	struct adiv5_dap *swjdp = &armv7m->dap;
 	int retval;
 
-	mem_ap_read_u32(swjdp, NVIC_SHCSR, &shcsr);
+	retval = mem_ap_read_u32(swjdp, NVIC_SHCSR, &shcsr);
+	if (retval != ERROR_OK)
+		return retval;
 	switch (armv7m->exception_number)
 	{
 		case 2:	/* NMI */
 			break;
 		case 3:	/* Hard Fault */
-			mem_ap_read_atomic_u32(swjdp, NVIC_HFSR, &except_sr);
+			retval = mem_ap_read_atomic_u32(swjdp, NVIC_HFSR, &except_sr);
+			if (retval != ERROR_OK)
+				return retval;
 			if (except_sr & 0x40000000)
 			{
-				mem_ap_read_u32(swjdp, NVIC_CFSR, &cfsr);
+				retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &cfsr);
+				if (retval != ERROR_OK)
+					return retval;
 			}
 			break;
 		case 4:	/* Memory Management */
-			mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
-			mem_ap_read_u32(swjdp, NVIC_MMFAR, &except_ar);
+			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = mem_ap_read_u32(swjdp, NVIC_MMFAR, &except_ar);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 5:	/* Bus Fault */
-			mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
-			mem_ap_read_u32(swjdp, NVIC_BFAR, &except_ar);
+			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = mem_ap_read_u32(swjdp, NVIC_BFAR, &except_ar);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 6:	/* Usage Fault */
-			mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
+			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 11:	/* SVCall */
 			break;
 		case 12:	/* Debug Monitor */
-			mem_ap_read_u32(swjdp, NVIC_DFSR, &except_sr);
+			retval = mem_ap_read_u32(swjdp, NVIC_DFSR, &except_sr);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 14:	/* PendSV */
 			break;

commit e7a1ec64bface364305e9c355811838e9f310bf3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 13:45:53 2010 +0200

    arm_adi_v5: add error propagation for dap_setup_accessport
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index dfb45b4..9a33d82 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -5,7 +5,7 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   spen at spen-soft.co.uk                                                  *
  *                                                                         *
- *   Copyright (C) 2009 by Oyvind Harboe                                   *
+ *   Copyright (C) 2009-2010 by Oyvind Harboe                              *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2009-2010 by David Brownell                             *
@@ -309,7 +309,9 @@ int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 
 		for (writecount = 0; writecount < blocksize; writecount++)
 		{
@@ -363,7 +365,9 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 		writecount = blocksize;
 
 		do
@@ -430,7 +434,9 @@ int mem_ap_write_buf_u16(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 
 	while (count > 0)
 	{
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		uint16_t svalue;
 		memcpy(&svalue, buffer, sizeof(uint16_t));
 		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
@@ -468,7 +474,9 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 		if (wcount < blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 		writecount = blocksize;
 
 		do
@@ -534,7 +542,9 @@ int mem_ap_write_buf_u8(struct adiv5_dap *dap, uint8_t *buffer, int count, uint3
 
 	while (count > 0)
 	{
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
 		retval = dap_queue_ap_write(dap, AP_REG_DRW, outvalue);
 		if (retval != ERROR_OK)
@@ -592,8 +602,10 @@ int mem_ap_read_buf_u32(struct adiv5_dap *dap, uint8_t *buffer,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE,
+		retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE,
 				address);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* FIXME remove these three calls to adi_jtag_dp_scan(),
 		 * so this routine becomes transport-neutral.  Be careful
@@ -686,7 +698,9 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *dap,
 		if (wcount < blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
@@ -739,7 +753,9 @@ int mem_ap_read_buf_u16(struct adiv5_dap *dap, uint8_t *buffer,
 
 	while (count > 0)
 	{
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
 		if (retval != ERROR_OK)
 			break;
@@ -795,7 +811,9 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *dap,
 		if (wcount < blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 		readcount = blocksize;
 
 		do
@@ -844,8 +862,12 @@ int mem_ap_read_buf_u8(struct adiv5_dap *dap, uint8_t *buffer,
 
 	while (count > 0)
 	{
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 4f3560f..d6090f5 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -71,13 +71,17 @@ static int cortexm3_dap_read_coreregister_u32(struct adiv5_dap *swjdp,
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, regnum); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* mem_ap_read_u32(swjdp, DCB_DCRDR, value); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_read(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
 	if (retval != ERROR_OK)
 		return retval;
@@ -106,12 +110,16 @@ static int cortexm3_dap_write_coreregister_u32(struct adiv5_dap *swjdp,
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRDR, core_regs[i]); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
 	// XXX check retval
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, i | DCRSR_WnR); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum | DCRSR_WnR);
 	// XXX check retval
 

commit 44ef0327dd97c1893afc63cd7fd8025cb1b57827
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 12:34:54 2010 +0200

    debug: debug entry error propagation
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 36bbaba..67f0524 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -439,7 +439,7 @@ static int arm11_halt(struct target *target)
 
 	enum target_state old_state	= target->state;
 
-	arm11_debug_entry(arm11);
+	CHECK_RETVAL(arm11_debug_entry(arm11));
 
 	CHECK_RETVAL(
 		target_call_event_callbacks(target,
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 6bf38bb..96e0baa 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -202,13 +202,18 @@ static int arm720t_enable_mmu_caches(struct target *target,
 	return retval;
 }
 
-static void arm720t_post_debug_entry(struct target *target)
+static int arm720t_post_debug_entry(struct target *target)
 {
 	struct arm720t_common *arm720t = target_to_arm720(target);
+	int retval;
 
 	/* examine cp15 control reg */
-	arm720t_read_cp15(target, 0xee110f10, &arm720t->cp15_control_reg);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee110f10, &arm720t->cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32 "", arm720t->cp15_control_reg);
 
 	arm720t->armv4_5_mmu.mmu_enabled = (arm720t->cp15_control_reg & 0x1U) ? 1 : 0;
@@ -216,9 +221,14 @@ static void arm720t_post_debug_entry(struct target *target)
 	arm720t->armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
 
 	/* save i/d fault status and address register */
-	arm720t_read_cp15(target, 0xee150f10, &arm720t->fsr_reg);
-	arm720t_read_cp15(target, 0xee160f10, &arm720t->far_reg);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee150f10, &arm720t->fsr_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm720t_read_cp15(target, 0xee160f10, &arm720t->far_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	return retval;
 }
 
 static void arm720t_pre_restore_context(struct target *target)
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index abe0c2f..b742dae 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1470,7 +1470,11 @@ static int arm7_9_debug_entry(struct target *target)
 		return retval;
 
 	if (arm7_9->post_debug_entry)
-		arm7_9->post_debug_entry(target);
+	{
+		retval = arm7_9->post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return ERROR_OK;
 }
@@ -1878,7 +1882,9 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 				return err;
 			}
 
-			arm7_9_debug_entry(target);
+			retval = arm7_9_debug_entry(target);
+			if (retval != ERROR_OK)
+				return retval;
 			LOG_DEBUG("new PC after step: 0x%8.8" PRIx32,
 					buf_get_u32(armv4_5->pc->value, 0, 32));
 
@@ -2079,7 +2085,9 @@ int arm7_9_step(struct target *target, int current, uint32_t address, int handle
 	{
 		target->state = TARGET_UNKNOWN;
 	} else {
-		arm7_9_debug_entry(target);
+		retval = arm7_9_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
 		if ((retval = target_call_event_callbacks(target, TARGET_EVENT_HALTED)) != ERROR_OK)
 		{
 			return retval;
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index a741c59..69ea221 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -100,7 +100,7 @@ struct arm7_9_common
 
 	void (*set_special_dbgrq)(struct target *target); /**< Function for setting DBGRQ if the normal way won't work */
 
-	void (*post_debug_entry)(struct target *target); /**< Callback function called after entering debug mode */
+	int (*post_debug_entry)(struct target *target); /**< Callback function called after entering debug mode */
 
 	void (*pre_restore_context)(struct target *target); /**< Callback function called before restoring the processor context */
 };
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index a80a378..7627b25 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -389,24 +389,33 @@ int arm920t_enable_mmu_caches(struct target *target, int mmu,
 }
 
 // EXPORTED to FA256
-void arm920t_post_debug_entry(struct target *target)
+int arm920t_post_debug_entry(struct target *target)
 {
 	uint32_t cp15c15;
 	struct arm920t_common *arm920t = target_to_arm920(target);
+	int retval;
 
 	/* examine cp15 control reg */
-	arm920t_read_cp15_physical(target,
+	retval = arm920t_read_cp15_physical(target,
 			CP15PHYS_CTRL, &arm920t->cp15_control_reg);
-	jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, arm920t->cp15_control_reg);
 
 	if (arm920t->armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
 		uint32_t cache_type_reg;
 		/* identify caches */
-		arm920t_read_cp15_physical(target,
+		retval = arm920t_read_cp15_physical(target,
 				CP15PHYS_CACHETYPE, &cache_type_reg);
-		jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
 		armv4_5_identify_cache(cache_type_reg,
 				&arm920t->armv4_5_mmu.armv4_5_cache);
 	}
@@ -420,10 +429,18 @@ void arm920t_post_debug_entry(struct target *target)
 
 	/* save i/d fault status and address register */
 			/* FIXME use opcode macros */
-	arm920t_read_cp15_interpreted(target, 0xee150f10, 0x0, &arm920t->d_fsr);
-	arm920t_read_cp15_interpreted(target, 0xee150f30, 0x0, &arm920t->i_fsr);
-	arm920t_read_cp15_interpreted(target, 0xee160f10, 0x0, &arm920t->d_far);
-	arm920t_read_cp15_interpreted(target, 0xee160f30, 0x0, &arm920t->i_far);
+	retval = arm920t_read_cp15_interpreted(target, 0xee150f10, 0x0, &arm920t->d_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm920t_read_cp15_interpreted(target, 0xee150f30, 0x0, &arm920t->i_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm920t_read_cp15_interpreted(target, 0xee160f10, 0x0, &arm920t->d_far);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm920t_read_cp15_interpreted(target, 0xee160f30, 0x0, &arm920t->i_far);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("D FSR: 0x%8.8" PRIx32 ", D FAR: 0x%8.8" PRIx32
 		", I FSR: 0x%8.8" PRIx32 ", I FAR: 0x%8.8" PRIx32,
@@ -433,13 +450,20 @@ void arm920t_post_debug_entry(struct target *target)
 	{
 		/* read-modify-write CP15 test state register
 		 * to disable I/D-cache linefills */
-		arm920t_read_cp15_physical(target,
+		retval = arm920t_read_cp15_physical(target,
 				CP15PHYS_TESTSTATE, &cp15c15);
-		jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
 		cp15c15 |= 0x600;
-		arm920t_write_cp15_physical(target,
+		retval = arm920t_write_cp15_physical(target,
 				CP15PHYS_TESTSTATE, cp15c15);
+		if (retval != ERROR_OK)
+			return retval;
 	}
+	return ERROR_OK;
 }
 
 // EXPORTED to FA256
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 20f614d..02d7f83 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -64,7 +64,7 @@ int arm920t_read_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int arm920t_write_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-void arm920t_post_debug_entry(struct target *target);
+int arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
 int arm920t_get_ttb(struct target *target, uint32_t *result);
 int arm920t_disable_mmu_caches(struct target *target,
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index f8a4f62..aa38d27 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -432,21 +432,30 @@ static int arm926ejs_enable_mmu_caches(struct target *target, int mmu,
 	return retval;
 }
 
-static void arm926ejs_post_debug_entry(struct target *target)
+static int arm926ejs_post_debug_entry(struct target *target)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
+	int retval;
 
 	/* examine cp15 control reg */
-	arm926ejs->read_cp15(target, 0, 0, 1, 0, &arm926ejs->cp15_control_reg);
-	jtag_execute_queue();
+	retval = arm926ejs->read_cp15(target, 0, 0, 1, 0, &arm926ejs->cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32 "", arm926ejs->cp15_control_reg);
 
 	if (arm926ejs->armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
 		uint32_t cache_type_reg;
 		/* identify caches */
-		arm926ejs->read_cp15(target, 0, 1, 0, 0, &cache_type_reg);
-		jtag_execute_queue();
+		retval = arm926ejs->read_cp15(target, 0, 1, 0, 0, &cache_type_reg);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
 		armv4_5_identify_cache(cache_type_reg, &arm926ejs->armv4_5_mmu.armv4_5_cache);
 	}
 
@@ -455,9 +464,15 @@ static void arm926ejs_post_debug_entry(struct target *target)
 	arm926ejs->armv4_5_mmu.armv4_5_cache.i_cache_enabled = (arm926ejs->cp15_control_reg & 0x1000U) ? 1 : 0;
 
 	/* save i/d fault status and address register */
-	arm926ejs->read_cp15(target, 0, 0, 5, 0, &arm926ejs->d_fsr);
-	arm926ejs->read_cp15(target, 0, 1, 5, 0, &arm926ejs->i_fsr);
-	arm926ejs->read_cp15(target, 0, 0, 6, 0, &arm926ejs->d_far);
+	retval = arm926ejs->read_cp15(target, 0, 0, 5, 0, &arm926ejs->d_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm926ejs->read_cp15(target, 0, 1, 5, 0, &arm926ejs->i_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm926ejs->read_cp15(target, 0, 0, 6, 0, &arm926ejs->d_far);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("D FSR: 0x%8.8" PRIx32 ", D FAR: 0x%8.8" PRIx32 ", I FSR: 0x%8.8" PRIx32 "",
 		arm926ejs->d_fsr, arm926ejs->d_far, arm926ejs->i_fsr);
@@ -466,9 +481,12 @@ static void arm926ejs_post_debug_entry(struct target *target)
 
 	/* read-modify-write CP15 cache debug control register
 	 * to disable I/D-cache linefills and force WT */
-	arm926ejs->read_cp15(target, 7, 0, 15, 0, &cache_dbg_ctrl);
+	retval = arm926ejs->read_cp15(target, 7, 0, 15, 0, &cache_dbg_ctrl);
+	if (retval != ERROR_OK)
+		return retval;
 	cache_dbg_ctrl |= 0x7;
-	arm926ejs->write_cp15(target, 7, 0, 15, 0, cache_dbg_ctrl);
+	retval = arm926ejs->write_cp15(target, 7, 0, 15, 0, cache_dbg_ctrl);
+	return retval;
 }
 
 static void arm926ejs_pre_restore_context(struct target *target)
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 621761d..f932456 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -62,7 +62,7 @@ struct armv7a_common
 	struct armv4_5_mmu_common armv4_5_mmu;
 
 	int (*examine_debug_reason)(struct target *target);
-	void (*post_debug_entry)(struct target *target);
+	int (*post_debug_entry)(struct target *target);
 
 	void (*pre_restore_context)(struct target *target);
 };
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 57d46ed..8ef3800 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -121,7 +121,7 @@ struct armv7m_common
 	int (*write_core_reg)(struct target *target, unsigned num);
 
 	int (*examine_debug_reason)(struct target *target);
-	void (*post_debug_entry)(struct target *target);
+	int (*post_debug_entry)(struct target *target);
 
 	void (*pre_restore_context)(struct target *target);
 };
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 76c3d37..9b3521a 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1056,12 +1056,16 @@ static int cortex_a8_debug_entry(struct target *target)
 	/* Are we in an exception handler */
 //	armv4_5->exception_number = 0;
 	if (armv7a->post_debug_entry)
-		armv7a->post_debug_entry(target);
+	{
+		retval = armv7a->post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return retval;
 }
 
-static void cortex_a8_post_debug_entry(struct target *target)
+static int cortex_a8_post_debug_entry(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
@@ -1072,6 +1076,8 @@ static void cortex_a8_post_debug_entry(struct target *target)
 			0, 0,	/* op1, op2 */
 			1, 0,	/* CRn, CRm */
 			&cortex_a8->cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a8->cp15_control_reg);
 
 	if (armv7a->armv4_5_mmu.armv4_5_cache.ctype == -1)
@@ -1083,6 +1089,8 @@ static void cortex_a8_post_debug_entry(struct target *target)
 				0, 1,	/* op1, op2 */
 				0, 0,	/* CRn, CRm */
 				&cache_type_reg);
+		if (retval != ERROR_OK)
+			return retval;
 		LOG_DEBUG("cp15 cache type: %8.8x", (unsigned) cache_type_reg);
 
 		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A8 */
@@ -1097,7 +1105,7 @@ static void cortex_a8_post_debug_entry(struct target *target)
 	armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled =
 			(cortex_a8->cp15_control_reg & 0x1000U) ? 1 : 0;
 
-
+	return ERROR_OK;
 }
 
 static int cortex_a8_step(struct target *target, int current, uint32_t address,
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 7f6cbaf..4f3560f 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -442,7 +442,11 @@ static int cortex_m3_debug_entry(struct target *target)
 		target_state_name(target));
 
 	if (armv7m->post_debug_entry)
-		armv7m->post_debug_entry(target);
+	{
+		retval = armv7m->post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return ERROR_OK;
 }
@@ -813,7 +817,10 @@ static int cortex_m3_step(struct target *target, int current,
 			" nvic_icsr = 0x%" PRIx32,
 			cortex_m3->dcb_dhcsr, cortex_m3->nvic_icsr);
 
-	cortex_m3_debug_entry(target);
+	int retval;
+	retval = cortex_m3_debug_entry(target);
+	if (retval != ERROR_OK)
+		return retval;
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 
 	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32

commit 6c573df11d1c1bc76c897d0688adfd00ec56ca8e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 12:17:11 2010 +0200

    cortex a8: added timeout handling
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 9a90180..76c3d37 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -136,6 +136,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
 
 	/* Wait for InstrCompl bit to be set */
+	long long then = timeval_ms();
 	while ((dscr & DSCR_INSTR_COMP) == 0)
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
@@ -145,12 +146,18 @@ static int cortex_a8_exec_opcode(struct target *target,
 			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
 			return retval;
 		}
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for cortex_a8_exec_opcode");
+			return ERROR_FAIL;
+		}
 	}
 
 	retval = mem_ap_write_u32(swjdp, armv7a->debug_base + CPUDBG_ITR, opcode);
 	if (retval != ERROR_OK)
 		return retval;
 
+	then = timeval_ms();
 	do
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
@@ -160,6 +167,11 @@ static int cortex_a8_exec_opcode(struct target *target,
 			LOG_ERROR("Could not read DSCR register");
 			return retval;
 		}
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for cortex_a8_exec_opcode");
+			return ERROR_FAIL;
+		}
 	}
 	while ((dscr & DSCR_INSTR_COMP) == 0); /* Wait for InstrCompl bit to be set */
 
@@ -248,12 +260,18 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	}
 
 	/* Wait for DTRRXfull then read DTRRTX */
+	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0)
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for cortex_a8_exec_opcode");
+			return ERROR_FAIL;
+		}
 	}
 
 	retval = mem_ap_read_atomic_u32(swjdp,
@@ -394,12 +412,18 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		dscr = *dscr_p;
 
 	/* Wait for DTRRXfull */
+	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
 		retval = mem_ap_read_atomic_u32(swjdp,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
 		if (retval != ERROR_OK)
 			return retval;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for read dcc");
+			return ERROR_FAIL;
+		}
 	}
 
 	retval = mem_ap_read_atomic_u32(swjdp,
@@ -1086,8 +1110,6 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	struct reg *r;
 	int retval;
 
-	int timeout = 100;
-
 	if (target->state != TARGET_HALTED)
 	{
 		LOG_WARNING("target not halted");
@@ -1132,12 +1154,13 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	if (retval != ERROR_OK)
 		return retval;
 
+	long long then = timeval_ms();
 	while (target->state != TARGET_HALTED)
 	{
 		retval = cortex_a8_poll(target);
 		if (retval != ERROR_OK)
 			return retval;
-		if (--timeout == 0)
+		if (timeval_ms() > then + 1000)
 		{
 			LOG_ERROR("timeout waiting for target halt");
 			return ERROR_FAIL;
@@ -1145,8 +1168,8 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	}
 
 	cortex_a8_unset_breakpoint(target, &stepbreakpoint);
-	if (timeout > 0)
-		target->debug_reason = DBG_REASON_BREAKPOINT;
+
+	target->debug_reason = DBG_REASON_BREAKPOINT;
 
 	if (breakpoint)
 		cortex_a8_set_breakpoint(target, breakpoint, 0);

commit 6a237c23c1adb0be91a82a44d2cf13ff158b3ee2
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 10:58:07 2010 +0200

    arm: add error propagation for enable/disable mmu caches
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index b269f94..6bf38bb 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -154,14 +154,19 @@ static int arm720t_get_ttb(struct target *target, uint32_t *result)
 	return ERROR_OK;
 }
 
-static void arm720t_disable_mmu_caches(struct target *target,
+static int arm720t_disable_mmu_caches(struct target *target,
 		int mmu, int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm720t_read_cp15(target, 0xee110f10, &cp15_control);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee110f10, &cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control &= ~0x1U;
@@ -169,17 +174,23 @@ static void arm720t_disable_mmu_caches(struct target *target,
 	if (d_u_cache || i_cache)
 		cp15_control &= ~0x4U;
 
-	arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	retval = arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	return retval;
 }
 
-static void arm720t_enable_mmu_caches(struct target *target,
+static int arm720t_enable_mmu_caches(struct target *target,
 		int mmu, int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm720t_read_cp15(target, 0xee110f10, &cp15_control);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee110f10, &cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control |= 0x1U;
@@ -187,7 +198,8 @@ static void arm720t_enable_mmu_caches(struct target *target,
 	if (d_u_cache || i_cache)
 		cp15_control |= 0x4U;
 
-	arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	retval = arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	return retval;
 }
 
 static void arm720t_post_debug_entry(struct target *target)
@@ -282,12 +294,19 @@ static int arm720t_read_memory(struct target *target,
 
 	/* disable cache, but leave MMU enabled */
 	if (arm720t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-		arm720t_disable_mmu_caches(target, 0, 1, 0);
-
+	{
+		retval = arm720t_disable_mmu_caches(target, 0, 1, 0);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 	retval = arm7_9_read_memory(target, address, size, count, buffer);
 
 	if (arm720t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-		arm720t_enable_mmu_caches(target, 0, 1, 0);
+	{
+		retval = arm720t_enable_mmu_caches(target, 0, 1, 0);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return retval;
 }
@@ -367,7 +386,9 @@ static int arm720t_soft_reset_halt(struct target *target)
 	armv4_5->pc->dirty = 1;
 	armv4_5->pc->valid = 1;
 
-	arm720t_disable_mmu_caches(target, 1, 1, 1);
+	retval = arm720t_disable_mmu_caches(target, 1, 1, 1);
+	if (retval != ERROR_OK)
+		return retval;
 	arm720t->armv4_5_mmu.mmu_enabled = 0;
 	arm720t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
 	arm720t->armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 9c11d12..a80a378 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -333,14 +333,19 @@ int arm920t_get_ttb(struct target *target, uint32_t *result)
 }
 
 // EXPORTED to FA256
-void arm920t_disable_mmu_caches(struct target *target, int mmu,
+int arm920t_disable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_control);
-	jtag_execute_queue();
+	retval = arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control &= ~0x1U;
@@ -351,18 +356,24 @@ void arm920t_disable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 		cp15_control &= ~0x1000U;
 
-	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	retval = arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	return retval;
 }
 
 // EXPORTED to FA256
-void arm920t_enable_mmu_caches(struct target *target, int mmu,
+int arm920t_enable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_control);
-	jtag_execute_queue();
+	retval = arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control |= 0x1U;
@@ -373,7 +384,8 @@ void arm920t_enable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 		cp15_control |= 0x1000U;
 
-	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	retval = arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	return retval;
 }
 
 // EXPORTED to FA256
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 9d5afab..20f614d 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -67,9 +67,9 @@ int arm920t_write_memory(struct target *target,
 void arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
 int arm920t_get_ttb(struct target *target, uint32_t *result);
-void arm920t_disable_mmu_caches(struct target *target,
+int arm920t_disable_mmu_caches(struct target *target,
 	int mmu, int d_u_cache, int i_cache);
-void arm920t_enable_mmu_caches(struct target *target,
+int arm920t_enable_mmu_caches(struct target *target,
 	int mmu, int d_u_cache, int i_cache);
 
 extern const struct command_registration arm920t_command_handlers[];
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 0cf7173..f8a4f62 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -337,20 +337,27 @@ static int arm926ejs_get_ttb(struct target *target, uint32_t *result)
 	return ERROR_OK;
 }
 
-static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
+static int arm926ejs_disable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm926ejs->read_cp15(target, 0, 0, 1, 0, &cp15_control);
-	jtag_execute_queue();
+	retval = arm926ejs->read_cp15(target, 0, 0, 1, 0, &cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 	{
 		/* invalidate TLB */
-		arm926ejs->write_cp15(target, 0, 0, 8, 7, 0x0);
+		retval = arm926ejs->write_cp15(target, 0, 0, 8, 7, 0x0);
+		if (retval != ERROR_OK)
+			return retval;
 
 		cp15_control &= ~0x1U;
 	}
@@ -360,17 +367,25 @@ static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
 		uint32_t debug_override;
 		/* read-modify-write CP15 debug override register
 		 * to enable "test and clean all" */
-		arm926ejs->read_cp15(target, 0, 0, 15, 0, &debug_override);
+		retval = arm926ejs->read_cp15(target, 0, 0, 15, 0, &debug_override);
+		if (retval != ERROR_OK)
+			return retval;
 		debug_override |= 0x80000;
-		arm926ejs->write_cp15(target, 0, 0, 15, 0, debug_override);
+		retval = arm926ejs->write_cp15(target, 0, 0, 15, 0, debug_override);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* clean and invalidate DCache */
-		arm926ejs->write_cp15(target, 0, 0, 7, 5, 0x0);
+		retval = arm926ejs->write_cp15(target, 0, 0, 7, 5, 0x0);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* write CP15 debug override register
 		 * to disable "test and clean all" */
 		debug_override &= ~0x80000;
-		arm926ejs->write_cp15(target, 0, 0, 15, 0, debug_override);
+		retval = arm926ejs->write_cp15(target, 0, 0, 15, 0, debug_override);
+		if (retval != ERROR_OK)
+			return retval;
 
 		cp15_control &= ~0x4U;
 	}
@@ -378,23 +393,31 @@ static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 	{
 		/* invalidate ICache */
-		arm926ejs->write_cp15(target, 0, 0, 7, 5, 0x0);
+		retval = arm926ejs->write_cp15(target, 0, 0, 7, 5, 0x0);
+		if (retval != ERROR_OK)
+			return retval;
 
 		cp15_control &= ~0x1000U;
 	}
 
-	arm926ejs->write_cp15(target, 0, 0, 1, 0, cp15_control);
+	retval = arm926ejs->write_cp15(target, 0, 0, 1, 0, cp15_control);
+	return retval;
 }
 
-static void arm926ejs_enable_mmu_caches(struct target *target, int mmu,
+static int arm926ejs_enable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm926ejs->read_cp15(target, 0, 0, 1, 0, &cp15_control);
-	jtag_execute_queue();
+	retval = arm926ejs->read_cp15(target, 0, 0, 1, 0, &cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control |= 0x1U;
@@ -405,7 +428,8 @@ static void arm926ejs_enable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 		cp15_control |= 0x1000U;
 
-	arm926ejs->write_cp15(target, 0, 0, 1, 0, cp15_control);
+	retval = arm926ejs->write_cp15(target, 0, 0, 1, 0, cp15_control);
+	return retval;
 }
 
 static void arm926ejs_post_debug_entry(struct target *target)
@@ -564,7 +588,9 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	armv4_5->pc->dirty = 1;
 	armv4_5->pc->valid = 1;
 
-	arm926ejs_disable_mmu_caches(target, 1, 1, 1);
+	retval = arm926ejs_disable_mmu_caches(target, 1, 1, 1);
+	if (retval != ERROR_OK)
+		return retval;
 	arm926ejs->armv4_5_mmu.mmu_enabled = 0;
 	arm926ejs->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
 	arm926ejs->armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 3d450ae..8978f35 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -131,14 +131,20 @@ int armv4_5_mmu_read_physical(struct target *target, struct armv4_5_mmu_common *
 		return ERROR_TARGET_NOT_HALTED;
 
 	/* disable MMU and data (or unified) cache */
-	armv4_5_mmu->disable_mmu_caches(target, 1, 1, 0);
+	retval = armv4_5_mmu->disable_mmu_caches(target, 1, 1, 0);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	retval = armv4_5_mmu->read_memory(target, address, size, count, buffer);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* reenable MMU / cache */
-	armv4_5_mmu->enable_mmu_caches(target, armv4_5_mmu->mmu_enabled,
+	retval = armv4_5_mmu->enable_mmu_caches(target, armv4_5_mmu->mmu_enabled,
 		armv4_5_mmu->armv4_5_cache.d_u_cache_enabled,
 		armv4_5_mmu->armv4_5_cache.i_cache_enabled);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	return retval;
 }
@@ -151,14 +157,20 @@ int armv4_5_mmu_write_physical(struct target *target, struct armv4_5_mmu_common
 		return ERROR_TARGET_NOT_HALTED;
 
 	/* disable MMU and data (or unified) cache */
-	armv4_5_mmu->disable_mmu_caches(target, 1, 1, 0);
+	retval = armv4_5_mmu->disable_mmu_caches(target, 1, 1, 0);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	retval = armv4_5_mmu->write_memory(target, address, size, count, buffer);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* reenable MMU / cache */
-	armv4_5_mmu->enable_mmu_caches(target, armv4_5_mmu->mmu_enabled,
+	retval = armv4_5_mmu->enable_mmu_caches(target, armv4_5_mmu->mmu_enabled,
 		armv4_5_mmu->armv4_5_cache.d_u_cache_enabled,
 		armv4_5_mmu->armv4_5_cache.i_cache_enabled);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	return retval;
 }
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index d2716fb..f39834e 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -29,8 +29,8 @@ struct armv4_5_mmu_common
 	int (*get_ttb)(struct target *target, uint32_t *result);
 	int (*read_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-	void (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
-	void (*enable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
+	int (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
+	int (*enable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
 	struct armv4_5_cache_common armv4_5_cache;
 	int has_tiny_pages;
 	int mmu_enabled;
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index e1acbf7..9a90180 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -58,9 +58,9 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 static int cortex_a8_mmu(struct target *target, int *enabled);
 static int cortex_a8_virt2phys(struct target *target,
                 uint32_t virt, uint32_t *phys);
-static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
-static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_enable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
 static int cortex_a8_get_ttb(struct target *target, uint32_t *result);
 
@@ -1916,19 +1916,21 @@ static int cortex_a8_get_ttb(struct target *target, uint32_t *result)
     return ERROR_OK;
 }
 
-/* FIX! error propagation missing from this fn */
-static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache)
 {
     struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
     struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
     uint32_t cp15_control;
+    int retval;
 
     /* read cp15 control register */
-    armv7a->armv4_5_common.mrc(target, 15,
+    retval = armv7a->armv4_5_common.mrc(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     &cp15_control);
+    if (retval != ERROR_OK)
+    	return retval;
 
 
     if (mmu)
@@ -1940,25 +1942,28 @@ static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
     if (i_cache)
             cp15_control &= ~0x1000U;
 
-    armv7a->armv4_5_common.mcr(target, 15,
+    retval = armv7a->armv4_5_common.mcr(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     cp15_control);
+	return retval;
 }
 
-/* FIX! error propagation missing from this fn */
-static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_enable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache)
 {
     struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
     struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
     uint32_t cp15_control;
+    int retval;
 
     /* read cp15 control register */
-    armv7a->armv4_5_common.mrc(target, 15,
+    retval = armv7a->armv4_5_common.mrc(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     &cp15_control);
+    if (retval != ERROR_OK)
+    	return retval;
 
     if (mmu)
             cp15_control |= 0x1U;
@@ -1969,10 +1974,11 @@ static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
     if (i_cache)
             cp15_control |= 0x1000U;
 
-    armv7a->armv4_5_common.mcr(target, 15,
+    retval = armv7a->armv4_5_common.mcr(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     cp15_control);
+   	return retval;
 }
 
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 35efa85..c0080b2 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2018,14 +2018,17 @@ static int xscale_get_ttb(struct target *target, uint32_t *result)
 	return ERROR_OK;
 }
 
-static void xscale_disable_mmu_caches(struct target *target, int mmu,
+static int xscale_disable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	xscale_get_reg(&xscale->reg_cache->reg_list[XSCALE_CTRL]);
+	retval = xscale_get_reg(&xscale->reg_cache->reg_list[XSCALE_CTRL]);
+	if (retval !=ERROR_OK)
+		return retval;
 	cp15_control = buf_get_u32(xscale->reg_cache->reg_list[XSCALE_CTRL].value, 0, 32);
 
 	if (mmu)
@@ -2034,11 +2037,17 @@ static void xscale_disable_mmu_caches(struct target *target, int mmu,
 	if (d_u_cache)
 	{
 		/* clean DCache */
-		xscale_send_u32(target, 0x50);
-		xscale_send_u32(target, xscale->cache_clean_address);
+		retval = xscale_send_u32(target, 0x50);
+		if (retval !=ERROR_OK)
+			return retval;
+		retval = xscale_send_u32(target, xscale->cache_clean_address);
+		if (retval !=ERROR_OK)
+			return retval;
 
 		/* invalidate DCache */
-		xscale_send_u32(target, 0x51);
+		retval = xscale_send_u32(target, 0x51);
+		if (retval !=ERROR_OK)
+			return retval;
 
 		cp15_control &= ~0x4U;
 	}
@@ -2046,25 +2055,33 @@ static void xscale_disable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 	{
 		/* invalidate ICache */
-		xscale_send_u32(target, 0x52);
+		retval = xscale_send_u32(target, 0x52);
+		if (retval !=ERROR_OK)
+			return retval;
 		cp15_control &= ~0x1000U;
 	}
 
 	/* write new cp15 control register */
-	xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_CTRL], cp15_control);
+	retval = xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_CTRL], cp15_control);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* execute cpwait to ensure outstanding operations complete */
-	xscale_send_u32(target, 0x53);
+	retval = xscale_send_u32(target, 0x53);
+	return retval;
 }
 
-static void xscale_enable_mmu_caches(struct target *target, int mmu,
+static int xscale_enable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	xscale_get_reg(&xscale->reg_cache->reg_list[XSCALE_CTRL]);
+	retval = xscale_get_reg(&xscale->reg_cache->reg_list[XSCALE_CTRL]);
+	if (retval !=ERROR_OK)
+		return retval;
 	cp15_control = buf_get_u32(xscale->reg_cache->reg_list[XSCALE_CTRL].value, 0, 32);
 
 	if (mmu)
@@ -2077,10 +2094,13 @@ static void xscale_enable_mmu_caches(struct target *target, int mmu,
 		cp15_control |= 0x1000U;
 
 	/* write new cp15 control register */
-	xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_CTRL], cp15_control);
+	retval = xscale_set_reg_u32(&xscale->reg_cache->reg_list[XSCALE_CTRL], cp15_control);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* execute cpwait to ensure outstanding operations complete */
-	xscale_send_u32(target, 0x53);
+	retval = xscale_send_u32(target, 0x53);
+	return retval;
 }
 
 static int xscale_set_breakpoint(struct target *target,

commit 70fee9207b5fd1c6f499b790591446adc4d4467c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jul 19 08:45:45 2010 +0200

    arm: add error propagation to generic get_ttb fn
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 0ea6cb2..b269f94 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -134,16 +134,24 @@ static int arm720t_write_cp15(struct target *target, uint32_t opcode, uint32_t v
 	return ERROR_OK;
 }
 
-static uint32_t arm720t_get_ttb(struct target *target)
+static int arm720t_get_ttb(struct target *target, uint32_t *result)
 {
 	uint32_t ttb = 0x0;
 
-	arm720t_read_cp15(target, 0xee120f10, &ttb);
-	jtag_execute_queue();
+	int retval;
+
+	retval = arm720t_read_cp15(target, 0xee120f10, &ttb);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	ttb &= 0xffffc000;
 
-	return ttb;
+	*result = ttb;
+
+	return ERROR_OK;
 }
 
 static void arm720t_disable_mmu_caches(struct target *target,
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index fe9bba7..9c11d12 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -318,7 +318,7 @@ int arm920t_write_cp15_interpreted(struct target *target,
 }
 
 // EXPORTED to FA256
-uint32_t arm920t_get_ttb(struct target *target)
+int arm920t_get_ttb(struct target *target, uint32_t *result)
 {
 	int retval;
 	uint32_t ttb = 0x0;
@@ -328,7 +328,8 @@ uint32_t arm920t_get_ttb(struct target *target)
 			0xeebf0f51, 0x0, &ttb)) != ERROR_OK)
 		return retval;
 
-	return ttb;
+	*result = ttb;
+	return ERROR_OK;
 }
 
 // EXPORTED to FA256
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index a75f01a..9d5afab 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -66,7 +66,7 @@ int arm920t_write_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 void arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
-	uint32_t arm920t_get_ttb(struct target *target);
+int arm920t_get_ttb(struct target *target, uint32_t *result);
 void arm920t_disable_mmu_caches(struct target *target,
 	int mmu, int d_u_cache, int i_cache);
 void arm920t_enable_mmu_caches(struct target *target,
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index d68e5ca..0cf7173 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -323,7 +323,7 @@ static int arm926ejs_examine_debug_reason(struct target *target)
 	return ERROR_OK;
 }
 
-static uint32_t arm926ejs_get_ttb(struct target *target)
+static int arm926ejs_get_ttb(struct target *target, uint32_t *result)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 	int retval;
@@ -332,7 +332,9 @@ static uint32_t arm926ejs_get_ttb(struct target *target)
 	if ((retval = arm926ejs->read_cp15(target, 0, 0, 2, 0, &ttb)) != ERROR_OK)
 		return retval;
 
-	return ttb;
+	*result = ttb;
+
+	return ERROR_OK;
 }
 
 static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 861410d..3d450ae 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -30,8 +30,11 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 {
 	uint32_t first_lvl_descriptor = 0x0;
 	uint32_t second_lvl_descriptor = 0x0;
-	uint32_t ttb = armv4_5_mmu->get_ttb(target);
+	uint32_t ttb;
 	int retval;
+	retval = armv4_5_mmu->get_ttb(target, &ttb);
+	if (retval != ERROR_OK)
+	  return retval;
 
 	retval = armv4_5_mmu_read_physical(target, armv4_5_mmu,
 		(ttb & 0xffffc000) | ((va & 0xfff00000) >> 18),
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 24f3993..d2716fb 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -26,7 +26,7 @@ struct target;
 
 struct armv4_5_mmu_common
 {
-	uint32_t (*get_ttb)(struct target *target);
+	int (*get_ttb)(struct target *target, uint32_t *result);
 	int (*read_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	void (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index bd14016..e1acbf7 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -62,7 +62,7 @@ static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
 static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
-static uint32_t cortex_a8_get_ttb(struct target *target);
+static int cortex_a8_get_ttb(struct target *target, uint32_t *result);
 
 
 /*
@@ -1853,8 +1853,7 @@ static int cortex_a8_target_create(struct target *target, Jim_Interp *interp)
 	return cortex_a8_init_arch_info(target, cortex_a8, target->tap);
 }
 
-/* FIX! error propagation missing from this fn */
-static uint32_t cortex_a8_get_ttb(struct target *target)
+static int cortex_a8_get_ttb(struct target *target, uint32_t *result)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
     struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
@@ -1869,6 +1868,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 1,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     else if(cortex_a8->current_address_mode == ARM_MODE_USR)
     {
@@ -1877,6 +1878,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 0,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     /* we don't know whose address is: user or kernel
        we assume that if we are in kernel mode then
@@ -1889,6 +1892,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 1,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     else if(armv7a->armv4_5_common.core_mode == ARM_MODE_USR)
     {
@@ -1897,6 +1902,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 0,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     /* finally we don't know whose ttb to use: user or kernel */
     else
@@ -1904,7 +1911,9 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
 
     ttb &= 0xffffc000;
 
-    return ttb;
+    *result = ttb;
+
+    return ERROR_OK;
 }
 
 /* FIX! error propagation missing from this fn */
diff --git a/src/target/xscale.c b/src/target/xscale.c
index d5c2129..35efa85 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2002,15 +2002,20 @@ static int xscale_bulk_write_memory(struct target *target, uint32_t address,
 	return xscale_write_memory(target, address, 4, count, buffer);
 }
 
-static uint32_t xscale_get_ttb(struct target *target)
+static int xscale_get_ttb(struct target *target, uint32_t *result)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t ttb;
+	int retval;
 
-	xscale_get_reg(&xscale->reg_cache->reg_list[XSCALE_TTB]);
+	retval = xscale_get_reg(&xscale->reg_cache->reg_list[XSCALE_TTB]);
+	if (retval != ERROR_OK)
+		return retval;
 	ttb = buf_get_u32(xscale->reg_cache->reg_list[XSCALE_TTB].value, 0, 32);
 
-	return ttb;
+	*result = ttb;
+
+	return ERROR_OK;
 }
 
 static void xscale_disable_mmu_caches(struct target *target, int mmu,

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c   |   21 ++++-
 src/target/arm11.c         |    2 +-
 src/target/arm720t.c       |   83 +++++++++++++-----
 src/target/arm7_9_common.c |   41 +++++++--
 src/target/arm7_9_common.h |    2 +-
 src/target/arm7tdmi.c      |   17 +++-
 src/target/arm920t.c       |   95 ++++++++++++++-----
 src/target/arm920t.h       |    8 +-
 src/target/arm926ejs.c     |  116 +++++++++++++++++-------
 src/target/arm966e.c       |    8 ++-
 src/target/arm9tdmi.c      |   16 +++-
 src/target/arm_adi_v5.c    |  163 ++++++++++++++++++++++++----------
 src/target/arm_dpm.c       |   28 ++++++-
 src/target/armv4_5_mmu.c   |   25 ++++-
 src/target/armv4_5_mmu.h   |    6 +-
 src/target/armv7a.h        |    2 +-
 src/target/armv7m.h        |    2 +-
 src/target/cortex_a8.c     |   90 ++++++++++++++-----
 src/target/cortex_m3.c     |  215 +++++++++++++++++++++++++++++++++-----------
 src/target/embeddedice.c   |   22 ++++-
 src/target/etm.c           |   10 ++-
 src/target/feroceon.c      |    5 +-
 src/target/xscale.c        |   55 ++++++++---
 23 files changed, 769 insertions(+), 263 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jul 20 08:28:55 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 20 Jul 2010 06:28:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-444-ge0525cd
Message-ID: <E1Ob6K3-0003KO-VK@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e0525cd182aee35549f13e786143ccc0a252aeab (commit)
      from  a9761c90931101d280b9443126db017f96d92e3d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e0525cd182aee35549f13e786143ccc0a252aeab
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jul 20 08:23:59 2010 +0200

    arm_jtag_scann error propagation fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 8befe2b..f4ba44a 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -120,7 +120,9 @@ static __inline int arm7tdmi_clock_out(struct arm_jtag *jtag_info,
 		uint32_t out, uint32_t *deprecated, int breakpoint)
 {
 	int retval;
-	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
+	retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index c5064c1..90f548f 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -93,7 +93,9 @@ static int arm920t_read_cp15_physical(struct target *target,
 
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
-	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
@@ -146,7 +148,9 @@ static int arm920t_write_cp15_physical(struct target *target,
 
 	buf_set_u32(value_buf, 0, 32, value);
 
-	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
@@ -197,7 +201,9 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
-	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 965260c..abc49d7 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -346,7 +346,9 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	uint8_t field2_out[1];
 	int retval;
 
-	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
+	retval = arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	retval = arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
@@ -410,7 +412,9 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	uint8_t field2_out[1];
 	int retval;
 
-	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	retval = arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
@@ -497,7 +501,7 @@ void embeddedice_write_reg(struct reg *reg, uint32_t value)
 
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", ice_reg->addr, value);
 
-	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
+	retval = arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
 	retval = arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
@@ -530,7 +534,9 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	uint8_t field2_out[1];
 	int retval;
 
-	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	retval = arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
@@ -584,7 +590,9 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 	else
 		return ERROR_INVALID_ARGUMENTS;
 
-	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	retval = arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/etm.c b/src/target/etm.c
index 5c42fb5..9da6955 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -505,7 +505,9 @@ static int etm_read_reg_w_check(struct reg *reg,
 
 	LOG_DEBUG("%s (%u)", r->name, reg_addr);
 
-	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
+	retval = arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
@@ -589,7 +591,9 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 
 	LOG_DEBUG("%s (%u): 0x%8.8" PRIx32 "", r->name, reg_addr, value);
 
-	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
+	retval = arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 6ca432a..2152a26 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -85,7 +85,9 @@ static int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 
 	buf_set_u32(instr_buf, 0, 32, flip_u32(instr, 32));
 
-	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
+	retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 	if (retval != ERROR_OK)

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7tdmi.c    |    4 +++-
 src/target/arm920t.c     |   12 +++++++++---
 src/target/embeddedice.c |   18 +++++++++++++-----
 src/target/etm.c         |    8 ++++++--
 src/target/feroceon.c    |    4 +++-
 5 files changed, 34 insertions(+), 12 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jul 20 08:43:30 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 20 Jul 2010 06:43:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-445-g1143bbc
Message-ID: <E1Ob6YC-0004mM-PJ@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1143bbc0c88c20300106ce9d63b2b77c9c2f66c9 (commit)
      from  e0525cd182aee35549f13e786143ccc0a252aeab (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1143bbc0c88c20300106ce9d63b2b77c9c2f66c9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jul 20 08:42:52 2010 +0200

    arm11 error propagation fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 67f0524..85d45b0 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -62,7 +62,7 @@ static int arm11_check_init(struct arm11_common *arm11)
 		LOG_DEBUG("Bringing target into debug mode");
 
 		arm11->dscr |= DSCR_HALT_DBG_MODE;
-		arm11_write_DSCR(arm11, arm11->dscr);
+		CHECK_RETVAL(arm11_write_DSCR(arm11, arm11->dscr));
 
 		/* add further reset initialization here */
 
@@ -85,7 +85,7 @@ static int arm11_check_init(struct arm11_common *arm11)
 			arm11->arm.target->debug_reason = DBG_REASON_NOTHALTED;
 		}
 
-		arm11_sc7_clear_vbw(arm11);
+		CHECK_RETVAL(arm11_sc7_clear_vbw(arm11));
 	}
 
 	return ERROR_OK;
@@ -133,7 +133,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 	 * but not to issue ITRs(?).  The ARMv7 arch spec says it's required
 	 * for executing instructions via ITR.
 	 */
-	arm11_write_DSCR(arm11, DSCR_ITR_EN | arm11->dscr);
+	CHECK_RETVAL(arm11_write_DSCR(arm11, DSCR_ITR_EN | arm11->dscr));
 
 
 	/* From the spec:
@@ -291,14 +291,14 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	/* restore CPSR, PC, and R0 ... after flushing any modified
 	 * registers.
 	 */
-	retval = arm_dpm_write_dirty_registers(&arm11->dpm, bpwp);
+	CHECK_RETVAL(arm_dpm_write_dirty_registers(&arm11->dpm, bpwp));
 
-	retval = arm11_bpwp_flush(arm11);
+	CHECK_RETVAL(arm11_bpwp_flush(arm11));
 
 	register_cache_invalidate(arm11->arm.core_cache);
 
 	/* restore DSCR */
-	arm11_write_DSCR(arm11, arm11->dscr);
+	CHECK_RETVAL(arm11_write_DSCR(arm11, arm11->dscr));
 
 	/* maybe restore rDTR */
 	if (arm11->is_rdtr_saved)
@@ -484,7 +484,7 @@ static int arm11_resume(struct target *target, int current,
 	LOG_DEBUG("RESUME PC %08" PRIx32 "%s", address, !current ? "!" : "");
 
 	/* clear breakpoints/watchpoints and VCR*/
-	arm11_sc7_clear_vbw(arm11);
+	CHECK_RETVAL(arm11_sc7_clear_vbw(arm11));
 
 	if (!debug_execution)
 		target_free_all_working_areas(target);
@@ -520,7 +520,7 @@ static int arm11_resume(struct target *target, int current,
 			brp[1].address	= ARM11_SC7_BCR0 + brp_num;
 			brp[1].value	= 0x1 | (3 << 1) | (0x0F << 5) | (0 << 14) | (0 << 16) | (0 << 20) | (0 << 21);
 
-			arm11_sc7_run(arm11, brp, ARRAY_SIZE(brp));
+			CHECK_RETVAL(arm11_sc7_run(arm11, brp, ARRAY_SIZE(brp)));
 
 			LOG_DEBUG("Add BP %d at %08" PRIx32, brp_num,
 					bp->address);
@@ -529,11 +529,11 @@ static int arm11_resume(struct target *target, int current,
 		}
 
 		if (arm11->vcr)
-			arm11_sc7_set_vcr(arm11, arm11->vcr);
+			CHECK_RETVAL(arm11_sc7_set_vcr(arm11, arm11->vcr));
 	}
 
 	/* activate all watchpoints and breakpoints */
-	arm11_leave_debug_state(arm11, true);
+	CHECK_RETVAL(arm11_leave_debug_state(arm11, true));
 
 	arm11_add_IR(arm11, ARM11_RESTART, TAP_IDLE);
 
@@ -725,7 +725,7 @@ static int arm11_step(struct target *target, int current,
 		}
 
 		/* clear breakpoint */
-		arm11_sc7_clear_vbw(arm11);
+		CHECK_RETVAL(arm11_sc7_clear_vbw(arm11));
 
 		/* save state */
 		CHECK_RETVAL(arm11_debug_entry(arm11));
@@ -748,7 +748,7 @@ static int arm11_assert_reset(struct target *target)
 
 	/* optionally catch reset vector */
 	if (target->reset_halt && !(arm11->vcr & 1))
-		arm11_sc7_set_vcr(arm11, arm11->vcr | 1);
+		CHECK_RETVAL(arm11_sc7_set_vcr(arm11, arm11->vcr | 1));
 
 	/* Issue some kind of warm reset. */
 	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
@@ -795,7 +795,7 @@ static int arm11_deassert_reset(struct target *target)
 	 */
 	jtag_add_tlr();
 
-	retval = arm11_poll(target);
+	CHECK_RETVAL(arm11_poll(target));
 
 	if (target->reset_halt) {
 		if (target->state != TARGET_HALTED) {
@@ -808,7 +808,7 @@ static int arm11_deassert_reset(struct target *target)
 
 	/* maybe restore vector catch config */
 	if (target->reset_halt && !(arm11->vcr & 1))
-		arm11_sc7_set_vcr(arm11, arm11->vcr);
+		CHECK_RETVAL(arm11_sc7_set_vcr(arm11, arm11->vcr));
 
 	return ERROR_OK;
 }
@@ -863,12 +863,12 @@ static int arm11_read_memory_inner(struct target *target,
 		{
 			/* ldrb    r1, [r0], #1 */
 			/* ldrb    r1, [r0] */
-			arm11_run_instr_no_data1(arm11,
-					!arm11_config_memrw_no_increment ? 0xe4d01001 : 0xe5d01000);
+			CHECK_RETVAL(arm11_run_instr_no_data1(arm11,
+					!arm11_config_memrw_no_increment ? 0xe4d01001 : 0xe5d01000));
 
 			uint32_t res;
 			/* MCR p14,0,R1,c0,c5,0 */
-			arm11_run_instr_data_from_core(arm11, 0xEE001E15, &res, 1);
+			CHECK_RETVAL(arm11_run_instr_data_from_core(arm11, 0xEE001E15, &res, 1));
 
 			*buffer++ = res;
 		}
@@ -882,13 +882,13 @@ static int arm11_read_memory_inner(struct target *target,
 			for (size_t i = 0; i < count; i++)
 			{
 				/* ldrh    r1, [r0], #2 */
-				arm11_run_instr_no_data1(arm11,
-					!arm11_config_memrw_no_increment ? 0xe0d010b2 : 0xe1d010b0);
+				CHECK_RETVAL(arm11_run_instr_no_data1(arm11,
+					!arm11_config_memrw_no_increment ? 0xe0d010b2 : 0xe1d010b0));
 
 				uint32_t res;
 
 				/* MCR p14,0,R1,c0,c5,0 */
-				arm11_run_instr_data_from_core(arm11, 0xEE001E15, &res, 1);
+				CHECK_RETVAL(arm11_run_instr_data_from_core(arm11, 0xEE001E15, &res, 1));
 
 				uint16_t svalue = res;
 				memcpy(buffer + i * sizeof(uint16_t), &svalue, sizeof(uint16_t));
@@ -905,7 +905,7 @@ static int arm11_read_memory_inner(struct target *target,
 
 		/* LDC p14,c5,[R0],#4 */
 		/* LDC p14,c5,[R0] */
-		arm11_run_instr_data_from_core(arm11, instr, words, count);
+		CHECK_RETVAL(arm11_run_instr_data_from_core(arm11, instr, words, count));
 		break;
 		}
 	}
@@ -1265,14 +1265,14 @@ static int arm11_examine(struct target *target)
 	 * want to know if this core supports Secure Monitor mode.
 	 */
 	if (!target_was_examined(target))
-		retval = arm11_dpm_init(arm11, didr);
+		CHECK_RETVAL(arm11_dpm_init(arm11, didr));
 
 	/* ETM on ARM11 still uses original scanchain 6 access mode */
 	if (arm11->arm.etm && !target_was_examined(target)) {
 		*register_get_last_cache_p(&target->reg_cache) =
 			etm_build_reg_cache(target, &arm11->jtag_info,
 					arm11->arm.etm);
-		retval = etm_setup(target);
+		CHECK_RETVAL(etm_setup(target));
 	}
 
 	target_set_examined(target);
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index b2c6287..4e90933 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -964,7 +964,7 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
  * \param arm11		Target state variable.
  *
  */
-void arm11_sc7_clear_vbw(struct arm11_common * arm11)
+int arm11_sc7_clear_vbw(struct arm11_common * arm11)
 {
 	size_t clear_bw_size = arm11->brp + 1;
 	struct arm11_sc7_action		*clear_bw = malloc(sizeof(struct arm11_sc7_action) * clear_bw_size);
@@ -981,9 +981,12 @@ void arm11_sc7_clear_vbw(struct arm11_common * arm11)
 
 	(pos++)->address = ARM11_SC7_VCR;
 
-	arm11_sc7_run(arm11, clear_bw, clear_bw_size);
+	int retval;
+	retval = arm11_sc7_run(arm11, clear_bw, clear_bw_size);
 
 	free (clear_bw);
+
+	return retval;
 }
 
 /** Write VCR register
@@ -991,7 +994,7 @@ void arm11_sc7_clear_vbw(struct arm11_common * arm11)
  * \param arm11		Target state variable.
  * \param value		Value to be written
  */
-void arm11_sc7_set_vcr(struct arm11_common * arm11, uint32_t value)
+int arm11_sc7_set_vcr(struct arm11_common * arm11, uint32_t value)
 {
 	struct arm11_sc7_action		set_vcr;
 
@@ -999,7 +1002,7 @@ void arm11_sc7_set_vcr(struct arm11_common * arm11, uint32_t value)
 	set_vcr.address		= ARM11_SC7_VCR;
 	set_vcr.value		= value;
 
-	arm11_sc7_run(arm11, &set_vcr, 1);
+	return arm11_sc7_run(arm11, &set_vcr, 1);
 }
 
 
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 762c9be..e45bdc2 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -52,8 +52,8 @@ int arm11_sc7_run(struct arm11_common *arm11,
 		struct arm11_sc7_action *actions, size_t count);
 
 /* Mid-level helper functions */
-void arm11_sc7_clear_vbw(struct arm11_common *arm11);
-void arm11_sc7_set_vcr(struct arm11_common *arm11, uint32_t value);
+int arm11_sc7_clear_vbw(struct arm11_common *arm11);
+int arm11_sc7_set_vcr(struct arm11_common *arm11, uint32_t value);
 
 int arm11_read_memory_word(struct arm11_common *arm11,
 		uint32_t address, uint32_t *result);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c        |   46 ++++++++++++++++++++++----------------------
 src/target/arm11_dbgtap.c |   11 ++++++---
 src/target/arm11_dbgtap.h |    4 +-
 3 files changed, 32 insertions(+), 29 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Jul 20 10:28:40 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 20 Jul 2010 08:28:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-449-g260eb45
Message-ID: <E1Ob8C1-0002RZ-3S@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  260eb4548b01da3ecd2cd146bb22a0f36df1a038 (commit)
       via  ee17d5c48eaca42438663405ff6d090a391fc9e6 (commit)
       via  7176ed9afe0972ca768d6aabc8e58418d6f91286 (commit)
       via  f0c0256b1f05a04a58d857e9d865a0be0dd1680d (commit)
      from  1143bbc0c88c20300106ce9d63b2b77c9c2f66c9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 260eb4548b01da3ecd2cd146bb22a0f36df1a038
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 19 20:33:04 2010 +0100

    flash: remove algorithm exit_point address for supported targets
    
    For the above targets the exit_point is
    optional when used with run_algorithm, so remove it.
    
    This makes updating the algorithm less error prone.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 866be50..0930d62 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -346,7 +346,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 			init_reg_param(&reg_params[4], "lr", 32, PARAM_OUT);
 			buf_set_u32(reg_params[4].value, 0, 32, (lpc2000_info->iap_working_area->address + 0x04) | 1); /* bit0 of LR = 1 to return in Thumb mode */
 
-			target_run_algorithm(target, 2, mem_params, 5, reg_params, lpc2000_info->iap_working_area->address, lpc2000_info->iap_working_area->address + 0x4, 10000, &armv7m_info);
+			target_run_algorithm(target, 2, mem_params, 5, reg_params, lpc2000_info->iap_working_area->address, 0, 10000, &armv7m_info);
 			break;
 		case lpc2000_v1:
 		case lpc2000_v2:
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 2fe864d..363f49e 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -360,7 +360,7 @@ static int pic32mx_write_block(struct flash_bank *bank, uint8_t *buffer,
 
 		if ((retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
 				pic32mx_info->write_algorithm->address,
-				pic32mx_info->write_algorithm->address + (sizeof(pic32mx_flash_write_code) - 76),
+				0,
 				10000, &mips32_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing pic32mx flash write algorithm");
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index ff1c2e4..69e2f10 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -884,8 +884,7 @@ static int stellaris_write_block(struct flash_bank *bank,
 				(unsigned) (wcount - thisrun_count));
 		retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
 				write_algorithm->address,
-				write_algorithm->address +
-					sizeof(stellaris_write_code) - 10,
+				0,
 				10000, &armv7m_info);
 		if (retval != ERROR_OK)
 		{
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 5ce5d45..4ec777d 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -519,7 +519,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 
 		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
 				stm32x_info->write_algorithm->address,
-				stm32x_info->write_algorithm->address + (sizeof(stm32x_flash_write_code) - 10),
+				0,
 				10000, &armv7m_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing stm32x flash write algorithm");

commit ee17d5c48eaca42438663405ff6d090a391fc9e6
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 19 20:29:16 2010 +0100

    mips32: exit_point optional for mips32_run_algorithm
    
    As the mips32 uses instruction breakpoints for algorithms we do not really
    need to check the pc on exit.
    
    This now matches the behaviour of the arm codebase.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/mips32.c b/src/target/mips32.c
index 2547b01..24cd7d9 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -348,7 +348,7 @@ static int mips32_run_and_wait(struct target *target, uint32_t entry_point,
 	}
 
 	pc = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32);
-	if (pc != exit_point)
+	if (exit_point && (pc != exit_point))
 	{
 		LOG_DEBUG("failed algoritm halted at 0x%" PRIx32 " ", pc);
 		return ERROR_TARGET_TIMEOUT;

commit 7176ed9afe0972ca768d6aabc8e58418d6f91286
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jul 19 20:28:30 2010 +0100

    armv7m: exit_point optional for armv7m_run_algorithm
    
    As the armv7m uses instruction breakpoints for algorithms we do not really
    need to check the pc on exit.
    
    This now matches the behaviour of the arm4_5 codebase.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index bd5aa14..a73a9bb 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -313,7 +313,7 @@ static int armv7m_run_and_wait(struct target *target, uint32_t entry_point, int
 	}
 
 	armv7m->load_core_reg_u32(target, ARMV7M_REGISTER_CORE_GP, 15, &pc);
-	if (pc != exit_point)
+	if (exit_point && (pc != exit_point))
 	{
 		LOG_DEBUG("failed algoritm halted at 0x%" PRIx32 " ", pc);
 		return ERROR_TARGET_TIMEOUT;

commit f0c0256b1f05a04a58d857e9d865a0be0dd1680d
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Jul 20 09:02:10 2010 +0100

    armv4_5: add algorithms instruction breakpoint support
    
    Update the arm_checksum_memory and arm_blank_check_memory
    algorithms to use a breakpoint instruction on v5 arch.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 1a84a5f..d950af3 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -1286,16 +1286,17 @@ int armv4_5_run_algorithm(struct target *target, int num_mem_params, struct mem_
 /**
  * Runs ARM code in the target to calculate a CRC32 checksum.
  *
- * \todo On ARMv5+, rely on BKPT termination for reduced overhead.
  */
 int arm_checksum_memory(struct target *target,
 		uint32_t address, uint32_t count, uint32_t *checksum)
 {
 	struct working_area *crc_algorithm;
 	struct arm_algorithm armv4_5_info;
+	struct arm *armv4_5 = target_to_arm(target);
 	struct reg_param reg_params[2];
 	int retval;
 	uint32_t i;
+	uint32_t exit_var = 0;
 
 	static const uint32_t arm_crc_code[] = {
 		0xE1A02000,		/* mov		r2, r0 */
@@ -1321,7 +1322,7 @@ int arm_checksum_memory(struct target *target,
 		0xE1540003,		/* cmp		r4, r3 */
 		0x1AFFFFF1,		/* bne		nbyte */
 		/* end: */
-		0xEAFFFFFE,		/* b		end */
+		0xe1200070,		/* bkpt		#0 */
 		/* CRC32XOR: */
 		0x04C11DB7		/* .word 0x04C11DB7 */
 	};
@@ -1353,9 +1354,13 @@ int arm_checksum_memory(struct target *target,
 	/* 20 second timeout/megabyte */
 	int timeout = 20000 * (1 + (count / (1024 * 1024)));
 
+	/* armv4 must exit using a hardware breakpoint */
+	if (armv4_5->is_armv4)
+		exit_var = crc_algorithm->address + sizeof(arm_crc_code) - 8;
+
 	retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
 			crc_algorithm->address,
-			crc_algorithm->address + sizeof(arm_crc_code) - 8,
+			exit_var,
 			timeout, &armv4_5_info);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("error executing ARM crc algorithm");
@@ -1380,7 +1385,6 @@ int arm_checksum_memory(struct target *target,
  * all ones.  NOR flash which has been erased, and thus may be written,
  * holds all ones.
  *
- * \todo On ARMv5+, rely on BKPT termination for reduced overhead.
  */
 int arm_blank_check_memory(struct target *target,
 		uint32_t address, uint32_t count, uint32_t *blank)
@@ -1388,8 +1392,10 @@ int arm_blank_check_memory(struct target *target,
 	struct working_area *check_algorithm;
 	struct reg_param reg_params[3];
 	struct arm_algorithm armv4_5_info;
+	struct arm *armv4_5 = target_to_arm(target);
 	int retval;
 	uint32_t i;
+	uint32_t exit_var = 0;
 
 	static const uint32_t check_code[] = {
 		/* loop: */
@@ -1398,7 +1404,7 @@ int arm_blank_check_memory(struct target *target,
 		0xe2511001,		/* subs r1, r1, #1   */
 		0x1afffffb,		/* bne loop          */
 		/* end: */
-		0xeafffffe		/* b end             */
+		0xe1200070,		/* bkpt #0 */
 	};
 
 	/* make sure we have a working area */
@@ -1430,9 +1436,13 @@ int arm_blank_check_memory(struct target *target,
 	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT);
 	buf_set_u32(reg_params[2].value, 0, 32, 0xff);
 
+	/* armv4 must exit using a hardware breakpoint */
+	if (armv4_5->is_armv4)
+		exit_var = check_algorithm->address + sizeof(check_code) - 4;
+
 	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
 			check_algorithm->address,
-			check_algorithm->address + sizeof(check_code) - 4,
+			exit_var,
 			10000, &armv4_5_info);
 	if (retval != ERROR_OK) {
 		destroy_reg_param(&reg_params[0]);

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/lpc2000.c   |    2 +-
 src/flash/nor/pic32mx.c   |    2 +-
 src/flash/nor/stellaris.c |    3 +--
 src/flash/nor/stm32x.c    |    2 +-
 src/target/armv4_5.c      |   22 ++++++++++++++++------
 src/target/armv7m.c       |    2 +-
 src/target/mips32.c       |    2 +-
 7 files changed, 22 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Jul 21 15:50:39 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 21 Jul 2010 13:50:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-450-g450aaad
Message-ID: <E1ObZh4-0004FH-VY@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  450aaad1e92ad039ef6a34c11e752a0a315c5397 (commit)
      from  260eb4548b01da3ecd2cd146bb22a0f36df1a038 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 450aaad1e92ad039ef6a34c11e752a0a315c5397
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Jul 20 10:46:54 2010 +0100

    docs: removed unused cmd 'fast'
    
    The cmd fast was removed in commit c0d14dc7f19d785702eee5f69de5b1a63902554b
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 08578fa..89c9f66 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -5430,25 +5430,6 @@ file (which is normally the server's standard output).
 @xref{Running}.
 @end deffn
 
- at deffn Command fast (@option{enable}|@option{disable})
-Default disabled.
-Set default behaviour of OpenOCD to be "fast and dangerous".
-
-At this writing, this only affects the defaults for two ARM7/ARM9 parameters:
-fast memory access, and DCC downloads.  Those parameters may still be
-individually overridden.
-
-The target specific "dangerous" optimisation tweaking options may come and go
-as more robust and user friendly ways are found to ensure maximum throughput
-and robustness with a minimum of configuration.
-
-Typically the "fast enable" is specified first on the command line:
-
- at example
-openocd -c "fast enable" -c "interface dummy" -f target/str710.cfg
- at end example
- at end deffn
-
 @deffn Command echo message
 Logs a message at "user" priority.
 Output @var{message} to stdout.

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |   19 -------------------
 1 files changed, 0 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jul 23 19:17:45 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 23 Jul 2010 17:17:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-451-g51d9b56
Message-ID: <E1OcLsf-0003SV-Kl@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  51d9b56861e1a64629177283fe37f289de932ba5 (commit)
      from  450aaad1e92ad039ef6a34c11e752a0a315c5397 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 51d9b56861e1a64629177283fe37f289de932ba5
Author: Michal Demin <michal.demin at gmail.com>
Date:   Sat Jul 10 10:08:18 2010 +0200

    Buspirate: fix shadow

diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
index 1c433a9..e5f8fb6 100644
--- a/src/jtag/drivers/buspirate.c
+++ b/src/jtag/drivers/buspirate.c
@@ -633,24 +633,24 @@ static void buspirate_tap_make_space(int scans, int bits)
 
 static void buspirate_tap_append(int tms, int tdi)
 {
-	int index;
+	int chain_index;
 
 	buspirate_tap_make_space(0, 1);
-	index = tap_chain_index / 8;
+	chain_index = tap_chain_index / 8;
 
-	if (index < BUSPIRATE_BUFFER_SIZE) {
+	if (chain_index < BUSPIRATE_BUFFER_SIZE) {
 		int bit_index = tap_chain_index % 8;
 		uint8_t bit = 1 << bit_index;
 
 		if (tms)
-			tms_chain[index] |= bit;
+			tms_chain[chain_index] |= bit;
 		else
-			tms_chain[index] &= ~bit;
+			tms_chain[chain_index] &= ~bit;
 
 		if (tdi)
-			tdi_chain[index] |= bit;
+			tdi_chain[chain_index] |= bit;
 		else
-			tdi_chain[index] &= ~bit;
+			tdi_chain[chain_index] &= ~bit;
 
 		tap_chain_index++;
 	} else
@@ -832,13 +832,13 @@ static void buspirate_jtag_get_adcs(int fd)
 		((float)c)/155.1515, ((float)d)/155.1515);
 }
 
-static unsigned char buspirate_jtag_command(int buspirate_fd,
+static unsigned char buspirate_jtag_command(int fd,
 		char *cmd, int cmdlen)
 {
 	int res;
 	int len = 0;
 
-	res = buspirate_serial_write(buspirate_fd, cmd, cmdlen);
+	res = buspirate_serial_write(fd, cmd, cmdlen);
 
 	if ((cmd[0] == CMD_UART_SPEED)
 				|| (cmd[0] == CMD_PORT_MODE)
@@ -857,7 +857,7 @@ static unsigned char buspirate_jtag_command(int buspirate_fd,
 		default:
 			LOG_INFO("Wrong !");
 		}
-		res =  buspirate_serial_read(buspirate_fd, cmd, len);
+		res =  buspirate_serial_read(fd, cmd, len);
 		if (res > 0)
 			return (unsigned char)cmd[1];
 		else
@@ -874,8 +874,8 @@ static int buspirate_serial_setspeed(int fd, speed_t speed)
 	struct termios t_opt;
 
 	/* set the serial port parameters */
-	fcntl(buspirate_fd, F_SETFL, 0);
-	tcgetattr(buspirate_fd, &t_opt);
+	fcntl(fd, F_SETFL, 0);
+	tcgetattr(fd, &t_opt);
 	cfsetispeed(&t_opt, speed);
 	cfsetospeed(&t_opt, speed);
 	t_opt.c_cflag |= (CLOCAL | CREAD);
@@ -888,8 +888,8 @@ static int buspirate_serial_setspeed(int fd, speed_t speed)
 	t_opt.c_oflag &= ~OPOST;
 	t_opt.c_cc[VMIN] = 0;
 	t_opt.c_cc[VTIME] = 10;
-	tcflush(buspirate_fd, TCIFLUSH);
-	tcsetattr(buspirate_fd, TCSANOW, &t_opt);
+	tcflush(fd, TCIFLUSH);
+	tcsetattr(fd, TCSANOW, &t_opt);
 
 	return 0;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/buspirate.c |   28 ++++++++++++++--------------
 1 files changed, 14 insertions(+), 14 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Jul 24 20:40:26 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 24 Jul 2010 18:40:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-452-ga463670
Message-ID: <E1OcjeD-0008V6-Q9@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a463670c312befd86224e74a79aa804ee5fbae03 (commit)
      from  51d9b56861e1a64629177283fe37f289de932ba5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a463670c312befd86224e74a79aa804ee5fbae03
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Jul 24 14:38:46 2010 -0400

    "transport select" returns Jim value
    
    Make it scriptable, so code can be conditionalized based on
    what transport is in use for the session.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 89c9f66..97d2e81 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2451,7 +2451,7 @@ version of OpenOCD.
 Select which of the supported transports to use in this OpenOCD session.
 The transport must be supported by the debug adapter hardware  and by the
 version of OPenOCD you are using (including the adapter's driver).
-No arguments: print selected transport..
+No arguments: returns name of session's selected transport.
 @end deffn
 
 @subsection JTAG Transport
diff --git a/src/jtag/transport.c b/src/jtag/transport.c
index d290bd2..503b57b 100644
--- a/src/jtag/transport.c
+++ b/src/jtag/transport.c
@@ -46,6 +46,9 @@
 
 #include "transport.h"
 
+extern struct command_context *global_cmd_ctx;
+
+
 /*-----------------------------------------------------------------------*/
 
 /*
@@ -272,39 +275,26 @@ COMMAND_HANDLER(handle_transport_list)
 /**
  * Implements the Tcl "transport select" command, choosing the
  * transport to be used in this debug session from among the
- * set supported by the debug adapter being used.
+ * set supported by the debug adapter being used.  Return value
+ * is scriptable (allowing "if swd then..." etc).
  */
-COMMAND_HANDLER(handle_transport_select)
+static int jim_transport_select(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
-	int retval = ERROR_OK;;
-
-	switch (CMD_ARGC) {
-	case 0:			/* "select" */
-		if (session) {
-			goto show;
-		}
-		LOG_ERROR("session's transport is not selected.");
-		return ERROR_FAIL;
-
-	case 1:			/* "select FOO" */
-		if ((session!= NULL) && strcmp(session->name, CMD_ARGV[0]) == 0) {
-			/* NOP */
-			LOG_DEBUG("transport '%s' is already selected",
-					CMD_ARGV[0]);
-			return ERROR_OK;
+	switch (argc) {
+	case 1:			/* return/display */
+		if (!session) {
+			LOG_ERROR("session's transport is not selected.");
+			return JIM_ERR;
 		} else {
-			/* we can't change this session's transport after-the-fact */
-			if (session) {
-				LOG_ERROR("session's transport is already selected.");
-				return ERROR_FAIL;
-			}
+			Jim_SetResultString(interp, session->name, -1);
+			return JIM_OK;
 		}
 		break;
-
-	default:		/* select FOO BAR */
-		/* we only select *one* transport per session */
-		LOG_ERROR("may only select one transport!");
-		return ERROR_COMMAND_SYNTAX_ERROR;
+	case 2:			/* assign */
+	if (session) {
+		/* can't change session's transport after-the-fact */
+		LOG_ERROR("session's transport is already selected.");
+		return JIM_ERR;
 	}
 
 	/* Is this transport supported by our debug adapter?
@@ -315,24 +305,23 @@ COMMAND_HANDLER(handle_transport_select)
 	 */
 	if (!allowed_transports) {
 		LOG_ERROR("Debug adapter doesn't support any transports?");
-		return ERROR_FAIL;
+		return JIM_ERR;
 	}
 
 	for (unsigned i = 0; allowed_transports[i]; i++) {
 
-		if (strcmp(allowed_transports[i], CMD_ARGV[0]) == 0)
-			return transport_select(CMD_CTX, CMD_ARGV[0]);
+		if (strcmp(allowed_transports[i], argv[0]->bytes) == 0)
+		return transport_select(global_cmd_ctx, argv[0]->bytes);
 	}
 
-	LOG_ERROR("Debug adapter doesn't support '%s' "
-			"transport?", CMD_ARGV[0]);
-	return ERROR_FAIL;
-
-
-show:
-	/* report the current transport selection */
-	command_print(CMD_CTX, "%s", session->name);
-	return retval;
+		LOG_ERROR("Debug adapter doesn't support '%s' "
+			"transport", argv[0]->bytes);
+		return JIM_ERR;
+		break;
+	default:
+		Jim_WrongNumArgs(interp, 1, argv, "[too many parameters]");
+		return JIM_ERR;
+	}
 }
 
 static const struct command_registration transport_commands[] = {
@@ -354,7 +343,7 @@ static const struct command_registration transport_commands[] = {
 	},
 	{
 		.name = "select",
-		.handler = handle_transport_select,
+		.jim_handler = jim_transport_select,
 		.mode = COMMAND_ANY,
 		.help = "Select this session's transport",
 		.usage = "[transport_name]",

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi     |    2 +-
 src/jtag/transport.c |   71 +++++++++++++++++++++-----------------------------
 2 files changed, 31 insertions(+), 42 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jul 30 22:37:13 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 30 Jul 2010 20:37:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-453-gf4c1f08
Message-ID: <E1OewKZ-0005fr-GK@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f4c1f08f164ab74a7893742218ac0f8dd4a2e473 (commit)
      from  a463670c312befd86224e74a79aa804ee5fbae03 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f4c1f08f164ab74a7893742218ac0f8dd4a2e473
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Jul 30 22:34:43 2010 +0200

    lpc7168: make flash available upon reset init
    
    set user mode to avoid ROM being mapped at address
    0 rather than flash.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index fc00d78..88827fa 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -52,3 +52,22 @@ flash bank $_FLASHNAME lpc2000 0x0 0x80000 0 0 $_TARGETNAME \
 # a reset-init handler) speeds it up.
 jtag_rclk [ expr 4000 / 6 ]
 $_TARGETNAME configure -event reset-start { jtag_rclk [ expr 4000 / 6]  }
+
+
+$_TARGETNAME configure -event reset-init {
+	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
+	# "User Flash Mode" where interrupt vectors are _not_ remapped,
+	# and reside in flash instead).
+	#
+	# See Table 612. Memory Mapping Control register (MEMMAP - 0x400F C040) bit description
+	# Bit Symbol Value Description Reset
+	# value
+	# 0 MAP Memory map control. 0
+	# 0 Boot mode. A portion of the Boot ROM is mapped to address 0.
+	# 1 User mode. The on-chip Flash memory is mapped to address 0.
+	# 31:1 - Reserved. The value read from a reserved bit is not defined. NA
+	#
+	# http://ics.nxp.com/support/documents/microcontrollers/?scope=LPC1768&type=user
+
+	mww 0x400FC040 0x01
+}

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc1768.cfg |   19 +++++++++++++++++++
 1 files changed, 19 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


