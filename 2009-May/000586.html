<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1802 - trunk/src/flash
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1802%20-%20trunk/src/flash&In-Reply-To=%3C200905180437.n4I4bajS020288%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000585.html">
   <LINK REL="Next"  HREF="000587.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1802 - trunk/src/flash</H1>
    <B>kc8apf at BerliOS</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1802%20-%20trunk/src/flash&In-Reply-To=%3C200905180437.n4I4bajS020288%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1802 - trunk/src/flash">kc8apf at mail.berlios.de
       </A><BR>
    <I>Mon May 18 06:37:36 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000585.html">[Openocd-svn] r1801 - trunk/src/target
</A></li>
        <LI>Next message: <A HREF="000587.html">[Openocd-svn] r1803 - trunk/doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#586">[ date ]</a>
              <a href="thread.html#586">[ thread ]</a>
              <a href="subject.html#586">[ subject ]</a>
              <a href="author.html#586">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kc8apf
Date: 2009-05-18 06:37:33 +0200 (Mon, 18 May 2009)
New Revision: 1802

Modified:
   trunk/src/flash/lpc3180_nand_controller.c
   trunk/src/flash/nand.c
   trunk/src/flash/nand.h
   trunk/src/flash/s3c2410_nand.c
   trunk/src/flash/s3c2412_nand.c
   trunk/src/flash/s3c2440_nand.c
   trunk/src/flash/s3c2443_nand.c
   trunk/src/flash/s3c24xx_nand.c
   trunk/src/flash/s3c24xx_nand.h
   trunk/src/flash/stellaris.h
   trunk/src/flash/stm32x.h
   trunk/src/flash/str7x.h
Log:
Whitespace cleanup from David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">david-b at pacbell.net</A>&gt;

Modified: trunk/src/flash/lpc3180_nand_controller.c
===================================================================
--- trunk/src/flash/lpc3180_nand_controller.c	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/lpc3180_nand_controller.c	2009-05-18 04:37:33 UTC (rev 1802)
@@ -61,13 +61,13 @@
 static int lpc3180_nand_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct nand_device_s *device)
 {
 	lpc3180_nand_controller_t *lpc3180_info;
-	
+
 	if (argc &lt; 3)
 	{
 		LOG_WARNING(&quot;incomplete 'lpc3180' nand flash configuration&quot;);
 		return ERROR_FLASH_BANK_INVALID;
 	}
-	
+
 	lpc3180_info = malloc(sizeof(lpc3180_nand_controller_t));
 	device-&gt;controller_priv = lpc3180_info;
 
@@ -81,22 +81,22 @@
 	lpc3180_info-&gt;osc_freq = strtoul(args[2], NULL, 0);
 	if ((lpc3180_info-&gt;osc_freq &lt; 1000) || (lpc3180_info-&gt;osc_freq &gt; 20000))
 	{
-		LOG_WARNING(&quot;LPC3180 oscillator frequency should be between 1000 and 20000 kHz, was %i&quot;, lpc3180_info-&gt;osc_freq); 
+		LOG_WARNING(&quot;LPC3180 oscillator frequency should be between 1000 and 20000 kHz, was %i&quot;, lpc3180_info-&gt;osc_freq);
 	}
 	lpc3180_info-&gt;selected_controller = LPC3180_NO_CONTROLLER;
 	lpc3180_info-&gt;sw_write_protection = 0;
 	lpc3180_info-&gt;sw_wp_lower_bound = 0x0;
 	lpc3180_info-&gt;sw_wp_upper_bound = 0x0;
-		
+
 	return ERROR_OK;
 }
 
 static int lpc3180_register_commands(struct command_context_s *cmd_ctx)
 {
 	command_t *lpc3180_cmd = register_command(cmd_ctx, NULL, &quot;lpc3180&quot;, NULL, COMMAND_ANY, &quot;commands specific to the LPC3180 NAND flash controllers&quot;);
-	
+
 	register_command(cmd_ctx, lpc3180_cmd, &quot;select&quot;, handle_lpc3180_select_command, COMMAND_EXEC, &quot;select &lt;'mlc'|'slc'&gt; controller (default is mlc)&quot;);
-	
+
 	return ERROR_OK;
 }
 
@@ -112,20 +112,20 @@
 
 	if (!lock)
 		LOG_WARNING(&quot;PLL is not locked&quot;);
-	
+
 	if (!bypass &amp;&amp; direct)	/* direct mode */
 		return (m * fclkin) / n;
-	
+
 	if (bypass &amp;&amp; !direct)	/* bypass mode */
 		return fclkin / (2 * p);
-	
+
 	if (bypass &amp; direct)	/* direct bypass mode */
 		return fclkin;
-	
+
 	if (feedback)			/* integer mode */
 		return m * (fclkin / n);
 	else					/* non-integer mode */
-		return (m / (2 * p)) * (fclkin / n); 
+		return (m / (2 * p)) * (fclkin / n);
 }
 
 static float lpc3180_cycle_time(lpc3180_nand_controller_t *lpc3180_info)
@@ -136,20 +136,20 @@
 	int hclk;
 	int hclk_pll;
 	float cycle;
-	
+
 	/* calculate timings */
-	
-	/* determine current SYSCLK (13'MHz or main oscillator) */ 
+
+	/* determine current SYSCLK (13'MHz or main oscillator) */
 	target_read_u32(target, 0x40004050, &amp;sysclk_ctrl);
-	
+
 	if ((sysclk_ctrl &amp; 1) == 0)
 		sysclk = lpc3180_info-&gt;osc_freq;
 	else
 		sysclk = 13000;
-	
+
 	/* determine selected HCLK source */
 	target_read_u32(target, 0x40004044, &amp;pwr_ctrl);
-	
+
 	if ((pwr_ctrl &amp; (1 &lt;&lt; 2)) == 0) /* DIRECT RUN mode */
 	{
 		hclk = sysclk;
@@ -160,21 +160,21 @@
 		hclk_pll = lpc3180_pll(sysclk, hclkpll_ctrl);
 
 		target_read_u32(target, 0x40004040, &amp;hclkdiv_ctrl);
-		
+
 		if (pwr_ctrl &amp; (1 &lt;&lt; 10)) /* ARM_CLK and HCLK use PERIPH_CLK */
 		{
 			hclk = hclk_pll / (((hclkdiv_ctrl &amp; 0x7c) &gt;&gt; 2) + 1);
 		}
 		else /* HCLK uses HCLK_PLL */
 		{
-			hclk = hclk_pll / (1 &lt;&lt; (hclkdiv_ctrl &amp; 0x3)); 
+			hclk = hclk_pll / (1 &lt;&lt; (hclkdiv_ctrl &amp; 0x3));
 		}
 	}
-	
+
 	LOG_DEBUG(&quot;LPC3180 HCLK currently clocked at %i kHz&quot;, hclk);
-	
+
 	cycle = (1.0 / hclk) * 1000000.0;
-	
+
 	return cycle;
 }
 
@@ -185,20 +185,20 @@
 	int bus_width = (device-&gt;bus_width) ? (device-&gt;bus_width) : 8;
 	int address_cycles = (device-&gt;address_cycles) ? (device-&gt;address_cycles) : 3;
 	int page_size = (device-&gt;page_size) ? (device-&gt;page_size) : 512;
-		
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	/* sanitize arguments */
 	if ((bus_width != 8) &amp;&amp; (bus_width != 16))
 	{
 		LOG_ERROR(&quot;LPC3180 only supports 8 or 16 bit bus width, not %i&quot;, bus_width);
 		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 	}
-	
+
 	/* The LPC3180 only brings out 8 bit NAND data bus, but the controller
 	 * would support 16 bit, too, so we just warn about this for now
 	 */
@@ -206,44 +206,44 @@
 	{
 		LOG_WARNING(&quot;LPC3180 only supports 8 bit bus width&quot;);
 	}
-	
+
 	/* inform calling code about selected bus width */
 	device-&gt;bus_width = bus_width;
-	
+
 	if ((address_cycles != 3) &amp;&amp; (address_cycles != 4))
 	{
 		LOG_ERROR(&quot;LPC3180 only supports 3 or 4 address cycles, not %i&quot;, address_cycles);
 		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 	}
-	
+
 	if ((page_size != 512) &amp;&amp; (page_size != 2048))
 	{
 		LOG_ERROR(&quot;LPC3180 only supports 512 or 2048 byte pages, not %i&quot;, page_size);
 		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 	}
-	
+
 	/* select MLC controller if none is currently selected */
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_DEBUG(&quot;no LPC3180 NAND flash controller selected, using default 'mlc'&quot;);
 		lpc3180_info-&gt;selected_controller = LPC3180_MLC_CONTROLLER;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_MLC_CONTROLLER)
 	{
 		u32 mlc_icr_value = 0x0;
 		float cycle;
 		int twp, twh, trp, treh, trhz, trbwb, tcea;
-		
+
 		/* FLASHCLK_CTRL = 0x22 (enable clock for MLC flash controller) */
 		target_write_u32(target, 0x400040c8, 0x22);
-		
+
 		/* MLC_CEH = 0x0 (Force nCE assert) */
 		target_write_u32(target, 0x200b804c, 0x0);
-		
+
 		/* MLC_LOCK = 0xa25e (unlock protected registers) */
 		target_write_u32(target, 0x200b8044, 0xa25e);
-		
+
 		/* MLC_ICR = configuration */
 		if (lpc3180_info-&gt;sw_write_protection)
 			mlc_icr_value |= 0x8;
@@ -254,10 +254,10 @@
 		if (bus_width == 16)
 			mlc_icr_value |= 0x1;
 		target_write_u32(target, 0x200b8030, mlc_icr_value);
-		
+
 		/* calculate NAND controller timings */
 		cycle = lpc3180_cycle_time(lpc3180_info);
-		
+
 		twp = ((40 / cycle) + 1);
 		twh = ((20 / cycle) + 1);
 		trp = ((30 / cycle) + 1);
@@ -265,14 +265,14 @@
 		trhz = ((30 / cycle) + 1);
 		trbwb = ((100 / cycle) + 1);
 		tcea = ((45 / cycle) + 1);
-		
+
 		/* MLC_LOCK = 0xa25e (unlock protected registers) */
 		target_write_u32(target, 0x200b8044, 0xa25e);
-	
+
 		/* MLC_TIME_REG */
-		target_write_u32(target, 0x200b8034, (twp &amp; 0xf) | ((twh &amp; 0xf) &lt;&lt; 4) | 
-			((trp &amp; 0xf) &lt;&lt; 8) | ((treh &amp; 0xf) &lt;&lt; 12) | ((trhz &amp; 0x7) &lt;&lt; 16) | 
-			((trbwb &amp; 0x1f) &lt;&lt; 19) | ((tcea &amp; 0x3) &lt;&lt; 24)); 
+		target_write_u32(target, 0x200b8034, (twp &amp; 0xf) | ((twh &amp; 0xf) &lt;&lt; 4) |
+			((trp &amp; 0xf) &lt;&lt; 8) | ((treh &amp; 0xf) &lt;&lt; 12) | ((trhz &amp; 0x7) &lt;&lt; 16) |
+			((trbwb &amp; 0x1f) &lt;&lt; 19) | ((tcea &amp; 0x3) &lt;&lt; 24));
 
 		lpc3180_reset(device);
 	}
@@ -281,30 +281,30 @@
 		float cycle;
 		int r_setup, r_hold, r_width, r_rdy;
 		int w_setup, w_hold, w_width, w_rdy;
-		
+
 		/* FLASHCLK_CTRL = 0x05 (enable clock for SLC flash controller) */
 		target_write_u32(target, 0x400040c8, 0x05);
-		
+
 		/* SLC_CFG = 0x (Force nCE assert, ECC enabled, WIDTH = bus_width) */
 		target_write_u32(target, 0x20020014, 0x28 | (bus_width == 16) ? 1 : 0);
-		
+
 		/* calculate NAND controller timings */
 		cycle = lpc3180_cycle_time(lpc3180_info);
-		
+
 		r_setup = w_setup = 0;
 		r_hold = w_hold = 10 / cycle;
 		r_width = 30 / cycle;
 		w_width = 40 / cycle;
 		r_rdy = w_rdy = 100 / cycle;
-		
+
 		/* SLC_TAC: SLC timing arcs register */
 		target_write_u32(target, 0x2002002c, (r_setup &amp; 0xf) | ((r_hold &amp; 0xf) &lt;&lt; 4) |
 			((r_width &amp; 0xf) &lt;&lt; 8) | ((r_rdy &amp; 0xf) &lt;&lt; 12) |  ((w_setup &amp; 0xf) &lt;&lt; 16) |
-			((w_hold &amp; 0xf) &lt;&lt; 20) | ((w_width &amp; 0xf) &lt;&lt; 24) | ((w_rdy &amp; 0xf) &lt;&lt; 28)); 
-		
+			((w_hold &amp; 0xf) &lt;&lt; 20) | ((w_width &amp; 0xf) &lt;&lt; 24) | ((w_rdy &amp; 0xf) &lt;&lt; 28));
+
 		lpc3180_reset(device);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -312,13 +312,13 @@
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_ERROR(&quot;BUG: no LPC3180 NAND flash controller selected&quot;);
@@ -339,14 +339,14 @@
 	{
 		/* SLC_CTRL = 0x6 (ECC_CLEAR, SW_RESET) */
 		target_write_u32(target, 0x20020010, 0x6);
-		
+
 		if (!lpc3180_controller_ready(device, 100))
 		{
 			LOG_ERROR(&quot;LPC3180 NAND controller timed out after reset&quot;);
 			return ERROR_NAND_OPERATION_TIMEOUT;
 		}
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -354,13 +354,13 @@
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_ERROR(&quot;BUG: no LPC3180 NAND flash controller selected&quot;);
@@ -375,8 +375,8 @@
 	{
 		/* SLC_CMD = command */
 		target_write_u32(target, 0x20020008, command);
-	}	
-	
+	}
+
 	return ERROR_OK;
 }
 
@@ -384,13 +384,13 @@
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_ERROR(&quot;BUG: no LPC3180 NAND flash controller selected&quot;);
@@ -406,7 +406,7 @@
 		/* SLC_ADDR = address */
 		target_write_u32(target, 0x20020004, address);
 	}
-		
+
 	return ERROR_OK;
 }
 
@@ -414,13 +414,13 @@
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_ERROR(&quot;BUG: no LPC3180 NAND flash controller selected&quot;);
@@ -436,7 +436,7 @@
 		/* SLC_DATA = data */
 		target_write_u32(target, 0x20020000, data);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -444,13 +444,13 @@
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_ERROR(&quot;BUG: no LPC3180 NAND flash controller selected&quot;);
@@ -481,7 +481,7 @@
 
 		/* data = SLC_DATA, must use 32-bit access */
 		target_read_u32(target, 0x20020000, &amp;data32);
-		
+
 		if (device-&gt;bus_width == 8)
 		{
 			u8 *data8 = data;
@@ -497,8 +497,8 @@
 			LOG_ERROR(&quot;BUG: bus_width neither 8 nor 16 bit&quot;);
 			return ERROR_NAND_OPERATION_FAILED;
 		}
-	}	
-	
+	}
+
 	return ERROR_OK;
 }
 
@@ -508,13 +508,13 @@
 	target_t *target = lpc3180_info-&gt;target;
 	int retval;
 	u8 status;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_ERROR(&quot;BUG: no LPC3180 NAND flash controller selected&quot;);
@@ -525,30 +525,30 @@
 		u8 *page_buffer;
 		u8 *oob_buffer;
 		int quarter, num_quarters;
-		
+
 		if (!data &amp;&amp; oob)
 		{
 			LOG_ERROR(&quot;LPC3180 MLC controller can't write OOB data only&quot;);
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 		}
-		
+
 		if (oob &amp;&amp; (oob_size &gt; 6))
 		{
 			LOG_ERROR(&quot;LPC3180 MLC controller can't write more than 6 bytes of OOB data&quot;);
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 		}
-		
+
 		if (data_size &gt; (u32)device-&gt;page_size)
 		{
 			LOG_ERROR(&quot;data size exceeds page size&quot;);
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 		}
-		
+
 		/* MLC_CMD = sequential input */
 		target_write_u32(target, 0x200b8000, NAND_CMD_SEQIN);
 
 		page_buffer = malloc(512);
-		oob_buffer = malloc(6);		
+		oob_buffer = malloc(6);
 
 		if (device-&gt;page_size == 512)
 		{
@@ -558,7 +558,7 @@
 			/* MLC_ADDR = row */
 			target_write_u32(target, 0x200b8004, page &amp; 0xff);
 			target_write_u32(target, 0x200b8004, (page &gt;&gt; 8) &amp; 0xff);
-			
+
 			if (device-&gt;address_cycles == 4)
 				target_write_u32(target, 0x200b8004, (page &gt;&gt; 16) &amp; 0xff);
 		}
@@ -572,17 +572,17 @@
 			target_write_u32(target, 0x200b8004, page &amp; 0xff);
 			target_write_u32(target, 0x200b8004, (page &gt;&gt; 8) &amp; 0xff);
 		}
-		
+
 		/* when using the MLC controller, we have to treat a large page device
 		 * as being made out of four quarters, each the size of a small page device
 		 */
 		num_quarters = (device-&gt;page_size == 2048) ? 4 : 1;
-		 
+
 		for (quarter = 0; quarter &lt; num_quarters; quarter++)
 		{
 			int thisrun_data_size = (data_size &gt; 512) ? 512 : data_size;
 			int thisrun_oob_size = (oob_size &gt; 6) ? 6 : oob_size;
-			
+
 			memset(page_buffer, 0xff, 512);
 			if (data)
 			{
@@ -590,7 +590,7 @@
 				data_size -= thisrun_data_size;
 				data += thisrun_data_size;
 			}
-			
+
 			memset(oob_buffer, 0xff, (device-&gt;page_size == 512) ? 6 : 24);
 			if (oob)
 			{
@@ -598,38 +598,38 @@
 				oob_size -= thisrun_oob_size;
 				oob += thisrun_oob_size;
 			}
-			
+
 			/* write MLC_ECC_ENC_REG to start encode cycle */
 			target_write_u32(target, 0x200b8008, 0x0);
-			
+
 			target-&gt;type-&gt;write_memory(target, 0x200a8000, 4, 128, page_buffer + (quarter * 512));
 			target-&gt;type-&gt;write_memory(target, 0x200a8000, 1, 6, oob_buffer + (quarter * 6));
-			
+
 			/* write MLC_ECC_AUTO_ENC_REG to start auto encode */
 			target_write_u32(target, 0x200b8010, 0x0);
-			
+
 			if (!lpc3180_controller_ready(device, 1000))
 			{
 				LOG_ERROR(&quot;timeout while waiting for completion of auto encode cycle&quot;);
 				return ERROR_NAND_OPERATION_FAILED;
 			}
 		}
-		
+
 		/* MLC_CMD = auto program command */
 		target_write_u32(target, 0x200b8000, NAND_CMD_PAGEPROG);
-		
+
 		if ((retval = nand_read_status(device, &amp;status)) != ERROR_OK)
 		{
 			LOG_ERROR(&quot;couldn't read status&quot;);
 			return ERROR_NAND_OPERATION_FAILED;
 		}
-			
+
 		if (status &amp; NAND_STATUS_FAIL)
 		{
 			LOG_ERROR(&quot;write operation didn't pass, status: 0x%2.2x&quot;, status);
 			return ERROR_NAND_OPERATION_FAILED;
 		}
-	
+
 		free(page_buffer);
 		free(oob_buffer);
 	}
@@ -637,7 +637,7 @@
 	{
 		return nand_write_page_raw(device, page, data, data_size, oob, oob_size);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -645,13 +645,13 @@
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	if (lpc3180_info-&gt;selected_controller == LPC3180_NO_CONTROLLER)
 	{
 		LOG_ERROR(&quot;BUG: no LPC3180 NAND flash controller selected&quot;);
@@ -672,13 +672,13 @@
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 		}
 #endif
-		
+
 		if (data_size &gt; (u32)device-&gt;page_size)
 		{
 			LOG_ERROR(&quot;data size exceeds page size&quot;);
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 		}
-		
+
 		if (device-&gt;page_size == 2048)
 		{
 			page_buffer = malloc(2048);
@@ -689,10 +689,10 @@
 			page_buffer = malloc(512);
 			oob_buffer = malloc(16);
 		}
-		
+
 		if (!data &amp;&amp; oob)
 		{
-			/* MLC_CMD = Read OOB 
+			/* MLC_CMD = Read OOB
 			 * we can use the READOOB command on both small and large page devices,
 			 * as the controller translates the 0x50 command to a 0x0 with appropriate
 			 * positioning of the serial buffer read pointer
@@ -704,7 +704,7 @@
 			/* MLC_CMD = Read0 */
 			target_write_u32(target, 0x200b8000, NAND_CMD_READ0);
 		}
-		
+
 		if (device-&gt;page_size == 512)
 		{
 			/* small page device */
@@ -714,7 +714,7 @@
 			/* MLC_ADDR = row */
 			target_write_u32(target, 0x200b8004, page &amp; 0xff);
 			target_write_u32(target, 0x200b8004, (page &gt;&gt; 8) &amp; 0xff);
-			
+
 			if (device-&gt;address_cycles == 4)
 				target_write_u32(target, 0x200b8004, (page &gt;&gt; 16) &amp; 0xff);
 		}
@@ -728,24 +728,24 @@
 			/* MLC_ADDR = row */
 			target_write_u32(target, 0x200b8004, page &amp; 0xff);
 			target_write_u32(target, 0x200b8004, (page &gt;&gt; 8) &amp; 0xff);
-			
+
 			/* MLC_CMD = Read Start */
 			target_write_u32(target, 0x200b8000, NAND_CMD_READSTART);
 		}
-		
+
 		while (page_bytes_done &lt; (u32)device-&gt;page_size)
 		{
 			/* MLC_ECC_AUTO_DEC_REG = dummy */
 			target_write_u32(target, 0x200b8014, 0xaa55aa55);
-			
+
 			if (!lpc3180_controller_ready(device, 1000))
 			{
 				LOG_ERROR(&quot;timeout while waiting for completion of auto decode cycle&quot;);
 				return ERROR_NAND_OPERATION_FAILED;
 			}
-		
+
 			target_read_u32(target, 0x200b8048, &amp;mlc_isr);
-			
+
 			if (mlc_isr &amp; 0x8)
 			{
 				if (mlc_isr &amp; 0x40)
@@ -753,15 +753,15 @@
 					LOG_ERROR(&quot;uncorrectable error detected: 0x%2.2x&quot;, mlc_isr);
 					return ERROR_NAND_OPERATION_FAILED;
 				}
-				
+
 				LOG_WARNING(&quot;%i symbol error detected and corrected&quot;, ((mlc_isr &amp; 0x30) &gt;&gt; 4) + 1);
 			}
-			
+
 			if (data)
 			{
 				target-&gt;type-&gt;read_memory(target, 0x200a8000, 4, 128, page_buffer + page_bytes_done);
 			}
-			
+
 			if (oob)
 			{
 				target-&gt;type-&gt;read_memory(target, 0x200a8000, 4, 4, oob_buffer + oob_bytes_done);
@@ -770,13 +770,13 @@
 			page_bytes_done += 512;
 			oob_bytes_done += 16;
 		}
-		
+
 		if (data)
 			memcpy(data, page_buffer, data_size);
-		
+
 		if (oob)
 			memcpy(oob, oob_buffer, oob_size);
-		
+
 		free(page_buffer);
 		free(oob_buffer);
 	}
@@ -784,7 +784,7 @@
 	{
 		return nand_read_page_raw(device, page, data, data_size, oob, oob_size);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -793,20 +793,20 @@
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
 	u8 status = 0x0;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-			
+
 	do
 	{
 		if (lpc3180_info-&gt;selected_controller == LPC3180_MLC_CONTROLLER)
 		{
 			/* Read MLC_ISR, wait for controller to become ready */
 			target_read_u8(target, 0x200b8048, &amp;status);
-			
+
 			if (status &amp; 2)
 				return 1;
 		}
@@ -818,7 +818,7 @@
 
 		alive_sleep(1);
 	} while (timeout-- &gt; 0);
-	
+
 	return 0;
 }
 
@@ -826,65 +826,65 @@
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;target must be halted to use LPC3180 NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-			
+
 	do
 	{
 		if (lpc3180_info-&gt;selected_controller == LPC3180_MLC_CONTROLLER)
-		{	
+		{
 			u8 status = 0x0;
-			
+
 			/* Read MLC_ISR, wait for NAND flash device to become ready */
 			target_read_u8(target, 0x200b8048, &amp;status);
-			
+
 			if (status &amp; 1)
 				return 1;
 		}
 		else if (lpc3180_info-&gt;selected_controller == LPC3180_SLC_CONTROLLER)
 		{
 			u32 status = 0x0;
-			
+
 			/* Read SLC_STAT and check READY bit */
 			target_read_u32(target, 0x20020018, &amp;status);
-			
+
 			if (status &amp; 1)
 				return 1;
 		}
-		
+
 		alive_sleep(1);
 	} while (timeout-- &gt; 0);
-	
-	return 0;	
+
+	return 0;
 }
 
 static int handle_lpc3180_select_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	nand_device_t *device = NULL;
 	lpc3180_nand_controller_t *lpc3180_info = NULL;
-	char *selected[] = 
+	char *selected[] =
 	{
 		&quot;no&quot;, &quot;mlc&quot;, &quot;slc&quot;
 	};
-	
+
 	if ((argc &lt; 1) || (argc &gt; 2))
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	
+
 	device = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (!device)
 	{
 		command_print(cmd_ctx, &quot;nand device '#%s' is out of bounds&quot;, args[0]);
 		return ERROR_OK;
 	}
-	
+
 	lpc3180_info = device-&gt;controller_priv;
-	
+
 	if (argc == 2)
 	{
 		if (strcmp(args[1], &quot;mlc&quot;) == 0)
@@ -900,8 +900,8 @@
 			return ERROR_COMMAND_SYNTAX_ERROR;
 		}
 	}
-	
+
 	command_print(cmd_ctx, &quot;%s controller selected&quot;, selected[lpc3180_info-&gt;selected_controller]);
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/flash/nand.c
===================================================================
--- trunk/src/flash/nand.c	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/nand.c	2009-05-18 04:37:33 UTC (rev 1802)
@@ -216,17 +216,17 @@
 {
 	int i;
 	int retval;
-		
+
 	if (argc &lt; 1)
 	{
 		LOG_WARNING(&quot;incomplete flash device nand configuration&quot;);
 		return ERROR_FLASH_BANK_INVALID;
 	}
-	
+
 	for (i = 0; nand_flash_controllers[i]; i++)
 	{
 		nand_device_t *p, *c;
-		
+
 		if (strcmp(args[0], nand_flash_controllers[i]-&gt;name) == 0)
 		{
 			/* register flash specific commands */
@@ -235,7 +235,7 @@
 				LOG_ERROR(&quot;couldn't register '%s' commands&quot;, args[0]);
 				return retval;
 			}
-	
+
 			c = malloc(sizeof(nand_device_t));
 
 			c-&gt;controller = nand_flash_controllers[i];
@@ -254,7 +254,7 @@
 				free(c);
 				return ERROR_OK;
 			}
-			
+
 			/* put NAND device in linked list */
 			if (nand_devices)
 			{
@@ -267,7 +267,7 @@
 			{
 				nand_devices = c;
 			}
-			
+
 			return ERROR_OK;
 		}
 	}
@@ -281,16 +281,16 @@
 	{
 		LOG_ERROR(&quot;%i: %s&quot;, i, nand_flash_controllers[i]-&gt;name);
 	}
-	
+
 	return ERROR_OK;
 }
 
 int nand_register_commands(struct command_context_s *cmd_ctx)
 {
 	nand_cmd = register_command(cmd_ctx, NULL, &quot;nand&quot;, NULL, COMMAND_ANY, &quot;NAND specific commands&quot;);
-	
+
 	register_command(cmd_ctx, nand_cmd, &quot;device&quot;, handle_nand_device_command, COMMAND_CONFIG, NULL);
-	
+
 	return ERROR_OK;
 }
 
@@ -317,7 +317,7 @@
 		register_command(cmd_ctx, nand_cmd, &quot;raw_access&quot;, handle_nand_raw_access_command, COMMAND_EXEC,
 						 &quot;raw access to NAND flash device &lt;num&gt; ['enable'|'disable']&quot;);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -333,7 +333,7 @@
 			return p;
 		}
 	}
-	
+
 	return NULL;
 }
 
@@ -342,17 +342,17 @@
 	u32 page = 0x0;
 	int i;
 	u8 oob[6];
-	
+
 	if ((first &lt; 0) || (first &gt;= device-&gt;num_blocks))
 		first = 0;
-	
+
 	if ((last &gt;= device-&gt;num_blocks) || (last == -1))
 		last = device-&gt;num_blocks - 1;
-	
+
 	for (i = first; i &lt; last; i++)
 	{
 		nand_read_page(device, page, NULL, 0, oob, 6);
-		
+
 		if (((device-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16) &amp;&amp; ((oob[0] &amp; oob[1]) != 0xff))
 			|| (((device-&gt;page_size == 512) &amp;&amp; (oob[5] != 0xff)) ||
 				((device-&gt;page_size == 2048) &amp;&amp; (oob[0] != 0xff))))
@@ -364,10 +364,10 @@
 		{
 			device-&gt;blocks[i].is_bad = 0;
 		}
-		
+
 		page += (device-&gt;erase_size / device-&gt;page_size);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -375,12 +375,12 @@
 {
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-		
+
 	/* Send read status command */
 	device-&gt;controller-&gt;command(device, NAND_CMD_STATUS);
-	
+
 	alive_sleep(1);
-	
+
 	/* read status */
 	if (device-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
 	{
@@ -392,7 +392,7 @@
 	{
 		device-&gt;controller-&gt;read_data(device, status);
 	}
-			
+
 	return ERROR_OK;
 }
 
@@ -427,13 +427,13 @@
 	/* clear device data */
 	device-&gt;device = NULL;
 	device-&gt;manufacturer = NULL;
-	
+
 	/* clear device parameters */
 	device-&gt;bus_width = 0;
 	device-&gt;address_cycles = 0;
 	device-&gt;page_size = 0;
 	device-&gt;erase_size = 0;
-	
+
 	/* initialize controller (device parameters are zero, use controller default) */
 	if ((retval = device-&gt;controller-&gt;init(device) != ERROR_OK))
 	{
@@ -450,13 +450,13 @@
 				return ERROR_NAND_OPERATION_FAILED;
 		}
 	}
-	
+
 	device-&gt;controller-&gt;command(device, NAND_CMD_RESET);
 	device-&gt;controller-&gt;reset(device);
 
 	device-&gt;controller-&gt;command(device, NAND_CMD_READID);
 	device-&gt;controller-&gt;address(device, 0x0);
-	
+
 	if (device-&gt;bus_width == 8)
 	{
 		device-&gt;controller-&gt;read_data(device, &amp;manufacturer_id);
@@ -470,7 +470,7 @@
 		device-&gt;controller-&gt;read_data(device, &amp;data_buf);
 		device_id = data_buf &amp; 0xff;
 	}
-		
+
 	for (i = 0; nand_flash_ids[i].name; i++)
 	{
 		if (nand_flash_ids[i].id == device_id)
@@ -479,7 +479,7 @@
 			break;
 		}
 	}
-	
+
 	for (i = 0; nand_manuf_ids[i].name; i++)
 	{
 		if (nand_manuf_ids[i].id == manufacturer_id)
@@ -488,25 +488,25 @@
 			break;
 		}
 	}
-	
+
 	if (!device-&gt;manufacturer)
 	{
 		device-&gt;manufacturer = &amp;nand_manuf_ids[0];
 		device-&gt;manufacturer-&gt;id = manufacturer_id;
 	}
-	
+
 	if (!device-&gt;device)
 	{
 		LOG_ERROR(&quot;unknown NAND flash device found, manufacturer id: 0x%2.2x device id: 0x%2.2x&quot;,
 			manufacturer_id, device_id);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	LOG_DEBUG(&quot;found %s (%s)&quot;, device-&gt;device-&gt;name, device-&gt;manufacturer-&gt;name);
-	
+
 	/* initialize device parameters */
-	
-	/* bus width */ 
+
+	/* bus width */
 	if (device-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
 		device-&gt;bus_width = 16;
 	else
@@ -536,7 +536,7 @@
 			id_buff[5] = data_buf &gt;&gt; 8;
 		}
 	}
-		
+
 	/* page size */
 	if (device-&gt;device-&gt;page_size == 0)
 	{
@@ -551,7 +551,7 @@
 	{
 		device-&gt;page_size = device-&gt;device-&gt;page_size;
 	}
-	
+
 	/* number of address cycles */
 	if (device-&gt;page_size &lt;= 512)
 	{
@@ -579,7 +579,7 @@
 			device-&gt;address_cycles = 6;
 		}
 	}
-	
+
 	/* erase size */
 	if (device-&gt;device-&gt;erase_size == 0)
 	{
@@ -602,7 +602,7 @@
 	{
 		device-&gt;erase_size = device-&gt;device-&gt;erase_size;
 	}
-	
+
 	/* initialize controller, but leave parameters at the controllers default */
 	if ((retval = device-&gt;controller-&gt;init(device) != ERROR_OK))
 	{
@@ -620,10 +620,10 @@
 				return ERROR_NAND_OPERATION_FAILED;
 		}
 	}
-	
+
 	device-&gt;num_blocks = (device-&gt;device-&gt;chip_size * 1024) / (device-&gt;erase_size / 1024);
 	device-&gt;blocks = malloc(sizeof(nand_block_t) * device-&gt;num_blocks);
-	
+
 	for (i = 0; i &lt; device-&gt;num_blocks; i++)
 	{
 		device-&gt;blocks[i].size = device-&gt;erase_size;
@@ -631,7 +631,7 @@
 		device-&gt;blocks[i].is_erased = -1;
 		device-&gt;blocks[i].is_bad = -1;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -641,13 +641,13 @@
 	u32 page;
 	u8 status;
 	int retval;
-	
+
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-	
+
 	if ((first_block &lt; 0) || (last_block &gt; device-&gt;num_blocks))
 		return ERROR_INVALID_ARGUMENTS;
-	
+
 	/* make sure we know if a block is bad before erasing it */
 	for (i = first_block; i &lt;= last_block; i++)
 	{
@@ -657,25 +657,25 @@
 			break;
 		}
 	}
-	
+
 	for (i = first_block; i &lt;= last_block; i++)
 	{
 		/* Send erase setup command */
 		device-&gt;controller-&gt;command(device, NAND_CMD_ERASE1);
-		
+
 		page = i * (device-&gt;erase_size / device-&gt;page_size);
-		
+
 		/* Send page address */
 		if (device-&gt;page_size &lt;= 512)
 		{
 			/* row */
 			device-&gt;controller-&gt;address(device, page &amp; 0xff);
 			device-&gt;controller-&gt;address(device, (page &gt;&gt; 8) &amp; 0xff);
-			
+
 			/* 3rd cycle only on devices with more than 32 MiB */
 			if (device-&gt;address_cycles &gt;= 4)
 				device-&gt;controller-&gt;address(device, (page &gt;&gt; 16) &amp; 0xff);
-	
+
 			/* 4th cycle only on devices with more than 8 GiB */
 			if (device-&gt;address_cycles &gt;= 5)
 				device-&gt;controller-&gt;address(device, (page &gt;&gt; 24) &amp; 0xff);
@@ -685,12 +685,12 @@
 			/* row */
 			device-&gt;controller-&gt;address(device, page &amp; 0xff);
 			device-&gt;controller-&gt;address(device, (page &gt;&gt; 8) &amp; 0xff);
-	
+
 			/* 3rd cycle only on devices with more than 128 MiB */
 			if (device-&gt;address_cycles &gt;= 5)
 				device-&gt;controller-&gt;address(device, (page &gt;&gt; 16) &amp; 0xff);
 		}
-		
+
 		/* Send erase confirm command */
 		device-&gt;controller-&gt;command(device, NAND_CMD_ERASE2);
 
@@ -701,13 +701,13 @@
 			LOG_ERROR(&quot;timeout waiting for NAND flash block erase to complete&quot;);
 			return ERROR_NAND_OPERATION_TIMEOUT;
 		}
-		
+
 		if ((retval = nand_read_status(device, &amp;status)) != ERROR_OK)
 		{
 			LOG_ERROR(&quot;couldn't read status&quot;);
 			return ERROR_NAND_OPERATION_FAILED;
 		}
-		
+
 		if (status &amp; 0x1)
 		{
 			LOG_ERROR(&quot;erase operation didn't pass, status: 0x%2.2x&quot;, status);
@@ -716,7 +716,7 @@
 
 		device-&gt;blocks[i].is_erased = 1;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -724,74 +724,74 @@
 static int nand_read_plain(struct nand_device_s *device, u32 address, u8 *data, u32 data_size)
 {
 	u8 *page;
-	
+
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-		
+
 	if (address % device-&gt;page_size)
 	{
 		LOG_ERROR(&quot;reads need to be page aligned&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	page = malloc(device-&gt;page_size);
-	
+
 	while (data_size &gt; 0 )
 	{
 		u32 thisrun_size = (data_size &gt; device-&gt;page_size) ? device-&gt;page_size : data_size;
 		u32 page_address;
-		
-		
+
+
 		page_address = address / device-&gt;page_size;
-		
+
 		nand_read_page(device, page_address, page, device-&gt;page_size, NULL, 0);
 
 		memcpy(data, page, thisrun_size);
-		
+
 		address += thisrun_size;
 		data += thisrun_size;
 		data_size -= thisrun_size;
 	}
-	
+
 	free(page);
-	
+
 	return ERROR_OK;
 }
 
 static int nand_write_plain(struct nand_device_s *device, u32 address, u8 *data, u32 data_size)
 {
 	u8 *page;
-	
+
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-		
+
 	if (address % device-&gt;page_size)
 	{
 		LOG_ERROR(&quot;writes need to be page aligned&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	page = malloc(device-&gt;page_size);
-	
+
 	while (data_size &gt; 0 )
 	{
 		u32 thisrun_size = (data_size &gt; device-&gt;page_size) ? device-&gt;page_size : data_size;
 		u32 page_address;
-		
+
 		memset(page, 0xff, device-&gt;page_size);
 		memcpy(page, data, thisrun_size);
-		
+
 		page_address = address / device-&gt;page_size;
-		
+
 		nand_write_page(device, page_address, page, device-&gt;page_size, NULL, 0);
-		
+
 		address += thisrun_size;
 		data += thisrun_size;
 		data_size -= thisrun_size;
 	}
-	
+
 	free(page);
-	
+
 	return ERROR_OK;
 }
 #endif
@@ -802,7 +802,7 @@
 
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-		
+
 	block = page / (device-&gt;erase_size / device-&gt;page_size);
 	if (device-&gt;blocks[block].is_erased == 1)
 		device-&gt;blocks[block].is_erased = 0;
@@ -817,7 +817,7 @@
 {
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
-		
+
 	if (device-&gt;use_raw || device-&gt;controller-&gt;read_page == NULL)
 		return nand_read_page_raw(device, page, data, data_size, oob, oob_size);
 	else
@@ -827,7 +827,7 @@
 int nand_read_page_raw(struct nand_device_s *device, u32 page, u8 *data, u32 data_size, u8 *oob, u32 oob_size)
 {
 	u32 i;
-	
+
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
 
@@ -838,14 +838,14 @@
 			device-&gt;controller-&gt;command(device, NAND_CMD_READ0);
 		else
 			device-&gt;controller-&gt;command(device, NAND_CMD_READOOB);
-		
+
 		/* column (always 0, we start at the beginning of a page/OOB area) */
 		device-&gt;controller-&gt;address(device, 0x0);
-		
+
 		/* row */
 		device-&gt;controller-&gt;address(device, page &amp; 0xff);
 		device-&gt;controller-&gt;address(device, (page &gt;&gt; 8) &amp; 0xff);
-		
+
 		/* 4th cycle only on devices with more than 32 MiB */
 		if (device-&gt;address_cycles &gt;= 4)
 			device-&gt;controller-&gt;address(device, (page &gt;&gt; 16) &amp; 0xff);
@@ -858,7 +858,7 @@
 	{
 		/* large page device */
 		device-&gt;controller-&gt;command(device, NAND_CMD_READ0);
-		
+
 		/* column (0 when we start at the beginning of a page,
 		 * or 2048 for the beginning of OOB area)
 		 */
@@ -867,7 +867,7 @@
 			device-&gt;controller-&gt;address(device, 0x0);
 		else
 			device-&gt;controller-&gt;address(device, 0x8);
-		
+
 		/* row */
 		device-&gt;controller-&gt;address(device, page &amp; 0xff);
 		device-&gt;controller-&gt;address(device, (page &gt;&gt; 8) &amp; 0xff);
@@ -879,14 +879,14 @@
 		/* large page devices need a start command */
 		device-&gt;controller-&gt;command(device, NAND_CMD_READSTART);
 	}
-	
+
 	if (device-&gt;controller-&gt;nand_ready) {
 		if (!device-&gt;controller-&gt;nand_ready(device, 100))
 			return ERROR_NAND_OPERATION_TIMEOUT;
 	} else {
 		alive_sleep(1);
 	}
-	
+
 	if (data)
 	{
 		if (device-&gt;controller-&gt;read_block_data != NULL)
@@ -910,7 +910,7 @@
 			}
 		}
 	}
-	
+
 	if (oob)
 	{
 		if (device-&gt;controller-&gt;read_block_data != NULL)
@@ -934,8 +934,8 @@
 			}
 		}
 	}
-	
-	return ERROR_OK;	
+
+	return ERROR_OK;
 }
 
 int nand_write_page_raw(struct nand_device_s *device, u32 page, u8 *data, u32 data_size, u8 *oob, u32 oob_size)
@@ -943,21 +943,21 @@
 	u32 i;
 	int retval;
 	u8 status;
-	
+
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
 
 	device-&gt;controller-&gt;command(device, NAND_CMD_SEQIN);
-	
+
 	if (device-&gt;page_size &lt;= 512)
 	{
 		/* column (always 0, we start at the beginning of a page/OOB area) */
 		device-&gt;controller-&gt;address(device, 0x0);
-		
+
 		/* row */
 		device-&gt;controller-&gt;address(device, page &amp; 0xff);
 		device-&gt;controller-&gt;address(device, (page &gt;&gt; 8) &amp; 0xff);
-		
+
 		/* 4th cycle only on devices with more than 32 MiB */
 		if (device-&gt;address_cycles &gt;= 4)
 			device-&gt;controller-&gt;address(device, (page &gt;&gt; 16) &amp; 0xff);
@@ -976,7 +976,7 @@
 			device-&gt;controller-&gt;address(device, 0x0);
 		else
 			device-&gt;controller-&gt;address(device, 0x8);
-		
+
 		/* row */
 		device-&gt;controller-&gt;address(device, page &amp; 0xff);
 		device-&gt;controller-&gt;address(device, (page &gt;&gt; 8) &amp; 0xff);
@@ -985,7 +985,7 @@
 		if (device-&gt;address_cycles &gt;= 5)
 			device-&gt;controller-&gt;address(device, (page &gt;&gt; 16) &amp; 0xff);
 	}
-	
+
 	if (data)
 	{
 		if (device-&gt;controller-&gt;write_block_data != NULL)
@@ -1010,7 +1010,7 @@
 			}
 		}
 	}
-	
+
 	if (oob)
 	{
 		if (device-&gt;controller-&gt;write_block_data != NULL)
@@ -1035,41 +1035,41 @@
 			}
 		}
 	}
-	
+
 	device-&gt;controller-&gt;command(device, NAND_CMD_PAGEPROG);
-	
+
 	retval = device-&gt;controller-&gt;nand_ready ?
 			device-&gt;controller-&gt;nand_ready(device, 100) :
 			nand_poll_ready(device, 100);
 	if (!retval)
 		return ERROR_NAND_OPERATION_TIMEOUT;
-	
+
 	if ((retval = nand_read_status(device, &amp;status)) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;couldn't read status&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-		
+
 	if (status &amp; NAND_STATUS_FAIL)
 	{
 		LOG_ERROR(&quot;write operation didn't pass, status: 0x%2.2x&quot;, status);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
-	return ERROR_OK;	
+
+	return ERROR_OK;
 }
 
 int handle_nand_list_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	nand_device_t *p;
 	int i = 0;
-	
+
 	if (!nand_devices)
 	{
 		command_print(cmd_ctx, &quot;no NAND flash devices configured&quot;);
 		return ERROR_OK;
 	}
-	
+
 	for (p = nand_devices; p; p = p-&gt;next)
 	{
 		if (p-&gt;device)
@@ -1078,7 +1078,7 @@
 		else
 			command_print(cmd_ctx, &quot;#%i: not probed&quot;);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1089,13 +1089,13 @@
 	int j = 0;
 	int first = -1;
 	int last = -1;
-		
+
 	if ((argc &lt; 1) || (argc &gt; 3))
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	}
-	
+
 	if (argc == 2)
 	{
 		first = last = strtoul(args[1], NULL, 0);
@@ -1105,7 +1105,7 @@
 		first = strtoul(args[1], NULL, 0);
 		last = strtoul(args[2], NULL, 0);
 	}
-		
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
@@ -1113,24 +1113,24 @@
 		{
 			if (first &gt;= p-&gt;num_blocks)
 				first = p-&gt;num_blocks - 1;
-			
+
 			if (last &gt;= p-&gt;num_blocks)
 				last = p-&gt;num_blocks - 1;
-			
+
 			command_print(cmd_ctx, &quot;#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i&quot;,
 				i++, p-&gt;device-&gt;name, p-&gt;manufacturer-&gt;name, p-&gt;page_size, p-&gt;bus_width, p-&gt;erase_size);
-			
+
 			for (j = first; j &lt;= last; j++)
 			{
 				char *erase_state, *bad_state;
-				
+
 				if (p-&gt;blocks[j].is_erased == 0)
 					erase_state = &quot;not erased&quot;;
 				else if (p-&gt;blocks[j].is_erased == 1)
 					erase_state = &quot;erased&quot;;
 				else
 					erase_state = &quot;erase state unknown&quot;;
-				
+
 				if (p-&gt;blocks[j].is_bad == 0)
 					bad_state = &quot;&quot;;
 				else if (p-&gt;blocks[j].is_bad == 1)
@@ -1148,7 +1148,7 @@
 			command_print(cmd_ctx, &quot;#%i: not probed&quot;);
 		}
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1156,12 +1156,12 @@
 {
 	nand_device_t *p;
 	int retval;
-		
+
 	if (argc != 1)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
@@ -1182,7 +1182,7 @@
 	{
 		command_print(cmd_ctx, &quot;NAND flash device '#%s' is out of bounds&quot;, args[0]);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1190,19 +1190,19 @@
 {
 	nand_device_t *p;
 	int retval;
-		
+
 	if (argc != 3)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	}
-	
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
 		int first = strtoul(args[1], NULL, 0);
 		int last = strtoul(args[2], NULL, 0);
-		
+
 		if ((retval = nand_erase(p, first, last)) == ERROR_OK)
 		{
 			command_print(cmd_ctx, &quot;successfully erased blocks %i to %i on NAND flash device '%s'&quot;, first, last, p-&gt;device-&gt;name);
@@ -1220,7 +1220,7 @@
 	{
 		command_print(cmd_ctx, &quot;NAND flash device '#%s' is out of bounds&quot;, args[0]);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1230,19 +1230,19 @@
 	int retval;
 	int first = -1;
 	int last = -1;
-		
+
 	if ((argc &lt; 1) || (argc &gt; 3) || (argc == 2))
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	}
-	
+
 	if (argc == 3)
 	{
 		first = strtoul(args[1], NULL, 0);
 		last = strtoul(args[2], NULL, 0);
 	}
-	
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
@@ -1263,20 +1263,20 @@
 	{
 		command_print(cmd_ctx, &quot;NAND flash device '#%s' is out of bounds&quot;, args[0]);
 	}
-	
+
 	return ERROR_OK;
 }
 
 static int handle_nand_copy_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	nand_device_t *p;
-		
+
 	if (argc != 4)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	}
-	
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
@@ -1286,7 +1286,7 @@
 	{
 		command_print(cmd_ctx, &quot;NAND flash device '#%s' is out of bounds&quot;, args[0]);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1296,20 +1296,20 @@
 	u32 binary_size;
 	u32 buf_cnt;
 	enum oob_formats oob_format = NAND_OOB_NONE;
-	
+
 	fileio_t fileio;
-	
+
 	duration_t duration;
 	char *duration_text;
-	
+
 	nand_device_t *p;
-		
+
 	if (argc &lt; 3)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	}
-	
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
@@ -1318,9 +1318,9 @@
 		u8 *oob = NULL;
 		u32 oob_size = 0;
 		const int *eccpos = NULL;
-			
+
 		offset = strtoul(args[2], NULL, 0);
-		
+
 		if (argc &gt; 3)
 		{
 			int i;
@@ -1341,16 +1341,16 @@
 				}
 			}
 		}
-		
+
 		duration_start_measure(&amp;duration);
 
 		if (fileio_open(&amp;fileio, args[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
 		{
 			return ERROR_OK;
 		}
-	
+
 		buf_cnt = binary_size = fileio.size;
-		
+
 		if (!(oob_format &amp; NAND_OOB_ONLY))
 		{
 			page_size = p-&gt;page_size;
@@ -1368,7 +1368,7 @@
 			}
 			oob = malloc(oob_size);
 		}
-		
+
 		if (offset % p-&gt;page_size)
 		{
 			command_print(cmd_ctx, &quot;only page size aligned offsets and sizes are supported&quot;);
@@ -1377,11 +1377,11 @@
 			free(page);
 			return ERROR_OK;
 		}
-		
+
 		while (buf_cnt &gt; 0)
 		{
 			u32 size_read;
-			
+
 			if (NULL != page)
 			{
 				fileio_read(&amp;fileio, page_size, page, &amp;size_read);
@@ -1428,7 +1428,7 @@
 					memset(oob + size_read, 0xff, oob_size - size_read);
 				}
 			}
-			
+
 			if (nand_write_page(p, offset / p-&gt;page_size, page, page_size, oob, oob_size) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;failed writing file %s to NAND flash %s at offset 0x%8.8x&quot;,
@@ -1458,19 +1458,19 @@
 	{
 		command_print(cmd_ctx, &quot;NAND flash device '#%s' is out of bounds&quot;, args[0]);
 	}
-	
+
 	return ERROR_OK;
 }
 
 static int handle_nand_dump_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	nand_device_t *p;
-			
+
 	if (argc &lt; 4)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
@@ -1480,7 +1480,7 @@
 			duration_t duration;
 			char *duration_text;
 			int retval;
-			
+
 			u8 *page = NULL;
 			u32 page_size = 0;
 			u8 *oob = NULL;
@@ -1489,7 +1489,7 @@
 			u32 size = strtoul(args[3], NULL, 0);
 			u32 bytes_done = 0;
 			enum oob_formats oob_format = NAND_OOB_NONE;
-			
+
 			if (argc &gt; 4)
 			{
 				int i;
@@ -1500,16 +1500,16 @@
 					else if (!strcmp(args[i], &quot;oob_only&quot;))
 						oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
 					else
-						command_print(cmd_ctx, &quot;unknown option: '%s'&quot;, args[i]); 
+						command_print(cmd_ctx, &quot;unknown option: '%s'&quot;, args[i]);
 				}
 			}
-			
+
 			if ((address % p-&gt;page_size) || (size % p-&gt;page_size))
 			{
 				command_print(cmd_ctx, &quot;only page size aligned addresses and sizes are supported&quot;);
 				return ERROR_OK;
 			}
-		
+
 			if (!(oob_format &amp; NAND_OOB_ONLY))
 			{
 				page_size = p-&gt;page_size;
@@ -1524,14 +1524,14 @@
 					oob_size = 64;
 				oob = malloc(oob_size);
 			}
-			
+
 			if (fileio_open(&amp;fileio, args[1], FILEIO_WRITE, FILEIO_BINARY) != ERROR_OK)
 			{
 				return ERROR_OK;
 			}
-	
+
 			duration_start_measure(&amp;duration);
-			
+
 			while (size &gt; 0)
 			{
 				u32 size_written;
@@ -1539,27 +1539,27 @@
 				{
 					command_print(cmd_ctx, &quot;reading NAND flash page failed&quot;);
 					free(page);
-					free(oob);								
+					free(oob);
 					fileio_close(&amp;fileio);
 					return ERROR_OK;
 				}
-				
+
 				if (NULL != page)
 				{
 					fileio_write(&amp;fileio, page_size, page, &amp;size_written);
 					bytes_done += page_size;
 				}
-					
+
 				if (NULL != oob)
 				{
 					fileio_write(&amp;fileio, oob_size, oob, &amp;size_written);
 					bytes_done += oob_size;
 				}
-					
+
 				size -= p-&gt;page_size;
 				address += p-&gt;page_size;
 			}
-			
+
 			free(page);
 			page = NULL;
 			free(oob);
@@ -1580,19 +1580,19 @@
 	{
 		command_print(cmd_ctx, &quot;NAND flash device '#%s' is out of bounds&quot;, args[0]);
 	}
-	
+
 	return ERROR_OK;
 }
 
 static int handle_nand_raw_access_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	nand_device_t *p;
-		
+
 	if ((argc &lt; 1) || (argc &gt; 2))
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	
+
 	p = get_nand_device_by_num(strtoul(args[0], NULL, 0));
 	if (p)
 	{
@@ -1613,7 +1613,7 @@
 					return ERROR_COMMAND_SYNTAX_ERROR;
 				}
 			}
-	
+
 			command_print(cmd_ctx, &quot;raw access is %s&quot;, (p-&gt;use_raw) ? &quot;enabled&quot; : &quot;disabled&quot;);
 		}
 		else
@@ -1625,6 +1625,6 @@
 	{
 		command_print(cmd_ctx, &quot;NAND flash device '#%s' is out of bounds&quot;, args[0]);
 	}
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/flash/nand.h
===================================================================
--- trunk/src/flash/nand.h	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/nand.h	2009-05-18 04:37:33 UTC (rev 1802)
@@ -99,7 +99,7 @@
 
 typedef struct nand_manufacturer_s
 {
-    int id;
+	int id;
 	char *name;
 } nand_manufacturer_t;
 
@@ -115,43 +115,43 @@
 
 /* Option constants for bizarre disfunctionality and real features
  */
-enum { 
+enum {
 	/* Chip can not auto increment pages */
 	NAND_NO_AUTOINCR = 0x00000001,
-	
+
 	/* Buswitdh is 16 bit */
 	NAND_BUSWIDTH_16 = 0x00000002,
-	
+
 	/* Device supports partial programming without padding */
 	NAND_NO_PADDING = 0x00000004,
-	
+
 	/* Chip has cache program function */
 	NAND_CACHEPRG = 0x00000008,
-	
+
 	/* Chip has copy back function */
 	NAND_COPYBACK = 0x00000010,
-	
+
 	/* AND Chip which has 4 banks and a confusing page / block
 	 * assignment. See Renesas datasheet for further information */
 	NAND_IS_AND = 0x00000020,
-	
+
 	/* Chip has a array of 4 pages which can be read without
 	 * additional ready /busy waits */
 	NAND_4PAGE_ARRAY = 0x00000040,
-	
+
 	/* Chip requires that BBT is periodically rewritten to prevent
 	 * bits from adjacent blocks from 'leaking' in altering data.
 	 * This happens with the Renesas AG-AND chips, possibly others.  */
 	BBT_AUTO_REFRESH = 0x00000080,
-	
+
 	/* Chip does not require ready check on read. True
 	 * for all large page devices, as they do not support
 	 * autoincrement.*/
 	NAND_NO_READRDY = 0x00000100,
-	
+
 	/* Options valid for Samsung large page devices */
 	NAND_SAMSUNG_LP_OPTIONS = (NAND_NO_PADDING | NAND_CACHEPRG | NAND_COPYBACK),
-	
+
 	/* Options for new chips with large page size. The pagesize and the
 	 * erasesize is determined from the extended id bytes
 	 */
@@ -175,7 +175,7 @@
 	NAND_CMD_READID = 0x90,
 	NAND_CMD_ERASE2 = 0xd0,
 	NAND_CMD_RESET = 0xff,
-	
+
 	/* Extended commands for large page devices */
 	NAND_CMD_READSTART = 0x30,
 	NAND_CMD_RNDOUTSTART = 0xE0,
@@ -198,7 +198,7 @@
 	NAND_OOB_NONE = 0x0,	/* no OOB data at all */
 	NAND_OOB_RAW = 0x1,		/* raw OOB data (16 bytes for 512b page sizes, 64 bytes for 2048b page sizes) */
 	NAND_OOB_ONLY = 0x2,	/* only OOB data */
-	NAND_OOB_SW_ECC = 0x10,	/* when writing, use SW ECC (as opposed to no ECC) */ 
+	NAND_OOB_SW_ECC = 0x10,	/* when writing, use SW ECC (as opposed to no ECC) */
 	NAND_OOB_HW_ECC = 0x20, /* when writing, use HW ECC (as opposed to no ECC) */
 	NAND_OOB_SW_ECC_KW = 0x40, /* when writing, use Marvell's Kirkwood bootrom format */
 	NAND_OOB_JFFS2 = 0x100,	/* when writing, use JFFS2 OOB layout */

Modified: trunk/src/flash/s3c2410_nand.c
===================================================================
--- trunk/src/flash/s3c2410_nand.c	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/s3c2410_nand.c	2009-05-18 04:37:33 UTC (rev 1802)
@@ -59,7 +59,7 @@
 				struct nand_device_s *device)
 {
 	s3c24xx_nand_controller_t *info;
-	
+
 	info = s3c24xx_nand_device_command(cmd_ctx, cmd, args, argc, device);
 	if (info == NULL) {
 		return ERROR_NAND_DEVICE_INVALID;
@@ -70,7 +70,7 @@
 	info-&gt;addr = S3C2410_NFADDR;
 	info-&gt;data = S3C2410_NFDATA;
 	info-&gt;nfstat = S3C2410_NFSTAT;
-		
+
 	return ERROR_OK;
 }
 
@@ -79,7 +79,7 @@
 	s3c24xx_nand_controller_t *s3c24xx_info = device-&gt;controller_priv;
 	target_t *target = s3c24xx_info-&gt;target;
 
-	target_write_u32(target, S3C2410_NFCONF, 
+	target_write_u32(target, S3C2410_NFCONF,
 			 S3C2410_NFCONF_EN | S3C2410_NFCONF_TACLS(3) |
 			 S3C2410_NFCONF_TWRPH0(5) | S3C2410_NFCONF_TWRPH1(3));
 
@@ -95,7 +95,7 @@
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	target_write_u32(target, S3C2410_NFDATA, data);
 	return ERROR_OK;
 }
@@ -104,13 +104,13 @@
 {
 	s3c24xx_nand_controller_t *s3c24xx_info = device-&gt;controller_priv;
 	target_t *target = s3c24xx_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED) {
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	target_read_u8(target, S3C2410_NFDATA, data);	
+	target_read_u8(target, S3C2410_NFDATA, data);
 	return ERROR_OK;
 }
 
@@ -124,14 +124,14 @@
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	do {
 		target_read_u8(target, S3C2410_NFSTAT, &amp;status);
-		
+
 		if (status &amp; S3C2410_NFSTAT_BUSY)
 			return 1;
 
-		alive_sleep(1);		
+		alive_sleep(1);
 	} while (timeout-- &gt; 0);
 
 	return 0;

Modified: trunk/src/flash/s3c2412_nand.c
===================================================================
--- trunk/src/flash/s3c2412_nand.c	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/s3c2412_nand.c	2009-05-18 04:37:33 UTC (rev 1802)
@@ -69,7 +69,7 @@
 	info-&gt;addr = S3C2440_NFADDR;
 	info-&gt;data = S3C2440_NFDATA;
 	info-&gt;nfstat = S3C2412_NFSTAT;
-	
+
 	return ERROR_OK;
 }
 

Modified: trunk/src/flash/s3c2440_nand.c
===================================================================
--- trunk/src/flash/s3c2440_nand.c	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/s3c2440_nand.c	2009-05-18 04:37:33 UTC (rev 1802)
@@ -59,7 +59,7 @@
 				struct nand_device_s *device)
 {
 	s3c24xx_nand_controller_t *info;
-	
+
 	info = s3c24xx_nand_device_command(cmd_ctx, cmd, args, argc, device);
 	if (info == NULL) {
 		return ERROR_NAND_DEVICE_INVALID;
@@ -70,7 +70,7 @@
 	info-&gt;addr = S3C2440_NFADDR;
 	info-&gt;data = S3C2440_NFDATA;
 	info-&gt;nfstat = S3C2440_NFSTAT;
-		
+
 	return ERROR_OK;
 }
 
@@ -100,10 +100,10 @@
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
-	do {		
+
+	do {
 		target_read_u8(target, s3c24xx_info-&gt;nfstat, &amp;status);
-		
+
 		if (status &amp; S3C2440_NFSTAT_READY)
 			return 1;
 
@@ -130,7 +130,7 @@
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	while (data_size &gt;= 4) {	  
+	while (data_size &gt;= 4) {
 		target_read_u32(target, nfdata, &amp;tmp);
 
 		data[0] = tmp;
@@ -164,7 +164,7 @@
 		return ERROR_NAND_OPERATION_FAILED;
 	}
 
-	while (data_size &gt;= 4) {	  
+	while (data_size &gt;= 4) {
 		tmp = le_to_h_u32(data);
 		target_write_u32(target, nfdata, tmp);
 

Modified: trunk/src/flash/s3c2443_nand.c
===================================================================
--- trunk/src/flash/s3c2443_nand.c	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/s3c2443_nand.c	2009-05-18 04:37:33 UTC (rev 1802)
@@ -58,7 +58,7 @@
 				struct nand_device_s *device)
 {
 	s3c24xx_nand_controller_t *info;
-	
+
 	info = s3c24xx_nand_device_command(cmd_ctx, cmd, args, argc, device);
 	if (info == NULL) {
 		return ERROR_NAND_DEVICE_INVALID;
@@ -69,7 +69,7 @@
 	info-&gt;addr = S3C2440_NFADDR;
 	info-&gt;data = S3C2440_NFDATA;
 	info-&gt;nfstat = S3C2412_NFSTAT;
-	
+
 	return ERROR_OK;
 }
 

Modified: trunk/src/flash/s3c24xx_nand.c
===================================================================
--- trunk/src/flash/s3c24xx_nand.c	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/s3c24xx_nand.c	2009-05-18 04:37:33 UTC (rev 1802)
@@ -37,7 +37,7 @@
 			    struct nand_device_s *device)
 {
 	s3c24xx_nand_controller_t *s3c24xx_info;
-	
+
 	s3c24xx_info = malloc(sizeof(s3c24xx_nand_controller_t));
 	if (s3c24xx_info == NULL) {
 		LOG_ERROR(&quot;no memory for nand controller\n&quot;);
@@ -69,9 +69,9 @@
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	target_write_u32(target, s3c24xx_info-&gt;cmd, 0xff);
-	
+
 	return ERROR_OK;
 }
 
@@ -79,7 +79,7 @@
 {
 	s3c24xx_nand_controller_t *s3c24xx_info = device-&gt;controller_priv;
 	target_t *target = s3c24xx_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED) {
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
@@ -94,12 +94,12 @@
 {
 	s3c24xx_nand_controller_t *s3c24xx_info = device-&gt;controller_priv;
 	target_t *target = s3c24xx_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED) {
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	target_write_u16(target, s3c24xx_info-&gt;addr, address);
 	return ERROR_OK;
 }
@@ -113,7 +113,7 @@
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;
 	}
-	
+
 	target_write_u8(target, s3c24xx_info-&gt;data, data);
 	return ERROR_OK;
 }
@@ -122,7 +122,7 @@
 {
 	s3c24xx_nand_controller_t *s3c24xx_info = device-&gt;controller_priv;
 	target_t *target = s3c24xx_info-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED) {
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);
 		return ERROR_NAND_OPERATION_FAILED;

Modified: trunk/src/flash/s3c24xx_nand.h
===================================================================
--- trunk/src/flash/s3c24xx_nand.h	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/s3c24xx_nand.h	2009-05-18 04:37:33 UTC (rev 1802)
@@ -30,12 +30,12 @@
 typedef struct s3c24xx_nand_controller_s
 {
 	struct target_s *target;
-	
+
 	/* register addresses */
 	u32		 cmd;
 	u32		 addr;
 	u32		 data;
-	u32		 nfstat; 
+	u32		 nfstat;
 } s3c24xx_nand_controller_t;
 
 /* Default to using the un-translated NAND register based address */

Modified: trunk/src/flash/stellaris.h
===================================================================
--- trunk/src/flash/stellaris.h	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/stellaris.h	2009-05-18 04:37:33 UTC (rev 1802)
@@ -47,7 +47,6 @@
 	u32 rcc;
 	u8  mck_valid;
 	u32 mck_freq;
-	
 } stellaris_flash_bank_t;
 
 /* STELLARIS control registers */
@@ -66,7 +65,7 @@
 
 #define FMPRE		0x130
 #define FMPPE		0x134
-#define USECRL 		0x140
+#define USECRL		0x140
 
 #define FLASH_CONTROL_BASE	0x400FD000
 #define FLASH_FMA	(FLASH_CONTROL_BASE|0x000)
@@ -87,7 +86,7 @@
 #define FMC_COMT	(1&lt;&lt;3)
 #define FMC_MERASE	(1&lt;&lt;2)
 #define FMC_ERASE	(1&lt;&lt;1)
-#define FMC_WRITE	(1&lt;&lt;0)	
+#define FMC_WRITE	(1&lt;&lt;0)
 
 /* STELLARIS constants */
 

Modified: trunk/src/flash/stm32x.h
===================================================================
--- trunk/src/flash/stm32x.h	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/stm32x.h	2009-05-18 04:37:33 UTC (rev 1802)
@@ -66,17 +66,17 @@
 
 #define FLASH_PG		(1&lt;&lt;0)
 #define FLASH_PER		(1&lt;&lt;1)
-#define FLASH_MER   	(1&lt;&lt;2)
+#define FLASH_MER		(1&lt;&lt;2)
 #define FLASH_OPTPG		(1&lt;&lt;4)
 #define FLASH_OPTER		(1&lt;&lt;5)
 #define FLASH_STRT		(1&lt;&lt;6)
 #define FLASH_LOCK		(1&lt;&lt;7)
 #define FLASH_OPTWRE	(1&lt;&lt;9)
 
-/* FLASH_SR regsiter bits */
+/* FLASH_SR register bits */
 
 #define FLASH_BSY		(1&lt;&lt;0)
-#define FLASH_PGERR   	(1&lt;&lt;2)
+#define FLASH_PGERR		(1&lt;&lt;2)
 #define FLASH_WRPRTERR	(1&lt;&lt;4)
 #define FLASH_EOP		(1&lt;&lt;5)
 

Modified: trunk/src/flash/str7x.h
===================================================================
--- trunk/src/flash/str7x.h	2009-05-17 13:00:36 UTC (rev 1801)
+++ trunk/src/flash/str7x.h	2009-05-18 04:37:33 UTC (rev 1802)
@@ -59,14 +59,14 @@
 #define FLASH_AR		0x00000010
 #define FLASH_ER		0x00000014
 #define FLASH_NVWPAR	0x0000DFB0
-#define FLASH_NVAPR0 	0x0000DFB8
-#define FLASH_NVAPR1 	0x0000DFBC
+#define FLASH_NVAPR0	0x0000DFB8
+#define FLASH_NVAPR1	0x0000DFBC
 
 /* FLASH_CR0 register bits */
 
 #define FLASH_WMS		0x80000000
 #define FLASH_SUSP		0x40000000
-#define FLASH_WPG   	0x20000000
+#define FLASH_WPG		0x20000000
 #define FLASH_DWPG		0x10000000
 #define FLASH_SER		0x08000000
 #define FLASH_SPR		0x01000000
@@ -76,7 +76,7 @@
 #define FLASH_BSYA1		0x00000004
 #define FLASH_BSYA0		0x00000002
 
-/* FLASH_CR1 regsiter bits */
+/* FLASH_CR1 register bits */
 
 #define FLASH_B1S		0x02000000
 #define FLASH_B0S		0x01000000


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000585.html">[Openocd-svn] r1801 - trunk/src/target
</A></li>
	<LI>Next message: <A HREF="000587.html">[Openocd-svn] r1803 - trunk/doc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#586">[ date ]</a>
              <a href="thread.html#586">[ thread ]</a>
              <a href="subject.html#586">[ subject ]</a>
              <a href="author.html#586">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
