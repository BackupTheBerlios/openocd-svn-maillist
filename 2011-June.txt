From gowinex at users.sourceforge.net  Wed Jun  1 07:22:12 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  1 Jun 2011 05:22:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-893-g4da5517
Message-ID: <mailman.93.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4da551732eceee87085ec6b159bef6693c704835 (commit)
      from  096fd6bcc09f33d9ce684854c91d22223b8b03f2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4da551732eceee87085ec6b159bef6693c704835
Author: Laurent Charpentier <laurent_pubs at yahoo.com>
Date:   Tue May 31 01:52:50 2011 -0700

    bootstrap: fix argument handling
    
    - no argument => run submodule init
    - "nosubmoudle" => do not run submodule
    - other values => error message

diff --git a/bootstrap b/bootstrap
index 071ee2b..39ece23 100755
--- a/bootstrap
+++ b/bootstrap
@@ -27,13 +27,15 @@ automake --gnu --add-missing --copy
 # current source snapshots (working from GIT, or some source snapshot, etc)
 # otherwise the documentation will fail to build due to missing version.texi
 
-if [ -n $1 ] || [ $1 != nosubmodule ]
-then
+if [ $1 == nosubmodule ]; then
+    echo "Skipping submodule setup"
+elif [ -z $1 ]; then 
     echo "Setting up submodules"
     git submodule init
     git submodule update
 else
-    echo "Skipping submodule setup"
+    echo "Argument to bootstrap is either no argument or nosubmodule"
+    exit 1
 fi
 
 echo "Bootstrap complete. Quick start build instructions:"

-----------------------------------------------------------------------

Summary of changes:
 bootstrap |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun  1 07:25:09 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  1 Jun 2011 05:25:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-895-g796086c
Message-ID: <mailman.94.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  796086cd49f769a55bebcdd43d2d348672c87371 (commit)
       via  524d79ebe74e28d751c88e665aabac2ea4d04e5c (commit)
      from  4da551732eceee87085ec6b159bef6693c704835 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 796086cd49f769a55bebcdd43d2d348672c87371
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Tue May 31 09:33:01 2011 +0200

    mips: fixup fastdata
    
    fixup fastdata

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index f951049..449b6b8 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -342,7 +342,6 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_t *data)
 {
 	struct jtag_tap *tap;
-	uint8_t r[4];
 
 	tap = ejtag_info->tap;
 	assert(tap != NULL);
@@ -367,15 +366,14 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_
 	}
 	else
 	{
-		fields[1].in_value = r;
+		fields[1].in_value = (void *) data;
 	}
 
 	jtag_add_dr_scan(tap, 2, fields, TAP_IDLE);
 
-	if (!write_t)
-	{
-		*data = buf_get_u32(fields[1].in_value, 0, 32);
-	}
+	if ( (!write_t) && (data) )
+		jtag_add_callback(mips_le_to_h_u32,
+			(jtag_callback_data_t) data);
 
 	keep_alive();
 
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index a6ed95a..399246c 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -146,4 +146,10 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info);
 int mips_ejtag_config_step(struct mips_ejtag *ejtag_info, int enable_step);
 int mips_ejtag_read_debug(struct mips_ejtag *ejtag_info, uint32_t* debug_reg);
 
+static __inline__ void mips_le_to_h_u32(jtag_callback_data_t arg)
+{
+	uint8_t *in = (uint8_t *)arg;
+	*((uint32_t *)arg) = le_to_h_u32(in);
+}
+
 #endif /* MIPS_EJTAG */

commit 524d79ebe74e28d751c88e665aabac2ea4d04e5c
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Mon May 30 16:21:04 2011 +0200

    mips: fix some more endian madness

diff --git a/src/target/mips32.c b/src/target/mips32.c
index 79215b5..4782067 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -559,6 +559,13 @@ int mips32_configure_break_unit(struct target *target)
 			return retval;
 	}
 
+	/* check if target endianness settings matches debug control register */
+	if ( (  (dcr & EJTAG_DCR_ENM) && (target->endianness == TARGET_LITTLE_ENDIAN) ) ||
+		( !(dcr & EJTAG_DCR_ENM) && (target->endianness == TARGET_BIG_ENDIAN)    ) )
+	{
+		LOG_WARNING("DCR endianness settings does not match target settings");
+	}
+
 	LOG_DEBUG("DCR 0x%" PRIx32 " numinst %i numdata %i", dcr, mips32->num_inst_bpoints,
 			mips32->num_data_bpoints);
 
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 1166b87..03c9969 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -868,25 +868,22 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 	if (ERROR_OK != retval)
 		return retval;
 
-	/* TAP data register is loaded LSB first (little endian) */
-	if (target->endianness == TARGET_BIG_ENDIAN)
+	/* mips32_..._read_mem with size 4/2 returns uint32_t/uint16_t in host */
+	/* endianness, but byte array should represent target endianness       */
+	uint32_t i, t32;
+	uint16_t t16;
+	for(i = 0; i < (count*size); i += size)
 	{
-		uint32_t i, t32;
-		uint16_t t16;
-
-		for(i = 0; i < (count*size); i += size)
+		switch(size)
 		{
-			switch(size)
-			{
-				case 4:
-					t32 = le_to_h_u32(&buffer[i]);
-					h_u32_to_be(&buffer[i], t32);
-					break;
-				case 2:
-					t16 = le_to_h_u16(&buffer[i]);
-					h_u16_to_be(&buffer[i], t16);
-					break;
-			}
+		case 4:
+			t32 = *(uint32_t*)&buffer[i];
+			target_buffer_set_u32(target,&buffer[i], t32);
+			break;
+		case 2:
+			t16 = *(uint16_t*)&buffer[i];
+			target_buffer_set_u16(target,&buffer[i], t16);
+			break;
 		}
 	}
 
@@ -915,36 +912,33 @@ static int mips_m4k_write_memory(struct target *target, uint32_t address,
 	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
+	/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
+	/* endianness, but byte array represents target endianness               */
 	uint8_t * t = NULL;
-
-	/* TAP data register is loaded LSB first (little endian) */
-	if (target->endianness == TARGET_BIG_ENDIAN)
+	t = malloc(count * sizeof(uint32_t));
+	if (t == NULL)
 	{
-		t = malloc(count * sizeof(uint32_t));
-		if (t == NULL)
-		{
-			LOG_ERROR("Out of memory");
-			return ERROR_FAIL;
-		}
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
 
-		uint32_t i, t32, t16;
-		for(i = 0; i < (count*size); i += size)
+ 	uint32_t i, t32;
+	uint16_t t16;
+	for(i = 0; i < (count*size); i += size)
+	{
+		switch(size)
 		{
-			switch(size)
-			{
-				case 4:
-					t32 = be_to_h_u32((uint8_t *) &buffer[i]);
-					h_u32_to_le(&t[i], t32);
-					break;
-				case 2:
-					t16 = be_to_h_u16((uint8_t *) &buffer[i]);
-					h_u16_to_le(&t[i], t16);
-					break;
-			}
+		case 4:
+			t32 = target_buffer_get_u32(target,&buffer[i]);
+			*(uint32_t*)&t[i] = t32;
+			break;
+		case 2:
+			t16 = target_buffer_get_u16(target,&buffer[i]);
+			*(uint16_t*)&t[i] = t16;
+			break;
 		}
-
-		buffer = t;
 	}
+	buffer = t;
 
 	/* if noDMA off, use DMAACC mode for memory write */
 	int retval;
@@ -952,12 +946,13 @@ static int mips_m4k_write_memory(struct target *target, uint32_t address,
 		retval = mips32_pracc_write_mem(ejtag_info, address, size, count, (void *)buffer);
 	else
 		retval = mips32_dmaacc_write_mem(ejtag_info, address, size, count, (void *)buffer);
-	if (ERROR_OK != retval)
-		return retval;
 
 	if (t != NULL)
 		free(t);
 
+	if (ERROR_OK != retval)
+		return retval;
+
 	return ERROR_OK;
 }
 
@@ -1065,31 +1060,25 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		ejtag_info->fast_access_save = -1;
 	}
 
+	/* mips32_pracc_fastdata_xfer requires uint32_t in host endianness, */
+	/* but byte array represents target endianness                      */
 	uint8_t * t = NULL;
-	const uint8_t *ec_buffer = buffer;	/* endian-corrected buffer */
-
-	/* TAP data register is loaded LSB first (little endian) */
-	if (target->endianness == TARGET_BIG_ENDIAN)
+	t = malloc(count * sizeof(uint32_t));
+	if (t == NULL)
 	{
-		t = malloc(count * sizeof(uint32_t));
-		if (t == NULL)
-		{
-			LOG_ERROR("Out of memory");
-			return ERROR_FAIL;
-		}
-
-		uint32_t i, t32;
-		for(i = 0; i < (count * 4); i += 4)
-		{
-			t32 = be_to_h_u32((uint8_t *) &buffer[i]);
-			h_u32_to_le(&t[i], t32);
-		}
-
-		ec_buffer = t;
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
 	}
 
+ 	uint32_t i, t32;
+	for(i = 0; i < (count*4); i += 4)
+	{
+		t32 = target_buffer_get_u32(target,&buffer[i]);
+		*(uint32_t*)&t[i] = t32;
+	}
+	
 	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,
-			count, (uint32_t*) (void *)ec_buffer);
+			count, (uint32_t*) (void *)t);
 
 	if (t != NULL)
 		free(t);

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32.c     |    7 +++
 src/target/mips_ejtag.c |   10 ++---
 src/target/mips_ejtag.h |    6 +++
 src/target/mips_m4k.c   |  115 +++++++++++++++++++++--------------------------
 4 files changed, 69 insertions(+), 69 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun  1 21:47:00 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  1 Jun 2011 19:47:00 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-896-gfa1f268
Message-ID: <mailman.95.1331736154.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fa1f2682d4b8077a6c82002976f090827db3d8e5 (commit)
      from  796086cd49f769a55bebcdd43d2d348672c87371 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fa1f2682d4b8077a6c82002976f090827db3d8e5
Author: Tormod Volden <debian.tormod at gmail.com>
Date:   Wed Jun 1 20:59:52 2011 +0200

    bootstrap: Various code improvements
    
    - Do not specify -e twice.
    - Use "which" instead of calling commands that might not exist.
    - Fix bashism ("==" is C not sh)
    - Carefully quote potentially empty variables
    - Check command arguments before doing anything
    - Rewrite argument checking to be more easily extensible
    - Consistent indentation
    - UNIX style error messages

diff --git a/bootstrap b/bootstrap
index 39ece23..8a3945e 100755
--- a/bootstrap
+++ b/bootstrap
@@ -1,16 +1,24 @@
-#!/bin/sh -e
+#!/bin/sh
 # Run the autotools bootstrap sequence to create the configure script
 
-# Stop execution as soon as we have an unknown command
+# Abort execution on error
 set -e
 
-if libtoolize --version >/dev/null 2>&1; then
-	libtoolize="libtoolize"
-elif glibtoolize --version >/dev/null 2>&1; then
-	libtoolize="glibtoolize"
+if which libtoolize > /dev/null; then
+    libtoolize="libtoolize"
+elif which glibtoolize >/dev/null; then
+    libtoolize="glibtoolize"
 else
-	echo "libtool is required" >&2
-	exit 1
+    echo "$0: Error: libtool is required" >&2
+    exit 1
+fi
+
+if [ "$1" = "nosubmodule" ]; then
+    SKIP_SUBMODULE=1
+elif [ -n "$1" ]; then
+    echo "$0: Illegal argument $1"
+    echo "USAGE: $0 [nosubmodule]"
+    exit 1
 fi
 
 # bootstrap the autotools
@@ -27,16 +35,13 @@ automake --gnu --add-missing --copy
 # current source snapshots (working from GIT, or some source snapshot, etc)
 # otherwise the documentation will fail to build due to missing version.texi
 
-if [ $1 == nosubmodule ]; then
+if [ -n "$SKIP_SUBMODULE" ]; then
     echo "Skipping submodule setup"
-elif [ -z $1 ]; then 
+else
     echo "Setting up submodules"
     git submodule init
     git submodule update
-else
-    echo "Argument to bootstrap is either no argument or nosubmodule"
-    exit 1
 fi
 
-echo "Bootstrap complete. Quick start build instructions:"
+echo "Bootstrap complete. Quick build instructions:"
 echo "./configure --enable-maintainer-mode ...."

-----------------------------------------------------------------------

Summary of changes:
 bootstrap |   33 +++++++++++++++++++--------------
 1 files changed, 19 insertions(+), 14 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun  2 12:20:31 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  2 Jun 2011 10:20:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-897-gae02a0e
Message-ID: <mailman.96.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ae02a0e51708d292b4dff67c12baef1b62b367fa (commit)
      from  fa1f2682d4b8077a6c82002976f090827db3d8e5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ae02a0e51708d292b4dff67c12baef1b62b367fa
Author: Bear <jilingshu at gmail.com>
Date:   Thu Jun 2 12:17:28 2011 +0200

    uptech2410

diff --git a/tcl/board/uptech_2410.cfg b/tcl/board/uptech_2410.cfg
new file mode 100644
index 0000000..950f2a7
--- /dev/null
+++ b/tcl/board/uptech_2410.cfg
@@ -0,0 +1,65 @@
+# Target Configuration for the Uptech 2410 board.
+# This configuration hould also work on smdk2410, but I havn't tested it yet.
+# Author: xionglingfeng at Gmail.com
+
+source [find target/samsung_s3c2410.cfg]
+
+$_TARGETNAME configure -event reset-init { uptech2410_init }
+$_TARGETNAME configure -event gdb-attach { reset init }
+
+proc init_pll_sdram { } {
+	#echo "---------- Initializing PLL and SDRAM ---------"
+	#watchdog timer disable
+	mww phys 0x53000000 0x00000000
+	
+	#disable all interrupts
+	mww phys 0x4a000008 0xffffffff
+	
+	#disable all sub-interrupts
+	mww phys 0x4a00001c 0x000007ff
+	
+	#clear all source pending bits
+	mww phys 0x4a000000 0xffffffff
+	
+	#clear all sub-source pending bits
+	mww phys 0x4a000018 0x000007ff
+	
+	#clear interrupt pending bit
+	mww phys 0x4a000010 0xffffffff
+	
+	#PLL locktime counter
+	mww phys 0x4c000000 0x00ffffff
+	
+	#Fin=12MHz Fout=202.8MHz
+	#mww phys 0x4c000004 0x000a1031
+	
+	#FCLK:HCLK:PCLK = 1:2:4
+	mww phys 0x4c000014 0x00000003
+
+
+	mww phys 0x48000000 0x11111110
+	mww phys 0x48000004 0x00007FFC
+	mww phys 0x48000008 0x00007FFC
+	mww phys 0x4800000c 0x00000700
+	mww phys 0x48000010 0x00000700
+	mww phys 0x48000014 0x00002E50
+	mww phys 0x48000018 0x00002E50
+	mww phys 0x4800001c 0x00018005
+	mww phys 0x48000020 0x00018005
+	mww phys 0x48000024 0x008c04e9
+	mww phys 0x48000028 0x000000b2
+	mww phys 0x4800002c 0x00000030
+	mww phys 0x48000030 0x00000030
+}
+
+proc uptech2410_init { } {
+	init_pll_sdram
+	#echo "---------- Probing Nand flash ----------"
+	nand probe 0
+	#echo "---------- Enable some functions ----------"
+}
+
+set _NANDNAME $_CHIPNAME.nand
+nand device $_NANDNAME s3c2410 $_TARGETNAME
+
+

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/uptech_2410.cfg |   65 +++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 65 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/uptech_2410.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Jun  4 09:36:56 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  4 Jun 2011 07:36:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-898-gf6315d5
Message-ID: <mailman.97.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f6315d5e5b7b71515ef051711e5f818a42d6b3b3 (commit)
      from  ae02a0e51708d292b4dff67c12baef1b62b367fa (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f6315d5e5b7b71515ef051711e5f818a42d6b3b3
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Fri Jun 3 22:10:03 2011 +0200

    Fix "unused variable" warnings (errors) detected with GCC 4.7.0 - trivial fixes

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index ab1bf03..4b5fe7d 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -621,7 +621,6 @@ int flash_write_unlock(struct target *target, struct image *image,
 	{
 		uint32_t buffer_size;
 		uint8_t *buffer;
-		int section_first;
 		int section_last;
 		uint32_t run_address = sections[section]->base_address + section_offset;
 		uint32_t run_size = sections[section]->size - section_offset;
@@ -649,7 +648,6 @@ int flash_write_unlock(struct target *target, struct image *image,
 		}
 
 		/* collect consecutive sections which fall into the same bank */
-		section_first = section;
 		section_last = section;
 		padding[section] = 0;
 		while ((run_address + run_size - 1 < c->base + c->size - 1)
diff --git a/src/flash/nor/em357.c b/src/flash/nor/em357.c
index 8a3cf4c..a62be6a 100644
--- a/src/flash/nor/em357.c
+++ b/src/flash/nor/em357.c
@@ -813,7 +813,6 @@ COMMAND_HANDLER(em357_handle_lock_command)
 COMMAND_HANDLER(em357_handle_unlock_command)
 {
 	struct target *target = NULL;
-	struct em357_flash_bank *em357_info = NULL;
 
 	if (CMD_ARGC < 1)
 	{
@@ -826,8 +825,6 @@ COMMAND_HANDLER(em357_handle_unlock_command)
 	if (ERROR_OK != retval)
 		return retval;
 
-	em357_info = bank->driver_priv;
-
 	target = bank->target;
 
 	if (target->state != TARGET_HALTED)
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index a8392eb..69321ac 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -313,11 +313,8 @@ static int pic32mx_erase(struct flash_bank *bank, int first, int last)
 
 static int pic32mx_protect(struct flash_bank *bank, int set, int first, int last)
 {
-	struct pic32mx_flash_bank *pic32mx_info = NULL;
 	struct target *target = bank->target;
 
-	pic32mx_info = bank->driver_priv;
-
 	if (target->state != TARGET_HALTED)
 	{
 		LOG_ERROR("Target not halted");
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 3914d25..b4300be 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -1217,7 +1217,6 @@ COMMAND_HANDLER(stm32x_handle_lock_command)
 COMMAND_HANDLER(stm32x_handle_unlock_command)
 {
 	struct target *target = NULL;
-	struct stm32x_flash_bank *stm32x_info = NULL;
 
 	if (CMD_ARGC < 1)
 	{
@@ -1230,8 +1229,6 @@ COMMAND_HANDLER(stm32x_handle_unlock_command)
 	if (ERROR_OK != retval)
 		return retval;
 
-	stm32x_info = bank->driver_priv;
-
 	target = bank->target;
 
 	if (target->state != TARGET_HALTED)
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 303daa0..61a438f 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -681,7 +681,6 @@ static int get_str9x_info(struct flash_bank *bank, char *buf, int buf_size)
 
 COMMAND_HANDLER(str9x_handle_flash_config_command)
 {
-	struct str9x_flash_bank *str9x_info;
 	struct target *target = NULL;
 
 	if (CMD_ARGC < 5)
@@ -700,8 +699,6 @@ COMMAND_HANDLER(str9x_handle_flash_config_command)
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], bbadr);
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[4], nbbadr);
 
-	str9x_info = bank->driver_priv;
-
 	target = bank->target;
 
 	if (bank->target->state != TARGET_HALTED)
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index f4657bc..fdaeb61 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -175,7 +175,6 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 COMMAND_HANDLER(virtex2_handle_read_stat_command)
 {
 	struct pld_device *device;
-	struct virtex2_pld_device *virtex2_info;
 	uint32_t status;
 
 	if (CMD_ARGC < 1)
@@ -193,8 +192,6 @@ COMMAND_HANDLER(virtex2_handle_read_stat_command)
 		return ERROR_OK;
 	}
 
-	virtex2_info = device->driver_priv;
-
 	virtex2_read_stat(device, &status);
 
 	command_print(CMD_CTX, "virtex2 status register: 0x%8.8" PRIx32 "", status);
diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
index 818a979..263795c 100644
--- a/src/rtos/rtos.c
+++ b/src/rtos/rtos.c
@@ -314,15 +314,14 @@ int gdb_thread_packet(struct connection *connection, struct target *target, char
 				int symbol_num;
 
 				char* found = strstr( packet, "qSymbol::" );
-				int numconv;
 				if (0 == found )
 				{
-					numconv =sscanf(packet, "qSymbol:%" SCNx64 ":%s", &value, hex_name_str);
+					sscanf(packet, "qSymbol:%" SCNx64 ":%s", &value, hex_name_str);
 				}
 				else
 				{
 					// No value returned by GDB - symbol was not found
-					numconv =sscanf(packet, "qSymbol::%s", hex_name_str);
+					sscanf(packet, "qSymbol::%s", hex_name_str);
 				}
 				name_str = (char*) malloc( 1+ strlen(hex_name_str) / 2 );
 
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index b29ee4f..b6921ff 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -1731,11 +1731,10 @@ static int gdb_memory_map(struct connection *connection,
 	for (i = 0; i < flash_get_bank_count(); i++) {
 		int j;
 		unsigned sector_size = 0;
-		uint32_t start, end;
+		uint32_t start;
 
 		p = banks[i];
 		start = p->base;
-		end = p->base + p->size;
 
 		if (ram_start < p->base)
 			xml_printf(&retval, &xml, &pos, &size,
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 64be127..bb3f780 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -653,7 +653,7 @@ static int svf_read_command_from_file(FILE * fd)
 	unsigned char ch;
 	int i = 0;
 	size_t cmd_pos = 0;
-	int cmd_ok = 0, slash = 0, comment = 0;
+	int cmd_ok = 0, slash = 0;
 
 	if (svf_getline (&svf_read_line, &svf_read_line_size, svf_fd) <= 0)
 	{
@@ -699,7 +699,6 @@ static int svf_read_command_from_file(FILE * fd)
 			i = -1;
 		case '\r':
 			slash = 0;
-			comment = 0;
 			/* Don't save '\r' and '\n' if no data is parsed */
 			if (!cmd_pos)
 				break;
@@ -1507,13 +1506,12 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 		{
 #if 1
 			/* FIXME handle statemove failures */
-			int retval;
 			uint32_t min_usec = 1000000 * min_time;
 
 			// enter into run_state if necessary
 			if (cmd_queue_cur_state != svf_para.runtest_run_state)
 			{
-				retval = svf_add_statemove(svf_para.runtest_run_state);
+				svf_add_statemove(svf_para.runtest_run_state);
 			}
 
 			// add clocks and/or min wait
@@ -1530,7 +1528,7 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			// move to end_state if necessary
 			if (svf_para.runtest_end_state != svf_para.runtest_run_state)
 			{
-				retval = svf_add_statemove(svf_para.runtest_end_state);
+				svf_add_statemove(svf_para.runtest_end_state);
 			}
 #else
 			if (svf_para.runtest_run_state != TAP_IDLE)
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 76862ed..b41fbec 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -253,15 +253,12 @@ static int arm720t_verify_pointer(struct command_context *cmd_ctx,
 static int arm720t_arch_state(struct target *target)
 {
 	struct arm720t_common *arm720t = target_to_arm720(target);
-	struct arm *armv4_5;
 
 	static const char *state[] =
 	{
 		"disabled", "enabled"
 	};
 
-	armv4_5 = &arm720t->arm7_9_common.armv4_5_common;
-
 	arm_arch_state(target);
 	LOG_USER("MMU: %s, Cache: %s",
 			 state[arm720t->armv4_5_mmu.mmu_enabled],
@@ -466,13 +463,11 @@ COMMAND_HANDLER(arm720t_handle_cp15_command)
 	int retval;
 	struct target *target = get_current_target(CMD_CTX);
 	struct arm720t_common *arm720t = target_to_arm720(target);
-	struct arm_jtag *jtag_info;
 
 	retval = arm720t_verify_pointer(CMD_CTX, arm720t);
 	if (retval != ERROR_OK)
 		return retval;
 
-	jtag_info = &arm720t->arm7_9_common.jtag_info;
 
 	if (target->state != TARGET_HALTED)
 	{
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 210c253..f057d7b 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -533,7 +533,6 @@ int arm920t_arch_state(struct target *target)
 	};
 
 	struct arm920t_common *arm920t = target_to_arm920(target);
-	struct arm *armv4_5;
 
 	if (arm920t->common_magic != ARM920T_COMMON_MAGIC)
 	{
@@ -541,8 +540,6 @@ int arm920t_arch_state(struct target *target)
 		return ERROR_TARGET_INVALID;
 	}
 
-	armv4_5 = &arm920t->arm7_9_common.armv4_5_common;
-
 	arm_arch_state(target);
 	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
 		 state[arm920t->armv4_5_mmu.mmu_enabled],
@@ -898,7 +895,6 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 	uint32_t C15_C_D_Ind, C15_C_I_Ind;
 	int i;
 	FILE *output;
-	struct arm920t_cache_line d_cache[8][64], i_cache[8][64];
 	int segment, index_t;
 	struct reg *r;
 
@@ -1007,8 +1003,6 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				return retval;
 			}
 
-			d_cache[segment][index_t].cam = regs[9];
-
 			/* mask LFSR[6] */
 			regs[9] &= 0xfffffffe;
 			fprintf(output, "\nsegment: %i, index: %i, CAM: 0x%8.8"
@@ -1018,7 +1012,6 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			for (i = 1; i < 9; i++)
 			{
-				 d_cache[segment][index_t].data[i] = regs[i];
 				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n",
 						i-1, regs[i]);
 			}
@@ -1115,8 +1108,6 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				return retval;
 			}
 
-			i_cache[segment][index_t].cam = regs[9];
-
 			/* mask LFSR[6] */
 			regs[9] &= 0xfffffffe;
 			fprintf(output, "\nsegment: %i, index: %i, "
@@ -1126,7 +1117,6 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			for (i = 1; i < 9; i++)
 			{
-				 i_cache[segment][index_t].data[i] = regs[i];
 				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n",
 						i-1, regs[i]);
 			}
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index c72fe10..873e9a0 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -536,7 +536,6 @@ int arm926ejs_arch_state(struct target *target)
 	};
 
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
-	struct arm *armv4_5;
 
 	if (arm926ejs->common_magic != ARM926EJS_COMMON_MAGIC)
 	{
@@ -544,8 +543,6 @@ int arm926ejs_arch_state(struct target *target)
 		return ERROR_TARGET_INVALID;
 	}
 
-	armv4_5 = &arm926ejs->arm7_9_common.armv4_5_common;
-
 	arm_arch_state(target);
 	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
 			 state[arm926ejs->armv4_5_mmu.mmu_enabled],
diff --git a/src/target/arm946e.c b/src/target/arm946e.c
index 0922718..d9d953d 100644
--- a/src/target/arm946e.c
+++ b/src/target/arm946e.c
@@ -383,7 +383,6 @@ uint32_t arm946e_invalidate_dcache(struct target *target, uint32_t address,
 	uint32_t shift = 0;
 	uint32_t cur_addr = 0x0;
 	uint32_t cp15_idx, set, way, dtag;
-	int nb_idx;
 	uint32_t i = 0;
 	int retval;
 
@@ -403,7 +402,6 @@ uint32_t arm946e_invalidate_dcache(struct target *target, uint32_t address,
 			shift = csize - 0x3; /* Now 0 = 4KB, 1 = 8KB, ... */
 
 		csize = 1 << (12 + shift);
-		nb_idx = (csize / 32);
 
 		set = (cur_addr >> 5) & 0xff;	/* set field is 8 bits long */
 
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index cd6e5de..f8a2e22 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1088,7 +1088,7 @@ int dap_get_debugbase(struct adiv5_dap *dap, int ap,
 {
 	uint32_t ap_old;
 	int retval;
-	uint32_t dbgbase, apid, idcode;
+	uint32_t dbgbase, apid;
 
 	/* AP address is in bits 31:24 of DP_SELECT */
 	if (ap >= 256)
@@ -1110,10 +1110,8 @@ int dap_get_debugbase(struct adiv5_dap *dap, int ap,
 	/* Excavate the device ID code */
 	struct jtag_tap *tap = dap->jtag_info->tap;
 	while (tap != NULL) {
-		if (tap->hasidcode) {
-			idcode = tap->idcode;
+		if (tap->hasidcode)
 			break;
-		}
 		tap = tap->next_tap;
 	}
 	if (tap == NULL || !tap->hasidcode)
diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
index 10720f4..36566c9 100644
--- a/src/target/arm_disassembler.c
+++ b/src/target/arm_disassembler.c
@@ -300,7 +300,7 @@ static int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode,
 	else /* LDC or STC */
 	{
 		uint8_t CRd, Rn, offset;
-		uint8_t U, N;
+		uint8_t U;
 		char *mnemonic;
 		char addressing_mode[32];
 
@@ -321,7 +321,6 @@ static int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode,
 		}
 
 		U = (opcode & 0x00800000) >> 23;
-		N = (opcode & 0x00400000) >> 22;
 
 		/* addressing modes */
 		if ((opcode & 0x01200000) == 0x01000000) /* offset */
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index ac7f623..ef9b839 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -612,7 +612,6 @@ COMMAND_HANDLER(handle_armv4_5_reg_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct arm *armv4_5 = target_to_arm(target);
-	unsigned num_regs;
 	struct reg *regs;
 
 	if (!is_arm(armv4_5))
@@ -645,7 +644,6 @@ COMMAND_HANDLER(handle_armv4_5_reg_command)
 		return ERROR_FAIL;
 	}
 
-	num_regs = armv4_5->core_cache->num_regs;
 	regs = armv4_5->core_cache->reg_list;
 
 	for (unsigned mode = 0; mode < ARRAY_SIZE(arm_mode_data); mode++) {
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index 80f98dc..e6eb673 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -159,13 +159,11 @@ static void breakpoint_free(struct target *target, struct breakpoint *breakpoint
 void breakpoint_remove_internal(struct target *target, uint32_t address)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
-	struct breakpoint **breakpoint_p = &target->breakpoints;
 
 	while (breakpoint)
 	{
 		if (breakpoint->address == address)
 			break;
-		breakpoint_p = &breakpoint->next;
 		breakpoint = breakpoint->next;
 	}
 
@@ -332,13 +330,11 @@ static void watchpoint_free(struct target *target, struct watchpoint *watchpoint
 void watchpoint_remove(struct target *target, uint32_t address)
 {
 	struct watchpoint *watchpoint = target->watchpoints;
-	struct watchpoint **watchpoint_p = &target->watchpoints;
 
 	while (watchpoint)
 	{
 		if (watchpoint->address == address)
 			break;
-		watchpoint_p = &watchpoint->next;
 		watchpoint = watchpoint->next;
 	}
 
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 82cd8be..5290b63 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -349,13 +349,11 @@ static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_lis
 static int dsp563xx_read_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
-	struct dsp563xx_core_reg *dsp563xx_core_reg;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	if ((num < 0) || (num >= DSP563XX_NUMCOREREGS))
 		return ERROR_INVALID_ARGUMENTS;
 
-	dsp563xx_core_reg = dsp563xx->core_cache->reg_list[num].arch_info;
 	reg_value = dsp563xx->core_regs[num];
 	buf_set_u32(dsp563xx->core_cache->reg_list[num].value, 0, 32, reg_value);
 	dsp563xx->core_cache->reg_list[num].valid = 1;
@@ -367,14 +365,12 @@ static int dsp563xx_read_core_reg(struct target *target, int num)
 static int dsp563xx_write_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
-	struct dsp563xx_core_reg *dsp563xx_core_reg;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	if ((num < 0) || (num >= DSP563XX_NUMCOREREGS))
 		return ERROR_INVALID_ARGUMENTS;
 
 	reg_value = buf_get_u32(dsp563xx->core_cache->reg_list[num].value, 0, 32);
-	dsp563xx_core_reg = dsp563xx->core_cache->reg_list[num].arch_info;
 	dsp563xx->core_regs[num] = reg_value;
 	dsp563xx->core_cache->reg_list[num].valid = 1;
 	dsp563xx->core_cache->reg_list[num].dirty = 0;
@@ -582,7 +578,7 @@ static int dsp563xx_reg_pc_read(struct target *target)
 static int dsp563xx_reg_ssh_read(struct target *target)
 {
 	int err;
-	uint32_t sp, sc, ep;
+	uint32_t sp;
 	struct dsp563xx_core_reg *arch_info;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
@@ -598,14 +594,14 @@ static int dsp563xx_reg_ssh_read(struct target *target)
 	/* get a valid stack count */
 	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SC, 0)) != ERROR_OK)
 		return err;
-	sc = dsp563xx->core_regs[DSP563XX_REG_IDX_SC];
+
 	if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_SC, 0)) != ERROR_OK)
 		return err;
 
 	/* get a valid extended pointer */
 	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_EP, 0)) != ERROR_OK)
 		return err;
-	ep = dsp563xx->core_regs[DSP563XX_REG_IDX_EP];
+
 	if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_EP, 0)) != ERROR_OK)
 		return err;
 
@@ -1060,7 +1056,6 @@ static int dsp563xx_halt(struct target *target)
 static int dsp563xx_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	int err;
-	struct dsp563xx_core_reg *dsp563xx_core_reg;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	/* check if pc was changed and resume want to execute the next address
@@ -1072,7 +1067,6 @@ static int dsp563xx_resume(struct target *target, int current, uint32_t address,
 	if ( current && dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].dirty )
 	{
 		dsp563xx_write_core_reg(target,DSP563XX_REG_IDX_PC);
-		dsp563xx_core_reg = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].arch_info;
 		address = dsp563xx->core_regs[DSP563XX_REG_IDX_PC];
 		current = 0;
 	}
@@ -1112,7 +1106,6 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 	int err;
 	uint32_t once_status;
 	uint32_t dr_in, cnt;
-	struct dsp563xx_core_reg *dsp563xx_core_reg;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	if (target->state != TARGET_HALTED)
@@ -1130,7 +1123,6 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 	if ( current && dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].dirty )
 	{
 		dsp563xx_write_core_reg(target,DSP563XX_REG_IDX_PC);
-		dsp563xx_core_reg = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].arch_info;
 		address = dsp563xx->core_regs[DSP563XX_REG_IDX_PC];
 		current = 0;
 	}
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index b171dcf..a38028c 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -497,13 +497,12 @@ static int embeddedice_set_reg_w_exec(struct reg *reg, uint8_t *buf)
 void embeddedice_write_reg(struct reg *reg, uint32_t value)
 {
 	struct embeddedice_reg *ice_reg = reg->arch_info;
-	int retval;
 
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", ice_reg->addr, value);
 
-	retval = arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
+	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
-	retval = arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
+	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	uint8_t reg_addr = ice_reg->addr & 0x1f;
 	embeddedice_write_reg_inner(ice_reg->jtag_info->tap, reg_addr, value);
diff --git a/src/target/mips32.c b/src/target/mips32.c
index 4782067..65ea6e8 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -143,7 +143,6 @@ static int mips32_set_core_reg(struct reg *reg, uint8_t *buf)
 static int mips32_read_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
-	struct mips32_core_reg *mips_core_reg;
 
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -151,7 +150,6 @@ static int mips32_read_core_reg(struct target *target, int num)
 	if ((num < 0) || (num >= MIPS32NUMCOREREGS))
 		return ERROR_INVALID_ARGUMENTS;
 
-	mips_core_reg = mips32->core_cache->reg_list[num].arch_info;
 	reg_value = mips32->core_regs[num];
 	buf_set_u32(mips32->core_cache->reg_list[num].value, 0, 32, reg_value);
 	mips32->core_cache->reg_list[num].valid = 1;
@@ -163,7 +161,6 @@ static int mips32_read_core_reg(struct target *target, int num)
 static int mips32_write_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
-	struct mips32_core_reg *mips_core_reg;
 
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -172,7 +169,6 @@ static int mips32_write_core_reg(struct target *target, int num)
 		return ERROR_INVALID_ARGUMENTS;
 
 	reg_value = buf_get_u32(mips32->core_cache->reg_list[num].value, 0, 32);
-	mips_core_reg = mips32->core_cache->reg_list[num].arch_info;
 	mips32->core_regs[num] = reg_value;
 	LOG_DEBUG("write core reg %i value 0x%" PRIx32 "", num , reg_value);
 	mips32->core_cache->reg_list[num].valid = 1;
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 178f68e..af60d32 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -473,11 +473,8 @@ static int mips32_pracc_read_mem16(struct mips_ejtag *ejtag_info, uint32_t addr,
 
 	int retval = ERROR_OK;
 	int blocksize;
-	int bytesread;
 	uint32_t param_in[2];
 
-	bytesread = 0;
-
 	//while (count > 0)
 	{
 		blocksize = count;
@@ -492,7 +489,6 @@ static int mips32_pracc_read_mem16(struct mips_ejtag *ejtag_info, uint32_t addr,
 
 //		count -= blocksize;
 //		addr += blocksize;
-//		bytesread += blocksize;
 	}
 
 	for (i = 0; i < count; i++)
@@ -550,11 +546,8 @@ static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 
 	int retval = ERROR_OK;
 	int blocksize;
-	int bytesread;
 	uint32_t param_in[2];
 
-	bytesread = 0;
-
 //	while (count > 0)
 	{
 		blocksize = count;
@@ -569,7 +562,6 @@ static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 
 //		count -= blocksize;
 //		addr += blocksize;
-//		bytesread += blocksize;
 	}
 
 	for (i = 0; i < count; i++)
diff --git a/src/target/smp.c b/src/target/smp.c
index aabfa5b..f4adc8d 100644
--- a/src/target/smp.c
+++ b/src/target/smp.c
@@ -95,7 +95,6 @@ int gdb_write_smp_packet(struct connection *connection,
 {
 	char *separator;
 	int coreid = 0;
-    int retval = ERROR_OK;
 
 	/* skip command character */
 	if (target->smp)
@@ -110,7 +109,8 @@ int gdb_write_smp_packet(struct connection *connection,
 	}
 	else
 	{
-		retval = gdb_put_packet(connection,"E01",3);
+		gdb_put_packet(connection,"E01",3);
 	}
+
 	return ERROR_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/core.c          |    2 --
 src/flash/nor/em357.c         |    3 ---
 src/flash/nor/pic32mx.c       |    3 ---
 src/flash/nor/stm32x.c        |    3 ---
 src/flash/nor/str9x.c         |    3 ---
 src/pld/virtex2.c             |    3 ---
 src/rtos/rtos.c               |    5 ++---
 src/server/gdb_server.c       |    3 +--
 src/svf/svf.c                 |    8 +++-----
 src/target/arm720t.c          |    5 -----
 src/target/arm920t.c          |   10 ----------
 src/target/arm926ejs.c        |    3 ---
 src/target/arm946e.c          |    2 --
 src/target/arm_adi_v5.c       |    6 ++----
 src/target/arm_disassembler.c |    3 +--
 src/target/armv4_5.c          |    2 --
 src/target/breakpoints.c      |    4 ----
 src/target/dsp563xx.c         |   14 +++-----------
 src/target/embeddedice.c      |    5 ++---
 src/target/mips32.c           |    4 ----
 src/target/mips32_pracc.c     |    8 --------
 src/target/smp.c              |    4 ++--
 22 files changed, 16 insertions(+), 87 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Jun  4 09:47:03 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  4 Jun 2011 07:47:03 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-899-gf499bab
Message-ID: <mailman.98.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f499bab6984c815b8d7aea49bafcc85ac4beb522 (commit)
      from  f6315d5e5b7b71515ef051711e5f818a42d6b3b3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f499bab6984c815b8d7aea49bafcc85ac4beb522
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Fri Jun 3 22:13:35 2011 +0200

    Fix "unused variable" warnings (errors) detected with GCC 4.7.0 - dubious fixes

diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 4e90933..5c671cc 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -1045,10 +1045,6 @@ static inline struct arm11_common *dpm_to_arm11(struct arm_dpm *dpm)
 
 static int arm11_dpm_prepare(struct arm_dpm *dpm)
 {
-	struct arm11_common *arm11 = dpm_to_arm11(dpm);
-
-	arm11 = container_of(dpm->arm, struct arm11_common, arm);
-
 	return arm11_run_instr_data_prepare(dpm_to_arm11(dpm));
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11_dbgtap.c |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Jun  4 09:53:26 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat,  4 Jun 2011 07:53:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-901-gc989de0
Message-ID: <mailman.99.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c989de0cea1dafa22b0a089f2d68a80190f560e1 (commit)
       via  d09bef2622fe2a1baeae7a98fad02b25ed104d16 (commit)
      from  f499bab6984c815b8d7aea49bafcc85ac4beb522 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c989de0cea1dafa22b0a089f2d68a80190f560e1
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Thu Jun 2 09:59:18 2011 -0700

    crc check on flashed data

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 044fb7e..9eba374 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -716,7 +716,7 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
   uint16_t tmp;
   retval = eonce_rx_upper_data(target,&tmp);
   err_check_propagate(retval);
-  *data_read = (((*data_read)<<16) | tmp);
+  *data_read = ((tmp<<16) | (*data_read));//This enables opencd crc to succeed, even though it's very slow.
   return retval;
 }
 
@@ -973,7 +973,34 @@ static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint3
 }
 
 static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
-  return ERROR_FAIL; //this makes openocd do the crc
+ //TODO implement.
+  //This will make openocd do the work, but it will fail because of the word/byte addressing issues.
+  int retval;
+  struct working_area * crc_algorithm;
+  retval = target_alloc_working_area(target, 20, &crc_algorithm);
+  if(retval != ERROR_OK)
+    return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+  retval = target_free_working_area(target, crc_algorithm);
+  return ERROR_FAIL;
+}
+
+// Data signature algorithm used by the core FM (flash module)
+static int perl_crc(uint16_t * buff16,uint32_t  word_count){
+  uint16_t checksum = 0xffff;
+  uint16_t data,fbmisr;
+  uint32_t i;
+  for(i=0;i<word_count;i++){
+    data = buff16[i];
+    fbmisr = (checksum & 2)>>1 ^ (checksum & 4)>>2 ^ (checksum & 16)>>4 ^ (checksum & 0x8000)>>15;
+    checksum = (data ^ ((checksum << 1) | fbmisr));
+  }
+  i--;
+  for(;!(i&0x80000000);i--){
+    data = buff16[i];
+    fbmisr = (checksum & 2)>>1 ^ (checksum & 4)>>2 ^ (checksum & 16)>>4 ^ (checksum & 0x8000)>>15;
+    checksum = (data ^ ((checksum << 1) | fbmisr));
+  }
+  return checksum;
 }
 
 int dsp5680xx_f_SIM_reset(struct target * target){
@@ -1025,7 +1052,7 @@ int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected) {
   return retval;
 }
 
-static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint16_t * hfm_ustat, int pmem){
+static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint32_t data, uint16_t * hfm_ustat, int pmem){
   int retval;
   retval = eonce_load_TX_RX_high_to_r0(target);
   err_check_propagate(retval);
@@ -1057,6 +1084,8 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_PROTB);		// write to HMF_PROTB, clear protection
   err_check_propagate(retval);
+  retval = eonce_move_value_to_y0(target,data);
+  err_check_propagate(retval);
   retval = eonce_move_long_to_r3(target,address);			// write to the flash block
   err_check_propagate(retval);
   if (pmem){
@@ -1125,6 +1154,23 @@ static int eonce_set_hfmdiv(struct target * target){
   return ERROR_OK;
 }
 
+static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint32_t words, uint16_t * signature){
+  int retval;
+  uint16_t hfm_ustat;
+  if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
+    retval = eonce_enter_debug_mode(target,NULL);
+    err_check_propagate(retval);
+  }
+  retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&hfm_ustat,1);
+  err_check_propagate(retval);
+  if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,"HFM exec error:pviol and/or accer bits set.");
+  }
+  retval = dsp5680xx_read_16_single(target, HFM_BASE_ADDR|HFM_DATA, signature, 0);
+  return retval;
+}
+
 int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
   int retval;
   uint16_t hfm_ustat;
@@ -1150,7 +1196,7 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
 
   // Check if chip is already erased.
   // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
-  retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1); // blank check
+  retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,0,&hfm_ustat,1); // blank check
   err_check_propagate(retval);
   if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
 	retval = ERROR_TARGET_FAILURE;
@@ -1204,7 +1250,7 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
     // Execute mass erase command.
 	uint16_t hfm_ustat;
 	uint16_t hfm_cmd = HFM_MASS_ERASE;
-    retval = dsp5680xx_f_execute_command(target,hfm_cmd,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,&hfm_ustat,1);
+	retval = dsp5680xx_f_execute_command(target,hfm_cmd,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,0,&hfm_ustat,1);
 	err_check_propagate(retval);
     if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
 	  retval = ERROR_TARGET_FAILURE;
@@ -1332,11 +1378,12 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   int counter_reset = FLUSH_COUNT_FLASH;
   int counter = counter_reset;
   context.flush = 0;
-  for(uint32_t i=1; (i<count/2)&&(i<HFM_SIZE_REAL); i++){
-	if(--counter==0){
-	  context.flush = 1;
-	  counter = counter_reset;
-	}
+  uint32_t i;
+  for(i=1; (i<count/2)&&(i<HFM_SIZE_REAL); i++){
+    if(--counter==0){
+      context.flush = 1;
+      counter = counter_reset;
+    }
     retval = eonce_tx_upper_data(target,buff16[i],&drscan_data);
 	if(retval!=ERROR_OK){
 	  context.flush = 1;
@@ -1345,9 +1392,23 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	context.flush = 0;
   }
   context.flush = 1;
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+  // Verify flash
+  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+  uint16_t signature;
+  uint16_t pc_crc;
+  retval =  dsp5680xx_f_signature(target,address,i,&signature);
+  err_check_propagate(retval);
+  pc_crc = perl_crc(buff16,i);
+  if(pc_crc != signature){
+    retval = ERROR_FAIL;
+    err_check(retval,"Flashed data failed CRC check, flash again!");
+  }
   return retval;
 }
 
+
+
 int dsp5680xx_f_unlock(struct target * target){
   int retval;
   if(target->tap->enabled){

commit d09bef2622fe2a1baeae7a98fad02b25ed104d16
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Thu Jun 2 09:52:33 2011 -0700

    code cleanup

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index f2f2dba..044fb7e 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -28,7 +28,7 @@
 #include "target_type.h"
 #include "dsp5680xx.h"
 
-#define err_check(retval,err_msg) if(retval != ERROR_OK){LOG_ERROR("%s: %s.",__FUNCTION__,err_msg);return retval;}
+#define err_check(retval,err_msg) if(retval != ERROR_OK){LOG_ERROR("%s: %d %s.",__FUNCTION__,__LINE__,err_msg);return retval;}
 #define err_check_propagate(retval) if(retval!=ERROR_OK){return retval;}
 
 // Forward declarations, could try to optimize this.
@@ -158,16 +158,11 @@ int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t
 }
 
 static int dsp5680xx_assert_reset(struct target *target){
-  //TODO verify the sleeps are necessary
-  jtag_add_reset(1,0);
   target->state = TARGET_RESET;
-  jtag_add_sleep(500);
-  usleep(1000);
   return ERROR_OK;
 }
 
 static int dsp5680xx_deassert_reset(struct target *target){
-  jtag_add_reset(0,0);
   target->state = TARGET_RUNNING;
   return ERROR_OK;
 }
@@ -179,7 +174,6 @@ static int dsp5680xx_poll(struct target *target){
   uint16_t read_tmp;
   retval = dsp5680xx_jtag_status(target,&jtag_status);
   err_check_propagate(retval);
-  LOG_DEBUG("JTAG 0x%02X",jtag_status);//TODO remove!!
   if (jtag_status == JTAG_STATUS_DEBUG)
     if (target->state != TARGET_HALTED){
       retval = eonce_enter_debug_mode(target,&read_tmp);
@@ -620,16 +614,15 @@ static int eonce_move_value_to_pc(struct target * target, uint32_t value)
 
 static int eonce_load_TX_RX_to_r0(struct target * target)
 {
-  //TODO add error control
   uint32_t obase_addr;
   int retval = dsp5680xx_obase_addr(target,& obase_addr);
-  eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(obase_addr<<16)));
+  err_check_propagate(retval);
+  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(obase_addr<<16)));
   return retval;
 }
 
 static int eonce_load_TX_RX_high_to_r0(struct target * target)
 {
-  //TODO add error control
   uint32_t obase_addr;
   int retval = dsp5680xx_obase_addr(target,& obase_addr);
   err_check_propagate(retval);
@@ -811,22 +804,19 @@ static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t
   uint16_t * data_w = (uint16_t *)data;
   uint32_t iter;
 
-  int counter_reset = FLUSH_COUNT_WRITE;
-  int counter = counter_reset;
-
+  int counter = FLUSH_COUNT_WRITE;
   for(iter = 0; iter<count/2; iter++){
-	if(--counter==0){
-	  context.flush = 1;
-	  counter = counter_reset;
-	}
-
+    if(--counter==0){
+      context.flush = 1;
+      counter = FLUSH_COUNT_WRITE;
+    }
     retval = dsp5680xx_write_16_single(target,address+iter,data_w[iter], pmem);
     if(retval != ERROR_OK){
       LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
-	  context.flush = 1;
+      context.flush = 1;
       return retval;
     }
-	context.flush = 0;
+    context.flush = 0;
   }
   context.flush = 1;
 
@@ -904,7 +894,7 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
 
 //TODO doxy
 static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer){
-  //TODO Cannot write 32bit to odd address, will write 0x1234567 to as 0x5678 0x0012
+  //TODO Cannot write 32bit to odd address, will write 0x12345678  as 0x5678 0x0012
   if(target->state != TARGET_HALTED){
     LOG_USER("Target must be halted.");
     return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp5680xx.c |  113 ++++++++++++++++++++++++++++++++++-------------
 1 files changed, 82 insertions(+), 31 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jun  5 22:46:48 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  5 Jun 2011 20:46:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-902-g5d9b7cd
Message-ID: <mailman.100.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5d9b7cdd2b2a4759740e35b23aade517b8b3a548 (commit)
      from  c989de0cea1dafa22b0a089f2d68a80190f560e1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5d9b7cdd2b2a4759740e35b23aade517b8b3a548
Author: Stefan Mahr <stefan.mahr at sphairon.com>
Date:   Fri Jun 3 11:10:34 2011 +0200

    mips: add nor flash write from memory block

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 954dbc2..3f1fbab 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -31,6 +31,7 @@
 #include <target/arm.h>
 #include <target/arm7_9_common.h>
 #include <target/armv7m.h>
+#include <target/mips32.h>
 #include <helper/binarybuffer.h>
 #include <target/algorithm.h>
 
@@ -1278,6 +1279,12 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer,
 	uint32_t target_code_size;
 	int retval = ERROR_OK;
 
+	/*  todo:  if ( (!is_armv7m(target_to_armv7m(target)) && (!is_arm(target_to_arm(target)) ) */
+	if (strncmp(target_type_name(target),"mips_m4k",8) == 0)
+	{
+		LOG_ERROR("Your target has no flash block write support yet.");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
 
 	cfi_intel_clear_status_register(bank);
 
@@ -1454,6 +1461,234 @@ cleanup:
 	return retval;
 }
 
+static int cfi_spansion_write_block_mips(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t address, uint32_t count)
+{
+	struct cfi_flash_bank *cfi_info = bank->driver_priv;
+	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
+	struct target *target = bank->target;
+	struct reg_param reg_params[10];
+	struct mips32_algorithm mips32_info;
+	struct working_area *source;
+	uint32_t buffer_size = 32768;
+	uint32_t status;
+	int retval = ERROR_OK;
+
+	/* input parameters - */
+	/*	4  A0 = source address */
+	/*	5  A1 = destination address */
+	/*	6  A2 = number of writes */
+	/*	7  A3 = flash write command */
+	/*	8  T0 = constant to mask DQ7 bits (also used for Dq5 with shift) */
+	/* output parameters - */
+	/*	9  T1 = 0x80 ok 0x00 bad */
+	/* temp registers - */
+	/*	10 T2 = value read from flash to test status */
+	/*	11 T3 = holding register */
+	/* unlock registers - */
+	/*  12 T4 = unlock1_addr */
+	/*  13 T5 = unlock1_cmd */
+	/*  14 T6 = unlock2_addr */
+	/*  15 T7 = unlock2_cmd */
+
+	static const uint32_t mips_word_16_code[] = {
+															/* start:	*/
+		MIPS32_LHU(9,0,4),		/* lhu $t1, ($a0)		; out = &saddr				*/
+		MIPS32_ADDI(4,4,2),		/* addi $a0, $a0, 2		; saddr += 2				*/
+		MIPS32_SH(13,0,12),		/* sh $t5, ($t4)		; *fl_unl_addr1 = fl_unl_cmd1		*/
+		MIPS32_SH(15,0,14),		/* sh $t7, ($t6)		; *fl_unl_addr2 = fl_unl_cmd2		*/
+		MIPS32_SH(7,0,12),		/* sh $a3, ($t4)		; *fl_unl_addr1 = fl_write_cmd		*/
+		MIPS32_SH(9,0,5),		/* sh $t1, ($a1)		; *daddr = out				*/
+		MIPS32_NOP,			/* nop									*/
+															/* busy:	*/
+		MIPS32_LHU(10,0,5),		/* lhu $t2, ($a1)		; temp1 = *daddr			*/
+		MIPS32_XOR(11,9,10),		/* xor $t3, $a0, $t2		; temp2 = out ^ temp1;			*/
+		MIPS32_AND(11,8,11),		/* and $t3, $t0, $t3		; temp2 = temp2 & DQ7mask		*/
+		MIPS32_BNE(11,8, 13),		/* bne $t3, $t0, cont		; if (temp2 != DQ7mask) goto cont	*/
+		MIPS32_NOP,			/* nop									*/
+
+		MIPS32_SRL(10,8,2),		/* srl $t2,$t0,2		; temp1 = DQ7mask >> 2			*/
+		MIPS32_AND(11,10,11),		/* and $t3, $t2, $t3		; temp2 = temp2 & temp1			*/
+		MIPS32_BNE(11,10, NEG16(8)),	/* bne $t3, $t2, busy		; if (temp2 != temp1) goto busy		*/
+		MIPS32_NOP,			/* nop									*/
+
+		MIPS32_LHU(10,0,5),		/* lhu $t2, ($a1)		; temp1 = *daddr			*/
+		MIPS32_XOR(11,9,10),		/* xor $t3, $a0, $t2		; temp2 = out ^ temp1;			*/
+		MIPS32_AND(11,8,11),		/* and $t3, $t0, $t3		; temp2 = temp2 & DQ7mask		*/
+		MIPS32_BNE(11,8, 4),		/* bne $t3, $t0, cont		; if (temp2 != DQ7mask) goto cont	*/
+		MIPS32_NOP,			/* nop									*/
+
+		MIPS32_XOR(9,9,9),		/* xor $t1, $t1, $t1		; out = 0				*/
+		MIPS32_BEQ(9,0, 11),		/* beq $t1, $zero, done		; if (out == 0) goto done		*/
+		MIPS32_NOP,			/* nop									*/
+															/* cont:	*/
+		MIPS32_ADDI(6,6,NEG16(1)),	/* addi, $a2, $a2, -1		; numwrites--				*/
+		MIPS32_BNE(6,0, 5),		/* bne $a2, $zero, cont2	; if (numwrite != 0) goto cont2		*/
+		MIPS32_NOP,			/* nop									*/
+		
+		MIPS32_LUI(9,0),		/* lui $t1, 0								*/
+		MIPS32_ORI(9,9,0x80),		/* ori $t1, $t1, 0x80		; out = 0x80				*/
+
+		MIPS32_B(4),			/* b done			; goto done				*/
+		MIPS32_NOP,			/* nop									*/
+															/* cont2:	*/
+		MIPS32_ADDI(5,5,2),		/* addi $a0, $a0, 2		; daddr += 2				*/
+		MIPS32_B(NEG16(33)),		/* b start			; goto start				*/
+		MIPS32_NOP,			/* nop									*/
+															/* done:	*/
+		/*MIPS32_B(NEG16(1)),	*/	/* b done			; goto done				*/
+		MIPS32_SDBBP,			/* sdbbp			; break();				*/
+		/*MIPS32_B(NEG16(33)),	*/	/* b start			; goto start				*/
+		/* MIPS32_NOP, */
+	};
+
+	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
+	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
+
+	int target_code_size = 0;
+	const uint32_t *target_code_src = NULL;
+
+	switch (bank->bus_width)
+	{
+	case 2 :
+		/* Check for DQ5 support */
+		if( cfi_info->status_poll_mask & (1 << 5) )
+		{
+			target_code_src = mips_word_16_code;
+			target_code_size = sizeof(mips_word_16_code);
+		}
+		else
+		{
+			LOG_ERROR("Need DQ5 support");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+			//target_code_src = mips_word_16_code_dq7only;
+			//target_code_size = sizeof(mips_word_16_code_dq7only);
+		}
+		break;
+	default:
+		LOG_ERROR("Unsupported bank buswidth %d, can't do block memory writes", bank->bus_width);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	/* flash write code */
+	if (!cfi_info->write_algorithm)
+	{
+		uint8_t *target_code;
+
+		/* convert bus-width dependent algorithm code to correct endiannes */
+		target_code = malloc(target_code_size);
+		if (target_code == NULL)
+		{
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
+		cfi_fix_code_endian(target, target_code, target_code_src, target_code_size / 4);
+
+		/* allocate working area */
+		retval = target_alloc_working_area(target, target_code_size,
+				&cfi_info->write_algorithm);
+		if (retval != ERROR_OK)
+		{
+			free(target_code);
+			return retval;
+		}
+
+		/* write algorithm code to working area */
+		if ((retval = target_write_buffer(target, cfi_info->write_algorithm->address,
+				target_code_size, target_code)) != ERROR_OK)
+		{
+			free(target_code);
+			return retval;
+		}
+
+		free(target_code);
+	}
+	/* the following code still assumes target code is fixed 24*4 bytes */
+
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size <= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			if (cfi_info->write_algorithm)
+				target_free_working_area(target, cfi_info->write_algorithm);
+
+			LOG_WARNING("not enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	init_reg_param(&reg_params[0], "a0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "a2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "a3", 32, PARAM_OUT);
+	init_reg_param(&reg_params[4], "t0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[5], "t1", 32, PARAM_IN);
+	init_reg_param(&reg_params[6], "t4", 32, PARAM_OUT);
+	init_reg_param(&reg_params[7], "t5", 32, PARAM_OUT);
+	init_reg_param(&reg_params[8], "t6", 32, PARAM_OUT);
+	init_reg_param(&reg_params[9], "t7", 32, PARAM_OUT);
+
+	while (count > 0)
+	{
+		uint32_t thisrun_count = (count > buffer_size) ? buffer_size : count;
+
+		retval = target_write_buffer(target, source->address, thisrun_count, buffer);
+		if (retval != ERROR_OK)
+		{
+			break;
+		}
+
+		buf_set_u32(reg_params[0].value, 0, 32, source->address);
+		buf_set_u32(reg_params[1].value, 0, 32, address);
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count / bank->bus_width);
+		buf_set_u32(reg_params[3].value, 0, 32, cfi_command_val(bank, 0xA0));
+		buf_set_u32(reg_params[4].value, 0, 32, cfi_command_val(bank, 0x80));
+		buf_set_u32(reg_params[6].value, 0, 32, flash_address(bank, 0, pri_ext->_unlock1));
+		buf_set_u32(reg_params[7].value, 0, 32, 0xaaaaaaaa);
+		buf_set_u32(reg_params[8].value, 0, 32, flash_address(bank, 0, pri_ext->_unlock2));
+		buf_set_u32(reg_params[9].value, 0, 32, 0x55555555);
+
+		retval = target_run_algorithm(target, 0, NULL, 10, reg_params,
+				cfi_info->write_algorithm->address,
+				cfi_info->write_algorithm->address + ((target_code_size) - 4),
+				10000, &mips32_info);
+		if (retval != ERROR_OK)
+		{
+			break;
+		}
+
+		status = buf_get_u32(reg_params[5].value, 0, 32);
+		if (status != 0x80)
+		{
+			LOG_ERROR("flash write block failed status: 0x%" PRIx32 , status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
+			break;
+		}
+
+		buffer += thisrun_count;
+		address += thisrun_count;
+		count -= thisrun_count;
+	}
+
+	target_free_all_working_areas(target);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+	destroy_reg_param(&reg_params[4]);
+	destroy_reg_param(&reg_params[5]);
+	destroy_reg_param(&reg_params[6]);
+	destroy_reg_param(&reg_params[7]);
+	destroy_reg_param(&reg_params[8]);
+	destroy_reg_param(&reg_params[9]);
+
+	return retval;
+}
+
 static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 		uint32_t address, uint32_t count)
 {
@@ -1637,6 +1872,11 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer,
 		0xeafffffe		/* b	8204 <sp_8_done>		*/
 	};
 
+	if (strncmp(target_type_name(target),"mips_m4k",8) == 0)
+	{
+		return cfi_spansion_write_block_mips(bank,buffer,address,count);
+	}
+
 	if (is_armv7m(target_to_armv7m(target))) /* Cortex-M3 target */
 	{
 		armv4_5_info.common_magic = ARMV7M_COMMON_MAGIC;
diff --git a/src/target/mips32.h b/src/target/mips32.h
index 0d544a4..4f0f0ef 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -110,6 +110,8 @@ struct mips32_algorithm
 #define MIPS32_OP_SH	0x29
 #define MIPS32_OP_SW	0x2B
 #define MIPS32_OP_ORI	0x0D
+#define MIPS32_OP_XOR	0x26
+#define MIPS32_OP_SRL	0x03
 
 #define MIPS32_COP0_MF	0x00
 #define MIPS32_COP0_MT	0x04
@@ -135,10 +137,12 @@ struct mips32_algorithm
 #define MIPS32_MFHI(reg)			MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
 #define MIPS32_MTLO(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
 #define MIPS32_MTHI(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
-#define MIPS32_ORI(src, tar, val)	MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
+#define MIPS32_ORI(tar, src, val)	MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
 #define MIPS32_SB(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
 #define MIPS32_SH(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
 #define MIPS32_SW(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
+#define MIPS32_XOR(reg, val1, val2)	MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
+#define MIPS32_SRL(reg, src, off)	MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
 
 /* ejtag specific instructions */
 #define MIPS32_DRET					0x4200001F

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |  240 +++++++++++++++++++++++++++++++++++++++++++++++++++
 src/target/mips32.h |    6 +-
 2 files changed, 245 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun  7 17:54:22 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  7 Jun 2011 15:54:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-903-g1cfb228
Message-ID: <mailman.101.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1cfb2287a67c1f78b76583b2e5ed83ca3560b0d5 (commit)
      from  5d9b7cdd2b2a4759740e35b23aade517b8b3a548 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1cfb2287a67c1f78b76583b2e5ed83ca3560b0d5
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Fri Jun 3 22:10:03 2011 +0200

    Fix "unused variable" warnings (errors) detected with GCC 4.7.0 - leftover changes

diff --git a/src/jtag/drivers/usbprog.c b/src/jtag/drivers/usbprog.c
index 17b0116..3b8a613 100644
--- a/src/jtag/drivers/usbprog.c
+++ b/src/jtag/drivers/usbprog.c
@@ -214,15 +214,9 @@ static void usbprog_end_state(tap_state_t state)
 
 static void usbprog_state_move(void)
 {
-	int i = 0, tms = 0;
 	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	usbprog_jtag_write_tms(usbprog_jtag_handle, (char)tms_scan);
-	for (i = 0; i < tms_count; i++)
-	{
-		tms = (tms_scan >> i) & 1;
-	}
 
 	tap_set_state(tap_get_end_state());
 }
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 0f6fe3f..0a34cfc 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -666,15 +666,12 @@ static int arm_simulate_step_core(struct target *target,
 		}
 		else
 		{
-			enum arm_mode mode = sim->get_mode(sim);
 			int update_cpsr = 0;
 
 			if (instruction.info.load_store_multiple.S)
 			{
 				if (instruction.info.load_store_multiple.register_list & 0x8000)
 					update_cpsr = 1;
-				else
-					mode = ARM_MODE_USR;
 			}
 
 			for (i = 0; i < 16; i++)
@@ -722,7 +719,6 @@ static int arm_simulate_step_core(struct target *target,
 			uint32_t Rn = sim->get_reg_mode(sim,
 					instruction.info.load_store_multiple.Rn);
 			int bits_set = 0;
-			enum arm_mode mode = sim->get_mode(sim);
 
 			for (i = 0; i < 16; i++)
 			{
@@ -730,11 +726,6 @@ static int arm_simulate_step_core(struct target *target,
 					bits_set++;
 			}
 
-			if (instruction.info.load_store_multiple.S)
-			{
-				mode = ARM_MODE_USR;
-			}
-
 			switch (instruction.info.load_store_multiple.addressing_mode)
 			{
 				case 0: /* Increment after */
diff --git a/src/target/etb.c b/src/target/etb.c
index 489b9ed..3cb2254 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -304,31 +304,21 @@ static int etb_write_reg(struct reg *reg, uint32_t value)
 {
 	struct etb_reg *etb_reg = reg->arch_info;
 	uint8_t reg_addr = etb_reg->addr & 0x7f;
-	struct scan_field fields[3];
 
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", (int)(etb_reg->addr), value);
 
 	etb_scann(etb_reg->etb, 0x0);
 	etb_set_instr(etb_reg->etb, 0xc);
 
-	fields[0].num_bits = 32;
 	uint8_t temp0[4];
-	fields[0].out_value = temp0;
 	buf_set_u32(&temp0, 0, 32, value);
-	fields[0].in_value = NULL;
 
-	fields[1].num_bits = 7;
 	uint8_t temp1;
-	fields[1].out_value = &temp1;
 	buf_set_u32(&temp1, 0, 7, reg_addr);
-	fields[1].in_value = NULL;
 
-	fields[2].num_bits = 1;
 	uint8_t temp2;
-	fields[2].out_value = &temp2;
 	buf_set_u32(&temp2, 0, 1, 1);
 
-	fields[2].in_value = NULL;
 	return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/usbprog.c |    6 ------
 src/target/arm_simulator.c |    9 ---------
 src/target/etb.c           |   10 ----------
 3 files changed, 0 insertions(+), 25 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun  7 17:58:58 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  7 Jun 2011 15:58:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-904-g33f9bec
Message-ID: <mailman.102.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  33f9bec9ec5fe370e7a1398c53a7e97409f669ba (commit)
      from  1cfb2287a67c1f78b76583b2e5ed83ca3560b0d5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 33f9bec9ec5fe370e7a1398c53a7e97409f669ba
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 7 17:58:41 2011 +0200

    Silence -O3 warning

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 0a9d72a..22d0b8c 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1672,7 +1672,7 @@ int jtag_get_speed(int *speed)
 
 int jtag_get_speed_readable(int *khz)
 {
-	int jtag_speed_var;
+	int jtag_speed_var = 0;
 	int retval = jtag_get_speed(&jtag_speed_var);
 	if (retval != ERROR_OK)
 		return retval;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun  8 07:21:53 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  8 Jun 2011 05:21:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-906-ge899fca
Message-ID: <mailman.103.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e899fcaca0d207eadea569b9dd9b2d54afafcfd4 (commit)
       via  01c0ffe98f87e35f21b8f392b6432d4190d1eb43 (commit)
      from  33f9bec9ec5fe370e7a1398c53a7e97409f669ba (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e899fcaca0d207eadea569b9dd9b2d54afafcfd4
Author: Laurent Charpentier <laurent_pubs at yahoo.com>
Date:   Mon Jun 6 12:47:52 2011 +0200

    Added configuration file for STM3220G-EVAL board.

diff --git a/tcl/board/stm3220g_eval.cfg b/tcl/board/stm3220g_eval.cfg
new file mode 100644
index 0000000..e836f0e
--- /dev/null
+++ b/tcl/board/stm3220g_eval.cfg
@@ -0,0 +1,11 @@
+# STM3220G-EVAL: This is an STM32F2 eval board with a single STM32F207IGT6
+# (128KB) chip.
+# http://www.st.com/internet/evalboard/product/250374.jsp
+
+# increase working area to 128KB
+set WORKAREASIZE 0x20000
+
+# chip name
+set CHIPNAME STM32F207IGT6
+
+source [find target/stm32f2xxx.cfg]

commit 01c0ffe98f87e35f21b8f392b6432d4190d1eb43
Author: Laurent Charpentier <laurent_pubs at yahoo.com>
Date:   Mon Jun 6 11:51:38 2011 +0200

    Added configuration file for stm32f2xxx.

diff --git a/tcl/target/stm32f2xxx.cfg b/tcl/target/stm32f2xxx.cfg
new file mode 100644
index 0000000..9ebc00f
--- /dev/null
+++ b/tcl/target/stm32f2xxx.cfg
@@ -0,0 +1,56 @@
+# script for stm32f2xxx
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME stm32f2xxx
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+# Work-area is a space in RAM used for flash programming
+# By default use 64kB
+if { [info exists WORKAREASIZE] } {
+   set  _WORKAREASIZE $WORKAREASIZE
+} else {
+   set  _WORKAREASIZE 0x10000
+}
+
+# JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
+jtag_khz 1000
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+#jtag scan chain
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # See STM Document RM0033
+  # Section 32.6.3 - corresponds to Cortex-M3 r2p0
+   set _CPUTAPID 0x4ba00477
+}
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+if { [info exists BSTAPID ] } {
+   set _BSTAPID $BSTAPID
+} else {
+  # See STM Document RM0033
+  # Section 32.6.2
+  # 
+  set _BSTAPID 0x06411041
+}
+jtag newtap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
+
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME stm32f2xxx 0 0 0 0 $_TARGETNAME
+

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/stm3220g_eval.cfg |   11 ++++++++
 tcl/target/stm32f2xxx.cfg   |   56 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 67 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/stm3220g_eval.cfg
 create mode 100644 tcl/target/stm32f2xxx.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jun 12 11:25:39 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 12 Jun 2011 09:25:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-918-g5227ae7
Message-ID: <mailman.104.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5227ae7162732c89fbf2e5eb547c4b1bee03bb58 (commit)
       via  47aa65b3e8499ab17bc0bff05c2eae27b39457a3 (commit)
       via  d343941386bfa274cd64f8f384fc51a695f9f626 (commit)
       via  cbe201fe6bb2f004957ff8174b53c6d4ecd5bae6 (commit)
       via  7b0ead520dcf6969954f42255a01e63b89f96cd6 (commit)
       via  f4b9a2fc8bbc682e957276a0012199a606c919b0 (commit)
       via  ca76e4a4231e665309c7f11a6be741067ef3b09c (commit)
       via  c4bcb0b95a8d3ee9baf7046b6768976d8a4eb134 (commit)
       via  d539fc856f4c09e3a3b683c2b1b5766652ab9d7a (commit)
       via  f42353d82137d0a3f5e2433bae931c82b8407c74 (commit)
       via  f4a3db0d4a353ccc6d701a2645390ef9039e0d02 (commit)
       via  56d3927abf2d2c6c49f3ae6ad6c2f353168d5a60 (commit)
      from  e899fcaca0d207eadea569b9dd9b2d54afafcfd4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5227ae7162732c89fbf2e5eb547c4b1bee03bb58
Author: rlrosa <rodrigo at evolution.com>
Date:   Fri Jun 10 13:26:47 2011 -0700

    added minimodule interface

diff --git a/tcl/interface/minimodule.cfg b/tcl/interface/minimodule.cfg
new file mode 100644
index 0000000..c8f9ba1
--- /dev/null
+++ b/tcl/interface/minimodule.cfg
@@ -0,0 +1,10 @@
+#
+# FTDI MiniModule
+#
+# http://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf
+#
+
+interface ft2232
+ft2232_device_desc "FT2232H MiniModule"
+ft2232_layout "minimodule"
+ft2232_vid_pid 0x0403 0x6010

commit 47aa65b3e8499ab17bc0bff05c2eae27b39457a3
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:24:55 2011 -0700

    doxy more

diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index a574724..3fbe90e 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -226,10 +226,11 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
 /** 
  * Writes to flash memory.
  * Does not check if flash is erased, it's up to the user to erase the flash before running this function.
+ * The flashing algorithm runs from RAM, reading from a register to which this function writes to. The algorithm is open loop, there is no control to verify that the FM read the register before writing the next data. A closed loop approach was much slower, and the current implementation does not fail, and if it did the crc check would detect it, allowing to flash again.
  * 
  * @param target 
  * @param buffer 
- * @param address 
+ * @param address Word addressing.
  * @param count In bytes. 
  * 
  * @return 
@@ -259,7 +260,7 @@ int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased, uint32_t se
 int dsp5680xx_f_erase(struct target * target, int first, int last);
 
 /** 
- * Reads the memory mapped protection register.
+ * Reads the memory mapped protection register. A 1 implies the sector is protected, a 0 implies the sector is not protected.
  * 
  * @param target 
  * @param protected Data read from the protection register.

commit d343941386bfa274cd64f8f384fc51a695f9f626
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:24:27 2011 -0700

    doxy & cleanup

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index b919f56..4ed7206 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -23,6 +23,19 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
+/**
+ * @file   dsp5680xx_flash.c
+ * @author Rodrigo L. Rosa <rodrigorosa.LG at gmail.com>
+ * @date   Thu Jun  9 18:21:58 2011
+ * 
+ * @brief  This file implements the basic functions to run flashing commands
+ * from the TCL interface.
+ * It allows the user to flash the Freescale 5680xx DSP.
+ * 
+ * 
+ */
+
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
@@ -71,6 +84,15 @@ FLASH_BANK_COMMAND_HANDLER(dsp5680xx_flash_bank_command){
   return ERROR_OK;
 }
 
+/** 
+ * A memory mapped register (PROT) holds information regarding sector protection.
+ * Protection refers to undesired core access.
+ * The value in this register is loaded from flash upon reset.
+ * 
+ * @param bank 
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
   int retval = ERROR_OK;
   uint16_t protected = 0;
@@ -93,6 +115,18 @@ static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
   return retval;
 }
 
+/** 
+ * Protection funcionality is not implemented.
+ * The current implementation applies/removes security on the chip.
+ * The chip is effectively secured/unsecured after the first reset following the execution of this function.
+ * 
+ * @param bank 
+ * @param set Apply or remove security on the chip.
+ * @param first This parameter is ignored.
+ * @param last This parameter is ignored.
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first, int last){
   // This applies security to flash module after next reset, it does not actually apply protection (protection refers to undesired access from the core)
   int retval;
@@ -103,24 +137,16 @@ static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first,
   return retval;
 }
 
-/*
-static int dsp5680xx_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
-  LOG_USER("%s not implemented",__FUNCTION__);
-  return ERROR_OK;
-}
-
-static int dsp5680xx_write_single(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
-  LOG_USER("%s not implemented",__FUNCTION__);
-  return ERROR_OK;
-}
-*/
-
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-//  Flash stuff test
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-//-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-
+/** 
+ * The dsp5680xx use word addressing. The "/2" that appear in the following code are a workaround for the fact that OpenOCD uses byte addressing.
+ * 
+ * @param bank 
+ * @param buffer Data to write to flash.
+ * @param offset 
+ * @param count In bytes (2 bytes per address).
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count){
   int retval;
   if((offset + count/2)>bank->size){
@@ -151,19 +177,17 @@ static int dsp5680xx_flash_info(struct flash_bank *bank, char *buf, int buf_size
 	snprintf(buf, buf_size, "\ndsp5680xx flash driver info:\n - Currently only full erase/lock/unlock are implemented. \n - Call with bank==0 and sector 0 to 0.\n - Protect requires arp_init-reset to complete. \n - Before removing protection the master tap must be selected, and arp_init-reset is required to complete unlocking.");
 	return ERROR_OK;
 }
-/*
-static int dsp5680xx_set_write_enable(struct target *target, int enable){
-	LOG_USER("%s not implemented",__FUNCTION__);
-        return ERROR_OK;
-}
-
-
-static int dsp5680xx_check_flash_completion(struct target* target, unsigned int timeout_ms){
-  LOG_USER("%s not implemented",__FUNCTION__);
-  return ERROR_OK;
-}
-*/
 
+/** 
+ * The flash module (FM) on the dsp5680xx supports both individual sector and mass erase of the flash memory.
+ * If this function is called with @first == @last == 0 or if @first is the first sector (#0) and @last is the last sector then the mass erase command is executed (much faster than erasing each sector individually).
+ * 
+ * @param bank 
+ * @param first 
+ * @param last 
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_erase(struct flash_bank * bank, int first, int last){
   int retval;
   retval = dsp5680xx_f_erase(bank->target, (uint32_t) first, (uint32_t) last);
@@ -177,6 +201,14 @@ static int dsp5680xx_flash_erase(struct flash_bank * bank, int first, int last){
   return retval;
 }
 
+/** 
+ * The flash module (FM) on the dsp5680xx support a blank check function.
+ * This function executes the FM's blank check functionality on each and every sector.
+ * 
+ * @param bank 
+ * 
+ * @return 
+ */
 static int dsp5680xx_flash_erase_check(struct flash_bank * bank){
   int retval = ERROR_OK;
   uint8_t erased = 0;
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index f3f25a1..9afda42 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -31,18 +31,6 @@
 #define err_check(retval,err_msg) if(retval != ERROR_OK){LOG_ERROR("%s: %d %s.",__FUNCTION__,__LINE__,err_msg);return retval;}
 #define err_check_propagate(retval) if(retval!=ERROR_OK){return retval;}
 
-// Forward declarations, could try to optimize this.
-static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex, uint8_t * eonce_status);
-static int eonce_load_TX_RX_to_r0(struct target * target);
-static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status);
-static int eonce_read_status_reg(struct target * target, uint16_t * data);
-static int eonce_pc_store(struct target * target);
-static int eonce_move_value_to_pc(struct target * target, uint32_t value);
-static int dsp5680xx_jtag_status(struct target *target, uint8_t * status);
-static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution);
-static int dsp5680xx_halt(struct target *target);
-static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer);
-
 int dsp5680xx_execute_queue(void){
   int retval;
   retval = jtag_execute_queue();
@@ -50,14 +38,6 @@ int dsp5680xx_execute_queue(void){
   return retval;
 }
 
-static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
-  int retval;
-  retval = eonce_instruction_exec(target,0x1F,0,0,1,eonce_status);
-  err_check_propagate(retval);
-  return retval;
-}
-
-
 static int dsp5680xx_drscan(struct target * target, uint8_t * data_to_shift_into_dr, uint8_t * data_shifted_out_of_dr, int len){
 // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 //
@@ -115,116 +95,12 @@ static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_int
   //is the casting necessary?
   jtag_add_plain_ir_scan(ir_len,(uint8_t *)data_to_shift_into_ir,(uint8_t *)data_shifted_out_of_ir, TAP_IDLE);
   if(context.flush){
-	retval = dsp5680xx_execute_queue();
-	err_check_propagate(retval);
+    retval = dsp5680xx_execute_queue();
+    err_check_propagate(retval);
   }
   return retval;
 }
 
-static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uint16_t * data_read)
-{
-  //TODO implement a general version of this which matches what openocd uses.
-  int retval;
-  uint32_t dummy_data_to_shift_into_dr;
-  retval = eonce_instruction_exec(target,reg_addr,1,0,0,NULL);
-  err_check_propagate(retval);
-  retval = dsp5680xx_drscan(target,(uint8_t *)& dummy_data_to_shift_into_dr,(uint8_t *) data_read, 8);
-  err_check_propagate(retval);
-  LOG_DEBUG("Reg. data: 0x%02X.",*data_read);
-  return retval;
-}
-
-static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
-  struct dsp5680xx_common *dsp5680xx = calloc(1, sizeof(struct dsp5680xx_common));
-  target->arch_info = dsp5680xx;
-  return ERROR_OK;
-}
-
-static int dsp5680xx_init_target(struct command_context *cmd_ctx, struct target *target){
-  context.stored_pc = 0;
-  context.flush = 1;
-  LOG_DEBUG("target initiated!");
-  //TODO core tap must be enabled before running these commands, currently this is done in the .cfg tcl script.
-  return ERROR_OK;
-}
-
-static int dsp5680xx_arch_state(struct target *target){
-  LOG_USER("%s not implemented yet.",__FUNCTION__);
-  return ERROR_OK;
-}
-
-int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t * eonce_st){
-  return target->state;
-}
-
-static int dsp5680xx_assert_reset(struct target *target){
-  target->state = TARGET_RESET;
-  return ERROR_OK;
-}
-
-static int dsp5680xx_deassert_reset(struct target *target){
-  target->state = TARGET_RUNNING;
-  return ERROR_OK;
-}
-
-static int dsp5680xx_poll(struct target *target){
-  int retval;
-  uint8_t jtag_status;
-  uint8_t eonce_status;
-  uint16_t read_tmp;
-  retval = dsp5680xx_jtag_status(target,&jtag_status);
-  err_check_propagate(retval);
-  if (jtag_status == JTAG_STATUS_DEBUG)
-    if (target->state != TARGET_HALTED){
-      retval = eonce_enter_debug_mode(target,&read_tmp);
-	  err_check_propagate(retval);
-      eonce_status = (uint8_t) read_tmp;
-      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_DEBUG_M){
-		LOG_WARNING("%s: Failed to put EOnCE in debug mode. Is flash locked?...",__FUNCTION__);
-		return ERROR_TARGET_FAILURE;
-      }else{
-		target->state = TARGET_HALTED;
-		return ERROR_OK;
-      }
-    }
-  if (jtag_status == JTAG_STATUS_NORMAL){
-    if(target->state == TARGET_RESET){
-      retval = dsp5680xx_halt(target);
-	  err_check_propagate(retval);
-      retval = eonce_exit_debug_mode(target,&eonce_status);
-	  err_check_propagate(retval);
-      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
-		LOG_WARNING("%s: JTAG running, but cannot make EOnCE run. Try resetting...",__FUNCTION__);
-		return ERROR_TARGET_FAILURE;
-      }else{
-		target->state = TARGET_RUNNING;
-		return ERROR_OK;
-      }
-    }
-    if(target->state != TARGET_RUNNING){
-      retval = eonce_read_status_reg(target,&read_tmp);
-	  err_check_propagate(retval);
-      eonce_status = (uint8_t) read_tmp;
-      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
-		LOG_WARNING("Inconsistent target status. Restart!");
-		return ERROR_TARGET_FAILURE;
-      }
-    }
-    target->state = TARGET_RUNNING;
-    return ERROR_OK;
-  }
-  if(jtag_status == JTAG_STATUS_DEAD){
-    LOG_ERROR("%s: Cannot communicate with JTAG. Check connection...",__FUNCTION__);
-    target->state = TARGET_UNKNOWN;
-    return ERROR_TARGET_FAILURE;
-  };
-  if (target->state == TARGET_UNKNOWN){
-    LOG_ERROR("%s: Target status invalid - communication failure",__FUNCTION__);
-    return ERROR_TARGET_FAILURE;
-  };
-  return ERROR_OK;
-}
-
 static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
   uint32_t read_from_ir;
   uint32_t instr;
@@ -237,57 +113,6 @@ static int dsp5680xx_jtag_status(struct target *target, uint8_t * status){
   return ERROR_OK;
 }
 
-static int eonce_read_status_reg(struct target * target, uint16_t * data){
-  int retval;
-  retval = dsp5680xx_read_core_reg(target,DSP5680XX_ONCE_OSR,data);
-  err_check_propagate(retval);
-  return retval;
-}
-
-static int dsp5680xx_halt(struct target *target){
-  int retval;
-  uint16_t eonce_status;
-  if(target->state == TARGET_HALTED){
-    LOG_USER("Target already halted.");
-    return ERROR_OK;
-  }
-  retval = eonce_enter_debug_mode(target,&eonce_status);
-  err_check_propagate(retval);
-  retval = eonce_pc_store(target);
-  err_check_propagate(retval);
-  //TODO is it useful to store the pc?
-  return retval;
-}
-
-static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution){
-  if(target->state == TARGET_RUNNING){
-    LOG_USER("Target already running.");
-    return ERROR_OK;
-  }
-  int retval;
-  uint8_t eonce_status;
-  if(!current){
-    retval = eonce_move_value_to_pc(target,address);
-    err_check_propagate(retval);
-  }
-
-  int retry = 20;
-  while(retry-- > 1){
-    retval = eonce_exit_debug_mode(target,&eonce_status );
-	err_check_propagate(retval);
-    if(eonce_status == DSP5680XX_ONCE_OSCR_NORMAL_M)
-      break;
-  }
-  if(retry == 0){
-    retval = ERROR_TARGET_FAILURE;
-	err_check(retval,"Failed to resume...");
-  }else{
-    target->state = TARGET_RUNNING;
-  }
-  LOG_DEBUG("EOnCE status: 0x%02X.",eonce_status);
-  return ERROR_OK;
-}
-
 static int jtag_data_read(struct target * target, uint32_t * data_read, int num_bits){
   uint32_t bogus_instr;
   int retval = dsp5680xx_drscan(target,(uint8_t *) & bogus_instr,(uint8_t *) data_read,num_bits);
@@ -314,37 +139,18 @@ static int jtag_data_write(struct target * target, uint32_t instr,int num_bits,
 #define jtag_data_write24(target,instr,data_read) jtag_data_write(target,instr,24,data_read)
 #define jtag_data_write32(target,instr,data_read) jtag_data_write(target,instr,32,data_read)
 
-static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
-  int retval;
-  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
-  uint32_t ir_out;//not used, just to make jtag happy.
-  // Debug request #1
-  retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-
-  // Enable EOnCE module
-  instr = JTAG_INSTR_ENABLE_ONCE;
-  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
-  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
-  err_check_propagate(retval);
-  // Verify that debug mode is enabled
-  uint16_t data_read_from_dr;
-  retval = eonce_read_status_reg(target,&data_read_from_dr);
-  err_check_propagate(retval);
-  if((data_read_from_dr&0x30) == 0x30){
-    LOG_DEBUG("EOnCE successfully entered debug mode.");
-    target->state = TARGET_HALTED;
-    return ERROR_OK;
-  }else{
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,"Failed to set EOnCE module to debug mode.");
-  }
-  if(eonce_status!=NULL)
-    *eonce_status = data_read_from_dr;
-  return ERROR_OK;
-}
+/** 
+ * Executes DSP instruction.
+ * 
+ * @param target 
+ * @param instr Instruction to execute.
+ * @param rw 
+ * @param go 
+ * @param ex 
+ * @param eonce_status Value read from the EOnCE status register.
+ * 
+ * @return 
+ */
 
 static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex,uint8_t * eonce_status){
   int retval;
@@ -357,15 +163,14 @@ static int eonce_instruction_exec(struct target * target, uint8_t instr, uint8_t
   return retval;
 }
 
-/* Executes DSP instruction */
-/* wrappers for parameter conversion between eonce_execute_instruction and eonce_execute_instructionX */
+///wrappers for parameter conversion between eonce_execute_instruction and eonce_execute_instructionX
+
 #define eonce_execute_instruction_1(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction1(target,opcode1)
 #define eonce_execute_instruction_2(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction2(target,opcode1,opcode2)
 #define eonce_execute_instruction_3(target,opcode1,opcode2,opcode3)	 eonce_execute_instruction3(target,opcode1,opcode2,opcode3)
-/* the macro itself */
 #define eonce_execute_instruction(target,words,opcode1,opcode2,opcode3) eonce_execute_instruction_##words(target,opcode1,opcode2,opcode3)
 
-/* Executes one word DSP instruction */
+/// Executes one word DSP instruction
 static int eonce_execute_instruction1(struct target * target, uint16_t opcode){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,1,0,NULL);
@@ -375,7 +180,7 @@ static int eonce_execute_instruction1(struct target * target, uint16_t opcode){
   return retval;
 }
 
-/* Executes two word DSP instruction */
+/// Executes two word DSP instruction
 static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, uint16_t opcode2){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
@@ -389,7 +194,7 @@ static int eonce_execute_instruction2(struct target * target,uint16_t opcode1, u
   return retval;
 }
 
-/* Executes three word DSP instruction */
+/// Executes three word DSP instruction
 static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,uint16_t opcode2,uint16_t opcode3){
   int retval;
   retval = eonce_instruction_exec(target,0x04,0,0,0,NULL);
@@ -407,15 +212,16 @@ static int eonce_execute_instruction3(struct target * target, uint16_t opcode1,u
   return retval;
 }
 
-/* --------------- Real-time data exchange --------------- */
-/*
-  The EOnCE Transmit (OTX) and Receive (ORX) registers are data memory mapped, each with an upper and lower 16 bit word.
-  Transmit and receive directions are defined from the core???s perspective.
-  The core writes to the Transmit register and reads the Receive register, and the host through JTAG writes to the Receive register and reads the Transmit register.
-  Both registers have a combined data memory mapped OTXRXSR which provides indication when each may be accessed.
-ref: eonce_rev.1.0_0208081.pdf at 36
+/**
+ * --------------- Real-time data exchange ---------------
+ * The EOnCE Transmit (OTX) and Receive (ORX) registers are data memory mapped, each with an upper and lower 16 bit word.
+ * Transmit and receive directions are defined from the core???s perspective.
+ * The core writes to the Transmit register and reads the Receive register, and the host through JTAG writes to the Receive register and reads the Transmit register.
+ * Both registers have a combined data memory mapped OTXRXSR which provides indication when each may be accessed.
+ *ref: eonce_rev.1.0_0208081.pdf at 36
 */
 
+/// writes data into upper ORx register of the target
 static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t * eonce_status_low){
   int retval;
   retval = eonce_instruction_exec(target,DSP5680XX_ONCE_ORX1,0,0,0,NULL);
@@ -425,7 +231,7 @@ static int eonce_tx_upper_data(struct target * target, uint16_t data, uint32_t *
   return retval;
 }
 
-/* writes data into lower ORx register of the target */
+/// writes data into lower ORx register of the target
 #define eonce_tx_lower_data(target,data) eonce_instruction_exec(target,DSP5680XX_ONCE_ORX,0,0,0,NULL);\
 								  jtag_data_write16(target,data)
 
@@ -461,119 +267,124 @@ static int eonce_rx_lower_data(struct target * target,uint16_t * data_read)
   return retval;
 }
 
-/* -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -*/
-/* -- -- -- -- --- -- -- -Core Instructions- -- -- -- --- -- -- -- --- -- -*/
-/* -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -*/
-/* move.l #value,r0 */
+/**
+ * -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- --
+ * -- -- -- -- --- -- -- -Core Instructions- -- -- -- --- -- -- -- --- --
+ * -- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- -- -- -- --- --
+ */
+
+/// move.l #value,r0
 #define eonce_move_long_to_r0(target,value)	eonce_execute_instruction(target,3,0xe418,value&0xffff,value>>16)
 
-/* move.l #value,n */
+/// move.l #value,n
 #define eonce_move_long_to_n(target,value)		eonce_execute_instruction(target,3,0xe41e,value&0xffff,value>>16)
 
-/* move x:(r0),y0 */
+/// move x:(r0),y0
 #define eonce_move_at_r0_to_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
 
-/* move x:(r0),y1 */
+/// move x:(r0),y1
 #define eonce_move_at_r0_to_y1(target)			eonce_execute_instruction(target,1,0xF714,0,0)
 
-/* move.l x:(r0),y */
+/// move.l x:(r0),y
 #define eonce_move_long_at_r0_y(target) eonce_execute_instruction(target,1,0xF734,0,0)
 
-/* move y0,x:(r0) */
+/// move y0,x:(r0)
 #define eonce_move_y0_at_r0(target)			eonce_execute_instruction(target,1,0xd514,0,0)
 
-/* bfclr #value,x:(r0) */
+/// bfclr #value,x:(r0)
 #define eonce_bfclr_at_r0(target,value)		eonce_execute_instruction(target,2,0x8040,value,0)
 
-/* move #value,y0 */
+/// move #value,y0
 #define eonce_move_value_to_y0(target,value)	eonce_execute_instruction(target,2,0x8745,value,0)
 
-/* move.w y0,x:(r0)+ */
+/// move.w y0,x:(r0)+
 #define eonce_move_y0_at_r0_inc(target)		eonce_execute_instruction(target,1,0xd500,0,0)
 
-/* move.w y0,p:(r0)+ */
+/// move.w y0,p:(r0)+
 #define eonce_move_y0_at_pr0_inc(target)		eonce_execute_instruction(target,1,0x8560,0,0)
 
-/* move.w p:(r0)+,y0 */
+/// move.w p:(r0)+,y0
 #define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
 
-/* move.w p:(r0)+,y1 */
+/// move.w p:(r0)+,y1
 #define eonce_move_at_pr0_inc_to_y1(target)	eonce_execute_instruction(target,1,0x8768,0,0)
 
-/* move.l #value,r2 */
+/// move.l #value,r2
 #define eonce_move_long_to_r2(target,value)	eonce_execute_instruction(target,3,0xe41A,value&0xffff,value>>16)
 
-/* move y0,x:(r2) */
+/// move y0,x:(r2)
 #define eonce_move_y0_at_r2(target)             eonce_execute_instruction(target,1,0xd516,0,0)
 
-/* move.w #<value>,x:(r2) */
+/// move.w #<value>,x:(r2)
 #define eonce_move_value_at_r2(target,value)	eonce_execute_instruction(target,2,0x8642,value,0)
 
-/* move.w #<value>,x:(r0) */
+/// move.w #<value>,x:(r0)
 #define eonce_move_value_at_r0(target,value)	eonce_execute_instruction(target,2,0x8640,value,0)
 
-/* move.w #<value>,x:(R2+<disp>) */
+/// move.w #<value>,x:(R2+<disp>)
 #define eonce_move_value_at_r2_disp(target,value,disp)	eonce_execute_instruction(target,3,0x8646,value,disp)
 
-/* move.w x:(r2),Y0 */
+/// move.w x:(r2),Y0
 #define eonce_move_at_r2_to_y0(target)		eonce_execute_instruction(target,1,0xF516,0,0)
 
-/* move.w p:(r2)+,y0 */
+/// move.w p:(r2)+,y0
 #define eonce_move_at_pr2_inc_to_y0(target)	eonce_execute_instruction(target,1,0x856A,0,0)
 
-/* move.l #value,r3 */
+/// move.l #value,r3
 #define eonce_move_long_to_r1(target,value)	eonce_execute_instruction(target,3,0xE419,value&0xffff,value>>16)
 
-/* move.l #value,r3 */
+/// move.l #value,r3
 #define eonce_move_long_to_r3(target,value)	eonce_execute_instruction(target,3,0xE41B,value&0xffff,value>>16)
 
-/* move.w y0,p:(r3)+ */
+/// move.w y0,p:(r3)+
 #define eonce_move_y0_at_pr3_inc(target)		eonce_execute_instruction(target,1,0x8563,0,0)
 
-/* move.w y0,x:(r3) */
+/// move.w y0,x:(r3)
 #define eonce_move_y0_at_r3(target)			eonce_execute_instruction(target,1,0xD503,0,0)
 
-/* move pc,r4 */
+/// move.l #value,r4
+#define eonce_move_long_to_r4(target,value)	eonce_execute_instruction(target,3,0xE41C,value&0xffff,value>>16)
+
+/// move pc,r4
 #define eonce_move_pc_to_r4(target)			eonce_execute_instruction(target,1,0xE716,0,0)
 
-/* move.l r4,y */
+/// move.l r4,y
 #define eonce_move_r4_to_y(target)			eonce_execute_instruction(target,1,0xe764,0,0)
 
-/* move.w p:(r0)+,y0 */
+/// move.w p:(r0)+,y0
 #define eonce_move_at_pr0_inc_to_y0(target)	eonce_execute_instruction(target,1,0x8568,0,0)
 
-/* move.w x:(r0)+,y0 */
+/// move.w x:(r0)+,y0
 #define eonce_move_at_r0_inc_to_y0(target)	eonce_execute_instruction(target,1,0xf500,0,0)
 
-/* move x:(r0),y0 */
+/// move x:(r0),y0
 #define eonce_move_at_r0_y0(target)			eonce_execute_instruction(target,1,0xF514,0,0)
 
-/* nop */
+/// nop
 #define eonce_nop(target)		eonce_execute_instruction(target,1,0xe700,0,0)
 
-/* move.w x:(R2+<disp>),Y0 */
+/// move.w x:(R2+<disp>),Y0
 #define eonce_move_at_r2_disp_to_y0(target,disp) eonce_execute_instruction(target,2,0xF542,disp,0)
 
-/* move.w y1,x:(r2) */
+/// move.w y1,x:(r2)
 #define eonce_move_y1_at_r2(target) eonce_execute_instruction(target,1,0xd716,0,0)
 
-/* move.w y1,x:(r0) */
+/// move.w y1,x:(r0)
 #define eonce_move_y1_at_r0(target) eonce_execute_instruction(target,1,0xd714,0,0)
 
-/* move.bp y0,x:(r0)+ */
+/// move.bp y0,x:(r0)+
 #define eonce_move_byte_y0_at_r0(target) eonce_execute_instruction(target,1,0xd5a0,0,0)
 
-/* move.w y1,p:(r0)+ */
+/// move.w y1,p:(r0)+
 #define eonce_move_y1_at_pr0_inc(target) eonce_execute_instruction(target,1,0x8760,0,0)
 
-/* move.w y1,x:(r0)+ */
+/// move.w y1,x:(r0)+
 #define eonce_move_y1_at_r0_inc(target) eonce_execute_instruction(target,1,0xD700,0,0)
 
-/* move.l #value,y */
+/// move.l #value,y
 #define eonce_move_long_to_y(target,value) eonce_execute_instruction(target,3,0xe417,value&0xffff,value>>16)
 
-static int eonce_move_value_to_pc(struct target * target, uint32_t value)
-{
+static int eonce_move_value_to_pc(struct target * target, uint32_t value){
   if (!(target->state == TARGET_HALTED)){
     LOG_ERROR("Target must be halted to move PC. Target state = %d.",target->state);
     return ERROR_TARGET_NOT_HALTED;
@@ -598,6 +409,88 @@ static int eonce_load_TX_RX_high_to_r0(struct target * target)
   return retval;
 }
 
+static int dsp5680xx_read_core_reg(struct target * target, uint8_t reg_addr, uint16_t * data_read)
+{
+  //TODO implement a general version of this which matches what openocd uses.
+  int retval;
+  uint32_t dummy_data_to_shift_into_dr;
+  retval = eonce_instruction_exec(target,reg_addr,1,0,0,NULL);
+  err_check_propagate(retval);
+  retval = dsp5680xx_drscan(target,(uint8_t *)& dummy_data_to_shift_into_dr,(uint8_t *) data_read, 8);
+  err_check_propagate(retval);
+  LOG_DEBUG("Reg. data: 0x%02X.",*data_read);
+  return retval;
+}
+
+static int eonce_read_status_reg(struct target * target, uint16_t * data){
+  int retval;
+  retval = dsp5680xx_read_core_reg(target,DSP5680XX_ONCE_OSR,data);
+  err_check_propagate(retval);
+  return retval;
+}
+
+/** 
+ * Takes the core out of debug mode.
+ * 
+ * @param target 
+ * @param eonce_status Data read from the EOnCE status register.
+ * 
+ * @return 
+ */
+static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
+  int retval;
+  retval = eonce_instruction_exec(target,0x1F,0,0,1,eonce_status);
+  err_check_propagate(retval);
+  return retval;
+}
+
+/** 
+ * Puts the core into debug mode, enabling the EOnCE module.
+ * 
+ * @param target 
+ * @param eonce_status Data read from the EOnCE status register.
+ * 
+ * @return 
+ */
+static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
+  int retval;
+  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  // Debug request #1
+  retval = dsp5680xx_irscan(target,& instr,& ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+
+  // Enable EOnCE module
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  retval =  dsp5680xx_irscan(target, & instr, & ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  // Verify that debug mode is enabled
+  uint16_t data_read_from_dr;
+  retval = eonce_read_status_reg(target,&data_read_from_dr);
+  err_check_propagate(retval);
+  if((data_read_from_dr&0x30) == 0x30){
+    LOG_DEBUG("EOnCE successfully entered debug mode.");
+    target->state = TARGET_HALTED;
+    return ERROR_OK;
+  }else{
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,"Failed to set EOnCE module to debug mode.");
+  }
+  if(eonce_status!=NULL)
+    *eonce_status = data_read_from_dr;
+  return ERROR_OK;
+}
+
+/** 
+ * Reads the current value of the program counter and stores it.
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 static int eonce_pc_store(struct target * target){
   uint32_t tmp = 0;
   int retval;
@@ -616,6 +509,155 @@ static int eonce_pc_store(struct target * target){
   return ERROR_OK;
 }
 
+static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
+  struct dsp5680xx_common *dsp5680xx = calloc(1, sizeof(struct dsp5680xx_common));
+  target->arch_info = dsp5680xx;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_init_target(struct command_context *cmd_ctx, struct target *target){
+  context.stored_pc = 0;
+  context.flush = 1;
+  LOG_DEBUG("target initiated!");
+  //TODO core tap must be enabled before running these commands, currently this is done in the .cfg tcl script.
+  return ERROR_OK;
+}
+
+static int dsp5680xx_arch_state(struct target *target){
+  LOG_USER("%s not implemented yet.",__FUNCTION__);
+  return ERROR_OK;
+}
+
+int dsp5680xx_target_status(struct target * target, uint8_t * jtag_st, uint16_t * eonce_st){
+  return target->state;
+}
+
+static int dsp5680xx_assert_reset(struct target *target){
+  target->state = TARGET_RESET;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_deassert_reset(struct target *target){
+  target->state = TARGET_RUNNING;
+  return ERROR_OK;
+}
+
+static int dsp5680xx_halt(struct target *target){
+  int retval;
+  uint16_t eonce_status;
+  if(target->state == TARGET_HALTED){
+    LOG_USER("Target already halted.");
+    return ERROR_OK;
+  }
+  retval = eonce_enter_debug_mode(target,&eonce_status);
+  err_check_propagate(retval);
+  retval = eonce_pc_store(target);
+  err_check_propagate(retval);
+  //TODO is it useful to store the pc?
+  return retval;
+}
+
+static int dsp5680xx_poll(struct target *target){
+  int retval;
+  uint8_t jtag_status;
+  uint8_t eonce_status;
+  uint16_t read_tmp;
+  retval = dsp5680xx_jtag_status(target,&jtag_status);
+  err_check_propagate(retval);
+  if (jtag_status == JTAG_STATUS_DEBUG)
+    if (target->state != TARGET_HALTED){
+      retval = eonce_enter_debug_mode(target,&read_tmp);
+	  err_check_propagate(retval);
+      eonce_status = (uint8_t) read_tmp;
+      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_DEBUG_M){
+		LOG_WARNING("%s: Failed to put EOnCE in debug mode. Is flash locked?...",__FUNCTION__);
+		return ERROR_TARGET_FAILURE;
+      }else{
+		target->state = TARGET_HALTED;
+		return ERROR_OK;
+      }
+    }
+  if (jtag_status == JTAG_STATUS_NORMAL){
+    if(target->state == TARGET_RESET){
+      retval = dsp5680xx_halt(target);
+	  err_check_propagate(retval);
+      retval = eonce_exit_debug_mode(target,&eonce_status);
+	  err_check_propagate(retval);
+      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
+		LOG_WARNING("%s: JTAG running, but cannot make EOnCE run. Try resetting...",__FUNCTION__);
+		return ERROR_TARGET_FAILURE;
+      }else{
+		target->state = TARGET_RUNNING;
+		return ERROR_OK;
+      }
+    }
+    if(target->state != TARGET_RUNNING){
+      retval = eonce_read_status_reg(target,&read_tmp);
+	  err_check_propagate(retval);
+      eonce_status = (uint8_t) read_tmp;
+      if((eonce_status&EONCE_STAT_MASK) != DSP5680XX_ONCE_OSCR_NORMAL_M){
+		LOG_WARNING("Inconsistent target status. Restart!");
+		return ERROR_TARGET_FAILURE;
+      }
+    }
+    target->state = TARGET_RUNNING;
+    return ERROR_OK;
+  }
+  if(jtag_status == JTAG_STATUS_DEAD){
+    LOG_ERROR("%s: Cannot communicate with JTAG. Check connection...",__FUNCTION__);
+    target->state = TARGET_UNKNOWN;
+    return ERROR_TARGET_FAILURE;
+  };
+  if (target->state == TARGET_UNKNOWN){
+    LOG_ERROR("%s: Target status invalid - communication failure",__FUNCTION__);
+    return ERROR_TARGET_FAILURE;
+  };
+  return ERROR_OK;
+}
+
+static int dsp5680xx_resume(struct target *target, int current, uint32_t address,int handle_breakpoints, int debug_execution){
+  if(target->state == TARGET_RUNNING){
+    LOG_USER("Target already running.");
+    return ERROR_OK;
+  }
+  int retval;
+  uint8_t eonce_status;
+  if(!current){
+    retval = eonce_move_value_to_pc(target,address);
+    err_check_propagate(retval);
+  }
+
+  int retry = 20;
+  while(retry-- > 1){
+    retval = eonce_exit_debug_mode(target,&eonce_status );
+	err_check_propagate(retval);
+    if(eonce_status == DSP5680XX_ONCE_OSCR_NORMAL_M)
+      break;
+  }
+  if(retry == 0){
+    retval = ERROR_TARGET_FAILURE;
+	err_check(retval,"Failed to resume...");
+  }else{
+    target->state = TARGET_RUNNING;
+  }
+  LOG_DEBUG("EOnCE status: 0x%02X.",eonce_status);
+  return ERROR_OK;
+}
+
+
+
+
+
+
+/** 
+ * The value of @address determines if it corresponds to P: (program) or X: (data) memory. If the address is over 0x200000 then it is considered X: memory, and @pmem = 0.
+ * The special case of 0xFFXXXX is not modified, since it allows to read out the memory mapped EOnCE registers.
+ * 
+ * @param address 
+ * @param pmem 
+ * 
+ * @return 
+ */
 static int dsp5680xx_convert_address(uint32_t * address, int * pmem){
   // Distinguish data memory (x:) from program memory (p:) by the address.
   // Addresses over S_FILE_DATA_OFFSET are considered (x:) memory.
@@ -679,7 +721,7 @@ static int dsp5680xx_read_32_single(struct target * target, uint32_t address, ui
   uint16_t tmp;
   retval = eonce_rx_upper_data(target,&tmp);
   err_check_propagate(retval);
-  *data_read = ((tmp<<16) | (*data_read));//This enables opencd crc to succeed, even though it's very slow.
+  *data_read = ((tmp<<16) | (*data_read));//This enables OpenOCD crc to succeed (when it should)
   return retval;
 }
 
@@ -734,7 +776,6 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   return retval;
 }
 
-//TODO doxy
 static int dsp5680xx_write_16_single(struct target *target, uint32_t address, uint16_t data, uint8_t w_pmem){
   int retval = 0;
   retval = eonce_move_long_to_r0(target,address);
@@ -751,7 +792,6 @@ static int dsp5680xx_write_16_single(struct target *target, uint32_t address, ui
   return retval;
 }
 
-//TODO doxy
 static int dsp5680xx_write_32_single(struct target *target, uint32_t address, uint32_t data, int w_pmem){
   int retval = 0;
   retval = eonce_move_long_to_r0(target,address);
@@ -864,7 +904,18 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
   return retval;
 }
 
-//TODO doxy
+/** 
+ * Writes @buffer to memory.
+ * The parameter @address determines whether @buffer should be written to P: (program) memory or X: (data) memory.
+ * 
+ * @param target 
+ * @param address
+ * @param size Bytes (1), Half words (2), Words (4).
+ * @param count In bytes.
+ * @param buffer 
+ * 
+ * @return 
+ */
 static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer){
   //TODO Cannot write 32bit to odd address, will write 0x12345678  as 0x5678 0x0012
   if(target->state != TARGET_HALTED){
@@ -888,7 +939,7 @@ static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t siz
     break;
   default:
 	retval = ERROR_TARGET_DATA_ABORT;
-	err_check(retval,"Invalid data size.")
+	err_check(retval,"Invalid data size.");
 	break;
   }
   return retval;
@@ -907,21 +958,49 @@ static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint
   return dsp5680xx_write(target, address, 1, size, buffer);
 }
 
+/** 
+ * This function is called by verify_image, it is used to read data from memory.
+ * 
+ * @param target 
+ * @param address Word addressing.
+ * @param size In bytes.
+ * @param buffer 
+ * 
+ * @return 
+ */
 static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){
   if(target->state != TARGET_HALTED){
     LOG_USER("Target must be halted.");
     return ERROR_OK;
   }
-  // read_buffer is called when the verify_image command is executed.
   // The "/2" solves the byte/word addressing issue.
   return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
+/** 
+ * This function is not implemented.
+ * It returns an error in order to get OpenOCD to do read out the data and calculate the CRC, or try a binary comparison.
+ * 
+ * @param target 
+ * @param address Start address of the image.
+ * @param size In bytes.
+ * @param checksum 
+ * 
+ * @return 
+ */
 static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
-  return ERROR_FAIL;// This will make OpenOCD do the read out the data and verify it.
+  return ERROR_FAIL;
 }
 
-// Data signature algorithm used by the core FM (flash module)
+/** 
+ * Calculates a signature over @word_count words in the data from @buff16. The algorithm used is the same the FM uses, so the @return may be used to compare with the one generated by the FM module, and check if flashing was successful.
+ * This algorithm is based on the perl script available from the Freescale website at FAQ 25630.
+ * 
+ * @param buff16 
+ * @param word_count 
+ * 
+ * @return 
+ */
 static int perl_crc(uint16_t * buff16,uint32_t  word_count){
   uint16_t checksum = 0xffff;
   uint16_t data,fbmisr;
@@ -940,6 +1019,13 @@ static int perl_crc(uint16_t * buff16,uint32_t  word_count){
   return checksum;
 }
 
+/** 
+ * Resets the SIM. (System Integration Module).
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_SIM_reset(struct target * target){
   int retval = ERROR_OK;
   uint16_t sim_cmd = SIM_CMD_RESET;
@@ -952,7 +1038,13 @@ int dsp5680xx_f_SIM_reset(struct target * target){
   return retval;
 }
 
-//TODO doxy
+/** 
+ * Halts the core and resets the SIM. (System Integration Module).
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 static int dsp5680xx_soft_reset_halt(struct target *target){
   //TODO is this what this function is expected to do...?
   int retval;
@@ -979,6 +1071,18 @@ int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
   return retval;
 }
 
+/** 
+ * Executes a command on the FM module. Some commands use the parameters @address and @data, others ignore them.
+ * 
+ * @param target 
+ * @param command Command to execute.
+ * @param address Command parameter.
+ * @param data Command parameter.
+ * @param hfm_ustat FM status register.
+ * @param pmem Address is P: (program) memory (@pmem==1) or X: (data) memory (@pmem==0)
+ * 
+ * @return 
+ */
 static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint32_t data, uint16_t * hfm_ustat, int pmem){
   int retval;
   retval = eonce_load_TX_RX_high_to_r0(target);
@@ -1055,6 +1159,13 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   return ERROR_OK;
 }
 
+/** 
+ * Prior to the execution of any Flash module command, the Flash module Clock Divider (CLKDIV) register must be initialized. The values of this register determine the speed of the internal Flash Clock (FCLK). FCLK must be in the range of 150kHz ??? FCLK ??? 200kHz for proper operation of the Flash module. (Running FCLK too slowly wears out the module, while running it too fast under programs Flash leading to bit errors.) 
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 static int eonce_set_hfmdiv(struct target * target){
   uint16_t i;
   int retval;
@@ -1093,6 +1204,16 @@ static int eonce_set_hfmdiv(struct target * target){
   return ERROR_OK;
 }
 
+/** 
+ * Executes the FM calculate signature command. The FM will calculate over the data from @address to @address + @words -1. The result is written to a register, then read out by this function and returned in @signature. The value @signature may be compared to the the one returned by perl_crc to verify the flash was written correctly.
+ * 
+ * @param target 
+ * @param address Start of flash array where the signature should be calculated.
+ * @param words Number of words over which the signature should be calculated.
+ * @param signature Value calculated by the FM.
+ * 
+ * @return 
+ */
 static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint32_t words, uint16_t * signature){
   int retval;
   uint16_t hfm_ustat;
@@ -1121,6 +1242,15 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
   return retval;
 }
 
+/** 
+ * Executes the FM page erase command.
+ * 
+ * @param target 
+ * @param sector Page to erase.
+ * @param hfm_ustat FM module status register.
+ * 
+ * @return 
+ */
 static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_PAGE_ERASE,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,hfm_ustat,1);
@@ -1128,6 +1258,14 @@ static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat
   return retval;
 }
 
+/** 
+ * Executes the FM mass erase command. Erases the flash array completely.
+ * 
+ * @param target 
+ * @param hfm_ustat FM module status register.
+ * 
+ * @return 
+ */
 static int mass_erase(struct target * target, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_MASS_ERASE,0,0,hfm_ustat,1);
@@ -1161,49 +1299,51 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
   }else{
     for(int i = first;i<=last;i++){
       retval = erase_sector(target,i,&hfm_ustat);
-	err_check_propagate(retval);
-  }
+      err_check_propagate(retval);
+    }
   }
   return ERROR_OK;
 }
 
-// Algorithm for programming normal p: flash
-// Follow state machine from "56F801x Peripheral Reference Manual"@163.
-// Registers to set up before calling:
-//  r0: TX/RX high address.
-//  r2: FM module base address.
-//  r3: Destination address in flash.
-//
-//		hfm_wait:                                           // wait for command to finish
-//			brclr	#0x40,x:(r2+0x13),hfm_wait
-//		rx_check:					    // wait for input buffer full
-//			brclr	#0x01,x:(r0-2),rx_check
-//			move.w	x:(r0),y0		   	    // read from Rx buffer
-//			move.w	y0,p:(r3)+
-//			move.w	#0x20,x:(r2+0x14)		    // write PGM command
-//			move.w	#0x80,x:(r2+0x13)		    // start the command
-//                      brclr       #0x20,X:(R2+0x13),accerr_check  // protection violation check
-//                      bfset       #0x20,X:(R2+0x13)               // clear pviol
-//                      bra         hfm_wait
-//              accerr_check:
-//                      brclr       #0x10,X:(R2+0x13),hfm_wait      // access error check
-//                      bfset       #0x10,X:(R2+0x13)               // clear accerr
-//			bra	    hfm_wait		            // loop
-//0x00000073  0x8A460013407D         brclr       #0x40,X:(R2+0x13),*+0
-//0x00000076  0xE700                 nop
-//0x00000077  0xE700                 nop
-//0x00000078  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
-//0x0000007B  0xE700                 nop
-//0x0000007C  0xF514                 move.w      X:(R0),Y0
-//0x0000007D  0x8563                 move.w      Y0,P:(R3)+
-//0x0000007E  0x864600200014         move.w      #0x20,X:(R2+0x14)
-//0x00000081  0x864600800013         move.w      #0x80,X:(R2+0x13)
-//0x00000084  0x8A4600132004         brclr       #0x20,X:(R2+0x13),*+7
-//0x00000087  0x824600130020         bfset       #0x20,X:(R2+0x13)
-//0x0000008A  0xA968                 bra         *-23
-//0x0000008B  0x8A4600131065         brclr       #0x10,X:(R2+0x13),*-24
-//0x0000008E  0x824600130010         bfset       #0x10,X:(R2+0x13)
-//0x00000091  0xA961                 bra         *-30
+/**
+ * Algorithm for programming normal p: flash
+ * Follow state machine from "56F801x Peripheral Reference Manual"@163.
+ * Registers to set up before calling:
+*  r0: TX/RX high address.
+*  r2: FM module base address.
+*  r3: Destination address in flash.
+*
+*		hfm_wait:                                           // wait for command to finish
+*			brclr	#0x40,x:(r2+0x13),hfm_wait
+*		rx_check:					    // wait for input buffer full
+*			brclr	#0x01,x:(r0-2),rx_check
+*			move.w	x:(r0),y0		   	    // read from Rx buffer
+*			move.w	y0,p:(r3)+
+*			move.w	#0x20,x:(r2+0x14)		    // write PGM command
+*			move.w	#0x80,x:(r2+0x13)		    // start the command
+*                      brclr       #0x20,X:(R2+0x13),accerr_check  // protection violation check
+*                      bfset       #0x20,X:(R2+0x13)               // clear pviol
+*                      bra         hfm_wait
+*              accerr_check:
+*                      brclr       #0x10,X:(R2+0x13),hfm_wait      // access error check
+*                      bfset       #0x10,X:(R2+0x13)               // clear accerr
+*			bra	    hfm_wait		            // loop
+*0x00000073  0x8A460013407D         brclr       #0x40,X:(R2+0x13),*+0
+*0x00000076  0xE700                 nop
+*0x00000077  0xE700                 nop
+*0x00000078  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
+*0x0000007B  0xE700                 nop
+*0x0000007C  0xF514                 move.w      X:(R0),Y0
+*0x0000007D  0x8563                 move.w      Y0,P:(R3)+
+*0x0000007E  0x864600200014         move.w      #0x20,X:(R2+0x14)
+*0x00000081  0x864600800013         move.w      #0x80,X:(R2+0x13)
+*0x00000084  0x8A4600132004         brclr       #0x20,X:(R2+0x13),*+7
+*0x00000087  0x824600130020         bfset       #0x20,X:(R2+0x13)
+*0x0000008A  0xA968                 bra         *-23
+*0x0000008B  0x8A4600131065         brclr       #0x10,X:(R2+0x13),*-24
+*0x0000008E  0x824600130010         bfset       #0x10,X:(R2+0x13)
+*0x00000091  0xA961                 bra         *-30
+*/
 const uint16_t pgm_write_pflash[] = {0x8A46,0x0013,0x407D,0xE700,0xE700,0x8A44,0xFFFE,0x017B,0xE700,0xF514,0x8563,0x8646,0x0020,0x0014,0x8646,0x0080,0x0013,0x8A46,0x0013,0x2004,0x8246,0x0013,0x0020,0xA968,0x8A46,0x0013,0x1065,0x8246,0x0013,0x0010,0xA961};
 const uint32_t pgm_write_pflash_length = 31;
 
@@ -1211,8 +1351,8 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   int retval = ERROR_OK;
   uint16_t* buff16 = (uint16_t *) buffer;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
-    retval = dsp5680xx_halt(target);
-	err_check_propagate(retval);
+    retval = eonce_enter_debug_mode(target,NULL);
+    err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Download the pgm that flashes.
@@ -1302,8 +1442,6 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   return retval;
 }
 
-
-
 int dsp5680xx_f_unlock(struct target * target){
   int retval;
   if(target->tap->enabled){
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 50ab990..a574724 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -25,6 +25,19 @@
 
 #include <jtag/jtag.h>
 
+/**
+ * @file   dsp5680xx.h
+ * @author Rodrigo Rosa <rodrigorosa.LG at gmail.com>
+ * @date   Thu Jun  9 18:54:38 2011
+ * 
+ * @brief  Basic support for the 5680xx DSP from Freescale.
+ * The chip has two taps in the JTAG chain, the Master tap and the Core tap.
+ * In this code the Master tap is only used to unlock the flash memory by executing a JTAG instruction.
+ * 
+ * 
+ */
+
+
 #define S_FILE_DATA_OFFSET 0x200000
 
 //----------------------------------------------------------------
@@ -160,6 +173,11 @@
 #define HFM_USTAT_MASK_BLANK 0x4
 #define HFM_USTAT_MASK_PVIOL_ACCER 0x30
 
+/**
+ * The value used on for the FM clock is important to prevent flashing errors and to prevent deterioration of the FM.
+ * This value was calculated using a spreadsheet tool available on the Freescale website under FAQ 25464.
+ * 
+ */
 #define HFM_CLK_DEFAULT	0x40
 #define HFM_FLASH_BASE_ADDR 0x0
 #define HFM_SIZE_BYTES 0x4000 // bytes
@@ -168,10 +186,12 @@
 #define HFM_SECTOR_COUNT 0x20
 // A 16K block in pages of 256 words.
 
+/**
+ * Writing HFM_LOCK_FLASH to HFM_LOCK_ADDR_L and HFM_LOCK_ADDR_H will enable security on flash after the next reset.
+ */
 #define HFM_LOCK_FLASH 0xE70A
 #define HFM_LOCK_ADDR_L 0x1FF7
 #define HFM_LOCK_ADDR_H 0x1FF8
-// Writing HFM_LOCK_FLASH to HFM_LOCK_ADDR_L and HFM_LOCK_ADDR_H will enable security on flash after the next reset.
 //----------------------------------------------------------------
 
 //----------------------------------------------------------------
@@ -203,12 +223,69 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
   return target->arch_info;
 }
 
+/** 
+ * Writes to flash memory.
+ * Does not check if flash is erased, it's up to the user to erase the flash before running this function.
+ * 
+ * @param target 
+ * @param buffer 
+ * @param address 
+ * @param count In bytes. 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
 
+/** 
+ * The FM has the funcionality of checking if the flash array is erased. This function executes it. It does not support individual sector analysis.
+ * 
+ * @param target 
+ * @param erased 
+ * @param sector This parameter is ignored because the FM does not support checking if individual sectors are erased.
+ * 
+ * @return 
+ */
 int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased, uint32_t sector);
+
+/** 
+ * Erases either a sector or the complete flash array. If either the range first-last covers the complete array or if @first == 0 and @last == 0 then a mass erase command is executed on the FM. If not, then individual sectors are erased.
+ * 
+ * @param target 
+ * @param first 
+ * @param last 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_erase(struct target * target, int first, int last);
+
+/** 
+ * Reads the memory mapped protection register.
+ * 
+ * @param target 
+ * @param protected Data read from the protection register.
+ * 
+ * @return 
+ */
 int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected);
+
+/** 
+ * Writes the flash security words with a specific value. The chip's security will be enabled after the first reset following the execution of this function.
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_lock(struct target * target);
+
+/** 
+ * Executes a mass erase command. The must be done from the Master tap.
+ * It is up to the user to select the master tap (jtag tapenable dsp5680xx.chp) before running this function.
+ * The flash array will be unsecured (and erased) after the first reset following the execution of this function.
+ * 
+ * @param target 
+ * 
+ * @return 
+ */
 int dsp5680xx_f_unlock(struct target * target);
 
 #endif // dsp5680xx.h

commit cbe201fe6bb2f004957ff8174b53c6d4ecd5bae6
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:23:52 2011 -0700

    fix protection behavior

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 9fa7b06..b919f56 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -96,18 +96,10 @@ static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
 static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first, int last){
   // This applies security to flash module after next reset, it does not actually apply protection (protection refers to undesired access from the core)
   int retval;
-  if(set){
+  if(set)
     retval = dsp5680xx_f_lock(bank->target);
-    if(retval == ERROR_OK){
-      for(int i = first;i<last;i++)
-	bank->sectors[i].is_protected = 1;
-    }
-  }else{
+  else
     retval = dsp5680xx_f_unlock(bank->target);
-    if(retval == ERROR_OK)
-      for(int i = first;i<last;i++)
-	bank->sectors[i].is_protected = 0;
-  }
   return retval;
 }
 
@@ -140,10 +132,13 @@ static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint3
     return ERROR_FAIL;
   }
   retval = dsp5680xx_f_wr(bank->target,  buffer, bank->base + offset/2,  count);
-  if(retval == ERROR_OK)
-    bank->sectors[0].is_erased = 0;
-  else
-    bank->sectors[0].is_erased = -1;
+  uint32_t addr_word;
+  for(addr_word = bank->base + offset/2;addr_word<count/2;addr_word+=(HFM_SECTOR_SIZE/2)){
+    if(retval == ERROR_OK)
+      bank->sectors[addr_word/(HFM_SECTOR_SIZE/2)].is_erased = 0;
+    else
+      bank->sectors[addr_word/(HFM_SECTOR_SIZE/2)].is_erased = -1;
+  }
   return retval;
 }
 

commit 7b0ead520dcf6969954f42255a01e63b89f96cd6
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:23:34 2011 -0700

    cleanup trailing whitespaces

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 4e7a0b6..9fa7b06 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -3,7 +3,7 @@
  *   rodrigorosa.LG at gmail.com                                              *
  *                                                                         *
  *   Based on a file written by:                                           *
- *   Kevin McGuire                                                         * 
+ *   Kevin McGuire                                                         *
  *   Marcel Wijlaars                                                       *
  *   Michael Ashton                                                        *
  *                                                                         *
@@ -102,7 +102,7 @@ static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first,
       for(int i = first;i<last;i++)
 	bank->sectors[i].is_protected = 1;
     }
-  }else{    
+  }else{
     retval = dsp5680xx_f_unlock(bank->target);
     if(retval == ERROR_OK)
       for(int i = first;i<last;i++)
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 7c28327..bde1700 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2935,7 +2935,7 @@ static int minimodule_init(void)
 		LOG_ERROR("couldn't initialize FT2232 with 'minimodule' layout");
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 
 	nSRST    = 0x20;
 
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 3db31d3..f3f25a1 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -726,11 +726,11 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
 	err_check_propagate(retval);
     context.flush = 0;
   }
-  
+
   context.flush = 1;
   retval = dsp5680xx_execute_queue();
   err_check_propagate(retval);
-  
+
   return retval;
 }
 
@@ -913,7 +913,7 @@ static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint3
     return ERROR_OK;
   }
   // read_buffer is called when the verify_image command is executed.
-  // The "/2" solves the byte/word addressing issue. 
+  // The "/2" solves the byte/word addressing issue.
   return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
@@ -1120,14 +1120,14 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
     *erased = (uint8_t)(hfm_ustat&HFM_USTAT_MASK_BLANK);
   return retval;
 }
-  
+
 static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_PAGE_ERASE,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,hfm_ustat,1);
   err_check_propagate(retval);
   return retval;
 }
- 
+
 static int mass_erase(struct target * target, uint16_t * hfm_ustat){
   int retval;
   retval = dsp5680xx_f_execute_command(target,HFM_MASS_ERASE,0,0,hfm_ustat,1);
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index da494c9..50ab990 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -114,13 +114,13 @@
 #define DSP5680XX_ONCE_OPDBR    0x08 /* EOnCE Program Data Bus Register (OPDBR) */
 #define DSP5680XX_ONCE_OTX1     0x09 /* EOnCE Upper Transmit register (OTX1) */
 #define DSP5680XX_ONCE_OPABFR   0x0A /* OnCE Program Address Register???Fetch cycle */
-#define DSP5680XX_ONCE_ORX      0x0B /* EOnCE Receive register (ORX) */ 
+#define DSP5680XX_ONCE_ORX      0x0B /* EOnCE Receive register (ORX) */
 #define DSP5680XX_ONCE_OCNTR_C  0x0C /* Clear OCNTR */
 #define DSP5680XX_ONCE_ORX1     0x0D /* EOnCE Upper Receive register (ORX1) */
 #define DSP5680XX_ONCE_OTBCR    0x0E /* EOnCE Trace Buffer Control Reg (OTBCR) */
 #define DSP5680XX_ONCE_OPABER   0x10 /* OnCE Program Address Register???Execute cycle */
 #define DSP5680XX_ONCE_OPFIFO   0x11 /* OnCE Program address FIFO */
-#define DSP5680XX_ONCE_OBAR1    0x12 /* EOnCE Breakpoint 1 Unit 0 Address Reg.(OBAR1) */ 
+#define DSP5680XX_ONCE_OBAR1    0x12 /* EOnCE Breakpoint 1 Unit 0 Address Reg.(OBAR1) */
 #define DSP5680XX_ONCE_OPABDR   0x13 /* OnCE Program Address Register???Decode cycle (OPABDR) */
 //----------------------------------------------------------------
 
@@ -179,7 +179,7 @@
 //----------------------------------------------------------------
 #define MC568013_EONCE_OBASE_ADDR 0xFF
 // The following are relative to EONCE_OBASE_ADDR (EONCE_OBASE_ADDR<<16 + ...)
-#define MC568013_EONCE_TX_RX_ADDR    0xFFFE // 
+#define MC568013_EONCE_TX_RX_ADDR    0xFFFE //
 #define MC568013_EONCE_TX1_RX1_HIGH_ADDR  0xFFFF // Relative to EONCE_OBASE_ADDR
 #define MC568013_EONCE_OCR 0xFFA0 // Relative to EONCE_OBASE_ADDR
 //----------------------------------------------------------------

commit f4b9a2fc8bbc682e957276a0012199a606c919b0
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:23:17 2011 -0700

    flash speed improved

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 1f26b69..3db31d3 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -1230,6 +1230,9 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Setup registers needed by pgm_write_pflash
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+
+  context.flush = 0;
+
   retval = eonce_move_long_to_r3(target,address);  // Destination address to r3
   err_check_propagate(retval);
   eonce_load_TX_RX_high_to_r0(target);  // TX/RX reg address to r0
@@ -1256,6 +1259,11 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	retval = ERROR_FAIL;
 	err_check(retval,"Cannot handle odd number of words.");
   }
+
+  context.flush = 1;
+  retval = dsp5680xx_execute_queue();
+  err_check_propagate(retval);
+
   uint32_t drscan_data;
   retval = eonce_tx_upper_data(target,buff16[0],&drscan_data);
   err_check_propagate(retval);

commit ca76e4a4231e665309c7f11a6be741067ef3b09c
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:21:49 2011 -0700

    removed unnecessary actions/controls

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index d1c1d19..1f26b69 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -246,7 +246,6 @@ static int eonce_read_status_reg(struct target * target, uint16_t * data){
 
 static int dsp5680xx_halt(struct target *target){
   int retval;
-  uint8_t jtag_status;
   uint16_t eonce_status;
   if(target->state == TARGET_HALTED){
     LOG_USER("Target already halted.");
@@ -254,8 +253,6 @@ static int dsp5680xx_halt(struct target *target){
   }
   retval = eonce_enter_debug_mode(target,&eonce_status);
   err_check_propagate(retval);
-  retval = dsp5680xx_jtag_status(target,&jtag_status);
-  err_check_propagate(retval);
   retval = eonce_pc_store(target);
   err_check_propagate(retval);
   //TODO is it useful to store the pc?
@@ -268,17 +265,7 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
     return ERROR_OK;
   }
   int retval;
-  uint8_t jtag_status;
-  uint16_t eonce_status;
-
-  // Verify that EOnCE is enabled (enable it if necessary)
-  uint16_t data_read_from_dr = 0;
-  retval = eonce_read_status_reg(target,&data_read_from_dr);
-  err_check_propagate(retval);
-  if((data_read_from_dr&DSP5680XX_ONCE_OSCR_DEBUG_M) != DSP5680XX_ONCE_OSCR_DEBUG_M){
-    retval = eonce_enter_debug_mode(target,NULL);
-	err_check_propagate(retval);
-  }
+  uint8_t eonce_status;
   if(!current){
     retval = eonce_move_value_to_pc(target,address);
     err_check_propagate(retval);
@@ -286,21 +273,17 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
 
   int retry = 20;
   while(retry-- > 1){
-    retval = eonce_exit_debug_mode(target,(uint8_t *)&eonce_status );
-	err_check_propagate(retval);
-    retval = dsp5680xx_jtag_status(target,&jtag_status);
+    retval = eonce_exit_debug_mode(target,&eonce_status );
 	err_check_propagate(retval);
-    if((jtag_status & 0xff) == JTAG_STATUS_NORMAL){
+    if(eonce_status == DSP5680XX_ONCE_OSCR_NORMAL_M)
       break;
-    }
   }
   if(retry == 0){
     retval = ERROR_TARGET_FAILURE;
 	err_check(retval,"Failed to resume...");
   }else{
     target->state = TARGET_RUNNING;
-  };
-  LOG_DEBUG("JTAG status: 0x%02X.",jtag_status);
+  }
   LOG_DEBUG("EOnCE status: 0x%02X.",eonce_status);
   return ERROR_OK;
 }
@@ -916,25 +899,12 @@ static int dsp5680xx_bulk_write_memory(struct target * target,uint32_t address,
   return ERROR_FAIL;
 }
 
-// Writes to pram at address
-// r3 holds the destination address-> p:(r3)
-// r2 hold 0xf151 to flash a led (probably cannot see it due to high freq.)
-// r0 holds TX/RX address.
-//0x00000073  0x8A44FFFE017B         brclr       #1,X:(R0-2),*-2
-//0x00000076  0xE700                 nop
-//0x00000077  0xF514                 move.w      X:(R0),Y0
-//0x00000078  0xE700                 nop
-//0x00000079  0x8563                 move.w      Y0,P:(R3)+
-//0x0000007A  0x84420003             bfchg       #3,X:(R2)
-//0x0000007C  0xA976                 bra         *-9
-uint16_t pgm_write_pram[] = {0x8A44,0xFFFE,0x017D,0xE700,0xF514,0xE700,0x8563,0x8442,0x0003,0xA976};
-uint16_t pgm_write_pram_length = 10;
-
 static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint32_t size, const uint8_t * buffer){
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // this solution works, but it's slow. it flushes USB all the time.
+  if(target->state != TARGET_HALTED){
+    LOG_USER("Target must be halted.");
+    return ERROR_OK;
+  }
   return dsp5680xx_write(target, address, 1, size, buffer);
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 }
 
 static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){

commit c4bcb0b95a8d3ee9baf7046b6768976d8a4eb134
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:21:22 2011 -0700

    cleanup flash module command

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index da9ba46..d1c1d19 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -1029,6 +1029,9 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
       err_check(retval,"FM execute command failed.");
     }
   }while (!(i&0x40));				// wait until current command is complete
+
+  context.flush = 0;
+
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG);	// write to HFM_CNFG (lock=0, select bank) -- flash_desc.bank&0x03,0x01 == 0x00,0x01 ???
   err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x04,HFM_USTAT);		// write to HMF_USTAT, clear PVIOL, ACCERR & BLANK bits
@@ -1056,6 +1059,11 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   err_check_propagate(retval);
   retval = eonce_move_value_at_r2_disp(target,0x80,HFM_USTAT);		// start the command
   err_check_propagate(retval);
+
+  context.flush = 1;
+  retval = dsp5680xx_execute_queue();
+  err_check_propagate(retval);
+
   watchdog = 100;
   do{
     retval = eonce_move_at_r2_disp_to_y0(target,HFM_USTAT);	// read HMF_USTAT
@@ -1070,6 +1078,10 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
     }
   }while (!(i&0x40));	    // wait until the command is complete
   *hfm_ustat = i;
+  if (i&HFM_USTAT_MASK_PVIOL_ACCER){
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,"pviol and/or accer bits set. HFM command execution error");
+  }
   return ERROR_OK;
 }
 
@@ -1120,10 +1132,6 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   }
   retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&hfm_ustat,1);
   err_check_propagate(retval);
-  if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
-    retval = ERROR_TARGET_FAILURE;
-    err_check(retval,"HFM exec error:pviol and/or accer bits set.");
-  }
   retval = dsp5680xx_read_16_single(target, HFM_BASE_ADDR|HFM_DATA, signature, 0);
   return retval;
 }
@@ -1138,10 +1146,6 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
   // Check if chip is already erased.
   retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,&hfm_ustat,1); // blank check
   err_check_propagate(retval);
-  if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,"pviol and/or accer bits set. EraseVerify HFM command execution error");;
-  }
   if(erased!=NULL)
     *erased = (uint8_t)(hfm_ustat&HFM_USTAT_MASK_BLANK);
   return retval;

commit d539fc856f4c09e3a3b683c2b1b5766652ab9d7a
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:20:59 2011 -0700

    fix read for verify_image

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index f503e08..da9ba46 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -942,35 +942,13 @@ static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint3
     LOG_USER("Target must be halted.");
     return ERROR_OK;
   }
-  // byte addressing!
-  int retval = ERROR_OK;
-  int pmem = 1;
-  uint16_t tmp_wrd= 0;
-
-  retval = dsp5680xx_convert_address(&address, &pmem);
-  err_check_propagate(retval);
-
-  for (unsigned i=0; i<size; i++)
-    if(!(i%2)){
-      retval = dsp5680xx_read_16_single(target, address + i/2, &tmp_wrd, pmem);
-	  err_check_propagate(retval);
-      //TODO find a better solution. endiannes differs from normal read, otherwise the openocd crc would do weird stuff.
-      buffer[i+1] = (uint8_t) (tmp_wrd>>8);
-      buffer[i] = (uint8_t) (tmp_wrd&0xff);
-   }
-  return retval;
+  // read_buffer is called when the verify_image command is executed.
+  // The "/2" solves the byte/word addressing issue. 
+  return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
 static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
- //TODO implement.
-  //This will make openocd do the work, but it will fail because of the word/byte addressing issues.
-  int retval;
-  struct working_area * crc_algorithm;
-  retval = target_alloc_working_area(target, 20, &crc_algorithm);
-  if(retval != ERROR_OK)
-    return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-  retval = target_free_working_area(target, crc_algorithm);
-  return ERROR_FAIL;
+  return ERROR_FAIL;// This will make OpenOCD do the read out the data and verify it.
 }
 
 // Data signature algorithm used by the core FM (flash module)

commit f42353d82137d0a3f5e2433bae931c82b8407c74
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:20:18 2011 -0700

    fix read speed improved by queueing commands

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index c79ee3a..f503e08 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -714,7 +714,14 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   retval = dsp5680xx_convert_address(&address, &pmem);
   err_check_propagate(retval);
 
+  context.flush = 0;
+  int counter = FLUSH_COUNT_READ_WRITE;
+
   for (unsigned i=0; i<count; i++){
+    if(--counter==0){
+      context.flush = 1;
+      counter = FLUSH_COUNT_FLASH;
+    }
     switch (size){
     case 1:
       if(!(i%2)){
@@ -734,7 +741,13 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
       break;
     }
 	err_check_propagate(retval);
+    context.flush = 0;
   }
+  
+  context.flush = 1;
+  retval = dsp5680xx_execute_queue();
+  err_check_propagate(retval);
+  
   return retval;
 }
 

commit f4a3db0d4a353ccc6d701a2645390ef9039e0d02
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:19:58 2011 -0700

    fix flash driver size, sector erase

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index e9c4e82..4e7a0b6 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -41,17 +41,13 @@ struct dsp5680xx_flash_bank {
 };
 
 static int dsp5680xx_build_sector_list(struct flash_bank *bank){
-  //LOG_USER("%s not implemented",__FUNCTION__);
-  //return ERROR_OK;
-
-  // sector size is 512
-  // bank->num_sectors = bank->size / 512; // Bank size is actually 0x2000, but it is set much higher as part of the workaround for byte/word addressing issues.
+  uint32_t offset = HFM_FLASH_BASE_ADDR;
   bank->sectors = malloc(sizeof(struct flash_sector) * bank->num_sectors);
   int i;
   for (i = 0; i < bank->num_sectors; ++i){
-    bank->sectors[i].offset = 0;// not implemented.
+    bank->sectors[i].offset = i*HFM_SECTOR_SIZE;
     bank->sectors[i].size = HFM_SECTOR_SIZE;
-    //offset += bank->sectors[i].size;
+    offset += bank->sectors[i].size;
     bank->sectors[i].is_erased = -1;
     bank->sectors[i].is_protected = -1;
   }
@@ -67,9 +63,9 @@ FLASH_BANK_COMMAND_HANDLER(dsp5680xx_flash_bank_command){
   nbank = malloc(sizeof(struct dsp5680xx_flash_bank));
 
   bank->base = HFM_FLASH_BASE_ADDR;
-  bank->size = HFM_SIZE; // top 4k not accessible
+  bank->size = HFM_SIZE_BYTES; // top 4k not accessible
   bank->driver_priv = nbank;
-  bank->num_sectors = HFM_SECTOR_COUNT;// This number is anything >0. not really used.
+  bank->num_sectors = HFM_SECTOR_COUNT;
   dsp5680xx_build_sector_list(bank);
 
   return ERROR_OK;
@@ -77,30 +73,40 @@ FLASH_BANK_COMMAND_HANDLER(dsp5680xx_flash_bank_command){
 
 static int dsp5680xx_flash_protect_check(struct flash_bank *bank){
   int retval = ERROR_OK;
-  uint8_t protected = 0; 
-  if(bank->sectors[0].is_protected == -1){
+  uint16_t protected = 0;
     retval = dsp5680xx_f_protect_check(bank->target,&protected);
-    if(retval == ERROR_OK)
-      if(protected)
-	bank->sectors[0].is_protected = 1;
-      else
-	bank->sectors[0].is_protected = 0;
-    else
-      bank->sectors[0].is_protected = -1;
+  if(retval != ERROR_OK){
+    for(int i = 0;i<HFM_SECTOR_COUNT;i++)
+      bank->sectors[i].is_protected = -1;
+    return ERROR_OK;
+  }
+  for(int i = 0;i<HFM_SECTOR_COUNT/2;i++){
+    if(protected & 1){
+      bank->sectors[2*i].is_protected = 1;
+      bank->sectors[2*i+1].is_protected = 1;
+    }else{
+      bank->sectors[2*i].is_protected = 0;
+      bank->sectors[2*i+1].is_protected = 0;
+    }
+    protected = (protected >> 1);
   }
   return retval;
 }
 
 static int dsp5680xx_flash_protect(struct flash_bank *bank, int set, int first, int last){
+  // This applies security to flash module after next reset, it does not actually apply protection (protection refers to undesired access from the core)
   int retval;
   if(set){
     retval = dsp5680xx_f_lock(bank->target);
-    if(retval == ERROR_OK)
-      bank->sectors[0].is_protected = 1;
+    if(retval == ERROR_OK){
+      for(int i = first;i<last;i++)
+	bank->sectors[i].is_protected = 1;
+    }
   }else{    
     retval = dsp5680xx_f_unlock(bank->target);
     if(retval == ERROR_OK)
-      bank->sectors[0].is_protected = 0;
+      for(int i = first;i<last;i++)
+	bank->sectors[i].is_protected = 0;
   }
   return retval;
 }
@@ -167,24 +173,30 @@ static int dsp5680xx_flash_erase(struct flash_bank * bank, int first, int last){
   int retval;
   retval = dsp5680xx_f_erase(bank->target, (uint32_t) first, (uint32_t) last);
   if(retval == ERROR_OK)
-    bank->sectors[0].is_erased = 1;
+    for(int i = first;i<=last;i++)
+      bank->sectors[i].is_erased = 1;
   else
-    bank->sectors[0].is_erased = -1;
+	// If an error occurred unknown status is set even though some sector could have been correctly erased.
+    for(int i = first;i<=last;i++)
+      bank->sectors[i].is_erased = -1;
   return retval;
 }
 
 static int dsp5680xx_flash_erase_check(struct flash_bank * bank){
   int retval = ERROR_OK;
   uint8_t erased = 0;
-  if(bank->sectors[0].is_erased == -1){
-    retval = dsp5680xx_f_erase_check(bank->target,&erased);
+  uint32_t i;
+  for(i=0;i<HFM_SECTOR_COUNT;i++){
+    if(bank->sectors[i].is_erased == -1){
+      retval = dsp5680xx_f_erase_check(bank->target,&erased,i);
     if (retval != ERROR_OK){
-      bank->sectors[0].is_erased = -1;
+	bank->sectors[i].is_erased = -1;
     }else{
       if(erased)
-	bank->sectors[0].is_erased = 1;
+	bank->sectors[i].is_erased = 1;
       else
-	bank->sectors[0].is_erased = 0;
+	bank->sectors[i].is_erased = 0;
+      }
     }
   }
   return retval;
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 9eba374..c79ee3a 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -244,17 +244,6 @@ static int eonce_read_status_reg(struct target * target, uint16_t * data){
   return retval;
 }
 
-static int dsp5680xx_obase_addr(struct target * target, uint32_t * addr){
-  // Finds out the default value of the OBASE register address.
-  int retval;
-  uint32_t data_to_shift_into_dr;// just to make jtag happy
-  retval = eonce_instruction_exec(target,DSP5680XX_ONCE_OBASE,1,0,0,NULL);
-  err_check_propagate(retval);
-  retval = dsp5680xx_drscan(target,(uint8_t *)& data_to_shift_into_dr,(uint8_t *) addr, 8);
-  err_check_propagate(retval);
-  return retval;
-}
-
 static int dsp5680xx_halt(struct target *target){
   int retval;
   uint8_t jtag_status;
@@ -614,24 +603,15 @@ static int eonce_move_value_to_pc(struct target * target, uint32_t value)
 
 static int eonce_load_TX_RX_to_r0(struct target * target)
 {
-  uint32_t obase_addr;
-  int retval = dsp5680xx_obase_addr(target,& obase_addr);
-  err_check_propagate(retval);
-  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(obase_addr<<16)));
+  int retval;
+  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX_RX_ADDR)+(MC568013_EONCE_OBASE_ADDR<<16)));
   return retval;
 }
 
 static int eonce_load_TX_RX_high_to_r0(struct target * target)
 {
-  uint32_t obase_addr;
-  int retval = dsp5680xx_obase_addr(target,& obase_addr);
-  err_check_propagate(retval);
-  if(!(obase_addr && 0xff)){
-	LOG_USER("%s: OBASE address read as 0x%04X instead of 0xFF.",__FUNCTION__,obase_addr);
-	return ERROR_FAIL;
-  }
-  eonce_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(obase_addr<<16)));
-  err_check_propagate(retval);
+  int retval = 0;
+  retval = eonce_move_long_to_r0(target,((MC568013_EONCE_TX1_RX1_HIGH_ADDR)+(MC568013_EONCE_OBASE_ADDR<<16)));
   return retval;
 }
 
@@ -804,11 +784,11 @@ static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t
   uint16_t * data_w = (uint16_t *)data;
   uint32_t iter;
 
-  int counter = FLUSH_COUNT_WRITE;
+  int counter = FLUSH_COUNT_READ_WRITE;
   for(iter = 0; iter<count/2; iter++){
     if(--counter==0){
       context.flush = 1;
-      counter = FLUSH_COUNT_WRITE;
+      counter = FLUSH_COUNT_READ_WRITE;
     }
     retval = dsp5680xx_write_16_single(target,address+iter,data_w[iter], pmem);
     if(retval != ERROR_OK){
@@ -843,14 +823,12 @@ static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t
 	err_check(retval,"Target must be halted.");
   };
   uint32_t iter;
-
-  int counter_reset = FLUSH_COUNT_WRITE;
-  int counter = counter_reset;
+  int counter = FLUSH_COUNT_READ_WRITE;
 
   for(iter = 0; iter<count; iter++){
 	if(--counter==0){
 	  context.flush = 1;
-	  counter = counter_reset;
+      counter = FLUSH_COUNT_READ_WRITE;
 	}
     retval = dsp5680xx_write_16_single(target,address+iter,data[iter], pmem);
     if(retval != ERROR_OK){
@@ -871,14 +849,12 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
 	err_check(retval,"Target must be halted.");
   };
   uint32_t iter;
-
-  int counter_reset = FLUSH_COUNT_WRITE;
-  int counter = counter_reset;
+  int counter = FLUSH_COUNT_READ_WRITE;
 
   for(iter = 0; iter<count; iter++){
 	if(--counter==0){
 	  context.flush = 1;
-	  counter = counter_reset;
+      counter = FLUSH_COUNT_READ_WRITE;
 	}
     retval = dsp5680xx_write_32_single(target,address+(iter<<1),data[iter], pmem);
     if(retval != ERROR_OK){
@@ -1026,29 +1002,19 @@ static int dsp5680xx_soft_reset_halt(struct target *target){
   return retval;
 }
 
-int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected) {
-  uint16_t i,j;
+int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
+  uint16_t aux;
   int retval;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
 	err_check_propagate(retval);
   }
-  retval = eonce_load_TX_RX_high_to_r0(target);
-  err_check_propagate(retval);
-  retval = eonce_move_value_to_y0(target,0x1234);
-  err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
-  err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,&i);
-  err_check_propagate(retval);
-  retval = eonce_move_value_to_y0(target,0x4321);
-  err_check_propagate(retval);
-  retval = eonce_move_y0_at_r0(target);
-  err_check_propagate(retval);
-  retval = eonce_rx_upper_data(target,&j);
+  if(protected == NULL){
+    err_check(ERROR_FAIL,"NULL pointer not valid.");
+  }
+  retval = dsp5680xx_read_16_single(target,HFM_BASE_ADDR|HFM_PROT,&aux,0);
   err_check_propagate(retval);
-  if(protected!=NULL)
-    *protected = (uint8_t) ((i!=0x1234)||(j!=0x4321));
+  *protected = aux;
   return retval;
 }
 
@@ -1171,32 +1137,15 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   return retval;
 }
 
-int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
+int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t sector){
   int retval;
   uint16_t hfm_ustat;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
     err_check_propagate(retval);
   }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Check security
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint8_t protected;
-  retval = dsp5680xx_f_protect_check(target,&protected);
-  err_check_propagate(retval);
-  if(protected){
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,"Failed to erase, flash is still protected.");
-  }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Set hfmdiv
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  retval = eonce_set_hfmdiv(target);
-  err_check_propagate(retval);
-
   // Check if chip is already erased.
-  // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
-  retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,0,&hfm_ustat,1); // blank check
+  retval = dsp5680xx_f_execute_command(target,HFM_ERASE_VERIFY,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,&hfm_ustat,1); // blank check
   err_check_propagate(retval);
   if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
 	retval = ERROR_TARGET_FAILURE;
@@ -1206,17 +1155,25 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased){
     *erased = (uint8_t)(hfm_ustat&HFM_USTAT_MASK_BLANK);
   return retval;
 }
+  
+static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
+  int retval;
+  retval = dsp5680xx_f_execute_command(target,HFM_PAGE_ERASE,HFM_FLASH_BASE_ADDR+sector*HFM_SECTOR_SIZE/2,0,hfm_ustat,1);
+  err_check_propagate(retval);
+  return retval;
+}
+ 
+static int mass_erase(struct target * target, uint16_t * hfm_ustat){
+  int retval;
+  retval = dsp5680xx_f_execute_command(target,HFM_MASS_ERASE,0,0,hfm_ustat,1);
+  return retval;
+}
 
 int dsp5680xx_f_erase(struct target * target, int first, int last){
-  //TODO implement erasing individual sectors.
   int retval;
-  if(first||last){
-	retval = ERROR_FAIL;
-	err_check(retval,"Sector erasing not implemented. Call with first=last=0.");
-  }
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = dsp5680xx_halt(target);
-	err_check_propagate(retval);
+    err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Reset SIM
@@ -1224,49 +1181,25 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
   retval = dsp5680xx_f_SIM_reset(target);
   err_check_propagate(retval);
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Check security
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint8_t protected;
-  retval = dsp5680xx_f_protect_check(target,&protected);
-  err_check_propagate(retval);
-  if(protected){
-	retval = ERROR_TARGET_FAILURE;
-	err_check(retval,"Cannot flash, security is still enabled.");
-  }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   retval = eonce_set_hfmdiv(target);
   err_check_propagate(retval);
 
-  // Check if chip is already erased.
-  // Since only mass erase is currently implemented, only the first sector is checked (assuming no code will leave it unused)
-  uint8_t erased;
-  retval = dsp5680xx_f_erase_check(target,&erased);
-  err_check_propagate(retval);
-  if (erased)
-    LOG_USER("Flash blank - mass erase skipped.");
-  else{
-    // Execute mass erase command.
-	uint16_t hfm_ustat;
-	uint16_t hfm_cmd = HFM_MASS_ERASE;
-	retval = dsp5680xx_f_execute_command(target,hfm_cmd,HFM_FLASH_BASE_ADDR+0*HFM_SECTOR_SIZE,0,&hfm_ustat,1);
-	err_check_propagate(retval);
-    if (hfm_ustat&HFM_USTAT_MASK_PVIOL_ACCER){
-	  retval = ERROR_TARGET_FAILURE;
-	  err_check(retval,"pviol and/or accer bits set. HFM command execution error");
-    }
-    // Verify flash was successfully erased.
-    retval = dsp5680xx_f_erase_check(target,&erased);
+  uint16_t hfm_ustat;
+  int do_mass_erase = ((!(first|last)) || ((first==0)&&(last == (HFM_SECTOR_COUNT-1))));
+  if(do_mass_erase){
+    //Mass erase
+    retval = mass_erase(target,&hfm_ustat);
+    err_check_propagate(retval);
+    last = HFM_SECTOR_COUNT-1;
+  }else{
+    for(int i = first;i<=last;i++){
+      retval = erase_sector(target,i,&hfm_ustat);
 	err_check_propagate(retval);
-	if(retval == ERROR_OK){
-      if (erased)
-		LOG_USER("Flash mass erased and checked blank.");
-      else
-		LOG_WARNING("Flash mass erased, but still not blank!");
-    }
   }
-  return retval;
+  }
+  return ERROR_OK;
 }
 
 // Algorithm for programming normal p: flash
@@ -1317,16 +1250,6 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	err_check_propagate(retval);
   }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Check if flash is erased
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint8_t erased;
-  retval = dsp5680xx_f_erase_check(target,&erased);
-  err_check_propagate(retval);
-  if(!erased){
-	retval = ERROR_FAIL;
-	err_check(retval,"Flash must be erased before flashing.");
-  }
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Download the pgm that flashes.
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint32_t my_favourite_ram_address = 0x8700; // This seems to be a safe address. This one is the one used by codewarrior in 56801x_flash.cfg
@@ -1375,14 +1298,13 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   retval = dsp5680xx_resume(target,0,my_favourite_ram_address,0,0);
   err_check_propagate(retval);
 
-  int counter_reset = FLUSH_COUNT_FLASH;
-  int counter = counter_reset;
+  int counter = FLUSH_COUNT_FLASH;
   context.flush = 0;
   uint32_t i;
-  for(i=1; (i<count/2)&&(i<HFM_SIZE_REAL); i++){
+  for(i=1; (i<count/2)&&(i<HFM_SIZE_WORDS); i++){
     if(--counter==0){
       context.flush = 1;
-      counter = counter_reset;
+      counter = FLUSH_COUNT_FLASH;
     }
     retval = eonce_tx_upper_data(target,buff16[i],&drscan_data);
 	if(retval!=ERROR_OK){
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 9f66ee7..da494c9 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -124,8 +124,8 @@
 #define DSP5680XX_ONCE_OPABDR   0x13 /* OnCE Program Address Register???Decode cycle (OPABDR) */
 //----------------------------------------------------------------
 
-#define FLUSH_COUNT_WRITE 4095 // This value works, higher values (and lower...) may work as well.
-#define FLUSH_COUNT_FLASH 7 // Waiting for longer queues will cause flashing errors.
+#define FLUSH_COUNT_READ_WRITE 8192 // This value works, higher values (and lower...) may work as well.
+#define FLUSH_COUNT_FLASH 8192
 //----------------------------------------------------------------
 // HFM (flash module) Commands (ref:MC56F801xRM.pdf at 159)
 //----------------------------------------------------------------
@@ -160,12 +160,13 @@
 #define HFM_USTAT_MASK_BLANK 0x4
 #define HFM_USTAT_MASK_PVIOL_ACCER 0x30
 
-#define HFM_CLK_DEFAULT	0x29
+#define HFM_CLK_DEFAULT	0x40
 #define HFM_FLASH_BASE_ADDR 0x0
-#define HFM_SIZE 0x8000 // This is not true for 56F8013, but it is necessary to get the byte/word addressing workaround to actually work.
-#define HFM_SIZE_REAL 0x2000
-#define HFM_SECTOR_SIZE 0x8000 // 512 bytes pages.
-#define HFM_SECTOR_COUNT 1
+#define HFM_SIZE_BYTES 0x4000 // bytes
+#define HFM_SIZE_WORDS 0x2000 // words
+#define HFM_SECTOR_SIZE 0x200 // Size in bytes
+#define HFM_SECTOR_COUNT 0x20
+// A 16K block in pages of 256 words.
 
 #define HFM_LOCK_FLASH 0xE70A
 #define HFM_LOCK_ADDR_L 0x1FF7
@@ -204,9 +205,9 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
 
 int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
 
-int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased);
+int dsp5680xx_f_erase_check(struct target * target,uint8_t * erased, uint32_t sector);
 int dsp5680xx_f_erase(struct target * target, int first, int last);
-int dsp5680xx_f_protect_check(struct target * target, uint8_t * protected);
+int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected);
 int dsp5680xx_f_lock(struct target * target);
 int dsp5680xx_f_unlock(struct target * target);
 

commit 56d3927abf2d2c6c49f3ae6ad6c2f353168d5a60
Author: Rodrigo L. Rosa <rodrigorosa.lg at gmail.com>
Date:   Fri Jun 10 12:19:32 2011 -0700

    Added minimodule (ftdi) interface

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 8c2382a..7c28327 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -177,6 +177,7 @@ static int lm3s811_jtag_init(void);
 static int icdi_jtag_init(void);
 static int olimex_jtag_init(void);
 static int flyswatter_init(void);
+static int minimodule_init(void);
 static int turtle_init(void);
 static int comstick_init(void);
 static int stm32stick_init(void);
@@ -197,6 +198,7 @@ static void ftx23_reset(int trst, int srst);
 static void jtagkey_reset(int trst, int srst);
 static void olimex_jtag_reset(int trst, int srst);
 static void flyswatter_reset(int trst, int srst);
+static void minimodule_reset(int trst, int srst);
 static void turtle_reset(int trst, int srst);
 static void comstick_reset(int trst, int srst);
 static void stm32stick_reset(int trst, int srst);
@@ -261,6 +263,10 @@ static const struct ft2232_layout  ft2232_layouts[] =
 		.reset = flyswatter_reset,
 		.blink = flyswatter_jtag_blink
 	},
+	{ .name = "minimodule",
+		.init = minimodule_init,
+		.reset = minimodule_reset,
+	},
 	{ .name = "turtelizer2",
 		.init = turtle_init,
 		.reset = turtle_reset,
@@ -1565,6 +1571,24 @@ static void flyswatter_reset(int trst, int srst)
 	LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x", trst, srst, low_output, low_direction);
 }
 
+static void minimodule_reset(int trst, int srst)
+{
+	if (srst == 1)
+	{
+		low_output &= ~nSRST;
+	}
+	else if (srst == 0)
+	{
+		low_output |= nSRST;
+	}
+
+	/* command "set data bits low byte" */
+	buffer_write(0x80);
+	buffer_write(low_output);
+	buffer_write(low_direction);
+	LOG_DEBUG("trst: %i, srst: %i, low_output: 0x%2.2x, low_direction: 0x%2.2x", trst, srst, low_output, low_direction);
+}
+
 static void turtle_reset(int trst, int srst)
 {
 	trst = trst;
@@ -2900,6 +2924,37 @@ static int flyswatter_init(void)
 	return ERROR_OK;
 }
 
+static int minimodule_init(void)
+{
+	low_output    = 0x18;//check if srst should be 1 or 0 initially. (0x08) (flyswatter was 0x18)
+	low_direction = 0xfb;//0xfb;
+
+	/* initialize low byte for jtag */
+	if (ft2232_set_data_bits_low_byte(low_output,low_direction) != ERROR_OK)
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'minimodule' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+	
+
+	nSRST    = 0x20;
+
+	high_output    = 0x00;
+	high_direction = 0x05;
+
+	/* turn red LED3 on, LED2 off */
+	//high_output |= 0x08;
+
+	/* initialize high byte for jtag */
+	if (ft2232_set_data_bits_high_byte(high_output,high_direction) != ERROR_OK)
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'minimodule' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
 static int turtle_init(void)
 {
 	low_output    = 0x08;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/dsp5680xx_flash.c |  173 ++++---
 src/jtag/drivers/ft2232.c       |   55 ++
 src/target/dsp5680xx.c          | 1037 ++++++++++++++++++++-------------------
 src/target/dsp5680xx.h          |  105 ++++-
 tcl/interface/minimodule.cfg    |   10 +
 5 files changed, 798 insertions(+), 582 deletions(-)
 create mode 100644 tcl/interface/minimodule.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jun 12 11:33:56 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 12 Jun 2011 09:33:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-919-g1b0862c
Message-ID: <mailman.105.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1b0862c189f8db70f65e0eeabb749580d71e0e97 (commit)
      from  5227ae7162732c89fbf2e5eb547c4b1bee03bb58 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1b0862c189f8db70f65e0eeabb749580d71e0e97
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jun 12 11:33:37 2011 +0200

    HACKING: add tip on how to write comments

diff --git a/HACKING b/HACKING
index 5718798..6e4fc4b 100644
--- a/HACKING
+++ b/HACKING
@@ -34,6 +34,13 @@ while(!done) {
 
 TIP! use "git add ." before commit to add new files.
 
+--- example comment, notice the short first line w/topic ---
+topic: short comment
+<blank line>
+longer comments over several
+lines...
+-----
+
 3. Next you need to make sure that your patches
 are on top of the latest stuff on the server and
 that there are no conflicts.

-----------------------------------------------------------------------

Summary of changes:
 HACKING |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 13 21:13:24 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 13 Jun 2011 19:13:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-920-gc8b5719
Message-ID: <mailman.106.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c8b57198025c414f8d19577e6846021843c2a751 (commit)
      from  1b0862c189f8db70f65e0eeabb749580d71e0e97 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c8b57198025c414f8d19577e6846021843c2a751
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 13 15:42:46 2011 +0200

    transport: move files over to transport folder
    
    as we introduce swd and jtag as two transports, we want
    to start up with a new transport folder to organize the
    code a bit.

diff --git a/configure.in b/configure.in
index 8315a18..cb62c85 100644
--- a/configure.in
+++ b/configure.in
@@ -1167,6 +1167,7 @@ AC_OUTPUT(dnl
     src/helper/Makefile dnl
     src/jtag/Makefile dnl
     src/jtag/drivers/Makefile dnl
+    src/transport/Makefile dnl
     src/xsvf/Makefile dnl
     src/svf/Makefile dnl
     src/target/Makefile dnl
diff --git a/src/Makefile.am b/src/Makefile.am
index 3d7b05f..60d1189 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -4,6 +4,7 @@ SUBDIRS = \
 	jtag \
 	helper \
 	target \
+	transport \
 	flash \
 	svf \
 	xsvf \
@@ -98,6 +99,7 @@ libopenocd_la_LIBADD = \
 	$(top_builddir)/src/svf/libsvf.la \
 	$(top_builddir)/src/pld/libpld.la \
 	$(top_builddir)/src/jtag/libjtag.la \
+	$(top_builddir)/src/transport/libtransport.la \
 	$(top_builddir)/src/flash/libflash.la \
 	$(top_builddir)/src/target/libtarget.la \
 	$(top_builddir)/src/server/libserver.la \
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index fa964a3..2717dc5 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -56,7 +56,6 @@ libjtag_la_SOURCES = \
 	interface.c \
 	interfaces.c \
 	tcl.c \
-	transport.c \
 	$(DRIVERFILES)
 
 noinst_HEADERS = \
@@ -66,7 +65,6 @@ noinst_HEADERS = \
 	interfaces.h \
 	minidriver.h \
 	jtag.h \
-	transport.h \
 	minidriver/minidriver_imp.h \
 	minidummy/jtag_minidriver.h
 
diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index e16f756..94843d7 100644
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -35,7 +35,7 @@
 #include "minidriver.h"
 #include "interface.h"
 #include "interfaces.h"
-#include "transport.h"
+#include <transport/transport.h>
 
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 22d0b8c..b26701e 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -33,7 +33,7 @@
 
 #include "jtag.h"
 #include "interface.h"
-#include "transport.h"
+#include <transport/transport.h>
 
 #ifdef HAVE_STRINGS_H
 #include <strings.h>
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index bde1700..38ead56 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -81,7 +81,7 @@
 
 /* project specific includes */
 #include <jtag/interface.h>
-#include <jtag/transport.h>
+#include <transport/transport.h>
 #include <helper/time_support.h>
 
 #if IS_CYGWIN == 1
diff --git a/src/openocd.c b/src/openocd.c
index a5002d1..57676f5 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -31,7 +31,7 @@
 #include "openocd.h"
 #include <jtag/driver.h>
 #include <jtag/jtag.h>
-#include <jtag/transport.h>
+#include <transport/transport.h>
 #include <helper/ioutil.h>
 #include <helper/util.h>
 #include <helper/configuration.h>
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
index 39f3857..5a3570d 100644
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -50,7 +50,7 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
-#include <jtag/transport.h>
+#include <transport/transport.h>
 #include <jtag/interface.h>
 
 #include <jtag/swd.h>
diff --git a/src/transport/Makefile.am b/src/transport/Makefile.am
new file mode 100644
index 0000000..7c6224a
--- /dev/null
+++ b/src/transport/Makefile.am
@@ -0,0 +1,11 @@
+include $(top_srcdir)/common.mk
+
+#METASOURCES = AUTO
+noinst_LTLIBRARIES = libtransport.la
+libtransport_la_SOURCES = \
+	transport.c
+
+noinst_HEADERS = \
+	transport.h
+
+MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
diff --git a/src/jtag/transport.c b/src/transport/transport.c
similarity index 99%
rename from src/jtag/transport.c
rename to src/transport/transport.c
index 6022880..b5e4b90 100644
--- a/src/jtag/transport.c
+++ b/src/transport/transport.c
@@ -44,7 +44,7 @@
 
 #include <helper/log.h>
 
-#include "transport.h"
+#include <transport/transport.h>
 
 extern struct command_context *global_cmd_ctx;
 
diff --git a/src/jtag/transport.h b/src/transport/transport.h
similarity index 95%
rename from src/jtag/transport.h
rename to src/transport/transport.h
index d2d38ec..6ece39e 100644
--- a/src/jtag/transport.h
+++ b/src/transport/transport.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2010 by David Brownell
+ * Copyright (C) 2011 Tomasz Boleslaw CEDRO (http://www.tomek.cedro.info)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -16,6 +17,9 @@
  * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#ifndef TRANSPORT_H
+#define TRANSPORT_H
+
 #include "helper/command.h"
 
 /**
@@ -78,3 +82,5 @@ COMMAND_HELPER(transport_list_parse, char ***vector);
 int allow_transports(struct command_context *ctx, const char **vector);
 
 bool transports_are_declared(void);
+
+#endif

-----------------------------------------------------------------------

Summary of changes:
 configure.in                        |    1 +
 src/Makefile.am                     |    2 ++
 src/jtag/Makefile.am                |    2 --
 src/jtag/adapter.c                  |    2 +-
 src/jtag/core.c                     |    2 +-
 src/jtag/drivers/ft2232.c           |    2 +-
 src/openocd.c                       |    2 +-
 src/target/adi_v5_swd.c             |    2 +-
 src/transport/Makefile.am           |   11 +++++++++++
 src/{jtag => transport}/transport.c |    2 +-
 src/{jtag => transport}/transport.h |    6 ++++++
 11 files changed, 26 insertions(+), 8 deletions(-)
 create mode 100644 src/transport/Makefile.am
 rename src/{jtag => transport}/transport.c (99%)
 rename src/{jtag => transport}/transport.h (95%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 16 17:30:30 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 16 Jun 2011 15:30:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-922-g9f40d41
Message-ID: <mailman.107.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9f40d41f6867fcaa68636d2f958aa1df43ec3971 (commit)
      from  523c172280b10dea9e65ff726face6f0deed4736 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9f40d41f6867fcaa68636d2f958aa1df43ec3971
Author: Tomek CEDRO <cederom at tlen.pl>
Date:   Thu Jun 16 07:09:41 2011 +0000

    OPENOCD: Renamed ambiguous main2() into openocd_thread() to show possible solution for thread support in future.

diff --git a/src/openocd.c b/src/openocd.c
index 57676f5..a352b70 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -301,7 +301,11 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 	return cmd_ctx;
 }
 
-static int main2(int argc, char *argv[], struct command_context *cmd_ctx)
+/** OpenOCD runtime meat that can become single-thread in future. It parse
+ * commandline, reads configuration, sets up the target and starts server loop.
+ * Commandline arguments are passed into this function from openocd_main().
+ */
+static int openocd_thread(int argc, char *argv[], struct command_context *cmd_ctx)
 {
 	int ret;
 
@@ -362,7 +366,8 @@ int openocd_main(int argc, char *argv[])
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
 	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
 
-	ret = main2(argc, argv, cmd_ctx);
+	/* Start the executable meat that can evolve into thread in future. */
+	ret = openocd_thread(argc, argv, cmd_ctx);
 
 	unregister_all_commands(cmd_ctx, NULL);
 

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 16 16:54:34 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 16 Jun 2011 14:54:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-921-g523c172
Message-ID: <mailman.108.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  523c172280b10dea9e65ff726face6f0deed4736 (commit)
      from  c8b57198025c414f8d19577e6846021843c2a751 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 523c172280b10dea9e65ff726face6f0deed4736
Author: Dale Lukas Peterson <hazelnusse at gmail.com>
Date:   Wed Jun 15 15:12:54 2011 -0700

    Added Olimex STM32 {H,P}107.cfg board

diff --git a/tcl/board/olimex_stm32_h107.cfg b/tcl/board/olimex_stm32_h107.cfg
new file mode 100644
index 0000000..c21e19b
--- /dev/null
+++ b/tcl/board/olimex_stm32_h107.cfg
@@ -0,0 +1,8 @@
+# Olimex STM32-H107 and STM32-P107 eval boards
+# http://olimex.com/dev/stm32-h107.html
+# http://olimex.com/dev/stm32-p107.html
+
+# Work-area size (RAM size) = 64kB for STM32F107VC device
+set WORKAREASIZE 0x10000
+
+source [find target/stm32.cfg]

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/olimex_stm32_h107.cfg |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/olimex_stm32_h107.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 16 20:11:22 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 16 Jun 2011 18:11:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-923-g37d5ac6
Message-ID: <mailman.109.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  37d5ac6378c306275775b36ad776ba4de6746e10 (commit)
      from  9f40d41f6867fcaa68636d2f958aa1df43ec3971 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 37d5ac6378c306275775b36ad776ba4de6746e10
Author: Tomek CEDRO <cederom at tlen.pl>
Date:   Thu Jun 16 06:54:58 2011 +0000

    ADAPTER: Fixed transport selection mechanism to support transports other than jtag (if defined).

diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index 94843d7..a0cd5e3 100644
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -47,8 +47,7 @@
  */
 
 extern struct jtag_interface *jtag_interface;
-
-
+const char *jtag_only[] = { "jtag", NULL };
 
 static int
 jim_adapter_name(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
@@ -93,9 +92,6 @@ static int default_srst_asserted(int *srst_asserted)
 	return ERROR_OK;
 }
 
-const char *jtag_only[] = { "jtag", NULL, };
-
-
 COMMAND_HANDLER(interface_transport_command)
 {
 	char **transports;
@@ -169,9 +165,8 @@ COMMAND_HANDLER(handle_interface_command)
 		LOG_WARNING("Adapter driver '%s' did not declare "
 			"which transports it allows; assuming "
 			"legacy JTAG-only", jtag_interface->name);
-		retval = allow_transports(CMD_CTX,
-					jtag_interface->transports
-						? : jtag_only);
+		retval = allow_transports(CMD_CTX, jtag_interface->transports
+						? jtag_interface->transports : jtag_only);
 			if (ERROR_OK != retval)
 				return retval;
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/adapter.c |   11 +++--------
 1 files changed, 3 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Jun 17 11:00:48 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri, 17 Jun 2011 09:00:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-925-g9cac49c
Message-ID: <mailman.110.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9cac49caeee7990c07064bfb09555c68ed2d2516 (commit)
       via  3428035a7e0890a319f40a5c7c61f5ebeb3126d0 (commit)
      from  37d5ac6378c306275775b36ad776ba4de6746e10 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9cac49caeee7990c07064bfb09555c68ed2d2516
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jun 17 09:28:02 2011 +0100

    build: pass correct flags to jimtcl during make distcheck
    
    This is only for the case of a make distcheck.
    During a normal release build these flags will be created by configure.gnu
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/Makefile.am b/Makefile.am
index b31bcea..2d07552 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2,6 +2,9 @@
 # have all needed files, that a GNU package needs
 AUTOMAKE_OPTIONS = gnu 1.6
 
+# make sure we pass the correct jimtcl flags to distcheck
+DISTCHECK_CONFIGURE_FLAGS = --with-jim-ext=nvp --disable-lineedit
+
 nobase_dist_pkgdata_DATA = \
 	contrib/libdcc/dcc_stdio.c \
 	contrib/libdcc/dcc_stdio.h \

commit 3428035a7e0890a319f40a5c7c61f5ebeb3126d0
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jun 17 09:26:18 2011 +0100

    build: add missing files from dist release
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 2717dc5..d8a71e2 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -66,7 +66,8 @@ noinst_HEADERS = \
 	minidriver.h \
 	jtag.h \
 	minidriver/minidriver_imp.h \
-	minidummy/jtag_minidriver.h
+	minidummy/jtag_minidriver.h \
+	swd.h
 
 EXTRA_DIST = startup.tcl
 
diff --git a/src/rtos/Makefile.am b/src/rtos/Makefile.am
index fba9d47..6f17a5f 100644
--- a/src/rtos/Makefile.am
+++ b/src/rtos/Makefile.am
@@ -22,10 +22,9 @@ include $(top_srcdir)/common.mk
 
 METASOURCES = AUTO
 noinst_LTLIBRARIES = librtos.la
-noinst_HEADERS = rtos.h
+noinst_HEADERS = rtos.h rtos_standard_stackings.h rtos_ecos_stackings.h 
 librtos_la_SOURCES = rtos.c rtos_standard_stackings.c rtos_ecos_stackings.c FreeRTOS.c ThreadX.c eCos.c
 
-
 librtos_la_CFLAGS =
 if IS_MINGW
 # FD_* macros are sloppy with their signs on MinGW32 platform
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index eb1e6db..02bf0f4 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -157,7 +157,12 @@ noinst_HEADERS = \
 	target_request.h \
 	trace.h \
 	xscale.h \
-	xscale_debug.h
+	xscale_debug.h \
+	smp.h \
+	avr32_ap7k.h \
+	avr32_jtag.h \
+	avr32_mem.h \
+	avr32_regs.h
 
 nobase_dist_pkglib_DATA =
 nobase_dist_pkglib_DATA += ecos/at91eb40a.elf

-----------------------------------------------------------------------

Summary of changes:
 Makefile.am            |    3 +++
 src/jtag/Makefile.am   |    3 ++-
 src/rtos/Makefile.am   |    3 +--
 src/target/Makefile.am |    7 ++++++-
 4 files changed, 12 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Jun 17 13:56:37 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri, 17 Jun 2011 11:56:37 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-927-ge7c611d
Message-ID: <mailman.111.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e7c611deeac63e585eb61d6c4cdb54d078c2c579 (commit)
       via  16cbe1216a17708fb40ebba84a359c845c263870 (commit)
      from  9cac49caeee7990c07064bfb09555c68ed2d2516 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e7c611deeac63e585eb61d6c4cdb54d078c2c579
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jun 17 12:22:37 2011 +0100

    build: do not included generated files in distribution
    
    We have to use this method as automake seems to ignore nodist_ on libs.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/Makefile.am b/src/Makefile.am
index 60d1189..e3adaad 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -130,7 +130,10 @@ startup_tcl.c: startup.tcl $(BIN2C)
 # add startup_tcl.c to make clean list
 CLEANFILES = startup.tcl startup_tcl.c
 
-
+# we do not want generated file in the dist
+dist-hook:
+	rm -f $(distdir)/startup_tcl.c
+	
 MAINTAINERCLEANFILES = $(srcdir)/Makefile.in
 
 # The "quick" target builds executables & reinstalls the executables

commit 16cbe1216a17708fb40ebba84a359c845c263870
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Jun 17 12:21:01 2011 +0100

    build: add missing files to make dist
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/Makefile.am b/Makefile.am
index 2d07552..63ac5a1 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -21,8 +21,14 @@ endif
 SUBDIRS += src doc
 
 EXTRA_DIST = \
+	BUGS \
+	HACKING \
+	NEWTAPS \
+	PATCHES.txt \
+	README.Win32 \
 	Doxyfile.in \
-	tools/logger.pl
+	tools/logger.pl \
+	contrib/loaders
 
 libtool: $(LIBTOOL_DEPS)
 	$(SHELL) ./config.status --recheck
@@ -78,7 +84,6 @@ install-data-hook:
 uninstall-hook:
 	rm -rf $(DESTDIR)$(pkgdatadir)/scripts
 
-
 distclean-local:
 	rm -rf Doxyfile doxygen
 
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 8e8e0d1..6759ed5 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -1,7 +1,8 @@
 info_TEXINFOS = openocd.texi
 openocd_TEXINFOS = fdl.texi
 man_MANS = openocd.1
-EXTRA_DIST = openocd.1
+EXTRA_DIST = openocd.1 \
+	INSTALL.txt
 
 dist-hook:
 	mkdir $(distdir)/manual
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 02bf0f4..27ad054 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -157,7 +157,6 @@ noinst_HEADERS = \
 	target_request.h \
 	trace.h \
 	xscale.h \
-	xscale_debug.h \
 	smp.h \
 	avr32_ap7k.h \
 	avr32_jtag.h \

-----------------------------------------------------------------------

Summary of changes:
 Makefile.am            |    9 +++++++--
 doc/Makefile.am        |    3 ++-
 src/Makefile.am        |    5 ++++-
 src/target/Makefile.am |    1 -
 4 files changed, 13 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jun 24 11:01:56 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 24 Jun 2011 09:01:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-928-g37aaa28
Message-ID: <mailman.112.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  37aaa28292baee3592492933beb49d5e8884aa14 (commit)
      from  e7c611deeac63e585eb61d6c4cdb54d078c2c579 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 37aaa28292baee3592492933beb49d5e8884aa14
Author: Drasko DRASKOVIC <drasko.draskovic at gmail.com>
Date:   Wed Jun 22 12:45:21 2011 +0200

    Fix load_image for ELF with all p_paddr set to zero
    
    So far image_load command tries to load ELF binaries to address
    discovered by reading p_paddr member of a Program header of an ELF
    segment.
    
    However, ELF specifications says for p_paddr : ...Because System V
    ignores physical addressing for application programs, this member has
    unspecified contents for executable files and shared objects.
    
    ARM ELF specifiaction goes even further, demanding that this member
    be set to zero, using the p_vaddr as a segment load address.
    
    To avoid the cases to wrong addr where p_paddr is zero,
    we are now using p_vaddr to as a load destination in case that *all*
    p_paddr == 0. Basically, this patch re-implements the approach present in
    BDF's elf.c, which is used by GDB also (so that we can be consistent).

diff --git a/src/target/image.c b/src/target/image.c
index 454fc6c..21ce11f 100644
--- a/src/target/image.c
+++ b/src/target/image.c
@@ -396,6 +396,7 @@ static int image_elf_read_headers(struct image *image)
 	size_t read_bytes;
 	uint32_t i,j;
 	int retval;
+	uint32_t nload,load_to_vaddr=0;
 
 	elf->header = malloc(sizeof(Elf32_Ehdr));
 
@@ -471,6 +472,26 @@ static int image_elf_read_headers(struct image *image)
 	for (i = 0;i < elf->segment_count;i++)
 		if ((field32(elf, elf->segments[i].p_type) == PT_LOAD) && (field32(elf, elf->segments[i].p_filesz) != 0))
 			image->num_sections++;
+
+	/**
+	 * some ELF linkers produce binaries with *all* the program header
+	 * p_paddr fields zero (there can be however one loadable segment
+	 * that has valid physical address 0x0).
+	 * If we have such a binary with more than
+	 * one PT_LOAD header, then use p_vaddr instead of p_paddr
+	 * (ARM ELF standard demands p_paddr = 0 anyway, and BFD
+	 * library uses this approach to workaround zero-initialized p_paddrs
+	 * when obtaining lma - look at elf.c of BDF)
+	 */
+	for (nload = 0, i = 0; i < elf->segment_count; i++)
+		if (elf->segments[i].p_paddr != 0)
+			break;
+		else if ((field32(elf, elf->segments[i].p_type) == PT_LOAD) && (field32(elf, elf->segments[i].p_memsz) != 0))
+			++nload;
+
+	if (i >= elf->segment_count && nload > 1)
+		load_to_vaddr = 1;
+
 	/* alloc and fill sections array with loadable segments */
 	image->sections = malloc(image->num_sections * sizeof(struct imagesection));
 	for (i = 0,j = 0;i < elf->segment_count;i++)
@@ -478,7 +499,10 @@ static int image_elf_read_headers(struct image *image)
 		if ((field32(elf, elf->segments[i].p_type) == PT_LOAD) && (field32(elf, elf->segments[i].p_filesz) != 0))
 		{
 			image->sections[j].size = field32(elf,elf->segments[i].p_filesz);
-			image->sections[j].base_address = field32(elf,elf->segments[i].p_paddr);
+			if (load_to_vaddr)
+				image->sections[j].base_address = field32(elf,elf->segments[i].p_vaddr);
+			else
+				image->sections[j].base_address = field32(elf,elf->segments[i].p_paddr);
 			image->sections[j].private = &elf->segments[i];
 			image->sections[j].flags = field32(elf,elf->segments[i].p_flags);
 			j++;

-----------------------------------------------------------------------

Summary of changes:
 src/target/image.c |   26 +++++++++++++++++++++++++-
 1 files changed, 25 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Jun 26 17:47:46 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 26 Jun 2011 15:47:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-938-g5e2637a
Message-ID: <mailman.113.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5e2637a4e0996f993916dcc24fa34afa4f3eaeda (commit)
       via  b851a4949b991a9e5189b9b9276c758a63740426 (commit)
       via  1aba8205191a4f5af1aa7aa3465a8abc86f4f9d5 (commit)
       via  5141ab3e691b63e080e3620d82e0e3a1953fb968 (commit)
       via  29f6f6ae5f5cd83cb1cdff04a98bd6232e87a36b (commit)
       via  379abb9167d30048c8fa4ba66ebef766b69b6142 (commit)
       via  b4bbe33d17979e90b54d81b80831f385479c9bbf (commit)
       via  f279e54347914ac319405c35aca338b34b2e6728 (commit)
       via  3c3f3c42472faa0414a8096133cb9b8a9ab37c86 (commit)
       via  03e4ae8481953613a3f562ef9b69bd77b624ca50 (commit)
      from  37aaa28292baee3592492933beb49d5e8884aa14 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5e2637a4e0996f993916dcc24fa34afa4f3eaeda
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:52:33 2011 +0200

    Add description for configure argument "--enable-ulink" to README file

diff --git a/README b/README
index fd0bd33..7c1b5b2 100644
--- a/README
+++ b/README
@@ -236,6 +236,8 @@ options may be available there:
                           Programmer
   --enable-rlink          Enable building support for the Raisonance RLink
                           JTAG Programmer
+  --enable-ulink          Enable building support for the Keil ULINK JTAG
+                          Programmer
   --enable-usbprog        Enable building support for the usbprog JTAG
                           Programmer
   --enable-vsllink        Enable building support for the Versaloon-Link JTAG

commit b851a4949b991a9e5189b9b9276c758a63740426
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:52:17 2011 +0200

    Add OpenULINK driver files generated by SDCC to .gitignore

diff --git a/.gitignore b/.gitignore
index 2812304..e4ac7f8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -14,6 +14,17 @@
 src/jtag/minidriver_imp.h
 src/jtag/jtag_minidriver.h
 
+# OpenULINK driver files generated by SDCC
+src/jtag/drivers/OpenULINK/*.rel
+src/jtag/drivers/OpenULINK/*.asm
+src/jtag/drivers/OpenULINK/*.lst
+src/jtag/drivers/OpenULINK/*.sym
+src/jtag/drivers/OpenULINK/*.map
+src/jtag/drivers/OpenULINK/*.mem
+src/jtag/drivers/OpenULINK/*.lnk
+src/jtag/drivers/OpenULINK/*.ihx
+src/jtag/drivers/OpenULINK/*.rst
+
 # editor files
 *.swp
 

commit 1aba8205191a4f5af1aa7aa3465a8abc86f4f9d5
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:51:46 2011 +0200

    Add -DPKGLIBDIR to AM_CPPFLAGS.
    
    This is required so the OpenULINK driver knows the install location of the OpenULINK
    firmware image.

diff --git a/common.mk b/common.mk
index c1a5e6c..20b96bd 100644
--- a/common.mk
+++ b/common.mk
@@ -2,7 +2,8 @@
 # common flags used in openocd build
 AM_CPPFLAGS = -I$(top_srcdir)/src \
 			  -I$(top_builddir)/src \
-			  -DPKGDATADIR=\"$(pkgdatadir)\"
+			  -DPKGDATADIR=\"$(pkgdatadir)\" \
+			  -DPKGLIBDIR=\"$(pkglibdir)\"
 
 if INTERNAL_JIMTCL
 AM_CPPFLAGS += -I$(top_srcdir)/jimtcl \

commit 5141ab3e691b63e080e3620d82e0e3a1953fb968
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:51:16 2011 +0200

    Include ULINK driver in src/jtag/drivers/Makefile.am
    
    A new variable "nobase_dist_pkglib_DATA" is introduced to install
    the OpenULINK firmware image to $PREFIX/lib/openocd/OpenULINK/ulink_firmware.hex
    
    Also, the variable "EXTRA_DIST" is used to include the OpenULINK firmware source
    in the OpenOCD source distribution.

diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index f3d5ab0..1e52358 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -5,6 +5,12 @@ noinst_LTLIBRARIES = libocdjtagdrivers.la
 libocdjtagdrivers_la_SOURCES = \
 	$(DRIVERFILES)
 
+nobase_dist_pkglib_DATA =
+
+ULINK_FIRMWARE = $(srcdir)/OpenULINK
+
+EXTRA_DIST = $(ULINK_FIRMWARE)
+
 DRIVERFILES =
 
 # Standard Driver: common files
@@ -56,6 +62,10 @@ endif
 if RLINK
 DRIVERFILES += rlink.c rlink_speed_table.c
 endif
+if ULINK
+DRIVERFILES += ulink.c
+nobase_dist_pkglib_DATA += $(ULINK_FIRMWARE)/ulink_firmware.hex
+endif
 if VSLLINK
 DRIVERFILES += vsllink.c
 endif

commit 29f6f6ae5f5cd83cb1cdff04a98bd6232e87a36b
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:50:54 2011 +0200

    Include ULINK driver in src/Makefile.am

diff --git a/src/Makefile.am b/src/Makefile.am
index e3adaad..1e7af9c 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -85,6 +85,9 @@ else
 if RLINK
 LIBUSB = -lusb
 else
+if ULINK
+LIBUSB = -lusb
+else
 if VSLLINK
 LIBUSB = -lusb
 else
@@ -93,6 +96,7 @@ endif
 endif
 endif
 endif
+endif
 
 libopenocd_la_LIBADD = \
 	$(top_builddir)/src/xsvf/libxsvf.la \

commit 379abb9167d30048c8fa4ba66ebef766b69b6142
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:50:35 2011 +0200

    Include ULINK driver in configure.in

diff --git a/configure.in b/configure.in
index cb62c85..de74ffa 100644
--- a/configure.in
+++ b/configure.in
@@ -472,6 +472,10 @@ AC_ARG_ENABLE(rlink,
   AS_HELP_STRING([--enable-rlink], [Enable building support for the Raisonance RLink JTAG Programmer]),
   [build_rlink=$enableval], [build_rlink=no])
 
+AC_ARG_ENABLE(ulink,
+  AS_HELP_STRING([--enable-ulink], [Enable building support for the Keil ULINK JTAG Programmer]),
+  [build_ulink=$enableval], [build_ulink=no])
+
 AC_ARG_ENABLE(arm-jtag-ew,
   AS_HELP_STRING([--enable-arm-jtag-ew], [Enable building support for the Olimex ARM-JTAG-EW Programmer]),
   [build_armjtagew=$enableval], [build_armjtagew=no])
@@ -750,6 +754,12 @@ else
   AC_DEFINE(BUILD_RLINK, 0, [0 if you don't want the RLink JTAG driver.])
 fi
 
+if test $build_ulink = yes; then
+  AC_DEFINE(BUILD_ULINK, 1, [1 if you want the ULINK JTAG driver.])
+else
+  AC_DEFINE(BUILD_ULINK, 0, [0 if you don't want the ULINK JTAG driver.])
+fi
+
 if test $build_armjtagew = yes; then
   AC_DEFINE(BUILD_ARMJTAGEW, 1, [1 if you want the ARM-JTAG-EW JTAG driver.])
 else
@@ -1025,7 +1035,7 @@ fi
 # check for usb.h when a driver will require it
 build_usb=no
 if test $build_jlink = yes -o $build_vsllink = yes -o $build_usbprog = yes -o \
-  $build_rlink = yes -o $build_armjtagew = yes
+  $build_rlink = yes -o $build_ulink = yes -o $build_armjtagew = yes
 then
   AC_CHECK_HEADERS([usb.h],[],
   [AC_MSG_ERROR([usb.h is required to build some OpenOCD driver(s)])])
@@ -1056,6 +1066,7 @@ AM_CONDITIONAL(OOCD_TRACE, test $build_oocd_trace = yes)
 AM_CONDITIONAL(JLINK, test $build_jlink = yes)
 AM_CONDITIONAL(VSLLINK, test $build_vsllink = yes)
 AM_CONDITIONAL(RLINK, test $build_rlink = yes)
+AM_CONDITIONAL(ULINK, test $build_ulink = yes)
 AM_CONDITIONAL(ARMJTAGEW, test $build_armjtagew = yes)
 AM_CONDITIONAL(BUSPIRATE, test $build_buspirate = yes)
 AM_CONDITIONAL(USB, test $build_usb = yes)

commit b4bbe33d17979e90b54d81b80831f385479c9bbf
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:50:18 2011 +0200

    Add ULINK interface script

diff --git a/tcl/interface/ulink.cfg b/tcl/interface/ulink.cfg
new file mode 100644
index 0000000..491ac7a
--- /dev/null
+++ b/tcl/interface/ulink.cfg
@@ -0,0 +1,5 @@
+#
+# Keil ULINK running OpenULINK firmware.
+#
+
+interface ulink

commit f279e54347914ac319405c35aca338b34b2e6728
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:49:24 2011 +0200

    Include ULINK driver in src/jtag/interfaces.c

diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index 8d13a08..dbc69d0 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -88,6 +88,9 @@ extern struct jtag_interface vsllink_interface;
 #if BUILD_RLINK == 1
 extern struct jtag_interface rlink_interface;
 #endif
+#if BUILD_ULINK == 1
+extern struct jtag_interface ulink_interface;
+#endif
 #if BUILD_ARMJTAGEW == 1
 extern struct jtag_interface armjtagew_interface;
 #endif
@@ -151,6 +154,9 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_RLINK == 1
 		&rlink_interface,
 #endif
+#if BUILD_ULINK == 1
+		&ulink_interface,
+#endif
 #if BUILD_ARMJTAGEW == 1
 		&armjtagew_interface,
 #endif

commit 3c3f3c42472faa0414a8096133cb9b8a9ab37c86
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:49:49 2011 +0200

    Add OpenULINK firmware
    
    Build requires SDCC, the Small Device C Compiler.

diff --git a/src/jtag/drivers/OpenULINK/Makefile b/src/jtag/drivers/OpenULINK/Makefile
new file mode 100644
index 0000000..c0e3435
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/Makefile
@@ -0,0 +1,90 @@
+############################################################################
+#    Copyright (C) 2011 by Martin Schmoelzer                               #
+#    <martin.schmoelzer at student.tuwien.ac.at>                              #
+#                                                                          #
+#    This program is free software; you can redistribute it and/or modify  #
+#    it under the terms of the GNU General Public License as published by  #
+#    the Free Software Foundation; either version 2 of the License, or     #
+#    (at your option) any later version.                                   #
+#                                                                          #
+#    This program is distributed in the hope that it will be useful,       #
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of        #
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
+#    GNU General Public License for more details.                          #
+#                                                                          #
+#    You should have received a copy of the GNU General Public License     #
+#    along with this program; if not, write to the                         #
+#    Free Software Foundation, Inc.,                                       #
+#    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             #
+############################################################################
+
+# Define the name of our tools. Some distributions (e. g. Fedora) prefix
+# the SDCC executables, change this accordingly!
+PREFIX =
+
+# Small Device C Compiler: http://sdcc.sourceforge.net/
+CC = $(PREFIX)-sdcc
+
+# 8051 assembler, part of the SDCC software package.
+AS = $(PREFIX)-sdas8051
+
+# SDCC produces quite messy Intel HEX files. This tool is be used to re-format
+# those files. It is not required for the firmware download functionality in
+# the OpenOCD driver, but the resulting file is smaller.
+PACKIHX = $(PREFIX)-packihx
+
+# GNU binutils size. Used to print the size of the IHX file generated by SDCC.
+SIZE = size
+
+# Source and header directories.
+SRC_DIR     = src
+INCLUDE_DIR = include
+
+CODE_SIZE = 0x1B00
+
+# Starting address of __xdata variables. Since the OpenULINK firmware does not
+# use any of the isochronous interrupts, we can use the isochronous buffer space
+# as XDATA memory.
+XRAM_LOC  = 0x2000
+XRAM_SIZE = 0x0800
+
+CFLAGS  = --std-sdcc99 --opt-code-size --model-small
+LDFLAGS = --code-loc 0x0000 --code-size $(CODE_SIZE) --xram-loc $(XRAM_LOC) \
+          --xram-size $(XRAM_SIZE) --iram-size 256 --model-small
+
+# list of base object files
+OBJECTS = main.rel usb.rel protocol.rel jtag.rel delay.rel USBJmpTb.rel
+HEADERS = $(INCLUDE_DIR)/main.h         \
+          $(INCLUDE_DIR)/usb.h          \
+          $(INCLUDE_DIR)/protocol.h     \
+          $(INCLUDE_DIR)/jtag.h         \
+          $(INCLUDE_DIR)/delay.h        \
+          $(INCLUDE_DIR)/reg_ezusb.h    \
+          $(INCLUDE_DIR)/io.h           \
+          $(INCLUDE_DIR)/msgtypes.h     \
+          $(INCLUDE_DIR)/shorttypes.h
+
+# Disable all built-in rules.
+.SUFFIXES:
+
+# Targets which are executed even when identically named file is present.
+.PHONY: all, clean
+
+all: ulink_firmware.ihx
+	$(SIZE) ulink_firmware.ihx
+
+ulink_firmware.ihx: $(OBJECTS)
+	$(CC) -mmcs51 $(LDFLAGS) -o $@ $^
+
+# Rebuild every C module (there are only 5 of them) if any header changes.
+%.rel: $(SRC_DIR)/%.c $(HEADERS)
+	$(CC) -c $(CFLAGS) -mmcs51 -I$(INCLUDE_DIR) -o $@ $<
+
+%.rel: $(SRC_DIR)/%.a51
+	$(AS) -lsgo $@ $<
+
+clean:
+	rm -f *.asm *.lst *.rel *.rst *.sym *.ihx *.lnk *.map *.mem
+
+hex: ulink_firmware.ihx
+	$(PACKIHX) ulink_firmware.ihx > ulink_firmware.hex
diff --git a/src/jtag/drivers/OpenULINK/README b/src/jtag/drivers/OpenULINK/README
new file mode 100644
index 0000000..445d770
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/README
@@ -0,0 +1,34 @@
+This is the OpenULINK firmware for the Keil ULINK JTAG adapter.
+
+The main components of the Keil ULINK adapter are:
+- Cypress EZ-USB microcontroller: enhanced 8051 CPU + USB core (1.1 Full-Speed)
+- SRAM memory chip
+- Level shifters to support different JTAG signal voltage levels
+- Pin headers for various JTAG pin assignments
+
+This firmware can only be run on the ORIGINAL Keil ULINK adapter, not on the
+newer ULINK2, ULINK-ME or ULINK-PRO, as these adapters are based on different
+hardware.
+
+To compile the firmware, the SDCC compiler package is required. Most Linux
+distributions include SDCC in their official package repositories. The SDCC
+source code can be found at http://sdcc.sourceforge.net/
+Simply type "make hex" in the OpenULINK directory to compile the firmware.
+"make clean" will remove all generated files except the Intel HEX file required
+for downloading the firmware to the ULINK adapter.
+
+Note that the EZ-USB microcontroller does not have on-chip flash, nor does the
+Keil ULINK include on-board memory to store the firmware program of the EZ-USB.
+Instead, upon initial connection of the ULINK adapter to the host PC via USB,
+the EZ-USB core has enough intelligence to act as a stand-alone USB device,
+responding to USB control requests and allowing firmware download via a special
+VENDOR-type control request. Then, the EZ-USB microcontroller simulates a
+disconnect and re-connect to the USB bus. It may take up to two seconds for the
+host to recognize the newly connected device before OpenOCD can proceed to
+execute JTAG commands. This delay is only visible when OpenOCD first uses a
+blank (unconfigured) ULINK device.
+
+Once the user disconnects the ULINK adapter, all its memory contents are lost
+and the firmware download process has to be executed again. This also maintains
+compatibility with the original Keil uVision IDE, which will happily download
+its own firmware image to a blank ULINK adapter.
diff --git a/src/jtag/drivers/OpenULINK/include/common.h b/src/jtag/drivers/OpenULINK/include/common.h
new file mode 100644
index 0000000..f4c966c
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/common.h
@@ -0,0 +1,26 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __COMMON_H
+#define __COMMON_H
+
+#define DIV_ROUND_UP(m, n)  (((m) + (n) - 1) / (n))
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/delay.h b/src/jtag/drivers/OpenULINK/include/delay.h
new file mode 100644
index 0000000..3dfaf35
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/delay.h
@@ -0,0 +1,34 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __DELAY_H
+#define __DELAY_H
+
+#include "shorttypes.h"
+
+#define NOP  {__asm nop __endasm;}
+
+void delay_5us(void);
+void delay_1ms(void);
+
+void delay_us(u16 delay);
+void delay_ms(u16 delay);
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/io.h b/src/jtag/drivers/OpenULINK/include/io.h
new file mode 100644
index 0000000..f7119b9
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/io.h
@@ -0,0 +1,125 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __IO_H
+#define __IO_H
+
+#include "reg_ezusb.h"
+
+/***************************************************************************
+ *  JTAG Signals:                                                          *
+ ***************************************************************************
+ * TMS ....... Test Mode Select                                            *
+ * TCK ....... Test Clock                                                  *
+ * TDI ....... Test Data Input  (from device point of view, not JTAG       *
+ *             adapter point of view!)                                     *
+ * TDO ....... Test Data Output (from device point of view, not JTAG       *
+ *             adapter point of view!)                                     *
+ * TRST ...... Test Reset: Used to reset the TAP Finite State Machine      *
+ *             into the Test Logic Reset state                             *
+ * RTCK ...... Return Test Clock                                           *
+ * OCDSE ..... Enable/Disable OCDS interface (Infineon specific) - shared  *
+ *             with /JEN                                                   *
+ * TRAP ...... Trap Condition (Infineon specific) - shared with TSTAT      *
+ * BRKIN ..... Hardware Break-In (Infineon specific)                       *
+ * BRKOUT .... Hardware Break-Out (Infineon specific)                      *
+ * /JEN ...... JTAG-Enable (STMicroelectronics specific) - shared          *
+ *             with OCDSE                                                  *
+ * TSTAT ..... JTAG ISP Status (STMicroelectronics specific) - shared      *
+ *             with TRAP                                                   *
+ * RESET ..... Chip Reset (STMicroelectronics specific)                    *
+ * /TERR ..... JTAG ISP Error (STMicroelectronics specific) - shared       *
+ *             with BRKOUT                                                 *
+ ***************************************************************************/
+
+/* PORT A */
+#define PIN_U_OE      OUTA0
+// PA1 Not Connected
+#define PIN_OE        OUTA2
+// PA3 Not Connected
+#define PIN_RUN_LED   OUTA4
+#define PIN_TDO       PINA5
+#define PIN_BRKOUT    PINA6
+#define PIN_COM_LED   OUTA7
+
+
+/* PORT B */
+#define PIN_TDI       OUTB0
+#define PIN_TMS       OUTB1
+#define PIN_TCK       OUTB2
+#define PIN_TRST      OUTB3
+#define PIN_BRKIN     OUTB4
+#define PIN_RESET     OUTB5
+#define PIN_OCDSE     OUTB6
+#define PIN_TRAP      PINB7
+
+/* JTAG Signals with direction 'OUT' on port B */
+#define MASK_PORTB_DIRECTION_OUT (PIN_TDI | PIN_TMS | PIN_TCK | PIN_TRST | PIN_BRKIN | PIN_RESET | PIN_OCDSE)
+
+/* PORT C */
+#define PIN_RXD0      PINC0
+#define PIN_TXD0      OUTC1
+#define PIN_RESET_2   PINC2
+// PC3 Not Connected
+// PC4 Not Connected
+#define PIN_RTCK      PINC5
+#define PIN_WR        OUTC6
+// PC7 Not Connected
+
+/* LED Macros */
+#define SET_RUN_LED()     OUTA &= ~PIN_RUN_LED
+#define CLEAR_RUN_LED()   OUTA |=  PIN_RUN_LED
+
+#define SET_COM_LED()     OUTA &= ~PIN_COM_LED
+#define CLEAR_COM_LED()   OUTA |=  PIN_COM_LED
+
+/* JTAG Pin Macros */
+#define GET_TMS()         (PINSB & PIN_TMS)
+#define GET_TCK()         (PINSB & PIN_TCK)
+
+#define GET_TDO()         (PINSA & PIN_TDO)
+#define GET_BRKOUT()      (PINSA & PIN_BRKOUT)
+#define GET_TRAP()        (PINSB & PIN_TRAP)
+#define GET_RTCK()        (PINSC & PIN_RTCK)
+
+#define SET_TMS_HIGH()    OUTB |=  PIN_TMS
+#define SET_TMS_LOW()     OUTB &= ~PIN_TMS
+
+#define SET_TCK_HIGH()    OUTB |=  PIN_TCK
+#define SET_TCK_LOW()     OUTB &= ~PIN_TCK
+
+#define SET_TDI_HIGH()    OUTB |=  PIN_TDI
+#define SET_TDI_LOW()     OUTB &= ~PIN_TDI
+
+/* TRST and RESET are low-active and inverted by hardware. SET_HIGH de-asserts
+ * the signal (enabling reset), SET_LOW asserts the signal (disabling reset) */
+#define SET_TRST_HIGH()   OUTB |=  PIN_TRST
+#define SET_TRST_LOW()    OUTB &= ~PIN_TRST
+
+#define SET_RESET_HIGH()  OUTB |=  PIN_RESET
+#define SET_RESET_LOW()   OUTB &= ~PIN_RESET
+
+#define SET_OCDSE_HIGH()  OUTB |=  PIN_OCDSE
+#define SET_OCDSE_LOW()   OUTB &= ~PIN_OCDSE
+
+#define SET_BRKIN_HIGH()  OUTB |=  PIN_BRKIN
+#define SET_BRKIN_LOW()   OUTB &= ~PIN_BRKIN
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/jtag.h b/src/jtag/drivers/OpenULINK/include/jtag.h
new file mode 100644
index 0000000..93ecfb0
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/jtag.h
@@ -0,0 +1,46 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __JTAG_H
+#define __JTAG_H
+
+#include "shorttypes.h"
+
+#define NOP {__asm nop __endasm;}
+
+void jtag_scan_in(u8 out_offset, u8 in_offset);
+void jtag_scan_out(u8 out_offset);
+void jtag_scan_io(u8 out_offset, u8 in_offset);
+
+void jtag_slow_scan_in(u8 scan_size_bytes, u8 tdo_index, u8 scan_options);
+void jtag_slow_scan_out(u8 scan_size_bytes, u8 tdi_index, u8 scan_options);
+void jtag_slow_scan_io(u8 scan_size_bytes, u8 tdi_index, u8 tdo_index,
+    u8 scan_options);
+
+void jtag_clock_tck(u16 count);
+void jtag_clock_tms(u8 count, u8 sequence);
+void jtag_slow_clock_tms(u8 count, u8 sequence);
+
+u16  jtag_get_signals(void);
+void jtag_set_signals(u8 low, u8 high);
+
+void jtag_configure_tck_delay(u8 scan, u8 tck, u8 tms);
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/main.h b/src/jtag/drivers/OpenULINK/include/main.h
new file mode 100644
index 0000000..08d748c
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/main.h
@@ -0,0 +1,26 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __MAIN_H
+#define __MAIN_H
+
+void io_init(void);
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/msgtypes.h b/src/jtag/drivers/OpenULINK/include/msgtypes.h
new file mode 100644
index 0000000..e3afb67
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/msgtypes.h
@@ -0,0 +1,187 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/**
+ * @file Definition of the commands supported by the OpenULINK firmware.
+ *
+ * Basically, two types of commands can be distinguished:
+ *  - Commands with fixed payload size
+ *  - Commands with variable payload size
+ *
+ * SCAN commands (in all variations) carry payloads of variable size, all
+ * other commands carry payloads of fixed size.
+ *
+ * In the case of SCAN commands, the payload size (n) is calculated by
+ * dividing the scan_size_bits variable by 8, rounding up the result.
+ *
+ * Offset zero always contains the command ID.
+ *
+ ****************************************************************************
+ * CMD_SCAN_IN, CMD_SLOW_SCAN_IN:                                           *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: scan_size_bytes                                                *
+ * offset 2: bits_last_byte                                                 *
+ * offset 3: tms_count_start + tms_count_end                                *
+ * offset 4: tms_sequence_start                                             *
+ * offset 5: tms_sequence_end                                               *
+ *                                                                          *
+ * IN:                                                                      *
+ * offset 0..n: TDO data                                                    *
+ ****************************************************************************
+ * CMD_SCAN_OUT, CMD_SLOW_SCAN_OUT:                                         *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: scan_size_bytes                                                *
+ * offset 2: bits_last_byte                                                 *
+ * offset 3: tms_count_start + tms_count_end                                *
+ * offset 4: tms_sequence_start                                             *
+ * offset 5: tms_sequence_end                                               *
+ * offset 6..x: TDI data                                                    *
+ ****************************************************************************
+ * CMD_SCAN_IO, CMD_SLOW_SCAN_IO:                                           *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: scan_size_bytes                                                *
+ * offset 2: bits_last_byte                                                 *
+ * offset 3: tms_count_start + tms_count_end                                *
+ * offset 4: tms_sequence_start                                             *
+ * offset 5: tms_sequence_end                                               *
+ * offset 6..x: TDI data                                                    *
+ *                                                                          *
+ * IN:                                                                      *
+ * offset 0..n: TDO data                                                    *
+ ****************************************************************************
+ * CMD_CLOCK_TMS, CMD_SLOW_CLOCK_TMS:                                       *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: tms_count                                                      *
+ * offset 2: tms_sequence                                                   *
+ ****************************************************************************
+ * CMD_CLOCK_TCK:                                                           *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: low byte of tck_count                                          *
+ * offset 2: high byte of tck_count                                         *
+ ****************************************************************************
+ * CMD_CLOCK_SLEEP_US:                                                      *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: low byte of sleep_us                                           *
+ * offset 2: high byte of sleep_us                                          *
+ ****************************************************************************
+ * CMD_CLOCK_SLEEP_MS:                                                      *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: low byte of sleep_ms                                           *
+ * offset 2: high byte of sleep_ms                                          *
+ ****************************************************************************
+ * CMD_GET_SIGNALS:                                                         *
+ *                                                                          *
+ * IN:                                                                      *
+ * offset 0: current state of input signals                                 *
+ * offset 1: current state of output signals                                *
+ ****************************************************************************
+ * CMD_SET_SIGNALS:                                                         *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: signals that should be de-asserted                             *
+ * offset 2: signals that should be asserted                                *
+ ****************************************************************************
+ * CMD_CONFIGURE_TCK_FREQ:                                                  *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: delay value for scan functions                                 *
+ * offset 2: delay value for clock_tck function                             *
+ * offset 3: delay value for clock_tms function                             *
+ ****************************************************************************
+ * CMD_SET_LEDS:                                                            *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: LED states:                                                    *
+ *           Bit 0: turn COM LED on                                         *
+ *           Bit 1: turn RUN LED on                                         *
+ *           Bit 2: turn COM LED off                                        *
+ *           Bit 3: turn RUN LED off                                        *
+ *           Bits 7..4: Reserved                                            *
+ ****************************************************************************
+ * CMD_TEST:                                                                *
+ *                                                                          *
+ * OUT:                                                                     *
+ * offset 1: unused dummy value                                             *
+ ****************************************************************************
+ */
+
+#ifndef __MSGTYPES_H
+#define __MSGTYPES_H
+
+/*
+ * Command IDs:
+ *
+ * Bits 7..6: Reserved, should always be zero
+ * Bits 5..0: Command ID. There are 62 usable IDs. Of this 63 available IDs,
+ *            the IDs 0x00..0x1F are commands with variable payload size,
+ *            the IDs 0x20..0x3F are commands with fixed payload size.
+ */
+
+#define CMD_ID_MASK             0x3F
+
+/* Commands with variable payload size */
+#define CMD_SCAN_IN             0x00
+#define CMD_SLOW_SCAN_IN        0x01
+#define CMD_SCAN_OUT            0x02
+#define CMD_SLOW_SCAN_OUT       0x03
+#define CMD_SCAN_IO             0x04
+#define CMD_SLOW_SCAN_IO        0x05
+
+/* Commands with fixed payload size */
+#define CMD_CLOCK_TMS           0x20
+#define CMD_SLOW_CLOCK_TMS      0x21
+#define CMD_CLOCK_TCK           0x22
+#define CMD_SLEEP_US            0x23
+#define CMD_SLEEP_MS            0x24
+#define CMD_GET_SIGNALS         0x25
+#define CMD_SET_SIGNALS         0x26
+#define CMD_CONFIGURE_TCK_FREQ  0x27
+#define CMD_SET_LEDS            0x28
+#define CMD_TEST                0x29
+
+/* JTAG signal definition for jtag_get_signals() -- Input signals! */
+#define SIGNAL_TDO      (1<<0)
+#define SIGNAL_BRKOUT   (1<<1)
+#define SIGNAL_TRAP     (1<<2)
+#define SIGNAL_RTCK     (1<<3)
+
+/* JTAG signal definition for jtag_get_signals() -- Output signals! */
+#define SIGNAL_TDI      (1<<0)
+#define SIGNAL_TMS      (1<<1)
+#define SIGNAL_TCK      (1<<2)
+#define SIGNAL_TRST     (1<<3)
+#define SIGNAL_BRKIN    (1<<4)
+#define SIGNAL_RESET    (1<<5)
+#define SIGNAL_OCDSE    (1<<6)
+
+/* LED definitions for CMD_SET_LEDS and CMD_CLEAR_LEDS commands */
+#define COM_LED_ON      (1<<0)
+#define RUN_LED_ON      (1<<1)
+#define COM_LED_OFF     (1<<2)
+#define RUN_LED_OFF     (1<<3)
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/protocol.h b/src/jtag/drivers/OpenULINK/include/protocol.h
new file mode 100644
index 0000000..2129fc8
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/protocol.h
@@ -0,0 +1,33 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __PROTOCOL_H
+#define __PROTOCOL_H
+
+#include "shorttypes.h"
+#include "common.h"
+#include <stdbool.h>
+
+void execute_set_led_command(void);
+
+bool execute_command(void);
+void command_loop(void);
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/reg_ezusb.h b/src/jtag/drivers/OpenULINK/include/reg_ezusb.h
new file mode 100644
index 0000000..26ee018
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/reg_ezusb.h
@@ -0,0 +1,742 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef REG_EZUSB_H
+#define REG_EZUSB_H
+
+/**
+ * @file All information in this file was taken from the EZ-USB Technical
+ * Reference Manual, Cypress Semiconductor, 3901 North First Street
+ * San Jose, CA 95134 (www.cypress.com).
+ *
+ * The EZ-USB Technical Reference Manual is called "EZ-USB TRM" hereafter.
+ *
+ * The following bit name  definitions differ from those in the EZ-USB TRM:
+ * - All lowercase characters in the EZ-USB TRM bit names have been converted
+ *   to capitals (e. g. "WakeSRC" converted to "WAKESRC").
+ * - CPUCS:  8051RES is named "RES8051".
+ * - ISOCTL: Two MBZ ("Must Be Zero") bits are named "MBZ0" and "MBZ1".
+ * - I2CS: STOP and START bits are preceded by "I2C_"
+ * - INxCS, OUTxCS: the busy and stall bits are named "EPBSY" and "EPSTALL".
+ * - TOGCTL: EZ-USB TRM bit names are preceded by "TOG_".
+ */
+
+/* Compiler-specific definitions of SBIT, SFR, SFRX, ... macros */
+#include <mcs51/compiler.h>
+
+/* Bit vectors */
+#define bmBit0      0x01
+#define bmBit1      0x02
+#define bmBit2      0x04
+#define bmBit3      0x08
+#define bmBit4      0x10
+#define bmBit5      0x20
+#define bmBit6      0x40
+#define bmBit7      0x80
+
+/***************************************************************************/
+/************************ Special Function Registers ***********************/
+/***************************************************************************/
+
+/* See EZ-USB TRM, pp. A-9 - A-10 */
+
+SFR(SP,             0x81);
+SFR(DPL0,           0x82);
+SFR(DPH0,           0x83);
+SFR(DPL1,           0x84);
+SFR(DPL2,           0x85);
+
+SFR(DPS,            0x86);
+  #define SEL       bmBit0
+  // Bit 1 read-only, always reads '0'
+  // Bit 2 read-only, always reads '0'
+  // Bit 3 read-only, always reads '0'
+  // Bit 4 read-only, always reads '0'
+  // Bit 5 read-only, always reads '0'
+  // Bit 6 read-only, always reads '0'
+  // Bit 7 read-only, always reads '0'
+
+SFR(PCON,           0x87);
+  #define IDLE      bmBit0
+  #define STOP      bmBit1
+  #define GF0       bmBit2
+  #define GF1       bmBit3
+  // Bit 4 read-only, always reads '1'
+  // Bit 5 read-only, always reads '1'
+  // Bit 6 unused
+  #define SMOD0     bmBit7
+
+SFR(TCON,           0x88);
+  SBIT(IT0,         0x88, 0);
+  SBIT(IE0,         0x88, 1);
+  SBIT(IT1,         0x88, 2);
+  SBIT(IE1,         0x88, 3);
+  SBIT(TR0,         0x88, 4);
+  SBIT(TF0,         0x88, 5);
+  SBIT(TR1,         0x88, 6);
+  SBIT(TF1,         0x88, 7);
+
+SFR(TMOD,           0x89);
+/* Some bits in this register share the same name in the EZ-USB TRM. Therefore,
+ * we add a '0'/'1' to distinguish them */
+  #define M00       bmBit0
+  #define M01       bmBit1
+  #define CT0       bmBit2
+  #define GATE0     bmBit3
+  #define M10       bmBit4
+  #define M11       bmBit5
+  #define CT1       bmBit6
+  #define GATE1     bmBit7
+
+SFR(TL0,            0x8A);
+SFR(TL1,            0x8B);
+SFR(TH0,            0x8C);
+SFR(TH1,            0x8D);
+
+SFR(CKCON,          0x8E);
+  #define MD0       bmBit0
+  #define MD1       bmBit1
+  #define MD2       bmBit2
+  #define T0M       bmBit3
+  #define T1M       bmBit4
+  #define T2M       bmBit5
+  // Bit 6 unused
+  // Bit 7 unused
+
+SFR(SPC_FNC,        0x8D);
+  #define bmWRS     bmBit0
+  // Bit 1 read-only, always reads '0'
+  // Bit 2 read-only, always reads '0'
+  // Bit 3 read-only, always reads '0'
+  // Bit 4 read-only, always reads '0'
+  // Bit 5 read-only, always reads '0'
+  // Bit 6 read-only, always reads '0'
+  // Bit 7 read-only, always reads '0'
+
+SFR(EXIF,           0x91);
+  // Bit 0 read-only, always reads '0'
+  // Bit 1 read-only, always reads '0'
+  // Bit 2 read-only, always reads '0'
+  // Bit 3 read-only, always reads '1'
+  #define USBINT    bmBit4
+  #define I2CINT    bmBit5
+  #define IE4       bmBit6
+  #define IE5       bmBit7
+
+/* Definition of the _XPAGE register, according to SDCC Compiler User Guide,
+ * Version 3.0.1, Chapter 4, p. 61. Also see EZ-USB TRM, p. 2-4. */
+SFR(MPAGE,          0x92);
+SFR(_XPAGE,         0x92);
+
+SFR(SCON0,          0x98);
+  SBIT(RI_0,        0x98, 0);
+  SBIT(TI_0,        0x98, 1);
+  SBIT(RB8_0,       0x98, 2);
+  SBIT(TB8_0,       0x98, 3);
+  SBIT(REN_0,       0x98, 4);
+  SBIT(SM2_0,       0x98, 5);
+  SBIT(SM1_0,       0x98, 6);
+  SBIT(SM0_0,       0x98, 7);
+
+SFR(SBUF0,          0x99);
+
+SFR(IE,             0xA8);
+  SBIT(EX0,         0xA8, 0);
+  SBIT(ET0,         0xA8, 1);
+  SBIT(EX1,         0xA8, 2);
+  SBIT(ET1,         0xA8, 3);
+  SBIT(ES0,         0xA8, 4);
+  SBIT(ET2,         0xA8, 5);
+  SBIT(ES1,         0xA8, 6);
+  SBIT(EA,          0xA8, 7);
+
+SFR(IP,             0xB8);
+  SBIT(PX0,         0xB8, 0);
+  SBIT(PT0,         0xB8, 1);
+  SBIT(PX1,         0xB8, 2);
+  SBIT(PT1,         0xB8, 3);
+  SBIT(PS0,         0xB8, 4);
+  SBIT(PT2,         0xB8, 5);
+  SBIT(PS1,         0xB8, 6);
+  // Bit 7 read-only, always reads '1'
+
+SFR(SCON1,          0xC0);
+  SBIT(RI_1,        0xC0, 0);
+  SBIT(TI_1,        0xC0, 1);
+  SBIT(RB8_1,       0xC0, 2);
+  SBIT(TB8_1,       0xC0, 3);
+  SBIT(REN_1,       0xC0, 4);
+  SBIT(SM2_1,       0xC0, 5);
+  SBIT(SM1_1,       0xC0, 6);
+  SBIT(SM0_1,       0xC0, 7);
+
+SFR(SBUF1,          0xC1);
+
+SFR(T2CON,          0xC8);
+  SBIT(CPRL2,       0xC8, 0);
+  SBIT(CT2,         0xC8, 1);
+  SBIT(TR2,         0xC8, 2);
+  SBIT(EXEN2,       0xC8, 3);
+  SBIT(TCLK,        0xC8, 4);
+  SBIT(RCLK,        0xC8, 5);
+  SBIT(EXF2,        0xC8, 6);
+  SBIT(TF2,         0xC8, 7);
+
+SFR(RCAP2L,         0xCA);
+SFR(RCAP2H,         0xCB);
+SFR(TL2,            0xCC);
+SFR(TH2,            0xCD);
+
+SFR(PSW,            0xD0);
+  SBIT(P,           0xD0, 0);
+  SBIT(F1,          0xD0, 1);
+  SBIT(OV,          0xD0, 2);
+  SBIT(RS0,         0xD0, 3);
+  SBIT(RS1,         0xD0, 4);
+  SBIT(F0,          0xD0, 5);
+  SBIT(AC,          0xD0, 6);
+  SBIT(CY,          0xD0, 7);
+
+SFR(EICON,          0xD8);
+  // Bit 0 read-only, always reads '0'
+  // Bit 1 read-only, always reads '0'
+  // Bit 2 read-only, always reads '0'
+  SBIT(INT6,        0xD8, 3);
+  SBIT(RESI,        0xD8, 4);
+  SBIT(ERESI,       0xD8, 5);
+  // Bit 6 read-only, always reads '1'
+  SBIT(SMOD1,       0xD8, 7);
+
+SFR(ACC,            0xE0);
+
+SFR(EIE,            0xE8);
+  SBIT(EUSB,        0xE8, 0);
+  SBIT(EI2C,        0xE8, 1);
+  SBIT(EX4,         0xE8, 2);
+  SBIT(EX5,         0xE8, 3);
+  SBIT(EWDI,        0xE8, 4);
+  // Bit 5 read-only, always reads '1'
+  // Bit 6 read-only, always reads '1'
+  // Bit 7 read-only, always reads '1'
+
+SFR(B,              0xF0);
+
+SFR(EIP,            0xF8);
+  SBIT(PUSB,        0xF8, 0);
+  SBIT(PI2C,        0xF8, 1);
+  SBIT(PX4,         0xF8, 2);
+  SBIT(PX5,         0xF8, 3);
+  SBIT(PX6,         0xF8, 4);
+  // Bit 5 read-only, always reads '1'
+  // Bit 6 read-only, always reads '1'
+  // Bit 7 read-only, always reads '1'
+
+/***************************************************************************/
+/***************************** XDATA Registers *****************************/
+/***************************************************************************/
+
+/************************ Endpoint 0-7 Data Buffers ************************/
+SFRX(OUT7BUF[64],   0x7B40);
+SFRX(IN7BUF[64],    0x7B80);
+SFRX(OUT6BUF[64],   0x7BC0);
+SFRX(IN6BUF[64],    0x7C00);
+SFRX(OUT5BUF[64],   0x7C40);
+SFRX(IN5BUF[64],    0x7C80);
+SFRX(OUT4BUF[64],   0x7CC0);
+SFRX(IN4BUF[64],    0x7D00);
+SFRX(OUT3BUF[64],   0x7D40);
+SFRX(IN3BUF[64],    0x7D80);
+SFRX(OUT2BUF[64],   0x7DC0);
+SFRX(IN2BUF[64],    0x7E00);
+SFRX(OUT1BUF[64],   0x7E40);
+SFRX(IN1BUF[64],    0x7E80);
+SFRX(OUT0BUF[64],   0x7EC0);
+SFRX(IN0BUF[64],    0x7F00);
+// 0x7F40 - 0x7F5F reserved
+
+/**************************** Isochronous Data *****************************/
+SFRX(OUT8DATA,      0x7F60);
+SFRX(OUT9DATA,      0x7F61);
+SFRX(OUT10DATA,     0x7F62);
+SFRX(OUT11DATA,     0x7F63);
+SFRX(OUT12DATA,     0x7F64);
+SFRX(OUT13DATA,     0x7F65);
+SFRX(OUT14DATA,     0x7F66);
+SFRX(OUT15DATA,     0x7F67);
+
+SFRX(IN8DATA,       0x7F68);
+SFRX(IN9DATA,       0x7F69);
+SFRX(IN10DATA,      0x7F6A);
+SFRX(IN11DATA,      0x7F6B);
+SFRX(IN12DATA,      0x7F6C);
+SFRX(IN13DATA,      0x7F6D);
+SFRX(IN14DATA,      0x7F6E);
+SFRX(IN15DATA,      0x7F6F);
+
+/************************* Isochronous Byte Counts *************************/
+SFRX(OUT8BCH,       0x7F70);
+SFRX(OUT8BCL,       0x7F71);
+SFRX(OUT9BCH,       0x7F72);
+SFRX(OUT9BCL,       0x7F73);
+SFRX(OUT10BCH,      0x7F74);
+SFRX(OUT10BCL,      0x7F75);
+SFRX(OUT11BCH,      0x7F76);
+SFRX(OUT11BCL,      0x7F77);
+SFRX(OUT12BCH,      0x7F78);
+SFRX(OUT12BCL,      0x7F79);
+SFRX(OUT13BCH,      0x7F7A);
+SFRX(OUT13BCL,      0x7F7B);
+SFRX(OUT14BCH,      0x7F7C);
+SFRX(OUT14BCL,      0x7F7D);
+SFRX(OUT15BCH,      0x7F7E);
+SFRX(OUT16BCL,      0x7F7F);
+
+/****************************** CPU Registers ******************************/
+SFRX(CPUCS,         0x7F92);
+  #define RES8051   bmBit0
+  #define CLK24OE   bmBit1
+  // Bit 2 read-only, always reads '0'
+  // Bit 3 read-only, always reads '0'
+  // Bits 4...7: Chip Revision
+
+SFRX(PORTACFG,      0x7F93);
+  #define T0OUT     bmBit0
+  #define T1OUT     bmBit1
+  #define OE        bmBit2
+  #define CS        bmBit3
+  #define FWR       bmBit4
+  #define FRD       bmBit5
+  #define RXD0OUT   bmBit6
+  #define RXD1OUT   bmBit7
+
+SFRX(PORTBCFG,      0x7F94);
+  #define T2        bmBit0
+  #define T2EX      bmBit1
+  #define RXD1      bmBit2
+  #define TXD1      bmBit3
+  #define INT4      bmBit4
+  #define INT5      bmBit5
+  #define INT6      bmBit6
+  #define T2OUT     bmBit7
+
+SFRX(PORTCCFG,      0x7F95);
+  #define RXD0      bmBit0
+  #define TXD0      bmBit1
+  #define INT0      bmBit2
+  #define INT1      bmBit3
+  #define T0        bmBit4
+  #define T1        bmBit5
+  #define WR        bmBit6
+  #define RD        bmBit7
+
+/*********************** Input-Output Port Registers ***********************/
+SFRX(OUTA,          0x7F96);
+  #define OUTA0     bmBit0
+  #define OUTA1     bmBit1
+  #define OUTA2     bmBit2
+  #define OUTA3     bmBit3
+  #define OUTA4     bmBit4
+  #define OUTA5     bmBit5
+  #define OUTA6     bmBit6
+  #define OUTA7     bmBit7
+
+SFRX(OUTB,          0x7F97);
+  #define OUTB0     bmBit0
+  #define OUTB1     bmBit1
+  #define OUTB2     bmBit2
+  #define OUTB3     bmBit3
+  #define OUTB4     bmBit4
+  #define OUTB5     bmBit5
+  #define OUTB6     bmBit6
+  #define OUTB7     bmBit7
+
+SFRX(OUTC,          0x7F98);
+  #define OUTC0     bmBit0
+  #define OUTC1     bmBit1
+  #define OUTC2     bmBit2
+  #define OUTC3     bmBit3
+  #define OUTC4     bmBit4
+  #define OUTC5     bmBit5
+  #define OUTC6     bmBit6
+  #define OUTC7     bmBit7
+
+SFRX(PINSA,         0x7F99);
+  #define PINA0     bmBit0
+  #define PINA1     bmBit1
+  #define PINA2     bmBit2
+  #define PINA3     bmBit3
+  #define PINA4     bmBit4
+  #define PINA5     bmBit5
+  #define PINA6     bmBit6
+  #define PINA7     bmBit7
+
+SFRX(PINSB,         0x7F9A);
+  #define PINB0     bmBit0
+  #define PINB1     bmBit1
+  #define PINB2     bmBit2
+  #define PINB3     bmBit3
+  #define PINB4     bmBit4
+  #define PINB5     bmBit5
+  #define PINB6     bmBit6
+  #define PINB7     bmBit7
+
+SFRX(PINSC,         0x7F9B);
+  #define PINC0     bmBit0
+  #define PINC1     bmBit1
+  #define PINC2     bmBit2
+  #define PINC3     bmBit3
+  #define PINC4     bmBit4
+  #define PINC5     bmBit5
+  #define PINC6     bmBit6
+  #define PINC7     bmBit7
+
+SFRX(OEA,           0x7F9C);
+  #define OEA0      bmBit0
+  #define OEA1      bmBit1
+  #define OEA2      bmBit2
+  #define OEA3      bmBit3
+  #define OEA4      bmBit4
+  #define OEA5      bmBit5
+  #define OEA6      bmBit6
+  #define OEA7      bmBit7
+
+SFRX(OEB,           0x7F9D);
+  #define OEB0      bmBit0
+  #define OEB1      bmBit1
+  #define OEB2      bmBit2
+  #define OEB3      bmBit3
+  #define OEB4      bmBit4
+  #define OEB5      bmBit5
+  #define OEB6      bmBit6
+  #define OEB7      bmBit7
+
+SFRX(OEC,           0x7F9E);
+  #define OEC0      bmBit0
+  #define OEC1      bmBit1
+  #define OEC2      bmBit2
+  #define OEC3      bmBit3
+  #define OEC4      bmBit4
+  #define OEC5      bmBit5
+  #define OEC6      bmBit6
+  #define OEC7      bmBit7
+
+// 0x7F9F reserved
+
+/****************** Isochronous Control/Status Registers *******************/
+SFRX(ISOERR,        0x7FA0);
+  #define ISO8ERR   bmBit0
+  #define ISO9ERR   bmBit1
+  #define ISO10ERR  bmBit2
+  #define ISO11ERR  bmBit3
+  #define ISO12ERR  bmBit4
+  #define ISO13ERR  bmBit5
+  #define ISO14ERR  bmBit6
+  #define ISO15ERR  bmBit7
+
+SFRX(ISOCTL,        0x7FA1);
+  #define ISODISAB  bmBit0
+  #define MBZ0      bmBit1
+  #define MBZ1      bmBit2
+  #define PPSTAT    bmBit3
+  // Bit 4 unused
+  // Bit 5 unused
+  // Bit 6 unused
+  // Bit 7 unused
+
+SFRX(ZBCOUT,        0x7FA2);
+  #define EP8       bmBit0
+  #define EP9       bmBit1
+  #define EP10      bmBit2
+  #define EP11      bmBit3
+  #define EP12      bmBit4
+  #define EP13      bmBit5
+  #define EP14      bmBit6
+  #define EP15      bmBit7
+
+// 0x7FA3 reserved
+// 0x7FA4 reserved
+
+/****************************** I2C Registers ******************************/
+SFRX(I2CS,          0x7FA5);
+  #define DONE      bmBit0
+  #define ACK       bmBit1
+  #define BERR      bmBit2
+  #define ID0       bmBit3
+  #define ID1       bmBit4
+  #define LASTRD    bmBit5
+  #define I2C_STOP  bmBit6
+  #define I2C_START bmBit7
+
+SFRX(I2DAT,         0x7FA6);
+// 0x7FA7 reserved
+
+/******************************* Interrupts ********************************/
+SFRX(IVEC,          0x7FA8);
+  // Bit 0 read-only, always reads '0'
+  // Bit 1 read-only, always reads '0'
+  #define IV0       bmBit2
+  #define IV1       bmBit3
+  #define IV2       bmBit4
+  #define IV3       bmBit5
+  #define IV4       bmBit6
+  // Bit 7 read-only, always reads '0'
+
+SFRX(IN07IRQ,       0x7FA9);
+  #define IN0IR     bmBit0
+  #define IN1IR     bmBit1
+  #define IN2IR     bmBit2
+  #define IN3IR     bmBit3
+  #define IN4IR     bmBit4
+  #define IN5IR     bmBit5
+  #define IN6IR     bmBit6
+  #define IN7IR     bmBit7
+
+SFRX(OUT07IRQ,      0x7FAA);
+  #define OUT0IR    bmBit0
+  #define OUT1IR    bmBit1
+  #define OUT2IR    bmBit2
+  #define OUT3IR    bmBit3
+  #define OUT4IR    bmBit4
+  #define OUT5IR    bmBit5
+  #define OUT6IR    bmBit6
+  #define OUT7IR    bmBit7
+
+SFRX(USBIRQ,        0x7FAB);
+  #define SUDAVIR   bmBit0
+  #define SOFIR     bmBit1
+  #define SUTOKIR   bmBit2
+  #define SUSPIR    bmBit3
+  #define URESIR    bmBit4
+  // Bit 5 unused
+  // Bit 6 unused
+  // Bit 7 unused
+
+SFRX(IN07IEN,       0x7FAC);
+  #define IN0IEN    bmBit0
+  #define IN1IEN    bmBit1
+  #define IN2IEN    bmBit2
+  #define IN3IEN    bmBit3
+  #define IN4IEN    bmBit4
+  #define IN5IEN    bmBit5
+  #define IN6IEN    bmBit6
+  #define IN7IEN    bmBit7
+
+SFRX(OUT07IEN,      0x7FAD);
+  #define OUT0IEN   bmBit0
+  #define OUT1IEN   bmBit1
+  #define OUT2IEN   bmBit2
+  #define OUT3IEN   bmBit3
+  #define OUT4IEN   bmBit4
+  #define OUT5IEN   bmBit5
+  #define OUT6IEN   bmBit6
+  #define OUT7IEN   bmBit7
+
+SFRX(USBIEN,        0x7FAE);
+  #define SUDAVIE   bmBit0
+  #define SOFIE     bmBit1
+  #define SUTOKIE   bmBit2
+  #define SUSPIE    bmBit3
+  #define URESIE    bmBit4
+  // Bit 5 unused
+  // Bit 6 unused
+  // Bit 7 unused
+
+SFRX(USBBAV,        0x7FAF);
+  #define AVEN      bmBit0
+  #define BPEN      bmBit1
+  #define BPPULSE   bmBit2
+  #define BREAK     bmBit3
+  // Bit 4 unused
+  // Bit 5 unused
+  // Bit 6 unused
+  // Bit 7 unused
+
+// 0x7FB0 reserved
+// 0x7FB1 reserved
+SFRX(BPADDRH,       0x7FB2);
+SFRX(BPADDRL,       0x7FB3);
+
+/****************************** Endpoints 0-7 ******************************/
+SFRX(EP0CS,         0x7FB4);
+  #define EP0STALL  bmBit0
+  #define HSNAK     bmBit1
+  #define IN0BSY    bmBit2
+  #define OUT0BSY   bmBit3
+  // Bit 4 unused
+  // Bit 5 unused
+  // Bit 6 unused
+  // Bit 7 unused
+
+SFRX(IN0BC,         0x7FB5);
+SFRX(IN1CS,         0x7FB6);
+SFRX(IN1BC,         0x7FB7);
+SFRX(IN2CS,         0x7FB8);
+SFRX(IN2BC,         0x7FB9);
+SFRX(IN3CS,         0x7FBA);
+SFRX(IN3BC,         0x7FBB);
+SFRX(IN4CS,         0x7FBC);
+SFRX(IN4BC,         0x7FBD);
+SFRX(IN5CS,         0x7FBE);
+SFRX(IN5BC,         0x7FBF);
+SFRX(IN6CS,         0x7FC0);
+SFRX(IN6BC,         0x7FC1);
+SFRX(IN7CS,         0x7FC2);
+SFRX(IN7BC,         0x7FC3);
+// 0x7FC4 reserved
+SFRX(OUT0BC,        0x7FC5);
+SFRX(OUT1CS,        0x7FC6);
+SFRX(OUT1BC,        0x7FC7);
+SFRX(OUT2CS,        0x7FC8);
+SFRX(OUT2BC,        0x7FC9);
+SFRX(OUT3CS,        0x7FCA);
+SFRX(OUT3BC,        0x7FCB);
+SFRX(OUT4CS,        0x7FCC);
+SFRX(OUT4BC,        0x7FCD);
+SFRX(OUT5CS,        0x7FCE);
+SFRX(OUT5BC,        0x7FCF);
+SFRX(OUT6CS,        0x7FD0);
+SFRX(OUT6BC,        0x7FD1);
+SFRX(OUT7CS,        0x7FD2);
+SFRX(OUT7BC,        0x7FD3);
+
+/* The INxSTALL, OUTxSTALL, INxBSY and OUTxBSY bits are the same for all
+ * INxCS/OUTxCS registers. For better readability, we define them only once */
+#define EPSTALL     bmBit0
+#define EPBSY       bmBit1
+
+/************************** Global USB Registers ***************************/
+SFRX(SUDPTRH,       0x7FD4);
+SFRX(SUDPTRL,       0x7FD5);
+
+SFRX(USBCS,         0x7FD6);
+  #define SIGRSUME  bmBit0
+  #define RENUM     bmBit1
+  #define DISCOE    bmBit2
+  #define DISCON    bmBit3
+  // Bit 4 unused
+  // Bit 5 unused
+  // Bit 6 unused
+  #define WAKESRC   bmBit7
+
+SFRX(TOGCTL,        0x7FD7);
+  #define TOG_EP0   bmBit0
+  #define TOG_EP1   bmBit1
+  #define TOG_EP2   bmBit2
+  // Bit 3 is read-only, always reads '0'
+  #define TOG_IO    bmBit4
+  #define TOG_R     bmBit5
+  #define TOG_S     bmBit6
+  #define TOG_Q     bmBit7
+
+SFRX(USBFRAMEL,     0x7FD8);
+SFRX(USBFRAMEH,     0x7FD9);
+// 0x7FDA reserved
+SFRX(FNADDR,        0x7FDB);
+// 0x7FDC reserved
+
+SFRX(USBPAIR,       0x7FDD);
+  #define PR2IN     bmBit0
+  #define PR4IN     bmBit1
+  #define PR6IN     bmBit2
+  #define PR2OUT    bmBit3
+  #define PR4OUT    bmBit4
+  #define PR6OUT    bmBit5
+  // Bit 6 unused
+  #define ISOSEND0  bmBit7
+
+SFRX(IN07VAL,       0x7FDE);
+  // Bit 0 is read-only, always reads '1'
+  #define IN1VAL    bmBit1
+  #define IN2VAL    bmBit2
+  #define IN3VAL    bmBit3
+  #define IN4VAL    bmBit4
+  #define IN5VAL    bmBit5
+  #define IN6VAL    bmBit6
+  #define IN7VAL    bmBit7
+
+SFRX(OUT07VAL,      0x7FDF);
+  // Bit 0 is read-only, always reads '1'
+  #define OUT1VAL   bmBit1
+  #define OUT2VAL   bmBit2
+  #define OUT3VAL   bmBit3
+  #define OUT4VAL   bmBit4
+  #define OUT5VAL   bmBit5
+  #define OUT6VAL   bmBit6
+  #define OUT7VAL   bmBit7
+
+SFRX(INISOVAL,      0x7FE0);
+  #define IN8VAL    bmBit0
+  #define IN9VAL    bmBit1
+  #define IN10VAL   bmBit2
+  #define IN11VAL   bmBit3
+  #define IN12VAL   bmBit4
+  #define IN13VAL   bmBit5
+  #define IN14VAL   bmBit6
+  #define IN15VAL   bmBit7
+
+SFRX(OUTISOVAL,     0x7FE1);
+  #define OUT8VAL   bmBit0
+  #define OUT9VAL   bmBit1
+  #define OUT10VAL  bmBit2
+  #define OUT11VAL  bmBit3
+  #define OUT12VAL  bmBit4
+  #define OUT13VAL  bmBit5
+  #define OUT14VAL  bmBit6
+  #define OUT15VAL  bmBit7
+
+SFRX(FASTXFR,       0x7FE2);
+  #define WMOD0     bmBit0
+  #define WMOD1     bmBit1
+  #define WPOL      bmBit2
+  #define RMOD0     bmBit3
+  #define RMOD1     bmBit4
+  #define RPOL      bmBit5
+  #define FBLK      bmBit6
+  #define FISO      bmBit7
+
+SFRX(AUTOPTRH,      0x7FE3);
+SFRX(AUTOPTRL,      0x7FE4);
+SFRX(AUTODATA,      0x7FE5);
+// 0x7FE6 reserved
+// 0x7FE7 reserved
+
+/******************************* Setup Data ********************************/
+SFRX(SETUPDAT[8],   0x7FE8);
+
+/************************* Isochronous FIFO sizes **************************/
+SFRX(OUT8ADDR,      0x7FF0);
+SFRX(OUT9ADDR,      0x7FF1);
+SFRX(OUT10ADDR,     0x7FF2);
+SFRX(OUT11ADDR,     0x7FF3);
+SFRX(OUT12ADDR,     0x7FF4);
+SFRX(OUT13ADDR,     0x7FF5);
+SFRX(OUT14ADDR,     0x7FF6);
+SFRX(OUT15ADDR,     0x7FF7);
+
+SFRX(IN8ADDR,       0x7FF8);
+SFRX(IN9ADDR,       0x7FF9);
+SFRX(IN10ADDR,      0x7FFA);
+SFRX(IN11ADDR,      0x7FFB);
+SFRX(IN12ADDR,      0x7FFC);
+SFRX(IN13ADDR,      0x7FFD);
+SFRX(IN14ADDR,      0x7FFE);
+SFRX(IN15ADDR,      0x7FFF);
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/shorttypes.h b/src/jtag/drivers/OpenULINK/include/shorttypes.h
new file mode 100644
index 0000000..60b37df
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/shorttypes.h
@@ -0,0 +1,41 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __SHORTTYPES_H
+#define __SHORTTYPES_H
+
+#include <stdint.h>
+
+/**
+ * @file Integer type definitions for shorter code (easier to stay within 80
+ * character maximum line length).
+ */
+
+/* Signed integers */
+typedef int8_t   s8;
+typedef int16_t  s16;
+typedef int32_t  s32;
+
+/* Unsigned integers */
+typedef uint8_t  u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/include/usb.h b/src/jtag/drivers/OpenULINK/include/usb.h
new file mode 100644
index 0000000..f70819e
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/include/usb.h
@@ -0,0 +1,267 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef __USB_H
+#define __USB_H
+
+#include "shorttypes.h"
+#include "reg_ezusb.h"
+
+#include <stdbool.h>
+
+#define NULL        (void*)0;
+
+/* High and Low byte of a word (u16) */
+#define HI8(word)   (u8)(((u16)word >> 8) & 0xff)
+#define LO8(word)   (u8)((u16)word & 0xff)
+
+/* Convenience functions */
+#define STALL_EP0()   EP0CS |= EP0STALL
+#define CLEAR_IRQ()   EXIF &= ~USBINT
+
+/*********** USB descriptors. See section 9.5 of the USB 1.1 spec **********/
+
+/* USB Descriptor Types. See USB 1.1 spec, page 187, table 9-5 */
+#define DESCRIPTOR_TYPE_DEVICE         0x01
+#define DESCRIPTOR_TYPE_CONFIGURATION  0x02
+#define DESCRIPTOR_TYPE_STRING         0x03
+#define DESCRIPTOR_TYPE_INTERFACE      0x04
+#define DESCRIPTOR_TYPE_ENDPOINT       0x05
+
+#define STR_DESCR(len,...) { len*2+2, DESCRIPTOR_TYPE_STRING, { __VA_ARGS__ } }
+
+/** USB Device Descriptor. See USB 1.1 spec, pp. 196 - 198 */
+typedef struct {
+  u8  bLength;             ///< Size of this descriptor in bytes.
+  u8  bDescriptorType;     ///< DEVICE Descriptor Type.
+  u16 bcdUSB;              ///< USB specification release number (BCD).
+  u8  bDeviceClass;        ///< Class code.
+  u8  bDeviceSubClass;     ///< Subclass code.
+  u8  bDeviceProtocol;     ///< Protocol code.
+  u8  bMaxPacketSize0;     ///< Maximum packet size for EP0 (8, 16, 32, 64).
+  u16 idVendor;            ///< USB Vendor ID.
+  u16 idProduct;           ///< USB Product ID.
+  u16 bcdDevice;           ///< Device Release Number (BCD).
+  u8  iManufacturer;       ///< Index of manufacturer string descriptor.
+  u8  iProduct;            ///< Index of product string descriptor.
+  u8  iSerialNumber;       ///< Index of string descriptor containing serial #.
+  u8  bNumConfigurations;  ///< Number of possible configurations.
+} usb_device_descriptor_t;
+
+/** USB Configuration Descriptor. See USB 1.1 spec, pp. 199 - 200 */
+typedef struct {
+  u8  bLength;             ///< Size of this descriptor in bytes.
+  u8  bDescriptorType;     ///< CONFIGURATION descriptor type.
+  u16 wTotalLength;        ///< Combined total length of all descriptors.
+  u8  bNumInterfaces;      ///< Number of interfaces in this configuration.
+  u8  bConfigurationValue; ///< Value used to select this configuration.
+  u8  iConfiguration;      ///< Index of configuration string descriptor.
+  u8  bmAttributes;        ///< Configuration characteristics.
+  u8  MaxPower;            ///< Maximum power consumption in 2 mA units.
+} usb_config_descriptor_t;
+
+/** USB Interface Descriptor. See USB 1.1 spec, pp. 201 - 203 */
+typedef struct {
+  u8  bLength;             ///< Size of this descriptor in bytes.
+  u8  bDescriptorType;     ///< INTERFACE descriptor type.
+  u8  bInterfaceNumber;    ///< Interface number.
+  u8  bAlternateSetting;   ///< Value used to select alternate setting.
+  u8  bNumEndpoints;       ///< Number of endpoints used by this interface.
+  u8  bInterfaceClass;     ///< Class code.
+  u8  bInterfaceSubclass;  ///< Subclass code.
+  u8  bInterfaceProtocol;  ///< Protocol code.
+  u8  iInterface;          ///< Index of interface string descriptor.
+} usb_interface_descriptor_t;
+
+/** USB Endpoint Descriptor. See USB 1.1 spec, pp. 203 - 204 */
+typedef struct {
+  u8  bLength;             ///< Size of this descriptor in bytes.
+  u8  bDescriptorType;     ///< ENDPOINT descriptor type.
+  u8  bEndpointAddress;    ///< Endpoint Address: USB 1.1 spec, table 9-10.
+  u8  bmAttributes;        ///< Endpoint Attributes: USB 1.1 spec, table 9-10.
+  u16 wMaxPacketSize;      ///< Maximum packet size for this endpoint.
+  u8  bInterval;           ///< Polling interval (in ms) for this endpoint.
+} usb_endpoint_descriptor_t;
+
+/** USB Language Descriptor. See USB 1.1 spec, pp. 204 - 205 */
+typedef struct {
+  u8  bLength;             ///< Size of this descriptor in bytes.
+  u8  bDescriptorType;     ///< STRING descriptor type.
+  u16 wLANGID[];           ///< LANGID codes.
+} usb_language_descriptor_t;
+
+/** USB String Descriptor. See USB 1.1 spec, pp. 204 - 205 */
+typedef struct {
+  u8  bLength;             ///< Size of this descriptor in bytes.
+  u8  bDescriptorType;     ///< STRING descriptor type.
+  u16 bString[];           ///< UNICODE encoded string.
+} usb_string_descriptor_t;
+
+/********************** USB Control Endpoint 0 related *********************/
+
+/** USB Control Setup Data. See USB 1.1 spec, pp. 183 - 185 */
+typedef struct {
+  u8  bmRequestType;       ///< Characteristics of a request.
+  u8  bRequest;            ///< Specific request.
+  u16 wValue;              ///< Field that varies according to request.
+  u16 wIndex;              ///< Field that varies according to request.
+  u16 wLength;             ///< Number of bytes to transfer in data stage.
+} setup_data_t;
+
+/* External declarations for variables that need to be accessed outside of
+ * the USB module */
+extern volatile bool EP2_out;
+extern volatile bool EP2_in;
+extern volatile __xdata __at 0x7FE8 setup_data_t setup_data;
+
+/*
+ * USB Request Types (bmRequestType): See USB 1.1 spec, page 183, table 9-2
+ *
+ * Bit 7: Data transfer direction
+ *    0 = Host-to-device
+ *    1 = Device-to-host
+ * Bit 6...5: Type
+ *    0 = Standard
+ *    1 = Class
+ *    2 = Vendor
+ *    3 = Reserved
+ * Bit 4...0: Recipient
+ *    0 = Device
+ *    1 = Interface
+ *    2 = Endpoint
+ *    3 = Other
+ *    4...31 = Reserved
+ */
+
+#define USB_DIR_OUT             0x00
+#define USB_DIR_IN              0x80
+
+#define USB_REQ_TYPE_STANDARD   (0x00 << 5)
+#define USB_REQ_TYPE_CLASS      (0x01 << 5)
+#define USB_REQ_TYPE_VENDOR     (0x02 << 5)
+#define USB_REQ_TYPE_RESERVED   (0x03 << 5)
+
+#define USB_RECIP_DEVICE        0x00
+#define USB_RECIP_INTERFACE     0x01
+#define USB_RECIP_ENDPOINT      0x02
+#define USB_RECIP_OTHER         0x03
+
+/* bmRequestType for USB Standard Requests */
+
+/* Clear Interface Request */
+#define CF_DEVICE    (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_DEVICE)
+#define CF_INTERFACE (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_INTERFACE)
+#define CF_ENDPOINT  (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_ENDPOINT)
+
+/* Get Configuration Request */
+#define GC_DEVICE    (USB_DIR_IN | USB_REQ_TYPE_STANDARD | USB_RECIP_DEVICE)
+
+/* Get Descriptor Request */
+#define GD_DEVICE    (USB_DIR_IN | USB_REQ_TYPE_STANDARD | USB_RECIP_DEVICE)
+
+/* Get Interface Request */
+#define GI_INTERFACE (USB_DIR_IN | USB_REQ_TYPE_STANDARD | USB_RECIP_INTERFACE)
+
+/* Get Status Request: See USB 1.1 spec, page 190 */
+#define GS_DEVICE    (USB_DIR_IN | USB_REQ_TYPE_STANDARD | USB_RECIP_DEVICE)
+#define GS_INTERFACE (USB_DIR_IN | USB_REQ_TYPE_STANDARD | USB_RECIP_INTERFACE)
+#define GS_ENDPOINT  (USB_DIR_IN | USB_REQ_TYPE_STANDARD | USB_RECIP_ENDPOINT)
+
+/* Set Address Request is handled by EZ-USB core */
+
+/* Set Configuration Request */
+#define SC_DEVICE    (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_DEVICE)
+
+/* Set Descriptor Request */
+#define SD_DEVICE    (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_DEVICE)
+
+/* Set Feature Request */
+#define SF_DEVICE    (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_DEVICE)
+#define SF_INTERFACE (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_INTERFACE)
+#define SF_ENDPOINT  (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_ENDPOINT)
+
+/* Set Interface Request */
+#define SI_INTERFACE (USB_DIR_OUT | USB_REQ_TYPE_STANDARD | USB_RECIP_INTERFACE)
+
+/* Synch Frame Request */
+#define SY_ENDPOINT  (USB_DIR_IN | USB_REQ_TYPE_STANDARD | USB_RECIP_ENDPOINT)
+
+/* USB Requests (bRequest): See USB 1.1 spec, table 9-4 on page 187 */
+#define GET_STATUS               0
+#define CLEAR_FEATURE            1
+// Value '2' is reserved for future use
+#define SET_FEATURE              3
+// Value '4' is reserved for future use
+#define SET_ADDRESS              5
+#define GET_DESCRIPTOR           6
+#define SET_DESCRIPTOR           7
+#define GET_CONFIGURATION        8
+#define SET_CONFIGURATION        9
+#define GET_INTERFACE           10
+#define SET_INTERFACE           11
+#define SYNCH_FRAME             12
+
+/* Standard Feature Selectors: See USB 1.1 spec, table 9-6 on page 188 */
+#define DEVICE_REMOTE_WAKEUP     1
+#define ENDPOINT_HALT            0
+
+/************************** EZ-USB specific stuff **************************/
+
+/** USB Interrupts. See AN2131-TRM, page 9-4 for details */
+typedef enum {
+  SUDAV_ISR = 13,
+  SOF_ISR,
+  SUTOK_ISR,
+  SUSPEND_ISR,
+  USBRESET_ISR,
+  IBN_ISR,
+  EP0IN_ISR,
+  EP0OUT_ISR,
+  EP1IN_ISR,
+  EP1OUT_ISR,
+  EP2IN_ISR,
+  EP2OUT_ISR,
+  EP3IN_ISR,
+  EP3OUT_ISR,
+  EP4IN_ISR,
+  EP4OUT_ISR,
+  EP5IN_ISR,
+  EP5OUT_ISR,
+  EP6IN_ISR,
+  EP6OUT_ISR,
+  EP7IN_ISR,
+  EP7OUT_ISR
+} USB_ISR;
+
+/*************************** Function Prototypes ***************************/
+
+__xdata u8* usb_get_endpoint_cs_reg(u8 ep);
+void usb_reset_data_toggle(u8 ep);
+
+bool usb_handle_get_status(void);
+bool usb_handle_clear_feature(void);
+bool usb_handle_set_feature(void);
+bool usb_handle_get_descriptor(void);
+void usb_handle_set_interface(void);
+
+void usb_handle_setup_data(void);
+void usb_init(void);
+
+#endif
diff --git a/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51 b/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
new file mode 100644
index 0000000..6f774dd
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
@@ -0,0 +1,83 @@
+;--------------------------------------------------------------------------;
+;    Copyright (C) 2011 by Martin Schmoelzer                               ;
+;    <martin.schmoelzer at student.tuwien.ac.at>                              ;
+;                                                                          ;
+;    This program is free software; you can redistribute it and/or modify  ;
+;    it under the terms of the GNU General Public License as published by  ;
+;    the Free Software Foundation; either version 2 of the License, or     ;
+;    (at your option) any later version.                                   ;
+;                                                                          ;
+;    This program is distributed in the hope that it will be useful,       ;
+;    but WITHOUT ANY WARRANTY; without even the implied warranty of        ;
+;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         ;
+;    GNU General Public License for more details.                          ;
+;                                                                          ;
+;    You should have received a copy of the GNU General Public License     ;
+;    along with this program; if not, write to the                         ;
+;    Free Software Foundation, Inc.,                                       ;
+;    59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             ;
+;--------------------------------------------------------------------------;
+
+.module JUMPTABLE
+.globl USB_AutoVector
+.globl USB_Jump_Table
+
+;--------------------------------------------------------------------------;
+; Interrupt Vectors                                                        ;
+;--------------------------------------------------------------------------;
+.area   USB_JV (ABS,OVR)   ; Absolute, Overlay
+.org    0x43               ; USB interrupt (INT2) jumps here
+USB_AutoVector = #. + 2
+    ljmp  USB_jump_table
+
+;--------------------------------------------------------------------------;
+; USB Jump Table                                                           ;
+;--------------------------------------------------------------------------;
+.area  USB_JT (ABS)        ; Absolute placement
+.org   0x1B00              ; Place jump table at 0x1B00
+
+USB_jump_table:            ; autovector jump table
+    ljmp  _sudav_isr       ; Setup Data Available
+    .db 0
+    ljmp  _sof_isr         ; Start of Frame
+    .db 0
+    ljmp  _sutok_isr       ; Setup Data Loading
+    .db 0
+    ljmp  _suspend_isr     ; Global Suspend
+    .db 0
+    ljmp  _usbreset_isr    ; USB Reset
+    .db 0
+    ljmp  _ibn_isr         ; IN Bulk NAK interrupt
+    .db 0
+    ljmp  _ep0in_isr       ; Endpoint 0 IN
+    .db 0
+    ljmp  _ep0out_isr      ; Endpoint 0 OUT
+    .db 0
+    ljmp  _ep1in_isr       ; Endpoint 1 IN
+    .db 0
+    ljmp  _ep1out_isr      ; Endpoint 1 OUT
+    .db 0
+    ljmp  _ep2in_isr       ; Endpoint 2 IN
+    .db 0
+    ljmp  _ep2out_isr      ; Endpoint 2 OUT
+    .db 0
+    ljmp  _ep3in_isr       ; Endpoint 3 IN
+    .db 0
+    ljmp  _ep3out_isr      ; Endpoint 3 OUT
+    .db 0
+    ljmp  _ep4in_isr       ; Endpoint 4 IN
+    .db 0
+    ljmp  _ep4out_isr      ; Endpoint 4 OUT
+    .db 0
+    ljmp  _ep5in_isr       ; Endpoint 5 IN
+    .db 0
+    ljmp  _ep5out_isr      ; Endpoint 5 OUT
+    .db 0
+    ljmp  _ep6in_isr       ; Endpoint 6 IN
+    .db 0
+    ljmp  _ep6out_isr      ; Endpoint 6 OUT
+    .db 0
+    ljmp  _ep7in_isr       ; Endpoint 7 IN
+    .db 0
+    ljmp  _ep7out_isr      ; Endpoint 7 OUT
+    .db 0
diff --git a/src/jtag/drivers/OpenULINK/src/delay.c b/src/jtag/drivers/OpenULINK/src/delay.c
new file mode 100644
index 0000000..5b7d0eb
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/src/delay.c
@@ -0,0 +1,51 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "delay.h"
+
+void delay_5us(void)
+{
+  NOP;
+}
+
+void delay_1ms(void) {
+  u16 i;
+
+  for (i = 0; i < 598; i++);
+}
+
+void delay_us(u16 delay)
+{
+  u16 i;
+  u16 maxcount = (delay / 5);
+
+  for (i = 0; i < maxcount; i++) {
+    delay_5us();
+  }
+}
+
+void delay_ms(u16 delay)
+{
+  u16 i;
+
+  for (i = 0; i < delay; i++) {
+    delay_1ms();
+  }
+}
diff --git a/src/jtag/drivers/OpenULINK/src/jtag.c b/src/jtag/drivers/OpenULINK/src/jtag.c
new file mode 100644
index 0000000..cf126ed
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/src/jtag.c
@@ -0,0 +1,414 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "jtag.h"
+
+#include "io.h"
+#include "msgtypes.h"
+#include "common.h"
+
+#include <stdbool.h>
+
+/** Delay value for SCAN operations with less than maximum TCK frequency */
+u8 delay_scan = 0;
+
+/** Delay value for CLOCK_TCK operations */
+u8 delay_tck = 0;
+
+/** Delay value for CLOCK_TMS operations with less than maximum frequency */
+u8 delay_tms = 0;
+
+/**
+ * Perform JTAG SCAN-IN operation at maximum TCK frequency.
+ *
+ * Dummy data is shifted into the JTAG chain via TDI, TDO data is sampled and
+ * stored in the EP2 IN buffer.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_scan_in(u8 out_offset, u8 in_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdo_data, i, j;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] >> 4) & 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] & 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+
+  if (tms_count_start > 0) {
+    jtag_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB & ~(PIN_TDI | PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i < scan_size_bytes - 1; i++) {
+    tdo_data = 0;
+
+    for (j = 0; j < 8; j++) {
+      OUTB = outb_buffer; /* TCK changes here */
+      OUTB = (outb_buffer | PIN_TCK);
+      tdo_data = tdo_data >> 1;
+
+      if (GET_TDO()) {
+        tdo_data |= 0x80;
+      }
+    }
+
+    /* Copy TDO data to IN2BUF */
+    IN2BUF[i + in_offset] = tdo_data;
+  }
+
+  tdo_data = 0;
+
+  /* Shift the last byte */
+  for (j = 0; j < bits_last_byte; j++) {
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) && (tms_count_end > 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end >> 1;
+    }
+
+    OUTB = outb_buffer; /* TCK change here */
+    OUTB = (outb_buffer | PIN_TCK);
+    tdo_data = tdo_data >> 1;
+
+    if (GET_TDO()) {
+      tdo_data |= 0x80;
+    }
+  }
+  tdo_data = tdo_data >> (8 - bits_last_byte);
+
+  /* Copy TDO data to IN2BUF */
+  IN2BUF[i + in_offset] = tdo_data;
+
+  /* Move to correct end state */
+  if (tms_count_end > 0) {
+    jtag_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
+ * Perform JTAG SCAN-OUT operation at maximum TCK frequency.
+ *
+ * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
+ * data is not sampled.
+ * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_scan_out(u8 out_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdi_data, i, j;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] >> 4) & 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] & 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+  
+  if (tms_count_start > 0) {
+    jtag_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB & ~(PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i < scan_size_bytes - 1; i++) {
+    tdi_data = OUT2BUF[i + out_offset + 5];
+
+    for (j = 0; j < 8; j++) {
+      if (tdi_data & 0x01) {
+        outb_buffer |= PIN_TDI;
+      }
+      else {
+        outb_buffer &= ~PIN_TDI;
+      }
+
+      OUTB = outb_buffer; /* TDI and TCK change here */
+      tdi_data = tdi_data >> 1;
+      OUTB = (outb_buffer | PIN_TCK);
+    }
+  }
+
+  tdi_data = OUT2BUF[i + out_offset + 5];
+
+  /* Shift the last byte */
+  for (j = 0; j < bits_last_byte; j++) {
+    if (tdi_data & 0x01) {
+      outb_buffer |= PIN_TDI;
+    }
+    else {
+      outb_buffer &= ~PIN_TDI;
+    }
+
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) && (tms_count_end > 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end >> 1;
+    }
+
+    OUTB = outb_buffer; /* TDI and TCK change here */
+    tdi_data = tdi_data >> 1;
+    OUTB = (outb_buffer | PIN_TCK);
+  }
+
+  /* Move to correct end state */
+  if (tms_count_end > 0) {
+    jtag_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
+ * Perform bidirectional JTAG SCAN operation at maximum TCK frequency.
+ *
+ * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
+ * data is sampled and stored in the EP2 IN buffer.
+ * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_scan_io(u8 out_offset, u8 in_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdi_data, tdo_data, i, j;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] >> 4) & 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] & 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+  
+  if (tms_count_start > 0) {
+    jtag_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB & ~(PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i < scan_size_bytes - 1; i++) {
+    tdi_data = OUT2BUF[i + out_offset + 5];
+    tdo_data = 0;
+
+    for (j = 0; j < 8; j++) {
+      if (tdi_data & 0x01) {
+        outb_buffer |= PIN_TDI;
+      }
+      else {
+        outb_buffer &= ~PIN_TDI;
+      }
+
+      OUTB = outb_buffer; /* TDI and TCK change here */
+      tdi_data = tdi_data >> 1;
+      OUTB = (outb_buffer | PIN_TCK);
+      tdo_data = tdo_data >> 1;
+
+      if (GET_TDO()) {
+        tdo_data |= 0x80;
+      }
+    }
+
+    /* Copy TDO data to IN2BUF */
+    IN2BUF[i + in_offset] = tdo_data;
+  }
+
+  tdi_data = OUT2BUF[i + out_offset + 5];
+  tdo_data = 0;
+
+  /* Shift the last byte */
+  for (j = 0; j < bits_last_byte; j++) {
+    if (tdi_data & 0x01) {
+      outb_buffer |= PIN_TDI;
+    }
+    else {
+      outb_buffer &= ~PIN_TDI;
+    }
+
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) && (tms_count_end > 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end >> 1;
+    }
+
+    OUTB = outb_buffer; /* TDI and TCK change here */
+    tdi_data = tdi_data >> 1;
+    OUTB = (outb_buffer | PIN_TCK);
+    tdo_data = tdo_data >> 1;
+
+    if (GET_TDO()) {
+      tdo_data |= 0x80;
+    }
+  }
+  tdo_data = tdo_data >> (8 - bits_last_byte);
+
+  /* Copy TDO data to IN2BUF */
+  IN2BUF[i + in_offset] = tdo_data;
+  
+  /* Move to correct end state */
+  if (tms_count_end > 0) {
+    jtag_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
+ * Generate TCK clock cycles.
+ *
+ * @param count number of TCK clock cyclces to generate.
+ */
+void jtag_clock_tck(u16 count)
+{
+  u16 i;
+  u8 j;
+
+  for ( i = 0; i < count; i++ ) {
+    SET_TCK_LOW();
+    for(j = 0; j < delay_tck; j++);
+
+    SET_TCK_HIGH();
+    for(j = 0; j < delay_tck; j++);
+  }
+}
+
+/**
+ * Perform TAP-FSM state transitions at maximum TCK frequency.
+ *
+ * @param count the number of state transitions to perform.
+ * @param sequence the TMS pin levels for each state transition, starting with
+ *  the least-significant bit.
+ */
+void jtag_clock_tms(u8 count, u8 sequence)
+{
+  volatile u8 outb_buffer;
+  u8 i;
+
+  outb_buffer = OUTB & ~(PIN_TCK);
+
+  for ( i = 0; i < count; i++ ) {
+    /* Set TMS pin according to sequence parameter */
+    if ( sequence & 0x1 ) {
+      outb_buffer |= PIN_TMS;
+    }
+    else {
+      outb_buffer &= ~PIN_TMS;
+    }
+
+    OUTB = outb_buffer;
+    sequence = sequence >> 1;
+    OUTB = outb_buffer | PIN_TCK;
+  }
+}
+
+/**
+ * Perform TAP-FSM state transitions at less than maximum TCK frequency.
+ *
+ * @param count the number of state transitions to perform.
+ * @param sequence the TMS pin levels for each state transition, starting with
+ *  the least-significant bit.
+ */
+void jtag_slow_clock_tms(u8 count, u8 sequence)
+{
+
+}
+
+/**
+ * Get current JTAG signal states.
+ *
+ * @return a 16-bit integer where the most-significant byte contains the state
+ *  of the JTAG input signals and the least-significant byte cotains the state
+ *  of the JTAG output signals.
+ */
+u16 jtag_get_signals(void)
+{
+  u8 input_signal_state, output_signal_state;
+
+  input_signal_state = 0;
+  output_signal_state = 0;
+
+  /* Get states of input pins */
+  if (GET_TDO()) {
+    input_signal_state |= SIGNAL_TDO;
+  }
+  if (GET_BRKOUT()) {
+    input_signal_state |= SIGNAL_BRKOUT;
+  }
+  if (GET_TRAP()) {
+    input_signal_state |= SIGNAL_TRAP;
+  }
+  if (GET_RTCK()) {
+    /* Using RTCK this way would be extremely slow,
+     * implemented only for the sake of completeness */
+    input_signal_state |= SIGNAL_RTCK;
+  }
+
+  /* Get states of output pins */
+  output_signal_state = PINSB & MASK_PORTB_DIRECTION_OUT;
+
+  return ((u16)input_signal_state << 8) | ((u16)output_signal_state);
+}
+
+/**
+ * Set state of JTAG output signals.
+ *
+ * @param low signals which should be de-asserted.
+ * @param high signals which should be asserted.
+ */
+void jtag_set_signals(u8 low, u8 high)
+{
+  OUTB &= ~(low & MASK_PORTB_DIRECTION_OUT);
+  OUTB |= (high & MASK_PORTB_DIRECTION_OUT);
+}
+
+/**
+ * Configure TCK delay parameters.
+ *
+ * @param scan number of delay cycles in shift operations.
+ * @param tck number of delay cycles in clock_tck operations.
+ * @param tms number of delay cycles in clock_tms operations.
+ */
+void jtag_configure_tck_delay(u8 scan, u8 tck, u8 tms)
+{
+  delay_scan = scan;
+  delay_tck = tck;
+  delay_tms = tms;
+}
diff --git a/src/jtag/drivers/OpenULINK/src/main.c b/src/jtag/drivers/OpenULINK/src/main.c
new file mode 100644
index 0000000..3ea3fff
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/src/main.c
@@ -0,0 +1,92 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "main.h"
+
+#include "shorttypes.h"
+#include "io.h"
+#include "usb.h"
+#include "protocol.h"
+
+extern void sudav_isr(void)    __interrupt SUDAV_ISR;
+extern void sof_isr(void)      __interrupt;
+extern void sutok_isr(void)    __interrupt;
+extern void suspend_isr(void)  __interrupt;
+extern void usbreset_isr(void) __interrupt;
+extern void ibn_isr(void)      __interrupt;
+extern void ep0in_isr(void)    __interrupt;
+extern void ep0out_isr(void)   __interrupt;
+extern void ep1in_isr(void)    __interrupt;
+extern void ep1out_isr(void)   __interrupt;
+extern void ep2in_isr(void)    __interrupt;
+extern void ep2out_isr(void)   __interrupt;
+extern void ep3in_isr(void)    __interrupt;
+extern void ep3out_isr(void)   __interrupt;
+extern void ep4in_isr(void)    __interrupt;
+extern void ep4out_isr(void)   __interrupt;
+extern void ep5in_isr(void)    __interrupt;
+extern void ep5out_isr(void)   __interrupt;
+extern void ep6in_isr(void)    __interrupt;
+extern void ep6out_isr(void)   __interrupt;
+extern void ep7in_isr(void)    __interrupt;
+extern void ep7out_isr(void)   __interrupt;
+
+void io_init(void)
+{
+  /* PORTxCFG register bits select alternate functions (1 == alternate function,
+   *                                                    0 == standard I/O)
+   * OEx register bits turn on/off output buffer (1 == output, 0 == input)
+   * OUTx register bits determine pin state of output
+   * PINx register bits reflect pin state (high == 1, low == 0) */
+
+  /* PORT A */
+  PORTACFG = PIN_OE;
+  OEA = PIN_U_OE | PIN_OE | PIN_RUN_LED | PIN_COM_LED;
+  OUTA = PIN_RUN_LED | PIN_COM_LED;
+
+  /* PORT B */
+  PORTBCFG = 0x00;
+  OEB = PIN_TDI | PIN_TMS | PIN_TCK | PIN_TRST | PIN_BRKIN | PIN_RESET
+      | PIN_OCDSE;
+
+  /* TRST and RESET signals are low-active but inverted by hardware, so we clear
+   * these signals here! */
+  OUTB = 0x00;
+
+  /* PORT C */
+  PORTCCFG = PIN_WR;
+  OEC = PIN_TXD0 | PIN_WR;
+  OUTC = 0x00;
+}
+
+int main(void)
+{
+  io_init();
+  usb_init();
+
+  /* Enable Interrupts */
+  EA = 1;
+
+  /* Begin executing command(s). This function never returns. */
+  command_loop();
+
+  /* Never reached, but SDCC complains about missing return statement */
+  return 0;
+}
diff --git a/src/jtag/drivers/OpenULINK/src/protocol.c b/src/jtag/drivers/OpenULINK/src/protocol.c
new file mode 100644
index 0000000..05929d0
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/src/protocol.c
@@ -0,0 +1,212 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include "protocol.h"
+#include "jtag.h"
+#include "delay.h"
+#include "usb.h"
+#include "io.h"
+#include "msgtypes.h"
+
+#include "reg_ezusb.h"
+
+/**
+ * @file Implementation of the OpenULINK communication protocol.
+ *
+ * The OpenULINK protocol uses one OUT and one IN endpoint. These two endpoints
+ * are configured to use the maximum packet size for full-speed transfers,
+ * 64 bytes. Commands always start with a command ID (see msgtypes.h for
+ * command ID definitions) and contain zero or more payload data bytes in both
+ * transfer directions (IN and OUT). The payload 
+ *
+ * Almost all commands contain a fixed number of payload data bytes. The number
+ * of payload data bytes for the IN and OUT direction does not need to be the
+ * same.
+ * 
+ * Multiple commands may be sent in one EP2 Bulk-OUT packet. Because the
+ * OpenULINK firmware does not perform bounds checking for EP2 Bulk-IN packets,
+ * the host MUST ensure that the commands sent in the OUT packet require a
+ * maximum of 64 bytes of IN data.
+ */
+
+/** Index in EP2 Bulk-OUT data buffer that contains the current command ID */
+volatile u8 cmd_id_index;
+
+/** Number of data bytes already in EP2 Bulk-IN buffer */
+volatile u8 payload_index_in;
+
+/**
+ * Execute a SET_LEDS command.
+ */
+void execute_set_led_command(void)
+{
+  u8 led_state = OUT2BUF[cmd_id_index + 1];
+
+  if (led_state & RUN_LED_ON) {
+    SET_RUN_LED();
+  }
+
+  if (led_state & COM_LED_ON) {
+    SET_COM_LED();
+  }
+
+  if (led_state & RUN_LED_OFF) {
+    CLEAR_RUN_LED();
+  }
+
+  if (led_state & COM_LED_OFF) {
+    CLEAR_COM_LED();
+  }
+}
+
+/**
+ * Executes one command and updates global command indexes.
+ *
+ * @param index the index of the Bulk EP2-OUT data buffer at which the
+ *  command ID is stored.
+ * @return true if this command was the last command.
+ * @return false if there are more commands within the current contents of the
+ *  Bulk EP2-OUT data buffer.
+ */
+bool execute_command(void)
+{
+  u8 usb_out_bytecount, usb_in_bytecount;
+  u16 signal_state;
+  u16 count;
+
+  /* Most commands do not transfer IN data. To save code space, we write 0 to
+   * usb_in_bytecount here, then modify it in the switch statement below where
+   * neccessary */
+  usb_in_bytecount = 0;
+
+  switch (OUT2BUF[cmd_id_index] /* Command ID */) {
+  case CMD_SCAN_IN:
+    usb_out_bytecount = 5;
+    usb_in_bytecount = OUT2BUF[cmd_id_index + 1];
+    jtag_scan_in(cmd_id_index + 1, payload_index_in);
+    break;
+  case CMD_SCAN_OUT:
+    usb_out_bytecount = OUT2BUF[cmd_id_index + 1] + 5;
+    jtag_scan_out(cmd_id_index + 1);
+    break;
+  case CMD_SCAN_IO:
+    usb_in_bytecount = OUT2BUF[cmd_id_index + 1];
+    usb_out_bytecount = usb_in_bytecount + 5;
+    jtag_scan_io(cmd_id_index + 1, payload_index_in);
+    break;
+  case CMD_CLOCK_TMS:
+    usb_out_bytecount = 2;
+    jtag_clock_tms(OUT2BUF[cmd_id_index + 1], OUT2BUF[cmd_id_index + 2]);
+    break;
+  case CMD_CLOCK_TCK:
+    usb_out_bytecount = 2;
+    count = (u16)OUT2BUF[cmd_id_index + 1];
+    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    jtag_clock_tck(count);
+    break;
+  case CMD_SLEEP_US:
+    usb_out_bytecount = 2;
+    count = (u16)OUT2BUF[cmd_id_index + 1];
+    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    delay_us(count);
+    break;
+  case CMD_SLEEP_MS:
+    usb_out_bytecount = 2;
+    count = (u16)OUT2BUF[cmd_id_index + 1];
+    count |= ((u16)OUT2BUF[cmd_id_index + 2]) << 8;
+    delay_ms(count);
+    break;
+  case CMD_GET_SIGNALS:
+    usb_out_bytecount = 0;
+    usb_in_bytecount = 2;
+    signal_state = jtag_get_signals();
+    IN2BUF[payload_index_in] = (signal_state >> 8) & 0x00FF;
+    IN2BUF[payload_index_in + 1] = signal_state & 0x00FF;
+    break;
+  case CMD_SET_SIGNALS:
+    usb_out_bytecount = 2;
+    jtag_set_signals(OUT2BUF[cmd_id_index + 1], OUT2BUF[cmd_id_index + 2]);
+    break;
+  case CMD_SET_LEDS:
+    usb_out_bytecount = 1;
+    execute_set_led_command();
+    break;
+  case CMD_TEST:
+    usb_out_bytecount = 1;
+    /* Do nothing... This command is only used to test if the device is ready
+     * to accept new commands */
+    break;
+  default:
+    /* Should never be reached */
+    usb_out_bytecount = 0;
+    break;
+  }
+
+  /* Update EP2 Bulk-IN data byte count */
+  payload_index_in += usb_in_bytecount;
+
+  /* Determine if this was the last command */
+  if ((cmd_id_index + usb_out_bytecount + 1) >= OUT2BC) {
+    return true;
+  }
+  else {
+    /* Not the last command, update cmd_id_index */
+    cmd_id_index += (usb_out_bytecount + 1);
+    return false;
+  }
+}
+
+/**
+ * Forever wait for commands and execute them as they arrive.
+ */
+void command_loop(void)
+{
+  bool last_command;
+
+  while (1) {
+    cmd_id_index = 0;
+    payload_index_in = 0;
+
+    /* Wait until host sends EP2 Bulk-OUT packet */
+    while (!EP2_out);
+    EP2_out = 0;
+
+    /* Turn on COM LED to indicate command execution */
+    SET_COM_LED();
+
+    /* Execute the commands */
+    last_command = false;
+    while (last_command == false) {
+      last_command = execute_command();
+    }
+
+    CLEAR_COM_LED();
+    
+    /* Send back EP2 Bulk-IN packet if required */
+    if (payload_index_in > 0) {
+      IN2BC = payload_index_in;
+      while (!EP2_in);
+      EP2_in = 0;
+    }
+
+    /* Re-arm EP2-OUT after command execution */
+    OUT2BC = 0;
+  }
+}
diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
new file mode 100644
index 0000000..b74b3a2
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -0,0 +1,543 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/**
+ * @file Defines USB descriptors, interrupt routines and helper functions.
+ * To minimize code size, we make the following assumptions:
+ *  - The OpenULINK has exactly one configuration
+ *  - and exactly one alternate setting
+ *
+ * Therefore, we do not have to support the Set Configuration USB request.
+ */
+
+#include "usb.h"
+#include "delay.h"
+#include "io.h"
+
+/* Also update external declarations in "include/usb.h" if making changes to
+ * these variables! */
+volatile bool EP2_out = 0;
+volatile bool EP2_in  = 0;
+
+volatile __xdata __at 0x7FE8 setup_data_t setup_data;
+
+/* Define number of endpoints (except Control Endpoint 0) in a central place.
+ * Be sure to include the neccessary endpoint descriptors! */
+#define NUM_ENDPOINTS  2
+
+/*
+ * Normally, we would initialize the descriptor structures in C99 style:
+ *
+ * __code usb_device_descriptor_t device_descriptor = {
+ *   .bLength = foo,
+ *   .bDescriptorType = bar,
+ *   .bcdUSB = 0xABCD,
+ *   ...
+ * };
+ *
+ * But SDCC currently does not support this, so we have to do it the
+ * old-fashioned way...
+ */
+
+__code usb_device_descriptor_t device_descriptor = {
+  /* .bLength = */            sizeof(usb_device_descriptor_t),
+  /* .bDescriptorType = */     DESCRIPTOR_TYPE_DEVICE,
+  /* .bcdUSB = */              0x0110, /* BCD: 01.00 (Version 1.0 USB spec) */
+  /* .bDeviceClass = */        0xFF,   /* 0xFF = vendor-specific */
+  /* .bDeviceSubClass = */     0xFF,
+  /* .bDeviceProtocol = */     0xFF,
+  /* .bMaxPacketSize0 = */     64,
+  /* .idVendor = */            0xC251,
+  /* .idProduct = */           0x2710,
+  /* .bcdDevice = */           0x0100,
+  /* .iManufacturer = */       1,
+  /* .iProduct = */            2,
+  /* .iSerialNumber = */       3,
+  /* .bNumConfigurations = */  1
+};
+
+/* WARNING: ALL config, interface and endpoint descriptors MUST be adjacent! */
+
+__code usb_config_descriptor_t config_descriptor = {
+  /* .bLength = */             sizeof(usb_config_descriptor_t),
+  /* .bDescriptorType = */     DESCRIPTOR_TYPE_CONFIGURATION,
+  /* .wTotalLength = */        sizeof(usb_config_descriptor_t) +
+                               sizeof(usb_interface_descriptor_t) + 
+                               NUM_ENDPOINTS * sizeof(usb_endpoint_descriptor_t),
+  /* .bNumInterfaces = */      1,
+  /* .bConfigurationValue = */ 1,
+  /* .iConfiguration = */      4,     /* String describing this configuration */
+  /* .bmAttributes = */        0x80,  /* Only MSB set according to USB spec */
+  /* .MaxPower = */            50     /* 100 mA */
+};
+
+__code usb_interface_descriptor_t interface_descriptor00 = {
+  /* .bLength = */             sizeof(usb_interface_descriptor_t),
+  /* .bDescriptorType = */     DESCRIPTOR_TYPE_INTERFACE,
+  /* .bInterfaceNumber = */    0,
+  /* .bAlternateSetting = */   0,
+  /* .bNumEndpoints = */       NUM_ENDPOINTS,
+  /* .bInterfaceClass = */     0xFF,
+  /* .bInterfaceSubclass = */  0xFF,
+  /* .bInterfaceProtocol = */  0xFF,
+  /* .iInterface = */          0
+};
+
+__code usb_endpoint_descriptor_t Bulk_EP2_IN_Endpoint_Descriptor = {
+  /* .bLength = */             sizeof(usb_endpoint_descriptor_t),
+  /* .bDescriptorType = */     0x05,
+  /* .bEndpointAddress = */    2 | USB_DIR_IN,
+  /* .bmAttributes = */        0x02,
+  /* .wMaxPacketSize = */      64,
+  /* .bInterval = */           0
+};
+
+__code usb_endpoint_descriptor_t Bulk_EP2_OUT_Endpoint_Descriptor = {
+  /* .bLength = */             sizeof(usb_endpoint_descriptor_t),
+  /* .bDescriptorType = */     0x05,
+  /* .bEndpointAddress = */    2 | USB_DIR_OUT,
+  /* .bmAttributes = */        0x02,
+  /* .wMaxPacketSize = */      64,
+  /* .bInterval = */           0
+};
+
+__code usb_language_descriptor_t language_descriptor = {
+  /* .bLength =  */            4,
+  /* .bDescriptorType = */     DESCRIPTOR_TYPE_STRING,
+  /* .wLANGID = */             {0x0409 /* US English */}
+};
+
+__code usb_string_descriptor_t strManufacturer = STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
+__code usb_string_descriptor_t strProduct      = STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
+__code usb_string_descriptor_t strSerialNumber = STR_DESCR(6, '0','0','0','0','0','1');
+__code usb_string_descriptor_t strConfigDescr  = STR_DESCR(12, 'J','T','A','G',' ','A','d','a','p','t','e','r');
+
+/* Table containing pointers to string descriptors */
+__code usb_string_descriptor_t* __code en_string_descriptors[4] = {
+  &strManufacturer,
+  &strProduct,
+  &strSerialNumber,
+  &strConfigDescr
+};
+
+void sudav_isr(void) __interrupt SUDAV_ISR
+{
+  CLEAR_IRQ();
+
+  usb_handle_setup_data();
+
+  USBIRQ = SUDAVIR;
+  EP0CS |= HSNAK;
+}
+
+void sof_isr(void)      __interrupt SOF_ISR      { }
+void sutok_isr(void)    __interrupt SUTOK_ISR    { }
+void suspend_isr(void)  __interrupt SUSPEND_ISR  { }
+void usbreset_isr(void) __interrupt USBRESET_ISR { }
+void ibn_isr(void)      __interrupt IBN_ISR      { }
+
+void ep0in_isr(void)    __interrupt EP0IN_ISR    { }
+void ep0out_isr(void)   __interrupt EP0OUT_ISR   { }
+void ep1in_isr(void)    __interrupt EP1IN_ISR    { }
+void ep1out_isr(void)   __interrupt EP1OUT_ISR   { }
+
+/**
+ * EP2 IN: called after the transfer from uC->Host has finished: we sent data
+ */
+void ep2in_isr(void)    __interrupt EP2IN_ISR { 
+  EP2_in = 1;
+
+  CLEAR_IRQ();
+  IN07IRQ = IN2IR;     // Clear OUT2 IRQ
+}
+
+/**
+ * EP2 OUT: called after the transfer from Host->uC has finished: we got data
+ */
+void ep2out_isr(void)   __interrupt EP2OUT_ISR {
+  EP2_out = 1;
+
+  CLEAR_IRQ();
+  OUT07IRQ = OUT2IR;    // Clear OUT2 IRQ
+}
+
+void ep3in_isr(void)    __interrupt EP3IN_ISR    { }
+void ep3out_isr(void)   __interrupt EP3OUT_ISR   { }
+void ep4in_isr(void)    __interrupt EP4IN_ISR    { }
+void ep4out_isr(void)   __interrupt EP4OUT_ISR   { }
+void ep5in_isr(void)    __interrupt EP5IN_ISR    { }
+void ep5out_isr(void)   __interrupt EP5OUT_ISR   { }
+void ep6in_isr(void)    __interrupt EP6IN_ISR    { }
+void ep6out_isr(void)   __interrupt EP6OUT_ISR   { }
+void ep7in_isr(void)    __interrupt EP7IN_ISR    { }
+void ep7out_isr(void)   __interrupt EP7OUT_ISR   { }
+
+/**
+ * Return the control/status register for an endpoint
+ *
+ * @param ep endpoint address
+ * @return on success: pointer to Control & Status register for endpoint
+ *  specified in \a ep
+ * @return on failure: NULL
+ */
+__xdata u8* usb_get_endpoint_cs_reg(u8 ep)
+{
+  /* Mask direction bit */
+  u8 ep_num = ep & 0x7F;
+
+  switch (ep_num) {
+  case 0:
+    return &EP0CS;
+    break;
+  case 1:
+    return ep & 0x80 ? &IN1CS : &OUT1CS;
+    break;
+  case 2:
+    return ep & 0x80 ? &IN2CS : &OUT2CS;
+    break;
+  case 3:
+    return ep & 0x80 ? &IN3CS : &OUT3CS;
+    break;
+  case 4:
+    return ep & 0x80 ? &IN4CS : &OUT4CS;
+    break;
+  case 5:
+    return ep & 0x80 ? &IN5CS : &OUT5CS;
+    break;
+  case 6:
+    return ep & 0x80 ? &IN6CS : &OUT6CS;
+    break;
+  case 7:
+    return ep & 0x80 ? &IN7CS : &OUT7CS;
+    break;
+  }
+
+  return NULL;
+}
+
+void usb_reset_data_toggle(u8 ep)
+{
+  /* TOGCTL register:
+     +----+-----+-----+------+-----+-------+-------+-------+
+     | Q  |  S  |  R  |  IO  |  0  |  EP2  |  EP1  |  EP0  |
+     +----+-----+-----+------+-----+-------+-------+-------+
+
+     To reset data toggle bits, we have to write the endpoint direction (IN/OUT)
+     to the IO bit and the endpoint number to the EP2..EP0 bits. Then, in a
+     separate write cycle, the R bit needs to be set.
+  */
+  u8 togctl_value = (ep & 0x80 >> 3) | (ep & 0x7);
+
+  /* First step: Write EP number and direction bit */
+  TOGCTL = togctl_value;
+
+  /* Second step: Set R bit */
+  togctl_value |= TOG_R;
+  TOGCTL = togctl_value;
+}
+
+/**
+ * Handle GET_STATUS request.
+ *
+ * @return on success: true
+ * @return on failure: false
+ */
+bool usb_handle_get_status(void)
+{
+  u8 *ep_cs;
+
+  switch (setup_data.bmRequestType) {
+  case GS_DEVICE:
+    /* Two byte response: Byte 0, Bit 0 = self-powered, Bit 1 = remote wakeup.
+     *                    Byte 1: reserved, reset to zero */
+    IN0BUF[0] = 0;
+    IN0BUF[1] = 0;
+
+    /* Send response */
+    IN0BC = 2;
+    break;
+  case GS_INTERFACE:
+    /* Always return two zero bytes according to USB 1.1 spec, p. 191 */
+    IN0BUF[0] = 0;
+    IN0BUF[1] = 0;
+
+    /* Send response */
+    IN0BC = 2;
+    break;
+  case GS_ENDPOINT:
+    /* Get stall bit for endpoint specified in low byte of wIndex */
+    ep_cs = usb_get_endpoint_cs_reg(setup_data.wIndex & 0xff);
+
+    if (*ep_cs & EPSTALL) {
+      IN0BUF[0] = 0x01;
+    }
+    else {
+      IN0BUF[0] = 0x00;
+    }
+
+    /* Second byte sent has to be always zero */
+    IN0BUF[1] = 0;
+
+    /* Send response */
+    IN0BC = 2;
+    break;
+  default:
+    return false;
+    break;
+  }
+
+  return true;
+}
+
+/**
+ * Handle CLEAR_FEATURE request.
+ *
+ * @return on success: true
+ * @return on failure: false
+ */
+bool usb_handle_clear_feature(void)
+{
+  __xdata u8 *ep_cs;
+
+  switch (setup_data.bmRequestType) {
+  case CF_DEVICE:
+    /* Clear remote wakeup not supported: stall EP0 */
+    STALL_EP0();
+    break;
+  case CF_ENDPOINT:
+    if (setup_data.wValue == 0) {
+      /* Unstall the endpoint specified in wIndex */
+      ep_cs = usb_get_endpoint_cs_reg(setup_data.wIndex);
+      if (!ep_cs) {
+        return false;
+      }
+      *ep_cs &= ~EPSTALL;
+    }
+    else {
+      /* Unsupported feature, stall EP0 */
+      STALL_EP0();
+    }
+    break;
+  default:
+    /* Vendor commands... */
+  }
+
+  return true;
+}
+
+/**
+ * Handle SET_FEATURE request.
+ *
+ * @return on success: true
+ * @return on failure: false
+ */
+bool usb_handle_set_feature(void)
+{
+  __xdata u8 *ep_cs;
+
+  switch (setup_data.bmRequestType) {
+  case SF_DEVICE:
+    if (setup_data.wValue == 2) {
+      return true;
+    }
+    break;
+  case SF_ENDPOINT:
+    if (setup_data.wValue == 0) {
+      /* Stall the endpoint specified in wIndex */
+      ep_cs = usb_get_endpoint_cs_reg(setup_data.wIndex);
+      if (!ep_cs) {
+        return false;
+      }
+      *ep_cs |= EPSTALL;
+    }
+    else {
+      /* Unsupported endpoint feature */
+      return false;
+    }
+    break;
+  default:
+    /* Vendor commands... */
+    break;
+  }
+
+  return true;
+}
+
+/**
+ * Handle GET_DESCRIPTOR request.
+ *
+ * @return on success: true
+ * @return on failure: false
+ */
+bool usb_handle_get_descriptor(void)
+{
+  __xdata u8 descriptor_type;
+  __xdata u8 descriptor_index;
+
+  descriptor_type = (setup_data.wValue & 0xff00) >> 8;
+  descriptor_index = setup_data.wValue & 0x00ff;
+
+  switch (descriptor_type) {
+  case DESCRIPTOR_TYPE_DEVICE:
+    SUDPTRH = HI8(&device_descriptor);
+    SUDPTRL = LO8(&device_descriptor);
+    break;
+  case DESCRIPTOR_TYPE_CONFIGURATION:
+    SUDPTRH = HI8(&config_descriptor);
+    SUDPTRL = LO8(&config_descriptor);
+    break;
+  case DESCRIPTOR_TYPE_STRING:
+    if (setup_data.wIndex == 0) {
+      /* Supply language descriptor */
+      SUDPTRH = HI8(&language_descriptor);
+      SUDPTRL = LO8(&language_descriptor);
+    }
+    else if (setup_data.wIndex == 0x0409 /* US English */) {
+      /* Supply string descriptor */
+      SUDPTRH = HI8(en_string_descriptors[descriptor_index - 1]);
+      SUDPTRL = LO8(en_string_descriptors[descriptor_index - 1]);
+    }
+    else {
+      return false;
+    }
+    break;
+  default:
+    /* Unsupported descriptor type */
+    return false;
+    break;
+  }
+
+  return true;
+}
+
+/**
+ * Handle SET_INTERFACE request.
+ */
+void usb_handle_set_interface(void)
+{
+  /* Reset Data Toggle */
+  usb_reset_data_toggle(USB_DIR_IN  | 2);
+  usb_reset_data_toggle(USB_DIR_OUT | 2);
+
+  /* Unstall & clear busy flag of all valid IN endpoints */
+  IN2CS = 0 | EPBSY;
+  
+  /* Unstall all valid OUT endpoints, reset bytecounts */
+  OUT2CS = 0;
+  OUT2BC = 0;
+}
+
+/**
+ * Handle the arrival of a USB Control Setup Packet.
+ */
+void usb_handle_setup_data(void)
+{
+  switch (setup_data.bRequest) {
+    case GET_STATUS:
+      if (!usb_handle_get_status()) {
+        STALL_EP0();
+      }
+      break;
+    case CLEAR_FEATURE:
+      if (!usb_handle_clear_feature()) {
+        STALL_EP0();
+      }
+      break;
+    case 2: case 4:
+      /* Reserved values */
+      STALL_EP0();
+      break;
+    case SET_FEATURE:
+      if (!usb_handle_set_feature()) {
+        STALL_EP0();
+      }
+      break;
+    case SET_ADDRESS:
+      /* Handled by USB core */
+      break;
+    case SET_DESCRIPTOR:
+      /* Set Descriptor not supported. */
+      STALL_EP0();
+      break;
+    case GET_DESCRIPTOR:
+      if (!usb_handle_get_descriptor()) {
+        STALL_EP0();
+      }
+      break;
+    case GET_CONFIGURATION:
+      /* OpenULINK has only one configuration, return its index */
+      IN0BUF[0] = config_descriptor.bConfigurationValue;
+      IN0BC = 1;
+      break;
+    case SET_CONFIGURATION:
+      /* OpenULINK has only one configuration -> nothing to do */
+      break;
+    case GET_INTERFACE:
+      /* OpenULINK only has one interface, return its number */
+      IN0BUF[0] = interface_descriptor00.bInterfaceNumber;
+      IN0BC = 1;
+      break;
+    case SET_INTERFACE:
+      usb_handle_set_interface();
+      break;
+    case SYNCH_FRAME:
+      /* Isochronous endpoints not used -> nothing to do */
+      break;
+    default:
+      /* Any other requests: do nothing */
+      break;
+  }
+}
+
+/**
+ * USB initialization. Configures USB interrupts, endpoints and performs
+ * ReNumeration.
+ */
+void usb_init(void) {
+  /* Mark endpoint 2 IN & OUT as valid */
+  IN07VAL  = IN2VAL;
+  OUT07VAL = OUT2VAL;
+
+  /* Make sure no isochronous endpoints are marked valid */
+  INISOVAL  = 0;
+  OUTISOVAL = 0;
+
+  /* Disable isochronous endpoints. This makes the isochronous data buffers
+   * available as 8051 XDATA memory at address 0x2000 - 0x27FF */
+  ISOCTL = ISODISAB;
+
+  /* Enable USB Autovectoring */
+  USBBAV |= AVEN;
+  
+  /* Enable SUDAV interrupt */
+  USBIEN |= SUDAVIE;
+
+  /* Enable EP2 OUT & IN interrupts */
+  OUT07IEN = OUT2IEN;
+  IN07IEN  = IN2IEN;
+
+  /* Enable USB interrupt (EIE register) */
+  EUSB = 1;
+
+  /* Perform ReNumeration */
+  USBCS = DISCON | RENUM;
+  delay_ms(200);
+  USBCS = DISCOE | RENUM;
+}
diff --git a/src/jtag/drivers/OpenULINK/ulink_firmware.hex b/src/jtag/drivers/OpenULINK/ulink_firmware.hex
new file mode 100644
index 0000000..9e74423
--- /dev/null
+++ b/src/jtag/drivers/OpenULINK/ulink_firmware.hex
@@ -0,0 +1,251 @@
+:040000000200733255
+:01000B0032C2
+:0100130032BA
+:01001B0032B2
+:0100230032AA
+:01002B0032A2
+:01003300329A
+:01003B003292
+:01004300328A
+:01004B003282
+:01005300327A
+:01005B003272
+:01006300326A
+:03006B0002011F70
+:0300D90002006EB4
+:05006E0012011080FEEC
+:1000DC00907F937404F0907F9C7495F0907F96744D
+:1000EC0090F0907F94E4F0907F9D747FF0907F97D8
+:1000FC00E4F0907F957440F0907F9E7442F0907F76
+:10010C0098E4F0221200DC1204FCD2AF1207C89063
+:03011C00000022BE
+:0400CC00C200C201AB
+:10011F00C021C0E0C0F0C082C083C002C003C004D1
+:10012F00C005C006C007C000C001C0D075D00053C5
+:10013F0091EF120455907FAB7401F0907FB4E044BF
+:10014F0002F0D0D0D001D000D007D006D005D00417
+:10015F00D003D002D083D082D0F0D0E0D021323281
+:10016F003232323232323232C0E0C082C083D201F8
+:10017F005391EF907FA97404F0D083D082D0E032F6
+:10018F00C0E0C082C083D2005391EF907FAA740465
+:10019F00F0D083D082D0E032323232323232323249
+:1001AF003232AA82747F5AFB7407B50300500302E0
+:1001BF000269EB2B2B9001C8730201E00201E402EC
+:1001CF0001F702020A02021D02023002024302027A
+:1001DF0056907FB422EA30E7067BB67C7F80047BA3
+:1001EF00C67C7F8B828C8322EA30E7067BB87C7FCC
+:1001FF0080047BC87C7F8B828C8322EA30E7067B6E
+:10020F00BA7C7F80047BCA7C7F8B828C8322EA300E
+:10021F00E7067BBC7C7F80047BCC7C7F8B828C83CE
+:10022F0022EA30E7067BBE7C7F80047BCE7C7F8B0F
+:10023F00828C8322EA30E7067BC07C7F80047BD0F0
+:10024F007C7F8B828C8322EA30E7067AC27B7F80A9
+:10025F00047AD27B7F8A828B832290000022AA822B
+:10026F0074105AFB74075A4203907FD7EBF0742037
+:10027F004BF022907FE8E0FABA8002800ABA81023E
+:10028F008016BA825D8022907F00E4F0907F01F0AB
+:10029F00907FB57402F0804C907F00E4F0907F0166
+:1002AF00F0907FB57402F0803B907FECE0FAA3E012
+:1002BF008A821201B1AA82AB837C008A828B838CE3
+:1002CF00F0120D90FA30E008907F007401F0800575
+:1002DF00907F00E4F0907F01E4F0907FB57402F01E
+:1002EF008002C322D322907FE8E0FA6005BA02466B
+:1002FF00800A907FB4E0FA4401F0803A907FEAE000
+:10030F00FAA3E0FB4A7027907FECE0FAA3E08A8221
+:10031F001201B1AA82AB83EA4B7002C3228A828B8D
+:10032F0083E0FC5304FE8A828B83ECF08008907F7D
+:10033F00B4E0FA4401F0D322907FE8E0FA6005BA06
+:10034F0002468010907FEAE0FAA3E0FBBA0239BBC5
+:10035F000036D322907FEAE0FAA3E0FB4A702790A1
+:10036F007FECE0FAA3E08A821201B1AA82AB83EAA2
+:10037F004B7002C3228A828B83E0FC4304018A8282
+:10038F008B83ECF08002C322D322907FEAE0A3E0BC
+:10039F00FA907FEAE0FBA3E07C00BA0102800CBA7E
+:1003AF000202801DBA0302802E807B7AB07C0D90F2
+:1003BF007FD4ECF07AB07C0D7C00907FD5EAF08092
+:1003CF00677AC27C0D907FD4ECF07AC27C0D7C00F2
+:1003DF00907FD5EAF08051907FECE0FAA3E0FC4AE1
+:1003EF0070167AE27C0D907FD4ECF07AE27C0D7C73
+:1003FF0000907FD5EAF08030907FECE0FAA3E0FC2C
+:10040F00BA0921BC041E1BEB2BFA900E3693CAA31C
+:10041F0093FB8A048B05907FD4EDF07B00907FD502
+:10042F00EAF08004C322C322D32275828212026DA6
+:10043F0075820212026D907FB87402F0907FC8E44B
+:10044F00F0907FC9F022907FE9E0FA740CB50200BA
+:10045F00500122EA2A2A9004697302049002049E32
+:10046F000204AC0204B40204AC0204C10204CA02C6
+:10047F0004C20204D70204E70204E80204F80204EB
+:10048F00FB120282500122907FB4E04401F022124D
+:10049F0002F5500122907FB4E04401F022907FB426
+:1004AF00E04401F0221203474042907FB4E0440140
+:1004BF00F02222907FB4E04401F022120399402CE5
+:1004CF00907FB4E04401F022900DC7E493907F0039
+:1004DF00F0907FB57401F02222900DCDE493907FC0
+:1004EF0000F0907FB57401F02212043922907FDE64
+:1004FF007404F0907FDF7404F0907FE0E4F0907F5D
+:10050F00E1F0907FA17401F0907FAFE04401F09093
+:10051F007FAEE04401F0907FAD7404F0907FAC7437
+:10052F0004F0D2E8907FD6740AF09000C8120D3D07
+:07053F00907FD67406F02244
+:100DB00012011001FFFFFF4051C210270001010284
+:100DC000030109022000010104803209040000022D
+:100DD000FFFFFF00070582024000000705020240F6
+:100DE00000000403090414034F00700065006E0046
+:100DF00055004C0049004E004B0014034F0070009A
+:100E000065006E0055004C0049004E004B000E037B
+:100E10003000300030003000300031001A034A004A
+:100E20005400410047002000410064006100700050
+:0E0E3000740065007200E60DFA0D0E0E1C0E29
+:10054600E5080424C0F582E4347DF583E0FA30E161
+:1005560008907F96E0FB54EFF0EA30E008907F9633
+:10056600E0FB547FF0EA30E308907F96E0FB44100E
+:10057600F0EA30E208907F96E0FA4480F0227A00B2
+:10058600E50824C0F582E4347DF583E0FB603EBBDC
+:100596000202805FBB040302061CBB200302064363
+:1005A600BB2203020673BB23030206ACBB24030271
+:1005B60006E5BB250302071DBB260302074CBB2825
+:1005C6000302077BBB290302078A02078E7B05E528
+:1005D600080424C0F582E4347DF583E0FAE50804D6
+:1005E600F58285090DC002C003120805D003D002AA
+:1005F600020790E5080424C0F582E4347DF583E023
+:100606002405FBE50804F582C002C003120951D097
+:1006160003D002020790E5080424C0F582E4347D85
+:10062600F583E0FA2405FBE50804F582850917C081
+:1006360002C003120A83D003D0020207907B02E5B0
+:10064600080424C0F582E4347DF583E0FC740225B9
+:100656000824C0F582E4347DF583E0F5228C82C05F
+:1006660002C003120C5BD003D0020207907B02E5A6
+:10067600080424C0F582E4347DF583E0FC7D007433
+:1006860002250824C0F582E4347DF583E0FFE442C8
+:1006960004EF42058C828D83C002C003120C20D069
+:1006A60003D0020207907B02E5080424C0F582E429
+:1006B600347DF583E0FC7D007402250824C0F582B4
+:1006C600E4347DF583E0FFE44204EF42058C828D3D
+:1006D60083C002C003120D0AD003D0020207907B2A
+:1006E60002E5080424C0F582E4347DF583E0FC7D50
+:1006F600007402250824C0F582E4347DF583E0FF0A
+:10070600E44204EF42058C828D83C002C003120DC1
+:100716003DD003D00280737B007A02C002C0031270
+:100726000C95AC82AD83D003D00285098275837E99
+:100736008D06EEF0E509042400F582E4347EF583A7
+:100746007D00ECF080447B02E5080424C0F582E4D9
+:10075600347DF583E0FC7402250824C0F582E43478
+:100766007DF583E0F5228C82C002C003120CD8D03E
+:1007760003D00280157B01C002C003120546D003D8
+:10078600D00280067B0180027B00EA2509F509AAD2
+:10079600087C008B057E00ED2AFAEE3CFC0ABA00C6
+:1007A600010C907FC9E0FD7E00C3EA9DEC64808E5B
+:1007B600F063F08095F04002D322EB042508F5089B
+:1007C600C32275080075090010000280FB907F9611
+:1007D600E0FA547FF0C202200207120584920280DA
+:1007E600F6907F96E0FA4480F0E509600B907FB9B9
+:0F07F600E509F010010280FB907FC9E4F080C399
+:0900D000750A00750B00750C00A7
+:10080500E582FA24C0F582E4347DF583E0F50EEA4D
+:100815000424C0F582E4347DF583E0F50F74022AE3
+:10082500FD24C0F582E4347DF583E0C4540FFE5306
+:10083500060FED24C0F582E4347DF583E0FD740FE9
+:100845005DF51074032A24C0F582E4347DF583E058
+:10085500FF74042A24C0F582E4347DF583E0F511A4
+:10086500EE60078F228E82120C5B907F97E0FE531D
+:1008750006F87F0074044EF87900AD0E7B001DBDAF
+:10088500FF011B89027C00C3EA9DEC64808BF06349
+:10089500F08095F050357A007B00BB080050199028
+:1008A5007F97EEF0E8F0EAC313FA907F99E0FC3009
+:1008B500E5034302800B80E2E50D292400F582E47F
+:1008C500347EF583EAF009890780AF89077A00ABA2
+:1008D50010751200E512B50F00503EAD0F78001DE2
+:1008E500BDFF0118A9127C00E9B50511ECB5000D95
+:1008F500EB600A4306021BE511C313F511907F97C0
+:10090500EEF074044EF0EAC313FA907F99E0FC30E0
+:10091500E503430280051280BBAC0F7D007408C35C
+:100925009CFCE49DFD8CF005F0EA8002C313D5F034
+:10093500FBFAE50D2F2400F582E4347EF583EAF019
+:10094500EB60088511228B82020C5B22E582FA247A
+:10095500C0F582E4347DF583E0F513EA0424C0F59F
+:1009650082E4347DF583E0F51474022AFD24C0F594
+:1009750082E4347DF583E0C4540FFE53060FED2465
+:10098500C0F582E4347DF583E0FD740F5DF51574E3
+:10099500032A24C0F582E4347DF583E0FF74042A3C
+:1009A50024C0F582E4347DF583E0F516EE600B8F07
+:1009B500228E82C002120C5BD002907F97E0FE531C
+:1009C50006F97F00A9137D0019B9FF011D8F037872
+:1009D50000C3EB99E864808DF063F08095F05038A2
+:1009E500EA2F240524C0F582E4347DF583E0FB7D00
+:1009F50000BD0800501FEB30E0054306018003539E
+:100A050006FE907F97EEF0EBC313FB907F9774047F
+:100A15004EF00D80DC0F80ACEA2F240524C0F58252
+:100A2500E4347DF583E0FBAA157D00EDB514005097
+:100A350041EB30E00543060180035306FEAF147811
+:100A4500001FBFFF01188D017C00E9B50711ECB54A
+:100A5500000DEA600A4306021AE516C313F516905F
+:100A65007F97EEF0EBC313FB907F9774044EF00D68
+:100A750080B9EA60088516228A82020C5B22E5822B
+:100A8500F51824C0F582E4347DF583E0F519E51801
+:100A95000424C0F582E4347DF583E0F51A7402255B
+:100AA50018FD24C0F582E4347DF583E0C4540FFEBF
+:100AB50053060FED24C0F582E4347DF583E0FD7423
+:100AC5000F5DF51B7403251824C0F582E4347DF50C
+:100AD50083E0FF7404251824C0F582E4347DF58392
+:100AE500E0F51CEE60078F228E82120C5B907F97DB
+:100AF500E0FE5306F97F007900AD197B001DBDFFAF
+:100B0500011B89007A00C3E89DEA64808BF063F0DD
+:100B15008095F0505EE51829240524C0F582E4345B
+:100B25007DF583E0F51D7B007D00BD08005031E5B6
+:100B35001D30E00543060180035306FE907F97EEC6
+:100B4500F0E51DC313F51D907F9774044EF0EBC3BC
+:100B550013FB907F99E0F830E5034303800D80CACD
+:100B6500E517292400F582E4347EF583EBF0098945
+:100B75000780868907E51829240524C0F582E43411
+:100B85007DF583E0F51D7B00AD1B751E00E51EB5EB
+:100B95001A005054E51D30E0054306018003530655
+:100BA500FEA91A7C0019B9FF011CA81E7A00E8B538
+:100BB5000111EAB5040DED600A4306021DE51CC3EB
+:100BC50013F51C907F97EEF0E51DC313F51D907F7F
+:100BD5009774044EF0EBC313FB907F99E0FA30E570
+:100BE50003430380051E80A5AC1A7A007408C39CD4
+:100BF500FCE49AFA8CF005F0EB8002C313D5F0FB08
+:100C0500FBE5172F2400F582E4347EF583EBF0ED48
+:100C15006008851C228D82020C5B22AA82AB837C34
+:100C2500007D00C3EC9AED9B502B907F97E054FB21
+:100C3500F07E00EEB50B0050030E80F7907F97E035
+:100C45004404F07E00EEB50B0050030E80F70CBC9B
+:100C550000D10D80CE22AA82907F97E0FB74FB5BCA
+:100C6500F5237B00EBB502005024E52230E0054377
+:100C7500230280035323FD907F97E523F0E522C3EC
+:100C850013F522907F9774044523F00B80D622221A
+:100C95007A00907F99E0FB30E5027A01907F99E038
+:100CA500FB30E603430202907F9AE0FB30E7034303
+:100CB5000204907F9BE0FB30E503430208907F9A96
+:100CC500E0FB53037F8A04E4FAFDEB4AF582ED4C21
+:100CD500F58322E582547FF4FA907F97E05AF07409
+:100CE5007F5522FA907F97E04AF02285820A852275
+:100CF5000B85230C2200227A567B021ABAFF011BB0
+:100D0500EA4B70F722752205752300120D67AA823A
+:100D1500AB837C007D00C3EC9AED9B501AC002C0EA
+:100D250003C004C005120CFAD005D004D003D002CC
+:100D35000CBC00E20D80DF22AA82AB837C007D0023
+:100D4500C3EC9AED9B501AC002C003C004C0051243
+:100D55000CFCD005D004D003D0020CBC00E20D8001
+:020D6500DF228B
+:03004300021B009D
+:101B000002011F0002016E0002016F00020170005D
+:101B100002017100020172000201730002017400EF
+:101B200002017500020176000201770002018F00B8
+:101B30000201A7000201A8000201A9000201AA00F7
+:101B40000201AB000201AC000201AD000201AE00D7
+:081B50000201AF000201B00028
+:100D67007A10E4FBFCE58225E0F582E58333F58321
+:100D7700EB33FBEC33FCEB9522F5F0EC95234006C7
+:090D8700FCABF0438201DADD222D
+:0600A200E478FFF6D8FD32
+:100080007900E94400601B7A00900E3E780075927A
+:1000900020E493F2A308B800020592D9F4DAF275CD
+:0200A00092FFCD
+:1000A8007800E84400600A7900759220E4F309D8E2
+:1000B800FC7800E84400600C7900902000E4F0A38C
+:0400C800D8FCD9FA8D
+:0D007300758123120DACE582600302006E62
+:100D900020F71430F6148883A88220F507E6A8838C
+:100DA00075830022E280F7E49322E022758200221C
+:00000001FF

commit 03e4ae8481953613a3f562ef9b69bd77b624ca50
Author: Martin Schm??lzer <martin.schmoelzer at student.tuwien.ac.at>
Date:   Mon Jun 20 19:48:40 2011 +0200

    Add source code for new ULINK driver

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
new file mode 100644
index 0000000..0e04fd6
--- /dev/null
+++ b/src/jtag/drivers/ulink.c
@@ -0,0 +1,1890 @@
+/***************************************************************************
+ *   Copyright (C) 2011 by Martin Schmoelzer                               *
+ *   <martin.schmoelzer at student.tuwien.ac.at>                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+#include <target/image.h>
+#include <helper/types.h>
+#include "usb_common.h"
+#include "OpenULINK/include/msgtypes.h"
+
+/** USB Vendor ID of ULINK device in unconfigured state (no firmware loaded
+ *  yet) or with OpenULINK firmware. */
+#define ULINK_VID                0xC251
+
+/** USB Product ID of ULINK device in unconfigured state (no firmware loaded
+ *  yet) or with OpenULINK firmware. */
+#define ULINK_PID                0x2710
+
+/** Address of EZ-USB CPU Control & Status register. This register can be
+ *  written by issuing a Control EP0 vendor request. */
+#define CPUCS_REG                0x7F92
+
+/** USB Control EP0 bRequest: "Firmware Load". */
+#define REQUEST_FIRMWARE_LOAD    0xA0
+
+/** Value to write into CPUCS to put EZ-USB into reset. */
+#define CPU_RESET                0x01
+
+/** Value to write into CPUCS to put EZ-USB out of reset. */
+#define CPU_START                0x00
+
+/** Base address of firmware in EZ-USB code space. */
+#define FIRMWARE_ADDR            0x0000
+
+/** USB interface number */
+#define USB_INTERFACE            0
+
+/** libusb timeout in ms */
+#define USB_TIMEOUT              5000
+
+/** Delay (in microseconds) to wait while EZ-USB performs ReNumeration. */
+#define ULINK_RENUMERATION_DELAY 1500000
+
+/** Location of OpenULINK firmware image. TODO: Provide some way of modifying
+ *  this path, maybe in a separate OpenOCD command? */
+#define ULINK_FIRMWARE_FILE      PKGLIBDIR "/OpenULINK/ulink_firmware.hex"
+
+/** Maximum size of a single firmware section. Entire EZ-USB code space = 8kB */
+#define SECTION_BUFFERSIZE       8192
+
+/** Tuning of OpenOCD SCAN commands split into multiple OpenULINK commands. */
+#define SPLIT_SCAN_THRESHOLD     10
+
+/** ULINK hardware type */
+enum ulink_type
+{
+  /** Original ULINK adapter, based on Cypress EZ-USB (AN2131):
+   *  Full JTAG support, no SWD support. */
+  ULINK_1,
+
+  /** Newer ULINK adapter, based on NXP LPC2148. Currently unsupported. */
+  ULINK_2,
+
+  /** Newer ULINK adapter, based on EZ-USB FX2 + FPGA. Currently unsupported. */
+  ULINK_PRO,
+
+  /** Newer ULINK adapter, possibly based on ULINK 2. Currently unsupported. */
+  ULINK_ME
+};
+
+enum ulink_payload_direction
+{
+  PAYLOAD_DIRECTION_OUT,
+  PAYLOAD_DIRECTION_IN
+};
+
+/**
+ * OpenULINK command (OpenULINK command queue element).
+ *
+ * For the OUT direction payload, things are quite easy: Payload is stored
+ * in a rather small array (up to 63 bytes), the payload is always allocated
+ * by the function generating the command and freed by ulink_clear_queue().
+ *
+ * For the IN direction payload, things get a little bit more complicated:
+ * The maximum IN payload size for a single command is 64 bytes. Assume that
+ * a single OpenOCD command needs to scan 256 bytes. This results in the
+ * generation of four OpenULINK commands. The function generating these
+ * commands shall allocate an uint8_t[256] array. Each command's #payload_in
+ * pointer shall point to the corresponding offset where IN data shall be
+ * placed, while #payload_in_start shall point to the first element of the 256
+ * byte array.
+ * - first command:  #payload_in_start + 0
+ * - second command: #payload_in_start + 64
+ * - third command:  #payload_in_start + 128
+ * - fourth command: #payload_in_start + 192
+ *
+ * The last command sets #needs_postprocessing to true.
+ */
+struct ulink_cmd {
+  uint8_t id;                 ///< ULINK command ID
+
+  uint8_t *payload_out;       ///< OUT direction payload data
+  uint8_t payload_out_size;   ///< OUT direction payload size for this command
+
+  uint8_t *payload_in_start;  ///< Pointer to first element of IN payload array
+  uint8_t *payload_in;        ///< Pointer where IN payload shall be stored
+  uint8_t payload_in_size;    ///< IN direction payload size for this command
+
+  /** Indicates if this command needs post-processing */
+  bool needs_postprocessing;
+
+  /** Indicates if ulink_clear_queue() should free payload_in_start  */
+  bool free_payload_in_start;
+
+  /** Pointer to corresponding OpenOCD command for post-processing */
+  struct jtag_command *cmd_origin;
+
+  struct ulink_cmd *next;    ///< Pointer to next command (linked list)
+};
+
+typedef struct ulink_cmd ulink_cmd_t;
+
+/** Describes one driver instance */
+struct ulink
+{
+  struct usb_dev_handle *usb_handle;
+  enum ulink_type type;
+
+  int commands_in_queue;     ///< Number of commands in queue
+  ulink_cmd_t *queue_start;  ///< Pointer to first command in queue
+  ulink_cmd_t *queue_end;    ///< Pointer to last command in queue
+};
+
+/**************************** Function Prototypes *****************************/
+
+/* USB helper functions */
+int ulink_usb_open(struct ulink **device);
+int ulink_usb_close(struct ulink **device);
+
+/* ULINK MCU (Cypress EZ-USB) specific functions */
+int ulink_cpu_reset(struct ulink *device, char reset_bit);
+int ulink_load_firmware_and_renumerate(struct ulink **device, char *filename,
+    uint32_t delay);
+int ulink_load_firmware(struct ulink *device, char *filename);
+int ulink_write_firmware_section(struct ulink *device,
+    struct image *firmware_image, int section_index);
+
+/* Generic helper functions */
+void ulink_print_signal_states(uint8_t input_signals, uint8_t output_signals);
+
+/* OpenULINK command generation helper functions */
+int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
+    enum ulink_payload_direction direction);
+
+/* OpenULINK command queue helper functions */
+int ulink_get_queue_size(struct ulink *device,
+    enum ulink_payload_direction direction);
+void ulink_clear_queue(struct ulink *device);
+int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd);
+int ulink_execute_queued_commands(struct ulink *device, int timeout);
+
+#ifdef _DEBUG_JTAG_IO_
+const char * ulink_cmd_id_string(uint8_t id);
+void ulink_print_command(ulink_cmd_t *ulink_cmd);
+void ulink_print_queue(struct ulink *device);
+#endif
+
+int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
+    int scan_size_bits, uint8_t *tdi, uint8_t *tdo_start, uint8_t *tdo,
+    uint8_t tms_count_start, uint8_t tms_sequence_start, uint8_t tms_count_end,
+    uint8_t tms_sequence_end, struct jtag_command *origin, bool postprocess);
+int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
+    uint8_t sequence);
+int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count);
+int ulink_append_get_signals_cmd(struct ulink *device);
+int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
+    uint8_t high);
+int ulink_append_sleep_cmd(struct ulink *device, uint32_t us);
+int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
+    uint8_t delay_tck, uint8_t delay_tms);
+int ulink_append_led_cmd(struct ulink *device, uint8_t led_state);
+int ulink_append_test_cmd(struct ulink *device);
+
+/* Interface between OpenULINK and OpenOCD */
+int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_statemove(struct ulink *device);
+int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd);
+
+static void ulink_set_end_state(tap_state_t endstate);
+
+int ulink_post_process_scan(ulink_cmd_t *ulink_cmd);
+int ulink_post_process_queue(struct ulink *device);
+
+/* JTAG driver functions (registered in struct jtag_interface) */
+static int ulink_execute_queue(void);
+static int ulink_khz(int khz, int *jtag_speed);
+static int ulink_speed(int speed);
+static int ulink_speed_div(int speed, int *khz);
+static int ulink_init(void);
+static int ulink_quit(void);
+
+/****************************** Global Variables ******************************/
+
+struct ulink *ulink_handle;
+
+/**************************** USB helper functions ****************************/
+
+/**
+ * Opens the ULINK device and claims its USB interface.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_usb_open(struct ulink **device)
+{
+  int ret;
+  struct usb_dev_handle *usb_handle;
+
+  /* Currently, only original ULINK is supported */
+  uint16_t vids[] = { ULINK_VID, 0 };
+  uint16_t pids[] = { ULINK_PID, 0 };
+
+  ret = jtag_usb_open(vids, pids, &usb_handle);
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  ret = usb_claim_interface(usb_handle, 0);
+
+  if (ret != 0) {
+    return ret;
+  }
+
+  (*device)->usb_handle = usb_handle;
+  (*device)->type = ULINK_1;
+
+  return ERROR_OK;
+}
+
+/**
+ * Releases the ULINK interface and closes the USB device handle.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_usb_close(struct ulink **device)
+{
+  if (usb_release_interface((*device)->usb_handle, 0) != 0) {
+    return ERROR_FAIL;
+  }
+
+  if (usb_close((*device)->usb_handle) != 0) {
+    return ERROR_FAIL;
+  }
+
+  (*device)->usb_handle = NULL;
+
+  return ERROR_OK;
+}
+
+/******************* ULINK CPU (EZ-USB) specific functions ********************/
+
+/**
+ * Writes '0' or '1' to the CPUCS register, putting the EZ-USB CPU into reset
+ * or out of reset.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param reset_bit 0 to put CPU into reset, 1 to put CPU out of reset.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_cpu_reset(struct ulink *device, char reset_bit)
+{
+  int ret;
+
+  ret = usb_control_msg(device->usb_handle,
+      (USB_ENDPOINT_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE),
+      REQUEST_FIRMWARE_LOAD, CPUCS_REG, 0, &reset_bit, 1, USB_TIMEOUT);
+
+  /* usb_control_msg() returns the number of bytes transferred during the
+   * DATA stage of the control transfer - must be exactly 1 in this case! */
+  if (ret != 1) {
+    return ERROR_FAIL;
+  }
+  return ERROR_OK;
+}
+
+/**
+ * Puts the ULINK's EZ-USB microcontroller into reset state, downloads
+ * the firmware image, resumes the microcontroller and re-enumerates
+ * USB devices.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ *  The usb_handle member will be modified during re-enumeration.
+ * @param filename path to the Intel HEX file containing the firmware image.
+ * @param delay the delay to wait for the device to re-enumerate.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_load_firmware_and_renumerate(struct ulink **device,
+    char *filename, uint32_t delay)
+{
+  int ret;
+
+  /* Basic process: After downloading the firmware, the ULINK will disconnect
+   * itself and re-connect after a short amount of time so we have to close
+   * the handle and re-enumerate USB devices */
+
+  ret = ulink_load_firmware(*device, filename);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  ret = ulink_usb_close(device);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  usleep(delay);
+
+  ret = ulink_usb_open(device);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  return ERROR_OK;
+}
+
+/**
+ * Downloads a firmware image to the ULINK's EZ-USB microcontroller
+ * over the USB bus.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param filename an absolute or relative path to the Intel HEX file
+ *  containing the firmware image.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_load_firmware(struct ulink *device, char *filename)
+{
+  struct image ulink_firmware_image;
+  int ret, i;
+
+  ret = ulink_cpu_reset(device, CPU_RESET);
+  if (ret != ERROR_OK) {
+    LOG_ERROR("Could not halt ULINK CPU");
+    return ret;
+  }
+
+  ulink_firmware_image.base_address = 0;
+  ulink_firmware_image.base_address_set = 0;
+
+  ret = image_open(&ulink_firmware_image, ULINK_FIRMWARE_FILE, "ihex");
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  /* Download all sections in the image to ULINK */
+  for (i = 0; i < ulink_firmware_image.num_sections; i++) {
+    ret = ulink_write_firmware_section(device, &ulink_firmware_image, i);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
+
+  image_close(&ulink_firmware_image);
+
+  ret = ulink_cpu_reset(device, CPU_START);
+  if (ret != ERROR_OK) {
+    LOG_ERROR("Could not restart ULINK CPU");
+    return ret;
+  }
+
+  return ERROR_OK;
+}
+
+/**
+ * Send one contiguous firmware section to the ULINK's EZ-USB microcontroller
+ * over the USB bus.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param firmware_image pointer to the firmware image that contains the section
+ *  which should be sent to the ULINK's EZ-USB microcontroller.
+ * @param section_index index of the section within the firmware image.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_write_firmware_section(struct ulink *device,
+    struct image *firmware_image, int section_index)
+{
+  uint16_t addr, size, bytes_remaining, chunk_size;
+  uint8_t data[SECTION_BUFFERSIZE];
+  uint8_t *data_ptr = data;
+  size_t size_read;
+  int ret;
+
+  size = (uint16_t)firmware_image->sections[section_index].size;
+  addr = (uint16_t)firmware_image->sections[section_index].base_address;
+
+  LOG_DEBUG("section %02i at addr 0x%04x (size 0x%04x)", section_index, addr,
+      size);
+
+  if (data == NULL) {
+    return ERROR_FAIL;
+  }
+
+  /* Copy section contents to local buffer */
+  ret = image_read_section(firmware_image, section_index, 0, size, data,
+      &size_read);
+
+  if ((ret != ERROR_OK) || (size_read != size)) {
+    /* Propagating the return code would return '0' (misleadingly indicating
+     * successful execution of the function) if only the size check fails. */
+    return ERROR_FAIL;
+  }
+
+  bytes_remaining = size;
+
+  /* Send section data in chunks of up to 64 bytes to ULINK */
+  while (bytes_remaining > 0) {
+    if (bytes_remaining > 64) {
+      chunk_size = 64;
+    }
+    else {
+      chunk_size = bytes_remaining;
+    }
+
+    ret = usb_control_msg(device->usb_handle,
+        (USB_ENDPOINT_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE),
+        REQUEST_FIRMWARE_LOAD, addr, FIRMWARE_ADDR, (char *)data_ptr,
+        chunk_size, USB_TIMEOUT);
+
+    if (ret != (int)chunk_size) {
+      /* Abort if libusb sent less data than requested */
+      return ERROR_FAIL;
+    }
+
+    bytes_remaining -= chunk_size;
+    addr += chunk_size;
+    data_ptr += chunk_size;
+  }
+
+  return ERROR_OK;
+}
+
+/************************** Generic helper functions **************************/
+
+/**
+ * Print state of interesting signals via LOG_INFO().
+ *
+ * @param input_signals input signal states as returned by CMD_GET_SIGNALS
+ * @param output_signals output signal states as returned by CMD_GET_SIGNALS
+ */
+void ulink_print_signal_states(uint8_t input_signals, uint8_t output_signals)
+{
+  LOG_INFO("ULINK signal states: TDI: %i, TDO: %i, TMS: %i, TCK: %i, TRST: %i,"
+      " SRST: %i",
+      (output_signals & SIGNAL_TDI   ? 1 : 0),
+      (input_signals  & SIGNAL_TDO   ? 1 : 0),
+      (output_signals & SIGNAL_TMS   ? 1 : 0),
+      (output_signals & SIGNAL_TCK   ? 1 : 0),
+      (output_signals & SIGNAL_TRST  ? 0 : 1),  // TRST and RESET are inverted
+      (output_signals & SIGNAL_RESET ? 0 : 1)); // by hardware
+}
+
+/**************** OpenULINK command generation helper functions ***************/
+
+/**
+ * Allocate and initialize space in memory for OpenULINK command payload.
+ *
+ * @param ulink_cmd pointer to command whose payload should be allocated.
+ * @param size the amount of memory to allocate (bytes).
+ * @param direction which payload to allocate.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
+    enum ulink_payload_direction direction)
+{
+  uint8_t *payload;
+
+  payload = calloc(size, sizeof(uint8_t));
+
+  if (payload == NULL) {
+    LOG_ERROR("Could not allocate OpenULINK command payload: out of memory");
+    return ERROR_FAIL;
+  }
+
+  switch (direction) {
+  case PAYLOAD_DIRECTION_OUT:
+    if (ulink_cmd->payload_out != NULL) {
+      LOG_ERROR("BUG: Duplicate payload allocation for OpenULINK command");
+      return ERROR_FAIL;
+    }
+    else {
+      ulink_cmd->payload_out = payload;
+      ulink_cmd->payload_out_size = size;
+    }
+    break;
+  case PAYLOAD_DIRECTION_IN:
+    if (ulink_cmd->payload_in_start != NULL) {
+      LOG_ERROR("BUG: Duplicate payload allocation for OpenULINK command");
+      return ERROR_FAIL;
+    }
+    else {
+      ulink_cmd->payload_in_start = payload;
+      ulink_cmd->payload_in = payload;
+      ulink_cmd->payload_in_size = size;
+
+      /* By default, free payload_in_start in ulink_clear_queue(). Commands
+       * that do not want this behavior (e. g. split scans) must turn it off
+       * separately! */
+      ulink_cmd->free_payload_in_start = true;
+    }
+    break;
+  }
+
+  return ERROR_OK;
+}
+
+/****************** OpenULINK command queue helper functions ******************/
+
+/**
+ * Get the current number of bytes in the queue, including command IDs.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param direction the transfer direction for which to get byte count.
+ * @return the number of bytes currently stored in the queue for the specified
+ *  direction.
+ */
+int ulink_get_queue_size(struct ulink *device,
+    enum ulink_payload_direction direction)
+{
+  ulink_cmd_t *current = device->queue_start;
+  int sum = 0;
+
+  while (current != NULL) {
+    switch (direction) {
+    case PAYLOAD_DIRECTION_OUT:
+      sum += current->payload_out_size + 1; // + 1 byte for Command ID
+      break;
+    case PAYLOAD_DIRECTION_IN:
+      sum += current->payload_in_size;
+      break;
+    }
+
+    current = current->next;
+  }
+
+  return sum;
+}
+
+/**
+ * Clear the OpenULINK command queue.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+void ulink_clear_queue(struct ulink *device)
+{
+  ulink_cmd_t *current = device->queue_start;
+  ulink_cmd_t *next = NULL;
+
+  while (current != NULL) {
+    /* Save pointer to next element */
+    next = current->next;
+
+    /* Free payloads: OUT payload can be freed immediately */
+    free(current->payload_out);
+    current->payload_out = NULL;
+
+    /* IN payload MUST be freed ONLY if no other commands use the
+     * payload_in_start buffer */
+    if (current->free_payload_in_start == true) {
+      free(current->payload_in_start);
+      current->payload_in_start = NULL;
+      current->payload_in = NULL;
+    }
+
+    /* Free queue element */
+    free(current);
+
+    /* Proceed with next element */
+    current = next;
+  }
+
+  device->commands_in_queue = 0;
+  device->queue_start = NULL;
+  device->queue_end = NULL;
+}
+
+/**
+ * Add a command to the OpenULINK command queue.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param ulink_cmd pointer to command that shall be appended to the OpenULINK
+ *  command queue.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd)
+{
+  int newsize_out, newsize_in;
+  int ret;
+
+  newsize_out = ulink_get_queue_size(device, PAYLOAD_DIRECTION_OUT) + 1
+      + ulink_cmd->payload_out_size;
+
+  newsize_in = ulink_get_queue_size(device, PAYLOAD_DIRECTION_IN)
+      + ulink_cmd->payload_in_size;
+
+  /* Check if the current command can be appended to the queue */
+  if ((newsize_out > 64) || (newsize_in > 64)) {
+    /* New command does not fit. Execute all commands in queue before starting
+     * new queue with the current command as first entry. */
+    ret = ulink_execute_queued_commands(device, USB_TIMEOUT);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ret = ulink_post_process_queue(device);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ulink_clear_queue(device);
+  }
+
+  if (device->queue_start == NULL) {
+    /* Queue was empty */
+    device->commands_in_queue = 1;
+
+    device->queue_start = ulink_cmd;
+    device->queue_end = ulink_cmd;
+  }
+  else {
+    /* There are already commands in the queue */
+    device->commands_in_queue++;
+
+    device->queue_end->next = ulink_cmd;
+    device->queue_end = ulink_cmd;
+  }
+
+  return ERROR_OK;
+}
+
+/**
+ * Sends all queued OpenULINK commands to the ULINK for execution.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_execute_queued_commands(struct ulink *device, int timeout)
+{
+  ulink_cmd_t *current;
+  int ret, i, index_out, index_in, count_out, count_in;
+  uint8_t buffer[64];
+
+#ifdef _DEBUG_JTAG_IO_
+  ulink_print_queue(device);
+#endif
+
+  index_out = 0;
+  count_out = 0;
+  count_in = 0;
+
+  for (current = device->queue_start; current; current = current->next) {
+    /* Add command to packet */
+    buffer[index_out] = current->id;
+    index_out++;
+    count_out++;
+
+    for (i = 0; i < current->payload_out_size; i++) {
+      buffer[index_out + i] = current->payload_out[i];
+    }
+    index_out += current->payload_out_size;
+    count_in += current->payload_in_size;
+    count_out += current->payload_out_size;
+  }
+
+  /* Send packet to ULINK */
+  ret = usb_bulk_write(device->usb_handle, (2 | USB_ENDPOINT_OUT),
+      (char *)buffer, count_out, timeout);
+  if (ret < 0) {
+    return ERROR_FAIL;
+  }
+  if (ret != count_out) {
+    return ERROR_FAIL;
+  }
+
+  /* Wait for response if commands contain IN payload data */
+  if (count_in > 0) {
+    ret = usb_bulk_read(device->usb_handle, (2 | USB_ENDPOINT_IN),
+        (char *)buffer, 64, timeout);
+    if (ret < 0) {
+      return ERROR_FAIL;
+    }
+    if (ret != count_in) {
+      return ERROR_FAIL;
+    }
+
+    /* Write back IN payload data */
+    index_in = 0;
+    for (current = device->queue_start; current; current = current->next) {
+      for (i = 0; i < current->payload_in_size; i++) {
+        current->payload_in[i] = buffer[index_in];
+        index_in++;
+      }
+    }
+  }
+
+  return ERROR_OK;
+}
+
+#ifdef _DEBUG_JTAG_IO_
+
+/**
+ * Convert an OpenULINK command ID (\a id) to a human-readable string.
+ *
+ * @param id the OpenULINK command ID.
+ * @return the corresponding human-readable string.
+ */
+const char * ulink_cmd_id_string(uint8_t id)
+{
+  switch (id) {
+  case CMD_SCAN_IN:
+    return "CMD_SCAN_IN";
+    break;
+  case CMD_SLOW_SCAN_IN:
+    return "CMD_SLOW_SCAN_IN";
+    break;
+  case CMD_SCAN_OUT:
+    return "CMD_SCAN_OUT";
+    break;
+  case CMD_SLOW_SCAN_OUT:
+    return "CMD_SLOW_SCAN_OUT";
+    break;
+  case CMD_SCAN_IO:
+    return "CMD_SCAN_IO";
+    break;
+  case CMD_SLOW_SCAN_IO:
+    return "CMD_SLOW_SCAN_IO";
+    break;
+  case CMD_CLOCK_TMS:
+    return "CMD_CLOCK_TMS";
+    break;
+  case CMD_SLOW_CLOCK_TMS:
+    return "CMD_SLOW_CLOCK_TMS";
+    break;
+  case CMD_CLOCK_TCK:
+    return "CMD_CLOCK_TCK";
+    break;
+  case CMD_SLEEP_US:
+    return "CMD_SLEEP_US";
+    break;
+  case CMD_SLEEP_MS:
+    return "CMD_SLEEP_MS";
+    break;
+  case CMD_GET_SIGNALS:
+    return "CMD_GET_SIGNALS";
+    break;
+  case CMD_SET_SIGNALS:
+    return "CMD_SET_SIGNALS";
+    break;
+  case CMD_CONFIGURE_TCK_FREQ:
+    return "CMD_CONFIGURE_TCK_FREQ";
+    break;
+  case CMD_SET_LEDS:
+    return "CMD_SET_LEDS";
+    break;
+  case CMD_TEST:
+    return "CMD_TEST";
+    break;
+  default:
+    return "CMD_UNKNOWN";
+    break;
+  }
+}
+
+/**
+ * Print one OpenULINK command to stdout.
+ *
+ * @param ulink_cmd pointer to OpenULINK command.
+ */
+void ulink_print_command(ulink_cmd_t *ulink_cmd)
+{
+  int i;
+
+  printf("  %-22s | OUT size = %i, bytes = 0x", ulink_cmd_id_string(ulink_cmd->id),
+      ulink_cmd->payload_out_size);
+
+  for (i = 0; i < ulink_cmd->payload_out_size; i++) {
+    printf("%02X ", ulink_cmd->payload_out[i]);
+  }
+  printf("\n                         | IN size  = %i\n", ulink_cmd->payload_in_size);
+}
+
+/**
+ * Print the OpenULINK command queue to stdout.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ */
+void ulink_print_queue(struct ulink *device)
+{
+  ulink_cmd_t *current;
+
+  printf("OpenULINK command queue:\n");
+
+  for (current = device->queue_start; current; current = current->next) {
+    ulink_print_command(current);
+  }
+}
+
+#endif /* _DEBUG_JTAG_IO_ */
+
+/**
+ * Perform JTAG scan
+ *
+ * Creates and appends a JTAG scan command to the OpenULINK command queue.
+ * A JTAG scan consists of three steps:
+ * - Move to the desired SHIFT state, depending on scan type (IR/DR scan).
+ * - Shift TDI data into the JTAG chain, optionally reading the TDO pin.
+ * - Move to the desired end state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param scan_type the type of the scan (IN, OUT, IO (bidirectional)).
+ * @param scan_size_bits number of bits to shift into the JTAG chain.
+ * @param tdi pointer to array containing TDI data.
+ * @param tdo_start pointer to first element of array where TDO data shall be
+ *  stored. See #ulink_cmd for details.
+ * @param tdo pointer to array where TDO data shall be stored
+ * @param tms_count_start number of TMS state transitions to perform BEFORE
+ *  shifting data into the JTAG chain.
+ * @param tms_sequence_start sequence of TMS state transitions that will be
+ *  performed BEFORE shifting data into the JTAG chain.
+ * @param tms_count_end number of TMS state transitions to perform AFTER
+ *  shifting data into the JTAG chain.
+ * @param tms_sequence_end sequence of TMS state transitions that will be
+ *  performed AFTER shifting data into the JTAG chain.
+ * @param origin pointer to OpenOCD command that generated this scan command.
+ * @param postprocess whether this command needs to be post-processed after
+ *  execution.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
+    int scan_size_bits, uint8_t *tdi, uint8_t *tdo_start, uint8_t *tdo,
+    uint8_t tms_count_start, uint8_t tms_sequence_start, uint8_t tms_count_end,
+    uint8_t tms_sequence_end, struct jtag_command *origin, bool postprocess)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret, i, scan_size_bytes;
+  uint8_t bits_last_byte;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  /* Check size of command. USB buffer can hold 64 bytes, 1 byte is command ID,
+   * 5 bytes are setup data -> 58 remaining payload bytes for TDI data */
+  if (scan_size_bits > (58 * 8)) {
+    LOG_ERROR("BUG: Tried to create CMD_SCAN_IO OpenULINK command with too"
+        " large payload");
+    return ERROR_FAIL;
+  }
+
+  scan_size_bytes = DIV_ROUND_UP(scan_size_bits, 8);
+
+  bits_last_byte = scan_size_bits % 8;
+  if (bits_last_byte == 0) {
+    bits_last_byte = 8;
+  }
+
+  /* Allocate out_payload depending on scan type */
+  // TODO: set command ID depending on interface speed settings (slow scan)
+  switch (scan_type) {
+  case SCAN_IN:
+    cmd->id = CMD_SCAN_IN;
+    ret = ulink_allocate_payload(cmd, 5, PAYLOAD_DIRECTION_OUT);
+    break;
+  case SCAN_OUT:
+    cmd->id = CMD_SCAN_OUT;
+    ret = ulink_allocate_payload(cmd, scan_size_bytes + 5, PAYLOAD_DIRECTION_OUT);
+    break;
+  case SCAN_IO:
+    cmd->id = CMD_SCAN_IO;
+    ret = ulink_allocate_payload(cmd, scan_size_bytes + 5, PAYLOAD_DIRECTION_OUT);
+    break;
+  default:
+    LOG_ERROR("BUG: ulink_append_scan_cmd() encountered an unknown scan type");
+    ret = ERROR_FAIL;
+  }
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  /* Build payload_out that is common to all scan types */
+  cmd->payload_out[0] = scan_size_bytes & 0xFF;
+  cmd->payload_out[1] = bits_last_byte & 0xFF;
+  cmd->payload_out[2] = ((tms_count_start & 0x0F) << 4) | (tms_count_end & 0x0F);
+  cmd->payload_out[3] = tms_sequence_start;
+  cmd->payload_out[4] = tms_sequence_end;
+
+  /* Setup payload_out for types with OUT transfer */
+  if ((scan_type == SCAN_OUT) || (scan_type == SCAN_IO)) {
+    for (i = 0; i < scan_size_bytes; i++) {
+      cmd->payload_out[i + 5] = tdi[i];
+    }
+  }
+
+  /* Setup payload_in pointers for types with IN transfer */
+  if ((scan_type == SCAN_IN) || (scan_type == SCAN_IO)) {
+    cmd->payload_in_start = tdo_start;
+    cmd->payload_in = tdo;
+    cmd->payload_in_size = scan_size_bytes;
+  }
+
+  cmd->needs_postprocessing = postprocess;
+  cmd->cmd_origin = origin;
+
+  /* For scan commands, we free payload_in_start only when the command is
+   * the last in a series of split commands or a stand-alone command */
+  cmd->free_payload_in_start = postprocess;
+
+  return ulink_append_queue(device, cmd);
+}
+
+/**
+ * Perform TAP state transitions
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param count defines the number of TCK clock cycles generated (up to 8).
+ * @param sequence defines the TMS pin levels for each state transition. The
+ *  Least-Significant Bit is read first.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
+    uint8_t sequence)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_CLOCK_TMS;
+
+  /* CMD_CLOCK_TMS has two OUT payload bytes and zero IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  cmd->payload_out[0] = count;
+  cmd->payload_out[1] = sequence;
+
+  return ulink_append_queue(device, cmd);
+}
+
+/**
+ * Generate a defined amount of TCK clock cycles
+ *
+ * All other JTAG signals are left unchanged.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param count the number of TCK clock cycles to generate.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_CLOCK_TCK;
+
+  /* CMD_CLOCK_TCK has two OUT payload bytes and zero IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  cmd->payload_out[0] = count & 0xff;
+  cmd->payload_out[1] = (count >> 8) & 0xff;
+
+  return ulink_append_queue(device, cmd);
+}
+
+/**
+ * Read JTAG signals.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_get_signals_cmd(struct ulink *device)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_GET_SIGNALS;
+  cmd->needs_postprocessing = true;
+
+  /* CMD_GET_SIGNALS has two IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_IN);
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  return ulink_append_queue(device, cmd);
+}
+
+/**
+ * Arbitrarily set JTAG output signals.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param low defines which signals will be de-asserted. Each bit corresponds
+ *  to a JTAG signal:
+ *  - SIGNAL_TDI
+ *  - SIGNAL_TMS
+ *  - SIGNAL_TCK
+ *  - SIGNAL_TRST
+ *  - SIGNAL_BRKIN
+ *  - SIGNAL_RESET
+ *  - SIGNAL_OCDSE
+ * @param high defines which signals will be asserted.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
+    uint8_t high)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_SET_SIGNALS;
+
+  /* CMD_SET_SIGNALS has two OUT payload bytes and zero IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  cmd->payload_out[0] = low;
+  cmd->payload_out[1] = high;
+
+  return ulink_append_queue(device, cmd);;
+}
+
+/**
+ * Sleep for a pre-defined number of microseconds
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param us the number microseconds to sleep.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_sleep_cmd(struct ulink *device, uint32_t us)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_SLEEP_US;
+
+  /* CMD_SLEEP_US has two OUT payload bytes and zero IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  cmd->payload_out[0] = us & 0x00ff;
+  cmd->payload_out[1] = (us >> 8) & 0x00ff;
+
+  return ulink_append_queue(device, cmd);
+}
+
+/**
+ * Set TCK delay counters
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param delay_scan delay count top value in jtag_slow_scan() functions
+ * @param delay_tck delay count top value in jtag_clock_tck() function
+ * @param delay_tms delay count top value in jtag_slow_clock_tms() function
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
+    uint8_t delay_tck, uint8_t delay_tms)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_CONFIGURE_TCK_FREQ;
+
+  /* CMD_CONFIGURE_TCK_FREQ has three OUT payload bytes and zero
+   * IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 3, PAYLOAD_DIRECTION_OUT);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  cmd->payload_out[0] = delay_scan;
+  cmd->payload_out[1] = delay_tck;
+  cmd->payload_out[2] = delay_tms;
+
+  return ulink_append_queue(device, cmd);
+}
+
+/**
+ * Turn on/off ULINK LEDs.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param led_state which LED(s) to turn on or off. The following bits
+ *  influence the LEDS:
+ *  - Bit 0: Turn COM LED on
+ *  - Bit 1: Turn RUN LED on
+ *  - Bit 2: Turn COM LED off
+ *  - Bit 3: Turn RUN LED off
+ *  If both the on-bit and the off-bit for the same LED is set, the LED is
+ *  turned off.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_led_cmd(struct ulink *device, uint8_t led_state)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_SET_LEDS;
+
+  /* CMD_SET_LEDS has one OUT payload byte and zero IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 1, PAYLOAD_DIRECTION_OUT);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  cmd->payload_out[0] = led_state;
+
+  return ulink_append_queue(device, cmd);
+}
+
+/**
+ * Test command. Used to check if the ULINK device is ready to accept new
+ * commands.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_append_test_cmd(struct ulink *device)
+{
+  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  int ret;
+
+  if (cmd == NULL) {
+    return ERROR_FAIL;
+  }
+
+  cmd->id = CMD_TEST;
+
+  /* CMD_TEST has one OUT payload byte and zero IN payload bytes */
+  ret = ulink_allocate_payload(cmd, 1, PAYLOAD_DIRECTION_OUT);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  cmd->payload_out[0] = 0xAA;
+
+  return ulink_append_queue(device, cmd);
+}
+
+/******************* Interface between OpenULINK and OpenOCD ******************/
+
+/**
+ * Perform a scan operation on a JTAG register.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd)
+{
+  uint32_t scan_size_bits, scan_size_bytes, bits_last_scan;
+  uint32_t scans_max_payload, bytecount;
+  uint8_t *tdi_buffer_start = NULL, *tdi_buffer = NULL;
+  uint8_t *tdo_buffer_start = NULL, *tdo_buffer = NULL;
+
+  uint8_t first_tms_count, first_tms_sequence;
+  uint8_t last_tms_count, last_tms_sequence;
+
+  uint8_t tms_count_pause, tms_sequence_pause;
+  uint8_t tms_count_resume, tms_sequence_resume;
+
+  uint8_t tms_count_start, tms_sequence_start;
+  uint8_t tms_count_end, tms_sequence_end;
+
+  enum scan_type type;
+  int ret;
+
+  /* Determine scan size */
+  scan_size_bits = jtag_scan_size(cmd->cmd.scan);
+  scan_size_bytes = DIV_ROUND_UP(scan_size_bits, 8);
+
+  /* Determine scan type (IN/OUT/IO) */
+  type = jtag_scan_type(cmd->cmd.scan);
+
+  /* Determine number of scan commands */
+  scans_max_payload = scan_size_bytes / 58;
+
+  /* Determine size of last shift command */
+  bits_last_scan = scan_size_bits - (scans_max_payload * 58 * 8);
+
+  /* Allocate TDO buffer if required */
+  if ((type == SCAN_IN) || (type == SCAN_IO)) {
+    tdo_buffer_start = calloc(sizeof(uint8_t), scan_size_bytes);
+
+    if (tdo_buffer_start == NULL) {
+      return ERROR_FAIL;
+    }
+
+    tdo_buffer = tdo_buffer_start;
+  }
+
+  /* Fill TDI buffer if required */
+  if ((type == SCAN_OUT) || (type == SCAN_IO)) {
+    jtag_build_buffer(cmd->cmd.scan, &tdi_buffer_start);
+    tdi_buffer = tdi_buffer_start;
+  }
+
+  /* Get TAP state transitions */
+  if (cmd->cmd.scan->ir_scan) {
+    ulink_set_end_state(TAP_IRSHIFT);
+    first_tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+    first_tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+
+    tap_set_state(TAP_IRSHIFT);
+    tap_set_end_state(cmd->cmd.scan->end_state);
+    last_tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+    last_tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+
+    /* TAP state transitions for split scans */
+    tms_count_pause = tap_get_tms_path_len(TAP_IRSHIFT, TAP_IRPAUSE);
+    tms_sequence_pause = tap_get_tms_path(TAP_IRSHIFT, TAP_IRPAUSE);
+    tms_count_resume = tap_get_tms_path_len(TAP_IRPAUSE, TAP_IRSHIFT);
+    tms_sequence_resume = tap_get_tms_path(TAP_IRPAUSE, TAP_IRSHIFT);
+  }
+  else {
+    ulink_set_end_state(TAP_DRSHIFT);
+    first_tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+    first_tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+
+    tap_set_state(TAP_DRSHIFT);
+    tap_set_end_state(cmd->cmd.scan->end_state);
+    last_tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+    last_tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+
+    /* TAP state transitions for split scans */
+    tms_count_pause = tap_get_tms_path_len(TAP_DRSHIFT, TAP_DRPAUSE);
+    tms_sequence_pause = tap_get_tms_path(TAP_DRSHIFT, TAP_DRPAUSE);
+    tms_count_resume = tap_get_tms_path_len(TAP_DRPAUSE, TAP_DRSHIFT);
+    tms_sequence_resume = tap_get_tms_path(TAP_DRPAUSE, TAP_DRSHIFT);
+  }
+
+  /* Generate scan commands with full payload */
+  bytecount = scan_size_bytes;
+  while (bytecount > 0) {
+    if (bytecount == scan_size_bytes) {
+      /* This is the first scan */
+      tms_count_start = first_tms_count;
+      tms_sequence_start = first_tms_sequence;
+    }
+    else {
+      /* Resume from previous scan */
+      tms_count_start = tms_count_resume;
+      tms_sequence_start = tms_sequence_resume;
+    }
+
+    if (bytecount > 58) { /* Full scan, at least one scan will follow */
+      tms_count_end = tms_count_pause;
+      tms_sequence_end = tms_sequence_pause;
+
+      ret = ulink_append_scan_cmd(device, type, 58 * 8, tdi_buffer,
+          tdo_buffer_start, tdo_buffer, tms_count_start, tms_sequence_start,
+          tms_count_end, tms_sequence_end, cmd, false);
+
+      bytecount -= 58;
+
+      /* Update TDI and TDO buffer pointers */
+      if (tdi_buffer_start != NULL) {
+        tdi_buffer += 58;
+      }
+      if (tdo_buffer_start != NULL) {
+        tdo_buffer += 58;
+      }
+    }
+    else if (bytecount == 58) { /* Full scan, no further scans */
+      tms_count_end = last_tms_count;
+      tms_sequence_end = last_tms_sequence;
+
+      ret = ulink_append_scan_cmd(device, type, 58 * 8, tdi_buffer,
+          tdo_buffer_start, tdo_buffer, tms_count_start, tms_sequence_start,
+          tms_count_end, tms_sequence_end, cmd, true);
+
+      bytecount = 0;
+    }
+    else { /* Scan with less than maximum payload, no further scans */
+      tms_count_end = last_tms_count;
+      tms_sequence_end = last_tms_sequence;
+
+      ret = ulink_append_scan_cmd(device, type, bits_last_scan, tdi_buffer,
+          tdo_buffer_start, tdo_buffer, tms_count_start, tms_sequence_start,
+          tms_count_end, tms_sequence_end, cmd, true);
+
+      bytecount = 0;
+    }
+
+    if (ret != ERROR_OK) {
+      free(tdi_buffer_start);
+      return ret;
+    }
+  }
+
+  free(tdi_buffer_start);
+
+  /* Set current state to the end state requested by the command */
+  tap_set_state(cmd->cmd.scan->end_state);
+
+  return ERROR_OK;
+}
+
+/**
+ * Sets the end state follower (see interface.h) if \a endstate is a stable
+ * state.
+ *
+ * @param endstate the state the end state follower should be set to.
+ */
+static void ulink_set_end_state(tap_state_t endstate)
+{
+  if (tap_is_state_stable(endstate)) {
+    tap_set_end_state(endstate);
+  }
+  else {
+    LOG_ERROR("BUG: %s is not a valid end state", tap_state_name(endstate));
+    exit( EXIT_FAILURE);
+  }
+}
+
+/**
+ * Move from the current TAP state to the current TAP end state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_statemove(struct ulink *device)
+{
+  uint8_t tms_sequence, tms_count;
+  int ret;
+
+  if (tap_get_state() == tap_get_end_state()) {
+    /* Do nothing if we are already there */
+    return ERROR_OK;
+  }
+
+  tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+  tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+
+  ret = ulink_append_clock_tms_cmd(device, tms_count, tms_sequence);
+
+  if (ret == ERROR_OK) {
+    tap_set_state(tap_get_end_state());
+  }
+
+  return ret;
+}
+
+/**
+ * Execute a JTAG_RESET command
+ *
+ * @param cmd pointer to the command that shall be executed.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd)
+{
+  uint8_t low = 0, high = 0;
+
+  if (cmd->cmd.reset->trst) {
+    tap_set_state(TAP_RESET);
+    high |= SIGNAL_TRST;
+  }
+  else {
+    low |= SIGNAL_TRST;
+  }
+
+  if (cmd->cmd.reset->srst) {
+    high |= SIGNAL_RESET;
+  }
+  else {
+    low |= SIGNAL_RESET;
+  }
+
+  return ulink_append_set_signals_cmd(device, low, high);
+}
+
+/**
+ * Run Test.
+ *
+ * Generate TCK clock cycles while remaining
+ * in the Run-Test/Idle state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd)
+{
+  int ret;
+
+  /* Only perform statemove if the TAP currently isn't in the TAP_IDLE state */
+  if (tap_get_state() != TAP_IDLE) {
+    ulink_set_end_state(TAP_IDLE);
+    ulink_queue_statemove(device);
+  }
+
+  /* Generate the clock cycles */
+  ret = ulink_append_clock_tck_cmd(device, cmd->cmd.runtest->num_cycles);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  /* Move to end state specified in command */
+  if (cmd->cmd.runtest->end_state != tap_get_state()) {
+    tap_set_end_state(cmd->cmd.runtest->end_state);
+    ulink_queue_statemove(device);
+  }
+
+  return ERROR_OK;
+}
+
+/**
+ * Move the TAP into the Test Logic Reset state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd)
+{
+  int ret;
+
+  ret = ulink_append_clock_tms_cmd(device, 5, 0xff);
+
+  if (ret == ERROR_OK) {
+    tap_set_state(TAP_RESET);
+  }
+
+  return ret;
+}
+
+/**
+ * Move to one TAP state or several states in succession.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd)
+{
+  // TODO: Implement this!
+  return ERROR_OK;
+}
+
+/**
+ * Sleep for a specific amount of time.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd)
+{
+  /* IMPORTANT! Due to the time offset in command execution introduced by
+   * command queueing, this needs to be implemented in the ULINK device */
+  return ulink_append_sleep_cmd(device, cmd->cmd.sleep->us);
+}
+
+/**
+ * Post-process JTAG_SCAN command
+ *
+ * @param ulink_cmd pointer to OpenULINK command that shall be processed.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_post_process_scan(ulink_cmd_t *ulink_cmd)
+{
+  struct jtag_command *cmd = ulink_cmd->cmd_origin;
+  int ret;
+
+  switch (jtag_scan_type(cmd->cmd.scan)) {
+  case SCAN_IN:
+  case SCAN_IO:
+    ret = jtag_read_buffer(ulink_cmd->payload_in_start, cmd->cmd.scan);
+    break;
+  case SCAN_OUT:
+    /* Nothing to do for OUT scans */
+    ret = ERROR_OK;
+    break;
+  default:
+    LOG_ERROR("BUG: ulink_post_process_scan() encountered an unknown"
+        " JTAG scan type");
+    ret = ERROR_FAIL;
+    break;
+  }
+
+  return ret;
+}
+
+/**
+ * Perform post-processing of commands after OpenULINK queue has been executed.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_post_process_queue(struct ulink *device)
+{
+  ulink_cmd_t *current;
+  struct jtag_command *openocd_cmd;
+  int ret;
+
+  current = device->queue_start;
+
+  while (current != NULL) {
+    openocd_cmd = current->cmd_origin;
+
+    /* Check if a corresponding OpenOCD command is stored for this
+     * OpenULINK command */
+    if ((current->needs_postprocessing == true) && (openocd_cmd != NULL)) {
+      switch (openocd_cmd->type) {
+      case JTAG_SCAN:
+        ret = ulink_post_process_scan(current);
+        break;
+      case JTAG_RUNTEST:
+      case JTAG_TLR_RESET:
+      case JTAG_PATHMOVE:
+      case JTAG_RESET:
+      case JTAG_SLEEP:
+        /* Nothing to do for these commands */
+        ret = ERROR_OK;
+        break;
+      default:
+        ret = ERROR_FAIL;
+        LOG_ERROR("BUG: ulink_post_process_queue() encountered unknown JTAG "
+            "command type");
+      }
+
+      if (ret != ERROR_OK) {
+        return ret;
+      }
+    }
+
+    current = current->next;
+  }
+
+  return ERROR_OK;
+}
+
+/**************************** JTAG driver functions ***************************/
+
+/**
+ * Executes the JTAG Command Queue.
+ *
+ * This is done in three stages: First, all OpenOCD commands are processed into
+ * queued OpenULINK commands. Next, the OpenULINK command queue is sent to the
+ * ULINK device and data received from the ULINK device is cached. Finally,
+ * the post-processing function writes back data to the corresponding OpenOCD
+ * commands.
+ *
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+static int ulink_execute_queue(void)
+{
+  struct jtag_command *cmd = jtag_command_queue;
+  int ret;
+
+  while (cmd) {
+    switch (cmd->type) {
+    case JTAG_SCAN:
+      ret = ulink_queue_scan(ulink_handle, cmd);
+      break;
+    case JTAG_RUNTEST:
+      ret = ulink_queue_runtest(ulink_handle, cmd);
+      break;
+    case JTAG_TLR_RESET:
+      ret = ulink_queue_tlr_reset(ulink_handle, cmd);
+      break;
+    case JTAG_PATHMOVE:
+      ret = ulink_queue_pathmove(ulink_handle, cmd);
+      break;
+    case JTAG_RESET:
+      ret = ulink_queue_reset(ulink_handle, cmd);
+      break;
+    case JTAG_SLEEP:
+      ret = ulink_queue_sleep(ulink_handle, cmd);
+      break;
+    default:
+      ret = ERROR_FAIL;
+      LOG_ERROR("BUG: encountered unknown JTAG command type");
+    }
+
+    cmd = cmd->next;
+  }
+
+  if (ulink_handle->commands_in_queue > 0) {
+    ret = ulink_execute_queued_commands(ulink_handle, USB_TIMEOUT);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ret = ulink_post_process_queue(ulink_handle);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ulink_clear_queue(ulink_handle);
+  }
+
+  return ERROR_OK;
+}
+
+/**
+ * Set the TCK frequency of the ULINK adapter.
+ *
+ * @param khz ???
+ * @param jtag_speed ???
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+static int ulink_khz(int khz, int *jtag_speed)
+{
+  if (khz == 0) {
+    LOG_ERROR("RCLK not supported");
+    return ERROR_FAIL;
+  }
+
+  LOG_INFO("ulink_khz: %i kHz", khz);
+
+  /* ULINK maximum TCK frequency is ~ 150 kHz */
+  if (khz > 150) {
+    return ERROR_FAIL;
+  }
+
+  *jtag_speed = 0;
+
+  return ERROR_OK;
+}
+
+/**
+ * Set the TCK frequency of the ULINK adapter.
+ *
+ * @param speed ???
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+static int ulink_speed(int speed)
+{
+  return ERROR_OK;
+}
+
+/**
+ *
+ */
+static int ulink_speed_div(int speed, int *khz)
+{
+  LOG_INFO("ulink_speed_div: %i", speed);
+
+  switch (speed) {
+  case 0:
+    *khz = 150;
+    break;
+  case 1:
+    *khz = 100;
+    break;
+  }
+
+  return ERROR_OK;
+}
+
+/**
+ * Initiates the firmware download to the ULINK adapter and prepares
+ * the USB handle.
+ *
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+static int ulink_init(void)
+{
+  int ret;
+  char str_manufacturer[20];
+  bool download_firmware = false;
+  uint8_t *dummy;
+  uint8_t input_signals, output_signals;
+
+  ulink_handle = calloc(1, sizeof(struct ulink));
+  if (ulink_handle == NULL) {
+    return ERROR_FAIL;
+  }
+
+  usb_init();
+
+  ret = ulink_usb_open(&ulink_handle);
+  if (ret != ERROR_OK) {
+    LOG_ERROR("Could not open ULINK device");
+    return ret;
+  }
+
+  /* Get String Descriptor to determine if firmware needs to be loaded */
+  ret = usb_get_string_simple(ulink_handle->usb_handle, 1, str_manufacturer, 20);
+  if (ret < 0) {
+    /* Could not get descriptor -> Unconfigured or original Keil firmware */
+    download_firmware = true;
+  }
+  else {
+    /* We got a String Descriptor, check if it is the correct one */
+    if (strncmp(str_manufacturer, "OpenULINK", 9) != 0) {
+      download_firmware = true;
+    }
+  }
+
+  if (download_firmware == true) {
+    LOG_INFO("Loading OpenULINK firmware. This is reversible by power-cycling"
+        " ULINK device.");
+    ret = ulink_load_firmware_and_renumerate(&ulink_handle,
+        ULINK_FIRMWARE_FILE, ULINK_RENUMERATION_DELAY);
+    if (ret != ERROR_OK) {
+      LOG_ERROR("Could not download firmware and re-numerate ULINK");
+      return ret;
+    }
+  }
+  else {
+    LOG_INFO("ULINK device is already running OpenULINK firmware");
+  }
+
+  /* Initialize OpenULINK command queue */
+  ulink_clear_queue(ulink_handle);
+
+  /* Issue one test command with short timeout */
+  ret = ulink_append_test_cmd(ulink_handle);
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  ret = ulink_execute_queued_commands(ulink_handle, 200);
+  if (ret != ERROR_OK) {
+    /* Sending test command failed. The ULINK device may be forever waiting for
+     * the host to fetch an USB Bulk IN packet (e. g. OpenOCD crashed or was
+     * shut down by the user via Ctrl-C. Try to retrieve this Bulk IN packet. */
+    dummy = calloc(64, sizeof(uint8_t));
+
+    ret = usb_bulk_read(ulink_handle->usb_handle, (2 | USB_ENDPOINT_IN),
+        (char *)dummy, 64, 200);
+
+    free(dummy);
+
+    if (ret < 0) {
+      /* Bulk IN transfer failed -> unrecoverable error condition */
+      LOG_ERROR("Cannot communicate with ULINK device. Disconnect ULINK from "
+          "the USB port and re-connect, then re-run OpenOCD");
+      return ERROR_FAIL;
+    }
+#ifdef _DEBUG_USB_COMMS_
+    else {
+      /* Successfully received Bulk IN packet -> continue */
+      LOG_INFO("Recovered from lost Bulk IN packet");
+    }
+#endif
+  }
+  ulink_clear_queue(ulink_handle);
+
+  ulink_append_get_signals_cmd(ulink_handle);
+  ulink_execute_queued_commands(ulink_handle, 200);
+
+  /* Post-process the single CMD_GET_SIGNALS command */
+  input_signals = ulink_handle->queue_start->payload_in[0];
+  output_signals = ulink_handle->queue_start->payload_in[1];
+
+  ulink_print_signal_states(input_signals, output_signals);
+
+  ulink_clear_queue(ulink_handle);
+
+  return ERROR_OK;
+}
+
+/**
+ * Closes the USB handle for the ULINK device.
+ *
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+static int ulink_quit(void)
+{
+  int ret;
+
+  ret = ulink_usb_close(&ulink_handle);
+  free(ulink_handle);
+
+  return ret;
+}
+
+/*************************** Command Registration **************************/
+
+struct jtag_interface ulink_interface = {
+  .name = "ulink",
+  .transports = jtag_only,
+
+  .execute_queue = ulink_execute_queue,
+  .khz = ulink_khz,
+  .speed = ulink_speed,
+  .speed_div = ulink_speed_div,
+
+  .init = ulink_init,
+  .quit = ulink_quit
+};

-----------------------------------------------------------------------

Summary of changes:
 .gitignore                                         |   11 +
 README                                             |    2 +
 common.mk                                          |    3 +-
 configure.in                                       |   13 +-
 src/Makefile.am                                    |    4 +
 src/jtag/drivers/Makefile.am                       |   10 +
 src/jtag/drivers/OpenULINK/Makefile                |   90 +
 src/jtag/drivers/OpenULINK/README                  |   34 +
 .../drivers/OpenULINK/include/common.h}            |   20 +-
 .../drivers/OpenULINK/include/delay.h}             |   21 +-
 src/jtag/drivers/OpenULINK/include/io.h            |  125 ++
 .../drivers/OpenULINK/include/jtag.h}              |   40 +-
 .../drivers/OpenULINK/include/main.h}              |   13 +-
 src/jtag/drivers/OpenULINK/include/msgtypes.h      |  187 ++
 .../drivers/OpenULINK/include/protocol.h}          |   20 +-
 src/jtag/drivers/OpenULINK/include/reg_ezusb.h     |  742 ++++++++
 .../drivers/OpenULINK/include/shorttypes.h}        |   29 +-
 src/jtag/drivers/OpenULINK/include/usb.h           |  267 +++
 src/jtag/drivers/OpenULINK/src/USBJmpTb.a51        |   83 +
 .../drivers/OpenULINK/src/delay.c}                 |   39 +-
 src/jtag/drivers/OpenULINK/src/jtag.c              |  414 +++++
 src/jtag/drivers/OpenULINK/src/main.c              |   92 +
 src/jtag/drivers/OpenULINK/src/protocol.c          |  212 +++
 src/jtag/drivers/OpenULINK/src/usb.c               |  543 ++++++
 src/jtag/drivers/OpenULINK/ulink_firmware.hex      |  251 +++
 src/jtag/drivers/ulink.c                           | 1890 ++++++++++++++++++++
 src/jtag/interfaces.c                              |    6 +
 tcl/interface/ulink.cfg                            |    5 +
 28 files changed, 5086 insertions(+), 80 deletions(-)
 create mode 100644 src/jtag/drivers/OpenULINK/Makefile
 create mode 100644 src/jtag/drivers/OpenULINK/README
 copy src/{server/server_stubs.c => jtag/drivers/OpenULINK/include/common.h} (85%)
 copy src/{flash/ocl/at91sam7x/dcc.h => jtag/drivers/OpenULINK/include/delay.h} (80%)
 create mode 100644 src/jtag/drivers/OpenULINK/include/io.h
 copy src/{flash/ocl/at91sam7x/samflash.h => jtag/drivers/OpenULINK/include/jtag.h} (61%)
 copy src/{helper/ioutil.h => jtag/drivers/OpenULINK/include/main.h} (85%)
 create mode 100644 src/jtag/drivers/OpenULINK/include/msgtypes.h
 copy src/{flash/ocl/at91sam7x/dcc.h => jtag/drivers/OpenULINK/include/protocol.h} (80%)
 create mode 100644 src/jtag/drivers/OpenULINK/include/reg_ezusb.h
 copy src/{rtos/rtos_standard_stackings.h => jtag/drivers/OpenULINK/include/shorttypes.h} (73%)
 create mode 100644 src/jtag/drivers/OpenULINK/include/usb.h
 create mode 100644 src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
 copy src/{pld/virtex2.h => jtag/drivers/OpenULINK/src/delay.c} (74%)
 create mode 100644 src/jtag/drivers/OpenULINK/src/jtag.c
 create mode 100644 src/jtag/drivers/OpenULINK/src/main.c
 create mode 100644 src/jtag/drivers/OpenULINK/src/protocol.c
 create mode 100644 src/jtag/drivers/OpenULINK/src/usb.c
 create mode 100644 src/jtag/drivers/OpenULINK/ulink_firmware.hex
 create mode 100644 src/jtag/drivers/ulink.c
 create mode 100644 tcl/interface/ulink.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Jun 27 17:16:56 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 27 Jun 2011 15:16:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-939-g45287bd
Message-ID: <mailman.114.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  45287bda76ace1f93b9e48ead7fed83c774258d1 (commit)
      from  5e2637a4e0996f993916dcc24fa34afa4f3eaeda (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 45287bda76ace1f93b9e48ead7fed83c774258d1
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Jun 27 16:08:56 2011 +0100

    build: cleanup jimtcl generated configure.gnu
    
    We use configure.gnu to pass options to the jimtcl submodule.
    Make sure a distclean removes any generated files
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/Makefile.am b/Makefile.am
index 63ac5a1..1b19ba4 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -86,7 +86,8 @@ uninstall-hook:
 
 distclean-local:
 	rm -rf Doxyfile doxygen
-
+	rm -f $(srcdir)/jimtcl/configure.gnu
+	
 DISTCLEANFILES = doxygen.log
 
 MAINTAINERCLEANFILES = \

-----------------------------------------------------------------------

Summary of changes:
 Makefile.am |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Jun 28 15:18:15 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 28 Jun 2011 13:18:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-941-gff640f1
Message-ID: <mailman.115.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ff640f197a9a343b2f3ed10e9174e35282334e8c (commit)
       via  e53f7e5fc0d92299ee0bcc255bb8d1107a297372 (commit)
      from  45287bda76ace1f93b9e48ead7fed83c774258d1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ff640f197a9a343b2f3ed10e9174e35282334e8c
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Jun 28 14:16:48 2011 +0100

    cortex_m3: add auto maskisr
    
    This patch extends the cortex_m3 maskisr command by a new option 'auto'.
    The 'auto' option handles interrupts during stepping in a way they are
    processed but don't disturb the program flow during debugging.
    
    Before one had to choose to either enable or disable interrupts. The former
    steps into interrupt handlers when they trigger. This disturbs the flow during
    debugging, making it hard to follow some piece of code when interrupts occur
    often.
    
    When interrupts are disabled, the flow isn't disturbed but code relying on
    interrupt handlers to be processed will stop working. For example a delay
    function counting the number of timer interrupts will never complete, RTOS
    task switching will not occur and output I/O queues of interrupt driven
    I/O will stall or overflow.
    
    Using the 'maskisr' command also typically requires gdb hooks to be supplied
    by the user to switch interrupts off during the step and to enable them again
    afterward.
    
    The new 'auto' option of the 'maskisr' command solves the above problems. When
    set, the step command allows pending interrupt handlers to be executed before
    the step, then the step is taken with interrupts disabled and finally interrupts
    are enabled again. This way interrupt processing stays in the background without
    disturbing the flow of debugging. No gdb hooks are required. The 'auto'
    option is the default, since it's believed that handling interrupts in this
    way is suitable for most users.
    
    The principle used for interrupt handling could probably be used for other
    targets too.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 892661f..fd92d51 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -6720,8 +6720,21 @@ If @var{value} is defined, first assigns that.
 @subsection Cortex-M3 specific commands
 @cindex Cortex-M3
 
- at deffn Command {cortex_m3 maskisr} (@option{on}|@option{off})
+ at deffn Command {cortex_m3 maskisr} (@option{auto}|@option{on}|@option{off})
 Control masking (disabling) interrupts during target step/resume.
+
+The @option{auto} option handles interrupts during stepping a way they get
+served but don't disturb the program flow. The step command first allows
+pending interrupt handlers to execute, then disables interrupts and steps over
+the next instruction where the core was halted. After the step interrupts
+are enabled again. If the interrupt handlers don't complete within 500ms,
+the step command leaves with the core running.
+
+Note that a free breakpoint is required for the @option{auto} option. If no
+breakpoint is available at the time of the step, then the step is taken
+with interrupts enabled, i.e. the same way the @option{off} option does.
+
+Default is @option{auto}.
 @end deffn
 
 @deffn Command {cortex_m3 vector_catch} [@option{all}|@option{none}|list]
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 9c3d2d9..98a775c 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -39,6 +39,7 @@
 #include "register.h"
 #include "arm_opcodes.h"
 #include "arm_semihosting.h"
+#include <helper/time_support.h>
 
 /* NOTE:  most of this should work fine for the Cortex-M1 and
  * Cortex-M0 cores too, although they're ARMv6-M not ARMv7-M.
@@ -858,6 +859,8 @@ static int cortex_m3_step(struct target *target, int current,
 	struct breakpoint *breakpoint = NULL;
 	struct reg *pc = armv7m->arm.pc;
 	bool bkpt_inst_found = false;
+	int retval;
+	bool isr_timed_out = false;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -891,11 +894,79 @@ static int cortex_m3_step(struct target *target, int current,
 	 * instruction - as such simulate a step */
 	if (bkpt_inst_found == false)
 	{
-		/* set step and clear halt */
-		cortex_m3_write_debug_halt_mask(target, C_STEP, C_HALT);
+		/* Automatic ISR masking mode off: Just step over the next instruction */
+		if ((cortex_m3->isrmasking_mode != CORTEX_M3_ISRMASK_AUTO))
+		{
+			cortex_m3_write_debug_halt_mask(target, C_STEP, C_HALT);
+		}
+		else
+		{
+			/* Process interrupts during stepping in a way they don't interfere
+			 * debugging.
+			 *
+			 * Principle:
+			 *
+			 * Set a temporary break point at the current pc and let the core run
+			 * with interrupts enabled. Pending interrupts get served and we run
+			 * into the breakpoint again afterwards. Then we step over the next
+			 * instruction with interrupts disabled.
+			 *
+			 * If the pending interrupts don't complete within time, we leave the
+			 * core running. This may happen if the interrupts trigger faster
+			 * than the core can process them or the handler doesn't return.
+			 *
+			 * If no more breakpoints are available we simply do a step with
+			 * interrupts enabled.
+			 *
+			 */
+
+			/* Set a temporary break point */
+			retval = breakpoint_add(target, pc_value , 2, BKPT_TYPE_BY_ADDR(pc_value));
+			bool tmp_bp_set = (retval == ERROR_OK);
+
+			/* No more breakpoints left, just do a step */
+			if (!tmp_bp_set)
+			{
+				cortex_m3_write_debug_halt_mask(target, C_STEP, C_HALT);
+			}
+			else
+			{
+				/* Start the core */
+				LOG_DEBUG("Starting core to serve pending interrupts");
+				int64_t t_start = timeval_ms();
+				cortex_m3_write_debug_halt_mask(target, 0, C_HALT | C_STEP);
+
+				/* Wait for pending handlers to complete or timeout */
+				do {
+					retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
+					if (retval != ERROR_OK)
+					{
+						target->state = TARGET_UNKNOWN;
+						return retval;
+					}
+					isr_timed_out = ((timeval_ms() - t_start) > 500);
+				} while (!((cortex_m3->dcb_dhcsr & S_HALT) || isr_timed_out));
+
+				/* Remove the temporary breakpoint */
+				breakpoint_remove(target, pc_value);
+
+				if (isr_timed_out)
+				{
+					LOG_DEBUG("Interrupt handlers didn't complete within time, "
+							"leaving target running");
+				}
+				else
+				{
+					/* Step over next instruction with interrupts disabled */
+					cortex_m3_write_debug_halt_mask(target, C_HALT | C_MASKINTS, 0);
+					cortex_m3_write_debug_halt_mask(target, C_STEP, C_HALT);
+					/* Re-enable interrupts */
+					cortex_m3_write_debug_halt_mask(target, C_HALT, C_MASKINTS);
+				}
+			}
+		}
 	}
 
-	int retval;
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
@@ -906,6 +977,13 @@ static int cortex_m3_step(struct target *target, int current,
 	if (breakpoint)
 		cortex_m3_set_breakpoint(target, breakpoint);
 
+	if (isr_timed_out) {
+		/* Leave the core running. The user has to stop execution manually. */
+		target->debug_reason = DBG_REASON_NOTHALTED;
+		target->state = TARGET_RUNNING;
+		return ERROR_OK;
+	}
+
 	LOG_DEBUG("target stepped dcb_dhcsr = 0x%" PRIx32
 			" nvic_icsr = 0x%" PRIx32,
 			cortex_m3->dcb_dhcsr, cortex_m3->nvic_icsr);
@@ -2104,6 +2182,15 @@ COMMAND_HANDLER(handle_cortex_m3_mask_interrupts_command)
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	int retval;
 
+	static const Jim_Nvp nvp_maskisr_modes[] = {
+		{ .name = "auto", .value = CORTEX_M3_ISRMASK_AUTO },
+		{ .name = "off" , .value = CORTEX_M3_ISRMASK_OFF },
+		{ .name = "on"  , .value = CORTEX_M3_ISRMASK_ON },
+		{ .name = NULL  , .value = -1 },
+	};
+	const Jim_Nvp *n;
+
+
 	retval = cortex_m3_verify_pointer(CMD_CTX, cortex_m3);
 	if (retval != ERROR_OK)
 		return retval;
@@ -2116,15 +2203,26 @@ COMMAND_HANDLER(handle_cortex_m3_mask_interrupts_command)
 
 	if (CMD_ARGC > 0)
 	{
-		bool enable;
-		COMMAND_PARSE_ON_OFF(CMD_ARGV[0], enable);
-		uint32_t mask_on = C_HALT | (enable ? C_MASKINTS : 0);
-		uint32_t mask_off = enable ? 0 : C_MASKINTS;
-		cortex_m3_write_debug_halt_mask(target, mask_on, mask_off);
+		n = Jim_Nvp_name2value_simple(nvp_maskisr_modes, CMD_ARGV[0]);
+		if (n->name == NULL)
+		{
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+		cortex_m3->isrmasking_mode = n->value;
+
+
+		if(cortex_m3->isrmasking_mode == CORTEX_M3_ISRMASK_ON)
+		{
+			cortex_m3_write_debug_halt_mask(target, C_HALT | C_MASKINTS, 0);
+		}
+		else
+		{
+			cortex_m3_write_debug_halt_mask(target, C_HALT, C_MASKINTS);
+		}
 	}
 
-	command_print(CMD_CTX, "cortex_m3 interrupt mask %s",
-			(cortex_m3->dcb_dhcsr & C_MASKINTS) ? "on" : "off");
+	n = Jim_Nvp_value2name_simple(nvp_maskisr_modes, cortex_m3->isrmasking_mode);
+	command_print(CMD_CTX, "cortex_m3 interrupt mask %s", n->name);
 
 	return ERROR_OK;
 }
@@ -2174,7 +2272,7 @@ static const struct command_registration cortex_m3_exec_command_handlers[] = {
 		.handler = handle_cortex_m3_mask_interrupts_command,
 		.mode = COMMAND_EXEC,
 		.help = "mask cortex_m3 interrupts",
-		.usage = "['on'|'off']",
+		.usage = "['auto'|'on'|'off']",
 	},
 	{
 		.name = "vector_catch",
diff --git a/src/target/cortex_m3.h b/src/target/cortex_m3.h
index e1f8ef8..e16aa89 100644
--- a/src/target/cortex_m3.h
+++ b/src/target/cortex_m3.h
@@ -140,6 +140,13 @@ enum cortex_m3_soft_reset_config
 	CORTEX_M3_RESET_VECTRESET,
 };
 
+enum cortex_m3_isrmasking_mode
+{
+	CORTEX_M3_ISRMASK_AUTO,
+	CORTEX_M3_ISRMASK_OFF,
+	CORTEX_M3_ISRMASK_ON,
+};
+
 struct cortex_m3_common
 {
 	int common_magic;
@@ -166,6 +173,8 @@ struct cortex_m3_common
 
 	enum cortex_m3_soft_reset_config soft_reset_config;
 
+	enum cortex_m3_isrmasking_mode isrmasking_mode;
+
 	struct armv7m_common armv7m;
 };
 

commit e53f7e5fc0d92299ee0bcc255bb8d1107a297372
Author: Peter Horn <peter.horn at bluewin.ch>
Date:   Tue Jun 28 14:08:22 2011 +0100

    cortex_m3: add BKPT_TYPE_BY_ADDR define
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 269d2a6..9c3d2d9 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -51,6 +51,11 @@
  * any longer.
  */
 
+/**
+ * Returns the type of a break point required by address location
+ */
+#define BKPT_TYPE_BY_ADDR(addr) ((addr) < 0x20000000 ? BKPT_HARD : BKPT_SOFT)
+
 
 /* forward declarations */
 static int cortex_m3_set_breakpoint(struct target *target, struct breakpoint *breakpoint);
@@ -864,10 +869,11 @@ static int cortex_m3_step(struct target *target, int current,
 	if (!current)
 		buf_set_u32(pc->value, 0, 32, address);
 
+	uint32_t pc_value = buf_get_u32(pc->value, 0, 32);
+
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints) {
-		breakpoint = breakpoint_find(target,
-				buf_get_u32(pc->value, 0, 32));
+		breakpoint = breakpoint_find(target, pc_value);
 		if (breakpoint)
 			cortex_m3_unset_breakpoint(target, breakpoint);
 	}
@@ -1071,7 +1077,7 @@ cortex_m3_set_breakpoint(struct target *target, struct breakpoint *breakpoint)
 
 	if (cortex_m3->auto_bp_type)
 	{
-		breakpoint->type = (breakpoint->address < 0x20000000) ? BKPT_HARD : BKPT_SOFT;
+		breakpoint->type = BKPT_TYPE_BY_ADDR(breakpoint->address);
 	}
 
 	if (breakpoint->type == BKPT_HARD)
@@ -1191,7 +1197,7 @@ cortex_m3_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
 
 	if (cortex_m3->auto_bp_type)
 	{
-		breakpoint->type = (breakpoint->address < 0x20000000) ? BKPT_HARD : BKPT_SOFT;
+		breakpoint->type = BKPT_TYPE_BY_ADDR(breakpoint->address);
 #ifdef ARMV7_GDB_HACKS
 		if (breakpoint->length != 2) {
 			/* XXX Hack: Replace all breakpoints with length != 2 with
@@ -1202,16 +1208,18 @@ cortex_m3_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
 #endif
 	}
 
-	if ((breakpoint->type == BKPT_HARD) && (breakpoint->address >= 0x20000000))
-	{
-		LOG_INFO("flash patch comparator requested outside code memory region");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
+	if(breakpoint->type != BKPT_TYPE_BY_ADDR(breakpoint->address)) {
+		if (breakpoint->type == BKPT_HARD)
+		{
+			LOG_INFO("flash patch comparator requested outside code memory region");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
 
-	if ((breakpoint->type == BKPT_SOFT) && (breakpoint->address < 0x20000000))
-	{
-		LOG_INFO("soft breakpoint requested in code (flash) memory region");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		if (breakpoint->type == BKPT_SOFT)
+		{
+			LOG_INFO("soft breakpoint requested in code (flash) memory region");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
 	}
 
 	if ((breakpoint->type == BKPT_HARD) && (cortex_m3->fp_code_available < 1))
@@ -1246,7 +1254,7 @@ cortex_m3_remove_breakpoint(struct target *target, struct breakpoint *breakpoint
 
 	if (cortex_m3->auto_bp_type)
 	{
-		breakpoint->type = (breakpoint->address < 0x20000000) ? BKPT_HARD : BKPT_SOFT;
+		breakpoint->type = BKPT_TYPE_BY_ADDR(breakpoint->address);
 	}
 
 	if (breakpoint->set)

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi       |   15 ++++-
 src/target/cortex_m3.c |  156 ++++++++++++++++++++++++++++++++++++++++--------
 src/target/cortex_m3.h |    9 +++
 3 files changed, 154 insertions(+), 26 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 28 18:43:19 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 28 Jun 2011 16:43:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-942-ge4c054c
Message-ID: <mailman.116.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e4c054cada07bf780fbb750bfd630ec6c03d6d99 (commit)
      from  ff640f197a9a343b2f3ed10e9174e35282334e8c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e4c054cada07bf780fbb750bfd630ec6c03d6d99
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 28 18:09:48 2011 +0200

    dsp5680xx: fix compilation problems
    
    use a more specific global variable name than "context", which
    can easily conflict with other things.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 9afda42..97cd0f4 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -28,6 +28,9 @@
 #include "target_type.h"
 #include "dsp5680xx.h"
 
+struct dsp5680xx_common dsp5680xx_context;
+
+
 #define err_check(retval,err_msg) if(retval != ERROR_OK){LOG_ERROR("%s: %d %s.",__FUNCTION__,__LINE__,err_msg);return retval;}
 #define err_check_propagate(retval) if(retval!=ERROR_OK){return retval;}
 
@@ -62,7 +65,7 @@ static int dsp5680xx_drscan(struct target * target, uint8_t * data_to_shift_into
   //can i send as many bits as i want?
   //is the casting necessary?
   jtag_add_plain_dr_scan(len,data_to_shift_into_dr,data_shifted_out_of_dr, TAP_IDLE);
-  if(context.flush){
+  if(dsp5680xx_context.flush){
 	retval = dsp5680xx_execute_queue();
 	err_check_propagate(retval);
   }
@@ -94,7 +97,7 @@ static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_int
   //can i send as many bits as i want?
   //is the casting necessary?
   jtag_add_plain_ir_scan(ir_len,(uint8_t *)data_to_shift_into_ir,(uint8_t *)data_shifted_out_of_ir, TAP_IDLE);
-  if(context.flush){
+  if(dsp5680xx_context.flush){
     retval = dsp5680xx_execute_queue();
     err_check_propagate(retval);
   }
@@ -505,7 +508,7 @@ static int eonce_pc_store(struct target * target){
   retval = eonce_rx_lower_data(target,(uint16_t *)&tmp);
   err_check_propagate(retval);
   LOG_USER("PC value: 0x%06X\n",tmp);
-  context.stored_pc = (uint32_t)tmp;
+  dsp5680xx_context.stored_pc = (uint32_t)tmp;
   return ERROR_OK;
 }
 
@@ -516,8 +519,8 @@ static int dsp5680xx_target_create(struct target *target, Jim_Interp * interp){
 }
 
 static int dsp5680xx_init_target(struct command_context *cmd_ctx, struct target *target){
-  context.stored_pc = 0;
-  context.flush = 1;
+  dsp5680xx_context.stored_pc = 0;
+  dsp5680xx_context.flush = 1;
   LOG_DEBUG("target initiated!");
   //TODO core tap must be enabled before running these commands, currently this is done in the .cfg tcl script.
   return ERROR_OK;
@@ -739,12 +742,12 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
   retval = dsp5680xx_convert_address(&address, &pmem);
   err_check_propagate(retval);
 
-  context.flush = 0;
+  dsp5680xx_context.flush = 0;
   int counter = FLUSH_COUNT_READ_WRITE;
 
   for (unsigned i=0; i<count; i++){
     if(--counter==0){
-      context.flush = 1;
+      dsp5680xx_context.flush = 1;
       counter = FLUSH_COUNT_FLASH;
     }
     switch (size){
@@ -766,10 +769,10 @@ static int dsp5680xx_read(struct target * target, uint32_t address, unsigned siz
       break;
     }
 	err_check_propagate(retval);
-    context.flush = 0;
+    dsp5680xx_context.flush = 0;
   }
 
-  context.flush = 1;
+  dsp5680xx_context.flush = 1;
   retval = dsp5680xx_execute_queue();
   err_check_propagate(retval);
 
@@ -823,18 +826,18 @@ static int dsp5680xx_write_8(struct target * target, uint32_t address, uint32_t
   int counter = FLUSH_COUNT_READ_WRITE;
   for(iter = 0; iter<count/2; iter++){
     if(--counter==0){
-      context.flush = 1;
+      dsp5680xx_context.flush = 1;
       counter = FLUSH_COUNT_READ_WRITE;
     }
     retval = dsp5680xx_write_16_single(target,address+iter,data_w[iter], pmem);
     if(retval != ERROR_OK){
       LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
-      context.flush = 1;
+      dsp5680xx_context.flush = 1;
       return retval;
     }
-    context.flush = 0;
+    dsp5680xx_context.flush = 0;
   }
-  context.flush = 1;
+  dsp5680xx_context.flush = 1;
 
   // Only one byte left, let's not overwrite the other byte (mem is 16bit)
   // Need to retrieve the part we do not want to overwrite.
@@ -863,18 +866,18 @@ static int dsp5680xx_write_16(struct target * target, uint32_t address, uint32_t
 
   for(iter = 0; iter<count; iter++){
 	if(--counter==0){
-	  context.flush = 1;
+	  dsp5680xx_context.flush = 1;
       counter = FLUSH_COUNT_READ_WRITE;
 	}
     retval = dsp5680xx_write_16_single(target,address+iter,data[iter], pmem);
     if(retval != ERROR_OK){
       LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
-	  context.flush = 1;
+	  dsp5680xx_context.flush = 1;
       return retval;
     }
-	context.flush = 0;
+	dsp5680xx_context.flush = 0;
   }
-  context.flush = 1;
+  dsp5680xx_context.flush = 1;
   return retval;
 }
 
@@ -889,18 +892,18 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
 
   for(iter = 0; iter<count; iter++){
 	if(--counter==0){
-	  context.flush = 1;
+	  dsp5680xx_context.flush = 1;
       counter = FLUSH_COUNT_READ_WRITE;
 	}
     retval = dsp5680xx_write_32_single(target,address+(iter<<1),data[iter], pmem);
     if(retval != ERROR_OK){
       LOG_ERROR("%s: Could not write to p:0x%04X",__FUNCTION__,address);
-	  context.flush = 1;
+	  dsp5680xx_context.flush = 1;
       return retval;
     }
-	context.flush = 0;
+	dsp5680xx_context.flush = 0;
   }
-  context.flush = 1;
+  dsp5680xx_context.flush = 1;
   return retval;
 }
 
@@ -1104,7 +1107,7 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
     }
   }while (!(i&0x40));				// wait until current command is complete
 
-  context.flush = 0;
+  dsp5680xx_context.flush = 0;
 
   retval = eonce_move_value_at_r2_disp(target,0x00,HFM_CNFG);	// write to HFM_CNFG (lock=0, select bank) -- flash_desc.bank&0x03,0x01 == 0x00,0x01 ???
   err_check_propagate(retval);
@@ -1134,7 +1137,7 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   retval = eonce_move_value_at_r2_disp(target,0x80,HFM_USTAT);		// start the command
   err_check_propagate(retval);
 
-  context.flush = 1;
+  dsp5680xx_context.flush = 1;
   retval = dsp5680xx_execute_queue();
   err_check_propagate(retval);
 
@@ -1371,7 +1374,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   // Setup registers needed by pgm_write_pflash
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
 
-  context.flush = 0;
+  dsp5680xx_context.flush = 0;
 
   retval = eonce_move_long_to_r3(target,address);  // Destination address to r3
   err_check_propagate(retval);
@@ -1400,7 +1403,7 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	err_check(retval,"Cannot handle odd number of words.");
   }
 
-  context.flush = 1;
+  dsp5680xx_context.flush = 1;
   retval = dsp5680xx_execute_queue();
   err_check_propagate(retval);
 
@@ -1412,21 +1415,21 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   err_check_propagate(retval);
 
   int counter = FLUSH_COUNT_FLASH;
-  context.flush = 0;
+  dsp5680xx_context.flush = 0;
   uint32_t i;
   for(i=1; (i<count/2)&&(i<HFM_SIZE_WORDS); i++){
     if(--counter==0){
-      context.flush = 1;
+      dsp5680xx_context.flush = 1;
       counter = FLUSH_COUNT_FLASH;
     }
     retval = eonce_tx_upper_data(target,buff16[i],&drscan_data);
 	if(retval!=ERROR_OK){
-	  context.flush = 1;
+	  dsp5680xx_context.flush = 1;
 	  err_check_propagate(retval);
 	}
-	context.flush = 0;
+	dsp5680xx_context.flush = 0;
   }
-  context.flush = 1;
+  dsp5680xx_context.flush = 1;
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Verify flash
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 3fbe90e..599fd68 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -217,7 +217,9 @@ struct dsp5680xx_common{
   //TODO
   uint32_t stored_pc;
   int flush;
-}context;
+};
+
+extern struct dsp5680xx_common dsp5680xx_context;
 
 static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target){
   return target->arch_info;

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp5680xx.c |   63 +++++++++++++++++++++++++----------------------
 src/target/dsp5680xx.h |    4 ++-
 2 files changed, 36 insertions(+), 31 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 28 18:45:55 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 28 Jun 2011 16:45:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-943-g2482244
Message-ID: <mailman.117.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2482244b0788c007dd789c21a4416379c229ea5c (commit)
      from  e4c054cada07bf780fbb750bfd630ec6c03d6d99 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2482244b0788c007dd789c21a4416379c229ea5c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 28 18:22:32 2011 +0200

    mips4k: fix big-endian hosts and host alignment problems
    
    the code was making assumptions about the endianness of the host.

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 03c9969..9b4e1a4 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -877,11 +877,11 @@ static int mips_m4k_read_memory(struct target *target, uint32_t address,
 		switch(size)
 		{
 		case 4:
-			t32 = *(uint32_t*)&buffer[i];
+			t32 = le_to_h_u32(&buffer[i]);
 			target_buffer_set_u32(target,&buffer[i], t32);
 			break;
 		case 2:
-			t16 = *(uint16_t*)&buffer[i];
+			t16 = le_to_h_u16(&buffer[i]);
 			target_buffer_set_u16(target,&buffer[i], t16);
 			break;
 		}
@@ -930,11 +930,11 @@ static int mips_m4k_write_memory(struct target *target, uint32_t address,
 		{
 		case 4:
 			t32 = target_buffer_get_u32(target,&buffer[i]);
-			*(uint32_t*)&t[i] = t32;
+			h_u32_to_le(&t[i], t32);
 			break;
 		case 2:
 			t16 = target_buffer_get_u16(target,&buffer[i]);
-			*(uint16_t*)&t[i] = t16;
+			h_u16_to_le(&t[i], t16);
 			break;
 		}
 	}
@@ -1074,7 +1074,7 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 	for(i = 0; i < (count*4); i += 4)
 	{
 		t32 = target_buffer_get_u32(target,&buffer[i]);
-		*(uint32_t*)&t[i] = t32;
+		h_u32_to_le(&t[i], t32);
 	}
 	
 	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32->fast_data_area, write_t, address,

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips_m4k.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 28 18:46:21 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 28 Jun 2011 16:46:21 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-944-gd567df0
Message-ID: <mailman.118.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d567df02b9f3e7d2e7e78b3c2907ecad9aa4bbd4 (commit)
      from  2482244b0788c007dd789c21a4416379c229ea5c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d567df02b9f3e7d2e7e78b3c2907ecad9aa4bbd4
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 28 18:35:34 2011 +0200

    dsp5680xx: disable for now, it generates warnings
    
    Use "git revert <commit>" to revert this commit, then build and
    repair and post patch to the mailing list.
    
    Warnings generated with:
    
    nios2-elf-gcc (GCC) 3.4.6 (Altera Nios II 9.1 b222)
    
    openocd/src/target/dsp5680xx.c: In function 'eonce_rx_upper_data':
    openocd/src/target/dsp5680xx.c:252: warning: cast increases required
    alignment of target type
    openocd/src/target/dsp5680xx.c: In function 'eonce_rx_lower_data':
    openocd/src/target/dsp5680xx.c:268: warning: cast increases required
    alignment of target type
    openocd/src/target/dsp5680xx.c: In function 'eonce_pc_store':
    openocd/src/target/dsp5680xx.c:508: warning: dereferencing type-punned
    pointer will break strict-aliasing rules
    openocd/src/target/dsp5680xx.c: In function 'dsp5680xx_read':
    openocd/src/target/dsp5680xx.c:736: warning: cast increases required
    alignment of target type
    openocd/src/target/dsp5680xx.c:737: warning: cast increases required
    alignment of target type
    openocd/src/target/dsp5680xx.c: In function 'dsp5680xx_write_8':
    openocd/src/target/dsp5680xx.c:823: warning: cast increases required
    alignment of target type
    openocd/src/target/dsp5680xx.c: In function 'dsp5680xx_write':
    openocd/src/target/dsp5680xx.c:938: warning: cast increases required
    alignment of target type
    openocd/src/target/dsp5680xx.c:941: warning: cast increases required
    alignment of target type
    openocd/src/target/dsp5680xx.c: In function 'dsp5680xx_f_wr':
    openocd/src/target/dsp5680xx.c:1355: warning: cast increases required
    alignment of target type

diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 98460af..41fb564 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -30,9 +30,11 @@ NOR_DRIVERS = \
 	str9x.c \
 	str9xpec.c \
 	tms470.c \
-	dsp5680xx_flash.c \
 	virtual.c
 
+# Disabled for now, it generates warnings
+# dsp5680xx_flash.c 
+
 noinst_HEADERS = \
 	core.h \
 	cfi.h \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 52febf1..637c63b 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -43,7 +43,7 @@ extern struct flash_driver faux_flash;
 extern struct flash_driver virtual_flash;
 extern struct flash_driver stmsmi_flash;
 extern struct flash_driver em357_flash;
-extern struct flash_driver dsp5680xx_flash;
+//extern struct flash_driver dsp5680xx_flash;
 
 /**
  * The list of built-in flash drivers.
@@ -72,7 +72,8 @@ static struct flash_driver *flash_drivers[] = {
 	&virtual_flash,
 	&stmsmi_flash,
 	&em357_flash,
-	&dsp5680xx_flash,
+	// Disabled for now, it generates warnings
+	//&dsp5680xx_flash,
 	NULL,
 };
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 27ad054..2de0646 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -33,8 +33,10 @@ libtarget_la_SOURCES = \
 	$(MIPS32_SRC) \
 	avrt.c \
 	dsp563xx.c \
-	dsp563xx_once.c \
-	dsp5680xx.c
+	dsp563xx_once.c
+	
+# This file generates warnings, disabled for now, see also target.c
+#	dsp5680xx.c
 
 TARGET_CORE_SRC = \
 	algorithm.c \
diff --git a/src/target/target.c b/src/target/target.c
index 0343156..f62915e 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -81,7 +81,7 @@ extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
 extern struct target_type dsp563xx_target;
-extern struct target_type dsp5680xx_target;
+//extern struct target_type dsp5680xx_target;
 extern struct target_type testee_target;
 extern struct target_type avr32_ap7k_target;
 
@@ -104,7 +104,8 @@ static struct target_type *target_types[] =
 	&mips_m4k_target,
 	&avr_target,
 	&dsp563xx_target,
-	&dsp5680xx_target,
+// Disabled for now, it generates warnings
+//	&dsp5680xx_target,
 	&testee_target,
 	&avr32_ap7k_target,
 	NULL,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/Makefile.am |    4 +++-
 src/flash/nor/drivers.c   |    5 +++--
 src/target/Makefile.am    |    6 ++++--
 src/target/target.c       |    5 +++--
 4 files changed, 13 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Jun 29 18:39:03 2011
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 29 Jun 2011 16:39:03 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-945-gf6026a8
Message-ID: <mailman.119.1331736155.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f6026a8295faf158e500a7acb9884f9fd4c30ad1 (commit)
      from  d567df02b9f3e7d2e7e78b3c2907ecad9aa4bbd4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f6026a8295faf158e500a7acb9884f9fd4c30ad1
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Jun 29 16:01:54 2011 +0100

    jimtcl: update to 0.71 based release
    
    The actual release is 411e92fea9621630eb350e0c2bb43543e553b84f as we
    had a few issues relating to its use within openocd.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/jimtcl b/jimtcl
index 60dfb02..411e92f 160000
--- a/jimtcl
+++ b/jimtcl
@@ -1 +1 @@
-Subproject commit 60dfb023c4afa95047e0fa8db49830ccb46446b2
+Subproject commit 411e92fea9621630eb350e0c2bb43543e553b84f

-----------------------------------------------------------------------

Summary of changes:
 jimtcl |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


