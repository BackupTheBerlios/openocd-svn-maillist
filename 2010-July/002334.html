<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-443-ga9761c9
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-July/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-443-ga9761c9&In-Reply-To=%3CE1OaxTi-0005zk-WD%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002333.html">
   <LINK REL="Next"  HREF="002335.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-443-ga9761c9</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-443-ga9761c9&In-Reply-To=%3CE1OaxTi-0005zk-WD%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-443-ga9761c9">gowinex at users.sourceforge.net
       </A><BR>
    <I>Mon Jul 19 23:02:21 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002333.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-431-g6121841
</A></li>
        <LI>Next message: <A HREF="002335.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-444-ge0525cd
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2334">[ date ]</a>
              <a href="thread.html#2334">[ thread ]</a>
              <a href="subject.html#2334">[ subject ]</a>
              <a href="author.html#2334">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  a9761c90931101d280b9443126db017f96d92e3d (commit)
       via  441ea95f693316052f04486b927abb2b152ca547 (commit)
       via  4333840ee3d6d79299bf90b719a3c1628c688690 (commit)
       via  5164fe55639877be4dd6a7c0a504aa1bc279d64d (commit)
       via  b62c8d600995638081f9a34c358db58337df7bdb (commit)
       via  a7315891eff5ed84dbd88e950321c6ff2a58e867 (commit)
       via  7dcde11b459f60d40db9ca53f038cd200c852064 (commit)
       via  e7a1ec64bface364305e9c355811838e9f310bf3 (commit)
       via  44ef0327dd97c1893afc63cd7fd8025cb1b57827 (commit)
       via  6c573df11d1c1bc76c897d0688adfd00ec56ca8e (commit)
       via  6a237c23c1adb0be91a82a44d2cf13ff158b3ee2 (commit)
       via  70fee9207b5fd1c6f499b790591446adc4d4467c (commit)
      from  612184176fee6333e5372c4637e3cf54628ee416 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a9761c90931101d280b9443126db017f96d92e3d
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 14:49:41 2010 +0200

    arm_dpm: error propagation fixes
    
    found by inspection
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 4fbe5e3..012316b 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -123,6 +123,8 @@ static int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
 		cpsr = mode;
 
 	retval = dpm-&gt;instr_write_data_r0(dpm, ARMV4_5_MSR_GP(0, 0xf, 0), cpsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (dpm-&gt;instr_cpsr_sync)
 		retval = dpm-&gt;instr_cpsr_sync(dpm);
@@ -211,6 +213,8 @@ static int dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 		retval = dpm-&gt;instr_write_data_r0(dpm,
 				ARMV4_5_MSR_GP(0, 0xf, regnum &amp; 1),
 				value);
+		if (retval != ERROR_OK)
+			return retval;
 
 		if (regnum == 16 &amp;&amp; dpm-&gt;instr_cpsr_sync)
 			retval = dpm-&gt;instr_cpsr_sync(dpm);
@@ -364,6 +368,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 			retval = dpm_maybe_update_bpwp(dpm, bpwp, &amp;dbp-&gt;bpwp,
 					bp ? &amp;bp-&gt;set : NULL);
+			if (retval != ERROR_OK)
+				goto done;
 		}
 	}
 
@@ -374,6 +380,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 		retval = dpm_maybe_update_bpwp(dpm, bpwp, &amp;dwp-&gt;bpwp,
 				wp ? &amp;wp-&gt;set : NULL);
+		if (retval != ERROR_OK)
+			goto done;
 	}
 
 	/* NOTE:  writes to breakpoint and watchpoint registers might
@@ -433,7 +441,11 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 
 				/* REVISIT error checks */
 				if (tmode != ARM_MODE_ANY)
+				{
 					retval = dpm_modeswitch(dpm, tmode);
+					if (retval != ERROR_OK)
+						goto done;
+				}
 			}
 			if (r-&gt;mode != mode)
 				continue;
@@ -441,7 +453,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 			retval = dpm_write_reg(dpm,
 					&amp;cache-&gt;reg_list[i],
 					regnum);
-
+			if (retval != ERROR_OK)
+				goto done;
 		}
 
 	} while (did_write);
@@ -451,13 +464,19 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * defined, and must not write it before CPSR.
 	 */
 	retval = dpm_modeswitch(dpm, ARM_MODE_ANY);
+	if (retval != ERROR_OK)
+		goto done;
 	arm-&gt;cpsr-&gt;dirty = false;
 
 	retval = dpm_write_reg(dpm, arm-&gt;pc, 15);
+	if (retval != ERROR_OK)
+		goto done;
 	arm-&gt;pc-&gt;dirty = false;
 
 	/* flush R0 -- it's *very* dirty by now */
 	retval = dpm_write_reg(dpm, &amp;cache-&gt;reg_list[0], 0);
+	if (retval != ERROR_OK)
+		goto done;
 	cache-&gt;reg_list[0].dirty = false;
 
 	/* (void) */ dpm-&gt;finish(dpm);
@@ -540,6 +559,8 @@ static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
 	}
 
 	retval = dpm_read_reg(dpm, r, regnum);
+	if (retval != ERROR_OK)
+		goto fail;
 	/* always clean up, regardless of error */
 
 	if (mode != ARM_MODE_ANY)
@@ -636,6 +657,8 @@ static int arm_dpm_full_context(struct target *target)
 
 				/* REVISIT error checks */
 				retval = dpm_modeswitch(dpm, mode);
+				if (retval != ERROR_OK)
+					goto done;
 			}
 			if (r-&gt;mode != mode)
 				continue;
@@ -644,7 +667,8 @@ static int arm_dpm_full_context(struct target *target)
 			retval = dpm_read_reg(dpm,
 					&amp;cache-&gt;reg_list[i],
 					(r-&gt;num == 16) ? 17 : r-&gt;num);
-
+			if (retval != ERROR_OK)
+				goto done;
 		}
 
 	} while (did_read);

commit 441ea95f693316052f04486b927abb2b152ca547
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 14:42:54 2010 +0200

    adi_jtag_ error propagation
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 185bd54..8731a1a 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -211,8 +211,10 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 	/* Post CTRL/STAT read; discard any previous posted read value
 	 * but collect its ACK status.
 	 */
-	adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+	retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+	if (retval != ERROR_OK)
+		return retval;
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
@@ -246,8 +248,10 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
-			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+			if (retval != ERROR_OK)
+				return retval;
 			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 			dap-&gt;ack = dap-&gt;ack &amp; 0x7;
@@ -292,12 +296,16 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 				LOG_ERROR(&quot;JTAG-DP STICKY ERROR&quot;);
 
 			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_WRITE,
 					dap-&gt;dp_ctrl_stat | SSTICKYORUN
 						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			if (retval != ERROR_OK)
+				return retval;
+			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
+			if (retval != ERROR_OK)
+				return retval;
 			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 

commit 4333840ee3d6d79299bf90b719a3c1628c688690
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 14:37:45 2010 +0200

    arm: error propagation of arm_jtag_set_instr
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 0a374be..185bd54 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -86,8 +86,11 @@ int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	struct arm_jtag *jtag_info = dap-&gt;jtag_info;
 	struct scan_field fields[2];
 	uint8_t out_addr_buf;
+	int retval;
 
-	arm_jtag_set_instr(jtag_info, instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index b742dae..abfb21b 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -690,9 +690,13 @@ int arm7_9_execute_sys_speed(struct target *target)
 	/* set RESTART instruction */
 	if (arm7_9-&gt;need_bypass_before_restart) {
 		arm7_9-&gt;need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		if (retval != ERROR_OK)
+			return retval;
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	long long then = timeval_ms();
 	int timeout;
@@ -738,13 +742,18 @@ static int arm7_9_execute_fast_sys_speed(struct target *target)
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm_jtag *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	struct reg *dbg_stat = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_STAT];
+	int retval;
 
 	/* set RESTART instruction */
 	if (arm7_9-&gt;need_bypass_before_restart) {
 		arm7_9-&gt;need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		if (retval != ERROR_OK)
+			return retval;
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (!set)
 	{
@@ -1744,13 +1753,19 @@ static int arm7_9_restart_core(struct target *target)
 {
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm_jtag *jtag_info = &amp;arm7_9-&gt;jtag_info;
+	int retval;
 
 	/* set RESTART instruction */
 	if (arm7_9-&gt;need_bypass_before_restart) {
 		arm7_9-&gt;need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+
+		retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+		if (retval != ERROR_OK)
+			return retval;
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	jtag_add_runtest(1, TAP_IDLE);
 	return jtag_execute_queue();
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 541adc8..8befe2b 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -68,7 +68,9 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		{
 			return retval;
 		}
-		arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		retval = arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		if (retval != ERROR_OK)
+			return retval;
 
 		jtag_add_dr_scan(arm7_9-&gt;jtag_info.tap, 2, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -117,8 +119,11 @@ static __inline int arm7tdmi_clock_out_inner(struct arm_jtag *jtag_info, uint32_
 static __inline int arm7tdmi_clock_out(struct arm_jtag *jtag_info,
 		uint32_t out, uint32_t *deprecated, int breakpoint)
 {
+	int retval;
 	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return arm7tdmi_clock_out_inner(jtag_info, out, breakpoint);
 }
@@ -133,7 +138,9 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
@@ -217,7 +224,9 @@ static int arm7tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 7627b25..c5064c1 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -89,11 +89,14 @@ static int arm920t_read_cp15_physical(struct target *target,
 	uint8_t access_type_buf = 1;
 	uint8_t reg_addr_buf = reg_addr &amp; 0x3f;
 	uint8_t nr_w_buf = 0;
+	int retval;
 
 	jtag_info = &amp;arm920t-&gt;arm7_9_common.jtag_info;
 
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = &amp;access_type_buf;
@@ -137,13 +140,16 @@ static int arm920t_write_cp15_physical(struct target *target,
 	uint8_t reg_addr_buf = reg_addr &amp; 0x3f;
 	uint8_t nr_w_buf = 1;
 	uint8_t value_buf[4];
+	int retval;
 
 	jtag_info = &amp;arm920t-&gt;arm7_9_common.jtag_info;
 
 	buf_set_u32(value_buf, 0, 32, value);
 
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = &amp;access_type_buf;
@@ -192,7 +198,9 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 	jtag_info = &amp;arm920t-&gt;arm7_9_common.jtag_info;
 
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	buf_set_u32(cp15_opcode_buf, 0, 32, cp15_opcode);
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index aa38d27..3765f23 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -67,7 +67,9 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -120,7 +122,9 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	LOG_DEBUG(&quot;addr: 0x%x value: %8.8x&quot;, address, *value);
 #endif
 
-	arm_jtag_set_instr(jtag_info, 0xc, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0xc, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return ERROR_OK;
 }
@@ -155,7 +159,9 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
@@ -205,7 +211,9 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	LOG_DEBUG(&quot;addr: 0x%x value: %8.8x&quot;, address, value);
 #endif
 
-	arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index b4207c8..170e3cc 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -88,7 +88,9 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	/* REVISIT: table 7-2 shows that bits 31-31 need to be
@@ -142,7 +144,9 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 0749a56..fd50703 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -103,7 +103,9 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		{
 			return retval;
 		}
-		arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		retval = arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL, TAP_DRPAUSE);
+		if (retval != ERROR_OK)
+			return retval;
 
 		jtag_add_dr_scan(arm7_9-&gt;jtag_info.tap, 3, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -157,7 +159,9 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
@@ -215,7 +219,9 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -281,7 +287,9 @@ int arm9tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 7ef4ac4..965260c 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -344,10 +344,13 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	struct scan_field fields[3];
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
+	int retval;
 
 	arm_jtag_scann(ice_reg-&gt;jtag_info, 0x2, TAP_IDLE);
 
-	arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* bits 31:0 -- data (ignored here) */
 	fields[0].num_bits = 32;
@@ -405,9 +408,12 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	struct scan_field fields[3];
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
+	int retval;
 
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -487,12 +493,13 @@ static int embeddedice_set_reg_w_exec(struct reg *reg, uint8_t *buf)
 void embeddedice_write_reg(struct reg *reg, uint32_t value)
 {
 	struct embeddedice_reg *ice_reg = reg-&gt;arch_info;
+	int retval;
 
 	LOG_DEBUG(&quot;%i: 0x%8.8&quot; PRIx32 &quot;&quot;, ice_reg-&gt;addr, value);
 
 	arm_jtag_scann(ice_reg-&gt;jtag_info, 0x2, TAP_IDLE);
 
-	arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
 
 	uint8_t reg_addr = ice_reg-&gt;addr &amp; 0x1f;
 	embeddedice_write_reg_inner(ice_reg-&gt;jtag_info-&gt;tap, reg_addr, value);
@@ -521,9 +528,12 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	uint8_t field0_out[4];
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
+	int retval;
 
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = field0_out;
@@ -575,7 +585,9 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 		return ERROR_INVALID_ARGUMENTS;
 
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
diff --git a/src/target/etm.c b/src/target/etm.c
index 61ee99a..5c42fb5 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -496,6 +496,7 @@ static int etm_read_reg_w_check(struct reg *reg,
 	const struct etm_reg_info *r = etm_reg-&gt;reg_info;
 	uint8_t reg_addr = r-&gt;addr &amp; 0x7f;
 	struct scan_field fields[3];
+	int retval;
 
 	if (etm_reg-&gt;reg_info-&gt;mode == WO) {
 		LOG_ERROR(&quot;BUG: can't read write-only register %s&quot;, r-&gt;name);
@@ -505,7 +506,9 @@ static int etm_read_reg_w_check(struct reg *reg,
 	LOG_DEBUG(&quot;%s (%u)&quot;, r-&gt;name, reg_addr);
 
 	arm_jtag_scann(etm_reg-&gt;jtag_info, 0x6, TAP_IDLE);
-	arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg-&gt;value;
@@ -577,6 +580,7 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	const struct etm_reg_info *r = etm_reg-&gt;reg_info;
 	uint8_t reg_addr = r-&gt;addr &amp; 0x7f;
 	struct scan_field fields[3];
+	int retval;
 
 	if (etm_reg-&gt;reg_info-&gt;mode == RO) {
 		LOG_ERROR(&quot;BUG: can't write read--only register %s&quot;, r-&gt;name);
@@ -586,7 +590,9 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	LOG_DEBUG(&quot;%s (%u): 0x%8.8&quot; PRIx32 &quot;&quot;, r-&gt;name, reg_addr, value);
 
 	arm_jtag_scann(etm_reg-&gt;jtag_info, 0x6, TAP_IDLE);
-	arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	retval = arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL, TAP_IDLE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	uint8_t tmp1[4];
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index ea22ca0..6ca432a 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -78,6 +78,7 @@ static int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 	uint8_t out_buf[4];
 	uint8_t instr_buf[4];
 	uint8_t sysspeed_buf = 0x0;
+	int retval;
 
 	/* prepare buffer */
 	buf_set_u32(out_buf, 0, 32, 0);
@@ -86,7 +87,9 @@ static int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 
 	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
 
-	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	retval = arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL, TAP_DRPAUSE);
+	if (retval != ERROR_OK)
+		return retval;
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;

commit 5164fe55639877be4dd6a7c0a504aa1bc279d64d
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 14:22:35 2010 +0200

    arm_adi_v5: dap_run() error propagation
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 39d8bde..b26175b 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -321,7 +321,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 				break;
 		}
 
-		if (dap_run(dap) == ERROR_OK)
+		if ((retval = dap_run(dap)) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address = address + 4 * blocksize;
@@ -335,8 +335,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 		if (errorcount &gt; 1)
 		{
 			LOG_WARNING(&quot;Block write error address 0x%&quot; PRIx32 &quot;, wcount 0x%x&quot;, address, wcount);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
+			return retval;
 		}
 	}
 
@@ -406,13 +405,12 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(dap) != ERROR_OK)
+				if ((retval = dap_run(dap)) != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
 						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
 						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 			}
 
@@ -515,13 +513,12 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(dap) != ERROR_OK)
+				if ((retval = dap_run(dap)) != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
 						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
 						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 			}
 
@@ -712,11 +709,12 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *dap,
 		do
 		{
 			retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
-			if (dap_run(dap) != ERROR_OK)
+			if (retval != ERROR_OK)
+				return retval;
+			if ((retval = dap_run(dap)) != ERROR_OK)
 			{
 				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
+				return retval;
 			}
 
 			nbytes = MIN((readcount &lt;&lt; 1), 4);
@@ -821,11 +819,12 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *dap,
 		do
 		{
 			retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
-			if (dap_run(dap) != ERROR_OK)
+			if (retval != ERROR_OK)
+				return retval;
+			if ((retval = dap_run(dap)) != ERROR_OK)
 			{
 				LOG_WARNING(&quot;Block read error address 0x%&quot; PRIx32 &quot;, count 0x%x&quot;, address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
+				return retval;
 			}
 
 			nbytes = MIN(readcount, 4);
@@ -993,7 +992,11 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	 * place to scan the table and do any topology detection?
 	 */
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;idreg);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &amp;romaddr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((retval = dap_run(dap)) != ERROR_OK)
 		return retval;
@@ -1039,7 +1042,11 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	apselold = dap-&gt;apsel;
 	dap_ap_select(dap, apsel);
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &amp;dbgbase);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1490,6 +1497,8 @@ COMMAND_HANDLER(dap_baseaddr_command)
 	 * use the ID register to verify it's a MEM-AP.
 	 */
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &amp;baseaddr);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1553,6 +1562,8 @@ COMMAND_HANDLER(dap_apsel_command)
 
 	dap_ap_select(dap, apsel);
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1591,6 +1602,8 @@ COMMAND_HANDLER(dap_apid_command)
 		dap_ap_select(dap, apsel);
 
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &amp;apid);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;

commit b62c8d600995638081f9a34c358db58337df7bdb
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 14:03:33 2010 +0200

    arm_adi_v5: mem_ap_write error propagation
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 194865e..39d8bde 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -376,13 +376,14 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 
 			if (nbytes &lt; 4)
 			{
-				if (mem_ap_write_buf_u16(dap, buffer,
-						nbytes, address) != ERROR_OK)
+				retval = mem_ap_write_buf_u16(dap, buffer,
+						nbytes, address);
+				if (retval != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
 						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
 						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 
 				address += nbytes &gt;&gt; 1;
@@ -485,12 +486,13 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 
 			if (nbytes &lt; 4)
 			{
-				if (mem_ap_write_buf_u8(dap, buffer, nbytes, address) != ERROR_OK)
+				retval = mem_ap_write_buf_u8(dap, buffer, nbytes, address);
+				if (retval != ERROR_OK)
 				{
 					LOG_WARNING(&quot;Block write error address &quot;
 						&quot;0x%&quot; PRIx32 &quot;, count 0x%x&quot;,
 						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
+					return retval;
 				}
 
 				address += nbytes;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 7bdf7d5..2a58f5b 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -166,7 +166,9 @@ static int cortex_m3_clear_halt(struct target *target)
 		return retval;
 
 	/* Clear Debug Fault Status */
-	mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3-&gt;nvic_dfsr);
+	retval = mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3-&gt;nvic_dfsr);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(&quot; NVIC_DFSR 0x%&quot; PRIx32 &quot;&quot;, cortex_m3-&gt;nvic_dfsr);
 
 	return ERROR_OK;
@@ -177,6 +179,7 @@ static int cortex_m3_single_step_core(struct target *target)
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct adiv5_dap *swjdp = &amp;cortex_m3-&gt;armv7m.dap;
 	uint32_t dhcsr_save;
+	int retval;
 
 	/* backup dhcsr reg */
 	dhcsr_save = cortex_m3-&gt;dcb_dhcsr;
@@ -186,10 +189,16 @@ static int cortex_m3_single_step_core(struct target *target)
 	 * HALT can put the core into an unknown state.
 	 */
 	if (!(cortex_m3-&gt;dcb_dhcsr &amp; C_MASKINTS))
-		mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+	{
+		retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
 				DBGKEY | C_MASKINTS | C_HALT | C_DEBUGEN);
-	mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
 				DBGKEY | C_MASKINTS | C_STEP | C_DEBUGEN);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(&quot; &quot;);
 
 	/* restore dhcsr reg */
@@ -217,14 +226,20 @@ static int cortex_m3_endreset_event(struct target *target)
 	LOG_DEBUG(&quot;DCB_DEMCR = 0x%8.8&quot; PRIx32 &quot;&quot;,dcb_demcr);
 
 	/* this register is used for emulated dcc channel */
-	mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	retval = mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Enable debug requests */
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m3-&gt;dcb_dhcsr &amp; C_DEBUGEN))
-		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+	{
+		retval = mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	/* clear any interrupt masking */
 	cortex_m3_write_debug_halt_mask(target, 0, C_MASKINTS);
@@ -236,31 +251,44 @@ static int cortex_m3_endreset_event(struct target *target)
 	 * choices *EXCEPT* explicitly scripted overrides like &quot;vector_catch&quot;
 	 * or manual updates to the NVIC SHCSR and CCR registers.
 	 */
-	mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | armv7m-&gt;demcr);
+	retval = mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | armv7m-&gt;demcr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Paranoia: evidently some (early?) chips don't preserve all the
 	 * debug state (including FBP, DWT, etc) across reset...
 	 */
 
 	/* Enable FPB */
-	target_write_u32(target, FP_CTRL, 3);
+	retval = target_write_u32(target, FP_CTRL, 3);
+	if (retval != ERROR_OK)
+		return retval;
+
 	cortex_m3-&gt;fpb_enabled = 1;
 
 	/* Restore FPB registers */
 	for (i = 0; i &lt; cortex_m3-&gt;fp_num_code + cortex_m3-&gt;fp_num_lit; i++)
 	{
-		target_write_u32(target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
+		retval = target_write_u32(target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	/* Restore DWT registers */
 	for (i = 0; i &lt; cortex_m3-&gt;dwt_num_comp; i++)
 	{
-		target_write_u32(target, dwt_list[i].dwt_comparator_address + 0,
+		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 0,
 				dwt_list[i].comp);
-		target_write_u32(target, dwt_list[i].dwt_comparator_address + 4,
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 4,
 				dwt_list[i].mask);
-		target_write_u32(target, dwt_list[i].dwt_comparator_address + 8,
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 8,
 				dwt_list[i].function);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	retval = dap_run(swjdp);
 	if (retval != ERROR_OK)
@@ -639,12 +667,16 @@ static int cortex_m3_soft_reset_halt(struct target *target)
 	int retval, timeout = 0;
 
 	/* Enter debug state on reset; restore DEMCR in endreset_event() */
-	mem_ap_write_u32(swjdp, DCB_DEMCR,
+	retval = mem_ap_write_u32(swjdp, DCB_DEMCR,
 			TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Request a core-only reset */
-	mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+	retval = mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
 			AIRCR_VECTKEY | AIRCR_VECTRESET);
+	if (retval != ERROR_OK)
+		return retval;
 	target-&gt;state = TARGET_RESET;
 
 	/* registers are now invalid */
@@ -902,16 +934,26 @@ static int cortex_m3_assert_reset(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m3-&gt;dcb_dhcsr &amp; C_DEBUGEN))
-		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+	{
+		retval = mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
-	mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	retval = mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (!target-&gt;reset_halt)
 	{
 		/* Set/Clear C_MASKINTS in a separate operation */
 		if (cortex_m3-&gt;dcb_dhcsr &amp; C_MASKINTS)
-			mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+		{
+			retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
 					DBGKEY | C_DEBUGEN | C_HALT);
+			if (retval != ERROR_OK)
+				return retval;
+		}
 
 		/* clear any debug flags before resuming */
 		cortex_m3_clear_halt(target);
@@ -927,8 +969,10 @@ static int cortex_m3_assert_reset(struct target *target)
 		 * bad vector table entries.  Should this include MMERR or
 		 * other flags too?
 		 */
-		mem_ap_write_atomic_u32(swjdp, DCB_DEMCR,
+		retval = mem_ap_write_atomic_u32(swjdp, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	/*
@@ -992,8 +1036,10 @@ static int cortex_m3_assert_reset(struct target *target)
 		 * core, like watchdog timers, if the SoC wires it up
 		 * correctly.  Else VECRESET can reset just the core.
 		 */
-		mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+		retval = mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
 				AIRCR_VECTKEY | AIRCR_SYSRESETREQ);
+		if (retval != ERROR_OK)
+			return retval;
 		LOG_DEBUG(&quot;Using Cortex-M3 SYSRESETREQ&quot;);
 
 		{
@@ -1834,6 +1880,7 @@ static int cortex_m3_examine(struct target *target)
 static int cortex_m3_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
 {
 	uint16_t dcrdr;
+	int retval;
 
 	mem_ap_read_buf_u16(swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
 	*ctrl = (uint8_t)dcrdr;
@@ -1846,7 +1893,9 @@ static int cortex_m3_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *
 	if (dcrdr &amp; (1 &lt;&lt; 0))
 	{
 		dcrdr = 0;
-		mem_ap_write_buf_u16(swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
+		retval = mem_ap_write_buf_u16(swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	return ERROR_OK;
@@ -2041,7 +2090,9 @@ write:
 		demcr |= catch;
 
 		/* write, but don't assume it stuck (why not??) */
-		mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
+		retval = mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;demcr);
 		if (retval != ERROR_OK)
 			return retval;

commit a7315891eff5ed84dbd88e950321c6ff2a58e867
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 13:56:59 2010 +0200

    arm_adi_v5: error propagation of mem_ap_read_atomic_u32 failure
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 496360f..194865e 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1124,7 +1124,9 @@ static int dap_info_command(struct command_context *cmd_ctx,
 		entry_offset = 0;
 		do
 		{
-			mem_ap_read_atomic_u32(dap, (dbgbase&amp;0xFFFFF000) | entry_offset, &amp;romentry);
+			retval = mem_ap_read_atomic_u32(dap, (dbgbase&amp;0xFFFFF000) | entry_offset, &amp;romentry);
+			if (retval != ERROR_OK)
+				return retval;
 			command_print(cmd_ctx, &quot;\tROMTABLE[0x%x] = 0x%&quot; PRIx32 &quot;&quot;,entry_offset,romentry);
 			if (romentry&amp;0x01)
 			{
@@ -1140,33 +1142,51 @@ static int dap_info_command(struct command_context *cmd_ctx,
 				/* IDs are in last 4K section */
 
 
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFE0, &amp;c_pid0);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid0 &amp;= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFE4, &amp;c_pid1);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid1 &amp;= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFE8, &amp;c_pid2);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid2 &amp;= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFEC, &amp;c_pid3);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid3 &amp;= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFD0, &amp;c_pid4);
+				if (retval != ERROR_OK)
+					return retval;
 				c_pid4 &amp;= 0xff;
 
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFF0, &amp;c_cid0);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid0 &amp;= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFF4, &amp;c_cid1);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid1 &amp;= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFF8, &amp;c_cid2);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid2 &amp;= 0xff;
-				mem_ap_read_atomic_u32(dap,
+				retval = mem_ap_read_atomic_u32(dap,
 					component_base + 0xFFC, &amp;c_cid3);
+				if (retval != ERROR_OK)
+					return retval;
 				c_cid3 &amp;= 0xff;
 
 
@@ -1187,9 +1207,11 @@ static int dap_info_command(struct command_context *cmd_ctx,
 					unsigned minor;
 					char *major = &quot;Reserved&quot;, *subtype = &quot;Reserved&quot;;
 
-					mem_ap_read_atomic_u32(dap,
+					retval = mem_ap_read_atomic_u32(dap,
 							(component_base &amp; 0xfffff000) | 0xfcc,
 							&amp;devtype);
+					if (retval != ERROR_OK)
+						return retval;
 					minor = (devtype &gt;&gt; 4) &amp; 0x0f;
 					switch (devtype &amp; 0x0f) {
 					case 0:
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 6939890..7bdf7d5 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -155,12 +155,15 @@ static int cortex_m3_clear_halt(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct adiv5_dap *swjdp = &amp;cortex_m3-&gt;armv7m.dap;
+	int retval;
 
 	/* clear step if any */
 	cortex_m3_write_debug_halt_mask(target, C_HALT, C_STEP);
 
 	/* Read Debug Fault Status Register */
-	mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &amp;cortex_m3-&gt;nvic_dfsr);
+	retval = mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &amp;cortex_m3-&gt;nvic_dfsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Clear Debug Fault Status */
 	mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m3-&gt;nvic_dfsr);
@@ -208,14 +211,18 @@ static int cortex_m3_endreset_event(struct target *target)
 	struct cortex_m3_dwt_comparator *dwt_list = cortex_m3-&gt;dwt_comparator_list;
 
 	/* REVISIT The four debug monitor bits are currently ignored... */
-	mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;dcb_demcr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;dcb_demcr);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(&quot;DCB_DEMCR = 0x%8.8&quot; PRIx32 &quot;&quot;,dcb_demcr);
 
 	/* this register is used for emulated dcc channel */
 	mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
 
 	/* Enable debug requests */
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 	if (!(cortex_m3-&gt;dcb_dhcsr &amp; C_DEBUGEN))
 		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
 
@@ -262,7 +269,7 @@ static int cortex_m3_endreset_event(struct target *target)
 	register_cache_invalidate(cortex_m3-&gt;armv7m.core_cache);
 
 	/* make sure we have latest dhcsr flags */
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
 
 	return retval;
 }
@@ -396,7 +403,9 @@ static int cortex_m3_debug_entry(struct target *target)
 	LOG_DEBUG(&quot; &quot;);
 
 	cortex_m3_clear_halt(target);
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((retval = armv7m-&gt;examine_debug_reason(target)) != ERROR_OK)
 		return retval;
@@ -508,13 +517,17 @@ static int cortex_m3_poll(struct target *target)
 		target-&gt;debug_reason = DBG_REASON_DBGRQ;
 
 		/* refresh status bits */
-		mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	if (cortex_m3-&gt;dcb_dhcsr &amp; S_RESET_ST)
 	{
 		/* check if still in reset */
-		mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+		if (retval != ERROR_OK)
+			return retval;
 
 		if (cortex_m3-&gt;dcb_dhcsr &amp; S_RESET_ST)
 		{
@@ -642,8 +655,10 @@ static int cortex_m3_soft_reset_halt(struct target *target)
 		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;dcb_dhcsr);
 		if (retval == ERROR_OK)
 		{
-			mem_ap_read_atomic_u32(swjdp, NVIC_DFSR,
+			retval = mem_ap_read_atomic_u32(swjdp, NVIC_DFSR,
 					&amp;cortex_m3-&gt;nvic_dfsr);
+			if (retval != ERROR_OK)
+				return retval;
 			if ((dcb_dhcsr &amp; S_HALT)
 					&amp;&amp; (cortex_m3-&gt;nvic_dfsr &amp; DFSR_VCATCH))
 			{
@@ -835,7 +850,10 @@ static int cortex_m3_step(struct target *target, int current,
 		cortex_m3_write_debug_halt_mask(target, C_STEP, C_HALT);
 	}
 
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	int retval;
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* registers are now invalid */
 	register_cache_invalidate(cortex_m3-&gt;armv7m.core_cache);
@@ -847,7 +865,6 @@ static int cortex_m3_step(struct target *target, int current,
 			&quot; nvic_icsr = 0x%&quot; PRIx32,
 			cortex_m3-&gt;dcb_dhcsr, cortex_m3-&gt;nvic_icsr);
 
-	int retval;
 	retval = cortex_m3_debug_entry(target);
 	if (retval != ERROR_OK)
 		return retval;
@@ -880,7 +897,10 @@ static int cortex_m3_assert_reset(struct target *target)
 		assert_srst = 0;
 
 	/* Enable debug requests */
-	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	int retval;
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &amp;cortex_m3-&gt;dcb_dhcsr);
+	if (retval != ERROR_OK)
+		return retval;
 	if (!(cortex_m3-&gt;dcb_dhcsr &amp; C_DEBUGEN))
 		mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
 
@@ -982,7 +1002,9 @@ static int cortex_m3_assert_reset(struct target *target)
 			 * after reset) on LM3S6918 -- Michael Schwingen
 			 */
 			uint32_t tmp;
-			mem_ap_read_atomic_u32(swjdp, NVIC_AIRCR, &amp;tmp);
+			retval = mem_ap_read_atomic_u32(swjdp, NVIC_AIRCR, &amp;tmp);
+			if (retval != ERROR_OK)
+				return retval;
 		}
 	}
 
@@ -993,7 +1015,6 @@ static int cortex_m3_assert_reset(struct target *target)
 
 	if (target-&gt;reset_halt)
 	{
-		int retval;
 		if ((retval = target_halt(target)) != ERROR_OK)
 			return retval;
 	}
@@ -1982,7 +2003,9 @@ COMMAND_HANDLER(handle_cortex_m3_vector_catch_command)
 	if (retval != ERROR_OK)
 		return retval;
 
-	mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;demcr);
+	retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;demcr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (CMD_ARGC &gt; 0) {
 		unsigned catch = 0;
@@ -2019,7 +2042,9 @@ write:
 
 		/* write, but don't assume it stuck (why not??) */
 		mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
-		mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;demcr);
+		retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;demcr);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* FIXME be sure to clear DEMCR on clean server shutdown.
 		 * Otherwise the vector catch hardware could fire when there's

commit 7dcde11b459f60d40db9ca53f038cd200c852064
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 13:50:28 2010 +0200

    mem_ap_read_u32 error propagation
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 9a33d82..496360f 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1088,11 +1088,21 @@ static int dap_info_command(struct command_context *cmd_ctx,
 			command_print(cmd_ctx, &quot;\tROM table in legacy format&quot;);
 
 		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF0, &amp;cid0);
-		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF4, &amp;cid1);
-		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF8, &amp;cid2);
-		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFFC, &amp;cid3);
-		mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFCC, &amp;memtype);
+		retval = mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF0, &amp;cid0);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF4, &amp;cid1);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFF8, &amp;cid2);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFFC, &amp;cid3);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = mem_ap_read_u32(dap, (dbgbase&amp;0xFFFFF000) | 0xFCC, &amp;memtype);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			return retval;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index d6090f5..6939890 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -68,7 +68,9 @@ static int cortexm3_dap_read_coreregister_u32(struct adiv5_dap *swjdp,
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we have to save/restore the DCB_DCRDR when used */
 
-	mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
+	retval = mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, regnum); */
 	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
@@ -107,7 +109,9 @@ static int cortexm3_dap_write_coreregister_u32(struct adiv5_dap *swjdp,
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we have to save/restore the DCB_DCRDR when used */
 
-	mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
+	retval = mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRDR, core_regs[i]); */
 	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
@@ -297,33 +301,51 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 	struct adiv5_dap *swjdp = &amp;armv7m-&gt;dap;
 	int retval;
 
-	mem_ap_read_u32(swjdp, NVIC_SHCSR, &amp;shcsr);
+	retval = mem_ap_read_u32(swjdp, NVIC_SHCSR, &amp;shcsr);
+	if (retval != ERROR_OK)
+		return retval;
 	switch (armv7m-&gt;exception_number)
 	{
 		case 2:	/* NMI */
 			break;
 		case 3:	/* Hard Fault */
-			mem_ap_read_atomic_u32(swjdp, NVIC_HFSR, &amp;except_sr);
+			retval = mem_ap_read_atomic_u32(swjdp, NVIC_HFSR, &amp;except_sr);
+			if (retval != ERROR_OK)
+				return retval;
 			if (except_sr &amp; 0x40000000)
 			{
-				mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;cfsr);
+				retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;cfsr);
+				if (retval != ERROR_OK)
+					return retval;
 			}
 			break;
 		case 4:	/* Memory Management */
-			mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;except_sr);
-			mem_ap_read_u32(swjdp, NVIC_MMFAR, &amp;except_ar);
+			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;except_sr);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = mem_ap_read_u32(swjdp, NVIC_MMFAR, &amp;except_ar);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 5:	/* Bus Fault */
-			mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;except_sr);
-			mem_ap_read_u32(swjdp, NVIC_BFAR, &amp;except_ar);
+			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;except_sr);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = mem_ap_read_u32(swjdp, NVIC_BFAR, &amp;except_ar);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 6:	/* Usage Fault */
-			mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;except_sr);
+			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &amp;except_sr);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 11:	/* SVCall */
 			break;
 		case 12:	/* Debug Monitor */
-			mem_ap_read_u32(swjdp, NVIC_DFSR, &amp;except_sr);
+			retval = mem_ap_read_u32(swjdp, NVIC_DFSR, &amp;except_sr);
+			if (retval != ERROR_OK)
+				return retval;
 			break;
 		case 14:	/* PendSV */
 			break;

commit e7a1ec64bface364305e9c355811838e9f310bf3
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 13:45:53 2010 +0200

    arm_adi_v5: add error propagation for dap_setup_accessport
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index dfb45b4..9a33d82 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -5,7 +5,7 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
  *                                                                         *
- *   Copyright (C) 2009 by Oyvind Harboe                                   *
+ *   Copyright (C) 2009-2010 by Oyvind Harboe                              *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
  *                                                                         *
  *   Copyright (C) 2009-2010 by David Brownell                             *
@@ -309,7 +309,9 @@ int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 
 		for (writecount = 0; writecount &lt; blocksize; writecount++)
 		{
@@ -363,7 +365,9 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 		writecount = blocksize;
 
 		do
@@ -430,7 +434,9 @@ int mem_ap_write_buf_u16(struct adiv5_dap *dap, uint8_t *buffer, int count, uint
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		uint16_t svalue;
 		memcpy(&amp;svalue, buffer, sizeof(uint16_t));
 		uint32_t outvalue = (uint32_t)svalue &lt;&lt; 8 * (address &amp; 0x3);
@@ -468,7 +474,9 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 		writecount = blocksize;
 
 		do
@@ -534,7 +542,9 @@ int mem_ap_write_buf_u8(struct adiv5_dap *dap, uint8_t *buffer, int count, uint3
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		uint32_t outvalue = (uint32_t)*buffer &lt;&lt; 8 * (address &amp; 0x3);
 		retval = dap_queue_ap_write(dap, AP_REG_DRW, outvalue);
 		if (retval != ERROR_OK)
@@ -592,8 +602,10 @@ int mem_ap_read_buf_u32(struct adiv5_dap *dap, uint8_t *buffer,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE,
+		retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE,
 				address);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* FIXME remove these three calls to adi_jtag_dp_scan(),
 		 * so this routine becomes transport-neutral.  Be careful
@@ -686,7 +698,9 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *dap,
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
@@ -739,7 +753,9 @@ int mem_ap_read_buf_u16(struct adiv5_dap *dap, uint8_t *buffer,
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
 		if (retval != ERROR_OK)
 			break;
@@ -795,7 +811,9 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *dap,
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		if (retval != ERROR_OK)
+			return retval;
 		readcount = blocksize;
 
 		do
@@ -844,8 +862,12 @@ int mem_ap_read_buf_u8(struct adiv5_dap *dap, uint8_t *buffer,
 
 	while (count &gt; 0)
 	{
-		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_queue_ap_read(dap, AP_REG_DRW, &amp;invalue);
+		if (retval != ERROR_OK)
+			return retval;
 		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 4f3560f..d6090f5 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -71,13 +71,17 @@ static int cortexm3_dap_read_coreregister_u32(struct adiv5_dap *swjdp,
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, regnum); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRSR &amp; 0xC), regnum);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* mem_ap_read_u32(swjdp, DCB_DCRDR, value); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_read(swjdp, AP_REG_BD0 | (DCB_DCRDR &amp; 0xC), value);
 	if (retval != ERROR_OK)
 		return retval;
@@ -106,12 +110,16 @@ static int cortexm3_dap_write_coreregister_u32(struct adiv5_dap *swjdp,
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRDR, core_regs[i]); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRDR &amp; 0xC), value);
 	// XXX check retval
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, i | DCRSR_WnR); */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
 	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRSR &amp; 0xC), regnum | DCRSR_WnR);
 	// XXX check retval
 

commit 44ef0327dd97c1893afc63cd7fd8025cb1b57827
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 12:34:54 2010 +0200

    debug: debug entry error propagation
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 36bbaba..67f0524 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -439,7 +439,7 @@ static int arm11_halt(struct target *target)
 
 	enum target_state old_state	= target-&gt;state;
 
-	arm11_debug_entry(arm11);
+	CHECK_RETVAL(arm11_debug_entry(arm11));
 
 	CHECK_RETVAL(
 		target_call_event_callbacks(target,
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 6bf38bb..96e0baa 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -202,13 +202,18 @@ static int arm720t_enable_mmu_caches(struct target *target,
 	return retval;
 }
 
-static void arm720t_post_debug_entry(struct target *target)
+static int arm720t_post_debug_entry(struct target *target)
 {
 	struct arm720t_common *arm720t = target_to_arm720(target);
+	int retval;
 
 	/* examine cp15 control reg */
-	arm720t_read_cp15(target, 0xee110f10, &amp;arm720t-&gt;cp15_control_reg);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee110f10, &amp;arm720t-&gt;cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(&quot;cp15_control_reg: %8.8&quot; PRIx32 &quot;&quot;, arm720t-&gt;cp15_control_reg);
 
 	arm720t-&gt;armv4_5_mmu.mmu_enabled = (arm720t-&gt;cp15_control_reg &amp; 0x1U) ? 1 : 0;
@@ -216,9 +221,14 @@ static void arm720t_post_debug_entry(struct target *target)
 	arm720t-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
 
 	/* save i/d fault status and address register */
-	arm720t_read_cp15(target, 0xee150f10, &amp;arm720t-&gt;fsr_reg);
-	arm720t_read_cp15(target, 0xee160f10, &amp;arm720t-&gt;far_reg);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee150f10, &amp;arm720t-&gt;fsr_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm720t_read_cp15(target, 0xee160f10, &amp;arm720t-&gt;far_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	return retval;
 }
 
 static void arm720t_pre_restore_context(struct target *target)
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index abe0c2f..b742dae 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1470,7 +1470,11 @@ static int arm7_9_debug_entry(struct target *target)
 		return retval;
 
 	if (arm7_9-&gt;post_debug_entry)
-		arm7_9-&gt;post_debug_entry(target);
+	{
+		retval = arm7_9-&gt;post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return ERROR_OK;
 }
@@ -1878,7 +1882,9 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 				return err;
 			}
 
-			arm7_9_debug_entry(target);
+			retval = arm7_9_debug_entry(target);
+			if (retval != ERROR_OK)
+				return retval;
 			LOG_DEBUG(&quot;new PC after step: 0x%8.8&quot; PRIx32,
 					buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32));
 
@@ -2079,7 +2085,9 @@ int arm7_9_step(struct target *target, int current, uint32_t address, int handle
 	{
 		target-&gt;state = TARGET_UNKNOWN;
 	} else {
-		arm7_9_debug_entry(target);
+		retval = arm7_9_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
 		if ((retval = target_call_event_callbacks(target, TARGET_EVENT_HALTED)) != ERROR_OK)
 		{
 			return retval;
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index a741c59..69ea221 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -100,7 +100,7 @@ struct arm7_9_common
 
 	void (*set_special_dbgrq)(struct target *target); /**&lt; Function for setting DBGRQ if the normal way won't work */
 
-	void (*post_debug_entry)(struct target *target); /**&lt; Callback function called after entering debug mode */
+	int (*post_debug_entry)(struct target *target); /**&lt; Callback function called after entering debug mode */
 
 	void (*pre_restore_context)(struct target *target); /**&lt; Callback function called before restoring the processor context */
 };
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index a80a378..7627b25 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -389,24 +389,33 @@ int arm920t_enable_mmu_caches(struct target *target, int mmu,
 }
 
 // EXPORTED to FA256
-void arm920t_post_debug_entry(struct target *target)
+int arm920t_post_debug_entry(struct target *target)
 {
 	uint32_t cp15c15;
 	struct arm920t_common *arm920t = target_to_arm920(target);
+	int retval;
 
 	/* examine cp15 control reg */
-	arm920t_read_cp15_physical(target,
+	retval = arm920t_read_cp15_physical(target,
 			CP15PHYS_CTRL, &amp;arm920t-&gt;cp15_control_reg);
-	jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(&quot;cp15_control_reg: %8.8&quot; PRIx32, arm920t-&gt;cp15_control_reg);
 
 	if (arm920t-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
 		uint32_t cache_type_reg;
 		/* identify caches */
-		arm920t_read_cp15_physical(target,
+		retval = arm920t_read_cp15_physical(target,
 				CP15PHYS_CACHETYPE, &amp;cache_type_reg);
-		jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
 		armv4_5_identify_cache(cache_type_reg,
 				&amp;arm920t-&gt;armv4_5_mmu.armv4_5_cache);
 	}
@@ -420,10 +429,18 @@ void arm920t_post_debug_entry(struct target *target)
 
 	/* save i/d fault status and address register */
 			/* FIXME use opcode macros */
-	arm920t_read_cp15_interpreted(target, 0xee150f10, 0x0, &amp;arm920t-&gt;d_fsr);
-	arm920t_read_cp15_interpreted(target, 0xee150f30, 0x0, &amp;arm920t-&gt;i_fsr);
-	arm920t_read_cp15_interpreted(target, 0xee160f10, 0x0, &amp;arm920t-&gt;d_far);
-	arm920t_read_cp15_interpreted(target, 0xee160f30, 0x0, &amp;arm920t-&gt;i_far);
+	retval = arm920t_read_cp15_interpreted(target, 0xee150f10, 0x0, &amp;arm920t-&gt;d_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm920t_read_cp15_interpreted(target, 0xee150f30, 0x0, &amp;arm920t-&gt;i_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm920t_read_cp15_interpreted(target, 0xee160f10, 0x0, &amp;arm920t-&gt;d_far);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm920t_read_cp15_interpreted(target, 0xee160f30, 0x0, &amp;arm920t-&gt;i_far);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG(&quot;D FSR: 0x%8.8&quot; PRIx32 &quot;, D FAR: 0x%8.8&quot; PRIx32
 		&quot;, I FSR: 0x%8.8&quot; PRIx32 &quot;, I FAR: 0x%8.8&quot; PRIx32,
@@ -433,13 +450,20 @@ void arm920t_post_debug_entry(struct target *target)
 	{
 		/* read-modify-write CP15 test state register
 		 * to disable I/D-cache linefills */
-		arm920t_read_cp15_physical(target,
+		retval = arm920t_read_cp15_physical(target,
 				CP15PHYS_TESTSTATE, &amp;cp15c15);
-		jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
 		cp15c15 |= 0x600;
-		arm920t_write_cp15_physical(target,
+		retval = arm920t_write_cp15_physical(target,
 				CP15PHYS_TESTSTATE, cp15c15);
+		if (retval != ERROR_OK)
+			return retval;
 	}
+	return ERROR_OK;
 }
 
 // EXPORTED to FA256
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 20f614d..02d7f83 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -64,7 +64,7 @@ int arm920t_read_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int arm920t_write_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-void arm920t_post_debug_entry(struct target *target);
+int arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
 int arm920t_get_ttb(struct target *target, uint32_t *result);
 int arm920t_disable_mmu_caches(struct target *target,
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index f8a4f62..aa38d27 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -432,21 +432,30 @@ static int arm926ejs_enable_mmu_caches(struct target *target, int mmu,
 	return retval;
 }
 
-static void arm926ejs_post_debug_entry(struct target *target)
+static int arm926ejs_post_debug_entry(struct target *target)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
+	int retval;
 
 	/* examine cp15 control reg */
-	arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;arm926ejs-&gt;cp15_control_reg);
-	jtag_execute_queue();
+	retval = arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;arm926ejs-&gt;cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(&quot;cp15_control_reg: %8.8&quot; PRIx32 &quot;&quot;, arm926ejs-&gt;cp15_control_reg);
 
 	if (arm926ejs-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
 		uint32_t cache_type_reg;
 		/* identify caches */
-		arm926ejs-&gt;read_cp15(target, 0, 1, 0, 0, &amp;cache_type_reg);
-		jtag_execute_queue();
+		retval = arm926ejs-&gt;read_cp15(target, 0, 1, 0, 0, &amp;cache_type_reg);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = jtag_execute_queue();
+		if (retval != ERROR_OK)
+			return retval;
 		armv4_5_identify_cache(cache_type_reg, &amp;arm926ejs-&gt;armv4_5_mmu.armv4_5_cache);
 	}
 
@@ -455,9 +464,15 @@ static void arm926ejs_post_debug_entry(struct target *target)
 	arm926ejs-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled = (arm926ejs-&gt;cp15_control_reg &amp; 0x1000U) ? 1 : 0;
 
 	/* save i/d fault status and address register */
-	arm926ejs-&gt;read_cp15(target, 0, 0, 5, 0, &amp;arm926ejs-&gt;d_fsr);
-	arm926ejs-&gt;read_cp15(target, 0, 1, 5, 0, &amp;arm926ejs-&gt;i_fsr);
-	arm926ejs-&gt;read_cp15(target, 0, 0, 6, 0, &amp;arm926ejs-&gt;d_far);
+	retval = arm926ejs-&gt;read_cp15(target, 0, 0, 5, 0, &amp;arm926ejs-&gt;d_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm926ejs-&gt;read_cp15(target, 0, 1, 5, 0, &amp;arm926ejs-&gt;i_fsr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = arm926ejs-&gt;read_cp15(target, 0, 0, 6, 0, &amp;arm926ejs-&gt;d_far);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG(&quot;D FSR: 0x%8.8&quot; PRIx32 &quot;, D FAR: 0x%8.8&quot; PRIx32 &quot;, I FSR: 0x%8.8&quot; PRIx32 &quot;&quot;,
 		arm926ejs-&gt;d_fsr, arm926ejs-&gt;d_far, arm926ejs-&gt;i_fsr);
@@ -466,9 +481,12 @@ static void arm926ejs_post_debug_entry(struct target *target)
 
 	/* read-modify-write CP15 cache debug control register
 	 * to disable I/D-cache linefills and force WT */
-	arm926ejs-&gt;read_cp15(target, 7, 0, 15, 0, &amp;cache_dbg_ctrl);
+	retval = arm926ejs-&gt;read_cp15(target, 7, 0, 15, 0, &amp;cache_dbg_ctrl);
+	if (retval != ERROR_OK)
+		return retval;
 	cache_dbg_ctrl |= 0x7;
-	arm926ejs-&gt;write_cp15(target, 7, 0, 15, 0, cache_dbg_ctrl);
+	retval = arm926ejs-&gt;write_cp15(target, 7, 0, 15, 0, cache_dbg_ctrl);
+	return retval;
 }
 
 static void arm926ejs_pre_restore_context(struct target *target)
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 621761d..f932456 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -62,7 +62,7 @@ struct armv7a_common
 	struct armv4_5_mmu_common armv4_5_mmu;
 
 	int (*examine_debug_reason)(struct target *target);
-	void (*post_debug_entry)(struct target *target);
+	int (*post_debug_entry)(struct target *target);
 
 	void (*pre_restore_context)(struct target *target);
 };
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 57d46ed..8ef3800 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -121,7 +121,7 @@ struct armv7m_common
 	int (*write_core_reg)(struct target *target, unsigned num);
 
 	int (*examine_debug_reason)(struct target *target);
-	void (*post_debug_entry)(struct target *target);
+	int (*post_debug_entry)(struct target *target);
 
 	void (*pre_restore_context)(struct target *target);
 };
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 76c3d37..9b3521a 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1056,12 +1056,16 @@ static int cortex_a8_debug_entry(struct target *target)
 	/* Are we in an exception handler */
 //	armv4_5-&gt;exception_number = 0;
 	if (armv7a-&gt;post_debug_entry)
-		armv7a-&gt;post_debug_entry(target);
+	{
+		retval = armv7a-&gt;post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return retval;
 }
 
-static void cortex_a8_post_debug_entry(struct target *target)
+static int cortex_a8_post_debug_entry(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &amp;cortex_a8-&gt;armv7a_common;
@@ -1072,6 +1076,8 @@ static void cortex_a8_post_debug_entry(struct target *target)
 			0, 0,	/* op1, op2 */
 			1, 0,	/* CRn, CRm */
 			&amp;cortex_a8-&gt;cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
 	LOG_DEBUG(&quot;cp15_control_reg: %8.8&quot; PRIx32, cortex_a8-&gt;cp15_control_reg);
 
 	if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
@@ -1083,6 +1089,8 @@ static void cortex_a8_post_debug_entry(struct target *target)
 				0, 1,	/* op1, op2 */
 				0, 0,	/* CRn, CRm */
 				&amp;cache_type_reg);
+		if (retval != ERROR_OK)
+			return retval;
 		LOG_DEBUG(&quot;cp15 cache type: %8.8x&quot;, (unsigned) cache_type_reg);
 
 		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A8 */
@@ -1097,7 +1105,7 @@ static void cortex_a8_post_debug_entry(struct target *target)
 	armv7a-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled =
 			(cortex_a8-&gt;cp15_control_reg &amp; 0x1000U) ? 1 : 0;
 
-
+	return ERROR_OK;
 }
 
 static int cortex_a8_step(struct target *target, int current, uint32_t address,
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 7f6cbaf..4f3560f 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -442,7 +442,11 @@ static int cortex_m3_debug_entry(struct target *target)
 		target_state_name(target));
 
 	if (armv7m-&gt;post_debug_entry)
-		armv7m-&gt;post_debug_entry(target);
+	{
+		retval = armv7m-&gt;post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return ERROR_OK;
 }
@@ -813,7 +817,10 @@ static int cortex_m3_step(struct target *target, int current,
 			&quot; nvic_icsr = 0x%&quot; PRIx32,
 			cortex_m3-&gt;dcb_dhcsr, cortex_m3-&gt;nvic_icsr);
 
-	cortex_m3_debug_entry(target);
+	int retval;
+	retval = cortex_m3_debug_entry(target);
+	if (retval != ERROR_OK)
+		return retval;
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 
 	LOG_DEBUG(&quot;target stepped dcb_dhcsr = 0x%&quot; PRIx32

commit 6c573df11d1c1bc76c897d0688adfd00ec56ca8e
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 12:17:11 2010 +0200

    cortex a8: added timeout handling
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 9a90180..76c3d37 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -136,6 +136,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 	LOG_DEBUG(&quot;exec opcode 0x%08&quot; PRIx32, opcode);
 
 	/* Wait for InstrCompl bit to be set */
+	long long then = timeval_ms();
 	while ((dscr &amp; DSCR_INSTR_COMP) == 0)
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
@@ -145,12 +146,18 @@ static int cortex_a8_exec_opcode(struct target *target,
 			LOG_ERROR(&quot;Could not read DSCR register, opcode = 0x%08&quot; PRIx32, opcode);
 			return retval;
 		}
+		if (timeval_ms() &gt; then + 1000)
+		{
+			LOG_ERROR(&quot;Timeout waiting for cortex_a8_exec_opcode&quot;);
+			return ERROR_FAIL;
+		}
 	}
 
 	retval = mem_ap_write_u32(swjdp, armv7a-&gt;debug_base + CPUDBG_ITR, opcode);
 	if (retval != ERROR_OK)
 		return retval;
 
+	then = timeval_ms();
 	do
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
@@ -160,6 +167,11 @@ static int cortex_a8_exec_opcode(struct target *target,
 			LOG_ERROR(&quot;Could not read DSCR register&quot;);
 			return retval;
 		}
+		if (timeval_ms() &gt; then + 1000)
+		{
+			LOG_ERROR(&quot;Timeout waiting for cortex_a8_exec_opcode&quot;);
+			return ERROR_FAIL;
+		}
 	}
 	while ((dscr &amp; DSCR_INSTR_COMP) == 0); /* Wait for InstrCompl bit to be set */
 
@@ -248,12 +260,18 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	}
 
 	/* Wait for DTRRXfull then read DTRRTX */
+	long long then = timeval_ms();
 	while ((dscr &amp; DSCR_DTR_TX_FULL) == 0)
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
 		if (retval != ERROR_OK)
 			return retval;
+		if (timeval_ms() &gt; then + 1000)
+		{
+			LOG_ERROR(&quot;Timeout waiting for cortex_a8_exec_opcode&quot;);
+			return ERROR_FAIL;
+		}
 	}
 
 	retval = mem_ap_read_atomic_u32(swjdp,
@@ -394,12 +412,18 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		dscr = *dscr_p;
 
 	/* Wait for DTRRXfull */
+	long long then = timeval_ms();
 	while ((dscr &amp; DSCR_DTR_TX_FULL) == 0) {
 		retval = mem_ap_read_atomic_u32(swjdp,
 				a8-&gt;armv7a_common.debug_base + CPUDBG_DSCR,
 				&amp;dscr);
 		if (retval != ERROR_OK)
 			return retval;
+		if (timeval_ms() &gt; then + 1000)
+		{
+			LOG_ERROR(&quot;Timeout waiting for read dcc&quot;);
+			return ERROR_FAIL;
+		}
 	}
 
 	retval = mem_ap_read_atomic_u32(swjdp,
@@ -1086,8 +1110,6 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	struct reg *r;
 	int retval;
 
-	int timeout = 100;
-
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_WARNING(&quot;target not halted&quot;);
@@ -1132,12 +1154,13 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	if (retval != ERROR_OK)
 		return retval;
 
+	long long then = timeval_ms();
 	while (target-&gt;state != TARGET_HALTED)
 	{
 		retval = cortex_a8_poll(target);
 		if (retval != ERROR_OK)
 			return retval;
-		if (--timeout == 0)
+		if (timeval_ms() &gt; then + 1000)
 		{
 			LOG_ERROR(&quot;timeout waiting for target halt&quot;);
 			return ERROR_FAIL;
@@ -1145,8 +1168,8 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	}
 
 	cortex_a8_unset_breakpoint(target, &amp;stepbreakpoint);
-	if (timeout &gt; 0)
-		target-&gt;debug_reason = DBG_REASON_BREAKPOINT;
+
+	target-&gt;debug_reason = DBG_REASON_BREAKPOINT;
 
 	if (breakpoint)
 		cortex_a8_set_breakpoint(target, breakpoint, 0);

commit 6a237c23c1adb0be91a82a44d2cf13ff158b3ee2
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 10:58:07 2010 +0200

    arm: add error propagation for enable/disable mmu caches
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index b269f94..6bf38bb 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -154,14 +154,19 @@ static int arm720t_get_ttb(struct target *target, uint32_t *result)
 	return ERROR_OK;
 }
 
-static void arm720t_disable_mmu_caches(struct target *target,
+static int arm720t_disable_mmu_caches(struct target *target,
 		int mmu, int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control &amp;= ~0x1U;
@@ -169,17 +174,23 @@ static void arm720t_disable_mmu_caches(struct target *target,
 	if (d_u_cache || i_cache)
 		cp15_control &amp;= ~0x4U;
 
-	arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	retval = arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	return retval;
 }
 
-static void arm720t_enable_mmu_caches(struct target *target,
+static int arm720t_enable_mmu_caches(struct target *target,
 		int mmu, int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
-	jtag_execute_queue();
+	retval = arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control |= 0x1U;
@@ -187,7 +198,8 @@ static void arm720t_enable_mmu_caches(struct target *target,
 	if (d_u_cache || i_cache)
 		cp15_control |= 0x4U;
 
-	arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	retval = arm720t_write_cp15(target, 0xee010f10, cp15_control);
+	return retval;
 }
 
 static void arm720t_post_debug_entry(struct target *target)
@@ -282,12 +294,19 @@ static int arm720t_read_memory(struct target *target,
 
 	/* disable cache, but leave MMU enabled */
 	if (arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-		arm720t_disable_mmu_caches(target, 0, 1, 0);
-
+	{
+		retval = arm720t_disable_mmu_caches(target, 0, 1, 0);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 	retval = arm7_9_read_memory(target, address, size, count, buffer);
 
 	if (arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
-		arm720t_enable_mmu_caches(target, 0, 1, 0);
+	{
+		retval = arm720t_enable_mmu_caches(target, 0, 1, 0);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	return retval;
 }
@@ -367,7 +386,9 @@ static int arm720t_soft_reset_halt(struct target *target)
 	armv4_5-&gt;pc-&gt;dirty = 1;
 	armv4_5-&gt;pc-&gt;valid = 1;
 
-	arm720t_disable_mmu_caches(target, 1, 1, 1);
+	retval = arm720t_disable_mmu_caches(target, 1, 1, 1);
+	if (retval != ERROR_OK)
+		return retval;
 	arm720t-&gt;armv4_5_mmu.mmu_enabled = 0;
 	arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
 	arm720t-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 9c11d12..a80a378 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -333,14 +333,19 @@ int arm920t_get_ttb(struct target *target, uint32_t *result)
 }
 
 // EXPORTED to FA256
-void arm920t_disable_mmu_caches(struct target *target, int mmu,
+int arm920t_disable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &amp;cp15_control);
-	jtag_execute_queue();
+	retval = arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &amp;cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control &amp;= ~0x1U;
@@ -351,18 +356,24 @@ void arm920t_disable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 		cp15_control &amp;= ~0x1000U;
 
-	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	retval = arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	return retval;
 }
 
 // EXPORTED to FA256
-void arm920t_enable_mmu_caches(struct target *target, int mmu,
+int arm920t_enable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &amp;cp15_control);
-	jtag_execute_queue();
+	retval = arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &amp;cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control |= 0x1U;
@@ -373,7 +384,8 @@ void arm920t_enable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 		cp15_control |= 0x1000U;
 
-	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	retval = arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
+	return retval;
 }
 
 // EXPORTED to FA256
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index 9d5afab..20f614d 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -67,9 +67,9 @@ int arm920t_write_memory(struct target *target,
 void arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
 int arm920t_get_ttb(struct target *target, uint32_t *result);
-void arm920t_disable_mmu_caches(struct target *target,
+int arm920t_disable_mmu_caches(struct target *target,
 	int mmu, int d_u_cache, int i_cache);
-void arm920t_enable_mmu_caches(struct target *target,
+int arm920t_enable_mmu_caches(struct target *target,
 	int mmu, int d_u_cache, int i_cache);
 
 extern const struct command_registration arm920t_command_handlers[];
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 0cf7173..f8a4f62 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -337,20 +337,27 @@ static int arm926ejs_get_ttb(struct target *target, uint32_t *result)
 	return ERROR_OK;
 }
 
-static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
+static int arm926ejs_disable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;cp15_control);
-	jtag_execute_queue();
+	retval = arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 	{
 		/* invalidate TLB */
-		arm926ejs-&gt;write_cp15(target, 0, 0, 8, 7, 0x0);
+		retval = arm926ejs-&gt;write_cp15(target, 0, 0, 8, 7, 0x0);
+		if (retval != ERROR_OK)
+			return retval;
 
 		cp15_control &amp;= ~0x1U;
 	}
@@ -360,17 +367,25 @@ static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
 		uint32_t debug_override;
 		/* read-modify-write CP15 debug override register
 		 * to enable &quot;test and clean all&quot; */
-		arm926ejs-&gt;read_cp15(target, 0, 0, 15, 0, &amp;debug_override);
+		retval = arm926ejs-&gt;read_cp15(target, 0, 0, 15, 0, &amp;debug_override);
+		if (retval != ERROR_OK)
+			return retval;
 		debug_override |= 0x80000;
-		arm926ejs-&gt;write_cp15(target, 0, 0, 15, 0, debug_override);
+		retval = arm926ejs-&gt;write_cp15(target, 0, 0, 15, 0, debug_override);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* clean and invalidate DCache */
-		arm926ejs-&gt;write_cp15(target, 0, 0, 7, 5, 0x0);
+		retval = arm926ejs-&gt;write_cp15(target, 0, 0, 7, 5, 0x0);
+		if (retval != ERROR_OK)
+			return retval;
 
 		/* write CP15 debug override register
 		 * to disable &quot;test and clean all&quot; */
 		debug_override &amp;= ~0x80000;
-		arm926ejs-&gt;write_cp15(target, 0, 0, 15, 0, debug_override);
+		retval = arm926ejs-&gt;write_cp15(target, 0, 0, 15, 0, debug_override);
+		if (retval != ERROR_OK)
+			return retval;
 
 		cp15_control &amp;= ~0x4U;
 	}
@@ -378,23 +393,31 @@ static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 	{
 		/* invalidate ICache */
-		arm926ejs-&gt;write_cp15(target, 0, 0, 7, 5, 0x0);
+		retval = arm926ejs-&gt;write_cp15(target, 0, 0, 7, 5, 0x0);
+		if (retval != ERROR_OK)
+			return retval;
 
 		cp15_control &amp;= ~0x1000U;
 	}
 
-	arm926ejs-&gt;write_cp15(target, 0, 0, 1, 0, cp15_control);
+	retval = arm926ejs-&gt;write_cp15(target, 0, 0, 1, 0, cp15_control);
+	return retval;
 }
 
-static void arm926ejs_enable_mmu_caches(struct target *target, int mmu,
+static int arm926ejs_enable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;cp15_control);
-	jtag_execute_queue();
+	retval = arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;cp15_control);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (mmu)
 		cp15_control |= 0x1U;
@@ -405,7 +428,8 @@ static void arm926ejs_enable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 		cp15_control |= 0x1000U;
 
-	arm926ejs-&gt;write_cp15(target, 0, 0, 1, 0, cp15_control);
+	retval = arm926ejs-&gt;write_cp15(target, 0, 0, 1, 0, cp15_control);
+	return retval;
 }
 
 static void arm926ejs_post_debug_entry(struct target *target)
@@ -564,7 +588,9 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	armv4_5-&gt;pc-&gt;dirty = 1;
 	armv4_5-&gt;pc-&gt;valid = 1;
 
-	arm926ejs_disable_mmu_caches(target, 1, 1, 1);
+	retval = arm926ejs_disable_mmu_caches(target, 1, 1, 1);
+	if (retval != ERROR_OK)
+		return retval;
 	arm926ejs-&gt;armv4_5_mmu.mmu_enabled = 0;
 	arm926ejs-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
 	arm926ejs-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 3d450ae..8978f35 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -131,14 +131,20 @@ int armv4_5_mmu_read_physical(struct target *target, struct armv4_5_mmu_common *
 		return ERROR_TARGET_NOT_HALTED;
 
 	/* disable MMU and data (or unified) cache */
-	armv4_5_mmu-&gt;disable_mmu_caches(target, 1, 1, 0);
+	retval = armv4_5_mmu-&gt;disable_mmu_caches(target, 1, 1, 0);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	retval = armv4_5_mmu-&gt;read_memory(target, address, size, count, buffer);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* reenable MMU / cache */
-	armv4_5_mmu-&gt;enable_mmu_caches(target, armv4_5_mmu-&gt;mmu_enabled,
+	retval = armv4_5_mmu-&gt;enable_mmu_caches(target, armv4_5_mmu-&gt;mmu_enabled,
 		armv4_5_mmu-&gt;armv4_5_cache.d_u_cache_enabled,
 		armv4_5_mmu-&gt;armv4_5_cache.i_cache_enabled);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	return retval;
 }
@@ -151,14 +157,20 @@ int armv4_5_mmu_write_physical(struct target *target, struct armv4_5_mmu_common
 		return ERROR_TARGET_NOT_HALTED;
 
 	/* disable MMU and data (or unified) cache */
-	armv4_5_mmu-&gt;disable_mmu_caches(target, 1, 1, 0);
+	retval = armv4_5_mmu-&gt;disable_mmu_caches(target, 1, 1, 0);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	retval = armv4_5_mmu-&gt;write_memory(target, address, size, count, buffer);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* reenable MMU / cache */
-	armv4_5_mmu-&gt;enable_mmu_caches(target, armv4_5_mmu-&gt;mmu_enabled,
+	retval = armv4_5_mmu-&gt;enable_mmu_caches(target, armv4_5_mmu-&gt;mmu_enabled,
 		armv4_5_mmu-&gt;armv4_5_cache.d_u_cache_enabled,
 		armv4_5_mmu-&gt;armv4_5_cache.i_cache_enabled);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	return retval;
 }
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index d2716fb..f39834e 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -29,8 +29,8 @@ struct armv4_5_mmu_common
 	int (*get_ttb)(struct target *target, uint32_t *result);
 	int (*read_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-	void (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
-	void (*enable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
+	int (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
+	int (*enable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
 	struct armv4_5_cache_common armv4_5_cache;
 	int has_tiny_pages;
 	int mmu_enabled;
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index e1acbf7..9a90180 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -58,9 +58,9 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 static int cortex_a8_mmu(struct target *target, int *enabled);
 static int cortex_a8_virt2phys(struct target *target,
                 uint32_t virt, uint32_t *phys);
-static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
-static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_enable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
 static int cortex_a8_get_ttb(struct target *target, uint32_t *result);
 
@@ -1916,19 +1916,21 @@ static int cortex_a8_get_ttb(struct target *target, uint32_t *result)
     return ERROR_OK;
 }
 
-/* FIX! error propagation missing from this fn */
-static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache)
 {
     struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
     struct armv7a_common *armv7a = &amp;cortex_a8-&gt;armv7a_common;
     uint32_t cp15_control;
+    int retval;
 
     /* read cp15 control register */
-    armv7a-&gt;armv4_5_common.mrc(target, 15,
+    retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     &amp;cp15_control);
+    if (retval != ERROR_OK)
+    	return retval;
 
 
     if (mmu)
@@ -1940,25 +1942,28 @@ static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
     if (i_cache)
             cp15_control &amp;= ~0x1000U;
 
-    armv7a-&gt;armv4_5_common.mcr(target, 15,
+    retval = armv7a-&gt;armv4_5_common.mcr(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     cp15_control);
+	return retval;
 }
 
-/* FIX! error propagation missing from this fn */
-static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
+static int cortex_a8_enable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache)
 {
     struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
     struct armv7a_common *armv7a = &amp;cortex_a8-&gt;armv7a_common;
     uint32_t cp15_control;
+    int retval;
 
     /* read cp15 control register */
-    armv7a-&gt;armv4_5_common.mrc(target, 15,
+    retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     &amp;cp15_control);
+    if (retval != ERROR_OK)
+    	return retval;
 
     if (mmu)
             cp15_control |= 0x1U;
@@ -1969,10 +1974,11 @@ static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
     if (i_cache)
             cp15_control |= 0x1000U;
 
-    armv7a-&gt;armv4_5_common.mcr(target, 15,
+    retval = armv7a-&gt;armv4_5_common.mcr(target, 15,
                     0, 0,   /* op1, op2 */
                     1, 0,   /* CRn, CRm */
                     cp15_control);
+   	return retval;
 }
 
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 35efa85..c0080b2 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2018,14 +2018,17 @@ static int xscale_get_ttb(struct target *target, uint32_t *result)
 	return ERROR_OK;
 }
 
-static void xscale_disable_mmu_caches(struct target *target, int mmu,
+static int xscale_disable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL]);
+	retval = xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL]);
+	if (retval !=ERROR_OK)
+		return retval;
 	cp15_control = buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL].value, 0, 32);
 
 	if (mmu)
@@ -2034,11 +2037,17 @@ static void xscale_disable_mmu_caches(struct target *target, int mmu,
 	if (d_u_cache)
 	{
 		/* clean DCache */
-		xscale_send_u32(target, 0x50);
-		xscale_send_u32(target, xscale-&gt;cache_clean_address);
+		retval = xscale_send_u32(target, 0x50);
+		if (retval !=ERROR_OK)
+			return retval;
+		retval = xscale_send_u32(target, xscale-&gt;cache_clean_address);
+		if (retval !=ERROR_OK)
+			return retval;
 
 		/* invalidate DCache */
-		xscale_send_u32(target, 0x51);
+		retval = xscale_send_u32(target, 0x51);
+		if (retval !=ERROR_OK)
+			return retval;
 
 		cp15_control &amp;= ~0x4U;
 	}
@@ -2046,25 +2055,33 @@ static void xscale_disable_mmu_caches(struct target *target, int mmu,
 	if (i_cache)
 	{
 		/* invalidate ICache */
-		xscale_send_u32(target, 0x52);
+		retval = xscale_send_u32(target, 0x52);
+		if (retval !=ERROR_OK)
+			return retval;
 		cp15_control &amp;= ~0x1000U;
 	}
 
 	/* write new cp15 control register */
-	xscale_set_reg_u32(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL], cp15_control);
+	retval = xscale_set_reg_u32(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL], cp15_control);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* execute cpwait to ensure outstanding operations complete */
-	xscale_send_u32(target, 0x53);
+	retval = xscale_send_u32(target, 0x53);
+	return retval;
 }
 
-static void xscale_enable_mmu_caches(struct target *target, int mmu,
+static int xscale_enable_mmu_caches(struct target *target, int mmu,
 		int d_u_cache, int i_cache)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t cp15_control;
+	int retval;
 
 	/* read cp15 control register */
-	xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL]);
+	retval = xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL]);
+	if (retval !=ERROR_OK)
+		return retval;
 	cp15_control = buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL].value, 0, 32);
 
 	if (mmu)
@@ -2077,10 +2094,13 @@ static void xscale_enable_mmu_caches(struct target *target, int mmu,
 		cp15_control |= 0x1000U;
 
 	/* write new cp15 control register */
-	xscale_set_reg_u32(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL], cp15_control);
+	retval = xscale_set_reg_u32(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL], cp15_control);
+	if (retval !=ERROR_OK)
+		return retval;
 
 	/* execute cpwait to ensure outstanding operations complete */
-	xscale_send_u32(target, 0x53);
+	retval = xscale_send_u32(target, 0x53);
+	return retval;
 }
 
 static int xscale_set_breakpoint(struct target *target,

commit 70fee9207b5fd1c6f499b790591446adc4d4467c
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Mon Jul 19 08:45:45 2010 +0200

    arm: add error propagation to generic get_ttb fn
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 0ea6cb2..b269f94 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -134,16 +134,24 @@ static int arm720t_write_cp15(struct target *target, uint32_t opcode, uint32_t v
 	return ERROR_OK;
 }
 
-static uint32_t arm720t_get_ttb(struct target *target)
+static int arm720t_get_ttb(struct target *target, uint32_t *result)
 {
 	uint32_t ttb = 0x0;
 
-	arm720t_read_cp15(target, 0xee120f10, &amp;ttb);
-	jtag_execute_queue();
+	int retval;
+
+	retval = arm720t_read_cp15(target, 0xee120f10, &amp;ttb);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
 
 	ttb &amp;= 0xffffc000;
 
-	return ttb;
+	*result = ttb;
+
+	return ERROR_OK;
 }
 
 static void arm720t_disable_mmu_caches(struct target *target,
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index fe9bba7..9c11d12 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -318,7 +318,7 @@ int arm920t_write_cp15_interpreted(struct target *target,
 }
 
 // EXPORTED to FA256
-uint32_t arm920t_get_ttb(struct target *target)
+int arm920t_get_ttb(struct target *target, uint32_t *result)
 {
 	int retval;
 	uint32_t ttb = 0x0;
@@ -328,7 +328,8 @@ uint32_t arm920t_get_ttb(struct target *target)
 			0xeebf0f51, 0x0, &amp;ttb)) != ERROR_OK)
 		return retval;
 
-	return ttb;
+	*result = ttb;
+	return ERROR_OK;
 }
 
 // EXPORTED to FA256
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
index a75f01a..9d5afab 100644
--- a/src/target/arm920t.h
+++ b/src/target/arm920t.h
@@ -66,7 +66,7 @@ int arm920t_write_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 void arm920t_post_debug_entry(struct target *target);
 void arm920t_pre_restore_context(struct target *target);
-	uint32_t arm920t_get_ttb(struct target *target);
+int arm920t_get_ttb(struct target *target, uint32_t *result);
 void arm920t_disable_mmu_caches(struct target *target,
 	int mmu, int d_u_cache, int i_cache);
 void arm920t_enable_mmu_caches(struct target *target,
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index d68e5ca..0cf7173 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -323,7 +323,7 @@ static int arm926ejs_examine_debug_reason(struct target *target)
 	return ERROR_OK;
 }
 
-static uint32_t arm926ejs_get_ttb(struct target *target)
+static int arm926ejs_get_ttb(struct target *target, uint32_t *result)
 {
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 	int retval;
@@ -332,7 +332,9 @@ static uint32_t arm926ejs_get_ttb(struct target *target)
 	if ((retval = arm926ejs-&gt;read_cp15(target, 0, 0, 2, 0, &amp;ttb)) != ERROR_OK)
 		return retval;
 
-	return ttb;
+	*result = ttb;
+
+	return ERROR_OK;
 }
 
 static void arm926ejs_disable_mmu_caches(struct target *target, int mmu,
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 861410d..3d450ae 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -30,8 +30,11 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 {
 	uint32_t first_lvl_descriptor = 0x0;
 	uint32_t second_lvl_descriptor = 0x0;
-	uint32_t ttb = armv4_5_mmu-&gt;get_ttb(target);
+	uint32_t ttb;
 	int retval;
+	retval = armv4_5_mmu-&gt;get_ttb(target, &amp;ttb);
+	if (retval != ERROR_OK)
+	  return retval;
 
 	retval = armv4_5_mmu_read_physical(target, armv4_5_mmu,
 		(ttb &amp; 0xffffc000) | ((va &amp; 0xfff00000) &gt;&gt; 18),
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 24f3993..d2716fb 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -26,7 +26,7 @@ struct target;
 
 struct armv4_5_mmu_common
 {
-	uint32_t (*get_ttb)(struct target *target);
+	int (*get_ttb)(struct target *target, uint32_t *result);
 	int (*read_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	int (*write_memory)(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	void (*disable_mmu_caches)(struct target *target, int mmu, int d_u_cache, int i_cache);
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index bd14016..e1acbf7 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -62,7 +62,7 @@ static void cortex_a8_disable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
 static void cortex_a8_enable_mmu_caches(struct target *target, int mmu,
                 int d_u_cache, int i_cache);
-static uint32_t cortex_a8_get_ttb(struct target *target);
+static int cortex_a8_get_ttb(struct target *target, uint32_t *result);
 
 
 /*
@@ -1853,8 +1853,7 @@ static int cortex_a8_target_create(struct target *target, Jim_Interp *interp)
 	return cortex_a8_init_arch_info(target, cortex_a8, target-&gt;tap);
 }
 
-/* FIX! error propagation missing from this fn */
-static uint32_t cortex_a8_get_ttb(struct target *target)
+static int cortex_a8_get_ttb(struct target *target, uint32_t *result)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
     struct armv7a_common *armv7a = &amp;cortex_a8-&gt;armv7a_common;
@@ -1869,6 +1868,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 1,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &amp;ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     else if(cortex_a8-&gt;current_address_mode == ARM_MODE_USR)
     {
@@ -1877,6 +1878,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 0,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &amp;ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     /* we don't know whose address is: user or kernel
        we assume that if we are in kernel mode then
@@ -1889,6 +1892,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 1,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &amp;ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     else if(armv7a-&gt;armv4_5_common.core_mode == ARM_MODE_USR)
     {
@@ -1897,6 +1902,8 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
                     0, 0,   /* op1, op2 */
                     2, 0,   /* CRn, CRm */
                     &amp;ttb);
+		if (retval != ERROR_OK)
+			return retval;
     }
     /* finally we don't know whose ttb to use: user or kernel */
     else
@@ -1904,7 +1911,9 @@ static uint32_t cortex_a8_get_ttb(struct target *target)
 
     ttb &amp;= 0xffffc000;
 
-    return ttb;
+    *result = ttb;
+
+    return ERROR_OK;
 }
 
 /* FIX! error propagation missing from this fn */
diff --git a/src/target/xscale.c b/src/target/xscale.c
index d5c2129..35efa85 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2002,15 +2002,20 @@ static int xscale_bulk_write_memory(struct target *target, uint32_t address,
 	return xscale_write_memory(target, address, 4, count, buffer);
 }
 
-static uint32_t xscale_get_ttb(struct target *target)
+static int xscale_get_ttb(struct target *target, uint32_t *result)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t ttb;
+	int retval;
 
-	xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_TTB]);
+	retval = xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_TTB]);
+	if (retval != ERROR_OK)
+		return retval;
 	ttb = buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_TTB].value, 0, 32);
 
-	return ttb;
+	*result = ttb;
+
+	return ERROR_OK;
 }
 
 static void xscale_disable_mmu_caches(struct target *target, int mmu,

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c   |   21 ++++-
 src/target/arm11.c         |    2 +-
 src/target/arm720t.c       |   83 +++++++++++++-----
 src/target/arm7_9_common.c |   41 +++++++--
 src/target/arm7_9_common.h |    2 +-
 src/target/arm7tdmi.c      |   17 +++-
 src/target/arm920t.c       |   95 ++++++++++++++-----
 src/target/arm920t.h       |    8 +-
 src/target/arm926ejs.c     |  116 +++++++++++++++++-------
 src/target/arm966e.c       |    8 ++-
 src/target/arm9tdmi.c      |   16 +++-
 src/target/arm_adi_v5.c    |  163 ++++++++++++++++++++++++----------
 src/target/arm_dpm.c       |   28 ++++++-
 src/target/armv4_5_mmu.c   |   25 ++++-
 src/target/armv4_5_mmu.h   |    6 +-
 src/target/armv7a.h        |    2 +-
 src/target/armv7m.h        |    2 +-
 src/target/cortex_a8.c     |   90 ++++++++++++++-----
 src/target/cortex_m3.c     |  215 +++++++++++++++++++++++++++++++++-----------
 src/target/embeddedice.c   |   22 ++++-
 src/target/etm.c           |   10 ++-
 src/target/feroceon.c      |    5 +-
 src/target/xscale.c        |   55 ++++++++---
 23 files changed, 769 insertions(+), 263 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002333.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-431-g6121841
</A></li>
	<LI>Next message: <A HREF="002335.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-444-ge0525cd
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2334">[ date ]</a>
              <a href="thread.html#2334">[ thread ]</a>
              <a href="subject.html#2334">[ subject ]</a>
              <a href="author.html#2334">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
