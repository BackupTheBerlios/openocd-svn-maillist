<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-404-g5557571
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-404-g5557571&In-Reply-To=%3CE1NA0Ow-00070m-DL%409j8yhf1.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001793.html">
   <LINK REL="Next"  HREF="001795.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-404-g5557571</H1>
    <B>Zach Welch</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-404-g5557571&In-Reply-To=%3CE1NA0Ow-00070m-DL%409j8yhf1.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-404-g5557571">zwelch at users.sourceforge.net
       </A><BR>
    <I>Mon Nov 16 13:09:45 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001793.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-400-g45527ee
</A></li>
        <LI>Next message: <A HREF="001795.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-405-gd7a0dfa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1794">[ date ]</a>
              <a href="thread.html#1794">[ thread ]</a>
              <a href="subject.html#1794">[ subject ]</a>
              <a href="author.html#1794">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  555757175eb344d11f3c0123f2f83460ef6ca67b (commit)
       via  da4cb3c029e7f271ee4fa7165ceefbef04d45e49 (commit)
       via  51cd370b396d19555158c1eb913e7c8386d92a0f (commit)
       via  23cc85b307de80be089dcb0048dbb6168e59651a (commit)
      from  45527ee82c9e7c93b29b79f01f52d663960649c2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 555757175eb344d11f3c0123f2f83460ef6ca67b
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Sat Nov 7 21:20:45 2009 -0800

    Add 'nand verify' command
    
    Add the 'nand verify' command to perform a dump and fake-write
    simultaneously, checking the read bits against those generated by the
    write process.  Appropriate user documentation for this command has
    been added to the user guide as well.
    
    The algorithm presently makes a relatively naive comparison.  Some chips
    that use ECC may not verify correctly using this implementation, but the
    new documentation provides details about this limitation.

diff --git a/doc/openocd.texi b/doc/openocd.texi
index bb96a2e..81409ac 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4620,6 +4620,32 @@ the underlying driver from applying hardware ECC.
 @end itemize
 @end deffn
 
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">+ at deffn</A> Command {nand verify} num filename offset [option...]
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">+ at cindex</A> NAND verification
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">+ at cindex</A> NAND programming
+Verify the binary data in the file has been programmed to the
+specified NAND device, starting at the specified offset.
+The @var{num} parameter is the value shown by @command{nand list}.
+
+Use a complete path name for @var{filename}, so you don't depend
+on the directory used to start the OpenOCD server.
+
+The @var{offset} must be an exact multiple of the device's page size.
+All data in the file will be read and compared to the contents of the
+flash, assuming it doesn't run past the end of the device.
+As with @command{nand write}, only full pages are verified, so any extra
+space in the last page will be filled with 0xff bytes.
+
+The same @var{options} accepted by @command{nand write},
+and the file will be processed similarly to produce the buffers that
+can be compared against the contents produced from @command{nand dump}.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">+ at b</A>{NOTE:} This will not work when the underlying NAND controller
+driver's @code{write_page} routine must update the OOB with a
+hardward-computed ECC before the data is written.  This limitation may
+be removed in a future release.
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">+ at end</A> deffn
+
 @section Other NAND commands
 @cindex NAND other commands
 
diff --git a/src/flash/nand.c b/src/flash/nand.c
index da561f6..46ac728 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -1543,6 +1543,67 @@ COMMAND_HANDLER(handle_nand_write_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_nand_verify_command)
+{
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state file;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&amp;file, &amp;nand, FILEIO_READ, false, true);
+	if (ERROR_OK != retval)
+		return retval;
+
+	struct nand_fileio_state dev;
+	nand_fileio_init(&amp;dev);
+	dev.address = file.address;
+	dev.size = file.size;
+	dev.oob_format = file.oob_format;
+	retval = nand_fileio_start(cmd_ctx, nand, NULL, FILEIO_NONE, &amp;dev);
+	if (ERROR_OK != retval)
+		return retval;
+
+	while (file.size &gt; 0)
+	{
+		int retval = nand_read_page(nand, dev.address / dev.page_size,
+				dev.page, dev.page_size, dev.oob, dev.oob_size);
+		if (ERROR_OK != retval)
+		{
+			command_print(cmd_ctx, &quot;reading NAND flash page failed&quot;);
+			nand_fileio_cleanup(&amp;dev);
+			return nand_fileio_cleanup(&amp;file);
+		}
+
+		int bytes_read = nand_fileio_read(nand, &amp;file);
+		if (bytes_read &lt;= 0)
+		{
+			command_print(cmd_ctx, &quot;error while reading file&quot;);
+			nand_fileio_cleanup(&amp;dev);
+			return nand_fileio_cleanup(&amp;file);
+		}
+
+		if ((dev.page &amp;&amp; memcmp(dev.page, file.page, dev.page_size)) ||
+		    (dev.oob &amp;&amp; memcmp(dev.oob, file.oob, dev.oob_size)) )
+		{
+			command_print(cmd_ctx, &quot;NAND flash contents differ &quot;
+						&quot;at 0x%8.8&quot; PRIx32, dev.address);
+			nand_fileio_cleanup(&amp;dev);
+			return nand_fileio_cleanup(&amp;file);
+		}
+
+		file.size -= bytes_read;
+		file.address += nand-&gt;page_size;
+	}
+
+	if (nand_fileio_finish(&amp;file) == ERROR_OK)
+	{
+		command_print(cmd_ctx, &quot;verified file %s in NAND flash %s &quot;
+				&quot;up to offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
+				args[1], args[0], dev.address, duration_elapsed(&amp;file.bench),
+				duration_kbps(&amp;file.bench, dev.size));
+	}
+
+	return nand_fileio_cleanup(&amp;dev);
+}
+
 COMMAND_HANDLER(handle_nand_dump_command)
 {
 	struct nand_device *nand = NULL;
@@ -1641,6 +1702,10 @@ int nand_init(struct command_context *cmd_ctx)
 			handle_nand_dump_command, COMMAND_EXEC,
 			&quot;dump from NAND flash device &lt;num&gt; &lt;filename&gt; &quot;
 			 &quot;&lt;offset&gt; &lt;length&gt; [oob_raw | oob_only]&quot;);
+	register_command(cmd_ctx, nand_cmd, &quot;verify&quot;,
+			&amp;handle_nand_verify_command, COMMAND_EXEC,
+			&quot;verify NAND flash device &lt;num&gt; &lt;filename&gt; &lt;offset&gt; &quot;
+			&quot;[oob_raw | oob_only | oob_softecc | oob_softecc_kw]&quot;);
 	register_command(cmd_ctx, nand_cmd, &quot;write&quot;,
 			handle_nand_write_command, COMMAND_EXEC,
 			&quot;write to NAND flash device &lt;num&gt; &lt;filename&gt; &lt;offset&gt; &quot;

commit da4cb3c029e7f271ee4fa7165ceefbef04d45e49
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Sat Nov 7 22:37:39 2009 -0800

    Add FILEIO_NONE access mode.
    
    In some cases, the FILEIO_NONE access mode may be useful as a parameter
    to indicate that file access should be disabled.  High-level routines can
    use it to skip file access calls, as 'fileio_open' will fail presently
    if called to open a file using this mode.

diff --git a/src/helper/fileio.h b/src/helper/fileio.h
index 024ad08..8cba926 100644
--- a/src/helper/fileio.h
+++ b/src/helper/fileio.h
@@ -38,6 +38,7 @@ enum fileio_type
 
 enum fileio_access
 {
+	FILEIO_NONE,		/* open without any access (invalid mode) */
 	FILEIO_READ,		/* open for reading, position at beginning */
 	FILEIO_WRITE,		/* open for writing, position at beginning */
 	FILEIO_READWRITE,	/* open for writing, position at beginning, allow reading */

commit 51cd370b396d19555158c1eb913e7c8386d92a0f
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Thu Nov 5 19:45:24 2009 -0800

    Use nand_fileio_* in write/dump commands.
    
    This patch eliminates duplicated code in the the NAND 'dump' and 'write'
    by using the new static helper functions.
    
    These changes also fix a possible memory leak in nand dump command, in
    the case that the dump file failed to open.
    
    Overall, the changes should be functionally equivalent, but the
    resulting code will be easier to improve and extend further.

diff --git a/src/flash/nand.c b/src/flash/nand.c
index 9cc0802..da561f6 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -1375,13 +1375,13 @@ static int nand_fileio_cleanup(struct nand_fileio_state *state)
 	}
 	return ERROR_OK;
 }
-int nand_fileio_finish(struct nand_fileio_state *state)
+static int nand_fileio_finish(struct nand_fileio_state *state)
 {
 	nand_fileio_cleanup(state);
 	return duration_measure(&amp;state-&gt;bench);
 }
 
-COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
+static COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
 		struct nand_device **dev, enum fileio_access filemode,
 		bool need_size, bool sw_ecc)
 {
@@ -1449,7 +1449,7 @@ COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
  * @returns If no error occurred, returns number of bytes consumed;
  * otherwise, returns a negative error code.)
  */
-int nand_fileio_read(struct nand_device *nand,
+static int nand_fileio_read(struct nand_device *nand,
 		struct nand_fileio_state *s)
 {
 	uint32_t total_read = 0;
@@ -1503,284 +1503,82 @@ int nand_fileio_read(struct nand_device *nand,
 
 COMMAND_HANDLER(handle_nand_write_command)
 {
-	uint32_t offset;
-	uint32_t binary_size;
-	uint32_t buf_cnt;
-	enum oob_formats oob_format = NAND_OOB_NONE;
-
-	struct fileio fileio;
-
-
-	if (argc &lt; 3)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct nand_device *p;
-	int retval = nand_command_get_device_by_num(cmd_ctx, args[0], &amp;p);
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state s;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&amp;s, &amp;nand, FILEIO_READ, false, true);
 	if (ERROR_OK != retval)
 		return retval;
 
-	uint8_t *page = NULL;
-	uint32_t page_size = 0;
-	uint8_t *oob = NULL;
-	uint32_t oob_size = 0;
-	const int *eccpos = NULL;
-
-	COMMAND_PARSE_NUMBER(u32, args[2], offset);
-
-	if (argc &gt; 3)
-	{
-		for (unsigned i = 3; i &lt; argc; i++)
-		{
-			if (!strcmp(args[i], &quot;oob_raw&quot;))
-				oob_format |= NAND_OOB_RAW;
-			else if (!strcmp(args[i], &quot;oob_only&quot;))
-				oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
-			else if (!strcmp(args[i], &quot;oob_softecc&quot;))
-				oob_format |= NAND_OOB_SW_ECC;
-			else if (!strcmp(args[i], &quot;oob_softecc_kw&quot;))
-				oob_format |= NAND_OOB_SW_ECC_KW;
-			else
-			{
-				command_print(cmd_ctx, &quot;unknown option: %s&quot;, args[i]);
-				return ERROR_COMMAND_SYNTAX_ERROR;
-			}
-		}
-	}
-
-	struct duration bench;
-	duration_start(&amp;bench);
-
-	if (fileio_open(&amp;fileio, args[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
-	{
-		return ERROR_OK;
-	}
-
-	buf_cnt = binary_size = fileio.size;
-
-	if (!(oob_format &amp; NAND_OOB_ONLY))
-	{
-		page_size = p-&gt;page_size;
-		page = malloc(p-&gt;page_size);
-	}
-
-	if (oob_format &amp; (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
-	{
-		if (p-&gt;page_size == 512) {
-			oob_size = 16;
-			eccpos = nand_oob_16.eccpos;
-		} else if (p-&gt;page_size == 2048) {
-			oob_size = 64;
-			eccpos = nand_oob_64.eccpos;
-		}
-		oob = malloc(oob_size);
-	}
-
-	if (offset % p-&gt;page_size)
-	{
-		command_print(cmd_ctx, &quot;only page size aligned offsets and sizes are supported&quot;);
-		fileio_close(&amp;fileio);
-		free(oob);
-		free(page);
-		return ERROR_OK;
-	}
-
-	while (buf_cnt &gt; 0)
+	uint32_t total_bytes = s.size;
+	while (s.size &gt; 0)
 	{
-		uint32_t size_read;
-
-		if (NULL != page)
+		int bytes_read = nand_fileio_read(nand, &amp;s);
+		if (bytes_read &lt;= 0)
 		{
-			fileio_read(&amp;fileio, page_size, page, &amp;size_read);
-			buf_cnt -= size_read;
-			if (size_read &lt; page_size)
-			{
-				memset(page + size_read, 0xff, page_size - size_read);
-			}
+			command_print(cmd_ctx, &quot;error while reading file&quot;);
+			return nand_fileio_cleanup(&amp;s);
 		}
+		s.size -= bytes_read;
 
-		if (oob_format &amp; NAND_OOB_SW_ECC)
-		{
-			uint32_t i, j;
-			uint8_t ecc[3];
-			memset(oob, 0xff, oob_size);
-			for (i = 0, j = 0; i &lt; page_size; i += 256) {
-				nand_calculate_ecc(p, page + i, ecc);
-				oob[eccpos[j++]] = ecc[0];
-				oob[eccpos[j++]] = ecc[1];
-				oob[eccpos[j++]] = ecc[2];
-			}
-		} else if (oob_format &amp; NAND_OOB_SW_ECC_KW)
-		{
-			/*
-			 * In this case eccpos is not used as
-			 * the ECC data is always stored contigously
-			 * at the end of the OOB area.  It consists
-			 * of 10 bytes per 512-byte data block.
-			 */
-			uint32_t i;
-			uint8_t *ecc = oob + oob_size - page_size/512 * 10;
-			memset(oob, 0xff, oob_size);
-			for (i = 0; i &lt; page_size; i += 512) {
-				nand_calculate_ecc_kw(p, page + i, ecc);
-				ecc += 10;
-			}
-		}
-		else if (NULL != oob)
+		retval = nand_write_page(nand, s.address / nand-&gt;page_size,
+				s.page, s.page_size, s.oob, s.oob_size);
+		if (ERROR_OK != retval)
 		{
-			fileio_read(&amp;fileio, oob_size, oob, &amp;size_read);
-			buf_cnt -= size_read;
-			if (size_read &lt; oob_size)
-			{
-				memset(oob + size_read, 0xff, oob_size - size_read);
-			}
+			command_print(cmd_ctx, &quot;failed writing file %s &quot;
+				&quot;to NAND flash %s at offset 0x%8.8&quot; PRIx32,
+				args[1], args[0], s.address);
+			return nand_fileio_cleanup(&amp;s);
 		}
-
-		if (nand_write_page(p, offset / p-&gt;page_size, page, page_size, oob, oob_size) != ERROR_OK)
-		{
-			command_print(cmd_ctx, &quot;failed writing file %s to NAND flash %s at offset 0x%8.8&quot; PRIx32 &quot;&quot;,
-				args[1], args[0], offset);
-
-			fileio_close(&amp;fileio);
-			free(oob);
-			free(page);
-
-			return ERROR_OK;
-		}
-		offset += page_size;
+		s.address += s.page_size;
 	}
 
-	fileio_close(&amp;fileio);
-	free(oob);
-	free(page);
-	oob = NULL;
-	page = NULL;
-	if (duration_measure(&amp;bench) == ERROR_OK)
+	if (nand_fileio_finish(&amp;s))
 	{
-		command_print(cmd_ctx, &quot;wrote file %s to NAND flash %s &quot;
-			&quot;up to offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
-			args[1], args[0], offset, duration_elapsed(&amp;bench),
-			duration_kbps(&amp;bench, fileio.size));
+		command_print(cmd_ctx, &quot;wrote file %s to NAND flash %s up to &quot;
+				&quot;offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
+				args[1], args[0], s.address, duration_elapsed(&amp;s.bench),
+				duration_kbps(&amp;s.bench, total_bytes));
 	}
-
 	return ERROR_OK;
 }
 
 COMMAND_HANDLER(handle_nand_dump_command)
 {
-	if (argc &lt; 4)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct nand_device *p;
-	int retval = nand_command_get_device_by_num(cmd_ctx, args[0], &amp;p);
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state s;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&amp;s, &amp;nand, FILEIO_WRITE, true, false);
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (NULL == p-&gt;device)
-	{
-		command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
-		return ERROR_OK;
-	}
-
-	struct fileio fileio;
-
-	uint8_t *page = NULL;
-	uint32_t page_size = 0;
-	uint8_t *oob = NULL;
-	uint32_t oob_size = 0;
-	uint32_t address;
-	COMMAND_PARSE_NUMBER(u32, args[2], address);
-	uint32_t size;
-	COMMAND_PARSE_NUMBER(u32, args[3], size);
-	uint32_t bytes_done = 0;
-	enum oob_formats oob_format = NAND_OOB_NONE;
-
-	if (argc &gt; 4)
-	{
-		for (unsigned i = 4; i &lt; argc; i++)
-		{
-			if (!strcmp(args[i], &quot;oob_raw&quot;))
-				oob_format |= NAND_OOB_RAW;
-			else if (!strcmp(args[i], &quot;oob_only&quot;))
-				oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
-			else
-				command_print(cmd_ctx, &quot;unknown option: '%s'&quot;, args[i]);
-		}
-	}
-
-	if ((address % p-&gt;page_size) || (size % p-&gt;page_size))
-	{
-		command_print(cmd_ctx, &quot;only page size aligned addresses and sizes are supported&quot;);
-		return ERROR_OK;
-	}
-
-	if (!(oob_format &amp; NAND_OOB_ONLY))
-	{
-		page_size = p-&gt;page_size;
-		page = malloc(p-&gt;page_size);
-	}
-
-	if (oob_format &amp; NAND_OOB_RAW)
-	{
-		if (p-&gt;page_size == 512)
-			oob_size = 16;
-		else if (p-&gt;page_size == 2048)
-			oob_size = 64;
-		oob = malloc(oob_size);
-	}
-
-	if (fileio_open(&amp;fileio, args[1], FILEIO_WRITE, FILEIO_BINARY) != ERROR_OK)
-	{
-		return ERROR_OK;
-	}
-
-	struct duration bench;
-	duration_start(&amp;bench);
-
-	while (size &gt; 0)
+	while (s.size &gt; 0)
 	{
 		uint32_t size_written;
-		if ((retval = nand_read_page(p, address / p-&gt;page_size, page, page_size, oob, oob_size)) != ERROR_OK)
+		int retval = nand_read_page(nand, s.address / nand-&gt;page_size,
+				s.page, s.page_size, s.oob, s.oob_size);
+		if (ERROR_OK != retval)
 		{
 			command_print(cmd_ctx, &quot;reading NAND flash page failed&quot;);
-			free(page);
-			free(oob);
-			fileio_close(&amp;fileio);
-			return ERROR_OK;
+			return nand_fileio_cleanup(&amp;s);
 		}
 
-		if (NULL != page)
-		{
-			fileio_write(&amp;fileio, page_size, page, &amp;size_written);
-			bytes_done += page_size;
-		}
+		if (NULL != s.page)
+			fileio_write(&amp;s.fileio, s.page_size, s.page, &amp;size_written);
 
-		if (NULL != oob)
-		{
-			fileio_write(&amp;fileio, oob_size, oob, &amp;size_written);
-			bytes_done += oob_size;
-		}
+		if (NULL != s.oob)
+			fileio_write(&amp;s.fileio, s.oob_size, s.oob, &amp;size_written);
 
-		size -= p-&gt;page_size;
-		address += p-&gt;page_size;
+		s.size -= nand-&gt;page_size;
+		s.address += nand-&gt;page_size;
 	}
 
-	free(page);
-	page = NULL;
-	free(oob);
-	oob = NULL;
-	fileio_close(&amp;fileio);
-
-	if (duration_measure(&amp;bench) == ERROR_OK)
+	if (nand_fileio_finish(&amp;s) == ERROR_OK)
 	{
-		command_print(cmd_ctx, &quot;dumped %lld byte in %fs (%0.3f kb/s)&quot;,
-			fileio.size, duration_elapsed(&amp;bench),
-			duration_kbps(&amp;bench, fileio.size));
+		command_print(cmd_ctx, &quot;dumped %lld byte in %fs (%0.3f kb/s)&quot;, 
+				s.fileio.size, duration_elapsed(&amp;s.bench),
+				duration_kbps(&amp;s.bench, s.fileio.size));
 	}
-
 	return ERROR_OK;
 }
 

commit 23cc85b307de80be089dcb0048dbb6168e59651a
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Sun Nov 8 02:06:34 2009 -0800

    Add nand_fileio_* helper APIs.
    
    This patch provides helpers APIs that will eliminate duplicated code in
    the the NAND 'dump' and 'write' commands by factoring their common code
    into static helper functions.  These helpers may be useful for creating
    new commands, as shown in the final patch to 'verify' flash from a file.
    
    Several previously unreported error conditions now generate messages and
    propogate the return codes, such as when the file fails to open and bad
    arguments are given.  These changes will fix a possible memory leak in
    nand dump command, in the case that the dump file failed to open.
    
    Overall, the changes should be functionally equivalent, but the
    resulting code will be easier to improve and extend consistently.

diff --git a/src/flash/nand.c b/src/flash/nand.c
index be3a669..9cc0802 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -1285,6 +1285,222 @@ COMMAND_HANDLER(handle_nand_check_bad_blocks_command)
 	return ERROR_OK;
 }
 
+struct nand_fileio_state {
+	uint32_t address;
+	uint32_t size;
+
+	uint8_t *page;
+	uint32_t page_size;
+
+	enum oob_formats oob_format;
+	uint8_t *oob;
+	uint32_t oob_size;
+
+	const int *eccpos;
+
+	bool file_opened;
+	struct fileio fileio;
+
+	struct duration bench;
+};
+
+static void nand_fileio_init(struct nand_fileio_state *state)
+{
+	memset(state, 0, sizeof(*state));
+	state-&gt;oob_format = NAND_OOB_NONE;
+}
+
+static int nand_fileio_start(struct command_context *cmd_ctx,
+		struct nand_device *nand, const char *filename, int filemode,
+		struct nand_fileio_state *state)
+{
+	if (state-&gt;address % nand-&gt;page_size)
+	{
+		command_print(cmd_ctx, &quot;only page-aligned addresses are supported&quot;);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	duration_start(&amp;state-&gt;bench);
+
+	if (NULL != filename)
+	{
+		int retval = fileio_open(&amp;state-&gt;fileio, filename, filemode, FILEIO_BINARY);
+		if (ERROR_OK != retval)
+		{
+			const char *msg = (FILEIO_READ == filemode) ? &quot;read&quot; : &quot;write&quot;;
+			command_print(cmd_ctx, &quot;failed to open '%s' for %s access&quot;,
+					filename, msg);
+			return retval;
+		}
+		state-&gt;file_opened = true;
+	}
+
+	if (!(state-&gt;oob_format &amp; NAND_OOB_ONLY))
+	{
+		state-&gt;page_size = nand-&gt;page_size;
+		state-&gt;page = malloc(nand-&gt;page_size);
+	}
+
+	if (state-&gt;oob_format &amp; (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
+	{
+		if (nand-&gt;page_size == 512)
+		{
+			state-&gt;oob_size = 16;
+			state-&gt;eccpos = nand_oob_16.eccpos;
+		}
+		else if (nand-&gt;page_size == 2048)
+		{
+			state-&gt;oob_size = 64;
+			state-&gt;eccpos = nand_oob_64.eccpos;
+		}
+		state-&gt;oob = malloc(state-&gt;oob_size);
+	}
+
+	return ERROR_OK;
+}
+static int nand_fileio_cleanup(struct nand_fileio_state *state)
+{
+	if (state-&gt;file_opened)
+		fileio_close(&amp;state-&gt;fileio);
+
+	if (state-&gt;oob)
+	{
+		free(state-&gt;oob);
+		state-&gt;oob = NULL;
+	}
+	if (state-&gt;page)
+	{
+		free(state-&gt;page);
+		state-&gt;page = NULL;
+	}
+	return ERROR_OK;
+}
+int nand_fileio_finish(struct nand_fileio_state *state)
+{
+	nand_fileio_cleanup(state);
+	return duration_measure(&amp;state-&gt;bench);
+}
+
+COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
+		struct nand_device **dev, enum fileio_access filemode,
+		bool need_size, bool sw_ecc)
+{
+	nand_fileio_init(state);
+
+	unsigned minargs = need_size ? 4 : 3;
+	if (argc &lt; minargs)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct nand_device *nand;
+	int retval = nand_command_get_device_by_num(cmd_ctx, args[0], &amp;nand);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (NULL == nand-&gt;device)
+	{
+		command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
+		return ERROR_OK;
+	}
+
+	COMMAND_PARSE_NUMBER(u32, args[2], state-&gt;address);
+	if (need_size)
+	{
+			COMMAND_PARSE_NUMBER(u32, args[2], state-&gt;size);
+			if (state-&gt;size % nand-&gt;page_size)
+			{
+				command_print(cmd_ctx, &quot;only page-aligned sizes are supported&quot;);
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+	}
+
+	if (argc &gt; minargs)
+	{
+		for (unsigned i = minargs; i &lt; argc; i++)
+		{
+			if (!strcmp(args[i], &quot;oob_raw&quot;))
+				state-&gt;oob_format |= NAND_OOB_RAW;
+			else if (!strcmp(args[i], &quot;oob_only&quot;))
+				state-&gt;oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
+			else if (sw_ecc &amp;&amp; !strcmp(args[i], &quot;oob_softecc&quot;))
+				state-&gt;oob_format |= NAND_OOB_SW_ECC;
+			else if (sw_ecc &amp;&amp; !strcmp(args[i], &quot;oob_softecc_kw&quot;))
+				state-&gt;oob_format |= NAND_OOB_SW_ECC_KW;
+			else
+			{
+				command_print(cmd_ctx, &quot;unknown option: %s&quot;, args[i]);
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+		}
+	}
+
+	retval = nand_fileio_start(cmd_ctx, nand, args[1], filemode, state);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (!need_size)
+		state-&gt;size = state-&gt;fileio.size;
+
+	*dev = nand;
+
+	return ERROR_OK;
+}
+
+/**
+ * @returns If no error occurred, returns number of bytes consumed;
+ * otherwise, returns a negative error code.)
+ */
+int nand_fileio_read(struct nand_device *nand,
+		struct nand_fileio_state *s)
+{
+	uint32_t total_read = 0;
+	uint32_t one_read;
+
+	if (NULL != s-&gt;page)
+	{
+		fileio_read(&amp;s-&gt;fileio, s-&gt;page_size, s-&gt;page, &amp;one_read);
+		if (one_read &lt; s-&gt;page_size)
+			memset(s-&gt;page + one_read, 0xff, s-&gt;page_size - one_read);
+		total_read += one_read;
+	}
+
+	if (s-&gt;oob_format &amp; NAND_OOB_SW_ECC)
+	{
+		uint8_t ecc[3];
+		memset(s-&gt;oob, 0xff, s-&gt;oob_size);
+		for (uint32_t i = 0, j = 0; i &lt; s-&gt;page_size; i += 256)
+		{
+			nand_calculate_ecc(nand, s-&gt;page + i, ecc);
+			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[0];
+			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[1];
+			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[2];
+		}
+	}
+	else if (s-&gt;oob_format &amp; NAND_OOB_SW_ECC_KW)
+	{
+		/*
+		 * In this case eccpos is not used as
+		 * the ECC data is always stored contigously
+		 * at the end of the OOB area.  It consists
+		 * of 10 bytes per 512-byte data block.
+		 */
+		uint8_t *ecc = s-&gt;oob + s-&gt;oob_size - s-&gt;page_size / 512 * 10;
+		memset(s-&gt;oob, 0xff, s-&gt;oob_size);
+		for (uint32_t i = 0; i &lt; s-&gt;page_size; i += 512)
+		{
+			nand_calculate_ecc_kw(nand, s-&gt;page + i, ecc);
+			ecc += 10;
+		}
+	}
+	else if (NULL != s-&gt;oob)
+	{
+		fileio_read(&amp;s-&gt;fileio, s-&gt;oob_size, s-&gt;oob, &amp;one_read);
+		if (one_read &lt; s-&gt;oob_size)
+			memset(s-&gt;oob + one_read, 0xff, s-&gt;oob_size - one_read);
+		total_read += one_read;
+	}
+	return total_read;
+}
+
 COMMAND_HANDLER(handle_nand_write_command)
 {
 	uint32_t offset;

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi    |   26 +++
 src/flash/nand.c    |  477 ++++++++++++++++++++++++++++++---------------------
 src/helper/fileio.h |    1 +
 3 files changed, 305 insertions(+), 199 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001793.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-400-g45527ee
</A></li>
	<LI>Next message: <A HREF="001795.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-405-gd7a0dfa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1794">[ date ]</a>
              <a href="thread.html#1794">[ thread ]</a>
              <a href="subject.html#1794">[ subject ]</a>
              <a href="author.html#1794">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
