<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-90-gca00483
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-90-gca00483&In-Reply-To=%3CE1N6MXk-0008FP-Bq%40fxgxhf1.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001733.html">
   <LINK REL="Next"  HREF="001735.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-90-gca00483</H1>
    <B>Zach Welch</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-90-gca00483&In-Reply-To=%3CE1N6MXk-0008FP-Bq%40fxgxhf1.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-90-gca00483">zwelch at users.sourceforge.net
       </A><BR>
    <I>Fri Nov  6 11:59:47 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001733.html">[openocd-svn] Main OpenOCD repository annotated tag, v0.1.0,	created. v0.1.0
</A></li>
        <LI>Next message: <A HREF="001735.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-92-gfb50efc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1734">[ date ]</a>
              <a href="thread.html#1734">[ thread ]</a>
              <a href="subject.html#1734">[ subject ]</a>
              <a href="author.html#1734">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  ca00483a95bd574ff824d66212c10a870d6620ee (commit)
       via  ff61e6a37ce79f00957fc5aeb304291e5fa06323 (commit)
       via  c5f56437c0be07201481ae2232d2c765cc1bc281 (commit)
      from  6a0af06bd9f66780d2c3e9f69c40f2b89ad90605 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ca00483a95bd574ff824d66212c10a870d6620ee
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Thu Nov 5 18:40:52 2009 -0800

    Simplify nand indentation.
    
    Removes check covered by new nand_command_get_device_by_num helper.
    Reverses logic of probe check to further reduce indentation.

diff --git a/src/flash/nand.c b/src/flash/nand.c
index 7fb7c99..81a04f7 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -1135,50 +1135,46 @@ static int handle_nand_info_command(struct command_context_s *cmd_ctx, char *cmd
 		break;
 	}
 
-	if (p)
+	if (NULL == p-&gt;device)
 	{
-		if (p-&gt;device)
-		{
-			if (first &gt;= p-&gt;num_blocks)
-				first = p-&gt;num_blocks - 1;
+		command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
+		return ERROR_OK;
+	}
 
-			if (last &gt;= p-&gt;num_blocks)
-				last = p-&gt;num_blocks - 1;
+	if (first &gt;= p-&gt;num_blocks)
+		first = p-&gt;num_blocks - 1;
 
-			command_print(cmd_ctx, &quot;#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i&quot;,
-				i++, p-&gt;device-&gt;name, p-&gt;manufacturer-&gt;name, p-&gt;page_size, p-&gt;bus_width, p-&gt;erase_size);
+	if (last &gt;= p-&gt;num_blocks)
+		last = p-&gt;num_blocks - 1;
 
-			for (j = first; j &lt;= last; j++)
-			{
-				char *erase_state, *bad_state;
+	command_print(cmd_ctx, &quot;#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i&quot;,
+		i++, p-&gt;device-&gt;name, p-&gt;manufacturer-&gt;name, p-&gt;page_size, p-&gt;bus_width, p-&gt;erase_size);
 
-				if (p-&gt;blocks[j].is_erased == 0)
-					erase_state = &quot;not erased&quot;;
-				else if (p-&gt;blocks[j].is_erased == 1)
-					erase_state = &quot;erased&quot;;
-				else
-					erase_state = &quot;erase state unknown&quot;;
+	for (j = first; j &lt;= last; j++)
+	{
+		char *erase_state, *bad_state;
 
-				if (p-&gt;blocks[j].is_bad == 0)
-					bad_state = &quot;&quot;;
-				else if (p-&gt;blocks[j].is_bad == 1)
-					bad_state = &quot; (marked bad)&quot;;
-				else
-					bad_state = &quot; (block condition unknown)&quot;;
-
-				command_print(cmd_ctx,
-					      &quot;\t#%i: 0x%8.8&quot; PRIx32 &quot; (%&quot; PRId32 &quot;kB) %s%s&quot;,
-					      j,
-					      p-&gt;blocks[j].offset,
-					      p-&gt;blocks[j].size / 1024,
-					      erase_state,
-					      bad_state);
-			}
-		}
+		if (p-&gt;blocks[j].is_erased == 0)
+			erase_state = &quot;not erased&quot;;
+		else if (p-&gt;blocks[j].is_erased == 1)
+			erase_state = &quot;erased&quot;;
 		else
-		{
-			command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
-		}
+			erase_state = &quot;erase state unknown&quot;;
+
+		if (p-&gt;blocks[j].is_bad == 0)
+			bad_state = &quot;&quot;;
+		else if (p-&gt;blocks[j].is_bad == 1)
+			bad_state = &quot; (marked bad)&quot;;
+		else
+			bad_state = &quot; (block condition unknown)&quot;;
+
+		command_print(cmd_ctx,
+			      &quot;\t#%i: 0x%8.8&quot; PRIx32 &quot; (%&quot; PRId32 &quot;kB) %s%s&quot;,
+			      j,
+			      p-&gt;blocks[j].offset,
+			      p-&gt;blocks[j].size / 1024,
+			      erase_state,
+			      bad_state);
 	}
 
 	return ERROR_OK;
@@ -1196,20 +1192,17 @@ static int handle_nand_probe_command(struct command_context_s *cmd_ctx, char *cm
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (p)
+	if ((retval = nand_probe(p)) == ERROR_OK)
 	{
-		if ((retval = nand_probe(p)) == ERROR_OK)
-		{
-			command_print(cmd_ctx, &quot;NAND flash device '%s' found&quot;, p-&gt;device-&gt;name);
-		}
-		else if (retval == ERROR_NAND_OPERATION_FAILED)
-		{
-			command_print(cmd_ctx, &quot;probing failed for NAND flash device&quot;);
-		}
-		else
-		{
-			command_print(cmd_ctx, &quot;unknown error when probing NAND flash device&quot;);
-		}
+		command_print(cmd_ctx, &quot;NAND flash device '%s' found&quot;, p-&gt;device-&gt;name);
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(cmd_ctx, &quot;probing failed for NAND flash device&quot;);
+	}
+	else
+	{
+		command_print(cmd_ctx, &quot;unknown error when probing NAND flash device&quot;);
 	}
 
 	return ERROR_OK;
@@ -1228,47 +1221,44 @@ static int handle_nand_erase_command(struct command_context_s *cmd_ctx, char *cm
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (p)
-	{
-		unsigned long offset;
-		unsigned long length;
+	unsigned long offset;
+	unsigned long length;
 
-		/* erase specified part of the chip; or else everything */
-		if (argc == 3) {
-			unsigned long size = p-&gt;erase_size * p-&gt;num_blocks;
+	/* erase specified part of the chip; or else everything */
+	if (argc == 3) {
+		unsigned long size = p-&gt;erase_size * p-&gt;num_blocks;
 
-			COMMAND_PARSE_NUMBER(ulong, args[1], offset);
-			if ((offset % p-&gt;erase_size) != 0 || offset &gt;= size)
-				return ERROR_INVALID_ARGUMENTS;
+		COMMAND_PARSE_NUMBER(ulong, args[1], offset);
+		if ((offset % p-&gt;erase_size) != 0 || offset &gt;= size)
+			return ERROR_INVALID_ARGUMENTS;
 
-			COMMAND_PARSE_NUMBER(ulong, args[2], length);
-			if ((length == 0) || (length % p-&gt;erase_size) != 0
-					|| (length + offset) &gt; size)
-				return ERROR_INVALID_ARGUMENTS;
+		COMMAND_PARSE_NUMBER(ulong, args[2], length);
+		if ((length == 0) || (length % p-&gt;erase_size) != 0
+				|| (length + offset) &gt; size)
+			return ERROR_INVALID_ARGUMENTS;
 
-			offset /= p-&gt;erase_size;
-			length /= p-&gt;erase_size;
-		} else {
-			offset = 0;
-			length = p-&gt;num_blocks;
-		}
+		offset /= p-&gt;erase_size;
+		length /= p-&gt;erase_size;
+	} else {
+		offset = 0;
+		length = p-&gt;num_blocks;
+	}
 
-		retval = nand_erase(p, offset, offset + length - 1);
-		if (retval == ERROR_OK)
-		{
-			command_print(cmd_ctx, &quot;erased blocks %lu to %lu &quot;
-					&quot;on NAND flash device #%s '%s'&quot;,
-					offset, offset + length,
-					args[0], p-&gt;device-&gt;name);
-		}
-		else if (retval == ERROR_NAND_OPERATION_FAILED)
-		{
-			command_print(cmd_ctx, &quot;erase failed&quot;);
-		}
-		else
-		{
-			command_print(cmd_ctx, &quot;unknown error when erasing NAND flash device&quot;);
-		}
+	retval = nand_erase(p, offset, offset + length - 1);
+	if (retval == ERROR_OK)
+	{
+		command_print(cmd_ctx, &quot;erased blocks %lu to %lu &quot;
+				&quot;on NAND flash device #%s '%s'&quot;,
+				offset, offset + length,
+				args[0], p-&gt;device-&gt;name);
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(cmd_ctx, &quot;erase failed&quot;);
+	}
+	else
+	{
+		command_print(cmd_ctx, &quot;unknown error when erasing NAND flash device&quot;);
 	}
 
 	return ERROR_OK;
@@ -1353,150 +1343,147 @@ static int handle_nand_write_command(struct command_context_s *cmd_ctx, char *cm
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (p)
-	{
-		uint8_t *page = NULL;
-		uint32_t page_size = 0;
-		uint8_t *oob = NULL;
-		uint32_t oob_size = 0;
-		const int *eccpos = NULL;
+	uint8_t *page = NULL;
+	uint32_t page_size = 0;
+	uint8_t *oob = NULL;
+	uint32_t oob_size = 0;
+	const int *eccpos = NULL;
 
-		COMMAND_PARSE_NUMBER(u32, args[2], offset);
+	COMMAND_PARSE_NUMBER(u32, args[2], offset);
 
-		if (argc &gt; 3)
+	if (argc &gt; 3)
+	{
+		int i;
+		for (i = 3; i &lt; argc; i++)
 		{
-			int i;
-			for (i = 3; i &lt; argc; i++)
+			if (!strcmp(args[i], &quot;oob_raw&quot;))
+				oob_format |= NAND_OOB_RAW;
+			else if (!strcmp(args[i], &quot;oob_only&quot;))
+				oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
+			else if (!strcmp(args[i], &quot;oob_softecc&quot;))
+				oob_format |= NAND_OOB_SW_ECC;
+			else if (!strcmp(args[i], &quot;oob_softecc_kw&quot;))
+				oob_format |= NAND_OOB_SW_ECC_KW;
+			else
 			{
-				if (!strcmp(args[i], &quot;oob_raw&quot;))
-					oob_format |= NAND_OOB_RAW;
-				else if (!strcmp(args[i], &quot;oob_only&quot;))
-					oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
-				else if (!strcmp(args[i], &quot;oob_softecc&quot;))
-					oob_format |= NAND_OOB_SW_ECC;
-				else if (!strcmp(args[i], &quot;oob_softecc_kw&quot;))
-					oob_format |= NAND_OOB_SW_ECC_KW;
-				else
-				{
-					command_print(cmd_ctx, &quot;unknown option: %s&quot;, args[i]);
-					return ERROR_COMMAND_SYNTAX_ERROR;
-				}
+				command_print(cmd_ctx, &quot;unknown option: %s&quot;, args[i]);
+				return ERROR_COMMAND_SYNTAX_ERROR;
 			}
 		}
+	}
 
-		duration_start_measure(&amp;duration);
+	duration_start_measure(&amp;duration);
 
-		if (fileio_open(&amp;fileio, args[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
-		{
-			return ERROR_OK;
-		}
+	if (fileio_open(&amp;fileio, args[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
+	{
+		return ERROR_OK;
+	}
 
-		buf_cnt = binary_size = fileio.size;
+	buf_cnt = binary_size = fileio.size;
 
-		if (!(oob_format &amp; NAND_OOB_ONLY))
-		{
-			page_size = p-&gt;page_size;
-			page = malloc(p-&gt;page_size);
-		}
+	if (!(oob_format &amp; NAND_OOB_ONLY))
+	{
+		page_size = p-&gt;page_size;
+		page = malloc(p-&gt;page_size);
+	}
 
-		if (oob_format &amp; (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
-		{
-			if (p-&gt;page_size == 512) {
-				oob_size = 16;
-				eccpos = nand_oob_16.eccpos;
-			} else if (p-&gt;page_size == 2048) {
-				oob_size = 64;
-				eccpos = nand_oob_64.eccpos;
-			}
-			oob = malloc(oob_size);
+	if (oob_format &amp; (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
+	{
+		if (p-&gt;page_size == 512) {
+			oob_size = 16;
+			eccpos = nand_oob_16.eccpos;
+		} else if (p-&gt;page_size == 2048) {
+			oob_size = 64;
+			eccpos = nand_oob_64.eccpos;
 		}
+		oob = malloc(oob_size);
+	}
 
-		if (offset % p-&gt;page_size)
-		{
-			command_print(cmd_ctx, &quot;only page size aligned offsets and sizes are supported&quot;);
-			fileio_close(&amp;fileio);
-			free(oob);
-			free(page);
-			return ERROR_OK;
-		}
+	if (offset % p-&gt;page_size)
+	{
+		command_print(cmd_ctx, &quot;only page size aligned offsets and sizes are supported&quot;);
+		fileio_close(&amp;fileio);
+		free(oob);
+		free(page);
+		return ERROR_OK;
+	}
 
-		while (buf_cnt &gt; 0)
-		{
-			uint32_t size_read;
+	while (buf_cnt &gt; 0)
+	{
+		uint32_t size_read;
 
-			if (NULL != page)
+		if (NULL != page)
+		{
+			fileio_read(&amp;fileio, page_size, page, &amp;size_read);
+			buf_cnt -= size_read;
+			if (size_read &lt; page_size)
 			{
-				fileio_read(&amp;fileio, page_size, page, &amp;size_read);
-				buf_cnt -= size_read;
-				if (size_read &lt; page_size)
-				{
-					memset(page + size_read, 0xff, page_size - size_read);
-				}
+				memset(page + size_read, 0xff, page_size - size_read);
 			}
+		}
 
-			if (oob_format &amp; NAND_OOB_SW_ECC)
-			{
-				uint32_t i, j;
-				uint8_t ecc[3];
-				memset(oob, 0xff, oob_size);
-				for (i = 0, j = 0; i &lt; page_size; i += 256) {
-					nand_calculate_ecc(p, page + i, ecc);
-					oob[eccpos[j++]] = ecc[0];
-					oob[eccpos[j++]] = ecc[1];
-					oob[eccpos[j++]] = ecc[2];
-				}
-			} else if (oob_format &amp; NAND_OOB_SW_ECC_KW)
-			{
-				/*
-				 * In this case eccpos is not used as
-				 * the ECC data is always stored contigously
-				 * at the end of the OOB area.  It consists
-				 * of 10 bytes per 512-byte data block.
-				 */
-				uint32_t i;
-				uint8_t *ecc = oob + oob_size - page_size/512 * 10;
-				memset(oob, 0xff, oob_size);
-				for (i = 0; i &lt; page_size; i += 512) {
-					nand_calculate_ecc_kw(p, page + i, ecc);
-					ecc += 10;
-				}
+		if (oob_format &amp; NAND_OOB_SW_ECC)
+		{
+			uint32_t i, j;
+			uint8_t ecc[3];
+			memset(oob, 0xff, oob_size);
+			for (i = 0, j = 0; i &lt; page_size; i += 256) {
+				nand_calculate_ecc(p, page + i, ecc);
+				oob[eccpos[j++]] = ecc[0];
+				oob[eccpos[j++]] = ecc[1];
+				oob[eccpos[j++]] = ecc[2];
+			}
+		} else if (oob_format &amp; NAND_OOB_SW_ECC_KW)
+		{
+			/*
+			 * In this case eccpos is not used as
+			 * the ECC data is always stored contigously
+			 * at the end of the OOB area.  It consists
+			 * of 10 bytes per 512-byte data block.
+			 */
+			uint32_t i;
+			uint8_t *ecc = oob + oob_size - page_size/512 * 10;
+			memset(oob, 0xff, oob_size);
+			for (i = 0; i &lt; page_size; i += 512) {
+				nand_calculate_ecc_kw(p, page + i, ecc);
+				ecc += 10;
 			}
-			else if (NULL != oob)
+		}
+		else if (NULL != oob)
+		{
+			fileio_read(&amp;fileio, oob_size, oob, &amp;size_read);
+			buf_cnt -= size_read;
+			if (size_read &lt; oob_size)
 			{
-				fileio_read(&amp;fileio, oob_size, oob, &amp;size_read);
-				buf_cnt -= size_read;
-				if (size_read &lt; oob_size)
-				{
-					memset(oob + size_read, 0xff, oob_size - size_read);
-				}
+				memset(oob + size_read, 0xff, oob_size - size_read);
 			}
+		}
 
-			if (nand_write_page(p, offset / p-&gt;page_size, page, page_size, oob, oob_size) != ERROR_OK)
-			{
-				command_print(cmd_ctx, &quot;failed writing file %s to NAND flash %s at offset 0x%8.8&quot; PRIx32 &quot;&quot;,
-					args[1], args[0], offset);
+		if (nand_write_page(p, offset / p-&gt;page_size, page, page_size, oob, oob_size) != ERROR_OK)
+		{
+			command_print(cmd_ctx, &quot;failed writing file %s to NAND flash %s at offset 0x%8.8&quot; PRIx32 &quot;&quot;,
+				args[1], args[0], offset);
 
-				fileio_close(&amp;fileio);
-				free(oob);
-				free(page);
+			fileio_close(&amp;fileio);
+			free(oob);
+			free(page);
 
-				return ERROR_OK;
-			}
-			offset += page_size;
+			return ERROR_OK;
 		}
-
-		fileio_close(&amp;fileio);
-		free(oob);
-		free(page);
-		oob = NULL;
-		page = NULL;
-		duration_stop_measure(&amp;duration, &amp;duration_text);
-		command_print(cmd_ctx, &quot;wrote file %s to NAND flash %s up to offset 0x%8.8&quot; PRIx32 &quot; in %s&quot;,
-			args[1], args[0], offset, duration_text);
-		free(duration_text);
-		duration_text = NULL;
+		offset += page_size;
 	}
 
+	fileio_close(&amp;fileio);
+	free(oob);
+	free(page);
+	oob = NULL;
+	page = NULL;
+	duration_stop_measure(&amp;duration, &amp;duration_text);
+	command_print(cmd_ctx, &quot;wrote file %s to NAND flash %s up to offset 0x%8.8&quot; PRIx32 &quot; in %s&quot;,
+		args[1], args[0], offset, duration_text);
+	free(duration_text);
+	duration_text = NULL;
+
 	return ERROR_OK;
 }
 
@@ -1512,113 +1499,108 @@ static int handle_nand_dump_command(struct command_context_s *cmd_ctx, char *cmd
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (p)
+	if (NULL == p-&gt;device)
 	{
-		if (p-&gt;device)
-		{
-			fileio_t fileio;
-			duration_t duration;
-			char *duration_text;
-			int retval;
-
-			uint8_t *page = NULL;
-			uint32_t page_size = 0;
-			uint8_t *oob = NULL;
-			uint32_t oob_size = 0;
-			uint32_t address;
-			COMMAND_PARSE_NUMBER(u32, args[2], address);
-			uint32_t size;
-			COMMAND_PARSE_NUMBER(u32, args[3], size);
-			uint32_t bytes_done = 0;
-			enum oob_formats oob_format = NAND_OOB_NONE;
-
-			if (argc &gt; 4)
-			{
-				int i;
-				for (i = 4; i &lt; argc; i++)
-				{
-					if (!strcmp(args[i], &quot;oob_raw&quot;))
-						oob_format |= NAND_OOB_RAW;
-					else if (!strcmp(args[i], &quot;oob_only&quot;))
-						oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
-					else
-						command_print(cmd_ctx, &quot;unknown option: '%s'&quot;, args[i]);
-				}
-			}
-
-			if ((address % p-&gt;page_size) || (size % p-&gt;page_size))
-			{
-				command_print(cmd_ctx, &quot;only page size aligned addresses and sizes are supported&quot;);
-				return ERROR_OK;
-			}
+		command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
+		return ERROR_OK;
+	}
 
-			if (!(oob_format &amp; NAND_OOB_ONLY))
-			{
-				page_size = p-&gt;page_size;
-				page = malloc(p-&gt;page_size);
-			}
+	fileio_t fileio;
+	duration_t duration;
+	char *duration_text;
 
-			if (oob_format &amp; NAND_OOB_RAW)
-			{
-				if (p-&gt;page_size == 512)
-					oob_size = 16;
-				else if (p-&gt;page_size == 2048)
-					oob_size = 64;
-				oob = malloc(oob_size);
-			}
+	uint8_t *page = NULL;
+	uint32_t page_size = 0;
+	uint8_t *oob = NULL;
+	uint32_t oob_size = 0;
+	uint32_t address;
+	COMMAND_PARSE_NUMBER(u32, args[2], address);
+	uint32_t size;
+	COMMAND_PARSE_NUMBER(u32, args[3], size);
+	uint32_t bytes_done = 0;
+	enum oob_formats oob_format = NAND_OOB_NONE;
 
-			if (fileio_open(&amp;fileio, args[1], FILEIO_WRITE, FILEIO_BINARY) != ERROR_OK)
-			{
-				return ERROR_OK;
-			}
+	if (argc &gt; 4)
+	{
+		int i;
+		for (i = 4; i &lt; argc; i++)
+		{
+			if (!strcmp(args[i], &quot;oob_raw&quot;))
+				oob_format |= NAND_OOB_RAW;
+			else if (!strcmp(args[i], &quot;oob_only&quot;))
+				oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
+			else
+				command_print(cmd_ctx, &quot;unknown option: '%s'&quot;, args[i]);
+		}
+	}
 
-			duration_start_measure(&amp;duration);
+	if ((address % p-&gt;page_size) || (size % p-&gt;page_size))
+	{
+		command_print(cmd_ctx, &quot;only page size aligned addresses and sizes are supported&quot;);
+		return ERROR_OK;
+	}
 
-			while (size &gt; 0)
-			{
-				uint32_t size_written;
-				if ((retval = nand_read_page(p, address / p-&gt;page_size, page, page_size, oob, oob_size)) != ERROR_OK)
-				{
-					command_print(cmd_ctx, &quot;reading NAND flash page failed&quot;);
-					free(page);
-					free(oob);
-					fileio_close(&amp;fileio);
-					return ERROR_OK;
-				}
+	if (!(oob_format &amp; NAND_OOB_ONLY))
+	{
+		page_size = p-&gt;page_size;
+		page = malloc(p-&gt;page_size);
+	}
 
-				if (NULL != page)
-				{
-					fileio_write(&amp;fileio, page_size, page, &amp;size_written);
-					bytes_done += page_size;
-				}
+	if (oob_format &amp; NAND_OOB_RAW)
+	{
+		if (p-&gt;page_size == 512)
+			oob_size = 16;
+		else if (p-&gt;page_size == 2048)
+			oob_size = 64;
+		oob = malloc(oob_size);
+	}
 
-				if (NULL != oob)
-				{
-					fileio_write(&amp;fileio, oob_size, oob, &amp;size_written);
-					bytes_done += oob_size;
-				}
+	if (fileio_open(&amp;fileio, args[1], FILEIO_WRITE, FILEIO_BINARY) != ERROR_OK)
+	{
+		return ERROR_OK;
+	}
 
-				size -= p-&gt;page_size;
-				address += p-&gt;page_size;
-			}
+	duration_start_measure(&amp;duration);
 
+	while (size &gt; 0)
+	{
+		uint32_t size_written;
+		if ((retval = nand_read_page(p, address / p-&gt;page_size, page, page_size, oob, oob_size)) != ERROR_OK)
+		{
+			command_print(cmd_ctx, &quot;reading NAND flash page failed&quot;);
 			free(page);
-			page = NULL;
 			free(oob);
-			oob = NULL;
 			fileio_close(&amp;fileio);
+			return ERROR_OK;
+		}
 
-			duration_stop_measure(&amp;duration, &amp;duration_text);
-			command_print(cmd_ctx, &quot;dumped %lld byte in %s&quot;, fileio.size, duration_text);
-			free(duration_text);
-			duration_text = NULL;
+		if (NULL != page)
+		{
+			fileio_write(&amp;fileio, page_size, page, &amp;size_written);
+			bytes_done += page_size;
 		}
-		else
+
+		if (NULL != oob)
 		{
-			command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
+			fileio_write(&amp;fileio, oob_size, oob, &amp;size_written);
+			bytes_done += oob_size;
 		}
+
+		size -= p-&gt;page_size;
+		address += p-&gt;page_size;
 	}
 
+	free(page);
+	page = NULL;
+	free(oob);
+	oob = NULL;
+	fileio_close(&amp;fileio);
+
+	duration_stop_measure(&amp;duration, &amp;duration_text);
+	command_print(cmd_ctx, &quot;dumped %lld byte in %s&quot;, fileio.size, duration_text);
+	free(duration_text);
+	duration_text = NULL;
+
 	return ERROR_OK;
 }
 
@@ -1634,33 +1616,24 @@ static int handle_nand_raw_access_command(struct command_context_s *cmd_ctx, cha
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (p)
+	if (NULL == p-&gt;device)
 	{
-		if (p-&gt;device)
-		{
-			if (argc == 2)
-			{
-				if (strcmp(&quot;enable&quot;, args[1]) == 0)
-				{
-					p-&gt;use_raw = 1;
-				}
-				else if (strcmp(&quot;disable&quot;, args[1]) == 0)
-				{
-					p-&gt;use_raw = 0;
-				}
-				else
-				{
-					return ERROR_COMMAND_SYNTAX_ERROR;
-				}
-			}
+		command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
+		return ERROR_OK;
+	}
 
-			command_print(cmd_ctx, &quot;raw access is %s&quot;, (p-&gt;use_raw) ? &quot;enabled&quot; : &quot;disabled&quot;);
-		}
+	if (argc == 2)
+	{
+		if (strcmp(&quot;enable&quot;, args[1]) == 0)
+			p-&gt;use_raw = 1;
+		else if (strcmp(&quot;disable&quot;, args[1]) == 0)
+			p-&gt;use_raw = 0;
 		else
-		{
-			command_print(cmd_ctx, &quot;#%s: not probed&quot;, args[0]);
-		}
+			return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
+	const char *msg = p-&gt;use_raw ? &quot;enabled&quot; : &quot;disabled&quot;;
+	command_print(cmd_ctx, &quot;raw access is %s&quot;, msg);
+
 	return ERROR_OK;
 }

commit ff61e6a37ce79f00957fc5aeb304291e5fa06323
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Thu Nov 5 23:52:03 2009 -0800

    Improve flash indentation.
    
    Removes redundant tests and reverses backwards logic to reduce the
    indentation level in flash.c.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index b40e074..329ade6 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -177,35 +177,35 @@ int flash_init_drivers(struct command_context_s *cmd_ctx)
 {
 	register_jim(cmd_ctx, &quot;ocd_flash_banks&quot;, jim_flash_banks, &quot;return information about the flash banks&quot;);
 
-	if (flash_banks)
-	{
-		register_command(cmd_ctx, flash_cmd, &quot;info&quot;, handle_flash_info_command, COMMAND_EXEC,
-						 &quot;print info about flash bank &lt;num&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;probe&quot;, handle_flash_probe_command, COMMAND_EXEC,
-						 &quot;identify flash bank &lt;num&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;erase_check&quot;, handle_flash_erase_check_command, COMMAND_EXEC,
-						 &quot;check erase state of sectors in flash bank &lt;num&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;protect_check&quot;, handle_flash_protect_check_command, COMMAND_EXEC,
-						 &quot;check protection state of sectors in flash bank &lt;num&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;erase_sector&quot;, handle_flash_erase_command, COMMAND_EXEC,
-						 &quot;erase sectors at &lt;bank&gt; &lt;first&gt; &lt;last&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;erase_address&quot;, handle_flash_erase_address_command, COMMAND_EXEC,
-						 &quot;erase address range &lt;address&gt; &lt;length&gt;&quot;);
-
-		register_command(cmd_ctx, flash_cmd, &quot;fillw&quot;, handle_flash_fill_command, COMMAND_EXEC,
-						 &quot;fill with pattern (no autoerase) &lt;address&gt; &lt;word_pattern&gt; &lt;count&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;fillh&quot;, handle_flash_fill_command, COMMAND_EXEC,
-						 &quot;fill with pattern &lt;address&gt; &lt;halfword_pattern&gt; &lt;count&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;fillb&quot;, handle_flash_fill_command, COMMAND_EXEC,
-						 &quot;fill with pattern &lt;address&gt; &lt;byte_pattern&gt; &lt;count&gt;&quot;);
-
-		register_command(cmd_ctx, flash_cmd, &quot;write_bank&quot;, handle_flash_write_bank_command, COMMAND_EXEC,
-						 &quot;write binary data to &lt;bank&gt; &lt;file&gt; &lt;offset&gt;&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;write_image&quot;, handle_flash_write_image_command, COMMAND_EXEC,
-						 &quot;write_image [erase] [unlock] &lt;file&gt; [offset] [type]&quot;);
-		register_command(cmd_ctx, flash_cmd, &quot;protect&quot;, handle_flash_protect_command, COMMAND_EXEC,
-						 &quot;set protection of sectors at &lt;bank&gt; &lt;first&gt; &lt;last&gt; &lt;on | off&gt;&quot;);
-	}
+	if (!flash_banks)
+		return ERROR_OK;
+
+	register_command(cmd_ctx, flash_cmd, &quot;info&quot;, handle_flash_info_command, COMMAND_EXEC,
+					 &quot;print info about flash bank &lt;num&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;probe&quot;, handle_flash_probe_command, COMMAND_EXEC,
+					 &quot;identify flash bank &lt;num&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;erase_check&quot;, handle_flash_erase_check_command, COMMAND_EXEC,
+					 &quot;check erase state of sectors in flash bank &lt;num&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;protect_check&quot;, handle_flash_protect_check_command, COMMAND_EXEC,
+					 &quot;check protection state of sectors in flash bank &lt;num&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;erase_sector&quot;, handle_flash_erase_command, COMMAND_EXEC,
+					 &quot;erase sectors at &lt;bank&gt; &lt;first&gt; &lt;last&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;erase_address&quot;, handle_flash_erase_address_command, COMMAND_EXEC,
+					 &quot;erase address range &lt;address&gt; &lt;length&gt;&quot;);
+
+	register_command(cmd_ctx, flash_cmd, &quot;fillw&quot;, handle_flash_fill_command, COMMAND_EXEC,
+					 &quot;fill with pattern (no autoerase) &lt;address&gt; &lt;word_pattern&gt; &lt;count&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;fillh&quot;, handle_flash_fill_command, COMMAND_EXEC,
+					 &quot;fill with pattern &lt;address&gt; &lt;halfword_pattern&gt; &lt;count&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;fillb&quot;, handle_flash_fill_command, COMMAND_EXEC,
+					 &quot;fill with pattern &lt;address&gt; &lt;byte_pattern&gt; &lt;count&gt;&quot;);
+
+	register_command(cmd_ctx, flash_cmd, &quot;write_bank&quot;, handle_flash_write_bank_command, COMMAND_EXEC,
+					 &quot;write binary data to &lt;bank&gt; &lt;file&gt; &lt;offset&gt;&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;write_image&quot;, handle_flash_write_image_command, COMMAND_EXEC,
+					 &quot;write_image [erase] [unlock] &lt;file&gt; [offset] [type]&quot;);
+	register_command(cmd_ctx, flash_cmd, &quot;protect&quot;, handle_flash_protect_command, COMMAND_EXEC,
+					 &quot;set protection of sectors at &lt;bank&gt; &lt;first&gt; &lt;last&gt; &lt;on | off&gt;&quot;);
 
 	return ERROR_OK;
 }
@@ -292,54 +292,54 @@ static int handle_flash_bank_command(struct command_context_s *cmd_ctx, char *cm
 
 	for (i = 0; flash_drivers[i]; i++)
 	{
-		if (strcmp(args[0], flash_drivers[i]-&gt;name) == 0)
-		{
-			flash_bank_t *p, *c;
+		if (strcmp(args[0], flash_drivers[i]-&gt;name) != 0)
+			continue;
 
-			/* register flash specific commands */
-			if (flash_drivers[i]-&gt;register_commands(cmd_ctx) != ERROR_OK)
-			{
-				LOG_ERROR(&quot;couldn't register '%s' commands&quot;, args[0]);
-				return ERROR_FAIL;
-			}
+		flash_bank_t *p, *c;
 
-			c = malloc(sizeof(flash_bank_t));
-			c-&gt;target = target;
-			c-&gt;driver = flash_drivers[i];
-			c-&gt;driver_priv = NULL;
-			COMMAND_PARSE_NUMBER(u32, args[1], c-&gt;base);
-			COMMAND_PARSE_NUMBER(u32, args[2], c-&gt;size);
-			COMMAND_PARSE_NUMBER(int, args[3], c-&gt;chip_width);
-			COMMAND_PARSE_NUMBER(int, args[4], c-&gt;bus_width);
-			c-&gt;num_sectors = 0;
-			c-&gt;sectors = NULL;
-			c-&gt;next = NULL;
-
-			if ((retval = flash_drivers[i]-&gt;flash_bank_command(cmd_ctx, cmd, args, argc, c)) != ERROR_OK)
-			{
-				LOG_ERROR(&quot;'%s' driver rejected flash bank at 0x%8.8&quot; PRIx32 , args[0], c-&gt;base);
-				free(c);
-				return retval;
-			}
+		/* register flash specific commands */
+		if (flash_drivers[i]-&gt;register_commands(cmd_ctx) != ERROR_OK)
+		{
+			LOG_ERROR(&quot;couldn't register '%s' commands&quot;, args[0]);
+			return ERROR_FAIL;
+		}
 
-			/* put flash bank in linked list */
-			if (flash_banks)
-			{
-				int	bank_num = 0;
-				/* find last flash bank */
-				for (p = flash_banks; p &amp;&amp; p-&gt;next; p = p-&gt;next) bank_num++;
-				if (p)
-					p-&gt;next = c;
-				c-&gt;bank_number = bank_num + 1;
-			}
-			else
-			{
-				flash_banks = c;
-				c-&gt;bank_number = 0;
-			}
+		c = malloc(sizeof(flash_bank_t));
+		c-&gt;target = target;
+		c-&gt;driver = flash_drivers[i];
+		c-&gt;driver_priv = NULL;
+		COMMAND_PARSE_NUMBER(u32, args[1], c-&gt;base);
+		COMMAND_PARSE_NUMBER(u32, args[2], c-&gt;size);
+		COMMAND_PARSE_NUMBER(int, args[3], c-&gt;chip_width);
+		COMMAND_PARSE_NUMBER(int, args[4], c-&gt;bus_width);
+		c-&gt;num_sectors = 0;
+		c-&gt;sectors = NULL;
+		c-&gt;next = NULL;
+
+		if ((retval = flash_drivers[i]-&gt;flash_bank_command(cmd_ctx, cmd, args, argc, c)) != ERROR_OK)
+		{
+			LOG_ERROR(&quot;'%s' driver rejected flash bank at 0x%8.8&quot; PRIx32 , args[0], c-&gt;base);
+			free(c);
+			return retval;
+		}
 
-			found = 1;
+		/* put flash bank in linked list */
+		if (flash_banks)
+		{
+			int	bank_num = 0;
+			/* find last flash bank */
+			for (p = flash_banks; p &amp;&amp; p-&gt;next; p = p-&gt;next) bank_num++;
+			if (p)
+				p-&gt;next = c;
+			c-&gt;bank_number = bank_num + 1;
 		}
+		else
+		{
+			flash_banks = c;
+			c-&gt;bank_number = 0;
+		}
+
+		found = 1;
 	}
 
 	/* no matching flash driver found */
@@ -367,48 +367,48 @@ static int handle_flash_info_command(struct command_context_s *cmd_ctx, char *cm
 
 	for (p = flash_banks; p; p = p-&gt;next, i++)
 	{
-		if (i == bank_nr)
+		if (i != bank_nr)
+			continue;
+
+		char buf[1024];
+
+		/* attempt auto probe */
+		if ((retval = p-&gt;driver-&gt;auto_probe(p)) != ERROR_OK)
+			return retval;
+
+		command_print(cmd_ctx,
+			      &quot;#%&quot; PRIi32 &quot; : %s at 0x%8.8&quot; PRIx32 &quot;, size 0x%8.8&quot; PRIx32 &quot;, buswidth %i, chipwidth %i&quot;,
+			      i,
+			      p-&gt;driver-&gt;name,
+			      p-&gt;base,
+			      p-&gt;size,
+			      p-&gt;bus_width,
+			      p-&gt;chip_width);
+		for (j = 0; j &lt; p-&gt;num_sectors; j++)
 		{
-			char buf[1024];
+			char *protect_state;
 
-			/* attempt auto probe */
-			if ((retval = p-&gt;driver-&gt;auto_probe(p)) != ERROR_OK)
-				return retval;
+			if (p-&gt;sectors[j].is_protected == 0)
+				protect_state = &quot;not protected&quot;;
+			else if (p-&gt;sectors[j].is_protected == 1)
+				protect_state = &quot;protected&quot;;
+			else
+				protect_state = &quot;protection state unknown&quot;;
 
 			command_print(cmd_ctx,
-				      &quot;#%&quot; PRIi32 &quot; : %s at 0x%8.8&quot; PRIx32 &quot;, size 0x%8.8&quot; PRIx32 &quot;, buswidth %i, chipwidth %i&quot;,
-				      i,
-				      p-&gt;driver-&gt;name,
-				      p-&gt;base,
-				      p-&gt;size,
-				      p-&gt;bus_width,
-				      p-&gt;chip_width);
-			for (j = 0; j &lt; p-&gt;num_sectors; j++)
-			{
-				char *protect_state;
-
-				if (p-&gt;sectors[j].is_protected == 0)
-					protect_state = &quot;not protected&quot;;
-				else if (p-&gt;sectors[j].is_protected == 1)
-					protect_state = &quot;protected&quot;;
-				else
-					protect_state = &quot;protection state unknown&quot;;
-
-				command_print(cmd_ctx,
-					      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
-					      j,
-					      p-&gt;sectors[j].offset,
-					      p-&gt;sectors[j].size,
-					      p-&gt;sectors[j].size &gt;&gt; 10,
-					      protect_state);
-			}
-
-			*buf = '\0'; /* initialize buffer, otherwise it migh contain garbage if driver function fails */
-			retval = p-&gt;driver-&gt;info(p, buf, sizeof(buf));
-			command_print(cmd_ctx, &quot;%s&quot;, buf);
-			if (retval != ERROR_OK)
-				LOG_ERROR(&quot;error retrieving flash info (%d)&quot;, retval);
+				      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
+				      j,
+				      p-&gt;sectors[j].offset,
+				      p-&gt;sectors[j].size,
+				      p-&gt;sectors[j].size &gt;&gt; 10,
+				      protect_state);
 		}
+
+		*buf = '\0'; /* initialize buffer, otherwise it migh contain garbage if driver function fails */
+		retval = p-&gt;driver-&gt;info(p, buf, sizeof(buf));
+		command_print(cmd_ctx, &quot;%s&quot;, buf);
+		if (retval != ERROR_OK)
+			LOG_ERROR(&quot;error retrieving flash info (%d)&quot;, retval);
 	}
 
 	return ERROR_OK;
@@ -463,38 +463,35 @@ static int handle_flash_erase_check_command(struct command_context_s *cmd_ctx, c
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (p)
+	int j;
+	if ((retval = p-&gt;driver-&gt;erase_check(p)) == ERROR_OK)
 	{
-		int j;
-		if ((retval = p-&gt;driver-&gt;erase_check(p)) == ERROR_OK)
-		{
-			command_print(cmd_ctx, &quot;successfully checked erase state&quot;);
-		}
-		else
-		{
-			command_print(cmd_ctx, &quot;unknown error when checking erase state of flash bank #%s at 0x%8.8&quot; PRIx32,
-				args[0], p-&gt;base);
-		}
+		command_print(cmd_ctx, &quot;successfully checked erase state&quot;);
+	}
+	else
+	{
+		command_print(cmd_ctx, &quot;unknown error when checking erase state of flash bank #%s at 0x%8.8&quot; PRIx32,
+			args[0], p-&gt;base);
+	}
 
-		for (j = 0; j &lt; p-&gt;num_sectors; j++)
-		{
-			char *erase_state;
+	for (j = 0; j &lt; p-&gt;num_sectors; j++)
+	{
+		char *erase_state;
 
-			if (p-&gt;sectors[j].is_erased == 0)
-				erase_state = &quot;not erased&quot;;
-			else if (p-&gt;sectors[j].is_erased == 1)
-				erase_state = &quot;erased&quot;;
-			else
-				erase_state = &quot;erase state unknown&quot;;
+		if (p-&gt;sectors[j].is_erased == 0)
+			erase_state = &quot;not erased&quot;;
+		else if (p-&gt;sectors[j].is_erased == 1)
+			erase_state = &quot;erased&quot;;
+		else
+			erase_state = &quot;erase state unknown&quot;;
 
-			command_print(cmd_ctx,
-				      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
-				      j,
-				      p-&gt;sectors[j].offset,
-				      p-&gt;sectors[j].size,
-				      p-&gt;sectors[j].size &gt;&gt; 10,
-				      erase_state);
-		}
+		command_print(cmd_ctx,
+			      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
+			      j,
+			      p-&gt;sectors[j].offset,
+			      p-&gt;sectors[j].size,
+			      p-&gt;sectors[j].size &gt;&gt; 10,
+			      erase_state);
 	}
 
 	return ERROR_OK;
@@ -556,21 +553,17 @@ static int handle_flash_protect_check_command(struct command_context_s *cmd_ctx,
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (p)
+	if ((retval = p-&gt;driver-&gt;protect_check(p)) == ERROR_OK)
 	{
-		int retval;
-		if ((retval = p-&gt;driver-&gt;protect_check(p)) == ERROR_OK)
-		{
-			command_print(cmd_ctx, &quot;successfully checked protect state&quot;);
-		}
-		else if (retval == ERROR_FLASH_OPERATION_FAILED)
-		{
-			command_print(cmd_ctx, &quot;checking protection state failed (possibly unsupported) by flash #%s at 0x%8.8&quot; PRIx32, args[0], p-&gt;base);
-		}
-		else
-		{
-			command_print(cmd_ctx, &quot;unknown error when checking protection state of flash bank '#%s' at 0x%8.8&quot; PRIx32, args[0], p-&gt;base);
-		}
+		command_print(cmd_ctx, &quot;successfully checked protect state&quot;);
+	}
+	else if (retval == ERROR_FLASH_OPERATION_FAILED)
+	{
+		command_print(cmd_ctx, &quot;checking protection state failed (possibly unsupported) by flash #%s at 0x%8.8&quot; PRIx32, args[0], p-&gt;base);
+	}
+	else
+	{
+		command_print(cmd_ctx, &quot;unknown error when checking protection state of flash bank '#%s' at 0x%8.8&quot; PRIx32, args[0], p-&gt;base);
 	}
 
 	return ERROR_OK;
@@ -597,45 +590,43 @@ static int flash_check_sector_parameters(struct command_context_s *cmd_ctx,
 static int handle_flash_erase_command(struct command_context_s *cmd_ctx,
 		char *cmd, char **args, int argc)
 {
-	if (argc &gt; 2)
-	{
-		uint32_t bank_nr;
-		uint32_t first;
-		uint32_t last;
-
-		COMMAND_PARSE_NUMBER(u32, args[0], bank_nr);
-		flash_bank_t *p = get_flash_bank_by_num(bank_nr);
-		if (!p)
-			return ERROR_OK;
-
-		COMMAND_PARSE_NUMBER(u32, args[1], first);
-		if (strcmp(args[2], &quot;last&quot;) == 0)
-			last = p-&gt;num_sectors - 1;
-		else
-			COMMAND_PARSE_NUMBER(u32, args[2], last);
+	if (argc != 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
-		int retval;
-		if ((retval = flash_check_sector_parameters(cmd_ctx,
-				first, last, p-&gt;num_sectors)) != ERROR_OK)
-			return retval;
+	uint32_t bank_nr;
+	uint32_t first;
+	uint32_t last;
 
-		duration_t duration;
-		char *duration_text;
-		duration_start_measure(&amp;duration);
+	COMMAND_PARSE_NUMBER(u32, args[0], bank_nr);
+	flash_bank_t *p = get_flash_bank_by_num(bank_nr);
+	if (!p)
+		return ERROR_OK;
 
-		if ((retval = flash_driver_erase(p, first, last)) == ERROR_OK) {
-			if ((retval = duration_stop_measure(&amp;duration,
-						&amp;duration_text)) != ERROR_OK)
-				return retval;
-			command_print(cmd_ctx, &quot;erased sectors %i through %i &quot;
-					&quot;on flash bank %i in %s&quot;,
-				(int) first, (int) last, (int) bank_nr,
-				duration_text);
-			free(duration_text);
-		}
-	}
+	COMMAND_PARSE_NUMBER(u32, args[1], first);
+	if (strcmp(args[2], &quot;last&quot;) == 0)
+		last = p-&gt;num_sectors - 1;
 	else
-		return ERROR_COMMAND_SYNTAX_ERROR;
+		COMMAND_PARSE_NUMBER(u32, args[2], last);
+
+	int retval;
+	if ((retval = flash_check_sector_parameters(cmd_ctx,
+			first, last, p-&gt;num_sectors)) != ERROR_OK)
+		return retval;
+
+	duration_t duration;
+	char *duration_text;
+	duration_start_measure(&amp;duration);
+
+	if ((retval = flash_driver_erase(p, first, last)) == ERROR_OK) {
+		if ((retval = duration_stop_measure(&amp;duration,
+					&amp;duration_text)) != ERROR_OK)
+			return retval;
+		command_print(cmd_ctx, &quot;erased sectors %i through %i &quot;
+				&quot;on flash bank %i in %s&quot;,
+			(int) first, (int) last, (int) bank_nr,
+			duration_text);
+		free(duration_text);
+	}
 
 	return ERROR_OK;
 }
@@ -643,47 +634,45 @@ static int handle_flash_erase_command(struct command_context_s *cmd_ctx,
 static int handle_flash_protect_command(struct command_context_s *cmd_ctx,
 		char *cmd, char **args, int argc)
 {
-	if (argc &gt; 3)
-	{
-		uint32_t bank_nr;
-		uint32_t first;
-		uint32_t last;
-		int set;
-
-		COMMAND_PARSE_NUMBER(u32, args[0], bank_nr);
-		flash_bank_t *p = get_flash_bank_by_num(bank_nr);
-		if (!p)
-			return ERROR_OK;
-
-		COMMAND_PARSE_NUMBER(u32, args[1], first);
-		if (strcmp(args[2], &quot;last&quot;) == 0)
-			last = p-&gt;num_sectors - 1;
-		else
-			COMMAND_PARSE_NUMBER(u32, args[2], last);
+	if (argc != 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
-		if (strcmp(args[3], &quot;on&quot;) == 0)
-			set = 1;
-		else if (strcmp(args[3], &quot;off&quot;) == 0)
-			set = 0;
-		else
-			return ERROR_COMMAND_SYNTAX_ERROR;
+	uint32_t bank_nr;
+	uint32_t first;
+	uint32_t last;
+	int set;
 
-		int retval;
-		if ((retval = flash_check_sector_parameters(cmd_ctx,
-				first, last, p-&gt;num_sectors)) != ERROR_OK)
-			return retval;
+	COMMAND_PARSE_NUMBER(u32, args[0], bank_nr);
+	flash_bank_t *p = get_flash_bank_by_num(bank_nr);
+	if (!p)
+		return ERROR_OK;
 
-		retval = flash_driver_protect(p, set, first, last);
-		if (retval == ERROR_OK) {
-			command_print(cmd_ctx, &quot;%s protection for sectors %i &quot;
-					&quot;through %i on flash bank %i&quot;,
-				(set) ? &quot;set&quot; : &quot;cleared&quot;, (int) first,
-				(int) last, (int) bank_nr);
-		}
-	}
+	COMMAND_PARSE_NUMBER(u32, args[1], first);
+	if (strcmp(args[2], &quot;last&quot;) == 0)
+		last = p-&gt;num_sectors - 1;
+	else
+		COMMAND_PARSE_NUMBER(u32, args[2], last);
+
+	if (strcmp(args[3], &quot;on&quot;) == 0)
+		set = 1;
+	else if (strcmp(args[3], &quot;off&quot;) == 0)
+		set = 0;
 	else
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
+	int retval;
+	if ((retval = flash_check_sector_parameters(cmd_ctx,
+			first, last, p-&gt;num_sectors)) != ERROR_OK)
+		return retval;
+
+	retval = flash_driver_protect(p, set, first, last);
+	if (retval == ERROR_OK) {
+		command_print(cmd_ctx, &quot;%s protection for sectors %i &quot;
+				&quot;through %i on flash bank %i&quot;,
+			(set) ? &quot;set&quot; : &quot;cleared&quot;, (int) first,
+			(int) last, (int) bank_nr);
+	}
+
 	return ERROR_OK;
 }
 

commit c5f56437c0be07201481ae2232d2c765cc1bc281
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Nov 6 00:16:39 2009 -0800

    Fix arm11 vcr command parsing.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 28ee723..9cb80f1 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -2065,6 +2065,7 @@ int arm11_handle_vcr(struct command_context_s *cmd_ctx, char *cmd, char **args,
 		break;
 	case 1:
 		COMMAND_PARSE_NUMBER(u32, args[0], arm11_vcr);
+		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/flash/flash.c  |  437 +++++++++++++++++++-------------------
 src/flash/nand.c   |  601 +++++++++++++++++++++++++---------------------------
 src/target/arm11.c |    1 +
 3 files changed, 501 insertions(+), 538 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001733.html">[openocd-svn] Main OpenOCD repository annotated tag, v0.1.0,	created. v0.1.0
</A></li>
	<LI>Next message: <A HREF="001735.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-92-gfb50efc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1734">[ date ]</a>
              <a href="thread.html#1734">[ thread ]</a>
              <a href="subject.html#1734">[ subject ]</a>
              <a href="author.html#1734">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
