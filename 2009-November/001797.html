<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-412-gdc1685c
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-412-gdc1685c&In-Reply-To=%3CE1NA5rM-0000Dc-6N%40cj8yhf1.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001796.html">
   <LINK REL="Next"  HREF="001798.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-412-gdc1685c</H1>
    <B>Zach Welch</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-412-gdc1685c&In-Reply-To=%3CE1NA5rM-0000Dc-6N%40cj8yhf1.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-412-gdc1685c">zwelch at users.sourceforge.net
       </A><BR>
    <I>Mon Nov 16 18:59:27 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001796.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-407-gcbc0578
</A></li>
        <LI>Next message: <A HREF="001798.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-413-g9a98e83
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1797">[ date ]</a>
              <a href="thread.html#1797">[ thread ]</a>
              <a href="subject.html#1797">[ subject ]</a>
              <a href="author.html#1797">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  dc1685ca25567fe75c8d50c825fb0303fbb66fac (commit)
       via  10cce4a5fe85bfd680bc338c900b0033d7174b6a (commit)
       via  0535a9245632e2cf12d8eaae8c4a9b1cc0bc66c6 (commit)
       via  a94748ec6da9bdc6e25a7f73bbea723b8b55fa33 (commit)
       via  f0ce88b3af9a6090ac986160950d66317de5087e (commit)
      from  cbc05783727122f0052fe6f3be40635eb73ec5bc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dc1685ca25567fe75c8d50c825fb0303fbb66fac
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 16 03:29:30 2009 -0800

    move ARRAY_SIZE macro to types.h
    
    The ARRAY_SIZE macro was defined in several target files, so move it
    to types.h.
    
    This patch also removes two other identical macros: DIM (from jtag.h)
    and asizeof (from arm11.h).

diff --git a/src/helper/types.h b/src/helper/types.h
index 8f6283b..96a923b 100644
--- a/src/helper/types.h
+++ b/src/helper/types.h
@@ -61,6 +61,16 @@ typedef bool _Bool;
 
 
 /**
+ * Compute the number of elements of a variable length array.
+ * &lt;code&gt;
+ * const char *strs[] = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; };
+ * unsigned num_strs = ARRAY_SIZE(strs);
+ * &lt;/code&gt;
+ */
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))
+
+
+/**
  * Cast a member of a structure out to the containing structure.
  * @param ptr The pointer to the member.
  * @param type The type of the container struct this is embedded in.
diff --git a/src/jtag/core.c b/src/jtag/core.c
index c8a76e8..ea723eb 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -586,7 +586,7 @@ int jtag_add_statemove(tap_state_t goal_state)
 		unsigned tms_bits  = tap_get_tms_path(cur_state, goal_state);
 		unsigned tms_count = tap_get_tms_path_len(cur_state, goal_state);
 		tap_state_t moves[8];
-		assert(tms_count &lt; DIM(moves));
+		assert(tms_count &lt; ARRAY_SIZE(moves));
 
 		for (unsigned i = 0; i &lt; tms_count; i++, tms_bits &gt;&gt;= 1)
 		{
diff --git a/src/jtag/interface.c b/src/jtag/interface.c
index f062414..1ed4512 100644
--- a/src/jtag/interface.c
+++ b/src/jtag/interface.c
@@ -363,7 +363,7 @@ const char *tap_state_name(tap_state_t state)
 {
 	unsigned i;
 
-	for (i = 0; i &lt; DIM(tap_name_mapping); i++) {
+	for (i = 0; i &lt; ARRAY_SIZE(tap_name_mapping); i++) {
 		if (tap_name_mapping[i].symbol == state)
 			return tap_name_mapping[i].name;
 	}
@@ -374,7 +374,7 @@ tap_state_t tap_state_by_name(const char *name)
 {
 	unsigned i;
 
-	for (i = 0; i &lt; DIM(tap_name_mapping); i++) {
+	for (i = 0; i &lt; ARRAY_SIZE(tap_name_mapping); i++) {
 		/* be nice to the human */
 		if (strcasecmp(name, tap_name_mapping[i].name) == 0)
 			return tap_name_mapping[i].symbol;
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index ee3ca32..d4fafa3 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -38,14 +38,6 @@
 #define DEBUG_JTAG_IOZ 64
 #endif
 
-/*-----&lt;Macros&gt;--------------------------------------------------*/
-
-/**
- * When given an array, compute its DIMension; in other words, the
- * number of elements in the array
- */
-#define DIM(x)					(sizeof(x)/sizeof((x)[0]))
-
 /*-----&lt;/Macros&gt;-------------------------------------------------*/
 
 /**
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 814f3f2..fb5e1b0 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -282,7 +282,7 @@ int svf_add_statemove(tap_state_t state_to)
 		return ERROR_OK;
 	}
 
-	for (index = 0; index &lt; DIM(svf_statemoves); index++)
+	for (index = 0; index &lt; ARRAY_SIZE(svf_statemoves); index++)
 	{
 		if ((svf_statemoves[index].from == state_from)
 			&amp;&amp; (svf_statemoves[index].to == state_to))
@@ -783,7 +783,7 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 	 */
 
 	command = svf_find_string_in_array(argus[0],
-			(char **)svf_command_name, DIM(svf_command_name));
+			(char **)svf_command_name, ARRAY_SIZE(svf_command_name));
 	switch (command)
 	{
 	case ENDDR:
@@ -1391,7 +1391,7 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			}
 			i_tmp = svf_find_string_in_array(argus[1],
 					(char **)svf_trst_mode_name,
-					DIM(svf_trst_mode_name));
+					ARRAY_SIZE(svf_trst_mode_name));
 			switch (i_tmp)
 			{
 			case TRST_ON:
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 46f332e..e4d2693 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -363,7 +363,7 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 	int retval;
 	FNC_INFO;
 
-	for (size_t i = 0; i &lt; asizeof(arm11-&gt;reg_values); i++)
+	for (size_t i = 0; i &lt; ARRAY_SIZE(arm11-&gt;reg_values); i++)
 	{
 		arm11-&gt;reg_list[i].valid	= 1;
 		arm11-&gt;reg_list[i].dirty	= 0;
@@ -386,7 +386,7 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 1);
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 	else
 	{
@@ -666,7 +666,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11)
 		arm11_setup_field(arm11,  1, &amp;Ready,	NULL, chain5_fields + 1);
 		arm11_setup_field(arm11,  1, &amp;Valid,	NULL, chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 
 	arm11_record_register_history(arm11);
@@ -877,7 +877,7 @@ static int arm11_resume(struct target *target, int current,
 			brp[1].address	= ARM11_SC7_BCR0 + brp_num;
 			brp[1].value	= 0x1 | (3 &lt;&lt; 1) | (0x0F &lt;&lt; 5) | (0 &lt;&lt; 14) | (0 &lt;&lt; 16) | (0 &lt;&lt; 20) | (0 &lt;&lt; 21);
 
-			arm11_sc7_run(arm11, brp, asizeof(brp));
+			arm11_sc7_run(arm11, brp, ARRAY_SIZE(brp));
 
 			LOG_DEBUG(&quot;Add BP &quot; ZU &quot; at %08&quot; PRIx32 &quot;&quot;, brp_num, bp-&gt;address);
 
@@ -1120,7 +1120,7 @@ static int arm11_step(struct target *target, int current,
 			brp[1].value	= 0x1 | (3 &lt;&lt; 1) | (0x0F &lt;&lt; 5) | (0 &lt;&lt; 14) | (0 &lt;&lt; 16) | (0 &lt;&lt; 20) | (0 &lt;&lt; 21);
 		}
 
-		CHECK_RETVAL(arm11_sc7_run(arm11, brp, asizeof(brp)));
+		CHECK_RETVAL(arm11_sc7_run(arm11, brp, ARRAY_SIZE(brp)));
 
 		/* resume */
 
@@ -1847,7 +1847,7 @@ static int arm11_examine(struct target *target)
 	arm11_setup_field(arm11, 32, NULL,	&amp;arm11-&gt;didr,		chain0_fields + 0);
 	arm11_setup_field(arm11,  8, NULL,	&amp;arm11-&gt;implementor,	chain0_fields + 1);
 
-	arm11_add_dr_scan_vc(asizeof(chain0_fields), chain0_fields, TAP_IDLE);
+	arm11_add_dr_scan_vc(ARRAY_SIZE(chain0_fields), chain0_fields, TAP_IDLE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
@@ -1975,11 +1975,11 @@ static int arm11_build_reg_cache(struct target *target)
 	size_t i;
 
 	/* Not very elegant assertion */
-	if (ARM11_REGCACHE_COUNT != asizeof(arm11-&gt;reg_values) ||
-		ARM11_REGCACHE_COUNT != asizeof(arm11_reg_defs) ||
+	if (ARM11_REGCACHE_COUNT != ARRAY_SIZE(arm11-&gt;reg_values) ||
+		ARM11_REGCACHE_COUNT != ARRAY_SIZE(arm11_reg_defs) ||
 		ARM11_REGCACHE_COUNT != ARM11_RC_MAX)
 	{
-		LOG_ERROR(&quot;BUG: arm11-&gt;reg_values inconsistent (%d &quot; ZU &quot; &quot; ZU &quot; %d)&quot;, ARM11_REGCACHE_COUNT, asizeof(arm11-&gt;reg_values), asizeof(arm11_reg_defs), ARM11_RC_MAX);
+		LOG_ERROR(&quot;BUG: arm11-&gt;reg_values inconsistent (%d &quot; ZU &quot; &quot; ZU &quot; %d)&quot;, ARM11_REGCACHE_COUNT, ARRAY_SIZE(arm11-&gt;reg_values), ARRAY_SIZE(arm11_reg_defs), ARM11_RC_MAX);
 		exit(-1);
 	}
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 9bc6eb4..809c23f 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -25,8 +25,6 @@
 
 #include &quot;armv4_5.h&quot;
 
-#define asizeof(x)	(sizeof(x) / sizeof((x)[0]))
-
 #define NEW(type, variable, items)			\
 	type * variable = calloc(1, sizeof(type) * items)
 
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index a95dcdd..7010eab 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -50,7 +50,7 @@ static const tap_state_t arm11_move_pi_to_si_via_ci[] =
 int arm11_add_ir_scan_vc(int num_fields, struct scan_field *fields, tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_IRPAUSE)
-		jtag_add_pathmove(asizeof(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
+		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
 	jtag_add_ir_scan(num_fields, fields, state);
 	return ERROR_OK;
@@ -64,7 +64,7 @@ static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
 int arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields, tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_DRPAUSE)
-		jtag_add_pathmove(asizeof(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
+		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
 
 	jtag_add_dr_scan(num_fields, fields, state);
 	return ERROR_OK;
@@ -209,7 +209,7 @@ void arm11_add_debug_INST(struct arm11_common * arm11, uint32_t inst, uint8_t *
 	arm11_setup_field(arm11, 32,    &amp;inst,	NULL, itr + 0);
 	arm11_setup_field(arm11, 1,	    NULL,	flag, itr + 1);
 
-	arm11_add_dr_scan_vc(asizeof(itr), itr, state == ARM11_TAP_DEFAULT ? TAP_IDLE : state);
+	arm11_add_dr_scan_vc(ARRAY_SIZE(itr), itr, state == ARM11_TAP_DEFAULT ? TAP_IDLE : state);
 }
 
 /** Read the Debug Status and Control Register (DSCR)
@@ -470,7 +470,7 @@ int arm11_run_instr_data_to_core(struct arm11_common * arm11, uint32_t opcode, u
 		{
 			Data	    = *data;
 
-			arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
+			arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
 
 			CHECK_RETVAL(jtag_execute_queue());
 
@@ -505,7 +505,7 @@ int arm11_run_instr_data_to_core(struct arm11_common * arm11, uint32_t opcode, u
 	{
 		Data	    = 0;
 
-		arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 		CHECK_RETVAL(jtag_execute_queue());
 
@@ -605,13 +605,13 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opc
 
 		if (count)
 		{
-			jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, jtag_set_end_state(TAP_DRPAUSE));
-			jtag_add_pathmove(asizeof(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
+			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_DRPAUSE));
+			jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
 				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
 		}
 		else
 		{
-			jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
 		}
 	}
 
@@ -620,7 +620,7 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opc
 	chain5_fields[0].out_value	= 0;
 	chain5_fields[1].in_value   = ReadyPos++;
 
-	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 	int retval = jtag_execute_queue();
 	if (retval == ERROR_OK)
@@ -699,7 +699,7 @@ int arm11_run_instr_data_from_core(struct arm11_common * arm11, uint32_t opcode,
 		int i = 0;
 		do
 		{
-			arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
+			arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
 
@@ -833,7 +833,7 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 		{
 			JTAG_DEBUG(&quot;SC7 &lt;= Address %02x  Data %08x    nRW %d&quot;, AddressOut, DataOut, nRW);
 
-			arm11_add_dr_scan_vc(asizeof(chain7_fields), chain7_fields, TAP_DRPAUSE);
+			arm11_add_dr_scan_vc(ARRAY_SIZE(chain7_fields), chain7_fields, TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
 
@@ -880,7 +880,7 @@ void arm11_sc7_clear_vbw(struct arm11_common * arm11)
 	struct arm11_sc7_action		clear_bw[arm11-&gt;brp + arm11-&gt;wrp + 1];
 	struct arm11_sc7_action *	pos = clear_bw;
 
-	for (size_t i = 0; i &lt; asizeof(clear_bw); i++)
+	for (size_t i = 0; i &lt; ARRAY_SIZE(clear_bw); i++)
 	{
 		clear_bw[i].write	= true;
 		clear_bw[i].value	= 0;
@@ -896,7 +896,7 @@ void arm11_sc7_clear_vbw(struct arm11_common * arm11)
 
 	(pos++)-&gt;address = ARM11_SC7_VCR;
 
-	arm11_sc7_run(arm11, clear_bw, asizeof(clear_bw));
+	arm11_sc7_run(arm11, clear_bw, ARRAY_SIZE(clear_bw));
 }
 
 /** Write VCR register
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 884f8f6..9fa1ac0 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -759,7 +759,7 @@ int arm_checksum_memory(struct target *target,
 		return retval;
 
 	/* convert code into a buffer in target endianness */
-	for (i = 0; i &lt; DIM(arm_crc_code); i++) {
+	for (i = 0; i &lt; ARRAY_SIZE(arm_crc_code); i++) {
 		retval = target_write_u32(target,
 				crc_algorithm-&gt;address + i * sizeof(uint32_t),
 				arm_crc_code[i]);
@@ -835,7 +835,7 @@ int arm_blank_check_memory(struct target *target,
 		return retval;
 
 	/* convert code into a buffer in target endianness */
-	for (i = 0; i &lt; DIM(check_code); i++) {
+	for (i = 0; i &lt; ARRAY_SIZE(check_code); i++) {
 		retval = target_write_u32(target,
 				check_algorithm-&gt;address
 						+ i * sizeof(uint32_t),
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index f6127e8..132b786 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -40,8 +40,6 @@
 #include &quot;algorithm.h&quot;
 #include &quot;register.h&quot;
 
-#define ARRAY_SIZE(x)	((int)(sizeof(x)/sizeof((x)[0])))
-
 
 #if 0
 #define _DEBUG_INSTRUCTION_EXECUTION_
@@ -389,7 +387,6 @@ int armv7m_run_algorithm(struct target *target,
 	struct armv7m_algorithm *armv7m_algorithm_info = arch_info;
 	enum armv7m_mode core_mode = armv7m-&gt;core_mode;
 	int retval = ERROR_OK;
-	int i;
 	uint32_t context[ARMV7M_NUM_REGS];
 
 	if (armv7m_algorithm_info-&gt;common_magic != ARMV7M_COMMON_MAGIC)
@@ -406,20 +403,20 @@ int armv7m_run_algorithm(struct target *target,
 
 	/* refresh core register cache */
 	/* Not needed if core register cache is always consistent with target process state */
-	for (i = 0; i &lt; ARMV7M_NUM_REGS; i++)
+	for (unsigned i = 0; i &lt; ARMV7M_NUM_REGS; i++)
 	{
 		if (!armv7m-&gt;core_cache-&gt;reg_list[i].valid)
 			armv7m-&gt;read_core_reg(target, i);
 		context[i] = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[i].value, 0, 32);
 	}
 
-	for (i = 0; i &lt; num_mem_params; i++)
+	for (int i = 0; i &lt; num_mem_params; i++)
 	{
 		if ((retval = target_write_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
 			return retval;
 	}
 
-	for (i = 0; i &lt; num_reg_params; i++)
+	for (int i = 0; i &lt; num_reg_params; i++)
 	{
 		struct reg *reg = register_get_by_name(armv7m-&gt;core_cache, reg_params[i].reg_name, 0);
 //		uint32_t regvalue;
@@ -471,7 +468,7 @@ int armv7m_run_algorithm(struct target *target,
 	}
 
 	/* Read memory values to mem_params[] */
-	for (i = 0; i &lt; num_mem_params; i++)
+	for (int i = 0; i &lt; num_mem_params; i++)
 	{
 		if (mem_params[i].direction != PARAM_OUT)
 			if ((retval = target_read_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
@@ -481,7 +478,7 @@ int armv7m_run_algorithm(struct target *target,
 	}
 
 	/* Copy core register values to reg_params[] */
-	for (i = 0; i &lt; num_reg_params; i++)
+	for (int i = 0; i &lt; num_reg_params; i++)
 	{
 		if (reg_params[i].direction != PARAM_OUT)
 		{
@@ -503,7 +500,7 @@ int armv7m_run_algorithm(struct target *target,
 		}
 	}
 
-	for (i = ARMV7M_NUM_REGS - 1; i &gt;= 0; i--)
+	for (int i = ARMV7M_NUM_REGS - 1; i &gt;= 0; i--)
 	{
 		uint32_t regvalue;
 		regvalue = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[i].value, 0, 32);
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index e4949d2..e99e99c 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -43,8 +43,6 @@
  * Cortex-M0 cores too, although they're ARMv6-M not ARMv7-M.
  */
 
-#define ARRAY_SIZE(x)	((int)(sizeof(x)/sizeof((x)[0])))
-
 
 /* forward declarations */
 static int cortex_m3_set_breakpoint(struct target *target, struct breakpoint *breakpoint);
@@ -1843,8 +1841,6 @@ COMMAND_HANDLER(handle_cortex_m3_vector_catch_command)
 	struct swjdp_common *swjdp = &amp;armv7m-&gt;swjdp_info;
 	uint32_t demcr = 0;
 	int retval;
-	int i;
-
 	retval = cortex_m3_verify_pointer(cmd_ctx, cortex_m3);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1865,6 +1861,7 @@ COMMAND_HANDLER(handle_cortex_m3_vector_catch_command)
 			}
 		}
 		while (argc-- &gt; 0) {
+			unsigned i;
 			for (i = 0; i &lt; ARRAY_SIZE(vec_ids); i++) {
 				if (strcmp(args[argc], vec_ids[i].name) != 0)
 					continue;
@@ -1885,7 +1882,7 @@ write:
 		mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &amp;demcr);
 	}
 
-	for (i = 0; i &lt; ARRAY_SIZE(vec_ids); i++)
+	for (unsigned i = 0; i &lt; ARRAY_SIZE(vec_ids); i++)
 		command_print(cmd_ctx, &quot;%9s: %s&quot;, vec_ids[i].name,
 			(demcr &amp; vec_ids[i].mask) ? &quot;catch&quot; : &quot;ignore&quot;);
 
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 4a7cf12..2e9f1c0 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -30,8 +30,6 @@
 #include &quot;embeddedice.h&quot;
 #include &quot;register.h&quot;
 
-#define ARRAY_SIZE(x)	((int)(sizeof(x)/sizeof((x)[0])))
-
 /**
  * @file
  *
diff --git a/src/target/etm.c b/src/target/etm.c
index e70df10..936c9e6 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -50,8 +50,6 @@
  *  ARM IHI 0014O ... Embedded Trace Macrocell, Architecture Specification
  */
 
-#define ARRAY_SIZE(x)	((int)(sizeof(x)/sizeof((x)[0])))
-
 enum {
 	RO,				/* read/only */
 	WO,				/* write/only */
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 2e78447..01a9411 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -470,7 +470,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 							TAP_IDLE,
 						};
 
-						jtag_add_pathmove(DIM(exception_path), exception_path);
+						jtag_add_pathmove(ARRAY_SIZE(exception_path), exception_path);
 
 						if (verbose)
 							LOG_USER(&quot;%s mismatch, xsdrsize=%d retry=%d&quot;, op_name, xsdrsize, attempt);

commit 10cce4a5fe85bfd680bc338c900b0033d7174b6a
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 16 03:33:22 2009 -0800

    armv7m: make core reg read/write use unsigned
    
    Eliminate redundant check that gets covered by using unsigned type.
    Created to eliminate noise from subsequent patches, but this kind of
    conversion will be beneficial in similar ways throughout the tree.

diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index d8718f9..f6127e8 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -236,14 +236,14 @@ static int armv7m_set_core_reg(struct reg *reg, uint8_t *buf)
 	return ERROR_OK;
 }
 
-static int armv7m_read_core_reg(struct target *target, int num)
+static int armv7m_read_core_reg(struct target *target, unsigned num)
 {
 	uint32_t reg_value;
 	int retval;
 	struct armv7m_core_reg * armv7m_core_reg;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 
-	if ((num &lt; 0) || (num &gt;= ARMV7M_NUM_REGS))
+	if (num &gt;= ARMV7M_NUM_REGS)
 		return ERROR_INVALID_ARGUMENTS;
 
 	armv7m_core_reg = armv7m-&gt;core_cache-&gt;reg_list[num].arch_info;
@@ -255,14 +255,14 @@ static int armv7m_read_core_reg(struct target *target, int num)
 	return retval;
 }
 
-static int armv7m_write_core_reg(struct target *target, int num)
+static int armv7m_write_core_reg(struct target *target, unsigned num)
 {
 	int retval;
 	uint32_t reg_value;
 	struct armv7m_core_reg *armv7m_core_reg;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 
-	if ((num &lt; 0) || (num &gt;= ARMV7M_NUM_REGS))
+	if (num &gt;= ARMV7M_NUM_REGS)
 		return ERROR_INVALID_ARGUMENTS;
 
 	reg_value = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[num].value, 0, 32);
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 7f8190b..dba9a3b 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -103,8 +103,8 @@ struct armv7m_common
 	int (*load_core_reg_u32)(struct target *target, enum armv7m_regtype type, uint32_t num, uint32_t *value);
 	int (*store_core_reg_u32)(struct target *target, enum armv7m_regtype type, uint32_t num, uint32_t value);
 	/* register cache to processor synchronization */
-	int (*read_core_reg)(struct target *target, int num);
-	int (*write_core_reg)(struct target *target, int num);
+	int (*read_core_reg)(struct target *target, unsigned num);
+	int (*write_core_reg)(struct target *target, unsigned num);
 
 	int (*examine_debug_reason)(struct target *target);
 	void (*post_debug_entry)(struct target *target);

commit 0535a9245632e2cf12d8eaae8c4a9b1cc0bc66c6
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 16 03:12:45 2009 -0800

    remove TAP_SCAN_BYTES macro
    
    Use DIV_ROUND_UP(n, 8) instead of TAP_SCAN_BYTES macro.

diff --git a/src/jtag/interface.c b/src/jtag/interface.c
index e475b48..f062414 100644
--- a/src/jtag/interface.c
+++ b/src/jtag/interface.c
@@ -413,7 +413,7 @@ tap_state_t jtag_debug_state_machine(const void *tms_buf, const void *tdi_buf,
 	tms_buffer = (const uint8_t *)tms_buf;
 	tdi_buffer = (const uint8_t *)tdi_buf;
 
-	tap_bytes = TAP_SCAN_BYTES(tap_bits);
+	tap_bytes = DIV_ROUND_UP(tap_bits, 8);
 	DEBUG_JTAG_IO(&quot;TAP/SM: TMS bits: %u (bytes: %u)&quot;, tap_bits, tap_bytes);
 
 	tap_out_bits = 0;
diff --git a/src/jtag/jlink.c b/src/jtag/jlink.c
index 2422135..23ebc62 100644
--- a/src/jtag/jlink.c
+++ b/src/jtag/jlink.c
@@ -763,15 +763,16 @@ static int jlink_tap_execute(void)
 	if (!tap_length)
 		return ERROR_OK;
 
-	/* JLink returns an extra NULL in packet when size of in message is a multiple of 64, creates problems with usb comms */
-	/* WARNING This will interfere with tap state counting */
-	while ((TAP_SCAN_BYTES(tap_length)%64) == 0)
+	/* JLink returns an extra NULL in packet when size of incoming
+	 * message is a multiple of 64, creates problems with USB comms.
+	 * WARNING: This will interfere with tap state counting. */
+	while ((DIV_ROUND_UP(tap_length, 8) % 64) == 0)
 	{
 		jlink_tap_append_step((tap_get_state() == TAP_RESET)?1:0, 0);
 	}
 
 	// number of full bytes (plus one if some would be left over)
-	byte_length = TAP_SCAN_BYTES(tap_length);
+	byte_length = DIV_ROUND_UP(tap_length, 8);
 
 	bool use_jtag3 = jlink_hw_jtag_version &gt;= 3;
 	usb_out_buffer[0] = use_jtag3 ? EMU_CMD_HW_JTAG3 : EMU_CMD_HW_JTAG2;
@@ -808,7 +809,7 @@ static int jlink_tap_execute(void)
 		DEBUG_JTAG_IO(&quot;pending scan result, length = %d&quot;, length);
 
 #ifdef _DEBUG_USB_COMMS_
-		jlink_debug_buffer(buffer, TAP_SCAN_BYTES(length));
+		jlink_debug_buffer(buffer, DIV_ROUND_UP(length, 8));
 #endif
 
 		if (jtag_read_buffer(buffer, command) != ERROR_OK)
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 5328ff8..ee3ca32 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -46,9 +46,6 @@
  */
 #define DIM(x)					(sizeof(x)/sizeof((x)[0]))
 
-/** Calculate the number of bytes required to hold @a n TAP scan bits */
-#define TAP_SCAN_BYTES(n)		DIV_ROUND_UP(n, 8)
-
 /*-----&lt;/Macros&gt;-------------------------------------------------*/
 
 /**
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 49931b7..392a190 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -58,7 +58,7 @@ static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
 	/* We're executing this synchronously, so try to use local storage. */
 	if (field-&gt;num_bits &gt; 32)
 	{
-		unsigned num_bytes = TAP_SCAN_BYTES(field-&gt;num_bits);
+		unsigned num_bytes = DIV_ROUND_UP(field-&gt;num_bits, 8);
 		field-&gt;in_value = (uint8_t *)malloc(num_bytes);
 		field-&gt;allocated = 1;
 	}
@@ -77,7 +77,7 @@ static inline void interface_jtag_alloc_in_value32(struct scan_field *field)
 
 static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
 {
-	unsigned num_bytes = TAP_SCAN_BYTES(field-&gt;num_bits);
+	unsigned num_bytes = DIV_ROUND_UP(field-&gt;num_bits, 8);
 	field-&gt;in_value = (uint8_t *)cmd_queue_alloc(num_bytes);
 }
 

commit a94748ec6da9bdc6e25a7f73bbea723b8b55fa33
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 16 02:53:57 2009 -0800

    rename CEIL as DIV_ROUND_UP
    
    Improves the name of this macro, moves it to types.h, and adds a block
    of Doxygen comments to describe what it does.

diff --git a/src/flash/at91sam7.c b/src/flash/at91sam7.c
index e0b83d5..9d05d7b 100644
--- a/src/flash/at91sam7.c
+++ b/src/flash/at91sam7.c
@@ -979,7 +979,7 @@ static int at91sam7_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 		return ERROR_FLASH_BANK_NOT_PROBED;
 
 	first_page = offset/dst_min_alignment;
-	last_page = CEIL(offset + count, dst_min_alignment);
+	last_page = DIV_ROUND_UP(offset + count, dst_min_alignment);
 
 	LOG_DEBUG(&quot;first_page: %i, last_page: %i, count %i&quot;, (int)first_page, (int)last_page, (int)count);
 
@@ -997,7 +997,7 @@ static int at91sam7_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 
 		/* Write one block to the PageWriteBuffer */
 		buffer_pos = (pagen-first_page)*dst_min_alignment;
-		wcount = CEIL(count,4);
+		wcount = DIV_ROUND_UP(count,4);
 		if ((retval = target_write_memory(target, bank-&gt;base + pagen*dst_min_alignment, 4, wcount, buffer + buffer_pos)) != ERROR_OK)
 		{
 			return retval;
diff --git a/src/flash/lpc2000.c b/src/flash/lpc2000.c
index 79f5804..a3f9718 100644
--- a/src/flash/lpc2000.c
+++ b/src/flash/lpc2000.c
@@ -573,7 +573,7 @@ static int lpc2000_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offs
 	{
 		if (offset &gt;= bank-&gt;sectors[i].offset)
 			first_sector = i;
-		if (offset + CEIL(count, dst_min_alignment) * dst_min_alignment &gt; bank-&gt;sectors[i].offset)
+		if (offset + DIV_ROUND_UP(count, dst_min_alignment) * dst_min_alignment &gt; bank-&gt;sectors[i].offset)
 			last_sector = i;
 	}
 
diff --git a/src/flash/str9xpec.c b/src/flash/str9xpec.c
index 4bf5bca..7f6d8be 100644
--- a/src/flash/str9xpec.c
+++ b/src/flash/str9xpec.c
@@ -44,7 +44,7 @@ int str9xpec_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end
 
 		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
-		field.out_value = calloc(CEIL(field.num_bits, 8), 1);
+		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
@@ -289,7 +289,7 @@ static int str9xpec_blank_check(struct flash_bank *bank, int first, int last)
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
-	buffer = calloc(CEIL(64, 8), 1);
+	buffer = calloc(DIV_ROUND_UP(64, 8), 1);
 
 	LOG_DEBUG(&quot;blank check: first_bank: %i, last_bank: %i&quot;, first, last);
 
@@ -378,7 +378,7 @@ static int str9xpec_erase_area(struct flash_bank *bank, int first, int last)
 		return ISC_STATUS_ERROR;
 	}
 
-	buffer = calloc(CEIL(64, 8), 1);
+	buffer = calloc(DIV_ROUND_UP(64, 8), 1);
 
 	LOG_DEBUG(&quot;erase: first_bank: %i, last_bank: %i&quot;, first, last);
 
@@ -618,7 +618,7 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 
 	LOG_DEBUG(&quot;first_sector: %i, last_sector: %i&quot;, first_sector, last_sector);
 
-	scanbuf = calloc(CEIL(64, 8), 1);
+	scanbuf = calloc(DIV_ROUND_UP(64, 8), 1);
 
 	LOG_DEBUG(&quot;ISC_PROGRAM&quot;);
 
@@ -745,7 +745,7 @@ COMMAND_HANDLER(str9xpec_handle_part_id_command)
 	str9xpec_info = bank-&gt;driver_priv;
 	tap = str9xpec_info-&gt;tap;
 
-	buffer = calloc(CEIL(32, 8), 1);
+	buffer = calloc(DIV_ROUND_UP(32, 8), 1);
 
 	str9xpec_set_instr(tap, ISC_IDCODE, TAP_IRPAUSE);
 
diff --git a/src/helper/binarybuffer.c b/src/helper/binarybuffer.c
index 53ad4d3..081cc03 100644
--- a/src/helper/binarybuffer.c
+++ b/src/helper/binarybuffer.c
@@ -54,7 +54,7 @@ void* buf_cpy(const void *from, void *_to, unsigned size)
 		return NULL;
 
 	// copy entire buffer
-	memcpy(_to, from, CEIL(size, 8));
+	memcpy(_to, from, DIV_ROUND_UP(size, 8));
 
 	/* mask out bits that don't belong to the buffer */
 	unsigned trailing_bits = size % 8;
@@ -191,11 +191,11 @@ char* buf_to_str(const void *_buf, unsigned buf_len, unsigned radix)
 		return NULL;
 	}
 
-	unsigned str_len = ceil_f_to_u32(CEIL(buf_len, 8) * factor);
+	unsigned str_len = ceil_f_to_u32(DIV_ROUND_UP(buf_len, 8) * factor);
 	char *str = calloc(str_len + 1, 1);
 
 	const uint8_t *buf = _buf;
-	int b256_len = CEIL(buf_len, 8);
+	int b256_len = DIV_ROUND_UP(buf_len, 8);
 	for (int i = b256_len - 1; i &gt;= 0; i--)
 	{
 		uint32_t tmp = buf[i];
@@ -300,7 +300,7 @@ int str_to_buf(const char *str, unsigned str_len,
 	}
 
 	uint8_t *buf = _buf;
-	for (unsigned j = 0; j &lt; CEIL(buf_len, 8); j++)
+	for (unsigned j = 0; j &lt; DIV_ROUND_UP(buf_len, 8); j++)
 	{
 		if (j &lt; b256_len)
 			buf[j] = b256_buf[j];
diff --git a/src/helper/binarybuffer.h b/src/helper/binarybuffer.h
index 9e0cc9b..460d017 100644
--- a/src/helper/binarybuffer.h
+++ b/src/helper/binarybuffer.h
@@ -124,8 +124,6 @@ int str_to_buf(const char *str, unsigned len,
 		void *bin_buf, unsigned buf_size, unsigned radix);
 char* buf_to_str(const void *buf, unsigned size, unsigned radix);
 
-#define CEIL(m, n)	(((m) + (n) - 1) / (n))
-
 /* read a uint32_t from a buffer in target memory endianness */
 static inline uint32_t fast_target_buffer_get_u32(const void *p, bool le)
 {
diff --git a/src/helper/types.h b/src/helper/types.h
index a8753c5..8f6283b 100644
--- a/src/helper/types.h
+++ b/src/helper/types.h
@@ -73,6 +73,15 @@ typedef bool _Bool;
 	(type *)( (char *)__mptr - offsetof(type,member) );})
 
 
+/**
+ * Rounds @c m up to the nearest multiple of @c n using division.
+ * @params m The value to round up to @c n.
+ * @params n Round @c m up to a multiple of this number.
+ * @returns The rounded integer value.
+ */
+#define DIV_ROUND_UP(m, n)	(((m) + (n) - 1) / (n))
+
+
 /* DANGER!!!! here be dragons!
  *
  * Leave these fn's as byte accesses because it is safe
diff --git a/src/jtag/commands.c b/src/jtag/commands.c
index ccd6d0f..4e8ce40 100644
--- a/src/jtag/commands.c
+++ b/src/jtag/commands.c
@@ -179,7 +179,7 @@ int jtag_build_buffer(const struct scan_command *cmd, uint8_t **buffer)
 	int i;
 
 	bit_count = jtag_scan_size(cmd);
-	*buffer = calloc(1,CEIL(bit_count, 8));
+	*buffer = calloc(1,DIV_ROUND_UP(bit_count, 8));
 
 	bit_count = 0;
 
@@ -235,7 +235,7 @@ int jtag_read_buffer(uint8_t *buffer, const struct scan_command *cmd)
 		if (cmd-&gt;fields[i].in_value)
 		{
 			int num_bits = cmd-&gt;fields[i].num_bits;
-			uint8_t *captured = buf_set_buf(buffer, bit_count, malloc(CEIL(num_bits, 8)), 0, num_bits);
+			uint8_t *captured = buf_set_buf(buffer, bit_count, malloc(DIV_ROUND_UP(num_bits, 8)), 0, num_bits);
 
 #ifdef _DEBUG_JTAG_IO_
 			char *char_buf = buf_to_str(captured,
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 1841dde..c8a76e8 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1193,7 +1193,7 @@ static int jtag_validate_ircapture(void)
 	/* increase length to add 2 bit sentinel after scan */
 	total_ir_length += 2;
 
-	ir_test = malloc(CEIL(total_ir_length, 8));
+	ir_test = malloc(DIV_ROUND_UP(total_ir_length, 8));
 	if (ir_test == NULL)
 		return ERROR_FAIL;
 
@@ -1293,7 +1293,7 @@ void jtag_tap_init(struct jtag_tap *tap)
 
 	/* if we're autoprobing, cope with potentially huge ir_length */
 	ir_len_bits = tap-&gt;ir_length ? : JTAG_IRLEN_MAX;
-	ir_len_bytes = CEIL(ir_len_bits, 8);
+	ir_len_bytes = DIV_ROUND_UP(ir_len_bits, 8);
 
 	tap-&gt;expected = calloc(1, ir_len_bytes);
 	tap-&gt;expected_mask = calloc(1, ir_len_bytes);
diff --git a/src/jtag/driver.c b/src/jtag/driver.c
index 6469358..cadd88e 100644
--- a/src/jtag/driver.c
+++ b/src/jtag/driver.c
@@ -64,7 +64,7 @@ static void cmd_queue_scan_field_clone(struct scan_field * dst, const struct sca
 {
 	dst-&gt;tap		= src-&gt;tap;
 	dst-&gt;num_bits	= src-&gt;num_bits;
-	dst-&gt;out_value	= buf_cpy(src-&gt;out_value, cmd_queue_alloc(CEIL(src-&gt;num_bits, 8)), src-&gt;num_bits);
+	dst-&gt;out_value	= buf_cpy(src-&gt;out_value, cmd_queue_alloc(DIV_ROUND_UP(src-&gt;num_bits, 8)), src-&gt;num_bits);
 	dst-&gt;in_value	= src-&gt;in_value;
 }
 
@@ -128,7 +128,7 @@ int interface_jtag_add_ir_scan(int in_num_fields, const struct scan_field *in_fi
 
 			field-&gt;tap			= tap;
 			field-&gt;num_bits		= tap-&gt;ir_length;
-			field-&gt;out_value	= buf_set_ones(cmd_queue_alloc(CEIL(tap-&gt;ir_length, 8)), tap-&gt;ir_length);
+			field-&gt;out_value	= buf_set_ones(cmd_queue_alloc(DIV_ROUND_UP(tap-&gt;ir_length, 8)), tap-&gt;ir_length);
 			field-&gt;in_value		= NULL; /* do not collect input for tap's in bypass */
 		}
 
@@ -317,7 +317,7 @@ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 
 				field-&gt;tap			= tap;
 				field-&gt;num_bits		= scan_size;
-				field-&gt;out_value	= buf_cpy(out_value, cmd_queue_alloc(CEIL(scan_size, 8)), scan_size);
+				field-&gt;out_value	= buf_cpy(out_value, cmd_queue_alloc(DIV_ROUND_UP(scan_size, 8)), scan_size);
 				field-&gt;in_value		= NULL;
 
 				field++;
diff --git a/src/jtag/ft2232.c b/src/jtag/ft2232.c
index cee55e0..7acdf1a 100644
--- a/src/jtag/ft2232.c
+++ b/src/jtag/ft2232.c
@@ -721,7 +721,7 @@ static int ft2232_send_and_recv(struct jtag_command* first, struct jtag_command*
 			if (type != SCAN_OUT)
 			{
 				scan_size = jtag_scan_size(cmd-&gt;cmd.scan);
-				buffer    = calloc(CEIL(scan_size, 8), 1);
+				buffer    = calloc(DIV_ROUND_UP(scan_size, 8), 1);
 				ft2232_read_scan(type, buffer, scan_size);
 				if (jtag_read_buffer(buffer, cmd-&gt;cmd.scan) != ERROR_OK)
 					retval = ERROR_JTAG_QUEUE_FAILED;
@@ -962,7 +962,7 @@ static int ft2232_large_scan(struct scan_command* cmd, enum scan_type type, uint
 	int bits_left = scan_size;
 	int cur_byte  = 0;
 	int last_bit;
-	uint8_t* receive_buffer  = malloc(CEIL(scan_size, 8));
+	uint8_t* receive_buffer  = malloc(DIV_ROUND_UP(scan_size, 8));
 	uint8_t* receive_pointer = receive_buffer;
 	uint32_t bytes_written;
 	uint32_t bytes_read;
@@ -1182,7 +1182,7 @@ static int ft2232_predict_scan_out(int scan_size, enum scan_type type)
 	if (type == SCAN_IN)	/* only from device to host */
 	{
 		/* complete bytes */
-		predicted_size += CEIL(num_bytes, 65536) * 3;
+		predicted_size += DIV_ROUND_UP(num_bytes, 65536) * 3;
 
 		/* remaining bits - 1 (up to 7) */
 		predicted_size += ((scan_size - 1) % 8) ? 2 : 0;
@@ -1190,7 +1190,7 @@ static int ft2232_predict_scan_out(int scan_size, enum scan_type type)
 	else	/* host to device, or bidirectional */
 	{
 		/* complete bytes */
-		predicted_size += num_bytes + CEIL(num_bytes, 65536) * 3;
+		predicted_size += num_bytes + DIV_ROUND_UP(num_bytes, 65536) * 3;
 
 		/* remaining bits -1 (up to 7) */
 		predicted_size += ((scan_size - 1) % 8) ? 3 : 0;
@@ -1206,7 +1206,7 @@ static int ft2232_predict_scan_in(int scan_size, enum scan_type type)
 	if (type != SCAN_OUT)
 	{
 		/* complete bytes */
-		predicted_size += (CEIL(scan_size, 8) &gt; 1) ? (CEIL(scan_size, 8) - 1) : 0;
+		predicted_size += (DIV_ROUND_UP(scan_size, 8) &gt; 1) ? (DIV_ROUND_UP(scan_size, 8) - 1) : 0;
 
 		/* remaining bits - 1 */
 		predicted_size += ((scan_size - 1) % 8) ? 1 : 0;
@@ -1506,7 +1506,7 @@ static int ft2232_execute_runtest(struct jtag_command *cmd)
 	predicted_size = 0;
 	if (tap_get_state() != TAP_IDLE)
 		predicted_size += 3;
-	predicted_size += 3 * CEIL(cmd-&gt;cmd.runtest-&gt;num_cycles, 7);
+	predicted_size += 3 * DIV_ROUND_UP(cmd-&gt;cmd.runtest-&gt;num_cycles, 7);
 	if (cmd-&gt;cmd.runtest-&gt;end_state != TAP_IDLE)
 		predicted_size += 3;
 	if (tap_get_end_state() != TAP_IDLE)
@@ -1605,7 +1605,7 @@ static int ft2232_execute_pathmove(struct jtag_command *cmd)
 			tap_state_name(path[num_states-1]));
 
 	/* only send the maximum buffer size that FT2232C can handle */
-	predicted_size = 3 * CEIL(num_states, 7);
+	predicted_size = 3 * DIV_ROUND_UP(num_states, 7);
 	if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
 	{
 		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 30d62fd..5328ff8 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -47,7 +47,7 @@
 #define DIM(x)					(sizeof(x)/sizeof((x)[0]))
 
 /** Calculate the number of bytes required to hold @a n TAP scan bits */
-#define TAP_SCAN_BYTES(n)		CEIL(n, 8)
+#define TAP_SCAN_BYTES(n)		DIV_ROUND_UP(n, 8)
 
 /*-----&lt;/Macros&gt;-------------------------------------------------*/
 
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 75732ef..71e7bd5 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1129,7 +1129,7 @@ COMMAND_HANDLER(handle_irscan_command)
 		int field_size = tap-&gt;ir_length;
 		fields[i].tap = tap;
 		fields[i].num_bits = field_size;
-		fields[i].out_value = malloc(CEIL(field_size, 8));
+		fields[i].out_value = malloc(DIV_ROUND_UP(field_size, 8));
 
 		uint32_t value;
 		retval = parse_u32(args[i * 2 + 1], &amp;value);
@@ -1257,7 +1257,7 @@ static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args
 
 		fields[field_count].tap = tap;
 		fields[field_count].num_bits = bits;
-		fields[field_count].out_value = malloc(CEIL(bits, 8));
+		fields[field_count].out_value = malloc(DIV_ROUND_UP(bits, 8));
 		str_to_buf(str, len, fields[field_count].out_value, bits, 0);
 		fields[field_count].in_value = fields[field_count].out_value;
 		field_count++;
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index ea9ee0c..c07931e 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -37,7 +37,7 @@ static int virtex2_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 
 		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
-		field.out_value = calloc(CEIL(field.num_bits, 8), 1);
+		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index f6b44cd..55ec7d4 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -871,7 +871,7 @@ void gdb_str_to_target(struct target *target, char *tstr, struct reg *reg)
 	uint8_t *buf;
 	int buf_len;
 	buf = reg-&gt;value;
-	buf_len = CEIL(reg-&gt;size, 8);
+	buf_len = DIV_ROUND_UP(reg-&gt;size, 8);
 
 	for (i = 0; i &lt; buf_len; i++)
 	{
@@ -940,25 +940,25 @@ int gdb_get_registers_packet(struct connection *connection, struct target *targe
 		reg_packet_size += reg_list[i]-&gt;size;
 	}
 
-	reg_packet = malloc(CEIL(reg_packet_size, 8) * 2);
+	reg_packet = malloc(DIV_ROUND_UP(reg_packet_size, 8) * 2);
 	reg_packet_p = reg_packet;
 
 	for (i = 0; i &lt; reg_list_size; i++)
 	{
 		gdb_str_to_target(target, reg_packet_p, reg_list[i]);
-		reg_packet_p += CEIL(reg_list[i]-&gt;size, 8) * 2;
+		reg_packet_p += DIV_ROUND_UP(reg_list[i]-&gt;size, 8) * 2;
 	}
 
 #ifdef _DEBUG_GDB_IO_
 	{
 		char *reg_packet_p;
-		reg_packet_p = strndup(reg_packet, CEIL(reg_packet_size, 8) * 2);
+		reg_packet_p = strndup(reg_packet, DIV_ROUND_UP(reg_packet_size, 8) * 2);
 		LOG_DEBUG(&quot;reg_packet: %s&quot;, reg_packet_p);
 		free(reg_packet_p);
 	}
 #endif
 
-	gdb_put_packet(connection, reg_packet, CEIL(reg_packet_size, 8) * 2);
+	gdb_put_packet(connection, reg_packet, DIV_ROUND_UP(reg_packet_size, 8) * 2);
 	free(reg_packet);
 
 	free(reg_list);
@@ -997,7 +997,7 @@ int gdb_set_registers_packet(struct connection *connection, struct target *targe
 	for (i = 0; i &lt; reg_list_size; i++)
 	{
 		uint8_t *bin_buf;
-		int chars = (CEIL(reg_list[i]-&gt;size, 8) * 2);
+		int chars = (DIV_ROUND_UP(reg_list[i]-&gt;size, 8) * 2);
 
 		if (packet_p + chars &gt; packet + packet_size)
 		{
@@ -1005,7 +1005,7 @@ int gdb_set_registers_packet(struct connection *connection, struct target *targe
 		}
 
 		struct reg_arch_type *arch_type;
-		bin_buf = malloc(CEIL(reg_list[i]-&gt;size, 8));
+		bin_buf = malloc(DIV_ROUND_UP(reg_list[i]-&gt;size, 8));
 		gdb_target_to_reg(target, packet_p, chars, bin_buf);
 
 		/* get register arch_type, and call set method */
@@ -1051,11 +1051,11 @@ int gdb_get_register_packet(struct connection *connection, struct target *target
 		exit(-1);
 	}
 
-	reg_packet = malloc(CEIL(reg_list[reg_num]-&gt;size, 8) * 2);
+	reg_packet = malloc(DIV_ROUND_UP(reg_list[reg_num]-&gt;size, 8) * 2);
 
 	gdb_str_to_target(target, reg_packet, reg_list[reg_num]);
 
-	gdb_put_packet(connection, reg_packet, CEIL(reg_list[reg_num]-&gt;size, 8) * 2);
+	gdb_put_packet(connection, reg_packet, DIV_ROUND_UP(reg_list[reg_num]-&gt;size, 8) * 2);
 
 	free(reg_list);
 	free(reg_packet);
@@ -1093,8 +1093,8 @@ int gdb_set_register_packet(struct connection *connection, struct target *target
 	}
 
 	/* convert from GDB-string (target-endian) to hex-string (big-endian) */
-	bin_buf = malloc(CEIL(reg_list[reg_num]-&gt;size, 8));
-	int chars = (CEIL(reg_list[reg_num]-&gt;size, 8) * 2);
+	bin_buf = malloc(DIV_ROUND_UP(reg_list[reg_num]-&gt;size, 8));
+	int chars = (DIV_ROUND_UP(reg_list[reg_num]-&gt;size, 8) * 2);
 
 	/* fix!!! add some sanity checks on packet size here */
 
diff --git a/src/target/algorithm.c b/src/target/algorithm.c
index 7643e3c..76cf48b 100644
--- a/src/target/algorithm.c
+++ b/src/target/algorithm.c
@@ -43,7 +43,7 @@ void init_reg_param(struct reg_param *param, char *reg_name, uint32_t size, enum
 {
 	param-&gt;reg_name = reg_name;
 	param-&gt;size = size;
-	param-&gt;value = malloc(CEIL(size, 8));
+	param-&gt;value = malloc(DIV_ROUND_UP(size, 8));
 	param-&gt;direction = direction;
 }
 
diff --git a/src/target/etb.c b/src/target/etb.c
index 72474cd..21c375c 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -57,7 +57,7 @@ static int etb_set_instr(struct etb *etb, uint32_t new_instr)
 
 		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
-		field.out_value = calloc(CEIL(field.num_bits, 8), 1);
+		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
 		field.in_value = NULL;
@@ -78,7 +78,7 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 
 		field.tap = etb-&gt;tap;
 		field.num_bits = 5;
-		field.out_value = calloc(CEIL(field.num_bits, 8), 1);
+		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_scan_chain);
 
 		field.in_value = NULL;
diff --git a/src/target/target.c b/src/target/target.c
index f5a092a..c24085f 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1967,7 +1967,7 @@ COMMAND_HANDLER(handle_reg_command)
 	/* set register value */
 	if (argc == 2)
 	{
-		uint8_t *buf = malloc(CEIL(reg-&gt;size, 8));
+		uint8_t *buf = malloc(DIV_ROUND_UP(reg-&gt;size, 8));
 		str_to_buf(args[1], strlen(args[1]), buf, reg-&gt;size, 0);
 
 		struct reg_arch_type *arch_type = register_get_arch_type(reg-&gt;arch_type);
diff --git a/src/target/target_request.c b/src/target/target_request.c
index 7215155..be176ca 100644
--- a/src/target/target_request.c
+++ b/src/target/target_request.c
@@ -40,10 +40,10 @@ static int charmsg_mode = 0;
 
 static int target_asciimsg(struct target *target, uint32_t length)
 {
-	char *msg = malloc(CEIL(length + 1, 4) * 4);
+	char *msg = malloc(DIV_ROUND_UP(length + 1, 4) * 4);
 	struct debug_msg_receiver *c = target-&gt;dbgmsg;
 
-	target-&gt;type-&gt;target_request_data(target, CEIL(length, 4), (uint8_t*)msg);
+	target-&gt;type-&gt;target_request_data(target, DIV_ROUND_UP(length, 4), (uint8_t*)msg);
 	msg[length] = 0;
 
 	LOG_DEBUG(&quot;%s&quot;, msg);
@@ -66,7 +66,7 @@ static int target_charmsg(struct target *target, uint8_t msg)
 
 static int target_hexmsg(struct target *target, int size, uint32_t length)
 {
-	uint8_t *data = malloc(CEIL(length * size, 4) * 4);
+	uint8_t *data = malloc(DIV_ROUND_UP(length * size, 4) * 4);
 	char line[128];
 	int line_len;
 	struct debug_msg_receiver *c = target-&gt;dbgmsg;
@@ -74,7 +74,7 @@ static int target_hexmsg(struct target *target, int size, uint32_t length)
 
 	LOG_DEBUG(&quot;size: %i, length: %i&quot;, (int)size, (int)length);
 
-	target-&gt;type-&gt;target_request_data(target, CEIL(length * size, 4), (uint8_t*)data);
+	target-&gt;type-&gt;target_request_data(target, DIV_ROUND_UP(length * size, 4), (uint8_t*)data);
 
 	line_len = 0;
 	for (i = 0; i &lt; length; i++)
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 3fe2c0f..2e78447 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -479,7 +479,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					field.tap = tap;
 					field.num_bits = xsdrsize;
 					field.out_value = dr_out_buf;
-					field.in_value = calloc(CEIL(field.num_bits, 8), 1);
+					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 
 					if (tap == NULL)
 						jtag_add_plain_dr_scan(1, &amp;field, jtag_set_end_state(TAP_DRPAUSE));
@@ -933,7 +933,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					field.tap = tap;
 					field.num_bits = xsdrsize;
 					field.out_value = dr_out_buf;
-					field.in_value = calloc(CEIL(field.num_bits, 8), 1);
+					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 
 					if (attempt &gt; 0 &amp;&amp; verbose)
 						LOG_USER(&quot;LSDR retry %d&quot;, attempt);

commit f0ce88b3af9a6090ac986160950d66317de5087e
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 16 02:29:09 2009 -0800

    move container_of to types.h
    
    The container_of macro is useful as a general solution.  It belongs
    in types.h, rather than target.h where it was introduced.  Requires
    the offsetof macro, which comes from &lt;stddef.h&gt; (moved as well).

diff --git a/src/helper/types.h b/src/helper/types.h
index 79eac13..a8753c5 100644
--- a/src/helper/types.h
+++ b/src/helper/types.h
@@ -23,6 +23,7 @@
 #ifndef TYPES_H
 #define TYPES_H
 
+#include &lt;stddef.h&gt;
 #ifdef HAVE_SYS_TYPES_H
 #include &lt;sys/types.h&gt;
 #endif
@@ -58,6 +59,20 @@ typedef bool _Bool;
 #define stringify(s) __stringify(s)
 #define __stringify(s) #s
 
+
+/**
+ * Cast a member of a structure out to the containing structure.
+ * @param ptr The pointer to the member.
+ * @param type The type of the container struct this is embedded in.
+ * @param member The name of the member within the struct.
+ *
+ * This is a mechanism which is used throughout the Linux kernel.
+ */
+#define container_of(ptr, type, member) ({			\
+	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\
+	(type *)( (char *)__mptr - offsetof(type,member) );})
+
+
 /* DANGER!!!! here be dragons!
  *
  * Leave these fn's as byte accesses because it is safe
diff --git a/src/target/target.h b/src/target/target.h
index 51fb299..ee40209 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -26,7 +26,6 @@
 #ifndef TARGET_H
 #define TARGET_H
 
-#include &lt;stddef.h&gt;
 #include &quot;types.h&quot;
 #include &quot;jim.h&quot;
 
@@ -39,18 +38,6 @@ struct mem_param;
 struct reg_param;
 
 
-/**
- * Cast a member of a structure out to the containing structure.
- * @param ptr The pointer to the member.
- * @param type The type of the container struct this is embedded in.
- * @param member The name of the member within the struct.
- *
- * This is a mechanism which is used throughout the Linux kernel.
- */
-#define container_of(ptr, type, member) ({			\
-	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\
-	(type *)( (char *)__mptr - offsetof(type,member) );})
-
 /*
  * TARGET_UNKNOWN = 0: we don't know anything about the target yet
  * TARGET_RUNNING = 1: the target is executing user code

-----------------------------------------------------------------------

Summary of changes:
 src/flash/at91sam7.c        |    4 ++--
 src/flash/lpc2000.c         |    2 +-
 src/flash/str9xpec.c        |   10 +++++-----
 src/helper/binarybuffer.c   |    8 ++++----
 src/helper/binarybuffer.h   |    2 --
 src/helper/types.h          |   34 ++++++++++++++++++++++++++++++++++
 src/jtag/commands.c         |    4 ++--
 src/jtag/core.c             |    6 +++---
 src/jtag/driver.c           |    6 +++---
 src/jtag/ft2232.c           |   14 +++++++-------
 src/jtag/interface.c        |    6 +++---
 src/jtag/jlink.c            |   11 ++++++-----
 src/jtag/jtag.h             |   11 -----------
 src/jtag/minidriver.h       |    4 ++--
 src/jtag/tcl.c              |    4 ++--
 src/pld/virtex2.c           |    2 +-
 src/server/gdb_server.c     |   22 +++++++++++-----------
 src/svf/svf.c               |    6 +++---
 src/target/algorithm.c      |    2 +-
 src/target/arm11.c          |   18 +++++++++---------
 src/target/arm11.h          |    2 --
 src/target/arm11_dbgtap.c   |   26 +++++++++++++-------------
 src/target/armv4_5.c        |    4 ++--
 src/target/armv7m.c         |   23 ++++++++++-------------
 src/target/armv7m.h         |    4 ++--
 src/target/cortex_m3.c      |    7 ++-----
 src/target/embeddedice.c    |    2 --
 src/target/etb.c            |    4 ++--
 src/target/etm.c            |    2 --
 src/target/target.c         |    2 +-
 src/target/target.h         |   13 -------------
 src/target/target_request.c |    8 ++++----
 src/xsvf/xsvf.c             |    6 +++---
 33 files changed, 138 insertions(+), 141 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001796.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-407-gcbc0578
</A></li>
	<LI>Next message: <A HREF="001798.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-413-g9a98e83
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1797">[ date ]</a>
              <a href="thread.html#1797">[ thread ]</a>
              <a href="subject.html#1797">[ subject ]</a>
              <a href="author.html#1797">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
