<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-107-g3885ab5
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-107-g3885ab5&In-Reply-To=%3CE1N7YJf-0001Gs-Fs%40fxgxhf1.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001744.html">
   <LINK REL="Next"  HREF="001746.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-107-g3885ab5</H1>
    <B>Zach Welch</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-107-g3885ab5&In-Reply-To=%3CE1N7YJf-0001Gs-Fs%40fxgxhf1.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-107-g3885ab5">zwelch at users.sourceforge.net
       </A><BR>
    <I>Mon Nov  9 18:46:10 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001744.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-101-g4882647
</A></li>
        <LI>Next message: <A HREF="001746.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-108-g9253ce9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1745">[ date ]</a>
              <a href="thread.html#1745">[ thread ]</a>
              <a href="subject.html#1745">[ subject ]</a>
              <a href="author.html#1745">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  3885ab5a5af7ece410ce3eeb1059da3ea950436a (commit)
       via  42cafc9369088d2a5d5f633358a2a42aa7bbc0de (commit)
       via  994a63c3fee11b8c65891ead6b03b2b716044541 (commit)
       via  81fbc637185fb0007dbe84c866794800851295b5 (commit)
       via  5e9d18f027954c5f5e883934d6c54cb20817ea9f (commit)
       via  1712d7835e0fbba60d578b52b21b95b046805757 (commit)
      from  4882647f3ee7fc0680c49fbd27a484359fd7e86a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3885ab5a5af7ece410ce3eeb1059da3ea950436a
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 9 04:22:23 2009 -0800

    src/target: remove 'extern' and wrap headers
    
    Remove extern keywords from function prototypes and wrap long lines.

diff --git a/src/target/algorithm.h b/src/target/algorithm.h
index 15e3cf2..600580c 100644
--- a/src/target/algorithm.h
+++ b/src/target/algorithm.h
@@ -45,9 +45,12 @@ typedef struct reg_param_s
 	enum param_direction direction;
 } reg_param_t;
 
-extern void init_mem_param(mem_param_t *param, uint32_t address, uint32_t size, enum param_direction direction);
-extern void destroy_mem_param(mem_param_t *param);
-extern void init_reg_param(reg_param_t *param, char *reg_name, uint32_t size, enum param_direction direction);
-extern void destroy_reg_param(reg_param_t *param);
+void init_mem_param(mem_param_t *param,
+		uint32_t address, uint32_t size, enum param_direction dir);
+void destroy_mem_param(mem_param_t *param);
+
+void init_reg_param(reg_param_t *param,
+		char *reg_name, uint32_t size, enum param_direction dir);
+void destroy_reg_param(reg_param_t *param);
 
 #endif /* ALGORITHM_H */
diff --git a/src/target/arm926ejs.h b/src/target/arm926ejs.h
index 01e3c09..0712c53 100644
--- a/src/target/arm926ejs.h
+++ b/src/target/arm926ejs.h
@@ -46,10 +46,12 @@ target_to_arm926(struct target_s *target)
 }
 
 
-extern int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap);
-extern int arm926ejs_register_commands(struct command_context_s *cmd_ctx);
-extern int arm926ejs_arch_state(struct target_s *target);
-extern int arm926ejs_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-extern int arm926ejs_soft_reset_halt(struct target_s *target);
+int arm926ejs_init_arch_info(target_t *target,
+		arm926ejs_common_t *arm926ejs, jtag_tap_t *tap);
+int arm926ejs_register_commands(struct command_context_s *cmd_ctx);
+int arm926ejs_arch_state(struct target_s *target);
+int arm926ejs_write_memory(struct target_s *target,
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int arm926ejs_soft_reset_halt(struct target_s *target);
 
 #endif /* ARM926EJS_H */
diff --git a/src/target/arm966e.h b/src/target/arm966e.h
index e8346f9..8d0ee50 100644
--- a/src/target/arm966e.h
+++ b/src/target/arm966e.h
@@ -41,8 +41,9 @@ target_to_arm966(struct target_s *target)
 			arm9tdmi_common.arm7_9_common.armv4_5_common);
 }
 
-extern int arm966e_init_arch_info(target_t *target, arm966e_common_t *arm966e, jtag_tap_t *tap);
-extern int arm966e_register_commands(struct command_context_s *cmd_ctx);
-extern int arm966e_write_cp15(target_t *target, int reg_addr, uint32_t value);
+int arm966e_init_arch_info(target_t *target,
+		arm966e_common_t *arm966e, jtag_tap_t *tap);
+int arm966e_register_commands(struct command_context_s *cmd_ctx);
+int arm966e_write_cp15(target_t *target, int reg_addr, uint32_t value);
 
 #endif /* ARM966E_H */
diff --git a/src/target/arm9tdmi.h b/src/target/arm9tdmi.h
index 8bf2713..c098d82 100644
--- a/src/target/arm9tdmi.h
+++ b/src/target/arm9tdmi.h
@@ -51,34 +51,34 @@ enum arm9tdmi_vector
 	ARM9TDMI_FIQ_VECTOR = 0x80,
 };
 
-extern int arm9tdmi_init_target(struct command_context_s *cmd_ctx,
-	struct target_s *target);
+int arm9tdmi_init_target(struct command_context_s *cmd_ctx,
+		struct target_s *target);
 int arm9tdmi_examine(struct target_s *target);
-extern int arm9tdmi_init_arch_info(target_t *target,
-	arm9tdmi_common_t *arm9tdmi, jtag_tap_t *tap);
-extern int arm9tdmi_register_commands(struct command_context_s *cmd_ctx);
+int arm9tdmi_init_arch_info(target_t *target,
+		arm9tdmi_common_t *arm9tdmi, jtag_tap_t *tap);
+int arm9tdmi_register_commands(struct command_context_s *cmd_ctx);
 
-extern int arm9tdmi_clock_out(arm_jtag_t *jtag_info,
-	uint32_t instr, uint32_t out, uint32_t *in, int sysspeed);
-extern int arm9tdmi_clock_data_in(arm_jtag_t *jtag_info, uint32_t *in);
-extern int arm9tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info,
-	void *in, int size, int be);
-extern void arm9tdmi_read_core_regs(target_t *target,
-	uint32_t mask, uint32_t* core_regs[16]);
-extern void arm9tdmi_write_core_regs(target_t *target,
-	uint32_t mask, uint32_t core_regs[16]);
+int arm9tdmi_clock_out(arm_jtag_t *jtag_info,
+		uint32_t instr, uint32_t out, uint32_t *in, int sysspeed);
+int arm9tdmi_clock_data_in(arm_jtag_t *jtag_info, uint32_t *in);
+int arm9tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info,
+		void *in, int size, int be);
+void arm9tdmi_read_core_regs(target_t *target,
+		uint32_t mask, uint32_t* core_regs[16]);
+void arm9tdmi_write_core_regs(target_t *target,
+		uint32_t mask, uint32_t core_regs[16]);
 
-extern int arm9tdmi_examine_debug_reason(target_t *target);
+int arm9tdmi_examine_debug_reason(target_t *target);
 
-extern void arm9tdmi_load_word_regs(target_t *target, uint32_t mask);
-extern void arm9tdmi_load_hword_reg(target_t *target, int num);
-extern void arm9tdmi_load_byte_reg(target_t *target, int num);
-extern void arm9tdmi_store_word_regs(target_t *target, uint32_t mask);
-extern void arm9tdmi_store_hword_reg(target_t *target, int num);
-extern void arm9tdmi_store_byte_reg(target_t *target, int num);
+void arm9tdmi_load_word_regs(target_t *target, uint32_t mask);
+void arm9tdmi_load_hword_reg(target_t *target, int num);
+void arm9tdmi_load_byte_reg(target_t *target, int num);
+void arm9tdmi_store_word_regs(target_t *target, uint32_t mask);
+void arm9tdmi_store_hword_reg(target_t *target, int num);
+void arm9tdmi_store_byte_reg(target_t *target, int num);
 
-extern void arm9tdmi_branch_resume(target_t *target);
-extern void arm9tdmi_enable_single_step(target_t *target, uint32_t next_pc);
-extern void arm9tdmi_disable_single_step(target_t *target);
+void arm9tdmi_branch_resume(target_t *target);
+void arm9tdmi_enable_single_step(target_t *target, uint32_t next_pc);
+void arm9tdmi_disable_single_step(target_t *target);
 
 #endif /* ARM9TDMI_H */
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 3ff883a..442b45c 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -111,39 +111,48 @@ static inline uint8_t dap_ap_get_select(swjdp_common_t *swjdp)
 }
 
 /* Internal functions used in the module, partial transactions, use with caution */
-extern int dap_dp_write_reg(swjdp_common_t *swjdp, uint32_t value, uint8_t reg_addr);
-/* extern int swjdp_write_apacc(swjdp_common_t *swjdp, uint32_t value, uint8_t reg_addr); */
-extern int dap_dp_read_reg(swjdp_common_t *swjdp, uint32_t *value, uint8_t reg_addr);
-/* extern int swjdp_read_apacc(swjdp_common_t *swjdp, uint32_t *value, uint8_t reg_addr); */
-extern int dap_setup_accessport(swjdp_common_t *swjdp, uint32_t csw, uint32_t tar);
-extern int dap_ap_select(swjdp_common_t *swjdp,uint8_t apsel);
-
-extern int dap_ap_write_reg(swjdp_common_t *swjdp, uint32_t reg_addr, uint8_t* out_value_buf);
-extern int dap_ap_write_reg_u32(swjdp_common_t *swjdp, uint32_t reg_addr, uint32_t value);
-extern int dap_ap_read_reg(swjdp_common_t *swjdp, uint32_t reg_addr, uint8_t *in_value_buf);
-extern int dap_ap_read_reg_u32(swjdp_common_t *swjdp, uint32_t reg_addr, uint32_t *value);
+int dap_dp_write_reg(swjdp_common_t *swjdp, uint32_t value, uint8_t reg_addr);
+/* int swjdp_write_apacc(swjdp_common_t *swjdp, uint32_t value, uint8_t reg_addr); */
+int dap_dp_read_reg(swjdp_common_t *swjdp, uint32_t *value, uint8_t reg_addr);
+/* int swjdp_read_apacc(swjdp_common_t *swjdp, uint32_t *value, uint8_t reg_addr); */
+int dap_setup_accessport(swjdp_common_t *swjdp, uint32_t csw, uint32_t tar);
+int dap_ap_select(swjdp_common_t *swjdp,uint8_t apsel);
+
+int dap_ap_write_reg(swjdp_common_t *swjdp, uint32_t addr, uint8_t* out_buf);
+int dap_ap_write_reg_u32(swjdp_common_t *swjdp, uint32_t addr, uint32_t value);
+int dap_ap_read_reg(swjdp_common_t *swjdp, uint32_t addr, uint8_t *in_buf);
+int dap_ap_read_reg_u32(swjdp_common_t *swjdp, uint32_t addr, uint32_t *value);
 
 /* External interface, partial operations must be completed with swjdp_transaction_endcheck() */
-extern int swjdp_transaction_endcheck(swjdp_common_t *swjdp);
+int swjdp_transaction_endcheck(swjdp_common_t *swjdp);
 
 /* MEM-AP memory mapped bus single uint32_t register transfers, without endcheck */
-extern int mem_ap_read_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value);
-extern int mem_ap_write_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value);
+int mem_ap_read_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value);
+int mem_ap_write_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value);
 
 /* MEM-AP memory mapped bus transfers, single registers, complete transactions */
-extern int mem_ap_read_atomic_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value);
-extern int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value);
+int mem_ap_read_atomic_u32(swjdp_common_t *swjdp,
+		uint32_t address, uint32_t *value);
+int mem_ap_write_atomic_u32(swjdp_common_t *swjdp,
+		uint32_t address, uint32_t value);
 
 /* MEM-AP memory mapped bus block transfers */
-extern int mem_ap_read_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
-extern int mem_ap_read_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
-extern int mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
-extern int mem_ap_write_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
-extern int mem_ap_write_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
-extern int mem_ap_write_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
+int mem_ap_read_buf_u8(swjdp_common_t *swjdp,
+		uint8_t *buffer, int count, uint32_t address);
+int mem_ap_read_buf_u16(swjdp_common_t *swjdp,
+		uint8_t *buffer, int count, uint32_t address);
+int mem_ap_read_buf_u32(swjdp_common_t *swjdp,
+		uint8_t *buffer, int count, uint32_t address);
+
+int mem_ap_write_buf_u8(swjdp_common_t *swjdp,
+		uint8_t *buffer, int count, uint32_t address);
+int mem_ap_write_buf_u16(swjdp_common_t *swjdp,
+		uint8_t *buffer, int count, uint32_t address);
+int mem_ap_write_buf_u32(swjdp_common_t *swjdp,
+		uint8_t *buffer, int count, uint32_t address);
 
 /* Initialisation of the debug system, power domains and registers */
-extern int ahbap_debugport_init(swjdp_common_t *swjdp);
+int ahbap_debugport_init(swjdp_common_t *swjdp);
 
 
 /* Commands for user dap access */
diff --git a/src/target/arm_disassembler.h b/src/target/arm_disassembler.h
index b841d6c..8021e7c 100644
--- a/src/target/arm_disassembler.h
+++ b/src/target/arm_disassembler.h
@@ -197,11 +197,13 @@ typedef struct arm_instruction_s
 
 } arm_instruction_t;
 
-extern int arm_evaluate_opcode(uint32_t opcode, uint32_t address, arm_instruction_t *instruction);
-extern int thumb_evaluate_opcode(uint16_t opcode, uint32_t address, arm_instruction_t *instruction);
-extern int thumb2_opcode(target_t *target, uint32_t address,
+int arm_evaluate_opcode(uint32_t opcode, uint32_t address,
 		arm_instruction_t *instruction);
-extern int arm_access_size(arm_instruction_t *instruction);
+int thumb_evaluate_opcode(uint16_t opcode, uint32_t address,
+		arm_instruction_t *instruction);
+int thumb2_opcode(target_t *target, uint32_t address,
+		arm_instruction_t *instruction);
+int arm_access_size(arm_instruction_t *instruction);
 
 #define COND(opcode) (arm_condition_strings[(opcode &amp; 0xf0000000) &gt;&gt; 28])
 
diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
index f4b04e8..c7d12cb 100644
--- a/src/target/arm_jtag.h
+++ b/src/target/arm_jtag.h
@@ -36,9 +36,10 @@ typedef struct arm_jtag_s
 	uint32_t intest_instr;
 } arm_jtag_t;
 
-extern int arm_jtag_set_instr(arm_jtag_t *jtag_info, uint32_t new_instr, void *verify_capture);
-extern int arm_jtag_scann(arm_jtag_t *jtag_info, uint32_t new_scan_chain);
-extern int arm_jtag_setup_connection(arm_jtag_t *jtag_info);
+int arm_jtag_set_instr(arm_jtag_t *jtag_info,
+		uint32_t new_instr, void *verify_capture);
+int arm_jtag_scann(arm_jtag_t *jtag_info, uint32_t new_scan_chain);
+int arm_jtag_setup_connection(arm_jtag_t *jtag_info);
 
 /* JTAG buffers to host, be and le buffers, flipping variants */
 int arm_jtag_buf_to_u32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field);
diff --git a/src/target/arm_simulator.h b/src/target/arm_simulator.h
index bad904b..9e7b040 100644
--- a/src/target/arm_simulator.h
+++ b/src/target/arm_simulator.h
@@ -37,12 +37,11 @@ struct arm_sim_interface
 	enum armv4_5_mode (*get_mode)(struct arm_sim_interface *sim);
 };
 
-
 /* armv4_5 version */
-extern int arm_simulate_step(struct target_s *target, uint32_t *dry_run_pc);
+int arm_simulate_step(struct target_s *target, uint32_t *dry_run_pc);
 
 /* a generic arm simulator. Caller must implement the sim interface */
-extern int arm_simulate_step_core(target_t *target, uint32_t *dry_run_pc, struct arm_sim_interface *sim);
-
+int arm_simulate_step_core(target_t *target,
+		uint32_t *dry_run_pc, struct arm_sim_interface *sim);
 
 #endif /* ARM_SIMULATOR_H */
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index fb7926b..d76ce75 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -108,7 +108,8 @@ typedef struct armv4_5_core_reg_s
 	armv4_5_common_t *armv4_5_common;
 } armv4_5_core_reg_t;
 
-extern reg_cache_t* armv4_5_build_reg_cache(target_t *target, armv4_5_common_t *armv4_5_common);
+reg_cache_t* armv4_5_build_reg_cache(target_t *target,
+		armv4_5_common_t *armv4_5_common);
 
 /* map psr mode bits to linear number */
 static __inline int armv4_5_mode_to_number(enum armv4_5_mode mode)
@@ -147,15 +148,20 @@ static __inline enum armv4_5_mode armv4_5_number_to_mode(int number)
 	}
 };
 
-extern int armv4_5_arch_state(struct target_s *target);
-extern int armv4_5_get_gdb_reg_list(target_t *target, reg_t **reg_list[], int *reg_list_size);
+int armv4_5_arch_state(struct target_s *target);
+int armv4_5_get_gdb_reg_list(target_t *target,
+		reg_t **reg_list[], int *reg_list_size);
 
-extern int armv4_5_register_commands(struct command_context_s *cmd_ctx);
-extern int armv4_5_init_arch_info(target_t *target, armv4_5_common_t *armv4_5);
+int armv4_5_register_commands(struct command_context_s *cmd_ctx);
+int armv4_5_init_arch_info(target_t *target, armv4_5_common_t *armv4_5);
 
-extern int armv4_5_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
+int armv4_5_run_algorithm(struct target_s *target,
+		int num_mem_params, mem_param_t *mem_params,
+		int num_reg_params, reg_param_t *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		int timeout_ms, void *arch_info);
 
-extern int armv4_5_invalidate_core_regs(target_t *target);
+int armv4_5_invalidate_core_regs(target_t *target);
 
 /* ARM mode instructions
  */
diff --git a/src/target/armv4_5_cache.h b/src/target/armv4_5_cache.h
index 44bc212..71e3203 100644
--- a/src/target/armv4_5_cache.h
+++ b/src/target/armv4_5_cache.h
@@ -42,10 +42,13 @@ typedef struct armv4_5_cache_common_s
 	int d_u_cache_enabled;
 } armv4_5_cache_common_t;
 
-extern int armv4_5_identify_cache(uint32_t cache_type_reg, armv4_5_cache_common_t *cache);
-extern int armv4_5_cache_state(uint32_t cp15_control_reg, armv4_5_cache_common_t *cache);
+int armv4_5_identify_cache(uint32_t cache_type_reg,
+		armv4_5_cache_common_t *cache);
+int armv4_5_cache_state(uint32_t cp15_control_reg,
+		armv4_5_cache_common_t *cache);
 
-extern int armv4_5_handle_cache_info_command(struct command_context_s *cmd_ctx, armv4_5_cache_common_t *armv4_5_cache);
+int armv4_5_handle_cache_info_command(struct command_context_s *cmd_ctx,
+		armv4_5_cache_common_t *armv4_5_cache);
 
 enum
 {
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 0c9b550..b0c39a7 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -42,9 +42,17 @@ enum
 
 extern char* armv4_5_page_type_names[];
 
-extern uint32_t armv4_5_mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t va, int *type, uint32_t *cb, int *domain, uint32_t *ap);
-extern int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-extern int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+uint32_t armv4_5_mmu_translate_va(target_t *target,
+		armv4_5_mmu_common_t *armv4_5_mmu, uint32_t va, int *type,
+		uint32_t *cb, int *domain, uint32_t *ap);
+
+int armv4_5_mmu_read_physical(target_t *target,
+		armv4_5_mmu_common_t *armv4_5_mmu,
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+
+int armv4_5_mmu_write_physical(target_t *target,
+		armv4_5_mmu_common_t *armv4_5_mmu,
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 enum
 {
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 217f0e3..7601685 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -50,7 +50,7 @@ enum armv7m_regtype
 	ARMV7M_REGISTER_MEMMAP
 };
 
-extern char *armv7m_exception_string(int number);
+char *armv7m_exception_string(int number);
 
 /* offsets into armv7m core register cache */
 enum
@@ -134,24 +134,31 @@ typedef struct armv7m_core_reg_s
 	armv7m_common_t *armv7m_common;
 } armv7m_core_reg_t;
 
-extern reg_cache_t *armv7m_build_reg_cache(target_t *target);
-extern enum armv7m_mode armv7m_number_to_mode(int number);
-extern int armv7m_mode_to_number(enum armv7m_mode mode);
+reg_cache_t *armv7m_build_reg_cache(target_t *target);
+enum armv7m_mode armv7m_number_to_mode(int number);
+int armv7m_mode_to_number(enum armv7m_mode mode);
 
-extern int armv7m_arch_state(struct target_s *target);
-extern int armv7m_get_gdb_reg_list(target_t *target, reg_t **reg_list[], int *reg_list_size);
+int armv7m_arch_state(struct target_s *target);
+int armv7m_get_gdb_reg_list(target_t *target,
+		reg_t **reg_list[], int *reg_list_size);
 
-extern int armv7m_register_commands(struct command_context_s *cmd_ctx);
-extern int armv7m_init_arch_info(target_t *target, armv7m_common_t *armv7m);
+int armv7m_register_commands(struct command_context_s *cmd_ctx);
+int armv7m_init_arch_info(target_t *target, armv7m_common_t *armv7m);
 
-extern int armv7m_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
+int armv7m_run_algorithm(struct target_s *target,
+		int num_mem_params, mem_param_t *mem_params,
+		int num_reg_params, reg_param_t *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		int timeout_ms, void *arch_info);
 
-extern int armv7m_invalidate_core_regs(target_t *target);
+int armv7m_invalidate_core_regs(target_t *target);
 
-extern int armv7m_restore_context(target_t *target);
+int armv7m_restore_context(target_t *target);
 
-extern int armv7m_checksum_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum);
-extern int armv7m_blank_check_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* blank);
+int armv7m_checksum_memory(struct target_s *target,
+		uint32_t address, uint32_t count, uint32_t* checksum);
+int armv7m_blank_check_memory(struct target_s *target,
+		uint32_t address, uint32_t count, uint32_t* blank);
 
 /* Thumb mode instructions
  */
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
index 9145966..781c91b 100644
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -58,12 +58,17 @@ typedef struct watchpoint_s
 	int unique_id;
 } watchpoint_t;
 
-extern void breakpoint_clear_target(struct target_s *target);
-extern int breakpoint_add(struct target_s *target, uint32_t address, uint32_t length, enum breakpoint_type type);
-extern void breakpoint_remove(struct target_s *target, uint32_t address);
-extern breakpoint_t* breakpoint_find(struct target_s *target, uint32_t address);
-extern int watchpoint_add(struct target_s *target, uint32_t address, uint32_t length, enum watchpoint_rw rw, uint32_t value, uint32_t mask);
-extern void watchpoint_remove(struct target_s *target, uint32_t address);
-extern void watchpoint_clear_target(struct target_s *target);
+void breakpoint_clear_target(struct target_s *target);
+int breakpoint_add(struct target_s *target,
+		uint32_t address, uint32_t length, enum breakpoint_type type);
+void breakpoint_remove(struct target_s *target, uint32_t address);
+
+breakpoint_t* breakpoint_find(struct target_s *target, uint32_t address);
+
+void watchpoint_clear_target(struct target_s *target);
+int watchpoint_add(struct target_s *target,
+		uint32_t address, uint32_t length,
+		enum watchpoint_rw rw, uint32_t value, uint32_t mask);
+void watchpoint_remove(struct target_s *target, uint32_t address);
 
 #endif /* BREAKPOINTS_H */
diff --git a/src/target/cortex_a8.h b/src/target/cortex_a8.h
index b4cb327..42cb062 100644
--- a/src/target/cortex_a8.h
+++ b/src/target/cortex_a8.h
@@ -143,8 +143,13 @@ target_to_cortex_a8(struct target_s *target)
 			armv7a_common.armv4_5_common);
 }
 
-extern int cortex_a8_init_arch_info(target_t *target, cortex_a8_common_t *cortex_a8, jtag_tap_t *tap);
-int cortex_a8_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-int cortex_a8_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int cortex_a8_init_arch_info(target_t *target,
+		cortex_a8_common_t *cortex_a8, jtag_tap_t *tap);
+int cortex_a8_read_memory(struct target_s *target,
+		uint32_t address, uint32_t size,
+		uint32_t count, uint8_t *buffer);
+int cortex_a8_write_memory(struct target_s *target,
+		uint32_t address, uint32_t size,
+		uint32_t count, uint8_t *buffer);
 
 #endif /* CORTEX_A8_H */
diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
index 08e42c9..b1ba989 100644
--- a/src/target/embeddedice.h
+++ b/src/target/embeddedice.h
@@ -93,17 +93,25 @@ typedef struct embeddedice_reg_s
 	arm_jtag_t *jtag_info;
 } embeddedice_reg_t;
 
-extern reg_cache_t* embeddedice_build_reg_cache(target_t *target, arm7_9_common_t *arm7_9);
-extern int embeddedice_setup(target_t *target);
-extern int embeddedice_read_reg(reg_t *reg);
-extern void embeddedice_write_reg(reg_t *reg, uint32_t value);
-extern int embeddedice_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
-extern void embeddedice_store_reg(reg_t *reg);
-extern void embeddedice_set_reg(reg_t *reg, uint32_t value);
-extern int embeddedice_set_reg_w_exec(reg_t *reg, uint8_t *buf);
-extern int embeddedice_receive(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size);
-extern int embeddedice_send(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size);
-extern int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, uint32_t timeout);
+reg_cache_t* embeddedice_build_reg_cache(target_t *target,
+		arm7_9_common_t *arm7_9);
+
+int embeddedice_setup(target_t *target);
+
+int embeddedice_read_reg(reg_t *reg);
+int embeddedice_read_reg_w_check(reg_t *reg,
+		uint8_t* check_value, uint8_t* check_mask);
+
+void embeddedice_write_reg(reg_t *reg, uint32_t value);
+void embeddedice_store_reg(reg_t *reg);
+
+void embeddedice_set_reg(reg_t *reg, uint32_t value);
+int embeddedice_set_reg_w_exec(reg_t *reg, uint8_t *buf);
+
+int embeddedice_receive(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size);
+int embeddedice_send(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size);
+
+int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, uint32_t timeout);
 
 /* If many embeddedice_write_reg() follow eachother, then the &gt;1 invocations can be this faster version of
  * embeddedice_write_reg
diff --git a/src/target/etb.h b/src/target/etb.h
index 0eeb02b..cc58b65 100644
--- a/src/target/etb.h
+++ b/src/target/etb.h
@@ -56,6 +56,6 @@ typedef struct etb_reg_s
 
 extern etm_capture_driver_t etb_capture_driver;
 
-extern reg_cache_t* etb_build_reg_cache(etb_t *etb);
+reg_cache_t* etb_build_reg_cache(etb_t *etb);
 
 #endif /* ETB_H */
diff --git a/src/target/etm.h b/src/target/etm.h
index b2426c7..c751aac 100644
--- a/src/target/etm.h
+++ b/src/target/etm.h
@@ -200,8 +200,10 @@ typedef enum
 	BR_RSVD7   = 0x7, /* reserved */
 } etmv1_branch_reason_t;
 
-extern reg_cache_t* etm_build_reg_cache(target_t *target, arm_jtag_t *jtag_info, etm_context_t *etm_ctx);
-extern int etm_setup(target_t *target);
+reg_cache_t* etm_build_reg_cache(target_t *target,
+		arm_jtag_t *jtag_info, etm_context_t *etm_ctx);
+
+int etm_setup(target_t *target);
 
 int etm_register_commands(struct command_context_s *cmd_ctx);
 
diff --git a/src/target/image.h b/src/target/image.h
index 551524e..8b70b3b 100644
--- a/src/target/image.h
+++ b/src/target/image.h
@@ -100,12 +100,16 @@ typedef struct image_mot_s
 	uint8_t *buffer;
 } image_mot_t;
 
-extern int image_open(image_t *image, char *url, char *type_string);
-extern int image_read_section(image_t *image, int section, uint32_t offset, uint32_t size, uint8_t *buffer, uint32_t *size_read);
-extern void image_close(image_t *image);
-extern int image_add_section(image_t *image, uint32_t base, uint32_t size, int flags, uint8_t *data);
+int image_open(image_t *image, char *url, char *type_string);
+int image_read_section(image_t *image, int section, uint32_t offset,
+		uint32_t size, uint8_t *buffer, uint32_t *size_read);
+void image_close(image_t *image);
 
-extern int image_calculate_checksum(uint8_t* buffer, uint32_t nbytes, uint32_t* checksum);
+int image_add_section(image_t *image, uint32_t base, uint32_t size,
+		int flags, uint8_t *data);
+
+int image_calculate_checksum(uint8_t* buffer, uint32_t nbytes,
+		uint32_t* checksum);
 
 #define ERROR_IMAGE_FORMAT_ERROR	(-1400)
 #define ERROR_IMAGE_TYPE_UNKNOWN	(-1401)
diff --git a/src/target/mips32.h b/src/target/mips32.h
index bc88bc3..005798d 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -124,18 +124,32 @@ typedef struct mips32_core_reg_s
 #define MIPS32_SDBBP				0x7000003F
 #define MIPS16_SDBBP 				0xE801
 
-extern int mips32_arch_state(struct target_s *target);
-extern int mips32_init_arch_info(target_t *target, mips32_common_t *mips32, jtag_tap_t *tap);
-extern int mips32_restore_context(target_t *target);
-extern int mips32_save_context(target_t *target);
-extern reg_cache_t *mips32_build_reg_cache(target_t *target);
-extern int mips32_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
-extern int mips32_configure_break_unit(struct target_s *target);
-extern int mips32_enable_interrupts(struct target_s *target, int enable);
-extern int mips32_examine(struct target_s *target);
-
-extern int mips32_register_commands(struct command_context_s *cmd_ctx);
-extern int mips32_invalidate_core_regs(target_t *target);
-extern int mips32_get_gdb_reg_list(target_t *target, reg_t **reg_list[], int *reg_list_size);
+int mips32_arch_state(struct target_s *target);
+
+int mips32_init_arch_info(target_t *target,
+		mips32_common_t *mips32, jtag_tap_t *tap);
+
+int mips32_restore_context(target_t *target);
+int mips32_save_context(target_t *target);
+
+reg_cache_t *mips32_build_reg_cache(target_t *target);
+
+int mips32_run_algorithm(struct target_s *target,
+		int num_mem_params, mem_param_t *mem_params,
+		int num_reg_params, reg_param_t *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		int timeout_ms, void *arch_info);
+
+int mips32_configure_break_unit(struct target_s *target);
+
+int mips32_enable_interrupts(struct target_s *target, int enable);
+
+int mips32_examine(struct target_s *target);
+
+int mips32_register_commands(struct command_context_s *cmd_ctx);
+
+int mips32_invalidate_core_regs(target_t *target);
+int mips32_get_gdb_reg_list(target_t *target,
+		reg_t **reg_list[], int *reg_list_size);
 
 #endif	/*MIPS32_H*/
diff --git a/src/target/mips32_dmaacc.h b/src/target/mips32_dmaacc.h
index e44ddad..c8a64fb 100644
--- a/src/target/mips32_dmaacc.h
+++ b/src/target/mips32_dmaacc.h
@@ -34,15 +34,23 @@
 
 #define RETRY_ATTEMPTS	0
 
-extern int mips32_dmaacc_read_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
-extern int mips32_dmaacc_write_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
+int mips32_dmaacc_read_mem(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int size, int count, void *buf);
+int mips32_dmaacc_write_mem(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int size, int count, void *buf);
 
-extern int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
-extern int mips32_dmaacc_read_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
-extern int mips32_dmaacc_read_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
+int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint8_t *buf);
+int mips32_dmaacc_read_mem16(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint16_t *buf);
+int mips32_dmaacc_read_mem32(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint32_t *buf);
 
-extern int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
-extern int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
-extern int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
+int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint8_t *buf);
+int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint16_t *buf);
+int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint32_t *buf);
 
 #endif
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
index 8443f87..866f6f5 100644
--- a/src/target/mips32_pracc.h
+++ b/src/target/mips32_pracc.h
@@ -37,22 +37,34 @@
 #define NEG16(v) (((~(v)) + 1) &amp; 0xFFFF)
 /*#define NEG18(v) (((~(v)) + 1) &amp; 0x3FFFF)*/
 
-extern int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
-extern int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
+int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int size, int count, void *buf);
+int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int size, int count, void *buf);
 
-extern int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
-extern int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
-extern int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
-extern int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t *buf);
+int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint8_t *buf);
+int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint16_t *buf);
+int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint32_t *buf);
+int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info,
+		uint32_t addr, uint32_t *buf);
 
-extern int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
-extern int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
-extern int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
-extern int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t *buf);
+int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint8_t *buf);
+int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint16_t *buf);
+int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info,
+		uint32_t addr, int count, uint32_t *buf);
+int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info,
+		uint32_t addr, uint32_t *buf);
 
-extern int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, uint32_t *regs);
-extern int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, uint32_t *regs);
+int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, uint32_t *regs);
+int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, uint32_t *regs);
 
-extern int mips32_pracc_exec(mips_ejtag_t *ejtag_info, int code_len, uint32_t *code, int num_param_in, uint32_t *param_in, int num_param_out, uint32_t *param_out, int cycle);
+int mips32_pracc_exec(mips_ejtag_t *ejtag_info, int code_len, uint32_t *code,
+		int num_param_in, uint32_t *param_in,
+		int num_param_out, uint32_t *param_out, int cycle);
 
 #endif
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 274392a..69ede52 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -111,15 +111,16 @@ typedef struct mips_ejtag_s
 	uint32_t ejtag_ctrl;
 } mips_ejtag_t;
 
-extern int mips_ejtag_set_instr(mips_ejtag_t *ejtag_info, int new_instr, void *delete_me_and_submit_patch);
-extern int mips_ejtag_enter_debug(mips_ejtag_t *ejtag_info);
-extern int mips_ejtag_exit_debug(mips_ejtag_t *ejtag_info);
-extern int mips_ejtag_get_impcode(mips_ejtag_t *ejtag_info, uint32_t *impcode);
-extern int mips_ejtag_get_idcode(mips_ejtag_t *ejtag_info, uint32_t *idcode);
-extern int mips_ejtag_drscan_32(mips_ejtag_t *ejtag_info, uint32_t *data);
+int mips_ejtag_set_instr(mips_ejtag_t *ejtag_info,
+		int new_instr, void *delete_me_and_submit_patch);
+int mips_ejtag_enter_debug(mips_ejtag_t *ejtag_info);
+int mips_ejtag_exit_debug(mips_ejtag_t *ejtag_info);
+int mips_ejtag_get_impcode(mips_ejtag_t *ejtag_info, uint32_t *impcode);
+int mips_ejtag_get_idcode(mips_ejtag_t *ejtag_info, uint32_t *idcode);
+int mips_ejtag_drscan_32(mips_ejtag_t *ejtag_info, uint32_t *data);
 
-extern int mips_ejtag_init(mips_ejtag_t *ejtag_info);
-extern int mips_ejtag_config_step(mips_ejtag_t *ejtag_info, int enable_step);
-extern int mips_ejtag_read_debug(mips_ejtag_t *ejtag_info, uint32_t* debug_reg);
+int mips_ejtag_init(mips_ejtag_t *ejtag_info);
+int mips_ejtag_config_step(mips_ejtag_t *ejtag_info, int enable_step);
+int mips_ejtag_read_debug(mips_ejtag_t *ejtag_info, uint32_t* debug_reg);
 
 #endif /* MIPS_EJTAG */
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index 8e81d8f..e11f06a 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -35,17 +35,19 @@ typedef struct mips_m4k_common_s
 	mips32_common_t mips32_common;
 } mips_m4k_common_t;
 
-extern int mips_m4k_bulk_write_memory(struct target_s *target, uint32_t address, uint32_t count, uint8_t *buffer);
-
-extern void mips_m4k_enable_breakpoints(struct target_s *target);
-extern int mips_m4k_set_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
-extern int mips_m4k_unset_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
-extern int mips_m4k_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
-extern int mips_m4k_remove_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
-extern int mips_m4k_set_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
-extern int mips_m4k_unset_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
-extern int mips_m4k_add_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
-extern int mips_m4k_remove_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
-extern void mips_m4k_enable_watchpoints(struct target_s *target);
+int mips_m4k_bulk_write_memory(struct target_s *target,
+		uint32_t address, uint32_t count, uint8_t *buffer);
+
+void mips_m4k_enable_breakpoints(struct target_s *target);
+int mips_m4k_set_breakpoint(struct target_s *target, breakpoint_t *bp);
+int mips_m4k_unset_breakpoint(struct target_s *target, breakpoint_t *bp);
+int mips_m4k_add_breakpoint(struct target_s *target, breakpoint_t *bp);
+int mips_m4k_remove_breakpoint(struct target_s *target, breakpoint_t *bp);
+
+void mips_m4k_enable_watchpoints(struct target_s *target);
+int mips_m4k_set_watchpoint(struct target_s *target, watchpoint_t *wp);
+int mips_m4k_unset_watchpoint(struct target_s *target, watchpoint_t *wp);
+int mips_m4k_add_watchpoint(struct target_s *target, watchpoint_t *wp);
+int mips_m4k_remove_watchpoint(struct target_s *target, watchpoint_t *wp);
 
 #endif	/*MIPS_M4K_H*/
diff --git a/src/target/register.h b/src/target/register.h
index d139379..e7904e5 100644
--- a/src/target/register.h
+++ b/src/target/register.h
@@ -62,10 +62,13 @@ typedef struct reg_arch_type_s
 	struct reg_arch_type_s *next;
 } reg_arch_type_t;
 
-extern reg_t* register_get_by_name(reg_cache_t *first, char *name, int search_all);
-extern reg_cache_t** register_get_last_cache_p(reg_cache_t **first);
-extern int register_reg_arch_type(int (*get)(reg_t *reg), int (*set)(reg_t *reg, uint8_t *buf));
-extern reg_arch_type_t* register_get_arch_type(int id);
-extern void register_init_dummy(reg_t *reg);
+reg_t* register_get_by_name(reg_cache_t *first, char *name, int search_all);
+reg_cache_t** register_get_last_cache_p(reg_cache_t **first);
+
+int register_reg_arch_type(int (*get)(reg_t *reg),
+		int (*set)(reg_t *reg, uint8_t *buf));
+reg_arch_type_t* register_get_arch_type(int id);
+
+void register_init_dummy(reg_t *reg);
 
 #endif /* REGISTER_H */
diff --git a/src/target/target_request.h b/src/target/target_request.h
index b457bd9..433c592 100644
--- a/src/target/target_request.h
+++ b/src/target/target_request.h
@@ -42,8 +42,9 @@ typedef struct debug_msg_receiver_s
 	struct debug_msg_receiver_s *next;
 } debug_msg_receiver_t;
 
-extern int target_request(target_t *target, uint32_t request);
-extern int delete_debug_msg_receiver(struct command_context_s *cmd_ctx, target_t *target);
-extern int target_request_register_commands(struct command_context_s *cmd_ctx);
+int target_request(target_t *target, uint32_t request);
+int delete_debug_msg_receiver(struct command_context_s *cmd_ctx,
+		target_t *target);
+int target_request_register_commands(struct command_context_s *cmd_ctx);
 
 #endif /* TARGET_REQUEST_H */
diff --git a/src/target/trace.h b/src/target/trace.h
index 0a9ccc5..f6615f5 100644
--- a/src/target/trace.h
+++ b/src/target/trace.h
@@ -51,8 +51,8 @@ typedef enum trace_status
 	TRACE_OVERFLOWED = 0x8,
 } trace_status_t;
 
-extern int trace_point(struct target_s *target, uint32_t number);
-extern int trace_register_commands(struct command_context_s *cmd_ctx);
+int trace_point(struct target_s *target, uint32_t number);
+int trace_register_commands(struct command_context_s *cmd_ctx);
 
 #define ERROR_TRACE_IMAGE_UNAVAILABLE		-(1500)
 #define ERROR_TRACE_INSTRUCTION_UNAVAILABLE	-(1501)

commit 42cafc9369088d2a5d5f633358a2a42aa7bbc0de
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 9 04:21:36 2009 -0800

    target.h: remove extern keyword and wrap
    
    Removes 'extern' keyword from function prototypes and wraps long lines.

diff --git a/src/target/target.h b/src/target/target.h
index 1bbf40f..5a61170 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -249,53 +249,65 @@ typedef struct target_timer_callback_s
 	struct target_timer_callback_s *next;
 } target_timer_callback_t;
 
-extern int target_register_commands(struct command_context_s *cmd_ctx);
-extern int target_register_user_commands(struct command_context_s *cmd_ctx);
-extern int target_init(struct command_context_s *cmd_ctx);
-extern int target_examine(void);
-extern int handle_target(void *priv);
-extern int target_process_reset(struct command_context_s *cmd_ctx, enum target_reset_mode reset_mode);
-
-extern int target_register_event_callback(int (*callback)(struct target_s *target, enum target_event event, void *priv), void *priv);
-extern int target_unregister_event_callback(int (*callback)(struct target_s *target, enum target_event event, void *priv), void *priv);
-extern int target_poll(target_t *target);
-extern int target_resume(target_t *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
-extern int target_halt(target_t *target);
-extern int target_call_event_callbacks(target_t *target, enum target_event event);
-
-/* The period is very approximate, the callback can happen much more often
+int target_register_commands(struct command_context_s *cmd_ctx);
+int target_register_user_commands(struct command_context_s *cmd_ctx);
+int target_init(struct command_context_s *cmd_ctx);
+int target_examine(void);
+int handle_target(void *priv);
+int target_process_reset(struct command_context_s *cmd_ctx,
+		enum target_reset_mode reset_mode);
+
+int target_register_event_callback(
+		int (*callback)(struct target_s *target,
+				enum target_event event, void *priv),
+		void *priv);
+int target_unregister_event_callback(
+		int (*callback)(struct target_s *target,
+				enum target_event event, void *priv),
+		void *priv);
+int target_poll(target_t *target);
+int target_resume(target_t *target, int current, uint32_t address,
+		int handle_breakpoints, int debug_execution);
+int target_halt(target_t *target);
+int target_call_event_callbacks(target_t *target, enum target_event event);
+
+/**
+ * The period is very approximate, the callback can happen much more often
  * or much more rarely than specified
  */
-extern int target_register_timer_callback(int (*callback)(void *priv), int time_ms, int periodic, void *priv);
-extern int target_unregister_timer_callback(int (*callback)(void *priv), void *priv);
-extern int target_call_timer_callbacks(void);
-/* invoke this to ensure that e.g. polling timer callbacks happen before
+int target_register_timer_callback(int (*callback)(void *priv),
+		int time_ms, int periodic, void *priv);
+int target_unregister_timer_callback(int (*callback)(void *priv), void *priv);
+
+int target_call_timer_callbacks(void);
+/**
+ * Invoke this to ensure that e.g. polling timer callbacks happen before
  * a syncrhonous command completes.
  */
-extern int target_call_timer_callbacks_now(void);
+int target_call_timer_callbacks_now(void);
 
-extern target_t* get_current_target(struct command_context_s *cmd_ctx);
-extern target_t *get_target(const char *id);
+target_t* get_current_target(struct command_context_s *cmd_ctx);
+target_t *get_target(const char *id);
 
 /**
  * Get the target name.
  *
  * This routine is a wrapper for the target-&gt;type-&gt;name field.
  */
-extern const char *target_get_name(struct target_s *target);
+const char *target_get_name(struct target_s *target);
 
 /**
  * Examine the specified @a target.
  *
  * This routine is a wrapper for target-&gt;type-&gt;examine.
  */
-extern int target_examine_one(struct target_s *target);
+int target_examine_one(struct target_s *target);
 /// @returns @c true if the target has been examined.
-extern bool target_was_examined(struct target_s *target);
+bool target_was_examined(struct target_s *target);
 /// Sets the @c examined flag for the given target.
-extern void target_set_examined(struct target_s *target);
+void target_set_examined(struct target_s *target);
 /// Reset the @c examined flag for the given target.
-extern void target_reset_examined(struct target_s *target);
+void target_reset_examined(struct target_s *target);
 
 
 /**
@@ -303,28 +315,28 @@ extern void target_reset_examined(struct target_s *target);
  *
  * This routine is a wrapper for target-&gt;type-&gt;add_breakpoint.
  */
-extern int target_add_breakpoint(struct target_s *target,
+int target_add_breakpoint(struct target_s *target,
 		struct breakpoint_s *breakpoint);
 /**
  * Remove the @a breakpoint for @a target.
  *
  * This routine is a wrapper for target-&gt;type-&gt;remove_breakpoint.
  */
-extern int target_remove_breakpoint(struct target_s *target,
+int target_remove_breakpoint(struct target_s *target,
 		struct breakpoint_s *breakpoint);
 /**
  * Add the @a watchpoint for @a target.
  *
  * This routine is a wrapper for target-&gt;type-&gt;add_watchpoint.
  */
-extern int target_add_watchpoint(struct target_s *target,
+int target_add_watchpoint(struct target_s *target,
 		struct watchpoint_s *watchpoint);
 /**
  * Remove the @a watchpoint for @a target.
  *
  * This routine is a wrapper for target-&gt;type-&gt;remove_watchpoint.
  */
-extern int target_remove_watchpoint(struct target_s *target,
+int target_remove_watchpoint(struct target_s *target,
 		struct watchpoint_s *watchpoint);
 
 /**
@@ -332,7 +344,7 @@ extern int target_remove_watchpoint(struct target_s *target,
  *
  * This routine is a wrapper for target-&gt;type-&gt;get_gdb_reg_list.
  */
-extern int target_get_gdb_reg_list(struct target_s *target,
+int target_get_gdb_reg_list(struct target_s *target,
 		struct reg_s **reg_list[], int *reg_list_size);
 
 /**
@@ -347,7 +359,7 @@ int target_step(struct target_s *target,
  *
  * This routine is a wrapper for target-&gt;type-&gt;run_algorithm.
  */
-extern int target_run_algorithm(struct target_s *target,
+int target_run_algorithm(struct target_s *target,
 		int num_mem_params, mem_param_t *mem_params,
 		int num_reg_params, reg_param_t *reg_param,
 		uint32_t entry_point, uint32_t exit_point,
@@ -359,7 +371,7 @@ extern int target_run_algorithm(struct target_s *target,
  *
  * This routine is a wrapper for target-&gt;type-&gt;read_memory.
  */
-extern int target_read_memory(struct target_s *target,
+int target_read_memory(struct target_s *target,
 		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 /**
  * Write @a count items of @a size bytes to the memory of @a target at
@@ -367,7 +379,7 @@ extern int target_read_memory(struct target_s *target,
  *
  * This routine is wrapper for target-&gt;type-&gt;write_memory.
  */
-extern int target_write_memory(struct target_s *target,
+int target_write_memory(struct target_s *target,
 		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 /**
@@ -377,7 +389,7 @@ extern int target_write_memory(struct target_s *target,
  *
  * This routine is wrapper for target-&gt;type-&gt;bulk_write_memory.
  */
-extern int target_bulk_write_memory(struct target_s *target,
+int target_bulk_write_memory(struct target_s *target,
 		uint32_t address, uint32_t count, uint8_t *buffer);
 
 /*
@@ -404,11 +416,15 @@ extern int target_bulk_write_memory(struct target_s *target,
  * write operation, thus making this fn suitable to e.g. write to special
  * peripheral registers which do not support byte operations.
  */
-extern int target_write_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer);
-extern int target_read_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer);
-extern int target_checksum_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t* crc);
-extern int target_blank_check_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t* blank);
-extern int target_wait_state(target_t *target, enum target_state state, int ms);
+int target_write_buffer(struct target_s *target,
+		uint32_t address, uint32_t size, uint8_t *buffer);
+int target_read_buffer(struct target_s *target,
+		uint32_t address, uint32_t size, uint8_t *buffer);
+int target_checksum_memory(struct target_s *target,
+		uint32_t address, uint32_t size, uint32_t* crc);
+int target_blank_check_memory(struct target_s *target,
+		uint32_t address, uint32_t size, uint32_t* blank);
+int target_wait_state(target_t *target, enum target_state state, int ms);
 
 /** Return the *name* of this targets current state */
 const char *target_state_name( target_t *target );
@@ -424,23 +440,25 @@ const char *target_state_name( target_t *target );
  * upon resuming or resetting the CPU.
  *
  */
-extern int target_alloc_working_area(struct target_s *target, uint32_t size, working_area_t **area);
-extern int target_free_working_area(struct target_s *target, working_area_t *area);
-extern int target_free_working_area_restore(struct target_s *target, working_area_t *area, int restore);
-extern void target_free_all_working_areas(struct target_s *target);
-extern void target_free_all_working_areas_restore(struct target_s *target, int restore);
+int target_alloc_working_area(struct target_s *target,
+		uint32_t size, working_area_t **area);
+int target_free_working_area(struct target_s *target, working_area_t *area);
+int target_free_working_area_restore(struct target_s *target,
+		working_area_t *area, int restore);
+void target_free_all_working_areas(struct target_s *target);
+void target_free_all_working_areas_restore(struct target_s *target, int restore);
 
 extern target_t *all_targets;
 
 extern target_event_callback_t *target_event_callbacks;
 extern target_timer_callback_t *target_timer_callbacks;
 
-extern uint32_t target_buffer_get_u32(target_t *target, const uint8_t *buffer);
-extern uint16_t target_buffer_get_u16(target_t *target, const uint8_t *buffer);
-extern uint8_t  target_buffer_get_u8 (target_t *target, const uint8_t *buffer);
-extern void target_buffer_set_u32(target_t *target, uint8_t *buffer, uint32_t value);
-extern void target_buffer_set_u16(target_t *target, uint8_t *buffer, uint16_t value);
-extern void target_buffer_set_u8 (target_t *target, uint8_t *buffer, uint8_t  value);
+uint32_t target_buffer_get_u32(target_t *target, const uint8_t *buffer);
+uint16_t target_buffer_get_u16(target_t *target, const uint8_t *buffer);
+uint8_t  target_buffer_get_u8 (target_t *target, const uint8_t *buffer);
+void target_buffer_set_u32(target_t *target, uint8_t *buffer, uint32_t value);
+void target_buffer_set_u16(target_t *target, uint8_t *buffer, uint16_t value);
+void target_buffer_set_u8 (target_t *target, uint8_t *buffer, uint8_t  value);
 
 int target_read_u32(struct target_s *target, uint32_t address, uint32_t *value);
 int target_read_u16(struct target_s *target, uint32_t address, uint16_t *value);
@@ -468,6 +486,7 @@ void target_all_handle_event(enum target_event e);
 #define ERROR_TARGET_NOT_EXAMINED (-311)
 
 extern const Jim_Nvp nvp_error_target[];
-extern const char *target_strerror_safe(int err);
+
+const char *target_strerror_safe(int err);
 
 #endif /* TARGET_H */

commit 994a63c3fee11b8c65891ead6b03b2b716044541
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 9 03:38:34 2009 -0800

    src/{server,pld,svf,xsvf}: remove 'extern' keyword
    
    Removes 'extern' keyword from function declarations in header filess.

diff --git a/src/pld/pld.h b/src/pld/pld.h
index e4cfc07..c6d3c92 100644
--- a/src/pld/pld.h
+++ b/src/pld/pld.h
@@ -39,9 +39,11 @@ typedef struct pld_device_s
 	struct pld_device_s *next;
 } pld_device_t;
 
-extern int pld_register_commands(struct command_context_s *cmd_ctx);
-extern int pld_init(struct command_context_s *cmd_ctx);
-extern pld_device_t *get_pld_device_by_num(int num);
+int pld_register_commands(struct command_context_s *cmd_ctx);
+
+int pld_init(struct command_context_s *cmd_ctx);
+
+pld_device_t *get_pld_device_by_num(int num);
 
 #define ERROR_PLD_DEVICE_INVALID	(-1000)
 #define ERROR_PLD_FILE_LOAD_FAILED	(-1001)
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index ea981f3..4e334bc 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -54,8 +54,8 @@ typedef struct gdb_service_s
 	struct target_s *target;
 } gdb_service_t;
 
-extern int gdb_init(void);
-extern int gdb_register_commands(command_context_t *command_context);
+int gdb_init(void);
+int gdb_register_commands(command_context_t *command_context);
 
 #define ERROR_GDB_BUFFER_TOO_SMALL (-800)
 #define ERROR_GDB_TIMEOUT (-801)
diff --git a/src/server/server.h b/src/server/server.h
index dab28ec..d4f1b6b 100644
--- a/src/server/server.h
+++ b/src/server/server.h
@@ -69,11 +69,17 @@ typedef struct service_s
 	struct service_s *next;
 } service_t;
 
-extern int add_service(char *name, enum connection_type type, unsigned short port, int max_connections, new_connection_handler_t new_connection_handler, input_handler_t input_handler, connection_closed_handler_t connection_closed_handler, void *priv);
-extern int server_init(void);
-extern int server_quit(void);
-extern int server_loop(command_context_t *command_context);
-extern int server_register_commands(command_context_t *context);
+int add_service(char *name, enum connection_type type, unsigned short port,
+		int max_connections, new_connection_handler_t new_connection_handler,
+		input_handler_t in_handler, connection_closed_handler_t close_handler,
+		void *priv);
+
+int server_init(void);
+int server_quit(void);
+
+int server_loop(command_context_t *command_context);
+
+int server_register_commands(command_context_t *context);
 
 int server_port_command(struct command_context_s *cmd_ctx,
 		char *cmd, char **args, int argc, unsigned short *port);
diff --git a/src/server/tcl_server.h b/src/server/tcl_server.h
index c90dc8e..d6c9e10 100644
--- a/src/server/tcl_server.h
+++ b/src/server/tcl_server.h
@@ -22,7 +22,7 @@
 
 #include &quot;server.h&quot;
 
-extern int tcl_init(void);
-extern int tcl_register_commands(command_context_t *cmd_ctx);
+int tcl_init(void);
+int tcl_register_commands(command_context_t *cmd_ctx);
 
 #endif /* _TCL_SERVER_H_ */
diff --git a/src/server/telnet_server.h b/src/server/telnet_server.h
index 541d720..8f0d24a 100644
--- a/src/server/telnet_server.h
+++ b/src/server/telnet_server.h
@@ -68,7 +68,7 @@ typedef struct telnet_service_s
 	char *banner;
 } telnet_service_t;
 
-extern int telnet_init(char *banner);
-extern int telnet_register_commands(command_context_t *command_context);
+int telnet_init(char *banner);
+int telnet_register_commands(command_context_t *command_context);
 
 #endif /* TELNET_SERVER_H */
diff --git a/src/svf/svf.h b/src/svf/svf.h
index 83123fc..329fea9 100644
--- a/src/svf/svf.h
+++ b/src/svf/svf.h
@@ -22,7 +22,7 @@
 
 #include &quot;command.h&quot;
 
-extern int svf_register_commands(struct command_context_s *cmd_ctx);
+int svf_register_commands(struct command_context_s *cmd_ctx);
 
 /**
  * svf_add_statemove() moves from the current state to @a goal_state.
@@ -35,7 +35,7 @@ extern int svf_register_commands(struct command_context_s *cmd_ctx);
  * SVF specification for single-argument STATE commands (and also used
  * for various other state transitions).
  */
-extern int svf_add_statemove(tap_state_t goal_state);
+int svf_add_statemove(tap_state_t goal_state);
 
 /**
  * svf_tap_state_is_stable() returns true for stable non-SHIFT states
@@ -43,6 +43,6 @@ extern int svf_add_statemove(tap_state_t goal_state);
  * @param state The TAP state in question
  * @return true iff the state is stable and not a SHIFT state.
  */
-extern bool svf_tap_state_is_stable(tap_state_t state);
+bool svf_tap_state_is_stable(tap_state_t state);
 
 #endif /* SVF_H */
diff --git a/src/xsvf/xsvf.h b/src/xsvf/xsvf.h
index 017af88..93cccf0 100644
--- a/src/xsvf/xsvf.h
+++ b/src/xsvf/xsvf.h
@@ -22,7 +22,7 @@
 
 #include &quot;command.h&quot;
 
-extern int xsvf_register_commands(struct command_context_s *cmd_ctx);
+int xsvf_register_commands(struct command_context_s *cmd_ctx);
 
 #define ERROR_XSVF_EOF	(-200)
 #define ERROR_XSVF_FAILED	(-201)

commit 81fbc637185fb0007dbe84c866794800851295b5
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 9 03:10:11 2009 -0800

    src/flash: remove 'extern' and wrap headers
    
    Removes 'extern' keywords from function prototypes in the flash headers.
    Wraps long lines to fit into 80 columns.
    
    Adds multiple inclusion protection for s3c2xx_nand.h.

diff --git a/src/flash/flash.h b/src/flash/flash.h
index 05c4b2c..fd3c4c2 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -127,7 +127,8 @@ typedef struct flash_driver_s
 	 *
 	 * @returns ERROR_OK if successful; otherwise, an error code.
 	 */
-	int (*flash_bank_command)(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
+	int (*flash_bank_command)(struct command_context_s *cmd_ctx,
+			char *cmd, char **args, int argc, struct flash_bank_s *bank);
 
 	/**
 	 * Bank/sector erase routine (target-specific).  When
@@ -166,7 +167,8 @@ typedef struct flash_driver_s
 	 * @param count The number of bytes to write.
 	 * @returns ERROR_OK if successful; otherwise, an error code.
 	 */
-	int (*write)(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
+	int (*write)(struct flash_bank_s *bank,
+			uint8_t *buffer, uint32_t offset, uint32_t count);
 
 	/**
 	 * Probe to determine what kind of flash is present.
@@ -265,15 +267,16 @@ typedef struct flash_bank_s
 } flash_bank_t;
 
 /// Registers the 'flash' subsystem commands
-extern int flash_register_commands(struct command_context_s *cmd_ctx);
+int flash_register_commands(struct command_context_s *cmd_ctx);
 /// Initializes the 'flash' subsystem drivers
-extern int flash_init_drivers(struct command_context_s *cmd_ctx);
+int flash_init_drivers(struct command_context_s *cmd_ctx);
 
 /**
  * Erases @a length bytes in the @a target flash, starting at @a addr.
  * @returns ERROR_OK if successful; otherwise, an error code.
  */
-extern int flash_erase_address_range(struct target_s *target, uint32_t addr, uint32_t length);
+int flash_erase_address_range(struct target_s *target,
+		uint32_t addr, uint32_t length);
 /**
  * Writes @a image into the @a target flash.  The @a written parameter
  * will contain the
@@ -284,35 +287,36 @@ extern int flash_erase_address_range(struct target_s *target, uint32_t addr, uin
  * erase the corresponding banks or sectors before programming.
  * @returns ERROR_OK if successful; otherwise, an error code.
  */
-extern int flash_write(struct target_s *target, struct image_s *image, uint32_t *written, int erase);
+int flash_write(struct target_s *target,
+		struct image_s *image, uint32_t *written, int erase);
 /**
  * Forces targets to re-examine their erase/protection state.
  * This routine must be called when the system may modify the status.
  */
-extern void flash_set_dirty(void);
+void flash_set_dirty(void);
 /// @returns The number of flash banks currently defined.
-extern int flash_get_bank_count(void);
+int flash_get_bank_count(void);
 /**
  * Provides default erased-bank check handling. Checks to see if
  * the flash driver knows they are erased; if things look uncertain,
  * this routine will call default_flash_mem_blank_check() to confirm.
  * @returns ERROR_OK if successful; otherwise, an error code.
  */
-extern int default_flash_blank_check(struct flash_bank_s *bank);
+int default_flash_blank_check(struct flash_bank_s *bank);
 /**
  * Provides a default blank flash memory check.  Ensures the contents
  * of the given bank have truly been erased.
  * @param bank The flash bank.
  * @returns ERROR_OK if successful; otherwise, an error code.
  */
-extern int default_flash_mem_blank_check(struct flash_bank_s *bank);
+int default_flash_mem_blank_check(struct flash_bank_s *bank);
 
 /**
  * Returns a flash bank by the specified flash_bank_s bank_number, @a num.
  * @param num The flash bank number.
  * @returns A flash_bank_t for flash bank @a num, or NULL
  */
-extern flash_bank_t *get_flash_bank_by_num(int num);
+flash_bank_t *get_flash_bank_by_num(int num);
 /**
  * Retreives @a bank from a command argument, reporting errors parsing
  * the bank identifier or retreiving the specified bank.
@@ -321,21 +325,21 @@ extern flash_bank_t *get_flash_bank_by_num(int num);
  * @param bank On output, contians a pointer to the bank or NULL.
  * @returns ERROR_OK on success, or an error indicating the problem.
  */
-int flash_command_get_bank_by_num(
-	struct command_context_s *cmd_ctx, char *str, flash_bank_t **bank);
+int flash_command_get_bank_by_num(struct command_context_s *cmd_ctx,
+		char *str, flash_bank_t **bank);
 /**
  * Returns the flash bank like get_flash_bank_by_num(), without probing.
  * @param num The flash bank number.
  * @returns A flash_bank_t for flash bank @a num, or NULL.
  */
-extern flash_bank_t *get_flash_bank_by_num_noprobe(int num);
+flash_bank_t *get_flash_bank_by_num_noprobe(int num);
 /**
  * Returns the flash bank located at a specified address.
  * @param target The target, presumed to contain one or more banks.
  * @param addr An address that is within the range of the bank.
  * @returns The flash_bank_t located at @a addr, or NULL.
  */
-extern flash_bank_t *get_flash_bank_by_addr(struct target_s *target, uint32_t addr);
+flash_bank_t *get_flash_bank_by_addr(struct target_s *target, uint32_t addr);
 
 #define ERROR_FLASH_BANK_INVALID			(-900)
 #define ERROR_FLASH_SECTOR_INVALID			(-901)
diff --git a/src/flash/mflash.h b/src/flash/mflash.h
index bfaf743..1b54307 100644
--- a/src/flash/mflash.h
+++ b/src/flash/mflash.h
@@ -141,8 +141,8 @@ typedef struct mflash_bank_s
 	mg_drv_info_t *drv_info;
 } mflash_bank_t;
 
-extern int mflash_register_commands(struct command_context_s *cmd_ctx);
-extern int mflash_init_drivers(struct command_context_s *cmd_ctx);
+int mflash_register_commands(struct command_context_s *cmd_ctx);
+int mflash_init_drivers(struct command_context_s *cmd_ctx);
 
 #define MG_MFLASH_SECTOR_SIZE		(0x200)		/* 512Bytes = 2^9 */
 #define MG_MFLASH_SECTOR_SIZE_MASK	(0x200-1)
diff --git a/src/flash/nand.h b/src/flash/nand.h
index d867494..16558c2 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand.h
@@ -206,16 +206,23 @@ enum oob_formats
 	NAND_OOB_YAFFS2 = 0x100,/* when writing, use YAFFS2 OOB layout */
 };
 
-/* Function prototypes */
-extern nand_device_t *get_nand_device_by_num(int num);
-extern int nand_read_page_raw(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-extern int nand_write_page_raw(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-extern int nand_read_status(struct nand_device_s *device, uint8_t *status);
-extern int nand_calculate_ecc(struct nand_device_s *device, const uint8_t *dat, uint8_t *ecc_code);
-extern int nand_calculate_ecc_kw(struct nand_device_s *device, const uint8_t *dat, uint8_t *ecc_code);
-
-extern int nand_register_commands(struct command_context_s *cmd_ctx);
-extern int nand_init(struct command_context_s *cmd_ctx);
+
+nand_device_t *get_nand_device_by_num(int num);
+
+int nand_read_page_raw(struct nand_device_s *device, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+int nand_write_page_raw(struct nand_device_s *device, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+
+int nand_read_status(struct nand_device_s *device, uint8_t *status);
+
+int nand_calculate_ecc(struct nand_device_s *device,
+		const uint8_t *dat, uint8_t *ecc_code);
+int nand_calculate_ecc_kw(struct nand_device_s *device,
+		const uint8_t *dat, uint8_t *ecc_code);
+
+int nand_register_commands(struct command_context_s *cmd_ctx);
+int nand_init(struct command_context_s *cmd_ctx);
 
 /// helper for parsing a nand device command argument string
 int nand_command_get_device_by_num(struct command_context_s *cmd_ctx,
diff --git a/src/flash/non_cfi.h b/src/flash/non_cfi.h
index 48cee92..14a6df7 100644
--- a/src/flash/non_cfi.h
+++ b/src/flash/non_cfi.h
@@ -35,6 +35,6 @@ typedef struct non_cfi_s
 	uint8_t  status_poll_mask;
 } non_cfi_t;
 
-extern void cfi_fixup_non_cfi(flash_bank_t *bank);
+void cfi_fixup_non_cfi(flash_bank_t *bank);
 
 #endif /* NON_CFI_H */
diff --git a/src/flash/ocl/at91sam7x/dcc.h b/src/flash/ocl/at91sam7x/dcc.h
index f41b1d2..f7d6d22 100644
--- a/src/flash/ocl/at91sam7x/dcc.h
+++ b/src/flash/ocl/at91sam7x/dcc.h
@@ -23,9 +23,9 @@
 #include &quot;platform.h&quot;
 
 /* debug channel read (debugger-&gt;MCU) */
-extern uint32 dcc_rd(void);
+uint32 dcc_rd(void);
 
 /* debug channel write (MCU-&gt;debugger) */
-extern int dcc_wr(uint32 data);
+int dcc_wr(uint32 data);
 
 #endif
diff --git a/src/flash/ocl/at91sam7x/samflash.h b/src/flash/ocl/at91sam7x/samflash.h
index 136e314..f544942 100644
--- a/src/flash/ocl/at91sam7x/samflash.h
+++ b/src/flash/ocl/at91sam7x/samflash.h
@@ -34,15 +34,15 @@ extern unsigned int flash_page_count;
 extern unsigned int flash_page_size; /* words */
 
 /* detect chip and set loader parameters */
-extern int flash_init(void);
+int flash_init(void);
 
 /* program single flash page */
-extern int flash_page_program(uint32 *data, int page_num);
+int flash_page_program(uint32 *data, int page_num);
 
 /* erase whole chip */
-extern int flash_erase_all(void);
+int flash_erase_all(void);
 
 /* verify written data */
-extern int flash_verify(uint32 adr, unsigned int len, uint8 *src);
+int flash_verify(uint32 adr, unsigned int len, uint8 *src);
 
 #endif
diff --git a/src/flash/s3c24xx_nand.h b/src/flash/s3c24xx_nand.h
index fef34e4..0213df3 100644
--- a/src/flash/s3c24xx_nand.h
+++ b/src/flash/s3c24xx_nand.h
@@ -18,6 +18,9 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
+#ifndef S3C24xx_NAND_H
+#define S3C24xx_NAND_H
+
 /*
  * S3C24XX Series OpenOCD NAND Flash controller support.
  *
@@ -42,22 +45,32 @@ typedef struct s3c24xx_nand_controller_s
 #undef S3C2410_NFREG
 #define S3C2410_NFREG(x) ((x) + 0x4e000000)
 
-extern s3c24xx_nand_controller_t *s3c24xx_nand_device_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct nand_device_s *device);
+s3c24xx_nand_controller_t *s3c24xx_nand_device_command(
+			struct command_context_s *cmd_ctx, char *cmd,
+			char **args, int argc, struct nand_device_s *device);
+
+int s3c24xx_register_commands(struct command_context_s *cmd_ctx);
+
+int s3c24xx_reset(struct nand_device_s *device);
 
-extern int s3c24xx_register_commands(struct command_context_s *cmd_ctx);
-extern int s3c24xx_reset(struct nand_device_s *device);
-extern int s3c24xx_command(struct nand_device_s *device, uint8_t command);
-extern int s3c24xx_address(struct nand_device_s *device, uint8_t address);
-extern int s3c24xx_write_data(struct nand_device_s *device, uint16_t data);
-extern int s3c24xx_read_data(struct nand_device_s *device, void *data);
-extern int s3c24xx_controller_ready(struct nand_device_s *device, int tout);
+int s3c24xx_command(struct nand_device_s *device, uint8_t command);
+int s3c24xx_address(struct nand_device_s *device, uint8_t address);
+
+int s3c24xx_write_data(struct nand_device_s *device, uint16_t data);
+int s3c24xx_read_data(struct nand_device_s *device, void *data);
+
+int s3c24xx_controller_ready(struct nand_device_s *device, int tout);
 
 #define s3c24xx_write_page NULL
 #define s3c24xx_read_page NULL
 
 /* code shared between different controllers */
 
-extern int s3c2440_nand_ready(struct nand_device_s *device, int timeout);
+int s3c2440_nand_ready(struct nand_device_s *device, int timeout);
+
+int s3c2440_read_block_data(struct nand_device_s *device,
+		uint8_t *data, int data_size);
+int s3c2440_write_block_data(struct nand_device_s *device,
+		uint8_t *data, int data_size);
 
-extern int s3c2440_read_block_data(struct nand_device_s *, uint8_t *data, int data_size);
-extern int s3c2440_write_block_data(struct nand_device_s *, uint8_t *data, int data_size);
+#endif // S3C24xx_NAND_H

commit 5e9d18f027954c5f5e883934d6c54cb20817ea9f
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 9 02:53:22 2009 -0800

    src/jtag: remove 'extern' and wrap headers.
    
    Removes the 'extern' keyword from function declarations.
    Wraps long prototypes to fit into 80 columns.
    
    Fixes documentation for jtag_tap_s::{,has}idcode fields.

diff --git a/src/jtag/bitbang.h b/src/jtag/bitbang.h
index ee2e688..060b689 100644
--- a/src/jtag/bitbang.h
+++ b/src/jtag/bitbang.h
@@ -35,6 +35,6 @@ typedef struct bitbang_interface_s
 
 extern bitbang_interface_t *bitbang_interface;
 
-extern int bitbang_execute_queue(void);
+int bitbang_execute_queue(void);
 
 #endif /* BITBANG_H */
diff --git a/src/jtag/bitq.h b/src/jtag/bitq.h
index 6b441bf..15b2d5c 100644
--- a/src/jtag/bitq.h
+++ b/src/jtag/bitq.h
@@ -50,8 +50,8 @@ typedef struct bitq_state_s
 
 extern bitq_interface_t *bitq_interface;
 
-extern int bitq_execute_queue(void);
+int bitq_execute_queue(void);
 
-extern void bitq_cleanup(void);
+void bitq_cleanup(void);
 
 #endif /* BITQ_H */
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index ca09f92..c5bee07 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -165,9 +165,10 @@ struct jtag_tap_s
 	uint8_t* expected; /**&lt; Capture-IR expected value */
 	uint32_t ir_capture_mask;
 	uint8_t* expected_mask; /**&lt; Capture-IR expected mask */
-	uint32_t idcode;
-	bool hasidcode; /* not all devices have idcode, we'll discover this during chain examination */
-	/**&lt; device identification code */
+	uint32_t idcode; /**&lt; device identification code */
+	/** not all devices have idcode,
+	 * we'll discover this during chain examination */
+	bool hasidcode;
 
 	/// Array of expected identification codes */
 	uint32_t* expected_ids;
@@ -187,13 +188,13 @@ struct jtag_tap_s
 void jtag_tap_init(jtag_tap_t *tap);
 void jtag_tap_free(jtag_tap_t *tap);
 
-extern jtag_tap_t* jtag_all_taps(void);
-extern const char *jtag_tap_name(const jtag_tap_t *tap);
-extern jtag_tap_t* jtag_tap_by_string(const char* dotted_name);
-extern jtag_tap_t* jtag_tap_by_jim_obj(Jim_Interp* interp, Jim_Obj* obj);
-extern jtag_tap_t* jtag_tap_next_enabled(jtag_tap_t* p);
-extern unsigned jtag_tap_count_enabled(void);
-extern unsigned jtag_tap_count(void);
+jtag_tap_t* jtag_all_taps(void);
+const char *jtag_tap_name(const jtag_tap_t *tap);
+jtag_tap_t* jtag_tap_by_string(const char* dotted_name);
+jtag_tap_t* jtag_tap_by_jim_obj(Jim_Interp* interp, Jim_Obj* obj);
+jtag_tap_t* jtag_tap_next_enabled(jtag_tap_t* p);
+unsigned jtag_tap_count_enabled(void);
+unsigned jtag_tap_count(void);
 
 
 /*
@@ -245,10 +246,10 @@ struct jtag_tap_event_action_s
  */
 typedef int (*jtag_event_handler_t)(enum jtag_event event, void* priv);
 
-extern int jtag_register_event_callback(jtag_event_handler_t f, void *x);
-extern int jtag_unregister_event_callback(jtag_event_handler_t f, void *x);
+int jtag_register_event_callback(jtag_event_handler_t f, void *x);
+int jtag_unregister_event_callback(jtag_event_handler_t f, void *x);
 
-extern int jtag_call_event_callbacks(enum jtag_event event);
+int jtag_call_event_callbacks(enum jtag_event event);
 
 
 /// @returns The current JTAG speed setting.
@@ -328,21 +329,21 @@ bool jtag_will_verify_capture_ir(void);
  * Initialize interface upon startup.  Return a successful no-op upon
  * subsequent invocations.
  */
-extern int  jtag_interface_init(struct command_context_s* cmd_ctx);
+int  jtag_interface_init(struct command_context_s* cmd_ctx);
 
 /// Shutdown the JTAG interface upon program exit.
-extern int  jtag_interface_quit(void);
+int  jtag_interface_quit(void);
 
 /**
  * Initialize JTAG chain using only a RESET reset. If init fails,
  * try reset + init.
  */
-extern int  jtag_init(struct command_context_s* cmd_ctx);
+int  jtag_init(struct command_context_s* cmd_ctx);
 
 /// reset, then initialize JTAG chain
-extern int jtag_init_reset(struct command_context_s* cmd_ctx);
-extern int jtag_register_commands(struct command_context_s* cmd_ctx);
-extern int jtag_init_inner(struct command_context_s *cmd_ctx);
+int jtag_init_reset(struct command_context_s* cmd_ctx);
+int jtag_register_commands(struct command_context_s* cmd_ctx);
+int jtag_init_inner(struct command_context_s *cmd_ctx);
 
 /**
  * @file
@@ -369,18 +370,21 @@ extern int jtag_init_inner(struct command_context_s *cmd_ctx);
  * subsequent DR SCANs.
  *
  */
-extern void jtag_add_ir_scan(int num_fields, scan_field_t* fields, tap_state_t endstate);
+void jtag_add_ir_scan(int num_fields,
+		scan_field_t* fields, tap_state_t endstate);
 /**
  * The same as jtag_add_ir_scan except no verification is performed out
  * the output values.
  */
-extern void jtag_add_ir_scan_noverify(int num_fields, const scan_field_t *fields, tap_state_t state);
+void jtag_add_ir_scan_noverify(int num_fields,
+		const scan_field_t *fields, tap_state_t state);
 /**
  * Duplicate the scan fields passed into the function into an IR SCAN
  * command.  This function assumes that the caller handles extra fields
  * for bypassed TAPs.
  */
-extern void jtag_add_plain_ir_scan(int num_fields, const scan_field_t* fields, tap_state_t endstate);
+void jtag_add_plain_ir_scan(int num_fields,
+		const scan_field_t* fields, tap_state_t endstate);
 
 
 /**
@@ -392,7 +396,7 @@ extern void jtag_add_plain_ir_scan(int num_fields, const scan_field_t* fields, t
  * allocation method is used, for the synchronous case the temporary 32
  * bits come from the input field itself.
  */
-extern void jtag_alloc_in_value32(scan_field_t *field);
+void jtag_alloc_in_value32(scan_field_t *field);
 
 /**
  * Generate a DR SCAN using the fields passed to the function.
@@ -400,15 +404,18 @@ extern void jtag_alloc_in_value32(scan_field_t *field);
  * specified there.  For bypassed TAPs, the function generates a dummy
  * 1-bit field.  The bypass status of TAPs is set by jtag_add_ir_scan().
  */
-extern void jtag_add_dr_scan(int num_fields, const scan_field_t* fields, tap_state_t endstate);
+void jtag_add_dr_scan(int num_fields,
+		const scan_field_t* fields, tap_state_t endstate);
 /// A version of jtag_add_dr_scan() that uses the check_value/mask fields
-extern void jtag_add_dr_scan_check(int num_fields, scan_field_t* fields, tap_state_t endstate);
+void jtag_add_dr_scan_check(int num_fields,
+		scan_field_t* fields, tap_state_t endstate);
 /**
  * Duplicate the scan fields passed into the function into a DR SCAN
  * command.  Unlike jtag_add_dr_scan(), this function assumes that the
  * caller handles extra fields for bypassed TAPs.
  */
-extern void jtag_add_plain_dr_scan(int num_fields, const scan_field_t* fields, tap_state_t endstate);
+void jtag_add_plain_dr_scan(int num_fields,
+		const scan_field_t* fields, tap_state_t endstate);
 
 /**
  * Defines the type of data passed to the jtag_callback_t interface.
@@ -427,7 +434,7 @@ typedef intptr_t jtag_callback_data_t;
 typedef void (*jtag_callback1_t)(jtag_callback_data_t data0);
 
 /// A simpler version of jtag_add_callback4().
-extern void jtag_add_callback(jtag_callback1_t, jtag_callback_data_t data0);
+void jtag_add_callback(jtag_callback1_t, jtag_callback_data_t data0);
 
 
 
@@ -440,7 +447,10 @@ extern void jtag_add_callback(jtag_callback1_t, jtag_callback_data_t data0);
  * @param data3 An integer big enough to use as an @c int or a pointer.
  * @returns an error code
  */
-typedef int (*jtag_callback_t)(jtag_callback_data_t data0, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3);
+typedef int (*jtag_callback_t)(jtag_callback_data_t data0,
+				jtag_callback_data_t data1,
+				jtag_callback_data_t data2,
+				jtag_callback_data_t data3);
 
 
 /**
@@ -471,7 +481,7 @@ typedef int (*jtag_callback_t)(jtag_callback_data_t data0, jtag_callback_data_t
  * @param data3 An integer big enough to use as an @c int or a pointer.
  *
  */
-extern void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
+void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
 		jtag_callback_data_t data1, jtag_callback_data_t data2,
 		jtag_callback_data_t data3);
 
@@ -480,7 +490,7 @@ extern void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
  * Run a TAP_RESET reset where the end state is TAP_RESET,
  * regardless of the start state.
  */
-extern void jtag_add_tlr(void);
+void jtag_add_tlr(void);
 
 /**
  * Application code *must* assume that interfaces will
@@ -530,7 +540,7 @@ extern void jtag_add_tlr(void);
  *   - ERROR_JTAG_TRANSITION_INVALID -- The path includes invalid
  *     state transitions.
  */
-extern void jtag_add_pathmove(int num_states, const tap_state_t* path);
+void jtag_add_pathmove(int num_states, const tap_state_t* path);
 
 /**
  * jtag_add_statemove() moves from the current state to @a goal_state.
@@ -541,7 +551,7 @@ extern void jtag_add_pathmove(int num_states, const tap_state_t* path);
  * Moves from the current state to the goal \a state.
  * Both states must be stable.
  */
-extern int jtag_add_statemove(tap_state_t goal_state);
+int jtag_add_statemove(tap_state_t goal_state);
 
 /**
  * Goes to TAP_IDLE (if we're not already there), cycle
@@ -553,7 +563,7 @@ extern int jtag_add_statemove(tap_state_t goal_state);
  * 	via TAP_IDLE.
  * @param endstate The final state.
  */
-extern void jtag_add_runtest(int num_cycles, tap_state_t endstate);
+void jtag_add_runtest(int num_cycles, tap_state_t endstate);
 
 /**
  * A reset of the TAP state machine can be requested.
@@ -578,7 +588,7 @@ extern void jtag_add_runtest(int num_cycles, tap_state_t endstate);
  * are undefined, but when srst_pulls_trst or vice versa,
  * then trst &amp; srst *must* be asserted together.
  */
-extern void jtag_add_reset(int req_tlr_or_trst, int srst);
+void jtag_add_reset(int req_tlr_or_trst, int srst);
 
 
 /**
@@ -589,15 +599,15 @@ extern void jtag_add_reset(int req_tlr_or_trst, int srst);
  * Return the value of the global variable.
  *
  **/
-extern tap_state_t jtag_set_end_state(tap_state_t state);
+tap_state_t jtag_set_end_state(tap_state_t state);
 /**
  * Function jtag_get_end_state
  *
  * Return the value of the global variable for end state
  *
  **/
-extern tap_state_t jtag_get_end_state(void);
-extern void jtag_add_sleep(uint32_t us);
+tap_state_t jtag_get_end_state(void);
+void jtag_add_sleep(uint32_t us);
 
 
 /**
@@ -628,10 +638,10 @@ void jtag_add_clocks(int num_cycles);
  * jtag_add_xxx() commands can either be executed immediately or
  * at some time between the jtag_add_xxx() fn call and jtag_execute_queue().
  */
-extern int jtag_execute_queue(void);
+int jtag_execute_queue(void);
 
 /// same as jtag_execute_queue() but does not clear the error flag
-extern void jtag_execute_queue_noclear(void);
+void jtag_execute_queue_noclear(void);
 
 /// @returns the number of times the scan queue has been flushed
 int jtag_get_flush_queue_count(void);
@@ -641,8 +651,8 @@ void jtag_notify_event(enum jtag_event);
 
 
 /* can be implemented by hw + sw */
-extern int jtag_power_dropout(int* dropout);
-extern int jtag_srst_asserted(int* srst_asserted);
+int jtag_power_dropout(int* dropout);
+int jtag_srst_asserted(int* srst_asserted);
 
 /* JTAG support functions */
 
@@ -653,9 +663,9 @@ extern int jtag_srst_asserted(int* srst_asserted);
  * @param mask Pointer to scan mask; may be NULL.
  * @returns Nothing, but calls jtag_set_error() on any error.
  */
-extern void jtag_check_value_mask(scan_field_t *field, uint8_t *value, uint8_t *mask);
+void jtag_check_value_mask(scan_field_t *field, uint8_t *value, uint8_t *mask);
 
-extern void jtag_sleep(uint32_t us);
+void jtag_sleep(uint32_t us);
 
 /*
  * The JTAG subsystem defines a number of error codes,
@@ -698,7 +708,7 @@ extern void jtag_sleep(uint32_t us);
  * There is no jtag_add_dr_outin() version of this fn that also allows
  * clocking data back in. Patches gladly accepted!
  */
-extern void jtag_add_dr_out(jtag_tap_t* tap,
+void jtag_add_dr_out(jtag_tap_t* tap,
 		int num_fields, const int* num_bits, const uint32_t* value,
 		tap_state_t end_state);
 
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index b7c01ab..57d1d6e 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -81,35 +81,35 @@ static inline void interface_jtag_add_scan_check_alloc(scan_field_t *field)
 	field-&gt;in_value = (uint8_t *)cmd_queue_alloc(num_bytes);
 }
 
-extern void interface_jtag_add_dr_out(jtag_tap_t* tap,
+void interface_jtag_add_dr_out(jtag_tap_t* tap,
 		int num_fields, const int* num_bits, const uint32_t* value,
 		tap_state_t end_state);
 
-extern void interface_jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0);
+void interface_jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0);
 
-extern void interface_jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
+void interface_jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
 		jtag_callback_data_t data1, jtag_callback_data_t data2,
 		jtag_callback_data_t data3);
 
 #endif
 
-extern int interface_jtag_add_ir_scan(
+int interface_jtag_add_ir_scan(
 		int num_fields, const scan_field_t* fields,
 		tap_state_t endstate);
-extern int interface_jtag_add_plain_ir_scan(
+int interface_jtag_add_plain_ir_scan(
 		int num_fields, const scan_field_t* fields,
 		tap_state_t endstate);
 
-extern int interface_jtag_add_dr_scan(
+int interface_jtag_add_dr_scan(
 		int num_fields, const scan_field_t* fields,
 		tap_state_t endstate);
-extern int interface_jtag_add_plain_dr_scan(
+int interface_jtag_add_plain_dr_scan(
 		int num_fields, const scan_field_t* fields,
 		tap_state_t endstate);
 
-extern int interface_jtag_add_tlr(void);
-extern int interface_jtag_add_pathmove(int num_states, const tap_state_t* path);
-extern int interface_jtag_add_runtest(int num_cycles, tap_state_t endstate);
+int interface_jtag_add_tlr(void);
+int interface_jtag_add_pathmove(int num_states, const tap_state_t* path);
+int interface_jtag_add_runtest(int num_cycles, tap_state_t endstate);
 
 /**
  * This drives the actual srst and trst pins. srst will always be 0
@@ -119,16 +119,15 @@ extern int interface_jtag_add_runtest(int num_cycles, tap_state_t endstate);
  * the higher level jtag_add_reset will invoke jtag_add_tlr() if
  * approperiate
  */
-extern int interface_jtag_add_reset(int trst, int srst);
-extern int interface_jtag_add_sleep(uint32_t us);
-extern int interface_jtag_add_clocks(int num_cycles);
-extern int interface_jtag_execute_queue(void);
+int interface_jtag_add_reset(int trst, int srst);
+int interface_jtag_add_sleep(uint32_t us);
+int interface_jtag_add_clocks(int num_cycles);
+int interface_jtag_execute_queue(void);
 
 /**
  * Calls the interface callback to execute the queue.  This routine
  * is used by the JTAG driver layer and should not be called directly.
  */
-extern int default_interface_jtag_execute_queue(void);
-
+int default_interface_jtag_execute_queue(void);
 
 #endif // MINIDRIVER_H

commit 1712d7835e0fbba60d578b52b21b95b046805757
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Mon Nov 9 02:47:00 2009 -0800

    src/helper: wrap and clean headers.
    
    Remove all useless 'extern' keywords from function prototypes.
    Wraps long lines for readability.

diff --git a/src/helper/binarybuffer.h b/src/helper/binarybuffer.h
index eef4057..5017a35 100644
--- a/src/helper/binarybuffer.h
+++ b/src/helper/binarybuffer.h
@@ -30,7 +30,8 @@
  */
 
 /* inlining this will help show what fn that is taking time during profiling. */
-static inline void buf_set_u32(uint8_t* buffer, unsigned int first, unsigned int num, uint32_t value)
+static inline void buf_set_u32(uint8_t* buffer,
+		unsigned int first, unsigned int num, uint32_t value)
 {
 	if ((num == 32) &amp;&amp; (first == 0))
 	{
@@ -51,13 +52,16 @@ static inline void buf_set_u32(uint8_t* buffer, unsigned int first, unsigned int
 		}
 	}
 }
-static inline uint32_t buf_get_u32(const uint8_t* buffer, unsigned int first, unsigned int num)
+static inline uint32_t buf_get_u32(const uint8_t* buffer,
+		unsigned int first, unsigned int num)
 {
 	if ((num == 32) &amp;&amp; (first == 0))
 	{
-		return (((uint32_t)buffer[3]) &lt;&lt; 24) | (((uint32_t)buffer[2]) &lt;&lt; 16) | (((uint32_t)buffer[1]) &lt;&lt; 8) | (((uint32_t)buffer[0]) &lt;&lt; 0);
-	} else
-	{
+		return (((uint32_t)buffer[3]) &lt;&lt; 24) |
+			(((uint32_t)buffer[2]) &lt;&lt; 16) |
+			(((uint32_t)buffer[1]) &lt;&lt; 8) |
+			(((uint32_t)buffer[0]) &lt;&lt; 0);
+	} else {
 		uint32_t result = 0;
 		unsigned int i;
 
@@ -71,30 +75,30 @@ static inline uint32_t buf_get_u32(const uint8_t* buffer, unsigned int first, un
 	}
 }
 
-extern uint32_t flip_u32(uint32_t value, unsigned int num);
+uint32_t flip_u32(uint32_t value, unsigned int num);
 
-extern int buf_cmp(const uint8_t *buf1, const uint8_t *buf2, int size);
-extern int buf_cmp_mask(const uint8_t *buf1, const uint8_t *buf2, const uint8_t *mask, int size);
-extern uint8_t* buf_cpy(const uint8_t *from, uint8_t *to, int size);
+int buf_cmp(const uint8_t *buf1, const uint8_t *buf2, int size);
+int buf_cmp_mask(const uint8_t *buf1, const uint8_t *buf2,
+		const uint8_t *mask, int size);
+uint8_t* buf_cpy(const uint8_t *from, uint8_t *to, int size);
 
-extern uint8_t* buf_set_ones(uint8_t *buf, int count);
-extern uint8_t* buf_set_buf(const uint8_t *src, int src_start, uint8_t *dst, int dst_start, int len);
+uint8_t* buf_set_ones(uint8_t *buf, int count);
+uint8_t* buf_set_buf(const uint8_t *src, int src_start,
+		uint8_t *dst, int dst_start, int len);
 
-extern int str_to_buf(const char *str, int len, uint8_t *bin_buf, int buf_size, int radix);
-extern char* buf_to_str(const uint8_t *buf, int size, int radix);
+int str_to_buf(const char *str, int len,
+		uint8_t *bin_buf, int buf_size, int radix);
+char* buf_to_str(const uint8_t *buf, int size, int radix);
 
 struct scan_field_s;
-extern int buf_to_u32_handler(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int buf_to_u32_handler(uint8_t *in_buf, void *priv, struct scan_field_s *field);
 
 #define CEIL(m, n)	(((m) + (n) - 1) / (n))
 
 /* read a uint32_t from a buffer in target memory endianness */
-static inline uint32_t fast_target_buffer_get_u32(const uint8_t *buffer, int little)
+static inline uint32_t fast_target_buffer_get_u32(const uint8_t *p, int le)
 {
-	if (little)
-		return le_to_h_u32(buffer);
-	else
-		return be_to_h_u32(buffer);
+	return le ? le_to_h_u32(p) : be_to_h_u32(p);
 }
 
 #endif /* BINARYBUFFER_H */
diff --git a/src/helper/command.h b/src/helper/command.h
index 2d0142f..70b00c3 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -84,25 +84,36 @@ typedef struct command_s
 	struct command_s *next;
 } command_t;
 
-extern command_t* register_command(command_context_t *context, command_t *parent, char *name, int (*handler)(struct command_context_s *context, char* name, char** args, int argc), enum command_mode mode, char *help);
-extern int unregister_command(command_context_t *context, char *name);
-extern int unregister_all_commands(command_context_t *context);
-extern void command_set_output_handler(command_context_t* context, int (*output_handler)(struct command_context_s *context, const char* line), void *priv);
-extern command_context_t* copy_command_context(command_context_t* context);
-extern int command_context_mode(command_context_t *context, enum command_mode mode);
-extern command_context_t* command_init(void);
-extern int command_done(command_context_t *context);
-
-extern void command_print(command_context_t *context, const char *format, ...)
+command_t* register_command(command_context_t *context,
+		command_t *parent, char *name,
+		int (*handler)(struct command_context_s *context,
+				char* name, char** args, int argc),
+		enum command_mode mode, char *help);
+
+int unregister_command(command_context_t *context, char *name);
+int unregister_all_commands(command_context_t *context);
+
+void command_set_output_handler(command_context_t* context,
+		int (*output_handler)(struct command_context_s *context,
+		const char* line), void *priv);
+
+command_context_t* copy_command_context(command_context_t* context);
+
+int command_context_mode(command_context_t *context, enum command_mode mode);
+
+command_context_t* command_init(void);
+int command_done(command_context_t *context);
+
+void command_print(command_context_t *context, const char *format, ...)
 		__attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 2, 3)));
-extern void command_print_sameline(command_context_t *context, const char *format, ...)
+void command_print_sameline(command_context_t *context, const char *format, ...)
 		__attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 2, 3)));
-extern int command_run_line(command_context_t *context, char *line);
-extern int command_run_linef(command_context_t *context, const char *format, ...)
+int command_run_line(command_context_t *context, char *line);
+int command_run_linef(command_context_t *context, const char *format, ...)
 		__attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 2, 3)));
-extern void command_output_text(command_context_t *context, const char *data);
+void command_output_text(command_context_t *context, const char *data);
 
-extern void process_jim_events(void);
+void process_jim_events(void);
 
 #define		ERROR_COMMAND_CLOSE_CONNECTION		(-600)
 #define		ERROR_COMMAND_SYNTAX_ERROR			(-601)
diff --git a/src/helper/configuration.h b/src/helper/configuration.h
index 16bd8d8..5d60148 100644
--- a/src/helper/configuration.h
+++ b/src/helper/configuration.h
@@ -25,12 +25,19 @@
 
 #include &quot;command.h&quot;
 
-extern int parse_cmdline_args(struct command_context_s *cmd_ctx, int argc, char *argv[]);
-extern int parse_config_file(struct command_context_s *cmd_ctx);
-extern void add_config_command (const char *cfg);
-extern void add_script_search_dir (const char *dir);
-extern int configuration_output_handler(struct command_context_s *context, const char* line);
-extern FILE *open_file_from_path (char *file, char *mode);
-extern char *find_file(const char *name);
+int parse_cmdline_args(struct command_context_s *cmd_ctx,
+		int argc, char *argv[]);
+
+int parse_config_file(struct command_context_s *cmd_ctx);
+void add_config_command(const char *cfg);
+
+void add_script_search_dir(const char *dir);
+
+int configuration_output_handler(struct command_context_s *cmd_ctx,
+		const char *line);
+
+FILE *open_file_from_path(char *file, char *mode);
+
+char *find_file(const char *name);
 
 #endif /* CONFIGURATION_H */
diff --git a/src/helper/fileio.h b/src/helper/fileio.h
index d1e227c..3f47cb9 100644
--- a/src/helper/fileio.h
+++ b/src/helper/fileio.h
@@ -54,14 +54,20 @@ typedef struct fileio_s
 	FILE *file;
 } fileio_t;
 
-extern int fileio_write(fileio_t *fileio, uint32_t size, const uint8_t *buffer, uint32_t *size_written);
-extern int fileio_read(fileio_t *fileio, uint32_t size, uint8_t *buffer, uint32_t *size_read);
-extern int fileio_fgets(fileio_t *fileio, uint32_t size, char *buffer);
-extern int fileio_seek(fileio_t *fileio, uint32_t position);
-extern int fileio_close(fileio_t *fileio);
-extern int fileio_open(fileio_t *fileio, const char *url, enum fileio_access access, enum fileio_type type);
-extern int fileio_read_u32(fileio_t *fileio, uint32_t *data);
-extern int fileio_write_u32(fileio_t *fileio, uint32_t data);
+int fileio_open(fileio_t *fileio,
+	const char *url, enum fileio_access access, enum fileio_type type);
+int fileio_close(fileio_t *fileio);
+
+int fileio_seek(fileio_t *fileio, uint32_t position);
+int fileio_fgets(fileio_t *fileio, uint32_t size, char *buffer);
+
+int fileio_read(fileio_t *fileio,
+		uint32_t size, uint8_t *buffer, uint32_t *size_read);
+int fileio_write(fileio_t *fileio,
+		uint32_t size, const uint8_t *buffer, uint32_t *size_written);
+
+int fileio_read_u32(fileio_t *fileio, uint32_t *data);
+int fileio_write_u32(fileio_t *fileio, uint32_t data);
 
 #define ERROR_FILEIO_LOCATION_UNKNOWN	(-1200)
 #define ERROR_FILEIO_NOT_FOUND			(-1201)
diff --git a/src/helper/log.h b/src/helper/log.h
index f43e1e6..15bd3c8 100644
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -59,20 +59,23 @@ enum log_levels
 	LOG_LVL_DEBUG = 3
 };
 
-extern void log_printf(enum log_levels level, const char *file, int line,
+void log_printf(enum log_levels level, const char *file, int line,
 	const char *function, const char *format, ...)
 __attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 5, 6)));
-extern void log_printf_lf(enum log_levels level, const char *file, int line,
+void log_printf_lf(enum log_levels level, const char *file, int line,
 	const char *function, const char *format, ...)
 __attribute__ ((format (PRINTF_ATTRIBUTE_FORMAT, 5, 6)));
-extern int log_register_commands(struct command_context_s *cmd_ctx);
-extern int log_init(struct command_context_s *cmd_ctx);
-extern int set_log_output(struct command_context_s *cmd_ctx, FILE *output);
-extern void keep_alive(void);
-extern void kept_alive(void);
-extern void alive_sleep(int ms);
-extern void busy_sleep(int ms);
 
+int log_init(struct command_context_s *cmd_ctx);
+int set_log_output(struct command_context_s *cmd_ctx, FILE *output);
+
+int log_register_commands(struct command_context_s *cmd_ctx);
+
+void keep_alive(void);
+void kept_alive(void);
+
+void alive_sleep(int ms);
+void busy_sleep(int ms);
 
 /* log entries can be paused and replayed roughly according to the try/catch/rethrow
  * concepts in C++
@@ -92,8 +95,8 @@ typedef struct log_callback_s
 	struct log_callback_s *next;
 } log_callback_t;
 
-extern int log_add_callback(log_callback_fn fn, void *priv);
-extern int log_remove_callback(log_callback_fn fn, void *priv);
+int log_add_callback(log_callback_fn fn, void *priv);
+int log_remove_callback(log_callback_fn fn, void *priv);
 
 char *alloc_vprintf(const char *fmt, va_list ap);
 char *alloc_printf(const char *fmt, ...);
diff --git a/src/helper/replacements.h b/src/helper/replacements.h
index f2c6e94..a029674 100644
--- a/src/helper/replacements.h
+++ b/src/helper/replacements.h
@@ -65,7 +65,8 @@ struct timezone {
 #endif
 struct timezone;
 
-extern int gettimeofday(struct timeval *tv, struct timezone *tz);
+int gettimeofday(struct timeval *tv, struct timezone *tz);
+
 #endif
 
 #ifndef IN_REPLACEMENTS_C
@@ -105,11 +106,11 @@ void *fill_malloc(size_t size);
 
 /* GNU extensions to the C library that may be missing on some systems */
 #ifndef HAVE_STRNDUP
-extern char* strndup(const char *s, size_t n);
+char* strndup(const char *s, size_t n);
 #endif /* HAVE_STRNDUP */
 
 #ifndef HAVE_STRNLEN
-extern size_t strnlen(const char *s, size_t maxlen);
+size_t strnlen(const char *s, size_t maxlen);
 #endif /* HAVE_STRNLEN */
 
 #ifndef HAVE_USLEEP

-----------------------------------------------------------------------

Summary of changes:
 src/flash/flash.h                  |   34 ++++++----
 src/flash/mflash.h                 |    4 +-
 src/flash/nand.h                   |   27 +++++---
 src/flash/non_cfi.h                |    2 +-
 src/flash/ocl/at91sam7x/dcc.h      |    4 +-
 src/flash/ocl/at91sam7x/samflash.h |    8 +-
 src/flash/s3c24xx_nand.h           |   35 +++++++---
 src/helper/binarybuffer.h          |   42 +++++++------
 src/helper/command.h               |   39 +++++++----
 src/helper/configuration.h         |   21 ++++--
 src/helper/fileio.h                |   22 ++++--
 src/helper/log.h                   |   25 ++++---
 src/helper/replacements.h          |    7 +-
 src/jtag/bitbang.h                 |    2 +-
 src/jtag/bitq.h                    |    4 +-
 src/jtag/jtag.h                    |   98 +++++++++++++++-------------
 src/jtag/minidriver.h              |   31 ++++-----
 src/pld/pld.h                      |    8 ++-
 src/server/gdb_server.h            |    4 +-
 src/server/server.h                |   16 +++--
 src/server/tcl_server.h            |    4 +-
 src/server/telnet_server.h         |    4 +-
 src/svf/svf.h                      |    6 +-
 src/target/algorithm.h             |   11 ++-
 src/target/arm926ejs.h             |   12 ++--
 src/target/arm966e.h               |    7 +-
 src/target/arm9tdmi.h              |   48 +++++++-------
 src/target/arm_adi_v5.h            |   55 +++++++++-------
 src/target/arm_disassembler.h      |   10 ++-
 src/target/arm_jtag.h              |    7 +-
 src/target/arm_simulator.h         |    7 +-
 src/target/armv4_5.h               |   20 ++++--
 src/target/armv4_5_cache.h         |    9 ++-
 src/target/armv4_5_mmu.h           |   14 +++-
 src/target/armv7m.h                |   33 ++++++----
 src/target/breakpoints.h           |   19 ++++--
 src/target/cortex_a8.h             |   11 ++-
 src/target/embeddedice.h           |   30 ++++++---
 src/target/etb.h                   |    2 +-
 src/target/etm.h                   |    6 +-
 src/target/image.h                 |   14 +++--
 src/target/mips32.h                |   40 ++++++++----
 src/target/mips32_dmaacc.h         |   24 +++++--
 src/target/mips32_pracc.h          |   38 +++++++----
 src/target/mips_ejtag.h            |   19 +++---
 src/target/mips_m4k.h              |   26 ++++----
 src/target/register.h              |   13 ++--
 src/target/target.h                |  125 +++++++++++++++++++++---------------
 src/target/target_request.h        |    7 +-
 src/target/trace.h                 |    4 +-
 src/xsvf/xsvf.h                    |    2 +-
 51 files changed, 629 insertions(+), 431 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001744.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-101-g4882647
</A></li>
	<LI>Next message: <A HREF="001746.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-108-g9253ce9
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1745">[ date ]</a>
              <a href="thread.html#1745">[ thread ]</a>
              <a href="subject.html#1745">[ subject ]</a>
              <a href="author.html#1745">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
