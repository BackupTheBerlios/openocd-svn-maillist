<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-517-gdd9894f
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-517-gdd9894f&In-Reply-To=%3CE1NCApm-0001DP-2c%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001835.html">
   <LINK REL="Next"  HREF="001837.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-517-gdd9894f</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-517-gdd9894f&In-Reply-To=%3CE1NCApm-0001DP-2c%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-517-gdd9894f">dbrownell at users.sourceforge.net
       </A><BR>
    <I>Sun Nov 22 12:42:23 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001835.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-513-gb58239e
</A></li>
        <LI>Next message: <A HREF="001837.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-518-gd1fbcc3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1836">[ date ]</a>
              <a href="thread.html#1836">[ thread ]</a>
              <a href="subject.html#1836">[ subject ]</a>
              <a href="author.html#1836">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  dd9894f481d127266c201d7075ecbdd34b034124 (commit)
       via  ff810723e051ed1f86cffcb565ade6b4d1fc50c8 (commit)
       via  5706fd7860ea01c591ecf74880a5a5e04e6df22e (commit)
       via  60a2d85af1afbc207ae5fb9dafdbe4c8b49ad5bb (commit)
      from  b58239e4c03c440ac89b36c9de917224a8439332 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dd9894f481d127266c201d7075ecbdd34b034124
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Nov 22 03:41:14 2009 -0800

    ARM: arm_set_cpsr() handles T and J bits
    
    Have arm_set_cpsr() handle the two core state flags, updating
    the CPU state.  This eliminates code in various debug_entry()
    paths, and marginally improves handling of the J bit.
    
    Catch and comment a few holes in the handling of the J bit on
    ARM926ejs cores ... it's unlikely our users will care about
    Jazelle mode, but we can at least warn of Impending Doom.  If
    anyone does use it, these breadcrumbs may help them to find
    the right path through the code.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index ac7e488..3aa77ea 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -354,7 +354,6 @@ static int arm720t_soft_reset_halt(struct target *target)
 	cpsr |= 0xd3;
 	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 9580f62..19fe98d 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1223,6 +1223,8 @@ int arm7_9_soft_reset_halt(struct target *target)
 		arm7_9-&gt;change_to_arm(target, &amp;r0_thumb, &amp;pc_thumb);
 	}
 
+	/* REVISIT likewise for bit 5 -- switch Jazelle-to-ARM */
+
 	/* all register content is now invalid */
 	register_cache_invalidate(armv4_5-&gt;core_cache);
 
@@ -1234,7 +1236,6 @@ int arm7_9_soft_reset_halt(struct target *target)
 	cpsr |= 0xd3;
 	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
@@ -1334,7 +1335,7 @@ static int arm7_9_debug_entry(struct target *target)
 	uint32_t context[16];
 	uint32_t* context_p[16];
 	uint32_t r0_thumb, pc_thumb;
-	uint32_t cpsr;
+	uint32_t cpsr, cpsr_mask = 0;
 	int retval;
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct armv4_5_common_s *armv4_5 = &amp;arm7_9-&gt;armv4_5_common;
@@ -1379,11 +1380,21 @@ static int arm7_9_debug_entry(struct target *target)
 		LOG_DEBUG(&quot;target entered debug from Thumb state&quot;);
 		/* Entered debug from Thumb mode */
 		armv4_5-&gt;core_state = ARMV4_5_STATE_THUMB;
+		cpsr_mask = 1 &lt;&lt; 5;
 		arm7_9-&gt;change_to_arm(target, &amp;r0_thumb, &amp;pc_thumb);
-		LOG_DEBUG(&quot;r0_thumb: 0x%8.8&quot; PRIx32 &quot;, pc_thumb: 0x%8.8&quot; PRIx32 &quot;&quot;, r0_thumb, pc_thumb);
-	}
-	else
-	{
+		LOG_DEBUG(&quot;r0_thumb: 0x%8.8&quot; PRIx32
+			&quot;, pc_thumb: 0x%8.8&quot; PRIx32, r0_thumb, pc_thumb);
+	} else if (buf_get_u32(dbg_stat-&gt;value, 5, 1)) {
+		/* \todo Get some vaguely correct handling of Jazelle, if
+		 * anyone ever uses it and full info becomes available.
+		 * See ARM9EJS TRM B.7.1 for how to switch J-&gt;ARM; and
+		 * B.7.3 for the reverse.  That'd be the bare minimum...
+		 */
+		LOG_DEBUG(&quot;target entered debug from Jazelle state&quot;);
+		armv4_5-&gt;core_state = ARMV4_5_STATE_JAZELLE;
+		cpsr_mask = 1 &lt;&lt; 24;
+		LOG_ERROR(&quot;Jazelle debug entry -- BROKEN!&quot;);
+	} else {
 		LOG_DEBUG(&quot;target entered debug from ARM state&quot;);
 		/* Entered debug from ARM mode */
 		armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
@@ -1399,11 +1410,10 @@ static int arm7_9_debug_entry(struct target *target)
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
-	/* if the core has been executing in Thumb state, set the T bit */
-	if (armv4_5-&gt;core_state == ARMV4_5_STATE_THUMB)
-		cpsr |= 0x20;
-
-	arm_set_cpsr(armv4_5, cpsr);
+	/* Sync our CPSR copy with J or T bits EICE reported, but
+	 * which we then erased by putting the core into ARM mode.
+	 */
+	arm_set_cpsr(armv4_5, cpsr | cpsr_mask);
 
 	if (!is_arm_mode(armv4_5-&gt;core_mode))
 	{
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 739df3e..8a03554 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -603,7 +603,6 @@ int arm920t_soft_reset_halt(struct target *target)
 	cpsr |= 0xd3;
 	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 7ecc782..aa29989 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -572,7 +572,6 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	cpsr |= 0xd3;
 	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 3156c66..22e1186 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -372,6 +372,24 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 	arm-&gt;spsr = (mode == ARMV4_5_MODE_USR || mode == ARMV4_5_MODE_SYS)
 			? NULL
 			: arm-&gt;core_cache-&gt;reg_list + arm-&gt;map[16];
+
+	/* Older ARMs won't have the J bit */
+	enum armv4_5_state state;
+
+	if (cpsr &amp; (1 &lt;&lt; 5)) {	/* T */
+		if (cpsr &amp; (1 &lt;&lt; 24)) {	/* J */
+			LOG_WARNING(&quot;ThumbEE -- incomplete support&quot;);
+			state = ARM_STATE_THUMB_EE;
+		} else
+			state = ARMV4_5_STATE_THUMB;
+	} else {
+		if (cpsr &amp; (1 &lt;&lt; 24)) {	/* J */
+			LOG_ERROR(&quot;Jazelle state handling is BROKEN!&quot;);
+			state = ARMV4_5_STATE_JAZELLE;
+		} else
+			state = ARMV4_5_STATE_ARM;
+	}
+	arm-&gt;core_state = state;
 }
 
 /**
@@ -481,49 +499,27 @@ static int armv4_5_set_core_reg(struct reg *reg, uint8_t *buf)
 	/* Except for CPSR, the &quot;reg&quot; command exposes a writeback model
 	 * for the register cache.
 	 */
-	buf_set_u32(reg-&gt;value, 0, 32, value);
-	reg-&gt;dirty = 1;
-	reg-&gt;valid = 1;
+	if (reg == armv4_5_target-&gt;cpsr) {
+		arm_set_cpsr(armv4_5_target, value);
 
-	if (reg == armv4_5_target-&gt;cpsr)
-	{
-		/* FIXME handle J bit too; mostly for ThumbEE, also Jazelle */
-		if (value &amp; 0x20)
-		{
-			/* T bit should be set */
-			if (armv4_5_target-&gt;core_state == ARMV4_5_STATE_ARM)
-			{
-				/* change state to Thumb */
-				LOG_DEBUG(&quot;changing to Thumb state&quot;);
-				armv4_5_target-&gt;core_state = ARMV4_5_STATE_THUMB;
-			}
-		}
-		else
-		{
-			/* T bit should be cleared */
-			if (armv4_5_target-&gt;core_state == ARMV4_5_STATE_THUMB)
-			{
-				/* change state to ARM */
-				LOG_DEBUG(&quot;changing to ARM state&quot;);
-				armv4_5_target-&gt;core_state = ARMV4_5_STATE_ARM;
-			}
-		}
-
-		/* REVISIT Why only update core for mode change, not also
-		 * for state changes?  Possibly older cores need to stay
-		 * in ARM mode during halt mode debug, not execute Thumb;
-		 * v6/v7a/v7r seem to do that automatically...
+		/* Older cores need help to be in ARM mode during halt
+		 * mode debug, so we clear the J and T bits if we flush.
+		 * For newer cores (v6/v7a/v7r) we don't need that, but
+		 * it won't hurt since CPSR is always flushed anyway.
 		 */
-
-		if (armv4_5_target-&gt;core_mode != (enum armv4_5_mode)(value &amp; 0x1f))
-		{
+		if (armv4_5_target-&gt;core_mode !=
+				(enum armv4_5_mode)(value &amp; 0x1f)) {
 			LOG_DEBUG(&quot;changing ARM core mode to '%s'&quot;,
 					arm_mode_name(value &amp; 0x1f));
+			value &amp;= ~((1 &lt;&lt; 24) | (1 &lt;&lt; 5));
 			armv4_5_target-&gt;write_core_reg(target, reg,
 					16, ARMV4_5_MODE_ANY, value);
-			arm_set_cpsr(armv4_5_target, value);
 		}
+	} else {
+		buf_set_u32(reg-&gt;value, 0, 32, value);
+		reg-&gt;valid = 1;
 	}
+	reg-&gt;dirty = 1;
 
 	return ERROR_OK;
 }
@@ -1240,7 +1236,6 @@ int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 
 	armv4_5-&gt;common_magic = ARMV4_5_COMMON_MAGIC;
 	arm_set_cpsr(armv4_5, ARMV4_5_MODE_USR);
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* core_type may be overridden by subtype logic */
 	armv4_5-&gt;core_type = ARMV4_5_MODE_ANY;
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 71de3b7..fa26b6a 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -650,29 +650,6 @@ static int cortex_a8_debug_entry(struct target *target)
 
 	arm_set_cpsr(armv4_5, cpsr);
 
-	i = (cpsr &gt;&gt; 5) &amp; 1;	/* T */
-	i |= (cpsr &gt;&gt; 23) &amp; 1;	/* J &lt;&lt; 1 */
-	switch (i) {
-	case 0:	/* J = 0, T = 0 */
-		armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-		break;
-	case 1:	/* J = 0, T = 1 */
-		armv4_5-&gt;core_state = ARMV4_5_STATE_THUMB;
-		break;
-	case 2:	/* J = 1, T = 0 */
-		LOG_WARNING(&quot;Jazelle state -- not handled&quot;);
-		armv4_5-&gt;core_state = ARMV4_5_STATE_JAZELLE;
-		break;
-	case 3:	/* J = 1, T = 1 */
-		/* ThumbEE is very much like Thumb, but some of the
-		 * instructions are different.  Single stepping and
-		 * breakpoints need updating...
-		 */
-		LOG_WARNING(&quot;ThumbEE -- incomplete support&quot;);
-		armv4_5-&gt;core_state = ARM_STATE_THUMB_EE;
-		break;
-	}
-
 	/* update cache */
 	for (i = 0; i &lt;= ARM_PC; i++)
 	{
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 659caec..e8a3e49 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -960,12 +960,6 @@ static int xscale_debug_entry(struct target *target)
 	LOG_DEBUG(&quot;target entered debug state in %s mode&quot;,
 			 arm_mode_name(armv4_5-&gt;core_mode));
 
-	if (buffer[9] &amp; 0x20)
-		armv4_5-&gt;core_state = ARMV4_5_STATE_THUMB;
-	else
-		armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-
-
 	/* get banked registers, r8 to r14, and spsr if not in USR/SYS mode */
 	if ((armv4_5-&gt;core_mode != ARMV4_5_MODE_USR) &amp;&amp; (armv4_5-&gt;core_mode != ARMV4_5_MODE_SYS))
 	{

commit ff810723e051ed1f86cffcb565ade6b4d1fc50c8
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Nov 22 03:38:34 2009 -0800

    ARM: define two register utilities
    
    Define arm_reg_current() ... returning handle to a given register,
    and encapsulating the current mode's register shadowing.  It's got
    one current use, for reporting the current register set to GDB.
    This will let later patches clean up much ARMV4_5_CORE_REG_MODE()
    nastiness, saving a bit of code.
    
    Define and use arm_set_cpsr() ... initially it updates the cached
    CPSR and sets up state used by arm_reg_current(), plus any SPSR
    handle.   (Later: can also set up for T and J bits.)
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 4768f82..ac7e488 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -347,18 +347,20 @@ static int arm720t_soft_reset_halt(struct target *target)
 	target-&gt;state = TARGET_HALTED;
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	uint32_t cpsr;
+
+	cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32);
+	cpsr &amp;= ~0xff;
+	cpsr |= 0xd3;
+	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;cpsr-&gt;valid = 1;
+	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
 	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
 
-	armv4_5-&gt;core_mode = ARMV4_5_MODE_SVC;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-
 	arm720t_disable_mmu_caches(target, 1, 1, 1);
 	arm720t-&gt;armv4_5_mmu.mmu_enabled = 0;
 	arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 7ca807a..9580f62 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1227,18 +1227,20 @@ int arm7_9_soft_reset_halt(struct target *target)
 	register_cache_invalidate(armv4_5-&gt;core_cache);
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	uint32_t cpsr;
+
+	cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32);
+	cpsr &amp;= ~0xff;
+	cpsr |= 0xd3;
+	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;cpsr-&gt;valid = 1;
+	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
 	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
 
-	armv4_5-&gt;core_mode = ARMV4_5_MODE_SVC;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-
 	/* reset registers */
 	for (i = 0; i &lt;= 14; i++)
 	{
@@ -1401,11 +1403,7 @@ static int arm7_9_debug_entry(struct target *target)
 	if (armv4_5-&gt;core_state == ARMV4_5_STATE_THUMB)
 		cpsr |= 0x20;
 
-	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32, cpsr);
-	armv4_5-&gt;cpsr-&gt;dirty = 0;
-	armv4_5-&gt;cpsr-&gt;valid = 1;
-
-	armv4_5-&gt;core_mode = cpsr &amp; 0x1f;
+	arm_set_cpsr(armv4_5, cpsr);
 
 	if (!is_arm_mode(armv4_5-&gt;core_mode))
 	{
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 9cd491f..739df3e 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -596,18 +596,20 @@ int arm920t_soft_reset_halt(struct target *target)
 	target-&gt;state = TARGET_HALTED;
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	uint32_t cpsr;
+
+	cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32);
+	cpsr &amp;= ~0xff;
+	cpsr |= 0xd3;
+	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;cpsr-&gt;valid = 1;
+	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
 	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
 
-	armv4_5-&gt;core_mode = ARMV4_5_MODE_SVC;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-
 	arm920t_disable_mmu_caches(target, 1, 1, 1);
 	arm920t-&gt;armv4_5_mmu.mmu_enabled = 0;
 	arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 44afb2c..7ecc782 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -565,18 +565,20 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	target-&gt;state = TARGET_HALTED;
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	uint32_t cpsr;
+
+	cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32);
+	cpsr &amp;= ~0xff;
+	cpsr |= 0xd3;
+	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;cpsr-&gt;valid = 1;
+	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
 	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
 
-	armv4_5-&gt;core_mode = ARMV4_5_MODE_SVC;
-	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-
 	arm926ejs_disable_mmu_caches(target, 1, 1, 1);
 	arm926ejs-&gt;armv4_5_mmu.mmu_enabled = 0;
 	arm926ejs-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 01d3bc3..3156c66 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -245,6 +245,10 @@ static const struct {
 	unsigned cookie;
 	enum armv4_5_mode mode;
 } arm_core_regs[] = {
+	/* IMPORTANT:  we guarantee that the first eight cached registers
+	 * correspond to r0..r7, and the fifteenth to PC, so that callers
+	 * don't need to map them.
+	 */
 	{ .name = &quot;r0&quot;, .cookie = 0, .mode = ARMV4_5_MODE_ANY, },
 	{ .name = &quot;r1&quot;, .cookie = 1, .mode = ARMV4_5_MODE_ANY, },
 	{ .name = &quot;r2&quot;, .cookie = 2, .mode = ARMV4_5_MODE_ANY, },
@@ -255,7 +259,8 @@ static const struct {
 	{ .name = &quot;r7&quot;, .cookie = 7, .mode = ARMV4_5_MODE_ANY, },
 
 	/* NOTE: regs 8..12 might be shadowed by FIQ ... flagging
-	 * them as MODE_ANY creates special cases.
+	 * them as MODE_ANY creates special cases.  (ANY means
+	 * &quot;not mapped&quot; elsewhere; here it's &quot;everything but FIQ&quot;.)
 	 */
 	{ .name = &quot;r8&quot;, .cookie = 8, .mode = ARMV4_5_MODE_ANY, },
 	{ .name = &quot;r9&quot;, .cookie = 9, .mode = ARMV4_5_MODE_ANY, },
@@ -267,6 +272,7 @@ static const struct {
 	{ .name = &quot;sp_usr&quot;, .cookie = 13, .mode = ARMV4_5_MODE_USR, },
 	{ .name = &quot;lr_usr&quot;, .cookie = 14, .mode = ARMV4_5_MODE_USR, },
 
+	/* guaranteed to be at index 15 */
 	{ .name = &quot;pc&quot;, .cookie = 15, .mode = ARMV4_5_MODE_ANY, },
 
 	{ .name = &quot;r8_fiq&quot;, .cookie = 8, .mode = ARMV4_5_MODE_FIQ, },
@@ -333,6 +339,73 @@ const int armv4_5_core_reg_map[8][17] =
 	}
 };
 
+/**
+ * Configures host-side ARM records to reflect the specified CPSR.
+ * Later, code can use arm_reg_current() to map register numbers
+ * according to how they are exposed by this mode.
+ */
+void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
+{
+	enum armv4_5_mode mode = cpsr &amp; 0x1f;
+	int num;
+
+	/* NOTE:  this may be called very early, before the register
+	 * cache is set up.  We can't defend against many errors, in
+	 * particular against CPSRs that aren't valid *here* ...
+	 */
+	if (arm-&gt;cpsr) {
+		buf_set_u32(arm-&gt;cpsr-&gt;value, 0, 32, cpsr);
+		arm-&gt;cpsr-&gt;valid = 1;
+		arm-&gt;cpsr-&gt;dirty = 0;
+	}
+
+	arm-&gt;core_mode = mode;
+
+	/* mode_to_number() warned; set up a somewhat-sane mapping */
+	num = armv4_5_mode_to_number(mode);
+	if (num &lt; 0) {
+		mode = ARMV4_5_MODE_USR;
+		num = 0;
+	}
+
+	arm-&gt;map = &amp;armv4_5_core_reg_map[num][0];
+	arm-&gt;spsr = (mode == ARMV4_5_MODE_USR || mode == ARMV4_5_MODE_SYS)
+			? NULL
+			: arm-&gt;core_cache-&gt;reg_list + arm-&gt;map[16];
+}
+
+/**
+ * Returns handle to the register currently mapped to a given number.
+ * Someone must have called arm_set_cpsr() before.
+ *
+ * \param arm This core's state and registers are used.
+ * \param regnum From 0..15 corresponding to R0..R14 and PC.
+ *	Note that R0..R7 don't require mapping; you may access those
+ *	as the first eight entries in the register cache.  Likewise
+ *	R15 (PC) doesn't need mapping; you may also access it directly.
+ *	However, R8..R14, and SPSR (arm-&gt;spsr) *must* be mapped.
+ *	CPSR (arm-&gt;cpsr) is also not mapped.
+ */
+struct reg *arm_reg_current(struct arm *arm, unsigned regnum)
+{
+	struct reg *r;
+
+	if (regnum &gt; 16)
+		return NULL;
+
+	r = arm-&gt;core_cache-&gt;reg_list + arm-&gt;map[regnum];
+
+	/* e.g. invalid CPSR said &quot;secure monitor&quot; mode on a core
+	 * that doesn't support it...
+	 */
+	if (!r) {
+		LOG_ERROR(&quot;Invalid CPSR mode&quot;);
+		r = arm-&gt;core_cache-&gt;reg_list + regnum;
+	}
+
+	return r;
+}
+
 static const uint8_t arm_gdb_dummy_fp_value[12];
 
 /**
@@ -446,10 +519,9 @@ static int armv4_5_set_core_reg(struct reg *reg, uint8_t *buf)
 		{
 			LOG_DEBUG(&quot;changing ARM core mode to '%s'&quot;,
 					arm_mode_name(value &amp; 0x1f));
-			armv4_5_target-&gt;core_mode = value &amp; 0x1f;
 			armv4_5_target-&gt;write_core_reg(target, reg,
 					16, ARMV4_5_MODE_ANY, value);
-			reg-&gt;dirty = 0;
+			arm_set_cpsr(armv4_5_target, value);
 		}
 	}
 
@@ -752,14 +824,10 @@ int armv4_5_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int
 	*reg_list = malloc(sizeof(struct reg*) * (*reg_list_size));
 
 	for (i = 0; i &lt; 16; i++)
-	{
-		(*reg_list)[i] = &amp;ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, i);
-	}
+		(*reg_list)[i] = arm_reg_current(armv4_5, i);
 
 	for (i = 16; i &lt; 24; i++)
-	{
 		(*reg_list)[i] = &amp;arm_gdb_dummy_fp_reg;
-	}
 
 	(*reg_list)[24] = &amp;arm_gdb_dummy_fps_reg;
 	(*reg_list)[25] = armv4_5-&gt;cpsr;
@@ -805,7 +873,6 @@ int armv4_5_run_algorithm_inner(struct target *target, int num_mem_params, struc
 	struct armv4_5_common_s *armv4_5 = target_to_armv4_5(target);
 	struct armv4_5_algorithm *armv4_5_algorithm_info = arch_info;
 	enum armv4_5_state core_state = armv4_5-&gt;core_state;
-	enum armv4_5_mode core_mode = armv4_5-&gt;core_mode;
 	uint32_t context[17];
 	uint32_t cpsr;
 	int exit_breakpoint_size = 0;
@@ -835,6 +902,9 @@ int armv4_5_run_algorithm_inner(struct target *target, int num_mem_params, struc
 		return ERROR_FAIL;
 	}
 
+	/* save r0..pc, cpsr-or-spsr, and then cpsr-for-sure;
+	 * they'll be restored later.
+	 */
 	for (i = 0; i &lt;= 16; i++)
 	{
 		struct reg *r;
@@ -952,6 +1022,7 @@ int armv4_5_run_algorithm_inner(struct target *target, int num_mem_params, struc
 		}
 	}
 
+	/* restore everything we saved before (17 or 18 registers) */
 	for (i = 0; i &lt;= 16; i++)
 	{
 		uint32_t regvalue;
@@ -964,12 +1035,11 @@ int armv4_5_run_algorithm_inner(struct target *target, int num_mem_params, struc
 			ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_algorithm_info-&gt;core_mode, i).dirty = 1;
 		}
 	}
-	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32, cpsr);
-	armv4_5-&gt;cpsr-&gt;valid = 1;
+
+	arm_set_cpsr(armv4_5, cpsr);
 	armv4_5-&gt;cpsr-&gt;dirty = 1;
 
 	armv4_5-&gt;core_state = core_state;
-	armv4_5-&gt;core_mode = core_mode;
 
 	return retval;
 }
@@ -1169,8 +1239,8 @@ int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 	target-&gt;arch_info = armv4_5;
 
 	armv4_5-&gt;common_magic = ARMV4_5_COMMON_MAGIC;
+	arm_set_cpsr(armv4_5, ARMV4_5_MODE_USR);
 	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-	armv4_5-&gt;core_mode = ARMV4_5_MODE_USR;
 
 	/* core_type may be overridden by subtype logic */
 	armv4_5-&gt;core_type = ARMV4_5_MODE_ANY;
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 5bce30b..a9599c8 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -85,6 +85,11 @@ struct arm
 	/** Handle to the CPSR; valid in all core modes. */
 	struct reg *cpsr;
 
+	/** Handle to the SPSR; valid only in core modes with an SPSR. */
+	struct reg *spsr;
+
+	const int *map;
+
 	/**
 	 * Indicates what registers are in the ARM state core register set.
 	 * ARMV4_5_MODE_ANY indicates the standard set of 37 registers,
@@ -161,6 +166,9 @@ int arm_checksum_memory(struct target *target,
 int arm_blank_check_memory(struct target *target,
 		uint32_t address, uint32_t count, uint32_t *blank);
 
+void arm_set_cpsr(struct arm *arm, uint32_t cpsr);
+struct reg *arm_reg_current(struct arm *arm, unsigned regnum);
+
 extern struct reg arm_gdb_dummy_fp_reg;
 extern struct reg arm_gdb_dummy_fps_reg;
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 2463209..71de3b7 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -648,7 +648,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	dap_ap_select(swjdp, swjdp_debugap);
 	LOG_DEBUG(&quot;cpsr: %8.8&quot; PRIx32, cpsr);
 
-	armv4_5-&gt;core_mode = cpsr &amp; 0x1F;
+	arm_set_cpsr(armv4_5, cpsr);
 
 	i = (cpsr &gt;&gt; 5) &amp; 1;	/* T */
 	i |= (cpsr &gt;&gt; 23) &amp; 1;	/* J &lt;&lt; 1 */
@@ -674,11 +674,6 @@ static int cortex_a8_debug_entry(struct target *target)
 	}
 
 	/* update cache */
-	reg = armv4_5-&gt;cpsr;
-	buf_set_u32(reg-&gt;value, 0, 32, cpsr);
-	reg-&gt;valid = 1;
-	reg-&gt;dirty = 0;
-
 	for (i = 0; i &lt;= ARM_PC; i++)
 	{
 		reg = &amp;ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache,
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 3ed7bf0..659caec 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -948,12 +948,9 @@ static int xscale_debug_entry(struct target *target)
 		LOG_DEBUG(&quot;r%i: 0x%8.8&quot; PRIx32 &quot;&quot;, i, buffer[i + 1]);
 	}
 
-	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32, buffer[9]);
-	armv4_5-&gt;cpsr-&gt;dirty = 1;
-	armv4_5-&gt;cpsr-&gt;valid = 1;
+	arm_set_cpsr(armv4_5, buffer[9]);
 	LOG_DEBUG(&quot;cpsr: 0x%8.8&quot; PRIx32 &quot;&quot;, buffer[9]);
 
-	armv4_5-&gt;core_mode = buffer[9] &amp; 0x1f;
 	if (!is_arm_mode(armv4_5-&gt;core_mode))
 	{
 		target-&gt;state = TARGET_UNKNOWN;

commit 5706fd7860ea01c591ecf74880a5a5e04e6df22e
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Nov 22 03:37:21 2009 -0800

    ARM: simplify CPSR handling
    
    Stash a pointer to the CPSR in the &quot;struct arm&quot;, to help get rid
    of the (common) references to its index in the register cache.
    
    This removes almost all references to CPSR offsets outside of the
    toplevel ARM code ... except a pair related to the current ARM11
    &quot;simulator&quot; logic (which should be removable soonish).
    
    This is a net minor code shrink of a few hundred bytes of object
    code, and also makes the code more readable.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index a6c7cc7..4768f82 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -240,7 +240,7 @@ static int arm720t_arch_state(struct target *target)
 			 armv4_5_state_strings[armv4_5-&gt;core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target-&gt;debug_reason)-&gt;name ,
 			 arm_mode_name(armv4_5-&gt;core_mode),
-			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32),
+			 buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32),
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32),
 			 state[arm720t-&gt;armv4_5_mmu.mmu_enabled],
 			 state[arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled]);
@@ -347,9 +347,9 @@ static int arm720t_soft_reset_halt(struct target *target)
 	target-&gt;state = TARGET_HALTED;
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8, 0xd3);
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	armv4_5-&gt;cpsr-&gt;dirty = 1;
+	armv4_5-&gt;cpsr-&gt;valid = 1;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 3a32764..7ca807a 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1227,9 +1227,9 @@ int arm7_9_soft_reset_halt(struct target *target)
 	register_cache_invalidate(armv4_5-&gt;core_cache);
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8, 0xd3);
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	armv4_5-&gt;cpsr-&gt;dirty = 1;
+	armv4_5-&gt;cpsr-&gt;valid = 1;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
@@ -1401,9 +1401,9 @@ static int arm7_9_debug_entry(struct target *target)
 	if (armv4_5-&gt;core_state == ARMV4_5_STATE_THUMB)
 		cpsr |= 0x20;
 
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32, cpsr);
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 0;
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32, cpsr);
+	armv4_5-&gt;cpsr-&gt;dirty = 0;
+	armv4_5-&gt;cpsr-&gt;valid = 1;
 
 	armv4_5-&gt;core_mode = cpsr &amp; 0x1f;
 
@@ -1520,7 +1520,8 @@ int arm7_9_full_context(struct target *target)
 			uint32_t tmp_cpsr;
 
 			/* change processor mode (and mask T bit) */
-			tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
+			tmp_cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8)
+					&amp; 0xe0;
 			tmp_cpsr |= armv4_5_number_to_mode(i);
 			tmp_cpsr &amp;= ~0x20;
 			arm7_9-&gt;write_xpsr_im8(target, tmp_cpsr &amp; 0xff, 0, 0);
@@ -1551,7 +1552,9 @@ int arm7_9_full_context(struct target *target)
 	}
 
 	/* restore processor mode (mask T bit) */
-	arm7_9-&gt;write_xpsr_im8(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; ~0x20, 0, 0);
+	arm7_9-&gt;write_xpsr_im8(target,
+			buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8) &amp; ~0x20,
+			0, 0);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -1645,7 +1648,8 @@ int arm7_9_restore_context(struct target *target)
 				uint32_t tmp_cpsr;
 
 				/* change processor mode (mask T bit) */
-				tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
+				tmp_cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value,
+						0, 8) &amp; 0xe0;
 				tmp_cpsr |= armv4_5_number_to_mode(i);
 				tmp_cpsr &amp;= ~0x20;
 				arm7_9-&gt;write_xpsr_im8(target, tmp_cpsr &amp; 0xff, 0, 0);
@@ -1687,24 +1691,27 @@ int arm7_9_restore_context(struct target *target)
 		}
 	}
 
-	if ((armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty == 0) &amp;&amp; (armv4_5-&gt;core_mode != current_mode))
+	if (!armv4_5-&gt;cpsr-&gt;dirty &amp;&amp; (armv4_5-&gt;core_mode != current_mode))
 	{
 		/* restore processor mode (mask T bit) */
 		uint32_t tmp_cpsr;
 
-		tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
+		tmp_cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8) &amp; 0xE0;
 		tmp_cpsr |= armv4_5_number_to_mode(i);
 		tmp_cpsr &amp;= ~0x20;
 		LOG_DEBUG(&quot;writing lower 8 bit of cpsr with value 0x%2.2x&quot;, (unsigned)(tmp_cpsr));
 		arm7_9-&gt;write_xpsr_im8(target, tmp_cpsr &amp; 0xff, 0, 0);
 	}
-	else if (armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty == 1)
+	else if (armv4_5-&gt;cpsr-&gt;dirty)
 	{
 		/* CPSR has been changed, full restore necessary (mask T bit) */
-		LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
-		arm7_9-&gt;write_xpsr(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32) &amp; ~0x20, 0);
-		armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 0;
-		armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+		LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32));
+		arm7_9-&gt;write_xpsr(target,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32)
+					&amp; ~0x20, 0);
+		armv4_5-&gt;cpsr-&gt;dirty = 0;
+		armv4_5-&gt;cpsr-&gt;valid = 1;
 	}
 
 	/* restore PC */
@@ -2106,7 +2113,7 @@ static int arm7_9_read_core_reg(struct target *target, struct reg *r,
 		uint32_t tmp_cpsr;
 
 		/* change processor mode (mask T bit) */
-		tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
+		tmp_cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8) &amp; 0xE0;
 		tmp_cpsr |= mode;
 		tmp_cpsr &amp;= ~0x20;
 		arm7_9-&gt;write_xpsr_im8(target, tmp_cpsr &amp; 0xff, 0, 0);
@@ -2140,7 +2147,9 @@ static int arm7_9_read_core_reg(struct target *target, struct reg *r,
 			&amp;&amp; (mode != armv4_5-&gt;core_mode)
 			&amp;&amp; (areg-&gt;mode != ARMV4_5_MODE_ANY))	{
 		/* restore processor mode (mask T bit) */
-		arm7_9-&gt;write_xpsr_im8(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; ~0x20, 0, 0);
+		arm7_9-&gt;write_xpsr_im8(target,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8)
+					&amp; ~0x20, 0, 0);
 	}
 
 	return ERROR_OK;
@@ -2165,7 +2174,7 @@ static int arm7_9_write_core_reg(struct target *target, struct reg *r,
 		uint32_t tmp_cpsr;
 
 		/* change processor mode (mask T bit) */
-		tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
+		tmp_cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8) &amp; 0xE0;
 		tmp_cpsr |= mode;
 		tmp_cpsr &amp;= ~0x20;
 		arm7_9-&gt;write_xpsr_im8(target, tmp_cpsr &amp; 0xff, 0, 0);
@@ -2199,7 +2208,9 @@ static int arm7_9_write_core_reg(struct target *target, struct reg *r,
 			&amp;&amp; (mode != armv4_5-&gt;core_mode)
 			&amp;&amp; (areg-&gt;mode != ARMV4_5_MODE_ANY))	{
 		/* restore processor mode (mask T bit) */
-		arm7_9-&gt;write_xpsr_im8(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; ~0x20, 0, 0);
+		arm7_9-&gt;write_xpsr_im8(target,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8)
+					&amp; ~0x20, 0, 0);
 	}
 
 	return jtag_execute_queue();
@@ -2372,7 +2383,9 @@ int arm7_9_read_memory(struct target *target, uint32_t address, uint32_t size, u
 	{
 		LOG_WARNING(&quot;memory read caused data abort (address: 0x%8.8&quot; PRIx32 &quot;, size: 0x%&quot; PRIx32 &quot;, count: 0x%&quot; PRIx32 &quot;)&quot;, address, size, count);
 
-		arm7_9-&gt;write_xpsr_im8(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; ~0x20, 0, 0);
+		arm7_9-&gt;write_xpsr_im8(target,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8)
+					&amp; ~0x20, 0, 0);
 
 		return ERROR_TARGET_DATA_ABORT;
 	}
@@ -2555,7 +2568,9 @@ int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size,
 	{
 		LOG_WARNING(&quot;memory write caused data abort (address: 0x%8.8&quot; PRIx32 &quot;, size: 0x%&quot; PRIx32 &quot;, count: 0x%&quot; PRIx32 &quot;)&quot;, address, size, count);
 
-		arm7_9-&gt;write_xpsr_im8(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; ~0x20, 0, 0);
+		arm7_9-&gt;write_xpsr_im8(target,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8)
+					&amp; ~0x20, 0, 0);
 
 		return ERROR_TARGET_DATA_ABORT;
 	}
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 29f7917..9cd491f 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -452,7 +452,7 @@ int arm920t_arch_state(struct target *target)
 			 armv4_5_state_strings[armv4_5-&gt;core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target-&gt;debug_reason)-&gt;name,
 			 arm_mode_name(armv4_5-&gt;core_mode),
-			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32),
+			 buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32),
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32),
 			 state[arm920t-&gt;armv4_5_mmu.mmu_enabled],
 			 state[arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
@@ -596,9 +596,9 @@ int arm920t_soft_reset_halt(struct target *target)
 	target-&gt;state = TARGET_HALTED;
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8, 0xd3);
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	armv4_5-&gt;cpsr-&gt;dirty = 1;
+	armv4_5-&gt;cpsr-&gt;valid = 1;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 27eb752..44afb2c 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -510,7 +510,7 @@ int arm926ejs_arch_state(struct target *target)
 			 armv4_5_state_strings[armv4_5-&gt;core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason,target-&gt;debug_reason)-&gt;name,
 			 arm_mode_name(armv4_5-&gt;core_mode),
-			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32),
+			 buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32),
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32),
 			 state[arm926ejs-&gt;armv4_5_mmu.mmu_enabled],
 			 state[arm926ejs-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
@@ -565,9 +565,9 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	target-&gt;state = TARGET_HALTED;
 
 	/* SVC, ARM state, IRQ and FIQ disabled */
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8, 0xd3);
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 8, 0xd3);
+	armv4_5-&gt;cpsr-&gt;dirty = 1;
+	armv4_5-&gt;cpsr-&gt;valid = 1;
 
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 31163b4..23cc556 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -821,7 +821,7 @@ static uint32_t armv4_5_get_cpsr(struct arm_sim_interface *sim, int pos, int bit
 {
 	struct arm *armv4_5 = (struct arm *)sim-&gt;user_data;
 
-	return buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, pos, bits);
+	return buf_get_u32(armv4_5-&gt;cpsr-&gt;value, pos, bits);
 }
 
 static enum armv4_5_state armv4_5_get_state(struct arm_sim_interface *sim)
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 71c7299..01d3bc3 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -36,6 +36,17 @@
 #include &quot;register.h&quot;
 
 
+/* offsets into armv4_5 core register cache */
+enum {
+//	ARMV4_5_CPSR = 31,
+	ARMV4_5_SPSR_FIQ = 32,
+	ARMV4_5_SPSR_IRQ = 33,
+	ARMV4_5_SPSR_SVC = 34,
+	ARMV4_5_SPSR_ABT = 35,
+	ARMV4_5_SPSR_UND = 36,
+	ARM_SPSR_MON = 39,
+};
+
 static const uint8_t arm_usr_indices[17] = {
 	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ARMV4_5_CPSR,
 };
@@ -214,7 +225,7 @@ char* armv4_5_state_strings[] =
  *
  * NOTE:  offsets in this table are coupled to the arm_mode_data
  * table above, the armv4_5_core_reg_map array below, and also to
- * the ARMV4_5_*PSR* symols.
+ * the ARMV4_5_CPSR symbol (which should vanish after ARM11 updates).
  */
 static const struct {
 	/* The name is used for e.g. the &quot;regs&quot; command. */
@@ -401,7 +412,7 @@ static int armv4_5_set_core_reg(struct reg *reg, uint8_t *buf)
 	reg-&gt;dirty = 1;
 	reg-&gt;valid = 1;
 
-	if (reg == &amp;armv4_5_target-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR])
+	if (reg == armv4_5_target-&gt;cpsr)
 	{
 		/* FIXME handle J bit too; mostly for ThumbEE, also Jazelle */
 		if (value &amp; 0x20)
@@ -493,6 +504,7 @@ struct reg_cache* armv4_5_build_reg_cache(struct target *target, struct arm *arm
 		cache-&gt;num_regs++;
 	}
 
+	armv4_5_common-&gt;cpsr = reg_list + ARMV4_5_CPSR;
 	armv4_5_common-&gt;core_cache = cache;
 	return cache;
 }
@@ -511,7 +523,7 @@ int armv4_5_arch_state(struct target *target)
 			 armv4_5_state_strings[armv4_5-&gt;core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target-&gt;debug_reason)-&gt;name,
 			 arm_mode_name(armv4_5-&gt;core_mode),
-			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32),
+			 buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32),
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
 
 	return ERROR_OK;
@@ -750,7 +762,7 @@ int armv4_5_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int
 	}
 
 	(*reg_list)[24] = &amp;arm_gdb_dummy_fps_reg;
-	(*reg_list)[25] = &amp;armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR];
+	(*reg_list)[25] = armv4_5-&gt;cpsr;
 
 	return ERROR_OK;
 }
@@ -834,7 +846,7 @@ int armv4_5_run_algorithm_inner(struct target *target, int num_mem_params, struc
 					armv4_5_algorithm_info-&gt;core_mode);
 		context[i] = buf_get_u32(r-&gt;value, 0, 32);
 	}
-	cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32);
+	cpsr = buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32);
 
 	for (i = 0; i &lt; num_mem_params; i++)
 	{
@@ -878,10 +890,12 @@ int armv4_5_run_algorithm_inner(struct target *target, int num_mem_params, struc
 
 	if (armv4_5_algorithm_info-&gt;core_mode != ARMV4_5_MODE_ANY)
 	{
-		LOG_DEBUG(&quot;setting core_mode: 0x%2.2x&quot;, armv4_5_algorithm_info-&gt;core_mode);
-		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 5, armv4_5_algorithm_info-&gt;core_mode);
-		armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
-		armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+		LOG_DEBUG(&quot;setting core_mode: 0x%2.2x&quot;,
+				armv4_5_algorithm_info-&gt;core_mode);
+		buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 5,
+				armv4_5_algorithm_info-&gt;core_mode);
+		armv4_5-&gt;cpsr-&gt;dirty = 1;
+		armv4_5-&gt;cpsr-&gt;valid = 1;
 	}
 
 	/* terminate using a hardware or (ARMv5+) software breakpoint */
@@ -950,9 +964,9 @@ int armv4_5_run_algorithm_inner(struct target *target, int num_mem_params, struc
 			ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_algorithm_info-&gt;core_mode, i).dirty = 1;
 		}
 	}
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32, cpsr);
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
+	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32, cpsr);
+	armv4_5-&gt;cpsr-&gt;valid = 1;
+	armv4_5-&gt;cpsr-&gt;dirty = 1;
 
 	armv4_5-&gt;core_state = core_state;
 	armv4_5-&gt;core_mode = core_mode;
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index c8fc558..5bce30b 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -62,17 +62,8 @@ extern const int armv4_5_core_reg_map[8][17];
 #define ARMV4_5_CORE_REG_MODE(cache, mode, num) \
 		cache-&gt;reg_list[armv4_5_core_reg_map[armv4_5_mode_to_number(mode)][num]]
 
-/* offsets into armv4_5 core register cache */
-enum
-{
-	ARMV4_5_CPSR = 31,
-	ARMV4_5_SPSR_FIQ = 32,
-	ARMV4_5_SPSR_IRQ = 33,
-	ARMV4_5_SPSR_SVC = 34,
-	ARMV4_5_SPSR_ABT = 35,
-	ARMV4_5_SPSR_UND = 36,
-	ARM_SPSR_MON = 39,
-};
+/* offset into armv4_5 core register cache -- OBSOLETE, DO NOT USE! */
+enum { ARMV4_5_CPSR = 31, };
 
 #define ARMV4_5_COMMON_MAGIC 0x0A450A45
 
@@ -91,6 +82,9 @@ struct arm
 	int common_magic;
 	struct reg_cache *core_cache;
 
+	/** Handle to the CPSR; valid in all core modes. */
+	struct reg *cpsr;
+
 	/**
 	 * Indicates what registers are in the ARM state core register set.
 	 * ARMV4_5_MODE_ANY indicates the standard set of 37 registers,
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index ea883c1..63f95b8 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -74,8 +74,7 @@ int armv7a_arch_state(struct target *target)
 		 Jim_Nvp_value2name_simple(nvp_target_debug_reason,
 				target-&gt;debug_reason)-&gt;name,
 		 arm_mode_name(armv4_5-&gt;core_mode),
-		 buf_get_u32(armv4_5-&gt;core_cache
-				-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32),
+		 buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32),
 		 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32),
 		 state[armv7a-&gt;armv4_5_mmu.mmu_enabled],
 		 state[armv7a-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 635cd40..51f7b45 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -30,16 +30,6 @@ enum
 	ARM_CPSR = 16
 }
 ;
-/* offsets into armv4_5 core register cache */
-enum
-{
-	ARMV7A_CPSR = 31,
-	ARMV7A_SPSR_FIQ = 32,
-	ARMV7A_SPSR_IRQ = 33,
-	ARMV7A_SPSR_SVC = 34,
-	ARMV7A_SPSR_ABT = 35,
-	ARMV7A_SPSR_UND = 36
-};
 
 #define ARMV7_COMMON_MAGIC 0x0A450999
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index c6a46c5..2463209 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -674,7 +674,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	}
 
 	/* update cache */
-	reg = armv4_5-&gt;core_cache-&gt;reg_list + ARMV4_5_CPSR;
+	reg = armv4_5-&gt;cpsr;
 	buf_set_u32(reg-&gt;value, 0, 32, cpsr);
 	reg-&gt;valid = 1;
 	reg-&gt;dirty = 0;
@@ -879,7 +879,7 @@ static int cortex_a8_restore_context(struct target *target)
 		for (i = max - 1, r = cache-&gt;reg_list + 1; i &gt; 0; i--, r++) {
 			struct arm_reg *reg;
 
-			if (!r-&gt;dirty || i == ARMV4_5_CPSR)
+			if (!r-&gt;dirty || r == armv7a-&gt;armv4_5_common.cpsr)
 				continue;
 			reg = r-&gt;arch_info;
 
@@ -915,7 +915,7 @@ static int cortex_a8_restore_context(struct target *target)
 	} while (flushed);
 
 	/* now flush CPSR if needed ... */
-	r = cache-&gt;reg_list + ARMV4_5_CPSR;
+	r = armv7a-&gt;armv4_5_common.cpsr;
 	if (flush_cpsr || r-&gt;dirty) {
 		value = buf_get_u32(r-&gt;value, 0, 32);
 		cortex_a8_dap_write_coreregister_u32(target, value, 16);
@@ -1027,7 +1027,6 @@ static int cortex_a8_read_core_reg(struct target *target, struct reg *r,
 	uint32_t value;
 	int retval;
 	struct armv4_5_common_s *armv4_5 = target_to_armv4_5(target);
-	struct reg_cache *cache = armv4_5-&gt;core_cache;
 	struct reg *cpsr_r = NULL;
 	uint32_t cpsr = 0;
 	unsigned cookie = num;
@@ -1043,7 +1042,7 @@ static int cortex_a8_read_core_reg(struct target *target, struct reg *r,
 			mode = ARMV4_5_MODE_ANY;
 
 		if (mode != ARMV4_5_MODE_ANY) {
-			cpsr_r = cache-&gt;reg_list + ARMV4_5_CPSR;
+			cpsr_r = armv4_5-&gt;cpsr;
 			cpsr = buf_get_u32(cpsr_r-&gt;value, 0, 32);
 			cortex_a8_write_core_reg(target, cpsr_r,
 					16, ARMV4_5_MODE_ANY, mode);
@@ -1083,7 +1082,6 @@ static int cortex_a8_write_core_reg(struct target *target, struct reg *r,
 {
 	int retval;
 	struct armv4_5_common_s *armv4_5 = target_to_armv4_5(target);
-	struct reg_cache *cache = armv4_5-&gt;core_cache;
 	struct reg *cpsr_r = NULL;
 	uint32_t cpsr = 0;
 	unsigned cookie = num;
@@ -1099,7 +1097,7 @@ static int cortex_a8_write_core_reg(struct target *target, struct reg *r,
 			mode = ARMV4_5_MODE_ANY;
 
 		if (mode != ARMV4_5_MODE_ANY) {
-			cpsr_r = cache-&gt;reg_list + ARMV4_5_CPSR;
+			cpsr_r = armv4_5-&gt;cpsr;
 			cpsr = buf_get_u32(cpsr_r-&gt;value, 0, 32);
 			cortex_a8_write_core_reg(target, cpsr_r,
 					16, ARMV4_5_MODE_ANY, mode);
diff --git a/src/target/xscale.c b/src/target/xscale.c
index c908fd7..3ed7bf0 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -858,7 +858,7 @@ static int xscale_arch_state(struct target *target)
 			 armv4_5_state_strings[armv4_5-&gt;core_state],
 			 Jim_Nvp_value2name_simple(nvp_target_debug_reason, target-&gt;debug_reason)-&gt;name ,
 			 arm_mode_name(armv4_5-&gt;core_mode),
-			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32),
+			 buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32),
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32),
 			 state[xscale-&gt;armv4_5_mmu.mmu_enabled],
 			 state[xscale-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
@@ -948,9 +948,9 @@ static int xscale_debug_entry(struct target *target)
 		LOG_DEBUG(&quot;r%i: 0x%8.8&quot; PRIx32 &quot;&quot;, i, buffer[i + 1]);
 	}
 
-	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32, buffer[9]);
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
-	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
+	buf_set_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32, buffer[9]);
+	armv4_5-&gt;cpsr-&gt;dirty = 1;
+	armv4_5-&gt;cpsr-&gt;valid = 1;
 	LOG_DEBUG(&quot;cpsr: 0x%8.8&quot; PRIx32 &quot;&quot;, buffer[9]);
 
 	armv4_5-&gt;core_mode = buffer[9] &amp; 0x1f;
@@ -1260,8 +1260,10 @@ static int xscale_resume(struct target *target, int current,
 				xscale_send_u32(target, 0x30);
 
 			/* send CPSR */
-			xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
-			LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
+			xscale_send_u32(target,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32));
+			LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32,
+				buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32));
 
 			for (i = 7; i &gt;= 0; i--)
 			{
@@ -1303,8 +1305,9 @@ static int xscale_resume(struct target *target, int current,
 		xscale_send_u32(target, 0x30);
 
 	/* send CPSR */
-	xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
-	LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
+	xscale_send_u32(target, buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32));
+	LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32,
+			buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32));
 
 	for (i = 7; i &gt;= 0; i--)
 	{
@@ -1381,9 +1384,12 @@ static int xscale_step_inner(struct target *target, int current,
 			return retval;
 
 	/* send CPSR */
-	if ((retval = xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32))) != ERROR_OK)
+	retval = xscale_send_u32(target,
+			buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32));
+	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
+	LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32,
+			buf_get_u32(armv4_5-&gt;cpsr-&gt;value, 0, 32));
 
 	for (i = 7; i &gt;= 0; i--)
 	{

commit 60a2d85af1afbc207ae5fb9dafdbe4c8b49ad5bb
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Sun Nov 22 03:36:24 2009 -0800

    ARM11: remove disabled register hooks
    
    Minor cleanup of ARM11 register handling:  remove disabled
    register hooks.  This should all be handled by shared code,
    and this stuff is just clutter.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 58b5d54..9c42705 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -115,52 +115,8 @@ static const struct arm11_reg_defs arm11_reg_defs[] =
 	{&quot;lr&quot;,	14,	14,	ARM11_REGISTER_CORE},
 	{&quot;pc&quot;,	15,	15,	ARM11_REGISTER_CORE},
 
-#if ARM11_REGCACHE_FREGS
-	{&quot;f0&quot;,	0,	16,	ARM11_REGISTER_FX},
-	{&quot;f1&quot;,	1,	17,	ARM11_REGISTER_FX},
-	{&quot;f2&quot;,	2,	18,	ARM11_REGISTER_FX},
-	{&quot;f3&quot;,	3,	19,	ARM11_REGISTER_FX},
-	{&quot;f4&quot;,	4,	20,	ARM11_REGISTER_FX},
-	{&quot;f5&quot;,	5,	21,	ARM11_REGISTER_FX},
-	{&quot;f6&quot;,	6,	22,	ARM11_REGISTER_FX},
-	{&quot;f7&quot;,	7,	23,	ARM11_REGISTER_FX},
-	{&quot;fps&quot;,	0,	24,	ARM11_REGISTER_FPS},
-#endif
-
 	{&quot;cpsr&quot;,	0,	25,	ARM11_REGISTER_CPSR},
 
-#if ARM11_REGCACHE_MODEREGS
-	{&quot;r8_fiq&quot;,	8,	-1,	ARM11_REGISTER_FIQ},
-	{&quot;r9_fiq&quot;,	9,	-1,	ARM11_REGISTER_FIQ},
-	{&quot;r10_fiq&quot;,	10,	-1,	ARM11_REGISTER_FIQ},
-	{&quot;r11_fiq&quot;,	11,	-1,	ARM11_REGISTER_FIQ},
-	{&quot;r12_fiq&quot;,	12,	-1,	ARM11_REGISTER_FIQ},
-	{&quot;r13_fiq&quot;,	13,	-1,	ARM11_REGISTER_FIQ},
-	{&quot;r14_fiq&quot;,	14,	-1,	ARM11_REGISTER_FIQ},
-	{&quot;spsr_fiq&quot;, 0,	-1,	ARM11_REGISTER_SPSR_FIQ},
-
-	{&quot;r13_svc&quot;,	13,	-1,	ARM11_REGISTER_SVC},
-	{&quot;r14_svc&quot;,	14,	-1,	ARM11_REGISTER_SVC},
-	{&quot;spsr_svc&quot;, 0,	-1,	ARM11_REGISTER_SPSR_SVC},
-
-	{&quot;r13_abt&quot;,	13,	-1,	ARM11_REGISTER_ABT},
-	{&quot;r14_abt&quot;,	14,	-1,	ARM11_REGISTER_ABT},
-	{&quot;spsr_abt&quot;, 0,	-1,	ARM11_REGISTER_SPSR_ABT},
-
-	{&quot;r13_irq&quot;,	13,	-1,	ARM11_REGISTER_IRQ},
-	{&quot;r14_irq&quot;,	14,	-1,	ARM11_REGISTER_IRQ},
-	{&quot;spsr_irq&quot;, 0,	-1,	ARM11_REGISTER_SPSR_IRQ},
-
-	{&quot;r13_und&quot;,	13,	-1,	ARM11_REGISTER_UND},
-	{&quot;r14_und&quot;,	14,	-1,	ARM11_REGISTER_UND},
-	{&quot;spsr_und&quot;, 0,	-1,	ARM11_REGISTER_SPSR_UND},
-
-	/* ARM1176 only */
-	{&quot;r13_mon&quot;,	13,	-1,	ARM11_REGISTER_MON},
-	{&quot;r14_mon&quot;,	14,	-1,	ARM11_REGISTER_MON},
-	{&quot;spsr_mon&quot;, 0,	-1,	ARM11_REGISTER_SPSR_MON},
-#endif
-
 	/* Debug Registers */
 	{&quot;dscr&quot;,	0,	-1,	ARM11_REGISTER_DSCR},
 	{&quot;wdtr&quot;,	0,	-1,	ARM11_REGISTER_WDTR},
@@ -191,52 +147,8 @@ enum arm11_regcache_ids
 	ARM11_RC_R15,
 	ARM11_RC_PC			= ARM11_RC_R15,
 
-#if ARM11_REGCACHE_FREGS
-	ARM11_RC_F0,
-	ARM11_RC_FX			= ARM11_RC_F0,
-	ARM11_RC_F1,
-	ARM11_RC_F2,
-	ARM11_RC_F3,
-	ARM11_RC_F4,
-	ARM11_RC_F5,
-	ARM11_RC_F6,
-	ARM11_RC_F7,
-	ARM11_RC_FPS,
-#endif
-
 	ARM11_RC_CPSR,
 
-#if ARM11_REGCACHE_MODEREGS
-	ARM11_RC_R8_FIQ,
-	ARM11_RC_R9_FIQ,
-	ARM11_RC_R10_FIQ,
-	ARM11_RC_R11_FIQ,
-	ARM11_RC_R12_FIQ,
-	ARM11_RC_R13_FIQ,
-	ARM11_RC_R14_FIQ,
-	ARM11_RC_SPSR_FIQ,
-
-	ARM11_RC_R13_SVC,
-	ARM11_RC_R14_SVC,
-	ARM11_RC_SPSR_SVC,
-
-	ARM11_RC_R13_ABT,
-	ARM11_RC_R14_ABT,
-	ARM11_RC_SPSR_ABT,
-
-	ARM11_RC_R13_IRQ,
-	ARM11_RC_R14_IRQ,
-	ARM11_RC_SPSR_IRQ,
-
-	ARM11_RC_R13_UND,
-	ARM11_RC_R14_UND,
-	ARM11_RC_SPSR_UND,
-
-	ARM11_RC_R13_MON,
-	ARM11_RC_R14_MON,
-	ARM11_RC_SPSR_MON,
-#endif
-
 	ARM11_RC_DSCR,
 	ARM11_RC_WDTR,
 	ARM11_RC_RDTR,
@@ -244,6 +156,7 @@ enum arm11_regcache_ids
 	ARM11_RC_MAX,
 };
 
+/* GDB expects ARMs to give R0..R15, CPSR, and 7 FPA dummies */
 #define ARM11_GDB_REGISTER_COUNT	26
 
 static int arm11_on_enter_debug_state(struct arm11_common *arm11);
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 809c23f..79f4b6b 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -37,12 +37,9 @@
 #define ZU		&quot;%Iu&quot;
 #endif
 
-#define ARM11_REGCACHE_MODEREGS		0
-#define ARM11_REGCACHE_FREGS		0
 
-#define ARM11_REGCACHE_COUNT		(20 +					\
-					 23 * ARM11_REGCACHE_MODEREGS +			\
-					  9 * ARM11_REGCACHE_FREGS)
+/* TEMPORARY -- till we switch to the shared infrastructure */
+#define ARM11_REGCACHE_COUNT		20
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c         |   89 +--------------------
 src/target/arm11.h         |    7 +-
 src/target/arm720t.c       |   15 ++--
 src/target/arm7_9_common.c |   95 +++++++++++++--------
 src/target/arm920t.c       |   15 ++--
 src/target/arm926ejs.c     |   15 ++--
 src/target/arm_simulator.c |    2 +-
 src/target/armv4_5.c       |  193 +++++++++++++++++++++++++++++++-------------
 src/target/armv4_5.h       |   24 +++---
 src/target/armv7a.c        |    3 +-
 src/target/armv7a.h        |   10 ---
 src/target/cortex_a8.c     |   40 +--------
 src/target/xscale.c        |   31 +++----
 13 files changed, 256 insertions(+), 283 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001835.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-513-gb58239e
</A></li>
	<LI>Next message: <A HREF="001837.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-518-gd1fbcc3
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1836">[ date ]</a>
              <a href="thread.html#1836">[ thread ]</a>
              <a href="subject.html#1836">[ subject ]</a>
              <a href="author.html#1836">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
