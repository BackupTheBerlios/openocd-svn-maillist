<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-70-gfbbce95
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-August/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-70-gfbbce95&In-Reply-To=%3Cmailman.166.1331736157.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002680.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-70-gfbbce95</H1>
    <B>&#195;&#152;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-70-gfbbce95&In-Reply-To=%3Cmailman.166.1331736157.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-70-gfbbce95">gowinex at users.sourceforge.net
       </A><BR>
    <I>Wed Aug 31 16:27:56 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002680.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-61-g3533626
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2681">[ date ]</a>
              <a href="thread.html#2681">[ thread ]</a>
              <a href="subject.html#2681">[ subject ]</a>
              <a href="author.html#2681">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  fbbce951402bc08367786f2ba2ce3af549d0d5a5 (commit)
       via  42300c98ab7edb634982b41c3e790c87be9718d1 (commit)
       via  be568d37c0d2c3826c6428eec906a3bd7dd9cb90 (commit)
       via  573cbeac1ee0bfadef5c924ff4a13c8e251c773c (commit)
       via  eb0734de19c51f48dd66f6bc8af4e20bdb534e63 (commit)
       via  1d4f294c3c61ef8ad7a5cc89f3cfbd61ecaaf846 (commit)
       via  e1a2d7255eb8c282fc91e951c7453932c1e9a55f (commit)
       via  2aa14db67747d25df1f072f262dbc98e2169f718 (commit)
       via  67bb8a6cb208a7529045fc11b1dc30adf98d928f (commit)
      from  353362651fc28c1f1d823659cde36dd31d1aede6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fbbce951402bc08367786f2ba2ce3af549d0d5a5
Merge: 3533626 42300c9
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Wed Aug 31 16:27:09 2011 +0200

    Merge branch 'dsp5680xx_cherry' of <A HREF="git://repo.or.cz/openocd/dsp568013">git://repo.or.cz/openocd/dsp568013</A> into fix


commit 42300c98ab7edb634982b41c3e790c87be9718d1
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Tue Aug 30 21:14:33 2011 -0700

    removed trailing whitespaces
    
    emacs is awesome.
    replace-regexp RET [ ]+$ RET RET
    and it's done

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index ce729af..4d2ae49 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -147,17 +147,17 @@ static int jtag_data_write(struct target * target, uint32_t instr,int num_bits,
 #define jtag_data_write24(target,instr,data_read) jtag_data_write(target,instr,24,data_read)
 #define jtag_data_write32(target,instr,data_read) jtag_data_write(target,instr,32,data_read)
 
-/** 
+/**
  * Executes EOnCE instruction.
- * 
- * @param target 
+ *
+ * @param target
  * @param instr Instruction to execute.
- * @param rw 
- * @param go 
- * @param ex 
+ * @param rw
+ * @param go
+ * @param ex
  * @param eonce_status Value read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_instruction_exec_single(struct target * target, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex,uint8_t * eonce_status){
   int retval;
@@ -435,13 +435,13 @@ static int eonce_read_status_reg(struct target * target, uint16_t * data){
   return retval;
 }
 
-/** 
+/**
  * Takes the core out of debug mode.
- * 
- * @param target 
+ *
+ * @param target
  * @param eonce_status Data read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
   int retval;
@@ -496,13 +496,13 @@ int switch_tap(struct target * target, struct jtag_tap * master_tap,struct jtag_
 }
 
 #define TIME_DIV_FREESCALE 0.3
-/** 
+/**
  * Puts the core into debug mode, enabling the EOnCE module.
- * 
- * @param target 
+ *
+ * @param target
  * @param eonce_status Data read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
   int retval = ERROR_OK;
@@ -592,7 +592,7 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   return retval;
 }
 
-/** 
+/**
  * Puts the core into debug mode, enabling the EOnCE module.
  * This will not always work, eonce_enter_debug_mode executes much
  * more complicated routine, which is guaranteed to work, but requires
@@ -600,11 +600,11 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
  * after a reset clock divisors must be set again.
  * This implementation works most of the time, and is not accesible to the
  * user.
- * 
- * @param target 
+ *
+ * @param target
  * @param eonce_status Data read from the EOnCE status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t * eonce_status){
   int retval;
@@ -638,12 +638,12 @@ static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t
   return ERROR_OK;
 }
 
-/** 
+/**
  * Reads the current value of the program counter and stores it.
- * 
- * @param target 
- * 
- * @return 
+ *
+ * @param target
+ *
+ * @return
  */
 static int eonce_pc_store(struct target * target){
   uint8_t tmp[2];
@@ -803,14 +803,14 @@ static int dsp5680xx_resume(struct target *target, int current, uint32_t address
 
 
 
-/** 
+/**
  * The value of @address determines if it corresponds to P: (program) or X: (data) memory. If the address is over 0x200000 then it is considered X: memory, and @pmem = 0.
  * The special case of 0xFFXXXX is not modified, since it allows to read out the memory mapped EOnCE registers.
- * 
- * @param address 
- * @param pmem 
- * 
- * @return 
+ *
+ * @param address
+ * @param pmem
+ *
+ * @return
  */
 static int dsp5680xx_convert_address(uint32_t * address, int * pmem){
   // Distinguish data memory (x:) from program memory (p:) by the address.
@@ -1051,17 +1051,17 @@ static int dsp5680xx_write_32(struct target * target, uint32_t address, uint32_t
   return retval;
 }
 
-/** 
+/**
  * Writes @buffer to memory.
  * The parameter @address determines whether @buffer should be written to P: (program) memory or X: (data) memory.
- * 
- * @param target 
+ *
+ * @param target
  * @param address
  * @param size Bytes (1), Half words (2), Words (4).
  * @param count In bytes.
- * @param buffer 
- * 
- * @return 
+ * @param buffer
+ *
+ * @return
  */
 static int dsp5680xx_write(struct target *target, uint32_t address, uint32_t size, uint32_t count, const uint8_t * buffer){
   //TODO Cannot write 32bit to odd address, will write 0x12345678  as 0x5678 0x0012
@@ -1105,15 +1105,15 @@ static int dsp5680xx_write_buffer(struct target * target, uint32_t address, uint
   return dsp5680xx_write(target, address, 1, size, buffer);
 }
 
-/** 
+/**
  * This function is called by verify_image, it is used to read data from memory.
- * 
- * @param target 
+ *
+ * @param target
  * @param address Word addressing.
  * @param size In bytes.
- * @param buffer 
- * 
- * @return 
+ * @param buffer
+ *
+ * @return
  */
 static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint32_t size, uint8_t * buffer){
   if(target-&gt;state != TARGET_HALTED){
@@ -1124,29 +1124,29 @@ static int dsp5680xx_read_buffer(struct target * target, uint32_t address, uint3
   return dsp5680xx_read(target,address,2,size/2,buffer);
 }
 
-/** 
+/**
  * This function is not implemented.
  * It returns an error in order to get OpenOCD to do read out the data and calculate the CRC, or try a binary comparison.
- * 
- * @param target 
+ *
+ * @param target
  * @param address Start address of the image.
  * @param size In bytes.
- * @param checksum 
- * 
- * @return 
+ * @param checksum
+ *
+ * @return
  */
 static int dsp5680xx_checksum_memory(struct target * target, uint32_t address, uint32_t size, uint32_t * checksum){
   return ERROR_FAIL;
 }
 
-/** 
+/**
  * Calculates a signature over @word_count words in the data from @buff16. The algorithm used is the same the FM uses, so the @return may be used to compare with the one generated by the FM module, and check if flashing was successful.
  * This algorithm is based on the perl script available from the Freescale website at FAQ 25630.
- * 
- * @param buff16 
- * @param word_count 
- * 
- * @return 
+ *
+ * @param buff16
+ * @param word_count
+ *
+ * @return
  */
 static int perl_crc(uint8_t * buff8,uint32_t  word_count){
   uint16_t checksum = 0xffff;
@@ -1166,12 +1166,12 @@ static int perl_crc(uint8_t * buff8,uint32_t  word_count){
   return checksum;
 }
 
-/** 
+/**
  * Resets the SIM. (System Integration Module).
- * 
- * @param target 
- * 
- * @return 
+ *
+ * @param target
+ *
+ * @return
  */
 int dsp5680xx_f_SIM_reset(struct target * target){
   int retval = ERROR_OK;
@@ -1185,12 +1185,12 @@ int dsp5680xx_f_SIM_reset(struct target * target){
   return retval;
 }
 
-/** 
+/**
  * Halts the core and resets the SIM. (System Integration Module).
- * 
- * @param target 
- * 
- * @return 
+ *
+ * @param target
+ *
+ * @return
  */
 static int dsp5680xx_soft_reset_halt(struct target *target){
   //TODO is this what this function is expected to do...?
@@ -1216,17 +1216,17 @@ int dsp5680xx_f_protect_check(struct target * target, uint16_t * protected) {
   return retval;
 }
 
-/** 
+/**
  * Executes a command on the FM module. Some commands use the parameters @address and @data, others ignore them.
- * 
- * @param target 
+ *
+ * @param target
  * @param command Command to execute.
  * @param address Command parameter.
  * @param data Command parameter.
  * @param hfm_ustat FM status register.
  * @param pmem Address is P: (program) memory (@pmem==1) or X: (data) memory (@pmem==0)
- * 
- * @return 
+ *
+ * @return
  */
 static int dsp5680xx_f_execute_command(struct target * target, uint16_t command, uint32_t address, uint32_t data, uint16_t * hfm_ustat, int pmem){
   int retval;
@@ -1304,12 +1304,12 @@ static int dsp5680xx_f_execute_command(struct target * target, uint16_t command,
   return ERROR_OK;
 }
 
-/** 
- * Prior to the execution of any Flash module command, the Flash module Clock Divider (CLKDIV) register must be initialized. The values of this register determine the speed of the internal Flash Clock (FCLK). FCLK must be in the range of 150kHz &#226;&#137;&#164; FCLK &#226;&#137;&#164; 200kHz for proper operation of the Flash module. (Running FCLK too slowly wears out the module, while running it too fast under programs Flash leading to bit errors.) 
- * 
- * @param target 
- * 
- * @return 
+/**
+ * Prior to the execution of any Flash module command, the Flash module Clock Divider (CLKDIV) register must be initialized. The values of this register determine the speed of the internal Flash Clock (FCLK). FCLK must be in the range of 150kHz &#226;&#137;&#164; FCLK &#226;&#137;&#164; 200kHz for proper operation of the Flash module. (Running FCLK too slowly wears out the module, while running it too fast under programs Flash leading to bit errors.)
+ *
+ * @param target
+ *
+ * @return
  */
 static int set_fm_ck_div(struct target * target){
   uint8_t i[2];
@@ -1349,15 +1349,15 @@ static int set_fm_ck_div(struct target * target){
   return ERROR_OK;
 }
 
-/** 
+/**
  * Executes the FM calculate signature command. The FM will calculate over the data from @address to @address + @words -1. The result is written to a register, then read out by this function and returned in @signature. The value @signature may be compared to the the one returned by perl_crc to verify the flash was written correctly.
- * 
- * @param target 
+ *
+ * @param target
  * @param address Start of flash array where the signature should be calculated.
  * @param words Number of words over which the signature should be calculated.
  * @param signature Value calculated by the FM.
- * 
- * @return 
+ *
+ * @return
  */
 static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint32_t words, uint16_t * signature){
   int retval;
@@ -1389,14 +1389,14 @@ int dsp5680xx_f_erase_check(struct target * target, uint8_t * erased,uint32_t se
   return retval;
 }
 
-/** 
+/**
  * Executes the FM page erase command.
- * 
- * @param target 
+ *
+ * @param target
  * @param sector Page to erase.
  * @param hfm_ustat FM module status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat){
   int retval;
@@ -1405,13 +1405,13 @@ static int erase_sector(struct target * target, int sector, uint16_t * hfm_ustat
   return retval;
 }
 
-/** 
+/**
  * Executes the FM mass erase command. Erases the flash array completely.
- * 
- * @param target 
+ *
+ * @param target
  * @param hfm_ustat FM module status register.
- * 
- * @return 
+ *
+ * @return
  */
 static int mass_erase(struct target * target, uint16_t * hfm_ustat){
   int retval;
@@ -1633,10 +1633,10 @@ int dsp5680xx_f_unlock(struct target * target){
   if(retval == ERROR_OK){
     LOG_WARNING(&quot;Memory was not locked.&quot;);
   }
-  
+
   jtag_add_reset(0,1);
   usleep(TIME_DIV_FREESCALE*200*1000);
-  
+
   retval = reset_jtag();
   err_check(retval,&quot;Failed to reset JTAG state machine&quot;);
   usleep(150);

commit be568d37c0d2c3826c6428eec906a3bd7dd9cb90
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Tue Aug 30 21:08:59 2011 -0700

    fix enter debug mode for locking
    
    added an alternative way to enter debug mode, which does not require restarting the chip.
    this will not always work, but in general it will (failure 0.3%), and failure is not a dramatic issue, simply have to use the full sequence.
    the user can only access &quot;halt&quot;, which uses the full sequence, so the user should not have any problems.
    restarting the chip requires reconfiguring the flash module. the doc is very poor, so i'd rather have the two methods, and live with the 0.3%.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 7a1f990..ce729af 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -524,9 +524,9 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
     err_check(retval,&quot;Failed to get master tap.&quot;);
   }
 
-  tap_chp-&gt;enabled = false;
-  retval = switch_tap(target,tap_chp,tap_cpu);
-  err_check_propagate(retval);
+  // Enable master tap
+  tap_chp-&gt;enabled = true;
+  tap_cpu-&gt;enabled = false;
 
   instr = MASTER_TAP_CMD_IDCODE;
   retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
@@ -542,6 +542,7 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   // ir_out now hold tap idcode
 
   // Enable core tap
+  tap_chp-&gt;enabled = true;
   retval = switch_tap(target,tap_chp,tap_cpu);
   err_check_propagate(retval);
 
@@ -592,6 +593,52 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
 }
 
 /** 
+ * Puts the core into debug mode, enabling the EOnCE module.
+ * This will not always work, eonce_enter_debug_mode executes much
+ * more complicated routine, which is guaranteed to work, but requires
+ * a reset. This will complicate comm with the flash module, since
+ * after a reset clock divisors must be set again.
+ * This implementation works most of the time, and is not accesible to the
+ * user.
+ * 
+ * @param target 
+ * @param eonce_status Data read from the EOnCE status register.
+ * 
+ * @return 
+ */
+static int eonce_enter_debug_mode_without_reset(struct target * target, uint16_t * eonce_status){
+  int retval;
+  uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  // Debug request #1
+  retval = dsp5680xx_irscan(target,&amp; instr,&amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+
+  // Enable EOnCE module
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  // Verify that debug mode is enabled
+  uint16_t data_read_from_dr;
+  retval = eonce_read_status_reg(target,&amp;data_read_from_dr);
+  err_check_propagate(retval);
+  if((data_read_from_dr&amp;0x30) == 0x30){
+    LOG_DEBUG(&quot;EOnCE successfully entered debug mode.&quot;);
+    target-&gt;state = TARGET_HALTED;
+    retval = ERROR_OK;
+  }else{
+    retval = ERROR_TARGET_FAILURE;
+    err_check(retval,&quot;Failed to set EOnCE module to debug mode. Try with halt&quot;);
+  }
+  if(eonce_status!=NULL)
+    *eonce_status = data_read_from_dr;
+  return ERROR_OK;
+}
+
+/** 
  * Reads the current value of the program counter and stores it.
  * 
  * @param target 
@@ -1316,12 +1363,7 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   int retval;
   uint16_t hfm_ustat;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
-    retval = eonce_enter_debug_mode(target,NULL);
-    err_check_propagate(retval);
-    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-    // Set hfmdiv
-    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-    retval = set_fm_ck_div(target);
+    retval = eonce_enter_debug_mode_without_reset(target,NULL);
     err_check_propagate(retval);
   }
   retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&amp;hfm_ustat,1);
@@ -1590,7 +1632,6 @@ int dsp5680xx_f_unlock(struct target * target){
   retval = eonce_enter_debug_mode(target,&amp;eonce_status);
   if(retval == ERROR_OK){
     LOG_WARNING(&quot;Memory was not locked.&quot;);
-    return retval;
   }
   
   jtag_add_reset(0,1);
@@ -1613,6 +1654,7 @@ int dsp5680xx_f_unlock(struct target * target){
   usleep(TIME_DIV_FREESCALE*300*1000);
 
   // Enable master tap
+  tap_chp-&gt;enabled = false;
   retval = switch_tap(target,tap_chp,tap_cpu);
   err_check_propagate(retval);
 
@@ -1667,10 +1709,10 @@ int dsp5680xx_f_unlock(struct target * target){
 
 int dsp5680xx_f_lock(struct target * target){
   int retval;
-  uint16_t lock_word[] = {HFM_LOCK_FLASH,HFM_LOCK_FLASH};
-  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4,1);
+  uint16_t lock_word[] = {HFM_LOCK_FLASH};
+  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,2,1);
   err_check_propagate(retval);
-  return retval;
+
   jtag_add_reset(0,1);
   usleep(TIME_DIV_FREESCALE*200*1000);
 

commit 573cbeac1ee0bfadef5c924ff4a13c8e251c773c
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Tue Aug 30 14:46:20 2011 -0700

    fix irlen handling
    
    sometimes the master tap will be enabled, since tap switching is required during halt/lock/unlocking procedures.
    now irscan handles this, avoiding unnecessary warnings and preventing errors.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 675dfce..7a1f990 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -90,12 +90,17 @@ static int dsp5680xx_irscan(struct target * target, uint32_t * data_to_shift_int
 	err_check(retval,&quot;Invalid tap&quot;);
   }
   if (ir_len != target-&gt;tap-&gt;ir_length){
-    LOG_WARNING(&quot;%s: Invalid ir_len of core tap. If you are removing protection on flash then do not worry about this warninig.&quot;,__FUNCTION__);
-    //return ERROR_FAIL;//TODO this was commented out to enable unlocking using the master tap. did not find a way to enable the master tap without using tcl.
+    if(target-&gt;tap-&gt;enabled){
+      retval = ERROR_FAIL;
+      err_check(retval,&quot;Invalid irlen&quot;);
+    }else{
+      struct jtag_tap * master_tap = jtag_tap_by_string(&quot;dsp568013.chp&quot;);
+      if((master_tap == NULL) || ((master_tap-&gt;enabled) &amp;&amp; (ir_len != DSP5680XX_JTAG_MASTER_TAP_IRLEN))){
+        retval = ERROR_FAIL;
+        err_check(retval,&quot;Invalid irlen&quot;);
+      }
+    }
   }
-  //TODO what values of len are valid for jtag_add_plain_ir_scan?
-  //can i send as many bits as i want?
-  //is the casting necessary?
   jtag_add_plain_ir_scan(ir_len,(uint8_t *)data_to_shift_into_ir,(uint8_t *)data_shifted_out_of_ir, TAP_IDLE);
   if(dsp5680xx_context.flush){
     retval = dsp5680xx_execute_queue();

commit eb0734de19c51f48dd66f6bc8af4e20bdb534e63
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Tue Aug 30 15:13:49 2011 -0700

    fix debug mode,lock,unlock
    
    got new info regarding setting the chip to debug mode, and locking/unlocking flash memory.
    the newer implementation is a bit slower, but always works.
    the previous implementation would randomly (as once every 25k-70k times) get the chip into a state where the freescale tool would be necessary. this is fixed now.
    
    added functions to play around with the jtag state machine. they are not the happiest, but are necessary to be able to execute the halting/locking/unlocking sequences.
    
    Conflicts:
    
    	src/target/dsp5680xx.c

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index cc00f40..675dfce 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -445,6 +445,52 @@ static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
   return retval;
 }
 
+int switch_tap(struct target * target, struct jtag_tap * master_tap,struct jtag_tap * core_tap){
+  int retval = ERROR_OK;
+  uint32_t instr;
+  uint32_t ir_out;//not used, just to make jtag happy.
+  if(master_tap == NULL){
+    master_tap = jtag_tap_by_string(&quot;dsp568013.chp&quot;);
+    if(master_tap == NULL){
+      retval = ERROR_FAIL;
+      err_check(retval,&quot;Failed to get master tap.&quot;);
+    }
+  }
+  if(core_tap == NULL){
+    core_tap = jtag_tap_by_string(&quot;dsp568013.cpu&quot;);
+    if(core_tap == NULL){
+      retval = ERROR_FAIL;
+      err_check(retval,&quot;Failed to get core tap.&quot;);
+    }
+  }
+
+  if(!(((int)master_tap-&gt;enabled) ^ ((int)core_tap-&gt;enabled))){
+      LOG_WARNING(&quot;Wrong tap enabled/disabled status:\nMaster tap:%d\nCore Tap:%d\nOnly one tap should be enabled at a given time.\n&quot;,(int)master_tap-&gt;enabled,(int)core_tap-&gt;enabled);
+  }
+
+  if(master_tap-&gt;enabled){
+    instr = 0x5;
+    retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
+    err_check_propagate(retval);
+    instr = 0x2;
+    retval =  dsp5680xx_drscan(target,(uint8_t *) &amp; instr,(uint8_t *) &amp; ir_out,4);
+    err_check_propagate(retval);
+    core_tap-&gt;enabled = true;
+    master_tap-&gt;enabled = false;
+  }else{
+    instr = 0x08;
+    retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+    err_check_propagate(retval);
+    instr = 0x1;
+    retval =  dsp5680xx_drscan(target,(uint8_t *) &amp; instr,(uint8_t *) &amp; ir_out,4);
+    err_check_propagate(retval);
+    core_tap-&gt;enabled = false;
+    master_tap-&gt;enabled = true;
+  }
+  return retval;
+}
+
+#define TIME_DIV_FREESCALE 0.3
 /** 
  * Puts the core into debug mode, enabling the EOnCE module.
  * 
@@ -454,20 +500,75 @@ static int eonce_exit_debug_mode(struct target * target,uint8_t * eonce_status){
  * @return 
  */
 static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_status){
-  int retval;
+  int retval = ERROR_OK;
   uint32_t instr = JTAG_INSTR_DEBUG_REQUEST;
   uint32_t ir_out;//not used, just to make jtag happy.
-  // Debug request #1
-  retval = dsp5680xx_irscan(target,&amp; instr,&amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  uint16_t instr_16;
+  uint16_t read_16;
+
+  struct jtag_tap * tap_chp;
+  struct jtag_tap * tap_cpu;
+  tap_chp = jtag_tap_by_string(&quot;dsp568013.chp&quot;);
+  if(tap_chp == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,&quot;Failed to get master tap.&quot;);
+  }
+  tap_cpu = jtag_tap_by_string(&quot;dsp568013.cpu&quot;);
+  if(tap_cpu == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,&quot;Failed to get master tap.&quot;);
+  }
+
+  tap_chp-&gt;enabled = false;
+  retval = switch_tap(target,tap_chp,tap_cpu);
+  err_check_propagate(retval);
+
+  instr = MASTER_TAP_CMD_IDCODE;
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
   err_check_propagate(retval);
+  usleep(TIME_DIV_FREESCALE*100*1000);
 
   // Enable EOnCE module
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+  instr = 0x0606ffff;// This was selected experimentally.
+  retval =  dsp5680xx_drscan(target,(uint8_t *) &amp; instr,(uint8_t *) &amp; ir_out,32);
+  err_check_propagate(retval);
+  // ir_out now hold tap idcode
+
+  // Enable core tap
+  retval = switch_tap(target,tap_chp,tap_cpu);
+  err_check_propagate(retval);
+
   instr = JTAG_INSTR_ENABLE_ONCE;
   //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
   retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
+  instr = JTAG_INSTR_DEBUG_REQUEST;
   retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
+  instr_16 = 0x1;
+  retval = dsp5680xx_drscan(target,(uint8_t *) &amp; instr_16,(uint8_t *) &amp; read_16,8);
+  instr_16 = 0x20;
+  retval = dsp5680xx_drscan(target,(uint8_t *) &amp; instr_16,(uint8_t *) &amp; read_16,8);
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
+
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  for(int i = 0; i&lt;3; i++){
+    retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+    err_check_propagate(retval);
+  }
+
+  for(int i = 0; i&lt;3; i++){
+    instr_16 = 0x86;
+    dsp5680xx_drscan(target,(uint8_t *) &amp; instr_16,(uint8_t *) &amp; read_16,16);
+    instr_16 = 0xff;
+    dsp5680xx_drscan(target,(uint8_t *) &amp; instr_16,(uint8_t *) &amp; read_16,16);
+  }
+
   // Verify that debug mode is enabled
   uint16_t data_read_from_dr;
   retval = eonce_read_status_reg(target,&amp;data_read_from_dr);
@@ -1212,6 +1313,11 @@ static int dsp5680xx_f_signature(struct target * target, uint32_t address, uint3
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = eonce_enter_debug_mode(target,NULL);
     err_check_propagate(retval);
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    // Set hfmdiv
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    retval = set_fm_ck_div(target);
+    err_check_propagate(retval);
   }
   retval = dsp5680xx_f_execute_command(target,HFM_CALCULATE_DATA_SIGNATURE,address,words,&amp;hfm_ustat,1);
   err_check_propagate(retval);
@@ -1457,19 +1563,100 @@ int reset_jtag(void){
 }
 
 int dsp5680xx_f_unlock(struct target * target){
-  int retval;
-  if(target-&gt;tap-&gt;enabled){
-    //TODO find a way to switch to the master tap here.
-    LOG_ERROR(&quot;Master tap must be enabled to unlock flash.&quot;);
-    return ERROR_TARGET_FAILURE;
+  int retval = ERROR_OK;
+  uint16_t eonce_status;
+  uint32_t instr;
+  uint32_t ir_out;
+  uint16_t instr_16;
+  uint16_t read_16;
+  struct jtag_tap * tap_chp;
+  struct jtag_tap * tap_cpu;
+  tap_chp = jtag_tap_by_string(&quot;dsp568013.chp&quot;);
+  if(tap_chp == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,&quot;Failed to get master tap.&quot;);
+  }
+  tap_cpu = jtag_tap_by_string(&quot;dsp568013.cpu&quot;);
+  if(tap_cpu == NULL){
+    retval = ERROR_FAIL;
+    err_check(retval,&quot;Failed to get master tap.&quot;);
+  }
+
+  retval = eonce_enter_debug_mode(target,&amp;eonce_status);
+  if(retval == ERROR_OK){
+    LOG_WARNING(&quot;Memory was not locked.&quot;);
+    return retval;
   }
-  uint32_t data_to_shift_in = MASTER_TAP_CMD_FLASH_ERASE;
-  uint32_t data_shifted_out;
-  retval = dsp5680xx_irscan(target,&amp;data_to_shift_in,&amp;data_shifted_out,8);
+  
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+  
+  retval = reset_jtag();
+  err_check(retval,&quot;Failed to reset JTAG state machine&quot;);
+  usleep(150);
+
+  // Enable core tap
+  tap_chp-&gt;enabled = true;
+  retval = switch_tap(target,tap_chp,tap_cpu);
+  err_check_propagate(retval);
+
+  instr = JTAG_INSTR_DEBUG_REQUEST;
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
   err_check_propagate(retval);
-  data_to_shift_in = HFM_CLK_DEFAULT;
-  retval = dsp5680xx_drscan(target,((uint8_t *) &amp; data_to_shift_in),((uint8_t *)&amp;data_shifted_out),8);
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
+
+  // Enable master tap
+  retval = switch_tap(target,tap_chp,tap_cpu);
   err_check_propagate(retval);
+
+  // Execute mass erase to unlock
+  instr = MASTER_TAP_CMD_FLASH_ERASE;
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
+  err_check_propagate(retval);
+
+  instr = HFM_CLK_DEFAULT;
+  retval =  dsp5680xx_drscan(target,(uint8_t *) &amp; instr,(uint8_t *) &amp; ir_out,16);
+  err_check_propagate(retval);
+
+  usleep(TIME_DIV_FREESCALE*150*1000);
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+
+  retval = reset_jtag();
+  err_check(retval,&quot;Failed to reset JTAG state machine&quot;);
+  usleep(150);
+
+  instr = 0x0606ffff;
+  retval =  dsp5680xx_drscan(target,(uint8_t *) &amp; instr,(uint8_t *) &amp; ir_out,32);
+  err_check_propagate(retval);
+
+  // enable core tap
+  instr = 0x5;
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_MASTER_TAP_IRLEN);
+  err_check_propagate(retval);
+  instr = 0x2;
+  retval =  dsp5680xx_drscan(target,(uint8_t *) &amp; instr,(uint8_t *) &amp; ir_out,4);
+  err_check_propagate(retval);
+
+  tap_cpu-&gt;enabled = true;
+  tap_chp-&gt;enabled = false;
+
+  instr = JTAG_INSTR_ENABLE_ONCE;
+  //Two rounds of jtag 0x6  (enable eonce) to enable EOnCE.
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  instr = JTAG_INSTR_DEBUG_REQUEST;
+  retval =  dsp5680xx_irscan(target, &amp; instr, &amp; ir_out,DSP5680XX_JTAG_CORE_TAP_IRLEN);
+  err_check_propagate(retval);
+  instr_16 = 0x1;
+  retval = dsp5680xx_drscan(target,(uint8_t *) &amp; instr_16,(uint8_t *) &amp; read_16,8);
+  instr_16 = 0x20;
+  retval = dsp5680xx_drscan(target,(uint8_t *) &amp; instr_16,(uint8_t *) &amp; read_16,8);
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
   return retval;
 }
 
@@ -1479,6 +1666,16 @@ int dsp5680xx_f_lock(struct target * target){
   retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4,1);
   err_check_propagate(retval);
   return retval;
+  jtag_add_reset(0,1);
+  usleep(TIME_DIV_FREESCALE*200*1000);
+
+  retval = reset_jtag();
+  err_check(retval,&quot;Failed to reset JTAG state machine&quot;);
+  usleep(TIME_DIV_FREESCALE*100*1000);
+  jtag_add_reset(0,0);
+  usleep(TIME_DIV_FREESCALE*300*1000);
+
+  return retval;
 }
 
 static int dsp5680xx_step(struct target * target,int current, uint32_t address, int handle_breakpoints){

commit 1d4f294c3c61ef8ad7a5cc89f3cfbd61ecaaf846
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Tue Aug 30 14:26:05 2011 -0700

    fix error handling during halt
    
    the user can execute halt, but no enter_debug_mode. modified the error handling to suite this.
    the new implementation of unlocking will use enter_debug_mode, and should not get the same errors as the user would, because not being able to enter debug mode is actually success when checking for locked flash.

diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index 4cd3ff5..cc00f40 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -475,14 +475,14 @@ static int eonce_enter_debug_mode(struct target * target, uint16_t * eonce_statu
   if((data_read_from_dr&amp;0x30) == 0x30){
     LOG_DEBUG(&quot;EOnCE successfully entered debug mode.&quot;);
     target-&gt;state = TARGET_HALTED;
-    return ERROR_OK;
+    retval = ERROR_OK;
   }else{
+    LOG_DEBUG(&quot;Failed to set EOnCE module to debug mode.&quot;);
     retval = ERROR_TARGET_FAILURE;
-    err_check(retval,&quot;Failed to set EOnCE module to debug mode.&quot;);
   }
   if(eonce_status!=NULL)
     *eonce_status = data_read_from_dr;
-  return ERROR_OK;
+  return retval;
 }
 
 /** 
@@ -551,7 +551,7 @@ static int dsp5680xx_halt(struct target *target){
     return ERROR_OK;
   }
   retval = eonce_enter_debug_mode(target,&amp;eonce_status);
-  err_check_propagate(retval);
+  err_check(retval,&quot;Failed to halt target.&quot;);
   retval = eonce_pc_store(target);
   err_check_propagate(retval);
   //TODO is it useful to store the pc?

commit e1a2d7255eb8c282fc91e951c7453932c1e9a55f
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Tue Aug 30 14:19:09 2011 -0700

    optional crc for flash writing
    
    crc check was always performed on newly flashed data, now it is optional
    flash mem can be locked by writing a specific word to a specific address in flash.
    to verify flash, target must be halted, and this will (when the new halt sequence is implemented) require reseting the chip. if the target is reset after writing the lock words, then it will lock, hence the CRC will fail because it is not possible to read stuff from the target.
    
    also added a function that resets the jtag state machine.
    this is not used yet, but will be soon.
    it is implemented to allow strict control over JTAG state machine, necessary to implement to halt and unlocking sequences.

diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
index 4ed7206..688493b 100644
--- a/src/flash/nor/dsp5680xx_flash.c
+++ b/src/flash/nor/dsp5680xx_flash.c
@@ -157,7 +157,7 @@ static int dsp5680xx_flash_write(struct flash_bank *bank, uint8_t *buffer, uint3
     LOG_ERROR(&quot;%s: Writing to odd addresses not supported. This chip uses word addressing, Openocd only supports byte addressing. The workaround results in disabling writing to odd byte addresses.&quot;,__FUNCTION__);
     return ERROR_FAIL;
   }
-  retval = dsp5680xx_f_wr(bank-&gt;target,  buffer, bank-&gt;base + offset/2,  count);
+  retval = dsp5680xx_f_wr(bank-&gt;target,  buffer, bank-&gt;base + offset/2,  count, 0);
   uint32_t addr_word;
   for(addr_word = bank-&gt;base + offset/2;addr_word&lt;count/2;addr_word+=(HFM_SECTOR_SIZE/2)){
     if(retval == ERROR_OK)
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
index c25eabf..4cd3ff5 100644
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -1341,7 +1341,7 @@ int dsp5680xx_f_erase(struct target * target, int first, int last){
 const uint16_t pgm_write_pflash[] = {0x8A46,0x0013,0x407D,0xE700,0xE700,0x8A44,0xFFFE,0x017B,0xE700,0xF514,0x8563,0x8646,0x0020,0x0014,0x8646,0x0080,0x0013,0x8A46,0x0013,0x2004,0x8246,0x0013,0x0020,0xA968,0x8A46,0x0013,0x1065,0x8246,0x0013,0x0010,0xA961};
 const uint32_t pgm_write_pflash_length = 31;
 
-int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count){
+int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count, int is_flash_lock){
   int retval = ERROR_OK;
   if (dsp5680xx_target_status(target,NULL,NULL) != TARGET_HALTED){
     retval = eonce_enter_debug_mode(target,NULL);
@@ -1351,10 +1351,12 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
   // Download the pgm that flashes.
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   uint32_t my_favourite_ram_address = 0x8700; // This seems to be a safe address. This one is the one used by codewarrior in 56801x_flash.cfg
-  retval = dsp5680xx_write(target, my_favourite_ram_address, 1, pgm_write_pflash_length*2,(uint8_t *) pgm_write_pflash);
-  err_check_propagate(retval);
-  retval = dsp5680xx_execute_queue();
-  err_check_propagate(retval);
+  if(!is_flash_lock){
+    retval = dsp5680xx_write(target, my_favourite_ram_address, 1, pgm_write_pflash_length*2,(uint8_t *) pgm_write_pflash);
+    err_check_propagate(retval);
+    retval = dsp5680xx_execute_queue();
+    err_check_propagate(retval);
+  }
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   // Set hfmdiv
   // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
@@ -1422,21 +1424,38 @@ int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, ui
 	dsp5680xx_context.flush = 0;
   }
   dsp5680xx_context.flush = 1;
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  // Verify flash
-  // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-  uint16_t signature;
-  uint16_t pc_crc;
-  retval =  dsp5680xx_f_signature(target,address,i,&amp;signature);
-  err_check_propagate(retval);
-  pc_crc = perl_crc(buffer,i);
-  if(pc_crc != signature){
-    retval = ERROR_FAIL;
-    err_check(retval,&quot;Flashed data failed CRC check, flash again!&quot;);
+  if(!is_flash_lock){
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    // Verify flash (skip when exec lock sequence)
+    // -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
+    uint16_t signature;
+    uint16_t pc_crc;
+    retval =  dsp5680xx_f_signature(target,address,i,&amp;signature);
+    err_check_propagate(retval);
+    pc_crc = perl_crc(buffer,i);
+    if(pc_crc != signature){
+      retval = ERROR_FAIL;
+      err_check(retval,&quot;Flashed data failed CRC check, flash again!&quot;);
+    }
   }
   return retval;
 }
 
+// Reset state machine
+int reset_jtag(void){
+  int retval;
+  tap_state_t states[2];
+  const char *cp = &quot;RESET&quot;;
+  states[0] = tap_state_by_name(cp);
+  retval = jtag_add_statemove(states[0]);
+  err_check_propagate(retval);
+  retval = jtag_execute_queue();
+  err_check_propagate(retval);
+  jtag_add_pathmove(0, states + 1);
+  retval = jtag_execute_queue();
+  return retval;
+}
+
 int dsp5680xx_f_unlock(struct target * target){
   int retval;
   if(target-&gt;tap-&gt;enabled){
@@ -1457,7 +1476,7 @@ int dsp5680xx_f_unlock(struct target * target){
 int dsp5680xx_f_lock(struct target * target){
   int retval;
   uint16_t lock_word[] = {HFM_LOCK_FLASH,HFM_LOCK_FLASH};
-  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4);
+  retval = dsp5680xx_f_wr(target,(uint8_t *)(lock_word),HFM_LOCK_ADDR_L,4,1);
   err_check_propagate(retval);
   return retval;
 }
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 6c86ef8..05b4a28 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -234,10 +234,11 @@ static inline struct dsp5680xx_common *target_to_dsp5680xx(struct target *target
  * @param buffer 
  * @param address Word addressing.
  * @param count In bytes. 
+ * @param verify_flash Execute a CRC check after flashing. 
  * 
  * @return 
  */
-int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count);
+int dsp5680xx_f_wr(struct target * target, uint8_t *buffer, uint32_t address, uint32_t count, int is_flash_lock);
 
 /** 
  * The FM has the funcionality of checking if the flash array is erased. This function executes it. It does not support individual sector analysis.

commit 2aa14db67747d25df1f072f262dbc98e2169f718
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Tue Aug 30 13:49:44 2011 -0700

    def syntax to match tap irlen
    
    the master tap has a 4 bit irlen
    changed the instructions to be 4 bit, ie, removed the zeros.
    it makes it clearer to interpret.

diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
index 599fd68..6c86ef8 100644
--- a/src/target/dsp5680xx.h
+++ b/src/target/dsp5680xx.h
@@ -69,10 +69,10 @@
 //----------------------------------------------------------------
 // Master TAP instructions from MC56F8000RM.pdf
 //----------------------------------------------------------------
-#define MASTER_TAP_CMD_BYPASS      0xFF
-#define MASTER_TAP_CMD_IDCODE      0x02
-#define MASTER_TAP_CMD_TLM_SEL     0x05
-#define MASTER_TAP_CMD_FLASH_ERASE 0x08
+#define MASTER_TAP_CMD_BYPASS      0xF
+#define MASTER_TAP_CMD_IDCODE      0x2
+#define MASTER_TAP_CMD_TLM_SEL     0x5
+#define MASTER_TAP_CMD_FLASH_ERASE 0x8
 //----------------------------------------------------------------
 
 //----------------------------------------------------------------

commit 67bb8a6cb208a7529045fc11b1dc30adf98d928f
Author: Rodrigo L. Rosa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">rodrigorosa.LG at gmail.com</A>&gt;
Date:   Mon Aug 15 19:50:59 2011 -0700

    dsp568013 disable polling by default

diff --git a/tcl/target/dsp568013.cfg b/tcl/target/dsp568013.cfg
index fa7c4d9..80adc76 100644
--- a/tcl/target/dsp568013.cfg
+++ b/tcl/target/dsp568013.cfg
@@ -36,7 +36,11 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME dsp5680xx -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # Setup the interesting tap
-jtag configure $_CHIPNAME.chp -event setup &quot;jtag tapenable $_TARGETNAME&quot;
+# Disable polling to be able to get idcode from core tap. If re enabled, can be re enabled, but it should be disabled to correctly unlock flash (operations requiere certain instruction to be in the IR register during reset, and polling would change this)
+jtag configure $_CHIPNAME.chp -event setup &quot;
+     jtag tapenable $_TARGETNAME
+     poll off
+&quot;
 
 #select CORE tap by modifying the TLM register.
 #to be used when MASTER tap is selected.

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/dsp5680xx_flash.c |    2 +-
 src/target/dsp5680xx.c          |  515 +++++++++++++++++++++++++++++----------
 src/target/dsp5680xx.h          |   11 +-
 tcl/target/dsp568013.cfg        |    6 +-
 4 files changed, 401 insertions(+), 133 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002680.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-61-g3533626
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2681">[ date ]</a>
              <a href="thread.html#2681">[ thread ]</a>
              <a href="subject.html#2681">[ subject ]</a>
              <a href="author.html#2681">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
