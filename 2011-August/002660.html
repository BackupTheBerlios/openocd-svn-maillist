<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-14-g827057f
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-August/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-14-g827057f&In-Reply-To=%3Cmailman.145.1331736156.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002658.html">
   <LINK REL="Next"  HREF="002661.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-14-g827057f</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-14-g827057f&In-Reply-To=%3Cmailman.145.1331736156.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-14-g827057f">gowinex at users.sourceforge.net
       </A><BR>
    <I>Tue Aug  9 23:20:12 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002658.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-9-g194e3c5
</A></li>
        <LI>Next message: <A HREF="002661.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-21-gf25ffaf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2660">[ date ]</a>
              <a href="thread.html#2660">[ thread ]</a>
              <a href="subject.html#2660">[ subject ]</a>
              <a href="author.html#2660">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  827057f5608653ef721c0fef46277d3791f00adb (commit)
       via  c18e02387b0628a9ecfc41a65af4802e8b95357e (commit)
       via  1be7163408cc6420d85bf990a2dae46c559a12b1 (commit)
       via  800bc9308dfcae950cd95ca287876b60401e7608 (commit)
       via  e1466df54d8ddd6800f8df2f9e0d2f1dd646cb20 (commit)
      from  194e3c5bc5e0fbb7d41cfcbe913c4264782cdd5b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 827057f5608653ef721c0fef46277d3791f00adb
Author: Drasko DRASKOVIC &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>&gt;
Date:   Mon Jul 25 14:23:35 2011 +0200

    mips32 : Fixed memory byte access
    
    Function mips_m4k_write_memory() does endianess byte swap,
    but this procedure break one byte access (temporary array
    overwrites content in buffer).
    As a fix, this endianess swap and buffer affecting
    is preformed only on hword and word accesses (not on byte access).

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 350ed51..e4ab044 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -923,33 +923,38 @@ static int mips_m4k_write_memory(struct target *target, uint32_t address,
 	if (((size == 4) &amp;&amp; (address &amp; 0x3u)) || ((size == 2) &amp;&amp; (address &amp; 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
-	/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
-	/* endianness, but byte array represents target endianness               */
-	uint8_t * t = NULL;
-	t = malloc(count * sizeof(uint32_t));
-	if (t == NULL)
+	/** correct endianess if we have word or hword access */
+	uint8_t *t = NULL;
+	if (size &gt; 1)
 	{
-		LOG_ERROR(&quot;Out of memory&quot;);
-		return ERROR_FAIL;
-	}
+		/* mips32_..._write_mem with size 4/2 requires uint32_t/uint16_t in host */
+		/* endianness, but byte array represents target endianness               */
+		t = malloc(count * sizeof(uint32_t));
+		if (t == NULL)
+		{
+			LOG_ERROR(&quot;Out of memory&quot;);
+			return ERROR_FAIL;
+		}
 
- 	uint32_t i, t32;
-	uint16_t t16;
-	for(i = 0; i &lt; (count*size); i += size)
-	{
-		switch(size)
+		uint32_t i, t32;
+		uint16_t t16;
+		for(i = 0; i &lt; (count*size); i += size)
 		{
-		case 4:
-			t32 = target_buffer_get_u32(target,&amp;buffer[i]);
-			h_u32_to_le(&amp;t[i], t32);
-			break;
-		case 2:
-			t16 = target_buffer_get_u16(target,&amp;buffer[i]);
-			h_u16_to_le(&amp;t[i], t16);
-			break;
+			switch(size)
+			{
+			case 4:
+				t32 = target_buffer_get_u32(target,&amp;buffer[i]);
+				h_u32_to_le(&amp;t[i], t32);
+				break;
+			case 2:
+				t16 = target_buffer_get_u16(target,&amp;buffer[i]);
+				h_u16_to_le(&amp;t[i], t16);
+				break;
+			}
 		}
+
+		buffer = t;
 	}
-	buffer = t;
 
 	/* if noDMA off, use DMAACC mode for memory write */
 	int retval;

commit c18e02387b0628a9ecfc41a65af4802e8b95357e
Author: Drasko DRASKOVIC &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>&gt;
Date:   Thu Jul 7 17:59:13 2011 +0200

    mips32: Sync Caches to Make Instr Writes Effective
    
    Pprogram that loads another program into memory is actually writing the
    D- side cache.
    The instructions it has loaded can't be executed until they reach the
    I-cache.
    
    After the instructions have been written, the loader should arrange to
    write back any containing D-cache line and invalidate any locations
    already in the I-cache.
    
    For the MIPS Architecture Release2 cores, we can use synci command
    that does this job.
    For Release1 we must use &quot;cache&quot; instruction.

diff --git a/src/target/mips32.h b/src/target/mips32.h
index 8b21b0a..5d5aa46 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -31,6 +31,38 @@
 
 #define MIPS32_COMMON_MAGIC		0xB320B320
 
+/**
+ * Memory segments (32bit kernel mode addresses)
+ * These are the traditional names used in the 32-bit universe.
+ */
+#define KUSEG			0x00000000
+#define KSEG0			0x80000000
+#define KSEG1			0xa0000000
+#define KSEG2			0xc0000000
+#define KSEG3			0xe0000000
+
+/** Returns the kernel segment base of a given address */
+#define KSEGX(a)		((a) &amp; 0xe0000000)
+
+/** CP0 CONFIG regites fields */
+#define MIPS32_CONFIG0_KU_SHIFT 25
+#define MIPS32_CONFIG0_KU_MASK (0x7 &lt;&lt; MIPS32_CONFIG0_KU_SHIFT)
+
+#define MIPS32_CONFIG0_K0_SHIFT 0
+#define MIPS32_CONFIG0_K0_MASK (0x7 &lt;&lt; MIPS32_CONFIG0_K0_SHIFT)
+
+#define MIPS32_CONFIG0_K23_SHIFT 28
+#define MIPS32_CONFIG0_K23_MASK (0x7 &lt;&lt; MIPS32_CONFIG0_K23_SHIFT)
+
+#define MIPS32_CONFIG0_AR_SHIFT 10
+#define MIPS32_CONFIG0_AR_MASK (0x7 &lt;&lt; MIPS32_CONFIG0_AR_SHIFT)
+
+#define MIPS32_CONFIG1_DL_SHIFT 10
+#define MIPS32_CONFIG1_DL_MASK (0x7 &lt;&lt; MIPS32_CONFIG1_DL_SHIFT)
+
+#define MIPS32_ARCH_REL1 0x0
+#define MIPS32_ARCH_REL2 0x1
+
 /* offsets into mips32 core register cache */
 enum
 {
@@ -95,10 +127,14 @@ struct mips32_algorithm
 	enum mips32_isa_mode isa_mode;
 };
 
+#define MIPS32_OP_ADDIU 0x21
+#define MIPS32_OP_ANDI	0x0C
 #define MIPS32_OP_BEQ	0x04
+#define MIPS32_OP_BGTZ	0x07
 #define MIPS32_OP_BNE	0x05
 #define MIPS32_OP_ADDI	0x08
 #define MIPS32_OP_AND	0x24
+#define MIPS32_OP_CACHE	0x2F
 #define MIPS32_OP_COP0	0x10
 #define MIPS32_OP_JR	0x08
 #define MIPS32_OP_LUI	0x0F
@@ -109,12 +145,21 @@ struct mips32_algorithm
 #define MIPS32_OP_MTHI	0x11
 #define MIPS32_OP_MFLO	0x12
 #define MIPS32_OP_MTLO	0x13
+#define MIPS32_OP_RDHWR 0x3B
 #define MIPS32_OP_SB	0x28
 #define MIPS32_OP_SH	0x29
 #define MIPS32_OP_SW	0x2B
 #define MIPS32_OP_ORI	0x0D
 #define MIPS32_OP_XOR	0x26
+#define MIPS32_OP_SLTU  0x2B
 #define MIPS32_OP_SRL	0x03
+#define MIPS32_OP_SYNCI	0x1F
+
+#define MIPS32_OP_REGIMM	0x01
+#define MIPS32_OP_SDBBP		0x3F
+#define MIPS32_OP_SPECIAL	0x00
+#define MIPS32_OP_SPECIAL2	0x07
+#define MIPS32_OP_SPECIAL3	0x1F
 
 #define MIPS32_COP0_MF	0x00
 #define MIPS32_COP0_MT	0x04
@@ -123,33 +168,52 @@ struct mips32_algorithm
 #define MIPS32_I_INST(opcode, rs, rt, immd)	(((opcode) &lt;&lt; 26) |((rs) &lt;&lt; 21) | ((rt) &lt;&lt; 16) | (immd))
 #define MIPS32_J_INST(opcode, addr)	(((opcode) &lt;&lt; 26) |(addr))
 
-#define MIPS32_NOP					0
-#define MIPS32_ADDI(tar, src, val)	MIPS32_I_INST(MIPS32_OP_ADDI, src, tar, val)
-#define MIPS32_AND(reg, off, val)	MIPS32_R_INST(0, off, val, reg, 0, MIPS32_OP_AND)
-#define MIPS32_B(off)				MIPS32_BEQ(0, 0, off)
-#define MIPS32_BEQ(src,tar,off)		MIPS32_I_INST(MIPS32_OP_BEQ, src, tar, off)
-#define MIPS32_BNE(src,tar,off)		MIPS32_I_INST(MIPS32_OP_BNE, src, tar, off)
-#define MIPS32_JR(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_JR)
-#define MIPS32_MFC0(gpr, cpr, sel)	MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MF, gpr, cpr, 0, sel)
-#define MIPS32_MTC0(gpr,cpr, sel)	MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MT, gpr, cpr, 0, sel)
-#define MIPS32_LBU(reg, off, base)	MIPS32_I_INST(MIPS32_OP_LBU, base, reg, off)
-#define MIPS32_LHU(reg, off, base)	MIPS32_I_INST(MIPS32_OP_LHU, base, reg, off)
-#define MIPS32_LUI(reg, val)		MIPS32_I_INST(MIPS32_OP_LUI, 0, reg, val)
-#define MIPS32_LW(reg, off, base)	MIPS32_I_INST(MIPS32_OP_LW, base, reg, off)
-#define MIPS32_MFLO(reg)			MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFLO)
-#define MIPS32_MFHI(reg)			MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
-#define MIPS32_MTLO(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
-#define MIPS32_MTHI(reg)			MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
-#define MIPS32_ORI(tar, src, val)	MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
-#define MIPS32_SB(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
-#define MIPS32_SH(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
-#define MIPS32_SW(reg, off, base)	MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
-#define MIPS32_XOR(reg, val1, val2)	MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
-#define MIPS32_SRL(reg, src, off)	MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
+#define MIPS32_NOP						0
+#define MIPS32_ADDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ADDI, src, tar, val)
+#define MIPS32_ADDU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_ADDIU)
+#define MIPS32_AND(reg, off, val)		MIPS32_R_INST(0, off, val, reg, 0, MIPS32_OP_AND)
+#define MIPS32_ANDI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ANDI, src, tar, val)
+#define MIPS32_B(off)					MIPS32_BEQ(0, 0, off)
+#define MIPS32_BEQ(src, tar, off)		MIPS32_I_INST(MIPS32_OP_BEQ, src, tar, off)
+#define MIPS32_BGTZ(reg, off)			MIPS32_I_INST(MIPS32_OP_BGTZ, reg, 0, off)
+#define MIPS32_BNE(src,tar,off)			MIPS32_I_INST(MIPS32_OP_BNE, src, tar, off)
+#define MIPS32_CACHE(op, off, base)		MIPS32_I_INST(MIPS32_OP_CACHE, base, op, off)
+#define MIPS32_JR(reg)					MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_JR)
+#define MIPS32_MFC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MF, gpr, cpr, 0, sel)
+#define MIPS32_MTC0(gpr, cpr, sel)		MIPS32_R_INST(MIPS32_OP_COP0, MIPS32_COP0_MT, gpr, cpr, 0, sel)
+#define MIPS32_LBU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LBU, base, reg, off)
+#define MIPS32_LHU(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LHU, base, reg, off)
+#define MIPS32_LUI(reg, val)			MIPS32_I_INST(MIPS32_OP_LUI, 0, reg, val)
+#define MIPS32_LW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_LW, base, reg, off)
+#define MIPS32_MFLO(reg)				MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFLO)
+#define MIPS32_MFHI(reg)				MIPS32_R_INST(0, 0, 0, reg, 0, MIPS32_OP_MFHI)
+#define MIPS32_MTLO(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTLO)
+#define MIPS32_MTHI(reg)				MIPS32_R_INST(0, reg, 0, 0, 0, MIPS32_OP_MTHI)
+#define MIPS32_ORI(tar, src, val)		MIPS32_I_INST(MIPS32_OP_ORI, src, tar, val)
+#define MIPS32_RDHWR(tar, dst)			MIPS32_R_INST(MIPS32_OP_SPECIAL3, 0, tar, dst, 0, MIPS32_OP_RDHWR)
+#define MIPS32_SB(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SB, base, reg, off)
+#define MIPS32_SH(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SH, base, reg, off)
+#define MIPS32_SW(reg, off, base)		MIPS32_I_INST(MIPS32_OP_SW, base, reg, off)
+#define MIPS32_XOR(reg, val1, val2)		MIPS32_R_INST(0, val1, val2, reg, 0, MIPS32_OP_XOR)
+#define MIPS32_SRL(reg, src, off)		MIPS32_R_INST(0, 0, src, reg, off, MIPS32_OP_SRL)
+#define MIPS32_SLTU(dst, src, tar)		MIPS32_R_INST(MIPS32_OP_SPECIAL, src, tar, dst, 0, MIPS32_OP_SLTU)
+#define MIPS32_SYNCI(off, base)			MIPS32_I_INST(MIPS32_OP_REGIMM, base, MIPS32_OP_SYNCI, off)
+
+#define MIPS32_SYNC			0xF
+#define MIPS32_SYNCI_STEP	0x1	/* reg num od address step size to be used with synci instruction */
+
+/**
+ * Cache operations definietions
+ * Operation field is 5 bits long :
+ * 1) bits 1..0 hold cache type
+ * 2) bits 4..2 hold operation code
+ */
+#define MIPS32_CACHE_D_HIT_WRITEBACK ((0x1 &lt;&lt; 0) | (0x6 &lt;&lt; 2))
+#define MIPS32_CACHE_I_HIT_INVALIDATE ((0x0 &lt;&lt; 0) | (0x4 &lt;&lt; 2))
 
 /* ejtag specific instructions */
 #define MIPS32_DRET					0x4200001F
-#define MIPS32_SDBBP				0x7000003F
+#define MIPS32_SDBBP				0x7000003F	/* MIPS32_J_INST(MIPS32_OP_SPECIAL2, MIPS32_OP_SDBBP) */
 #define MIPS16_SDBBP				0xE801
 
 extern const struct command_registration mips32_command_handlers[];
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 1986e5c..6b43479 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -113,6 +113,11 @@ static int mips32_pracc_write_mem32(struct mips_ejtag *ejtag_info,
 static int mips32_pracc_write_u32(struct mips_ejtag *ejtag_info,
 		uint32_t addr, uint32_t *buf);
 
+static int mips32_pracc_sync_cache(struct mips_ejtag *ejtag_info,
+		uint32_t start_addr, uint32_t end_addr);
+static int mips32_pracc_clean_invalidate_cache(struct mips_ejtag *ejtag_info,
+													uint32_t start_addr, uint32_t end_addr);
+
 static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 {
 	uint32_t ejtag_ctrl;
@@ -663,22 +668,246 @@ int mips32_cp0_write(struct mips_ejtag *ejtag_info,
 	return retval;
 }
 
+/**
+ * \b mips32_pracc_sync_cache
+ *
+ * Synchronize Caches to Make Instruction Writes Effective
+ * (ref. doc. MIPS32 Architecture For Programmers Volume II: The MIPS32 Instruction Set,
+ *  Document Number: MD00086, Revision 2.00, June 9, 2003)
+ *
+ * When the instruction stream is written, the SYNCI instruction should be used
+ * in conjunction with other instructions to make the newly-written instructions effective.
+ *
+ * Explanation :
+ * A program that loads another program into memory is actually writing the D- side cache.
+ * The instructions it has loaded can't be executed until they reach the I-cache.
+ *
+ * After the instructions have been written, the loader should arrange
+ * to write back any containing D-cache line and invalidate any locations
+ * already in the I-cache.
+ *
+ * You can do that with cache instructions, but those instructions are only available in kernel mode,
+ * and a loader writing instructions for the use of its own process need not be privileged software.
+ *
+ * In the latest MIPS32/64 CPUs, MIPS provides the synci instruction,
+ * which does the whole job for a cache-line-sized chunk of the memory you just loaded:
+ * That is, it arranges a D-cache write-back and an I-cache invalidate.
+ *
+ * To employ synci at user level, you need to know the size of a cache line,
+ * and that can be obtained with a rdhwr SYNCI_Step
+ * from one of the standard &#226;&#128;&#156;hardware registers&#226;&#128;&#157;.
+ */
+static int mips32_pracc_sync_cache(struct mips_ejtag *ejtag_info,
+											uint32_t start_addr, uint32_t end_addr)
+{
+	static const uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+		MIPS32_SW(10,0,15),									/* sw $10,($15) */
+		MIPS32_SW(11,0,15),									/* sw $11,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(9,0,8),									/* Load write start_addr to $9 */
+		MIPS32_LW(10,4,8),									/* Load write end_addr to $10 */
+
+		MIPS32_RDHWR(11, MIPS32_SYNCI_STEP),				/* $11 = MIPS32_SYNCI_STEP */
+		MIPS32_BEQ(11,0,6),									/* beq $11, $0, end */
+		MIPS32_NOP,
+															/* synci_loop : */
+		MIPS32_SYNCI(0,9),									/* synci 0($9) */
+		MIPS32_SLTU(8,10,9),								/* sltu $8, $10, $9  # $8 = $10 &lt; $9 ? 1 : 0 */
+		MIPS32_BNE(8,0,NEG16(3)),							/* bne $8, $0, synci_loop */
+		MIPS32_ADDU(9, 9, 11),								/* $9 += MIPS32_SYNCI_STEP */
+		MIPS32_SYNC,
+															/* end: */
+		MIPS32_LW(11,0,15),									/* lw $11,($15) */
+		MIPS32_LW(10,0,15),									/* lw $10,($15) */
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(24)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/* TODO remove array */
+	uint32_t *param_in = malloc(2 * sizeof(uint32_t));
+	int retval;
+	param_in[0] = start_addr;
+	param_in[1] = end_addr;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 2, param_in, 0, NULL, 1);
+
+	free(param_in);
+
+	return retval;
+}
+
+/**
+ * \b mips32_pracc_clean_invalidate_cache
+ *
+ * Writeback D$ and Invalidate I$
+ * so that the instructions written can be visible to CPU
+ */
+static int mips32_pracc_clean_invalidate_cache(struct mips_ejtag *ejtag_info,
+													uint32_t start_addr, uint32_t end_addr)
+{
+	static const uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+		MIPS32_SW(10,0,15),									/* sw $10,($15) */
+		MIPS32_SW(11,0,15),									/* sw $11,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(9,0,8),									/* Load write start_addr to $9 */
+		MIPS32_LW(10,4,8),									/* Load write end_addr to $10 */
+		MIPS32_LW(11,8,8),									/* Load write clsiz to $11 */
+
+															/* cache_loop: */
+		MIPS32_SLTU(8,10,9),								/* sltu $8, $10, $9  :  $8 &lt;- $10 &lt; $9 ? */
+		MIPS32_BGTZ(8,6),									/* bgtz $8, end */
+		MIPS32_NOP,
+
+		MIPS32_CACHE(MIPS32_CACHE_D_HIT_WRITEBACK,0,9),		/* cache Hit_Writeback_D, 0($9) */
+		MIPS32_CACHE(MIPS32_CACHE_I_HIT_INVALIDATE,0,9),	/* cache Hit_Invalidate_I, 0($9) */
+
+		MIPS32_ADDU(9,9,11),								/* $9 += $11 */
+
+		MIPS32_B(NEG16(7)),									/* b cache_loop */
+		MIPS32_NOP,
+															/* end: */
+		MIPS32_LW(11,0,15),									/* lw $11,($15) */
+		MIPS32_LW(10,0,15),									/* lw $10,($15) */
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(25)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/**
+	 * Find cache line size in bytes
+	 */
+	uint32_t conf;
+	uint32_t dl, clsiz;
+
+	mips32_cp0_read(ejtag_info, &amp;conf, 16, 1);
+	dl = (conf &amp; MIPS32_CONFIG1_DL_MASK) &gt;&gt; MIPS32_CONFIG1_DL_SHIFT;
+
+	/* dl encoding : dl=1 =&gt; 4 bytes, dl=2 =&gt; 8 bytes, etc... */
+	clsiz = 0x2 &lt;&lt; dl;
+
+	/* TODO remove array */
+	uint32_t *param_in = malloc(3 * sizeof(uint32_t));
+	int retval;
+	param_in[0] = start_addr;
+	param_in[1] = end_addr;
+	param_in[2] = clsiz;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 3, param_in, 0, NULL, 1);
+
+	free(param_in);
+
+	return retval;
+}
+
+
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
+	int retval;
+
 	switch (size)
 	{
 		case 1:
-			return mips32_pracc_write_mem8(ejtag_info, addr, count, (uint8_t*)buf);
+			retval = mips32_pracc_write_mem8(ejtag_info, addr, count, (uint8_t*)buf);
+			break;
 		case 2:
-			return mips32_pracc_write_mem16(ejtag_info, addr, count,(uint16_t*)buf);
+			retval = mips32_pracc_write_mem16(ejtag_info, addr, count,(uint16_t*)buf);
+			break;
 		case 4:
 			if (count == 1)
-				return mips32_pracc_write_u32(ejtag_info, addr, (uint32_t*)buf);
+			{
+				retval = mips32_pracc_write_u32(ejtag_info, addr, (uint32_t*)buf);
+			}
 			else
-				return mips32_pracc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);
+			{
+				retval = mips32_pracc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);
+			}
+			break;
+		default:
+			retval = ERROR_FAIL;
 	}
 
-	return ERROR_OK;
+	/**
+	 * If we are in the cachable regoion and cache is activated,
+	 * we must clean D$ + invalidate I$ after we did the write,
+	 * so that changes do not continue to live only in D$, but to be
+	 * replicated in I$ also (maybe we wrote the istructions)
+	 */
+	uint32_t conf = 0;
+	int cached = 0;
+
+	mips32_cp0_read(ejtag_info, &amp;conf, 16, 0);
+
+	switch (KSEGX(addr))
+	{
+		case KUSEG:
+			cached = (conf &amp; MIPS32_CONFIG0_KU_MASK) &gt;&gt; MIPS32_CONFIG0_KU_SHIFT;
+			break;
+		case KSEG0 :
+			cached = (conf &amp; MIPS32_CONFIG0_K0_MASK) &gt;&gt; MIPS32_CONFIG0_K0_SHIFT;
+			break;
+		case KSEG1:
+			/* uncachable segment - nothing to do */
+			break;
+		case KSEG2:
+		case KSEG3:
+			cached = (conf &amp; MIPS32_CONFIG0_K23_MASK) &gt;&gt; MIPS32_CONFIG0_K23_SHIFT;
+			break;
+		default:
+			/* what ? */
+			break;
+	}
+
+	/**
+	 * Check cachablitiy bits coherency algorithm -
+	 * is the region cacheable or uncached.
+	 * If cacheable we have to synchronize the cache
+	 */
+	if (cached == 0x3)
+	{
+		uint32_t start_addr, end_addr;
+		uint32_t rel;
+
+		start_addr = addr;
+		end_addr = addr + count * size;
+
+		/** select cache synchronisation mechanism based on Architecture Release */
+		rel = (conf &amp; MIPS32_CONFIG0_AR_MASK) &gt;&gt; MIPS32_CONFIG0_AR_SHIFT;
+		switch (rel)
+		{
+			case MIPS32_ARCH_REL1 :
+				/* MIPS32/64 Release 1 - we must use cache instruction */
+				mips32_pracc_clean_invalidate_cache(ejtag_info, start_addr, end_addr);
+				break;
+			case MIPS32_ARCH_REL2 :
+				/* MIPS32/64 Release 2 - we can use synci instruction */
+				mips32_pracc_sync_cache(ejtag_info, start_addr, end_addr);
+				break;
+			default :
+				/* what ? */
+				break;
+		}
+	}
+
+	return retval;
 }
 
 static int mips32_pracc_write_mem32(struct mips_ejtag *ejtag_info, uint32_t addr, int count, uint32_t *buf)

commit 1be7163408cc6420d85bf990a2dae46c559a12b1
Author: Drasko DRASKOVIC &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>&gt;
Date:   Thu Jul 7 17:41:20 2011 +0200

    mips32: Added CP0 coprocessor R/W routines
    
    This patch adds MIPS32 CP0 coprocessor R/W routines,
    as well as adequate commands to use these routines via
    telnet interface.
    
    Now is becomes possible to affect CP0 internal registers
    and configure CPU directly from OpenOCD.

diff --git a/src/target/mips32.c b/src/target/mips32.c
index 65ea6e8..d7f001e 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -7,6 +7,9 @@
  *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe                                 *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -758,3 +761,106 @@ int mips32_blank_check_memory(struct target *target,
 
 	return ERROR_OK;
 }
+
+static int mips32_verify_pointer(struct command_context *cmd_ctx,
+		struct mips32_common *mips32)
+{
+	if (mips32-&gt;common_magic != MIPS32_COMMON_MAGIC) {
+		command_print(cmd_ctx, &quot;target is not an MIPS32&quot;);
+		return ERROR_TARGET_INVALID;
+	}
+	return ERROR_OK;
+}
+
+/**
+ * MIPS32 targets expose command interface
+ * to manipulate CP0 registers
+ */
+COMMAND_HANDLER(mips32_handle_cp0_command)
+{
+	int retval;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips_ejtag *ejtag_info = &amp;mips32-&gt;ejtag_info;
+
+
+	retval = mips32_verify_pointer(CMD_CTX, mips32);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		command_print(CMD_CTX, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, CMD_NAME);
+		return ERROR_OK;
+	}
+
+	/* two or more argument, access a single register/select (write if third argument is given) */
+	if (CMD_ARGC &lt; 2)
+	{
+		command_print(CMD_CTX, &quot;command requires more arguments.&quot;);
+	}
+	else
+	{
+		uint32_t cp0_reg, cp0_sel;
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
+
+		if (CMD_ARGC == 2)
+		{
+			uint32_t value;
+
+			if ((retval = mips32_cp0_read(ejtag_info, &amp;value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						&quot;couldn't access reg %&quot; PRIi32,
+						cp0_reg);
+				return ERROR_OK;
+			}
+			if ((retval = jtag_execute_queue()) != ERROR_OK)
+			{
+				return retval;
+			}
+
+			command_print(CMD_CTX, &quot;cp0 reg %&quot; PRIi32 &quot;, select %&quot; PRIi32 &quot;: %8.8&quot; PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+		else if (CMD_ARGC == 3)
+		{
+			uint32_t value;
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], value);
+			if ((retval = mips32_cp0_write(ejtag_info, value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						&quot;couldn't access cp0 reg %&quot; PRIi32 &quot;, select %&quot; PRIi32,
+						cp0_reg,  cp0_sel);
+				return ERROR_OK;
+			}
+			command_print(CMD_CTX, &quot;cp0 reg %&quot; PRIi32 &quot;, select %&quot; PRIi32 &quot;: %8.8&quot; PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration mips32_exec_command_handlers[] = {
+	{
+		.name = &quot;cp0&quot;,
+		.handler = mips32_handle_cp0_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;regnum select [value]&quot;,
+		.help = &quot;display/modify cp0 register&quot;,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration mips32_command_handlers[] = {
+	{
+		.name = &quot;mips32&quot;,
+		.mode = COMMAND_ANY,
+		.help = &quot;mips32 command group&quot;,
+		.chain = mips32_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
diff --git a/src/target/mips32.h b/src/target/mips32.h
index 4f0f0ef..8b21b0a 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -4,6 +4,9 @@
  *                                                                         *
  *   Copyright (C) 2008 by David T.L. Wong                                 *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -149,6 +152,8 @@ struct mips32_algorithm
 #define MIPS32_SDBBP				0x7000003F
 #define MIPS16_SDBBP				0xE801
 
+extern const struct command_registration mips32_command_handlers[];
+
 int mips32_arch_state(struct target *target);
 
 int mips32_init_arch_info(struct target *target,
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index cb8665c..1986e5c 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -6,6 +6,9 @@
  *                                                                         *
  *   Copyright (C) 2009 by David N. Claffey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dnclaffey at gmail.com</A>&gt;          *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -568,6 +571,98 @@ static int mips32_pracc_read_mem8(struct mips_ejtag *ejtag_info, uint32_t addr,
 	return retval;
 }
 
+int mips32_cp0_read(struct mips_ejtag *ejtag_info, uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel)
+{
+	/**
+	 * Do not make this code static, but regenerate it every time,
+	 * as 5th element has to be changed to add parameters
+	 */
+	uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+
+		/* 5 */ MIPS32_MFC0(8,0,0),							/* move COP0 [cp0_reg select] to $8 */
+
+		MIPS32_LUI(9,UPPER16(MIPS32_PRACC_PARAM_OUT)),		/* $11 = MIPS32_PRACC_PARAM_OUT */
+		MIPS32_ORI(9,9,LOWER16(MIPS32_PRACC_PARAM_OUT)),
+		MIPS32_SW(8,0,9),									/* sw $8,0($9) */
+
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(12)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/**
+	 * Note that our input parametes cp0_reg and cp0_sel
+	 * are numbers (not gprs) which make part of mfc0 instruction opcode.
+	 *
+	 * These are not fix, but can be different for each mips32_cp0_read() function call,
+	 * and that is why we must insert them directly into opcode,
+	 * i.e. we can not pass it on EJTAG microprogram stack (via param_in),
+	 * and put them into the gprs later from MIPS32_PRACC_STACK
+	 * because mfc0 do not use gpr as a parameter for the cp0_reg and select part,
+	 * but plain (immediate) number.
+	 *
+	 * MIPS32_MTC0 is implemented via MIPS32_R_INST macro.
+	 * In order to insert our parameters, we must change rd and funct fields.
+	 */
+	code[5] |= (cp0_reg &lt;&lt; 11) | cp0_sel;  /* change rd and funct of MIPS32_R_INST macro */
+
+	/* TODO remove array */
+	uint32_t *param_out = val;
+	int retval;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 0, NULL, 1, param_out, 1);
+
+	return retval;
+}
+
+int mips32_cp0_write(struct mips_ejtag *ejtag_info,
+											uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel)
+{
+	uint32_t code[] = {
+															/* start: */
+		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
+		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),			/* $15 = MIPS32_PRACC_STACK */
+		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
+		MIPS32_SW(8,0,15),									/* sw $8,($15) */
+		MIPS32_SW(9,0,15),									/* sw $9,($15) */
+
+		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
+		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
+		MIPS32_LW(9,0,8),									/* Load write val to $9 */
+
+		/* 8 */ MIPS32_MTC0(9,0,0),							/* move $9 to COP0 [cp0_reg select] */
+
+		MIPS32_LW(9,0,15),									/* lw $9,($15) */
+		MIPS32_LW(8,0,15),									/* lw $8,($15) */
+		MIPS32_B(NEG16(12)),								/* b start */
+		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
+	};
+
+	/**
+	 * Note that MIPS32_MTC0 macro is implemented via MIPS32_R_INST macro.
+	 * In order to insert our parameters, we must change rd and funct fields.
+	 */
+	code[8] |= (cp0_reg &lt;&lt; 11) | cp0_sel;  /* change rd and funct fields of MIPS32_R_INST macro */
+
+	/* TODO remove array */
+	uint32_t *param_in = malloc(1 * sizeof(uint32_t));
+	int retval;
+	param_in[0] = val;
+
+	retval = mips32_pracc_exec(ejtag_info, ARRAY_SIZE(code), code, 1, param_in, 0, NULL, 1);
+
+	free(param_in);
+
+	return retval;
+}
+
 int mips32_pracc_write_mem(struct mips_ejtag *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
 	switch (size)
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
index b207a5b..0c106ba 100644
--- a/src/target/mips32_pracc.h
+++ b/src/target/mips32_pracc.h
@@ -4,6 +4,9 @@
  *                                                                         *
  *   Copyright (C) 2008 by David T.L. Wong                                 *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -35,9 +38,9 @@
 #define MIPS32_PRACC_PARAM_OUT_SIZE		0x1000
 
 #define MIPS32_FASTDATA_HANDLER_SIZE	0x80
-#define UPPER16(uint32_t) 				(uint32_t &gt;&gt; 16)
-#define LOWER16(uint32_t) 				(uint32_t &amp; 0xFFFF)
-#define NEG16(v) 						(((~(v)) + 1) &amp; 0xFFFF)
+#define UPPER16(uint32_t)				(uint32_t &gt;&gt; 16)
+#define LOWER16(uint32_t)				(uint32_t &amp; 0xFFFF)
+#define NEG16(v)						(((~(v)) + 1) &amp; 0xFFFF)
 /*#define NEG18(v) (((~(v)) + 1) &amp; 0x3FFFF)*/
 
 int mips32_pracc_read_mem(struct mips_ejtag *ejtag_info,
@@ -54,4 +57,36 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, int code_len, const uint32_
 		int num_param_in, uint32_t *param_in,
 		int num_param_out, uint32_t *param_out, int cycle);
 
+/**
+ * \b mips32_cp0_read
+ *
+ * Simulates mfc0 ASM instruction (Move From C0),
+ * i.e. implements copro C0 Register read.
+ *
+ * @param[in] ejtag_info
+ * @param[in] val Storage to hold read value
+ * @param[in] cp0_reg Number of copro C0 register we want to read
+ * @param[in] cp0_sel Select for the given C0 register
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_cp0_read(struct mips_ejtag *ejtag_info,
+								uint32_t *val, uint32_t cp0_reg, uint32_t cp0_sel);
+
+/**
+ * \b mips32_cp0_write
+ *
+ * Simulates mtc0 ASM instruction (Move To C0),
+ * i.e. implements copro C0 Register read.
+ *
+ * @param[in] ejtag_info
+ * @param[in] val Value to be written
+ * @param[in] cp0_reg Number of copro C0 register we want to write to
+ * @param[in] cp0_sel Select for the given C0 register
+ *
+ * @return ERROR_OK on Sucess, ERROR_FAIL otherwise
+ */
+int mips32_cp0_write(struct mips_ejtag *ejtag_info,
+											uint32_t val, uint32_t cp0_reg, uint32_t cp0_sel);
+
 #endif
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 822d0c8..350ed51 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -6,6 +6,9 @@
  *                                                                         *
  *   Copyright (C) 2009 by David N. Claffey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dnclaffey at gmail.com</A>&gt;          *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -1078,13 +1081,13 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		return ERROR_FAIL;
 	}
 
- 	uint32_t i, t32;
+	uint32_t i, t32;
 	for(i = 0; i &lt; (count*4); i += 4)
 	{
 		t32 = target_buffer_get_u32(target,&amp;buffer[i]);
 		h_u32_to_le(&amp;t[i], t32);
 	}
-	
+
 	retval = mips32_pracc_fastdata_xfer(ejtag_info, mips32-&gt;fast_data_area, write_t, address,
 			count, (uint32_t*) (void *)t);
 
@@ -1101,6 +1104,106 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 	return retval;
 }
 
+static int mips_m4k_verify_pointer(struct command_context *cmd_ctx,
+		struct mips_m4k_common *mips_m4k)
+{
+	if (mips_m4k-&gt;common_magic != MIPSM4K_COMMON_MAGIC) {
+		command_print(cmd_ctx, &quot;target is not an MIPS_M4K&quot;);
+		return ERROR_TARGET_INVALID;
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(mips_m4k_handle_cp0_command)
+{
+	int retval;
+	struct target *target = get_current_target(CMD_CTX);
+	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
+	struct mips_ejtag *ejtag_info = &amp;mips_m4k-&gt;mips32.ejtag_info;
+
+	retval = mips_m4k_verify_pointer(CMD_CTX, mips_m4k);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target-&gt;state != TARGET_HALTED)
+	{
+		command_print(CMD_CTX, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, CMD_NAME);
+		return ERROR_OK;
+	}
+
+	/* two or more argument, access a single register/select (write if third argument is given) */
+	if (CMD_ARGC &lt; 2)
+	{
+		command_print(CMD_CTX, &quot;command requires more arguments.&quot;);
+	}
+	else
+	{
+		uint32_t cp0_reg, cp0_sel;
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], cp0_reg);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], cp0_sel);
+
+		if (CMD_ARGC == 2)
+		{
+			uint32_t value;
+
+			if ((retval = mips32_cp0_read(ejtag_info, &amp;value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						&quot;couldn't access reg %&quot; PRIi32,
+						cp0_reg);
+				return ERROR_OK;
+			}
+			if ((retval = jtag_execute_queue()) != ERROR_OK)
+			{
+				return retval;
+			}
+
+			command_print(CMD_CTX, &quot;cp0 reg %&quot; PRIi32 &quot;, select %&quot; PRIi32 &quot;: %8.8&quot; PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+		else if (CMD_ARGC == 3)
+		{
+			uint32_t value;
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], value);
+			if ((retval = mips32_cp0_write(ejtag_info, value, cp0_reg, cp0_sel)) != ERROR_OK)
+			{
+				command_print(CMD_CTX,
+						&quot;couldn't access cp0 reg %&quot; PRIi32 &quot;, select %&quot; PRIi32,
+						cp0_reg,  cp0_sel);
+				return ERROR_OK;
+			}
+			command_print(CMD_CTX, &quot;cp0 reg %&quot; PRIi32 &quot;, select %&quot; PRIi32 &quot;: %8.8&quot; PRIx32,
+					cp0_reg, cp0_sel, value);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration mips_m4k_exec_command_handlers[] = {
+	{
+		.name = &quot;cp0&quot;,
+		.handler = mips_m4k_handle_cp0_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;regnum [value]&quot;,
+		.help = &quot;display/modify cp0 register&quot;,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration mips_m4k_command_handlers[] = {
+	{
+		.chain = mips32_command_handlers,
+	},
+	{
+		.name = &quot;mips_m4k&quot;,
+		.mode = COMMAND_ANY,
+		.help = &quot;mips_m4k command group&quot;,
+		.chain = mips_m4k_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
 struct target_type mips_m4k_target =
 {
 	.name = &quot;mips_m4k&quot;,
@@ -1133,6 +1236,7 @@ struct target_type mips_m4k_target =
 	.add_watchpoint = mips_m4k_add_watchpoint,
 	.remove_watchpoint = mips_m4k_remove_watchpoint,
 
+	.commands = mips_m4k_command_handlers,
 	.target_create = mips_m4k_target_create,
 	.init_target = mips_m4k_init_target,
 	.examine = mips_m4k_examine,
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index 85d4c0a..11a936f 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -4,6 +4,9 @@
  *                                                                         *
  *   Copyright (C) 2008 by David T.L. Wong                                 *
  *                                                                         *
+ *   Copyright (C) 2011 by Drasko DRASKOVIC                                *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>                                            *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -43,4 +46,6 @@ target_to_m4k(struct target *target)
 			struct mips_m4k_common, mips32);
 }
 
+extern const struct command_registration mips_m4k_command_handlers[];
+
 #endif	/*MIPS_M4K_H*/

commit 800bc9308dfcae950cd95ca287876b60401e7608
Author: Drasko DRASKOVIC &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>&gt;
Date:   Thu Jul 7 16:38:38 2011 +0200

    mips_m4k: common_magic should be unsigned
    
    For all architectures we use distinct common magic number,
    and this should be a uint32_t type.
    Otherwise, comparison with macros will yield compilation
    warning.

diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index bb37ee2..85d4c0a 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -31,7 +31,7 @@ struct target;
 
 struct mips_m4k_common
 {
-	int common_magic;
+	uint32_t common_magic;
 	bool is_pic32mx;
 	struct mips32_common mips32;
 };

commit e1466df54d8ddd6800f8df2f9e0d2f1dd646cb20
Author: Drasko DRASKOVIC &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">drasko.draskovic at gmail.com</A>&gt;
Date:   Tue Jul 5 17:37:05 2011 +0200

    mips32: Removed Unnecessary JTAG Queue Flush
    
    jtag_execute_queue() is executed as a part of mips_ejtag_drscan_32().
    No need for this to be done before - removed for optimisation.

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index af60d32..cb8665c 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -115,18 +115,12 @@ static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 	uint32_t ejtag_ctrl;
 	long long then = timeval_ms();
 	int timeout;
+	int retval;
 
 	/* wait for the PrAcc to become &quot;1&quot; */
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl;
 
-	int retval;
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR(&quot;fastdata load failed&quot;);
-		return retval;
-	}
-
 	while (1)
 	{
 		retval = mips_ejtag_drscan_32(ejtag_info, &amp;ejtag_ctrl);

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips32.c       |  106 ++++++++++++++
 src/target/mips32.h       |  117 ++++++++++++---
 src/target/mips32_pracc.c |  342 +++++++++++++++++++++++++++++++++++++++++++--
 src/target/mips32_pracc.h |   41 +++++-
 src/target/mips_m4k.c     |  157 ++++++++++++++++++---
 src/target/mips_m4k.h     |    7 +-
 6 files changed, 706 insertions(+), 64 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002658.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-9-g194e3c5
</A></li>
	<LI>Next message: <A HREF="002661.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-21-gf25ffaf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2660">[ date ]</a>
              <a href="thread.html#2660">[ thread ]</a>
              <a href="subject.html#2660">[ subject ]</a>
              <a href="author.html#2660">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
