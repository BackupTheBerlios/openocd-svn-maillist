<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-61-g3533626
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-August/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-61-g3533626&In-Reply-To=%3Cmailman.165.1331736157.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002679.html">
   <LINK REL="Next"  HREF="002681.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-61-g3533626</H1>
    <B>&#195;&#152;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-61-g3533626&In-Reply-To=%3Cmailman.165.1331736157.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-61-g3533626">gowinex at users.sourceforge.net
       </A><BR>
    <I>Wed Aug 31 16:26:22 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002679.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-50-g7e20eda
</A></li>
        <LI>Next message: <A HREF="002681.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-70-gfbbce95
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2680">[ date ]</a>
              <a href="thread.html#2680">[ thread ]</a>
              <a href="subject.html#2680">[ subject ]</a>
              <a href="author.html#2680">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  353362651fc28c1f1d823659cde36dd31d1aede6 (commit)
       via  1d135dddf27f6f8dd2ceee2e3b07a0b91e098459 (commit)
       via  c331c9382f3e2442b4ddc6a5c65c5278b19938eb (commit)
       via  6446dbaacbf7c0607ea571ed7f5a4f32745544eb (commit)
       via  c881fb8532235c9dd1b0b3c6fa05a20ce9018306 (commit)
       via  d1bd5569b30704faaef574759bd07493c1129989 (commit)
       via  118a9a9ca044bc85955aaec1bb2ef58f9aad19de (commit)
       via  b6e4d26695bd2268638ad52a1860f1c849b177cf (commit)
       via  d01cbd71434d9ef0666fe9a3a1a29c9897b5caae (commit)
       via  b6f8b2ab669d070d6a4b82b36c4b0787bf162112 (commit)
       via  3633e8d7b8b88d58cfc5989a330dfbaa6b66fad4 (commit)
      from  7e20eda9446a4c66765169dfcbc506c23f320540 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 353362651fc28c1f1d823659cde36dd31d1aede6
Author: Martin Schmoelzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Tue Aug 23 17:22:53 2011 +0200

    ULINK driver: Update firmware image to reflect the latest changes in source code.
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/OpenULINK/ulink_firmware.hex b/src/jtag/drivers/OpenULINK/ulink_firmware.hex
index 9e74423..dcb724b 100644
--- a/src/jtag/drivers/OpenULINK/ulink_firmware.hex
+++ b/src/jtag/drivers/OpenULINK/ulink_firmware.hex
@@ -11,241 +11,346 @@
 :01005300327A
 :01005B003272
 :01006300326A
-:03006B0002011F70
-:0300D90002006EB4
-:05006E0012011080FEEC
-:1000DC00907F937404F0907F9C7495F0907F96744D
-:1000EC0090F0907F94E4F0907F9D747FF0907F97D8
-:1000FC00E4F0907F957440F0907F9E7442F0907F76
-:10010C0098E4F0221200DC1204FCD2AF1207C89063
-:03011C00000022BE
+:03006B000201256A
+:0300DF0002006EAE
+:05006E0012011680FEE6
+:1000E200907F937404F0907F9C7495F0907F967447
+:1000F20090F0907F94E4F0907F9D747FF0907F97D2
+:10010200E4F0907F957440F0907F9E7442F0907F6F
+:1001120098E4F0221200E2120502D2AF12093590E1
+:03012200000022B8
 :0400CC00C200C201AB
-:10011F00C021C0E0C0F0C082C083C002C003C004D1
-:10012F00C005C006C007C000C001C0D075D00053C5
-:10013F0091EF120455907FAB7401F0907FB4E044BF
-:10014F0002F0D0D0D001D000D007D006D005D00417
-:10015F00D003D002D083D082D0F0D0E0D021323281
-:10016F003232323232323232C0E0C082C083D201F8
-:10017F005391EF907FA97404F0D083D082D0E032F6
-:10018F00C0E0C082C083D2005391EF907FAA740465
-:10019F00F0D083D082D0E032323232323232323249
-:1001AF003232AA82747F5AFB7407B50300500302E0
-:1001BF000269EB2B2B9001C8730201E00201E402EC
-:1001CF0001F702020A02021D02023002024302027A
-:1001DF0056907FB422EA30E7067BB67C7F80047BA3
-:1001EF00C67C7F8B828C8322EA30E7067BB87C7FCC
-:1001FF0080047BC87C7F8B828C8322EA30E7067B6E
-:10020F00BA7C7F80047BCA7C7F8B828C8322EA300E
-:10021F00E7067BBC7C7F80047BCC7C7F8B828C83CE
-:10022F0022EA30E7067BBE7C7F80047BCE7C7F8B0F
-:10023F00828C8322EA30E7067BC07C7F80047BD0F0
-:10024F007C7F8B828C8322EA30E7067AC27B7F80A9
-:10025F00047AD27B7F8A828B832290000022AA822B
-:10026F0074105AFB74075A4203907FD7EBF0742037
-:10027F004BF022907FE8E0FABA8002800ABA81023E
-:10028F008016BA825D8022907F00E4F0907F01F0AB
-:10029F00907FB57402F0804C907F00E4F0907F0166
-:1002AF00F0907FB57402F0803B907FECE0FAA3E012
-:1002BF008A821201B1AA82AB837C008A828B838CE3
-:1002CF00F0120D90FA30E008907F007401F0800575
-:1002DF00907F00E4F0907F01E4F0907FB57402F01E
-:1002EF008002C322D322907FE8E0FA6005BA02466B
-:1002FF00800A907FB4E0FA4401F0803A907FEAE000
-:10030F00FAA3E0FB4A7027907FECE0FAA3E08A8221
-:10031F001201B1AA82AB83EA4B7002C3228A828B8D
-:10032F0083E0FC5304FE8A828B83ECF08008907F7D
-:10033F00B4E0FA4401F0D322907FE8E0FA6005BA06
-:10034F0002468010907FEAE0FAA3E0FBBA0239BBC5
-:10035F000036D322907FEAE0FAA3E0FB4A702790A1
-:10036F007FECE0FAA3E08A821201B1AA82AB83EAA2
-:10037F004B7002C3228A828B83E0FC4304018A8282
-:10038F008B83ECF08002C322D322907FEAE0A3E0BC
-:10039F00FA907FEAE0FBA3E07C00BA0102800CBA7E
-:1003AF000202801DBA0302802E807B7AB07C0D90F2
-:1003BF007FD4ECF07AB07C0D7C00907FD5EAF08092
-:1003CF00677AC27C0D907FD4ECF07AC27C0D7C00F2
-:1003DF00907FD5EAF08051907FECE0FAA3E0FC4AE1
-:1003EF0070167AE27C0D907FD4ECF07AE27C0D7C73
-:1003FF0000907FD5EAF08030907FECE0FAA3E0FC2C
-:10040F00BA0921BC041E1BEB2BFA900E3693CAA31C
-:10041F0093FB8A048B05907FD4EDF07B00907FD502
-:10042F00EAF08004C322C322D32275828212026DA6
-:10043F0075820212026D907FB87402F0907FC8E44B
-:10044F00F0907FC9F022907FE9E0FA740CB50200BA
-:10045F00500122EA2A2A9004697302049002049E32
-:10046F000204AC0204B40204AC0204C10204CA02C6
-:10047F0004C20204D70204E70204E80204F80204EB
-:10048F00FB120282500122907FB4E04401F022124D
-:10049F0002F5500122907FB4E04401F022907FB426
-:1004AF00E04401F0221203474042907FB4E0440140
-:1004BF00F02222907FB4E04401F022120399402CE5
-:1004CF00907FB4E04401F022900DC7E493907F0039
-:1004DF00F0907FB57401F02222900DCDE493907FC0
-:1004EF0000F0907FB57401F02212043922907FDE64
-:1004FF007404F0907FDF7404F0907FE0E4F0907F5D
-:10050F00E1F0907FA17401F0907FAFE04401F09093
-:10051F007FAEE04401F0907FAD7404F0907FAC7437
-:10052F0004F0D2E8907FD6740AF09000C8120D3D07
-:07053F00907FD67406F02244
-:100DB00012011001FFFFFF4051C210270001010284
-:100DC000030109022000010104803209040000022D
-:100DD000FFFFFF00070582024000000705020240F6
-:100DE00000000403090414034F00700065006E0046
-:100DF00055004C0049004E004B0014034F0070009A
-:100E000065006E0055004C0049004E004B000E037B
-:100E10003000300030003000300031001A034A004A
-:100E20005400410047002000410064006100700050
-:0E0E3000740065007200E60DFA0D0E0E1C0E29
-:10054600E5080424C0F582E4347DF583E0FA30E161
-:1005560008907F96E0FB54EFF0EA30E008907F9633
-:10056600E0FB547FF0EA30E308907F96E0FB44100E
-:10057600F0EA30E208907F96E0FA4480F0227A00B2
-:10058600E50824C0F582E4347DF583E0FB603EBBDC
-:100596000202805FBB040302061CBB200302064363
-:1005A600BB2203020673BB23030206ACBB24030271
-:1005B60006E5BB250302071DBB260302074CBB2825
-:1005C6000302077BBB290302078A02078E7B05E528
-:1005D600080424C0F582E4347DF583E0FAE50804D6
-:1005E600F58285090DC002C003120805D003D002AA
-:1005F600020790E5080424C0F582E4347DF583E023
-:100606002405FBE50804F582C002C003120951D097
-:1006160003D002020790E5080424C0F582E4347D85
-:10062600F583E0FA2405FBE50804F582850917C081
-:1006360002C003120A83D003D0020207907B02E5B0
-:10064600080424C0F582E4347DF583E0FC740225B9
-:100656000824C0F582E4347DF583E0F5228C82C05F
-:1006660002C003120C5BD003D0020207907B02E5A6
-:10067600080424C0F582E4347DF583E0FC7D007433
-:1006860002250824C0F582E4347DF583E0FFE442C8
-:1006960004EF42058C828D83C002C003120C20D069
-:1006A60003D0020207907B02E5080424C0F582E429
-:1006B600347DF583E0FC7D007402250824C0F582B4
-:1006C600E4347DF583E0FFE44204EF42058C828D3D
-:1006D60083C002C003120D0AD003D0020207907B2A
-:1006E60002E5080424C0F582E4347DF583E0FC7D50
-:1006F600007402250824C0F582E4347DF583E0FF0A
-:10070600E44204EF42058C828D83C002C003120DC1
-:100716003DD003D00280737B007A02C002C0031270
-:100726000C95AC82AD83D003D00285098275837E99
-:100736008D06EEF0E509042400F582E4347EF583A7
-:100746007D00ECF080447B02E5080424C0F582E4D9
-:10075600347DF583E0FC7402250824C0F582E43478
-:100766007DF583E0F5228C82C002C003120CD8D03E
-:1007760003D00280157B01C002C003120546D003D8
-:10078600D00280067B0180027B00EA2509F509AAD2
-:10079600087C008B057E00ED2AFAEE3CFC0ABA00C6
-:1007A600010C907FC9E0FD7E00C3EA9DEC64808E5B
-:1007B600F063F08095F04002D322EB042508F5089B
-:1007C600C32275080075090010000280FB907F9611
-:1007D600E0FA547FF0C202200207120584920280DA
-:1007E600F6907F96E0FA4480F0E509600B907FB9B9
-:0F07F600E509F010010280FB907FC9E4F080C399
-:0900D000750A00750B00750C00A7
-:10080500E582FA24C0F582E4347DF583E0F50EEA4D
-:100815000424C0F582E4347DF583E0F50F74022AE3
-:10082500FD24C0F582E4347DF583E0C4540FFE5306
-:10083500060FED24C0F582E4347DF583E0FD740FE9
-:100845005DF51074032A24C0F582E4347DF583E058
-:10085500FF74042A24C0F582E4347DF583E0F511A4
-:10086500EE60078F228E82120C5B907F97E0FE531D
-:1008750006F87F0074044EF87900AD0E7B001DBDAF
-:10088500FF011B89027C00C3EA9DEC64808BF06349
-:10089500F08095F050357A007B00BB080050199028
-:1008A5007F97EEF0E8F0EAC313FA907F99E0FC3009
-:1008B500E5034302800B80E2E50D292400F582E47F
-:1008C500347EF583EAF009890780AF89077A00ABA2
-:1008D50010751200E512B50F00503EAD0F78001DE2
-:1008E500BDFF0118A9127C00E9B50511ECB5000D95
-:1008F500EB600A4306021BE511C313F511907F97C0
-:10090500EEF074044EF0EAC313FA907F99E0FC30E0
-:10091500E503430280051280BBAC0F7D007408C35C
-:100925009CFCE49DFD8CF005F0EA8002C313D5F034
-:10093500FBFAE50D2F2400F582E4347EF583EAF019
-:10094500EB60088511228B82020C5B22E582FA247A
-:10095500C0F582E4347DF583E0F513EA0424C0F59F
-:1009650082E4347DF583E0F51474022AFD24C0F594
-:1009750082E4347DF583E0C4540FFE53060FED2465
-:10098500C0F582E4347DF583E0FD740F5DF51574E3
-:10099500032A24C0F582E4347DF583E0FF74042A3C
-:1009A50024C0F582E4347DF583E0F516EE600B8F07
-:1009B500228E82C002120C5BD002907F97E0FE531C
-:1009C50006F97F00A9137D0019B9FF011D8F037872
-:1009D50000C3EB99E864808DF063F08095F05038A2
-:1009E500EA2F240524C0F582E4347DF583E0FB7D00
-:1009F50000BD0800501FEB30E0054306018003539E
-:100A050006FE907F97EEF0EBC313FB907F9774047F
-:100A15004EF00D80DC0F80ACEA2F240524C0F58252
-:100A2500E4347DF583E0FBAA157D00EDB514005097
-:100A350041EB30E00543060180035306FEAF147811
-:100A4500001FBFFF01188D017C00E9B50711ECB54A
-:100A5500000DEA600A4306021AE516C313F516905F
-:100A65007F97EEF0EBC313FB907F9774044EF00D68
-:100A750080B9EA60088516228A82020C5B22E5822B
-:100A8500F51824C0F582E4347DF583E0F519E51801
-:100A95000424C0F582E4347DF583E0F51A7402255B
-:100AA50018FD24C0F582E4347DF583E0C4540FFEBF
-:100AB50053060FED24C0F582E4347DF583E0FD7423
-:100AC5000F5DF51B7403251824C0F582E4347DF50C
-:100AD50083E0FF7404251824C0F582E4347DF58392
-:100AE500E0F51CEE60078F228E82120C5B907F97DB
-:100AF500E0FE5306F97F007900AD197B001DBDFFAF
-:100B0500011B89007A00C3E89DEA64808BF063F0DD
-:100B15008095F0505EE51829240524C0F582E4345B
-:100B25007DF583E0F51D7B007D00BD08005031E5B6
-:100B35001D30E00543060180035306FE907F97EEC6
-:100B4500F0E51DC313F51D907F9774044EF0EBC3BC
-:100B550013FB907F99E0F830E5034303800D80CACD
-:100B6500E517292400F582E4347EF583EBF0098945
-:100B75000780868907E51829240524C0F582E43411
-:100B85007DF583E0F51D7B00AD1B751E00E51EB5EB
-:100B95001A005054E51D30E0054306018003530655
-:100BA500FEA91A7C0019B9FF011CA81E7A00E8B538
-:100BB5000111EAB5040DED600A4306021DE51CC3EB
-:100BC50013F51C907F97EEF0E51DC313F51D907F7F
-:100BD5009774044EF0EBC313FB907F99E0FA30E570
-:100BE50003430380051E80A5AC1A7A007408C39CD4
-:100BF500FCE49AFA8CF005F0EB8002C313D5F0FB08
-:100C0500FBE5172F2400F582E4347EF583EBF0ED48
-:100C15006008851C228D82020C5B22AA82AB837C34
-:100C2500007D00C3EC9AED9B502B907F97E054FB21
-:100C3500F07E00EEB50B0050030E80F7907F97E035
-:100C45004404F07E00EEB50B0050030E80F70CBC9B
-:100C550000D10D80CE22AA82907F97E0FB74FB5BCA
-:100C6500F5237B00EBB502005024E52230E0054377
-:100C7500230280035323FD907F97E523F0E522C3EC
-:100C850013F522907F9774044523F00B80D622221A
-:100C95007A00907F99E0FB30E5027A01907F99E038
-:100CA500FB30E603430202907F9AE0FB30E7034303
-:100CB5000204907F9BE0FB30E503430208907F9A96
-:100CC500E0FB53037F8A04E4FAFDEB4AF582ED4C21
-:100CD500F58322E582547FF4FA907F97E05AF07409
-:100CE5007F5522FA907F97E04AF02285820A852275
-:100CF5000B85230C2200227A567B021ABAFF011BB0
-:100D0500EA4B70F722752205752300120D67AA823A
-:100D1500AB837C007D00C3EC9AED9B501AC002C0EA
-:100D250003C004C005120CFAD005D004D003D002CC
-:100D35000CBC00E20D80DF22AA82AB837C007D0023
-:100D4500C3EC9AED9B501AC002C003C004C0051243
-:100D55000CFCD005D004D003D0020CBC00E20D8001
-:020D6500DF228B
+:10012500C021C0E0C0F0C082C083C002C003C004CB
+:10013500C005C006C007C000C001C0D075D00053BF
+:1001450091EF12045B907FAB7401F0907FB4E044B3
+:1001550002F0D0D0D001D000D007D006D005D00411
+:10016500D003D002D083D082D0F0D0E0D02132327B
+:100175003232323232323232C0E0C082C083D201F2
+:100185005391EF907FA97404F0D083D082D0E032F0
+:10019500C0E0C082C083D2005391EF907FAA74045F
+:1001A500F0D083D082D0E032323232323232323243
+:1001B5003232AA82747F5AFB7407B50300500302DA
+:1001C500026FEB2B2B9001CE730201E60201EA02CE
+:1001D50001FD020210020223020236020249020256
+:1001E5005C907FB422EA30E7067BB67C7F80047B97
+:1001F500C67C7F8B828C8322EA30E7067BB87C7FC6
+:1002050080047BC87C7F8B828C8322EA30E7067B67
+:10021500BA7C7F80047BCA7C7F8B828C8322EA3008
+:10022500E7067BBC7C7F80047BCC7C7F8B828C83C8
+:1002350022EA30E7067BBE7C7F80047BCE7C7F8B09
+:10024500828C8322EA30E7067BC07C7F80047BD0EA
+:100255007C7F8B828C8322EA30E7067AC27B7F80A3
+:10026500047AD27B7F8A828B832290000022AA8225
+:1002750074105AFB74075A4203907FD7EBF0742031
+:100285004BF022907FE8E0FABA8002800ABA810238
+:100295008016BA825D8022907F00E4F0907F01F0A5
+:1002A500907FB57402F0804C907F00E4F0907F0160
+:1002B500F0907FB57402F0803B907FECE0FAA3E00C
+:1002C5008A821201B7AA82AB837C008A828B838CD7
+:1002D500F0121427FA30E008907F007401F08005D1
+:1002E500907F00E4F0907F01E4F0907FB57402F018
+:1002F5008002C322D322907FE8E0FA6005BA024665
+:10030500800A907FB4E0FA4401F0803A907FEAE0F9
+:10031500FAA3E0FB4A7027907FECE0FAA3E08A821B
+:100325001201B7AA82AB83EA4B7002C3228A828B81
+:1003350083E0FC5304FE8A828B83ECF08008907F77
+:10034500B4E0FA4401F0D322907FE8E0FA6005BA00
+:1003550002468010907FEAE0FAA3E0FBBA0239BBBF
+:100365000036D322907FEAE0FAA3E0FB4A7027909B
+:100375007FECE0FAA3E08A821201B7AA82AB83EA96
+:100385004B7002C3228A828B83E0FC4304018A827C
+:100395008B83ECF08002C322D322907FEAE0A3E0B6
+:1003A500FA907FEAE0FBA3E07C00BA0102800CBA78
+:1003B5000202801DBA0302802E807B7A477C14904E
+:1003C5007FD4ECF07A477C147C00907FD5EAF080EE
+:1003D500677A597C14907FD4ECF07A597C147C00B0
+:1003E500907FD5EAF08051907FECE0FAA3E0FC4ADB
+:1003F50070167A797C14907FD4ECF07A797C147C31
+:1004050000907FD5EAF08030907FECE0FAA3E0FC25
+:10041500BA0921BC041E1BEB2BFA9014CD93CAA379
+:1004250093FB8A048B05907FD4EDF07B00907FD5FC
+:10043500EAF08004C322C322D3227582821202739A
+:10044500758202120273907FB87402F0907FC8E43F
+:10045500F0907FC9F022907FE9E0FA740CB50200B4
+:10046500500122EA2A2A90046F730204960204A41A
+:100475000204B20204BA0204B20204C70204D002A2
+:1004850004C80204DD0204ED0204EE0204FE0205C6
+:1004950001120288500122907FB4E04401F022123B
+:1004A50002FB500122907FB4E04401F022907FB41A
+:1004B500E04401F02212034D4042907FB4E0440134
+:1004C500F02222907FB4E04401F02212039F402CD9
+:1004D500907FB4E04401F02290145EE493907F0095
+:1004E500F0907FB57401F02222901464E493907F1C
+:1004F50000F0907FB57401F02212043F22907FDE58
+:100505007404F0907FDF7404F0907FE0E4F0907F56
+:10051500E1F0907FA17401F0907FAFE04401F0908D
+:100525007FAEE04401F0907FAD7404F0907FAC7431
+:1005350004F0D2E8907FD6740AF09000C81213D464
+:07054500907FD67406F0223E
+:1014470012011001FFFFFF4051C2102700010102E6
+:10145700030109022000010104803209040000028F
+:10146700FFFFFF0007058202400000070502024058
+:1014770000000403090414034F00700065006E00A8
+:1014870055004C0049004E004B0014034F007000FC
+:1014970065006E0055004C0049004E004B000E03DE
+:1014A7003000300030003000300031001A034A00AD
+:1014B70054004100470020004100640061007000B3
+:0E14C7007400650072007D149114A514B31416
+:10054C00E5080424C0F582E4347DF583E0FA30E15B
+:10055C0008907F96E0FB54EFF0EA30E008907F962D
+:10056C00E0FB547FF0EA30E308907F96E0FB441008
+:10057C00F0EA30E208907F96E0FA4480F0227A00AC
+:10058C00E50824C0F582E4347DF583E0FB742AB5DC
+:10059C00030050030208FBEB240983C0E0EB242E7C
+:1005AC0083C0E02206DF2C054F28FBFBFBFBFBFB8B
+:1005BC00FBFBFBFBFBFBFBFBFBFBFBFBFBFBFBFB7F
+:1005CC00FBFBFBFB764FA67FB8F12A5A89E8F706AE
+:1005DC000606070607080808080808080808080897
+:1005EC000808080808080808080808080808080681
+:1005FC00070607070708080808087B05E508042410
+:10060C00C0F582E4347DF583E0FAE50804F58285D3
+:10061C000927C002C003120972D003D0020208FDE0
+:10062C00E5080424C0F582E4347DF583E02405FB61
+:10063C00E50804F582C002C003120C42D003D002BC
+:10064C000208FDE5080424C0F582E4347DF583E05E
+:10065C00FA2405FBE50804F58285093BC002C003BA
+:10066C00120ED2D003D0020208FD7B02E50804244E
+:10067C00C0F582E4347DF583E0FC7402250824C0C7
+:10068C00F582E4347DF583E0F50A8C82C002C00368
+:10069C001212A6D003D0020208FD7B02E508042446
+:1006AC00C0F582E4347DF583E0FC7D0074022508FE
+:1006BC0024C0F582E4347DF583E0FFE44204EF428C
+:1006CC00058C828D83C002C003121239D003D00274
+:1006DC000208FD7B05E5080424C0F582E4347DF5B1
+:1006EC0083E0FAE50804F58285092DC002C00312E7
+:1006FC000AC4D003D0020208FDE5080424C0F58228
+:10070C00E4347DF583E02405FBE50804F582C002A2
+:10071C00C003120D74D003D0020208FDE5080424B6
+:10072C00C0F582E4347DF583E0FA2405FBE508048A
+:10073C00F582850943C002C00312106FD003D002AA
+:10074C000208FD7B02E5080424C0F582E4347DF543
+:10075C0083E0FE7402250824C0F582E4347DF58321
+:10076C00E0F50A8E82C002C0031212DBD003D00265
+:10077C000208FD7B02E5080424C0F582E4347DF513
+:10078C0083E0FC7D007402250824C0F582E4347DEE
+:10079C00F583E0FFE44204EF42058C828D83C002B6
+:1007AC00C003121263D003D0020208FD7B02E508DD
+:1007BC000424C0F582E4347DF583E0FC7D007402F2
+:1007CC00250824C0F582E4347DF583E0FFE442047F
+:1007DC00EF42058C828D83C002C0031213A1D0039B
+:1007EC00D0020208FD7B02E5080424C0F582E43443
+:1007FC007DF583E0FC7D007402250824C0F582E4BD
+:10080C00347DF583E0FFE44204EF42058C828D8356
+:10081C00C002C0031213D4D003D0020208FD7B0027
+:10082C007A02C002C003121326AC82AD83D003D06F
+:10083C000285098275837E8D06EEF0E5090424009D
+:10084C00F582E4347EF5837D00ECF00208FD7B023A
+:10085C00E5080424C0F582E4347DF583E0FC7402E1
+:10086C00250824C0F582E4347DF583E0F50A8C82FA
+:10087C00C002C003121369D003D00280747B05E55B
+:10088C00080424C0F582E4347DF583E0FC74022571
+:10089C000824C0F582E4347DF583E0F50A74032561
+:1008AC000824C0F582E4347DF583E0F50B7404254F
+:1008BC000824C0F582E4347DF583E0F50C7405253D
+:1008CC000824C0F582E4347DF583E0F50D8C82C0FC
+:1008DC0002C003121381D003D00280157B01C00229
+:1008EC00C00312054CD003D00280067B0180027B32
+:1008FC0000EA2509F509AA087C008B057E00ED2A83
+:10090C00FAEE3CFC0ABA00010C907FC9E0FD7E00B7
+:10091C00C3EA9DEC64808EF063F08095F04002D3C6
+:10092C0022EB042508F508C3227508007509001090
+:10093C00000280FB907F96E0FA547FF0C202200206
+:10094C000712058A920280F6907F96E0FA4480F0B6
+:10095C00E509600B907FB9E509F010010280FB906E
+:06096C007FC9E4F080C326
+:0F00D00075220075230075240075250075260024
+:10097200E582FA24C0F582E4347DF583E0F528EAC5
+:100982000424C0F582E4347DF583E0F52974022A5B
+:10099200FD24C0F582E4347DF583E0C4540FFE5398
+:1009A200060FED24C0F582E4347DF583E0FD740F7B
+:1009B2005DF52A74032A24C0F582E4347DF583E0D0
+:1009C200FF74042A24C0F582E4347DF583E0F52B1C
+:1009D200EE60078F0A8E821212A6907F97E0FE5376
+:1009E20006F87F0074044EF87900AD287B001DBD27
+:1009F200FF011B89027C00C3EA9DEC64808BF063DB
+:100A0200F08095F050387A007B00BB0800501C90B3
+:100A12007F97EEF0EAC313FA907F97E8F0907F9900
+:100A2200E0FC30E5034302800B80DFE52729240048
+:100A3200F582E4347EF583EAF009890780AC890700
+:100A42007A00AB2A752C00E52CB529005041AD295E
+:100A520078001DBDFF0118A92C7C00E9B50511EC39
+:100A6200B5000DEB600A4306021BE52BC313F52B01
+:100A7200907F97EEF0EAC313FA907F9774044EF0DA
+:100A8200907F99E0FC30E503430280052C80B8ACEE
+:100A9200297D007408C39CFCE49DFD8CF005F0EAFE
+:100AA2008002C313D5F0FBFAE5272F2400F582E478
+:100AB200347EF583EAF0EB6008852B0A8B82021202
+:100AC200A622E582FA24C0F582E4347DF583E0F5BE
+:100AD2002EEA0424C0F582E4347DF583E0F52F7418
+:100AE200022AFD24C0F582E4347DF583E0C4540F6C
+:100AF200FE53060FED24C0F582E4347DF583E0FD5C
+:100B0200740F5DF53074032A24C0F582E4347DF558
+:100B120083E0FF74042A24C0F582E4347DF583E087
+:100B2200F531EE60078F0A8E821212DB907F97E01A
+:100B3200FE5306F87F0074044EF87900AD2E7B0058
+:100B42001DBDFF011B89027C00C3EA9DEC64808B02
+:100B5200F063F08095F0504E7A007B00BB080050A5
+:100B620032907F97EEF07C00ECB5220050030C80AF
+:100B7200F7EAC313FA907F97E8F07C00ECB5220005
+:100B820050030C80F7907F99E0FC30E5034302802C
+:100B92000B80C9E52D292400F582E4347EF583EA31
+:100BA200F0098907809689077A00AB30753200E533
+:100BB20032B52F005057AD2F78001DBDFF0118A987
+:100BC200327C00E9B50511ECB5000DEB600A430675
+:100BD200021BE531C313F531907F97EEF07C00ECF8
+:100BE200B5220050030C80F7EAC313FA907F977482
+:100BF200044EF07C00ECB5220050030C80F7907F8D
+:100C020099E0FC30E503430280053280A2AC2F7DDF
+:100C1200007408C39CFCE49DFD8CF005F0EA8002A0
+:100C2200C313D5F0FBFAE52D2F2400F582E4347EC0
+:100C3200F583EAF0EB600885310A8B820212DB222F
+:100C4200E582FA24C0F582E4347DF583E0F533EAE7
+:100C52000424C0F582E4347DF583E0F53474022A7D
+:100C6200FD24C0F582E4347DF583E0C4540FFE53C5
+:100C7200060FED24C0F582E4347DF583E0FD740FA8
+:100C82005DF53574032A24C0F582E4347DF583E0F2
+:100C9200FF74042A24C0F582E4347DF583E0F5363E
+:100CA200EE600B8F0A8E82C0021212A6D002907FD3
+:100CB20097E0FE5306F97F00A9337D0019B9FF01C1
+:100CC2001D8F037800C3EB99E864808DF063F08098
+:100CD20095F05038EA2F240524C0F582E4347DF5DE
+:100CE20083E0FB7D00BD0800501FEB30E0054306AA
+:100CF2000180035306FE907F97EEF0EBC313FB9047
+:100D02007F9774044EF00D80DC0F80ACEA2F24052F
+:100D120024C0F582E4347DF583E0FBAA357D00ED45
+:100D2200B534005041EB30E0054306018003530621
+:100D3200FEAF3478001FBFFF01188D017C00E9B5BA
+:100D42000711ECB5000DEA600A4306021AE536C344
+:100D520013F536907F97EEF0EBC313FB907F9774F9
+:100D6200044EF00D80B9EA600885360A8A820212C2
+:100D7200A622E582FA24C0F582E4347DF583E0F50B
+:100D820037EA0424C0F582E4347DF583E0F5387453
+:100D9200022AFD24C0F582E4347DF583E0C4540FB9
+:100DA200FE53060FED24C0F582E4347DF583E0FDA9
+:100DB200740F5DF53974032A24C0F582E4347DF59D
+:100DC20083E0FF74042A24C0F582E4347DF583E0D5
+:100DD200F53AEE600B8F0A8E82C0021212DBD0024D
+:100DE200907F97E0FE5306F97F00A9377D0019B97D
+:100DF200FF011D8F037800C3EB99E864808DF063D7
+:100E0200F08095F0504EEA2F240524C0F582E43498
+:100E12007DF583E0FB7D00BD08005035EB30E00539
+:100E220043060180035306FE907F97EEF07800E8B8
+:100E3200B5230050030880F7EBC313FB907F977430
+:100E4200044EF07800E8B5230050030880F70D80C7
+:100E5200C60F8096EA2F240524C0F582E4347DF57E
+:100E620083E0FBAA397D00EDB538005057EB30E046
+:100E72000543060180035306FEAF3878001FBFFF0B
+:100E820001188D017C00E9B50711ECB5000DEA608F
+:100E92000A4306021AE53AC313F53A907F97EEF039
+:100EA2007C00ECB5230050030C80F7EBC313FB90DE
+:100EB2007F9774044EF07C00ECB5230050030C8045
+:100EC200F70D80A3EA6008853A0A8A820212DB22C1
+:100ED200E582F53C24C0F582E4347DF583E0F53DFE
+:100EE200E53C0424C0F582E4347DF583E0F53E74EC
+:100EF20002253CFD24C0F582E4347DF583E0C45430
+:100F02000FFE53060FED24C0F582E4347DF583E035
+:100F1200FD740F5DF53F7403253C24C0F582E43473
+:100F22007DF583E0FF7404253C24C0F582E4347D22
+:100F3200F583E0F540EE60078F0A8E821212A690CA
+:100F42007F97E0FE5306F97F007900AD3D7B001DDF
+:100F5200BDFF011B89007A00C3E89DEA64808BF023
+:100F620063F08095F0505EE53C29240524C0F582AB
+:100F7200E4347DF583E0F5417B007D00BD0800503F
+:100F820031E54130E00543060180035306FE907FC0
+:100F920097EEF0E541C313F541907F9774044EF04C
+:100FA200EBC313FB907F99E0F830E5034303800D18
+:100FB20080CAE53B292400F582E4347EF583EBF018
+:100FC20009890780868907E53C29240524C0F58222
+:100FD200E4347DF583E0F5417B00AD3F754200E5E9
+:100FE20042B53E005054E54130E00543060180031E
+:100FF2005306FEA93E7C0019B9FF011CA8427A00E3
+:10100200E8B50111EAB5040DED600A4306021DE5DB
+:1010120040C313F540907F97EEF0E541C313F541CD
+:10102200907F9774044EF0EBC313FB907F99E0FA24
+:1010320030E503430380054280A5AC3E7A00740884
+:10104200C39CFCE49AFA8CF005F0EB8002C313D542
+:10105200F0FBFBE53B2F2400F582E4347EF583EBC5
+:10106200F0ED600885400A8D820212A622E582F523
+:101072004424C0F582E4347DF583E0F545E544047B
+:1010820024C0F582E4347DF583E0F54674022544FC
+:10109200FD24C0F582E4347DF583E0C4540FFE5391
+:1010A200060FED24C0F582E4347DF583E0FD740F74
+:1010B2005DF5477403254424C0F582E4347DF5834D
+:1010C200E0FF7404254424C0F582E4347DF583E016
+:1010D200F548EE60078F0A8E821212DB907F97E04E
+:1010E200FE5306F97F007900AD457B001DBDFF016F
+:1010F2001B89007A00C3E89DEA64808BF063F0806C
+:1011020095F05075E54429240524C0F582E4347D28
+:10111200F583E0F5497B007D00BD08005047E549B5
+:1011220030E00543060180035306FE907F97EEF000
+:101132007800E8B5240050030880F7E549C313F5A9
+:1011420049907F9774044EF07800E8B5240050036C
+:101152000880F7EBC313FB907F99E0F830E5034377
+:1011620003800D80B4E543292400F582E4347EF542
+:1011720083EBF00989070210EA8907E5442924056F
+:1011820024C0F582E4347DF583E0F5497B00AD4768
+:10119200754A00E54AB54600506AE54930E0054324
+:1011A200060180035306FEA9467C0019B9FF011C03
+:1011B200A84A7A00E8B50111EAB5040DED600A43C8
+:1011C20006021DE548C313F548907F97EEF07A00BA
+:1011D200EAB5240050030A80F7E549C313F54990A4
+:1011E2007F9774044EF07A00EAB5240050030A8017
+:1011F200F7EBC313FB907F99E0FA30E503430380DA
+:10120200054A808FAC467A007408C39CFCE49AFAC3
+:101212008CF005F0EB8002C313D5F0FBFBE5432F06
+:101222002400F582E4347EF583EBF0ED6008854816
+:101232000A8D820212DB22AA82AB83907F97E0FCA6
+:101242005304FB74044CFD7E007F00C3EE9AEF9BB7
+:10125200500E907F97ECF0EDF00EBE00EE0F80EB9B
+:1012620022AA82AB83907F97E0FC5304FB74044C68
+:10127200FD7E007F00C3EE9AEF9B5027907F97EC94
+:10128200F07800E8B5250050030880F7907F97EDCD
+:10129200F07800E8B5250050030880F70EBE00D5AF
+:1012A2000F80D222AA82907F97E0FB5303FB7C003F
+:1012B200ECB502005022E50A30E005430302800348
+:1012C2005303FD907F97EBF0E50AC313F50A907F75
+:1012D2009774044BF00C80D822AA82907F97E0FB8F
+:1012E2005303FB7C00ECB502005038E50A30E00500
+:1012F20043030280035303FD907F97EBF07D00EDE3
+:10130200B5260050030D80F7E50AC313F50A907F56
+:101312009774044BF07D00EDB5260050030D80F765
+:101322000C80C2227A00907F99E0FB30E5027A01BC
+:10133200907F99E0FB30E603430202907F9AE0FB44
+:1013420030E703430204907F9BE0FB30E503430256
+:1013520008907F9AE0FB53037F8A04E4FAFDEB4A8C
+:10136200F582ED4CF58322E582547FF4FA907F9763
+:10137200E05AF0747F550AFA907F97E04AF022858E
+:101382008222850A23850B24850C25850D262200C1
+:10139200227A567B021ABAFF011BEA4B70F72275BA
+:1013A2000A05750B001213FEAA82AB837C007D0036
+:1013B200C3EC9AED9B501AC002C003C004C00512D0
+:1013C2001391D005D004D003D0020CBC00E20D80F2
+:1013D200DF22AA82AB837C007D00C3EC9AED9B5096
+:1013E2001AC002C003C004C005121393D005D00472
+:0C13F200D003D0020CBC00E20D80DF2212
 :03004300021B009D
-:101B000002011F0002016E0002016F00020170005D
-:101B100002017100020172000201730002017400EF
-:101B200002017500020176000201770002018F00B8
-:101B30000201A7000201A8000201A9000201AA00F7
-:101B40000201AB000201AC000201AD000201AE00D7
-:081B50000201AF000201B00028
-:100D67007A10E4FBFCE58225E0F582E58333F58321
-:100D7700EB33FBEC33FCEB9522F5F0EC95234006C7
-:090D8700FCABF0438201DADD222D
+:101B00000201250002017400020175000201760045
+:101B100002017700020178000201790002017A00D7
+:101B200002017B0002017C0002017D0002019500A0
+:101B30000201AD000201AE000201AF000201B000DF
+:101B40000201B1000201B2000201B3000201B400BF
+:081B50000201B5000201B6001C
+:1013FE007A10E4FBFCE58225E0F582E58333F58384
+:10140E00EB33FBEC33FCEB950AF5F0EC950B400659
+:09141E00FCABF0438201DADD228F
 :0600A200E478FFF6D8FD32
-:100080007900E94400601B7A00900E3E780075927A
+:100080007900E94400601B7A009014D578007592DD
 :1000900020E493F2A308B800020592D9F4DAF275CD
 :0200A00092FFCD
 :1000A8007800E84400600A7900759220E4F309D8E2
 :1000B800FC7800E84400600C7900902000E4F0A38C
 :0400C800D8FCD9FA8D
-:0D007300758123120DACE582600302006E62
-:100D900020F71430F6148883A88220F507E6A8838C
-:100DA00075830022E280F7E49322E022758200221C
+:0D00730075814A121443E582600302006E9D
+:1014270020F71430F6148883A88220F507E6A883EE
+:1014370075830022E280F7E49322E022758200227E
 :00000001FF

commit 1d135dddf27f6f8dd2ceee2e3b07a0b91e098459
Author: Martin Schmoelzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Thu Aug 4 22:30:25 2011 +0200

    ULINK driver: Add '-lm' linker flag when building this driver (required for correct calculation of JTAG TCK speed setting)
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/Makefile.am b/src/Makefile.am
index 1be24ea..8375683 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -30,6 +30,10 @@ else
 openocd_LDADD += -ljim
 endif
 
+if ULINK
+openocd_LDADD += -lm
+endif
+
 libopenocd_la_SOURCES = \
 	hello.c \
 	openocd.c \

commit c331c9382f3e2442b4ddc6a5c65c5278b19938eb
Author: Martin Schmoelzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Thu Aug 4 19:03:59 2011 +0200

    ULINK driver: Implement variable TCK frequency in OpenOCD driver
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index a90c50d..2657eea 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -22,6 +22,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &lt;math.h&gt;
 #include &lt;jtag/interface.h&gt;
 #include &lt;jtag/commands.h&gt;
 #include &lt;target/image.h&gt;
@@ -94,6 +95,15 @@ enum ulink_payload_direction
   PAYLOAD_DIRECTION_IN
 };
 
+enum ulink_delay_type
+{
+  DELAY_CLOCK_TCK,
+  DELAY_CLOCK_TMS,
+  DELAY_SCAN_IN,
+  DELAY_SCAN_OUT,
+  DELAY_SCAN_IO
+};
+
 /**
  * OpenULINK command (OpenULINK command queue element).
  *
@@ -146,6 +156,12 @@ struct ulink
   struct usb_dev_handle *usb_handle;
   enum ulink_type type;
 
+  int delay_scan_in;         ///&lt; Delay value for SCAN_IN commands
+  int delay_scan_out;        ///&lt; Delay value for SCAN_OUT commands
+  int delay_scan_io;         ///&lt; Delay value for SCAN_IO commands
+  int delay_clock_tck;       ///&lt; Delay value for CLOCK_TMS commands
+  int delay_clock_tms;       ///&lt; Delay value for CLOCK_TCK commands
+
   int commands_in_queue;     ///&lt; Number of commands in queue
   ulink_cmd_t *queue_start;  ///&lt; Pointer to first command in queue
   ulink_cmd_t *queue_end;    ///&lt; Pointer to last command in queue
@@ -196,11 +212,15 @@ int ulink_append_get_signals_cmd(struct ulink *device);
 int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
     uint8_t high);
 int ulink_append_sleep_cmd(struct ulink *device, uint32_t us);
-int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
-    uint8_t delay_tck, uint8_t delay_tms);
+int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
+    int delay_scan_out, int delay_scan_io, int delay_tck, int delay_tms);
 int ulink_append_led_cmd(struct ulink *device, uint8_t led_state);
 int ulink_append_test_cmd(struct ulink *device);
 
+/* OpenULINK TCK frequency helper functions */
+int ulink_calculate_delay(enum ulink_delay_type type, long f, int *delay);
+int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f);
+
 /* Interface between OpenULINK and OpenOCD */
 static void ulink_set_end_state(tap_state_t endstate);
 int ulink_queue_statemove(struct ulink *device);
@@ -781,6 +801,9 @@ const char * ulink_cmd_id_string(uint8_t id)
   case CMD_CLOCK_TCK:
     return &quot;CMD_CLOCK_TCK&quot;;
     break;
+  case CMD_SLOW_CLOCK_TCK:
+    return &quot;CMD_SLOW_CLOCK_TCK&quot;;
+    break;
   case CMD_SLEEP_US:
     return &quot;CMD_SLEEP_US&quot;;
     break;
@@ -903,18 +926,32 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
   }
 
   /* Allocate out_payload depending on scan type */
-  // TODO: set command ID depending on interface speed settings (slow scan)
   switch (scan_type) {
   case SCAN_IN:
-    cmd-&gt;id = CMD_SCAN_IN;
+    if (device-&gt;delay_scan_in &lt; 0) {
+      cmd-&gt;id = CMD_SCAN_IN;
+    }
+    else {
+      cmd-&gt;id = CMD_SLOW_SCAN_IN;
+    }
     ret = ulink_allocate_payload(cmd, 5, PAYLOAD_DIRECTION_OUT);
     break;
   case SCAN_OUT:
-    cmd-&gt;id = CMD_SCAN_OUT;
+    if (device-&gt;delay_scan_out &lt; 0) {
+      cmd-&gt;id = CMD_SCAN_OUT;
+    }
+    else {
+      cmd-&gt;id = CMD_SLOW_SCAN_OUT;
+    }
     ret = ulink_allocate_payload(cmd, scan_size_bytes + 5, PAYLOAD_DIRECTION_OUT);
     break;
   case SCAN_IO:
-    cmd-&gt;id = CMD_SCAN_IO;
+    if (device-&gt;delay_scan_io &lt; 0) {
+      cmd-&gt;id = CMD_SCAN_IO;
+    }
+    else {
+      cmd-&gt;id = CMD_SLOW_SCAN_IO;
+    }
     ret = ulink_allocate_payload(cmd, scan_size_bytes + 5, PAYLOAD_DIRECTION_OUT);
     break;
   default:
@@ -978,7 +1015,12 @@ int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
     return ERROR_FAIL;
   }
 
-  cmd-&gt;id = CMD_CLOCK_TMS;
+  if (device-&gt;delay_clock_tms &lt; 0) {
+    cmd-&gt;id = CMD_CLOCK_TMS;
+  }
+  else {
+    cmd-&gt;id = CMD_SLOW_CLOCK_TMS;
+  }
 
   /* CMD_CLOCK_TMS has two OUT payload bytes and zero IN payload bytes */
   ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
@@ -1011,7 +1053,12 @@ int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count)
     return ERROR_FAIL;
   }
 
-  cmd-&gt;id = CMD_CLOCK_TCK;
+  if (device-&gt;delay_clock_tck &lt; 0) {
+    cmd-&gt;id = CMD_CLOCK_TCK;
+  }
+  else {
+    cmd-&gt;id = CMD_SLOW_CLOCK_TCK;
+  }
 
   /* CMD_CLOCK_TCK has two OUT payload bytes and zero IN payload bytes */
   ret = ulink_allocate_payload(cmd, 2, PAYLOAD_DIRECTION_OUT);
@@ -1132,14 +1179,16 @@ int ulink_append_sleep_cmd(struct ulink *device, uint32_t us)
  * Set TCK delay counters
  *
  * @param device pointer to struct ulink identifying ULINK driver instance.
- * @param delay_scan delay count top value in jtag_slow_scan() functions
- * @param delay_tck delay count top value in jtag_clock_tck() function
- * @param delay_tms delay count top value in jtag_slow_clock_tms() function
+ * @param delay_scan_in delay count top value in jtag_slow_scan_in() function.
+ * @param delay_scan_out delay count top value in jtag_slow_scan_out() function.
+ * @param delay_scan_io delay count top value in jtag_slow_scan_io() function.
+ * @param delay_tck delay count top value in jtag_clock_tck() function.
+ * @param delay_tms delay count top value in jtag_slow_clock_tms() function.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
-    uint8_t delay_tck, uint8_t delay_tms)
+int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
+    int delay_scan_out, int delay_scan_io, int delay_tck, int delay_tms)
 {
   ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
   int ret;
@@ -1150,16 +1199,47 @@ int ulink_append_configure_tck_cmd(struct ulink *device, uint8_t delay_scan,
 
   cmd-&gt;id = CMD_CONFIGURE_TCK_FREQ;
 
-  /* CMD_CONFIGURE_TCK_FREQ has three OUT payload bytes and zero
+  /* CMD_CONFIGURE_TCK_FREQ has five OUT payload bytes and zero
    * IN payload bytes */
-  ret = ulink_allocate_payload(cmd, 3, PAYLOAD_DIRECTION_OUT);
+  ret = ulink_allocate_payload(cmd, 5, PAYLOAD_DIRECTION_OUT);
   if (ret != ERROR_OK) {
     return ret;
   }
 
-  cmd-&gt;payload_out[0] = delay_scan;
-  cmd-&gt;payload_out[1] = delay_tck;
-  cmd-&gt;payload_out[2] = delay_tms;
+  if (delay_scan_in &lt; 0) {
+    cmd-&gt;payload_out[0] = 0;
+  }
+  else {
+    cmd-&gt;payload_out[0] = (uint8_t)delay_scan_in;
+  }
+
+  if (delay_scan_out &lt; 0) {
+    cmd-&gt;payload_out[1] = 0;
+  }
+  else {
+    cmd-&gt;payload_out[1] = (uint8_t)delay_scan_out;
+  }
+
+  if (delay_scan_io &lt; 0) {
+    cmd-&gt;payload_out[2] = 0;
+  }
+  else {
+    cmd-&gt;payload_out[2] = (uint8_t)delay_scan_io;
+  }
+
+  if (delay_tck &lt; 0) {
+    cmd-&gt;payload_out[3] = 0;
+  }
+  else {
+    cmd-&gt;payload_out[3] = (uint8_t)delay_tck;
+  }
+
+  if (delay_tms &lt; 0) {
+    cmd-&gt;payload_out[4] = 0;
+  }
+  else {
+    cmd-&gt;payload_out[4] = (uint8_t)delay_tms;
+  }
 
   return ulink_append_queue(device, cmd);
 }
@@ -1231,6 +1311,165 @@ int ulink_append_test_cmd(struct ulink *device)
   return ulink_append_queue(device, cmd);
 }
 
+/****************** OpenULINK TCK frequency helper functions ******************/
+
+/**
+ * Calculate delay values for a given TCK frequency.
+ *
+ * The OpenULINK firmware uses five different speed values for different
+ * commands. These speed values are calculated in these functions.
+ *
+ * The five different commands which support variable TCK frequency are
+ * implemented twice in the firmware:
+ *   1. Maximum possible frequency without any artificial delay
+ *   2. Variable frequency with artificial linear delay loop
+ *
+ * To set the ULINK to maximum frequency, it is only neccessary to use the
+ * corresponding command IDs. To set the ULINK to a lower frequency, the
+ * delay loop top values have to be calculated first. Then, a
+ * CMD_CONFIGURE_TCK_FREQ command needs to be sent to the ULINK device.
+ *
+ * The delay values are described by linear equations:
+ *    t = k * x + d
+ *    (t = period, k = constant, x = delay value, d = constant)
+ *
+ * Thus, the delay can be calculated as in the following equation:
+ *    x = (t - d) / k
+ *
+ * The constants in these equations have been determined and validated by
+ * measuring the frequency resulting from different delay values.
+ *
+ * @param type for which command to calculate the delay value.
+ * @param f TCK frequency for which to calculate the delay value in Hz.
+ * @param delay where to store resulting delay value.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_calculate_delay(enum ulink_delay_type type, long f, int *delay)
+{
+  float t, x, x_ceil;
+
+  /* Calculate period of requested TCK frequency */
+  t = 1.0 / (float)(f);
+
+  switch (type) {
+  case DELAY_CLOCK_TCK:
+    x = (t - (float)(6E-6)) / (float)(4E-6);
+    break;
+  case DELAY_CLOCK_TMS:
+    x = (t - (float)(8.5E-6)) / (float)(4E-6);
+    break;
+  case DELAY_SCAN_IN:
+    x = (t - (float)(8.8308E-6)) / (float)(4E-6);
+    break;
+  case DELAY_SCAN_OUT:
+    x = (t - (float)(1.0527E-5)) / (float)(4E-6);
+    break;
+  case DELAY_SCAN_IO:
+    x = (t - (float)(1.3132E-5)) / (float)(4E-6);
+    break;
+  default:
+    return ERROR_FAIL;
+    break;
+  }
+
+  /* Check if the delay value is negative. This happens when a frequency is
+   * requested that is too high for the delay loop implementation. In this
+   * case, set delay value to zero. */
+  if (x &lt; 0) {
+    x = 0;
+  }
+
+  /* We need to convert the exact delay value to an integer. Therefore, we
+   * round the exact value UP to ensure that the resulting frequency is NOT
+   * higher than the requested frequency. */
+  x_ceil = ceilf(x);
+
+  /* Check if the value is within limits */
+  if (x_ceil &gt; 255) {
+    return ERROR_FAIL;
+  }
+
+  *delay = (int)x_ceil;
+
+  return ERROR_OK;
+}
+
+/**
+ * Calculate frequency for a given delay value.
+ *
+ * Similar to the #ulink_calculate_delay function, this function calculates the
+ * TCK frequency for a given delay value by using linear equations of the form:
+ *    t = k * x + d
+ *    (t = period, k = constant, x = delay value, d = constant)
+ *
+ * @param type for which command to calculate the delay value.
+ * @param delay delay value for which to calculate the resulting TCK frequency.
+ * @param f where to store the resulting TCK frequency.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_calculate_frequency(enum ulink_delay_type type, int delay, long *f)
+{
+  float t, f_float, f_rounded;
+
+  if (delay &gt; 255) {
+    return ERROR_FAIL;
+  }
+
+  switch (type) {
+  case DELAY_CLOCK_TCK:
+    if (delay &lt; 0) {
+      t = (float)(2.666E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(6E-6);
+    }
+    break;
+  case DELAY_CLOCK_TMS:
+    if (delay &lt; 0) {
+      t = (float)(5.666E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(8.5E-6);
+    }
+    break;
+  case DELAY_SCAN_IN:
+    if (delay &lt; 0) {
+      t = (float)(5.5E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(8.8308E-6);
+    }
+    break;
+  case DELAY_SCAN_OUT:
+    if (delay &lt; 0) {
+      t = (float)(7.0E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(1.0527E-5);
+    }
+    break;
+  case DELAY_SCAN_IO:
+    if (delay &lt; 0) {
+      t = (float)(9.926E-6);
+    }
+    else {
+      t = (float)(4E-6) * (float)(delay) + (float)(1.3132E-5);
+    }
+    break;
+  default:
+    return ERROR_FAIL;
+    break;
+  }
+
+  f_float = 1.0 / t;
+  f_rounded = roundf(f_float);
+  *f = (long)f_rounded;
+
+  return ERROR_OK;
+}
+
 /******************* Interface between OpenULINK and OpenOCD ******************/
 
 /**
@@ -1809,26 +2048,108 @@ static int ulink_execute_queue(void)
 /**
  * Set the TCK frequency of the ULINK adapter.
  *
- * @param khz ???
- * @param jtag_speed ???
+ * @param khz desired JTAG TCK frequency.
+ * @param jtag_speed where to store corresponding adapter-specific speed value.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
 static int ulink_khz(int khz, int *jtag_speed)
 {
+  int ret;
+
   if (khz == 0) {
     LOG_ERROR(&quot;RCLK not supported&quot;);
     return ERROR_FAIL;
   }
 
-  LOG_INFO(&quot;ulink_khz: %i kHz&quot;, khz);
+  /* CLOCK_TCK commands are decoupled from others. Therefore, the frequency
+   * setting can be done independently from all other commands. */
+  if (khz &gt;= 375) {
+    ulink_handle-&gt;delay_clock_tck = -1;
+  }
+  else {
+    ret = ulink_calculate_delay(DELAY_CLOCK_TCK, khz * 1000,
+        &amp;ulink_handle-&gt;delay_clock_tck);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
 
-  /* ULINK maximum TCK frequency is ~ 150 kHz */
-  if (khz &gt; 150) {
-    return ERROR_FAIL;
+  /* SCAN_{IN,OUT,IO} commands invoke CLOCK_TMS commands. Therefore, if the
+   * requested frequency goes below the maximum frequency for SLOW_CLOCK_TMS
+   * commands, all SCAN commands MUST also use the variable frequency
+   * implementation! */
+  if (khz &gt;= 176) {
+    ulink_handle-&gt;delay_clock_tms = -1;
+    ulink_handle-&gt;delay_scan_in = -1;
+    ulink_handle-&gt;delay_scan_out = -1;
+    ulink_handle-&gt;delay_scan_io = -1;
   }
+  else {
+    ret = ulink_calculate_delay(DELAY_CLOCK_TMS, khz * 1000,
+        &amp;ulink_handle-&gt;delay_clock_tms);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ret = ulink_calculate_delay(DELAY_SCAN_IN, khz * 1000,
+        &amp;ulink_handle-&gt;delay_scan_in);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
+    ret = ulink_calculate_delay(DELAY_SCAN_OUT, khz * 1000,
+        &amp;ulink_handle-&gt;delay_scan_out);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
 
-  *jtag_speed = 0;
+    ret = ulink_calculate_delay(DELAY_SCAN_IO, khz * 1000,
+        &amp;ulink_handle-&gt;delay_scan_io);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
+
+#ifdef _DEBUG_JTAG_IO_
+  long f_tck, f_tms, f_scan_in, f_scan_out, f_scan_io;
+
+  ulink_calculate_frequency(DELAY_CLOCK_TCK, ulink_handle-&gt;delay_clock_tck,
+      &amp;f_tck);
+  ulink_calculate_frequency(DELAY_CLOCK_TMS, ulink_handle-&gt;delay_clock_tms,
+      &amp;f_tms);
+  ulink_calculate_frequency(DELAY_SCAN_IN, ulink_handle-&gt;delay_scan_in,
+      &amp;f_scan_in);
+  ulink_calculate_frequency(DELAY_SCAN_OUT, ulink_handle-&gt;delay_scan_out,
+      &amp;f_scan_out);
+  ulink_calculate_frequency(DELAY_SCAN_IO, ulink_handle-&gt;delay_scan_io,
+      &amp;f_scan_io);
+
+  DEBUG_JTAG_IO(&quot;ULINK TCK setup: delay_tck      = %i (%li Hz),&quot;,
+      ulink_handle-&gt;delay_clock_tck, f_tck);
+  DEBUG_JTAG_IO(&quot;                 delay_tms      = %i (%li Hz),&quot;,
+      ulink_handle-&gt;delay_clock_tms, f_tms);
+  DEBUG_JTAG_IO(&quot;                 delay_scan_in  = %i (%li Hz),&quot;,
+      ulink_handle-&gt;delay_scan_in, f_scan_in);
+  DEBUG_JTAG_IO(&quot;                 delay_scan_out = %i (%li Hz),&quot;,
+      ulink_handle-&gt;delay_scan_out, f_scan_out);
+  DEBUG_JTAG_IO(&quot;                 delay_scan_io  = %i (%li Hz),&quot;,
+      ulink_handle-&gt;delay_scan_io, f_scan_io);
+#endif
+
+  /* Configure the ULINK device with the new delay values */
+  ret = ulink_append_configure_tck_cmd(ulink_handle,
+      ulink_handle-&gt;delay_scan_in,
+      ulink_handle-&gt;delay_scan_out,
+      ulink_handle-&gt;delay_scan_io,
+      ulink_handle-&gt;delay_clock_tck,
+      ulink_handle-&gt;delay_clock_tms);
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  *jtag_speed = khz;
 
   return ERROR_OK;
 }
@@ -1836,30 +2157,38 @@ static int ulink_khz(int khz, int *jtag_speed)
 /**
  * Set the TCK frequency of the ULINK adapter.
  *
- * @param speed ???
+ * Because of the way the TCK frequency is set up in the OpenULINK firmware,
+ * there are five different speed settings. To simplify things, the
+ * adapter-specific speed setting value is identical to the TCK frequency in
+ * khz.
+ *
+ * @param speed desired adapter-specific speed value.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
 static int ulink_speed(int speed)
 {
-  return ERROR_OK;
+  int dummy;
+
+  return ulink_khz(speed, &amp;dummy);
 }
 
 /**
+ * Convert adapter-specific speed value to corresponding TCK frequency in kHz.
+ *
+ * Because of the way the TCK frequency is set up in the OpenULINK firmware,
+ * there are five different speed settings. To simplify things, the
+ * adapter-specific speed setting value is identical to the TCK frequency in
+ * khz.
  *
+ * @param speed adapter-specific speed value.
+ * @param khz where to store corresponding TCK frequency in kHz.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
  */
 static int ulink_speed_div(int speed, int *khz)
 {
-  LOG_INFO(&quot;ulink_speed_div: %i&quot;, speed);
-
-  switch (speed) {
-  case 0:
-    *khz = 150;
-    break;
-  case 1:
-    *khz = 100;
-    break;
-  }
+  *khz = speed;
 
   return ERROR_OK;
 }

commit 6446dbaacbf7c0607ea571ed7f5a4f32745544eb
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Mon Jul 4 19:03:29 2011 +0200

    ULINK driver: Implement variable TCK frequency in OpenULINK firmware
    
    Also, speed up jtag_clock_tck() significantly (150 kHz -&gt; 375 kHz)
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/OpenULINK/include/jtag.h b/src/jtag/drivers/OpenULINK/include/jtag.h
index 93ecfb0..cef5f42 100644
--- a/src/jtag/drivers/OpenULINK/include/jtag.h
+++ b/src/jtag/drivers/OpenULINK/include/jtag.h
@@ -26,21 +26,23 @@
 #define NOP {__asm nop __endasm;}
 
 void jtag_scan_in(u8 out_offset, u8 in_offset);
+void jtag_slow_scan_in(u8 out_offset, u8 in_offset);
+
 void jtag_scan_out(u8 out_offset);
-void jtag_scan_io(u8 out_offset, u8 in_offset);
+void jtag_slow_scan_out(u8 out_offset);
 
-void jtag_slow_scan_in(u8 scan_size_bytes, u8 tdo_index, u8 scan_options);
-void jtag_slow_scan_out(u8 scan_size_bytes, u8 tdi_index, u8 scan_options);
-void jtag_slow_scan_io(u8 scan_size_bytes, u8 tdi_index, u8 tdo_index,
-    u8 scan_options);
+void jtag_scan_io(u8 out_offset, u8 in_offset);
+void jtag_slow_scan_io(u8 out_offset, u8 in_offset);
 
 void jtag_clock_tck(u16 count);
+void jtag_slow_clock_tck(u16 count);
 void jtag_clock_tms(u8 count, u8 sequence);
 void jtag_slow_clock_tms(u8 count, u8 sequence);
 
 u16  jtag_get_signals(void);
 void jtag_set_signals(u8 low, u8 high);
 
-void jtag_configure_tck_delay(u8 scan, u8 tck, u8 tms);
+void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
+    u8 tms);
 
 #endif
diff --git a/src/jtag/drivers/OpenULINK/include/msgtypes.h b/src/jtag/drivers/OpenULINK/include/msgtypes.h
index e3afb67..cb35612 100644
--- a/src/jtag/drivers/OpenULINK/include/msgtypes.h
+++ b/src/jtag/drivers/OpenULINK/include/msgtypes.h
@@ -75,7 +75,7 @@
  * offset 1: tms_count                                                      *
  * offset 2: tms_sequence                                                   *
  ****************************************************************************
- * CMD_CLOCK_TCK:                                                           *
+ * CMD_CLOCK_TCK, CMD_SLOW_CLOCK_TCK:                                       *
  *                                                                          *
  * OUT:                                                                     *
  * offset 1: low byte of tck_count                                          *
@@ -108,9 +108,11 @@
  * CMD_CONFIGURE_TCK_FREQ:                                                  *
  *                                                                          *
  * OUT:                                                                     *
- * offset 1: delay value for scan functions                                 *
- * offset 2: delay value for clock_tck function                             *
- * offset 3: delay value for clock_tms function                             *
+ * offset 1: delay value for scan_in function                               *
+ * offset 2: delay value for scan_out function                              *
+ * offset 3: delay value for scan_io function                               *
+ * offset 4: delay value for clock_tck function                             *
+ * offset 5: delay value for clock_tms function                             *
  ****************************************************************************
  * CMD_SET_LEDS:                                                            *
  *                                                                          *
@@ -155,13 +157,14 @@
 #define CMD_CLOCK_TMS           0x20
 #define CMD_SLOW_CLOCK_TMS      0x21
 #define CMD_CLOCK_TCK           0x22
-#define CMD_SLEEP_US            0x23
-#define CMD_SLEEP_MS            0x24
-#define CMD_GET_SIGNALS         0x25
-#define CMD_SET_SIGNALS         0x26
-#define CMD_CONFIGURE_TCK_FREQ  0x27
-#define CMD_SET_LEDS            0x28
-#define CMD_TEST                0x29
+#define CMD_SLOW_CLOCK_TCK      0x23
+#define CMD_SLEEP_US            0x24
+#define CMD_SLEEP_MS            0x25
+#define CMD_GET_SIGNALS         0x26
+#define CMD_SET_SIGNALS         0x27
+#define CMD_CONFIGURE_TCK_FREQ  0x28
+#define CMD_SET_LEDS            0x29
+#define CMD_TEST                0x2A
 
 /* JTAG signal definition for jtag_get_signals() -- Input signals! */
 #define SIGNAL_TDO      (1&lt;&lt;0)
diff --git a/src/jtag/drivers/OpenULINK/src/jtag.c b/src/jtag/drivers/OpenULINK/src/jtag.c
index cf126ed..812d4f7 100644
--- a/src/jtag/drivers/OpenULINK/src/jtag.c
+++ b/src/jtag/drivers/OpenULINK/src/jtag.c
@@ -26,10 +26,16 @@
 
 #include &lt;stdbool.h&gt;
 
-/** Delay value for SCAN operations with less than maximum TCK frequency */
-u8 delay_scan = 0;
+/** Delay value for SCAN_IN operations with less than maximum TCK frequency */
+u8 delay_scan_in = 0;
 
-/** Delay value for CLOCK_TCK operations */
+/** Delay value for SCAN_OUT operations with less than maximum TCK frequency */
+u8 delay_scan_out = 0;
+
+/** Delay value for SCAN_IO operations with less than maximum TCK frequency */
+u8 delay_scan_io = 0;
+
+/** Delay value for CLOCK_TCK operations with less than maximum frequency */
 u8 delay_tck = 0;
 
 /** Delay value for CLOCK_TMS operations with less than maximum frequency */
@@ -41,6 +47,8 @@ u8 delay_tms = 0;
  * Dummy data is shifted into the JTAG chain via TDI, TDO data is sampled and
  * stored in the EP2 IN buffer.
  *
+ * Maximum achievable TCK frequency is 182 kHz for ULINK clocked at 24 MHz.
+ *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
 void jtag_scan_in(u8 out_offset, u8 in_offset)
@@ -72,8 +80,8 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
 
     for (j = 0; j &lt; 8; j++) {
       OUTB = outb_buffer; /* TCK changes here */
-      OUTB = (outb_buffer | PIN_TCK);
       tdo_data = tdo_data &gt;&gt; 1;
+      OUTB = (outb_buffer | PIN_TCK);
 
       if (GET_TDO()) {
         tdo_data |= 0x80;
@@ -96,8 +104,8 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
     }
 
     OUTB = outb_buffer; /* TCK change here */
-    OUTB = (outb_buffer | PIN_TCK);
     tdo_data = tdo_data &gt;&gt; 1;
+    OUTB = (outb_buffer | PIN_TCK);
 
     if (GET_TDO()) {
       tdo_data |= 0x80;
@@ -115,12 +123,101 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
 }
 
 /**
+ * Perform JTAG SCAN-IN operation at variable TCK frequency.
+ *
+ * Dummy data is shifted into the JTAG chain via TDI, TDO data is sampled and
+ * stored in the EP2 IN buffer.
+ *
+ * Maximum achievable TCK frequency is 113 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_slow_scan_in(u8 out_offset, u8 in_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdo_data, i, j, k;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] &gt;&gt; 4) &amp; 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] &amp; 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+
+  if (tms_count_start &gt; 0) {
+    jtag_slow_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB &amp; ~(PIN_TDI | PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i &lt; scan_size_bytes - 1; i++) {
+    tdo_data = 0;
+
+    for (j = 0; j &lt; 8; j++) {
+      OUTB = outb_buffer; /* TCK changes here */
+      for (k = 0; k &lt; delay_scan_in; k++);
+      tdo_data = tdo_data &gt;&gt; 1;
+
+      OUTB = (outb_buffer | PIN_TCK);
+      for (k = 0; k &lt; delay_scan_in; k++);
+
+      if (GET_TDO()) {
+        tdo_data |= 0x80;
+      }
+    }
+
+    /* Copy TDO data to IN2BUF */
+    IN2BUF[i + in_offset] = tdo_data;
+  }
+
+  tdo_data = 0;
+
+  /* Shift the last byte */
+  for (j = 0; j &lt; bits_last_byte; j++) {
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) &amp;&amp; (tms_count_end &gt; 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end &gt;&gt; 1;
+    }
+
+    OUTB = outb_buffer; /* TCK change here */
+    for (k = 0; k &lt; delay_scan_in; k++);
+    tdo_data = tdo_data &gt;&gt; 1;
+
+    OUTB = (outb_buffer | PIN_TCK);
+    for (k = 0; k &lt; delay_scan_in; k++);
+
+    if (GET_TDO()) {
+      tdo_data |= 0x80;
+    }
+  }
+  tdo_data = tdo_data &gt;&gt; (8 - bits_last_byte);
+
+  /* Copy TDO data to IN2BUF */
+  IN2BUF[i + in_offset] = tdo_data;
+
+  /* Move to correct end state */
+  if (tms_count_end &gt; 0) {
+    jtag_slow_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
  * Perform JTAG SCAN-OUT operation at maximum TCK frequency.
  *
  * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
  * data is not sampled.
  * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
  *
+ * Maximum achievable TCK frequency is 142 kHz for ULINK clocked at 24 MHz.
+ *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
 void jtag_scan_out(u8 out_offset)
@@ -194,12 +291,101 @@ void jtag_scan_out(u8 out_offset)
 }
 
 /**
+ * Perform JTAG SCAN-OUT operation at maximum TCK frequency.
+ *
+ * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
+ * data is not sampled.
+ * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
+ *
+ * Maximum achievable TCK frequency is 97 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_slow_scan_out(u8 out_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdi_data, i, j, k;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] &gt;&gt; 4) &amp; 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] &amp; 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+
+  if (tms_count_start &gt; 0) {
+    jtag_slow_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB &amp; ~(PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i &lt; scan_size_bytes - 1; i++) {
+    tdi_data = OUT2BUF[i + out_offset + 5];
+
+    for (j = 0; j &lt; 8; j++) {
+      if (tdi_data &amp; 0x01) {
+        outb_buffer |= PIN_TDI;
+      }
+      else {
+        outb_buffer &amp;= ~PIN_TDI;
+      }
+
+      OUTB = outb_buffer; /* TDI and TCK change here */
+      for (k = 0; k &lt; delay_scan_out; k++);
+      tdi_data = tdi_data &gt;&gt; 1;
+
+      OUTB = (outb_buffer | PIN_TCK);
+      for (k = 0; k &lt; delay_scan_out; k++);
+    }
+  }
+
+  tdi_data = OUT2BUF[i + out_offset + 5];
+
+  /* Shift the last byte */
+  for (j = 0; j &lt; bits_last_byte; j++) {
+    if (tdi_data &amp; 0x01) {
+      outb_buffer |= PIN_TDI;
+    }
+    else {
+      outb_buffer &amp;= ~PIN_TDI;
+    }
+
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) &amp;&amp; (tms_count_end &gt; 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end &gt;&gt; 1;
+    }
+
+    OUTB = outb_buffer; /* TDI and TCK change here */
+    for (k = 0; k &lt; delay_scan_out; k++);
+    tdi_data = tdi_data &gt;&gt; 1;
+
+    OUTB = (outb_buffer | PIN_TCK);
+    for (k = 0; k &lt; delay_scan_out; k++);
+  }
+
+  /* Move to correct end state */
+  if (tms_count_end &gt; 0) {
+    jtag_slow_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
  * Perform bidirectional JTAG SCAN operation at maximum TCK frequency.
  *
  * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
  * data is sampled and stored in the EP2 IN buffer.
  * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
  *
+ * Maximum achievable TCK frequency is 100 kHz for ULINK clocked at 24 MHz.
+ *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
 void jtag_scan_io(u8 out_offset, u8 in_offset)
@@ -292,26 +478,154 @@ void jtag_scan_io(u8 out_offset, u8 in_offset)
 }
 
 /**
+ * Perform bidirectional JTAG SCAN operation at maximum TCK frequency.
+ *
+ * Data stored in EP2 OUT buffer is shifted into the JTAG chain via TDI, TDO
+ * data is sampled and stored in the EP2 IN buffer.
+ * The TAP-FSM state is alyways left in the PAUSE-DR/PAUSE-IR state.
+ *
+ * Maximum achievable TCK frequency is 78 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param out_offset offset in OUT2BUF where payload data starts
+ */
+void jtag_slow_scan_io(u8 out_offset, u8 in_offset)
+{
+  u8 scan_size_bytes, bits_last_byte;
+  u8 tms_count_start, tms_count_end;
+  u8 tms_sequence_start, tms_sequence_end;
+  u8 tdi_data, tdo_data, i, j, k;
+
+  u8 outb_buffer;
+
+  /* Get parameters from OUT2BUF */
+  scan_size_bytes = OUT2BUF[out_offset];
+  bits_last_byte = OUT2BUF[out_offset + 1];
+  tms_count_start = (OUT2BUF[out_offset + 2] &gt;&gt; 4) &amp; 0x0F;
+  tms_count_end = OUT2BUF[out_offset + 2] &amp; 0x0F;
+  tms_sequence_start = OUT2BUF[out_offset + 3];
+  tms_sequence_end = OUT2BUF[out_offset + 4];
+
+  if (tms_count_start &gt; 0) {
+    jtag_slow_clock_tms(tms_count_start, tms_sequence_start);
+  }
+
+  outb_buffer = OUTB &amp; ~(PIN_TCK | PIN_TMS);
+
+  /* Shift all bytes except the last byte */
+  for (i = 0; i &lt; scan_size_bytes - 1; i++) {
+    tdi_data = OUT2BUF[i + out_offset + 5];
+    tdo_data = 0;
+
+    for (j = 0; j &lt; 8; j++) {
+      if (tdi_data &amp; 0x01) {
+        outb_buffer |= PIN_TDI;
+      }
+      else {
+        outb_buffer &amp;= ~PIN_TDI;
+      }
+
+      OUTB = outb_buffer; /* TDI and TCK change here */
+      for (k = 0; k &lt; delay_scan_io; k++);
+      tdi_data = tdi_data &gt;&gt; 1;
+
+      OUTB = (outb_buffer | PIN_TCK);
+      for (k = 0; k &lt; delay_scan_io; k++);
+      tdo_data = tdo_data &gt;&gt; 1;
+
+      if (GET_TDO()) {
+        tdo_data |= 0x80;
+      }
+    }
+
+    /* Copy TDO data to IN2BUF */
+    IN2BUF[i + in_offset] = tdo_data;
+  }
+
+  tdi_data = OUT2BUF[i + out_offset + 5];
+  tdo_data = 0;
+
+  /* Shift the last byte */
+  for (j = 0; j &lt; bits_last_byte; j++) {
+    if (tdi_data &amp; 0x01) {
+      outb_buffer |= PIN_TDI;
+    }
+    else {
+      outb_buffer &amp;= ~PIN_TDI;
+    }
+
+    /* Assert TMS signal if requested and this is the last bit */
+    if ((j == bits_last_byte - 1) &amp;&amp; (tms_count_end &gt; 0)) {
+      outb_buffer |= PIN_TMS;
+      tms_count_end--;
+      tms_sequence_end = tms_sequence_end &gt;&gt; 1;
+    }
+
+    OUTB = outb_buffer; /* TDI and TCK change here */
+    for (k = 0; k &lt; delay_scan_io; k++);
+    tdi_data = tdi_data &gt;&gt; 1;
+
+    OUTB = (outb_buffer | PIN_TCK);
+    for (k = 0; k &lt; delay_scan_io; k++);
+    tdo_data = tdo_data &gt;&gt; 1;
+
+    if (GET_TDO()) {
+      tdo_data |= 0x80;
+    }
+  }
+  tdo_data = tdo_data &gt;&gt; (8 - bits_last_byte);
+
+  /* Copy TDO data to IN2BUF */
+  IN2BUF[i + in_offset] = tdo_data;
+
+  /* Move to correct end state */
+  if (tms_count_end &gt; 0) {
+    jtag_slow_clock_tms(tms_count_end, tms_sequence_end);
+  }
+}
+
+/**
  * Generate TCK clock cycles.
  *
+ * Maximum achievable TCK frequency is 375 kHz for ULINK clocked at 24 MHz.
+ *
  * @param count number of TCK clock cyclces to generate.
  */
 void jtag_clock_tck(u16 count)
 {
   u16 i;
-  u8 j;
+  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
 
   for ( i = 0; i &lt; count; i++ ) {
-    SET_TCK_LOW();
-    for(j = 0; j &lt; delay_tck; j++);
+    OUTB = outb_buffer;
+    OUTB = outb_buffer | PIN_TCK;
+  }
+}
+
+/**
+ * Generate TCK clock cycles at variable frequency.
+ *
+ * Maximum achieveable TCK frequency is 166.6 kHz for ULINK clocked at 24 MHz.
+ *
+ * @param count number of TCK clock cyclces to generate.
+ */
+void jtag_slow_clock_tck(u16 count)
+{
+  u16 i;
+  u8 j;
+  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
 
-    SET_TCK_HIGH();
-    for(j = 0; j &lt; delay_tck; j++);
+  for ( i = 0; i &lt; count; i++ ) {
+    OUTB = outb_buffer;
+    for (j = 0; j &lt; delay_tck; j++);
+    OUTB = outb_buffer | PIN_TCK;
+    for (j = 0; j &lt; delay_tck; j++);
   }
 }
 
 /**
- * Perform TAP-FSM state transitions at maximum TCK frequency.
+ * Perform TAP FSM state transitions at maximum TCK frequency.
+ *
+ * Maximum achievable TCK frequency is 176 kHz for ULINK clocked at 24 MHz.
  *
  * @param count the number of state transitions to perform.
  * @param sequence the TMS pin levels for each state transition, starting with
@@ -319,11 +633,9 @@ void jtag_clock_tck(u16 count)
  */
 void jtag_clock_tms(u8 count, u8 sequence)
 {
-  volatile u8 outb_buffer;
+  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
   u8 i;
 
-  outb_buffer = OUTB &amp; ~(PIN_TCK);
-
   for ( i = 0; i &lt; count; i++ ) {
     /* Set TMS pin according to sequence parameter */
     if ( sequence &amp; 0x1 ) {
@@ -342,13 +654,32 @@ void jtag_clock_tms(u8 count, u8 sequence)
 /**
  * Perform TAP-FSM state transitions at less than maximum TCK frequency.
  *
+ * Maximum achievable TCK frequency is 117 kHz for ULINK clocked at 24 MHz.
+ *
  * @param count the number of state transitions to perform.
  * @param sequence the TMS pin levels for each state transition, starting with
  *  the least-significant bit.
  */
 void jtag_slow_clock_tms(u8 count, u8 sequence)
 {
+  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
+  u8 i, j;
+
+  for (i = 0; i &lt; count; i++) {
+    /* Set TMS pin according to sequence parameter */
+    if ( sequence &amp; 0x1 ) {
+      outb_buffer |= PIN_TMS;
+    }
+    else {
+      outb_buffer &amp;= ~PIN_TMS;
+    }
 
+    OUTB = outb_buffer;
+    for (j = 0; j &lt; delay_tms; j++);
+    sequence = sequence &gt;&gt; 1;
+    OUTB = outb_buffer | PIN_TCK;
+    for (j = 0; j &lt; delay_tms; j++);
+  }
 }
 
 /**
@@ -402,13 +733,18 @@ void jtag_set_signals(u8 low, u8 high)
 /**
  * Configure TCK delay parameters.
  *
- * @param scan number of delay cycles in shift operations.
+ * @param scan_in number of delay cycles in scan_in operations.
+ * @param scan_out number of delay cycles in scan_out operations.
+ * @param scan_io number of delay cycles in scan_io operations.
  * @param tck number of delay cycles in clock_tck operations.
  * @param tms number of delay cycles in clock_tms operations.
  */
-void jtag_configure_tck_delay(u8 scan, u8 tck, u8 tms)
+void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
+    u8 tms)
 {
-  delay_scan = scan;
+  delay_scan_in = scan_in;
+  delay_scan_out = scan_out;
+  delay_scan_io = scan_io;
   delay_tck = tck;
   delay_tms = tms;
 }
diff --git a/src/jtag/drivers/OpenULINK/src/protocol.c b/src/jtag/drivers/OpenULINK/src/protocol.c
index 05929d0..6e33ec7 100644
--- a/src/jtag/drivers/OpenULINK/src/protocol.c
+++ b/src/jtag/drivers/OpenULINK/src/protocol.c
@@ -121,6 +121,30 @@ bool execute_command(void)
     count |= ((u16)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
     jtag_clock_tck(count);
     break;
+  case CMD_SLOW_SCAN_IN:
+    usb_out_bytecount = 5;
+    usb_in_bytecount = OUT2BUF[cmd_id_index + 1];
+    jtag_slow_scan_in(cmd_id_index + 1, payload_index_in);
+    break;
+  case CMD_SLOW_SCAN_OUT:
+    usb_out_bytecount = OUT2BUF[cmd_id_index + 1] + 5;
+    jtag_slow_scan_out(cmd_id_index + 1);
+    break;
+  case CMD_SLOW_SCAN_IO:
+    usb_in_bytecount = OUT2BUF[cmd_id_index + 1];
+    usb_out_bytecount = usb_in_bytecount + 5;
+    jtag_slow_scan_io(cmd_id_index + 1, payload_index_in);
+    break;
+  case CMD_SLOW_CLOCK_TMS:
+    usb_out_bytecount = 2;
+    jtag_slow_clock_tms(OUT2BUF[cmd_id_index + 1], OUT2BUF[cmd_id_index + 2]);
+    break;
+  case CMD_SLOW_CLOCK_TCK:
+    usb_out_bytecount = 2;
+    count = (u16)OUT2BUF[cmd_id_index + 1];
+    count |= ((u16)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
+    jtag_slow_clock_tck(count);
+    break;
   case CMD_SLEEP_US:
     usb_out_bytecount = 2;
     count = (u16)OUT2BUF[cmd_id_index + 1];
@@ -144,6 +168,15 @@ bool execute_command(void)
     usb_out_bytecount = 2;
     jtag_set_signals(OUT2BUF[cmd_id_index + 1], OUT2BUF[cmd_id_index + 2]);
     break;
+  case CMD_CONFIGURE_TCK_FREQ:
+    usb_out_bytecount = 5;
+    jtag_configure_tck_delay(
+        OUT2BUF[cmd_id_index + 1],  /* scan_in */
+        OUT2BUF[cmd_id_index + 2],  /* scan_out */
+        OUT2BUF[cmd_id_index + 3],  /* scan_io */
+        OUT2BUF[cmd_id_index + 4],  /* clock_tck */
+        OUT2BUF[cmd_id_index + 5]); /* clock_tms */
+    break;
   case CMD_SET_LEDS:
     usb_out_bytecount = 1;
     execute_set_led_command();

commit c881fb8532235c9dd1b0b3c6fa05a20ce9018306
Author: Martin Schmoelzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Tue Aug 23 14:21:56 2011 +0200

    ULINK driver: Fix whitespace in OpenULINK firmware usb.c module (trivial)
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
index b74b3a2..042addf 100644
--- a/src/jtag/drivers/OpenULINK/src/usb.c
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -57,7 +57,7 @@ volatile __xdata __at 0x7FE8 setup_data_t setup_data;
  */
 
 __code usb_device_descriptor_t device_descriptor = {
-  /* .bLength = */            sizeof(usb_device_descriptor_t),
+  /* .bLength = */             sizeof(usb_device_descriptor_t),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_DEVICE,
   /* .bcdUSB = */              0x0110, /* BCD: 01.00 (Version 1.0 USB spec) */
   /* .bDeviceClass = */        0xFF,   /* 0xFF = vendor-specific */

commit d1bd5569b30704faaef574759bd07493c1129989
Author: Martin Schmoelzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Tue Aug 23 16:53:03 2011 +0200

    ULINK driver: Implement JTAG_PATHMOVE command
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 1dc4d9e..a90c50d 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -1533,7 +1533,57 @@ int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd)
  */
 int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd)
 {
-  // TODO: Implement this!
+    int ret, i, num_states, batch_size, state_count;
+  tap_state_t *path;
+  uint8_t tms_sequence;
+
+  num_states = cmd-&gt;cmd.pathmove-&gt;num_states;
+  path = cmd-&gt;cmd.pathmove-&gt;path;
+  state_count = 0;
+
+  while (num_states &gt; 0) {
+    tms_sequence = 0;
+
+    /* Determine batch size */
+    if (num_states &gt;= 8) {
+      batch_size = 8;
+    }
+    else {
+      batch_size = num_states;
+    }
+
+    for (i = 0; i &lt; batch_size; i++) {
+      if (tap_state_transition(tap_get_state(), false) == path[state_count]) {
+        /* Append '0' transition: clear bit 'i' in tms_sequence */
+        buf_set_u32(&amp;tms_sequence, i, 1, 0x0);
+      }
+      else if (tap_state_transition(tap_get_state(), true)
+          == path[state_count]) {
+        /* Append '1' transition: set bit 'i' in tms_sequence */
+        buf_set_u32(&amp;tms_sequence, i, 1, 0x1);
+      }
+      else {
+        /* Invalid state transition */
+        LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP state transition&quot;,
+            tap_state_name(tap_get_state()),
+            tap_state_name(path[state_count]));
+        return ERROR_FAIL;
+      }
+
+      tap_set_state(path[state_count]);
+      state_count++;
+      num_states--;
+    }
+
+    /* Append CLOCK_TMS command to OpenULINK command queue */
+    LOG_INFO(
+        &quot;pathmove batch: count = %i, sequence = 0x%x&quot;, batch_size, tms_sequence);
+    ret = ulink_append_clock_tms_cmd(ulink_handle, batch_size, tms_sequence);
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
+
   return ERROR_OK;
 }
 

commit 118a9a9ca044bc85955aaec1bb2ef58f9aad19de
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Mon Jul 4 12:29:02 2011 +0200

    ULINK driver: Implement JTAG_STABLECLOCKS command
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 049989b..1dc4d9e 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -211,6 +211,7 @@ int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd);
 
 int ulink_post_process_scan(ulink_cmd_t *ulink_cmd);
 int ulink_post_process_queue(struct ulink *device);
@@ -1552,6 +1553,55 @@ int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd)
 }
 
 /**
+ * Generate TCK cycles while remaining in a stable state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
+ */
+int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd)
+{
+  int ret;
+  unsigned num_cycles;
+
+  if (!tap_is_state_stable(tap_get_state())) {
+    LOG_ERROR(&quot;JTAG_STABLECLOCKS: state not stable&quot;);
+    return ERROR_FAIL;
+  }
+
+  num_cycles = cmd-&gt;cmd.stableclocks-&gt;num_cycles;
+
+  /* TMS stays either high (Test Logic Reset state) or low (all other states) */
+  if (tap_get_state() == TAP_RESET) {
+    ret = ulink_append_set_signals_cmd(device, 0, SIGNAL_TMS);
+  }
+  else {
+    ret = ulink_append_set_signals_cmd(device, SIGNAL_TMS, 0);
+  }
+
+  if (ret != ERROR_OK) {
+    return ret;
+  }
+
+  while (num_cycles &gt; 0) {
+    if (num_cycles &gt; 0xFFFF) {
+      /* OpenULINK CMD_CLOCK_TCK can generate up to 0xFFFF (uint16_t) cycles */
+      ret = ulink_append_clock_tck_cmd(device, 0xFFFF);
+      num_cycles -= 0xFFFF;
+    }
+    else {
+      ret = ulink_append_clock_tck_cmd(device, num_cycles);
+      num_cycles = 0;
+    }
+
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+  }
+
+  return ERROR_OK;
+}
+
+/**
  * Post-process JTAG_SCAN command
  *
  * @param ulink_cmd pointer to OpenULINK command that shall be processed.
@@ -1612,6 +1662,7 @@ int ulink_post_process_queue(struct ulink *device)
       case JTAG_RESET:
       case JTAG_PATHMOVE:
       case JTAG_SLEEP:
+      case JTAG_STABLECLOCKS:
         /* Nothing to do for these commands */
         ret = ERROR_OK;
         break;
@@ -1672,6 +1723,9 @@ static int ulink_execute_queue(void)
     case JTAG_SLEEP:
       ret = ulink_queue_sleep(ulink_handle, cmd);
       break;
+    case JTAG_STABLECLOCKS:
+      ret = ulink_queue_stableclocks(ulink_handle, cmd);
+      break;
     default:
       ret = ERROR_FAIL;
       LOG_ERROR(&quot;BUG: encountered unknown JTAG command type&quot;);

commit b6e4d26695bd2268638ad52a1860f1c849b177cf
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Mon Jul 4 19:50:46 2011 +0200

    ULINK driver: Implement command to manually force downloading firmware image from arbitrary location
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 14a2ad8..049989b 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -62,8 +62,7 @@
 /** Delay (in microseconds) to wait while EZ-USB performs ReNumeration. */
 #define ULINK_RENUMERATION_DELAY 1500000
 
-/** Location of OpenULINK firmware image. TODO: Provide some way of modifying
- *  this path, maybe in a separate OpenOCD command? */
+/** Default location of OpenULINK firmware image. */
 #define ULINK_FIRMWARE_FILE      PKGLIBDIR &quot;/OpenULINK/ulink_firmware.hex&quot;
 
 /** Maximum size of a single firmware section. Entire EZ-USB code space = 8kB */
@@ -378,8 +377,9 @@ int ulink_load_firmware(struct ulink *device, char *filename)
   ulink_firmware_image.base_address = 0;
   ulink_firmware_image.base_address_set = 0;
 
-  ret = image_open(&amp;ulink_firmware_image, ULINK_FIRMWARE_FILE, &quot;ihex&quot;);
+  ret = image_open(&amp;ulink_firmware_image, filename, &quot;ihex&quot;);
   if (ret != ERROR_OK) {
+    LOG_ERROR(&quot;Could not load firmware image&quot;);
     return ret;
   }
 
@@ -1881,10 +1881,44 @@ static int ulink_quit(void)
   return ret;
 }
 
+/**
+ * Set a custom path to ULINK firmware image and force downloading to ULINK.
+ */
+COMMAND_HANDLER(ulink_download_firmware_handler)
+{
+  int ret;
+
+  if (CMD_ARGC != 1) {
+    LOG_ERROR(&quot;Need exactly one argument to ulink_download_firmware&quot;);
+    return ERROR_FAIL;
+  }
+
+  LOG_INFO(&quot;Downloading ULINK firmware image %s&quot;, CMD_ARGV[0]);
+
+  /* Download firmware image in CMD_ARGV[0] */
+  ret = ulink_load_firmware_and_renumerate(&amp;ulink_handle, (char *)CMD_ARGV[0],
+      ULINK_RENUMERATION_DELAY);
+
+  return ret;
+}
+
 /*************************** Command Registration **************************/
 
+static const struct command_registration ulink_command_handlers[] = {
+  {
+    .name = &quot;ulink_download_firmware&quot;,
+    .handler = &amp;ulink_download_firmware_handler,
+    .mode = COMMAND_EXEC,
+    .help = &quot;download firmware image to ULINK device&quot;,
+    .usage = &quot;path/to/ulink_firmware.hex&quot;,
+  },
+  COMMAND_REGISTRATION_DONE,
+};
+
 struct jtag_interface ulink_interface = {
   .name = &quot;ulink&quot;,
+
+  .commands = ulink_command_handlers,
   .transports = jtag_only,
 
   .execute_queue = ulink_execute_queue,

commit d01cbd71434d9ef0666fe9a3a1a29c9897b5caae
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Mon Jul 4 12:38:47 2011 +0200

    ULINK driver: Re-order queue functions to reflect the order in commands.h
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index d7e16b5..14a2ad8 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -203,16 +203,16 @@ int ulink_append_led_cmd(struct ulink *device, uint8_t led_state);
 int ulink_append_test_cmd(struct ulink *device);
 
 /* Interface between OpenULINK and OpenOCD */
-int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd);
+static void ulink_set_end_state(tap_state_t endstate);
 int ulink_queue_statemove(struct ulink *device);
-int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd);
-int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd);
+
+int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd);
+int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd);
 
-static void ulink_set_end_state(tap_state_t endstate);
-
 int ulink_post_process_scan(ulink_cmd_t *ulink_cmd);
 int ulink_post_process_queue(struct ulink *device);
 
@@ -1233,6 +1233,52 @@ int ulink_append_test_cmd(struct ulink *device)
 /******************* Interface between OpenULINK and OpenOCD ******************/
 
 /**
+ * Sets the end state follower (see interface.h) if \a endstate is a stable
+ * state.
+ *
+ * @param endstate the state the end state follower should be set to.
+ */
+static void ulink_set_end_state(tap_state_t endstate)
+{
+  if (tap_is_state_stable(endstate)) {
+    tap_set_end_state(endstate);
+  }
+  else {
+    LOG_ERROR(&quot;BUG: %s is not a valid end state&quot;, tap_state_name(endstate));
+    exit( EXIT_FAILURE);
+  }
+}
+
+/**
+ * Move from the current TAP state to the current TAP end state.
+ *
+ * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @return on success: ERROR_OK
+ * @return on failure: ERROR_FAIL
+ */
+int ulink_queue_statemove(struct ulink *device)
+{
+  uint8_t tms_sequence, tms_count;
+  int ret;
+
+  if (tap_get_state() == tap_get_end_state()) {
+    /* Do nothing if we are already there */
+    return ERROR_OK;
+  }
+
+  tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+  tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+
+  ret = ulink_append_clock_tms_cmd(device, tms_count, tms_sequence);
+
+  if (ret == ERROR_OK) {
+    tap_set_state(tap_get_end_state());
+  }
+
+  return ret;
+}
+
+/**
  * Perform a scan operation on a JTAG register.
  *
  * @param device pointer to struct ulink identifying ULINK driver instance.
@@ -1391,78 +1437,24 @@ int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd)
 }
 
 /**
- * Sets the end state follower (see interface.h) if \a endstate is a stable
- * state.
- *
- * @param endstate the state the end state follower should be set to.
- */
-static void ulink_set_end_state(tap_state_t endstate)
-{
-  if (tap_is_state_stable(endstate)) {
-    tap_set_end_state(endstate);
-  }
-  else {
-    LOG_ERROR(&quot;BUG: %s is not a valid end state&quot;, tap_state_name(endstate));
-    exit( EXIT_FAILURE);
-  }
-}
-
-/**
- * Move from the current TAP state to the current TAP end state.
+ * Move the TAP into the Test Logic Reset state.
  *
  * @param device pointer to struct ulink identifying ULINK driver instance.
+ * @param cmd pointer to the command that shall be executed.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_queue_statemove(struct ulink *device)
+int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd)
 {
-  uint8_t tms_sequence, tms_count;
   int ret;
 
-  if (tap_get_state() == tap_get_end_state()) {
-    /* Do nothing if we are already there */
-    return ERROR_OK;
-  }
-
-  tms_sequence = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-  tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
-
-  ret = ulink_append_clock_tms_cmd(device, tms_count, tms_sequence);
+  ret = ulink_append_clock_tms_cmd(device, 5, 0xff);
 
   if (ret == ERROR_OK) {
-    tap_set_state(tap_get_end_state());
-  }
-
-  return ret;
-}
-
-/**
- * Execute a JTAG_RESET command
- *
- * @param cmd pointer to the command that shall be executed.
- * @return on success: ERROR_OK
- * @return on failure: ERROR_FAIL
- */
-int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd)
-{
-  uint8_t low = 0, high = 0;
-
-  if (cmd-&gt;cmd.reset-&gt;trst) {
     tap_set_state(TAP_RESET);
-    high |= SIGNAL_TRST;
-  }
-  else {
-    low |= SIGNAL_TRST;
-  }
-
-  if (cmd-&gt;cmd.reset-&gt;srst) {
-    high |= SIGNAL_RESET;
-  }
-  else {
-    low |= SIGNAL_RESET;
   }
 
-  return ulink_append_set_signals_cmd(device, low, high);
+  return ret;
 }
 
 /**
@@ -1502,24 +1494,32 @@ int ulink_queue_runtest(struct ulink *device, struct jtag_command *cmd)
 }
 
 /**
- * Move the TAP into the Test Logic Reset state.
+ * Execute a JTAG_RESET command
  *
- * @param device pointer to struct ulink identifying ULINK driver instance.
  * @param cmd pointer to the command that shall be executed.
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_queue_tlr_reset(struct ulink *device, struct jtag_command *cmd)
+int ulink_queue_reset(struct ulink *device, struct jtag_command *cmd)
 {
-  int ret;
-
-  ret = ulink_append_clock_tms_cmd(device, 5, 0xff);
+  uint8_t low = 0, high = 0;
 
-  if (ret == ERROR_OK) {
+  if (cmd-&gt;cmd.reset-&gt;trst) {
     tap_set_state(TAP_RESET);
+    high |= SIGNAL_TRST;
+  }
+  else {
+    low |= SIGNAL_TRST;
   }
 
-  return ret;
+  if (cmd-&gt;cmd.reset-&gt;srst) {
+    high |= SIGNAL_RESET;
+  }
+  else {
+    low |= SIGNAL_RESET;
+  }
+
+  return ulink_append_set_signals_cmd(device, low, high);
 }
 
 /**
@@ -1607,10 +1607,10 @@ int ulink_post_process_queue(struct ulink *device)
       case JTAG_SCAN:
         ret = ulink_post_process_scan(current);
         break;
-      case JTAG_RUNTEST:
       case JTAG_TLR_RESET:
-      case JTAG_PATHMOVE:
+      case JTAG_RUNTEST:
       case JTAG_RESET:
+      case JTAG_PATHMOVE:
       case JTAG_SLEEP:
         /* Nothing to do for these commands */
         ret = ERROR_OK;
@@ -1657,18 +1657,18 @@ static int ulink_execute_queue(void)
     case JTAG_SCAN:
       ret = ulink_queue_scan(ulink_handle, cmd);
       break;
-    case JTAG_RUNTEST:
-      ret = ulink_queue_runtest(ulink_handle, cmd);
-      break;
     case JTAG_TLR_RESET:
       ret = ulink_queue_tlr_reset(ulink_handle, cmd);
       break;
-    case JTAG_PATHMOVE:
-      ret = ulink_queue_pathmove(ulink_handle, cmd);
+    case JTAG_RUNTEST:
+      ret = ulink_queue_runtest(ulink_handle, cmd);
       break;
     case JTAG_RESET:
       ret = ulink_queue_reset(ulink_handle, cmd);
       break;
+    case JTAG_PATHMOVE:
+      ret = ulink_queue_pathmove(ulink_handle, cmd);
+      break;
     case JTAG_SLEEP:
       ret = ulink_queue_sleep(ulink_handle, cmd);
       break;

commit b6f8b2ab669d070d6a4b82b36c4b0787bf162112
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Mon Jul 4 12:30:13 2011 +0200

    ULINK driver: Properly propagate return values in ulink_execute_queue()
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index f810394..d7e16b5 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -1678,6 +1678,10 @@ static int ulink_execute_queue(void)
       break;
     }
 
+    if (ret != ERROR_OK) {
+      return ret;
+    }
+
     cmd = cmd-&gt;next;
   }
 

commit 3633e8d7b8b88d58cfc5989a330dfbaa6b66fad4
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Mon Jun 27 01:00:15 2011 +0200

    ULINK driver: Update some comments, fix some coding mistakes
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 0e04fd6..f810394 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -136,7 +136,7 @@ struct ulink_cmd {
   /** Pointer to corresponding OpenOCD command for post-processing */
   struct jtag_command *cmd_origin;
 
-  struct ulink_cmd *next;    ///&lt; Pointer to next command (linked list)
+  struct ulink_cmd *next;     ///&lt; Pointer to next command (linked list)
 };
 
 typedef struct ulink_cmd ulink_cmd_t;
@@ -919,6 +919,7 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
   default:
     LOG_ERROR(&quot;BUG: ulink_append_scan_cmd() encountered an unknown scan type&quot;);
     ret = ERROR_FAIL;
+    break;
   }
 
   if (ret != ERROR_OK) {
@@ -1091,7 +1092,7 @@ int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
   cmd-&gt;payload_out[0] = low;
   cmd-&gt;payload_out[1] = high;
 
-  return ulink_append_queue(device, cmd);;
+  return ulink_append_queue(device, cmd);
 }
 
 /**
@@ -1265,7 +1266,7 @@ int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd)
   /* Determine scan type (IN/OUT/IO) */
   type = jtag_scan_type(cmd-&gt;cmd.scan);
 
-  /* Determine number of scan commands */
+  /* Determine number of scan commands with maximum payload */
   scans_max_payload = scan_size_bytes / 58;
 
   /* Determine size of last shift command */
@@ -1322,7 +1323,7 @@ int ulink_queue_scan(struct ulink *device, struct jtag_command *cmd)
     tms_sequence_resume = tap_get_tms_path(TAP_DRPAUSE, TAP_DRSHIFT);
   }
 
-  /* Generate scan commands with full payload */
+  /* Generate scan commands */
   bytecount = scan_size_bytes;
   while (bytecount &gt; 0) {
     if (bytecount == scan_size_bytes) {
@@ -1618,6 +1619,7 @@ int ulink_post_process_queue(struct ulink *device)
         ret = ERROR_FAIL;
         LOG_ERROR(&quot;BUG: ulink_post_process_queue() encountered unknown JTAG &quot;
             &quot;command type&quot;);
+        break;
       }
 
       if (ret != ERROR_OK) {
@@ -1673,6 +1675,7 @@ static int ulink_execute_queue(void)
     default:
       ret = ERROR_FAIL;
       LOG_ERROR(&quot;BUG: encountered unknown JTAG command type&quot;);
+      break;
     }
 
     cmd = cmd-&gt;next;

-----------------------------------------------------------------------

Summary of changes:
 src/Makefile.am                               |    4 +
 src/jtag/drivers/OpenULINK/include/jtag.h     |   14 +-
 src/jtag/drivers/OpenULINK/include/msgtypes.h |   25 +-
 src/jtag/drivers/OpenULINK/src/jtag.c         |  370 ++++++++++++-
 src/jtag/drivers/OpenULINK/src/protocol.c     |   33 ++
 src/jtag/drivers/OpenULINK/src/usb.c          |    2 +-
 src/jtag/drivers/OpenULINK/ulink_firmware.hex |  563 ++++++++++++--------
 src/jtag/drivers/ulink.c                      |  722 ++++++++++++++++++++-----
 8 files changed, 1345 insertions(+), 388 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002679.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-50-g7e20eda
</A></li>
	<LI>Next message: <A HREF="002681.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-70-gfbbce95
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2680">[ date ]</a>
              <a href="thread.html#2680">[ thread ]</a>
              <a href="subject.html#2680">[ subject ]</a>
              <a href="author.html#2680">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
