From ntfreak at users.sourceforge.net  Mon Mar  1 00:11:47 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Sun, 28 Feb 2010 23:11:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-37-g409e23e
Message-ID: <E1NlsIe-0002OA-Pc@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  409e23e39b955d92c8e879143d2b979b7de799e9 (commit)
       via  57fc63f9f16934be777a14707d518ea9c9c3db80 (commit)
       via  c9560ba19071b2f988b0210ad03e6d9e8eca5edb (commit)
       via  73c1cff7c242566d995e7b77de0fcec9fe50a6bb (commit)
       via  8d13a4662647c33901592f699fcf544d88cfe443 (commit)
       via  9d6ede25ddb0863873f84b6a55f4300891429049 (commit)
       via  550abe7396f60274ffd0c5f373eda046af9d9a85 (commit)
       via  4c9f29bd9c9e38c3f495f8c26869f4dfe8fe9983 (commit)
       via  b8d8953ae9995829a61ce7b34e544f004bb23c55 (commit)
       via  a851ce0d6f2b961f94e09746304e0fb0dad6a15f (commit)
      from  0324eb24967088f753bc2fd997b4c18f4ea988c8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 409e23e39b955d92c8e879143d2b979b7de799e9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Sun Feb 28 23:06:49 2010 +0000

    armv4_5: remove core_type check in mcr/mrc cmd
    
    core_type check is not required as the core function will be
    null for cores that do not support the mcr/mrc functions.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 0488785..1e9a296 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -840,13 +840,6 @@ static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return JIM_ERR;
 	}
 
-	if (arm->core_type == ARM_MODE_THREAD)
-	{
-		/* armv7m not supported */
-		LOG_ERROR("Unsupported Command");
-		return ERROR_OK;
-	}
-
 	if ((argc < 6) || (argc > 7)) {
 		/* FIXME use the command name to verify # params... */
 		LOG_ERROR("%s: wrong number of arguments", __func__);

commit 57fc63f9f16934be777a14707d518ea9c9c3db80
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Sun Feb 28 22:52:06 2010 +0000

    cm3-ftest: change to use arm disassemble
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/testing/examples/cortex/cm3-ftest.cfg b/testing/examples/cortex/cm3-ftest.cfg
index 2dae249..2c7809d 100644
--- a/testing/examples/cortex/cm3-ftest.cfg
+++ b/testing/examples/cortex/cm3-ftest.cfg
@@ -63,7 +63,7 @@ proc load_and_run { name halfwords n_instr } {
 	mwh $addr 0xe7fe
 
 	# disassemble, as sanity check and what's-happening trace
-	cortex_m3 disassemble 0x20000000 [expr 1 + $n_instr ]
+	arm disassemble 0x20000000 [expr 1 + $n_instr ]
 
 	# Assume that block of code is at most 16 halfwords long.
 	# Create a basic table of loop-to-self exception handlers.

commit c9560ba19071b2f988b0210ad03e6d9e8eca5edb
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Sun Feb 28 22:40:23 2010 +0000

    stellaris: recover_command use usleep rather than sleep
    
    windows api does not define a posix sleep, use usleep that
    has an openocd wrapper to the win32 native function.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index b80daed..c9c800e 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -1215,7 +1215,7 @@ COMMAND_HANDLER(stellaris_handle_recover_command)
 	retval = jtag_execute_queue();
 
 	/* wait 400+ msec ... OK, "1+ second" is simpler */
-	sleep(1);
+	usleep(1000);
 
 	/* USER INTERVENTION required for the power cycle
 	 * Restarting OpenOCD is likely needed because of mode switching.

commit 73c1cff7c242566d995e7b77de0fcec9fe50a6bb
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Sun Feb 28 22:37:53 2010 +0000

    FT2232: add missing enum when using ftd2xx library
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 43e7b9f..38195c7 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -86,6 +86,16 @@
 /* FT2232 access library includes */
 #if BUILD_FT2232_FTD2XX == 1
 #include <ftd2xx.h>
+
+enum ftdi_interface
+{
+    INTERFACE_ANY = 0,
+    INTERFACE_A   = 1,
+    INTERFACE_B   = 2,
+    INTERFACE_C   = 3,
+    INTERFACE_D   = 4
+};
+
 #elif BUILD_FT2232_LIBFTDI == 1
 #include <ftdi.h>
 #endif

commit 8d13a4662647c33901592f699fcf544d88cfe443
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Feb 26 23:30:30 2010 +0000

    semihosting: add armv7m semihosting support
    
    do_semihosting and arm_semihosting now check the core type and
    use the generic arm structure.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 24a4de5..2f50a4a 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -39,6 +39,9 @@
 
 #include "arm.h"
 #include "armv4_5.h"
+#include "arm7_9_common.h"
+#include "armv7m.h"
+#include "cortex_m3.h"
 #include "register.h"
 #include "arm_semihosting.h"
 #include <helper/binarybuffer.h>
@@ -62,14 +65,19 @@ static int open_modeflags[12] = {
 
 static int do_semihosting(struct target *target)
 {
-	struct arm *armv4_5 = target_to_arm(target);
-	uint32_t r0 = buf_get_u32(armv4_5->core_cache->reg_list[0].value, 0, 32);
-	uint32_t r1 = buf_get_u32(armv4_5->core_cache->reg_list[1].value, 0, 32);
-	uint32_t lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, ARM_MODE_SVC, 14).value, 0, 32);
-	uint32_t spsr = buf_get_u32(armv4_5->spsr->value, 0, 32);;
+	struct arm *arm = target_to_arm(target);
+	uint32_t r0 = buf_get_u32(arm->core_cache->reg_list[0].value, 0, 32);
+	uint32_t r1 = buf_get_u32(arm->core_cache->reg_list[1].value, 0, 32);
+	uint32_t lr, spsr;
 	uint8_t params[16];
 	int retval, result;
 
+	if (is_arm7_9(target_to_arm7_9(target)))
+	{
+		lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(arm->core_cache, ARM_MODE_SVC, 14).value, 0, 32);
+		spsr = buf_get_u32(arm->spsr->value, 0, 32);;
+	}
+
 	/*
 	 * TODO: lots of security issues are not considered yet, such as:
 	 * - no validation on target provided file descriptors
@@ -105,10 +113,10 @@ static int do_semihosting(struct target *target)
 					 * written file */
 					result = open((char *)fn, open_modeflags[m], 0644);
 				}
-				armv4_5->semihosting_errno =  errno;
+				arm->semihosting_errno =  errno;
 			} else {
 				result = -1;
-				armv4_5->semihosting_errno = EINVAL;
+				arm->semihosting_errno = EINVAL;
 			}
 		}
 		break;
@@ -120,7 +128,7 @@ static int do_semihosting(struct target *target)
 		else {
 			int fd = target_buffer_get_u32(target, params+0);
 			result = close(fd);
-			armv4_5->semihosting_errno = errno;
+			arm->semihosting_errno = errno;
 		}
 		break;
 
@@ -159,7 +167,7 @@ static int do_semihosting(struct target *target)
 			uint8_t *buf = malloc(l);
 			if (!buf) {
 				result = -1;
-				armv4_5->semihosting_errno = ENOMEM;
+				arm->semihosting_errno = ENOMEM;
 			} else {
 				retval = target_read_buffer(target, a, l, buf);
 				if (retval != ERROR_OK) {
@@ -167,7 +175,7 @@ static int do_semihosting(struct target *target)
 					return retval;
 				}
 				result = write(fd, buf, l);
-				armv4_5->semihosting_errno = errno;
+				arm->semihosting_errno = errno;
 				if (result >= 0)
 					result = l - result;
 				free(buf);
@@ -186,10 +194,10 @@ static int do_semihosting(struct target *target)
 			uint8_t *buf = malloc(l);
 			if (!buf) {
 				result = -1;
-				armv4_5->semihosting_errno = ENOMEM;
+				arm->semihosting_errno = ENOMEM;
 			} else {
 				result = read(fd, buf, l);
-				armv4_5->semihosting_errno = errno;
+				arm->semihosting_errno = errno;
 				if (result >= 0) {
 					retval = target_write_buffer(target, a, result, buf);
 					if (retval != ERROR_OK) {
@@ -229,7 +237,7 @@ static int do_semihosting(struct target *target)
 			int fd = target_buffer_get_u32(target, params+0);
 			off_t pos = target_buffer_get_u32(target, params+4);
 			result = lseek(fd, pos, SEEK_SET);
-			armv4_5->semihosting_errno = errno;
+			arm->semihosting_errno = errno;
 			if (result == pos)
 				result = 0;
 		}
@@ -244,7 +252,7 @@ static int do_semihosting(struct target *target)
 			struct stat buf;
 			result = fstat(fd, &buf);
 			if (result == -1) {
-				armv4_5->semihosting_errno = errno;
+				arm->semihosting_errno = errno;
 				result = -1;
 				break;
 			}
@@ -266,10 +274,10 @@ static int do_semihosting(struct target *target)
 					return retval;
 				fn[l] = 0;
 				result = remove((char *)fn);
-				armv4_5->semihosting_errno =  errno;
+				arm->semihosting_errno =  errno;
 			} else {
 				result = -1;
-				armv4_5->semihosting_errno = EINVAL;
+				arm->semihosting_errno = EINVAL;
 			}
 		}
 		break;
@@ -294,10 +302,10 @@ static int do_semihosting(struct target *target)
 				fn1[l1] = 0;
 				fn2[l2] = 0;
 				result = rename((char *)fn1, (char *)fn2);
-				armv4_5->semihosting_errno =  errno;
+				arm->semihosting_errno =  errno;
 			} else {
 				result = -1;
-				armv4_5->semihosting_errno = EINVAL;
+				arm->semihosting_errno = EINVAL;
 			}
 		}
 		break;
@@ -307,7 +315,7 @@ static int do_semihosting(struct target *target)
 		break;
 
 	case 0x13:	/* SYS_ERRNO */
-		result = armv4_5->semihosting_errno;
+		result = arm->semihosting_errno;
 		break;
 
 	case 0x15:	/* SYS_GET_CMDLINE */
@@ -383,25 +391,37 @@ static int do_semihosting(struct target *target)
 		fprintf(stderr, "semihosting: unsupported call %#x\n",
 				(unsigned) r0);
 		result = -1;
-		armv4_5->semihosting_errno = ENOTSUP;
+		arm->semihosting_errno = ENOTSUP;
 	}
 
 	/* resume execution to the original mode */
 
-	/* return value in R0 */
-	buf_set_u32(armv4_5->core_cache->reg_list[0].value, 0, 32, result);
-	armv4_5->core_cache->reg_list[0].dirty = 1;
-
-	/* LR --> PC */
-	buf_set_u32(armv4_5->pc->value, 0, 32, lr);
-	armv4_5->pc->dirty = 1;
-
-	/* saved PSR --> current PSR */
-	buf_set_u32(armv4_5->cpsr->value, 0, 32, spsr);
-	armv4_5->cpsr->dirty = 1;
-	armv4_5->core_mode = spsr & 0x1f;
-	if (spsr & 0x20)
-		armv4_5->core_state = ARM_STATE_THUMB;
+	if (is_arm7_9(target_to_arm7_9(target)))
+	{
+		/* return value in R0 */
+		buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, result);
+		arm->core_cache->reg_list[0].dirty = 1;
+
+		/* LR --> PC */
+		buf_set_u32(arm->core_cache->reg_list[15].value, 0, 32, lr);
+		arm->core_cache->reg_list[15].dirty = 1;
+
+		/* saved PSR --> current PSR */
+		buf_set_u32(arm->cpsr->value, 0, 32, spsr);
+		arm->cpsr->dirty = 1;
+		arm->core_mode = spsr & 0x1f;
+		if (spsr & 0x20)
+			arm->core_state = ARM_STATE_THUMB;
+	}
+	else
+	{
+		/* resume execution, this will be pc+2 to skip over the
+		 * bkpt instruction */
+
+		/* return result in R0 */
+		buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, result);
+		arm->core_cache->reg_list[0].dirty = 1;
+	}
 
 	return target_resume(target, 1, 0, 0, 0);
 }
@@ -425,60 +445,90 @@ int arm_semihosting(struct target *target, int *retval)
 	uint32_t pc, lr, spsr;
 	struct reg *r;
 
-	if (!arm->is_semihosting || arm->core_mode != ARM_MODE_SVC)
+	if (!arm->is_semihosting)
 		return 0;
 
-	/* Check for PC == 0x00000008 or 0xffff0008: Supervisor Call vector. */
-	r = arm->pc;
-	pc = buf_get_u32(r->value, 0, 32);
-	if (pc != 0x00000008 && pc != 0xffff0008)
-		return 0;
+	if (is_arm7_9(target_to_arm7_9(target)))
+	{
+		if (arm->core_mode != ARM_MODE_SVC)
+			return 0;
 
-	r = arm_reg_current(arm, 14);
-	lr = buf_get_u32(r->value, 0, 32);
+		/* Check for PC == 0x00000008 or 0xffff0008: Supervisor Call vector. */
+		r = arm->pc;
+		pc = buf_get_u32(r->value, 0, 32);
+		if (pc != 0x00000008 && pc != 0xffff0008)
+			return 0;
 
-	/* Core-specific code should make sure SPSR is retrieved
-	 * when the above checks pass...
-	 */
-	if (!arm->spsr->valid) {
-		LOG_ERROR("SPSR not valid!");
-		*retval = ERROR_FAIL;
-		return 1;
-	}
+		r = arm_reg_current(arm, 14);
+		lr = buf_get_u32(r->value, 0, 32);
 
-	spsr = buf_get_u32(arm->spsr->value, 0, 32);
+		/* Core-specific code should make sure SPSR is retrieved
+		 * when the above checks pass...
+		 */
+		if (!arm->spsr->valid) {
+			LOG_ERROR("SPSR not valid!");
+			*retval = ERROR_FAIL;
+			return 1;
+		}
 
-	/* check instruction that triggered this trap */
-	if (spsr & (1 << 5)) {
-		/* was in Thumb (or ThumbEE) mode */
-		uint8_t insn_buf[2];
-		uint16_t insn;
+		spsr = buf_get_u32(arm->spsr->value, 0, 32);
 
-		*retval = target_read_memory(target, lr-2, 2, 1, insn_buf);
-		if (*retval != ERROR_OK)
-			return 1;
-		insn = target_buffer_get_u16(target, insn_buf);
+		/* check instruction that triggered this trap */
+		if (spsr & (1 << 5)) {
+			/* was in Thumb (or ThumbEE) mode */
+			uint8_t insn_buf[2];
+			uint16_t insn;
+
+			*retval = target_read_memory(target, lr-2, 2, 1, insn_buf);
+			if (*retval != ERROR_OK)
+				return 1;
+			insn = target_buffer_get_u16(target, insn_buf);
 
-		/* SVC 0xab */
-		if (insn != 0xDFAB)
+			/* SVC 0xab */
+			if (insn != 0xDFAB)
+				return 0;
+		} else if (spsr & (1 << 24)) {
+			/* was in Jazelle mode */
+			return 0;
+		} else {
+			/* was in ARM mode */
+			uint8_t insn_buf[4];
+			uint32_t insn;
+
+			*retval = target_read_memory(target, lr-4, 4, 1, insn_buf);
+			if (*retval != ERROR_OK)
+				return 1;
+			insn = target_buffer_get_u32(target, insn_buf);
+
+			/* SVC 0x123456 */
+			if (insn != 0xEF123456)
+				return 0;
+		}
+	}
+	else if (is_armv7m(target_to_armv7m(target)))
+	{
+		uint16_t insn;
+
+		if (target->debug_reason != DBG_REASON_BREAKPOINT)
 			return 0;
-	} else if (spsr & (1 << 24)) {
-		/* was in Jazelle mode */
-		return 0;
-	} else {
-		/* was in ARM mode */
-		uint8_t insn_buf[4];
-		uint32_t insn;
 
-		*retval = target_read_memory(target, lr-4, 4, 1, insn_buf);
+		r = arm->pc;
+		pc = buf_get_u32(r->value, 0, 32);
+
+		pc &= ~1;
+		*retval = target_read_u16(target, pc, &insn);
 		if (*retval != ERROR_OK)
 			return 1;
-		insn = target_buffer_get_u32(target, insn_buf);
 
-		/* SVC 0x123456 */
-		if (insn != 0xEF123456)
+		/* bkpt 0xAB */
+		if (insn != 0xBEAB)
 			return 0;
 	}
+	else
+	{
+		LOG_ERROR("Unsupported semi-hosting Target");
+		return 0;
+	}
 
 	*retval = do_semihosting(target);
 	return 1;
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index ec11176..65e03bf 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -469,14 +469,15 @@ int armv7m_arch_state(struct target *target)
 	sp = buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_R13].value, 0, 32);
 
 	LOG_USER("target halted due to %s, current mode: %s %s\n"
-		"xPSR: %#8.8" PRIx32 " pc: %#8.8" PRIx32 " %csp: %#8.8" PRIx32,
+		"xPSR: %#8.8" PRIx32 " pc: %#8.8" PRIx32 " %csp: %#8.8" PRIx32 "%s",
 		debug_reason_name(target),
 		armv7m_mode_strings[armv7m->core_mode],
 		armv7m_exception_string(armv7m->exception_number),
 		buf_get_u32(arm->cpsr->value, 0, 32),
 		buf_get_u32(arm->pc->value, 0, 32),
 		(ctrl & 0x02) ? 'p' : 'm',
-		sp);
+		sp,
+		arm->is_semihosting ? ", semihosting" : "");
 
 	return ERROR_OK;
 }
@@ -529,6 +530,12 @@ struct reg_cache *armv7m_build_reg_cache(struct target *target)
 	return cache;
 }
 
+int armv7m_setup_semihosting(struct target *target, int enable)
+{
+	/* nothing todo for armv7m */
+	return ERROR_OK;
+}
+
 /** Sets up target as a generic ARMv7-M core */
 int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m)
 {
@@ -538,6 +545,7 @@ int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m)
 
 	arm->core_type = ARM_MODE_THREAD;
 	arm->arch_info = armv7m;
+	arm->setup_semihosting = armv7m_setup_semihosting;
 
 	/* FIXME remove v7m-specific r/w core_reg functions;
 	 * use the generic ARM core support..
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 0aa7ac1..aecf371 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -38,7 +38,7 @@
 #include "arm_disassembler.h"
 #include "register.h"
 #include "arm_opcodes.h"
-
+#include "arm_semihosting.h"
 
 /* NOTE:  most of this should work fine for the Cortex-M1 and
  * Cortex-M0 cores too, although they're ARMv6-M not ARMv7-M.
@@ -495,6 +495,9 @@ static int cortex_m3_poll(struct target *target)
 			if ((retval = cortex_m3_debug_entry(target)) != ERROR_OK)
 				return retval;
 
+			if (arm_semihosting(target, &retval) != 0)
+				return retval;
+
 			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 		}
 		if (prev_target_state == TARGET_DEBUG_RUNNING)

commit 9d6ede25ddb0863873f84b6a55f4300891429049
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Feb 26 23:29:38 2010 +0000

    semihosting: move semihosting cmd to arm cmd group
    
    Move semihosting cmd to the arm cmd group.
    
    Targets that support semihosting will setup the
    setup_semihosting callback function.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index d54ad12..507498f 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -6021,6 +6021,18 @@ Display a table of all banked core registers, fetching the current value from ev
 core mode if necessary.
 @end deffn
 
+ at deffn Command {arm semihosting} [@option{enable}|@option{disable}]
+ at cindex ARM semihosting
+Display status of semihosting, after optionally changing that status.
+
+Semihosting allows for code executing on an ARM target to use the
+I/O facilities on the host computer i.e. the system where OpenOCD
+is running. The target application must be linked against a library
+implementing the ARM semihosting convention that forwards operation
+requests by using a special SVC instruction that is trapped at the
+Supervisor Call vector by OpenOCD.
+ at end deffn
+
 @section ARMv4 and ARMv5 Architecture
 @cindex ARMv4
 @cindex ARMv5
@@ -6073,18 +6085,6 @@ cables (FT2232), but might be unsafe if used with targets running at very low
 speeds, like the 32kHz startup clock of an AT91RM9200.
 @end deffn
 
- at deffn Command {arm7_9 semihosting} [@option{enable}|@option{disable}]
- at cindex ARM semihosting
-Display status of semihosting, after optionally changing that status.
-
-Semihosting allows for code executing on an ARM target to use the
-I/O facilities on the host computer i.e. the system where OpenOCD
-is running. The target application must be linked against a library
-implementing the ARM semihosting convention that forwards operation
-requests by using a special SVC instruction that is trapped at the
-Supervisor Call vector by OpenOCD.
- at end deffn
-
 @subsection ARM720T specific commands
 @cindex ARM720T
 
diff --git a/src/target/arm.h b/src/target/arm.h
index 6b304e9..ee4bd76 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -132,6 +132,8 @@ struct arm {
 	/** Value to be returned by semihosting SYS_ERRNO request. */
 	int semihosting_errno;
 
+	int (*setup_semihosting)(struct target *target, int enable);
+
 	/** Backpointer to the target. */
 	struct target *target;
 
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 2176729..f9deb83 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2834,54 +2834,32 @@ COMMAND_HANDLER(handle_arm7_9_dcc_downloads_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_arm7_9_semihosting_command)
+int arm7_9_setup_semihosting(struct target *target, int enable)
 {
-	struct target *target = get_current_target(CMD_CTX);
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 
 	if (!is_arm7_9(arm7_9))
 	{
-		command_print(CMD_CTX, "current target isn't an ARM7/ARM9 target");
+		LOG_USER("current target isn't an ARM7/ARM9 target");
 		return ERROR_TARGET_INVALID;
 	}
 
-	if (CMD_ARGC > 0)
-	{
-		int semihosting;
-
-		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
-
-		if (!target_was_examined(target))
-		{
-			LOG_ERROR("Target not examined yet");
-			return ERROR_FAIL;
-		}
-
-		if (arm7_9->has_vector_catch) {
-			struct reg *vector_catch = &arm7_9->eice_cache
-					->reg_list[EICE_VEC_CATCH];
-
-			if (!vector_catch->valid)
-				embeddedice_read_reg(vector_catch);
-			buf_set_u32(vector_catch->value, 2, 1, semihosting);
-			embeddedice_store_reg(vector_catch);
-		} else {
-			/* TODO: allow optional high vectors and/or BKPT_HARD */
-			if (semihosting)
-				breakpoint_add(target, 8, 4, BKPT_SOFT);
-			else
-				breakpoint_remove(target, 8); 
-		}
-
-		/* FIXME never let that "catch" be dropped! */
-		arm7_9->armv4_5_common.is_semihosting = semihosting;
+	if (arm7_9->has_vector_catch) {
+		struct reg *vector_catch = &arm7_9->eice_cache
+				->reg_list[EICE_VEC_CATCH];
 
+		if (!vector_catch->valid)
+			embeddedice_read_reg(vector_catch);
+		buf_set_u32(vector_catch->value, 2, 1, enable);
+		embeddedice_store_reg(vector_catch);
+	} else {
+		/* TODO: allow optional high vectors and/or BKPT_HARD */
+		if (enable)
+			breakpoint_add(target, 8, 4, BKPT_SOFT);
+		else
+			breakpoint_remove(target, 8);
 	}
 
-	command_print(CMD_CTX, "semihosting is %s",
-			arm7_9->armv4_5_common.is_semihosting
-			? "enabled" : "disabled");
-
 	return ERROR_OK;
 }
 
@@ -2906,6 +2884,7 @@ int arm7_9_init_arch_info(struct target *target, struct arm7_9_common *arm7_9)
 	armv4_5->read_core_reg = arm7_9_read_core_reg;
 	armv4_5->write_core_reg = arm7_9_write_core_reg;
 	armv4_5->full_context = arm7_9_full_context;
+	armv4_5->setup_semihosting = arm7_9_setup_semihosting;
 
 	retval = arm_init_arch_info(target, armv4_5);
 	if (retval != ERROR_OK)
@@ -2939,13 +2918,6 @@ static const struct command_registration arm7_9_any_command_handlers[] = {
 		.usage = "['enable'|'disable']",
 		.help = "use DCC downloads for larger memory writes",
 	},
-	{
-		"semihosting",
-		.handler = handle_arm7_9_semihosting_command,
-		.mode = COMMAND_EXEC,
-		.usage = "['enable'|'disable']",
-		.help = "activate support for semihosting operations",
-	},
 	COMMAND_REGISTRATION_DONE
 };
 const struct command_registration arm7_9_command_handlers[] = {
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 36101b0..0488785 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -951,6 +951,49 @@ static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	return JIM_OK;
 }
 
+COMMAND_HANDLER(handle_arm_semihosting_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target ? target_to_arm(target) : NULL;
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	if (!arm->setup_semihosting)
+	{
+		command_print(CMD_CTX, "semihosting not supported for current target");
+	}
+
+	if (CMD_ARGC > 0)
+	{
+		int semihosting;
+
+		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
+
+		if (!target_was_examined(target))
+		{
+			LOG_ERROR("Target not examined yet");
+			return ERROR_FAIL;
+		}
+
+		if (arm->setup_semihosting(target, semihosting) != ERROR_OK) {
+			LOG_ERROR("Failed to Configure semihosting");
+			return ERROR_FAIL;
+		}
+
+		/* FIXME never let that "catch" be dropped! */
+		arm->is_semihosting = semihosting;
+	}
+
+	command_print(CMD_CTX, "semihosting is %s",
+			arm->is_semihosting
+			? "enabled" : "disabled");
+
+	return ERROR_OK;
+}
+
 static const struct command_registration arm_exec_command_handlers[] = {
 	{
 		.name = "reg",
@@ -985,6 +1028,13 @@ static const struct command_registration arm_exec_command_handlers[] = {
 		.help = "read coprocessor register",
 		.usage = "cpnum op1 CRn op2 CRm",
 	},
+	{
+		"semihosting",
+		.handler = handle_arm_semihosting_command,
+		.mode = COMMAND_EXEC,
+		.usage = "['enable'|'disable']",
+		.help = "activate support for semihosting operations",
+	},
 
 	COMMAND_REGISTRATION_DONE
 };

commit 550abe7396f60274ffd0c5f373eda046af9d9a85
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Feb 26 23:25:55 2010 +0000

    CortexM3: move disassemble cmd to arm cmd group
    
    Rather than using a Cortex disassemble cmd, we now use
    the arm generic version.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 9da2977..d54ad12 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -6427,12 +6427,6 @@ If @var{value} is defined, first assigns that.
 @subsection Cortex-M3 specific commands
 @cindex Cortex-M3
 
- at deffn Command {cortex_m3 disassemble} address [count]
- at cindex disassemble
-Disassembles @var{count} Thumb2 instructions starting at @var{address}.
-If @var{count} is not specified, a single instruction is disassembled.
- at end deffn
-
 @deffn Command {cortex_m3 maskisr} (@option{on}|@option{off})
 Control masking (disabling) interrupts during target step/resume.
 @end deffn
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 3ebc34a..0aa7ac1 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -1899,50 +1899,6 @@ static int cortex_m3_verify_pointer(struct command_context *cmd_ctx,
  * cortexm3_target structure, which is only used with CM3 targets.
  */
 
-/*
- * REVISIT Thumb2 disassembly should work for all ARMv7 cores, as well
- * as at least ARM-1156T2.  The interesting thing about Cortex-M is
- * that *only* Thumb2 disassembly matters.  There are also some small
- * additions to Thumb2 that are specific to ARMv7-M.
- */
-COMMAND_HANDLER(handle_cortex_m3_disassemble_command)
-{
-	int retval;
-	struct target *target = get_current_target(CMD_CTX);
-	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	uint32_t address;
-	unsigned long count = 1;
-	struct arm_instruction cur_instruction;
-
-	retval = cortex_m3_verify_pointer(CMD_CTX, cortex_m3);
-	if (retval != ERROR_OK)
-		return retval;
-
-	errno = 0;
-	switch (CMD_ARGC) {
-	case 2:
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], count);
-		/* FALL THROUGH */
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
-		break;
-	default:
-		command_print(CMD_CTX,
-			"usage: cortex_m3 disassemble <address> [<count>]");
-		return ERROR_OK;
-	}
-
-	while (count--) {
-		retval = thumb2_opcode(target, address, &cur_instruction);
-		if (retval != ERROR_OK)
-			return retval;
-		command_print(CMD_CTX, "%s", cur_instruction.text);
-		address += cur_instruction.instruction_size;
-	}
-
-	return ERROR_OK;
-}
-
 static const struct {
 	char name[10];
 	unsigned mask;
@@ -2057,13 +2013,6 @@ COMMAND_HANDLER(handle_cortex_m3_mask_interrupts_command)
 
 static const struct command_registration cortex_m3_exec_command_handlers[] = {
 	{
-		.name = "disassemble",
-		.handler = handle_cortex_m3_disassemble_command,
-		.mode = COMMAND_EXEC,
-		.help = "disassemble Thumb2 instructions",
-		.usage = "address [count]",
-	},
-	{
 		.name = "maskisr",
 		.handler = handle_cortex_m3_mask_interrupts_command,
 		.mode = COMMAND_EXEC,

commit 4c9f29bd9c9e38c3f495f8c26869f4dfe8fe9983
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri Feb 26 23:14:51 2010 +0000

    ARMv7M: add arm cmd group
    
    - Add arm cmd group to armv7m cmd chain.
     - arm cmd's now check the core type before running a cmd.
     - todo: add support for armv7m registers for reg cmd.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index a4a15b4..36101b0 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -627,6 +627,12 @@ COMMAND_HANDLER(handle_armv4_5_reg_command)
 		return ERROR_FAIL;
 	}
 
+	if (armv4_5->core_type != ARM_MODE_ANY)
+	{
+		command_print(CMD_CTX, "Microcontroller Profile not supported - use standard reg cmd");
+		return ERROR_OK;
+	}
+
 	if (!is_arm_mode(armv4_5->core_mode))
 		return ERROR_FAIL;
 
@@ -706,6 +712,13 @@ COMMAND_HANDLER(handle_armv4_5_core_state_command)
 		return ERROR_FAIL;
 	}
 
+	if (armv4_5->core_type == ARM_MODE_THREAD)
+	{
+		/* armv7m not supported */
+		command_print(CMD_CTX, "Unsupported Command");
+		return ERROR_OK;
+	}
+
 	if (CMD_ARGC > 0)
 	{
 		if (strcmp(CMD_ARGV[0], "arm") == 0)
@@ -723,7 +736,7 @@ COMMAND_HANDLER(handle_armv4_5_core_state_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_armv4_5_disassemble_command)
+COMMAND_HANDLER(handle_arm_disassemble_command)
 {
 	int retval = ERROR_OK;
 	struct target *target = get_current_target(CMD_CTX);
@@ -737,6 +750,12 @@ COMMAND_HANDLER(handle_armv4_5_disassemble_command)
 		return ERROR_FAIL;
 	}
 
+	if (arm->core_type == ARM_MODE_THREAD)
+	{
+		/* armv7m is always thumb mode */
+		thumb = 1;
+	}
+
 	switch (CMD_ARGC) {
 	case 3:
 		if (strcmp(CMD_ARGV[2], "thumb") != 0)
@@ -821,6 +840,13 @@ static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return JIM_ERR;
 	}
 
+	if (arm->core_type == ARM_MODE_THREAD)
+	{
+		/* armv7m not supported */
+		LOG_ERROR("Unsupported Command");
+		return ERROR_OK;
+	}
+
 	if ((argc < 6) || (argc > 7)) {
 		/* FIXME use the command name to verify # params... */
 		LOG_ERROR("%s: wrong number of arguments", __func__);
@@ -941,7 +967,7 @@ static const struct command_registration arm_exec_command_handlers[] = {
 	},
 	{
 		.name = "disassemble",
-		.handler = handle_armv4_5_disassemble_command,
+		.handler = handle_arm_disassemble_command,
 		.mode = COMMAND_EXEC,
 		.usage = "address [count ['thumb']]",
 		.help = "disassemble instructions ",
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 056ac7b..ec11176 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -878,6 +878,9 @@ static const struct command_registration armv7m_exec_command_handlers[] = {
 };
 const struct command_registration armv7m_command_handlers[] = {
 	{
+		.chain = arm_command_handlers,
+	},
+	{
 		.name = "dap",
 		.mode = COMMAND_EXEC,
 		.help = "Cortex DAP command group",

commit b8d8953ae9995829a61ce7b34e544f004bb23c55
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Jan 13 10:12:34 2010 +0000

    MIPS: add mips algorithm support
    
     - add mips support for target algorithms.
     - added handlers for target_checksum_memory and target_blank_check_memory.
     - clean up long lines
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/mips32.c b/src/target/mips32.c
index 5bb4104..b0cb79c 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -27,6 +27,8 @@
 #endif
 
 #include "mips32.h"
+#include "breakpoints.h"
+#include "algorithm.h"
 #include "register.h"
 
 char* mips32_core_reg_list[] =
@@ -319,9 +321,168 @@ int mips32_init_arch_info(struct target *target, struct mips32_common *mips32, s
 	return ERROR_OK;
 }
 
-int mips32_run_algorithm(struct target *target, int num_mem_params, struct mem_param *mem_params, int num_reg_params, struct reg_param *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info)
+/* run to exit point. return error if exit point was not reached. */
+static int mips32_run_and_wait(struct target *target, uint32_t entry_point,
+		int timeout_ms, uint32_t exit_point, struct mips32_common *mips32)
 {
-	/*TODO*/
+	uint32_t pc;
+	int retval;
+	/* This code relies on the target specific  resume() and  poll()->debug_entry()
+	 * sequence to write register values to the processor and the read them back */
+	if ((retval = target_resume(target, 0, entry_point, 0, 1)) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	retval = target_wait_state(target, TARGET_HALTED, timeout_ms);
+	/* If the target fails to halt due to the breakpoint, force a halt */
+	if (retval != ERROR_OK || target->state != TARGET_HALTED)
+	{
+		if ((retval = target_halt(target)) != ERROR_OK)
+			return retval;
+		if ((retval = target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
+		{
+			return retval;
+		}
+		return ERROR_TARGET_TIMEOUT;
+	}
+
+	pc = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32);
+	if (pc != exit_point)
+	{
+		LOG_DEBUG("failed algoritm halted at 0x%" PRIx32 " ", pc);
+		return ERROR_TARGET_TIMEOUT;
+	}
+
+	return ERROR_OK;
+}
+
+int mips32_run_algorithm(struct target *target, int num_mem_params,
+		struct mem_param *mem_params, int num_reg_params,
+		struct reg_param *reg_params, uint32_t entry_point,
+		uint32_t exit_point, int timeout_ms, void *arch_info)
+{
+	struct mips32_common *mips32 = target_to_mips32(target);
+	struct mips32_algorithm *mips32_algorithm_info = arch_info;
+	enum mips32_isa_mode isa_mode = mips32->isa_mode;
+
+	uint32_t context[MIPS32NUMCOREREGS];
+	int i;
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("Running algorithm");
+
+	/* NOTE: mips32_run_algorithm requires that each algorithm uses a software breakpoint
+	 * at the exit point */
+
+	if (mips32->common_magic != MIPS32_COMMON_MAGIC)
+	{
+		LOG_ERROR("current target isn't a MIPS32 target");
+		return ERROR_TARGET_INVALID;
+	}
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* refresh core register cache */
+	for (unsigned i = 0; i < MIPS32NUMCOREREGS; i++)
+	{
+		if (!mips32->core_cache->reg_list[i].valid)
+			mips32->read_core_reg(target, i);
+		context[i] = buf_get_u32(mips32->core_cache->reg_list[i].value, 0, 32);
+	}
+
+	for (i = 0; i < num_mem_params; i++)
+	{
+		if ((retval = target_write_buffer(target, mem_params[i].address,
+				mem_params[i].size, mem_params[i].value)) != ERROR_OK)
+		{
+			return retval;
+		}
+	}
+
+	for (int i = 0; i < num_reg_params; i++)
+	{
+		struct reg *reg = register_get_by_name(mips32->core_cache, reg_params[i].reg_name, 0);
+
+		if (!reg)
+		{
+			LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
+			return ERROR_INVALID_ARGUMENTS;
+		}
+
+		if (reg->size != reg_params[i].size)
+		{
+			LOG_ERROR("BUG: register '%s' size doesn't match reg_params[i].size",
+					reg_params[i].reg_name);
+			return ERROR_INVALID_ARGUMENTS;
+		}
+
+		mips32_set_core_reg(reg, reg_params[i].value);
+	}
+
+	mips32->isa_mode = mips32_algorithm_info->isa_mode;
+
+	retval = mips32_run_and_wait(target, entry_point, timeout_ms, exit_point, mips32);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	for (i = 0; i < num_mem_params; i++)
+	{
+		if (mem_params[i].direction != PARAM_OUT)
+		{
+			if ((retval = target_read_buffer(target, mem_params[i].address, mem_params[i].size,
+					mem_params[i].value)) != ERROR_OK)
+			{
+				return retval;
+			}
+		}
+	}
+
+	for (i = 0; i < num_reg_params; i++)
+	{
+		if (reg_params[i].direction != PARAM_OUT)
+		{
+			struct reg *reg = register_get_by_name(mips32->core_cache, reg_params[i].reg_name, 0);
+			if (!reg)
+			{
+				LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
+				return ERROR_INVALID_ARGUMENTS;
+			}
+
+			if (reg->size != reg_params[i].size)
+			{
+				LOG_ERROR("BUG: register '%s' size doesn't match reg_params[i].size",
+						reg_params[i].reg_name);
+				return ERROR_INVALID_ARGUMENTS;
+			}
+
+			buf_set_u32(reg_params[i].value, 0, 32, buf_get_u32(reg->value, 0, 32));
+		}
+	}
+
+	/* restore everything we saved before */
+	for (i = 0; i < MIPS32NUMCOREREGS; i++)
+	{
+		uint32_t regvalue;
+		regvalue = buf_get_u32(mips32->core_cache->reg_list[i].value, 0, 32);
+		if (regvalue != context[i])
+		{
+			LOG_DEBUG("restoring register %s with value 0x%8.8" PRIx32,
+				mips32->core_cache->reg_list[i].name, context[i]);
+			buf_set_u32(mips32->core_cache->reg_list[i].value,
+					0, 32, context[i]);
+			mips32->core_cache->reg_list[i].valid = 1;
+			mips32->core_cache->reg_list[i].dirty = 1;
+		}
+	}
+
+	mips32->isa_mode = isa_mode;
+
 	return ERROR_OK;
 }
 
@@ -397,7 +558,8 @@ int mips32_configure_break_unit(struct target *target)
 			return retval;
 	}
 
-	LOG_DEBUG("DCR 0x%" PRIx32 " numinst %i numdata %i", dcr, mips32->num_inst_bpoints, mips32->num_data_bpoints);
+	LOG_DEBUG("DCR 0x%" PRIx32 " numinst %i numdata %i", dcr, mips32->num_inst_bpoints,
+			mips32->num_data_bpoints);
 
 	mips32->bp_scanned = 1;
 
@@ -441,3 +603,150 @@ int mips32_enable_interrupts(struct target *target, int enable)
 
 	return ERROR_OK;
 }
+
+int mips32_checksum_memory(struct target *target, uint32_t address,
+		uint32_t count, uint32_t* checksum)
+{
+	struct working_area *crc_algorithm;
+	struct reg_param reg_params[2];
+	struct mips32_algorithm mips32_info;
+	int retval;
+	uint32_t i;
+
+	static const uint32_t mips_crc_code[] =
+	{
+		0x248C0000,		/* addiu 	$t4, $a0, 0 */
+		0x24AA0000,		/* addiu	$t2, $a1, 0 */
+		0x2404FFFF,		/* addiu	$a0, $zero, 0xffffffff */
+		0x10000010,		/* beq		$zero, $zero, ncomp */
+		0x240B0000,		/* addiu	$t3, $zero, 0 */
+						/* nbyte: */
+		0x81850000,		/* lb		$a1, ($t4) */
+		0x218C0001,		/* addi		$t4, $t4, 1 */
+		0x00052E00,		/* sll		$a1, $a1, 24 */
+		0x3C0204C1,		/* lui		$v0, 0x04c1 */
+		0x00852026,		/* xor		$a0, $a0, $a1 */
+		0x34471DB7,		/* ori		$a3, $v0, 0x1db7 */
+		0x00003021,		/* addu		$a2, $zero, $zero */
+						/* loop: */
+		0x00044040,		/* sll		$t0, $a0, 1 */
+		0x24C60001,		/* addiu	$a2, $a2, 1 */
+		0x28840000,		/* slti		$a0, $a0, 0 */
+		0x01074826,		/* xor		$t1, $t0, $a3 */
+		0x0124400B,		/* movn		$t0, $t1, $a0 */
+		0x28C30008,		/* slti		$v1, $a2, 8 */
+		0x1460FFF9,		/* bne		$v1, $zero, loop */
+		0x01002021,		/* addu		$a0, $t0, $zero */
+						/* ncomp: */
+		0x154BFFF0,		/* bne		$t2, $t3, nbyte */
+		0x256B0001,		/* addiu	$t3, $t3, 1 */
+		0x7000003F,		/* sdbbp */
+	};
+
+	/* make sure we have a working area */
+	if (target_alloc_working_area(target, sizeof(mips_crc_code), &crc_algorithm) != ERROR_OK)
+	{
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	/* convert flash writing code into a buffer in target endianness */
+	for (i = 0; i < ARRAY_SIZE(mips_crc_code); i++)
+		target_write_u32(target, crc_algorithm->address + i*sizeof(uint32_t), mips_crc_code[i]);
+
+	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
+	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
+
+	init_reg_param(&reg_params[0], "a0", 32, PARAM_IN_OUT);
+	buf_set_u32(reg_params[0].value, 0, 32, address);
+
+	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);
+	buf_set_u32(reg_params[1].value, 0, 32, count);
+
+	if ((retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
+			crc_algorithm->address, crc_algorithm->address + (sizeof(mips_crc_code)-4), 10000,
+			&mips32_info)) != ERROR_OK)
+	{
+		destroy_reg_param(&reg_params[0]);
+		destroy_reg_param(&reg_params[1]);
+		target_free_working_area(target, crc_algorithm);
+		return 0;
+	}
+
+	*checksum = buf_get_u32(reg_params[0].value, 0, 32);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+
+	target_free_working_area(target, crc_algorithm);
+
+	return ERROR_OK;
+}
+
+/** Checks whether a memory region is zeroed. */
+int mips32_blank_check_memory(struct target *target,
+		uint32_t address, uint32_t count, uint32_t* blank)
+{
+	struct working_area *erase_check_algorithm;
+	struct reg_param reg_params[3];
+	struct mips32_algorithm mips32_info;
+	int retval;
+	uint32_t i;
+
+	static const uint32_t erase_check_code[] =
+	{
+						/* nbyte: */
+		0x80880000,		/* lb		$t0, ($a0) */
+		0x00C83024,		/* and		$a2, $a2, $t0 */
+		0x24A5FFFF,		/* addiu	$a1, $a1, -1 */
+		0x14A0FFFC,		/* bne		$a1, $zero, nbyte */
+		0x24840001,		/* addiu	$a0, $a0, 1 */
+		0x7000003F		/* sdbbp */
+	};
+
+	/* make sure we have a working area */
+	if (target_alloc_working_area(target, sizeof(erase_check_code), &erase_check_algorithm) != ERROR_OK)
+	{
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	/* convert flash writing code into a buffer in target endianness */
+	for (i = 0; i < ARRAY_SIZE(erase_check_code); i++)
+	{
+		target_write_u32(target, erase_check_algorithm->address + i*sizeof(uint32_t),
+				erase_check_code[i]);
+	}
+
+	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
+	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
+
+	init_reg_param(&reg_params[0], "a0", 32, PARAM_OUT);
+	buf_set_u32(reg_params[0].value, 0, 32, address);
+
+	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);
+	buf_set_u32(reg_params[1].value, 0, 32, count);
+
+	init_reg_param(&reg_params[2], "a2", 32, PARAM_IN_OUT);
+	buf_set_u32(reg_params[2].value, 0, 32, 0xff);
+
+	if ((retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
+			erase_check_algorithm->address,
+			erase_check_algorithm->address + (sizeof(erase_check_code)-2),
+			10000, &mips32_info)) != ERROR_OK)
+	{
+		destroy_reg_param(&reg_params[0]);
+		destroy_reg_param(&reg_params[1]);
+		destroy_reg_param(&reg_params[2]);
+		target_free_working_area(target, erase_check_algorithm);
+		return 0;
+	}
+
+	*blank = buf_get_u32(reg_params[2].value, 0, 32);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+
+	target_free_working_area(target, erase_check_algorithm);
+
+	return ERROR_OK;
+}
diff --git a/src/target/mips32.h b/src/target/mips32.h
index b731c68..94d29ff 100644
--- a/src/target/mips32.h
+++ b/src/target/mips32.h
@@ -85,6 +85,12 @@ struct mips32_core_reg
 	struct mips32_common *mips32_common;
 };
 
+struct mips32_algorithm
+{
+	int common_magic;
+	enum mips32_isa_mode isa_mode;
+};
+
 #define MIPS32_OP_BEQ	0x04
 #define MIPS32_OP_BNE	0x05
 #define MIPS32_OP_ADDI	0x08
@@ -164,5 +170,9 @@ int mips32_register_commands(struct command_context *cmd_ctx);
 
 int mips32_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size);
+int mips32_checksum_memory(struct target *target, uint32_t address,
+		uint32_t count, uint32_t* checksum);
+int mips32_blank_check_memory(struct target *target,
+		uint32_t address, uint32_t count, uint32_t* blank);
 
 #endif	/*MIPS32_H*/
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index 7d91d42..f20c69e 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -206,7 +206,8 @@ static int mips32_pracc_exec_write(struct mips32_pracc_context *ctx, uint32_t ad
 	return ERROR_OK;
 }
 
-int mips32_pracc_exec(struct mips_ejtag *ejtag_info, int code_len, const uint32_t *code, int num_param_in, uint32_t *param_in, int num_param_out, uint32_t *param_out, int cycle)
+int mips32_pracc_exec(struct mips_ejtag *ejtag_info, int code_len, const uint32_t *code,
+		int num_param_in, uint32_t *param_in, int num_param_out, uint32_t *param_out, int cycle)
 {
 	uint32_t ejtag_ctrl;
 	uint32_t address, data;
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 5f5aa72..f581ddf 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -32,61 +32,6 @@
 #include "target_type.h"
 #include "register.h"
 
-/* cli handling */
-
-/* forward declarations */
-int mips_m4k_poll(struct target *target);
-int mips_m4k_halt(struct target *target);
-int mips_m4k_soft_reset_halt(struct target *target);
-int mips_m4k_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
-int mips_m4k_step(struct target *target, int current, uint32_t address, int handle_breakpoints);
-int mips_m4k_read_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-int mips_m4k_write_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
-int mips_m4k_init_target(struct command_context *cmd_ctx, struct target *target);
-int mips_m4k_target_create(struct target *target, Jim_Interp *interp);
-
-int mips_m4k_examine(struct target *target);
-int mips_m4k_assert_reset(struct target *target);
-int mips_m4k_deassert_reset(struct target *target);
-int mips_m4k_checksum_memory(struct target *target, uint32_t address, uint32_t size, uint32_t *checksum);
-
-struct target_type mips_m4k_target =
-{
-	.name = "mips_m4k",
-
-	.poll = mips_m4k_poll,
-	.arch_state = mips32_arch_state,
-
-	.target_request_data = NULL,
-
-	.halt = mips_m4k_halt,
-	.resume = mips_m4k_resume,
-	.step = mips_m4k_step,
-
-	.assert_reset = mips_m4k_assert_reset,
-	.deassert_reset = mips_m4k_deassert_reset,
-	.soft_reset_halt = mips_m4k_soft_reset_halt,
-
-	.get_gdb_reg_list = mips32_get_gdb_reg_list,
-
-	.read_memory = mips_m4k_read_memory,
-	.write_memory = mips_m4k_write_memory,
-	.bulk_write_memory = mips_m4k_bulk_write_memory,
-	.checksum_memory = mips_m4k_checksum_memory,
-	.blank_check_memory = NULL,
-
-	.run_algorithm = mips32_run_algorithm,
-
-	.add_breakpoint = mips_m4k_add_breakpoint,
-	.remove_breakpoint = mips_m4k_remove_breakpoint,
-	.add_watchpoint = mips_m4k_add_watchpoint,
-	.remove_watchpoint = mips_m4k_remove_watchpoint,
-
-	.target_create = mips_m4k_target_create,
-	.init_target = mips_m4k_init_target,
-	.examine = mips_m4k_examine,
-};
-
 int mips_m4k_examine_debug_reason(struct target *target)
 {
 	uint32_t break_status;
@@ -148,13 +93,8 @@ int mips_m4k_debug_entry(struct target *target)
 	/* default to mips32 isa, it will be changed below if required */
 	mips32->isa_mode = MIPS32_ISA_MIPS32;
 
-	if (ejtag_info->impcode & EJTAG_IMP_MIPS16)
-	{
-		if (buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32) & 0x01)
-		{
-			/* core is running mips16e isa */
-			mips32->isa_mode = MIPS32_ISA_MIPS16E;
-		}
+	if (ejtag_info->impcode & EJTAG_IMP_MIPS16) {
+		mips32->isa_mode = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1);
 	}
 
 	LOG_DEBUG("entered debug state at PC 0x%" PRIx32 ", target->state: %s",
@@ -396,6 +336,10 @@ int mips_m4k_resume(struct target *target, int current, uint32_t address, int ha
 		mips32->core_cache->reg_list[MIPS32_PC].valid = 1;
 	}
 
+	if (ejtag_info->impcode & EJTAG_IMP_MIPS16) {
+		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 1, mips32->isa_mode);
+	}
+
 	resume_pc = buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32);
 
 	mips32_restore_context(target);
@@ -457,9 +401,12 @@ int mips_m4k_step(struct target *target, int current, uint32_t address, int hand
 		buf_set_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32, address);
 
 	/* the front-end may request us not to handle breakpoints */
-	if (handle_breakpoints)
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32))))
+	if (handle_breakpoints) {
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(mips32->core_cache->reg_list[MIPS32_PC].value, 0, 32));
+		if (breakpoint)
 			mips_m4k_unset_breakpoint(target, breakpoint);
+	}
 
 	/* restore context */
 	mips32_restore_context(target);
@@ -545,7 +492,8 @@ int mips_m4k_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 		{
 			uint32_t verify = 0xffffffff;
 
-			if ((retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1, breakpoint->orig_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1,
+					breakpoint->orig_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -568,7 +516,8 @@ int mips_m4k_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 		{
 			uint16_t verify = 0xffff;
 
-			if ((retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1, breakpoint->orig_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint->address, breakpoint->length, 1,
+					breakpoint->orig_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -633,13 +582,15 @@ int mips_m4k_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 			uint32_t current_instr;
 
 			/* check that user program has not modified breakpoint instruction */
-			if ((retval = target_read_memory(target, breakpoint->address, 4, 1, (uint8_t*)&current_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint->address, 4, 1,
+					(uint8_t*)&current_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
 			if (current_instr == MIPS32_SDBBP)
 			{
-				if ((retval = target_write_memory(target, breakpoint->address, 4, 1, breakpoint->orig_instr)) != ERROR_OK)
+				if ((retval = target_write_memory(target, breakpoint->address, 4, 1,
+						breakpoint->orig_instr)) != ERROR_OK)
 				{
 					return retval;
 				}
@@ -650,14 +601,16 @@ int mips_m4k_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 			uint16_t current_instr;
 
 			/* check that user program has not modified breakpoint instruction */
-			if ((retval = target_read_memory(target, breakpoint->address, 2, 1, (uint8_t*)&current_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint->address, 2, 1,
+					(uint8_t*)&current_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
 
 			if (current_instr == MIPS16_SDBBP)
 			{
-				if ((retval = target_write_memory(target, breakpoint->address, 2, 1, breakpoint->orig_instr)) != ERROR_OK)
+				if ((retval = target_write_memory(target, breakpoint->address, 2, 1,
+						breakpoint->orig_instr)) != ERROR_OK)
 				{
 					return retval;
 				}
@@ -886,12 +839,14 @@ int mips_m4k_read_memory(struct target *target, uint32_t address, uint32_t size,
 	return ERROR_OK;
 }
 
-int mips_m4k_write_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+int mips_m4k_write_memory(struct target *target, uint32_t address, uint32_t size,
+		uint32_t count, uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, size, count);
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "",
+			address, size, count);
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -920,7 +875,8 @@ int mips_m4k_init_target(struct command_context *cmd_ctx, struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_init_arch_info(struct target *target, struct mips_m4k_common *mips_m4k, struct jtag_tap *tap)
+int mips_m4k_init_arch_info(struct target *target, struct mips_m4k_common *mips_m4k,
+		struct jtag_tap *tap)
 {
 	struct mips32_common *mips32 = &mips_m4k->mips32_common;
 
@@ -973,7 +929,8 @@ int mips_m4k_examine(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_bulk_write_memory(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
+		uint32_t count, uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -1012,7 +969,8 @@ int mips_m4k_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 		}
 	}
 
-	retval = mips32_pracc_fastdata_xfer(ejtag_info, source, write, address, count, (uint32_t*) buffer);
+	retval = mips32_pracc_fastdata_xfer(ejtag_info, source, write, address,
+			count, (uint32_t*) buffer);
 	if (retval != ERROR_OK)
 	{
 		/* FASTDATA access failed, try normal memory write */
@@ -1026,7 +984,39 @@ int mips_m4k_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 	return retval;
 }
 
-int mips_m4k_checksum_memory(struct target *target, uint32_t address, uint32_t size, uint32_t *checksum)
+struct target_type mips_m4k_target =
 {
-	return ERROR_FAIL; /* use bulk read method */
-}
+	.name = "mips_m4k",
+
+	.poll = mips_m4k_poll,
+	.arch_state = mips32_arch_state,
+
+	.target_request_data = NULL,
+
+	.halt = mips_m4k_halt,
+	.resume = mips_m4k_resume,
+	.step = mips_m4k_step,
+
+	.assert_reset = mips_m4k_assert_reset,
+	.deassert_reset = mips_m4k_deassert_reset,
+	.soft_reset_halt = mips_m4k_soft_reset_halt,
+
+	.get_gdb_reg_list = mips32_get_gdb_reg_list,
+
+	.read_memory = mips_m4k_read_memory,
+	.write_memory = mips_m4k_write_memory,
+	.bulk_write_memory = mips_m4k_bulk_write_memory,
+	.checksum_memory = mips32_checksum_memory,
+	.blank_check_memory = mips32_blank_check_memory,
+
+	.run_algorithm = mips32_run_algorithm,
+
+	.add_breakpoint = mips_m4k_add_breakpoint,
+	.remove_breakpoint = mips_m4k_remove_breakpoint,
+	.add_watchpoint = mips_m4k_add_watchpoint,
+	.remove_watchpoint = mips_m4k_remove_watchpoint,
+
+	.target_create = mips_m4k_target_create,
+	.init_target = mips_m4k_init_target,
+	.examine = mips_m4k_examine,
+};

commit a851ce0d6f2b961f94e09746304e0fb0dad6a15f
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Feb 2 13:22:07 2010 +0000

    ARMv7M: use software breakpoints for algorithms
    
     - armv7m_run_algorithm now requires all algorithms to use
       a software breakpoint at their exit address
     - updated all algorithms to support this
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 1b2f27c..5f013ed 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -2046,9 +2046,7 @@ sam3_page_write_opcodes[] = {
 	0x10,0xf0,0x01,0x0f,
 	//  41 0024 FBD0     		beq	.L4
 	0xfb,0xd0,
-	//  42              	.done:
-	//  43 0026 FEE7     		b	.done
-	0xfe,0xe7
+	0x00,0xBE     				/* bkpt #0 */
 };
 
 
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index fc2b1cf..6674f17 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -267,7 +267,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, int code, uint32_t param_ta
 				target_buffer_set_u32(target, jump_gate,
 						ARMV4_5_T_BX(12));
 				target_buffer_set_u32(target, jump_gate + 4,
-						ARMV4_5_T_B(0xfffffe));
+						ARMV5_T_BKPT(0));
 				break;
 			case lpc2000_v1:
 			case lpc2000_v2:
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 21a0cff..b80daed 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -805,8 +805,7 @@ static const uint8_t stellaris_write_code[] =
 	0x04,0x36,			/* adds	r6, r6, #4 */
 	0x96,0x42,			/* cmp	r6, r2 */
 	0xF4,0xD1,			/* bne	mainloop */
-						/* exit: */
-	0xFE,0xE7,			/* b exit */
+	0x00,0xBE,     		/* bkpt #0 */
 /* pFLASH_CTRL_BASE: */
 	0x00,0xD0,0x0F,0x40,	/* .word	0x400FD000 */
 /* FLASHWRITECMD: */
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index bfdd3cd..53fc4ea 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -459,8 +459,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 		0x01, 0xD1,					/* bne	exit */
 		0x01, 0x3A,					/* subs	r2, r2, #1 */
 		0xED, 0xD1,					/* bne	write */
-									/* exit: */
-		0xFE, 0xE7,					/* b exit */
+		0x00, 0xBE,     			/* bkpt #0 */
 		0x10, 0x20, 0x02, 0x40,		/* STM32_FLASH_CR:	.word 0x40022010 */
 		0x0C, 0x20, 0x02, 0x40		/* STM32_FLASH_SR:	.word 0x4002200C */
 	};
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 466c0b2..056ac7b 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -338,6 +338,9 @@ int armv7m_run_algorithm(struct target *target,
 	int retval = ERROR_OK;
 	uint32_t context[ARMV7M_NUM_REGS];
 
+	/* NOTE: armv7m_run_algorithm requires that each algorithm uses a software breakpoint
+	 * at the exit point */
+
 	if (armv7m_algorithm_info->common_magic != ARMV7M_COMMON_MAGIC)
 	{
 		LOG_ERROR("current target isn't an ARMV7M target");
@@ -395,22 +398,8 @@ int armv7m_run_algorithm(struct target *target,
 		armv7m->core_cache->reg_list[ARMV7M_CONTROL].valid = 1;
 	}
 
-	/* REVISIT speed things up (3% or so in one case) by requiring
-	 * algorithms to include a BKPT instruction at each exit point.
-	 * This eliminates overheads of adding/removing a breakpoint.
-	 */
-
-	/* ARMV7M always runs in Thumb state */
-	if ((retval = breakpoint_add(target, exit_point, 2, BKPT_SOFT)) != ERROR_OK)
-	{
-		LOG_ERROR("can't add breakpoint to finish algorithm execution");
-		return ERROR_TARGET_FAILURE;
-	}
-
 	retval = armv7m_run_and_wait(target, entry_point, timeout_ms, exit_point, armv7m);
 
-	breakpoint_remove(target, exit_point);
-
 	if (retval != ERROR_OK)
 	{
 		return retval;
@@ -594,8 +583,7 @@ int armv7m_checksum_memory(struct target *target,
 								/* ncomp: */
 		0x429C,					/* cmp	r4, r3 */
 		0xD1E9,					/* bne	nbyte */
-								/* end: */
-		0xE7FE,					/* b	end */
+		0xBE00,     			/* bkpt #0 */
 		0x1DB7, 0x04C1			/* CRC32XOR:	.word 0x04C11DB7 */
 	};
 
@@ -659,8 +647,7 @@ int armv7m_blank_check_memory(struct target *target,
 		0xEA02, 0x0203,		/* and  r2, r2, r3 */
 		0x3901,				/* subs	r1, r1, #1 */
 		0xD1F9,				/* bne	loop */
-		/* end: */
-		0xE7FE,				/* b	end */
+		0xBE00,     		/* bkpt #0 */
 	};
 
 	/* make sure we have a working area */

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi                      |   30 ++--
 src/flash/nor/at91sam3.c              |    4 +-
 src/flash/nor/lpc2000.c               |    2 +-
 src/flash/nor/stellaris.c             |    5 +-
 src/flash/nor/stm32x.c                |    3 +-
 src/jtag/drivers/ft2232.c             |   10 +
 src/target/arm.h                      |    2 +
 src/target/arm7_9_common.c            |   60 ++-----
 src/target/arm_semihosting.c          |  196 +++++++++++++--------
 src/target/armv4_5.c                  |   73 ++++++++-
 src/target/armv7m.c                   |   38 ++--
 src/target/cortex_m3.c                |   56 +------
 src/target/mips32.c                   |  315 ++++++++++++++++++++++++++++++++-
 src/target/mips32.h                   |   10 +
 src/target/mips32_pracc.c             |    3 +-
 src/target/mips_m4k.c                 |  146 +++++++--------
 testing/examples/cortex/cm3-ftest.cfg |    2 +-
 17 files changed, 654 insertions(+), 301 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar  1 13:34:05 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon,  1 Mar 2010 12:34:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-39-gafbf927
Message-ID: <E1Nm4p5-00012S-8f@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  afbf92766348a32a700d62a29b9a6c92537b9271 (commit)
       via  761d4555b8f8c8eb2b899dee16584656a43b6444 (commit)
      from  409e23e39b955d92c8e879143d2b979b7de799e9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit afbf92766348a32a700d62a29b9a6c92537b9271
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 1 08:25:57 2010 +0100

    zy1000: add jtag_add_tms_seq support
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index e21104c..b730b72 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2007-2009 by ??yvind Harboe                              *
+ *   Copyright (C) 2007-2010 by ??yvind Harboe                              *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -763,18 +763,52 @@ int interface_jtag_add_sleep(uint32_t us)
 	return ERROR_OK;
 }
 
+int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq, enum tap_state state)
+{
+	/*wait for the fifo to be empty*/
+	waitIdle();
+
+	for (unsigned i = 0; i < num_bits; i++)
+	{
+		int tms;
+
+		if (((seq[i/8] >> (i % 8)) & 1) == 0)
+		{
+			tms = 0;
+		}
+		else
+		{
+			tms = 1;
+		}
+
+		waitIdle();
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, tms);
+	}
+
+	waitIdle();
+	if (state != TAP_INVALID)
+	{
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, state);
+	} else
+	{
+		/* this would be normal if we are switching to SWD mode */
+	}
+	return ERROR_OK;
+}
+
 int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 {
 	int state_count;
 	int tms = 0;
 
-	/*wait for the fifo to be empty*/
-	waitIdle();
-
 	state_count = 0;
 
 	tap_state_t cur_state = cmd_queue_cur_state;
 
+	uint8_t seq[16];
+	memset(seq, 0, sizeof(seq));
+	assert(num_states < (sizeof(seq) * 8));
+
 	while (num_states)
 	{
 		if (tap_state_transition(cur_state, false) == path[state_count])
@@ -791,28 +825,14 @@ int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 			exit(-1);
 		}
 
-		waitIdle();
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28,  tms);
+		seq[state_count/8] = seq[state_count/8] | (tms << (state_count % 8));
 
 		cur_state = path[state_count];
 		state_count++;
 		num_states--;
 	}
 
-	waitIdle();
-	ZY1000_POKE(ZY1000_JTAG_BASE + 0x20,  cur_state);
-	return ERROR_OK;
-}
-
-int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq)
-{
-	/* FIXME just implement this, like pathmove but without
-	 * JTAG-specific state transition checking.  Then update
-	 * zy1000_interface to report that it's supported.
-	 *
-	 * Eventually interface_jtag_add_pathmove() could vanish.
-	 */
-	return ERROR_JTAG_NOT_IMPLEMENTED;
+	return interface_add_tms_seq(state_count, seq, cur_state);
 }
 
 void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
@@ -963,6 +983,7 @@ static const struct command_registration zy1000_commands[] = {
 struct jtag_interface zy1000_interface =
 {
 	.name = "ZY1000",
+	.supported = DEBUG_CAP_TMS_SEQ,
 	.execute_queue = NULL,
 	.speed = zy1000_speed,
 	.commands = zy1000_commands,

commit 761d4555b8f8c8eb2b899dee16584656a43b6444
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 1 08:22:12 2010 +0100

    jtag: the post TAP state is now passed to the drivers
    
    after clocking out a tms sequence, then the TAP will be
    in some state. This state is now handed to the drivers.
    
    TAP_INVALID is a possible state after a TMS sequence if
    switching to SWD.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 7f417b7..d43bd1c 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -512,7 +512,7 @@ int jtag_add_tms_seq(unsigned nbits, const uint8_t *seq, enum tap_state state)
 	jtag_checks();
 	cmd_queue_cur_state = state;
 
-	retval = interface_add_tms_seq(nbits, seq);
+	retval = interface_add_tms_seq(nbits, seq, state);
 	jtag_set_error(retval);
 	return retval;
 }
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 14efe96..ca59239 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -388,7 +388,7 @@ int interface_jtag_add_tlr(void)
 	return ERROR_OK;
 }
 
-int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq)
+int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq, enum tap_state state)
 {
 	struct jtag_command *cmd;
 
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 5caec58..810bb0e 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -67,7 +67,8 @@ int interface_jtag_add_tlr(void);
 int interface_jtag_add_pathmove(int num_states, const tap_state_t* path);
 int interface_jtag_add_runtest(int num_cycles, tap_state_t endstate);
 
-int interface_add_tms_seq(unsigned num_bits, const uint8_t *bits);
+int interface_add_tms_seq(unsigned num_bits,
+		const uint8_t *bits, enum tap_state state);
 
 /**
  * This drives the actual srst and trst pins. srst will always be 0
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 6410c2d..705f1b4 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -147,7 +147,7 @@ int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 	return ERROR_OK;
 }
 
-int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq)
+int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq, enum tap_state state)
 {
 	/* synchronously do the operation here */
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c                |    2 +-
 src/jtag/drivers/driver.c      |    2 +-
 src/jtag/minidriver.h          |    3 +-
 src/jtag/minidummy/minidummy.c |    2 +-
 src/jtag/zy1000/zy1000.c       |   61 +++++++++++++++++++++++++++-------------
 5 files changed, 46 insertions(+), 24 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar  1 15:24:53 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon,  1 Mar 2010 14:24:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-40-g27401e4
Message-ID: <E1Nm6YJ-0002JD-7m@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  27401e4c80b137f599954ac521387b247002770c (commit)
      from  afbf92766348a32a700d62a29b9a6c92537b9271 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 27401e4c80b137f599954ac521387b247002770c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 1 15:22:10 2010 +0100

    zy1000: arm11 load is now faster
    
    290kBytes/s @ 8MHz, no need to inline jtag_tap_next_enabled().
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index b730b72..6465aaa 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -888,57 +888,86 @@ int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opc
 	 * with unaligned uint32_t * pointers... */
 	const uint8_t *t = (const uint8_t *)data;
 
-	while (count--)
-	{
-		values[0] = *t++;
-		values[0] |= (*t++<<8);
-		values[0] |= (*t++<<16);
-		values[0] |= (*t++<<24);
 
-		if (count > 0)
+	/* bypass bits before and after */
+	int pre_bits = 0;
+	int post_bits = 0;
+
+	bool found = false;
+	struct jtag_tap *cur_tap, *nextTap;
+	for (cur_tap = jtag_tap_next_enabled(NULL); cur_tap!= NULL; cur_tap = nextTap)
+	{
+		nextTap = jtag_tap_next_enabled(cur_tap);
+		if (cur_tap == tap)
 		{
-			jtag_add_dr_out(tap,
-				2,
-				bits,
-				values,
-				TAP_DRPAUSE);
+			found = true;
+		} else
+		{
+			if (found)
+			{
+				post_bits++;
+			} else
+			{
+				pre_bits++;
+			}
+		}
+	}
+
+	post_bits+=2;
+
+
+	while (--count > 0)
+	{
+		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
+
+		uint32_t value;
+		value = *t++;
+		value |= (*t++<<8);
+		value |= (*t++<<16);
+		value |= (*t++<<24);
+
+		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, value);
+		shiftValueInner(TAP_DRSHIFT, TAP_DRPAUSE, post_bits, 0);
 
 #if 1
-			/* copy & paste from arm11_dbgtap.c */
-			//TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
-
-			waitIdle();
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-			waitIdle();
-			ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_DRSHIFT);
+		/* copy & paste from arm11_dbgtap.c */
+		//TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+
+		waitIdle();
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+		/* we don't have to wait for the queue to empty here. waitIdle();	 */
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_DRSHIFT);
 #else
-			static const tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
-			{
-				TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
-			};
+		static const tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
+		{
+			TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+		};
 
-			jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
-				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
+		jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
+			arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
 #endif
-		} else
-		{
-			/* This will happen on the last iteration updating the current tap state
-			 * so we don't have to track it during the common code path */
-			jtag_add_dr_out(tap,
-				2,
-				bits,
-				values,
-				TAP_IDLE);
-		}
 	}
 
+	values[0] = *t++;
+	values[0] |= (*t++<<8);
+	values[0] |= (*t++<<16);
+	values[0] |= (*t++<<24);
+
+	/* This will happen on the last iteration updating the current tap state
+	 * so we don't have to track it during the common code path */
+	jtag_add_dr_out(tap,
+		2,
+		bits,
+		values,
+		TAP_IDLE);
+
 	return jtag_execute_queue();
 #endif
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |  113 +++++++++++++++++++++++++++++-----------------
 1 files changed, 71 insertions(+), 42 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar  1 15:40:16 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon,  1 Mar 2010 14:40:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-41-gb1c00e5
Message-ID: <E1Nm6nB-0000Xw-KH@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b1c00e5a4e038068dce4512c5a2eb3735990b880 (commit)
      from  27401e4c80b137f599954ac521387b247002770c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b1c00e5a4e038068dce4512c5a2eb3735990b880
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 1 15:39:41 2010 +0100

    zy1000: faster jtag_add_ir_scan()
    
    Faster and simpler.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 6465aaa..c5bc0ff 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -608,15 +608,9 @@ int interface_jtag_add_ir_scan(int num_fields, const struct scan_field *fields,
 		if (!found)
 		{
 			/* if a device isn't listed, set it to BYPASS */
-			uint8_t ones[]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
-
-			struct scan_field tmp;
-			memset(&tmp, 0, sizeof(tmp));
-			tmp.out_value = ones;
-			tmp.num_bits = scan_size;
-			scanFields(1, &tmp, TAP_IRSHIFT, pause);
-			/* update device information */
-			buf_cpy(tmp.out_value, tap->cur_instr, scan_size);
+			assert(scan_size <= 32);
+			shiftValueInner(TAP_IRSHIFT, pause?TAP_IRPAUSE:TAP_IRSHIFT, scan_size, 0xffffffff);
+
 			tap->bypass = 1;
 		}
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   12 +++---------
 1 files changed, 3 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Mar  1 19:40:13 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon,  1 Mar 2010 18:40:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-42-gcb72b7a
Message-ID: <E1NmAXP-0004ed-28@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  cb72b7a270c7be60c1ec2ee47282156397bea846 (commit)
      from  b1c00e5a4e038068dce4512c5a2eb3735990b880 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit cb72b7a270c7be60c1ec2ee47282156397bea846
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Mar 1 10:39:57 2010 -0800

    arm_semihosting buildfix
    
    The recent "add armv7m semihosting support" patch introduced two
    build errors:
    
    arm_semihosting.c: In function ???do_semihosting???:
    arm_semihosting.c:71: error: ???spsr??? may be used uninitialized in this function
    arm_semihosting.c:71: error: ???lr??? may be used uninitialized in this function
    
    This fixes those build errors.  The behavior is, however, untested.
    (Also, note the two new REVISIT comments.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 2f50a4a..a247cc8 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -68,16 +68,9 @@ static int do_semihosting(struct target *target)
 	struct arm *arm = target_to_arm(target);
 	uint32_t r0 = buf_get_u32(arm->core_cache->reg_list[0].value, 0, 32);
 	uint32_t r1 = buf_get_u32(arm->core_cache->reg_list[1].value, 0, 32);
-	uint32_t lr, spsr;
 	uint8_t params[16];
 	int retval, result;
 
-	if (is_arm7_9(target_to_arm7_9(target)))
-	{
-		lr = buf_get_u32(ARMV4_5_CORE_REG_MODE(arm->core_cache, ARM_MODE_SVC, 14).value, 0, 32);
-		spsr = buf_get_u32(arm->spsr->value, 0, 32);;
-	}
-
 	/*
 	 * TODO: lots of security issues are not considered yet, such as:
 	 * - no validation on target provided file descriptors
@@ -396,22 +389,35 @@ static int do_semihosting(struct target *target)
 
 	/* resume execution to the original mode */
 
+	/* REVISIT this looks wrong ... ARM11 and Cortex-A8
+	 * should work this way at least sometimes.
+	 */
 	if (is_arm7_9(target_to_arm7_9(target)))
 	{
+		uint32_t spsr;
+
 		/* return value in R0 */
 		buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, result);
 		arm->core_cache->reg_list[0].dirty = 1;
 
 		/* LR --> PC */
-		buf_set_u32(arm->core_cache->reg_list[15].value, 0, 32, lr);
+		buf_set_u32(arm->core_cache->reg_list[15].value, 0, 32,
+			buf_get_u32(arm_reg_current(arm,14)->value, 0, 32));
 		arm->core_cache->reg_list[15].dirty = 1;
 
 		/* saved PSR --> current PSR */
+		spsr = buf_get_u32(arm->spsr->value, 0, 32);
+
+		/* REVISIT should this be arm_set_cpsr(arm, spsr)
+		 * instead of a partially unrolled version?
+		 */
+
 		buf_set_u32(arm->cpsr->value, 0, 32, spsr);
 		arm->cpsr->dirty = 1;
 		arm->core_mode = spsr & 0x1f;
 		if (spsr & 0x20)
 			arm->core_state = ARM_STATE_THUMB;
+
 	}
 	else
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_semihosting.c |   22 ++++++++++++++--------
 1 files changed, 14 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Mar  2 18:42:27 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  2 Mar 2010 17:42:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-43-g5b31186
Message-ID: <E1NmW72-0006UO-W7@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5b311865788009445a1457f62204899a4aa1c7b3 (commit)
      from  cb72b7a270c7be60c1ec2ee47282156397bea846 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5b311865788009445a1457f62204899a4aa1c7b3
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 2 09:39:36 2010 -0800

    ADIv5: use right ID for Cortex-M3 ETM
    
    Correct a mistake made copying the ID of the Cortex-M3 ETM module
    from the TRM, so that "dap info" on a CM3 with an ETM will now
    correctly describe ROM table entries for such modules.  (They are
    included on LPC17xx and some other cores.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 6be60af..115ccf1 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1530,10 +1530,6 @@ int dap_info_command(struct command_context *cmd_ctx,
 					type = "TI DAPCTL";
 					full = "";
 					break;
-				case 0x4e0:
-					type = "Cortex-M3 ETM";
-					full = "(Embedded Trace)";
-					break;
 				case 0x906:
 					type = "Coresight CTI";
 					full = "(Cross Trigger)";
@@ -1566,6 +1562,10 @@ int dap_info_command(struct command_context *cmd_ctx,
 					type = "Cortex-M3 TPIU";
 					full = "(Trace Port Interface Unit)";
 					break;
+				case 0x924:
+					type = "Cortex-M3 ETM";
+					full = "(Embedded Trace)";
+					break;
 				case 0xc08:
 					type = "Cortex-A8 Debug";
 					full = "(Debug Unit)";

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Mar  3 00:06:34 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  2 Mar 2010 23:06:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-44-g53b3d4d
Message-ID: <E1NmbAi-0004Jp-Ey@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  53b3d4dd53eebbf03f481dc59e4bc0259911864a (commit)
      from  5b311865788009445a1457f62204899a4aa1c7b3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 53b3d4dd53eebbf03f481dc59e4bc0259911864a
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 2 15:00:14 2010 -0800

    LPC1768 updates, IAR board support
    
    Fix some issues with the generic LPC1768 config file:
    
     - Handle the post-reset clock config:  4 MHz internal RC, no PLL.
       This affects flash and JTAG clocking.
    
     - Remove JTAG adapter config; they don't all support trst_and_srst
    
     - Remove the rest of the bogus "reset-init" event handler.
    
     - Allow explicit CCLK configuration, instead of assuming 12 MHz;
       some boards will use 100 Mhz (or the post-reset 4 MHz).
    
     - Simplify: rely on defaults for endianness and IR-Capture value
    
     - Update some comments too
    
    Build on those fixes to make a trivial config for the IAR LPC1768
    kickstart board (by Olimex) start working.
    
    Also, add doxygen to the lpc2000 flash driver, primarily to note a
    configuration problem with driver: it wrongly assumes the core clock
    rate never changes.  Configs that are safe for updating flash after
    "reset halt" will thus often be unsafe later ... e.g. for LPC1768,
    after switching to use PLL0 at 100 MHz.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 56c697f..4fef5b2 100644
--- a/NEWS
+++ b/NEWS
@@ -18,6 +18,7 @@ Flash Layer:
 
 
 Board, Target, and Interface Configuration Scripts:
+	Support IAR LPC1768 kickstart board (by Olimex)
 
 Core Jim/TCL Scripting:
 
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 6674f17..438ab54 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -33,7 +33,15 @@
 #include <target/armv7m.h>
 
 
-/* flash programming support for NXP LPC17xx and LPC2xxx devices
+/**
+ * @file
+ * flash programming support for NXP LPC17xx and LPC2xxx devices.
+ *
+ * @todo Provide a way to update CCLK after declaring the flash bank.
+ * The value which is correct after chip reset will rarely still work
+ * right after the clocks switch to use the PLL (e.g. 4MHz --> 100 MHz).
+ */
+/*
  * currently supported devices:
  * variant 1 (lpc2000_v1):
  * - 2104 | 5 | 6
diff --git a/tcl/board/iar_lpc1768.cfg b/tcl/board/iar_lpc1768.cfg
new file mode 100644
index 0000000..b8fd026
--- /dev/null
+++ b/tcl/board/iar_lpc1768.cfg
@@ -0,0 +1,17 @@
+# Board from IAR KickStart Kit for LPC1768
+# See www.iar.com and also
+# http://www.olimex.com/dev/lpc-1766stk.html
+#
+
+source [find target/lpc1768.cfg]
+
+# The chip has just been reset.
+#
+$_TARGETNAME configure -event reset-init {
+	# FIXME update the core clock to run at 100 MHz;
+	# and update JTAG clocking similarly; then
+	# make CCLK match,
+
+	flash probe 0
+}
+
diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index f0093ad..182fb89 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -1,4 +1,4 @@
-# NXP LPC1768 Cortex-M3 with 512kB Flash and 32kB+32kB Local On-Chip SRAM, clocked with 4MHz internal RC oscillator
+# NXP LPC1768 Cortex-M3 with 512kB Flash and 32kB+32kB Local On-Chip SRAM,
 
 if { [info exists CHIPNAME] } {
 	set  _CHIPNAME $CHIPNAME
@@ -6,12 +6,18 @@ if { [info exists CHIPNAME] } {
 	set  _CHIPNAME lpc1768
 }
 
-if { [info exists ENDIAN] } {
-	set  _ENDIAN $ENDIAN
+# After reset the chip is clocked by the ~4MHz internal RC oscillator.
+# When board-specific code (reset-init handler or device firmware)
+# configures another oscillator and/or PLL0, set CCLK to match; if
+# you don't, then flash erase and write operations may misbehave.
+# (The ROM code doing those updates cares about core clock speed...)
+#
+# CCLK is the core clock frequency in KHz
+if { [info exists CCLK ] } {
+	set _CCLK $CCLK
 } else {
-	set  _ENDIAN little
+	set _CCLK 4000
 }
-
 if { [info exists CPUTAPID ] } {
 	set _CPUTAPID $CPUTAPID
 } else {
@@ -23,29 +29,25 @@ jtag_nsrst_delay 200
 jtag_ntrst_delay 200
 
 # LPC2000 & LPC1700 -> SRST causes TRST
-reset_config trst_and_srst srst_pulls_trst
+reset_config srst_pulls_trst
 
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
-
-# LPC1768 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
-$_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size 0x8000 -work-area-backup 0
+target create $_TARGETNAME cortex_m3 -chain-position $_TARGETNAME
 
-# REVISIT is there any good reason to have this reset-init event handler??
-# Normally they should set up (board-specific) clocking then probe the flash...
-$_TARGETNAME configure -event reset-init {
-	# Force NVIC.VTOR to point to flash at 0 ...
-	# WHY?  This is it's reset value; we run right after reset!!
-	mwb 0xE000ED08 0x00
-}
-
-# LPC1768 has 512kB of user-available FLASH (bootloader is located in separate dedicated region).
-# flash bank lpc1700 <base> <size> 0 0 <target#> <variant> <cclk> [calc_checksum]
+# LPC1768 has 32kB of SRAM In the ARMv7-M "Code" area (at 0x10000000)
+# and 32K more on AHB, in the ARMv7-M "SRAM" area, (at 0x2007c000).
+$_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size 0x8000
 
+# LPC1768 has 512kB of flash memory, managed by ROM code (including a
+# boot loader which verifies the flash exception table's checksum).
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x80000 0 0 $_TARGETNAME lpc1700 12000 calc_checksum
-
-# 4MHz / 6 = 666kHz, so use 500
-jtag_khz 500
+flash bank $_FLASHNAME lpc2000 0x0 0x80000 0 0 $_TARGETNAME \
+	lpc1700 $_CCLK calc_checksum
+
+# JTAG clock should be CCLK/6 (unless using adaptive clocking)
+# CCLK is 4 MHz after reset, and until board-specific code (like
+# a reset-init handler) speeds it up.
+jtag_rclk [ expr 4000 / 6 ]
+$_TARGETNAME configure -event reset-start { jtag_rclk [ expr 4000 / 6]  }

-----------------------------------------------------------------------

Summary of changes:
 NEWS                      |    1 +
 src/flash/nor/lpc2000.c   |   10 +++++++-
 tcl/board/iar_lpc1768.cfg |   17 ++++++++++++++
 tcl/target/lpc1768.cfg    |   52 +++++++++++++++++++++++---------------------
 4 files changed, 54 insertions(+), 26 deletions(-)
 create mode 100644 tcl/board/iar_lpc1768.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Mar  3 00:45:43 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  2 Mar 2010 23:45:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-45-gd72e90a
Message-ID: <E1Nmbma-00044c-Lu@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d72e90ae4b070cc08799e800c111dd422ac6b1a4 (commit)
      from  53b3d4dd53eebbf03f481dc59e4bc0259911864a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d72e90ae4b070cc08799e800c111dd422ac6b1a4
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 2 15:45:12 2010 -0800

    target_resume() doxygen
    
    Add doxygen for target_resume() ... referencing the still-unresolved
    confusion about what the "debug_execution" parameter means (not all
    CPU support code acts the same).
    
    The 'handle_breakpoints" param seems to have resolved the main issue
    with its semantics, but it wasn't part of the function spec before.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/target.c b/src/target/target.c
index 2522408..9596302 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -424,6 +424,36 @@ int target_halt(struct target *target)
 	return ERROR_OK;
 }
 
+/**
+ * Make the target (re)start executing using its saved execution
+ * context (possibly with some modifications).
+ *
+ * @param target Which target should start executing.
+ * @param current True to use the target's saved program counter instead
+ *	of the address parameter
+ * @param address Optionally used as the program counter.
+ * @param handle_breakpoints True iff breakpoints at the resumption PC
+ *	should be skipped.  (For example, maybe execution was stopped by
+ *	such a breakpoint, in which case it would be counterprodutive to
+ *	let it re-trigger.
+ * @param debug_execution False if all working areas allocated by OpenOCD
+ *	should be released and/or restored to their original contents.
+ *	(This would for example be true to run some downloaded "helper"
+ *	algorithm code, which resides in one such working buffer and uses
+ *	another for data storage.)
+ *
+ * @todo Resolve the ambiguity about what the "debug_execution" flag
+ * signifies.  For example, Target implementations don't agree on how
+ * it relates to invalidation of the register cache, or to whether
+ * breakpoints and watchpoints should be enabled.  (It would seem wrong
+ * to enable breakpoints when running downloaded "helper" algorithms
+ * (debug_execution true), since the breakpoints would be set to match
+ * target firmware being debugged, not the helper algorithm.... and
+ * enabling them could cause such helpers to malfunction (for example,
+ * by overwriting data with a breakpoint instruction.  On the other
+ * hand the infrastructure for running such helpers might use this
+ * procedure but rely on hardware breakpoint to detect termination.)
+ */
 int target_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	int retval;
@@ -435,9 +465,9 @@ int target_resume(struct target *target, int current, uint32_t address, int hand
 		return ERROR_FAIL;
 	}
 
-	/* note that resume *must* be asynchronous. The CPU can halt before we poll. The CPU can
-	 * even halt at the current PC as a result of a software breakpoint being inserted by (a bug?)
-	 * the application.
+	/* note that resume *must* be asynchronous. The CPU can halt before
+	 * we poll. The CPU can even halt at the current PC as a result of
+	 * a software breakpoint being inserted by (a bug?) the application.
 	 */
 	if ((retval = target->type->resume(target, current, address, handle_breakpoints, debug_execution)) != ERROR_OK)
 		return retval;

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |   36 +++++++++++++++++++++++++++++++++---
 1 files changed, 33 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Mar  3 07:55:41 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed,  3 Mar 2010 06:55:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-49-g381ce43
Message-ID: <E1NmiUg-000528-GV@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  381ce4308c60c54e3a03d97e883302909b834875 (commit)
       via  61ee632dbc4dce5f4ce6f6dac537f488595917b9 (commit)
       via  24b1426a728f2bac1b3828069fa13af2be6d9e94 (commit)
       via  db6c994642f29b7d47abb4233494a606fbb65369 (commit)
      from  d72e90ae4b070cc08799e800c111dd422ac6b1a4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 381ce4308c60c54e3a03d97e883302909b834875
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 2 22:49:36 2010 -0800

    ADIv5: use new DAP ops for AP read/write
    
    Make ADIv5 internals use the two new transport-neutral calls for reading
    and writing DP registers; and do the same for external callers.  Also,
    bugfix some of their call sites to handle the fault returns, instead of
    ignoring them.
    
    Remove most of the JTAG-specific calls, using their code as the bodies
    of the JTAG-specific implementation for the new methods.
    
    NOTE that there's a remaining issue:  mem_ap_read_buf_u32() makes calls
    which are JTAG-specific.  A later patch will need to remove those, so
    JTAG-specific operations can be removed from this file, and so that SWD
    support will be able to properly drop in as just a transport layer to the
    ADIv5 infrastructure.  (The way read results are posted may need some more
    attention in the transport-neutrality interface.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 2d9ea0d..c5e0dd3 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -328,8 +328,16 @@ static int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 
 			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
 
-			dap_ap_read_reg_u32(swjdp, AP_REG_CSW, &mem_ap_csw);
-			dap_ap_read_reg_u32(swjdp, AP_REG_TAR, &mem_ap_tar);
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_CSW, &mem_ap_csw);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_TAR, &mem_ap_tar);
+			if (retval != ERROR_OK)
+				return retval;
+
 			if ((retval = dap_run(swjdp)) != ERROR_OK)
 				return retval;
 			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
@@ -375,79 +383,6 @@ void dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
 	}
 }
 
-/** Select the AP register bank matching bits 7:4 of ap_reg. */
-static int dap_ap_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
-{
-	uint32_t select = (ap_reg & 0x000000F0);
-
-	if (select != swjdp->ap_bank_value)
-	{
-		swjdp->ap_bank_value = select;
-		select |= swjdp->apsel;
-		return dap_queue_dp_write(swjdp, DP_SELECT, select);
-	} else
-		return ERROR_OK;
-}
-
-/* FIXME remove dap_ap_{read,write}_reg() and dap_ap_write_reg_u32()
- * ... these should become the bodies of the JTAG implementations of
- * dap_queue_ap_{read,write}(), then all their current callers should
- * switch over to the transport-neutral calls.
- */
-
-static int dap_ap_write_reg(struct swjdp_common *swjdp,
-		uint32_t reg_addr, uint8_t *out_value_buf)
-{
-	int retval;
-
-	retval = dap_ap_bankselect(swjdp, reg_addr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return adi_jtag_ap_write_check(swjdp, reg_addr, out_value_buf);
-}
-
-/**
- * Asynchronous (queued) AP register write.
- *
- * @param swjdp The DAP whose currently selected AP will be written.
- * @param reg_addr Eight bit AP register address.
- * @param value Word to be written at reg_addr
- *
- * @return ERROR_OK if the transaction was properly queued, else a fault code.
- */
-int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
-		uint32_t reg_addr, uint32_t value)
-{
-	uint8_t out_value_buf[4];
-
-	buf_set_u32(out_value_buf, 0, 32, value);
-	return dap_ap_write_reg(swjdp,
-			reg_addr, out_value_buf);
-}
-
-/**
- * Asynchronous (queued) AP register eread.
- *
- * @param swjdp The DAP whose currently selected AP will be read.
- * @param reg_addr Eight bit AP register address.
- * @param value Points to where the 32-bit (little-endian) word will be stored.
- *
- * @return ERROR_OK if the transaction was properly queued, else a fault code.
- */
-int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
-		uint32_t reg_addr, uint32_t *value)
-{
-	int retval;
-
-	retval = dap_ap_bankselect(swjdp, reg_addr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_READ, 0, value);
-}
-
 /**
  * Queue transactions setting up transfer parameters for the
  * currently selected MEM-AP.
@@ -475,7 +410,7 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 	if (csw != swjdp->ap_csw_value)
 	{
 		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
-		retval = dap_ap_write_reg_u32(swjdp, AP_REG_CSW, csw);
+		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
 		if (retval != ERROR_OK)
 			return retval;
 		swjdp->ap_csw_value = csw;
@@ -483,7 +418,7 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 	if (tar != swjdp->ap_tar_value)
 	{
 		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
-		retval = dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar);
+		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
 		if (retval != ERROR_OK)
 			return retval;
 		swjdp->ap_tar_value = tar;
@@ -518,7 +453,7 @@ int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC), value);
+	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address & 0xC), value);
 }
 
 /**
@@ -569,7 +504,7 @@ int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC),
+	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address & 0xC),
 			value);
 }
 
@@ -645,7 +580,10 @@ int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 
 		for (writecount = 0; writecount < blocksize; writecount++)
 		{
-			dap_ap_write_reg(swjdp, AP_REG_DRW, buffer + 4 * writecount);
+			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
+				*(uint32_t *) (buffer + 4 * writecount));
+			if (retval != ERROR_OK)
+				break;
 		}
 
 		if (dap_run(swjdp) == ERROR_OK)
@@ -725,7 +663,11 @@ static int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp,
 				}
 
 				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
+				retval = dap_queue_ap_write(swjdp,
+						AP_REG_DRW, outvalue);
+				if (retval != ERROR_OK)
+					break;
+
 				if (dap_run(swjdp) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
@@ -759,7 +701,10 @@ int mem_ap_write_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 		uint16_t svalue;
 		memcpy(&svalue, buffer, sizeof(uint16_t));
 		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
-		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
+		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		if (retval != ERROR_OK)
+			break;
+
 		retval = dap_run(swjdp);
 		if (retval != ERROR_OK)
 			break;
@@ -822,7 +767,11 @@ static int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp,
 				}
 
 				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
+				retval = dap_queue_ap_write(swjdp,
+						AP_REG_DRW, outvalue);
+				if (retval != ERROR_OK)
+					break;
+
 				if (dap_run(swjdp) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
@@ -854,7 +803,10 @@ int mem_ap_write_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
 		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
-		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
+		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		if (retval != ERROR_OK)
+			break;
+
 		retval = dap_run(swjdp);
 		if (retval != ERROR_OK)
 			break;
@@ -903,6 +855,13 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer,
 		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
 				address);
 
+		/* FIXME remove these three calls to adi_jtag_dp_scan(),
+		 * so this routine becomes transport-neutral.  Be careful
+		 * not to cause performance problems with JTAG; would it
+		 * suffice to loop over dap_queue_ap_read(), or would that
+		 * be slower when JTAG is the chosen transport?
+		 */
+
 		/* Scan out first read */
 		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
 				DPAP_READ, 0, NULL, NULL);
@@ -992,7 +951,7 @@ static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
 
 		do
 		{
-			dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
+			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
 			if (dap_run(swjdp) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
@@ -1037,7 +996,10 @@ int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer,
 	while (count > 0)
 	{
 		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
+		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+		if (retval != ERROR_OK)
+			break;
+
 		retval = dap_run(swjdp);
 		if (retval != ERROR_OK)
 			break;
@@ -1094,7 +1056,7 @@ static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
 
 		do
 		{
-			dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
+			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
 			if (dap_run(swjdp) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
@@ -1139,7 +1101,7 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer,
 	while (count > 0)
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
+		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
 		retval = dap_run(swjdp);
 		if (retval != ERROR_OK)
 			break;
@@ -1199,6 +1161,7 @@ static int jtag_dp_q_write(struct swjdp_common *dap, unsigned reg,
 			reg, DPAP_WRITE, data, NULL);
 }
 
+/** Select the AP register bank matching bits 7:4 of reg. */
 static int jtag_ap_q_bankselect(struct swjdp_common *dap, unsigned reg)
 {
 	uint32_t select = reg & 0x000000F0;
@@ -1219,17 +1182,23 @@ static int jtag_ap_q_read(struct swjdp_common *dap, unsigned reg,
 
 	if (retval != ERROR_OK)
 		return retval;
-	return dap_ap_read_reg_u32(dap, reg, data);
+
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
+			DPAP_READ, 0, data);
 }
 
 static int jtag_ap_q_write(struct swjdp_common *dap, unsigned reg,
 		uint32_t data)
 {
-	int retval = jtag_ap_q_bankselect(dap, reg);
+	uint8_t out_value_buf[4];
 
+	int retval = jtag_ap_q_bankselect(dap, reg);
 	if (retval != ERROR_OK)
 		return retval;
-	return dap_ap_write_reg_u32(dap, reg, data);
+
+	buf_set_u32(out_value_buf, 0, 32, data);
+
+	return adi_jtag_ap_write_check(dap, reg, out_value_buf);
 }
 
 static int jtag_ap_q_abort(struct swjdp_common *dap, uint8_t *ack)
@@ -1355,8 +1324,8 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	 * Should it?  If the ROM address is valid, is this the right
 	 * place to scan the table and do any topology detection?
 	 */
-	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &idreg);
-	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &romaddr);
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &idreg);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &romaddr);
 
 	LOG_DEBUG("MEM-AP #%d ID Register 0x%" PRIx32
 		", Debug ROM Address 0x%" PRIx32,
@@ -1398,8 +1367,8 @@ int dap_info_command(struct command_context *cmd_ctx,
 
 	apselold = swjdp->apsel;
 	dap_ap_select(swjdp, apsel);
-	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &dbgbase);
-	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &apid);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &dbgbase);
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
 	retval = dap_run(swjdp);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1770,7 +1739,7 @@ DAP_COMMAND_HANDLER(dap_baseaddr_command)
 	 * though they're not common for now.  This should
 	 * use the ID register to verify it's a MEM-AP.
 	 */
-	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &baseaddr);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &baseaddr);
 	retval = dap_run(swjdp);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1825,7 +1794,7 @@ DAP_COMMAND_HANDLER(dap_apsel_command)
 	}
 
 	dap_ap_select(swjdp, apsel);
-	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &apid);
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
 	retval = dap_run(swjdp);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1859,7 +1828,7 @@ DAP_COMMAND_HANDLER(dap_apid_command)
 	if (apselsave != apsel)
 		dap_ap_select(swjdp, apsel);
 
-	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &apid);
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
 	retval = dap_run(swjdp);
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index e71feb9..e867b85 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -350,10 +350,6 @@ void dap_ap_select(struct swjdp_common *dap,uint8_t apsel);
 /* Queued AP transactions */
 int dap_setup_accessport(struct swjdp_common *swjdp,
 		uint32_t csw, uint32_t tar);
-int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
-		uint32_t addr, uint32_t value);
-int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
-		uint32_t addr, uint32_t *value);
 
 /* Queued MEM-AP memory mapped single word transfers */
 int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t *value);
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 7aec015..3178ce3 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -72,13 +72,19 @@ static int cortexm3_dap_read_coreregister_u32(struct swjdp_common *swjdp,
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, regnum); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
-	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum);
+	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* mem_ap_read_u32(swjdp, DCB_DCRDR, value); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
-	dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
+	if (retval != ERROR_OK)
+		return retval;
 
 	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* restore DCB_DCRDR - this needs to be in a seperate
 	 * transaction otherwise the emulated DCC channel breaks */
@@ -101,11 +107,13 @@ static int cortexm3_dap_write_coreregister_u32(struct swjdp_common *swjdp,
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRDR, core_regs[i]); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
-	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
+	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
+	// XXX check retval
 
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, i | DCRSR_WnR); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
-	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum | DCRSR_WnR);
+	retval = dap_queue_ap_write(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum | DCRSR_WnR);
+	// XXX check retval
 
 	retval = dap_run(swjdp);
 

commit 61ee632dbc4dce5f4ce6f6dac537f488595917b9
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 2 22:46:38 2010 -0800

    ADIv5: use new DAP ops for DP read/write
    
    Make ADIv5 internals use the two new transport-neutral calls for reading
    and writing DP registers.  Also,  bugfix some of their call sites to
    handle the fault returns, instead of ignoring them.
    
    Remove the old JTAG-specific calls, using their code as the bodies
    of the JTAG-specific implementation for the new methods.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index daabd8b..2d9ea0d 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -350,25 +350,6 @@ static int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
  *                                                                         *
 ***************************************************************************/
 
-/* FIXME remove dap_dp_{read,write}_reg() ... these should become the
- * bodies of the JTAG implementations of dap_queue_dp_{read,write}() and
- * callers should switch over to the transport-neutral calls.
- */
-
-static int dap_dp_write_reg(struct swjdp_common *swjdp,
-		uint32_t value, uint8_t reg_addr)
-{
-	return adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			reg_addr, DPAP_WRITE, value, NULL);
-}
-
-static int dap_dp_read_reg(struct swjdp_common *swjdp,
-		uint32_t *value, uint8_t reg_addr)
-{
-	return adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			reg_addr, DPAP_READ, 0, value);
-}
-
 /**
  * Select one of the APs connected to the specified DAP.  The
  * selection is implicitly used with future AP transactions.
@@ -403,7 +384,7 @@ static int dap_ap_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 	{
 		swjdp->ap_bank_value = select;
 		select |= swjdp->apsel;
-		return dap_dp_write_reg(swjdp, select, DP_SELECT);
+		return dap_queue_dp_write(swjdp, DP_SELECT, select);
 	} else
 		return ERROR_OK;
 }
@@ -1207,13 +1188,15 @@ static int jtag_idcode_q_read(struct swjdp_common *dap,
 static int jtag_dp_q_read(struct swjdp_common *dap, unsigned reg,
 		uint32_t *data)
 {
-	return dap_dp_read_reg(dap, data, reg);
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_READ, 0, data);
 }
 
 static int jtag_dp_q_write(struct swjdp_common *dap, unsigned reg,
 		uint32_t data)
 {
-	return dap_dp_write_reg(dap, data, reg);
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_WRITE, data, NULL);
 }
 
 static int jtag_ap_q_bankselect(struct swjdp_common *dap, unsigned reg)
@@ -1307,14 +1290,27 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	dap_ap_select(swjdp, 0);
 
 	/* DP initialization */
-	dap_dp_read_reg(swjdp, &dummy, DP_CTRL_STAT);
-	dap_dp_write_reg(swjdp, SSTICKYERR, DP_CTRL_STAT);
-	dap_dp_read_reg(swjdp, &dummy, DP_CTRL_STAT);
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
 
 	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
 
-	dap_dp_write_reg(swjdp, swjdp->dp_ctrl_stat, DP_CTRL_STAT);
-	dap_dp_read_reg(swjdp, &ctrlstat, DP_CTRL_STAT);
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+	if (retval != ERROR_OK)
+		return retval;
 	if ((retval = dap_run(swjdp)) != ERROR_OK)
 		return retval;
 
@@ -1322,7 +1318,9 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	while (!(ctrlstat & CDBGPWRUPACK) && (cnt++ < 10))
 	{
 		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
-		dap_dp_read_reg(swjdp, &ctrlstat, DP_CTRL_STAT);
+		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		if (retval != ERROR_OK)
+			return retval;
 		if ((retval = dap_run(swjdp)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
@@ -1331,17 +1329,25 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	while (!(ctrlstat & CSYSPWRUPACK) && (cnt++ < 10))
 	{
 		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
-		dap_dp_read_reg(swjdp, &ctrlstat, DP_CTRL_STAT);
+		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		if (retval != ERROR_OK)
+			return retval;
 		if ((retval = dap_run(swjdp)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
 
-	dap_dp_read_reg(swjdp, &dummy, DP_CTRL_STAT);
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
 	/* With debug power on we can activate OVERRUN checking */
 	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	dap_dp_write_reg(swjdp, swjdp->dp_ctrl_stat, DP_CTRL_STAT);
-	dap_dp_read_reg(swjdp, &dummy, DP_CTRL_STAT);
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/*
 	 * REVISIT this isn't actually *initializing* anything in an AP,

commit 24b1426a728f2bac1b3828069fa13af2be6d9e94
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 2 22:42:45 2010 -0800

    ADIv5: use new dap_run() operation
    
    Make ADIv5 use one of the new transport-neutral interfaces: call
    dap_run(), not jtagdp_transaction_endcheck().
    
    Also, make that old interface private; and bugfix some of its call
    sites to handle the fault returns, instead of ignoring them.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 735308a..daabd8b 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -213,7 +213,7 @@ static int adi_jtag_scan_inout_check_u32(struct swjdp_common *swjdp,
 	return retval;
 }
 
-int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
+static int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 {
 	int retval;
 	uint32_t ctrlstat;
@@ -277,7 +277,7 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 
 			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = jtag_execute_queue()) != ERROR_OK)
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
 				return retval;
 			swjdp->ack = swjdp->ack & 0x7;
 		}
@@ -323,20 +323,20 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 						| SSTICKYERR, NULL);
 			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = jtag_execute_queue()) != ERROR_OK)
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
 				return retval;
 
 			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
 
 			dap_ap_read_reg_u32(swjdp, AP_REG_CSW, &mem_ap_csw);
 			dap_ap_read_reg_u32(swjdp, AP_REG_TAR, &mem_ap_tar);
-			if ((retval = jtag_execute_queue()) != ERROR_OK)
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
 				return retval;
 			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
 					PRIx32, mem_ap_csw, mem_ap_tar);
 
 		}
-		if ((retval = jtag_execute_queue()) != ERROR_OK)
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
 			return retval;
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
@@ -561,7 +561,7 @@ int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return jtagdp_transaction_endcheck(swjdp);
+	return dap_run(swjdp);
 }
 
 /**
@@ -611,7 +611,7 @@ int mem_ap_write_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return jtagdp_transaction_endcheck(swjdp);
+	return dap_run(swjdp);
 }
 
 /*****************************************************************************
@@ -667,7 +667,7 @@ int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 			dap_ap_write_reg(swjdp, AP_REG_DRW, buffer + 4 * writecount);
 		}
 
-		if (jtagdp_transaction_endcheck(swjdp) == ERROR_OK)
+		if (dap_run(swjdp) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address = address + 4 * blocksize;
@@ -681,6 +681,7 @@ int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 		if (errorcount > 1)
 		{
 			LOG_WARNING("Block write error address 0x%" PRIx32 ", wcount 0x%x", address, wcount);
+			/* REVISIT return the *actual* fault code */
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
@@ -744,11 +745,12 @@ static int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp,
 
 				memcpy(&outvalue, buffer, sizeof(uint32_t));
 				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
-				if (jtagdp_transaction_endcheck(swjdp) != ERROR_OK)
+				if (dap_run(swjdp) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
 						address, count);
+					/* REVISIT return *actual* fault code */
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
 			}
@@ -777,7 +779,10 @@ int mem_ap_write_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 		memcpy(&svalue, buffer, sizeof(uint16_t));
 		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
 		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
-		retval = jtagdp_transaction_endcheck(swjdp);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
 		count -= 2;
 		address += 2;
 		buffer += 2;
@@ -837,11 +842,12 @@ static int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp,
 
 				memcpy(&outvalue, buffer, sizeof(uint32_t));
 				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
-				if (jtagdp_transaction_endcheck(swjdp) != ERROR_OK)
+				if (dap_run(swjdp) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
 						address, count);
+					/* REVISIT return *actual* fault code */
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
 			}
@@ -868,7 +874,10 @@ int mem_ap_write_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
 		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
 		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
-		retval = jtagdp_transaction_endcheck(swjdp);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
 		count--;
 		address++;
 		buffer++;
@@ -933,7 +942,7 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer,
 		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
 				DPAP_READ, 0, buffer + 4 * readcount,
 				&swjdp->ack);
-		if (jtagdp_transaction_endcheck(swjdp) == ERROR_OK)
+		if (dap_run(swjdp) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address += 4 * blocksize;
@@ -948,6 +957,7 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer,
 		{
 			LOG_WARNING("Block read error address 0x%" PRIx32
 				", count 0x%x", address, count);
+			/* REVISIT return the *actual* fault code */
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
@@ -1002,9 +1012,10 @@ static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
 		do
 		{
 			dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
-			if (jtagdp_transaction_endcheck(swjdp) != ERROR_OK)
+			if (dap_run(swjdp) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
+				/* REVISIT return the *actual* fault code */
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
@@ -1046,7 +1057,10 @@ int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer,
 	{
 		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
 		dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
-		retval = jtagdp_transaction_endcheck(swjdp);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
 		if (address & 0x1)
 		{
 			for (i = 0; i < 2; i++)
@@ -1100,9 +1114,10 @@ static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
 		do
 		{
 			dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
-			if (jtagdp_transaction_endcheck(swjdp) != ERROR_OK)
+			if (dap_run(swjdp) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
+				/* REVISIT return the *actual* fault code */
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
@@ -1144,7 +1159,10 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer,
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
 		dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &invalue);
-		retval = jtagdp_transaction_endcheck(swjdp);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
 		*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
 		count--;
 		address++;
@@ -1297,7 +1315,7 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 
 	dap_dp_write_reg(swjdp, swjdp->dp_ctrl_stat, DP_CTRL_STAT);
 	dap_dp_read_reg(swjdp, &ctrlstat, DP_CTRL_STAT);
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	if ((retval = dap_run(swjdp)) != ERROR_OK)
 		return retval;
 
 	/* Check that we have debug power domains activated */
@@ -1305,7 +1323,7 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	{
 		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
 		dap_dp_read_reg(swjdp, &ctrlstat, DP_CTRL_STAT);
-		if ((retval = jtag_execute_queue()) != ERROR_OK)
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
@@ -1314,7 +1332,7 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	{
 		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
 		dap_dp_read_reg(swjdp, &ctrlstat, DP_CTRL_STAT);
-		if ((retval = jtag_execute_queue()) != ERROR_OK)
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
@@ -1362,7 +1380,7 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 int dap_info_command(struct command_context *cmd_ctx,
 		struct swjdp_common *swjdp, int apsel)
 {
-
+	int retval;
 	uint32_t dbgbase, apid;
 	int romtable_present = 0;
 	uint8_t mem_ap;
@@ -1376,7 +1394,10 @@ int dap_info_command(struct command_context *cmd_ctx,
 	dap_ap_select(swjdp, apsel);
 	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &dbgbase);
 	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &apid);
-	jtagdp_transaction_endcheck(swjdp);
+	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
 	mem_ap = ((apid&0x10000) && ((apid&0x0F) != 0));
 	command_print(cmd_ctx, "AP ID register 0x%8.8" PRIx32, apid);
@@ -1428,7 +1449,10 @@ int dap_info_command(struct command_context *cmd_ctx,
 		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
 		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
 		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
-		jtagdp_transaction_endcheck(swjdp);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			return retval;
+
 		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
 			command_print(cmd_ctx, "\tCID3 0x%2.2" PRIx32
 					", CID2 0x%2.2" PRIx32
@@ -1741,7 +1765,10 @@ DAP_COMMAND_HANDLER(dap_baseaddr_command)
 	 * use the ID register to verify it's a MEM-AP.
 	 */
 	dap_ap_read_reg_u32(swjdp, AP_REG_BASE, &baseaddr);
-	retval = jtagdp_transaction_endcheck(swjdp);
+	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
 	command_print(CMD_CTX, "0x%8.8" PRIx32, baseaddr);
 
 	if (apselsave != apsel)
@@ -1793,7 +1820,10 @@ DAP_COMMAND_HANDLER(dap_apsel_command)
 
 	dap_ap_select(swjdp, apsel);
 	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &apid);
-	retval = jtagdp_transaction_endcheck(swjdp);
+	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
 	command_print(CMD_CTX, "ap %" PRIi32 " selected, identification register 0x%8.8" PRIx32,
 			apsel, apid);
 
@@ -1824,7 +1854,10 @@ DAP_COMMAND_HANDLER(dap_apid_command)
 		dap_ap_select(swjdp, apsel);
 
 	dap_ap_read_reg_u32(swjdp, AP_REG_IDR, &apid);
-	retval = jtagdp_transaction_endcheck(swjdp);
+	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
 	command_print(CMD_CTX, "0x%8.8" PRIx32, apid);
 	if (apselsave != apsel)
 		dap_ap_select(swjdp, apselsave);
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index ec4a179..e71feb9 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -355,9 +355,6 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 		uint32_t addr, uint32_t *value);
 
-/* Queued JTAG ops must be completed with jtagdp_transaction_endcheck() */
-int jtagdp_transaction_endcheck(struct swjdp_common *swjdp);
-
 /* Queued MEM-AP memory mapped single word transfers */
 int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t *value);
 int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t value);
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index aecf371..7aec015 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -78,7 +78,7 @@ static int cortexm3_dap_read_coreregister_u32(struct swjdp_common *swjdp,
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
 	dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
 
-	retval = jtagdp_transaction_endcheck(swjdp);
+	retval = dap_run(swjdp);
 
 	/* restore DCB_DCRDR - this needs to be in a seperate
 	 * transaction otherwise the emulated DCC channel breaks */
@@ -107,7 +107,7 @@ static int cortexm3_dap_write_coreregister_u32(struct swjdp_common *swjdp,
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
 	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum | DCRSR_WnR);
 
-	retval = jtagdp_transaction_endcheck(swjdp);
+	retval = dap_run(swjdp);
 
 	/* restore DCB_DCRDR - this needs to be in a seperate
 	 * transaction otherwise the emulated DCC channel breaks */
@@ -179,6 +179,7 @@ static int cortex_m3_single_step_core(struct target *target)
 static int cortex_m3_endreset_event(struct target *target)
 {
 	int i;
+	int retval;
 	uint32_t dcb_demcr;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
@@ -234,14 +235,16 @@ static int cortex_m3_endreset_event(struct target *target)
 		target_write_u32(target, dwt_list[i].dwt_comparator_address + 8,
 				dwt_list[i].function);
 	}
-	jtagdp_transaction_endcheck(swjdp);
+	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
 
 	register_cache_invalidate(cortex_m3->armv7m.core_cache);
 
 	/* make sure we have latest dhcsr flags */
 	mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
 
-	return ERROR_OK;
+	return retval;
 }
 
 static int cortex_m3_examine_debug_reason(struct target *target)
@@ -276,6 +279,7 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 	uint32_t shcsr, except_sr, cfsr = -1, except_ar = -1;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	int retval;
 
 	mem_ap_read_u32(swjdp, NVIC_SHCSR, &shcsr);
 	switch (armv7m->exception_number)
@@ -313,10 +317,13 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 			except_sr = 0;
 			break;
 	}
-	jtagdp_transaction_endcheck(swjdp);
-	LOG_DEBUG("%s SHCSR 0x%" PRIx32 ", SR 0x%" PRIx32 ", CFSR 0x%" PRIx32 ", AR 0x%" PRIx32 "", armv7m_exception_string(armv7m->exception_number), \
-		shcsr, except_sr, cfsr, except_ar);
-	return ERROR_OK;
+	retval = dap_run(swjdp);
+	if (retval == ERROR_OK)
+		LOG_DEBUG("%s SHCSR 0x%" PRIx32 ", SR 0x%" PRIx32
+			", CFSR 0x%" PRIx32 ", AR 0x%" PRIx32,
+			armv7m_exception_string(armv7m->exception_number),
+			shcsr, except_sr, cfsr, except_ar);
+	return retval;
 }
 
 /* PSP is used in some thread modes */

commit db6c994642f29b7d47abb4233494a606fbb65369
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 2 22:41:59 2010 -0800

    ARM: start abstracting ADIv5 transports (JTAG/SWD)
    
    To support both JTAG and SWD, ADIv5 needs DAP operations which are
    transport-neutral, instead being of JTAG-specific.  This patch:
    
     - Defines such a transport-neutral interface, abstracting access
       to DP and AP registers through a conceptual queue of operations.
    
     - Builds the first implementation of such a transport with the existing
       JTAG-specific code.
    
    In contrast to the current JTAG-only interface, the interface adds
    support for two previously-missing (and unused) DAP operations:
    
     - aborting the current AP transaction (untested);
     - reading the IDCODE register (tested) ... required for SWD init.
    
    The choice of transports may be fixed at the chip, board, or JTAG/SWD
    adapter level.  Or if all the relevant hardware supports both transport
    options, the choice may be made at runtime, This patch provides basic
    infrastructure to support whichever choice is made.
    
    The current "JTAG-only" transport choice policy will necessarily continue
    for now, until SWD support becomes available in OpenOCD.  Later patches
    start phasing out JTAG-specific calls in favor of transport-neutral calls.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 115ccf1..735308a 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -350,6 +350,11 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
  *                                                                         *
 ***************************************************************************/
 
+/* FIXME remove dap_dp_{read,write}_reg() ... these should become the
+ * bodies of the JTAG implementations of dap_queue_dp_{read,write}() and
+ * callers should switch over to the transport-neutral calls.
+ */
+
 static int dap_dp_write_reg(struct swjdp_common *swjdp,
 		uint32_t value, uint8_t reg_addr)
 {
@@ -403,6 +408,12 @@ static int dap_ap_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 		return ERROR_OK;
 }
 
+/* FIXME remove dap_ap_{read,write}_reg() and dap_ap_write_reg_u32()
+ * ... these should become the bodies of the JTAG implementations of
+ * dap_queue_ap_{read,write}(), then all their current callers should
+ * switch over to the transport-neutral calls.
+ */
+
 static int dap_ap_write_reg(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint8_t *out_value_buf)
 {
@@ -1143,6 +1154,107 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer,
 	return retval;
 }
 
+/*--------------------------------------------------------------------------*/
+
+static int jtag_idcode_q_read(struct swjdp_common *dap,
+		uint8_t *ack, uint32_t *data)
+{
+	struct arm_jtag *jtag_info = dap->jtag_info;
+	int retval;
+	struct scan_field fields[1];
+
+	jtag_set_end_state(TAP_IDLE);
+
+	/* This is a standard JTAG operation -- no DAP tweakage */
+	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	fields[0].tap = jtag_info->tap;
+	fields[0].num_bits = 32;
+	fields[0].out_value = NULL;
+	fields[0].in_value = (void *) data;
+
+	jtag_add_dr_scan(1, fields, jtag_get_end_state());
+	retval = jtag_get_error();
+	if (retval != ERROR_OK)
+		return retval;
+
+	jtag_add_callback(arm_le_to_h_u32,
+			(jtag_callback_data_t) data);
+
+	return retval;
+}
+
+static int jtag_dp_q_read(struct swjdp_common *dap, unsigned reg,
+		uint32_t *data)
+{
+	return dap_dp_read_reg(dap, data, reg);
+}
+
+static int jtag_dp_q_write(struct swjdp_common *dap, unsigned reg,
+		uint32_t data)
+{
+	return dap_dp_write_reg(dap, data, reg);
+}
+
+static int jtag_ap_q_bankselect(struct swjdp_common *dap, unsigned reg)
+{
+	uint32_t select = reg & 0x000000F0;
+
+	if (select == dap->ap_bank_value)
+		return ERROR_OK;
+	dap->ap_bank_value = select;
+
+	select |= dap->apsel;
+
+	return jtag_dp_q_write(dap, DP_SELECT, select);
+}
+
+static int jtag_ap_q_read(struct swjdp_common *dap, unsigned reg,
+		uint32_t *data)
+{
+	int retval = jtag_ap_q_bankselect(dap, reg);
+
+	if (retval != ERROR_OK)
+		return retval;
+	return dap_ap_read_reg_u32(dap, reg, data);
+}
+
+static int jtag_ap_q_write(struct swjdp_common *dap, unsigned reg,
+		uint32_t data)
+{
+	int retval = jtag_ap_q_bankselect(dap, reg);
+
+	if (retval != ERROR_OK)
+		return retval;
+	return dap_ap_write_reg_u32(dap, reg, data);
+}
+
+static int jtag_ap_q_abort(struct swjdp_common *dap, uint8_t *ack)
+{
+	/* for JTAG, this is the only valid ABORT register operation */
+	return adi_jtag_dp_scan_u32(dap, JTAG_DP_ABORT,
+			0, DPAP_WRITE, 1, NULL, ack);
+}
+
+static int jtag_dp_run(struct swjdp_common *dap)
+{
+	return jtagdp_transaction_endcheck(dap);
+}
+
+static const struct dap_ops jtag_dp_ops = {
+	.queue_idcode_read =	jtag_idcode_q_read,
+	.queue_dp_read =	jtag_dp_q_read,
+	.queue_dp_write =	jtag_dp_q_write,
+	.queue_ap_read =	jtag_ap_q_read,
+	.queue_ap_write =	jtag_ap_q_write,
+	.queue_ap_abort =	jtag_ap_q_abort,
+	.run =			jtag_dp_run,
+};
+
+/*--------------------------------------------------------------------------*/
+
 /**
  * Initialize a DAP.  This sets up the power domains, prepares the DP
  * for further use, and arranges to use AP #0 for all AP operations
@@ -1164,6 +1276,9 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 
 	LOG_DEBUG(" ");
 
+	/* JTAG-DP or SWJ-DP, in JTAG mode */
+	swjdp->ops = &jtag_dp_ops;
+
 	/* Default MEM-AP setup.
 	 *
 	 * REVISIT AP #0 may be an inappropriate default for this.
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 5c5ca4f..ec4a179 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -124,10 +124,22 @@
  * transport agent; and at least one Access Port (AP), controlling
  * resource access.  Most common is a MEM-AP, for memory access.
  *
+ * There are two basic DP transports: JTAG, and ARM's low pin-count SWD.
+ * Accordingly, this interface is responsible for hiding the transport
+ * differences so upper layer code can largely ignore them.
+ *
+ * When the chip is implemented with JTAG-DP or SW-DP, the transport is
+ * fixed as JTAG or SWD, respectively.  Chips incorporating SWJ-DP permit
+ * a choice made at board design time (by only using the SWD pins), or
+ * as part of setting up a debug session (if all the dual-role JTAG/SWD
+ * signals are available).
+ *
  * @todo Rename "swjdp_common" as "dap".  Use of SWJ-DP is optional!
  */
 struct swjdp_common
 {
+	const struct dap_ops *ops;
+
 	struct arm_jtag *jtag_info;
 	/* Control config */
 	uint32_t dp_ctrl_stat;
@@ -175,6 +187,157 @@ struct swjdp_common
 
 };
 
+/**
+ * Transport-neutral representation of queued DAP transactions, supporting
+ * both JTAG and SWD transports.  All submitted transactions are logically
+ * queued, until the queue is executed by run().  Some implementations might
+ * execute transactions as soon as they're submitted, but no status is made
+ * availablue until run().
+ */
+struct dap_ops {
+	/** If the DAP transport isn't SWD, it must be JTAG.  Upper level
+	 * code may need to care about the difference in some cases.
+	 */
+	bool	is_swd;
+
+	/** Reads the DAP's IDCODe register. */
+	int (*queue_idcode_read)(struct swjdp_common *dap,
+			uint8_t *ack, uint32_t *data);
+
+	/** DP register read. */
+	int (*queue_dp_read)(struct swjdp_common *dap, unsigned reg,
+			uint32_t *data);
+	/** DP register write. */
+	int (*queue_dp_write)(struct swjdp_common *dap, unsigned reg,
+			uint32_t data);
+
+	/** AP register read. */
+	int (*queue_ap_read)(struct swjdp_common *dap, unsigned reg,
+			uint32_t *data);
+	/** AP register write. */
+	int (*queue_ap_write)(struct swjdp_common *dap, unsigned reg,
+			uint32_t data);
+	/** AP operation abort. */
+	int (*queue_ap_abort)(struct swjdp_common *dap, uint8_t *ack);
+
+	/** Executes all queued DAP operations. */
+	int (*run)(struct swjdp_common *dap);
+};
+
+/**
+ * Queue an IDCODE register read.  This is primarily useful for SWD
+ * transports, where it is required as part of link initialization.
+ * (For JTAG, this register is read as part of scan chain setup.)
+ *
+ * @param dap The DAP used for reading.
+ * @param ack Pointer to where transaction status will be stored.
+ * @param data Pointer saying where to store the IDCODE value.
+ *
+ * @return ERROR_OK for success, else a fault code.
+ */
+static inline int dap_queue_idcode_read(struct swjdp_common *dap,
+		uint8_t *ack, uint32_t *data)
+{
+	return dap->ops->queue_idcode_read(dap, ack, data);
+}
+
+/**
+ * Queue a DP register read.
+ * Note that not all DP registers are readable; also, that JTAG and SWD
+ * have slight differences in DP register support.
+ *
+ * @param dap The DAP used for reading.
+ * @param reg The two-bit number of the DP register being read.
+ * @param data Pointer saying where to store the register's value
+ * 	(in host endianness).
+ *
+ * @return ERROR_OK for success, else a fault code.
+ */
+static inline int dap_queue_dp_read(struct swjdp_common *dap,
+		unsigned reg, uint32_t *data)
+{
+	return dap->ops->queue_dp_read(dap, reg, data);
+}
+
+/**
+ * Queue a DP register write.
+ * Note that not all DP registers are writable; also, that JTAG and SWD
+ * have slight differences in DP register support.
+ *
+ * @param dap The DAP used for writing.
+ * @param reg The two-bit number of the DP register being written.
+ * @param data Value being written (host endianness)
+ *
+ * @return ERROR_OK for success, else a fault code.
+ */
+static inline int dap_queue_dp_write(struct swjdp_common *dap,
+		unsigned reg, uint32_t data)
+{
+	return dap->ops->queue_dp_write(dap, reg, data);
+}
+
+/**
+ * Queue an AP register read.
+ *
+ * @param dap The DAP used for reading.
+ * @param reg The number of the AP register being read.
+ * @param data Pointer saying where to store the register's value
+ * 	(in host endianness).
+ *
+ * @return ERROR_OK for success, else a fault code.
+ */
+static inline int dap_queue_ap_read(struct swjdp_common *dap,
+		unsigned reg, uint32_t *data)
+{
+	return dap->ops->queue_ap_read(dap, reg, data);
+}
+
+/**
+ * Queue an AP register write.
+ *
+ * @param dap The DAP used for writing.
+ * @param reg The number of the AP register being written.
+ * @param data Value being written (host endianness)
+ *
+ * @return ERROR_OK for success, else a fault code.
+ */
+static inline int dap_queue_ap_write(struct swjdp_common *dap,
+		unsigned reg, uint32_t data)
+{
+	return dap->ops->queue_ap_write(dap, reg, data);
+}
+
+/**
+ * Queue an AP abort operation.  The current AP transaction is aborted,
+ * including any update of the transaction counter.  The AP is left in
+ * an unknown state (so it must be re-initialized).  For use only after
+ * the AP has reported WAIT status for an extended period.
+ *
+ * @param dap The DAP used for writing.
+ * @param ack Pointer to where transaction status will be stored.
+ *
+ * @return ERROR_OK for success, else a fault code.
+ */
+static inline int dap_queue_ap_abort(struct swjdp_common *dap, uint8_t *ack)
+{
+	return dap->ops->queue_ap_abort(dap, ack);
+}
+
+/**
+ * Perform all queued DAP operations, and clear any errors posted in the
+ * CTRL_STAT register when they are done.  Note that if more than one AP
+ * operation will be queued, one of the first operations in the queue
+ * should probably enable CORUNDETECT in the CTRL/STAT register.
+ *
+ * @param dap The DAP used.
+ *
+ * @return ERROR_OK for success, else a fault code.
+ */
+static inline int dap_run(struct swjdp_common *dap)
+{
+	return dap->ops->run(dap);
+}
+
 /** Accessor for currently selected DAP-AP number (0..255) */
 static inline uint8_t dap_ap_get_select(struct swjdp_common *swjdp)
 {

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |  401 +++++++++++++++++++++++++++++++----------------
 src/target/arm_adi_v5.h |  170 +++++++++++++++++++-
 src/target/cortex_m3.c  |   39 +++--
 3 files changed, 452 insertions(+), 158 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Mar  3 11:22:48 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed,  3 Mar 2010 10:22:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-50-g2119c0a
Message-ID: <E1Nmlj7-0007GC-Un@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2119c0a7641d05ad8b6b8feb64d4c315716f6d3a (commit)
      from  381ce4308c60c54e3a03d97e883302909b834875 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2119c0a7641d05ad8b6b8feb64d4c315716f6d3a
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Mar 3 10:20:37 2010 +0000

    STM32: Add Value Line Flash Programming Support
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 53fc4ea..ebdcde7 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -743,6 +743,21 @@ static int stm32x_probe(struct flash_bank *bank)
 			num_pages = 256;
 		}
 	}
+	else if ((device_id & 0x7ff) == 0x420)
+	{
+		/* value line density - we have 1k pages
+		 * 4 pages for a protection area */
+		page_size = 1024;
+		stm32x_info->ppage_size = 4;
+
+		/* check for early silicon */
+		if (num_pages == 0xffff)
+		{
+			/* number of sectors may be incorrrect on early silicon */
+			LOG_WARNING("STM32 flash size failed, probe inaccurate - assuming 128k flash");
+			num_pages = 128;
+		}
+	}
 	else
 	{
 		LOG_WARNING("Cannot identify target as a STM32 family.");
@@ -884,6 +899,27 @@ static int stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 				break;
 		}
 	}
+	else if ((device_id & 0x7ff) == 0x420)
+	{
+		printed = snprintf(buf, buf_size, "stm32x (Value) - Rev: ");
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id >> 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, "A");
+				break;
+
+			case 0x1001:
+				snprintf(buf, buf_size, "Z");
+				break;
+
+			default:
+				snprintf(buf, buf_size, "unknown");
+				break;
+		}
+	}
 	else
 	{
 		snprintf(buf, buf_size, "Cannot identify target as a stm32x\n");

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stm32x.c |   36 ++++++++++++++++++++++++++++++++++++
 1 files changed, 36 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Mar  3 22:09:59 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed,  3 Mar 2010 21:09:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-51-g99939c3
Message-ID: <E1NmvpY-0008Tk-V1@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  99939c3c75f3bef44d4cd176e90a6c5fe8b833da (commit)
      from  2119c0a7641d05ad8b6b8feb64d4c315716f6d3a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 99939c3c75f3bef44d4cd176e90a6c5fe8b833da
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Mar 3 12:59:53 2010 -0800

    NOR: stellaris message tweaks
    
    Give a more accurate failure message when trying to unprotect; don't
    complain about pages being write protected, just say that unprotect is
    not supported by the hardware ... referencing the new "recover" command,
    which is the way to achieve that.
    
    Likewise, when trying to protect, talk about "pages" (matching hardware
    doc) not "sectors" (an concept that's alien to these chips).
    
    Also make the helptext for the "recover" command mention that it
    also erases the device.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index c9c800e..0b7c45a 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -693,8 +693,8 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 
 	if (!set)
 	{
-		LOG_ERROR("Can't unprotect write-protected pages.");
-		/* except by the "recover locked device" procedure ... */
+		LOG_ERROR("Hardware doesn't suppport page-level unprotect. "
+			"Try the 'recover' command.");
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
@@ -706,7 +706,7 @@ static int stellaris_protect(struct flash_bank *bank, int set, int first, int la
 			|| (last < first) || !(last & 1)
 			|| (last >= 2 * stellaris_info->num_lockbits))
 	{
-		LOG_ERROR("Can't protect unaligned or out-of-range sectors.");
+		LOG_ERROR("Can't protect unaligned or out-of-range pages.");
 		return ERROR_FLASH_SECTOR_INVALID;
 	}
 
@@ -1240,7 +1240,7 @@ static const struct command_registration stellaris_exec_command_handlers[] = {
 		.handler = stellaris_handle_recover_command,
 		.mode = COMMAND_EXEC,
 		.usage = "bank_id",
-		.help = "recover locked device",
+		.help = "recover (and erase) locked device",
 	},
 	COMMAND_REGISTRATION_DONE
 };

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stellaris.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Mar  4 06:02:48 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu,  4 Mar 2010 05:02:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-53-g5e78ddc
Message-ID: <E1Nn3Cz-0002wb-Bu@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5e78ddcea0d8303c316f687c05dfa78af27109d8 (commit)
       via  5fdf9535cef7e43f6e99081b6d1f6bd682184803 (commit)
      from  99939c3c75f3bef44d4cd176e90a6c5fe8b833da (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5e78ddcea0d8303c316f687c05dfa78af27109d8
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Mar 3 21:01:16 2010 -0800

    NOR: trim range in flash_driver_protect()
    
    When the beginning or end of the specified range of sectors
    already has the requested protection status, don't ask the
    flash driver to change those sectors.
    
    This will among other things turn command sequences like
    this into the NOPs one would expect:
    
    	flash protect_check 0
    	flash info 0
    		... reports everything as unprotected ...
    	flash protect 0 0 1 off
    
    That speeds things up (by whatever work was just avoided).
    
    Also, with Stellaris (which can't unprotect flash at  page level)
    this can eliminate some undesirable/false error reports.  (And
    finishes fixing a bug currently listed in our bug database...)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index fc020a8..767006d 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -54,6 +54,63 @@ int flash_driver_erase(struct flash_bank *bank, int first, int last)
 int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
 {
 	int retval;
+	bool updated = false;
+
+	/* NOTE: "first == last" means protect just that sector */
+
+	/* callers may not supply illegal parameters ... */
+	if (first < 0 || first > last || last >= bank->num_sectors)
+		return ERROR_FAIL;
+
+	/* force "set" to 0/1 */
+	set = !!set;
+
+	/*
+	 * Filter out what trivial nonsense we can, so drivers don't have to.
+	 *
+	 * Don't tell drivers to change to the current state...  it's needless,
+	 * and reducing the amount of work to be done (potentially to nothing)
+	 * speeds at least some things up.
+	 */
+scan:
+	for (int i = first; i < last; i++) {
+		struct flash_sector *sector = bank->sectors + i;
+
+		/* Only filter requests to protect the already-protected, or
+		 * to unprotect the already-unprotected.  Changing from the
+		 * unknown state (-1) to a known one is unwise but allowed;
+		 * protection status is best checked first.
+		 */
+		if (sector->is_protected != set)
+			continue;
+
+		/* Shrink this range of sectors from the start; don't overrun
+		 * the end.  Also shrink from the end; don't overun the start.
+		 *
+		 * REVISIT we could handle discontiguous regions by issuing
+		 * more than one driver request.  How much would that matter?
+		 */
+		if (i == first) {
+			updated = true;
+			first++;
+		} else if (i == last) {
+			updated = true;
+			last--;
+		}
+	}
+
+	/* updating the range affects the tests in the scan loop above; so
+	 * re-scan, to make sure we didn't miss anything.
+	 */
+	if (updated) {
+		updated = false;
+		goto scan;
+	}
+
+	/* Single sector, already protected?  Nothing to do! */
+	if (first == last)
+		return ERROR_OK;
+
 
 	retval = bank->driver->protect(bank, set, first, last);
 	if (retval != ERROR_OK)

commit 5fdf9535cef7e43f6e99081b6d1f6bd682184803
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Mar 3 20:57:49 2010 -0800

    NOR: invalidate cached state on target resume
    
    The NOR infrastructure caches some per-sector state, but
    it's not used much ... because the cache is not trustworthy.
    
    This patch addresses one part of that problem, by ensuring
    that state cached by NOR drivers gets invalidated once we
    resume the target -- since targets may then modify sectors.
    
    Now if we see sector protection or erase status marked as
    anything other than "unknown", we should be able to rely
    on that as being accurate.  (That is ... if we assume the
    drivers initialize and update this state correctly.)
    
    Another part of that problem is that the cached state isn't
    much used (being unreliable, it would have been unsafe).
    Those issues can be addressed in later patches.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 2c61519..fc020a8 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -657,3 +657,34 @@ int flash_write(struct target *target, struct image *image,
 {
 	return flash_write_unlock(target, image, written, erase, false);
 }
+
+/**
+ * Invalidates cached flash state which a target can change as it runs.
+ *
+ * @param target The target being resumed
+ *
+ * OpenOCD caches some flash state for brief periods.  For example, a sector
+ * that is protected must be unprotected before OpenOCD tries to write it,
+ * Also, a sector that's not erased must be erased before it's written.
+ *
+ * As a rule, OpenOCD and target firmware can both modify the flash, so when
+ * a target starts running, OpenOCD needs to invalidate its cached state.
+ */
+void nor_resume(struct target *target)
+{
+	struct flash_bank *bank;
+
+	for (bank = flash_banks; bank; bank = bank->next) {
+		int i;
+
+		if (bank->target != target)
+			continue;
+
+		for (i = 0; i < bank->num_sectors; i++) {
+			struct flash_sector *sector = bank->sectors + i;
+
+			sector->is_erased = -1;
+			sector->is_protected = -1;
+		}
+	}
+}
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index b164b8d..98763b7 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -122,6 +122,10 @@ int flash_erase_address_range(struct target *target,
  */
 int flash_write(struct target *target,
 		struct image *image, uint32_t *written, int erase);
+
+/* invalidate cached state (targets may modify their own flash) */
+void nor_resume(struct target *target);
+
 /**
  * Forces targets to re-examine their erase/protection state.
  * This routine must be called when the system may modify the status.
diff --git a/src/target/target.c b/src/target/target.c
index 9596302..1eb1435 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -35,6 +35,7 @@
 
 #include <helper/time_support.h>
 #include <jtag/jtag.h>
+#include <flash/nor/core.h>
 
 #include "target.h"
 #include "target_type.h"
@@ -472,6 +473,14 @@ int target_resume(struct target *target, int current, uint32_t address, int hand
 	if ((retval = target->type->resume(target, current, address, handle_breakpoints, debug_execution)) != ERROR_OK)
 		return retval;
 
+	/* Invalidate any cached protect/erase/... flash status, since
+	 * almost all targets will now be able modify the flash by
+	 * themselves.  We want flash drivers and infrastructure to
+	 * be able to rely on (non-invalidated) cached state.
+	 *
+	 * REVISIT do the same for NAND ; maybe other flash flavors too...
+	 */
+	nor_resume(target);
 	return retval;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/core.c |   88 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/flash/nor/core.h |    4 ++
 src/target/target.c  |    9 +++++
 3 files changed, 101 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Mar  5 06:52:53 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  5 Mar 2010 05:52:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-54-g45a528f
Message-ID: <E1NnQT0-0003xZ-8k@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  45a528ff3c0582f7d22b65d76d925f34a6956957 (commit)
      from  5e78ddcea0d8303c316f687c05dfa78af27109d8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 45a528ff3c0582f7d22b65d76d925f34a6956957
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Mar 4 21:51:58 2010 -0800

    rename "swjdp_common" as "adiv5_dap"
    
    This partially corrects an inappropriate name choice (and its
    associated FIXME).
    
    There are still too many variables named "swjdp", bug little
    current code actually relies on them referencing an SWJ-DP instead
    of some other flavor of DAP.  Only the two new dap_to{swd,jtag}()
    calls could behave differently on an SWJ-DP instead of a SW-DP or
    a JTAG-DP.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index c5e0dd3..e30ddf6 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -108,7 +108,7 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  * @param invalue NULL, or points to a 32-bit (little-endian) integer
  * @param ack points to where the three bit JTAG_ACK_* code will be stored
  */
-static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
+static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
 {
@@ -161,7 +161,7 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
  * conversions are performed (so the types of invalue and outvalue
  * must be different).
  */
-static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
+static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
 {
@@ -185,14 +185,14 @@ static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 /**
  * Utility to write AP registers.
  */
-static inline int adi_jtag_ap_write_check(struct swjdp_common *dap,
+static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
 		uint8_t reg_addr, uint8_t *outvalue)
 {
 	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
 			outvalue, NULL, NULL);
 }
 
-static int adi_jtag_scan_inout_check_u32(struct swjdp_common *swjdp,
+static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue)
 {
@@ -213,7 +213,7 @@ static int adi_jtag_scan_inout_check_u32(struct swjdp_common *swjdp,
 	return retval;
 }
 
-static int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
+static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 {
 	int retval;
 	uint32_t ctrlstat;
@@ -367,7 +367,7 @@ static int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
  * @param apsel Number of the AP to (implicitly) use with further
  *	transactions.  This normally identifies a MEM-AP.
  */
-void dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
+void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
 {
 	uint32_t select = (apsel << 24) & 0xFF000000;
 
@@ -402,7 +402,7 @@ void dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
  *
  * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
-int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
+int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
 {
 	int retval;
 
@@ -440,7 +440,7 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
+int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
 		uint32_t *value)
 {
 	int retval;
@@ -468,7 +468,7 @@ int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
  * @return ERROR_OK for success; *value holds the result.
  * Otherwise a fault code.
  */
-int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
+int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
 		uint32_t *value)
 {
 	int retval;
@@ -491,7 +491,7 @@ int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
+int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
 		uint32_t value)
 {
 	int retval;
@@ -519,7 +519,7 @@ int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
  *
  * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
  */
-int mem_ap_write_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
+int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
 		uint32_t value)
 {
 	int retval = mem_ap_write_u32(swjdp, address, value);
@@ -532,12 +532,12 @@ int mem_ap_write_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 
 /*****************************************************************************
 *                                                                            *
-* mem_ap_write_buf(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address) *
+* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
 *                                                                            *
 * Write a buffer in target order (little endian)                             *
 *                                                                            *
 *****************************************************************************/
-int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
 	uint32_t adr = address;
@@ -608,7 +608,7 @@ int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	return retval;
 }
 
-static int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp,
+static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
@@ -688,7 +688,7 @@ static int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp,
 	return retval;
 }
 
-int mem_ap_write_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
@@ -717,7 +717,7 @@ int mem_ap_write_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	return retval;
 }
 
-static int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp,
+static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
@@ -792,7 +792,7 @@ static int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp,
 	return retval;
 }
 
-int mem_ap_write_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
@@ -827,7 +827,7 @@ int mem_ap_write_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count,
  * @param address Memory address from which to read words; all the
  *	words must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
@@ -924,7 +924,7 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer,
 	return retval;
 }
 
-static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
+static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
@@ -984,7 +984,7 @@ static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
  * @param address Memory address from which to read words; all the
  *	words must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	uint32_t invalue, i;
@@ -1032,7 +1032,7 @@ int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer,
  * The solution is to arrange for a large out/in scan in this loop and
  * and convert data afterwards.
  */
-static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
+static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
@@ -1089,7 +1089,7 @@ static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
  * @param address Memory address from which to read data; all the
  *	data must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	uint32_t invalue;
@@ -1117,7 +1117,7 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer,
 
 /*--------------------------------------------------------------------------*/
 
-static int jtag_idcode_q_read(struct swjdp_common *dap,
+static int jtag_idcode_q_read(struct adiv5_dap *dap,
 		uint8_t *ack, uint32_t *data)
 {
 	struct arm_jtag *jtag_info = dap->jtag_info;
@@ -1147,14 +1147,14 @@ static int jtag_idcode_q_read(struct swjdp_common *dap,
 	return retval;
 }
 
-static int jtag_dp_q_read(struct swjdp_common *dap, unsigned reg,
+static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
 		uint32_t *data)
 {
 	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 			reg, DPAP_READ, 0, data);
 }
 
-static int jtag_dp_q_write(struct swjdp_common *dap, unsigned reg,
+static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
 		uint32_t data)
 {
 	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
@@ -1162,7 +1162,7 @@ static int jtag_dp_q_write(struct swjdp_common *dap, unsigned reg,
 }
 
 /** Select the AP register bank matching bits 7:4 of reg. */
-static int jtag_ap_q_bankselect(struct swjdp_common *dap, unsigned reg)
+static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
 	uint32_t select = reg & 0x000000F0;
 
@@ -1175,7 +1175,7 @@ static int jtag_ap_q_bankselect(struct swjdp_common *dap, unsigned reg)
 	return jtag_dp_q_write(dap, DP_SELECT, select);
 }
 
-static int jtag_ap_q_read(struct swjdp_common *dap, unsigned reg,
+static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
 		uint32_t *data)
 {
 	int retval = jtag_ap_q_bankselect(dap, reg);
@@ -1187,7 +1187,7 @@ static int jtag_ap_q_read(struct swjdp_common *dap, unsigned reg,
 			DPAP_READ, 0, data);
 }
 
-static int jtag_ap_q_write(struct swjdp_common *dap, unsigned reg,
+static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
 		uint32_t data)
 {
 	uint8_t out_value_buf[4];
@@ -1201,14 +1201,14 @@ static int jtag_ap_q_write(struct swjdp_common *dap, unsigned reg,
 	return adi_jtag_ap_write_check(dap, reg, out_value_buf);
 }
 
-static int jtag_ap_q_abort(struct swjdp_common *dap, uint8_t *ack)
+static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
 	/* for JTAG, this is the only valid ABORT register operation */
 	return adi_jtag_dp_scan_u32(dap, JTAG_DP_ABORT,
 			0, DPAP_WRITE, 1, NULL, ack);
 }
 
-static int jtag_dp_run(struct swjdp_common *dap)
+static int jtag_dp_run(struct adiv5_dap *dap)
 {
 	return jtagdp_transaction_endcheck(dap);
 }
@@ -1237,7 +1237,7 @@ static const struct dap_ops jtag_dp_ops = {
  * in layering.  (JTAG is useful without any debug target; but not SWD.)
  * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
  */
-int ahbap_debugport_init(struct swjdp_common *swjdp)
+int ahbap_debugport_init(struct adiv5_dap *swjdp)
 {
 	uint32_t idreg, romaddr, dummy;
 	uint32_t ctrlstat;
@@ -1353,7 +1353,7 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 }
 
 int dap_info_command(struct command_context *cmd_ctx,
-		struct swjdp_common *swjdp, int apsel)
+		struct adiv5_dap *swjdp, int apsel)
 {
 	int retval;
 	uint32_t dbgbase, apid;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index e867b85..abdbd24 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -133,10 +133,8 @@
  * a choice made at board design time (by only using the SWD pins), or
  * as part of setting up a debug session (if all the dual-role JTAG/SWD
  * signals are available).
- *
- * @todo Rename "swjdp_common" as "dap".  Use of SWJ-DP is optional!
  */
-struct swjdp_common
+struct adiv5_dap
 {
 	const struct dap_ops *ops;
 
@@ -201,27 +199,27 @@ struct dap_ops {
 	bool	is_swd;
 
 	/** Reads the DAP's IDCODe register. */
-	int (*queue_idcode_read)(struct swjdp_common *dap,
+	int (*queue_idcode_read)(struct adiv5_dap *dap,
 			uint8_t *ack, uint32_t *data);
 
 	/** DP register read. */
-	int (*queue_dp_read)(struct swjdp_common *dap, unsigned reg,
+	int (*queue_dp_read)(struct adiv5_dap *dap, unsigned reg,
 			uint32_t *data);
 	/** DP register write. */
-	int (*queue_dp_write)(struct swjdp_common *dap, unsigned reg,
+	int (*queue_dp_write)(struct adiv5_dap *dap, unsigned reg,
 			uint32_t data);
 
 	/** AP register read. */
-	int (*queue_ap_read)(struct swjdp_common *dap, unsigned reg,
+	int (*queue_ap_read)(struct adiv5_dap *dap, unsigned reg,
 			uint32_t *data);
 	/** AP register write. */
-	int (*queue_ap_write)(struct swjdp_common *dap, unsigned reg,
+	int (*queue_ap_write)(struct adiv5_dap *dap, unsigned reg,
 			uint32_t data);
 	/** AP operation abort. */
-	int (*queue_ap_abort)(struct swjdp_common *dap, uint8_t *ack);
+	int (*queue_ap_abort)(struct adiv5_dap *dap, uint8_t *ack);
 
 	/** Executes all queued DAP operations. */
-	int (*run)(struct swjdp_common *dap);
+	int (*run)(struct adiv5_dap *dap);
 };
 
 /**
@@ -235,7 +233,7 @@ struct dap_ops {
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_idcode_read(struct swjdp_common *dap,
+static inline int dap_queue_idcode_read(struct adiv5_dap *dap,
 		uint8_t *ack, uint32_t *data)
 {
 	return dap->ops->queue_idcode_read(dap, ack, data);
@@ -253,7 +251,7 @@ static inline int dap_queue_idcode_read(struct swjdp_common *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_dp_read(struct swjdp_common *dap,
+static inline int dap_queue_dp_read(struct adiv5_dap *dap,
 		unsigned reg, uint32_t *data)
 {
 	return dap->ops->queue_dp_read(dap, reg, data);
@@ -270,7 +268,7 @@ static inline int dap_queue_dp_read(struct swjdp_common *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_dp_write(struct swjdp_common *dap,
+static inline int dap_queue_dp_write(struct adiv5_dap *dap,
 		unsigned reg, uint32_t data)
 {
 	return dap->ops->queue_dp_write(dap, reg, data);
@@ -286,7 +284,7 @@ static inline int dap_queue_dp_write(struct swjdp_common *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_ap_read(struct swjdp_common *dap,
+static inline int dap_queue_ap_read(struct adiv5_dap *dap,
 		unsigned reg, uint32_t *data)
 {
 	return dap->ops->queue_ap_read(dap, reg, data);
@@ -301,7 +299,7 @@ static inline int dap_queue_ap_read(struct swjdp_common *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_ap_write(struct swjdp_common *dap,
+static inline int dap_queue_ap_write(struct adiv5_dap *dap,
 		unsigned reg, uint32_t data)
 {
 	return dap->ops->queue_ap_write(dap, reg, data);
@@ -318,7 +316,7 @@ static inline int dap_queue_ap_write(struct swjdp_common *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_ap_abort(struct swjdp_common *dap, uint8_t *ack)
+static inline int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
 	return dap->ops->queue_ap_abort(dap, ack);
 }
@@ -333,59 +331,59 @@ static inline int dap_queue_ap_abort(struct swjdp_common *dap, uint8_t *ack)
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_run(struct swjdp_common *dap)
+static inline int dap_run(struct adiv5_dap *dap)
 {
 	return dap->ops->run(dap);
 }
 
 /** Accessor for currently selected DAP-AP number (0..255) */
-static inline uint8_t dap_ap_get_select(struct swjdp_common *swjdp)
+static inline uint8_t dap_ap_get_select(struct adiv5_dap *swjdp)
 {
 	return (uint8_t)(swjdp ->apsel >> 24);
 }
 
 /* AP selection applies to future AP transactions */
-void dap_ap_select(struct swjdp_common *dap,uint8_t apsel);
+void dap_ap_select(struct adiv5_dap *dap,uint8_t apsel);
 
 /* Queued AP transactions */
-int dap_setup_accessport(struct swjdp_common *swjdp,
+int dap_setup_accessport(struct adiv5_dap *swjdp,
 		uint32_t csw, uint32_t tar);
 
 /* Queued MEM-AP memory mapped single word transfers */
-int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t *value);
-int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t value);
+int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address, uint32_t *value);
+int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address, uint32_t value);
 
 /* Synchronous MEM-AP memory mapped single word transfers */
-int mem_ap_read_atomic_u32(struct swjdp_common *swjdp,
+int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp,
 		uint32_t address, uint32_t *value);
-int mem_ap_write_atomic_u32(struct swjdp_common *swjdp,
+int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp,
 		uint32_t address, uint32_t value);
 
 /* MEM-AP memory mapped bus block transfers */
-int mem_ap_read_buf_u8(struct swjdp_common *swjdp,
+int mem_ap_read_buf_u8(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_read_buf_u16(struct swjdp_common *swjdp,
+int mem_ap_read_buf_u16(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_read_buf_u32(struct swjdp_common *swjdp,
+int mem_ap_read_buf_u32(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address);
 
-int mem_ap_write_buf_u8(struct swjdp_common *swjdp,
+int mem_ap_write_buf_u8(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_write_buf_u16(struct swjdp_common *swjdp,
+int mem_ap_write_buf_u16(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_write_buf_u32(struct swjdp_common *swjdp,
+int mem_ap_write_buf_u32(struct adiv5_dap *swjdp,
 		uint8_t *buffer, int count, uint32_t address);
 
 /* Initialisation of the debug system, power domains and registers */
-int ahbap_debugport_init(struct swjdp_common *swjdp);
+int ahbap_debugport_init(struct adiv5_dap *swjdp);
 
 
 /* Commands for user dap access */
 int dap_info_command(struct command_context *cmd_ctx,
-		struct swjdp_common *swjdp, int apsel);
+		struct adiv5_dap *swjdp, int apsel);
 
 #define DAP_COMMAND_HANDLER(name) \
-		COMMAND_HELPER(name, struct swjdp_common *swjdp)
+		COMMAND_HELPER(name, struct adiv5_dap *swjdp)
 DAP_COMMAND_HANDLER(dap_baseaddr_command);
 DAP_COMMAND_HANDLER(dap_memaccess_command);
 DAP_COMMAND_HANDLER(dap_apsel_command);
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index fe87fee..92a373a 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -121,7 +121,7 @@ COMMAND_HANDLER(handle_dap_baseaddr_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	return CALL_COMMAND_HANDLER(dap_baseaddr_command, swjdp);
 }
@@ -130,7 +130,7 @@ COMMAND_HANDLER(handle_dap_memaccess_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	return CALL_COMMAND_HANDLER(dap_memaccess_command, swjdp);
 }
@@ -139,7 +139,7 @@ COMMAND_HANDLER(handle_dap_apsel_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	return CALL_COMMAND_HANDLER(dap_apsel_command, swjdp);
 }
@@ -148,7 +148,7 @@ COMMAND_HANDLER(handle_dap_apid_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	return CALL_COMMAND_HANDLER(dap_apid_command, swjdp);
 }
@@ -157,7 +157,7 @@ COMMAND_HANDLER(handle_dap_info_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 	uint32_t apsel;
 
 	switch (CMD_ARGC) {
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 581813a..70a2d9e 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -51,7 +51,7 @@ struct armv7a_common
 	struct reg_cache *core_cache;
 
 	/* arm adp debug port */
-	struct swjdp_common swjdp_info;
+	struct adiv5_dap swjdp_info;
 
 	/* Core Debug Unit */
 	struct arm_dpm dpm;
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 65e03bf..5276af8 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -755,7 +755,7 @@ COMMAND_HANDLER(handle_dap_baseaddr_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 
 	if (!is_armv7m(armv7m)) {
 		command_print(CMD_CTX, "current target isn't an ARM7-M");
@@ -773,7 +773,7 @@ COMMAND_HANDLER(handle_dap_apid_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 
 	if (!is_armv7m(armv7m)) {
 		command_print(CMD_CTX, "current target isn't an ARM7-M");
@@ -787,7 +787,7 @@ COMMAND_HANDLER(handle_dap_apsel_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 
 	if (!is_armv7m(armv7m)) {
 		command_print(CMD_CTX, "current target isn't an ARM7-M");
@@ -801,7 +801,7 @@ COMMAND_HANDLER(handle_dap_memaccess_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 
 	if (!is_armv7m(armv7m)) {
 		command_print(CMD_CTX, "current target isn't an ARM7-M");
@@ -816,7 +816,7 @@ COMMAND_HANDLER(handle_dap_info_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	uint32_t apsel;
 
 	if (!is_armv7m(armv7m)) {
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 89c5064..5526505 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -106,7 +106,7 @@ struct armv7m_common
 	struct reg_cache *core_cache;
 	enum armv7m_mode core_mode;
 	int exception_number;
-	struct swjdp_common swjdp_info;
+	struct adiv5_dap swjdp_info;
 
 	uint32_t demcr;
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index f4818f8..0dc7cee 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -67,7 +67,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 static int cortex_a8_init_debug_access(struct target *target)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	int retval;
 	uint32_t dummy;
@@ -103,7 +103,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 	uint32_t dscr;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	dscr = dscr_p ? *dscr_p : 0;
 
@@ -150,7 +150,7 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 {
 	int retval = ERROR_OK;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	cortex_a8_dap_read_coreregister_u32(target, regfile, 0);
 	cortex_a8_dap_write_coreregister_u32(target, address, 0);
@@ -169,7 +169,7 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	uint8_t reg = regnum&0xFF;
 	uint32_t dscr = 0;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	if (reg > 17)
 		return retval;
@@ -221,7 +221,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	uint8_t Rd = regnum&0xFF;
 	uint32_t dscr;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
 
@@ -284,7 +284,7 @@ static int cortex_a8_dap_write_memap_register_u32(struct target *target, uint32_
 {
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	retval = mem_ap_write_atomic_u32(swjdp, address, value);
 
@@ -317,7 +317,7 @@ static int cortex_a8_write_dcc(struct cortex_a8_common *a8, uint32_t data)
 static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		uint32_t *dscr_p)
 {
-	struct swjdp_common *swjdp = &a8->armv7a_common.swjdp_info;
+	struct adiv5_dap *swjdp = &a8->armv7a_common.swjdp_info;
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
@@ -344,7 +344,7 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
-	struct swjdp_common *swjdp = &a8->armv7a_common.swjdp_info;
+	struct adiv5_dap *swjdp = &a8->armv7a_common.swjdp_info;
 	uint32_t dscr;
 	int retval;
 
@@ -562,7 +562,7 @@ static int cortex_a8_poll(struct target *target)
 	uint32_t dscr;
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 	enum target_state prev_target_state = target->state;
 	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 
@@ -626,7 +626,7 @@ static int cortex_a8_halt(struct target *target)
 	int retval = ERROR_OK;
 	uint32_t dscr;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 	dap_ap_select(swjdp, swjdp_debugap);
 
@@ -664,7 +664,7 @@ static int cortex_a8_resume(struct target *target, int current,
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 //	struct breakpoint *breakpoint = NULL;
 	uint32_t resume_pc, dscr;
@@ -788,7 +788,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 	struct reg *reg;
 
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
@@ -1276,7 +1276,7 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 	/* cortex_a8 handles unaligned memory access */
@@ -1304,7 +1304,7 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 // ???	dap_ap_select(swjdp, swjdp_memoryap);
@@ -1386,7 +1386,7 @@ static int cortex_a8_bulk_write_memory(struct target *target, uint32_t address,
 }
 
 
-static int cortex_a8_dcc_read(struct swjdp_common *swjdp, uint8_t *value, uint8_t *ctrl)
+static int cortex_a8_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
 {
 #if 0
 	u16 dcrdr;
@@ -1413,7 +1413,7 @@ static int cortex_a8_handle_target_request(void *priv)
 {
 	struct target *target = priv;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	if (!target_was_examined(target))
 		return ERROR_OK;
@@ -1455,7 +1455,7 @@ static int cortex_a8_examine_first(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 	int i;
 	int retval = ERROR_OK;
 	uint32_t didr, ctypr, ttypr, cpuid;
@@ -1562,7 +1562,7 @@ static int cortex_a8_init_arch_info(struct target *target,
 {
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct swjdp_common *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
 
 	/* Setup struct cortex_a8_common */
 	cortex_a8->common_magic = CORTEX_A8_COMMON_MAGIC;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 3178ce3..852965c 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -59,7 +59,7 @@ static void cortex_m3_enable_watchpoints(struct target *target);
 static int cortex_m3_store_core_reg_u32(struct target *target,
 		enum armv7m_regtype type, uint32_t num, uint32_t value);
 
-static int cortexm3_dap_read_coreregister_u32(struct swjdp_common *swjdp,
+static int cortexm3_dap_read_coreregister_u32(struct adiv5_dap *swjdp,
 		uint32_t *value, int regnum)
 {
 	int retval;
@@ -94,7 +94,7 @@ static int cortexm3_dap_read_coreregister_u32(struct swjdp_common *swjdp,
 	return retval;
 }
 
-static int cortexm3_dap_write_coreregister_u32(struct swjdp_common *swjdp,
+static int cortexm3_dap_write_coreregister_u32(struct adiv5_dap *swjdp,
 		uint32_t value, int regnum)
 {
 	int retval;
@@ -129,7 +129,7 @@ static int cortex_m3_write_debug_halt_mask(struct target *target,
 		uint32_t mask_on, uint32_t mask_off)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 
 	/* mask off status bits */
 	cortex_m3->dcb_dhcsr &= ~((0xFFFF << 16) | mask_off);
@@ -142,7 +142,7 @@ static int cortex_m3_write_debug_halt_mask(struct target *target,
 static int cortex_m3_clear_halt(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 
 	/* clear step if any */
 	cortex_m3_write_debug_halt_mask(target, C_HALT, C_STEP);
@@ -160,7 +160,7 @@ static int cortex_m3_clear_halt(struct target *target)
 static int cortex_m3_single_step_core(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 	uint32_t dhcsr_save;
 
 	/* backup dhcsr reg */
@@ -191,7 +191,7 @@ static int cortex_m3_endreset_event(struct target *target)
 	uint32_t dcb_demcr;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 	struct cortex_m3_fp_comparator *fp_list = cortex_m3->fp_comparator_list;
 	struct cortex_m3_dwt_comparator *dwt_list = cortex_m3->dwt_comparator_list;
 
@@ -286,7 +286,7 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 {
 	uint32_t shcsr, except_sr, cfsr = -1, except_ar = -1;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	int retval;
 
 	mem_ap_read_u32(swjdp, NVIC_SHCSR, &shcsr);
@@ -360,7 +360,7 @@ static int cortex_m3_debug_entry(struct target *target)
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
 	struct arm *arm = &armv7m->arm;
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	struct reg *r;
 
 	LOG_DEBUG(" ");
@@ -452,7 +452,7 @@ static int cortex_m3_poll(struct target *target)
 	int retval;
 	enum target_state prev_target_state = target->state;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 
 	/* Read from Debug Halting Control and Status Register */
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
@@ -587,7 +587,7 @@ static int cortex_m3_halt(struct target *target)
 static int cortex_m3_soft_reset_halt(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 	uint32_t dcb_dhcsr = 0;
 	int retval, timeout = 0;
 
@@ -761,7 +761,7 @@ static int cortex_m3_step(struct target *target, int current,
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	struct breakpoint *breakpoint = NULL;
 	struct reg *pc = armv7m->arm.pc;
 	bool bkpt_inst_found = false;
@@ -826,7 +826,7 @@ static int cortex_m3_step(struct target *target, int current,
 static int cortex_m3_assert_reset(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 	int assert_srst = 1;
 
 	LOG_DEBUG("target->state: %s",
@@ -1376,7 +1376,7 @@ static int cortex_m3_load_core_reg_u32(struct target *target,
 {
 	int retval;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 
 	/* NOTE:  we "know" here that the register identifiers used
 	 * in the v7m header match the Cortex-M3 Debug Core Register
@@ -1440,7 +1440,7 @@ static int cortex_m3_store_core_reg_u32(struct target *target,
 	int retval;
 	uint32_t reg;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 
 #ifdef ARMV7_GDB_HACKS
 	/* If the LR register is being modified, make sure it will put us
@@ -1518,7 +1518,7 @@ static int cortex_m3_read_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 	/* cortex_m3 handles unaligned memory access */
@@ -1543,7 +1543,7 @@ static int cortex_m3_write_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 	if (count && buffer) {
@@ -1724,7 +1724,7 @@ static int cortex_m3_examine(struct target *target)
 	uint32_t cpuid, fpcr;
 	int i;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct swjdp_common *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
 
 	if ((retval = ahbap_debugport_init(swjdp)) != ERROR_OK)
 		return retval;
@@ -1773,7 +1773,7 @@ static int cortex_m3_examine(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_m3_dcc_read(struct swjdp_common *swjdp, uint8_t *value, uint8_t *ctrl)
+static int cortex_m3_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
 {
 	uint16_t dcrdr;
 
@@ -1798,7 +1798,7 @@ static int cortex_m3_target_request_data(struct target *target,
 		uint32_t size, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	uint8_t data;
 	uint8_t ctrl;
 	uint32_t i;
@@ -1818,7 +1818,7 @@ static int cortex_m3_handle_target_request(void *priv)
 	if (!target_was_examined(target))
 		return ERROR_OK;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 
 	if (!target->dbg_msg_enabled)
 		return ERROR_OK;
@@ -1936,7 +1936,7 @@ COMMAND_HANDLER(handle_cortex_m3_vector_catch_command)
 	struct target *target = get_current_target(CMD_CTX);
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
-	struct swjdp_common *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
 	uint32_t demcr = 0;
 	int retval;
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   64 +++++++++++++++++++++++-----------------------
 src/target/arm_adi_v5.h |   64 ++++++++++++++++++++++------------------------
 src/target/armv7a.c     |   10 +++---
 src/target/armv7a.h     |    2 +-
 src/target/armv7m.c     |   10 +++---
 src/target/armv7m.h     |    2 +-
 src/target/cortex_a8.c  |   36 +++++++++++++-------------
 src/target/cortex_m3.c  |   42 +++++++++++++++---------------
 8 files changed, 114 insertions(+), 116 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar  5 10:37:12 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri,  5 Mar 2010 09:37:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-55-g57ebf6d
Message-ID: <E1NnTy6-0006yR-0J@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  57ebf6d3dea85d7c4d712a1ada161d76096fdf23 (commit)
      from  45a528ff3c0582f7d22b65d76d925f34a6956957 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 57ebf6d3dea85d7c4d712a1ada161d76096fdf23
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 4 18:30:03 2010 +0100

    minidriver: fix arm11 compilation problem
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 705f1b4..01cdd2e 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -163,3 +163,9 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 		buffer += 4;
 	}
 }
+
+int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count)
+{
+	int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count);
+	return arm11_run_instr_data_to_core_noack_inner_default(tap, opcode, data, count);
+}

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/minidummy/minidummy.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Mar  5 19:39:43 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  5 Mar 2010 18:39:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-56-gd33a81c
Message-ID: <E1NncR6-0005H7-VW@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d33a81c549743e13633db9e8749f0e7cb0f7324b (commit)
      from  57ebf6d3dea85d7c4d712a1ada161d76096fdf23 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d33a81c549743e13633db9e8749f0e7cb0f7324b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Mar 5 10:39:25 2010 -0800

    ADIv5 share DAP command support
    
    Get rid of needless and undesirable code duplication for
    all the DAP commands (resolving a FIXME) ... there's no
    need for coreas to have private copies of that stuff.
    Stick a pointer to the DAP in "struct arm", letting common
    code get to it.
    
    Also rename the "swjdp_info" symbol; just call it "dap".
    
    This is an overall code shrink.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm.h b/src/target/arm.h
index ee4bd76..99bd983 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -167,6 +167,12 @@ struct arm {
 			uint32_t value);
 
 	void *arch_info;
+
+	/** For targets conforming to ARM Debug Interface v5,
+	 * this handle references the Debug Access Port (DAP)
+	 * used to make requests to the target.
+	 */
+	struct adiv5_dap *dap;
 };
 
 /** Convert target handle to generic ARM target state handle. */
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index e30ddf6..1c52786 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -69,6 +69,7 @@
 #include "config.h"
 #endif
 
+#include "arm.h"
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
@@ -1352,7 +1353,7 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
 }
 
-int dap_info_command(struct command_context *cmd_ctx,
+static int dap_info_command(struct command_context *cmd_ctx,
 		struct adiv5_dap *swjdp, int apsel)
 {
 	int retval;
@@ -1711,15 +1712,40 @@ int dap_info_command(struct command_context *cmd_ctx,
 	return ERROR_OK;
 }
 
-DAP_COMMAND_HANDLER(dap_baseaddr_command)
+COMMAND_HANDLER(handle_dap_info_command)
 {
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+	uint32_t apsel;
+
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = dap->apsel;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	return dap_info_command(CMD_CTX, dap, apsel);
+}
+
+COMMAND_HANDLER(dap_baseaddr_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
 	uint32_t apsel, apselsave, baseaddr;
 	int retval;
 
-	apselsave = swjdp->apsel;
+	apselsave = dap->apsel;
 	switch (CMD_ARGC) {
 	case 0:
-		apsel = swjdp->apsel;
+		apsel = dap->apsel;
 		break;
 	case 1:
 		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
@@ -1732,33 +1758,37 @@ DAP_COMMAND_HANDLER(dap_baseaddr_command)
 	}
 
 	if (apselsave != apsel)
-		dap_ap_select(swjdp, apsel);
+		dap_ap_select(dap, apsel);
 
 	/* NOTE:  assumes we're talking to a MEM-AP, which
 	 * has a base address.  There are other kinds of AP,
 	 * though they're not common for now.  This should
 	 * use the ID register to verify it's a MEM-AP.
 	 */
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &baseaddr);
-	retval = dap_run(swjdp);
+	retval = dap_queue_ap_read(dap, AP_REG_BASE, &baseaddr);
+	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
 
 	command_print(CMD_CTX, "0x%8.8" PRIx32, baseaddr);
 
 	if (apselsave != apsel)
-		dap_ap_select(swjdp, apselsave);
+		dap_ap_select(dap, apselsave);
 
 	return retval;
 }
 
-DAP_COMMAND_HANDLER(dap_memaccess_command)
+COMMAND_HANDLER(dap_memaccess_command)
 {
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
 	uint32_t memaccess_tck;
 
 	switch (CMD_ARGC) {
 	case 0:
-		memaccess_tck = swjdp->memaccess_tck;
+		memaccess_tck = dap->memaccess_tck;
 		break;
 	case 1:
 		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
@@ -1766,16 +1796,20 @@ DAP_COMMAND_HANDLER(dap_memaccess_command)
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	swjdp->memaccess_tck = memaccess_tck;
+	dap->memaccess_tck = memaccess_tck;
 
 	command_print(CMD_CTX, "memory bus access delay set to %" PRIi32 " tck",
-			swjdp->memaccess_tck);
+			dap->memaccess_tck);
 
 	return ERROR_OK;
 }
 
-DAP_COMMAND_HANDLER(dap_apsel_command)
+COMMAND_HANDLER(dap_apsel_command)
 {
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
 	uint32_t apsel, apid;
 	int retval;
 
@@ -1793,9 +1827,9 @@ DAP_COMMAND_HANDLER(dap_apsel_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	dap_ap_select(swjdp, apsel);
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
-	retval = dap_run(swjdp);
+	dap_ap_select(dap, apsel);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1805,15 +1839,19 @@ DAP_COMMAND_HANDLER(dap_apsel_command)
 	return retval;
 }
 
-DAP_COMMAND_HANDLER(dap_apid_command)
+COMMAND_HANDLER(dap_apid_command)
 {
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
 	uint32_t apsel, apselsave, apid;
 	int retval;
 
-	apselsave = swjdp->apsel;
+	apselsave = dap->apsel;
 	switch (CMD_ARGC) {
 	case 0:
-		apsel = swjdp->apsel;
+		apsel = dap->apsel;
 		break;
 	case 1:
 		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
@@ -1826,20 +1864,75 @@ DAP_COMMAND_HANDLER(dap_apid_command)
 	}
 
 	if (apselsave != apsel)
-		dap_ap_select(swjdp, apsel);
+		dap_ap_select(dap, apsel);
 
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
-	retval = dap_run(swjdp);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
 
 	command_print(CMD_CTX, "0x%8.8" PRIx32, apid);
 	if (apselsave != apsel)
-		dap_ap_select(swjdp, apselsave);
+		dap_ap_select(dap, apselsave);
 
 	return retval;
 }
 
+static const struct command_registration dap_commands[] = {
+	{
+		.name = "info",
+		.handler = handle_dap_info_command,
+		.mode = COMMAND_EXEC,
+		.help = "display ROM table for MEM-AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "apsel",
+		.handler = dap_apsel_command,
+		.mode = COMMAND_EXEC,
+		.help = "Set the currently selected AP (default 0) "
+			"and display the result",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "apid",
+		.handler = dap_apid_command,
+		.mode = COMMAND_EXEC,
+		.help = "return ID register from AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "baseaddr",
+		.handler = dap_baseaddr_command,
+		.mode = COMMAND_EXEC,
+		.help = "return debug base address from MEM-AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "memaccess",
+		.handler = dap_memaccess_command,
+		.mode = COMMAND_EXEC,
+		.help = "set/get number of extra tck for MEM-AP memory "
+			"bus access [0-255]",
+		.usage = "[cycles]",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration dap_command_handlers[] = {
+	{
+		.name = "dap",
+		.mode = COMMAND_EXEC,
+		.help = "DAP command group",
+		.chain = dap_commands,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+
 /*
  * This represents the bits which must be sent out on TMS/SWDIO to
  * switch a DAP implemented using an SWJ-DP module into SWD mode.
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index abdbd24..d207fd9 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -378,17 +378,6 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp,
 int ahbap_debugport_init(struct adiv5_dap *swjdp);
 
 
-/* Commands for user dap access */
-int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *swjdp, int apsel);
-
-#define DAP_COMMAND_HANDLER(name) \
-		COMMAND_HELPER(name, struct adiv5_dap *swjdp)
-DAP_COMMAND_HANDLER(dap_baseaddr_command);
-DAP_COMMAND_HANDLER(dap_memaccess_command);
-DAP_COMMAND_HANDLER(dap_apsel_command);
-DAP_COMMAND_HANDLER(dap_apid_command);
-
 struct target;
 
 /* Put debug link into SWD mode */
@@ -397,4 +386,6 @@ int dap_to_swd(struct target *target);
 /* Put debug link into JTAG mode */
 int dap_to_jtag(struct target *target);
 
+extern const struct command_registration dap_command_handlers[];
+
 #endif
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 92a373a..151deb4 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -117,115 +117,9 @@ int armv7a_arch_state(struct target *target)
 }
 
 
-COMMAND_HANDLER(handle_dap_baseaddr_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
-
-	return CALL_COMMAND_HANDLER(dap_baseaddr_command, swjdp);
-}
-
-COMMAND_HANDLER(handle_dap_memaccess_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
-
-	return CALL_COMMAND_HANDLER(dap_memaccess_command, swjdp);
-}
-
-COMMAND_HANDLER(handle_dap_apsel_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
-
-	return CALL_COMMAND_HANDLER(dap_apsel_command, swjdp);
-}
-
-COMMAND_HANDLER(handle_dap_apid_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
-
-	return CALL_COMMAND_HANDLER(dap_apid_command, swjdp);
-}
-
-COMMAND_HANDLER(handle_dap_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
-	uint32_t apsel;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = swjdp->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	return dap_info_command(CMD_CTX, swjdp, apsel);
-}
-
-/* FIXME this table should be part of generic DAP support, and
- * be shared by the ARMv7-A/R and ARMv7-M support ...
- */
-static const struct command_registration armv7a_exec_command_handlers[] = {
-	{
-		.name = "info",
-		.handler = handle_dap_info_command,
-		.mode = COMMAND_EXEC,
-		.help = "display ROM table for MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apsel",
-		.handler = handle_dap_apsel_command,
-		.mode = COMMAND_EXEC,
-		.help = "Set the currently selected AP (default 0) "
-			"and display the result",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apid",
-		.handler = handle_dap_apid_command,
-		.mode = COMMAND_EXEC,
-		.help = "return ID register from AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "baseaddr",
-		.handler = handle_dap_baseaddr_command,
-		.mode = COMMAND_EXEC,
-		.help = "return debug base address from MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "memaccess",
-		.handler = handle_dap_memaccess_command,
-		.mode = COMMAND_EXEC,
-		.help = "set/get number of extra tck for MEM-AP memory "
-			"bus access [0-255]",
-		.usage = "[cycles]",
-	},
-	COMMAND_REGISTRATION_DONE
-};
 const struct command_registration armv7a_command_handlers[] = {
 	{
-		.name = "dap",
-		.mode = COMMAND_ANY,
-		.help = "Cortex DAP command group",
-		.chain = armv7a_exec_command_handlers,
+		.chain = dap_command_handlers,
 	},
 	COMMAND_REGISTRATION_DONE
 };
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 70a2d9e..5ef8c42 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -50,8 +50,7 @@ struct armv7a_common
 	int common_magic;
 	struct reg_cache *core_cache;
 
-	/* arm adp debug port */
-	struct adiv5_dap swjdp_info;
+	struct adiv5_dap dap;
 
 	/* Core Debug Unit */
 	struct arm_dpm dpm;
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 5276af8..1216a45 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -739,160 +739,12 @@ int armv7m_maybe_skip_bkpt_inst(struct target *target, bool *inst_found)
 	return ERROR_OK;
 }
 
-/*--------------------------------------------------------------------------*/
-
-/*
- * Only stuff below this line should need to verify that its target
- * is an ARMv7-M node.
- */
-
-
-/*
- * Return the debug ap baseaddress in hexadecimal;
- * no extra output to simplify script processing
- */
-COMMAND_HANDLER(handle_dap_baseaddr_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
-
-	if (!is_armv7m(armv7m)) {
-		command_print(CMD_CTX, "current target isn't an ARM7-M");
-		return ERROR_TARGET_INVALID;
-	}
-
-	return CALL_COMMAND_HANDLER(dap_baseaddr_command, swjdp);
-}
-
-/*
- * Return the debug ap id in hexadecimal;
- * no extra output to simplify script processing
- */
-COMMAND_HANDLER(handle_dap_apid_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
-
-	if (!is_armv7m(armv7m)) {
-		command_print(CMD_CTX, "current target isn't an ARM7-M");
-		return ERROR_TARGET_INVALID;
-	}
-
-	return CALL_COMMAND_HANDLER(dap_apid_command, swjdp);
-}
-
-COMMAND_HANDLER(handle_dap_apsel_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
-
-	if (!is_armv7m(armv7m)) {
-		command_print(CMD_CTX, "current target isn't an ARM7-M");
-		return ERROR_TARGET_INVALID;
-	}
-
-	return CALL_COMMAND_HANDLER(dap_apsel_command, swjdp);
-}
-
-COMMAND_HANDLER(handle_dap_memaccess_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
-
-	if (!is_armv7m(armv7m)) {
-		command_print(CMD_CTX, "current target isn't an ARM7-M");
-		return ERROR_TARGET_INVALID;
-	}
-
-	return CALL_COMMAND_HANDLER(dap_memaccess_command, swjdp);
-}
-
-
-COMMAND_HANDLER(handle_dap_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
-	uint32_t apsel;
-
-	if (!is_armv7m(armv7m)) {
-		command_print(CMD_CTX, "current target isn't an ARM7-M");
-		return ERROR_TARGET_INVALID;
-	}
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = swjdp->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	return dap_info_command(CMD_CTX, swjdp, apsel);
-}
-
-/* FIXME this table should be part of generic DAP support, and
- * be shared by the ARMv7-A/R and ARMv7-M support ...
- */
-static const struct command_registration armv7m_exec_command_handlers[] = {
-	{
-		.name = "info",
-		.handler = handle_dap_info_command,
-		.mode = COMMAND_EXEC,
-		.help = "display ROM table for MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apsel",
-		.handler = handle_dap_apsel_command,
-		.mode = COMMAND_EXEC,
-		.help = "Set the currently selected AP (default 0) "
-			"and display the result",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apid",
-		.handler = handle_dap_apid_command,
-		.mode = COMMAND_EXEC,
-		.help = "return ID register from AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "baseaddr",
-		.handler = handle_dap_baseaddr_command,
-		.mode = COMMAND_EXEC,
-		.help = "return debug base address from MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "memaccess",
-		.handler = handle_dap_memaccess_command,
-		.mode = COMMAND_EXEC,
-		.help = "set/get number of extra tck for MEM-AP memory "
-			"bus access [0-255]",
-		.usage = "[cycles]",
-	},
-	COMMAND_REGISTRATION_DONE
-};
 const struct command_registration armv7m_command_handlers[] = {
 	{
 		.chain = arm_command_handlers,
 	},
 	{
-		.name = "dap",
-		.mode = COMMAND_EXEC,
-		.help = "Cortex DAP command group",
-		.chain = armv7m_exec_command_handlers,
+		.chain = dap_command_handlers,
 	},
 	COMMAND_REGISTRATION_DONE
 };
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 5526505..51d6704 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -106,7 +106,7 @@ struct armv7m_common
 	struct reg_cache *core_cache;
 	enum armv7m_mode core_mode;
 	int exception_number;
-	struct adiv5_dap swjdp_info;
+	struct adiv5_dap dap;
 
 	uint32_t demcr;
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 0dc7cee..332a55a 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -67,7 +67,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 static int cortex_a8_init_debug_access(struct target *target)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 	int retval;
 	uint32_t dummy;
@@ -103,7 +103,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 	uint32_t dscr;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 	dscr = dscr_p ? *dscr_p : 0;
 
@@ -150,7 +150,7 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 {
 	int retval = ERROR_OK;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 	cortex_a8_dap_read_coreregister_u32(target, regfile, 0);
 	cortex_a8_dap_write_coreregister_u32(target, address, 0);
@@ -169,7 +169,7 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	uint8_t reg = regnum&0xFF;
 	uint32_t dscr = 0;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 	if (reg > 17)
 		return retval;
@@ -221,7 +221,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	uint8_t Rd = regnum&0xFF;
 	uint32_t dscr;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
 
@@ -284,7 +284,7 @@ static int cortex_a8_dap_write_memap_register_u32(struct target *target, uint32_
 {
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 	retval = mem_ap_write_atomic_u32(swjdp, address, value);
 
@@ -310,14 +310,14 @@ static inline struct cortex_a8_common *dpm_to_a8(struct arm_dpm *dpm)
 static int cortex_a8_write_dcc(struct cortex_a8_common *a8, uint32_t data)
 {
 	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
-	return mem_ap_write_u32(&a8->armv7a_common.swjdp_info,
+	return mem_ap_write_u32(&a8->armv7a_common.dap,
 			a8->armv7a_common.debug_base + CPUDBG_DTRRX, data);
 }
 
 static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		uint32_t *dscr_p)
 {
-	struct adiv5_dap *swjdp = &a8->armv7a_common.swjdp_info;
+	struct adiv5_dap *swjdp = &a8->armv7a_common.dap;
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
@@ -344,7 +344,7 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
-	struct adiv5_dap *swjdp = &a8->armv7a_common.swjdp_info;
+	struct adiv5_dap *swjdp = &a8->armv7a_common.dap;
 	uint32_t dscr;
 	int retval;
 
@@ -562,7 +562,7 @@ static int cortex_a8_poll(struct target *target)
 	uint32_t dscr;
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 	enum target_state prev_target_state = target->state;
 	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 
@@ -626,7 +626,7 @@ static int cortex_a8_halt(struct target *target)
 	int retval = ERROR_OK;
 	uint32_t dscr;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 	dap_ap_select(swjdp, swjdp_debugap);
 
@@ -664,7 +664,7 @@ static int cortex_a8_resume(struct target *target, int current,
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 //	struct breakpoint *breakpoint = NULL;
 	uint32_t resume_pc, dscr;
@@ -788,7 +788,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 	struct reg *reg;
 
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
@@ -1276,7 +1276,7 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 	/* cortex_a8 handles unaligned memory access */
@@ -1304,7 +1304,7 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 // ???	dap_ap_select(swjdp, swjdp_memoryap);
@@ -1413,7 +1413,7 @@ static int cortex_a8_handle_target_request(void *priv)
 {
 	struct target *target = priv;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 
 	if (!target_was_examined(target))
 		return ERROR_OK;
@@ -1455,7 +1455,7 @@ static int cortex_a8_examine_first(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7a->dap;
 	int i;
 	int retval = ERROR_OK;
 	uint32_t didr, ctypr, ttypr, cpuid;
@@ -1562,7 +1562,9 @@ static int cortex_a8_init_arch_info(struct target *target,
 {
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
-	struct adiv5_dap *swjdp = &armv7a->swjdp_info;
+	struct adiv5_dap *dap = &armv7a->dap;
+
+	armv7a->armv4_5_common.dap = dap;
 
 	/* Setup struct cortex_a8_common */
 	cortex_a8->common_magic = CORTEX_A8_COMMON_MAGIC;
@@ -1573,11 +1575,11 @@ static int cortex_a8_init_arch_info(struct target *target,
 	cortex_a8->jtag_info.scann_size = 4;
 
 	/* Leave (only) generic DAP stuff for debugport_init() */
-	swjdp->jtag_info = &cortex_a8->jtag_info;
-	swjdp->memaccess_tck = 80;
+	dap->jtag_info = &cortex_a8->jtag_info;
+	dap->memaccess_tck = 80;
 
 	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
-	swjdp->tar_autoincr_block = (1 << 10);
+	dap->tar_autoincr_block = (1 << 10);
 
 	cortex_a8->fast_reg_read = 0;
 
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 852965c..d39d839 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -129,7 +129,7 @@ static int cortex_m3_write_debug_halt_mask(struct target *target,
 		uint32_t mask_on, uint32_t mask_off)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 
 	/* mask off status bits */
 	cortex_m3->dcb_dhcsr &= ~((0xFFFF << 16) | mask_off);
@@ -142,7 +142,7 @@ static int cortex_m3_write_debug_halt_mask(struct target *target,
 static int cortex_m3_clear_halt(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 
 	/* clear step if any */
 	cortex_m3_write_debug_halt_mask(target, C_HALT, C_STEP);
@@ -160,7 +160,7 @@ static int cortex_m3_clear_halt(struct target *target)
 static int cortex_m3_single_step_core(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 	uint32_t dhcsr_save;
 
 	/* backup dhcsr reg */
@@ -191,7 +191,7 @@ static int cortex_m3_endreset_event(struct target *target)
 	uint32_t dcb_demcr;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 	struct cortex_m3_fp_comparator *fp_list = cortex_m3->fp_comparator_list;
 	struct cortex_m3_dwt_comparator *dwt_list = cortex_m3->dwt_comparator_list;
 
@@ -286,7 +286,7 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 {
 	uint32_t shcsr, except_sr, cfsr = -1, except_ar = -1;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 	int retval;
 
 	mem_ap_read_u32(swjdp, NVIC_SHCSR, &shcsr);
@@ -360,7 +360,7 @@ static int cortex_m3_debug_entry(struct target *target)
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
 	struct arm *arm = &armv7m->arm;
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 	struct reg *r;
 
 	LOG_DEBUG(" ");
@@ -452,7 +452,7 @@ static int cortex_m3_poll(struct target *target)
 	int retval;
 	enum target_state prev_target_state = target->state;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 
 	/* Read from Debug Halting Control and Status Register */
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);
@@ -587,7 +587,7 @@ static int cortex_m3_halt(struct target *target)
 static int cortex_m3_soft_reset_halt(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 	uint32_t dcb_dhcsr = 0;
 	int retval, timeout = 0;
 
@@ -761,7 +761,7 @@ static int cortex_m3_step(struct target *target, int current,
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 	struct breakpoint *breakpoint = NULL;
 	struct reg *pc = armv7m->arm.pc;
 	bool bkpt_inst_found = false;
@@ -826,7 +826,7 @@ static int cortex_m3_step(struct target *target, int current,
 static int cortex_m3_assert_reset(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 	int assert_srst = 1;
 
 	LOG_DEBUG("target->state: %s",
@@ -1376,7 +1376,7 @@ static int cortex_m3_load_core_reg_u32(struct target *target,
 {
 	int retval;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 
 	/* NOTE:  we "know" here that the register identifiers used
 	 * in the v7m header match the Cortex-M3 Debug Core Register
@@ -1440,7 +1440,7 @@ static int cortex_m3_store_core_reg_u32(struct target *target,
 	int retval;
 	uint32_t reg;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 
 #ifdef ARMV7_GDB_HACKS
 	/* If the LR register is being modified, make sure it will put us
@@ -1518,7 +1518,7 @@ static int cortex_m3_read_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 	/* cortex_m3 handles unaligned memory access */
@@ -1543,7 +1543,7 @@ static int cortex_m3_write_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
 
 	if (count && buffer) {
@@ -1724,7 +1724,7 @@ static int cortex_m3_examine(struct target *target)
 	uint32_t cpuid, fpcr;
 	int i;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
-	struct adiv5_dap *swjdp = &cortex_m3->armv7m.swjdp_info;
+	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
 
 	if ((retval = ahbap_debugport_init(swjdp)) != ERROR_OK)
 		return retval;
@@ -1798,7 +1798,7 @@ static int cortex_m3_target_request_data(struct target *target,
 		uint32_t size, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 	uint8_t data;
 	uint8_t ctrl;
 	uint32_t i;
@@ -1818,7 +1818,7 @@ static int cortex_m3_handle_target_request(void *priv)
 	if (!target_was_examined(target))
 		return ERROR_OK;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 
 	if (!target->dbg_msg_enabled)
 		return ERROR_OK;
@@ -1862,11 +1862,13 @@ static int cortex_m3_init_arch_info(struct target *target,
 	cortex_m3->jtag_info.tap = tap;
 	cortex_m3->jtag_info.scann_size = 4;
 
+	armv7m->arm.dap = &armv7m->dap;
+
 	/* Leave (only) generic DAP stuff for debugport_init(); */
-	armv7m->swjdp_info.jtag_info = &cortex_m3->jtag_info;
-	armv7m->swjdp_info.memaccess_tck = 8;
+	armv7m->dap.jtag_info = &cortex_m3->jtag_info;
+	armv7m->dap.memaccess_tck = 8;
 	/* Cortex-M3 has 4096 bytes autoincrement range */
-	armv7m->swjdp_info.tar_autoincr_block = (1 << 12);
+	armv7m->dap.tar_autoincr_block = (1 << 12);
 
 	/* register arch-specific functions */
 	armv7m->examine_debug_reason = cortex_m3_examine_debug_reason;
@@ -1936,7 +1938,7 @@ COMMAND_HANDLER(handle_cortex_m3_vector_catch_command)
 	struct target *target = get_current_target(CMD_CTX);
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
-	struct adiv5_dap *swjdp = &armv7m->swjdp_info;
+	struct adiv5_dap *swjdp = &armv7m->dap;
 	uint32_t demcr = 0;
 	int retval;
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm.h        |    6 ++
 src/target/arm_adi_v5.c |  139 ++++++++++++++++++++++++++++++++++++-------
 src/target/arm_adi_v5.h |   13 +----
 src/target/armv7a.c     |  108 +---------------------------------
 src/target/armv7a.h     |    3 +-
 src/target/armv7m.c     |  150 +----------------------------------------------
 src/target/armv7m.h     |    2 +-
 src/target/cortex_a8.c  |   44 +++++++-------
 src/target/cortex_m3.c  |   44 +++++++-------
 9 files changed, 174 insertions(+), 335 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Mar  6 06:09:16 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat,  6 Mar 2010 05:09:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-58-gc6e323b
Message-ID: <E1NnmGL-0001TI-Qk@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c6e323b9838254b338310ec165a5345635c5d177 (commit)
       via  74113cf72570a20f5f2ff66f721284bd4228aee3 (commit)
      from  d33a81c549743e13633db9e8749f0e7cb0f7324b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c6e323b9838254b338310ec165a5345635c5d177
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Mar 5 21:09:03 2010 -0800

    doc: not all debug adapters are "dongles"
    
    Talk more about "debug adapters" instead of only "dongles".  Not all
    adapters are discrete widgets; some are integrated onto boards.  If
    we only talk about "dongles" we rule out many valid setups, and help
    confuse some users (who may be using Dongle-free environments).
    
    Also start bringing out the point that JTAG isn't the only transport
    protocol, even though OpenOCD historically presumes "all is JTAG".
    (Not all debug adapters are JTAG adapters, or JTAG-only adapters.)
    
    Plus a few minor fixes (spelling etc) in the vicinity of those changes,
    and updates about FT2232H clocking issues (they can go faster than the
    older chips, and can support adaptive clocking).
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/manual/server.txt b/doc/manual/server.txt
index 5250f7f..f75f1d1 100644
--- a/doc/manual/server.txt
+++ b/doc/manual/server.txt
@@ -207,7 +207,7 @@ upon it, sometimes that is the only scheme available.
 
 As a small group of developers, supporting all the platforms and
 targets in the debugger will be difficult, as there are enough problem
-with the plethora of Dongles, Chips, and different target boards.
+with the plethora of Adapters, Chips, and different target boards.
 Yes, the TCL interface might be suitable, but it has not received much
 love or attention.  Perhaps it will after you read and understand this.
 
@@ -235,7 +235,7 @@ different host-side GDB..
 Sure - a <em>man on a mission</em> can make that work.  The GUI might be
 libopenocd + Perl/TK, or maybe an Eclipse Plug-in.
 That is a development support nightmare for reasons described
-above. We have enough support problems as it is with targets, dongles,
+above. We have enough support problems as it is with targets, adapters,
 etc.
 
 @section serverdocshttpbg HTTP Server Background
@@ -270,8 +270,8 @@ every peripheral register on the target platform.
 
 That also is transportable, regardless of the OpenOCD host
 platform: Linux/X86, Linux/ARM, FreeBSD, Cygwin, MingW, or MacOSX.
-You could even port OpenOCD to an Google Android and use it as a
-bit-bang dongle JTAG serving web pages.
+You could even port OpenOCD to an Android system and use it as a
+bit-banging JTAG Adapter serving web pages.
 
 @subsection serverdocshtmladv Advanced HTML Pages
 
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 507498f..f9f9b68 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -61,13 +61,13 @@ Free Documentation License''.
 @menu
 * About::                            About OpenOCD
 * Developers::                       OpenOCD Developer Resources
-* JTAG Hardware Dongles::            JTAG Hardware Dongles
+* Debug Adapter Hardware::           Debug Adapter Hardware
 * About JIM-Tcl::                    About JIM-Tcl
 * Running::                          Running OpenOCD
 * OpenOCD Project Setup::            OpenOCD Project Setup
 * Config File Guidelines::           Config File Guidelines
 * Daemon Configuration::             Daemon Configuration
-* Interface - Dongle Configuration:: Interface - Dongle Configuration
+* Debug Adapter Configuration:: Debug Adapter Configuration
 * Reset Configuration::              Reset Configuration
 * TAP Declaration::                  TAP Declaration
 * CPU Configuration::                CPU Configuration
@@ -111,15 +111,47 @@ The Open On-Chip Debugger (OpenOCD) aims to provide debugging,
 in-system programming and boundary-scan testing for embedded target
 devices.
 
- at b{JTAG:} OpenOCD uses a ``hardware interface dongle'' to communicate
-with the JTAG (IEEE 1149.1) compliant TAPs on your target board.
+It does so with the assistance of a @dfn{debug adapter}, which is
+a small hardware module which helps provide the right kind of
+electrical signaling to the target being debugged.  These are
+required since the debug host (on which OpenOCD runs) won't
+usually have native support for such signaling, or the connector
+needed to hook up to the target.
+
+Such debug adapters support one or more @dfn{transport} protocols,
+each of which involves different electrical signaling (and uses
+different messaging protocols on top of that signaling).  There
+are many types of debug adapter, and little uniformity in what
+they are called.  (There are also product naming differences.)
+
+These adapters are sometimes packaged as discrete dongles. which
+may generically be called @dfn{hardware interface dongles}.
+Some development boards also integrate them directly, which may
+let the development board can be directly connected to the debug
+host over USB (and sometimes also to power it over USB).
+
+For example, a @dfn{JTAG Adapter} supports JTAG
+signaling, and is used to communicate
+with JTAG (IEEE 1149.1) compliant TAPs on your target board.
 A @dfn{TAP} is a ``Test Access Port'', a module which processes
 special instructions and data.  TAPs are daisy-chained within and
-between chips and boards.
+between chips and boards.  JTAG supports debugging and boundary
+scan operations.
+
+There are also @dfn{SWD Adapters} that support Serial Wire Debug (SWD)
+signaling to communicate with some newer ARM cores, as well as debug
+adapters which support both JTAG and SWD transports.  SWD only supports
+debugging, whereas JTAG also supports boundary scan operations.
+
+For some chips, there are also @dfn{Programming Adapters} supporting
+special transports used only to write code to flash memory, without
+support for on-chip debugging or boundary scan.
+(At this writing, OpenOCD does not support such non-debug adapters.)
+
 
 @b{Dongles:} OpenOCD currently supports many types of hardware dongles: USB
 based, parallel port based, and other standalone boxes that run
-OpenOCD internally. @xref{JTAG Hardware Dongles}.
+OpenOCD internally. @xref{Debug Adapter Hardware}.
 
 @b{GDB Debug:} It allows ARM7 (ARM7TDMI and ARM720t), ARM9 (ARM920T,
 ARM922T, ARM926EJ--S, ARM966E--S), XScale (PXA25x, IXP42x) and
@@ -234,8 +266,8 @@ using Trac for its bug database:
 @uref{https://sourceforge.net/apps/trac/openocd}
 
 
- at node JTAG Hardware Dongles
- at chapter JTAG Hardware Dongles
+ at node Debug Adapter Hardware
+ at chapter Debug Adapter Hardware
 @cindex dongles
 @cindex FTDI
 @cindex wiggler
@@ -247,9 +279,9 @@ using Trac for its bug database:
 Defined: @b{dongle}: A small device that plugins into a computer and serves as
 an adapter .... [snip]
 
-In the OpenOCD case, this generally refers to @b{a small adapater} one
-attaches to your computer via USB or the Parallel Printer Port.  The
-execption being the Zylin ZY1000 which is a small box you attach via
+In the OpenOCD case, this generally refers to @b{a small adapter} that
+attaches to your computer via USB or the Parallel Printer Port.  One
+exception is the Zylin ZY1000, packaged as a small box you attach via
 an ethernet cable. The Zylin ZY1000 has the advantage that it does not
 require any drivers to be installed on the developer PC. It also has
 a built in web interface. It supports RTCK/RCLK or adaptive clocking
@@ -261,6 +293,9 @@ and has a built in relay to power cycle targets remotely.
 There are several things you should keep in mind when choosing a dongle.
 
 @enumerate
+ at item @b{Transport} Does it support the kind of communication that you need?
+OpenOCD focusses mostly on JTAG.  Your version may also support
+other ways to communicate with target devices.
 @item @b{Voltage} What voltage is your target - 1.8, 2.8, 3.3, or 5V?
 Does your dongle support it?  You might need a level converter.
 @item @b{Pinout} What pinout does your target board use?
@@ -268,7 +303,8 @@ Does your dongle support it?  You may be able to use jumper
 wires, or an "octopus" connector, to convert pinouts.
 @item @b{Connection} Does your computer have the USB, printer, or
 Ethernet port needed?
- at item @b{RTCK} Do you require RTCK? Also known as ``adaptive clocking''
+ at item @b{RTCK} Do you expect to use it with ARM chips and boards with
+RTCK support? Also known as ``adaptive clocking''
 @end enumerate
 
 @section Stand alone Systems
@@ -286,7 +322,17 @@ on a chip from ``Future Technology Devices International'' (FTDI)
 known as the FTDI FT2232; this is a USB full speed (12 Mbps) chip.
 See: @url{http://www.ftdichip.com} for more information.
 In summer 2009, USB high speed (480 Mbps) versions of these FTDI
-chips are starting to become available in JTAG adapters.
+chips are starting to become available in JTAG adapters.  (Adapters
+using those high speed FT2232H chips may support adaptive clocking.)
+
+The FT2232 chips are flexible enough to support some other
+transport options, such as SWD or the SPI variants used to
+program some chips. They have two communications channels,
+and one can be used for a UART adapter at the same time the
+other one is used to provide a debug adapter.
+
+Also, some development boards integrate an FT2232 chip to serve as
+a built-in low coast debug adapter and usb-to-serial solution.
 
 @itemize @bullet
 @item @b{usbjtag}
@@ -303,11 +349,11 @@ chips are starting to become available in JTAG adapters.
 @* See: @url{http://www.luminarymicro.com} - The Stellaris eval boards
 bundle FT2232-based JTAG and SWD support, which can be used to debug
 the Stellaris chips.  Using separate JTAG adapters is optional.
-These boards can also be used as JTAG adapters to other target boards,
-disabling the Stellaris chip.
+These boards can also be used in a "pass through" mode as JTAG adapters
+to other target boards, disabling the Stellaris chip.
 @item @b{Luminary ICDI}
 @* See: @url{http://www.luminarymicro.com} - Luminary In-Circuit Debug
-Interface (ICDI) Boards are included in Stellaris LM3S9B90 and LM3S9B92
+Interface (ICDI) Boards are included in Stellaris LM3S9B9x
 Evaluation Kits.  Like the non-detachable FT2232 support on the other
 Stellaris eval boards, they can be used to debug other target boards.
 @item @b{olimex-jtag}
@@ -507,7 +553,7 @@ as Tcl scripts, from a @file{startup.tcl} file internal to the server.
 @cindex directory search
 
 Properly installing OpenOCD sets up your operating system to grant it access
-to the JTAG adapters.  On Linux, this usually involves installing a file
+to the debug adapters.  On Linux, this usually involves installing a file
 in @file{/etc/udev/rules.d,} so OpenOCD has permissions.  MS-Windows needs
 complex and confusing driver configuration for every peripheral.  Such issues
 are unique to each operating system, and are not detailed in this User's Guide.
@@ -798,7 +844,7 @@ Three main types of non-user configuration file each have their
 own subdirectory in the @file{scripts} directory:
 
 @enumerate
- at item @b{interface} -- one for each kind of JTAG adapter/dongle
+ at item @b{interface} -- one for each different debug adapter;
 @item @b{board} -- one for each different board
 @item @b{target} -- the chips which integrate CPUs and other JTAG TAPs
 @end enumerate
@@ -823,7 +869,8 @@ the board differences are encapsulated by application code.
 @item Maybe you don't know yet what your board looks like to JTAG.
 Once you know the @file{interface.cfg} file to use, you may
 need help from OpenOCD to discover what's on the board.
-Once you find the TAPs, you can just search for appropriate
+Once you find the JTAG TAPs, you can just search for appropriate
+target and board
 configuration files ... or write your own, from the bottom up.
 @xref{Autoprobing}.
 
@@ -849,7 +896,7 @@ will help support users of any board using that chip.
 @item
 You may may need to write some C code.
 It may be as simple as a supporting a new ft2232 or parport
-based dongle; a bit more involved, like a NAND or NOR flash
+based adapter; a bit more involved, like a NAND or NOR flash
 controller driver; or a big piece of work like supporting
 a new chip architecture.
 @end itemize
@@ -1141,7 +1188,8 @@ with files including the ones listed here.
 Use them as-is where you can; or as models for new files.
 @itemize @bullet
 @item @file{interface} ...
-think JTAG Dongle. Files that configure JTAG adapters go here.
+These are for debug adapters.
+Files that configure JTAG adapters go here.
 @example
 $ ls interface
 arm-jtag-ew.cfg          hitex_str9-comstick.cfg  oocdlink.cfg
@@ -1252,13 +1300,15 @@ should be able to source one of these files with a command like this:
 source [find interface/FOOBAR.cfg]
 @end example
 
-A preconfigured interface file should exist for every interface in use
-today, that said, perhaps some interfaces have only been used by the
-sole developer who created it.
+A preconfigured interface file should exist for every debug adapter
+in use today with OpenOCD.
+That said, perhaps some of these config files
+have only been used by the developer who created it.
 
 A separate chapter gives information about how to set these up.
- at xref{Interface - Dongle Configuration}.
-Read the OpenOCD source code if you have a new kind of hardware interface
+ at xref{Debug Adapter Configuration}.
+Read the OpenOCD source code (and Developer's GUide)
+if you have a new kind of hardware interface
 and need to provide a driver for it.
 
 @section Board Config Files
@@ -1987,16 +2037,26 @@ MMU: disabled, D-Cache: disabled, I-Cache: enabled
 @end example
 @end deffn
 
- at node Interface - Dongle Configuration
- at chapter Interface - Dongle Configuration
+ at node Debug Adapter Configuration
+ at chapter Debug Adapter Configuration
 @cindex config file, interface
 @cindex interface config file
 
 Correctly installing OpenOCD includes making your operating system give
-OpenOCD access to JTAG adapters.  Once that has been done, Tcl commands
+OpenOCD access to debug adapters.  Once that has been done, Tcl commands
 are used to select which one is used, and to configure how it is used.
 
-JTAG Adapters/Interfaces/Dongles are normally configured
+ at quotation Note
+Because OpenOCD started out with a focus purely on JTAG, you may find
+places where it wrongly presumes JTAG is the only transport protocol
+in use.  Be aware that recent versions of OpenOCD are removing that
+limitation.  JTAG remains more functional than most other transports.
+Other transports do not support boundary scan operations, or may be
+specific to a given chip vendor.  Some might be usable only for
+programming flash memory, instead of also for debugging.
+ at end quotation
+
+Debug Adapters/Interfaces/Dongles are normally configured
 through commands in an interface configuration
 file which is sourced by your @file{openocd.cfg} file, or
 through a command line @option{-f interface/....cfg} option.
@@ -2019,9 +2079,9 @@ Most adapters need a bit more configuration than that.
 
 @section Interface Configuration
 
-The interface command tells OpenOCD what type of JTAG dongle you are
-using. Depending on the type of dongle, you may need to have one or
-more additional commands.
+The interface command tells OpenOCD what type of debug adapter you are
+using. Depending on the type of adapter, you may need to use one or
+more additional commands to further identify or configure the adapter.
 
 @deffn {Config Command} {interface} name
 Use the interface driver @var{name} to connect to the
@@ -7161,8 +7221,8 @@ that 5 MHz JTAG clock be usable?
 @b{Solution #1 - A special circuit}
 
 In order to make use of this,
-both your CPU and your JTAG dongle must support the RTCK
-feature. Not all dongles support this - keep reading!
+your CPU, board, and JTAG adapter must all support the RTCK
+feature. Not all of them support this; keep reading!
 
 The RTCK ("Return TCK") signal in some ARM chips is used to help with
 this problem. ARM has a good description of the problem described at
@@ -7198,7 +7258,9 @@ depending on the chips on your board.
 ARM11 cores use an 8:1 division.
 @b{Xilinx rule of thumb} is 1/12 the clock speed.
 
-Note: Many FTDI2232C based JTAG dongles are limited to 6MHz.
+Note: most full speed FT2232 based JTAG adapters are limited to a
+maximum of 6MHz.  The ones using USB high speed chips (FT2232H)
+often support faster clock rates (and adaptive clocking).
 
 You can still debug the 'low power' situations - you just need to
 either use a fixed and very slow JTAG clock rate ... or else
diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index b0fe546..fb6068c 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -28,8 +28,9 @@ reset_config trst_and_srst
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-# Use caution changing the delays listed below.  These seem to be affected by the board and type of
-# debugger dongle.  A value of 200 ms seems to work reliably for the configuration listed in the file header above.
+# Use caution changing the delays listed below.  These seem to be
+# affected by the board and type of JTAG adapter.  A value of 200 ms seems
+# to work reliably for the configuration listed in the file header above.
 
 jtag_nsrst_delay 200
 jtag_ntrst_delay 200

commit 74113cf72570a20f5f2ff66f721284bd4228aee3
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Mar 5 13:08:11 2010 -0800

    README: update libftdi version
    
    The FT2232H really wants libftdi 0.17 or newer; some notable
    bugs got fixed in that version.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/README b/README
index b69a69a..a683476 100644
--- a/README
+++ b/README
@@ -317,7 +317,7 @@ The libftdi source code can be download from the following website:
 
 For both Linux and Windows, both libusb and libftdi must be built and
 installed.  To use the newer FT2232H chips, supporting RTCK and USB high
-speed (480 Mbps), you need libftdi version 0.16 or newer.  Many Linux
+speed (480 Mbps), use libftdi version 0.17 or newer.  Many Linux
 distributions provide suitable packages for these libraries.
 
 For Windows, libftdi is supported with versions 0.14 and later.

-----------------------------------------------------------------------

Summary of changes:
 README                       |    2 +-
 doc/manual/server.txt        |    8 +-
 doc/openocd.texi             |  134 ++++++++++++++++++++++++++++++-----------
 tcl/board/at91sam9g20-ek.cfg |    5 +-
 4 files changed, 106 insertions(+), 43 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Mar  6 09:53:43 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Sat,  6 Mar 2010 08:53:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-59-gf7d1be7
Message-ID: <E1NnplY-0007N5-5n@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f7d1be714b91fcc12e56c8fa78c702e75a733019 (commit)
      from  c6e323b9838254b338310ec165a5345635c5d177 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f7d1be714b91fcc12e56c8fa78c702e75a733019
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Mar 6 00:56:36 2010 +0800

    CFI: review print of Voltage values
    
    JEDEC standard reports Vpp integer part encoded as 4 bit HEX value.
    To print it using decimal digits, %u is required.
    Other voltage values are coded as BCD, so %x is appropriate.
    
    Code already prints one nibble at a time, so no need for field width
    and precision in format string.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 42aa294..b0c7b0b 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -361,7 +361,7 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 	pri_ext->vcc_optimal = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xc);
 	pri_ext->vpp_optimal = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xd);
 
-	LOG_DEBUG("Vcc opt: %1.1x.%1.1x, Vpp opt: %1.1x.%1.1x",
+	LOG_DEBUG("Vcc opt: %x.%x, Vpp opt: %u.%x",
 		  (pri_ext->vcc_optimal & 0xf0) >> 4, pri_ext->vcc_optimal & 0x0f,
 		  (pri_ext->vpp_optimal & 0xf0) >> 4, pri_ext->vpp_optimal & 0x0f);
 
@@ -431,7 +431,7 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 	LOG_DEBUG("Burst Mode: 0x%x, Page Mode: 0x%x, ", pri_ext->BurstMode, pri_ext->PageMode);
 
 
-	LOG_DEBUG("Vpp min: %2.2d.%1.1d, Vpp max: %2.2d.%1.1x",
+	LOG_DEBUG("Vpp min: %u.%x, Vpp max: %u.%x",
 		  (pri_ext->VppMin & 0xf0) >> 4, pri_ext->VppMin & 0x0f,
 		  (pri_ext->VppMax & 0xf0) >> 4, pri_ext->VppMax & 0x0f);
 
@@ -554,7 +554,7 @@ static int cfi_spansion_info(struct flash_bank *bank, char *buf, int buf_size)
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, buf_size, "VppMin: %2.2d.%1.1x, VppMax: %2.2d.%1.1x\n",
+	printed = snprintf(buf, buf_size, "VppMin: %u.%x, VppMax: %u.%x\n",
 		(pri_ext->VppMin & 0xf0) >> 4, pri_ext->VppMin & 0x0f,
 		(pri_ext->VppMax & 0xf0) >> 4, pri_ext->VppMax & 0x0f);
 
@@ -579,7 +579,7 @@ static int cfi_intel_info(struct flash_bank *bank, char *buf, int buf_size)
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, buf_size, "Vcc opt: %1.1x.%1.1x, Vpp opt: %1.1x.%1.1x\n",
+	printed = snprintf(buf, buf_size, "Vcc opt: %x.%x, Vpp opt: %u.%x\n",
 		(pri_ext->vcc_optimal & 0xf0) >> 4, pri_ext->vcc_optimal & 0x0f,
 		(pri_ext->vpp_optimal & 0xf0) >> 4, pri_ext->vpp_optimal & 0x0f);
 	buf += printed;
@@ -2285,7 +2285,7 @@ static int cfi_probe(struct flash_bank *bank)
 		cfi_info->block_erase_timeout_max = cfi_query_u8(bank, 0, 0x25);
 		cfi_info->chip_erase_timeout_max = cfi_query_u8(bank, 0, 0x26);
 
-		LOG_DEBUG("Vcc min: %1.1x.%1.1x, Vcc max: %1.1x.%1.1x, Vpp min: %1.1x.%1.1x, Vpp max: %1.1x.%1.1x",
+		LOG_DEBUG("Vcc min: %x.%x, Vcc max: %x.%x, Vpp min: %u.%x, Vpp max: %u.%x",
 			(cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
 			(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
 			(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,
@@ -2568,7 +2568,7 @@ static int cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 	buf += printed;
 	buf_size -= printed;
 
-		printed = snprintf(buf, buf_size, "Vcc min: %1.1x.%1.1x, Vcc max: %1.1x.%1.1x, Vpp min: %1.1x.%1.1x, Vpp max: %1.1x.%1.1x\n",
+		printed = snprintf(buf, buf_size, "Vcc min: %x.%x, Vcc max: %x.%x, Vpp min: %u.%x, Vpp max: %u.%x\n",
 		                   (cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
 	(cfi_info->vcc_max & 0xf0) >> 4, cfi_info->vcc_max & 0x0f,
 	(cfi_info->vpp_min & 0xf0) >> 4, cfi_info->vpp_min & 0x0f,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar  8 08:12:06 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon,  8 Mar 2010 07:12:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-62-g50dc56a
Message-ID: <E1NoX8J-0006hg-RK@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  50dc56a488c6e4d5acdfd73f12e3502e1586c51e (commit)
       via  57d7743639d5092770d79f7c4b12ae694c482750 (commit)
       via  e018c7c1d29e8dabb9b4a90bb9eb3574eb1668bb (commit)
      from  f7d1be714b91fcc12e56c8fa78c702e75a733019 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 50dc56a488c6e4d5acdfd73f12e3502e1586c51e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sat Mar 6 11:29:59 2010 +0100

    jtag: simplify jtag_add_plain_ir/dr_scan
    
    These fn's now clearly just clock out/in bits. No mystical
    fields are involved.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index bce332f..706f2f2 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -388,15 +388,16 @@ void jtag_add_ir_scan(struct jtag_tap *active, struct scan_field *in_fields, tap
 	}
 }
 
-void jtag_add_plain_ir_scan(int in_num_fields, const struct scan_field *in_fields,
+void jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t state)
 {
+	assert(out_bits != NULL);
 	assert(state != TAP_RESET);
 
 	jtag_prelude(state);
 
 	int retval = interface_jtag_add_plain_ir_scan(
-			in_num_fields, in_fields, state);
+			num_bits, out_bits, in_bits, state);
 	jtag_set_error(retval);
 }
 
@@ -469,15 +470,16 @@ void jtag_add_dr_scan(struct jtag_tap *active, int in_num_fields, const struct s
 	jtag_set_error(retval);
 }
 
-void jtag_add_plain_dr_scan(int in_num_fields, const struct scan_field *in_fields,
+void jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t state)
 {
+	assert(out_bits != NULL);
 	assert(state != TAP_RESET);
 
 	jtag_prelude(state);
 
 	int retval;
-	retval = interface_jtag_add_plain_dr_scan(in_num_fields, in_fields, state);
+	retval = interface_jtag_add_plain_dr_scan(num_bits, out_bits, in_bits, state);
 	jtag_set_error(retval);
 }
 
@@ -906,7 +908,7 @@ static int jtag_examine_chain_execute(uint8_t *idcode_buffer, unsigned num_idcod
 	for (unsigned i = 0; i < JTAG_MAX_CHAIN_SIZE; i++)
 		buf_set_u32(idcode_buffer, i * 32, 32, END_OF_CHAIN_FLAG);
 
-	jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
+	jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value, TAP_DRPAUSE);
 	jtag_add_tlr();
 	return jtag_execute_queue();
 }
@@ -1207,7 +1209,7 @@ static int jtag_validate_ircapture(void)
 	field.out_value = ir_test;
 	field.in_value = ir_test;
 
-	jtag_add_plain_ir_scan(1, &field, TAP_IDLE);
+	jtag_add_plain_ir_scan(field.num_bits, field.out_value, field.in_value, TAP_IDLE);
 
 	LOG_DEBUG("IR capture validation scan");
 	retval = jtag_execute_queue();
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 57bc28d..7f7f879 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2009 SoftPLC Corporation                                *
@@ -130,35 +130,6 @@ int interface_jtag_add_ir_scan(struct jtag_tap* active, const struct scan_field
 }
 
 /**
- * see jtag_add_plain_ir_scan()
- *
- */
-int interface_jtag_add_plain_ir_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
-{
-
-	struct jtag_command * cmd		= cmd_queue_alloc(sizeof(struct jtag_command));
-	struct scan_command * scan		= cmd_queue_alloc(sizeof(struct scan_command));
-	struct scan_field * out_fields	= cmd_queue_alloc(in_num_fields * sizeof(struct scan_field));
-
-	jtag_queue_command(cmd);
-
-	cmd->type				= JTAG_SCAN;
-	cmd->cmd.scan			= scan;
-
-	scan->ir_scan			= true;
-	scan->num_fields		= in_num_fields;
-	scan->fields			= out_fields;
-	scan->end_state			= state;
-
-	for (int i = 0; i < in_num_fields; i++)
-		cmd_queue_scan_field_clone(out_fields + i, in_fields + i);
-
-	return ERROR_OK;
-}
-
-
-
-/**
  * see jtag_add_dr_scan()
  *
  */
@@ -324,32 +295,40 @@ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 	assert(target_tap_match);	/* target_tap should be enabled and not bypassed */
 }
 
-/**
- * see jtag_add_plain_dr_scan()
- *
- */
-int interface_jtag_add_plain_dr_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+static int jtag_add_plain_scan(int num_bits, const uint8_t *out_bits,
+		uint8_t *in_bits, tap_state_t state, bool ir_scan)
 {
 	struct jtag_command * cmd		= cmd_queue_alloc(sizeof(struct jtag_command));
 	struct scan_command * scan		= cmd_queue_alloc(sizeof(struct scan_command));
-	struct scan_field * out_fields	= cmd_queue_alloc(in_num_fields * sizeof(struct scan_field));
+	struct scan_field * out_fields	= cmd_queue_alloc(sizeof(struct scan_field));
 
 	jtag_queue_command(cmd);
 
 	cmd->type				= JTAG_SCAN;
 	cmd->cmd.scan			= scan;
 
-	scan->ir_scan			= false;
-	scan->num_fields		= in_num_fields;
+	scan->ir_scan			= ir_scan;
+	scan->num_fields		= 1;
 	scan->fields			= out_fields;
 	scan->end_state			= state;
 
-	for (int i = 0; i < in_num_fields; i++)
-		cmd_queue_scan_field_clone(out_fields + i, in_fields + i);
+	out_fields->num_bits	= num_bits;
+	out_fields->out_value	= buf_cpy(out_bits, cmd_queue_alloc(DIV_ROUND_UP(num_bits, 8)), num_bits);
+	out_fields->in_value	= in_bits;
 
 	return ERROR_OK;
 }
 
+int interface_jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
+{
+	return jtag_add_plain_scan(num_bits, out_bits, in_bits, state, false);
+}
+
+int interface_jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
+{
+	return jtag_add_plain_scan(num_bits, out_bits, in_bits, state, true);
+}
+
 int interface_jtag_add_tlr(void)
 {
 	tap_state_t state = TAP_RESET;
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index fe57db1..ae85961 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -359,12 +359,12 @@ void jtag_add_ir_scan(struct jtag_tap* tap,
 void jtag_add_ir_scan_noverify(struct jtag_tap* tap,
 		const struct scan_field *fields, tap_state_t state);
 /**
- * Duplicate the scan fields passed into the function into an IR SCAN
- * command.  This function assumes that the caller handles extra fields
- * for bypassed TAPs.
+ * Scan out the bits in ir scan mode.
+ *
+ * If in_bits == NULL, discard incoming bits.
  */
-void jtag_add_plain_ir_scan(int num_fields,
-		const struct scan_field* fields, tap_state_t endstate);
+void jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
+		tap_state_t endstate);
 
 
 /**
@@ -390,12 +390,12 @@ void jtag_add_dr_scan(struct jtag_tap* tap, int num_fields,
 void jtag_add_dr_scan_check(struct jtag_tap* tap, int num_fields,
 		struct scan_field* fields, tap_state_t endstate);
 /**
- * Duplicate the scan fields passed into the function into a DR SCAN
- * command.  Unlike jtag_add_dr_scan(), this function assumes that the
- * caller handles extra fields for bypassed TAPs.
+ * Scan out the bits in ir scan mode.
+ *
+ * If in_bits == NULL, discard incoming bits.
  */
-void jtag_add_plain_dr_scan(int num_fields,
-		const struct scan_field* fields, tap_state_t endstate);
+void jtag_add_plain_dr_scan(int num_bits,
+		const uint8_t *out_bits, uint8_t *in_bits, tap_state_t endstate);
 
 /**
  * Defines the type of data passed to the jtag_callback_t interface.
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 4631593..59b2a32 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -53,14 +53,14 @@ int interface_jtag_add_ir_scan(struct jtag_tap* active,
 		const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_ir_scan(
-		int num_fields, const struct scan_field* fields,
+		int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t endstate);
 
 int interface_jtag_add_dr_scan(struct jtag_tap* active,
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_dr_scan(
-		int num_fields, const struct scan_field* fields,
+		int num_bits, const uint8_t *out_bits, uint8_t *in_bits,
 		tap_state_t endstate);
 
 int interface_jtag_add_tlr(void);
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 1eef087..46ec9c3 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -54,7 +54,7 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field
 
 }
 
-int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
@@ -68,7 +68,7 @@ int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const st
 	return ERROR_OK;
 }
 
-int interface_jtag_add_plain_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 391d8f2..65d8402 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -611,9 +611,14 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field
 
 
 
-int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
-	scanFields(num_fields, fields, TAP_IRSHIFT, 1);
+	struct scan_field field;
+	field.num_bits	= num_bits;
+	field.out_value	= out_bits;
+	field.in_value	= in_bits;
+
+	scanFields(1, &field, TAP_IRSHIFT, 1);
 	gotoEndState(state);
 
 	return ERROR_OK;
@@ -644,9 +649,14 @@ int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const st
 	return ERROR_OK;
 }
 
-int interface_jtag_add_plain_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
-	scanFields(num_fields, fields, TAP_DRSHIFT, 1);
+	struct scan_field field;
+	field.num_bits	= num_bits;
+	field.out_value	= out_bits;
+	field.in_value	= in_bits;
+
+	scanFields(1, &field, TAP_DRSHIFT, 1);
 	gotoEndState(state);
 	return ERROR_OK;
 }
diff --git a/src/svf/svf.c b/src/svf/svf.c
index 28595d5..fba499c 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -1084,7 +1084,7 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			field.out_value = &svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &svf_tdi_buffer[svf_buffer_index];
 			/* NOTE:  doesn't use SVF-specified state paths */
-			jtag_add_plain_dr_scan(1, &field, svf_para.dr_end_state);
+			jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value, svf_para.dr_end_state);
 
 			svf_buffer_index += (i + 7) >> 3;
 		}
@@ -1179,7 +1179,8 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			field.out_value = &svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &svf_tdi_buffer[svf_buffer_index];
 			/* NOTE:  doesn't use SVF-specified state paths */
-			jtag_add_plain_ir_scan(1, &field, svf_para.ir_end_state);
+			jtag_add_plain_ir_scan(field.num_bits, field.out_value, field.in_value,
+					svf_para.ir_end_state);
 
 			svf_buffer_index += (i + 7) >> 3;
 		}
diff --git a/src/target/avrt.c b/src/target/avrt.c
index 5d912da..720261e 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -190,12 +190,8 @@ int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_l
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = tap->ir_length;
-		field[0].out_value = ir_out;
-		field[0].in_value = ir_in;
-		jtag_add_plain_ir_scan(ARRAY_SIZE(field), field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in,
+				jtag_set_end_state(TAP_IDLE));
 	}
 
 	return ERROR_OK;
@@ -210,12 +206,7 @@ int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_l
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = dr_len;
-		field[0].out_value = dr_out;
-		field[0].in_value = dr_in;
-		jtag_add_plain_dr_scan(ARRAY_SIZE(field), field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, jtag_set_end_state(TAP_IDLE));
 	}
 
 	return ERROR_OK;
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index a379121..4be7f3b 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -863,12 +863,7 @@ int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = tap->ir_length;
-		field[0].out_value = ir_out;
-		field[0].in_value = ir_in;
-		jtag_add_plain_ir_scan(ARRAY_SIZE(field), field,
+		jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in,
 				       jtag_set_end_state(TAP_IDLE));
 	}
 
@@ -885,12 +880,7 @@ int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
 	}
 
 	{
-		struct scan_field field[1];
-
-		field[0].num_bits = dr_len;
-		field[0].out_value = dr_out;
-		field[0].in_value = dr_in;
-		jtag_add_plain_dr_scan(ARRAY_SIZE(field), field,
+		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in,
 				       jtag_set_end_state(TAP_IDLE));
 	}
 
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 14bed8e..f2c1a42 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -481,7 +481,8 @@ COMMAND_HANDLER(handle_xsvf_command)
 					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 
 					if (tap == NULL)
-						jtag_add_plain_dr_scan(1, &field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value,
+								jtag_set_end_state(TAP_DRPAUSE));
 					else
 						jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
 
@@ -702,7 +703,8 @@ COMMAND_HANDLER(handle_xsvf_command)
 
 
 					if (tap == NULL)
-						jtag_add_plain_ir_scan(1, &field, my_end_state);
+						jtag_add_plain_ir_scan(field.num_bits,
+								field.out_value, field.in_value, my_end_state);
 					else
 						jtag_add_ir_scan(tap, &field, my_end_state);
 
@@ -936,7 +938,8 @@ COMMAND_HANDLER(handle_xsvf_command)
 						LOG_USER("LSDR retry %d", attempt);
 
 					if (tap == NULL)
-						jtag_add_plain_dr_scan(1, &field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value,
+								jtag_set_end_state(TAP_DRPAUSE));
 					else
 						jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
 

commit 57d7743639d5092770d79f7c4b12ae694c482750
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 4 14:38:19 2010 +0100

    jtag: jtag_add_ir_scan() now takes a single field
    
    In the code a single field was all that was ever used. Makes
    jtag_add_ir_scan() simpler and leaves more complicated stuff
    to jtag_add_plain_ir_scan().
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 3796a4b..b6d24f5 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -48,7 +48,7 @@ int str9xpec_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &field, end_state);
+		jtag_add_ir_scan(tap, &field, end_state);
 
 		free(field.out_value);
 	}
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 2e09cb6..bce332f 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -42,7 +42,8 @@
 /// The number of JTAG queue flushes (for profiling and debugging purposes).
 static int jtag_flush_queue_count;
 
-static void jtag_add_scan_check(struct jtag_tap *active, void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
+static void jtag_add_scan_check(struct jtag_tap *active,
+		void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
 		int in_num_fields, struct scan_field *in_fields, tap_state_t state);
 
 /**
@@ -352,17 +353,22 @@ void jtag_alloc_in_value32(struct scan_field *field)
 	interface_jtag_alloc_in_value32(field);
 }
 
-void jtag_add_ir_scan_noverify(struct jtag_tap *active, int in_count, const struct scan_field *in_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap *active, const struct scan_field *in_fields,
 		tap_state_t state)
 {
 	jtag_prelude(state);
 
-	int retval = interface_jtag_add_ir_scan(active, in_count, in_fields, state);
+	int retval = interface_jtag_add_ir_scan(active, in_fields, state);
 	jtag_set_error(retval);
 }
 
+static void jtag_add_ir_scan_noverify_callback(struct jtag_tap *active, int dummy, const struct scan_field *in_fields,
+		tap_state_t state)
+{
+	jtag_add_ir_scan_noverify(active, in_fields, state);
+}
 
-void jtag_add_ir_scan(struct jtag_tap *active, int in_num_fields, struct scan_field *in_fields, tap_state_t state)
+void jtag_add_ir_scan(struct jtag_tap *active, struct scan_field *in_fields, tap_state_t state)
 {
 	assert(state != TAP_RESET);
 
@@ -370,18 +376,15 @@ void jtag_add_ir_scan(struct jtag_tap *active, int in_num_fields, struct scan_fi
 	{
 		/* 8 x 32 bit id's is enough for all invocations */
 
-		for (int j = 0; j < in_num_fields; j++)
-		{
-			/* if we are to run a verification of the ir scan, we need to get the input back.
-			 * We may have to allocate space if the caller didn't ask for the input back.
-			 */
-			in_fields[j].check_value = active->expected;
-			in_fields[j].check_mask = active->expected_mask;
-		}
-		jtag_add_scan_check(active, jtag_add_ir_scan_noverify, in_num_fields, in_fields, state);
+		/* if we are to run a verification of the ir scan, we need to get the input back.
+		 * We may have to allocate space if the caller didn't ask for the input back.
+		 */
+		in_fields->check_value = active->expected;
+		in_fields->check_mask = active->expected_mask;
+		jtag_add_scan_check(active, jtag_add_ir_scan_noverify_callback, 1, in_fields, state);
 	} else
 	{
-		jtag_add_ir_scan_noverify(active, in_num_fields, in_fields, state);
+		jtag_add_ir_scan_noverify(active, in_fields, state);
 	}
 }
 
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 673d191..57bc28d 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -74,7 +74,7 @@ static void cmd_queue_scan_field_clone(struct scan_field * dst, const struct sca
  * see jtag_add_ir_scan()
  *
  */
-int interface_jtag_add_ir_scan(struct jtag_tap* active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap* active, const struct scan_field *in_fields, tap_state_t state)
 {
 	size_t num_taps = jtag_tap_count_enabled();
 
@@ -106,8 +106,7 @@ int interface_jtag_add_ir_scan(struct jtag_tap* active, int in_num_fields, const
 			/* if TAP is listed in input fields, copy the value */
 			tap->bypass = 0;
 
-			for (int j = 0; j < in_num_fields; j++)
-				cmd_queue_scan_field_clone(field, in_fields + j);
+			cmd_queue_scan_field_clone(field, in_fields);
 		} else
 		{
 			/* if a TAP isn't listed in input fields, set it to BYPASS */
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 6e21024..fe57db1 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -350,13 +350,13 @@ int jtag_init_inner(struct command_context *cmd_ctx);
  * subsequent DR SCANs.
  *
  */
-void jtag_add_ir_scan(struct jtag_tap* tap, int num_fields,
+void jtag_add_ir_scan(struct jtag_tap* tap,
 		struct scan_field* fields, tap_state_t endstate);
 /**
  * The same as jtag_add_ir_scan except no verification is performed out
  * the output values.
  */
-void jtag_add_ir_scan_noverify(struct jtag_tap* tap, int num_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap* tap,
 		const struct scan_field *fields, tap_state_t state);
 /**
  * Duplicate the scan fields passed into the function into an IR SCAN
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index a417216..4631593 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -50,7 +50,7 @@
 #include <jtag/minidriver_imp.h>
 
 int interface_jtag_add_ir_scan(struct jtag_tap* active,
-		int num_fields, const struct scan_field* fields,
+		const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_ir_scan(
 		int num_fields, const struct scan_field* fields,
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 98b449f..1eef087 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -46,7 +46,7 @@ int interface_jtag_execute_queue(void)
 	return ERROR_OK;
 }
 
-int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field *fields, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index da01f81..1073abc 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1490,6 +1490,15 @@ COMMAND_HANDLER(handle_irscan_command)
 	}
 
 	int num_fields = CMD_ARGC / 2;
+	if (num_fields > 1)
+	{
+		/* we really should be looking at plain_ir_scan if we want
+		 * anything more fancy.
+		 */
+		LOG_ERROR("Specify a single value for tap");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
 	size_t fields_len = sizeof(struct scan_field) * num_fields;
 	fields = malloc(fields_len);
 	memset(fields, 0, fields_len);
@@ -1521,7 +1530,7 @@ COMMAND_HANDLER(handle_irscan_command)
 	}
 
 	/* did we have an endstate? */
-	jtag_add_ir_scan(tap, num_fields, fields, endstate);
+	jtag_add_ir_scan(tap, fields, endstate);
 
 	retval = jtag_execute_queue();
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 0b11258..391d8f2 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -574,13 +574,11 @@ static __inline void scanFields(int num_fields, const struct scan_field *fields,
 	}
 }
 
-int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field *fields, tap_state_t state)
 {
 	int scan_size = 0;
 	struct jtag_tap *tap, *nextTap;
 
-	assert(num_fields == 1);
-
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
@@ -590,7 +588,7 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const st
 		/* search the list */
 		if (tap == active)
 		{
-			scanFields(num_fields, fields, TAP_IRSHIFT, pause);
+			scanFields(1, fields, TAP_IRSHIFT, pause);
 			/* update device information */
 			buf_cpy(fields[0].out_value, tap->cur_instr, scan_size);
 
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index 15685e6..976535b 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -40,7 +40,7 @@ static int virtex2_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_ir_scan(tap, &field, jtag_set_end_state(TAP_IDLE));
 
 		free(field.out_value);
 	}
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index f049059..2b7b4e4 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -49,13 +49,13 @@ static const tap_state_t arm11_move_pi_to_si_via_ci[] =
 
 
 /* REVISIT no error handling here! */
-static void arm11_add_ir_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
+static void arm11_add_ir_scan_vc(struct jtag_tap *tap, struct scan_field *fields,
 		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_IRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
-	jtag_add_ir_scan(tap, num_fields, fields, state);
+	jtag_add_ir_scan(tap, fields, state);
 }
 
 static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
@@ -149,7 +149,7 @@ void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 
 	arm11_setup_field(arm11, 5, &instr, NULL, &field);
 
-	arm11_add_ir_scan_vc(arm11->arm.target->tap, 1, &field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
+	arm11_add_ir_scan_vc(arm11->arm.target->tap, &field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
 }
 
 /** Verify data shifted out from Scan Chain Register (SCREG). */
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index 3e27b76..5ed104c 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -45,13 +45,13 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 
 	if (no_verify_capture == NULL)
 	{
-		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
 	} else
 	{
 		/* FIX!!!! this is a kludge!!! arm926ejs.c should reimplement this arm_jtag_set_instr to
 		 * have special verification code.
 		 */
-		jtag_add_ir_scan_noverify(tap, 1, &field, jtag_get_end_state());
+		jtag_add_ir_scan_noverify(tap, &field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/target/etb.c b/src/target/etb.c
index 1f73ff5..2c4e3eb 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -60,7 +60,7 @@ static int etb_set_instr(struct etb *etb, uint32_t new_instr)
 
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
 
 		free(field.out_value);
 	}
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 79160fc..e0550a8 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -46,7 +46,7 @@ int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr, void *del
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 4973898..602034e 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -173,7 +173,7 @@ static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		field.out_value = scratch;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
-		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index faa5542..14bed8e 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -704,7 +704,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_ir_scan(1, &field, my_end_state);
 					else
-						jtag_add_ir_scan(tap, 1, &field, my_end_state);
+						jtag_add_ir_scan(tap, &field, my_end_state);
 
 					if (xruntest)
 					{

commit e018c7c1d29e8dabb9b4a90bb9eb3574eb1668bb
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 1 20:00:59 2010 +0100

    jtag: retire tap field
    
    jtag_add_dr/ir_scan() now takes the tap as the first
    argument, rather than for each of the fields passed
    in.
    
    The code never exercised the path where there was
    more than one tap being scanned, who knows if it even
    worked.
    
    This simplifies the implementation and reduces clutter
    in the calling code.
    
    use jtag_add_ir/dr_plain_scan() for more fancy situations.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 243336a..3796a4b 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -43,13 +43,12 @@ int str9xpec_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end
 	{
 		struct scan_field field;
 
-		field.tap = tap;
 		field.num_bits = tap->ir_length;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &field, end_state);
+		jtag_add_ir_scan(tap, 1, &field, end_state);
 
 		free(field.out_value);
 	}
@@ -65,13 +64,12 @@ static uint8_t str9xpec_isc_status(struct jtag_tap *tap)
 	if (str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE) != ERROR_OK)
 		return ISC_STATUS_ERROR;
 
-	field.tap = tap;
 	field.num_bits = 8;
 	field.out_value = NULL;
 	field.in_value = &status;
 
 
-	jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	LOG_DEBUG("status: 0x%2.2x", status);
@@ -153,13 +151,12 @@ static int str9xpec_read_config(struct flash_bank *bank)
 	/* execute ISC_CONFIGURATION command */
 	str9xpec_set_instr(tap, ISC_CONFIGURATION, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = NULL;
 	field.in_value = str9xpec_info->options;
 
 
-	jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	status = str9xpec_isc_status(tap);
@@ -301,21 +298,19 @@ static int str9xpec_blank_check(struct flash_bank *bank, int first, int last)
 	/* execute ISC_BLANK_CHECK command */
 	str9xpec_set_instr(tap, ISC_BLANK_CHECK, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = buffer;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 	jtag_add_sleep(40000);
 
 	/* read blank check result */
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = NULL;
 	field.in_value = buffer;
 
-	jtag_add_dr_scan(1, &field, TAP_IRPAUSE);
+	jtag_add_dr_scan(tap, 1, &field, TAP_IRPAUSE);
 	jtag_execute_queue();
 
 	status = str9xpec_isc_status(tap);
@@ -407,12 +402,11 @@ static int str9xpec_erase_area(struct flash_bank *bank, int first, int last)
 	/* execute ISC_ERASE command */
 	str9xpec_set_instr(tap, ISC_ERASE, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = buffer;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	jtag_add_sleep(10);
@@ -468,12 +462,11 @@ static int str9xpec_lock_device(struct flash_bank *bank)
 	str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 	do {
-		field.tap = tap;
 		field.num_bits = 8;
 		field.out_value = NULL;
 		field.in_value = &status;
 
-		jtag_add_dr_scan(1, &field, jtag_get_end_state());
+		jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
 		jtag_execute_queue();
 
 	} while (!(status & ISC_STATUS_BUSY));
@@ -549,12 +542,11 @@ static int str9xpec_set_address(struct flash_bank *bank, uint8_t sector)
 	/* set flash controller address */
 	str9xpec_set_instr(tap, ISC_ADDRESS_SHIFT, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 8;
 	field.out_value = &sector;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
 
 	return ERROR_OK;
 }
@@ -633,12 +625,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 		{
 			str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
-			field.tap = tap;
 			field.num_bits = 64;
 			field.out_value = (buffer + bytes_written);
 			field.in_value = NULL;
 
-			jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 
 			/* small delay before polling */
 			jtag_add_sleep(50);
@@ -646,12 +637,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 			str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 			do {
-				field.tap = tap;
 				field.num_bits = 8;
 				field.out_value = NULL;
 				field.in_value = scanbuf;
 
-				jtag_add_dr_scan(1, &field, jtag_get_end_state());
+				jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
 				jtag_execute_queue();
 
 				status = buf_get_u32(scanbuf, 0, 8);
@@ -683,12 +673,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 
 		str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
-		field.tap = tap;
 		field.num_bits = 64;
 		field.out_value = last_dword;
 		field.in_value = NULL;
 
-		jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 
 		/* small delay before polling */
 		jtag_add_sleep(50);
@@ -696,12 +685,11 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 		str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 		do {
-			field.tap = tap;
 			field.num_bits = 8;
 			field.out_value = NULL;
 			field.in_value = scanbuf;
 
-			jtag_add_dr_scan(1, &field, jtag_get_end_state());
+			jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
 			jtag_execute_queue();
 
 			status = buf_get_u32(scanbuf, 0, 8);
@@ -750,12 +738,11 @@ COMMAND_HANDLER(str9xpec_handle_part_id_command)
 
 	str9xpec_set_instr(tap, ISC_IDCODE, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 32;
 	field.out_value = NULL;
 	field.in_value = buffer;
 
-	jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 	jtag_execute_queue();
 
 	idcode = buf_get_u32(buffer, 0, 32);
@@ -867,12 +854,11 @@ static int str9xpec_write_options(struct flash_bank *bank)
 	/* execute ISC_PROGRAM command */
 	str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
-	field.tap = tap;
 	field.num_bits = 64;
 	field.out_value = str9xpec_info->options;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 
 	/* small delay before polling */
 	jtag_add_sleep(50);
@@ -880,12 +866,11 @@ static int str9xpec_write_options(struct flash_bank *bank)
 	str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 	do {
-		field.tap = tap;
 		field.num_bits = 8;
 		field.out_value = NULL;
 		field.in_value = &status;
 
-		jtag_add_dr_scan(1, &field, jtag_get_end_state());
+		jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
 		jtag_execute_queue();
 
 	} while (!(status & ISC_STATUS_BUSY));
diff --git a/src/jtag/core.c b/src/jtag/core.c
index d43bd1c..2e09cb6 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -42,7 +42,7 @@
 /// The number of JTAG queue flushes (for profiling and debugging purposes).
 static int jtag_flush_queue_count;
 
-static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
+static void jtag_add_scan_check(struct jtag_tap *active, void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
 		int in_num_fields, struct scan_field *in_fields, tap_state_t state);
 
 /**
@@ -352,17 +352,17 @@ void jtag_alloc_in_value32(struct scan_field *field)
 	interface_jtag_alloc_in_value32(field);
 }
 
-void jtag_add_ir_scan_noverify(int in_count, const struct scan_field *in_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap *active, int in_count, const struct scan_field *in_fields,
 		tap_state_t state)
 {
 	jtag_prelude(state);
 
-	int retval = interface_jtag_add_ir_scan(in_count, in_fields, state);
+	int retval = interface_jtag_add_ir_scan(active, in_count, in_fields, state);
 	jtag_set_error(retval);
 }
 
 
-void jtag_add_ir_scan(int in_num_fields, struct scan_field *in_fields, tap_state_t state)
+void jtag_add_ir_scan(struct jtag_tap *active, int in_num_fields, struct scan_field *in_fields, tap_state_t state)
 {
 	assert(state != TAP_RESET);
 
@@ -375,13 +375,13 @@ void jtag_add_ir_scan(int in_num_fields, struct scan_field *in_fields, tap_state
 			/* if we are to run a verification of the ir scan, we need to get the input back.
 			 * We may have to allocate space if the caller didn't ask for the input back.
 			 */
-			in_fields[j].check_value = in_fields[j].tap->expected;
-			in_fields[j].check_mask = in_fields[j].tap->expected_mask;
+			in_fields[j].check_value = active->expected;
+			in_fields[j].check_mask = active->expected_mask;
 		}
-		jtag_add_scan_check(jtag_add_ir_scan_noverify, in_num_fields, in_fields, state);
+		jtag_add_scan_check(active, jtag_add_ir_scan_noverify, in_num_fields, in_fields, state);
 	} else
 	{
-		jtag_add_ir_scan_noverify(in_num_fields, in_fields, state);
+		jtag_add_ir_scan_noverify(active, in_num_fields, in_fields, state);
 	}
 }
 
@@ -405,7 +405,7 @@ static int jtag_check_value_mask_callback(jtag_callback_data_t data0, jtag_callb
 	return jtag_check_value_inner((uint8_t *)data0, (uint8_t *)data1, (uint8_t *)data2, (int)data3);
 }
 
-static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
+static void jtag_add_scan_check(struct jtag_tap *active, void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
 		int in_num_fields, struct scan_field *in_fields, tap_state_t state)
 {
 	for (int i = 0; i < in_num_fields; i++)
@@ -419,7 +419,7 @@ static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const s
 		field->modified = 1;
 	}
 
-	jtag_add_scan(in_num_fields, in_fields, state);
+	jtag_add_scan(active, in_num_fields, in_fields, state);
 
 	for (int i = 0; i < in_num_fields; i++)
 	{
@@ -442,19 +442,19 @@ static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const s
 	}
 }
 
-void jtag_add_dr_scan_check(int in_num_fields, struct scan_field *in_fields, tap_state_t state)
+void jtag_add_dr_scan_check(struct jtag_tap *active, int in_num_fields, struct scan_field *in_fields, tap_state_t state)
 {
 	if (jtag_verify)
 	{
-		jtag_add_scan_check(jtag_add_dr_scan, in_num_fields, in_fields, state);
+		jtag_add_scan_check(active, jtag_add_dr_scan, in_num_fields, in_fields, state);
 	} else
 	{
-		jtag_add_dr_scan(in_num_fields, in_fields, state);
+		jtag_add_dr_scan(active, in_num_fields, in_fields, state);
 	}
 }
 
 
-void jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fields,
+void jtag_add_dr_scan(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields,
 		tap_state_t state)
 {
 	assert(state != TAP_RESET);
@@ -462,7 +462,7 @@ void jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fields,
 	jtag_prelude(state);
 
 	int retval;
-	retval = interface_jtag_add_dr_scan(in_num_fields, in_fields, state);
+	retval = interface_jtag_add_dr_scan(active, in_num_fields, in_fields, state);
 	jtag_set_error(retval);
 }
 
@@ -894,7 +894,6 @@ void jtag_sleep(uint32_t us)
 static int jtag_examine_chain_execute(uint8_t *idcode_buffer, unsigned num_idcode)
 {
 	struct scan_field field = {
-			.tap = NULL,
 			.num_bits = num_idcode * 32,
 			.out_value = idcode_buffer,
 			.in_value = idcode_buffer,
@@ -1201,7 +1200,6 @@ static int jtag_validate_ircapture(void)
 	/* after this scan, all TAPs will capture BYPASS instructions */
 	buf_set_ones(ir_test, total_ir_length);
 
-	field.tap = NULL;
 	field.num_bits = total_ir_length;
 	field.out_value = ir_test;
 	field.in_value = ir_test;
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index ca59239..673d191 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -64,7 +64,6 @@ static void jtag_callback_queue_reset(void)
  */
 static void cmd_queue_scan_field_clone(struct scan_field * dst, const struct scan_field * src)
 {
-	dst->tap		= src->tap;
 	dst->num_bits	= src->num_bits;
 	dst->out_value	= buf_cpy(src->out_value, cmd_queue_alloc(DIV_ROUND_UP(src->num_bits, 8)), src->num_bits);
 	dst->in_value	= src->in_value;
@@ -75,7 +74,7 @@ static void cmd_queue_scan_field_clone(struct scan_field * dst, const struct sca
  * see jtag_add_ir_scan()
  *
  */
-int interface_jtag_add_ir_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap* active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
 {
 	size_t num_taps = jtag_tap_count_enabled();
 
@@ -102,33 +101,19 @@ int interface_jtag_add_ir_scan(int in_num_fields, const struct scan_field *in_fi
 	{
 		/* search the input field list for fields for the current TAP */
 
-		bool found = false;
-
-		for (int j = 0; j < in_num_fields; j++)
+		if (tap == active)
 		{
-			if (tap != in_fields[j].tap)
-				continue;
-
 			/* if TAP is listed in input fields, copy the value */
-
-			found = true;
-
 			tap->bypass = 0;
 
-			assert(in_fields[j].num_bits == tap->ir_length); /* input fields must have the same length as the TAP's IR */
-
-			cmd_queue_scan_field_clone(field, in_fields + j);
-
-			break;
-		}
-
-		if (!found)
+			for (int j = 0; j < in_num_fields; j++)
+				cmd_queue_scan_field_clone(field, in_fields + j);
+		} else
 		{
 			/* if a TAP isn't listed in input fields, set it to BYPASS */
 
 			tap->bypass = 1;
 
-			field->tap			= tap;
 			field->num_bits		= tap->ir_length;
 			field->out_value	= buf_set_ones(cmd_queue_alloc(DIV_ROUND_UP(tap->ir_length, 8)), tap->ir_length);
 			field->in_value		= NULL; /* do not collect input for tap's in bypass */
@@ -178,7 +163,7 @@ int interface_jtag_add_plain_ir_scan(int in_num_fields, const struct scan_field
  * see jtag_add_dr_scan()
  *
  */
-int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
+int interface_jtag_add_dr_scan(struct jtag_tap* active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state)
 {
 	/* count devices in bypass */
 
@@ -215,6 +200,7 @@ int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fi
 
 		if (!tap->bypass)
 		{
+			assert(active == tap);
 #ifndef NDEBUG
 			/* remember initial position for assert() */
 			struct scan_field *start_field = field;
@@ -222,9 +208,6 @@ int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fi
 
 			for (int j = 0; j < in_num_fields; j++)
 			{
-				if (tap != in_fields[j].tap)
-					continue;
-
 				cmd_queue_scan_field_clone(field, in_fields + j);
 
 				field++;
@@ -236,7 +219,6 @@ int interface_jtag_add_dr_scan(int in_num_fields, const struct scan_field *in_fi
 		/* if a TAP is bypassed, generated a dummy bit*/
 		else
 		{
-			field->tap			= tap;
 			field->num_bits		= 1;
 			field->out_value	= NULL;
 			field->in_value		= NULL;
@@ -320,7 +302,6 @@ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 				size_t scan_size = num_bits[j];
 				buf_set_u32(out_value, 0, scan_size, value[j]);
 
-				field->tap			= tap;
 				field->num_bits		= scan_size;
 				field->out_value	= buf_cpy(out_value, cmd_queue_alloc(DIV_ROUND_UP(scan_size, 8)), scan_size);
 				field->in_value		= NULL;
@@ -333,7 +314,6 @@ void interface_jtag_add_dr_out(struct jtag_tap *target_tap,
 		else
 		{
 
-			field->tap				= tap;
 			field->num_bits			= 1;
 			field->out_value		= NULL;
 			field->in_value			= NULL;
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 7e5dc10..6e21024 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -109,9 +109,6 @@ extern tap_state_t cmd_queue_cur_state;
  * The allocated, modified, and intmp fields are internal work space.
  */
 struct scan_field {
-	/// A pointer to the tap structure to which this field refers.
-	struct jtag_tap* tap;
-
 	/// The number of bits this field specifies (up to 32)
 	int num_bits;
 	/// A pointer to value to be scanned into the device
@@ -353,13 +350,13 @@ int jtag_init_inner(struct command_context *cmd_ctx);
  * subsequent DR SCANs.
  *
  */
-void jtag_add_ir_scan(int num_fields,
+void jtag_add_ir_scan(struct jtag_tap* tap, int num_fields,
 		struct scan_field* fields, tap_state_t endstate);
 /**
  * The same as jtag_add_ir_scan except no verification is performed out
  * the output values.
  */
-void jtag_add_ir_scan_noverify(int num_fields,
+void jtag_add_ir_scan_noverify(struct jtag_tap* tap, int num_fields,
 		const struct scan_field *fields, tap_state_t state);
 /**
  * Duplicate the scan fields passed into the function into an IR SCAN
@@ -387,10 +384,10 @@ void jtag_alloc_in_value32(struct scan_field *field);
  * specified there.  For bypassed TAPs, the function generates a dummy
  * 1-bit field.  The bypass status of TAPs is set by jtag_add_ir_scan().
  */
-void jtag_add_dr_scan(int num_fields,
+void jtag_add_dr_scan(struct jtag_tap* tap, int num_fields,
 		const struct scan_field* fields, tap_state_t endstate);
 /// A version of jtag_add_dr_scan() that uses the check_value/mask fields
-void jtag_add_dr_scan_check(int num_fields,
+void jtag_add_dr_scan_check(struct jtag_tap* tap, int num_fields,
 		struct scan_field* fields, tap_state_t endstate);
 /**
  * Duplicate the scan fields passed into the function into a DR SCAN
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 810bb0e..a417216 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -49,14 +49,14 @@
 // and it may provide additional declarations that must be defined.
 #include <jtag/minidriver_imp.h>
 
-int interface_jtag_add_ir_scan(
+int interface_jtag_add_ir_scan(struct jtag_tap* active,
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_ir_scan(
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 
-int interface_jtag_add_dr_scan(
+int interface_jtag_add_dr_scan(struct jtag_tap* active,
 		int num_fields, const struct scan_field* fields,
 		tap_state_t endstate);
 int interface_jtag_add_plain_dr_scan(
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 01cdd2e..98b449f 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -46,7 +46,7 @@ int interface_jtag_execute_queue(void)
 	return ERROR_OK;
 }
 
-int interface_jtag_add_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
@@ -61,7 +61,7 @@ int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fi
 	return ERROR_OK;
 }
 
-int interface_jtag_add_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
 	/* synchronously do the operation here */
 
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index ffb5d27..da01f81 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -175,7 +175,6 @@ static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args
 		Jim_GetLong(interp, args[i], &bits);
 		str = Jim_GetString(args[i + 1], &len);
 
-		fields[field_count].tap = tap;
 		fields[field_count].num_bits = bits;
 		fields[field_count].out_value = malloc(DIV_ROUND_UP(bits, 8));
 		str_to_buf(str, len, fields[field_count].out_value, bits, 0);
@@ -183,7 +182,7 @@ static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args
 		field_count++;
 	}
 
-	jtag_add_dr_scan(num_fields, fields, endstate);
+	jtag_add_dr_scan(tap, num_fields, fields, endstate);
 
 	retval = jtag_execute_queue();
 	if (retval != ERROR_OK)
@@ -1462,7 +1461,7 @@ COMMAND_HANDLER(handle_irscan_command)
 {
 	int i;
 	struct scan_field *fields;
-	struct jtag_tap *tap;
+	struct jtag_tap *tap = NULL;
 	tap_state_t endstate;
 
 	if ((CMD_ARGC < 2) || (CMD_ARGC % 2))
@@ -1510,7 +1509,6 @@ COMMAND_HANDLER(handle_irscan_command)
 			return ERROR_FAIL;
 		}
 		int field_size = tap->ir_length;
-		fields[i].tap = tap;
 		fields[i].num_bits = field_size;
 		fields[i].out_value = malloc(DIV_ROUND_UP(field_size, 8));
 
@@ -1523,7 +1521,7 @@ COMMAND_HANDLER(handle_irscan_command)
 	}
 
 	/* did we have an endstate? */
-	jtag_add_ir_scan(num_fields, fields, endstate);
+	jtag_add_ir_scan(tap, num_fields, fields, endstate);
 
 	retval = jtag_execute_queue();
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index c5bc0ff..0b11258 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -574,38 +574,28 @@ static __inline void scanFields(int num_fields, const struct scan_field *fields,
 	}
 }
 
-int interface_jtag_add_ir_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_ir_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
-
-	int j;
 	int scan_size = 0;
 	struct jtag_tap *tap, *nextTap;
+
+	assert(num_fields == 1);
+
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
-		int pause = (nextTap==NULL);
-
-		int found = 0;
-
+		bool pause = (nextTap==NULL);
 		scan_size = tap->ir_length;
 
 		/* search the list */
-		for (j = 0; j < num_fields; j++)
+		if (tap == active)
 		{
-			if (tap == fields[j].tap)
-			{
-				found = 1;
-
-				scanFields(1, fields + j, TAP_IRSHIFT, pause);
-				/* update device information */
-				buf_cpy(fields[j].out_value, tap->cur_instr, scan_size);
+			scanFields(num_fields, fields, TAP_IRSHIFT, pause);
+			/* update device information */
+			buf_cpy(fields[0].out_value, tap->cur_instr, scan_size);
 
-				tap->bypass = 0;
-				break;
-			}
-		}
-
-		if (!found)
+			tap->bypass = 0;
+		} else
 		{
 			/* if a device isn't listed, set it to BYPASS */
 			assert(scan_size <= 32);
@@ -631,46 +621,26 @@ int interface_jtag_add_plain_ir_scan(int num_fields, const struct scan_field *fi
 	return ERROR_OK;
 }
 
-int interface_jtag_add_dr_scan(int num_fields, const struct scan_field *fields, tap_state_t state)
+int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
-
-	int j;
 	struct jtag_tap *tap, *nextTap;
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
-		int found = 0;
-		int pause = (nextTap==NULL);
+		bool pause = (nextTap==NULL);
 
-		for (j = 0; j < num_fields; j++)
+		/* Find a range of fields to write to this tap */
+		if (tap == active)
 		{
-			/* Find a range of fields to write to this tap */
-			if (tap == fields[j].tap)
-			{
-				found = 1;
-				int i;
-				for (i = j + 1; i < num_fields; i++)
-				{
-					if (tap != fields[j].tap)
-					{
-						break;
-					}
-				}
-
-				scanFields(i - j, fields + j, TAP_DRSHIFT, pause);
+			assert(!tap->bypass);
 
-				j = i;
-			}
-		}
-
-		if (!found)
+			scanFields(num_fields, fields, TAP_DRSHIFT, pause);
+		} else
 		{
 			/* Shift out a 0 for disabled tap's */
+			assert(tap->bypass);
 			shiftValueInner(TAP_DRSHIFT, pause?TAP_DRPAUSE:TAP_DRSHIFT, 1, 0);
 		}
-		else
-		{
-		}
 	}
 	gotoEndState(state);
 	return ERROR_OK;
@@ -683,7 +653,6 @@ int interface_jtag_add_plain_dr_scan(int num_fields, const struct scan_field *fi
 	return ERROR_OK;
 }
 
-
 int interface_jtag_add_tlr()
 {
 	setCurrentState(TAP_RESET);
@@ -691,8 +660,6 @@ int interface_jtag_add_tlr()
 }
 
 
-
-
 int interface_jtag_add_reset(int req_trst, int req_srst)
 {
 	zy1000_reset(req_trst, req_srst);
@@ -737,7 +704,6 @@ static int zy1000_jtag_add_clocks(int num_cycles, tap_state_t state, tap_state_t
 	ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, state);
 #endif
 
-
 	return ERROR_OK;
 }
 
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index bbf6b66..15685e6 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -35,13 +35,12 @@ static int virtex2_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 	{
 		struct scan_field field;
 
-		field.tap = tap;
 		field.num_bits = tap->ir_length;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_ir_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
 
 		free(field.out_value);
 	}
@@ -59,7 +58,6 @@ static int virtex2_send_32(struct pld_device *pld_device,
 
 	values = malloc(num_words * 4);
 
-	scan_field.tap = virtex2_info->tap;
 	scan_field.num_bits = num_words * 32;
 	scan_field.out_value = values;
 	scan_field.in_value = NULL;
@@ -69,7 +67,7 @@ static int virtex2_send_32(struct pld_device *pld_device,
 
 	virtex2_set_instr(virtex2_info->tap, 0x5); /* CFG_IN */
 
-	jtag_add_dr_scan(1, &scan_field, jtag_set_end_state(TAP_DRPAUSE));
+	jtag_add_dr_scan(virtex2_info->tap, 1, &scan_field, jtag_set_end_state(TAP_DRPAUSE));
 
 	free(values);
 
@@ -88,7 +86,6 @@ static int virtex2_receive_32(struct pld_device *pld_device,
 	struct virtex2_pld_device *virtex2_info = pld_device->driver_priv;
 	struct scan_field scan_field;
 
-	scan_field.tap = virtex2_info->tap;
 	scan_field.num_bits = 32;
 	scan_field.out_value = NULL;
 	scan_field.in_value = NULL;
@@ -99,7 +96,7 @@ static int virtex2_receive_32(struct pld_device *pld_device,
 	{
 		scan_field.in_value = (uint8_t *)words;
 
-		jtag_add_dr_scan(1, &scan_field, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(virtex2_info->tap, 1, &scan_field, jtag_set_end_state(TAP_DRPAUSE));
 
 		jtag_add_callback(virtexflip32, (jtag_callback_data_t)words);
 
@@ -139,7 +136,6 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 	unsigned int i;
 	struct scan_field field;
 
-	field.tap = virtex2_info->tap;
 	field.in_value = NULL;
 
 	if ((retval = xilinx_read_bit_file(&bit_file, filename)) != ERROR_OK)
@@ -159,7 +155,7 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 	field.num_bits = bit_file.length * 8;
 	field.out_value = bit_file.data;
 
-	jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_DRPAUSE));
+	jtag_add_dr_scan(virtex2_info->tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
 	jtag_execute_queue();
 
 	jtag_add_tlr();
diff --git a/src/svf/svf.c b/src/svf/svf.c
index f46d698..28595d5 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -216,8 +216,6 @@ static char *svf_command_buffer = NULL;
 static int svf_command_buffer_size = 0;
 static int svf_line_number = 1;
 
-static struct jtag_tap *tap = NULL;
-
 #define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(4 * 1024)
 static uint8_t *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
 static int svf_buffer_index = 0, svf_buffer_size = 0;
@@ -1082,7 +1080,6 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			{
 				svf_add_check_para(0, svf_buffer_index, i);
 			}
-			field.tap = tap;
 			field.num_bits = i;
 			field.out_value = &svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &svf_tdi_buffer[svf_buffer_index];
@@ -1178,7 +1175,6 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			{
 				svf_add_check_para(0, svf_buffer_index, i);
 			}
-			field.tap = tap;
 			field.num_bits = i;
 			field.out_value = &svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &svf_tdi_buffer[svf_buffer_index];
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 51be701..36bbaba 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -123,7 +123,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 1);
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 	}
 
@@ -317,7 +317,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 		arm11_setup_field(arm11,  1, &Ready,	NULL, chain5_fields + 1);
 		arm11_setup_field(arm11,  1, &Valid,	NULL, chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 
 	/* now processor is ready to RESTART */
@@ -1194,7 +1194,7 @@ static int arm11_examine(struct target *target)
 
 	arm11_setup_field(arm11, 32, NULL, &device_id, &idcode_field);
 
-	arm11_add_dr_scan_vc(1, &idcode_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11->arm.target->tap, 1, &idcode_field, TAP_DRPAUSE);
 
 	/* check DIDR */
 
@@ -1207,7 +1207,7 @@ static int arm11_examine(struct target *target)
 	arm11_setup_field(arm11, 32, NULL, &didr, chain0_fields + 0);
 	arm11_setup_field(arm11,  8, NULL, &implementor, chain0_fields + 1);
 
-	arm11_add_dr_scan_vc(ARRAY_SIZE(chain0_fields), chain0_fields, TAP_IDLE);
+	arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain0_fields), chain0_fields, TAP_IDLE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index b8388c8..f049059 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -49,13 +49,13 @@ static const tap_state_t arm11_move_pi_to_si_via_ci[] =
 
 
 /* REVISIT no error handling here! */
-static void arm11_add_ir_scan_vc(int num_fields, struct scan_field *fields,
+static void arm11_add_ir_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
 		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_IRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
-	jtag_add_ir_scan(num_fields, fields, state);
+	jtag_add_ir_scan(tap, num_fields, fields, state);
 }
 
 static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
@@ -64,13 +64,13 @@ static const tap_state_t arm11_move_pd_to_sd_via_cd[] =
 };
 
 /* REVISIT no error handling here! */
-void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
+void arm11_add_dr_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
 		tap_state_t state)
 {
 	if (cmd_queue_cur_state == TAP_DRPAUSE)
 		jtag_add_pathmove(ARRAY_SIZE(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
 
-	jtag_add_dr_scan(num_fields, fields, state);
+	jtag_add_dr_scan(tap, num_fields, fields, state);
 }
 
 
@@ -87,7 +87,6 @@ void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
 void arm11_setup_field(struct arm11_common *arm11, int num_bits,
 		void *out_data, void *in_data, struct scan_field *field)
 {
-	field->tap			= arm11->arm.target->tap;
 	field->num_bits			= num_bits;
 	field->out_value		= out_data;
 	field->in_value			= in_data;
@@ -150,7 +149,7 @@ void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 
 	arm11_setup_field(arm11, 5, &instr, NULL, &field);
 
-	arm11_add_ir_scan_vc(1, &field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
+	arm11_add_ir_scan_vc(arm11->arm.target->tap, 1, &field, state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
 }
 
 /** Verify data shifted out from Scan Chain Register (SCREG). */
@@ -214,7 +213,7 @@ int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 	uint8_t tmp[1];
 	arm11_setup_field(arm11, 5, &chain, &tmp, &field);
 
-	arm11_add_dr_scan_vc(1, &field, state == ARM11_TAP_DEFAULT ? TAP_DRPAUSE : state);
+	arm11_add_dr_scan_vc(arm11->arm.target->tap, 1, &field, state == ARM11_TAP_DEFAULT ? TAP_DRPAUSE : state);
 
 	jtag_execute_queue_noclear();
 
@@ -253,7 +252,7 @@ static void arm11_add_debug_INST(struct arm11_common * arm11,
 	arm11_setup_field(arm11, 32,    &inst,	NULL, itr + 0);
 	arm11_setup_field(arm11, 1,	    NULL,	flag, itr + 1);
 
-	arm11_add_dr_scan_vc(ARRAY_SIZE(itr), itr, state);
+	arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(itr), itr, state);
 }
 
 /**
@@ -281,7 +280,7 @@ int arm11_read_DSCR(struct arm11_common *arm11)
 
 	arm11_setup_field(arm11, 32, NULL, &dscr, &chain1_field);
 
-	arm11_add_dr_scan_vc(1, &chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11->arm.target->tap, 1, &chain1_field, TAP_DRPAUSE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
@@ -317,7 +316,7 @@ int arm11_write_DSCR(struct arm11_common * arm11, uint32_t dscr)
 
 	arm11_setup_field(arm11, 32, &dscr, NULL, &chain1_field);
 
-	arm11_add_dr_scan_vc(1, &chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11->arm.target->tap, 1, &chain1_field, TAP_DRPAUSE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
@@ -483,7 +482,7 @@ int arm11_run_instr_data_to_core(struct arm11_common * arm11, uint32_t opcode, u
 		{
 			Data	    = *data;
 
-			arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
+			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
 
 			CHECK_RETVAL(jtag_execute_queue());
 
@@ -518,7 +517,7 @@ int arm11_run_instr_data_to_core(struct arm11_common * arm11, uint32_t opcode, u
 	{
 		Data	    = 0;
 
-		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+		arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 		CHECK_RETVAL(jtag_execute_queue());
 
@@ -577,17 +576,14 @@ int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint
 {
 	struct scan_field	chain5_fields[3];
 
-	chain5_fields[0].tap			= tap;
 	chain5_fields[0].num_bits		= 32;
 	chain5_fields[0].out_value		= NULL; /*&Data*/
 	chain5_fields[0].in_value		= NULL;
 
-	chain5_fields[1].tap			= tap;
 	chain5_fields[1].num_bits		= 1;
 	chain5_fields[1].out_value		= NULL;
 	chain5_fields[1].in_value		= NULL; /*&Ready*/
 
-	chain5_fields[2].tap			= tap;
 	chain5_fields[2].num_bits		= 1;
 	chain5_fields[2].out_value		= NULL;
 	chain5_fields[2].in_value		= NULL;
@@ -611,12 +607,12 @@ int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint
 
 		if (count > 0)
 		{
-			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+			jtag_add_dr_scan(tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 			jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
 				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
 		} else
 		{
-			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_IDLE);
+			jtag_add_dr_scan(tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_IDLE);
 		}
 	}
 
@@ -697,7 +693,7 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opc
 	uint8_t ready_flag;
 	chain5_fields[1].in_value   = &ready_flag;
 
-	arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 	retval = jtag_execute_queue();
 	if (retval == ERROR_OK)
@@ -770,7 +766,7 @@ int arm11_run_instr_data_from_core(struct arm11_common * arm11, uint32_t opcode,
 		int i = 0;
 		do
 		{
-			arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
+			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
 
@@ -910,7 +906,7 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 					(unsigned) DataOut,
 					nRW ? "write" : "read");
 
-			arm11_add_dr_scan_vc(ARRAY_SIZE(chain7_fields),
+			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain7_fields),
 					chain7_fields, TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 45052b9..762c9be 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -30,7 +30,7 @@ int arm11_run_instr_data_from_core_via_r0(struct arm11_common *arm11,
 int arm11_run_instr_data_to_core_via_r0(struct arm11_common *arm11,
 		uint32_t opcode, uint32_t data);
 
-void arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields,
+void arm11_add_dr_scan_vc(struct jtag_tap *tap, int num_fields, struct scan_field *fields,
 		tap_state_t state);
 
 /**
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 2275935..79eb79b 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -64,12 +64,10 @@ static int arm720t_scan_cp15(struct target *target,
 		return retval;
 	}
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &instruction_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = out_buf;
 	fields[1].in_value = NULL;
@@ -77,11 +75,11 @@ static int arm720t_scan_cp15(struct target *target,
 	if (in)
 	{
 		fields[1].in_value = (uint8_t *)in;
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
 		jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
 	} else
 	{
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
 	}
 
 	if (clock)
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 530a675..bd29caf 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -58,12 +58,10 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 
 		jtag_set_end_state(TAP_DRPAUSE);
 
-		fields[0].tap = arm7_9->jtag_info.tap;
 		fields[0].num_bits = 1;
 		fields[0].out_value = NULL;
 		fields[0].in_value = &breakpoint;
 
-		fields[1].tap = arm7_9->jtag_info.tap;
 		fields[1].num_bits = 32;
 		fields[1].out_value = NULL;
 		fields[1].in_value = databus;
@@ -74,7 +72,7 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		}
 		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(2, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, jtag_set_end_state(TAP_DRPAUSE));
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
@@ -85,7 +83,7 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		fields[1].in_value = NULL;
 		fields[1].out_value = databus;
 
-		jtag_add_dr_scan(2, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, jtag_set_end_state(TAP_DRPAUSE));
 
 		if (breakpoint & 1)
 			target->debug_reason = DBG_REASON_WATCHPOINT;
@@ -141,17 +139,15 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
 	fields[1].in_value = (uint8_t *)in;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
 
@@ -228,17 +224,15 @@ static int arm7tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
 	jtag_alloc_in_value32(&fields[1]);
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
 
 	jtag_add_callback4(arm7endianness, (jtag_callback_data_t)in, (jtag_callback_data_t)size, (jtag_callback_data_t)be, (jtag_callback_data_t)fields[1].in_value);
 
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 152edcf..a7816fd 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -95,31 +95,27 @@ static int arm920t_read_cp15_physical(struct target *target,
 	arm_jtag_scann(jtag_info, 0xf);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &access_type_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 6;
 	fields[2].out_value = &reg_addr_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info->tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 
 	fields[1].in_value = (uint8_t *)value;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -150,27 +146,23 @@ static int arm920t_write_cp15_physical(struct target *target,
 	arm_jtag_scann(jtag_info, 0xf);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &access_type_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = value_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 6;
 	fields[2].out_value = &reg_addr_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info->tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG("addr: 0x%x value: %8.8x", reg_addr, value);
@@ -206,27 +198,23 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 
 	buf_set_u32(cp15_opcode_buf, 0, 32, cp15_opcode);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &access_type_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = cp15_opcode_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 6;
 	fields[2].out_value = &reg_addr_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info->tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 
 	arm9tdmi_clock_out(jtag_info, arm_opcode, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index d811196..f4c4774 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -70,28 +70,23 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = (uint8_t *)value;
 
-
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 1;
 	fields[1].out_value = &access;
 	fields[1].in_value = &access;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 14;
 	fields[2].out_value = address_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info->tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 
 	long long then = timeval_ms();
 
@@ -100,7 +95,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 		/* rescan with NOP, to wait for the access to complete */
 		access = 0;
 		nr_w_buf = 0;
-		jtag_add_dr_scan(4, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -164,27 +159,23 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 1;
 	fields[1].out_value = &access;
 	fields[1].in_value = &access;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 14;
 	fields[2].out_value = address_buf;
 	fields[2].in_value = NULL;
 
-	fields[3].tap = jtag_info->tap;
 	fields[3].num_bits = 1;
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 
 	long long then = timeval_ms();
 
@@ -193,7 +184,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 		/* rescan with NOP, to wait for the access to complete */
 		access = 0;
 		nr_w_buf = 0;
-		jtag_add_dr_scan(4, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index 2f5e390..4f47644 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -91,7 +91,6 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	/* REVISIT: table 7-2 shows that bits 31-31 need to be
 	 * specified for accessing BIST registers ...
@@ -99,21 +98,19 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 6;
 	fields[1].out_value = &reg_addr_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &nr_w_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	fields[1].in_value = (uint8_t *)value;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -149,22 +146,19 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value)
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 6;
 	fields[1].out_value = &reg_addr_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &nr_w_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG("addr: 0x%x value: %8.8x", reg_addr, value);
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 77b01b1..7c1e372 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -89,17 +89,14 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 
 		jtag_set_end_state(TAP_DRPAUSE);
 
-		fields[0].tap = arm7_9->jtag_info.tap;
 		fields[0].num_bits = 32;
 		fields[0].out_value = NULL;
 		fields[0].in_value = databus;
 
-		fields[1].tap = arm7_9->jtag_info.tap;
 		fields[1].num_bits = 3;
 		fields[1].out_value = NULL;
 		fields[1].in_value = &debug_reason;
 
-		fields[2].tap = arm7_9->jtag_info.tap;
 		fields[2].num_bits = 32;
 		fields[2].out_value = NULL;
 		fields[2].in_value = instructionbus;
@@ -110,7 +107,7 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		}
 		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, jtag_set_end_state(TAP_DRPAUSE));
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
@@ -123,7 +120,7 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		fields[2].in_value = NULL;
 		fields[2].out_value = instructionbus;
 
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, jtag_set_end_state(TAP_DRPAUSE));
 
 		if (debug_reason & 0x4)
 			if (debug_reason & 0x2)
@@ -165,17 +162,14 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = &sysspeed_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = instr_buf;
 	fields[2].in_value = NULL;
@@ -183,13 +177,13 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 	if (in)
 	{
 		fields[0].in_value = (uint8_t *)in;
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
 	}
 	else
 	{
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 	}
 
 	jtag_add_runtest(0, jtag_get_end_state());
@@ -227,22 +221,19 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = (uint8_t *)in;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = NULL;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = NULL;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
 
@@ -297,22 +288,19 @@ int arm9tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	jtag_alloc_in_value32(&fields[0]);
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = NULL;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = NULL;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	jtag_add_callback4(arm9endianness, (jtag_callback_data_t)in, (jtag_callback_data_t)size, (jtag_callback_data_t)be, (jtag_callback_data_t)fields[0].in_value);
 
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 1c52786..61cf989 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -123,7 +123,6 @@ static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
 	 */
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 3;
 	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
 	fields[0].out_value = &out_addr_buf;
@@ -134,12 +133,11 @@ static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	 * When overrun detect is active, STICKYORUN is set.
 	 */
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = outvalue;
 	fields[1].in_value = invalue;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
 
 	/* Add specified number of tck clocks after starting memory bus
 	 * access, giving the hardware time to complete the access.
@@ -1132,12 +1130,11 @@ static int jtag_idcode_q_read(struct adiv5_dap *dap,
 	if (retval != ERROR_OK)
 		return retval;
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = (void *) data;
 
-	jtag_add_dr_scan(1, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 1, fields, jtag_get_end_state());
 	retval = jtag_get_error();
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index f7a540a..3e27b76 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -38,7 +38,6 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 	struct scan_field field;
 	uint8_t t[4];
 
-	field.tap = tap;
 	field.num_bits = tap->ir_length;
 	field.out_value = t;
 	buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
@@ -46,13 +45,13 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 
 	if (no_verify_capture == NULL)
 	{
-		jtag_add_ir_scan(1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
 	} else
 	{
 		/* FIX!!!! this is a kludge!!! arm926ejs.c should reimplement this arm_jtag_set_instr to
 		 * have special verification code.
 		 */
-		jtag_add_ir_scan_noverify(1, &field, jtag_get_end_state());
+		jtag_add_ir_scan_noverify(tap, 1, &field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
diff --git a/src/target/avrt.c b/src/target/avrt.c
index 6ba6206..5d912da 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -192,7 +192,6 @@ int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_l
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = tap->ir_length;
 		field[0].out_value = ir_out;
 		field[0].in_value = ir_in;
@@ -213,7 +212,6 @@ int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_l
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = dr_len;
 		field[0].out_value = dr_out;
 		field[0].in_value = dr_in;
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 049ee1a..a379121 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -865,7 +865,6 @@ int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = tap->ir_length;
 		field[0].out_value = ir_out;
 		field[0].in_value = ir_in;
@@ -888,7 +887,6 @@ int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
 	{
 		struct scan_field field[1];
 
-		field[0].tap = tap;
 		field[0].num_bits = dr_len;
 		field[0].out_value = dr_out;
 		field[0].in_value = dr_in;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index bf22036..4693fcc 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -349,7 +349,6 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL);
 
 	/* bits 31:0 -- data (ignored here) */
-	fields[0].tap = ice_reg->jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg->value;
 	fields[0].in_value = NULL;
@@ -357,7 +356,6 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[0].check_mask = NULL;
 
 	/* bits 36:32 -- register */
-	fields[1].tap = ice_reg->jtag_info->tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = reg_addr;
@@ -366,7 +364,6 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[1].check_mask = NULL;
 
 	/* bit 37 -- 0/read */
-	fields[2].tap = ice_reg->jtag_info->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 0;
@@ -375,7 +372,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[2].check_mask = NULL;
 
 	/* traverse Update-DR, setting address for the next read */
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(ice_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	/* bits 31:0 -- the data we're reading (and maybe checking) */
 	fields[0].in_value = reg->value;
@@ -389,7 +386,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 	/* traverse Update-DR, reading but with no other side effects */
-	jtag_add_dr_scan_check(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(ice_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	return ERROR_OK;
 }
@@ -412,24 +409,21 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 0;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	while (size > 0)
 	{
@@ -440,7 +434,7 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 			fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 		fields[0].in_value = (uint8_t *)data;
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)data);
 
 		data++;
@@ -533,18 +527,15 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = field0_out;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 1;
@@ -554,7 +545,7 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	while (size > 0)
 	{
 		buf_set_u32(fields[0].out_value, 0, 32, *data);
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 		data++;
 		size--;
@@ -589,27 +580,24 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = field0_in;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
 	fields[2].out_value[0] = 0;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 	gettimeofday(&lap, NULL);
 	do {
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 
diff --git a/src/target/etb.c b/src/target/etb.c
index 18258f6..1f73ff5 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -54,14 +54,13 @@ static int etb_set_instr(struct etb *etb, uint32_t new_instr)
 	{
 		struct scan_field field;
 
-		field.tap = tap;
 		field.num_bits = tap->ir_length;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
 
 		free(field.out_value);
 	}
@@ -75,7 +74,6 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 	{
 		struct scan_field field;
 
-		field.tap = etb->tap;
 		field.num_bits = 5;
 		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_scan_chain);
@@ -84,7 +82,7 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 
 		/* select INTEST instruction */
 		etb_set_instr(etb, 0x2);
-		jtag_add_dr_scan(1, &field, jtag_get_end_state());
+		jtag_add_dr_scan(etb->tap, 1, &field, jtag_get_end_state());
 
 		etb->cur_scan_chain = new_scan_chain;
 
@@ -179,24 +177,21 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 	etb_scann(etb, 0x0);
 	etb_set_instr(etb, 0xc);
 
-	fields[0].tap = etb->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = etb->tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, 4);
 	fields[1].in_value = NULL;
 
-	fields[2].tap = etb->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 0);
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etb->tap, 3, fields, jtag_get_end_state());
 
 	for (i = 0; i < num_frames; i++)
 	{
@@ -210,7 +205,7 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 			buf_set_u32(fields[1].out_value, 0, 7, 0);
 
 		fields[0].in_value = (uint8_t *)(data + i);
-		jtag_add_dr_scan(3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(etb->tap, 3, fields, jtag_get_end_state());
 
 		jtag_add_callback(etb_getbuf, (jtag_callback_data_t)(data + i));
 	}
@@ -236,14 +231,12 @@ static int etb_read_reg_w_check(struct reg *reg,
 	etb_scann(etb_reg->etb, 0x0);
 	etb_set_instr(etb_reg->etb, 0xc);
 
-	fields[0].tap = etb_reg->etb->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg->value;
 	fields[0].in_value = NULL;
 	fields[0].check_value = NULL;
 	fields[0].check_mask = NULL;
 
-	fields[1].tap = etb_reg->etb->tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
@@ -251,7 +244,6 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[1].check_value = NULL;
 	fields[1].check_mask = NULL;
 
-	fields[2].tap = etb_reg->etb->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 0);
@@ -259,7 +251,7 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etb_reg->etb->tap, 3, fields, jtag_get_end_state());
 
 	/* read the identification register in the second run, to make sure we
 	 * don't read the ETB data register twice, skipping every second entry
@@ -269,7 +261,7 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[0].check_value = check_value;
 	fields[0].check_mask = check_mask;
 
-	jtag_add_dr_scan_check(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(etb_reg->etb->tap, 3, fields, jtag_get_end_state());
 
 	free(fields[1].out_value);
 	free(fields[2].out_value);
@@ -322,19 +314,16 @@ static int etb_write_reg(struct reg *reg, uint32_t value)
 	etb_scann(etb_reg->etb, 0x0);
 	etb_set_instr(etb_reg->etb, 0xc);
 
-	fields[0].tap = etb_reg->etb->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = malloc(4);
 	buf_set_u32(fields[0].out_value, 0, 32, value);
 	fields[0].in_value = NULL;
 
-	fields[1].tap = etb_reg->etb->tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 
-	fields[2].tap = etb_reg->etb->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 1);
diff --git a/src/target/etm.c b/src/target/etm.c
index 3126efc..10ab72a 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -508,14 +508,12 @@ static int etm_read_reg_w_check(struct reg *reg,
 	arm_jtag_scann(etm_reg->jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL);
 
-	fields[0].tap = etm_reg->jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg->value;
 	fields[0].in_value = NULL;
 	fields[0].check_value = NULL;
 	fields[0].check_mask = NULL;
 
-	fields[1].tap = etm_reg->jtag_info->tap;
 	fields[1].num_bits = 7;
 	fields[1].out_value = malloc(1);
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
@@ -523,7 +521,6 @@ static int etm_read_reg_w_check(struct reg *reg,
 	fields[1].check_value = NULL;
 	fields[1].check_mask = NULL;
 
-	fields[2].tap = etm_reg->jtag_info->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = malloc(1);
 	buf_set_u32(fields[2].out_value, 0, 1, 0);
@@ -531,13 +528,13 @@ static int etm_read_reg_w_check(struct reg *reg,
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etm_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	fields[0].in_value = reg->value;
 	fields[0].check_value = check_value;
 	fields[0].check_mask = check_mask;
 
-	jtag_add_dr_scan_check(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(etm_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	free(fields[1].out_value);
 	free(fields[2].out_value);
@@ -594,28 +591,25 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	arm_jtag_scann(etm_reg->jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL);
 
-	fields[0].tap = etm_reg->jtag_info->tap;
 	fields[0].num_bits = 32;
 	uint8_t tmp1[4];
 	fields[0].out_value = tmp1;
 	buf_set_u32(fields[0].out_value, 0, 32, value);
 	fields[0].in_value = NULL;
 
-	fields[1].tap = etm_reg->jtag_info->tap;
 	fields[1].num_bits = 7;
 	uint8_t tmp2;
 	fields[1].out_value = &tmp2;
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 
-	fields[2].tap = etm_reg->jtag_info->tap;
 	fields[2].num_bits = 1;
 	uint8_t tmp3;
 	fields[2].out_value = &tmp3;
 	buf_set_u32(fields[2].out_value, 0, 1, 1);
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etm_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	return ERROR_OK;
 }
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index e0c3c39..133ad4f 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -89,22 +89,19 @@ int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
 
-	fields[0].tap = jtag_info->tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
 	fields[0].in_value = NULL;
 
-	fields[1].tap = jtag_info->tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = &sysspeed_buf;
 	fields[1].in_value = NULL;
 
-	fields[2].tap = jtag_info->tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = instr_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
 
 	/* no jtag_add_runtest(0, jtag_get_end_state()) here */
 
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 336adb5..79160fc 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -41,13 +41,12 @@ int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr, void *del
 		struct scan_field field;
 		uint8_t t[4];
 
-		field.tap = tap;
 		field.num_bits = tap->ir_length;
 		field.out_value = t;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
@@ -61,12 +60,11 @@ int mips_ejtag_ge
t_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE, NULL);
 
-	field.tap = ejtag_info->tap;
 	field.num_bits = 32;
 	field.out_value = NULL;
 	field.in_value = (void*)idcode;
 
-	jtag_add_dr_scan(1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(ejtag_info->tap, 1, &field, jtag_get_end_state());
 
 	if (jtag_execute_queue() != ERROR_OK)
 	{
@@ -84,12 +82,11 @@ int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE, NULL);
 
-	field.tap = ejtag_info->tap;
 	field.num_bits = 32;
 	field.out_value = NULL;
 	field.in_value = (void*)impcode;
 
-	jtag_add_dr_scan(1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(ejtag_info->tap, 1, &field, jtag_get_end_state());
 
 	if (jtag_execute_queue() != ERROR_OK)
 	{
@@ -110,13 +107,12 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 	uint8_t t[4], r[4];
 	int retval;
 
-	field.tap = tap;
 	field.num_bits = 32;
 	field.out_value = t;
 	buf_set_u32(field.out_value, 0, field.num_bits, *data);
 	field.in_value = r;
 
-	jtag_add_dr_scan(1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -294,13 +290,11 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t
 	uint8_t t[4] = {0, 0, 0, 0};
 
 	/* fastdata 1-bit register */
-	fields[0].tap = tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &spracc;
 	fields[0].in_value = NULL;
 
 	/* processor access data register 32 bit */
-	fields[1].tap = tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = t;
 
@@ -314,7 +308,7 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t
 		fields[1].in_value = (uint8_t *) data;
 	}
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 2, fields, jtag_get_end_state());
 	keep_alive();
 
 	return ERROR_OK;
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 48dbc47..4973898 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -169,12 +169,11 @@ static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		uint8_t scratch[4];
 
 		memset(&field, 0, sizeof field);
-		field.tap = tap;
 		field.num_bits = tap->ir_length;
 		field.out_value = scratch;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
-		jtag_add_ir_scan(1, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, 1, &field, jtag_get_end_state());
 	}
 
 	return ERROR_OK;
@@ -201,23 +200,20 @@ static int xscale_read_dcsr(struct target *target)
 
 	memset(&fields, 0, sizeof fields);
 
-	fields[0].tap = target->tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &field0;
 	uint8_t tmp;
 	fields[0].in_value = &tmp;
 
-	fields[1].tap = target->tap;
 	fields[1].num_bits = 32;
 	fields[1].in_value = xscale->reg_cache->reg_list[XSCALE_DCSR].value;
 
-	fields[2].tap = target->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &field2;
 	uint8_t tmp2;
 	fields[2].in_value = &tmp2;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 3, fields, jtag_get_end_state());
 
 	jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 	jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -240,7 +236,7 @@ static int xscale_read_dcsr(struct target *target)
 
 	jtag_set_end_state(TAP_IDLE);
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 3, fields, jtag_get_end_state());
 
 	/* DANGER!!! this must be here. It will make sure that the arguments
 	 * to jtag_set_check_value() does not go out of scope! */
@@ -279,15 +275,12 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 
 	memset(&fields, 0, sizeof fields);
 
-	fields[0].tap = target->tap;
 	fields[0].num_bits = 3;
 	fields[0].check_value = &field0_check_value;
 	fields[0].check_mask = &field0_check_mask;
 
-	fields[1].tap = target->tap;
 	fields[1].num_bits = 32;
 
-	fields[2].tap = target->tap;
 	fields[2].num_bits = 1;
 	fields[2].check_value = &field2_check_value;
 	fields[2].check_mask = &field2_check_mask;
@@ -311,7 +304,7 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 
 			fields[1].in_value = (uint8_t *)(field1 + i);
 
-			jtag_add_dr_scan_check(3, fields, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan_check(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 			jtag_add_callback(xscale_getbuf, (jtag_callback_data_t)(field1 + i));
 
@@ -392,15 +385,12 @@ static int xscale_read_tx(struct target *target, int consume)
 
 	memset(&fields, 0, sizeof fields);
 
-	fields[0].tap = target->tap;
 	fields[0].num_bits = 3;
 	fields[0].in_value = &field0_in;
 
-	fields[1].tap = target->tap;
 	fields[1].num_bits = 32;
 	fields[1].in_value = xscale->reg_cache->reg_list[XSCALE_TX].value;
 
-	fields[2].tap = target->tap;
 	fields[2].num_bits = 1;
 	uint8_t tmp;
 	fields[2].in_value = &tmp;
@@ -421,7 +411,7 @@ static int xscale_read_tx(struct target *target, int consume)
 			jtag_add_pathmove(ARRAY_SIZE(noconsume_path), noconsume_path);
 		}
 
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 		jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 		jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -480,16 +470,13 @@ static int xscale_write_rx(struct target *target)
 
 	memset(&fields, 0, sizeof fields);
 
-	fields[0].tap = target->tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &field0_out;
 	fields[0].in_value = &field0_in;
 
-	fields[1].tap = target->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = xscale->reg_cache->reg_list[XSCALE_RX].value;
 
-	fields[2].tap = target->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &field2;
 	uint8_t tmp;
@@ -502,7 +489,7 @@ static int xscale_write_rx(struct target *target)
 	LOG_DEBUG("polling RX");
 	for (;;)
 	{
-		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 		jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 		jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -534,7 +521,7 @@ static int xscale_write_rx(struct target *target)
 
 	/* set rx_valid */
 	field2 = 0x1;
-	jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -646,23 +633,20 @@ static int xscale_write_dcsr(struct target *target, int hold_rst, int ext_dbg_br
 
 	memset(&fields, 0, sizeof fields);
 
-	fields[0].tap = target->tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &field0;
 	uint8_t tmp;
 	fields[0].in_value = &tmp;
 
-	fields[1].tap = target->tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = xscale->reg_cache->reg_list[XSCALE_DCSR].value;
 
-	fields[2].tap = target->tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &field2;
 	uint8_t tmp2;
 	fields[2].in_value = &tmp2;
 
-	jtag_add_dr_scan(3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 3, fields, jtag_get_end_state());
 
 	jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 	jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -717,15 +701,13 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 
 	memset(&fields, 0, sizeof fields);
 
-	fields[0].tap = target->tap;
 	fields[0].num_bits = 6;
 	fields[0].out_value = &cmd;
 
-	fields[1].tap = target->tap;
 	fields[1].num_bits = 27;
 	fields[1].out_value = packet;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 2, fields, jtag_get_end_state());
 
 	/* rest of packet is a cacheline: 8 instructions, with parity */
 	fields[0].num_bits = 32;
@@ -742,7 +724,7 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 		memcpy(&value, packet, sizeof(uint32_t));
 		cmd = parity(value);
 
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(target->tap, 2, fields, jtag_get_end_state());
 	}
 
 	return jtag_execute_queue();
@@ -767,15 +749,13 @@ static int xscale_invalidate_ic_line(struct target *target, uint32_t va)
 
 	memset(&fields, 0, sizeof fields);
 
-	fields[0].tap = target->tap;
 	fields[0].num_bits = 6;
 	fields[0].out_value = &cmd;
 
-	fields[1].tap = target->tap;
 	fields[1].num_bits = 27;
 	fields[1].out_value = packet;
 
-	jtag_add_dr_scan(2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 2, fields, jtag_get_end_state());
 
 	return ERROR_OK;
 }
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 539fbdc..faa5542 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -476,7 +476,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 							LOG_USER("%s mismatch, xsdrsize=%d retry=%d", op_name, xsdrsize, attempt);
 					}
 
-					field.tap = tap;
 					field.num_bits = xsdrsize;
 					field.out_value = dr_out_buf;
 					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
@@ -484,7 +483,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_dr_scan(1, &field, jtag_set_end_state(TAP_DRPAUSE));
 					else
-						jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
 
 					jtag_check_value_mask(&field, dr_in_buf, dr_in_mask);
 
@@ -694,7 +693,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 				{
 					struct scan_field field;
 
-					field.tap = tap;
 					field.num_bits = bitcount;
 					field.out_value = ir_buf;
 
@@ -706,7 +704,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_ir_scan(1, &field, my_end_state);
 					else
-						jtag_add_ir_scan(1, &field, my_end_state);
+						jtag_add_ir_scan(tap, 1, &field, my_end_state);
 
 					if (xruntest)
 					{
@@ -930,7 +928,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 					jtag_add_clocks(loop_clocks);
 					jtag_add_sleep(loop_usecs);
 
-					field.tap = tap;
 					field.num_bits = xsdrsize;
 					field.out_value = dr_out_buf;
 					field.in_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
@@ -941,7 +938,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					if (tap == NULL)
 						jtag_add_plain_dr_scan(1, &field, jtag_set_end_state(TAP_DRPAUSE));
 					else
-						jtag_add_dr_scan(1, &field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
 
 					jtag_check_value_mask(&field, dr_in_buf, dr_in_mask);
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9xpec.c       |   45 +++++++-------------
 src/jtag/core.c                |   61 ++++++++++++++-------------
 src/jtag/drivers/driver.c      |   92 +++++++++++-----------------------------
 src/jtag/jtag.h                |   31 ++++++-------
 src/jtag/minidriver.h          |   10 ++--
 src/jtag/minidummy/minidummy.c |    8 ++--
 src/jtag/tcl.c                 |   17 +++++--
 src/jtag/zy1000/zy1000.c       |   88 +++++++++++++-------------------------
 src/pld/virtex2.c              |   12 ++----
 src/svf/svf.c                  |    9 +---
 src/target/arm11.c             |    8 ++--
 src/target/arm11_dbgtap.c      |   36 +++++++---------
 src/target/arm11_dbgtap.h      |    2 +-
 src/target/arm720t.c           |    6 +--
 src/target/arm7tdmi.c          |   14 ++----
 src/target/arm920t.c           |   20 ++-------
 src/target/arm926ejs.c         |   17 ++------
 src/target/arm966e.c           |   12 +----
 src/target/arm9tdmi.c          |   24 +++--------
 src/target/arm_adi_v5.c        |    7 +--
 src/target/arm_jtag.c          |    5 +-
 src/target/avrt.c              |   17 +------
 src/target/dsp563xx.c          |   16 +------
 src/target/embeddedice.c       |   26 +++--------
 src/target/etb.c               |   23 +++-------
 src/target/etm.c               |   12 +----
 src/target/feroceon.c          |    5 +--
 src/target/mips_ejtag.c        |   16 ++-----
 src/target/xscale.c            |   42 +++++-------------
 src/xsvf/xsvf.c                |   18 ++++----
 30 files changed, 240 insertions(+), 459 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar  8 08:35:49 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon,  8 Mar 2010 07:35:49 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-63-g7a5c9c2
Message-ID: <E1NoXVG-0006z9-QM@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7a5c9c2f4ae409e09faf12d5b8b76af135a85e73 (commit)
      from  50dc56a488c6e4d5acdfd73f12e3502e1586c51e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7a5c9c2f4ae409e09faf12d5b8b76af135a85e73
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 8 08:32:45 2010 +0100

    zy1000: embedded ice dcc tweak
    
    How many bits to shift out before/after enabled tap not
    in bypass is calculated outside the loop. This is more of
    a demonstration of principle and to clarify code than
    a performance optimisation as such. Follows up a bit
    on the simplification work in jtag interface.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 65d8402..005a4e0 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -803,34 +803,43 @@ int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 	return interface_add_tms_seq(state_count, seq, cur_state);
 }
 
-void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
+static void jtag_pre_post_bits(struct jtag_tap *tap, int *pre, int *post)
 {
-//	static int const reg_addr = 0x5;
-	tap_state_t end_state = jtag_get_end_state();
-	if (jtag_tap_next_enabled(jtag_tap_next_enabled(NULL)) == NULL)
+	/* bypass bits before and after */
+	int pre_bits = 0;
+	int post_bits = 0;
+
+	bool found = false;
+	struct jtag_tap *cur_tap, *nextTap;
+	for (cur_tap = jtag_tap_next_enabled(NULL); cur_tap!= NULL; cur_tap = nextTap)
 	{
-		/* better performance via code duplication */
-		if (little)
+		nextTap = jtag_tap_next_enabled(cur_tap);
+		if (cur_tap == tap)
 		{
-			int i;
-			for (i = 0; i < count; i++)
-			{
-				shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, 1));
-				shiftValueInner(TAP_DRSHIFT, end_state, 6, reg_addr | (1 << 5));
-				buffer += 4;
-			}
+			found = true;
 		} else
 		{
-			int i;
-			for (i = 0; i < count; i++)
+			if (found)
 			{
-				shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, 0));
-				shiftValueInner(TAP_DRSHIFT, end_state, 6, reg_addr | (1 << 5));
-				buffer += 4;
+				post_bits++;
+			} else
+			{
+				pre_bits++;
 			}
 		}
 	}
-	else
+	*pre = pre_bits;
+	*post = post_bits;
+}
+
+void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
+{
+
+	int pre_bits;
+	int post_bits;
+	jtag_pre_post_bits(tap, &pre_bits, &post_bits);
+
+	if ((pre_bits > 32) || (post_bits > 32))
 	{
 		int i;
 		for (i = 0; i < count; i++)
@@ -838,6 +847,22 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 			embeddedice_write_reg_inner(tap, reg_addr, fast_target_buffer_get_u32(buffer, little));
 			buffer += 4;
 		}
+	} else
+	{
+		tap_state_t end_state = jtag_get_end_state();
+		tap_state_t shift_end_state;
+		if (post_bits == 0)
+			shift_end_state = end_state;
+
+		int i;
+		for (i = 0; i < count; i++)
+		{
+			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
+			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, little));
+			shiftValueInner(TAP_DRSHIFT, shift_end_state, 6, reg_addr | (1 << 5));
+			shiftValueInner(shift_end_state, end_state, post_bits, 0);
+			buffer += 4;
+		}
 	}
 }
 
@@ -858,8 +883,9 @@ int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opc
 
 
 	/* bypass bits before and after */
-	int pre_bits = 0;
-	int post_bits = 0;
+	int pre_bits;
+	int post_bits;
+	jtag_pre_post_bits(tap, &pre_bits, &post_bits);
 
 	bool found = false;
 	struct jtag_tap *cur_tap, *nextTap;
@@ -895,6 +921,7 @@ int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opc
 		value |= (*t++<<24);
 
 		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, value);
+		/* minimum 2 bits */
 		shiftValueInner(TAP_DRSHIFT, TAP_DRPAUSE, post_bits, 0);
 
 #if 1

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   69 ++++++++++++++++++++++++++++++++--------------
 1 files changed, 48 insertions(+), 21 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar  8 18:46:37 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon,  8 Mar 2010 17:46:37 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-64-gfc1063a
Message-ID: <E1Noh2M-0005Ef-AR@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fc1063a1b9df5857ee3f1c18f88e5b821b5f0960 (commit)
      from  7a5c9c2f4ae409e09faf12d5b8b76af135a85e73 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fc1063a1b9df5857ee3f1c18f88e5b821b5f0960
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Mon Mar 8 18:31:27 2010 +0100

    cfi: simplify and clearify code
    
    At the end I have added comments /* FIXME: to be removed */
    There are 3 lines in which my simplification is not complete due to
    data dependency with LOG_DEBUG() messages visible in the patch.
    Such log_debug has been introduced on Jan 22, 2007 with commit
    4fc97d3f2726efa147cfdb0c456eace51550e1e3 during development activity
    in this file/procedure.
    
    From my point of view, these logs can be removed, since not part of a
    consistent flow of information.
    Alternatively, could be borrowed in the new cfi_send_command(), but
    this will increase verbosity.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index b0c7b0b..5f7ed1e 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -132,6 +132,14 @@ static void cfi_command(struct flash_bank *bank, uint8_t cmd, uint8_t *cmd_buf)
 	}
 }
 
+static int cfi_send_command(struct flash_bank *bank, uint8_t cmd, uint32_t address)
+{
+    uint8_t command[CFI_MAX_BUS_WIDTH];
+
+    cfi_command(bank, cmd, command);
+    return target_write_memory(bank->target, address, bank->bus_width, 1, command);
+}
+
 /* read unsigned 8-bit value from the bank
  * flash banks are expected to be made of similar chips
  * the query result should be the same for all
@@ -226,7 +234,6 @@ static uint32_t cfi_query_u32(struct flash_bank *bank, int sector, uint32_t offs
 static void cfi_intel_clear_status_register(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
-	uint8_t command[8];
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -234,8 +241,7 @@ static void cfi_intel_clear_status_register(struct flash_bank *bank)
 		exit(-1);
 	}
 
-	cfi_command(bank, 0x50, command);
-	target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command);
+	cfi_send_command(bank, 0x50, flash_address(bank, 0, 0x0));
 }
 
 uint8_t cfi_intel_wait_status_busy(struct flash_bank *bank, int timeout)
@@ -319,8 +325,6 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_intel_pri_ext *pri_ext = malloc(sizeof(struct cfi_intel_pri_ext));
-	struct target *target = bank->target;
-	uint8_t command[8];
 
 	cfi_info->pri_ext = pri_ext;
 
@@ -330,13 +334,11 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 
 	if ((pri_ext->pri[0] != 'P') || (pri_ext->pri[1] != 'R') || (pri_ext->pri[2] != 'I'))
 	{
-		cfi_command(bank, 0xf0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
-		cfi_command(bank, 0xff, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -385,8 +387,6 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_spansion_pri_ext *pri_ext = malloc(sizeof(struct cfi_spansion_pri_ext));
-	struct target *target = bank->target;
-	uint8_t command[8];
 
 	cfi_info->pri_ext = pri_ext;
 
@@ -396,8 +396,7 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 
 	if ((pri_ext->pri[0] != 'P') || (pri_ext->pri[1] != 'R') || (pri_ext->pri[2] != 'I'))
 	{
-		cfi_command(bank, 0xf0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -451,8 +450,6 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 	struct cfi_atmel_pri_ext atmel_pri_ext;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_spansion_pri_ext *pri_ext = malloc(sizeof(struct cfi_spansion_pri_ext));
-	struct target *target = bank->target;
-	uint8_t command[8];
 
 	/* ATMEL devices use the same CFI primary command set (0x2) as AMD/Spansion,
 	 * but a different primary extended query table.
@@ -469,8 +466,7 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 
 	if ((atmel_pri_ext.pri[0] != 'P') || (atmel_pri_ext.pri[1] != 'R') || (atmel_pri_ext.pri[2] != 'I'))
 	{
-		cfi_command(bank, 0xf0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -647,22 +643,18 @@ static int cfi_intel_erase(struct flash_bank *bank, int first, int last)
 {
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
-	struct target *target = bank->target;
-	uint8_t command[8];
 	int i;
 
 	cfi_intel_clear_status_register(bank);
 
 	for (i = first; i <= last; i++)
 	{
-		cfi_command(bank, 0x20, command);
-		if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x20, flash_address(bank, i, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		cfi_command(bank, 0xd0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xd0, flash_address(bank, i, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -671,8 +663,7 @@ static int cfi_intel_erase(struct flash_bank *bank, int first, int last)
 			bank->sectors[i].is_erased = 1;
 		else
 		{
-			cfi_command(bank, 0xff, command);
-			if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+			if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -682,9 +673,7 @@ static int cfi_intel_erase(struct flash_bank *bank, int first, int last)
 		}
 	}
 
-	cfi_command(bank, 0xff, command);
-	return target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command);
-
+	return cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0));
 }
 
 static int cfi_spansion_erase(struct flash_bank *bank, int first, int last)
@@ -692,44 +681,36 @@ static int cfi_spansion_erase(struct flash_bank *bank, int first, int last)
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
-	struct target *target = bank->target;
-	uint8_t command[8];
 	int i;
 
 	for (i = first; i <= last; i++)
 	{
-		cfi_command(bank, 0xaa, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		cfi_command(bank, 0x55, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock2), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		cfi_command(bank, 0x80, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x80, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		cfi_command(bank, 0xaa, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		cfi_command(bank, 0x55, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock2), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		cfi_command(bank, 0x30, command);
-		if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x30, flash_address(bank, i, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -738,8 +719,7 @@ static int cfi_spansion_erase(struct flash_bank *bank, int first, int last)
 			bank->sectors[i].is_erased = 1;
 		else
 		{
-			cfi_command(bank, 0xf0, command);
-			if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+			if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -749,8 +729,7 @@ static int cfi_spansion_erase(struct flash_bank *bank, int first, int last)
 		}
 	}
 
-	cfi_command(bank, 0xf0, command);
-	return target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command);
+	return	cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0));
 }
 
 static int cfi_erase(struct flash_bank *bank, int first, int last)
@@ -793,8 +772,8 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_intel_pri_ext *pri_ext = cfi_info->pri_ext;
-	struct target *target = bank->target;
-	uint8_t command[8];
+	struct target *target = bank->target; /* FIXME: to be removed */
+	uint8_t command[CFI_MAX_BUS_WIDTH]; /* FIXME: to be removed */
 	int retry = 0;
 	int i;
 
@@ -808,17 +787,17 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 
 	for (i = first; i <= last; i++)
 	{
-		cfi_command(bank, 0x60, command);
+		cfi_command(bank, 0x60, command); /* FIXME: to be removed */
 		LOG_DEBUG("address: 0x%4.4" PRIx32 ", command: 0x%4.4" PRIx32, flash_address(bank, i, 0x0), target_buffer_get_u32(target, command));
-		if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0x60, flash_address(bank, i, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
 		if (set)
 		{
-			cfi_command(bank, 0x01, command);
+			cfi_command(bank, 0x01, command); /* FIXME: to be removed */
 			LOG_DEBUG("address: 0x%4.4" PRIx32 ", command: 0x%4.4" PRIx32 , flash_address(bank, i, 0x0), target_buffer_get_u32(target, command));
-			if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+			if ((retval = cfi_send_command(bank, 0x01, flash_address(bank, i, 0x0))) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -826,9 +805,9 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 		}
 		else
 		{
-			cfi_command(bank, 0xd0, command);
+			cfi_command(bank, 0xd0, command); /* FIXME: to be removed */
 			LOG_DEBUG("address: 0x%4.4" PRIx32 ", command: 0x%4.4" PRIx32, flash_address(bank, i, 0x0), target_buffer_get_u32(target, command));
-			if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+			if ((retval = cfi_send_command(bank, 0xd0, flash_address(bank, i, 0x0))) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -845,8 +824,7 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 		{
 			uint8_t block_status;
 			/* read block lock bit, to verify status */
-			cfi_command(bank, 0x90, command);
-			if ((retval = target_write_memory(target, flash_address(bank, 0, 0x55), bank->bus_width, 1, command)) != ERROR_OK)
+			if ((retval = cfi_send_command(bank, 0x90, flash_address(bank, 0, 0x55))) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -855,8 +833,7 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 			if ((block_status & 0x1) != set)
 			{
 				LOG_ERROR("couldn't change block lock status (set = %i, block_status = 0x%2.2x)", set, block_status);
-				cfi_command(bank, 0x70, command);
-				if ((retval = target_write_memory(target, flash_address(bank, 0, 0x55), bank->bus_width, 1, command)) != ERROR_OK)
+				if ((retval = cfi_send_command(bank, 0x70, flash_address(bank, 0, 0x55))) != ERROR_OK)
 				{
 					return retval;
 				}
@@ -884,14 +861,12 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 			{
 				cfi_intel_clear_status_register(bank);
 
-				cfi_command(bank, 0x60, command);
-				if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+				if ((retval = cfi_send_command(bank, 0x60, flash_address(bank, i, 0x0))) != ERROR_OK)
 				{
 					return retval;
 				}
 
-				cfi_command(bank, 0x01, command);
-				if ((retval = target_write_memory(target, flash_address(bank, i, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+				if ((retval = cfi_send_command(bank, 0x01, flash_address(bank, i, 0x0))) != ERROR_OK)
 				{
 					return retval;
 				}
@@ -901,8 +876,7 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 		}
 	}
 
-	cfi_command(bank, 0xff, command);
-	return target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command);
+	return cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0));
 }
 
 static int cfi_protect(struct flash_bank *bank, int set, int first, int last)
@@ -1555,11 +1529,9 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint8_t command[8];
 
 	cfi_intel_clear_status_register(bank);
-	cfi_command(bank, 0x40, command);
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x40, address)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -1571,8 +1543,7 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 
 	if (cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max)) != 0x80)
 	{
-		cfi_command(bank, 0xff, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -1589,7 +1560,6 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint8_t command[8];
 
 	/* Calculate buffer size and boundary mask */
 	uint32_t buffersize = (1UL << cfi_info->max_buf_write_size) * (bank->bus_width / bank->chip_width);
@@ -1627,15 +1597,13 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	cfi_intel_clear_status_register(bank);
 
 	/* Initiate buffer operation _*/
-	cfi_command(bank, 0xE8, command);
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xe8, address)) != ERROR_OK)
 	{
 		return retval;
 	}
 	if (cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max)) != 0x80)
 	{
-		cfi_command(bank, 0xff, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -1645,8 +1613,7 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	}
 
 	/* Write buffer wordcount-1 and data words */
-	cfi_command(bank, bufferwsize-1, command);
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, bufferwsize-1, address)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -1657,15 +1624,13 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	}
 
 	/* Commit write operation */
-	cfi_command(bank, 0xd0, command);
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xd0, address)) != ERROR_OK)
 	{
 		return retval;
 	}
 	if (cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max)) != 0x80)
 	{
-		cfi_command(bank, 0xff, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -1683,22 +1648,18 @@ static int cfi_spansion_write_word(struct flash_bank *bank, uint8_t *word, uint3
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
 	struct target *target = bank->target;
-	uint8_t command[8];
 
-	cfi_command(bank, 0xaa, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	cfi_command(bank, 0x55, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock2), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	cfi_command(bank, 0xa0, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xa0, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -1710,8 +1671,7 @@ static int cfi_spansion_write_word(struct flash_bank *bank, uint8_t *word, uint3
 
 	if (cfi_spansion_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
 	{
-		cfi_command(bank, 0xf0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -1728,7 +1688,6 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint8_t command[8];
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
 
 	/* Calculate buffer size and boundary mask */
@@ -1762,28 +1721,24 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 	}
 
 	// Unlock
-	cfi_command(bank, 0xaa, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	cfi_command(bank, 0x55, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock2), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 	{
 		return retval;
 	}
 
 	// Buffer load command
-	cfi_command(bank, 0x25, command);
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x25, address)) != ERROR_OK)
 	{
 		return retval;
 	}
 
 	/* Write buffer wordcount-1 and data words */
-	cfi_command(bank, bufferwsize-1, command);
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, bufferwsize-1, address)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -1794,16 +1749,14 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 	}
 
 	/* Commit write operation */
-	cfi_command(bank, 0x29, command);
-	if ((retval = target_write_memory(target, address, bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x29, address)) != ERROR_OK)
 	{
 		return retval;
 	}
 
 	if (cfi_spansion_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max)) != ERROR_OK)
 	{
-		cfi_command(bank, 0xf0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -2017,13 +1970,11 @@ int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_
 	}
 
 	/* return to read array mode, so we can read from flash again for padding */
-	cfi_command(bank, 0xf0, current_word);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, current_word)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 	{
 		return retval;
 	}
-	cfi_command(bank, 0xff, current_word);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, current_word)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2057,13 +2008,11 @@ int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_
 	}
 
 	/* return to read array mode */
-	cfi_command(bank, 0xf0, current_word);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, current_word)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 	{
 		return retval;
 	}
-	cfi_command(bank, 0xff, current_word);
-	return target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, current_word);
+	return cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0));
 }
 
 static void cfi_fixup_atmel_reversed_erase_regions(struct flash_bank *bank, void *param)
@@ -2112,12 +2061,9 @@ static void cfi_fixup_0002_unlock_addresses(struct flash_bank *bank, void *param
 static int cfi_query_string(struct flash_bank *bank, int address)
 {
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
-	struct target *target = bank->target;
 	int retval;
-	uint8_t command[8];
 
-	cfi_command(bank, 0x98, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, address), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x98, flash_address(bank, 0, address))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2130,13 +2076,11 @@ static int cfi_query_string(struct flash_bank *bank, int address)
 
 	if ((cfi_info->qry[0] != 'Q') || (cfi_info->qry[1] != 'R') || (cfi_info->qry[2] != 'Y'))
 	{
-		cfi_command(bank, 0xf0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
-		cfi_command(bank, 0xff, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -2151,7 +2095,6 @@ static int cfi_probe(struct flash_bank *bank)
 {
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint8_t command[8];
 	int num_sectors = 0;
 	int i;
 	int sector = 0;
@@ -2177,18 +2120,15 @@ static int cfi_probe(struct flash_bank *bank)
 	}
 
 	/* switch to read identifier codes mode ("AUTOSELECT") */
-	cfi_command(bank, 0xaa, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
-	cfi_command(bank, 0x55, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, unlock2), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, unlock2))) != ERROR_OK)
 	{
 		return retval;
 	}
-	cfi_command(bank, 0x90, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x90, flash_address(bank, 0, unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2221,13 +2161,11 @@ static int cfi_probe(struct flash_bank *bank)
 
 	LOG_INFO("Flash Manufacturer/Device: 0x%04x 0x%04x", cfi_info->manufacturer, cfi_info->device_id);
 	/* switch back to read array mode */
-	cfi_command(bank, 0xf0, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, 0x00), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x00))) != ERROR_OK)
 	{
 		return retval;
 	}
-	cfi_command(bank, 0xff, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, 0x00), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x00))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2344,13 +2282,11 @@ static int cfi_probe(struct flash_bank *bank)
 		/* return to read array mode
 		 * we use both reset commands, as some Intel flashes fail to recognize the 0xF0 command
 		 */
-		cfi_command(bank, 0xf0, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
-		cfi_command(bank, 0xff, command);
-		if ((retval = target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command)) != ERROR_OK)
+		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -2440,16 +2376,13 @@ static int cfi_intel_protect_check(struct flash_bank *bank)
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_intel_pri_ext *pri_ext = cfi_info->pri_ext;
-	struct target *target = bank->target;
-	uint8_t command[CFI_MAX_BUS_WIDTH];
 	int i;
 
 	/* check if block lock bits are supported on this device */
 	if (!(pri_ext->blk_status_reg_mask & 0x1))
 		return ERROR_FLASH_OPERATION_FAILED;
 
-	cfi_command(bank, 0x90, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, 0x55), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x90, flash_address(bank, 0, 0x55))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2464,8 +2397,7 @@ static int cfi_intel_protect_check(struct flash_bank *bank)
 			bank->sectors[i].is_protected = 0;
 	}
 
-	cfi_command(bank, 0xff, command);
-	return target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command);
+	return cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0));
 }
 
 static int cfi_spansion_protect_check(struct flash_bank *bank)
@@ -2473,24 +2405,19 @@ static int cfi_spansion_protect_check(struct flash_bank *bank)
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
-	struct target *target = bank->target;
-	uint8_t command[8];
 	int i;
 
-	cfi_command(bank, 0xaa, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0xaa, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	cfi_command(bank, 0x55, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock2), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x55, flash_address(bank, 0, pri_ext->_unlock2))) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	cfi_command(bank, 0x90, command);
-	if ((retval = target_write_memory(target, flash_address(bank, 0, pri_ext->_unlock1), bank->bus_width, 1, command)) != ERROR_OK)
+	if ((retval = cfi_send_command(bank, 0x90, flash_address(bank, 0, pri_ext->_unlock1))) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2505,8 +2432,7 @@ static int cfi_spansion_protect_check(struct flash_bank *bank)
 			bank->sectors[i].is_protected = 0;
 	}
 
-	cfi_command(bank, 0xf0, command);
-	return target_write_memory(target, flash_address(bank, 0, 0x0), bank->bus_width, 1, command);
+	return cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0));
 }
 
 static int cfi_protect_check(struct flash_bank *bank)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |  224 +++++++++++++++++----------------------------------
 1 files changed, 75 insertions(+), 149 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Mar  9 04:19:19 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  9 Mar 2010 03:19:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-65-gc986cc2
Message-ID: <E1Nopyb-0001nN-3H@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c986cc200cb7e0904a200992e1288007aa4c8c07 (commit)
      from  fc1063a1b9df5857ee3f1c18f88e5b821b5f0960 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c986cc200cb7e0904a200992e1288007aa4c8c07
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Mar 8 19:10:05 2010 -0800

    move a constant table to .rodata section
    
    The table of command registration functions shouldn't be
    in writable memory, where stray pointers can clobber it.
    Also, it shouldn't be initialized at runtime; that just
    consumes needless code space.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/openocd.c b/src/openocd.c
index a689d59..7833606 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -202,7 +202,7 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 
 	/* register subsystem commands */
 	typedef int (*command_registrant_t)(struct command_context *cmd_ctx);
-	command_registrant_t command_registrants[] = {
+	static const command_registrant_t command_registrants[] = {
 		&openocd_register_commands,
 		&server_register_commands,
 		&gdb_register_commands,

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar  9 22:54:56 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue,  9 Mar 2010 21:54:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-66-g17d437a
Message-ID: <E1Np7OE-0007Aw-5c@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  17d437a7a193e783e8daeb0837e6dad5e6811213 (commit)
      from  c986cc200cb7e0904a200992e1288007aa4c8c07 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 17d437a7a193e783e8daeb0837e6dad5e6811213
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Tue Mar 9 00:43:59 2010 +0800

    CFI CORE: bug-fix protect single sector
    
    Cannot protect or unprotect single sector in cfi flash.
    When first==last the procedure fails.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 767006d..8b581b0 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -73,7 +73,7 @@ int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
 	 * speeds at least some things up.
 	 */
 scan:
-	for (int i = first; i < last; i++) {
+	for (int i = first; i <= last; i++) {
 		struct flash_sector *sector = bank->sectors + i;
 
 		/* Only filter requests to protect the already-protected, or
@@ -108,7 +108,7 @@ scan:
 	}
 
 	/* Single sector, already protected?  Nothing to do! */
-	if (first == last)
+	if (first > last)
 		return ERROR_OK;
 
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/core.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Mar 10 21:38:00 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 10 Mar 2010 20:38:00 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-70-gf10ed95
Message-ID: <E1NpSfM-00058Z-Gm@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f10ed95a5ce6be416bcb2ec20826c6e508e4b622 (commit)
       via  d0a57c0f0c3be172195b12e27b668919488f5d00 (commit)
       via  6344f2ab98cf1fd1f92403de46b6e36b3b122ad5 (commit)
       via  2946c895a175e586a7f79797e2168c9fd0eddbbe (commit)
      from  17d437a7a193e783e8daeb0837e6dad5e6811213 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f10ed95a5ce6be416bcb2ec20826c6e508e4b622
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Mar 8 20:32:11 2010 +0000

    STM32: flash loader cleanup
    
    - make algorithm array static const.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index ebdcde7..845d589 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -362,9 +362,11 @@ static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if ((first && (first % stm32x_info->ppage_size)) || ((last + 1) && (last + 1) % stm32x_info->ppage_size))
+	if ((first && (first % stm32x_info->ppage_size)) || ((last + 1) &&
+			(last + 1) % stm32x_info->ppage_size))
 	{
-		LOG_WARNING("Error: start and end sectors must be on a %d sector boundary", stm32x_info->ppage_size);
+		LOG_WARNING("Error: start and end sectors must be on a %d sector boundary",
+				stm32x_info->ppage_size);
 		return ERROR_FLASH_SECTOR_INVALID;
 	}
 
@@ -432,7 +434,8 @@ static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
 	return stm32x_write_options(bank);
 }
 
-static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
 {
 	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
 	struct target *target = bank->target;
@@ -443,7 +446,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 	struct armv7m_algorithm armv7m_info;
 	int retval = ERROR_OK;
 
-	uint8_t stm32x_flash_write_code[] = {
+	static const uint8_t stm32x_flash_write_code[] = {
 									/* write: */
 		0xDF, 0xF8, 0x24, 0x40,		/* ldr	r4, STM32_FLASH_CR */
 		0x09, 0x4D,					/* ldr	r5, STM32_FLASH_SR */
@@ -465,13 +468,16 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 	};
 
 	/* flash write code */
-	if (target_alloc_working_area(target, sizeof(stm32x_flash_write_code), &stm32x_info->write_algorithm) != ERROR_OK)
+	if (target_alloc_working_area(target, sizeof(stm32x_flash_write_code),
+			&stm32x_info->write_algorithm) != ERROR_OK)
 	{
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	if ((retval = target_write_buffer(target, stm32x_info->write_algorithm->address, sizeof(stm32x_flash_write_code), stm32x_flash_write_code)) != ERROR_OK)
+	if ((retval = target_write_buffer(target, stm32x_info->write_algorithm->address,
+			sizeof(stm32x_flash_write_code),
+			(uint8_t*)stm32x_flash_write_code)) != ERROR_OK)
 		return retval;
 
 	/* memory buffer */
@@ -480,7 +486,8 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 		buffer_size /= 2;
 		if (buffer_size <= 256)
 		{
-			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
 			if (stm32x_info->write_algorithm)
 				target_free_working_area(target, stm32x_info->write_algorithm);
 
@@ -499,17 +506,21 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 
 	while (count > 0)
 	{
-		uint32_t thisrun_count = (count > (buffer_size / 2)) ? (buffer_size / 2) : count;
+		uint32_t thisrun_count = (count > (buffer_size / 2)) ?
+				(buffer_size / 2) : count;
 
-		if ((retval = target_write_buffer(target, source->address, thisrun_count * 2, buffer)) != ERROR_OK)
+		if ((retval = target_write_buffer(target, source->address,
+				thisrun_count * 2, buffer)) != ERROR_OK)
 			break;
 
 		buf_set_u32(reg_params[0].value, 0, 32, source->address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
 
-		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params, stm32x_info->write_algorithm->address, \
-				stm32x_info->write_algorithm->address + (sizeof(stm32x_flash_write_code) - 10), 10000, &armv7m_info)) != ERROR_OK)
+		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
+				stm32x_info->write_algorithm->address,
+				stm32x_info->write_algorithm->address + (sizeof(stm32x_flash_write_code) - 10),
+				10000, &armv7m_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing stm32x flash write algorithm");
 			retval = ERROR_FLASH_OPERATION_FAILED;
@@ -550,7 +561,8 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 	return retval;
 }
 
-static int stm32x_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
 {
 	struct target *target = bank->target;
 	uint32_t words_remaining = (count / 2);
@@ -1269,6 +1281,7 @@ static const struct command_registration stm32x_exec_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 static const struct command_registration stm32x_command_handlers[] = {
 	{
 		.name = "stm32x",

commit d0a57c0f0c3be172195b12e27b668919488f5d00
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Mar 8 20:31:50 2010 +0000

    STR7: flash loader cleanup
    
    - make algorithm array static const.
     - increase algorithm buffer size to 32k.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 3bf07c9..fa1744c 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -316,18 +316,19 @@ static int str7x_protect(struct flash_bank *bank, int set, int first, int last)
 	return ERROR_OK;
 }
 
-static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
 {
 	struct str7x_flash_bank *str7x_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint32_t buffer_size = 8192;
+	uint32_t buffer_size = 32768;
 	struct working_area *source;
 	uint32_t address = bank->base + offset;
 	struct reg_param reg_params[6];
 	struct arm_algorithm armv4_5_info;
 	int retval = ERROR_OK;
 
-	uint32_t str7x_flash_write_code[] = {
+	static const uint32_t str7x_flash_write_code[] = {
 					/* write:				*/
 		0xe3a04201, /*	mov r4, #0x10000000	*/
 		0xe5824000, /*	str r4, [r2, #0x0]	*/
@@ -354,13 +355,16 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 	};
 
 	/* flash write code */
-	if (target_alloc_working_area(target, 4 * 20, &str7x_info->write_algorithm) != ERROR_OK)
+	if (target_alloc_working_area(target, sizeof(str7x_flash_write_code),
+			&str7x_info->write_algorithm) != ERROR_OK)
 	{
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	target_write_buffer(target, str7x_info->write_algorithm->address, 20 * 4, (uint8_t*)str7x_flash_write_code);
+	target_write_buffer(target, str7x_info->write_algorithm->address,
+			sizeof(str7x_flash_write_code),
+			(uint8_t*)str7x_flash_write_code);
 
 	/* memory buffer */
 	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
@@ -368,7 +372,8 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 		buffer_size /= 2;
 		if (buffer_size <= 256)
 		{
-			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
 			if (str7x_info->write_algorithm)
 				target_free_working_area(target, str7x_info->write_algorithm);
 
@@ -400,7 +405,10 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 		buf_set_u32(reg_params[3].value, 0, 32, thisrun_count);
 		buf_set_u32(reg_params[5].value, 0, 32, str7x_info->busy_bits);
 
-		if ((retval = target_run_algorithm(target, 0, NULL, 6, reg_params, str7x_info->write_algorithm->address, str7x_info->write_algorithm->address + (19 * 4), 10000, &armv4_5_info)) != ERROR_OK)
+		if ((retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
+				str7x_info->write_algorithm->address,
+				str7x_info->write_algorithm->address + (sizeof(str7x_flash_write_code) - 4),
+				10000, &armv4_5_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing str7x flash write algorithm");
 			retval = ERROR_FLASH_OPERATION_FAILED;
@@ -431,7 +439,8 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t
 	return retval;
 }
 
-static int str7x_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
 {
 	struct target *target = bank->target;
 	struct str7x_flash_bank *str7x_info = bank->driver_priv;
@@ -482,7 +491,8 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset
 	if (dwords_remaining > 0)
 	{
 		/* try using a block write */
-		if ((retval = str7x_write_block(bank, buffer, offset, dwords_remaining)) != ERROR_OK)
+		if ((retval = str7x_write_block(bank, buffer, offset,
+				dwords_remaining)) != ERROR_OK)
 		{
 			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
 			{
@@ -517,11 +527,13 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), address);
 
 		/* data word 1 */
-		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR0), 4, 1, buffer + bytes_written);
+		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR0),
+				4, 1, buffer + bytes_written);
 		bytes_written += 4;
 
 		/* data word 2 */
-		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR1), 4, 1, buffer + bytes_written);
+		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR1),
+				4, 1, buffer + bytes_written);
 		bytes_written += 4;
 
 		/* start programming cycle */
@@ -564,11 +576,13 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), address);
 
 		/* data word 1 */
-		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR0), 4, 1, last_dword);
+		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR0),
+				4, 1, last_dword);
 		bytes_written += 4;
 
 		/* data word 2 */
-		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR1), 4, 1, last_dword + 4);
+		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR1),
+				4, 1, last_dword + 4);
 		bytes_written += 4;
 
 		/* start programming cycle */
@@ -677,7 +691,8 @@ COMMAND_HANDLER(str7x_handle_disable_jtag_command)
 		flash_cmd = FLASH_SPR;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), flash_cmd);
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), 0x4010DFBC);
-		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_DR0), ~(1 << (15 + ProtectionLevel)));
+		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_DR0),
+				~(1 << (15 + ProtectionLevel)));
 		flash_cmd = FLASH_SPR | FLASH_WMS;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), flash_cmd);
 	}
@@ -694,6 +709,7 @@ static const struct command_registration str7x_exec_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 static const struct command_registration str7x_command_handlers[] = {
 	{
 		.name = "str7x",

commit 6344f2ab98cf1fd1f92403de46b6e36b3b122ad5
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Mar 8 20:31:25 2010 +0000

    STR9: flash loader cleanup
    
    - make algorithm array static const.
     - increase algorithm buffer size to 32k.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 0875851..3d8b84b 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -340,14 +340,14 @@ static int str9x_write_block(struct flash_bank *bank,
 {
 	struct str9x_flash_bank *str9x_info = bank->driver_priv;
 	struct target *target = bank->target;
-	uint32_t buffer_size = 8192;
+	uint32_t buffer_size = 32768;
 	struct working_area *source;
 	uint32_t address = bank->base + offset;
 	struct reg_param reg_params[4];
 	struct arm_algorithm armv4_5_info;
 	int retval = ERROR_OK;
 
-	uint32_t str9x_flash_write_code[] = {
+	static const uint32_t str9x_flash_write_code[] = {
 					/* write:				*/
 		0xe3c14003,	/*	bic	r4, r1, #3		*/
 		0xe3a03040,	/*	mov	r3, #0x40		*/
@@ -373,13 +373,16 @@ static int str9x_write_block(struct flash_bank *bank,
 	};
 
 	/* flash write code */
-	if (target_alloc_working_area(target, 4 * 19, &str9x_info->write_algorithm) != ERROR_OK)
+	if (target_alloc_working_area(target, sizeof(str9x_flash_write_code),
+			&str9x_info->write_algorithm) != ERROR_OK)
 	{
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	target_write_buffer(target, str9x_info->write_algorithm->address, 19 * 4, (uint8_t*)str9x_flash_write_code);
+	target_write_buffer(target, str9x_info->write_algorithm->address,
+			sizeof(str9x_flash_write_code),
+			(uint8_t*)str9x_flash_write_code);
 
 	/* memory buffer */
 	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
@@ -387,7 +390,8 @@ static int str9x_write_block(struct flash_bank *bank,
 		buffer_size /= 2;
 		if (buffer_size <= 256)
 		{
-			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
 			if (str9x_info->write_algorithm)
 				target_free_working_area(target, str9x_info->write_algorithm);
 
@@ -415,7 +419,10 @@ static int str9x_write_block(struct flash_bank *bank,
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
 
-		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params, str9x_info->write_algorithm->address, str9x_info->write_algorithm->address + (18 * 4), 10000, &armv4_5_info)) != ERROR_OK)
+		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
+				str9x_info->write_algorithm->address,
+				str9x_info->write_algorithm->address + (sizeof(str9x_flash_write_code) - 4),
+				10000, &armv4_5_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing str9x flash write algorithm");
 			retval = ERROR_FLASH_OPERATION_FAILED;
@@ -676,6 +683,7 @@ static const struct command_registration str9x_config_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 static const struct command_registration str9x_command_handlers[] = {
 	{
 		.name = "str9x",
diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index b6d24f5..35fe806 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -551,7 +551,8 @@ static int str9xpec_set_address(struct flash_bank *bank, uint8_t sector)
 	return ERROR_OK;
 }
 
-static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
 {
 	struct str9xpec_flash_controller *str9xpec_info = bank->driver_priv;
 	uint32_t dwords_remaining = (count / 8);
@@ -619,7 +620,8 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer, uint32_t off
 	{
 		str9xpec_set_address(bank, str9xpec_info->sector_bits[i]);
 
-		dwords_remaining = dwords_remaining < (bank->sectors[i].size/8) ? dwords_remaining : (bank->sectors[i].size/8);
+		dwords_remaining = dwords_remaining < (bank->sectors[i].size/8)
+				? dwords_remaining : (bank->sectors[i].size/8);
 
 		while (dwords_remaining > 0)
 		{
@@ -1226,6 +1228,7 @@ static const struct command_registration str9xpec_config_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 static const struct command_registration str9xpec_command_handlers[] = {
 	{
 		.name = "str9xpec",

commit 2946c895a175e586a7f79797e2168c9fd0eddbbe
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Mar 8 20:30:53 2010 +0000

    ADUC702x: flash loader cleanup
    
    - make algorithm array static const.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 7e81b32..88072b9 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -188,7 +188,7 @@ static int aduc702x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32
         r6 - set to 2, used to write flash command
 
         */
-        uint32_t aduc702x_flash_write_code[] = {
+        static const uint32_t aduc702x_flash_write_code[] = {
         //<_start>:
                 0xe3a05008,	// mov	r5, #8	; 0x8
                 0xe5845004,	// str	r5, [r4, #4]

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/aduc702x.c |    2 +-
 src/flash/nor/stm32x.c   |   37 +++++++++++++++++++++++++------------
 src/flash/nor/str7x.c    |   44 ++++++++++++++++++++++++++++++--------------
 src/flash/nor/str9x.c    |   20 ++++++++++++++------
 src/flash/nor/str9xpec.c |    7 +++++--
 5 files changed, 75 insertions(+), 35 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Mar 10 22:05:38 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 10 Mar 2010 21:05:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-71-g257a764
Message-ID: <E1NpT64-0000eY-8s@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  257a764582f52235414b5c35717b0ee2b49d4b0d (commit)
      from  f10ed95a5ce6be416bcb2ec20826c6e508e4b622 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 257a764582f52235414b5c35717b0ee2b49d4b0d
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Mar 8 22:54:18 2010 +0000

    PIC32: add flash algorithm support
    
    Add flash algorithm support for the PIC32MX.
    Still a few things todo but this dramatically decreases
    the programing time, eg. approx programming for 2.5k test file.
     - without fastload: 60secs
     - with fastload: 45secs
     - with fastload and algorithm: 2secs.
    
    Add new devices to supported list.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 1f66346..c46264c 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -29,38 +29,40 @@
 
 #include "imp.h"
 #include "pic32mx.h"
+#include <target/algorithm.h>
 #include <target/mips32.h>
 
-
-static
-struct pic32mx_devs_s {
+static const struct pic32mx_devs_s {
 	uint8_t	devid;
-	char	*name;
-	uint32_t	pfm_size;
+	char *name;
 } pic32mx_devs[] = {
-	{ 0x78, "460F512L USB", 512 },
-	{ 0x74, "460F256L USB", 256 },
-	{ 0x6D, "440F128L USB", 128 },
-	{ 0x56, "440F512H USB", 512 },
-	{ 0x52, "440F256H USB", 256 },
-	{ 0x4D, "440F128H USB", 128 },
-	{ 0x42, "420F032H USB",  32 },
-	{ 0x38, "360F512L",     512 },
-	{ 0x34, "360F256L",     256 },
-	{ 0x2D, "340F128L",     128 },
-	{ 0x2A, "320F128L",     128 },
-	{ 0x16, "340F512H",     512 },
-	{ 0x12, "340F256H",     256 },
-	{ 0x0D, "340F128H",     128 },
-	{ 0x0A, "320F128H",     128 },
-	{ 0x06, "320F064H",      64 },
-	{ 0x02, "320F032H",      32 },
-	{ 0x00, NULL, 0 }
+	{0x38, "360F512L"},
+	{0x34, "360F256L"},
+	{0x2D, "340F128L"},
+	{0x2A, "320F128L"},
+	{0x16, "340F512H"},
+	{0x12, "340F256H"},
+	{0x0D, "340F128H"},
+	{0x0A, "320F128H"},
+	{0x06, "320F064H"},
+	{0x02, "320F032H"},
+	{0x07, "795F512L"},
+	{0x0E, "795F512H"},
+	{0x11, "675F512L"},
+	{0x0C, "675F512H"},
+	{0x0F, "575F512L"},
+	{0x09, "575F512H"},
+	{0x17, "575F256H"},
+	{0x78, "460F512L"},
+	{0x74, "460F256L"},
+	{0x6D, "440F128L"},
+	{0x56, "440F512H"},
+	{0x52, "440F256H"},
+	{0x4D, "440F128H"},
+	{0x42, "420F032H"},
+	{0x00, NULL}
 };
 
-static int pic32mx_write_row(struct flash_bank *bank, uint32_t address, uint32_t srcaddr);
-static int pic32mx_write_word(struct flash_bank *bank, uint32_t address, uint32_t word);
-
 /* flash bank pic32mx <base> <size> 0 0 <target#>
  */
 FLASH_BANK_COMMAND_HANDLER(pic32mx_flash_bank_command)
@@ -145,9 +147,10 @@ static int pic32mx_protect_check(struct flash_bank *bank)
 	}
 
 	target_read_u32(target, PIC32MX_DEVCFG0, &devcfg0);
+
 	if ((devcfg0 & (1 << 28)) == 0) /* code protect bit */
 		num_pages = 0xffff;  /* All pages protected */
-	else if (bank->base == PIC32MX_KSEG1_BOOT_FLASH)
+	else if (Virt2Phys(bank->base) == PIC32MX_PHYS_BOOT_FLASH)
 	{
 		if (devcfg0 & (1 << 24))
 			num_pages = 0;       /* All pages unprotected */
@@ -156,6 +159,7 @@ static int pic32mx_protect_check(struct flash_bank *bank)
 	}
 	else /* pgm flash */
 		num_pages = (~devcfg0 >> 12) & 0xff;
+
 	for (s = 0; s < bank->num_sectors && s < num_pages; s++)
 		bank->sectors[s].is_protected = 1;
 	for (; s < bank->num_sectors; s++)
@@ -176,8 +180,11 @@ static int pic32mx_erase(struct flash_bank *bank, int first, int last)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if ((first == 0) && (last == (bank->num_sectors - 1)) && (bank->base == PIC32MX_KSEG0_PGM_FLASH || bank->base == PIC32MX_KSEG1_PGM_FLASH))
+	if ((first == 0) && (last == (bank->num_sectors - 1))
+		&& (Virt2Phys(bank->base) == PIC32MX_PHYS_PGM_FLASH))
 	{
+		/* this will only erase the Program Flash (PFM), not the Boot Flash (BFM)
+		 * we need to use the MTAP to perform a full erase */
 		LOG_DEBUG("Erasing entire program flash");
 		status = pic32mx_nvm_exec(bank, NVMCON_OP_PFM_ERASE, 50);
 		if (status & NVMCON_NVMERR)
@@ -189,10 +196,7 @@ static int pic32mx_erase(struct flash_bank *bank, int first, int last)
 
 	for (i = first; i <= last; i++)
 	{
-		if (bank->base >= PIC32MX_KSEG1_PGM_FLASH)
-			target_write_u32(target, PIC32MX_NVMADDR, KS1Virt2Phys(bank->base + bank->sectors[i].offset));
-		else
-			target_write_u32(target, PIC32MX_NVMADDR, KS0Virt2Phys(bank->base + bank->sectors[i].offset));
+		target_write_u32(target, PIC32MX_NVMADDR, Virt2Phys(bank->base + bank->sectors[i].offset));
 
 		status = pic32mx_nvm_exec(bank, NVMCON_OP_PAGE_ERASE, 10);
 
@@ -210,12 +214,6 @@ static int pic32mx_protect(struct flash_bank *bank, int set, int first, int last
 {
 	struct pic32mx_flash_bank *pic32mx_info = NULL;
 	struct target *target = bank->target;
-#if 0
-	uint16_t prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
-	int i, reg, bit;
-	int status;
-	uint32_t protection;
-#endif
 
 	pic32mx_info = bank->driver_priv;
 
@@ -225,205 +223,177 @@ static int pic32mx_protect(struct flash_bank *bank, int set, int first, int last
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-#if 0
-	if ((first && (first % pic32mx_info->ppage_size)) || ((last + 1) && (last + 1) % pic32mx_info->ppage_size))
-	{
-		LOG_WARNING("sector start/end incorrect - stm32 has %dK sector protection", pic32mx_info->ppage_size);
-		return ERROR_FLASH_SECTOR_INVALID;
-	}
-
-	/* medium density - each bit refers to a 4bank protection
-	 * high density - each bit refers to a 2bank protection */
-	target_read_u32(target, PIC32MX_FLASH_WRPR, &protection);
-
-	prot_reg[0] = (uint16_t)protection;
-	prot_reg[1] = (uint16_t)(protection >> 8);
-	prot_reg[2] = (uint16_t)(protection >> 16);
-	prot_reg[3] = (uint16_t)(protection >> 24);
-
-	if (pic32mx_info->ppage_size == 2)
-	{
-		/* high density flash */
-
-		/* bit 7 controls sector 62 - 255 protection */
-		if (last > 61)
-		{
-			if (set)
-				prot_reg[3] &= ~(1 << 7);
-			else
-				prot_reg[3] |= (1 << 7);
-		}
-
-		if (first > 61)
-			first = 62;
-		if (last > 61)
-			last = 61;
-
-		for (i = first; i <= last; i++)
-		{
-			reg = (i / pic32mx_info->ppage_size) / 8;
-			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
-
-			if (set)
-				prot_reg[reg] &= ~(1 << bit);
-			else
-				prot_reg[reg] |= (1 << bit);
-		}
-	}
-	else
-	{
-		/* medium density flash */
-		for (i = first; i <= last; i++)
-		{
-			reg = (i / pic32mx_info->ppage_size) / 8;
-			bit = (i / pic32mx_info->ppage_size) - (reg * 8);
-
-			if (set)
-				prot_reg[reg] &= ~(1 << bit);
-			else
-				prot_reg[reg] |= (1 << bit);
-		}
-	}
-
-	if ((status = pic32mx_erase_options(bank)) != ERROR_OK)
-		return status;
-
-	pic32mx_info->option_bytes.protection[0] = prot_reg[0];
-	pic32mx_info->option_bytes.protection[1] = prot_reg[1];
-	pic32mx_info->option_bytes.protection[2] = prot_reg[2];
-	pic32mx_info->option_bytes.protection[3] = prot_reg[3];
-
-	return pic32mx_write_options(bank);
-#else
 	return ERROR_OK;
-#endif
 }
 
-static int pic32mx_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+static const uint32_t pic32mx_flash_write_code[] = {
+					/* write: */
+	0x3C08AA99,		/* lui $t0, 0xaa99 */
+	0x35086655,		/* ori $t0, 0x6655 */
+	0x3C095566,		/* lui $t1, 0x5566 */
+	0x352999AA,		/* ori $t1, 0x99aa */
+	0x3C0ABF80,		/* lui $t2, 0xbf80 */
+	0x354AF400,		/* ori $t2, 0xf400 */
+	0x340B4003,		/* ori $t3, $zero, 0x4003 */
+	0x340C8000,		/* ori $t4, $zero, 0x8000 */
+					/* write_row: */
+	0x2CD30080,		/* sltiu $s3, $a2, 128 */
+	0x16600008,		/* bne $s3, $zero, write_word */
+	0x340D4000,		/* ori $t5, $zero, 0x4000 */
+	0xAD450020,		/* sw $a1, 32($t2) */
+	0xAD440040,		/* sw $a0, 64($t2) */
+	0x04110016,		/* bal progflash */
+	0x24840200,		/* addiu $a0, $a0, 512 */
+	0x24A50200,		/* addiu $a1, $a1, 512 */
+	0x1000FFF7,		/* beq $zero, $zero, write_row */
+	0x24C6FF80,		/* addiu $a2, $a2, -128 */
+					/* write_word: */
+	0x3C15A000,		/* lui $s5, 0xa000 */
+	0x36B50000,		/* ori $s5, $s5, 0x0 */
+	0x00952025,		/* or $a0, $a0, $s5 */
+	0x10000008,		/* beq $zero, $zero, next_word */
+	0x340B4001,		/* ori $t3, $zero, 0x4001 */
+					/* prog_word: */
+	0x8C940000,		/* lw $s4, 0($a0) */
+	0xAD540030,		/* sw $s4, 48($t2) */
+	0xAD450020,		/* sw $a1, 32($t2) */
+	0x04110009,		/* bal progflash */
+	0x24840004,		/* addiu $a0, $a0, 4 */
+	0x24A50004,		/* addiu $a1, $a1, 4 */
+	0x24C6FFFF,		/* addiu $a2, $a2, -1 */
+					/* next_word: */
+	0x14C0FFF8,		/* bne $a2, $zero, prog_word */
+	0x00000000,		/* nop */
+					/* done: */
+	0x10000002,		/* beq $zero, $zero, exit */
+	0x24040000,		/* addiu $a0, $zero, 0 */
+					/* error: */
+	0x26240000,		/* addiu $a0, $s1, 0 */
+					/* exit: */
+	0x7000003F,		/* sdbbp */
+					/* progflash: */
+	0xAD4B0000,		/* sw $t3, 0($t2) */
+	0xAD480010,		/* sw $t0, 16($t2) */
+	0xAD490010,		/* sw $t1, 16($t2) */
+	0xAD4C0008,		/* sw $t4, 8($t2) */
+					/* waitflash: */
+	0x8D500000,		/* lw $s0, 0($t2) */
+	0x020C8024,		/* and $s0, $s0, $t4 */
+	0x1600FFFD,		/* bne $s0, $zero, waitflash */
+	0x00000000,		/* nop */
+	0x00000000,		/* nop */
+	0x00000000, 	/* nop */
+	0x00000000,		/* nop */
+	0x00000000,		/* nop */
+	0x8D510000,		/* lw $s1, 0($t2) */
+	0x30113000,		/* andi $s1, $zero, 0x3000 */
+	0x1620FFEF,		/* bne $s1, $zero, error */
+	0xAD4D0004,		/* sw $t5, 4($t2) */
+	0x03E00008,		/* jr $ra */
+	0x00000000		/* nop */
+};
+
+static int pic32mx_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
 {
 	struct target *target = bank->target;
-	uint32_t buffer_size = 512;
+	uint32_t buffer_size = 16384;
 	struct working_area *source;
 	uint32_t address = bank->base + offset;
+	struct reg_param reg_params[3];
 	int retval = ERROR_OK;
-#if 0
+
 	struct pic32mx_flash_bank *pic32mx_info = bank->driver_priv;
-	struct armv7m_algorithm armv7m_info;
-
-	uint8_t pic32mx_flash_write_code[] = {
-									/* write: */
-		0xDF, 0xF8, 0x24, 0x40,		/* ldr	r4, PIC32MX_FLASH_CR */
-		0x09, 0x4D,					/* ldr	r5, PIC32MX_FLASH_SR */
-		0x4F, 0xF0, 0x01, 0x03,		/* mov	r3, #1 */
-		0x23, 0x60,					/* str	r3, [r4, #0] */
-		0x30, 0xF8, 0x02, 0x3B,		/* ldrh r3, [r0], #2 */
-		0x21, 0xF8, 0x02, 0x3B,		/* strh r3, [r1], #2 */
-									/* busy: */
-		0x2B, 0x68,					/* ldr 	r3, [r5, #0] */
-		0x13, 0xF0, 0x01, 0x0F,		/* tst 	r3, #0x01 */
-		0xFB, 0xD0,					/* beq 	busy */
-		0x13, 0xF0, 0x14, 0x0F,		/* tst	r3, #0x14 */
-		0x01, 0xD1,					/* bne	exit */
-		0x01, 0x3A,					/* subs	r2, r2, #1 */
-		0xED, 0xD1,					/* bne	write */
-									/* exit: */
-		0xFE, 0xE7,					/* b exit */
-		0x10, 0x20, 0x02, 0x40,		/* PIC32MX_FLASH_CR:	.word 0x40022010 */
-		0x0C, 0x20, 0x02, 0x40		/* PIC32MX_FLASH_SR:	.word 0x4002200C */
-	};
+	struct mips32_algorithm mips32_info;
 
 	/* flash write code */
-	if (target_alloc_working_area(target, sizeof(pic32mx_flash_write_code), &pic32mx_info->write_algorithm) != ERROR_OK)
+	if (target_alloc_working_area(target, sizeof(pic32mx_flash_write_code),
+			&pic32mx_info->write_algorithm) != ERROR_OK)
 	{
 		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	if ((retval = target_write_buffer(target, pic32mx_info->write_algorithm->address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code)) != ERROR_OK)
+	if ((retval = target_write_buffer(target,
+			pic32mx_info->write_algorithm->address,
+			sizeof(pic32mx_flash_write_code),
+			(uint8_t*)pic32mx_flash_write_code)) != ERROR_OK)
 		return retval;
-#endif
 
 	/* memory buffer */
-	if (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
 	{
-#if 0
-		/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
-		if (pic32mx_info->write_algorithm)
-			target_free_working_area(target, pic32mx_info->write_algorithm);
-#endif
+		buffer_size /= 2;
+		if (buffer_size <= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			if (pic32mx_info->write_algorithm)
+				target_free_working_area(target, pic32mx_info->write_algorithm);
 
-		LOG_WARNING("no large enough working area available, can't do block memory writes");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	mips32_info.common_magic = MIPS32_COMMON_MAGIC;
+	mips32_info.isa_mode = MIPS32_ISA_MIPS32;
 
-	while (count >= buffer_size/4)
+	init_reg_param(&reg_params[0], "a0", 32, PARAM_IN_OUT);
+	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "a2", 32, PARAM_OUT);
+
+	while (count > 0)
 	{
 		uint32_t status;
+		uint32_t thisrun_count = (count > (buffer_size / 4)) ?
+				(buffer_size / 4) : count;
 
-		if ((retval = target_write_buffer(target, source->address, buffer_size, buffer)) != ERROR_OK) {
-			LOG_ERROR("Failed to write row buffer (%d words) to RAM", (int)(buffer_size/4));
+		if ((retval = target_write_buffer(target, source->address,
+				thisrun_count * 4, buffer)) != ERROR_OK)
 			break;
-		}
 
-#if 0
-		buf_set_u32(reg_params[0].value, 0, 32, source->address);
-		buf_set_u32(reg_params[1].value, 0, 32, address);
-		buf_set_u32(reg_params[2].value, 0, 32, buffer_size/4);
+		buf_set_u32(reg_params[0].value, 0, 32, Virt2Phys(source->address));
+		buf_set_u32(reg_params[1].value, 0, 32, Virt2Phys(address));
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
 
-		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params, pic32mx_info->write_algorithm->address, \
-				pic32mx_info->write_algorithm->address + (sizeof(pic32mx_flash_write_code) - 10), 10000, &armv7m_info)) != ERROR_OK)
+		if ((retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
+				pic32mx_info->write_algorithm->address,
+				pic32mx_info->write_algorithm->address + (sizeof(pic32mx_flash_write_code) - 76),
+				10000, &mips32_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing pic32mx flash write algorithm");
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 
-		if (buf_get_u32(reg_params[3].value, 0, 32) & 0x14)
+		status = buf_get_u32(reg_params[0].value, 0, 32);
+
+		if (status & NVMCON_NVMERR)
 		{
-			retval = ERROR_FLASH_OPERATION_FAILED;
-			break;
-		}
-#endif
-		status = pic32mx_write_row(bank, address, source->address);
-		if (status & NVMCON_NVMERR) {
 			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
-		if (status & NVMCON_LVDERR) {
+
+		if (status & NVMCON_LVDERR)
+		{
 			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 
-		buffer  += buffer_size;
-		address += buffer_size;
-		count   -= buffer_size/4;
+		buffer += thisrun_count * 4;
+		address += thisrun_count * 4;
+		count -= thisrun_count;
 	}
 
 	target_free_working_area(target, source);
+	target_free_working_area(target, pic32mx_info->write_algorithm);
 
-	while (count > 0)
-	{
-		uint32_t value;
-		memcpy(&value, buffer, sizeof(uint32_t));
-
-		uint32_t status = pic32mx_write_word(bank, address, value);
-		if (status & NVMCON_NVMERR) {
-			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
-			retval = ERROR_FLASH_OPERATION_FAILED;
-			break;
-		}
-		if (status & NVMCON_LVDERR) {
-			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
-			retval = ERROR_FLASH_OPERATION_FAILED;
-			break;
-		}
-
-		buffer  += 4;
-		address += 4;
-		count--;
-	}
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
 
 	return retval;
 }
@@ -432,36 +402,12 @@ static int pic32mx_write_word(struct flash_bank *bank, uint32_t address, uint32_
 {
 	struct target *target = bank->target;
 
-	if (bank->base >= PIC32MX_KSEG1_PGM_FLASH)
-		target_write_u32(target, PIC32MX_NVMADDR, KS1Virt2Phys(address));
-	else
-		target_write_u32(target, PIC32MX_NVMADDR, KS0Virt2Phys(address));
+	target_write_u32(target, PIC32MX_NVMADDR, Virt2Phys(address));
 	target_write_u32(target, PIC32MX_NVMDATA, word);
 
 	return pic32mx_nvm_exec(bank, NVMCON_OP_WORD_PROG, 5);
 }
 
-/*
- * Write a 128 word (512 byte) row to flash address from RAM srcaddr.
- */
-static int pic32mx_write_row(struct flash_bank *bank, uint32_t address, uint32_t srcaddr)
-{
-	struct target *target = bank->target;
-
-	LOG_DEBUG("addr: 0x%08" PRIx32 " srcaddr: 0x%08" PRIx32 "", address, srcaddr);
-
-	if (address >= PIC32MX_KSEG1_PGM_FLASH)
-		target_write_u32(target, PIC32MX_NVMADDR,    KS1Virt2Phys(address));
-	else
-		target_write_u32(target, PIC32MX_NVMADDR,    KS0Virt2Phys(address));
-	if (srcaddr >= PIC32MX_KSEG1_RAM)
-		target_write_u32(target, PIC32MX_NVMSRCADDR, KS1Virt2Phys(srcaddr));
-	else
-		target_write_u32(target, PIC32MX_NVMSRCADDR, KS0Virt2Phys(srcaddr));
-
-	return pic32mx_nvm_exec(bank, NVMCON_OP_ROW_PROG, 100);
-}
-
 static int pic32mx_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	uint32_t words_remaining = (count / 4);
@@ -477,6 +423,9 @@ static int pic32mx_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offs
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	LOG_DEBUG("writing to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32
+			" count: 0x%8.8" PRIx32 "", bank->base, offset, count);
+
 	if (offset & 0x3)
 	{
 		LOG_WARNING("offset 0x%" PRIx32 "breaks required 4-byte alignment", offset);
@@ -515,10 +464,18 @@ static int pic32mx_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offs
 		memcpy(&value, buffer + bytes_written, sizeof(uint32_t));
 
 		status = pic32mx_write_word(bank, address, value);
+
 		if (status & NVMCON_NVMERR)
+		{
+			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
 			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
 		if (status & NVMCON_LVDERR)
+		{
+			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
 			return ERROR_FLASH_OPERATION_FAILED;
+		}
 
 		bytes_written += 4;
 		words_remaining--;
@@ -531,10 +488,18 @@ static int pic32mx_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offs
 		memcpy(&value, buffer + bytes_written, bytes_remaining);
 
 		status = pic32mx_write_word(bank, address, value);
+
 		if (status & NVMCON_NVMERR)
+		{
+			LOG_ERROR("Flash write error NVMERR (status = 0x%08" PRIx32 ")", status);
 			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
 		if (status & NVMCON_LVDERR)
+		{
+			LOG_ERROR("Flash write error LVDERR (status = 0x%08" PRIx32 ")", status);
 			return ERROR_FLASH_OPERATION_FAILED;
+		}
 	}
 
 	return ERROR_OK;
@@ -547,70 +512,60 @@ static int pic32mx_probe(struct flash_bank *bank)
 	struct mips32_common *mips32 = target->arch_info;
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 	int i;
-	uint16_t num_pages = 0;
+	uint32_t num_pages = 0;
 	uint32_t device_id;
 	int page_size;
 
 	pic32mx_info->probed = 0;
 
 	device_id = ejtag_info->idcode;
-	LOG_INFO("device id = 0x%08" PRIx32 " (manuf 0x%03x dev 0x%02x, ver 0x%03x)",
+	LOG_INFO("device id = 0x%08" PRIx32 " (manuf 0x%03x dev 0x%02x, ver 0x%02x)",
 			  device_id,
-			  (unsigned)((device_id >> 1)&0x7ff),
-			  (unsigned)((device_id >> 12)&0xff),
-			  (unsigned)((device_id >> 20)&0xfff));
+			  (unsigned)((device_id >> 1) & 0x7ff),
+			  (unsigned)((device_id >> 12) & 0xff),
+			  (unsigned)((device_id >> 28) & 0xf));
 
-	if (((device_id >> 1)&0x7ff) != PIC32MX_MANUF_ID) {
+	if (((device_id >> 1) & 0x7ff) != PIC32MX_MANUF_ID) {
 		LOG_WARNING("Cannot identify target as a PIC32MX family.");
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	page_size = 4096;
-	if (bank->base == PIC32MX_KSEG1_BOOT_FLASH || bank->base == 1) {
-		/* 0xBFC00000: Boot flash size fixed at 12k */
-		num_pages = 12;
-	} else {
-		/* 0xBD000000: Program flash size varies with device */
-		for (i = 0; pic32mx_devs[i].name != NULL; i++)
-			if (pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
-				num_pages = pic32mx_devs[i].pfm_size;
-				break;
-			}
-		if (pic32mx_devs[i].name == NULL) {
-			LOG_WARNING("Cannot identify target as a PIC32MX family.");
-			return ERROR_FLASH_OPERATION_FAILED;
-		}
-	}
 
-#if 0
-	if (bank->target->state != TARGET_HALTED)
+	if (Virt2Phys(bank->base) == PIC32MX_PHYS_BOOT_FLASH)
 	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
+		/* 0x1FC00000: Boot flash size */
+#if 0
+		/* for some reason this register returns 8k for the boot bank size
+		 * this does not match the docs, so for now set the boot bank at a
+		 * fixed 12k */
+		if (target_read_u32(target, PIC32MX_BMXBOOTSZ, &num_pages) != ERROR_OK) {
+			LOG_WARNING("PIC32MX flash size failed, probe inaccurate - assuming 12k flash");
+			num_pages = (12 * 1024);
+		}
+#else
+		/* fixed 12k boot bank - see comments above */
+		num_pages = (12 * 1024);
+#endif
 	}
-
-	/* get flash size from target */
-	if (target_read_u16(target, 0x1FFFF7E0, &num_pages) != ERROR_OK)
+	else
 	{
-		/* failed reading flash size, default to max target family */
-		num_pages = 0xffff;
+		/* read the flash size from the device */
+		if (target_read_u32(target, PIC32MX_BMXPFMSZ, &num_pages) != ERROR_OK) {
+			LOG_WARNING("PIC32MX flash size failed, probe inaccurate - assuming 512k flash");
+			num_pages = (512 * 1024);
+		}
 	}
-#endif
 
-	LOG_INFO("flash size = %dkbytes", num_pages);
+	LOG_INFO("flash size = %dkbytes", num_pages / 1024);
 
 	/* calculate numbers of pages */
-	num_pages /= (page_size / 1024);
-
-	if (bank->base == 0) bank->base = PIC32MX_KSEG1_PGM_FLASH;
-	if (bank->base == 1) bank->base = PIC32MX_KSEG1_BOOT_FLASH;
+	num_pages /= page_size;
 	bank->size = (num_pages * page_size);
 	bank->num_sectors = num_pages;
-	bank->chip_width = 4;
-	bank->bus_width  = 4;
 	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
 
-	for (i = 0; i < num_pages; i++)
+	for (i = 0; i < (int)num_pages; i++)
 	{
 		bank->sectors[i].offset = i * page_size;
 		bank->sectors[i].size = page_size;
@@ -631,13 +586,6 @@ static int pic32mx_auto_probe(struct flash_bank *bank)
 	return pic32mx_probe(bank);
 }
 
-#if 0
-COMMAND_HANDLER(pic32mx_handle_part_id_command)
-{
-	return ERROR_OK;
-}
-#endif
-
 static int pic32mx_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	struct target *target = bank->target;
@@ -648,198 +596,30 @@ static int pic32mx_info(struct flash_bank *bank, char *buf, int buf_size)
 
 	device_id = ejtag_info->idcode;
 
-	if (((device_id >> 1)&0x7ff) != PIC32MX_MANUF_ID) {
+	if (((device_id >> 1) & 0x7ff) != PIC32MX_MANUF_ID) {
 		snprintf(buf, buf_size,
 				 "Cannot identify target as a PIC32MX family (manufacturer 0x%03d != 0x%03d)\n",
-				 (unsigned)((device_id >> 1)&0x7ff),
+				 (unsigned)((device_id >> 1) & 0x7ff),
 				 PIC32MX_MANUF_ID);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
+
 	for (i = 0; pic32mx_devs[i].name != NULL; i++)
+	{
 		if (pic32mx_devs[i].devid == ((device_id >> 12) & 0xff)) {
 			printed = snprintf(buf, buf_size, "PIC32MX%s", pic32mx_devs[i].name);
 			break;
 		}
-	if (pic32mx_devs[i].name == NULL) {
-		snprintf(buf, buf_size, "Cannot identify target as a PIC32MX family\n");
-		return ERROR_FLASH_OPERATION_FAILED;
 	}
-	buf += printed;
-	buf_size -= printed;
-	printed = snprintf(buf, buf_size, "  Ver: 0x%03x",
-					   (unsigned)((device_id >> 20)&0xfff));
-
-	return ERROR_OK;
-}
-
-#if 0
-COMMAND_HANDLER(pic32mx_handle_lock_command)
-{
-	struct target *target = NULL;
-	struct pic32mx_flash_bank *pic32mx_info = NULL;
-
-	if (CMD_ARGC < 1)
-	{
-		command_print(CMD_CTX, "pic32mx lock <bank>");
-		return ERROR_OK;
-	}
-
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	pic32mx_info = bank->driver_priv;
-
-	target = bank->target;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (pic32mx_erase_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, "pic32mx failed to erase options");
-		return ERROR_OK;
-	}
-
-	/* set readout protection */
-	pic32mx_info->option_bytes.RDP = 0;
-
-	if (pic32mx_write_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, "pic32mx failed to lock device");
-		return ERROR_OK;
-	}
-
-	command_print(CMD_CTX, "pic32mx locked");
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(pic32mx_handle_unlock_command)
-{
-	struct target *target = NULL;
-	struct pic32mx_flash_bank *pic32mx_info = NULL;
-
-	if (CMD_ARGC < 1)
-	{
-		command_print(CMD_CTX, "pic32mx unlock <bank>");
-		return ERROR_OK;
-	}
-
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
-	if (ERROR_OK != retval)
-		return retval;
 
-	pic32mx_info = bank->driver_priv;
-
-	target = bank->target;
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (pic32mx_erase_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, "pic32mx failed to unlock device");
-		return ERROR_OK;
-	}
-
-	if (pic32mx_write_options(bank) != ERROR_OK)
-	{
-		command_print(CMD_CTX, "pic32mx failed to lock device");
-		return ERROR_OK;
-	}
-
-	command_print(CMD_CTX, "pic32mx unlocked");
-
-	return ERROR_OK;
-}
-#endif
-
-#if 0
-static int pic32mx_chip_erase(struct flash_bank *bank)
-{
-	struct target *target = bank->target;
-#if 0
-	uint32_t status;
-#endif
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	LOG_INFO("PIC32MX chip erase called");
-
-#if 0
-	/* unlock option flash registers */
-	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY1);
-	target_write_u32(target, PIC32MX_FLASH_KEYR, KEY2);
-
-	/* chip erase flash memory */
-	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER);
-	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_MER | FLASH_STRT);
-
-	status = pic32mx_wait_status_busy(bank, 10);
-
-	target_write_u32(target, PIC32MX_FLASH_CR, FLASH_LOCK);
-
-	if (status & FLASH_WRPRTERR)
-	{
-		LOG_ERROR("pic32mx device protected");
-		return ERROR_OK;
-	}
-
-	if (status & FLASH_PGERR)
-	{
-		LOG_ERROR("pic32mx device programming failed");
-		return ERROR_OK;
-	}
-#endif
-
-	return ERROR_OK;
-}
-#endif
-
-COMMAND_HANDLER(pic32mx_handle_chip_erase_command)
-{
-#if 0
-	int i;
-
-	if (CMD_ARGC != 0)
-	{
-		command_print(CMD_CTX, "pic32mx chip_erase");
-		return ERROR_OK;
+	if (pic32mx_devs[i].name == NULL) {
+		printed = snprintf(buf, buf_size, "Unknown");
 	}
 
-	struct flash_bank *bank;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (pic32mx_chip_erase(bank) == ERROR_OK)
-	{
-		/* set all sectors as erased */
-		for (i = 0; i < bank->num_sectors; i++)
-		{
-			bank->sectors[i].is_erased = 1;
-		}
-
-		command_print(CMD_CTX, "pic32mx chip erase complete");
-	}
-	else
-	{
-		command_print(CMD_CTX, "pic32mx chip erase failed");
-	}
-#endif
+	buf += printed;
+	buf_size -= printed;
+	printed = snprintf(buf, buf_size, "  Ver: 0x%02x",
+			(unsigned)((device_id >> 28) & 0xf));
 
 	return ERROR_OK;
 }
@@ -883,14 +663,9 @@ COMMAND_HANDLER(pic32mx_handle_pgm_word_command)
 
 	return ERROR_OK;
 }
+
 static const struct command_registration pic32mx_exec_command_handlers[] = {
 	{
-		.name = "chip_erase",
-		.handler = pic32mx_handle_chip_erase_command,
-		.mode = COMMAND_EXEC,
-		.help = "erase device",
-	},
-	{
 		.name = "pgm_word",
 		.handler = pic32mx_handle_pgm_word_command,
 		.mode = COMMAND_EXEC,
@@ -898,6 +673,7 @@ static const struct command_registration pic32mx_exec_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 static const struct command_registration pic32mx_command_handlers[] = {
 	{
 		.name = "pic32mx",
diff --git a/src/flash/nor/pic32mx.h b/src/flash/nor/pic32mx.h
index b3bdad2..79fa40e 100644
--- a/src/flash/nor/pic32mx.h
+++ b/src/flash/nor/pic32mx.h
@@ -29,8 +29,6 @@
 struct pic32mx_flash_bank
 {
 	struct working_area *write_algorithm;
-	int devid;
-	int ppage_size;
 	int probed;
 };
 
@@ -38,18 +36,6 @@ struct pic32mx_flash_bank
 
 /* pic32mx memory locations */
 
-#define PIC32MX_KUSEG_PGM_FLASH		0x7D000000
-#define PIC32MX_KUSEG_RAM			0x7F000000
-
-#define PIC32MX_KSEG0_RAM			0x80000000
-#define PIC32MX_KSEG0_PGM_FLASH		0x9D000000
-#define PIC32MX_KSEG0_BOOT_FLASH	0x9FC00000
-
-#define PIC32MX_KSEG1_RAM			0xA0000000
-#define PIC32MX_KSEG1_PGM_FLASH		0xBD000000
-#define PIC32MX_KSEG1_PERIPHERAL	0xBF800000
-#define PIC32MX_KSEG1_BOOT_FLASH	0xBFC00000
-
 #define PIC32MX_PHYS_RAM			0x00000000
 #define PIC32MX_PHYS_PGM_FLASH		0x1D000000
 #define PIC32MX_PHYS_PERIPHERALS	0x1F800000
@@ -59,19 +45,21 @@ struct pic32mx_flash_bank
  * Translate Virtual and Physical addresses.
  * Note: These macros only work for KSEG0/KSEG1 addresses.
  */
-#define KS1Virt2Phys(vaddr)			((vaddr)-0xA0000000)
-#define Phys2KS1Virt(paddr)			((paddr) + 0xA0000000)
-#define KS0Virt2Phys(vaddr)			((vaddr)-0x80000000)
-#define Phys2KS0Virt(paddr)			((paddr) + 0x80000000)
+
+#define Virt2Phys(v) 	((v) & 0x1FFFFFFF)
 
 /* pic32mx configuration register locations */
 
 #define PIC32MX_DEVCFG0		0xBFC02FFC
 #define PIC32MX_DEVCFG1		0xBFC02FF8
 #define PIC32MX_DEVCFG2		0xBFC02FF4
-#define PIC32MX_DEVCFG3		0XBFC02FF0
+#define PIC32MX_DEVCFG3		0xBFC02FF0
 #define PIC32MX_DEVID		0xBF80F220
 
+#define PIC32MX_BMXPFMSZ	0xBF882060
+#define PIC32MX_BMXBOOTSZ	0xBF882070
+#define PIC32MX_BMXDRMSZ	0xBF882040
+
 /* pic32mx flash controller register locations */
 
 #define PIC32MX_NVMCON		0xBF80F400
@@ -102,10 +90,5 @@ struct pic32mx_flash_bank
 #define NVMKEY1			0xAA996655
 #define NVMKEY2			0x556699AA
 
-struct pic32mx_mem_layout {
-	uint32_t sector_start;
-	uint32_t sector_size;
-};
-
 #endif /* PIC32MX_H */
 
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index f20c69e..bcba0f1 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -969,7 +969,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	/* write program into RAM */
 	mips32_pracc_write_mem32(ejtag_info, source->address, ARRAY_SIZE(handler_code), handler_code);
 
-	LOG_DEBUG("%s using 0x%.8" PRIx32 " for write handler\n", __func__, source->address);
+	LOG_DEBUG("%s using 0x%.8" PRIx32 " for write handler", __func__, source->address);
 
 	jmp_code[1] |= UPPER16(source->address);
 	jmp_code[2] |= LOWER16(source->address);
@@ -1030,7 +1030,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	mips_ejtag_drscan_32(ejtag_info, &address);
 
 	if (address != MIPS32_PRACC_TEXT)
-		LOG_ERROR("mini program did not return to start\n");
+		LOG_ERROR("mini program did not return to start");
 
 	return retval;
 }
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 2f62f2b..5c1f245 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -40,6 +40,10 @@
 #define EJTAG_INST_TCBDATA		0x12
 #define EJTAG_INST_BYPASS		0xFF
 
+/* microchip PIC32MX specific instructions */
+#define MTAP_SW_MTAP			0x04
+#define MTAP_SW_ETAP			0x05
+
 /* ejtag control register bits ECR */
 #define EJTAG_CTRL_TOF			(1 << 1)
 #define EJTAG_CTRL_TIF			(1 << 2)
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index f581ddf..389daf9 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -914,7 +914,7 @@ int mips_m4k_examine(struct target *target)
 		{
 			/* we are using a pic32mx so select ejtag port
 			 * as it is not selected by default */
-			mips_ejtag_set_instr(ejtag_info, 0x05, NULL);
+			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP, NULL);
 			LOG_DEBUG("PIC32MX Detected - using EJTAG Interface");
 		}
 	}
diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index 1561d73..0f1fa66 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -18,6 +18,14 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x30938053
 }
 
+# working area is 16384 - 2048
+# loose first 2048 bytes due to BMXDKPBA reg
+if { [info exists WORKAREASIZE] } {
+   set  _WORKAREASIZE $WORKAREASIZE
+} else {
+   set  _WORKAREASIZE [expr (16384 - 2048)]
+}
+
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
 
@@ -26,12 +34,12 @@ reset_config srst_only
 
 #jtag scan chain
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
-jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME
 
-$_TARGETNAME configure -work-area-phys 0xa0000800 -work-area-size 16384 -work-area-backup 0
+$_TARGETNAME configure -work-area-phys 0xa0000800 -work-area-size $_WORKAREASIZE -work-area-backup 0
 
 $_TARGETNAME configure -event reset-init {
 	#
@@ -50,9 +58,9 @@ $_TARGETNAME configure -event reset-init {
 }
 
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME pic32mx 0xbd000000 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME pic32mx 0x1fc00000 0 0 0 $_TARGETNAME
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME pic32mx 0xbfc00000 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME pic32mx 0x1d000000 0 0 0 $_TARGETNAME
 
 # For more information about the configuration files, take a look at:
 # openocd.texi

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/pic32mx.c   |  664 +++++++++++++++------------------------------
 src/flash/nor/pic32mx.h   |   31 +--
 src/target/mips32_pracc.c |    4 +-
 src/target/mips_ejtag.h   |    4 +
 src/target/mips_m4k.c     |    2 +-
 tcl/target/pic32mx.cfg    |   16 +-
 6 files changed, 246 insertions(+), 475 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Mar 10 22:54:48 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 10 Mar 2010 21:54:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-72-g6030a5c
Message-ID: <E1NpTrd-0000ft-Sb@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6030a5cb2af17fc4bb47788265c9b1400318da6b (commit)
      from  257a764582f52235414b5c35717b0ee2b49d4b0d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6030a5cb2af17fc4bb47788265c9b1400318da6b
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Mar 10 21:54:21 2010 +0000

    JLINK: user info message cleanup
    
     - remove trailing LF's from user info messages.
     - split long lines.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index f22ad7c..21dfab2 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -62,10 +62,10 @@ static uint8_t usb_out_buffer[JLINK_OUT_BUFFER_SIZE];
 static uint8_t usb_emu_result_buffer[JLINK_EMU_RESULT_BUFFER_SIZE];
 
 /* Constants for JLink command */
-#define EMU_CMD_VERSION		0x01
+#define EMU_CMD_VERSION			0x01
 #define EMU_CMD_SET_SPEED		0x05
 #define EMU_CMD_GET_STATE		0x07
-#define EMU_CMD_HW_CLOCK			0xc8
+#define EMU_CMD_HW_CLOCK		0xc8
 #define EMU_CMD_HW_TMS0			0xc9
 #define EMU_CMD_HW_TMS1			0xca
 #define EMU_CMD_HW_JTAG2		0xce
@@ -90,7 +90,8 @@ static void jlink_end_state(tap_state_t state);
 static void jlink_state_move(void);
 static void jlink_path_move(int num_states, tap_state_t *path);
 static void jlink_runtest(int num_cycles);
-static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command);
+static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer,
+		int scan_size, struct scan_command *command);
 static void jlink_reset(int trst, int srst);
 static void jlink_simple_command(uint8_t command);
 static int jlink_get_status(void);
@@ -100,7 +101,8 @@ static void jlink_tap_init(void);
 static int jlink_tap_execute(void);
 static void jlink_tap_ensure_space(int scans, int bits);
 static void jlink_tap_append_step(int tms, int tdi);
-static void jlink_tap_append_scan(int length, uint8_t *buffer, struct scan_command *command);
+static void jlink_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command);
 
 /* Jlink lowlevel functions */
 struct jlink {
@@ -276,18 +278,26 @@ static int jlink_init(void)
 
 	if (jlink_handle == 0)
 	{
-		LOG_ERROR("Cannot find jlink Interface! Please check connection and permissions.");
+		LOG_ERROR("Cannot find jlink Interface! Please check "
+				"connection and permissions.");
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
 	/*
-	 *  The next three instructions were added after discovering a problem while using an oscilloscope.  For the V8
-	 *	SAM-ICE dongle (and likely other j-link device variants), the reset line to the target microprocessor was found to
-	 *	cycle only intermittently during emulator startup (even after encountering the downstream reset instruction later
-	 *	in the code).  This was found to create two issues:  1) In general it is a bad practice to not reset a CPU to a known
-	 *	state when starting an emulator and 2) something critical happens inside the dongle when it does the first read
-	 *	following a new USB session.  Keeping the processor in reset during the first read collecting version information
-	 *	seems to prevent errant "J-Link command EMU_CMD_VERSION failed" issues.
+	 * The next three instructions were added after discovering a problem
+	 * while using an oscilloscope.
+	 * For the V8 SAM-ICE dongle (and likely other j-link device variants),
+	 * the reset line to the target microprocessor was found to cycle only
+	 * intermittently during emulator startup (even after encountering the
+	 * downstream reset instruction later in the code).
+	 * This was found to create two issues:
+	 * 1) In general it is a bad practice to not reset a CPU to a known
+	 * state when starting an emulator and
+	 * 2) something critical happens inside the dongle when it does the
+	 * first read following a new USB session.
+	 * Keeping the processor in reset during the first read collecting
+	 * version information seems to prevent errant
+	 * "J-Link command EMU_CMD_VERSION failed" issues.
 	 */
 
 	LOG_INFO("J-Link initialization started / target CPU reset initiated");
@@ -375,7 +385,8 @@ static void jlink_path_move(int num_states, tap_state_t *path)
 		}
 		else
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_name(tap_get_state()), tap_state_name(path[i]));
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition",
+					tap_state_name(tap_get_state()), tap_state_name(path[i]));
 			exit(-1);
 		}
 
@@ -415,7 +426,8 @@ static void jlink_runtest(int num_cycles)
 	}
 }
 
-static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command)
+static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer,
+		int scan_size, struct scan_command *command)
 {
 	tap_state_t saved_end_state;
 
@@ -500,13 +512,13 @@ static int jlink_get_status(void)
 	}
 
 	int vref = usb_in_buffer[0] + (usb_in_buffer[1] << 8);
-	LOG_INFO("Vref = %d.%d TCK = %d TDI = %d TDO = %d TMS = %d SRST = %d TRST = %d\n", \
+	LOG_INFO("Vref = %d.%d TCK = %d TDI = %d TDO = %d TMS = %d SRST = %d TRST = %d", \
 		vref / 1000, vref % 1000, \
 		usb_in_buffer[2], usb_in_buffer[3], usb_in_buffer[4], \
 		usb_in_buffer[5], usb_in_buffer[6], usb_in_buffer[7]);
 
 	if (vref < 1500)
-		LOG_ERROR("Vref too low. Check Target Power\n");
+		LOG_ERROR("Vref too low. Check Target Power");
 
 	return ERROR_OK;
 }
@@ -523,7 +535,7 @@ static int jlink_get_version_info(void)
 	result = jlink_usb_read(jlink_handle, 2);
 	if (2 != result)
 	{
-		LOG_ERROR("J-Link command EMU_CMD_VERSION failed (%d)\n", result);
+		LOG_ERROR("J-Link command EMU_CMD_VERSION failed (%d)", result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -537,7 +549,7 @@ static int jlink_get_version_info(void)
 	result = jlink_usb_read(jlink_handle, len);
 	if (result != len)
 	{
-		LOG_ERROR("J-Link command EMU_CMD_VERSION failed (%d)\n", result);
+		LOG_ERROR("J-Link command EMU_CMD_VERSION failed (%d)", result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -550,7 +562,7 @@ static int jlink_get_version_info(void)
 	result = jlink_usb_read(jlink_handle, 4);
 	if (4 != result)
 	{
-		LOG_ERROR("J-Link command EMU_CMD_GET_CAPS failed (%d)\n", result);
+		LOG_ERROR("J-Link command EMU_CMD_GET_CAPS failed (%d)", result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
@@ -565,7 +577,7 @@ static int jlink_get_version_info(void)
 		result = jlink_usb_read(jlink_handle, 4);
 		if (4 != result)
 		{
-			LOG_ERROR("J-Link command EMU_CMD_GET_HW_VERSION failed (%d)\n", result);
+			LOG_ERROR("J-Link command EMU_CMD_GET_HW_VERSION failed (%d)", result);
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -585,7 +597,7 @@ static int jlink_get_version_info(void)
 		result = jlink_usb_read(jlink_handle, 4);
 		if (4 != result)
 		{
-			LOG_ERROR("J-Link command EMU_CMD_GET_MAX_MEM_BLOCK failed (%d)\n", result);
+			LOG_ERROR("J-Link command EMU_CMD_GET_MAX_MEM_BLOCK failed (%d)", result);
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 
@@ -731,7 +743,8 @@ static void jlink_tap_append_step(int tms, int tdi)
 	tap_length++;
 }
 
-static void jlink_tap_append_scan(int length, uint8_t *buffer, struct scan_command *command)
+static void jlink_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command)
 {
 	struct pending_scan_result *pending_scan_result =
 		&pending_scan_results_buffer[pending_scan_results_length];
@@ -767,7 +780,7 @@ static int jlink_tap_execute(void)
 	 * WARNING: This will interfere with tap state counting. */
 	while ((DIV_ROUND_UP(tap_length, 8) % 64) == 0)
 	{
-		jlink_tap_append_step((tap_get_state() == TAP_RESET)?1:0, 0);
+		jlink_tap_append_step((tap_get_state() == TAP_RESET) ? 1 : 0, 0);
 	}
 
 	// number of full bytes (plus one if some would be left over)
@@ -787,7 +800,8 @@ static int jlink_tap_execute(void)
 	result = jlink_usb_message(jlink_handle, 4 + 2 * byte_length, byte_length);
 	if (result != byte_length)
 	{
-		LOG_ERROR("jlink_tap_execute, wrong result %d (expected %d)", result, byte_length);
+		LOG_ERROR("jlink_tap_execute, wrong result %d (expected %d)",
+				result, byte_length);
 		jlink_tap_init();
 		return ERROR_JTAG_QUEUE_FAILED;
 	}
@@ -942,7 +956,8 @@ static int jlink_usb_message(struct jlink *jlink, int out_length, int in_length)
 		result2 = jlink_usb_read_emu_result(jlink);
 		if (1 != result2)
 		{
-			LOG_ERROR("jlink_usb_read_emu_result retried requested = 1, result=%d, in_length=%i", result2,in_length);
+			LOG_ERROR("jlink_usb_read_emu_result retried requested = 1, "
+					"result=%d, in_length=%i", result2, in_length);
 			/* Try again once, should only happen if (in_length%64 == 0) */
 			result2 = jlink_usb_read_emu_result(jlink);
 			if (1 != result2)
@@ -971,7 +986,8 @@ static int jlink_usb_message(struct jlink *jlink, int out_length, int in_length)
 	return result;
 }
 
-/* calls the given usb_bulk_* function, allowing for the data to trickle in with some timeouts  */
+/* calls the given usb_bulk_* function, allowing for the data to
+ * trickle in with some timeouts  */
 static int usb_bulk_with_retries(
 		int (*f)(usb_dev_handle *, int, char *, int, int),
 		usb_dev_handle *dev, int ep,
@@ -1018,14 +1034,16 @@ static int jlink_usb_write(struct jlink *jlink, int out_length)
 
 	if (out_length > JLINK_OUT_BUFFER_SIZE)
 	{
-		LOG_ERROR("jlink_write illegal out_length=%d (max=%d)", out_length, JLINK_OUT_BUFFER_SIZE);
+		LOG_ERROR("jlink_write illegal out_length=%d (max=%d)",
+				out_length, JLINK_OUT_BUFFER_SIZE);
 		return -1;
 	}
 
 	result = usb_bulk_write_ex(jlink->usb_handle, jlink_write_ep,
 		(char *)usb_out_buffer, out_length, JLINK_USB_TIMEOUT);
 
-	DEBUG_JTAG_IO("jlink_usb_write, out_length = %d, result = %d", out_length, result);
+	DEBUG_JTAG_IO("jlink_usb_write, out_length = %d, result = %d",
+			out_length, result);
 
 #ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(usb_out_buffer, out_length);
@@ -1084,4 +1102,3 @@ static void jlink_debug_buffer(uint8_t *buffer, int length)
 	}
 }
 #endif
-

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/jlink.c |   75 ++++++++++++++++++++++++++++------------------
 1 files changed, 46 insertions(+), 29 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Mar 10 23:23:16 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 10 Mar 2010 22:23:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-73-gedf52a6
Message-ID: <E1NpUJB-00028v-Lz@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  edf52a6cc5314a1db34c110050090a539c8ab3ed (commit)
      from  6030a5cb2af17fc4bb47788265c9b1400318da6b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit edf52a6cc5314a1db34c110050090a539c8ab3ed
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Mar 10 22:23:01 2010 +0000

    MIPS: make fixed code arrays static const
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index e0550a8..984b535 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -129,7 +129,7 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 
 int mips_ejtag_step_enable(struct mips_ejtag *ejtag_info)
 {
-	uint32_t code[] = {
+	static const uint32_t code[] = {
 			MIPS32_MTC0(1,31,0),			/* move $1 to COP0 DeSave */
 			MIPS32_MFC0(1,23,0),			/* move COP0 Debug to $1 */
 			MIPS32_ORI(1,1,0x0100),			/* set SSt bit in debug reg */
@@ -145,7 +145,7 @@ int mips_ejtag_step_enable(struct mips_ejtag *ejtag_info)
 }
 int mips_ejtag_step_disable(struct mips_ejtag *ejtag_info)
 {
-	uint32_t code[] = {
+	static const uint32_t code[] = {
 			MIPS32_MTC0(15,31,0),							/* move $15 to COP0 DeSave */
 			MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),		/* $15 = MIPS32_PRACC_STACK */
 			MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
@@ -209,7 +209,7 @@ int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info)
 int mips_ejtag_read_debug(struct mips_ejtag *ejtag_info, uint32_t* debug_reg)
 {
 	/* read ejtag ECR */
-	uint32_t code[] = {
+	static const uint32_t code[] = {
 			MIPS32_MTC0(15,31,0),							/* move $15 to COP0 DeSave */
 			MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)),		/* $15 = MIPS32_PRACC_STACK */
 			MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips_ejtag.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Mar 11 18:52:36 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 11 Mar 2010 17:52:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-74-g591e0bb
Message-ID: <E1NpmYo-0002W6-OH@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  591e0bbab957e86c8b2c6e19420a8cd9f89993cd (commit)
      from  edf52a6cc5314a1db34c110050090a539c8ab3ed (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 591e0bbab957e86c8b2c6e19420a8cd9f89993cd
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Mar 11 09:47:47 2010 -0800

    split "interface" commands from "jtag" ones
    
    We'll need to be able to work with debug adapter interfaces (drivers)
    even when they're not used for JTAG ... for example, while there are
    multi-transport drivers which support JTAG *and* several other
    transports (or just one more, like SWD) there are also adapters
    with more limited goals (and no JTAG support at all).
    
    Start decoupling the two concepts ("debug adapter driver", "jtag")
    by having two command groups, which initialize separately.
    
    This will help us support OpenOCD sessions using only non-JTAG
    transports, in which JTAG commands should not be registered.
    Update docs to mention that the JTAG, SVF, and XSVF commands
    won't work without a JTAG transport.
    
    Note that at least commands working with SRST are still inappropriately
    coupled  to JTAG ... inappropriate because (a) SRST is not part of the
    JTAG standard, for all that many platforms (like ARM) expect it; and also
    (b) because they're used with non-JTAG debug and programming interfaces,
    too.  They should perhaps become generic "interface" operations at some
    point.  (Similarly with the clock rate to be used by a given adapter.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index f9f9b68..33c442f 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -6641,6 +6641,8 @@ the order of TAP state transitions.
 If you're not debugging OpenOCD internals, or bringing up a
 new JTAG adapter or a new type of TAP device (like a CPU or
 JTAG router), you probably won't need to use these commands.
+In a debug session that doesn't use JTAG for its transport protocol,
+these commands are not available.
 
 @deffn Command {drscan} tap [numbits value]+ [@option{-endstate} tap_state]
 Loads the data register of @var{tap} with a series of bit fields
@@ -6831,6 +6833,7 @@ OpenOCD also includes some boundary scan commands.
 
 The Serial Vector Format, better known as @dfn{SVF}, is a
 way to represent JTAG test patterns in text files.
+In a debug session using JTAG for its transport protocol,
 OpenOCD supports running such test files.
 
 @deffn Command {svf} filename [@option{quiet}]
@@ -6847,6 +6850,7 @@ each command is logged before it is executed.
 The Xilinx Serial Vector Format, better known as @dfn{XSVF}, is a
 binary representation of SVF which is optimized for use with
 Xilinx devices.
+In a debug session using JTAG for its transport protocol,
 OpenOCD supports running such test files.
 
 @quotation Important
diff --git a/src/jtag/driver.h b/src/jtag/driver.h
new file mode 100644
index 0000000..62cda41
--- /dev/null
+++ b/src/jtag/driver.h
@@ -0,0 +1,4 @@
+struct command_context;
+
+int interface_register_commands(struct command_context *ctx);
+
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 1073abc..3ffa930 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -985,7 +985,7 @@ COMMAND_HANDLER(handle_interface_list_command)
 	if (strcmp(CMD_NAME, "interface_list") == 0 && CMD_ARGC > 0)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	command_print(CMD_CTX, "The following JTAG interfaces are available:");
+	command_print(CMD_CTX, "The following debug interfaces are available:");
 	for (unsigned i = 0; NULL != jtag_interfaces[i]; i++)
 	{
 		const char *name = jtag_interfaces[i]->name;
@@ -1038,7 +1038,7 @@ COMMAND_HANDLER(handle_interface_command)
 	/* no valid interface was found (i.e. the configuration option,
 	 * didn't match one of the compiled-in interfaces
 	 */
-	LOG_ERROR("The specified JTAG interface was not found (%s)", CMD_ARGV[0]);
+	LOG_ERROR("The specified debug interface was not found (%s)", CMD_ARGV[0]);
 	CALL_COMMAND_HANDLER(handle_interface_list_command);
 	return ERROR_JTAG_INVALID_INTERFACE;
 }
@@ -1607,20 +1607,35 @@ COMMAND_HANDLER(handle_tms_sequence_command)
 	return ERROR_OK;
 }
 
-static const struct command_registration jtag_command_handlers[] = {
+static const struct command_registration interface_command_handlers[] = {
 	{
 		.name = "interface",
 		.handler = handle_interface_command,
 		.mode = COMMAND_CONFIG,
-		.help = "Select a JTAG interface",
+		.help = "Select a debug adapter interface (driver)",
 		.usage = "driver_name",
 	},
 	{
 		.name = "interface_list",
 		.handler = handle_interface_list_command,
 		.mode = COMMAND_ANY,
-		.help = "List all built-in interfaces",
+		.help = "List all built-in debug adapter interfaces (drivers)",
 	},
+	COMMAND_REGISTRATION_DONE
+};
+
+/**
+ * Register the commands which deal with arbitrary debug adapter drivers.
+ *
+ * @todo Remove internal assumptions that all debug adapters use JTAG for
+ * transport.  Various types and data structures are not named generically.
+ */
+int interface_register_commands(struct command_context *ctx)
+{
+	return register_commands(ctx, NULL, interface_command_handlers);
+}
+
+static const struct command_registration jtag_command_handlers[] = {
 	{
 		.name = "jtag_khz",
 		.handler = handle_jtag_khz_command,
@@ -1746,6 +1761,7 @@ static const struct command_registration jtag_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 int jtag_register_commands(struct command_context *cmd_ctx)
 {
 	return register_commands(cmd_ctx, NULL, jtag_command_handlers);
diff --git a/src/openocd.c b/src/openocd.c
index 7833606..4250434 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -29,6 +29,7 @@
 #endif
 
 #include "openocd.h"
+#include <jtag/driver.h>
 #include <jtag/jtag.h>
 #include <helper/ioutil.h>
 #include <helper/configuration.h>
@@ -207,6 +208,7 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 		&server_register_commands,
 		&gdb_register_commands,
 		&log_register_commands,
+		&interface_register_commands,
 		&jtag_register_commands,
 		&xsvf_register_commands,
 		&svf_register_commands,

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi  |    4 ++++
 src/jtag/driver.h |    4 ++++
 src/jtag/tcl.c    |   26 +++++++++++++++++++++-----
 src/openocd.c     |    2 ++
 4 files changed, 31 insertions(+), 5 deletions(-)
 create mode 100644 src/jtag/driver.h


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Mar 11 20:36:14 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 11 Mar 2010 19:36:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-75-g24e1e3d
Message-ID: <E1NpoB6-0004Xq-Fi@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  24e1e3dd2699b817fa72a7843d36197abcd9e3a3 (commit)
      from  591e0bbab957e86c8b2c6e19420a8cd9f89993cd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 24e1e3dd2699b817fa72a7843d36197abcd9e3a3
Author: Michal Demin <michaldemin at gmail.com>
Date:   Mon Mar 8 13:45:14 2010 +0100

    Add support for Bus Pirate as a JTAG adapter.
    
    This includes a driver and matching config file.  This support needs to be
    enabled through the initial "configure" (use "--enable-buspirate").
    
    Signed-off-by: Michal Demin <michaldemin at gmail.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 4fef5b2..77435e1 100644
--- a/NEWS
+++ b/NEWS
@@ -4,6 +4,7 @@ history for details about what changed, including bugfixes
 and other issues not mentioned here.
 
 JTAG Layer:
+	New driver for "Bus Pirate"
 
 Boundary Scan:
 
diff --git a/configure.in b/configure.in
index 3b0a06d..d93b21a 100644
--- a/configure.in
+++ b/configure.in
@@ -474,6 +474,10 @@ AC_ARG_ENABLE(arm-jtag-ew,
   AS_HELP_STRING([--enable-arm-jtag-ew], [Enable building support for the Olimex ARM-JTAG-EW Programmer]),
   [build_armjtagew=$enableval], [build_armjtagew=no])
 
+AC_ARG_ENABLE(buspirate,
+  AS_HELP_STRING([--enable-buspirate], [Enable building support for the Buspirate]),
+  [build_buspirate=$enableval], [build_buspirate=no])
+
 AC_ARG_ENABLE(minidriver_dummy,
   AS_HELP_STRING([--enable-minidriver-dummy], [Enable the dummy minidriver.]),
   [build_minidriver_dummy=$enableval], [build_minidriver_dummy=no])
@@ -741,6 +745,12 @@ else
   AC_DEFINE(BUILD_ARMJTAGEW, 0, [0 if you don't want the ARM-JTAG-EW JTAG driver.])
 fi
 
+if test $build_buspirate = yes; then
+  AC_DEFINE(BUILD_BUSPIRATE, 1, [1 if you want the Buspirate JTAG driver.])
+else
+  AC_DEFINE(BUILD_BUSPIRATE, 0, [0 if you don't want the Buspirate JTAG driver.])
+fi
+
 #-- Deal with MingW/Cygwin FTD2XX issues
 
 if test $is_win32 = yes; then
@@ -1035,6 +1045,7 @@ AM_CONDITIONAL(JLINK, test $build_jlink = yes)
 AM_CONDITIONAL(VSLLINK, test $build_vsllink = yes)
 AM_CONDITIONAL(RLINK, test $build_rlink = yes)
 AM_CONDITIONAL(ARMJTAGEW, test $build_armjtagew = yes)
+AM_CONDITIONAL(BUSPIRATE, test $build_buspirate = yes)
 AM_CONDITIONAL(USB, test $build_usb = yes)
 AM_CONDITIONAL(IS_CYGWIN, test $is_cygwin = yes)
 AM_CONDITIONAL(IS_MINGW, test $is_mingw = yes)
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 33c442f..93757d4 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -432,6 +432,9 @@ Raisonance has an adapter called @b{RLink}.  It exists in a stripped-down form o
 
 @item @b{ARM-JTAG-EW}
 @* Link: @url{http://www.olimex.com/dev/arm-jtag-ew.html}
+
+ at item @b{Buspirate}
+@* Link: @url{http://dangerousprototypes.com/bus-pirate-manual/}
 @end itemize
 
 @section IBM PC Parallel Printer Port Based
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
index d6113c6..0588126 100644
--- a/src/jtag/drivers/Makefile.am
+++ b/src/jtag/drivers/Makefile.am
@@ -64,6 +64,9 @@ endif
 if ARMJTAGEW
 DRIVERFILES += arm-jtag-ew.c
 endif
+if BUSPIRATE
+DRIVERFILES += buspirate.c
+endif
 
 noinst_HEADERS = \
 	bitbang.h \
diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
new file mode 100644
index 0000000..99210d2
--- /dev/null
+++ b/src/jtag/drivers/buspirate.c
@@ -0,0 +1,969 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Michal Demin                                    *
+ *   based on usbprog.c and arm-jtag-ew.c                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <jtag/interface.h>
+#include <jtag/commands.h>
+
+#include <termios.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#undef DEBUG_SERIAL
+/*#define DEBUG_SERIAL */
+static int buspirate_execute_queue(void);
+static int buspirate_speed(int speed);
+static int buspirate_khz(int khz, int *jtag_speed);
+static int buspirate_init(void);
+static int buspirate_quit(void);
+
+static void buspirate_end_state(tap_state_t state);
+static void buspirate_state_move(void);
+static void buspirate_path_move(int num_states, tap_state_t *path);
+static void buspirate_runtest(int num_cycles);
+static void buspirate_scan(bool ir_scan, enum scan_type type,
+	uint8_t *buffer, int scan_size, struct scan_command *command);
+
+
+#define CMD_UNKOWN        0x00
+#define CMD_PORT_MODE     0x01
+#define CMD_FEATURE       0x02
+#define CMD_READ_ADCS     0x03
+/*#define CMD_TAP_SHIFT     0x04 // old protocol */
+#define CMD_TAP_SHIFT     0x05
+#define CMD_ENTER_OOCD    0x06
+#define CMD_UART_SPEED    0x07
+#define CMD_JTAG_SPEED    0x08
+
+enum {
+	MODE_HIZ = 0,
+	MODE_JTAG = 1,		/* push-pull outputs */
+	MODE_JTAG_OD = 2,	/* open-drain outputs */
+};
+
+enum {
+	FEATURE_LED = 0x01,
+	FEATURE_VREG = 0x02,
+	FEATURE_TRST = 0x04,
+	FEATURE_SRST = 0x08,
+	FEATURE_PULLUP = 0x10
+};
+
+enum {
+	ACTION_DISABLE = 0,
+	ACTION_ENABLE = 1
+};
+
+enum {
+	SERIAL_NORMAL = 0,
+	SERIAL_FAST = 1
+};
+
+
+static int buspirate_fd = -1;
+static int buspirate_pinmode = MODE_JTAG_OD;
+static int buspirate_baudrate = SERIAL_NORMAL;
+static int buspirate_vreg;
+static int buspirate_pullup;
+static char *buspirate_port;
+
+
+/* TAP interface */
+static void buspirate_tap_init(void);
+static int buspirate_tap_execute(void);
+static void buspirate_tap_append(int tms, int tdi);
+static void buspirate_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command);
+static void buspirate_tap_make_space(int scan, int bits);
+
+static void buspirate_reset(int trst, int srst);
+
+/* low level interface */
+static void buspirate_jtag_reset(int);
+static void buspirate_jtag_enable(int);
+static unsigned char buspirate_jtag_command(int, char *, int);
+static void buspirate_jtag_set_speed(int, char);
+static void buspirate_jtag_set_mode(int, char);
+static void buspirate_jtag_set_feature(int, char, char);
+static void buspirate_jtag_get_adcs(int);
+
+/* low level HW communication interface */
+static int buspirate_serial_setspeed(int fd, speed_t speed);
+static int buspirate_serial_write(int fd, char *buf, int size);
+static int buspirate_serial_read(int fd, char *buf, int size);
+static void buspirate_print_buffer(char *buf, int size);
+
+static int buspirate_speed(int speed)
+{
+	/* TODO */
+	LOG_INFO("Want to set speed to %dkHz, but not implemented yet", speed);
+	return ERROR_OK;
+}
+
+static int buspirate_khz(int khz, int *jtag_speed)
+{
+	*jtag_speed = khz;
+	return ERROR_OK;
+}
+
+static int buspirate_execute_queue(void)
+{
+	/* currently processed command */
+	struct jtag_command *cmd = jtag_command_queue;
+	int scan_size;
+	enum scan_type type;
+	uint8_t *buffer;
+
+	while (cmd) {
+		switch (cmd->type) {
+		case JTAG_RUNTEST:
+			DEBUG_JTAG_IO("runtest %i cycles, end in %s",
+				cmd->cmd.runtest->num_cycles,
+				tap_state_name(cmd->cmd.runtest
+					->end_state));
+			buspirate_end_state(cmd->cmd.runtest
+					->end_state);
+			buspirate_runtest(cmd->cmd.runtest
+					->num_cycles);
+			break;
+		case JTAG_STATEMOVE:
+			DEBUG_JTAG_IO("statemove end in %s",
+				tap_state_name(cmd->cmd.statemove
+						->end_state));
+			buspirate_end_state(cmd->cmd.statemove
+					->end_state);
+			buspirate_state_move();
+			break;
+		case JTAG_PATHMOVE:
+			DEBUG_JTAG_IO("pathmove: %i states, end in %s",
+				cmd->cmd.pathmove->num_states,
+				tap_state_name(cmd->cmd.pathmove
+					->path[cmd->cmd.pathmove
+						->num_states - 1]));
+			buspirate_path_move(cmd->cmd.pathmove
+					->num_states,
+					cmd->cmd.pathmove->path);
+			break;
+		case JTAG_SCAN:
+			DEBUG_JTAG_IO("scan end in %s",
+				tap_state_name(cmd->cmd.scan
+					->end_state));
+
+			buspirate_end_state(cmd->cmd.scan
+					->end_state);
+
+			scan_size = jtag_build_buffer(cmd->cmd.scan,
+					&buffer);
+			type = jtag_scan_type(cmd->cmd.scan);
+			buspirate_scan(cmd->cmd.scan->ir_scan, type,
+				buffer, scan_size, cmd->cmd.scan);
+
+			break;
+		case JTAG_RESET:
+			DEBUG_JTAG_IO("reset trst: %i srst %i",
+				cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+
+			/* flush buffers, so we can reset */
+			buspirate_tap_execute();
+
+			if (cmd->cmd.reset->trst == 1)
+				tap_set_state(TAP_RESET);
+			buspirate_reset(cmd->cmd.reset->trst,
+					cmd->cmd.reset->srst);
+			break;
+		case JTAG_SLEEP:
+			DEBUG_JTAG_IO("sleep %i", cmd->cmd.sleep->us);
+			buspirate_tap_execute();
+			jtag_sleep(cmd->cmd.sleep->us);
+				break;
+		default:
+			LOG_ERROR("BUG: unknown JTAG command type encountered");
+			exit(-1);
+		}
+
+		cmd = cmd->next;
+	}
+
+	return buspirate_tap_execute();
+}
+
+static int buspirate_init(void)
+{
+	if (buspirate_port == NULL) {
+		LOG_ERROR("You need to specify port !");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	buspirate_fd = open(buspirate_port, O_RDWR | O_NOCTTY);
+	if (buspirate_fd == -1) {
+		LOG_ERROR("Could not open serial port.");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	buspirate_serial_setspeed(buspirate_fd, B115200);
+
+	buspirate_jtag_enable(buspirate_fd);
+
+	if (buspirate_baudrate != SERIAL_NORMAL)
+		buspirate_jtag_set_speed(buspirate_fd, SERIAL_FAST);
+
+	LOG_INFO("Buspirate Interface ready!");
+
+	buspirate_tap_init();
+	buspirate_jtag_set_mode(buspirate_fd, buspirate_pinmode);
+	buspirate_jtag_set_feature(buspirate_fd, FEATURE_VREG,
+		(buspirate_vreg == 1) ? ACTION_ENABLE : ACTION_DISABLE);
+	buspirate_jtag_set_feature(buspirate_fd, FEATURE_PULLUP,
+		(buspirate_pullup == 1) ? ACTION_ENABLE : ACTION_DISABLE);
+	buspirate_reset(0, 0);
+
+	return ERROR_OK;
+}
+
+static int buspirate_quit(void)
+{
+	LOG_INFO("Shuting down buspirate ");
+	buspirate_jtag_set_mode(buspirate_fd, MODE_HIZ);
+
+	buspirate_jtag_set_speed(buspirate_fd, SERIAL_NORMAL);
+	buspirate_jtag_reset(buspirate_fd);
+	if (buspirate_port) {
+		free(buspirate_port);
+		buspirate_port = NULL;
+	}
+	return ERROR_OK;
+}
+
+/* openocd command interface */
+COMMAND_HANDLER(buspirate_handle_adc_command)
+{
+	if (CMD_ARGC != 0) {
+		LOG_ERROR("usage: buspirate_adc");
+		return ERROR_OK;
+	}
+
+	if (buspirate_fd == -1)
+		return ERROR_OK;
+
+	/* send the command */
+	buspirate_jtag_get_adcs(buspirate_fd);
+
+	return ERROR_OK;
+
+}
+
+COMMAND_HANDLER(buspirate_handle_vreg_command)
+{
+	if (CMD_ARGC != 1) {
+		LOG_ERROR("usage: buspirate_vreg <1|0>");
+		return ERROR_OK;
+	}
+
+	if (atoi(CMD_ARGV[0]) == 1)
+		buspirate_vreg = 1;
+	else
+		buspirate_vreg = 0;
+
+	return ERROR_OK;
+
+}
+
+COMMAND_HANDLER(buspirate_handle_pullup_command)
+{
+	if (CMD_ARGC != 1) {
+		LOG_ERROR("usage: buspirate_pullup <1|0>");
+		return ERROR_OK;
+	}
+
+	if (atoi(CMD_ARGV[0]) == 1)
+		buspirate_pullup = 1;
+	else
+		buspirate_pullup = 0;
+
+	return ERROR_OK;
+
+}
+
+COMMAND_HANDLER(buspirate_handle_led_command)
+{
+	if (CMD_ARGC != 1) {
+		LOG_ERROR("usage: buspirate_led <1|0>");
+		return ERROR_OK;
+	}
+
+	if (atoi(CMD_ARGV[0]) == 1) {
+		/* enable led */
+		buspirate_jtag_set_feature(buspirate_fd, FEATURE_LED,
+				ACTION_ENABLE);
+	} else {
+		/* disable led */
+		buspirate_jtag_set_feature(buspirate_fd, FEATURE_LED,
+				ACTION_DISABLE);
+	}
+
+	return ERROR_OK;
+
+}
+
+COMMAND_HANDLER(buspirate_handle_mode_command)
+{
+	if (CMD_ARGC != 1) {
+		LOG_ERROR("usage: buspirate_mode <normal|open-drain>");
+		return ERROR_OK;
+	}
+
+	if (CMD_ARGV[0][0] == 'n')
+		buspirate_pinmode = MODE_JTAG;
+	else if (CMD_ARGV[0][0] == 'o')
+		buspirate_pinmode = MODE_JTAG_OD;
+	else
+		LOG_ERROR("usage: buspirate_mode <normal|open-drain>");
+
+	return ERROR_OK;
+
+}
+
+COMMAND_HANDLER(buspirate_handle_speed_command)
+{
+	if (CMD_ARGC != 1) {
+		LOG_ERROR("usage: buspirate_speed <normal|fast>");
+		return ERROR_OK;
+	}
+
+	if (CMD_ARGV[0][0] == 'n')
+		buspirate_baudrate = SERIAL_NORMAL;
+	else if (CMD_ARGV[0][0] == 'f')
+		buspirate_baudrate = SERIAL_FAST;
+	else
+		LOG_ERROR("usage: buspirate_speed <normal|fast>");
+
+	return ERROR_OK;
+
+}
+
+COMMAND_HANDLER(buspirate_handle_port_command)
+{
+	if (CMD_ARGC != 1) {
+		LOG_ERROR("usage: buspirate_port /dev/ttyUSB0");
+		return ERROR_OK;
+	}
+
+	if (buspirate_port == 0)
+		buspirate_port = strdup(CMD_ARGV[0]);
+
+	return ERROR_OK;
+
+}
+
+static const struct command_registration buspirate_command_handlers[] = {
+	{
+		.name = "buspirate_adc",
+		.handler = &buspirate_handle_adc_command,
+		.mode = COMMAND_EXEC,
+		.help = "reads voltages on adc pins",
+	},
+	{
+		.name = "buspirate_vreg",
+		.handler = &buspirate_handle_vreg_command,
+		.mode = COMMAND_CONFIG,
+		.help = "changes the state of voltage regulators",
+	},
+	{
+		.name = "buspirate_pullup",
+		.handler = &buspirate_handle_pullup_command,
+		.mode = COMMAND_CONFIG,
+		.help = "changes the state of pullup",
+	},
+	{
+		.name = "buspirate_led",
+		.handler = &buspirate_handle_led_command,
+		.mode = COMMAND_EXEC,
+		.help = "changes the state of led",
+	},
+	{
+		.name = "buspirate_speed",
+		.handler = &buspirate_handle_speed_command,
+		.mode = COMMAND_CONFIG,
+		.help = "speed of the interface",
+	},
+	{
+		.name = "buspirate_mode",
+		.handler = &buspirate_handle_mode_command,
+		.mode = COMMAND_CONFIG,
+		.help = "pin mode of the interface",
+	},
+	{
+		.name = "buspirate_port",
+		.handler = &buspirate_handle_port_command,
+		.mode =	COMMAND_CONFIG,
+		.help = "name of the serial port to open",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct jtag_interface buspirate_interface = {
+	.name = "buspirate",
+	.execute_queue = buspirate_execute_queue,
+	.speed = buspirate_speed,
+	.khz = buspirate_khz,
+	.commands = buspirate_command_handlers,
+	.init = buspirate_init,
+	.quit = buspirate_quit
+};
+
+/*************** jtag execute commands **********************/
+static void buspirate_end_state(tap_state_t state)
+{
+	if (tap_is_state_stable(state))
+		tap_set_end_state(state);
+	else {
+		LOG_ERROR("BUG: %i is not a valid end state", state);
+		exit(-1);
+	}
+}
+
+static void buspirate_state_move(void)
+{
+	int i = 0, tms = 0;
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(),
+			tap_get_end_state());
+	int tms_count = tap_get_tms_path_len(tap_get_state(),
+			tap_get_end_state());
+
+	for (i = 0; i < tms_count; i++) {
+		tms = (tms_scan >> i) & 1;
+		buspirate_tap_append(tms, 0);
+	}
+
+	tap_set_state(tap_get_end_state());
+}
+
+static void buspirate_path_move(int num_states, tap_state_t *path)
+{
+	int i;
+
+	for (i = 0; i < num_states; i++) {
+		if (tap_state_transition(tap_get_state(), false) == path[i]) {
+			buspirate_tap_append(0, 0);
+		} else if (tap_state_transition(tap_get_state(), true)
+				== path[i]) {
+			buspirate_tap_append(1, 0);
+		} else {
+			LOG_ERROR("BUG: %s -> %s isn't a valid "
+				"TAP transition",
+				tap_state_name(tap_get_state()),
+				tap_state_name(path[i]));
+			exit(-1);
+		}
+
+		tap_set_state(path[i]);
+	}
+
+	tap_set_end_state(tap_get_state());
+}
+
+static void buspirate_runtest(int num_cycles)
+{
+	int i;
+
+	tap_state_t saved_end_state = tap_get_end_state();
+
+	/* only do a state_move when we're not already in IDLE */
+	if (tap_get_state() != TAP_IDLE) {
+		buspirate_end_state(TAP_IDLE);
+		buspirate_state_move();
+	}
+
+	for (i = 0; i < num_cycles; i++)
+		buspirate_tap_append(0, 0);
+
+	DEBUG_JTAG_IO("runtest: cur_state %s end_state %s",
+			tap_state_name(tap_get_state()),
+			tap_state_name(tap_get_end_state()));
+
+	/* finish in end_state */
+	buspirate_end_state(saved_end_state);
+	if (tap_get_state() != tap_get_end_state())
+		buspirate_state_move();
+}
+
+static void buspirate_scan(bool ir_scan, enum scan_type type,
+	uint8_t *buffer, int scan_size, struct scan_command *command)
+{
+	tap_state_t saved_end_state;
+
+	buspirate_tap_make_space(1, scan_size+8);
+	/* is 8 correct ? (2 moves = 16) */
+
+	saved_end_state = tap_get_end_state();
+
+	buspirate_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
+	buspirate_state_move();
+
+	buspirate_tap_append_scan(scan_size, buffer, command);
+
+	/* move to PAUSE */
+	buspirate_tap_append(0, 0);
+
+	/* restore the saved state */
+	buspirate_end_state(saved_end_state);
+	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
+
+	if (tap_get_state() != tap_get_end_state())
+		buspirate_state_move();
+}
+
+
+/************************* TAP related stuff **********/
+
+#define BUSPIRATE_BUFFER_SIZE 1024
+#define BUSPIRATE_MAX_PENDING_SCANS 32
+
+static char tms_chain[BUSPIRATE_BUFFER_SIZE]; /* send */
+static char tdi_chain[BUSPIRATE_BUFFER_SIZE]; /* send */
+static int tap_chain_index;
+
+struct pending_scan_result /* this was stolen from arm-jtag-ew */
+{
+	int first; /* First bit position in tdo_buffer to read */
+	int length; /* Number of bits to read */
+	struct scan_command *command; /* Corresponding scan command */
+	uint8_t *buffer;
+};
+
+static struct pending_scan_result
+tap_pending_scans[BUSPIRATE_MAX_PENDING_SCANS];
+static int tap_pending_scans_num;
+
+static void buspirate_tap_init(void)
+{
+	tap_chain_index = 0;
+	tap_pending_scans_num = 0;
+}
+
+static int buspirate_tap_execute(void)
+{
+	char tmp[4096];
+	uint8_t *in_buf;
+	int i;
+	int fill_index = 0;
+	int ret;
+	int bytes_to_send;
+
+	if (tap_chain_index <= 0)
+		return ERROR_OK;
+
+	LOG_DEBUG("executing tap num bits = %i scans = %i",
+			tap_chain_index, tap_pending_scans_num);
+
+	bytes_to_send = (tap_chain_index+7) / 8;
+
+	tmp[0] = CMD_TAP_SHIFT; /* this command expects number of bits */
+	tmp[1] = (char)(tap_chain_index >> 8);  /* high */
+	tmp[2] = (char)(tap_chain_index);  /* low */
+
+	fill_index = 3;
+	for (i = 0; i < bytes_to_send; i++) {
+		tmp[fill_index] = tdi_chain[i];
+		fill_index++;
+		tmp[fill_index] = tms_chain[i];
+		fill_index++;
+	}
+
+	ret = buspirate_serial_write(buspirate_fd, tmp, 3 + bytes_to_send*2);
+	if (ret != bytes_to_send*2+3) {
+		LOG_ERROR("error writing :(");
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+
+	ret = buspirate_serial_read(buspirate_fd, tmp, bytes_to_send + 3);
+	in_buf = (uint8_t *)(&tmp[3]);
+
+	/* parse the scans */
+	for (i = 0; i < tap_pending_scans_num; i++) {
+		uint8_t *buffer = tap_pending_scans[i].buffer;
+		int length = tap_pending_scans[i].length;
+		int first = tap_pending_scans[i].first;
+		struct scan_command *command = tap_pending_scans[i].command;
+
+		/* copy bits from buffer */
+		buf_set_buf(in_buf, first, buffer, 0, length);
+
+		/* return buffer to higher level */
+		if (jtag_read_buffer(buffer, command) != ERROR_OK) {
+			buspirate_tap_init();
+			return ERROR_JTAG_QUEUE_FAILED;
+		}
+
+		free(buffer);
+	}
+	tap_pending_scans_num = 0;
+	tap_chain_index = 0;
+	return ERROR_OK;
+}
+
+static void buspirate_tap_make_space(int scans, int bits)
+{
+	int have_scans = BUSPIRATE_MAX_PENDING_SCANS - tap_pending_scans_num;
+	int have_bits = BUSPIRATE_BUFFER_SIZE * 8 - tap_chain_index;
+
+	if ((have_scans < scans) || (have_bits < bits))
+		buspirate_tap_execute();
+}
+
+static void buspirate_tap_append(int tms, int tdi)
+{
+	int index;
+
+	buspirate_tap_make_space(0, 1);
+	index = tap_chain_index / 8;
+
+	if (index < BUSPIRATE_BUFFER_SIZE) {
+		int bit_index = tap_chain_index % 8;
+		uint8_t bit = 1 << bit_index;
+
+		if (tms)
+			tms_chain[index] |= bit;
+		else
+			tms_chain[index] &= ~bit;
+
+		if (tdi)
+			tdi_chain[index] |= bit;
+		else
+			tdi_chain[index] &= ~bit;
+
+		tap_chain_index++;
+	} else
+		LOG_ERROR("tap_chain overflow, Bad things will happen");
+
+}
+
+static void buspirate_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command)
+{
+	int i;
+	tap_pending_scans[tap_pending_scans_num].length = length;
+	tap_pending_scans[tap_pending_scans_num].buffer = buffer;
+	tap_pending_scans[tap_pending_scans_num].command = command;
+	tap_pending_scans[tap_pending_scans_num].first = tap_chain_index;
+
+	for (i = 0; i < length; i++) {
+		int tms = (i < length-1 ? 0 : 1);
+		int tdi = (buffer[i/8] >> (i%8)) & 1;
+		buspirate_tap_append(tms, tdi);
+	}
+	tap_pending_scans_num++;
+}
+
+/*************** jtag wrapper functions *********************/
+
+/* (1) assert or (0) deassert reset lines */
+static void buspirate_reset(int trst, int srst)
+{
+	LOG_DEBUG("trst: %i, srst: %i", trst, srst);
+
+	if (trst)
+		buspirate_jtag_set_feature(buspirate_fd,
+				FEATURE_TRST, ACTION_DISABLE);
+	else
+		buspirate_jtag_set_feature(buspirate_fd,
+				FEATURE_TRST, ACTION_ENABLE);
+
+	if (srst)
+		buspirate_jtag_set_feature(buspirate_fd,
+				FEATURE_SRST, ACTION_DISABLE);
+	else
+		buspirate_jtag_set_feature(buspirate_fd,
+				FEATURE_SRST, ACTION_ENABLE);
+}
+
+/*************** jtag lowlevel functions ********************/
+static void buspirate_jtag_enable(int fd)
+{
+	int ret;
+	char tmp[21] = { [0 ... 20] = 0x00 };
+	int done = 0;
+	int cmd_sent = 0;
+
+	LOG_DEBUG("Entering binary mode");
+	buspirate_serial_write(fd, tmp, 20);
+	usleep(10000);
+
+	/* reads 1 to n "BBIO1"s and one "OCD1" */
+	while (!done) {
+		ret = buspirate_serial_read(fd, tmp, 4);
+		if (ret != 4) {
+			LOG_ERROR("Buspirate did not respond :"
+				"( restart everything");
+			exit(-1);
+		}
+		LOG_DEBUG("TUI");
+		if (strncmp(tmp, "BBIO", 4) == 0) {
+			ret = buspirate_serial_read(fd, tmp, 1);
+			if (ret != 1) {
+				LOG_ERROR("Buspirate did not respond well :"
+					"( restart everything");
+				exit(-1);
+			}
+			if (tmp[0] != '1') {
+				LOG_ERROR("Unsupported binary protocol ");
+				exit(-1);
+			}
+			if (cmd_sent == 0) {
+				cmd_sent = 1;
+				tmp[0] = CMD_ENTER_OOCD;
+				ret = buspirate_serial_write(fd, tmp, 1);
+			}
+		} else if (strncmp(tmp, "OCD1", 4) == 0)
+			done = 1;
+		else {
+			LOG_ERROR("Buspirate did not respond :"
+				"( restart everything");
+			exit(-1);
+		}
+	}
+
+}
+
+static void buspirate_jtag_reset(int fd)
+{
+	int ret;
+	char tmp[5];
+
+	tmp[0] = 0x00; /* exit OCD1 mode */
+	buspirate_serial_write(fd, tmp, 1);
+	usleep(10000);
+	ret = buspirate_serial_read(fd, tmp, 5);
+	if (strncmp(tmp, "BBIO1", 5) == 0) {
+		tmp[0] = 0x0F; /*  reset BP */
+		buspirate_serial_write(fd, tmp, 1);
+	} else
+		LOG_ERROR("Bad reply :( Please restart manually");
+}
+
+static void buspirate_jtag_set_speed(int fd, char speed)
+{
+	int ret;
+	char tmp[2];
+	char ack[2];
+	speed_t baudrate = B115200;
+
+	ack[0] = 0xAA;
+	ack[1] = 0x55;
+
+	tmp[0] = CMD_UART_SPEED;
+	tmp[1] = speed;
+	buspirate_jtag_command(fd, tmp, 2);
+
+	/* here the adapter changes speed, we need follow */
+	if (speed == SERIAL_FAST)
+		baudrate = B1000000;
+
+	buspirate_serial_setspeed(fd, baudrate);
+
+	buspirate_serial_write(fd, ack, 2);
+	ret = buspirate_serial_read(fd, tmp, 2);
+	if (ret != 2) {
+		LOG_ERROR("Buspirate did not respond :"
+			"( restart everything");
+		exit(-1);
+	}
+	if ((tmp[0] != CMD_UART_SPEED) || (tmp[1] != speed)) {
+		LOG_ERROR("Buspirate didn't reply as expected :"
+			"( restart everything");
+		exit(-1);
+	}
+	LOG_INFO("Buspirate switched to %s mode",
+		(speed == SERIAL_NORMAL) ? "normal" : "FAST");
+}
+
+
+static void buspirate_jtag_set_mode(int fd, char mode)
+{
+	char tmp[2];
+	tmp[0] = CMD_PORT_MODE;
+	tmp[1] = mode;
+	buspirate_jtag_command(fd, tmp, 2);
+}
+
+static void buspirate_jtag_set_feature(int fd, char feat, char action)
+{
+	char tmp[3];
+	tmp[0] = CMD_FEATURE;
+	tmp[1] = feat;   /* what */
+	tmp[2] = action; /* action */
+	buspirate_jtag_command(fd, tmp, 3);
+}
+
+static void buspirate_jtag_get_adcs(int fd)
+{
+	uint8_t tmp[10];
+	uint16_t a, b, c, d;
+	tmp[0] = CMD_READ_ADCS;
+	buspirate_jtag_command(fd, (char *)tmp, 1);
+	a = tmp[2] << 8 | tmp[3];
+	b = tmp[4] << 8 | tmp[5];
+	c = tmp[6] << 8 | tmp[7];
+	d = tmp[8] << 8 | tmp[9];
+
+	LOG_INFO("ADC: ADC_Pin = %.02f VPullup = %.02f V33 = %.02f "
+		"V50 = %.02f",
+		((float)a)/155.1515, ((float)b)/155.1515,
+		((float)c)/155.1515, ((float)d)/155.1515);
+}
+
+static unsigned char buspirate_jtag_command(int buspirate_fd,
+		char *cmd, int cmdlen)
+{
+	int res;
+	int len = 0;
+
+	res = buspirate_serial_write(buspirate_fd, cmd, cmdlen);
+
+	if ((cmd[0] == CMD_UART_SPEED)
+				|| (cmd[0] == CMD_PORT_MODE)
+				|| (cmd[0] == CMD_FEATURE)
+				|| (cmd[0] == CMD_JTAG_SPEED))
+		return 1;
+
+	if (res == cmdlen) {
+		switch (cmd[0]) {
+		case CMD_READ_ADCS:
+			len = 10; /* 2*sizeof(char)+4*sizeof(uint16_t) */
+			break;
+		case CMD_TAP_SHIFT:
+			len = cmdlen;
+			break;
+		default:
+			LOG_INFO("Wrong !");
+		}
+		res =  buspirate_serial_read(buspirate_fd, cmd, len);
+		if (res > 0)
+			return (unsigned char)cmd[1];
+		else
+			return -1;
+	} else
+		return -1;
+	return 0;
+}
+
+/* low level serial port */
+/* TODO add support for WIN32 and others ! */
+static int buspirate_serial_setspeed(int fd, speed_t speed)
+{
+	struct termios t_opt;
+
+	/* set the serial port parameters */
+	fcntl(buspirate_fd, F_SETFL, 0);
+	tcgetattr(buspirate_fd, &t_opt);
+	cfsetispeed(&t_opt, speed);
+	cfsetospeed(&t_opt, speed);
+	t_opt.c_cflag |= (CLOCAL | CREAD);
+	t_opt.c_cflag &= ~PARENB;
+	t_opt.c_cflag &= ~CSTOPB;
+	t_opt.c_cflag &= ~CSIZE;
+	t_opt.c_cflag |= CS8;
+	t_opt.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
+	t_opt.c_iflag &= ~(IXON | IXOFF | IXANY);
+	t_opt.c_oflag &= ~OPOST;
+	t_opt.c_cc[VMIN] = 0;
+	t_opt.c_cc[VTIME] = 10;
+	tcflush(buspirate_fd, TCIFLUSH);
+	tcsetattr(buspirate_fd, TCSANOW, &t_opt);
+
+	return 0;
+}
+
+static int buspirate_serial_write(int fd, char *buf, int size)
+{
+	int ret = 0;
+
+	ret = write(fd, buf, size);
+
+	LOG_DEBUG("size = %d ret = %d", size, ret);
+	buspirate_print_buffer(buf, size);
+
+	if (ret != size)
+		LOG_ERROR("Error sending data");
+
+	return ret;
+}
+
+static int buspirate_serial_read(int fd, char *buf, int size)
+{
+	int len = 0;
+	int ret = 0;
+	int timeout = 0;
+
+	while (len < size) {
+		ret = read(fd, buf+len, size-len);
+		if (ret == -1)
+			return -1;
+
+		if (ret == 0) {
+			timeout++;
+
+			if (timeout >= 10)
+				break;
+
+			continue;
+		}
+
+		len += ret;
+	}
+
+	LOG_DEBUG("should have read = %d actual size = %d", size, len);
+	buspirate_print_buffer(buf, len);
+
+	if (len != size)
+		LOG_ERROR("Error sending data");
+
+	return len;
+}
+
+#define LINE_SIZE      81
+#define BYTES_PER_LINE 16
+static void buspirate_print_buffer(char *buf, int size)
+{
+	char line[LINE_SIZE];
+	char tmp[10];
+	int offset = 0;
+
+	line[0] = 0;
+	while (offset < size) {
+		snprintf(tmp, 5, "%02x ", (uint8_t)buf[offset]);
+		offset++;
+
+		strcat(line, tmp);
+
+		if (offset % BYTES_PER_LINE == 0) {
+			LOG_DEBUG("%s", line);
+			line[0] = 0;
+		}
+	}
+
+	if (line[0] != 0) {
+		LOG_DEBUG("%s", line);
+	}
+}
+
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
index f6d8219..8d13a08 100644
--- a/src/jtag/interfaces.c
+++ b/src/jtag/interfaces.c
@@ -91,6 +91,9 @@ extern struct jtag_interface rlink_interface;
 #if BUILD_ARMJTAGEW == 1
 extern struct jtag_interface armjtagew_interface;
 #endif
+#if BUILD_BUSPIRATE == 1
+extern struct jtag_interface buspirate_interface;
+#endif
 #endif // standard drivers
 
 /**
@@ -151,6 +154,9 @@ struct jtag_interface *jtag_interfaces[] = {
 #if BUILD_ARMJTAGEW == 1
 		&armjtagew_interface,
 #endif
+#if BUILD_BUSPIRATE == 1
+		&buspirate_interface,
+#endif
 #endif // standard drivers
 		NULL,
 	};
diff --git a/tcl/interface/buspirate.cfg b/tcl/interface/buspirate.cfg
new file mode 100644
index 0000000..9c7e0e7
--- /dev/null
+++ b/tcl/interface/buspirate.cfg
@@ -0,0 +1,26 @@
+#
+# Buspirate with OpenOCD support
+#
+# http://dangerousprototypes.com/bus-pirate-manual/
+#
+
+interface buspirate
+
+# you need to specify port on which BP lives
+#buspirate_port /dev/ttyUSB0
+
+# communication speed setting
+buspirate_speed normal # or fast
+
+# voltage regulator Enabled = 1 Disabled = 0
+#buspirate_vreg 0
+
+# pin mode normal or open-drain
+#buspirate_mode normal
+
+# pullup state Enabled = 1 Disabled = 0
+#buspirate_pullup 0
+
+# this depends on the cable, you are safe with this option
+reset_config srst_only
+

-----------------------------------------------------------------------

Summary of changes:
 NEWS                         |    1 +
 configure.in                 |   11 +
 doc/openocd.texi             |    3 +
 src/jtag/drivers/Makefile.am |    3 +
 src/jtag/drivers/buspirate.c |  969 ++++++++++++++++++++++++++++++++++++++++++
 src/jtag/interfaces.c        |    6 +
 tcl/interface/buspirate.cfg  |   26 ++
 7 files changed, 1019 insertions(+), 0 deletions(-)
 create mode 100644 src/jtag/drivers/buspirate.c
 create mode 100644 tcl/interface/buspirate.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Mar 11 23:22:54 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 11 Mar 2010 22:22:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-77-g03a26d3
Message-ID: <E1NpqmO-0001hR-4U@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  03a26d31e991976ff978c8c9b245210f116f6ece (commit)
       via  db464f3cd4ed83b9f3411a98362dd67aad7bc3fd (commit)
      from  24e1e3dd2699b817fa72a7843d36197abcd9e3a3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 03a26d31e991976ff978c8c9b245210f116f6ece
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Mar 11 14:21:36 2010 -0800

    versaloon cleanup patch
    
    Remove undesirable
     - backslashes at end-of-line;
     - initializations of BSS data to zero/NULL;
     - overlong lines (80+ characters)
     - whitespace issues
     - brackets around single-line statements
    
    And other minor issues reported by the Linux "checkpatch" utility
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 451d5f8..a985677 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -39,11 +39,11 @@ static uint8_t  vsllink_usb_bulkin;
 static uint8_t  vsllink_usb_interface;
 static int      VSLLINK_USB_TIMEOUT = 1000;
 
-static int vsllink_tms_offset = 0;
+static int vsllink_tms_offset;
 
 /* Global USB buffers */
-static uint8_t* vsllink_usb_in_buffer  = NULL;
-static uint8_t* vsllink_usb_out_buffer = NULL;
+static uint8_t *vsllink_usb_in_buffer;
+static uint8_t *vsllink_usb_out_buffer;
 static int      vsllink_buffer_size    = 128;
 
 /* Constants for Versaloon command */
@@ -90,8 +90,8 @@ struct pending_scan_result {
 #define MAX_PENDING_SCAN_RESULTS 256
 
 static int pending_scan_results_length;
-static struct pending_scan_result \
-						pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
+static struct pending_scan_result
+		pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
 
 /* Queue command functions */
 static void vsllink_end_state(tap_state_t state);
@@ -99,8 +99,8 @@ static void vsllink_state_move(void);
 static void vsllink_path_move(int num_states, tap_state_t *path);
 static void vsllink_runtest(int num_cycles);
 static void vsllink_stableclocks(int num_cycles, int tms);
-static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
-							int scan_size, struct scan_command *command);
+static void vsllink_scan(bool ir_scan, enum scan_type type,
+	uint8_t *buffer, int scan_size, struct scan_command *command);
 static void vsllink_reset(int trst, int srst);
 static void vsllink_simple_command(uint8_t command);
 
@@ -109,17 +109,17 @@ static void vsllink_tap_append_step(int tms, int tdi);
 static void vsllink_tap_init(void);
 static int  vsllink_tap_execute(void);
 static void vsllink_tap_ensure_pending(int scans);
-static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
-									struct scan_command *command);
+static void vsllink_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command);
 
 /* VSLLink lowlevel functions */
 struct vsllink {
-	struct usb_dev_handle* usb_handle;
+	struct usb_dev_handle *usb_handle;
 };
 
 static struct vsllink *vsllink_usb_open(void);
 static void vsllink_usb_close(struct vsllink *vsllink);
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length,
 								int in_length);
 static int vsllink_usb_write(struct vsllink *vsllink, int out_length);
 static int vsllink_usb_read(struct vsllink *vsllink);
@@ -128,13 +128,13 @@ static int vsllink_usb_read(struct vsllink *vsllink);
 static void vsllink_debug_buffer(uint8_t *buffer, int length);
 #endif
 
-static int tap_length = 0;
-static int tap_buffer_size = 0;
-static uint8_t *tms_buffer = NULL;
-static uint8_t *tdi_buffer = NULL;
-static uint8_t *tdo_buffer = NULL;
+static int tap_length;
+static int tap_buffer_size;
+static uint8_t *tms_buffer;
+static uint8_t *tdi_buffer;
+static uint8_t *tdo_buffer;
 
-static struct vsllink* vsllink_handle = NULL;
+static struct vsllink *vsllink_handle;
 
 static void reset_command_pointer(void)
 {
@@ -148,80 +148,91 @@ static int vsllink_execute_queue(void)
 	enum scan_type type;
 	uint8_t *buffer;
 
-	DEBUG_JTAG_IO(	"-------------------------------------"
-					" vsllink "
-					"-------------------------------------");
+	DEBUG_JTAG_IO("-------------------------------------"
+		" vsllink "
+		"-------------------------------------");
 
 	reset_command_pointer();
-	while (cmd != NULL)
-	{
-		switch (cmd->type)
-		{
+	while (cmd != NULL) {
+		switch (cmd->type) {
 			case JTAG_RUNTEST:
-				DEBUG_JTAG_IO("runtest %i cycles, end in %s", \
-								cmd->cmd.runtest->num_cycles, \
-								tap_state_name(cmd->cmd.runtest->end_state));
+				DEBUG_JTAG_IO("runtest %i cycles, end in %s",
+					cmd->cmd.runtest->num_cycles,
+					tap_state_name(cmd->cmd.runtest
+							->end_state));
 
 				vsllink_end_state(cmd->cmd.runtest->end_state);
 				vsllink_runtest(cmd->cmd.runtest->num_cycles);
 				break;
 
 			case JTAG_STATEMOVE:
-				DEBUG_JTAG_IO("statemove end in %s", \
-								tap_state_name(cmd->cmd.statemove->end_state));
+				DEBUG_JTAG_IO("statemove end in %s",
+					tap_state_name(cmd->cmd.statemove
+							->end_state));
 
-				vsllink_end_state(cmd->cmd.statemove->end_state);
+				vsllink_end_state(cmd->cmd.statemove
+							->end_state);
 				vsllink_state_move();
 				break;
 
 			case JTAG_PATHMOVE:
-				DEBUG_JTAG_IO("pathmove: %i states, end in %s", \
-					cmd->cmd.pathmove->num_states, \
-					tap_state_name(cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]));
-
-				vsllink_path_move(cmd->cmd.pathmove->num_states, \
-									cmd->cmd.pathmove->path);
+				DEBUG_JTAG_IO("pathmove: %i states, end in %s",
+					cmd->cmd.pathmove->num_states,
+					tap_state_name(cmd->cmd.pathmove
+						->path[cmd->cmd.pathmove
+							->num_states - 1]));
+
+				vsllink_path_move(
+					cmd->cmd.pathmove->num_states,
+					cmd->cmd.pathmove->path);
 				break;
 
 			case JTAG_SCAN:
 				vsllink_end_state(cmd->cmd.scan->end_state);
 
-				scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
+				scan_size = jtag_build_buffer(
+					cmd->cmd.scan, &buffer);
+
 				if (cmd->cmd.scan->ir_scan)
-				{
-					DEBUG_JTAG_IO("JTAG Scan write IR(%d bits), end in %s:", \
-									scan_size, \
-									tap_state_name(cmd->cmd.scan->end_state));
-				}
+					DEBUG_JTAG_IO(
+						"JTAG Scan write IR(%d bits), "
+						"end in %s:",
+						scan_size,
+						tap_state_name(cmd->cmd.scan
+								->end_state));
+
 				else
-				{
-					DEBUG_JTAG_IO("JTAG Scan write DR(%d bits), end in %s:", \
-									scan_size, \
-									tap_state_name(cmd->cmd.scan->end_state));
-				}
+					DEBUG_JTAG_IO(
+						"JTAG Scan write DR(%d bits), "
+						"end in %s:",
+						scan_size,
+						tap_state_name(cmd->cmd.scan
+							->end_state));
 
 #ifdef _DEBUG_JTAG_IO_
-				vsllink_debug_buffer(buffer, DIV_ROUND_UP(scan_size, 8));
+				vsllink_debug_buffer(buffer,
+					DIV_ROUND_UP(scan_size, 8));
 #endif
 
 				type = jtag_scan_type(cmd->cmd.scan);
 
-				vsllink_scan(cmd->cmd.scan->ir_scan, type, buffer, \
-								scan_size, cmd->cmd.scan);
+				vsllink_scan(cmd->cmd.scan->ir_scan,
+						type, buffer, scan_size,
+						cmd->cmd.scan);
 				break;
 
 			case JTAG_RESET:
-				DEBUG_JTAG_IO("reset trst: %i srst %i", \
-								cmd->cmd.reset->trst, \
-								cmd->cmd.reset->srst);
+				DEBUG_JTAG_IO("reset trst: %i srst %i",
+						cmd->cmd.reset->trst,
+						cmd->cmd.reset->srst);
 
 				vsllink_tap_execute();
 
 				if (cmd->cmd.reset->trst == 1)
-				{
 					tap_set_state(TAP_RESET);
-				}
-				vsllink_reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+
+				vsllink_reset(cmd->cmd.reset->trst,
+						cmd->cmd.reset->srst);
 				break;
 
 			case JTAG_SLEEP:
@@ -231,12 +242,13 @@ static int vsllink_execute_queue(void)
 				break;
 
 			case JTAG_STABLECLOCKS:
-				DEBUG_JTAG_IO("add %d clocks", \
-								cmd->cmd.stableclocks->num_cycles);
-				switch (tap_get_state())
-				{
+				DEBUG_JTAG_IO("add %d clocks",
+					cmd->cmd.stableclocks->num_cycles);
+				switch (tap_get_state()) {
 				case TAP_RESET:
-					// tms should be '1' to stay in TAP_RESET mode
+					/* tms must be '1' to stay
+					 * n TAP_RESET mode
+					 */
 					scan_size = 1;
 					break;
 				case TAP_DRSHIFT:
@@ -244,21 +256,24 @@ static int vsllink_execute_queue(void)
 				case TAP_DRPAUSE:
 				case TAP_IRSHIFT:
 				case TAP_IRPAUSE:
-					// in other mode, tms should be '0'
+					/* else, tms should be '0' */
 					scan_size = 0;
-					break;			/* above stable states are OK */
+					break;
+					/* above stable states are OK */
 				default:
-					 LOG_ERROR("jtag_add_clocks() in non-stable state \"%s\"",
-								tap_state_name(tap_get_state()));
-					 exit(-1);
+					 LOG_ERROR("jtag_add_clocks() "
+						"in non-stable state \"%s\"",
+						tap_state_name(tap_get_state())
+						);
+				 exit(-1);
 				}
-				vsllink_stableclocks(cmd->cmd.stableclocks->num_cycles, \
-										scan_size);
+				vsllink_stableclocks(cmd->cmd.stableclocks
+						->num_cycles, scan_size);
 				break;
 
 			default:
-				LOG_ERROR("BUG: unknown JTAG command type encountered: %d", \
-							cmd->type);
+				LOG_ERROR("BUG: unknown JTAG command type "
+					"encountered: %d", cmd->type);
 				exit(-1);
 		}
 		cmd = cmd->next;
@@ -278,11 +293,8 @@ static int vsllink_speed(int speed)
 	result = vsllink_usb_write(vsllink_handle, 3);
 
 	if (result == 3)
-	{
 		return ERROR_OK;
-	}
-	else
-	{
+	else {
 		LOG_ERROR("VSLLink setting speed failed (%d)", result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
@@ -312,66 +324,60 @@ static int vsllink_init(void)
 
 	vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
 	vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
-	if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
-	{
+	if ((vsllink_usb_in_buffer == NULL)
+			|| (vsllink_usb_out_buffer == NULL)) {
 		LOG_ERROR("Not enough memory");
 		exit(-1);
 	}
 
 	vsllink_handle = vsllink_usb_open();
-	if (vsllink_handle == 0)
-	{
+	if (vsllink_handle == 0) {
 		LOG_ERROR("Can't find USB JTAG Interface!"\
-					"Please check connection and permissions.");
+				"Please check connection and permissions.");
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	LOG_DEBUG("vsllink found on %04X:%04X", vsllink_usb_vid, vsllink_usb_pid);
+	LOG_DEBUG("vsllink found on %04X:%04X",
+			vsllink_usb_vid, vsllink_usb_pid);
 
 	to_tmp = VSLLINK_USB_TIMEOUT;
 	VSLLINK_USB_TIMEOUT = 100;
 	check_cnt = 0;
-	while (check_cnt < 5)
-	{
+	while (check_cnt < 5) {
 		vsllink_simple_command(VERSALOON_GET_INFO);
 		result = vsllink_usb_read(vsllink_handle);
 
-		if (result > 2)
-		{
+		if (result > 2) {
 			vsllink_usb_in_buffer[result] = 0;
-			vsllink_buffer_size = vsllink_usb_in_buffer[0] + \
-									(vsllink_usb_in_buffer[1] << 8);
-			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+			vsllink_buffer_size = vsllink_usb_in_buffer[0]
+					+ (vsllink_usb_in_buffer[1] << 8);
+			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2,
 					sizeof(version_str));
 			LOG_INFO("%s", version_str);
 
-			// free the pre-alloc memroy
+			/* free the pre-allocated memory */
 			free(vsllink_usb_in_buffer);
 			free(vsllink_usb_out_buffer);
 			vsllink_usb_in_buffer = NULL;
 			vsllink_usb_out_buffer = NULL;
 
-			// alloc new memory
+			/* alloc new memory */
 			vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
 			vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
-			if ((vsllink_usb_in_buffer == NULL) || \
-				(vsllink_usb_out_buffer == NULL))
-			{
+			if ((vsllink_usb_in_buffer == NULL) ||
+				(vsllink_usb_out_buffer == NULL)) {
 				LOG_ERROR("Not enough memory");
 				exit(-1);
-			}
-			else
-			{
-				LOG_INFO("buffer size for USB is %d bytes", \
+			} else
+				LOG_INFO("buffer size for USB is %d bytes",
 							vsllink_buffer_size);
-			}
-			// alloc tms/tdi/tdo buffer
+
+			/* alloc tms/tdi/tdo buffer */
 			tap_buffer_size = (vsllink_buffer_size - 3) / 2;
-			tms_buffer = (uint8_t*)malloc(tap_buffer_size);
-			tdi_buffer = (uint8_t*)malloc(tap_buffer_size);
-			tdo_buffer = (uint8_t*)malloc(tap_buffer_size);
-			if ((tms_buffer == NULL) || (tdi_buffer == NULL) || \
-				(tdo_buffer == NULL))
-			{
+			tms_buffer = (uint8_t *)malloc(tap_buffer_size);
+			tdi_buffer = (uint8_t *)malloc(tap_buffer_size);
+			tdo_buffer = (uint8_t *)malloc(tap_buffer_size);
+			if ((tms_buffer == NULL) || (tdi_buffer == NULL) ||
+				(tdo_buffer == NULL)) {
 				LOG_ERROR("Not enough memory");
 				exit(-1);
 			}
@@ -380,9 +386,8 @@ static int vsllink_init(void)
 		vsllink_simple_command(VSLLINK_CMD_DISCONN);
 		check_cnt++;
 	}
-	if (check_cnt == 3)
-	{
-		// Fail to access Versaloon
+	if (check_cnt == 3) {
+		/* Fail to access Versaloon */
 		LOG_ERROR("VSLLink initial failed");
 		exit(-1);
 	}
@@ -394,33 +399,27 @@ static int vsllink_init(void)
 	vsllink_simple_command(VERSALOON_GET_TVCC);
 	result = vsllink_usb_read(vsllink_handle);
 	if (result != 2)
-	{
 		LOG_WARNING("Fail to get target voltage");
-	}
 	else
-	{
-		LOG_INFO("Target runs at %d mV", vsllink_usb_in_buffer[0] + \
+		LOG_INFO("Target runs at %d mV", vsllink_usb_in_buffer[0] +
 					(vsllink_usb_in_buffer[1] << 8));
-	}
 
-	// connect to vsllink
+	/* connect to vsllink */
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
 	vsllink_usb_out_buffer[1] = 1;
 	vsllink_usb_message(vsllink_handle, 2, 0);
-	if (vsllink_usb_read(vsllink_handle) > 2)
-	{
-		strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+	if (vsllink_usb_read(vsllink_handle) > 2) {
+		strncpy(version_str, (char *)vsllink_usb_in_buffer + 2,
 				sizeof(version_str));
 		LOG_INFO("%s", version_str);
 	}
 
-	// Set SRST and TRST to output, Set USR1 and USR2 to input
+	/* Set SRST and TRST to output, Set USR1 and USR2 to input */
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
-								JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST
+				| JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 	vsllink_usb_out_buffer[2] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
-	if (vsllink_usb_write(vsllink_handle, 3) != 3)
-	{
+	if (vsllink_usb_write(vsllink_handle, 3) != 3) {
 		LOG_ERROR("VSLLink USB send data error");
 		exit(-1);
 	}
@@ -436,15 +435,14 @@ static int vsllink_init(void)
 
 static int vsllink_quit(void)
 {
-	if ((vsllink_usb_in_buffer != NULL) && (vsllink_usb_out_buffer != NULL))
-	{
+	if ((vsllink_usb_in_buffer != NULL)
+			&& (vsllink_usb_out_buffer != NULL)) {
 		// Set all pins to input
 		vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
-									JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST
+				| JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 		vsllink_usb_out_buffer[2] = 0;
-		if (vsllink_usb_write(vsllink_handle, 3) != 3)
-		{
+		if (vsllink_usb_write(vsllink_handle, 3) != 3) {
 			LOG_ERROR("VSLLink USB send data error");
 			exit(-1);
 		}
@@ -455,13 +453,11 @@ static int vsllink_quit(void)
 		vsllink_handle = NULL;
 	}
 
-	if (vsllink_usb_in_buffer != NULL)
-	{
+	if (vsllink_usb_in_buffer != NULL) {
 		free(vsllink_usb_in_buffer);
 		vsllink_usb_in_buffer = NULL;
 	}
-	if (vsllink_usb_out_buffer != NULL)
-	{
+	if (vsllink_usb_out_buffer != NULL) {
 		free(vsllink_usb_out_buffer);
 		vsllink_usb_out_buffer = NULL;
 	}
@@ -475,11 +471,8 @@ static int vsllink_quit(void)
 static void vsllink_end_state(tap_state_t state)
 {
 	if (tap_is_state_stable(state))
-	{
 		tap_set_end_state(state);
-	}
-	else
-	{
+	else {
 		LOG_ERROR("BUG: %i is not a valid end state", state);
 		exit(-1);
 	}
@@ -489,34 +482,27 @@ static void vsllink_end_state(tap_state_t state)
 static void vsllink_state_move(void)
 {
 	int i;
-	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-	uint8_t tms_scan_bits = \
-				tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(),
+					tap_get_end_state());
+	uint8_t tms_scan_bits = tap_get_tms_path_len(tap_get_state(),
+					tap_get_end_state());
 
 	for (i = 0; i < tms_scan_bits; i++)
-	{
 		vsllink_tap_append_step((tms_scan >> i) & 1, 0);
-	}
 
 	tap_set_state(tap_get_end_state());
 }
 
 static void vsllink_path_move(int num_states, tap_state_t *path)
 {
-	for (int i = 0; i < num_states; i++)
-	{
+	for (int i = 0; i < num_states; i++) {
 		if (path[i] == tap_state_transition(tap_get_state(), false))
-		{
 			vsllink_tap_append_step(0, 0);
-		}
 		else if (path[i] == tap_state_transition(tap_get_state(), true))
-		{
 			vsllink_tap_append_step(1, 0);
-		}
-		else
-		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", \
-						tap_state_name(tap_get_state()), \
+		else {
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition",
+						tap_state_name(tap_get_state()),
 						tap_state_name(path[i]));
 			exit(-1);
 		}
@@ -529,8 +515,7 @@ static void vsllink_path_move(int num_states, tap_state_t *path)
 
 static void vsllink_stableclocks(int num_cycles, int tms)
 {
-	while (num_cycles > 0)
-	{
+	while (num_cycles > 0) {
 		vsllink_tap_append_step(tms, 0);
 		num_cycles--;
 	}
@@ -540,9 +525,8 @@ static void vsllink_runtest(int num_cycles)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 
-	if (tap_get_state() != TAP_IDLE)
-	{
-		// enter into IDLE state
+	if (tap_get_state() != TAP_IDLE) {
+		/* enter IDLE state */
 		vsllink_end_state(TAP_IDLE);
 		vsllink_state_move();
 	}
@@ -553,13 +537,11 @@ static void vsllink_runtest(int num_cycles)
 	// set end_state
 	vsllink_end_state(saved_end_state);
 	if (tap_get_end_state() != tap_get_end_state())
-	{
 		vsllink_state_move();
-	}
 }
 
-static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
-							int scan_size, struct scan_command *command)
+static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer,
+				int scan_size, struct scan_command *command)
 {
 	tap_state_t saved_end_state;
 
@@ -569,9 +551,7 @@ static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
 
 	if (tap_get_state() != tap_get_end_state())
-	{
 		vsllink_state_move();
-	}
 	vsllink_end_state(saved_end_state);
 
 	/* Scan */
@@ -584,9 +564,7 @@ static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
 	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
 
 	if (tap_get_state() != tap_get_end_state())
-	{
 		vsllink_state_move();
-	}
 }
 
 static void vsllink_reset(int trst, int srst)
@@ -600,19 +578,14 @@ static void vsllink_reset(int trst, int srst)
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
 	vsllink_usb_out_buffer[2] = 0;
 	if (srst == 0)
-	{
 		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_SRST;
-	}
 	if (trst == 0)
-	{
 		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_TRST;
-	}
 
 	result = vsllink_usb_write(vsllink_handle, 3);
 	if (result != 3)
-	{
-		LOG_ERROR("VSLLink command VSLLINK_CMD_SET_PORT failed (%d)", result);
-	}
+		LOG_ERROR("VSLLink command VSLLINK_CMD_SET_PORT failed (%d)",
+				result);
 }
 
 static void vsllink_simple_command(uint8_t command)
@@ -625,9 +598,8 @@ static void vsllink_simple_command(uint8_t command)
 	result = vsllink_usb_write(vsllink_handle, 1);
 
 	if (result != 1)
-	{
-		LOG_ERROR("VSLLink command 0x%02x failed (%d)", command, result);
-	}
+		LOG_ERROR("VSLLink command 0x%02x failed (%d)",
+				command, result);
 }
 
 COMMAND_HANDLER(vsllink_handle_mode_command)
@@ -643,8 +615,7 @@ COMMAND_HANDLER(vsllink_handle_mode_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_vid_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR("parameter error, "
 					"should be one parameter for VID");
 		return ERROR_OK;
@@ -656,8 +627,7 @@ COMMAND_HANDLER(vsllink_handle_usb_vid_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_pid_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR("parameter error, "
 					"should be one parameter for PID");
 		return ERROR_OK;
@@ -668,10 +638,9 @@ COMMAND_HANDLER(vsllink_handle_usb_pid_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_bulkin_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR("parameter error, "
-					"should be one parameter for BULKIN endpoint");
+			"should be one parameter for BULKIN endpoint");
 		return ERROR_OK;
 	}
 
@@ -684,10 +653,9 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkin_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_bulkout_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR("parameter error, "
-					"should be one parameter for BULKOUT endpoint");
+			"should be one parameter for BULKOUT endpoint");
 		return ERROR_OK;
 	}
 
@@ -700,10 +668,9 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkout_command)
 
 COMMAND_HANDLER(vsllink_handle_usb_interface_command)
 {
-	if (CMD_ARGC != 1)
-	{
+	if (CMD_ARGC != 1) {
 		LOG_ERROR("parameter error, "
-					"should be one parameter for interface number");
+			"should be one parameter for interface number");
 		return ERROR_OK;
 	}
 
@@ -723,13 +690,11 @@ static void vsllink_tap_init(void)
 
 static void vsllink_tap_ensure_pending(int scans)
 {
-	int available_scans = \
+	int available_scans =
 			MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 
 	if (scans > available_scans)
-	{
 		vsllink_tap_execute();
-	}
 }
 
 static void vsllink_tap_append_step(int tms, int tdi)
@@ -740,52 +705,40 @@ static void vsllink_tap_append_step(int tms, int tdi)
 	uint8_t bit = 1 << bit_index;
 
 	if (tms)
-	{
 		tms_buffer[index] |= bit;
-	}
 	else
-	{
 		tms_buffer[index] &= ~bit;
-	}
 
 	if (tdi)
-	{
 		tdi_buffer[index] |= bit;
-	}
 	else
-	{
 		tdi_buffer[index] &= ~bit;
-	}
 
 	tap_length++;
+
 	if (tap_buffer_size * 8 <= tap_length)
-	{
 		vsllink_tap_execute();
-	}
 }
 
-static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
-										struct scan_command *command)
+static void vsllink_tap_append_scan(int length, uint8_t *buffer,
+		struct scan_command *command)
 {
 	struct pending_scan_result *pending_scan_result;
 	int len_tmp, len_all, i;
 
 	len_all = 0;
-	while (len_all < length)
-	{
+	while (len_all < length) {
 		vsllink_tap_ensure_pending(1);
-		pending_scan_result = \
-				&pending_scan_results_buffer[pending_scan_results_length];
+		pending_scan_result =
+				&pending_scan_results_buffer[
+					pending_scan_results_length];
 
-		if ((length - len_all) > (tap_buffer_size * 8 - tap_length))
-		{
-			/* Use all memory available 
+		if ((length - len_all) > (tap_buffer_size * 8 - tap_length)) {
+			/* Use all memory available
 			   vsllink_tap_append_step will commit automatically */
 			len_tmp = tap_buffer_size * 8 - tap_length;
 			pending_scan_result->last = false;
-		}
-		else
-		{
+		} else {
 			len_tmp = length - len_all;
 			pending_scan_result->last = true;
 		}
@@ -796,10 +749,11 @@ static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
 		pending_scan_result->buffer = buffer;
 		pending_scan_results_length++;
 
-		for (i = 0; i < len_tmp; i++)
-		{
-			vsllink_tap_append_step(((len_all + i) < length-1 ? 0 : 1), \
-						(buffer[(len_all + i)/8] >> ((len_all + i)%8)) & 1);
+		for (i = 0; i < len_tmp; i++) {
+			vsllink_tap_append_step(((len_all + i) < length-1
+						? 0 : 1),
+					(buffer[(len_all + i)/8]
+						>> ((len_all + i)%8)) & 1);
 		}
 
 		len_all += len_tmp;
@@ -813,61 +767,70 @@ static int vsllink_tap_execute(void)
 	int result;
 
 	if (tap_length <= 0)
-	{
 		return ERROR_OK;
-	}
 
 	/* Pad data so that tap_length is divisible by 8 */
-	if ((tap_length % 8) != 0)
-	{
-		if (vsllink_tms_offset > 0)
-		{
-			/* append tms:0 at vsllink_tms_offset, which is in Pause */
+	if ((tap_length % 8) != 0) {
+		if (vsllink_tms_offset > 0) {
+			/* append tms:0 at vsllink_tms_offset,
+			 * which is in Pause
+			 */
 			int start_pos = DIV_ROUND_UP(tap_length, 8) - 1;
 			int end_pos = DIV_ROUND_UP(vsllink_tms_offset, 8) - 1;
 			int shift_cnt = (start_pos + 1) * 8 - tap_length;
-			uint8_t last_mask = ~((1 << (vsllink_tms_offset % 8)) - 1);
-
-			while (1)
-			{
-				if (start_pos == end_pos)
-				{
-					tms_buffer[start_pos] = \
-								(tms_buffer[start_pos] & ~last_mask) | \
-								((tms_buffer[start_pos] & last_mask) << shift_cnt);
-					tdi_buffer[start_pos] = \
-								(tdi_buffer[start_pos] & ~last_mask) | \
-								((tdi_buffer[start_pos] & last_mask) << shift_cnt);
+			uint8_t last_mask = ~(
+				(1 << (vsllink_tms_offset % 8)) - 1);
+
+			while (1) {
+				if (start_pos == end_pos) {
+					tms_buffer[start_pos] =
+						(tms_buffer[start_pos]
+							& ~last_mask)
+						| ((tms_buffer[start_pos]
+								& last_mask)
+							<< shift_cnt);
+					tdi_buffer[start_pos] =
+						(tdi_buffer[start_pos]
+							& ~last_mask)
+						|
+						((tdi_buffer[start_pos]
+								& last_mask)
+								<< shift_cnt);
 					break;
-				}
-				else if (start_pos == (end_pos + 1))
-				{
-					tms_buffer[start_pos] = \
-						(tms_buffer[start_pos] << shift_cnt) | \
-						((tms_buffer[start_pos - 1] & last_mask) >> (8 - shift_cnt));
-					tdi_buffer[start_pos] = \
-						(tdi_buffer[start_pos] << shift_cnt) | \
-						((tdi_buffer[start_pos - 1] & last_mask) >> (8 - shift_cnt));
-				}
-				else
-				{
-					tms_buffer[start_pos] = \
-						(tms_buffer[start_pos] << shift_cnt) | \
-						(tms_buffer[start_pos - 1] >> (8 - shift_cnt));
-					tdi_buffer[start_pos] = \
-						(tdi_buffer[start_pos] << shift_cnt) | \
-						(tdi_buffer[start_pos - 1] >> (8 - shift_cnt));
+				} else if (start_pos == (end_pos + 1)) {
+					tms_buffer[start_pos] =
+						(tms_buffer[start_pos]
+							<< shift_cnt) |
+						((tms_buffer[start_pos - 1]
+								& last_mask)
+							>> (8 - shift_cnt));
+					tdi_buffer[start_pos] =
+						(tdi_buffer[start_pos]
+							<< shift_cnt) |
+						((tdi_buffer[start_pos - 1]
+								& last_mask)
+							>> (8 - shift_cnt));
+				} else {
+					tms_buffer[start_pos] =
+						(tms_buffer[start_pos]
+							<< shift_cnt) |
+						(tms_buffer[start_pos - 1]
+							>> (8 - shift_cnt));
+					tdi_buffer[start_pos] =
+						(tdi_buffer[start_pos]
+							<< shift_cnt) |
+						(tdi_buffer[start_pos - 1]
+							>> (8 - shift_cnt));
 				}
 				start_pos--;
 			}
 			tap_length = DIV_ROUND_UP(tap_length, 8) * 8;
-		}
-		else
-		{
+		} else {
 			/* append data at last */
-			while ((tap_length % 8) != 0)
-			{
-				vsllink_tap_append_step((tap_get_state() == TAP_RESET)?1:0, 0);
+			while ((tap_length % 8) != 0) {
+				vsllink_tap_append_step(
+					(tap_get_state() == TAP_RESET)
+						? 1 : 0, 0);
 			}
 		}
 	}
@@ -878,51 +841,48 @@ static int vsllink_tap_execute(void)
 	vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) >> 8) & 0xff;
 
 	memcpy(&vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
-	memcpy(&vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
+	memcpy(&vsllink_usb_out_buffer[3 + byte_length], tms_buffer,
+			byte_length);
 
-	result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length, \
-									byte_length);
+	result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length,
+			byte_length);
 
-	if (result == byte_length)
-	{
-		for (i = 0; i < pending_scan_results_length; i++)
-		{
-			struct pending_scan_result *pending_scan_result = \
-											&pending_scan_results_buffer[i];
+	if (result == byte_length) {
+		for (i = 0; i < pending_scan_results_length; i++) {
+			struct pending_scan_result *pending_scan_result =
+				&pending_scan_results_buffer[i];
 			uint8_t *buffer = pending_scan_result->buffer;
 			int length = pending_scan_result->length;
 			int src_first = pending_scan_result->src_offset;
 			int dest_first = pending_scan_result->dest_offset;
 			bool last = pending_scan_result->last;
 
-			struct scan_command *command = pending_scan_result->command;
-			buf_set_buf(vsllink_usb_in_buffer, src_first, buffer, \
+			struct scan_command *command;
+
+			command = pending_scan_result->command;
+			buf_set_buf(vsllink_usb_in_buffer, src_first, buffer,
 							dest_first, length);
 
-			DEBUG_JTAG_IO("JTAG scan read(%d bits, from %d bits):", \
-							length, dest_first);
+			DEBUG_JTAG_IO("JTAG scan read(%d bits, from %d bits):",
+					length, dest_first);
 #ifdef _DEBUG_JTAG_IO_
-			vsllink_debug_buffer(buffer + dest_first / 8, DIV_ROUND_UP(length, 7));
+			vsllink_debug_buffer(buffer + dest_first / 8,
+					DIV_ROUND_UP(length, 7));
 #endif
 
-			if (last)
-			{
-				if (jtag_read_buffer(buffer, command) != ERROR_OK)
-				{
+			if (last) {
+				if (jtag_read_buffer(buffer, command)
+						!= ERROR_OK) {
 					vsllink_tap_init();
 					return ERROR_JTAG_QUEUE_FAILED;
 				}
 
 				if (pending_scan_result->buffer != NULL)
-				{
 					free(pending_scan_result->buffer);
-				}
 			}
 		}
-	}
-	else
-	{
-		LOG_ERROR("vsllink_tap_execute, wrong result %d, expected %d", \
+	} else {
+		LOG_ERROR("vsllink_tap_execute, wrong result %d, expected %d",
 					result, byte_length);
 		return ERROR_JTAG_QUEUE_FAILED;
 	}
@@ -935,7 +895,7 @@ static int vsllink_tap_execute(void)
 /*****************************************************************************/
 /* VSLLink USB low-level functions */
 
-static struct vsllink* vsllink_usb_open(void)
+static struct vsllink *vsllink_usb_open(void)
 {
 	usb_init();
 
@@ -947,17 +907,16 @@ static struct vsllink* vsllink_usb_open(void)
 
 	/* usb_set_configuration required under win32 */
 	struct usb_device *udev = usb_device(dev);
-	int ret = usb_set_configuration(dev, udev->config[0].bConfigurationValue);
-	if (ret != 0)
-	{
+	int ret = usb_set_configuration(dev,
+			udev->config[0].bConfigurationValue);
+	if (ret != 0) {
 		LOG_ERROR("fail to set configuration to %d (error %d)."
 				"Not enough permissions for the device?",
 				udev->config[0].bConfigurationValue, ret);
 		return NULL;
 	}
 	ret = usb_claim_interface(dev, vsllink_usb_interface);
-	if (ret != 0)
-	{
+	if (ret != 0) {
 		LOG_ERROR("fail to claim interface %d, %d returned",
 				vsllink_usb_interface, ret);
 		return NULL;
@@ -979,17 +938,16 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 {
 	int ret;
 
-	ret = usb_release_interface(vsllink->usb_handle, vsllink_usb_interface);
-	if (ret != 0)
-	{
-		LOG_ERROR("fail to release interface %d, %d returned", \
+	ret = usb_release_interface(vsllink->usb_handle,
+			vsllink_usb_interface);
+	if (ret != 0) {
+		LOG_ERROR("fail to release interface %d, %d returned",
 					vsllink_usb_interface, ret);
 		exit(-1);
 	}
 
 	ret = usb_close(vsllink->usb_handle);
-	if (ret != 0)
-	{
+	if (ret != 0) {
 		LOG_ERROR("fail to close usb, %d returned", ret);
 		exit(-1);
 	}
@@ -998,33 +956,27 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 }
 
 /* Send a message and receive the reply. */
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length,
 								int in_length)
 {
 	int result;
 
 	result = vsllink_usb_write(vsllink, out_length);
-	if (result == out_length)
-	{
-		if (in_length > 0)
-		{
+	if (result == out_length) {
+		if (in_length > 0) {
 			result = vsllink_usb_read(vsllink);
 			if (result == in_length)
-			{
 				return result;
-			}
-			else
-			{
-				LOG_ERROR("usb_bulk_read failed (requested=%d, result=%d)", \
+			else {
+				LOG_ERROR("usb_bulk_read failed "
+					"(requested=%d, result=%d)",
 							in_length, result);
 				return -1;
 			}
 		}
 		return 0;
-	}
-	else
-	{
-		LOG_ERROR("usb_bulk_write failed (requested=%d, result=%d)", \
+	} else {
+		LOG_ERROR("usb_bulk_write failed (requested=%d, result=%d)",
 					out_length, result);
 		return -1;
 	}
@@ -1035,17 +987,17 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 {
 	int result;
 
-	if (out_length > vsllink_buffer_size)
-	{
-		LOG_ERROR("vsllink_write illegal out_length=%d (max=%d)", \
+	if (out_length > vsllink_buffer_size) {
+		LOG_ERROR("vsllink_write illegal out_length=%d (max=%d)",
 					out_length, vsllink_buffer_size);
 		return -1;
 	}
 
-	result = usb_bulk_write(vsllink->usb_handle, vsllink_usb_bulkout, \
-		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
+	result = usb_bulk_write(vsllink->usb_handle, vsllink_usb_bulkout,
+		(char *)vsllink_usb_out_buffer, out_length,
+				VSLLINK_USB_TIMEOUT);
 
-	DEBUG_JTAG_IO("vsllink_usb_write, out_length = %d, result = %d", \
+	DEBUG_JTAG_IO("vsllink_usb_write, out_length = %d, result = %d",
 					out_length, result);
 
 #ifdef _DEBUG_USB_COMMS_
@@ -1063,8 +1015,8 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 /* Read data from USB into in_buffer. */
 static int vsllink_usb_read(struct vsllink *vsllink)
 {
-	int result = usb_bulk_read(vsllink->usb_handle, vsllink_usb_bulkin, \
-		(char *)vsllink_usb_in_buffer, vsllink_buffer_size, \
+	int result = usb_bulk_read(vsllink->usb_handle, vsllink_usb_bulkin,
+		(char *)vsllink_usb_in_buffer, vsllink_buffer_size,
 		VSLLINK_USB_TIMEOUT);
 
 	DEBUG_JTAG_IO("vsllink_usb_read, result = %d", result);
@@ -1086,18 +1038,16 @@ static void vsllink_debug_buffer(uint8_t *buffer, int length)
 	int i;
 	int j;
 
-	for (i = 0; i < length; i += BYTES_PER_LINE)
-	{
+	for (i = 0; i < length; i += BYTES_PER_LINE) {
 		snprintf(line, 5, "%04x", i);
-		for (j = i; j < i + BYTES_PER_LINE && j < length; j++)
-		{
+		for (j = i; j < i + BYTES_PER_LINE && j < length; j++) {
 			snprintf(s, 4, " %02x", buffer[j]);
 			strcat(line, s);
 		}
 		LOG_DEBUG("%s", line);
 	}
 }
-#endif // _DEBUG_USB_COMMS_ || _DEBUG_JTAG_IO_
+#endif /* _DEBUG_USB_COMMS_ || _DEBUG_JTAG_IO_ */
 
 static const struct command_registration vsllink_command_handlers[] = {
 	{

commit db464f3cd4ed83b9f3411a98362dd67aad7bc3fd
Author: simon qian <simonqian.openocd at gmail.com>
Date:   Thu Mar 11 14:11:30 2010 -0800

    New JTAG driver for Versaloon
    
    This patch greatly simplifies the Versaloon driver:
    
     - reducing the code size from more than 50K to less than 28K
     - adding support for IR/DR scan with unlimited size
     - using tap_get_tms_path and tap_get_tms_path_len.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 65c3bf1..451d5f8 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2009 by Simon Qian <SimonQian at SimonQian.com>            *
+ *   Copyright (C) 2009-2010 by Simon Qian <SimonQian at SimonQian.com>       *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -18,7 +18,7 @@
  ***************************************************************************/
 
 /* Versaloon is a programming tool for multiple MCUs.
- * OpenOCD and MSP430 supports are distributed under GPLv2.
+ * It's distributed under GPLv3.
  * You can find it at http://www.SimonQian.com/en/Versaloon.
  */
 
@@ -32,179 +32,85 @@
 
 //#define _VSLLINK_IN_DEBUG_MODE_
 
-#define VSLLINK_MODE_NORMAL			0
-#define VSLLINK_MODE_DMA			1
-
 static uint16_t vsllink_usb_vid;
 static uint16_t vsllink_usb_pid;
-static uint8_t vsllink_usb_bulkout;
-static uint8_t vsllink_usb_bulkin;
-static uint8_t vsllink_usb_interface;
-static uint8_t vsllink_mode = VSLLINK_MODE_NORMAL;
-static int VSLLINK_USB_TIMEOUT = 10000;
+static uint8_t  vsllink_usb_bulkout;
+static uint8_t  vsllink_usb_bulkin;
+static uint8_t  vsllink_usb_interface;
+static int      VSLLINK_USB_TIMEOUT = 1000;
 
-static int VSLLINK_BufferSize = 1024;
+static int vsllink_tms_offset = 0;
 
 /* Global USB buffers */
-static int vsllink_usb_out_buffer_idx;
-static int vsllink_usb_in_want_length;
-static uint8_t* vsllink_usb_in_buffer = NULL;
+static uint8_t* vsllink_usb_in_buffer  = NULL;
 static uint8_t* vsllink_usb_out_buffer = NULL;
+static int      vsllink_buffer_size    = 128;
 
-/* Constants for VSLLink command */
-#define VSLLINK_CMD_CONN			0x80
-#define VSLLINK_CMD_DISCONN			0x81
-#define VSLLINK_CMD_SET_SPEED		0x82
-#define VSLLINK_CMD_SET_PORT		0x90
-#define VSLLINK_CMD_GET_PORT		0x91
-#define VSLLINK_CMD_SET_PORTDIR		0x92
-#define VSLLINK_CMD_HW_JTAGSEQCMD	0xA0
-#define VSLLINK_CMD_HW_JTAGHLCMD	0xA1
-#define VSLLINK_CMD_HW_SWDCMD		0xA2
-#define VSLLINK_CMD_HW_JTAGRAWCMD	0xA3
-
-#define VSLLINK_CMDJTAGSEQ_TMSBYTE	0x00
-#define VSLLINK_CMDJTAGSEQ_TMSCLOCK	0x40
-#define VSLLINK_CMDJTAGSEQ_SCAN		0x80
-
-#define VSLLINK_CMDJTAGSEQ_CMDMSK	0xC0
-#define VSLLINK_CMDJTAGSEQ_LENMSK	0x3F
-
-#define JTAG_PINMSK_SRST			(1 << 0)
-#define JTAG_PINMSK_TRST			(1 << 1)
-#define JTAG_PINMSK_USR1			(1 << 2)
-#define JTAG_PINMSK_USR2			(1 << 3)
-#define JTAG_PINMSK_TCK				(1 << 4)
-#define JTAG_PINMSK_TMS				(1 << 5)
-#define JTAG_PINMSK_TDI				(1 << 6)
-#define JTAG_PINMSK_TDO				(1 << 7)
-
-
-#define VSLLINK_TAP_MOVE(from, to)	VSLLINK_tap_move[tap_move_ndx(from)][tap_move_ndx(to)]
-
-/* VSLLINK_tap_move[i][j]: tap movement command to go from state i to state j
- * 0: Test-Logic-Reset
- * 1: Run-Test/Idle
- * 2: Shift-DR
- * 3: Pause-DR
- * 4: Shift-IR
- * 5: Pause-IR
- *
- * SD->SD and SI->SI have to be caught in interface specific code
- */
-static uint8_t VSLLINK_tap_move[6][6] =
-{
-/*	  TLR   RTI   SD    PD    SI    PI             */
-	{0xff, 0x7f, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
-	{0xff, 0x00, 0x45, 0x05, 0x4b, 0x0b},	/* RTI */
-	{0xff, 0x61, 0x00, 0x01, 0x0f, 0x2f},	/* SD  */
-	{0xfe, 0x60, 0x40, 0x5c, 0x3c, 0x5e},	/* PD  */
-	{0xff, 0x61, 0x07, 0x17, 0x00, 0x01},	/* SI  */
-	{0xfe, 0x60, 0x38, 0x5c, 0x40, 0x5e}	/* PI  */
-};
-
-struct insert_insignificant_operation {
-	unsigned char insert_value;
-	unsigned char insert_position;
-};
-
-static struct insert_insignificant_operation VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[6][6] =
-{
-/*	 stuff	offset   */
-	{/*	TLR	*/
-	{1,		0,},	/* TLR */
-	{1,		0,},	/* RTI */
-	{1,		0,},	/* SD  */
-	{1,		0,},	/* PD  */
-	{1,		0,},	/* SI  */
-	{1,		0,}},	/* PI  */
-	{/*	RTI	*/
-	{1,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		4,},	/* SD  */
-	{0,		7,},	/* PD  */
-	{0,		5,},	/* SI  */
-	{0,		7,}},	/* PI  */
-	{/*	SD	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-	{/*	PD	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-	{/*	SI	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-	{/*	PI	*/
-	{0,		0,},	/* TLR */
-	{0,		0,},	/* RTI */
-	{0,		0,},	/* SD  */
-	{0,		0,},	/* PD  */
-	{0,		0,},	/* SI  */
-	{0,		0,}},	/* PI  */
-};
+/* Constants for Versaloon command */
+#define VERSALOON_GET_INFO				0x00
+#define VERSALOON_GET_TVCC				0x01
 
-static uint8_t VSLLINK_BIT_MSK[8] =
-{
-	0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f
-};
+/* Constants for VSLLink command */
+#define VSLLINK_CMD_CONN				0x80
+#define VSLLINK_CMD_DISCONN				0x81
+#define VSLLINK_CMD_SET_SPEED			0x82
+#define VSLLINK_CMD_SET_PORT			0x90
+#define VSLLINK_CMD_GET_PORT			0x91
+#define VSLLINK_CMD_SET_PORTDIR			0x92
+#define VSLLINK_CMD_HW_JTAGSEQCMD		0xA0
+#define VSLLINK_CMD_HW_JTAGHLCMD		0xA1
+#define VSLLINK_CMD_HW_SWDCMD			0xA2
+#define VSLLINK_CMD_HW_JTAGRAWCMD		0xA3
+
+#define VSLLINK_CMDJTAGSEQ_TMSBYTE		0x00
+#define VSLLINK_CMDJTAGSEQ_TMSCLOCK		0x40
+#define VSLLINK_CMDJTAGSEQ_SCAN			0x80
+
+#define VSLLINK_CMDJTAGSEQ_CMDMSK		0xC0
+#define VSLLINK_CMDJTAGSEQ_LENMSK		0x3F
+
+#define JTAG_PINMSK_SRST				(1 << 0)
+#define JTAG_PINMSK_TRST				(1 << 1)
+#define JTAG_PINMSK_USR1				(1 << 2)
+#define JTAG_PINMSK_USR2				(1 << 3)
+#define JTAG_PINMSK_TCK					(1 << 4)
+#define JTAG_PINMSK_TMS					(1 << 5)
+#define JTAG_PINMSK_TDI					(1 << 6)
+#define JTAG_PINMSK_TDO					(1 << 7)
 
 struct pending_scan_result {
-	int offset;
+	int src_offset;
+	int dest_offset;
 	int length; /* Number of bits to read */
 	struct scan_command *command; /* Corresponding scan command */
 	uint8_t *buffer;
+	bool last; /* indicate the last scan pending */
 };
 
 #define MAX_PENDING_SCAN_RESULTS 256
 
 static int pending_scan_results_length;
-static struct pending_scan_result pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
+static struct pending_scan_result \
+						pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
 
 /* Queue command functions */
 static void vsllink_end_state(tap_state_t state);
-static void vsllink_state_move_dma(void);
-static void vsllink_state_move_normal(void);
-static void (*vsllink_state_move)(void);
-static void vsllink_path_move_dma(int num_states, tap_state_t *path);
-static void vsllink_path_move_normal(int num_states, tap_state_t *path);
-static void (*vsllink_path_move)(int num_states, tap_state_t *path);
+static void vsllink_state_move(void);
+static void vsllink_path_move(int num_states, tap_state_t *path);
 static void vsllink_runtest(int num_cycles);
-static void vsllink_stableclocks_dma(int num_cycles, int tms);
-static void vsllink_stableclocks_normal(int num_cycles, int tms);
-static void (*vsllink_stableclocks)(int num_cycles, int tms);
-static void vsllink_scan_dma(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command);
-static void vsllink_scan_normal(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command);
-static void (*vsllink_scan)(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command);
+static void vsllink_stableclocks(int num_cycles, int tms);
+static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
+							int scan_size, struct scan_command *command);
 static void vsllink_reset(int trst, int srst);
 static void vsllink_simple_command(uint8_t command);
-static int vsllink_connect(void);
-static int vsllink_disconnect(void);
 
 /* VSLLink tap buffer functions */
 static void vsllink_tap_append_step(int tms, int tdi);
-static void vsllink_tap_init_dma(void);
-static void vsllink_tap_init_normal(void);
-static void (*vsllink_tap_init)(void);
-static int vsllink_tap_execute_dma(void);
-static int vsllink_tap_execute_normal(void);
-static int (*vsllink_tap_execute)(void);
-static void vsllink_tap_ensure_space_dma(int scans, int length);
-static void vsllink_tap_ensure_space_normal(int scans, int length);
-static void (*vsllink_tap_ensure_space)(int scans, int length);
-static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, struct scan_command *command);
-static void vsllink_tap_append_scan_normal(int length, uint8_t *buffer, struct scan_command *command, int offset);
+static void vsllink_tap_init(void);
+static int  vsllink_tap_execute(void);
+static void vsllink_tap_ensure_pending(int scans);
+static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
+									struct scan_command *command);
 
 /* VSLLink lowlevel functions */
 struct vsllink {
@@ -213,7 +119,8 @@ struct vsllink {
 
 static struct vsllink *vsllink_usb_open(void);
 static void vsllink_usb_close(struct vsllink *vsllink);
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_length);
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+								int in_length);
 static int vsllink_usb_write(struct vsllink *vsllink, int out_length);
 static int vsllink_usb_read(struct vsllink *vsllink);
 
@@ -221,29 +128,17 @@ static int vsllink_usb_read(struct vsllink *vsllink);
 static void vsllink_debug_buffer(uint8_t *buffer, int length);
 #endif
 
-static int vsllink_tms_data_len = 0;
-static uint8_t* vsllink_tms_cmd_pos;
-
 static int tap_length = 0;
 static int tap_buffer_size = 0;
 static uint8_t *tms_buffer = NULL;
 static uint8_t *tdi_buffer = NULL;
 static uint8_t *tdo_buffer = NULL;
-static int last_tms;
 
 static struct vsllink* vsllink_handle = NULL;
 
 static void reset_command_pointer(void)
 {
-	if (vsllink_mode == VSLLINK_MODE_NORMAL)
-	{
-		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
-		vsllink_usb_out_buffer_idx = 3;
-	}
-	else
-	{
-		tap_length = 0;
-	}
+	tap_length = 0;
 }
 
 static int vsllink_execute_queue(void)
@@ -253,7 +148,9 @@ static int vsllink_execute_queue(void)
 	enum scan_type type;
 	uint8_t *buffer;
 
-	DEBUG_JTAG_IO("--------------------------------- vsllink -------------------------------------");
+	DEBUG_JTAG_IO(	"-------------------------------------"
+					" vsllink "
+					"-------------------------------------");
 
 	reset_command_pointer();
 	while (cmd != NULL)
@@ -261,15 +158,17 @@ static int vsllink_execute_queue(void)
 		switch (cmd->type)
 		{
 			case JTAG_RUNTEST:
-				DEBUG_JTAG_IO("runtest %i cycles, end in %s", cmd->cmd.runtest->num_cycles, \
-					tap_state_name(cmd->cmd.runtest->end_state));
+				DEBUG_JTAG_IO("runtest %i cycles, end in %s", \
+								cmd->cmd.runtest->num_cycles, \
+								tap_state_name(cmd->cmd.runtest->end_state));
 
 				vsllink_end_state(cmd->cmd.runtest->end_state);
 				vsllink_runtest(cmd->cmd.runtest->num_cycles);
 				break;
 
 			case JTAG_STATEMOVE:
-				DEBUG_JTAG_IO("statemove end in %s", tap_state_name(cmd->cmd.statemove->end_state));
+				DEBUG_JTAG_IO("statemove end in %s", \
+								tap_state_name(cmd->cmd.statemove->end_state));
 
 				vsllink_end_state(cmd->cmd.statemove->end_state);
 				vsllink_state_move();
@@ -280,7 +179,8 @@ static int vsllink_execute_queue(void)
 					cmd->cmd.pathmove->num_states, \
 					tap_state_name(cmd->cmd.pathmove->path[cmd->cmd.pathmove->num_states - 1]));
 
-				vsllink_path_move(cmd->cmd.pathmove->num_states, cmd->cmd.pathmove->path);
+				vsllink_path_move(cmd->cmd.pathmove->num_states, \
+									cmd->cmd.pathmove->path);
 				break;
 
 			case JTAG_SCAN:
@@ -289,24 +189,31 @@ static int vsllink_execute_queue(void)
 				scan_size = jtag_build_buffer(cmd->cmd.scan, &buffer);
 				if (cmd->cmd.scan->ir_scan)
 				{
-					DEBUG_JTAG_IO("JTAG Scan write IR(%d bits), end in %s:", scan_size, tap_state_name(cmd->cmd.scan->end_state));
+					DEBUG_JTAG_IO("JTAG Scan write IR(%d bits), end in %s:", \
+									scan_size, \
+									tap_state_name(cmd->cmd.scan->end_state));
 				}
 				else
 				{
-					DEBUG_JTAG_IO("JTAG Scan write DR(%d bits), end in %s:", scan_size, tap_state_name(cmd->cmd.scan->end_state));
+					DEBUG_JTAG_IO("JTAG Scan write DR(%d bits), end in %s:", \
+									scan_size, \
+									tap_state_name(cmd->cmd.scan->end_state));
 				}
 
 #ifdef _DEBUG_JTAG_IO_
-				vsllink_debug_buffer(buffer, (scan_size + 7) >> 3);
+				vsllink_debug_buffer(buffer, DIV_ROUND_UP(scan_size, 8));
 #endif
 
 				type = jtag_scan_type(cmd->cmd.scan);
 
-				vsllink_scan(cmd->cmd.scan->ir_scan, type, buffer, scan_size, cmd->cmd.scan);
+				vsllink_scan(cmd->cmd.scan->ir_scan, type, buffer, \
+								scan_size, cmd->cmd.scan);
 				break;
 
 			case JTAG_RESET:
-				DEBUG_JTAG_IO("reset trst: %i srst %i", cmd->cmd.reset->trst, cmd->cmd.reset->srst);
+				DEBUG_JTAG_IO("reset trst: %i srst %i", \
+								cmd->cmd.reset->trst, \
+								cmd->cmd.reset->srst);
 
 				vsllink_tap_execute();
 
@@ -324,7 +231,8 @@ static int vsllink_execute_queue(void)
 				break;
 
 			case JTAG_STABLECLOCKS:
-				DEBUG_JTAG_IO("add %d clocks", cmd->cmd.stableclocks->num_cycles);
+				DEBUG_JTAG_IO("add %d clocks", \
+								cmd->cmd.stableclocks->num_cycles);
 				switch (tap_get_state())
 				{
 				case TAP_RESET:
@@ -340,15 +248,17 @@ static int vsllink_execute_queue(void)
 					scan_size = 0;
 					break;			/* above stable states are OK */
 				default:
-					 LOG_ERROR("jtag_add_clocks() was called with TAP in non-stable state \"%s\"",
-							 tap_state_name(tap_get_state()));
+					 LOG_ERROR("jtag_add_clocks() in non-stable state \"%s\"",
+								tap_state_name(tap_get_state()));
 					 exit(-1);
 				}
-				vsllink_stableclocks(cmd->cmd.stableclocks->num_cycles, scan_size);
+				vsllink_stableclocks(cmd->cmd.stableclocks->num_cycles, \
+										scan_size);
 				break;
 
 			default:
-				LOG_ERROR("BUG: unknown JTAG command type encountered: %d", cmd->type);
+				LOG_ERROR("BUG: unknown JTAG command type encountered: %d", \
+							cmd->type);
 				exit(-1);
 		}
 		cmd = cmd->next;
@@ -400,8 +310,8 @@ static int vsllink_init(void)
 	int result;
 	char version_str[100];
 
-	vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
-	vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
+	vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
+	vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
 	if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
 	{
 		LOG_ERROR("Not enough memory");
@@ -409,10 +319,10 @@ static int vsllink_init(void)
 	}
 
 	vsllink_handle = vsllink_usb_open();
-
 	if (vsllink_handle == 0)
 	{
-		LOG_ERROR("Can't find USB JTAG Interface! Please check connection and permissions.");
+		LOG_ERROR("Can't find USB JTAG Interface!"\
+					"Please check connection and permissions.");
 		return ERROR_JTAG_INIT_FAILED;
 	}
 	LOG_DEBUG("vsllink found on %04X:%04X", vsllink_usb_vid, vsllink_usb_pid);
@@ -422,14 +332,16 @@ static int vsllink_init(void)
 	check_cnt = 0;
 	while (check_cnt < 5)
 	{
-		vsllink_simple_command(0x00);
+		vsllink_simple_command(VERSALOON_GET_INFO);
 		result = vsllink_usb_read(vsllink_handle);
 
 		if (result > 2)
 		{
 			vsllink_usb_in_buffer[result] = 0;
-			VSLLINK_BufferSize = vsllink_usb_in_buffer[0] + (vsllink_usb_in_buffer[1] << 8);
-			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, sizeof(version_str));
+			vsllink_buffer_size = vsllink_usb_in_buffer[0] + \
+									(vsllink_usb_in_buffer[1] << 8);
+			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+					sizeof(version_str));
 			LOG_INFO("%s", version_str);
 
 			// free the pre-alloc memroy
@@ -439,29 +351,29 @@ static int vsllink_init(void)
 			vsllink_usb_out_buffer = NULL;
 
 			// alloc new memory
-			vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
-			vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
-			if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
+			vsllink_usb_in_buffer = malloc(vsllink_buffer_size);
+			vsllink_usb_out_buffer = malloc(vsllink_buffer_size);
+			if ((vsllink_usb_in_buffer == NULL) || \
+				(vsllink_usb_out_buffer == NULL))
 			{
 				LOG_ERROR("Not enough memory");
 				exit(-1);
 			}
 			else
 			{
-				LOG_INFO("buffer size for USB is %d bytes", VSLLINK_BufferSize);
+				LOG_INFO("buffer size for USB is %d bytes", \
+							vsllink_buffer_size);
 			}
-			// alloc memory for dma mode
-			if (vsllink_mode == VSLLINK_MODE_DMA)
+			// alloc tms/tdi/tdo buffer
+			tap_buffer_size = (vsllink_buffer_size - 3) / 2;
+			tms_buffer = (uint8_t*)malloc(tap_buffer_size);
+			tdi_buffer = (uint8_t*)malloc(tap_buffer_size);
+			tdo_buffer = (uint8_t*)malloc(tap_buffer_size);
+			if ((tms_buffer == NULL) || (tdi_buffer == NULL) || \
+				(tdo_buffer == NULL))
 			{
-				tap_buffer_size = (VSLLINK_BufferSize - 3) / 2;
-				tms_buffer = (uint8_t*)malloc(tap_buffer_size);
-				tdi_buffer = (uint8_t*)malloc(tap_buffer_size);
-				tdo_buffer = (uint8_t*)malloc(tap_buffer_size);
-				if ((tms_buffer == NULL) || (tdi_buffer == NULL) || (tdo_buffer == NULL))
-				{
-					LOG_ERROR("Not enough memory");
-					exit(-1);
-				}
+				LOG_ERROR("Not enough memory");
+				exit(-1);
 			}
 			break;
 		}
@@ -470,7 +382,7 @@ static int vsllink_init(void)
 	}
 	if (check_cnt == 3)
 	{
-		// It's dangerout to proced
+		// Fail to access Versaloon
 		LOG_ERROR("VSLLink initial failed");
 		exit(-1);
 	}
@@ -479,49 +391,33 @@ static int vsllink_init(void)
 	/* Some older firmware versions sometimes fail if the
 	 * voltage isn't read first.
 	 */
-	vsllink_simple_command(0x01);
+	vsllink_simple_command(VERSALOON_GET_TVCC);
 	result = vsllink_usb_read(vsllink_handle);
 	if (result != 2)
-		LOG_WARNING("Fail to get target voltage");
-	else
-		LOG_INFO("Target runs at %d mV", vsllink_usb_in_buffer[0]
-				+ (vsllink_usb_in_buffer[1] << 8));
-
-	// connect to vsllink
-	vsllink_connect();
-	// initialize function pointers
-	if (vsllink_mode == VSLLINK_MODE_NORMAL)
 	{
-		// normal mode
-		vsllink_state_move = vsllink_state_move_normal;
-		vsllink_path_move = vsllink_path_move_normal;
-		vsllink_stableclocks = vsllink_stableclocks_normal;
-		vsllink_scan = vsllink_scan_normal;
-
-		vsllink_tap_init = vsllink_tap_init_normal;
-		vsllink_tap_execute = vsllink_tap_execute_normal;
-		vsllink_tap_ensure_space = vsllink_tap_ensure_space_normal;
-
-		LOG_INFO("vsllink run in NORMAL mode");
+		LOG_WARNING("Fail to get target voltage");
 	}
 	else
 	{
-		// dma mode
-		vsllink_state_move = vsllink_state_move_dma;
-		vsllink_path_move = vsllink_path_move_dma;
-		vsllink_stableclocks = vsllink_stableclocks_dma;
-		vsllink_scan = vsllink_scan_dma;
-
-		vsllink_tap_init = vsllink_tap_init_dma;
-		vsllink_tap_execute = vsllink_tap_execute_dma;
-		vsllink_tap_ensure_space = vsllink_tap_ensure_space_dma;
+		LOG_INFO("Target runs at %d mV", vsllink_usb_in_buffer[0] + \
+					(vsllink_usb_in_buffer[1] << 8));
+	}
 
-		LOG_INFO("vsllink run in DMA mode");
+	// connect to vsllink
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
+	vsllink_usb_out_buffer[1] = 1;
+	vsllink_usb_message(vsllink_handle, 2, 0);
+	if (vsllink_usb_read(vsllink_handle) > 2)
+	{
+		strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, \
+				sizeof(version_str));
+		LOG_INFO("%s", version_str);
 	}
 
 	// Set SRST and TRST to output, Set USR1 and USR2 to input
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
+								JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 	vsllink_usb_out_buffer[2] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
 	if (vsllink_usb_write(vsllink_handle, 3) != 3)
 	{
@@ -531,7 +427,7 @@ static int vsllink_init(void)
 
 	vsllink_reset(0, 0);
 
-	LOG_INFO("VSLLink JTAG Interface ready");
+	LOG_INFO("VSLLink Interface ready");
 
 	vsllink_tap_init();
 
@@ -544,7 +440,8 @@ static int vsllink_quit(void)
 	{
 		// Set all pins to input
 		vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
-		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+		vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | \
+									JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
 		vsllink_usb_out_buffer[2] = 0;
 		if (vsllink_usb_write(vsllink_handle, 3) != 3)
 		{
@@ -553,7 +450,7 @@ static int vsllink_quit(void)
 		}
 
 		// disconnect
-		vsllink_disconnect();
+		vsllink_simple_command(VSLLINK_CMD_DISCONN);
 		vsllink_usb_close(vsllink_handle);
 		vsllink_handle = NULL;
 	}
@@ -574,61 +471,6 @@ static int vsllink_quit(void)
 
 /***************************************************************************/
 /* Queue command implementations */
-static int vsllink_disconnect(void)
-{
-	vsllink_simple_command(VSLLINK_CMD_DISCONN);
-	return ERROR_OK;
-}
-
-static int vsllink_connect(void)
-{
-	char vsllink_str[100];
-
-	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
-	vsllink_usb_out_buffer[1] = vsllink_mode;
-	vsllink_usb_message(vsllink_handle, 2, 0);
-	if (vsllink_usb_read(vsllink_handle) > 2)
-	{
-		strncpy(vsllink_str, (char *)vsllink_usb_in_buffer + 2, sizeof(vsllink_str));
-		LOG_INFO("%s", vsllink_str);
-	}
-
-	return ERROR_OK;
-}
-
-// when vsllink_tms_data_len > 0, vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] is the byte that need to be appended.
-// length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set it here.
-static void vsllink_append_tms(void)
-{
-	uint8_t tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-	uint16_t tms2;
-	struct insert_insignificant_operation *insert = \
-		&VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
-
-	if (((tap_get_state() != TAP_RESET) && (tap_get_state() != TAP_IDLE) && (tap_get_state() != TAP_DRPAUSE) && (tap_get_state() != TAP_IRPAUSE)) || \
-			(vsllink_tms_data_len <= 0) || (vsllink_tms_data_len >= 8) || \
-			(vsllink_tms_cmd_pos == NULL))
-	{
-		LOG_ERROR("There MUST be some bugs in the driver");
-		exit(-1);
-	}
-
-	tms2 = (tms_scan & VSLLINK_BIT_MSK[insert->insert_position]) << \
-				vsllink_tms_data_len;
-	if (insert->insert_value == 1)
-	{
-		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] << \
-				(vsllink_tms_data_len + insert->insert_position);
-	}
-	tms2 |= (tms_scan >> insert->insert_position) << \
-				(8 + insert->insert_position);
-
-	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 >> 0) & 0xff;
-	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 >> 8) & 0xff;
-
-	vsllink_tms_data_len = 0;
-	vsllink_tms_cmd_pos = NULL;
-}
 
 static void vsllink_end_state(tap_state_t state)
 {
@@ -644,482 +486,53 @@ static void vsllink_end_state(tap_state_t state)
 }
 
 /* Goes to the end state. */
-static void vsllink_state_move_normal(void)
+static void vsllink_state_move(void)
 {
-	if (vsllink_tms_data_len > 0)
-	{
-		vsllink_append_tms();
-	}
-	else
-	{
-		vsllink_tap_ensure_space(0, 2);
-
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-	}
-
-	tap_set_state(tap_get_end_state());
-}
-static void vsllink_state_move_dma(void)
-{
-	int i, insert_length = (tap_length % 8) ? (8 - (tap_length % 8)) : 0;
-	struct insert_insignificant_operation *insert = \
-		&VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
-	uint8_t tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-
-	if (tap_get_state() == TAP_RESET)
-	{
-		vsllink_tap_ensure_space(0, 8);
-
-		for (i = 0; i < 8; i++)
-		{
-			vsllink_tap_append_step(1, 0);
-		}
-	}
-
-	if (insert_length > 0)
-	{
-		vsllink_tap_ensure_space(0, 16);
+	int i;
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan_bits = \
+				tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
-		for (i = 0; i < insert->insert_position; i++)
-		{
-			vsllink_tap_append_step((tms_scan >> i) & 1, 0);
-		}
-		for (i = 0; i < insert_length; i++)
-		{
-			vsllink_tap_append_step(insert->insert_value, 0);
-		}
-		for (i = insert->insert_position; i < 8; i++)
-		{
-			vsllink_tap_append_step((tms_scan >> i) & 1, 0);
-		}
-	}
-	else
+	for (i = 0; i < tms_scan_bits; i++)
 	{
-		vsllink_tap_ensure_space(0, 8);
-
-		for (i = 0; i < 8; i++)
-		{
-			vsllink_tap_append_step((tms_scan >> i) & 1, 0);
-		}
+		vsllink_tap_append_step((tms_scan >> i) & 1, 0);
 	}
 
 	tap_set_state(tap_get_end_state());
 }
 
-// write tms from current vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx]
-static void vsllink_add_path(int start, int num, tap_state_t *path)
+static void vsllink_path_move(int num_states, tap_state_t *path)
 {
-	int i;
-
-	for (i = start; i < (start + num); i++)
+	for (int i = 0; i < num_states; i++)
 	{
-		if ((i & 7) == 0)
-		{
-			if (i > 0)
-			{
-				vsllink_usb_out_buffer_idx++;
-			}
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
-		}
-
-		if (path[i - start] == tap_state_transition(tap_get_state(), true))
+		if (path[i] == tap_state_transition(tap_get_state(), false))
 		{
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 << (i & 7);
+			vsllink_tap_append_step(0, 0);
 		}
-		else if (path[i - start] == tap_state_transition(tap_get_state(), false))
+		else if (path[i] == tap_state_transition(tap_get_state(), true))
 		{
-			// nothing to do
+			vsllink_tap_append_step(1, 0);
 		}
 		else
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_name(tap_get_state()), tap_state_name(path[i]));
+			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", \
+						tap_state_name(tap_get_state()), \
+						tap_state_name(path[i]));
 			exit(-1);
 		}
-		tap_set_state(path[i - start]);
-	}
-	if ((i > 0) && ((i & 7) == 0))
-	{
-		vsllink_usb_out_buffer_idx++;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
-	}
 
-	tap_set_end_state(tap_get_state());
-}
-
-static void vsllink_path_move_normal(int num_states, tap_state_t *path)
-{
-	int i, tms_len, tms_cmd_pos, path_idx = 0;
-
-	if (vsllink_tms_data_len > 0)
-	{
-		// there are vsllink_tms_data_len more tms bits to be shifted
-		// so there are vsllink_tms_data_len + num_states tms bits in all
-		tms_len = vsllink_tms_data_len + num_states;
-		if (tms_len <= 16)
-		{
-			// merge into last tms shift
-			if (tms_len < 8)
-			{
-				// just append tms data to the last tms byte
-				vsllink_add_path(vsllink_tms_data_len, num_states, path);
-			}
-			else if (tms_len == 8)
-			{
-				// end last tms shift command
-				(*vsllink_tms_cmd_pos)--;
-				vsllink_add_path(vsllink_tms_data_len, num_states, path);
-			}
-			else if (tms_len < 16)
-			{
-				if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) < VSLLINK_CMDJTAGSEQ_LENMSK)
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// there is enought tms length in the current tms shift command
-					(*vsllink_tms_cmd_pos)++;
-					vsllink_add_path(vsllink_tms_data_len, num_states, path);
-				}
-				else
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// not enough tms length in the current tms shift command
-					// so a new command should be added
-					// first decrease byte length of last tms shift command
-					(*vsllink_tms_cmd_pos)--;
-					// append tms data to the last tms byte
-					vsllink_add_path(vsllink_tms_data_len, 8 - vsllink_tms_data_len, path);
-					path += 8 - vsllink_tms_data_len;
-					// add new command(3 bytes)
-					vsllink_tap_ensure_space(0, 3);
-					vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-					vsllink_add_path(0, num_states - (8 - vsllink_tms_data_len), path);
-				}
-			}
-			else if (tms_len == 16)
-			{
-				// end last tms shift command
-				vsllink_add_path(vsllink_tms_data_len, num_states, path);
-			}
-
-			vsllink_tms_data_len = (vsllink_tms_data_len + num_states) & 7;
-			if (vsllink_tms_data_len == 0)
-			{
-				vsllink_tms_cmd_pos = NULL;
-			}
-			num_states = 0;
-		}
-		else
-		{
-			vsllink_add_path(vsllink_tms_data_len, 16 - vsllink_tms_data_len, path);
-
-			path += 16 - vsllink_tms_data_len;
-			num_states -= 16 - vsllink_tms_data_len;
-			vsllink_tms_data_len = 0;
-			vsllink_tms_cmd_pos = NULL;
-		}
-	}
-
-	if (num_states > 0)
-	{
-		// Normal operation, don't need to append tms data
-		vsllink_tms_data_len = num_states & 7;
-
-		while (num_states > 0)
-		{
-			if (num_states > ((VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8))
-			{
-				i = (VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8;
-			}
-			else
-			{
-				i = num_states;
-			}
-			tms_len = (i + 7) >> 3;
-			vsllink_tap_ensure_space(0, tms_len + 2);
-			tms_cmd_pos = vsllink_usb_out_buffer_idx;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | (tms_len - 1);
-
-			vsllink_add_path(0, i, path + path_idx);
-
-			path_idx += i;
-			num_states -= i;
-		}
-
-		if (vsllink_tms_data_len > 0)
-		{
-			if (tms_len < (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
-			{
-				vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[tms_cmd_pos];
-				(*vsllink_tms_cmd_pos)++;
-			}
-			else
-			{
-				vsllink_usb_out_buffer[tms_cmd_pos]--;
-
-				tms_len = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				vsllink_tap_ensure_space(0, 3);
-				vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = tms_len;
-			}
-		}
-	}
-}
-static void vsllink_path_move_dma(int num_states, tap_state_t *path)
-{
-	int i, j = 0;
-
-	if (tap_length & 7)
-	{
-		if ((8 - (tap_length & 7)) < num_states)
-		{
-			j = 8 - (tap_length & 7);
-		}
-		else
-		{
-			j = num_states;
-		}
-		for (i = 0; i < j; i++)
-		{
-			if (path[i] == tap_state_transition(tap_get_state(), false))
-			{
-				vsllink_tap_append_step(0, 0);
-			}
-			else if (path[i] == tap_state_transition(tap_get_state(), true))
-			{
-				vsllink_tap_append_step(1, 0);
-			}
-			else
-			{
-				LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_name(tap_get_state()), tap_state_name(path[i]));
-				exit(-1);
-			}
-			tap_set_state(path[i]);
-		}
-		num_states -= j;
-	}
-
-	if (num_states > 0)
-	{
-		vsllink_tap_ensure_space(0, num_states);
-
-		for (i = 0; i < num_states; i++)
-		{
-			if (path[j + i] == tap_state_transition(tap_get_state(), false))
-			{
-				vsllink_tap_append_step(0, 0);
-			}
-			else if (path[j + i] == tap_state_transition(tap_get_state(), true))
-			{
-				vsllink_tap_append_step(1, 0);
-			}
-			else
-			{
-				LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition", tap_state_name(tap_get_state()), tap_state_name(path[i]));
-				exit(-1);
-			}
-			tap_set_state(path[j + i]);
-		}
+		tap_set_state(path[i]);
 	}
 
 	tap_set_end_state(tap_get_state());
 }
 
-static void vsllink_stableclocks_normal(int num_cycles, int tms)
+static void vsllink_stableclocks(int num_cycles, int tms)
 {
-	int tms_len;
-	uint16_t tms_append_byte;
-
-	if (vsllink_tms_data_len > 0)
-	{
-		// there are vsllink_tms_data_len more tms bits to be shifted
-		// so there are vsllink_tms_data_len + num_cycles tms bits in all
-		tms_len = vsllink_tms_data_len + num_cycles;
-		if (tms > 0)
-		{
-			// append '1' for tms
-			tms_append_byte = (uint16_t)((((1 << num_cycles) - 1) << vsllink_tms_data_len) & 0xFFFF);
-		}
-		else
-		{
-			// append '0' for tms
-			tms_append_byte = 0;
-		}
-		if (tms_len <= 16)
-		{
-			// merge into last tms shift
-			if (tms_len < 8)
-			{
-				// just add to vsllink_tms_data_len
-				// same result if tun through
-				//vsllink_tms_data_len += num_cycles;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= (uint8_t)(tms_append_byte & 0xFF);
-			}
-			else if (tms_len == 8)
-			{
-				// end last tms shift command
-				// just reduce it, and append last tms byte
-				(*vsllink_tms_cmd_pos)--;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte & 0xFF);
-			}
-			else if (tms_len < 16)
-			{
-				if ((*vsllink_tms_cmd_pos & VSLLINK_CMDJTAGSEQ_LENMSK) < VSLLINK_CMDJTAGSEQ_LENMSK)
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// there is enought tms length in the current tms shift command
-					// increase the tms byte length by 1 and set the last byte to 0
-					(*vsllink_tms_cmd_pos)++;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte & 0xFF);
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (uint8_t)(tms_append_byte >> 8);
-				}
-				else
-				{
-					// every tms shift command can contain VSLLINK_CMDJTAGSEQ_LENMSK + 1 bytes in most
-					// not enough tms length in the current tms shift command
-					// so a new command should be added
-					// first decrease byte length of last tms shift command
-					(*vsllink_tms_cmd_pos)--;
-					// append last tms byte and move the command pointer to the next empty position
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte & 0xFF);
-					// add new command(3 bytes)
-					vsllink_tap_ensure_space(0, 3);
-					vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (uint8_t)(tms_append_byte >> 8);
-				}
-			}
-			else if (tms_len == 16)
-			{
-				// end last tms shift command
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte & 0xFF);
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (uint8_t)(tms_append_byte >> 8);
-			}
-
-			vsllink_tms_data_len = tms_len & 7;
-			if (vsllink_tms_data_len == 0)
-			{
-				vsllink_tms_cmd_pos = NULL;
-			}
-			num_cycles = 0;
-		}
-		else
-		{
-			// more shifts will be needed
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte & 0xFF);
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (uint8_t)(tms_append_byte >> 8);
-
-			num_cycles -= 16 - vsllink_tms_data_len;
-			vsllink_tms_data_len = 0;
-			vsllink_tms_cmd_pos = NULL;
-		}
-	}
-	// from here vsllink_tms_data_len == 0 or num_cycles == 0
-
-	if (vsllink_tms_data_len > 0)
-	{
-		// num_cycles == 0
-		// no need to shift
-		if (num_cycles > 0)
-		{
-			LOG_ERROR("There MUST be some bugs in the driver");
-			exit(-1);
-		}
-	}
-	else
-	{
-		// get number of bytes left to be sent
-		tms_len = num_cycles >> 3;
-		if (tms_len > 0)
-		{
-			vsllink_tap_ensure_space(1, 5);
-			// if tms_len > 0, vsllink_tms_data_len == 0
-			// so just add new command
-			// LSB of the command byte is the tms value when do the shifting
-			if (tms > 0)
-			{
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSCLOCK | 1;
-			}
-			else
-			{
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSCLOCK;
-			}
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 0) & 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 8) & 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 16) & 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len >> 24) & 0xff;
-
-			vsllink_usb_in_want_length += 1;
-			pending_scan_results_buffer[pending_scan_results_length].buffer = NULL;
-			pending_scan_results_length++;
-
-			if (tms_len > 0xFFFF)
-			{
-				vsllink_tap_execute();
-			}
-		}
-
-		// post-process
-		vsllink_tms_data_len = num_cycles & 7;
-		if (vsllink_tms_data_len > 0)
-		{
-			vsllink_tap_ensure_space(0, 3);
-			vsllink_tms_cmd_pos = &vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-			if (tms > 0)
-			{
-				// append '1' for tms
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (1 << vsllink_tms_data_len) - 1;
-			}
-			else
-			{
-				// append '0' for tms
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0x00;
-			}
-		}
-	}
-}
-static void vsllink_stableclocks_dma(int num_cycles, int tms)
-{
-	int i, cur_cycles;
-
-	if (tap_length & 7)
-	{
-		if ((8 - (tap_length & 7)) < num_cycles)
-		{
-			cur_cycles = 8 - (tap_length & 7);
-		}
-		else
-		{
-			cur_cycles = num_cycles;
-		}
-		for (i = 0; i < cur_cycles; i++)
-		{
-			vsllink_tap_append_step(tms, 0);
-		}
-		num_cycles -= cur_cycles;
-	}
-
 	while (num_cycles > 0)
 	{
-		if (num_cycles > 8 * tap_buffer_size)
-		{
-			cur_cycles = 8 * tap_buffer_size;
-		}
-		else
-		{
-			cur_cycles = num_cycles;
-		}
-
-		vsllink_tap_ensure_space(0, cur_cycles);
-
-		for (i = 0; i < cur_cycles; i++)
-		{
-			vsllink_tap_append_step(tms, 0);
-		}
-
-		num_cycles -= cur_cycles;
+		vsllink_tap_append_step(tms, 0);
+		num_cycles--;
 	}
 }
 
@@ -1139,150 +552,36 @@ static void vsllink_runtest(int num_cycles)
 	// post-process
 	// set end_state
 	vsllink_end_state(saved_end_state);
-	tap_set_state(TAP_IDLE);
-	if (tap_get_end_state() != TAP_IDLE)
+	if (tap_get_end_state() != tap_get_end_state())
 	{
 		vsllink_state_move();
 	}
 }
 
-static void vsllink_scan_normal(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command)
+static void vsllink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, \
+							int scan_size, struct scan_command *command)
 {
 	tap_state_t saved_end_state;
-	uint8_t bits_left, tms_tmp, tdi_len;
-	int i;
-
-	if (0 == scan_size)
-	{
-		return;
-	}
-
-	tdi_len = ((scan_size + 7) >> 3);
-	if ((tdi_len + 7) > VSLLINK_BufferSize)
-	{
-		LOG_ERROR("Your implementation of VSLLink has not enough buffer");
-		exit(-1);
-	}
 
 	saved_end_state = tap_get_end_state();
 
 	/* Move to appropriate scan state */
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
 
-	if (vsllink_tms_data_len > 0)
-	{
-		if (tap_get_state() == tap_get_end_state())
-		{
-			// already in IRSHIFT or DRSHIFT state
-			// merge tms data in the last tms shift command into next scan command
-			if (*vsllink_tms_cmd_pos < 1)
-			{
-				LOG_ERROR("There MUST be some bugs in the driver");
-				exit(-1);
-			}
-			else if (*vsllink_tms_cmd_pos < 2)
-			{
-				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				vsllink_usb_out_buffer_idx--;
-			}
-			else
-			{
-				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
-				*vsllink_tms_cmd_pos -= 2;
-			}
-
-			vsllink_tap_ensure_space(1, tdi_len + 7);
-			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid
-			// which is merged from the last tms shift command
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) >> 0) & 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) >> 8) & 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = tms_tmp;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[0] << (8 - vsllink_tms_data_len);
-
-			for (i = 0; i < tdi_len; i++)
-			{
-				buffer[i] >>= 8 - vsllink_tms_data_len;
-				if (i != tdi_len)
-				{
-					buffer[i] += buffer[i + 1] << vsllink_tms_data_len;
-				}
-			}
-
-			vsllink_tap_append_scan_normal(scan_size - vsllink_tms_data_len, buffer, command, vsllink_tms_data_len);
-			scan_size -= 8 - vsllink_tms_data_len;
-			vsllink_tms_data_len = 0;
-		}
-		else
-		{
-			vsllink_state_move();
-			vsllink_tap_ensure_space(1, tdi_len + 5);
-
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len >> 0) & 0xff;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len >> 8) & 0xff;
-
-			vsllink_tap_append_scan_normal(scan_size, buffer, command, 0);
-		}
-	}
-	else
-	{
-		vsllink_tap_ensure_space(1, tdi_len + 7);
-
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) >> 0) & 0xff;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)>> 8) & 0xff;
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-
-		vsllink_tap_append_scan_normal(scan_size, buffer, command, 8);
-	}
-	vsllink_end_state(saved_end_state);
-
-	bits_left = scan_size & 0x07;
-	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
-
-	if (bits_left > 0)
-	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 << (bits_left - 1);
-	}
-	else
-	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 << 7;
-	}
-
 	if (tap_get_state() != tap_get_end_state())
 	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-	}
-	else
-	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+		vsllink_state_move();
 	}
-
-	tap_set_state(tap_get_end_state());
-}
-static void vsllink_scan_dma(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, struct scan_command *command)
-{
-	tap_state_t saved_end_state;
-
-	saved_end_state = tap_get_end_state();
-
-	/* Move to appropriate scan state */
-	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
-
-	vsllink_state_move();
 	vsllink_end_state(saved_end_state);
 
 	/* Scan */
-	vsllink_tap_append_scan_dma(scan_size, buffer, command);
+	vsllink_tap_append_scan(scan_size, buffer, command);
+
+	/* Goto Pause and record position to insert tms:0 */
+	vsllink_tap_append_step(0, 0);
+	vsllink_tms_offset = tap_length;
 
 	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
-	while (tap_length % 8 != 0)
-	{
-		// more 0s in Pause
-		vsllink_tap_append_step(0, 0);
-	}
 
 	if (tap_get_state() != tap_get_end_state())
 	{
@@ -1334,21 +633,8 @@ static void vsllink_simple_command(uint8_t command)
 COMMAND_HANDLER(vsllink_handle_mode_command)
 {
 	if (CMD_ARGC != 1) {
-		LOG_ERROR("parameter error, should be one parameter for VID");
-		return ERROR_FAIL;
-	}
-
-	if (!strcmp(CMD_ARGV[0], "normal"))
-	{
-		vsllink_mode = VSLLINK_MODE_NORMAL;
-	}
-	else if (!strcmp(CMD_ARGV[0], "dma"))
-	{
-		vsllink_mode = VSLLINK_MODE_DMA;
-	}
-	else
-	{
-		LOG_ERROR("invalid vsllink_mode: %s", CMD_ARGV[0]);
+		LOG_ERROR("parameter error, "
+					"should be one parameter for mode");
 		return ERROR_FAIL;
 	}
 
@@ -1359,7 +645,8 @@ COMMAND_HANDLER(vsllink_handle_usb_vid_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR("parameter error, should be one parameter for VID");
+		LOG_ERROR("parameter error, "
+					"should be one parameter for VID");
 		return ERROR_OK;
 	}
 
@@ -1371,7 +658,8 @@ COMMAND_HANDLER(vsllink_handle_usb_pid_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR("parameter error, should be one parameter for PID");
+		LOG_ERROR("parameter error, "
+					"should be one parameter for PID");
 		return ERROR_OK;
 	}
 	COMMAND_PARSE_NUMBER(u16, CMD_ARGV[0], vsllink_usb_pid);
@@ -1382,7 +670,8 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkin_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR("parameter error, should be one parameter for BULKIN endpoint");
+		LOG_ERROR("parameter error, "
+					"should be one parameter for BULKIN endpoint");
 		return ERROR_OK;
 	}
 
@@ -1397,7 +686,8 @@ COMMAND_HANDLER(vsllink_handle_usb_bulkout_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR("parameter error, should be one parameter for BULKOUT endpoint");
+		LOG_ERROR("parameter error, "
+					"should be one parameter for BULKOUT endpoint");
 		return ERROR_OK;
 	}
 
@@ -1412,7 +702,8 @@ COMMAND_HANDLER(vsllink_handle_usb_interface_command)
 {
 	if (CMD_ARGC != 1)
 	{
-		LOG_ERROR("parameter error, should be one parameter for interface number");
+		LOG_ERROR("parameter error, "
+					"should be one parameter for interface number");
 		return ERROR_OK;
 	}
 
@@ -1423,34 +714,19 @@ COMMAND_HANDLER(vsllink_handle_usb_interface_command)
 /***************************************************************************/
 /* VSLLink tap functions */
 
-static void vsllink_tap_init_normal(void)
-{
-	vsllink_usb_out_buffer_idx = 0;
-	vsllink_usb_in_want_length = 0;
-	pending_scan_results_length = 0;
-}
-static void vsllink_tap_init_dma(void)
+static void vsllink_tap_init(void)
 {
 	tap_length = 0;
 	pending_scan_results_length = 0;
+	vsllink_tms_offset = 0;
 }
 
-static void vsllink_tap_ensure_space_normal(int scans, int length)
-{
-	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
-	int available_bytes = VSLLINK_BufferSize - vsllink_usb_out_buffer_idx;
-
-	if (scans > available_scans || length > available_bytes)
-	{
-		vsllink_tap_execute();
-	}
-}
-static void vsllink_tap_ensure_space_dma(int scans, int length)
+static void vsllink_tap_ensure_pending(int scans)
 {
-	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
-	int available_bytes = tap_buffer_size * 8 - tap_length;
+	int available_scans = \
+			MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 
-	if (scans > available_scans || length > available_bytes)
+	if (scans > available_scans)
 	{
 		vsllink_tap_execute();
 	}
@@ -1458,66 +734,38 @@ static void vsllink_tap_ensure_space_dma(int scans, int length)
 
 static void vsllink_tap_append_step(int tms, int tdi)
 {
-	last_tms = tms;
 	int index = tap_length / 8;
 
-	if (index < tap_buffer_size)
-	{
-		int bit_index = tap_length % 8;
-		uint8_t bit = 1 << bit_index;
-
-		if (tms)
-		{
-			tms_buffer[index] |= bit;
-		}
-		else
-		{
-			tms_buffer[index] &= ~bit;
-		}
+	int bit_index = tap_length % 8;
+	uint8_t bit = 1 << bit_index;
 
-		if (tdi)
-		{
-			tdi_buffer[index] |= bit;
-		}
-		else
-		{
-			tdi_buffer[index] &= ~bit;
-		}
-
-		tap_length++;
+	if (tms)
+	{
+		tms_buffer[index] |= bit;
 	}
 	else
 	{
-		LOG_ERROR("buffer overflow, tap_length=%d", tap_length);
+		tms_buffer[index] &= ~bit;
 	}
-}
 
-static void vsllink_tap_append_scan_normal(int length, uint8_t *buffer, struct scan_command *command, int offset)
-{
-	struct pending_scan_result *pending_scan_result = &pending_scan_results_buffer[pending_scan_results_length];
-	int i;
-
-	if (offset > 0)
+	if (tdi)
 	{
-		vsllink_usb_in_want_length += ((length + 7) >> 3) + 1;
+		tdi_buffer[index] |= bit;
 	}
 	else
 	{
-		vsllink_usb_in_want_length += (length + 7) >> 3;
+		tdi_buffer[index] &= ~bit;
 	}
-	pending_scan_result->length = length;
-	pending_scan_result->offset = offset;
-	pending_scan_result->command = command;
-	pending_scan_result->buffer = buffer;
 
-	for (i = 0; i < ((length + 7) >> 3); i++)
+	tap_length++;
+	if (tap_buffer_size * 8 <= tap_length)
 	{
-		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[i];
+		vsllink_tap_execute();
 	}
-
-	pending_scan_results_length++;
 }
-static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, struct scan_command *command)
+
+static void vsllink_tap_append_scan(int length, uint8_t *buffer, \
+										struct scan_command *command)
 {
 	struct pending_scan_result *pending_scan_result;
 	int len_tmp, len_all, i;
@@ -1525,164 +773,140 @@ static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, struct scan
 	len_all = 0;
 	while (len_all < length)
 	{
-		if ((length - len_all) > tap_buffer_size * 8)
+		vsllink_tap_ensure_pending(1);
+		pending_scan_result = \
+				&pending_scan_results_buffer[pending_scan_results_length];
+
+		if ((length - len_all) > (tap_buffer_size * 8 - tap_length))
 		{
-			len_tmp = tap_buffer_size * 8;
+			/* Use all memory available 
+			   vsllink_tap_append_step will commit automatically */
+			len_tmp = tap_buffer_size * 8 - tap_length;
+			pending_scan_result->last = false;
 		}
 		else
 		{
 			len_tmp = length - len_all;
+			pending_scan_result->last = true;
 		}
-
-		vsllink_tap_ensure_space(1, (len_tmp + 7) & ~7);
-
-		pending_scan_result = &pending_scan_results_buffer[pending_scan_results_length];
-		pending_scan_result->offset = tap_length;
+		pending_scan_result->src_offset = tap_length;
+		pending_scan_result->dest_offset = len_all;
 		pending_scan_result->length = len_tmp;
 		pending_scan_result->command = command;
-		pending_scan_result->buffer = buffer + len_all / 8;
+		pending_scan_result->buffer = buffer;
+		pending_scan_results_length++;
 
 		for (i = 0; i < len_tmp; i++)
 		{
-			vsllink_tap_append_step(((len_all + i) < length-1 ? 0 : 1), (buffer[(len_all + i)/8] >> ((len_all + i)%8)) & 1);
+			vsllink_tap_append_step(((len_all + i) < length-1 ? 0 : 1), \
+						(buffer[(len_all + i)/8] >> ((len_all + i)%8)) & 1);
 		}
 
-		pending_scan_results_length++;
 		len_all += len_tmp;
 	}
 }
 
-/* Pad and send a tap sequence to the device, and receive the answer.
- * For the purpose of padding we assume that we are in reset or idle or pause state. */
-static int vsllink_tap_execute_normal(void)
+static int vsllink_tap_execute(void)
 {
+	int byte_length;
 	int i;
 	int result;
-	int first = 0;
 
-	if (vsllink_tms_data_len > 0)
+	if (tap_length <= 0)
 	{
-		if ((tap_get_state() != TAP_RESET) && (tap_get_state() != TAP_IDLE) && (tap_get_state() != TAP_IRPAUSE) && (tap_get_state() != TAP_DRPAUSE))
-		{
-			LOG_WARNING("%s is not in RESET or IDLE or PAUSR state", tap_state_name(tap_get_state()));
-		}
-
-		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] & (1 << (vsllink_tms_data_len - 1)))
-		{
-			// last tms bit is '1'
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= 0xFF << vsllink_tms_data_len;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0xFF;
-			vsllink_tms_data_len = 0;
-		}
-		else
-		{
-			// last tms bit is '0'
-			vsllink_usb_out_buffer_idx++;
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-			vsllink_tms_data_len = 0;
-		}
+		return ERROR_OK;
 	}
 
-	if (vsllink_usb_out_buffer_idx > 3)
+	/* Pad data so that tap_length is divisible by 8 */
+	if ((tap_length % 8) != 0)
 	{
-		if (vsllink_usb_out_buffer[0] == VSLLINK_CMD_HW_JTAGSEQCMD)
+		if (vsllink_tms_offset > 0)
 		{
-			vsllink_usb_out_buffer[1] = (vsllink_usb_out_buffer_idx >> 0) & 0xff;
-			vsllink_usb_out_buffer[2] = (vsllink_usb_out_buffer_idx >> 8) & 0xff;
-		}
+			/* append tms:0 at vsllink_tms_offset, which is in Pause */
+			int start_pos = DIV_ROUND_UP(tap_length, 8) - 1;
+			int end_pos = DIV_ROUND_UP(vsllink_tms_offset, 8) - 1;
+			int shift_cnt = (start_pos + 1) * 8 - tap_length;
+			uint8_t last_mask = ~((1 << (vsllink_tms_offset % 8)) - 1);
 
-		result = vsllink_usb_message(vsllink_handle, vsllink_usb_out_buffer_idx, vsllink_usb_in_want_length);
-
-		if (result == vsllink_usb_in_want_length)
-		{
-			for (i = 0; i < pending_scan_results_length; i++)
+			while (1)
 			{
-				struct pending_scan_result *pending_scan_result = &pending_scan_results_buffer[i];
-				uint8_t *buffer = pending_scan_result->buffer;
-				int length = pending_scan_result->length;
-				int offset = pending_scan_result->offset;
-				struct scan_command *command = pending_scan_result->command;
-
-				if (buffer != NULL)
+				if (start_pos == end_pos)
 				{
-					// IRSHIFT or DRSHIFT
-					buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
-					first += (length + offset + 7) >> 3;
-
-					DEBUG_JTAG_IO("JTAG scan read(%d bits):", length);
-#ifdef _DEBUG_JTAG_IO_
-					vsllink_debug_buffer(buffer, (length + 7) >> 3);
-#endif
-
-					if (jtag_read_buffer(buffer, command) != ERROR_OK)
-					{
-						vsllink_tap_init();
-						return ERROR_JTAG_QUEUE_FAILED;
-					}
-
-					free(pending_scan_result->buffer);
-					pending_scan_result->buffer = NULL;
+					tms_buffer[start_pos] = \
+								(tms_buffer[start_pos] & ~last_mask) | \
+								((tms_buffer[start_pos] & last_mask) << shift_cnt);
+					tdi_buffer[start_pos] = \
+								(tdi_buffer[start_pos] & ~last_mask) | \
+								((tdi_buffer[start_pos] & last_mask) << shift_cnt);
+					break;
+				}
+				else if (start_pos == (end_pos + 1))
+				{
+					tms_buffer[start_pos] = \
+						(tms_buffer[start_pos] << shift_cnt) | \
+						((tms_buffer[start_pos - 1] & last_mask) >> (8 - shift_cnt));
+					tdi_buffer[start_pos] = \
+						(tdi_buffer[start_pos] << shift_cnt) | \
+						((tdi_buffer[start_pos - 1] & last_mask) >> (8 - shift_cnt));
 				}
 				else
 				{
-					first++;
+					tms_buffer[start_pos] = \
+						(tms_buffer[start_pos] << shift_cnt) | \
+						(tms_buffer[start_pos - 1] >> (8 - shift_cnt));
+					tdi_buffer[start_pos] = \
+						(tdi_buffer[start_pos] << shift_cnt) | \
+						(tdi_buffer[start_pos - 1] >> (8 - shift_cnt));
 				}
+				start_pos--;
 			}
+			tap_length = DIV_ROUND_UP(tap_length, 8) * 8;
 		}
 		else
 		{
-			LOG_ERROR("vsllink_tap_execute, wrong result %d, expected %d", result, vsllink_usb_in_want_length);
-			return ERROR_JTAG_QUEUE_FAILED;
+			/* append data at last */
+			while ((tap_length % 8) != 0)
+			{
+				vsllink_tap_append_step((tap_get_state() == TAP_RESET)?1:0, 0);
+			}
 		}
-
-		vsllink_tap_init();
 	}
-	reset_command_pointer();
-
-	return ERROR_OK;
-}
-static int vsllink_tap_execute_dma(void)
-{
-	int byte_length;
-	int i;
-	int result;
+	byte_length = tap_length / 8;
 
-	if (tap_length > 0)
-	{
-		/* Pad last byte so that tap_length is divisible by 8 */
-		while (tap_length % 8 != 0)
-		{
-			/* More of the last TMS value keeps us in the same state,
-			 * analogous to free-running JTAG interfaces. */
-			vsllink_tap_append_step(last_tms, 0);
-		}
-		byte_length = tap_length / 8;
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGRAWCMD;
+	vsllink_usb_out_buffer[1] = ((byte_length * 2 + 3) >> 0) & 0xff;
+	vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) >> 8) & 0xff;
 
-		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGRAWCMD;
-		vsllink_usb_out_buffer[1] = ((byte_length * 2 + 3) >> 0) & 0xff;		// package size
-		vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) >> 8) & 0xff;
+	memcpy(&vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
+	memcpy(&vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
 
-		memcpy(&vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
-		memcpy(&vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
+	result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length, \
+									byte_length);
 
-		result = vsllink_usb_message(vsllink_handle, 3 + 2 * byte_length, byte_length);
-		if (result == byte_length)
+	if (result == byte_length)
+	{
+		for (i = 0; i < pending_scan_results_length; i++)
 		{
-			for (i = 0; i < pending_scan_results_length; i++)
-			{
-				struct pending_scan_result *pending_scan_result = &pending_scan_results_buffer[i];
-				uint8_t *buffer = pending_scan_result->buffer;
-				int length = pending_scan_result->length;
-				int first = pending_scan_result->offset;
-
-				struct scan_command *command = pending_scan_result->command;
-				buf_set_buf(vsllink_usb_in_buffer, first, buffer, 0, length);
-
-				DEBUG_JTAG_IO("JTAG scan read(%d bits, from %d bits):", length, first);
+			struct pending_scan_result *pending_scan_result = \
+											&pending_scan_results_buffer[i];
+			uint8_t *buffer = pending_scan_result->buffer;
+			int length = pending_scan_result->length;
+			int src_first = pending_scan_result->src_offset;
+			int dest_first = pending_scan_result->dest_offset;
+			bool last = pending_scan_result->last;
+
+			struct scan_command *command = pending_scan_result->command;
+			buf_set_buf(vsllink_usb_in_buffer, src_first, buffer, \
+							dest_first, length);
+
+			DEBUG_JTAG_IO("JTAG scan read(%d bits, from %d bits):", \
+							length, dest_first);
 #ifdef _DEBUG_JTAG_IO_
-				vsllink_debug_buffer(buffer, (length + 7) >> 3);
+			vsllink_debug_buffer(buffer + dest_first / 8, DIV_ROUND_UP(length, 7));
 #endif
 
+			if (last)
+			{
 				if (jtag_read_buffer(buffer, command) != ERROR_OK)
 				{
 					vsllink_tap_init();
@@ -1695,14 +919,15 @@ static int vsllink_tap_execute_dma(void)
 				}
 			}
 		}
-		else
-		{
-			LOG_ERROR("vsllink_tap_execute, wrong result %d, expected %d", result, byte_length);
-			return ERROR_JTAG_QUEUE_FAILED;
-		}
-
-		vsllink_tap_init();
 	}
+	else
+	{
+		LOG_ERROR("vsllink_tap_execute, wrong result %d, expected %d", \
+					result, byte_length);
+		return ERROR_JTAG_QUEUE_FAILED;
+	}
+
+	vsllink_tap_init();
 
 	return ERROR_OK;
 }
@@ -1757,7 +982,8 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 	ret = usb_release_interface(vsllink->usb_handle, vsllink_usb_interface);
 	if (ret != 0)
 	{
-		LOG_ERROR("fail to release interface %d, %d returned", vsllink_usb_interface, ret);
+		LOG_ERROR("fail to release interface %d, %d returned", \
+					vsllink_usb_interface, ret);
 		exit(-1);
 	}
 
@@ -1772,7 +998,8 @@ static void vsllink_usb_close(struct vsllink *vsllink)
 }
 
 /* Send a message and receive the reply. */
-static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_length)
+static int vsllink_usb_message(struct vsllink *vsllink, int out_length, \
+								int in_length)
 {
 	int result;
 
@@ -1788,7 +1015,8 @@ static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_l
 			}
 			else
 			{
-				LOG_ERROR("usb_bulk_read failed (requested=%d, result=%d)", in_length, result);
+				LOG_ERROR("usb_bulk_read failed (requested=%d, result=%d)", \
+							in_length, result);
 				return -1;
 			}
 		}
@@ -1796,7 +1024,8 @@ static int vsllink_usb_message(struct vsllink *vsllink, int out_length, int in_l
 	}
 	else
 	{
-		LOG_ERROR("usb_bulk_write failed (requested=%d, result=%d)", out_length, result);
+		LOG_ERROR("usb_bulk_write failed (requested=%d, result=%d)", \
+					out_length, result);
 		return -1;
 	}
 }
@@ -1806,16 +1035,18 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 {
 	int result;
 
-	if (out_length > VSLLINK_BufferSize)
+	if (out_length > vsllink_buffer_size)
 	{
-		LOG_ERROR("vsllink_write illegal out_length=%d (max=%d)", out_length, VSLLINK_BufferSize);
+		LOG_ERROR("vsllink_write illegal out_length=%d (max=%d)", \
+					out_length, vsllink_buffer_size);
 		return -1;
 	}
 
 	result = usb_bulk_write(vsllink->usb_handle, vsllink_usb_bulkout, \
 		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
 
-	DEBUG_JTAG_IO("vsllink_usb_write, out_length = %d, result = %d", out_length, result);
+	DEBUG_JTAG_IO("vsllink_usb_write, out_length = %d, result = %d", \
+					out_length, result);
 
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG("USB out:");
@@ -1833,7 +1064,8 @@ static int vsllink_usb_write(struct vsllink *vsllink, int out_length)
 static int vsllink_usb_read(struct vsllink *vsllink)
 {
 	int result = usb_bulk_read(vsllink->usb_handle, vsllink_usb_bulkin, \
-		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize, VSLLINK_USB_TIMEOUT);
+		(char *)vsllink_usb_in_buffer, vsllink_buffer_size, \
+		VSLLINK_USB_TIMEOUT);
 
 	DEBUG_JTAG_IO("vsllink_usb_read, result = %d", result);
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/vsllink.c | 1680 ++++++++++++--------------------------------
 1 files changed, 431 insertions(+), 1249 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Mar 12 01:58:07 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 12 Mar 2010 00:58:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-78-g763013f
Message-ID: <E1NptCa-0005QQ-Nr@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  763013f15e348d760e193da807c5bd79437ab8c7 (commit)
      from  03a26d31e991976ff978c8c9b245210f116f6ece (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 763013f15e348d760e193da807c5bd79437ab8c7
Author: Mike Dunn <mikedunn at newsguy.com>
Date:   Thu Mar 11 16:53:05 2010 -0800

    fix xscale icache and dcache commands
    
    Simple patch that fixes the broken xscale icache and dcache commands.
    This broke when the helper functions and macros were changed.
    
    [ dbrownell at users.sourceforge.net: don't use strcasecmp ]
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index 602034e..50c9595 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3197,9 +3197,9 @@ COMMAND_HANDLER(xscale_handle_idcache_command)
 		return ERROR_OK;
 	}
 
-	bool icache;
-	COMMAND_PARSE_BOOL(CMD_NAME, icache, "icache", "dcache");
-
+	bool icache = false;
+	if (strcmp(CMD_NAME, "icache") == 0)
+		icache = true;
 	if (CMD_ARGC >= 1)
 	{
 		bool enable;

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Mar 14 21:22:04 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 14 Mar 2010 20:22:04 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-80-gc25fda2
Message-ID: <E1NquK6-0000yG-AF@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c25fda2c95f130d758c7784277fe5f2693ff3dd4 (commit)
       via  c23d4596d2239bdbba080499de837f53e0c89e59 (commit)
      from  763013f15e348d760e193da807c5bd79437ab8c7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c25fda2c95f130d758c7784277fe5f2693ff3dd4
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Mar 14 13:13:39 2010 -0700

    rename jtag_interface_{init,quit}()
    
    These routines apply to non-JTAG debug adapters too.  To
    reduce confusion, give them better (non-misleading) names.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 706f2f2..e7cb48d 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1346,7 +1346,11 @@ void jtag_tap_free(struct jtag_tap *tap)
 	free(tap);
 }
 
-int jtag_interface_init(struct command_context *cmd_ctx)
+/**
+ * Do low-level setup like initializing registers, output signals,
+ * and clocking.
+ */
+int adapter_init(struct command_context *cmd_ctx)
 {
 	if (jtag)
 		return ERROR_OK;
@@ -1354,7 +1358,8 @@ int jtag_interface_init(struct command_context *cmd_ctx)
 	if (!jtag_interface)
 	{
 		/* nothing was previously specified by "interface" command */
-		LOG_ERROR("JTAG interface has to be specified, see \"interface\" command");
+		LOG_ERROR("Debug Adapter has to be specified, "
+			"see \"interface\" command");
 		return ERROR_JTAG_INVALID_INTERFACE;
 	}
 
@@ -1369,9 +1374,10 @@ int jtag_interface_init(struct command_context *cmd_ctx)
 	int actual_khz = requested_khz;
 	int retval = jtag_get_speed_readable(&actual_khz);
 	if (ERROR_OK != retval)
-		LOG_INFO("interface specific clock speed value %d", jtag_get_speed());
+		LOG_INFO("adapter-specific clock speed value %d", jtag_get_speed());
 	else if (actual_khz)
 	{
+		/* Adaptive clocking -- JTAG-specific */
 		if ((CLOCK_MODE_RCLK == clock_mode)
 			|| ((CLOCK_MODE_KHZ == clock_mode) && !requested_khz))
 		{
@@ -1459,7 +1465,7 @@ int jtag_init_inner(struct command_context *cmd_ctx)
 	return ERROR_OK;
 }
 
-int jtag_interface_quit(void)
+int adapter_quit(void)
 {
 	if (!jtag || !jtag->quit)
 		return ERROR_OK;
@@ -1477,7 +1483,7 @@ int jtag_init_reset(struct command_context *cmd_ctx)
 {
 	int retval;
 
-	if ((retval = jtag_interface_init(cmd_ctx)) != ERROR_OK)
+	if ((retval = adapter_init(cmd_ctx)) != ERROR_OK)
 		return retval;
 
 	LOG_DEBUG("Initializing with hard TRST+SRST reset");
@@ -1531,7 +1537,7 @@ int jtag_init(struct command_context *cmd_ctx)
 {
 	int retval;
 
-	if ((retval = jtag_interface_init(cmd_ctx)) != ERROR_OK)
+	if ((retval = adapter_init(cmd_ctx)) != ERROR_OK)
 		return retval;
 
 	/* guard against oddball hardware: force resets to be inactive */
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index ae85961..0bbea5f 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -305,14 +305,11 @@ void jtag_set_verify_capture_ir(bool enable);
 /// @returns True if IR scan verification will be performed.
 bool jtag_will_verify_capture_ir(void);
 
-/**
- * Initialize interface upon startup.  Return a successful no-op upon
- * subsequent invocations.
- */
-int  jtag_interface_init(struct command_context* cmd_ctx);
+/** Initialize debug adapter upon startup.  */
+int  adapter_init(struct command_context* cmd_ctx);
 
-/// Shutdown the JTAG interface upon program exit.
-int  jtag_interface_quit(void);
+/// Shutdown the debug adapter upon program exit.
+int  adapter_quit(void);
 
 /**
  * Initialize JTAG chain using only a RESET reset. If init fails,
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 3ffa930..ce17e4b 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1430,7 +1430,7 @@ COMMAND_HANDLER(handle_jtag_reset_command)
 	else
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	if (jtag_interface_init(CMD_CTX) != ERROR_OK)
+	if (adapter_init(CMD_CTX) != ERROR_OK)
 		return ERROR_JTAG_INIT_FAILED;
 
 	jtag_add_reset(trst, srst);
diff --git a/src/openocd.c b/src/openocd.c
index 4250434..d376f5f 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -115,12 +115,12 @@ COMMAND_HANDLER(handle_init_command)
 	if (ERROR_OK != retval)
 		return ERROR_FAIL;
 
-	if ((retval = jtag_interface_init(CMD_CTX)) != ERROR_OK)
+	if ((retval = adapter_init(CMD_CTX)) != ERROR_OK)
 	{
-		/* we must be able to set up the jtag interface */
+		/* we must be able to set up the debug adapter */
 		return retval;
 	}
-	LOG_DEBUG("jtag interface init complete");
+	LOG_DEBUG("Debug Adapter init complete");
 
 	/* Try to initialize & examine the JTAG chain at this point,
 	 * but continue startup regardless.  Note that platforms
@@ -297,7 +297,7 @@ int openocd_main(int argc, char *argv[])
 	/* free commandline interface */
 	command_done(cmd_ctx);
 
-	jtag_interface_quit();
+	adapter_quit();
 
 	return ret;
 }

commit c23d4596d2239bdbba080499de837f53e0c89e59
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Mar 14 13:10:26 2010 -0700

    FT2232: lookup and save layout just once
    
    Streamline use of the layout:  have the "ft2232_layout" command
    look it up and save the result, instead of having a few different
    chunks of code looking it up later, and saving just its name (which
    is already part of the layout).  This
    
       - is cleaner
       - reports errors sooner
       - facilitates earlier adapter-specific setup
       - removes unused "default to "usbjtag" logic
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 38195c7..10e4636 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -141,7 +141,6 @@ static int ft2232_stableclocks(int num_cycles, struct jtag_command* cmd);
 static char *       ft2232_device_desc_A = NULL;
 static char*        ft2232_device_desc = NULL;
 static char*        ft2232_serial  = NULL;
-static char*        ft2232_layout  = NULL;
 static uint8_t		ft2232_latency = 2;
 static unsigned		ft2232_max_tck = FTDI_2232C_MAX_TCK;
 
@@ -289,7 +288,9 @@ static const struct ft2232_layout  ft2232_layouts[] =
 
 static uint8_t                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;
 
+/** the layout being used with this debug session */
 static const struct ft2232_layout *layout;
+
 static uint8_t                  low_output     = 0x0;
 static uint8_t                  low_direction  = 0x0;
 static uint8_t                  high_output    = 0x0;
@@ -2020,7 +2021,12 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 	char*	openex_string = NULL;
 	uint8_t	latency_timer;
 
-	LOG_DEBUG("'ft2232' interface using FTD2XX with '%s' layout (%4.4x:%4.4x)", ft2232_layout, vid, pid);
+	if ((layout == NULL) {
+		LOG_WARNING("No ft2232 layout specified'");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	LOG_DEBUG("'ft2232' interface using FTD2XX with '%s' layout (%4.4x:%4.4x)", layout->name, vid, pid);
 
 #if IS_WIN32 == 0
 	/* Add non-standard Vid/Pid to the linux driver */
@@ -2187,8 +2193,13 @@ static int ft2232_init_libftdi(uint16_t vid, uint16_t pid, int more, int* try_mo
 {
 	uint8_t latency_timer;
 
+	if (layout == NULL) {
+		LOG_WARNING("No ft2232 layout specified'");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
 	LOG_DEBUG("'ft2232' interface using libftdi with '%s' layout (%4.4x:%4.4x)",
-			ft2232_layout, vid, pid);
+			layout->name, vid, pid);
 
 	if (ftdi_init(&ftdic) < 0)
 		return ERROR_JTAG_INIT_FAILED;
@@ -2268,8 +2279,6 @@ static int ft2232_init(void)
 	uint8_t  buf[1];
 	int retval;
 	uint32_t bytes_written;
-	const struct ft2232_layout* cur_layout = ft2232_layouts;
-	int i;
 
 	if (tap_get_tms_path_len(TAP_IRPAUSE,TAP_IRPAUSE) == 7)
 	{
@@ -2280,29 +2289,12 @@ static int ft2232_init(void)
 		LOG_DEBUG("ft2232 interface using shortest path jtag state transitions");
 
 	}
-	if ((ft2232_layout == NULL) || (ft2232_layout[0] == 0))
-	{
-		ft2232_layout = "usbjtag";
-		LOG_WARNING("No ft2232 layout specified, using default 'usbjtag'");
-	}
-
-	while (cur_layout->name)
-	{
-		if (strcmp(cur_layout->name, ft2232_layout) == 0)
-		{
-			layout = cur_layout;
-			break;
-		}
-		cur_layout++;
-	}
-
-	if (!layout)
-	{
-		LOG_ERROR("No matching layout found for %s", ft2232_layout);
+	if (layout == NULL) {
+		LOG_WARNING("No ft2232 layout specified'");
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	for (i = 0; 1; i++)
+	for (int i = 0; 1; i++)
 	{
 		/*
 		 * "more indicates that there are more IDs to try, so we should
@@ -2321,7 +2313,7 @@ static int ft2232_init(void)
 				more, &try_more);
 #elif BUILD_FT2232_LIBFTDI == 1
 		retval = ft2232_init_libftdi(ft2232_vid[i], ft2232_pid[i],
-					     more, &try_more, cur_layout->channel);
+					     more, &try_more, layout->channel);
 #endif
 		if (retval >= 0)
 			break;
@@ -2371,6 +2363,7 @@ static int usbjtag_init(void)
 {
 	uint8_t  buf[3];
 	uint32_t bytes_written;
+	char *ft2232_layout = layout->name;
 
 	low_output    = 0x08;
 	low_direction = 0x0b;
@@ -3131,13 +3124,28 @@ COMMAND_HANDLER(ft2232_handle_serial_command)
 
 COMMAND_HANDLER(ft2232_handle_layout_command)
 {
-	if (CMD_ARGC == 0)
-		return ERROR_OK;
+	if (CMD_ARGC != 1) {
+		LOG_ERROR("Need exactly one argument to ft2232_layout");
+		return ERROR_FAIL;
+	}
 
-	ft2232_layout = malloc(strlen(CMD_ARGV[0]) + 1);
-	strcpy(ft2232_layout, CMD_ARGV[0]);
+	if (layout) {
+		LOG_ERROR("already specified ft2232_layout %s",
+				layout->name);
+		return (strcmp(layout->name, CMD_ARGV[0]) != 0)
+				? ERROR_FAIL
+				: ERROR_OK;
+	}
 
-	return ERROR_OK;
+	for (const struct ft2232_layout *l = ft2232_layouts; l->name; l++) {
+		if (strcmp(l->name, CMD_ARGV[0]) == 0) {
+			layout = l;
+			return ERROR_OK;
+		}
+	}
+
+	LOG_ERROR("No FT2232 layout '%s' found", CMD_ARGV[0]);
+	return ERROR_FAIL;
 }
 
 COMMAND_HANDLER(ft2232_handle_vid_pid_command)

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c           |   18 ++++++++----
 src/jtag/drivers/ft2232.c |   70 +++++++++++++++++++++++++--------------------
 src/jtag/jtag.h           |   11 ++----
 src/jtag/tcl.c            |    2 +-
 src/openocd.c             |    8 ++--
 5 files changed, 60 insertions(+), 49 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Mar 15 10:40:33 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 15 Mar 2010 09:40:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-81-gde761e3
Message-ID: <E1Nr6mo-00085I-He@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  de761e350ba8d89fab4fac6f14b1072f8369d778 (commit)
      from  c25fda2c95f130d758c7784277fe5f2693ff3dd4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit de761e350ba8d89fab4fac6f14b1072f8369d778
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Mar 15 09:36:46 2010 +0000

    PIC32MX: update cfg script
    
    The default config script will now dynamically setup the BMX registers
    in the reset init script.
    This will also work if the user overrides the default working area.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index 0f1fa66..d77c3a8 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -18,14 +18,14 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x30938053
 }
 
-# working area is 16384 - 2048
-# loose first 2048 bytes due to BMXDKPBA reg
+# default working area is 16384
 if { [info exists WORKAREASIZE] } {
    set  _WORKAREASIZE $WORKAREASIZE
 } else {
-   set  _WORKAREASIZE [expr (16384 - 2048)]
+   set  _WORKAREASIZE 0x4000
 }
 
+
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
 
@@ -39,22 +39,35 @@ jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_C
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME
 
-$_TARGETNAME configure -work-area-phys 0xa0000800 -work-area-size $_WORKAREASIZE -work-area-backup 0
+#
+# At reset the pic32mx does not allow code execution from RAM
+# we have to setup the BMX registers to allow this.
+# One limitation is that we loose the first 2k of RAM.
+#
+
+global _PIC32MX_DATASIZE
+global _PIC32MX_PROGSIZE
+set _PIC32MX_DATASIZE 0x800
+set _PIC32MX_PROGSIZE [expr ($_WORKAREASIZE - $_PIC32MX_DATASIZE)]
 
+$_TARGETNAME configure -work-area-phys 0xa0000800 -work-area-size $_PIC32MX_PROGSIZE -work-area-backup 0
 $_TARGETNAME configure -event reset-init {
 	#
 	# from reset the pic32 cannot execute code in ram - enable ram execution
 	# minimum offset from start of ram is 2k
 	#
 
+	global _PIC32MX_DATASIZE
+	global _PIC32MX_PROGSIZE
+
 	# BMXCON
 	mww 0xbf882000 0x001f0040
-	# BMXDKPBA: 0xa0000800
-	mww 0xbf882010 0x00000800
-	# BMXDUDBA
-	mww 0xbf882020 0x00004000
-	# BMXDUPBA
-	mww 0xbf882030 0x00004000
+	# BMXDKPBA: 2k kernel data @ 0xa0000800
+	mww 0xbf882010 $_PIC32MX_DATASIZE
+	# BMXDUDBA: 16k kernel program @ 0xa0000800
+	mww 0xbf882020 $_PIC32MX_PROGSIZE
+	# BMXDUPBA: 0k user program
+	mww 0xbf882030 $_PIC32MX_PROGSIZE
 }
 
 set _FLASHNAME $_CHIPNAME.flash

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/pic32mx.cfg |   33 +++++++++++++++++++++++----------
 1 files changed, 23 insertions(+), 10 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon Mar 15 11:08:10 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 15 Mar 2010 10:08:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-82-g4b964a8
Message-ID: <E1Nr7DX-0003TP-8r@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4b964a81ca1423b808a056b457e3d458689d50fa (commit)
      from  de761e350ba8d89fab4fac6f14b1072f8369d778 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4b964a81ca1423b808a056b457e3d458689d50fa
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon Mar 15 10:06:47 2010 +0000

    FT2232: bulidfix
    
    Fix build issue with commit c23d4596d2239bdbba080499de837f53e0c89e59
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 10e4636..b45e8a4 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2021,7 +2021,7 @@ static int ft2232_init_ftd2xx(uint16_t vid, uint16_t pid, int more, int* try_mor
 	char*	openex_string = NULL;
 	uint8_t	latency_timer;
 
-	if ((layout == NULL) {
+	if (layout == NULL) {
 		LOG_WARNING("No ft2232 layout specified'");
 		return ERROR_JTAG_INIT_FAILED;
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Mar 15 16:50:44 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 15 Mar 2010 15:50:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-86-ga540033
Message-ID: <E1NrCZ3-0006DC-Fs@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a540033a71eb0b10bb8de85963781ec1b9c06cf1 (commit)
       via  1bd3ae398646da1107e00e0651abbf9691d2d9ff (commit)
       via  b559b273b526b3077b3ca219eecc8df9f86efac0 (commit)
       via  96f9790279f74f39b35fc3ad09340fd03123180c (commit)
      from  4b964a81ca1423b808a056b457e3d458689d50fa (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a540033a71eb0b10bb8de85963781ec1b9c06cf1
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Mar 15 08:43:16 2010 -0700

    move "reset_config" out of JTAG command group
    
    The SRST configuration options are not specific to JTAG, so this
    command may be needed with non-JTAG debug sessions.  Just move
    the command to a different group.
    
    (The TRST options are, however, clearly JTAG-specific, but for
    compatibility, they're now left alone.  The flags they control
    could later be disabled in non-JTAG sessions.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 686eb3e..90081cd 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1645,6 +1645,17 @@ static const struct command_registration interface_command_handlers[] = {
 		.mode = COMMAND_ANY,
 		.help = "List all built-in debug adapter interfaces (drivers)",
 	},
+	{
+		.name = "reset_config",
+		.handler = handle_reset_config_command,
+		.mode = COMMAND_ANY,
+		.help = "configure adapter reset behavior",
+		.usage = "[none|trst_only|srst_only|trst_and_srst] "
+			"[srst_pulls_trst|trst_pulls_srst|combined|separate] "
+			"[srst_gates_jtag|srst_nogate] "
+			"[trst_push_pull|trst_open_drain] "
+			"[srst_push_pull|srst_open_drain]",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -1670,17 +1681,6 @@ static const struct command_registration jtag_command_handlers[] = {
 		.usage = "[fallback_speed_khz]",
 	},
 	{
-		.name = "reset_config",
-		.handler = handle_reset_config_command,
-		.mode = COMMAND_ANY,
-		.help = "configure JTAG reset behavior",
-		.usage = "[none|trst_only|srst_only|trst_and_srst] "
-			"[srst_pulls_trst|trst_pulls_srst|combined|separate] "
-			"[srst_gates_jtag|srst_nogate] "
-			"[trst_push_pull|trst_open_drain] "
-			"[srst_push_pull|srst_open_drain]",
-	},
-	{
 		.name = "jtag_ntrst_delay",
 		.handler = handle_jtag_ntrst_delay_command,
 		.mode = COMMAND_ANY,

commit 1bd3ae398646da1107e00e0651abbf9691d2d9ff
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Mar 15 08:42:26 2010 -0700

    rename jtag_nsrst_assert_width as adapter_nsrst_assert_width
    
    Globally rename "jtag_nsrst_assert_width" as "adapter_nsrst_assert_width",
    and move it out of the "jtag" command group ...  it needs to be used with
    non-JTAG transports
    
    Includes a migration aid (in jtag/startup.tcl) so that old user scripts
    won't break.  That aid should Sunset in about a year.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 924ee37..cc2560b 100644
--- a/NEWS
+++ b/NEWS
@@ -11,6 +11,7 @@ JTAG Layer:
 	   will not be around forever.
 	   	jtag_khz	... is now adapter_khz
 		jtag_nsrst_delay ... is now adapter_nsrst_delay
+		jtag_nsrst_assert_width ... is now adapter_nsrst_assert_width
 
 Boundary Scan:
 
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 9d1532b..e1bb2b7 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2643,7 +2643,7 @@ needing to cope with both architecture and board specific constraints.
 
 @section Commands for Handling Resets
 
- at deffn {Command} jtag_nsrst_assert_width milliseconds
+ at deffn {Command} adapter_nsrst_assert_width milliseconds
 Minimum amount of time (in milliseconds) OpenOCD should wait
 after asserting nSRST (active-low system reset) before
 allowing it to be deasserted.
diff --git a/src/jtag/core.c b/src/jtag/core.c
index bb11ff1..9792280 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -95,7 +95,7 @@ static int jtag_verify = 1;
 /* how long the OpenOCD should wait before attempting JTAG communication after reset lines deasserted (in ms) */
 static int adapter_nsrst_delay = 0; /* default to no nSRST delay */
 static int jtag_ntrst_delay = 0; /* default to no nTRST delay */
-static int jtag_nsrst_assert_width = 0; /* width of assertion */
+static int adapter_nsrst_assert_width = 0; /* width of assertion */
 static int jtag_ntrst_assert_width = 0; /* width of assertion */
 
 /**
@@ -699,8 +699,8 @@ void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 		if (jtag_srst)
 		{
 			LOG_DEBUG("SRST line asserted");
-			if (jtag_nsrst_assert_width)
-				jtag_add_sleep(jtag_nsrst_assert_width * 1000);
+			if (adapter_nsrst_assert_width)
+				jtag_add_sleep(adapter_nsrst_assert_width * 1000);
 		}
 		else {
 			LOG_DEBUG("SRST line released");
@@ -1714,11 +1714,11 @@ unsigned jtag_get_ntrst_delay(void)
 
 void jtag_set_nsrst_assert_width(unsigned delay)
 {
-	jtag_nsrst_assert_width = delay;
+	adapter_nsrst_assert_width = delay;
 }
 unsigned jtag_get_nsrst_assert_width(void)
 {
-	return jtag_nsrst_assert_width;
+	return adapter_nsrst_assert_width;
 }
 void jtag_set_ntrst_assert_width(unsigned delay)
 {
diff --git a/src/jtag/startup.tcl b/src/jtag/startup.tcl
index 42fbe4f..3a36886 100644
--- a/src/jtag/startup.tcl
+++ b/src/jtag/startup.tcl
@@ -84,4 +84,6 @@ proc srst_asserted {} {
 #
 proc jtag_khz args { eval adapter_khz $args }
 proc jtag_nsrst_delay args { eval adapter_nsrst_delay $args }
+proc jtag_nsrst_assert_width args { eval adapter_nsrst_assert_width $args }
+
 # END MIGRATION AIDS
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index d587922..686eb3e 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1321,7 +1321,7 @@ COMMAND_HANDLER(handle_jtag_ntrst_delay_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_jtag_nsrst_assert_width_command)
+COMMAND_HANDLER(handle_adapter_nsrst_assert_width_command)
 {
 	if (CMD_ARGC > 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -1332,7 +1332,7 @@ COMMAND_HANDLER(handle_jtag_nsrst_assert_width_command)
 
 		jtag_set_nsrst_assert_width(delay);
 	}
-	command_print(CMD_CTX, "jtag_nsrst_assert_width: %u", jtag_get_nsrst_assert_width());
+	command_print(CMD_CTX, "adapter_nsrst_assert_width: %u", jtag_get_nsrst_assert_width());
 	return ERROR_OK;
 }
 
@@ -1619,10 +1619,17 @@ static const struct command_registration interface_command_handlers[] = {
 		.usage = "[khz]",
 	},
 	{
+		.name = "adapter_nsrst_assert_width",
+		.handler = handle_adapter_nsrst_assert_width_command,
+		.mode = COMMAND_ANY,
+		.help = "delay after asserting SRST in ms",
+		.usage = "[milliseconds]",
+	},
+	{
 		.name = "adapter_nsrst_delay",
 		.handler = handle_adapter_nsrst_delay_command,
 		.mode = COMMAND_ANY,
-		.help = "delay after deasserting srst in ms",
+		.help = "delay after deasserting SRST in ms",
 		.usage = "[milliseconds]",
 	},
 	{
@@ -1681,13 +1688,6 @@ static const struct command_registration jtag_command_handlers[] = {
 		.usage = "[milliseconds]",
 	},
 	{
-		.name = "jtag_nsrst_assert_width",
-		.handler = handle_jtag_nsrst_assert_width_command,
-		.mode = COMMAND_ANY,
-		.help = "delay after asserting srst in ms",
-		.usage = "[milliseconds]",
-	},
-	{
 		.name = "jtag_ntrst_assert_width",
 		.handler = handle_jtag_ntrst_assert_width_command,
 		.mode = COMMAND_ANY,
diff --git a/tcl/board/telo.cfg b/tcl/board/telo.cfg
index 80040b1..a60cb02 100644
--- a/tcl/board/telo.cfg
+++ b/tcl/board/telo.cfg
@@ -13,7 +13,7 @@ source [find target/c100helper.tcl]
 # use libftdi.so library instead with this script
 # make the reset asserted to
 # allow RC circuit to discharge for: [ms]
-jtag_nsrst_assert_width 100
+adapter_nsrst_assert_width 100
 jtag_ntrst_assert_width 100
 # don't talk to JTAG after reset for: [ms]
 adapter_nsrst_delay 100
diff --git a/tcl/target/telo.cfg b/tcl/target/telo.cfg
index 40674b9..aa9ff22 100644
--- a/tcl/target/telo.cfg
+++ b/tcl/target/telo.cfg
@@ -13,7 +13,7 @@ source [find target/c100helper.tcl]
 # use libftdi.so library instead with this script
 # make the reset asserted to
 # allow RC circuit to discharge for: [ms]
-jtag_nsrst_assert_width 100
+adapter_nsrst_assert_width 100
 jtag_ntrst_assert_width 100
 # don't talk to JTAG after reset for: [ms]
 adapter_nsrst_delay 100

commit b559b273b526b3077b3ca219eecc8df9f86efac0
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Mar 15 08:41:30 2010 -0700

    rename jtag_nsrst_delay as adapter_nsrst_delay
    
    Globally rename "jtag_nsrst_delay" as "adapter_nsrst_delay", and move it
    out of the "jtag" command group ...  it needs to be used with non-JTAG
    transports
    
    Includes a migration aid (in jtag/startup.tcl) so that old user scripts
    won't break.  That aid should Sunset in about a year.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 4e093dc..924ee37 100644
--- a/NEWS
+++ b/NEWS
@@ -10,6 +10,7 @@ JTAG Layer:
 	   convert your scripts to the new names, since those procedures
 	   will not be around forever.
 	   	jtag_khz	... is now adapter_khz
+		jtag_nsrst_delay ... is now adapter_nsrst_delay
 
 Boundary Scan:
 
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 5a1e095..9d1532b 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2603,7 +2603,7 @@ stops issuing the reset.  For example, there may be chip or board
 requirements that all reset pulses last for at least a
 certain amount of time; and reset buttons commonly have
 hardware debouncing.
-Use the @command{jtag_nsrst_delay} and @command{jtag_ntrst_delay}
+Use the @command{adapter_nsrst_delay} and @command{jtag_ntrst_delay}
 commands to say when extra delays are needed.
 
 @item @emph{Drive type} ... Reset lines often have a pullup
@@ -2649,7 +2649,7 @@ after asserting nSRST (active-low system reset) before
 allowing it to be deasserted.
 @end deffn
 
- at deffn {Command} jtag_nsrst_delay milliseconds
+ at deffn {Command} adapter_nsrst_delay milliseconds
 How long (in milliseconds) OpenOCD should wait after deasserting
 nSRST (active-low system reset) before starting new JTAG operations.
 When a board has a reset button connected to SRST line it will
diff --git a/src/jtag/core.c b/src/jtag/core.c
index bdf968e..bb11ff1 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -93,7 +93,7 @@ static bool jtag_verify_capture_ir = true;
 static int jtag_verify = 1;
 
 /* how long the OpenOCD should wait before attempting JTAG communication after reset lines deasserted (in ms) */
-static int jtag_nsrst_delay = 0; /* default to no nSRST delay */
+static int adapter_nsrst_delay = 0; /* default to no nSRST delay */
 static int jtag_ntrst_delay = 0; /* default to no nTRST delay */
 static int jtag_nsrst_assert_width = 0; /* width of assertion */
 static int jtag_ntrst_assert_width = 0; /* width of assertion */
@@ -704,8 +704,8 @@ void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 		}
 		else {
 			LOG_DEBUG("SRST line released");
-			if (jtag_nsrst_delay)
-				jtag_add_sleep(jtag_nsrst_delay * 1000);
+			if (adapter_nsrst_delay)
+				jtag_add_sleep(adapter_nsrst_delay * 1000);
 		}
 	}
 
@@ -1696,11 +1696,11 @@ int jtag_get_srst(void)
 
 void jtag_set_nsrst_delay(unsigned delay)
 {
-	jtag_nsrst_delay = delay;
+	adapter_nsrst_delay = delay;
 }
 unsigned jtag_get_nsrst_delay(void)
 {
-	return jtag_nsrst_delay;
+	return adapter_nsrst_delay;
 }
 void jtag_set_ntrst_delay(unsigned delay)
 {
diff --git a/src/jtag/startup.tcl b/src/jtag/startup.tcl
index c49c43e..42fbe4f 100644
--- a/src/jtag/startup.tcl
+++ b/src/jtag/startup.tcl
@@ -83,4 +83,5 @@ proc srst_asserted {} {
 # FIXME phase these aids out after about April 2011
 #
 proc jtag_khz args { eval adapter_khz $args }
+proc jtag_nsrst_delay args { eval adapter_nsrst_delay $args }
 # END MIGRATION AIDS
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 8faefd1..d587922 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1291,7 +1291,7 @@ next:
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_jtag_nsrst_delay_command)
+COMMAND_HANDLER(handle_adapter_nsrst_delay_command)
 {
 	if (CMD_ARGC > 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -1302,7 +1302,7 @@ COMMAND_HANDLER(handle_jtag_nsrst_delay_command)
 
 		jtag_set_nsrst_delay(delay);
 	}
-	command_print(CMD_CTX, "jtag_nsrst_delay: %u", jtag_get_nsrst_delay());
+	command_print(CMD_CTX, "adapter_nsrst_delay: %u", jtag_get_nsrst_delay());
 	return ERROR_OK;
 }
 
@@ -1619,6 +1619,13 @@ static const struct command_registration interface_command_handlers[] = {
 		.usage = "[khz]",
 	},
 	{
+		.name = "adapter_nsrst_delay",
+		.handler = handle_adapter_nsrst_delay_command,
+		.mode = COMMAND_ANY,
+		.help = "delay after deasserting srst in ms",
+		.usage = "[milliseconds]",
+	},
+	{
 		.name = "interface",
 		.handler = handle_interface_command,
 		.mode = COMMAND_CONFIG,
@@ -1667,13 +1674,6 @@ static const struct command_registration jtag_command_handlers[] = {
 			"[srst_push_pull|srst_open_drain]",
 	},
 	{
-		.name = "jtag_nsrst_delay",
-		.handler = handle_jtag_nsrst_delay_command,
-		.mode = COMMAND_ANY,
-		.help = "delay after deasserting srst in ms",
-		.usage = "[milliseconds]",
-	},
-	{
 		.name = "jtag_ntrst_delay",
 		.handler = handle_jtag_ntrst_delay_command,
 		.mode = COMMAND_ANY,
diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index f24f1a1..c3eb952 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -32,7 +32,7 @@ jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CP
 # affected by the board and type of JTAG adapter.  A value of 200 ms seems
 # to work reliably for the configuration listed in the file header above.
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 # Set fallback clock to 1/6 of worst-case clock speed (which would be the 32.768 kHz slow clock).
diff --git a/tcl/board/crossbow_tech_imote2.cfg b/tcl/board/crossbow_tech_imote2.cfg
index 88d4aa7..002b537 100644
--- a/tcl/board/crossbow_tech_imote2.cfg
+++ b/tcl/board/crossbow_tech_imote2.cfg
@@ -4,7 +4,7 @@ set  CHIPNAME imote2
 source [find target/pxa270.cfg]
 
 # longer-than-normal reset delay
-jtag_nsrst_delay 800
+adapter_nsrst_delay 800
 
 reset_config trst_and_srst separate
 
diff --git a/tcl/board/csb732.cfg b/tcl/board/csb732.cfg
index cad38e2..4d6f0e4 100644
--- a/tcl/board/csb732.cfg
+++ b/tcl/board/csb732.cfg
@@ -3,7 +3,7 @@ source [find target/imx35.cfg]
 
 # Determined by trial and error
 reset_config trst_and_srst combined
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 $_TARGETNAME configure -event gdb-attach { reset init }
diff --git a/tcl/board/digi_connectcore_wi-9c.cfg b/tcl/board/digi_connectcore_wi-9c.cfg
index 2d82376..ad40d53 100644
--- a/tcl/board/digi_connectcore_wi-9c.cfg
+++ b/tcl/board/digi_connectcore_wi-9c.cfg
@@ -36,7 +36,7 @@ if { [info exists CPUTAPID ] } {
 set _TARGETNAME $_CHIPNAME.cpu
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 0
 
 
diff --git a/tcl/board/ek-lm3s1968.cfg b/tcl/board/ek-lm3s1968.cfg
index 6ce7f7f..28066f3 100644
--- a/tcl/board/ek-lm3s1968.cfg
+++ b/tcl/board/ek-lm3s1968.cfg
@@ -16,7 +16,7 @@ source [find target/lm3s1968.cfg]
 # jtag speed
 adapter_khz 3000
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 
 #LM3S1968 Evaluation Board has only srst
 reset_config srst_only
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s811.cfg
index 078cae1..7d3f2ce 100644
--- a/tcl/board/ek-lm3s811.cfg
+++ b/tcl/board/ek-lm3s811.cfg
@@ -12,7 +12,7 @@ source [find target/lm3s811.cfg]
 # jtag speed
 adapter_khz 500
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 
 #LM3S811 Evaluation Board has only srst
 reset_config srst_only
diff --git a/tcl/board/ek-lm3s9b9x.cfg b/tcl/board/ek-lm3s9b9x.cfg
index b8be88b..fb6272a 100644
--- a/tcl/board/ek-lm3s9b9x.cfg
+++ b/tcl/board/ek-lm3s9b9x.cfg
@@ -11,7 +11,7 @@ source [find target/lm3s9b9x.cfg]
 # jtag speed
 adapter_khz 500
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 
 #LM3S9B9x Evaluation Board has only srst
 reset_config srst_only
diff --git a/tcl/board/ethernut3.cfg b/tcl/board/ethernut3.cfg
index 359cb0b..34e9b72 100644
--- a/tcl/board/ethernut3.cfg
+++ b/tcl/board/ethernut3.cfg
@@ -20,7 +20,7 @@ flash bank $_FLASHNAME cfi 0x10000000 0x400000 2 2 $_TARGETNAME
 # Micrel MIC2775-29YM5 Supervisor
 # Reset output will remain active for 280ms (maximum)
 #
-jtag_nsrst_delay 300
+adapter_nsrst_delay 300
 jtag_ntrst_delay 300
 
 
diff --git a/tcl/board/hitex_lpc2929.cfg b/tcl/board/hitex_lpc2929.cfg
index 35cc7d0..d9ca110 100644
--- a/tcl/board/hitex_lpc2929.cfg
+++ b/tcl/board/hitex_lpc2929.cfg
@@ -2,7 +2,7 @@
 # http://www.hitex.com/
 
 # Delays on reset lines
-jtag_nsrst_delay 50
+adapter_nsrst_delay 50
 jtag_ntrst_delay 1
 
 # Maximum of 1/8 of clock frequency (XTAL = 16 MHz).
diff --git a/tcl/board/hitex_str9-comstick.cfg b/tcl/board/hitex_str9-comstick.cfg
index ade24f6..4d1bb2e 100644
--- a/tcl/board/hitex_str9-comstick.cfg
+++ b/tcl/board/hitex_str9-comstick.cfg
@@ -7,7 +7,7 @@ source [find interface/hitex_str9-comstick.cfg]
 # set jtag speed
 adapter_khz 3000
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config trst_and_srst
diff --git a/tcl/board/lubbock.cfg b/tcl/board/lubbock.cfg
index 32af386..095c60a 100644
--- a/tcl/board/lubbock.cfg
+++ b/tcl/board/lubbock.cfg
@@ -4,7 +4,7 @@
 
 source [find target/pxa255.cfg]
 
-jtag_nsrst_delay 250
+adapter_nsrst_delay 250
 jtag_ntrst_delay 250
 
 # NOTE: until after pinmux and such are set up, only CS0 is
diff --git a/tcl/board/mini2440.cfg b/tcl/board/mini2440.cfg
index b053c22..1688965 100644
--- a/tcl/board/mini2440.cfg
+++ b/tcl/board/mini2440.cfg
@@ -112,7 +112,7 @@ target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME
 $_TARGETNAME configure -work-area-phys 0x40000000  -work-area-size 0x4000 -work-area-backup 1
 
 #reset configuration
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 reset_config trst_and_srst
 
@@ -141,7 +141,7 @@ reset_config trst_and_srst
 
     nand device s3c2440 0
 
-    jtag_nsrst_delay 100
+    adapter_nsrst_delay 100
     jtag_ntrst_delay 100
     reset_config trst_and_srst
     init
diff --git a/tcl/board/phytec_lpc3250.cfg b/tcl/board/phytec_lpc3250.cfg
index 51622ef..6a7e8e9 100644
--- a/tcl/board/phytec_lpc3250.cfg
+++ b/tcl/board/phytec_lpc3250.cfg
@@ -1,6 +1,6 @@
 source [find target/lpc3250.cfg]
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 1
 adapter_khz 200
 reset_config trst_and_srst separate
diff --git a/tcl/board/pxa255_sst.cfg b/tcl/board/pxa255_sst.cfg
index ce90387..44f34ca 100644
--- a/tcl/board/pxa255_sst.cfg
+++ b/tcl/board/pxa255_sst.cfg
@@ -93,7 +93,7 @@ $_TARGETNAME configure -event reset-init {pxa255_sst_init}
 
 reset_config trst_and_srst
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 #xscale debug_handler 0  0xFFFF0800      # debug handler base address
diff --git a/tcl/board/telo.cfg b/tcl/board/telo.cfg
index cb4bc2a..80040b1 100644
--- a/tcl/board/telo.cfg
+++ b/tcl/board/telo.cfg
@@ -16,7 +16,7 @@ source [find target/c100helper.tcl]
 jtag_nsrst_assert_width 100
 jtag_ntrst_assert_width 100
 # don't talk to JTAG after reset for: [ms]
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 reset_config trst_and_srst separate
 
diff --git a/tcl/interface/calao-usb-a9260.cfg b/tcl/interface/calao-usb-a9260.cfg
index a9d7dec..5fae2f3 100644
--- a/tcl/interface/calao-usb-a9260.cfg
+++ b/tcl/interface/calao-usb-a9260.cfg
@@ -6,6 +6,6 @@
 # See calao-usb-a9260-c01.cfg and calao-usb-a9260-c02.cfg.
 #
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
diff --git a/tcl/target/aduc702x.cfg b/tcl/target/aduc702x.cfg
index 50b2a0d..d58b723 100644
--- a/tcl/target/aduc702x.cfg
+++ b/tcl/target/aduc702x.cfg
@@ -17,7 +17,7 @@ if { [info exists CPUTAPID] } {
    set  _CPUTAPID 0x3f0f0f0f
 }
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 ## JTAG scan chain
diff --git a/tcl/target/ar71xx.cfg b/tcl/target/ar71xx.cfg
index 2038331..126efe4 100644
--- a/tcl/target/ar71xx.cfg
+++ b/tcl/target/ar71xx.cfg
@@ -1,7 +1,7 @@
 # Atheros AR71xx MIPS 24Kc SoC.
 # tested on PB44 refererence board
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 reset_config trst_and_srst
diff --git a/tcl/target/at91sam9260.cfg b/tcl/target/at91sam9260.cfg
index df08d10..86258c6 100644
--- a/tcl/target/at91sam9260.cfg
+++ b/tcl/target/at91sam9260.cfg
@@ -26,7 +26,7 @@ reset_config trst_and_srst separate trst_push_pull srst_open_drain
 #
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-jtag_nsrst_delay 300
+adapter_nsrst_delay 300
 jtag_ntrst_delay 200
 
 jtag_rclk 3
diff --git a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
index 0359540..034a348 100644
--- a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
+++ b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
@@ -30,7 +30,7 @@ if { [info exists CPUTAPID ] } {
 reset_config trst_and_srst
 
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 
diff --git a/tcl/target/at91sam9rl.cfg b/tcl/target/at91sam9rl.cfg
index 6db1826..5ee5c49 100644
--- a/tcl/target/at91sam9rl.cfg
+++ b/tcl/target/at91sam9rl.cfg
@@ -26,7 +26,7 @@ reset_config trst_and_srst separate trst_push_pull srst_open_drain
 #
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-jtag_nsrst_delay 300
+adapter_nsrst_delay 300
 jtag_ntrst_delay 200
 
 jtag_rclk 3
diff --git a/tcl/target/dragonite.cfg b/tcl/target/dragonite.cfg
index d2e7e32..7e85624 100644
--- a/tcl/target/dragonite.cfg
+++ b/tcl/target/dragonite.cfg
@@ -26,6 +26,6 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME dragonite -endian $_ENDIAN -chain-position $_TARGETNAME
 
 reset_config trst_and_srst
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
diff --git a/tcl/target/epc9301.cfg b/tcl/target/epc9301.cfg
index 7e4599d..d2dc7ec 100644
--- a/tcl/target/epc9301.cfg
+++ b/tcl/target/epc9301.cfg
@@ -20,7 +20,7 @@ if { [info exists CPUTAPID ] } {
 }
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/feroceon.cfg b/tcl/target/feroceon.cfg
index b707770..e90165b 100644
--- a/tcl/target/feroceon.cfg
+++ b/tcl/target/feroceon.cfg
@@ -26,6 +26,6 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME feroceon -endian $_ENDIAN -chain-position $_TARGETNAME
 
 reset_config trst_and_srst
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
diff --git a/tcl/target/imx31.cfg b/tcl/target/imx31.cfg
index 46b4f94..3af6383 100644
--- a/tcl/target/imx31.cfg
+++ b/tcl/target/imx31.cfg
@@ -3,7 +3,7 @@
 
 reset_config trst_and_srst srst_gates_jtag
 
-jtag_nsrst_delay 5
+adapter_nsrst_delay 5
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
diff --git a/tcl/target/lm3s6965.cfg b/tcl/target/lm3s6965.cfg
index c6e623e..137cba9 100644
--- a/tcl/target/lm3s6965.cfg
+++ b/tcl/target/lm3s6965.cfg
@@ -15,7 +15,7 @@ if { [info exists CPUTAPID ] } {
 # jtag speed
 adapter_khz 500
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 #LM3S6965 Evaluation Board has only srst
diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index 182fb89..82a097f 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -25,7 +25,7 @@ if { [info exists CPUTAPID ] } {
 }
 
 #delays on reset lines
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 # LPC2000 & LPC1700 -> SRST causes TRST
diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
index 13535f5..2ebe91a 100644
--- a/tcl/target/lpc2103.cfg
+++ b/tcl/target/lpc2103.cfg
@@ -22,7 +22,7 @@ if { [info exists CPUTAPID ] } {
 reset_config trst_and_srst srst_pulls_trst
 
 # reset delays
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index ce55952..1b60c15 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -24,7 +24,7 @@ if { [info exists CPUTAPID ] } {
 reset_config trst_and_srst srst_pulls_trst
 
 # reset delays
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 adapter_khz 1000
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index 287fa5d..5b2a2f7 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -25,7 +25,7 @@ if { [info exists CPUTAPID ] } {
 reset_config trst_and_srst srst_pulls_trst
 
 # reset delays
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 #jtag scan chain
diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index cf6287c..502a355 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -21,7 +21,7 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x4f1f0f0f
 }
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 # NOTE!!! LPCs need reset pulled while RTCK is low. 0 to activate
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index d43d740..9ac3c6c 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -17,7 +17,7 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0xffffffff
 }
 
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 #use combined on interfaces or targets that can't set TRST/SRST separately
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index 7eb0dab..1a42e07 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -19,7 +19,7 @@ if { [info exists CPUTAPID ] } {
 }
 
 #delays on reset lines
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 # LPC2000 -> SRST causes TRST
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index d0bff1a..950ef63 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -19,7 +19,7 @@ if { [info exists CPUTAPID ] } {
 }
 
 #delays on reset lines
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 # LPC2000 -> SRST causes TRST
diff --git a/tcl/target/mega128.cfg b/tcl/target/mega128.cfg
index 697ec45..bb7cdee 100644
--- a/tcl/target/mega128.cfg
+++ b/tcl/target/mega128.cfg
@@ -7,7 +7,7 @@
 adapter_khz 4500
 
 reset_config  srst_only
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 
 #jtag scan chain
 if { [info exists CPUTAPID ] } {
diff --git a/tcl/target/netx500.cfg b/tcl/target/netx500.cfg
index 90315af..04a267b 100644
--- a/tcl/target/netx500.cfg
+++ b/tcl/target/netx500.cfg
@@ -20,7 +20,7 @@ if { [info exists CPUTAPID ] } {
 
 # FIXME most reset config belongs in board code
 reset_config trst_and_srst
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 # jtag scan chain
diff --git a/tcl/target/omap5912.cfg b/tcl/target/omap5912.cfg
index d825df7..ed64f52 100644
--- a/tcl/target/omap5912.cfg
+++ b/tcl/target/omap5912.cfg
@@ -14,7 +14,7 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x0692602f
 }
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 
 # NOTE:  presumes irlen 38 is the C55x DSP, matching BSDL for
 # its standalone siblings (like TMS320VC5502) of the same era
diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index d77c3a8..8c9a93d 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -26,7 +26,7 @@ if { [info exists WORKAREASIZE] } {
 }
 
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 #use combined on interfaces or targets that can't set TRST/SRST separately
diff --git a/tcl/target/pxa270.cfg b/tcl/target/pxa270.cfg
index 6ca057c..7aaef8c 100644
--- a/tcl/target/pxa270.cfg
+++ b/tcl/target/pxa270.cfg
@@ -28,9 +28,9 @@ if { [info exists CPUTAPID2 ] } {
 }
 
 
-# set jtag_nsrst_delay to the delay introduced by your reset circuit
+# set adapter_nsrst_delay to the delay introduced by your reset circuit
 # the rest of the needed delays are built into the openocd program
-jtag_nsrst_delay 260
+adapter_nsrst_delay 260
 # set the jtag_ntrst_delay to the delay introduced by a reset circuit
 # the rest of the needed delays are built into the openocd program
 jtag_ntrst_delay 250
diff --git a/tcl/target/pxa3xx.cfg b/tcl/target/pxa3xx.cfg
index 5d64986..62c325b 100644
--- a/tcl/target/pxa3xx.cfg
+++ b/tcl/target/pxa3xx.cfg
@@ -59,9 +59,9 @@ if { [info exists CPUTAPID_PXA32X_C0 ] } {
    set _CPUTAPID_PXA32X_C0 0x7E642013
 }
 
-# set jtag_nsrst_delay to the delay introduced by your reset circuit
+# set adapter_nsrst_delay to the delay introduced by your reset circuit
 # the rest of the needed delays are built into the openocd program
-jtag_nsrst_delay 260
+adapter_nsrst_delay 260
 
 # set the jtag_ntrst_delay to the delay introduced by a reset circuit
 # the rest of the needed delays are built into the openocd program
diff --git a/tcl/target/samsung_s3c6410.cfg b/tcl/target/samsung_s3c6410.cfg
index 9137199..f9738c2 100644
--- a/tcl/target/samsung_s3c6410.cfg
+++ b/tcl/target/samsung_s3c6410.cfg
@@ -42,7 +42,7 @@ jtag newtap $_CHIPNAME cpu     -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm11 -endian $_ENDIAN  -chain-position $_TARGETNAME -variant arm1176
 
-jtag_nsrst_delay 500
+adapter_nsrst_delay 500
 jtag_ntrst_delay 500
 
 #reset configuration
diff --git a/tcl/target/smp8634.cfg b/tcl/target/smp8634.cfg
index b6b037a..4f3959d 100644
--- a/tcl/target/smp8634.cfg
+++ b/tcl/target/smp8634.cfg
@@ -19,7 +19,7 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x08630001
 }
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 reset_config trst_and_srst separate
diff --git a/tcl/target/stm32.cfg b/tcl/target/stm32.cfg
index 29c9f7f..a13dc31 100644
--- a/tcl/target/stm32.cfg
+++ b/tcl/target/stm32.cfg
@@ -23,7 +23,7 @@ if { [info exists WORKAREASIZE] } {
 # JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
 adapter_khz 1000
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 #jtag scan chain
diff --git a/tcl/target/str730.cfg b/tcl/target/str730.cfg
index 3a84897..a1491ff 100644
--- a/tcl/target/str730.cfg
+++ b/tcl/target/str730.cfg
@@ -27,7 +27,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
 #jtag nTRST and nSRST delay
-jtag_nsrst_delay 500
+adapter_nsrst_delay 500
 jtag_ntrst_delay 500
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/str750.cfg b/tcl/target/str750.cfg
index c2fb786..8a64226 100644
--- a/tcl/target/str750.cfg
+++ b/tcl/target/str750.cfg
@@ -29,7 +29,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
 #jtag nTRST and nSRST delay
-jtag_nsrst_delay 500
+adapter_nsrst_delay 500
 jtag_ntrst_delay 500
 
 set _TARGETNAME $_CHIPNAME.cpu
diff --git a/tcl/target/str912.cfg b/tcl/target/str912.cfg
index 2defe9f..6f2981a 100644
--- a/tcl/target/str912.cfg
+++ b/tcl/target/str912.cfg
@@ -15,7 +15,7 @@ if { [info exists ENDIAN] } {
 # jtag speed. We need to stick to 16kHz until we've finished reset.
 jtag_rclk 16
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 #use combined on interfaces or targets that can't set TRST/SRST separately
diff --git a/tcl/target/telo.cfg b/tcl/target/telo.cfg
index 99b9cd6..40674b9 100644
--- a/tcl/target/telo.cfg
+++ b/tcl/target/telo.cfg
@@ -16,7 +16,7 @@ source [find target/c100helper.tcl]
 jtag_nsrst_assert_width 100
 jtag_ntrst_assert_width 100
 # don't talk to JTAG after reset for: [ms]
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 reset_config trst_and_srst separate
 
diff --git a/tcl/target/tmpa900.cfg b/tcl/target/tmpa900.cfg
index 329e03c..a551391 100644
--- a/tcl/target/tmpa900.cfg
+++ b/tcl/target/tmpa900.cfg
@@ -32,7 +32,7 @@ jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CP
 
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config trst_and_srst
-jtag_nsrst_delay 20
+adapter_nsrst_delay 20
 jtag_ntrst_delay 20
 
 ######################
diff --git a/tcl/target/tmpa910.cfg b/tcl/target/tmpa910.cfg
index 29d2d6e..fa6f87b 100644
--- a/tcl/target/tmpa910.cfg
+++ b/tcl/target/tmpa910.cfg
@@ -32,7 +32,7 @@ jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CP
 
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config trst_and_srst
-jtag_nsrst_delay 20
+adapter_nsrst_delay 20
 jtag_ntrst_delay 20
 
 ######################
diff --git a/tcl/target/xba_revA3.cfg b/tcl/target/xba_revA3.cfg
index fb02c68..8ff5be9 100644
--- a/tcl/target/xba_revA3.cfg
+++ b/tcl/target/xba_revA3.cfg
@@ -22,7 +22,7 @@ if { [info exists CPUTAPID ] } {
 
 reset_config trst_and_srst separate
 
-jtag_nsrst_delay 100
+adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
 #jtag scan chain
diff --git a/tcl/test/syntax1.cfg b/tcl/test/syntax1.cfg
index c3d8ed9..79d5384 100644
--- a/tcl/test/syntax1.cfg
+++ b/tcl/test/syntax1.cfg
@@ -1,4 +1,4 @@
-jtag_nsrst_delay 200
+adapter_nsrst_delay 200
 jtag_ntrst_delay 200
 
 #use combined on interfaces or targets that can't set TRST/SRST separately

commit 96f9790279f74f39b35fc3ad09340fd03123180c
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Mar 15 08:37:43 2010 -0700

    rename jtag_khz as adapter_khz
    
    Globally rename "jtag_khz" as "adapter_khz", and move it out of the "jtag"
    command group ...  it needs to be used with non-JTAG transports
    
    Includes a migration aid (in jtag/startup.tcl) so that old user scripts
    won't break.  That aid should Sunset in about a year.  (We may want to
    update it to include a nag message too.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 77435e1..4e093dc 100644
--- a/NEWS
+++ b/NEWS
@@ -5,6 +5,11 @@ and other issues not mentioned here.
 
 JTAG Layer:
 	New driver for "Bus Pirate"
+	Rename various commands so they're not JTAG-specific
+	   There are migration procedures for these, but you should
+	   convert your scripts to the new names, since those procedures
+	   will not be around forever.
+	   	jtag_khz	... is now adapter_khz
 
 Boundary Scan:
 
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 93757d4..5a1e095 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -1516,7 +1516,7 @@ solution just avoids using that instruction with JTAG debuggers.
 If both the chip and the board support adaptive clocking,
 use the @command{jtag_rclk}
 command, in case your board is used with JTAG adapter which
-also supports it.  Otherwise use @command{jtag_khz}.
+also supports it.  Otherwise use @command{adapter_khz}.
 Set the slow rate at the beginning of the reset sequence,
 and the faster rate as soon as the clocks are at full speed.
 
@@ -2342,7 +2342,7 @@ you may encounter a problem.
 @deffn Command {parport_toggling_time} [nanoseconds]
 Displays how many nanoseconds the hardware needs to toggle TCK;
 the parport driver uses this value to obey the
- at command{jtag_khz} configuration.
+ at command{adapter_khz} configuration.
 When the optional @var{nanoseconds} parameter is given,
 that setting is changed before displaying the current value.
 
@@ -2353,7 +2353,7 @@ To measure the toggling time with a logic analyzer or a digital storage
 oscilloscope, follow the procedure below:
 @example
 > parport_toggling_time 1000
-> jtag_khz 500
+> adapter_khz 500
 @end example
 This sets the maximum JTAG clock speed of the hardware, but
 the actual speed probably deviates from the requested 500 kHz.
@@ -2364,14 +2364,14 @@ Update the setting to match your measurement:
 @example
 > parport_toggling_time <measured nanoseconds>
 @end example
-Now the clock speed will be a better match for @command{jtag_khz rate}
+Now the clock speed will be a better match for @command{adapter_khz rate}
 commands given in OpenOCD scripts and event handlers.
 
 You can do something similar with many digital multimeters, but note
 that you'll probably need to run the clock continuously for several
 seconds before it decides what clock rate to show.  Adjust the
 toggling time up or down until the measured clock rate is a good
-match for the jtag_khz rate you specified; be conservative.
+match for the adapter_khz rate you specified; be conservative.
 @end quotation
 @end deffn
 
@@ -2470,10 +2470,10 @@ However, it introduces delays to synchronize clocks; so it
 may not be the fastest solution.
 
 @b{NOTE:} Script writers should consider using @command{jtag_rclk}
-instead of @command{jtag_khz}, but only for (ARM) cores and boards
+instead of @command{adapter_khz}, but only for (ARM) cores and boards
 which support adaptive clocking.
 
- at deffn {Command} jtag_khz max_speed_kHz
+ at deffn {Command} adapter_khz max_speed_kHz
 A non-zero speed is in KHZ. Hence: 3000 is 3mhz.
 JTAG interfaces usually support a limited number of
 speeds.  The speed actually used won't be faster
@@ -3881,7 +3881,7 @@ the target clocks are fully set up.)
 before @command{reset_init} is called.
 
 This is the most robust place to use @command{jtag_rclk}
-or @command{jtag_khz} to switch to a low JTAG clock rate,
+or @command{adapter_khz} to switch to a low JTAG clock rate,
 when reset disables PLLs needed to use a fast clock.
 @ignore
 @item @b{reset-wait-pos}
@@ -7290,7 +7290,7 @@ To set the JTAG frequency use the command:
 
 @example
 # Example: 1.234MHz
-jtag_khz 1234
+adapter_khz 1234
 @end example
 
 
diff --git a/src/jtag/core.c b/src/jtag/core.c
index e7cb48d..bdf968e 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1556,7 +1556,7 @@ unsigned jtag_get_speed_khz(void)
 	return speed_khz;
 }
 
-static int jtag_khz_to_speed(unsigned khz, int* speed)
+static int adapter_khz_to_speed(unsigned khz, int* speed)
 {
 	LOG_DEBUG("convert khz to interface specific speed value");
 	speed_khz = khz;
@@ -1576,11 +1576,11 @@ static int jtag_khz_to_speed(unsigned khz, int* speed)
 
 static int jtag_rclk_to_speed(unsigned fallback_speed_khz, int* speed)
 {
-	int retval = jtag_khz_to_speed(0, speed);
+	int retval = adapter_khz_to_speed(0, speed);
 	if ((ERROR_OK != retval) && fallback_speed_khz)
 	{
 		LOG_DEBUG("trying fallback speed...");
-		retval = jtag_khz_to_speed(fallback_speed_khz, speed);
+		retval = adapter_khz_to_speed(fallback_speed_khz, speed);
 	}
 	return retval;
 }
@@ -1598,7 +1598,7 @@ int jtag_config_khz(unsigned khz)
 	LOG_DEBUG("handle jtag khz");
 	clock_mode = CLOCK_MODE_KHZ;
 	int speed = 0;
-	int retval = jtag_khz_to_speed(khz, &speed);
+	int retval = adapter_khz_to_speed(khz, &speed);
 	return (ERROR_OK != retval) ? retval : jtag_set_speed(speed);
 }
 
@@ -1621,7 +1621,7 @@ int jtag_get_speed(void)
 			speed = jtag_speed;
 			break;
 		case CLOCK_MODE_KHZ:
-			jtag_khz_to_speed(jtag_get_speed_khz(), &speed);
+			adapter_khz_to_speed(jtag_get_speed_khz(), &speed);
 			break;
 		case CLOCK_MODE_RCLK:
 			jtag_rclk_to_speed(rclk_fallback_speed_khz, &speed);
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
index 72126a1..10bed27 100644
--- a/src/jtag/drivers/presto.c
+++ b/src/jtag/drivers/presto.c
@@ -680,7 +680,7 @@ static struct bitq_interface presto_bitq = {
 
 /* -------------------------------------------------------------------------- */
 
-static int presto_jtag_khz(int khz, int *jtag_speed)
+static int presto_adapter_khz(int khz, int *jtag_speed)
 {
 	if (khz < 0)
 	{
@@ -797,7 +797,7 @@ struct jtag_interface presto_interface = {
 
 	.execute_queue = bitq_execute_queue,
 	.speed = presto_jtag_speed,
-	.khz = presto_jtag_khz,
+	.khz = presto_adapter_khz,
 	.speed_div = presto_jtag_speed_div,
 	.init = presto_jtag_init,
 	.quit = presto_jtag_quit,
diff --git a/src/jtag/startup.tcl b/src/jtag/startup.tcl
index 4e6d5fc..c49c43e 100644
--- a/src/jtag/startup.tcl
+++ b/src/jtag/startup.tcl
@@ -75,3 +75,12 @@ add_help_text srst_deasserted "Overridable procedure run when srst deassert is d
 proc srst_asserted {} {
 	puts "Sensed nSRST asserted."
 }
+
+# BEGIN MIGRATION AIDS ...  these adapter operations originally had
+# JTAG-specific names despite the fact that the operations were not
+# specific to JTAG.
+#
+# FIXME phase these aids out after about April 2011
+#
+proc jtag_khz args { eval adapter_khz $args }
+# END MIGRATION AIDS
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index ce17e4b..8faefd1 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1351,7 +1351,7 @@ COMMAND_HANDLER(handle_jtag_ntrst_assert_width_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_jtag_khz_command)
+COMMAND_HANDLER(handle_adapter_khz_command)
 {
 	if (CMD_ARGC > 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -1609,6 +1609,16 @@ COMMAND_HANDLER(handle_tms_sequence_command)
 
 static const struct command_registration interface_command_handlers[] = {
 	{
+		.name = "adapter_khz",
+		.handler = handle_adapter_khz_command,
+		.mode = COMMAND_ANY,
+		.help = "With an argument, change to the specified maximum "
+			"jtag speed.  For JTAG, 0 KHz signifies adaptive "
+			" clocking. "
+			"With or without argument, display current setting.",
+		.usage = "[khz]",
+	},
+	{
 		.name = "interface",
 		.handler = handle_interface_command,
 		.mode = COMMAND_CONFIG,
@@ -1637,15 +1647,6 @@ int interface_register_commands(struct command_context *ctx)
 
 static const struct command_registration jtag_command_handlers[] = {
 	{
-		.name = "jtag_khz",
-		.handler = handle_jtag_khz_command,
-		.mode = COMMAND_ANY,
-		.help = "With an argument, change to the specified maximum "
-			"jtag speed.  Pass 0 to require adaptive clocking. "
-			"With or without argument, display current setting.",
-		.usage = "[khz]",
-	},
-	{
 		.name = "jtag_rclk",
 		.handler = handle_jtag_rclk_command,
 		.mode = COMMAND_ANY,
diff --git a/src/svf/svf.c b/src/svf/svf.c
index fba499c..6e951e2 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -880,7 +880,7 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			// TODO: set jtag speed to
 			if (svf_para.frequency > 0)
 			{
-				command_run_linef(cmd_ctx, "jtag_khz %d", (int)svf_para.frequency / 1000);
+				command_run_linef(cmd_ctx, "adapter_khz %d", (int)svf_para.frequency / 1000);
 				LOG_DEBUG("\tfrequency = %f", svf_para.frequency);
 			}
 		}
diff --git a/tcl/board/at91eb40a.cfg b/tcl/board/at91eb40a.cfg
index 40f2e12..14f21a1 100644
--- a/tcl/board/at91eb40a.cfg
+++ b/tcl/board/at91eb40a.cfg
@@ -65,4 +65,4 @@ $_TARGETNAME configure -event reset-init {
 }
 
 # This target is pretty snappy...
-jtag_khz 16000
+adapter_khz 16000
diff --git a/tcl/board/at91rm9200-dk.cfg b/tcl/board/at91rm9200-dk.cfg
index 9a6f89e..476f5a8 100644
--- a/tcl/board/at91rm9200-dk.cfg
+++ b/tcl/board/at91rm9200-dk.cfg
@@ -15,7 +15,7 @@ flash_bank cfi 0x10000000 0x00200000 2 2 0
 proc at91rm9200_dk_init { } {
     # Try to run at 1khz... Yea, that slow!
     # Chip is really running @ 32khz
-    jtag_khz 8
+    adapter_khz 8
 
     mww 0xfffffc64 0xffffffff
     ##  disable all clocks but system clock
@@ -41,7 +41,7 @@ proc at91rm9200_dk_init { } {
     #========================================
     # CPU now runs at 180mhz
     # SYS runs at 60mhz.
-    jtag_khz 40000
+    adapter_khz 40000
     #========================================
 
 
diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index fb6068c..f24f1a1 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -77,7 +77,7 @@ proc at91sam9g20_init { } {
 	# means the master clock (MCLK) must be at or below 133 MHz or timing errors will occur.  The processor
 	# core can operate up to 400 MHz and therefore PCLK must be at or below this to function properly.
 
-	jtag_khz 2			# Slow-speed oscillator enabled at reset, so run jtag speed slow.
+	adapter_khz 2			# Slow-speed oscillator enabled at reset, so run jtag speed slow.
 	halt				# Make sure processor is halted, or error will result in following steps.
 	mww 0xfffffd08 0xa5000501	# RSTC_MR : enable user reset.
 	mww 0xfffffd44 0x00008000	# WDT_MR : disable watchdog.
@@ -112,7 +112,7 @@ proc at91sam9g20_init { } {
 
 	# Switch over to adaptive clocking.
 
-	jtag_khz 0
+	adapter_khz 0
 
 	# Enable faster DCC downloads.
 
diff --git a/tcl/board/csb337.cfg b/tcl/board/csb337.cfg
index b7bce48..5e225f5 100644
--- a/tcl/board/csb337.cfg
+++ b/tcl/board/csb337.cfg
@@ -19,7 +19,7 @@ if { [info exists ETM_DRIVER] } {
 
 proc csb337_clk_init { } {
 	# CPU is in Slow Clock Mode (32KiHz) ... needs slow JTAG clock
-	jtag_khz 8
+	adapter_khz 8
 
 	# CKGR_MOR:  start main oscillator (3.6864 MHz)
 	mww 0xfffffc20 0xff01
@@ -37,7 +37,7 @@ proc csb337_clk_init { } {
 	sleep 20
 
 	# CPU is in Normal Mode ... allows faster JTAG clock speed
-	jtag_khz 40000
+	adapter_khz 40000
 }
 
 proc csb337_nor_init { } {
diff --git a/tcl/board/dm365evm.cfg b/tcl/board/dm365evm.cfg
index f8ec4e0..8f268c4 100644
--- a/tcl/board/dm365evm.cfg
+++ b/tcl/board/dm365evm.cfg
@@ -103,7 +103,7 @@ proc dm365evm_init {} {
 	echo "Initialize DM365 EVM board"
 
 	# CLKIN	= 24 MHz ... can't talk quickly to ARM yet
-	jtag_khz 1500
+	adapter_khz 1500
 
 	# FIXME -- PLL init
 
diff --git a/tcl/board/ek-lm3s1968.cfg b/tcl/board/ek-lm3s1968.cfg
index bf4b097..6ce7f7f 100644
--- a/tcl/board/ek-lm3s1968.cfg
+++ b/tcl/board/ek-lm3s1968.cfg
@@ -4,7 +4,7 @@
 # http://www.luminarymicro.com/products/lm3s1968_evaluation_kits.html
 
 # NOTE:  to use J-Link instead of the on-board interface,
-# you may also need to reduce jtag_khz to be about 1200.
+# you may also need to reduce adapter_khz to be about 1200.
 # source [find interface/jlink.cfg]
 
 # include the FT2232 interface config for on-board JTAG interface
@@ -14,7 +14,7 @@ source [find interface/luminary.cfg]
 source [find target/lm3s1968.cfg]
 
 # jtag speed
-jtag_khz 3000
+adapter_khz 3000
 
 jtag_nsrst_delay 100
 
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s811.cfg
index 5825c23..078cae1 100644
--- a/tcl/board/ek-lm3s811.cfg
+++ b/tcl/board/ek-lm3s811.cfg
@@ -10,7 +10,7 @@ source [find interface/luminary.cfg]
 source [find target/lm3s811.cfg]
 
 # jtag speed
-jtag_khz 500
+adapter_khz 500
 
 jtag_nsrst_delay 100
 
diff --git a/tcl/board/ek-lm3s9b9x.cfg b/tcl/board/ek-lm3s9b9x.cfg
index 407ecc8..b8be88b 100644
--- a/tcl/board/ek-lm3s9b9x.cfg
+++ b/tcl/board/ek-lm3s9b9x.cfg
@@ -9,7 +9,7 @@ source [find interface/luminary-icdi.cfg]
 source [find target/lm3s9b9x.cfg]
 
 # jtag speed
-jtag_khz 500
+adapter_khz 500
 
 jtag_nsrst_delay 100
 
diff --git a/tcl/board/ethernut3.cfg b/tcl/board/ethernut3.cfg
index f22e688..359cb0b 100644
--- a/tcl/board/ethernut3.cfg
+++ b/tcl/board/ethernut3.cfg
@@ -26,7 +26,7 @@ jtag_ntrst_delay 300
 
 arm7_9 fast_memory_access enable
 arm7_9 dcc_downloads enable
-jtag_khz 16000
+adapter_khz 16000
 
 
 # Target events
diff --git a/tcl/board/hitex_lpc2929.cfg b/tcl/board/hitex_lpc2929.cfg
index 7d06f74..35cc7d0 100644
--- a/tcl/board/hitex_lpc2929.cfg
+++ b/tcl/board/hitex_lpc2929.cfg
@@ -7,7 +7,7 @@ jtag_ntrst_delay 1
 
 # Maximum of 1/8 of clock frequency (XTAL = 16 MHz).
 # Adaptive clocking through RTCK is not supported.
-jtag_khz 2000
+adapter_khz 2000
 
 # Target device: LPC29xx with ETB
 # The following variables are used by the LPC2900 script:
@@ -24,7 +24,7 @@ $_TARGETNAME configure -work-area-phys 0x58000000 -work-area-size 0x10000 -work-
 # Event handlers
 $_TARGETNAME configure -event reset-start {
   # Back to the slow JTAG clock
-  jtag_khz 2000
+  adapter_khz 2000
 }
 
 # External 16-bit flash at chip select CS7 (SST39VF3201-70, 4 MiB)
@@ -46,7 +46,7 @@ $_TARGETNAME configure -event reset-init {
   mww 0xFFFF8070 0x02000000     # SYS_CLK_CONF: PLL
 
   # Increase JTAG speed
-  jtag_khz 6000
+  adapter_khz 6000
 
   # Enable external memory bus (16-bit SRAM at CS6, 16-bit flash at CS7)
   mww 0xE0001138 0x0000001F     # P1.14 = D0
diff --git a/tcl/board/hitex_str9-comstick.cfg b/tcl/board/hitex_str9-comstick.cfg
index af7527a..ade24f6 100644
--- a/tcl/board/hitex_str9-comstick.cfg
+++ b/tcl/board/hitex_str9-comstick.cfg
@@ -5,7 +5,7 @@
 source [find interface/hitex_str9-comstick.cfg]
 
 # set jtag speed
-jtag_khz 3000
+adapter_khz 3000
 
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
diff --git a/tcl/board/imx27lnst.cfg b/tcl/board/imx27lnst.cfg
index ae141d4..e0ed057 100644
--- a/tcl/board/imx27lnst.cfg
+++ b/tcl/board/imx27lnst.cfg
@@ -8,7 +8,7 @@ proc imx27lnst_init { } {
 	# This setup puts RAM at 0xA0000000
 
 	# reset the board correctly
-	jtag_khz 500
+	adapter_khz 500
 	reset run
 	reset halt
 
diff --git a/tcl/board/mini2440.cfg b/tcl/board/mini2440.cfg
index 47bebc4..b053c22 100644
--- a/tcl/board/mini2440.cfg
+++ b/tcl/board/mini2440.cfg
@@ -121,7 +121,7 @@ reset_config trst_and_srst
 # IMPORTANT! See README at top of this file.
 #-------------------------------------------------------------------------
 
-    jtag_khz 12000
+    adapter_khz 12000
     jtag interface
 
 #-------------------------------------------------------------------------
diff --git a/tcl/board/phytec_lpc3250.cfg b/tcl/board/phytec_lpc3250.cfg
index 78cb90d..51622ef 100644
--- a/tcl/board/phytec_lpc3250.cfg
+++ b/tcl/board/phytec_lpc3250.cfg
@@ -2,7 +2,7 @@ source [find target/lpc3250.cfg]
 
 jtag_nsrst_delay 200
 jtag_ntrst_delay 1
-jtag_khz 200
+adapter_khz 200
 reset_config trst_and_srst separate
 
 arm7_9 dcc_downloads enable
@@ -11,11 +11,11 @@ $_TARGETNAME configure -event gdb-attach { reset init }
 
 $_TARGETNAME configure -event reset-start {
              arm7_9 fast_memory_access disable
-             jtag_khz 200
+             adapter_khz 200
 }
 
 $_TARGETNAME configure -event reset-end {
-             jtag_khz 6000
+             adapter_khz 6000
              arm7_9 fast_memory_access enable
 }
 
diff --git a/tcl/board/telo.cfg b/tcl/board/telo.cfg
index 0cbdb81..cb4bc2a 100644
--- a/tcl/board/telo.cfg
+++ b/tcl/board/telo.cfg
@@ -26,11 +26,11 @@ reset_config trst_and_srst separate
 # issue telnet: reset init
 # issue gdb: monitor reset init
 $_TARGETNAME configure -event reset-init {
-	jtag_khz 100
+	adapter_khz 100
 	# this will setup Telo board
 	setupTelo
 	#turn up the JTAG speed
-	jtag_khz 3000
+	adapter_khz 3000
 	puts "JTAG speek now 3MHz"
 	puts "type helpC100 to get help on C100"
 }
diff --git a/tcl/board/topas910.cfg b/tcl/board/topas910.cfg
index ae72c4b..303fc77 100644
--- a/tcl/board/topas910.cfg
+++ b/tcl/board/topas910.cfg
@@ -99,7 +99,7 @@ proc topas910_init { } {
 	mww 0xf4300004 0x00000000
 
 	sleep 10
-#	jtag_khz NNNN
+#	adapter_khz NNNN
 
 # remap off in case of IROM boot
 	mww 0xf0000004 0x00000001
diff --git a/tcl/board/topasa900.cfg b/tcl/board/topasa900.cfg
index 5984f81..aa3f77f 100644
--- a/tcl/board/topasa900.cfg
+++ b/tcl/board/topasa900.cfg
@@ -105,7 +105,7 @@ proc topasa900_init { } {
 	mww 0xf4300004 0x00000000
 
 	sleep 10
-#	jtag_khz NNNN
+#	adapter_khz NNNN
 
 # remap off in case of IROM boot
 	mww 0xf0000004 0x00000001
diff --git a/tcl/board/zy1000.cfg b/tcl/board/zy1000.cfg
index 8278fa4..17594c2 100644
--- a/tcl/board/zy1000.cfg
+++ b/tcl/board/zy1000.cfg
@@ -66,7 +66,7 @@ $_TARGETNAME configure -event reset-init {
 # other things than flash programming.
 $_TARGETNAME configure -work-area-phys 0x00020000 -work-area-size 0x20000 -work-area-backup 0
 
-jtag_khz 16000
+adapter_khz 16000
 
 
 proc production_info {} {
diff --git a/tcl/interface/altera-usb-blaster.cfg b/tcl/interface/altera-usb-blaster.cfg
index ae21465..9f542d0 100644
--- a/tcl/interface/altera-usb-blaster.cfg
+++ b/tcl/interface/altera-usb-blaster.cfg
@@ -8,4 +8,4 @@ interface usb_blaster
 # These are already the defaults.
 # usb_blaster_vid_pid 0x09FB 0x6001
 # usb_blaster_device_desc "USB-Blaster"
-jtag_khz 3000
+adapter_khz 3000
diff --git a/tcl/interface/oocdlink.cfg b/tcl/interface/oocdlink.cfg
index 9022afd..4e962f5 100644
--- a/tcl/interface/oocdlink.cfg
+++ b/tcl/interface/oocdlink.cfg
@@ -8,5 +8,5 @@ interface ft2232
 ft2232_device_desc "OOCDLink"
 ft2232_layout oocdlink
 ft2232_vid_pid 0x0403 0xbaf8
-jtag_khz 5
+adapter_khz 5
 
diff --git a/tcl/interface/openrd.cfg b/tcl/interface/openrd.cfg
index b01205b..322b508 100644
--- a/tcl/interface/openrd.cfg
+++ b/tcl/interface/openrd.cfg
@@ -8,5 +8,5 @@ interface ft2232
 ft2232_layout sheevaplug
 ft2232_vid_pid 0x0403 0x9e90
 ft2232_device_desc "OpenRD JTAGKey FT2232D B"
-jtag_khz 3000
+adapter_khz 3000
 
diff --git a/tcl/interface/sheevaplug.cfg b/tcl/interface/sheevaplug.cfg
index 556f44d..d46d71e 100644
--- a/tcl/interface/sheevaplug.cfg
+++ b/tcl/interface/sheevaplug.cfg
@@ -8,5 +8,5 @@ interface ft2232
 ft2232_layout sheevaplug
 ft2232_vid_pid 0x9e88 0x9e8f
 ft2232_device_desc "SheevaPlug JTAGKey FT2232D B"
-jtag_khz 2000
+adapter_khz 2000
 
diff --git a/tcl/interface/usb-jtag.cfg b/tcl/interface/usb-jtag.cfg
index b81028d..a3db11e 100644
--- a/tcl/interface/usb-jtag.cfg
+++ b/tcl/interface/usb-jtag.cfg
@@ -7,5 +7,5 @@
 interface usb_blaster
 usb_blaster_vid_pid 0x16C0 0x06AD
 usb_blaster_device_desc "USB-JTAG-IF"
-jtag_khz 3000
+adapter_khz 3000
 
diff --git a/tcl/interface/vsllink.cfg b/tcl/interface/vsllink.cfg
index 7c9de7f..07a5a06 100644
--- a/tcl/interface/vsllink.cfg
+++ b/tcl/interface/vsllink.cfg
@@ -19,7 +19,7 @@ vsllink_usb_bulkout	0x03
 vsllink_usb_interface	1
 
 # vsllink mode, dma or normal
-# for low jtag_khz, use normal
-# for high jtag_khz, use dma
+# for low adapter_khz, use normal
+# for high adapter_khz, use dma
 #vsllink_mode dma
 vsllink_mode normal
diff --git a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
index 690406b..0359540 100644
--- a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
+++ b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
@@ -1,7 +1,7 @@
 
 
 
-jtag_khz 4
+adapter_khz 4
 
 
 ######################################
@@ -62,7 +62,7 @@ flash bank $_FLASHNAME cfi 0x10000000 0x01000000 2 2 $_TARGETNAME
 proc at91sam_init { } {
 
 	# at reset chip runs at 32khz
-	jtag_khz 8
+	adapter_khz 8
 	halt
 	mww 0xfffffd08 0xa5000501         # RSTC_MR : enable user reset
 	mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
@@ -79,7 +79,7 @@ proc at91sam_init { } {
 	sleep 10                          # wait 10 ms
 
 	# Now run at anything fast... ie: 10mhz!
-	jtag_khz 10000                    # Increase JTAG Speed to 6 MHz
+	adapter_khz 10000                    # Increase JTAG Speed to 6 MHz
 	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
 
 	mww 0xffffec00 0x0a0a0a0a         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
diff --git a/tcl/target/c100.cfg b/tcl/target/c100.cfg
index b175f23..23eca0c 100644
--- a/tcl/target/c100.cfg
+++ b/tcl/target/c100.cfg
@@ -3,7 +3,7 @@
 # this script only configures one core (that is used to run Linux)
 
 # assume no PLL lock, start slowly
-jtag_khz 100
+adapter_khz 100
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
diff --git a/tcl/target/c100helper.tcl b/tcl/target/c100helper.tcl
index 9658871..1fd58b6 100644
--- a/tcl/target/c100helper.tcl
+++ b/tcl/target/c100helper.tcl
@@ -504,7 +504,7 @@ proc reboot {} {
     mww $TIMER_WDT_HIGH_BOUND  0xffffff
     mww $TIMER_WDT_CURRENT_COUNT 0x0
     puts "JTAG speed lowered to 100kHz"
-    jtag_khz 100
+    adapter_khz 100
     mww $TIMER_WDT_CONTROL 0x1
     # wait until the reset
     puts -nonewline "Wating for watchdog to trigger..."
diff --git a/tcl/target/dsp56321.cfg b/tcl/target/dsp56321.cfg
index 4506837..281c4dd 100644
--- a/tcl/target/dsp56321.cfg
+++ b/tcl/target/dsp56321.cfg
@@ -22,7 +22,7 @@ if { [info exists CPUTAPID ] } {
 }
 
 #jtag speed
-jtag_khz 4500
+adapter_khz 4500
 
 #has only srst
 reset_config srst_only
diff --git a/tcl/target/lm3s6965.cfg b/tcl/target/lm3s6965.cfg
index 02d85d4..c6e623e 100644
--- a/tcl/target/lm3s6965.cfg
+++ b/tcl/target/lm3s6965.cfg
@@ -13,7 +13,7 @@ if { [info exists CPUTAPID ] } {
 }
 
 # jtag speed
-jtag_khz 500
+adapter_khz 500
 
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index 9a27aec..ce55952 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -27,7 +27,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
 
-jtag_khz 1000
+adapter_khz 1000
 
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index 4e50ac5..7eb0dab 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -47,4 +47,4 @@ set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x0007D000 0 0 $_TARGETNAME lpc2000_v2 4000 calc_checksum
 
 # 4MHz / 6 = 666kHz, so use 500
-jtag_khz 500
+adapter_khz 500
diff --git a/tcl/target/mc13224v.cfg b/tcl/target/mc13224v.cfg
index 497e376..33351ca 100644
--- a/tcl/target/mc13224v.cfg
+++ b/tcl/target/mc13224v.cfg
@@ -36,7 +36,7 @@ jtag_ntrst_delay 200
 
 # rclk hasn't been working well. This maybe the mc13224v or something else.
 #jtag_rclk 2000
-jtag_khz 2000
+adapter_khz 2000
 
 ######################
 # Target configuration
diff --git a/tcl/target/mega128.cfg b/tcl/target/mega128.cfg
index 2cf31d6..697ec45 100644
--- a/tcl/target/mega128.cfg
+++ b/tcl/target/mega128.cfg
@@ -4,7 +4,7 @@
    set  _ENDIAN little
 
 # jtag speed
-jtag_khz 4500
+adapter_khz 4500
 
 reset_config  srst_only
 jtag_nsrst_delay 100
@@ -27,7 +27,7 @@ flash bank $_FLASHNAME avr 0 0 0 0 $_TARGETNAME
 
 #to use it, script will be like:
 #init
-#jtag_khz 4500
+#adapter_khz 4500
 #reset init
 #verify_ircapture disable
 #
diff --git a/tcl/target/pxa255.cfg b/tcl/target/pxa255.cfg
index 44efdaa..5b745f8 100644
--- a/tcl/target/pxa255.cfg
+++ b/tcl/target/pxa255.cfg
@@ -28,8 +28,8 @@ target create $_TARGETNAME xscale -endian $_ENDIAN \
 # PXA255 comes out of reset using 3.6864 MHz oscillator.
 # Until the PLL kicks in, keep the JTAG clock slow enough
 # that we get no errors.
-jtag_khz 300
-$_TARGETNAME configure -event "reset-start" { jtag_khz 300 }
+adapter_khz 300
+$_TARGETNAME configure -event "reset-start" { adapter_khz 300 }
 
 # both TRST and SRST are *required* for debug
 # DCSR is often accessed with SRST active
diff --git a/tcl/target/readme.txt b/tcl/target/readme.txt
index 39f8d12..f028b11 100644
--- a/tcl/target/readme.txt
+++ b/tcl/target/readme.txt
@@ -26,12 +26,12 @@ assumed that all write-protect mechanisms should be disabled.
 flash write_image [file] <parameters>
 verify_image [file] <parameters>
 
-4. jtag_khz sets the maximum speed (or alternatively RCLK). If invoked
+4. adapter_khz sets the maximum speed (or alternatively RCLK). If invoked
 multiple times only the last setting is used.
 
 interface/xxx.cfg files are always executed *before* target/xxx.cfg
-files, so any jtag_khz in interface/xxx.cfg will be overridden by
-target/xxx.cfg. jtag_khz in interface/xxx.cfg would then, effectively,
+files, so any adapter_khz in interface/xxx.cfg will be overridden by
+target/xxx.cfg. adapter_khz in interface/xxx.cfg would then, effectively,
 set the default JTAG speed.
 
 Note that a target/xxx.cfg file can invoke another target/yyy.cfg file,
diff --git a/tcl/target/samsung_s3c2450.cfg b/tcl/target/samsung_s3c2450.cfg
index 071b271..0075426 100644
--- a/tcl/target/samsung_s3c2450.cfg
+++ b/tcl/target/samsung_s3c2450.cfg
@@ -7,11 +7,11 @@
 #
 # RCLK?
 #
-# jtag_khz 0
+# adapter_khz 0
 #
 # Really low clock during reset?
 #
-# jtag_khz 1
+# adapter_khz 1
 
 if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
diff --git a/tcl/target/stellaris.cfg b/tcl/target/stellaris.cfg
index 6fafac9..5f4428f 100644
--- a/tcl/target/stellaris.cfg
+++ b/tcl/target/stellaris.cfg
@@ -41,8 +41,8 @@ $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
 # NOTE:  this may be increased by a reset-init handler, after it
 # configures and enables the PLL.  Or you might need to decrease
 # this, if you're using a slower clock.
-jtag_khz 500
-$_TARGETNAME configure -event reset-start {jtag_khz 500}
+adapter_khz 500
+$_TARGETNAME configure -event reset-start {adapter_khz 500}
 
 # flash configuration ... autodetects sizes, autoprobed
 flash bank $_CHIPNAME.flash stellaris 0 0 0 0 $_TARGETNAME
diff --git a/tcl/target/stm32.cfg b/tcl/target/stm32.cfg
index 463a85c..29c9f7f 100644
--- a/tcl/target/stm32.cfg
+++ b/tcl/target/stm32.cfg
@@ -21,7 +21,7 @@ if { [info exists WORKAREASIZE] } {
 }
 
 # JTAG speed should be <= F_CPU/6. F_CPU after reset is 8MHz, so use F_JTAG = 1MHz
-jtag_khz 1000
+adapter_khz 1000
 
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
diff --git a/tcl/target/str710.cfg b/tcl/target/str710.cfg
index 028c604..4d68586 100644
--- a/tcl/target/str710.cfg
+++ b/tcl/target/str710.cfg
@@ -1,5 +1,5 @@
 #start slow, speed up after reset
-jtag_khz 10
+adapter_khz 10
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
@@ -29,9 +29,9 @@ jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_C
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 
-$_TARGETNAME configure -event reset-start { jtag_khz 10 }
+$_TARGETNAME configure -event reset-start { adapter_khz 10 }
 $_TARGETNAME configure -event reset-init {
-	jtag_khz 6000
+	adapter_khz 6000
 
 # Because the hardware cannot be interrogated for the protection state
 # of sectors, initialize all the sectors to be unprotected. The initial
diff --git a/tcl/target/str730.cfg b/tcl/target/str730.cfg
index 0917953..3a84897 100644
--- a/tcl/target/str730.cfg
+++ b/tcl/target/str730.cfg
@@ -1,6 +1,6 @@
 #STR730 CPU
 
-jtag_khz 3000
+adapter_khz 3000
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
@@ -33,9 +33,9 @@ jtag_ntrst_delay 500
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
 
-$_TARGETNAME configure -event reset-start { jtag_khz 10 }
+$_TARGETNAME configure -event reset-start { adapter_khz 10 }
 $_TARGETNAME configure -event reset-init {
-	jtag_khz 3000
+	adapter_khz 3000
 
 # Because the hardware cannot be interrogated for the protection state
 # of sectors, initialize all the sectors to be unprotected. The initial
diff --git a/tcl/target/str750.cfg b/tcl/target/str750.cfg
index c467ae2..c2fb786 100644
--- a/tcl/target/str750.cfg
+++ b/tcl/target/str750.cfg
@@ -19,7 +19,7 @@ if { [info exists CPUTAPID] } {
 }
 
 # jtag speed
-jtag_khz 10
+adapter_khz 10
 
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config trst_and_srst srst_pulls_trst
@@ -35,9 +35,9 @@ jtag_ntrst_delay 500
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
 
-$_TARGETNAME configure -event reset-start  { jtag_khz 10 }
+$_TARGETNAME configure -event reset-start  { adapter_khz 10 }
 $_TARGETNAME configure -event reset-init {
-	jtag_khz 3000
+	adapter_khz 3000
 
 # Because the hardware cannot be interrogated for the protection state
 # of sectors, initialize all the sectors to be unprotected. The initial
diff --git a/tcl/target/telo.cfg b/tcl/target/telo.cfg
index 0cbdb81..99b9cd6 100644
--- a/tcl/target/telo.cfg
+++ b/tcl/target/telo.cfg
@@ -26,12 +26,12 @@ reset_config trst_and_srst separate
 # issue telnet: reset init
 # issue gdb: monitor reset init
 $_TARGETNAME configure -event reset-init {
-	jtag_khz 100
+	adapter_khz 100
 	# this will setup Telo board
 	setupTelo
 	#turn up the JTAG speed
-	jtag_khz 3000
-	puts "JTAG speek now 3MHz"
+	adapter_khz 3000
+	puts "JTAG speed now 3MHz"
 	puts "type helpC100 to get help on C100"
 }
 
@@ -58,4 +58,4 @@ set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME cfi 0x20000000 0x01000000 2 2 $_TARGETNAME
 
 # writing data to memory does not work without this
-memwrite burst disable
\ No newline at end of file
+memwrite burst disable

-----------------------------------------------------------------------

Summary of changes:
 NEWS                                         |    7 ++
 doc/openocd.texi                             |   24 ++++----
 src/jtag/core.c                              |   30 +++++-----
 src/jtag/drivers/presto.c                    |    4 +-
 src/jtag/startup.tcl                         |   12 ++++
 src/jtag/tcl.c                               |   79 +++++++++++++-------------
 src/svf/svf.c                                |    2 +-
 tcl/board/at91eb40a.cfg                      |    2 +-
 tcl/board/at91rm9200-dk.cfg                  |    4 +-
 tcl/board/at91sam9g20-ek.cfg                 |    6 +-
 tcl/board/crossbow_tech_imote2.cfg           |    2 +-
 tcl/board/csb337.cfg                         |    4 +-
 tcl/board/csb732.cfg                         |    2 +-
 tcl/board/digi_connectcore_wi-9c.cfg         |    2 +-
 tcl/board/dm365evm.cfg                       |    2 +-
 tcl/board/ek-lm3s1968.cfg                    |    6 +-
 tcl/board/ek-lm3s811.cfg                     |    4 +-
 tcl/board/ek-lm3s9b9x.cfg                    |    4 +-
 tcl/board/ethernut3.cfg                      |    4 +-
 tcl/board/hitex_lpc2929.cfg                  |    8 +-
 tcl/board/hitex_str9-comstick.cfg            |    4 +-
 tcl/board/imx27lnst.cfg                      |    2 +-
 tcl/board/lubbock.cfg                        |    2 +-
 tcl/board/mini2440.cfg                       |    6 +-
 tcl/board/phytec_lpc3250.cfg                 |    8 +-
 tcl/board/pxa255_sst.cfg                     |    2 +-
 tcl/board/telo.cfg                           |    8 +-
 tcl/board/topas910.cfg                       |    2 +-
 tcl/board/topasa900.cfg                      |    2 +-
 tcl/board/zy1000.cfg                         |    2 +-
 tcl/interface/altera-usb-blaster.cfg         |    2 +-
 tcl/interface/calao-usb-a9260.cfg            |    2 +-
 tcl/interface/oocdlink.cfg                   |    2 +-
 tcl/interface/openrd.cfg                     |    2 +-
 tcl/interface/sheevaplug.cfg                 |    2 +-
 tcl/interface/usb-jtag.cfg                   |    2 +-
 tcl/interface/vsllink.cfg                    |    4 +-
 tcl/target/aduc702x.cfg                      |    2 +-
 tcl/target/ar71xx.cfg                        |    2 +-
 tcl/target/at91sam9260.cfg                   |    2 +-
 tcl/target/at91sam9260_ext_RAM_ext_flash.cfg |    8 +-
 tcl/target/at91sam9rl.cfg                    |    2 +-
 tcl/target/c100.cfg                          |    2 +-
 tcl/target/c100helper.tcl                    |    2 +-
 tcl/target/dragonite.cfg                     |    2 +-
 tcl/target/dsp56321.cfg                      |    2 +-
 tcl/target/epc9301.cfg                       |    2 +-
 tcl/target/feroceon.cfg                      |    2 +-
 tcl/target/imx31.cfg                         |    2 +-
 tcl/target/lm3s6965.cfg                      |    4 +-
 tcl/target/lpc1768.cfg                       |    2 +-
 tcl/target/lpc2103.cfg                       |    2 +-
 tcl/target/lpc2124.cfg                       |    4 +-
 tcl/target/lpc2129.cfg                       |    2 +-
 tcl/target/lpc2148.cfg                       |    2 +-
 tcl/target/lpc2294.cfg                       |    2 +-
 tcl/target/lpc2378.cfg                       |    4 +-
 tcl/target/lpc2478.cfg                       |    2 +-
 tcl/target/mc13224v.cfg                      |    2 +-
 tcl/target/mega128.cfg                       |    6 +-
 tcl/target/netx500.cfg                       |    2 +-
 tcl/target/omap5912.cfg                      |    2 +-
 tcl/target/pic32mx.cfg                       |    2 +-
 tcl/target/pxa255.cfg                        |    4 +-
 tcl/target/pxa270.cfg                        |    4 +-
 tcl/target/pxa3xx.cfg                        |    4 +-
 tcl/target/readme.txt                        |    6 +-
 tcl/target/samsung_s3c2450.cfg               |    4 +-
 tcl/target/samsung_s3c6410.cfg               |    2 +-
 tcl/target/smp8634.cfg                       |    2 +-
 tcl/target/stellaris.cfg                     |    4 +-
 tcl/target/stm32.cfg                         |    4 +-
 tcl/target/str710.cfg                        |    6 +-
 tcl/target/str730.cfg                        |    8 +-
 tcl/target/str750.cfg                        |    8 +-
 tcl/target/str912.cfg                        |    2 +-
 tcl/target/telo.cfg                          |   12 ++--
 tcl/target/tmpa900.cfg                       |    2 +-
 tcl/target/tmpa910.cfg                       |    2 +-
 tcl/target/xba_revA3.cfg                     |    2 +-
 tcl/test/syntax1.cfg                         |    2 +-
 81 files changed, 214 insertions(+), 194 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 16 10:37:48 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue, 16 Mar 2010 09:37:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-87-gf85ad1e
Message-ID: <E1NrTDh-0005zp-QQ@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f85ad1e52a499bc98ae9d559157e8adbe8a5ad1f (commit)
      from  a540033a71eb0b10bb8de85963781ec1b9c06cf1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f85ad1e52a499bc98ae9d559157e8adbe8a5ad1f
Author: Bradey Honsinger <bradeyh at gmail.com>
Date:   Mon Mar 15 08:43:41 2010 +0100

    image loading: fix problem with offsets > 0x80000000
    
    Fixes bug that prevented users from specifying a base address of
    0x80000000 or higher in image commands (flash write_image, etm image,
    xscale trace_image).
    
    image.base_address is an offset from the start address contained in
    the image file (if there is one), or from 0 (for binary files). As a
    signed 32-bit int, it couldn't be greater than 0x7fffffff, which is a
    problem when trying to write a binary file to flash above that
    address. Changing it to a 64-bit long long keeps it as a signed
    offset, but allows it to cover the entire 32-bit address space.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index a40230b..38cb655 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -434,7 +434,7 @@ COMMAND_HANDLER(handle_flash_write_image_command)
 	if (CMD_ARGC >= 2)
 	{
 		image.base_address_set = 1;
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], image.base_address);
+		COMMAND_PARSE_NUMBER(llong, CMD_ARGV[1], image.base_address);
 	}
 	else
 	{
diff --git a/src/target/etm.c b/src/target/etm.c
index 10ab72a..67dac06 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -1761,7 +1761,7 @@ COMMAND_HANDLER(handle_etm_image_command)
 	if (CMD_ARGC >= 2)
 	{
 		etm_ctx->image->base_address_set = 1;
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], etm_ctx->image->base_address);
+		COMMAND_PARSE_NUMBER(llong, CMD_ARGV[1], etm_ctx->image->base_address);
 	}
 	else
 	{
diff --git a/src/target/image.h b/src/target/image.h
index e963b3c..b096031 100644
--- a/src/target/image.h
+++ b/src/target/image.h
@@ -62,7 +62,7 @@ struct image
 	int num_sections;		/* number of sections contained in the image */
 	struct imageection *sections;	/* array of sections */
 	int base_address_set;	/* whether the image has a base address set (for relocation purposes) */
-	int base_address;		/* base address, if one is set */
+	long long base_address;		/* base address, if one is set */
 	int start_address_set;	/* whether the image has a start address (entry point) associated */
 	uint32_t start_address;		/* start address, if one is set */
 };
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 50c9595..dd4a7ee 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3419,7 +3419,7 @@ COMMAND_HANDLER(xscale_handle_trace_image_command)
 	if (CMD_ARGC >= 2)
 	{
 		xscale->trace.image->base_address_set = 1;
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], xscale->trace.image->base_address);
+		COMMAND_PARSE_NUMBER(llong, CMD_ARGV[1], xscale->trace.image->base_address);
 	}
 	else
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/tcl.c |    2 +-
 src/target/etm.c    |    2 +-
 src/target/image.h  |    2 +-
 src/target/xscale.c |    2 +-
 4 files changed, 4 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 16 10:47:18 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue, 16 Mar 2010 09:47:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-88-gab5f98e
Message-ID: <E1NrTMt-0001Zd-RA@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ab5f98edcd3e8810c15d378d3244238d9d8f8d0e (commit)
      from  f85ad1e52a499bc98ae9d559157e8adbe8a5ad1f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ab5f98edcd3e8810c15d378d3244238d9d8f8d0e
Author: richard vegh <vegh.ricsi at gmail.com>
Date:   Tue Mar 16 10:46:41 2010 +0100

    lpc3180: LPC3180(LPC3250) SLC driver implemented
    
    Until this time only basic  SLC functionality exists when you want to use SLC to access external nand flash.
    Basic functionality can be selected with command:
         lpc3180 select 0 slc
    It is anyway very slow to write/read to/from nand flash.
    
    With the new command, SLC speed improved about 20 times, and hardware ECC info also read/written from/to nand flash OOB area:
         lpc3180 select 0 slc bulk
    Speed improvement achieved by using working are in SRAM of the LPC3250 chip and controlling DMA controller to interact between SRAM and SLC peripheral.
    
    Here are the patches, and if they are ok than take them.
    Tested with hitex LPC3250 usb stick.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index acb5f58..6562e04 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -1,6 +1,9 @@
 /***************************************************************************
  *   Copyright (C) 2007 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
+ *
+ *   Copyright (C) 2010 richard vegh <vegh.ricsi at gmail.com>                *
+ *   Copyright (C) 2010 Oyvind Harboe <oyvind.harboe at zylin.com>            *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -28,6 +31,13 @@
 
 static int lpc3180_reset(struct nand_device *nand);
 static int lpc3180_controller_ready(struct nand_device *nand, int timeout);
+static int lpc3180_tc_ready(struct nand_device *nand, int timeout);
+
+
+#define ECC_OFFS   0x120
+#define SPARE_OFFS 0x140
+#define DATA_OFFS   0x200
+
 
 /* nand device lpc3180 <target#> <oscillator_frequency>
  */
@@ -253,8 +263,21 @@ static int lpc3180_init(struct nand_device *nand)
 		/* FLASHCLK_CTRL = 0x05 (enable clock for SLC flash controller) */
 		target_write_u32(target, 0x400040c8, 0x05);
 
-		/* SLC_CFG = 0x (Force nCE assert, ECC enabled, WIDTH = bus_width) */
-		target_write_u32(target, 0x20020014, 0x28 | (bus_width == 16) ? 1 : 0);
+		/* after reset set other registers of SLC so reset calling is here at the begining*/
+		lpc3180_reset(nand);
+
+		/* SLC_CFG = 0x (Force nCE assert, DMA ECC enabled, ECC enabled, DMA burst enabled, DMA read from SLC, WIDTH = bus_width) */
+		target_write_u32(target, 0x20020014, 0x3e | (bus_width == 16) ? 1 : 0);
+
+		/* SLC_IEN = 3 (INT_RDY_EN = 1) ,(INT_TC_STAT = 1) */
+		target_write_u32(target, 0x20020020, 0x03);
+
+		/* DMA configuration */
+		/* DMACLK_CTRL = 0x01 (enable clock for DMA controller) */
+		target_write_u32(target, 0x400040e8, 0x01);
+		/* DMACConfig = DMA enabled*/
+		target_write_u32(target, 0x31000030, 0x01);
+            
 
 		/* calculate NAND controller timings */
 		cycle = lpc3180_cycle_time(lpc3180_info);
@@ -270,7 +293,6 @@ static int lpc3180_init(struct nand_device *nand)
 			((r_width & 0xf) << 8) | ((r_rdy & 0xf) << 12) |  ((w_setup & 0xf) << 16) |
 			((w_hold & 0xf) << 20) | ((w_width & 0xf) << 24) | ((w_rdy & 0xf) << 28));
 
-		lpc3180_reset(nand);
 	}
 
 	return ERROR_OK;
@@ -476,6 +498,7 @@ static int lpc3180_write_page(struct nand_device *nand, uint32_t page, uint8_t *
 	struct target *target = lpc3180_info->target;
 	int retval;
 	uint8_t status;
+	uint8_t *page_buffer;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -490,7 +513,6 @@ static int lpc3180_write_page(struct nand_device *nand, uint32_t page, uint8_t *
 	}
 	else if (lpc3180_info->selected_controller == LPC3180_MLC_CONTROLLER)
 	{
-		uint8_t *page_buffer;
 		uint8_t *oob_buffer;
 		int quarter, num_quarters;
 
@@ -606,8 +628,202 @@ static int lpc3180_write_page(struct nand_device *nand, uint32_t page, uint8_t *
 	}
 	else if (lpc3180_info->selected_controller == LPC3180_SLC_CONTROLLER)
 	{
+    
+               /**********************************************************************
+               *     Write both SLC NAND flash page main area and spare area.
+               *     Small page -
+               *      ------------------------------------------
+               *     |    512 bytes main   |   16 bytes spare   |
+               *      ------------------------------------------
+               *     Large page -
+               *      ------------------------------------------
+               *     |   2048 bytes main   |   64 bytes spare   |
+               *      ------------------------------------------
+               *     If DMA & ECC enabled, then the ECC generated for the 1st 256-byte
+               *     data is written to the 3rd word of the spare area. The ECC
+               *     generated for the 2nd 256-byte data is written to the 4th word
+               *     of the spare area. The ECC generated for the 3rd 256-byte data is
+               *     written to the 7th word of the spare area. The ECC generated
+               *     for the 4th 256-byte data is written to the 8th word of the
+               *     spare area and so on.
+               *
+               **********************************************************************/
+        
+               int retval,i=0,target_mem_base;
+               uint8_t *ecc_flash_buffer;
+               struct working_area *pworking_area;
+    
+  
+                if(lpc3180_info->is_bulk){
+
+                    if (!data && oob){
+                        /*if oob only mode is active original method is used as SLC controller hangs during DMA interworking. Anyway the code supports the oob only mode below. */
 		return nand_write_page_raw(nand, page, data, data_size, oob, oob_size);
 	}
+                    retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
+                    if (ERROR_OK != retval)
+                        return retval;
+    
+                    /* allocate a working area */
+                    if (target->working_area_size < (uint32_t) nand->page_size + 0x200){
+                        LOG_ERROR("Reserve at least 0x%x physical target working area",nand->page_size + 0x200);
+                        return ERROR_FLASH_OPERATION_FAILED;
+                    }
+                    if (target->working_area_phys%4){
+                        LOG_ERROR("Reserve the physical target working area at word boundary");
+                        return ERROR_FLASH_OPERATION_FAILED;
+                    }
+                    if (target_alloc_working_area(target, target->working_area_size, &pworking_area) != ERROR_OK)
+                    {
+                        LOG_ERROR("no working area specified, can't read LPC internal flash");
+                        return ERROR_FLASH_OPERATION_FAILED;
+                    }
+                    target_mem_base = target->working_area_phys;
+        
+    
+                    if (nand->page_size == 2048)
+                    {
+                        page_buffer = malloc(2048);
+                    }
+                    else
+                    {
+                        page_buffer = malloc(512);
+                    }
+                    
+                    ecc_flash_buffer = malloc(64);
+                    
+                    /* SLC_CFG = 0x (Force nCE assert, DMA ECC enabled, ECC enabled, DMA burst enabled, DMA write to SLC, WIDTH = bus_width) */
+                    target_write_u32(target, 0x20020014, 0x3c);
+    
+                    if( data && !oob){
+                        /* set DMA LLI-s in target memory and in DMA*/
+                        for(i=0;i<nand->page_size/0x100;i++){
+        
+                            int tmp;
+                            /* -------LLI for 256 byte block---------*/
+                            /* DMACC0SrcAddr = SRAM */
+                            target_write_u32(target,target_mem_base+0+i*32,target_mem_base+DATA_OFFS+i*256 );
+                            if(i==0) target_write_u32(target,0x31000100,target_mem_base+DATA_OFFS );
+                            /* DMACCxDestAddr = SLC_DMA_DATA */
+                            target_write_u32(target,target_mem_base+4+i*32,0x20020038 );
+                            if(i==0)  target_write_u32(target,0x31000104,0x20020038 );
+                            /* DMACCxLLI = next element */
+                            tmp = (target_mem_base+(1+i*2)*16)&0xfffffffc;
+                            target_write_u32(target,target_mem_base+8+i*32, tmp );
+                            if(i==0) target_write_u32(target,0x31000108, tmp );
+                            /* DMACCxControl =  TransferSize =64, Source burst size =16, Destination burst size = 16, Source transfer width = 32 bit, 
+                            Destination transfer width = 32 bit, Source AHB master select = M0, Destination AHB master select = M0, Source increment = 1,
+                            Destination increment = 0, Terminal count interrupt enable bit = 0*/       
+                            target_write_u32(target,target_mem_base+12+i*32,0x40 | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 1<<26 | 0<<27| 0<<31);
+                            if(i==0) target_write_u32(target,0x3100010c,0x40 | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 1<<26 | 0<<27| 0<<31);
+        
+                            /* -------LLI for 3 byte ECC---------*/
+                            /* DMACC0SrcAddr = SLC_ECC*/
+                            target_write_u32(target,target_mem_base+16+i*32,0x20020034 );
+                            /* DMACCxDestAddr = SRAM */
+                            target_write_u32(target,target_mem_base+20+i*32,target_mem_base+SPARE_OFFS+8+16*(i>>1)+(i%2)*4 );
+                            /* DMACCxLLI = next element */
+                                tmp = (target_mem_base+(2+i*2)*16)&0xfffffffc;
+                            target_write_u32(target,target_mem_base+24+i*32, tmp );
+                            /* DMACCxControl =  TransferSize =1, Source burst size =4, Destination burst size = 4, Source transfer width = 32 bit, 
+                            Destination transfer width = 32 bit, Source AHB master select = M0, Destination AHB master select = M0, Source increment = 0,
+                            Destination increment = 1, Terminal count interrupt enable bit = 0*/       
+                            target_write_u32(target,target_mem_base+28+i*32,0x01 | 1<<12 | 1<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 0<<26 | 1<<27| 0<<31);
+                        }
+                    }
+                    else if (data && oob){
+                        /* -------LLI for 512 or 2048 bytes page---------*/
+                        /* DMACC0SrcAddr = SRAM */
+                        target_write_u32(target,target_mem_base,target_mem_base+DATA_OFFS );
+                        target_write_u32(target,0x31000100,target_mem_base+DATA_OFFS );
+                        /* DMACCxDestAddr = SLC_DMA_DATA */
+                        target_write_u32(target,target_mem_base+4,0x20020038 );
+                        target_write_u32(target,0x31000104,0x20020038 );
+                        /* DMACCxLLI = next element */
+                        target_write_u32(target,target_mem_base+8, (target_mem_base+32)&0xfffffffc );
+                        target_write_u32(target,0x31000108, (target_mem_base+32)&0xfffffffc );
+                        /* DMACCxControl =  TransferSize =512 or 128, Source burst size =16, Destination burst size = 16, Source transfer width = 32 bit, 
+                        Destination transfer width = 32 bit, Source AHB master select = M0, Destination AHB master select = M0, Source increment = 1,
+                        Destination increment = 0, Terminal count interrupt enable bit = 0*/       
+                        target_write_u32(target,target_mem_base+12,(nand->page_size==2048?512:128) | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 1<<26 | 0<<27| 0<<31);
+                        target_write_u32(target,0x3100010c,(nand->page_size==2048?512:128) | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 1<<26 | 0<<27| 0<<31);
+                        i = 1;
+                    }
+                    else if (!data && oob){
+                        i = 0;
+                    }
+    
+                    /* -------LLI for spare area---------*/
+                    /* DMACC0SrcAddr = SRAM*/
+                    target_write_u32(target,target_mem_base+0+i*32,target_mem_base+SPARE_OFFS );
+                    if(i==0) target_write_u32(target,0x31000100,target_mem_base+SPARE_OFFS );
+                    /* DMACCxDestAddr = SLC_DMA_DATA */
+                    target_write_u32(target,target_mem_base+4+i*32,0x20020038 );
+                    if(i==0) target_write_u32(target,0x31000104,0x20020038 );
+                    /* DMACCxLLI = next element = NULL */
+                    target_write_u32(target,target_mem_base+8+i*32, 0 );
+                    if(i==0) target_write_u32(target,0x31000108,0 );
+                    /* DMACCxControl =  TransferSize =16 for large page or 4 for small page, Source burst size =16, Destination burst size = 16, Source transfer width = 32 bit, 
+                    Destination transfer width = 32 bit, Source AHB master select = M0, Destination AHB master select = M0, Source increment = 1,
+                    Destination increment = 0, Terminal count interrupt enable bit = 0*/       
+                    target_write_u32(target,target_mem_base+12+i*32, (nand->page_size==2048?0x10:0x04) | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 1<<26 | 0<<27| 0<<31);
+                    if(i==0) target_write_u32(target,0x3100010c,(nand->page_size==2048?0x10:0x04) | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 1<<26 | 0<<27| 0<<31 );
+
+
+
+                    memset(ecc_flash_buffer, 0xff, 64);
+                    if( oob ){
+                        memcpy(ecc_flash_buffer,oob, oob_size);
+                    }
+                    target_write_memory(target, target_mem_base+SPARE_OFFS, 4, 16, ecc_flash_buffer);
+                    
+                    if (data){
+                        memset(page_buffer, 0xff, nand->page_size == 2048?2048:512);
+                        memcpy(page_buffer,data, data_size);
+                        target_write_memory(target, target_mem_base+DATA_OFFS, 4, nand->page_size == 2048?512:128, page_buffer);
+                    }
+
+                    free(page_buffer);
+                    free(ecc_flash_buffer);
+
+                    /* Enable DMA after channel set up ! 
+                        LLI only works when DMA is the flow controller!
+                    */
+                    /* DMACCxConfig= E=1, SrcPeripheral = 1 (SLC), DestPeripheral = 1 (SLC), FlowCntrl = 2 (Pher -> Mem, DMA), IE = 0, ITC = 0, L= 0, H=0*/
+                    target_write_u32(target,0x31000110,   1 | 1<<1 | 1<<6 | 2<<11 | 0<<14 | 0<<15 | 0<<16 | 0<<18);
+    
+    
+                            
+                     /* SLC_CTRL = 3 (START DMA), ECC_CLEAR */
+                     target_write_u32(target, 0x20020010, 0x3);
+    
+                    /* SLC_ICR = 2, INT_TC_CLR, clear pending TC*/
+                     target_write_u32(target, 0x20020028, 2);
+    
+                    /* SLC_TC */
+                    if (!data && oob)
+                       target_write_u32(target, 0x20020030,  (nand->page_size==2048?0x10:0x04));
+                    else
+                       target_write_u32(target, 0x20020030,  (nand->page_size==2048?0x840:0x210));
+
+                    nand_write_finish(nand);
+
+                    
+                    if (!lpc3180_tc_ready(nand, 1000))
+                    {
+                        LOG_ERROR("timeout while waiting for completion of DMA");
+                        return ERROR_NAND_OPERATION_FAILED;
+                    }
+
+                target_free_working_area(target,pworking_area);
+
+                LOG_INFO("Page =  0x%x was written.",page);
+    
+                }
+                else
+                    return nand_write_page_raw(nand, page, data, data_size, oob, oob_size);
+        }
+
 
 	return ERROR_OK;
 }
@@ -616,6 +832,7 @@ static int lpc3180_read_page(struct nand_device *nand, uint32_t page, uint8_t *d
 {
 	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
 	struct target *target = lpc3180_info->target;
+	uint8_t *page_buffer;
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -630,7 +847,6 @@ static int lpc3180_read_page(struct nand_device *nand, uint32_t page, uint8_t *d
 	}
 	else if (lpc3180_info->selected_controller == LPC3180_MLC_CONTROLLER)
 	{
-		uint8_t *page_buffer;
 		uint8_t *oob_buffer;
 		uint32_t page_bytes_done = 0;
 		uint32_t oob_bytes_done = 0;
@@ -753,6 +969,174 @@ static int lpc3180_read_page(struct nand_device *nand, uint32_t page, uint8_t *d
 	}
 	else if (lpc3180_info->selected_controller == LPC3180_SLC_CONTROLLER)
 	{
+
+           /**********************************************************************
+           *     Read both SLC NAND flash page main area and spare area.
+           *     Small page -
+           *      ------------------------------------------
+           *     |    512 bytes main   |   16 bytes spare   |
+           *      ------------------------------------------
+           *     Large page -
+           *      ------------------------------------------
+           *     |   2048 bytes main   |   64 bytes spare   |
+           *      ------------------------------------------
+           *     If DMA & ECC enabled, then the ECC generated for the 1st 256-byte
+           *     data is compared with the 3rd word of the spare area. The ECC
+           *     generated for the 2nd 256-byte data is compared with the 4th word
+           *     of the spare area. The ECC generated for the 3rd 256-byte data is
+           *     compared with the 7th word of the spare area. The ECC generated
+           *     for the 4th 256-byte data is compared with the 8th word of the
+           *     spare area and so on.
+           *
+           **********************************************************************/
+    
+           int retval,i,target_mem_base;
+           uint8_t *ecc_hw_buffer;
+           uint8_t *ecc_flash_buffer;
+           struct working_area *pworking_area;
+
+           if(lpc3180_info->is_bulk){
+
+                /* read always the data and also oob areas*/
+                
+                retval = nand_page_command(nand, page, NAND_CMD_READ0, 0);
+                if (ERROR_OK != retval)
+                	return retval;
+
+                /* allocate a working area */
+                if (target->working_area_size < (uint32_t) nand->page_size + 0x200){
+                    LOG_ERROR("Reserve at least 0x%x physical target working area",nand->page_size + 0x200);
+                    return ERROR_FLASH_OPERATION_FAILED;
+                }
+                if (target->working_area_phys%4){
+                    LOG_ERROR("Reserve the physical target working area at word boundary");
+                    return ERROR_FLASH_OPERATION_FAILED;
+                }
+                if (target_alloc_working_area(target, target->working_area_size, &pworking_area) != ERROR_OK)
+                {
+                    LOG_ERROR("no working area specified, can't read LPC internal flash");
+                    return ERROR_FLASH_OPERATION_FAILED;
+                }
+                target_mem_base = target->working_area_phys;
+
+                if (nand->page_size == 2048)
+                {
+                    page_buffer = malloc(2048);
+                }
+                else
+                {
+                    page_buffer = malloc(512);
+                }
+                
+                ecc_hw_buffer = malloc(32);
+                ecc_flash_buffer = malloc(64);
+                
+                /* SLC_CFG = 0x (Force nCE assert, DMA ECC enabled, ECC enabled, DMA burst enabled, DMA read from SLC, WIDTH = bus_width) */
+                target_write_u32(target, 0x20020014, 0x3e);
+
+                /* set DMA LLI-s in target memory and in DMA*/
+                for(i=0;i<nand->page_size/0x100;i++){
+                    int tmp;
+                    /* -------LLI for 256 byte block---------*/
+                    /* DMACC0SrcAddr = SLC_DMA_DATA*/
+                    target_write_u32(target,target_mem_base+0+i*32,0x20020038 );
+                    if(i==0) target_write_u32(target,0x31000100,0x20020038 );
+                    /* DMACCxDestAddr = SRAM */
+                    target_write_u32(target,target_mem_base+4+i*32,target_mem_base+DATA_OFFS+i*256 );
+                    if(i==0)  target_write_u32(target,0x31000104,target_mem_base+DATA_OFFS );
+                    /* DMACCxLLI = next element */
+                    tmp = (target_mem_base+(1+i*2)*16)&0xfffffffc;
+                    target_write_u32(target,target_mem_base+8+i*32, tmp );
+                    if(i==0) target_write_u32(target,0x31000108, tmp );
+                    /* DMACCxControl =  TransferSize =64, Source burst size =16, Destination burst size = 16, Source transfer width = 32 bit, 
+                    Destination transfer width = 32 bit, Source AHB master select = M0, Destination AHB master select = M0, Source increment = 0,
+                    Destination increment = 1, Terminal count interrupt enable bit = 0*/       
+                    target_write_u32(target,target_mem_base+12+i*32,0x40 | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 0<<26 | 1<<27| 0<<31);
+                    if(i==0) target_write_u32(target,0x3100010c,0x40 | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 0<<26 | 1<<27| 0<<31);
+
+                    /* -------LLI for 3 byte ECC---------*/
+                    /* DMACC0SrcAddr = SLC_ECC*/
+                    target_write_u32(target,target_mem_base+16+i*32,0x20020034 );
+                    /* DMACCxDestAddr = SRAM */
+                    target_write_u32(target,target_mem_base+20+i*32,target_mem_base+ECC_OFFS+i*4 );
+                    /* DMACCxLLI = next element */
+                    tmp = (target_mem_base+(2+i*2)*16)&0xfffffffc;
+                    target_write_u32(target,target_mem_base+24+i*32, tmp );
+                    /* DMACCxControl =  TransferSize =1, Source burst size =4, Destination burst size = 4, Source transfer width = 32 bit, 
+                    Destination transfer width = 32 bit, Source AHB master select = M0, Destination AHB master select = M0, Source increment = 0,
+                    Destination increment = 1, Terminal count interrupt enable bit = 0*/       
+                    target_write_u32(target,target_mem_base+28+i*32,0x01 | 1<<12 | 1<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 0<<26 | 1<<27| 0<<31);
+
+
+                }
+
+                /* -------LLI for spare area---------*/
+                /* DMACC0SrcAddr = SLC_DMA_DATA*/
+                target_write_u32(target,target_mem_base+0+i*32,0x20020038 );
+                /* DMACCxDestAddr = SRAM */
+                target_write_u32(target,target_mem_base+4+i*32,target_mem_base+SPARE_OFFS );
+                /* DMACCxLLI = next element = NULL */
+                target_write_u32(target,target_mem_base+8+i*32, 0 );
+                /* DMACCxControl =  TransferSize =16 for large page or 4 for small page, Source burst size =16, Destination burst size = 16, Source transfer width = 32 bit, 
+                Destination transfer width = 32 bit, Source AHB master select = M0, Destination AHB master select = M0, Source increment = 0,
+                Destination increment = 1, Terminal count interrupt enable bit = 0*/       
+                target_write_u32(target,target_mem_base+12+i*32, (nand->page_size==2048?0x10:0x04) | 3<<12 | 3<<15 | 2<<18 | 2<<21 | 0<<24 | 0<<25 | 0<<26 | 1<<27| 0<<31);
+                
+                /* Enable DMA after channel set up ! 
+                    LLI only works when DMA is the flow controller!
+                */
+                /* DMACCxConfig= E=1, SrcPeripheral = 1 (SLC), DestPeripheral = 1 (SLC), FlowCntrl = 2 (Pher-> Mem, DMA), IE = 0, ITC = 0, L= 0, H=0*/
+                target_write_u32(target,0x31000110,   1 | 1<<1 | 1<<6 |  2<<11 | 0<<14 | 0<<15 | 0<<16 | 0<<18);
+
+                        
+                 /* SLC_CTRL = 3 (START DMA), ECC_CLEAR */
+                target_write_u32(target, 0x20020010, 0x3);
+
+                /* SLC_ICR = 2, INT_TC_CLR, clear pending TC*/
+                target_write_u32(target, 0x20020028, 2);
+
+                /* SLC_TC */
+                target_write_u32(target, 0x20020030,  (nand->page_size==2048?0x840:0x210));
+                
+                if (!lpc3180_tc_ready(nand, 1000))
+                {
+                    LOG_ERROR("timeout while waiting for completion of DMA");
+                    free(page_buffer);
+                    free(ecc_hw_buffer);
+                    free(ecc_flash_buffer);
+                    target_free_working_area(target,pworking_area);
+                    return ERROR_NAND_OPERATION_FAILED;
+                }
+
+                if (data){
+                    target_read_memory(target, target_mem_base+DATA_OFFS, 4, nand->page_size == 2048?512:128, page_buffer);
+                    memcpy(data, page_buffer, data_size);
+
+                    LOG_INFO("Page =  0x%x was read.",page);
+
+                    /* check hw generated ECC for each 256 bytes block with the saved ECC in flash spare area*/
+                    int idx = nand->page_size/0x200 ;
+                    target_read_memory(target, target_mem_base+SPARE_OFFS, 4, 16, ecc_flash_buffer);
+                    target_read_memory(target, target_mem_base+ECC_OFFS, 4, 8, ecc_hw_buffer);
+                    for(i=0;i<idx;i++){
+                        if( (0x00ffffff&*(uint32_t *)(ecc_hw_buffer+i*8)) != (0x00ffffff&*(uint32_t *)(ecc_flash_buffer+8+i*16)) )
+                            LOG_WARNING("ECC mismatch at 256 bytes size block= %d at page= 0x%x",i*2+1,page);
+                        if( (0x00ffffff&*(uint32_t *)(ecc_hw_buffer+4+i*8)) != (0x00ffffff&*(uint32_t *)(ecc_flash_buffer+12+i*16)) )
+                            LOG_WARNING("ECC mismatch at 256 bytes size block= %d at page= 0x%x",i*2+2,page);
+                    }                
+                }
+
+                if (oob)
+                    memcpy(oob, ecc_flash_buffer, oob_size);
+                
+                free(page_buffer);
+                free(ecc_hw_buffer);
+                free(ecc_flash_buffer);
+
+                target_free_working_area(target,pworking_area);
+
+            }
+            else
 		return nand_read_page_raw(nand, page, data, data_size, oob, oob_size);
 	}
 
@@ -855,6 +1239,42 @@ static int lpc3180_nand_ready(struct nand_device *nand, int timeout)
 	return 0;
 }
 
+static int lpc3180_tc_ready(struct nand_device *nand, int timeout)
+{
+	struct lpc3180_nand_controller *lpc3180_info = nand->controller_priv;
+	struct target *target = lpc3180_info->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("target must be halted to use LPC3180 NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+      LOG_DEBUG("lpc3180_tc_ready count start=%d", 
+                          timeout);
+
+	do
+	{
+		if (lpc3180_info->selected_controller == LPC3180_SLC_CONTROLLER)
+		{
+                   uint32_t status = 0x0;
+			/* Read SLC_INT_STAT and check INT_TC_STAT bit */
+			target_read_u32(target, 0x2002001c, &status);
+
+			if (status & 2){
+                        LOG_DEBUG("lpc3180_tc_ready count=%d",
+                                            timeout);
+                        return 1;
+                    }
+		}
+
+		alive_sleep(1);
+	} while (timeout-- > 0);
+
+	return 0;
+}
+
+
 COMMAND_HANDLER(handle_lpc3180_select_command)
 {
 	struct lpc3180_nand_controller *lpc3180_info = NULL;
@@ -863,7 +1283,7 @@ COMMAND_HANDLER(handle_lpc3180_select_command)
 		"no", "mlc", "slc"
 	};
 
-	if ((CMD_ARGC < 1) || (CMD_ARGC > 2))
+	if ((CMD_ARGC < 1) || (CMD_ARGC > 3))
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
@@ -879,7 +1299,7 @@ COMMAND_HANDLER(handle_lpc3180_select_command)
 
 	lpc3180_info = nand->controller_priv;
 
-	if (CMD_ARGC == 2)
+	if (CMD_ARGC >= 2)
 	{
 		if (strcmp(CMD_ARGV[1], "mlc") == 0)
 		{
@@ -888,6 +1308,12 @@ COMMAND_HANDLER(handle_lpc3180_select_command)
 		else if (strcmp(CMD_ARGV[1], "slc") == 0)
 		{
 			lpc3180_info->selected_controller = LPC3180_SLC_CONTROLLER;
+                   if (CMD_ARGC == 3 && strcmp(CMD_ARGV[2], "bulk") == 0){
+                        lpc3180_info->is_bulk = 1;
+                   }
+                   else{
+                        lpc3180_info->is_bulk = 0;
+                   }
 		}
 		else
 		{
@@ -895,7 +1321,12 @@ COMMAND_HANDLER(handle_lpc3180_select_command)
 		}
 	}
 
+      if (lpc3180_info->selected_controller == LPC3180_MLC_CONTROLLER)
 	command_print(CMD_CTX, "%s controller selected", selected[lpc3180_info->selected_controller]);
+      else{
+            command_print(CMD_CTX, lpc3180_info->is_bulk?"%s controller selected bulk mode is avaliable":"%s controller selected bulk mode is not avaliable", selected[lpc3180_info->selected_controller]);
+      }
+ 
 
 	return ERROR_OK;
 }
@@ -905,8 +1336,8 @@ static const struct command_registration lpc3180_exec_command_handlers[] = {
 		.name = "select",
 		.handler = handle_lpc3180_select_command,
 		.mode = COMMAND_EXEC,
-		.help = "select MLC or SLC controller (default is MLC)",
-		.usage = "bank_id ['mlc'|'slc']",
+		.help = "select MLC or SLC controller (default is MLC), SLC can be set to bulk mode",
+		.usage = "bank_id ['mlc'|'slc' ['bulk'] ]",
 	},
 	COMMAND_REGISTRATION_DONE
 };
diff --git a/src/flash/nand/lpc3180.h b/src/flash/nand/lpc3180.h
index 0891ced..88280f3 100644
--- a/src/flash/nand/lpc3180.h
+++ b/src/flash/nand/lpc3180.h
@@ -32,6 +32,7 @@ struct lpc3180_nand_controller
 	struct target *target;
 	int osc_freq;
 	enum lpc3180_selected_controller selected_controller;
+	int is_bulk;
 	int sw_write_protection;
 	uint32_t sw_wp_lower_bound;
 	uint32_t sw_wp_upper_bound;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/lpc3180.c |  449 +++++++++++++++++++++++++++++++++++++++++++++-
 src/flash/nand/lpc3180.h |    1 +
 2 files changed, 441 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Mar 16 11:13:08 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 16 Mar 2010 10:13:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-90-g679f660
Message-ID: <E1NrTlw-000315-52@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  679f6602fd1a7e9763bac52f06bbf2db28098d9a (commit)
       via  82f44a4708cdfdf2bf4b386a4751e6b43adad2b2 (commit)
      from  ab5f98edcd3e8810c15d378d3244238d9d8f8d0e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 679f6602fd1a7e9763bac52f06bbf2db28098d9a
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Mar 16 09:59:05 2010 +0000

    PARPORT: add PARPORTADDR tcl variable
    
    Add PARPORTADDR tcl variable making it easier to
    change parallel port address in scripts.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/interface/flashlink.cfg b/tcl/interface/flashlink.cfg
index 4b00de9..5c81cf5 100644
--- a/tcl/interface/flashlink.cfg
+++ b/tcl/interface/flashlink.cfg
@@ -5,6 +5,12 @@
 # http://www.st.com/stonline/products/literature/um/7889.pdf
 #
 
+if { [info exists PARPORTADDR] } {
+   set  _PARPORTADDR $PARPORTADDR
+} else {
+   set  _PARPORTADDR 0
+}
+
 interface parport
-parport_port 0
+parport_port $_PARPORTADDR
 parport_cable flashlink
diff --git a/tcl/interface/parport.cfg b/tcl/interface/parport.cfg
index 0f18ce9..326005a 100644
--- a/tcl/interface/parport.cfg
+++ b/tcl/interface/parport.cfg
@@ -3,6 +3,12 @@
 #
 # Addresses: 0x378/LPT1 or 0x278/LPT2 ...
 
+if { [info exists PARPORTADDR] } {
+   set  _PARPORTADDR $PARPORTADDR
+} else {
+   set  _PARPORTADDR 0x378
+}
+
 interface parport
-parport_port 0x378
+parport_port $_PARPORTADDR
 parport_cable wiggler
diff --git a/tcl/interface/parport_dlc5.cfg b/tcl/interface/parport_dlc5.cfg
index 85caefc..d0f183f 100644
--- a/tcl/interface/parport_dlc5.cfg
+++ b/tcl/interface/parport_dlc5.cfg
@@ -4,7 +4,13 @@
 # http://www.xilinx.com/itp/xilinx4/data/docs/pac/appendixb.html
 #
 
+if { [info exists PARPORTADDR] } {
+   set  _PARPORTADDR $PARPORTADDR
+} else {
+   set  _PARPORTADDR 0
+}
+
 interface parport
-parport_port 0
+parport_port $_PARPORTADDR
 parport_cable dlc5
 

commit 82f44a4708cdfdf2bf4b386a4751e6b43adad2b2
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Mar 16 09:55:20 2010 +0000

    PIC32: add Microchip Explorer16 cfg
    
    - add Microchip Explorer16 cfg using PIC32MX360F512L PIM.
     - remove reset config from PIC32 target cfg.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/microchip_explorer16.cfg b/tcl/board/microchip_explorer16.cfg
new file mode 100644
index 0000000..f5c4faa
--- /dev/null
+++ b/tcl/board/microchip_explorer16.cfg
@@ -0,0 +1,13 @@
+# Microchip Explorer 16 with PIC32MX360F512L PIM module.
+# http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=1406&dDocName=en024858
+
+# TAPID for PIC32MX360F512L
+set CPUTAPID 0x30938053
+
+# use 32k working area
+set WORKAREASIZE 32768
+
+source [find target/pic32mx.cfg]
+
+# For more information about the configuration files, take a look at:
+# openocd.texi
diff --git a/tcl/board/pic-p32mx.cfg b/tcl/board/pic-p32mx.cfg
index 412a506..661e3d6 100644
--- a/tcl/board/pic-p32mx.cfg
+++ b/tcl/board/pic-p32mx.cfg
@@ -2,7 +2,3 @@
 
 set CPUTAPID 0x40916053
 source [find target/pic32mx.cfg]
-
-init
-flash probe 0
-flash probe 1
diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index 8c9a93d..673d254 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -14,7 +14,7 @@ if { [info exists ENDIAN] } {
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
+   # force an error till we get a good number
    set _CPUTAPID 0x30938053
 }
 
@@ -29,9 +29,6 @@ if { [info exists WORKAREASIZE] } {
 adapter_nsrst_delay 100
 jtag_ntrst_delay 100
 
-#use combined on interfaces or targets that can't set TRST/SRST separately
-reset_config srst_only
-
 #jtag scan chain
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/microchip_explorer16.cfg |   13 +++++++++++++
 tcl/board/pic-p32mx.cfg            |    4 ----
 tcl/interface/flashlink.cfg        |    8 +++++++-
 tcl/interface/parport.cfg          |    8 +++++++-
 tcl/interface/parport_dlc5.cfg     |    8 +++++++-
 tcl/target/pic32mx.cfg             |    5 +----
 6 files changed, 35 insertions(+), 11 deletions(-)
 create mode 100644 tcl/board/microchip_explorer16.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Mar 16 21:45:47 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Tue, 16 Mar 2010 20:45:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-91-g030ee19
Message-ID: <E1NrdeA-0002s9-JR@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  030ee192dd9647b10ff0841a671facec9d6b833f (commit)
      from  679f6602fd1a7e9763bac52f06bbf2db28098d9a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 030ee192dd9647b10ff0841a671facec9d6b833f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 1 08:25:18 2010 +0100

    bitbang: add jtag_add_tms_seq support
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/drivers/at91rm9200.c b/src/jtag/drivers/at91rm9200.c
index abaf3ad..89d7000 100644
--- a/src/jtag/drivers/at91rm9200.c
+++ b/src/jtag/drivers/at91rm9200.c
@@ -126,6 +126,7 @@ struct jtag_interface at91rm9200_interface =
 {
 	.name = "at91rm9200",
 
+	.supported = DEBUG_CAP_TMS_SEQ,
 	.execute_queue = bitbang_execute_queue,
 
 	.speed = at91rm9200_speed,
diff --git a/src/jtag/drivers/bitbang.c b/src/jtag/drivers/bitbang.c
index 83c2d29..6159ef7 100644
--- a/src/jtag/drivers/bitbang.c
+++ b/src/jtag/drivers/bitbang.c
@@ -91,6 +91,31 @@ static void bitbang_state_move(int skip)
 	tap_set_state(tap_get_end_state());
 }
 
+
+/**
+ * Clock a bunch of TMS (or SWDIO) transitions, to change the JTAG
+ * (or SWD) state machine.
+ */
+static int bitbang_execute_tms(struct jtag_command *cmd)
+{
+	unsigned	num_bits = cmd->cmd.tms->num_bits;
+	const uint8_t	*bits = cmd->cmd.tms->bits;
+
+	DEBUG_JTAG_IO("TMS: %d bits", num_bits);
+
+	int tms = 0;
+	for (unsigned i = 0; i < num_bits; i++)
+	{
+		tms = ((bits[i/8] >> (i % 8)) & 1);
+		bitbang_interface->write(0, tms, 0);
+		bitbang_interface->write(1, tms, 0);
+	}
+	bitbang_interface->write(CLOCK_IDLE(), tms, 0);
+
+	return ERROR_OK;
+}
+
+
 static void bitbang_path_move(struct pathmove_command *cmd)
 {
 	int num_states = cmd->num_states;
@@ -312,6 +337,9 @@ int bitbang_execute_queue(void)
 #endif
 				jtag_sleep(cmd->cmd.sleep->us);
 				break;
+			case JTAG_TMS:
+				retval = bitbang_execute_tms(cmd);
+				break;
 			default:
 				LOG_ERROR("BUG: unknown JTAG command type encountered");
 				exit(-1);
diff --git a/src/jtag/drivers/dummy.c b/src/jtag/drivers/dummy.c
index 1880712..7cb0e33 100644
--- a/src/jtag/drivers/dummy.c
+++ b/src/jtag/drivers/dummy.c
@@ -164,6 +164,7 @@ static const struct command_registration dummy_command_handlers[] = {
 struct jtag_interface dummy_interface = {
 		.name = "dummy",
 
+		.supported = DEBUG_CAP_TMS_SEQ,
 		.commands = dummy_command_handlers,
 
 		.execute_queue = &bitbang_execute_queue,
diff --git a/src/jtag/drivers/ep93xx.c b/src/jtag/drivers/ep93xx.c
index 61dc76e..0959a56 100644
--- a/src/jtag/drivers/ep93xx.c
+++ b/src/jtag/drivers/ep93xx.c
@@ -57,6 +57,7 @@ struct jtag_interface ep93xx_interface =
 {
 	.name = "ep93xx",
 
+	.supported = DEBUG_CAP_TMS_SEQ,
 	.execute_queue = bitbang_execute_queue,
 
 	.speed = ep93xx_speed,
diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index fa3373b..2323ec5 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -524,6 +524,7 @@ static const struct command_registration parport_command_handlers[] = {
 
 struct jtag_interface parport_interface = {
 	.name = "parport",
+	.supported = DEBUG_CAP_TMS_SEQ,
 	.commands = parport_command_handlers,
 
 	.init = parport_init,
diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 3703323..59c5715 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -580,6 +580,7 @@ static const struct command_registration usb_blaster_command_handlers[] = {
 struct jtag_interface usb_blaster_interface = {
 	.name = "usb_blaster",
 	.commands = usb_blaster_command_handlers,
+	.supported = DEBUG_CAP_TMS_SEQ,
 
 	.execute_queue = bitbang_execute_queue,
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/at91rm9200.c  |    1 +
 src/jtag/drivers/bitbang.c     |   28 ++++++++++++++++++++++++++++
 src/jtag/drivers/dummy.c       |    1 +
 src/jtag/drivers/ep93xx.c      |    1 +
 src/jtag/drivers/parport.c     |    1 +
 src/jtag/drivers/usb_blaster.c |    1 +
 6 files changed, 33 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Mar 16 22:50:08 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue, 16 Mar 2010 21:50:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-92-g6f8b859
Message-ID: <E1NreeQ-00077e-OF@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6f8b8593d63bc9781435270a54b6f7d245eecd8e (commit)
      from  030ee192dd9647b10ff0841a671facec9d6b833f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6f8b8593d63bc9781435270a54b6f7d245eecd8e
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Mar 16 14:12:00 2010 -0700

    ADIv5 transport support moves to separate files
    
    Unclutter arm_adi_v5.c by moving most transport-specific code
    to a transport-specific files adi_v5_{jtag,swd}.c ... it's not
    a full cleanup, because of some issues which need to be addressed
    as part of SWD support (along with implementing the DAP operations
    on top of SWD transport):
    
     - The mess where mem_ap_read_buf_u32() is currently coded to
       know about JTAG scan chains, and thus needs rewriting before
       it will work with SWD;
    
     - Initialization is still JTAG-specific
    
    Also  move JTAG_{DP,ACK}_* constants from adi_v5.h to the JTAG
    file; no other code should care about those values.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index ad0ff7c..ea6d88f 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -83,6 +83,8 @@ ARM_DEBUG_SRC = \
 	arm_simulator.c \
 	arm_semihosting.c \
 	arm_adi_v5.c \
+ 	adi_v5_jtag.c \
+	adi_v5_swd.c \
 	embeddedice.c \
 	trace.c \
 	etb.c \
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
new file mode 100644
index 0000000..eac83b7
--- /dev/null
+++ b/src/target/adi_v5_jtag.c
@@ -0,0 +1,481 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Magnus Lundin
+ *   lundin at mlu.mine.nu
+ *
+ *   Copyright (C) 2008 by Spencer Oliver
+ *   spen at spen-soft.co.uk
+ *
+ *   Copyright (C) 2009 by Oyvind Harboe
+ *   oyvind.harboe at zylin.com
+ *
+ *   Copyright (C) 2009-2010 by David Brownell
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the
+ *   Free Software Foundation, Inc.,
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ ***************************************************************************/
+
+/**
+ * @file
+ * This file implements JTAG transport support for cores implementing
+ the ARM Debug Interface version 5 (ADIv5).
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm.h"
+#include "arm_adi_v5.h"
+#include <helper/time_support.h>
+
+
+/* JTAG instructions/registers for JTAG-DP and SWJ-DP */
+#define JTAG_DP_ABORT		0x8
+#define JTAG_DP_DPACC		0xA
+#define JTAG_DP_APACC		0xB
+#define JTAG_DP_IDCODE		0xE
+
+/* three-bit ACK values for DPACC and APACC reads */
+#define JTAG_ACK_OK_FAULT	0x2
+#define JTAG_ACK_WAIT		0x1
+
+/***************************************************************************
+ *
+ * DPACC and APACC scanchain access through JTAG-DP (or SWJ-DP)
+ *
+***************************************************************************/
+
+/**
+ * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
+ * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
+ * discusses operations which access these registers.
+ *
+ * Note that only one scan is performed.  If RnW is set, a separate scan
+ * will be needed to collect the data which was read; the "invalue" collects
+ * the posted result of a preceding operation, not the current one.
+ *
+ * @param swjdp the DAP
+ * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
+ * @param reg_addr two significant bits; A[3:2]; for APACC access, the
+ *	SELECT register has more addressing bits.
+ * @param RnW false iff outvalue will be written to the DP or AP
+ * @param outvalue points to a 32-bit (little-endian) integer
+ * @param invalue NULL, or points to a 32-bit (little-endian) integer
+ * @param ack points to where the three bit JTAG_ACK_* code will be stored
+ */
+
+/* FIXME don't export ... this is a temporary workaround for the
+ * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
+ */
+int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
+{
+	struct arm_jtag *jtag_info = swjdp->jtag_info;
+	struct scan_field fields[2];
+	uint8_t out_addr_buf;
+
+	jtag_set_end_state(TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, instr, NULL);
+
+	/* Scan out a read or write operation using some DP or AP register.
+	 * For APACC access with any sticky error flag set, this is discarded.
+	 */
+	fields[0].num_bits = 3;
+	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
+	fields[0].out_value = &out_addr_buf;
+	fields[0].in_value = ack;
+
+	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
+	 * complete; data we write is discarded, data we read is unpredictable.
+	 * When overrun detect is active, STICKYORUN is set.
+	 */
+
+	fields[1].num_bits = 32;
+	fields[1].out_value = outvalue;
+	fields[1].in_value = invalue;
+
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
+
+	/* Add specified number of tck clocks after starting memory bus
+	 * access, giving the hardware time to complete the access.
+	 * They provide more time for the (MEM) AP to complete the read ...
+	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
+	 */
+	if ((instr == JTAG_DP_APACC)
+			&& ((reg_addr == AP_REG_DRW)
+				|| ((reg_addr & 0xF0) == AP_REG_BD0))
+			&& (swjdp->memaccess_tck != 0))
+		jtag_add_runtest(swjdp->memaccess_tck,
+				jtag_set_end_state(TAP_IDLE));
+
+	return jtag_get_error();
+}
+
+/**
+ * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
+ * This is exactly like adi_jtag_dp_scan(), except that endianness
+ * conversions are performed (so the types of invalue and outvalue
+ * must be different).
+ */
+static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
+{
+	uint8_t out_value_buf[4];
+	int retval;
+
+	buf_set_u32(out_value_buf, 0, 32, outvalue);
+
+	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
+			out_value_buf, (uint8_t *)invalue, ack);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (invalue)
+		jtag_add_callback(arm_le_to_h_u32,
+				(jtag_callback_data_t) invalue);
+
+	return retval;
+}
+
+/**
+ * Utility to write AP registers.
+ */
+static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
+		uint8_t reg_addr, uint8_t *outvalue)
+{
+	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
+			outvalue, NULL, NULL);
+}
+
+static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue)
+{
+	int retval;
+
+	/* Issue the read or write */
+	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
+			RnW, outvalue, NULL, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* For reads,  collect posted value; RDBUFF has no other effect.
+	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
+	 */
+	if ((RnW == DPAP_READ) && (invalue != NULL))
+		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
+	return retval;
+}
+
+static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
+{
+	int retval;
+	uint32_t ctrlstat;
+
+	/* too expensive to call keep_alive() here */
+
+#if 0
+	/* Danger!!!! BROKEN!!!! */
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
+	R956 introduced the check on return value here and now Michael Schwingen reports
+	that this code no longer works....
+
+	https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html
+	*/
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		LOG_ERROR("BUG: Why does this fail the first time????");
+	}
+	/* Why??? second time it works??? */
+#endif
+
+	/* Post CTRL/STAT read; discard any previous posted read value
+	 * but collect its ACK status.
+	 */
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+		return retval;
+
+	swjdp->ack = swjdp->ack & 0x7;
+
+	/* common code path avoids calling timeval_ms() */
+	if (swjdp->ack != JTAG_ACK_OK_FAULT)
+	{
+		long long then = timeval_ms();
+
+		while (swjdp->ack != JTAG_ACK_OK_FAULT)
+		{
+			if (swjdp->ack == JTAG_ACK_WAIT)
+			{
+				if ((timeval_ms()-then) > 1000)
+				{
+					/* NOTE:  this would be a good spot
+					 * to use JTAG_DP_ABORT.
+					 */
+					LOG_WARNING("Timeout (1000ms) waiting "
+						"for ACK=OK/FAULT "
+						"in JTAG-DP transaction");
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+			else
+			{
+				LOG_WARNING("Invalid ACK %#x "
+						"in JTAG-DP transaction",
+						swjdp->ack);
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+			swjdp->ack = swjdp->ack & 0x7;
+		}
+	}
+
+	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
+
+	/* Check for STICKYERR and STICKYORUN */
+	if (ctrlstat & (SSTICKYORUN | SSTICKYERR))
+	{
+		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
+		/* Check power to debug regions */
+		if ((ctrlstat & 0xf0000000) != 0xf0000000)
+			 ahbap_debugport_init(swjdp);
+		else
+		{
+			uint32_t mem_ap_csw, mem_ap_tar;
+
+			/* Maybe print information about last intended
+			 * MEM-AP access; but not if autoincrementing.
+			 * *Real* CSW and TAR values are always shown.
+			 */
+			if (swjdp->ap_tar_value != (uint32_t) -1)
+				LOG_DEBUG("MEM-AP Cached values: "
+					"ap_bank 0x%" PRIx32
+					", ap_csw 0x%" PRIx32
+					", ap_tar 0x%" PRIx32,
+					swjdp->ap_bank_value,
+					swjdp->ap_csw_value,
+					swjdp->ap_tar_value);
+
+			if (ctrlstat & SSTICKYORUN)
+				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
+					"memaccess, or reduce jtag speed");
+
+			if (ctrlstat & SSTICKYERR)
+				LOG_ERROR("JTAG-DP STICKY ERROR");
+
+			/* Clear Sticky Error Bits */
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_WRITE,
+					swjdp->dp_ctrl_stat | SSTICKYORUN
+						| SSTICKYERR, NULL);
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+
+			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
+
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_CSW, &mem_ap_csw);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_TAR, &mem_ap_tar);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
+					PRIx32, mem_ap_csw, mem_ap_tar);
+
+		}
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
+			return retval;
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+
+	return ERROR_OK;
+}
+
+/*--------------------------------------------------------------------------*/
+
+static int jtag_idcode_q_read(struct adiv5_dap *dap,
+		uint8_t *ack, uint32_t *data)
+{
+	struct arm_jtag *jtag_info = dap->jtag_info;
+	int retval;
+	struct scan_field fields[1];
+
+	jtag_set_end_state(TAP_IDLE);
+
+	/* This is a standard JTAG operation -- no DAP tweakage */
+	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	fields[0].num_bits = 32;
+	fields[0].out_value = NULL;
+	fields[0].in_value = (void *) data;
+
+	jtag_add_dr_scan(jtag_info->tap, 1, fields, jtag_get_end_state());
+	retval = jtag_get_error();
+	if (retval != ERROR_OK)
+		return retval;
+
+	jtag_add_callback(arm_le_to_h_u32,
+			(jtag_callback_data_t) data);
+
+	return retval;
+}
+
+static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_READ, 0, data);
+}
+
+static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_WRITE, data, NULL);
+}
+
+/** Select the AP register bank matching bits 7:4 of reg. */
+static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
+{
+	uint32_t select = reg & 0x000000F0;
+
+	if (select == dap->ap_bank_value)
+		return ERROR_OK;
+	dap->ap_bank_value = select;
+
+	select |= dap->apsel;
+
+	return jtag_dp_q_write(dap, DP_SELECT, select);
+}
+
+static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	int retval = jtag_ap_q_bankselect(dap, reg);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
+			DPAP_READ, 0, data);
+}
+
+static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	uint8_t out_value_buf[4];
+
+	int retval = jtag_ap_q_bankselect(dap, reg);
+	if (retval != ERROR_OK)
+		return retval;
+
+	buf_set_u32(out_value_buf, 0, 32, data);
+
+	return adi_jtag_ap_write_check(dap, reg, out_value_buf);
+}
+
+static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack)
+{
+	/* for JTAG, this is the only valid ABORT register operation */
+	return adi_jtag_dp_scan_u32(dap, JTAG_DP_ABORT,
+			0, DPAP_WRITE, 1, NULL, ack);
+}
+
+static int jtag_dp_run(struct adiv5_dap *dap)
+{
+	return jtagdp_transaction_endcheck(dap);
+}
+
+/* FIXME don't export ... just initialize as
+ * part of DAP setup
+*/
+const struct dap_ops jtag_dp_ops = {
+	.queue_idcode_read =	jtag_idcode_q_read,
+	.queue_dp_read =	jtag_dp_q_read,
+	.queue_dp_write =	jtag_dp_q_write,
+	.queue_ap_read =	jtag_ap_q_read,
+	.queue_ap_write =	jtag_ap_q_write,
+	.queue_ap_abort =	jtag_ap_q_abort,
+	.run =			jtag_dp_run,
+};
+
+
+const uint8_t swd2jtag_bitseq[] = {
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* Switching equence disables SWD and enables JTAG
+	 * NOTE: bits in the DP's IDCODE can expose the need for
+	 * the old/deprecated sequence (0xae 0xde).
+	 */
+	0x3c, 0xe7,
+	/* At least 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 * NOTE:  some docs say "at least 5".
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+
+/** Put the debug link into JTAG mode, if the target supports it.
+ * The link's initial mode may be either SWD or JTAG.
+ *
+ * @param target Enters JTAG mode (if possible).
+ *
+ * Note that targets implemented with SW-DP do not support JTAG, and
+ * that some targets which could otherwise support it may have been
+ * configured to disable JTAG signaling
+ *
+ * @return ERROR_OK or else a fault code.
+ */
+int dap_to_jtag(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG("Enter JTAG mode");
+
+	/* REVISIT it's nasty to need to make calls to a "jtag"
+	 * subsystem if the link isn't in JTAG mode...
+	 */
+
+	retval = jtag_add_tms_seq(8 * sizeof(swd2jtag_bitseq),
+			swd2jtag_bitseq, TAP_RESET);
+	if (retval == ERROR_OK)
+		retval = jtag_execute_queue();
+
+	/* REVISIT set up the DAP's ops vector for JTAG mode. */
+
+	return retval;
+}
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
new file mode 100644
index 0000000..f103e4b
--- /dev/null
+++ b/src/target/adi_v5_swd.c
@@ -0,0 +1,92 @@
+/***************************************************************************
+ *
+ *   Copyright (C) 2010 by David Brownell
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the
+ *   Free Software Foundation, Inc.,
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ ***************************************************************************/
+
+/**
+ * @file
+ * This file implements SWD transport support for cores implementing
+ the ARM Debug Interface version 5 (ADIv5).
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm.h"
+#include "arm_adi_v5.h"
+#include <helper/time_support.h>
+
+/*
+ * This represents the bits which must be sent out on TMS/SWDIO to
+ * switch a DAP implemented using an SWJ-DP module into SWD mode.
+ * These bits are stored (and transmitted) LSB-first.
+ *
+ * See the DAP-Lite specification, section 2.2.5 for information
+ * about making the debug link select SWD or JTAG.  (Similar info
+ * is in a few other ARM documents.)
+ */
+static const uint8_t jtag2swd_bitseq[] = {
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* Switching sequence enables SWD and disables JTAG
+	 * NOTE: bits in the DP's IDCODE may expose the need for
+	 * an old/deprecated sequence (0xb6 0xed).
+	 */
+	0x9e, 0xe7,
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+
+/**
+ * Put the debug link into SWD mode, if the target supports it.
+ * The link's initial mode may be either JTAG (for example,
+ * with SWJ-DP after reset) or SWD.
+ *
+ * @param target Enters SWD mode (if possible).
+ *
+ * Note that targets using the JTAG-DP do not support SWD, and that
+ * some targets which could otherwise support it may have have been
+ * configured to disable SWD signaling
+ *
+ * @return ERROR_OK or else a fault code.
+ */
+int dap_to_swd(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG("Enter SWD mode");
+
+	/* REVISIT it's nasty to need to make calls to a "jtag"
+	 * subsystem if the link isn't in JTAG mode...
+	 */
+
+	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
+			jtag2swd_bitseq, TAP_INVALID);
+	if (retval == ERROR_OK)
+		retval = jtag_execute_queue();
+
+	/* REVISIT set up the DAP's ops vector for SWD mode. */
+
+	return retval;
+}
+
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 61cf989..dcad0fb 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -87,272 +87,6 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
 
 /***************************************************************************
  *                                                                         *
- * DPACC and APACC scanchain access through JTAG-DP                        *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
- * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
- * discusses operations which access these registers.
- *
- * Note that only one scan is performed.  If RnW is set, a separate scan
- * will be needed to collect the data which was read; the "invalue" collects
- * the posted result of a preceding operation, not the current one.
- *
- * @param swjdp the DAP
- * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
- * @param reg_addr two significant bits; A[3:2]; for APACC access, the
- *	SELECT register has more addressing bits.
- * @param RnW false iff outvalue will be written to the DP or AP
- * @param outvalue points to a 32-bit (little-endian) integer
- * @param invalue NULL, or points to a 32-bit (little-endian) integer
- * @param ack points to where the three bit JTAG_ACK_* code will be stored
- */
-static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
-{
-	struct arm_jtag *jtag_info = swjdp->jtag_info;
-	struct scan_field fields[2];
-	uint8_t out_addr_buf;
-
-	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	/* Scan out a read or write operation using some DP or AP register.
-	 * For APACC access with any sticky error flag set, this is discarded.
-	 */
-	fields[0].num_bits = 3;
-	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
-	fields[0].out_value = &out_addr_buf;
-	fields[0].in_value = ack;
-
-	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
-	 * complete; data we write is discarded, data we read is unpredictable.
-	 * When overrun detect is active, STICKYORUN is set.
-	 */
-
-	fields[1].num_bits = 32;
-	fields[1].out_value = outvalue;
-	fields[1].in_value = invalue;
-
-	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
-
-	/* Add specified number of tck clocks after starting memory bus
-	 * access, giving the hardware time to complete the access.
-	 * They provide more time for the (MEM) AP to complete the read ...
-	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&& ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr & 0xF0) == AP_REG_BD0))
-			&& (swjdp->memaccess_tck != 0))
-		jtag_add_runtest(swjdp->memaccess_tck,
-				jtag_set_end_state(TAP_IDLE));
-
-	return jtag_get_error();
-}
-
-/**
- * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
- * This is exactly like adi_jtag_dp_scan(), except that endianness
- * conversions are performed (so the types of invalue and outvalue
- * must be different).
- */
-static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
-{
-	uint8_t out_value_buf[4];
-	int retval;
-
-	buf_set_u32(out_value_buf, 0, 32, outvalue);
-
-	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
-			out_value_buf, (uint8_t *)invalue, ack);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (invalue)
-		jtag_add_callback(arm_le_to_h_u32,
-				(jtag_callback_data_t) invalue);
-
-	return retval;
-}
-
-/**
- * Utility to write AP registers.
- */
-static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
-		uint8_t reg_addr, uint8_t *outvalue)
-{
-	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
-			outvalue, NULL, NULL);
-}
-
-static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue)
-{
-	int retval;
-
-	/* Issue the read or write */
-	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
-			RnW, outvalue, NULL, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* For reads,  collect posted value; RDBUFF has no other effect.
-	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
-	 */
-	if ((RnW == DPAP_READ) && (invalue != NULL))
-		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
-	return retval;
-}
-
-static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
-{
-	int retval;
-	uint32_t ctrlstat;
-
-	/* too expensive to call keep_alive() here */
-
-#if 0
-	/* Danger!!!! BROKEN!!!! */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
-	R956 introduced the check on return value here and now Michael Schwingen reports
-	that this code no longer works....
-
-	https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html
-	*/
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR("BUG: Why does this fail the first time????");
-	}
-	/* Why??? second time it works??? */
-#endif
-
-	/* Post CTRL/STAT read; discard any previous posted read value
-	 * but collect its ACK status.
-	 */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-		return retval;
-
-	swjdp->ack = swjdp->ack & 0x7;
-
-	/* common code path avoids calling timeval_ms() */
-	if (swjdp->ack != JTAG_ACK_OK_FAULT)
-	{
-		long long then = timeval_ms();
-
-		while (swjdp->ack != JTAG_ACK_OK_FAULT)
-		{
-			if (swjdp->ack == JTAG_ACK_WAIT)
-			{
-				if ((timeval_ms()-then) > 1000)
-				{
-					/* NOTE:  this would be a good spot
-					 * to use JTAG_DP_ABORT.
-					 */
-					LOG_WARNING("Timeout (1000ms) waiting "
-						"for ACK=OK/FAULT "
-						"in JTAG-DP transaction");
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-			else
-			{
-				LOG_WARNING("Invalid ACK %#x "
-						"in JTAG-DP transaction",
-						swjdp->ack);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			swjdp->ack = swjdp->ack & 0x7;
-		}
-	}
-
-	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
-
-	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat & (SSTICKYORUN | SSTICKYERR))
-	{
-		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
-		/* Check power to debug regions */
-		if ((ctrlstat & 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(swjdp);
-		else
-		{
-			uint32_t mem_ap_csw, mem_ap_tar;
-
-			/* Maybe print information about last intended
-			 * MEM-AP access; but not if autoincrementing.
-			 * *Real* CSW and TAR values are always shown.
-			 */
-			if (swjdp->ap_tar_value != (uint32_t) -1)
-				LOG_DEBUG("MEM-AP Cached values: "
-					"ap_bank 0x%" PRIx32
-					", ap_csw 0x%" PRIx32
-					", ap_tar 0x%" PRIx32,
-					swjdp->ap_bank_value,
-					swjdp->ap_csw_value,
-					swjdp->ap_tar_value);
-
-			if (ctrlstat & SSTICKYORUN)
-				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
-					"memaccess, or reduce jtag speed");
-
-			if (ctrlstat & SSTICKYERR)
-				LOG_ERROR("JTAG-DP STICKY ERROR");
-
-			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_WRITE,
-					swjdp->dp_ctrl_stat | SSTICKYORUN
-						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_CSW, &mem_ap_csw);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_TAR, &mem_ap_tar);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
-					PRIx32, mem_ap_csw, mem_ap_tar);
-
-		}
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-/***************************************************************************
- *                                                                         *
  * DP and MEM-AP  register access  through APACC and DPACC                 *
  *                                                                         *
 ***************************************************************************/
@@ -818,6 +552,13 @@ int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uin
 	return retval;
 }
 
+/* FIXME don't import ... this is a temporary workaround for the
+ * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
+ */
+extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
+
 /**
  * Synchronously read a block of 32-bit words into a buffer
  * @param swjdp The DAP connected to the MEM-AP.
@@ -1116,110 +857,11 @@ int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
 
 /*--------------------------------------------------------------------------*/
 
-static int jtag_idcode_q_read(struct adiv5_dap *dap,
-		uint8_t *ack, uint32_t *data)
-{
-	struct arm_jtag *jtag_info = dap->jtag_info;
-	int retval;
-	struct scan_field fields[1];
-
-	jtag_set_end_state(TAP_IDLE);
-
-	/* This is a standard JTAG operation -- no DAP tweakage */
-	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	fields[0].num_bits = 32;
-	fields[0].out_value = NULL;
-	fields[0].in_value = (void *) data;
-
-	jtag_add_dr_scan(jtag_info->tap, 1, fields, jtag_get_end_state());
-	retval = jtag_get_error();
-	if (retval != ERROR_OK)
-		return retval;
-
-	jtag_add_callback(arm_le_to_h_u32,
-			(jtag_callback_data_t) data);
-
-	return retval;
-}
-
-static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_READ, 0, data);
-}
-
-static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_WRITE, data, NULL);
-}
-
-/** Select the AP register bank matching bits 7:4 of reg. */
-static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
-{
-	uint32_t select = reg & 0x000000F0;
-
-	if (select == dap->ap_bank_value)
-		return ERROR_OK;
-	dap->ap_bank_value = select;
-
-	select |= dap->apsel;
-
-	return jtag_dp_q_write(dap, DP_SELECT, select);
-}
-
-static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	int retval = jtag_ap_q_bankselect(dap, reg);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
-			DPAP_READ, 0, data);
-}
-
-static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	uint8_t out_value_buf[4];
-
-	int retval = jtag_ap_q_bankselect(dap, reg);
-	if (retval != ERROR_OK)
-		return retval;
 
-	buf_set_u32(out_value_buf, 0, 32, data);
-
-	return adi_jtag_ap_write_check(dap, reg, out_value_buf);
-}
-
-static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack)
-{
-	/* for JTAG, this is the only valid ABORT register operation */
-	return adi_jtag_dp_scan_u32(dap, JTAG_DP_ABORT,
-			0, DPAP_WRITE, 1, NULL, ack);
-}
-
-static int jtag_dp_run(struct adiv5_dap *dap)
-{
-	return jtagdp_transaction_endcheck(dap);
-}
-
-static const struct dap_ops jtag_dp_ops = {
-	.queue_idcode_read =	jtag_idcode_q_read,
-	.queue_dp_read =	jtag_dp_q_read,
-	.queue_dp_write =	jtag_dp_q_write,
-	.queue_ap_read =	jtag_ap_q_read,
-	.queue_ap_write =	jtag_ap_q_write,
-	.queue_ap_abort =	jtag_ap_q_abort,
-	.run =			jtag_dp_run,
-};
+/* FIXME don't import ... just initialize as
+ * part of DAP transport setup
+*/
+extern const struct dap_ops jtag_dp_ops;
 
 /*--------------------------------------------------------------------------*/
 
@@ -1988,57 +1630,3 @@ int dap_to_swd(struct target *target)
 	return retval;
 }
 
-/**
- * This represents the bits which must be sent out on TMS/SWDIO to
- * switch a DAP implemented using an SWJ-DP module into JTAG mode.
- * These bits are stored (and transmitted) LSB-first.
- *
- * These bits are stored (and transmitted) LSB-first.
- */
-static const uint8_t swd2jtag_bitseq[] = {
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	/* Switching equence disables SWD and enables JTAG
-	 * NOTE: bits in the DP's IDCODE can expose the need for
-	 * the old/deprecated sequence (0xae 0xde).
-	 */
-	0x3c, 0xe7,
-	/* At least 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 * NOTE:  some docs say "at least 5".
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-};
-
-/** Put the debug link into JTAG mode, if the target supports it.
- * The link's initial mode may be either SWD or JTAG.
- *
- * @param target Enters JTAG mode (if possible).
- *
- * Note that targets implemented with SW-DP do not support JTAG, and
- * that some targets which could otherwise support it may have been
- * configured to disable JTAG signaling
- *
- * @return ERROR_OK or else a fault code.
- */
-int dap_to_jtag(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG("Enter JTAG mode");
-
-	/* REVISIT it's nasty to need to make calls to a "jtag"
-	 * subsystem if the link isn't in JTAG mode...
-	 */
-
-	retval = jtag_add_tms_seq(8 * sizeof(swd2jtag_bitseq),
-			swd2jtag_bitseq, TAP_RESET);
-	if (retval == ERROR_OK)
-		retval = jtag_execute_queue();
-
-	/* REVISIT set up the DAP's ops vector for JTAG mode. */
-
-	return retval;
-}
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index d207fd9..4ee36ff 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -32,15 +32,11 @@
 
 #include "arm_jtag.h"
 
-/* JTAG instructions/registers for JTAG-DP and SWJ-DP */
-#define JTAG_DP_ABORT		0x8
+/* FIXME remove these JTAG-specific decls when mem_ap_read_buf_u32()
+ * is no longer JTAG-specific
+ */
 #define JTAG_DP_DPACC		0xA
 #define JTAG_DP_APACC		0xB
-#define JTAG_DP_IDCODE		0xE
-
-/* three-bit ACK values for DPACC and APACC reads */
-#define JTAG_ACK_OK_FAULT	0x2
-#define JTAG_ACK_WAIT		0x1
 
 /* three-bit ACK values for SWD access (sent LSB first) */
 #define SWD_ACK_OK		0x4

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am   |    2 +
 src/target/adi_v5_jtag.c |  481 ++++++++++++++++++++++++++++++++++++++++++++++
 src/target/adi_v5_swd.c  |   92 +++++++++
 src/target/arm_adi_v5.c  |  434 +----------------------------------------
 src/target/arm_adi_v5.h  |   10 +-
 5 files changed, 589 insertions(+), 430 deletions(-)
 create mode 100644 src/target/adi_v5_jtag.c
 create mode 100644 src/target/adi_v5_swd.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 17 07:40:25 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 17 Mar 2010 06:40:25 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-93-g1d9fba8
Message-ID: <E1Nrmvb-0001uS-2a@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1d9fba8c1488c3774c8bde737c2d658b1f525d09 (commit)
      from  6f8b8593d63bc9781435270a54b6f7d245eecd8e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1d9fba8c1488c3774c8bde737c2d658b1f525d09
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 16 10:58:21 2010 +0100

    arm7/9: remove unused post_restore_context
    
    Unused. If something should happen after context restore, then the
    calling code can just do it afterwards.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index f9deb83..d1e7a93 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1726,9 +1726,6 @@ int arm7_9_restore_context(struct target *target)
 	arm7_9->write_pc(target, buf_get_u32(armv4_5->pc->value, 0, 32));
 	armv4_5->pc->dirty = 0;
 
-	if (arm7_9->post_restore_context)
-		arm7_9->post_restore_context(target);
-
 	return ERROR_OK;
 }
 
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index 93bee07..71f9a9d 100644
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -103,9 +103,6 @@ struct arm7_9_common
 	void (*post_debug_entry)(struct target *target); /**< Callback function called after entering debug mode */
 
 	void (*pre_restore_context)(struct target *target); /**< Callback function called before restoring the processor context */
-	void (*post_restore_context)(struct target *target); /**< Callback function called after restoring the processor context */
-
-
 };
 
 static inline struct arm7_9_common *
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index bd29caf..ab8a3e5 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -685,7 +685,6 @@ int arm7tdmi_init_arch_info(struct target *target,
 	arm7_9->post_debug_entry = NULL;
 
 	arm7_9->pre_restore_context = NULL;
-	arm7_9->post_restore_context = NULL;
 
 	/* initialize arch-specific breakpoint handling */
 	arm7_9->arm_bkpt = 0xdeeedeee;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 7c1e372..f3935a3 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -787,7 +787,6 @@ int arm9tdmi_init_arch_info(struct target *target,
 	arm7_9->post_debug_entry = NULL;
 
 	arm7_9->pre_restore_context = NULL;
-	arm7_9->post_restore_context = NULL;
 
 	/* initialize arch-specific breakpoint handling */
 	arm7_9->arm_bkpt = 0xdeeedeee;
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 5ef8c42..621761d 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -65,8 +65,6 @@ struct armv7a_common
 	void (*post_debug_entry)(struct target *target);
 
 	void (*pre_restore_context)(struct target *target);
-	void (*post_restore_context)(struct target *target);
-
 };
 
 static inline struct armv7a_common *
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 1216a45..f0829c6 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -139,9 +139,6 @@ int armv7m_restore_context(struct target *target)
 		}
 	}
 
-	if (armv7m->post_restore_context)
-		armv7m->post_restore_context(target);
-
 	return ERROR_OK;
 }
 
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 51d6704..57d46ed 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -124,7 +124,6 @@ struct armv7m_common
 	void (*post_debug_entry)(struct target *target);
 
 	void (*pre_restore_context)(struct target *target);
-	void (*post_restore_context)(struct target *target);
 };
 
 static inline struct armv7m_common *
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 332a55a..a548027 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1020,9 +1020,6 @@ static int cortex_a8_restore_context(struct target *target, bool bpwp)
 
 	arm_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
 
-	if (armv7a->post_restore_context)
-		armv7a->post_restore_context(target);
-
 	return ERROR_OK;
 }
 
@@ -1589,7 +1586,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 	armv7a->post_debug_entry = cortex_a8_post_debug_entry;
 
 	armv7a->pre_restore_context = NULL;
-	armv7a->post_restore_context = NULL;
 	armv7a->armv4_5_mmu.armv4_5_cache.ctype = -1;
 //	armv7a->armv4_5_mmu.get_ttb = armv7a_get_ttb;
 	armv7a->armv4_5_mmu.read_memory = cortex_a8_read_memory;
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index d39d839..7f6cbaf 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -1876,7 +1876,6 @@ static int cortex_m3_init_arch_info(struct target *target,
 	armv7m->post_debug_entry = NULL;
 
 	armv7m->pre_restore_context = NULL;
-	armv7m->post_restore_context = NULL;
 
 	armv7m->load_core_reg_u32 = cortex_m3_load_core_reg_u32;
 	armv7m->store_core_reg_u32 = cortex_m3_store_core_reg_u32;
diff --git a/src/target/fa526.c b/src/target/fa526.c
index b6149e3..d9d5d43 100644
--- a/src/target/fa526.c
+++ b/src/target/fa526.c
@@ -292,7 +292,6 @@ static int fa526_init_arch_info_2(struct target *target,
 	arm7_9->post_debug_entry = NULL;
 
 	arm7_9->pre_restore_context = NULL;
-	arm7_9->post_restore_context = NULL;
 
 	/* initialize arch-specific breakpoint handling */
 	arm7_9->arm_bkpt = 0xdeeedeee;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c |    3 ---
 src/target/arm7_9_common.h |    3 ---
 src/target/arm7tdmi.c      |    1 -
 src/target/arm9tdmi.c      |    1 -
 src/target/armv7a.h        |    2 --
 src/target/armv7m.c        |    3 ---
 src/target/armv7m.h        |    1 -
 src/target/cortex_a8.c     |    4 ----
 src/target/cortex_m3.c     |    1 -
 src/target/fa526.c         |    1 -
 10 files changed, 0 insertions(+), 20 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 17 07:42:14 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 17 Mar 2010 06:42:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-95-g051e2c9
Message-ID: <E1NrmxL-0000lz-M1@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  051e2c99ab8111f6bffdb412b40ceef333530ae6 (commit)
       via  7e447043cd7967bd9b8976d829d5cb79bf359d3c (commit)
      from  1d9fba8c1488c3774c8bde737c2d658b1f525d09 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 051e2c99ab8111f6bffdb412b40ceef333530ae6
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 16 14:45:07 2010 +0100

    gdb_server: improved gdb load performance
    
    by ack'ing memory writes immediately and reporting either
    at next memory write or stepi/continue time. GDB will then
    send off a new packet that is ready by the time the previous
    packet has been written to target memory.
    
    On faster adapters this can be as much as 10% improvement.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 17ca439..f46980e 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008 by Spencer Oliver                                  *
@@ -61,7 +61,12 @@ struct gdb_connection
 	bool sync; 	/* set flag to true if you want the next stepi to return immediately.
 	               allowing GDB to pick up a fresh set of register values from the target
 	               without modifying the target state. */
-
+	/* We delay reporting memory write errors until next step/continue or memory
+	 * write. This improves performance of gdb load significantly as the GDB packet
+	 * can be replied immediately and a new GDB packet will be ready without delay
+	 * (ca. 10% or so...).
+	 */
+	bool mem_write_error;
 };
 
 
@@ -821,6 +826,7 @@ static int gdb_new_connection(struct connection *connection)
 	gdb_connection->busy = 0;
 	gdb_connection->noack_mode = 0;
 	gdb_connection->sync = true;
+	gdb_connection->mem_write_error = false;
 
 	/* send ACK to GDB for debug request */
 	gdb_write(connection, "+", 1);
@@ -1361,7 +1367,7 @@ static int gdb_write_memory_binary_packet(struct connection *connection,
 	uint32_t addr = 0;
 	uint32_t len = 0;
 
-	int retval;
+	int retval = ERROR_OK;
 
 	/* skip command character */
 	packet++;
@@ -1382,14 +1388,18 @@ static int gdb_write_memory_binary_packet(struct connection *connection,
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	retval = ERROR_OK;
-	if (len)
-	{
-		LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
+	struct gdb_connection *gdb_connection = connection->priv;
 
-		retval = target_write_buffer(target, addr, len, (uint8_t*)separator);
+	if (gdb_connection->mem_write_error)
+	{
+		retval = ERROR_FAIL;
+		/* now that we have reported the memory write error, we can clear the condition */
+		gdb_connection->mem_write_error = false;
 	}
 
+	/* By replying the packet *immediately* GDB will send us a new packet
+	 * while we write the last one to the target.
+	 */
 	if (retval == ERROR_OK)
 	{
 		gdb_put_packet(connection, "OK", 2);
@@ -1400,6 +1410,17 @@ static int gdb_write_memory_binary_packet(struct connection *connection,
 			return retval;
 	}
 
+	if (len)
+	{
+		LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
+
+		retval = target_write_buffer(target, addr, len, (uint8_t*)separator);
+		if (retval != ERROR_OK)
+		{
+			gdb_connection->mem_write_error = true;
+		}
+	}
+
 	return ERROR_OK;
 }
 
@@ -2211,6 +2232,14 @@ static int gdb_input_inner(struct connection *connection)
 						struct gdb_connection *gdb_con = connection->priv;
 						log_add_callback(gdb_log_callback, connection);
 
+						if (gdb_con->mem_write_error)
+						{
+							LOG_ERROR("Memory write failure!");
+
+							/* now that we have reported the memory write error, we can clear the condition */
+							gdb_con->mem_write_error = false;
+						}
+
 						bool nostep = false;
 						bool already_running = false;
 						if (target->state == TARGET_RUNNING)

commit 7e447043cd7967bd9b8976d829d5cb79bf359d3c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 16 11:40:52 2010 +0100

    zy1000: tweak the DCC inner loop a tiny bit
    
    Uses FIFO a bit more efficiently now.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 005a4e0..177d286 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -839,7 +839,7 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 	int post_bits;
 	jtag_pre_post_bits(tap, &pre_bits, &post_bits);
 
-	if ((pre_bits > 32) || (post_bits > 32))
+	if (pre_bits + post_bits + 6 > 32)
 	{
 		int i;
 		for (i = 0; i < count; i++)
@@ -854,15 +854,18 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 		if (post_bits == 0)
 			shift_end_state = end_state;
 
+		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
 		int i;
-		for (i = 0; i < count; i++)
+		for (i = 0; i < count - 1; i++)
 		{
-			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
+			/* Fewer pokes means we get to use the FIFO more efficiently */
 			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, little));
-			shiftValueInner(TAP_DRSHIFT, shift_end_state, 6, reg_addr | (1 << 5));
-			shiftValueInner(shift_end_state, end_state, post_bits, 0);
+			shiftValueInner(TAP_DRSHIFT, shift_end_state, 6 + post_bits + pre_bits, (reg_addr | (1 << 5)));
 			buffer += 4;
 		}
+		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, little));
+		shiftValueInner(TAP_DRSHIFT, shift_end_state, 6, reg_addr | (1 << 5));
+		shiftValueInner(shift_end_state, end_state, post_bits, 0);
 	}
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   13 ++++++++-----
 src/server/gdb_server.c  |   45 +++++++++++++++++++++++++++++++++++++--------
 2 files changed, 45 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Mar 17 11:10:40 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 17 Mar 2010 10:10:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-98-g3ad171c
Message-ID: <E1NrqD4-0003WD-7b@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3ad171cd537f8fc1bac649f24513ebfafd95baf2 (commit)
       via  e7e9bfde47768b22be8b15c30c027dc8fb67c778 (commit)
       via  79ca05b106ef92915c4e9288cbf34d5db1cf4cd2 (commit)
      from  051e2c99ab8111f6bffdb412b40ceef333530ae6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3ad171cd537f8fc1bac649f24513ebfafd95baf2
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Mar 17 09:57:44 2010 +0000

    SCRIPT: add add_script_search_dir cmd
    
    Add a add_script_search_dir cmd so that adding search
    dir's can be added to cfg scripts.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index cc2560b..0b9a6a4 100644
--- a/NEWS
+++ b/NEWS
@@ -16,6 +16,11 @@ JTAG Layer:
 Boundary Scan:
 
 Target Layer:
+	MIPS:
+		- "ejtag_srst" variant removed. The same functionality is
+		  obtained by using "reset_config none".
+		- added PIC32MX software reset support, this means srst is not
+		  required to be connected anymore.
 
 Flash Layer:
 	New "stellaris recover" command, implements the procedure
@@ -23,12 +28,15 @@ Flash Layer:
 		state to the factory defaults, including erasing
 		the flash and its protection bits, and possibly
 		re-enabling hardware debugging).
-
+	PIC32MX now uses algorithm for flash programming, this
+		has increased the performance by approx 96%.
 
 Board, Target, and Interface Configuration Scripts:
 	Support IAR LPC1768 kickstart board (by Olimex)
 
 Core Jim/TCL Scripting:
+	New "add_script_search_dir" command, behaviour is the same
+		as the "-s" cmd line option.
 
 Documentation:
 
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 780cd4d..98fc690 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -590,6 +590,7 @@ Configuration files and scripts are searched for in
 @enumerate
 @item the current directory,
 @item any search dir specified on the command line using the @option{-s} option,
+ at item any search dir specified using the @command{add_script_search_dir} command,
 @item @file{$HOME/.openocd} (not on Windows),
 @item the site wide script library @file{$pkgdatadir/site} and
 @item the OpenOCD-supplied script library @file{$pkgdatadir/scripts}.
@@ -5396,6 +5397,10 @@ Redirect logging to @var{filename};
 the initial log output channel is stderr.
 @end deffn
 
+ at deffn Command add_script_search_dir [directory]
+Add @var{directory} to the file/script search path.
+ at end deffn
+
 @anchor{Target State handling}
 @section Target State handling
 @cindex reset
diff --git a/src/openocd.c b/src/openocd.c
index d376f5f..54c454d 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -159,6 +159,16 @@ COMMAND_HANDLER(handle_init_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_add_script_search_dir_command)
+{
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	add_script_search_dir(CMD_ARGV[0]);
+
+	return ERROR_OK;
+}
+
 static const struct command_registration openocd_command_handlers[] = {
 	{
 		.name = "version",
@@ -182,6 +192,13 @@ static const struct command_registration openocd_command_handlers[] = {
 			"called automatically at the end of startup.",
 
 	},
+	{
+		.name = "add_script_search_dir",
+		.handler = &handle_add_script_search_dir_command,
+		.mode = COMMAND_ANY,
+		.help = "dir to search for config files and scripts",
+
+	},
 	COMMAND_REGISTRATION_DONE
 };
 

commit e7e9bfde47768b22be8b15c30c027dc8fb67c778
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Mar 16 12:54:08 2010 +0000

    PIC32: add software reset support
    
    The PIC32MX does not support the ejtag software reset - it is
    optional in the ejtag spec.
    
    We perform the equivalent using the microchip specific MTAP cmd's.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 984b535..cea8fa8 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -127,6 +127,37 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 	return ERROR_OK;
 }
 
+int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
+{
+	struct jtag_tap *tap;
+	tap  = ejtag_info->tap;
+
+	if (tap == NULL)
+		return ERROR_FAIL;
+	struct scan_field field;
+	uint8_t t[4], r[4];
+	int retval;
+
+	field.num_bits = 8;
+	field.out_value = t;
+	buf_set_u32(field.out_value, 0, field.num_bits, *data);
+	field.in_value = r;
+
+	jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		LOG_ERROR("register read failed");
+		return retval;
+	}
+
+	*data = buf_get_u32(field.in_value, 0, 32);
+
+	keep_alive();
+
+	return ERROR_OK;
+}
+
 int mips_ejtag_step_enable(struct mips_ejtag *ejtag_info)
 {
 	static const uint32_t code[] = {
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 5c1f245..a086cd5 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -43,6 +43,11 @@
 /* microchip PIC32MX specific instructions */
 #define MTAP_SW_MTAP			0x04
 #define MTAP_SW_ETAP			0x05
+#define MTAP_COMMAND			0x07
+
+/* microchip specific cmds */
+#define MCHP_ASERT_RST			0xd1
+#define MCHP_DE_ASSERT_RST		0xd0
 
 /* ejtag control register bits ECR */
 #define EJTAG_CTRL_TOF			(1 << 1)
@@ -130,6 +135,7 @@ int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode);
 int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode);
 int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data);
+int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data);
 int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t *data);
 
 int mips_ejtag_init(struct mips_ejtag *ejtag_info);
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index d3536d8..d1b4589 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -250,11 +250,30 @@ int mips_m4k_assert_reset(struct target *target)
 	}
 	else
 	{
+		if (mips_m4k->is_pic32mx)
+		{
+			uint32_t mchip_cmd;
+
+			LOG_DEBUG("Using MTAP reset to reset processor...");
+
+			/* use microchip specific MTAP reset */
+			mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP, NULL);
+			mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND, NULL);
+
+			mchip_cmd = MCHP_ASERT_RST;
+			mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+			mchip_cmd = MCHP_DE_ASSERT_RST;
+			mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP, NULL);
+		}
+		else
+		{
 			/* use ejtag reset - not supported by all cores */
 			uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
 			LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
 			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
 			mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+		}
 	}
 
 	target->state = TARGET_RESET;
@@ -878,7 +897,7 @@ int mips_m4k_init_target(struct command_context *cmd_ctx, struct target *target)
 int mips_m4k_init_arch_info(struct target *target, struct mips_m4k_common *mips_m4k,
 		struct jtag_tap *tap)
 {
-	struct mips32_common *mips32 = &mips_m4k->mips32_common;
+	struct mips32_common *mips32 = &mips_m4k->mips32;
 
 	mips_m4k->common_magic = MIPSM4K_COMMON_MAGIC;
 
@@ -901,8 +920,8 @@ int mips_m4k_target_create(struct target *target, Jim_Interp *interp)
 int mips_m4k_examine(struct target *target)
 {
 	int retval;
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
+	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
 	uint32_t idcode = 0;
 
 	if (!target_was_examined(target))
@@ -916,6 +935,7 @@ int mips_m4k_examine(struct target *target)
 			 * as it is not selected by default */
 			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP, NULL);
 			LOG_DEBUG("PIC32MX Detected - using EJTAG Interface");
+			mips_m4k->is_pic32mx = true;
 		}
 	}
 
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index 9b33020..5eb2029 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -32,6 +32,7 @@ struct target;
 struct mips_m4k_common
 {
 	int common_magic;
+	bool is_pic32mx;
 	struct mips32_common mips32;
 };
 

commit 79ca05b106ef92915c4e9288cbf34d5db1cf4cd2
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Mar 16 12:48:53 2010 +0000

    MIPS: remove ejtag_srst variant
    
    The mips_m4k_assert_reset has now been restructured
    so the variant ejtag_srst is not required anymore.
    The ejtag software reset will be used if the target does not
    have srst connected.
    
    Remove ejtag_srst from docs.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index e1bb2b7..780cd4d 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -3453,14 +3453,6 @@ be detected and the normal reset behaviour used.
 @item @code{fa526} -- resembles arm920 (w/o Thumb)
 @item @code{feroceon} -- resembles arm926
 @item @code{mips_m4k} -- a MIPS core.  This supports one variant:
- at itemize @minus
- at item @code{ejtag_srst} ... Use this when debugging targets that do not
-provide a functional SRST line on the EJTAG connector.  This causes
-OpenOCD to instead use an EJTAG software reset command to reset the
-processor.
-You still need to enable @option{srst} on the @command{reset_config}
-command to enable OpenOCD hardware reset functionality.
- at end itemize
 @item @code{xscale} -- this is actually an architecture,
 not a CPU type.  It is based on the ARMv5 architecture.
 There are several variants defined:
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 389daf9..d3536d8 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -212,18 +212,17 @@ int mips_m4k_halt(struct target *target)
 
 int mips_m4k_assert_reset(struct target *target)
 {
-	struct mips32_common *mips32 = target_to_mips32(target);
-	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
+	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
+	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
+	int assert_srst = 1;
 
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
+
 	if (!(jtag_reset_config & RESET_HAS_SRST))
-	{
-		LOG_ERROR("Can't assert SRST");
-		return ERROR_FAIL;
-	}
+		assert_srst = 0;
 
 	if (target->reset_halt)
 	{
@@ -237,14 +236,7 @@ int mips_m4k_assert_reset(struct target *target)
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT, NULL);
 	}
 
-	if (strcmp(target->variant, "ejtag_srst") == 0)
-	{
-		uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
-		LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
-		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
-	}
-	else
+	if (assert_srst)
 	{
 		/* here we should issue a srst only, but we may have to assert trst as well */
 		if (jtag_reset_config & RESET_SRST_PULLS_TRST)
@@ -256,11 +248,19 @@ int mips_m4k_assert_reset(struct target *target)
 			jtag_add_reset(0, 1);
 		}
 	}
+	else
+	{
+			/* use ejtag reset - not supported by all cores */
+			uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
+			LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
+			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+			mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
+	}
 
 	target->state = TARGET_RESET;
 	jtag_add_sleep(50000);
 
-	register_cache_invalidate(mips32->core_cache);
+	register_cache_invalidate(mips_m4k->mips32.core_cache);
 
 	if (target->reset_halt)
 	{
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index 4fe14a0..9b33020 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -32,14 +32,14 @@ struct target;
 struct mips_m4k_common
 {
 	int common_magic;
-	struct mips32_common mips32_common;
+	struct mips32_common mips32;
 };
 
 static inline struct mips_m4k_common *
 target_to_m4k(struct target *target)
 {
 	return container_of(target->arch_info,
-			struct mips_m4k_common, mips32_common);
+			struct mips_m4k_common, mips32);
 }
 
 int mips_m4k_bulk_write_memory(struct target *target,

-----------------------------------------------------------------------

Summary of changes:
 NEWS                    |   10 +++++++-
 doc/openocd.texi        |   13 ++++------
 src/openocd.c           |   17 ++++++++++++++
 src/target/mips_ejtag.c |   31 ++++++++++++++++++++++++++
 src/target/mips_ejtag.h |    6 +++++
 src/target/mips_m4k.c   |   56 +++++++++++++++++++++++++++++++---------------
 src/target/mips_m4k.h   |    5 ++-
 7 files changed, 109 insertions(+), 29 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 17 12:45:42 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 17 Mar 2010 11:45:42 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-99-g099ffc7
Message-ID: <E1Nrrh2-0008Ji-5R@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  099ffc754ab22cb9b8e3e6af04e21284de12d885 (commit)
      from  3ad171cd537f8fc1bac649f24513ebfafd95baf2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 099ffc754ab22cb9b8e3e6af04e21284de12d885
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Mar 17 12:43:47 2010 +0100

    target: mdX/mwX on target were badly broken
    
    - incorrect parsing of arguments
    - mdX didn't display arguments correctly
    
    I don't think anyone ever used that code path :-)
    
    Did you know that "target mdw" and mdw are very different?
    
    for {set i 0} {$i < 256} {set i [expr $i+1]} {mwb [expr 0x2000000+$i] $i}
    
     mdw 0x2000000 0x10
    0x02000000: 03020100 07060504 0b0a0908 0f0e0d0c 13121110 17161514 1b1a1918 1f1e1d1c
    0x02000020: 23222120 27262524 2b2a2928 2f2e2d2c 33323130 37363534 3b3a3938 3f3e3d3c
    
    > zy1000.cpu mdb 0x2000000 0x20
    0x02000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f ................
    0x02000010 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f ................
    > zy1000.cpu mdh 0x2000000 0x20
    0x02000000 0100 0302 0504 0706 0908 0b0a 0d0c 0f0e ................
    0x02000010 1110 1312 1514 1716 1918 1b1a 1d1c 1f1e ................
    0x02000020 2120 2322 2524 2726 2928 2b2a 2d2c 2f2e  !"#$%&'()*+,-./
    0x02000030 3130 3332 3534 3736 3938 3b3a 3d3c 3f3e 0123456789:;<=>?
    > zy1000.cpu mdw 0x2000000 0x20
    0x02000000 03020100 07060504 0b0a0908 0f0e0d0c ................
    0x02000010 13121110 17161514 1b1a1918 1f1e1d1c ................
    0x02000020 23222120 27262524 2b2a2928 2f2e2d2c  !"#$%&'()*+,-./
    0x02000030 33323130 37363534 3b3a3938 3f3e3d3c 0123456789:;<=>?
    0x02000040 43424140 47464544 4b4a4948 4f4e4d4c @ABCDEFGHIJKLMNO
    0x02000050 53525150 57565554 5b5a5958 5f5e5d5c PQRSTUVWXYZ[\]^_
    0x02000060 63626160 67666564 6b6a6968 6f6e6d6c `abcdefghijklmno
    0x02000070 73727170 77767574 7b7a7978 7f7e7d7c pqrstuvwxyz{|}~.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 1eb1435..b6813fd 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3879,13 +3879,17 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
 
-	if (goi.argc != 2 && goi.argc != 3)
+	/* danger! goi.argc will be modified below! */
+	argc = goi.argc;
+
+	if (argc != 2 && argc != 3)
 	{
 		Jim_SetResult_sprintf(goi.interp,
 				"usage: %s <address> <data> [<count>]", cmd_name);
 		return JIM_ERR;
 	}
 
+
 	jim_wide a;
 	int e = Jim_GetOpt_Wide(&goi, &a);
 	if (e != JIM_OK)
@@ -3897,7 +3901,7 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return e;
 
 	jim_wide c = 1;
-	if (goi.argc == 3)
+	if (argc == 3)
 	{
 		e = Jim_GetOpt_Wide(&goi, &c);
 		if (e != JIM_OK)
@@ -3944,7 +3948,10 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
 
-	if ((goi.argc == 2) || (goi.argc == 3))
+	/* danger! goi.argc will be modified below! */
+	argc = goi.argc;
+
+	if ((argc != 1) && (argc != 2))
 	{
 		Jim_SetResult_sprintf(goi.interp,
 				"usage: %s <address> [<count>]", cmd_name);
@@ -3957,7 +3964,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return JIM_ERR;
 	}
 	jim_wide c;
-	if (goi.argc) {
+	if (argc == 2) {
 		e = Jim_GetOpt_Wide(&goi, &c);
 		if (e != JIM_OK) {
 			return JIM_ERR;
@@ -3999,7 +4006,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		case 4:
 			for (x = 0; x < 16 && x < y; x += 4)
 			{
-				z = target_buffer_get_u32(target, &(target_buf[ x * 4 ]));
+				z = target_buffer_get_u32(target, &(target_buf[ x ]));
 				Jim_fprintf(interp, interp->cookie_stdout, "%08x ", (int)(z));
 			}
 			for (; (x < 16) ; x += 4) {
@@ -4009,7 +4016,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		case 2:
 			for (x = 0; x < 16 && x < y; x += 2)
 			{
-				z = target_buffer_get_u16(target, &(target_buf[ x * 2 ]));
+				z = target_buffer_get_u16(target, &(target_buf[ x ]));
 				Jim_fprintf(interp, interp->cookie_stdout, "%04x ", (int)(z));
 			}
 			for (; (x < 16) ; x += 2) {
@@ -4019,7 +4026,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		case 1:
 		default:
 			for (x = 0 ; (x < 16) && (x < y) ; x += 1) {
-				z = target_buffer_get_u8(target, &(target_buf[ x * 4 ]));
+				z = target_buffer_get_u8(target, &(target_buf[ x ]));
 				Jim_fprintf(interp, interp->cookie_stdout, "%02x ", (int)(z));
 			}
 			for (; (x < 16) ; x += 1) {

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |   21 ++++++++++++++-------
 1 files changed, 14 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 17 12:48:34 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 17 Mar 2010 11:48:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-100-gbf71e34
Message-ID: <E1Nrrjo-0000Eg-82@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bf71e34cbf874fcf568742283cfa96360a9c75e1 (commit)
      from  099ffc754ab22cb9b8e3e6af04e21284de12d885 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bf71e34cbf874fcf568742283cfa96360a9c75e1
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 16 18:02:58 2010 +0100

    target: faster mww operations
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index b6813fd..91fe787 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008, Duane Ellis                                       *
@@ -2294,6 +2294,74 @@ COMMAND_HANDLER(handle_md_command)
 	return retval;
 }
 
+typedef int (*target_write_fn)(struct target *target,
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+
+static int target_write_memory_fast(struct target *target,
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	return target_write_buffer(target, address, size * count, buffer);
+}
+
+static int target_fill_mem(struct target *target,
+		uint32_t address,
+		target_write_fn fn,
+		unsigned data_size,
+		/* value */
+		uint32_t b,
+		/* count */
+		unsigned c)
+{
+	/* We have to write in reasonably large chunks to be able
+	 * to fill large memory areas with any sane speed */
+	const unsigned chunk_size = 16384;
+	uint8_t *target_buf = malloc(chunk_size * data_size);
+	if (target_buf == NULL)
+	{
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
+
+	for (unsigned i = 0; i < chunk_size; i ++)
+	{
+		switch (data_size)
+		{
+		case 4:
+			target_buffer_set_u32(target, target_buf + i*data_size, b);
+			break;
+		case 2:
+			target_buffer_set_u16(target, target_buf + i*data_size, b);
+			break;
+		case 1:
+			target_buffer_set_u8(target, target_buf + i*data_size, b);
+			break;
+		default:
+			exit(-1);
+		}
+	}
+
+	int retval = ERROR_OK;
+
+	for (unsigned x = 0; x < c; x += chunk_size)
+	{
+		unsigned current;
+		current = c - x;
+		if (current > chunk_size)
+		{
+			current = chunk_size;
+		}
+		int retval = fn(target, address + x * data_size, data_size, current, target_buf);
+		if (retval != ERROR_OK)
+		{
+			break;
+		}
+	}
+	free(target_buf);
+
+	return retval;
+}
+
+
 COMMAND_HANDLER(handle_mw_command)
 {
 	if (CMD_ARGC < 2)
@@ -2301,8 +2369,7 @@ COMMAND_HANDLER(handle_mw_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 	bool physical=strcmp(CMD_ARGV[0], "phys")==0;
-	int (*fn)(struct target *target,
-			uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	target_write_fn fn;
 	if (physical)
 	{
 		CMD_ARGC--;
@@ -2310,7 +2377,7 @@ COMMAND_HANDLER(handle_mw_command)
 		fn=target_write_phys_memory;
 	} else
 	{
-		fn=target_write_memory;
+		fn = target_write_memory_fast;
 	}
 	if ((CMD_ARGC < 2) || (CMD_ARGC > 3))
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -2327,35 +2394,22 @@ COMMAND_HANDLER(handle_mw_command)
 
 	struct target *target = get_current_target(CMD_CTX);
 	unsigned wordsize;
-	uint8_t value_buf[4];
 	switch (CMD_NAME[2])
 	{
 		case 'w':
 			wordsize = 4;
-			target_buffer_set_u32(target, value_buf, value);
 			break;
 		case 'h':
 			wordsize = 2;
-			target_buffer_set_u16(target, value_buf, value);
 			break;
 		case 'b':
 			wordsize = 1;
-			value_buf[0] = value;
 			break;
 		default:
 			return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	for (unsigned i = 0; i < count; i++)
-	{
-		int retval = fn(target,
-				address + i * wordsize, wordsize, 1, value_buf);
-		if (ERROR_OK != retval)
-			return retval;
-		keep_alive();
-	}
-
-	return ERROR_OK;
 
+	return target_fill_mem(target, address, fn, wordsize, value, count);
 }
 
 static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
@@ -3909,36 +3963,21 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 
 	struct target *target = Jim_CmdPrivData(goi.interp);
-	uint8_t  target_buf[32];
+	unsigned data_size;
 	if (strcasecmp(cmd_name, "mww") == 0) {
-		target_buffer_set_u32(target, target_buf, b);
-		b = 4;
+		data_size = 4;
 	}
 	else if (strcasecmp(cmd_name, "mwh") == 0) {
-		target_buffer_set_u16(target, target_buf, b);
-		b = 2;
+		data_size = 2;
 	}
 	else if (strcasecmp(cmd_name, "mwb") == 0) {
-		target_buffer_set_u8(target, target_buf, b);
-		b = 1;
+		data_size = 1;
 	} else {
 		LOG_ERROR("command '%s' unknown: ", cmd_name);
 		return JIM_ERR;
 	}
 
-	for (jim_wide x = 0; x < c; x++)
-	{
-		e = target_write_memory(target, a, b, 1, target_buf);
-		if (e != ERROR_OK)
-		{
-			Jim_SetResult_sprintf(interp,
-					"Error writing @ 0x%08x: %d\n", (int)(a), e);
-			return JIM_ERR;
-		}
-		/* b = width */
-		a = a + b;
-	}
-	return JIM_OK;
+	return (target_fill_mem(target, a, target_write_memory_fast, data_size, b, c) == ERROR_OK) ? JIM_OK : JIM_ERR;
 }
 
 static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |  115 ++++++++++++++++++++++++++++++++++-----------------
 1 files changed, 77 insertions(+), 38 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 17 13:02:33 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 17 Mar 2010 12:02:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-101-gcc197c8
Message-ID: <E1NrrxK-0000lq-9Z@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  cc197c808625d9afa5e4c316122d59b71fe8ee44 (commit)
      from  bf71e34cbf874fcf568742283cfa96360a9c75e1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit cc197c808625d9afa5e4c316122d59b71fe8ee44
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Mar 17 12:59:33 2010 +0100

    gdb: long running "monitor mww" now works w/gdb
    
    invoke keep_alive() to make sure that the default 2000ms
    timeout does not trigger.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 91fe787..2c88a6f 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2355,6 +2355,8 @@ static int target_fill_mem(struct target *target,
 		{
 			break;
 		}
+		/* avoid GDB timeouts */
+		keep_alive();
 	}
 	free(target_buf);
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 17 21:35:33 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 17 Mar 2010 20:35:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-102-g0529431
Message-ID: <E1Nrzxm-0003tt-JD@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0529431fe740fbf04b41129d84e2d8633b13fabe (commit)
      from  cc197c808625d9afa5e4c316122d59b71fe8ee44 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0529431fe740fbf04b41129d84e2d8633b13fabe
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Mar 17 21:34:43 2010 +0100

    mips: fix warning
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index cea8fa8..42dc6e0 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -135,7 +135,7 @@ int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 	if (tap == NULL)
 		return ERROR_FAIL;
 	struct scan_field field;
-	uint8_t t[4], r[4];
+	uint8_t t[4] = {0, 0, 0, 0}, r[4];
 	int retval;
 
 	field.num_bits = 8;

-----------------------------------------------------------------------

Summary of changes:
 src/target/mips_ejtag.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 18 08:41:13 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 18 Mar 2010 07:41:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-103-gfccdfc1
Message-ID: <E1NsAM7-0005Iq-Pj@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fccdfc1cd78ddfb687e0d1fc630c3fa10af2b5f9 (commit)
      from  0529431fe740fbf04b41129d84e2d8633b13fabe (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fccdfc1cd78ddfb687e0d1fc630c3fa10af2b5f9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Mar 17 21:50:23 2010 +0100

    linker error: fix problem with duplicate fn
    
    A fn was copied instead of moved to a new file. The linker
    can discard exact copies of fn's without warning.
    
    This is a C++'ism.
    
    However on my Ubuntu 9.10 machine, it fails.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index dcad0fb..4afd50c 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1597,36 +1597,3 @@ static const uint8_t jtag2swd_bitseq[] = {
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 };
 
-/**
- * Put the debug link into SWD mode, if the target supports it.
- * The link's initial mode may be either JTAG (for example,
- * with SWJ-DP after reset) or SWD.
- *
- * @param target Enters SWD mode (if possible).
- *
- * Note that targets using the JTAG-DP do not support SWD, and that
- * some targets which could otherwise support it may have have been
- * configured to disable SWD signaling
- *
- * @return ERROR_OK or else a fault code.
- */
-int dap_to_swd(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG("Enter SWD mode");
-
-	/* REVISIT it's nasty to need to make calls to a "jtag"
-	 * subsystem if the link isn't in JTAG mode...
-	 */
-
-	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
-			jtag2swd_bitseq, TAP_INVALID);
-	if (retval == ERROR_OK)
-		retval = jtag_execute_queue();
-
-	/* REVISIT set up the DAP's ops vector for SWD mode. */
-
-	return retval;
-}
-

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   33 ---------------------------------
 1 files changed, 0 insertions(+), 33 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 18 08:43:56 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 18 Mar 2010 07:43:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-104-g36df240
Message-ID: <E1NsAOb-00049j-Tw@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  36df240cea04990e8c18aa0b90bd63374f22dbd3 (commit)
      from  fccdfc1cd78ddfb687e0d1fc630c3fa10af2b5f9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 36df240cea04990e8c18aa0b90bd63374f22dbd3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Mar 16 14:13:03 2010 +0100

    jtag: cut down on usage of unintended modification of global end state
    
    jtag_get/set_end_state() is now deprecated.
    
    There were lots of places in the code where the end state was
    unintentionally modified.
    
    The big Q is whether there were any places where the intention
    was to modify the end state. 0.5 is a long way off, so we'll
    get a fair amount of testing.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 35fe806..732226f 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -69,7 +69,7 @@ static uint8_t str9xpec_isc_status(struct jtag_tap *tap)
 	field.in_value = &status;
 
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 	jtag_execute_queue();
 
 	LOG_DEBUG("status: 0x%2.2x", status);
@@ -156,7 +156,7 @@ static int str9xpec_read_config(struct flash_bank *bank)
 	field.in_value = str9xpec_info->options;
 
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 	jtag_execute_queue();
 
 	status = str9xpec_isc_status(tap);
@@ -302,7 +302,7 @@ static int str9xpec_blank_check(struct flash_bank *bank, int first, int last)
 	field.out_value = buffer;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 	jtag_add_sleep(40000);
 
 	/* read blank check result */
@@ -406,7 +406,7 @@ static int str9xpec_erase_area(struct flash_bank *bank, int first, int last)
 	field.out_value = buffer;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 	jtag_execute_queue();
 
 	jtag_add_sleep(10);
@@ -466,7 +466,7 @@ static int str9xpec_lock_device(struct flash_bank *bank)
 		field.out_value = NULL;
 		field.in_value = &status;
 
-		jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+		jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 		jtag_execute_queue();
 
 	} while (!(status & ISC_STATUS_BUSY));
@@ -546,7 +546,7 @@ static int str9xpec_set_address(struct flash_bank *bank, uint8_t sector)
 	field.out_value = &sector;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 1, &field, TAP_IRPAUSE);
 
 	return ERROR_OK;
 }
@@ -631,7 +631,7 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer,
 			field.out_value = (buffer + bytes_written);
 			field.in_value = NULL;
 
-			jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 
 			/* small delay before polling */
 			jtag_add_sleep(50);
@@ -643,7 +643,7 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer,
 				field.out_value = NULL;
 				field.in_value = scanbuf;
 
-				jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+				jtag_add_dr_scan(tap, 1, &field, TAP_IRPAUSE);
 				jtag_execute_queue();
 
 				status = buf_get_u32(scanbuf, 0, 8);
@@ -679,7 +679,7 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer,
 		field.out_value = last_dword;
 		field.in_value = NULL;
 
-		jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 
 		/* small delay before polling */
 		jtag_add_sleep(50);
@@ -691,7 +691,7 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer,
 			field.out_value = NULL;
 			field.in_value = scanbuf;
 
-			jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+			jtag_add_dr_scan(tap, 1, &field, TAP_IRPAUSE);
 			jtag_execute_queue();
 
 			status = buf_get_u32(scanbuf, 0, 8);
@@ -744,7 +744,7 @@ COMMAND_HANDLER(str9xpec_handle_part_id_command)
 	field.out_value = NULL;
 	field.in_value = buffer;
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 	jtag_execute_queue();
 
 	idcode = buf_get_u32(buffer, 0, 32);
@@ -860,7 +860,7 @@ static int str9xpec_write_options(struct flash_bank *bank)
 	field.out_value = str9xpec_info->options;
 	field.in_value = NULL;
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 
 	/* small delay before polling */
 	jtag_add_sleep(50);
@@ -872,7 +872,7 @@ static int str9xpec_write_options(struct flash_bank *bank)
 		field.out_value = NULL;
 		field.in_value = &status;
 
-		jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+		jtag_add_dr_scan(tap, 1, &field, TAP_IRPAUSE);
 		jtag_execute_queue();
 
 	} while (!(status & ISC_STATUS_BUSY));
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 9792280..a09472a 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -743,7 +743,8 @@ void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 	}
 }
 
-tap_state_t jtag_set_end_state(tap_state_t state)
+/* DEPRECATED! store such global state outside JTAG layer */
+void jtag_set_end_state(tap_state_t state)
 {
 	if ((state == TAP_DRSHIFT)||(state == TAP_IRSHIFT))
 	{
@@ -752,9 +753,9 @@ tap_state_t jtag_set_end_state(tap_state_t state)
 
 	if (state != TAP_INVALID)
 		cmd_queue_end_state = state;
-	return cmd_queue_end_state;
 }
 
+/* DEPRECATED! store such global state outside JTAG layer */
 tap_state_t jtag_get_end_state(void)
 {
 	return cmd_queue_end_state;
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 0bbea5f..a92c986 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -552,15 +552,18 @@ void jtag_add_reset(int req_tlr_or_trst, int srst);
 
 
 /**
+ * DEPRECATED! store such global state outside JTAG layer
+ *
  * Function jtag_set_end_state
  *
  * Set a global variable to \a state if \a state != TAP_INVALID.
  *
- * Return the value of the global variable.
  */
-tap_state_t jtag_set_end_state(tap_state_t state);
+void jtag_set_end_state(tap_state_t state);
 
 /**
+ * DEPRECATED! store such global state outside JTAG layer
+ * 
  * Function jtag_get_end_state
  *
  * Return the value of the global variable for end state
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index 976535b..93509de 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -40,7 +40,7 @@ static int virtex2_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, &field, jtag_set_end_state(TAP_IDLE));
+		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 
 		free(field.out_value);
 	}
@@ -67,7 +67,7 @@ static int virtex2_send_32(struct pld_device *pld_device,
 
 	virtex2_set_instr(virtex2_info->tap, 0x5); /* CFG_IN */
 
-	jtag_add_dr_scan(virtex2_info->tap, 1, &scan_field, jtag_set_end_state(TAP_DRPAUSE));
+	jtag_add_dr_scan(virtex2_info->tap, 1, &scan_field, TAP_DRPAUSE);
 
 	free(values);
 
@@ -96,7 +96,7 @@ static int virtex2_receive_32(struct pld_device *pld_device,
 	{
 		scan_field.in_value = (uint8_t *)words;
 
-		jtag_add_dr_scan(virtex2_info->tap, 1, &scan_field, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(virtex2_info->tap, 1, &scan_field, TAP_DRPAUSE);
 
 		jtag_add_callback(virtexflip32, (jtag_callback_data_t)words);
 
@@ -155,18 +155,18 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 	field.num_bits = bit_file.length * 8;
 	field.out_value = bit_file.data;
 
-	jtag_add_dr_scan(virtex2_info->tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
+	jtag_add_dr_scan(virtex2_info->tap, 1, &field, TAP_DRPAUSE);
 	jtag_execute_queue();
 
 	jtag_add_tlr();
 
 	jtag_set_end_state(TAP_IDLE);
 	virtex2_set_instr(virtex2_info->tap, 0xc); /* JSTART */
-	jtag_add_runtest(13, jtag_set_end_state(TAP_IDLE));
+	jtag_add_runtest(13, TAP_IDLE);
 	virtex2_set_instr(virtex2_info->tap, 0x3f); /* BYPASS */
 	virtex2_set_instr(virtex2_info->tap, 0x3f); /* BYPASS */
 	virtex2_set_instr(virtex2_info->tap, 0xc); /* JSTART */
-	jtag_add_runtest(13, jtag_set_end_state(TAP_IDLE));
+	jtag_add_runtest(13, TAP_IDLE);
 	virtex2_set_instr(virtex2_info->tap, 0x3f); /* BYPASS */
 	jtag_execute_queue();
 
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index eac83b7..091b77a 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -107,7 +107,7 @@ int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	fields[1].out_value = outvalue;
 	fields[1].in_value = invalue;
 
-	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
 
 	/* Add specified number of tck clocks after starting memory bus
 	 * access, giving the hardware time to complete the access.
@@ -119,7 +119,7 @@ int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 				|| ((reg_addr & 0xF0) == AP_REG_BD0))
 			&& (swjdp->memaccess_tck != 0))
 		jtag_add_runtest(swjdp->memaccess_tck,
-				jtag_set_end_state(TAP_IDLE));
+				TAP_IDLE);
 
 	return jtag_get_error();
 }
@@ -341,7 +341,7 @@ static int jtag_idcode_q_read(struct adiv5_dap *dap,
 	fields[0].out_value = NULL;
 	fields[0].in_value = (void *) data;
 
-	jtag_add_dr_scan(jtag_info->tap, 1, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 1, fields, TAP_IDLE);
 	retval = jtag_get_error();
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 2b7b4e4..18bf255 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -482,7 +482,7 @@ int arm11_run_instr_data_to_core(struct arm11_common * arm11, uint32_t opcode, u
 		{
 			Data	    = *data;
 
-			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
+			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain5_fields), chain5_fields, TAP_IDLE);
 
 			CHECK_RETVAL(jtag_execute_queue());
 
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 79eb79b..71d4a01 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -75,15 +75,15 @@ static int arm720t_scan_cp15(struct target *target,
 	if (in)
 	{
 		fields[1].in_value = (uint8_t *)in;
-		jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
 		jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
 	} else
 	{
-		jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
 	}
 
 	if (clock)
-		jtag_add_runtest(0, jtag_get_end_state());
+		jtag_add_runtest(0, TAP_DRPAUSE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index d1e7a93..c6a08cf 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1750,7 +1750,7 @@ int arm7_9_restart_core(struct target *target)
 	}
 	arm_jtag_set_instr(jtag_info, 0x4, NULL);
 
-	jtag_add_runtest(1, jtag_set_end_state(TAP_IDLE));
+	jtag_add_runtest(1, TAP_IDLE);
 	return jtag_execute_queue();
 }
 
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index ab8a3e5..2d6d68f 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -72,7 +72,7 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		}
 		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
@@ -83,7 +83,7 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		fields[1].in_value = NULL;
 		fields[1].out_value = databus;
 
-		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, TAP_DRPAUSE);
 
 		if (breakpoint & 1)
 			target->debug_reason = DBG_REASON_WATCHPOINT;
@@ -147,11 +147,11 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	fields[1].out_value = NULL;
 	fields[1].in_value = (uint8_t *)in;
 
-	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
 
 	jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
 
-	jtag_add_runtest(0, jtag_get_end_state());
+	jtag_add_runtest(0, TAP_DRPAUSE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -232,11 +232,11 @@ static int arm7tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	fields[1].out_value = NULL;
 	jtag_alloc_in_value32(&fields[1]);
 
-	jtag_add_dr_scan(jtag_info->tap, 2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
 
 	jtag_add_callback4(arm7endianness, (jtag_callback_data_t)in, (jtag_callback_data_t)size, (jtag_callback_data_t)be, (jtag_callback_data_t)fields[1].in_value);
 
-	jtag_add_runtest(0, jtag_get_end_state());
+	jtag_add_runtest(0, TAP_DRPAUSE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 {
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index a7816fd..68d3997 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -111,11 +111,11 @@ static int arm920t_read_cp15_physical(struct target *target,
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
 	fields[1].in_value = (uint8_t *)value;
 
-	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -162,7 +162,7 @@ static int arm920t_write_cp15_physical(struct target *target,
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG("addr: 0x%x value: %8.8x", reg_addr, value);
@@ -214,7 +214,7 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
 	arm9tdmi_clock_out(jtag_info, arm_opcode, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index f4c4774..ea951e5 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -86,7 +86,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
 	long long then = timeval_ms();
 
@@ -95,7 +95,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 		/* rescan with NOP, to wait for the access to complete */
 		access = 0;
 		nr_w_buf = 0;
-		jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -175,7 +175,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	fields[3].out_value = &nr_w_buf;
 	fields[3].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
 	long long then = timeval_ms();
 
@@ -184,7 +184,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 		/* rescan with NOP, to wait for the access to complete */
 		access = 0;
 		nr_w_buf = 0;
-		jtag_add_dr_scan(jtag_info->tap, 4, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index 4f47644..67678c1 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -106,11 +106,11 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	fields[2].out_value = &nr_w_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
 	fields[1].in_value = (uint8_t *)value;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
@@ -158,7 +158,7 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value)
 	fields[2].out_value = &nr_w_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG("addr: 0x%x value: %8.8x", reg_addr, value);
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index f3935a3..f091188 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -107,7 +107,7 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		}
 		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
@@ -120,7 +120,7 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		fields[2].in_value = NULL;
 		fields[2].out_value = instructionbus;
 
-		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, jtag_set_end_state(TAP_DRPAUSE));
+		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, TAP_DRPAUSE);
 
 		if (debug_reason & 0x4)
 			if (debug_reason & 0x2)
@@ -177,13 +177,13 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 	if (in)
 	{
 		fields[0].in_value = (uint8_t *)in;
-		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
 	}
 	else
 	{
-		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 	}
 
 	jtag_add_runtest(0, jtag_get_end_state());
@@ -233,11 +233,11 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	fields[2].out_value = NULL;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 
 	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
 
-	jtag_add_runtest(0, jtag_get_end_state());
+	jtag_add_runtest(0, TAP_DRPAUSE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	{
@@ -300,11 +300,11 @@ int arm9tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	fields[2].out_value = NULL;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 
 	jtag_add_callback4(arm9endianness, (jtag_callback_data_t)in, (jtag_callback_data_t)size, (jtag_callback_data_t)be, (jtag_callback_data_t)fields[0].in_value);
 
-	jtag_add_runtest(0, jtag_get_end_state());
+	jtag_add_runtest(0, TAP_DRPAUSE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	{
diff --git a/src/target/arm_adi_v5.c.orig b/src/target/arm_adi_v5.c.orig
new file mode 100644
index 0000000..708e858
--- /dev/null
+++ b/src/target/arm_adi_v5.c.orig
@@ -0,0 +1,1981 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Magnus Lundin                                   *
+ *   lundin at mlu.mine.nu                                                    *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2009 by Oyvind Harboe                                   *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   Copyright (C) 2009-2010 by David Brownell                             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/**
+ * @file
+ * This file implements support for the ARM Debug Interface version 5 (ADIv5)
+ * debugging architecture.  Compared with previous versions, this includes
+ * a low pin-count Serial Wire Debug (SWD) alternative to JTAG for message
+ * transport, and focusses on memory mapped resources as defined by the
+ * CoreSight architecture.
+ *
+ * A key concept in ADIv5 is the Debug Access Port, or DAP.  A DAP has two
+ * basic components:  a Debug Port (DP) transporting messages to and from a
+ * debugger, and an Access Port (AP) accessing resources.  Three types of DP
+ * are defined.  One uses only JTAG for communication, and is called JTAG-DP.
+ * One uses only SWD for communication, and is called SW-DP.  The third can
+ * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
+ * is used to access memory mapped resources and is called a MEM-AP.  Also a
+ * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
+ *
+ * This programming interface allows DAP pipelined operations through a
+ * transaction queue.  This primarily affects AP operations (such as using
+ * a MEM-AP to access memory or registers).  If the current transaction has
+ * not finished by the time the next one must begin, and the ORUNDETECT bit
+ * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
+ * further AP operations will fail.  There are two basic methods to avoid
+ * such overrun errors.  One involves polling for status instead of using
+ * transaction piplining.  The other involves adding delays to ensure the
+ * AP has enough time to complete one operation before starting the next
+ * one.  (For JTAG these delays are controlled by memaccess_tck.)
+ */
+
+/*
+ * Relevant specifications from ARM include:
+ *
+ * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A
+ * CoreSight(tm) v1.0 Architecture Specification            ARM IHI 0029B
+ *
+ * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D
+ * Cortex-M3(tm) TRM, ARM DDI 0337G
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm.h"
+#include "arm_adi_v5.h"
+#include <helper/time_support.h>
+
+
+/* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
+
+/*
+	uint32_t tar_block_size(uint32_t address)
+	Return the largest block starting at address that does not cross a tar block size alignment boundary
+*/
+static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
+{
+	return (tar_autoincr_block - ((tar_autoincr_block - 1) & address)) >> 2;
+}
+
+/***************************************************************************
+ *                                                                         *
+<<<<<<< HEAD:src/target/arm_adi_v5.c
+=======
+ * DPACC and APACC scanchain access through JTAG-DP                        *
+ *                                                                         *
+***************************************************************************/
+
+/**
+ * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
+ * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
+ * discusses operations which access these registers.
+ *
+ * Note that only one scan is performed.  If RnW is set, a separate scan
+ * will be needed to collect the data which was read; the "invalue" collects
+ * the posted result of a preceding operation, not the current one.
+ *
+ * @param swjdp the DAP
+ * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
+ * @param reg_addr two significant bits; A[3:2]; for APACC access, the
+ *	SELECT register has more addressing bits.
+ * @param RnW false iff outvalue will be written to the DP or AP
+ * @param outvalue points to a 32-bit (little-endian) integer
+ * @param invalue NULL, or points to a 32-bit (little-endian) integer
+ * @param ack points to where the three bit JTAG_ACK_* code will be stored
+ */
+static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
+{
+	struct arm_jtag *jtag_info = swjdp->jtag_info;
+	struct scan_field fields[2];
+	uint8_t out_addr_buf;
+
+	jtag_set_end_state(TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, instr, NULL);
+
+	/* Scan out a read or write operation using some DP or AP register.
+	 * For APACC access with any sticky error flag set, this is discarded.
+	 */
+	fields[0].num_bits = 3;
+	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
+	fields[0].out_value = &out_addr_buf;
+	fields[0].in_value = ack;
+
+	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
+	 * complete; data we write is discarded, data we read is unpredictable.
+	 * When overrun detect is active, STICKYORUN is set.
+	 */
+
+	fields[1].num_bits = 32;
+	fields[1].out_value = outvalue;
+	fields[1].in_value = invalue;
+
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+
+	/* Add specified number of tck clocks after starting memory bus
+	 * access, giving the hardware time to complete the access.
+	 * They provide more time for the (MEM) AP to complete the read ...
+	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
+	 */
+	if ((instr == JTAG_DP_APACC)
+			&& ((reg_addr == AP_REG_DRW)
+				|| ((reg_addr & 0xF0) == AP_REG_BD0))
+			&& (swjdp->memaccess_tck != 0))
+		jtag_add_runtest(swjdp->memaccess_tck,
+				TAP_IDLE);
+
+	return jtag_get_error();
+}
+
+/**
+ * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
+ * This is exactly like adi_jtag_dp_scan(), except that endianness
+ * conversions are performed (so the types of invalue and outvalue
+ * must be different).
+ */
+static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
+{
+	uint8_t out_value_buf[4];
+	int retval;
+
+	buf_set_u32(out_value_buf, 0, 32, outvalue);
+
+	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
+			out_value_buf, (uint8_t *)invalue, ack);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (invalue)
+		jtag_add_callback(arm_le_to_h_u32,
+				(jtag_callback_data_t) invalue);
+
+	return retval;
+}
+
+/**
+ * Utility to write AP registers.
+ */
+static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
+		uint8_t reg_addr, uint8_t *outvalue)
+{
+	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
+			outvalue, NULL, NULL);
+}
+
+static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue)
+{
+	int retval;
+
+	/* Issue the read or write */
+	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
+			RnW, outvalue, NULL, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* For reads,  collect posted value; RDBUFF has no other effect.
+	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
+	 */
+	if ((RnW == DPAP_READ) && (invalue != NULL))
+		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
+	return retval;
+}
+
+static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
+{
+	int retval;
+	uint32_t ctrlstat;
+
+	/* too expensive to call keep_alive() here */
+
+#if 0
+	/* Danger!!!! BROKEN!!!! */
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
+	R956 introduced the check on return value here and now Michael Schwingen reports
+	that this code no longer works....
+
+	https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html
+	*/
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		LOG_ERROR("BUG: Why does this fail the first time????");
+	}
+	/* Why??? second time it works??? */
+#endif
+
+	/* Post CTRL/STAT read; discard any previous posted read value
+	 * but collect its ACK status.
+	 */
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+		return retval;
+
+	swjdp->ack = swjdp->ack & 0x7;
+
+	/* common code path avoids calling timeval_ms() */
+	if (swjdp->ack != JTAG_ACK_OK_FAULT)
+	{
+		long long then = timeval_ms();
+
+		while (swjdp->ack != JTAG_ACK_OK_FAULT)
+		{
+			if (swjdp->ack == JTAG_ACK_WAIT)
+			{
+				if ((timeval_ms()-then) > 1000)
+				{
+					/* NOTE:  this would be a good spot
+					 * to use JTAG_DP_ABORT.
+					 */
+					LOG_WARNING("Timeout (1000ms) waiting "
+						"for ACK=OK/FAULT "
+						"in JTAG-DP transaction");
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+			else
+			{
+				LOG_WARNING("Invalid ACK %#x "
+						"in JTAG-DP transaction",
+						swjdp->ack);
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+			swjdp->ack = swjdp->ack & 0x7;
+		}
+	}
+
+	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
+
+	/* Check for STICKYERR and STICKYORUN */
+	if (ctrlstat & (SSTICKYORUN | SSTICKYERR))
+	{
+		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
+		/* Check power to debug regions */
+		if ((ctrlstat & 0xf0000000) != 0xf0000000)
+			 ahbap_debugport_init(swjdp);
+		else
+		{
+			uint32_t mem_ap_csw, mem_ap_tar;
+
+			/* Maybe print information about last intended
+			 * MEM-AP access; but not if autoincrementing.
+			 * *Real* CSW and TAR values are always shown.
+			 */
+			if (swjdp->ap_tar_value != (uint32_t) -1)
+				LOG_DEBUG("MEM-AP Cached values: "
+					"ap_bank 0x%" PRIx32
+					", ap_csw 0x%" PRIx32
+					", ap_tar 0x%" PRIx32,
+					swjdp->ap_bank_value,
+					swjdp->ap_csw_value,
+					swjdp->ap_tar_value);
+
+			if (ctrlstat & SSTICKYORUN)
+				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
+					"memaccess, or reduce jtag speed");
+
+			if (ctrlstat & SSTICKYERR)
+				LOG_ERROR("JTAG-DP STICKY ERROR");
+
+			/* Clear Sticky Error Bits */
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_WRITE,
+					swjdp->dp_ctrl_stat | SSTICKYORUN
+						| SSTICKYERR, NULL);
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+
+			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
+
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_CSW, &mem_ap_csw);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_TAR, &mem_ap_tar);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
+					PRIx32, mem_ap_csw, mem_ap_tar);
+
+		}
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
+			return retval;
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+
+	return ERROR_OK;
+}
+
+/***************************************************************************
+ *                                                                         *
+>>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
+ * DP and MEM-AP  register access  through APACC and DPACC                 *
+ *                                                                         *
+***************************************************************************/
+
+/**
+ * Select one of the APs connected to the specified DAP.  The
+ * selection is implicitly used with future AP transactions.
+ * This is a NOP if the specified AP is already selected.
+ *
+ * @param swjdp The DAP
+ * @param apsel Number of the AP to (implicitly) use with further
+ *	transactions.  This normally identifies a MEM-AP.
+ */
+void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
+{
+	uint32_t select = (apsel << 24) & 0xFF000000;
+
+	if (select != swjdp->apsel)
+	{
+		swjdp->apsel = select;
+		/* Switching AP invalidates cached values.
+		 * Values MUST BE UPDATED BEFORE AP ACCESS.
+		 */
+		swjdp->ap_bank_value = -1;
+		swjdp->ap_csw_value = -1;
+		swjdp->ap_tar_value = -1;
+	}
+}
+
+/**
+ * Queue transactions setting up transfer parameters for the
+ * currently selected MEM-AP.
+ *
+ * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
+ * initiate data reads or writes using memory or peripheral addresses.
+ * If the CSW is configured for it, the TAR may be automatically
+ * incremented after each transfer.
+ *
+ * @todo Rename to reflect it being specifically a MEM-AP function.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
+ *	matches the cached value, the register is not changed.
+ * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
+ *	matches the cached address, the register is not changed.
+ *
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
+ */
+int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
+{
+	int retval;
+
+	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
+	if (csw != swjdp->ap_csw_value)
+	{
+		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
+		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
+		if (retval != ERROR_OK)
+			return retval;
+		swjdp->ap_csw_value = csw;
+	}
+	if (tar != swjdp->ap_tar_value)
+	{
+		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
+		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
+		if (retval != ERROR_OK)
+			return retval;
+		swjdp->ap_tar_value = tar;
+	}
+	/* Disable TAR cache when autoincrementing */
+	if (csw & CSW_ADDRINC_MASK)
+		swjdp->ap_tar_value = -1;
+	return ERROR_OK;
+}
+
+/**
+ * Asynchronous (queued) read of a word from memory or a system register.
+ *
+ * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param address Address of the 32-bit word to read; it must be
+ *	readable by the currently selected MEM-AP.
+ * @param value points to where the word will be stored when the
+ *	transaction queue is flushed (assuming no errors).
+ *
+ * @return ERROR_OK for success.  Otherwise a fault code.
+ */
+int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t *value)
+{
+	int retval;
+
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when reading several consecutive addresses.
+	 */
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+			address & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address & 0xC), value);
+}
+
+/**
+ * Synchronous read of a word from memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param address Address of the 32-bit word to read; it must be
+ *	readable by the currently selected MEM-AP.
+ * @param value points to where the result will be stored.
+ *
+ * @return ERROR_OK for success; *value holds the result.
+ * Otherwise a fault code.
+ */
+int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t *value)
+{
+	int retval;
+
+	retval = mem_ap_read_u32(swjdp, address, value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_run(swjdp);
+}
+
+/**
+ * Asynchronous (queued) write of a word to memory or a system register.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param address Address to be written; it must be writable by
+ *	the currently selected MEM-AP.
+ * @param value Word that will be written to the address when transaction
+ *	queue is flushed (assuming no errors).
+ *
+ * @return ERROR_OK for success.  Otherwise a fault code.
+ */
+int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t value)
+{
+	int retval;
+
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when writing several consecutive addresses.
+	 */
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+			address & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address & 0xC),
+			value);
+}
+
+/**
+ * Synchronous write of a word to memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param address Address to be written; it must be writable by
+ *	the currently selected MEM-AP.
+ * @param value Word that will be written.
+ *
+ * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
+ */
+int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t value)
+{
+	int retval = mem_ap_write_u32(swjdp, address, value);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_run(swjdp);
+}
+
+/*****************************************************************************
+*                                                                            *
+* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
+*                                                                            *
+* Write a buffer in target order (little endian)                             *
+*                                                                            *
+*****************************************************************************/
+int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+{
+	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
+	uint32_t adr = address;
+	uint8_t* pBuffer = buffer;
+
+	count >>= 2;
+	wcount = count;
+
+	/* if we have an unaligned access - reorder data */
+	if (adr & 0x3u)
+	{
+		for (writecount = 0; writecount < count; writecount++)
+		{
+			int i;
+			uint32_t outvalue;
+			memcpy(&outvalue, pBuffer, sizeof(uint32_t));
+
+			for (i = 0; i < 4; i++)
+			{
+				*((uint8_t*)pBuffer + (adr & 0x3)) = outvalue;
+				outvalue >>= 8;
+				adr++;
+			}
+			pBuffer += sizeof(uint32_t);
+		}
+	}
+
+	while (wcount > 0)
+	{
+		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+
+		for (writecount = 0; writecount < blocksize; writecount++)
+		{
+			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
+				*(uint32_t *) (buffer + 4 * writecount));
+			if (retval != ERROR_OK)
+				break;
+		}
+
+		if (dap_run(swjdp) == ERROR_OK)
+		{
+			wcount = wcount - blocksize;
+			address = address + 4 * blocksize;
+			buffer = buffer + 4 * blocksize;
+		}
+		else
+		{
+			errorcount++;
+		}
+
+		if (errorcount > 1)
+		{
+			LOG_WARNING("Block write error address 0x%" PRIx32 ", wcount 0x%x", address, wcount);
+			/* REVISIT return the *actual* fault code */
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+	}
+
+	return retval;
+}
+
+static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+	int wcount, blocksize, writecount, i;
+
+	wcount = count >> 1;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		writecount = blocksize;
+
+		do
+		{
+			nbytes = MIN((writecount << 1), 4);
+
+			if (nbytes < 4)
+			{
+				if (mem_ap_write_buf_u16(swjdp, buffer,
+						nbytes, address) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+
+				address += nbytes >> 1;
+			}
+			else
+			{
+				uint32_t outvalue;
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+
+				for (i = 0; i < nbytes; i++)
+				{
+					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
+					outvalue >>= 8;
+					address++;
+				}
+
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+				retval = dap_queue_ap_write(swjdp,
+						AP_REG_DRW, outvalue);
+				if (retval != ERROR_OK)
+					break;
+
+				if (dap_run(swjdp) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					/* REVISIT return *actual* fault code */
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+
+			buffer += nbytes >> 1;
+			writecount -= nbytes >> 1;
+
+		} while (writecount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		uint16_t svalue;
+		memcpy(&svalue, buffer, sizeof(uint16_t));
+		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
+		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		if (retval != ERROR_OK)
+			break;
+
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		count -= 2;
+		address += 2;
+		buffer += 2;
+	}
+
+	return retval;
+}
+
+static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+	int wcount, blocksize, writecount, i;
+
+	wcount = count;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		writecount = blocksize;
+
+		do
+		{
+			nbytes = MIN(writecount, 4);
+
+			if (nbytes < 4)
+			{
+				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+
+				address += nbytes;
+			}
+			else
+			{
+				uint32_t outvalue;
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+
+				for (i = 0; i < nbytes; i++)
+				{
+					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
+					outvalue >>= 8;
+					address++;
+				}
+
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+				retval = dap_queue_ap_write(swjdp,
+						AP_REG_DRW, outvalue);
+				if (retval != ERROR_OK)
+					break;
+
+				if (dap_run(swjdp) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					/* REVISIT return *actual* fault code */
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+
+			buffer += nbytes;
+			writecount -= nbytes;
+
+		} while (writecount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
+		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		if (retval != ERROR_OK)
+			break;
+
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		count--;
+		address++;
+		buffer++;
+	}
+
+	return retval;
+}
+
+/* FIXME don't import ... this is a temporary workaround for the
+ * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
+ */
+extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
+
+/**
+ * Synchronously read a block of 32-bit words into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the words will be stored (in host byte order).
+ * @param count How many words to read.
+ * @param address Memory address from which to read words; all the
+ *	words must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
+{
+	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
+	uint32_t adr = address;
+	uint8_t* pBuffer = buffer;
+
+	count >>= 2;
+	wcount = count;
+
+	while (wcount > 0)
+	{
+		/* Adjust to read blocks within boundaries aligned to the
+		 * TAR autoincrement size (at least 2^10).  Autoincrement
+		 * mode avoids an extra per-word roundtrip to update TAR.
+		 */
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block,
+				address);
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
+				address);
+
+		/* FIXME remove these three calls to adi_jtag_dp_scan(),
+		 * so this routine becomes transport-neutral.  Be careful
+		 * not to cause performance problems with JTAG; would it
+		 * suffice to loop over dap_queue_ap_read(), or would that
+		 * be slower when JTAG is the chosen transport?
+		 */
+
+		/* Scan out first read */
+		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+				DPAP_READ, 0, NULL, NULL);
+		for (readcount = 0; readcount < blocksize - 1; readcount++)
+		{
+			/* Scan out next read; scan in posted value for the
+			 * previous one.  Assumes read is acked "OK/FAULT",
+			 * and CTRL_STAT says that meant "OK".
+			 */
+			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+					DPAP_READ, 0, buffer + 4 * readcount,
+					&swjdp->ack);
+		}
+
+		/* Scan in last posted value; RDBUFF has no other effect,
+		 * assuming ack is OK/FAULT and CTRL_STAT says "OK".
+		 */
+		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
+				DPAP_READ, 0, buffer + 4 * readcount,
+				&swjdp->ack);
+		if (dap_run(swjdp) == ERROR_OK)
+		{
+			wcount = wcount - blocksize;
+			address += 4 * blocksize;
+			buffer += 4 * blocksize;
+		}
+		else
+		{
+			errorcount++;
+		}
+
+		if (errorcount > 1)
+		{
+			LOG_WARNING("Block read error address 0x%" PRIx32
+				", count 0x%x", address, count);
+			/* REVISIT return the *actual* fault code */
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+	}
+
+	/* if we have an unaligned access - reorder data */
+	if (adr & 0x3u)
+	{
+		for (readcount = 0; readcount < count; readcount++)
+		{
+			int i;
+			uint32_t data;
+			memcpy(&data, pBuffer, sizeof(uint32_t));
+
+			for (i = 0; i < 4; i++)
+			{
+				*((uint8_t*)pBuffer) =
+						(data >> 8 * (adr & 0x3));
+				pBuffer++;
+				adr++;
+			}
+		}
+	}
+
+	return retval;
+}
+
+static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	uint32_t invalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, readcount, i;
+
+	wcount = count >> 1;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+		readcount = blocksize;
+
+		do
+		{
+			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+			if (dap_run(swjdp) != ERROR_OK)
+			{
+				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
+				/* REVISIT return the *actual* fault code */
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			nbytes = MIN((readcount << 1), 4);
+
+			for (i = 0; i < nbytes; i++)
+			{
+				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+				buffer++;
+				address++;
+			}
+
+			readcount -= (nbytes >> 1);
+		} while (readcount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+/**
+ * Synchronously read a block of 16-bit halfwords into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the halfwords will be stored (in host byte order).
+ * @param count How many halfwords to read.
+ * @param address Memory address from which to read words; all the
+ *	words must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
+{
+	uint32_t invalue, i;
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+		if (retval != ERROR_OK)
+			break;
+
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		if (address & 0x1)
+		{
+			for (i = 0; i < 2; i++)
+			{
+				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+				buffer++;
+				address++;
+			}
+		}
+		else
+		{
+			uint16_t svalue = (invalue >> 8 * (address & 0x3));
+			memcpy(buffer, &svalue, sizeof(uint16_t));
+			address += 2;
+			buffer += 2;
+		}
+		count -= 2;
+	}
+
+	return retval;
+}
+
+/* FIX!!! is this a potential performance bottleneck w.r.t. requiring too many
+ * roundtrips when jtag_execute_queue() has a large overhead(e.g. for USB)s?
+ *
+ * The solution is to arrange for a large out/in scan in this loop and
+ * and convert data afterwards.
+ */
+static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	uint32_t invalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, readcount, i;
+
+	wcount = count;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		readcount = blocksize;
+
+		do
+		{
+			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+			if (dap_run(swjdp) != ERROR_OK)
+			{
+				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
+				/* REVISIT return the *actual* fault code */
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			nbytes = MIN(readcount, 4);
+
+			for (i = 0; i < nbytes; i++)
+			{
+				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+				buffer++;
+				address++;
+			}
+
+			readcount -= nbytes;
+		} while (readcount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+/**
+ * Synchronously read a block of bytes into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the bytes will be stored.
+ * @param count How many bytes to read.
+ * @param address Memory address from which to read data; all the
+ *	data must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
+{
+	uint32_t invalue;
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+		count--;
+		address++;
+		buffer++;
+	}
+
+	return retval;
+}
+
+/*--------------------------------------------------------------------------*/
+
+<<<<<<< HEAD:src/target/arm_adi_v5.c
+=======
+static int jtag_idcode_q_read(struct adiv5_dap *dap,
+		uint8_t *ack, uint32_t *data)
+{
+	struct arm_jtag *jtag_info = dap->jtag_info;
+	int retval;
+	struct scan_field fields[1];
+
+	jtag_set_end_state(TAP_IDLE);
+
+	/* This is a standard JTAG operation -- no DAP tweakage */
+	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	fields[0].num_bits = 32;
+	fields[0].out_value = NULL;
+	fields[0].in_value = (void *) data;
+
+	jtag_add_dr_scan(jtag_info->tap, 1, fields, TAP_IDLE);
+	retval = jtag_get_error();
+	if (retval != ERROR_OK)
+		return retval;
+
+	jtag_add_callback(arm_le_to_h_u32,
+			(jtag_callback_data_t) data);
+
+	return retval;
+}
+
+static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_READ, 0, data);
+}
+
+static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_WRITE, data, NULL);
+}
+
+/** Select the AP register bank matching bits 7:4 of reg. */
+static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
+{
+	uint32_t select = reg & 0x000000F0;
+
+	if (select == dap->ap_bank_value)
+		return ERROR_OK;
+	dap->ap_bank_value = select;
+
+	select |= dap->apsel;
+
+	return jtag_dp_q_write(dap, DP_SELECT, select);
+}
+
+static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	int retval = jtag_ap_q_bankselect(dap, reg);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
+			DPAP_READ, 0, data);
+}
+
+static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	uint8_t out_value_buf[4];
+
+	int retval = jtag_ap_q_bankselect(dap, reg);
+	if (retval != ERROR_OK)
+		return retval;
+>>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
+
+/* FIXME don't import ... just initialize as
+ * part of DAP transport setup
+*/
+extern const struct dap_ops jtag_dp_ops;
+
+/*--------------------------------------------------------------------------*/
+
+/**
+ * Initialize a DAP.  This sets up the power domains, prepares the DP
+ * for further use, and arranges to use AP #0 for all AP operations
+ * until dap_ap-select() changes that policy.
+ *
+ * @param swjdp The DAP being initialized.
+ *
+ * @todo Rename this.  We also need an initialization scheme which account
+ * for SWD transports not just JTAG; that will need to address differences
+ * in layering.  (JTAG is useful without any debug target; but not SWD.)
+ * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
+ */
+int ahbap_debugport_init(struct adiv5_dap *swjdp)
+{
+	uint32_t idreg, romaddr, dummy;
+	uint32_t ctrlstat;
+	int cnt = 0;
+	int retval;
+
+	LOG_DEBUG(" ");
+
+	/* JTAG-DP or SWJ-DP, in JTAG mode */
+	swjdp->ops = &jtag_dp_ops;
+
+	/* Default MEM-AP setup.
+	 *
+	 * REVISIT AP #0 may be an inappropriate default for this.
+	 * Should we probe, or take a hint from the caller?
+	 * Presumably we can ignore the possibility of multiple APs.
+	 */
+	swjdp->apsel = !0;
+	dap_ap_select(swjdp, 0);
+
+	/* DP initialization */
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+	if (retval != ERROR_OK)
+		return retval;
+	if ((retval = dap_run(swjdp)) != ERROR_OK)
+		return retval;
+
+	/* Check that we have debug power domains activated */
+	while (!(ctrlstat & CDBGPWRUPACK) && (cnt++ < 10))
+	{
+		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
+		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
+			return retval;
+		alive_sleep(10);
+	}
+
+	while (!(ctrlstat & CSYSPWRUPACK) && (cnt++ < 10))
+	{
+		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
+		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
+			return retval;
+		alive_sleep(10);
+	}
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+	/* With debug power on we can activate OVERRUN checking */
+	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * REVISIT this isn't actually *initializing* anything in an AP,
+	 * and doesn't care if it's a MEM-AP at all (much less AHB-AP).
+	 * Should it?  If the ROM address is valid, is this the right
+	 * place to scan the table and do any topology detection?
+	 */
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &idreg);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &romaddr);
+
+	LOG_DEBUG("MEM-AP #%d ID Register 0x%" PRIx32
+		", Debug ROM Address 0x%" PRIx32,
+		swjdp->apsel, idreg, romaddr);
+
+	return ERROR_OK;
+}
+
+/* CID interpretation -- see ARM IHI 0029B section 3
+ * and ARM IHI 0031A table 13-3.
+ */
+static const char *class_description[16] ={
+	"Reserved", "ROM table", "Reserved", "Reserved",
+	"Reserved", "Reserved", "Reserved", "Reserved",
+	"Reserved", "CoreSight component", "Reserved", "Peripheral Test Block",
+	"Reserved", "OptimoDE DESS",
+		"Generic IP component", "PrimeCell or System component"
+};
+
+static bool
+is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
+{
+	return cid3 == 0xb1 && cid2 == 0x05
+			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
+}
+
+static int dap_info_command(struct command_context *cmd_ctx,
+		struct adiv5_dap *swjdp, int apsel)
+{
+	int retval;
+	uint32_t dbgbase, apid;
+	int romtable_present = 0;
+	uint8_t mem_ap;
+	uint32_t apselold;
+
+	/* AP address is in bits 31:24 of DP_SELECT */
+	if (apsel >= 256)
+		return ERROR_INVALID_ARGUMENTS;
+
+	apselold = swjdp->apsel;
+	dap_ap_select(swjdp, apsel);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &dbgbase);
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
+	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
+	mem_ap = ((apid&0x10000) && ((apid&0x0F) != 0));
+	command_print(cmd_ctx, "AP ID register 0x%8.8" PRIx32, apid);
+	if (apid)
+	{
+		switch (apid&0x0F)
+		{
+			case 0:
+				command_print(cmd_ctx, "\tType is JTAG-AP");
+				break;
+			case 1:
+				command_print(cmd_ctx, "\tType is MEM-AP AHB");
+				break;
+			case 2:
+				command_print(cmd_ctx, "\tType is MEM-AP APB");
+				break;
+			default:
+				command_print(cmd_ctx, "\tUnknown AP type");
+				break;
+		}
+
+		/* NOTE: a MEM-AP may have a single CoreSight component that's
+		 * not a ROM table ... or have no such components at all.
+		 */
+		if (mem_ap)
+			command_print(cmd_ctx, "AP BASE 0x%8.8" PRIx32,
+					dbgbase);
+	}
+	else
+	{
+		command_print(cmd_ctx, "No AP found at this apsel 0x%x", apsel);
+	}
+
+	romtable_present = ((mem_ap) && (dbgbase != 0xFFFFFFFF));
+	if (romtable_present)
+	{
+		uint32_t cid0,cid1,cid2,cid3,memtype,romentry;
+		uint16_t entry_offset;
+
+		/* bit 16 of apid indicates a memory access port */
+		if (dbgbase & 0x02)
+			command_print(cmd_ctx, "\tValid ROM table present");
+		else
+			command_print(cmd_ctx, "\tROM table in legacy format");
+
+		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
+			command_print(cmd_ctx, "\tCID3 0x%2.2" PRIx32
+					", CID2 0x%2.2" PRIx32
+					", CID1 0x%2.2" PRIx32
+					", CID0 0x%2.2" PRIx32,
+					cid3, cid2, cid1, cid0);
+		if (memtype & 0x01)
+			command_print(cmd_ctx, "\tMEMTYPE system memory present on bus");
+		else
+			command_print(cmd_ctx, "\tMEMTYPE System memory not present. "
+					"Dedicated debug bus.");
+
+		/* Now we read ROM table entries from dbgbase&0xFFFFF000) | 0x000 until we get 0x00000000 */
+		entry_offset = 0;
+		do
+		{
+			mem_ap_read_atomic_u32(swjdp, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
+			command_print(cmd_ctx, "\tROMTABLE[0x%x] = 0x%" PRIx32 "",entry_offset,romentry);
+			if (romentry&0x01)
+			{
+				uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
+				uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
+				uint32_t component_start, component_base;
+				unsigned part_num;
+				char *type, *full;
+
+				component_base = (uint32_t)((dbgbase & 0xFFFFF000)
+						+ (int)(romentry & 0xFFFFF000));
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFE0, &c_pid0);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFE4, &c_pid1);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFE8, &c_pid2);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFEC, &c_pid3);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFD0, &c_pid4);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFF0, &c_cid0);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFF4, &c_cid1);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFF8, &c_cid2);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFFC, &c_cid3);
+				component_start = component_base - 0x1000*(c_pid4 >> 4);
+
+				command_print(cmd_ctx, "\t\tComponent base address 0x%" PRIx32
+						", start address 0x%" PRIx32,
+						component_base, component_start);
+				command_print(cmd_ctx, "\t\tComponent class is 0x%x, %s",
+						(int) (c_cid1 >> 4) & 0xf,
+						/* See ARM IHI 0029B Table 3-3 */
+						class_description[(c_cid1 >> 4) & 0xf]);
+
+				/* CoreSight component? */
+				if (((c_cid1 >> 4) & 0x0f) == 9) {
+					uint32_t devtype;
+					unsigned minor;
+					char *major = "Reserved", *subtype = "Reserved";
+
+					mem_ap_read_atomic_u32(swjdp,
+							(component_base & 0xfffff000) | 0xfcc,
+							&devtype);
+					minor = (devtype >> 4) & 0x0f;
+					switch (devtype & 0x0f) {
+					case 0:
+						major = "Miscellaneous";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 4:
+							subtype = "Validation component";
+							break;
+						}
+						break;
+					case 1:
+						major = "Trace Sink";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Port";
+							break;
+						case 2:
+							subtype = "Buffer";
+							break;
+						}
+						break;
+					case 2:
+						major = "Trace Link";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Funnel, router";
+							break;
+						case 2:
+							subtype = "Filter";
+							break;
+						case 3:
+							subtype = "FIFO, buffer";
+							break;
+						}
+						break;
+					case 3:
+						major = "Trace Source";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Processor";
+							break;
+						case 2:
+							subtype = "DSP";
+							break;
+						case 3:
+							subtype = "Engine/Coprocessor";
+							break;
+						case 4:
+							subtype = "Bus";
+							break;
+						}
+						break;
+					case 4:
+						major = "Debug Control";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Trigger Matrix";
+							break;
+						case 2:
+							subtype = "Debug Auth";
+							break;
+						}
+						break;
+					case 5:
+						major = "Debug Logic";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Processor";
+							break;
+						case 2:
+							subtype = "DSP";
+							break;
+						case 3:
+							subtype = "Engine/Coprocessor";
+							break;
+						}
+						break;
+					}
+					command_print(cmd_ctx, "\t\tType is 0x%2.2x, %s, %s",
+							(unsigned) (devtype & 0xff),
+							major, subtype);
+					/* REVISIT also show 0xfc8 DevId */
+				}
+
+				if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
+					command_print(cmd_ctx, "\t\tCID3 0x%2.2" PRIx32
+							", CID2 0x%2.2" PRIx32
+							", CID1 0x%2.2" PRIx32
+							", CID0 0x%2.2" PRIx32,
+							c_cid3, c_cid2, c_cid1, c_cid0);
+				command_print(cmd_ctx, "\t\tPeripheral ID[4..0] = hex "
+						"%2.2x %2.2x %2.2x %2.2x %2.2x",
+						(int) c_pid4,
+						(int) c_pid3, (int) c_pid2,
+						(int) c_pid1, (int) c_pid0);
+
+				/* Part number interpretations are from Cortex
+				 * core specs, the CoreSight components TRM
+				 * (ARM DDI 0314H), and ETM specs; also from
+				 * chip observation (e.g. TI SDTI).
+				 */
+				part_num = c_pid0 & 0xff;
+				part_num |= (c_pid1 & 0x0f) << 8;
+				switch (part_num) {
+				case 0x000:
+					type = "Cortex-M3 NVIC";
+					full = "(Interrupt Controller)";
+					break;
+				case 0x001:
+					type = "Cortex-M3 ITM";
+					full = "(Instrumentation Trace Module)";
+					break;
+				case 0x002:
+					type = "Cortex-M3 DWT";
+					full = "(Data Watchpoint and Trace)";
+					break;
+				case 0x003:
+					type = "Cortex-M3 FBP";
+					full = "(Flash Patch and Breakpoint)";
+					break;
+				case 0x00d:
+					type = "CoreSight ETM11";
+					full = "(Embedded Trace)";
+					break;
+				// case 0x113: what?
+				case 0x120:		/* from OMAP3 memmap */
+					type = "TI SDTI";
+					full = "(System Debug Trace Interface)";
+					break;
+				case 0x343:		/* from OMAP3 memmap */
+					type = "TI DAPCTL";
+					full = "";
+					break;
+				case 0x906:
+					type = "Coresight CTI";
+					full = "(Cross Trigger)";
+					break;
+				case 0x907:
+					type = "Coresight ETB";
+					full = "(Trace Buffer)";
+					break;
+				case 0x908:
+					type = "Coresight CSTF";
+					full = "(Trace Funnel)";
+					break;
+				case 0x910:
+					type = "CoreSight ETM9";
+					full = "(Embedded Trace)";
+					break;
+				case 0x912:
+					type = "Coresight TPIU";
+					full = "(Trace Port Interface Unit)";
+					break;
+				case 0x921:
+					type = "Cortex-A8 ETM";
+					full = "(Embedded Trace)";
+					break;
+				case 0x922:
+					type = "Cortex-A8 CTI";
+					full = "(Cross Trigger)";
+					break;
+				case 0x923:
+					type = "Cortex-M3 TPIU";
+					full = "(Trace Port Interface Unit)";
+					break;
+				case 0x924:
+					type = "Cortex-M3 ETM";
+					full = "(Embedded Trace)";
+					break;
+				case 0xc08:
+					type = "Cortex-A8 Debug";
+					full = "(Debug Unit)";
+					break;
+				default:
+					type = "-*- unrecognized -*-";
+					full = "";
+					break;
+				}
+				command_print(cmd_ctx, "\t\tPart is %s %s",
+						type, full);
+			}
+			else
+			{
+				if (romentry)
+					command_print(cmd_ctx, "\t\tComponent not present");
+				else
+					command_print(cmd_ctx, "\t\tEnd of ROM table");
+			}
+			entry_offset += 4;
+		} while (romentry > 0);
+	}
+	else
+	{
+		command_print(cmd_ctx, "\tNo ROM table present");
+	}
+	dap_ap_select(swjdp, apselold);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_dap_info_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+	uint32_t apsel;
+
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = dap->apsel;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	return dap_info_command(CMD_CTX, dap, apsel);
+}
+
+COMMAND_HANDLER(dap_baseaddr_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t apsel, apselsave, baseaddr;
+	int retval;
+
+	apselsave = dap->apsel;
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = dap->apsel;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		/* AP address is in bits 31:24 of DP_SELECT */
+		if (apsel >= 256)
+			return ERROR_INVALID_ARGUMENTS;
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (apselsave != apsel)
+		dap_ap_select(dap, apsel);
+
+	/* NOTE:  assumes we're talking to a MEM-AP, which
+	 * has a base address.  There are other kinds of AP,
+	 * though they're not common for now.  This should
+	 * use the ID register to verify it's a MEM-AP.
+	 */
+	retval = dap_queue_ap_read(dap, AP_REG_BASE, &baseaddr);
+	retval = dap_run(dap);
+	if (retval != ERROR_OK)
+		return retval;
+
+	command_print(CMD_CTX, "0x%8.8" PRIx32, baseaddr);
+
+	if (apselsave != apsel)
+		dap_ap_select(dap, apselsave);
+
+	return retval;
+}
+
+COMMAND_HANDLER(dap_memaccess_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t memaccess_tck;
+
+	switch (CMD_ARGC) {
+	case 0:
+		memaccess_tck = dap->memaccess_tck;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	dap->memaccess_tck = memaccess_tck;
+
+	command_print(CMD_CTX, "memory bus access delay set to %" PRIi32 " tck",
+			dap->memaccess_tck);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(dap_apsel_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t apsel, apid;
+	int retval;
+
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = 0;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		/* AP address is in bits 31:24 of DP_SELECT */
+		if (apsel >= 256)
+			return ERROR_INVALID_ARGUMENTS;
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	dap_ap_select(dap, apsel);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	retval = dap_run(dap);
+	if (retval != ERROR_OK)
+		return retval;
+
+	command_print(CMD_CTX, "ap %" PRIi32 " selected, identification register 0x%8.8" PRIx32,
+			apsel, apid);
+
+	return retval;
+}
+
+COMMAND_HANDLER(dap_apid_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t apsel, apselsave, apid;
+	int retval;
+
+	apselsave = dap->apsel;
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = dap->apsel;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		/* AP address is in bits 31:24 of DP_SELECT */
+		if (apsel >= 256)
+			return ERROR_INVALID_ARGUMENTS;
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (apselsave != apsel)
+		dap_ap_select(dap, apsel);
+
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	retval = dap_run(dap);
+	if (retval != ERROR_OK)
+		return retval;
+
+	command_print(CMD_CTX, "0x%8.8" PRIx32, apid);
+	if (apselsave != apsel)
+		dap_ap_select(dap, apselsave);
+
+	return retval;
+}
+
+static const struct command_registration dap_commands[] = {
+	{
+		.name = "info",
+		.handler = handle_dap_info_command,
+		.mode = COMMAND_EXEC,
+		.help = "display ROM table for MEM-AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "apsel",
+		.handler = dap_apsel_command,
+		.mode = COMMAND_EXEC,
+		.help = "Set the currently selected AP (default 0) "
+			"and display the result",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "apid",
+		.handler = dap_apid_command,
+		.mode = COMMAND_EXEC,
+		.help = "return ID register from AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "baseaddr",
+		.handler = dap_baseaddr_command,
+		.mode = COMMAND_EXEC,
+		.help = "return debug base address from MEM-AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "memaccess",
+		.handler = dap_memaccess_command,
+		.mode = COMMAND_EXEC,
+		.help = "set/get number of extra tck for MEM-AP memory "
+			"bus access [0-255]",
+		.usage = "[cycles]",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration dap_command_handlers[] = {
+	{
+		.name = "dap",
+		.mode = COMMAND_EXEC,
+		.help = "DAP command group",
+		.chain = dap_commands,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+
+/*
+ * This represents the bits which must be sent out on TMS/SWDIO to
+ * switch a DAP implemented using an SWJ-DP module into SWD mode.
+ * These bits are stored (and transmitted) LSB-first.
+ *
+ * See the DAP-Lite specification, section 2.2.5 for information
+ * about making the debug link select SWD or JTAG.  (Similar info
+ * is in a few other ARM documents.)
+ */
+static const uint8_t jtag2swd_bitseq[] = {
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* Switching sequence enables SWD and disables JTAG
+	 * NOTE: bits in the DP's IDCODE may expose the need for
+	 * an old/deprecated sequence (0xb6 0xed).
+	 */
+	0x9e, 0xe7,
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+
+/**
+ * Put the debug link into SWD mode, if the target supports it.
+ * The link's initial mode may be either JTAG (for example,
+ * with SWJ-DP after reset) or SWD.
+ *
+ * @param target Enters SWD mode (if possible).
+ *
+ * Note that targets using the JTAG-DP do not support SWD, and that
+ * some targets which could otherwise support it may have have been
+ * configured to disable SWD signaling
+ *
+ * @return ERROR_OK or else a fault code.
+ */
+int dap_to_swd(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG("Enter SWD mode");
+
+	/* REVISIT it's nasty to need to make calls to a "jtag"
+	 * subsystem if the link isn't in JTAG mode...
+	 */
+
+	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
+			jtag2swd_bitseq, TAP_INVALID);
+	if (retval == ERROR_OK)
+		retval = jtag_execute_queue();
+
+	/* REVISIT set up the DAP's ops vector for SWD mode. */
+
+	return retval;
+}
+
diff --git a/src/target/arm_adi_v5.c~ b/src/target/arm_adi_v5.c~
new file mode 100644
index 0000000..708e858
--- /dev/null
+++ b/src/target/arm_adi_v5.c~
@@ -0,0 +1,1981 @@
+/***************************************************************************
+ *   Copyright (C) 2006 by Magnus Lundin                                   *
+ *   lundin at mlu.mine.nu                                                    *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2009 by Oyvind Harboe                                   *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   Copyright (C) 2009-2010 by David Brownell                             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/**
+ * @file
+ * This file implements support for the ARM Debug Interface version 5 (ADIv5)
+ * debugging architecture.  Compared with previous versions, this includes
+ * a low pin-count Serial Wire Debug (SWD) alternative to JTAG for message
+ * transport, and focusses on memory mapped resources as defined by the
+ * CoreSight architecture.
+ *
+ * A key concept in ADIv5 is the Debug Access Port, or DAP.  A DAP has two
+ * basic components:  a Debug Port (DP) transporting messages to and from a
+ * debugger, and an Access Port (AP) accessing resources.  Three types of DP
+ * are defined.  One uses only JTAG for communication, and is called JTAG-DP.
+ * One uses only SWD for communication, and is called SW-DP.  The third can
+ * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
+ * is used to access memory mapped resources and is called a MEM-AP.  Also a
+ * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
+ *
+ * This programming interface allows DAP pipelined operations through a
+ * transaction queue.  This primarily affects AP operations (such as using
+ * a MEM-AP to access memory or registers).  If the current transaction has
+ * not finished by the time the next one must begin, and the ORUNDETECT bit
+ * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
+ * further AP operations will fail.  There are two basic methods to avoid
+ * such overrun errors.  One involves polling for status instead of using
+ * transaction piplining.  The other involves adding delays to ensure the
+ * AP has enough time to complete one operation before starting the next
+ * one.  (For JTAG these delays are controlled by memaccess_tck.)
+ */
+
+/*
+ * Relevant specifications from ARM include:
+ *
+ * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A
+ * CoreSight(tm) v1.0 Architecture Specification            ARM IHI 0029B
+ *
+ * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D
+ * Cortex-M3(tm) TRM, ARM DDI 0337G
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm.h"
+#include "arm_adi_v5.h"
+#include <helper/time_support.h>
+
+
+/* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
+
+/*
+	uint32_t tar_block_size(uint32_t address)
+	Return the largest block starting at address that does not cross a tar block size alignment boundary
+*/
+static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
+{
+	return (tar_autoincr_block - ((tar_autoincr_block - 1) & address)) >> 2;
+}
+
+/***************************************************************************
+ *                                                                         *
+<<<<<<< HEAD:src/target/arm_adi_v5.c
+=======
+ * DPACC and APACC scanchain access through JTAG-DP                        *
+ *                                                                         *
+***************************************************************************/
+
+/**
+ * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
+ * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
+ * discusses operations which access these registers.
+ *
+ * Note that only one scan is performed.  If RnW is set, a separate scan
+ * will be needed to collect the data which was read; the "invalue" collects
+ * the posted result of a preceding operation, not the current one.
+ *
+ * @param swjdp the DAP
+ * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
+ * @param reg_addr two significant bits; A[3:2]; for APACC access, the
+ *	SELECT register has more addressing bits.
+ * @param RnW false iff outvalue will be written to the DP or AP
+ * @param outvalue points to a 32-bit (little-endian) integer
+ * @param invalue NULL, or points to a 32-bit (little-endian) integer
+ * @param ack points to where the three bit JTAG_ACK_* code will be stored
+ */
+static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
+{
+	struct arm_jtag *jtag_info = swjdp->jtag_info;
+	struct scan_field fields[2];
+	uint8_t out_addr_buf;
+
+	jtag_set_end_state(TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, instr, NULL);
+
+	/* Scan out a read or write operation using some DP or AP register.
+	 * For APACC access with any sticky error flag set, this is discarded.
+	 */
+	fields[0].num_bits = 3;
+	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
+	fields[0].out_value = &out_addr_buf;
+	fields[0].in_value = ack;
+
+	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
+	 * complete; data we write is discarded, data we read is unpredictable.
+	 * When overrun detect is active, STICKYORUN is set.
+	 */
+
+	fields[1].num_bits = 32;
+	fields[1].out_value = outvalue;
+	fields[1].in_value = invalue;
+
+	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+
+	/* Add specified number of tck clocks after starting memory bus
+	 * access, giving the hardware time to complete the access.
+	 * They provide more time for the (MEM) AP to complete the read ...
+	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
+	 */
+	if ((instr == JTAG_DP_APACC)
+			&& ((reg_addr == AP_REG_DRW)
+				|| ((reg_addr & 0xF0) == AP_REG_BD0))
+			&& (swjdp->memaccess_tck != 0))
+		jtag_add_runtest(swjdp->memaccess_tck,
+				TAP_IDLE);
+
+	return jtag_get_error();
+}
+
+/**
+ * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
+ * This is exactly like adi_jtag_dp_scan(), except that endianness
+ * conversions are performed (so the types of invalue and outvalue
+ * must be different).
+ */
+static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
+{
+	uint8_t out_value_buf[4];
+	int retval;
+
+	buf_set_u32(out_value_buf, 0, 32, outvalue);
+
+	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
+			out_value_buf, (uint8_t *)invalue, ack);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (invalue)
+		jtag_add_callback(arm_le_to_h_u32,
+				(jtag_callback_data_t) invalue);
+
+	return retval;
+}
+
+/**
+ * Utility to write AP registers.
+ */
+static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
+		uint8_t reg_addr, uint8_t *outvalue)
+{
+	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
+			outvalue, NULL, NULL);
+}
+
+static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint32_t outvalue, uint32_t *invalue)
+{
+	int retval;
+
+	/* Issue the read or write */
+	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
+			RnW, outvalue, NULL, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* For reads,  collect posted value; RDBUFF has no other effect.
+	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
+	 */
+	if ((RnW == DPAP_READ) && (invalue != NULL))
+		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
+	return retval;
+}
+
+static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
+{
+	int retval;
+	uint32_t ctrlstat;
+
+	/* too expensive to call keep_alive() here */
+
+#if 0
+	/* Danger!!!! BROKEN!!!! */
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
+	R956 introduced the check on return value here and now Michael Schwingen reports
+	that this code no longer works....
+
+	https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html
+	*/
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		LOG_ERROR("BUG: Why does this fail the first time????");
+	}
+	/* Why??? second time it works??? */
+#endif
+
+	/* Post CTRL/STAT read; discard any previous posted read value
+	 * but collect its ACK status.
+	 */
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+		return retval;
+
+	swjdp->ack = swjdp->ack & 0x7;
+
+	/* common code path avoids calling timeval_ms() */
+	if (swjdp->ack != JTAG_ACK_OK_FAULT)
+	{
+		long long then = timeval_ms();
+
+		while (swjdp->ack != JTAG_ACK_OK_FAULT)
+		{
+			if (swjdp->ack == JTAG_ACK_WAIT)
+			{
+				if ((timeval_ms()-then) > 1000)
+				{
+					/* NOTE:  this would be a good spot
+					 * to use JTAG_DP_ABORT.
+					 */
+					LOG_WARNING("Timeout (1000ms) waiting "
+						"for ACK=OK/FAULT "
+						"in JTAG-DP transaction");
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+			else
+			{
+				LOG_WARNING("Invalid ACK %#x "
+						"in JTAG-DP transaction",
+						swjdp->ack);
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+			swjdp->ack = swjdp->ack & 0x7;
+		}
+	}
+
+	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
+
+	/* Check for STICKYERR and STICKYORUN */
+	if (ctrlstat & (SSTICKYORUN | SSTICKYERR))
+	{
+		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
+		/* Check power to debug regions */
+		if ((ctrlstat & 0xf0000000) != 0xf0000000)
+			 ahbap_debugport_init(swjdp);
+		else
+		{
+			uint32_t mem_ap_csw, mem_ap_tar;
+
+			/* Maybe print information about last intended
+			 * MEM-AP access; but not if autoincrementing.
+			 * *Real* CSW and TAR values are always shown.
+			 */
+			if (swjdp->ap_tar_value != (uint32_t) -1)
+				LOG_DEBUG("MEM-AP Cached values: "
+					"ap_bank 0x%" PRIx32
+					", ap_csw 0x%" PRIx32
+					", ap_tar 0x%" PRIx32,
+					swjdp->ap_bank_value,
+					swjdp->ap_csw_value,
+					swjdp->ap_tar_value);
+
+			if (ctrlstat & SSTICKYORUN)
+				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
+					"memaccess, or reduce jtag speed");
+
+			if (ctrlstat & SSTICKYERR)
+				LOG_ERROR("JTAG-DP STICKY ERROR");
+
+			/* Clear Sticky Error Bits */
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_WRITE,
+					swjdp->dp_ctrl_stat | SSTICKYORUN
+						| SSTICKYERR, NULL);
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+
+			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
+
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_CSW, &mem_ap_csw);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = dap_queue_ap_read(swjdp,
+					AP_REG_TAR, &mem_ap_tar);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if ((retval = dap_run(swjdp)) != ERROR_OK)
+				return retval;
+			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
+					PRIx32, mem_ap_csw, mem_ap_tar);
+
+		}
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
+			return retval;
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+
+	return ERROR_OK;
+}
+
+/***************************************************************************
+ *                                                                         *
+>>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
+ * DP and MEM-AP  register access  through APACC and DPACC                 *
+ *                                                                         *
+***************************************************************************/
+
+/**
+ * Select one of the APs connected to the specified DAP.  The
+ * selection is implicitly used with future AP transactions.
+ * This is a NOP if the specified AP is already selected.
+ *
+ * @param swjdp The DAP
+ * @param apsel Number of the AP to (implicitly) use with further
+ *	transactions.  This normally identifies a MEM-AP.
+ */
+void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
+{
+	uint32_t select = (apsel << 24) & 0xFF000000;
+
+	if (select != swjdp->apsel)
+	{
+		swjdp->apsel = select;
+		/* Switching AP invalidates cached values.
+		 * Values MUST BE UPDATED BEFORE AP ACCESS.
+		 */
+		swjdp->ap_bank_value = -1;
+		swjdp->ap_csw_value = -1;
+		swjdp->ap_tar_value = -1;
+	}
+}
+
+/**
+ * Queue transactions setting up transfer parameters for the
+ * currently selected MEM-AP.
+ *
+ * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
+ * initiate data reads or writes using memory or peripheral addresses.
+ * If the CSW is configured for it, the TAR may be automatically
+ * incremented after each transfer.
+ *
+ * @todo Rename to reflect it being specifically a MEM-AP function.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
+ *	matches the cached value, the register is not changed.
+ * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
+ *	matches the cached address, the register is not changed.
+ *
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
+ */
+int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
+{
+	int retval;
+
+	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
+	if (csw != swjdp->ap_csw_value)
+	{
+		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
+		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
+		if (retval != ERROR_OK)
+			return retval;
+		swjdp->ap_csw_value = csw;
+	}
+	if (tar != swjdp->ap_tar_value)
+	{
+		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
+		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
+		if (retval != ERROR_OK)
+			return retval;
+		swjdp->ap_tar_value = tar;
+	}
+	/* Disable TAR cache when autoincrementing */
+	if (csw & CSW_ADDRINC_MASK)
+		swjdp->ap_tar_value = -1;
+	return ERROR_OK;
+}
+
+/**
+ * Asynchronous (queued) read of a word from memory or a system register.
+ *
+ * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param address Address of the 32-bit word to read; it must be
+ *	readable by the currently selected MEM-AP.
+ * @param value points to where the word will be stored when the
+ *	transaction queue is flushed (assuming no errors).
+ *
+ * @return ERROR_OK for success.  Otherwise a fault code.
+ */
+int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t *value)
+{
+	int retval;
+
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when reading several consecutive addresses.
+	 */
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+			address & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address & 0xC), value);
+}
+
+/**
+ * Synchronous read of a word from memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param address Address of the 32-bit word to read; it must be
+ *	readable by the currently selected MEM-AP.
+ * @param value points to where the result will be stored.
+ *
+ * @return ERROR_OK for success; *value holds the result.
+ * Otherwise a fault code.
+ */
+int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t *value)
+{
+	int retval;
+
+	retval = mem_ap_read_u32(swjdp, address, value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_run(swjdp);
+}
+
+/**
+ * Asynchronous (queued) write of a word to memory or a system register.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param address Address to be written; it must be writable by
+ *	the currently selected MEM-AP.
+ * @param value Word that will be written to the address when transaction
+ *	queue is flushed (assuming no errors).
+ *
+ * @return ERROR_OK for success.  Otherwise a fault code.
+ */
+int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t value)
+{
+	int retval;
+
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when writing several consecutive addresses.
+	 */
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+			address & 0xFFFFFFF0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address & 0xC),
+			value);
+}
+
+/**
+ * Synchronous write of a word to memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param address Address to be written; it must be writable by
+ *	the currently selected MEM-AP.
+ * @param value Word that will be written.
+ *
+ * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
+ */
+int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+		uint32_t value)
+{
+	int retval = mem_ap_write_u32(swjdp, address, value);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_run(swjdp);
+}
+
+/*****************************************************************************
+*                                                                            *
+* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
+*                                                                            *
+* Write a buffer in target order (little endian)                             *
+*                                                                            *
+*****************************************************************************/
+int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+{
+	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
+	uint32_t adr = address;
+	uint8_t* pBuffer = buffer;
+
+	count >>= 2;
+	wcount = count;
+
+	/* if we have an unaligned access - reorder data */
+	if (adr & 0x3u)
+	{
+		for (writecount = 0; writecount < count; writecount++)
+		{
+			int i;
+			uint32_t outvalue;
+			memcpy(&outvalue, pBuffer, sizeof(uint32_t));
+
+			for (i = 0; i < 4; i++)
+			{
+				*((uint8_t*)pBuffer + (adr & 0x3)) = outvalue;
+				outvalue >>= 8;
+				adr++;
+			}
+			pBuffer += sizeof(uint32_t);
+		}
+	}
+
+	while (wcount > 0)
+	{
+		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+
+		for (writecount = 0; writecount < blocksize; writecount++)
+		{
+			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
+				*(uint32_t *) (buffer + 4 * writecount));
+			if (retval != ERROR_OK)
+				break;
+		}
+
+		if (dap_run(swjdp) == ERROR_OK)
+		{
+			wcount = wcount - blocksize;
+			address = address + 4 * blocksize;
+			buffer = buffer + 4 * blocksize;
+		}
+		else
+		{
+			errorcount++;
+		}
+
+		if (errorcount > 1)
+		{
+			LOG_WARNING("Block write error address 0x%" PRIx32 ", wcount 0x%x", address, wcount);
+			/* REVISIT return the *actual* fault code */
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+	}
+
+	return retval;
+}
+
+static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+	int wcount, blocksize, writecount, i;
+
+	wcount = count >> 1;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		writecount = blocksize;
+
+		do
+		{
+			nbytes = MIN((writecount << 1), 4);
+
+			if (nbytes < 4)
+			{
+				if (mem_ap_write_buf_u16(swjdp, buffer,
+						nbytes, address) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+
+				address += nbytes >> 1;
+			}
+			else
+			{
+				uint32_t outvalue;
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+
+				for (i = 0; i < nbytes; i++)
+				{
+					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
+					outvalue >>= 8;
+					address++;
+				}
+
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+				retval = dap_queue_ap_write(swjdp,
+						AP_REG_DRW, outvalue);
+				if (retval != ERROR_OK)
+					break;
+
+				if (dap_run(swjdp) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					/* REVISIT return *actual* fault code */
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+
+			buffer += nbytes >> 1;
+			writecount -= nbytes >> 1;
+
+		} while (writecount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		uint16_t svalue;
+		memcpy(&svalue, buffer, sizeof(uint16_t));
+		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
+		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		if (retval != ERROR_OK)
+			break;
+
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		count -= 2;
+		address += 2;
+		buffer += 2;
+	}
+
+	return retval;
+}
+
+static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+	int wcount, blocksize, writecount, i;
+
+	wcount = count;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		writecount = blocksize;
+
+		do
+		{
+			nbytes = MIN(writecount, 4);
+
+			if (nbytes < 4)
+			{
+				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+
+				address += nbytes;
+			}
+			else
+			{
+				uint32_t outvalue;
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+
+				for (i = 0; i < nbytes; i++)
+				{
+					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
+					outvalue >>= 8;
+					address++;
+				}
+
+				memcpy(&outvalue, buffer, sizeof(uint32_t));
+				retval = dap_queue_ap_write(swjdp,
+						AP_REG_DRW, outvalue);
+				if (retval != ERROR_OK)
+					break;
+
+				if (dap_run(swjdp) != ERROR_OK)
+				{
+					LOG_WARNING("Block write error address "
+						"0x%" PRIx32 ", count 0x%x",
+						address, count);
+					/* REVISIT return *actual* fault code */
+					return ERROR_JTAG_DEVICE_ERROR;
+				}
+			}
+
+			buffer += nbytes;
+			writecount -= nbytes;
+
+		} while (writecount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+{
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
+		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		if (retval != ERROR_OK)
+			break;
+
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		count--;
+		address++;
+		buffer++;
+	}
+
+	return retval;
+}
+
+/* FIXME don't import ... this is a temporary workaround for the
+ * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
+ */
+extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
+		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
+
+/**
+ * Synchronously read a block of 32-bit words into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the words will be stored (in host byte order).
+ * @param count How many words to read.
+ * @param address Memory address from which to read words; all the
+ *	words must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
+{
+	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
+	uint32_t adr = address;
+	uint8_t* pBuffer = buffer;
+
+	count >>= 2;
+	wcount = count;
+
+	while (wcount > 0)
+	{
+		/* Adjust to read blocks within boundaries aligned to the
+		 * TAR autoincrement size (at least 2^10).  Autoincrement
+		 * mode avoids an extra per-word roundtrip to update TAR.
+		 */
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block,
+				address);
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+
+		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
+				address);
+
+		/* FIXME remove these three calls to adi_jtag_dp_scan(),
+		 * so this routine becomes transport-neutral.  Be careful
+		 * not to cause performance problems with JTAG; would it
+		 * suffice to loop over dap_queue_ap_read(), or would that
+		 * be slower when JTAG is the chosen transport?
+		 */
+
+		/* Scan out first read */
+		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+				DPAP_READ, 0, NULL, NULL);
+		for (readcount = 0; readcount < blocksize - 1; readcount++)
+		{
+			/* Scan out next read; scan in posted value for the
+			 * previous one.  Assumes read is acked "OK/FAULT",
+			 * and CTRL_STAT says that meant "OK".
+			 */
+			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+					DPAP_READ, 0, buffer + 4 * readcount,
+					&swjdp->ack);
+		}
+
+		/* Scan in last posted value; RDBUFF has no other effect,
+		 * assuming ack is OK/FAULT and CTRL_STAT says "OK".
+		 */
+		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
+				DPAP_READ, 0, buffer + 4 * readcount,
+				&swjdp->ack);
+		if (dap_run(swjdp) == ERROR_OK)
+		{
+			wcount = wcount - blocksize;
+			address += 4 * blocksize;
+			buffer += 4 * blocksize;
+		}
+		else
+		{
+			errorcount++;
+		}
+
+		if (errorcount > 1)
+		{
+			LOG_WARNING("Block read error address 0x%" PRIx32
+				", count 0x%x", address, count);
+			/* REVISIT return the *actual* fault code */
+			return ERROR_JTAG_DEVICE_ERROR;
+		}
+	}
+
+	/* if we have an unaligned access - reorder data */
+	if (adr & 0x3u)
+	{
+		for (readcount = 0; readcount < count; readcount++)
+		{
+			int i;
+			uint32_t data;
+			memcpy(&data, pBuffer, sizeof(uint32_t));
+
+			for (i = 0; i < 4; i++)
+			{
+				*((uint8_t*)pBuffer) =
+						(data >> 8 * (adr & 0x3));
+				pBuffer++;
+				adr++;
+			}
+		}
+	}
+
+	return retval;
+}
+
+static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	uint32_t invalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, readcount, i;
+
+	wcount = count >> 1;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+
+		/* handle unaligned data at 4k boundary */
+		if (blocksize == 0)
+			blocksize = 1;
+		readcount = blocksize;
+
+		do
+		{
+			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+			if (dap_run(swjdp) != ERROR_OK)
+			{
+				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
+				/* REVISIT return the *actual* fault code */
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			nbytes = MIN((readcount << 1), 4);
+
+			for (i = 0; i < nbytes; i++)
+			{
+				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+				buffer++;
+				address++;
+			}
+
+			readcount -= (nbytes >> 1);
+		} while (readcount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+/**
+ * Synchronously read a block of 16-bit halfwords into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the halfwords will be stored (in host byte order).
+ * @param count How many halfwords to read.
+ * @param address Memory address from which to read words; all the
+ *	words must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
+{
+	uint32_t invalue, i;
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+		if (retval != ERROR_OK)
+			break;
+
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		if (address & 0x1)
+		{
+			for (i = 0; i < 2; i++)
+			{
+				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+				buffer++;
+				address++;
+			}
+		}
+		else
+		{
+			uint16_t svalue = (invalue >> 8 * (address & 0x3));
+			memcpy(buffer, &svalue, sizeof(uint16_t));
+			address += 2;
+			buffer += 2;
+		}
+		count -= 2;
+	}
+
+	return retval;
+}
+
+/* FIX!!! is this a potential performance bottleneck w.r.t. requiring too many
+ * roundtrips when jtag_execute_queue() has a large overhead(e.g. for USB)s?
+ *
+ * The solution is to arrange for a large out/in scan in this loop and
+ * and convert data afterwards.
+ */
+static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
+		uint8_t *buffer, int count, uint32_t address)
+{
+	uint32_t invalue;
+	int retval = ERROR_OK;
+	int wcount, blocksize, readcount, i;
+
+	wcount = count;
+
+	while (wcount > 0)
+	{
+		int nbytes;
+
+		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+
+		if (wcount < blocksize)
+			blocksize = wcount;
+
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		readcount = blocksize;
+
+		do
+		{
+			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+			if (dap_run(swjdp) != ERROR_OK)
+			{
+				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
+				/* REVISIT return the *actual* fault code */
+				return ERROR_JTAG_DEVICE_ERROR;
+			}
+
+			nbytes = MIN(readcount, 4);
+
+			for (i = 0; i < nbytes; i++)
+			{
+				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+				buffer++;
+				address++;
+			}
+
+			readcount -= nbytes;
+		} while (readcount);
+		wcount -= blocksize;
+	}
+
+	return retval;
+}
+
+/**
+ * Synchronously read a block of bytes into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the bytes will be stored.
+ * @param count How many bytes to read.
+ * @param address Memory address from which to read data; all the
+ *	data must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
+{
+	uint32_t invalue;
+	int retval = ERROR_OK;
+
+	if (count >= 4)
+		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
+
+	while (count > 0)
+	{
+		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			break;
+
+		*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
+		count--;
+		address++;
+		buffer++;
+	}
+
+	return retval;
+}
+
+/*--------------------------------------------------------------------------*/
+
+<<<<<<< HEAD:src/target/arm_adi_v5.c
+=======
+static int jtag_idcode_q_read(struct adiv5_dap *dap,
+		uint8_t *ack, uint32_t *data)
+{
+	struct arm_jtag *jtag_info = dap->jtag_info;
+	int retval;
+	struct scan_field fields[1];
+
+	jtag_set_end_state(TAP_IDLE);
+
+	/* This is a standard JTAG operation -- no DAP tweakage */
+	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	fields[0].num_bits = 32;
+	fields[0].out_value = NULL;
+	fields[0].in_value = (void *) data;
+
+	jtag_add_dr_scan(jtag_info->tap, 1, fields, TAP_IDLE);
+	retval = jtag_get_error();
+	if (retval != ERROR_OK)
+		return retval;
+
+	jtag_add_callback(arm_le_to_h_u32,
+			(jtag_callback_data_t) data);
+
+	return retval;
+}
+
+static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_READ, 0, data);
+}
+
+static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
+			reg, DPAP_WRITE, data, NULL);
+}
+
+/** Select the AP register bank matching bits 7:4 of reg. */
+static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
+{
+	uint32_t select = reg & 0x000000F0;
+
+	if (select == dap->ap_bank_value)
+		return ERROR_OK;
+	dap->ap_bank_value = select;
+
+	select |= dap->apsel;
+
+	return jtag_dp_q_write(dap, DP_SELECT, select);
+}
+
+static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
+		uint32_t *data)
+{
+	int retval = jtag_ap_q_bankselect(dap, reg);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
+			DPAP_READ, 0, data);
+}
+
+static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
+		uint32_t data)
+{
+	uint8_t out_value_buf[4];
+
+	int retval = jtag_ap_q_bankselect(dap, reg);
+	if (retval != ERROR_OK)
+		return retval;
+>>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
+
+/* FIXME don't import ... just initialize as
+ * part of DAP transport setup
+*/
+extern const struct dap_ops jtag_dp_ops;
+
+/*--------------------------------------------------------------------------*/
+
+/**
+ * Initialize a DAP.  This sets up the power domains, prepares the DP
+ * for further use, and arranges to use AP #0 for all AP operations
+ * until dap_ap-select() changes that policy.
+ *
+ * @param swjdp The DAP being initialized.
+ *
+ * @todo Rename this.  We also need an initialization scheme which account
+ * for SWD transports not just JTAG; that will need to address differences
+ * in layering.  (JTAG is useful without any debug target; but not SWD.)
+ * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
+ */
+int ahbap_debugport_init(struct adiv5_dap *swjdp)
+{
+	uint32_t idreg, romaddr, dummy;
+	uint32_t ctrlstat;
+	int cnt = 0;
+	int retval;
+
+	LOG_DEBUG(" ");
+
+	/* JTAG-DP or SWJ-DP, in JTAG mode */
+	swjdp->ops = &jtag_dp_ops;
+
+	/* Default MEM-AP setup.
+	 *
+	 * REVISIT AP #0 may be an inappropriate default for this.
+	 * Should we probe, or take a hint from the caller?
+	 * Presumably we can ignore the possibility of multiple APs.
+	 */
+	swjdp->apsel = !0;
+	dap_ap_select(swjdp, 0);
+
+	/* DP initialization */
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+	if (retval != ERROR_OK)
+		return retval;
+	if ((retval = dap_run(swjdp)) != ERROR_OK)
+		return retval;
+
+	/* Check that we have debug power domains activated */
+	while (!(ctrlstat & CDBGPWRUPACK) && (cnt++ < 10))
+	{
+		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
+		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
+			return retval;
+		alive_sleep(10);
+	}
+
+	while (!(ctrlstat & CSYSPWRUPACK) && (cnt++ < 10))
+	{
+		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
+		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((retval = dap_run(swjdp)) != ERROR_OK)
+			return retval;
+		alive_sleep(10);
+	}
+
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+	/* With debug power on we can activate OVERRUN checking */
+	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
+	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * REVISIT this isn't actually *initializing* anything in an AP,
+	 * and doesn't care if it's a MEM-AP at all (much less AHB-AP).
+	 * Should it?  If the ROM address is valid, is this the right
+	 * place to scan the table and do any topology detection?
+	 */
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &idreg);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &romaddr);
+
+	LOG_DEBUG("MEM-AP #%d ID Register 0x%" PRIx32
+		", Debug ROM Address 0x%" PRIx32,
+		swjdp->apsel, idreg, romaddr);
+
+	return ERROR_OK;
+}
+
+/* CID interpretation -- see ARM IHI 0029B section 3
+ * and ARM IHI 0031A table 13-3.
+ */
+static const char *class_description[16] ={
+	"Reserved", "ROM table", "Reserved", "Reserved",
+	"Reserved", "Reserved", "Reserved", "Reserved",
+	"Reserved", "CoreSight component", "Reserved", "Peripheral Test Block",
+	"Reserved", "OptimoDE DESS",
+		"Generic IP component", "PrimeCell or System component"
+};
+
+static bool
+is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
+{
+	return cid3 == 0xb1 && cid2 == 0x05
+			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
+}
+
+static int dap_info_command(struct command_context *cmd_ctx,
+		struct adiv5_dap *swjdp, int apsel)
+{
+	int retval;
+	uint32_t dbgbase, apid;
+	int romtable_present = 0;
+	uint8_t mem_ap;
+	uint32_t apselold;
+
+	/* AP address is in bits 31:24 of DP_SELECT */
+	if (apsel >= 256)
+		return ERROR_INVALID_ARGUMENTS;
+
+	apselold = swjdp->apsel;
+	dap_ap_select(swjdp, apsel);
+	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &dbgbase);
+	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
+	retval = dap_run(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
+	mem_ap = ((apid&0x10000) && ((apid&0x0F) != 0));
+	command_print(cmd_ctx, "AP ID register 0x%8.8" PRIx32, apid);
+	if (apid)
+	{
+		switch (apid&0x0F)
+		{
+			case 0:
+				command_print(cmd_ctx, "\tType is JTAG-AP");
+				break;
+			case 1:
+				command_print(cmd_ctx, "\tType is MEM-AP AHB");
+				break;
+			case 2:
+				command_print(cmd_ctx, "\tType is MEM-AP APB");
+				break;
+			default:
+				command_print(cmd_ctx, "\tUnknown AP type");
+				break;
+		}
+
+		/* NOTE: a MEM-AP may have a single CoreSight component that's
+		 * not a ROM table ... or have no such components at all.
+		 */
+		if (mem_ap)
+			command_print(cmd_ctx, "AP BASE 0x%8.8" PRIx32,
+					dbgbase);
+	}
+	else
+	{
+		command_print(cmd_ctx, "No AP found at this apsel 0x%x", apsel);
+	}
+
+	romtable_present = ((mem_ap) && (dbgbase != 0xFFFFFFFF));
+	if (romtable_present)
+	{
+		uint32_t cid0,cid1,cid2,cid3,memtype,romentry;
+		uint16_t entry_offset;
+
+		/* bit 16 of apid indicates a memory access port */
+		if (dbgbase & 0x02)
+			command_print(cmd_ctx, "\tValid ROM table present");
+		else
+			command_print(cmd_ctx, "\tROM table in legacy format");
+
+		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
+		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
+		retval = dap_run(swjdp);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
+			command_print(cmd_ctx, "\tCID3 0x%2.2" PRIx32
+					", CID2 0x%2.2" PRIx32
+					", CID1 0x%2.2" PRIx32
+					", CID0 0x%2.2" PRIx32,
+					cid3, cid2, cid1, cid0);
+		if (memtype & 0x01)
+			command_print(cmd_ctx, "\tMEMTYPE system memory present on bus");
+		else
+			command_print(cmd_ctx, "\tMEMTYPE System memory not present. "
+					"Dedicated debug bus.");
+
+		/* Now we read ROM table entries from dbgbase&0xFFFFF000) | 0x000 until we get 0x00000000 */
+		entry_offset = 0;
+		do
+		{
+			mem_ap_read_atomic_u32(swjdp, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
+			command_print(cmd_ctx, "\tROMTABLE[0x%x] = 0x%" PRIx32 "",entry_offset,romentry);
+			if (romentry&0x01)
+			{
+				uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
+				uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
+				uint32_t component_start, component_base;
+				unsigned part_num;
+				char *type, *full;
+
+				component_base = (uint32_t)((dbgbase & 0xFFFFF000)
+						+ (int)(romentry & 0xFFFFF000));
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFE0, &c_pid0);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFE4, &c_pid1);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFE8, &c_pid2);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFEC, &c_pid3);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFD0, &c_pid4);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFF0, &c_cid0);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFF4, &c_cid1);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFF8, &c_cid2);
+				mem_ap_read_atomic_u32(swjdp,
+						(component_base & 0xFFFFF000) | 0xFFC, &c_cid3);
+				component_start = component_base - 0x1000*(c_pid4 >> 4);
+
+				command_print(cmd_ctx, "\t\tComponent base address 0x%" PRIx32
+						", start address 0x%" PRIx32,
+						component_base, component_start);
+				command_print(cmd_ctx, "\t\tComponent class is 0x%x, %s",
+						(int) (c_cid1 >> 4) & 0xf,
+						/* See ARM IHI 0029B Table 3-3 */
+						class_description[(c_cid1 >> 4) & 0xf]);
+
+				/* CoreSight component? */
+				if (((c_cid1 >> 4) & 0x0f) == 9) {
+					uint32_t devtype;
+					unsigned minor;
+					char *major = "Reserved", *subtype = "Reserved";
+
+					mem_ap_read_atomic_u32(swjdp,
+							(component_base & 0xfffff000) | 0xfcc,
+							&devtype);
+					minor = (devtype >> 4) & 0x0f;
+					switch (devtype & 0x0f) {
+					case 0:
+						major = "Miscellaneous";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 4:
+							subtype = "Validation component";
+							break;
+						}
+						break;
+					case 1:
+						major = "Trace Sink";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Port";
+							break;
+						case 2:
+							subtype = "Buffer";
+							break;
+						}
+						break;
+					case 2:
+						major = "Trace Link";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Funnel, router";
+							break;
+						case 2:
+							subtype = "Filter";
+							break;
+						case 3:
+							subtype = "FIFO, buffer";
+							break;
+						}
+						break;
+					case 3:
+						major = "Trace Source";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Processor";
+							break;
+						case 2:
+							subtype = "DSP";
+							break;
+						case 3:
+							subtype = "Engine/Coprocessor";
+							break;
+						case 4:
+							subtype = "Bus";
+							break;
+						}
+						break;
+					case 4:
+						major = "Debug Control";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Trigger Matrix";
+							break;
+						case 2:
+							subtype = "Debug Auth";
+							break;
+						}
+						break;
+					case 5:
+						major = "Debug Logic";
+						switch (minor) {
+						case 0:
+							subtype = "other";
+							break;
+						case 1:
+							subtype = "Processor";
+							break;
+						case 2:
+							subtype = "DSP";
+							break;
+						case 3:
+							subtype = "Engine/Coprocessor";
+							break;
+						}
+						break;
+					}
+					command_print(cmd_ctx, "\t\tType is 0x%2.2x, %s, %s",
+							(unsigned) (devtype & 0xff),
+							major, subtype);
+					/* REVISIT also show 0xfc8 DevId */
+				}
+
+				if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
+					command_print(cmd_ctx, "\t\tCID3 0x%2.2" PRIx32
+							", CID2 0x%2.2" PRIx32
+							", CID1 0x%2.2" PRIx32
+							", CID0 0x%2.2" PRIx32,
+							c_cid3, c_cid2, c_cid1, c_cid0);
+				command_print(cmd_ctx, "\t\tPeripheral ID[4..0] = hex "
+						"%2.2x %2.2x %2.2x %2.2x %2.2x",
+						(int) c_pid4,
+						(int) c_pid3, (int) c_pid2,
+						(int) c_pid1, (int) c_pid0);
+
+				/* Part number interpretations are from Cortex
+				 * core specs, the CoreSight components TRM
+				 * (ARM DDI 0314H), and ETM specs; also from
+				 * chip observation (e.g. TI SDTI).
+				 */
+				part_num = c_pid0 & 0xff;
+				part_num |= (c_pid1 & 0x0f) << 8;
+				switch (part_num) {
+				case 0x000:
+					type = "Cortex-M3 NVIC";
+					full = "(Interrupt Controller)";
+					break;
+				case 0x001:
+					type = "Cortex-M3 ITM";
+					full = "(Instrumentation Trace Module)";
+					break;
+				case 0x002:
+					type = "Cortex-M3 DWT";
+					full = "(Data Watchpoint and Trace)";
+					break;
+				case 0x003:
+					type = "Cortex-M3 FBP";
+					full = "(Flash Patch and Breakpoint)";
+					break;
+				case 0x00d:
+					type = "CoreSight ETM11";
+					full = "(Embedded Trace)";
+					break;
+				// case 0x113: what?
+				case 0x120:		/* from OMAP3 memmap */
+					type = "TI SDTI";
+					full = "(System Debug Trace Interface)";
+					break;
+				case 0x343:		/* from OMAP3 memmap */
+					type = "TI DAPCTL";
+					full = "";
+					break;
+				case 0x906:
+					type = "Coresight CTI";
+					full = "(Cross Trigger)";
+					break;
+				case 0x907:
+					type = "Coresight ETB";
+					full = "(Trace Buffer)";
+					break;
+				case 0x908:
+					type = "Coresight CSTF";
+					full = "(Trace Funnel)";
+					break;
+				case 0x910:
+					type = "CoreSight ETM9";
+					full = "(Embedded Trace)";
+					break;
+				case 0x912:
+					type = "Coresight TPIU";
+					full = "(Trace Port Interface Unit)";
+					break;
+				case 0x921:
+					type = "Cortex-A8 ETM";
+					full = "(Embedded Trace)";
+					break;
+				case 0x922:
+					type = "Cortex-A8 CTI";
+					full = "(Cross Trigger)";
+					break;
+				case 0x923:
+					type = "Cortex-M3 TPIU";
+					full = "(Trace Port Interface Unit)";
+					break;
+				case 0x924:
+					type = "Cortex-M3 ETM";
+					full = "(Embedded Trace)";
+					break;
+				case 0xc08:
+					type = "Cortex-A8 Debug";
+					full = "(Debug Unit)";
+					break;
+				default:
+					type = "-*- unrecognized -*-";
+					full = "";
+					break;
+				}
+				command_print(cmd_ctx, "\t\tPart is %s %s",
+						type, full);
+			}
+			else
+			{
+				if (romentry)
+					command_print(cmd_ctx, "\t\tComponent not present");
+				else
+					command_print(cmd_ctx, "\t\tEnd of ROM table");
+			}
+			entry_offset += 4;
+		} while (romentry > 0);
+	}
+	else
+	{
+		command_print(cmd_ctx, "\tNo ROM table present");
+	}
+	dap_ap_select(swjdp, apselold);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_dap_info_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+	uint32_t apsel;
+
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = dap->apsel;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	return dap_info_command(CMD_CTX, dap, apsel);
+}
+
+COMMAND_HANDLER(dap_baseaddr_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t apsel, apselsave, baseaddr;
+	int retval;
+
+	apselsave = dap->apsel;
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = dap->apsel;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		/* AP address is in bits 31:24 of DP_SELECT */
+		if (apsel >= 256)
+			return ERROR_INVALID_ARGUMENTS;
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (apselsave != apsel)
+		dap_ap_select(dap, apsel);
+
+	/* NOTE:  assumes we're talking to a MEM-AP, which
+	 * has a base address.  There are other kinds of AP,
+	 * though they're not common for now.  This should
+	 * use the ID register to verify it's a MEM-AP.
+	 */
+	retval = dap_queue_ap_read(dap, AP_REG_BASE, &baseaddr);
+	retval = dap_run(dap);
+	if (retval != ERROR_OK)
+		return retval;
+
+	command_print(CMD_CTX, "0x%8.8" PRIx32, baseaddr);
+
+	if (apselsave != apsel)
+		dap_ap_select(dap, apselsave);
+
+	return retval;
+}
+
+COMMAND_HANDLER(dap_memaccess_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t memaccess_tck;
+
+	switch (CMD_ARGC) {
+	case 0:
+		memaccess_tck = dap->memaccess_tck;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	dap->memaccess_tck = memaccess_tck;
+
+	command_print(CMD_CTX, "memory bus access delay set to %" PRIi32 " tck",
+			dap->memaccess_tck);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(dap_apsel_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t apsel, apid;
+	int retval;
+
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = 0;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		/* AP address is in bits 31:24 of DP_SELECT */
+		if (apsel >= 256)
+			return ERROR_INVALID_ARGUMENTS;
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	dap_ap_select(dap, apsel);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	retval = dap_run(dap);
+	if (retval != ERROR_OK)
+		return retval;
+
+	command_print(CMD_CTX, "ap %" PRIi32 " selected, identification register 0x%8.8" PRIx32,
+			apsel, apid);
+
+	return retval;
+}
+
+COMMAND_HANDLER(dap_apid_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+
+	uint32_t apsel, apselsave, apid;
+	int retval;
+
+	apselsave = dap->apsel;
+	switch (CMD_ARGC) {
+	case 0:
+		apsel = dap->apsel;
+		break;
+	case 1:
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		/* AP address is in bits 31:24 of DP_SELECT */
+		if (apsel >= 256)
+			return ERROR_INVALID_ARGUMENTS;
+		break;
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (apselsave != apsel)
+		dap_ap_select(dap, apsel);
+
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	retval = dap_run(dap);
+	if (retval != ERROR_OK)
+		return retval;
+
+	command_print(CMD_CTX, "0x%8.8" PRIx32, apid);
+	if (apselsave != apsel)
+		dap_ap_select(dap, apselsave);
+
+	return retval;
+}
+
+static const struct command_registration dap_commands[] = {
+	{
+		.name = "info",
+		.handler = handle_dap_info_command,
+		.mode = COMMAND_EXEC,
+		.help = "display ROM table for MEM-AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "apsel",
+		.handler = dap_apsel_command,
+		.mode = COMMAND_EXEC,
+		.help = "Set the currently selected AP (default 0) "
+			"and display the result",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "apid",
+		.handler = dap_apid_command,
+		.mode = COMMAND_EXEC,
+		.help = "return ID register from AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "baseaddr",
+		.handler = dap_baseaddr_command,
+		.mode = COMMAND_EXEC,
+		.help = "return debug base address from MEM-AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
+		.name = "memaccess",
+		.handler = dap_memaccess_command,
+		.mode = COMMAND_EXEC,
+		.help = "set/get number of extra tck for MEM-AP memory "
+			"bus access [0-255]",
+		.usage = "[cycles]",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration dap_command_handlers[] = {
+	{
+		.name = "dap",
+		.mode = COMMAND_EXEC,
+		.help = "DAP command group",
+		.chain = dap_commands,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+
+/*
+ * This represents the bits which must be sent out on TMS/SWDIO to
+ * switch a DAP implemented using an SWJ-DP module into SWD mode.
+ * These bits are stored (and transmitted) LSB-first.
+ *
+ * See the DAP-Lite specification, section 2.2.5 for information
+ * about making the debug link select SWD or JTAG.  (Similar info
+ * is in a few other ARM documents.)
+ */
+static const uint8_t jtag2swd_bitseq[] = {
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* Switching sequence enables SWD and disables JTAG
+	 * NOTE: bits in the DP's IDCODE may expose the need for
+	 * an old/deprecated sequence (0xb6 0xed).
+	 */
+	0x9e, 0xe7,
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+
+/**
+ * Put the debug link into SWD mode, if the target supports it.
+ * The link's initial mode may be either JTAG (for example,
+ * with SWJ-DP after reset) or SWD.
+ *
+ * @param target Enters SWD mode (if possible).
+ *
+ * Note that targets using the JTAG-DP do not support SWD, and that
+ * some targets which could otherwise support it may have have been
+ * configured to disable SWD signaling
+ *
+ * @return ERROR_OK or else a fault code.
+ */
+int dap_to_swd(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG("Enter SWD mode");
+
+	/* REVISIT it's nasty to need to make calls to a "jtag"
+	 * subsystem if the link isn't in JTAG mode...
+	 */
+
+	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
+			jtag2swd_bitseq, TAP_INVALID);
+	if (retval == ERROR_OK)
+		retval = jtag_execute_queue();
+
+	/* REVISIT set up the DAP's ops vector for SWD mode. */
+
+	return retval;
+}
+
diff --git a/src/target/avrt.c b/src/target/avrt.c
index 720261e..17f7c24 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -190,8 +190,7 @@ int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_l
 	}
 
 	{
-		jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in,
-				jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in, TAP_IDLE);
 	}
 
 	return ERROR_OK;
@@ -206,7 +205,7 @@ int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_l
 	}
 
 	{
-		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, TAP_IDLE);
 	}
 
 	return ERROR_OK;
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 4be7f3b..b42e7b3 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -863,8 +863,7 @@ int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
 	}
 
 	{
-		jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in,
-				       jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in, TAP_IDLE);
 	}
 
 	return ERROR_OK;
@@ -880,8 +879,7 @@ int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
 	}
 
 	{
-		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in,
-				       jtag_set_end_state(TAP_IDLE));
+		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, TAP_IDLE);
 	}
 
 	return ERROR_OK;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 4693fcc..fe266d6 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -372,7 +372,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[2].check_mask = NULL;
 
 	/* traverse Update-DR, setting address for the next read */
-	jtag_add_dr_scan(ice_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(ice_reg->jtag_info->tap, 3, fields, TAP_IDLE);
 
 	/* bits 31:0 -- the data we're reading (and maybe checking) */
 	fields[0].in_value = reg->value;
@@ -386,7 +386,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 	/* traverse Update-DR, reading but with no other side effects */
-	jtag_add_dr_scan_check(ice_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(ice_reg->jtag_info->tap, 3, fields, TAP_IDLE);
 
 	return ERROR_OK;
 }
@@ -423,7 +423,7 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	fields[2].out_value[0] = 0;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
 	while (size > 0)
 	{
@@ -434,7 +434,7 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 			fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 		fields[0].in_value = (uint8_t *)data;
-		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)data);
 
 		data++;
@@ -545,7 +545,7 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	while (size > 0)
 	{
 		buf_set_u32(fields[0].out_value, 0, 32, *data);
-		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
 		data++;
 		size--;
@@ -594,10 +594,10 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 	fields[2].out_value[0] = 0;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 	gettimeofday(&lap, NULL);
 	do {
-		jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 
diff --git a/src/target/etb.c b/src/target/etb.c
index 2c4e3eb..9971070 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -191,7 +191,7 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 	buf_set_u32(fields[2].out_value, 0, 1, 0);
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(etb->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etb->tap, 3, fields, TAP_IDLE);
 
 	for (i = 0; i < num_frames; i++)
 	{
@@ -205,7 +205,7 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 			buf_set_u32(fields[1].out_value, 0, 7, 0);
 
 		fields[0].in_value = (uint8_t *)(data + i);
-		jtag_add_dr_scan(etb->tap, 3, fields, jtag_get_end_state());
+		jtag_add_dr_scan(etb->tap, 3, fields, TAP_IDLE);
 
 		jtag_add_callback(etb_getbuf, (jtag_callback_d
ata_t)(data + i));
 	}
@@ -251,7 +251,7 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
 
-	jtag_add_dr_scan(etb_reg->etb->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etb_reg->etb->tap, 3, fields, TAP_IDLE);
 
 	/* read the identification register in the second run, to make sure we
 	 * don't read the ETB data register twice, skipping every second entry
@@ -261,7 +261,7 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[0].check_value = check_value;
 	fields[0].check_mask = check_mask;
 
-	jtag_add_dr_scan_check(etb_reg->etb->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(etb_reg->etb->tap, 3, fields, TAP_IDLE);
 
 	free(fields[1].out_value);
 	free(fields[2].out_value);
diff --git a/src/target/etm.c b/src/target/etm.c
index 67dac06..a1c77b0 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -528,13 +528,13 @@ static int etm_read_reg_w_check(struct reg *reg,
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
 
-	jtag_add_dr_scan(etm_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etm_reg->jtag_info->tap, 3, fields, TAP_IDLE);
 
 	fields[0].in_value = reg->value;
 	fields[0].check_value = check_value;
 	fields[0].check_mask = check_mask;
 
-	jtag_add_dr_scan_check(etm_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan_check(etm_reg->jtag_info->tap, 3, fields, TAP_IDLE);
 
 	free(fields[1].out_value);
 	free(fields[2].out_value);
@@ -609,7 +609,7 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	buf_set_u32(fields[2].out_value, 0, 1, 1);
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(etm_reg->jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(etm_reg->jtag_info->tap, 3, fields, TAP_IDLE);
 
 	return ERROR_OK;
 }
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 133ad4f..22ddb55 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -101,9 +101,9 @@ int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 	fields[2].out_value = instr_buf;
 	fields[2].in_value = NULL;
 
-	jtag_add_dr_scan(jtag_info->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 
-	/* no jtag_add_runtest(0, jtag_get_end_state()) here */
+	/* no jtag_add_runtest(0, TAP_DRPAUSE) here */
 
 	return ERROR_OK;
 }
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 42dc6e0..974c836 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -64,7 +64,7 @@ int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 	field.out_value = NULL;
 	field.in_value = (void*)idcode;
 
-	jtag_add_dr_scan(ejtag_info->tap, 1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
 
 	if (jtag_execute_queue() != ERROR_OK)
 	{
@@ -86,7 +86,7 @@ int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
 	field.out_value = NULL;
 	field.in_value = (void*)impcode;
 
-	jtag_add_dr_scan(ejtag_info->tap, 1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(ejtag_info->tap, 1, &field, TAP_IDLE);
 
 	if (jtag_execute_queue() != ERROR_OK)
 	{
diff --git a/src/target/xscale.c b/src/target/xscale.c
index dd4a7ee..f5aada5 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -213,7 +213,7 @@ static int xscale_read_dcsr(struct target *target)
 	uint8_t tmp2;
 	fields[2].in_value = &tmp2;
 
-	jtag_add_dr_scan(target->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 3, fields, TAP_DRPAUSE);
 
 	jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 	jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -236,7 +236,7 @@ static int xscale_read_dcsr(struct target *target)
 
 	jtag_set_end_state(TAP_IDLE);
 
-	jtag_add_dr_scan(target->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 3, fields, TAP_DRPAUSE);
 
 	/* DANGER!!! this must be here. It will make sure that the arguments
 	 * to jtag_set_check_value() does not go out of scope! */
@@ -288,7 +288,7 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_DBGTX << xscale->xscale_variant);
-	jtag_add_runtest(1, jtag_get_end_state()); /* ensures that we're in the TAP_IDLE state as the above could be a no-op */
+	jtag_add_runtest(1, TAP_IDLE); /* ensures that we're in the TAP_IDLE state as the above could be a no-op */
 
 	/* repeat until all words have been collected */
 	int attempts = 0;
@@ -304,7 +304,7 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 
 			fields[1].in_value = (uint8_t *)(field1 + i);
 
-			jtag_add_dr_scan_check(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan_check(target->tap, 3, fields, TAP_IDLE);
 
 			jtag_add_callback(xscale_getbuf, (jtag_callback_data_t)(field1 + i));
 
@@ -411,7 +411,7 @@ static int xscale_read_tx(struct target *target, int consume)
 			jtag_add_pathmove(ARRAY_SIZE(noconsume_path), noconsume_path);
 		}
 
-		jtag_add_dr_scan(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(target->tap, 3, fields, TAP_IDLE);
 
 		jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 		jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -489,7 +489,7 @@ static int xscale_write_rx(struct target *target)
 	LOG_DEBUG("polling RX");
 	for (;;)
 	{
-		jtag_add_dr_scan(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
+		jtag_add_dr_scan(target->tap, 3, fields, TAP_IDLE);
 
 		jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 		jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -521,7 +521,7 @@ static int xscale_write_rx(struct target *target)
 
 	/* set rx_valid */
 	field2 = 0x1;
-	jtag_add_dr_scan(target->tap, 3, fields, jtag_set_end_state(TAP_IDLE));
+	jtag_add_dr_scan(target->tap, 3, fields, TAP_IDLE);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -585,7 +585,7 @@ static int xscale_send(struct target *target, uint8_t *buffer, int count, int si
 				3,
 				bits,
 				t,
-				jtag_set_end_state(TAP_IDLE));
+				TAP_IDLE);
 		buffer += size;
 	}
 
@@ -646,7 +646,7 @@ static int xscale_write_dcsr(struct target *target, int hold_rst, int ext_dbg_br
 	uint8_t tmp2;
 	fields[2].in_value = &tmp2;
 
-	jtag_add_dr_scan(target->tap, 3, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 3, fields, TAP_IDLE);
 
 	jtag_check_value_mask(fields + 0, &field0_check_value, &field0_check_mask);
 	jtag_check_value_mask(fields + 2, &field2_check_value, &field2_check_mask);
@@ -707,7 +707,7 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 	fields[1].num_bits = 27;
 	fields[1].out_value = packet;
 
-	jtag_add_dr_scan(target->tap, 2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 2, fields, TAP_IDLE);
 
 	/* rest of packet is a cacheline: 8 instructions, with parity */
 	fields[0].num_bits = 32;
@@ -724,7 +724,7 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 		memcpy(&value, packet, sizeof(uint32_t));
 		cmd = parity(value);
 
-		jtag_add_dr_scan(target->tap, 2, fields, jtag_get_end_state());
+		jtag_add_dr_scan(target->tap, 2, fields, TAP_IDLE);
 	}
 
 	return jtag_execute_queue();
@@ -755,7 +755,7 @@ static int xscale_invalidate_ic_line(struct target *target, uint32_t va)
 	fields[1].num_bits = 27;
 	fields[1].out_value = packet;
 
-	jtag_add_dr_scan(target->tap, 2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(target->tap, 2, fields, TAP_IDLE);
 
 	return ERROR_OK;
 }
@@ -1556,7 +1556,7 @@ static int xscale_deassert_reset(struct target *target)
 		/* wait 300ms; 150 and 100ms were not enough */
 		jtag_add_sleep(300*1000);
 
-		jtag_add_runtest(2030, jtag_set_end_state(TAP_IDLE));
+		jtag_add_runtest(2030, TAP_IDLE);
 		jtag_execute_queue();
 
 		/* set Hold reset, Halt mode and Trap Reset */
@@ -1613,7 +1613,7 @@ static int xscale_deassert_reset(struct target *target)
 		if (retval != ERROR_OK)
 			return retval;
 
-		jtag_add_runtest(30, jtag_set_end_state(TAP_IDLE));
+		jtag_add_runtest(30, TAP_IDLE);
 
 		jtag_add_sleep(100000);
 
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index f2c1a42..dff1a1e 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -482,9 +482,9 @@ COMMAND_HANDLER(handle_xsvf_command)
 
 					if (tap == NULL)
 						jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value,
-								jtag_set_end_state(TAP_DRPAUSE));
+								TAP_DRPAUSE);
 					else
-						jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_dr_scan(tap, 1, &field, TAP_DRPAUSE);
 
 					jtag_check_value_mask(&field, dr_in_buf, dr_in_mask);
 
@@ -939,9 +939,9 @@ COMMAND_HANDLER(handle_xsvf_command)
 
 					if (tap == NULL)
 						jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value,
-								jtag_set_end_state(TAP_DRPAUSE));
+								TAP_DRPAUSE);
 					else
-						jtag_add_dr_scan(tap, 1, &field, jtag_set_end_state(TAP_DRPAUSE));
+						jtag_add_dr_scan(tap, 1, &field, TAP_DRPAUSE);
 
 					jtag_check_value_mask(&field, dr_in_buf, dr_in_mask);
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9xpec.c                       |   26 +-
 src/jtag/core.c                                |    5 +-
 src/jtag/jtag.h                                |    7 +-
 src/pld/virtex2.c                              |   12 +-
 src/target/adi_v5_jtag.c                       |    6 +-
 src/target/arm11_dbgtap.c                      |    2 +-
 src/target/arm720t.c                           |    6 +-
 src/target/arm7_9_common.c                     |    2 +-
 src/target/arm7tdmi.c                          |   12 +-
 src/target/arm920t.c                           |    8 +-
 src/target/arm926ejs.c                         |    8 +-
 src/target/arm966e.c                           |    6 +-
 src/target/arm9tdmi.c                          |   16 +-
 src/target/{arm_adi_v5.c => arm_adi_v5.c.orig} |  382 ++++++++++++++++++++++++
 src/target/{arm_adi_v5.c => arm_adi_v5.c~}     |  382 ++++++++++++++++++++++++
 src/target/avrt.c                              |    5 +-
 src/target/dsp563xx.c                          |    6 +-
 src/target/embeddedice.c                       |   14 +-
 src/target/etb.c                               |    8 +-
 src/target/etm.c                               |    6 +-
 src/target/feroceon.c                          |    4 +-
 src/target/mips_ejtag.c                        |    4 +-
 src/target/xscale.c                            |   28 +-
 src/xsvf/xsvf.c                                |    8 +-
 24 files changed, 864 insertions(+), 99 deletions(-)
 copy src/target/{arm_adi_v5.c => arm_adi_v5.c.orig} (79%)
 copy src/target/{arm_adi_v5.c => arm_adi_v5.c~} (79%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 18 12:08:55 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 18 Mar 2010 11:08:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-108-g46f9287
Message-ID: <E1NsDay-0002U7-Ga@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  46f92878da6c65eac275d1783e4e4019ec3c9af9 (commit)
      from  d37ed9094a62ec144b9d9fdc214d8c7723caadec (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 46f92878da6c65eac275d1783e4e4019ec3c9af9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 18 12:06:07 2010 +0100

    oops: committed and pushed two temp files....
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c.orig b/src/target/arm_adi_v5.c.orig
deleted file mode 100644
index 708e858..0000000
--- a/src/target/arm_adi_v5.c.orig
+++ /dev/null
@@ -1,1981 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   lundin at mlu.mine.nu                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Oyvind Harboe                                   *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2009-2010 by David Brownell                             *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/**
- * @file
- * This file implements support for the ARM Debug Interface version 5 (ADIv5)
- * debugging architecture.  Compared with previous versions, this includes
- * a low pin-count Serial Wire Debug (SWD) alternative to JTAG for message
- * transport, and focusses on memory mapped resources as defined by the
- * CoreSight architecture.
- *
- * A key concept in ADIv5 is the Debug Access Port, or DAP.  A DAP has two
- * basic components:  a Debug Port (DP) transporting messages to and from a
- * debugger, and an Access Port (AP) accessing resources.  Three types of DP
- * are defined.  One uses only JTAG for communication, and is called JTAG-DP.
- * One uses only SWD for communication, and is called SW-DP.  The third can
- * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
- * is used to access memory mapped resources and is called a MEM-AP.  Also a
- * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
- *
- * This programming interface allows DAP pipelined operations through a
- * transaction queue.  This primarily affects AP operations (such as using
- * a MEM-AP to access memory or registers).  If the current transaction has
- * not finished by the time the next one must begin, and the ORUNDETECT bit
- * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
- * further AP operations will fail.  There are two basic methods to avoid
- * such overrun errors.  One involves polling for status instead of using
- * transaction piplining.  The other involves adding delays to ensure the
- * AP has enough time to complete one operation before starting the next
- * one.  (For JTAG these delays are controlled by memaccess_tck.)
- */
-
-/*
- * Relevant specifications from ARM include:
- *
- * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A
- * CoreSight(tm) v1.0 Architecture Specification            ARM IHI 0029B
- *
- * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D
- * Cortex-M3(tm) TRM, ARM DDI 0337G
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "arm.h"
-#include "arm_adi_v5.h"
-#include <helper/time_support.h>
-
-
-/* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
-
-/*
-	uint32_t tar_block_size(uint32_t address)
-	Return the largest block starting at address that does not cross a tar block size alignment boundary
-*/
-static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
-{
-	return (tar_autoincr_block - ((tar_autoincr_block - 1) & address)) >> 2;
-}
-
-/***************************************************************************
- *                                                                         *
-<<<<<<< HEAD:src/target/arm_adi_v5.c
-=======
- * DPACC and APACC scanchain access through JTAG-DP                        *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
- * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
- * discusses operations which access these registers.
- *
- * Note that only one scan is performed.  If RnW is set, a separate scan
- * will be needed to collect the data which was read; the "invalue" collects
- * the posted result of a preceding operation, not the current one.
- *
- * @param swjdp the DAP
- * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
- * @param reg_addr two significant bits; A[3:2]; for APACC access, the
- *	SELECT register has more addressing bits.
- * @param RnW false iff outvalue will be written to the DP or AP
- * @param outvalue points to a 32-bit (little-endian) integer
- * @param invalue NULL, or points to a 32-bit (little-endian) integer
- * @param ack points to where the three bit JTAG_ACK_* code will be stored
- */
-static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
-{
-	struct arm_jtag *jtag_info = swjdp->jtag_info;
-	struct scan_field fields[2];
-	uint8_t out_addr_buf;
-
-	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	/* Scan out a read or write operation using some DP or AP register.
-	 * For APACC access with any sticky error flag set, this is discarded.
-	 */
-	fields[0].num_bits = 3;
-	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
-	fields[0].out_value = &out_addr_buf;
-	fields[0].in_value = ack;
-
-	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
-	 * complete; data we write is discarded, data we read is unpredictable.
-	 * When overrun detect is active, STICKYORUN is set.
-	 */
-
-	fields[1].num_bits = 32;
-	fields[1].out_value = outvalue;
-	fields[1].in_value = invalue;
-
-	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
-
-	/* Add specified number of tck clocks after starting memory bus
-	 * access, giving the hardware time to complete the access.
-	 * They provide more time for the (MEM) AP to complete the read ...
-	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&& ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr & 0xF0) == AP_REG_BD0))
-			&& (swjdp->memaccess_tck != 0))
-		jtag_add_runtest(swjdp->memaccess_tck,
-				TAP_IDLE);
-
-	return jtag_get_error();
-}
-
-/**
- * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
- * This is exactly like adi_jtag_dp_scan(), except that endianness
- * conversions are performed (so the types of invalue and outvalue
- * must be different).
- */
-static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
-{
-	uint8_t out_value_buf[4];
-	int retval;
-
-	buf_set_u32(out_value_buf, 0, 32, outvalue);
-
-	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
-			out_value_buf, (uint8_t *)invalue, ack);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (invalue)
-		jtag_add_callback(arm_le_to_h_u32,
-				(jtag_callback_data_t) invalue);
-
-	return retval;
-}
-
-/**
- * Utility to write AP registers.
- */
-static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
-		uint8_t reg_addr, uint8_t *outvalue)
-{
-	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
-			outvalue, NULL, NULL);
-}
-
-static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue)
-{
-	int retval;
-
-	/* Issue the read or write */
-	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
-			RnW, outvalue, NULL, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* For reads,  collect posted value; RDBUFF has no other effect.
-	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
-	 */
-	if ((RnW == DPAP_READ) && (invalue != NULL))
-		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
-	return retval;
-}
-
-static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
-{
-	int retval;
-	uint32_t ctrlstat;
-
-	/* too expensive to call keep_alive() here */
-
-#if 0
-	/* Danger!!!! BROKEN!!!! */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
-	R956 introduced the check on return value here and now Michael Schwingen reports
-	that this code no longer works....
-
-	https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html
-	*/
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR("BUG: Why does this fail the first time????");
-	}
-	/* Why??? second time it works??? */
-#endif
-
-	/* Post CTRL/STAT read; discard any previous posted read value
-	 * but collect its ACK status.
-	 */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-		return retval;
-
-	swjdp->ack = swjdp->ack & 0x7;
-
-	/* common code path avoids calling timeval_ms() */
-	if (swjdp->ack != JTAG_ACK_OK_FAULT)
-	{
-		long long then = timeval_ms();
-
-		while (swjdp->ack != JTAG_ACK_OK_FAULT)
-		{
-			if (swjdp->ack == JTAG_ACK_WAIT)
-			{
-				if ((timeval_ms()-then) > 1000)
-				{
-					/* NOTE:  this would be a good spot
-					 * to use JTAG_DP_ABORT.
-					 */
-					LOG_WARNING("Timeout (1000ms) waiting "
-						"for ACK=OK/FAULT "
-						"in JTAG-DP transaction");
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-			else
-			{
-				LOG_WARNING("Invalid ACK %#x "
-						"in JTAG-DP transaction",
-						swjdp->ack);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			swjdp->ack = swjdp->ack & 0x7;
-		}
-	}
-
-	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
-
-	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat & (SSTICKYORUN | SSTICKYERR))
-	{
-		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
-		/* Check power to debug regions */
-		if ((ctrlstat & 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(swjdp);
-		else
-		{
-			uint32_t mem_ap_csw, mem_ap_tar;
-
-			/* Maybe print information about last intended
-			 * MEM-AP access; but not if autoincrementing.
-			 * *Real* CSW and TAR values are always shown.
-			 */
-			if (swjdp->ap_tar_value != (uint32_t) -1)
-				LOG_DEBUG("MEM-AP Cached values: "
-					"ap_bank 0x%" PRIx32
-					", ap_csw 0x%" PRIx32
-					", ap_tar 0x%" PRIx32,
-					swjdp->ap_bank_value,
-					swjdp->ap_csw_value,
-					swjdp->ap_tar_value);
-
-			if (ctrlstat & SSTICKYORUN)
-				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
-					"memaccess, or reduce jtag speed");
-
-			if (ctrlstat & SSTICKYERR)
-				LOG_ERROR("JTAG-DP STICKY ERROR");
-
-			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_WRITE,
-					swjdp->dp_ctrl_stat | SSTICKYORUN
-						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_CSW, &mem_ap_csw);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_TAR, &mem_ap_tar);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
-					PRIx32, mem_ap_csw, mem_ap_tar);
-
-		}
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-/***************************************************************************
- *                                                                         *
->>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
- * DP and MEM-AP  register access  through APACC and DPACC                 *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Select one of the APs connected to the specified DAP.  The
- * selection is implicitly used with future AP transactions.
- * This is a NOP if the specified AP is already selected.
- *
- * @param swjdp The DAP
- * @param apsel Number of the AP to (implicitly) use with further
- *	transactions.  This normally identifies a MEM-AP.
- */
-void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
-{
-	uint32_t select = (apsel << 24) & 0xFF000000;
-
-	if (select != swjdp->apsel)
-	{
-		swjdp->apsel = select;
-		/* Switching AP invalidates cached values.
-		 * Values MUST BE UPDATED BEFORE AP ACCESS.
-		 */
-		swjdp->ap_bank_value = -1;
-		swjdp->ap_csw_value = -1;
-		swjdp->ap_tar_value = -1;
-	}
-}
-
-/**
- * Queue transactions setting up transfer parameters for the
- * currently selected MEM-AP.
- *
- * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
- * initiate data reads or writes using memory or peripheral addresses.
- * If the CSW is configured for it, the TAR may be automatically
- * incremented after each transfer.
- *
- * @todo Rename to reflect it being specifically a MEM-AP function.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
- *	matches the cached value, the register is not changed.
- * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
- *	matches the cached address, the register is not changed.
- *
- * @return ERROR_OK if the transaction was properly queued, else a fault code.
- */
-int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
-{
-	int retval;
-
-	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
-	if (csw != swjdp->ap_csw_value)
-	{
-		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp->ap_csw_value = csw;
-	}
-	if (tar != swjdp->ap_tar_value)
-	{
-		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp->ap_tar_value = tar;
-	}
-	/* Disable TAR cache when autoincrementing */
-	if (csw & CSW_ADDRINC_MASK)
-		swjdp->ap_tar_value = -1;
-	return ERROR_OK;
-}
-
-/**
- * Asynchronous (queued) read of a word from memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the word will be stored when the
- *	transaction queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when reading several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address & 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address & 0xC), value);
-}
-
-/**
- * Synchronous read of a word from memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the result will be stored.
- *
- * @return ERROR_OK for success; *value holds the result.
- * Otherwise a fault code.
- */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	retval = mem_ap_read_u32(swjdp, address, value);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/**
- * Asynchronous (queued) write of a word to memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written to the address when transaction
- *	queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when writing several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address & 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address & 0xC),
-			value);
-}
-
-/**
- * Synchronous write of a word to memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written.
- *
- * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
- */
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval = mem_ap_write_u32(swjdp, address, value);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/*****************************************************************************
-*                                                                            *
-* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
-*                                                                            *
-* Write a buffer in target order (little endian)                             *
-*                                                                            *
-*****************************************************************************/
-int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count >>= 2;
-	wcount = count;
-
-	/* if we have an unaligned access - reorder data */
-	if (adr & 0x3u)
-	{
-		for (writecount = 0; writecount < count; writecount++)
-		{
-			int i;
-			uint32_t outvalue;
-			memcpy(&outvalue, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i < 4; i++)
-			{
-				*((uint8_t*)pBuffer + (adr & 0x3)) = outvalue;
-				outvalue >>= 8;
-				adr++;
-			}
-			pBuffer += sizeof(uint32_t);
-		}
-	}
-
-	while (wcount > 0)
-	{
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-
-		for (writecount = 0; writecount < blocksize; writecount++)
-		{
-			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
-				*(uint32_t *) (buffer + 4 * writecount));
-			if (retval != ERROR_OK)
-				break;
-		}
-
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address = address + 4 * blocksize;
-			buffer = buffer + 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount > 1)
-		{
-			LOG_WARNING("Block write error address 0x%" PRIx32 ", wcount 0x%x", address, wcount);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count >> 1;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN((writecount << 1), 4);
-
-			if (nbytes < 4)
-			{
-				if (mem_ap_write_buf_u16(swjdp, buffer,
-						nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes >> 1;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i < nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
-					outvalue >>= 8;
-					address++;
-				}
-
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes >> 1;
-			writecount -= nbytes >> 1;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		uint16_t svalue;
-		memcpy(&svalue, buffer, sizeof(uint16_t));
-		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count -= 2;
-		address += 2;
-		buffer += 2;
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN(writecount, 4);
-
-			if (nbytes < 4)
-			{
-				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i < nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
-					outvalue >>= 8;
-					address++;
-				}
-
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes;
-			writecount -= nbytes;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/* FIXME don't import ... this is a temporary workaround for the
- * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
- */
-extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
-
-/**
- * Synchronously read a block of 32-bit words into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the words will be stored (in host byte order).
- * @param count How many words to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count >>= 2;
-	wcount = count;
-
-	while (wcount > 0)
-	{
-		/* Adjust to read blocks within boundaries aligned to the
-		 * TAR autoincrement size (at least 2^10).  Autoincrement
-		 * mode avoids an extra per-word roundtrip to update TAR.
-		 */
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block,
-				address);
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
-				address);
-
-		/* FIXME remove these three calls to adi_jtag_dp_scan(),
-		 * so this routine becomes transport-neutral.  Be careful
-		 * not to cause performance problems with JTAG; would it
-		 * suffice to loop over dap_queue_ap_read(), or would that
-		 * be slower when JTAG is the chosen transport?
-		 */
-
-		/* Scan out first read */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-				DPAP_READ, 0, NULL, NULL);
-		for (readcount = 0; readcount < blocksize - 1; readcount++)
-		{
-			/* Scan out next read; scan in posted value for the
-			 * previous one.  Assumes read is acked "OK/FAULT",
-			 * and CTRL_STAT says that meant "OK".
-			 */
-			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-					DPAP_READ, 0, buffer + 4 * readcount,
-					&swjdp->ack);
-		}
-
-		/* Scan in last posted value; RDBUFF has no other effect,
-		 * assuming ack is OK/FAULT and CTRL_STAT says "OK".
-		 */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
-				DPAP_READ, 0, buffer + 4 * readcount,
-				&swjdp->ack);
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address += 4 * blocksize;
-			buffer += 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount > 1)
-		{
-			LOG_WARNING("Block read error address 0x%" PRIx32
-				", count 0x%x", address, count);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	/* if we have an unaligned access - reorder data */
-	if (adr & 0x3u)
-	{
-		for (readcount = 0; readcount < count; readcount++)
-		{
-			int i;
-			uint32_t data;
-			memcpy(&data, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i < 4; i++)
-			{
-				*((uint8_t*)pBuffer) =
-						(data >> 8 * (adr & 0x3));
-				pBuffer++;
-				adr++;
-			}
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count >> 1;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN((readcount << 1), 4);
-
-			for (i = 0; i < nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= (nbytes >> 1);
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of 16-bit halfwords into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the halfwords will be stored (in host byte order).
- * @param count How many halfwords to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue, i;
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		if (address & 0x1)
-		{
-			for (i = 0; i < 2; i++)
-			{
-				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-				buffer++;
-				address++;
-			}
-		}
-		else
-		{
-			uint16_t svalue = (invalue >> 8 * (address & 0x3));
-			memcpy(buffer, &svalue, sizeof(uint16_t));
-			address += 2;
-			buffer += 2;
-		}
-		count -= 2;
-	}
-
-	return retval;
-}
-
-/* FIX!!! is this a potential performance bottleneck w.r.t. requiring too many
- * roundtrips when jtag_execute_queue() has a large overhead(e.g. for USB)s?
- *
- * The solution is to arrange for a large out/in scan in this loop and
- * and convert data afterwards.
- */
-static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN(readcount, 4);
-
-			for (i = 0; i < nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= nbytes;
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of bytes into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the bytes will be stored.
- * @param count How many bytes to read.
- * @param address Memory address from which to read data; all the
- *	data must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/*--------------------------------------------------------------------------*/
-
-<<<<<<< HEAD:src/target/arm_adi_v5.c
-=======
-static int jtag_idcode_q_read(struct adiv5_dap *dap,
-		uint8_t *ack, uint32_t *data)
-{
-	struct arm_jtag *jtag_info = dap->jtag_info;
-	int retval;
-	struct scan_field fields[1];
-
-	jtag_set_end_state(TAP_IDLE);
-
-	/* This is a standard JTAG operation -- no DAP tweakage */
-	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	fields[0].num_bits = 32;
-	fields[0].out_value = NULL;
-	fields[0].in_value = (void *) data;
-
-	jtag_add_dr_scan(jtag_info->tap, 1, fields, TAP_IDLE);
-	retval = jtag_get_error();
-	if (retval != ERROR_OK)
-		return retval;
-
-	jtag_add_callback(arm_le_to_h_u32,
-			(jtag_callback_data_t) data);
-
-	return retval;
-}
-
-static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_READ, 0, data);
-}
-
-static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_WRITE, data, NULL);
-}
-
-/** Select the AP register bank matching bits 7:4 of reg. */
-static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
-{
-	uint32_t select = reg & 0x000000F0;
-
-	if (select == dap->ap_bank_value)
-		return ERROR_OK;
-	dap->ap_bank_value = select;
-
-	select |= dap->apsel;
-
-	return jtag_dp_q_write(dap, DP_SELECT, select);
-}
-
-static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	int retval = jtag_ap_q_bankselect(dap, reg);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
-			DPAP_READ, 0, data);
-}
-
-static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	uint8_t out_value_buf[4];
-
-	int retval = jtag_ap_q_bankselect(dap, reg);
-	if (retval != ERROR_OK)
-		return retval;
->>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
-
-/* FIXME don't import ... just initialize as
- * part of DAP transport setup
-*/
-extern const struct dap_ops jtag_dp_ops;
-
-/*--------------------------------------------------------------------------*/
-
-/**
- * Initialize a DAP.  This sets up the power domains, prepares the DP
- * for further use, and arranges to use AP #0 for all AP operations
- * until dap_ap-select() changes that policy.
- *
- * @param swjdp The DAP being initialized.
- *
- * @todo Rename this.  We also need an initialization scheme which account
- * for SWD transports not just JTAG; that will need to address differences
- * in layering.  (JTAG is useful without any debug target; but not SWD.)
- * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
- */
-int ahbap_debugport_init(struct adiv5_dap *swjdp)
-{
-	uint32_t idreg, romaddr, dummy;
-	uint32_t ctrlstat;
-	int cnt = 0;
-	int retval;
-
-	LOG_DEBUG(" ");
-
-	/* JTAG-DP or SWJ-DP, in JTAG mode */
-	swjdp->ops = &jtag_dp_ops;
-
-	/* Default MEM-AP setup.
-	 *
-	 * REVISIT AP #0 may be an inappropriate default for this.
-	 * Should we probe, or take a hint from the caller?
-	 * Presumably we can ignore the possibility of multiple APs.
-	 */
-	swjdp->apsel = !0;
-	dap_ap_select(swjdp, 0);
-
-	/* DP initialization */
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
-	if (retval != ERROR_OK)
-		return retval;
-	if ((retval = dap_run(swjdp)) != ERROR_OK)
-		return retval;
-
-	/* Check that we have debug power domains activated */
-	while (!(ctrlstat & CDBGPWRUPACK) && (cnt++ < 10))
-	{
-		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	while (!(ctrlstat & CSYSPWRUPACK) && (cnt++ < 10))
-	{
-		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-	/* With debug power on we can activate OVERRUN checking */
-	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * REVISIT this isn't actually *initializing* anything in an AP,
-	 * and doesn't care if it's a MEM-AP at all (much less AHB-AP).
-	 * Should it?  If the ROM address is valid, is this the right
-	 * place to scan the table and do any topology detection?
-	 */
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &idreg);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &romaddr);
-
-	LOG_DEBUG("MEM-AP #%d ID Register 0x%" PRIx32
-		", Debug ROM Address 0x%" PRIx32,
-		swjdp->apsel, idreg, romaddr);
-
-	return ERROR_OK;
-}
-
-/* CID interpretation -- see ARM IHI 0029B section 3
- * and ARM IHI 0031A table 13-3.
- */
-static const char *class_description[16] ={
-	"Reserved", "ROM table", "Reserved", "Reserved",
-	"Reserved", "Reserved", "Reserved", "Reserved",
-	"Reserved", "CoreSight component", "Reserved", "Peripheral Test Block",
-	"Reserved", "OptimoDE DESS",
-		"Generic IP component", "PrimeCell or System component"
-};
-
-static bool
-is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
-{
-	return cid3 == 0xb1 && cid2 == 0x05
-			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
-}
-
-static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *swjdp, int apsel)
-{
-	int retval;
-	uint32_t dbgbase, apid;
-	int romtable_present = 0;
-	uint8_t mem_ap;
-	uint32_t apselold;
-
-	/* AP address is in bits 31:24 of DP_SELECT */
-	if (apsel >= 256)
-		return ERROR_INVALID_ARGUMENTS;
-
-	apselold = swjdp->apsel;
-	dap_ap_select(swjdp, apsel);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &dbgbase);
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
-	retval = dap_run(swjdp);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-	mem_ap = ((apid&0x10000) && ((apid&0x0F) != 0));
-	command_print(cmd_ctx, "AP ID register 0x%8.8" PRIx32, apid);
-	if (apid)
-	{
-		switch (apid&0x0F)
-		{
-			case 0:
-				command_print(cmd_ctx, "\tType is JTAG-AP");
-				break;
-			case 1:
-				command_print(cmd_ctx, "\tType is MEM-AP AHB");
-				break;
-			case 2:
-				command_print(cmd_ctx, "\tType is MEM-AP APB");
-				break;
-			default:
-				command_print(cmd_ctx, "\tUnknown AP type");
-				break;
-		}
-
-		/* NOTE: a MEM-AP may have a single CoreSight component that's
-		 * not a ROM table ... or have no such components at all.
-		 */
-		if (mem_ap)
-			command_print(cmd_ctx, "AP BASE 0x%8.8" PRIx32,
-					dbgbase);
-	}
-	else
-	{
-		command_print(cmd_ctx, "No AP found at this apsel 0x%x", apsel);
-	}
-
-	romtable_present = ((mem_ap) && (dbgbase != 0xFFFFFFFF));
-	if (romtable_present)
-	{
-		uint32_t cid0,cid1,cid2,cid3,memtype,romentry;
-		uint16_t entry_offset;
-
-		/* bit 16 of apid indicates a memory access port */
-		if (dbgbase & 0x02)
-			command_print(cmd_ctx, "\tValid ROM table present");
-		else
-			command_print(cmd_ctx, "\tROM table in legacy format");
-
-		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			return retval;
-
-		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-			command_print(cmd_ctx, "\tCID3 0x%2.2" PRIx32
-					", CID2 0x%2.2" PRIx32
-					", CID1 0x%2.2" PRIx32
-					", CID0 0x%2.2" PRIx32,
-					cid3, cid2, cid1, cid0);
-		if (memtype & 0x01)
-			command_print(cmd_ctx, "\tMEMTYPE system memory present on bus");
-		else
-			command_print(cmd_ctx, "\tMEMTYPE System memory not present. "
-					"Dedicated debug bus.");
-
-		/* Now we read ROM table entries from dbgbase&0xFFFFF000) | 0x000 until we get 0x00000000 */
-		entry_offset = 0;
-		do
-		{
-			mem_ap_read_atomic_u32(swjdp, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
-			command_print(cmd_ctx, "\tROMTABLE[0x%x] = 0x%" PRIx32 "",entry_offset,romentry);
-			if (romentry&0x01)
-			{
-				uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
-				uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
-				uint32_t component_start, component_base;
-				unsigned part_num;
-				char *type, *full;
-
-				component_base = (uint32_t)((dbgbase & 0xFFFFF000)
-						+ (int)(romentry & 0xFFFFF000));
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFE0, &c_pid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFE4, &c_pid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFE8, &c_pid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFEC, &c_pid3);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFD0, &c_pid4);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFF0, &c_cid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFF4, &c_cid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFF8, &c_cid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFFC, &c_cid3);
-				component_start = component_base - 0x1000*(c_pid4 >> 4);
-
-				command_print(cmd_ctx, "\t\tComponent base address 0x%" PRIx32
-						", start address 0x%" PRIx32,
-						component_base, component_start);
-				command_print(cmd_ctx, "\t\tComponent class is 0x%x, %s",
-						(int) (c_cid1 >> 4) & 0xf,
-						/* See ARM IHI 0029B Table 3-3 */
-						class_description[(c_cid1 >> 4) & 0xf]);
-
-				/* CoreSight component? */
-				if (((c_cid1 >> 4) & 0x0f) == 9) {
-					uint32_t devtype;
-					unsigned minor;
-					char *major = "Reserved", *subtype = "Reserved";
-
-					mem_ap_read_atomic_u32(swjdp,
-							(component_base & 0xfffff000) | 0xfcc,
-							&devtype);
-					minor = (devtype >> 4) & 0x0f;
-					switch (devtype & 0x0f) {
-					case 0:
-						major = "Miscellaneous";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 4:
-							subtype = "Validation component";
-							break;
-						}
-						break;
-					case 1:
-						major = "Trace Sink";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Port";
-							break;
-						case 2:
-							subtype = "Buffer";
-							break;
-						}
-						break;
-					case 2:
-						major = "Trace Link";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Funnel, router";
-							break;
-						case 2:
-							subtype = "Filter";
-							break;
-						case 3:
-							subtype = "FIFO, buffer";
-							break;
-						}
-						break;
-					case 3:
-						major = "Trace Source";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Processor";
-							break;
-						case 2:
-							subtype = "DSP";
-							break;
-						case 3:
-							subtype = "Engine/Coprocessor";
-							break;
-						case 4:
-							subtype = "Bus";
-							break;
-						}
-						break;
-					case 4:
-						major = "Debug Control";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Trigger Matrix";
-							break;
-						case 2:
-							subtype = "Debug Auth";
-							break;
-						}
-						break;
-					case 5:
-						major = "Debug Logic";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Processor";
-							break;
-						case 2:
-							subtype = "DSP";
-							break;
-						case 3:
-							subtype = "Engine/Coprocessor";
-							break;
-						}
-						break;
-					}
-					command_print(cmd_ctx, "\t\tType is 0x%2.2x, %s, %s",
-							(unsigned) (devtype & 0xff),
-							major, subtype);
-					/* REVISIT also show 0xfc8 DevId */
-				}
-
-				if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-					command_print(cmd_ctx, "\t\tCID3 0x%2.2" PRIx32
-							", CID2 0x%2.2" PRIx32
-							", CID1 0x%2.2" PRIx32
-							", CID0 0x%2.2" PRIx32,
-							c_cid3, c_cid2, c_cid1, c_cid0);
-				command_print(cmd_ctx, "\t\tPeripheral ID[4..0] = hex "
-						"%2.2x %2.2x %2.2x %2.2x %2.2x",
-						(int) c_pid4,
-						(int) c_pid3, (int) c_pid2,
-						(int) c_pid1, (int) c_pid0);
-
-				/* Part number interpretations are from Cortex
-				 * core specs, the CoreSight components TRM
-				 * (ARM DDI 0314H), and ETM specs; also from
-				 * chip observation (e.g. TI SDTI).
-				 */
-				part_num = c_pid0 & 0xff;
-				part_num |= (c_pid1 & 0x0f) << 8;
-				switch (part_num) {
-				case 0x000:
-					type = "Cortex-M3 NVIC";
-					full = "(Interrupt Controller)";
-					break;
-				case 0x001:
-					type = "Cortex-M3 ITM";
-					full = "(Instrumentation Trace Module)";
-					break;
-				case 0x002:
-					type = "Cortex-M3 DWT";
-					full = "(Data Watchpoint and Trace)";
-					break;
-				case 0x003:
-					type = "Cortex-M3 FBP";
-					full = "(Flash Patch and Breakpoint)";
-					break;
-				case 0x00d:
-					type = "CoreSight ETM11";
-					full = "(Embedded Trace)";
-					break;
-				// case 0x113: what?
-				case 0x120:		/* from OMAP3 memmap */
-					type = "TI SDTI";
-					full = "(System Debug Trace Interface)";
-					break;
-				case 0x343:		/* from OMAP3 memmap */
-					type = "TI DAPCTL";
-					full = "";
-					break;
-				case 0x906:
-					type = "Coresight CTI";
-					full = "(Cross Trigger)";
-					break;
-				case 0x907:
-					type = "Coresight ETB";
-					full = "(Trace Buffer)";
-					break;
-				case 0x908:
-					type = "Coresight CSTF";
-					full = "(Trace Funnel)";
-					break;
-				case 0x910:
-					type = "CoreSight ETM9";
-					full = "(Embedded Trace)";
-					break;
-				case 0x912:
-					type = "Coresight TPIU";
-					full = "(Trace Port Interface Unit)";
-					break;
-				case 0x921:
-					type = "Cortex-A8 ETM";
-					full = "(Embedded Trace)";
-					break;
-				case 0x922:
-					type = "Cortex-A8 CTI";
-					full = "(Cross Trigger)";
-					break;
-				case 0x923:
-					type = "Cortex-M3 TPIU";
-					full = "(Trace Port Interface Unit)";
-					break;
-				case 0x924:
-					type = "Cortex-M3 ETM";
-					full = "(Embedded Trace)";
-					break;
-				case 0xc08:
-					type = "Cortex-A8 Debug";
-					full = "(Debug Unit)";
-					break;
-				default:
-					type = "-*- unrecognized -*-";
-					full = "";
-					break;
-				}
-				command_print(cmd_ctx, "\t\tPart is %s %s",
-						type, full);
-			}
-			else
-			{
-				if (romentry)
-					command_print(cmd_ctx, "\t\tComponent not present");
-				else
-					command_print(cmd_ctx, "\t\tEnd of ROM table");
-			}
-			entry_offset += 4;
-		} while (romentry > 0);
-	}
-	else
-	{
-		command_print(cmd_ctx, "\tNo ROM table present");
-	}
-	dap_ap_select(swjdp, apselold);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_dap_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-	uint32_t apsel;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	return dap_info_command(CMD_CTX, dap, apsel);
-}
-
-COMMAND_HANDLER(dap_baseaddr_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t apsel, apselsave, baseaddr;
-	int retval;
-
-	apselsave = dap->apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	/* NOTE:  assumes we're talking to a MEM-AP, which
-	 * has a base address.  There are other kinds of AP,
-	 * though they're not common for now.  This should
-	 * use the ID register to verify it's a MEM-AP.
-	 */
-	retval = dap_queue_ap_read(dap, AP_REG_BASE, &baseaddr);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, "0x%8.8" PRIx32, baseaddr);
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_memaccess_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t memaccess_tck;
-
-	switch (CMD_ARGC) {
-	case 0:
-		memaccess_tck = dap->memaccess_tck;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-	dap->memaccess_tck = memaccess_tck;
-
-	command_print(CMD_CTX, "memory bus access delay set to %" PRIi32 " tck",
-			dap->memaccess_tck);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(dap_apsel_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t apsel, apid;
-	int retval;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = 0;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	dap_ap_select(dap, apsel);
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, "ap %" PRIi32 " selected, identification register 0x%8.8" PRIx32,
-			apsel, apid);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_apid_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t apsel, apselsave, apid;
-	int retval;
-
-	apselsave = dap->apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, "0x%8.8" PRIx32, apid);
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-static const struct command_registration dap_commands[] = {
-	{
-		.name = "info",
-		.handler = handle_dap_info_command,
-		.mode = COMMAND_EXEC,
-		.help = "display ROM table for MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apsel",
-		.handler = dap_apsel_command,
-		.mode = COMMAND_EXEC,
-		.help = "Set the currently selected AP (default 0) "
-			"and display the result",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apid",
-		.handler = dap_apid_command,
-		.mode = COMMAND_EXEC,
-		.help = "return ID register from AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "baseaddr",
-		.handler = dap_baseaddr_command,
-		.mode = COMMAND_EXEC,
-		.help = "return debug base address from MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "memaccess",
-		.handler = dap_memaccess_command,
-		.mode = COMMAND_EXEC,
-		.help = "set/get number of extra tck for MEM-AP memory "
-			"bus access [0-255]",
-		.usage = "[cycles]",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-const struct command_registration dap_command_handlers[] = {
-	{
-		.name = "dap",
-		.mode = COMMAND_EXEC,
-		.help = "DAP command group",
-		.chain = dap_commands,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-
-/*
- * This represents the bits which must be sent out on TMS/SWDIO to
- * switch a DAP implemented using an SWJ-DP module into SWD mode.
- * These bits are stored (and transmitted) LSB-first.
- *
- * See the DAP-Lite specification, section 2.2.5 for information
- * about making the debug link select SWD or JTAG.  (Similar info
- * is in a few other ARM documents.)
- */
-static const uint8_t jtag2swd_bitseq[] = {
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	/* Switching sequence enables SWD and disables JTAG
-	 * NOTE: bits in the DP's IDCODE may expose the need for
-	 * an old/deprecated sequence (0xb6 0xed).
-	 */
-	0x9e, 0xe7,
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-};
-
-/**
- * Put the debug link into SWD mode, if the target supports it.
- * The link's initial mode may be either JTAG (for example,
- * with SWJ-DP after reset) or SWD.
- *
- * @param target Enters SWD mode (if possible).
- *
- * Note that targets using the JTAG-DP do not support SWD, and that
- * some targets which could otherwise support it may have have been
- * configured to disable SWD signaling
- *
- * @return ERROR_OK or else a fault code.
- */
-int dap_to_swd(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG("Enter SWD mode");
-
-	/* REVISIT it's nasty to need to make calls to a "jtag"
-	 * subsystem if the link isn't in JTAG mode...
-	 */
-
-	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
-			jtag2swd_bitseq, TAP_INVALID);
-	if (retval == ERROR_OK)
-		retval = jtag_execute_queue();
-
-	/* REVISIT set up the DAP's ops vector for SWD mode. */
-
-	return retval;
-}
-
diff --git a/src/target/arm_adi_v5.c~ b/src/target/arm_adi_v5.c~
deleted file mode 100644
index 708e858..0000000
--- a/src/target/arm_adi_v5.c~
+++ /dev/null
@@ -1,1981 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2006 by Magnus Lundin                                   *
- *   lundin at mlu.mine.nu                                                    *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   spen at spen-soft.co.uk                                                  *
- *                                                                         *
- *   Copyright (C) 2009 by Oyvind Harboe                                   *
- *   oyvind.harboe at zylin.com                                               *
- *                                                                         *
- *   Copyright (C) 2009-2010 by David Brownell                             *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-/**
- * @file
- * This file implements support for the ARM Debug Interface version 5 (ADIv5)
- * debugging architecture.  Compared with previous versions, this includes
- * a low pin-count Serial Wire Debug (SWD) alternative to JTAG for message
- * transport, and focusses on memory mapped resources as defined by the
- * CoreSight architecture.
- *
- * A key concept in ADIv5 is the Debug Access Port, or DAP.  A DAP has two
- * basic components:  a Debug Port (DP) transporting messages to and from a
- * debugger, and an Access Port (AP) accessing resources.  Three types of DP
- * are defined.  One uses only JTAG for communication, and is called JTAG-DP.
- * One uses only SWD for communication, and is called SW-DP.  The third can
- * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
- * is used to access memory mapped resources and is called a MEM-AP.  Also a
- * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
- *
- * This programming interface allows DAP pipelined operations through a
- * transaction queue.  This primarily affects AP operations (such as using
- * a MEM-AP to access memory or registers).  If the current transaction has
- * not finished by the time the next one must begin, and the ORUNDETECT bit
- * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
- * further AP operations will fail.  There are two basic methods to avoid
- * such overrun errors.  One involves polling for status instead of using
- * transaction piplining.  The other involves adding delays to ensure the
- * AP has enough time to complete one operation before starting the next
- * one.  (For JTAG these delays are controlled by memaccess_tck.)
- */
-
-/*
- * Relevant specifications from ARM include:
- *
- * ARM(tm) Debug Interface v5 Architecture Specification    ARM IHI 0031A
- * CoreSight(tm) v1.0 Architecture Specification            ARM IHI 0029B
- *
- * CoreSight(tm) DAP-Lite TRM, ARM DDI 0316D
- * Cortex-M3(tm) TRM, ARM DDI 0337G
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "arm.h"
-#include "arm_adi_v5.h"
-#include <helper/time_support.h>
-
-
-/* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
-
-/*
-	uint32_t tar_block_size(uint32_t address)
-	Return the largest block starting at address that does not cross a tar block size alignment boundary
-*/
-static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
-{
-	return (tar_autoincr_block - ((tar_autoincr_block - 1) & address)) >> 2;
-}
-
-/***************************************************************************
- *                                                                         *
-<<<<<<< HEAD:src/target/arm_adi_v5.c
-=======
- * DPACC and APACC scanchain access through JTAG-DP                        *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Scan DPACC or APACC using target ordered uint8_t buffers.  No endianness
- * conversions are performed.  See section 4.4.3 of the ADIv5 spec, which
- * discusses operations which access these registers.
- *
- * Note that only one scan is performed.  If RnW is set, a separate scan
- * will be needed to collect the data which was read; the "invalue" collects
- * the posted result of a preceding operation, not the current one.
- *
- * @param swjdp the DAP
- * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
- * @param reg_addr two significant bits; A[3:2]; for APACC access, the
- *	SELECT register has more addressing bits.
- * @param RnW false iff outvalue will be written to the DP or AP
- * @param outvalue points to a 32-bit (little-endian) integer
- * @param invalue NULL, or points to a 32-bit (little-endian) integer
- * @param ack points to where the three bit JTAG_ACK_* code will be stored
- */
-static int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
-{
-	struct arm_jtag *jtag_info = swjdp->jtag_info;
-	struct scan_field fields[2];
-	uint8_t out_addr_buf;
-
-	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	/* Scan out a read or write operation using some DP or AP register.
-	 * For APACC access with any sticky error flag set, this is discarded.
-	 */
-	fields[0].num_bits = 3;
-	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
-	fields[0].out_value = &out_addr_buf;
-	fields[0].in_value = ack;
-
-	/* NOTE: if we receive JTAG_ACK_WAIT, the previous operation did not
-	 * complete; data we write is discarded, data we read is unpredictable.
-	 * When overrun detect is active, STICKYORUN is set.
-	 */
-
-	fields[1].num_bits = 32;
-	fields[1].out_value = outvalue;
-	fields[1].in_value = invalue;
-
-	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
-
-	/* Add specified number of tck clocks after starting memory bus
-	 * access, giving the hardware time to complete the access.
-	 * They provide more time for the (MEM) AP to complete the read ...
-	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&& ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr & 0xF0) == AP_REG_BD0))
-			&& (swjdp->memaccess_tck != 0))
-		jtag_add_runtest(swjdp->memaccess_tck,
-				TAP_IDLE);
-
-	return jtag_get_error();
-}
-
-/**
- * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
- * This is exactly like adi_jtag_dp_scan(), except that endianness
- * conversions are performed (so the types of invalue and outvalue
- * must be different).
- */
-static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
-{
-	uint8_t out_value_buf[4];
-	int retval;
-
-	buf_set_u32(out_value_buf, 0, 32, outvalue);
-
-	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
-			out_value_buf, (uint8_t *)invalue, ack);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (invalue)
-		jtag_add_callback(arm_le_to_h_u32,
-				(jtag_callback_data_t) invalue);
-
-	return retval;
-}
-
-/**
- * Utility to write AP registers.
- */
-static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
-		uint8_t reg_addr, uint8_t *outvalue)
-{
-	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
-			outvalue, NULL, NULL);
-}
-
-static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint32_t outvalue, uint32_t *invalue)
-{
-	int retval;
-
-	/* Issue the read or write */
-	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
-			RnW, outvalue, NULL, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* For reads,  collect posted value; RDBUFF has no other effect.
-	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
-	 */
-	if ((RnW == DPAP_READ) && (invalue != NULL))
-		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
-	return retval;
-}
-
-static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
-{
-	int retval;
-	uint32_t ctrlstat;
-
-	/* too expensive to call keep_alive() here */
-
-#if 0
-	/* Danger!!!! BROKEN!!!! */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
-	R956 introduced the check on return value here and now Michael Schwingen reports
-	that this code no longer works....
-
-	https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html
-	*/
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR("BUG: Why does this fail the first time????");
-	}
-	/* Why??? second time it works??? */
-#endif
-
-	/* Post CTRL/STAT read; discard any previous posted read value
-	 * but collect its ACK status.
-	 */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-		return retval;
-
-	swjdp->ack = swjdp->ack & 0x7;
-
-	/* common code path avoids calling timeval_ms() */
-	if (swjdp->ack != JTAG_ACK_OK_FAULT)
-	{
-		long long then = timeval_ms();
-
-		while (swjdp->ack != JTAG_ACK_OK_FAULT)
-		{
-			if (swjdp->ack == JTAG_ACK_WAIT)
-			{
-				if ((timeval_ms()-then) > 1000)
-				{
-					/* NOTE:  this would be a good spot
-					 * to use JTAG_DP_ABORT.
-					 */
-					LOG_WARNING("Timeout (1000ms) waiting "
-						"for ACK=OK/FAULT "
-						"in JTAG-DP transaction");
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-			else
-			{
-				LOG_WARNING("Invalid ACK %#x "
-						"in JTAG-DP transaction",
-						swjdp->ack);
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			swjdp->ack = swjdp->ack & 0x7;
-		}
-	}
-
-	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
-
-	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat & (SSTICKYORUN | SSTICKYERR))
-	{
-		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
-		/* Check power to debug regions */
-		if ((ctrlstat & 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(swjdp);
-		else
-		{
-			uint32_t mem_ap_csw, mem_ap_tar;
-
-			/* Maybe print information about last intended
-			 * MEM-AP access; but not if autoincrementing.
-			 * *Real* CSW and TAR values are always shown.
-			 */
-			if (swjdp->ap_tar_value != (uint32_t) -1)
-				LOG_DEBUG("MEM-AP Cached values: "
-					"ap_bank 0x%" PRIx32
-					", ap_csw 0x%" PRIx32
-					", ap_tar 0x%" PRIx32,
-					swjdp->ap_bank_value,
-					swjdp->ap_csw_value,
-					swjdp->ap_tar_value);
-
-			if (ctrlstat & SSTICKYORUN)
-				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
-					"memaccess, or reduce jtag speed");
-
-			if (ctrlstat & SSTICKYERR)
-				LOG_ERROR("JTAG-DP STICKY ERROR");
-
-			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_WRITE,
-					swjdp->dp_ctrl_stat | SSTICKYORUN
-						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_CSW, &mem_ap_csw);
-			if (retval != ERROR_OK)
-				return retval;
-
-			retval = dap_queue_ap_read(swjdp,
-					AP_REG_TAR, &mem_ap_tar);
-			if (retval != ERROR_OK)
-				return retval;
-
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
-				return retval;
-			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
-					PRIx32, mem_ap_csw, mem_ap_tar);
-
-		}
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
-	}
-
-	return ERROR_OK;
-}
-
-/***************************************************************************
- *                                                                         *
->>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
- * DP and MEM-AP  register access  through APACC and DPACC                 *
- *                                                                         *
-***************************************************************************/
-
-/**
- * Select one of the APs connected to the specified DAP.  The
- * selection is implicitly used with future AP transactions.
- * This is a NOP if the specified AP is already selected.
- *
- * @param swjdp The DAP
- * @param apsel Number of the AP to (implicitly) use with further
- *	transactions.  This normally identifies a MEM-AP.
- */
-void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
-{
-	uint32_t select = (apsel << 24) & 0xFF000000;
-
-	if (select != swjdp->apsel)
-	{
-		swjdp->apsel = select;
-		/* Switching AP invalidates cached values.
-		 * Values MUST BE UPDATED BEFORE AP ACCESS.
-		 */
-		swjdp->ap_bank_value = -1;
-		swjdp->ap_csw_value = -1;
-		swjdp->ap_tar_value = -1;
-	}
-}
-
-/**
- * Queue transactions setting up transfer parameters for the
- * currently selected MEM-AP.
- *
- * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
- * initiate data reads or writes using memory or peripheral addresses.
- * If the CSW is configured for it, the TAR may be automatically
- * incremented after each transfer.
- *
- * @todo Rename to reflect it being specifically a MEM-AP function.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
- *	matches the cached value, the register is not changed.
- * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
- *	matches the cached address, the register is not changed.
- *
- * @return ERROR_OK if the transaction was properly queued, else a fault code.
- */
-int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
-{
-	int retval;
-
-	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
-	if (csw != swjdp->ap_csw_value)
-	{
-		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp->ap_csw_value = csw;
-	}
-	if (tar != swjdp->ap_tar_value)
-	{
-		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
-		if (retval != ERROR_OK)
-			return retval;
-		swjdp->ap_tar_value = tar;
-	}
-	/* Disable TAR cache when autoincrementing */
-	if (csw & CSW_ADDRINC_MASK)
-		swjdp->ap_tar_value = -1;
-	return ERROR_OK;
-}
-
-/**
- * Asynchronous (queued) read of a word from memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the word will be stored when the
- *	transaction queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when reading several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address & 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address & 0xC), value);
-}
-
-/**
- * Synchronous read of a word from memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the result will be stored.
- *
- * @return ERROR_OK for success; *value holds the result.
- * Otherwise a fault code.
- */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t *value)
-{
-	int retval;
-
-	retval = mem_ap_read_u32(swjdp, address, value);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/**
- * Asynchronous (queued) write of a word to memory or a system register.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written to the address when transaction
- *	queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when writing several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
-			address & 0xFFFFFFF0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address & 0xC),
-			value);
-}
-
-/**
- * Synchronous write of a word to memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param swjdp The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written.
- *
- * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
- */
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
-		uint32_t value)
-{
-	int retval = mem_ap_write_u32(swjdp, address, value);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return dap_run(swjdp);
-}
-
-/*****************************************************************************
-*                                                                            *
-* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
-*                                                                            *
-* Write a buffer in target order (little endian)                             *
-*                                                                            *
-*****************************************************************************/
-int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count >>= 2;
-	wcount = count;
-
-	/* if we have an unaligned access - reorder data */
-	if (adr & 0x3u)
-	{
-		for (writecount = 0; writecount < count; writecount++)
-		{
-			int i;
-			uint32_t outvalue;
-			memcpy(&outvalue, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i < 4; i++)
-			{
-				*((uint8_t*)pBuffer + (adr & 0x3)) = outvalue;
-				outvalue >>= 8;
-				adr++;
-			}
-			pBuffer += sizeof(uint32_t);
-		}
-	}
-
-	while (wcount > 0)
-	{
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-
-		for (writecount = 0; writecount < blocksize; writecount++)
-		{
-			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
-				*(uint32_t *) (buffer + 4 * writecount));
-			if (retval != ERROR_OK)
-				break;
-		}
-
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address = address + 4 * blocksize;
-			buffer = buffer + 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount > 1)
-		{
-			LOG_WARNING("Block write error address 0x%" PRIx32 ", wcount 0x%x", address, wcount);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count >> 1;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN((writecount << 1), 4);
-
-			if (nbytes < 4)
-			{
-				if (mem_ap_write_buf_u16(swjdp, buffer,
-						nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes >> 1;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i < nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
-					outvalue >>= 8;
-					address++;
-				}
-
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes >> 1;
-			writecount -= nbytes >> 1;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		uint16_t svalue;
-		memcpy(&svalue, buffer, sizeof(uint16_t));
-		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count -= 2;
-		address += 2;
-		buffer += 2;
-	}
-
-	return retval;
-}
-
-static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-	int wcount, blocksize, writecount, i;
-
-	wcount = count;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		writecount = blocksize;
-
-		do
-		{
-			nbytes = MIN(writecount, 4);
-
-			if (nbytes < 4)
-			{
-				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-
-				address += nbytes;
-			}
-			else
-			{
-				uint32_t outvalue;
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-
-				for (i = 0; i < nbytes; i++)
-				{
-					*((uint8_t*)buffer + (address & 0x3)) = outvalue;
-					outvalue >>= 8;
-					address++;
-				}
-
-				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
-						AP_REG_DRW, outvalue);
-				if (retval != ERROR_OK)
-					break;
-
-				if (dap_run(swjdp) != ERROR_OK)
-				{
-					LOG_WARNING("Block write error address "
-						"0x%" PRIx32 ", count 0x%x",
-						address, count);
-					/* REVISIT return *actual* fault code */
-					return ERROR_JTAG_DEVICE_ERROR;
-				}
-			}
-
-			buffer += nbytes;
-			writecount -= nbytes;
-
-		} while (writecount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
-{
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/* FIXME don't import ... this is a temporary workaround for the
- * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
- */
-extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
-
-/**
- * Synchronously read a block of 32-bit words into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the words will be stored (in host byte order).
- * @param count How many words to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
-	uint32_t adr = address;
-	uint8_t* pBuffer = buffer;
-
-	count >>= 2;
-	wcount = count;
-
-	while (wcount > 0)
-	{
-		/* Adjust to read blocks within boundaries aligned to the
-		 * TAR autoincrement size (at least 2^10).  Autoincrement
-		 * mode avoids an extra per-word roundtrip to update TAR.
-		 */
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block,
-				address);
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
-				address);
-
-		/* FIXME remove these three calls to adi_jtag_dp_scan(),
-		 * so this routine becomes transport-neutral.  Be careful
-		 * not to cause performance problems with JTAG; would it
-		 * suffice to loop over dap_queue_ap_read(), or would that
-		 * be slower when JTAG is the chosen transport?
-		 */
-
-		/* Scan out first read */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-				DPAP_READ, 0, NULL, NULL);
-		for (readcount = 0; readcount < blocksize - 1; readcount++)
-		{
-			/* Scan out next read; scan in posted value for the
-			 * previous one.  Assumes read is acked "OK/FAULT",
-			 * and CTRL_STAT says that meant "OK".
-			 */
-			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
-					DPAP_READ, 0, buffer + 4 * readcount,
-					&swjdp->ack);
-		}
-
-		/* Scan in last posted value; RDBUFF has no other effect,
-		 * assuming ack is OK/FAULT and CTRL_STAT says "OK".
-		 */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
-				DPAP_READ, 0, buffer + 4 * readcount,
-				&swjdp->ack);
-		if (dap_run(swjdp) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address += 4 * blocksize;
-			buffer += 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
-
-		if (errorcount > 1)
-		{
-			LOG_WARNING("Block read error address 0x%" PRIx32
-				", count 0x%x", address, count);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
-		}
-	}
-
-	/* if we have an unaligned access - reorder data */
-	if (adr & 0x3u)
-	{
-		for (readcount = 0; readcount < count; readcount++)
-		{
-			int i;
-			uint32_t data;
-			memcpy(&data, pBuffer, sizeof(uint32_t));
-
-			for (i = 0; i < 4; i++)
-			{
-				*((uint8_t*)pBuffer) =
-						(data >> 8 * (adr & 0x3));
-				pBuffer++;
-				adr++;
-			}
-		}
-	}
-
-	return retval;
-}
-
-static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count >> 1;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-
-		/* handle unaligned data at 4k boundary */
-		if (blocksize == 0)
-			blocksize = 1;
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN((readcount << 1), 4);
-
-			for (i = 0; i < nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= (nbytes >> 1);
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of 16-bit halfwords into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the halfwords will be stored (in host byte order).
- * @param count How many halfwords to read.
- * @param address Memory address from which to read words; all the
- *	words must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue, i;
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-		if (retval != ERROR_OK)
-			break;
-
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		if (address & 0x1)
-		{
-			for (i = 0; i < 2; i++)
-			{
-				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-				buffer++;
-				address++;
-			}
-		}
-		else
-		{
-			uint16_t svalue = (invalue >> 8 * (address & 0x3));
-			memcpy(buffer, &svalue, sizeof(uint16_t));
-			address += 2;
-			buffer += 2;
-		}
-		count -= 2;
-	}
-
-	return retval;
-}
-
-/* FIX!!! is this a potential performance bottleneck w.r.t. requiring too many
- * roundtrips when jtag_execute_queue() has a large overhead(e.g. for USB)s?
- *
- * The solution is to arrange for a large out/in scan in this loop and
- * and convert data afterwards.
- */
-static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
-		uint8_t *buffer, int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-	int wcount, blocksize, readcount, i;
-
-	wcount = count;
-
-	while (wcount > 0)
-	{
-		int nbytes;
-
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
-
-		if (wcount < blocksize)
-			blocksize = wcount;
-
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
-		readcount = blocksize;
-
-		do
-		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-			if (dap_run(swjdp) != ERROR_OK)
-			{
-				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
-				/* REVISIT return the *actual* fault code */
-				return ERROR_JTAG_DEVICE_ERROR;
-			}
-
-			nbytes = MIN(readcount, 4);
-
-			for (i = 0; i < nbytes; i++)
-			{
-				*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-				buffer++;
-				address++;
-			}
-
-			readcount -= nbytes;
-		} while (readcount);
-		wcount -= blocksize;
-	}
-
-	return retval;
-}
-
-/**
- * Synchronously read a block of bytes into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
- * @param buffer where the bytes will be stored.
- * @param count How many bytes to read.
- * @param address Memory address from which to read data; all the
- *	data must be readable by the currently selected MEM-AP.
- */
-int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
-		int count, uint32_t address)
-{
-	uint32_t invalue;
-	int retval = ERROR_OK;
-
-	if (count >= 4)
-		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
-
-	while (count > 0)
-	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			break;
-
-		*((uint8_t*)buffer) = (invalue >> 8 * (address & 0x3));
-		count--;
-		address++;
-		buffer++;
-	}
-
-	return retval;
-}
-
-/*--------------------------------------------------------------------------*/
-
-<<<<<<< HEAD:src/target/arm_adi_v5.c
-=======
-static int jtag_idcode_q_read(struct adiv5_dap *dap,
-		uint8_t *ack, uint32_t *data)
-{
-	struct arm_jtag *jtag_info = dap->jtag_info;
-	int retval;
-	struct scan_field fields[1];
-
-	jtag_set_end_state(TAP_IDLE);
-
-	/* This is a standard JTAG operation -- no DAP tweakage */
-	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	fields[0].num_bits = 32;
-	fields[0].out_value = NULL;
-	fields[0].in_value = (void *) data;
-
-	jtag_add_dr_scan(jtag_info->tap, 1, fields, TAP_IDLE);
-	retval = jtag_get_error();
-	if (retval != ERROR_OK)
-		return retval;
-
-	jtag_add_callback(arm_le_to_h_u32,
-			(jtag_callback_data_t) data);
-
-	return retval;
-}
-
-static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_READ, 0, data);
-}
-
-static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			reg, DPAP_WRITE, data, NULL);
-}
-
-/** Select the AP register bank matching bits 7:4 of reg. */
-static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
-{
-	uint32_t select = reg & 0x000000F0;
-
-	if (select == dap->ap_bank_value)
-		return ERROR_OK;
-	dap->ap_bank_value = select;
-
-	select |= dap->apsel;
-
-	return jtag_dp_q_write(dap, DP_SELECT, select);
-}
-
-static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
-		uint32_t *data)
-{
-	int retval = jtag_ap_q_bankselect(dap, reg);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	return adi_jtag_scan_inout_check_u32(dap, JTAG_DP_APACC, reg,
-			DPAP_READ, 0, data);
-}
-
-static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
-		uint32_t data)
-{
-	uint8_t out_value_buf[4];
-
-	int retval = jtag_ap_q_bankselect(dap, reg);
-	if (retval != ERROR_OK)
-		return retval;
->>>>>>> jtag: cut down on usage of unintended modification of global end state:src/target/arm_adi_v5.c
-
-/* FIXME don't import ... just initialize as
- * part of DAP transport setup
-*/
-extern const struct dap_ops jtag_dp_ops;
-
-/*--------------------------------------------------------------------------*/
-
-/**
- * Initialize a DAP.  This sets up the power domains, prepares the DP
- * for further use, and arranges to use AP #0 for all AP operations
- * until dap_ap-select() changes that policy.
- *
- * @param swjdp The DAP being initialized.
- *
- * @todo Rename this.  We also need an initialization scheme which account
- * for SWD transports not just JTAG; that will need to address differences
- * in layering.  (JTAG is useful without any debug target; but not SWD.)
- * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
- */
-int ahbap_debugport_init(struct adiv5_dap *swjdp)
-{
-	uint32_t idreg, romaddr, dummy;
-	uint32_t ctrlstat;
-	int cnt = 0;
-	int retval;
-
-	LOG_DEBUG(" ");
-
-	/* JTAG-DP or SWJ-DP, in JTAG mode */
-	swjdp->ops = &jtag_dp_ops;
-
-	/* Default MEM-AP setup.
-	 *
-	 * REVISIT AP #0 may be an inappropriate default for this.
-	 * Should we probe, or take a hint from the caller?
-	 * Presumably we can ignore the possibility of multiple APs.
-	 */
-	swjdp->apsel = !0;
-	dap_ap_select(swjdp, 0);
-
-	/* DP initialization */
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
-	if (retval != ERROR_OK)
-		return retval;
-	if ((retval = dap_run(swjdp)) != ERROR_OK)
-		return retval;
-
-	/* Check that we have debug power domains activated */
-	while (!(ctrlstat & CDBGPWRUPACK) && (cnt++ < 10))
-	{
-		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	while (!(ctrlstat & CSYSPWRUPACK) && (cnt++ < 10))
-	{
-		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
-		if (retval != ERROR_OK)
-			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
-			return retval;
-		alive_sleep(10);
-	}
-
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-	/* With debug power on we can activate OVERRUN checking */
-	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/*
-	 * REVISIT this isn't actually *initializing* anything in an AP,
-	 * and doesn't care if it's a MEM-AP at all (much less AHB-AP).
-	 * Should it?  If the ROM address is valid, is this the right
-	 * place to scan the table and do any topology detection?
-	 */
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &idreg);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &romaddr);
-
-	LOG_DEBUG("MEM-AP #%d ID Register 0x%" PRIx32
-		", Debug ROM Address 0x%" PRIx32,
-		swjdp->apsel, idreg, romaddr);
-
-	return ERROR_OK;
-}
-
-/* CID interpretation -- see ARM IHI 0029B section 3
- * and ARM IHI 0031A table 13-3.
- */
-static const char *class_description[16] ={
-	"Reserved", "ROM table", "Reserved", "Reserved",
-	"Reserved", "Reserved", "Reserved", "Reserved",
-	"Reserved", "CoreSight component", "Reserved", "Peripheral Test Block",
-	"Reserved", "OptimoDE DESS",
-		"Generic IP component", "PrimeCell or System component"
-};
-
-static bool
-is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
-{
-	return cid3 == 0xb1 && cid2 == 0x05
-			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
-}
-
-static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *swjdp, int apsel)
-{
-	int retval;
-	uint32_t dbgbase, apid;
-	int romtable_present = 0;
-	uint8_t mem_ap;
-	uint32_t apselold;
-
-	/* AP address is in bits 31:24 of DP_SELECT */
-	if (apsel >= 256)
-		return ERROR_INVALID_ARGUMENTS;
-
-	apselold = swjdp->apsel;
-	dap_ap_select(swjdp, apsel);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &dbgbase);
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
-	retval = dap_run(swjdp);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-	mem_ap = ((apid&0x10000) && ((apid&0x0F) != 0));
-	command_print(cmd_ctx, "AP ID register 0x%8.8" PRIx32, apid);
-	if (apid)
-	{
-		switch (apid&0x0F)
-		{
-			case 0:
-				command_print(cmd_ctx, "\tType is JTAG-AP");
-				break;
-			case 1:
-				command_print(cmd_ctx, "\tType is MEM-AP AHB");
-				break;
-			case 2:
-				command_print(cmd_ctx, "\tType is MEM-AP APB");
-				break;
-			default:
-				command_print(cmd_ctx, "\tUnknown AP type");
-				break;
-		}
-
-		/* NOTE: a MEM-AP may have a single CoreSight component that's
-		 * not a ROM table ... or have no such components at all.
-		 */
-		if (mem_ap)
-			command_print(cmd_ctx, "AP BASE 0x%8.8" PRIx32,
-					dbgbase);
-	}
-	else
-	{
-		command_print(cmd_ctx, "No AP found at this apsel 0x%x", apsel);
-	}
-
-	romtable_present = ((mem_ap) && (dbgbase != 0xFFFFFFFF));
-	if (romtable_present)
-	{
-		uint32_t cid0,cid1,cid2,cid3,memtype,romentry;
-		uint16_t entry_offset;
-
-		/* bit 16 of apid indicates a memory access port */
-		if (dbgbase & 0x02)
-			command_print(cmd_ctx, "\tValid ROM table present");
-		else
-			command_print(cmd_ctx, "\tROM table in legacy format");
-
-		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
-		retval = dap_run(swjdp);
-		if (retval != ERROR_OK)
-			return retval;
-
-		if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-			command_print(cmd_ctx, "\tCID3 0x%2.2" PRIx32
-					", CID2 0x%2.2" PRIx32
-					", CID1 0x%2.2" PRIx32
-					", CID0 0x%2.2" PRIx32,
-					cid3, cid2, cid1, cid0);
-		if (memtype & 0x01)
-			command_print(cmd_ctx, "\tMEMTYPE system memory present on bus");
-		else
-			command_print(cmd_ctx, "\tMEMTYPE System memory not present. "
-					"Dedicated debug bus.");
-
-		/* Now we read ROM table entries from dbgbase&0xFFFFF000) | 0x000 until we get 0x00000000 */
-		entry_offset = 0;
-		do
-		{
-			mem_ap_read_atomic_u32(swjdp, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
-			command_print(cmd_ctx, "\tROMTABLE[0x%x] = 0x%" PRIx32 "",entry_offset,romentry);
-			if (romentry&0x01)
-			{
-				uint32_t c_cid0, c_cid1, c_cid2, c_cid3;
-				uint32_t c_pid0, c_pid1, c_pid2, c_pid3, c_pid4;
-				uint32_t component_start, component_base;
-				unsigned part_num;
-				char *type, *full;
-
-				component_base = (uint32_t)((dbgbase & 0xFFFFF000)
-						+ (int)(romentry & 0xFFFFF000));
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFE0, &c_pid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFE4, &c_pid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFE8, &c_pid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFEC, &c_pid3);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFD0, &c_pid4);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFF0, &c_cid0);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFF4, &c_cid1);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFF8, &c_cid2);
-				mem_ap_read_atomic_u32(swjdp,
-						(component_base & 0xFFFFF000) | 0xFFC, &c_cid3);
-				component_start = component_base - 0x1000*(c_pid4 >> 4);
-
-				command_print(cmd_ctx, "\t\tComponent base address 0x%" PRIx32
-						", start address 0x%" PRIx32,
-						component_base, component_start);
-				command_print(cmd_ctx, "\t\tComponent class is 0x%x, %s",
-						(int) (c_cid1 >> 4) & 0xf,
-						/* See ARM IHI 0029B Table 3-3 */
-						class_description[(c_cid1 >> 4) & 0xf]);
-
-				/* CoreSight component? */
-				if (((c_cid1 >> 4) & 0x0f) == 9) {
-					uint32_t devtype;
-					unsigned minor;
-					char *major = "Reserved", *subtype = "Reserved";
-
-					mem_ap_read_atomic_u32(swjdp,
-							(component_base & 0xfffff000) | 0xfcc,
-							&devtype);
-					minor = (devtype >> 4) & 0x0f;
-					switch (devtype & 0x0f) {
-					case 0:
-						major = "Miscellaneous";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 4:
-							subtype = "Validation component";
-							break;
-						}
-						break;
-					case 1:
-						major = "Trace Sink";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Port";
-							break;
-						case 2:
-							subtype = "Buffer";
-							break;
-						}
-						break;
-					case 2:
-						major = "Trace Link";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Funnel, router";
-							break;
-						case 2:
-							subtype = "Filter";
-							break;
-						case 3:
-							subtype = "FIFO, buffer";
-							break;
-						}
-						break;
-					case 3:
-						major = "Trace Source";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Processor";
-							break;
-						case 2:
-							subtype = "DSP";
-							break;
-						case 3:
-							subtype = "Engine/Coprocessor";
-							break;
-						case 4:
-							subtype = "Bus";
-							break;
-						}
-						break;
-					case 4:
-						major = "Debug Control";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Trigger Matrix";
-							break;
-						case 2:
-							subtype = "Debug Auth";
-							break;
-						}
-						break;
-					case 5:
-						major = "Debug Logic";
-						switch (minor) {
-						case 0:
-							subtype = "other";
-							break;
-						case 1:
-							subtype = "Processor";
-							break;
-						case 2:
-							subtype = "DSP";
-							break;
-						case 3:
-							subtype = "Engine/Coprocessor";
-							break;
-						}
-						break;
-					}
-					command_print(cmd_ctx, "\t\tType is 0x%2.2x, %s, %s",
-							(unsigned) (devtype & 0xff),
-							major, subtype);
-					/* REVISIT also show 0xfc8 DevId */
-				}
-
-				if (!is_dap_cid_ok(cid3, cid2, cid1, cid0))
-					command_print(cmd_ctx, "\t\tCID3 0x%2.2" PRIx32
-							", CID2 0x%2.2" PRIx32
-							", CID1 0x%2.2" PRIx32
-							", CID0 0x%2.2" PRIx32,
-							c_cid3, c_cid2, c_cid1, c_cid0);
-				command_print(cmd_ctx, "\t\tPeripheral ID[4..0] = hex "
-						"%2.2x %2.2x %2.2x %2.2x %2.2x",
-						(int) c_pid4,
-						(int) c_pid3, (int) c_pid2,
-						(int) c_pid1, (int) c_pid0);
-
-				/* Part number interpretations are from Cortex
-				 * core specs, the CoreSight components TRM
-				 * (ARM DDI 0314H), and ETM specs; also from
-				 * chip observation (e.g. TI SDTI).
-				 */
-				part_num = c_pid0 & 0xff;
-				part_num |= (c_pid1 & 0x0f) << 8;
-				switch (part_num) {
-				case 0x000:
-					type = "Cortex-M3 NVIC";
-					full = "(Interrupt Controller)";
-					break;
-				case 0x001:
-					type = "Cortex-M3 ITM";
-					full = "(Instrumentation Trace Module)";
-					break;
-				case 0x002:
-					type = "Cortex-M3 DWT";
-					full = "(Data Watchpoint and Trace)";
-					break;
-				case 0x003:
-					type = "Cortex-M3 FBP";
-					full = "(Flash Patch and Breakpoint)";
-					break;
-				case 0x00d:
-					type = "CoreSight ETM11";
-					full = "(Embedded Trace)";
-					break;
-				// case 0x113: what?
-				case 0x120:		/* from OMAP3 memmap */
-					type = "TI SDTI";
-					full = "(System Debug Trace Interface)";
-					break;
-				case 0x343:		/* from OMAP3 memmap */
-					type = "TI DAPCTL";
-					full = "";
-					break;
-				case 0x906:
-					type = "Coresight CTI";
-					full = "(Cross Trigger)";
-					break;
-				case 0x907:
-					type = "Coresight ETB";
-					full = "(Trace Buffer)";
-					break;
-				case 0x908:
-					type = "Coresight CSTF";
-					full = "(Trace Funnel)";
-					break;
-				case 0x910:
-					type = "CoreSight ETM9";
-					full = "(Embedded Trace)";
-					break;
-				case 0x912:
-					type = "Coresight TPIU";
-					full = "(Trace Port Interface Unit)";
-					break;
-				case 0x921:
-					type = "Cortex-A8 ETM";
-					full = "(Embedded Trace)";
-					break;
-				case 0x922:
-					type = "Cortex-A8 CTI";
-					full = "(Cross Trigger)";
-					break;
-				case 0x923:
-					type = "Cortex-M3 TPIU";
-					full = "(Trace Port Interface Unit)";
-					break;
-				case 0x924:
-					type = "Cortex-M3 ETM";
-					full = "(Embedded Trace)";
-					break;
-				case 0xc08:
-					type = "Cortex-A8 Debug";
-					full = "(Debug Unit)";
-					break;
-				default:
-					type = "-*- unrecognized -*-";
-					full = "";
-					break;
-				}
-				command_print(cmd_ctx, "\t\tPart is %s %s",
-						type, full);
-			}
-			else
-			{
-				if (romentry)
-					command_print(cmd_ctx, "\t\tComponent not present");
-				else
-					command_print(cmd_ctx, "\t\tEnd of ROM table");
-			}
-			entry_offset += 4;
-		} while (romentry > 0);
-	}
-	else
-	{
-		command_print(cmd_ctx, "\tNo ROM table present");
-	}
-	dap_ap_select(swjdp, apselold);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_dap_info_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-	uint32_t apsel;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	return dap_info_command(CMD_CTX, dap, apsel);
-}
-
-COMMAND_HANDLER(dap_baseaddr_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t apsel, apselsave, baseaddr;
-	int retval;
-
-	apselsave = dap->apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	/* NOTE:  assumes we're talking to a MEM-AP, which
-	 * has a base address.  There are other kinds of AP,
-	 * though they're not common for now.  This should
-	 * use the ID register to verify it's a MEM-AP.
-	 */
-	retval = dap_queue_ap_read(dap, AP_REG_BASE, &baseaddr);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, "0x%8.8" PRIx32, baseaddr);
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_memaccess_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t memaccess_tck;
-
-	switch (CMD_ARGC) {
-	case 0:
-		memaccess_tck = dap->memaccess_tck;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-	dap->memaccess_tck = memaccess_tck;
-
-	command_print(CMD_CTX, "memory bus access delay set to %" PRIi32 " tck",
-			dap->memaccess_tck);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(dap_apsel_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t apsel, apid;
-	int retval;
-
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = 0;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	dap_ap_select(dap, apsel);
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, "ap %" PRIi32 " selected, identification register 0x%8.8" PRIx32,
-			apsel, apid);
-
-	return retval;
-}
-
-COMMAND_HANDLER(dap_apid_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t apsel, apselsave, apid;
-	int retval;
-
-	apselsave = dap->apsel;
-	switch (CMD_ARGC) {
-	case 0:
-		apsel = dap->apsel;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
-			return ERROR_INVALID_ARGUMENTS;
-		break;
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
-
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	command_print(CMD_CTX, "0x%8.8" PRIx32, apid);
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
-	return retval;
-}
-
-static const struct command_registration dap_commands[] = {
-	{
-		.name = "info",
-		.handler = handle_dap_info_command,
-		.mode = COMMAND_EXEC,
-		.help = "display ROM table for MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apsel",
-		.handler = dap_apsel_command,
-		.mode = COMMAND_EXEC,
-		.help = "Set the currently selected AP (default 0) "
-			"and display the result",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "apid",
-		.handler = dap_apid_command,
-		.mode = COMMAND_EXEC,
-		.help = "return ID register from AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "baseaddr",
-		.handler = dap_baseaddr_command,
-		.mode = COMMAND_EXEC,
-		.help = "return debug base address from MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
-	},
-	{
-		.name = "memaccess",
-		.handler = dap_memaccess_command,
-		.mode = COMMAND_EXEC,
-		.help = "set/get number of extra tck for MEM-AP memory "
-			"bus access [0-255]",
-		.usage = "[cycles]",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-const struct command_registration dap_command_handlers[] = {
-	{
-		.name = "dap",
-		.mode = COMMAND_EXEC,
-		.help = "DAP command group",
-		.chain = dap_commands,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-
-/*
- * This represents the bits which must be sent out on TMS/SWDIO to
- * switch a DAP implemented using an SWJ-DP module into SWD mode.
- * These bits are stored (and transmitted) LSB-first.
- *
- * See the DAP-Lite specification, section 2.2.5 for information
- * about making the debug link select SWD or JTAG.  (Similar info
- * is in a few other ARM documents.)
- */
-static const uint8_t jtag2swd_bitseq[] = {
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	/* Switching sequence enables SWD and disables JTAG
-	 * NOTE: bits in the DP's IDCODE may expose the need for
-	 * an old/deprecated sequence (0xb6 0xed).
-	 */
-	0x9e, 0xe7,
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-};
-
-/**
- * Put the debug link into SWD mode, if the target supports it.
- * The link's initial mode may be either JTAG (for example,
- * with SWJ-DP after reset) or SWD.
- *
- * @param target Enters SWD mode (if possible).
- *
- * Note that targets using the JTAG-DP do not support SWD, and that
- * some targets which could otherwise support it may have have been
- * configured to disable SWD signaling
- *
- * @return ERROR_OK or else a fault code.
- */
-int dap_to_swd(struct target *target)
-{
-	int retval;
-
-	LOG_DEBUG("Enter SWD mode");
-
-	/* REVISIT it's nasty to need to make calls to a "jtag"
-	 * subsystem if the link isn't in JTAG mode...
-	 */
-
-	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
-			jtag2swd_bitseq, TAP_INVALID);
-	if (retval == ERROR_OK)
-		retval = jtag_execute_queue();
-
-	/* REVISIT set up the DAP's ops vector for SWD mode. */
-
-	return retval;
-}
-

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c.orig | 1981 ------------------------------------------
 src/target/arm_adi_v5.c~     | 1981 ------------------------------------------
 2 files changed, 0 insertions(+), 3962 deletions(-)
 delete mode 100644 src/target/arm_adi_v5.c.orig
 delete mode 100644 src/target/arm_adi_v5.c~


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Mar 18 11:58:17 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 18 Mar 2010 10:58:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-107-gd37ed90
Message-ID: <E1NsDQh-0001uw-Bl@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d37ed9094a62ec144b9d9fdc214d8c7723caadec (commit)
       via  ae1c64706a6fa421b60884e23561f39016950f54 (commit)
       via  b48a94f05da3a887f1978da01db77b79513d4aa9 (commit)
      from  36df240cea04990e8c18aa0b90bd63374f22dbd3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d37ed9094a62ec144b9d9fdc214d8c7723caadec
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Mar 18 09:18:53 2010 +0000

    DOCS: update flash bank examples
    
     - include the $_FLASHNAME in all flash bank examples.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index da2782b..83a6369 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4180,8 +4180,8 @@ To configure two adjacent banks of 16 MBytes each, both sixteen bits (two bytes)
 wide on a sixteen bit bus:
 
 @example
-flash bank cfi 0x00000000 0x01000000 2 2 $_TARGETNAME
-flash bank cfi 0x01000000 0x01000000 2 2 $_TARGETNAME
+flash bank $_FLASHNAME cfi 0x00000000 0x01000000 2 2 $_TARGETNAME
+flash bank $_FLASHNAME cfi 0x01000000 0x01000000 2 2 $_TARGETNAME
 @end example
 
 To configure one bank of 32 MBytes
@@ -4189,7 +4189,7 @@ built from two sixteen bit (two byte) wide parts wired in parallel
 to create a thirty-two bit (four byte) bus with doubled throughput:
 
 @example
-flash bank cfi 0x00000000 0x02000000 2 4 $_TARGETNAME
+flash bank $_FLASHNAME cfi 0x00000000 0x02000000 2 4 $_TARGETNAME
 @end example
 
 @c "cfi part_id" disabled
@@ -4205,7 +4205,7 @@ The setup command only requires the @var{target} argument
 since all devices in this family have the same memory layout.
 
 @example
-flash bank aduc702x 0 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME aduc702x 0 0 0 0 $_TARGETNAME
 @end example
 @end deffn
 
@@ -4226,9 +4226,9 @@ the following fixed locations:
 
 @example
 # Flash bank 0 - all chips
-flash bank at91sam3 0x00080000 0 1 1 $_TARGETNAME
+flash bank $_FLASHNAME at91sam3 0x00080000 0 1 1 $_TARGETNAME
 # Flash bank 1 - only 256K chips
-flash bank at91sam3 0x00100000 0 1 1 $_TARGETNAME
+flash bank $_FLASHNAME at91sam3 0x00100000 0 1 1 $_TARGETNAME
 @end example
 
 Internally, the AT91SAM3 flash memory is organized as follows.
@@ -4280,7 +4280,7 @@ recognizes a number of these chips using the chip identification
 register, and autoconfigures itself.
 
 @example
-flash bank at91sam7 0 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME
 @end example
 
 For chips which are not recognized by the controller driver, you must
@@ -4367,7 +4367,7 @@ with most tool chains @command{verify_image} will fail.
 LPC flashes don't require the chip and bus width to be specified.
 
 @example
-flash bank lpc2000 0x0 0x7d000 0 0 $_TARGETNAME \
+flash bank $_FLASHNAME lpc2000 0x0 0x7d000 0 0 $_TARGETNAME \
       lpc2000_v2 14765 calc_checksum
 @end example
 
@@ -4385,7 +4385,7 @@ the programming clock rate in Hz.
 LPC flashes don't require the chip and bus width to be specified.
 
 @example
-flash bank lpc288x 0 0 0 0 $_TARGETNAME 12000000
+flash bank $_FLASHNAME lpc288x 0 0 0 0 $_TARGETNAME 12000000
 @end example
 @end deffn
 
@@ -4418,7 +4418,7 @@ and not by the standard @code{flash protect} command.
 
 Example for a 125 MHz clock frequency:
 @example
-flash bank lpc2900 0 0 0 0 $_TARGETNAME 125000
+flash bank $_FLASHNAME lpc2900 0 0 0 0 $_TARGETNAME 125000
 @end example
 
 Some @code{lpc2900}-specific commands are defined. In the following command list,
@@ -4516,7 +4516,7 @@ lpc2900 secure_jtag 0
 @emph{No idea what this is, other than using some arm7/arm9 core.}
 
 @example
-flash bank ocl 0 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME ocl 0 0 0 0 $_TARGETNAME
 @end example
 @end deffn
 
@@ -4525,8 +4525,8 @@ The PIC32MX microcontrollers are based on the MIPS 4K cores,
 and integrate flash memory.
 
 @example
-flash bank pix32mx 0x1fc00000 0 0 0 $_TARGETNAME
-flash bank pix32mx 0x1d000000 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME pix32mx 0x1fc00000 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME pix32mx 0x1d000000 0 0 0 $_TARGETNAME
 @end example
 
 @comment numerous *disabled* commands are defined:
@@ -4555,7 +4555,7 @@ That seems pointless since the same effect can be had using the
 standard @command{flash erase_address} command.}
 
 @example
-flash bank stellaris 0 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME stellaris 0 0 0 0 $_TARGETNAME
 @end example
 @end deffn
 
@@ -4581,7 +4581,7 @@ The driver automatically recognizes a number of these chips using
 the chip identification register, and autoconfigures itself.
 
 @example
-flash bank stm32x 0 0 0 0 $_TARGETNAME
+flash bank $_FLASHNAME stm32x 0 0 0 0 $_TARGETNAME
 @end example
 
 Some stm32x-specific commands
@@ -4619,7 +4619,7 @@ The @var{str7x} driver defines one mandatory parameter, @var{variant},
 which is either @code{STR71x}, @code{STR73x} or @code{STR75x}.
 
 @example
-flash bank str7x 0x40000000 0x00040000 0 0 $_TARGETNAME STR71x
+flash bank $_FLASHNAME str7x 0x40000000 0x00040000 0 0 $_TARGETNAME STR71x
 @end example
 
 @deffn Command {str7x disable_jtag} bank
@@ -4635,7 +4635,7 @@ The str9 needs the flash controller to be configured using
 the @command{str9x flash_config} command prior to Flash programming.
 
 @example
-flash bank str9x 0x40000000 0x00040000 0 0 $_TARGETNAME
+flash bank $_FLASHNAME str9x 0x40000000 0x00040000 0 0 $_TARGETNAME
 str9x flash_config 0 4 2 0 0x80000
 @end example
 
@@ -4785,13 +4785,13 @@ Currently, the mflash driver supports s3c2440 and pxa270.
 Example for s3c2440 mflash where @var{RST pin} is GPIO B1:
 
 @example
-mflash bank s3c2440 0x10000000 1b 0
+mflash bank $_FLASHNAME s3c2440 0x10000000 1b 0
 @end example
 
 Example for pxa270 mflash where @var{RST pin} is GPIO 43:
 
 @example
-mflash bank pxa270 0x08000000 43 0
+mflash bank $_FLASHNAME pxa270 0x08000000 43 0
 @end example
 @end deffn
 
@@ -7406,8 +7406,8 @@ has closed the connection to OpenOCD. This might be a GDB issue.
 
 @item @b{LPC2000 Flash} In the configuration file in the section where flash device configurations
 are described, there is a parameter for specifying the clock frequency
-for LPC2000 internal flash devices (e.g.  @option{flash bank lpc2000
-0x0 0x40000 0 0 0 lpc2000_v1 14746 calc_checksum}), which must be
+for LPC2000 internal flash devices (e.g.  @option{flash bank $_FLASHNAME lpc2000
+0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14746 calc_checksum}), which must be
 specified in kilohertz. However, I do have a quartz crystal of a
 frequency that contains fractions of kilohertz (e.g. 14,745,600 Hz,
 i.e. 14,745.600 kHz).  Is it possible to specify real numbers for the

commit ae1c64706a6fa421b60884e23561f39016950f54
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Mar 18 09:35:45 2010 +0000

    PIC32MX: add unlock cmd
    
    'unlock' performs a full unlock/erase of the device, removing any
    code protection.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 98fc690..da2782b 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4523,10 +4523,10 @@ flash bank ocl 0 0 0 0 $_TARGETNAME
 @deffn {Flash Driver} pic32mx
 The PIC32MX microcontrollers are based on the MIPS 4K cores,
 and integrate flash memory.
- at emph{The current implementation is incomplete.}
 
 @example
-flash bank pix32mx 0 0 0 0 $_TARGETNAME
+flash bank pix32mx 0x1fc00000 0 0 0 $_TARGETNAME
+flash bank pix32mx 0x1d000000 0 0 0 $_TARGETNAME
 @end example
 
 @comment numerous *disabled* commands are defined:
@@ -4538,6 +4538,10 @@ Some pic32mx-specific commands are defined:
 Programs the specified 32-bit @var{value} at the given @var{address}
 in the specified chip @var{bank}.
 @end deffn
+ at deffn Command {pic32mx unlock} bank
+Unlock and erase specified chip @var{bank}.
+This will remove any Code Protection.
+ at end deffn
 @end deffn
 
 @deffn {Flash Driver} stellaris
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index c46264c..36744e6 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -31,6 +31,7 @@
 #include "pic32mx.h"
 #include <target/algorithm.h>
 #include <target/mips32.h>
+#include <target/mips_m4k.h>
 
 static const struct pic32mx_devs_s {
 	uint8_t	devid;
@@ -664,6 +665,73 @@ COMMAND_HANDLER(pic32mx_handle_pgm_word_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(pic32mx_handle_unlock_command)
+{
+	uint32_t mchip_cmd;
+	struct target *target = NULL;
+	struct mips_m4k_common *mips_m4k;
+	struct mips_ejtag *ejtag_info;
+	int timeout = 10;
+
+	if (CMD_ARGC < 1)
+	{
+		command_print(CMD_CTX, "pic32mx unlock <bank>");
+		return ERROR_OK;
+	}
+
+	struct flash_bank *bank;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (ERROR_OK != retval)
+		return retval;
+
+	target = bank->target;
+	mips_m4k = target_to_m4k(target);
+	ejtag_info = &mips_m4k->mips32.ejtag_info;
+
+	/* we have to use the MTAP to perform a full erase */
+	mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP);
+	mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND);
+
+	/* first check status of device */
+	mchip_cmd = MCHP_STATUS;
+	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+	if (mchip_cmd & (1 << 7))
+	{
+		/* device is not locked */
+		command_print(CMD_CTX, "pic32mx is already unlocked, erasing anyway");
+	}
+
+	/* unlock/erase device */
+	mchip_cmd = MCHP_ASERT_RST;
+	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+
+	mchip_cmd = MCHP_ERASE;
+	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+
+	do {
+		mchip_cmd = MCHP_STATUS;
+		mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+		if (timeout-- == 0)
+		{
+			LOG_DEBUG("timeout waiting for unlock: 0x%" PRIx32 "", mchip_cmd);
+			break;
+		}
+		alive_sleep(1);
+	} while ((mchip_cmd & (1 << 2)) || (!(mchip_cmd & (1 << 3))));
+
+	mchip_cmd = MCHP_DE_ASSERT_RST;
+	mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
+
+	/* select ejtag tap */
+	mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
+
+	command_print(CMD_CTX, "pic32mx unlocked.\n"
+			"INFO: a reset or power cycle is required "
+			"for the new settings to take effect.");
+
+	return ERROR_OK;
+}
+
 static const struct command_registration pic32mx_exec_command_handlers[] = {
 	{
 		.name = "pgm_word",
@@ -671,6 +739,13 @@ static const struct command_registration pic32mx_exec_command_handlers[] = {
 		.mode = COMMAND_EXEC,
 		.help = "program a word",
 	},
+	{
+		.name = "unlock",
+		.handler = pic32mx_handle_unlock_command,
+		.mode = COMMAND_EXEC,
+		.usage = "[bank_id]",
+		.help = "Unlock/Erase entire device.",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 164edd0..f302a70 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -48,6 +48,8 @@
 /* microchip specific cmds */
 #define MCHP_ASERT_RST			0xd1
 #define MCHP_DE_ASSERT_RST		0xd0
+#define MCHP_ERASE				0xfc
+#define MCHP_STATUS				0x00
 
 /* ejtag control register bits ECR */
 #define EJTAG_CTRL_TOF			(1 << 1)

commit b48a94f05da3a887f1978da01db77b79513d4aa9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Mar 17 17:24:22 2010 +0000

    MIPS: remove unused arg from mips_ejtag_set_instr
    
    This arg was never used and was just taken from the arm jtag code.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/mips32_dmaacc.c b/src/target/mips32_dmaacc.c
index aa36d2c..7d3c2da 100644
--- a/src/target/mips32_dmaacc.c
+++ b/src/target/mips32_dmaacc.c
@@ -49,11 +49,11 @@ begin_ejtag_dma_read:
 
 	/* Setup Address */
 	v = addr;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Initiate DMA Read & set DSTRT */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = EJTAG_CTRL_DMAACC | EJTAG_CTRL_DRWN | EJTAG_CTRL_DMA_WORD | EJTAG_CTRL_DSTRT | ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
@@ -64,11 +64,11 @@ begin_ejtag_dma_read:
 	} while (ejtag_ctrl & EJTAG_CTRL_DSTRT);
 
 	/* Read Data */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ejtag_info, data);
 
 	/* Clear DMA & Check DERR */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
@@ -95,11 +95,11 @@ begin_ejtag_dma_read_h:
 
 	/* Setup Address */
 	v = addr;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Initiate DMA Read & set DSTRT */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = EJTAG_CTRL_DMAACC | EJTAG_CTRL_DRWN | EJTAG_CTRL_DMA_HALFWORD | EJTAG_CTRL_DSTRT | ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
@@ -110,11 +110,11 @@ begin_ejtag_dma_read_h:
 	} while (ejtag_ctrl & EJTAG_CTRL_DSTRT);
 
 	/* Read Data */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Clear DMA & Check DERR */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
@@ -147,11 +147,11 @@ begin_ejtag_dma_read_b:
 
 	/* Setup Address */
 	v = addr;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Initiate DMA Read & set DSTRT */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = EJTAG_CTRL_DMAACC | EJTAG_CTRL_DRWN | EJTAG_CTRL_DMA_BYTE | EJTAG_CTRL_DSTRT | ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
@@ -162,11 +162,11 @@ begin_ejtag_dma_read_b:
 	} while (ejtag_ctrl & EJTAG_CTRL_DSTRT);
 
 	/* Read Data */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Clear DMA & Check DERR */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
@@ -209,16 +209,16 @@ begin_ejtag_dma_write:
 
 	/* Setup Address */
 	v = addr;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Setup Data */
 	v = data;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Initiate DMA Write & set DSTRT */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = EJTAG_CTRL_DMAACC | EJTAG_CTRL_DMA_WORD | EJTAG_CTRL_DSTRT | ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
@@ -229,7 +229,7 @@ begin_ejtag_dma_write:
 	} while (ejtag_ctrl & EJTAG_CTRL_DSTRT);
 
 	/* Clear DMA & Check DERR */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
@@ -260,16 +260,16 @@ begin_ejtag_dma_write_h:
 
 	/* Setup Address */
 	v = addr;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Setup Data */
 	v = data;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Initiate DMA Write & set DSTRT */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = EJTAG_CTRL_DMAACC | EJTAG_CTRL_DMA_HALFWORD | EJTAG_CTRL_DSTRT | ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
@@ -280,7 +280,7 @@ begin_ejtag_dma_write_h:
 	} while (ejtag_ctrl & EJTAG_CTRL_DSTRT);
 
 	/* Clear DMA & Check DERR */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	if (ejtag_ctrl  & EJTAG_CTRL_DERR)
@@ -312,16 +312,16 @@ begin_ejtag_dma_write_b:
 
 	/*  Setup Address*/
 	v = addr;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Setup Data */
 	v = data;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ejtag_info, &v);
 
 	/* Initiate DMA Write & set DSTRT */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = EJTAG_CTRL_DMAACC | EJTAG_CTRL_DMA_BYTE | EJTAG_CTRL_DSTRT | ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
@@ -332,7 +332,7 @@ begin_ejtag_dma_write_b:
 	} while (ejtag_ctrl & EJTAG_CTRL_DSTRT);
 
 	/* Clear DMA & Check DERR */
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	ejtag_ctrl = ejtag_info->ejtag_ctrl;
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	if (ejtag_ctrl & EJTAG_CTRL_DERR)
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index bcba0f1..19ba886 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -96,7 +96,7 @@ static int wait_for_pracc_rw(struct mips_ejtag *ejtag_info, uint32_t *ctrl)
 
 	while (1)
 	{
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 		ejtag_ctrl = ejtag_info->ejtag_ctrl;
 		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 		if (ejtag_ctrl & EJTAG_CTRL_PRACC)
@@ -149,12 +149,12 @@ static int mips32_pracc_exec_read(struct mips32_pracc_context *ctx, uint32_t add
 	}
 
 	/* Send the data out */
-	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ctx->ejtag_info, &data);
 
 	/* Clear the access pending bit (let the processor eat!) */
 	ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
-	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL);
 	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
 
 	jtag_add_clocks(5);
@@ -169,12 +169,12 @@ static int mips32_pracc_exec_write(struct mips32_pracc_context *ctx, uint32_t ad
 	int offset;
 	struct mips_ejtag *ejtag_info = ctx->ejtag_info;
 
-	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_DATA, NULL);
+	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_DATA);
 	mips_ejtag_drscan_32(ctx->ejtag_info, &data);
 
 	/* Clear access pending bit */
 	ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
-	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ctx->ejtag_info, EJTAG_INST_CONTROL);
 	mips_ejtag_drscan_32(ctx->ejtag_info, &ejtag_ctrl);
 
 	jtag_add_clocks(5);
@@ -230,7 +230,7 @@ int mips32_pracc_exec(struct mips_ejtag *ejtag_info, int code_len, const uint32_
 			return retval;
 
 		address = data = 0;
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 		mips_ejtag_drscan_32(ejtag_info, &address);
 
 		/* Check for read or write */
@@ -979,12 +979,12 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 		if ((retval = wait_for_pracc_rw(ejtag_info, &ejtag_ctrl)) != ERROR_OK)
 			return retval;
 
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA, NULL);
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_DATA);
 		mips_ejtag_drscan_32(ejtag_info, &jmp_code[i]);
 
 		/* Clear the access pending bit (let the processor eat!) */
 		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_PRACC;
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 	}
 
@@ -993,7 +993,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 
 	/* next fetch to dmseg should be in FASTDATA_AREA, check */
 	address = 0;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &address);
 
 	if (address != MIPS32_PRACC_FASTDATA_AREA)
@@ -1001,12 +1001,12 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 
 	/* Send the load start address */
 	val = addr;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FASTDATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FASTDATA);
 	mips_ejtag_fastdata_scan(ejtag_info, 1, &val);
 
 	/* Send the load end address */
 	val = addr + (count - 1) * 4;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FASTDATA, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_FASTDATA);
 	mips_ejtag_fastdata_scan(ejtag_info, 1, &val);
 
 	for (i = 0; i < count; i++)
@@ -1026,7 +1026,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 		return retval;
 
 	address = 0;
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS);
 	mips_ejtag_drscan_32(ejtag_info, &address);
 
 	if (address != MIPS32_PRACC_TEXT)
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 974c836..3ea23d4 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -28,7 +28,7 @@
 #include "mips32.h"
 #include "mips_ejtag.h"
 
-int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr, void *delete_me_and_submit_patch)
+int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
 {
 	struct jtag_tap *tap;
 
@@ -58,7 +58,7 @@ int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 
 	jtag_set_end_state(TAP_IDLE);
 
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE);
 
 	field.num_bits = 32;
 	field.out_value = NULL;
@@ -80,7 +80,7 @@ int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
 
 	jtag_set_end_state(TAP_IDLE);
 
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE);
 
 	field.num_bits = 32;
 	field.out_value = NULL;
@@ -210,7 +210,7 @@ int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info)
 {
 	uint32_t ejtag_ctrl;
 	jtag_set_end_state(TAP_IDLE);
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 
 	/* set debug break bit */
 	ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_JTAGBRK;
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index a086cd5..164edd0 100644
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -129,7 +129,7 @@ struct mips_ejtag
 };
 
 int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info,
-		int new_instr, void *delete_me_and_submit_patch);
+		int new_instr);
 int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_exit_debug(struct mips_ejtag *ejtag_info);
 int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode);
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index d1b4589..5919f5b 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -113,7 +113,7 @@ int mips_m4k_poll(struct target *target)
 
 	/* read ejtag control reg */
 	jtag_set_end_state(TAP_IDLE);
-	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
 	/* clear this bit before handling polling
@@ -125,7 +125,7 @@ int mips_m4k_poll(struct target *target)
 		jtag_set_end_state(TAP_IDLE);
 		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_ROCC;
 
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 		mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 		LOG_DEBUG("Reset Detected");
 	}
@@ -136,7 +136,7 @@ int mips_m4k_poll(struct target *target)
 		if ((target->state == TARGET_RUNNING) || (target->state == TARGET_RESET))
 		{
 			jtag_set_end_state(TAP_IDLE);
-			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT, NULL);
+			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
 
 			target->state = TARGET_HALTED;
 
@@ -228,12 +228,12 @@ int mips_m4k_assert_reset(struct target *target)
 	{
 		/* use hardware to catch reset */
 		jtag_set_end_state(TAP_IDLE);
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_EJTAGBOOT, NULL);
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_EJTAGBOOT);
 	}
 	else
 	{
 		jtag_set_end_state(TAP_IDLE);
-		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT, NULL);
+		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
 	}
 
 	if (assert_srst)
@@ -257,21 +257,21 @@ int mips_m4k_assert_reset(struct target *target)
 			LOG_DEBUG("Using MTAP reset to reset processor...");
 
 			/* use microchip specific MTAP reset */
-			mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP, NULL);
-			mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND, NULL);
+			mips_ejtag_set_instr(ejtag_info, MTAP_SW_MTAP);
+			mips_ejtag_set_instr(ejtag_info, MTAP_COMMAND);
 
 			mchip_cmd = MCHP_ASERT_RST;
 			mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
 			mchip_cmd = MCHP_DE_ASSERT_RST;
 			mips_ejtag_drscan_8(ejtag_info, &mchip_cmd);
-			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP, NULL);
+			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
 		}
 		else
 		{
 			/* use ejtag reset - not supported by all cores */
 			uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
 			LOG_DEBUG("Using EJTAG reset (PRRST) to reset processor...");
-			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
+			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 			mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 		}
 	}
@@ -933,7 +933,7 @@ int mips_m4k_examine(struct target *target)
 		{
 			/* we are using a pic32mx so select ejtag port
 			 * as it is not selected by default */
-			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP, NULL);
+			mips_ejtag_set_instr(ejtag_info, MTAP_SW_ETAP);
 			LOG_DEBUG("PIC32MX Detected - using EJTAG Interface");
 			mips_m4k->is_pic32mx = true;
 		}

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi           |   46 ++++++++++++++------------
 src/flash/nor/pic32mx.c    |   75 ++++++++++++++++++++++++++++++++++++++++++++
 src/target/mips32_dmaacc.c |   48 ++++++++++++++--------------
 src/target/mips32_pracc.c  |   24 +++++++-------
 src/target/mips_ejtag.c    |    8 ++--
 src/target/mips_ejtag.h    |    4 ++-
 src/target/mips_m4k.c      |   20 ++++++------
 7 files changed, 153 insertions(+), 72 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 18 17:44:40 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 18 Mar 2010 16:44:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-109-gec108ff
Message-ID: <E1NsIpu-0000hl-Oq@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ec108ff59e23ec32abf1223488ad96dd26205a5b (commit)
      from  46f92878da6c65eac275d1783e4e4019ec3c9af9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ec108ff59e23ec32abf1223488ad96dd26205a5b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 18 12:07:41 2010 +0100

    jtag: retire one instance of jtag_get_end_state() usage
    
    Less global variables....
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 091b77a..41443ff 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -88,7 +88,7 @@ int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	uint8_t out_addr_buf;
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
+	arm_jtag_set_instr(jtag_info, instr, NULL, TAP_IDLE);
 
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
@@ -330,10 +330,9 @@ static int jtag_idcode_q_read(struct adiv5_dap *dap,
 	int retval;
 	struct scan_field fields[1];
 
-	jtag_set_end_state(TAP_IDLE);
-
 	/* This is a standard JTAG operation -- no DAP tweakage */
-	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL);
+	jtag_set_end_state(TAP_IDLE);
+	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
 
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 71d4a01..6e72c7a 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -55,11 +55,11 @@ static int arm720t_scan_cp15(struct target *target,
 	buf_set_u32(out_buf, 0, 32, flip_u32(out, 32));
 
 	jtag_set_end_state(TAP_DRPAUSE);
-	if ((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
 	}
-	if ((retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL)) != ERROR_OK)
+	if ((retval = arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
 	}
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index c6a08cf..85c6816 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -690,9 +690,9 @@ int arm7_9_execute_sys_speed(struct target *target)
 	jtag_set_end_state(TAP_IDLE);
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL);
+		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL);
+	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
 
 	long long then = timeval_ms();
 	int timeout;
@@ -743,9 +743,9 @@ int arm7_9_execute_fast_sys_speed(struct target *target)
 	jtag_set_end_state(TAP_IDLE);
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL);
+		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL);
+	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
 
 	if (!set)
 	{
@@ -1746,9 +1746,9 @@ int arm7_9_restart_core(struct target *target)
 	jtag_set_end_state(TAP_IDLE);
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
-		arm_jtag_set_instr(jtag_info, 0xf, NULL);
+		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
 	}
-	arm_jtag_set_instr(jtag_info, 0x4, NULL);
+	arm_jtag_set_instr(jtag_info, 0x4, NULL, TAP_IDLE);
 
 	jtag_add_runtest(1, TAP_IDLE);
 	return jtag_execute_queue();
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 2d6d68f..25151ff 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -66,11 +66,11 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		fields[1].out_value = NULL;
 		fields[1].in_value = databus;
 
-		if ((retval = arm_jtag_scann(&arm7_9->jtag_info, 0x1)) != ERROR_OK)
+		if ((retval = arm_jtag_scann(&arm7_9->jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 		{
 			return retval;
 		}
-		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL);
+		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL, TAP_DRPAUSE);
 
 		jtag_add_dr_scan(arm7_9->jtag_info.tap, 2, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -120,8 +120,8 @@ static __inline int arm7tdmi_clock_out(struct arm_jtag *jtag_info,
 		uint32_t out, uint32_t *deprecated, int breakpoint)
 {
 	jtag_set_end_state(TAP_DRPAUSE);
-	arm_jtag_scann(jtag_info, 0x1);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
 	return arm7tdmi_clock_out_inner(jtag_info, out, breakpoint);
 }
@@ -133,11 +133,11 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	struct scan_field fields[2];
 
 	jtag_set_end_state(TAP_DRPAUSE);
-	if ((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
@@ -218,11 +218,11 @@ static int arm7tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	struct scan_field fields[2];
 
 	jtag_set_end_state(TAP_DRPAUSE);
-	if ((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 68d3997..2e7c72d 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -92,8 +92,8 @@ static int arm920t_read_cp15_physical(struct target *target,
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(jtag_info, 0xf);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = &access_type_buf;
@@ -143,8 +143,8 @@ static int arm920t_write_cp15_physical(struct target *target,
 	buf_set_u32(value_buf, 0, 32, value);
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(jtag_info, 0xf);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 1;
 	fields[0].out_value = &access_type_buf;
@@ -193,8 +193,8 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(jtag_info, 0xf);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	buf_set_u32(cp15_opcode_buf, 0, 32, cp15_opcode);
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index ea951e5..c45d984 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -64,11 +64,11 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	buf_set_u32(address_buf, 0, 14, address);
 
 	jtag_set_end_state(TAP_IDLE);
-	if ((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -121,7 +121,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	LOG_DEBUG("addr: 0x%x value: %8.8x", address, *value);
 #endif
 
-	arm_jtag_set_instr(jtag_info, 0xc, NULL);
+	arm_jtag_set_instr(jtag_info, 0xc, NULL, TAP_IDLE);
 
 	return ERROR_OK;
 }
@@ -153,11 +153,11 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	buf_set_u32(value_buf, 0, 32, value);
 
 	jtag_set_end_state(TAP_IDLE);
-	if ((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
@@ -207,7 +207,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	LOG_DEBUG("addr: 0x%x value: %8.8x", address, value);
 #endif
 
-	arm_jtag_set_instr(jtag_info, 0xf, NULL);
+	arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index 67678c1..c1e8058 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -85,11 +85,11 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	uint8_t nr_w_buf = 0;
 
 	jtag_set_end_state(TAP_IDLE);
-	if ((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	/* REVISIT: table 7-2 shows that bits 31-31 need to be
@@ -140,11 +140,11 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value)
 	buf_set_u32(value_buf, 0, 32, value);
 
 	jtag_set_end_state(TAP_IDLE);
-	if ((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
 	}
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = value_buf;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index f091188..b4b6f04 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -101,11 +101,11 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		fields[2].out_value = NULL;
 		fields[2].in_value = instructionbus;
 
-		if ((retval = arm_jtag_scann(&arm7_9->jtag_info, 0x1)) != ERROR_OK)
+		if ((retval = arm_jtag_scann(&arm7_9->jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 		{
 			return retval;
 		}
-		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL);
+		arm_jtag_set_instr(&arm7_9->jtag_info, arm7_9->jtag_info.intest_instr, NULL, TAP_DRPAUSE);
 
 		jtag_add_dr_scan(arm7_9->jtag_info.tap, 3, fields, TAP_DRPAUSE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -155,12 +155,12 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 		buf_set_u32(&sysspeed_buf, 2, 1, 1);
 
 	jtag_set_end_state(TAP_DRPAUSE);
-	if ((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
@@ -214,12 +214,12 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	struct scan_field fields[3];
 
 	jtag_set_end_state(TAP_DRPAUSE);
-	if ((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -281,12 +281,12 @@ int arm9tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	struct scan_field fields[3];
 
 	jtag_set_end_state(TAP_DRPAUSE);
-	if ((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
+	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index 5ed104c..f8b5f4f 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -31,7 +31,7 @@
 #define _ARM_JTAG_SCAN_N_CHECK_
 #endif
 
-int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  void *no_verify_capture)
+int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  void *no_verify_capture, tap_state_t end_state)
 {
 	struct jtag_tap *tap;
 	tap = jtag_info->tap;
@@ -45,19 +45,19 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 
 	if (no_verify_capture == NULL)
 	{
-		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, end_state);
 	} else
 	{
 		/* FIX!!!! this is a kludge!!! arm926ejs.c should reimplement this arm_jtag_set_instr to
 		 * have special verification code.
 		 */
-		jtag_add_ir_scan_noverify(tap, &field, jtag_get_end_state());
+		jtag_add_ir_scan_noverify(tap, &field, end_state);
 	}
 
 	return ERROR_OK;
 }
 
-int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain)
+int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain, tap_state_t end_state)
 {
 	int retval = ERROR_OK;
 	uint32_t values[1];
@@ -66,7 +66,7 @@ int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain)
 	values[0]=new_scan_chain;
 	num_bits[0]=jtag_info->scann_size;
 
-	if ((retval = arm_jtag_set_instr(jtag_info, jtag_info->scann_instr, NULL)) != ERROR_OK)
+	if ((retval = arm_jtag_set_instr(jtag_info, jtag_info->scann_instr, NULL, end_state)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -75,7 +75,7 @@ int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain)
 			1,
 			num_bits,
 			values,
-			jtag_get_end_state());
+			end_state);
 
 	jtag_info->cur_scan_chain = new_scan_chain;
 
diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
index cf230b4..37c228f 100644
--- a/src/target/arm_jtag.h
+++ b/src/target/arm_jtag.h
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -36,9 +36,11 @@ struct arm_jtag
 	uint32_t intest_instr;
 };
 
-int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  void *no_verify_capture);
+int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,
+		void *no_verify_capture,
+		tap_state_t end_state);
 static inline int arm_jtag_set_instr(struct arm_jtag *jtag_info,
-		uint32_t new_instr, void *no_verify_capture)
+		uint32_t new_instr, void *no_verify_capture, tap_state_t end_state)
 {
 	/* inline most common code path */
 	struct jtag_tap *tap;
@@ -48,7 +50,7 @@ static inline int arm_jtag_set_instr(struct arm_jtag *jtag_info,
 
 	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != new_instr)
 	{
-		return arm_jtag_set_instr_inner(jtag_info, new_instr, no_verify_capture);
+		return arm_jtag_set_instr_inner(jtag_info, new_instr, no_verify_capture, end_state);
 	}
 
 	return ERROR_OK;
@@ -56,14 +58,14 @@ static inline int arm_jtag_set_instr(struct arm_jtag *jtag_info,
 }
 
 
-int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain);
-static inline int arm_jtag_scann(struct arm_jtag *jtag_info, uint32_t new_scan_chain)
+int arm_jtag_scann_inner(struct arm_jtag *jtag_info, uint32_t new_scan_chain, tap_state_t end_state);
+static inline int arm_jtag_scann(struct arm_jtag *jtag_info, uint32_t new_scan_chain, tap_state_t end_state)
 {
 	/* inline most common code path */
 	int retval = ERROR_OK;
 	if (jtag_info->cur_scan_chain != new_scan_chain)
 	{
-		return arm_jtag_scann_inner(jtag_info, new_scan_chain);
+		return arm_jtag_scann_inner(jtag_info, new_scan_chain, end_state);
 	}
 
 	return retval;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index fe266d6..9272f66 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -344,9 +344,9 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	uint8_t field2_out[1];
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(ice_reg->jtag_info, 0x2);
+	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
-	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	/* bits 31:0 -- data (ignored here) */
 	fields[0].num_bits = 32;
@@ -406,8 +406,8 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	uint8_t field2_out[1];
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(jtag_info, 0x2);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -491,9 +491,9 @@ void embeddedice_write_reg(struct reg *reg, uint32_t value)
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", ice_reg->addr, value);
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(ice_reg->jtag_info, 0x2);
+	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
-	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	uint8_t reg_addr = ice_reg->addr & 0x1f;
 	embeddedice_write_reg_inner(ice_reg->jtag_info->tap, reg_addr, value);
@@ -524,8 +524,8 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	uint8_t field2_out[1];
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(jtag_info, 0x2);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = field0_out;
@@ -577,8 +577,8 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 		return ERROR_INVALID_ARGUMENTS;
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(jtag_info, 0x2);
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
diff --git a/src/target/etm.c b/src/target/etm.c
index a1c77b0..3c25f4e 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -505,8 +505,8 @@ static int etm_read_reg_w_check(struct reg *reg,
 	LOG_DEBUG("%s (%u)", r->name, reg_addr);
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(etm_reg->jtag_info, 0x6);
-	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL);
+	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
+	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = reg->value;
@@ -588,8 +588,8 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	LOG_DEBUG("%s (%u): 0x%8.8" PRIx32 "", r->name, reg_addr, value);
 
 	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_scann(etm_reg->jtag_info, 0x6);
-	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL);
+	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
+	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
 	fields[0].num_bits = 32;
 	uint8_t tmp1[4];
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 22ddb55..405c50c 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -85,9 +85,9 @@ int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 	buf_set_u32(instr_buf, 0, 32, flip_u32(instr, 32));
 
 	jtag_set_end_state(TAP_DRPAUSE);
-	arm_jtag_scann(jtag_info, 0x1);
+	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
 
-	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL);
+	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c   |    7 +++----
 src/target/arm720t.c       |    4 ++--
 src/target/arm7_9_common.c |   12 ++++++------
 src/target/arm7tdmi.c      |   16 ++++++++--------
 src/target/arm920t.c       |   12 ++++++------
 src/target/arm926ejs.c     |   12 ++++++------
 src/target/arm966e.c       |    8 ++++----
 src/target/arm9tdmi.c      |   16 ++++++++--------
 src/target/arm_jtag.c      |   12 ++++++------
 src/target/arm_jtag.h      |   16 +++++++++-------
 src/target/embeddedice.c   |   20 ++++++++++----------
 src/target/etm.c           |    8 ++++----
 src/target/feroceon.c      |    4 ++--
 13 files changed, 74 insertions(+), 73 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Mar 18 20:32:48 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 18 Mar 2010 19:32:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-112-gfc9de56
Message-ID: <E1NsLSb-0001Kv-Fj@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fc9de56a251a7cfc2610cc1904a69fc7b9fd3011 (commit)
      from  c09035ea2cb24dee300476a3502919d23d90d1f5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fc9de56a251a7cfc2610cc1904a69fc7b9fd3011
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Mar 18 12:32:35 2010 -0700

    ADI_v5 - it's not always an "SWJ-DP"
    
    So don't use the name "swjdp" for all DAPs; rename to
    plain old "dap", which *is* always correct.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 41443ff..d59465b 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -66,7 +66,7 @@
  * will be needed to collect the data which was read; the "invalue" collects
  * the posted result of a preceding operation, not the current one.
  *
- * @param swjdp the DAP
+ * @param dap the DAP
  * @param instr JTAG_DP_APACC (AP access) or JTAG_DP_DPACC (DP access)
  * @param reg_addr two significant bits; A[3:2]; for APACC access, the
  *	SELECT register has more addressing bits.
@@ -79,11 +79,11 @@
 /* FIXME don't export ... this is a temporary workaround for the
  * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
  */
-int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
 {
-	struct arm_jtag *jtag_info = swjdp->jtag_info;
+	struct arm_jtag *jtag_info = dap->jtag_info;
 	struct scan_field fields[2];
 	uint8_t out_addr_buf;
 
@@ -117,8 +117,8 @@ int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
 	if ((instr == JTAG_DP_APACC)
 			&& ((reg_addr == AP_REG_DRW)
 				|| ((reg_addr & 0xF0) == AP_REG_BD0))
-			&& (swjdp->memaccess_tck != 0))
-		jtag_add_runtest(swjdp->memaccess_tck,
+			&& (dap->memaccess_tck != 0))
+		jtag_add_runtest(dap->memaccess_tck,
 				TAP_IDLE);
 
 	return jtag_get_error();
@@ -130,7 +130,7 @@ int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
  * conversions are performed (so the types of invalue and outvalue
  * must be different).
  */
-static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
+static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
 {
@@ -139,7 +139,7 @@ static int adi_jtag_dp_scan_u32(struct adiv5_dap *swjdp,
 
 	buf_set_u32(out_value_buf, 0, 32, outvalue);
 
-	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
+	retval = adi_jtag_dp_scan(dap, instr, reg_addr, RnW,
 			out_value_buf, (uint8_t *)invalue, ack);
 	if (retval != ERROR_OK)
 		return retval;
@@ -161,14 +161,14 @@ static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
 			outvalue, NULL, NULL);
 }
 
-static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
+static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue)
 {
 	int retval;
 
 	/* Issue the read or write */
-	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
+	retval = adi_jtag_dp_scan_u32(dap, instr, reg_addr,
 			RnW, outvalue, NULL, NULL);
 	if (retval != ERROR_OK)
 		return retval;
@@ -177,12 +177,12 @@ static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *swjdp,
 	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
 	 */
 	if ((RnW == DPAP_READ) && (invalue != NULL))
-		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
+		retval = adi_jtag_dp_scan_u32(dap, JTAG_DP_DPACC,
+				DP_RDBUFF, DPAP_READ, 0, invalue, &dap->ack);
 	return retval;
 }
 
-static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
+static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 {
 	int retval;
 	uint32_t ctrlstat;
@@ -191,7 +191,7 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 
 #if 0
 	/* Danger!!!! BROKEN!!!! */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
 	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
 	R956 introduced the check on return value here and now Michael Schwingen reports
@@ -209,21 +209,21 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 	/* Post CTRL/STAT read; discard any previous posted read value
 	 * but collect its ACK status.
 	 */
-	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
-	swjdp->ack = swjdp->ack & 0x7;
+	dap->ack = dap->ack & 0x7;
 
 	/* common code path avoids calling timeval_ms() */
-	if (swjdp->ack != JTAG_ACK_OK_FAULT)
+	if (dap->ack != JTAG_ACK_OK_FAULT)
 	{
 		long long then = timeval_ms();
 
-		while (swjdp->ack != JTAG_ACK_OK_FAULT)
+		while (dap->ack != JTAG_ACK_OK_FAULT)
 		{
-			if (swjdp->ack == JTAG_ACK_WAIT)
+			if (dap->ack == JTAG_ACK_WAIT)
 			{
 				if ((timeval_ms()-then) > 1000)
 				{
@@ -240,15 +240,15 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 			{
 				LOG_WARNING("Invalid ACK %#x "
 						"in JTAG-DP transaction",
-						swjdp->ack);
+						dap->ack);
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
+			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
-			swjdp->ack = swjdp->ack & 0x7;
+			dap->ack = dap->ack & 0x7;
 		}
 	}
 
@@ -260,7 +260,7 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
 		/* Check power to debug regions */
 		if ((ctrlstat & 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(swjdp);
+			 ahbap_debugport_init(dap);
 		else
 		{
 			uint32_t mem_ap_csw, mem_ap_tar;
@@ -269,14 +269,14 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 			 * MEM-AP access; but not if autoincrementing.
 			 * *Real* CSW and TAR values are always shown.
 			 */
-			if (swjdp->ap_tar_value != (uint32_t) -1)
+			if (dap->ap_tar_value != (uint32_t) -1)
 				LOG_DEBUG("MEM-AP Cached values: "
 					"ap_bank 0x%" PRIx32
 					", ap_csw 0x%" PRIx32
 					", ap_tar 0x%" PRIx32,
-					swjdp->ap_bank_value,
-					swjdp->ap_csw_value,
-					swjdp->ap_tar_value);
+					dap->ap_bank_value,
+					dap->ap_csw_value,
+					dap->ap_tar_value);
 
 			if (ctrlstat & SSTICKYORUN)
 				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
@@ -286,34 +286,34 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *swjdp)
 				LOG_ERROR("JTAG-DP STICKY ERROR");
 
 			/* Clear Sticky Error Bits */
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_WRITE,
-					swjdp->dp_ctrl_stat | SSTICKYORUN
+					dap->dp_ctrl_stat | SSTICKYORUN
 						| SSTICKYERR, NULL);
-			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
+			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 
 			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
 
-			retval = dap_queue_ap_read(swjdp,
+			retval = dap_queue_ap_read(dap,
 					AP_REG_CSW, &mem_ap_csw);
 			if (retval != ERROR_OK)
 				return retval;
 
-			retval = dap_queue_ap_read(swjdp,
+			retval = dap_queue_ap_read(dap,
 					AP_REG_TAR, &mem_ap_tar);
 			if (retval != ERROR_OK)
 				return retval;
 
-			if ((retval = dap_run(swjdp)) != ERROR_OK)
+			if ((retval = dap_run(dap)) != ERROR_OK)
 				return retval;
 			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
 					PRIx32, mem_ap_csw, mem_ap_tar);
 
 		}
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
+		if ((retval = dap_run(dap)) != ERROR_OK)
 			return retval;
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 01c274b..1b97e33 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -96,23 +96,23 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  * selection is implicitly used with future AP transactions.
  * This is a NOP if the specified AP is already selected.
  *
- * @param swjdp The DAP
+ * @param dap The DAP
  * @param apsel Number of the AP to (implicitly) use with further
  *	transactions.  This normally identifies a MEM-AP.
  */
-void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
+void dap_ap_select(struct adiv5_dap *dap,uint8_t apsel)
 {
 	uint32_t select = (apsel << 24) & 0xFF000000;
 
-	if (select != swjdp->apsel)
+	if (select != dap->apsel)
 	{
-		swjdp->apsel = select;
+		dap->apsel = select;
 		/* Switching AP invalidates cached values.
 		 * Values MUST BE UPDATED BEFORE AP ACCESS.
 		 */
-		swjdp->ap_bank_value = -1;
-		swjdp->ap_csw_value = -1;
-		swjdp->ap_tar_value = -1;
+		dap->ap_bank_value = -1;
+		dap->ap_csw_value = -1;
+		dap->ap_tar_value = -1;
 	}
 }
 
@@ -127,7 +127,7 @@ void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
  *
  * @todo Rename to reflect it being specifically a MEM-AP function.
  *
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
  *	matches the cached value, the register is not changed.
  * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
@@ -135,37 +135,37 @@ void dap_ap_select(struct adiv5_dap *swjdp,uint8_t apsel)
  *
  * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
-int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
+int dap_setup_accessport(struct adiv5_dap *dap, uint32_t csw, uint32_t tar)
 {
 	int retval;
 
 	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
-	if (csw != swjdp->ap_csw_value)
+	if (csw != dap->ap_csw_value)
 	{
 		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_CSW, csw);
+		retval = dap_queue_ap_write(dap, AP_REG_CSW, csw);
 		if (retval != ERROR_OK)
 			return retval;
-		swjdp->ap_csw_value = csw;
+		dap->ap_csw_value = csw;
 	}
-	if (tar != swjdp->ap_tar_value)
+	if (tar != dap->ap_tar_value)
 	{
 		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
-		retval = dap_queue_ap_write(swjdp, AP_REG_TAR, tar);
+		retval = dap_queue_ap_write(dap, AP_REG_TAR, tar);
 		if (retval != ERROR_OK)
 			return retval;
-		swjdp->ap_tar_value = tar;
+		dap->ap_tar_value = tar;
 	}
 	/* Disable TAR cache when autoincrementing */
 	if (csw & CSW_ADDRINC_MASK)
-		swjdp->ap_tar_value = -1;
+		dap->ap_tar_value = -1;
 	return ERROR_OK;
 }
 
 /**
  * Asynchronous (queued) read of a word from memory or a system register.
  *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param dap The DAP connected to the MEM-AP performing the read.
  * @param address Address of the 32-bit word to read; it must be
  *	readable by the currently selected MEM-AP.
  * @param value points to where the word will be stored when the
@@ -173,7 +173,7 @@ int dap_setup_accessport(struct adiv5_dap *swjdp, uint32_t csw, uint32_t tar)
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_read_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t *value)
 {
 	int retval;
@@ -181,19 +181,19 @@ int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,
 			address & 0xFFFFFFF0);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_queue_ap_read(swjdp, AP_REG_BD0 | (address & 0xC), value);
+	return dap_queue_ap_read(dap, AP_REG_BD0 | (address & 0xC), value);
 }
 
 /**
  * Synchronous read of a word from memory or a system register.
  * As a side effect, this flushes any queued transactions.
  *
- * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param dap The DAP connected to the MEM-AP performing the read.
  * @param address Address of the 32-bit word to read; it must be
  *	readable by the currently selected MEM-AP.
  * @param value points to where the result will be stored.
@@ -201,22 +201,22 @@ int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address,
  * @return ERROR_OK for success; *value holds the result.
  * Otherwise a fault code.
  */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_read_atomic_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t *value)
 {
 	int retval;
 
-	retval = mem_ap_read_u32(swjdp, address, value);
+	retval = mem_ap_read_u32(dap, address, value);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_run(swjdp);
+	return dap_run(dap);
 }
 
 /**
  * Asynchronous (queued) write of a word to memory or a system register.
  *
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param address Address to be written; it must be writable by
  *	the currently selected MEM-AP.
  * @param value Word that will be written to the address when transaction
@@ -224,7 +224,7 @@ int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_write_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t value)
 {
 	int retval;
@@ -232,12 +232,12 @@ int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
-	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,
 			address & 0xFFFFFFF0);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_queue_ap_write(swjdp, AP_REG_BD0 | (address & 0xC),
+	return dap_queue_ap_write(dap, AP_REG_BD0 | (address & 0xC),
 			value);
 }
 
@@ -245,32 +245,32 @@ int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address,
  * Synchronous write of a word to memory or a system register.
  * As a side effect, this flushes any queued transactions.
  *
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param address Address to be written; it must be writable by
  *	the currently selected MEM-AP.
  * @param value Word that will be written.
  *
  * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
  */
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, uint32_t address,
+int mem_ap_write_atomic_u32(struct adiv5_dap *dap, uint32_t address,
 		uint32_t value)
 {
-	int retval = mem_ap_write_u32(swjdp, address, value);
+	int retval = mem_ap_write_u32(dap, address, value);
 
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_run(swjdp);
+	return dap_run(dap);
 }
 
 /*****************************************************************************
 *                                                                            *
-* mem_ap_write_buf(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address) *
+* mem_ap_write_buf(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address) *
 *                                                                            *
 * Write a buffer in target order (little endian)                             *
 *                                                                            *
 *****************************************************************************/
-int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u32(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
 {
 	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
 	uint32_t adr = address;
@@ -301,7 +301,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 	while (wcount > 0)
 	{
 		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap->tar_autoincr_block, address);
 		if (wcount < blocksize)
 			blocksize = wcount;
 
@@ -309,17 +309,17 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
 
 		for (writecount = 0; writecount < blocksize; writecount++)
 		{
-			retval = dap_queue_ap_write(swjdp, AP_REG_DRW,
+			retval = dap_queue_ap_write(dap, AP_REG_DRW,
 				*(uint32_t *) (buffer + 4 * writecount));
 			if (retval != ERROR_OK)
 				break;
 		}
 
-		if (dap_run(swjdp) == ERROR_OK)
+		if (dap_run(dap) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address = address + 4 * blocksize;
@@ -341,7 +341,7 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 	return retval;
 }
 
-static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
+static int mem_ap_write_buf_packed_u16(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
@@ -354,7 +354,7 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap->tar_autoincr_block, address);
 
 		if (wcount < blocksize)
 			blocksize = wcount;
@@ -363,7 +363,7 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
 		writecount = blocksize;
 
 		do
@@ -372,7 +372,7 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 
 			if (nbytes < 4)
 			{
-				if (mem_ap_write_buf_u16(swjdp, buffer,
+				if (mem_ap_write_buf_u16(dap, buffer,
 						nbytes, address) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
@@ -396,12 +396,12 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 				}
 
 				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
+				retval = dap_queue_ap_write(dap,
 						AP_REG_DRW, outvalue);
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(swjdp) != ERROR_OK)
+				if (dap_run(dap) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
@@ -421,24 +421,24 @@ static int mem_ap_write_buf_packed_u16(struct adiv5_dap *swjdp,
 	return retval;
 }
 
-int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u16(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
 	if (count >= 4)
-		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
+		return mem_ap_write_buf_packed_u16(dap, buffer, count, address);
 
 	while (count > 0)
 	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
 		uint16_t svalue;
 		memcpy(&svalue, buffer, sizeof(uint16_t));
 		uint32_t outvalue = (uint32_t)svalue << 8 * (address & 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		retval = dap_queue_ap_write(dap, AP_REG_DRW, outvalue);
 		if (retval != ERROR_OK)
 			break;
 
-		retval = dap_run(swjdp);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -450,7 +450,7 @@ int mem_ap_write_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer, int count, ui
 	return retval;
 }
 
-static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
+static int mem_ap_write_buf_packed_u8(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
@@ -463,12 +463,12 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to write blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap->tar_autoincr_block, address);
 
 		if (wcount < blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
 		writecount = blocksize;
 
 		do
@@ -477,7 +477,7 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 
 			if (nbytes < 4)
 			{
-				if (mem_ap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
+				if (mem_ap_write_buf_u8(dap, buffer, nbytes, address) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
@@ -500,12 +500,12 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 				}
 
 				memcpy(&outvalue, buffer, sizeof(uint32_t));
-				retval = dap_queue_ap_write(swjdp,
+				retval = dap_queue_ap_write(dap,
 						AP_REG_DRW, outvalue);
 				if (retval != ERROR_OK)
 					break;
 
-				if (dap_run(swjdp) != ERROR_OK)
+				if (dap_run(dap) != ERROR_OK)
 				{
 					LOG_WARNING("Block write error address "
 						"0x%" PRIx32 ", count 0x%x",
@@ -525,22 +525,22 @@ static int mem_ap_write_buf_packed_u8(struct adiv5_dap *swjdp,
 	return retval;
 }
 
-int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uint32_t address)
+int mem_ap_write_buf_u8(struct adiv5_dap *dap, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
 	if (count >= 4)
-		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
+		return mem_ap_write_buf_packed_u8(dap, buffer, count, address);
 
 	while (count > 0)
 	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
 		uint32_t outvalue = (uint32_t)*buffer << 8 * (address & 0x3);
-		retval = dap_queue_ap_write(swjdp, AP_REG_DRW, outvalue);
+		retval = dap_queue_ap_write(dap, AP_REG_DRW, outvalue);
 		if (retval != ERROR_OK)
 			break;
 
-		retval = dap_run(swjdp);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -555,19 +555,19 @@ int mem_ap_write_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer, int count, uin
 /* FIXME don't import ... this is a temporary workaround for the
  * mem_ap_read_buf_u32() mess, until it's no longer JTAG-specific.
  */
-extern int adi_jtag_dp_scan(struct adiv5_dap *swjdp,
+extern int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack);
 
 /**
  * Synchronously read a block of 32-bit words into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param buffer where the words will be stored (in host byte order).
  * @param count How many words to read.
  * @param address Memory address from which to read words; all the
  *	words must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u32(struct adiv5_dap *dap, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
@@ -583,7 +583,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 		 * TAR autoincrement size (at least 2^10).  Autoincrement
 		 * mode avoids an extra per-word roundtrip to update TAR.
 		 */
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block,
+		blocksize = max_tar_block_size(dap->tar_autoincr_block,
 				address);
 		if (wcount < blocksize)
 			blocksize = wcount;
@@ -592,7 +592,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
+		dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_SINGLE,
 				address);
 
 		/* FIXME remove these three calls to adi_jtag_dp_scan(),
@@ -603,7 +603,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 		 */
 
 		/* Scan out first read */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+		adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
 				DPAP_READ, 0, NULL, NULL);
 		for (readcount = 0; readcount < blocksize - 1; readcount++)
 		{
@@ -611,18 +611,18 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 			 * previous one.  Assumes read is acked "OK/FAULT",
 			 * and CTRL_STAT says that meant "OK".
 			 */
-			adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
+			adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
 					DPAP_READ, 0, buffer + 4 * readcount,
-					&swjdp->ack);
+					&dap->ack);
 		}
 
 		/* Scan in last posted value; RDBUFF has no other effect,
 		 * assuming ack is OK/FAULT and CTRL_STAT says "OK".
 		 */
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC, DP_RDBUFF,
+		adi_jtag_dp_scan(dap, JTAG_DP_DPACC, DP_RDBUFF,
 				DPAP_READ, 0, buffer + 4 * readcount,
-				&swjdp->ack);
-		if (dap_run(swjdp) == ERROR_OK)
+				&dap->ack);
+		if (dap_run(dap) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address += 4 * blocksize;
@@ -664,7 +664,7 @@ int mem_ap_read_buf_u32(struct adiv5_dap *swjdp, uint8_t *buffer,
 	return retval;
 }
 
-static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
+static int mem_ap_read_buf_packed_u16(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
@@ -678,11 +678,11 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap->tar_autoincr_block, address);
 		if (wcount < blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_PACKED, address);
 
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
@@ -691,8 +691,8 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
 
 		do
 		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-			if (dap_run(swjdp) != ERROR_OK)
+			retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
+			if (dap_run(dap) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
 				/* REVISIT return the *actual* fault code */
@@ -718,29 +718,29 @@ static int mem_ap_read_buf_packed_u16(struct adiv5_dap *swjdp,
 
 /**
  * Synchronously read a block of 16-bit halfwords into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param buffer where the halfwords will be stored (in host byte order).
  * @param count How many halfwords to read.
  * @param address Memory address from which to read words; all the
  *	words must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u16(struct adiv5_dap *dap, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	uint32_t invalue, i;
 	int retval = ERROR_OK;
 
 	if (count >= 4)
-		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
+		return mem_ap_read_buf_packed_u16(dap, buffer, count, address);
 
 	while (count > 0)
 	{
-		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
+		dap_setup_accessport(dap, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
 		if (retval != ERROR_OK)
 			break;
 
-		retval = dap_run(swjdp);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -772,7 +772,7 @@ int mem_ap_read_buf_u16(struct adiv5_dap *swjdp, uint8_t *buffer,
  * The solution is to arrange for a large out/in scan in this loop and
  * and convert data afterwards.
  */
-static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
+static int mem_ap_read_buf_packed_u8(struct adiv5_dap *dap,
 		uint8_t *buffer, int count, uint32_t address)
 {
 	uint32_t invalue;
@@ -786,18 +786,18 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
 		int nbytes;
 
 		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		blocksize = max_tar_block_size(dap->tar_autoincr_block, address);
 
 		if (wcount < blocksize)
 			blocksize = wcount;
 
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, address);
 		readcount = blocksize;
 
 		do
 		{
-			retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-			if (dap_run(swjdp) != ERROR_OK)
+			retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
+			if (dap_run(dap) != ERROR_OK)
 			{
 				LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
 				/* REVISIT return the *actual* fault code */
@@ -823,26 +823,26 @@ static int mem_ap_read_buf_packed_u8(struct adiv5_dap *swjdp,
 
 /**
  * Synchronously read a block of bytes into a buffer
- * @param swjdp The DAP connected to the MEM-AP.
+ * @param dap The DAP connected to the MEM-AP.
  * @param buffer where the bytes will be stored.
  * @param count How many bytes to read.
  * @param address Memory address from which to read data; all the
  *	data must be readable by the currently selected MEM-AP.
  */
-int mem_ap_read_buf_u8(struct adiv5_dap *swjdp, uint8_t *buffer,
+int mem_ap_read_buf_u8(struct adiv5_dap *dap, uint8_t *buffer,
 		int count, uint32_t address)
 {
 	uint32_t invalue;
 	int retval = ERROR_OK;
 
 	if (count >= 4)
-		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
+		return mem_ap_read_buf_packed_u8(dap, buffer, count, address);
 
 	while (count > 0)
 	{
-		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		retval = dap_queue_ap_read(swjdp, AP_REG_DRW, &invalue);
-		retval = dap_run(swjdp);
+		dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
+		retval = dap_queue_ap_read(dap, AP_REG_DRW, &invalue);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			break;
 
@@ -870,14 +870,14 @@ extern const struct dap_ops jtag_dp_ops;
  * for further use, and arranges to use AP #0 for all AP operations
  * until dap_ap-select() changes that policy.
  *
- * @param swjdp The DAP being initialized.
+ * @param dap The DAP being initialized.
  *
  * @todo Rename this.  We also need an initialization scheme which account
  * for SWD transports not just JTAG; that will need to address differences
  * in layering.  (JTAG is useful without any debug target; but not SWD.)
  * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
  */
-int ahbap_debugport_init(struct adiv5_dap *swjdp)
+int ahbap_debugport_init(struct adiv5_dap *dap)
 {
 	uint32_t idreg, romaddr, dummy;
 	uint32_t ctrlstat;
@@ -887,7 +887,7 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	LOG_DEBUG(" ");
 
 	/* JTAG-DP or SWJ-DP, in JTAG mode */
-	swjdp->ops = &jtag_dp_ops;
+	dap->ops = &jtag_dp_ops;
 
 	/* Default MEM-AP setup.
 	 *
@@ -895,42 +895,42 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	 * Should we probe, or take a hint from the caller?
 	 * Presumably we can ignore the possibility of multiple APs.
 	 */
-	swjdp->apsel = !0;
-	dap_ap_select(swjdp, 0);
+	dap->apsel = !0;
+	dap_ap_select(dap, 0);
 
 	/* DP initialization */
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, SSTICKYERR);
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, SSTICKYERR);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
-	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &ctrlstat);
 	if (retval != ERROR_OK)
 		return retval;
-	if ((retval = dap_run(swjdp)) != ERROR_OK)
+	if ((retval = dap_run(dap)) != ERROR_OK)
 		return retval;
 
 	/* Check that we have debug power domains activated */
 	while (!(ctrlstat & CDBGPWRUPACK) && (cnt++ < 10))
 	{
 		LOG_DEBUG("DAP: wait CDBGPWRUPACK");
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &ctrlstat);
 		if (retval != ERROR_OK)
 			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
+		if ((retval = dap_run(dap)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
@@ -938,23 +938,23 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	while (!(ctrlstat & CSYSPWRUPACK) && (cnt++ < 10))
 	{
 		LOG_DEBUG("DAP: wait CSYSPWRUPACK");
-		retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &ctrlstat);
+		retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &ctrlstat);
 		if (retval != ERROR_OK)
 			return retval;
-		if ((retval = dap_run(swjdp)) != ERROR_OK)
+		if ((retval = dap_run(dap)) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
 
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 	/* With debug power on we can activate OVERRUN checking */
-	swjdp->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	retval = dap_queue_dp_write(swjdp, DP_CTRL_STAT, swjdp->dp_ctrl_stat);
+	dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
+	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = dap_queue_dp_read(swjdp, DP_CTRL_STAT, &dummy);
+	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -964,12 +964,12 @@ int ahbap_debugport_init(struct adiv5_dap *swjdp)
 	 * Should it?  If the ROM address is valid, is this the right
 	 * place to scan the table and do any topology detection?
 	 */
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &idreg);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &romaddr);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &idreg);
+	retval = dap_queue_ap_read(dap, AP_REG_BASE, &romaddr);
 
 	LOG_DEBUG("MEM-AP #%d ID Register 0x%" PRIx32
 		", Debug ROM Address 0x%" PRIx32,
-		swjdp->apsel, idreg, romaddr);
+		dap->apsel, idreg, romaddr);
 
 	return ERROR_OK;
 }
@@ -993,7 +993,7 @@ is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t cid0)
 }
 
 static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *swjdp, int apsel)
+		struct adiv5_dap *dap, int apsel)
 {
 	int retval;
 	uint32_t dbgbase, apid;
@@ -1005,11 +1005,11 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	if (apsel >= 256)
 		return ERROR_INVALID_ARGUMENTS;
 
-	apselold = swjdp->apsel;
-	dap_ap_select(swjdp, apsel);
-	retval = dap_queue_ap_read(swjdp, AP_REG_BASE, &dbgbase);
-	retval = dap_queue_ap_read(swjdp, AP_REG_IDR, &apid);
-	retval = dap_run(swjdp);
+	apselold = dap->apsel;
+	dap_ap_select(dap, apsel);
+	retval = dap_queue_ap_read(dap, AP_REG_BASE, &dbgbase);
+	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
+	retval = dap_run(dap);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1059,12 +1059,12 @@ static int dap_info_command(struct command_context *cmd_ctx,
 			command_print(cmd_ctx, "\tROM table in legacy format");
 
 		/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
-		mem_ap_read_u32(swjdp, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
-		retval = dap_run(swjdp);
+		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
+		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
+		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
+		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
+		mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
+		retval = dap_run(dap);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -1084,7 +1084,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 		entry_offset = 0;
 		do
 		{
-			mem_ap_read_atomic_u32(swjdp, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
+			mem_ap_read_atomic_u32(dap, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
 			command_print(cmd_ctx, "\tROMTABLE[0x%x] = 0x%" PRIx32 "",entry_offset,romentry);
 			if (romentry&0x01)
 			{
@@ -1096,23 +1096,23 @@ static int dap_info_command(struct command_context *cmd_ctx,
 
 				component_base = (uint32_t)((dbgbase & 0xFFFFF000)
 						+ (int)(romentry & 0xFFFFF000));
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFE0, &c_pid0);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFE4, &c_pid1);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFE8, &c_pid2);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFEC, &c_pid3);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFD0, &c_pid4);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFF0, &c_cid0);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFF4, &c_cid1);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFF8, &c_cid2);
-				mem_ap_read_atomic_u32(swjdp,
+				mem_ap_read_atomic_u32(dap,
 						(component_base & 0xFFFFF000) | 0xFFC, &c_cid3);
 				component_start = component_base - 0x1000*(c_pid4 >> 4);
 
@@ -1130,7 +1130,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 					unsigned minor;
 					char *major = "Reserved", *subtype = "Reserved";
 
-					mem_ap_read_atomic_u32(swjdp,
+					mem_ap_read_atomic_u32(dap,
 							(component_base & 0xfffff000) | 0xfcc,
 							&devtype);
 					minor = (devtype >> 4) & 0x0f;
@@ -1346,7 +1346,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	{
 		command_print(cmd_ctx, "\tNo ROM table present");
 	}
-	dap_ap_select(swjdp, apselold);
+	dap_ap_select(dap, apselold);
 
 	return ERROR_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c |   70 ++++++------
 src/target/arm_adi_v5.c  |  280 +++++++++++++++++++++++-----------------------
 2 files changed, 175 insertions(+), 175 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Mar 18 20:13:31 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 18 Mar 2010 19:13:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-111-gc09035e
Message-ID: <E1NsL9w-000801-Mt@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c09035ea2cb24dee300476a3502919d23d90d1f5 (commit)
       via  52a788e008ecf0ca6156f02de08a0f062d49a236 (commit)
      from  ec108ff59e23ec32abf1223488ad96dd26205a5b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c09035ea2cb24dee300476a3502919d23d90d1f5
Merge: 52a788e ec108ff
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Mar 18 12:11:58 2010 -0700

    Merge branch 'master' of ssh://dbrownell at openocd.git.sourceforge.net/gitroot/openocd/openocd


commit 52a788e008ecf0ca6156f02de08a0f062d49a236
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Mar 18 11:56:17 2010 -0700

    remove more duplication
    
    Not sure how the original "move code to adi_v5_swd.c" patch left
    some code in the "arm_adi_v5.c" file, but a recent patch was only
    a partial fix -- it didn't remove all the duplication.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 4afd50c..01c274b 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1572,28 +1572,3 @@ const struct command_registration dap_command_handlers[] = {
 };
 
 
-/*
- * This represents the bits which must be sent out on TMS/SWDIO to
- * switch a DAP implemented using an SWJ-DP module into SWD mode.
- * These bits are stored (and transmitted) LSB-first.
- *
- * See the DAP-Lite specification, section 2.2.5 for information
- * about making the debug link select SWD or JTAG.  (Similar info
- * is in a few other ARM documents.)
- */
-static const uint8_t jtag2swd_bitseq[] = {
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	/* Switching sequence enables SWD and disables JTAG
-	 * NOTE: bits in the DP's IDCODE may expose the need for
-	 * an old/deprecated sequence (0xb6 0xed).
-	 */
-	0x9e, 0xe7,
-	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
-	 * putting both JTAG and SWD logic into reset state.
-	 */
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-};
-

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   25 -------------------------
 1 files changed, 0 insertions(+), 25 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Mar 19 05:35:48 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 19 Mar 2010 04:35:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-113-g8d411d0
Message-ID: <E1NsTw6-0005Ns-EK@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8d411d0d249dda7ceb951c4f8c8a509f4fd1dfb0 (commit)
      from  fc9de56a251a7cfc2610cc1904a69fc7b9fd3011 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8d411d0d249dda7ceb951c4f8c8a509f4fd1dfb0
Author: Mike Dunn <mikedunn at newsguy.com>
Date:   Thu Mar 18 21:34:13 2010 -0700

    Fix underlying problem with xscale icache and dcache commands
    
    Fix problem with the xscale icache and dcache commands.  Both commands were
    enabling or disabling the mmu, not the caches
    
    I didn't look any further after my earlier patch fixed the trivial problem
    with command argument parsing.  Turns out the underlying code was broken.
    
    The resolution is straightforward when you look at the arguments to
    xscale_enable_mmu_caches() and xscale_disable_mmu_caches().  I finally
    took a deeper look after dumping the cp15 control register (XSCALE_CTRL)
    and seeing that the cache bits weren't changing, but the mmu bit was
    (which caused all manner of grief, as you can imagine).  This has been
    tested and works OK now.
    
     src/target/xscale.c |   17 +++++++++++------
     1 files changed, 11 insertions(+), 6 deletions(-)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index f5aada5..55323ae 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3204,14 +3204,19 @@ COMMAND_HANDLER(xscale_handle_idcache_command)
 	{
 		bool enable;
 		COMMAND_PARSE_ENABLE(CMD_ARGV[0], enable);
-		if (enable)
-			xscale_enable_mmu_caches(target, 1, 0, 0);
-		else
-			xscale_disable_mmu_caches(target, 1, 0, 0);
-		if (icache)
+		if (icache) {
 			xscale->armv4_5_mmu.armv4_5_cache.i_cache_enabled = enable;
-		else
+			if (enable)
+				xscale_enable_mmu_caches(target, 0, 0, 1);
+			else
+				xscale_disable_mmu_caches(target, 0, 0, 1);
+		} else {
 			xscale->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = enable;
+			if (enable)
+				xscale_enable_mmu_caches(target, 0, 1, 0);
+			else
+				xscale_disable_mmu_caches(target, 0, 1, 0);
+		}
 	}
 
 	bool enabled = icache ?

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c |   17 +++++++++++------
 1 files changed, 11 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar 19 08:40:45 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri, 19 Mar 2010 07:40:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-118-g7f6bab0
Message-ID: <E1NsWp4-0002C2-QP@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7f6bab0c4c36d7a64f933904e5add9bc6b36d78c (commit)
       via  15ff2aeca9b302419aed62fc3cc73dedacdd62cb (commit)
       via  1911c8ec8d286840c6a0d6a57c423072766d3386 (commit)
       via  729845238228f577bc3d6369d83667e5e2df1aee (commit)
       via  8ce828dd382c907db4c6bd38e5b54996e50327fd (commit)
      from  8d411d0d249dda7ceb951c4f8c8a509f4fd1dfb0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7f6bab0c4c36d7a64f933904e5add9bc6b36d78c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 18 18:53:39 2010 +0100

    jtag: retire jtag_get/set_end_state()
    
    Voila! This get rids of mysteries about what what
    state the TAP is in.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index a09472a..65ca824 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -86,7 +86,6 @@ static struct jtag_tap *__jtag_all_taps = NULL;
 static unsigned jtag_num_taps = 0;
 
 static enum reset_types jtag_reset_config = RESET_NONE;
-static tap_state_t cmd_queue_end_state = TAP_RESET;
 tap_state_t cmd_queue_cur_state = TAP_RESET;
 
 static bool jtag_verify_capture_ir = true;
@@ -717,7 +716,6 @@ void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 	 */
 	if (trst_with_tlr) {
 		LOG_DEBUG("JTAG reset with TLR instead of TRST");
-		jtag_set_end_state(TAP_RESET);
 		jtag_add_tlr();
 
 	} else if (jtag_trst != new_trst) {
@@ -743,24 +741,6 @@ void jtag_add_reset(int req_tlr_or_trst, int req_srst)
 	}
 }
 
-/* DEPRECATED! store such global state outside JTAG layer */
-void jtag_set_end_state(tap_state_t state)
-{
-	if ((state == TAP_DRSHIFT)||(state == TAP_IRSHIFT))
-	{
-		LOG_ERROR("BUG: TAP_DRSHIFT/IRSHIFT can't be end state. Calling code should use a larger scan field");
-	}
-
-	if (state != TAP_INVALID)
-		cmd_queue_end_state = state;
-}
-
-/* DEPRECATED! store such global state outside JTAG layer */
-tap_state_t jtag_get_end_state(void)
-{
-	return cmd_queue_end_state;
-}
-
 void jtag_add_sleep(uint32_t us)
 {
 	/// @todo Here, keep_alive() appears to be a layering violation!!!
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index a92c986..a6d16e9 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -550,26 +550,6 @@ void jtag_add_runtest(int num_cycles, tap_state_t endstate);
  */
 void jtag_add_reset(int req_tlr_or_trst, int srst);
 
-
-/**
- * DEPRECATED! store such global state outside JTAG layer
- *
- * Function jtag_set_end_state
- *
- * Set a global variable to \a state if \a state != TAP_INVALID.
- *
- */
-void jtag_set_end_state(tap_state_t state);
-
-/**
- * DEPRECATED! store such global state outside JTAG layer
- * 
- * Function jtag_get_end_state
- *
- * Return the value of the global variable for end state
- */
-tap_state_t jtag_get_end_state(void);
-
 void jtag_add_sleep(uint32_t us);
 
 int jtag_add_tms_seq(unsigned nbits, const uint8_t *seq, enum tap_state t);
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index 93509de..b2833fa 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -141,7 +141,6 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 	if ((retval = xilinx_read_bit_file(&bit_file, filename)) != ERROR_OK)
 		return retval;
 
-	jtag_set_end_state(TAP_IDLE);
 	virtex2_set_instr(virtex2_info->tap, 0xb); /* JPROG_B */
 	jtag_execute_queue();
 	jtag_add_sleep(1000);
@@ -160,7 +159,6 @@ static int virtex2_load(struct pld_device *pld_device, const char *filename)
 
 	jtag_add_tlr();
 
-	jtag_set_end_state(TAP_IDLE);
 	virtex2_set_instr(virtex2_info->tap, 0xc); /* JSTART */
 	jtag_add_runtest(13, TAP_IDLE);
 	virtex2_set_instr(virtex2_info->tap, 0x3f); /* BYPASS */
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index d59465b..0d795fb 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -87,7 +87,6 @@ int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	struct scan_field fields[2];
 	uint8_t out_addr_buf;
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, instr, NULL, TAP_IDLE);
 
 	/* Scan out a read or write operation using some DP or AP register.
@@ -331,7 +330,6 @@ static int jtag_idcode_q_read(struct adiv5_dap *dap,
 	struct scan_field fields[1];
 
 	/* This is a standard JTAG operation -- no DAP tweakage */
-	jtag_set_end_state(TAP_IDLE);
 	retval = arm_jtag_set_instr(jtag_info, JTAG_DP_IDCODE, NULL, TAP_IDLE);
 	if (retval != ERROR_OK)
 		return retval;
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 6e72c7a..0093360 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -54,7 +54,6 @@ static int arm720t_scan_cp15(struct target *target,
 
 	buf_set_u32(out_buf, 0, 32, flip_u32(out, 32));
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 4c8d83d..8f63f3c 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -687,7 +687,6 @@ int arm7_9_execute_sys_speed(struct target *target)
 	struct reg *dbg_stat = &arm7_9->eice_cache->reg_list[EICE_DBG_STAT];
 
 	/* set RESTART instruction */
-	jtag_set_end_state(TAP_IDLE);
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
 		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
@@ -740,7 +739,6 @@ int arm7_9_execute_fast_sys_speed(struct target *target)
 	struct reg *dbg_stat = &arm7_9->eice_cache->reg_list[EICE_DBG_STAT];
 
 	/* set RESTART instruction */
-	jtag_set_end_state(TAP_IDLE);
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
 		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
@@ -1743,7 +1741,6 @@ int arm7_9_restart_core(struct target *target)
 	struct arm_jtag *jtag_info = &arm7_9->jtag_info;
 
 	/* set RESTART instruction */
-	jtag_set_end_state(TAP_IDLE);
 	if (arm7_9->need_bypass_before_restart) {
 		arm7_9->need_bypass_before_restart = 0;
 		arm_jtag_set_instr(jtag_info, 0xf, NULL, TAP_IDLE);
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index f145275..541adc8 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -56,8 +56,6 @@ static int arm7tdmi_examine_debug_reason(struct target *target)
 		uint8_t databus[4];
 		uint8_t breakpoint;
 
-		jtag_set_end_state(TAP_DRPAUSE);
-
 		fields[0].num_bits = 1;
 		fields[0].out_value = NULL;
 		fields[0].in_value = &breakpoint;
@@ -119,7 +117,6 @@ static __inline int arm7tdmi_clock_out_inner(struct arm_jtag *jtag_info, uint32_
 static __inline int arm7tdmi_clock_out(struct arm_jtag *jtag_info,
 		uint32_t out, uint32_t *deprecated, int breakpoint)
 {
-	jtag_set_end_state(TAP_DRPAUSE);
 	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
 
@@ -132,7 +129,6 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	int retval = ERROR_OK;
 	struct scan_field fields[2];
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
@@ -217,7 +213,6 @@ static int arm7tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	int retval = ERROR_OK;
 	struct scan_field fields[2];
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 2e7c72d..4916de1 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -91,7 +91,6 @@ static int arm920t_read_cp15_physical(struct target *target,
 
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
@@ -142,7 +141,6 @@ static int arm920t_write_cp15_physical(struct target *target,
 
 	buf_set_u32(value_buf, 0, 32, value);
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
@@ -192,7 +190,6 @@ static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 
 	jtag_info = &arm920t->arm7_9_common.jtag_info;
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf, TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index c45d984..ff18bae 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -63,7 +63,6 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 
 	buf_set_u32(address_buf, 0, 14, address);
 
-	jtag_set_end_state(TAP_IDLE);
 	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
@@ -152,7 +151,6 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	buf_set_u32(address_buf, 0, 14, address);
 	buf_set_u32(value_buf, 0, 32, value);
 
-	jtag_set_end_state(TAP_IDLE);
 	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index c1e8058..b4207c8 100644
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -84,7 +84,6 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	uint8_t reg_addr_buf = reg_addr & 0x3f;
 	uint8_t nr_w_buf = 0;
 
-	jtag_set_end_state(TAP_IDLE);
 	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
@@ -139,7 +138,6 @@ int arm966e_write_cp15(struct target *target, int reg_addr, uint32_t value)
 
 	buf_set_u32(value_buf, 0, 32, value);
 
-	jtag_set_end_state(TAP_IDLE);
 	if ((retval = arm_jtag_scann(jtag_info, 0xf, TAP_IDLE)) != ERROR_OK)
 	{
 		return retval;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 4f28599..744ee76 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -87,8 +87,6 @@ int arm9tdmi_examine_debug_reason(struct target *target)
 		uint8_t instructionbus[4];
 		uint8_t debug_reason;
 
-		jtag_set_end_state(TAP_DRPAUSE);
-
 		fields[0].num_bits = 32;
 		fields[0].out_value = NULL;
 		fields[0].in_value = databus;
@@ -154,7 +152,6 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 	if (sysspeed)
 		buf_set_u32(&sysspeed_buf, 2, 1, 1);
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
@@ -213,7 +210,6 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 	int retval = ERROR_OK;;
 	struct scan_field fields[3];
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
@@ -280,7 +276,6 @@ int arm9tdmi_clock_data_in_endianness(struct arm_jtag *jtag_info,
 	int retval = ERROR_OK;
 	struct scan_field fields[3];
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	if ((retval = arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE)) != ERROR_OK)
 	{
 		return retval;
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 9272f66..59cd562 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -343,7 +343,6 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
 	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
@@ -405,7 +404,6 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
@@ -490,7 +488,6 @@ void embeddedice_write_reg(struct reg *reg, uint32_t value)
 
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", ice_reg->addr, value);
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(ice_reg->jtag_info, 0x2, TAP_IDLE);
 
 	arm_jtag_set_instr(ice_reg->jtag_info, ice_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
@@ -523,7 +520,6 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
@@ -576,7 +572,6 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 	else
 		return ERROR_INVALID_ARGUMENTS;
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2, TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_IDLE);
 
diff --git a/src/target/etb.c b/src/target/etb.c
index 96a6e0d..3280874 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -173,7 +173,6 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 	struct scan_field fields[3];
 	int i;
 
-	jtag_set_end_state(TAP_IDLE);
 	etb_scann(etb, 0x0);
 	etb_set_instr(etb, 0xc);
 
@@ -227,7 +226,6 @@ static int etb_read_reg_w_check(struct reg *reg,
 
 	LOG_DEBUG("%i", (int)(etb_reg->addr));
 
-	jtag_set_end_state(TAP_IDLE);
 	etb_scann(etb_reg->etb, 0x0);
 	etb_set_instr(etb_reg->etb, 0xc);
 
@@ -310,7 +308,6 @@ static int etb_write_reg(struct reg *reg, uint32_t value)
 
 	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", (int)(etb_reg->addr), value);
 
-	jtag_set_end_state(TAP_IDLE);
 	etb_scann(etb_reg->etb, 0x0);
 	etb_set_instr(etb_reg->etb, 0xc);
 
diff --git a/src/target/etm.c b/src/target/etm.c
index 3c25f4e..3850ced 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -504,7 +504,6 @@ static int etm_read_reg_w_check(struct reg *reg,
 
 	LOG_DEBUG("%s (%u)", r->name, reg_addr);
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
 	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
@@ -587,7 +586,6 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 
 	LOG_DEBUG("%s (%u): 0x%8.8" PRIx32 "", r->name, reg_addr, value);
 
-	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(etm_reg->jtag_info, 0x6, TAP_IDLE);
 	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL, TAP_IDLE);
 
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 405c50c..efd3040 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -84,7 +84,6 @@ int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 
 	buf_set_u32(instr_buf, 0, 32, flip_u32(instr, 32));
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	arm_jtag_scann(jtag_info, 0x1, TAP_DRPAUSE);
 
 	arm_jtag_set_instr(jtag_info, jtag_info->intest_instr, NULL, TAP_DRPAUSE);
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index d79c58d..37e1f09 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -56,8 +56,6 @@ int mips_ejtag_get_idcode(struct mips_ejtag *ejtag_info, uint32_t *idcode)
 {
 	struct scan_field field;
 
-	jtag_set_end_state(TAP_IDLE);
-
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE);
 
 	field.num_bits = 32;
@@ -78,8 +76,6 @@ int mips_ejtag_get_impcode(struct mips_ejtag *ejtag_info, uint32_t *impcode)
 {
 	struct scan_field field;
 
-	jtag_set_end_state(TAP_IDLE);
-
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE);
 
 	field.num_bits = 32;
@@ -209,7 +205,6 @@ int mips_ejtag_config_step(struct mips_ejtag *ejtag_info, int enable_step)
 int mips_ejtag_enter_debug(struct mips_ejtag *ejtag_info)
 {
 	uint32_t ejtag_ctrl;
-	jtag_set_end_state(TAP_IDLE);
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 
 	/* set debug break bit */
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 5919f5b..5604b6a 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -112,7 +112,6 @@ int mips_m4k_poll(struct target *target)
 	uint32_t ejtag_ctrl = ejtag_info->ejtag_ctrl;
 
 	/* read ejtag control reg */
-	jtag_set_end_state(TAP_IDLE);
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
 	mips_ejtag_drscan_32(ejtag_info, &ejtag_ctrl);
 
@@ -122,7 +121,6 @@ int mips_m4k_poll(struct target *target)
 	{
 		/* we have detected a reset, clear flag
 		 * otherwise ejtag will not work */
-		jtag_set_end_state(TAP_IDLE);
 		ejtag_ctrl = ejtag_info->ejtag_ctrl & ~EJTAG_CTRL_ROCC;
 
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL);
@@ -135,7 +133,6 @@ int mips_m4k_poll(struct target *target)
 	{
 		if ((target->state == TARGET_RUNNING) || (target->state == TARGET_RESET))
 		{
-			jtag_set_end_state(TAP_IDLE);
 			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
 
 			target->state = TARGET_HALTED;
@@ -227,12 +224,10 @@ int mips_m4k_assert_reset(struct target *target)
 	if (target->reset_halt)
 	{
 		/* use hardware to catch reset */
-		jtag_set_end_state(TAP_IDLE);
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_EJTAGBOOT);
 	}
 	else
 	{
-		jtag_set_end_state(TAP_IDLE);
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT);
 	}
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index f22513a..f0e2311 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -191,7 +191,6 @@ static int xscale_read_dcsr(struct target *target)
 	uint8_t field2_check_value = 0x0;
 	uint8_t field2_check_mask = 0x1;
 
-	jtag_set_end_state(TAP_DRPAUSE);
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_SELDCSR << xscale->xscale_variant,
 		TAP_DRPAUSE);
@@ -235,8 +234,6 @@ static int xscale_read_dcsr(struct target *target)
 	fields[1].out_value = xscale->reg_cache->reg_list[XSCALE_DCSR].value;
 	fields[1].in_value = NULL;
 
-	jtag_set_end_state(TAP_IDLE);
-
 	jtag_add_dr_scan(target->tap, 3, fields, TAP_DRPAUSE);
 
 	/* DANGER!!! this must be here. It will make sure that the arguments
@@ -286,7 +283,6 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 	fields[2].check_value = &field2_check_value;
 	fields[2].check_mask = &field2_check_mask;
 
-	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_DBGTX << xscale->xscale_variant,
 		TAP_IDLE);
@@ -369,8 +365,6 @@ static int xscale_read_tx(struct target *target, int consume)
 	uint8_t field2_check_value = 0x0;
 	uint8_t field2_check_mask = 0x1;
 
-	jtag_set_end_state(TAP_IDLE);
-
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_DBGTX << xscale->xscale_variant,
 		TAP_IDLE);
@@ -466,8 +460,6 @@ static int xscale_write_rx(struct target *target)
 	uint8_t field2_check_value = 0x0;
 	uint8_t field2_check_mask = 0x1;
 
-	jtag_set_end_state(TAP_IDLE);
-
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_DBGRX << xscale->xscale_variant,
 		TAP_IDLE);
@@ -545,8 +537,6 @@ static int xscale_send(struct target *target, uint8_t *buffer, int count, int si
 	int retval;
 	int done_count = 0;
 
-	jtag_set_end_state(TAP_IDLE);
-
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_DBGRX << xscale->xscale_variant,
 		TAP_IDLE);
@@ -629,7 +619,6 @@ static int xscale_write_dcsr(struct target *target, int hold_rst, int ext_dbg_br
 	if (ext_dbg_brk != -1)
 		xscale->external_debug_break = ext_dbg_brk;
 
-	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_SELDCSR << xscale->xscale_variant,
 		TAP_IDLE);
@@ -692,7 +681,6 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 	LOG_DEBUG("loading miniIC at 0x%8.8" PRIx32 "", va);
 
 	/* LDIC into IR */
-	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_LDIC << xscale->xscale_variant,
 		TAP_IDLE);
@@ -744,7 +732,6 @@ static int xscale_invalidate_ic_line(struct target *target, uint32_t va)
 	uint8_t cmd;
 	struct scan_field fields[2];
 
-	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_LDIC << xscale->xscale_variant,
 		TAP_IDLE);
@@ -1484,7 +1471,6 @@ static int xscale_assert_reset(struct target *target)
 	/* select DCSR instruction (set endstate to R-T-I to ensure we don't
 	 * end up in T-L-R, which would reset JTAG
 	 */
-	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
 		XSCALE_SELDCSR << xscale->xscale_variant,
 		TAP_IDLE);

commit 15ff2aeca9b302419aed62fc3cc73dedacdd62cb
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 18 18:41:43 2010 +0100

    jtag: remove jtag_get_end_state() usage
    
    Code inspection indicated what constant end states to
    use.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 3ea23d4..d79c58d 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -46,7 +46,7 @@ int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 	}
 
 	return ERROR_OK;
@@ -112,7 +112,7 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 	buf_set_u32(field.out_value, 0, field.num_bits, *data);
 	field.in_value = r;
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -143,7 +143,7 @@ int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 	buf_set_u32(field.out_value, 0, field.num_bits, *data);
 	field.in_value = r;
 
-	jtag_add_dr_scan(tap, 1, &field, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -339,7 +339,7 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t
 		fields[1].in_value = (uint8_t *) data;
 	}
 
-	jtag_add_dr_scan(tap, 2, fields, jtag_get_end_state());
+	jtag_add_dr_scan(tap, 2, fields, TAP_IDLE);
 	keep_alive();
 
 	return ERROR_OK;

commit 1911c8ec8d286840c6a0d6a57c423072766d3386
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 18 18:37:23 2010 +0100

    jtag: get rid of unecessary jtag_get_end_state()
    
    By code inspection.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index 55323ae..f22513a 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -158,7 +158,7 @@ static int xscale_verify_pointer(struct command_context *cmd_ctx,
 	return ERROR_OK;
 }
 
-static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr)
+static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end_state)
 {
 	if (tap == NULL)
 		return ERROR_FAIL;
@@ -173,7 +173,7 @@ static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		field.out_value = scratch;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
-		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, end_state);
 	}
 
 	return ERROR_OK;
@@ -193,7 +193,8 @@ static int xscale_read_dcsr(struct target *target)
 
 	jtag_set_end_state(TAP_DRPAUSE);
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_SELDCSR << xscale->xscale_variant);
+		XSCALE_SELDCSR << xscale->xscale_variant,
+		TAP_DRPAUSE);
 
 	buf_set_u32(&field0, 1, 1, xscale->hold_rst);
 	buf_set_u32(&field0, 2, 1, xscale->external_debug_break);
@@ -287,7 +288,8 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 
 	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_DBGTX << xscale->xscale_variant);
+		XSCALE_DBGTX << xscale->xscale_variant,
+		TAP_IDLE);
 	jtag_add_runtest(1, TAP_IDLE); /* ensures that we're in the TAP_IDLE state as the above could be a no-op */
 
 	/* repeat until all words have been collected */
@@ -370,7 +372,8 @@ static int xscale_read_tx(struct target *target, int consume)
 	jtag_set_end_state(TAP_IDLE);
 
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_DBGTX << xscale->xscale_variant);
+		XSCALE_DBGTX << xscale->xscale_variant,
+		TAP_IDLE);
 
 	path[0] = TAP_DRSELECT;
 	path[1] = TAP_DRCAPTURE;
@@ -466,7 +469,8 @@ static int xscale_write_rx(struct target *target)
 	jtag_set_end_state(TAP_IDLE);
 
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_DBGRX << xscale->xscale_variant);
+		XSCALE_DBGRX << xscale->xscale_variant,
+		TAP_IDLE);
 
 	memset(&fields, 0, sizeof fields);
 
@@ -544,7 +548,8 @@ static int xscale_send(struct target *target, uint8_t *buffer, int count, int si
 	jtag_set_end_state(TAP_IDLE);
 
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_DBGRX << xscale->xscale_variant);
+		XSCALE_DBGRX << xscale->xscale_variant,
+		TAP_IDLE);
 
 	bits[0]=3;
 	t[0]=0;
@@ -626,7 +631,8 @@ static int xscale_write_dcsr(struct target *target, int hold_rst, int ext_dbg_br
 
 	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_SELDCSR << xscale->xscale_variant);
+		XSCALE_SELDCSR << xscale->xscale_variant,
+		TAP_IDLE);
 
 	buf_set_u32(&field0, 1, 1, xscale->hold_rst);
 	buf_set_u32(&field0, 2, 1, xscale->external_debug_break);
@@ -688,7 +694,8 @@ static int xscale_load_ic(struct target *target, uint32_t va, uint32_t buffer[8]
 	/* LDIC into IR */
 	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_LDIC << xscale->xscale_variant);
+		XSCALE_LDIC << xscale->xscale_variant,
+		TAP_IDLE);
 
 	/* CMD is b011 to load a cacheline into the Mini ICache.
 	 * Loading into the main ICache is deprecated, and unused.
@@ -739,7 +746,8 @@ static int xscale_invalidate_ic_line(struct target *target, uint32_t va)
 
 	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_LDIC << xscale->xscale_variant);
+		XSCALE_LDIC << xscale->xscale_variant,
+		TAP_IDLE);
 
 	/* CMD for invalidate IC line b000, bits [6:4] b000 */
 	buf_set_u32(&cmd, 0, 6, 0x0);
@@ -1478,7 +1486,8 @@ static int xscale_assert_reset(struct target *target)
 	 */
 	jtag_set_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(target->tap,
-		XSCALE_SELDCSR << xscale->xscale_variant);
+		XSCALE_SELDCSR << xscale->xscale_variant,
+		TAP_IDLE);
 
 	/* set Hold reset, Halt mode and Trap Reset */
 	buf_set_u32(xscale->reg_cache->reg_list[XSCALE_DCSR].value, 30, 1, 0x1);
@@ -1486,7 +1495,7 @@ static int xscale_assert_reset(struct target *target)
 	xscale_write_dcsr(target, 1, 0);
 
 	/* select BYPASS, because having DCSR selected caused problems on the PXA27x */
-	xscale_jtag_set_instr(target->tap, ~0);
+	xscale_jtag_set_instr(target->tap, ~0, TAP_IDLE);
 	jtag_execute_queue();
 
 	/* assert reset */

commit 729845238228f577bc3d6369d83667e5e2df1aee
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 18 18:34:34 2010 +0100

    jtag: remove unecessary usage of jtag_get_end_state().
    
    By code inspection.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/etb.c b/src/target/etb.c
index 9971070..96a6e0d 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -60,7 +60,7 @@ static int etb_set_instr(struct etb *etb, uint32_t new_instr)
 
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(tap, &field, jtag_get_end_state());
+		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 
 		free(field.out_value);
 	}
@@ -82,7 +82,7 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 
 		/* select INTEST instruction */
 		etb_set_instr(etb, 0x2);
-		jtag_add_dr_scan(etb->tap, 1, &field, jtag_get_end_state());
+		jtag_add_dr_scan(etb->tap, 1, &field, TAP_IDLE);
 
 		etb->cur_scan_chain = new_scan_chain;
 

commit 8ce828dd382c907db4c6bd38e5b54996e50327fd
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 18 18:31:58 2010 +0100

    jtag: remove jtag_get_end_state()'s that should be unecessary
    
    By a bit of code inspection it seems like all of these
    instances of jtag_get_end_state() can be unambigously
    replaced by constants.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 177d286..9b8b480 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -849,7 +849,7 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 		}
 	} else
 	{
-		tap_state_t end_state = jtag_get_end_state();
+		tap_state_t end_state = TAP_IDLE;
 		tap_state_t shift_end_state;
 		if (post_bits == 0)
 			shift_end_state = end_state;
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 85c6816..4c8d83d 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -995,7 +995,7 @@ int arm7_9_assert_reset(struct target *target)
 			 * certain ARM9 cores (maybe more) - AT91SAM9260
 			 * and STR9
 			 */
-			jtag_add_runtest(1, jtag_get_end_state());
+			jtag_add_runtest(1, TAP_IDLE);
 		}
 		else
 		{
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 25151ff..f145275 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -104,9 +104,9 @@ static __inline int arm7tdmi_clock_out_inner(struct arm_jtag *jtag_info, uint32_
 			2,
 			arm7tdmi_num_bits,
 			values,
-			jtag_get_end_state());
+			TAP_DRPAUSE);
 
-	jtag_add_runtest(0, jtag_get_end_state());
+	jtag_add_runtest(0, TAP_DRPAUSE);
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index b4b6f04..4f28599 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -186,7 +186,7 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 	}
 
-	jtag_add_runtest(0, jtag_get_end_state());
+	jtag_add_runtest(0, TAP_DRPAUSE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	{
diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
index cd48ce6..d278115 100644
--- a/src/target/embeddedice.h
+++ b/src/target/embeddedice.h
@@ -128,7 +128,7 @@ static __inline__ void embeddedice_write_reg_inner(struct jtag_tap *tap, int reg
 			2,
 			embeddedice_num_bits,
 			values,
-			jtag_get_end_state());
+			TAP_IDLE);
 }
 
 void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count);

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c            |   20 ------------------
 src/jtag/jtag.h            |   20 ------------------
 src/jtag/zy1000/zy1000.c   |    2 +-
 src/pld/virtex2.c          |    2 -
 src/target/adi_v5_jtag.c   |    2 -
 src/target/arm720t.c       |    1 -
 src/target/arm7_9_common.c |    5 +---
 src/target/arm7tdmi.c      |    9 +------
 src/target/arm920t.c       |    3 --
 src/target/arm926ejs.c     |    2 -
 src/target/arm966e.c       |    2 -
 src/target/arm9tdmi.c      |    7 +-----
 src/target/embeddedice.c   |    5 ----
 src/target/embeddedice.h   |    2 +-
 src/target/etb.c           |    7 +----
 src/target/etm.c           |    2 -
 src/target/feroceon.c      |    1 -
 src/target/mips_ejtag.c    |   13 +++--------
 src/target/mips_m4k.c      |    5 ----
 src/target/xscale.c        |   47 +++++++++++++++++++------------------------
 20 files changed, 33 insertions(+), 124 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar 19 14:28:48 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri, 19 Mar 2010 13:28:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-119-g03359b1
Message-ID: <E1NscFu-00009C-BE@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  03359b16800c618ea4489d086bac9cd26a8d4547 (commit)
      from  7f6bab0c4c36d7a64f933904e5add9bc6b36d78c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 03359b16800c618ea4489d086bac9cd26a8d4547
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Mar 19 14:27:19 2010 +0100

    zy1000: fix bug in end state of DCC writes
    
    Introduced in latest commits, found by code inspection &
    GCC warning.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 9b8b480..a844dc3 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -775,7 +775,7 @@ int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 
 	uint8_t seq[16];
 	memset(seq, 0, sizeof(seq));
-	assert(num_states < (sizeof(seq) * 8));
+	assert(num_states < (int)((sizeof(seq) * 8)));
 
 	while (num_states)
 	{
@@ -850,7 +850,7 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 	} else
 	{
 		tap_state_t end_state = TAP_IDLE;
-		tap_state_t shift_end_state;
+		tap_state_t shift_end_state = TAP_DRSHIFT;
 		if (post_bits == 0)
 			shift_end_state = end_state;
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar 19 14:48:01 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri, 19 Mar 2010 13:48:01 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-120-g7373d1c
Message-ID: <E1NscYW-0001B2-Jh@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7373d1c342ff0ef5c0663fcee2f688eb5eb4ef65 (commit)
      from  03359b16800c618ea4489d086bac9cd26a8d4547 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7373d1c342ff0ef5c0663fcee2f688eb5eb4ef65
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Mar 19 14:47:01 2010 +0100

    zy1000: clean up jtag_add_xx_scan fn's
    
    The implementation is now more straightforward as the
    scan_fields have been greatly simplified over time.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index a844dc3..6f75e59 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -492,103 +492,93 @@ static void shiftValueInnerFlip(const tap_state_t state, const tap_state_t endSt
 }
 #endif
 
-static void gotoEndState(tap_state_t end_state)
+// here we shuffle N bits out/in
+static __inline void scanBits(const uint8_t *out_value, uint8_t *in_value, int num_bits, bool pause, tap_state_t shiftState, tap_state_t end_state)
 {
-	setCurrentState(end_state);
-}
-
-static __inline void scanFields(int num_fields, const struct scan_field *fields, tap_state_t shiftState, int pause)
-{
-	int i;
-	int j;
-	int k;
-
-	for (i = 0; i < num_fields; i++)
+	tap_state_t pause_state = shiftState;
+	for (int j = 0; j < num_bits; j += 32)
 	{
-		cyg_uint32 value;
-
-		uint8_t *inBuffer = NULL;
-
-
-		// figure out where to store the input data
-		int num_bits = fields[i].num_bits;
-		if (fields[i].in_value != NULL)
+		int k = num_bits - j;
+		if (k > 32)
 		{
-			inBuffer = fields[i].in_value;
+			k = 32;
+			/* we have more to shift out */
+		} else if (pause)
+		{
+			/* this was the last to shift out this time */
+			pause_state = end_state;
 		}
 
-		// here we shuffle N bits out/in
-		j = 0;
-		while (j < num_bits)
+		// we have (num_bits + 7)/8 bytes of bits to toggle out.
+		// bits are pushed out LSB to MSB
+		cyg_uint32 value;
+		value = 0;
+		if (out_value != NULL)
 		{
-			tap_state_t pause_state;
-			int l;
-			k = num_bits-j;
-			pause_state = (shiftState == TAP_DRSHIFT)?TAP_DRSHIFT:TAP_IRSHIFT;
-			if (k > 32)
-			{
-				k = 32;
-				/* we have more to shift out */
-			} else if (pause&&(i == num_fields-1))
+			for (int l = 0; l < k; l += 8)
 			{
-				/* this was the last to shift out this time */
-				pause_state = (shiftState==TAP_DRSHIFT)?TAP_DRPAUSE:TAP_IRPAUSE;
+				value|=out_value[(j + l)/8]<<l;
 			}
+		}
+		/* mask away unused bits for easier debugging */
+		if (k < 32)
+		{
+			value&=~(((uint32_t)0xffffffff) << k);
+		} else
+		{
+			/* Shifting by >= 32 is not defined by the C standard
+			 * and will in fact shift by &0x1f bits on nios */
+		}
 
-			// we have (num_bits + 7)/8 bytes of bits to toggle out.
-			// bits are pushed out LSB to MSB
-			value = 0;
-			if (fields[i].out_value != NULL)
-			{
-				for (l = 0; l < k; l += 8)
-				{
-					value|=fields[i].out_value[(j + l)/8]<<l;
-				}
-			}
-			/* mask away unused bits for easier debugging */
-			if (k < 32)
-			{
-				value&=~(((uint32_t)0xffffffff) << k);
-			} else
-			{
-				/* Shifting by >= 32 is not defined by the C standard
-				 * and will in fact shift by &0x1f bits on nios */
-			}
+		shiftValueInner(shiftState, pause_state, k, value);
 
-			shiftValueInner(shiftState, pause_state, k, value);
+		if (in_value != NULL)
+		{
+			// data in, LSB to MSB
+			value = getShiftValue();
+			// we're shifting in data to MSB, shift data to be aligned for returning the value
+			value >>= 32-k;
 
-			if (inBuffer != NULL)
+			for (int l = 0; l < k; l += 8)
 			{
-				// data in, LSB to MSB
-				value = getShiftValue();
-				// we're shifting in data to MSB, shift data to be aligned for returning the value
-				value >>= 32-k;
-
-				for (l = 0; l < k; l += 8)
-				{
-					inBuffer[(j + l)/8]=(value >> l)&0xff;
-				}
+				in_value[(j + l)/8]=(value >> l)&0xff;
 			}
-			j += k;
 		}
 	}
 }
 
+static __inline void scanFields(int num_fields, const struct scan_field *fields, tap_state_t shiftState, tap_state_t end_state)
+{
+	for (int i = 0; i < num_fields; i++)
+	{
+		scanBits(fields[i].out_value,
+				fields[i].in_value,
+				fields[i].num_bits,
+				(i == num_fields-1),
+				shiftState,
+				end_state);
+	}
+}
+
 int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field *fields, tap_state_t state)
 {
 	int scan_size = 0;
 	struct jtag_tap *tap, *nextTap;
+	tap_state_t pause_state = TAP_IRSHIFT;
 
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
-		bool pause = (nextTap==NULL);
+		if (nextTap==NULL)
+		{
+			pause_state = state;
+		}
 		scan_size = tap->ir_length;
 
 		/* search the list */
 		if (tap == active)
 		{
-			scanFields(1, fields, TAP_IRSHIFT, pause);
+			scanFields(1, fields, TAP_IRSHIFT, pause_state);
 			/* update device information */
 			buf_cpy(fields[0].out_value, tap->cur_instr, scan_size);
 
@@ -597,12 +587,11 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field
 		{
 			/* if a device isn't listed, set it to BYPASS */
 			assert(scan_size <= 32);
-			shiftValueInner(TAP_IRSHIFT, pause?TAP_IRPAUSE:TAP_IRSHIFT, scan_size, 0xffffffff);
+			shiftValueInner(TAP_IRSHIFT, pause_state, scan_size, 0xffffffff);
 
 			tap->bypass = 1;
 		}
 	}
-	gotoEndState(state);
 
 	return ERROR_OK;
 }
@@ -613,51 +602,41 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active, const struct scan_field
 
 int interface_jtag_add_plain_ir_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
-	struct scan_field field;
-	field.num_bits	= num_bits;
-	field.out_value	= out_bits;
-	field.in_value	= in_bits;
-
-	scanFields(1, &field, TAP_IRSHIFT, 1);
-	gotoEndState(state);
-
+	scanBits(out_bits, in_bits, num_bits, true, TAP_IRSHIFT, state);
 	return ERROR_OK;
 }
 
 int interface_jtag_add_dr_scan(struct jtag_tap *active, int num_fields, const struct scan_field *fields, tap_state_t state)
 {
 	struct jtag_tap *tap, *nextTap;
+	tap_state_t pause_state = TAP_DRSHIFT;
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
 		nextTap = jtag_tap_next_enabled(tap);
-		bool pause = (nextTap==NULL);
+		if (nextTap==NULL)
+		{
+			pause_state = state;
+		}
 
 		/* Find a range of fields to write to this tap */
 		if (tap == active)
 		{
 			assert(!tap->bypass);
 
-			scanFields(num_fields, fields, TAP_DRSHIFT, pause);
+			scanFields(num_fields, fields, TAP_DRSHIFT, pause_state);
 		} else
 		{
 			/* Shift out a 0 for disabled tap's */
 			assert(tap->bypass);
-			shiftValueInner(TAP_DRSHIFT, pause?TAP_DRPAUSE:TAP_DRSHIFT, 1, 0);
+			shiftValueInner(TAP_DRSHIFT, pause_state, 1, 0);
 		}
 	}
-	gotoEndState(state);
 	return ERROR_OK;
 }
 
 int interface_jtag_add_plain_dr_scan(int num_bits, const uint8_t *out_bits, uint8_t *in_bits, tap_state_t state)
 {
-	struct scan_field field;
-	field.num_bits	= num_bits;
-	field.out_value	= out_bits;
-	field.in_value	= in_bits;
-
-	scanFields(1, &field, TAP_DRSHIFT, 1);
-	gotoEndState(state);
+	scanBits(out_bits, in_bits, num_bits, true, TAP_DRSHIFT, state);
 	return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |  155 ++++++++++++++++++++--------------------------
 1 files changed, 67 insertions(+), 88 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Mar 19 20:15:23 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 19 Mar 2010 19:15:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-121-g3b310db
Message-ID: <E1NshfJ-0006f4-Q3@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3b310dbac5ae1db7fb768aa0789bbe101137c7e1 (commit)
      from  7373d1c342ff0ef5c0663fcee2f688eb5eb4ef65 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3b310dbac5ae1db7fb768aa0789bbe101137c7e1
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Mar 19 10:31:44 2010 -0700

    FT2232 comment tweaks
    
    Note that the FT4232 chips have four channels not two, and
    Elaborate on uses of the additional channels.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index b45e8a4..8e835c5 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -32,12 +32,24 @@
  * JTAG adapters based on the FT2232 full and high speed USB parts are
  * popular low cost JTAG debug solutions.  Many FT2232 based JTAG adapters
  * are discrete, but development boards may integrate them as alternatives
- * to more capable (and expensive) third party JTAG pods.  Since JTAG uses
- * only one of the two ports on these devices, on integrated boards the
- * second port often serves as a USB-to-serial adapter for the target's
- * console UART even when the JTAG port is not in use.  (Systems which
- * support ARM's SWD in addition to JTAG, or instead of it, may use that
- * second port for reading SWV trace data.)
+ * to more capable (and expensive) third party JTAG pods.
+ *
+ * JTAG uses only one of the two communications channels ("MPSSE engines")
+ * on these devices.  Adapters based on FT4232 parts have four ports/channels
+ * (A/B/C/D), instead of just two (A/B).
+ *
+ * Especially on development boards integrating one of these chips (as
+ * opposed to discrete pods/dongles), the additional channels can be used
+ * for a variety of purposes, but OpenOCD only uses one channel at a time.
+ *
+ *  - As a USB-to-serial adapter for the target's console UART ...
+ *    which may be able to support ROM boot loaders that load initial
+ *    firmware images to flash (or SRAM).
+ *
+ *  - On systems which support ARM's SWD in addition to JTAG, or instead
+ *    of it, that second port can be used for reading SWV/SWO trace data.
+ *
+ *  - Additional JTAG links, e.g. to a CPLD or * FPGA.
  *
  * FT2232 based JTAG adapters are "dumb" not "smart", because most JTAG
  * request/response interactions involve round trips over the USB link.

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |   24 ++++++++++++++++++------
 1 files changed, 18 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Mar 21 19:14:44 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Sun, 21 Mar 2010 18:14:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-123-g5dcad2d
Message-ID: <E1NtPfi-0006qv-UM@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5dcad2d34fc40659018da2cf75ceeacd3abea860 (commit)
       via  96949890ee29ab4b3ca15802302c5d93358b69e1 (commit)
      from  3b310dbac5ae1db7fb768aa0789bbe101137c7e1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5dcad2d34fc40659018da2cf75ceeacd3abea860
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Mar 19 22:06:01 2010 +0100

    jtag: make out_value const
    
    Tightens up the jtag_add_xxx_scan() API
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index a6d16e9..cdc02ab 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -2,7 +2,7 @@
 *   Copyright (C) 2005 by Dominic Rath                                    *
 *   Dominic.Rath at gmx.de                                                   *
 *                                                                         *
-*   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+*   Copyright (C) 2007-2010 ??yvind Harboe                                 *
 *   oyvind.harboe at zylin.com                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
@@ -112,7 +112,7 @@ struct scan_field {
 	/// The number of bits this field specifies (up to 32)
 	int num_bits;
 	/// A pointer to value to be scanned into the device
-	uint8_t* out_value;
+	const uint8_t* out_value;
 	/// A pointer to a 32-bit memory location for data scanned out
 	uint8_t* in_value;
 
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 90081cd..25516cf 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2009 SoftPLC Corporation                                *
@@ -176,9 +176,10 @@ static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args
 		str = Jim_GetString(args[i + 1], &len);
 
 		fields[field_count].num_bits = bits;
-		fields[field_count].out_value = malloc(DIV_ROUND_UP(bits, 8));
-		str_to_buf(str, len, fields[field_count].out_value, bits, 0);
-		fields[field_count].in_value = fields[field_count].out_value;
+		void * t = malloc(DIV_ROUND_UP(bits, 8));
+		fields[field_count].out_value = t;
+		str_to_buf(str, len, t, bits, 0);
+		fields[field_count].in_value = t;
 		field_count++;
 	}
 
@@ -200,7 +201,7 @@ static int Jim_Command_drscan(Jim_Interp *interp, int argc, Jim_Obj *const *args
 
 		Jim_GetLong(interp, args[i], &bits);
 		str = buf_to_str(fields[field_count].in_value, bits, 16);
-		free(fields[field_count].out_value);
+		free((void *)fields[field_count].out_value);
 
 		Jim_ListAppendElement(interp, list, Jim_NewStringObj(interp, str, strlen(str)));
 		free(str);
@@ -1511,7 +1512,7 @@ COMMAND_HANDLER(handle_irscan_command)
 		{
 			int j;
 			for (j = 0; j < i; j++)
-				free(fields[j].out_value);
+				free((void *)fields[j].out_value);
                         free(fields);
 			command_print(CMD_CTX, "Tap: %s unknown", CMD_ARGV[i*2]);
 
@@ -1525,7 +1526,7 @@ COMMAND_HANDLER(handle_irscan_command)
 		retval = parse_u32(CMD_ARGV[i * 2 + 1], &value);
 		if (ERROR_OK != retval)
 			goto error_return;
-		buf_set_u32(fields[i].out_value, 0, field_size, value);
+		buf_set_u32((void *)fields[i].out_value, 0, field_size, value);
 		fields[i].in_value = NULL;
 	}
 
@@ -1538,7 +1539,7 @@ error_return:
 	for (i = 0; i < num_fields; i++)
 	{
 		if (NULL != fields[i].out_value)
-			free(fields[i].out_value);
+			free((void *)fields[i].out_value);
 	}
 
 	free (fields);
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 59cd562..69f3a76 100644
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008,2009 ??yvind Harboe                            *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008 by Spencer Oliver                                  *
@@ -357,7 +357,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	/* bits 36:32 -- register */
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
-	fields[1].out_value[0] = reg_addr;
+	field1_out[0] = reg_addr;
 	fields[1].in_value = NULL;
 	fields[1].check_value = NULL;
 	fields[1].check_mask = NULL;
@@ -365,7 +365,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	/* bit 37 -- 0/read */
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
-	fields[2].out_value[0] = 0;
+	field2_out[0] = 0;
 	fields[2].in_value = NULL;
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
@@ -382,7 +382,7 @@ int embeddedice_read_reg_w_check(struct reg *reg,
 	 * EICE_COMMS_DATA would read the register twice
 	 * reading the control register is safe
 	 */
-	fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
+	field1_out[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 	/* traverse Update-DR, reading but with no other side effects */
 	jtag_add_dr_scan_check(ice_reg->jtag_info->tap, 3, fields, TAP_IDLE);
@@ -413,12 +413,12 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
-	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
+	field1_out[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
-	fields[2].out_value[0] = 0;
+	field2_out[0] = 0;
 	fields[2].in_value = NULL;
 
 	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
@@ -429,7 +429,7 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 		 * to avoid reading additional data from the DCC data reg
 		 */
 		if (size == 1)
-			fields[1].out_value[0] = eice_regs[EICE_COMMS_CTRL].addr;
+			field1_out[0] = eice_regs[EICE_COMMS_CTRL].addr;
 
 		fields[0].in_value = (uint8_t *)data;
 		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
@@ -529,18 +529,18 @@ int embeddedice_send(struct arm_jtag *jtag_info, uint32_t *data, uint32_t size)
 
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
-	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
+	field1_out[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
-	fields[2].out_value[0] = 1;
+	field2_out[0] = 1;
 
 	fields[2].in_value = NULL;
 
 	while (size > 0)
 	{
-		buf_set_u32(fields[0].out_value, 0, 32, *data);
+		buf_set_u32(field0_out, 0, 32, *data);
 		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
 		data++;
@@ -581,12 +581,12 @@ int embeddedice_handshake(struct arm_jtag *jtag_info, int hsbit, uint32_t timeou
 
 	fields[1].num_bits = 5;
 	fields[1].out_value = field1_out;
-	fields[1].out_value[0] = eice_regs[EICE_COMMS_DATA].addr;
+	field1_out[0] = eice_regs[EICE_COMMS_DATA].addr;
 	fields[1].in_value = NULL;
 
 	fields[2].num_bits = 1;
 	fields[2].out_value = field2_out;
-	fields[2].out_value[0] = 0;
+	field2_out[0] = 0;
 	fields[2].in_value = NULL;
 
 	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
diff --git a/src/target/etb.c b/src/target/etb.c
index 3280874..ba47c39 100644
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -55,14 +55,15 @@ static int etb_set_instr(struct etb *etb, uint32_t new_instr)
 		struct scan_field field;
 
 		field.num_bits = tap->ir_length;
-		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
-		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
+		void * t = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
+		field.out_value = t;
+		buf_set_u32(t, 0, field.num_bits, new_instr);
 
 		field.in_value = NULL;
 
 		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 
-		free(field.out_value);
+		free(t);
 	}
 
 	return ERROR_OK;
@@ -75,8 +76,9 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 		struct scan_field field;
 
 		field.num_bits = 5;
-		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
-		buf_set_u32(field.out_value, 0, field.num_bits, new_scan_chain);
+		void * t = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
+		field.out_value = t;
+		buf_set_u32(t, 0, field.num_bits, new_scan_chain);
 
 		field.in_value = NULL;
 
@@ -86,7 +88,7 @@ static int etb_scann(struct etb *etb, uint32_t new_scan_chain)
 
 		etb->cur_scan_chain = new_scan_chain;
 
-		free(field.out_value);
+		free(t);
 	}
 
 	return ERROR_OK;
@@ -181,13 +183,15 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 	fields[0].in_value = NULL;
 
 	fields[1].num_bits = 7;
-	fields[1].out_value = malloc(1);
-	buf_set_u32(fields[1].out_value, 0, 7, 4);
+	uint8_t temp1;
+	fields[1].out_value = &temp1;
+	buf_set_u32(&temp1, 0, 7, 4);
 	fields[1].in_value = NULL;
 
 	fields[2].num_bits = 1;
-	fields[2].out_value = malloc(1);
-	buf_set_u32(fields[2].out_value, 0, 1, 0);
+	uint8_t temp2;
+	fields[2].out_value = &temp2;
+	buf_set_u32(&temp2, 0, 1, 0);
 	fields[2].in_value = NULL;
 
 	jtag_add_dr_scan(etb->tap, 3, fields, TAP_IDLE);
@@ -195,13 +199,13 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 	for (i = 0; i < num_frames; i++)
 	{
 		/* ensure nR/W reamins set to read */
-		buf_set_u32(fields[2].out_value, 0, 1, 0);
+		buf_set_u32(&temp2, 0, 1, 0);
 
 		/* address remains set to 0x4 (RAM data) until we read the last frame */
 		if (i < num_frames - 1)
-			buf_set_u32(fields[1].out_value, 0, 7, 4);
+			buf_set_u32(&temp1, 0, 7, 4);
 		else
-			buf_set_u32(fields[1].out_value, 0, 7, 0);
+			buf_set_u32(&temp1, 0, 7, 0);
 
 		fields[0].in_value = (uint8_t *)(data + i);
 		jtag_add_dr_scan(etb->tap, 3, fields, TAP_IDLE);
@@ -211,9 +215,6 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 
 	jtag_execute_queue();
 
-	free(fields[1].out_value);
-	free(fields[2].out_value);
-
 	return ERROR_OK;
 }
 
@@ -236,15 +237,17 @@ static int etb_read_reg_w_check(struct reg *reg,
 	fields[0].check_mask = NULL;
 
 	fields[1].num_bits = 7;
-	fields[1].out_value = malloc(1);
-	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
+	uint8_t temp1;
+	fields[1].out_value = &temp1;
+	buf_set_u32(&temp1, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 	fields[1].check_value = NULL;
 	fields[1].check_mask = NULL;
 
 	fields[2].num_bits = 1;
-	fields[2].out_value = malloc(1);
-	buf_set_u32(fields[2].out_value, 0, 1, 0);
+	uint8_t temp2;
+	fields[2].out_value = &temp2;
+	buf_set_u32(&temp2, 0, 1, 0);
 	fields[2].in_value = NULL;
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
@@ -254,16 +257,13 @@ static int etb_read_reg_w_check(struct reg *reg,
 	/* read the identification register in the second run, to make sure we
 	 * don't read the ETB data register twice, skipping every second entry
 	 */
-	buf_set_u32(fields[1].out_value, 0, 7, 0x0);
+	buf_set_u32(&temp1, 0, 7, 0x0);
 	fields[0].in_value = reg->value;
 	fields[0].check_value = check_value;
 	fields[0].check_mask = check_mask;
 
 	jtag_add_dr_scan_check(etb_reg->etb->tap, 3, fields, TAP_IDLE);
 
-	free(fields[1].out_value);
-	free(fields[2].out_value);
-
 	return ERROR_OK;
 }
 
@@ -312,25 +312,23 @@ static int etb_write_reg(struct reg *reg, uint32_t value)
 	etb_set_instr(etb_reg->etb, 0xc);
 
 	fields[0].num_bits = 32;
-	fields[0].out_value = malloc(4);
-	buf_set_u32(fields[0].out_value, 0, 32, value);
+	uint8_t temp0[4];
+	fields[0].out_value = temp0;
+	buf_set_u32(&temp0, 0, 32, value);
 	fields[0].in_value = NULL;
 
 	fields[1].num_bits = 7;
-	fields[1].out_value = malloc(1);
-	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
+	uint8_t temp1;
+	fields[1].out_value = &temp1;
+	buf_set_u32(&temp1, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 
 	fields[2].num_bits = 1;
-	fields[2].out_value = malloc(1);
-	buf_set_u32(fields[2].out_value, 0, 1, 1);
+	uint8_t temp2;
+	fields[2].out_value = &temp2;
+	buf_set_u32(&temp2, 0, 1, 1);
 
 	fields[2].in_value = NULL;
-
-	free(fields[0].out_value);
-	free(fields[1].out_value);
-	free(fields[2].out_value);
-
 	return ERROR_OK;
 }
 
diff --git a/src/target/etm.c b/src/target/etm.c
index 3850ced..4f4bf9a 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -514,15 +514,17 @@ static int etm_read_reg_w_check(struct reg *reg,
 	fields[0].check_mask = NULL;
 
 	fields[1].num_bits = 7;
-	fields[1].out_value = malloc(1);
-	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
+	uint8_t temp1;
+	fields[1].out_value = &temp1;
+	buf_set_u32(&temp1, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 	fields[1].check_value = NULL;
 	fields[1].check_mask = NULL;
 
 	fields[2].num_bits = 1;
-	fields[2].out_value = malloc(1);
-	buf_set_u32(fields[2].out_value, 0, 1, 0);
+	uint8_t temp2;
+	fields[2].out_value = &temp2;
+	buf_set_u32(&temp2, 0, 1, 0);
 	fields[2].in_value = NULL;
 	fields[2].check_value = NULL;
 	fields[2].check_mask = NULL;
@@ -535,9 +537,6 @@ static int etm_read_reg_w_check(struct reg *reg,
 
 	jtag_add_dr_scan_check(etm_reg->jtag_info->tap, 3, fields, TAP_IDLE);
 
-	free(fields[1].out_value);
-	free(fields[2].out_value);
-
 	return ERROR_OK;
 }
 
@@ -592,19 +591,19 @@ static int etm_write_reg(struct reg *reg, uint32_t value)
 	fields[0].num_bits = 32;
 	uint8_t tmp1[4];
 	fields[0].out_value = tmp1;
-	buf_set_u32(fields[0].out_value, 0, 32, value);
+	buf_set_u32(tmp1, 0, 32, value);
 	fields[0].in_value = NULL;
 
 	fields[1].num_bits = 7;
 	uint8_t tmp2;
 	fields[1].out_value = &tmp2;
-	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
+	buf_set_u32(&tmp2, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 
 	fields[2].num_bits = 1;
 	uint8_t tmp3;
 	fields[2].out_value = &tmp3;
-	buf_set_u32(fields[2].out_value, 0, 1, 1);
+	buf_set_u32(&tmp3, 0, 1, 1);
 	fields[2].in_value = NULL;
 
 	jtag_add_dr_scan(etm_reg->jtag_info->tap, 3, fields, TAP_IDLE);

commit 96949890ee29ab4b3ca15802302c5d93358b69e1
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Mar 19 22:04:45 2010 +0100

    jtag: move towards making out_value const
    
    These were relatively straightforward fixes which are
    backwards compatible.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 732226f..a93b6a2 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -44,13 +44,14 @@ int str9xpec_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end
 		struct scan_field field;
 
 		field.num_bits = tap->ir_length;
-		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
-		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
+		void * t = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
+		field.out_value = t;
+		buf_set_u32(t, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
 		jtag_add_ir_scan(tap, &field, end_state);
 
-		free(field.out_value);
+		free(t);
 	}
 
 	return ERROR_OK;
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index b2833fa..1963736 100644
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -36,13 +36,14 @@ static int virtex2_set_instr(struct jtag_tap *tap, uint32_t new_instr)
 		struct scan_field field;
 
 		field.num_bits = tap->ir_length;
-		field.out_value = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
-		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
+		void * t = calloc(DIV_ROUND_UP(field.num_bits, 8), 1);
+		field.out_value = t;
+		buf_set_u32(t, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
 		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 
-		free(field.out_value);
+		free(t);
 	}
 
 	return ERROR_OK;
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
index f8b5f4f..8cc4428 100644
--- a/src/target/arm_jtag.c
+++ b/src/target/arm_jtag.c
@@ -40,7 +40,7 @@ int arm_jtag_set_instr_inner(struct arm_jtag *jtag_info, uint32_t new_instr,  vo
 
 	field.num_bits = tap->ir_length;
 	field.out_value = t;
-	buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
+	buf_set_u32(t, 0, field.num_bits, new_instr);
 	field.in_value = NULL;
 
 	if (no_verify_capture == NULL)
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 37e1f09..98b27f0 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -43,7 +43,7 @@ int mips_ejtag_set_instr(struct mips_ejtag *ejtag_info, int new_instr)
 
 		field.num_bits = tap->ir_length;
 		field.out_value = t;
-		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
+		buf_set_u32(t, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
 
 		jtag_add_ir_scan(tap, &field, TAP_IDLE);
@@ -105,7 +105,7 @@ int mips_ejtag_drscan_32(struct mips_ejtag *ejtag_info, uint32_t *data)
 
 	field.num_bits = 32;
 	field.out_value = t;
-	buf_set_u32(field.out_value, 0, field.num_bits, *data);
+	buf_set_u32(t, 0, field.num_bits, *data);
 	field.in_value = r;
 
 	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
@@ -136,7 +136,7 @@ int mips_ejtag_drscan_8(struct mips_ejtag *ejtag_info, uint32_t *data)
 
 	field.num_bits = 8;
 	field.out_value = t;
-	buf_set_u32(field.out_value, 0, field.num_bits, *data);
+	buf_set_u32(t, 0, field.num_bits, *data);
 	field.in_value = r;
 
 	jtag_add_dr_scan(tap, 1, &field, TAP_IDLE);
diff --git a/src/target/xscale.c b/src/target/xscale.c
index f0e2311..0f1953d 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -171,7 +171,7 @@ static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_s
 		memset(&field, 0, sizeof field);
 		field.num_bits = tap->ir_length;
 		field.out_value = scratch;
-		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
+		buf_set_u32(scratch, 0, field.num_bits, new_instr);
 
 		jtag_add_ir_scan(tap, &field, end_state);
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9xpec.c |    7 +++--
 src/jtag/jtag.h          |    4 +-
 src/jtag/tcl.c           |   17 ++++++-----
 src/pld/virtex2.c        |    7 +++--
 src/target/arm_jtag.c    |    2 +-
 src/target/embeddedice.c |   24 ++++++++--------
 src/target/etb.c         |   68 ++++++++++++++++++++++-----------------------
 src/target/etm.c         |   19 ++++++-------
 src/target/mips_ejtag.c  |    6 ++--
 src/target/xscale.c      |    2 +-
 10 files changed, 78 insertions(+), 78 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Mar 21 19:21:56 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Sun, 21 Mar 2010 18:21:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-124-gb7811b7
Message-ID: <E1NtPmf-0002Tf-RR@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b7811b76795aaeacfea0473bdca2c44826f20501 (commit)
      from  5dcad2d34fc40659018da2cf75ceeacd3abea860 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b7811b76795aaeacfea0473bdca2c44826f20501
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Mar 21 19:20:26 2010 +0100

    arm breakpoints: amended fix comment
    
    the handling of caches, should be moved into the breakpoint
    specific callbacks rather than being plonked into generic
    memory write fn's.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 4916de1..99f7dca 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -567,7 +567,11 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 
 	/* FIX!!!! this should be cleaned up and made much more general. The
 	 * plan is to write up and test on arm920t specifically and
-	 * then generalize and clean up afterwards. */
+	 * then generalize and clean up afterwards.
+	 *
+	 * Also it should be moved to the callbacks that handle breakpoints
+	 * specifically and not the generic memory write fn's. See XScale code.
+	 */
 	if (arm920t->armv4_5_mmu.mmu_enabled && (count == 1) &&
 			((size==2) || (size==4)))
 	{
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index ff18bae..1f753a6 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -579,7 +579,12 @@ int arm926ejs_write_memory(struct target *target, uint32_t address,
 
 	/* FIX!!!! this should be cleaned up and made much more general. The
 	 * plan is to write up and test on arm926ejs specifically and
-	 * then generalize and clean up afterwards. */
+	 * then generalize and clean up afterwards.
+	 *
+	 *
+	 * Also it should be moved to the callbacks that handle breakpoints
+	 * specifically and not the generic memory write fn's. See XScale code.
+	 **/
 	if (arm926ejs->armv4_5_mmu.mmu_enabled && (count == 1) && ((size==2) || (size==4)))
 	{
 		/* special case the handling of single word writes to bypass MMU

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm920t.c   |    6 +++++-
 src/target/arm926ejs.c |    7 ++++++-
 2 files changed, 11 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Mar 22 06:50:11 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 22 Mar 2010 05:50:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-125-gc2f714b
Message-ID: <E1NtaWj-00011H-Jc@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c2f714bd4482cfe3c09efdc57e8b6b7e8536e181 (commit)
      from  b7811b76795aaeacfea0473bdca2c44826f20501 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c2f714bd4482cfe3c09efdc57e8b6b7e8536e181
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Mar 21 22:49:23 2010 -0700

    ft2232 init mess cleanup
    
    In the ft2232 driver, initialization for many layouts punts to a routine
    called usbjtag_init(), instead of a routine specific to each layout.
    
    That routine is  a mess  built around a "what type layout am I" core.
    That's a bad design ... in this case, especially so, since it bypasses
    the layout-specific dispatch which was just done, and obfuscates the
    initialization which is at least somewhat generic, instead of being
    specific to the "usbjtag" layout.
    
    Split and document out the generic parts of usbjtag_init(), and make
    the rest of those layouts have layout-specific init methods.  Also,
    rename usbjtag_reset() ... that also was not specific to the "usbjtag"
    layout, and thus contributed to the previous code structure confusion.
    
    (Eventually, all layout-specific code (and method tables) should probably
    live in files specific to each layout.  These changes will facilitate
    those and other cleanups to this driver.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 8e835c5..dd11aec 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -172,6 +172,8 @@ struct ft2232_layout {
 /* init procedures for supported layouts */
 static int usbjtag_init(void);
 static int jtagkey_init(void);
+static int lm3s811_jtag_init(void);
+static int icdi_jtag_init(void);
 static int olimex_jtag_init(void);
 static int flyswatter_init(void);
 static int turtle_init(void);
@@ -181,12 +183,13 @@ static int axm0432_jtag_init(void);
 static int sheevaplug_init(void);
 static int icebear_jtag_init(void);
 static int cortino_jtag_init(void);
+static int signalyzer_init(void);
 static int signalyzer_h_init(void);
 static int ktlink_init(void);
 static int redbee_init(void);
 
 /* reset procedures for supported layouts */
-static void usbjtag_reset(int trst, int srst);
+static void ftx23_reset(int trst, int srst);
 static void jtagkey_reset(int trst, int srst);
 static void olimex_jtag_reset(int trst, int srst);
 static void flyswatter_reset(int trst, int srst);
@@ -211,7 +214,7 @@ static const struct ft2232_layout  ft2232_layouts[] =
 {
 	{ .name = "usbjtag",
 		.init = usbjtag_init,
-		.reset = usbjtag_reset,
+		.reset = ftx23_reset,
 	},
 	{ .name = "jtagkey",
 		.init = jtagkey_init,
@@ -226,16 +229,16 @@ static const struct ft2232_layout  ft2232_layouts[] =
 		.reset = jtagkey_reset,
 	},
 	{ .name = "signalyzer",
-		.init = usbjtag_init,
-		.reset = usbjtag_reset,
+		.init = signalyzer_init,
+		.reset = ftx23_reset,
 	},
 	{ .name = "evb_lm3s811",
-		.init = usbjtag_init,
-		.reset = usbjtag_reset,
+		.init = lm3s811_jtag_init,
+		.reset = ftx23_reset,
 	},
 	{ .name = "luminary_icdi",
-		.init = usbjtag_init,
-		.reset = usbjtag_reset,
+		.init = icdi_jtag_init,
+		.reset = ftx23_reset,
 	},
 	{ .name = "olimex-jtag",
 		.init = olimex_jtag_init,
@@ -298,14 +301,23 @@ static const struct ft2232_layout  ft2232_layouts[] =
 	{ .name = NULL, /* END OF TABLE */ },
 };
 
-static uint8_t                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;
+/* bitmask used to drive nTRST; usually a GPIOLx signal */
+static uint8_t                  nTRST;
+static uint8_t                  nTRSTnOE;
+/* bitmask used to drive nSRST; usually a GPIOLx signal */
+static uint8_t                  nSRST;
+static uint8_t                  nSRSTnOE;
 
 /** the layout being used with this debug session */
 static const struct ft2232_layout *layout;
 
+/** default bitmask values ddriven on DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
 static uint8_t                  low_output     = 0x0;
+/** default direction bitmask for DBUS: TCK/TDI/TDO/TMS and GPIOL(0..4) */
 static uint8_t                  low_direction  = 0x0;
+/** default value bitmask for CBUS GPIOH(0..4) */
 static uint8_t                  high_output    = 0x0;
+/** default direction bitmask for CBUS GPIOH(0..4) */
 static uint8_t                  high_direction = 0x0;
 
 #if BUILD_FT2232_FTD2XX == 1
@@ -1340,7 +1352,8 @@ static int ft2232_predict_scan_in(int scan_size, enum scan_type type)
 	return predicted_size;
 }
 
-static void usbjtag_reset(int trst, int srst)
+/* semi-generic FT2232/FT4232 reset code */
+static void ftx23_reset(int trst, int srst)
 {
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 	if (trst == 1)
@@ -2371,60 +2384,23 @@ static int ft2232_init(void)
 	return ERROR_OK;
 }
 
-static int usbjtag_init(void)
+/** Updates defaults for DBUS signals:  the four JTAG signals
+ * (TCK, TDI, TDO, TMS) and * the four GPIOL signals.
+ */
+static inline void ftx232_init_head(void)
 {
-	uint8_t  buf[3];
-	uint32_t bytes_written;
-	char *ft2232_layout = layout->name;
-
 	low_output    = 0x08;
 	low_direction = 0x0b;
+}
 
-	if (strcmp(ft2232_layout, "usbjtag") == 0)
-	{
-		nTRST    = 0x10;
-		nTRSTnOE = 0x10;
-		nSRST    = 0x40;
-		nSRSTnOE = 0x40;
-	}
-	else if (strcmp(ft2232_layout, "signalyzer") == 0)
-	{
-		nTRST    = 0x10;
-		nTRSTnOE = 0x10;
-		nSRST    = 0x20;
-		nSRSTnOE = 0x20;
-	}
-	else if (strcmp(ft2232_layout, "evb_lm3s811") == 0)
-	{
-		/* There are multiple revisions of LM3S811 eval boards:
-		 * - Rev B (and older?) boards have no SWO trace support.
-		 * - Rev C boards add ADBUS_6 DBG_ENn and BDBUS_4 SWO_EN;
-		 *   they should use the "luminary_icdi" layout instead.
-		 */
-		nTRST = 0x0;
-		nTRSTnOE = 0x00;
-		nSRST = 0x20;
-		nSRSTnOE = 0x20;
-		low_output    = 0x88;
-		low_direction = 0x8b;
-	}
-	else if (strcmp(ft2232_layout, "luminary_icdi") == 0)
-	{
-		/* Most Luminary eval boards support SWO trace output,
-		 * and should use this "luminary_icdi" layout.
-		 */
-		nTRST = 0x0;
-		nTRSTnOE = 0x00;
-		nSRST = 0x20;
-		nSRSTnOE = 0x20;
-		low_output    = 0x88;
-		low_direction = 0xcb;
-	}
-	else
-	{
-		LOG_ERROR("BUG: usbjtag_init called for unknown layout '%s'", ft2232_layout);
-		return ERROR_JTAG_INIT_FAILED;
-	}
+/** Initializes DBUS signals:  the four JTAG signals (TCK, TDI, TDO, TMS),
+ * the four GPIOL signals.  Initialization covers value and direction,
+ * as customized for each layout.
+ */
+static int ftx232_init_tail(void)
+{
+	uint8_t  buf[3];
+	uint32_t bytes_written;
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
@@ -2464,6 +2440,69 @@ static int usbjtag_init(void)
 	return ERROR_OK;
 }
 
+static int usbjtag_init(void)
+{
+	/*
+	 * NOTE:  This is now _specific_ to the "usbjtag" layout.
+	 * Don't try cram any more layouts into this.
+	 */
+	ftx232_init_head();
+
+	nTRST    = 0x10;
+	nTRSTnOE = 0x10;
+	nSRST    = 0x40;
+	nSRSTnOE = 0x40;
+
+	return ftx232_init_tail();
+}
+
+static int lm3s811_jtag_init(void)
+{
+	ftx232_init_head();
+
+	/* There are multiple revisions of LM3S811 eval boards:
+	 * - Rev B (and older?) boards have no SWO trace support.
+	 * - Rev C boards add ADBUS_6 DBG_ENn and BDBUS_4 SWO_EN;
+	 *   they should use the "luminary_icdi" layout instead.
+	 */
+	nTRST = 0x0;
+	nTRSTnOE = 0x00;
+	nSRST = 0x20;
+	nSRSTnOE = 0x20;
+	low_output    = 0x88;
+	low_direction = 0x8b;
+
+	return ftx232_init_tail();
+}
+
+static int icdi_jtag_init(void)
+{
+	ftx232_init_head();
+
+	/* Most Luminary eval boards support SWO trace output,
+	 * and should use this "luminary_icdi" layout.
+	 */
+	nTRST = 0x0;
+	nTRSTnOE = 0x00;
+	nSRST = 0x20;
+	nSRSTnOE = 0x20;
+	low_output    = 0x88;
+	low_direction = 0xcb;
+
+	return ftx232_init_tail();
+}
+
+static int signalyzer_init(void)
+{
+	ftx232_init_head();
+
+	nTRST    = 0x10;
+	nTRSTnOE = 0x10;
+	nSRST    = 0x20;
+	nSRSTnOE = 0x20;
+	return ftx232_init_tail();
+}
+
 static int axm0432_jtag_init(void)
 {
 	uint8_t  buf[3];

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |  159 ++++++++++++++++++++++++++++-----------------
 1 files changed, 99 insertions(+), 60 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar 22 07:22:21 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon, 22 Mar 2010 06:22:21 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-126-gccfaed8
Message-ID: <E1Ntb1q-0004S7-II@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ccfaed8bc7936d7a1640bf69df52ac65ca38e298 (commit)
      from  c2f714bd4482cfe3c09efdc57e8b6b7e8536e181 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ccfaed8bc7936d7a1640bf69df52ac65ca38e298
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 22 07:21:09 2010 +0100

    bitq: fix warning now that out_value is const
    
    This was an easy one. Just add the missing "const" to a
    local variable definition.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/drivers/bitq.c b/src/jtag/drivers/bitq.c
index bffc475..79ca349 100644
--- a/src/jtag/drivers/bitq.c
+++ b/src/jtag/drivers/bitq.c
@@ -226,7 +226,7 @@ void bitq_scan_field(struct scan_field* field, int pause)
 	int bit_cnt;
 	int tdo_req;
 
-	uint8_t* out_ptr;
+	const uint8_t* out_ptr;
 	uint8_t  out_mask;
 
 	if (field->in_value)

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/bitq.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar 22 08:29:09 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon, 22 Mar 2010 07:29:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-127-g4be9ede
Message-ID: <E1Ntc4U-0006D9-Iy@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4be9eded7f723af8fe755b1ef62469e87d1003bc (commit)
      from  ccfaed8bc7936d7a1640bf69df52ac65ca38e298 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4be9eded7f723af8fe755b1ef62469e87d1003bc
Author: Mike Dunn <mikedunn at newsguy.com>
Date:   Sat Mar 20 10:53:47 2010 -0400

    fix software breakpoints on xscale
    
    This patch fixes xscale software breakpoints by cleaning the dcache and
    invalidating the icache after the bkpt instruction is inserted or removed.  The
    icache operation is necessary in order to flush the fetch buffers, even if the
    icache is disabled (see section 4.2.7 of the xscale core developer's manual).
    The dcache is presumed to be enabled; no harm done if not.  The dcache is also
    invalidated after cleaning in order to safeguard against a future load of
    invalid data, in the event that cache_clean_address points to memory that is
    valid and in use.
    
    Also corrected a confusing typo I noticed in a comment.
    
    TODO (or not TODO...?): the xscale's 2K "mini dcache" is not cleaned.  This
    cache is not used unless the 'X' bit in the page table entry is set.  This is a
    proprietary xscale extension to the ARM architecture.  If a target's OS or
    executive makes use of this for memory regions holding code, the breakpoint
    problem will persist.  Flushing the mini dcache requires that 2K of valid
    cacheable memory (mapped with 'X' bit set) be designated by the user for this
    purpose.  The debug handler that gets downloaded to the target will also need to
    be extended.

diff --git a/src/target/xscale.c b/src/target/xscale.c
index 0f1953d..e578a77 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -2125,7 +2125,7 @@ static int xscale_set_breakpoint(struct target *target,
 			{
 				return retval;
 			}
-			/* write the original instruction in target endianness (arm7_9->arm_bkpt is host endian) */
+			/* write the bkpt instruction in target endianness (arm7_9->arm_bkpt is host endian) */
 			if ((retval = target_write_u32(target, breakpoint->address, xscale->arm_bkpt)) != ERROR_OK)
 			{
 				return retval;
@@ -2138,13 +2138,18 @@ static int xscale_set_breakpoint(struct target *target,
 			{
 				return retval;
 			}
-			/* write the original instruction in target endianness (arm7_9->arm_bkpt is host endian) */
+			/* write the bkpt instruction in target endianness (arm7_9->arm_bkpt is host endian) */
 			if ((retval = target_write_u32(target, breakpoint->address, xscale->thumb_bkpt)) != ERROR_OK)
 			{
 				return retval;
 			}
 		}
 		breakpoint->set = 1;
+
+		xscale_send_u32(target, 0x50);   /* clean dcache */
+		xscale_send_u32(target, xscale->cache_clean_address);
+		xscale_send_u32(target, 0x51);   /* invalidate dcache */
+		xscale_send_u32(target, 0x52);   /* invalidate icache and flush fetch buffers */
 	}
 
 	return ERROR_OK;
@@ -2225,6 +2230,11 @@ static int xscale_unset_breakpoint(struct target *target,
 			}
 		}
 		breakpoint->set = 0;
+
+		xscale_send_u32(target, 0x50);   /* clean dcache */
+		xscale_send_u32(target, xscale->cache_clean_address);
+		xscale_send_u32(target, 0x51);   /* invalidate dcache */
+		xscale_send_u32(target, 0x52);   /* invalidate icache and flush fetch buffers */
 	}
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar 22 08:29:30 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon, 22 Mar 2010 07:29:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-128-g721502f
Message-ID: <E1Ntc4p-0001xs-62@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  721502f1d3a0d506bc0e814926368fbedda60028 (commit)
      from  4be9eded7f723af8fe755b1ef62469e87d1003bc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 721502f1d3a0d506bc0e814926368fbedda60028
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Mar 22 08:27:03 2010 +0100

    zy1000: fix optimisaion bug in dcc writes
    
    Introduced & corrected since 0.4.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 6f75e59..b8abc89 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -828,23 +828,17 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 		}
 	} else
 	{
-		tap_state_t end_state = TAP_IDLE;
-		tap_state_t shift_end_state = TAP_DRSHIFT;
-		if (post_bits == 0)
-			shift_end_state = end_state;
-
 		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
 		int i;
 		for (i = 0; i < count - 1; i++)
 		{
 			/* Fewer pokes means we get to use the FIFO more efficiently */
 			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, little));
-			shiftValueInner(TAP_DRSHIFT, shift_end_state, 6 + post_bits + pre_bits, (reg_addr | (1 << 5)));
+			shiftValueInner(TAP_DRSHIFT, TAP_IDLE, 6 + post_bits + pre_bits, (reg_addr | (1 << 5)));
 			buffer += 4;
 		}
 		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, little));
-		shiftValueInner(TAP_DRSHIFT, shift_end_state, 6, reg_addr | (1 << 5));
-		shiftValueInner(shift_end_state, end_state, post_bits, 0);
+		shiftValueInner(TAP_DRSHIFT, TAP_IDLE, 6 + post_bits, (reg_addr | (1 << 5)));
 	}
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   10 ++--------
 1 files changed, 2 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Mar 24 07:47:16 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Wed, 24 Mar 2010 06:47:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-130-g1cda3e6
Message-ID: <E1NuKN4-0005HG-3N@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  1cda3e64e4555d64496709b23f0af1da8f3a7034 (commit)
       via  9f1d9499ce5d15f25c3d0f150348e16deb2e7aaf (commit)
      from  721502f1d3a0d506bc0e814926368fbedda60028 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 1cda3e64e4555d64496709b23f0af1da8f3a7034
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed Mar 24 12:08:45 2010 +0800

    server: review unused symbols
    
    Remove unused function
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/server/server.c b/src/server/server.c
index 1a6250c..0d3273b 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -233,34 +233,6 @@ int add_service(char *name, enum connection_type type, unsigned short port, int
 	return ERROR_OK;
 }
 
-int remove_service(unsigned short port)
-{
-	struct service **p = &services;
-	struct service *c;
-
-	/* find service */
-	while ((c = *p))
-	{
-		if (c->port == port)
-		{
-			if (c->name)
-				free(c->name);
-
-			if (c->priv)
-				free(c->priv);
-
-			/* delete service */
-			*p = c->next;
-			free(c);
-		}
-
-		/* redirect p to next list pointer */
-		p = &(*p)->next;
-	}
-
-	return ERROR_OK;
-}
-
 static int remove_services(void)
 {
 	struct service *c = services;

commit 9f1d9499ce5d15f25c3d0f150348e16deb2e7aaf
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed Mar 24 12:06:45 2010 +0800

    server: review scope of functions and data
    
    Add "static" qualifier to private functions and data.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/server/server.c b/src/server/server.c
index 173beb8..1a6250c 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -40,7 +40,7 @@
 #endif
 
 
-struct service *services = NULL;
+static struct service *services = NULL;
 
 /* shutdown_openocd == 1: exit the main event loop, and quit the debugger */
 static int shutdown_openocd = 0;
@@ -48,7 +48,7 @@ static int shutdown_openocd = 0;
 /* set when using pipes rather than tcp */
 int server_use_pipes = 0;
 
-int add_connection(struct service *service, struct command_context *cmd_ctx)
+static int add_connection(struct service *service, struct command_context *cmd_ctx)
 {
 	socklen_t address_size;
 	struct connection *c, **p;
@@ -112,7 +112,7 @@ int add_connection(struct service *service, struct command_context *cmd_ctx)
 	return ERROR_OK;
 }
 
-int remove_connection(struct service *service, struct connection *connection)
+static int remove_connection(struct service *service, struct connection *connection)
 {
 	struct connection **p = &service->connections;
 	struct connection *c;
@@ -261,7 +261,7 @@ int remove_service(unsigned short port)
 	return ERROR_OK;
 }
 
-int remove_services(void)
+static int remove_services(void)
 {
 	struct service *c = services;
 

-----------------------------------------------------------------------

Summary of changes:
 src/server/server.c |   36 ++++--------------------------------
 1 files changed, 4 insertions(+), 32 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Mar 25 00:07:35 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 24 Mar 2010 23:07:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-131-gd7dba8d
Message-ID: <E1NuZfm-0003Oo-0X@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d7dba8d346bed622ab4269723d1d1c8992d3353b (commit)
      from  1cda3e64e4555d64496709b23f0af1da8f3a7034 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d7dba8d346bed622ab4269723d1d1c8992d3353b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Mar 24 16:04:26 2010 -0700

    FT2232 Messaaging fix
    
    The init cleanup patch overlooked a message which was
    wrongly specific to the "usbjtag" layout.  Fix.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index dd11aec..93d1c4a 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -2433,7 +2433,7 @@ static int ftx232_init_tail(void)
 
 	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR("couldn't initialize FT2232 with 'USBJTAG' layout");
+		LOG_ERROR("couldn't initialize FT2232 DBUS");
 		return ERROR_JTAG_INIT_FAILED;
 	}
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 25 07:49:56 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 25 Mar 2010 06:49:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-133-g4af724d
Message-ID: <E1NugtC-0006qc-8e@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4af724df238eb30569c2845b6160ef4e7f894ad1 (commit)
       via  ec28c674af428a968ddc8b0242913bde07b901c7 (commit)
      from  d7dba8d346bed622ab4269723d1d1c8992d3353b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4af724df238eb30569c2845b6160ef4e7f894ad1
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed Mar 24 13:45:29 2010 +0800

    telnet_server: review unused symbols
    
    Remove unused function
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/server/telnet_server.c b/src/server/telnet_server.c
index 46c8836..10caee3 100644
--- a/src/server/telnet_server.c
+++ b/src/server/telnet_server.c
@@ -580,18 +580,6 @@ static int telnet_connection_closed(struct connection *connection)
 	return ERROR_OK;
 }
 
-int telnet_set_prompt(struct connection *connection, char *prompt)
-{
-	struct telnet_connection *t_con = connection->priv;
-
-	if (t_con->prompt != NULL)
-		free(t_con->prompt);
-
-	t_con->prompt = strdup(prompt);
-
-	return ERROR_OK;
-}
-
 int telnet_init(char *banner)
 {
 	struct telnet_service *telnet_service = malloc(sizeof(struct telnet_service));

commit ec28c674af428a968ddc8b0242913bde07b901c7
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed Mar 24 13:44:40 2010 +0800

    telnet_server: review scope of functions
    
    Add "static" qualifier to private functions.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/server/telnet_server.c b/src/server/telnet_server.c
index 94c8943..46c8836 100644
--- a/src/server/telnet_server.c
+++ b/src/server/telnet_server.c
@@ -44,7 +44,8 @@ static char *negotiate =
  * we write to it, we will fail. Subsequent write operations will
  * succeed. Shudder!
  */
-int telnet_write(struct connection *connection, const void *data, int len)
+static int telnet_write(struct connection *connection, const void *data,
+		int len)
 {
 	struct telnet_connection *t_con = connection->priv;
 	if (t_con->closed)
@@ -58,14 +59,14 @@ int telnet_write(struct connection *connection, const void *data, int len)
 	return ERROR_SERVER_REMOTE_CLOSED;
 }
 
-int telnet_prompt(struct connection *connection)
+static int telnet_prompt(struct connection *connection)
 {
 	struct telnet_connection *t_con = connection->priv;
 
 	return telnet_write(connection, t_con->prompt, strlen(t_con->prompt));
 }
 
-int telnet_outputline(struct connection *connection, const char *line)
+static int telnet_outputline(struct connection *connection, const char *line)
 {
 	int len;
 
@@ -93,14 +94,14 @@ int telnet_outputline(struct connection *connection, const char *line)
 	return ERROR_OK;
 }
 
-int telnet_output(struct command_context *cmd_ctx, const char* line)
+static int telnet_output(struct command_context *cmd_ctx, const char* line)
 {
 	struct connection *connection = cmd_ctx->output_handler_priv;
 
 	return telnet_outputline(connection, line);
 }
 
-void telnet_log_callback(void *priv, const char *file, unsigned line,
+static void telnet_log_callback(void *priv, const char *file, unsigned line,
 		const char *function, const char *string)
 {
 	struct connection *connection = priv;
@@ -132,7 +133,7 @@ void telnet_log_callback(void *priv, const char *file, unsigned line,
 		telnet_write(connection, "\b", 1);
 }
 
-int telnet_new_connection(struct connection *connection)
+static int telnet_new_connection(struct connection *connection)
 {
 	struct telnet_connection *telnet_connection = malloc(sizeof(struct telnet_connection));
 	struct telnet_service *telnet_service = connection->service->priv;
@@ -177,7 +178,8 @@ int telnet_new_connection(struct connection *connection)
 	return ERROR_OK;
 }
 
-void telnet_clear_line(struct connection *connection, struct telnet_connection *t_con)
+static void telnet_clear_line(struct connection *connection,
+		struct telnet_connection *t_con)
 {
 	/* move to end of line */
 	if (t_con->line_cursor < t_con->line_size)
@@ -194,7 +196,7 @@ void telnet_clear_line(struct connection *connection, struct telnet_connection *
 	t_con->line_cursor = 0;
 }
 
-int telnet_input(struct connection *connection)
+static int telnet_input(struct connection *connection)
 {
 	int bytes_read;
 	unsigned char buffer[TELNET_BUFFER_SIZE];
@@ -540,7 +542,7 @@ int telnet_input(struct connection *connection)
 	return ERROR_OK;
 }
 
-int telnet_connection_closed(struct connection *connection)
+static int telnet_connection_closed(struct connection *connection)
 {
 	struct telnet_connection *t_con = connection->priv;
 	int i;

-----------------------------------------------------------------------

Summary of changes:
 src/server/telnet_server.c |   32 +++++++++++---------------------
 1 files changed, 11 insertions(+), 21 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 25 11:12:54 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 25 Mar 2010 10:12:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-134-ge736468
Message-ID: <E1Nuk3b-0000aO-A6@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e736468b0e25f255db60cfd6cb2f6a2e470ba50e (commit)
      from  4af724df238eb30569c2845b6160ef4e7f894ad1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e736468b0e25f255db60cfd6cb2f6a2e470ba50e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 4 19:03:26 2010 +0100

    zy1000: allow it to build on linux host for testing purposes
    
    For testing and checking the build this can be useful,
    it doesn't have any practical application outside development.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index 1dcf23a..43d0c97 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -17,14 +17,14 @@
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
 
-#include <cyg/hal/hal_io.h>             // low level i/o
-#include <cyg/hal/hal_intr.h>             // low level i/o
-
-//#define VERBOSE(a) a
-#define VERBOSE(a)
-
 /* used to test manual mode */
 #define TEST_MANUAL() 0
+#define VERBOSE(a)
+
+#if BUILD_ECOSBOARD
+
+#include <cyg/hal/hal_io.h>             // low level i/o
+#include <cyg/hal/hal_intr.h>             // low level i/o
 
 #if 0
 int  diag_printf(const char *fmt, ...);
@@ -35,10 +35,20 @@ int  diag_printf(const char *fmt, ...);
 #define ZY1000_POKE(a, b) HAL_WRITE_UINT32(a, b)
 #endif
 
+#else
+
+/* redirect this to TCP/IP */
+#define ZY1000_PEEK(a, b) b = 1;
+#define ZY1000_POKE(a, b)
+
+#endif
+
+
+
 // FIFO empty?
 static __inline__ void waitIdle(void)
 {
-	cyg_uint32 empty;
+	uint32_t empty;
 	do
 	{
 		ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
@@ -53,7 +63,7 @@ static __inline__ void waitQueue(void)
 static __inline__ void sampleShiftRegister(void)
 {
 #if 0
-	cyg_uint32 dummy;
+	uint32_t dummy;
 	waitIdle();
 	ZY1000_PEEK(ZY1000_JTAG_BASE + 0xc, dummy);
 #endif
@@ -61,7 +71,7 @@ static __inline__ void sampleShiftRegister(void)
 
 static __inline__ void setCurrentState(enum tap_state state)
 {
-	cyg_uint32 a;
+	uint32_t a;
 	a = state;
 	int repeat = 0;
 	if (state == TAP_RESET)
@@ -82,9 +92,9 @@ static __inline__ void setCurrentState(enum tap_state state)
  * Enter state and cause repeat transitions *out* of that state. So if the endState != state, then
  * the transition from state to endState counts as a transition out of state.
  */
-static __inline__ void shiftValueInner(const enum tap_state state, const enum tap_state endState, int repeat, cyg_uint32 value)
+static __inline__ void shiftValueInner(const enum tap_state state, const enum tap_state endState, int repeat, uint32_t value)
 {
-	cyg_uint32 a,b;
+	uint32_t a,b;
 	a = state;
 	b = endState;
 	waitQueue();
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index b8abc89..907b965 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -48,13 +48,15 @@
 #include <target/embeddedice.h>
 #include <jtag/minidriver.h>
 #include <jtag/interface.h>
+#include <time.h>
+
+
+#if BUILD_ECOSBOARD
 #include "zy1000_version.h"
 
 #include <cyg/hal/hal_io.h>             // low level i/o
 #include <cyg/hal/hal_diag.h>
 
-#include <time.h>
-
 #ifdef CYGPKG_HAL_NIOS2
 #include <cyg/hal/io.h>
 #include <cyg/firmwareutil/firmwareutil.h>
@@ -66,6 +68,7 @@
 #define ZYLIN_OPENOCD GIT_OPENOCD_VERSION
 #define ZYLIN_OPENOCD_VERSION "ZY1000 " ZYLIN_VERSION " " ZYLIN_DATE
 
+#endif
 
 static int zy1000_khz(int khz, int *jtag_speed)
 {
@@ -96,7 +99,7 @@ static int zy1000_speed_div(int speed, int *khz)
 
 static bool readPowerDropout(void)
 {
-	cyg_uint32 state;
+	uint32_t state;
 	// sample and clear power dropout
 	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x80);
 	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, state);
@@ -108,7 +111,7 @@ static bool readPowerDropout(void)
 
 static bool readSRST(void)
 {
-	cyg_uint32 state;
+	uint32_t state;
 	// sample and clear SRST sensing
 	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x00000040);
 	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, state);
@@ -260,6 +263,7 @@ COMMAND_HANDLER(handle_power_command)
 }
 
 
+#if BUILD_ECOSBOARD
 /* Give TELNET a way to find out what version this is */
 static int jim_zy1000_version(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
@@ -308,7 +312,7 @@ static int jim_zy1000_version(Jim_Interp *interp, int argc, Jim_Obj *const *argv
 			 * and actual FPGA
 			 */
 			static char *fpga_id = "0x12345678 0x12345678 0x12345678 0x12345678";
-			cyg_uint32 id, timestamp;
+			uint32_t id, timestamp;
 			HAL_READ_UINT32(SYSID_BASE, id);
 			HAL_READ_UINT32(SYSID_BASE+4, timestamp);
 			sprintf(fpga_id, "0x%08x 0x%08x 0x%08x 0x%08x", id, timestamp, SYSID_ID, SYSID_TIMESTAMP);
@@ -333,7 +337,7 @@ static int jim_zy1000_version(Jim_Interp *interp, int argc, Jim_Obj *const *argv
 
 	return JIM_OK;
 }
-
+#endif
 
 #ifdef CYGPKG_HAL_NIOS2
 
@@ -353,7 +357,7 @@ static void report_info(void *data, const char * format, va_list args)
 
 struct cyg_upgrade_info firmware_info =
 {
-		(cyg_uint8 *)0x84000000,
+		(uint8_t *)0x84000000,
 		"/ram/firmware.phi",
 		"Firmware",
 		0x0300000,
@@ -401,7 +405,7 @@ zylinjtag_Jim_Command_powerstatus(Jim_Interp *interp,
 		return JIM_ERR;
 	}
 
-	cyg_uint32 status;
+	uint32_t status;
 	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, status);
 
 	Jim_SetResult(interp, Jim_NewIntObj(interp, (status&0x80) != 0));
@@ -414,7 +418,9 @@ zylinjtag_Jim_Command_powerstatus(Jim_Interp *interp,
 
 int zy1000_init(void)
 {
+#if BUILD_ECOSBOARD
 	LOG_USER("%s", ZYLIN_OPENOCD_VERSION);
+#endif
 
 	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x30); // Turn on LED1 & LED2
 
@@ -438,7 +444,7 @@ int zy1000_quit(void)
 
 int interface_jtag_execute_queue(void)
 {
-	cyg_uint32 empty;
+	uint32_t empty;
 
 	waitIdle();
 	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
@@ -460,18 +466,18 @@ int interface_jtag_execute_queue(void)
 
 
 
-static cyg_uint32 getShiftValue(void)
+static uint32_t getShiftValue(void)
 {
-	cyg_uint32 value;
+	uint32_t value;
 	waitIdle();
 	ZY1000_PEEK(ZY1000_JTAG_BASE + 0xc, value);
 	VERBOSE(LOG_INFO("getShiftValue %08x", value));
 	return value;
 }
 #if 0
-static cyg_uint32 getShiftValueFlip(void)
+static uint32_t getShiftValueFlip(void)
 {
-	cyg_uint32 value;
+	uint32_t value;
 	waitIdle();
 	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x18, value);
 	VERBOSE(LOG_INFO("getShiftValue %08x (flipped)", value));
@@ -480,10 +486,10 @@ static cyg_uint32 getShiftValueFlip(void)
 #endif
 
 #if 0
-static void shiftValueInnerFlip(const tap_state_t state, const tap_state_t endState, int repeat, cyg_uint32 value)
+static void shiftValueInnerFlip(const tap_state_t state, const tap_state_t endState, int repeat, uint32_t value)
 {
 	VERBOSE(LOG_INFO("shiftValueInner %s %s %d %08x (flipped)", tap_state_name(state), tap_state_name(endState), repeat, value));
-	cyg_uint32 a,b;
+	uint32_t a,b;
 	a = state;
 	b = endState;
 	ZY1000_POKE(ZY1000_JTAG_BASE + 0xc, value);
@@ -511,7 +517,7 @@ static __inline void scanBits(const uint8_t *out_value, uint8_t *in_value, int n
 
 		// we have (num_bits + 7)/8 bytes of bits to toggle out.
 		// bits are pushed out LSB to MSB
-		cyg_uint32 value;
+		uint32_t value;
 		value = 0;
 		if (out_value != NULL)
 		{
@@ -953,6 +959,7 @@ static const struct command_registration zy1000_commands[] = {
 			"With no arguments, prints status.",
 		.usage = "('on'|'off)",
 	},
+#if BUILD_ECOSBOARD
 	{
 		.name = "zy1000_version",
 		.mode = COMMAND_ANY,
@@ -960,6 +967,7 @@ static const struct command_registration zy1000_commands[] = {
 		.help = "Print version info for zy1000.",
 		.usage = "['openocd'|'zy1000'|'date'|'time'|'pcb'|'fpga']",
 	},
+#endif
 	{
 		.name = "powerstatus",
 		.mode = COMMAND_ANY,

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/jtag_minidriver.h |   32 +++++++++++++++++++----------
 src/jtag/zy1000/zy1000.c          |   40 ++++++++++++++++++++++--------------
 2 files changed, 45 insertions(+), 27 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 25 12:47:23 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 25 Mar 2010 11:47:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-135-g010492a
Message-ID: <E1NulX2-0005kz-IO@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  010492a1ede305d2375602afa26f50281fea3e2f (commit)
      from  e736468b0e25f255db60cfd6cb2f6a2e470ba50e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 010492a1ede305d2375602afa26f50281fea3e2f
Author: Daniel B??der <openocd at eh-oh.de>
Date:   Thu Mar 25 11:24:42 2010 +0100

    change %x and %d to PRIx32 and PRId32 where needed for cygwin

diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index 6562e04..40324f2 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -817,7 +817,7 @@ static int lpc3180_write_page(struct nand_device *nand, uint32_t page, uint8_t *
 
                 target_free_working_area(target,pworking_area);
 
-                LOG_INFO("Page =  0x%x was written.",page);
+                LOG_INFO("Page =  0x%" PRIx32 " was written.",page);
     
                 }
                 else
@@ -1112,7 +1112,7 @@ static int lpc3180_read_page(struct nand_device *nand, uint32_t page, uint8_t *d
                     target_read_memory(target, target_mem_base+DATA_OFFS, 4, nand->page_size == 2048?512:128, page_buffer);
                     memcpy(data, page_buffer, data_size);
 
-                    LOG_INFO("Page =  0x%x was read.",page);
+                    LOG_INFO("Page =  0x%" PRIx32 " was read.",page);
 
                     /* check hw generated ECC for each 256 bytes block with the saved ECC in flash spare area*/
                     int idx = nand->page_size/0x200 ;
@@ -1120,9 +1120,9 @@ static int lpc3180_read_page(struct nand_device *nand, uint32_t page, uint8_t *d
                     target_read_memory(target, target_mem_base+ECC_OFFS, 4, 8, ecc_hw_buffer);
                     for(i=0;i<idx;i++){
                         if( (0x00ffffff&*(uint32_t *)(ecc_hw_buffer+i*8)) != (0x00ffffff&*(uint32_t *)(ecc_flash_buffer+8+i*16)) )
-                            LOG_WARNING("ECC mismatch at 256 bytes size block= %d at page= 0x%x",i*2+1,page);
+                            LOG_WARNING("ECC mismatch at 256 bytes size block= %d at page= 0x%" PRIx32,i*2+1,page);
                         if( (0x00ffffff&*(uint32_t *)(ecc_hw_buffer+4+i*8)) != (0x00ffffff&*(uint32_t *)(ecc_flash_buffer+12+i*16)) )
-                            LOG_WARNING("ECC mismatch at 256 bytes size block= %d at page= 0x%x",i*2+2,page);
+                            LOG_WARNING("ECC mismatch at 256 bytes size block= %d at page= 0x%" PRIx32,i*2+2,page);
                     }                
                 }
 
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 36744e6..2540342 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -558,7 +558,7 @@ static int pic32mx_probe(struct flash_bank *bank)
 		}
 	}
 
-	LOG_INFO("flash size = %dkbytes", num_pages / 1024);
+	LOG_INFO("flash size = %" PRId32 "kbytes", num_pages / 1024);
 
 	/* calculate numbers of pages */
 	num_pages /= page_size;
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 1b97e33..8b18fa3 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -967,7 +967,7 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &idreg);
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &romaddr);
 
-	LOG_DEBUG("MEM-AP #%d ID Register 0x%" PRIx32
+	LOG_DEBUG("MEM-AP #%" PRId32 " ID Register 0x%" PRIx32
 		", Debug ROM Address 0x%" PRIx32,
 		dap->apsel, idreg, romaddr);
 
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 8e8cc17..213afbd 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -718,7 +718,7 @@ static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
 	xp->control = control;
 	xp->dirty = true;
 
-	LOG_DEBUG("BPWP: addr %8.8x, control %x, number %d",
+	LOG_DEBUG("BPWP: addr %8.8" PRIx32 ", control %" PRIx32 ", number %d",
 			xp->address, control, xp->number);
 
 	/* hardware is updated in write_dirty_registers() */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/lpc3180.c |    8 ++++----
 src/flash/nor/pic32mx.c  |    2 +-
 src/target/arm_adi_v5.c  |    2 +-
 src/target/arm_dpm.c     |    2 +-
 4 files changed, 7 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 25 20:47:34 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 25 Mar 2010 19:47:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-136-ged6756f
Message-ID: <E1Nut1j-0001Ag-P2@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ed6756fb23fc7383ec7a4a831a8750a6cf5eaa4e (commit)
      from  010492a1ede305d2375602afa26f50281fea3e2f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ed6756fb23fc7383ec7a4a831a8750a6cf5eaa4e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 25 13:06:23 2010 +0100

    target: fix poll off
    
    I don't know when "poll off" broke, but "poll off" didn't
    stop background polling of target. The polling status flag
    simply wasn't checked in the handle_target timer callback.
    
    All target polling(including power/reset state) is now stopped
    upon "poll off".
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 2c88a6f..868241e 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1784,6 +1784,12 @@ static int handle_target(void *priv)
 	Jim_Interp *interp = (Jim_Interp *)priv;
 	int retval = ERROR_OK;
 
+	if (!is_jtag_poll_safe())
+	{
+		/* polling is disabled currently */
+		return ERROR_OK;
+	}
+
 	/* we do not want to recurse here... */
 	static int recursive = 0;
 	if (! recursive)

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Mar 25 20:47:51 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Thu, 25 Mar 2010 19:47:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-137-ged81249
Message-ID: <E1Nut20-0001CG-HF@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ed81249129d4b43159843712efa408660cf4c03d (commit)
      from  ed6756fb23fc7383ec7a4a831a8750a6cf5eaa4e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ed81249129d4b43159843712efa408660cf4c03d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Mar 4 19:58:42 2010 +0100

    zy1000: dev tool
    
    first cut peek/poke over tcp/ip, used for debug/research
    purposes only. Long term JTAG over TCP/IP might be an
    offshoot. The performance is usable for development/testing
    purposes.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index 43d0c97..d556699 100644
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -38,8 +38,11 @@ int  diag_printf(const char *fmt, ...);
 #else
 
 /* redirect this to TCP/IP */
-#define ZY1000_PEEK(a, b) b = 1;
-#define ZY1000_POKE(a, b)
+#define ZY1000_JTAG_BASE 0
+extern void zy1000_tcpout(uint32_t address, uint32_t data);
+extern uint32_t zy1000_tcpin(uint32_t address);
+#define ZY1000_PEEK(a, b) b=zy1000_tcpin(a)
+#define ZY1000_POKE(a, b) zy1000_tcpout(a, b)
 
 #endif
 
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 907b965..80731aa 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -50,6 +50,7 @@
 #include <jtag/interface.h>
 #include <time.h>
 
+#include <netinet/tcp.h>
 
 #if BUILD_ECOSBOARD
 #include "zy1000_version.h"
@@ -262,6 +263,18 @@ COMMAND_HANDLER(handle_power_command)
 	return ERROR_OK;
 }
 
+#if !BUILD_ECOSBOARD
+static char *tcp_server = "notspecified";
+static int jim_zy1000_server(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	if (argc != 2)
+		return JIM_ERR;
+
+	tcp_server = strdup(Jim_GetString(argv[1], NULL));
+
+	return JIM_OK;
+}
+#endif
 
 #if BUILD_ECOSBOARD
 /* Give TELNET a way to find out what version this is */
@@ -415,25 +428,6 @@ zylinjtag_Jim_Command_powerstatus(Jim_Interp *interp,
 
 
 
-
-int zy1000_init(void)
-{
-#if BUILD_ECOSBOARD
-	LOG_USER("%s", ZYLIN_OPENOCD_VERSION);
-#endif
-
-	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x30); // Turn on LED1 & LED2
-
-	setPower(true); // on by default
-
-
-	 /* deassert resets. Important to avoid infinite loop waiting for SRST to deassert */
-	zy1000_reset(0, 0);
-	zy1000_speed(jtag_get_speed());
-
-	return ERROR_OK;
-}
-
 int zy1000_quit(void)
 {
 
@@ -710,12 +704,6 @@ int interface_jtag_add_clocks(int num_cycles)
 	return zy1000_jtag_add_clocks(num_cycles, cmd_queue_cur_state, cmd_queue_cur_state);
 }
 
-int interface_jtag_add_sleep(uint32_t us)
-{
-	jtag_sleep(us);
-	return ERROR_OK;
-}
-
 int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq, enum tap_state state)
 {
 	/*wait for the fifo to be empty*/
@@ -967,6 +955,14 @@ static const struct command_registration zy1000_commands[] = {
 		.help = "Print version info for zy1000.",
 		.usage = "['openocd'|'zy1000'|'date'|'time'|'pcb'|'fpga']",
 	},
+#else
+	{
+		.name = "zy1000_server",
+		.mode = COMMAND_ANY,
+		.jim_handler = jim_zy1000_server,
+		.help = "Tcpip address for ZY1000 server.",
+		.usage = "address",
+	},
 #endif
 	{
 		.name = "powerstatus",
@@ -987,6 +983,320 @@ static const struct command_registration zy1000_commands[] = {
 };
 
 
+static int tcp_ip = -1;
+
+/* Write large packets if we can */
+static size_t out_pos;
+static uint8_t out_buffer[16384];
+static size_t in_pos;
+static size_t in_write;
+static uint8_t in_buffer[16384];
+
+static bool flush_writes(void)
+{
+	bool ok = (write(tcp_ip, out_buffer, out_pos) == (int)out_pos);
+	out_pos = 0;
+	return ok;
+}
+
+static bool writeLong(uint32_t l)
+{
+	int i;
+	for (i = 0; i < 4; i++)
+	{
+		uint8_t c = (l >> (i*8))&0xff;
+		out_buffer[out_pos++] = c;
+		if (out_pos >= sizeof(out_buffer))
+		{
+			if (!flush_writes())
+			{
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+static bool readLong(uint32_t *out_data)
+{
+	if (out_pos > 0)
+	{
+		if (!flush_writes())
+		{
+			return false;
+		}
+	}
+
+	uint32_t data = 0;
+	int i;
+	for (i = 0; i < 4; i++)
+	{
+		uint8_t c;
+		if (in_pos == in_write)
+		{
+			/* read more */
+			int t;
+			t = read(tcp_ip, in_buffer, sizeof(in_buffer));
+			if (t < 1)
+			{
+				return false;
+			}
+			in_write = (size_t) t;
+			in_pos = 0;
+		}
+		c = in_buffer[in_pos++];
+
+		data |= (c << (i*8));
+	}
+	*out_data = data;
+	return true;
+}
+
+enum ZY1000_CMD
+{
+	ZY1000_CMD_POKE = 0x0,
+	ZY1000_CMD_PEEK = 0x8,
+	ZY1000_CMD_SLEEP = 0x1,
+};
+
+
+#if !BUILD_ECOSBOARD
+
+#include <sys/socket.h> /* for socket(), connect(), send(), and recv() */
+#include <arpa/inet.h>  /* for sockaddr_in and inet_addr() */
+
+/* We initialize this late since we need to know the server address
+ * first.
+ */
+static void tcpip_open(void)
+{
+	if (tcp_ip >= 0)
+		return;
+
+	struct sockaddr_in echoServAddr; /* Echo server address */
+
+	/* Create a reliable, stream socket using TCP */
+	if ((tcp_ip = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
+	{
+		fprintf(stderr, "Failed to connect to zy1000 server\n");
+		exit(-1);
+	}
+
+	/* Construct the server address structure */
+	memset(&echoServAddr, 0, sizeof(echoServAddr)); /* Zero out structure */
+	echoServAddr.sin_family = AF_INET; /* Internet address family */
+	echoServAddr.sin_addr.s_addr = inet_addr(tcp_server); /* Server IP address */
+	echoServAddr.sin_port = htons(7777); /* Server port */
+
+	/* Establish the connection to the echo server */
+	if (connect(tcp_ip, (struct sockaddr *) &echoServAddr, sizeof(echoServAddr)) < 0)
+	{
+		fprintf(stderr, "Failed to connect to zy1000 server\n");
+		exit(-1);
+	}
+
+	int flag = 1;
+	setsockopt(tcp_ip,	/* socket affected */
+			IPPROTO_TCP,		/* set option at TCP level */
+			TCP_NODELAY,		/* name of option */
+			(char *)&flag,		/* the cast is historical cruft */
+			sizeof(int));		/* length of option value */
+
+}
+
+
+/* send a poke */
+void zy1000_tcpout(uint32_t address, uint32_t data)
+{
+	tcpip_open();
+	if (!writeLong((ZY1000_CMD_POKE << 24) | address)||
+			!writeLong(data))
+	{
+		fprintf(stderr, "Could not write to zy1000 server\n");
+		exit(-1);
+	}
+}
+
+uint32_t zy1000_tcpin(uint32_t address)
+{
+	tcpip_open();
+	uint32_t data;
+	if (!writeLong((ZY1000_CMD_PEEK << 24) | address)||
+			!readLong(&data))
+	{
+		fprintf(stderr, "Could not read from zy1000 server\n");
+		exit(-1);
+	}
+	return data;
+}
+
+int interface_jtag_add_sleep(uint32_t us)
+{
+	tcpip_open();
+	if (!writeLong((ZY1000_CMD_SLEEP << 24))||
+			!writeLong(us))
+	{
+		fprintf(stderr, "Could not read from zy1000 server\n");
+		exit(-1);
+	}
+	return ERROR_OK;
+}
+
+
+#endif
+
+#if BUILD_ECOSBOARD
+static char tcpip_stack[2048];
+
+static cyg_thread tcpip_thread_object;
+static cyg_handle_t tcpip_thread_handle;
+
+/* Infinite loop peeking & poking */
+static void tcpipserver(void)
+{
+	for (;;)
+	{
+		uint32_t address;
+		if (!readLong(&address))
+			return;
+		enum ZY1000_CMD c = (address >> 24) & 0xff;
+		address &= 0xffffff;
+		switch (c)
+		{
+			case ZY1000_CMD_POKE:
+			{
+				uint32_t data;
+				if (!readLong(&data))
+					return;
+				address &= ~0x80000000;
+				ZY1000_POKE(address + ZY1000_JTAG_BASE, data);
+				break;
+			}
+			case ZY1000_CMD_PEEK:
+			{
+				uint32_t data;
+				ZY1000_PEEK(address + ZY1000_JTAG_BASE, data);
+				if (!writeLong(data))
+					return;
+				break;
+			}
+			case ZY1000_CMD_SLEEP:
+			{
+				uint32_t data;
+				if (!readLong(&data))
+					return;
+				jtag_sleep(data);
+				break;
+			}
+			default:
+				return;
+		}
+	}
+}
+
+
+static void tcpip_server(cyg_addrword_t data)
+{
+	int so_reuseaddr_option = 1;
+
+	int fd;
+	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
+	{
+		LOG_ERROR("error creating socket: %s", strerror(errno));
+		exit(-1);
+	}
+
+	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (void*) &so_reuseaddr_option,
+			sizeof(int));
+
+	struct sockaddr_in sin;
+	unsigned int address_size;
+	address_size = sizeof(sin);
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = INADDR_ANY;
+	sin.sin_port = htons(7777);
+
+	if (bind(fd, (struct sockaddr *) &sin, sizeof(sin)) == -1)
+	{
+		LOG_ERROR("couldn't bind to socket: %s", strerror(errno));
+		exit(-1);
+	}
+
+	if (listen(fd, 1) == -1)
+	{
+		LOG_ERROR("couldn't listen on socket: %s", strerror(errno));
+		exit(-1);
+	}
+
+
+	for (;;)
+	{
+		tcp_ip = accept(fd, (struct sockaddr *) &sin, &address_size);
+		if (tcp_ip < 0)
+		{
+			continue;
+		}
+
+		int flag = 1;
+		setsockopt(tcp_ip,	/* socket affected */
+				IPPROTO_TCP,		/* set option at TCP level */
+				TCP_NODELAY,		/* name of option */
+				(char *)&flag,		/* the cast is historical cruft */
+				sizeof(int));		/* length of option value */
+
+		bool save_poll = jtag_poll_get_enabled();
+
+		/* polling will screw up the "connection" */
+		jtag_poll_set_enabled(false);
+
+		tcpipserver();
+
+		jtag_poll_set_enabled(save_poll);
+
+		close(tcp_ip);
+
+	}
+	close(fd);
+
+}
+
+int interface_jtag_add_sleep(uint32_t us)
+{
+	jtag_sleep(us);
+	return ERROR_OK;
+}
+
+#endif
+
+
+int zy1000_init(void)
+{
+#if BUILD_ECOSBOARD
+	LOG_USER("%s", ZYLIN_OPENOCD_VERSION);
+#endif
+
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x30); // Turn on LED1 & LED2
+
+	setPower(true); // on by default
+
+
+	 /* deassert resets. Important to avoid infinite loop waiting for SRST to deassert */
+	zy1000_reset(0, 0);
+	zy1000_speed(jtag_get_speed());
+
+
+#if BUILD_ECOSBOARD
+	cyg_thread_create(1, tcpip_server, (cyg_addrword_t) 0, "tcip/ip server",
+			(void *) tcpip_stack, sizeof(tcpip_stack),
+			&tcpip_thread_handle, &tcpip_thread_object);
+	cyg_thread_resume(tcpip_thread_handle);
+#endif
+
+	return ERROR_OK;
+}
+
+
 
 struct jtag_interface zy1000_interface =
 {

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/jtag_minidriver.h |    7 +-
 src/jtag/zy1000/zy1000.c          |  360 ++++++++++++++++++++++++++++++++++---
 2 files changed, 340 insertions(+), 27 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar 26 08:43:57 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri, 26 Mar 2010 07:43:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-138-g27b98c2
Message-ID: <E1Nv4D6-0001DP-Li@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  27b98c2fa548a46bbd2e3f5417160bbfb6eb89a1 (commit)
      from  ed81249129d4b43159843712efa408660cf4c03d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 27b98c2fa548a46bbd2e3f5417160bbfb6eb89a1
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Mar 26 15:17:46 2010 +0800

    TCL scripts: update to current "flash bank" syntax
    
    While "flash bank" syntax has been changed long ago,
    several tcl script are still not fully update.
    
    Fix following cases related with "cfi" driver:
    - syntax error: the mandatory <name> parameter is missing
    - warning: the <target> parameter is a number, instead of
      the target name
    - the comment line above the command does not report
      actual syntax
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/tcl/board/at91rm9200-dk.cfg b/tcl/board/at91rm9200-dk.cfg
index 476f5a8..af6e3df 100644
--- a/tcl/board/at91rm9200-dk.cfg
+++ b/tcl/board/at91rm9200-dk.cfg
@@ -8,8 +8,9 @@ source [find target/at91rm9200.cfg]
 $_TARGETNAME configure -event gdb-attach { reset init }
 $_TARGETNAME configure -event reset-init { at91rm9200_dk_init }
 
-#flash bank <driver> <base> <size> <chip_width> <bus_width>
-flash_bank cfi 0x10000000 0x00200000 2 2 0
+#flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
+set _FLASHNAME $_CHIPNAME.flash
+flash_bank $_FLASHNAME cfi 0x10000000 0x00200000 2 2 $_TARGETNAME
 
 
 proc at91rm9200_dk_init { } {
diff --git a/tcl/board/balloon3-cpu.cfg b/tcl/board/balloon3-cpu.cfg
index ecb1a28..468b867 100644
--- a/tcl/board/balloon3-cpu.cfg
+++ b/tcl/board/balloon3-cpu.cfg
@@ -8,7 +8,7 @@ source [find target/pxa270.cfg]
 # Override this in the interface config for parallel dongles
 reset_config trst_and_srst separate
 
-# flash bank <driver> <base> <size> <chip_width> <bus_width>
+# flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
 # 29LV650 64Mbit Flash
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x00000000 0x800000 2 2 0
+flash bank $_FLASHNAME cfi 0x00000000 0x800000 2 2 $_TARGETNAME
diff --git a/tcl/board/digi_connectcore_wi-9c.cfg b/tcl/board/digi_connectcore_wi-9c.cfg
index ad40d53..096af1b 100644
--- a/tcl/board/digi_connectcore_wi-9c.cfg
+++ b/tcl/board/digi_connectcore_wi-9c.cfg
@@ -125,6 +125,6 @@ $_TARGETNAME configure -work-area-phys 0x00000000 -work-area-size 0x1000 -work-a
 #####################
 
 #M29DW323DB - not working
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x50000000 0x0400000 2 2 0
+flash bank $_FLASHNAME cfi 0x50000000 0x0400000 2 2 $_TARGETNAME
diff --git a/tcl/board/dm6446evm.cfg b/tcl/board/dm6446evm.cfg
index 39607fe..dcd1c4e 100644
--- a/tcl/board/dm6446evm.cfg
+++ b/tcl/board/dm6446evm.cfg
@@ -31,7 +31,8 @@ if { [info exists J4_OPTION] } {
 if { $CS2_MODE == "NOR" } {
 	# 16 Mbytes address space; 16 bit bus width
 	# (older boards used 32MB parts, with upper 16 MB unusable)
-	flash bank cfi 0x02000000 0x01000000 2 2 $_TARGETNAME
+	set _FLASHNAME $_CHIPNAME.flash
+	flash bank $_FLASHNAME cfi 0x02000000 0x01000000 2 2 $_TARGETNAME
 	proc flashprobe {} { flash probe 0 }
 } elseif { $CS2_MODE == "NAND" } {
 	# 64 Mbyte small page; 8 bit bus width
diff --git a/tcl/board/hammer.cfg b/tcl/board/hammer.cfg
index d366a45..ea3da81 100644
--- a/tcl/board/hammer.cfg
+++ b/tcl/board/hammer.cfg
@@ -32,6 +32,6 @@ $_TARGETNAME configure -event reset-init {
 
 
 #flash configuration
-#flash bank <driver> <base> <size> <chip_width> <bus_width> [driver_options ...]
+#flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target> [driver_options ...]
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x00000000 0x1000000 2 2 0
+flash bank $_FLASHNAME cfi 0x00000000 0x1000000 2 2 $_TARGETNAME
diff --git a/tcl/board/imx27ads.cfg b/tcl/board/imx27ads.cfg
index 664b470..927647a 100644
--- a/tcl/board/imx27ads.cfg
+++ b/tcl/board/imx27ads.cfg
@@ -5,7 +5,8 @@ $_TARGETNAME configure -event gdb-attach { reset init }
 $_TARGETNAME configure -event reset-init { imx27ads_init }
 
 # The IMX27 ADS board has a NOR flash on CS0
-flash_bank cfi 0xc0000000 0x00200000 2 2 0
+set _FLASHNAME $_CHIPNAME.flash
+flash_bank $_FLASHNAME cfi 0xc0000000 0x00200000 2 2 $_TARGETNAME
 
 proc imx27ads_init { } {
 	# This setup puts RAM at 0xA0000000
diff --git a/tcl/board/logicpd_imx27.cfg b/tcl/board/logicpd_imx27.cfg
index b068f1a..02afc77 100644
--- a/tcl/board/logicpd_imx27.cfg
+++ b/tcl/board/logicpd_imx27.cfg
@@ -2,7 +2,8 @@
 source [find target/imx27.cfg]
 
 # The Logic PD board has a NOR flash on CS0
-flash_bank cfi 0xc0000000 0x00200000 2 2 0
+set _FLASHNAME $_CHIPNAME.flash
+flash_bank $_FLASHNAME cfi 0xc0000000 0x00200000 2 2 $_TARGETNAME
 
 #
 # FIX ME, Add support to
diff --git a/tcl/board/topas910.cfg b/tcl/board/topas910.cfg
index 303fc77..333b016 100644
--- a/tcl/board/topas910.cfg
+++ b/tcl/board/topas910.cfg
@@ -114,6 +114,6 @@ arm7_9 dcc_downloads enable       # Enable faster DCC downloads
 # Flash configuration
 #####################
 
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x20000000 0x2000000 2 2 0
+flash bank $_FLASHNAME cfi 0x20000000 0x2000000 2 2 $_TARGETNAME
diff --git a/tcl/board/topasa900.cfg b/tcl/board/topasa900.cfg
index aa3f77f..065cd31 100644
--- a/tcl/board/topasa900.cfg
+++ b/tcl/board/topasa900.cfg
@@ -120,7 +120,7 @@ arm7_9 dcc_downloads enable       # Enable faster DCC downloads
 # Flash configuration
 #####################
 
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x20000000 0x1000000 2 2 0
+flash bank $_FLASHNAME cfi 0x20000000 0x1000000 2 2 $_TARGETNAME
 
diff --git a/tcl/board/unknown_at91sam9260.cfg b/tcl/board/unknown_at91sam9260.cfg
index ad7b13c..845de6b 100644
--- a/tcl/board/unknown_at91sam9260.cfg
+++ b/tcl/board/unknown_at91sam9260.cfg
@@ -90,8 +90,8 @@ $_TARGETNAME configure -event reset-init {
 # Flash configuration
 #####################
 
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x10000000 0x01000000 2 2 0
+flash bank $_FLASHNAME cfi 0x10000000 0x01000000 2 2 $_TARGETNAME
 
 
diff --git a/tcl/board/x300t.cfg b/tcl/board/x300t.cfg
index d914180..9d9a320 100644
--- a/tcl/board/x300t.cfg
+++ b/tcl/board/x300t.cfg
@@ -7,9 +7,9 @@ source [find target/smp8634.cfg]
 $_TARGETNAME configure -event reset-init { x300t_init }
 
 # 1MB CFI capable flash
-# flash bank <driver> <base> <size> <chip_width> <bus_width>
+# flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0xac000000 0x100000 2 2 0
+flash bank $_FLASHNAME cfi 0xac000000 0x100000 2 2 $_TARGETNAME
 
 proc x300t_init { } {
 	# Setup SDRAM config and flash mapping
diff --git a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
index 034a348..d2bf66f 100644
--- a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
+++ b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
@@ -54,7 +54,7 @@ $_TARGETNAME configure -event reset-deassert-post {at91sam_init}
 
 
 # Flash configuration
-#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+#flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME cfi 0x10000000 0x01000000 2 2 $_TARGETNAME
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/at91rm9200-dk.cfg                  |    5 +++--
 tcl/board/balloon3-cpu.cfg                   |    4 ++--
 tcl/board/digi_connectcore_wi-9c.cfg         |    4 ++--
 tcl/board/dm6446evm.cfg                      |    3 ++-
 tcl/board/hammer.cfg                         |    4 ++--
 tcl/board/imx27ads.cfg                       |    3 ++-
 tcl/board/logicpd_imx27.cfg                  |    3 ++-
 tcl/board/topas910.cfg                       |    4 ++--
 tcl/board/topasa900.cfg                      |    4 ++--
 tcl/board/unknown_at91sam9260.cfg            |    4 ++--
 tcl/board/x300t.cfg                          |    4 ++--
 tcl/target/at91sam9260_ext_RAM_ext_flash.cfg |    2 +-
 12 files changed, 24 insertions(+), 20 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Mar 26 09:15:53 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Fri, 26 Mar 2010 08:15:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-139-ga092e8d
Message-ID: <E1Nv4hv-0006YA-Fr@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a092e8d237e7d23b1b952c4d400d8210523f9ce2 (commit)
      from  27b98c2fa548a46bbd2e3f5417160bbfb6eb89a1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a092e8d237e7d23b1b952c4d400d8210523f9ce2
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Mar 26 15:54:33 2010 +0800

    NOR TCL: fix usage message
    
    The command "flash bank" has updated syntax.
    Add the mandatory parameter <target> to the usage message
    that prints in case of error.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 38cb655..fc7169f 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -789,7 +789,7 @@ COMMAND_HANDLER(handle_flash_bank_command)
 	if (CMD_ARGC < 7)
 	{
 		LOG_ERROR("usage: flash bank <name> <driver> "
-				"<base> <size> <chip_width> <bus_width>");
+				"<base> <size> <chip_width> <bus_width> <target>");
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 	// save bank name and advance arguments for compatibility

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/tcl.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Mar 27 18:07:56 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 27 Mar 2010 17:07:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-140-gd60ebc0
Message-ID: <E1NvZUd-0002dQ-3P@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d60ebc0ab535e54f76e734d00d9ac1b5c9b6eb93 (commit)
      from  a092e8d237e7d23b1b952c4d400d8210523f9ce2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d60ebc0ab535e54f76e734d00d9ac1b5c9b6eb93
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Mar 27 10:07:13 2010 -0700

    jtag/tcl.c cleanup -- split out "adapter.c"
    
    Clean up the jtag/tcl.c file, which was one of the biggest and
    messiest ones in that directory.  Do it by splitting out all the
    generic adapter commands to a separate "adapter.c" file (leaving
    the "tcl.c" file holding only JTAG utilities).
    
    Also rename the little-used "jtag interface" to "adapter_name", which
    should have been at least re-categorized earlier (it's not jtag-only).
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index 0b9a6a4..a744da3 100644
--- a/NEWS
+++ b/NEWS
@@ -6,9 +6,10 @@ and other issues not mentioned here.
 JTAG Layer:
 	New driver for "Bus Pirate"
 	Rename various commands so they're not JTAG-specific
-	   There are migration procedures for these, but you should
+	   There are migration procedures for most of these, but you should
 	   convert your scripts to the new names, since those procedures
 	   will not be around forever.
+		jtag jinterface ... is now adapter_name
 	   	jtag_khz	... is now adapter_khz
 		jtag_nsrst_delay ... is now adapter_nsrst_delay
 		jtag_nsrst_assert_width ... is now adapter_nsrst_assert_width
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 83a6369..bb8f3ab 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2093,12 +2093,12 @@ target.
 @end deffn
 
 @deffn Command {interface_list}
-List the interface drivers that have been built into
+List the debug adapter drivers that have been built into
 the running copy of OpenOCD.
 @end deffn
 
- at deffn Command {jtag interface}
-Returns the name of the interface driver being used.
+ at deffn Command {adapter_name}
+Returns the name of the debug adapter driver being used.
 @end deffn
 
 @section Interface Drivers
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 3f132d4..875fbcb 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -53,6 +53,7 @@ minidriver_imp.h: $(MINIDRIVER_IMP_DIR)/minidriver_imp.h
 
 
 libjtag_la_SOURCES = \
+	adapter.c \
 	core.c \
 	interface.c \
 	interfaces.c \
diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
new file mode 100644
index 0000000..b262a9a
--- /dev/null
+++ b/src/jtag/adapter.c
@@ -0,0 +1,459 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   Copyright (C) 2009 SoftPLC Corporation                                *
+ *       http://softplc.com                                                *
+ *   dick at softplc.com                                                      *
+ *                                                                         *
+ *   Copyright (C) 2009 Zachary T Welch                                    *
+ *   zw at superlucidity.net                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jtag.h"
+#include "minidriver.h"
+#include "interface.h"
+#include "interfaces.h"
+
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+
+/**
+ * @file
+ * Holds support for configuring debug adapters from TCl scripts.
+ */
+
+extern struct jtag_interface *jtag_interface;
+
+
+
+static int
+jim_adapter_name(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	Jim_GetOptInfo goi;
+	Jim_GetOpt_Setup(&goi, interp, argc-1, argv + 1);
+
+	/* return the name of the interface */
+	/* TCL code might need to know the exact type... */
+	/* FUTURE: we allow this as a means to "set" the interface. */
+	if (goi.argc != 0) {
+		Jim_WrongNumArgs(goi.interp, 1, goi.argv-1, "(no params)");
+		return JIM_ERR;
+	}
+	const char *name = jtag_interface ? jtag_interface->name : NULL;
+	Jim_SetResultString(goi.interp, name ? : "undefined", -1);
+	return JIM_OK;
+}
+
+
+static int default_khz(int khz, int *jtag_speed)
+{
+	LOG_ERROR("Translation from khz to jtag_speed not implemented");
+	return ERROR_FAIL;
+}
+
+static int default_speed_div(int speed, int *khz)
+{
+	LOG_ERROR("Translation from jtag_speed to khz not implemented");
+	return ERROR_FAIL;
+}
+
+static int default_power_dropout(int *dropout)
+{
+	*dropout = 0; /* by default we can't detect power dropout */
+	return ERROR_OK;
+}
+
+static int default_srst_asserted(int *srst_asserted)
+{
+	*srst_asserted = 0; /* by default we can't detect srst asserted */
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_interface_list_command)
+{
+	if (strcmp(CMD_NAME, "interface_list") == 0 && CMD_ARGC > 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	command_print(CMD_CTX, "The following debug interfaces are available:");
+	for (unsigned i = 0; NULL != jtag_interfaces[i]; i++)
+	{
+		const char *name = jtag_interfaces[i]->name;
+		command_print(CMD_CTX, "%u: %s", i + 1, name);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_interface_command)
+{
+	/* check whether the interface is already configured */
+	if (jtag_interface)
+	{
+		LOG_WARNING("Interface already configured, ignoring");
+		return ERROR_OK;
+	}
+
+	/* interface name is a mandatory argument */
+	if (CMD_ARGC != 1 || CMD_ARGV[0][0] == '\0')
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	for (unsigned i = 0; NULL != jtag_interfaces[i]; i++)
+	{
+		if (strcmp(CMD_ARGV[0], jtag_interfaces[i]->name) != 0)
+			continue;
+
+		if (NULL != jtag_interfaces[i]->commands)
+		{
+			int retval = register_commands(CMD_CTX, NULL,
+					jtag_interfaces[i]->commands);
+			if (ERROR_OK != retval)
+				return retval;
+		}
+
+		jtag_interface = jtag_interfaces[i];
+
+		if (jtag_interface->khz == NULL)
+			jtag_interface->khz = default_khz;
+		if (jtag_interface->speed_div == NULL)
+			jtag_interface->speed_div = default_speed_div;
+		if (jtag_interface->power_dropout == NULL)
+			jtag_interface->power_dropout = default_power_dropout;
+		if (jtag_interface->srst_asserted == NULL)
+			jtag_interface->srst_asserted = default_srst_asserted;
+
+		return ERROR_OK;
+	}
+
+	/* no valid interface was found (i.e. the configuration option,
+	 * didn't match one of the compiled-in interfaces
+	 */
+	LOG_ERROR("The specified debug interface was not found (%s)", CMD_ARGV[0]);
+	CALL_COMMAND_HANDLER(handle_interface_list_command);
+	return ERROR_JTAG_INVALID_INTERFACE;
+}
+
+COMMAND_HANDLER(handle_reset_config_command)
+{
+	int new_cfg = 0;
+	int mask = 0;
+
+	/* Original versions cared about the order of these tokens:
+	 *   reset_config signals [combination [trst_type [srst_type]]]
+	 * They also clobbered the previous configuration even on error.
+	 *
+	 * Here we don't care about the order, and only change values
+	 * which have been explicitly specified.
+	 */
+	for (; CMD_ARGC; CMD_ARGC--, CMD_ARGV++) {
+		int tmp = 0;
+		int m;
+
+		/* gating */
+		m = RESET_SRST_NO_GATING;
+		if (strcmp(*CMD_ARGV, "srst_gates_jtag") == 0)
+			/* default: don't use JTAG while SRST asserted */;
+		else if (strcmp(*CMD_ARGV, "srst_nogate") == 0)
+			tmp = RESET_SRST_NO_GATING;
+		else
+			m = 0;
+		if (mask & m) {
+			LOG_ERROR("extra reset_config %s spec (%s)",
+					"gating", *CMD_ARGV);
+			return ERROR_INVALID_ARGUMENTS;
+		}
+		if (m)
+			goto next;
+
+		/* signals */
+		m = RESET_HAS_TRST | RESET_HAS_SRST;
+		if (strcmp(*CMD_ARGV, "none") == 0)
+			tmp = RESET_NONE;
+		else if (strcmp(*CMD_ARGV, "trst_only") == 0)
+			tmp = RESET_HAS_TRST;
+		else if (strcmp(*CMD_ARGV, "srst_only") == 0)
+			tmp = RESET_HAS_SRST;
+		else if (strcmp(*CMD_ARGV, "trst_and_srst") == 0)
+			tmp = RESET_HAS_TRST | RESET_HAS_SRST;
+		else
+			m = 0;
+		if (mask & m) {
+			LOG_ERROR("extra reset_config %s spec (%s)",
+					"signal", *CMD_ARGV);
+			return ERROR_INVALID_ARGUMENTS;
+		}
+		if (m)
+			goto next;
+
+		/* combination (options for broken wiring) */
+		m = RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST;
+		if (strcmp(*CMD_ARGV, "separate") == 0)
+			/* separate reset lines - default */;
+		else if (strcmp(*CMD_ARGV, "srst_pulls_trst") == 0)
+			tmp |= RESET_SRST_PULLS_TRST;
+		else if (strcmp(*CMD_ARGV, "trst_pulls_srst") == 0)
+			tmp |= RESET_TRST_PULLS_SRST;
+		else if (strcmp(*CMD_ARGV, "combined") == 0)
+			tmp |= RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST;
+		else
+			m = 0;
+		if (mask & m) {
+			LOG_ERROR("extra reset_config %s spec (%s)",
+					"combination", *CMD_ARGV);
+			return ERROR_INVALID_ARGUMENTS;
+		}
+		if (m)
+			goto next;
+
+		/* trst_type (NOP without HAS_TRST) */
+		m = RESET_TRST_OPEN_DRAIN;
+		if (strcmp(*CMD_ARGV, "trst_open_drain") == 0)
+			tmp |= RESET_TRST_OPEN_DRAIN;
+		else if (strcmp(*CMD_ARGV, "trst_push_pull") == 0)
+			/* push/pull from adapter - default */;
+		else
+			m = 0;
+		if (mask & m) {
+			LOG_ERROR("extra reset_config %s spec (%s)",
+					"trst_type", *CMD_ARGV);
+			return ERROR_INVALID_ARGUMENTS;
+		}
+		if (m)
+			goto next;
+
+		/* srst_type (NOP without HAS_SRST) */
+		m |= RESET_SRST_PUSH_PULL;
+		if (strcmp(*CMD_ARGV, "srst_push_pull") == 0)
+			tmp |= RESET_SRST_PUSH_PULL;
+		else if (strcmp(*CMD_ARGV, "srst_open_drain") == 0)
+			/* open drain from adapter - default */;
+		else
+			m = 0;
+		if (mask & m) {
+			LOG_ERROR("extra reset_config %s spec (%s)",
+					"srst_type", *CMD_ARGV);
+			return ERROR_INVALID_ARGUMENTS;
+		}
+		if (m)
+			goto next;
+
+		/* caller provided nonsense; fail */
+		LOG_ERROR("unknown reset_config flag (%s)", *CMD_ARGV);
+		return ERROR_INVALID_ARGUMENTS;
+
+next:
+		/* Remember the bits which were specified (mask)
+		 * and their new values (new_cfg).
+		 */
+		mask |= m;
+		new_cfg |= tmp;
+	}
+
+	/* clear previous values of those bits, save new values */
+	if (mask) {
+		int old_cfg = jtag_get_reset_config();
+
+		old_cfg &= ~mask;
+		new_cfg |= old_cfg;
+		jtag_set_reset_config(new_cfg);
+	} else
+		new_cfg = jtag_get_reset_config();
+
+
+	/*
+	 * Display the (now-)current reset mode
+	 */
+	char *modes[5];
+
+	/* minimal JTAG has neither SRST nor TRST (so that's the default) */
+	switch (new_cfg & (RESET_HAS_TRST | RESET_HAS_SRST)) {
+	case RESET_HAS_SRST:
+		modes[0] = "srst_only";
+		break;
+	case RESET_HAS_TRST:
+		modes[0] = "trst_only";
+		break;
+	case RESET_TRST_AND_SRST:
+		modes[0] = "trst_and_srst";
+		break;
+	default:
+		modes[0] = "none";
+		break;
+	}
+
+	/* normally SRST and TRST are decoupled; but bugs happen ... */
+	switch (new_cfg & (RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST)) {
+	case RESET_SRST_PULLS_TRST:
+		modes[1] = "srst_pulls_trst";
+		break;
+	case RESET_TRST_PULLS_SRST:
+		modes[1] = "trst_pulls_srst";
+		break;
+	case RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST:
+		modes[1] = "combined";
+		break;
+	default:
+		modes[1] = "separate";
+		break;
+	}
+
+	/* TRST-less connectors include Altera, Xilinx, and minimal JTAG */
+	if (new_cfg & RESET_HAS_TRST) {
+		if (new_cfg & RESET_TRST_OPEN_DRAIN)
+			modes[3] = " trst_open_drain";
+		else
+			modes[3] = " trst_push_pull";
+	} else
+		modes[3] = "";
+
+	/* SRST-less connectors include TI-14, Xilinx, and minimal JTAG */
+	if (new_cfg & RESET_HAS_SRST) {
+		if (new_cfg & RESET_SRST_NO_GATING)
+			modes[2] = " srst_nogate";
+		else
+			modes[2] = " srst_gates_jtag";
+
+		if (new_cfg & RESET_SRST_PUSH_PULL)
+			modes[4] = " srst_push_pull";
+		else
+			modes[4] = " srst_open_drain";
+	} else {
+		modes[2] = "";
+		modes[4] = "";
+	}
+
+	command_print(CMD_CTX, "%s %s%s%s%s",
+			modes[0], modes[1],
+			modes[2], modes[3], modes[4]);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_adapter_nsrst_delay_command)
+{
+	if (CMD_ARGC > 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (CMD_ARGC == 1)
+	{
+		unsigned delay;
+		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], delay);
+
+		jtag_set_nsrst_delay(delay);
+	}
+	command_print(CMD_CTX, "adapter_nsrst_delay: %u", jtag_get_nsrst_delay());
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_adapter_khz_command)
+{
+	if (CMD_ARGC > 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	int retval = ERROR_OK;
+	if (CMD_ARGC == 1)
+	{
+		unsigned khz = 0;
+		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], khz);
+
+		retval = jtag_config_khz(khz);
+		if (ERROR_OK != retval)
+			return retval;
+	}
+
+	int cur_speed = jtag_get_speed_khz();
+	retval = jtag_get_speed_readable(&cur_speed);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (cur_speed)
+		command_print(CMD_CTX, "%d kHz", cur_speed);
+	else
+		command_print(CMD_CTX, "RCLK - adaptive");
+
+	return retval;
+}
+
+static const struct command_registration interface_command_handlers[] = {
+	{
+		.name = "adapter_khz",
+		.handler = handle_adapter_khz_command,
+		.mode = COMMAND_ANY,
+		.help = "With an argument, change to the specified maximum "
+			"jtag speed.  For JTAG, 0 KHz signifies adaptive "
+			" clocking. "
+			"With or without argument, display current setting.",
+		.usage = "[khz]",
+	},
+	{
+		.name = "adapter_name",
+		.mode = COMMAND_ANY,
+		.jim_handler = jim_adapter_name,
+		.help = "Returns the name of the currently "
+			"selected adapter (driver)",
+	},
+	{
+		.name = "adapter_nsrst_delay",
+		.handler = handle_adapter_nsrst_delay_command,
+		.mode = COMMAND_ANY,
+		.help = "delay after deasserting SRST in ms",
+		.usage = "[milliseconds]",
+	},
+	{
+		.name = "interface",
+		.handler = handle_interface_command,
+		.mode = COMMAND_CONFIG,
+		.help = "Select a debug adapter interface (driver)",
+		.usage = "driver_name",
+	},
+	{
+		.name = "interface_list",
+		.handler = handle_interface_list_command,
+		.mode = COMMAND_ANY,
+		.help = "List all built-in debug adapter interfaces (drivers)",
+	},
+	{
+		.name = "reset_config",
+		.handler = handle_reset_config_command,
+		.mode = COMMAND_ANY,
+		.help = "configure adapter reset behavior",
+		.usage = "[none|trst_only|srst_only|trst_and_srst] "
+			"[srst_pulls_trst|trst_pulls_srst|combined|separate] "
+			"[srst_gates_jtag|srst_nogate] "
+			"[trst_push_pull|trst_open_drain] "
+			"[srst_push_pull|srst_open_drain]",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+/**
+ * Register the commands which deal with arbitrary debug adapter drivers.
+ *
+ * @todo Remove internal assumptions that all debug adapters use JTAG for
+ * transport.  Various types and data structures are not named generically.
+ */
+int interface_register_commands(struct command_context *ctx)
+{
+	return register_commands(ctx, NULL, interface_command_handlers);
+}
diff --git a/src/jtag/startup.tcl b/src/jtag/startup.tcl
index 3a36886..496fdc8 100644
--- a/src/jtag/startup.tcl
+++ b/src/jtag/startup.tcl
@@ -78,7 +78,7 @@ proc srst_asserted {} {
 
 # BEGIN MIGRATION AIDS ...  these adapter operations originally had
 # JTAG-specific names despite the fact that the operations were not
-# specific to JTAG.
+# specific to JTAG, or otherewise had troublesome/misleading names.
 #
 # FIXME phase these aids out after about April 2011
 #
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 25516cf..7dc7fb7 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -40,6 +40,11 @@
 #include <strings.h>
 #endif
 
+/**
+ * @file
+ * Holds support for accessing JTAG-specific mechanisms from TCl scripts.
+ */
+
 static const Jim_Nvp nvp_jtag_tap_event[] = {
 	{ .value = JTAG_TRST_ASSERTED,		.name = "post-reset" },
 	{ .value = JTAG_TAP_EVENT_SETUP,	.name = "setup" },
@@ -671,24 +676,6 @@ static void jtag_tap_handle_event(struct jtag_tap *tap, enum jtag_event e)
 	}
 }
 
-static int
-jim_jtag_interface(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	Jim_GetOptInfo goi;
-	Jim_GetOpt_Setup(&goi, interp, argc-1, argv + 1);
-
-	/* return the name of the interface */
-	/* TCL code might need to know the exact type... */
-	/* FUTURE: we allow this as a means to "set" the interface. */
-	if (goi.argc != 0) {
-		Jim_WrongNumArgs(goi.interp, 1, goi.argv-1, "(no params)");
-		return JIM_ERR;
-	}
-	const char *name = jtag_interface ? jtag_interface->name : NULL;
-	Jim_SetResultString(goi.interp, name ? : "undefined", -1);
-	return JIM_OK;
-}
-
 static int jim_jtag_arp_init(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	Jim_GetOptInfo goi;
@@ -863,12 +850,6 @@ static const struct command_registration jtag_subcommand_handlers[] = {
 		.help = "initialize jtag scan chain",
 	},
 	{
-		.name = "interface",
-		.mode = COMMAND_ANY,
-		.jim_handler = jim_jtag_interface,
-		.help = "Returns the name of the currently selected interface.",
-	},
-	{
 		.name = "arp_init",
 		.mode = COMMAND_ANY,
 		.jim_handler = jim_jtag_arp_init,
@@ -957,93 +938,6 @@ void jtag_notify_event(enum jtag_event event)
 }
 
 
-static int default_khz(int khz, int *jtag_speed)
-{
-	LOG_ERROR("Translation from khz to jtag_speed not implemented");
-	return ERROR_FAIL;
-}
-
-static int default_speed_div(int speed, int *khz)
-{
-	LOG_ERROR("Translation from jtag_speed to khz not implemented");
-	return ERROR_FAIL;
-}
-
-static int default_power_dropout(int *dropout)
-{
-	*dropout = 0; /* by default we can't detect power dropout */
-	return ERROR_OK;
-}
-
-static int default_srst_asserted(int *srst_asserted)
-{
-	*srst_asserted = 0; /* by default we can't detect srst asserted */
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_interface_list_command)
-{
-	if (strcmp(CMD_NAME, "interface_list") == 0 && CMD_ARGC > 0)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	command_print(CMD_CTX, "The following debug interfaces are available:");
-	for (unsigned i = 0; NULL != jtag_interfaces[i]; i++)
-	{
-		const char *name = jtag_interfaces[i]->name;
-		command_print(CMD_CTX, "%u: %s", i + 1, name);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_interface_command)
-{
-	/* check whether the interface is already configured */
-	if (jtag_interface)
-	{
-		LOG_WARNING("Interface already configured, ignoring");
-		return ERROR_OK;
-	}
-
-	/* interface name is a mandatory argument */
-	if (CMD_ARGC != 1 || CMD_ARGV[0][0] == '\0')
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	for (unsigned i = 0; NULL != jtag_interfaces[i]; i++)
-	{
-		if (strcmp(CMD_ARGV[0], jtag_interfaces[i]->name) != 0)
-			continue;
-
-		if (NULL != jtag_interfaces[i]->commands)
-		{
-			int retval = register_commands(CMD_CTX, NULL,
-					jtag_interfaces[i]->commands);
-			if (ERROR_OK != retval)
-				return retval;
-		}
-
-		jtag_interface = jtag_interfaces[i];
-
-		if (jtag_interface->khz == NULL)
-			jtag_interface->khz = default_khz;
-		if (jtag_interface->speed_div == NULL)
-			jtag_interface->speed_div = default_speed_div;
-		if (jtag_interface->power_dropout == NULL)
-			jtag_interface->power_dropout = default_power_dropout;
-		if (jtag_interface->srst_asserted == NULL)
-			jtag_interface->srst_asserted = default_srst_asserted;
-
-		return ERROR_OK;
-	}
-
-	/* no valid interface was found (i.e. the configuration option,
-	 * didn't match one of the compiled-in interfaces
-	 */
-	LOG_ERROR("The specified debug interface was not found (%s)", CMD_ARGV[0]);
-	CALL_COMMAND_HANDLER(handle_interface_list_command);
-	return ERROR_JTAG_INVALID_INTERFACE;
-}
-
 COMMAND_HANDLER(handle_scan_chain_command)
 {
 	struct jtag_tap *tap;
@@ -1096,217 +990,6 @@ COMMAND_HANDLER(handle_scan_chain_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_reset_config_command)
-{
-	int new_cfg = 0;
-	int mask = 0;
-
-	/* Original versions cared about the order of these tokens:
-	 *   reset_config signals [combination [trst_type [srst_type]]]
-	 * They also clobbered the previous configuration even on error.
-	 *
-	 * Here we don't care about the order, and only change values
-	 * which have been explicitly specified.
-	 */
-	for (; CMD_ARGC; CMD_ARGC--, CMD_ARGV++) {
-		int tmp = 0;
-		int m;
-
-		/* gating */
-		m = RESET_SRST_NO_GATING;
-		if (strcmp(*CMD_ARGV, "srst_gates_jtag") == 0)
-			/* default: don't use JTAG while SRST asserted */;
-		else if (strcmp(*CMD_ARGV, "srst_nogate") == 0)
-			tmp = RESET_SRST_NO_GATING;
-		else
-			m = 0;
-		if (mask & m) {
-			LOG_ERROR("extra reset_config %s spec (%s)",
-					"gating", *CMD_ARGV);
-			return ERROR_INVALID_ARGUMENTS;
-		}
-		if (m)
-			goto next;
-
-		/* signals */
-		m = RESET_HAS_TRST | RESET_HAS_SRST;
-		if (strcmp(*CMD_ARGV, "none") == 0)
-			tmp = RESET_NONE;
-		else if (strcmp(*CMD_ARGV, "trst_only") == 0)
-			tmp = RESET_HAS_TRST;
-		else if (strcmp(*CMD_ARGV, "srst_only") == 0)
-			tmp = RESET_HAS_SRST;
-		else if (strcmp(*CMD_ARGV, "trst_and_srst") == 0)
-			tmp = RESET_HAS_TRST | RESET_HAS_SRST;
-		else
-			m = 0;
-		if (mask & m) {
-			LOG_ERROR("extra reset_config %s spec (%s)",
-					"signal", *CMD_ARGV);
-			return ERROR_INVALID_ARGUMENTS;
-		}
-		if (m)
-			goto next;
-
-		/* combination (options for broken wiring) */
-		m = RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST;
-		if (strcmp(*CMD_ARGV, "separate") == 0)
-			/* separate reset lines - default */;
-		else if (strcmp(*CMD_ARGV, "srst_pulls_trst") == 0)
-			tmp |= RESET_SRST_PULLS_TRST;
-		else if (strcmp(*CMD_ARGV, "trst_pulls_srst") == 0)
-			tmp |= RESET_TRST_PULLS_SRST;
-		else if (strcmp(*CMD_ARGV, "combined") == 0)
-			tmp |= RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST;
-		else
-			m = 0;
-		if (mask & m) {
-			LOG_ERROR("extra reset_config %s spec (%s)",
-					"combination", *CMD_ARGV);
-			return ERROR_INVALID_ARGUMENTS;
-		}
-		if (m)
-			goto next;
-
-		/* trst_type (NOP without HAS_TRST) */
-		m = RESET_TRST_OPEN_DRAIN;
-		if (strcmp(*CMD_ARGV, "trst_open_drain") == 0)
-			tmp |= RESET_TRST_OPEN_DRAIN;
-		else if (strcmp(*CMD_ARGV, "trst_push_pull") == 0)
-			/* push/pull from adapter - default */;
-		else
-			m = 0;
-		if (mask & m) {
-			LOG_ERROR("extra reset_config %s spec (%s)",
-					"trst_type", *CMD_ARGV);
-			return ERROR_INVALID_ARGUMENTS;
-		}
-		if (m)
-			goto next;
-
-		/* srst_type (NOP without HAS_SRST) */
-		m |= RESET_SRST_PUSH_PULL;
-		if (strcmp(*CMD_ARGV, "srst_push_pull") == 0)
-			tmp |= RESET_SRST_PUSH_PULL;
-		else if (strcmp(*CMD_ARGV, "srst_open_drain") == 0)
-			/* open drain from adapter - default */;
-		else
-			m = 0;
-		if (mask & m) {
-			LOG_ERROR("extra reset_config %s spec (%s)",
-					"srst_type", *CMD_ARGV);
-			return ERROR_INVALID_ARGUMENTS;
-		}
-		if (m)
-			goto next;
-
-		/* caller provided nonsense; fail */
-		LOG_ERROR("unknown reset_config flag (%s)", *CMD_ARGV);
-		return ERROR_INVALID_ARGUMENTS;
-
-next:
-		/* Remember the bits which were specified (mask)
-		 * and their new values (new_cfg).
-		 */
-		mask |= m;
-		new_cfg |= tmp;
-	}
-
-	/* clear previous values of those bits, save new values */
-	if (mask) {
-		int old_cfg = jtag_get_reset_config();
-
-		old_cfg &= ~mask;
-		new_cfg |= old_cfg;
-		jtag_set_reset_config(new_cfg);
-	} else
-		new_cfg = jtag_get_reset_config();
-
-
-	/*
-	 * Display the (now-)current reset mode
-	 */
-	char *modes[5];
-
-	/* minimal JTAG has neither SRST nor TRST (so that's the default) */
-	switch (new_cfg & (RESET_HAS_TRST | RESET_HAS_SRST)) {
-	case RESET_HAS_SRST:
-		modes[0] = "srst_only";
-		break;
-	case RESET_HAS_TRST:
-		modes[0] = "trst_only";
-		break;
-	case RESET_TRST_AND_SRST:
-		modes[0] = "trst_and_srst";
-		break;
-	default:
-		modes[0] = "none";
-		break;
-	}
-
-	/* normally SRST and TRST are decoupled; but bugs happen ... */
-	switch (new_cfg & (RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST)) {
-	case RESET_SRST_PULLS_TRST:
-		modes[1] = "srst_pulls_trst";
-		break;
-	case RESET_TRST_PULLS_SRST:
-		modes[1] = "trst_pulls_srst";
-		break;
-	case RESET_SRST_PULLS_TRST | RESET_TRST_PULLS_SRST:
-		modes[1] = "combined";
-		break;
-	default:
-		modes[1] = "separate";
-		break;
-	}
-
-	/* TRST-less connectors include Altera, Xilinx, and minimal JTAG */
-	if (new_cfg & RESET_HAS_TRST) {
-		if (new_cfg & RESET_TRST_OPEN_DRAIN)
-			modes[3] = " trst_open_drain";
-		else
-			modes[3] = " trst_push_pull";
-	} else
-		modes[3] = "";
-
-	/* SRST-less connectors include TI-14, Xilinx, and minimal JTAG */
-	if (new_cfg & RESET_HAS_SRST) {
-		if (new_cfg & RESET_SRST_NO_GATING)
-			modes[2] = " srst_nogate";
-		else
-			modes[2] = " srst_gates_jtag";
-
-		if (new_cfg & RESET_SRST_PUSH_PULL)
-			modes[4] = " srst_push_pull";
-		else
-			modes[4] = " srst_open_drain";
-	} else {
-		modes[2] = "";
-		modes[4] = "";
-	}
-
-	command_print(CMD_CTX, "%s %s%s%s%s",
-			modes[0], modes[1],
-			modes[2], modes[3], modes[4]);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_adapter_nsrst_delay_command)
-{
-	if (CMD_ARGC > 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	if (CMD_ARGC == 1)
-	{
-		unsigned delay;
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], delay);
-
-		jtag_set_nsrst_delay(delay);
-	}
-	command_print(CMD_CTX, "adapter_nsrst_delay: %u", jtag_get_nsrst_delay());
-	return ERROR_OK;
-}
-
 COMMAND_HANDLER(handle_jtag_ntrst_delay_command)
 {
 	if (CMD_ARGC > 1)
@@ -1322,21 +1005,6 @@ COMMAND_HANDLER(handle_jtag_ntrst_delay_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_adapter_nsrst_assert_width_command)
-{
-	if (CMD_ARGC > 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	if (CMD_ARGC == 1)
-	{
-		unsigned delay;
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], delay);
-
-		jtag_set_nsrst_assert_width(delay);
-	}
-	command_print(CMD_CTX, "adapter_nsrst_assert_width: %u", jtag_get_nsrst_assert_width());
-	return ERROR_OK;
-}
-
 COMMAND_HANDLER(handle_jtag_ntrst_assert_width_command)
 {
 	if (CMD_ARGC > 1)
@@ -1352,35 +1020,6 @@ COMMAND_HANDLER(handle_jtag_ntrst_assert_width_command)
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_adapter_khz_command)
-{
-	if (CMD_ARGC > 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	int retval = ERROR_OK;
-	if (CMD_ARGC == 1)
-	{
-		unsigned khz = 0;
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], khz);
-
-		retval = jtag_config_khz(khz);
-		if (ERROR_OK != retval)
-			return retval;
-	}
-
-	int cur_speed = jtag_get_speed_khz();
-	retval = jtag_get_speed_readable(&cur_speed);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (cur_speed)
-		command_print(CMD_CTX, "%d kHz", cur_speed);
-	else
-		command_print(CMD_CTX, "RCLK - adaptive");
-
-	return retval;
-}
-
 COMMAND_HANDLER(handle_jtag_rclk_command)
 {
 	if (CMD_ARGC > 1)
@@ -1608,69 +1247,6 @@ COMMAND_HANDLER(handle_tms_sequence_command)
 	return ERROR_OK;
 }
 
-static const struct command_registration interface_command_handlers[] = {
-	{
-		.name = "adapter_khz",
-		.handler = handle_adapter_khz_command,
-		.mode = COMMAND_ANY,
-		.help = "With an argument, change to the specified maximum "
-			"jtag speed.  For JTAG, 0 KHz signifies adaptive "
-			" clocking. "
-			"With or without argument, display current setting.",
-		.usage = "[khz]",
-	},
-	{
-		.name = "adapter_nsrst_assert_width",
-		.handler = handle_adapter_nsrst_assert_width_command,
-		.mode = COMMAND_ANY,
-		.help = "delay after asserting SRST in ms",
-		.usage = "[milliseconds]",
-	},
-	{
-		.name = "adapter_nsrst_delay",
-		.handler = handle_adapter_nsrst_delay_command,
-		.mode = COMMAND_ANY,
-		.help = "delay after deasserting SRST in ms",
-		.usage = "[milliseconds]",
-	},
-	{
-		.name = "interface",
-		.handler = handle_interface_command,
-		.mode = COMMAND_CONFIG,
-		.help = "Select a debug adapter interface (driver)",
-		.usage = "driver_name",
-	},
-	{
-		.name = "interface_list",
-		.handler = handle_interface_list_command,
-		.mode = COMMAND_ANY,
-		.help = "List all built-in debug adapter interfaces (drivers)",
-	},
-	{
-		.name = "reset_config",
-		.handler = handle_reset_config_command,
-		.mode = COMMAND_ANY,
-		.help = "configure adapter reset behavior",
-		.usage = "[none|trst_only|srst_only|trst_and_srst] "
-			"[srst_pulls_trst|trst_pulls_srst|combined|separate] "
-			"[srst_gates_jtag|srst_nogate] "
-			"[trst_push_pull|trst_open_drain] "
-			"[srst_push_pull|srst_open_drain]",
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-/**
- * Register the commands which deal with arbitrary debug adapter drivers.
- *
- * @todo Remove internal assumptions that all debug adapters use JTAG for
- * transport.  Various types and data structures are not named generically.
- */
-int interface_register_commands(struct command_context *ctx)
-{
-	return register_commands(ctx, NULL, interface_command_handlers);
-}
-
 static const struct command_registration jtag_command_handlers[] = {
 	{
 		.name = "jtag_rclk",

-----------------------------------------------------------------------

Summary of changes:
 NEWS                 |    3 +-
 doc/openocd.texi     |    6 +-
 src/jtag/Makefile.am |    1 +
 src/jtag/adapter.c   |  459 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/jtag/startup.tcl |    2 +-
 src/jtag/tcl.c       |  434 +----------------------------------------------
 6 files changed, 471 insertions(+), 434 deletions(-)
 create mode 100644 src/jtag/adapter.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Mar 29 20:24:55 2010
From: gowinex at users.sourceforge.net (yvind Harboe)
Date: Mon, 29 Mar 2010 18:24:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-141-g33e5dd1
Message-ID: <E1NwJdw-0003tz-Mi@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  33e5dd12729d995b351ece716e8c835dd8331c71 (commit)
      from  d60ebc0ab535e54f76e734d00d9ac1b5c9b6eb93 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 33e5dd12729d995b351ece716e8c835dd8331c71
Author: Mike Dunn <mikedunn at newsguy.com>
Date:   Sun Mar 28 15:48:32 2010 -0400

    xscale: fix trace buffer functionality when resuming from a breakpoint
    
    Problem: halt at a breakpoint, enable trace buffer ('xscale trace_buffer enable
    fill'), then resume.  Wait for debug exception when trace buffer fills (if not
    sooner due to another breakpoint, vector catch, etc).  Instead, never halts.
    When halted explicitly from OpenOCD and trace buffer dumped, it contains only
    one entry; a branch to the address of the original breakpoint.  If the above
    steps are repeated, except that the breakpoint is removed before resuming, the
    trace buffer fills and the debug exception is generated, as expected.
    
    Cause: related to how a breakpoint is stepped over on resume.  The breakpoint is
    temporarily removed, and a hardware breakpoint is set on the next instruction
    that will execute.  xscale_debug_entry() is called when that breakpoint hits.
    This function checks if the trace buffer is enabled, and if so reads the trace
    buffer from the target and then disables the trace (unless multiple trace
    buffers are specified by the user when trace is enabled).  Thus you only trace
    one instruction before it is disabled.
    
    Solution: kind of a hack on top of a hack, but it's simple.  Anything better
    would involve some refactoring.  This has been tested and trace now works as
    intended, except that the very first instruction is not part of the trace when
    resuming from a breakpoint.
    
    TODO: still many issues with trace: doesn't work during single-stepping (trace
    buffer is flushed each step), 'xscale analyze_trace' works only marginally for
    a trace captured in 'fill' mode, and not at all for a trace captured in 'wrap'
    mode.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/xscale.c b/src/target/xscale.c
index e578a77..24c0794 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1206,6 +1206,7 @@ static int xscale_resume(struct target *target, int current,
 		if (breakpoint != NULL)
 		{
 			uint32_t next_pc;
+			int saved_trace_buffer_enabled;
 
 			/* there's a breakpoint at the current PC, we have to step over it */
 			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
@@ -1225,15 +1226,8 @@ static int xscale_resume(struct target *target, int current,
 			/* restore banked registers */
 			retval = xscale_restore_banked(target);
 
-			/* send resume request (command 0x30 or 0x31)
-			 * clean the trace buffer if it is to be enabled (0x62) */
-			if (xscale->trace.buffer_enabled)
-			{
-				xscale_send_u32(target, 0x62);
-				xscale_send_u32(target, 0x31);
-			}
-			else
-				xscale_send_u32(target, 0x30);
+			/* send resume request */
+			xscale_send_u32(target, 0x30);
 
 			/* send CPSR */
 			xscale_send_u32(target,
@@ -1254,9 +1248,16 @@ static int xscale_resume(struct target *target, int current,
 			LOG_DEBUG("writing PC with value 0x%8.8" PRIx32,
 					buf_get_u32(armv4_5->pc->value, 0, 32));
 
+			/* disable trace data collection in xscale_debug_entry() */
+			saved_trace_buffer_enabled = xscale->trace.buffer_enabled;
+			xscale->trace.buffer_enabled = 0;
+
 			/* wait for and process debug entry */
 			xscale_debug_entry(target);
 
+			/* re-enable trace buffer, if enabled previously */
+			xscale->trace.buffer_enabled = saved_trace_buffer_enabled;
+
 			LOG_DEBUG("disable single-step");
 			xscale_disable_single_step(target);
 
@@ -1276,6 +1277,12 @@ static int xscale_resume(struct target *target, int current,
 	 * clean the trace buffer if it is to be enabled (0x62) */
 	if (xscale->trace.buffer_enabled)
 	{
+		/* if trace buffer is set to 'fill' mode, save starting pc */
+		if (xscale->trace.buffer_fill > 0)
+		{
+			xscale->trace.pc_ok = 1;
+			xscale->trace.current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
+		}
 		xscale_send_u32(target, 0x62);
 		xscale_send_u32(target, 0x31);
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/target/xscale.c |   25 ++++++++++++++++---------
 1 files changed, 16 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


