From gowinex at users.sourceforge.net  Wed Feb  2 08:35:35 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  2 Feb 2011 07:35:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-734-gaaf145c
Message-ID: <E1PkXFa-0004Mb-EY@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  aaf145c42201496007e0fc9168d9738cb0237717 (commit)
       via  efcea8306af922d867ff93073959dad774e10f0c (commit)
      from  859ccccd8076910f7b022d712beeaffaf2f2fa9e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit aaf145c42201496007e0fc9168d9738cb0237717
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Wed Feb 2 18:16:26 2011 +1100

    omap4430: fix reset sequence
    
    * Write to the PRM reset control register should have been 'phys';
    * Setup empty reset-assert handlers for the M3's, since the board-level reset
      takes care of them;
    * Remove the dbginit cruft, because it gets called implicitly on reset.
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
index 360ac66..69678ee 100644
--- a/tcl/target/omap4430.cfg
+++ b/tcl/target/omap4430.cfg
@@ -92,15 +92,10 @@ jtag configure $_CHIPNAME.jrc -event setup "
 	jtag tapenable $_CHIPNAME.m31_dap
 "
 
-proc omap4_dbginit {target} {
-	# General Cortex A9 debug initialisation
-	cortex_a9 dbginit
-}
-
-$_TARGETNAME configure -event reset-assert-post "omap4_dbginit $_TARGETNAME"
-
 # Assume SRST is unavailable (e.g. TI-14 JTAG), so we must assert reset
 # ourselves using PRM_RSTCTRL.  1 is a warm reset, 2 a cold reset.
 set PRM_RSTCTRL 0x4A307B00
-$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww $PRM_RSTCTRL 0x1"
+$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww phys $PRM_RSTCTRL 0x1"
+$_CHIPNAME.m30 configure -event reset-assert { }
+$_CHIPNAME.m31 configure -event reset-assert { }
 

commit efcea8306af922d867ff93073959dad774e10f0c
Author: Aaron Carroll <aaronc at cse.unsw.edu.au>
Date:   Wed Feb 2 18:16:25 2011 +1100

    cortex_m3: allow scripts to override reset
    
    If a handler for the reset-assert event it present, skip the usual reset
    handling.  This is needed, for example, for board-level resets.
    
    Signed-off-by: Aaron Carroll <aaronc at cse.unsw.edu.au>

diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index f6918af..5fd56e4 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -927,6 +927,16 @@ static int cortex_m3_assert_reset(struct target *target)
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 
+	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
+		/* allow scripts to override the reset event */
+
+		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
+		register_cache_invalidate(cortex_m3->armv7m.core_cache);
+		target->state = TARGET_RESET;
+
+		return ERROR_OK;
+	}
+
 	/* Enable debug requests */
 	int retval;
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m3->dcb_dhcsr);

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_m3.c  |   10 ++++++++++
 tcl/target/omap4430.cfg |   11 +++--------
 2 files changed, 13 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb  3 12:26:39 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  3 Feb 2011 11:26:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-735-gb0bdc4e
Message-ID: <E1PkxKj-0001jX-V9@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b0bdc4e2f2b4fd31ae3b0ebf47765e88c4c37556 (commit)
      from  aaf145c42201496007e0fc9168d9738cb0237717 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b0bdc4e2f2b4fd31ae3b0ebf47765e88c4c37556
Author: Mathias K <kesmtp at freenet.de>
Date:   Wed Feb 2 17:38:38 2011 +0100

    24bit buffer support
    
    Hello,
    
    this patch add 24bit support to the target buffer functions and little/big endian functions.
    
    Regards,
    
    Mathias

diff --git a/src/helper/types.h b/src/helper/types.h
index 04b0059..12b9515 100644
--- a/src/helper/types.h
+++ b/src/helper/types.h
@@ -116,6 +116,11 @@ static inline uint32_t le_to_h_u32(const uint8_t* buf)
 	return (uint32_t)(buf[0] | buf[1] << 8 | buf[2] << 16 | buf[3] << 24);
 }
 
+static inline uint32_t le_to_h_u24(const uint8_t* buf)
+{
+	return (uint32_t)(buf[0] | buf[1] << 8 | buf[2] << 16);
+}
+
 static inline uint16_t le_to_h_u16(const uint8_t* buf)
 {
 	return (uint16_t)(buf[0] | buf[1] << 8);
@@ -126,6 +131,11 @@ static inline uint32_t be_to_h_u32(const uint8_t* buf)
 	return (uint32_t)(buf[3] | buf[2] << 8 | buf[1] << 16 | buf[0] << 24);
 }
 
+static inline uint32_t be_to_h_u24(const uint8_t* buf)
+{
+	return (uint32_t)(buf[2] | buf[1] << 8 | buf[0] << 16);
+}
+
 static inline uint16_t be_to_h_u16(const uint8_t* buf)
 {
 	return (uint16_t)(buf[1] | buf[0] << 8);
@@ -147,6 +157,20 @@ static inline void h_u32_to_be(uint8_t* buf, int val)
 	buf[3] = (uint8_t) (val >> 0);
 }
 
+static inline void h_u24_to_le(uint8_t* buf, int val)
+{
+	buf[2] = (uint8_t) (val >> 16);
+	buf[1] = (uint8_t) (val >> 8);
+	buf[0] = (uint8_t) (val >> 0);
+}
+
+static inline void h_u24_to_be(uint8_t* buf, int val)
+{
+	buf[0] = (uint8_t) (val >> 16);
+	buf[1] = (uint8_t) (val >> 8);
+	buf[2] = (uint8_t) (val >> 0);
+}
+
 static inline void h_u16_to_le(uint8_t* buf, int val)
 {
 	buf[1] = (uint8_t) (val >> 8);
diff --git a/src/target/target.c b/src/target/target.c
index 66aa6bf..3a6c6bb 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -280,6 +280,15 @@ uint32_t target_buffer_get_u32(struct target *target, const uint8_t *buffer)
 		return be_to_h_u32(buffer);
 }
 
+/* read a uint24_t from a buffer in target memory endianness */
+uint32_t target_buffer_get_u24(struct target *target, const uint8_t *buffer)
+{
+	if (target->endianness == TARGET_LITTLE_ENDIAN)
+		return le_to_h_u24(buffer);
+	else
+		return be_to_h_u24(buffer);
+}
+
 /* read a uint16_t from a buffer in target memory endianness */
 uint16_t target_buffer_get_u16(struct target *target, const uint8_t *buffer)
 {
@@ -304,6 +313,15 @@ void target_buffer_set_u32(struct target *target, uint8_t *buffer, uint32_t valu
 		h_u32_to_be(buffer, value);
 }
 
+/* write a uint24_t to a buffer in target memory endianness */
+void target_buffer_set_u24(struct target *target, uint8_t *buffer, uint32_t value)
+{
+	if (target->endianness == TARGET_LITTLE_ENDIAN)
+		h_u24_to_le(buffer, value);
+	else
+		h_u24_to_be(buffer, value);
+}
+
 /* write a uint16_t to a buffer in target memory endianness */
 void target_buffer_set_u16(struct target *target, uint8_t *buffer, uint16_t value)
 {
diff --git a/src/target/target.h b/src/target/target.h
index 2c6f4cd..2bf9668 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -479,8 +479,10 @@ void target_free_all_working_areas(struct target *target);
 extern struct target *all_targets;
 
 uint32_t target_buffer_get_u32(struct target *target, const uint8_t *buffer);
+uint32_t target_buffer_get_u24(struct target *target, const uint8_t *buffer);
 uint16_t target_buffer_get_u16(struct target *target, const uint8_t *buffer);
 void target_buffer_set_u32(struct target *target, uint8_t *buffer, uint32_t value);
+void target_buffer_set_u24(struct target *target, uint8_t *buffer, uint32_t value);
 void target_buffer_set_u16(struct target *target, uint8_t *buffer, uint16_t value);
 
 int target_read_u32(struct target *target, uint32_t address, uint32_t *value);

-----------------------------------------------------------------------

Summary of changes:
 src/helper/types.h  |   24 ++++++++++++++++++++++++
 src/target/target.c |   18 ++++++++++++++++++
 src/target/target.h |    2 ++
 3 files changed, 44 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb  3 12:29:01 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  3 Feb 2011 11:29:01 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-736-g75cdbff
Message-ID: <E1PkxN1-0001t0-3W@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  75cdbff5aa93d93e414cb22d413f41fb38a076bb (commit)
      from  b0bdc4e2f2b4fd31ae3b0ebf47765e88c4c37556 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 75cdbff5aa93d93e414cb22d413f41fb38a076bb
Author: Mathias K <kesmtp at freenet.de>
Date:   Tue Feb 1 13:00:59 2011 +0100

    more changes to dsp563xx code
    
    Hello,
    
    this patch adds the missing cpu registers and the correct read/write register functions and fixed
    most of the halt/step/resume issues. The complete missing error propagation was added.
    
    + fix tab/spaces
    
    Regards,
    
    Mathias

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 10fd014..85d559a 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   Copyright (C) 2009-2011 by Mathias Kuester                            *
  *   mkdorg at users.sourceforge.net                                          *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -29,37 +29,7 @@
 #include "dsp563xx.h"
 #include "dsp563xx_once.h"
 
-#define DSP563XX_JTAG_INS_LEN		4
-
-#define JTAG_STATUS_NORMAL		0x01
-#define JTAG_STATUS_STOPWAIT		0x05
-#define JTAG_STATUS_BUSY		0x09
-#define JTAG_STATUS_DEBUG		0x0d
-
-#define JTAG_INSTR_EXTEST		0x00
-#define JTAG_INSTR_SAMPLE_PRELOAD	0x01
-#define JTAG_INSTR_IDCODE		0x02
-#define JTAG_INSTR_CLAMP		0x03
-#define JTAG_INSTR_HIZ			0x04
-#define JTAG_INSTR_ENABLE_ONCE		0x06
-#define JTAG_INSTR_DEBUG_REQUEST	0x07
-#define JTAG_INSTR_BYPASS		0x0F
-
-/* forward declarations */
-static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
-		int ir_len, int rti);
-
-/* IR and DR functions */
-static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out);
-
-#define ASM_REG_R_R0	0x607000
-#define ASM_REG_R_R1	0x617000
-#define ASM_REG_R_R2	0x627000
-#define ASM_REG_R_R3	0x637000
-#define ASM_REG_R_R4	0x647000
-#define ASM_REG_R_R5	0x657000
-#define ASM_REG_R_R6	0x667000
-#define ASM_REG_R_R7	0x677000
+//#define DSP563XX_JTAG_INS_LEN         4
 
 #define ASM_REG_W_R0	0x60F400
 #define ASM_REG_W_R1	0x61F400
@@ -70,15 +40,6 @@ static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_
 #define ASM_REG_W_R6	0x66F400
 #define ASM_REG_W_R7	0x67F400
 
-#define ASM_REG_R_N0	0x707000
-#define ASM_REG_R_N1	0x717000
-#define ASM_REG_R_N2	0x727000
-#define ASM_REG_R_N3	0x737000
-#define ASM_REG_R_N4	0x747000
-#define ASM_REG_R_N5	0x757000
-#define ASM_REG_R_N6	0x767000
-#define ASM_REG_R_N7	0x777000
-
 #define ASM_REG_W_N0	0x70F400
 #define ASM_REG_W_N1	0x71F400
 #define ASM_REG_W_N2	0x72F400
@@ -88,15 +49,6 @@ static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_
 #define ASM_REG_W_N6	0x76F400
 #define ASM_REG_W_N7	0x77F400
 
-#define ASM_REG_R_M0	0x057020	/* control register m[0..7] */
-#define ASM_REG_R_M1	0x057021
-#define ASM_REG_R_M2	0x057022
-#define ASM_REG_R_M3	0x057023
-#define ASM_REG_R_M4	0x057024
-#define ASM_REG_R_M5	0x057025
-#define ASM_REG_R_M6	0x057026
-#define ASM_REG_R_M7	0x057027
-
 #define ASM_REG_W_M0	0x05F420
 #define ASM_REG_W_M1	0x05F421
 #define ASM_REG_W_M2	0x05F422
@@ -106,132 +58,185 @@ static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_
 #define ASM_REG_W_M6	0x05F426
 #define ASM_REG_W_M7	0x05F427
 
-#define ASM_REG_R_X0	0x447000
-#define ASM_REG_R_X1	0x457000
-
 #define ASM_REG_W_X0	0x44F400
 #define ASM_REG_W_X1	0x45F400
 
-#define ASM_REG_R_Y0	0x467000
-#define ASM_REG_R_Y1	0x477000
-
 #define ASM_REG_W_Y0	0x46F400
 #define ASM_REG_W_Y1	0x47F400
 
-#define ASM_REG_R_A0	0x507000
-#define ASM_REG_R_A1	0x547000
-#define ASM_REG_R_A2	0x527000
-
 #define ASM_REG_W_A0	0x50F400
 #define ASM_REG_W_A1	0x54F400
 #define ASM_REG_W_A2	0x52F400
 
-#define ASM_REG_R_B0	0x517000
-#define ASM_REG_R_B1	0x557000
-#define ASM_REG_R_B2	0x537000
-
 #define ASM_REG_W_B0	0x51F400
 #define ASM_REG_W_B1	0x55F400
 #define ASM_REG_W_B2	0x53F400
 
-#define ASM_REG_R_VBA	0x057030	/* control register */
 #define ASM_REG_W_VBA	0x05F430
-
-#define ASM_REG_R_OMR	0x05703A	/* control register */
 #define ASM_REG_W_OMR	0x05F43A
-
-#define ASM_REG_R_EP	0x05702A
 #define ASM_REG_W_EP	0x05F42A
-
-#define ASM_REG_R_SC	0x057031	/* stack counter */
 #define ASM_REG_W_SC	0x05F431
-
-#define ASM_REG_R_SZ	0x057038	/* stack size */
 #define ASM_REG_W_SZ	0x05F438
-
-#define ASM_REG_R_SR	0x057039	/* control register, status register */
 #define ASM_REG_W_SR	0x05F439
-
-#define ASM_REG_R_SP	0x05703B	/* control register, stack pointer */
 #define ASM_REG_W_SP	0x05F43B
-
-#define ASM_REG_R_SSH	0x05703C	/* control register, system stack high */
-#define ASM_REG_W_SSH	0x05743C
-
-#define ASM_REG_R_SSL	0x05703D	/* control register, system stack low */
+#define ASM_REG_W_SSH	0x05F43C
 #define ASM_REG_W_SSL	0x05F43D
-
-#define ASM_REG_R_LA	0x05703E	/* control register, loop address */
 #define ASM_REG_W_LA	0x05F43E
-
-#define ASM_REG_R_LC	0x05703F	/* control register, loop count */
 #define ASM_REG_W_LC	0x05F43F
-
-#define ASM_REG_R_PC	0x000000
 #define ASM_REG_W_PC	0x000000
+#define ASM_REG_W_IPRC	0xFFFFFF
+#define ASM_REG_W_IPRP	0xFFFFFE
+
+#define ASM_REG_W_BCR	0xFFFFFB
+#define ASM_REG_W_DCR	0xFFFFFA
+#define ASM_REG_W_AAR0	0xFFFFF9
+#define ASM_REG_W_AAR1	0xFFFFF8
+#define ASM_REG_W_AAR2	0xFFFFF7
+#define ASM_REG_W_AAR3	0xFFFFF6
+
+static struct once_reg once_regs[] = {
+	{0, 0x00, 24, "OSCR", 0},
+	{1, 0x01, 24, "OMBC", 0},
+	{2, 0x02, 24, "OBCR", 0},
+	{3, 0x05, 24, "OMLR0", 0},
+	{4, 0x06, 24, "OMLR1", 0},
+	{5, 0x09, 24, "OGDBR", 0},
+	{6, 0x0a, 24, "OPDBR", 0},
+	{7, 0x0b, 24, "OPILR", 0},
+	{8, 0x0c, 24, "PDB", 0},
+	{9, 0x0d, 24, "OTC", 0},
+	{10, 0x0f, 24, "OPABFR", 0},
+	{11, 0x10, 24, "OPABDR", 0},
+	{12, 0x11, 24, "OPABEX", 0},
+	{13, 0x12, 25, "OPABF0", 0},
+	{14, 0x12, 25, "OPABF1", 0},
+	{15, 0x12, 25, "OPABF2", 0},
+	{16, 0x12, 25, "OPABF3", 0},
+	{17, 0x12, 25, "OPABF4", 0},
+	{18, 0x12, 25, "OPABF5", 0},
+	{19, 0x12, 25, "OPABF6", 0},
+	{20, 0x12, 25, "OPABF7", 0},
+	{21, 0x12, 25, "OPABF8", 0},
+	{22, 0x12, 25, "OPABF9", 0},
+	{23, 0x12, 25, "OPABF10", 0},
+	{24, 0x12, 25, "OPABF11", 0},
+//      {25,0x1f,24,"NRSEL",0},
+};
 
 static const struct
 {
 	unsigned id;
 	const char *name;
 	unsigned bits;
-	uint32_t r_cmd;
-	uint32_t w_cmd;
+	/* effective addressing mode encoding */
+	uint8_t eame;
+	uint32_t instr_mask;
 } dsp563xx_regs[] =
 {
 	/* *INDENT-OFF* */
-	{0, "r0", 24, ASM_REG_R_R0, ASM_REG_W_R0},
-	{1, "r1", 24, ASM_REG_R_R1, ASM_REG_W_R1},
-	{2, "r2", 24, ASM_REG_R_R2, ASM_REG_W_R2},
-	{3, "r3", 24, ASM_REG_R_R3, ASM_REG_W_R3},
-	{4, "r4", 24, ASM_REG_R_R4, ASM_REG_W_R4},
-	{5, "r5", 24, ASM_REG_R_R5, ASM_REG_W_R5},
-	{6, "r6", 24, ASM_REG_R_R6, ASM_REG_W_R6},
-	{7, "r7", 24, ASM_REG_R_R7, ASM_REG_W_R7},
-	{8, "n0", 24, ASM_REG_R_N0, ASM_REG_W_N0},
-	{9, "n1", 24, ASM_REG_R_N1, ASM_REG_W_N1},
-	{10, "n2", 24, ASM_REG_R_N2, ASM_REG_W_N2},
-	{11, "n3", 24, ASM_REG_R_N3, ASM_REG_W_N3},
-	{12, "n4", 24, ASM_REG_R_N4, ASM_REG_W_N4},
-	{13, "n5", 24, ASM_REG_R_N5, ASM_REG_W_N5},
-	{14, "n6", 24, ASM_REG_R_N6, ASM_REG_W_N6},
-	{15, "n7", 24, ASM_REG_R_N7, ASM_REG_W_N7},
-	{16, "m0", 24, ASM_REG_R_M0, ASM_REG_W_M0},
-	{17, "m1", 24, ASM_REG_R_M1, ASM_REG_W_M1},
-	{18, "m2", 24, ASM_REG_R_M2, ASM_REG_W_M2},
-	{19, "m3", 24, ASM_REG_R_M3, ASM_REG_W_M3},
-	{20, "m4", 24, ASM_REG_R_M4, ASM_REG_W_M4},
-	{21, "m5", 24, ASM_REG_R_M5, ASM_REG_W_M5},
-	{22, "m6", 24, ASM_REG_R_M6, ASM_REG_W_M6},
-	{23, "m7", 24, ASM_REG_R_M7, ASM_REG_W_M7},
-	{24, "x0", 24, ASM_REG_R_X0, ASM_REG_W_X0},
-	{25, "x1", 24, ASM_REG_R_X1, ASM_REG_W_X1},
-	{26, "y0", 24, ASM_REG_R_Y0, ASM_REG_W_Y0},
-	{27, "y1", 24, ASM_REG_R_Y1, ASM_REG_W_Y1},
-	{28, "a0", 24, ASM_REG_R_A0, ASM_REG_W_A0},
-	{29, "a1", 24, ASM_REG_R_A1, ASM_REG_W_A1},
-	{30, "a2", 8, ASM_REG_R_A2, ASM_REG_W_A2},
-	{31, "b0", 24, ASM_REG_R_B0, ASM_REG_W_B0},
-	{32, "b1", 24, ASM_REG_R_B1, ASM_REG_W_B1},
-	{33, "b2", 8, ASM_REG_R_B2, ASM_REG_W_B2},
-	{34, "omr", 24, ASM_REG_R_OMR, ASM_REG_W_OMR},
-	{35, "vba", 24, ASM_REG_R_VBA, ASM_REG_W_VBA},
-	{36, "ep", 24, ASM_REG_R_EP, ASM_REG_W_EP},
-	{37, "sc", 24, ASM_REG_R_SC, ASM_REG_W_SC},
-	{38, "sz", 24, ASM_REG_R_SZ, ASM_REG_W_SZ},
-	{39, "sr", 24, ASM_REG_R_SR, ASM_REG_W_SR},
-	{40, "sp", 24, ASM_REG_R_SP, ASM_REG_W_SP},
-	{41, "la", 24, ASM_REG_R_LA, ASM_REG_W_LA},
-	{42, "lc", 24, ASM_REG_R_LC, ASM_REG_W_LC},
-	{43, "pc", 24, ASM_REG_R_PC, ASM_REG_W_PC}
+	/* address registers */
+	{ 0, "r0", 24, 0x10, ASM_REG_W_R0},
+	{ 1, "r1", 24, 0x11, ASM_REG_W_R1},
+	{ 2, "r2", 24, 0x12, ASM_REG_W_R2},
+	{ 3, "r3", 24, 0x13, ASM_REG_W_R3},
+	{ 4, "r4", 24, 0x14, ASM_REG_W_R4},
+	{ 5, "r5", 24, 0x15, ASM_REG_W_R5},
+	{ 6, "r6", 24, 0x16, ASM_REG_W_R6},
+	{ 7, "r7", 24, 0x17, ASM_REG_W_R7},
+	/* offset registers */
+	{ 8, "n0", 24, 0x18, ASM_REG_W_N0},
+	{ 9, "n1", 24, 0x19, ASM_REG_W_N1},
+	{10, "n2", 24, 0x1a, ASM_REG_W_N2},
+	{11, "n3", 24, 0x1b, ASM_REG_W_N3},
+	{12, "n4", 24, 0x1c, ASM_REG_W_N4},
+	{13, "n5", 24, 0x1d, ASM_REG_W_N5},
+	{14, "n6", 24, 0x1e, ASM_REG_W_N6},
+	{15, "n7", 24, 0x1f, ASM_REG_W_N7},
+	/* modifier registers */
+	{16, "m0", 24, 0x20, ASM_REG_W_M0},
+	{17, "m1", 24, 0x21, ASM_REG_W_M1},
+	{18, "m2", 24, 0x22, ASM_REG_W_M2},
+	{19, "m3", 24, 0x23, ASM_REG_W_M3},
+	{20, "m4", 24, 0x24, ASM_REG_W_M4},
+	{21, "m5", 24, 0x25, ASM_REG_W_M5},
+	{22, "m6", 24, 0x26, ASM_REG_W_M6},
+	{23, "m7", 24, 0x27, ASM_REG_W_M7},
+	/* data alu input register */
+	{24, "x0", 24, 0x04, ASM_REG_W_X0},
+	{25, "x1", 24, 0x05, ASM_REG_W_X1},
+	{26, "y0", 24, 0x06, ASM_REG_W_Y0},
+	{27, "y1", 24, 0x07, ASM_REG_W_Y1},
+	/* data alu accumulator register */
+	{28, "a0", 24, 0x08, ASM_REG_W_A0},
+	{29, "a1", 24, 0x0c, ASM_REG_W_A1},
+	{30, "a2",  8, 0x0a, ASM_REG_W_A2},
+	{31, "b0", 24, 0x09, ASM_REG_W_B0},
+	{32, "b1", 24, 0x0d, ASM_REG_W_B1},
+	{33, "b2",  8, 0x0b, ASM_REG_W_B2},
+	/* stack */
+	{34, "ssh",24, 0x3c, ASM_REG_W_SSH},
+	{35, "ssl",24, 0x3d, ASM_REG_W_SSL},
+	{36, "sp", 24, 0x3b, ASM_REG_W_SP},
+	{37, "ep", 24, 0x2a, ASM_REG_W_EP},
+	{38, "sz", 24, 0x38, ASM_REG_W_SZ},
+	{39, "sc", 24, 0x31, ASM_REG_W_SC},
+	/* system */
+	{40, "pc", 24, 0x00, ASM_REG_W_PC},
+	{41, "sr", 24, 0x39, ASM_REG_W_SR},
+	{42, "omr",24, 0x3a, ASM_REG_W_OMR},
+	{43, "la", 24, 0x3e, ASM_REG_W_LA},
+	{44, "lc", 24, 0x3f, ASM_REG_W_LC},
+	/* interrupt */
+	{45, "vba", 24, 0x30, ASM_REG_W_VBA},
+	{46, "iprc",24, 0x00, ASM_REG_W_IPRC},
+	{47, "iprp",24, 0x00, ASM_REG_W_IPRP},
+	/* port a */
+	{48, "bcr", 24, 0x00, ASM_REG_W_BCR},
+	{49, "dcr", 24, 0x00, ASM_REG_W_DCR},
+	{50, "aar0",24, 0x00, ASM_REG_W_AAR0},
+	{51, "aar1",24, 0x00, ASM_REG_W_AAR1},
+	{52, "aar2",24, 0x00, ASM_REG_W_AAR2},
+	{53, "aar3",24, 0x00, ASM_REG_W_AAR3},
 	/* *INDENT-ON* */
 };
 
-static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_list[],
-			      int *reg_list_size)
+#define REG_NUM_R0	0
+#define REG_NUM_N0	8
+#define REG_NUM_N1	9
+#define REG_NUM_M0	16
+#define REG_NUM_M1	17
+#define REG_NUM_SSH	34
+#define REG_NUM_SSL	35
+#define REG_NUM_SP	36
+#define REG_NUM_EP	37
+#define REG_NUM_SC	39
+#define REG_NUM_PC	40
+#define REG_NUM_SR	41
+#define REG_NUM_IPRC	46
+#define REG_NUM_IPRP	47
+#define REG_NUM_BCR	48
+#define REG_NUM_DCR	49
+#define REG_NUM_AAR0	50
+#define REG_NUM_AAR1	51
+#define REG_NUM_AAR2	52
+#define REG_NUM_AAR3	53
+
+#define INSTR_JUMP	0x0AF080
+/* Effective Addressing Mode Encoding */
+#define EAME_R0		0x10
+/* instrcution encoder */
+/* movep
+ * s - peripheral space X/Y (X=0,Y=1)
+ * w - write/read
+ * d - source/destination register
+ * p - IO short address
+ */
+#define INSTR_MOVEP_REG_HIO(s,w,d,p)   (0x084000 | ((s & 1)<<16) | ((w&1)<<15) | ((d & 0x3f)<<8) | (p & 0x3f))
+
+static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int *reg_list_size)
 {
-	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 	int i;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -241,6 +246,9 @@ static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_lis
 	*reg_list_size = DSP563XX_NUMCOREREGS;
 	*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
 
+	if (!*reg_list)
+		return ERROR_INVALID_ARGUMENTS;
+
 	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
 	{
 		(*reg_list)[i] = &dsp563xx->core_cache->reg_list[i];
@@ -290,6 +298,9 @@ static int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
 {
 	struct dsp563xx_common *dsp563xx = calloc(1, sizeof(struct dsp563xx_common));
 
+	if (!dsp563xx)
+		return ERROR_INVALID_ARGUMENTS;
+
 	dsp563xx->jtag_info.tap = target->tap;
 	target->arch_info = dsp563xx;
 	dsp563xx->read_core_reg = dsp563xx_read_core_reg;
@@ -300,22 +311,18 @@ static int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
 
 static int dsp563xx_get_core_reg(struct reg *reg)
 {
-	int retval = 0;
-
-	LOG_DEBUG("%s", __FUNCTION__);
-
 	struct dsp563xx_core_reg *dsp563xx_reg = reg->arch_info;
 	struct target *target = dsp563xx_reg->target;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
+	LOG_DEBUG("%s", __FUNCTION__);
+
 	if (target->state != TARGET_HALTED)
 	{
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	retval = dsp563xx->read_core_reg(target, dsp563xx_reg->num);
-
-	return retval;
+	return dsp563xx->read_core_reg(target, dsp563xx_reg->num);
 }
 
 static int dsp563xx_set_core_reg(struct reg *reg, uint8_t * buf)
@@ -338,58 +345,366 @@ static int dsp563xx_set_core_reg(struct reg *reg, uint8_t * buf)
 	return ERROR_OK;
 }
 
-static int dsp563xx_save_context(struct target *target)
+static int dsp563xx_read_register(struct target *target, int num, int force);
+static int dsp563xx_write_register(struct target *target, int num, int force);
+
+static int dsp563xx_reg_read_high_io(struct target *target, uint32_t instr_mask, uint32_t * data)
 {
-	int i;
-	uint32_t data = 0;
+	int err;
+	uint32_t instr;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	/* we use r0 to store temporary data */
+	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
+		dsp563xx->read_core_reg(target, REG_NUM_R0);
+
+	/* move source memory to r0 */
+	instr = INSTR_MOVEP_REG_HIO(0, 0, EAME_R0, instr_mask);
+	if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, instr)) != ERROR_OK)
+		return err;
+	/* move r0 to debug register */
+	instr = INSTR_MOVEP_REG_HIO(0, 1, EAME_R0, 0xfffffc);
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, instr)) != ERROR_OK)
+		return err;
+	/* read debug register */
+	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, data)) != ERROR_OK)
+		return err;
+	/* r0 is no longer valid on target */
+	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+
+	return ERROR_OK;
+}
+
+static int dsp563xx_reg_write_high_io(struct target *target, uint32_t instr_mask, uint32_t data)
+{
+	int err;
+	uint32_t instr;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	/* we use r0 to store temporary data */
+	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
+		dsp563xx->read_core_reg(target, REG_NUM_R0);
+
+	/* move data to r0 */
+	if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, data)) != ERROR_OK)
+		return err;
+	/* move r0 to destination memory */
+	instr = INSTR_MOVEP_REG_HIO(0, 1, EAME_R0, instr_mask);
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, instr)) != ERROR_OK)
+		return err;
+
+	/* r0 is no longer valid on target */
+	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+
+	return ERROR_OK;
+}
+
+static int dsp563xx_reg_read(struct target *target, uint32_t eame, uint32_t * data)
+{
+	int err;
+	uint32_t instr;
+
+	instr = INSTR_MOVEP_REG_HIO(0, 1, eame, 0xfffffc);
+	if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, instr)) != ERROR_OK)
+		return err;
+	/* nop */
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0x000000)) != ERROR_OK)
+		return err;
+	/* read debug register */
+	return dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, data);
+}
+
+static int dsp563xx_reg_write(struct target *target, uint32_t instr_mask, uint32_t data)
+{
+	int err;
+
+	if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, instr_mask, data)) != ERROR_OK)
+		return err;
+	/* nop */
+	return dsp563xx_once_execute_sw_ir(target->tap, 0x000000);
+}
+
+static int dsp563xx_reg_pc_read(struct target *target)
+{
+	int err;
+	uint32_t opabdr, opabex;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	/* pc was changed, nothing todo */
+	if (dsp563xx->core_cache->reg_list[REG_NUM_PC].dirty)
+		return ERROR_OK;
+
+	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABDR, &opabdr)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX, &opabex)) != ERROR_OK)
+		return err;
+
+	/* conditional branch check */
+	if (opabdr == opabex)
+	{
+		/* TODO: check the trace buffer and if a
+		 * conditional branch is detected then decode
+		 * the branch command and add the relative
+		 * address to the current pc
+		 */
+		LOG_DEBUG("%s conditional branch not supported yet", __FUNCTION__);
+	}
+	else
+	{
+		dsp563xx->core_regs[REG_NUM_PC] = opabex;
+		dsp563xx->read_core_reg(target, REG_NUM_PC);
+	}
+
+	return ERROR_OK;
+}
+
+static int dsp563xx_reg_ssh_read(struct target *target)
+{
+	int err;
+	uint32_t sp, sc, ep;
+	struct dsp563xx_core_reg *arch_info;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SSH].arch_info;
+
+	/* get a valid stack pointer */
+	if ((err = dsp563xx_read_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+		return err;
+	sp = dsp563xx->core_regs[REG_NUM_SP];
+	if ((err = dsp563xx_write_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+		return err;
+
+	/* get a valid stack count */
+	if ((err = dsp563xx_read_register(target, REG_NUM_SC, 0)) != ERROR_OK)
+		return err;
+	sc = dsp563xx->core_regs[REG_NUM_SC];
+	if ((err = dsp563xx_write_register(target, REG_NUM_SC, 0)) != ERROR_OK)
+		return err;
+
+	/* get a valid extended pointer */
+	if ((err = dsp563xx_read_register(target, REG_NUM_EP, 0)) != ERROR_OK)
+		return err;
+	ep = dsp563xx->core_regs[REG_NUM_EP];
+	if ((err = dsp563xx_write_register(target, REG_NUM_EP, 0)) != ERROR_OK)
+		return err;
+
+	if (!sp)
+	{
+		sp = 0x00FFFFFF;
+	}
+	else
+	{
+		if ((err = dsp563xx_reg_read(target, arch_info->eame, &sp)) != ERROR_OK)
+			return err;
+
+		if ((err = dsp563xx_write_register(target, REG_NUM_SC, 1)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_write_register(target, REG_NUM_SP, 1)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_write_register(target, REG_NUM_EP, 1)) != ERROR_OK)
+			return err;
+	}
+
+	dsp563xx->core_regs[REG_NUM_SSH] = sp;
+	dsp563xx->read_core_reg(target, REG_NUM_SSH);
+
+	return ERROR_OK;
+}
+
+static int dsp563xx_reg_ssh_write(struct target *target)
+{
+	int err;
+	uint32_t sp;
 	struct dsp563xx_core_reg *arch_info;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
-	for (i = 0; i < DSP563XX_NUMCOREREGS - 1; i++)
+	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SSH].arch_info;
+
+	/* get a valid stack pointer */
+	if ((err = dsp563xx_read_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+		return err;
+	sp = dsp563xx->core_regs[REG_NUM_SP];
+
+	if (sp)
 	{
+		sp--;
+		/* write new stackpointer */
+		dsp563xx->core_regs[REG_NUM_SP] = sp;
+		if ((err = dsp563xx->read_core_reg(target, REG_NUM_SP)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_write_register(target, REG_NUM_SP, 1)) != ERROR_OK)
+			return err;
+
+		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, dsp563xx->core_regs[REG_NUM_SSH])) != ERROR_OK)
+			return err;
+
+		if ((err = dsp563xx_read_register(target, REG_NUM_SP, 1)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_read_register(target, REG_NUM_SSH, 1)) != ERROR_OK)
+			return err;
+	}
 
-//              if (!dsp563xx->core_cache->reg_list[i].valid)
-		{
-			arch_info = dsp563xx->core_cache->reg_list[i].arch_info;
-			dsp563xx_once_execute_dw_ir(target->tap, arch_info->r_cmd,
-						    0xfffffc);
-			dsp563xx_once_execute_sw_ir(target->tap, 0x000000);
-			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR,
-					       &data);
-			dsp563xx->core_regs[i] = data;
-			dsp563xx->read_core_reg(target, i);
-		}
+	return ERROR_OK;
+}
+
+static int dsp563xx_reg_ssl_read(struct target *target)
+{
+	int err;
+	uint32_t sp;
+	struct dsp563xx_core_reg *arch_info;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SSL].arch_info;
+
+	/* get a valid stack pointer */
+	if ((err = dsp563xx_read_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+		return err;
+	sp = dsp563xx->core_regs[REG_NUM_SP];
+
+	if (!sp)
+	{
+		sp = 0x00FFFFFF;
+	}
+	else
+	{
+		if ((err = dsp563xx_reg_read(target, arch_info->eame, &sp)) != ERROR_OK)
+			return err;
 	}
 
-	/* read pc */
-	dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX, &data);
-	dsp563xx->core_regs[i] = data;
-	dsp563xx->read_core_reg(target, i);
+	dsp563xx->core_regs[REG_NUM_SSL] = sp;
+	dsp563xx->read_core_reg(target, REG_NUM_SSL);
 
 	return ERROR_OK;
 }
 
-static int dsp563xx_restore_context(struct target *target)
+static int dsp563xx_read_register(struct target *target, int num, int force)
 {
-	int i;
+	int err = ERROR_OK;
+	uint32_t data = 0;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 	struct dsp563xx_core_reg *arch_info;
 
-	for (i = 0; i < DSP563XX_NUMCOREREGS - 1; i++)
+	if (force)
+		dsp563xx->core_cache->reg_list[num].valid = 0;
+
+	if (!dsp563xx->core_cache->reg_list[num].valid)
 	{
-		if (dsp563xx->core_cache->reg_list[i].dirty)
+		arch_info = dsp563xx->core_cache->reg_list[num].arch_info;
+
+		switch (arch_info->num)
 		{
-			arch_info = dsp563xx->core_cache->reg_list[i].arch_info;
+			case REG_NUM_SSH:
+				err = dsp563xx_reg_ssh_read(target);
+				break;
+			case REG_NUM_SSL:
+				err = dsp563xx_reg_ssl_read(target);
+				break;
+			case REG_NUM_PC:
+				err = dsp563xx_reg_pc_read(target);
+				break;
+			case REG_NUM_IPRC:
+			case REG_NUM_IPRP:
+			case REG_NUM_BCR:
+			case REG_NUM_DCR:
+			case REG_NUM_AAR0:
+			case REG_NUM_AAR1:
+			case REG_NUM_AAR2:
+			case REG_NUM_AAR3:
+				err = dsp563xx_reg_read_high_io(target, arch_info->instr_mask, &data);
+				if (err == ERROR_OK)
+				{
+					dsp563xx->core_regs[num] = data;
+					dsp563xx->read_core_reg(target, num);
+				}
+				break;
+			default:
+				err = dsp563xx_reg_read(target, arch_info->eame, &data);
+				if (err == ERROR_OK)
+				{
+					dsp563xx->core_regs[num] = data;
+					dsp563xx->read_core_reg(target, num);
+				}
+				break;
+		}
+
+	}
 
-			dsp563xx->write_core_reg(target, i);
+	return err;
+}
 
-			dsp563xx_once_execute_dw_ir(target->tap, arch_info->w_cmd,
-						    dsp563xx->core_regs[i]);
-			dsp563xx_once_execute_sw_ir(target->tap, 0x000000);
+static int dsp563xx_write_register(struct target *target, int num, int force)
+{
+	int err = ERROR_OK;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+	struct dsp563xx_core_reg *arch_info;
+
+	if (force)
+		dsp563xx->core_cache->reg_list[num].dirty = 1;
+
+	if (dsp563xx->core_cache->reg_list[num].dirty)
+	{
+		arch_info = dsp563xx->core_cache->reg_list[num].arch_info;
+
+		dsp563xx->write_core_reg(target, num);
+
+		switch (arch_info->num)
+		{
+			case REG_NUM_SSH:
+				err = dsp563xx_reg_ssh_write(target);
+				break;
+			case REG_NUM_PC:
+				/* pc is updated on resume, no need to write it here */
+				break;
+			case REG_NUM_IPRC:
+			case REG_NUM_IPRP:
+			case REG_NUM_BCR:
+			case REG_NUM_DCR:
+			case REG_NUM_AAR0:
+			case REG_NUM_AAR1:
+			case REG_NUM_AAR2:
+			case REG_NUM_AAR3:
+				err = dsp563xx_reg_write_high_io(target, arch_info->instr_mask, dsp563xx->core_regs[num]);
+				break;
+			default:
+				err = dsp563xx_reg_write(target, arch_info->instr_mask, dsp563xx->core_regs[num]);
+
+				if ((err == ERROR_OK) && (arch_info->num == REG_NUM_SP))
+				{
+					dsp563xx->core_cache->reg_list[REG_NUM_SSH].valid = 0;
+					dsp563xx->core_cache->reg_list[REG_NUM_SSL].valid = 0;
+				}
+
+				break;
 		}
 	}
 
-	return ERROR_OK;
+	return err;
+}
+
+static int dsp563xx_save_context(struct target *target)
+{
+	int i, err = ERROR_OK;
+
+	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
+	{
+		if ((err = dsp563xx_read_register(target, i, 0)) != ERROR_OK)
+			break;
+	}
+
+	return err;
+}
+
+static int dsp563xx_restore_context(struct target *target)
+{
+	int i, err = ERROR_OK;
+
+	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
+	{
+		if ((err = dsp563xx_write_register(target, i, 0)) != ERROR_OK)
+			break;
+	}
+
+	return err;
 }
 
 static const struct reg_arch_type dsp563xx_reg_type = {
@@ -405,8 +720,7 @@ static int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *
 	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
 	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
 	struct reg *reg_list = malloc(sizeof(struct reg) * DSP563XX_NUMCOREREGS);
-	struct dsp563xx_core_reg *arch_info =
-		malloc(sizeof(struct dsp563xx_core_reg) * DSP563XX_NUMCOREREGS);
+	struct dsp563xx_core_reg *arch_info = malloc(sizeof(struct dsp563xx_core_reg) * DSP563XX_NUMCOREREGS);
 	int i;
 
 	LOG_DEBUG("%s", __FUNCTION__);
@@ -424,8 +738,8 @@ static int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *
 		arch_info[i].num = dsp563xx_regs[i].id;
 		arch_info[i].name = dsp563xx_regs[i].name;
 		arch_info[i].size = dsp563xx_regs[i].bits;
-		arch_info[i].r_cmd = dsp563xx_regs[i].r_cmd;
-		arch_info[i].w_cmd = dsp563xx_regs[i].w_cmd;
+		arch_info[i].eame = dsp563xx_regs[i].eame;
+		arch_info[i].instr_mask = dsp563xx_regs[i].instr_mask;
 		arch_info[i].target = target;
 		arch_info[i].dsp563xx_common = dsp563xx;
 		reg_list[i].name = dsp563xx_regs[i].name;
@@ -446,73 +760,121 @@ static int dsp563xx_arch_state(struct target *target)
 	return ERROR_OK;
 }
 
-static int dsp563xx_jtag_status(struct target *target, uint8_t * status)
+#define DSP563XX_SR_SA	(1<<17)
+#define DSP563XX_SR_SC	(1<<13)
+
+static int dsp563xx_debug_once_init(struct target *target)
 {
-	uint8_t ir_in;
+	return dsp563xx_once_read_register(target->tap, once_regs, DSP563XX_NUMONCEREGS);
+}
 
-	ir_in = 0;
+static int dsp563xx_debug_init(struct target *target)
+{
+	int err;
+	uint32_t sr;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+	struct dsp563xx_core_reg *arch_info;
 
-	dsp563xx_jtag_sendinstr(target->tap, &ir_in, JTAG_INSTR_ENABLE_ONCE);
-	dsp563xx_execute_queue();
+	if ((err = dsp563xx_debug_once_init(target)) != ERROR_OK)
+		return err;
 
-	*status = ir_in;
+	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SR].arch_info;
 
-	return ERROR_OK;
-}
+	/* check 24bit mode */
+	if ((err = dsp563xx_read_register(target, REG_NUM_SR, 0)) != ERROR_OK)
+		return err;
 
-static int dsp563xx_jtag_debug_request(struct target *target)
-{
-	uint8_t ir_in = 0;
-	uint32_t retry = 0;
+	sr = dsp563xx->core_regs[REG_NUM_SR];
 
-	while (ir_in != JTAG_STATUS_DEBUG)
+	if (sr & (DSP563XX_SR_SA | DSP563XX_SR_SC))
 	{
-		dsp563xx_jtag_sendinstr(target->tap, &ir_in,
-					JTAG_INSTR_DEBUG_REQUEST);
-		dsp563xx_execute_queue();
-		LOG_DEBUG("JTAG CMD 7 res: %02X", ir_in);
-		dsp563xx_jtag_sendinstr(target->tap, &ir_in, JTAG_INSTR_ENABLE_ONCE);
-		dsp563xx_execute_queue();
-		LOG_DEBUG("JTAG CMD 6 res: %02X", ir_in);
+		sr &= ~(DSP563XX_SR_SA | DSP563XX_SR_SC);
 
-		if (retry++ == 100)
-			return ERROR_TARGET_FAILURE;
+		if ((err = dsp563xx_once_execute_dw_ir(target->tap, arch_info->instr_mask, sr)) != ERROR_OK)
+			return err;
+		dsp563xx->core_cache->reg_list[REG_NUM_SR].dirty = 1;
 	}
 
-	if (ir_in != JTAG_STATUS_DEBUG)
+	if ((err = dsp563xx_read_register(target, REG_NUM_N0, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_read_register(target, REG_NUM_N1, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_read_register(target, REG_NUM_M0, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_read_register(target, REG_NUM_M1, 0)) != ERROR_OK)
+		return err;
+
+	if (dsp563xx->core_regs[REG_NUM_N0] != 0x000000)
 	{
-		return ERROR_TARGET_FAILURE;
+		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_N0].arch_info;
+		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0x000000)) != ERROR_OK)
+			return err;
+	}
+	dsp563xx->core_cache->reg_list[REG_NUM_N0].dirty = 1;
+
+	if (dsp563xx->core_regs[REG_NUM_N1] != 0x000000)
+	{
+		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_N1].arch_info;
+		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0x000000)) != ERROR_OK)
+			return err;
+	}
+	dsp563xx->core_cache->reg_list[REG_NUM_N1].dirty = 1;
+
+	if (dsp563xx->core_regs[REG_NUM_M0] != 0xffffff)
+	{
+		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_M0].arch_info;
+		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0xffffff)) != ERROR_OK)
+			return err;
 	}
+	dsp563xx->core_cache->reg_list[REG_NUM_M0].dirty = 1;
+
+	if (dsp563xx->core_regs[REG_NUM_M1] != 0xffffff)
+	{
+		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_M1].arch_info;
+		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0xffffff)) != ERROR_OK)
+			return err;
+	}
+	dsp563xx->core_cache->reg_list[REG_NUM_M1].dirty = 1;
+
+	if ((err = dsp563xx_save_context(target)) != ERROR_OK)
+		return err;
 
 	return ERROR_OK;
 }
 
+static int dsp563xx_jtag_debug_request(struct target *target)
+{
+	return dsp563xx_once_request_debug(target->tap, target->state == TARGET_RESET);
+}
+
 static int dsp563xx_poll(struct target *target)
 {
-	uint8_t jtag_status;
+	int err;
 	uint32_t once_status;
+	int state;
 
-	dsp563xx_jtag_status(target, &jtag_status);
+	state = dsp563xx_once_target_status(target->tap);
 
-	if ((jtag_status & 1) != 1)
+	if (state == TARGET_UNKNOWN)
 	{
-		target->state = TARGET_UNKNOWN;
-		LOG_ERROR
-			("jtag status contains invalid mode value - communication failure");
+		target->state = state;
+		LOG_ERROR("jtag status contains invalid mode value - communication failure");
 		return ERROR_TARGET_FAILURE;
 	}
 
-	if (jtag_status != JTAG_STATUS_DEBUG)
-	{
-		target->state = TARGET_RUNNING;
-	}
-
-	dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR, &once_status);
+	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR, &once_status)) != ERROR_OK)
+		return err;
 
 	if ((once_status & DSP563XX_ONCE_OSCR_DEBUG_M) == DSP563XX_ONCE_OSCR_DEBUG_M)
 	{
-		target->state = TARGET_HALTED;
+		if (target->state != TARGET_HALTED)
+		{
+			target->state = TARGET_HALTED;
+			if ((err = dsp563xx_debug_init(target)) != ERROR_OK)
+				return err;
 
+			LOG_DEBUG("target->state: %s", target_state_name(target));
+		}
 	}
 
 	return ERROR_OK;
@@ -520,8 +882,7 @@ static int dsp563xx_poll(struct target *target)
 
 static int dsp563xx_halt(struct target *target)
 {
-	uint8_t jtag_status;
-	uint32_t once_status;
+	int err;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	if (target->state == TARGET_HALTED)
@@ -535,61 +896,48 @@ static int dsp563xx_halt(struct target *target)
 		LOG_WARNING("target was in unknown state when halt was requested");
 	}
 
-//      if ( jtag_status != 0x0d )
-	{
-		dsp563xx_jtag_debug_request(target);
-
-		/* store pipeline register */
-		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR,
-				       &dsp563xx->pipeline_context.once_opilr);
-		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR,
-				       &dsp563xx->pipeline_context.once_opdbr);
-
-		dsp563xx_save_context(target);
+	if ((err = dsp563xx_jtag_debug_request(target)) != ERROR_OK)
+		return err;
 
-		dsp563xx_jtag_status(target, &jtag_status);
-		LOG_DEBUG("%02X", jtag_status);
-		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR,
-				       &once_status);
-		LOG_DEBUG("%02X", (unsigned) once_status);
-	}
-
-	LOG_DEBUG("target->state: %s", target_state_name(target));
+	/* store pipeline register */
+	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+		return err;
 
 	LOG_DEBUG("%s", __FUNCTION__);
 
 	return ERROR_OK;
 }
 
-#define DSP563XX_ASM_CMD_JUMP	0x0AF080
-
-static int dsp563xx_resume(struct target *target, int current, uint32_t address,
-		    int handle_breakpoints, int debug_execution)
+static int dsp563xx_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
+	int err;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	LOG_DEBUG("%s", __FUNCTION__);
 
-	dsp563xx_restore_context(target);
+	if ((err = dsp563xx_restore_context(target)) != ERROR_OK)
+		return err;
+	register_cache_invalidate(dsp563xx->core_cache);
 
 	if (current)
 	{
 		/* restore pipeline registers and go */
-		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR,
-					dsp563xx->pipeline_context.once_opilr);
-		dsp563xx_once_reg_write(target->tap,
-					DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX |
-					DSP563XX_ONCE_OCR_GO,
-					dsp563xx->pipeline_context.once_opdbr);
+		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+			return err;
+		if ((err =
+		     dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
+					     dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+			return err;
 	}
 	else
 	{
 		/* set to go register and jump */
-		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR,
-					DSP563XX_ASM_CMD_JUMP);
-		dsp563xx_once_reg_write(target->tap,
-					DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX
-					| DSP563XX_ONCE_OCR_GO, address);
+		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR, INSTR_JUMP)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO, address)) != ERROR_OK)
+			return err;
 	}
 
 	target->state = TARGET_RUNNING;
@@ -597,9 +945,9 @@ static int dsp563xx_resume(struct target *target, int current, uint32_t address,
 	return ERROR_OK;
 }
 
-static int dsp563xx_step(struct target *target, int current, uint32_t address,
-		  int handle_breakpoints)
+static int dsp563xx_step_ex(struct target *target, int current, uint32_t address, int handle_breakpoints, int steps)
 {
+	int err;
 	uint32_t once_status;
 	uint32_t dr_in, cnt;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
@@ -612,75 +960,77 @@ static int dsp563xx_step(struct target *target, int current, uint32_t address,
 
 	LOG_DEBUG("%s %08X %08X", __FUNCTION__, current, (unsigned) address);
 
-	dsp563xx_jtag_debug_request(target);
-
-	dsp563xx_restore_context(target);
+	if ((err = dsp563xx_jtag_debug_request(target)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_restore_context(target)) != ERROR_OK)
+		return err;
 
 	/* reset trace mode */
-	dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, 0x000000);
+	if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, 0x000000)) != ERROR_OK)
+		return err;
 	/* enable trace mode */
-	dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR,
-				DSP563XX_ONCE_OSCR_TME);
+	if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, DSP563XX_ONCE_OSCR_TME)) != ERROR_OK)
+		return err;
 
-	cnt = 0;
+	cnt = steps;
 
 	/* on JUMP we need one extra cycle */
 	if (!current)
 		cnt++;
 
 	/* load step counter with N-1 */
-	dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OTC, cnt);
+	if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OTC, cnt)) != ERROR_OK)
+		return err;
 
 	if (current)
 	{
 		/* restore pipeline registers and go */
-		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR,
-					dsp563xx->pipeline_context.once_opilr);
-		dsp563xx_once_reg_write(target->tap,
-					DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX |
-					DSP563XX_ONCE_OCR_GO,
-					dsp563xx->pipeline_context.once_opdbr);
+		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+			return err;
+		if ((err =
+		     dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
+					     dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+			return err;
 	}
 	else
 	{
 		/* set to go register and jump */
-		dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR,
-					DSP563XX_ASM_CMD_JUMP);
-		dsp563xx_once_reg_write(target->tap,
-					DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX
-					| DSP563XX_ONCE_OCR_GO, address);
+		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR, INSTR_JUMP)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO, address)) != ERROR_OK)
+			return err;
 	}
 
 	while (1)
 	{
-		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR,
-				       &once_status);
+		if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR, &once_status)) != ERROR_OK)
+			return err;
 
 		if (once_status & DSP563XX_ONCE_OSCR_TO)
 		{
 			/* store pipeline register */
-			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR,
-					       &dsp563xx->pipeline_context.
-					       once_opilr);
-			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR,
-					       &dsp563xx->pipeline_context.
-					       once_opdbr);
-
-			dsp563xx_save_context(target);
-
-			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABFR,
-					       &dr_in);
-			LOG_DEBUG("%08X", (unsigned) dr_in);
-			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABDR,
-					       &dr_in);
-			LOG_DEBUG("%08X", (unsigned) dr_in);
-			dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX,
-					       &dr_in);
-			LOG_DEBUG("%08X", (unsigned) dr_in);
+			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+				return err;
+			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+				return err;
+
+			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABFR, &dr_in)) != ERROR_OK)
+				return err;
+			LOG_DEBUG("fetch: %08X", (unsigned) dr_in);
+			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABDR, &dr_in)) != ERROR_OK)
+				return err;
+			LOG_DEBUG("decode: %08X", (unsigned) dr_in);
+			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX, &dr_in)) != ERROR_OK)
+				return err;
+			LOG_DEBUG("execute: %08X", (unsigned) dr_in);
 
 			/* reset trace mode */
-			dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR,
-						0x000000);
+			if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, 0x000000)) != ERROR_OK)
+				return err;
+
+			register_cache_invalidate(dsp563xx->core_cache);
+			if ((err = dsp563xx_debug_init(target)) != ERROR_OK)
+				return err;
 
 			break;
 		}
@@ -689,9 +1039,41 @@ static int dsp563xx_step(struct target *target, int current, uint32_t address,
 	return ERROR_OK;
 }
 
+static int dsp563xx_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
+{
+	return dsp563xx_step_ex(target, current, address, handle_breakpoints, 0);
+}
+
 static int dsp563xx_assert_reset(struct target *target)
 {
+	int retval = 0;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+	enum reset_types jtag_reset_config = jtag_get_reset_config();
+
+	if (jtag_reset_config & RESET_HAS_SRST)
+	{
+		/* default to asserting srst */
+		if (jtag_reset_config & RESET_SRST_PULLS_TRST)
+		{
+			jtag_add_reset(1, 1);
+		}
+		else
+		{
+			jtag_add_reset(0, 1);
+		}
+	}
+
 	target->state = TARGET_RESET;
+	jtag_add_sleep(5000);
+
+	/* registers are now invalid */
+	register_cache_invalidate(dsp563xx->core_cache);
+
+	if (target->reset_halt)
+	{
+		if ((retval = target_halt(target)) != ERROR_OK)
+			return retval;
+	}
 
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
@@ -699,7 +1081,28 @@ static int dsp563xx_assert_reset(struct target *target)
 
 static int dsp563xx_deassert_reset(struct target *target)
 {
-	target->state = TARGET_RUNNING;
+	int err;
+
+	/* deassert reset lines */
+	jtag_add_reset(0, 0);
+
+	if ((err = dsp563xx_poll(target)) != ERROR_OK)
+		return err;
+
+	if (target->reset_halt)
+	{
+		if (target->state == TARGET_HALTED)
+		{
+			/* after a reset the cpu jmp to the
+			 * reset vector and need 2 cycles to fill
+			 * the cache (fetch,decode,excecute)
+			 */
+			if ((err = dsp563xx_step_ex(target, 1, 0, 1, 1)) != ERROR_OK)
+				return err;
+		}
+	}
+
+//      target->state = TARGET_RUNNING;
 
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
@@ -728,20 +1131,19 @@ static int dsp563xx_soft_reset_halt(struct target *target)
 * 0446BD		move              ssl,y0
 * 0446BE		move              la,y0
 * 0446BF		move              lc,y0
-* 
+*
 * 61F000 AABBCC		move              x:AABBCC,r1
 * 076190		movem             r0,p:(r1)
 *
 */
-static int dsp563xx_read_memory_p(struct target *target, uint32_t address,
-			   uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
 {
+	int err;
 	uint32_t i, x;
 	uint32_t data;
 	uint8_t *b;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8"
-		  PRIx32, address, size, count);
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32, address, size, count);
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -753,12 +1155,17 @@ static int dsp563xx_read_memory_p(struct target *target, uint32_t address,
 
 	for (i = 0; i < x; i++)
 	{
-		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, address + i);
-		dsp563xx_once_execute_sw_ir_nq(target->tap, 0x07E086);
-		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x467000, 0xfffffc);
-		dsp563xx_execute_queue();
-
-		dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, &data);
+		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, address + i)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, 0x07E086)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x467000, 0xfffffc)) != ERROR_OK)
+			return err;
+		if ((err = jtag_execute_queue()) != ERROR_OK)
+			return err;
+
+		if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, &data)) != ERROR_OK)
+			return err;
 
 		b = buffer + 4 * i;
 		if (size > 0)
@@ -774,15 +1181,14 @@ static int dsp563xx_read_memory_p(struct target *target, uint32_t address,
 	return ERROR_OK;
 }
 
-static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size,
-			    uint32_t count, uint8_t * buffer)
+static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
 {
+	int err;
 	uint32_t i, x;
 	uint32_t data;
 	uint8_t *b;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8"
-		  PRIx32 "", address, size, count);
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, size, count);
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -808,105 +1214,19 @@ static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint
 
 //              LOG_DEBUG("%08X", data);
 
-		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x61F400, address + i);
-		dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, data);
-		dsp563xx_once_execute_sw_ir_nq(target->tap, 0x076190);
-		dsp563xx_execute_queue();
+		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x61F400, address + i)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, data)) != ERROR_OK)
+			return err;
+		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, 0x076190)) != ERROR_OK)
+			return err;
+		if ((err = jtag_execute_queue()) != ERROR_OK)
+			return err;
 	}
 
 	return ERROR_OK;
 }
 
-static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
-{
-	return dsp563xx_write_ir_u8(tap, ir_in, ir_out, DSP563XX_JTAG_INS_LEN, 1);
-}
-
-/* IR and DR functions */
-static int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
-		      int ir_len, int rti)
-{
-	if (NULL == tap)
-	{
-		LOG_ERROR("invalid tap");
-		return ERROR_FAIL;
-	}
-	if (ir_len != tap->ir_length)
-	{
-		LOG_ERROR("invalid ir_len");
-		return ERROR_FAIL;
-	}
-
-	{
-		jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in, TAP_IDLE);
-	}
-
-	return ERROR_OK;
-}
-
-static int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
-		      int dr_len, int rti)
-{
-	if (NULL == tap)
-	{
-		LOG_ERROR("invalid tap");
-		return ERROR_FAIL;
-	}
-
-	{
-		jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, TAP_IDLE);
-	}
-
-	return ERROR_OK;
-}
-
-static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
-			 int ir_len, int rti)
-{
-	if (ir_len > 8)
-	{
-		LOG_ERROR("ir_len overflow, maxium is 8");
-		return ERROR_FAIL;
-	}
-
-	dsp563xx_write_ir(tap, ir_in, &ir_out, ir_len, rti);
-
-	return ERROR_OK;
-}
-
-int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t dr_out,
-			 int dr_len, int rti)
-{
-	if (dr_len > 8)
-	{
-		LOG_ERROR("dr_len overflow, maxium is 8");
-		return ERROR_FAIL;
-	}
-
-	dsp563xx_write_dr(tap, dr_in, &dr_out, dr_len, rti);
-
-	return ERROR_OK;
-}
-
-int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
-			  int dr_len, int rti)
-{
-	if (dr_len > 32)
-	{
-		LOG_ERROR("dr_len overflow, maxium is 32");
-		return ERROR_FAIL;
-	}
-
-	dsp563xx_write_dr(tap, (uint8_t *) dr_in, (uint8_t *) & dr_out, dr_len, rti);
-
-	return ERROR_OK;
-}
-
-int dsp563xx_execute_queue(void)
-{
-	return jtag_execute_queue();
-}
-
 /** Holds methods for DSP563XX targets. */
 struct target_type dsp563xx_target = {
 	.name = "dsp563xx",
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
index 475e516..c553471 100644
--- a/src/target/dsp563xx.h
+++ b/src/target/dsp563xx.h
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2009 by Mathias Kuester                                 *
+ *   Copyright (C) 2009-2011 by Mathias Kuester                            *
  *   mkdorg at users.sourceforge.net                                          *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -21,8 +21,10 @@
 #define DSP563XX_H
 
 #include <jtag/jtag.h>
+#include <target/dsp563xx_once.h>
 
-#define DSP563XX_NUMCOREREGS	44
+#define DSP563XX_NUMCOREREGS	54
+#define DSP563XX_NUMONCEREGS	25
 
 struct mcu_jtag
 {
@@ -42,6 +44,7 @@ struct dsp563xx_common
 	struct mcu_jtag jtag_info;
 	struct reg_cache *core_cache;
 	uint32_t core_regs[DSP563XX_NUMCOREREGS];
+	struct once_reg once_regs[DSP563XX_NUMONCEREGS];
 
 	struct dsp563xx_pipeline_context pipeline_context;
 
@@ -55,8 +58,8 @@ struct dsp563xx_core_reg
 	uint32_t num;
 	const char *name;
 	uint32_t size;
-	uint32_t r_cmd;
-	uint32_t w_cmd;
+	uint8_t eame;
+	uint32_t instr_mask;
 	struct target *target;
 	struct dsp563xx_common *dsp563xx_common;
 };
@@ -66,11 +69,4 @@ static inline struct dsp563xx_common *target_to_dsp563xx(struct target *target)
 	return target->arch_info;
 }
 
-int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
-			 int dr_len, int rti);
-int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * ir_in, uint32_t ir_out,
-			  int dr_len, int rti);
-
-int dsp563xx_execute_queue(void);
-
 #endif /* DSP563XX_H */
diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
index edca7f4..b7443fa 100644
--- a/src/target/dsp563xx_once.c
+++ b/src/target/dsp563xx_once.c
@@ -29,74 +29,295 @@
 #include "dsp563xx.h"
 #include "dsp563xx_once.h"
 
-/** single word instruction */
-static int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw,
-			  uint8_t go, uint8_t ex)
+#define JTAG_STATUS_NORMAL		0x01
+#define JTAG_STATUS_STOPWAIT		0x05
+#define JTAG_STATUS_BUSY		0x09
+#define JTAG_STATUS_DEBUG		0x0d
+
+#define JTAG_INSTR_EXTEST		0x00
+#define JTAG_INSTR_SAMPLE_PRELOAD	0x01
+#define JTAG_INSTR_IDCODE		0x02
+#define JTAG_INSTR_CLAMP		0x03
+#define JTAG_INSTR_HIZ			0x04
+#define JTAG_INSTR_ENABLE_ONCE		0x06
+#define JTAG_INSTR_DEBUG_REQUEST	0x07
+#define JTAG_INSTR_BYPASS		0x0F
+
+static int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out, int dr_len, int rti)
 {
-	dsp563xx_write_dr_u8(tap, 0,
-			     instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0);
-	dsp563xx_execute_queue();
+	if (NULL == tap)
+	{
+		LOG_ERROR("invalid tap");
+		return ERROR_FAIL;
+	}
+
+	jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, TAP_IDLE);
 
 	return ERROR_OK;
 }
 
+static int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t dr_out, int dr_len, int rti)
+{
+	if (dr_len > 8)
+	{
+		LOG_ERROR("dr_len overflow, maxium is 8");
+		return ERROR_FAIL;
+	}
+
+	return dsp563xx_write_dr(tap, dr_in, &dr_out, dr_len, rti);
+}
+
+static int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out, int dr_len, int rti)
+{
+	if (dr_len > 32)
+	{
+		LOG_ERROR("dr_len overflow, maxium is 32");
+		return ERROR_FAIL;
+	}
+
+	return dsp563xx_write_dr(tap, (uint8_t *) dr_in, (uint8_t *) & dr_out, dr_len, rti);
+}
+
 /** single word instruction */
-static int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap, uint8_t instr, uint8_t rw,
-			     uint8_t go, uint8_t ex)
+static int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
 {
-	dsp563xx_write_dr_u8(tap, 0,
-			     instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0);
+	int err;
+
+	if ((err = dsp563xx_write_dr_u8(tap, 0, instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0)) != ERROR_OK)
+		return err;
+
+	return jtag_execute_queue();
+}
+
+/** single word instruction */
+static int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
+{
+	return dsp563xx_write_dr_u8(tap, 0, instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0);
+}
+
+/* IR and DR functions */
+static int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out, int ir_len, int rti)
+{
+	if (NULL == tap)
+	{
+		LOG_ERROR("invalid tap");
+		return ERROR_FAIL;
+	}
+	if (ir_len != tap->ir_length)
+	{
+		LOG_ERROR("invalid ir_len");
+		return ERROR_FAIL;
+	}
+
+	jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in, TAP_IDLE);
 
 	return ERROR_OK;
 }
 
-/** once read register */
-int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data)
+static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out, int ir_len, int rti)
 {
-	uint32_t dr_in;
+	if (ir_len > 8)
+	{
+		LOG_ERROR("ir_len overflow, maxium is 8");
+		return ERROR_FAIL;
+	}
 
-	dr_in = 0;
+	return dsp563xx_write_ir(tap, ir_in, &ir_out, ir_len, rti);
+}
 
-	dsp563xx_once_ir_exec(tap, reg, 1, 0, 0);
-	dsp563xx_write_dr_u32(tap, &dr_in, 0x00, 24, 0);
-	dsp563xx_execute_queue();
+static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
+{
+	return dsp563xx_write_ir_u8(tap, ir_in, ir_out, tap->ir_length, 1);
+}
 
-	*data = dr_in;
+/** */
+int dsp563xx_once_target_status(struct jtag_tap *tap)
+{
+	int err;
+	uint8_t jtag_status;
+
+	if ((err = dsp563xx_jtag_sendinstr(tap, &jtag_status, JTAG_INSTR_ENABLE_ONCE)) != ERROR_OK)
+		return err;
+	if ((err = jtag_execute_queue()) != ERROR_OK)
+		return err;
+
+	if ((jtag_status & 1) != 1)
+	{
+		return TARGET_UNKNOWN;
+	}
+
+	if (jtag_status != JTAG_STATUS_DEBUG)
+	{
+		return TARGET_RUNNING;
+	}
+
+	return TARGET_HALTED;
+}
+
+/** */
+int dsp563xx_once_request_debug(struct jtag_tap *tap, int reset_state)
+{
+	int err;
+	uint8_t ir_in = 0, pattern = 0;
+	uint32_t retry = 0;
+
+	/* in reset state we only get a ACK
+	 * from the interface */
+	if (reset_state)
+	{
+		pattern = 1;
+	}
+	else
+	{
+		pattern = JTAG_STATUS_DEBUG;
+	}
+
+	/* wait until we get the ack */
+	while (ir_in != pattern)
+	{
+		if ((err = dsp563xx_jtag_sendinstr(tap, &ir_in, JTAG_INSTR_DEBUG_REQUEST)) != ERROR_OK)
+			return err;
+		if ((err = jtag_execute_queue()) != ERROR_OK)
+			return err;
+
+		LOG_DEBUG("debug request: %02X", ir_in);
+
+		if (retry++ == 100)
+		{
+			return ERROR_TARGET_FAILURE;
+		}
+	}
+
+	/* we cant enable the once in reset state */
+	if (pattern == 1)
+	{
+		return ERROR_OK;
+	}
+
+	/* try to enable once */
+	retry = 0;
+	ir_in = 0;
+	while (ir_in != pattern)
+	{
+		if ((err = dsp563xx_jtag_sendinstr(tap, &ir_in, JTAG_INSTR_ENABLE_ONCE)) != ERROR_OK)
+			return err;
+		if ((err = jtag_execute_queue()) != ERROR_OK)
+			return err;
+
+		LOG_DEBUG("enable once: %02X", ir_in);
+
+		if (retry++ == 100)
+		{
+			LOG_DEBUG("error");
+			return ERROR_TARGET_FAILURE;
+		}
+	}
+
+	if (ir_in != JTAG_STATUS_DEBUG)
+	{
+		return ERROR_TARGET_FAILURE;
+	}
 
 	return ERROR_OK;
 }
 
+/** once read registers */
+int dsp563xx_once_read_register(struct jtag_tap *tap, struct once_reg *regs, int len)
+{
+	int i;
+	int err;
+
+	for (i = 0; i < len; i++)
+	{
+		if ((err = dsp563xx_once_reg_read_ex_nq(tap, regs[i].addr, regs[i].len, &regs[i].reg)) != ERROR_OK)
+			return err;
+	}
+
+	return jtag_execute_queue();
+/*
+	for(i=0;i<len;i++)
+	{
+		printf("%08X\n",regs[i].reg);
+	}
+*/
+}
+
+/** once read register */
+int dsp563xx_once_reg_read_ex_nq(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data)
+{
+	int err;
+
+	if ((err = dsp563xx_once_ir_exec(tap, reg, 1, 0, 0)) != ERROR_OK)
+		return err;
+	return dsp563xx_write_dr_u32(tap, data, 0x00, len, 0);
+}
+
+/** once read register */
+int dsp563xx_once_reg_read_ex(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data)
+{
+	int err;
+
+	if ((err = dsp563xx_once_ir_exec(tap, reg, 1, 0, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, data, 0x00, len, 0)) != ERROR_OK)
+		return err;
+	return jtag_execute_queue();
+}
+
+/** once read register */
+int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data)
+{
+	int err;
+
+	if ((err = dsp563xx_once_ir_exec(tap, reg, 1, 0, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, data, 0x00, 24, 0)) != ERROR_OK)
+		return err;
+	return jtag_execute_queue();
+}
+
 /** once write register */
 int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data)
 {
-	dsp563xx_once_ir_exec(tap, reg, 0, 0, 0);
-	dsp563xx_write_dr_u32(tap, 0x00, data, 24, 0);
-	dsp563xx_execute_queue();
+	int err;
 
-	return ERROR_OK;
+	if ((err = dsp563xx_once_ir_exec(tap, reg, 0, 0, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, 0x00, data, 24, 0)) != ERROR_OK)
+		return err;
+	return jtag_execute_queue();
 }
 
 /** single word instruction */
 int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, uint32_t opcode)
 {
-	dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
-	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
-	dsp563xx_execute_queue();
+	int err;
 
-	return ERROR_OK;
+	if ((err = dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
+		return err;
+	return jtag_execute_queue();
 }
 
 /** double word instruction */
-int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode,
-				uint32_t operand)
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode, uint32_t operand)
 {
-	dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0);
-	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
-	dsp563xx_execute_queue();
+	int err;
 
-	dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
-	dsp563xx_write_dr_u32(tap, 0, operand, 24, 0);
-	dsp563xx_execute_queue();
+	if ((err = dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
+		return err;
+	if ((err = jtag_execute_queue()) != ERROR_OK)
+		return err;
+
+	if ((err = dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, 0, operand, 24, 0)) != ERROR_OK)
+		return err;
+	if ((err = jtag_execute_queue()) != ERROR_OK)
+		return err;
 
 	return ERROR_OK;
 }
@@ -104,21 +325,29 @@ int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode,
 /** single word instruction */
 int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap, uint32_t opcode)
 {
-	dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
-	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
+	int err;
+
+	if ((err = dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
+		return err;
 
 	return ERROR_OK;
 }
 
 /** double word instruction */
-int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode,
-				   uint32_t operand)
+int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode, uint32_t operand)
 {
-	dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0);
-	dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0);
+	int err;
 
-	dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0);
-	dsp563xx_write_dr_u32(tap, 0, operand, 24, 0);
+	if ((err = dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
+		return err;
+	if ((err = dsp563xx_write_dr_u32(tap, 0, operand, 24, 0)) != ERROR_OK)
+		return err;
 
 	return ERROR_OK;
 }
diff --git a/src/target/dsp563xx_once.h b/src/target/dsp563xx_once.h
index 942cd65..6b27694 100644
--- a/src/target/dsp563xx_once.h
+++ b/src/target/dsp563xx_once.h
@@ -54,9 +54,29 @@
 #define DSP563XX_ONCE_OPABFR	0x00F	/* pab fetch reg */
 #define DSP563XX_ONCE_OPABDR	0x010	/* pab decode reg */
 #define DSP563XX_ONCE_OPABEX	0x011	/* pab exec reg */
-#define DSP563XX_ONCE_OPABEX	0x011	/* trace buffer/inc ptr */
+#define DSP563XX_ONCE_OPABF11	0x012	/* trace buffer/inc ptr */
 #define DSP563XX_ONCE_NOREG	0x01F	/* no register selected */
 
+struct once_reg
+{
+	uint8_t num;
+	uint8_t addr;
+	uint8_t len;
+	const char *name;
+	uint32_t reg;
+};
+
+/** */
+int dsp563xx_once_request_debug(struct jtag_tap *tap, int reset_state);
+/** */
+int dsp563xx_once_target_status(struct jtag_tap *tap);
+
+/** once read registers */
+int dsp563xx_once_read_register(struct jtag_tap *tap, struct once_reg *regs, int len);
+/** once read register */
+int dsp563xx_once_reg_read_ex_nq(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data);
+/** once read register */
+int dsp563xx_once_reg_read_ex(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data);
 /** once read register */
 int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data);
 /** once write register */
@@ -64,12 +84,10 @@ int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data);
 /** single word instruction */
 int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, uint32_t opcode);
 /** double word instruction */
-int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode,
-				uint32_t operand);
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode, uint32_t operand);
 /** single word instruction */
 int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap, uint32_t opcode);
 /** double word instruction */
-int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode,
-				   uint32_t operand);
+int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode, uint32_t operand);
 
 #endif /* DSP563XX_ONCE_H */

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c      | 1128 ++++++++++++++++++++++++++++----------------
 src/target/dsp563xx.h      |   18 +-
 src/target/dsp563xx_once.c |  313 +++++++++++--
 src/target/dsp563xx_once.h |   28 +-
 4 files changed, 1025 insertions(+), 462 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb  4 10:56:30 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  4 Feb 2011 09:56:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-737-g5ca7cbe
Message-ID: <E1PlIP3-0005gz-Ev@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5ca7cbe2d232fcaff32598af1ef5e962e704c004 (commit)
      from  75cdbff5aa93d93e414cb22d413f41fb38a076bb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5ca7cbe2d232fcaff32598af1ef5e962e704c004
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jan 31 12:32:07 2011 +0100

    stm32x: add support for STM32F20x
    
    ready for wider testing and comments on basic erase + programming.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/contrib/loaders/flash/stm32f2xxx.S b/contrib/loaders/flash/stm32f2xxx.S
new file mode 100644
index 0000000..49c821b
--- /dev/null
+++ b/contrib/loaders/flash/stm32f2xxx.S
@@ -0,0 +1,63 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2011 ??yvind Harboe                                      *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+
+// Build : arm-eabi-gcc -c stm32f2xxx.S
+	.text
+	.syntax unified
+	.cpu cortex-m3
+	.thumb
+	.thumb_func
+	.global write
+
+/*
+	r0 - source address
+	r1 - target address
+	r2 - count (halfword-16bit)
+	r3 - result out
+	r4 - flash base
+*/
+
+#define STM32_FLASH_CR_OFFSET	0x10			/* offset of CR register in FLASH struct */
+#define STM32_FLASH_SR_OFFSET	0x0c			/* offset of CR register in FLASH struct */
+
+write:
+
+write_half_word:
+	ldr		r3, STM32_PROG16
+	str		r3, [r4, #STM32_FLASH_CR_OFFSET]
+	ldrh 	r3, [r0], #0x02						/* read one half-word from src, increment ptr */
+	strh 	r3, [r1], #0x02						/* write one half-word from src, increment ptr */
+busy:
+	ldr 	r3, [r4, #STM32_FLASH_SR_OFFSET]
+	tst 	r3, #0x10000						/* BSY (bit0) == 1 => operation in progress */
+	beq 	busy								/* wait more... */
+	tst		r3, #0xf0							/* PGSERR | PGPERR | PGAERR | WRPERR */
+	bne		exit								/* fail... */
+	subs	r2, r2, #0x01						/* decrement counter */
+	bne		write_half_word						/* write next half-word if anything left */
+exit:
+	bkpt	#0x00
+
+
+STM32_PROG16: .word 0x101 						/* PG | PSIZE_16*/
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 42707e0..95bd313 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -25,6 +25,7 @@ NOR_DRIVERS = \
 	stmsmi.c \
 	stellaris.c \
 	stm32x.c \
+	stm32f2xxx.c \
 	str7x.c \
 	str9x.c \
 	str9xpec.c \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index f4479f6..5489419 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -33,6 +33,7 @@ extern struct flash_driver aduc702x_flash;
 extern struct flash_driver stellaris_flash;
 extern struct flash_driver str9xpec_flash;
 extern struct flash_driver stm32x_flash;
+extern struct flash_driver stm32xf2xxx_flash;
 extern struct flash_driver tms470_flash;
 extern struct flash_driver ecosflash_flash;
 extern struct flash_driver ocl_flash;
@@ -60,6 +61,7 @@ static struct flash_driver *flash_drivers[] = {
 	&stellaris_flash,
 	&str9xpec_flash,
 	&stm32x_flash,
+	&stm32xf2xxx_flash,
 	&tms470_flash,
 	&ecosflash_flash,
 	&ocl_flash,
diff --git a/src/flash/nor/stm32f2xxx.c b/src/flash/nor/stm32f2xxx.c
new file mode 100644
index 0000000..2ccf531
--- /dev/null
+++ b/src/flash/nor/stm32f2xxx.c
@@ -0,0 +1,712 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2008 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   Copyright (C) 2011 ??yvind Harboe                                      *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include <helper/binarybuffer.h>
+#include <target/algorithm.h>
+#include <target/armv7m.h>
+
+/* Regarding performance:
+ *
+ * Short story - it might be best to leave the performance at
+ * current levels.
+ *
+ * You may see a jump in speed if you change to using
+ * 32bit words for the block programming.
+ *
+ * Its a shame you cannot use the double word as its
+ * even faster - but you require external VPP for that mode.
+ *
+ * Having said all that 16bit writes give us the widest vdd
+ * operating range, so may be worth adding a note to that effect.
+ *
+ */
+
+
+/* Danger!!!! The STM32F1xxxx and STM32F2xxxx series actually have
+ * quite different flash controllers.
+ *
+ * What's more scary is that the names of the registers and their
+ * addresses are the same, but the actual bits and what they do are
+ * can be very different.
+ *
+ * To reduce testing complexity and dangers of regressions,
+ * a seperate file is used for stm32fx2222.
+ *
+ * 1mByte part with 4 x 16, 1 x 64, 7 x 128kBytes sectors
+ *
+ * What's the protection page size???
+ *
+ * Tested with STM3220F-EVAL board.
+ *
+ * STM32F21xx series for reference.
+ *
+ * RM0033
+ * http://www.st.com/internet/mcu/product/250192.jsp
+ *
+ * PM0059
+ * www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/PROGRAMMING_MANUAL/CD00233952.pdf
+ *
+ * STM32F1xxx series - notice that this code was copy, pasted and knocked
+ * into a stm32f2xxx driver, so in case something has been converted or
+ * bugs haven't been fixed, here are the original manuals:
+ *
+ * RM0008 - Reference manual
+ *
+ * RM0042, the Flash programming manual for low-, medium- high-density and
+ * connectivity line STM32F10xxx devices
+ *
+ * PM0068, the Flash programming manual for XL-density STM32F10xxx devices.
+ *
+ */
+
+ // Erase time can be as high as 1000ms, 10x this and it's toast...
+#define FLASH_ERASE_TIMEOUT 10000
+#define FLASH_WRITE_TIMEOUT 5
+
+
+#define STM32_FLASH_BASE	0x40023c00
+#define STM32_FLASH_ACR		0x40023c00
+#define STM32_FLASH_KEYR	0x40023c04
+#define STM32_FLASH_OPTKEYR	0x40023c08
+#define STM32_FLASH_SR		0x40023c0C
+#define STM32_FLASH_CR		0x40023c10
+#define STM32_FLASH_OPTCR	0x40023c14
+#define STM32_FLASH_OBR		0x40023c1C
+
+
+
+/* option byte location */
+
+#define STM32_OB_RDP		0x1FFFF800
+#define STM32_OB_USER		0x1FFFF802
+#define STM32_OB_DATA0		0x1FFFF804
+#define STM32_OB_DATA1		0x1FFFF806
+#define STM32_OB_WRP0		0x1FFFF808
+#define STM32_OB_WRP1		0x1FFFF80A
+#define STM32_OB_WRP2		0x1FFFF80C
+#define STM32_OB_WRP3		0x1FFFF80E
+
+/* FLASH_CR register bits */
+
+#define FLASH_PG		(1 << 0)
+#define FLASH_SER		(1 << 1)
+#define FLASH_MER		(1 << 2)
+#define FLASH_STRT		(1 << 16)
+#define FLASH_PSIZE_8	(0 << 8)
+#define FLASH_PSIZE_16	(1 << 8)
+#define FLASH_PSIZE_32	(2 << 8)
+#define FLASH_PSIZE_64	(3 << 8)
+#define FLASH_SNB(a) 	((a) << 3)
+#define FLASH_LOCK		(1 << 31)
+
+/* FLASH_SR register bits */
+
+#define FLASH_BSY		(1 << 16)
+#define FLASH_PGSERR	(1 << 7) // Programming sequence error
+#define FLASH_PGPERR	(1 << 6) // Programming parallelism error
+#define FLASH_PGAERR	(1 << 5) // Programming alignment error
+#define FLASH_WRPERR	(1 << 4) // Write protection error
+#define FLASH_OPERR		(1 << 1) // Operation error
+
+#define FLASH_ERROR (FLASH_PGSERR | FLASH_PGPERR | FLASH_PGAERR| FLASH_WRPERR| FLASH_OPERR)
+
+/* STM32_FLASH_OBR bit definitions (reading) */
+
+#define OPT_ERROR		0
+#define OPT_READOUT		1
+#define OPT_RDWDGSW		2
+#define OPT_RDRSTSTOP	3
+#define OPT_RDRSTSTDBY	4
+#define OPT_BFB2		5	/* dual flash bank only */
+
+/* register unlock keys */
+
+#define KEY1			0x45670123
+#define KEY2			0xCDEF89AB
+
+struct stm32x_flash_bank
+{
+	struct working_area *write_algorithm;
+	int probed;
+};
+
+
+/* flash bank stm32x <base> <size> 0 0 <target#>
+ */
+FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
+{
+	struct stm32x_flash_bank *stm32x_info;
+
+	if (CMD_ARGC < 6)
+	{
+		LOG_WARNING("incomplete flash_bank stm32x configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	stm32x_info = malloc(sizeof(struct stm32x_flash_bank));
+	bank->driver_priv = stm32x_info;
+
+	stm32x_info->write_algorithm = NULL;
+	stm32x_info->probed = 0;
+
+	return ERROR_OK;
+}
+
+static inline int stm32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
+{
+	return reg;
+}
+
+static inline int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
+{
+	struct target *target = bank->target;
+	return target_read_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR), status);
+}
+
+static int stm32x_wait_status_busy(struct flash_bank *bank, int timeout)
+{
+	struct target *target = bank->target;
+	uint32_t status;
+	int retval = ERROR_OK;
+
+	/* wait for busy to clear */
+	for (;;)
+	{
+		retval = stm32x_get_flash_status(bank, &status);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("status: 0x%" PRIx32 "", status);
+		if ((status & FLASH_BSY) == 0)
+			break;
+		if (timeout-- <= 0)
+		{
+			LOG_ERROR("timed out waiting for flash");
+			return ERROR_FAIL;
+		}
+		alive_sleep(1);
+	}
+
+
+	if (status & FLASH_WRPERR)
+	{
+		LOG_ERROR("stm32x device protected");
+		retval = ERROR_FAIL;
+	}
+
+	/* Clear but report errors */
+	if (status & FLASH_ERROR)
+	{
+		/* If this operation fails, we ignore it and report the original
+		 * retval
+		 */
+		target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_SR),
+				status & FLASH_ERROR);
+	}
+	return retval;
+}
+
+static int stm32x_unlock_reg(struct target *target)
+{
+	/* unlock flash registers */
+	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	if (retval != ERROR_OK)
+		return retval;
+	return ERROR_OK;
+}
+
+static int stm32x_protect_check(struct flash_bank *bank)
+{
+	return ERROR_OK;
+}
+
+static int stm32x_erase(struct flash_bank *bank, int first, int last)
+{
+	struct target *target = bank->target;
+	int i;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	int retval;
+	retval = stm32x_unlock_reg(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	Sector Erase
+	To erase a sector, follow the procedure below:
+	1. Check that no Flash memory operation is ongoing by checking the BSY bit in the
+	  FLASH_SR register
+	2. Set the SER bit and select the sector (out of the 12 sectors in the main memory block)
+	  you wish to erase (SNB) in the FLASH_CR register
+	3. Set the STRT bit in the FLASH_CR register
+	4. Wait for the BSY bit to be cleared
+	 */
+
+	for (i = first; i <= last; i++)
+	{
+		retval = target_write_u32(target,
+				stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_SER | FLASH_SNB(i) | FLASH_STRT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, FLASH_ERASE_TIMEOUT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bank->sectors[i].is_erased = 1;
+	}
+
+	retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR), FLASH_LOCK);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	return ERROR_OK;
+}
+
+static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t buffer_size = 16384;
+	struct working_area *source;
+	uint32_t address = bank->base + offset;
+	struct reg_param reg_params[5];
+	struct armv7m_algorithm armv7m_info;
+	int retval = ERROR_OK;
+
+	/* see contib/loaders/flash/stm32x.s for src */
+
+	static const uint16_t stm32x_flash_write_code_16[] = {
+//	00000000 <write>:
+	   0x4b07, //     	ldr	r3, [pc, #28]	(20 <STM32_PROG16>)
+	   0x6123,  //    	str	r3, [r4, #16]
+       0xf830, 0x3b02, 	//ldrh.w	r3, [r0], #2
+       0xf821, 0x3b02, 	//strh.w	r3, [r1], #2
+
+	//0000000c <busy>:
+	0x68e3,      	//ldr	r3, [r4, #12]
+0xf413, 0x3f80, // 	tst.w	r3, #65536	; 0x10000
+0xd0fb,      	//beq.n	c <busy>
+0xf013, 0x0ff0, 	//tst.w	r3, #240	; 0xf0
+0xd101,      	//bne.n	1e <exit>
+0x3a01,      	//subs	r2, #1
+0xd1f0,      	//bne.n	0 <write>
+	            	   	//0000001e <exit>:
+	0xbe00, //      	bkpt	0x0000
+
+	//00000020 <STM32_PROG16>:
+	0x0101, 0x0000, // 	.word	0x00000101
+
+	};
+
+	// Flip endian
+	uint8_t stm32x_flash_write_code[sizeof(stm32x_flash_write_code_16)*2];
+	for (unsigned i = 0; i < sizeof(stm32x_flash_write_code_16) / 2; i++)
+	{
+		stm32x_flash_write_code[i*2 + 0] = stm32x_flash_write_code_16[i] & 0xff;
+		stm32x_flash_write_code[i*2 + 1] = (stm32x_flash_write_code_16[i] >> 8) & 0xff;
+	}
+
+	if (target_alloc_working_area(target, sizeof(stm32x_flash_write_code),
+			&stm32x_info->write_algorithm) != ERROR_OK)
+	{
+		LOG_WARNING("no working area available, can't do block memory writes");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	};
+
+	if ((retval = target_write_buffer(target, stm32x_info->write_algorithm->address,
+			sizeof(stm32x_flash_write_code),
+			(uint8_t*)stm32x_flash_write_code)) != ERROR_OK)
+		return retval;
+
+	/* memory buffer */
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
+	{
+		buffer_size /= 2;
+		if (buffer_size <= 256)
+		{
+			/* if we already allocated the writing code, but failed to get a
+			 * buffer, free the algorithm */
+			if (stm32x_info->write_algorithm)
+				target_free_working_area(target, stm32x_info->write_algorithm);
+
+			LOG_WARNING("no large enough working area available, can't do block memory writes");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+	};
+
+	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.core_mode = ARMV7M_MODE_ANY;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+	init_reg_param(&reg_params[3], "r3", 32, PARAM_IN_OUT);
+	init_reg_param(&reg_params[4], "r4", 32, PARAM_OUT);
+
+	while (count > 0)
+	{
+		uint32_t thisrun_count = (count > (buffer_size / 2)) ?
+				(buffer_size / 2) : count;
+
+		if ((retval = target_write_buffer(target, source->address,
+				thisrun_count * 2, buffer)) != ERROR_OK)
+			break;
+
+		buf_set_u32(reg_params[0].value, 0, 32, source->address);
+		buf_set_u32(reg_params[1].value, 0, 32, address);
+		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+		// R3 is a return value only
+		buf_set_u32(reg_params[4].value, 0, 32, STM32_FLASH_BASE);
+
+		if ((retval = target_run_algorithm(target, 0, NULL,
+				sizeof(reg_params) / sizeof(*reg_params),
+				reg_params,
+				stm32x_info->write_algorithm->address,
+				0,
+				10000, &armv7m_info)) != ERROR_OK)
+		{
+			LOG_ERROR("error executing stm32x flash write algorithm");
+			break;
+		}
+
+		uint32_t error = buf_get_u32(reg_params[3].value, 0, 32) & FLASH_ERROR;
+
+		if (error & FLASH_WRPERR)
+		{
+			LOG_ERROR("flash memory write protected");
+		}
+
+		if (error != 0)
+		{
+			LOG_ERROR("flash write failed = %08x", error);
+			/* Clear but report errors */
+			target_write_u32(target, STM32_FLASH_SR, error);
+			retval = ERROR_FAIL;
+			break;
+		}
+
+		buffer += thisrun_count * 2;
+		address += thisrun_count * 2;
+		count -= thisrun_count;
+	}
+
+	target_free_working_area(target, source);
+	target_free_working_area(target, stm32x_info->write_algorithm);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+	destroy_reg_param(&reg_params[3]);
+	destroy_reg_param(&reg_params[4]);
+
+	return retval;
+}
+
+static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct target *target = bank->target;
+	uint32_t words_remaining = (count / 2);
+	uint32_t bytes_remaining = (count & 0x00000001);
+	uint32_t address = bank->base + offset;
+	uint32_t bytes_written = 0;
+	int retval;
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset & 0x1)
+	{
+		LOG_WARNING("offset 0x%" PRIx32 " breaks required 2-byte alignment", offset);
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+	}
+
+	retval = stm32x_unlock_reg(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* multiple half words (2-byte) to be programmed? */
+	if (words_remaining > 0)
+	{
+		/* try using a block write */
+		if ((retval = stm32x_write_block(bank, buffer, offset, words_remaining)) != ERROR_OK)
+		{
+			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+			{
+				/* if block write failed (no sufficient working area),
+				 * we use normal (slow) single dword accesses */
+				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+			}
+		}
+		else
+		{
+			buffer += words_remaining * 2;
+			address += words_remaining * 2;
+			words_remaining = 0;
+		}
+	}
+
+	if ((retval != ERROR_OK) && (retval != ERROR_TARGET_RESOURCE_NOT_AVAILABLE))
+		return retval;
+
+	/*
+	Standard programming
+	The Flash memory programming sequence is as follows:
+	1. Check that no main Flash memory operation is ongoing by checking the BSY bit in the
+	  FLASH_SR register.
+	2. Set the PG bit in the FLASH_CR register
+	3. Perform the data write operation(s) to the desired memory address (inside main
+	  memory block or OTP area):
+	??? ??? Half-word access in case of x16 parallelism
+	??? Word access in case of x32 parallelism
+	???
+	4.
+	Byte access in case of x8 parallelism
+	Double word access in case of x64 parallelism
+	Wait for the BSY bit to be cleared
+	*/
+	while (words_remaining > 0)
+	{
+		uint16_t value;
+		memcpy(&value, buffer + bytes_written, sizeof(uint16_t));
+
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
+				FLASH_PG | FLASH_PSIZE_16);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = target_write_u16(target, address, value);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, FLASH_WRITE_TIMEOUT);
+		if (retval != ERROR_OK)
+			return retval;
+
+		bytes_written += 2;
+		words_remaining--;
+		address += 2;
+	}
+
+	if (bytes_remaining)
+	{
+		retval = target_write_u32(target, stm32x_get_flash_reg(bank, STM32_FLASH_CR),
+				FLASH_PG | FLASH_PSIZE_8);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_u8(target, address, buffer[bytes_written]);
+		if (retval != ERROR_OK)
+			return retval;
+
+		retval = stm32x_wait_status_busy(bank, FLASH_WRITE_TIMEOUT);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+}
+
+static void setup_sector(struct flash_bank *bank, int start, int num, int size)
+{
+	for (int i = start; i < (start + num) ; i++)
+	{
+		bank->sectors[i].offset = bank->size;
+		bank->sectors[i].size = size;
+		bank->size += bank->sectors[i].size;
+	}
+}
+
+static int stm32x_probe(struct flash_bank *bank)
+{
+	struct target *target = bank->target;
+	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
+	int i;
+	uint16_t num_pages;
+	uint32_t device_id;
+	uint32_t base_address = 0x08000000;
+
+	stm32x_info->probed = 0;
+
+	/* read stm32 device id register */
+	int retval = target_read_u32(target, 0xE0042000, &device_id);
+	if (retval != ERROR_OK)
+		return retval;
+	LOG_INFO("device id = 0x%08" PRIx32 "", device_id);
+
+	/* get flash size from target. */
+	retval = target_read_u16(target, 0x1FFFF7E0, &num_pages);
+	if (retval != ERROR_OK)
+	{
+		LOG_WARNING("failed reading flash size, default to max target family");
+		/* failed reading flash size, default to max target family */
+		num_pages = 0xffff;
+	}
+
+	if ((device_id & 0x7ff) != 0x411)
+	{
+		LOG_WARNING("Cannot identify target as a STM32 family, try the other STM32 drivers.");
+		return ERROR_FAIL;
+	}
+
+	/* sectors sizes vary, handle this in a different code path
+	 * than the rest.
+	 */
+	// Uhhh.... what to use here?
+
+	/* calculate numbers of pages*/
+	num_pages = 4 + 1 + 7;
+
+	if (bank->sectors)
+	{
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
+	bank->base = base_address;
+	bank->num_sectors = num_pages;
+	bank->sectors = malloc(sizeof(struct flash_sector) * num_pages);
+
+	bank->size = 0;
+	setup_sector(bank, 0, 4, 16 * 1024);
+	setup_sector(bank, 4, 1, 64 * 1024);
+	setup_sector(bank, 4+1, 7, 128 * 1024);
+
+	for (i = 0; i < num_pages; i++)
+	{
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = 0;
+	}
+
+	LOG_INFO("flash size = %dkBytes", bank->size / 1024);
+
+	stm32x_info->probed = 1;
+
+	return ERROR_OK;
+}
+
+static int stm32x_auto_probe(struct flash_bank *bank)
+{
+	struct stm32x_flash_bank *stm32x_info = bank->driver_priv;
+	if (stm32x_info->probed)
+		return ERROR_OK;
+	return stm32x_probe(bank);
+}
+
+static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct target *target = bank->target;
+	uint32_t device_id;
+	int printed;
+
+	/* read stm32 device id register */
+	int retval = target_read_u32(target, 0xE0042000, &device_id);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if ((device_id & 0x7ff) == 0x411)
+	{
+		printed = snprintf(buf, buf_size, "stm32x (1mByte part) - Rev: ");
+		buf += printed;
+		buf_size -= printed;
+
+		switch (device_id >> 16)
+		{
+			case 0x1000:
+				snprintf(buf, buf_size, "A");
+				break;
+
+			case 0x2000:
+				snprintf(buf, buf_size, "B");
+				break;
+
+			case 0x1001:
+				snprintf(buf, buf_size, "Z");
+				break;
+
+			default:
+				snprintf(buf, buf_size, "unknown");
+				break;
+		}
+	}
+	else
+	{
+		snprintf(buf, buf_size, "Cannot identify target as a stm32x\n");
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static const struct command_registration stm32x_exec_command_handlers[] = {
+	COMMAND_REGISTRATION_DONE
+};
+
+static const struct command_registration stm32x_command_handlers[] = {
+	{
+		.name = "stm32f2xxx",
+		.mode = COMMAND_ANY,
+		.help = "stm32f2xxx flash command group",
+		.chain = stm32x_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct flash_driver stm32xf2xxx_flash = {
+	.name = "stm32f2xxx",
+	.commands = stm32x_command_handlers,
+	.flash_bank_command = stm32x_flash_bank_command,
+	.erase = stm32x_erase,
+	.protect = stm32x_protect,
+	.write = stm32x_write,
+	.read = default_flash_read,
+	.probe = stm32x_probe,
+	.auto_probe = stm32x_auto_probe,
+	.erase_check = default_flash_mem_blank_check,
+	.protect_check = stm32x_protect_check,
+	.info = get_stm32x_info,
+};

-----------------------------------------------------------------------

Summary of changes:
 contrib/loaders/flash/{stm32x.S => stm32f2xxx.S} |   21 +-
 src/flash/nor/Makefile.am                        |    1 +
 src/flash/nor/drivers.c                          |    2 +
 src/flash/nor/stm32f2xxx.c                       |  712 ++++++++++++++++++++++
 4 files changed, 728 insertions(+), 8 deletions(-)
 copy contrib/loaders/flash/{stm32x.S => stm32f2xxx.S} (80%)
 create mode 100644 src/flash/nor/stm32f2xxx.c


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb  8 09:41:09 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Feb 2011 08:41:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-738-g706284a
Message-ID: <E1Pmj8I-0001Lt-GM@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  706284a8fd562d5a6e2c1f123f8cb366b7e49e7d (commit)
      from  5ca7cbe2d232fcaff32598af1ef5e962e704c004 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 706284a8fd562d5a6e2c1f123f8cb366b7e49e7d
Author: Mathias K <kesmtp at freenet.de>
Date:   Fri Feb 4 21:15:22 2011 +0100

    buf_set_buf around 30% speed increase
    
    Also i have checked the input of this function and in many cases
    a simple byte copy is possible.
    
    I have added this check now and is it possible the buffer is
    copied byte by byte and not bit by bit.
    
    With byte boundary input the test looks like this:
    
    buf_set_buf 0x02000000 iteration test:
    runtime (seconds): old: 6.828559 new: 0.436191 diff: 6.392368
    runtime (seconds): old: 6.853636 new: 0.430389 diff: 6.423247
    runtime (seconds): old: 6.794985 new: 0.423065 diff: 6.371920
    
    Without:
    
    buf_set_buf 0x02000000 iteration test:
    runtime (seconds): old: 6.370869 new: 5.552624 diff: 0.818245
    runtime (seconds): old: 6.420730 new: 5.665887 diff: 0.754843
    runtime (seconds): old: 6.583306 new: 5.599021 diff: 0.984285
    
    Regards,
    
    Mathias

diff --git a/src/helper/binarybuffer.c b/src/helper/binarybuffer.c
index 3a16cce..e789e6f 100644
--- a/src/helper/binarybuffer.c
+++ b/src/helper/binarybuffer.c
@@ -133,19 +133,34 @@ void* buf_set_buf(const void *_src, unsigned src_start,
 {
 	const uint8_t *src = _src;
 	uint8_t *dst = _dst;
+	unsigned  sb,db,sq,dq;
+
+	sb = src_start / 8;
+	db = dst_start / 8;
+	sq = src_start % 8;
+	dq = dst_start % 8;
 
-	unsigned src_idx = src_start, dst_idx = dst_start;
 	for (unsigned i = 0; i < len; i++)
 	{
-		if (((src[src_idx / 8] >> (src_idx % 8)) & 1) == 1)
-			dst[dst_idx / 8] |= 1 << (dst_idx % 8);
+		if (((*src >> (sq&7)) & 1) == 1)
+			*dst |= 1 << (dq&7);
 		else
-			dst[dst_idx / 8] &= ~(1 << (dst_idx % 8));
-		dst_idx++;
-		src_idx++;
+			*dst &= ~(1 << (dq&7));
+
+		if ( sq++ == 7 )
+		{
+			sq = 0;
+			src++;
+		}
+
+		if ( dq++ == 7 )
+		{
+			dq = 0;
+			dst++;
+		}
 	}
 
-	return dst;
+	return (uint8_t*)_dst;
 }
 
 uint32_t flip_u32(uint32_t value, unsigned int num)

-----------------------------------------------------------------------

Summary of changes:
 src/helper/binarybuffer.c |   29 ++++++++++++++++++++++-------
 1 files changed, 22 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb  8 09:42:42 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Feb 2011 08:42:42 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-739-gd51b561
Message-ID: <E1Pmj9n-0003Ea-TR@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d51b561b10bc516bf76ced479b73ae1c7b170cf7 (commit)
      from  706284a8fd562d5a6e2c1f123f8cb366b7e49e7d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d51b561b10bc516bf76ced479b73ae1c7b170cf7
Author: Luca Ellero <lroluk at gmail.com>
Date:   Tue Feb 8 05:16:54 2011 +0000

    cortex_a8/a9: fix some comments
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 3c80923..f50b149 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -299,7 +299,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	if (dscr & DSCR_DTR_RX_FULL)
 	{
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
-		/* Clear DCCRX with MCR(p14, 0, Rd, c0, c5, 0), opcode  0xEE000E15 */
+		/* Clear DCCRX with MRC(p14, 0, Rd, c0, c5, 0), opcode  0xEE100E15 */
 		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
 		if (retval != ERROR_OK)
@@ -318,7 +318,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 
 	if (Rd < 15)
 	{
-		/* DCCRX to Rn, "MCR p14, 0, Rn, c0, c5, 0", 0xEE00nE15 */
+		/* DCCRX to Rn, "MRC p14, 0, Rn, c0, c5, 0", 0xEE10nE15 */
 		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
 				&dscr);
 		if (retval != ERROR_OK)
@@ -326,7 +326,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	}
 	else if (Rd == 15)
 	{
-		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
+		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
 		 * then "mov r15, r0"
 		 */
 		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
@@ -339,7 +339,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	}
 	else
 	{
-		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
+		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
 		 * then "MSR CPSR_cxsf, r0" or "MSR SPSR_cxsf, r0" (all fields)
 		 */
 		retval = cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
diff --git a/src/target/cortex_a9.c b/src/target/cortex_a9.c
index 0ede1d5..5850ace 100644
--- a/src/target/cortex_a9.c
+++ b/src/target/cortex_a9.c
@@ -299,7 +299,7 @@ static int cortex_a9_dap_write_coreregister_u32(struct target *target,
 	if (dscr & DSCR_DTR_RX_FULL)
 	{
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
-		/* Clear DCCRX with MCR(p14, 0, Rd, c0, c5, 0), opcode  0xEE000E15 */
+		/* Clear DCCRX with MRC(p14, 0, Rd, c0, c5, 0), opcode  0xEE100E15 */
 		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
 		if (retval != ERROR_OK)
@@ -318,7 +318,7 @@ static int cortex_a9_dap_write_coreregister_u32(struct target *target,
 
 	if (Rd < 15)
 	{
-		/* DCCRX to Rn, "MCR p14, 0, Rn, c0, c5, 0", 0xEE00nE15 */
+		/* DCCRX to Rn, "MRC p14, 0, Rn, c0, c5, 0", 0xEE10nE15 */
 		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
 				&dscr);
 		if (retval != ERROR_OK)
@@ -326,7 +326,7 @@ static int cortex_a9_dap_write_coreregister_u32(struct target *target,
 	}
 	else if (Rd == 15)
 	{
-		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
+		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
 		 * then "mov r15, r0"
 		 */
 		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
@@ -339,7 +339,7 @@ static int cortex_a9_dap_write_coreregister_u32(struct target *target,
 	}
 	else
 	{
-		/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15
+		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
 		 * then "MSR CPSR_cxsf, r0" or "MSR SPSR_cxsf, r0" (all fields)
 		 */
 		retval = cortex_a9_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a8.c |    8 ++++----
 src/target/cortex_a9.c |    8 ++++----
 2 files changed, 8 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb  8 09:45:10 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Feb 2011 08:45:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-740-g08bf273
Message-ID: <E1PmjCE-0003CS-Ev@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  08bf273def9dcd4bae020f1fc2edecb835f6f32e (commit)
      from  d51b561b10bc516bf76ced479b73ae1c7b170cf7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 08bf273def9dcd4bae020f1fc2edecb835f6f32e
Author: Mathias K <kesmtp at freenet.de>
Date:   Thu Feb 3 17:58:52 2011 +0100

    dsp563xx: add x, y and p memory access
    
    Hello,
    
    this patch add commands to access to x,y and p memory. For run time optimization some local jtag
    function was changed to static inline.
    
    Regards,
    
    Mathias

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 85d559a..4371d0a 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -201,6 +201,7 @@ static const struct
 };
 
 #define REG_NUM_R0	0
+#define REG_NUM_R1	1
 #define REG_NUM_N0	8
 #define REG_NUM_N1	9
 #define REG_NUM_M0	16
@@ -221,6 +222,13 @@ static const struct
 #define REG_NUM_AAR2	52
 #define REG_NUM_AAR3	53
 
+enum memory_type
+{
+	MEM_X = 0,
+	MEM_Y = 1,
+	MEM_P = 2,
+};
+
 #define INSTR_JUMP	0x0AF080
 /* Effective Addressing Mode Encoding */
 #define EAME_R0		0x10
@@ -359,11 +367,11 @@ static int dsp563xx_reg_read_high_io(struct target *target, uint32_t instr_mask,
 		dsp563xx->read_core_reg(target, REG_NUM_R0);
 
 	/* move source memory to r0 */
-	instr = INSTR_MOVEP_REG_HIO(0, 0, EAME_R0, instr_mask);
+	instr = INSTR_MOVEP_REG_HIO(MEM_X, 0, EAME_R0, instr_mask);
 	if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, instr)) != ERROR_OK)
 		return err;
 	/* move r0 to debug register */
-	instr = INSTR_MOVEP_REG_HIO(0, 1, EAME_R0, 0xfffffc);
+	instr = INSTR_MOVEP_REG_HIO(MEM_X, 1, EAME_R0, 0xfffffc);
 	if ((err = dsp563xx_once_execute_sw_ir(target->tap, instr)) != ERROR_OK)
 		return err;
 	/* read debug register */
@@ -389,7 +397,7 @@ static int dsp563xx_reg_write_high_io(struct target *target, uint32_t instr_mask
 	if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, data)) != ERROR_OK)
 		return err;
 	/* move r0 to destination memory */
-	instr = INSTR_MOVEP_REG_HIO(0, 1, EAME_R0, instr_mask);
+	instr = INSTR_MOVEP_REG_HIO(MEM_X, 1, EAME_R0, instr_mask);
 	if ((err = dsp563xx_once_execute_sw_ir(target->tap, instr)) != ERROR_OK)
 		return err;
 
@@ -404,7 +412,7 @@ static int dsp563xx_reg_read(struct target *target, uint32_t eame, uint32_t * da
 	int err;
 	uint32_t instr;
 
-	instr = INSTR_MOVEP_REG_HIO(0, 1, eame, 0xfffffc);
+	instr = INSTR_MOVEP_REG_HIO(MEM_X, 1, eame, 0xfffffc);
 	if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, instr)) != ERROR_OK)
 		return err;
 	/* nop */
@@ -1114,33 +1122,12 @@ static int dsp563xx_soft_reset_halt(struct target *target)
 	return ERROR_OK;
 }
 
-/*
-* 000000			nop
-* 46F400 AABBCC		move              #$aabbcc,y0
-* 60F400 AABBCC		move              #$aabbcc,r0
-* 467000 AABBCC		move              y0,x:AABBCC
-* 607000 AABBCC		move              r0,x:AABBCC
-
-* 46E000		move              x:(r0),y0
-* 4EE000		move              y:(r0),y0
-* 07E086		move              p:(r0),y0
-
-* 0450B9		move              sr,r0
-* 0446BA		move              omr,y0
-* 0446BC		move              ssh,y0
-* 0446BD		move              ssl,y0
-* 0446BE		move              la,y0
-* 0446BF		move              lc,y0
-*
-* 61F000 AABBCC		move              x:AABBCC,r1
-* 076190		movem             r0,p:(r1)
-*
-*/
-static int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
 {
 	int err;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 	uint32_t i, x;
-	uint32_t data;
+	uint32_t data, move_cmd;
 	uint8_t *b;
 
 	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32, address, size, count);
@@ -1151,41 +1138,68 @@ static int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint3
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	switch (mem_type)
+	{
+		case MEM_X:
+			move_cmd = 0x61d800;
+			break;
+		case MEM_Y:
+			move_cmd = 0x69d800;
+			break;
+		case MEM_P:
+			move_cmd = 0x07d891;
+			break;
+		default:
+			return ERROR_INVALID_ARGUMENTS;
+	}
+
+	/* we use r0 to store temporary data */
+	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
+		dsp563xx->read_core_reg(target, REG_NUM_R0);
+	/* we use r1 to store temporary data */
+	if (!dsp563xx->core_cache->reg_list[REG_NUM_R1].valid)
+		dsp563xx->read_core_reg(target, REG_NUM_R1);
+
+	/* r0 is no longer valid on target */
+	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+	/* r1 is no longer valid on target */
+	dsp563xx->core_cache->reg_list[REG_NUM_R1].dirty = 1;
+
 	x = count;
+	b = buffer;
+
+	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0x60F400, address)) != ERROR_OK)
+		return err;
 
 	for (i = 0; i < x; i++)
 	{
-		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, address + i)) != ERROR_OK)
-			return err;
-		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, 0x07E086)) != ERROR_OK)
-			return err;
-		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x467000, 0xfffffc)) != ERROR_OK)
+		data = 0;
+		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, move_cmd)) != ERROR_OK)
 			return err;
-		if ((err = jtag_execute_queue()) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0x08D13C)) != ERROR_OK)
 			return err;
-
 		if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, &data)) != ERROR_OK)
 			return err;
+		target_buffer_set_u32(target, b, data);
+		b += 4;
 
-		b = buffer + 4 * i;
-		if (size > 0)
-			*b++ = data >> 0;
-		if (size > 1)
-			*b++ = data >> 8;
-		if (size > 2)
-			*b++ = data >> 16;
-		if (size > 3)
-			*b++ = 0x00;
+		LOG_DEBUG("R: %08X", data);
 	}
 
 	return ERROR_OK;
 }
 
-static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+{
+	return dsp563xx_read_memory(target, MEM_P, address, size, count, buffer);
+}
+
+static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
 {
 	int err;
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 	uint32_t i, x;
-	uint32_t data;
+	uint32_t data, move_cmd;
 	uint8_t *b;
 
 	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, size, count);
@@ -1196,37 +1210,260 @@ static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	switch (mem_type)
+	{
+		case MEM_X:
+			move_cmd = 0x615800;
+			break;
+		case MEM_Y:
+			move_cmd = 0x695800;
+			break;
+		case MEM_P:
+			move_cmd = 0x075891;
+			break;
+		default:
+			return ERROR_INVALID_ARGUMENTS;
+	}
+
+	/* we use r0 to store temporary data */
+	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
+		dsp563xx->read_core_reg(target, REG_NUM_R0);
+	/* we use r1 to store temporary data */
+	if (!dsp563xx->core_cache->reg_list[REG_NUM_R1].valid)
+		dsp563xx->read_core_reg(target, REG_NUM_R1);
+
+	/* r0 is no longer valid on target */
+	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+	/* r1 is no longer valid on target */
+	dsp563xx->core_cache->reg_list[REG_NUM_R1].dirty = 1;
+
 	x = count;
+	b = buffer;
+
+	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0x60F400, address)) != ERROR_OK)
+		return err;
 
 	for (i = 0; i < x; i++)
 	{
-		b = buffer + 4 * i;
+		data = target_buffer_get_u32(target, b);
+		data &= 0x00ffffff;
 
-		data = 0;
-		if (size > 0)
-			data = *buffer++;
-		if (size > 1)
-			data |= (*buffer++) << 8;
-		if (size > 2)
-			data |= (*buffer++) << 16;
-		if (size > 3)
-			data |= (*buffer++) << 24;
-
-//              LOG_DEBUG("%08X", data);
-
-		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x61F400, address + i)) != ERROR_OK)
-			return err;
-		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, data)) != ERROR_OK)
-			return err;
-		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, 0x076190)) != ERROR_OK)
+		LOG_DEBUG("W: %08X", data);
+
+		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x61F400, data)) != ERROR_OK)
 			return err;
-		if ((err = jtag_execute_queue()) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_sw_ir(target->tap, move_cmd)) != ERROR_OK)
 			return err;
+
+		b += 4;
 	}
 
 	return ERROR_OK;
 }
 
+static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+{
+	return dsp563xx_write_memory(target, MEM_P, address, size, count, buffer);
+}
+
+static void handle_md_output(struct command_context *cmd_ctx, struct target *target, uint32_t address, unsigned size, unsigned count, const uint8_t * buffer)
+{
+	const unsigned line_bytecnt = 32;
+	unsigned line_modulo = line_bytecnt / size;
+
+	char output[line_bytecnt * 4 + 1];
+	unsigned output_len = 0;
+
+	const char *value_fmt;
+	switch (size)
+	{
+		case 4:
+			value_fmt = "%8.8x ";
+			break;
+		case 2:
+			value_fmt = "%4.4x ";
+			break;
+		case 1:
+			value_fmt = "%2.2x ";
+			break;
+		default:
+			/* "can't happen", caller checked */
+			LOG_ERROR("invalid memory read size: %u", size);
+			return;
+	}
+
+	for (unsigned i = 0; i < count; i++)
+	{
+		if (i % line_modulo == 0)
+		{
+			output_len += snprintf(output + output_len, sizeof(output) - output_len, "0x%8.8x: ", (unsigned) (address + (i * size)));
+		}
+
+		uint32_t value = 0;
+		const uint8_t *value_ptr = buffer + i * size;
+		switch (size)
+		{
+			case 4:
+				value = target_buffer_get_u32(target, value_ptr);
+				break;
+			case 2:
+				value = target_buffer_get_u16(target, value_ptr);
+				break;
+			case 1:
+				value = *value_ptr;
+		}
+		output_len += snprintf(output + output_len, sizeof(output) - output_len, value_fmt, value);
+
+		if ((i % line_modulo == line_modulo - 1) || (i == count - 1))
+		{
+			command_print(cmd_ctx, "%s", output);
+			output_len = 0;
+		}
+	}
+}
+
+COMMAND_HANDLER(dsp563xx_mem_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	int err = ERROR_OK;
+	int read_mem;
+	uint32_t address = 0;
+	uint32_t count = 1, i;
+	uint32_t pattern = 0;
+	uint32_t mem_type;
+	uint8_t *buffer, *b;
+
+	switch (CMD_NAME[1])
+	{
+		case 'w':
+			read_mem = 0;
+			break;
+		case 'd':
+			read_mem = 1;
+			break;
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	switch (CMD_NAME[3])
+	{
+		case 'x':
+			mem_type = MEM_X;
+			break;
+		case 'y':
+			mem_type = MEM_Y;
+			break;
+		case 'p':
+			mem_type = MEM_P;
+			break;
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (CMD_ARGC > 0)
+	{
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	}
+
+	if (read_mem == 0)
+	{
+		if (CMD_ARGC < 2)
+		{
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+		if (CMD_ARGC > 1)
+		{
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], pattern);
+		}
+		if (CMD_ARGC > 2)
+		{
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], count);
+		}
+	}
+
+	if (read_mem == 1)
+	{
+		if (CMD_ARGC < 1)
+		{
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+		if (CMD_ARGC > 1)
+		{
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], count);
+		}
+	}
+
+	buffer = calloc(count, sizeof(uint32_t));
+
+	if (read_mem == 1)
+	{
+		if ((err = dsp563xx_read_memory(target, mem_type, address, sizeof(uint32_t), count, buffer)) == ERROR_OK)
+			handle_md_output(CMD_CTX, target, address, sizeof(uint32_t), count, buffer);
+	}
+	else
+	{
+		b = buffer;
+
+		for (i = 0; i < count; i++)
+		{
+			target_buffer_set_u32(target, b, pattern);
+			b += 4;
+		}
+
+		err = dsp563xx_write_memory(target, mem_type, address, sizeof(uint32_t), count, buffer);
+	}
+
+	free(buffer);
+
+	return err;
+}
+
+static const struct command_registration dsp563xx_command_handlers[] = {
+	{
+	 .name = "mwwx",
+	 .handler = dsp563xx_mem_command,
+	 .mode = COMMAND_EXEC,
+	 .help = "write x memory words",
+	 .usage = "mwwx address value [count]",
+	 },
+	{
+	 .name = "mwwy",
+	 .handler = dsp563xx_mem_command,
+	 .mode = COMMAND_EXEC,
+	 .help = "write y memory words",
+	 .usage = "mwwy address value [count]",
+	 },
+	{
+	 .name = "mwwp",
+	 .handler = dsp563xx_mem_command,
+	 .mode = COMMAND_EXEC,
+	 .help = "write p memory words",
+	 .usage = "mwwp address value [count]",
+	 },
+	{
+	 .name = "mdwx",
+	 .handler = dsp563xx_mem_command,
+	 .mode = COMMAND_EXEC,
+	 .help = "display x memory words",
+	 .usage = "mdwx address [count]",
+	 },
+	{
+	 .name = "mdwy",
+	 .handler = dsp563xx_mem_command,
+	 .mode = COMMAND_EXEC,
+	 .help = "display y memory words",
+	 .usage = "mdwy address [count]",
+	 },
+	{
+	 .name = "mdwp",
+	 .handler = dsp563xx_mem_command,
+	 .mode = COMMAND_EXEC,
+	 .help = "display p memory words",
+	 .usage = "mdwp address [count]",
+	 },
+	COMMAND_REGISTRATION_DONE
+};
+
 /** Holds methods for DSP563XX targets. */
 struct target_type dsp563xx_target = {
 	.name = "dsp563xx",
@@ -1249,6 +1486,7 @@ struct target_type dsp563xx_target = {
 	.read_memory = dsp563xx_read_memory_p,
 	.write_memory = dsp563xx_write_memory_p,
 
+	.commands = dsp563xx_command_handlers,
 	.target_create = dsp563xx_target_create,
 	.init_target = dsp563xx_init_target,
 };
diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
index b7443fa..df43ed6 100644
--- a/src/target/dsp563xx_once.c
+++ b/src/target/dsp563xx_once.c
@@ -43,7 +43,7 @@
 #define JTAG_INSTR_DEBUG_REQUEST	0x07
 #define JTAG_INSTR_BYPASS		0x0F
 
-static int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out, int dr_len, int rti)
+static inline int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out, int dr_len, int rti)
 {
 	if (NULL == tap)
 	{
@@ -56,7 +56,7 @@ static int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr
 	return ERROR_OK;
 }
 
-static int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t dr_out, int dr_len, int rti)
+static inline int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t dr_out, int dr_len, int rti)
 {
 	if (dr_len > 8)
 	{
@@ -67,7 +67,7 @@ static int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t d
 	return dsp563xx_write_dr(tap, dr_in, &dr_out, dr_len, rti);
 }
 
-static int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out, int dr_len, int rti)
+static inline int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out, int dr_len, int rti)
 {
 	if (dr_len > 32)
 	{
@@ -79,7 +79,7 @@ static int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_
 }
 
 /** single word instruction */
-static int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
+static inline int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
 {
 	int err;
 
@@ -90,13 +90,13 @@ static int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw
 }
 
 /** single word instruction */
-static int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
+static inline inline int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
 {
 	return dsp563xx_write_dr_u8(tap, 0, instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0);
 }
 
 /* IR and DR functions */
-static int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out, int ir_len, int rti)
+static inline int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out, int ir_len, int rti)
 {
 	if (NULL == tap)
 	{
@@ -114,7 +114,7 @@ static int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir
 	return ERROR_OK;
 }
 
-static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out, int ir_len, int rti)
+static inline int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out, int ir_len, int rti)
 {
 	if (ir_len > 8)
 	{
@@ -125,7 +125,7 @@ static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t i
 	return dsp563xx_write_ir(tap, ir_in, &ir_out, ir_len, rti);
 }
 
-static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
+static inline int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
 {
 	return dsp563xx_write_ir_u8(tap, ir_in, ir_out, tap->ir_length, 1);
 }

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c      |  368 ++++++++++++++++++++++++++++++++++++--------
 src/target/dsp563xx_once.c |   16 +-
 2 files changed, 311 insertions(+), 73 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb  8 09:51:55 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Feb 2011 08:51:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-741-g6684b35
Message-ID: <E1PmjIi-0002GY-Ig@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6684b35346fc10626041e1b2fef060786bf98a95 (commit)
      from  08bf273def9dcd4bae020f1fc2edecb835f6f32e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6684b35346fc10626041e1b2fef060786bf98a95
Author: Luca Ellero <lroluk at gmail.com>
Date:   Mon Feb 7 22:47:15 2011 +0000

    omap4430: Add JRC TAPID for PandaBoard REV EA1 (PEAP platforms)
    
    PandaBoard REV EA1 (Panda Early Adopter Program) has a different ID.
    This patch add alternate REV EA1 TAP id to configuration file
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
index 69678ee..19b2d70 100644
--- a/tcl/target/omap4430.cfg
+++ b/tcl/target/omap4430.cfg
@@ -54,11 +54,21 @@ jtag configure $_CHIPNAME.m30_dap -event tap-enable \
 if { [info exists JRC_TAPID ] } {
 	set _JRC_TAPID $JRC_TAPID
 } else {
-	set _JRC_TAPID 0x3b95c02f
+	set _JRC_TAPID  0x3b95c02f
+	set _JRC_TAPID2 0x1b85202f
 }
 
+# PandaBoard REV EA1 (PEAP platforms)
+if { [info exists JRC_TAPID2 ] } {
+	set _JRC_TAPID2 $JRC_TAPID2
+} else {
+	set _JRC_TAPID2 0x1b85202f
+}
+
+
+
 jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
-	-expected-id $_JRC_TAPID
+	-expected-id $_JRC_TAPID -expected-id $_JRC_TAPID2  
 
 # Required by ICEpick to power-up the debug domain
 jtag configure $_CHIPNAME.jrc -event post-reset "runtest 200"

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/omap4430.cfg |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb  8 11:08:11 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Feb 2011 10:08:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-742-gb21be60
Message-ID: <E1PmkUY-0001xr-LT@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b21be6054a76418e93920ae4d038f75d65ba8840 (commit)
      from  6684b35346fc10626041e1b2fef060786bf98a95 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b21be6054a76418e93920ae4d038f75d65ba8840
Author: Mathias K <kesmtp at freenet.de>
Date:   Tue Feb 8 11:06:56 2011 +0100

    performance: committed wrong version of buf_set_buf optimization
    
    oops...
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/binarybuffer.c b/src/helper/binarybuffer.c
index e789e6f..5732689 100644
--- a/src/helper/binarybuffer.c
+++ b/src/helper/binarybuffer.c
@@ -133,26 +133,40 @@ void* buf_set_buf(const void *_src, unsigned src_start,
 {
 	const uint8_t *src = _src;
 	uint8_t *dst = _dst;
-	unsigned  sb,db,sq,dq;
+	unsigned  i,sb,db,sq,dq, lb,lq;
 
 	sb = src_start / 8;
 	db = dst_start / 8;
 	sq = src_start % 8;
 	dq = dst_start % 8;
+	lb = len / 8;
+	lq = len % 8;
 
-	for (unsigned i = 0; i < len; i++)
+	src += sb;
+	dst += db;
+
+	/* check if both buffers are on byte boundary and
+	 * len is a multiple of 8bit so we can simple copy
+	 * the buffer */
+	if ( (sq == 0) && (dq == 0) &&  (lq == 0) )
+	{
+		for (i = 0; i < lb; i++)
+			*dst++ = *src++;
+		return (uint8_t*)_dst;
+	}
+
+	/* fallback to slow bit copy */
+	for (i = 0; i < len; i++)
 	{
 		if (((*src >> (sq&7)) & 1) == 1)
 			*dst |= 1 << (dq&7);
 		else
 			*dst &= ~(1 << (dq&7));
-
 		if ( sq++ == 7 )
 		{
 			sq = 0;
 			src++;
 		}
-
 		if ( dq++ == 7 )
 		{
 			dq = 0;

-----------------------------------------------------------------------

Summary of changes:
 src/helper/binarybuffer.c |   22 ++++++++++++++++++----
 1 files changed, 18 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb  8 12:12:50 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Feb 2011 11:12:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-743-g405b7a4
Message-ID: <E1PmlV7-0005sC-DU@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  405b7a458d516f1f5c6dad860a31189e1007a6b6 (commit)
      from  b21be6054a76418e93920ae4d038f75d65ba8840 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 405b7a458d516f1f5c6dad860a31189e1007a6b6
Author: Michal Demin <michaldemin at gmail.com>
Date:   Tue Feb 8 11:59:01 2011 +0100

    buspirate: Fix command parsing, fix errors to have more sense.
    
    Signed-off-by: Michal Demin <michaldemin at gmail.com>

diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
index 13819ba..836a4d1 100644
--- a/src/jtag/drivers/buspirate.c
+++ b/src/jtag/drivers/buspirate.c
@@ -262,11 +262,6 @@ static int buspirate_quit(void)
 /* openocd command interface */
 COMMAND_HANDLER(buspirate_handle_adc_command)
 {
-	if (CMD_ARGC != 0) {
-		LOG_ERROR("usage: buspirate_adc");
-		return ERROR_OK;
-	}
-
 	if (buspirate_fd == -1)
 		return ERROR_OK;
 
@@ -279,15 +274,17 @@ COMMAND_HANDLER(buspirate_handle_adc_command)
 
 COMMAND_HANDLER(buspirate_handle_vreg_command)
 {
-	if (CMD_ARGC != 1) {
+	if (CMD_ARGC < 1) {
 		LOG_ERROR("usage: buspirate_vreg <1|0>");
 		return ERROR_OK;
 	}
 
 	if (atoi(CMD_ARGV[0]) == 1)
 		buspirate_vreg = 1;
-	else
+	else if (atoi(CMD_ARGV[0]) == 0)
 		buspirate_vreg = 0;
+	else
+		LOG_ERROR("usage: buspirate_vreg <1|0>");
 
 	return ERROR_OK;
 
@@ -295,15 +292,17 @@ COMMAND_HANDLER(buspirate_handle_vreg_command)
 
 COMMAND_HANDLER(buspirate_handle_pullup_command)
 {
-	if (CMD_ARGC != 1) {
+	if (CMD_ARGC < 1) {
 		LOG_ERROR("usage: buspirate_pullup <1|0>");
 		return ERROR_OK;
 	}
 
 	if (atoi(CMD_ARGV[0]) == 1)
 		buspirate_pullup = 1;
-	else
+	else if (atoi(CMD_ARGV[0]) == 0)
 		buspirate_pullup = 0;
+	else
+		LOG_ERROR("usage: buspirate_pullup <1|0>");
 
 	return ERROR_OK;
 
@@ -311,7 +310,7 @@ COMMAND_HANDLER(buspirate_handle_pullup_command)
 
 COMMAND_HANDLER(buspirate_handle_led_command)
 {
-	if (CMD_ARGC != 1) {
+	if (CMD_ARGC < 1) {
 		LOG_ERROR("usage: buspirate_led <1|0>");
 		return ERROR_OK;
 	}
@@ -320,10 +319,12 @@ COMMAND_HANDLER(buspirate_handle_led_command)
 		/* enable led */
 		buspirate_jtag_set_feature(buspirate_fd, FEATURE_LED,
 				ACTION_ENABLE);
-	} else {
+	} else if (atoi(CMD_ARGV[0]) == 0) {
 		/* disable led */
 		buspirate_jtag_set_feature(buspirate_fd, FEATURE_LED,
 				ACTION_DISABLE);
+	} else {
+		LOG_ERROR("usage: buspirate_led <1|0>");
 	}
 
 	return ERROR_OK;
@@ -332,7 +333,7 @@ COMMAND_HANDLER(buspirate_handle_led_command)
 
 COMMAND_HANDLER(buspirate_handle_mode_command)
 {
-	if (CMD_ARGC != 1) {
+	if (CMD_ARGC < 1) {
 		LOG_ERROR("usage: buspirate_mode <normal|open-drain>");
 		return ERROR_OK;
 	}
@@ -350,7 +351,7 @@ COMMAND_HANDLER(buspirate_handle_mode_command)
 
 COMMAND_HANDLER(buspirate_handle_speed_command)
 {
-	if (CMD_ARGC != 1) {
+	if (CMD_ARGC < 1) {
 		LOG_ERROR("usage: buspirate_speed <normal|fast>");
 		return ERROR_OK;
 	}
@@ -368,12 +369,12 @@ COMMAND_HANDLER(buspirate_handle_speed_command)
 
 COMMAND_HANDLER(buspirate_handle_port_command)
 {
-	if (CMD_ARGC != 1) {
+	if (CMD_ARGC < 1) {
 		LOG_ERROR("usage: buspirate_port /dev/ttyUSB0");
 		return ERROR_OK;
 	}
 
-	if (buspirate_port == 0)
+	if (buspirate_port == NULL)
 		buspirate_port = strdup(CMD_ARGV[0]);
 
 	return ERROR_OK;
@@ -718,16 +719,15 @@ static void buspirate_jtag_enable(int fd)
 	while (!done) {
 		ret = buspirate_serial_read(fd, tmp, 4);
 		if (ret != 4) {
-			LOG_ERROR("Buspirate did not respond :"
-				"( restart everything");
+			LOG_ERROR("Buspirate error. Is is binary/"
+				"/OpenOCD support enabled?");
 			exit(-1);
 		}
-		LOG_DEBUG("TUI");
 		if (strncmp(tmp, "BBIO", 4) == 0) {
 			ret = buspirate_serial_read(fd, tmp, 1);
 			if (ret != 1) {
-				LOG_ERROR("Buspirate did not respond well :"
-					"( restart everything");
+				LOG_ERROR("Buspirate did not correctly! "
+					"Do you have correct firmware?");
 				exit(-1);
 			}
 			if (tmp[0] != '1') {
@@ -742,8 +742,8 @@ static void buspirate_jtag_enable(int fd)
 		} else if (strncmp(tmp, "OCD1", 4) == 0)
 			done = 1;
 		else {
-			LOG_ERROR("Buspirate did not respond :"
-				"( restart everything");
+			LOG_ERROR("Buspirate did not correctly! "
+				"Do you have correct firmware?");
 			exit(-1);
 		}
 	}
@@ -763,7 +763,7 @@ static void buspirate_jtag_reset(int fd)
 		tmp[0] = 0x0F; /*  reset BP */
 		buspirate_serial_write(fd, tmp, 1);
 	} else
-		LOG_ERROR("Bad reply :( Please restart manually");
+		LOG_ERROR("Unable to restart buspirate!");
 }
 
 static void buspirate_jtag_set_speed(int fd, char speed)
@@ -785,13 +785,11 @@ static void buspirate_jtag_set_speed(int fd, char speed)
 	buspirate_serial_write(fd, ack, 2);
 	ret = buspirate_serial_read(fd, tmp, 2);
 	if (ret != 2) {
-		LOG_ERROR("Buspirate did not respond :"
-			"( restart everything");
+		LOG_ERROR("Buspirate did not ack speed change");
 		exit(-1);
 	}
 	if ((tmp[0] != CMD_UART_SPEED) || (tmp[1] != speed)) {
-		LOG_ERROR("Buspirate didn't reply as expected :"
-			"( restart everything");
+		LOG_ERROR("Buspirate didn't reply as expected");
 		exit(-1);
 	}
 	LOG_INFO("Buspirate switched to %s mode",
@@ -945,7 +943,7 @@ static int buspirate_serial_read(int fd, char *buf, int size)
 	buspirate_print_buffer(buf, len);
 
 	if (len != size)
-		LOG_ERROR("Error sending data");
+		LOG_ERROR("Error reading data");
 
 	return len;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/buspirate.c |   54 ++++++++++++++++++++---------------------
 1 files changed, 26 insertions(+), 28 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb 15 20:18:49 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Feb 2011 19:18:49 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-754-g17a6ffa
Message-ID: <mailman.3.1331736152.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  17a6ffa0c78dcd2df3a8fd5260e823f8776066df (commit)
      from  422e9f9b417e9084998defec7bb4e17458a23f53 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 17a6ffa0c78dcd2df3a8fd5260e823f8776066df
Author: Phil Fong <fongpwf at yahoo.com>
Date:   Tue Feb 15 20:17:33 2011 +0100

    dsp563xx_once: Correct definition of JTAG_INSTR_CLAMP
    
     I've been working on Rodrigo on adding support to flash
    Freescale dsp56800e devices and have been looking at the
    dsp563xx code.  I think the define for the JTAG CLAMP
    instruction in dsp563xx_once.c is incorrect.  It should
    be 0x05 according the Freescale AN2074 (and is also
    0x05 in the dsp568xx according to AN1935).  It won't
    actually change anything in OpenOCD since this define
    is not used anywhere (as far as I can tell).

diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
index cb3abf6..ddd06dd 100644
--- a/src/target/dsp563xx_once.c
+++ b/src/target/dsp563xx_once.c
@@ -37,8 +37,8 @@
 #define JTAG_INSTR_EXTEST		0x00
 #define JTAG_INSTR_SAMPLE_PRELOAD	0x01
 #define JTAG_INSTR_IDCODE		0x02
-#define JTAG_INSTR_CLAMP		0x03
 #define JTAG_INSTR_HIZ			0x04
+#define JTAG_INSTR_CLAMP		0x05
 #define JTAG_INSTR_ENABLE_ONCE		0x06
 #define JTAG_INSTR_DEBUG_REQUEST	0x07
 #define JTAG_INSTR_BYPASS		0x0F

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx_once.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb 15 20:20:00 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Feb 2011 19:20:00 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-756-gfe08940
Message-ID: <mailman.4.1331736152.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fe0894015fd3d25593ce3a7211b1540ebfbab1f3 (commit)
       via  aa9baf11a8080cab47f19905a0e7697a1128724e (commit)
      from  17a6ffa0c78dcd2df3a8fd5260e823f8776066df (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fe0894015fd3d25593ce3a7211b1540ebfbab1f3
Author: Mathias K <kesmtp at freenet.de>
Date:   Tue Feb 15 17:25:10 2011 +0100

    - add parameter flush to the once api to signalize if the jtag queue need to be flushed after the command

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 10365df..011b616 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -366,14 +366,14 @@ static int dsp563xx_reg_read_high_io(struct target *target, uint32_t instr_mask,
 
 	/* move source memory to r0 */
 	instr = INSTR_MOVEP_REG_HIO(MEM_X, 0, EAME_R0, instr_mask);
-	if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, instr)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0, instr)) != ERROR_OK)
 		return err;
 	/* move r0 to debug register */
 	instr = INSTR_MOVEP_REG_HIO(MEM_X, 1, EAME_R0, 0xfffffc);
-	if ((err = dsp563xx_once_execute_sw_ir(target->tap, instr)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, 1, instr)) != ERROR_OK)
 		return err;
 	/* read debug register */
-	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, data)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OGDBR, data)) != ERROR_OK)
 		return err;
 	/* r0 is no longer valid on target */
 	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
@@ -392,11 +392,11 @@ static int dsp563xx_reg_write_high_io(struct target *target, uint32_t instr_mask
 		dsp563xx->read_core_reg(target, REG_NUM_R0);
 
 	/* move data to r0 */
-	if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x60F400, data)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0, 0x60F400, data)) != ERROR_OK)
 		return err;
 	/* move r0 to destination memory */
 	instr = INSTR_MOVEP_REG_HIO(MEM_X, 1, EAME_R0, instr_mask);
-	if ((err = dsp563xx_once_execute_sw_ir(target->tap, instr)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, 1, instr)) != ERROR_OK)
 		return err;
 
 	/* r0 is no longer valid on target */
@@ -411,23 +411,23 @@ static int dsp563xx_reg_read(struct target *target, uint32_t eame, uint32_t * da
 	uint32_t instr;
 
 	instr = INSTR_MOVEP_REG_HIO(MEM_X, 1, eame, 0xfffffc);
-	if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, instr)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0, instr)) != ERROR_OK)
 		return err;
 	/* nop */
-	if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0x000000)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_sw_ir(target->tap, 1, 0x000000)) != ERROR_OK)
 		return err;
 	/* read debug register */
-	return dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, data);
+	return dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OGDBR, data);
 }
 
 static int dsp563xx_reg_write(struct target *target, uint32_t instr_mask, uint32_t data)
 {
 	int err;
 
-	if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, instr_mask, data)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0, instr_mask, data)) != ERROR_OK)
 		return err;
 	/* nop */
-	return dsp563xx_once_execute_sw_ir(target->tap, 0x000000);
+	return dsp563xx_once_execute_sw_ir(target->tap, 1, 0x000000);
 }
 
 static int dsp563xx_reg_pc_read(struct target *target)
@@ -440,9 +440,9 @@ static int dsp563xx_reg_pc_read(struct target *target)
 	if (dsp563xx->core_cache->reg_list[REG_NUM_PC].dirty)
 		return ERROR_OK;
 
-	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABDR, &opabdr)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABDR, &opabdr)) != ERROR_OK)
 		return err;
-	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX, &opabex)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABEX, &opabex)) != ERROR_OK)
 		return err;
 
 	/* conditional branch check */
@@ -771,7 +771,7 @@ static int dsp563xx_arch_state(struct target *target)
 
 static int dsp563xx_debug_once_init(struct target *target)
 {
-	return dsp563xx_once_read_register(target->tap, once_regs, DSP563XX_NUMONCEREGS);
+	return dsp563xx_once_read_register(target->tap, 1, once_regs, DSP563XX_NUMONCEREGS);
 }
 
 static int dsp563xx_debug_init(struct target *target)
@@ -796,7 +796,7 @@ static int dsp563xx_debug_init(struct target *target)
 	{
 		sr &= ~(DSP563XX_SR_SA | DSP563XX_SR_SC);
 
-		if ((err = dsp563xx_once_execute_dw_ir(target->tap, arch_info->instr_mask, sr)) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_dw_ir(target->tap, 1, arch_info->instr_mask, sr)) != ERROR_OK)
 			return err;
 		dsp563xx->core_cache->reg_list[REG_NUM_SR].dirty = 1;
 	}
@@ -868,7 +868,7 @@ static int dsp563xx_poll(struct target *target)
 		return ERROR_TARGET_FAILURE;
 	}
 
-	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR, &once_status)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OSCR, &once_status)) != ERROR_OK)
 		return err;
 
 	if ((once_status & DSP563XX_ONCE_OSCR_DEBUG_M) == DSP563XX_ONCE_OSCR_DEBUG_M)
@@ -906,9 +906,9 @@ static int dsp563xx_halt(struct target *target)
 		return err;
 
 	/* store pipeline register */
-	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
 		return err;
-	if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
 		return err;
 
 	LOG_DEBUG("%s", __FUNCTION__);
@@ -930,19 +930,19 @@ static int dsp563xx_resume(struct target *target, int current, uint32_t address,
 	if (current)
 	{
 		/* restore pipeline registers and go */
-		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
 			return err;
 		if ((err =
-		     dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
+		     dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
 					     dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
 			return err;
 	}
 	else
 	{
 		/* set to go register and jump */
-		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR, INSTR_JUMP)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR, INSTR_JUMP)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO, address)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO, address)) != ERROR_OK)
 			return err;
 	}
 
@@ -972,10 +972,10 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 		return err;
 
 	/* reset trace mode */
-	if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, 0x000000)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OSCR, 0x000000)) != ERROR_OK)
 		return err;
 	/* enable trace mode */
-	if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, DSP563XX_ONCE_OSCR_TME)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OSCR, DSP563XX_ONCE_OSCR_TME)) != ERROR_OK)
 		return err;
 
 	cnt = steps;
@@ -985,53 +985,53 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 		cnt++;
 
 	/* load step counter with N-1 */
-	if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OTC, cnt)) != ERROR_OK)
+	if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OTC, cnt)) != ERROR_OK)
 		return err;
 
 	if (current)
 	{
 		/* restore pipeline registers and go */
-		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
 			return err;
 		if ((err =
-		     dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
+		     dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
 					     dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
 			return err;
 	}
 	else
 	{
 		/* set to go register and jump */
-		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OPDBR, INSTR_JUMP)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR, INSTR_JUMP)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO, address)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_PDBGOTO | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO, address)) != ERROR_OK)
 			return err;
 	}
 
 	while (1)
 	{
-		if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OSCR, &once_status)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OSCR, &once_status)) != ERROR_OK)
 			return err;
 
 		if (once_status & DSP563XX_ONCE_OSCR_TO)
 		{
 			/* store pipeline register */
-			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
 				return err;
-			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
 				return err;
 
-			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABFR, &dr_in)) != ERROR_OK)
+			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABFR, &dr_in)) != ERROR_OK)
 				return err;
 			LOG_DEBUG("fetch: %08X", (unsigned) dr_in);
-			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABDR, &dr_in)) != ERROR_OK)
+			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABDR, &dr_in)) != ERROR_OK)
 				return err;
 			LOG_DEBUG("decode: %08X", (unsigned) dr_in);
-			if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OPABEX, &dr_in)) != ERROR_OK)
+			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABEX, &dr_in)) != ERROR_OK)
 				return err;
 			LOG_DEBUG("execute: %08X", (unsigned) dr_in);
 
 			/* reset trace mode */
-			if ((err = dsp563xx_once_reg_write(target->tap, DSP563XX_ONCE_OSCR, 0x000000)) != ERROR_OK)
+			if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OSCR, 0x000000)) != ERROR_OK)
 				return err;
 
 			register_cache_invalidate(dsp563xx->core_cache);
@@ -1173,16 +1173,16 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 	x = count;
 	b = buffer;
 
-	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0x60F400, address)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 1, 0x60F400, address)) != ERROR_OK)
 		return err;
 
 	for (i = 0; i < x; i++)
 	{
-		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, move_cmd)) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0, move_cmd)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, 0x08D13C)) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0, 0x08D13C)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_reg_read_nq(target->tap, DSP563XX_ONCE_OGDBR, (uint32_t*)b)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_read(target->tap, 0, DSP563XX_ONCE_OGDBR, (uint32_t*)b)) != ERROR_OK)
 			return err;
 		b += 4;
 	}
@@ -1264,7 +1264,7 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	x = count;
 	b = buffer;
 
-	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0x60F400, address)) != ERROR_OK)
+	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 1, 0x60F400, address)) != ERROR_OK)
 		return err;
 
 	for (i = 0; i < x; i++)
@@ -1275,9 +1275,9 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 
 		data &= 0x00ffffff;
 
-		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x61F400, data)) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0, 0x61F400, data)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, move_cmd)) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0, move_cmd)) != ERROR_OK)
 			return err;
 		b += 4;
 	}
diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
index ddd06dd..d19323e 100644
--- a/src/target/dsp563xx_once.c
+++ b/src/target/dsp563xx_once.c
@@ -43,72 +43,41 @@
 #define JTAG_INSTR_DEBUG_REQUEST	0x07
 #define JTAG_INSTR_BYPASS		0x0F
 
+/** */
 static inline int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out, int dr_len, int rti)
 {
-	if (NULL == tap)
-	{
-		LOG_ERROR("invalid tap");
-		return ERROR_FAIL;
-	}
-
 	jtag_add_plain_dr_scan(dr_len, dr_out, dr_in, TAP_IDLE);
 
 	return ERROR_OK;
 }
 
+/** */
 static inline int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t dr_out, int dr_len, int rti)
 {
-	if (dr_len > 8)
-	{
-		LOG_ERROR("dr_len overflow, maxium is 8");
-		return ERROR_FAIL;
-	}
-
 	return dsp563xx_write_dr(tap, dr_in, &dr_out, dr_len, rti);
 }
 
+/** */
 static inline int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out, int dr_len, int rti)
 {
-	if (dr_len > 32)
-	{
-		LOG_ERROR("dr_len overflow, maxium is 32");
-		return ERROR_FAIL;
-	}
-
 	return dsp563xx_write_dr(tap, (uint8_t *) dr_in, (uint8_t *) & dr_out, dr_len, rti);
 }
 
 /** single word instruction */
-static inline int dsp563xx_once_ir_exec(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
+static inline int dsp563xx_once_ir_exec(struct jtag_tap *tap, int flush, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
 {
 	int err;
 
 	if ((err = dsp563xx_write_dr_u8(tap, 0, instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0)) != ERROR_OK)
 		return err;
-
-	return jtag_execute_queue();
-}
-
-/** single word instruction */
-static inline int dsp563xx_once_ir_exec_nq(struct jtag_tap *tap, uint8_t instr, uint8_t rw, uint8_t go, uint8_t ex)
-{
-	return dsp563xx_write_dr_u8(tap, 0, instr | (ex << 5) | (go << 6) | (rw << 7), 8, 0);
+	if ( flush )
+		err = jtag_execute_queue();
+	return err;
 }
 
 /* IR and DR functions */
 static inline int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out, int ir_len, int rti)
 {
-	if (NULL == tap)
-	{
-		LOG_ERROR("invalid tap");
-		return ERROR_FAIL;
-	}
-	if (ir_len != tap->ir_length)
-	{
-		LOG_ERROR("invalid ir_len");
-		return ERROR_FAIL;
-	}
-
 	jtag_add_plain_ir_scan(tap->ir_length, ir_out, ir_in, TAP_IDLE);
 
 	return ERROR_OK;
@@ -116,12 +85,6 @@ static inline int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8
 
 static inline int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out, int ir_len, int rti)
 {
-	if (ir_len > 8)
-	{
-		LOG_ERROR("ir_len overflow, maxium is 8");
-		return ERROR_FAIL;
-	}
-
 	return dsp563xx_write_ir(tap, ir_in, &ir_out, ir_len, rti);
 }
 
@@ -222,132 +185,98 @@ int dsp563xx_once_request_debug(struct jtag_tap *tap, int reset_state)
 }
 
 /** once read registers */
-int dsp563xx_once_read_register(struct jtag_tap *tap, struct once_reg *regs, int len)
+int dsp563xx_once_read_register(struct jtag_tap *tap, int flush, struct once_reg *regs, int len)
 {
 	int i;
 	int err;
 
 	for (i = 0; i < len; i++)
 	{
-		if ((err = dsp563xx_once_reg_read_ex_nq(tap, regs[i].addr, regs[i].len, &regs[i].reg)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_read_ex(tap, flush, regs[i].addr, regs[i].len, &regs[i].reg)) != ERROR_OK)
 			return err;
 	}
 
-	return jtag_execute_queue();
-/*
-	for(i=0;i<len;i++)
-	{
-		printf("%08X\n",regs[i].reg);
-	}
-*/
-}
-
-/** once read register */
-int dsp563xx_once_reg_read_ex_nq(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data)
-{
-	int err;
-
-	if ((err = dsp563xx_once_ir_exec(tap, reg, 1, 0, 0)) != ERROR_OK)
-		return err;
-	return dsp563xx_write_dr_u32(tap, data, 0x00, len, 0);
+	if ( flush )
+		err = jtag_execute_queue();
+	return err;
 }
 
-/** once read register */
-int dsp563xx_once_reg_read_ex(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data)
+/** once read register with register len */
+int dsp563xx_once_reg_read_ex(struct jtag_tap *tap, int flush, uint8_t reg, uint8_t len, uint32_t * data)
 {
 	int err;
 
-	if ((err = dsp563xx_once_ir_exec(tap, reg, 1, 0, 0)) != ERROR_OK)
+	if ((err = dsp563xx_once_ir_exec(tap, 1, reg, 1, 0, 0)) != ERROR_OK)
 		return err;
 	if ((err = dsp563xx_write_dr_u32(tap, data, 0x00, len, 0)) != ERROR_OK)
 		return err;
-	return jtag_execute_queue();
+	if ( flush )
+		err = jtag_execute_queue();
+	return err;
 }
 
 /** once read register */
-int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data)
+int dsp563xx_once_reg_read(struct jtag_tap *tap, int flush, uint8_t reg, uint32_t * data)
 {
 	int err;
 
-	if ((err = dsp563xx_once_ir_exec(tap, reg, 1, 0, 0)) != ERROR_OK)
+	if ((err = dsp563xx_once_ir_exec(tap, flush, reg, 1, 0, 0)) != ERROR_OK)
 		return err;
 	if ((err = dsp563xx_write_dr_u32(tap, data, 0x00, 24, 0)) != ERROR_OK)
 		return err;
-	return jtag_execute_queue();
+	if ( flush )
+		err = jtag_execute_queue();
+	return err;
 }
 
 /** once write register */
-int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data)
+int dsp563xx_once_reg_write(struct jtag_tap *tap, int flush, uint8_t reg, uint32_t data)
 {
 	int err;
 
-	if ((err = dsp563xx_once_ir_exec(tap, reg, 0, 0, 0)) != ERROR_OK)
+	if ((err = dsp563xx_once_ir_exec(tap, flush, reg, 0, 0, 0)) != ERROR_OK)
 		return err;
 	if ((err = dsp563xx_write_dr_u32(tap, 0x00, data, 24, 0)) != ERROR_OK)
 		return err;
-	return jtag_execute_queue();
+	if ( flush )
+		err = jtag_execute_queue();
+	return err;
 }
 
 /** single word instruction */
-int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, uint32_t opcode)
+int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, int flush, uint32_t opcode)
 {
 	int err;
 
-	if ((err = dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
+	if ((err = dsp563xx_once_ir_exec(tap, flush, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
 		return err;
 	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
 		return err;
-	return jtag_execute_queue();
+	if ( flush )
+		err = jtag_execute_queue();
+	return err;
 }
 
 /** double word instruction */
-int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode, uint32_t operand)
-{
-	int err;
-
-	if ((err = dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0)) != ERROR_OK)
-		return err;
-	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
-		return err;
-	if ((err = jtag_execute_queue()) != ERROR_OK)
-		return err;
-
-	if ((err = dsp563xx_once_ir_exec(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
-		return err;
-	if ((err = dsp563xx_write_dr_u32(tap, 0, operand, 24, 0)) != ERROR_OK)
-		return err;
-	if ((err = jtag_execute_queue()) != ERROR_OK)
-		return err;
-
-	return ERROR_OK;
-}
-
-/** single word instruction */
-int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap, uint32_t opcode)
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, int flush, uint32_t opcode, uint32_t operand)
 {
 	int err;
 
-	if ((err = dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
+	if ((err = dsp563xx_once_ir_exec(tap, flush, DSP563XX_ONCE_OPDBR, 0, 0, 0)) != ERROR_OK)
 		return err;
 	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
 		return err;
+	if ( flush )
+		if ((err = jtag_execute_queue()) != ERROR_OK)
+			return err;
 
-	return ERROR_OK;
-}
-
-/** double word instruction */
-int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode, uint32_t operand)
-{
-	int err;
-
-	if ((err = dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 0, 0)) != ERROR_OK)
-		return err;
-	if ((err = dsp563xx_write_dr_u32(tap, 0, opcode, 24, 0)) != ERROR_OK)
-		return err;
-	if ((err = dsp563xx_once_ir_exec_nq(tap, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
+	if ((err = dsp563xx_once_ir_exec(tap, flush, DSP563XX_ONCE_OPDBR, 0, 1, 0)) != ERROR_OK)
 		return err;
 	if ((err = dsp563xx_write_dr_u32(tap, 0, operand, 24, 0)) != ERROR_OK)
 		return err;
+	if ( flush )
+		if ((err = jtag_execute_queue()) != ERROR_OK)
+			return err;
 
 	return ERROR_OK;
 }
diff --git a/src/target/dsp563xx_once.h b/src/target/dsp563xx_once.h
index 6b27694..1ba9c1e 100644
--- a/src/target/dsp563xx_once.h
+++ b/src/target/dsp563xx_once.h
@@ -72,22 +72,16 @@ int dsp563xx_once_request_debug(struct jtag_tap *tap, int reset_state);
 int dsp563xx_once_target_status(struct jtag_tap *tap);
 
 /** once read registers */
-int dsp563xx_once_read_register(struct jtag_tap *tap, struct once_reg *regs, int len);
+int dsp563xx_once_read_register(struct jtag_tap *tap, int flush, struct once_reg *regs, int len);
 /** once read register */
-int dsp563xx_once_reg_read_ex_nq(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data);
+int dsp563xx_once_reg_read_ex(struct jtag_tap *tap, int flush, uint8_t reg, uint8_t len, uint32_t * data);
 /** once read register */
-int dsp563xx_once_reg_read_ex(struct jtag_tap *tap, uint8_t reg, uint8_t len, uint32_t * data);
-/** once read register */
-int dsp563xx_once_reg_read(struct jtag_tap *tap, uint8_t reg, uint32_t * data);
+int dsp563xx_once_reg_read(struct jtag_tap *tap, int flush, uint8_t reg, uint32_t * data);
 /** once write register */
-int dsp563xx_once_reg_write(struct jtag_tap *tap, uint8_t reg, uint32_t data);
-/** single word instruction */
-int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, uint32_t opcode);
-/** double word instruction */
-int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, uint32_t opcode, uint32_t operand);
+int dsp563xx_once_reg_write(struct jtag_tap *tap, int flush, uint8_t reg, uint32_t data);
 /** single word instruction */
-int dsp563xx_once_execute_sw_ir_nq(struct jtag_tap *tap, uint32_t opcode);
+int dsp563xx_once_execute_sw_ir(struct jtag_tap *tap, int flush, uint32_t opcode);
 /** double word instruction */
-int dsp563xx_once_execute_dw_ir_nq(struct jtag_tap *tap, uint32_t opcode, uint32_t operand);
+int dsp563xx_once_execute_dw_ir(struct jtag_tap *tap, int flush, uint32_t opcode, uint32_t operand);
 
 #endif /* DSP563XX_ONCE_H */

commit aa9baf11a8080cab47f19905a0e7697a1128724e
Author: Mathias K <kesmtp at freenet.de>
Date:   Tue Feb 15 16:59:23 2011 +0100

    - add bulk memory write function - execute jtag queue at the end of the memory transfer

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 4371d0a..10365df 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -29,8 +29,6 @@
 #include "dsp563xx.h"
 #include "dsp563xx_once.h"
 
-//#define DSP563XX_JTAG_INS_LEN         4
-
 #define ASM_REG_W_R0	0x60F400
 #define ASM_REG_W_R1	0x61F400
 #define ASM_REG_W_R2	0x62F400
@@ -1138,9 +1136,16 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	/* we only support 4 byte aligned data */
+	if ( size != 4 )
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
 	switch (mem_type)
 	{
 		case MEM_X:
+			/* TODO: mark effected queued registers */
 			move_cmd = 0x61d800;
 			break;
 		case MEM_Y:
@@ -1173,17 +1178,30 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 
 	for (i = 0; i < x; i++)
 	{
-		data = 0;
 		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, move_cmd)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_execute_sw_ir(target->tap, 0x08D13C)) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, 0x08D13C)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_reg_read(target->tap, DSP563XX_ONCE_OGDBR, &data)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_read_nq(target->tap, DSP563XX_ONCE_OGDBR, (uint32_t*)b)) != ERROR_OK)
 			return err;
-		target_buffer_set_u32(target, b, data);
 		b += 4;
+	}
 
-		LOG_DEBUG("R: %08X", data);
+	/* flush the jtag queue */
+	if ((err = jtag_execute_queue()) != ERROR_OK)
+	{
+		return err;
+	}
+
+	/* walk over the buffer and fix target endianness */
+	b = buffer;
+
+	for (i = 0; i < x; i++)
+	{
+		data = *((uint32_t*)b) & 0x00FFFFFF;
+//		LOG_DEBUG("R: %08X", *((uint32_t*)b));
+		target_buffer_set_u32(target, b, data);
+		b += 4;
 	}
 
 	return ERROR_OK;
@@ -1210,6 +1228,12 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	/* we only support 4 byte aligned data */
+	if ( size != 4 )
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
 	switch (mem_type)
 	{
 		case MEM_X:
@@ -1246,18 +1270,24 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	for (i = 0; i < x; i++)
 	{
 		data = target_buffer_get_u32(target, b);
-		data &= 0x00ffffff;
 
-		LOG_DEBUG("W: %08X", data);
+//		LOG_DEBUG("W: %08X", data);
+
+		data &= 0x00ffffff;
 
 		if ((err = dsp563xx_once_execute_dw_ir_nq(target->tap, 0x61F400, data)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_once_execute_sw_ir(target->tap, move_cmd)) != ERROR_OK)
+		if ((err = dsp563xx_once_execute_sw_ir_nq(target->tap, move_cmd)) != ERROR_OK)
 			return err;
-
 		b += 4;
 	}
 
+	/* flush the jtag queue */
+	if ((err = jtag_execute_queue()) != ERROR_OK)
+	{
+		return err;
+	}
+
 	return ERROR_OK;
 }
 
@@ -1266,6 +1296,11 @@ static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint
 	return dsp563xx_write_memory(target, MEM_P, address, size, count, buffer);
 }
 
+static int dsp563xx_bulk_write_memory_p(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+{
+	return dsp563xx_write_memory(target, MEM_P, address, 4, count, buffer);
+}
+
 static void handle_md_output(struct command_context *cmd_ctx, struct target *target, uint32_t address, unsigned size, unsigned count, const uint8_t * buffer)
 {
 	const unsigned line_bytecnt = 32;
@@ -1485,6 +1520,7 @@ struct target_type dsp563xx_target = {
 
 	.read_memory = dsp563xx_read_memory_p,
 	.write_memory = dsp563xx_write_memory_p,
+	.bulk_write_memory = dsp563xx_bulk_write_memory_p,
 
 	.commands = dsp563xx_command_handlers,
 	.target_create = dsp563xx_target_create,

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c      |  136 ++++++++++++++++++++++++--------------
 src/target/dsp563xx_once.c |  155 ++++++++++++--------------------------------
 src/target/dsp563xx_once.h |   18 ++----
 3 files changed, 134 insertions(+), 175 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb 15 20:23:51 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Feb 2011 19:23:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-757-g3f4b9e3
Message-ID: <mailman.5.1331736152.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3f4b9e334b867a16c35b1c6d9a1f9aefd35fd91b (commit)
      from  fe0894015fd3d25593ce3a7211b1540ebfbab1f3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3f4b9e334b867a16c35b1c6d9a1f9aefd35fd91b
Author: Bjarne Steinsbo <bsteinsbo at gmail.com>
Date:   Tue Feb 15 20:23:40 2011 +0100

    lpc32xx: Flash driver
    
    Based on the lpc3180 driver, but released as a separate driver for two reasons:
     1) I don't have an lpc3180 to test it against, so it might unintentionally break compatibility.
     2) It's using a different OOB layout than lpc3180.
    
    Rewritten so that it no longer borrows code from the NXP CDL library.  Instead borrowing code from the u-boot port to lpc32xx, written by Kevin Wells.
    
    Tested on lpc3250 (Hitex LPC3250-Stick).  OOB layout is compatible with LPCLinux.

diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 9aa0e69..23c303b 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -16,6 +16,7 @@ NAND_DRIVERS = \
 	nonce.c \
 	davinci.c \
 	lpc3180.c \
+	lpc32xx.c \
 	mx2.c \
 	mx3.c \
 	orion.c \
@@ -35,6 +36,7 @@ noinst_HEADERS = \
 	fileio.h \
 	imp.h \
 	lpc3180.h \
+	lpc32xx.h \
 	mx2.h \
 	mx3.h \
 	s3c24xx.h \
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
index 522dfa4..f34811b 100644
--- a/src/flash/nand/driver.c
+++ b/src/flash/nand/driver.c
@@ -31,6 +31,7 @@
 extern struct nand_flash_controller nonce_nand_controller;
 extern struct nand_flash_controller davinci_nand_controller;
 extern struct nand_flash_controller lpc3180_nand_controller;
+extern struct nand_flash_controller lpc32xx_nand_controller;
 extern struct nand_flash_controller orion_nand_controller;
 extern struct nand_flash_controller s3c2410_nand_controller;
 extern struct nand_flash_controller s3c2412_nand_controller;
@@ -49,6 +50,7 @@ static struct nand_flash_controller *nand_flash_controllers[] =
 	&nonce_nand_controller,
 	&davinci_nand_controller,
 	&lpc3180_nand_controller,
+	&lpc32xx_nand_controller,
 	&orion_nand_controller,
 	&s3c2410_nand_controller,
 	&s3c2412_nand_controller,
diff --git a/src/flash/nand/ecc.c b/src/flash/nand/ecc.c
index 2de12d4..b403997 100644
--- a/src/flash/nand/ecc.c
+++ b/src/flash/nand/ecc.c
@@ -120,3 +120,64 @@ int nand_calculate_ecc(struct nand_device *nand, const uint8_t *dat, uint8_t *ec
 
 	return 0;
 }
+
+static inline int countbits(uint32_t byte)
+{
+	int res = 0;
+
+	for (;byte; byte >>= 1)
+		res += byte & 0x01;
+	return res;
+}
+
+/**
+ * nand_correct_data - Detect and correct a 1 bit error for 256 byte block
+ */
+int nand_correct_data(struct nand_device *nand, u_char *dat,
+		      u_char *read_ecc, u_char *calc_ecc)
+{
+	uint8_t s0, s1, s2;
+
+#ifdef NAND_ECC_SMC
+	s0 = calc_ecc[0] ^ read_ecc[0];
+	s1 = calc_ecc[1] ^ read_ecc[1];
+	s2 = calc_ecc[2] ^ read_ecc[2];
+#else
+	s1 = calc_ecc[0] ^ read_ecc[0];
+	s0 = calc_ecc[1] ^ read_ecc[1];
+	s2 = calc_ecc[2] ^ read_ecc[2];
+#endif
+	if ((s0 | s1 | s2) == 0)
+		return 0;
+
+	/* Check for a single bit error */
+	if( ((s0 ^ (s0 >> 1)) & 0x55) == 0x55 &&
+	    ((s1 ^ (s1 >> 1)) & 0x55) == 0x55 &&
+	    ((s2 ^ (s2 >> 1)) & 0x54) == 0x54) {
+
+		uint32_t byteoffs, bitnum;
+
+		byteoffs = (s1 << 0) & 0x80;
+		byteoffs |= (s1 << 1) & 0x40;
+		byteoffs |= (s1 << 2) & 0x20;
+		byteoffs |= (s1 << 3) & 0x10;
+
+		byteoffs |= (s0 >> 4) & 0x08;
+		byteoffs |= (s0 >> 3) & 0x04;
+		byteoffs |= (s0 >> 2) & 0x02;
+		byteoffs |= (s0 >> 1) & 0x01;
+
+		bitnum = (s2 >> 5) & 0x04;
+		bitnum |= (s2 >> 4) & 0x02;
+		bitnum |= (s2 >> 3) & 0x01;
+
+		dat[byteoffs] ^= (1 << bitnum);
+
+		return 1;
+	}
+
+	if(countbits(s0 | ((uint32_t)s1 << 8) | ((uint32_t)s2 <<16)) == 1)
+		return 1;
+
+	return -1;
+}
diff --git a/src/flash/nand/lpc32xx.c b/src/flash/nand/lpc32xx.c
new file mode 100644
index 0000000..5cde90c
--- /dev/null
+++ b/src/flash/nand/lpc32xx.c
@@ -0,0 +1,1828 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   Copyright (C) 2011 Bjarne Steinsbo <bsteinsbo at gmail.com>              *
+ *   Copyright (C) 2010 richard vegh <vegh.ricsi at gmail.com>                *
+ *   Copyright (C) 2010 Oyvind Harboe <oyvind.harboe at zylin.com>            *
+ *                                                                         *
+ *   Based on a combination of the lpc3180 driver and code from            *
+ *   uboot-2009.03-lpc32xx by Kevin Wells.                                 *
+ *   Any bugs are mine. --BSt                                              *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include "lpc32xx.h"
+#include <target/target.h>
+
+static int lpc32xx_reset(struct nand_device *nand);
+static int lpc32xx_controller_ready(struct nand_device *nand, int timeout);
+static int lpc32xx_tc_ready(struct nand_device *nand, int timeout);
+extern int nand_correct_data(struct nand_device *nand, u_char *dat,
+			     u_char *read_ecc, u_char *calc_ecc);
+
+/* These are offset with the working area in IRAM when using DMA to
+ * read/write data to the SLC controller.
+ * - DMA descriptors will be put at start of working area,
+ * - Hardware generated ECC will be stored at ECC_OFFS
+ * - OOB wil be read/written from/to SPARE_OFFS
+ * - Actual page data will be read from/to DATA_OFFS
+ * There are unused holes between the used areas.
+ */
+#define ECC_OFFS   0x120
+#define SPARE_OFFS 0x140
+#define DATA_OFFS  0x200
+
+static int sp_ooblayout[] = {
+	10, 11, 12, 13, 14, 15
+};
+static int lp_ooblayout[] = {
+	40, 41, 42, 43, 44, 45,
+	46, 47, 48, 49, 50, 51,
+	52, 53, 54, 55, 56, 57,
+	58, 59, 60, 61, 62, 63
+};
+
+typedef struct {
+	volatile uint32_t dma_src;
+	volatile uint32_t dma_dest;
+	volatile uint32_t next_lli;
+	volatile uint32_t next_ctrl;
+} dmac_ll_t;
+
+static dmac_ll_t dmalist[(2048/256) * 2 + 1];
+
+/* nand device lpc32xx <target#> <oscillator_frequency>
+ */
+NAND_DEVICE_COMMAND_HANDLER(lpc32xx_nand_device_command)
+{
+	if (CMD_ARGC < 3) {
+		LOG_WARNING("incomplete 'lpc32xx' nand flash configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	uint32_t osc_freq;
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], osc_freq);
+
+	struct lpc32xx_nand_controller *lpc32xx_info;
+	lpc32xx_info = malloc(sizeof(struct lpc32xx_nand_controller));
+	nand->controller_priv = lpc32xx_info;
+
+	lpc32xx_info->osc_freq = osc_freq;
+
+	if ((lpc32xx_info->osc_freq < 1000) || (lpc32xx_info->osc_freq > 20000))
+		LOG_WARNING("LPC32xx oscillator frequency should be between "
+			    "1000 and 20000 kHz, was %i",
+			    lpc32xx_info->osc_freq);
+
+	lpc32xx_info->selected_controller = LPC32xx_NO_CONTROLLER;
+	lpc32xx_info->sw_write_protection = 0;
+	lpc32xx_info->sw_wp_lower_bound = 0x0;
+	lpc32xx_info->sw_wp_upper_bound = 0x0;
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_pll(int fclkin, uint32_t pll_ctrl)
+{
+	int bypass = (pll_ctrl & 0x8000) >> 15;
+	int direct = (pll_ctrl & 0x4000) >> 14;
+	int feedback = (pll_ctrl & 0x2000) >> 13;
+	int p = (1 << ((pll_ctrl & 0x1800) >> 11) * 2);
+	int n = ((pll_ctrl & 0x0600) >> 9) + 1;
+	int m = ((pll_ctrl & 0x01fe) >> 1) + 1;
+	int lock = (pll_ctrl & 0x1);
+
+	if (!lock)
+		LOG_WARNING("PLL is not locked");
+
+	if (!bypass && direct) /* direct mode */
+		return (m * fclkin) / n;
+
+	if (bypass && !direct) /* bypass mode */
+		return fclkin / (2 * p);
+
+	if (bypass & direct) /* direct bypass mode */
+		return fclkin;
+
+	if (feedback) /* integer mode */
+		return m * (fclkin / n);
+	else /* non-integer mode */
+		return (m / (2 * p)) * (fclkin / n);
+}
+
+static float lpc32xx_cycle_time(struct nand_device *nand)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	uint32_t sysclk_ctrl, pwr_ctrl, hclkdiv_ctrl, hclkpll_ctrl;
+	int sysclk;
+	int hclk;
+	int hclk_pll;
+	float cycle;
+	int retval;
+
+	/* calculate timings */
+
+	/* determine current SYSCLK (13'MHz or main oscillator) */
+	retval = target_read_u32(target, 0x40004050, &sysclk_ctrl);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("could not read SYSCLK_CTRL");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if ((sysclk_ctrl & 1) == 0)
+		sysclk = lpc32xx_info->osc_freq;
+	else
+		sysclk = 13000;
+
+	/* determine selected HCLK source */
+	retval = target_read_u32(target, 0x40004044, &pwr_ctrl);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("could not read HCLK_CTRL");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if ((pwr_ctrl & (1 << 2)) == 0) { /* DIRECT RUN mode */
+		hclk = sysclk;
+	} else {
+		retval = target_read_u32(target, 0x40004058, &hclkpll_ctrl);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not read HCLKPLL_CTRL");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		hclk_pll = lpc32xx_pll(sysclk, hclkpll_ctrl);
+
+		retval = target_read_u32(target, 0x40004040, &hclkdiv_ctrl);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not read CLKDIV_CTRL");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (pwr_ctrl & (1 << 10)) /* ARM_CLK and HCLK use PERIPH_CLK */
+			hclk = hclk_pll / (((hclkdiv_ctrl & 0x7c) >> 2) + 1);
+		else /* HCLK uses HCLK_PLL */
+			hclk = hclk_pll / (1 << (hclkdiv_ctrl & 0x3));
+	}
+
+	LOG_DEBUG("LPC32xx HCLK currently clocked at %i kHz", hclk);
+
+	cycle = (1.0 / hclk) * 1000000.0;
+
+	return cycle;
+}
+
+static int lpc32xx_init(struct nand_device *nand)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int bus_width = nand->bus_width ? : 8;
+	int address_cycles = nand->address_cycles ? : 3;
+	int page_size = nand->page_size ? : 512;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use LPC32xx "
+			  "NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	/* sanitize arguments */
+	if (bus_width != 8) {
+		LOG_ERROR("LPC32xx doesn't support %i", bus_width);
+		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+	}
+
+	/* inform calling code about selected bus width */
+	nand->bus_width = bus_width;
+
+	if ((address_cycles != 3) && (address_cycles != 4)) {
+		LOG_ERROR("LPC32xx driver doesn't support %i", address_cycles);
+		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+	}
+
+	if ((page_size != 512) && (page_size != 2048)) {
+		LOG_ERROR("LPC32xx doesn't support page size %i", page_size);
+		return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+	}
+
+	/* select MLC controller if none is currently selected */
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_DEBUG("no LPC32xx NAND flash controller selected, "
+			  "using default 'mlc'");
+		lpc32xx_info->selected_controller = LPC32xx_MLC_CONTROLLER;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		uint32_t mlc_icr_value = 0x0;
+		float cycle;
+		int twp, twh, trp, treh, trhz, trbwb, tcea;
+
+		/* FLASHCLK_CTRL = 0x22 (enable clk for MLC) */
+		retval = target_write_u32(target, 0x400040c8, 0x22);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set FLASHCLK_CTRL");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_CEH = 0x0 (Force nCE assert) */
+		retval = target_write_u32(target, 0x200b804c, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_CEH");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_LOCK = 0xa25e (unlock protected registers) */
+		retval = target_write_u32(target, 0x200b8044, 0xa25e);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_LOCK");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_ICR = configuration */
+		if (lpc32xx_info->sw_write_protection)
+			mlc_icr_value |= 0x8;
+		if (page_size == 2048)
+			mlc_icr_value |= 0x4;
+		if (address_cycles == 4)
+			mlc_icr_value |= 0x2;
+		if (bus_width == 16)
+			mlc_icr_value |= 0x1;
+		retval = target_write_u32(target, 0x200b8030, mlc_icr_value);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ICR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* calculate NAND controller timings */
+		cycle = lpc32xx_cycle_time(nand);
+
+		twp = ((40 / cycle) + 1);
+		twh = ((20 / cycle) + 1);
+		trp = ((30 / cycle) + 1);
+		treh = ((15 / cycle) + 1);
+		trhz = ((30 / cycle) + 1);
+		trbwb = ((100 / cycle) + 1);
+		tcea = ((45 / cycle) + 1);
+
+		/* MLC_LOCK = 0xa25e (unlock protected registers) */
+		retval = target_write_u32(target, 0x200b8044, 0xa25e);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_LOCK");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_TIME_REG */
+		retval = target_write_u32(target, 0x200b8034,
+					  (twp & 0xf)
+					  | ((twh & 0xf) << 4)
+					  | ((trp & 0xf) << 8)
+					  | ((treh & 0xf) << 12)
+					  | ((trhz & 0x7) << 16)
+					  | ((trbwb & 0x1f) << 19)
+					  | ((tcea & 0x3) << 24));
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_TIME_REG");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		retval = lpc32xx_reset(nand);
+		if (ERROR_OK != retval)
+			return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		float cycle;
+		int r_setup, r_hold, r_width, r_rdy;
+		int w_setup, w_hold, w_width, w_rdy;
+
+		/* FLASHCLK_CTRL = 0x05 (enable clk for SLC) */
+		retval = target_write_u32(target, 0x400040c8, 0x05);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set FLASHCLK_CTRL");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* after reset set other registers of SLC,
+		 * so reset calling is here at the begining
+		 */
+		retval = lpc32xx_reset(nand);
+		if (ERROR_OK != retval)
+			return ERROR_NAND_OPERATION_FAILED;
+
+		/* SLC_CFG =
+			Force nCE assert,
+			DMA ECC enabled,
+			ECC enabled,
+			DMA burst enabled,
+			DMA read from SLC,
+			WIDTH = bus_width)
+		*/
+		retval = target_write_u32(target, 0x20020014,
+					  0x3e | (bus_width == 16) ? 1 : 0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set SLC_CFG");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* SLC_IEN = 3 (INT_RDY_EN = 1) ,(INT_TC_STAT = 1) */
+		retval = target_write_u32(target, 0x20020020, 0x03);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set SLC_IEN");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* DMA configuration */
+
+		/* DMACLK_CTRL = 0x01 (enable clock for DMA controller) */
+		retval = target_write_u32(target, 0x400040e8, 0x01);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set DMACLK_CTRL");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* DMACConfig = DMA enabled*/
+		retval = target_write_u32(target, 0x31000030, 0x01);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set DMACConfig");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* calculate NAND controller timings */
+		cycle = lpc32xx_cycle_time(nand);
+
+		r_setup = w_setup = 0;
+		r_hold = w_hold = 10 / cycle;
+		r_width = 30 / cycle;
+		w_width = 40 / cycle;
+		r_rdy = w_rdy = 100 / cycle;
+
+		/* SLC_TAC: SLC timing arcs register */
+		retval = target_write_u32(target, 0x2002002c,
+					  (r_setup & 0xf)
+					  | ((r_hold & 0xf) << 4)
+					  | ((r_width & 0xf) << 8)
+					  | ((r_rdy & 0xf) << 12)
+					  | ((w_setup & 0xf) << 16)
+					  | ((w_hold & 0xf) << 20)
+					  | ((w_width & 0xf) << 24)
+					  | ((w_rdy & 0xf) << 28));
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set SLC_TAC");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_reset(struct nand_device *nand)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use "
+			  "LPC32xx NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_ERROR("BUG: no LPC32xx NAND flash controller selected");
+		return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		/* MLC_CMD = 0xff (reset controller and NAND device) */
+		retval = target_write_u32(target, 0x200b8000, 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_CMD");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (!lpc32xx_controller_ready(nand, 100)) {
+			LOG_ERROR("LPC32xx MLC NAND controller timed out "
+				  "after reset");
+			return ERROR_NAND_OPERATION_TIMEOUT;
+		}
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		/* SLC_CTRL = 0x6 (ECC_CLEAR, SW_RESET) */
+		retval = target_write_u32(target, 0x20020010, 0x6);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set SLC_CTRL");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (!lpc32xx_controller_ready(nand, 100))
+		{
+			LOG_ERROR("LPC32xx SLC NAND controller timed out "
+				  "after reset");
+			return ERROR_NAND_OPERATION_TIMEOUT;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_command(struct nand_device *nand, uint8_t command)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use "
+			  "LPC32xx NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_ERROR("BUG: no LPC32xx NAND flash controller selected");
+		return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		/* MLC_CMD = command */
+		retval = target_write_u32(target, 0x200b8000, command);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_CMD");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		/* SLC_CMD = command */
+		retval = target_write_u32(target, 0x20020008, command);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set SLC_CMD");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_address(struct nand_device *nand, uint8_t address)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use "
+			  "LPC32xx NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_ERROR("BUG: no LPC32xx NAND flash controller selected");
+		return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		/* MLC_ADDR = address */
+		retval = target_write_u32(target, 0x200b8004, address);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		/* SLC_ADDR = address */
+		retval = target_write_u32(target, 0x20020004, address);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set SLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_write_data(struct nand_device *nand, uint16_t data)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use "
+			  "LPC32xx NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_ERROR("BUG: no LPC32xx NAND flash controller selected");
+		return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		/* MLC_DATA = data */
+		retval = target_write_u32(target, 0x200b0000, data);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_DATA");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		/* SLC_DATA = data */
+		retval = target_write_u32(target, 0x20020000, data);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set SLC_DATA");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_read_data(struct nand_device *nand, void *data)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use LPC32xx "
+			  "NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_ERROR("BUG: no LPC32xx NAND flash controller selected");
+		return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		/* data = MLC_DATA, use sized access */
+		if (nand->bus_width == 8) {
+			uint8_t *data8 = data;
+			retval = target_read_u8(target, 0x200b0000, data8);
+		} else {
+			LOG_ERROR("BUG: bus_width neither 8 nor 16 bit");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not read MLC_DATA");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		uint32_t data32;
+
+		/* data = SLC_DATA, must use 32-bit access */
+		retval = target_read_u32(target, 0x20020000, &data32);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not read SLC_DATA");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (nand->bus_width == 8) {
+			uint8_t *data8 = data;
+			*data8 = data32 & 0xff;
+		} else {
+			LOG_ERROR("BUG: bus_width neither 8 nor 16 bit");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_write_page_mlc(struct nand_device *nand, uint32_t page,
+				  uint8_t *data, uint32_t data_size,
+				  uint8_t *oob, uint32_t oob_size)
+{
+	struct target *target = nand->target;
+	int retval;
+	uint8_t status;
+	static uint8_t page_buffer[512];
+	static uint8_t oob_buffer[6];
+	int quarter, num_quarters;
+
+	/* MLC_CMD = sequential input */
+	retval = target_write_u32(target, 0x200b8000, NAND_CMD_SEQIN);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("could not set MLC_CMD");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (nand->page_size == 512) {
+		/* MLC_ADDR = 0x0 (one column cycle) */
+		retval = target_write_u32(target, 0x200b8004, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_ADDR = row */
+		retval = target_write_u32(target, 0x200b8004, page & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		retval = target_write_u32(target, 0x200b8004,
+					  (page >> 8) & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (nand->address_cycles == 4) {
+			retval = target_write_u32(target, 0x200b8004,
+						  (page >> 16) & 0xff);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not set MLC_ADDR");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+		}
+	} else {
+		/* MLC_ADDR = 0x0 (two column cycles) */
+		retval = target_write_u32(target, 0x200b8004, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		retval = target_write_u32(target, 0x200b8004, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_ADDR = row */
+		retval = target_write_u32(target, 0x200b8004, page & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		retval = target_write_u32(target, 0x200b8004,
+					  (page >> 8) & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	/* when using the MLC controller, we have to treat a large page device
+	 * as being made out of four quarters, each the size of a small page
+	 * device
+	 */
+	num_quarters = (nand->page_size == 2048) ? 4 : 1;
+
+	for (quarter = 0; quarter < num_quarters; quarter++) {
+		int thisrun_data_size = (data_size > 512) ? 512 : data_size;
+		int thisrun_oob_size = (oob_size > 6) ? 6 : oob_size;
+
+		memset(page_buffer, 0xff, 512);
+		if (data) {
+			memcpy(page_buffer, data, thisrun_data_size);
+			data_size -= thisrun_data_size;
+			data += thisrun_data_size;
+		}
+
+		memset(oob_buffer, 0xff, 6);
+		if (oob) {
+			memcpy(oob_buffer, oob, thisrun_oob_size);
+			oob_size -= thisrun_oob_size;
+			oob += thisrun_oob_size;
+		}
+
+		/* write MLC_ECC_ENC_REG to start encode cycle */
+		retval = target_write_u32(target, 0x200b8008, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ECC_ENC_REG");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		retval = target_write_memory(target, 0x200a8000,
+				4, 128, page_buffer);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_BUF (data)");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		retval = target_write_memory(target, 0x200a8000,
+				1, 6, oob_buffer);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_BUF (oob)");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* write MLC_ECC_AUTO_ENC_REG to start auto encode */
+		retval = target_write_u32(target, 0x200b8010, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ECC_AUTO_ENC_REG");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (!lpc32xx_controller_ready(nand, 1000)) {
+			LOG_ERROR("timeout while waiting for "
+				  "completion of auto encode cycle");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	/* MLC_CMD = auto program command */
+	retval = target_write_u32(target, 0x200b8000, NAND_CMD_PAGEPROG);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("could not set MLC_CMD");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if ((retval = nand_read_status(nand, &status)) != ERROR_OK) {
+		LOG_ERROR("couldn't read status");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (status & NAND_STATUS_FAIL) {
+		LOG_ERROR("write operation didn't pass, status: 0x%2.2x",
+			  status);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+/* SLC controller in !raw mode will use target cpu to read/write nand from/to
+ * target internal memory.  The transfer to/from flash is done by DMA.  This
+ * function sets up the dma linked list in host memory for later transfer to
+ * target.
+ */
+static int lpc32xx_make_dma_list(uint32_t target_mem_base, uint32_t page_size,
+				 int do_read)
+{
+	uint32_t i, dmasrc, ctrl, ecc_ctrl, oob_ctrl, dmadst;
+
+	/* DMACCxControl =
+		TransferSize =64,
+		Source burst size =16,
+		Destination burst size = 16,
+		Source transfer width = 32 bit,
+		Destination transfer width = 32 bit,
+		Source AHB master select = M0,
+		Destination AHB master select = M0,
+		Source increment = 0, // set later
+		Destination increment = 0, // set later
+		Terminal count interrupt enable bit = 0 // set on last
+	*/			/*
+	 * Write Operation Sequence for Small Block NAND
+	 * ----------------------------------------------------------
+	 * 1. X'fer 256 bytes of data from Memory to Flash.
+	 * 2. Copy generated ECC data from Register to Spare Area
+	 * 3. X'fer next 256 bytes of data from Memory to Flash.
+	 * 4. Copy generated ECC data from Register to Spare Area.
+	 * 5. X'fer 16 byets of Spare area from Memory to Flash.
+	 * Read Operation Sequence for Small Block NAND
+	 * ----------------------------------------------------------
+	 * 1. X'fer 256 bytes of data from Flash to Memory.
+	 * 2. Copy generated ECC data from Register to ECC calc Buffer.
+	 * 3. X'fer next 256 bytes of data from Flash to Memory.
+	 * 4. Copy generated ECC data from Register to ECC calc Buffer.
+	 * 5. X'fer 16 bytes of Spare area from Flash to Memory.
+	 * Write Operation Sequence for Large Block NAND
+	 * ----------------------------------------------------------
+	 * 1. Steps(1-4) of Write Operations repeate for four times
+	 * which generates 16 DMA descriptors to X'fer 2048 bytes of
+	 * data & 32 bytes of ECC data.
+	 * 2. X'fer 64 bytes of Spare area from Memory to Flash.
+	 * Read Operation Sequence for Large Block NAND
+	 * ----------------------------------------------------------
+	 * 1. Steps(1-4) of Read Operations repeate for four times
+	 * which generates 16 DMA descriptors to X'fer 2048 bytes of
+	 * data & 32 bytes of ECC data.
+	 * 2. X'fer 64 bytes of Spare area from Flash to Memory.
+	 */
+
+	ctrl = (0x40 | 3 << 12 | 3 << 15 | 2 << 18 | 2 << 21 | 0 << 24
+	        | 0 << 25 | 0 << 26 | 0 << 27 | 0 << 31);
+
+	/* DMACCxControl =
+		TransferSize =1,
+		Source burst size =4,
+		Destination burst size = 4,
+		Source transfer width = 32 bit,
+		Destination transfer width = 32 bit,
+		Source AHB master select = M0,
+		Destination AHB master select = M0,
+		Source increment = 0,
+		Destination increment = 1,
+		Terminal count interrupt enable bit = 0
+	 */
+	ecc_ctrl = 0x01 | 1 << 12 | 1 << 15 | 2 << 18 | 2 << 21 | 0 << 24
+		   | 0 << 25 | 0 << 26 | 1 << 27 | 0 << 31;
+
+	/* DMACCxControl =
+		TransferSize =16 for lp or 4 for sp,
+		Source burst size =16,
+		Destination burst size = 16,
+		Source transfer width = 32 bit,
+		Destination transfer width = 32 bit,
+		Source AHB master select = M0,
+		Destination AHB master select = M0,
+		Source increment = 0, // set later
+		Destination increment = 0, // set later
+		Terminal count interrupt enable bit = 1 // set on last
+	 */
+	oob_ctrl = (page_size == 2048 ? 0x10 : 0x04)
+		   | 3 << 12 | 3 << 15 | 2 << 18 | 2 << 21 | 0 << 24
+		   | 0 << 25 | 0 << 26 | 0 << 27 | 1 << 31;
+	if (do_read) {
+		ctrl |= 1 << 27; /* Destination increment = 1 */
+		oob_ctrl |= 1 << 27; /* Destination increment = 1 */
+		dmasrc = 0x20020038; /* SLC_DMA_DATA */
+		dmadst = target_mem_base + DATA_OFFS;
+	} else {
+		ctrl |= 1 << 26; /* Source increment = 1 */
+		oob_ctrl |= 1 << 26; /* Source increment = 1 */
+		dmasrc = target_mem_base + DATA_OFFS;
+		dmadst = 0x20020038; /* SLC_DMA_DATA */
+	}
+	/*
+	 * Write Operation Sequence for Small Block NAND
+	 * ----------------------------------------------------------
+	 * 1. X'fer 256 bytes of data from Memory to Flash.
+	 * 2. Copy generated ECC data from Register to Spare Area
+	 * 3. X'fer next 256 bytes of data from Memory to Flash.
+	 * 4. Copy generated ECC data from Register to Spare Area.
+	 * 5. X'fer 16 byets of Spare area from Memory to Flash.
+	 * Read Operation Sequence for Small Block NAND
+	 * ----------------------------------------------------------
+	 * 1. X'fer 256 bytes of data from Flash to Memory.
+	 * 2. Copy generated ECC data from Register to ECC calc Buffer.
+	 * 3. X'fer next 256 bytes of data from Flash to Memory.
+	 * 4. Copy generated ECC data from Register to ECC calc Buffer.
+	 * 5. X'fer 16 bytes of Spare area from Flash to Memory.
+	 * Write Operation Sequence for Large Block NAND
+	 * ----------------------------------------------------------
+	 * 1. Steps(1-4) of Write Operations repeate for four times
+	 * which generates 16 DMA descriptors to X'fer 2048 bytes of
+	 * data & 32 bytes of ECC data.
+	 * 2. X'fer 64 bytes of Spare area from Memory to Flash.
+	 * Read Operation Sequence for Large Block NAND
+	 * ----------------------------------------------------------
+	 * 1. Steps(1-4) of Read Operations repeate for four times
+	 * which generates 16 DMA descriptors to X'fer 2048 bytes of
+	 * data & 32 bytes of ECC data.
+	 * 2. X'fer 64 bytes of Spare area from Flash to Memory.
+	 */
+	for (i = 0; i < page_size/0x100; i++)
+	{
+		dmalist[i*2].dma_src = (do_read ? dmasrc : (dmasrc + i * 256));
+		dmalist[i*2].dma_dest = (do_read ? (dmadst + i * 256) : dmadst);
+		dmalist[i*2].next_lli =
+			target_mem_base + (i*2 + 1) * sizeof(dmac_ll_t);
+		dmalist[i*2].next_ctrl = ctrl;
+
+		dmalist[(i*2) + 1].dma_src = 0x20020034; /* SLC_ECC */
+		dmalist[(i*2) + 1].dma_dest =
+			target_mem_base + ECC_OFFS + i * 4;
+		dmalist[(i*2) + 1].next_lli =
+			 target_mem_base + (i*2 + 2) * sizeof(dmac_ll_t);
+		dmalist[(i*2) + 1].next_ctrl = ecc_ctrl;
+
+	}
+	if (do_read)
+	{
+		dmadst = target_mem_base + SPARE_OFFS;
+	} else {
+		dmasrc = target_mem_base + SPARE_OFFS;
+		dmalist[(i*2) - 1].next_lli = 0; /* last link = null on write */
+		dmalist[(i*2) - 1].next_ctrl |= (1 << 31); /* Set TC enable */
+	}
+	dmalist[i*2].dma_src = dmasrc;
+	dmalist[i*2].dma_dest = dmadst;
+	dmalist[i*2].next_lli = 0;
+	dmalist[i*2].next_ctrl = oob_ctrl;
+
+	return (i*2 + 1); /* Number of descriptors */
+}
+
+static int lpc32xx_start_slc_dma(struct nand_device *nand, uint32_t count,
+				 int do_wait)
+{
+	struct target *target = nand->target;
+	int retval;
+
+	/* DMACIntTCClear = ch0 */
+	retval = target_write_u32(target, 0x31000008, 1);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not set DMACIntTCClear");
+		return retval;
+	}
+	
+	/* DMACIntErrClear = ch0 */
+	retval = target_write_u32(target, 0x31000010, 1);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not set DMACIntErrClear");
+		return retval;
+	}
+	
+	/* DMACCxConfig=
+		E=1,
+		SrcPeripheral = 1 (SLC),
+		DestPeripheral = 1 (SLC),
+		FlowCntrl = 2 (Pher -> Mem, DMA),
+		IE = 0,
+		ITC = 0,
+		L= 0,
+		H=0
+	*/
+	retval = target_write_u32(target, 0x31000110,
+				  1 | 1<<1 | 1<<6 | 2<<11 | 0<<14
+				  | 0<<15 | 0<<16 | 0<<18);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not set DMACC0Config");
+		return retval;
+	}
+
+	/* SLC_CTRL = 3 (START DMA), ECC_CLEAR */
+	retval = target_write_u32(target, 0x20020010, 0x3);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not set SLC_CTRL");
+		return retval;
+	}
+
+	/* SLC_ICR = 2, INT_TC_CLR, clear pending TC*/
+	retval = target_write_u32(target, 0x20020028, 2);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not set SLC_ICR");
+		return retval;
+	}
+
+	/* SLC_TC */
+	retval = target_write_u32(target, 0x20020030, count);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("lpc32xx_start_slc_dma: Could not set SLC_TC");
+		return retval;
+	}
+
+	/* Wait finish */
+	if (do_wait && !lpc32xx_tc_ready(nand, 100)) {
+		LOG_ERROR("timeout while waiting for completion of DMA");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return retval;
+}
+
+static int lpc32xx_dma_ready(struct nand_device *nand, int timeout)
+{
+	struct target *target = nand->target;
+
+	LOG_DEBUG("lpc32xx_dma_ready count start=%d", timeout);
+
+	do {
+		uint32_t tc_stat;
+		uint32_t err_stat;
+		int retval;
+
+		/* Read DMACRawIntTCStat */
+		retval = target_read_u32(target, 0x31000014, &tc_stat);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not read DMACRawIntTCStat");
+			return 0;
+		}
+		/* Read DMACRawIntErrStat */
+		retval = target_read_u32(target, 0x31000018, &err_stat);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not read DMACRawIntErrStat");
+			return 0;
+		}
+		if ((tc_stat | err_stat) & 1) {
+			LOG_DEBUG("lpc32xx_dma_ready count=%d",
+				  timeout);
+			if (err_stat & 1) {
+				LOG_ERROR("lpc32xx_dma_ready "
+					  "DMA error, aborted");
+				return 0;
+			} else {
+				return 1;
+			}
+		}
+
+		alive_sleep(1);
+	} while (timeout-- > 0);
+
+	return 0;
+}
+
+static uint32_t slc_ecc_copy_to_buffer(uint8_t * spare,
+		const uint32_t * ecc, int count)
+{
+	int i;
+	for (i = 0; i < (count * 3); i += 3) {
+		uint32_t ce = ecc[i/3];
+		ce = ~(ce << 2) & 0xFFFFFF;
+		spare[i+2] = (uint8_t)(ce & 0xFF); ce >>= 8;
+		spare[i+1] = (uint8_t)(ce & 0xFF); ce >>= 8;
+		spare[i]   = (uint8_t)(ce & 0xFF);
+	}
+	return 0;
+}
+
+static void lpc32xx_dump_oob(uint8_t *oob, uint32_t oob_size)
+{
+	int addr = 0;
+	while (oob_size > 0) {
+		LOG_DEBUG("%02x: %02x %02x %02x %02x %02x %02x %02x %02x", addr,
+			  oob[0], oob[1], oob[2], oob[3],
+			  oob[4], oob[5], oob[6], oob[7]);
+		oob += 8;
+		addr += 8;
+		oob_size -= 8;
+	}	
+}
+
+static int lpc32xx_write_page_slc(struct nand_device *nand,
+				  struct working_area *pworking_area,
+				  uint32_t page, uint8_t *data,
+				  uint32_t data_size, uint8_t *oob,
+				  uint32_t oob_size)
+{
+	struct target *target = nand->target;
+	int retval;
+	uint32_t target_mem_base;
+
+	LOG_DEBUG("SLC write page %x data=%d, oob=%d, "
+		  "data_size=%d, oob_size=%d",
+		  page, data != 0, oob != 0, data_size, oob_size);
+
+	target_mem_base = pworking_area->address;
+	/* 
+	 * Skip writting page which has all 0xFF data as this will
+	 * generate 0x0 value.
+	 */
+	if (data && !oob) {
+		uint32_t i, all_ff = 1;
+		for (i = 0; i < data_size; i++)
+			if (data[i] != 0xFF) {
+				all_ff = 0;
+				break;
+			}
+		if (all_ff)
+		        return ERROR_OK;
+	}
+	/* Make the dma descriptors in local memory */
+	int nll = lpc32xx_make_dma_list(target_mem_base, nand->page_size, 0);
+	/* Write them to target.
+	   XXX: Assumes host and target have same byte sex.
+	*/
+	retval = target_write_memory(target, target_mem_base, 4,
+				     nll * sizeof(dmac_ll_t) / 4,
+				     (uint8_t *)dmalist);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not write DMA descriptors to IRAM");
+		return retval;
+	}
+
+	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("NAND_CMD_SEQIN failed");
+		return retval;
+	}
+
+	 /* SLC_CFG =
+		Force nCE assert,
+		DMA ECC enabled,
+		ECC enabled,
+		DMA burst enabled,
+		DMA write to SLC,
+		WIDTH = bus_width
+	*/
+	retval = target_write_u32(target, 0x20020014, 0x3c);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not set SLC_CFG");
+		return retval;
+	}
+	if (data) {
+		/* Write data to target */
+		static uint8_t fdata[2048];
+		memset(fdata, 0xFF, nand->page_size);
+		memcpy(fdata, data, data_size);
+		retval = target_write_memory(target,
+					     target_mem_base + DATA_OFFS,
+					     4, nand->page_size/4, fdata);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not write data to IRAM");
+			return retval;
+		}
+
+		/* Write first decriptor to DMA controller */
+		retval = target_write_memory(target, 0x31000100, 4,
+					     sizeof(dmac_ll_t) / 4,
+					     (uint8_t *)dmalist);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not write DMA descriptor to DMAC");
+			return retval;
+		}
+
+		/* Start xfer of data from iram to flash using DMA */
+		int tot_size = nand->page_size;
+		tot_size += tot_size == 2048 ? 64 : 16;
+		retval = lpc32xx_start_slc_dma(nand, tot_size, 0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("DMA failed");
+			return retval;
+		}
+		
+		/* Wait for DMA to finish.  SLC is not finished at this stage */
+		if (!lpc32xx_dma_ready(nand, 100)) {
+			LOG_ERROR("Data DMA failed during write");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+	} /* data xfer */
+
+	/* Copy OOB to iram */
+	static uint8_t foob[64];
+	int foob_size = nand->page_size == 2048 ? 64 : 16;
+	memset(foob, 0xFF, foob_size);
+	if (oob) { /* Raw mode */
+		memcpy(foob, oob, oob_size);
+	} else {
+		/* Get HW generated ECC, made while writing data */
+		int ecc_count = nand->page_size == 2048 ? 8 : 2;
+		static uint32_t hw_ecc[8];
+		retval = target_read_memory(target, target_mem_base + ECC_OFFS,
+					    4, ecc_count, (uint8_t *)hw_ecc);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Reading hw generated ECC from IRAM failed");
+			return retval;
+		}
+		/* Copy to oob, at correct offsets */
+		static uint8_t ecc[24];
+		slc_ecc_copy_to_buffer(ecc, hw_ecc, ecc_count);
+		int *layout = nand->page_size == 2048 ? lp_ooblayout : sp_ooblayout;
+		int i;
+		for (i = 0; i < ecc_count * 3; i++)
+			foob[layout[i]] = ecc[i];
+		lpc32xx_dump_oob(foob, foob_size);
+	}
+	retval = target_write_memory(target, target_mem_base + SPARE_OFFS, 4,
+				     foob_size / 4, foob);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Writing OOB to IRAM failed");
+		return retval;
+	}
+
+	/* Write OOB decriptor to DMA controller */
+	retval = target_write_memory(target, 0x31000100, 4,
+				     sizeof(dmac_ll_t) / 4,
+				     (uint8_t *)(&dmalist[nll-1]));
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not write OOB DMA descriptor to DMAC");
+		return retval;
+	}
+	if (data) {
+		/* Only restart DMA with last descriptor,
+		 * don't setup SLC again */
+
+		/* DMACIntTCClear = ch0 */
+		retval = target_write_u32(target, 0x31000008, 1);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not set DMACIntTCClear");
+			return retval;
+		}
+		/* DMACCxConfig=
+			E=1,
+			SrcPeripheral = 1 (SLC),
+			DestPeripheral = 1 (SLC),
+			FlowCntrl = 2 (Pher -> Mem, DMA),
+			IE = 0,
+			ITC = 0,
+			L= 0,
+			H=0
+		*/
+		retval = target_write_u32(target, 0x31000110,
+					  1 | 1<<1 | 1<<6 | 2<<11 | 0<<14
+					  | 0<<15 | 0<<16 | 0<<18);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not set DMACC0Config");
+			return retval;
+		}
+		/* Wait finish */
+		if (!lpc32xx_tc_ready(nand, 100)) {
+			LOG_ERROR("timeout while waiting for "
+				  "completion of DMA");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	} else {
+		/* Start xfer of data from iram to flash using DMA */
+		retval = lpc32xx_start_slc_dma(nand, foob_size, 1);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("DMA OOB failed");
+			return retval;
+		}
+	}
+
+	/* Let NAND start actual writing */
+	retval = nand_write_finish(nand);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("nand_write_finish failed");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_write_page(struct nand_device *nand, uint32_t page,
+			      uint8_t *data, uint32_t data_size,
+			      uint8_t *oob, uint32_t oob_size)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval = ERROR_OK;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use LPC32xx "
+			  "NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_ERROR("BUG: no LPC32xx NAND flash controller selected");
+		return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		if (!data && oob) {
+			LOG_ERROR("LPC32xx MLC controller can't write "
+				  "OOB data only");
+			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+		}
+
+		if (oob && (oob_size > 24)) {
+			LOG_ERROR("LPC32xx MLC controller can't write more "
+				  "than 6 bytes for each quarter's OOB data");
+			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+		}
+
+		if (data_size > (uint32_t)nand->page_size) {
+			LOG_ERROR("data size exceeds page size");
+			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+		}
+
+		retval = lpc32xx_write_page_mlc(nand, page, data, data_size,
+					        oob, oob_size);
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		struct working_area *pworking_area;
+		if (!data && oob) {
+			/*
+			 * if oob only mode is active original method is used
+			 * as SLC controller hangs during DMA interworking. (?)
+			 * Anyway the code supports the oob only mode below.
+			 */
+			return nand_write_page_raw(nand, page, data,
+						   data_size, oob, oob_size);
+		}
+		retval = target_alloc_working_area(target,
+						   nand->page_size + DATA_OFFS,
+						   &pworking_area);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Can't allocate working area in "
+				  "LPC internal RAM");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+		retval = lpc32xx_write_page_slc(nand, pworking_area, page,
+					        data, data_size, oob, oob_size);
+		target_free_working_area(target, pworking_area);
+	}
+
+	return retval;
+}
+
+static int lpc32xx_read_page_mlc(struct nand_device *nand, uint32_t page,
+				 uint8_t *data, uint32_t data_size,
+				 uint8_t *oob, uint32_t oob_size)
+{
+	struct target *target = nand->target;
+	static uint8_t page_buffer[2048];
+	static uint8_t oob_buffer[64];
+	uint32_t page_bytes_done = 0;
+	uint32_t oob_bytes_done = 0;
+	uint32_t mlc_isr;
+	int retval;
+
+	if (!data && oob) {
+		/* MLC_CMD = Read OOB
+		 * we can use the READOOB command on both small and large page
+		 * devices, as the controller translates the 0x50 command to
+		 * a 0x0 with appropriate positioning of the serial buffer
+		 * read pointer
+		 */
+		retval = target_write_u32(target, 0x200b8000, NAND_CMD_READOOB);
+	} else {
+		/* MLC_CMD = Read0 */
+		retval = target_write_u32(target, 0x200b8000, NAND_CMD_READ0);
+	}
+	if (ERROR_OK != retval) {
+		LOG_ERROR("could not set MLC_CMD");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	if (nand->page_size == 512) {
+		/* small page device */
+		/* MLC_ADDR = 0x0 (one column cycle) */
+		retval = target_write_u32(target, 0x200b8004, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_ADDR = row */
+		retval = target_write_u32(target, 0x200b8004, page & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		retval = target_write_u32(target, 0x200b8004,
+					  (page >> 8) & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (nand->address_cycles == 4) {
+			retval = target_write_u32(target, 0x200b8004,
+						  (page >> 16) & 0xff);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not set MLC_ADDR");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+		}
+	} else {
+		/* large page device */
+		/* MLC_ADDR = 0x0 (two column cycles) */
+		retval = target_write_u32(target, 0x200b8004, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		retval = target_write_u32(target, 0x200b8004, 0x0);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_ADDR = row */
+		retval = target_write_u32(target, 0x200b8004, page & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+		retval = target_write_u32(target, 0x200b8004,
+					  (page >> 8) & 0xff);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ADDR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		/* MLC_CMD = Read Start */
+		retval = target_write_u32(target, 0x200b8000,
+					  NAND_CMD_READSTART);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_CMD");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	while (page_bytes_done < (uint32_t)nand->page_size) {
+		/* MLC_ECC_AUTO_DEC_REG = dummy */
+		retval = target_write_u32(target, 0x200b8014, 0xaa55aa55);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not set MLC_ECC_AUTO_DEC_REG");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (!lpc32xx_controller_ready(nand, 1000)) {
+			LOG_ERROR("timeout while waiting for "
+				  "completion of auto decode cycle");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		retval = target_read_u32(target, 0x200b8048, &mlc_isr);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("could not read MLC_ISR");
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (mlc_isr & 0x8) {
+			if (mlc_isr & 0x40) {
+				LOG_ERROR("uncorrectable error detected: "
+					  "0x%2.2x", (unsigned)mlc_isr);
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+
+			LOG_WARNING("%i symbol error detected and corrected",
+				    ((int)(((mlc_isr & 0x30) >> 4) + 1)));
+		}
+
+		if (data) {
+			retval = target_read_memory(target, 0x200a8000, 4, 128,
+						 page_buffer + page_bytes_done);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not read MLC_BUF (data)");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+		}
+
+		if (oob) {
+			retval = target_read_memory(target, 0x200a8000, 4, 4,
+						 oob_buffer + oob_bytes_done);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not read MLC_BUF (oob)");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+		}
+
+		page_bytes_done += 512;
+		oob_bytes_done += 16;
+	}
+
+	if (data)
+		memcpy(data, page_buffer, data_size);
+
+	if (oob)
+		memcpy(oob, oob_buffer, oob_size);
+
+	return ERROR_OK;
+}
+
+static int lpc32xx_read_page_slc(struct nand_device *nand,
+				 struct working_area *pworking_area,
+				 uint32_t page, uint8_t *data,
+				 uint32_t data_size, uint8_t *oob,
+				 uint32_t oob_size)
+{
+	struct target *target = nand->target;
+	int retval;
+	uint32_t target_mem_base;
+
+	LOG_DEBUG("SLC read page %x data=%d, oob=%d",
+		  page, data_size, oob_size);
+
+	target_mem_base = pworking_area->address;
+
+	/* Make the dma descriptors in local memory */
+	int nll = lpc32xx_make_dma_list(target_mem_base, nand->page_size, 1);
+	/* Write them to target.
+	   XXX: Assumes host and target have same byte sex.
+	*/
+	retval = target_write_memory(target, target_mem_base, 4,
+				     nll * sizeof(dmac_ll_t) / 4,
+				     (uint8_t *)dmalist);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not write DMA descriptors to IRAM");
+		return retval;
+	}
+
+	retval = nand_page_command(nand, page, NAND_CMD_READ0, 0);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("lpc32xx_read_page_slc: NAND_CMD_READ0 failed");
+		return retval;
+	}
+
+	 /* SLC_CFG =
+		Force nCE assert,
+		DMA ECC enabled,
+		ECC enabled,
+		DMA burst enabled,
+		DMA read from SLC,
+		WIDTH = bus_width
+	*/
+	retval = target_write_u32(target, 0x20020014, 0x3e);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("lpc32xx_read_page_slc: Could not set SLC_CFG");
+		return retval;
+	}
+
+	/* Write first decriptor to DMA controller */
+	retval = target_write_memory(target, 0x31000100, 4,
+				     sizeof(dmac_ll_t) / 4, (uint8_t *)dmalist);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not write DMA descriptor to DMAC");
+		return retval;
+	}
+
+	/* Start xfer of data from flash to iram using DMA */
+	int tot_size = nand->page_size;
+	tot_size += nand->page_size == 2048 ? 64 : 16;
+	retval = lpc32xx_start_slc_dma(nand, tot_size, 1);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("lpc32xx_read_page_slc: DMA read failed");
+		return retval;
+	}
+
+	/* Copy data from iram */
+	if (data) {
+		retval = target_read_memory(target, target_mem_base + DATA_OFFS,
+					    4, data_size/4, data);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not read data from IRAM");
+			return retval;
+		}
+	}
+	if (oob) {
+		/* No error correction, just return data as read from flash */
+		retval = target_read_memory(target,
+					    target_mem_base + SPARE_OFFS, 4,
+					    oob_size/4, oob);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not read OOB from IRAM");
+			return retval;
+		}
+		return ERROR_OK;
+	}
+
+	/* Copy OOB from flash, stored in IRAM */
+	static uint8_t foob[64];
+	retval = target_read_memory(target, target_mem_base + SPARE_OFFS,
+				    4, nand->page_size == 2048 ? 16 : 4, foob);
+	lpc32xx_dump_oob(foob, nand->page_size == 2048 ? 64 : 16);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not read OOB from IRAM");
+		return retval;
+	}
+	/* Copy ECC from HW, generated while reading */
+	int ecc_count = nand->page_size == 2048 ? 8 : 2;
+	static uint32_t hw_ecc[8]; /* max size */
+	retval = target_read_memory(target, target_mem_base + ECC_OFFS, 4,
+				    ecc_count, (uint8_t *)hw_ecc);
+	if (ERROR_OK != retval) {
+		LOG_ERROR("Could not read hw generated ECC from IRAM");
+		return retval;
+	}
+	static uint8_t ecc[24];
+	slc_ecc_copy_to_buffer(ecc, hw_ecc, ecc_count);
+	/* Copy ECC from flash using correct layout */
+	static uint8_t fecc[24]; /* max size */
+	int *layout = nand->page_size == 2048 ? lp_ooblayout : sp_ooblayout;
+	int i;
+	for (i = 0; i < ecc_count * 3; i++)
+		fecc[i] = foob[layout[i]];
+	/* Compare ECC and possibly correct data */
+	for (i = 0; i < ecc_count; i++) {
+		retval = nand_correct_data(nand, data + 256*i, &fecc[i * 3],
+					   &ecc[i * 3]);
+		if (retval > 0)
+			LOG_WARNING("error detected and corrected: %d/%d",
+				     page, i);
+		if (retval < 0)
+			break;
+	}
+	if (i == ecc_count)
+		retval = ERROR_OK;
+	else {
+		LOG_ERROR("uncorrectable error detected: %d/%d", page, i);
+		retval = ERROR_NAND_OPERATION_FAILED;
+	}
+	return retval;
+}
+
+static int lpc32xx_read_page(struct nand_device *nand, uint32_t page,
+			     uint8_t *data, uint32_t data_size,
+			     uint8_t *oob, uint32_t oob_size)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval = ERROR_OK;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use LPC32xx "
+			  "NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (lpc32xx_info->selected_controller == LPC32xx_NO_CONTROLLER) {
+		LOG_ERROR("BUG: no LPC32xx NAND flash controller selected");
+		return ERROR_NAND_OPERATION_FAILED;
+	} else if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+		if (data_size > (uint32_t)nand->page_size) {
+			LOG_ERROR("data size exceeds page size");
+			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
+		}
+		retval = lpc32xx_read_page_mlc(nand, page, data, data_size,
+					       oob, oob_size);
+	} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+		struct working_area *pworking_area;
+
+ 		retval = target_alloc_working_area(target,
+						   nand->page_size + 0x200,
+						   &pworking_area);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Can't allocate working area in "
+				  "LPC internal RAM");
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+		retval = lpc32xx_read_page_slc(nand, pworking_area, page,
+					      data, data_size, oob, oob_size);
+ 		target_free_working_area(target, pworking_area);
+	}
+
+	return retval;
+}
+
+static int lpc32xx_controller_ready(struct nand_device *nand, int timeout)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use LPC32xx "
+			  "NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	LOG_DEBUG("lpc32xx_controller_ready count start=%d", timeout);
+
+	do {
+		if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+			uint8_t status;
+
+			/* Read MLC_ISR, wait for controller to become ready */
+			retval = target_read_u8(target, 0x200b8048, &status);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not set MLC_STAT");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+
+			if (status & 2) {
+				LOG_DEBUG("lpc32xx_controller_ready count=%d",
+					  timeout);
+				return 1;
+			}
+		} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+			uint32_t status;
+
+			/* Read SLC_STAT and check READY bit */
+			retval = target_read_u32(target, 0x20020018, &status);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not set SLC_STAT");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+
+			if (status & 1) {
+				LOG_DEBUG("lpc32xx_controller_ready count=%d",
+					  timeout);
+				return 1;
+			}
+		}
+
+		alive_sleep(1);
+	} while (timeout-- > 0);
+
+	return 0;
+}
+
+static int lpc32xx_nand_ready(struct nand_device *nand, int timeout)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = nand->controller_priv;
+	struct target *target = nand->target;
+	int retval;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("target must be halted to use LPC32xx "
+			  "NAND flash controller");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	LOG_DEBUG("lpc32xx_nand_ready count start=%d", timeout);
+
+	do {
+		if (lpc32xx_info->selected_controller == LPC32xx_MLC_CONTROLLER) {
+			uint8_t status = 0x0;
+
+			/* Read MLC_ISR, wait for NAND flash device to
+			 * become ready */
+			retval = target_read_u8(target, 0x200b8048, &status);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not read MLC_ISR");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+
+			if (status & 1) {
+				LOG_DEBUG("lpc32xx_nand_ready count end=%d",
+					  timeout);
+				return 1;
+			}
+		} else if (lpc32xx_info->selected_controller == LPC32xx_SLC_CONTROLLER) {
+			uint32_t status = 0x0;
+
+			/* Read SLC_STAT and check READY bit */
+			retval = target_read_u32(target, 0x20020018, &status);
+			if (ERROR_OK != retval) {
+				LOG_ERROR("could not read SLC_STAT");
+				return ERROR_NAND_OPERATION_FAILED;
+			}
+
+			if (status & 1) {
+				LOG_DEBUG("lpc32xx_nand_ready count end=%d",
+					  timeout);
+				return 1;
+			}
+		}
+
+		alive_sleep(1);
+	} while (timeout-- > 0);
+
+	return 0;
+}
+
+static int lpc32xx_tc_ready(struct nand_device *nand, int timeout)
+{
+	struct target *target = nand->target;
+
+	LOG_DEBUG("lpc32xx_tc_ready count start=%d", timeout);
+
+	do {
+		uint32_t status = 0x0;
+		int retval;
+		/* Read SLC_INT_STAT and check INT_TC_STAT bit */
+		retval = target_read_u32(target, 0x2002001c, &status);
+		if (ERROR_OK != retval) {
+			LOG_ERROR("Could not read SLC_INT_STAT");
+			return 0;
+		}
+		if (status & 2){
+			LOG_DEBUG("lpc32xx_tc_ready count=%d", timeout);
+			return 1;
+		}
+
+		alive_sleep(1);
+	} while (timeout-- > 0);
+
+	return 0;
+}
+
+COMMAND_HANDLER(handle_lpc32xx_select_command)
+{
+	struct lpc32xx_nand_controller *lpc32xx_info = NULL;
+	char *selected[] = {
+		"no", "mlc", "slc"
+	};
+
+	if ((CMD_ARGC < 1) || (CMD_ARGC > 3)) {
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	unsigned num;
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], num);
+	struct nand_device *nand = get_nand_device_by_num(num);
+	if (!nand) {
+		command_print(CMD_CTX, "nand device '#%s' is out of bounds",
+			      CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	lpc32xx_info = nand->controller_priv;
+
+	if (CMD_ARGC >= 2) {
+		if (strcmp(CMD_ARGV[1], "mlc") == 0) {
+			lpc32xx_info->selected_controller =
+				LPC32xx_MLC_CONTROLLER;
+		} else if (strcmp(CMD_ARGV[1], "slc") == 0) {
+			lpc32xx_info->selected_controller =
+				LPC32xx_SLC_CONTROLLER;
+ 		} else {
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+	}
+
+	command_print(CMD_CTX, "%s controller selected",
+		      selected[lpc32xx_info->selected_controller]);
+
+	return ERROR_OK;
+}
+
+static const struct command_registration lpc32xx_exec_command_handlers[] = {
+	{
+		.name = "select",
+		.handler = handle_lpc32xx_select_command,
+		.mode = COMMAND_EXEC,
+		.help = "select MLC or SLC controller (default is MLC)",
+		.usage = "bank_id ['mlc'|'slc' ]",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration lpc32xx_command_handler[] = {
+	{
+		.name = "lpc32xx",
+		.mode = COMMAND_ANY,
+		.help = "LPC32xx NAND flash controller commands",
+		.chain = lpc32xx_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct nand_flash_controller lpc32xx_nand_controller = {
+	.name = "lpc32xx",
+	.commands = lpc32xx_command_handler,
+	.nand_device_command = lpc32xx_nand_device_command,
+	.init = lpc32xx_init,
+	.reset = lpc32xx_reset,
+	.command = lpc32xx_command,
+	.address = lpc32xx_address,
+	.write_data = lpc32xx_write_data,
+	.read_data = lpc32xx_read_data,
+	.write_page = lpc32xx_write_page,
+	.read_page = lpc32xx_read_page,
+	.nand_ready = lpc32xx_nand_ready,
+};
diff --git a/src/flash/nand/lpc32xx.h b/src/flash/nand/lpc32xx.h
new file mode 100644
index 0000000..fd87245
--- /dev/null
+++ b/src/flash/nand/lpc32xx.h
@@ -0,0 +1,39 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath                                    *
+ *   Dominic.Rath at gmx.de                                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef LPC32xx_NAND_CONTROLLER_H
+#define LPC32xx_NAND_CONTROLLER_H
+
+enum lpc32xx_selected_controller
+{
+	LPC32xx_NO_CONTROLLER,
+	LPC32xx_MLC_CONTROLLER,
+	LPC32xx_SLC_CONTROLLER,
+};
+
+struct lpc32xx_nand_controller
+{
+	int osc_freq;
+	enum lpc32xx_selected_controller selected_controller;
+	int sw_write_protection;
+	uint32_t sw_wp_lower_bound;
+	uint32_t sw_wp_upper_bound;
+};
+
+#endif /*LPC32xx_NAND_CONTROLLER_H */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/Makefile.am              |    2 +
 src/flash/nand/driver.c                 |    2 +
 src/flash/nand/ecc.c                    |   61 +
 src/flash/nand/lpc32xx.c                | 1828 +++++++++++++++++++++++++++++++
 src/flash/nand/{lpc3180.h => lpc32xx.h} |   19 +-
 5 files changed, 1902 insertions(+), 10 deletions(-)
 create mode 100644 src/flash/nand/lpc32xx.c
 copy src/flash/nand/{lpc3180.h => lpc32xx.h} (83%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb 17 08:24:32 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Feb 2011 07:24:32 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-758-g0f863ec
Message-ID: <mailman.6.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0f863ecb0112e5032608b9b66ab4c69bfe43b12f (commit)
      from  3f4b9e334b867a16c35b1c6d9a1f9aefd35fd91b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0f863ecb0112e5032608b9b66ab4c69bfe43b12f
Author: Mathias K <kesmtp at freenet.de>
Date:   Tue Feb 15 20:17:10 2011 +0100

    - remove pipeline context, use once register instead - fix wrong register write in resume and step function - add more conditional branch handling

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 011b616..5e30739 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -92,32 +92,60 @@
 #define ASM_REG_W_AAR2	0xFFFFF7
 #define ASM_REG_W_AAR3	0xFFFFF6
 
+enum once_reg_idx {
+	ONCE_REG_IDX_OSCR=0,
+	ONCE_REG_IDX_OMBC=1,
+	ONCE_REG_IDX_OBCR=2,
+	ONCE_REG_IDX_OMLR0=3,
+	ONCE_REG_IDX_OMLR1=4,
+	ONCE_REG_IDX_OGDBR=5,
+	ONCE_REG_IDX_OPDBR=6,
+	ONCE_REG_IDX_OPILR=7,
+	ONCE_REG_IDX_PDB=8,
+	ONCE_REG_IDX_OTC=9,
+	ONCE_REG_IDX_OPABFR=10,
+	ONCE_REG_IDX_OPABDR=11,
+	ONCE_REG_IDX_OPABEX=12,
+	ONCE_REG_IDX_OPABF0=13,
+	ONCE_REG_IDX_OPABF1=14,
+	ONCE_REG_IDX_OPABF2=15,
+	ONCE_REG_IDX_OPABF3=16,
+	ONCE_REG_IDX_OPABF4=17,
+	ONCE_REG_IDX_OPABF5=18,
+	ONCE_REG_IDX_OPABF6=19,
+	ONCE_REG_IDX_OPABF7=20,
+	ONCE_REG_IDX_OPABF8=21,
+	ONCE_REG_IDX_OPABF9=22,
+	ONCE_REG_IDX_OPABF10=23,
+	ONCE_REG_IDX_OPABF11=24,
+};
+
 static struct once_reg once_regs[] = {
-	{0, 0x00, 24, "OSCR", 0},
-	{1, 0x01, 24, "OMBC", 0},
-	{2, 0x02, 24, "OBCR", 0},
-	{3, 0x05, 24, "OMLR0", 0},
-	{4, 0x06, 24, "OMLR1", 0},
-	{5, 0x09, 24, "OGDBR", 0},
-	{6, 0x0a, 24, "OPDBR", 0},
-	{7, 0x0b, 24, "OPILR", 0},
-	{8, 0x0c, 24, "PDB", 0},
-	{9, 0x0d, 24, "OTC", 0},
-	{10, 0x0f, 24, "OPABFR", 0},
-	{11, 0x10, 24, "OPABDR", 0},
-	{12, 0x11, 24, "OPABEX", 0},
-	{13, 0x12, 25, "OPABF0", 0},
-	{14, 0x12, 25, "OPABF1", 0},
-	{15, 0x12, 25, "OPABF2", 0},
-	{16, 0x12, 25, "OPABF3", 0},
-	{17, 0x12, 25, "OPABF4", 0},
-	{18, 0x12, 25, "OPABF5", 0},
-	{19, 0x12, 25, "OPABF6", 0},
-	{20, 0x12, 25, "OPABF7", 0},
-	{21, 0x12, 25, "OPABF8", 0},
-	{22, 0x12, 25, "OPABF9", 0},
-	{23, 0x12, 25, "OPABF10", 0},
-	{24, 0x12, 25, "OPABF11", 0},
+	{ONCE_REG_IDX_OSCR,    DSP563XX_ONCE_OSCR,    24, "OSCR",    0},
+	{ONCE_REG_IDX_OMBC,    DSP563XX_ONCE_OMBC,    24, "OMBC",    0},
+	{ONCE_REG_IDX_OBCR,    DSP563XX_ONCE_OBCR,    24, "OBCR",    0},
+	{ONCE_REG_IDX_OMLR0,   DSP563XX_ONCE_OMLR0,   24, "OMLR0",   0},
+	{ONCE_REG_IDX_OMLR1,   DSP563XX_ONCE_OMLR1,   24, "OMLR1",   0},
+	{ONCE_REG_IDX_OGDBR,   DSP563XX_ONCE_OGDBR,   24, "OGDBR",   0},
+	{ONCE_REG_IDX_OPDBR,   DSP563XX_ONCE_OPDBR,   24, "OPDBR",   0},
+	{ONCE_REG_IDX_OPILR,   DSP563XX_ONCE_OPILR,   24, "OPILR",   0},
+	{ONCE_REG_IDX_PDB,     DSP563XX_ONCE_PDBGOTO, 24, "PDB",     0},
+	{ONCE_REG_IDX_OTC,     DSP563XX_ONCE_OTC,     24, "OTC",     0},
+	{ONCE_REG_IDX_OPABFR,  DSP563XX_ONCE_OPABFR,  24, "OPABFR",  0},
+	{ONCE_REG_IDX_OPABDR,  DSP563XX_ONCE_OPABDR,  24, "OPABDR",  0},
+	{ONCE_REG_IDX_OPABEX,  DSP563XX_ONCE_OPABEX,  24, "OPABEX",  0},
+	{ONCE_REG_IDX_OPABF0,  DSP563XX_ONCE_OPABF11, 25, "OPABF0",  0},
+	{ONCE_REG_IDX_OPABF1,  DSP563XX_ONCE_OPABF11, 25, "OPABF1",  0},
+	{ONCE_REG_IDX_OPABF2,  DSP563XX_ONCE_OPABF11, 25, "OPABF2",  0},
+	{ONCE_REG_IDX_OPABF3,  DSP563XX_ONCE_OPABF11, 25, "OPABF3",  0},
+	{ONCE_REG_IDX_OPABF4,  DSP563XX_ONCE_OPABF11, 25, "OPABF4",  0},
+	{ONCE_REG_IDX_OPABF5,  DSP563XX_ONCE_OPABF11, 25, "OPABF5",  0},
+	{ONCE_REG_IDX_OPABF6,  DSP563XX_ONCE_OPABF11, 25, "OPABF6",  0},
+	{ONCE_REG_IDX_OPABF7,  DSP563XX_ONCE_OPABF11, 25, "OPABF7",  0},
+	{ONCE_REG_IDX_OPABF8,  DSP563XX_ONCE_OPABF11, 25, "OPABF8",  0},
+	{ONCE_REG_IDX_OPABF9,  DSP563XX_ONCE_OPABF11, 25, "OPABF9",  0},
+	{ONCE_REG_IDX_OPABF10, DSP563XX_ONCE_OPABF11, 25, "OPABF10", 0},
+	{ONCE_REG_IDX_OPABF11, DSP563XX_ONCE_OPABF11, 25, "OPABF11", 0},
 //      {25,0x1f,24,"NRSEL",0},
 };
 
@@ -432,35 +460,41 @@ static int dsp563xx_reg_write(struct target *target, uint32_t instr_mask, uint32
 
 static int dsp563xx_reg_pc_read(struct target *target)
 {
-	int err;
-	uint32_t opabdr, opabex;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	/* pc was changed, nothing todo */
 	if (dsp563xx->core_cache->reg_list[REG_NUM_PC].dirty)
 		return ERROR_OK;
 
-	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABDR, &opabdr)) != ERROR_OK)
-		return err;
-	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABEX, &opabex)) != ERROR_OK)
-		return err;
-
 	/* conditional branch check */
-	if (opabdr == opabex)
+	if ( once_regs[ONCE_REG_IDX_OPABDR].reg == once_regs[ONCE_REG_IDX_OPABEX].reg )
 	{
-		/* TODO: check the trace buffer and if a
-		 * conditional branch is detected then decode
-		 * the branch command and add the relative
-		 * address to the current pc
-		 */
-		LOG_DEBUG("%s conditional branch not supported yet", __FUNCTION__);
+		if ( (once_regs[ONCE_REG_IDX_OPABF11].reg & 1) == 0 )
+		{
+			LOG_DEBUG("%s conditional branch not supported yet", __FUNCTION__);
+
+			/* TODO: use disassembly to set correct pc offset */
+			dsp563xx->core_regs[REG_NUM_PC] = (once_regs[ONCE_REG_IDX_OPABF11].reg >> 1) & 0x00FFFFFF;
+		}
+		else
+		{
+			if ( once_regs[ONCE_REG_IDX_OPABEX].reg == once_regs[ONCE_REG_IDX_OPABFR].reg )
+			{
+				dsp563xx->core_regs[REG_NUM_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg;
+			}
+			else
+			{
+				dsp563xx->core_regs[REG_NUM_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg - 1;
+			}
+		}
 	}
 	else
 	{
-		dsp563xx->core_regs[REG_NUM_PC] = opabex;
-		dsp563xx->read_core_reg(target, REG_NUM_PC);
+		dsp563xx->core_regs[REG_NUM_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg;
 	}
 
+	dsp563xx->read_core_reg(target, REG_NUM_PC);
+
 	return ERROR_OK;
 }
 
@@ -889,7 +923,6 @@ static int dsp563xx_poll(struct target *target)
 static int dsp563xx_halt(struct target *target)
 {
 	int err;
-	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	if (target->state == TARGET_HALTED)
 	{
@@ -905,12 +938,6 @@ static int dsp563xx_halt(struct target *target)
 	if ((err = dsp563xx_jtag_debug_request(target)) != ERROR_OK)
 		return err;
 
-	/* store pipeline register */
-	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
-		return err;
-	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
-		return err;
-
 	LOG_DEBUG("%s", __FUNCTION__);
 
 	return ERROR_OK;
@@ -930,11 +957,11 @@ static int dsp563xx_resume(struct target *target, int current, uint32_t address,
 	if (current)
 	{
 		/* restore pipeline registers and go */
-		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR, once_regs[ONCE_REG_IDX_OPILR].reg)) != ERROR_OK)
 			return err;
 		if ((err =
 		     dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
-					     dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+					     once_regs[ONCE_REG_IDX_OPDBR].reg)) != ERROR_OK)
 			return err;
 	}
 	else
@@ -991,11 +1018,11 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 	if (current)
 	{
 		/* restore pipeline registers and go */
-		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPILR, dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
+		if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR, once_regs[ONCE_REG_IDX_OPILR].reg)) != ERROR_OK)
 			return err;
 		if ((err =
 		     dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OPDBR | DSP563XX_ONCE_OCR_EX | DSP563XX_ONCE_OCR_GO,
-					     dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
+					     once_regs[ONCE_REG_IDX_OPDBR].reg)) != ERROR_OK)
 			return err;
 	}
 	else
@@ -1014,21 +1041,15 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 
 		if (once_status & DSP563XX_ONCE_OSCR_TO)
 		{
-			/* store pipeline register */
-			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPILR, &dsp563xx->pipeline_context.once_opilr)) != ERROR_OK)
-				return err;
-			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPDBR, &dsp563xx->pipeline_context.once_opdbr)) != ERROR_OK)
-				return err;
-
 			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABFR, &dr_in)) != ERROR_OK)
 				return err;
-			LOG_DEBUG("fetch: %08X", (unsigned) dr_in);
+			LOG_DEBUG("fetch: %08X", (unsigned) dr_in&0x00ffffff);
 			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABDR, &dr_in)) != ERROR_OK)
 				return err;
-			LOG_DEBUG("decode: %08X", (unsigned) dr_in);
+			LOG_DEBUG("decode: %08X", (unsigned) dr_in&0x00ffffff);
 			if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OPABEX, &dr_in)) != ERROR_OK)
 				return err;
-			LOG_DEBUG("execute: %08X", (unsigned) dr_in);
+			LOG_DEBUG("execute: %08X", (unsigned) dr_in&0x00ffffff);
 
 			/* reset trace mode */
 			if ((err = dsp563xx_once_reg_write(target->tap, 1, DSP563XX_ONCE_OSCR, 0x000000)) != ERROR_OK)
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
index c553471..67ff8d5 100644
--- a/src/target/dsp563xx.h
+++ b/src/target/dsp563xx.h
@@ -31,14 +31,6 @@ struct mcu_jtag
 	struct jtag_tap *tap;
 };
 
-struct dsp563xx_pipeline_context
-{
-	/* PIL Register */
-	uint32_t once_opilr;
-	/* PDB Register */
-	uint32_t once_opdbr;
-};
-
 struct dsp563xx_common
 {
 	struct mcu_jtag jtag_info;
@@ -46,8 +38,6 @@ struct dsp563xx_common
 	uint32_t core_regs[DSP563XX_NUMCOREREGS];
 	struct once_reg once_regs[DSP563XX_NUMONCEREGS];
 
-	struct dsp563xx_pipeline_context pipeline_context;
-
 	/* register cache to processor synchronization */
 	int (*read_core_reg) (struct target * target, int num);
 	int (*write_core_reg) (struct target * target, int num);

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c |  143 ++++++++++++++++++++++++++++---------------------
 src/target/dsp563xx.h |   10 ----
 2 files changed, 82 insertions(+), 71 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb 17 09:22:34 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Feb 2011 08:22:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-760-g01edbc2
Message-ID: <mailman.7.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  01edbc2c3f3f2927ec7b7a1ec2b602dca760512b (commit)
       via  b7163f534a4bb753b768398af11055cd3a9718cc (commit)
      from  0f863ecb0112e5032608b9b66ab4c69bfe43b12f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 01edbc2c3f3f2927ec7b7a1ec2b602dca760512b
Author: Mathias K <kesmtp at freenet.de>
Date:   Thu Feb 17 09:11:25 2011 +0100

    dsp563xx: minor fixes, code cleanup
    
    This patch move the dsp563xx_target_create function to the
    related code block. Also the target examine function was added
    and the register cache is initialized in a separate function. The
    missing functionality to invalidate the x memory context on memory
    writes was also added.

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 5e30739..8e1d6f7 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -328,21 +328,6 @@ static int dsp563xx_write_core_reg(struct target *target, int num)
 	return ERROR_OK;
 }
 
-static int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
-{
-	struct dsp563xx_common *dsp563xx = calloc(1, sizeof(struct dsp563xx_common));
-
-	if (!dsp563xx)
-		return ERROR_INVALID_ARGUMENTS;
-
-	dsp563xx->jtag_info.tap = target->tap;
-	target->arch_info = dsp563xx;
-	dsp563xx->read_core_reg = dsp563xx_read_core_reg;
-	dsp563xx->write_core_reg = dsp563xx_write_core_reg;
-
-	return ERROR_OK;
-}
-
 static int dsp563xx_get_core_reg(struct reg *reg)
 {
 	struct dsp563xx_core_reg *dsp563xx_reg = reg->arch_info;
@@ -379,6 +364,48 @@ static int dsp563xx_set_core_reg(struct reg *reg, uint8_t * buf)
 	return ERROR_OK;
 }
 
+static const struct reg_arch_type dsp563xx_reg_type = {
+	.get = dsp563xx_get_core_reg,
+	.set = dsp563xx_set_core_reg,
+};
+
+static void dsp563xx_build_reg_cache(struct target *target)
+{
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+
+	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = malloc(sizeof(struct reg) * DSP563XX_NUMCOREREGS);
+	struct dsp563xx_core_reg *arch_info = malloc(sizeof(struct dsp563xx_core_reg) * DSP563XX_NUMCOREREGS);
+	int i;
+
+	/* Build the process context cache */
+	cache->name = "dsp563xx registers";
+	cache->next = NULL;
+	cache->reg_list = reg_list;
+	cache->num_regs = DSP563XX_NUMCOREREGS;
+	(*cache_p) = cache;
+	dsp563xx->core_cache = cache;
+
+	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
+	{
+		arch_info[i].num = dsp563xx_regs[i].id;
+		arch_info[i].name = dsp563xx_regs[i].name;
+		arch_info[i].size = dsp563xx_regs[i].bits;
+		arch_info[i].eame = dsp563xx_regs[i].eame;
+		arch_info[i].instr_mask = dsp563xx_regs[i].instr_mask;
+		arch_info[i].target = target;
+		arch_info[i].dsp563xx_common = dsp563xx;
+		reg_list[i].name = dsp563xx_regs[i].name;
+		reg_list[i].size = dsp563xx_regs[i].bits;
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].dirty = 0;
+		reg_list[i].valid = 0;
+		reg_list[i].type = &dsp563xx_reg_type;
+		reg_list[i].arch_info = &arch_info[i];
+	}
+}
+
 static int dsp563xx_read_register(struct target *target, int num, int force);
 static int dsp563xx_write_register(struct target *target, int num, int force);
 
@@ -747,48 +774,76 @@ static int dsp563xx_restore_context(struct target *target)
 	return err;
 }
 
-static const struct reg_arch_type dsp563xx_reg_type = {
-	.get = dsp563xx_get_core_reg,
-	.set = dsp563xx_set_core_reg,
-};
-
-static int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target)
+static void dsp563xx_invalidate_x_context(struct target *target, uint32_t addr_start, uint32_t addr_end )
 {
-	/* get pointers to arch-specific information */
+	int i;
+	struct dsp563xx_core_reg *arch_info;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
-	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
-	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
-	struct reg *reg_list = malloc(sizeof(struct reg) * DSP563XX_NUMCOREREGS);
-	struct dsp563xx_core_reg *arch_info = malloc(sizeof(struct dsp563xx_core_reg) * DSP563XX_NUMCOREREGS);
-	int i;
+	if ( addr_start > ASM_REG_W_IPRC )
+		return;
+	if ( addr_start < ASM_REG_W_AAR3 )
+		return;
+
+	for (i = REG_NUM_IPRC; i < DSP563XX_NUMCOREREGS; i++)
+	{
+		arch_info = dsp563xx->core_cache->reg_list[i].arch_info;
+
+		if ( (arch_info->instr_mask >= addr_start) &&
+		     (arch_info->instr_mask <= addr_end))
+		{
+			dsp563xx->core_cache->reg_list[i].valid = 0;
+			dsp563xx->core_cache->reg_list[i].dirty = 0;
+		}
+	}
+}
+
+static int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
+{
+	struct dsp563xx_common *dsp563xx = calloc(1, sizeof(struct dsp563xx_common));
 
+	if (!dsp563xx)
+		return ERROR_INVALID_ARGUMENTS;
+
+	dsp563xx->jtag_info.tap = target->tap;
+	target->arch_info = dsp563xx;
+	dsp563xx->read_core_reg = dsp563xx_read_core_reg;
+	dsp563xx->write_core_reg = dsp563xx_write_core_reg;
+
+	return ERROR_OK;
+}
+
+static int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target)
+{
 	LOG_DEBUG("%s", __FUNCTION__);
 
-	/* Build the process context cache */
-	cache->name = "dsp563xx registers";
-	cache->next = NULL;
-	cache->reg_list = reg_list;
-	cache->num_regs = DSP563XX_NUMCOREREGS;
-	(*cache_p) = cache;
-	dsp563xx->core_cache = cache;
+	dsp563xx_build_reg_cache(target);
 
-	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
+	return ERROR_OK;
+}
+
+static int dsp563xx_examine(struct target *target)
+{
+	uint32_t chip;
+
+	if (target->tap->hasidcode == false)
 	{
-		arch_info[i].num = dsp563xx_regs[i].id;
-		arch_info[i].name = dsp563xx_regs[i].name;
-		arch_info[i].size = dsp563xx_regs[i].bits;
-		arch_info[i].eame = dsp563xx_regs[i].eame;
-		arch_info[i].instr_mask = dsp563xx_regs[i].instr_mask;
-		arch_info[i].target = target;
-		arch_info[i].dsp563xx_common = dsp563xx;
-		reg_list[i].name = dsp563xx_regs[i].name;
-		reg_list[i].size = dsp563xx_regs[i].bits;
-		reg_list[i].value = calloc(1, 4);
-		reg_list[i].dirty = 0;
-		reg_list[i].valid = 0;
-		reg_list[i].type = &dsp563xx_reg_type;
-		reg_list[i].arch_info = &arch_info[i];
+		LOG_ERROR("no IDCODE present on device");
+
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	if (!target_was_examined(target))
+	{
+		target_set_examined(target);
+
+		/* examine core and chip derivate number */
+		chip = (target->tap->idcode>>12)&0x3ff;
+		/* core number 0 means DSP563XX */
+		if ( ((chip>>5)&0x1f) == 0 )
+			chip += 300;
+
+		LOG_INFO("DSP56%03d device found",chip);
 	}
 
 	return ERROR_OK;
@@ -913,7 +968,7 @@ static int dsp563xx_poll(struct target *target)
 			if ((err = dsp563xx_debug_init(target)) != ERROR_OK)
 				return err;
 
-			LOG_DEBUG("target->state: %s", target_state_name(target));
+			LOG_DEBUG("target->state: %s (%x)", target_state_name(target),once_status);
 		}
 	}
 
@@ -1158,7 +1213,7 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 	}
 
 	/* we only support 4 byte aligned data */
-	if ( size != 4 )
+	if ( (size != 4) || (!count) )
 	{
 		return ERROR_INVALID_ARGUMENTS;
 	}
@@ -1250,7 +1305,7 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	}
 
 	/* we only support 4 byte aligned data */
-	if ( size != 4 )
+	if ( (size != 4) || (!count) )
 	{
 		return ERROR_INVALID_ARGUMENTS;
 	}
@@ -1258,6 +1313,8 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	switch (mem_type)
 	{
 		case MEM_X:
+			/* invalidate affected x registers */
+			dsp563xx_invalidate_x_context(target,address,address+count-1);
 			move_cmd = 0x615800;
 			break;
 		case MEM_Y:
@@ -1546,4 +1603,5 @@ struct target_type dsp563xx_target = {
 	.commands = dsp563xx_command_handlers,
 	.target_create = dsp563xx_target_create,
 	.init_target = dsp563xx_init_target,
+	.examine = dsp563xx_examine,
 };

commit b7163f534a4bb753b768398af11055cd3a9718cc
Author: Mathias K <kesmtp at freenet.de>
Date:   Thu Feb 17 09:05:42 2011 +0100

    dsp563xx_once: Correct wrong return value on jtag communication errors
    
    This patch change the return value on a jtag communication error
    to TARGET_UNKNOWN because this function should return the current
    target status and not a error code from the underlying api call.
    Also the validity of the jtag_status is extended to all static
    bits in this value.

diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
index d19323e..d95dcdf 100644
--- a/src/target/dsp563xx_once.c
+++ b/src/target/dsp563xx_once.c
@@ -29,6 +29,9 @@
 #include "dsp563xx.h"
 #include "dsp563xx_once.h"
 
+#define JTAG_STATUS_STATIC_MASK		0x03
+#define JTAG_STATUS_STATIC_VALUE	0x01
+
 #define JTAG_STATUS_NORMAL		0x01
 #define JTAG_STATUS_STOPWAIT		0x05
 #define JTAG_STATUS_BUSY		0x09
@@ -100,19 +103,16 @@ int dsp563xx_once_target_status(struct jtag_tap *tap)
 	uint8_t jtag_status;
 
 	if ((err = dsp563xx_jtag_sendinstr(tap, &jtag_status, JTAG_INSTR_ENABLE_ONCE)) != ERROR_OK)
-		return err;
+		return TARGET_UNKNOWN;
 	if ((err = jtag_execute_queue()) != ERROR_OK)
-		return err;
+		return TARGET_UNKNOWN;
 
-	if ((jtag_status & 1) != 1)
-	{
+	/* verify correct static status pattern */
+	if ( (jtag_status & JTAG_STATUS_STATIC_MASK) != JTAG_STATUS_STATIC_VALUE )
 		return TARGET_UNKNOWN;
-	}
 
 	if (jtag_status != JTAG_STATUS_DEBUG)
-	{
 		return TARGET_RUNNING;
-	}
 
 	return TARGET_HALTED;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c      |  162 ++++++++++++++++++++++++++++++--------------
 src/target/dsp563xx_once.c |   14 ++--
 2 files changed, 117 insertions(+), 59 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb 17 09:27:39 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Feb 2011 08:27:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-761-gfa93174
Message-ID: <mailman.8.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fa93174a56c0aca1201bebf88795d6fe31c18aa1 (commit)
      from  01edbc2c3f3f2927ec7b7a1ec2b602dca760512b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fa93174a56c0aca1201bebf88795d6fe31c18aa1
Author: Luca Ellero <lroluk at gmail.com>
Date:   Mon Feb 14 21:46:53 2011 +0000

    arm_adi_v5: add/move apsel member in struct adiv5_dap
    
    This patch tries to make some order in "apsel" mess.
    "dap apsel" command was quite useless (and broken) by itself.
    With this patch we can use it to select between AHB or APB memory access
    (previous patch 05ab8bdb813acdcd74afa71d6656c2df816cb230 was somehow broken).
    
    - moves member apsel (in struct adiv5_dap) to ap_current
    - adds apsel member
    
    this strange choice is made trying to keep coherence in "dap apsel" command
     and to keep compatibility with other code (for example cortex_a8).
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 48b4a7b..75461c3 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -392,7 +392,7 @@ static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 		return ERROR_OK;
 	dap->ap_bank_value = select_ap_bank;
 
-	select_ap_bank |= dap->apsel;
+	select_ap_bank |= dap->ap_current;
 
 	return jtag_dp_q_write(dap, DP_SELECT, select_ap_bank);
 }
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 4a3cfbb..480472f 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -100,13 +100,13 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  * @param apsel Number of the AP to (implicitly) use with further
  *	transactions.  This normally identifies a MEM-AP.
  */
-void dap_ap_select(struct adiv5_dap *dap,uint8_t apsel)
+void dap_ap_select(struct adiv5_dap *dap,uint8_t ap)
 {
-	uint32_t select_apsel = (apsel << 24) & 0xFF000000;
+	uint32_t new_ap = (ap << 24) & 0xFF000000;
 
-	if (select_apsel != dap->apsel)
+	if (new_ap != dap->ap_current)
 	{
-		dap->apsel = select_apsel;
+		dap->ap_current = new_ap;
 		/* Switching AP invalidates cached values.
 		 * Values MUST BE UPDATED BEFORE AP ACCESS.
 		 */
@@ -885,73 +885,73 @@ int mem_ap_read_buf_u8(struct adiv5_dap *dap, uint8_t *buffer,
 /*--------------------------------------------------------------------*/
 /*          Wrapping function with selection of AP                    */
 /*--------------------------------------------------------------------*/
-int mem_ap_sel_read_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t *value)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_read_u32(swjdp, address, value);
 }
 
-int mem_ap_sel_write_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t value)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_write_u32(swjdp, address, value);
 }
 
-int mem_ap_sel_read_atomic_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t *value)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_read_atomic_u32(swjdp, address, value);
 }
 
-int mem_ap_sel_write_atomic_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t value)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_write_atomic_u32(swjdp, address, value);
 }
 
-int mem_ap_sel_read_buf_u8(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_buf_u8(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_read_buf_u8(swjdp, buffer, count, address);
 }
 
-int mem_ap_sel_read_buf_u16(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_buf_u16(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_read_buf_u16(swjdp, buffer, count, address);
 }
 
-int mem_ap_sel_read_buf_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_read_buf_u32(swjdp, buffer, count, address);
 }
 
-int mem_ap_sel_write_buf_u8(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_buf_u8(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_write_buf_u8(swjdp, buffer, count, address);
 }
 
-int mem_ap_sel_write_buf_u16(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_buf_u16(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_write_buf_u16(swjdp, buffer, count, address);
 }
 
-int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address)
 {
-	dap_ap_select(swjdp, apsel);
+	dap_ap_select(swjdp, ap);
 	return mem_ap_write_buf_u32(swjdp, buffer, count, address);
 }
 
@@ -999,7 +999,7 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	 * Should we probe, or take a hint from the caller?
 	 * Presumably we can ignore the possibility of multiple APs.
 	 */
-	dap->apsel = !0;
+	dap->ap_current = !0;
 	dap_ap_select(dap, 0);
 
 	/* DP initialization */
@@ -1093,20 +1093,20 @@ struct broken_cpu {
 	{ 0x80000000, 0x04770002, 0x1ba00477, 0x60000000, "imx51" },
 };
 
-int dap_get_debugbase(struct adiv5_dap *dap, int apsel,
+int dap_get_debugbase(struct adiv5_dap *dap, int ap,
 			uint32_t *out_dbgbase, uint32_t *out_apid)
 {
-	uint32_t apselold;
+	uint32_t ap_old;
 	int retval;
 	unsigned int i;
 	uint32_t dbgbase, apid, idcode;
 
 	/* AP address is in bits 31:24 of DP_SELECT */
-	if (apsel >= 256)
+	if (ap >= 256)
 		return ERROR_INVALID_ARGUMENTS;
 
-	apselold = dap->apsel;
-	dap_ap_select(dap, apsel);
+	ap_old = dap->ap_current;
+	dap_ap_select(dap, ap);
 
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &dbgbase);
 	if (retval != ERROR_OK)
@@ -1143,7 +1143,7 @@ int dap_get_debugbase(struct adiv5_dap *dap, int apsel,
 			break;
 		}
 
-	dap_ap_select(dap, apselold);
+	dap_ap_select(dap, ap_old);
 
 	/* The asignment happens only here to prevent modification of these
 	 * values before they are certain. */
@@ -1153,18 +1153,18 @@ int dap_get_debugbase(struct adiv5_dap *dap, int apsel,
 	return ERROR_OK;
 }
 
-int dap_lookup_cs_component(struct adiv5_dap *dap, int apsel,
+int dap_lookup_cs_component(struct adiv5_dap *dap, int ap,
 			uint32_t dbgbase, uint8_t type, uint32_t *addr)
 {
-	uint32_t apselold;
+	uint32_t ap_old;
 	uint32_t romentry, entry_offset = 0, component_base, devtype;
 	int retval = ERROR_FAIL;
 
-	if (apsel >= 256)
+	if (ap >= 256)
 		return ERROR_INVALID_ARGUMENTS;
 
-	apselold = dap->apsel;
-	dap_ap_select(dap, apsel);
+	ap_old = dap->ap_current;
+	dap_ap_select(dap, ap);
 
 	do
 	{
@@ -1189,26 +1189,26 @@ int dap_lookup_cs_component(struct adiv5_dap *dap, int apsel,
 		entry_offset += 4;
 	} while (romentry > 0);
 
-	dap_ap_select(dap, apselold);
+	dap_ap_select(dap, ap_old);
 
 	return retval;
 }
 
 static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *dap, int apsel)
+		struct adiv5_dap *dap, int ap)
 {
 	int retval;
 	uint32_t dbgbase, apid;
 	int romtable_present = 0;
 	uint8_t mem_ap;
-	uint32_t apselold;
+	uint32_t ap_old;
 
-	retval = dap_get_debugbase(dap, apsel, &dbgbase, &apid);
+	retval = dap_get_debugbase(dap, ap, &dbgbase, &apid);
 	if (retval != ERROR_OK)
 		return retval;
 
-	apselold = dap->apsel;
-	dap_ap_select(dap, apsel);
+	ap_old = dap->ap_current;
+	dap_ap_select(dap, ap);
 
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
 	mem_ap = ((apid&0x10000) && ((apid&0x0F) != 0));
@@ -1240,7 +1240,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	}
 	else
 	{
-		command_print(cmd_ctx, "No AP found at this apsel 0x%x", apsel);
+		command_print(cmd_ctx, "No AP found at this ap 0x%x", ap);
 	}
 
 	romtable_present = ((mem_ap) && (dbgbase != 0xFFFFFFFF));
@@ -1602,7 +1602,7 @@ static int dap_info_command(struct command_context *cmd_ctx,
 	{
 		command_print(cmd_ctx, "\tNo ROM table present");
 	}
-	dap_ap_select(dap, apselold);
+	dap_ap_select(dap, ap_old);
 
 	return ERROR_OK;
 }
@@ -1634,10 +1634,9 @@ COMMAND_HANDLER(dap_baseaddr_command)
 	struct arm *arm = target_to_arm(target);
 	struct adiv5_dap *dap = arm->dap;
 
-	uint32_t apsel, apselsave, baseaddr;
+	uint32_t apsel, baseaddr;
 	int retval;
 
-	apselsave = dap->apsel;
 	switch (CMD_ARGC) {
 	case 0:
 		apsel = dap->apsel;
@@ -1652,8 +1651,7 @@ COMMAND_HANDLER(dap_baseaddr_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
+	dap_ap_select(dap, apsel);
 
 	/* NOTE:  assumes we're talking to a MEM-AP, which
 	 * has a base address.  There are other kinds of AP,
@@ -1669,9 +1667,6 @@ COMMAND_HANDLER(dap_baseaddr_command)
 
 	command_print(CMD_CTX, "0x%8.8" PRIx32, baseaddr);
 
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
-
 	return retval;
 }
 
@@ -1724,7 +1719,9 @@ COMMAND_HANDLER(dap_apsel_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
+	dap->apsel = apsel;
 	dap_ap_select(dap, apsel);
+
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
 	if (retval != ERROR_OK)
 		return retval;
@@ -1744,10 +1741,9 @@ COMMAND_HANDLER(dap_apid_command)
 	struct arm *arm = target_to_arm(target);
 	struct adiv5_dap *dap = arm->dap;
 
-	uint32_t apsel, apselsave, apid;
+	uint32_t apsel, apid;
 	int retval;
 
-	apselsave = dap->apsel;
 	switch (CMD_ARGC) {
 	case 0:
 		apsel = dap->apsel;
@@ -1762,8 +1758,7 @@ COMMAND_HANDLER(dap_apid_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	if (apselsave != apsel)
-		dap_ap_select(dap, apsel);
+	dap_ap_select(dap, apsel);
 
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
 	if (retval != ERROR_OK)
@@ -1773,8 +1768,6 @@ COMMAND_HANDLER(dap_apid_command)
 		return retval;
 
 	command_print(CMD_CTX, "0x%8.8" PRIx32, apid);
-	if (apselsave != apsel)
-		dap_ap_select(dap, apselsave);
 
 	return retval;
 }
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index b6c16b7..03a75f4 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -141,13 +141,16 @@ struct adiv5_dap
 	/* Control config */
 	uint32_t dp_ctrl_stat;
 
+
+	uint32_t apsel;
+
 	/**
 	 * Cache for DP_SELECT bits identifying the current AP.  A DAP may
 	 * connect to multiple APs, such as one MEM-AP for general access,
 	 * another reserved for accessing debug modules, and a JTAG-DP.
 	 * "-1" indicates no cached value.
 	 */
-	uint32_t apsel;
+	uint32_t ap_current;
 
 	/**
 	 * Cache for DP_SELECT bits identifying the current four-word AP
@@ -344,11 +347,11 @@ static inline int dap_run(struct adiv5_dap *dap)
 /** Accessor for currently selected DAP-AP number (0..255) */
 static inline uint8_t dap_ap_get_select(struct adiv5_dap *swjdp)
 {
-	return (uint8_t)(swjdp ->apsel >> 24);
+	return (uint8_t)(swjdp ->ap_current >> 24);
 }
 
 /* AP selection applies to future AP transactions */
-void dap_ap_select(struct adiv5_dap *dap,uint8_t apsel);
+void dap_ap_select(struct adiv5_dap *dap,uint8_t ap);
 
 /* Queued AP transactions */
 int dap_setup_accessport(struct adiv5_dap *swjdp,
@@ -382,30 +385,30 @@ int mem_ap_write_buf_u32(struct adiv5_dap *swjdp,
 
 
 /* Queued MEM-AP memory mapped single word transfers with selection of ap */
-int mem_ap_sel_read_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t *value);
-int mem_ap_sel_write_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t value);
 
 /* Synchronous MEM-AP memory mapped single word transfers with selection of ap */
-int mem_ap_sel_read_atomic_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t *value);
-int mem_ap_sel_write_atomic_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint32_t address, uint32_t value);
 
 /* MEM-AP memory mapped bus block transfers with selection of ap */
-int mem_ap_sel_read_buf_u8(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_buf_u8(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_sel_read_buf_u16(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_buf_u16(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_sel_read_buf_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_read_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address);
 
-int mem_ap_sel_write_buf_u8(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_buf_u8(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_sel_write_buf_u16(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_buf_u16(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address);
-int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t apsel,
+int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t ap,
 		uint8_t *buffer, int count, uint32_t address);
 
 
@@ -414,11 +417,11 @@ int mem_ap_sel_write_buf_u32(struct adiv5_dap *swjdp, uint8_t apsel,
 int ahbap_debugport_init(struct adiv5_dap *swjdp);
 
 /* Probe the AP for ROM Table location */
-int dap_get_debugbase(struct adiv5_dap *dap, int apsel,
+int dap_get_debugbase(struct adiv5_dap *dap, int ap,
 			uint32_t *dbgbase, uint32_t *apid);
 
 /* Lookup CoreSight component */
-int dap_lookup_cs_component(struct adiv5_dap *dap, int apsel,
+int dap_lookup_cs_component(struct adiv5_dap *dap, int ap,
 			uint32_t dbgbase, uint8_t type, uint32_t *addr);
 
 struct target;
diff --git a/src/target/cortex_a9.c b/src/target/cortex_a9.c
index 95bb07f..ce72ecd 100644
--- a/src/target/cortex_a9.c
+++ b/src/target/cortex_a9.c
@@ -1462,7 +1462,7 @@ static int cortex_a9_read_phys_memory(struct target *target,
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
-	uint8_t apsel = dap_ap_get_select(swjdp);
+	uint8_t apsel = swjdp->apsel;
 
 	LOG_DEBUG("Reading memory at real address 0x%x; size %d; count %d", address, size, count);
 
@@ -1591,15 +1591,16 @@ static int cortex_a9_write_phys_memory(struct target *target,
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
 	int retval = ERROR_INVALID_ARGUMENTS;
+	uint8_t apsel = swjdp->apsel;
 
 	LOG_DEBUG("Writing memory to real address 0x%x; size %d; count %d", address, size, count);
 
 	if (count && buffer) {
-		uint8_t apsel = dap_ap_get_select(swjdp);
 
 		if ( apsel == swjdp_memoryap ) {
 
 			/* write memory through AHB-AP */
+
 			switch (size) {
 				case 4:
 					retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c |    2 +-
 src/target/arm_adi_v5.c  |  107 +++++++++++++++++++++------------------------
 src/target/arm_adi_v5.h  |   33 ++++++++------
 src/target/cortex_a9.c   |    5 +-
 4 files changed, 72 insertions(+), 75 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb 18 08:07:56 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Feb 2011 07:07:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-762-g578294d
Message-ID: <mailman.9.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  578294dbdd93ab79a6ecc1561c52a974d1b588af (commit)
      from  fa93174a56c0aca1201bebf88795d6fe31c18aa1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 578294dbdd93ab79a6ecc1561c52a974d1b588af
Author: Luca Ellero <lroluk at gmail.com>
Date:   Thu Feb 17 20:51:32 2011 +0000

    stm32: add ID for medium density device Rev Z
    
    stm32-discovery evaluation board (STM32F100RBTB6):
    reading device id register (0xE0042000) returns 0x10010420
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/tcl/target/stm32.cfg b/tcl/target/stm32.cfg
index eef1269..9879c04 100644
--- a/tcl/target/stm32.cfg
+++ b/tcl/target/stm32.cfg
@@ -48,17 +48,18 @@ if { [info exists BSTAPID ] } {
   set _BSTAPID2 0x06410041
   # Medium density devices, Rev B and Rev Z
   set _BSTAPID3 0x16410041
+  set _BSTAPID4 0x06420041
   # High density devices, Rev A
-  set _BSTAPID4 0x06414041
+  set _BSTAPID5 0x06414041
   # Connectivity line devices, Rev A and Rev Z
-  set _BSTAPID5 0x06418041
+  set _BSTAPID6 0x06418041
   # XL line devices, Rev A
-  set _BSTAPID6 0x06430041
+  set _BSTAPID7 0x06430041
 }
 jtag newtap $_CHIPNAME bs -irlen 5 -expected-id $_BSTAPID1 \
 	-expected-id $_BSTAPID2 -expected-id $_BSTAPID3 \
 	-expected-id $_BSTAPID4 -expected-id $_BSTAPID5 \
-	-expected-id $_BSTAPID6
+	-expected-id $_BSTAPID6 -expected-id $_BSTAPID7
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/stm32.cfg |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb 18 13:54:05 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Feb 2011 12:54:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-763-g2bd6a47
Message-ID: <mailman.10.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2bd6a4795a2c4096aab614d729fe189b67b78d44 (commit)
      from  578294dbdd93ab79a6ecc1561c52a974d1b588af (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2bd6a4795a2c4096aab614d729fe189b67b78d44
Author: SimonQian <SimonQian at SimonQian.com>
Date:   Fri Feb 18 20:39:55 2011 +0800

    fix compile error under MinGW

diff --git a/src/flash/nand/ecc.c b/src/flash/nand/ecc.c
index b403997..b3623d4 100644
--- a/src/flash/nand/ecc.c
+++ b/src/flash/nand/ecc.c
@@ -121,12 +121,12 @@ int nand_calculate_ecc(struct nand_device *nand, const uint8_t *dat, uint8_t *ec
 	return 0;
 }
 
-static inline int countbits(uint32_t byte)
+static inline int countbits(uint32_t b)
 {
 	int res = 0;
 
-	for (;byte; byte >>= 1)
-		res += byte & 0x01;
+	for (;b; b >>= 1)
+		res += b & 0x01;
 	return res;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/ecc.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb 21 07:52:04 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 21 Feb 2011 06:52:04 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-764-g6ebac1b
Message-ID: <mailman.11.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6ebac1b829fe1a04cae6fa29bf67d53c4fbe2023 (commit)
      from  2bd6a4795a2c4096aab614d729fe189b67b78d44 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6ebac1b829fe1a04cae6fa29bf67d53c4fbe2023
Author: Edgar Grimberg <edgar.grimberg at gmail.com>
Date:   Mon Feb 21 00:07:39 2011 +0100

    gitmodules: use http protocol for git2cl module
    
    Use the http protocol for git2cl module, as it makes it easier for the
    firewall safe mirror to keep all submodules firewall safe.
    
    Signed-off-by: Edgar Grimberg <edgar.grimberg at gmail.com>

diff --git a/.gitmodules b/.gitmodules
index 0b6ed6f..f23a5d4 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,6 +1,6 @@
 [submodule "tools/git2cl"]
 	path = tools/git2cl
-	url = git://repo.or.cz/git2cl.git
+	url = http://repo.or.cz/r/git2cl.git
 [submodule "jimtcl"]
 	path = jimtcl
 	url = http://repo.or.cz/r/jimtcl.git

-----------------------------------------------------------------------

Summary of changes:
 .gitmodules |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb 21 21:30:27 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 21 Feb 2011 20:30:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-765-g403e239
Message-ID: <mailman.12.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  403e239960758bed7888496c3d1e3faf91b49a6c (commit)
      from  6ebac1b829fe1a04cae6fa29bf67d53c4fbe2023 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 403e239960758bed7888496c3d1e3faf91b49a6c
Author: Mathias K <kesmtp at freenet.de>
Date:   Sun Feb 20 11:12:53 2011 +0100

    dsp563xx: rudimentary gdb support
    
    This patch add rudimentary gdb support. The gdb register list
    order is corrected. All registers are now 32bit width. Events are
    send to signalize gdb the current target status. Resume and step
    function was corrected to consider a modified pc register. Read/write
    memory now support L memory type, this means a memory with alternating
    y/x memory words. The memspace variable, used by gdb, is now observed
    before a default memory access is initiated. Dummy functions for breakpoint
    and watchpoint are added.

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 8e1d6f7..cb2025e 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -149,6 +149,63 @@ static struct once_reg once_regs[] = {
 //      {25,0x1f,24,"NRSEL",0},
 };
 
+enum dsp563xx_reg_idx {
+	DSP563XX_REG_IDX_R0=0,
+	DSP563XX_REG_IDX_R1=1,
+	DSP563XX_REG_IDX_R2=2,
+	DSP563XX_REG_IDX_R3=3,
+	DSP563XX_REG_IDX_R4=4,
+	DSP563XX_REG_IDX_R5=5,
+	DSP563XX_REG_IDX_R6=6,
+	DSP563XX_REG_IDX_R7=7,
+	DSP563XX_REG_IDX_N0=8,
+	DSP563XX_REG_IDX_N1=9,
+	DSP563XX_REG_IDX_N2=10,
+	DSP563XX_REG_IDX_N3=11,
+	DSP563XX_REG_IDX_N4=12,
+	DSP563XX_REG_IDX_N5=13,
+	DSP563XX_REG_IDX_N6=14,
+	DSP563XX_REG_IDX_N7=15,
+	DSP563XX_REG_IDX_M0=16,
+	DSP563XX_REG_IDX_M1=17,
+	DSP563XX_REG_IDX_M2=18,
+	DSP563XX_REG_IDX_M3=19,
+	DSP563XX_REG_IDX_M4=20,
+	DSP563XX_REG_IDX_M5=21,
+	DSP563XX_REG_IDX_M6=22,
+	DSP563XX_REG_IDX_M7=23,
+	DSP563XX_REG_IDX_X0=24,
+	DSP563XX_REG_IDX_X1=25,
+	DSP563XX_REG_IDX_Y0=26,
+	DSP563XX_REG_IDX_Y1=27,
+	DSP563XX_REG_IDX_A0=28,
+	DSP563XX_REG_IDX_A1=29,
+	DSP563XX_REG_IDX_A2=30,
+	DSP563XX_REG_IDX_B0=31,
+	DSP563XX_REG_IDX_B1=32,
+	DSP563XX_REG_IDX_B2=33,
+	DSP563XX_REG_IDX_SSH=34,
+	DSP563XX_REG_IDX_SSL=35,
+	DSP563XX_REG_IDX_SP=36,
+	DSP563XX_REG_IDX_EP=37,
+	DSP563XX_REG_IDX_SZ=38,
+	DSP563XX_REG_IDX_SC=39,
+	DSP563XX_REG_IDX_PC=40,
+	DSP563XX_REG_IDX_SR=41,
+	DSP563XX_REG_IDX_OMR=42,
+	DSP563XX_REG_IDX_LA=43,
+	DSP563XX_REG_IDX_LC=44,
+	DSP563XX_REG_IDX_VBA=45,
+	DSP563XX_REG_IDX_IPRC=46,
+	DSP563XX_REG_IDX_IPRP=47,
+	DSP563XX_REG_IDX_BCR=48,
+	DSP563XX_REG_IDX_DCR=49,
+	DSP563XX_REG_IDX_AAR0=50,
+	DSP563XX_REG_IDX_AAR1=51,
+	DSP563XX_REG_IDX_AAR2=52,
+	DSP563XX_REG_IDX_AAR3=53,
+};
+
 static const struct
 {
 	unsigned id;
@@ -161,98 +218,77 @@ static const struct
 {
 	/* *INDENT-OFF* */
 	/* address registers */
-	{ 0, "r0", 24, 0x10, ASM_REG_W_R0},
-	{ 1, "r1", 24, 0x11, ASM_REG_W_R1},
-	{ 2, "r2", 24, 0x12, ASM_REG_W_R2},
-	{ 3, "r3", 24, 0x13, ASM_REG_W_R3},
-	{ 4, "r4", 24, 0x14, ASM_REG_W_R4},
-	{ 5, "r5", 24, 0x15, ASM_REG_W_R5},
-	{ 6, "r6", 24, 0x16, ASM_REG_W_R6},
-	{ 7, "r7", 24, 0x17, ASM_REG_W_R7},
+	{DSP563XX_REG_IDX_R0, "r0", 24, 0x10, ASM_REG_W_R0},
+	{DSP563XX_REG_IDX_R1, "r1", 24, 0x11, ASM_REG_W_R1},
+	{DSP563XX_REG_IDX_R2, "r2", 24, 0x12, ASM_REG_W_R2},
+	{DSP563XX_REG_IDX_R3, "r3", 24, 0x13, ASM_REG_W_R3},
+	{DSP563XX_REG_IDX_R4, "r4", 24, 0x14, ASM_REG_W_R4},
+	{DSP563XX_REG_IDX_R5, "r5", 24, 0x15, ASM_REG_W_R5},
+	{DSP563XX_REG_IDX_R6, "r6", 24, 0x16, ASM_REG_W_R6},
+	{DSP563XX_REG_IDX_R7, "r7", 24, 0x17, ASM_REG_W_R7},
 	/* offset registers */
-	{ 8, "n0", 24, 0x18, ASM_REG_W_N0},
-	{ 9, "n1", 24, 0x19, ASM_REG_W_N1},
-	{10, "n2", 24, 0x1a, ASM_REG_W_N2},
-	{11, "n3", 24, 0x1b, ASM_REG_W_N3},
-	{12, "n4", 24, 0x1c, ASM_REG_W_N4},
-	{13, "n5", 24, 0x1d, ASM_REG_W_N5},
-	{14, "n6", 24, 0x1e, ASM_REG_W_N6},
-	{15, "n7", 24, 0x1f, ASM_REG_W_N7},
+	{DSP563XX_REG_IDX_N0, "n0", 24, 0x18, ASM_REG_W_N0},
+	{DSP563XX_REG_IDX_N1, "n1", 24, 0x19, ASM_REG_W_N1},
+	{DSP563XX_REG_IDX_N2, "n2", 24, 0x1a, ASM_REG_W_N2},
+	{DSP563XX_REG_IDX_N3, "n3", 24, 0x1b, ASM_REG_W_N3},
+	{DSP563XX_REG_IDX_N4, "n4", 24, 0x1c, ASM_REG_W_N4},
+	{DSP563XX_REG_IDX_N5, "n5", 24, 0x1d, ASM_REG_W_N5},
+	{DSP563XX_REG_IDX_N6, "n6", 24, 0x1e, ASM_REG_W_N6},
+	{DSP563XX_REG_IDX_N7, "n7", 24, 0x1f, ASM_REG_W_N7},
 	/* modifier registers */
-	{16, "m0", 24, 0x20, ASM_REG_W_M0},
-	{17, "m1", 24, 0x21, ASM_REG_W_M1},
-	{18, "m2", 24, 0x22, ASM_REG_W_M2},
-	{19, "m3", 24, 0x23, ASM_REG_W_M3},
-	{20, "m4", 24, 0x24, ASM_REG_W_M4},
-	{21, "m5", 24, 0x25, ASM_REG_W_M5},
-	{22, "m6", 24, 0x26, ASM_REG_W_M6},
-	{23, "m7", 24, 0x27, ASM_REG_W_M7},
+	{DSP563XX_REG_IDX_M0, "m0", 24, 0x20, ASM_REG_W_M0},
+	{DSP563XX_REG_IDX_M1, "m1", 24, 0x21, ASM_REG_W_M1},
+	{DSP563XX_REG_IDX_M2, "m2", 24, 0x22, ASM_REG_W_M2},
+	{DSP563XX_REG_IDX_M3, "m3", 24, 0x23, ASM_REG_W_M3},
+	{DSP563XX_REG_IDX_M4, "m4", 24, 0x24, ASM_REG_W_M4},
+	{DSP563XX_REG_IDX_M5, "m5", 24, 0x25, ASM_REG_W_M5},
+	{DSP563XX_REG_IDX_M6, "m6", 24, 0x26, ASM_REG_W_M6},
+	{DSP563XX_REG_IDX_M7, "m7", 24, 0x27, ASM_REG_W_M7},
 	/* data alu input register */
-	{24, "x0", 24, 0x04, ASM_REG_W_X0},
-	{25, "x1", 24, 0x05, ASM_REG_W_X1},
-	{26, "y0", 24, 0x06, ASM_REG_W_Y0},
-	{27, "y1", 24, 0x07, ASM_REG_W_Y1},
+	{DSP563XX_REG_IDX_X0, "x0", 24, 0x04, ASM_REG_W_X0},
+	{DSP563XX_REG_IDX_X1, "x1", 24, 0x05, ASM_REG_W_X1},
+	{DSP563XX_REG_IDX_Y0, "y0", 24, 0x06, ASM_REG_W_Y0},
+	{DSP563XX_REG_IDX_Y1, "y1", 24, 0x07, ASM_REG_W_Y1},
 	/* data alu accumulator register */
-	{28, "a0", 24, 0x08, ASM_REG_W_A0},
-	{29, "a1", 24, 0x0c, ASM_REG_W_A1},
-	{30, "a2",  8, 0x0a, ASM_REG_W_A2},
-	{31, "b0", 24, 0x09, ASM_REG_W_B0},
-	{32, "b1", 24, 0x0d, ASM_REG_W_B1},
-	{33, "b2",  8, 0x0b, ASM_REG_W_B2},
+	{DSP563XX_REG_IDX_A0, "a0", 24, 0x08, ASM_REG_W_A0},
+	{DSP563XX_REG_IDX_A1, "a1", 24, 0x0c, ASM_REG_W_A1},
+	{DSP563XX_REG_IDX_A2, "a2",  8, 0x0a, ASM_REG_W_A2},
+	{DSP563XX_REG_IDX_B0, "b0", 24, 0x09, ASM_REG_W_B0},
+	{DSP563XX_REG_IDX_B1, "b1", 24, 0x0d, ASM_REG_W_B1},
+	{DSP563XX_REG_IDX_B2, "b2",  8, 0x0b, ASM_REG_W_B2},
 	/* stack */
-	{34, "ssh",24, 0x3c, ASM_REG_W_SSH},
-	{35, "ssl",24, 0x3d, ASM_REG_W_SSL},
-	{36, "sp", 24, 0x3b, ASM_REG_W_SP},
-	{37, "ep", 24, 0x2a, ASM_REG_W_EP},
-	{38, "sz", 24, 0x38, ASM_REG_W_SZ},
-	{39, "sc", 24, 0x31, ASM_REG_W_SC},
+	{DSP563XX_REG_IDX_SSH, "ssh",24, 0x3c, ASM_REG_W_SSH},
+	{DSP563XX_REG_IDX_SSL, "ssl",24, 0x3d, ASM_REG_W_SSL},
+	{DSP563XX_REG_IDX_SP, "sp", 24, 0x3b, ASM_REG_W_SP},
+	{DSP563XX_REG_IDX_EP, "ep", 24, 0x2a, ASM_REG_W_EP},
+	{DSP563XX_REG_IDX_SZ, "sz", 24, 0x38, ASM_REG_W_SZ},
+	{DSP563XX_REG_IDX_SC, "sc", 24, 0x31, ASM_REG_W_SC},
 	/* system */
-	{40, "pc", 24, 0x00, ASM_REG_W_PC},
-	{41, "sr", 24, 0x39, ASM_REG_W_SR},
-	{42, "omr",24, 0x3a, ASM_REG_W_OMR},
-	{43, "la", 24, 0x3e, ASM_REG_W_LA},
-	{44, "lc", 24, 0x3f, ASM_REG_W_LC},
+	{DSP563XX_REG_IDX_PC, "pc", 24, 0x00, ASM_REG_W_PC},
+	{DSP563XX_REG_IDX_SR, "sr", 24, 0x39, ASM_REG_W_SR},
+	{DSP563XX_REG_IDX_OMR, "omr",24, 0x3a, ASM_REG_W_OMR},
+	{DSP563XX_REG_IDX_LA, "la", 24, 0x3e, ASM_REG_W_LA},
+	{DSP563XX_REG_IDX_LC, "lc", 24, 0x3f, ASM_REG_W_LC},
 	/* interrupt */
-	{45, "vba", 24, 0x30, ASM_REG_W_VBA},
-	{46, "iprc",24, 0x00, ASM_REG_W_IPRC},
-	{47, "iprp",24, 0x00, ASM_REG_W_IPRP},
+	{DSP563XX_REG_IDX_VBA, "vba", 24, 0x30, ASM_REG_W_VBA},
+	{DSP563XX_REG_IDX_IPRC, "iprc",24, 0x00, ASM_REG_W_IPRC},
+	{DSP563XX_REG_IDX_IPRP, "iprp",24, 0x00, ASM_REG_W_IPRP},
 	/* port a */
-	{48, "bcr", 24, 0x00, ASM_REG_W_BCR},
-	{49, "dcr", 24, 0x00, ASM_REG_W_DCR},
-	{50, "aar0",24, 0x00, ASM_REG_W_AAR0},
-	{51, "aar1",24, 0x00, ASM_REG_W_AAR1},
-	{52, "aar2",24, 0x00, ASM_REG_W_AAR2},
-	{53, "aar3",24, 0x00, ASM_REG_W_AAR3},
+	{DSP563XX_REG_IDX_BCR, "bcr", 24, 0x00, ASM_REG_W_BCR},
+	{DSP563XX_REG_IDX_DCR, "dcr", 24, 0x00, ASM_REG_W_DCR},
+	{DSP563XX_REG_IDX_AAR0, "aar0",24, 0x00, ASM_REG_W_AAR0},
+	{DSP563XX_REG_IDX_AAR1, "aar1",24, 0x00, ASM_REG_W_AAR1},
+	{DSP563XX_REG_IDX_AAR2, "aar2",24, 0x00, ASM_REG_W_AAR2},
+	{DSP563XX_REG_IDX_AAR3, "aar3",24, 0x00, ASM_REG_W_AAR3},
 	/* *INDENT-ON* */
 };
 
-#define REG_NUM_R0	0
-#define REG_NUM_R1	1
-#define REG_NUM_N0	8
-#define REG_NUM_N1	9
-#define REG_NUM_M0	16
-#define REG_NUM_M1	17
-#define REG_NUM_SSH	34
-#define REG_NUM_SSL	35
-#define REG_NUM_SP	36
-#define REG_NUM_EP	37
-#define REG_NUM_SC	39
-#define REG_NUM_PC	40
-#define REG_NUM_SR	41
-#define REG_NUM_IPRC	46
-#define REG_NUM_IPRP	47
-#define REG_NUM_BCR	48
-#define REG_NUM_DCR	49
-#define REG_NUM_AAR0	50
-#define REG_NUM_AAR1	51
-#define REG_NUM_AAR2	52
-#define REG_NUM_AAR3	53
-
 enum memory_type
 {
 	MEM_X = 0,
 	MEM_Y = 1,
 	MEM_P = 2,
+	MEM_L = 3,
 };
 
 #define INSTR_JUMP	0x0AF080
@@ -267,6 +303,24 @@ enum memory_type
  */
 #define INSTR_MOVEP_REG_HIO(s,w,d,p)   (0x084000 | ((s & 1)<<16) | ((w&1)<<15) | ((d & 0x3f)<<8) | (p & 0x3f))
 
+/* the gdb register list is send in this order */
+uint8_t gdb_reg_list_idx[] = {
+	DSP563XX_REG_IDX_X1, DSP563XX_REG_IDX_X0, DSP563XX_REG_IDX_Y1, DSP563XX_REG_IDX_Y0,
+	DSP563XX_REG_IDX_A2, DSP563XX_REG_IDX_A1, DSP563XX_REG_IDX_A0, DSP563XX_REG_IDX_B2,
+	DSP563XX_REG_IDX_B1, DSP563XX_REG_IDX_B0, DSP563XX_REG_IDX_PC, DSP563XX_REG_IDX_SR,
+	DSP563XX_REG_IDX_OMR,DSP563XX_REG_IDX_LA, DSP563XX_REG_IDX_LC, DSP563XX_REG_IDX_SSH,
+	DSP563XX_REG_IDX_SSL,DSP563XX_REG_IDX_SP, DSP563XX_REG_IDX_EP, DSP563XX_REG_IDX_SZ,
+	DSP563XX_REG_IDX_SC, DSP563XX_REG_IDX_VBA,DSP563XX_REG_IDX_IPRC, DSP563XX_REG_IDX_IPRP,
+	DSP563XX_REG_IDX_BCR,DSP563XX_REG_IDX_DCR,DSP563XX_REG_IDX_AAR0,DSP563XX_REG_IDX_AAR1,
+	DSP563XX_REG_IDX_AAR2,DSP563XX_REG_IDX_AAR3,DSP563XX_REG_IDX_R0,DSP563XX_REG_IDX_R1,
+	DSP563XX_REG_IDX_R2, DSP563XX_REG_IDX_R3, DSP563XX_REG_IDX_R4, DSP563XX_REG_IDX_R5,
+	DSP563XX_REG_IDX_R6, DSP563XX_REG_IDX_R7, DSP563XX_REG_IDX_N0, DSP563XX_REG_IDX_N1,
+	DSP563XX_REG_IDX_N2, DSP563XX_REG_IDX_N3, DSP563XX_REG_IDX_N4, DSP563XX_REG_IDX_N5,
+	DSP563XX_REG_IDX_N6, DSP563XX_REG_IDX_N7, DSP563XX_REG_IDX_M0, DSP563XX_REG_IDX_M1,
+	DSP563XX_REG_IDX_M2, DSP563XX_REG_IDX_M3, DSP563XX_REG_IDX_M4, DSP563XX_REG_IDX_M5,
+	DSP563XX_REG_IDX_M6, DSP563XX_REG_IDX_M7,
+};
+
 static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int *reg_list_size)
 {
 	int i;
@@ -285,7 +339,7 @@ static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_lis
 
 	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
 	{
-		(*reg_list)[i] = &dsp563xx->core_cache->reg_list[i];
+		(*reg_list)[i] = &dsp563xx->core_cache->reg_list[gdb_reg_list_idx[i]];
 	}
 
 	return ERROR_OK;
@@ -397,7 +451,7 @@ static void dsp563xx_build_reg_cache(struct target *target)
 		arch_info[i].target = target;
 		arch_info[i].dsp563xx_common = dsp563xx;
 		reg_list[i].name = dsp563xx_regs[i].name;
-		reg_list[i].size = dsp563xx_regs[i].bits;
+		reg_list[i].size = 32; //dsp563xx_regs[i].bits;
 		reg_list[i].value = calloc(1, 4);
 		reg_list[i].dirty = 0;
 		reg_list[i].valid = 0;
@@ -416,8 +470,8 @@ static int dsp563xx_reg_read_high_io(struct target *target, uint32_t instr_mask,
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	/* we use r0 to store temporary data */
-	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
-		dsp563xx->read_core_reg(target, REG_NUM_R0);
+	if (!dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].valid)
+		dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_R0);
 
 	/* move source memory to r0 */
 	instr = INSTR_MOVEP_REG_HIO(MEM_X, 0, EAME_R0, instr_mask);
@@ -431,7 +485,7 @@ static int dsp563xx_reg_read_high_io(struct target *target, uint32_t instr_mask,
 	if ((err = dsp563xx_once_reg_read(target->tap, 1, DSP563XX_ONCE_OGDBR, data)) != ERROR_OK)
 		return err;
 	/* r0 is no longer valid on target */
-	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].dirty = 1;
 
 	return ERROR_OK;
 }
@@ -443,8 +497,8 @@ static int dsp563xx_reg_write_high_io(struct target *target, uint32_t instr_mask
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	/* we use r0 to store temporary data */
-	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
-		dsp563xx->read_core_reg(target, REG_NUM_R0);
+	if (!dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].valid)
+		dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_R0);
 
 	/* move data to r0 */
 	if ((err = dsp563xx_once_execute_dw_ir(target->tap, 0, 0x60F400, data)) != ERROR_OK)
@@ -455,7 +509,7 @@ static int dsp563xx_reg_write_high_io(struct target *target, uint32_t instr_mask
 		return err;
 
 	/* r0 is no longer valid on target */
-	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].dirty = 1;
 
 	return ERROR_OK;
 }
@@ -490,7 +544,7 @@ static int dsp563xx_reg_pc_read(struct target *target)
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	/* pc was changed, nothing todo */
-	if (dsp563xx->core_cache->reg_list[REG_NUM_PC].dirty)
+	if (dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].dirty)
 		return ERROR_OK;
 
 	/* conditional branch check */
@@ -501,26 +555,26 @@ static int dsp563xx_reg_pc_read(struct target *target)
 			LOG_DEBUG("%s conditional branch not supported yet", __FUNCTION__);
 
 			/* TODO: use disassembly to set correct pc offset */
-			dsp563xx->core_regs[REG_NUM_PC] = (once_regs[ONCE_REG_IDX_OPABF11].reg >> 1) & 0x00FFFFFF;
+			dsp563xx->core_regs[DSP563XX_REG_IDX_PC] = (once_regs[ONCE_REG_IDX_OPABF11].reg >> 1) & 0x00FFFFFF;
 		}
 		else
 		{
 			if ( once_regs[ONCE_REG_IDX_OPABEX].reg == once_regs[ONCE_REG_IDX_OPABFR].reg )
 			{
-				dsp563xx->core_regs[REG_NUM_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg;
+				dsp563xx->core_regs[DSP563XX_REG_IDX_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg;
 			}
 			else
 			{
-				dsp563xx->core_regs[REG_NUM_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg - 1;
+				dsp563xx->core_regs[DSP563XX_REG_IDX_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg - 1;
 			}
 		}
 	}
 	else
 	{
-		dsp563xx->core_regs[REG_NUM_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg;
+		dsp563xx->core_regs[DSP563XX_REG_IDX_PC] = once_regs[ONCE_REG_IDX_OPABEX].reg;
 	}
 
-	dsp563xx->read_core_reg(target, REG_NUM_PC);
+	dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_PC);
 
 	return ERROR_OK;
 }
@@ -532,27 +586,27 @@ static int dsp563xx_reg_ssh_read(struct target *target)
 	struct dsp563xx_core_reg *arch_info;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
-	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SSH].arch_info;
+	arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_SSH].arch_info;
 
 	/* get a valid stack pointer */
-	if ((err = dsp563xx_read_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SP, 0)) != ERROR_OK)
 		return err;
-	sp = dsp563xx->core_regs[REG_NUM_SP];
-	if ((err = dsp563xx_write_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+	sp = dsp563xx->core_regs[DSP563XX_REG_IDX_SP];
+	if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_SP, 0)) != ERROR_OK)
 		return err;
 
 	/* get a valid stack count */
-	if ((err = dsp563xx_read_register(target, REG_NUM_SC, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SC, 0)) != ERROR_OK)
 		return err;
-	sc = dsp563xx->core_regs[REG_NUM_SC];
-	if ((err = dsp563xx_write_register(target, REG_NUM_SC, 0)) != ERROR_OK)
+	sc = dsp563xx->core_regs[DSP563XX_REG_IDX_SC];
+	if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_SC, 0)) != ERROR_OK)
 		return err;
 
 	/* get a valid extended pointer */
-	if ((err = dsp563xx_read_register(target, REG_NUM_EP, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_EP, 0)) != ERROR_OK)
 		return err;
-	ep = dsp563xx->core_regs[REG_NUM_EP];
-	if ((err = dsp563xx_write_register(target, REG_NUM_EP, 0)) != ERROR_OK)
+	ep = dsp563xx->core_regs[DSP563XX_REG_IDX_EP];
+	if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_EP, 0)) != ERROR_OK)
 		return err;
 
 	if (!sp)
@@ -564,16 +618,16 @@ static int dsp563xx_reg_ssh_read(struct target *target)
 		if ((err = dsp563xx_reg_read(target, arch_info->eame, &sp)) != ERROR_OK)
 			return err;
 
-		if ((err = dsp563xx_write_register(target, REG_NUM_SC, 1)) != ERROR_OK)
+		if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_SC, 1)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_write_register(target, REG_NUM_SP, 1)) != ERROR_OK)
+		if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_SP, 1)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_write_register(target, REG_NUM_EP, 1)) != ERROR_OK)
+		if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_EP, 1)) != ERROR_OK)
 			return err;
 	}
 
-	dsp563xx->core_regs[REG_NUM_SSH] = sp;
-	dsp563xx->read_core_reg(target, REG_NUM_SSH);
+	dsp563xx->core_regs[DSP563XX_REG_IDX_SSH] = sp;
+	dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_SSH);
 
 	return ERROR_OK;
 }
@@ -585,29 +639,29 @@ static int dsp563xx_reg_ssh_write(struct target *target)
 	struct dsp563xx_core_reg *arch_info;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
-	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SSH].arch_info;
+	arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_SSH].arch_info;
 
 	/* get a valid stack pointer */
-	if ((err = dsp563xx_read_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SP, 0)) != ERROR_OK)
 		return err;
-	sp = dsp563xx->core_regs[REG_NUM_SP];
+	sp = dsp563xx->core_regs[DSP563XX_REG_IDX_SP];
 
 	if (sp)
 	{
 		sp--;
 		/* write new stackpointer */
-		dsp563xx->core_regs[REG_NUM_SP] = sp;
-		if ((err = dsp563xx->read_core_reg(target, REG_NUM_SP)) != ERROR_OK)
+		dsp563xx->core_regs[DSP563XX_REG_IDX_SP] = sp;
+		if ((err = dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_SP)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_write_register(target, REG_NUM_SP, 1)) != ERROR_OK)
+		if ((err = dsp563xx_write_register(target, DSP563XX_REG_IDX_SP, 1)) != ERROR_OK)
 			return err;
 
-		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, dsp563xx->core_regs[REG_NUM_SSH])) != ERROR_OK)
+		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, dsp563xx->core_regs[DSP563XX_REG_IDX_SSH])) != ERROR_OK)
 			return err;
 
-		if ((err = dsp563xx_read_register(target, REG_NUM_SP, 1)) != ERROR_OK)
+		if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SP, 1)) != ERROR_OK)
 			return err;
-		if ((err = dsp563xx_read_register(target, REG_NUM_SSH, 1)) != ERROR_OK)
+		if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SSH, 1)) != ERROR_OK)
 			return err;
 	}
 
@@ -621,12 +675,12 @@ static int dsp563xx_reg_ssl_read(struct target *target)
 	struct dsp563xx_core_reg *arch_info;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
-	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SSL].arch_info;
+	arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_SSL].arch_info;
 
 	/* get a valid stack pointer */
-	if ((err = dsp563xx_read_register(target, REG_NUM_SP, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SP, 0)) != ERROR_OK)
 		return err;
-	sp = dsp563xx->core_regs[REG_NUM_SP];
+	sp = dsp563xx->core_regs[DSP563XX_REG_IDX_SP];
 
 	if (!sp)
 	{
@@ -638,8 +692,8 @@ static int dsp563xx_reg_ssl_read(struct target *target)
 			return err;
 	}
 
-	dsp563xx->core_regs[REG_NUM_SSL] = sp;
-	dsp563xx->read_core_reg(target, REG_NUM_SSL);
+	dsp563xx->core_regs[DSP563XX_REG_IDX_SSL] = sp;
+	dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_SSL);
 
 	return ERROR_OK;
 }
@@ -660,23 +714,23 @@ static int dsp563xx_read_register(struct target *target, int num, int force)
 
 		switch (arch_info->num)
 		{
-			case REG_NUM_SSH:
+			case DSP563XX_REG_IDX_SSH:
 				err = dsp563xx_reg_ssh_read(target);
 				break;
-			case REG_NUM_SSL:
+			case DSP563XX_REG_IDX_SSL:
 				err = dsp563xx_reg_ssl_read(target);
 				break;
-			case REG_NUM_PC:
+			case DSP563XX_REG_IDX_PC:
 				err = dsp563xx_reg_pc_read(target);
 				break;
-			case REG_NUM_IPRC:
-			case REG_NUM_IPRP:
-			case REG_NUM_BCR:
-			case REG_NUM_DCR:
-			case REG_NUM_AAR0:
-			case REG_NUM_AAR1:
-			case REG_NUM_AAR2:
-			case REG_NUM_AAR3:
+			case DSP563XX_REG_IDX_IPRC:
+			case DSP563XX_REG_IDX_IPRP:
+			case DSP563XX_REG_IDX_BCR:
+			case DSP563XX_REG_IDX_DCR:
+			case DSP563XX_REG_IDX_AAR0:
+			case DSP563XX_REG_IDX_AAR1:
+			case DSP563XX_REG_IDX_AAR2:
+			case DSP563XX_REG_IDX_AAR3:
 				err = dsp563xx_reg_read_high_io(target, arch_info->instr_mask, &data);
 				if (err == ERROR_OK)
 				{
@@ -716,29 +770,29 @@ static int dsp563xx_write_register(struct target *target, int num, int force)
 
 		switch (arch_info->num)
 		{
-			case REG_NUM_SSH:
+			case DSP563XX_REG_IDX_SSH:
 				err = dsp563xx_reg_ssh_write(target);
 				break;
-			case REG_NUM_PC:
+			case DSP563XX_REG_IDX_PC:
 				/* pc is updated on resume, no need to write it here */
 				break;
-			case REG_NUM_IPRC:
-			case REG_NUM_IPRP:
-			case REG_NUM_BCR:
-			case REG_NUM_DCR:
-			case REG_NUM_AAR0:
-			case REG_NUM_AAR1:
-			case REG_NUM_AAR2:
-			case REG_NUM_AAR3:
+			case DSP563XX_REG_IDX_IPRC:
+			case DSP563XX_REG_IDX_IPRP:
+			case DSP563XX_REG_IDX_BCR:
+			case DSP563XX_REG_IDX_DCR:
+			case DSP563XX_REG_IDX_AAR0:
+			case DSP563XX_REG_IDX_AAR1:
+			case DSP563XX_REG_IDX_AAR2:
+			case DSP563XX_REG_IDX_AAR3:
 				err = dsp563xx_reg_write_high_io(target, arch_info->instr_mask, dsp563xx->core_regs[num]);
 				break;
 			default:
 				err = dsp563xx_reg_write(target, arch_info->instr_mask, dsp563xx->core_regs[num]);
 
-				if ((err == ERROR_OK) && (arch_info->num == REG_NUM_SP))
+				if ((err == ERROR_OK) && (arch_info->num == DSP563XX_REG_IDX_SP))
 				{
-					dsp563xx->core_cache->reg_list[REG_NUM_SSH].valid = 0;
-					dsp563xx->core_cache->reg_list[REG_NUM_SSL].valid = 0;
+					dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_SSH].valid = 0;
+					dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_SSL].valid = 0;
 				}
 
 				break;
@@ -785,7 +839,7 @@ static void dsp563xx_invalidate_x_context(struct target *target, uint32_t addr_s
 	if ( addr_start < ASM_REG_W_AAR3 )
 		return;
 
-	for (i = REG_NUM_IPRC; i < DSP563XX_NUMCOREREGS; i++)
+	for (i = DSP563XX_REG_IDX_IPRC; i < DSP563XX_NUMCOREREGS; i++)
 	{
 		arch_info = dsp563xx->core_cache->reg_list[i].arch_info;
 
@@ -873,13 +927,13 @@ static int dsp563xx_debug_init(struct target *target)
 	if ((err = dsp563xx_debug_once_init(target)) != ERROR_OK)
 		return err;
 
-	arch_info = dsp563xx->core_cache->reg_list[REG_NUM_SR].arch_info;
+	arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_SR].arch_info;
 
 	/* check 24bit mode */
-	if ((err = dsp563xx_read_register(target, REG_NUM_SR, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_SR, 0)) != ERROR_OK)
 		return err;
 
-	sr = dsp563xx->core_regs[REG_NUM_SR];
+	sr = dsp563xx->core_regs[DSP563XX_REG_IDX_SR];
 
 	if (sr & (DSP563XX_SR_SA | DSP563XX_SR_SC))
 	{
@@ -887,49 +941,49 @@ static int dsp563xx_debug_init(struct target *target)
 
 		if ((err = dsp563xx_once_execute_dw_ir(target->tap, 1, arch_info->instr_mask, sr)) != ERROR_OK)
 			return err;
-		dsp563xx->core_cache->reg_list[REG_NUM_SR].dirty = 1;
+		dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_SR].dirty = 1;
 	}
 
-	if ((err = dsp563xx_read_register(target, REG_NUM_N0, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_N0, 0)) != ERROR_OK)
 		return err;
-	if ((err = dsp563xx_read_register(target, REG_NUM_N1, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_N1, 0)) != ERROR_OK)
 		return err;
-	if ((err = dsp563xx_read_register(target, REG_NUM_M0, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_M0, 0)) != ERROR_OK)
 		return err;
-	if ((err = dsp563xx_read_register(target, REG_NUM_M1, 0)) != ERROR_OK)
+	if ((err = dsp563xx_read_register(target, DSP563XX_REG_IDX_M1, 0)) != ERROR_OK)
 		return err;
 
-	if (dsp563xx->core_regs[REG_NUM_N0] != 0x000000)
+	if (dsp563xx->core_regs[DSP563XX_REG_IDX_N0] != 0x000000)
 	{
-		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_N0].arch_info;
+		arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_N0].arch_info;
 		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0x000000)) != ERROR_OK)
 			return err;
 	}
-	dsp563xx->core_cache->reg_list[REG_NUM_N0].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_N0].dirty = 1;
 
-	if (dsp563xx->core_regs[REG_NUM_N1] != 0x000000)
+	if (dsp563xx->core_regs[DSP563XX_REG_IDX_N1] != 0x000000)
 	{
-		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_N1].arch_info;
+		arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_N1].arch_info;
 		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0x000000)) != ERROR_OK)
 			return err;
 	}
-	dsp563xx->core_cache->reg_list[REG_NUM_N1].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_N1].dirty = 1;
 
-	if (dsp563xx->core_regs[REG_NUM_M0] != 0xffffff)
+	if (dsp563xx->core_regs[DSP563XX_REG_IDX_M0] != 0xffffff)
 	{
-		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_M0].arch_info;
+		arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_M0].arch_info;
 		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0xffffff)) != ERROR_OK)
 			return err;
 	}
-	dsp563xx->core_cache->reg_list[REG_NUM_M0].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_M0].dirty = 1;
 
-	if (dsp563xx->core_regs[REG_NUM_M1] != 0xffffff)
+	if (dsp563xx->core_regs[DSP563XX_REG_IDX_M1] != 0xffffff)
 	{
-		arch_info = dsp563xx->core_cache->reg_list[REG_NUM_M1].arch_info;
+		arch_info = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_M1].arch_info;
 		if ((err = dsp563xx_reg_write(target, arch_info->instr_mask, 0xffffff)) != ERROR_OK)
 			return err;
 	}
-	dsp563xx->core_cache->reg_list[REG_NUM_M1].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_M1].dirty = 1;
 
 	if ((err = dsp563xx_save_context(target)) != ERROR_OK)
 		return err;
@@ -965,9 +1019,12 @@ static int dsp563xx_poll(struct target *target)
 		if (target->state != TARGET_HALTED)
 		{
 			target->state = TARGET_HALTED;
+
 			if ((err = dsp563xx_debug_init(target)) != ERROR_OK)
 				return err;
 
+			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+
 			LOG_DEBUG("target->state: %s (%x)", target_state_name(target),once_status);
 		}
 	}
@@ -979,6 +1036,8 @@ static int dsp563xx_halt(struct target *target)
 {
 	int err;
 
+	LOG_DEBUG("%s", __FUNCTION__);
+
 	if (target->state == TARGET_HALTED)
 	{
 		LOG_DEBUG("target was already halted");
@@ -993,7 +1052,7 @@ static int dsp563xx_halt(struct target *target)
 	if ((err = dsp563xx_jtag_debug_request(target)) != ERROR_OK)
 		return err;
 
-	LOG_DEBUG("%s", __FUNCTION__);
+	target->debug_reason = DBG_REASON_DBGRQ;
 
 	return ERROR_OK;
 }
@@ -1001,9 +1060,24 @@ static int dsp563xx_halt(struct target *target)
 static int dsp563xx_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	int err;
+	struct dsp563xx_core_reg *dsp563xx_core_reg;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
-	LOG_DEBUG("%s", __FUNCTION__);
+	/* check if pc was changed and resume want to execute the next address
+	 * if pc was changed from gdb or other interface we will
+	 * jump to this address and don't execute the next address
+	 * this will not affect the resume command with an address argument
+	 * because current is set to zero then
+	 */
+	if ( current && dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].dirty )
+	{
+		dsp563xx_write_core_reg(target,DSP563XX_REG_IDX_PC);
+		dsp563xx_core_reg = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].arch_info;
+		address = dsp563xx->core_regs[DSP563XX_REG_IDX_PC];
+		current = 0;
+	}
+
+	LOG_DEBUG("%s %08X %08X", __FUNCTION__, current, (unsigned) address);
 
 	if ((err = dsp563xx_restore_context(target)) != ERROR_OK)
 		return err;
@@ -1038,6 +1112,7 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 	int err;
 	uint32_t once_status;
 	uint32_t dr_in, cnt;
+	struct dsp563xx_core_reg *dsp563xx_core_reg;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 
 	if (target->state != TARGET_HALTED)
@@ -1046,6 +1121,20 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 		return ERROR_OK;
 	}
 
+	/* check if pc was changed and step want to execute the next address
+	 * if pc was changed from gdb or other interface we will
+	 * jump to this address and don't execute the next address
+	 * this will not affect the step command with an address argument
+	 * because current is set to zero then
+	 */
+	if ( current && dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].dirty )
+	{
+		dsp563xx_write_core_reg(target,DSP563XX_REG_IDX_PC);
+		dsp563xx_core_reg = dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_PC].arch_info;
+		address = dsp563xx->core_regs[DSP563XX_REG_IDX_PC];
+		current = 0;
+	}
+
 	LOG_DEBUG("%s %08X %08X", __FUNCTION__, current, (unsigned) address);
 
 	if ((err = dsp563xx_jtag_debug_request(target)) != ERROR_OK)
@@ -1123,7 +1212,17 @@ static int dsp563xx_step_ex(struct target *target, int current, uint32_t address
 
 static int dsp563xx_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
 {
-	return dsp563xx_step_ex(target, current, address, handle_breakpoints, 0);
+	int err;
+
+	if ( (err=dsp563xx_step_ex(target, current, address, handle_breakpoints, 0)) != ERROR_OK )
+	{
+		return err;
+	}
+
+	target->debug_reason = DBG_REASON_SINGLESTEP;
+	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+
+	return err;
 }
 
 static int dsp563xx_assert_reset(struct target *target)
@@ -1196,15 +1295,57 @@ static int dsp563xx_soft_reset_halt(struct target *target)
 	return ERROR_OK;
 }
 
-static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+/* global command context from openocd.c */
+extern struct command_context *global_cmd_ctx;
+
+static int dsp563xx_get_default_memory(void)
+{
+	Jim_Interp *interp;
+	Jim_Obj * memspace;
+	char * c;
+
+	if ( !global_cmd_ctx )
+		return MEM_P;
+
+	interp = global_cmd_ctx->interp;
+
+	if ( !interp )
+		return MEM_P;
+
+	memspace = Jim_GetGlobalVariableStr(interp,"memspace", JIM_NONE);
+
+	if ( !memspace )
+		return MEM_P;
+
+	c = (char*)Jim_GetString(memspace,NULL);
+
+	if ( !c )
+		return MEM_P;
+
+	switch(c[0])
+	{
+		case '1':
+			return MEM_X;
+		case '2':
+			return MEM_Y;
+		case '3':
+			return MEM_L;
+		default:
+			break;
+	}
+
+	return MEM_P;
+}
+
+static int dsp563xx_read_memory_core(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
 {
 	int err;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 	uint32_t i, x;
-	uint32_t data, move_cmd;
+	uint32_t data, move_cmd = 0;
 	uint8_t *b;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32, address, size, count);
+	LOG_DEBUG("memtype: %d address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", mem_type,address, size, count);
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -1212,12 +1353,6 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	/* we only support 4 byte aligned data */
-	if ( (size != 4) || (!count) )
-	{
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
 	switch (mem_type)
 	{
 		case MEM_X:
@@ -1235,16 +1370,16 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 	}
 
 	/* we use r0 to store temporary data */
-	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
-		dsp563xx->read_core_reg(target, REG_NUM_R0);
+	if (!dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].valid)
+		dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_R0);
 	/* we use r1 to store temporary data */
-	if (!dsp563xx->core_cache->reg_list[REG_NUM_R1].valid)
-		dsp563xx->read_core_reg(target, REG_NUM_R1);
+	if (!dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R1].valid)
+		dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_R1);
 
 	/* r0 is no longer valid on target */
-	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].dirty = 1;
 	/* r1 is no longer valid on target */
-	dsp563xx->core_cache->reg_list[REG_NUM_R1].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R1].dirty = 1;
 
 	x = count;
 	b = buffer;
@@ -1283,20 +1418,79 @@ static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t ad
 	return ERROR_OK;
 }
 
-static int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_read_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
 {
-	return dsp563xx_read_memory(target, MEM_P, address, size, count, buffer);
+	int err;
+	uint32_t i,i1;
+	uint8_t *buffer_y,*buffer_x;
+
+	/* we only support 4 byte aligned data */
+	if ( (size != 4) || (!count) )
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	if ( mem_type != MEM_L )
+	{
+		return dsp563xx_read_memory_core(target,mem_type,address,size,count,buffer);
+	}
+
+	if ( !(buffer_y = malloc(size*count)) )
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	if ( !(buffer_x = malloc(size*count)) )
+	{
+		free(buffer_y);
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	err = dsp563xx_read_memory_core(target,MEM_Y,address,size,count/2,buffer_y);
+
+	if ( err != ERROR_OK )
+	{
+		free(buffer_y);
+		free(buffer_x);
+		return err;
+	}
+
+	err = dsp563xx_read_memory_core(target,MEM_X,address,size,count/2,buffer_x);
+
+	if ( err != ERROR_OK )
+	{
+		free(buffer_y);
+		free(buffer_x);
+		return err;
+	}
+
+	for(i=0,i1=0;i<count;i+=2,i1++)
+	{
+		((uint32_t*)buffer)[i] = ((uint32_t*)buffer_y)[i1];
+		((uint32_t*)buffer)[i] = ((uint32_t*)buffer_x)[i1];
+	}
+
+	free(buffer_y);
+	free(buffer_x);
+
+	return ERROR_OK;
 }
 
-static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_read_memory_default(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+{
+
+	return dsp563xx_read_memory(target, dsp563xx_get_default_memory(), address, size, count, buffer);
+}
+
+static int dsp563xx_write_memory_core(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
 {
 	int err;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
 	uint32_t i, x;
-	uint32_t data, move_cmd;
+	uint32_t data, move_cmd = 0;
 	uint8_t *b;
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, size, count);
+	LOG_DEBUG("memtype: %d address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", mem_type,address, size, count);
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -1304,12 +1498,6 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	/* we only support 4 byte aligned data */
-	if ( (size != 4) || (!count) )
-	{
-		return ERROR_INVALID_ARGUMENTS;
-	}
-
 	switch (mem_type)
 	{
 		case MEM_X:
@@ -1328,16 +1516,16 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	}
 
 	/* we use r0 to store temporary data */
-	if (!dsp563xx->core_cache->reg_list[REG_NUM_R0].valid)
-		dsp563xx->read_core_reg(target, REG_NUM_R0);
+	if (!dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].valid)
+		dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_R0);
 	/* we use r1 to store temporary data */
-	if (!dsp563xx->core_cache->reg_list[REG_NUM_R1].valid)
-		dsp563xx->read_core_reg(target, REG_NUM_R1);
+	if (!dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R1].valid)
+		dsp563xx->read_core_reg(target, DSP563XX_REG_IDX_R1);
 
 	/* r0 is no longer valid on target */
-	dsp563xx->core_cache->reg_list[REG_NUM_R0].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R0].dirty = 1;
 	/* r1 is no longer valid on target */
-	dsp563xx->core_cache->reg_list[REG_NUM_R1].dirty = 1;
+	dsp563xx->core_cache->reg_list[DSP563XX_REG_IDX_R1].dirty = 1;
 
 	x = count;
 	b = buffer;
@@ -1369,14 +1557,92 @@ static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t a
 	return ERROR_OK;
 }
 
-static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+static int dsp563xx_write_memory(struct target *target, int mem_type, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+{
+	int err;
+	uint32_t i,i1;
+	uint8_t *buffer_y,*buffer_x;
+
+	/* we only support 4 byte aligned data */
+	if ( (size != 4) || (!count) )
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	if ( mem_type != MEM_L )
+	{
+		return dsp563xx_write_memory_core(target,mem_type,address,size,count,buffer);
+	}
+
+	if ( !(buffer_y = malloc(size*count)) )
+	{
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	if ( !(buffer_x = malloc(size*count)) )
+	{
+		free(buffer_y);
+		return ERROR_INVALID_ARGUMENTS;
+	}
+
+	for(i=0,i1=0;i<count;i+=2,i1++)
+	{
+		((uint32_t*)buffer_y)[i1] = ((uint32_t*)buffer)[i];
+		((uint32_t*)buffer_x)[i1] = ((uint32_t*)buffer)[i+1];
+	}
+
+	err = dsp563xx_write_memory_core(target,MEM_Y,address,size,count/2,buffer_y);
+
+	if ( err != ERROR_OK )
+	{
+		free(buffer_y);
+		free(buffer_x);
+		return err;
+	}
+
+	err = dsp563xx_write_memory_core(target,MEM_X,address,size,count/2,buffer_x);
+
+	if ( err != ERROR_OK )
+	{
+		free(buffer_y);
+		free(buffer_x);
+		return err;
+	}
+
+	free(buffer_y);
+	free(buffer_x);
+
+	return ERROR_OK;
+}
+
+static int dsp563xx_write_memory_default(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t * buffer)
+{
+	return dsp563xx_write_memory(target, dsp563xx_get_default_memory(), address, size, count, buffer);
+}
+
+static int dsp563xx_bulk_write_memory_default(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
-	return dsp563xx_write_memory(target, MEM_P, address, size, count, buffer);
+	return dsp563xx_write_memory(target, dsp563xx_get_default_memory(), address, 4, count, buffer);
 }
 
-static int dsp563xx_bulk_write_memory_p(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+static int dsp563xx_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
-	return dsp563xx_write_memory(target, MEM_P, address, 4, count, buffer);
+	return ERROR_OK;
+}
+
+static int dsp563xx_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	return ERROR_OK;
+}
+
+static int dsp563xx_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	return ERROR_OK;
+}
+
+static int dsp563xx_remove_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	return ERROR_OK;
 }
 
 static void handle_md_output(struct command_context *cmd_ctx, struct target *target, uint32_t address, unsigned size, unsigned count, const uint8_t * buffer)
@@ -1596,9 +1862,14 @@ struct target_type dsp563xx_target = {
 	.deassert_reset = dsp563xx_deassert_reset,
 	.soft_reset_halt = dsp563xx_soft_reset_halt,
 
-	.read_memory = dsp563xx_read_memory_p,
-	.write_memory = dsp563xx_write_memory_p,
-	.bulk_write_memory = dsp563xx_bulk_write_memory_p,
+	.read_memory = dsp563xx_read_memory_default,
+	.write_memory = dsp563xx_write_memory_default,
+	.bulk_write_memory = dsp563xx_bulk_write_memory_default,
+
+	.add_breakpoint = dsp563xx_add_breakpoint,
+	.remove_breakpoint = dsp563xx_remove_breakpoint,
+	.add_watchpoint = dsp563xx_add_watchpoint,
+	.remove_watchpoint = dsp563xx_remove_watchpoint,
 
 	.commands = dsp563xx_command_handlers,
 	.target_create = dsp563xx_target_create,

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c |  683 ++++++++++++++++++++++++++++++++++---------------
 1 files changed, 477 insertions(+), 206 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Feb 23 08:14:10 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 23 Feb 2011 07:14:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-767-gf26cd96
Message-ID: <mailman.13.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f26cd967406d98e3cccf61b314e3eb544241364b (commit)
       via  05abfbadf12ec6167d5d6137705a7631ff8cb5eb (commit)
      from  403e239960758bed7888496c3d1e3faf91b49a6c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f26cd967406d98e3cccf61b314e3eb544241364b
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Feb 21 18:59:50 2011 +0100

    add at91rm9200-ek board support
    
    tested with jlink sam-ice v5 while loading barebox
    
    (gdb) load
    Loading section .text, size 0x2f190 lma 0x21f00000
    Loading section .rodata, size 0x931c lma 0x21f2f190
    Loading section .data, size 0x29e8 lma 0x21f384ac
    Loading section .barebox_cmd, size 0x78c lma 0x21f3ae94
    Loading section .barebox_initcalls, size 0x80 lma 0x21f3b620
    Start address 0x21f00000, load size 243360
    Transfer rate: 26 KB/sec, 13520 bytes/write.
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/tcl/board/at91rm9200-ek.cfg b/tcl/board/at91rm9200-ek.cfg
new file mode 100644
index 0000000..07a006b
--- /dev/null
+++ b/tcl/board/at91rm9200-ek.cfg
@@ -0,0 +1,112 @@
+#
+# Copyright 2010 Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
+#
+# under GPLv2 Only
+#
+# This is for the "at91rm9200-ek" eval board.
+#
+#
+# It has atmel at91rm9200 chip.
+source [find target/at91rm9200.cfg]
+
+reset_config trst_and_srst
+
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { at91rm9200_ek_init }
+
+## flash bank <name> <driver> <base> <size> <chip_width> <bus_width> <target>
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME cfi 0x10000000 0x00800000 2 2 $_TARGETNAME
+
+
+proc at91rm9200_ek_init { } {
+	# Try to run at 1khz... Yea, that slow!
+	# Chip is really running @ 32khz
+	adapter_khz 8
+
+	mww 0xfffffc64 0xffffffff
+	## disable all clocks but system clock
+	mww 0xfffffc04 0xfffffffe
+	## disable all clocks to pioa and piob
+	mww 0xfffffc14 0xffffffc3
+	## master clock = slow cpu = slow
+	## (means the CPU is running at 32khz!)
+	mww 0xfffffc30 0
+	## main osc enable
+	mww 0xfffffc20 0x0000ff01
+	## MC_PUP
+	mww 0xFFFFFF50 0x00000000
+	## MC_PUER: Memory controller protection unit disable
+	mww 0xFFFFFF54 0x00000000
+	## EBI_CFGR
+	mww 0xFFFFFF64 0x00000000
+	## SMC2_CSR[0]: 16bit, 2 TDF, 4 WS
+	mww 0xFFFFFF70 0x00003284
+
+	## Init Clocks
+	## CKGR_PLLAR
+	mww 0xFFFFFC28 0x2000BF05
+	## PLLAR: 179,712000 MHz for PCK
+	mww 0xFFFFFC28 0x20263E04
+	sleep 100
+	## PMC_MCKR
+	mww 0xFFFFFC30 0x00000100
+	sleep 100
+	## ;MCKR : PCK/3 = MCK Master Clock = 59,904000MHz from PLLA
+	mww 0xFFFFFC30 0x00000202
+	sleep 100
+
+	#========================================
+	# CPU now runs at 180mhz
+	# SYS runs at 60mhz.
+	adapter_khz 40000
+	#========================================
+
+	## Init SDRAM
+	## PIOC_ASR: Configure PIOC as peripheral (D16/D31)
+	mww 0xFFFFF870 0xFFFF0000
+	## PIOC_BSR:
+	mww 0xFFFFF874 0x00000000
+	## PIOC_PDR:
+	mww 0xFFFFF804 0xFFFF0000
+	## EBI_CSA : CS1=SDRAM
+	mww 0xFFFFFF60 0x00000002
+	## EBI_CFGR:
+	mww 0xFFFFFF64 0x00000000
+	## SDRC_CR :
+	mww 0xFFFFFF98 0x2188c155
+	## SDRC_MR : Precharge All
+	mww 0xFFFFFF90 0x00000002
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## SDRC_MR : Refresh
+	mww 0xFFFFFF90 0x00000004
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## SDRC_MR : Load Mode Register
+	mww 0xFFFFFF90 0x00000003
+	## access SDRAM
+	mww 0x20000080 0x00000000
+	## SDRC_TR : Write refresh rate
+	mww 0xFFFFFF94 0x000002E0
+	## access SDRAM
+	mww 0x20000000 0x00000000
+	## SDRC_MR : Normal Mode
+	mww 0xFFFFFF90 0x00000000
+	## access SDRAM
+	mww 0x20000000 0x00000000
+}

commit 05abfbadf12ec6167d5d6137705a7631ff8cb5eb
Author: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
Date:   Mon Feb 21 18:59:49 2011 +0100

    jlink: set the speed at JLINK_MAX_SPEED when an exceeded speed is requested
    
    it will allow to be at the highest speed of the jlink without touching the
    board or cpu config
    
    tested on sam-ice v5 and at91rm9200-ek
    
    Signed-off-by: Jean-Christophe PLAGNIOL-VILLARD <plagnioj at jcrosoft.com>
    Cc: Nicolas Ferre <nicolas.ferre at atmel.com>
    Cc: Patrice Vilchez <patrice.vilchez at atmel.com>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 4a8896b..bc5448d 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -236,9 +236,9 @@ static int jlink_speed(int speed)
 
 	if (speed > JLINK_MAX_SPEED)
 	{
-		LOG_INFO("Ignoring speed request: %dkHz exceeds %dkHz maximum",
+		LOG_INFO("reduce speed request: %dkHz to %dkHz maximum",
 				speed, JLINK_MAX_SPEED);
-		return ERROR_OK;
+		speed = JLINK_MAX_SPEED;
 	}
 
 	/* check for RTCK setting */

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/jlink.c    |    4 +-
 tcl/board/at91rm9200-ek.cfg |  112 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 114 insertions(+), 2 deletions(-)
 create mode 100644 tcl/board/at91rm9200-ek.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Feb 23 08:15:25 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 23 Feb 2011 07:15:25 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-768-g47b5829
Message-ID: <mailman.14.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  47b5829db40459650866488ab46008fd8b7e191c (commit)
      from  f26cd967406d98e3cccf61b314e3eb544241364b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 47b5829db40459650866488ab46008fd8b7e191c
Author: Luca Ellero <lroluk at gmail.com>
Date:   Tue Feb 22 20:16:10 2011 +0000

    cortex_a8: remove dap_ap_sel calls
    
    add new mem_ap_sel_* functions (as was made for cortex_a9)
    see commit: 779005f43dc372de937dfd4b445f31d882b98eca
    
    Signed-off-by: Luca Ellero <lroluk at gmail.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index f50b149..7815522 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -81,7 +81,6 @@ static int cortex_a8_init_debug_access(struct target *target)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
-
 	int retval;
 	uint32_t dummy;
 
@@ -89,11 +88,13 @@ static int cortex_a8_init_debug_access(struct target *target)
 
 	/* Unlocking the debug registers for modification */
 	/* The debugport might be uninitialised so try twice */
-	retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
+			armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
 	if (retval != ERROR_OK)
 	{
 		/* try again */
-		retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
+				armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
 		if (retval == ERROR_OK)
 		{
 			LOG_USER("Locking debug access failed on first, but succeeded on second try.");
@@ -103,7 +104,8 @@ static int cortex_a8_init_debug_access(struct target *target)
 		return retval;
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
-	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_PRSR, &dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+				armv7a->debug_base + CPUDBG_PRSR, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -112,9 +114,7 @@ static int cortex_a8_init_debug_access(struct target *target)
 	/* Resync breakpoint registers */
 
 	/* Since this is likely called from init or reset, update target state information*/
-	retval = cortex_a8_poll(target);
-
-	return retval;
+	return cortex_a8_poll(target);
 }
 
 /* To reduce needless round-trips, pass in a pointer to the current
@@ -138,7 +138,7 @@ static int cortex_a8_exec_opcode(struct target *target,
 	long long then = timeval_ms();
 	while ((dscr & DSCR_INSTR_COMP) == 0)
 	{
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 		{
@@ -152,14 +152,15 @@ static int cortex_a8_exec_opcode(struct target *target,
 		}
 	}
 
-	retval = mem_ap_write_u32(swjdp, armv7a->debug_base + CPUDBG_ITR, opcode);
+	retval = mem_ap_sel_write_u32(swjdp, swjdp_debugap,
+				armv7a->debug_base + CPUDBG_ITR, opcode);
 	if (retval != ERROR_OK)
 		return retval;
 
 	then = timeval_ms();
 	do
 	{
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 		{
@@ -201,11 +202,8 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 	if (retval != ERROR_OK)
 		return retval;
 
-	dap_ap_select(swjdp, swjdp_memoryap);
-	retval = mem_ap_read_buf_u32(swjdp, (uint8_t *)(&regfile[1]), 4*15, address);
-	if (retval != ERROR_OK)
-		return retval;
-	dap_ap_select(swjdp, swjdp_debugap);
+	retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
+			(uint8_t *)(&regfile[1]), 4*15, address);
 
 	return retval;
 }
@@ -262,7 +260,7 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0)
 	{
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
@@ -273,7 +271,7 @@ static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 		}
 	}
 
-	retval = mem_ap_read_atomic_u32(swjdp,
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DTRTX, value);
 	LOG_DEBUG("read DCC 0x%08" PRIx32, *value);
 
@@ -292,7 +290,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
 
 	/* Check that DCCRX is not full */
-	retval = mem_ap_read_atomic_u32(swjdp,
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
@@ -311,7 +309,7 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 
 	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
 	LOG_DEBUG("write DCC 0x%08" PRIx32, value);
-	retval = mem_ap_write_u32(swjdp,
+	retval = mem_ap_sel_write_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DTRRX, value);
 	if (retval != ERROR_OK)
 		return retval;
@@ -372,7 +370,7 @@ static int cortex_a8_dap_write_memap_register_u32(struct target *target, uint32_
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
 
-	retval = mem_ap_write_atomic_u32(swjdp, address, value);
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap, address, value);
 
 	return retval;
 }
@@ -396,7 +394,7 @@ static inline struct cortex_a8_common *dpm_to_a8(struct arm_dpm *dpm)
 static int cortex_a8_write_dcc(struct cortex_a8_common *a8, uint32_t data)
 {
 	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
-	return mem_ap_write_u32(&a8->armv7a_common.dap,
+	return mem_ap_sel_write_u32(&a8->armv7a_common.dap, swjdp_debugap,
 			a8->armv7a_common.debug_base + CPUDBG_DTRRX, data);
 }
 
@@ -413,7 +411,7 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 	/* Wait for DTRRXfull */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
 		if (retval != ERROR_OK)
@@ -425,7 +423,7 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 		}
 	}
 
-	retval = mem_ap_read_atomic_u32(swjdp,
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			a8->armv7a_common.debug_base + CPUDBG_DTRTX, data);
 	if (retval != ERROR_OK)
 		return retval;
@@ -448,7 +446,7 @@ static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 	long long then = timeval_ms();
 	for (;;)
 	{
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
 		if (retval != ERROR_OK)
@@ -685,14 +683,11 @@ static int cortex_a8_poll(struct target *target)
 	struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
 	struct adiv5_dap *swjdp = &armv7a->dap;
 	enum target_state prev_target_state = target->state;
-	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 
-	dap_ap_select(swjdp, swjdp_debugap);
-	retval = mem_ap_read_atomic_u32(swjdp,
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 	{
-		dap_ap_select(swjdp, saved_apsel);
 		return retval;
 	}
 	cortex_a8->cpudbg_dscr = dscr;
@@ -737,8 +732,6 @@ static int cortex_a8_poll(struct target *target)
 		target->state = TARGET_UNKNOWN;
 	}
 
-	dap_ap_select(swjdp, saved_apsel);
-
 	return retval;
 }
 
@@ -748,37 +741,36 @@ static int cortex_a8_halt(struct target *target)
 	uint32_t dscr;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = &armv7a->dap;
-	uint8_t saved_apsel = dap_ap_get_select(swjdp);
-	dap_ap_select(swjdp, swjdp_debugap);
 
 	/*
 	 * Tell the core to be halted by writing DRCR with 0x1
 	 * and then wait for the core to be halted.
 	 */
-	retval = mem_ap_write_atomic_u32(swjdp,
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DRCR, 0x1);
 	if (retval != ERROR_OK)
-		goto out;
+		return retval;
 
 	/*
 	 * enter halting debug mode
 	 */
-	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
-		goto out;
+		return retval;
 
-	retval = mem_ap_write_atomic_u32(swjdp,
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
 		armv7a->debug_base + CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
 	if (retval != ERROR_OK)
-		goto out;
+		return retval;
 
 	long long then = timeval_ms();
 	for (;;)
 	{
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
-			goto out;
+			return retval;
 		if ((dscr & DSCR_CORE_HALTED) != 0)
 		{
 			break;
@@ -792,9 +784,7 @@ static int cortex_a8_halt(struct target *target)
 
 	target->debug_reason = DBG_REASON_DBGRQ;
 
-out:
-	dap_ap_select(swjdp, saved_apsel);
-	return retval;
+	return ERROR_OK;
 }
 
 static int cortex_a8_resume(struct target *target, int current,
@@ -808,9 +798,6 @@ static int cortex_a8_resume(struct target *target, int current,
 //	struct breakpoint *breakpoint = NULL;
 	uint32_t resume_pc, dscr;
 
-	uint8_t saved_apsel = dap_ap_get_select(swjdp);
-	dap_ap_select(swjdp, swjdp_debugap);
-
 	if (!debug_execution)
 		target_free_all_working_areas(target);
 
@@ -889,14 +876,15 @@ static int cortex_a8_resume(struct target *target, int current,
 	 * REVISIT: for single stepping, we probably want to
 	 * disable IRQs by default, with optional override...
 	 */
-	retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DRCR, 0x2);
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
+			armv7a->debug_base + CPUDBG_DRCR, 0x2);
 	if (retval != ERROR_OK)
 		return retval;
 
 	long long then = timeval_ms();
 	for (;;)
 	{
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
@@ -928,8 +916,6 @@ static int cortex_a8_resume(struct target *target, int current,
 		LOG_DEBUG("target debug resumed at 0x%" PRIx32, resume_pc);
 	}
 
-	dap_ap_select(swjdp, saved_apsel);
-
 	return ERROR_OK;
 }
 
@@ -948,7 +934,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
 
 	/* REVISIT surely we should not re-read DSCR !! */
-	retval = mem_ap_read_atomic_u32(swjdp,
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
@@ -960,7 +946,7 @@ static int cortex_a8_debug_entry(struct target *target)
 
 	/* Enable the ITR execution once we are in debug mode */
 	dscr |= DSCR_ITR_EN;
-	retval = mem_ap_write_atomic_u32(swjdp,
+	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		return retval;
@@ -972,7 +958,7 @@ static int cortex_a8_debug_entry(struct target *target)
 	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 		uint32_t wfar;
 
-		retval = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 				armv7a->debug_base + CPUDBG_WFAR,
 				&wfar);
 		if (retval != ERROR_OK)
@@ -993,10 +979,9 @@ static int cortex_a8_debug_entry(struct target *target)
 	}
 	else
 	{
-		dap_ap_select(swjdp, swjdp_memoryap);
 		retval = cortex_a8_read_regs_through_mem(target,
 				regfile_working_area->address, regfile);
-		dap_ap_select(swjdp, swjdp_memoryap);
+
 		target_free_working_area(target, regfile_working_area);
 		if (retval != ERROR_OK)
 		{
@@ -1007,7 +992,7 @@ static int cortex_a8_debug_entry(struct target *target)
 		retval = cortex_a8_dap_read_coreregister_u32(target, &cpsr, 16);
 		if (retval != ERROR_OK)
 			return retval;
-		dap_ap_select(swjdp, swjdp_debugap);
+
 		LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
 
 		arm_set_cpsr(armv4_5, cpsr);
@@ -1469,13 +1454,16 @@ static int cortex_a8_read_phys_memory(struct target *target,
         if (count && buffer) {
                 switch (size) {
                 case 4:
-                        retval = mem_ap_read_buf_u32(swjdp, buffer, 4 * count, address);
+                        retval = mem_ap_sel_read_buf_u32(swjdp, swjdp_memoryap,
+								buffer, 4 * count, address);
                         break;
                 case 2:
-                        retval = mem_ap_read_buf_u16(swjdp, buffer, 2 * count, address);
+                        retval = mem_ap_sel_read_buf_u16(swjdp, swjdp_memoryap,
+								buffer, 2 * count, address);
                         break;
                 case 1:
-                        retval = mem_ap_read_buf_u8(swjdp, buffer, count, address);
+                        retval = mem_ap_sel_read_buf_u8(swjdp, swjdp_memoryap,
+								 buffer, count, address);
                         break;
                 }
         }
@@ -1526,13 +1514,16 @@ static int cortex_a8_write_phys_memory(struct target *target,
         if (count && buffer) {
                 switch (size) {
                 case 4:
-                        retval = mem_ap_write_buf_u32(swjdp, buffer, 4 * count, address);
+                        retval = mem_ap_sel_write_buf_u32(swjdp, swjdp_memoryap,
+								buffer, 4 * count, address);
                         break;
                 case 2:
-                        retval = mem_ap_write_buf_u16(swjdp, buffer, 2 * count, address);
+                        retval = mem_ap_sel_write_buf_u16(swjdp, swjdp_memoryap,
+								buffer, 2 * count, address);
                         break;
                 case 1:
-                        retval = mem_ap_write_buf_u8(swjdp, buffer, count, address);
+                        retval = mem_ap_sel_write_buf_u8(swjdp, swjdp_memoryap,
+								buffer, count, address);
                         break;
                 }
         }
@@ -1610,6 +1601,7 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
         retval = cortex_a8_mmu(target, &enabled);
         if (retval != ERROR_OK)
         	return retval;
+
         if(enabled)
         {
             virt = address;
@@ -1630,7 +1622,6 @@ static int cortex_a8_bulk_write_memory(struct target *target, uint32_t address,
 	return cortex_a8_write_memory(target, address, 4, count, buffer);
 }
 
-
 static int cortex_a8_dcc_read(struct adiv5_dap *swjdp, uint8_t *value, uint8_t *ctrl)
 {
 #if 0
@@ -1733,32 +1724,33 @@ static int cortex_a8_examine_first(struct target *target)
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
+			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK)
 		return retval;
 
-	if ((retval = mem_ap_read_atomic_u32(swjdp,
+	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_CPUID, &cpuid)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine %s failed", "CPUID");
 		return retval;
 	}
 
-	if ((retval = mem_ap_read_atomic_u32(swjdp,
+	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_CTYPR, &ctypr)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine %s failed", "CTYPR");
 		return retval;
 	}
 
-	if ((retval = mem_ap_read_atomic_u32(swjdp,
+	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_TTYPR, &ttypr)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine %s failed", "TTYPR");
 		return retval;
 	}
 
-	if ((retval = mem_ap_read_atomic_u32(swjdp,
+	if ((retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a->debug_base + CPUDBG_DIDR, &didr)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine %s failed", "DIDR");

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a8.c |  128 ++++++++++++++++++++++-------------------------
 1 files changed, 60 insertions(+), 68 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb 24 23:21:22 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 24 Feb 2011 22:21:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-769-g6ddcee7
Message-ID: <mailman.15.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6ddcee7d20ee873f1c214736c22f29d9781dded4 (commit)
      from  47b5829db40459650866488ab46008fd8b7e191c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6ddcee7d20ee873f1c214736c22f29d9781dded4
Author: Mathias K <kesmtp at freenet.de>
Date:   Thu Feb 24 13:00:59 2011 +0100

    ft2232: fix possible read buffer overflow
    
    This patch fix a possible read buffer overflow in ft2232_execute_queue.
    Also the correct read queue size for libftdi and libftd2xx was added and
    and tested.
    In function ft2232_write a uninitialized value was initialized because we
    don't know if this value was set in the ftdi api call.

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 9024f8e..a84d069 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -373,6 +373,12 @@ static int             require_send;
 	a comment would have been nice.
 */
 
+#if BUILD_FT2232_FTD2XX == 1
+#define FT2232_BUFFER_READ_QUEUE_SIZE	(64*64)
+#else
+#define FT2232_BUFFER_READ_QUEUE_SIZE	(64*4)
+#endif
+
 #define FT2232_BUFFER_SIZE 131072
 
 static uint8_t*             ft2232_buffer = NULL;
@@ -499,7 +505,7 @@ static int ft2232_write(uint8_t* buf, int size, uint32_t* bytes_written)
 {
 #if BUILD_FT2232_FTD2XX == 1
 	FT_STATUS status;
-	DWORD dw_bytes_written;
+	DWORD dw_bytes_written = 0;
 	if ((status = FT_Write(ftdih, buf, size, &dw_bytes_written)) != FT_OK)
 	{
 		*bytes_written = dw_bytes_written;
@@ -2081,12 +2087,20 @@ static int ft2232_execute_queue(void)
 
 	while (cmd)
 	{
+		/* fill the write buffer with the desired command */
 		if (ft2232_execute_command(cmd) != ERROR_OK)
 			retval = ERROR_JTAG_QUEUE_FAILED;
-		/* Start reading input before FT2232 TX buffer fills up */
+		/* Start reading input before FT2232 TX buffer fills up.
+		 * Sometimes this happens because we don't know the
+		 * length of the last command before we execute it. So
+		 * we simple inform the user.
+		 */
 		cmd = cmd->next;
-		if (ft2232_expect_read > 256)
+
+		if (ft2232_expect_read >= FT2232_BUFFER_READ_QUEUE_SIZE )
 		{
+			if (ft2232_expect_read > (FT2232_BUFFER_READ_QUEUE_SIZE+1) )
+				LOG_WARNING("read buffer size looks to high");
 			if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
 				retval = ERROR_JTAG_QUEUE_FAILED;
 			first_unsent = cmd;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c |   20 +++++++++++++++++---
 1 files changed, 17 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb 25 16:36:38 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 25 Feb 2011 15:36:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-771-g95de667
Message-ID: <mailman.16.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  95de667e243fe48783da0fdc92270a0d3d28ff0c (commit)
       via  c3c6a6e1d4b7cf121adb86d4021775ed8ced7fb4 (commit)
      from  6ddcee7d20ee873f1c214736c22f29d9781dded4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 95de667e243fe48783da0fdc92270a0d3d28ff0c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Feb 24 15:37:03 2011 +0100

    log: debug level is between silent and debug output levels
    
    It wasn't previously possible to silence the output.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/log.c b/src/helper/log.c
index b6fab01..8a8f08a 100644
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -224,19 +224,18 @@ void log_printf_lf(enum log_levels level, const char *file, unsigned line, const
 	va_end(ap);
 }
 
-/* change the current debug level on the fly
- * 0: only ERRORS
- * 1: + WARNINGS
- * 2: + INFORMATIONAL MSGS
- * 3: + DEBUG MSGS
- */
 COMMAND_HANDLER(handle_debug_level_command)
 {
 	if (CMD_ARGC == 1)
 	{
-		unsigned new_level;
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], new_level);
-		debug_level = MIN(new_level, LOG_LVL_DEBUG);
+		int new_level;
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], new_level);
+		if ((debug_level > LOG_LVL_DEBUG) || (new_level < LOG_LVL_SILENT))
+		{
+			LOG_ERROR("level must be between %d and %d", LOG_LVL_SILENT, LOG_LVL_DEBUG);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+		debug_level = new_level;
 	}
 	else if (CMD_ARGC > 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;

commit c3c6a6e1d4b7cf121adb86d4021775ed8ced7fb4
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Feb 24 15:19:27 2011 +0100

    jtag: add wait_srst_deassert command
    
    Useful to do something *real quick* after a SRST deassert.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 3e6074b..267802e 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -40,6 +40,8 @@
 #include <strings.h>
 #endif
 
+#include <helper/time_support.h>
+
 /**
  * @file
  * Holds support for accessing JTAG-specific mechanisms from TCl scripts.
@@ -1266,6 +1268,46 @@ COMMAND_HANDLER(handle_jtag_flush_queue_sleep)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_wait_srst_deassert)
+{
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	int timeout_ms;
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], timeout_ms);
+	if ((timeout_ms <= 0) || (timeout_ms > 100000))
+	{
+		LOG_ERROR("Timeout must be an integer between 0 and 100000");
+		return ERROR_FAIL;
+	}
+
+	LOG_USER("Waiting for srst assert + deassert for at most %dms", timeout_ms);
+	int asserted_yet;
+	long long then = timeval_ms();
+	while (jtag_srst_asserted(&asserted_yet) == ERROR_OK)
+	{
+		if ((timeval_ms() - then) > timeout_ms)
+		{
+			LOG_ERROR("Timed out");
+			return ERROR_FAIL;
+		}
+		if (asserted_yet)
+			break;
+	}
+	while (jtag_srst_asserted(&asserted_yet) == ERROR_OK)
+	{
+		if ((timeval_ms() - then) > timeout_ms)
+		{
+			LOG_ERROR("Timed out");
+			return ERROR_FAIL;
+		}
+		if (!asserted_yet)
+			break;
+	}
+
+	return ERROR_OK;
+}
+
 
 
 static const struct command_registration jtag_command_handlers[] = {
@@ -1358,6 +1400,15 @@ static const struct command_registration jtag_command_handlers[] = {
 		.usage = "['short'|'long']",
 	},
 	{
+		.name = "wait_srst_deassert",
+		.handler = handle_wait_srst_deassert,
+		.mode = COMMAND_ANY,
+		.help = "Wait for an SRST deassert. "
+			"Useful for cases where you need something to happen within ms "
+			"of an srst deassert. Timeout in ms ",
+		.usage = "ms",
+	},
+	{
 		.name = "jtag",
 		.mode = COMMAND_ANY,
 		.help = "perform jtag tap actions",

-----------------------------------------------------------------------

Summary of changes:
 src/helper/log.c |   17 ++++++++---------
 src/jtag/tcl.c   |   51 +++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 59 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb 28 09:01:31 2011
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 28 Feb 2011 08:01:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-772-ge5677ce
Message-ID: <mailman.17.1331736153.7625.openocd-svn@lists.berlios.de>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e5677ce9e523550f0de36d77b46461645a764cb3 (commit)
      from  95de667e243fe48783da0fdc92270a0d3d28ff0c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e5677ce9e523550f0de36d77b46461645a764cb3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Feb 25 14:09:39 2011 +0100

    svf: add nil option that just runs through the svf file
    
    useful for debugging without access to hardware to e.g.
    regression test, reproduce memory corruption problems,
    etc.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/svf/svf.c b/src/svf/svf.c
index 53994a2..6acf032 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -223,6 +223,7 @@ static int svf_getline (char **lineptr, size_t *n, FILE *stream);
 static uint8_t *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
 static int svf_buffer_index = 0, svf_buffer_size = 0;
 static int svf_quiet = 0;
+static int svf_nil = 0;
 
 // Targetting particular tap
 static int svf_tap_is_specified = 0;
@@ -288,6 +289,9 @@ int svf_add_statemove(tap_state_t state_to)
 
 	/* when resetting, be paranoid and ignore current state */
 	if (state_to == TAP_RESET) {
+		if (svf_nil)
+			return ERROR_OK;
+
 		jtag_add_tlr();
 		return ERROR_OK;
 	}
@@ -297,6 +301,10 @@ int svf_add_statemove(tap_state_t state_to)
 		if ((svf_statemoves[index_var].from == state_from)
 			&& (svf_statemoves[index_var].to == state_to))
 		{
+			if (svf_nil)
+			{
+				continue;
+			}
 			/* recorded path includes current state ... avoid extra TCKs! */
 			if (svf_statemoves[index_var].num_of_moves > 1)
 				jtag_add_pathmove(svf_statemoves[index_var].num_of_moves - 1,
@@ -333,6 +341,7 @@ COMMAND_HANDLER(handle_svf_command)
 
 	// parse command line
 	svf_quiet = 0;
+	svf_nil = 0;
 	for (unsigned int i = 0; i < CMD_ARGC; i++)
 	{
 		if (strcmp(CMD_ARGV[i], "-tap") == 0)
@@ -349,6 +358,10 @@ COMMAND_HANDLER(handle_svf_command)
 		{
 			svf_quiet = 1;
 		}
+		else if ((strcmp(CMD_ARGV[i], "nil") == 0) || (strcmp(CMD_ARGV[i], "-nil") == 0))
+		{
+			svf_nil = 1;
+		}
 		else if ((strcmp(CMD_ARGV[i], "progress") == 0) || (strcmp(CMD_ARGV[i], "-progress") == 0))
 		{
 			svf_progress_enabled = 1;
@@ -417,8 +430,11 @@ COMMAND_HANDLER(handle_svf_command)
 
 	memcpy(&svf_para, &svf_para_init, sizeof(svf_para));
 
-	// TAP_RESET
-	jtag_add_tlr();
+	if (!svf_nil)
+	{
+		// TAP_RESET
+		jtag_add_tlr();
+	}
 
 	if (tap)
 	{
@@ -519,7 +535,8 @@ COMMAND_HANDLER(handle_svf_command)
 		}
 		command_num++;
 	}
-	if (ERROR_OK != jtag_execute_queue())
+
+	if ((!svf_nil) && (ERROR_OK != jtag_execute_queue()))
 	{
 		ret = ERROR_FAIL;
 	}
@@ -956,7 +973,7 @@ static int svf_add_check_para(uint8_t enabled, int buffer_offset, int bit_len)
 
 static int svf_execute_tap(void)
 {
-	if (ERROR_OK != jtag_execute_queue())
+	if ((!svf_nil) && (ERROR_OK != jtag_execute_queue()))
 	{
 		return ERROR_FAIL;
 	}
@@ -1284,8 +1301,11 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			field.num_bits = i;
 			field.out_value = &svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &svf_tdi_buffer[svf_buffer_index];
-			/* NOTE:  doesn't use SVF-specified state paths */
-			jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value, svf_para.dr_end_state);
+			if (!svf_nil)
+			{
+				/* NOTE:  doesn't use SVF-specified state paths */
+				jtag_add_plain_dr_scan(field.num_bits, field.out_value, field.in_value, svf_para.dr_end_state);
+			}
 
 			svf_buffer_index += (i + 7) >> 3;
 		}
@@ -1379,9 +1399,12 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			field.num_bits = i;
 			field.out_value = &svf_tdi_buffer[svf_buffer_index];
 			field.in_value = &svf_tdi_buffer[svf_buffer_index];
-			/* NOTE:  doesn't use SVF-specified state paths */
-			jtag_add_plain_ir_scan(field.num_bits, field.out_value, field.in_value,
-					svf_para.ir_end_state);
+			if (!svf_nil)
+			{
+				/* NOTE:  doesn't use SVF-specified state paths */
+				jtag_add_plain_ir_scan(field.num_bits, field.out_value, field.in_value,
+						svf_para.ir_end_state);
+			}
 
 			svf_buffer_index += (i + 7) >> 3;
 		}
@@ -1495,11 +1518,13 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 
 			// add clocks and/or min wait
 			if (run_count > 0) {
-				jtag_add_clocks(run_count);
+				if (!svf_nil)
+					jtag_add_clocks(run_count);
 			}
 
 			if (min_usec > 0) {
-				jtag_add_sleep(min_usec);
+				if (!svf_nil)
+					jtag_add_sleep(min_usec);
 			}
 
 			// move to end_state if necessary
@@ -1515,7 +1540,8 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 				return ERROR_FAIL;
 			}
 
-			jtag_add_runtest(run_count, svf_para.runtest_end_state);
+			if (!svf_nil)
+				jtag_add_runtest(run_count, svf_para.runtest_end_state);
 #endif
 		}
 		else
@@ -1558,9 +1584,11 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 					/* FIXME last state MUST be stable! */
 					if (i > 0)
 					{
-						jtag_add_pathmove(i, path);
+						if (!svf_nil)
+							jtag_add_pathmove(i, path);
 					}
-					jtag_add_tlr();
+					if (!svf_nil)
+						jtag_add_tlr();
 					num_of_argu -= i + 1;
 					i = -1;
 				}
@@ -1571,7 +1599,8 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 				if (svf_tap_state_is_stable(path[num_of_argu - 1]))
 				{
 					// last state MUST be stable state
-					jtag_add_pathmove(num_of_argu, path);
+					if (!svf_nil)
+						jtag_add_pathmove(num_of_argu, path);
 					LOG_DEBUG("\tmove to %s by path_move",
 						tap_state_name(path[num_of_argu - 1]));
 				}
@@ -1626,11 +1655,13 @@ static int svf_run_command(struct command_context *cmd_ctx, char *cmd_str)
 			switch (i_tmp)
 			{
 			case TRST_ON:
-				jtag_add_reset(1, 0);
+				if (!svf_nil)
+					jtag_add_reset(1, 0);
 				break;
 			case TRST_Z:
 			case TRST_OFF:
-				jtag_add_reset(0, 0);
+				if (!svf_nil)
+					jtag_add_reset(0, 0);
 				break;
 			case TRST_ABSENT:
 				break;
@@ -1705,7 +1736,7 @@ static const struct command_registration svf_command_handlers[] = {
 		.handler = handle_svf_command,
 		.mode = COMMAND_EXEC,
 		.help = "Runs a SVF file.",
-		.usage = "svf [-tap device.tap] <file> [quiet] [progress]",
+		.usage = "svf [-tap device.tap] <file> [quiet] [nil] [progress]",
 	},
 	COMMAND_REGISTRATION_DONE
 };

-----------------------------------------------------------------------

Summary of changes:
 src/svf/svf.c |   67 +++++++++++++++++++++++++++++++++++++++++---------------
 1 files changed, 49 insertions(+), 18 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


