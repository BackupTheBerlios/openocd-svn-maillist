From dbrownell at users.sourceforge.net  Sun Aug  1 08:28:21 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun,  1 Aug 2010 06:28:21 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-454-ga84112f
Message-ID: <E1OfS25-00069W-AT@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a84112f47168d85942787b769bc4642c5953a4b4 (commit)
      from  f4c1f08f164ab74a7893742218ac0f8dd4a2e473 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a84112f47168d85942787b769bc4642c5953a4b4
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Aug 1 02:27:14 2010 -0400

    stellaris flash comment update
    
    This flash driver works on more than just two chips.
    (Though it does need work still, e.g. to protect more than 64K.
    (On non-'3748-A0 chips where errata allow that.))
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 69e2f10..03800fd 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -22,7 +22,7 @@
  ***************************************************************************/
 
 /***************************************************************************
-* STELLARIS is tested on LM3S811, LM3S6965
+* STELLARIS flash is tested on LM3S811, LM3S6965, LM3s3748, more.
 ***************************************************************************/
 #ifdef HAVE_CONFIG_H
 #include "config.h"

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stellaris.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Aug  1 09:11:05 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun,  1 Aug 2010 07:11:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-456-g8e9b12d
Message-ID: <E1OfShQ-0000Dm-Bu@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8e9b12dc8a5964cfc43996f94488759258c0f1dc (commit)
       via  8772355bbd507f4cd191d589d7ab5060b97c1818 (commit)
      from  a84112f47168d85942787b769bc4642c5953a4b4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8e9b12dc8a5964cfc43996f94488759258c0f1dc
Author: Peter Stuge <peter at stuge.se>
Date:   Sun Aug 1 03:26:48 2010 +0200

    Support NGX Technologies product NGX ARM USB JTAG
    
    This is a standard FT2232 device. More info at their web page:
    http://shop.ngxtechnologies.com/product_info.php?cPath=26&products_id=30

diff --git a/tcl/interface/ngxtech.cfg b/tcl/interface/ngxtech.cfg
new file mode 100644
index 0000000..fe9d6af
--- /dev/null
+++ b/tcl/interface/ngxtech.cfg
@@ -0,0 +1,6 @@
+# http://shop.ngxtechnologies.com/product_info.php?cPath=26&products_id=30
+
+interface ft2232
+ft2232_device_desc "NGX JTAG A"
+ft2232_vid_pid 0x0403 0x6010
+ft2232_layout "oocdlink"

commit 8772355bbd507f4cd191d589d7ab5060b97c1818
Author: Peter Stuge <peter at stuge.se>
Date:   Sun Aug 1 03:26:47 2010 +0200

    Remove srst_pulls_trst from LPC2148 target
    
    srst_pulls_trst is only true on some (broken) LPC2148 boards, a fact
    which is already documented in doc/openocd.texi, so it shouldn't be
    set unconditionally in the target tcl.
    
    This patch was needed to reflash when an Abort exception occured very
    early after reset, before OpenOCD tried to halt the CPU.

diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index cbf3058..8062cdd 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -22,7 +22,7 @@ jtag_ntrst_delay 200
 # JTAG, power-on reset is not enough, i.e. you need to perform a
 # reset before being able to talk to the LPC2148, attach is not possible.
 
-reset_config trst_and_srst srst_pulls_trst
+reset_config trst_and_srst
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/interface/ngxtech.cfg |    6 ++++++
 tcl/target/lpc2148.cfg    |    2 +-
 2 files changed, 7 insertions(+), 1 deletions(-)
 create mode 100644 tcl/interface/ngxtech.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  2 11:57:55 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  2 Aug 2010 09:57:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-459-gab818f6
Message-ID: <E1OfrmQ-00019K-Bl@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ab818f68984aaf56f8b966f4b2e2da4e7f1051c9 (commit)
       via  803351ec59cb57c63129c77d95b5edf2fc65c302 (commit)
       via  630fc86ee339aa400f58fe80cbc5a1926eb3ef39 (commit)
      from  8e9b12dc8a5964cfc43996f94488759258c0f1dc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ab818f68984aaf56f8b966f4b2e2da4e7f1051c9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Aug 2 11:15:21 2010 +0200

    jtag: measure_clk debug proc
    
    It can be useful to get an approximate measurement of
    rtck frequency for debugging purposes.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/startup.tcl b/src/jtag/startup.tcl
index 496fdc8..fdd3078 100644
--- a/src/jtag/startup.tcl
+++ b/src/jtag/startup.tcl
@@ -76,6 +76,15 @@ proc srst_asserted {} {
 	puts "Sensed nSRST asserted."
 }
 
+# measure actual JTAG clock
+proc measure_clk {} {
+	set start_time [ms];
+	runtest 10000000; 
+	echo "Running at more than [expr 10000.0 / ([ms]-$start_time)] kHz";
+}
+
+add_help_text measure_clk "Runs a test to measure the JTAG clk. Useful with RCLK / RTCK."
+
 # BEGIN MIGRATION AIDS ...  these adapter operations originally had
 # JTAG-specific names despite the fact that the operations were not
 # specific to JTAG, or otherewise had troublesome/misleading names.

commit 803351ec59cb57c63129c77d95b5edf2fc65c302
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sat Jul 31 21:45:56 2010 +0200

    jtag: add jtag_flush_queue_sleep debug command
    
    it can be useful to throttle performance: test
    differences in behavior, test performance effect
    of long roundtrips.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 352985f..1068681 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -46,6 +46,9 @@
 /// The number of JTAG queue flushes (for profiling and debugging purposes).
 static int jtag_flush_queue_count;
 
+// Sleep this # of ms after flushing the queue
+static int jtag_flush_queue_sleep = 0;
+
 static void jtag_add_scan_check(struct jtag_tap *active,
 		void (*jtag_add_scan)(struct jtag_tap *active, int in_num_fields, const struct scan_field *in_fields, tap_state_t state),
 		int in_num_fields, struct scan_field *in_fields, tap_state_t state);
@@ -129,6 +132,11 @@ static struct jtag_interface *jtag = NULL;
 /* configuration */
 struct jtag_interface *jtag_interface = NULL;
 
+void jtag_set_flush_queue_sleep(int ms)
+{
+	jtag_flush_queue_sleep = ms;
+}
+
 void jtag_set_error(int error)
 {
 	if ((error == ERROR_OK) || (jtag_error != ERROR_OK))
@@ -826,6 +834,15 @@ void jtag_execute_queue_noclear(void)
 {
 	jtag_flush_queue_count++;
 	jtag_set_error(interface_jtag_execute_queue());
+
+	if (jtag_flush_queue_sleep > 0)
+	{
+		/* For debug purposes it can be useful to test performance
+		 * or behavior when delaying after flushing the queue,
+		 * e.g. to simulate long roundtrip times.
+		 */
+		usleep(jtag_flush_queue_sleep * 1000);
+	}
 }
 
 int jtag_get_flush_queue_count(void)
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 3b0a145..d6e49e0 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -311,6 +311,10 @@ int  adapter_init(struct command_context* cmd_ctx);
 /// Shutdown the debug adapter upon program exit.
 int  adapter_quit(void);
 
+/// Set ms to sleep after jtag_execute_queue() flushes queue. Debug
+/// purposes.
+void jtag_set_flush_queue_sleep(int ms);
+
 /**
  * Initialize JTAG chain using only a RESET reset. If init fails,
  * try reset + init.
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index ea6d07e..69045c6 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -1248,7 +1248,31 @@ COMMAND_HANDLER(handle_tms_sequence_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_jtag_flush_queue_sleep)
+{
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	int sleep_ms;
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], sleep_ms);
+
+	jtag_set_flush_queue_sleep(sleep_ms);
+
+	return ERROR_OK;
+}
+
+
+
 static const struct command_registration jtag_command_handlers[] = {
+
+	{
+		.name = "jtag_flush_queue_sleep",
+		.handler = handle_jtag_flush_queue_sleep,
+		.mode = COMMAND_ANY,
+		.help = "For debug purposes(simulate long delays of interface) "
+				"to test performance or change in behavior. Default 0ms.",
+		.usage = "[sleep in ms]",
+	},
 	{
 		.name = "jtag_rclk",
 		.handler = handle_jtag_rclk_command,

commit 630fc86ee339aa400f58fe80cbc5a1926eb3ef39
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Aug 1 09:35:58 2010 +0200

    util: ms command to calculate length of operations
    
    This can be used to calculate approximate RTCK frequency
    for instance.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 1e3152e..f6e040f 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2007-2009 by ??yvind Harboe                              *
+ *   Copyright (C) 2007-2010 by ??yvind Harboe                              *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -24,6 +24,7 @@
 #include <helper/types.h>
 #include <jtag/jtag.h>
 #include <helper/ioutil.h>
+#include <helper/util.h>
 #include <helper/configuration.h>
 
 #include <server/server.h>
@@ -1089,6 +1090,9 @@ int main(int argc, char *argv[])
 	command_set_output_handler(cmd_ctx, configuration_output_handler, NULL);
 	command_context_mode(cmd_ctx, COMMAND_CONFIG);
 
+	if (util_init(cmd_ctx) != ERROR_OK)
+		return EXIT_FAILURE;
+
 	if (ioutil_init(cmd_ctx) != ERROR_OK)
 		return EXIT_FAILURE;
 
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 27ae1e2..cca5ac3 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -22,7 +22,8 @@ libhelper_la_SOURCES = \
 	command.c \
 	time_support.c \
 	replacements.c \
-	fileio.c
+	fileio.c \
+	util.c
 
 if IOUTIL
 libhelper_la_SOURCES += ioutil.c
@@ -40,6 +41,7 @@ noinst_HEADERS = \
 	binarybuffer.h \
 	configuration.h \
 	ioutil.h \
+	util.h \
 	types.h \
 	log.h \
 	command.h \
diff --git a/src/helper/util.c b/src/helper/util.c
new file mode 100644
index 0000000..12b83f6
--- /dev/null
+++ b/src/helper/util.c
@@ -0,0 +1,62 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by ??yvind Harboe                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/* this file contains various functionality useful to standalone systems */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "log.h"
+#include "time_support.h"
+
+static int
+util_Jim_Command_ms(Jim_Interp *interp,
+                                   int argc,
+		Jim_Obj * const *argv)
+{
+	if (argc != 1)
+	{
+		Jim_WrongNumArgs(interp, 1, argv, "ls ?dir?");
+		return JIM_ERR;
+	}
+
+	/* Cast from 64 to 32 bit int works for 2's-compliment
+	 * when calculating differences*/
+	Jim_SetResult(interp, Jim_NewIntObj(interp, (int)timeval_ms()));
+
+	return JIM_OK;
+}
+
+static const struct command_registration util_command_handlers[] = {
+	// jim handlers
+	{
+		.name = "ms",
+		.mode = COMMAND_ANY,
+		.jim_handler = util_Jim_Command_ms,
+		.help = "Returns ever increasing milliseconds. Used to calculuate differences in time.",
+		.usage = "",
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int util_init(struct command_context *cmd_ctx)
+{
+	return register_commands(cmd_ctx, NULL, util_command_handlers);
+}
diff --git a/src/helper/util.h b/src/helper/util.h
new file mode 100644
index 0000000..267477a
--- /dev/null
+++ b/src/helper/util.h
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by ??yvind Harboe                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef HELPER_UTILS_H
+#define HELPER_UTILS_H
+
+struct command_context;
+
+int util_init(struct command_context *cmd_ctx);
+
+#endif // HELPER_UTILS_H
diff --git a/src/openocd.c b/src/openocd.c
index 04a6307..69ed760 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -33,6 +33,7 @@
 #include <jtag/jtag.h>
 #include <jtag/transport.h>
 #include <helper/ioutil.h>
+#include <helper/util.h>
 #include <helper/configuration.h>
 #include <flash/nor/core.h>
 #include <flash/nand/core.h>
@@ -268,6 +269,9 @@ int openocd_main(int argc, char *argv[])
 
 	cmd_ctx = setup_command_handler(NULL);
 
+	if (util_init(cmd_ctx) != ERROR_OK)
+		return EXIT_FAILURE;
+
 	if (ioutil_init(cmd_ctx) != ERROR_OK)
 		return EXIT_FAILURE;
 

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c                        |    6 ++-
 src/helper/Makefile.am                 |    4 +-
 src/{target/testee.c => helper/util.c} |   68 ++++++++++++++------------------
 src/helper/{ioutil.h => util.h}        |   10 ++--
 src/jtag/core.c                        |   17 ++++++++
 src/jtag/jtag.h                        |    4 ++
 src/jtag/startup.tcl                   |    9 ++++
 src/jtag/tcl.c                         |   24 +++++++++++
 src/openocd.c                          |    4 ++
 9 files changed, 101 insertions(+), 45 deletions(-)
 copy src/{target/testee.c => helper/util.c} (59%)
 copy src/helper/{ioutil.h => util.h} (86%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  2 12:01:50 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  2 Aug 2010 10:01:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-460-g6ed9ab5
Message-ID: <E1OfrqB-0001PR-St@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6ed9ab5b58a121ace24620b2efb830412acf7599 (commit)
      from  ab818f68984aaf56f8b966f4b2e2da4e7f1051c9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6ed9ab5b58a121ace24620b2efb830412acf7599
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Aug 2 11:59:46 2010 +0200

    ioutil: fix internal fn names
    
    prefix w/ioutil_
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/ioutil.c b/src/helper/ioutil.c
index 14f6e91..d0f86a9 100644
--- a/src/helper/ioutil.c
+++ b/src/helper/ioutil.c
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2007-2008 by ??yvind Harboe                              *
+ *   Copyright (C) 2007-2010 by ??yvind Harboe                              *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -418,7 +418,7 @@ COMMAND_HANDLER(handle_rm_command)
 
 
 static int
-zylinjtag_Jim_Command_ls(Jim_Interp *interp,
+ioutil_Jim_Command_ls(Jim_Interp *interp,
                                    int argc,
 		Jim_Obj * const *argv)
 {
@@ -458,7 +458,7 @@ zylinjtag_Jim_Command_ls(Jim_Interp *interp,
 }
 
 static int
-zylinjtag_Jim_Command_peek(Jim_Interp *interp,
+ioutil_Jim_Command_peek(Jim_Interp *interp,
                                    int argc,
 		Jim_Obj * const *argv)
 {
@@ -480,7 +480,7 @@ zylinjtag_Jim_Command_peek(Jim_Interp *interp,
 }
 
 static int
-zylinjtag_Jim_Command_poke(Jim_Interp *interp,
+ioutil_Jim_Command_poke(Jim_Interp *interp,
                                    int argc,
 		Jim_Obj * const *argv)
 {
@@ -504,7 +504,7 @@ zylinjtag_Jim_Command_poke(Jim_Interp *interp,
 
 
 /* not so pretty code to fish out ip number*/
-static int zylinjtag_Jim_Command_ip(Jim_Interp *interp, int argc,
+static int ioutil_Jim_Command_ip(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv)
 {
 #if !defined(__CYGWIN__)
@@ -551,7 +551,7 @@ static int zylinjtag_Jim_Command_ip(Jim_Interp *interp, int argc,
 }
 
 /* not so pretty code to fish out eth0 mac address */
-static int zylinjtag_Jim_Command_mac(Jim_Interp *interp, int argc,
+static int ioutil_Jim_Command_mac(Jim_Interp *interp, int argc,
 		Jim_Obj * const *argv)
 {
 
@@ -661,10 +661,6 @@ static const struct command_registration ioutil_command_handlers[] = {
 	},
 
 	/*
-	 * REVISIT shouldn't most, or all, these zylinjtag_*()
-	 * entries be #ifdef ZY1000?  If not, why so they have
-	 * those names?
-	 *
 	 * Peek and poke are security holes -- they manipulate
 	 * server-internal addresses.
 	 */
@@ -673,33 +669,33 @@ static const struct command_registration ioutil_command_handlers[] = {
 	{
 		.name = "peek",
 		.mode = COMMAND_ANY,
-		.jim_handler = zylinjtag_Jim_Command_peek,
+		.jim_handler = ioutil_Jim_Command_peek,
 		.help = "peek at a memory address",
 		.usage = "address",
 	},
 	{
 		.name = "poke",
 		.mode = COMMAND_ANY,
-		.jim_handler = zylinjtag_Jim_Command_poke,
+		.jim_handler = ioutil_Jim_Command_poke,
 		.help = "poke at a memory address",
 		.usage = "address value",
 	},
 	{
 		.name = "ls",
 		.mode = COMMAND_ANY,
-		.jim_handler = zylinjtag_Jim_Command_ls,
+		.jim_handler = ioutil_Jim_Command_ls,
 		.help = "show a listing of files",
 		.usage = "dirname",
 	},
 	{
 		.name = "mac",
 		.mode = COMMAND_ANY,
-		.jim_handler = zylinjtag_Jim_Command_mac,
+		.jim_handler = ioutil_Jim_Command_mac,
 		.help = "show MAC address",
 	},
 	{
 		.name = "ip",
-		.jim_handler = zylinjtag_Jim_Command_ip,
+		.jim_handler = ioutil_Jim_Command_ip,
 		.mode = COMMAND_ANY,
 		.help = "show IP address",
 	},

-----------------------------------------------------------------------

Summary of changes:
 src/helper/ioutil.c |   26 +++++++++++---------------
 1 files changed, 11 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  2 16:25:57 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  2 Aug 2010 14:25:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-461-gd1638ab
Message-ID: <E1Ofvxs-0005RZ-9D@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d1638abd6a67ea028a3896c356af3fe135c719c7 (commit)
      from  6ed9ab5b58a121ace24620b2efb830412acf7599 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d1638abd6a67ea028a3896c356af3fe135c719c7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Aug 2 13:21:21 2010 +0200

    lpc1768: even if rclk "works", it isn't necessarily the correct clk
    
    rclk = 4MHz oon lpc1768, the correct JTAG clk is 666MHz(4MHz/6).
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index 88827fa..ff92e4a 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -50,8 +50,12 @@ flash bank $_FLASHNAME lpc2000 0x0 0x80000 0 0 $_TARGETNAME \
 # JTAG clock should be CCLK/6 (unless using adaptive clocking)
 # CCLK is 4 MHz after reset, and until board-specific code (like
 # a reset-init handler) speeds it up.
-jtag_rclk [ expr 4000 / 6 ]
-$_TARGETNAME configure -event reset-start { jtag_rclk [ expr 4000 / 6]  }
+#
+# Although rclk "appears to work", it turns out that this yields
+# 4MHz whereas the "correct" rate is CCLK/6, which is not what
+# you get with rclk.
+jtag_khz [ expr 4000 / 6 ]
+
 
 
 $_TARGETNAME configure -event reset-init {

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc1768.cfg |    8 ++++++--
 1 files changed, 6 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  2 22:23:08 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  2 Aug 2010 20:23:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-463-gc49d4c9
Message-ID: <E1Og1XT-0004tU-Co@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c49d4c9f7f43979e3abf04067dc38535f7ebc45a (commit)
       via  4e27305ed5dac23e8b9a43e43b4b908dc53a0a20 (commit)
      from  d1638abd6a67ea028a3896c356af3fe135c719c7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c49d4c9f7f43979e3abf04067dc38535f7ebc45a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Aug 2 22:12:33 2010 +0200

    zy1000: use correct base clock when calculating speed divisor
    
    revc uses 60MHz and revb 64MHz, use this in calculations.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 23f2fdd..3ecd0f9 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1,4 +1,4 @@
-'n/***************************************************************************
+/***************************************************************************
  *   Copyright (C) 2007-2010 by ??yvind Harboe                              *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -62,6 +62,9 @@
 #ifdef CYGPKG_HAL_NIOS2
 #include <cyg/hal/io.h>
 #include <cyg/firmwareutil/firmwareutil.h>
+#define ZYLIN_KHZ 60000
+#else
+#define ZYLIN_KHZ 64000
 #endif
 
 #define ZYLIN_VERSION GIT_ZY1000_VERSION
@@ -70,6 +73,9 @@
 #define ZYLIN_OPENOCD GIT_OPENOCD_VERSION
 #define ZYLIN_OPENOCD_VERSION "ZY1000 " ZYLIN_VERSION " " ZYLIN_DATE
 
+#else
+/* Assume we're connecting to a revc w/60MHz clock. */
+#define ZYLIN_KHZ 60000
 #endif
 
 
@@ -102,7 +108,7 @@ static int zy1000_khz(int khz, int *jtag_speed)
 		 * 64000 / 6 = 10666
 		 *
 		 */
-		speed = (64000 + (khz -1)) / khz;
+		speed = (ZYLIN_KHZ + (khz -1)) / khz;
 		speed = (speed + 1 ) / 2;
 		speed *= 2;
 		if (speed > 8190)
@@ -123,7 +129,7 @@ static int zy1000_speed_div(int speed, int *khz)
 	}
 	else
 	{
-		*khz = 64000/speed;
+		*khz = ZYLIN_KHZ / speed;
 	}
 
 	return ERROR_OK;
@@ -265,7 +271,8 @@ int zy1000_speed(int speed)
 	{
 		if (speed > 8190 || speed < 2)
 		{
-			LOG_USER("valid ZY1000 jtag_speed=[8190,2]. Divisor is 64MHz / even values between 8190-2, i.e. min 7814Hz, max 32MHz");
+			LOG_USER("valid ZY1000 jtag_speed=[8190,2]. With divisor is %dkHz / even values between 8190-2, i.e. min %dHz, max %dMHz",
+					ZYLIN_KHZ, (ZYLIN_KHZ * 1000) / 8190, ZYLIN_KHZ / (2 * 1000));
 			return ERROR_INVALID_ARGUMENTS;
 		}
 

commit 4e27305ed5dac23e8b9a43e43b4b908dc53a0a20
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Aug 2 17:09:57 2010 +0200

    zy1000: print out khz correctly in response to setting JTAG speed
    
    Calculate printout based on same core routines.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 28c65b6..23f2fdd 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1,4 +1,4 @@
-/***************************************************************************
+'n/***************************************************************************
  *   Copyright (C) 2007-2010 by ??yvind Harboe                              *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -84,7 +84,33 @@ static int zy1000_khz(int khz, int *jtag_speed)
 	}
 	else
 	{
-		*jtag_speed = 64000/khz;
+		int speed;
+		/* Round speed up to nearest divisor.
+		 *
+		 * E.g. 16000kHz
+		 * (64000 + 15999) / 16000 = 4
+		 * (4 + 1) / 2 = 2
+		 * 2 * 2 = 4
+		 *
+		 * 64000 / 4 = 16000
+		 *
+		 * E.g. 15999
+		 * (64000 + 15998) / 15999 = 5
+		 * (5 + 1) / 2 = 3
+		 * 3 * 2 = 6
+		 *
+		 * 64000 / 6 = 10666
+		 *
+		 */
+		speed = (64000 + (khz -1)) / khz;
+		speed = (speed + 1 ) / 2;
+		speed *= 2;
+		if (speed > 8190)
+		{
+			/* maximum dividend */
+			speed = 8190;
+		}
+		*jtag_speed = speed;
 	}
 	return ERROR_OK;
 }
@@ -243,9 +269,12 @@ int zy1000_speed(int speed)
 			return ERROR_INVALID_ARGUMENTS;
 		}
 
-		LOG_USER("jtag_speed %d => JTAG clk=%f", speed, 64.0/(float)speed);
+		int khz;
+		speed &= ~1;
+		zy1000_speed_div(speed, &khz);
+		LOG_USER("jtag_speed %d => JTAG clk=%d kHz", speed, khz);
 		ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x100);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x1c, speed&~1);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x1c, speed);
 	}
 	return ERROR_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   46 +++++++++++++++++++++++++++++++++++++++++-----
 1 files changed, 41 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  2 22:37:30 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  2 Aug 2010 20:37:30 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-464-gbfa34f8
Message-ID: <E1Og1lN-0005i8-PS@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bfa34f88f8b77596d6f70be446708a3f5a604e9b (commit)
      from  c49d4c9f7f43979e3abf04067dc38535f7ebc45a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bfa34f88f8b77596d6f70be446708a3f5a604e9b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Aug 2 16:55:46 2010 +0200

    verify_image: print out a statement that there are no further errors
    
    It is useful to know that the printed errors are *all* the
    errors there were.
    
    Added missing error handling(found by inspection).
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 3bf6824..f178ae3 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2703,7 +2703,12 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 		if (verify)
 		{
 			/* calculate checksum of image */
-			image_calculate_checksum(buffer, buf_cnt, &checksum);
+			retval = image_calculate_checksum(buffer, buf_cnt, &checksum);
+			if (retval != ERROR_OK)
+			{
+				free(buffer);
+				break;
+			}
 
 			retval = target_checksum_memory(target, image.sections[i].base_address, buf_cnt, &mem_checksum);
 			if (retval != ERROR_OK)
@@ -2769,6 +2774,10 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 		free(buffer);
 		image_size += buf_cnt;
 	}
+	if (diffs > 0)
+	{
+		command_print(CMD_CTX, "No more differences found.");
+	}
 done:
 	if (diffs > 0)
 	{

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  2 23:18:50 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  2 Aug 2010 21:18:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-465-g7682877
Message-ID: <E1Og2PM-0006f8-ND@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7682877c8ca59226f7131db5fe35253acf117bb4 (commit)
      from  bfa34f88f8b77596d6f70be446708a3f5a604e9b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7682877c8ca59226f7131db5fe35253acf117bb4
Author: Mike Dunn <mikedunn at newsguy.com>
Date:   Mon Aug 2 12:50:29 2010 -0700

    xscale documentation: vector table handling
    
    Hi everyone.  I noticed some incorrect information in the user manual
    regarding how the vector table is handled on the xscale, so for your
    consideration, here's a short patch that corrects it, and adds a
    little more detail I thought might be helpful.
    
    The documentation states that OpenOCD does not attempt to synchronize
    the vector tables in memory with those stored in the "mini instruction
    cache".  In fact, on each resume it does copy from memory to the cache
    all entries in the high and low tables that were not previously
    defined using the 'xscale vector_table' command. (In
    src/target/xscale.c, see xscale_update_vectors(), which is invoked by
    xscale_resume().)  I take advantage of this during Linux boot-up.  The
    extra detail describes in general terms how I do this.
    
    Corrections, comments are of course gratefully received.
    
    Thanks,
    Mike
    
    Signed-off-by: Mike Dunn <mikedunn at newsguy.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 97d2e81..0e57c1a 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -6337,10 +6337,10 @@ handler. However, this means that the complete first cacheline in the
 mini-IC is marked valid, which makes the CPU fetch all exception
 handlers from the mini-IC, ignoring the code in RAM.
 
-OpenOCD currently does not sync the mini-IC entries with the RAM
-contents (which would fail anyway while the target is running), so
-the user must provide appropriate values using the @code{xscale
-vector_table} command.
+To address this situation, OpenOCD provides the @code{xscale
+vector_table} command, which allows the user to explicity write
+individual entries to either the high or low vector table stored in
+the mini-IC.
 
 It is recommended to place a pc-relative indirect branch in the vector
 table, and put the branch destination somewhere in memory. Doing so
@@ -6367,6 +6367,24 @@ _vectors:
         .long real_fiq_handler
 @end example
 
+Alternatively, you may choose to keep some or all of the mini-IC
+vector table entries synced with those written to memory by your
+system software.  The mini-IC can not be modified while the processor
+is executing, but for each vector table entry not previously defined
+using the @code{xscale vector_table} command, OpenOCD will copy the
+value from memory to the mini-IC every time execution resumes from a
+halt.  This is done for both high and low vector tables (although the
+table not in use may not be mapped to valid memory, and in this case
+that copy operation will silently fail).  This means that you will
+need to briefly halt execution at some strategic point during system
+start-up; e.g., after the software has initialized the vector table,
+but before exceptions are enabled.  A breakpoint can be used to
+accomplish this once the appropriate location in the start-up code has
+been identified.  A watchpoint over the vector table region is helpful
+in finding the location if you're not sure.  Note that the same
+situation exists any time the vector table is modified by the system
+software.
+
 The debug handler must be placed somewhere in the address space using
 the @code{xscale debug_handler} command.  The allowed locations for the
 debug handler are either (0x800 - 0x1fef800) or (0xfe000800 -

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |   26 ++++++++++++++++++++++----
 1 files changed, 22 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Aug  4 03:54:23 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed,  4 Aug 2010 01:54:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-466-g28ddefd
Message-ID: <E1OgTBe-0007x9-Ab@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  28ddefd0659048773fd6066d0265fca76ca036d5 (commit)
      from  7682877c8ca59226f7131db5fe35253acf117bb4 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 28ddefd0659048773fd6066d0265fca76ca036d5
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Aug 3 21:29:05 2010 -0400

    Luminary-icdi comment update
    
    Clarify that ICDI is the generic logic, but this config is
    for the JTAG-only (no-SWD) mode.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/interface/luminary-icdi.cfg b/tcl/interface/luminary-icdi.cfg
index ec77256..94e00ae 100644
--- a/tcl/interface/luminary-icdi.cfg
+++ b/tcl/interface/luminary-icdi.cfg
@@ -2,6 +2,10 @@
 # Luminary Micro Stellaris LM3S9B9x Evaluation Kits
 # In-Circuit Debug Interface (ICDI) Board
 #
+# Essentially all Luminary debug hardware is the same, (with both
+# JTAG and SWD support compatible with ICDI boards.  This ICDI adapter
+# configuration is JTAG-only, but the same hardware handles SWD too.
+#
 # This is a discrete FT2232 based debug board which supports ARM's
 # JTAG/SWD connectors in both backwards-compatible 20-pin format and
 # in the new-style compact 10-pin.  There's also an 8-pin connector

-----------------------------------------------------------------------

Summary of changes:
 tcl/interface/luminary-icdi.cfg |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Aug  9 09:52:20 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  9 Aug 2010 07:52:20 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-468-g3e71449
Message-ID: <E1OiN9i-000207-2i@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3e71449adec41bf2a9f498d027aae0ba6e83721f (commit)
       via  1399e5f753256e7b5523f1eb260cdd7e95e80dee (commit)
      from  28ddefd0659048773fd6066d0265fca76ca036d5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3e71449adec41bf2a9f498d027aae0ba6e83721f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Aug 8 19:21:04 2010 +0200

    arm7/9: fix "reset run + halt"
    
    if polling is off, then "reset run + halt" would fail
    since halt incorrectly assumed the target was in the
    reset state as it is the internal poll implementation
    that moves the sw tracking of the target state out
    of the reset state.
    
    To reproduce:
    
    > reset run; halt
    JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)
    BUG: arm7/9 does not support halt during reset. This is handled in arm7_9_assert_reset()
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index abfb21b..3bbe8b0 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1074,24 +1074,29 @@ int arm7_9_deassert_reset(struct target *target)
 	/* deassert reset lines */
 	jtag_add_reset(0, 0);
 
+	/* In case polling is disabled, we need to examine the
+	 * target and poll here for this target to work correctly.
+	 *
+	 * Otherwise, e.g. halt will fail afterwards with bogus
+	 * error messages as halt will believe that reset is
+	 * still in effect.
+	 */
+	if ((retval = target_examine_one(target)) != ERROR_OK)
+		return retval;
+
+	if ((retval = target_poll(target)) != ERROR_OK)
+	{
+		return retval;
+	}
+
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
 	if (target->reset_halt && (jtag_reset_config & RESET_SRST_PULLS_TRST) != 0)
 	{
 		LOG_WARNING("srst pulls trst - can not reset into halted mode. Issuing halt after reset.");
-		/* set up embedded ice registers again */
-		if ((retval = target_examine_one(target)) != ERROR_OK)
-			return retval;
-
-		if ((retval = target_poll(target)) != ERROR_OK)
-		{
-			return retval;
-		}
-
 		if ((retval = target_halt(target)) != ERROR_OK)
 		{
 			return retval;
 		}
-
 	}
 	return retval;
 }
diff --git a/src/target/target_type.h b/src/target/target_type.h
index d3db8b5..10fcd4f 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008,2009 ??yvind Harboe                            *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008 by Spencer Oliver                                  *
@@ -73,6 +73,17 @@ struct target_type
 	 *
 	 */
 	int (*assert_reset)(struct target *target);
+	/**
+	 * The implementation is responsible for polling the
+	 * target such that target->state reflects the
+	 * state correctly.
+	 *
+	 * Otherwise the following would fail, as there will not
+	 * be any "poll" invoked inbetween the "reset run" and
+	 * "halt".
+	 *
+	 * reset run; halt
+     */
 	int (*deassert_reset)(struct target *target);
 	int (*soft_reset_halt_imp)(struct target *target);
 	int (*soft_reset_halt)(struct target *target);

commit 1399e5f753256e7b5523f1eb260cdd7e95e80dee
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Aug 8 09:14:54 2010 +0200

    target: if polling fails, back off
    
    back-off algorithm for polling. Double polling
    interval up to 5000ms when it fails.
    
    when polling succeeds, reset backoff.
    
    This avoids flooding logs(as much) when working
    with conditions where the target polling will fail.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index f178ae3..d7607e3 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -96,6 +96,7 @@ static struct target_type *target_types[] =
 struct target *all_targets = NULL;
 static struct target_event_callback *target_event_callbacks = NULL;
 static struct target_timer_callback *target_timer_callbacks = NULL;
+static const int polling_interval = 100;
 
 static const Jim_Nvp nvp_assert[] = {
 	{ .name = "assert", NVP_ASSERT },
@@ -862,7 +863,7 @@ static int target_init(struct command_context *cmd_ctx)
 		return retval;
 
 	retval = target_register_timer_callback(&handle_target,
-			100, 1, cmd_ctx->interp);
+			polling_interval, 1, cmd_ctx->interp);
 	if (ERROR_OK != retval)
 		return retval;
 
@@ -1800,6 +1801,9 @@ static int sense_handler(void)
 	return ERROR_OK;
 }
 
+static int backoff_times = 0;
+static int backoff_count = 0;
+
 /* process target state changes */
 static int handle_target(void *priv)
 {
@@ -1862,6 +1866,14 @@ static int handle_target(void *priv)
 		recursive = 0;
 	}
 
+	if (backoff_times > backoff_count)
+	{
+		/* do not poll this time as we failed previously */
+		backoff_count++;
+		return ERROR_OK;
+	}
+	backoff_count = 0;
+
 	/* Poll targets for state changes unless that's globally disabled.
 	 * Skip targets that are currently disabled.
 	 */
@@ -1878,17 +1890,26 @@ static int handle_target(void *priv)
 			/* polling may fail silently until the target has been examined */
 			if ((retval = target_poll(target)) != ERROR_OK)
 			{
-				/* FIX!!!!! If we add a LOG_INFO() here to output a line in GDB
-				 * *why* we are aborting GDB, then we'll spam telnet when the
-				 * poll is failing persistently.
-				 *
-				 * If we could implement an event that detected the
-				 * target going from non-pollable to pollable, we could issue
-				 * an error only upon the transition.
+				/* 100ms polling interval. Increase interval between polling up to 5000ms */
+				if (backoff_times * polling_interval < 5000)
+				{
+					backoff_times *= 2;
+					backoff_times++;
+				}
+				LOG_USER("Polling target failed, GDB will be halted. Polling again in %dms", backoff_times * polling_interval);
+
+				/* Tell GDB to halt the debugger. This allows the user to
+				 * run monitor commands to handle the situation.
 				 */
 				target_call_event_callbacks(target, TARGET_EVENT_GDB_HALT);
 				return retval;
 			}
+			/* Since we succeeded, we reset backoff count */
+			if (backoff_times > 0)
+			{
+				LOG_USER("Polling succeeded again");
+			}
+			backoff_times = 0;
 		}
 	}
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c |   25 +++++++++++++++----------
 src/target/target.c        |   37 +++++++++++++++++++++++++++++--------
 src/target/target_type.h   |   13 ++++++++++++-
 3 files changed, 56 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug 10 09:50:14 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 10 Aug 2010 07:50:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-469-g91305bf
Message-ID: <E1OijbE-0005No-C2@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  91305bfa7f550c96b967008c1512864cffdaa52a (commit)
      from  3e71449adec41bf2a9f498d027aae0ba6e83721f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 91305bfa7f550c96b967008c1512864cffdaa52a
Author: Ben Gardiner <bengardiner at nanometrics.ca>
Date:   Mon Aug 9 14:41:56 2010 -0400

    cfg: add omapl138 support and da850evm preliminary support
    
    This patch adds support for the omapl138 target and preliminary support for the da850evm. The
    target cfg file is based on the icepick routing done by the target/ti_dm6446.cfg file.
    
    I have performed limited testing with this setup. I am posting this patch in the interest of
    sharing cfg files and in the hopes that the experts on this list can correct errors I have made or
    point out enhancements.
    
    The testing I have performed is debugging uboot with gdb where I also use the following local.cfg
    and gdbinit files. Debugging appears to work in so much as 'ni' works.
    
    local.cfg:
    gdb_memory_map disable
    
    gdbinit:
    target remote localhost:3333
    set remote hardware-breakpoint-limit 2
    set remote hardware-watchpoint-limit 2
    monitor poll on
    
    Comments welcome.
    
    Best Regards,
    Ben Gardiner

diff --git a/tcl/board/da850evm.cfg b/tcl/board/da850evm.cfg
new file mode 100644
index 0000000..fbec609
--- /dev/null
+++ b/tcl/board/da850evm.cfg
@@ -0,0 +1,10 @@
+#DA850 EVM board
+# http://focus.ti.com/dsp/docs/thirdparty/catalog/devtoolsproductfolder.tsp?actionPerformed=productFolder&productId=5939
+# http://www.logicpd.com/products/development-kits/zoom-omap-l138-evm-development-kit
+
+source [find target/omapl138.cfg]
+
+reset_config trst_and_srst separate
+
+#currently any pinmux/timing must be setup by UBL before openocd can do debug
+#TODO: implement pinmux/timing on reset like in board/dm365evm.cfg
diff --git a/tcl/target/omapl138.cfg b/tcl/target/omapl138.cfg
new file mode 100644
index 0000000..6e06a19
--- /dev/null
+++ b/tcl/target/omapl138.cfg
@@ -0,0 +1,66 @@
+#
+# Texas Instruments DaVinci family:  OMAPL138
+#
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME omapl138
+}
+
+source [find target/icepick.cfg]
+
+# Subsidiary TAP: ARM ETB11, with scan chain for 4K of ETM trace buffer
+if { [info exists ETB_TAPID ] } {
+   set _ETB_TAPID $ETB_TAPID
+} else {
+   set _ETB_TAPID 0x2b900f0f
+}
+jtag newtap $_CHIPNAME etb -irlen 4 -irmask 0xf -expected-id $_ETB_TAPID -disable
+jtag configure $_CHIPNAME.etb -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 3"
+
+# Subsidiary TAP: ARM926ejs with scan chains for ARM Debug, EmbeddedICE-RT, ETM.
+if { [info exists CPU_TAPID ] } {
+   set _CPU_TAPID $CPU_TAPID
+} else {
+   set _CPU_TAPID 0x07926001
+}
+jtag newtap $_CHIPNAME arm -irlen 4 -irmask 0xf -expected-id $_CPU_TAPID -disable
+jtag configure $_CHIPNAME.arm -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 2"
+
+# Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
+if { [info exists JRC_TAPID ] } {
+   set _JRC_TAPID $JRC_TAPID
+} else {
+   set _JRC_TAPID 0x0b7d102f
+}
+jtag newtap $_CHIPNAME jrc -irlen 6 -irmask 0x3f -expected-id $_JRC_TAPID
+
+jtag configure $_CHIPNAME.jrc -event setup \
+	"jtag tapenable $_CHIPNAME.etb; jtag tapenable $_CHIPNAME.arm"
+
+################
+# GDB target:  the ARM, using SRAM1 for scratch.  SRAM0 (also 8K)
+# and the ETB memory (4K) are other options, while trace is unused.
+# Little-endian; use the OpenOCD default.
+set _TARGETNAME $_CHIPNAME.arm
+
+target create $_TARGETNAME arm926ejs -chain-position $_TARGETNAME
+$_TARGETNAME configure -work-area-phys 0x80000000 -work-area-size 0x2000
+
+# be absolutely certain the JTAG clock will work with the worst-case
+# CLKIN = 20 MHz (best case: 30 MHz) even when no bootloader turns
+# on the PLL and starts using it.  OK to speed up after clock setup.
+jtag_rclk 1500
+$_TARGETNAME configure -event "reset-start" { jtag_rclk 1500 }
+
+arm7_9 fast_memory_access enable
+arm7_9 dcc_downloads enable
+
+# trace setup
+etm config $_TARGETNAME 16 normal full etb
+etb config $_TARGETNAME $_CHIPNAME.etb
+
+gdb_breakpoint_override hard
+arm7_9 dbgrq enable

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/da850evm.cfg                     |   10 +++++++
 tcl/target/{ti_dm6446.cfg => omapl138.cfg} |   37 ++++++++-------------------
 2 files changed, 21 insertions(+), 26 deletions(-)
 create mode 100644 tcl/board/da850evm.cfg
 copy tcl/target/{ti_dm6446.cfg => omapl138.cfg} (67%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 11 17:09:15 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 11 Aug 2010 15:09:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-472-g676f48d
Message-ID: <E1OjCvk-0007tp-B6@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  676f48d77db83c687740955aed6783ea6d326853 (commit)
       via  f941192723f7d71ae4a9a8f011dad5909f156da3 (commit)
       via  ba951aede3aa98591087428955dad51279e6a5ea (commit)
      from  91305bfa7f550c96b967008c1512864cffdaa52a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 676f48d77db83c687740955aed6783ea6d326853
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Aug 11 11:00:02 2010 +0200

    debug: use assert's when approperiate
    
    error was returned instead of using assert.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
index 37c228f..f581278 100644
--- a/src/target/arm_jtag.h
+++ b/src/target/arm_jtag.h
@@ -45,8 +45,7 @@ static inline int arm_jtag_set_instr(struct arm_jtag *jtag_info,
 	/* inline most common code path */
 	struct jtag_tap *tap;
 	tap = jtag_info->tap;
-	if (tap == NULL)
-		return ERROR_FAIL;
+	assert (tap != NULL);
 
 	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != new_instr)
 	{
diff --git a/src/target/xscale.c b/src/target/xscale.c
index c0080b2..44358bc 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -160,8 +160,7 @@ static int xscale_verify_pointer(struct command_context *cmd_ctx,
 
 static int xscale_jtag_set_instr(struct jtag_tap *tap, uint32_t new_instr, tap_state_t end_state)
 {
-	if (tap == NULL)
-		return ERROR_FAIL;
+	assert (tap != NULL);
 
 	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != new_instr)
 	{

commit f941192723f7d71ae4a9a8f011dad5909f156da3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Aug 11 10:58:49 2010 +0200

    arm: add missing error reporting
    
    when an unknown core mode is read from the target,
    report error. Can be communication failure.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 3bbe8b0..778e606 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007-2009 ??yvind Harboe                                 *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008 by Spencer Oliver                                  *
@@ -1518,7 +1518,10 @@ static int arm7_9_full_context(struct target *target)
 	}
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	/* iterate through processor modes (User, FIQ, IRQ, SVC, ABT, UND)
 	 * SYS shares registers with User, so we don't touch SYS
@@ -1621,7 +1624,10 @@ static int arm7_9_restore_context(struct target *target)
 		arm7_9->pre_restore_context(target);
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	/* iterate through processor modes (User, FIQ, IRQ, SVC, ABT, UND)
 	 * SYS shares registers with User, so we don't touch SYS
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 90f548f..a3a5adf 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -281,7 +281,10 @@ static int arm920t_read_cp15_interpreted(struct target *target,
 #endif
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	r[0].dirty = 1;
 	r[1].dirty = 1;
@@ -323,7 +326,10 @@ int arm920t_write_cp15_interpreted(struct target *target,
 #endif
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	r[0].dirty = 1;
 	r[1].dirty = 1;
@@ -1154,7 +1160,10 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 	fclose(output);
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	/* force writeback of the valid data */
 	r = armv4_5->core_cache->reg_list;
@@ -1481,7 +1490,10 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	fclose(output);
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	/* force writeback of the valid data */
 	r = armv4_5->core_cache->reg_list;
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index d950af3..07c8c6e 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -634,7 +634,10 @@ COMMAND_HANDLER(handle_armv4_5_reg_command)
 	}
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	if (!armv4_5->full_context) {
 		command_print(CMD_CTX, "error: target doesn't support %s",
@@ -1046,7 +1049,10 @@ int arm_get_gdb_reg_list(struct target *target,
 	int i;
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	*reg_list_size = 26;
 	*reg_list = malloc(sizeof(struct reg*) * (*reg_list_size));
@@ -1127,7 +1133,10 @@ int armv4_5_run_algorithm_inner(struct target *target,
 	}
 
 	if (!is_arm_mode(armv4_5->core_mode))
+	{
+		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
+	}
 
 	/* armv5 and later can terminate with BKPT instruction; less overhead */
 	if (!exit_point && armv4_5->is_armv4)

commit ba951aede3aa98591087428955dad51279e6a5ea
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Aug 11 10:53:54 2010 +0200

    config scripts: remove useless reference to OpenOCD docs
    
    clutters config scripts.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/microchip_explorer16.cfg b/tcl/board/microchip_explorer16.cfg
index f5c4faa..7c036c6 100644
--- a/tcl/board/microchip_explorer16.cfg
+++ b/tcl/board/microchip_explorer16.cfg
@@ -8,6 +8,3 @@ set CPUTAPID 0x30938053
 set WORKAREASIZE 32768
 
 source [find target/pic32mx.cfg]
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/board/str910-eval.cfg b/tcl/board/str910-eval.cfg
index 9e3f881..38a1477 100644
--- a/tcl/board/str910-eval.cfg
+++ b/tcl/board/str910-eval.cfg
@@ -62,6 +62,3 @@ set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 0
 set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 0
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/at91sam7sx.cfg b/tcl/target/at91sam7sx.cfg
index f3cc88e..6cbd6b6 100644
--- a/tcl/target/at91sam7sx.cfg
+++ b/tcl/target/at91sam7sx.cfg
@@ -51,6 +51,3 @@ $_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-a
 #flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME at91sam7 0 0 0 0 0 0 0 0 0 0 0 0 18432
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index 8ed6352..6f34171 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -28,6 +28,3 @@ $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-a
 # flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14765 calc_checksum
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/mega128.cfg b/tcl/target/mega128.cfg
index bb7cdee..212a267 100644
--- a/tcl/target/mega128.cfg
+++ b/tcl/target/mega128.cfg
@@ -38,6 +38,3 @@ flash bank $_FLASHNAME avr 0 0 0 0 $_TARGETNAME
 #flash write_image E:/Versaloon/Software/CAMERAPROTOCOLAGENT.hex
 #reset run
 #shutdown
-#
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index 202668b..efffd04 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -78,6 +78,3 @@ flash bank $_FLASHNAME pic32mx 0x1d000000 0 0 0 $_TARGETNAME
 # add virtual banks for kseg0 and kseg1
 flash bank vbank2 virtual 0xbd000000 0 0 0 $_TARGETNAME $_FLASHNAME
 flash bank vbank3 virtual 0x9d000000 0 0 0 $_TARGETNAME $_FLASHNAME
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/sam7x256.cfg b/tcl/target/sam7x256.cfg
index 19145e5..dd36458 100644
--- a/tcl/target/sam7x256.cfg
+++ b/tcl/target/sam7x256.cfg
@@ -48,6 +48,3 @@ $_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-a
 #flash bank <driver> <base_addr> <size> <chip_width> <bus_width> <target_number> [<target_name> <banks> <sectors_per_bank> <pages_per_sector> <page_size> <num_nvmbits> <ext_freq_khz>]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/stm32.cfg b/tcl/target/stm32.cfg
index a13dc31..fa59e35 100644
--- a/tcl/target/stm32.cfg
+++ b/tcl/target/stm32.cfg
@@ -64,6 +64,3 @@ $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE
 
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME stm32x 0 0 0 0 $_TARGETNAME
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/str710.cfg b/tcl/target/str710.cfg
index a5955b6..0f61d44 100644
--- a/tcl/target/str710.cfg
+++ b/tcl/target/str710.cfg
@@ -51,6 +51,3 @@ set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str7x 0x40000000 0x00040000 0 0 $_TARGETNAME STR71x
 set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str7x 0x400C0000 0x00004000 0 0 $_TARGETNAME STR71x
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
diff --git a/tcl/target/str912.cfg b/tcl/target/str912.cfg
index a16c83a..9b0a708 100644
--- a/tcl/target/str912.cfg
+++ b/tcl/target/str912.cfg
@@ -67,6 +67,3 @@ set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 $_TARGETNAME
 set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 $_TARGETNAME
-
-# For more information about the configuration files, take a look at:
-# openocd.texi

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c         |    8 +++++++-
 src/target/arm920t.c               |   12 ++++++++++++
 src/target/arm_jtag.h              |    3 +--
 src/target/armv4_5.c               |    9 +++++++++
 src/target/xscale.c                |    3 +--
 tcl/board/microchip_explorer16.cfg |    3 ---
 tcl/board/str910-eval.cfg          |    3 ---
 tcl/target/at91sam7sx.cfg          |    3 ---
 tcl/target/lpc2294.cfg             |    3 ---
 tcl/target/mega128.cfg             |    3 ---
 tcl/target/pic32mx.cfg             |    3 ---
 tcl/target/sam7x256.cfg            |    3 ---
 tcl/target/stm32.cfg               |    3 ---
 tcl/target/str710.cfg              |    3 ---
 tcl/target/str912.cfg              |    3 ---
 15 files changed, 30 insertions(+), 35 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 11 17:11:04 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 11 Aug 2010 15:11:04 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-473-gf1bd127
Message-ID: <E1OjCxO-0008Qt-BK@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f1bd1274ee3491c1a98c1484408ce10215391190 (commit)
      from  676f48d77db83c687740955aed6783ea6d326853 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f1bd1274ee3491c1a98c1484408ce10215391190
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Aug 11 17:09:44 2010 +0200

    board: added at91cap7a stk w/sdram config scripts
    
    The strange thing here with this board is that 16MHz kinda
    works, but only 2MHz is really stable.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/at91cap7a-stk-sdram.cfg b/tcl/board/at91cap7a-stk-sdram.cfg
new file mode 100644
index 0000000..6a7e22b
--- /dev/null
+++ b/tcl/board/at91cap7a-stk-sdram.cfg
@@ -0,0 +1,165 @@
+# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4394
+#
+# use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config trst_and_srst srst_pulls_trst
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME cap7
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x40700f0f
+}
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
+
+$_TARGETNAME configure -event reset-start {
+	# start off real slow when we're running off internal RC oscillator
+	jtag_khz 10
+}
+
+proc peek32 {address} {
+	ocd_mem2array t 32 $address 1
+	return $t(0)
+}
+
+# Wait for an expression to be true with a timeout
+proc wait_state {expression} {
+	for {set i 0} {$i < 1000} {set i [expr $i + 1]} {
+		if {[uplevel 1 $expression] == 0} {
+			return
+		}
+	}
+	return -code 1 "Timed out"	
+}
+
+# Use a global variable here to be able to tinker interactively with
+# post reset jtag frequency.
+global post_reset_khz
+# Danger!!!! Even 16MHz kinda works with this target, but 
+# it needs to be as low as 2000kHz to be stable.
+set post_reset_khz 2000
+
+$_TARGETNAME configure -event reset-init {
+	echo "Configuring master clock"
+	# disable watchdog
+	mww 0xfffffd44 0xff008000
+	# enable user reset
+	mww 0xfffffd08 0xa5000001
+	# Enable main oscillator
+	mww 0xFFFFFc20  0x00000f01
+	wait_state {expr {([peek32 0xFFFFFC68] & 0x1) == 0}}  
+
+	# Set PLLA to 96MHz
+	mww 0xFFFFFc28 0x20072801
+	wait_state {expr {([peek32 0xFFFFFC68] & 0x2) == 0}}  
+
+	# Select prescaler
+	mww 0xFFFFFC30 0x00000004
+	wait_state {expr {([peek32 0xFFFFFC68] & 0x8) == 0}}  
+
+	# Select master clock to 48MHz
+	mww 0xFFFFFC30 0x00000006
+	wait_state {expr {([peek32 0xFFFFFC68] & 0x8) == 0}}  
+
+	echo "Master clock ok."
+	echo "Configuring the SDRAM controller..."
+
+	# Configure EBI Chip select for SDRAM
+	mww 0xFFFFEF30 0x00000102
+
+	# Enable clock on EBI PIOs
+	mww 0xFFFFFC10 0x00000004
+
+	# Configure PIO for SDRAM
+	mww 0xFFFFF470 0xFFFF0000
+	mww 0xFFFFF474 0x00000000
+	mww 0xFFFFF404 0xFFFF0000
+
+	# Configure SDRAMC CR
+	mww 0xFFFFEA08 0xA63392F9
+ 
+	# NOP command
+	mww 0xFFFFEA00 0x1
+	mww 0x20000000 0
+
+	# Precharge All Banks command
+	mww 0xFFFFEA00 0x2
+	mww 0x20000000 0
+
+	# Set 1st CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000010 0x00000001
+
+	# Set 2nd CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000020 0x00000002
+
+	# Set 3rd CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000030 0x00000003
+
+	# Set 4th CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000040 0x00000004
+
+	# Set 5th CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000050 0x00000005
+
+	# Set 6th CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000060 0x00000006
+
+	# Set 7th CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000070 0x00000007
+
+	# Set 8th CBR
+	mww 0xFFFFEA00 0x00000004
+	mww 0x20000080 0x00000008
+
+	# Set LMR operation
+	mww 0xFFFFEA00 0x00000003
+
+	# Perform LMR burst=1, lat=2
+	mww 0x20000020 0xCAFEDEDE
+
+	# Set Refresh Timer
+	mww 0xFFFFEA04 0x00000203
+
+	# Set Normal mode
+	mww 0xFFFFEA00 0x00000000
+	mww 0x20000000 0x00000000
+
+	#remap internal memory at address 0x0
+	mww 0xffffef00 0x3
+	
+	echo "SDRAM configuration ok."
+
+	# Now that we're up and running, crank up speed!
+	global post_reset_khz
+	jtag_khz $post_reset_khz
+}
+
+$_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0
+
+arm7_9 dcc_downloads enable
+arm7_9 fast_memory_access enable
+
+#set _FLASHNAME $_CHIPNAME.flash
+#flash bank $_FLASHNAME at91sam7 0 0 0 0 $_TARGETNAME 0 0 0 0 0 0 0 18432
+

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/at91cap7a-stk-sdram.cfg |  165 +++++++++++++++++++++++++++++++++++++
 1 files changed, 165 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/at91cap7a-stk-sdram.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Aug 11 17:26:56 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 11 Aug 2010 15:26:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-474-g8f779cf
Message-ID: <E1OjDCp-0007kA-4t@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8f779cf66bf459616b7dad88e871c2f4a7315371 (commit)
      from  f1bd1274ee3491c1a98c1484408ce10215391190 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8f779cf66bf459616b7dad88e871c2f4a7315371
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Aug 11 17:24:55 2010 +0200

    tcl: remove silly ocd_ prefix to array2mem and mem2array
    
    ocd_ prefix is used internally in OpenOCD as a kludge more
    or less to deal with the two kinds of commands that OpenOCD
    has.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 0e57c1a..3cf5bfe 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -7209,10 +7209,10 @@ Low-level commands are (should be) prefixed with "ocd_", e.g.
 is the low level API upon which @command{flash banks} is implemented.
 
 @itemize @bullet
- at item @b{ocd_mem2array} <@var{varname}> <@var{width}> <@var{addr}> <@var{nelems}>
+ at item @b{mem2array} <@var{varname}> <@var{width}> <@var{addr}> <@var{nelems}>
 
 Read memory and return as a Tcl array for script processing
- at item @b{ocd_array2mem} <@var{varname}> <@var{width}> <@var{addr}> <@var{nelems}>
+ at item @b{array2mem} <@var{varname}> <@var{width}> <@var{addr}> <@var{nelems}>
 
 Convert a Tcl array to memory locations and write the values
 @item @b{ocd_flash_banks} <@var{driver}> <@var{base}> <@var{size}> <@var{chip_width}> <@var{bus_width}> <@var{target}> [@option{driver options} ...]
diff --git a/src/target/target.c b/src/target/target.c
index d7607e3..16caea5 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -5296,7 +5296,7 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.usage = "filename [offset [type]]",
 	},
 	{
-		.name = "ocd_mem2array",
+		.name = "mem2array",
 		.mode = COMMAND_EXEC,
 		.jim_handler = jim_mem2array,
 		.help = "read 8/16/32 bit memory and return as a TCL array "
@@ -5304,7 +5304,7 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.usage = "arrayname bitwidth address count",
 	},
 	{
-		.name = "ocd_array2mem",
+		.name = "array2mem",
 		.mode = COMMAND_EXEC,
 		.jim_handler = jim_array2mem,
 		.help = "convert a TCL array to memory locations "
diff --git a/tcl/board/at91cap7a-stk-sdram.cfg b/tcl/board/at91cap7a-stk-sdram.cfg
index 6a7e22b..cca1211 100644
--- a/tcl/board/at91cap7a-stk-sdram.cfg
+++ b/tcl/board/at91cap7a-stk-sdram.cfg
@@ -32,7 +32,7 @@ $_TARGETNAME configure -event reset-start {
 }
 
 proc peek32 {address} {
-	ocd_mem2array t 32 $address 1
+	mem2array t 32 $address 1
 	return $t(0)
 }
 
diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index b50e8c8..15a9caf 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -67,7 +67,7 @@ at91sam9 ce 0 0xfffff800 14
 
 proc read_register {register} {
         set result ""
-        ocd_mem2array result 32 $register 1
+        mem2array result 32 $register 1
         return $result(0)
 }
 
diff --git a/tcl/chip/atmel/at91/aic.tcl b/tcl/chip/atmel/at91/aic.tcl
index 8c276aa..366be6d 100644
--- a/tcl/chip/atmel/at91/aic.tcl
+++ b/tcl/chip/atmel/at91/aic.tcl
@@ -54,7 +54,7 @@ proc show_AIC_IMR_helper { NAME ADDR VAL } {
 
 proc show_AIC { } {
     global AIC_SMR
-    if [catch { ocd_mem2array aaa 32 $AIC_SMR [expr 32 * 4] } msg ] {
+    if [catch { mem2array aaa 32 $AIC_SMR [expr 32 * 4] } msg ] {
 	error [format "%s (%s)" $msg AIC_SMR]
     }
     puts "AIC_SMR: Mode & Type"
@@ -71,7 +71,7 @@ proc show_AIC { } {
 	incr x
     }
     global AIC_SVR
-    if [catch { ocd_mem2array aaa 32 $AIC_SVR [expr 32 * 4] } msg ] {
+    if [catch { mem2array aaa 32 $AIC_SVR [expr 32 * 4] } msg ] {
 	error [format "%s (%s)" $msg AIC_SVR]
     }
     puts "AIC_SVR: Vectors"
diff --git a/tcl/memory.tcl b/tcl/memory.tcl
index c4418fa..2719d3f 100644
--- a/tcl/memory.tcl
+++ b/tcl/memory.tcl
@@ -80,7 +80,7 @@ proc address_info { ADDRESS } {
 
 proc memread32 {ADDR} {
     set foo(0) 0
-    if ![ catch { ocd_mem2array foo 32 $ADDR 1  } msg ] {
+    if ![ catch { mem2array foo 32 $ADDR 1  } msg ] {
 	return $foo(0)
     } else {
 	error "memread32: $msg"
@@ -89,7 +89,7 @@ proc memread32 {ADDR} {
 
 proc memread16 {ADDR} {
     set foo(0) 0
-    if ![ catch { ocd_mem2array foo 16 $ADDR 1  } msg ] {
+    if ![ catch { mem2array foo 16 $ADDR 1  } msg ] {
 	return $foo(0)
     } else {
 	error "memread16: $msg"
@@ -98,7 +98,7 @@ proc memread16 {ADDR} {
 
 proc memread8 {ADDR} {
     set foo(0) 0
-    if ![ catch { ocd_mem2array foo 8 $ADDR 1  } msg ] {
+    if ![ catch { mem2array foo 8 $ADDR 1  } msg ] {
 	return $foo(0)
     } else {
 	error "memread8: $msg"
@@ -107,7 +107,7 @@ proc memread8 {ADDR} {
 
 proc memwrite32 {ADDR DATA} {
     set foo(0) $DATA
-    if ![ catch { ocd_array2mem foo 32 $ADDR 1  } msg ] {
+    if ![ catch { array2mem foo 32 $ADDR 1  } msg ] {
 	return $foo(0)
     } else {
 	error "memwrite32: $msg"
@@ -116,7 +116,7 @@ proc memwrite32 {ADDR DATA} {
 
 proc memwrite16 {ADDR DATA} {
     set foo(0) $DATA
-    if ![ catch { ocd_array2mem foo 16 $ADDR 1  } msg ] {
+    if ![ catch { array2mem foo 16 $ADDR 1  } msg ] {
 	return $foo(0)
     } else {
 	error "memwrite16: $msg"
@@ -125,7 +125,7 @@ proc memwrite16 {ADDR DATA} {
 
 proc memwrite8 {ADDR DATA} {
     set foo(0) $DATA
-    if ![ catch { ocd_array2mem foo 8 $ADDR 1  } msg ] {
+    if ![ catch { array2mem foo 8 $ADDR 1  } msg ] {
 	return $foo(0)
     } else {
 	error "memwrite8: $msg"
diff --git a/tcl/target/c100helper.tcl b/tcl/target/c100helper.tcl
index 2a12c36..45adc62 100644
--- a/tcl/target/c100helper.tcl
+++ b/tcl/target/c100helper.tcl
@@ -29,14 +29,14 @@ proc helpC100 {} {
 # mrw: "memory read word", returns value of $reg
 proc mrw {reg} {
     set value ""
-    ocd_mem2array value 32 $reg 1
+    mem2array value 32 $reg 1
     return $value(0)
 }
 
 # read a 64-bit register (memory mapped)
 proc mr64bit {reg} {
     set value ""
-    ocd_mem2array value 32 $reg 2
+    mem2array value 32 $reg 2
     return $value
 }
 
@@ -131,7 +131,7 @@ proc showAmbaClk {} {
     set PLL_CLK_BYPASS	             [regs PLL_CLK_BYPASS]
 
     puts [format "CLKCORE_AHB_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_AHB_CLK_CNTRL [mrw $CLKCORE_AHB_CLK_CNTRL]]
-    ocd_mem2array value 32 $CLKCORE_AHB_CLK_CNTRL 1
+    mem2array value 32 $CLKCORE_AHB_CLK_CNTRL 1
     # see if the PLL is in bypass mode
     set bypass [expr ($value(0) & $PLL_CLK_BYPASS) >> 24 ]
     puts [format "PLL bypass bit: %d" $bypass]
@@ -206,7 +206,7 @@ proc showArmClk {} {
     set PLL_CLK_BYPASS	        [regs PLL_CLK_BYPASS]
 
     puts [format "CLKCORE_ARM_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_ARM_CLK_CNTRL [mrw $CLKCORE_ARM_CLK_CNTRL]]
-    ocd_mem2array value 32 $CLKCORE_ARM_CLK_CNTRL 1
+    mem2array value 32 $CLKCORE_ARM_CLK_CNTRL 1
     # see if the PLL is in bypass mode
     set bypass [expr ($value(0) & $PLL_CLK_BYPASS) >> 24 ]
     puts [format "PLL bypass bit: %d" $bypass]
diff --git a/tcl/target/davinci.cfg b/tcl/target/davinci.cfg
index 31750dd..6c6769f 100644
--- a/tcl/target/davinci.cfg
+++ b/tcl/target/davinci.cfg
@@ -10,7 +10,7 @@ proc davinci_pinmux {soc reg value} {
 # mrw: "memory read word", returns value of $reg
 proc mrw {reg} {
 	set value ""
-	ocd_mem2array value 32 $reg 1
+	mem2array value 32 $reg 1
 	return $value(0)
 }
 
diff --git a/testing/examples/cortex/cm3-ftest.cfg b/testing/examples/cortex/cm3-ftest.cfg
index 2c7809d..3793703 100644
--- a/testing/examples/cortex/cm3-ftest.cfg
+++ b/testing/examples/cortex/cm3-ftest.cfg
@@ -50,7 +50,7 @@ proc load_and_run { name halfwords n_instr } {
 	echo "# code to trigger $name vector"
 	set addr 0x20000000
 
-	# ocd_array2mem should be faster, though we'd need to
+	# array2mem should be faster, though we'd need to
 	# compute the resulting $addr ourselves
 	foreach opcode $halfwords {
 		mwh $addr $opcode

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi                      |    4 ++--
 src/target/target.c                   |    4 ++--
 tcl/board/at91cap7a-stk-sdram.cfg     |    2 +-
 tcl/board/at91sam9g20-ek.cfg          |    2 +-
 tcl/chip/atmel/at91/aic.tcl           |    4 ++--
 tcl/memory.tcl                        |   12 ++++++------
 tcl/target/c100helper.tcl             |    8 ++++----
 tcl/target/davinci.cfg                |    2 +-
 testing/examples/cortex/cm3-ftest.cfg |    2 +-
 9 files changed, 20 insertions(+), 20 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 12 08:55:07 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 12 Aug 2010 06:55:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-475-ga8c8c23
Message-ID: <E1OjRh5-0008Id-Bk@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a8c8c238f2dd1abe102f83bfa392ac40f313dd73 (commit)
      from  8f779cf66bf459616b7dad88e871c2f4a7315371 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a8c8c238f2dd1abe102f83bfa392ac40f313dd73
Author: Fredrik Hederstierna <fredrik.hederstierna at securitas-direct.com>
Date:   Thu Aug 12 08:53:29 2010 +0200

    str9x: faster flash erase of entire chip
    
    The patch improves flash erase for STR9x in case of a full bank erase.
    Then the chip erase command is used instead which improves speed significantly.
    
    Also I think it might help if e.g. STR912 enters some state where flash banks are locked, and a chip erase command is the key for unlocking the flash.

diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 528e52e..cfe6a77 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -223,6 +223,7 @@ static int str9x_erase(struct flash_bank *bank, int first, int last)
 	uint32_t adr;
 	uint8_t status;
 	uint8_t erase_cmd;
+	int total_timeout;
 
 	if (bank->target->state != TARGET_HALTED)
 	{
@@ -230,16 +231,27 @@ static int str9x_erase(struct flash_bank *bank, int first, int last)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	/*A slower but stable way of erasing*/
-	/* Erase sector command */
-	erase_cmd = 0x20;
+	/* Check if we can erase whole bank */
+	if ((first == 0) && (last == (bank->num_sectors - 1)))
+	{
+		/* Optimize to run erase bank command instead of sector */
+		erase_cmd = 0x80;
+                /* Add timeout duration since erase bank takes more time */
+		total_timeout = 1000 * bank->num_sectors;
+	}
+	else
+	{
+		/* Erase sector command */
+		erase_cmd = 0x20;
+		total_timeout = 1000;
+	}
 
 	for (i = first; i <= last; i++)
 	{
 		int retval;
 		adr = bank->base + bank->sectors[i].offset;
 
-		/* erase sectors */
+		/* erase sectors or block */
 		if ((retval = target_write_u16(target, adr, erase_cmd)) != ERROR_OK)
 		{
 			return retval;
@@ -256,7 +268,8 @@ static int str9x_erase(struct flash_bank *bank, int first, int last)
 		}
 
 		int timeout;
-		for (timeout = 0; timeout < 1000; timeout++) {
+		for (timeout = 0; timeout < total_timeout; timeout++) 
+		{
 			if ((retval = target_read_u8(target, adr, &status)) != ERROR_OK)
 			{
 				return retval;
@@ -265,7 +278,7 @@ static int str9x_erase(struct flash_bank *bank, int first, int last)
 				break;
 			alive_sleep(1);
 		}
-		if (timeout == 1000)
+		if (timeout == total_timeout)
 		{
 			LOG_ERROR("erase timed out");
 			return ERROR_FAIL;
@@ -288,6 +301,10 @@ static int str9x_erase(struct flash_bank *bank, int first, int last)
 			LOG_ERROR("error erasing flash bank, status: 0x%x", status);
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
+
+		/* If we ran erase bank command, we are finished */
+		if (erase_cmd == 0x80)
+			break;
 	}
 
 	for (i = first; i <= last; i++)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9x.c |   29 +++++++++++++++++++++++------
 1 files changed, 23 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 12 09:00:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 12 Aug 2010 07:00:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-479-g07e0bd4
Message-ID: <E1OjRmG-0000CZ-Ln@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  07e0bd46859439426084e2612d3fe1c3281564a9 (commit)
       via  14a25cd6de1fa7d72bae466375cdef3081f7f339 (commit)
       via  4ed89e4e42e1f2f62fdf6d0c660b2ea64479d136 (commit)
       via  98d2579c61aea1cfc4c1e4bd391b9acf1b1ff5db (commit)
      from  a8c8c238f2dd1abe102f83bfa392ac40f313dd73 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 07e0bd46859439426084e2612d3fe1c3281564a9
Author: Thomas Koeller <thomas.koeller at baslerweb.com>
Date:   Tue Aug 10 14:56:45 2010 +0200

    jtag: fix handling of 'tap enable' error
    
    if a tap could not be _enabled_, the error message was
    'failed to disable tap'. Fixed that. Also, display the failing
    tap's name.
    
    Signed-off-by: Thomas Koeller <thomas.koeller at baslerweb.com>

diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 69045c6..4df3ccb 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -768,10 +768,10 @@ static int jim_jtag_tap_enabler(Jim_Interp *interp, int argc, Jim_Obj *const *ar
 		// do nothing, just return the value
 	} else if (strcasecmp(cmd_name, "tapenable") == 0) {
 		if (!jtag_tap_enable(t))
-			LOG_WARNING("failed to disable tap");
+			LOG_WARNING("failed to enable tap %s", t->dotted_name);
 	} else if (strcasecmp(cmd_name, "tapdisable") == 0) {
 		if (!jtag_tap_disable(t))
-			LOG_WARNING("failed to disable tap");
+			LOG_WARNING("failed to disable tap %s", t->dotted_name);
 	} else {
 		LOG_ERROR("command '%s' unknown", cmd_name);
 		return JIM_ERR;

commit 14a25cd6de1fa7d72bae466375cdef3081f7f339
Author: Thomas Koeller <thomas.koeller at baslerweb.com>
Date:   Tue Aug 10 14:56:44 2010 +0200

    DM36x: Set OSCDIV divider
    
    The ability to set up the OSCDIV divider was missing.
    
    Signed-off-by: Thomas Koeller <thomas.koeller at baslerweb.com>

diff --git a/tcl/target/davinci.cfg b/tcl/target/davinci.cfg
index 11ae093..6e9091e 100644
--- a/tcl/target/davinci.cfg
+++ b/tcl/target/davinci.cfg
@@ -222,6 +222,13 @@ proc pll_v03_setup {pll_addr mult config} {
 	} else {
 		mww [expr $pll_addr + 0x0120] 0
 	}
+	if { [dict exists $config oscdiv] } {
+		set div [dict get $config oscdiv]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0124] $div
+	} else {
+		mww [expr $pll_addr + 0x0124] 0
+	}
 	if { [dict exists $config div4] } {
 		set div [dict get $config div4]
 		set div [expr 0x8000 | ($div - 1)]

commit 4ed89e4e42e1f2f62fdf6d0c660b2ea64479d136
Author: Thomas Koeller <thomas.koeller at baslerweb.com>
Date:   Tue Aug 10 14:56:43 2010 +0200

    DM36x: Disable unused SYSCLKs
    
    Clear the enable bits for all clocks that are not set explicitly.
    This is done to increase robustness by removing pre-existing
    state.
    
    Signed-off-by: Thomas Koeller <thomas.koeller at baslerweb.com>

diff --git a/tcl/target/davinci.cfg b/tcl/target/davinci.cfg
index b736c6e..11ae093 100644
--- a/tcl/target/davinci.cfg
+++ b/tcl/target/davinci.cfg
@@ -197,63 +197,82 @@ proc pll_v03_setup {pll_addr mult config} {
 	# 11 - optional:  set plldiv1, plldiv2, ...
 	# NOTE:  this assumes some registers have their just-reset values:
 	#	- PLLSTAT.GOSTAT is clear when we enter
-	#	- ALNCTL has everything set
 	set aln 0
 	if { [dict exists $config div1] } {
 		set div [dict get $config div1]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0118] $div
 		set aln [expr $aln | 0x1]
+	} else {
+		mww [expr $pll_addr + 0x0118] 0
 	}
 	if { [dict exists $config div2] } {
 		set div [dict get $config div2]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x011c] $div
 		set aln [expr $aln | 0x2]
+	} else {
+		mww [expr $pll_addr + 0x011c] 0
 	}
 	if { [dict exists $config div3] } {
 		set div [dict get $config div3]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0120] $div
 		set aln [expr $aln | 0x4]
+	} else {
+		mww [expr $pll_addr + 0x0120] 0
 	}
 	if { [dict exists $config div4] } {
 		set div [dict get $config div4]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0160] $div
 		set aln [expr $aln | 0x8]
+	} else {
+		mww [expr $pll_addr + 0x0160] 0
 	}
 	if { [dict exists $config div5] } {
 		set div [dict get $config div5]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0164] $div
 		set aln [expr $aln | 0x10]
+	} else {
+		mww [expr $pll_addr + 0x0164] 0
 	}
 	if { [dict exists $config div6] } {
 		set div [dict get $config div6]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0168] $div
 		set aln [expr $aln | 0x20]
+	} else {
+		mww [expr $pll_addr + 0x0168] 0
 	}
 	if { [dict exists $config div7] } {
 		set div [dict get $config div7]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x016c] $div
 		set aln [expr $aln | 0x40]
+	} else {
+		mww [expr $pll_addr + 0x016c] 0
 	}
 	if { [dict exists $config div8] } {
 		set div [dict get $config div8]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0170] $div
 		set aln [expr $aln | 0x80]
+	} else {
+		mww [expr $pll_addr + 0x0170] 0
 	}
 	if { [dict exists $config div9] } {
 		set div [dict get $config div9]
 		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0174] $div
 		set aln [expr $aln | 0x100]
+	} else {
+		mww [expr $pll_addr + 0x0174] 0
 	}
 	if {$aln != 0} {
+		# clear pllcmd.GO
+		mww [expr $pll_addr + 0x0138] 0x00
 		# write alingment flags
 		mww [expr $pll_addr + 0x0140] $aln
 		# write pllcmd.GO; poll pllstat.GO

commit 98d2579c61aea1cfc4c1e4bd391b9acf1b1ff5db
Author: Thomas Koeller <thomas.koeller at baslerweb.com>
Date:   Tue Aug 10 14:56:42 2010 +0200

    DM36x: Use enable bit for PLL pre-divider
    
    The PLL pre- and postdividers seem to have enable bits, although
    these are not mentioned in the chip documentation.
    
    Signed-off-by: Thomas Koeller <thomas.koeller at baslerweb.com>

diff --git a/tcl/target/davinci.cfg b/tcl/target/davinci.cfg
index 6c6769f..b736c6e 100644
--- a/tcl/target/davinci.cfg
+++ b/tcl/target/davinci.cfg
@@ -179,7 +179,7 @@ proc pll_v03_setup {pll_addr mult config} {
 	mww [expr $pll_addr + 0x0110] [expr ($mult / 2) & 0x1ff]
 	if { [dict exists $config prediv] } {
 		set div [dict get $config prediv]
-		set div [expr ($div - 1)]
+		set div [expr 0x8000 | ($div - 1)]
 		mww [expr $pll_addr + 0x0114] $div
 	}
 	if { [dict exists $config postdiv] } {

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/tcl.c         |    4 ++--
 tcl/target/davinci.cfg |   30 ++++++++++++++++++++++++++++--
 2 files changed, 30 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 12 15:02:24 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 12 Aug 2010 13:02:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-480-ga72faf6
Message-ID: <E1OjXQX-0002ro-7I@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a72faf6405234d2b46e293edfffc7a00d21c7fc8 (commit)
      from  07e0bd46859439426084e2612d3fe1c3281564a9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a72faf6405234d2b46e293edfffc7a00d21c7fc8
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Aug 12 15:01:23 2010 +0200

    at91cap7a-stk-sdram.cfg: faster reset
    
    crank up JTAG speed as soon as clocks are set up.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/at91cap7a-stk-sdram.cfg b/tcl/board/at91cap7a-stk-sdram.cfg
index cca1211..72d9e01 100644
--- a/tcl/board/at91cap7a-stk-sdram.cfg
+++ b/tcl/board/at91cap7a-stk-sdram.cfg
@@ -28,7 +28,7 @@ target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAM
 
 $_TARGETNAME configure -event reset-start {
 	# start off real slow when we're running off internal RC oscillator
-	jtag_khz 10
+	jtag_khz 32
 }
 
 proc peek32 {address} {
@@ -76,6 +76,10 @@ $_TARGETNAME configure -event reset-init {
 	wait_state {expr {([peek32 0xFFFFFC68] & 0x8) == 0}}  
 
 	echo "Master clock ok."
+	
+	# Now that we're up and running, crank up speed!
+	global post_reset_khz ;	jtag_khz $post_reset_khz
+	
 	echo "Configuring the SDRAM controller..."
 
 	# Configure EBI Chip select for SDRAM
@@ -149,10 +153,6 @@ $_TARGETNAME configure -event reset-init {
 	mww 0xffffef00 0x3
 	
 	echo "SDRAM configuration ok."
-
-	# Now that we're up and running, crank up speed!
-	global post_reset_khz
-	jtag_khz $post_reset_khz
 }
 
 $_TARGETNAME configure -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/at91cap7a-stk-sdram.cfg |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Aug 13 09:54:22 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 13 Aug 2010 07:54:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-483-gdce4225
Message-ID: <E1Ojp5x-0006ie-5e@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  dce422516ab1e28bb8045c9c081c73562dd1f163 (commit)
       via  52ba344a0988088f97c7aa0dc541da022ce960f4 (commit)
       via  c3ee26d2726c869db3c993dc7b6e6223de624d74 (commit)
      from  a72faf6405234d2b46e293edfffc7a00d21c7fc8 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dce422516ab1e28bb8045c9c081c73562dd1f163
Author: Piotr Esden-Tempski <piotr at esden.net>
Date:   Tue Aug 3 22:04:46 2010 -0700

    Added support for the Lisa/L jtag LEDs.

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index ecfa17f..7440f0c 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -188,6 +188,7 @@ static int signalyzer_init(void);
 static int signalyzer_h_init(void);
 static int ktlink_init(void);
 static int redbee_init(void);
+static int lisa_l_init(void);
 
 /* reset procedures for supported layouts */
 static void ftx23_reset(int trst, int srst);
@@ -210,6 +211,7 @@ static void flyswatter_jtag_blink(void);
 static void turtle_jtag_blink(void);
 static void signalyzer_h_blink(void);
 static void ktlink_blink(void);
+static void lisa_l_blink(void);
 
 /* common transport support options */
 
@@ -304,8 +306,9 @@ static const struct ft2232_layout  ft2232_layouts[] =
     	        .channel = INTERFACE_B,
 	},
 	{ .name = "lisa-l",
-		.init = usbjtag_init,
+		.init = lisa_l_init,
 		.reset = ftx23_reset,
+		.blink = lisa_l_blink,
 		.channel = INTERFACE_B,
 	},
 	{ .name = NULL, /* END OF TABLE */ },
@@ -3098,6 +3101,39 @@ static int cortino_jtag_init(void)
 	return ERROR_OK;
 }
 
+static int lisa_l_init(void)
+{
+	uint8_t  buf[3];
+	uint32_t bytes_written;
+
+	/*
+	 * NOTE:  This is now _specific_ to the "usbjtag" layout.
+	 * Don't try cram any more layouts into this.
+	 */
+	ftx232_dbus_init();
+
+	nTRST    = 0x10;
+	nTRSTnOE = 0x10;
+	nSRST    = 0x40;
+	nSRSTnOE = 0x40;
+
+	high_output = 0x00;
+	high_direction = 0x18;
+
+	/* initialize high port */
+	buf[0] = 0x82; /* command "set data bits high byte" */
+	buf[1] = high_output;
+	buf[2] = high_direction;
+	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
+
+	if (ft2232_write(buf, sizeof(buf), &bytes_written) != ERROR_OK)
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'lisa_l' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	return ftx232_dbus_write();
+}
 static void olimex_jtag_blink(void)
 {
 	/* Olimex ARM-USB-OCD has a LED connected to ACBUS3
@@ -3150,6 +3186,25 @@ static void turtle_jtag_blink(void)
 	buffer_write(high_direction);
 }
 
+static void lisa_l_blink(void)
+{
+	/*
+	 * Lisa/L has two LEDs connected to BCBUS3 and ACBUS4
+	 */
+	if (high_output & 0x10)
+	{
+		high_output = 0x08;
+	}
+	else
+	{
+		high_output = 0x10;
+	}
+
+	buffer_write(0x82);
+	buffer_write(high_output);
+	buffer_write(high_direction);
+}
+
 static int ft2232_quit(void)
 {
 #if BUILD_FT2232_FTD2XX == 1

commit 52ba344a0988088f97c7aa0dc541da022ce960f4
Author: Piotr Esden-Tempski <piotr at esden.net>
Date:   Tue Aug 3 21:00:09 2010 -0700

    Added Lisa/L script as a target board.

diff --git a/tcl/board/lisa-l.cfg b/tcl/board/lisa-l.cfg
new file mode 100644
index 0000000..00afa5e
--- /dev/null
+++ b/tcl/board/lisa-l.cfg
@@ -0,0 +1,7 @@
+# the Lost Illusions Serendipitous Autopilot
+# http://paparazzi.enac.fr/wiki/Lisa
+
+# Work-area size (RAM size) = 20kB for STM32F103RB device
+set WORKAREASIZE 0x5000
+
+source [find target/stm32.cfg]

commit c3ee26d2726c869db3c993dc7b6e6223de624d74
Author: Piotr Esden-Tempski <piotr at esden.net>
Date:   Tue Aug 3 20:58:29 2010 -0700

    Added support for Lisa/L builtin JTAG interface.

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 1a0eb4b..ecfa17f 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -303,6 +303,11 @@ static const struct ft2232_layout  ft2232_layouts[] =
 	        .reset = redbee_reset,
     	        .channel = INTERFACE_B,
 	},
+	{ .name = "lisa-l",
+		.init = usbjtag_init,
+		.reset = ftx23_reset,
+		.channel = INTERFACE_B,
+	},
 	{ .name = NULL, /* END OF TABLE */ },
 };
 
diff --git a/tcl/interface/lisa-l.cfg b/tcl/interface/lisa-l.cfg
new file mode 100644
index 0000000..cc7d6cc
--- /dev/null
+++ b/tcl/interface/lisa-l.cfg
@@ -0,0 +1,11 @@
+#
+# Lisa/L
+#
+# http://paparazzi.enac.fr/wiki/Lisa
+#
+
+interface ft2232
+ft2232_vid_pid 0x0403 0x6010
+ft2232_device_desc "Lisa/L"
+ft2232_layout "lisa-l"
+ft2232_latency 2

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/ft2232.c               |   60 +++++++++++++++++++++++++++++++
 tcl/board/{open-bldc.cfg => lisa-l.cfg} |    4 +-
 tcl/interface/lisa-l.cfg                |   11 ++++++
 3 files changed, 73 insertions(+), 2 deletions(-)
 copy tcl/board/{open-bldc.cfg => lisa-l.cfg} (58%)
 create mode 100644 tcl/interface/lisa-l.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Aug 13 13:00:46 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 13 Aug 2010 11:00:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-484-gf60a239
Message-ID: <E1Ojs0U-0000w1-H0@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f60a2390cc5abe3d01633d9793ac1791fd0a3a5d (commit)
      from  dce422516ab1e28bb8045c9c081c73562dd1f163 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f60a2390cc5abe3d01633d9793ac1791fd0a3a5d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Aug 13 12:59:36 2010 +0200

    lpc1768: turn down the jtag clock
    
    Tests should that it needs to be as low as 100kHz to be
    stable.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index ff92e4a..07c5ab8 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -47,16 +47,18 @@ set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x80000 0 0 $_TARGETNAME \
 	lpc1700 $_CCLK calc_checksum
 
-# JTAG clock should be CCLK/6 (unless using adaptive clocking)
-# CCLK is 4 MHz after reset, and until board-specific code (like
-# a reset-init handler) speeds it up.
-#
 # Although rclk "appears to work", it turns out that this yields
 # 4MHz whereas the "correct" rate is CCLK/6, which is not what
 # you get with rclk.
-jtag_khz [ expr 4000 / 6 ]
-
-
+#
+# Also, crank down the frequency further as we're running of an
+# RC oscillator instead of crystal.
+#
+# Setting up XTAL in the reset-init sequence could be worth 
+# the effort if you need to program the flash which is pretty
+# big on these devices.
+#
+jtag_khz 100
 
 $_TARGETNAME configure -event reset-init {
 	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc1768.cfg |   16 +++++++++-------
 1 files changed, 9 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Aug 13 23:35:39 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 13 Aug 2010 21:35:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-485-g36333f9
Message-ID: <E1Ok1uf-000516-T1@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  36333f9ca8eec7a83427116d9638065f3f02d08f (commit)
      from  f60a2390cc5abe3d01633d9793ac1791fd0a3a5d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 36333f9ca8eec7a83427116d9638065f3f02d08f
Author: Catalin Patulea <cat at vv.carleton.ca>
Date:   Fri Aug 13 16:57:37 2010 -0400

    Fix typo in documentation of usb_blaster_vid_pid command

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 3cf5bfe..cbb9c14 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2259,11 +2259,11 @@ default values are used.
 Currently, only one @var{vid}, @var{pid} pair may be given, e.g. for
 Altera USB-Blaster (default):
 @example
-ft2232_vid_pid 0x09FB 0x6001
+usb_blaster_vid_pid 0x09FB 0x6001
 @end example
 The following VID/PID is for Kolja Waschk's USB JTAG:
 @example
-ft2232_vid_pid 0x16C0 0x06AD
+usb_blaster_vid_pid 0x16C0 0x06AD
 @end example
 @end deffn
 

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Aug 14 08:00:54 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 14 Aug 2010 06:00:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-486-gbb88f3f
Message-ID: <E1Ok9nd-0000W4-NU@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bb88f3f470b7e3805636983c533756e84806bd2f (commit)
      from  36333f9ca8eec7a83427116d9638065f3f02d08f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bb88f3f470b7e3805636983c533756e84806bd2f
Author: Catalin Patulea <cat at vv.carleton.ca>
Date:   Fri Aug 13 18:41:18 2010 -0400

    Fix typo in usb_blaster_vid_pid error message

diff --git a/src/jtag/drivers/usb_blaster.c b/src/jtag/drivers/usb_blaster.c
index 59c5715..1679040 100644
--- a/src/jtag/drivers/usb_blaster.c
+++ b/src/jtag/drivers/usb_blaster.c
@@ -492,7 +492,7 @@ COMMAND_HANDLER(usb_blaster_handle_vid_pid_command)
 {
 	if (CMD_ARGC > 2)
 	{
-		LOG_WARNING("ignoring extra IDs in ft2232_vid_pid "
+		LOG_WARNING("ignoring extra IDs in usb_blaster_vid_pid "
 					"(maximum is 1 pair)");
 		CMD_ARGC = 2;
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/usb_blaster.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun Aug 15 21:59:27 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 15 Aug 2010 19:59:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-489-gc54c323
Message-ID: <E1OkjMl-0002wP-5z@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c54c323cf3b6b26c9d27d8bc4237daca4ba18e66 (commit)
       via  d23428a47f28e6028bc8608540cfbc7da2723a18 (commit)
       via  c3d51bf0da7333de303adf86011913a4bca96e4d (commit)
      from  bb88f3f470b7e3805636983c533756e84806bd2f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c54c323cf3b6b26c9d27d8bc4237daca4ba18e66
Author: Oleksandr Tymoshenko <gonzo at bluezbox.com>
Date:   Sun Aug 15 21:55:17 2010 +0200

    avr32: basic target script

diff --git a/tcl/target/avr32.cfg b/tcl/target/avr32.cfg
new file mode 100644
index 0000000..7fe98b2
--- /dev/null
+++ b/tcl/target/avr32.cfg
@@ -0,0 +1,18 @@
+set  _CHIPNAME avr32
+set  _ENDIAN big
+
+# force an error till we get a good number
+set _CPUTAPID  0x21e8203f
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+reset_config trst_and_srst separate
+
+# jtag scan chain
+# format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
+jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1 -expected-id $_CPUTAPID
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME avr32_ap7k -endian $_ENDIAN -chain-position $_TARGETNAME
+

commit d23428a47f28e6028bc8608540cfbc7da2723a18
Author: David Brownell <david-b at pacbell.net>
Date:   Sun Aug 15 21:54:01 2010 +0200

    at32ap7000 config file
    
    nice board to play with.

diff --git a/tcl/target/at32ap7000.cfg b/tcl/target/at32ap7000.cfg
new file mode 100644
index 0000000..8573aa1
--- /dev/null
+++ b/tcl/target/at32ap7000.cfg
@@ -0,0 +1,16 @@
+# Atmel AT32AP7000
+#
+# This is the only core in the now-inactive high end AVR32 product line,
+# with MMU, Java Acceleration, and "pixel coprocessor".  The AP7 line
+# is for "Application Processors" (AP) with 7-stage pipelines.
+#
+# Most current AVR32 parts are in the UC3 flash based microcontroller (UC)
+# product line with 3-stage pipelines and without those extras.
+#
+# All AVR32 parts provide the Nexus Class 3 on-chip debug interfaces
+# through their JTAG interfaces.
+
+jtag newtap ap7 nexus -irlen 5 -expected-id 0x21e8203f
+
+# REVISIT declare an avr32 target ... needs OpenOCD infrastructure
+# for both Nexus (generic) and AVR32 (Atmel-specific).

commit c3d51bf0da7333de303adf86011913a4bca96e4d
Author: Oleksandr Tymoshenko <gonzo at bluezbox.com>
Date:   Sun Aug 15 21:51:34 2010 +0200

    avr32: work-in-progress
    
    committed so as to ease cooperation and to let it be improved
    over time.
    
    So far it supports:
    - halt/resume
    - registers inspection
    - memory inspection/modification
    
    I'm still getting up to speed with OpenOCD internals and AVR32 so code is a little
    bit messy and I'd appreciate any feedback.

diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index ea6d88f..e01e077 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -32,6 +32,7 @@ libtarget_la_SOURCES = \
 	$(ARMV6_SRC) \
 	$(ARMV7_SRC) \
 	$(ARM_MISC_SRC) \
+	$(AVR32_SRC) \
 	$(MIPS32_SRC) \
 	avrt.c \
 	dsp563xx.c \
@@ -92,6 +93,12 @@ ARM_DEBUG_SRC = \
 	$(OOCD_TRACE_FILES) \
 	etm_dummy.c
 
+AVR32_SRC = \
+	avr32_ap7k.c \
+	avr32_jtag.c \
+	avr32_mem.c \
+	avr32_regs.c
+
 MIPS32_SRC = \
 	mips32.c \
 	mips_m4k.c \
diff --git a/src/target/avr32_ap7k.c b/src/target/avr32_ap7k.c
new file mode 100644
index 0000000..a5cdbe4
--- /dev/null
+++ b/src/target/avr32_ap7k.c
@@ -0,0 +1,684 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *   Based on mips_m4k code:                                               *
+ *       Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>       *
+ *       Copyright (C) 2008 by David T.L. Wong                             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jtag/jtag.h"
+#include "register.h"
+#include "algorithm.h"
+#include "target.h"
+#include "breakpoints.h"
+#include "target_type.h"
+#include "avr32_jtag.h"
+#include "avr32_mem.h"
+#include "avr32_regs.h"
+#include "avr32_ap7k.h"
+
+static char* avr32_core_reg_list[] =
+{
+	"r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", 
+	"r9", "r10", "r11", "r12", "sp", "lr", "pc", "sr"
+};
+
+static struct avr32_core_reg 
+	avr32_core_reg_list_arch_info[AVR32NUMCOREREGS] =
+{
+	{0, NULL, NULL},
+	{1, NULL, NULL},
+	{2, NULL, NULL},
+	{3, NULL, NULL},
+	{4, NULL, NULL},
+	{5, NULL, NULL},
+	{6, NULL, NULL},
+	{7, NULL, NULL},
+	{8, NULL, NULL},
+	{9, NULL, NULL},
+	{10, NULL, NULL},
+	{11, NULL, NULL},
+	{12, NULL, NULL},
+	{13, NULL, NULL},
+	{14, NULL, NULL},
+	{15, NULL, NULL},
+	{16, NULL, NULL},
+};
+
+
+static int avr32_read_core_reg(struct target *target, int num);
+static int avr32_write_core_reg(struct target *target, int num);
+
+int avr32_ap7k_save_context(struct target *target)
+{
+	int retval, i;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	retval = avr32_jtag_read_regs(&ap7k->jtag, ap7k->core_regs);
+	if (retval != ERROR_OK)
+		return retval;
+
+	for (i = 0; i < AVR32NUMCOREREGS; i++)
+	{
+		if (!ap7k->core_cache->reg_list[i].valid)
+		{
+			avr32_read_core_reg(target, i);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_ap7k_restore_context(struct target *target)
+{
+	int i;
+
+	/* get pointers to arch-specific information */
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	for (i = 0; i < AVR32NUMCOREREGS; i++)
+	{
+		if (ap7k->core_cache->reg_list[i].dirty)
+		{
+			avr32_write_core_reg(target, i);
+		}
+	}
+
+	/* write core regs */
+	avr32_jtag_write_regs(&ap7k->jtag, ap7k->core_regs);
+
+	return ERROR_OK;
+}
+
+static int avr32_read_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct avr32_core_reg *mips_core_reg;
+
+	/* get pointers to arch-specific information */
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	if ((num < 0) || (num >= AVR32NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+
+	mips_core_reg = ap7k->core_cache->reg_list[num].arch_info;
+	reg_value = ap7k->core_regs[num];
+	buf_set_u32(ap7k->core_cache->reg_list[num].value, 0, 32, reg_value);
+	ap7k->core_cache->reg_list[num].valid = 1;
+	ap7k->core_cache->reg_list[num].dirty = 0;
+
+	return ERROR_OK;
+}
+
+static int avr32_write_core_reg(struct target *target, int num)
+{
+	uint32_t reg_value;
+	struct avr32_core_reg *mips_core_reg;
+
+	/* get pointers to arch-specific information */
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	if ((num < 0) || (num >= AVR32NUMCOREREGS))
+		return ERROR_INVALID_ARGUMENTS;
+
+	reg_value = buf_get_u32(ap7k->core_cache->reg_list[num].value, 0, 32);
+	mips_core_reg = ap7k->core_cache->reg_list[num].arch_info;
+	ap7k->core_regs[num] = reg_value;
+	LOG_DEBUG("write core reg %i value 0x%" PRIx32 "", num , reg_value);
+	ap7k->core_cache->reg_list[num].valid = 1;
+	ap7k->core_cache->reg_list[num].dirty = 0;
+
+	return ERROR_OK;
+}
+
+static int avr32_get_core_reg(struct reg *reg)
+{
+	int retval;
+	struct avr32_core_reg *avr32_reg = reg->arch_info;
+	struct target *target = avr32_reg->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = avr32_read_core_reg(target, avr32_reg->num);
+
+	return retval;
+}
+
+static int avr32_set_core_reg(struct reg *reg, uint8_t *buf)
+{
+	struct avr32_core_reg *avr32_reg = reg->arch_info;
+	struct target *target = avr32_reg->target;
+	uint32_t value = buf_get_u32(buf, 0, 32);
+
+	if (target->state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	buf_set_u32(reg->value, 0, 32, value);
+	reg->dirty = 1;
+	reg->valid = 1;
+
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type avr32_reg_type = {
+	.get = avr32_get_core_reg,
+	.set = avr32_set_core_reg,
+};
+
+static struct reg_cache *avr32_build_reg_cache(struct target *target)
+{
+	int num_regs = AVR32NUMCOREREGS;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = malloc(sizeof(struct reg) * num_regs);
+	struct avr32_core_reg *arch_info = 
+		malloc(sizeof(struct avr32_core_reg) * num_regs);
+	int i;
+
+	/* Build the process context cache */
+	cache->name = "avr32 registers";
+	cache->next = NULL;
+	cache->reg_list = reg_list;
+	cache->num_regs = num_regs;
+	(*cache_p) = cache;
+	ap7k->core_cache = cache;
+
+	for (i = 0; i < num_regs; i++)
+	{
+		arch_info[i] = avr32_core_reg_list_arch_info[i];
+		arch_info[i].target = target;
+		arch_info[i].avr32_common = ap7k;
+		reg_list[i].name = avr32_core_reg_list[i];
+		reg_list[i].size = 32;
+		reg_list[i].value = calloc(1, 4);
+		reg_list[i].dirty = 0;
+		reg_list[i].valid = 0;
+		reg_list[i].type = &avr32_reg_type;
+		reg_list[i].arch_info = &arch_info[i];
+	}
+
+	return cache;
+}
+
+static int avr32_ap7k_debug_entry(struct target *target)
+{
+
+	uint32_t dpc, dinst;
+	int retval;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	retval = avr32_jtag_nexus_read(&ap7k->jtag, AVR32_OCDREG_DPC, &dpc);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_nexus_read(&ap7k->jtag, AVR32_OCDREG_DINST, &dinst);
+	if (retval != ERROR_OK)
+		return retval;
+
+	ap7k->jtag.dpc = dpc;
+
+	avr32_ap7k_save_context(target);
+
+	return ERROR_OK;
+}
+
+
+static int avr32_ap7k_poll(struct target *target)
+{
+	uint32_t ds;
+	int retval;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	retval = avr32_jtag_nexus_read(&ap7k->jtag, AVR32_OCDREG_DS, &ds);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* check for processor halted */
+	if (ds & OCDREG_DS_DBA)
+	{
+		if ((target->state == TARGET_RUNNING) || (target->state == TARGET_RESET))
+		{
+			target->state = TARGET_HALTED;
+
+			if ((retval = avr32_ap7k_debug_entry(target)) != ERROR_OK)
+				return retval;
+
+			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+		}
+		else if (target->state == TARGET_DEBUG_RUNNING)
+		{
+			target->state = TARGET_HALTED;
+
+			if ((retval = avr32_ap7k_debug_entry(target)) != ERROR_OK)
+				return retval;
+
+			target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
+		}
+	}
+	else
+	{
+		target->state = TARGET_RUNNING;
+	}
+
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_halt(struct target *target)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_DEBUG("target->state: %s",
+		  target_state_name(target));
+
+	if (target->state == TARGET_HALTED)
+	{
+		LOG_DEBUG("target was already halted");
+		return ERROR_OK;
+	}
+
+	if (target->state == TARGET_UNKNOWN)
+	{
+		LOG_WARNING("target was in unknown state when halt was requested");
+	}
+
+	if (target->state == TARGET_RESET)
+	{
+		if ((jtag_get_reset_config() & RESET_SRST_PULLS_TRST) && jtag_get_srst())
+		{
+			LOG_ERROR("can't request a halt while in reset if nSRST pulls nTRST");
+			return ERROR_TARGET_FAILURE;
+		}
+		else
+		{
+			target->debug_reason = DBG_REASON_DBGRQ;
+
+			return ERROR_OK;
+		}
+	}
+
+
+	avr32_ocd_setbits(&ap7k->jtag, AVR32_OCDREG_DC, OCDREG_DC_DBR);
+	target->debug_reason = DBG_REASON_DBGRQ;
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_assert_reset(struct target *target)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_deassert_reset(struct target *target)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_soft_reset_halt(struct target *target)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_resume(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+	struct breakpoint *breakpoint = NULL;
+	uint32_t resume_pc;
+	int retval;
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (!debug_execution)
+	{
+		target_free_all_working_areas(target);
+		/*
+		avr32_ap7k_enable_breakpoints(target);
+		avr32_ap7k_enable_watchpoints(target);
+		*/
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	if (!current)
+	{
+#if 0
+		if (retval != ERROR_OK)
+			return retval;
+#endif
+	}
+
+	resume_pc = 
+		buf_get_u32(ap7k->core_cache->reg_list[AVR32_REG_PC].value, 0, 32);
+	avr32_ap7k_restore_context(target);
+
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints)
+	{
+		/* Single step past breakpoint at current address */
+		if ((breakpoint = breakpoint_find(target, resume_pc)))
+		{
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+#if 0
+			avr32_ap7k_unset_breakpoint(target, breakpoint);
+			avr32_ap7k_single_step_core(target);
+			avr32_ap7k_set_breakpoint(target, breakpoint);
+#endif
+		}
+	}
+
+#if 0
+	/* enable interrupts if we are running */
+	avr32_ap7k_enable_interrupts(target, !debug_execution);
+
+	/* exit debug mode */
+	mips_ejtag_exit_debug(ejtag_info);
+#endif
+
+
+	retval = avr32_ocd_clearbits(&ap7k->jtag, AVR32_OCDREG_DC,
+			OCDREG_DC_DBR);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_exec(&ap7k->jtag, RETD);
+	if (retval != ERROR_OK)
+		return retval;
+
+	target->debug_reason = DBG_REASON_NOTHALTED;
+
+	/* registers are now invalid */
+	register_cache_invalidate(ap7k->core_cache);
+
+	if (!debug_execution)
+	{
+		target->state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG("target resumed at 0x%" PRIx32 "", resume_pc);
+	}
+	else
+	{
+		target->state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx32 "", resume_pc);
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_step(struct target *target, int current,
+		uint32_t address, int handle_breakpoints)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_remove_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_remove_watchpoint(struct target *target,
+		struct watchpoint *watchpoint)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_read_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, size, count);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* sanitize arguments */
+	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_INVALID_ARGUMENTS;
+
+	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	switch (size)
+	{
+	case 4:
+		return avr32_jtag_read_memory32(&ap7k->jtag, address, count, (uint32_t*)buffer);
+		break;
+	case 2:
+		return avr32_jtag_read_memory16(&ap7k->jtag, address, count, (uint16_t*)buffer);
+		break;
+	case 1:
+		return avr32_jtag_read_memory8(&ap7k->jtag, address, count, buffer);
+		break;
+	default:
+		break;
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_write_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_DEBUG("address: 0x%8.8" PRIx32 ", size: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, size, count);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* sanitize arguments */
+	if (((size != 4) && (size != 2) && (size != 1)) || (count == 0) || !(buffer))
+		return ERROR_INVALID_ARGUMENTS;
+
+	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+
+	switch (size)
+	{
+	case 4:
+		return avr32_jtag_write_memory32(&ap7k->jtag, address, count, (uint32_t*)buffer);
+		break;
+	case 2:
+		return avr32_jtag_write_memory16(&ap7k->jtag, address, count, (uint16_t*)buffer);
+		break;
+	case 1:
+		return avr32_jtag_write_memory8(&ap7k->jtag, address, count, buffer);
+		break;
+	default:
+		break;
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_init_target(struct command_context *cmd_ctx,
+		struct target *target)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	ap7k->jtag.tap = target->tap;
+	avr32_build_reg_cache(target);
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct avr32_ap7k_common *ap7k = calloc(1, sizeof(struct
+				avr32_ap7k_common));
+
+	ap7k->common_magic = AP7k_COMMON_MAGIC;
+	target->arch_info = ap7k;
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_examine(struct target *target)
+{
+	uint32_t devid, ds;
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	if (!target_was_examined(target))
+	{
+		target_set_examined(target);
+		avr32_jtag_nexus_read(&ap7k->jtag, AVR32_OCDREG_DID, &devid);
+		LOG_INFO("device id: %08x", devid);
+		avr32_ocd_setbits(&ap7k->jtag, AVR32_OCDREG_DC,OCDREG_DC_DBE);
+		avr32_jtag_nexus_read(&ap7k->jtag, AVR32_OCDREG_DS, &ds);
+
+		/* check for processor halted */
+		if (ds & OCDREG_DS_DBA) 
+		{
+			LOG_INFO("target is halted");
+			target->state = TARGET_HALTED;
+		}
+		else
+			target->state = TARGET_RUNNING;
+	}
+
+	return ERROR_OK;
+}
+
+static int avr32_ap7k_bulk_write_memory(struct target *target, uint32_t address,
+		uint32_t count, uint8_t *buffer)
+{
+	LOG_ERROR("%s: implement me", __func__);
+
+	return ERROR_OK;
+}
+
+
+int avr32_ap7k_arch_state(struct target *target)
+{
+	struct avr32_ap7k_common *ap7k = target_to_ap7k(target);
+
+	LOG_USER("target halted due to %s, pc: 0x%8.8" PRIx32 "",
+                debug_reason_name(target), ap7k->jtag.dpc);
+
+   	return ERROR_OK;
+}
+
+int avr32_ap7k_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int *reg_list_size)
+{
+#if 0
+        /* get pointers to arch-specific information */
+        int i;
+
+        /* include floating point registers */
+        *reg_list_size = AVR32NUMCOREREGS + AVR32NUMFPREGS;
+        *reg_list = malloc(sizeof(struct reg*) * (*reg_list_size));
+
+        for (i = 0; i < AVR32NUMCOREREGS; i++)
+        {
+                (*reg_list)[i] = &mips32->core_cache->reg_list[i];
+        }
+
+        /* add dummy floating points regs */
+        for (i = AVR32NUMCOREREGS; i < (AVR32NUMCOREREGS + AVR32NUMFPREGS); i++)
+        {
+                (*reg_list)[i] = &avr32_ap7k_gdb_dummy_fp_reg;
+        }
+#endif
+
+	LOG_ERROR("%s: implement me", __func__);
+	return ERROR_FAIL;
+}
+
+
+
+struct target_type avr32_ap7k_target =
+{
+	.name = "avr32_ap7k",
+
+	.poll = avr32_ap7k_poll,
+	.arch_state = avr32_ap7k_arch_state,
+
+	.target_request_data = NULL,
+
+	.halt = avr32_ap7k_halt,
+	.resume = avr32_ap7k_resume,
+	.step = avr32_ap7k_step,
+
+	.assert_reset = avr32_ap7k_assert_reset,
+	.deassert_reset = avr32_ap7k_deassert_reset,
+	.soft_reset_halt = avr32_ap7k_soft_reset_halt,
+
+	.get_gdb_reg_list = avr32_ap7k_get_gdb_reg_list,
+
+	.read_memory = avr32_ap7k_read_memory,
+	.write_memory = avr32_ap7k_write_memory,
+	.bulk_write_memory = avr32_ap7k_bulk_write_memory,
+	// .checksum_memory = avr32_ap7k_checksum_memory,
+	// .blank_check_memory = avr32_ap7k_blank_check_memory,
+
+	// .run_algorithm = avr32_ap7k_run_algorithm,
+
+	.add_breakpoint = avr32_ap7k_add_breakpoint,
+	.remove_breakpoint = avr32_ap7k_remove_breakpoint,
+	.add_watchpoint = avr32_ap7k_add_watchpoint,
+	.remove_watchpoint = avr32_ap7k_remove_watchpoint,
+
+	.target_create = avr32_ap7k_target_create,
+	.init_target = avr32_ap7k_init_target,
+	.examine = avr32_ap7k_examine,
+};
diff --git a/src/target/avr32_ap7k.h b/src/target/avr32_ap7k.h
new file mode 100644
index 0000000..d08254b
--- /dev/null
+++ b/src/target/avr32_ap7k.h
@@ -0,0 +1,49 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef AVR32_AP7K
+#define AVR32_AP7K
+
+#include <helper/types.h>
+
+struct target;
+
+#define AP7k_COMMON_MAGIC	0x4150374b
+struct avr32_ap7k_common
+{
+	int common_magic;
+	struct avr32_jtag jtag;
+	struct reg_cache *core_cache;
+	uint32_t core_regs[AVR32NUMCOREREGS];
+};
+
+static inline struct avr32_ap7k_common *
+target_to_ap7k(struct target *target)
+{
+	return (struct avr32_ap7k_common*)target->arch_info;
+}
+
+struct avr32_core_reg
+{
+	uint32_t num;
+	struct target *target;
+	struct avr32_ap7k_common *avr32_common;
+};
+
+#endif	/*AVR32_AP7K*/
diff --git a/src/target/avr32_jtag.c b/src/target/avr32_jtag.c
new file mode 100644
index 0000000..b6b5e37
--- /dev/null
+++ b/src/target/avr32_jtag.c
@@ -0,0 +1,392 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "target.h"
+#include "helper/types.h"
+#include "jtag/jtag.h"
+#include "avr32_jtag.h"
+
+static int avr32_jtag_set_instr(struct avr32_jtag *jtag_info, int new_instr)
+{
+	struct jtag_tap *tap;
+	int busy = 0;
+
+	tap = jtag_info->tap;
+	if (tap == NULL)
+		return ERROR_FAIL;
+
+	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != (uint32_t)new_instr)
+	{
+		do {
+			struct scan_field field;
+			uint8_t t[4];
+			uint8_t ret[4];
+
+			field.num_bits = tap->ir_length;
+			field.out_value = t;
+			buf_set_u32(t, 0, field.num_bits, new_instr);
+			field.in_value = ret;
+
+			jtag_add_ir_scan(tap, &field, TAP_IDLE);
+			if (jtag_execute_queue() != ERROR_OK)
+			{
+				LOG_ERROR("%s: setting address failed", __func__);
+				return ERROR_FAIL;
+			}
+			busy = buf_get_u32(ret, 2, 1);
+		} while (busy); /* check for busy bit */
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_nexus_set_address(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int mode)
+{
+	struct scan_field fields[2];
+	uint8_t addr_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	memset(fields, 0, sizeof(fields));
+
+	do {
+		memset(addr_buf, 0, sizeof(addr_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+
+		buf_set_u32(addr_buf, 0, 1, mode);
+		buf_set_u32(addr_buf, 1, 7, addr);
+
+		fields[0].num_bits = 26;
+		fields[0].in_value = NULL;
+		fields[0].out_value = NULL;
+
+		fields[1].num_bits = 8;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = addr_buf;
+
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR("%s: setting address failed", __func__);
+			return ERROR_FAIL;
+		}
+		busy = buf_get_u32(busy_buf, 6, 1);
+	} while(busy);
+
+	return ERROR_OK;
+}
+
+
+int avr32_jtag_nexus_read_data(struct avr32_jtag *jtag_info, 
+	uint32_t *pdata)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+
+		fields[0].num_bits = 32;
+		fields[0].out_value = NULL;
+		fields[0].in_value = data_buf;
+
+
+		fields[1].num_bits = 2;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = NULL;
+
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR("%s: reading data  failed", __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 1);
+	} while (busy);
+
+	*pdata = buf_get_u32(data_buf, 0, 32);
+
+	return ERROR_OK;
+}
+
+
+int avr32_jtag_nexus_write_data(struct avr32_jtag *jtag_info, 
+		uint32_t data)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	uint8_t dummy_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+		memset(dummy_buf, 0, sizeof(dummy_buf));
+
+		fields[0].num_bits = 2;
+		fields[0].in_value = busy_buf;
+		fields[0].out_value = dummy_buf;
+
+
+		buf_set_u32(data_buf, 0, 32, data);
+		fields[1].num_bits = 32;
+		fields[1].in_value = NULL;
+		fields[1].out_value = data_buf;
+
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR("%s: reading data  failed", __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 0);
+	} while (busy);
+
+
+	return ERROR_OK;
+}
+
+
+
+
+int avr32_jtag_nexus_read(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t *value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_NEXUS_ACCESS);
+	avr32_jtag_nexus_set_address(jtag_info, addr, MODE_READ);
+	avr32_jtag_nexus_read_data(jtag_info, value);
+
+	return ERROR_OK;
+
+}
+int avr32_jtag_nexus_write(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_NEXUS_ACCESS);
+	avr32_jtag_nexus_set_address(jtag_info, addr, MODE_WRITE);
+	avr32_jtag_nexus_write_data(jtag_info, value);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_set_address(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, int mode)
+{
+	struct scan_field fields[2];
+	uint8_t addr_buf[4];
+	uint8_t slave_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	memset(fields, 0, sizeof(fields));
+
+	do {
+		memset(addr_buf, 0, sizeof(addr_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+		memset(slave_buf, 0, sizeof(slave_buf));
+
+		buf_set_u32(slave_buf, 0, 4, slave);
+		buf_set_u32(addr_buf, 0, 1, mode);
+		buf_set_u32(addr_buf, 1, 30, addr >> 2);
+
+		fields[0].num_bits = 31;
+		fields[0].in_value = NULL;
+		fields[0].out_value = addr_buf;
+
+		fields[1].num_bits = 4;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = slave_buf;
+
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR("%s: setting address failed", __func__);
+			return ERROR_FAIL;
+		}
+		busy = buf_get_u32(busy_buf, 1, 1);
+	} while(busy);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_read_data(struct avr32_jtag *jtag_info, 
+	uint32_t *pdata)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+
+		fields[0].num_bits = 32;
+		fields[0].out_value = NULL;
+		fields[0].in_value = data_buf;
+
+
+		fields[1].num_bits = 3;
+		fields[1].in_value = busy_buf;
+		fields[1].out_value = NULL;
+
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR("%s: reading data  failed", __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 1);
+	} while (busy);
+
+	*pdata = buf_get_u32(data_buf, 0, 32);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_write_data(struct avr32_jtag *jtag_info, 
+	uint32_t data)
+{
+
+	struct scan_field fields[2];
+	uint8_t data_buf[4];
+	uint8_t busy_buf[4];
+	uint8_t zero_buf[4];
+	int busy;
+
+	do {
+		memset(data_buf, 0, sizeof(data_buf));
+		memset(busy_buf, 0, sizeof(busy_buf));
+		memset(zero_buf, 0, sizeof(zero_buf));
+
+		buf_set_u32(data_buf, 0, 32, data);
+		fields[0].num_bits = 3;
+		fields[0].in_value = busy_buf;
+		fields[0].out_value = zero_buf;
+
+		fields[1].num_bits = 32;
+		fields[1].out_value = data_buf;
+		fields[1].in_value = NULL;
+
+
+		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+
+		if (jtag_execute_queue() != ERROR_OK)
+		{
+			LOG_ERROR("%s: reading data  failed", __func__);
+			return ERROR_FAIL;
+		}
+
+		busy = buf_get_u32(busy_buf, 0, 1);
+	} while (busy);
+
+	return ERROR_OK;
+}
+
+
+
+int avr32_jtag_mwa_read(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t *value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_MW_ACCESS);
+	avr32_jtag_mwa_set_address(jtag_info, slave, addr, MODE_READ);
+	avr32_jtag_mwa_read_data(jtag_info, value);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_mwa_write(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t value)
+{
+	avr32_jtag_set_instr(jtag_info, AVR32_INST_MW_ACCESS);
+	avr32_jtag_mwa_set_address(jtag_info, slave, addr, MODE_WRITE);
+	avr32_jtag_mwa_write_data(jtag_info, value);
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_exec(struct avr32_jtag *jtag_info, uint32_t inst)
+{
+	int retval;
+	uint32_t ds;
+
+	retval = avr32_jtag_nexus_write(jtag_info, AVR32_OCDREG_DINST, inst);
+	if (retval != ERROR_OK)
+		return retval;
+
+	do {
+		retval = avr32_jtag_nexus_read(jtag_info, AVR32_OCDREG_DS, &ds);
+		if (retval != ERROR_OK)
+			return retval;
+	} while ((ds & OCDREG_DS_DBA) && !(ds & OCDREG_DS_INC));
+
+	return ERROR_OK;
+}
+
+int avr32_ocd_setbits(struct avr32_jtag *jtag, int reg, uint32_t bits)
+{
+	uint32_t value;
+	int res;
+
+	res = avr32_jtag_nexus_read(jtag, reg, &value);
+	if (res)
+		return res;
+
+	value |= bits;
+	res = avr32_jtag_nexus_write(jtag, reg, value);
+	if (res)
+		return res;
+
+	return ERROR_OK;
+}
+
+int avr32_ocd_clearbits(struct avr32_jtag *jtag, int reg, uint32_t bits)
+{
+	uint32_t value;
+	int res;
+
+	res = avr32_jtag_nexus_read(jtag, reg, &value);
+	if (res)
+		return res;
+
+	value &= ~bits;
+	res = avr32_jtag_nexus_write(jtag, reg, value);
+	if (res)
+		return res;
+
+	return ERROR_OK;
+}
+
diff --git a/src/target/avr32_jtag.h b/src/target/avr32_jtag.h
new file mode 100644
index 0000000..00f8330
--- /dev/null
+++ b/src/target/avr32_jtag.h
@@ -0,0 +1,107 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef AVR32_JTAG
+#define AVR32_JTAG
+
+#define	AVR32NUMCOREREGS	17
+
+/* tap instructions */
+#define AVR32_INST_IDCODE		0x01
+#define AVR32_INST_NEXUS_ACCESS	0x10
+#define AVR32_INST_MW_ACCESS	0x11
+#define AVR32_INST_MB_ACCESS	0x12
+
+#define	SLAVE_OCD				0x01
+#define	SLAVE_HSB_CACHED		0x04
+#define	SLAVE_HSB_UNCACHED		0x05
+
+/*
+ * Registers
+ */
+
+#define AVR32_OCDREG_DID		0x00
+#define AVR32_OCDREG_DC			0x02
+#define		OCDREG_DC_SS			(1 <<  8)
+#define		OCDREG_DC_DBR			(1 << 12)
+#define		OCDREG_DC_DBE			(1 << 13)
+#define		OCDREG_DC_SQA			(1 << 22)
+#define		OCDREG_DC_RES			(1 << 30)
+#define		OCDREG_DC_ABORT			(1 << 31)
+#define AVR32_OCDREG_DS			0x04
+#define		OCDREG_DS_SSS			(1 <<  0)
+#define		OCDREG_DS_SWB			(1 <<  1)
+#define		OCDREG_DS_HWB			(1 <<  2)
+#define		OCDREG_DS_STP			(1 <<  4)
+#define		OCDREG_DS_DBS			(1 <<  5)
+#define		OCDREG_DS_BP_SHIFT		8
+#define		OCDREG_DS_BP_MASK		0xff
+#define		OCDREG_DS_INC			(1 << 24)
+#define		OCDREG_DS_BOZ			(1 << 25)
+#define		OCDREG_DS_DBA			(1 << 26)
+#define		OCDREG_DS_EXB			(1 << 27)
+#define		OCDREG_DS_NTBF			(1 << 28)
+
+#define AVR32_OCDREG_DINST		0x41
+#define AVR32_OCDREG_DPC		0x42
+#define AVR32_OCDREG_DCCPU		0x44
+#define AVR32_OCDREG_DCEMU		0x45
+#define AVR32_OCDREG_DCSR		0x46
+#define		OCDREG_DCSR_CPUD		(1 <<  0)
+#define		OCDREG_DCSR_EMUD		(1 <<  1)
+
+/*
+ * Direction bit
+ */
+#define	MODE_WRITE				0x00
+#define	MODE_READ				0x01
+
+/*
+ * Some instructions
+ */
+
+#define	RETD					0xd703d623
+#define	MTDR(dreg, reg)			(0xe7b00044 | ((reg) << 16) | dreg)
+#define	MFDR(reg, dreg)			(0xe5b00044 | ((reg) << 16) | dreg)
+#define	MTSR(sysreg, reg)		(0xe3b00002 | ((reg) << 16) | sysreg)
+#define	MFSR(reg, sysreg)		(0xe1b00002 | ((reg) << 16) | sysreg)
+
+struct avr32_jtag
+{
+	struct jtag_tap *tap;
+	uint32_t dpc; /* Debug PC value */
+};
+
+int avr32_jtag_nexus_read(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t *value);
+int avr32_jtag_nexus_write(struct avr32_jtag *jtag_info,
+		uint32_t addr, uint32_t value);
+
+int avr32_jtag_mwa_read(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t *value);
+int avr32_jtag_mwa_write(struct avr32_jtag *jtag_info, int slave,
+		uint32_t addr, uint32_t value);
+
+
+int avr32_ocd_setbits(struct avr32_jtag *jtag, int reg, uint32_t bits);
+int avr32_ocd_clearbits(struct avr32_jtag *jtag, int reg, uint32_t bits);
+
+int avr32_jtag_exec(struct avr32_jtag *jtag_info, uint32_t inst);
+
+#endif /* AVR32_JTAG */
+
diff --git a/src/target/avr32_mem.c b/src/target/avr32_mem.c
new file mode 100644
index 0000000..0767c55
--- /dev/null
+++ b/src/target/avr32_mem.c
@@ -0,0 +1,333 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "target.h"
+#include "jtag/jtag.h"
+#include "avr32_jtag.h"
+#include "avr32_mem.h"
+
+int avr32_jtag_read_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+
+	for (i = 0; i < count; i++) 
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*4, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		buffer[i] = be_to_h_u32((uint8_t*)&data);
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_read_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+
+	i = 0;
+
+	/* any unaligned half-words? */
+	if (addr & 3)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		data = be_to_h_u32((uint8_t*)&data);
+		buffer[i] = (data >> 16) & 0xffff;
+		i++;
+	}
+
+	/* read all complete words */
+	for (; i < (count & ~1); i+=2)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		data = be_to_h_u32((uint8_t*)&data);
+		buffer[i] = data & 0xffff;
+		buffer[i+1] = (data >> 16) & 0xffff;
+	}
+
+	/* last halfword */
+	if (i < count)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* XXX: Assume AVR32 is BE */
+		data = be_to_h_u32((uint8_t*)&data);
+		buffer[i] = data & 0xffff;
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_read_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer)
+{
+	int i, j, retval;
+	uint8_t data[4];
+	i = 0;
+
+	/* Do we have non-aligned bytes? */
+	if (addr & 3)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, (uint32_t*)data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		for (j = addr & 3; (j < 4) && (i < count); j++, i++) 
+				buffer[i] = data[3-j];
+	}
+
+
+	/* read all complete words */
+	for (; i < (count & ~3); i+=4)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, (uint32_t*)data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		for (j = 0; j < 4; j++)
+				buffer[i+j] = data[3-j];
+	}
+
+	/* remaining bytes */
+	if (i < count)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, (uint32_t*)data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		for (j = 0; i + j < count; j++) 
+				buffer[i+j] = data[3-j];
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_write_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+
+	for (i = 0; i < count; i++) 
+	{
+		/* XXX: Assume AVR32 is BE */
+		h_u32_to_be((uint8_t*)&data, buffer[i]);
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*4, data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer)
+{
+	int i, retval;
+	uint32_t data;
+	uint32_t data_out;
+
+	i = 0;
+
+	/*
+	 * Do we have any non-aligned half-words?
+	 */
+	if (addr & 3) {
+		/* 
+		 * mwa_read will read whole world, no nead to fiddle
+		 * with address. It will be truncated in set_addr
+		 */
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&data);
+		data = (buffer[i] << 16) | (data & 0xffff);
+		h_u32_to_be((uint8_t*)&data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		i++;
+	}
+
+
+	/* write all complete words */
+	for (; i < (count & ~1); i+=2)
+	{
+		/* XXX: Assume AVR32 is BE */
+		data = (buffer[i+1] << 16) | buffer[i];
+		h_u32_to_be((uint8_t*)&data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/* last halfword */
+	if (i < count)
+	{
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&data);
+		data &= ~0xffff;
+		data |= buffer[i];
+		h_u32_to_be((uint8_t*)&data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i*2, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return ERROR_OK;
+}
+
+int avr32_jtag_write_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer)
+{
+	int i, j, retval;
+	uint32_t data;
+	uint32_t data_out;
+
+	i = 0;
+
+	/*
+	 * Do we have any non-aligned bytes?
+	 */
+	if (addr & 3) {
+		/* 
+		 * mwa_read will read whole world, no nead to fiddle
+		 * with address. It will be truncated in set_addr
+		 */
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&data);
+		for (j = addr & 3; (j < 4) && (i < count); j++, i++) 
+		{
+			data &= ~(0xff << j*8);
+			data |= (buffer[i] << j*8);
+		}
+
+		h_u32_to_be((uint8_t*)&data_out, data);
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+
+	/* write all complete words */
+	for (; i < (count & ~3); i+=4)
+	{
+		data = 0;
+
+		for (j = 0; j < 4; j++)
+			data |= (buffer[j+i] << j*8);
+
+		h_u32_to_be((uint8_t*)&data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/*
+	 * Write trailing bytes
+	 */
+	if (i < count) {
+		retval = avr32_jtag_mwa_read(jtag_info, SLAVE_HSB_UNCACHED,
+				addr + i, &data);
+
+		if (retval != ERROR_OK)
+			return retval;
+
+		data = be_to_h_u32((uint8_t*)&data);
+		for (j = 0; i < count; j++, i++)
+		{
+			data &= ~(0xff << j*8);
+			data |= (buffer[j+i] << j*8);
+		}
+
+		h_u32_to_be((uint8_t*)&data_out, data);
+
+		retval = avr32_jtag_mwa_write(jtag_info, SLAVE_HSB_UNCACHED,
+				addr+i, data_out);
+
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return ERROR_OK;
+}
diff --git a/src/target/avr32_mem.h b/src/target/avr32_mem.h
new file mode 100644
index 0000000..2a6f606
--- /dev/null
+++ b/src/target/avr32_mem.h
@@ -0,0 +1,37 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef AVR32_MEM
+#define AVR32_MEM
+
+int avr32_jtag_read_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer);
+int avr32_jtag_read_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer);
+int avr32_jtag_read_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer);
+
+int avr32_jtag_write_memory32(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint32_t *buffer);
+int avr32_jtag_write_memory16(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint16_t *buffer);
+int avr32_jtag_write_memory8(struct avr32_jtag *jtag_info, 
+		uint32_t addr, int count, uint8_t *buffer);
+
+#endif /* AVR32_MEM */
+
diff --git a/src/target/avr32_regs.c b/src/target/avr32_regs.c
new file mode 100644
index 0000000..eb283fc
--- /dev/null
+++ b/src/target/avr32_regs.c
@@ -0,0 +1,112 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "target.h"
+#include "jtag/jtag.h"
+#include "avr32_jtag.h"
+#include "avr32_regs.h"
+
+static int avr32_jtag_read_reg(struct avr32_jtag *jtag_info, int reg, 
+		uint32_t *val)
+{
+	int retval;
+	uint32_t dcsr;
+
+	retval = avr32_jtag_exec(jtag_info, MTDR(AVR32_OCDREG_DCCPU, reg));
+	if (retval != ERROR_OK)
+		return retval;
+
+	do {
+		retval = avr32_jtag_nexus_read(jtag_info, 
+			AVR32_OCDREG_DCSR, &dcsr);
+
+		if (retval != ERROR_OK)
+			return retval;
+	} while (!(dcsr & OCDREG_DCSR_CPUD));
+
+	retval = avr32_jtag_nexus_read(jtag_info, 
+			AVR32_OCDREG_DCCPU, val);
+
+	return retval;
+}
+
+static int avr32_jtag_write_reg(struct avr32_jtag *jtag_info, int reg, 
+		uint32_t val)
+{
+	int retval;
+	uint32_t dcsr;
+
+	/* Restore Status reg */
+	retval = avr32_jtag_nexus_write(jtag_info, 
+				AVR32_OCDREG_DCEMU, val);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_exec(jtag_info, MFDR(reg, AVR32_OCDREG_DCEMU));
+	if (retval != ERROR_OK)
+		return retval;
+	do {
+		retval = avr32_jtag_nexus_read(jtag_info, 
+			AVR32_OCDREG_DCSR, &dcsr);
+	} while (!(dcsr & OCDREG_DCSR_EMUD) && (retval == ERROR_OK));
+
+	return retval;
+}
+
+
+
+int avr32_jtag_read_regs(struct avr32_jtag *jtag_info, uint32_t *regs)
+{
+	int i, retval;
+
+	/* read core registers */
+	for (i = 0; i < AVR32NUMCOREREGS - 1; i++) 
+		avr32_jtag_read_reg(jtag_info, i, regs + i);
+
+	/* read status register */
+	retval = avr32_jtag_exec(jtag_info, MFSR(0, 0));
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = avr32_jtag_read_reg(jtag_info, 0, regs + AVR32_REG_SR);
+
+	return retval;
+}
+
+int avr32_jtag_write_regs(struct avr32_jtag *jtag_info, uint32_t *regs)
+{
+	int i, retval;
+
+	retval = avr32_jtag_write_reg(jtag_info, 0, regs[AVR32_REG_SR]);
+	/* Restore Status reg */
+	retval = avr32_jtag_exec(jtag_info, MTSR(0, 0));
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * And now the rest of registers
+	 */
+	for (i = 0; i < AVR32NUMCOREREGS - 1; i++) 
+		avr32_jtag_write_reg(jtag_info, i, regs[i]);
+
+	return ERROR_OK;
+}
diff --git a/src/target/avr32_regs.h b/src/target/avr32_regs.h
new file mode 100644
index 0000000..01ea3ed
--- /dev/null
+++ b/src/target/avr32_regs.h
@@ -0,0 +1,46 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Oleksandr Tymoshenko <gonzo at bluezbox.com>       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef AVR32_REGS
+#define AVR32_REGS
+
+enum avr32_reg_nums {
+	AVR32_REG_R0 = 0,
+	AVR32_REG_R1,
+	AVR32_REG_R2,
+	AVR32_REG_R3,
+	AVR32_REG_R4,
+	AVR32_REG_R5,
+	AVR32_REG_R6,
+	AVR32_REG_R7,
+	AVR32_REG_R8,
+	AVR32_REG_R9,
+	AVR32_REG_R10,
+	AVR32_REG_R11,
+	AVR32_REG_R12,
+	AVR32_REG_SP,
+	AVR32_REG_LR,
+	AVR32_REG_PC,
+	AVR32_REG_SR,
+};
+
+int avr32_jtag_read_regs(struct avr32_jtag *jtag_info, uint32_t *regs);
+int avr32_jtag_write_regs(struct avr32_jtag *jtag_info, uint32_t *regs);
+
+#endif /* AVR32_REGS */
+
diff --git a/src/target/target.c b/src/target/target.c
index 16caea5..c37432a 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -70,6 +70,7 @@ extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
 extern struct target_type dsp563xx_target;
 extern struct target_type testee_target;
+extern struct target_type avr32_ap7k_target;
 
 static struct target_type *target_types[] =
 {
@@ -90,6 +91,7 @@ static struct target_type *target_types[] =
 	&avr_target,
 	&dsp563xx_target,
 	&testee_target,
+	&avr32_ap7k_target,
 	NULL,
 };
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/Makefile.am                            |    7 +
 src/target/avr32_ap7k.c                           |  684 +++++++++++++++++++++
 src/{flash/nand/lpc3180.h => target/avr32_ap7k.h} |   40 +-
 src/target/avr32_jtag.c                           |  392 ++++++++++++
 src/target/avr32_jtag.h                           |  107 ++++
 src/target/avr32_mem.c                            |  333 ++++++++++
 src/{flash/nand/imp.h => target/avr32_mem.h}      |   34 +-
 src/target/avr32_regs.c                           |  112 ++++
 src/{pld/xilinx_bit.h => target/avr32_regs.h}     |   42 +-
 src/target/target.c                               |    2 +
 tcl/target/at32ap7000.cfg                         |   16 +
 tcl/target/avr32.cfg                              |   18 +
 12 files changed, 1736 insertions(+), 51 deletions(-)
 create mode 100644 src/target/avr32_ap7k.c
 copy src/{flash/nand/lpc3180.h => target/avr32_ap7k.h} (70%)
 create mode 100644 src/target/avr32_jtag.c
 create mode 100644 src/target/avr32_jtag.h
 create mode 100644 src/target/avr32_mem.c
 copy src/{flash/nand/imp.h => target/avr32_mem.h} (62%)
 create mode 100644 src/target/avr32_regs.c
 copy src/{pld/xilinx_bit.h => target/avr32_regs.h} (69%)
 create mode 100644 tcl/target/at32ap7000.cfg
 create mode 100644 tcl/target/avr32.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Aug 16 06:50:23 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 16 Aug 2010 04:50:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-490-g7079466
Message-ID: <E1Okrea-0000ER-Va@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  70794664f1a923c1fa2912f2b3ac81c7c1fc1ff5 (commit)
      from  c54c323cf3b6b26c9d27d8bc4237daca4ba18e66 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 70794664f1a923c1fa2912f2b3ac81c7c1fc1ff5
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Aug 16 00:36:52 2010 -0400

    Update comments for some Stellaris EK boards.
    
    These  don't need to use the on-board debuggers in JTAG mode.
    Off-board is OK, as would be SWD mode.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/ek-lm3s3748.cfg b/tcl/board/ek-lm3s3748.cfg
index 7613a0a..4695c89 100644
--- a/tcl/board/ek-lm3s3748.cfg
+++ b/tcl/board/ek-lm3s3748.cfg
@@ -2,6 +2,7 @@
 #  http://www.luminarymicro.com/products/lm3s3748_usb_h_d_evaluation_kits.html
 
 # NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
+# so is using it in JTAG mode, as done here.
 source [find interface/luminary.cfg]
 
 source [find target/stellaris.cfg]
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s811.cfg
index 66519f6..f036bc5 100644
--- a/tcl/board/ek-lm3s811.cfg
+++ b/tcl/board/ek-lm3s811.cfg
@@ -3,7 +3,8 @@
 #
 # http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
 
-# include the FT2232 interface config for on-board JTAG interface
+# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
+# so is using it in JTAG mode, as done here.
 # NOTE:  older '811-EK boards (before rev C) shouldn't use this.
 source [find interface/luminary.cfg]
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/ek-lm3s3748.cfg |    1 +
 tcl/board/ek-lm3s811.cfg  |    3 ++-
 2 files changed, 3 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Aug 16 07:12:15 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 16 Aug 2010 05:12:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-491-g66fb176
Message-ID: <E1Okrzj-0002pe-2h@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  66fb1767669775745631843eb5e7b373110d76a7 (commit)
      from  70794664f1a923c1fa2912f2b3ac81c7c1fc1ff5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 66fb1767669775745631843eb5e7b373110d76a7
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Aug 16 01:11:39 2010 -0400

    two NEWS updates
    
    Mention AVR32 AP7000 support.
    Clarify ARM semihosting update was for V7M (not ARM9 etc).
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index bb746fa..add6c1e 100644
--- a/NEWS
+++ b/NEWS
@@ -22,13 +22,15 @@ non-JTAG ways to debug targets or program flash.
 
 Target Layer:
 	ARM:
-		- basic semihosting support (ARMv7M).
+		- basic semihosting support for ARMv7M.
 		- renamed "armv7m" command prefix as "arm"
 	MIPS:
 		- "ejtag_srst" variant removed. The same functionality is
 		  obtained by using "reset_config none".
 		- added PIC32MX software reset support, this means srst is not
 		  required to be connected anymore.
+	OTHER:
+		- preliminary AVR32 AP7000 support.
 
 Flash Layer:
 	New "stellaris recover" command, implements the procedure

-----------------------------------------------------------------------

Summary of changes:
 NEWS |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Aug 16 14:26:50 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 16 Aug 2010 12:26:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-492-g962946e
Message-ID: <E1OkymG-0003Ej-PC@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  962946ea89fd948ab8c147134f06caa89b31e244 (commit)
      from  66fb1767669775745631843eb5e7b373110d76a7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 962946ea89fd948ab8c147134f06caa89b31e244
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Aug 16 08:25:37 2010 -0400

    update more Stellaris EK board comments
    
    Using the bundled JTAG/SWD debug support in JTAG mode
    is optional on *all* of the EK boards.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/ek-lm3s1968.cfg b/tcl/board/ek-lm3s1968.cfg
index 28066f3..cb83a3a 100644
--- a/tcl/board/ek-lm3s1968.cfg
+++ b/tcl/board/ek-lm3s1968.cfg
@@ -8,6 +8,8 @@
 # source [find interface/jlink.cfg]
 
 # include the FT2232 interface config for on-board JTAG interface
+# NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
+# so is using in JTAG mode, as done here.
 source [find interface/luminary.cfg]
 
 # include the target config
diff --git a/tcl/board/ek-lm3s9b9x.cfg b/tcl/board/ek-lm3s9b9x.cfg
index fb6272a..099e40d 100644
--- a/tcl/board/ek-lm3s9b9x.cfg
+++ b/tcl/board/ek-lm3s9b9x.cfg
@@ -5,6 +5,8 @@
 # http://www.luminarymicro.com/products/ek-lm3s9b92.html
 #
 
+# NOTE:  using the bundled FT2232 JTAG/SWD/SWO interface is optional!
+# so is using in JTAG mode, as done here.
 source [find interface/luminary-icdi.cfg]
 source [find target/lm3s9b9x.cfg]
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/ek-lm3s1968.cfg |    2 ++
 tcl/board/ek-lm3s9b9x.cfg |    2 ++
 2 files changed, 4 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Aug 17 22:02:22 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 17 Aug 2010 20:02:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-493-g2c4ef30
Message-ID: <E1OlSMa-0008Qs-35@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2c4ef30b11f459028c20185f41320e856db8c3a1 (commit)
      from  962946ea89fd948ab8c147134f06caa89b31e244 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2c4ef30b11f459028c20185f41320e856db8c3a1
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Aug 17 21:51:36 2010 +0200

    mcb1700: Keil MCB1700 w/1768 config script
    
    Ca. 93kBytes/s flashing speed @ 10MHz JTAG clock
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/mcb1700.cfg b/tcl/board/mcb1700.cfg
new file mode 100644
index 0000000..845c7e2
--- /dev/null
+++ b/tcl/board/mcb1700.cfg
@@ -0,0 +1,75 @@
+# Keil MCB1700 PCB with 1768
+# 
+# Reset init script sets it to 100MHz
+set CCLK 100000
+
+source [find target/lpc1768.cfg] 
+
+global MCB1700_CCLK
+set MCB1700_CCLK $CCLK
+
+$_TARGETNAME configure -event reset-start {
+	# Start *real slow* as we do not know the
+    # state the boot rom left the clock in
+	jtag_khz 10
+}
+
+# Set up 100MHz clock to CPU
+$_TARGETNAME configure -event reset-init {
+    # PLL0CON: Disable PLL
+	mww 0x400FC080 0x00000000
+    # PLLFEED
+	mww 0x400FC08C 0x000000AA
+    # PLLFEED
+	mww 0x400FC08C 0x00000055
+
+    # CCLK=PLL/4 (=100 MHz)
+	mww 0x400FC104 0x00000003
+    # CLKSRCSEL: Clock source = internal RC oscillator
+	mww 0x400FC10C 0x00000000
+
+    # PLL0CFG: M=50,N=1 -> PLL=400 MHz
+	mww 0x400FC084 0x00000031
+    # PLLFEED
+	mww 0x400FC08C 0x000000AA
+    # PLLFEED
+	mww 0x400FC08C 0x00000055
+
+	# PLL0CON: Enable PLL
+	mww 0x400FC080 0x00000001
+    # PLLFEED
+	mww 0x400FC08C 0x000000AA
+    # PLLFEED
+	mww 0x400FC08C 0x00000055
+
+	sleep 50
+
+    # PLL0CON: Connect PLL
+	mww 0x400FC080 0x00000003
+    # PLLFEED
+	mww 0x400FC08C 0x000000AA
+    # PLLFEED
+	mww 0x400FC08C 0x00000055
+
+	# Dividing CPU clock by 8 should be pretty conservative
+	#
+	# 
+	global MCB1700_CCLK
+	jtag_khz [expr $MCB1700_CCLK / 8]
+
+	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
+	# "User Flash Mode" where interrupt vectors are _not_ remapped,
+	# and reside in flash instead).
+	#
+	# See Table 612. Memory Mapping Control register (MEMMAP - 0x400F C040) bit description
+	# Bit Symbol Value Description Reset
+	# value
+	# 0 MAP Memory map control. 0
+	# 0 Boot mode. A portion of the Boot ROM is mapped to address 0.
+	# 1 User mode. The on-chip Flash memory is mapped to address 0.
+	# 31:1 - Reserved. The value read from a reserved bit is not defined. NA
+	#
+	# http://ics.nxp.com/support/documents/microcontrollers/?scope=LPC1768&type=user
+
+	mww 0x400FC040 0x01
+}
diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index 07c5ab8..4a1ff0b 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -47,18 +47,10 @@ set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x80000 0 0 $_TARGETNAME \
 	lpc1700 $_CCLK calc_checksum
 
-# Although rclk "appears to work", it turns out that this yields
-# 4MHz whereas the "correct" rate is CCLK/6, which is not what
-# you get with rclk.
-#
-# Also, crank down the frequency further as we're running of an
-# RC oscillator instead of crystal.
-#
-# Setting up XTAL in the reset-init sequence could be worth 
-# the effort if you need to program the flash which is pretty
-# big on these devices.
-#
-jtag_khz 100
+# Run with *real slow* clock by default since the
+# boot rom could have been playing with the PLL, so
+# we have no idea what clock the target is running at.
+jtag_khz 10
 
 $_TARGETNAME configure -event reset-init {
 	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/mcb1700.cfg  |   75 ++++++++++++++++++++++++++++++++++++++++++++++++
 tcl/target/lpc1768.cfg |   16 ++-------
 2 files changed, 79 insertions(+), 12 deletions(-)
 create mode 100644 tcl/board/mcb1700.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Aug 19 16:09:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 19 Aug 2010 14:09:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-494-g5c98e06
Message-ID: <E1Om5oM-00028b-Qs@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5c98e063b9827ec96194375f383a54cdff31883f (commit)
      from  2c4ef30b11f459028c20185f41320e856db8c3a1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5c98e063b9827ec96194375f383a54cdff31883f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Aug 19 16:06:45 2010 +0200

    imx35pdk: fix clock and reset delays
    
    Use rclk and 100ms delay on ntrst
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/imx35pdk.cfg b/tcl/board/imx35pdk.cfg
index e5891c8..73fa633 100644
--- a/tcl/board/imx35pdk.cfg
+++ b/tcl/board/imx35pdk.cfg
@@ -3,6 +3,10 @@ source [find target/imx35.cfg]
 source [find target/imx.cfg]
 $_TARGETNAME configure -event reset-init { imx35pdk_init }
 
+# Stick to *really* low clock rate or reset will fail
+# without RTCK / RCLK
+jtag_rclk 10
+
 proc imx35pdk_init { } {
 	
 	imx3x_reset
diff --git a/tcl/target/imx35.cfg b/tcl/target/imx35.cfg
index d47abdc..30cb386 100644
--- a/tcl/target/imx35.cfg
+++ b/tcl/target/imx35.cfg
@@ -2,6 +2,7 @@
 #
 
 reset_config trst_and_srst srst_gates_jtag
+jtag_ntrst_delay 100
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/imx35pdk.cfg |    4 ++++
 tcl/target/imx35.cfg   |    1 +
 2 files changed, 5 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Aug 28 00:20:34 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri, 27 Aug 2010 22:20:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-495-g6f84198
Message-ID: <E1Op7Ho-0000oz-QB@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6f841988417bdf64490604bee4f3c6d26a93a80b (commit)
      from  5c98e063b9827ec96194375f383a54cdff31883f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6f841988417bdf64490604bee4f3c6d26a93a80b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Fri Aug 27 15:16:39 2010 -0700

    bitq: unshadow pause()
    
    bitq.c: In function ???bitq_scan_field???:
    bitq.c:224: error: declaration of ???pause??? shadows a global declaration
    /usr/include/unistd.h:429: error: shadowed declaration is here
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/bitq.c b/src/jtag/drivers/bitq.c
index a58f633..46eb27a 100644
--- a/src/jtag/drivers/bitq.c
+++ b/src/jtag/drivers/bitq.c
@@ -221,7 +221,7 @@ void bitq_runtest(int num_cycles)
 }
 
 
-void bitq_scan_field(struct scan_field* field, int pause)
+void bitq_scan_field(struct scan_field* field, int do_pause)
 {
 	int bit_cnt;
 	int tdo_req;
@@ -240,7 +240,7 @@ void bitq_scan_field(struct scan_field* field, int pause)
 		for (bit_cnt = field->num_bits; bit_cnt > 1; bit_cnt--)
 			bitq_io(0, 0, tdo_req);
 
-		bitq_io(pause, 0, tdo_req);
+		bitq_io(do_pause, 0, tdo_req);
 	}
 	else
 	{
@@ -259,10 +259,10 @@ void bitq_scan_field(struct scan_field* field, int pause)
 				out_mask <<= 1;
 		}
 
-		bitq_io(pause, ((*out_ptr) & out_mask) != 0, tdo_req);
+		bitq_io(do_pause, ((*out_ptr) & out_mask) != 0, tdo_req);
 	}
 
-	if (pause)
+	if (do_pause)
 	{
 		bitq_io(0, 0, 0);
 		if (tap_get_state() == TAP_IRSHIFT)

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/bitq.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Aug 31 21:10:53 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 31 Aug 2010 19:10:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-498-g3c69eee
Message-ID: <E1OqWEV-0003PP-KW@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3c69eee9ef481333eb08e72badc9404e607f861c (commit)
       via  1ca286557a7b41211cae7026c99d41af031af177 (commit)
       via  31b47688ca5015bc91fb3480135a9e4efd53586a (commit)
      from  6f841988417bdf64490604bee4f3c6d26a93a80b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3c69eee9ef481333eb08e72badc9404e607f861c
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Aug 25 20:29:22 2010 +0100

    cortex m3: add cortex_m3 reset_config cmd
    
    This new cmd adds the ability to choose the Cortex-M3
    reset method used.
    It defaults to using SRST for reset if available otherwise
    it falls back to using NVIC VECTRESET. This is known to work
    on all cores.
    
    Move any luminary specific reset handling to the stellaris cfg file.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index cbb9c14..bc026b9 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -6592,6 +6592,21 @@ must also be explicitly enabled.
 This finishes by listing the current vector catch configuration.
 @end deffn
 
+ at deffn Command {cortex_m3 reset_config} (@option{srst}|@option{sysresetreq}|@option{vectreset})
+Control reset handling. The default @option{srst} is to use srst if fitted,
+otherwise fallback to @option{vectreset}.
+ at itemize @minus
+ at item @option{srst} use hardware srst if fitted otherwise fallback to @option{vectreset}.
+ at item @option{sysresetreq} use NVIC SYSRESETREQ to reset system.
+ at item @option{vectreset} use NVIC VECTRESET to reset system.
+ at end itemize
+Using @option{vectreset} is a safe option for all current Cortex-M3 cores.
+This however has the disadvantage of only resetting the core, all peripherals
+are uneffected. A solution would be to use a @code{reset-init} event handler to manually reset
+the peripherals.
+ at xref{Target Events}.
+ at end deffn
+
 @anchor{Software Debug Messages and Tracing}
 @section Software Debug Messages and Tracing
 @cindex Linux-ARM DCC support
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 2a58f5b..f87c3e0 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -913,7 +913,7 @@ static int cortex_m3_assert_reset(struct target *target)
 {
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct adiv5_dap *swjdp = &cortex_m3->armv7m.dap;
-	int assert_srst = 1;
+	enum cortex_m3_soft_reset_config reset_config = cortex_m3->soft_reset_config;
 
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
@@ -925,8 +925,10 @@ static int cortex_m3_assert_reset(struct target *target)
 	 * requiring SRST, getting a SoC reset (or a core-only reset)
 	 * instead of a system reset.
 	 */
-	if (!(jtag_reset_config & RESET_HAS_SRST))
-		assert_srst = 0;
+	if (!(jtag_reset_config & RESET_HAS_SRST) &&
+			(cortex_m3->soft_reset_config == CORTEX_M3_RESET_SRST)) {
+		reset_config = CORTEX_M3_RESET_VECTRESET;
+	}
 
 	/* Enable debug requests */
 	int retval;
@@ -975,49 +977,7 @@ static int cortex_m3_assert_reset(struct target *target)
 			return retval;
 	}
 
-	/*
-	 * When nRST is asserted on most Stellaris devices, it clears some of
-	 * the debug state.  The ARMv7M and Cortex-M3 TRMs say that's wrong;
-	 * and OpenOCD depends on those TRMs.  So we won't use SRST on those
-	 * chips.  (Only power-on reset should affect debug state, beyond a
-	 * few specified bits; not the chip's nRST input, wired to SRST.)
-	 *
-	 * REVISIT current errata specs don't seem to cover this issue.
-	 * Do we have more details than this email?
-	 *   https://lists.berlios.de/pipermail
-	 *	/openocd-development/2008-August/003065.html
-	 */
-	if (strcmp(target->variant, "lm3s") == 0)
-	{
-		/* Check for silicon revisions with the issue. */
-		uint32_t did0;
-
-		if (target_read_u32(target, 0x400fe000, &did0) == ERROR_OK)
-		{
-			switch ((did0 >> 16) & 0xff)
-			{
-				case 0:
-					/* all Sandstorm suffer issue */
-					assert_srst = 0;
-					break;
-
-				case 1:
-				case 3:
-					/* Fury and DustDevil rev A have
-					 * this nRST problem.  It should
-					 * be fixed in rev B silicon.
-					 */
-					if (((did0 >> 8) & 0xff) == 0)
-						assert_srst = 0;
-					break;
-				case 4:
-					/* Tempest should be fine. */
-					break;
-			}
-		}
-	}
-
-	if (assert_srst)
+	if (reset_config == CORTEX_M3_RESET_SRST)
 	{
 		/* default to asserting srst */
 		if (jtag_reset_config & RESET_SRST_PULLS_TRST)
@@ -1032,15 +992,23 @@ static int cortex_m3_assert_reset(struct target *target)
 	else
 	{
 		/* Use a standard Cortex-M3 software reset mechanism.
-		 * SYSRESETREQ will reset SoC peripherals outside the
-		 * core, like watchdog timers, if the SoC wires it up
-		 * correctly.  Else VECRESET can reset just the core.
+		 * We default to using VECRESET as it is supported on all current cores.
+		 * This has the disadvantage of not resetting the peripherals, so a
+		 * reset-init event handler is needed to perform any peripheral resets.
 		 */
 		retval = mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
-				AIRCR_VECTKEY | AIRCR_SYSRESETREQ);
+				AIRCR_VECTKEY | ((reset_config == CORTEX_M3_RESET_SYSRESETREQ)
+				? AIRCR_SYSRESETREQ : AIRCR_VECTRESET));
 		if (retval != ERROR_OK)
 			return retval;
-		LOG_DEBUG("Using Cortex-M3 SYSRESETREQ");
+
+		LOG_DEBUG("Using Cortex-M3 %s", (reset_config == CORTEX_M3_RESET_SYSRESETREQ)
+				? "SYSRESETREQ" : "VECTRESET");
+
+		if (reset_config == CORTEX_M3_RESET_VECTRESET) {
+			LOG_WARNING("Only resetting the Cortex-M3 core, use a reset-init event "
+					"handler to reset any peripherals");
+		}
 
 		{
 			/* I do not know why this is necessary, but it
@@ -1969,6 +1937,10 @@ static int cortex_m3_init_arch_info(struct target *target,
 	cortex_m3->jtag_info.tap = tap;
 	cortex_m3->jtag_info.scann_size = 4;
 
+	/* default reset mode is to use srst if fitted
+	 * if not it will use CORTEX_M3_RESET_VECTRESET */
+	cortex_m3->soft_reset_config = CORTEX_M3_RESET_SRST;
+
 	armv7m->arm.dap = &armv7m->dap;
 
 	/* Leave (only) generic DAP stuff for debugport_init(); */
@@ -2143,6 +2115,51 @@ COMMAND_HANDLER(handle_cortex_m3_mask_interrupts_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_cortex_m3_reset_config_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
+	int retval;
+	char *reset_config;
+
+	retval = cortex_m3_verify_pointer(CMD_CTX, cortex_m3);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (CMD_ARGC > 0)
+	{
+		if (strcmp(*CMD_ARGV, "systesetreq") == 0)
+			cortex_m3->soft_reset_config = CORTEX_M3_RESET_SYSRESETREQ;
+		else if (strcmp(*CMD_ARGV, "vectreset") == 0)
+			cortex_m3->soft_reset_config = CORTEX_M3_RESET_VECTRESET;
+		else
+			cortex_m3->soft_reset_config = CORTEX_M3_RESET_SRST;
+	}
+
+	switch (cortex_m3->soft_reset_config)
+	{
+		case CORTEX_M3_RESET_SRST:
+			reset_config = "srst";
+			break;
+
+		case CORTEX_M3_RESET_SYSRESETREQ:
+			reset_config = "sysresetreq";
+			break;
+
+		case CORTEX_M3_RESET_VECTRESET:
+			reset_config = "vectreset";
+			break;
+
+		default:
+			reset_config = "unknown";
+			break;
+	}
+
+	command_print(CMD_CTX, "cortex_m3 reset_config %s", reset_config);
+
+	return ERROR_OK;
+}
+
 static const struct command_registration cortex_m3_exec_command_handlers[] = {
 	{
 		.name = "maskisr",
@@ -2158,6 +2175,13 @@ static const struct command_registration cortex_m3_exec_command_handlers[] = {
 		.help = "configure hardware vectors to trigger debug entry",
 		.usage = "['all'|'none'|('bus_err'|'chk_err'|...)*]",
 	},
+	{
+		.name = "reset_config",
+		.handler = handle_cortex_m3_reset_config_command,
+		.mode = COMMAND_ANY,
+		.help = "configure software reset handling",
+		.usage = "['srst'|'sysresetreq'|'vectreset']",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration cortex_m3_command_handlers[] = {
diff --git a/src/target/cortex_m3.h b/src/target/cortex_m3.h
index 7ce8901..db80711 100644
--- a/src/target/cortex_m3.h
+++ b/src/target/cortex_m3.h
@@ -134,6 +134,13 @@ struct cortex_m3_dwt_comparator
 	uint32_t dwt_comparator_address;
 };
 
+enum cortex_m3_soft_reset_config
+{
+	CORTEX_M3_RESET_SRST,
+	CORTEX_M3_RESET_SYSRESETREQ,
+	CORTEX_M3_RESET_VECTRESET,
+};
+
 struct cortex_m3_common
 {
 	int common_magic;
@@ -158,6 +165,8 @@ struct cortex_m3_common
 	struct cortex_m3_dwt_comparator *dwt_comparator_list;
 	struct reg_cache *dwt_cache;
 
+	enum cortex_m3_soft_reset_config soft_reset_config;
+
 	struct armv7m_common armv7m;
 };
 
diff --git a/tcl/target/stellaris.cfg b/tcl/target/stellaris.cfg
index 4235f91..6ba5f14 100644
--- a/tcl/target/stellaris.cfg
+++ b/tcl/target/stellaris.cfg
@@ -21,18 +21,15 @@ if { [info exists CPUTAPID ] } {
 if { [info exists WORKAREASIZE ] } {
    set _WORKAREASIZE $WORKAREASIZE
 } else {
+   # default to 8K working area
    set _WORKAREASIZE 0x2000
 }
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -irmask 0xf \
 	-expected-id $_CPUTAPID -ignore-version
 
-# The "lm3s" variant uses a software reset rather than SRST.
-# This stops the debug registers from being cleared; it works
-# around an erratum which should be fixed in later silicon.
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu \
-	-variant lm3s
+target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu
 
 # 8K working area at base of ram, not backed up
 #
@@ -48,7 +45,41 @@ $_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE
 # configures and enables the PLL.  Or you might need to decrease
 # this, if you're using a slower clock.
 adapter_khz 500
-$_TARGETNAME configure -event reset-start {adapter_khz 500}
+
+# mrw: "memory read word", returns value of $reg
+proc mrw {reg} {
+	set value ""
+	mem2array value 32 $reg 1
+	return $value(0)
+}
+
+$_TARGETNAME configure -event reset-start {
+	adapter_khz 500
+
+	#	
+	# When nRST is asserted on most Stellaris devices, it clears some of
+	# the debug state.  The ARMv7M and Cortex-M3 TRMs say that's wrong;
+	# and OpenOCD depends on those TRMs.  So we won't use SRST on those
+	# chips.  (Only power-on reset should affect debug state, beyond a
+	# few specified bits; not the chip's nRST input, wired to SRST.)
+	#
+	# REVISIT current errata specs don't seem to cover this issue.
+	# Do we have more details than this email?
+	#   https://lists.berlios.de/pipermail
+	#	/openocd-development/2008-August/003065.html
+	#
+
+	set device_class [expr (([mrw 0x400fe000] >> 16) & 0xff)]
+	if {$device_class == 0 || $device_class == 1 || $device_class == 3} {
+		# Sandstorm, Fury and DustDevil are able to use NVIC SYSRESETREQ
+		cortex_m3 reset_config systesetreq
+	} else {
+		# Tempest and newer default to using NVIC VECTRESET
+		# this does mean a reset-init event handler is required to reset
+		# any peripherals
+		cortex_m3 reset_config vectreset
+	}
+}
 
 # flash configuration ... autodetects sizes, autoprobed
 flash bank $_CHIPNAME.flash stellaris 0 0 0 0 $_TARGETNAME

commit 1ca286557a7b41211cae7026c99d41af031af177
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Aug 24 20:52:04 2010 +0100

    flash: increase stellaris flash loader buffer
    
    This speeds up programming for targets with more working area,
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 03800fd..287be12 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -816,7 +816,7 @@ static int stellaris_write_block(struct flash_bank *bank,
 		uint8_t *buffer, uint32_t offset, uint32_t wcount)
 {
 	struct target *target = bank->target;
-	uint32_t buffer_size = 8192;
+	uint32_t buffer_size = 16384;
 	struct working_area *source;
 	struct working_area *write_algorithm;
 	uint32_t address = bank->base + offset;

commit 31b47688ca5015bc91fb3480135a9e4efd53586a
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Aug 24 20:50:20 2010 +0100

    cfg: update Luminary config files
    
     - Update all Luminary config's to use a common target/stellaris.cfg.
     - Add Luminary ek-lm3s6965 config.
     - Increase working area for boards with more ram.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/ek-lm3s1968.cfg b/tcl/board/ek-lm3s1968.cfg
index cb83a3a..184d368 100644
--- a/tcl/board/ek-lm3s1968.cfg
+++ b/tcl/board/ek-lm3s1968.cfg
@@ -13,7 +13,8 @@
 source [find interface/luminary.cfg]
 
 # include the target config
-source [find target/lm3s1968.cfg]
+set CHIPNAME lm3s1968
+source [find target/stellaris.cfg]
 
 # jtag speed
 adapter_khz 3000
diff --git a/tcl/board/ek-lm3s3748.cfg b/tcl/board/ek-lm3s3748.cfg
index 4695c89..acc62f6 100644
--- a/tcl/board/ek-lm3s3748.cfg
+++ b/tcl/board/ek-lm3s3748.cfg
@@ -5,6 +5,9 @@
 # so is using it in JTAG mode, as done here.
 source [find interface/luminary.cfg]
 
+# 20k working area
+set WORKAREASIZE 0x4000
+set CHIPNAME lm3s3748
 source [find target/stellaris.cfg]
 
 # Board has only srst
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s6965.cfg
similarity index 51%
copy from tcl/board/ek-lm3s811.cfg
copy to tcl/board/ek-lm3s6965.cfg
index f036bc5..e2cd1e2 100644
--- a/tcl/board/ek-lm3s811.cfg
+++ b/tcl/board/ek-lm3s6965.cfg
@@ -1,20 +1,19 @@
 #
-# TI/Luminary Stellaris LM3S811 Evaluation Kits
+# TI/Luminary Stellaris LM3S6965 Evaluation Kits
 #
-# http://www.luminarymicro.com/products/stellaris_811_evaluation_kits.html
+# http://www.luminarymicro.com/products/lm3s6965_ethernet_evaluation_kit.html
 
 # NOTE:  using the on-board FT2232 JTAG/SWD/SWO interface is optional!
 # so is using it in JTAG mode, as done here.
-# NOTE:  older '811-EK boards (before rev C) shouldn't use this.
 source [find interface/luminary.cfg]
 
-   set  CHIPNAME lm3s811
-
+# 20k working area
+set WORKAREASIZE 0x5000
+set CHIPNAME lm3s6965
 # include the target config
 source [find target/stellaris.cfg]
 
-
 adapter_nsrst_delay 100
 
-#LM3S811 Evaluation Board has only srst
+# LM3S6965 Evaluation Board has only srst
 reset_config srst_only
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s811.cfg
index f036bc5..0dcc70c 100644
--- a/tcl/board/ek-lm3s811.cfg
+++ b/tcl/board/ek-lm3s811.cfg
@@ -8,9 +8,8 @@
 # NOTE:  older '811-EK boards (before rev C) shouldn't use this.
 source [find interface/luminary.cfg]
 
-   set  CHIPNAME lm3s811
-
 # include the target config
+set CHIPNAME lm3s811
 source [find target/stellaris.cfg]
 
 
diff --git a/tcl/board/ek-lm3s9b9x.cfg b/tcl/board/ek-lm3s9b9x.cfg
index 099e40d..83f6731 100644
--- a/tcl/board/ek-lm3s9b9x.cfg
+++ b/tcl/board/ek-lm3s9b9x.cfg
@@ -8,7 +8,10 @@
 # NOTE:  using the bundled FT2232 JTAG/SWD/SWO interface is optional!
 # so is using in JTAG mode, as done here.
 source [find interface/luminary-icdi.cfg]
-source [find target/lm3s9b9x.cfg]
+
+set WORKAREASIZE 0x4000
+set CHIPNAME lm3s9b9x
+source [find target/stellaris.cfg]
 
 # jtag speed
 adapter_khz 500
diff --git a/tcl/target/lm3s1968.cfg b/tcl/target/lm3s1968.cfg
deleted file mode 100644
index 330bb56..0000000
--- a/tcl/target/lm3s1968.cfg
+++ /dev/null
@@ -1,29 +0,0 @@
-# Script for TI/Luminary Stellaris LM3S1968
-
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lm3s1968
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x3ba00477
-}
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0xf -expected-id $_CPUTAPID
-
-# the luminary variant causes a software reset rather than asserting SRST
-# this stops the debug registers from being cleared
-# this will be fixed in later revisions of silicon
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
-
-# 8k working area at base of ram, not backed up
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
-
-#flash configuration
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME stellaris 0 0 0 0 $_TARGETNAME
diff --git a/tcl/target/lm3s6965.cfg b/tcl/target/lm3s6965.cfg
deleted file mode 100644
index 137cba9..0000000
--- a/tcl/target/lm3s6965.cfg
+++ /dev/null
@@ -1,38 +0,0 @@
-# TI/Luminary Stellaris lm3s6965
-
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lm3s6965
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x3ba00477
-}
-
-# jtag speed
-adapter_khz 500
-
-adapter_nsrst_delay 100
-jtag_ntrst_delay 100
-
-#LM3S6965 Evaluation Board has only srst
-reset_config srst_only
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0xf -expected-id $_CPUTAPID
-
-# the luminary variant causes a software reset rather than asserting SRST
-# this stops the debug registers from being cleared
-# this will be fixed in later revisions of silicon
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
-
-# 8k working area at base of ram, not backed up
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
-
-#flash configuration
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME stellaris 0 0 0 0 $_TARGETNAME
diff --git a/tcl/target/lm3s9b9x.cfg b/tcl/target/lm3s9b9x.cfg
deleted file mode 100644
index a727251..0000000
--- a/tcl/target/lm3s9b9x.cfg
+++ /dev/null
@@ -1,33 +0,0 @@
-#
-# Luminary Micro Stellaris LM3S9B9x Microcontroller
-#
-# http://www.luminarymicro.com/products/lm3s9b90.html
-# http://www.luminarymicro.com/products/lm3s9b92.htm
-#
-
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME lm3s9b9x
-}
-
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   # Fourth generation "Tempest" device
-   set _CPUTAPID 0x4ba00477
-}
-
-#jtag scan chain
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 1 -irmask 0xf -expected-id $_CPUTAPID
-
-#Cortex-M3 with Luminary lm3s variant
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu -variant lm3s
-
-# 16k working area at base of ram, not backed up
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x4000
-
-#flash configuration
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME stellaris 0 0 0 0 $_TARGETNAME
diff --git a/tcl/target/stellaris.cfg b/tcl/target/stellaris.cfg
index 5f4428f..4235f91 100644
--- a/tcl/target/stellaris.cfg
+++ b/tcl/target/stellaris.cfg
@@ -18,6 +18,12 @@ if { [info exists CPUTAPID ] } {
    set _CPUTAPID 0x0ba00477
 }
 
+if { [info exists WORKAREASIZE ] } {
+   set _WORKAREASIZE $WORKAREASIZE
+} else {
+   set _WORKAREASIZE 0x2000
+}
+
 jtag newtap $_CHIPNAME cpu -irlen 4 -irmask 0xf \
 	-expected-id $_CPUTAPID -ignore-version
 
@@ -33,7 +39,7 @@ target create $_TARGETNAME cortex_m3 -chain-position $_CHIPNAME.cpu \
 # NOTE:  you may need or want to reconfigure the work area;
 # some parts have just 6K, and you may want to use other
 # addresses (at end of mem not beginning) or back it up.
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 0x2000
+$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE
 
 # JTAG speed ... slow enough to work with a 12 MHz RC oscillator;
 # LM3S parts don't support RTCK

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi                              |   15 +++
 src/flash/nor/stellaris.c                     |    2 +-
 src/target/cortex_m3.c                        |  126 +++++++++++++++----------
 src/target/cortex_m3.h                        |    9 ++
 tcl/board/ek-lm3s1968.cfg                     |    3 +-
 tcl/board/ek-lm3s3748.cfg                     |    3 +
 tcl/board/{ek-lm3s811.cfg => ek-lm3s6965.cfg} |   13 +--
 tcl/board/ek-lm3s811.cfg                      |    3 +-
 tcl/board/ek-lm3s9b9x.cfg                     |    5 +-
 tcl/target/lm3s1968.cfg                       |   29 ------
 tcl/target/lm3s6965.cfg                       |   38 --------
 tcl/target/lm3s9b9x.cfg                       |   33 -------
 tcl/target/stellaris.cfg                      |   51 +++++++++--
 13 files changed, 160 insertions(+), 170 deletions(-)
 copy tcl/board/{ek-lm3s811.cfg => ek-lm3s6965.cfg} (51%)
 delete mode 100644 tcl/target/lm3s1968.cfg
 delete mode 100644 tcl/target/lm3s6965.cfg
 delete mode 100644 tcl/target/lm3s9b9x.cfg


hooks/post-receive
-- 
Main OpenOCD repository


