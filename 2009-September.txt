From ntfreak at mail.berlios.de  Tue Sep  1 12:08:01 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 1 Sep 2009 12:08:01 +0200
Subject: [Openocd-svn] r2659 - trunk/src/target
Message-ID: <200909011008.n81A81f3028245@sheep.berlios.de>

Author: ntfreak
Date: 2009-09-01 12:08:00 +0200 (Tue, 01 Sep 2009)
New Revision: 2659

Modified:
   trunk/src/target/cortex_m3.c
Log:
- fix a regression when using cortex_m3 emulated dcc channel


Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-08-31 12:21:12 UTC (rev 2658)
+++ trunk/src/target/cortex_m3.c	2009-09-01 10:08:00 UTC (rev 2659)
@@ -105,7 +105,7 @@
 	uint32_t dcrdr;
 
 	/* because the DCB_DCRDR is used for the emulated dcc channel
-	 * we gave to save/restore the DCB_DCRDR when used */
+	 * we have to save/restore the DCB_DCRDR when used */
 
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
 
@@ -119,8 +119,13 @@
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
 	dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);
 
-	mem_ap_write_u32(swjdp, DCB_DCRDR, dcrdr);
 	retval = swjdp_transaction_endcheck(swjdp);
+
+	/* restore DCB_DCRDR - this needs to be in a seperate
+	 * transaction otherwise the emulated DCC channel breaks */
+	if (retval == ERROR_OK)
+		retval = mem_ap_write_atomic_u32(swjdp, DCB_DCRDR, dcrdr);
+
 	return retval;
 }
 
@@ -130,7 +135,7 @@
 	uint32_t dcrdr;
 
 	/* because the DCB_DCRDR is used for the emulated dcc channel
-	 * we gave to save/restore the DCB_DCRDR when used */
+	 * we have to save/restore the DCB_DCRDR when used */
 
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
 
@@ -144,12 +149,16 @@
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
 	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum | DCRSR_WnR);
 
-	mem_ap_write_u32(swjdp, DCB_DCRDR, dcrdr);
 	retval = swjdp_transaction_endcheck(swjdp);
+
+	/* restore DCB_DCRDR - this needs to be in a seperate
+	 * transaction otherwise the emulated DCC channel breaks */
+	if (retval == ERROR_OK)
+		retval = mem_ap_write_atomic_u32(swjdp, DCB_DCRDR, dcrdr);
+
 	return retval;
 }
 
-
 int cortex_m3_write_debug_halt_mask(target_t *target, uint32_t mask_on, uint32_t mask_off)
 {
 	/* get pointers to arch-specific information */
@@ -668,7 +677,7 @@
 		/* Single step past breakpoint at current address */
 		if ((breakpoint = breakpoint_find(target, resume_pc)))
 		{
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (ID: %d)", 
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (ID: %d)",
 					  breakpoint->address,
 					  breakpoint->unique_id );
 			cortex_m3_unset_breakpoint(target, breakpoint);
@@ -971,7 +980,7 @@
 		breakpoint->set = 0x11; /* Any nice value but 0 */
 	}
 
-	LOG_DEBUG("BPID: %d, Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)", 
+	LOG_DEBUG("BPID: %d, Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)",
 			  breakpoint->unique_id,
 			  (int)(breakpoint->type),
 			  breakpoint->address,
@@ -995,7 +1004,7 @@
 		return ERROR_OK;
 	}
 
-	LOG_DEBUG("BPID: %d, Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)", 
+	LOG_DEBUG("BPID: %d, Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)",
 			  breakpoint->unique_id,
 			  (int)(breakpoint->type),
 			  breakpoint->address,
@@ -1165,7 +1174,7 @@
 				  watchpoint->unique_id );
 		return ERROR_OK;
 	}
-	LOG_DEBUG("Watchpoint (ID: %d) address: 0x%08" PRIx32 " set=%d ", 
+	LOG_DEBUG("Watchpoint (ID: %d) address: 0x%08" PRIx32 " set=%d ",
 			  watchpoint->unique_id, watchpoint->address, watchpoint->set );
 	return ERROR_OK;
 
@@ -1185,7 +1194,7 @@
 		return ERROR_OK;
 	}
 
-	LOG_DEBUG("Watchpoint (ID: %d) address: 0x%08" PRIx32 " set=%d ", 
+	LOG_DEBUG("Watchpoint (ID: %d) address: 0x%08" PRIx32 " set=%d ",
 			  watchpoint->unique_id, watchpoint->address,watchpoint->set );
 
 	dwt_num = watchpoint->set - 1;



From ntfreak at mail.berlios.de  Tue Sep  1 12:08:42 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 1 Sep 2009 12:08:42 +0200
Subject: [Openocd-svn] r2660 - trunk/src/flash
Message-ID: <200909011008.n81A8gNC028474@sheep.berlios.de>

Author: ntfreak
Date: 2009-09-01 12:08:41 +0200 (Tue, 01 Sep 2009)
New Revision: 2660

Modified:
   trunk/src/flash/stellaris.c
Log:
- fixes the incorrect info msg displayed during stellaris flash programming.

Modified: trunk/src/flash/stellaris.c
===================================================================
--- trunk/src/flash/stellaris.c	2009-09-01 10:08:00 UTC (rev 2659)
+++ trunk/src/flash/stellaris.c	2009-09-01 10:08:41 UTC (rev 2660)
@@ -917,8 +917,8 @@
 		buf_set_u32(reg_params[0].value, 0, 32, source->address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, 4*thisrun_count);
-		LOG_INFO("Algorithm flash write %" PRIi32 " words to 0x%" PRIx32 ", %" PRIi32 " remaining", thisrun_count, address, wcount);
-		LOG_DEBUG("Algorithm flash write %" PRIi32 " words to 0x%" PRIx32 ", %" PRIi32 " remaining", thisrun_count, address, wcount);
+		LOG_INFO("Algorithm flash write %" PRIi32 " words to 0x%" PRIx32 ", %" PRIi32 " remaining", thisrun_count, address, (wcount - thisrun_count));
+		LOG_DEBUG("Algorithm flash write %" PRIi32 " words to 0x%" PRIx32 ", %" PRIi32 " remaining", thisrun_count, address, (wcount - thisrun_count));
 		if ((retval = target_run_algorithm(target, 0, NULL, 3, reg_params, write_algorithm->address, write_algorithm->address + sizeof(stellaris_write_code)-10, 10000, &armv7m_info)) != ERROR_OK)
 		{
 			LOG_ERROR("error executing stellaris flash write algorithm");



From duane at mail.berlios.de  Wed Sep  2 02:17:42 2009
From: duane at mail.berlios.de (duane at mail.berlios.de)
Date: Wed, 2 Sep 2009 02:17:42 +0200
Subject: [Openocd-svn] r2661 - in trunk/tcl/chip: atmel/at91 st/stm32
Message-ID: <200909020017.n820Hgtt024289@sheep.berlios.de>

Author: duane
Date: 2009-09-02 02:17:39 +0200 (Wed, 02 Sep 2009)
New Revision: 2661

Modified:
   trunk/tcl/chip/atmel/at91/at91sam7x128.tcl
   trunk/tcl/chip/atmel/at91/at91sam7x256.tcl
   trunk/tcl/chip/st/stm32/stm32.tcl
Log:
Crusty Code fixes from the tcl directory re-arragements

Modified: trunk/tcl/chip/atmel/at91/at91sam7x128.tcl
===================================================================
--- trunk/tcl/chip/atmel/at91/at91sam7x128.tcl	2009-09-01 10:08:41 UTC (rev 2660)
+++ trunk/tcl/chip/atmel/at91/at91sam7x128.tcl	2009-09-02 00:17:39 UTC (rev 2661)
@@ -1,7 +1,7 @@
-source [find tcl/bitsbytes.tcl]
-source [find tcl/cpu/arm/arm7tdmi.tcl]
-source [find tcl/memory.tcl]
-source [find tcl/mmr_helpers.tcl]
+source [find bitsbytes.tcl]
+source [find cpu/arm/arm7tdmi.tcl]
+source [find memory.tcl]
+source [find mmr_helpers.tcl]
 
 set CHIP_MAKER  atmel
 set CHIP_FAMILY at91sam7
@@ -122,7 +122,7 @@
 set AT91C_ID(30) IRQ0
 set AT91C_ID(31) IRQ1
 
-source [find tcl/chip/atmel/at91/aic.tcl]
-source [find tcl/chip/atmel/at91/usarts.tcl]
-source [find tcl/chip/atmel/at91/pmc.tcl]
-source [find tcl/chip/atmel/at91/rtt.tcl]
+source [find chip/atmel/at91/aic.tcl]
+source [find chip/atmel/at91/usarts.tcl]
+source [find chip/atmel/at91/pmc.tcl]
+source [find chip/atmel/at91/rtt.tcl]

Modified: trunk/tcl/chip/atmel/at91/at91sam7x256.tcl
===================================================================
--- trunk/tcl/chip/atmel/at91/at91sam7x256.tcl	2009-09-01 10:08:41 UTC (rev 2660)
+++ trunk/tcl/chip/atmel/at91/at91sam7x256.tcl	2009-09-02 00:17:39 UTC (rev 2661)
@@ -1,7 +1,7 @@
-source [find tcl/bitsbytes.tcl]
-source [find tcl/cpu/arm/arm7tdmi.tcl]
-source [find tcl/memory.tcl]
-source [find tcl/mmr_helpers.tcl]
+source [find bitsbytes.tcl]
+source [find cpu/arm/arm7tdmi.tcl]
+source [find memory.tcl]
+source [find mmr_helpers.tcl]
 
 set CHIP_MAKER  atmel
 set CHIP_FAMILY at91sam7
@@ -120,7 +120,7 @@
 set AT91C_ID(31)   "IRQ1"
 
 
-source [find tcl/chip/atmel/at91/aic.tcl]
-source [find tcl/chip/atmel/at91/usarts.tcl]
-source [find tcl/chip/atmel/at91/pmc.tcl]
-source [find tcl/chip/atmel/at91/rtt.tcl]
+source [find chip/atmel/at91/aic.tcl]
+source [find chip/atmel/at91/usarts.tcl]
+source [find chip/atmel/at91/pmc.tcl]
+source [find chip/atmel/at91/rtt.tcl]

Modified: trunk/tcl/chip/st/stm32/stm32.tcl
===================================================================
--- trunk/tcl/chip/st/stm32/stm32.tcl	2009-09-01 10:08:41 UTC (rev 2660)
+++ trunk/tcl/chip/st/stm32/stm32.tcl	2009-09-02 00:17:39 UTC (rev 2661)
@@ -1,7 +1,7 @@
-source [find tcl/bitsbytes.tcl]
-source [find tcl/cpu/arm/cortex_m3.tcl]
-source [find tcl/memory.tcl]
-source [find tcl/mmr_helpers.tcl]
+source [find bitsbytes.tcl]
+source [find cpu/arm/cortex_m3.tcl]
+source [find memory.tcl]
+source [find mmr_helpers.tcl]
 
-source [find tcl/chip/st/stm32/stm32_regs.tcl]
-source [find tcl/chip/st/stm32/stm32_rcc.tcl]
+source [find chip/st/stm32/stm32_regs.tcl]
+source [find chip/st/stm32/stm32_rcc.tcl]



From oharboe at mail.berlios.de  Wed Sep  2 19:34:35 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 2 Sep 2009 19:34:35 +0200
Subject: [Openocd-svn] r2662 - trunk/tcl/target
Message-ID: <200909021734.n82HYZtl002824@sheep.berlios.de>

Author: oharboe
Date: 2009-09-02 19:34:35 +0200 (Wed, 02 Sep 2009)
New Revision: 2662

Added:
   trunk/tcl/target/ar71xx.cfg
Log:
David Claffey <dnclaffey at gmail.com> tested with the Atheros reference design "PB44"

Added: trunk/tcl/target/ar71xx.cfg
===================================================================
--- trunk/tcl/target/ar71xx.cfg	2009-09-02 00:17:39 UTC (rev 2661)
+++ trunk/tcl/target/ar71xx.cfg	2009-09-02 17:34:35 UTC (rev 2662)
@@ -0,0 +1,56 @@
+# Atheros AR71xx MIPS 24Kc SoC.
+# tested on PB44 refererence board
+
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+
+reset_config trst_and_srst
+
+set CHIPNAME ar71xx
+
+jtag newtap $CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id 1
+
+set TARGETNAME [format "%s.cpu" $CHIPNAME]
+target create $TARGETNAME mips_m4k -endian big -chain-position $TARGETNAME
+
+$TARGETNAME configure -event reset-init {
+	#setup PLL to lowest common denominator 300/300/150 setting
+	mww 0xb8050000 0x000f40a3	# reset val + CPU:3 DDR:3 AHB:0
+	mww 0xb8050000 0x800f40a3	# send to PLL
+
+	#next command will reset for PLL changes to take effect
+	mww 0xb8050008 3		# set reset_switch and clock_switch (resets SoC)
+	reset halt     			# let openocd know that it is in the reset state
+
+	#initialize_pll
+	mww 0xb8050000 0x800f0080	# set sw_update bit
+	mww 0xb8050008 0		# clear reset_switch bit
+	mww 0xb8050000 0x800f00e8       # clr pwrdwn & bypass
+	mww 0xb8050008 1		# set clock_switch bit
+	sleep 1                         # wait for lock
+	
+	# Setup DDR config and flash mapping
+	mww 0xb8000000 0xefbc8cd0       # DDR cfg cdl val (rst: 0x5bfc8d0)
+	mww 0xb8000004 0x8e7156a2       # DDR cfg2 cdl val (rst: 0x80d106a8)
+	
+	mww 0xb8000010 8		# force precharge all banks
+	mww 0xb8000010 1 		# force EMRS update cycle
+	mww 0xb800000c 0                # clr ext. mode register
+	mww 0xb8000010 2 		# force auto refresh all banks
+	mww 0xb8000010 8		# force precharge all banks
+	mww 0xb8000008 0x31             # set DDR mode value CAS=3
+	mww 0xb8000010 1 		# force EMRS update cycle
+	mww 0xb8000014 0x461b           # DDR refresh value
+	mww 0xb8000018 0xffff           # DDR Read Data This Cycle value (16bit: 0xffff)
+	mww 0xb800001c 0x7              # delay added to the DQS line (normal = 7)
+	mww 0xb8000020 0
+	mww 0xb8000024 0
+	mww 0xb8000028 0
+}	
+
+# setup working area somewhere in RAM
+$TARGETNAME configure -work-area-phys 0xa0600000 -work-area-size 0x20000
+
+# serial SPI capable flash
+# flash bank <driver> <base> <size> <chip_width> <bus_width>
+


Property changes on: trunk/tcl/target/ar71xx.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Thu Sep  3 10:23:40 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 3 Sep 2009 10:23:40 +0200
Subject: [Openocd-svn] r2663 - trunk/src/flash
Message-ID: <200909030823.n838Neh3021012@sheep.berlios.de>

Author: oharboe
Date: 2009-09-03 10:23:39 +0200 (Thu, 03 Sep 2009)
New Revision: 2663

Added:
   trunk/src/flash/arm_nandio.c
   trunk/src/flash/arm_nandio.h
Modified:
   trunk/src/flash/Makefile.am
   trunk/src/flash/davinci_nand.c
   trunk/src/flash/nand.h
   trunk/src/flash/orion_nand.c
Log:
David Brownell

Abstract the orion_nand_fast_block_write() routine into a separate
routine -- arm_nandwrite() -- so that other ARM cores can reuse it.

Have davinci_nand do so.  This faster than byte-at-a-time ops by a
factor of three (!), even given the slowish interactions to support
hardware ECC (1-bit flavor in that test) each 512 bytes; those could
be read more efficiently by on-chip code.

NOTE that until there's a generic "ARM algorithm" structure, this
can't work on newer ARMv6 (like ARM1136) or ARMv7A (like Cortex-A8)
cores, though the downloaded code itself would work just fine there.

Modified: trunk/src/flash/Makefile.am
===================================================================
--- trunk/src/flash/Makefile.am	2009-09-02 17:34:35 UTC (rev 2662)
+++ trunk/src/flash/Makefile.am	2009-09-03 08:23:39 UTC (rev 2663)
@@ -6,6 +6,7 @@
 METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
 libflash_la_SOURCES = \
+	arm_nandio.c \
 	flash.c \
 	lpc2000.c \
 	cfi.c \
@@ -38,6 +39,7 @@
 	avrf.c
 
 noinst_HEADERS = \
+	arm_nandio.h \
 	flash.h \
 	lpc2000.h \
 	cfi.h \

Added: trunk/src/flash/arm_nandio.c
===================================================================
--- trunk/src/flash/arm_nandio.c	2009-09-02 17:34:35 UTC (rev 2662)
+++ trunk/src/flash/arm_nandio.c	2009-09-03 08:23:39 UTC (rev 2663)
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2009 by Marvell Semiconductors, Inc.
+ * Written by Nicolas Pitre <nico at marvell.com>
+ *
+ * Copyright (C) 2009 by David Brownell
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm_nandio.h"
+#include "armv4_5.h"
+
+
+/*
+ * ARM-specific bulk write from buffer to address of 8-bit wide NAND.
+ * For now this only supports ARMv4 and ARMv5 cores.
+ *
+ * Enhancements to target_run_algorithm() could enable:
+ *   - faster writes: on ARMv5+ don't setup/teardown hardware breakpoint
+ *   - ARMv6 and ARMv7 cores in ARM mode
+ *
+ * Different code fragments could handle:
+ *   - Thumb2 cores like Cortex-M (needs different byteswapping)
+ *   - 16-bit wide data (needs different setup too)
+ */
+int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
+{
+	target_t		*target = nand->target;
+	armv4_5_algorithm_t	algo;
+	reg_param_t		reg_params[3];
+	uint32_t		target_buf;
+	int			retval;
+
+	/* Inputs:
+	 *  r0	NAND data address (byte wide)
+	 *  r1	buffer address
+	 *  r2	buffer length
+	 */
+	static const uint32_t code[] = {
+		0xe4d13001,	/* s: ldrb  r3, [r1], #1 */
+		0xe5c03000,	/*    strb  r3, [r0]     */
+		0xe2522001,	/*    subs  r2, r2, #1   */
+		0x1afffffb,	/*    bne   s            */
+
+		/* exit: ARMv4 needs hardware breakpoint */
+		0xe1200070,	/* e: bkpt  #0           */
+	};
+
+	if (!nand->copy_area) {
+		uint8_t		code_buf[sizeof(code)];
+		unsigned	i;
+
+		/* make sure we have a working area */
+		if (target_alloc_working_area(target,
+				sizeof(code) + nand->chunk_size,
+				&nand->copy_area) != ERROR_OK) {
+			LOG_DEBUG("%s: no %d byte buffer",
+					__FUNCTION__,
+					(int) sizeof(code) + nand->chunk_size);
+			return ERROR_NAND_NO_BUFFER;
+		}
+
+		/* buffer code in target endianness */
+		for (i = 0; i < sizeof(code) / 4; i++)
+			target_buffer_set_u32(target, code_buf + i * 4, code[i]);
+
+		/* copy code to work area */
+                retval = target_write_memory(target,
+					nand->copy_area->address,
+					4, sizeof(code) / 4, code_buf);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/* copy data to work area */
+	target_buf = nand->copy_area->address + sizeof(code);
+	retval = target_bulk_write_memory(target, target_buf, size / 4, data);
+	if (retval == ERROR_OK && (size & 3) != 0)
+		retval = target_write_memory(target,
+				target_buf + (size & ~3),
+				1, size & 3, data + (size & ~3));
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* set up algorithm and parameters */
+	algo.common_magic = ARMV4_5_COMMON_MAGIC;
+	algo.core_mode = ARMV4_5_MODE_SVC;
+	algo.core_state = ARMV4_5_STATE_ARM;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_IN);
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN);
+
+	buf_set_u32(reg_params[0].value, 0, 32, nand->data);
+	buf_set_u32(reg_params[1].value, 0, 32, target_buf);
+	buf_set_u32(reg_params[2].value, 0, 32, size);
+
+	/* use alg to write data from work area to NAND chip */
+	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
+			nand->copy_area->address,
+			nand->copy_area->address + sizeof(code) - 4,
+			1000, &algo);
+	if (retval != ERROR_OK)
+		LOG_ERROR("error executing hosted NAND write");
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+
+	return retval;
+}
+
+/* REVISIT do the same for bulk *read* too ... */
+


Property changes on: trunk/src/flash/arm_nandio.c
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/src/flash/arm_nandio.h
===================================================================
--- trunk/src/flash/arm_nandio.h	2009-09-02 17:34:35 UTC (rev 2662)
+++ trunk/src/flash/arm_nandio.h	2009-09-03 08:23:39 UTC (rev 2663)
@@ -0,0 +1,25 @@
+#ifndef __ARM_NANDIO_H
+#define  __ARM_NANDIO_H
+
+#include "nand.h"
+#include "binarybuffer.h"
+
+struct arm_nand_data {
+	/* target is proxy for some ARM core */
+	struct target_s		*target;
+
+	/* copy_area holds write-to-NAND loop and data to write */
+	struct working_area_s	*copy_area;
+
+	/* chunk_size == page or ECC unit */
+	unsigned		chunk_size;
+
+	/* data == where to write the data */
+	uint32_t		data;
+
+	/* currently implicit:  data width == 8 bits (not 16) */
+};
+
+int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size);
+
+#endif  /* __ARM_NANDIO_H */


Property changes on: trunk/src/flash/arm_nandio.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/flash/davinci_nand.c
===================================================================
--- trunk/src/flash/davinci_nand.c	2009-09-02 17:34:35 UTC (rev 2662)
+++ trunk/src/flash/davinci_nand.c	2009-09-03 08:23:39 UTC (rev 2663)
@@ -28,7 +28,7 @@
 #include "config.h"
 #endif
 
-#include "nand.h"
+#include "arm_nandio.h"
 
 
 enum ecc {
@@ -51,6 +51,9 @@
 	uint32_t		cmd;		/* with CLE */
 	uint32_t		addr;		/* with ALE */
 
+	/* write acceleration */
+	struct arm_nand_data	io;
+
 	/* page i/o for the relevant flavor of hardware ECC */
 	int (*read_page)(struct nand_device_s *nand, uint32_t page,
 			uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
@@ -181,7 +184,7 @@
 	return ERROR_OK;
 }
 
-/* REVISIT a bit of native code should let block I/O be MUCH faster */
+/* REVISIT a bit of native code should let block reads be MUCH faster */
 
 static int davinci_read_block_data(struct nand_device_s *nand,
 		uint8_t *data, int data_size)
@@ -223,10 +226,17 @@
 	target_t *target = info->target;
 	uint32_t nfdata = info->data;
 	uint32_t tmp;
+	int status;
 
 	if (!halted(target, "write_block"))
 		return ERROR_NAND_OPERATION_FAILED;
 
+	/* try the fast way first */
+	status = arm_nandwrite(&info->io, data, data_size);
+	if (status != ERROR_NAND_NO_BUFFER)
+		return status;
+
+	/* else do it slowly */
 	while (data_size >= 4) {
 		tmp = le_to_h_u32(data);
 		target_write_u32(target, nfdata, tmp);
@@ -285,6 +295,12 @@
 		memset(oob, 0x0ff, oob_size);
 	}
 
+	/* REVISIT avoid wasting SRAM:  unless nand->use_raw is set,
+	 * use 512 byte chunks.  Read side support will often want
+	 * to include oob_size ...
+	 */
+	info->io.chunk_size = nand->page_size;
+
 	status = info->write_page(nand, page, data, data_size, oob, oob_size);
 	free(ooballoc);
 	return status;
@@ -700,6 +716,9 @@
 
 	nand->controller_priv = info;
 
+	info->io.target = target;
+	info->io.data = info->data;
+
 	/* NOTE:  for now we don't do any error correction on read.
 	 * Nothing else in OpenOCD currently corrects read errors,
 	 * and in any case it's *writing* that we care most about.

Modified: trunk/src/flash/nand.h
===================================================================
--- trunk/src/flash/nand.h	2009-09-02 17:34:35 UTC (rev 2662)
+++ trunk/src/flash/nand.h	2009-09-03 08:23:39 UTC (rev 2663)
@@ -223,5 +223,6 @@
 #define		ERROR_NAND_OPERATION_NOT_SUPPORTED	(-1103)
 #define		ERROR_NAND_DEVICE_NOT_PROBED	(-1104)
 #define		ERROR_NAND_ERROR_CORRECTION_FAILED	(-1105)
+#define		ERROR_NAND_NO_BUFFER			(-1106)
 
 #endif /* NAND_H */

Modified: trunk/src/flash/orion_nand.c
===================================================================
--- trunk/src/flash/orion_nand.c	2009-09-02 17:34:35 UTC (rev 2662)
+++ trunk/src/flash/orion_nand.c	2009-09-03 08:23:39 UTC (rev 2663)
@@ -26,16 +26,16 @@
 #include "config.h"
 #endif
 
-#include "nand.h"
+#include "arm_nandio.h"
 #include "armv4_5.h"
-#include "binarybuffer.h"
 
 
 typedef struct orion_nand_controller_s
 {
 	struct target_s	*target;
-	working_area_t *copy_area;
 
+	struct arm_nand_data	io;
+
 	uint32_t		cmd;
 	uint32_t		addr;
 	uint32_t		data;
@@ -99,78 +99,14 @@
 static int orion_nand_fast_block_write(struct nand_device_s *device, uint8_t *data, int size)
 {
 	orion_nand_controller_t *hw = device->controller_priv;
-	target_t *target = hw->target;
-	armv4_5_algorithm_t algo;
-	reg_param_t reg_params[3];
-	uint32_t target_buf;
 	int retval;
 
-	static const uint32_t code[] = {
-		0xe4d13001,	/* ldrb	r3, [r1], #1	*/
-		0xe5c03000,	/* strb	r3, [r0]	*/
-		0xe2522001,	/* subs	r2, r2, #1	*/
-		0x1afffffb,	/* bne	0		*/
-		0xeafffffe,	/* b	.		*/
-	};
-	int code_size = sizeof(code);
+	hw->io.chunk_size = device->page_size;
 
-	if (!hw->copy_area) {
-		uint8_t code_buf[code_size];
-		int i;
+	retval = arm_nandwrite(&hw->io, data, size);
+	if (retval == ERROR_NAND_NO_BUFFER)
+		retval = orion_nand_slow_block_write(device, data, size);
 
-		/* make sure we have a working area */
-		if (target_alloc_working_area(target,
-					      code_size + device->page_size,
-					      &hw->copy_area) != ERROR_OK)
-		{
-			return orion_nand_slow_block_write(device, data, size);
-		}
-
-		/* copy target instructions to target endianness */
-		for (i = 0; i < code_size/4; i++)
-			target_buffer_set_u32(target, code_buf + i*4, code[i]);
-
-		/* write code to working area */
-                retval = target_write_memory(target,
-					hw->copy_area->address,
-					4, code_size/4, code_buf);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	/* copy data to target's memory */
-	target_buf = hw->copy_area->address + code_size;
-	retval = target_bulk_write_memory(target, target_buf, size/4, data);
-	if (retval == ERROR_OK && size & 3) {
-		retval = target_write_memory(target,
-					target_buf + (size & ~3),
-					1, size & 3, data + (size & ~3));
-	}
-	if (retval != ERROR_OK)
-		return retval;
-
-	algo.common_magic = ARMV4_5_COMMON_MAGIC;
-	algo.core_mode = ARMV4_5_MODE_SVC;
-	algo.core_state = ARMV4_5_STATE_ARM;
-
-	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN);
-	init_reg_param(&reg_params[1], "r1", 32, PARAM_IN);
-	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN);
-
-	buf_set_u32(reg_params[0].value, 0, 32, hw->data);
-	buf_set_u32(reg_params[1].value, 0, 32, target_buf);
-	buf_set_u32(reg_params[2].value, 0, 32, size);
-
-	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
-					hw->copy_area->address,
-					hw->copy_area->address + code_size - 4,
-					1000, &algo);
-	if (retval != ERROR_OK)
-		LOG_ERROR("error executing hosted NAND write");
-
-	destroy_reg_param(&reg_params[0]);
-	destroy_reg_param(&reg_params[1]);
-	destroy_reg_param(&reg_params[2]);
 	return retval;
 }
 
@@ -224,6 +160,9 @@
 	hw->cmd = base + (1 << cle);
 	hw->addr = base + (1 << ale);
 
+	hw->io.target = hw->target;
+	hw->io.data = hw->data;
+
 	return ERROR_OK;
 }
 



From oharboe at mail.berlios.de  Fri Sep  4 07:14:35 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 07:14:35 +0200
Subject: [Openocd-svn] r2664 - trunk/tcl/target
Message-ID: <200909040514.n845EZUT016843@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 07:14:32 +0200 (Fri, 04 Sep 2009)
New Revision: 2664

Modified:
   trunk/tcl/target/ar71xx.cfg
Log:
David Claffey <dnclaffey at gmail.com> get rid of reset recursion

Modified: trunk/tcl/target/ar71xx.cfg
===================================================================
--- trunk/tcl/target/ar71xx.cfg	2009-09-03 08:23:39 UTC (rev 2663)
+++ trunk/tcl/target/ar71xx.cfg	2009-09-04 05:14:32 UTC (rev 2664)
@@ -13,16 +13,17 @@
 set TARGETNAME [format "%s.cpu" $CHIPNAME]
 target create $TARGETNAME mips_m4k -endian big -chain-position $TARGETNAME
 
-$TARGETNAME configure -event reset-init {
+$TARGETNAME configure -event reset-halt-post {
 	#setup PLL to lowest common denominator 300/300/150 setting
 	mww 0xb8050000 0x000f40a3	# reset val + CPU:3 DDR:3 AHB:0
 	mww 0xb8050000 0x800f40a3	# send to PLL
 
 	#next command will reset for PLL changes to take effect
 	mww 0xb8050008 3		# set reset_switch and clock_switch (resets SoC)
-	reset halt     			# let openocd know that it is in the reset state
+}
 
-	#initialize_pll
+$TARGETNAME configure -event reset-init {
+	#complete pll initialization
 	mww 0xb8050000 0x800f0080	# set sw_update bit
 	mww 0xb8050008 0		# clear reset_switch bit
 	mww 0xb8050000 0x800f00e8       # clr pwrdwn & bypass



From oharboe at mail.berlios.de  Fri Sep  4 07:17:08 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 07:17:08 +0200
Subject: [Openocd-svn] r2665 - trunk/tcl/target
Message-ID: <200909040517.n845H8OK019708@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 07:17:03 +0200 (Fri, 04 Sep 2009)
New Revision: 2665

Modified:
   trunk/tcl/target/aduc702x.cfg
   trunk/tcl/target/at91eb40a.cfg
   trunk/tcl/target/at91r40008.cfg
   trunk/tcl/target/at91sam3uXX.cfg
   trunk/tcl/target/at91sam7sx.cfg
   trunk/tcl/target/at91sam9260.cfg
   trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
   trunk/tcl/target/c100.cfg
   trunk/tcl/target/cs351x.cfg
   trunk/tcl/target/epc9301.cfg
   trunk/tcl/target/feroceon.cfg
   trunk/tcl/target/imx21.cfg
   trunk/tcl/target/imx27.cfg
   trunk/tcl/target/imx31.cfg
   trunk/tcl/target/imx35.cfg
   trunk/tcl/target/is5114.cfg
   trunk/tcl/target/ixp42x.cfg
   trunk/tcl/target/lpc1768.cfg
   trunk/tcl/target/lpc2103.cfg
   trunk/tcl/target/lpc2124.cfg
   trunk/tcl/target/lpc2129.cfg
   trunk/tcl/target/lpc2148.cfg
   trunk/tcl/target/lpc2294.cfg
   trunk/tcl/target/lpc2378.cfg
   trunk/tcl/target/lpc2478.cfg
   trunk/tcl/target/mega128.cfg
   trunk/tcl/target/netx500.cfg
   trunk/tcl/target/pic32mx.cfg
   trunk/tcl/target/pxa270.cfg
   trunk/tcl/target/sam7se512.cfg
   trunk/tcl/target/sam7x256.cfg
   trunk/tcl/target/samsung_s3c2410.cfg
   trunk/tcl/target/samsung_s3c2440.cfg
   trunk/tcl/target/samsung_s3c2450.cfg
   trunk/tcl/target/samsung_s3c4510.cfg
   trunk/tcl/target/samsung_s3c6410.cfg
   trunk/tcl/target/sharp_lh79532.cfg
   trunk/tcl/target/smp8634.cfg
   trunk/tcl/target/stm32.cfg
   trunk/tcl/target/str710.cfg
   trunk/tcl/target/str730.cfg
   trunk/tcl/target/str750.cfg
   trunk/tcl/target/str912.cfg
   trunk/tcl/target/test_reset_syntax_error.cfg
   trunk/tcl/target/xba_revA3.cfg
Log:
David Brownell <david-b at pacbell.net> "set _TARGETNAME ..." cleanup

Modified: trunk/tcl/target/aduc702x.cfg
===================================================================
--- trunk/tcl/target/aduc702x.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/aduc702x.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -36,7 +36,7 @@
 ##
 ## Target configuration
 ##
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # allocate the entire SRAM as working area

Modified: trunk/tcl/target/at91eb40a.cfg
===================================================================
--- trunk/tcl/target/at91eb40a.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/at91eb40a.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -34,7 +34,7 @@
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 #target configuration
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 # speed up memory downloads

Modified: trunk/tcl/target/at91r40008.cfg
===================================================================
--- trunk/tcl/target/at91r40008.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/at91r40008.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -28,7 +28,8 @@
 #jtag scan chain
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 
 

Modified: trunk/tcl/target/at91sam3uXX.cfg
===================================================================
--- trunk/tcl/target/at91sam3uXX.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/at91sam3uXX.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -29,7 +29,7 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # 16K is plenty, the smallest chip has this much

Modified: trunk/tcl/target/at91sam7sx.cfg
===================================================================
--- trunk/tcl/target/at91sam7sx.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/at91sam7sx.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -21,7 +21,7 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 $_TARGETNAME configure -event reset-init { 

Modified: trunk/tcl/target/at91sam9260.cfg
===================================================================
--- trunk/tcl/target/at91sam9260.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/at91sam9260.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -35,7 +35,7 @@
 # Target configuration
 ######################
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
 
 # Internal sram1 memory

Modified: trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
===================================================================
--- trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -41,7 +41,7 @@
 # Target configuration
 ######################
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
 
 $_TARGETNAME invoke-event halted

Modified: trunk/tcl/target/c100.cfg
===================================================================
--- trunk/tcl/target/c100.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/c100.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -36,7 +36,7 @@
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
 jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # C100's ARAM 64k SRAM

Modified: trunk/tcl/target/cs351x.cfg
===================================================================
--- trunk/tcl/target/cs351x.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/cs351x.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -19,8 +19,9 @@
 jtag newtap $_CHIPNAME cpu  -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 # Create the GDB Target.
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME fa526 -endian $_ENDIAN -chain-position $_TARGETNAME -variant fa526
+
 # There is 16K of SRAM on this chip
 # FIXME: flash programming is not working by using this work area. So comment this out for now.
 #$_TARGETNAME configure -work-area-virt 0x00000000 -work-area-phys 0x00000000 -work-area-size  0x4000 -work-area-backup 1

Modified: trunk/tcl/target/epc9301.cfg
===================================================================
--- trunk/tcl/target/epc9301.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/epc9301.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -23,7 +23,7 @@
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -work-area-virt 0 -work-area-phys 0x80014000 -work-area-size 0x1000 -work-area-backup 1
 
 #flash configuration

Modified: trunk/tcl/target/feroceon.cfg
===================================================================
--- trunk/tcl/target/feroceon.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/feroceon.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -21,7 +21,8 @@
 }
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME feroceon -endian $_ENDIAN -chain-position $_TARGETNAME
 
 reset_config trst_and_srst

Modified: trunk/tcl/target/imx21.cfg
===================================================================
--- trunk/tcl/target/imx21.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/imx21.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -28,7 +28,7 @@
 
 
 # Create the GDB Target.
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
 
 arm7_9 dcc_downloads enable

Modified: trunk/tcl/target/imx27.cfg
===================================================================
--- trunk/tcl/target/imx27.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/imx27.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -38,7 +38,7 @@
 jtag newtap $_CHIPNAME cpu  -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 # Create the GDB Target.
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
 $_TARGETNAME configure -work-area-virt 0xffff4c00 -work-area-phys 0xffff4c00 -work-area-size  0x8000 -work-area-backup 1
 # Internal to the chip, there is 45K of SRAM

Modified: trunk/tcl/target/imx31.cfg
===================================================================
--- trunk/tcl/target/imx31.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/imx31.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -54,7 +54,7 @@
 # But this conflicts with Diagram 6-13, "3bits ir and drs"
 jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_SDMATAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 

Modified: trunk/tcl/target/imx35.cfg
===================================================================
--- trunk/tcl/target/imx35.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/imx35.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -43,7 +43,7 @@
 
 jtag newtap $_CHIPNAME smda -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_SDMATAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 proc power_restore {} { puts "Sensed power restore. No action." } 

Modified: trunk/tcl/target/is5114.cfg
===================================================================
--- trunk/tcl/target/is5114.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/is5114.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -38,7 +38,7 @@
 
 
 #arm946e-s and 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm966e -endian $_ENDIAN  -chain-position $_TARGETNAME  -variant arm966e
 
 $_TARGETNAME configure -event reset-start { jtag_rclk 16 }

Modified: trunk/tcl/target/ixp42x.cfg
===================================================================
--- trunk/tcl/target/ixp42x.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/ixp42x.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -27,6 +27,6 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME xscale -endian $_ENDIAN -chain-position $_TARGETNAME -variant ixp42x
 

Modified: trunk/tcl/target/lpc1768.cfg
===================================================================
--- trunk/tcl/target/lpc1768.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc1768.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -27,7 +27,7 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # LPC1768 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)

Modified: trunk/tcl/target/lpc2103.cfg
===================================================================
--- trunk/tcl/target/lpc2103.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc2103.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -27,8 +27,7 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 # 8kB of internal SRAM

Modified: trunk/tcl/target/lpc2124.cfg
===================================================================
--- trunk/tcl/target/lpc2124.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc2124.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -32,7 +32,7 @@
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0

Modified: trunk/tcl/target/lpc2129.cfg
===================================================================
--- trunk/tcl/target/lpc2129.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc2129.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -32,7 +32,7 @@
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0

Modified: trunk/tcl/target/lpc2148.cfg
===================================================================
--- trunk/tcl/target/lpc2148.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc2148.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -32,8 +32,7 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
-
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0

Modified: trunk/tcl/target/lpc2294.cfg
===================================================================
--- trunk/tcl/target/lpc2294.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc2294.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -26,7 +26,7 @@
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 

Modified: trunk/tcl/target/lpc2378.cfg
===================================================================
--- trunk/tcl/target/lpc2378.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc2378.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -27,7 +27,7 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 # LPC2378 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)

Modified: trunk/tcl/target/lpc2478.cfg
===================================================================
--- trunk/tcl/target/lpc2478.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/lpc2478.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -27,7 +27,7 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 # LPC2478 has 64kB of SRAM on its main system bus (so-called Local On-Chip SRAM)

Modified: trunk/tcl/target/mega128.cfg
===================================================================
--- trunk/tcl/target/mega128.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/mega128.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -17,7 +17,7 @@
 }
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME avr -endian $_ENDIAN -chain-position $_TARGETNAME
 
 #$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x20000000 -work-area-size 16384 -work-area-backup 0

Modified: trunk/tcl/target/netx500.cfg
===================================================================
--- trunk/tcl/target/netx500.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/netx500.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -29,6 +29,6 @@
 jtag_nsrst_delay 100
 jtag_ntrst_delay 100
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
 

Modified: trunk/tcl/target/pic32mx.cfg
===================================================================
--- trunk/tcl/target/pic32mx.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/pic32mx.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -28,7 +28,7 @@
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME mips_m4k -endian $_ENDIAN -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0xa0000000 -work-area-size 16384 -work-area-backup 0

Modified: trunk/tcl/target/pxa270.cfg
===================================================================
--- trunk/tcl/target/pxa270.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/pxa270.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -30,7 +30,7 @@
 # the rest of the needed delays are built into the openocd program
 jtag_ntrst_delay 0
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID
 
 target create $_TARGETNAME xscale -endian $_ENDIAN -chain-position $_TARGETNAME -variant pxa27x

Modified: trunk/tcl/target/sam7se512.cfg
===================================================================
--- trunk/tcl/target/sam7se512.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/sam7se512.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -29,7 +29,7 @@
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 # The target
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

Modified: trunk/tcl/target/sam7x256.cfg
===================================================================
--- trunk/tcl/target/sam7x256.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/sam7x256.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -21,9 +21,9 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 $_TARGETNAME configure -event reset-init { 
 	# disable watchdog
 	mww 0xfffffd44 0x00008000	

Modified: trunk/tcl/target/samsung_s3c2410.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c2410.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/samsung_s3c2410.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -25,7 +25,7 @@
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm920t
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x30800000 -work-area-size 0x20000 -work-area-backup 0

Modified: trunk/tcl/target/samsung_s3c2440.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c2440.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/samsung_s3c2440.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -26,8 +26,9 @@
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm920t
+
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x200000 -work-area-size 0x4000 -work-area-backup 1
 
 #reset configuration

Modified: trunk/tcl/target/samsung_s3c2450.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c2450.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/samsung_s3c2450.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -36,7 +36,7 @@
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0xE -irmask 0x0f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
 
 # FIX!!!!! should this really use srst_pulls_trst?
@@ -46,4 +46,4 @@
 # However, without "srst_pulls_trst", then "reset halt" produces weird
 # errors:
 # WARNING: unknown debug reason: 0x0
-reset_config trst_and_srst
\ No newline at end of file
+reset_config trst_and_srst

Modified: trunk/tcl/target/samsung_s3c4510.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c4510.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/samsung_s3c4510.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -20,6 +20,6 @@
 }
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME  
 

Modified: trunk/tcl/target/samsung_s3c6410.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c6410.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/samsung_s3c6410.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -39,7 +39,7 @@
 jtag newtap $_CHIPNAME unknown -irlen 4 -ircapture 0x1 -irmask 0xe  -expected-id $_BSTAPID
 jtag newtap $_CHIPNAME cpu     -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm11 -endian $_ENDIAN  -chain-position $_TARGETNAME -variant arm1176
 
 jtag_nsrst_delay 500

Modified: trunk/tcl/target/sharp_lh79532.cfg
===================================================================
--- trunk/tcl/target/sharp_lh79532.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/sharp_lh79532.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -20,7 +20,7 @@
 }
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME  
 
 

Modified: trunk/tcl/target/smp8634.cfg
===================================================================
--- trunk/tcl/target/smp8634.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/smp8634.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -28,5 +28,5 @@
 # format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 jtag newtap $_CHIPNAME cpu -irlen 5  -ircapture 0x1 -irmask 0x1
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME mips_m4k -endian $_ENDIAN -variant

Modified: trunk/tcl/target/stm32.cfg
===================================================================
--- trunk/tcl/target/stm32.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/stm32.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -57,7 +57,7 @@
 }   
 jtag newtap $_CHIPNAME bs  -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID1 -expected-id $_BSTAPID2 -expected-id $_BSTAPID3 -expected-id $_BSTAPID4 -expected-id $_BSTAPID5
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

Modified: trunk/tcl/target/str710.cfg
===================================================================
--- trunk/tcl/target/str710.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/str710.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -26,8 +26,9 @@
 
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
+
 $_TARGETNAME configure -event reset-start { jtag_khz 10 }
 $_TARGETNAME configure -event reset-init { jtag_khz 6000 }
 $_TARGETNAME configure -event gdb-flash-erase-start {

Modified: trunk/tcl/target/str730.cfg
===================================================================
--- trunk/tcl/target/str730.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/str730.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -31,8 +31,9 @@
 jtag_nsrst_delay 500
 jtag_ntrst_delay 500
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
+
 $_TARGETNAME configure -event reset-start { jtag_khz 10 }
 $_TARGETNAME configure -event reset-init { jtag_khz 3000 }
 $_TARGETNAME configure -event gdb-flash-erase-start {

Modified: trunk/tcl/target/str750.cfg
===================================================================
--- trunk/tcl/target/str750.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/str750.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -33,7 +33,7 @@
 jtag_nsrst_delay 500
 jtag_ntrst_delay 500
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
 
 $_TARGETNAME configure -event reset-start  { jtag_khz 10 }

Modified: trunk/tcl/target/str912.cfg
===================================================================
--- trunk/tcl/target/str912.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/str912.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -43,7 +43,7 @@
 }
 jtag newtap $_CHIPNAME bs    -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm966e -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm966e
 
 $_TARGETNAME configure -event reset-start { jtag_rclk 16 }

Modified: trunk/tcl/target/test_reset_syntax_error.cfg
===================================================================
--- trunk/tcl/target/test_reset_syntax_error.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/test_reset_syntax_error.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -8,7 +8,7 @@
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf 
 
 #target configuration
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 $_TARGETNAME configure -event reset-init { 

Modified: trunk/tcl/target/xba_revA3.cfg
===================================================================
--- trunk/tcl/target/xba_revA3.cfg	2009-09-04 05:14:32 UTC (rev 2664)
+++ trunk/tcl/target/xba_revA3.cfg	2009-09-04 05:17:03 UTC (rev 2665)
@@ -28,8 +28,9 @@
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 7 -ircapture 0x1 -irmask 0x7f -expected-id $_CPUTAPID
 
-set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME xscale -endian $_ENDIAN -chain-position $_TARGETNAME -variant ixp42x
+
 $_TARGETNAME configure -event reset-init {
 	#############################################################################
 	# setup expansion bus CS, disable external wdt



From oharboe at mail.berlios.de  Fri Sep  4 07:20:47 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 07:20:47 +0200
Subject: [Openocd-svn] r2666 - trunk/src/target
Message-ID: <200909040520.n845KlsB024668@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 07:20:45 +0200 (Fri, 04 Sep 2009)
New Revision: 2666

Modified:
   trunk/src/target/cortex_a8.c
   trunk/src/target/cortex_a8.h
Log:
Matt Hsu <matt at 0xlab.org> Tidy up the bit-offset operation for DSCR register



Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-04 05:17:03 UTC (rev 2665)
+++ trunk/src/target/cortex_a8.c	2009-09-04 05:20:45 UTC (rev 2666)
@@ -166,7 +166,7 @@
 		retvalue = mem_ap_read_atomic_u32(swjdp,
 				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
 	}
-	while ((dscr & (1 << 24)) == 0); /* Wait for InstrCompl bit to be set */
+	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0); /* Wait for InstrCompl bit to be set */
 
 	mem_ap_write_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_ITR, opcode);
 
@@ -175,7 +175,7 @@
 		retvalue = mem_ap_read_atomic_u32(swjdp,
 				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
 	}
-	while ((dscr & (1 << 24)) == 0); /* Wait for InstrCompl bit to be set */
+	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0); /* Wait for InstrCompl bit to be set */
 
 	return retvalue;
 }
@@ -291,7 +291,7 @@
 		retval = mem_ap_read_atomic_u32(swjdp,
 				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
 	}
-	while ((dscr & (1 << 29)) == 0); /* Wait for DTRRXfull */
+	while ((dscr & (1 << DSCR_DTR_TX_FULL)) == 0); /* Wait for DTRRXfull */
 
 	retval = mem_ap_read_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
@@ -436,7 +436,7 @@
 	do {
 		mem_ap_read_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
-	} while ((dscr & (1 << 0)) == 0);
+	} while ((dscr & (1 << DSCR_CORE_HALTED)) == 0);
 
 	target->debug_reason = DBG_REASON_DBGRQ;
 
@@ -535,7 +535,7 @@
 	do {
 		mem_ap_read_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
-	} while ((dscr & (1 << 1)) == 0);
+	} while ((dscr & (1 << DSCR_CORE_RESTARTED)) == 0);
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
 	target->state = TARGET_RUNNING;
@@ -582,7 +582,7 @@
 	/* Enable the ITR execution once we are in debug mode */
 	mem_ap_read_atomic_u32(swjdp,
 				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
-	dscr |= (1 << 13);
+	dscr |= (1 << DSCR_EXT_INT_EN);
 	retval = mem_ap_write_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, dscr);
 

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-09-04 05:17:03 UTC (rev 2665)
+++ trunk/src/target/cortex_a8.h	2009-09-04 05:20:45 UTC (rev 2666)
@@ -67,6 +67,15 @@
 #define BRP_NORMAL 0
 #define BRP_CONTEXT 1
 
+/* DSCR Bit offset */
+#define DSCR_CORE_HALTED		0
+#define DSCR_CORE_RESTARTED 	1
+#define DSCR_EXT_INT_EN 		13
+#define DSCR_HALT_DBG_MODE		14
+#define DSCR_MON_DBG_MODE 		15
+#define DSCR_INSTR_COMP 		24
+#define DSCR_DTR_TX_FULL 		29
+
 typedef struct  cortex_a8_brp_s
 {
 	int used;



From oharboe at mail.berlios.de  Fri Sep  4 10:21:19 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 10:21:19 +0200
Subject: [Openocd-svn] r2667 - trunk/src/target
Message-ID: <200909040821.n848LJ4U007019@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 10:21:18 +0200 (Fri, 04 Sep 2009)
New Revision: 2667

Modified:
   trunk/src/target/arm7_9_common.c
Log:
more debug output for breakpoints

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-09-04 05:20:45 UTC (rev 2666)
+++ trunk/src/target/arm7_9_common.c	2009-09-04 08:21:18 UTC (rev 2667)
@@ -228,9 +228,10 @@
 	arm7_9_common_t *arm7_9 = armv4_5->arch_info;
 	int retval = ERROR_OK;
 
-	LOG_DEBUG("BPID: %d, Address: 0x%08" PRIx32,
+	LOG_DEBUG("BPID: %d, Address: 0x%08" PRIx32 ", Type: %d" ,
 			  breakpoint->unique_id,
-			  breakpoint->address );
+			  breakpoint->address,
+			  breakpoint->type);
 
 	if (target->state != TARGET_HALTED)
 	{
@@ -1187,6 +1188,13 @@
 	int i;
 	int retval;
 
+	/* FIX!!! replace some of this code with tcl commands
+	 *
+	 * halt # the halt command is synchronous
+	 * armv4_5 core_state arm
+	 *
+	 */
+
 	if ((retval = target_halt(target)) != ERROR_OK)
 		return retval;
 



From oharboe at mail.berlios.de  Fri Sep  4 10:22:02 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 10:22:02 +0200
Subject: [Openocd-svn] r2668 - trunk/src/target
Message-ID: <200909040822.n848M29K007551@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 10:22:02 +0200 (Fri, 04 Sep 2009)
New Revision: 2668

Modified:
   trunk/src/target/cortex_a8.c
Log:
Matt Hsu <matt at 0xlab.org> This patch simply enables the halting debug mode.
By enabling this bit, the processor halts when a debug event
such as breakpoint occurs.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-04 08:21:18 UTC (rev 2667)
+++ trunk/src/target/cortex_a8.c	2009-09-04 08:22:02 UTC (rev 2668)
@@ -430,6 +430,13 @@
 	retval = mem_ap_write_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DRCR, 0x1);
 
+	/*
+	 * enter halting debug mode
+	 */
+	mem_ap_read_atomic_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	retval = mem_ap_write_atomic_u32(swjdp,
+		OMAP3530_DEBUG_BASE + CPUDBG_DSCR, dscr | (1 << DSCR_HALT_DBG_MODE));
+
 	if (retval != ERROR_OK)
 		goto out;
 



From oharboe at mail.berlios.de  Fri Sep  4 10:23:25 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 10:23:25 +0200
Subject: [Openocd-svn] r2669 - trunk/tcl/target
Message-ID: <200909040823.n848NPPZ008342@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 10:23:24 +0200 (Fri, 04 Sep 2009)
New Revision: 2669

Modified:
   trunk/tcl/target/lpc2478.cfg
Log:
set ARM mode using explicit command rather than soft_reset_halt which has lots of side effects.

Modified: trunk/tcl/target/lpc2478.cfg
===================================================================
--- trunk/tcl/target/lpc2478.cfg	2009-09-04 08:22:02 UTC (rev 2668)
+++ trunk/tcl/target/lpc2478.cfg	2009-09-04 08:23:24 UTC (rev 2669)
@@ -35,7 +35,7 @@
 
 $_TARGETNAME configure -event reset-init {
 	# Force target into ARM state
-	soft_reset_halt
+	armv4_5 core_state arm
 	# Do not remap 0x0000-0x0020 to anything but the Flash
 	mwb 0xE01FC040 0x01
 }



From oharboe at mail.berlios.de  Fri Sep  4 10:27:10 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 10:27:10 +0200
Subject: [Openocd-svn] r2670 - trunk/tcl/board
Message-ID: <200909040827.n848RATd012974@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 10:27:08 +0200 (Fri, 04 Sep 2009)
New Revision: 2670

Modified:
   trunk/tcl/board/ti_beagleboard.cfg
Log:
Dirk Behme <dirk.behme at googlemail.com> Add default fall back freqency.

 

Modified: trunk/tcl/board/ti_beagleboard.cfg
===================================================================
--- trunk/tcl/board/ti_beagleboard.cfg	2009-09-04 08:23:24 UTC (rev 2669)
+++ trunk/tcl/board/ti_beagleboard.cfg	2009-09-04 08:27:08 UTC (rev 2670)
@@ -1,6 +1,9 @@
 # OMAP3 BeagleBoard
 #  http://beagleboard.org
 
+# Fall back to 6MHz if RTCK is not supported
+jtag_rclk 6000
+
 source [find target/omap3530.cfg]
 
 # TI-14 JTAG connector



From oharboe at mail.berlios.de  Fri Sep  4 10:27:29 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 10:27:29 +0200
Subject: [Openocd-svn] r2671 - trunk/tcl/interface
Message-ID: <200909040827.n848RTKu013010@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 10:27:27 +0200 (Fri, 04 Sep 2009)
New Revision: 2671

Modified:
   trunk/tcl/interface/flyswatter.cfg
Log:
Dirk Behme <dirk.behme at googlemail.com> retire jtag_speed usage

Modified: trunk/tcl/interface/flyswatter.cfg
===================================================================
--- trunk/tcl/interface/flyswatter.cfg	2009-09-04 08:27:08 UTC (rev 2670)
+++ trunk/tcl/interface/flyswatter.cfg	2009-09-04 08:27:27 UTC (rev 2671)
@@ -8,5 +8,3 @@
 ft2232_device_desc "Flyswatter"
 ft2232_layout "flyswatter"
 ft2232_vid_pid 0x0403 0x6010
-jtag_speed 1
-



From oharboe at mail.berlios.de  Fri Sep  4 13:03:29 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 13:03:29 +0200
Subject: [Openocd-svn] r2672 - trunk/tcl/target
Message-ID: <200909041103.n84B3T4F028320@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 13:03:26 +0200 (Fri, 04 Sep 2009)
New Revision: 2672

Modified:
   trunk/tcl/target/lpc1768.cfg
   trunk/tcl/target/lpc2148.cfg
   trunk/tcl/target/lpc2378.cfg
Log:
use "armv4_5 core_state arm" instead of soft_reset_halt, fewer side effects

Modified: trunk/tcl/target/lpc1768.cfg
===================================================================
--- trunk/tcl/target/lpc1768.cfg	2009-09-04 08:27:27 UTC (rev 2671)
+++ trunk/tcl/target/lpc1768.cfg	2009-09-04 11:03:26 UTC (rev 2672)
@@ -34,7 +34,8 @@
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x10000000 -work-area-size 0x8000 -work-area-backup 0
 
 $_TARGETNAME configure -event reset-init {
-	soft_reset_halt
+	# Force target into ARM state
+	armv4_5 core_state arm
 	#do not remap 0x0000-0x0020 to anything but the flash
 #	mwb 0xE01FC040 0x01
 	mwb 0xE000ED08 0x00

Modified: trunk/tcl/target/lpc2148.cfg
===================================================================
--- trunk/tcl/target/lpc2148.cfg	2009-09-04 08:27:27 UTC (rev 2671)
+++ trunk/tcl/target/lpc2148.cfg	2009-09-04 11:03:26 UTC (rev 2672)
@@ -38,8 +38,8 @@
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
 $_TARGETNAME configure -event reset-init {
-	# Force target into ARM state.
-	soft_reset_halt
+	# Force target into ARM state
+	armv4_5 core_state arm
 
 	# Do not remap 0x0000-0x0020 to anything but the flash (i.e. select
 	# "User Flash Mode" where interrupt vectors are _not_ remapped,

Modified: trunk/tcl/target/lpc2378.cfg
===================================================================
--- trunk/tcl/target/lpc2378.cfg	2009-09-04 08:27:27 UTC (rev 2671)
+++ trunk/tcl/target/lpc2378.cfg	2009-09-04 11:03:26 UTC (rev 2672)
@@ -35,7 +35,7 @@
 
 $_TARGETNAME configure -event reset-init {
 	# Force target into ARM state
-	soft_reset_halt
+	armv4_5 core_state arm
 	#do not remap 0x0000-0x0020 to anything but the flash
 	mwb 0xE01FC040 0x01
 }



From oharboe at mail.berlios.de  Fri Sep  4 21:35:11 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 4 Sep 2009 21:35:11 +0200
Subject: [Openocd-svn] r2673 - trunk/src/target
Message-ID: <200909041935.n84JZBvd027514@sheep.berlios.de>

Author: oharboe
Date: 2009-09-04 21:35:10 +0200 (Fri, 04 Sep 2009)
New Revision: 2673

Modified:
   trunk/src/target/mips_m4k.c
Log:
Mahr, Stefan <Stefan.Mahr at sphairon.com> removes the endianness swapping in mips_m4k.c Swapping is already done in target.c

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-09-04 11:03:26 UTC (rev 2672)
+++ trunk/src/target/mips_m4k.c	2009-09-04 19:35:10 UTC (rev 2673)
@@ -874,28 +874,6 @@
 	if (ERROR_OK != retval)
 		return retval;
 
-	/* TAP data register is loaded LSB first (little endian) */
-	if (target->endianness == TARGET_BIG_ENDIAN)
-	{
-		uint32_t i, t32;
-		uint16_t t16;
-
-		for (i = 0; i < (count*size); i += size)
-		{
-			switch (size)
-			{
-				case 4:
-					t32 = le_to_h_u32(&buffer[i]);
-					h_u32_to_be(&buffer[i], t32);
-					break;
-				case 2:
-					t16 = le_to_h_u16(&buffer[i]);
-					h_u16_to_be(&buffer[i], t16);
-					break;
-			}
-		}
-	}
-
 	return ERROR_OK;
 }
 
@@ -919,28 +897,6 @@
 	if (((size == 4) && (address & 0x3u)) || ((size == 2) && (address & 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
-	/* TAP data register is loaded LSB first (little endian) */
-	if (target->endianness == TARGET_BIG_ENDIAN)
-	{
-		uint32_t i, t32;
-		uint16_t t16;
-
-		for (i = 0; i < (count*size); i += size)
-		{
-			switch (size)
-			{
-				case 4:
-					t32 = be_to_h_u32(&buffer[i]);
-					h_u32_to_le(&buffer[i], t32);
-					break;
-				case 2:
-					t16 = be_to_h_u16(&buffer[i]);
-					h_u16_to_le(&buffer[i], t16);
-					break;
-			}
-		}
-	}
-
 	/* if noDMA off, use DMAACC mode for memory write */
 	if (ejtag_info->impcode & EJTAG_IMP_NODMA)
 		return mips32_pracc_write_mem(ejtag_info, address, size, count, (void *)buffer);



From mlu at mail.berlios.de  Mon Sep  7 22:19:37 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Mon, 7 Sep 2009 22:19:37 +0200
Subject: [Openocd-svn] r2674 - trunk/src/target
Message-ID: <200909072019.n87KJbMl003867@sheep.berlios.de>

Author: mlu
Date: 2009-09-07 22:19:17 +0200 (Mon, 07 Sep 2009)
New Revision: 2674

Modified:
   trunk/src/target/cortex_a8.c
Log:
Improved handling of instruction set state, helps for debugging Thumb state.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-04 19:35:10 UTC (rev 2673)
+++ trunk/src/target/cortex_a8.c	2009-09-07 20:19:17 UTC (rev 2674)
@@ -458,7 +458,6 @@
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	armv7a_common_t *armv7a = armv4_5->arch_info;
-	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
 	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
 //	breakpoint_t *breakpoint = NULL;
@@ -506,7 +505,7 @@
 	/* Make sure that the Armv7 gdb thumb fixups does not
 	 * kill the return address
 	 */
-	if (!(cortex_a8->cpudbg_dscr & (1 << 5)))
+	if (armv7a->core_state == ARMV7A_STATE_ARM)
 	{
 		resume_pc &= 0xFFFFFFFC;
 	}
@@ -638,7 +637,8 @@
 	dap_ap_select(swjdp, swjdp_debugap);
 	LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
 
-	armv4_5->core_mode = cpsr & 0x3F;
+	armv4_5->core_mode = cpsr & 0x1F;
+	armv7a->core_state = (cpsr & 0x20)?ARMV7A_STATE_THUMB:ARMV7A_STATE_ARM;
 
 	for (i = 0; i <= ARM_PC; i++)
 	{
@@ -657,8 +657,7 @@
 	ARMV7A_CORE_REG_MODE(armv4_5->core_cache, armv4_5->core_mode, 16).dirty = 0;
 
 	/* Fixup PC Resume Address */
-	/* TODO Her we should use arch->core_state */
-	if (cortex_a8->cpudbg_dscr & (1 << 5))
+	if (armv7a->core_state == ARMV7A_STATE_THUMB)
 	{
 		// T bit set for Thumb or ThumbEE state
 		regfile[ARM_PC] -= 4;
@@ -743,7 +742,6 @@
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	armv7a_common_t *armv7a = armv4_5->arch_info;
-	cortex_a8_common_t *cortex_a8 = armv7a->arch_info;
 	breakpoint_t *breakpoint = NULL;
 	breakpoint_t stepbreakpoint;
 
@@ -785,7 +783,7 @@
 
 	/* Setup single step breakpoint */
 	stepbreakpoint.address = address;
-	stepbreakpoint.length = (cortex_a8->cpudbg_dscr & (1 << 5)) ? 2 : 4;
+	stepbreakpoint.length = (armv7a->core_state == ARMV7A_STATE_THUMB) ? 2 : 4;
 	stepbreakpoint.type = BKPT_HARD;
 	stepbreakpoint.set = 0;
 



From oharboe at mail.berlios.de  Tue Sep  8 08:17:34 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 8 Sep 2009 08:17:34 +0200
Subject: [Openocd-svn] r2675 - trunk/src/target
Message-ID: <200909080617.n886HYrc010212@sheep.berlios.de>

Author: oharboe
Date: 2009-09-08 08:17:33 +0200 (Tue, 08 Sep 2009)
New Revision: 2675

Modified:
   trunk/src/target/arm_disassembler.c
Log:
David Brownell <david-b at pacbell.net> 
lean up some loose ends with the ARM disassembler

 - Add a header comment describing its current state and uses
   and referencing the now-generally-available V7 arch spec

 - Support some mode switch instructions:
    * Thumb to Jazelle (BXJ)
    * Thumb to ThumbEE (ENTERX)
    * ThumbEE to Thumb (LEAVEX)

 - Improve that recent warning fix (and associated whitespace goof)

 - Declare the rest of the internal code and data "static".  A
   compiler may use this, and it helps clarify the scope of these
   routines (e.g. what changes to them could affect).


Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-09-07 20:19:17 UTC (rev 2674)
+++ trunk/src/target/arm_disassembler.c	2009-09-08 06:17:33 UTC (rev 2675)
@@ -28,20 +28,86 @@
 #include "log.h"
 
 
+/*
+ * This disassembler supports two main functions for OpenOCD:
+ *
+ *  - Various "disassemble" commands.  OpenOCD can serve as a
+ *    machine-language debugger, without help from GDB.
+ *
+ *  - Single stepping.  Not all ARM cores support hardware single
+ *    stepping.  To work without that support, the debugger must
+ *    be able to decode instructions to find out where to put a
+ *    "next instruction" breakpoint.
+ *
+ * In addition, interpretation of ETM trace data needs some of the
+ * decoding mechanisms.
+ *
+ * At this writing (September 2009) neither function is complete.
+ *
+ *  - ARM decoding
+ *     * Old-style syntax (not UAL) is generally used
+ *     * VFP instructions are not understood (ARMv5 and later)
+ *       except as coprocessor 10/11 operations
+ *     * Most ARM instructions through ARMv6 are decoded, but some
+ *       of the post-ARMv4 opcodes may not be handled yet
+ *     * NEON instructions are not understood (ARMv7-A)
+ *
+ *  - Thumb/Thumb2 decoding
+ *     * UAL syntax should be consistently used
+ *     * Any Thumb2 instructions used in Cortex-M3 (ARMv7-M) should
+ *       be handled properly.  Accordingly, so should the subset
+ *       used in Cortex-M0/M1; and "original" 16-bit Thumb from
+ *       ARMv4T and ARMv5T.
+ *     * Conditional effects of Thumb2 "IT" (if-then) instructions
+ *       are not handled:  the affected instructions are not shown
+ *       with their now-conditional suffixes.
+ *     * Some ARMv6 and ARMv7-M Thumb2 instructions may not be
+ *       handled (minimally for coprocessor access).
+ *     * SIMD instructions, and some other Thumb2 instructions
+ *       from ARMv7-A, are not understood.
+ *
+ *  - ThumbEE decoding
+ *     * As a Thumb2 variant, the Thumb2 comments (above) apply.
+ *     * Opcodes changed by ThumbEE mode are not handled; these
+ *       instructions wrongly decode as LDM and STM.
+ *
+ *  - Jazelle decoding ...  no support whatsoever for Jazelle mode
+ *    or decoding.  ARM encourages use of the more generic ThumbEE
+ *    mode, instead of Jazelle mode, in current chips.
+ *
+ *  - Single-step/emulation ... spotty support, which is only weakly
+ *    tested.  Thumb2 is not supported.  (Arguably a full simulator
+ *    is not needed to support just single stepping.  Recognizing
+ *    branch vs non-branch instructions suffices, except when the
+ *    instruction faults and triggers a synchronous exception which
+ *    can be intercepted using other means.)
+ *
+ * ARM DDI 0406B "ARM Architecture Reference Manual, ARM v7-A and
+ * ARM v7-R edition" gives the most complete coverage of the various
+ * generations of ARM instructions.  At this writing it is publicly
+ * accessible to anyone willing to create an account at the ARM
+ * web site; see http://www.arm.com/documentation/ for information.
+ *
+ * ARM DDI 0403C "ARMv7-M Architecture Reference Manual" provides
+ * more details relevant to the Thumb2-only processors (such as
+ * the Cortex-M implementations).
+ */
+
 /* textual represenation of the condition field */
 /* ALways (default) is ommitted (empty string) */
-char *arm_condition_strings[] =
+static const char *arm_condition_strings[] =
 {
 	"EQ", "NE", "CS", "CC", "MI", "PL", "VS", "VC", "HI", "LS", "GE", "LT", "GT", "LE", "", "NV"
 };
 
 /* make up for C's missing ROR */
-uint32_t ror(uint32_t value, int places)
+static uint32_t ror(uint32_t value, int places)
 {
 	return (value >> places) | (value << (32 - places));
 }
 
-int evaluate_pld(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_pld(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	/* PLD */
 	if ((opcode & 0x0d70f0000) == 0x0550f000)
@@ -62,7 +128,8 @@
 	return -1;
 }
 
-int evaluate_swi(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_swi(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	instruction->type = ARM_SWI;
 
@@ -73,7 +140,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_blx_imm(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_blx_imm(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	int offset;
 	uint32_t immediate;
@@ -105,7 +173,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_b_bl(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_b_bl(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t L;
 	uint32_t immediate;
@@ -142,7 +211,8 @@
 
 /* Coprocessor load/store and double register transfers */
 /* both normal and extended instruction space (condition field b1111) */
-int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t cp_num = (opcode & 0xf00) >> 8;
 
@@ -222,9 +292,10 @@
 /* Coprocessor data processing instructions */
 /* Coprocessor register transfer instructions */
 /* both normal and extended instruction space (condition field b1111) */
-int evaluate_cdp_mcr_mrc(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_cdp_mcr_mrc(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
-	char* cond;
+	const char *cond;
 	char* mnemonic;
 	uint8_t cp_num, opcode_1, CRd_Rd, CRn, CRm, opcode_2;
 
@@ -271,7 +342,8 @@
 }
 
 /* Load/store instructions */
-int evaluate_load_store(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_load_store(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t I, P, U, B, W, L;
 	uint8_t Rn, Rd;
@@ -445,9 +517,6 @@
 	unsigned rn = (opcode >> 16) & 0xf;
 	char *type, *rot;
 
-	/* GCC 'uninitialized warning removal' */
-	type = rot = NULL;
-	
 	switch ((opcode >> 24) & 0x3) {
 	case 0:
 		type = "B16";
@@ -458,7 +527,7 @@
 	case 2:
 		type = "B";
 		break;
-	case 3:
+	default:
 		type = "H";
 		break;
 	}
@@ -473,7 +542,7 @@
 	case 2:
 		rot = ", ROR #16";
 		break;
-	case 3:
+	default:
 		rot = ", ROR #24";
 		break;
 	}
@@ -759,7 +828,8 @@
 }
 
 /* Miscellaneous load/store instructions */
-int evaluate_misc_load_store(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_misc_load_store(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t P, U, I, W, L, S, H;
 	uint8_t Rn, Rd;
@@ -886,7 +956,8 @@
 }
 
 /* Load/store multiples instructions */
-int evaluate_ldm_stm(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_ldm_stm(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t P, U, S, W, L, Rn;
 	uint32_t register_list;
@@ -974,7 +1045,8 @@
 }
 
 /* Multiplies, extra load/stores */
-int evaluate_mul_and_extra_ld_st(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_mul_and_extra_ld_st(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	/* Multiply (accumulate) (long) and Swap/swap byte */
 	if ((opcode & 0x000000f0) == 0x00000090)
@@ -1065,7 +1137,8 @@
 	return evaluate_misc_load_store(opcode, address, instruction);
 }
 
-int evaluate_mrs_msr(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_mrs_msr(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	int R = (opcode & 0x00400000) >> 22;
 	char *PSR = (R) ? "SPSR" : "CPSR";
@@ -1119,7 +1192,8 @@
 }
 
 /* Miscellaneous instructions */
-int evaluate_misc_instr(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_misc_instr(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	/* MRS/MSR */
 	if ((opcode & 0x000000f0) == 0x00000000)
@@ -1309,7 +1383,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_data_proc(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_data_proc(uint32_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t I, op, S, Rn, Rd;
 	char *mnemonic = NULL;
@@ -1668,7 +1743,8 @@
 	return -1;
 }
 
-int evaluate_b_bl_blx_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_b_bl_blx_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t offset = opcode & 0x7ff;
 	uint32_t opc = (opcode >> 11) & 0x3;
@@ -1721,7 +1797,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_add_sub_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_add_sub_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t Rd = (opcode >> 0) & 0x7;
 	uint8_t Rn = (opcode >> 3) & 0x7;
@@ -1766,7 +1843,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_shift_imm_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_shift_imm_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t Rd = (opcode >> 0) & 0x7;
 	uint8_t Rm = (opcode >> 3) & 0x7;
@@ -1811,7 +1889,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_data_proc_imm_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_data_proc_imm_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t imm = opcode & 0xff;
 	uint8_t Rd = (opcode >> 8) & 0x7;
@@ -1853,7 +1932,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_data_proc_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_data_proc_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t high_reg, op, Rm, Rd,H1,H2;
 	char *mnemonic = NULL;
@@ -2038,7 +2118,8 @@
 	return (addr + 4) & ~3;
 }
 
-int evaluate_load_literal_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_load_literal_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t immediate;
 	uint8_t Rd = (opcode >> 8) & 0x7;
@@ -2062,7 +2143,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_reg_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_load_store_reg_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t Rd = (opcode >> 0) & 0x7;
 	uint8_t Rn = (opcode >> 3) & 0x7;
@@ -2119,7 +2201,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_imm_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_load_store_imm_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t offset = (opcode >> 6) & 0x1f;
 	uint8_t Rd = (opcode >> 0) & 0x7;
@@ -2165,7 +2248,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_stack_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_load_store_stack_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t offset = opcode  & 0xff;
 	uint8_t Rd = (opcode >> 8) & 0x7;
@@ -2196,7 +2280,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_add_sp_pc_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_add_sp_pc_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t imm = opcode  & 0xff;
 	uint8_t Rd = (opcode >> 8) & 0x7;
@@ -2229,7 +2314,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_adjust_stack_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_adjust_stack_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t imm = opcode  & 0x7f;
 	uint8_t opc = opcode & (1 << 7);
@@ -2259,7 +2345,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_breakpoint_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_breakpoint_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t imm = opcode  & 0xff;
 
@@ -2272,7 +2359,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_multiple_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_load_store_multiple_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t reg_list = opcode  & 0xff;
 	uint32_t L = opcode & (1 << 11);
@@ -2285,6 +2373,10 @@
 	char ptr_name[7] = "";
 	int i;
 
+	/* REVISIT:  in ThumbEE mode, there are no LDM or STM instructions.
+	 * The STMIA and LDMIA opcodes are used for other instructions.
+	 */
+
 	if ((opcode & 0xf000) == 0xc000)
 	{ /* generic load/store multiple */
 		char *wback = "!";
@@ -2345,7 +2437,8 @@
 	return ERROR_OK;
 }
 
-int evaluate_cond_branch_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
+static int evaluate_cond_branch_thumb(uint16_t opcode,
+		uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t offset = opcode  & 0xff;
 	uint8_t cond = (opcode >> 8) & 0xf;
@@ -2835,6 +2928,12 @@
 	const char *mnemonic;
 
 	switch ((opcode >> 4) & 0x0f) {
+	case 0:
+		mnemonic = "LEAVEX";
+		break;
+	case 1:
+		mnemonic = "ENTERX";
+		break;
 	case 2:
 		mnemonic = "CLREX";
 		break;
@@ -2888,6 +2987,9 @@
 		return t2ev_hint(opcode, address, instruction, cp);
 	case 0x3b:
 		return t2ev_misc(opcode, address, instruction, cp);
+	case 0x3c:
+		sprintf(cp, "BXJ\tr%d", (int) (opcode >> 16) & 0x0f);
+		return ERROR_OK;
 	case 0x3e:
 	case 0x3f:
 		sprintf(cp, "MRS\tr%d, %s", (int) (opcode >> 8) & 0x0f,



From oharboe at mail.berlios.de  Tue Sep  8 08:18:47 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 8 Sep 2009 08:18:47 +0200
Subject: [Openocd-svn] r2676 - in trunk: doc src/target
Message-ID: <200909080618.n886Il1w010273@sheep.berlios.de>

Author: oharboe
Date: 2009-09-08 08:18:45 +0200 (Tue, 08 Sep 2009)
New Revision: 2676

Modified:
   trunk/doc/openocd.texi
   trunk/src/target/armv7a.c
Log:
David Brownell <david-b at pacbell.net> 
Provide an "armv7a disassemble" command.  Current omissions include
VFP (except as coprocessor instructions), Neon, and various Thumb2
opcodes that are not available in ARMv7-M processors.

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-08 06:17:33 UTC (rev 2675)
+++ trunk/doc/openocd.texi	2009-09-08 06:18:45 UTC (rev 2676)
@@ -5105,6 +5105,23 @@
 If @var{value} is defined, first assigns that.
 @end deffn
 
+ at subsection ARMv7-A specific commands
+ at cindex ARMv7-A
+
+ at deffn Command {armv7a disassemble} address [count [@option{thumb}]]
+ at cindex disassemble
+Disassembles @var{count} instructions starting at @var{address}.
+If @var{count} is not specified, a single instruction is disassembled.
+If @option{thumb} is specified, or the low bit of the address is set,
+Thumb2 (mixed 16/32-bit) instructions are used;
+else ARM (32-bit) instructions are used.
+With a handful of exceptions, ThumbEE instructions are the same as Thumb2;
+ThumbEE disassembly currently has no explicit support.
+(Processors may also support the Jazelle state, but
+those instructions are not currently understood by OpenOCD.)
+ at end deffn
+
+
 @subsection Cortex-M3 specific commands
 @cindex Cortex-M3
 

Modified: trunk/src/target/armv7a.c
===================================================================
--- trunk/src/target/armv7a.c	2009-09-08 06:17:33 UTC (rev 2675)
+++ trunk/src/target/armv7a.c	2009-09-08 06:18:45 UTC (rev 2676)
@@ -23,6 +23,7 @@
 #include "replacements.h"
 
 #include "armv7a.h"
+#include "arm_disassembler.h"
 
 #include "target.h"
 #include "register.h"
@@ -269,9 +270,86 @@
 	return dap_info_command(cmd_ctx, swjdp, apsel);
 }
 
+static int
+handle_armv7a_disassemble_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	int thumb = 0;
+	int count = 1;
+	uint32_t address;
+	int i;
+
+	if (armv4_5->common_magic != ARMV4_5_COMMON_MAGIC) {
+		command_print(cmd_ctx, "current target isn't an ARM target");
+		return ERROR_OK;
+	}
+
+	/* REVISIT:  eventually support ThumbEE disassembly too;
+	 * some opcodes work differently.
+	 */
+
+	switch (argc) {
+	case 3:
+		if (strcmp(args[2], "thumb") != 0)
+			goto usage;
+		thumb = 1;
+		/* FALL THROUGH */
+	case 2:
+		count = strtoul(args[1], NULL, 0);
+		/* FALL THROUGH */
+	case 1:
+		address = strtoul(args[0], NULL, 0);
+		if (address & 0x01) {
+			if (!thumb) {
+				command_print(cmd_ctx, "Disassemble as Thumb");
+				thumb = 1;
+			}
+			address &= ~1;
+		}
+		break;
+	default:
+usage:
+		command_print(cmd_ctx,
+			"usage: armv4_5 disassemble <address> [<count> ['thumb']]");
+		return ERROR_OK;
+	}
+
+	for (i = 0; i < count; i++) {
+		arm_instruction_t cur_instruction;
+		int retval;
+
+		if (thumb) {
+			retval = thumb2_opcode(target, address, &cur_instruction);
+			if (retval != ERROR_OK)
+				return retval;
+
+			address += cur_instruction.instruction_size;
+		} else {
+			uint32_t opcode;
+
+			retval = target_read_u32(target, address, &opcode);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = arm_evaluate_opcode(opcode, address,
+					&cur_instruction);
+			if (retval != ERROR_OK)
+				return retval;
+
+			address += 4;
+		}
+		command_print(cmd_ctx, "%s", cur_instruction.text);
+	}
+
+	return ERROR_OK;
+}
+
 int armv7a_register_commands(struct command_context_s *cmd_ctx)
 {
 	command_t *arm_adi_v5_dap_cmd;
+	command_t *armv7a_cmd;
 
 	arm_adi_v5_dap_cmd = register_command(cmd_ctx, NULL, "dap",
 			NULL, COMMAND_ANY,
@@ -297,5 +375,13 @@
 			"set/get number of extra tck for mem-ap memory "
 			"bus access [0-255]");
 
+	armv7a_cmd = register_command(cmd_ctx, NULL, "armv7a",
+			NULL, COMMAND_ANY,
+			"ARMv7-A specific commands");
+
+	register_command(cmd_ctx, armv7a_cmd, "disassemble",
+			handle_armv7a_disassemble_command, COMMAND_EXEC,
+			"disassemble instructions <address> [<count> ['thumb']]");
+
 	return ERROR_OK;
 }



From mlu at mail.berlios.de  Tue Sep  8 17:31:27 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Tue, 8 Sep 2009 17:31:27 +0200
Subject: [Openocd-svn] r2677 - trunk/src/target
Message-ID: <200909081531.n88FVRqv009311@sheep.berlios.de>

Author: mlu
Date: 2009-09-08 17:31:24 +0200 (Tue, 08 Sep 2009)
New Revision: 2677

Modified:
   trunk/src/target/cortex_a8.c
Log:
Load PC with bit 0 set to 1 when resuming  to say in Thumb instruction state.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-08 06:18:45 UTC (rev 2676)
+++ trunk/src/target/cortex_a8.c	2009-09-08 15:31:24 UTC (rev 2677)
@@ -85,7 +85,6 @@
 	.deassert_reset = NULL,
 	.soft_reset_halt = NULL,
 
-//	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
 	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
 
 	.read_memory = cortex_a8_read_memory,
@@ -509,6 +508,13 @@
 	{
 		resume_pc &= 0xFFFFFFFC;
 	}
+	/* When the return address is loaded into PC
+	 * bit 0 must be 1 to stay in Thumb state
+	 */
+	if (armv7a->core_state == ARMV7A_STATE_THUMB)
+	{
+		resume_pc |= 0x1;
+	}
 	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
 	buf_set_u32(ARMV7A_CORE_REG_MODE(armv4_5->core_cache,
 				armv4_5->core_mode, 15).value,
@@ -592,7 +598,6 @@
 	retval = mem_ap_write_atomic_u32(swjdp,
 			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, dscr);
 
-
 	/* Examine debug reason */
 	switch ((cortex_a8->cpudbg_dscr >> 2)&0xF)
 	{



From mlu at mail.berlios.de  Tue Sep  8 17:32:19 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Tue, 8 Sep 2009 17:32:19 +0200
Subject: [Openocd-svn] r2678 - trunk/src/target
Message-ID: <200909081532.n88FWJ07009473@sheep.berlios.de>

Author: mlu
Date: 2009-09-08 17:32:18 +0200 (Tue, 08 Sep 2009)
New Revision: 2678

Modified:
   trunk/src/target/armv7a.c
Log:
Report correct core instruction state for ARMv/A targets

Modified: trunk/src/target/armv7a.c
===================================================================
--- trunk/src/target/armv7a.c	2009-09-08 15:31:24 UTC (rev 2677)
+++ trunk/src/target/armv7a.c	2009-09-08 15:32:18 UTC (rev 2678)
@@ -192,7 +192,7 @@
 	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
 			 "%s: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "\n"
 			 "MMU: %s, D-Cache: %s, I-Cache: %s",
-		 armv7a_state_strings[armv4_5->core_state],
+		 armv7a_state_strings[armv7a->core_state],
 		 Jim_Nvp_value2name_simple(nvp_target_debug_reason,
 				target->debug_reason)->name,
 		 armv7a_mode_strings[



From oharboe at mail.berlios.de  Wed Sep  9 08:27:48 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 9 Sep 2009 08:27:48 +0200
Subject: [Openocd-svn] r2679 - trunk/doc
Message-ID: <200909090627.n896RmBI006811@sheep.berlios.de>

Author: oharboe
Date: 2009-09-09 08:27:47 +0200 (Wed, 09 Sep 2009)
New Revision: 2679

Modified:
   trunk/doc/openocd.texi
Log:
David Brownell <david-b at pacbell.net> 
Fix docs on ARM11 MCR and MRC coprocessor commands:
correct read-vs-write; and describe the params.

(ARM920 and ARM926 have cp15-specific commands; this
approach is more generic.  MCR2, MRC2, MCRR, MCRR2,
MRRC, and MRRC2 instructions could also get exposed.)

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-08 15:32:18 UTC (rev 2678)
+++ trunk/doc/openocd.texi	2009-09-09 06:27:47 UTC (rev 2679)
@@ -5038,8 +5038,13 @@
 @subsection ARM11 specific commands
 @cindex ARM11
 
- at deffn Command {arm11 mcr} p1 p2 p3 p4 p5
-Read coprocessor register
+ at deffn Command {arm11 mcr} pX opc1 CRn CRm opc2 value
+Write @var{value} to a coprocessor @var{pX} register
+passing parameters @var{CRn},
+ at var{CRm}, opcodes @var{opc1} and @var{opc2},
+and the MCR instruction.
+(The difference beween this and the MCR2 instruction is
+one bit in the encoding, effecively a fifth parameter.)
 @end deffn
 
 @deffn Command {arm11 memwrite burst} [value]
@@ -5054,8 +5059,13 @@
 If @var{value} is defined, first assigns that.
 @end deffn
 
- at deffn Command {arm11 mrc} p1 p2 p3 p4 p5 value
-Write coprocessor register
+ at deffn Command {arm11 mrc} pX opc1 CRn CRm opc2
+Read a coprocessor @var{pX} register passing parameters @var{CRn},
+ at var{CRm}, opcodes @var{opc1} and @var{opc2},
+and the MRC instruction.
+(The difference beween this and the MRC2 instruction is
+one bit in the encoding, effecively a fifth parameter.)
+Displays the result.
 @end deffn
 
 @deffn Command {arm11 no_increment}  [value]



From oharboe at mail.berlios.de  Wed Sep  9 08:28:50 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 9 Sep 2009 08:28:50 +0200
Subject: [Openocd-svn] r2680 - in trunk/src: flash target
Message-ID: <200909090628.n896So8i006902@sheep.berlios.de>

Author: oharboe
Date: 2009-09-09 08:28:49 +0200 (Wed, 09 Sep 2009)
New Revision: 2680

Modified:
   trunk/src/flash/arm_nandio.c
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm9tdmi.c
   trunk/src/target/armv4_5.c
   trunk/src/target/armv4_5.h
Log:
David Brownell <david-b at pacbell.net> 
Optionally shave time off the armv4_5 run_algorithm() code:  let
them terminate using software breakpoints, avoiding roundtrips
to manage hardware ones.

Enable this by using BKPT to terminate execution instead of "branch
to here" loops.  Then pass zero as the exit address, except when
running on an ARMv4 core.  ARM7TDMI, ARM9TDMI, and derived cores
now set a flag saying they're ARMv4.

Use that mechanism in arm_nandwrite(), for about 3% speedup on a
DaVinci ARM926 core; not huge, but it helps.  Some other algorithms
could use this too (mostly flavors of flash operation).

Modified: trunk/src/flash/arm_nandio.c
===================================================================
--- trunk/src/flash/arm_nandio.c	2009-09-09 06:27:47 UTC (rev 2679)
+++ trunk/src/flash/arm_nandio.c	2009-09-09 06:28:49 UTC (rev 2680)
@@ -33,7 +33,6 @@
  * For now this only supports ARMv4 and ARMv5 cores.
  *
  * Enhancements to target_run_algorithm() could enable:
- *   - faster writes: on ARMv5+ don't setup/teardown hardware breakpoint
  *   - ARMv6 and ARMv7 cores in ARM mode
  *
  * Different code fragments could handle:
@@ -44,8 +43,10 @@
 {
 	target_t		*target = nand->target;
 	armv4_5_algorithm_t	algo;
+	armv4_5_common_t	*armv4_5 = target->arch_info;
 	reg_param_t		reg_params[3];
 	uint32_t		target_buf;
+	uint32_t		exit = 0;
 	int			retval;
 
 	/* Inputs:
@@ -112,11 +113,13 @@
 	buf_set_u32(reg_params[1].value, 0, 32, target_buf);
 	buf_set_u32(reg_params[2].value, 0, 32, size);
 
+	/* armv4 must exit using a hardware breakpoint */
+	if (armv4_5->is_armv4)
+		exit = nand->copy_area->address + sizeof(code) - 4;
+
 	/* use alg to write data from work area to NAND chip */
 	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
-			nand->copy_area->address,
-			nand->copy_area->address + sizeof(code) - 4,
-			1000, &algo);
+			nand->copy_area->address, exit, 1000, &algo);
 	if (retval != ERROR_OK)
 		LOG_ERROR("error executing hosted NAND write");
 

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2009-09-09 06:27:47 UTC (rev 2679)
+++ trunk/src/target/arm7tdmi.c	2009-09-09 06:28:49 UTC (rev 2680)
@@ -828,6 +828,7 @@
 
 	arm7tdmi = calloc(1,sizeof(arm7tdmi_common_t));
 	arm7tdmi_init_arch_info(target, arm7tdmi, target->tap);
+	arm7tdmi->arm7_9_common.armv4_5_common.is_armv4 = true;
 
 	return ERROR_OK;
 }

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-09-09 06:27:47 UTC (rev 2679)
+++ trunk/src/target/arm9tdmi.c	2009-09-09 06:28:49 UTC (rev 2680)
@@ -956,6 +956,7 @@
 	arm9tdmi_common_t *arm9tdmi = calloc(1,sizeof(arm9tdmi_common_t));
 
 	arm9tdmi_init_arch_info(target, arm9tdmi, target->tap);
+	arm9tdmi->arm7_9_common.armv4_5_common.is_armv4 = true;
 
 	return ERROR_OK;
 }

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-09-09 06:27:47 UTC (rev 2679)
+++ trunk/src/target/armv4_5.c	2009-09-09 06:28:49 UTC (rev 2680)
@@ -532,7 +532,10 @@
 		}
 		return ERROR_TARGET_TIMEOUT;
 	}
-	if (buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32) != exit_point)
+
+	/* fast exit: ARMv5+ code can use BKPT */
+	if (exit_point && buf_get_u32(armv4_5->core_cache->reg_list[15].value,
+				0, 32) != exit_point)
 	{
 		LOG_WARNING("target reentered debug state, but not at the desired exit point: 0x%4.4" PRIx32 "",
 			buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
@@ -570,6 +573,13 @@
 	if (armv4_5_mode_to_number(armv4_5->core_mode)==-1)
 		return ERROR_FAIL;
 
+	/* armv5 and later can terminate with BKPT instruction; less overhead */
+	if (!exit_point && armv4_5->is_armv4)
+	{
+		LOG_ERROR("ARMv4 target needs HW breakpoint location");
+		return ERROR_FAIL;
+	}
+
 	for (i = 0; i <= 16; i++)
 	{
 		if (!ARMV4_5_CORE_REG_MODE(armv4_5->core_cache, armv4_5_algorithm_info->core_mode, i).valid)
@@ -626,9 +636,11 @@
 		armv4_5->core_cache->reg_list[ARMV4_5_CPSR].valid = 1;
 	}
 
-	if ((retval = breakpoint_add(target, exit_point, exit_breakpoint_size, BKPT_HARD)) != ERROR_OK)
+	/* terminate using a hardware or (ARMv5+) software breakpoint */
+	if (exit_point && (retval = breakpoint_add(target, exit_point,
+				exit_breakpoint_size, BKPT_HARD)) != ERROR_OK)
 	{
-		LOG_ERROR("can't add breakpoint to finish algorithm execution");
+		LOG_ERROR("can't add HW breakpoint to terminate algorithm");
 		return ERROR_TARGET_FAILURE;
 	}
 
@@ -639,7 +651,8 @@
 	int retvaltemp;
 	retval = run_it(target, exit_point, timeout_ms, arch_info);
 
-	breakpoint_remove(target, exit_point);
+	if (exit_point)
+		breakpoint_remove(target, exit_point);
 
 	if (retval != ERROR_OK)
 		return retval;

Modified: trunk/src/target/armv4_5.h
===================================================================
--- trunk/src/target/armv4_5.h	2009-09-09 06:27:47 UTC (rev 2679)
+++ trunk/src/target/armv4_5.h	2009-09-09 06:28:49 UTC (rev 2680)
@@ -76,6 +76,7 @@
 	reg_cache_t *core_cache;
 	enum armv4_5_mode core_mode;
 	enum armv4_5_state core_state;
+	bool is_armv4;
 	int (*full_context)(struct target_s *target);
 	int (*read_core_reg)(struct target_s *target, int num, enum armv4_5_mode mode);
 	int (*write_core_reg)(struct target_s *target, int num, enum armv4_5_mode mode, uint32_t value);



From oharboe at mail.berlios.de  Wed Sep  9 09:09:15 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 9 Sep 2009 09:09:15 +0200
Subject: [Openocd-svn] r2681 - trunk/src/jtag
Message-ID: <200909090709.n8979F0n010939@sheep.berlios.de>

Author: oharboe
Date: 2009-09-09 09:09:14 +0200 (Wed, 09 Sep 2009)
New Revision: 2681

Modified:
   trunk/src/jtag/tcl.c
Log:
- Fix bug-in-waiting when adding more than one TAP event type
- Infinite loop bugfix when running tap configure a second time


Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-09 06:28:49 UTC (rev 2680)
+++ trunk/src/jtag/tcl.c	2009-09-09 07:09:14 UTC (rev 2681)
@@ -141,9 +141,11 @@
 					}
 
 					if (goi->isconfigure) {
+						bool replace = true;
 						if (jteap == NULL) {
 							/* create new */
 							jteap = calloc(1, sizeof (*jteap));
+							replace = false;
 						}
 						jteap->event = n->value;
 						Jim_GetOpt_Obj(goi, &o);
@@ -153,9 +155,12 @@
 						jteap->body = Jim_DuplicateObj(goi->interp, o);
 						Jim_IncrRefCount(jteap->body);
 
-						/* add to head of event list */
-						jteap->next = tap->event_action;
-						tap->event_action = jteap;
+						if (!replace)
+						{
+							/* add to head of event list */
+							jteap->next = tap->event_action;
+							tap->event_action = jteap;
+						}
 						Jim_SetEmptyResult(goi->interp);
 					} else {
 						/* get */
@@ -374,7 +379,8 @@
 				 * can't fail.  That presumes later code
 				 * will be verifying the scan chains ...
 				 */
-				tap->enabled = (e == JTAG_TAP_EVENT_ENABLE);
+				if (e == JTAG_TAP_EVENT_ENABLE)
+					tap->enabled = true;
 			}
 		}
 



From oharboe at mail.berlios.de  Wed Sep  9 18:11:33 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 9 Sep 2009 18:11:33 +0200
Subject: [Openocd-svn] r2682 - trunk/src/flash
Message-ID: <200909091611.n89GBXgH016489@sheep.berlios.de>

Author: oharboe
Date: 2009-09-09 18:11:33 +0200 (Wed, 09 Sep 2009)
New Revision: 2682

Modified:
   trunk/src/flash/cfi.c
   trunk/src/flash/non_cfi.c
Log:
Rolf Meeser <rolfm_9dq at yahoo.de> 
This patch adds target algorithm support for those flash devices that do not support DQ5 polling. So far they could only be programmed with host algorithm, but this was way too slow.


Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-09-09 07:09:14 UTC (rev 2681)
+++ trunk/src/flash/cfi.c	2009-09-09 16:11:33 UTC (rev 2682)
@@ -1384,6 +1384,31 @@
 		0xeafffffe 	/* b	81ac <sp_16_done>              */
 		};
 
+		static const uint32_t word_16_code_dq7only[] = {
+				/* <sp_16_code>:                       */
+		0xe0d050b2, 	/* ldrh r5, [r0], #2                   */
+		0xe1c890b0, 	/* strh r9, [r8]                       */
+		0xe1cab0b0, 	/* strh	r11, [r10]				*/
+		0xe1c830b0, 	/* strh	r3, [r8]				*/
+		0xe1c150b0, 	/* strh	r5, [r1]		       */
+		0xe1a00000, 	/* nop			(mov r0,r0)    */
+				/* 				       */
+				/* <sp_16_busy>:                       */
+		0xe1d160b0, 	/* ldrh	r6, [r1]		       */
+		0xe0257006, 	/* eor	r7, r5, r6		       */
+		0xe2177080, 	/* ands	r7, #0x80                      */
+		0x1afffffb, 	/* bne	8168 <sp_16_busy>	       */
+				/* 				       */
+		0xe2522001, 	/* subs	r2, r2, #1	; 0x1	       */
+		0x03a05080, 	/* moveq	r5, #128	; 0x80 */
+		0x0a000001, 	/* beq	81ac <sp_16_done>	       */
+		0xe2811002, 	/* add	r1, r1, #2	; 0x2	       */
+		0xeafffff0, 	/* b	8158 <sp_16_code>	       */
+				/* 				       */
+				/* 000081ac <sp_16_done>:	       */
+		0xeafffffe 	/* b	81ac <sp_16_done>              */
+		};
+
 		static const uint32_t word_8_code[] = {
 				/* 000081b0 <sp_16_code_end>:          */
 		0xe4d05001, 	/* ldrb	r5, [r0], #1		       */
@@ -1423,10 +1448,10 @@
 	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
 
 	/* flash write code */
+	int target_code_size;
 	if (!cfi_info->write_algorithm)
 	{
 		uint8_t *target_code;
-		int target_code_size;
 		const uint32_t *src;
 
 		/* convert bus-width dependent algorithm code to correct endiannes */
@@ -1437,8 +1462,18 @@
 			target_code_size = sizeof(word_8_code);
 			break;
 		case 2:
-			src = word_16_code;
-			target_code_size = sizeof(word_16_code);
+			/* Check for DQ5 support */
+			if( cfi_info->status_poll_mask & (1 << 5) )
+			{
+				src = word_16_code;
+				target_code_size = sizeof(word_16_code);
+			}
+			else
+			{
+				/* No DQ5 support. Use DQ7 DATA# polling only. */
+				src = word_16_code_dq7only;
+				target_code_size = sizeof(word_16_code_dq7only);
+			}
 			break;
 		case 4:
 			src = word_32_code;
@@ -1515,7 +1550,7 @@
 
 		retval = target_run_algorithm(target, 0, NULL, 10, reg_params,
 						     cfi_info->write_algorithm->address,
-						     cfi_info->write_algorithm->address + ((24 * 4) - 4),
+						     cfi_info->write_algorithm->address + ((target_code_size) - 4),
 						     10000, &armv4_5_info);
 
 		status = buf_get_u32(reg_params[5].value, 0, 32);
@@ -1532,7 +1567,7 @@
 		count -= thisrun_count;
 	}
 
-	target_free_working_area(target, source);
+	target_free_all_working_areas(target);
 
 	destroy_reg_param(&reg_params[0]);
 	destroy_reg_param(&reg_params[1]);

Modified: trunk/src/flash/non_cfi.c
===================================================================
--- trunk/src/flash/non_cfi.c	2009-09-09 07:09:14 UTC (rev 2681)
+++ trunk/src/flash/non_cfi.c	2009-09-09 16:11:33 UTC (rev 2682)
@@ -140,7 +140,10 @@
 
 	/* SST 39VF* do not support DQ5 status polling - this currently is
 	   only supported by the host algorithm, not by the target code using
-	   the work area. */
+	   the work area.
+           Only true for 8-bit and 32-bit wide memories. 16-bit wide memories
+           without DQ5 status polling are supported by the target code.
+        */
 	{
 		.mfr = CFI_MFR_SST,
 		.id = 0x2782,				/* SST39xF160 */



From oharboe at mail.berlios.de  Thu Sep 10 10:06:23 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 10 Sep 2009 10:06:23 +0200
Subject: [Openocd-svn] r2683 - in trunk/tcl: board target
Message-ID: <200909100806.n8A86Nfi008468@sheep.berlios.de>

Author: oharboe
Date: 2009-09-10 10:06:22 +0200 (Thu, 10 Sep 2009)
New Revision: 2683

Added:
   trunk/tcl/board/telo.cfg
   trunk/tcl/target/c100config.tcl
   trunk/tcl/target/c100helper.tcl
   trunk/tcl/target/c100regs.tcl
Modified:
   trunk/tcl/target/c100.cfg
Log:
michal smulski <michal.smulski at ooma.com> telo target/board scripts

Added: trunk/tcl/board/telo.cfg
===================================================================
--- trunk/tcl/board/telo.cfg	2009-09-09 16:11:33 UTC (rev 2682)
+++ trunk/tcl/board/telo.cfg	2009-09-10 08:06:22 UTC (rev 2683)
@@ -0,0 +1,54 @@
+source [find target/c100.cfg]
+# basic register defintion for C100
+source [find target/c100regs.tcl]
+# board-config info
+source [find target/c100config.tcl]
+# C100 helper functions
+source [find target/c100helper.tcl]
+
+
+# Telo board & C100 support trst and srst
+# however openocd does not support 
+# 1. setting srst reset pulse width
+# 2. setting delay between srst pulse and JTAG access
+# This really makes the srst useless for now.
+reset_config trst_and_srst separate
+
+
+
+# issue telnet: reset init
+# issue gdb: monitor reset init
+$_TARGETNAME configure -event reset-init {
+	jtag_khz 100
+	# setup GPIO used as control signals for C100
+	setupGPIO
+	# This will allow acces to lower 8MB or NOR
+	lowGPIO5 
+	# setup NOR size,timing,etc.
+	setupNOR
+	# setup internals + PLL + DDR2
+	initC100
+	#turn up the JTAG speed
+	jtag_khz 3000
+	puts "JTAG speek now 3MHz"
+	puts "type helpC100 to get help on C100"
+}
+
+$_TARGETNAME configure -event reset-deassert-post {
+	# Force target into ARM state.
+#	soft_reset_halt # not implemented on ARM11
+	puts "Detected SRSRT asserted on C100.CPU"
+	
+}
+
+proc power_restore {} { puts "Sensed power restore. No action." } 
+proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }
+
+
+# boots from NOR on CS0:  8 MBytes CFI flash, 16-bit bus
+# it's really 16MB but the upper 8mb is controller via gpio
+# openocd does not support 'complex reads/writes' to NOR
+flash bank cfi 0x20000000 0x01000000 2 2 $_TARGETNAME
+
+# writing data to memory does not work without this
+memwrite burst disable
\ No newline at end of file


Property changes on: trunk/tcl/board/telo.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/tcl/target/c100.cfg
===================================================================
--- trunk/tcl/target/c100.cfg	2009-09-09 16:11:33 UTC (rev 2682)
+++ trunk/tcl/target/c100.cfg	2009-09-10 08:06:22 UTC (rev 2683)
@@ -1,11 +1,10 @@
-# c100 config
-#
-#jtag_nsrst_delay 5000
-#jtag_ntrst_delay 3000
-#reset_config none
-reset_config trst_and_srst separate
-#reset_config srst_only srst_pulls_trst
+# c100 config.
+# This is ARM1136 dual core
+# this script only configures one core (that is used to run Linux)
 
+# assume no PLL lock, start slowly
+jtag_khz 100
+
 if { [info exists CHIPNAME] } {	
    set  _CHIPNAME $CHIPNAME    
 } else {	 
@@ -36,30 +35,8 @@
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
 jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
-set _TARGETNAME $_CHIPNAME.cpu
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # C100's ARAM 64k SRAM
 $_TARGETNAME configure -work-area-phys 0x0a000000 -work-area-size 0x10000 -work-area-backup 0
-
-
-proc power_restore {} { puts "Sensed power restore. No action." } 
-proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }
-
-
-# issue telnet: reset init
-# issue gdb: monitor reset init
-$_TARGETNAME configure -event reset-init {
-	# Force target into ARM state.
-#	soft_reset_halt # not implemented on ARM11
-	puts "Halting C100.CPU"
-	halt
-}
-
-$_TARGETNAME configure -event reset-deassert-post {
-	# Force target into ARM state.
-#	soft_reset_halt # not implemented on ARM11
-	puts "Detected SRSRT asserted on C100.CPU"
-	
-}
-# Valid events: old-gdb_program_config, old-pre_resume, early-halted, halted, resumed, resume-start, resume-end, gdb-start, gdb-end, reset-start, reset-assert-pre, reset-assert-post, reset-deassert-pre, reset-deassert-post, reset-halt-pre, reset-halt-post, reset-wait-pre, reset-wait-post, reset-init, reset-end, examine-start, examine-end, debug-halted, debug-resumed, gdb-attach, gdb-detach, gdb-flash-write-start, gdb-flash-write-end, gdb-flash-erase-start, gdb-flash-erase-end, resume-start, resume-ok, or resume-end

Added: trunk/tcl/target/c100config.tcl
===================================================================
--- trunk/tcl/target/c100config.tcl	2009-09-09 16:11:33 UTC (rev 2682)
+++ trunk/tcl/target/c100config.tcl	2009-09-10 08:06:22 UTC (rev 2683)
@@ -0,0 +1,324 @@
+
+# board(-config) specfic parameters file.
+
+# set CFG_REFCLKFREQ [configC100 CFG_REFCLKFREQ]
+proc config {label} {
+    return [dict get [configC100] $label ]	
+}
+
+# show the value for the param. with label
+proc showconfig {label} {
+    puts [format "0x%x" [dict get [configC100] $label ]]
+}
+
+# Telo board config
+# when there are more then one board config
+# use soft links to c100board-config.tcl
+# so that only the right board-config gets
+# included (just like include/configs/board-configs.h 
+# in u-boot.
+proc configC100 {} {
+    # xtal freq. 24MHz
+    dict set configC100 CFG_REFCLKFREQ	         24000000
+
+    # Amba Clk 165MHz
+    dict set configC100 CONFIG_SYS_HZ_CLOCK      165000000
+    dict set configC100 w_amba 1
+    dict set configC100 x_amba 1
+    # y = amba_clk * (w+1)*(x+1)*2/xtal_clk
+    dict set configC100 y_amba [expr ([dict get $configC100 CONFIG_SYS_HZ_CLOCK] * ( ([dict get $configC100 w_amba]+1 ) * ([dict get $configC100 x_amba]+1 ) *2 ) / [dict get $configC100 CFG_REFCLKFREQ]) ]
+
+    # Arm Clk 450MHz, must be a multiple of 25 MHz 
+    dict set configC100 CFG_ARM_CLOCK      450000000
+    dict set configC100 w_arm 0
+    dict set configC100 x_arm 1
+    # y = arm_clk * (w+1)*(x+1)*2/xtal_clk
+    dict set configC100 y_arm [expr ([dict get $configC100 CFG_ARM_CLOCK] * ( ([dict get $configC100 w_arm]+1 ) * ([dict get $configC100 x_arm]+1 ) *2 ) / [dict get $configC100 CFG_REFCLKFREQ]) ]
+
+
+}
+
+proc setupNOR {} {
+    puts "Setting up NOR: 16MB, 16-bit wide bus, CS0"
+    # this is taken from u-boot/boards/mindspeed/ooma-darwin/board.c:nor_hw_init()
+    set EX_CSEN_REG	    [regs EX_CSEN_REG ]	
+    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]	
+    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]	
+    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]	
+    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]	
+    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]	
+    set EX_CLOCK_DIV_REG    [regs EX_CLOCK_DIV_REG ]
+    set EX_MFSM_REG	    [regs EX_MFSM_REG ]	
+    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]	
+    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]	
+    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]	
+
+    # enable Expansion Bus Clock + CS0 (NOR)
+    mww $EX_CSEN_REG 0x3
+    # set the address space for CS0=16MB
+    mww $EX_CS0_SEG_REG 0x7ff
+    # set the CS0 bus width to 16-bit
+    mww $EX_CS0_CFG_REG 0x202
+    # set timings to NOR
+    mww $EX_CS0_TMG1_REG 0x03034006
+    mww $EX_CS0_TMG2_REG 0x04040002
+    #mww $EX_CS0_TMG3_REG 
+    # set EBUS clock 165/5=33MHz
+    mww $EX_CLOCK_DIV_REG 0x5
+    # everthing else is OK with default
+}
+
+proc bootNOR {} {
+    set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]
+    set BLOCK_RESET_REG	       [regs BLOCK_RESET_REG]
+    set DDR_RST		       [regs DDR_RST]
+ 
+    # put DDR controller in reset (so that it comes reset in u-boot)
+    mmw $BLOCK_RESET_REG 0x0 $DDR_RST
+    # setup CS0 controller for NOR
+    setupNOR
+    # make sure we are accessing the lower part of NOR
+    lowGPIO5
+    # set PC to start of NOR (at boot 0x20000000 = 0x0)
+    reg pc $EXP_CS0_BASEADDR
+    # run
+    resume
+}
+proc setupGPIO {} {
+    puts "Setting up GPIO block for Telo"
+    # This is current setup for Telo (see sch. for details):
+    #GPIO0 reset for FXS-FXO IC, leave as input, the IC has internal pullup
+    #GPIO1 irq line for FXS-FXO
+    #GPIO5 addr22 for NOR flash (access to upper 8MB)
+    #GPIO17 reset for DECT module.
+    #GPIO29 CS_n for NAND
+
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
+    set GPIO_OE_REG		    [regs GPIO_OE_REG]	
+
+    # set GPIO29=GPIO17=1, GPIO5=0
+    mww $GPIO_OUTPUT_REG [expr 1<<29 | 1<<17]
+    # enable [as output] GPIO29,GPIO17,GPIO5
+    mww $GPIO_OE_REG [expr  1<<29 | 1<<17 | 1<<5]
+}
+
+proc highGPIO5 {} {
+    puts "GPIO5 high"
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
+    # set GPIO5=1
+    mmw $GPIO_OUTPUT_REG [expr 1 << 5] 0x0
+}
+
+proc lowGPIO5 {} {
+    puts "GPIO5 low"
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
+    # set GPIO5=0
+    mmw $GPIO_OUTPUT_REG 0x0 [expr 1 << 5]
+}
+
+proc boardID {id} {
+    # so far built:
+    # 4'b1111
+    dict set boardID 15 name "EVT1"		
+    dict set boardID 15 ddr2size 128M
+    # dict set boardID 15 nandsize 1G
+    # dict set boardID 15 norsize 16M
+    # 4'b0000
+    dict set boardID 0 name "EVT2"		
+    dict set boardID 0 ddr2size 128M
+    # 4'b0001
+    dict set boardID 1 name "EVT3"		
+    dict set boardID 1 ddr2size 256M
+    # 4'b1110
+    dict set boardID 14 name "EVT3_old"
+    dict set boardID 14 ddr2size 128M
+    # 4'b0010
+    dict set boardID 2 name "EVT4"		
+    dict set boardID 2 ddr2size 256M
+
+    return $boardID
+}
+
+# converted from u-boot/boards/mindspeed/ooma-darwin/board.c:ooma_board_detect()
+# figure out what board revision this is, uses BOOTSTRAP register to read stuffed resistors 
+proc ooma_board_detect {} {
+    set GPIO_BOOTSTRAP_REG	[regs GPIO_BOOTSTRAP_REG]
+    
+    # read the current value of the BOOTSRAP pins
+    set tmp [mrw $GPIO_BOOTSTRAP_REG]
+    puts [format "GPIO_BOOTSTRAP_REG  (0x%x): 0x%x" $GPIO_BOOTSTRAP_REG $tmp]
+    # extract the GPBP bits
+    set gpbt [expr ($tmp &0x1C00) >> 10 | ($tmp & 0x40) >>3]
+
+    # display board ID
+    puts [format "This is %s (0x%x)" [dict get [boardID $gpbt] $gpbt name] $gpbt]
+    # return the ddr2 size, used to configure DDR2 on a given board.
+    return [dict get [boardID $gpbt] $gpbt ddr2size]
+}
+
+proc configureDDR2regs_256M {} {
+    puts "ConfigureDDR2regs_256M TBD"
+}
+
+# converted from u-boot/cpu/arm1136/comcerto/bsp100.c:config_board99()
+# The values are computed based on Mindspeed and Nanya datasheets
+proc configureDDR2regs_128M {} {
+
+    set DENALI_CTL_00_DATA    [regs DENALI_CTL_00_DATA]
+    set DENALI_CTL_01_DATA    [regs DENALI_CTL_01_DATA]
+    set DENALI_CTL_02_DATA    [regs DENALI_CTL_02_DATA]
+    set DENALI_CTL_03_DATA    [regs DENALI_CTL_03_DATA]
+    set DENALI_CTL_04_DATA    [regs DENALI_CTL_04_DATA]
+    set DENALI_CTL_05_DATA    [regs DENALI_CTL_05_DATA]
+    set DENALI_CTL_06_DATA    [regs DENALI_CTL_06_DATA]
+    set DENALI_CTL_07_DATA    [regs DENALI_CTL_07_DATA]
+    set DENALI_CTL_08_DATA    [regs DENALI_CTL_08_DATA]
+    set DENALI_CTL_09_DATA    [regs DENALI_CTL_09_DATA]
+    set DENALI_CTL_10_DATA    [regs DENALI_CTL_10_DATA]
+    set DENALI_CTL_11_DATA    [regs DENALI_CTL_11_DATA]
+    set DENALI_CTL_12_DATA    [regs DENALI_CTL_12_DATA]
+    set DENALI_CTL_13_DATA    [regs DENALI_CTL_13_DATA]
+    set DENALI_CTL_14_DATA    [regs DENALI_CTL_14_DATA]
+    set DENALI_CTL_15_DATA    [regs DENALI_CTL_15_DATA]
+    set DENALI_CTL_16_DATA    [regs DENALI_CTL_16_DATA]
+    set DENALI_CTL_17_DATA    [regs DENALI_CTL_17_DATA]
+    set DENALI_CTL_18_DATA    [regs DENALI_CTL_18_DATA]
+    set DENALI_CTL_19_DATA    [regs DENALI_CTL_19_DATA]
+    set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]
+
+
+    set DENALI_CTL_02_VAL 0x0100010000010100 
+    set DENALI_CTL_11_VAL 0x433A42124A650A37
+    # set some default values     
+    mw64bit $DENALI_CTL_00_DATA  0x0100000101010101
+    mw64bit $DENALI_CTL_01_DATA  0x0100000100000101
+    mw64bit $DENALI_CTL_02_DATA  $DENALI_CTL_02_VAL
+    mw64bit $DENALI_CTL_03_DATA  0x0102020202020201
+    mw64bit $DENALI_CTL_04_DATA  0x0201010100000201
+    mw64bit $DENALI_CTL_05_DATA  0x0203010300010101
+    mw64bit $DENALI_CTL_06_DATA  0x050A020200020202
+    mw64bit $DENALI_CTL_07_DATA  0x000000030E0B0205
+    mw64bit $DENALI_CTL_08_DATA  0x6427003F3F0A0209
+    mw64bit $DENALI_CTL_09_DATA  0x1A00002F00001A00
+    mw64bit $DENALI_CTL_10_DATA  0x01202020201A1A1A
+    mw64bit $DENALI_CTL_11_DATA  $DENALI_CTL_11_VAL
+    mw64bit $DENALI_CTL_12_DATA  0x0000080000000800
+    mw64bit $DENALI_CTL_13_DATA  0x0010002000100040
+    mw64bit $DENALI_CTL_14_DATA  0x0010004000100040
+    mw64bit $DENALI_CTL_15_DATA  0x0508000000000000
+    mw64bit $DENALI_CTL_16_DATA  0x000020472D200000
+    mw64bit $DENALI_CTL_17_DATA  0x0000000008000000
+    mw64bit $DENALI_CTL_18_DATA  0x0302000000000000
+    mw64bit $DENALI_CTL_19_DATA  0x00001400C8030604
+    mw64bit $DENALI_CTL_20_DATA  0x00000000823600C8
+
+    set wr_dqs_shift 0x40
+    # start DDRC
+    mw64bit $DENALI_CTL_02_DATA [expr $DENALI_CTL_02_VAL | (1 << 32)]
+    # wait int_status[2] (DRAM init complete)
+    puts -nonewline "Waiting for DDR2 controller to init..."
+    set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
+    while { [expr $tmp & 0x040000] == 0 } { 
+	sleep 1
+	set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
+    }
+   mw64bit $DENALI_CTL_11_DATA [expr ($DENALI_CTL_11_VAL  & ~0x00007F0000000000) | ($wr_dqs_shift << 40) ]
+    puts "done."
+
+    # do ddr2 training sequence
+    # TBD (for now, if you need it, run trainDDR command)
+}
+
+
+
+proc setupUART0 {} {
+    # configure UART0 to 115200, 8N1
+    set GPIO_LOCK_REG      [regs GPIO_LOCK_REG]
+    set GPIO_IOCTRL_REG    [regs GPIO_IOCTRL_REG]
+    set GPIO_IOCTRL_VAL    [regs GPIO_IOCTRL_VAL]
+    set GPIO_IOCTRL_UART0  [regs GPIO_IOCTRL_UART0]
+    set UART0_LCR	            [regs UART0_LCR]	
+    set LCR_DLAB		    [regs LCR_DLAB]	
+    set UART0_DLL		    [regs UART0_DLL]		
+    set UART0_DLH		    [regs UART0_DLH]	
+    set UART0_IIR		    [regs UART0_IIR]	
+    set UART0_IER		    [regs UART0_IER]	
+    set LCR_ONE_STOP		    [regs LCR_ONE_STOP]		
+    set LCR_CHAR_LEN_8		    [regs LCR_CHAR_LEN_8]		
+    set FCR_XMITRES		    [regs FCR_XMITRES]
+    set FCR_RCVRRES		    [regs FCR_RCVRRES]	
+    set FCR_FIFOEN		    [regs FCR_FIFOEN]	
+    set IER_UUE			    [regs IER_UUE]		
+
+    # unlock writing to IOCTRL register
+    mww $GPIO_LOCK_REG $GPIO_IOCTRL_VAL
+    # enable UART0
+    mmw $GPIO_IOCTRL_REG $GPIO_IOCTRL_UART0 0x0
+    # baudrate  115200
+    # This should really be amba_clk/(16*115200) but amba_clk=165MHz
+    set tmp 89
+    # Enable Divisor Latch access
+    mmw  $UART0_LCR $LCR_DLAB 0x0
+    # set the divisor to $tmp
+    mww $UART0_DLL [expr $tmp & 0xff]
+    mww $UART0_DLH [expr $tmp >> 8]
+    # Disable Divisor Latch access
+    mmw  $UART0_LCR 0x0 $LCR_DLAB
+    # set the UART to 8N1
+    mmw  $UART0_LCR [expr $LCR_ONE_STOP | $LCR_CHAR_LEN_8 ] 0x0
+    # reset FIFO
+    mmw  $UART0_IIR [expr $FCR_XMITRES  | $FCR_RCVRRES | $FCR_FIFOEN ] 0x0
+    #  enable FFUART
+    mww $UART0_IER $IER_UUE
+}
+
+proc putcUART0 {char} {
+
+    set UART0_LSR	    [regs UART0_LSR]	
+    set UART0_THR	    [regs UART0_THR]
+    set LSR_TEMT	    [regs LSR_TEMT]
+
+    # convert the 'char' to digit
+    set tmp [ scan $char %c ]
+    # /* wait for room in the tx FIFO on FFUART */
+    while {[expr [mrw $UART0_LSR] & $LSR_TEMT] == 0} { sleep 1 }
+    mww $UART0_THR $tmp
+    if { $char == "\n" } { putcUART0 \r }
+}
+
+proc putsUART0 {str} {
+    set index 0
+    set len [string length $str]
+    while { $index < $len } {
+	putcUART0 [string index $str $index]
+	set index [expr $index + 1]
+    }
+}
+
+
+proc trainDDR2 {} {
+    set ARAM_BASEADDR	[regs ARAM_BASEADDR]
+
+    # you must have run 'reset init' or u-boot
+    # load the training code to ARAM
+    load_image ./images/ddr2train.bin $ARAM_BASEADDR bin
+    # set PC to start of NOR (at boot 0x20000000 = 0x0)
+    reg pc $ARAM_BASEADDR
+    # run
+    resume
+}
+
+proc flashUBOOT {} {
+    # this will update uboot on NOR partition
+    set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]
+    
+    # setup CS0 controller for NOR
+    setupNOR
+    # make sure we are accessing the lower part of NOR
+    lowGPIO5
+    flash probe 0
+    puts "Erasing sectors 0-3 for uboot"
+    flash erase_sector 0 0 3
+    puts "Programming u-boot, takes about 4-5 min for 256kb"
+    flash write_image ./images/u-boot.bin $EXP_CS0_BASEADDR
+}
\ No newline at end of file


Property changes on: trunk/tcl/target/c100config.tcl
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/c100helper.tcl
===================================================================
--- trunk/tcl/target/c100helper.tcl	2009-09-09 16:11:33 UTC (rev 2682)
+++ trunk/tcl/target/c100helper.tcl	2009-09-10 08:06:22 UTC (rev 2683)
@@ -0,0 +1,518 @@
+
+proc helpC100 {} {
+    puts "List of useful functions for C100 processor:"
+    puts "1)  reset init:        will set up your Telo board"
+    puts "2)  setupNOR:          will setup NOR access"
+    puts "3)  showNOR:           will show current NOR config registers for 16-bit, 16MB NOR"
+    puts "4)  setupGPIO:         will setup GPIOs for Telo board"
+    puts "5)  showGPIO:          will show current GPIO config registers"
+    puts "6)  highGPIO5:         will set GPIO5=NOR_addr22=1 to access upper 8MB"
+    puts "7)  lowGPIO5:          will set GPIO5=NOR_addr22=0 to access lower 8MB"
+    puts "8)  showAmbaClk:       will show current config registers for Amba Bus Clock"
+    puts "9)  setupAmbaClk:      will setup Amba Bus Clock=165MHz"
+    puts "10) showArmClk:        will show current config registers for Arm Bus Clock"
+    puts "11) setupArmClk:       will setup Amba Bus Clock=450MHz"
+    puts "12) ooma_board_detect: will show which version of Telo you have"
+    puts "13) setupDDR2:         will configure DDR2 controller, you must have PLLs configureg"
+    puts "14) showDDR2:          will show DDR2 config registers"
+    puts "15) showWatchdog:      will show current regster config for watchdog"
+    puts "16) reboot:            will trigger watchdog and reboot Telo (hw reset)"
+    puts "17) bootNOR:           will boot Telo from NOR"
+    puts "18) setupUART0:        will configure UART0 for 115200 8N1, PLLs have to be confiured"
+    puts "19) putcUART0:         will print a character on UART0"
+    puts "20) putsUART0:         will print a string on UART0"
+    puts "21) trainDDR2:          will run DDR2 training program"
+    puts "22) flashUBOOT:        will prgram NOR sectors 0-3 with u-boot.bin"
+}
+
+# mrw,mmw from davinci.cfg
+# mrw: "memory read word", returns value of $reg
+proc mrw {reg} {
+    set value ""
+    ocd_mem2array value 32 $reg 1
+    return $value(0)
+}
+
+# read a 64-bit register (memory mapped)
+proc mr64bit {reg} {
+    set value ""
+    ocd_mem2array value 32 $reg 2
+    return $value
+}
+
+
+# write a 64-bit register (memory mapped)
+proc mw64bit {reg value} {
+    set high [expr $value >> 32]
+    set low  [expr $value & 0xffffffff]
+    #puts [format "mw64bit(0x%x): 0x%08x%08x" $reg $high $low]
+    mww $reg $low
+    mww [expr $reg+4] $high
+}
+
+# mmw: "memory modify word", updates value of $reg
+#	$reg <== ((value & ~$clearbits) | $setbits)
+proc mmw {reg setbits clearbits} {
+    set old [mrw $reg]
+    set new [expr ($old & ~$clearbits) | $setbits]
+    mww $reg $new
+}
+
+
+proc showNOR {} {
+    puts "This is the current NOR setup"
+    set EX_CSEN_REG	    [regs EX_CSEN_REG ]	
+    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]	
+    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]	
+    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]	
+    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]	
+    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]	
+    set EX_CLOCK_DIV_REG    [regs EX_CLOCK_DIV_REG ]
+    set EX_MFSM_REG	    [regs EX_MFSM_REG ]	
+    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]	
+    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]	
+    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]	
+
+    puts [format "EX_CSEN_REG      (0x%x): 0x%x" $EX_CSEN_REG [mrw $EX_CSEN_REG]]
+    puts [format "EX_CS0_SEG_REG   (0x%x): 0x%x" $EX_CS0_SEG_REG [mrw $EX_CS0_SEG_REG]]
+    puts [format "EX_CS0_CFG_REG   (0x%x): 0x%x" $EX_CS0_CFG_REG [mrw $EX_CS0_CFG_REG]]
+    puts [format "EX_CS0_TMG1_REG  (0x%x): 0x%x" $EX_CS0_TMG1_REG [mrw $EX_CS0_TMG1_REG]]
+    puts [format "EX_CS0_TMG2_REG  (0x%x): 0x%x" $EX_CS0_TMG2_REG [mrw $EX_CS0_TMG2_REG]]
+    puts [format "EX_CS0_TMG3_REG  (0x%x): 0x%x" $EX_CS0_TMG3_REG [mrw $EX_CS0_TMG3_REG]]
+    puts [format "EX_CLOCK_DIV_REG (0x%x): 0x%x" $EX_CLOCK_DIV_REG [mrw $EX_CLOCK_DIV_REG]]
+    puts [format "EX_MFSM_REG      (0x%x): 0x%x" $EX_MFSM_REG [mrw $EX_MFSM_REG]]
+    puts [format "EX_CSFSM_REG     (0x%x): 0x%x" $EX_CSFSM_REG [mrw $EX_CSFSM_REG]]
+    puts [format "EX_WRFSM_REG     (0x%x): 0x%x" $EX_WRFSM_REG [mrw $EX_WRFSM_REG]]
+    puts [format "EX_RDFSM_REG     (0x%x): 0x%x" $EX_RDFSM_REG [mrw $EX_RDFSM_REG]]
+}
+
+
+
+proc showGPIO {} {
+    puts "This is the current GPIO register setup"
+    # GPIO outputs register
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]		
+    # GPIO Output Enable register
+    set GPIO_OE_REG		    [regs GPIO_OE_REG]		
+    set GPIO_HI_INT_ENABLE_REG	    [regs GPIO_HI_INT_ENABLE_REG]	
+    set GPIO_LO_INT_ENABLE_REG	    [regs GPIO_LO_INT_ENABLE_REG]	
+    # GPIO input register
+    set GPIO_INPUT_REG		    [regs GPIO_INPUT_REG]		
+    set APB_ACCESS_WS_REG	    [regs APB_ACCESS_WS_REG]	
+    set MUX_CONF_REG		    [regs MUX_CONF_REG]		
+    set SYSCONF_REG		    [regs SYSCONF_REG]		
+    set GPIO_ARM_ID_REG		    [regs GPIO_ARM_ID_REG]		
+    set GPIO_BOOTSTRAP_REG	    [regs GPIO_BOOTSTRAP_REG]	
+    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]		
+    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]		
+    set GPIO_DEVID_REG		    [regs GPIO_DEVID_REG]		
+
+    puts [format "GPIO_OUTPUT_REG       (0x%x): 0x%x" $GPIO_OUTPUT_REG [mrw $GPIO_OUTPUT_REG]]
+    puts [format "GPIO_OE_REG           (0x%x): 0x%x" $GPIO_OE_REG [mrw $GPIO_OE_REG]]
+    puts [format "GPIO_HI_INT_ENABLE_REG(0x%x): 0x%x" $GPIO_HI_INT_ENABLE_REG [mrw $GPIO_HI_INT_ENABLE_REG]]
+    puts [format "GPIO_LO_INT_ENABLE_REG(0x%x): 0x%x" $GPIO_LO_INT_ENABLE_REG [mrw $GPIO_LO_INT_ENABLE_REG]]
+    puts [format "GPIO_INPUT_REG        (0x%x): 0x%x" $GPIO_INPUT_REG [mrw $GPIO_INPUT_REG]]
+    puts [format "APB_ACCESS_WS_REG     (0x%x): 0x%x" $APB_ACCESS_WS_REG [mrw $APB_ACCESS_WS_REG]]
+    puts [format "MUX_CONF_REG          (0x%x): 0x%x" $MUX_CONF_REG [mrw $MUX_CONF_REG]]
+    puts [format "SYSCONF_REG           (0x%x): 0x%x" $SYSCONF_REG [mrw $SYSCONF_REG]]
+    puts [format "GPIO_ARM_ID_REG       (0x%x): 0x%x" $GPIO_ARM_ID_REG [mrw $GPIO_ARM_ID_REG]]
+    puts [format "GPIO_BOOTSTRAP_REG    (0x%x): 0x%x" $GPIO_BOOTSTRAP_REG [mrw $GPIO_BOOTSTRAP_REG]]
+    puts [format "GPIO_LOCK_REG         (0x%x): 0x%x" $GPIO_LOCK_REG [mrw $GPIO_LOCK_REG]]
+    puts [format "GPIO_IOCTRL_REG       (0x%x): 0x%x" $GPIO_IOCTRL_REG [mrw $GPIO_IOCTRL_REG]]
+    puts [format "GPIO_DEVID_REG        (0x%x): 0x%x" $GPIO_DEVID_REG [mrw $GPIO_DEVID_REG]]
+}
+
+
+
+# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_get_amba_clk())
+proc showAmbaClk {} {
+    set CFG_REFCLKFREQ		     [config CFG_REFCLKFREQ]
+    set CLKCORE_AHB_CLK_CNTRL	     [regs CLKCORE_AHB_CLK_CNTRL]
+    set PLL_CLK_BYPASS	             [regs PLL_CLK_BYPASS]
+    
+    puts [format "CLKCORE_AHB_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_AHB_CLK_CNTRL [mrw $CLKCORE_AHB_CLK_CNTRL]]
+    ocd_mem2array value 32 $CLKCORE_AHB_CLK_CNTRL 1
+    # see if the PLL is in bypass mode
+    set bypass [expr ($value(0) & $PLL_CLK_BYPASS) >> 24 ]
+    puts [format "PLL bypass bit: %d" $bypass]
+    if {$bypass == 1} {
+	puts [format "Amba Clk is set to REFCLK: %d (MHz)" [expr $CFG_REFCLKFREQ/1000000]]
+    } else {
+	# nope, extract x,y,w and compute the PLL output freq.
+	set x [expr ($value(0) & 0x0001F0000) >> 16]
+	puts [format "x: %d" $x]
+	set y [expr ($value(0) & 0x00000007F)]
+	puts [format "y: %d" $y]
+	set w [expr ($value(0) & 0x000000300) >> 8]
+	puts [format "w: %d" $w]
+	puts [format "Amba PLL Clk: %d (MHz)" [expr ($CFG_REFCLKFREQ * $y / (($w + 1) * ($x + 1) * 2))/1000000]]
+    }
+}
+
+
+# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_set_amba_clk())
+# this clock is useb by all peripherals (DDR2, ethernet, ebus, etc)
+proc setupAmbaClk {} {
+    set CLKCORE_PLL_STATUS           [regs CLKCORE_PLL_STATUS]       
+    set CLKCORE_AHB_CLK_CNTRL	     [regs CLKCORE_AHB_CLK_CNTRL]
+    set ARM_PLL_BY_CTRL	    [regs ARM_PLL_BY_CTRL]
+    set ARM_AHB_BYP	    [regs ARM_AHB_BYP]
+    set PLL_DISABLE	    [regs PLL_DISABLE]
+    set PLL_CLK_BYPASS	    [regs PLL_CLK_BYPASS]	
+    set AHB_PLL_BY_CTRL	    [regs AHB_PLL_BY_CTRL]	
+    set DIV_BYPASS	    [regs DIV_BYPASS]
+    set AHBCLK_PLL_LOCK	    [regs AHBCLK_PLL_LOCK]
+    set CFG_REFCLKFREQ		 [config CFG_REFCLKFREQ]
+    set CONFIG_SYS_HZ_CLOCK      [config CONFIG_SYS_HZ_CLOCK]
+    set w    [config w_amba]
+    set x    [config x_amba]
+    set y    [config y_amba]
+
+    puts [format "Setting Amba PLL to lock to %d MHz" [expr $CONFIG_SYS_HZ_CLOCK/1000000]]
+    #puts [format "setupAmbaClk: w= %d" $w]
+    #puts [format "setupAmbaClk: x= %d" $x]
+    #puts [format "setupAmbaClk: y= %d" $y]
+    # set PLL into BYPASS mode using MUX
+    mmw $CLKCORE_AHB_CLK_CNTRL $PLL_CLK_BYPASS 0x0
+    # do an internal PLL bypass
+    mmw $CLKCORE_AHB_CLK_CNTRL $AHB_PLL_BY_CTRL 0x0
+    # wait 500us (ARM running @24Mhz -> 12000 cycles => 500us)
+    # openocd smallest resolution is 1ms so, wait 1ms
+    sleep 1
+    # disable the PLL
+    mmw $CLKCORE_AHB_CLK_CNTRL $PLL_DISABLE 0x0
+    # wait 1ms
+    sleep 1
+    # enable the PLL
+    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 $PLL_DISABLE
+    sleep 1
+    # set X, W and X
+    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 0xFFFFFF
+    mmw $CLKCORE_AHB_CLK_CNTRL [expr (($x << 16) + ($w << 8) + $y)] 0x0
+    # wait for PLL to lock
+    puts "Wating for Amba PLL to lock"
+    while {[expr [mrw $CLKCORE_PLL_STATUS] & $AHBCLK_PLL_LOCK] == 0} { sleep 1 }
+    # remove the internal PLL bypass
+    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 $AHB_PLL_BY_CTRL
+    # remove PLL from BYPASS mode using MUX
+    mmw $CLKCORE_AHB_CLK_CNTRL 0x0 $PLL_CLK_BYPASS
+}
+
+
+# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_get_arm_clk())
+proc showArmClk {} {
+    set CFG_REFCLKFREQ		[config CFG_REFCLKFREQ]
+    set CLKCORE_ARM_CLK_CNTRL	[regs CLKCORE_ARM_CLK_CNTRL]
+    set PLL_CLK_BYPASS	        [regs PLL_CLK_BYPASS]
+    
+    puts [format "CLKCORE_ARM_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_ARM_CLK_CNTRL [mrw $CLKCORE_ARM_CLK_CNTRL]]
+    ocd_mem2array value 32 $CLKCORE_ARM_CLK_CNTRL 1
+    # see if the PLL is in bypass mode
+    set bypass [expr ($value(0) & $PLL_CLK_BYPASS) >> 24 ]
+    puts [format "PLL bypass bit: %d" $bypass]
+    if {$bypass == 1} {
+	puts [format "Amba Clk is set to REFCLK: %d (MHz)" [expr $CFG_REFCLKFREQ/1000000]]
+    } else {
+	# nope, extract x,y,w and compute the PLL output freq.
+	set x [expr ($value(0) & 0x0001F0000) >> 16]
+	puts [format "x: %d" $x]
+	set y [expr ($value(0) & 0x00000007F)]
+	puts [format "y: %d" $y]
+	set w [expr ($value(0) & 0x000000300) >> 8]
+	puts [format "w: %d" $w]
+	puts [format "Arm PLL Clk: %d (MHz)" [expr ($CFG_REFCLKFREQ * $y / (($w + 1) * ($x + 1) * 2))/1000000]]
+    }
+}
+
+# converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_set_arm_clk())
+# Arm Clock is used by two ARM1136 cores
+proc setupArmClk {} {
+    set CLKCORE_PLL_STATUS        [regs CLKCORE_PLL_STATUS]
+    set CLKCORE_ARM_CLK_CNTRL	  [regs CLKCORE_ARM_CLK_CNTRL]
+    set ARM_PLL_BY_CTRL	          [regs ARM_PLL_BY_CTRL]
+    set ARM_AHB_BYP	          [regs ARM_AHB_BYP]
+    set PLL_DISABLE	          [regs PLL_DISABLE]
+    set PLL_CLK_BYPASS	          [regs PLL_CLK_BYPASS]	
+    set AHB_PLL_BY_CTRL	          [regs AHB_PLL_BY_CTRL]	
+    set DIV_BYPASS	          [regs DIV_BYPASS]
+    set FCLK_PLL_LOCK	          [regs FCLK_PLL_LOCK]
+    set CFG_REFCLKFREQ		[config CFG_REFCLKFREQ]
+    set CFG_ARM_CLOCK		[config CFG_ARM_CLOCK]
+    set w    [config w_arm]
+    set x    [config x_arm]
+    set y    [config y_arm]
+
+    puts [format "Setting Arm PLL to lock to %d MHz" [expr $CFG_ARM_CLOCK/1000000]]
+    #puts [format "setupArmClk: w= %d" $w]
+    #puts [format "setupArmaClk: x= %d" $x]
+    #puts [format "setupArmaClk: y= %d" $y]
+    # set PLL into BYPASS mode using MUX
+    mmw $CLKCORE_ARM_CLK_CNTRL $PLL_CLK_BYPASS 0x0
+    # do an internal PLL bypass
+    mmw $CLKCORE_ARM_CLK_CNTRL $ARM_PLL_BY_CTRL 0x0
+    # wait 500us (ARM running @24Mhz -> 12000 cycles => 500us)
+    # openocd smallest resolution is 1ms so, wait 1ms
+    sleep 1
+    # disable the PLL
+    mmw $CLKCORE_ARM_CLK_CNTRL $PLL_DISABLE 0x0
+    # wait 1ms
+    sleep 1
+    # enable the PLL
+    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 $PLL_DISABLE
+    sleep 1
+    # set X, W and X
+    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 0xFFFFFF
+    mmw $CLKCORE_ARM_CLK_CNTRL [expr (($x << 16) + ($w << 8) + $y)] 0x0
+    # wait for PLL to lock
+    puts "Wating for Amba PLL to lock"
+    while {[expr [mrw $CLKCORE_PLL_STATUS] & $FCLK_PLL_LOCK] == 0} { sleep 1 }
+    # remove the internal PLL bypass
+    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 $ARM_PLL_BY_CTRL
+    # remove PLL from BYPASS mode using MUX
+    mmw $CLKCORE_ARM_CLK_CNTRL 0x0 $PLL_CLK_BYPASS
+}
+
+
+
+proc setupPLL {} {
+    puts "PLLs setup"
+    setupAmbaClk
+    setupArmClk
+}
+
+# converted from u-boot/cpu/arm1136/bsp100.c:SoC_mem_init()
+proc setupDDR2 {} {
+    puts "Configuring DDR2"
+    
+    set MEMORY_BASE_ADDR	    [regs  MEMORY_BASE_ADDR]
+    set MEMORY_MAX_ADDR	            [regs  MEMORY_MAX_ADDR]        
+    set MEMORY_CR 		    [regs  MEMORY_CR]
+    set BLOCK_RESET_REG		    [regs  BLOCK_RESET_REG]		
+    set DDR_RST		            [regs  DDR_RST]        
+
+    # put DDR controller in reset (so that it is reset and correctly configured)
+    # this is only necessary if DDR was previously confiured
+    # and not reset.
+    mmw $BLOCK_RESET_REG 0x0 $DDR_RST
+
+    set M [expr 1024 * 1024]
+    set DDR_SZ_1024M	[expr 1024 * $M]
+    set DDR_SZ_256M	[expr 256 * $M]
+    set DDR_SZ_128M	[expr 128 * $M]
+    set DDR_SZ_64M	[expr 64 * $M]
+    # ooma_board_detect returns DDR2 memory size
+    set tmp [ooma_board_detect]
+    if {$tmp == "128M"} {
+	puts "DDR2 size 128MB"
+	set ddr_size $DDR_SZ_128M
+    } elseif {$tmp == "256M"} {
+	puts "DDR2 size 256MB"
+	set ddr_size $DDR_SZ_256M
+    } else {
+	puts "Don't know how to handle this DDR2 size?"
+    }
+
+    # Memory setup register
+    mww $MEMORY_MAX_ADDR  [expr ($ddr_size - 1) + $MEMORY_BASE_ADDR]
+    # disbale ROM remap
+    mww $MEMORY_CR 0x0
+    # Take DDR controller out of reset
+    mmw $BLOCK_RESET_REG $DDR_RST 0x0
+    # min. 20 ops delay
+    sleep 1
+
+    # This will setup Denali DDR2 controller
+    if {$tmp == "128M"} {
+	configureDDR2regs_128M
+    } elseif {$tmp == "256M"} {
+	configureDDR2regs_256B
+    } else {
+	puts "Don't know how to configure DDR2 setup?"
+}
+
+
+
+proc showDDR2 {} {
+ 
+    set DENALI_CTL_00_DATA    [regs DENALI_CTL_00_DATA]
+    set DENALI_CTL_01_DATA    [regs DENALI_CTL_01_DATA]
+    set DENALI_CTL_02_DATA    [regs DENALI_CTL_02_DATA]
+    set DENALI_CTL_03_DATA    [regs DENALI_CTL_03_DATA]
+    set DENALI_CTL_04_DATA    [regs DENALI_CTL_04_DATA]
+    set DENALI_CTL_05_DATA    [regs DENALI_CTL_05_DATA]
+    set DENALI_CTL_06_DATA    [regs DENALI_CTL_06_DATA]
+    set DENALI_CTL_07_DATA    [regs DENALI_CTL_07_DATA]
+    set DENALI_CTL_08_DATA    [regs DENALI_CTL_08_DATA]
+    set DENALI_CTL_09_DATA    [regs DENALI_CTL_09_DATA]
+    set DENALI_CTL_10_DATA    [regs DENALI_CTL_10_DATA]
+    set DENALI_CTL_11_DATA    [regs DENALI_CTL_11_DATA]
+    set DENALI_CTL_12_DATA    [regs DENALI_CTL_12_DATA]
+    set DENALI_CTL_13_DATA    [regs DENALI_CTL_13_DATA]
+    set DENALI_CTL_14_DATA    [regs DENALI_CTL_14_DATA]
+    set DENALI_CTL_15_DATA    [regs DENALI_CTL_15_DATA]
+    set DENALI_CTL_16_DATA    [regs DENALI_CTL_16_DATA]
+    set DENALI_CTL_17_DATA    [regs DENALI_CTL_17_DATA]
+    set DENALI_CTL_18_DATA    [regs DENALI_CTL_18_DATA]
+    set DENALI_CTL_19_DATA    [regs DENALI_CTL_19_DATA]
+    set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]
+
+    set tmp [mr64bit $DENALI_CTL_00_DATA]
+    puts [format "DENALI_CTL_00_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_00_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_01_DATA]
+    puts [format "DENALI_CTL_01_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_01_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_02_DATA]
+    puts [format "DENALI_CTL_02_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_02_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_03_DATA]
+    puts [format "DENALI_CTL_03_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_03_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_04_DATA]
+    puts [format "DENALI_CTL_04_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_04_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_05_DATA]
+    puts [format "DENALI_CTL_05_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_05_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_06_DATA]
+    puts [format "DENALI_CTL_06_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_06_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_07_DATA]
+    puts [format "DENALI_CTL_07_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_07_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_08_DATA]
+    puts [format "DENALI_CTL_08_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_08_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_09_DATA]
+    puts [format "DENALI_CTL_09_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_09_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_10_DATA]
+    puts [format "DENALI_CTL_10_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_10_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_11_DATA]
+    puts [format "DENALI_CTL_11_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_11_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_12_DATA]
+    puts [format "DENALI_CTL_12_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_12_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_13_DATA]
+    puts [format "DENALI_CTL_13_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_13_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_14_DATA]
+    puts [format "DENALI_CTL_14_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_14_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_15_DATA]
+    puts [format "DENALI_CTL_15_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_15_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_16_DATA]
+    puts [format "DENALI_CTL_16_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_16_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_17_DATA]
+    puts [format "DENALI_CTL_17_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_17_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_18_DATA]
+    puts [format "DENALI_CTL_18_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_18_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_19_DATA]
+    puts [format "DENALI_CTL_19_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_19_DATA $tmp(1) $tmp(0)]
+    set tmp [mr64bit $DENALI_CTL_20_DATA]
+    puts [format "DENALI_CTL_20_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_20_DATA $tmp(1) $tmp(0)]
+    
+}
+
+proc initC100 {} {
+    # this follows u-boot/cpu/arm1136/start.S 
+    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]		
+    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]		
+    set GPIO_IOCTRL_VAL	            [regs GPIO_IOCTRL_VAL]	
+    set APB_ACCESS_WS_REG           [regs APB_ACCESS_WS_REG]
+    set ASA_ARAM_BASEADDR	    [regs ASA_ARAM_BASEADDR]
+    set ASA_ARAM_TC_CR_REG	    [regs ASA_ARAM_TC_CR_REG]	
+    set ASA_EBUS_BASEADDR	    [regs ASA_EBUS_BASEADDR]
+    set ASA_EBUS_TC_CR_REG	    [regs ASA_EBUS_TC_CR_REG]	
+    set ASA_TC_REQIDMAEN	    [regs ASA_TC_REQIDMAEN]
+    set ASA_TC_REQTDMEN	            [regs ASA_TC_REQTDMEN]        
+    set ASA_TC_REQIPSECUSBEN        [regs ASA_TC_REQIPSECUSBEN]    
+    set ASA_TC_REQARM0EN	    [regs ASA_TC_REQARM0EN]
+    set ASA_TC_REQARM1EN	    [regs ASA_TC_REQARM1EN]
+    set ASA_TC_REQMDMAEN	    [regs ASA_TC_REQMDMAEN]
+    set INTC_ARM1_CONTROL_REG       [regs INTC_ARM1_CONTROL_REG]
+
+
+    # unlock writing to IOCTRL register
+    mww $GPIO_LOCK_REG $GPIO_IOCTRL_VAL
+    # enable address lines A15-A21
+    mmw $GPIO_IOCTRL_REG 0xf 0x0
+    # set ARM into supervisor mode (SVC32)
+    # disable IRQ, FIQ
+    # Do I need this in JTAG mode?
+    # it really should be done as 'and ~0x1f | 0xd3 but 
+    # openocd does not support this yet
+    reg cpsr 0xd3
+    #	/*
+    #	 * flush v4 I/D caches
+    #	 */
+    #	mov	r0, #0
+    #	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
+    arm11 mcr c100.cpu 15 0 7 7 0 0x0
+    #	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
+    arm11 mcr c100.cpu 15 0 8 7 0 0x0
+
+    #	/*
+    #	 * disable MMU stuff and caches
+    #	 */
+    #	mrc	p15, 0, r0, c1, c0, 0
+    arm11 mrc c100.cpu 15 0 1 0 0  
+    #	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
+    #	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
+    #	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
+    #	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
+    #	orr	r0, r0, #0x00400000	@ set bit 22 (U) 
+    #	mcr	p15, 0, r0, c1, c0, 0
+    arm11 mcr c100.cpu 15 0 1 0 0 0x401002
+    # This is from bsp_init() in u-boot/boards/mindspeed/ooma-darwin/board.c
+    # APB init
+    #    	// Setting APB Bus Wait states to 1, set post write
+    #	(*(volatile u32*)(APB_ACCESS_WS_REG)) = 0x40;
+    mww [expr $APB_ACCESS_WS_REG] 0x40
+    # AHB init
+    #	// enable all 6 masters for ARAM
+    mmw $ASA_ARAM_TC_CR_REG [expr $ASA_TC_REQIDMAEN | $ASA_TC_REQTDMEN | $ASA_TC_REQIPSECUSBEN | $ASA_TC_REQARM0EN | $ASA_TC_REQARM1EN | $ASA_TC_REQMDMAEN] 0x0
+    #	// enable all 6 masters for EBUS
+    mmw $ASA_EBUS_TC_CR_REG [expr $ASA_TC_REQIDMAEN | $ASA_TC_REQTDMEN | $ASA_TC_REQIPSECUSBEN | $ASA_TC_REQARM0EN | $ASA_TC_REQARM1EN | $ASA_TC_REQMDMAEN] 0x0
+
+    # ARAM init
+    #	// disable pipeline mode in ARAM 
+    # I don't think this is documented anywhere?
+    mww $INTC_ARM1_CONTROL_REG 0x1
+    # configure clocks 
+    setupPLL
+    # enable cache
+    # ? (u-boot does nothing here)
+    # DDR2 memory init
+    setupDDR2
+    setupUART0
+    putsUART0 "C100 initialization complete.\n"
+    puts "C100 initialization complete."
+}
+
+# show current state of watchdog timer
+proc showWatchdog {} {
+    set TIMER_WDT_HIGH_BOUND	[regs TIMER_WDT_HIGH_BOUND]
+    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]	
+    set TIMER_WDT_CURRENT_COUNT	[regs TIMER_WDT_CURRENT_COUNT]
+    
+    puts [format "TIMER_WDT_HIGH_BOUND    (0x%x): 0x%x" $TIMER_WDT_HIGH_BOUND [mrw $TIMER_WDT_HIGH_BOUND]]
+    puts [format "TIMER_WDT_CONTROL       (0x%x): 0x%x" $TIMER_WDT_CONTROL [mrw $TIMER_WDT_CONTROL]]
+    puts [format "TIMER_WDT_CURRENT_COUNT (0x%x): 0x%x" $TIMER_WDT_CURRENT_COUNT [mrw $TIMER_WDT_CURRENT_COUNT]]
+}
+
+# converted from u-boot/cpu/arm1136/comcerto/intrrupts.c:void reset_cpu (ulong ignored)
+# this will trigger watchdog reset
+# the sw. reset does not work on C100
+# watchdog reset effectively works as hw. reset
+proc reboot {} {
+    set TIMER_WDT_HIGH_BOUND	[regs TIMER_WDT_HIGH_BOUND]
+    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]	
+    set TIMER_WDT_CURRENT_COUNT	[regs TIMER_WDT_CURRENT_COUNT]
+
+    # allow the counter to count to high value  before triggering
+    # this is because regsiter writes are slow over JTAG and
+    # I don't want to miss the high_bound==curr_count condition
+    mww $TIMER_WDT_HIGH_BOUND  0xffffff
+    mww $TIMER_WDT_CURRENT_COUNT 0x0
+    puts "JTAG speed lowered to 100kHz"
+    jtag_khz 100
+    mww $TIMER_WDT_CONTROL 0x1
+    # wait until the reset
+    puts -nonewline "Wating for watchdog to trigger..."
+    #while {[mrw $TIMER_WDT_CONTROL] == 1} { 
+    #    puts [format "TIMER_WDT_CURRENT_COUNT (0x%x): 0x%x" $TIMER_WDT_CURRENT_COUNT [mrw $TIMER_WDT_CURRENT_COUNT]]	    
+    #    sleep 1 
+    #    
+    #}
+    while {[c100.cpu curstate] != "running"} { sleep 1}
+    puts "done."
+    puts [format "Note that C100 is in %s state, type halt to stop" [c100.cpu curstate]]
+}


Property changes on: trunk/tcl/target/c100helper.tcl
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/c100regs.tcl
===================================================================
--- trunk/tcl/target/c100regs.tcl	2009-09-09 16:11:33 UTC (rev 2682)
+++ trunk/tcl/target/c100regs.tcl	2009-09-10 08:06:22 UTC (rev 2683)
@@ -0,0 +1,493 @@
+# Note that I basically converted
+# u-boot/include/asm-arm/arch/comcerto_100.h
+# defines
+
+# this is a work-around for 'global' not working under Linux
+# access registers by calling this routine.
+# For example:
+# set EX_CS_TMG1_REG [regs EX_CS0_TMG1_REG]
+proc regs {reg} {
+    return [dict get [regsC100] $reg ]	
+}
+
+proc showreg {reg} {
+    puts [format "0x%x" [dict get [regsC100] $reg ]]
+}
+
+proc regsC100 {} {
+#/* memcore */
+#/* device memory base addresses */
+#// device memory sizes
+#/* ARAM SIZE=64K */
+dict set regsC100 ARAM_SIZE		0x00010000 
+dict set regsC100 ARAM_BASEADDR	0x0A000000
+
+#/* Hardware Interface Units */
+dict set regsC100 APB_BASEADDR	0x10000000
+#/* APB_SIZE=16M address range */
+dict set regsC100 APB_SIZE		0x01000000 
+
+dict set regsC100 EXP_CS0_BASEADDR       0x20000000
+dict set regsC100 EXP_CS1_BASEADDR       0x24000000
+dict set regsC100 EXP_CS2_BASEADDR       0x28000000
+dict set regsC100 EXP_CS3_BASEADDR       0x2C000000
+dict set regsC100 EXP_CS4_BASEADDR       0x30000000
+
+dict set regsC100 DDR_BASEADDR           0x80000000
+
+dict set regsC100 TDM_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x000000]
+dict set regsC100 PHI_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x010000]
+dict set regsC100 TDMA_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x020000]
+dict set regsC100 ASA_DDR_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x040000]
+dict set regsC100 ASA_ARAM_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x048000]
+dict set regsC100 TIMER_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x050000]
+dict set regsC100 ASD_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x060000]
+dict set regsC100 GPIO_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x070000]
+dict set regsC100 UART0_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x090000]
+dict set regsC100 UART1_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x094000]
+dict set regsC100 SPI_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x098000]
+dict set regsC100 I2C_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x09C000]
+dict set regsC100 INTC_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0A0000]
+dict set regsC100 CLKCORE_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x0B0000]
+dict set regsC100 PUI_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0B0000]
+dict set regsC100 GEMAC_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0D0000]
+dict set regsC100 IDMA_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x0E0000]
+dict set regsC100 MEMCORE_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x0F0000]
+dict set regsC100 ASA_EBUS_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x100000]
+dict set regsC100 ASA_AAB_BASEADDR	        [expr [dict get $regsC100 APB_BASEADDR ] + 0x108000]
+dict set regsC100 GEMAC1_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x190000]
+dict set regsC100 EBUS_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x1A0000]
+dict set regsC100 MDMA_BASEADDR		[expr [dict get $regsC100 APB_BASEADDR ] + 0x1E0000]
+
+
+#////////////////////////////////////////////////////////////
+#//	AHB block											    //
+#////////////////////////////////////////////////////////////
+dict set regsC100 ASA_ARAM_PRI_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x00]
+dict set regsC100 ASA_ARAM_TC_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x04]
+dict set regsC100 ASA_ARAM_TC_CR_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x08]
+dict set regsC100 ASA_ARAM_STAT_REG	[expr [dict get $regsC100 ASA_ARAM_BASEADDR ] + 0x0C]
+
+dict set regsC100 ASA_EBUS_PRI_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x00]
+dict set regsC100 ASA_EBUS_TC_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x04]
+dict set regsC100 ASA_EBUS_TC_CR_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x08]
+dict set regsC100 ASA_EBUS_STAT_REG	[expr [dict get $regsC100 ASA_EBUS_BASEADDR ] + 0x0C]
+
+dict set regsC100 IDMA_MASTER		0
+dict set regsC100 TDMA_MASTER		1
+dict set regsC100 USBIPSEC_MASTER	2
+dict set regsC100 ARM0_MASTER		3
+dict set regsC100 ARM1_MASTER		4
+dict set regsC100 MDMA_MASTER		5
+
+#define IDMA_PRIORITY(level) (level)
+#define TDM_PRIORITY(level) (level << 4)
+#define USBIPSEC_PRIORITY(level) (level << 8)
+#define ARM0_PRIORITY(level) (level << 12)
+#define ARM1_PRIORITY(level) (level << 16)
+#define MDMA_PRIORITY(level) (level << 20)
+
+dict set regsC100 ASA_TC_REQIDMAEN	 [expr 1<<18]
+dict set regsC100 ASA_TC_REQTDMEN	 [expr 1<<19]
+dict set regsC100 ASA_TC_REQIPSECUSBEN [expr 1<<20]
+dict set regsC100 ASA_TC_REQARM0EN	 [expr 1<<21]
+dict set regsC100 ASA_TC_REQARM1EN	 [expr 1<<22]
+dict set regsC100 ASA_TC_REQMDMAEN	 [expr 1<<23]
+
+dict set regsC100 MEMORY_BASE_ADDR	0x80000000
+dict set regsC100 MEMORY_MAX_ADDR	[expr [dict get $regsC100 ASD_BASEADDR ] + 0x10]
+dict set regsC100 MEMORY_CR 		[expr [dict get $regsC100 ASD_BASEADDR ] + 0x14]
+dict set regsC100 ROM_REMAP_EN	0x1
+
+#define HAL_asb_priority(level) \
+#*(volatile unsigned *)ASA_PRI_REG = level
+
+#define HAL_aram_priority(level) \
+#*(volatile unsigned *)ASA_ARAM_PRI_REG = level
+
+#define HAL_aram_arbitration(arbitration_mask) \
+#*(volatile unsigned *)ASA_ARAM_TC_CR_REG |= arbitration_mask
+
+#define HAL_aram_defmaster(mask) \
+#*(volatile unsigned *)ASA_ARAM_TC_CR_REG = (*(volatile unsigned *)ASA_TC_CR_REG & 0xFFFF) | (mask << 24)
+
+#////////////////////////////////////////////////////////////
+#// INTC block						  //
+#////////////////////////////////////////////////////////////
+
+dict set regsC100 INTC_ARM1_CONTROL_REG	[expr [dict get $regsC100 INTC_BASEADDR ] + 0x18]
+
+#////////////////////////////////////////////////////////////
+#// TIMER block						  //
+#////////////////////////////////////////////////////////////
+
+dict set regsC100 TIMER0_CNTR_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x00]
+dict set regsC100 TIMER0_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x04]
+dict set regsC100 TIMER1_CNTR_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x08]
+dict set regsC100 TIMER1_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x0C]
+
+dict set regsC100 TIMER2_CNTR_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x18]
+dict set regsC100 TIMER2_LBOUND_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x10]
+dict set regsC100 TIMER2_HBOUND_REG	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x14]
+dict set regsC100 TIMER2_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x1C]
+
+dict set regsC100 TIMER3_LOBND	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x20]
+dict set regsC100 TIMER3_HIBND	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x24]
+dict set regsC100 TIMER3_CTRL		[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x28]
+dict set regsC100 TIMER3_CURR_COUNT	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x2C]
+
+dict set regsC100 TIMER_MASK		[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x40]
+dict set regsC100 TIMER_STATUS	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x50]
+dict set regsC100 TIMER_ACK		[expr [dict get $regsC100 TIMER_BASEADDR ] + 0x50]
+dict set regsC100 TIMER_WDT_HIGH_BOUND [expr [dict get $regsC100 TIMER_BASEADDR ] + 0xD0]
+dict set regsC100 TIMER_WDT_CONTROL	[expr [dict get $regsC100 TIMER_BASEADDR ] + 0xD4]
+dict set regsC100 TIMER_WDT_CURRENT_COUNT [expr [dict get $regsC100 TIMER_BASEADDR ] + 0xD8]
+
+
+
+#////////////////////////////////////////////////////////////
+#//  EBUS block
+#////////////////////////////////////////////////////////////
+
+dict set regsC100 EX_SWRST_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x00]
+dict set regsC100 EX_CSEN_REG		        [expr [dict get $regsC100 EBUS_BASEADDR ] + 0x04]
+dict set regsC100 EX_CS0_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x08]
+dict set regsC100 EX_CS1_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x0C]
+dict set regsC100 EX_CS2_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x10]
+dict set regsC100 EX_CS3_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x14]
+dict set regsC100 EX_CS4_SEG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x18]
+dict set regsC100 EX_CS0_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x1C]
+dict set regsC100 EX_CS1_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x20]
+dict set regsC100 EX_CS2_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x24]
+dict set regsC100 EX_CS3_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x28]
+dict set regsC100 EX_CS4_CFG_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x2C]
+dict set regsC100 EX_CS0_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x30]
+dict set regsC100 EX_CS1_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x34]
+dict set regsC100 EX_CS2_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x38]
+dict set regsC100 EX_CS3_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x3C]
+dict set regsC100 EX_CS4_TMG1_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x40]
+dict set regsC100 EX_CS0_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x44]
+dict set regsC100 EX_CS1_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x48]
+dict set regsC100 EX_CS2_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x4C]
+dict set regsC100 EX_CS3_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x50]
+dict set regsC100 EX_CS4_TMG2_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x54]
+dict set regsC100 EX_CS0_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x58]
+dict set regsC100 EX_CS1_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x5C]
+dict set regsC100 EX_CS2_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x60]
+dict set regsC100 EX_CS3_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x64]
+dict set regsC100 EX_CS4_TMG3_REG		[expr [dict get $regsC100 EBUS_BASEADDR ] + 0x68]
+dict set regsC100 EX_CLOCK_DIV_REG	        [expr [dict get $regsC100 EBUS_BASEADDR ] + 0x6C]
+
+dict set regsC100 EX_MFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x100]
+dict set regsC100 EX_MFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x100]
+dict set regsC100 EX_CSFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x104]
+dict set regsC100 EX_WRFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x108]
+dict set regsC100 EX_RDFSM_REG		[expr [dict get $regsC100 EBUS_BASEADDR] + 0x10C]
+
+
+dict set regsC100 EX_CLK_EN		0x00000001
+dict set regsC100 EX_CSBOOT_EN	0x00000002
+dict set regsC100 EX_CS0_EN		0x00000002
+dict set regsC100 EX_CS1_EN		0x00000004
+dict set regsC100 EX_CS2_EN		0x00000008
+dict set regsC100 EX_CS3_EN		0x00000010
+dict set regsC100 EX_CS4_EN		0x00000020
+
+dict set regsC100 EX_MEM_BUS_8	0x00000000
+dict set regsC100 EX_MEM_BUS_16       0x00000002
+dict set regsC100 EX_MEM_BUS_32	0x00000004
+dict set regsC100 EX_CS_HIGH		0x00000008
+dict set regsC100 EX_WE_HIGH		0x00000010
+dict set regsC100 EX_RE_HIGH		0x00000020
+dict set regsC100 EX_ALE_MODE		0x00000040
+dict set regsC100 EX_STRB_MODE	0x00000080
+dict set regsC100 EX_DM_MODE		0x00000100
+dict set regsC100 EX_NAND_MODE	0x00000200
+dict set regsC100 EX_RDY_EN		0x00000400
+dict set regsC100 EX_RDY_EDGE		0x00000800
+
+#////////////////////////////////////////////////////////////
+#//  GPIO block
+#////////////////////////////////////////////////////////////
+
+# GPIO outputs register
+dict set regsC100 GPIO_OUTPUT_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x00]
+# GPIO Output Enable register	
+dict set regsC100 GPIO_OE_REG		        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x04]
+dict set regsC100 GPIO_HI_INT_ENABLE_REG	[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x08]
+dict set regsC100 GPIO_LO_INT_ENABLE_REG	[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x0C]
+# GPIO input register
+dict set regsC100 GPIO_INPUT_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x10]
+dict set regsC100 APB_ACCESS_WS_REG	        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x14]
+dict set regsC100 MUX_CONF_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x18]
+dict set regsC100 SYSCONF_REG		        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x1C]
+dict set regsC100 GPIO_ARM_ID_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x30]
+dict set regsC100 GPIO_BOOTSTRAP_REG	        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x40]
+dict set regsC100 GPIO_LOCK_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x38]
+dict set regsC100 GPIO_IOCTRL_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x44]
+dict set regsC100 GPIO_DEVID_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x50]
+
+dict set regsC100 GPIO_IOCTRL_A15A16	0x00000001
+dict set regsC100 GPIO_IOCTRL_A17A18	0x00000002
+dict set regsC100 GPIO_IOCTRL_A19A21	0x00000004
+dict set regsC100 GPIO_IOCTRL_TMREVT0	0x00000008
+dict set regsC100 GPIO_IOCTRL_TMREVT1	0x00000010
+dict set regsC100 GPIO_IOCTRL_GPBT3	0x00000020
+dict set regsC100 GPIO_IOCTRL_I2C	0x00000040
+dict set regsC100 GPIO_IOCTRL_UART0	0x00000080
+dict set regsC100 GPIO_IOCTRL_UART1	0x00000100
+dict set regsC100 GPIO_IOCTRL_SPI	0x00000200
+dict set regsC100 GPIO_IOCTRL_HBMODE	0x00000400
+
+dict set regsC100 GPIO_IOCTRL_VAL	0x55555555
+
+dict set regsC100 GPIO_0			0x01
+dict set regsC100 GPIO_1			0x02
+dict set regsC100 GPIO_2			0x04
+dict set regsC100 GPIO_3			0x08
+dict set regsC100 GPIO_4			0x10
+dict set regsC100 GPIO_5			0x20
+dict set regsC100 GPIO_6			0x40
+dict set regsC100 GPIO_7			0x80
+
+dict set regsC100 GPIO_RISING_EDGE	1
+dict set regsC100 GPIO_FALLING_EDGE	2
+dict set regsC100 GPIO_BOTH_EDGES	3
+
+#////////////////////////////////////////////////////////////
+#// UART
+#////////////////////////////////////////////////////////////
+
+dict set regsC100 UART0_RBR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x00]
+dict set regsC100 UART0_THR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x00]
+dict set regsC100 UART0_DLL		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x00]
+dict set regsC100 UART0_IER		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x04]
+dict set regsC100 UART0_DLH		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x04]
+dict set regsC100 UART0_IIR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x08]
+dict set regsC100 UART0_FCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x08]
+dict set regsC100 UART0_LCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x0C]
+dict set regsC100 UART0_MCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x10]
+dict set regsC100 UART0_LSR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x14]
+dict set regsC100 UART0_MSR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x18]
+dict set regsC100 UART0_SCR		[expr [dict get $regsC100 UART0_BASEADDR ] + 0x1C]
+
+dict set regsC100 UART1_RBR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x00]
+dict set regsC100 UART1_THR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x00]
+dict set regsC100 UART1_DLL		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x00]
+dict set regsC100 UART1_IER		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x04]
+dict set regsC100 UART1_DLH		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x04]
+dict set regsC100 UART1_IIR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x08]
+dict set regsC100 UART1_FCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x08]
+dict set regsC100 UART1_LCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x0C]
+dict set regsC100 UART1_MCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x10]
+dict set regsC100 UART1_LSR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x14]
+dict set regsC100 UART1_MSR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x18]
+dict set regsC100 UART1_SCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x1C]
+
+# /* default */
+dict set regsC100 LCR_CHAR_LEN_5		0x00	  
+dict set regsC100 LCR_CHAR_LEN_6		0x01
+dict set regsC100 LCR_CHAR_LEN_7		0x02
+dict set regsC100 LCR_CHAR_LEN_8		0x03
+#/* One stop bit! - default */
+dict set regsC100 LCR_ONE_STOP		0x00
+#/* Two stop bit! */	  
+dict set regsC100 LCR_TWO_STOP		0x04	  
+#/* Parity Enable */
+dict set regsC100 LCR_PEN			0x08	  
+dict set regsC100 LCR_PARITY_NONE		0x00
+#/* Even Parity Select */
+dict set regsC100 LCR_EPS			0x10	  
+#/* Enable Parity  Stuff */
+dict set regsC100 LCR_PS			0x20	  
+#/* Start Break */
+dict set regsC100 LCR_SBRK		        0x40  
+#/* Parity Stuff Bit */
+dict set regsC100 LCR_PSB			0x80	  
+#/* UART 16550 Divisor Latch Assess */
+dict set regsC100 LCR_DLAB		        0x80  
+
+#/* FIFO Error Status */
+dict set regsC100 LSR_FIFOE		[expr 1 << 7]	
+#/* Transmitter Empty */
+dict set regsC100 LSR_TEMT		[expr 1 << 6]
+#/* Transmit Data Request */
+dict set regsC100 LSR_TDRQ		[expr 1 << 5]	
+#/* Break Interrupt */
+dict set regsC100 LSR_BI			[expr 1 << 4]	
+#/* Framing Error */
+dict set regsC100 LSR_FE			[expr 1 << 3]	
+#/* Parity Error */
+dict set regsC100 LSR_PE			[expr 1 << 2]	
+#/* Overrun Error */
+dict set regsC100 LSR_OE			[expr 1 << 1]	
+#/* Data Ready */
+dict set regsC100 LSR_DR			[expr 1 << 0]	
+
+#/* DMA Requests Enable */
+dict set regsC100 IER_DMAE		        [expr 1 << 7]	
+#/* UART Unit Enable */
+dict set regsC100 IER_UUE			[expr 1 << 6]	
+#/* NRZ coding Enable */
+dict set regsC100 IER_NRZE		        [expr 1 << 5]	
+#/* Receiver Time Out Interrupt Enable */
+dict set regsC100 IER_RTIOE		        [expr 1 << 4]	
+#/* Modem Interrupt Enable */
+dict set regsC100 IER_MIE			[expr 1 << 3]	
+#/* Receiver Line Status Interrupt Enable */
+dict set regsC100 IER_RLSE		        [expr 1 << 2]	
+#/* Transmit Data request Interrupt Enable */
+dict set regsC100 IER_TIE			[expr 1 << 1]	
+#/* Receiver Data Available Interrupt Enable */
+dict set regsC100 IER_RAVIE		        [expr 1 << 0]	
+
+#/* FIFO Mode Enable Status */
+dict set regsC100 IIR_FIFOES1		        [expr 1 << 7]	
+#/* FIFO Mode Enable Status */
+dict set regsC100 IIR_FIFOES0		        [expr 1 << 6]	
+#/* Time Out Detected */
+dict set regsC100 IIR_TOD			[expr 1 << 3]	
+#/* Interrupt Source Encoded */
+dict set regsC100 IIR_IID2		        [expr 1 << 2]	
+#/* Interrupt Source Encoded */
+dict set regsC100 IIR_IID1		        [expr 1 << 1]	
+#/* Interrupt Pending (active low) */
+dict set regsC100 IIR_IP			[expr 1 << 0]	
+
+#/* UART 16550 FIFO Control Register */
+dict set regsC100 FCR_FIFOEN		0x01
+dict set regsC100 FCR_RCVRRES		0x02
+dict set regsC100 FCR_XMITRES		0x04
+
+#/* Interrupt Enable Register */
+#// UART 16550
+#// Enable Received Data Available Interrupt
+dict set regsC100 IER_RXTH		0x01	
+#// Enable Transmitter Empty Interrupt
+dict set regsC100 IER_TXTH		0x02	
+
+
+
+#////////////////////////////////////////////////////////////
+#// CLK  + RESET block 
+#////////////////////////////////////////////////////////////
+
+dict set regsC100 CLKCORE_ARM_CLK_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x00]
+dict set regsC100 CLKCORE_AHB_CLK_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x04]
+dict set regsC100 CLKCORE_PLL_STATUS	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x08]
+dict set regsC100 CLKCORE_CLKDIV_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x0C]
+dict set regsC100 CLKCORE_TDM_CLK_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x10]
+dict set regsC100 CLKCORE_FSYNC_CNTRL	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x14]
+dict set regsC100 CLKCORE_CLK_PWR_DWN	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x18]
+dict set regsC100 CLKCORE_RNG_CNTRL	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x1C]
+dict set regsC100 CLKCORE_RNG_STATUS	        [expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x20]
+dict set regsC100 CLKCORE_ARM_CLK_CNTRL2	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x24]
+dict set regsC100 CLKCORE_TDM_REF_DIV_RST	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x40]
+
+dict set regsC100 ARM_PLL_BY_CTRL	0x80000000
+dict set regsC100 ARM_AHB_BYP		0x04000000
+dict set regsC100 PLL_DISABLE		0x02000000
+dict set regsC100 PLL_CLK_BYPASS	0x01000000
+
+dict set regsC100 AHB_PLL_BY_CTRL	0x80000000
+dict set regsC100 DIV_BYPASS		0x40000000
+dict set regsC100 SYNC_MODE		0x20000000
+
+dict set regsC100 EPHY_CLKDIV_BYPASS	0x00200000
+dict set regsC100 EPHY_CLKDIV_RATIO_SHIFT	16
+dict set regsC100 PUI_CLKDIV_BYPASS	0x00004000
+dict set regsC100 PUI_CLKDIV_SRCCLK	0x00002000
+dict set regsC100 PUI_CLKDIV_RATIO_SHIFT	8
+dict set regsC100 PCI_CLKDIV_BYPASS	0x00000020
+dict set regsC100 PCI_CLKDIV_RATIO_SHIFT	0
+
+dict set regsC100 ARM0_CLK_PD		0x00200000
+dict set regsC100 ARM1_CLK_PD		0x00100000
+dict set regsC100 EPHY_CLK_PD		0x00080000
+dict set regsC100 TDM_CLK_PD		0x00040000
+dict set regsC100 PUI_CLK_PD		0x00020000
+dict set regsC100 PCI_CLK_PD		0x00010000
+dict set regsC100 MDMA_AHBCLK_PD	0x00000400
+dict set regsC100 I2CSPI_AHBCLK_PD	0x00000200
+dict set regsC100 UART_AHBCLK_PD	0x00000100
+dict set regsC100 IPSEC_AHBCLK_PD	0x00000080
+dict set regsC100 TDM_AHBCLK_PD	0x00000040
+dict set regsC100 USB1_AHBCLK_PD	0x00000020
+dict set regsC100 USB0_AHBCLK_PD	0x00000010
+dict set regsC100 GEMAC1_AHBCLK_PD	0x00000008
+dict set regsC100 GEMAC0_AHBCLK_PD	0x00000004
+dict set regsC100 PUI_AHBCLK_PD	0x00000002
+dict set regsC100 HIF_AHBCLK_PD	0x00000001
+
+dict set regsC100 ARM1_DIV_BP		0x00001000
+dict set regsC100 ARM1_DIV_VAL_SHIFT	8
+dict set regsC100 ARM0_DIV_BP		0x00000010
+dict set regsC100 ARM0_DIV_VAL_SHIFT	0
+
+dict set regsC100 AHBCLK_PLL_LOCK	0x00000002
+dict set regsC100 FCLK_PLL_LOCK	0x00000001
+
+
+#// reset block
+dict set regsC100 BLOCK_RESET_REG		[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x100]
+dict set regsC100 CSP_RESET_REG		[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x104]
+
+dict set regsC100 RNG_RST		0x1000
+dict set regsC100 IPSEC_RST		0x0800
+dict set regsC100 DDR_RST		0x0400
+dict set regsC100 USB1_PHY_RST	0x0200
+dict set regsC100 USB0_PHY_RST	0x0100
+dict set regsC100 USB1_RST		0x0080
+dict set regsC100 USB0_RST		0x0040
+dict set regsC100 GEMAC1_RST		0x0020
+dict set regsC100 GEMAC0_RST		0x0010
+dict set regsC100 TDM_RST		0x0008
+dict set regsC100 PUI_RST		0x0004
+dict set regsC100 HIF_RST		0x0002
+dict set regsC100 PCI_RST		0x0001
+
+#////////////////////////////////////////////////////////////////
+#//	DDR  CONTROLLER block
+#////////////////////////////////////////////////////////////////
+
+dict set regsC100 DDR_CONFIG_BASEADDR	0x0D000000
+dict set regsC100 DENALI_CTL_00_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x00]
+dict set regsC100 DENALI_CTL_01_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x08]
+dict set regsC100 DENALI_CTL_02_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x10]
+dict set regsC100 DENALI_CTL_03_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x18]
+dict set regsC100 DENALI_CTL_04_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x20]
+dict set regsC100 DENALI_CTL_05_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x28]
+dict set regsC100 DENALI_CTL_06_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x30]
+dict set regsC100 DENALI_CTL_07_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x38]
+dict set regsC100 DENALI_CTL_08_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x40]
+dict set regsC100 DENALI_CTL_09_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x48]
+dict set regsC100 DENALI_CTL_10_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x50]
+dict set regsC100 DENALI_CTL_11_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x58]
+dict set regsC100 DENALI_CTL_12_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x60]
+dict set regsC100 DENALI_CTL_13_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x68]
+dict set regsC100 DENALI_CTL_14_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x70]
+dict set regsC100 DENALI_CTL_15_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x78]
+dict set regsC100 DENALI_CTL_16_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x80]
+dict set regsC100 DENALI_CTL_17_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x88]
+dict set regsC100 DENALI_CTL_18_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x90]
+dict set regsC100 DENALI_CTL_19_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x98]
+dict set regsC100 DENALI_CTL_20_DATA	[expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0xA0]
+
+# 32-bit value
+dict set regsC100 DENALI_READY_CHECK         [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x44]
+# 8-bit
+dict set regsC100 DENALI_WR_DQS              [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x5D]
+# 8-bit
+dict set regsC100 DENALI_DQS_OUT             [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x5A]
+# 8-bit
+dict set regsC100 DENALI_DQS_DELAY0          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] + 0x4F]
+# 8-bit
+dict set regsC100 DENALI_DQS_DELAY1          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] +0x50]
+# 8-bit
+dict set regsC100 DENALI_DQS_DELAY2          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] +0x51]
+# 8-bit
+dict set regsC100 DENALI_DQS_DELAY3          [expr [dict get $regsC100 DDR_CONFIG_BASEADDR ] +0x52]
+
+
+# end of proc regsC100
+}


Property changes on: trunk/tcl/target/c100regs.tcl
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Thu Sep 10 15:17:06 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 10 Sep 2009 15:17:06 +0200
Subject: [Openocd-svn] r2684 - trunk/src/target
Message-ID: <200909101317.n8ADH65F018551@sheep.berlios.de>

Author: oharboe
Date: 2009-09-10 15:17:05 +0200 (Thu, 10 Sep 2009)
New Revision: 2684

Modified:
   trunk/src/target/target.c
Log:
Alexei Babich <a.babich at rez.ru> fix problems with unecessary tailend byte accesses. Use 16 bit access on tailend of a memory read if possible.

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-09-10 08:06:22 UTC (rev 2683)
+++ trunk/src/target/target.c	2009-09-10 13:17:05 UTC (rev 2684)
@@ -1239,7 +1239,19 @@
 		address += aligned;
 		size -= aligned;
 	}
+	
+	/*prevent byte access when possible (avoid AHB access limitations in some cases)*/
+	if(size	>=2)
+	{
+		int aligned = size - (size%2);
+		retval = target_read_memory(target, address, 2, aligned / 2, buffer);
+		if (retval != ERROR_OK)
+			return retval;
 
+		buffer += aligned;
+		address += aligned;
+		size -= aligned;
+	}
 	/* handle tail writes of less than 4 bytes */
 	if (size > 0)
 	{



From oharboe at mail.berlios.de  Thu Sep 10 15:17:25 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 10 Sep 2009 15:17:25 +0200
Subject: [Openocd-svn] r2685 - trunk/src/flash
Message-ID: <200909101317.n8ADHPvu018571@sheep.berlios.de>

Author: oharboe
Date: 2009-09-10 15:17:25 +0200 (Thu, 10 Sep 2009)
New Revision: 2685

Added:
   trunk/src/flash/mx3_nand.c
   trunk/src/flash/mx3_nand.h
Modified:
   trunk/src/flash/Makefile.am
   trunk/src/flash/nand.c
Log:
Alexei Babich <a.babich at rez.ru>  imx31 nand flash controller support

Modified: trunk/src/flash/Makefile.am
===================================================================
--- trunk/src/flash/Makefile.am	2009-09-10 13:17:05 UTC (rev 2684)
+++ trunk/src/flash/Makefile.am	2009-09-10 13:17:25 UTC (rev 2685)
@@ -36,7 +36,8 @@
 	ocl.c \
 	mflash.c \
 	pic32mx.c \
-	avrf.c
+	avrf.c \
+	mx3_nand.c
 
 noinst_HEADERS = \
 	arm_nandio.h \
@@ -60,6 +61,7 @@
 	mflash.h \
 	ocl.h \
 	pic32mx.h \
-	avrf.h
+	avrf.h \
+	mx3_nand.h
 
 MAINTAINERCLEANFILES = $(srcdir)/Makefile.in

Added: trunk/src/flash/mx3_nand.c
===================================================================
--- trunk/src/flash/mx3_nand.c	2009-09-10 13:17:05 UTC (rev 2684)
+++ trunk/src/flash/mx3_nand.c	2009-09-10 13:17:25 UTC (rev 2685)
@@ -0,0 +1,908 @@
+
+/***************************************************************************
+ *   Copyright (C) 2009 by Alexei Babich                                   *
+ *   Rezonans plc., Chelyabinsk, Russia                                    *
+ *   impatt at mail.ru                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/*
+ * Freescale iMX3* OpenOCD NAND Flash controller support.
+ *
+ * Many thanks to Ben Dooks for writing s3c24xx driver.
+ */
+
+/*
+driver tested with STMicro NAND512W3A @imx31
+tested "nand probe #", "nand erase # 0 #", "nand dump # file 0 #", "nand write # file 0"
+get_next_halfword_from_sram_buffer() not tested
+*/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "mx3_nand.h"
+
+static const char target_not_halted_err_msg[] =
+	"target must be halted to use mx3 NAND flash controller";
+static const char data_block_size_err_msg[] =
+	"minimal granularity is one half-word, %d is incorrect";
+static const char sram_buffer_bounds_err_msg[] =
+	"trying to access out of SRAM buffer bound (addr=0x%x)";
+static const char invalid_command_sequense_err_msg[] =
+	"invalid command sequence in %s";
+static const char get_status_register_err_msg[] = "can't get NAND status";
+static uint32_t in_sram_address;
+unsigned char sign_of_sequental_byte_read;
+
+static int test_iomux_settings (target_t * target, uint32_t value,
+				uint32_t mask, const char *text);
+static int initialize_nf_controller (struct nand_device_s *device);
+static int get_next_byte_from_sram_buffer (target_t * target, uint8_t * value);
+static int get_next_halfword_from_sram_buffer (target_t * target,
+					       uint16_t * value);
+static int poll_for_complete_op (target_t * target, const char *text);
+static int validate_target_state (struct nand_device_s *device);
+static int do_data_output (struct nand_device_s *device);
+
+static int imx31_nand_device_command (struct command_context_s *cmd_ctx,
+				      char *cmd, char **args, int argc,
+				      struct nand_device_s *device);
+static int imx31_init (struct nand_device_s *device);
+static int imx31_read_data (struct nand_device_s *device, void *data);
+static int imx31_write_data (struct nand_device_s *device, uint16_t data);
+static int imx31_nand_ready (struct nand_device_s *device, int timeout);
+static int imx31_register_commands (struct command_context_s *cmd_ctx);
+static int imx31_reset (struct nand_device_s *device);
+static int imx31_command (struct nand_device_s *device, uint8_t command);
+static int imx31_address (struct nand_device_s *device, uint8_t address);
+static int imx31_controller_ready (struct nand_device_s *device, int tout);
+static int imx31_write_page (struct nand_device_s *device, uint32_t page,
+			     uint8_t * data, uint32_t data_size, uint8_t * oob,
+			     uint32_t oob_size);
+static int imx31_read_page (struct nand_device_s *device, uint32_t page,
+			    uint8_t * data, uint32_t data_size, uint8_t * oob,
+			    uint32_t oob_size);
+
+nand_flash_controller_t imx31_nand_flash_controller = {
+	.name = "imx31",
+	.nand_device_command = imx31_nand_device_command,
+	.register_commands = imx31_register_commands,
+	.init = imx31_init,
+	.reset = imx31_reset,
+	.command = imx31_command,
+	.address = imx31_address,
+	.write_data = imx31_write_data,
+	.read_data = imx31_read_data,
+	.write_page = imx31_write_page,
+	.read_page = imx31_read_page,
+	.controller_ready = imx31_controller_ready,
+	.nand_ready = imx31_nand_ready,
+};
+
+static int imx31_nand_device_command (struct command_context_s *cmd_ctx,
+				      char *cmd, char **args, int argc,
+				      struct nand_device_s *device)
+{
+	mx3_nf_controller_t *mx3_nf_info;
+	mx3_nf_info = malloc (sizeof (mx3_nf_controller_t));
+	if (mx3_nf_info == NULL)
+	{
+	    LOG_ERROR ("no memory for nand controller");
+	    return ERROR_FAIL;
+	}
+
+	device->controller_priv = mx3_nf_info;
+
+	mx3_nf_info->target = get_target (args[1]);
+	if (mx3_nf_info->target == NULL)
+	{
+	    LOG_ERROR ("target '%s' not defined", args[1]);
+	    return ERROR_FAIL;
+	}
+	if (argc < 3)
+	{
+	    LOG_ERROR ("use \"nand device imx31 target noecc|hwecc\"");
+	    return ERROR_FAIL;
+	}
+	/*
+	* check hwecc requirements
+	*/
+	{
+	int hwecc_needed;
+	hwecc_needed = strcmp (args[2], "hwecc");
+	if (hwecc_needed == 0)
+	    {
+		mx3_nf_info->flags.hw_ecc_enabled = 1;
+	    }
+	else
+	    {
+		mx3_nf_info->flags.hw_ecc_enabled = 0;
+	    }
+	}
+
+	mx3_nf_info->optype = MX3_NF_DATAOUT_PAGE;
+	mx3_nf_info->fin = MX3_NF_FIN_NONE;
+	mx3_nf_info->flags.target_little_endian =
+	(mx3_nf_info->target->endianness == TARGET_LITTLE_ENDIAN);
+	/*
+	* testing host endianess
+	*/
+	{
+	int x = 1;
+	if (*(char *) &x == 1)
+	    {
+		mx3_nf_info->flags.host_little_endian = 1;
+	    }
+	else
+	    {
+		mx3_nf_info->flags.host_little_endian = 0;
+	    }
+	}
+	return ERROR_OK;
+}
+
+static int imx31_init (struct nand_device_s *device)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+
+	{
+	/*
+	 * validate target state
+	 */
+	int validate_target_result;
+	validate_target_result = validate_target_state (device);
+	if (validate_target_result != ERROR_OK)
+	    {
+		return validate_target_result;
+	    }
+	}
+
+	{
+	uint16_t buffsize_register_content;
+	target_read_u16 (target, MX3_NF_BUFSIZ, &buffsize_register_content);
+	mx3_nf_info->flags.one_kb_sram = !(buffsize_register_content & 0x000f);
+	}
+
+	{
+	uint32_t pcsr_register_content;
+	target_read_u32 (target, MX3_PCSR, &pcsr_register_content);
+	if (!device->bus_width)
+	    {
+		device->bus_width =
+		    (pcsr_register_content & 0x80000000) ? 16 : 8;
+	    }
+	else
+	    {
+		pcsr_register_content |=
+		    ((device->bus_width == 16) ? 0x80000000 : 0x00000000);
+		target_write_u32 (target, MX3_PCSR, pcsr_register_content);
+	    }
+
+	if (!device->page_size)
+	    {
+		device->page_size =
+		    (pcsr_register_content & 0x40000000) ? 2048 : 512;
+	    }
+	else
+	    {
+		pcsr_register_content |=
+		    ((device->page_size == 2048) ? 0x40000000 : 0x00000000);
+		target_write_u32 (target, MX3_PCSR, pcsr_register_content);
+	    }
+	if (mx3_nf_info->flags.one_kb_sram && (device->page_size == 2048))
+	    {
+		LOG_ERROR
+		    ("NAND controller have only 1 kb SRAM, so pagesize 2048 is incompatible with it");
+	    }
+	}
+
+	{
+	uint32_t cgr_register_content;
+	target_read_u32 (target, MX3_CCM_CGR2, &cgr_register_content);
+	if (!(cgr_register_content & 0x00000300))
+	    {
+		LOG_ERROR ("clock gating to EMI disabled");
+		return ERROR_FAIL;
+	    }
+	}
+
+	{
+	uint32_t gpr_register_content;
+	target_read_u32 (target, MX3_GPR, &gpr_register_content);
+	if (gpr_register_content & 0x00000060)
+	    {
+		LOG_ERROR ("pins mode overrided by GPR");
+		return ERROR_FAIL;
+	    }
+	}
+
+	{
+	/*
+	 * testing IOMUX settings; must be in "functional-mode output and
+	 * functional-mode input" mode
+	 */
+	uint8_t test_iomux;
+	test_iomux = ERROR_OK;
+	test_iomux |=
+	    test_iomux_settings (target, 0x43fac0c0, 0x7f7f7f00, "d0,d1,d2");
+	test_iomux |=
+	    test_iomux_settings (target, 0x43fac0c4, 0x7f7f7f7f, "d3,d4,d5,d6");
+	test_iomux |=
+	    test_iomux_settings (target, 0x43fac0c8, 0x0000007f, "d7");
+	if (device->bus_width == 16)
+	    {
+		test_iomux |=
+		    test_iomux_settings (target, 0x43fac0c8, 0x7f7f7f00,
+					 "d8,d9,d10");
+		test_iomux |=
+		    test_iomux_settings (target, 0x43fac0cc, 0x7f7f7f7f,
+					 "d11,d12,d13,d14");
+		test_iomux |=
+		    test_iomux_settings (target, 0x43fac0d0, 0x0000007f, "d15");
+	    }
+	test_iomux |=
+	    test_iomux_settings (target, 0x43fac0d0, 0x7f7f7f00,
+				 "nfwp,nfce,nfrb");
+	test_iomux |=
+	    test_iomux_settings (target, 0x43fac0d4, 0x7f7f7f7f,
+				 "nfwe,nfre,nfale,nfcle");
+	if (test_iomux != ERROR_OK)
+	    {
+		return ERROR_FAIL;
+	    }
+	}
+
+	initialize_nf_controller (device);
+
+	{
+	int retval;
+	uint16_t nand_status_content;
+	retval = ERROR_OK;
+	retval |= imx31_command (device, NAND_CMD_STATUS);
+	retval |= imx31_address (device, 0x00);
+	retval |= do_data_output (device);
+	if (retval != ERROR_OK)
+	    {
+		LOG_ERROR (get_status_register_err_msg);
+		return ERROR_FAIL;
+	    }
+	target_read_u16 (target, MX3_NF_MAIN_BUFFER0, &nand_status_content);
+	if (!(nand_status_content & 0x0080))
+	    {
+		/*
+		 * is host-big-endian correctly ??
+		 */
+		LOG_INFO ("NAND read-only");
+		mx3_nf_info->flags.nand_readonly = 1;
+	    }
+	else
+	    {
+		mx3_nf_info->flags.nand_readonly = 0;
+	    }
+	}
+	return ERROR_OK;
+}
+
+static int imx31_read_data (struct nand_device_s *device, void *data)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+	{
+	/*
+	 * validate target state
+	 */
+	int validate_target_result;
+	validate_target_result = validate_target_state (device);
+	if (validate_target_result != ERROR_OK)
+	    {
+		return validate_target_result;
+	    }
+	}
+
+	{
+	/*
+	 * get data from nand chip
+	 */
+	int try_data_output_from_nand_chip;
+	try_data_output_from_nand_chip = do_data_output (device);
+	if (try_data_output_from_nand_chip != ERROR_OK)
+	    {
+		return try_data_output_from_nand_chip;
+	    }
+	}
+
+	if (device->bus_width == 16)
+	{
+	    get_next_halfword_from_sram_buffer (target, data);
+	}
+	else
+	{
+	    get_next_byte_from_sram_buffer (target, data);
+	}
+
+	return ERROR_OK;
+}
+
+static int imx31_write_data (struct nand_device_s *device, uint16_t data)
+{
+	LOG_ERROR ("write_data() not implemented");
+	return ERROR_NAND_OPERATION_FAILED;
+}
+
+static int imx31_nand_ready (struct nand_device_s *device, int timeout)
+{
+	return imx31_controller_ready (device, timeout);
+}
+
+static int imx31_register_commands (struct command_context_s *cmd_ctx)
+{
+	return ERROR_OK;
+}
+
+static int imx31_reset (struct nand_device_s *device)
+{
+	/*
+	* validate target state
+	*/
+	int validate_target_result;
+	validate_target_result = validate_target_state (device);
+	if (validate_target_result != ERROR_OK)
+	{
+	    return validate_target_result;
+	}
+	initialize_nf_controller (device);
+	return ERROR_OK;
+}
+
+static int imx31_command (struct nand_device_s *device, uint8_t command)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+	{
+	/*
+	 * validate target state
+	 */
+	int validate_target_result;
+	validate_target_result = validate_target_state (device);
+	if (validate_target_result != ERROR_OK)
+	    {
+		return validate_target_result;
+	    }
+	}
+
+	switch (command)
+	{
+	    case NAND_CMD_READOOB:
+		command = NAND_CMD_READ0;
+		in_sram_address = MX3_NF_SPARE_BUFFER0;	/* set read point for
+							 * data_read() and
+							 * read_block_data() to
+							 * spare area in SRAM
+							 * buffer */
+		break;
+	    case NAND_CMD_READ1:
+		command = NAND_CMD_READ0;
+		/*
+		 * offset == one half of page size
+		 */
+		in_sram_address =
+		    MX3_NF_MAIN_BUFFER0 + (device->page_size >> 1);
+	    default:
+		in_sram_address = MX3_NF_MAIN_BUFFER0;
+	}
+
+	target_write_u16 (target, MX3_NF_FCMD, command);
+	/*
+	* start command input operation (set MX3_NF_BIT_OP_DONE==0)
+	*/
+	target_write_u16 (target, MX3_NF_CFG2, MX3_NF_BIT_OP_FCI);
+	{
+	int poll_result;
+	poll_result = poll_for_complete_op (target, "command");
+	if (poll_result != ERROR_OK)
+	    {
+		return poll_result;
+	    }
+	}
+	/*
+	* reset cursor to begin of the buffer
+	*/
+	sign_of_sequental_byte_read = 0;
+	switch (command)
+	{
+	    case NAND_CMD_READID:
+		mx3_nf_info->optype = MX3_NF_DATAOUT_NANDID;
+		mx3_nf_info->fin = MX3_NF_FIN_DATAOUT;
+		break;
+	    case NAND_CMD_STATUS:
+		mx3_nf_info->optype = MX3_NF_DATAOUT_NANDSTATUS;
+		mx3_nf_info->fin = MX3_NF_FIN_DATAOUT;
+		break;
+	    case NAND_CMD_READ0:
+		mx3_nf_info->fin = MX3_NF_FIN_DATAOUT;
+		mx3_nf_info->optype = MX3_NF_DATAOUT_PAGE;
+		break;
+	    case NAND_CMD_SEQIN:
+		LOG_ERROR ("aaa");
+		return ERROR_FAIL;
+		break;
+	    default:
+		mx3_nf_info->optype = MX3_NF_DATAOUT_PAGE;
+	}
+	return ERROR_OK;
+}
+
+static int imx31_address (struct nand_device_s *device, uint8_t address)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+	{
+	/*
+	 * validate target state
+	 */
+	int validate_target_result;
+	validate_target_result = validate_target_state (device);
+	if (validate_target_result != ERROR_OK)
+	    {
+		return validate_target_result;
+	    }
+	}
+
+	target_write_u16 (target, MX3_NF_FADDR, address);
+	/*
+	* start address input operation (set MX3_NF_BIT_OP_DONE==0)
+	*/
+	target_write_u16 (target, MX3_NF_CFG2, MX3_NF_BIT_OP_FAI);
+	{
+	int poll_result;
+	poll_result = poll_for_complete_op (target, "address");
+	if (poll_result != ERROR_OK)
+	    {
+		return poll_result;
+	    }
+	}
+	return ERROR_OK;
+}
+
+static int imx31_controller_ready (struct nand_device_s *device, int tout)
+{
+	uint16_t poll_complete_status;
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+
+	{
+	/*
+	 * validate target state
+	 */
+	int validate_target_result;
+	validate_target_result = validate_target_state (device);
+	if (validate_target_result != ERROR_OK)
+	    {
+		return validate_target_result;
+	    }
+	}
+
+	do
+	{
+	    target_read_u16 (target, MX3_NF_CFG2, &poll_complete_status);
+	    if (poll_complete_status & MX3_NF_BIT_OP_DONE)
+		{
+		    return tout;
+		}
+	    alive_sleep (1);
+	}
+	while (tout-- > 0);
+	return tout;
+}
+
+static int imx31_write_page (struct nand_device_s *device, uint32_t page,
+			     uint8_t * data, uint32_t data_size, uint8_t * oob,
+			     uint32_t oob_size)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+
+	if (data_size % 2)
+	{
+	    LOG_ERROR (data_block_size_err_msg, data_size);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	if (oob_size % 2)
+	{
+	    LOG_ERROR (data_block_size_err_msg, oob_size);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	if (!data)
+	{
+	    LOG_ERROR ("nothing to program");
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	{
+	/*
+	 * validate target state
+	 */
+	int retval;
+	retval = validate_target_state (device);
+	if (retval != ERROR_OK)
+	    {
+		return retval;
+	    }
+	}
+	{
+	int retval = ERROR_OK;
+	retval |= imx31_command (device, NAND_CMD_SEQIN);
+	retval |= imx31_address (device, 0x00);
+	retval |= imx31_address (device, page & 0xff);
+	retval |= imx31_address (device, (page >> 8) & 0xff);
+	if (device->address_cycles >= 4)
+	    {
+		retval |= imx31_address (device, (page >> 16) & 0xff);
+		if (device->address_cycles >= 5)
+		    {
+			retval |= imx31_address (device, (page >> 24) & 0xff);
+		    }
+	    }
+	target_write_buffer (target, MX3_NF_MAIN_BUFFER0, data_size, data);
+	if (oob)
+	    {
+		if (mx3_nf_info->flags.hw_ecc_enabled)
+		    {
+			/*
+			 * part of spare block will be overrided by hardware
+			 * ECC generator
+			 */
+			LOG_DEBUG
+			    ("part of spare block will be overrided by hardware ECC generator");
+		    }
+		target_write_buffer (target, MX3_NF_SPARE_BUFFER0, oob_size,
+				     oob);
+	    }
+	/*
+	 * start data input operation (set MX3_NF_BIT_OP_DONE==0)
+	 */
+	target_write_u16 (target, MX3_NF_CFG2, MX3_NF_BIT_OP_FDI);
+	{
+	    int poll_result;
+	    poll_result = poll_for_complete_op (target, "data input");
+	    if (poll_result != ERROR_OK)
+		{
+		    return poll_result;
+		}
+	}
+	retval |= imx31_command (device, NAND_CMD_PAGEPROG);
+	if (retval != ERROR_OK)
+	    {
+		return retval;
+	    }
+
+	/*
+	 * check status register
+	 */
+	{
+	    uint16_t nand_status_content;
+	    retval = ERROR_OK;
+	    retval |= imx31_command (device, NAND_CMD_STATUS);
+	    retval |= imx31_address (device, 0x00);
+	    retval |= do_data_output (device);
+	    if (retval != ERROR_OK)
+		{
+		    LOG_ERROR (get_status_register_err_msg);
+		    return retval;
+		}
+	    target_read_u16 (target, MX3_NF_MAIN_BUFFER0, &nand_status_content);
+	    if (nand_status_content & 0x0001)
+		{
+		    /*
+		     * is host-big-endian correctly ??
+		     */
+		    return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+	}
+	return ERROR_OK;
+}
+
+static int imx31_read_page (struct nand_device_s *device, uint32_t page,
+			    uint8_t * data, uint32_t data_size, uint8_t * oob,
+			    uint32_t oob_size)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+
+	if (data_size % 2)
+	{
+	    LOG_ERROR (data_block_size_err_msg, data_size);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	if (oob_size % 2)
+	{
+	    LOG_ERROR (data_block_size_err_msg, oob_size);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	{
+	/*
+	 * validate target state
+	 */
+	int retval;
+	retval = validate_target_state (device);
+	if (retval != ERROR_OK)
+	    {
+		return retval;
+	    }
+	}
+	{
+	int retval = ERROR_OK;
+	retval |= imx31_command (device, NAND_CMD_READ0);
+	retval |= imx31_address (device, 0x00);
+	retval |= imx31_address (device, page & 0xff);
+	retval |= imx31_address (device, (page >> 8) & 0xff);
+	if (device->address_cycles >= 4)
+	    {
+		retval |= imx31_address (device, (page >> 16) & 0xff);
+		if (device->address_cycles >= 5)
+		    {
+			retval |= imx31_address (device, (page >> 24) & 0xff);
+			retval |= imx31_command (device, NAND_CMD_READSTART);
+		    }
+	    }
+	retval |= do_data_output (device);
+	if (retval != ERROR_OK)
+	    {
+		return retval;
+	    }
+
+	if (data)
+	    {
+		target_read_buffer (target, MX3_NF_MAIN_BUFFER0, data_size,
+				    data);
+	    }
+	if (oob)
+	    {
+		target_read_buffer (target, MX3_NF_SPARE_BUFFER0, oob_size,
+				    oob);
+	    }
+	}
+	return ERROR_OK;
+}
+
+static int test_iomux_settings (target_t * target, uint32_t address,
+				uint32_t mask, const char *text)
+{
+	uint32_t register_content;
+	target_read_u32 (target, address, &register_content);
+	if ((register_content & mask) != (0x12121212 & mask))
+	{
+	    LOG_ERROR ("IOMUX for {%s} is bad", text);
+	    return ERROR_FAIL;
+	}
+	return ERROR_OK;
+}
+
+static int initialize_nf_controller (struct nand_device_s *device)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+	/*
+	* resets NAND flash controller in zero time ? I dont know.
+	*/
+	target_write_u16 (target, MX3_NF_CFG1, MX3_NF_BIT_RESET_EN);
+	{
+	uint16_t work_mode;
+	work_mode = MX3_NF_BIT_INT_DIS;	/* disable interrupt */
+	if (target->endianness == TARGET_BIG_ENDIAN)
+	    {
+		work_mode |= MX3_NF_BIT_BE_EN;
+	    }
+	if (mx3_nf_info->flags.hw_ecc_enabled)
+	    {
+		work_mode |= MX3_NF_BIT_ECC_EN;
+	    }
+	target_write_u16 (target, MX3_NF_CFG1, work_mode);
+	}
+	/*
+	* unlock SRAM buffer for write; 2 mean "Unlock", other values means "Lock"
+	*/
+	target_write_u16 (target, MX3_NF_BUFCFG, 2);
+	{
+	uint16_t temp;
+	target_read_u16 (target, MX3_NF_FWP, &temp);
+	if ((temp & 0x0007) == 1)
+	    {
+		LOG_ERROR ("NAND flash is tight-locked, reset needed");
+		return ERROR_FAIL;
+	    }
+
+	}
+	/*
+	* unlock NAND flash for write
+	*/
+	target_write_u16 (target, MX3_NF_FWP, 4);
+	target_write_u16 (target, MX3_NF_LOCKSTART, 0x0000);
+	target_write_u16 (target, MX3_NF_LOCKEND, 0xFFFF);
+	/*
+	* 0x0000 means that first SRAM buffer @0xB800_0000 will be used
+	*/
+	target_write_u16 (target, MX3_NF_BUFADDR, 0x0000);
+	/*
+	* address of SRAM buffer
+	*/
+	in_sram_address = MX3_NF_MAIN_BUFFER0;
+	sign_of_sequental_byte_read = 0;
+	return ERROR_OK;
+}
+
+static int get_next_byte_from_sram_buffer (target_t * target, uint8_t * value)
+{
+	static uint8_t even_byte = 0;
+	/*
+	* host-big_endian ??
+	*/
+	if (sign_of_sequental_byte_read == 0)
+	{
+	    even_byte = 0;
+	}
+	if (in_sram_address > MX3_NF_LAST_BUFFER_ADDR)
+	{
+	    LOG_ERROR (sram_buffer_bounds_err_msg, in_sram_address);
+	    *value = 0;
+	    sign_of_sequental_byte_read = 0;
+	    even_byte = 0;
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	else
+	{
+	    uint16_t temp;
+	    target_read_u16 (target, in_sram_address, &temp);
+	    if (even_byte)
+		{
+		    *value = temp >> 8;
+		    even_byte = 0;
+		    in_sram_address += 2;
+		}
+	    else
+		{
+		    *value = temp & 0xff;
+		    even_byte = 1;
+		}
+	}
+	sign_of_sequental_byte_read = 1;
+	return ERROR_OK;
+}
+
+static int get_next_halfword_from_sram_buffer (target_t * target,
+					       uint16_t * value)
+{
+	if (in_sram_address > MX3_NF_LAST_BUFFER_ADDR)
+	{
+	    LOG_ERROR (sram_buffer_bounds_err_msg, in_sram_address);
+	    *value = 0;
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	else
+	{
+	    target_read_u16 (target, in_sram_address, value);
+	    in_sram_address += 2;
+	}
+	return ERROR_OK;
+}
+
+static int poll_for_complete_op (target_t * target, const char *text)
+{
+	uint16_t poll_complete_status;
+	for (int poll_cycle_count = 0; poll_cycle_count < 100; poll_cycle_count++)
+	{
+	    usleep (25);
+	    target_read_u16 (target, MX3_NF_CFG2, &poll_complete_status);
+	    if (poll_complete_status & MX3_NF_BIT_OP_DONE)
+		{
+		    break;
+		}
+	}
+	if (!(poll_complete_status & MX3_NF_BIT_OP_DONE))
+	{
+	    LOG_ERROR ("%s sending timeout", text);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	return ERROR_OK;
+}
+
+static int validate_target_state (struct nand_device_s *device)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+
+	if (target->state != TARGET_HALTED)
+	{
+	    LOG_ERROR (target_not_halted_err_msg);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (mx3_nf_info->flags.target_little_endian !=
+	(target->endianness == TARGET_LITTLE_ENDIAN))
+	{
+	    /*
+	     * endianness changed after NAND controller probed
+	     */
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	return ERROR_OK;
+}
+
+static int do_data_output (struct nand_device_s *device)
+{
+	mx3_nf_controller_t *mx3_nf_info = device->controller_priv;
+	target_t *target = mx3_nf_info->target;
+	switch (mx3_nf_info->fin)
+	{
+	    case MX3_NF_FIN_DATAOUT:
+		/*
+		 * start data output operation (set MX3_NF_BIT_OP_DONE==0)
+		 */
+		target_write_u16 (target, MX3_NF_CFG2,
+				  MX3_NF_BIT_DATAOUT_TYPE (mx3_nf_info->
+							   optype));
+		{
+		    int poll_result;
+		    poll_result = poll_for_complete_op (target, "data output");
+		    if (poll_result != ERROR_OK)
+			{
+			    return poll_result;
+			}
+		}
+		mx3_nf_info->fin = MX3_NF_FIN_NONE;
+		/*
+		 * ECC stuff
+		 */
+		if ((mx3_nf_info->optype == MX3_NF_DATAOUT_PAGE)
+		    && mx3_nf_info->flags.hw_ecc_enabled)
+		    {
+			uint16_t ecc_status;
+			target_read_u16 (target, MX3_NF_ECCSTATUS, &ecc_status);
+			switch (ecc_status & 0x000c)
+			    {
+				case 1 << 2:
+				    LOG_DEBUG
+					("main area readed with 1 (correctable) error");
+				    break;
+				case 2 << 2:
+				    LOG_DEBUG
+					("main area readed with more than 1 (incorrectable) error");
+				    return ERROR_NAND_OPERATION_FAILED;
+				    break;
+			    }
+			switch (ecc_status & 0x0003)
+			    {
+				case 1:
+				    LOG_DEBUG
+					("spare area readed with 1 (correctable) error");
+				    break;
+				case 2:
+				    LOG_DEBUG
+					("main area readed with more than 1 (incorrectable) error");
+				    return ERROR_NAND_OPERATION_FAILED;
+				    break;
+			    }
+		    }
+		break;
+	    case MX3_NF_FIN_NONE:
+		break;
+	}
+	return ERROR_OK;
+}

Added: trunk/src/flash/mx3_nand.h
===================================================================
--- trunk/src/flash/mx3_nand.h	2009-09-10 13:17:05 UTC (rev 2684)
+++ trunk/src/flash/mx3_nand.h	2009-09-10 13:17:25 UTC (rev 2685)
@@ -0,0 +1,90 @@
+#include <nand.h>
+
+#define		MX3_NF_BASE_ADDR		0xb8000000
+#define		MX3_NF_BUFSIZ			(MX3_NF_BASE_ADDR + 0xe00)
+#define		MX3_NF_BUFADDR			(MX3_NF_BASE_ADDR + 0xe04)
+#define		MX3_NF_FADDR			(MX3_NF_BASE_ADDR + 0xe06)
+#define		MX3_NF_FCMD				(MX3_NF_BASE_ADDR + 0xe08)
+#define		MX3_NF_BUFCFG			(MX3_NF_BASE_ADDR + 0xe0a)
+#define		MX3_NF_ECCSTATUS			(MX3_NF_BASE_ADDR + 0xe0c)
+#define		MX3_NF_ECCMAINPOS			(MX3_NF_BASE_ADDR + 0xe0e)
+#define		MX3_NF_ECCSPAREPOS			(MX3_NF_BASE_ADDR + 0xe10)
+#define		MX3_NF_FWP			(MX3_NF_BASE_ADDR + 0xe12)
+#define		MX3_NF_LOCKSTART			(MX3_NF_BASE_ADDR + 0xe14)
+#define		MX3_NF_LOCKEND			(MX3_NF_BASE_ADDR + 0xe16)
+#define		MX3_NF_FWPSTATUS			(MX3_NF_BASE_ADDR + 0xe18)
+ /*
+  * all bits not marked as self-clearing bit
+  */
+#define		MX3_NF_CFG1			(MX3_NF_BASE_ADDR + 0xe1a)
+#define		MX3_NF_CFG2			(MX3_NF_BASE_ADDR + 0xe1c)
+
+#define		MX3_NF_MAIN_BUFFER0		(MX3_NF_BASE_ADDR + 0x0000)
+#define		MX3_NF_MAIN_BUFFER1		(MX3_NF_BASE_ADDR + 0x0200)
+#define		MX3_NF_MAIN_BUFFER2		(MX3_NF_BASE_ADDR + 0x0400)
+#define		MX3_NF_MAIN_BUFFER3		(MX3_NF_BASE_ADDR + 0x0600)
+#define		MX3_NF_SPARE_BUFFER0	(MX3_NF_BASE_ADDR + 0x0800)
+#define		MX3_NF_SPARE_BUFFER1	(MX3_NF_BASE_ADDR + 0x0810)
+#define		MX3_NF_SPARE_BUFFER2	(MX3_NF_BASE_ADDR + 0x0820)
+#define		MX3_NF_SPARE_BUFFER3	(MX3_NF_BASE_ADDR + 0x0830)
+#define		MX3_NF_MAIN_BUFFER_LEN	512
+#define		MX3_NF_SPARE_BUFFER_LEN	16
+#define		MX3_NF_LAST_BUFFER_ADDR	((MX3_NF_SPARE_BUFFER3) + MX3_NF_SPARE_BUFFER_LEN - 2)
+
+/* bits in MX3_NF_CFG1 register */
+#define		MX3_NF_BIT_SPARE_ONLY_EN	(1<<2)
+#define		MX3_NF_BIT_ECC_EN			(1<<3)
+#define		MX3_NF_BIT_INT_DIS			(1<<4)
+#define		MX3_NF_BIT_BE_EN			(1<<5)
+#define		MX3_NF_BIT_RESET_EN			(1<<6)
+#define		MX3_NF_BIT_FORCE_CE			(1<<7)
+
+/* bits in MX3_NF_CFG2 register */
+
+/*Flash Command Input*/
+#define		MX3_NF_BIT_OP_FCI			(1<<0)
+ /*
+  * Flash Address Input
+  */
+#define		MX3_NF_BIT_OP_FAI			(1<<1)
+ /*
+  * Flash Data Input
+  */
+#define		MX3_NF_BIT_OP_FDI			(1<<2)
+
+/* see "enum mx_dataout_type" below */
+#define		MX3_NF_BIT_DATAOUT_TYPE(x)	((x)<<3)
+#define		MX3_NF_BIT_OP_DONE			(1<<15)
+
+#define		MX3_CCM_CGR2		0x53f80028
+#define		MX3_GPR				0x43fac008
+#define		MX3_PCSR			0x53f8000c
+
+enum mx_dataout_type
+{
+	MX3_NF_DATAOUT_PAGE = 1,
+	MX3_NF_DATAOUT_NANDID = 2,
+	MX3_NF_DATAOUT_NANDSTATUS = 4,
+};
+enum mx_nf_finalize_action
+{
+	MX3_NF_FIN_NONE,
+	MX3_NF_FIN_DATAOUT,
+};
+
+struct mx3_nf_flags
+{
+	unsigned host_little_endian:1;
+	unsigned target_little_endian:1;
+	unsigned nand_readonly:1;
+	unsigned one_kb_sram:1;
+	unsigned hw_ecc_enabled:1;
+};
+
+typedef struct mx3_nf_controller_s
+{
+	struct target_s *target;
+	enum mx_dataout_type optype;
+	enum mx_nf_finalize_action fin;
+	struct mx3_nf_flags flags;
+} mx3_nf_controller_t;

Modified: trunk/src/flash/nand.c
===================================================================
--- trunk/src/flash/nand.c	2009-09-10 13:17:05 UTC (rev 2684)
+++ trunk/src/flash/nand.c	2009-09-10 13:17:25 UTC (rev 2685)
@@ -52,6 +52,7 @@
 extern nand_flash_controller_t s3c2412_nand_controller;
 extern nand_flash_controller_t s3c2440_nand_controller;
 extern nand_flash_controller_t s3c2443_nand_controller;
+extern nand_flash_controller_t imx31_nand_flash_controller;
 
 /* extern nand_flash_controller_t boundary_scan_nand_controller; */
 
@@ -64,6 +65,7 @@
 	&s3c2412_nand_controller,
 	&s3c2440_nand_controller,
 	&s3c2443_nand_controller,
+ 	&imx31_nand_flash_controller,
 /*	&boundary_scan_nand_controller, */
 	NULL
 };



From oharboe at mail.berlios.de  Thu Sep 10 15:35:08 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 10 Sep 2009 15:35:08 +0200
Subject: [Openocd-svn] r2686 - trunk/src/flash
Message-ID: <200909101335.n8ADZ8Qs019854@sheep.berlios.de>

Author: oharboe
Date: 2009-09-10 15:35:08 +0200 (Thu, 10 Sep 2009)
New Revision: 2686

Modified:
   trunk/src/flash/mx3_nand.c
   trunk/src/flash/mx3_nand.h
Log:
eol-style:native


Property changes on: trunk/src/flash/mx3_nand.c
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/src/flash/mx3_nand.h
___________________________________________________________________
Name: svn:eol-style
   + native



From oharboe at mail.berlios.de  Fri Sep 11 07:57:52 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 07:57:52 +0200
Subject: [Openocd-svn] r2687 - trunk/src/target
Message-ID: <200909110557.n8B5vqKL020713@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 07:57:51 +0200 (Fri, 11 Sep 2009)
New Revision: 2687

Modified:
   trunk/src/target/feroceon.c
Log:
Nicolas Pitre <nico at cam.org> tighten error checking in bulk_write

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2009-09-10 13:35:08 UTC (rev 2686)
+++ trunk/src/target/feroceon.c	2009-09-11 05:57:51 UTC (rev 2687)
@@ -591,9 +591,20 @@
 		buffer += 4;
 	}
 
-	target_halt(target);
-	while (target->state != TARGET_HALTED)
-		target_poll(target);
+	retval = target_halt(target);
+	if (retval == ERROR_OK)
+		retval = target_wait_state(target, TARGET_HALTED, 500);
+	if (retval == ERROR_OK) {
+                uint32_t endaddress =
+			buf_get_u32(armv4_5->core_cache->reg_list[0].value, 0, 32);
+		if (endaddress != address + count*4) {
+			LOG_ERROR("DCC write failed,"
+				" expected end address 0x%08" PRIx32
+				" got 0x%0" PRIx32 "",
+			       	address + count*4, endaddress);
+			retval = ERROR_FAIL;
+		}
+	}
 
 	/* restore target state */
 	for (i = 0; i <= 5; i++)
@@ -607,7 +618,7 @@
 	armv4_5->core_cache->reg_list[15].dirty = 1;
 	armv4_5->core_state = core_state;
 
-	return ERROR_OK;
+	return retval;
 }
 
 int feroceon_init_target(struct command_context_s *cmd_ctx, struct target_s *target)



From oharboe at mail.berlios.de  Fri Sep 11 08:01:28 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 08:01:28 +0200
Subject: [Openocd-svn] r2688 - trunk/src/flash
Message-ID: <200909110601.n8B61SBV023533@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 08:01:28 +0200 (Fri, 11 Sep 2009)
New Revision: 2688

Modified:
   trunk/src/flash/mx3_nand.c
   trunk/src/flash/mx3_nand.h
Log:
Alexei Babich <a.babich at rez.ru>  cleanup

Modified: trunk/src/flash/mx3_nand.c
===================================================================
--- trunk/src/flash/mx3_nand.c	2009-09-11 05:57:51 UTC (rev 2687)
+++ trunk/src/flash/mx3_nand.c	2009-09-11 06:01:28 UTC (rev 2688)
@@ -43,8 +43,6 @@
 	"minimal granularity is one half-word, %d is incorrect";
 static const char sram_buffer_bounds_err_msg[] =
 	"trying to access out of SRAM buffer bound (addr=0x%x)";
-static const char invalid_command_sequense_err_msg[] =
-	"invalid command sequence in %s";
 static const char get_status_register_err_msg[] = "can't get NAND status";
 static uint32_t in_sram_address;
 unsigned char sign_of_sequental_byte_read;
@@ -237,7 +235,7 @@
 	 * testing IOMUX settings; must be in "functional-mode output and
 	 * functional-mode input" mode
 	 */
-	uint8_t test_iomux;
+	int test_iomux;
 	test_iomux = ERROR_OK;
 	test_iomux |=
 	    test_iomux_settings (target, 0x43fac0c0, 0x7f7f7f00, "d0,d1,d2");
@@ -438,10 +436,6 @@
 		mx3_nf_info->fin = MX3_NF_FIN_DATAOUT;
 		mx3_nf_info->optype = MX3_NF_DATAOUT_PAGE;
 		break;
-	    case NAND_CMD_SEQIN:
-		LOG_ERROR ("aaa");
-		return ERROR_FAIL;
-		break;
 	    default:
 		mx3_nf_info->optype = MX3_NF_DATAOUT_PAGE;
 	}

Modified: trunk/src/flash/mx3_nand.h
===================================================================
--- trunk/src/flash/mx3_nand.h	2009-09-11 05:57:51 UTC (rev 2687)
+++ trunk/src/flash/mx3_nand.h	2009-09-11 06:01:28 UTC (rev 2688)
@@ -1,3 +1,30 @@
+
+/***************************************************************************
+ *   Copyright (C) 2009 by Alexei Babich                                   *
+ *   Rezonans plc., Chelyabinsk, Russia                                    *
+ *   impatt at mail.ru                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/*
+ * Freescale iMX3* OpenOCD NAND Flash controller support.
+ *
+ * Many thanks to Ben Dooks for writing s3c24xx driver.
+ */
 #include <nand.h>
 
 #define		MX3_NF_BASE_ADDR		0xb8000000



From oharboe at mail.berlios.de  Fri Sep 11 08:08:51 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 08:08:51 +0200
Subject: [Openocd-svn] r2689 - trunk/tcl/target
Message-ID: <200909110608.n8B68pcv026078@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 08:08:51 +0200 (Fri, 11 Sep 2009)
New Revision: 2689

Modified:
   trunk/tcl/target/c100helper.tcl
Log:
syntax error fix

Modified: trunk/tcl/target/c100helper.tcl
===================================================================
--- trunk/tcl/target/c100helper.tcl	2009-09-11 06:01:28 UTC (rev 2688)
+++ trunk/tcl/target/c100helper.tcl	2009-09-11 06:08:51 UTC (rev 2689)
@@ -328,6 +328,7 @@
 	configureDDR2regs_256B
     } else {
 	puts "Don't know how to configure DDR2 setup?"
+    }
 }
 
 



From oharboe at mail.berlios.de  Fri Sep 11 08:58:49 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 08:58:49 +0200
Subject: [Openocd-svn] r2690 - trunk/src/target
Message-ID: <200909110658.n8B6wnOF013881@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 08:58:49 +0200 (Fri, 11 Sep 2009)
New Revision: 2690

Modified:
   trunk/src/target/target.c
Log:
registering a target event twice caused infinite loop. Same bug as in jtag/core.c copy & pasted.

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-09-11 06:08:51 UTC (rev 2689)
+++ trunk/src/target/target.c	2009-09-11 06:58:49 UTC (rev 2690)
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007,2008 ?yvind Harboe                                 *
+ *   Copyright (C) 2007-2009 ?yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008, Duane Ellis                                       *
@@ -3547,9 +3547,11 @@
 				}
 
 				if (goi->isconfigure) {
+					bool replace = true;
 					if (teap == NULL) {
 						/* create new */
 						teap = calloc(1, sizeof(*teap));
+						replace = false;
 					}
 					teap->event = n->value;
 					Jim_GetOpt_Obj(goi, &o);
@@ -3569,9 +3571,12 @@
 					 */
 					Jim_IncrRefCount(teap->body);
 
-					/* add to head of event list */
-					teap->next = target->event_action;
-					target->event_action = teap;
+					if (!replace)
+					{
+						/* add to head of event list */
+						teap->next = target->event_action;
+						target->event_action = teap;
+					}
 					Jim_SetEmptyResult(goi->interp);
 				} else {
 					/* get */



From oharboe at mail.berlios.de  Fri Sep 11 09:43:40 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 09:43:40 +0200
Subject: [Openocd-svn] r2691 - trunk/src/target
Message-ID: <200909110743.n8B7heX9017382@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 09:43:36 +0200 (Fri, 11 Sep 2009)
New Revision: 2691

Modified:
   trunk/src/target/arm11_dbgtap.c
Log:
do not use dynamically sized stack arrays, not compatible with embedded OS's

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-09-11 06:58:49 UTC (rev 2690)
+++ trunk/src/target/arm11_dbgtap.c	2009-09-11 07:43:36 UTC (rev 2691)
@@ -576,7 +576,15 @@
 	arm11_setup_field(arm11,  1,    NULL,			NULL /*&Ready*/,	chain5_fields + 1);
 	arm11_setup_field(arm11,  1,    NULL,			NULL,				chain5_fields + 2);
 
-	uint8_t			Readies[count + 1];
+	uint8_t			*Readies;
+	int bytes = sizeof(*Readies)*(count + 1);
+	Readies = (uint8_t *) malloc(bytes);
+	if (Readies == NULL)
+	{
+		LOG_ERROR("Out of memory allocating %d bytes", bytes);
+		return ERROR_FAIL;
+	}
+
 	uint8_t	*		ReadyPos			= Readies;
 
 	while (count--)
@@ -603,22 +611,28 @@
 
 	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
-	CHECK_RETVAL(jtag_execute_queue());
+	int retval = jtag_execute_queue();
+	if (retval == ERROR_OK)
+	{
 
-	size_t error_count = 0;
+		size_t error_count = 0;
 
-	for (size_t i = 0; i < asizeof(Readies); i++)
-	{
-		if (Readies[i] != 1)
+		for (size_t i = 0; i < asizeof(Readies); i++)
 		{
-			error_count++;
+			if (Readies[i] != 1)
+			{
+				error_count++;
+			}
 		}
+
+		if (error_count)
+			LOG_ERROR("Transfer errors " ZU, error_count);
+
 	}
 
-	if (error_count)
-		LOG_ERROR("Transfer errors " ZU, error_count);
+	free(Readies);
 
-	return ERROR_OK;
+	return retval;
 }
 
 



From oharboe at mail.berlios.de  Fri Sep 11 09:46:50 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 09:46:50 +0200
Subject: [Openocd-svn] r2692 - trunk/src/target
Message-ID: <200909110746.n8B7koGI017643@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 09:46:50 +0200 (Fri, 11 Sep 2009)
New Revision: 2692

Modified:
   trunk/src/target/target.c
Log:
spelling mistake

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-09-11 07:43:36 UTC (rev 2691)
+++ trunk/src/target/target.c	2009-09-11 07:46:50 UTC (rev 2692)
@@ -2334,7 +2334,7 @@
 				break;
 			}
 			image_size += length;
-			command_print(cmd_ctx, "%u byte written at address 0x%8.8" PRIx32 "",
+			command_print(cmd_ctx, "%u bytes written at address 0x%8.8" PRIx32 "",
 						  (unsigned int)length,
 						  image.sections[i].base_address + offset);
 		}
@@ -4537,7 +4537,7 @@
 			fastload[i].length = length;
 
 			image_size += length;
-			command_print(cmd_ctx, "%u byte written at address 0x%8.8x",
+			command_print(cmd_ctx, "%u bytes written at address 0x%8.8x",
 						  (unsigned int)length,
 						  ((unsigned int)(image.sections[i].base_address + offset)));
 		}



From oharboe at mail.berlios.de  Fri Sep 11 10:03:46 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 10:03:46 +0200
Subject: [Openocd-svn] r2693 - trunk/src/target
Message-ID: <200909110803.n8B83kna018820@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 10:03:46 +0200 (Fri, 11 Sep 2009)
New Revision: 2693

Modified:
   trunk/src/target/arm966e.c
   trunk/src/target/arm966e.h
   trunk/src/target/feroceon.c
   trunk/src/target/target.c
Log:
Nicolas Pitre <nico at cam.org> Dragonite support

Modified: trunk/src/target/arm966e.c
===================================================================
--- trunk/src/target/arm966e.c	2009-09-11 07:46:50 UTC (rev 2692)
+++ trunk/src/target/arm966e.c	2009-09-11 08:03:46 UTC (rev 2693)
@@ -32,9 +32,6 @@
 #define _DEBUG_INSTRUCTION_EXECUTION_
 #endif
 
-/* cli handling */
-int arm966e_register_commands(struct command_context_s *cmd_ctx);
-
 /* forward declarations */
 int arm966e_target_create(struct target_s *target, Jim_Interp *interp);
 int arm966e_init_target(struct command_context_s *cmd_ctx, struct target_s *target);

Modified: trunk/src/target/arm966e.h
===================================================================
--- trunk/src/target/arm966e.h	2009-09-11 07:46:50 UTC (rev 2692)
+++ trunk/src/target/arm966e.h	2009-09-11 08:03:46 UTC (rev 2693)
@@ -34,6 +34,8 @@
 	uint32_t cp15_control_reg;
 } arm966e_common_t;
 
+extern int arm966e_init_arch_info(target_t *target, arm966e_common_t *arm966e, jtag_tap_t *tap);
+extern int arm966e_register_commands(struct command_context_s *cmd_ctx);
 extern int arm966e_read_cp15(target_t *target, int reg_addr, uint32_t *value);
 extern int arm966e_write_cp15(target_t *target, int reg_addr, uint32_t value);
 

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2009-09-11 07:46:50 UTC (rev 2692)
+++ trunk/src/target/feroceon.c	2009-09-11 08:03:46 UTC (rev 2693)
@@ -1,5 +1,5 @@
 /***************************************************************************
- *   Copyright (C) 2008 by Marvell Semiconductors, Inc.                    *
+ *   Copyright (C) 2008-2009 by Marvell Semiconductors, Inc.                    *
  *   Written by Nicolas Pitre <nico at marvell.com>                           *
  *                                                                         *
  *   Copyright (C) 2008 by Hongtao Zheng                                   *
@@ -22,10 +22,10 @@
  ***************************************************************************/
 
 /*
- * Marvell Feroceon support, including Orion and Kirkwood SOCs.
+ * Marvell Feroceon/Dragonite support.
  *
- * The Feroceon core mimics the ARM926 ICE interface with the following
- * differences:
+ * The Feroceon core, as found in the Orion and Kirkwood SoCs amongst others,
+ * mimics the ARM926 ICE interface with the following differences:
  *
  * - the MOE (method of entry) reporting is not implemented
  *
@@ -43,6 +43,9 @@
  *
  * - the DCC channel is half duplex (only one FIFO for both directions) with
  *   seemingly no proper flow control.
+ *
+ * The Dragonite core is the non-mmu version based on the ARM966 model, and
+ * it shares the above issues as well.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -50,11 +53,13 @@
 #endif
 
 #include "arm926ejs.h"
+#include "arm966e.h"
 #include "target_type.h"
 
 
 int feroceon_examine(struct target_s *target);
 int feroceon_target_create(struct target_s *target, Jim_Interp *interp);
+int dragonite_target_create(struct target_s *target, Jim_Interp *interp);
 int feroceon_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer);
 int feroceon_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int feroceon_quit(void);
@@ -111,7 +116,45 @@
 	.quit = feroceon_quit
 };
 
+target_type_t dragonite_target =
+{
+	.name = "dragonite",
 
+	.poll = arm7_9_poll,
+	.arch_state = armv4_5_arch_state,
+
+	.target_request_data = arm7_9_target_request_data,
+
+	.halt = arm7_9_halt,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+
+	.assert_reset = feroceon_assert_reset,
+	.deassert_reset = arm7_9_deassert_reset,
+	.soft_reset_halt = arm7_9_soft_reset_halt,
+
+	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory,
+	.bulk_write_memory = feroceon_bulk_write_memory,
+	.checksum_memory = arm7_9_checksum_memory,
+	.blank_check_memory = arm7_9_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+
+	.add_breakpoint = arm7_9_add_breakpoint,
+	.remove_breakpoint = arm7_9_remove_breakpoint,
+	.add_watchpoint = arm7_9_add_watchpoint,
+	.remove_watchpoint = arm7_9_remove_watchpoint,
+
+	.register_commands = arm966e_register_commands,
+	.target_create = dragonite_target_create,
+	.init_target = feroceon_init_target,
+	.examine = feroceon_examine,
+	.quit = feroceon_quit
+};
+
 int feroceon_dummy_clock_out(arm_jtag_t *jtag_info, uint32_t instr)
 {
 	scan_field_t fields[3];
@@ -632,17 +675,11 @@
 	return ERROR_OK;
 }
 
-int feroceon_target_create(struct target_s *target, Jim_Interp *interp)
+void feroceon_common_setup(struct target_s *target)
 {
-	armv4_5_common_t *armv4_5;
-	arm7_9_common_t *arm7_9;
-	arm926ejs_common_t *arm926ejs = calloc(1,sizeof(arm926ejs_common_t));
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	arm7_9_common_t *arm7_9 = armv4_5->arch_info;
 
-	arm926ejs_init_arch_info(target, arm926ejs, target->tap);
-
-	armv4_5 = target->arch_info;
-	arm7_9 = armv4_5->arch_info;
-
 	/* override some insn sequence functions */
 	arm7_9->change_to_arm = feroceon_change_to_arm;
 	arm7_9->read_core_regs = feroceon_read_core_regs;
@@ -661,10 +698,6 @@
 	/* MOE is not implemented */
 	arm7_9->examine_debug_reason = feroceon_examine_debug_reason;
 
-	/* the standard ARM926 methods don't always work (don't ask...) */
-	arm926ejs->read_cp15 = feroceon_read_cp15;
-	arm926ejs->write_cp15 = feroceon_write_cp15;
-
 	/* Note: asserting DBGRQ might not win over the undef exception.
 	   If that happens then just use "arm7_9 dbgrq disable". */
 	arm7_9->use_dbgrq = 1;
@@ -673,10 +706,32 @@
 	/* only one working comparator */
 	arm7_9->wp_available_max = 1;
 	arm7_9->wp1_used_default = -1;
+}
 
+int feroceon_target_create(struct target_s *target, Jim_Interp *interp)
+{
+	arm926ejs_common_t *arm926ejs = calloc(1,sizeof(arm926ejs_common_t));
+
+	arm926ejs_init_arch_info(target, arm926ejs, target->tap);
+	feroceon_common_setup(target);
+
+	/* the standard ARM926 methods don't always work (don't ask...) */
+	arm926ejs->read_cp15 = feroceon_read_cp15;
+	arm926ejs->write_cp15 = feroceon_write_cp15;
+
 	return ERROR_OK;
 }
 
+int dragonite_target_create(struct target_s *target, Jim_Interp *interp)
+{
+	arm966e_common_t *arm966e = calloc(1,sizeof(arm966e_common_t));
+
+	arm966e_init_arch_info(target, arm966e, target->tap);
+	feroceon_common_setup(target);
+
+	return ERROR_OK;
+}
+
 int feroceon_examine(struct target_s *target)
 {
 	armv4_5_common_t *armv4_5;

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-09-11 07:46:50 UTC (rev 2692)
+++ trunk/src/target/target.c	2009-09-11 08:03:46 UTC (rev 2693)
@@ -84,6 +84,7 @@
 extern target_type_t arm926ejs_target;
 extern target_type_t fa526_target;
 extern target_type_t feroceon_target;
+extern target_type_t dragonite_target;
 extern target_type_t xscale_target;
 extern target_type_t cortexm3_target;
 extern target_type_t cortexa8_target;
@@ -101,6 +102,7 @@
 	&arm926ejs_target,
 	&fa526_target,
 	&feroceon_target,
+	&dragonite_target,
 	&xscale_target,
 	&cortexm3_target,
 	&cortexa8_target,



From oharboe at mail.berlios.de  Fri Sep 11 10:04:51 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 10:04:51 +0200
Subject: [Openocd-svn] r2694 - trunk/src/target
Message-ID: <200909110804.n8B84pTe018889@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 10:04:50 +0200 (Fri, 11 Sep 2009)
New Revision: 2694

Modified:
   trunk/src/target/feroceon.c
Log:
Nicolas Pitre <nico at cam.org> put feroceon target definition at the end so to avoid a
bunch of useless forward declarations.

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2009-09-11 08:03:46 UTC (rev 2693)
+++ trunk/src/target/feroceon.c	2009-09-11 08:04:50 UTC (rev 2694)
@@ -56,14 +56,6 @@
 #include "arm966e.h"
 #include "target_type.h"
 
-
-int feroceon_examine(struct target_s *target);
-int feroceon_target_create(struct target_s *target, Jim_Interp *interp);
-int dragonite_target_create(struct target_s *target, Jim_Interp *interp);
-int feroceon_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer);
-int feroceon_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
-int feroceon_quit(void);
-
 int feroceon_assert_reset(target_t *target)
 {
 	armv4_5_common_t *armv4_5 = target->arch_info;
@@ -77,84 +69,6 @@
 	return arm7_9_assert_reset(target);
 }
 
-target_type_t feroceon_target =
-{
-	.name = "feroceon",
-
-	.poll = arm7_9_poll,
-	.arch_state = arm926ejs_arch_state,
-
-	.target_request_data = arm7_9_target_request_data,
-
-	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
-
-	.assert_reset = feroceon_assert_reset,
-	.deassert_reset = arm7_9_deassert_reset,
-	.soft_reset_halt = arm926ejs_soft_reset_halt,
-
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
-
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm926ejs_write_memory,
-	.bulk_write_memory = feroceon_bulk_write_memory,
-	.checksum_memory = arm7_9_checksum_memory,
-	.blank_check_memory = arm7_9_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
-	.add_breakpoint = arm7_9_add_breakpoint,
-	.remove_breakpoint = arm7_9_remove_breakpoint,
-	.add_watchpoint = arm7_9_add_watchpoint,
-	.remove_watchpoint = arm7_9_remove_watchpoint,
-
-	.register_commands = arm926ejs_register_commands,
-	.target_create = feroceon_target_create,
-	.init_target = feroceon_init_target,
-	.examine = feroceon_examine,
-	.quit = feroceon_quit
-};
-
-target_type_t dragonite_target =
-{
-	.name = "dragonite",
-
-	.poll = arm7_9_poll,
-	.arch_state = armv4_5_arch_state,
-
-	.target_request_data = arm7_9_target_request_data,
-
-	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
-
-	.assert_reset = feroceon_assert_reset,
-	.deassert_reset = arm7_9_deassert_reset,
-	.soft_reset_halt = arm7_9_soft_reset_halt,
-
-	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
-
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm7_9_write_memory,
-	.bulk_write_memory = feroceon_bulk_write_memory,
-	.checksum_memory = arm7_9_checksum_memory,
-	.blank_check_memory = arm7_9_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
-	.add_breakpoint = arm7_9_add_breakpoint,
-	.remove_breakpoint = arm7_9_remove_breakpoint,
-	.add_watchpoint = arm7_9_add_watchpoint,
-	.remove_watchpoint = arm7_9_remove_watchpoint,
-
-	.register_commands = arm966e_register_commands,
-	.target_create = dragonite_target_create,
-	.init_target = feroceon_init_target,
-	.examine = feroceon_examine,
-	.quit = feroceon_quit
-};
-
 int feroceon_dummy_clock_out(arm_jtag_t *jtag_info, uint32_t instr)
 {
 	scan_field_t fields[3];
@@ -765,3 +679,82 @@
 
 	return ERROR_OK;
 }
+
+target_type_t feroceon_target =
+{
+	.name = "feroceon",
+
+	.poll = arm7_9_poll,
+	.arch_state = arm926ejs_arch_state,
+
+	.target_request_data = arm7_9_target_request_data,
+
+	.halt = arm7_9_halt,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+
+	.assert_reset = feroceon_assert_reset,
+	.deassert_reset = arm7_9_deassert_reset,
+	.soft_reset_halt = arm926ejs_soft_reset_halt,
+
+	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm926ejs_write_memory,
+	.bulk_write_memory = feroceon_bulk_write_memory,
+	.checksum_memory = arm7_9_checksum_memory,
+	.blank_check_memory = arm7_9_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+
+	.add_breakpoint = arm7_9_add_breakpoint,
+	.remove_breakpoint = arm7_9_remove_breakpoint,
+	.add_watchpoint = arm7_9_add_watchpoint,
+	.remove_watchpoint = arm7_9_remove_watchpoint,
+
+	.register_commands = arm926ejs_register_commands,
+	.target_create = feroceon_target_create,
+	.init_target = feroceon_init_target,
+	.examine = feroceon_examine,
+	.quit = feroceon_quit
+};
+
+target_type_t dragonite_target =
+{
+	.name = "dragonite",
+
+	.poll = arm7_9_poll,
+	.arch_state = armv4_5_arch_state,
+
+	.target_request_data = arm7_9_target_request_data,
+
+	.halt = arm7_9_halt,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+
+	.assert_reset = feroceon_assert_reset,
+	.deassert_reset = arm7_9_deassert_reset,
+	.soft_reset_halt = arm7_9_soft_reset_halt,
+
+	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
+
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory,
+	.bulk_write_memory = feroceon_bulk_write_memory,
+	.checksum_memory = arm7_9_checksum_memory,
+	.blank_check_memory = arm7_9_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+
+	.add_breakpoint = arm7_9_add_breakpoint,
+	.remove_breakpoint = arm7_9_remove_breakpoint,
+	.add_watchpoint = arm7_9_add_watchpoint,
+	.remove_watchpoint = arm7_9_remove_watchpoint,
+
+	.register_commands = arm966e_register_commands,
+	.target_create = dragonite_target_create,
+	.init_target = feroceon_init_target,
+	.examine = feroceon_examine,
+	.quit = feroceon_quit
+};
+



From ntfreak at mail.berlios.de  Fri Sep 11 16:08:28 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Fri, 11 Sep 2009 16:08:28 +0200
Subject: [Openocd-svn] r2695 - trunk/tcl/interface
Message-ID: <200909111408.n8BE8Srk011158@sheep.berlios.de>

Author: ntfreak
Date: 2009-09-11 16:08:28 +0200 (Fri, 11 Sep 2009)
New Revision: 2695

Modified:
   trunk/tcl/interface/sheevaplug.cfg
Log:
- revert change made to sheevaplug.cfg in rev2573

Modified: trunk/tcl/interface/sheevaplug.cfg
===================================================================
--- trunk/tcl/interface/sheevaplug.cfg	2009-09-11 08:04:50 UTC (rev 2694)
+++ trunk/tcl/interface/sheevaplug.cfg	2009-09-11 14:08:28 UTC (rev 2695)
@@ -7,6 +7,6 @@
 interface ft2232
 ft2232_layout sheevaplug
 ft2232_vid_pid 0x9e88 0x9e8f
-ft2232_device_desc "SheevaPlug JTAGKey FT2232D"
+ft2232_device_desc "SheevaPlug JTAGKey FT2232D B"
 jtag_khz 2000
 



From oharboe at mail.berlios.de  Fri Sep 11 20:34:16 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 20:34:16 +0200
Subject: [Openocd-svn] r2696 - in trunk: src/flash src/jtag tcl/target
Message-ID: <200909111834.n8BIYGd9029080@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 20:34:15 +0200 (Fri, 11 Sep 2009)
New Revision: 2696

Modified:
   trunk/src/flash/str9xpec.c
   trunk/src/jtag/core.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/tcl.c
   trunk/tcl/target/omap3530.cfg
Log:
tap post reset event added. Allows omap3530 to send 100 runtest idle tickle's after a TAP_RESET.

Modified: trunk/src/flash/str9xpec.c
===================================================================
--- trunk/src/flash/str9xpec.c	2009-09-11 14:08:28 UTC (rev 2695)
+++ trunk/src/flash/str9xpec.c	2009-09-11 18:34:15 UTC (rev 2696)
@@ -1254,7 +1254,8 @@
 		return ERROR_FAIL;
 
 	/* exit turbo mode via RESET */
-	str9xpec_set_instr(tap, ISC_NOOP, TAP_RESET);
+	str9xpec_set_instr(tap, ISC_NOOP, TAP_IDLE);
+	jtag_add_tlr();
 	jtag_execute_queue();
 
 	/* restore previous scan chain */

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-11 14:08:28 UTC (rev 2695)
+++ trunk/src/jtag/core.c	2009-09-11 18:34:15 UTC (rev 2696)
@@ -62,6 +62,7 @@
 {
 	[JTAG_TRST_ASSERTED] = "JTAG controller reset (TLR or TRST)",
 	[JTAG_TAP_EVENT_ENABLE] = "TAP enabled",
+	[JTAG_TAP_EVENT_POST_RESET] = "post reset",
 	[JTAG_TAP_EVENT_DISABLE] = "TAP disabled",
 };
 
@@ -339,6 +340,8 @@
 
 void jtag_add_ir_scan(int in_num_fields, scan_field_t *in_fields, tap_state_t state)
 {
+	assert(state != TAP_RESET);
+
 	if (jtag_verify && jtag_verify_capture_ir)
 	{
 		/* 8 x 32 bit id's is enough for all invocations */
@@ -361,6 +364,8 @@
 void jtag_add_plain_ir_scan(int in_num_fields, const scan_field_t *in_fields,
 		tap_state_t state)
 {
+	assert(state != TAP_RESET);
+
 	jtag_prelude(state);
 
 	int retval = interface_jtag_add_plain_ir_scan(
@@ -439,6 +444,8 @@
 void jtag_add_dr_scan(int in_num_fields, const scan_field_t *in_fields,
 		tap_state_t state)
 {
+	assert(state != TAP_RESET);
+	
 	jtag_prelude(state);
 
 	int retval;
@@ -449,6 +456,8 @@
 void jtag_add_plain_dr_scan(int in_num_fields, const scan_field_t *in_fields,
 		tap_state_t state)
 {
+	assert(state != TAP_RESET);
+	
 	jtag_prelude(state);
 
 	int retval;
@@ -460,6 +469,8 @@
 		int num_fields, const int* num_bits, const uint32_t* value,
 		tap_state_t end_state)
 {
+	assert(end_state != TAP_RESET);
+	
 	assert(end_state != TAP_INVALID);
 
 	cmd_queue_cur_state = end_state;
@@ -473,6 +484,9 @@
 {
 	jtag_prelude(TAP_RESET);
 	jtag_set_error(interface_jtag_add_tlr());
+
+	jtag_notify_reset();
+
 	jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
 }
 
@@ -683,6 +697,8 @@
 			LOG_DEBUG("TRST line released");
 			if (jtag_ntrst_delay)
 				jtag_add_sleep(jtag_ntrst_delay * 1000);
+
+			jtag_notify_reset();
 		}
 	}
 }
@@ -851,7 +867,8 @@
 	for (unsigned i = 0; i < JTAG_MAX_CHAIN_SIZE; i++)
 		buf_set_u32(idcode_buffer, i * 32, 32, 0x000000FF);
 
-	jtag_add_plain_dr_scan(1, &field, TAP_RESET);
+	jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
+	jtag_add_tlr();
 	return jtag_execute_queue();
 }
 
@@ -1065,7 +1082,9 @@
 	field.in_value = ir_test;
 
 
-	jtag_add_plain_ir_scan(1, &field, TAP_RESET);
+	jtag_add_plain_ir_scan(1, &field, TAP_IRPAUSE);
+	jtag_add_tlr();
+
 	int retval;
 	retval = jtag_execute_queue();
 	if (retval != ERROR_OK)

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-09-11 14:08:28 UTC (rev 2695)
+++ trunk/src/jtag/jtag.h	2009-09-11 18:34:15 UTC (rev 2696)
@@ -208,6 +208,7 @@
 	JTAG_TRST_ASSERTED,
 	JTAG_TAP_EVENT_ENABLE,
 	JTAG_TAP_EVENT_DISABLE,
+	JTAG_TAP_EVENT_POST_RESET,
 };
 
 struct jtag_tap_event_action_s
@@ -635,7 +636,10 @@
 /// @returns the number of times the scan queue has been flushed
 int jtag_get_flush_queue_count(void);
 
+/// Notify all TAP's about a TLR reset
+void jtag_notify_reset(void);
 
+
 /* can be implemented by hw + sw */
 extern int jtag_power_dropout(int* dropout);
 extern int jtag_srst_asserted(int* srst_asserted);

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-11 14:08:28 UTC (rev 2695)
+++ trunk/src/jtag/tcl.c	2009-09-11 18:34:15 UTC (rev 2696)
@@ -41,6 +41,7 @@
 #endif
 
 static const Jim_Nvp nvp_jtag_tap_event[] = {
+	{ .value = JTAG_TAP_EVENT_POST_RESET,   .name = "post-reset" },
 	{ .value = JTAG_TAP_EVENT_ENABLE,       .name = "tap-enable" },
 	{ .value = JTAG_TAP_EVENT_DISABLE,      .name = "tap-disable" },
 
@@ -583,6 +584,17 @@
 	return JIM_ERR;
 }
 
+
+void jtag_notify_reset(void)
+{
+	jtag_tap_t *tap;
+	for (tap = jtag_all_taps(); tap; tap = tap->next_tap)
+	{
+		jtag_tap_handle_event(tap, JTAG_TAP_EVENT_POST_RESET);
+	}
+}
+
+
 int jtag_register_commands(struct command_context_s *cmd_ctx)
 {
 	register_jim(cmd_ctx, "jtag", jim_jtag_command, "perform jtag tap actions");

Modified: trunk/tcl/target/omap3530.cfg
===================================================================
--- trunk/tcl/target/omap3530.cfg	2009-09-11 14:08:28 UTC (rev 2695)
+++ trunk/tcl/target/omap3530.cfg	2009-09-11 18:34:15 UTC (rev 2696)
@@ -34,6 +34,8 @@
 jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
 	-expected-id $_JRC_TAPID
 
+jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"
+
 # GDB target:  Cortex-A8, using DAP
 target create omap3.cpu cortex_a8 -chain-position $_CHIPNAME.dap
 



From oharboe at mail.berlios.de  Fri Sep 11 23:14:31 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 11 Sep 2009 23:14:31 +0200
Subject: [Openocd-svn] r2697 - trunk
Message-ID: <200909112114.n8BLEVuZ012667@sheep.berlios.de>

Author: oharboe
Date: 2009-09-11 23:14:31 +0200 (Fri, 11 Sep 2009)
New Revision: 2697

Modified:
   trunk/TODO
Log:
David Brownell <david-b at pacbell.net> some early todo items on run_algorithm

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2009-09-11 18:34:15 UTC (rev 2696)
+++ trunk/TODO	2009-09-11 21:14:31 UTC (rev 2697)
@@ -132,6 +132,10 @@
   ARM1156 has Thumb2; ARM1136 doesn't.
 - Cortex A8 support (ML)
   - add target implementation (ML)
+- Generic ARM run_algorithm() interface
+  - tagged struct wrapping ARM instructions and metadata
+  - not revision-specific (current: ARMv4+ARMv5 -or- ARMv6 -or- ARMv7)
+  - usable with at least arm_nandwrite() and generic CFI drivers
 - MC1322x support (JW/DE?)
   - integrate and test support from JW (and DE?)
   - get working with a known good interface (i.e. not today's jlink)



From oharboe at mail.berlios.de  Sat Sep 12 10:10:22 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sat, 12 Sep 2009 10:10:22 +0200
Subject: [Openocd-svn] r2698 - trunk/src/target
Message-ID: <200909120810.n8C8AMve004550@sheep.berlios.de>

Author: oharboe
Date: 2009-09-12 10:10:19 +0200 (Sat, 12 Sep 2009)
New Revision: 2698

Modified:
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7_9_common.h
   trunk/src/target/armv7m.c
Log:
David Brownell <david-b at pacbell.net> 
Cleanup some the downloaded ARM target algorithm code:

 - Provide more complete disassembly of the DCC bulk write code

 - Make code blocks "static const", in case GCC doesn't

 - Fix some tabbing/layout issues

 - Make some arm7_9_common.h flags be "bool" not "int"; and compact
   the layout a bit (group most bools together)

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-09-11 21:14:31 UTC (rev 2697)
+++ trunk/src/target/arm7_9_common.c	2009-09-12 08:10:19 UTC (rev 2698)
@@ -2657,8 +2657,21 @@
 
 static const uint32_t dcc_code[] =
 {
-	/* MRC      TST         BNE         MRC         STR         B */
-	0xee101e10, 0xe3110001, 0x0afffffc, 0xee111e10, 0xe4801004, 0xeafffff9
+	/* r0 == input, points to memory buffer
+	 * r1 == scratch
+	 */
+
+	/* spin until DCC control (c0) reports data arrived */
+	0xee101e10,	/* w: mrc p14, #0, r1, c0, c0 */
+	0xe3110001,	/*    tst r1, #1              */
+	0x0afffffc,	/*    bne w                   */
+
+	/* read word from DCC (c1), write to memory */
+	0xee111e10,	/*    mrc p14, #0, r1, c1, c0 */
+	0xe4801004,	/*    str r1, [r0], #4        */
+
+	/* repeat */
+	0xeafffff9	/*    b   w                   */
 };
 
 int armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, uint32_t exit_point, int timeout_ms, void *arch_info));
@@ -2736,7 +2749,7 @@
 	reg_param_t reg_params[2];
 	int retval;
 
-	uint32_t arm7_9_crc_code[] = {
+	static const uint32_t arm7_9_crc_code[] = {
 		0xE1A02000,				/* mov		r2, r0 */
 		0xE3E00000,				/* mov		r0, #0xffffffff */
 		0xE1A03001,				/* mov		r3, r1 */
@@ -2818,15 +2831,15 @@
 	int retval;
 	uint32_t i;
 
-	uint32_t erase_check_code[] =
+	static const uint32_t erase_check_code[] =
 	{
-						/* loop: */
-		0xe4d03001,		/* ldrb r3, [r0], #1	*/
-		0xe0022003,		/* and r2, r2, r3 		*/
-		0xe2511001, 	/* subs r1, r1, #1		*/
-		0x1afffffb,		/* bne loop				*/
-						/* end: */
-		0xeafffffe		/* b end				*/
+		/* loop: */
+		0xe4d03001,		/* ldrb r3, [r0], #1 */
+		0xe0022003,		/* and r2, r2, r3    */
+		0xe2511001,		/* subs r1, r1, #1   */
+		0x1afffffb,		/* bne loop          */
+		/* end: */
+		0xeafffffe		/* b end             */
 	};
 
 	/* make sure we have a working area */

Modified: trunk/src/target/arm7_9_common.h
===================================================================
--- trunk/src/target/arm7_9_common.h	2009-09-11 21:14:31 UTC (rev 2697)
+++ trunk/src/target/arm7_9_common.h	2009-09-12 08:10:19 UTC (rev 2698)
@@ -46,6 +46,8 @@
 
 	uint32_t arm_bkpt; /**< ARM breakpoint instruction */
 	uint16_t thumb_bkpt; /**< Thumb breakpoint instruction */
+	bool force_hw_bkpts;
+
 	int sw_breakpoints_added; /**< Specifies which watchpoint software breakpoints are setup on */
 	int sw_breakpoint_count; /**< keep track of number of software breakpoints we have set */
 	int breakpoint_count; /**< Current number of set breakpoints */
@@ -54,24 +56,23 @@
 	int wp0_used; /**< Specifies if and how watchpoint unit 0 is used */
 	int wp1_used; /**< Specifies if and how watchpoint unit 1 is used */
 	int wp1_used_default; /**< Specifies if and how watchpoint unit 1 is used by default */
-	int force_hw_bkpts;
 	int dbgreq_adjust_pc; /**< Amount of PC adjustment caused by a DBGREQ */
-	int use_dbgrq; /**< Specifies if DBGRQ should be used to halt the target */
-	int need_bypass_before_restart; /**< Specifies if there should be a bypass before a JTAG restart */
+	bool use_dbgrq; /**< Specifies if DBGRQ should be used to halt the target */
+	bool need_bypass_before_restart; /**< Specifies if there should be a bypass before a JTAG restart */
 
-	etm_context_t *etm_ctx;
+	bool has_single_step;
+	bool has_monitor_mode;
+	bool has_vector_catch; /**< Specifies if the target has a reset vector catch */
 
-	int has_single_step;
-	int has_monitor_mode;
-	int has_vector_catch; /**< Specifies if the target has a reset vector catch */
+	bool debug_entry_from_reset; /**< Specifies if debug entry was from a reset */
 
-	int debug_entry_from_reset; /**< Specifies if debug entry was from a reset */
+	bool fast_memory_access;
+	bool dcc_downloads;
 
+	etm_context_t *etm_ctx;
+
 	struct working_area_s *dcc_working_area;
 
-	int fast_memory_access;
-	int dcc_downloads;
-
 	int (*examine_debug_reason)(target_t *target); /**< Function for determining why debug state was entered */
 
 	void (*change_to_arm)(target_t *target, uint32_t *r0, uint32_t *pc); /**< Function for changing from Thumb to ARM mode */

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-09-11 21:14:31 UTC (rev 2697)
+++ trunk/src/target/armv7m.c	2009-09-12 08:10:19 UTC (rev 2698)
@@ -573,7 +573,7 @@
 	reg_param_t reg_params[2];
 	int retval;
 
-	uint16_t cortex_m3_crc_code[] = {
+	static const uint16_t cortex_m3_crc_code[] = {
 		0x4602,					/* mov	r2, r0 */
 		0xF04F, 0x30FF,			/* mov	r0, #0xffffffff */
 		0x460B,					/* mov	r3, r1 */
@@ -655,11 +655,11 @@
 	int retval;
 	uint32_t i;
 
-	uint16_t erase_check_code[] =
+	static const uint16_t erase_check_code[] =
 	{
 							/* loop: */
-		0xF810, 0x3B01,		/* ldrb 	r3, [r0], #1 */
-		0xEA02, 0x0203,		/* and 	r2, r2, r3 */
+		0xF810, 0x3B01,		/* ldrb r3, [r0], #1 */
+		0xEA02, 0x0203,		/* and  r2, r2, r3 */
 		0x3901,				/* subs 	r1, r1, #1 */
 		0xD1F9,				/* bne		loop */
 							/* end: */



From oharboe at mail.berlios.de  Sat Sep 12 10:11:47 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sat, 12 Sep 2009 10:11:47 +0200
Subject: [Openocd-svn] r2699 - in trunk/tcl: board target
Message-ID: <200909120811.n8C8BlYI006649@sheep.berlios.de>

Author: oharboe
Date: 2009-09-12 10:11:45 +0200 (Sat, 12 Sep 2009)
New Revision: 2699

Modified:
   trunk/tcl/board/dm355evm.cfg
   trunk/tcl/target/davinci.cfg
   trunk/tcl/target/ti_dm355.cfg
Log:
David Brownell <david-b at pacbell.net> 
Update the board config for the DaVinci DM355 EVM so the reset-init
event handler does the rest of the work it should do:

 - minor PLL setup bugfixes
 - initialize the DDR2 controller
 - probe both NAND banks
 - initialize UART0
 - enable the icache


Modified: trunk/tcl/board/dm355evm.cfg
===================================================================
--- trunk/tcl/board/dm355evm.cfg	2009-09-12 08:10:19 UTC (rev 2698)
+++ trunk/tcl/board/dm355evm.cfg	2009-09-12 08:11:45 UTC (rev 2699)
@@ -35,7 +35,7 @@
 	set addr [dict get $dm355 pllc1]
 	set pll_divs [dict create]
 	dict set pll_divs div3 16
-	dict set pll_divs div4 8
+	dict set pll_divs div4 4
 	pll_v02_setup $addr 144 $pll_divs
 
 	# ARM is now running at 216 MHz, so JTAG can go faster
@@ -48,6 +48,7 @@
 
 	set addr [dict get $dm355 pllc2]
 	set pll_divs [dict create]
+	dict set pll_divs div1 1
 	dict set pll_divs prediv 8
 	pll_v02_setup $addr 114 $pll_divs
 
@@ -77,8 +78,55 @@
 	########################
 	# DDR2 EMIF
 
-	# FIXME setup
+	# VTPIOCR impedance calibration
+	set addr [dict get $dm355 sysbase]
+	set addr [expr $addr + 0x70]
 
+	# clear CLR, LOCK, PWRDN; wait a clock; set CLR
+	mmw $addr 0 0x20c0
+	mmw $addr 0x2000 0
+
+	# wait for READY
+        while { [expr [mrw $addr] & 0x8000] == 0 } { sleep 1 }
+
+	# set IO_READY; then LOCK and PWRSAVE; then PWRDN
+	mmw $addr 0x4000 0
+	mmw $addr 0x0180 0
+	mmw $addr 0x0040 0
+
+	# NOTE:  this DDR2 initialization sequence borrows from
+	# both UBL 1.50 and the SPRUEH7D DDR2 EMIF spec.
+
+	# reset (then re-enable) DDR controller
+	psc_reset 13
+	psc_go
+	psc_enable 13
+	psc_go
+
+	# now set it up for Micron MT47H64M16HR-37E @ 171 MHz
+
+	set addr [dict get $dm355 ddr_emif]
+
+	# DDRPHYCR1
+	mww [expr $addr + 0xe4] 0x50006404
+
+	# PBBPR -- burst priority
+	mww [expr $addr + 0x20] 0xfe
+
+	# SDCR -- unlock boot config; init for DDR2, relock, unlock SDTIM*
+	mmw [expr $addr + 0x08] 0x00800000 0
+	mmw [expr $addr + 0x08] 0x0013c632 0x03870fff
+
+	# SDTIMR, SDTIMR2
+	mww [expr $addr + 0x10] 0x2a923249
+	mww [expr $addr + 0x14] 0x4c17c763
+
+	# SDCR -- relock SDTIM*
+	mmw [expr $addr + 0x08] 0 0x00008000
+
+	# SDRCR -- refresh rate (171 MHz * 7.8usec)
+	mww [expr $addr + 0x0c] 1336
+
 	########################
 	# ASYNC EMIF
 
@@ -98,10 +146,43 @@
 	# NANDFCR -- only CS0 has NAND
 	mww [expr $addr + 0x60] 0x01
 
+	# default: both chipselects to the NAND socket are used
+	nand probe 0
+	nand probe 1
+
 	########################
 	# UART0
 
-	# FIXME setup
+	set addr [dict get $dm355 uart0]
+
+	# PWREMU_MGNT -- rx + tx in reset
+	mww [expr $addr + 0x30] 0
+
+	# DLL, DLH -- 115200 baud
+	mwb [expr $addr + 0x20] 0x0d
+	mwb [expr $addr + 0x24] 0x00
+
+	# FCR - clear and disable FIFOs
+	mwb [expr $addr + 0x08] 0x07
+	mwb [expr $addr + 0x08] 0x00
+
+	# IER - disable IRQs
+	mwb [expr $addr + 0x04] 0x00
+
+	# LCR - 8-N-1
+	mwb [expr $addr + 0x0c] 0x03
+
+	# MCR - no flow control or loopback
+	mwb [expr $addr + 0x10] 0x00
+
+	# PWREMU_MGNT -- rx + tx normal, free running during JTAG halt
+	mww [expr $addr + 0x30] 0xe001
+
+
+	########################
+
+	# turn on icache - set I bit in cp15 register c1
+	arm926ejs cp15 0 0 1 0 0x00051078
 }
 
 # NAND -- socket has two chipselects, MT29F16G08FAA puts 1GByte on each one.

Modified: trunk/tcl/target/davinci.cfg
===================================================================
--- trunk/tcl/target/davinci.cfg	2009-09-12 08:10:19 UTC (rev 2698)
+++ trunk/tcl/target/davinci.cfg	2009-09-12 08:11:45 UTC (rev 2699)
@@ -125,6 +125,7 @@
 		set pllstat [expr $pll_addr + 0x013c]
 		while {[expr [mrw $pllstat] & 0x01] != 0} { sleep 1 }
 	}
+	mww [expr $pll_addr + 0x0138] 0x00
 
 	# 11 - wait at least 5 usec for reset to finish
 	# (assume covered by overheads including JTAG messaging)
@@ -152,7 +153,14 @@
 	mmw [expr $psc_addr + 0x0a00 + (4 * $module)] 0x03 0x1f
 }
 
-# execute non-DSP PSC transition(s) set up by psc_enable
+# prepare a non-DSP module to be reset; finish with psc_go
+proc psc_reset {module} {
+	set psc_addr 0x01c41000
+	# write MDCTL
+	mmw [expr $psc_addr + 0x0a00 + (4 * $module)] 0x01 0x1f
+}
+
+# execute non-DSP PSC transition(s) set up by psc_enable, psc_reset, etc
 proc psc_go {} {
 	set psc_addr 0x01c41000
 	set ptstat_addr [expr $psc_addr + 0x0128]

Modified: trunk/tcl/target/ti_dm355.cfg
===================================================================
--- trunk/tcl/target/ti_dm355.cfg	2009-09-12 08:10:19 UTC (rev 2698)
+++ trunk/tcl/target/ti_dm355.cfg	2009-09-12 08:11:45 UTC (rev 2699)
@@ -65,6 +65,9 @@
 dict set dm355 a_emif_cs1	0x04000000
 dict set dm355 ddr_emif		0x20000000
 dict set dm355 ddr		0x80000000
+dict set dm355 uart0		0x01c20000
+dict set dm355 uart1		0x01c20400
+dict set dm355 uart2		0x01e06000
 
 source [find target/davinci.cfg]
 



From oharboe at mail.berlios.de  Sat Sep 12 15:05:21 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sat, 12 Sep 2009 15:05:21 +0200
Subject: [Openocd-svn] r2700 - trunk/doc
Message-ID: <200909121305.n8CD5L42017598@sheep.berlios.de>

Author: oharboe
Date: 2009-09-12 15:05:20 +0200 (Sat, 12 Sep 2009)
New Revision: 2700

Modified:
   trunk/doc/openocd.texi
Log:
Dirk Behme <dirk.behme at googlemail.com> document post TAP reset event

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-12 08:11:45 UTC (rev 2699)
+++ trunk/doc/openocd.texi	2009-09-12 13:05:20 UTC (rev 2700)
@@ -2289,14 +2289,14 @@
 
 @deffn Command {jtag cget} dotted.name @option{-event} name
 @deffnx Command {jtag configure} dotted.name @option{-event} name string
-At this writing this mechanism is used only for event handling,
-and the only two events relate to TAP enabling and disabling.
+At this writing this mechanism is used only for event handling.
+Three events are available. Two events relate to TAP enabling
+and disabling, one to post reset handling.
 
 The @code{configure} subcommand assigns an event handler,
 a TCL string which is evaluated when the event is triggered.
 The @code{cget} subcommand returns that handler.
-The two possible values for an event @var{name}
-are @option{tap-disable} and @option{tap-enable}.
+The three possible values for an event @var{name} are @option{tap-disable}, @option{tap-enable} and @option{post-reset}.
 
 So for example, when defining a TAP for a CPU connected to
 a JTAG router, you should define TAP event handlers using
@@ -2312,6 +2312,15 @@
   ... jtag operations using CHIP.jrc
 @}
 @end example
+
+If you need some post reset action, you can do:
+
+ at example
+jtag configure CHIP.cpu -event post-reset @{
+  echo "Reset done"
+  ... jtag operations to be done after reset
+@}
+ at end example
 @end deffn
 
 @deffn Command {jtag tapdisable} dotted.name



From mlu at mail.berlios.de  Sun Sep 13 15:58:09 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Sun, 13 Sep 2009 15:58:09 +0200
Subject: [Openocd-svn] r2701 - trunk/src/target
Message-ID: <200909131358.n8DDw9en020096@sheep.berlios.de>

Author: mlu
Date: 2009-09-13 15:57:50 +0200 (Sun, 13 Sep 2009)
New Revision: 2701

Modified:
   trunk/src/target/cortex_a8.c
Log:
Fix argument passing in cortex_a8_write_cp.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-12 13:05:20 UTC (rev 2700)
+++ trunk/src/target/cortex_a8.c	2009-09-13 13:57:50 UTC (rev 2701)
@@ -224,7 +224,6 @@
 
 int cortex_a8_write_cp(target_t *target, uint32_t value,
 	uint8_t CP, uint8_t op1, uint8_t CRn, uint8_t CRm, uint8_t op2)
-/* TODO Fix this */
 {
 	int retval;
 	/* get pointers to arch-specific information */
@@ -237,7 +236,7 @@
 	/* Move DTRRX to r0 */
 	cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
 
-	cortex_a8_exec_opcode(target, ARMV4_5_MCR(CP, 0, 0, 0, 5, 0));
+	cortex_a8_exec_opcode(target, ARMV4_5_MCR(CP, op1, 0, CRn, CRm, op2));
 	return retval;
 }
 



From mlu at mail.berlios.de  Sun Sep 13 19:26:13 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Sun, 13 Sep 2009 19:26:13 +0200
Subject: [Openocd-svn] r2702 - trunk/src/target
Message-ID: <200909131726.n8DHQDl1031892@sheep.berlios.de>

Author: mlu
Date: 2009-09-13 19:26:07 +0200 (Sun, 13 Sep 2009)
New Revision: 2702

Modified:
   trunk/src/target/cortex_a8.h
Log:
More CortexA8 debug register definitions.

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-09-13 13:57:50 UTC (rev 2701)
+++ trunk/src/target/cortex_a8.h	2009-09-13 17:26:07 UTC (rev 2702)
@@ -43,6 +43,7 @@
 #define CPUDBG_DIDR		0x000
 #define CPUDBG_WFAR		0x018
 #define CPUDBG_VCR	0x01C
+#define CPUDBG_ECR	0x024
 #define CPUDBG_DSCCR	0x028
 #define CPUDBG_DTRRX	0x080
 #define CPUDBG_ITR	0x084
@@ -63,6 +64,9 @@
 #define CPUDBG_CPUID	0xD00
 #define CPUDBG_CTYPR	0xD04
 #define CPUDBG_TTYPR	0xD0C
+#define CPUDBG_LOCKACCESS 0xFB0
+#define CPUDBG_LOCKSTATUS 0xFB4
+#define CPUDBG_AUTHSTATUS 0xFB8
 
 #define BRP_NORMAL 0
 #define BRP_CONTEXT 1



From oharboe at mail.berlios.de  Sun Sep 13 22:07:13 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Sun, 13 Sep 2009 22:07:13 +0200
Subject: [Openocd-svn] r2703 - trunk/tcl/target
Message-ID: <200909132007.n8DK7DTP012198@sheep.berlios.de>

Author: oharboe
Date: 2009-09-13 22:07:13 +0200 (Sun, 13 Sep 2009)
New Revision: 2703

Modified:
   trunk/tcl/target/omap3530.cfg
Log:
Magnus Lundin <lundin at mlu.mine.nu> Disable poll while core register initialization

Modified: trunk/tcl/target/omap3530.cfg
===================================================================
--- trunk/tcl/target/omap3530.cfg	2009-09-13 17:26:07 UTC (rev 2702)
+++ trunk/tcl/target/omap3530.cfg	2009-09-13 20:07:13 UTC (rev 2703)
@@ -41,6 +41,7 @@
 
 # FIXME much of this should be in reset event handlers
 proc omap3_dbginit { } {
+     poll off
      reset
      sleep 500
 
@@ -65,4 +66,5 @@
      # omap3.cpu mdw 0x54011080
 
      omap3.cpu mww 0x5401d030 0x00002000
+     poll on
 }



From oharboe at mail.berlios.de  Mon Sep 14 08:06:36 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 14 Sep 2009 08:06:36 +0200
Subject: [Openocd-svn] r2704 - trunk/src/flash
Message-ID: <200909140606.n8E66a2n015827@sheep.berlios.de>

Author: oharboe
Date: 2009-09-14 08:06:35 +0200 (Mon, 14 Sep 2009)
New Revision: 2704

Modified:
   trunk/src/flash/cfi.c
Log:
fix warning

Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-09-13 20:07:13 UTC (rev 2703)
+++ trunk/src/flash/cfi.c	2009-09-14 06:06:35 UTC (rev 2704)
@@ -1448,7 +1448,7 @@
 	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
 
 	/* flash write code */
-	int target_code_size;
+	int target_code_size = 0;
 	if (!cfi_info->write_algorithm)
 	{
 		uint8_t *target_code;



From oharboe at mail.berlios.de  Mon Sep 14 09:48:29 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 14 Sep 2009 09:48:29 +0200
Subject: [Openocd-svn] r2705 - trunk/src/flash
Message-ID: <200909140748.n8E7mToe012244@sheep.berlios.de>

Author: oharboe
Date: 2009-09-14 09:48:28 +0200 (Mon, 14 Sep 2009)
New Revision: 2705

Modified:
   trunk/src/flash/cfi.c
Log:
Rolf Meeser <rolfm_9dq at yahoo.de> warning fix in previous commit was wrong. target_code_size needs the real value later.

Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-09-14 06:06:35 UTC (rev 2704)
+++ trunk/src/flash/cfi.c	2009-09-14 07:48:28 UTC (rev 2705)
@@ -1125,12 +1125,12 @@
 	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
 
 	/* If we are setting up the write_algorith, we need target_code_src */
-	/* if not we only need target_code_size.														*/
-	/* 																																	*/
-	/* However, we don't want to create multiple code paths, so we			*/
-	/* do the unecessary evaluation of target_code_src, which the 			*/
-	/* compiler will probably nicely optimize away if not needed				*/
+	/* if not we only need target_code_size. */
 
+	/* However, we don't want to create multiple code paths, so we */
+	/* do the unecessary evaluation of target_code_src, which the */
+	/* compiler will probably nicely optimize away if not needed */
+
 	/* prepare algorithm code for target endian */
 	switch (bank->bus_width)
 	{
@@ -1447,44 +1447,46 @@
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
 	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
 
+	int target_code_size;
+	const uint32_t *target_code_src;
+
+	switch (bank->bus_width)
+	{
+	case 1 :
+		target_code_src = word_8_code;
+		target_code_size = sizeof(word_8_code);
+		break;
+	case 2 :
+		/* Check for DQ5 support */
+		if( cfi_info->status_poll_mask & (1 << 5) )
+		{
+			target_code_src = word_16_code;
+			target_code_size = sizeof(word_16_code);
+		}
+		else
+		{
+			/* No DQ5 support. Use DQ7 DATA# polling only. */
+			target_code_src = word_16_code_dq7only;
+			target_code_size = sizeof(word_16_code_dq7only);
+		}
+		break;
+	case 4 :
+		target_code_src = word_32_code;
+		target_code_size = sizeof(word_32_code);
+		break;
+	default:
+		LOG_ERROR("Unsupported bank buswidth %d, can't do block memory writes", bank->bus_width);
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
 	/* flash write code */
-	int target_code_size = 0;
 	if (!cfi_info->write_algorithm)
 	{
 		uint8_t *target_code;
-		const uint32_t *src;
 
 		/* convert bus-width dependent algorithm code to correct endiannes */
-		switch (bank->bus_width)
-		{
-		case 1:
-			src = word_8_code;
-			target_code_size = sizeof(word_8_code);
-			break;
-		case 2:
-			/* Check for DQ5 support */
-			if( cfi_info->status_poll_mask & (1 << 5) )
-			{
-				src = word_16_code;
-				target_code_size = sizeof(word_16_code);
-			}
-			else
-			{
-				/* No DQ5 support. Use DQ7 DATA# polling only. */
-				src = word_16_code_dq7only;
-				target_code_size = sizeof(word_16_code_dq7only);
-			}
-			break;
-		case 4:
-			src = word_32_code;
-			target_code_size = sizeof(word_32_code);
-			break;
-		default:
-			LOG_ERROR("Unsupported bank buswidth %d, can't do block memory writes", bank->bus_width);
-			return ERROR_FLASH_OPERATION_FAILED;
-		}
 		target_code = malloc(target_code_size);
-		cfi_fix_code_endian(target, target_code, src, target_code_size / 4);
+		cfi_fix_code_endian(target, target_code, target_code_src, target_code_size / 4);
 
 		/* allocate working area */
 		retval = target_alloc_working_area(target, target_code_size,



From oharboe at mail.berlios.de  Mon Sep 14 10:04:00 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 14 Sep 2009 10:04:00 +0200
Subject: [Openocd-svn] r2706 - trunk/src/flash
Message-ID: <200909140804.n8E840AF013169@sheep.berlios.de>

Author: oharboe
Date: 2009-09-14 10:03:57 +0200 (Mon, 14 Sep 2009)
New Revision: 2706

Modified:
   trunk/src/flash/nand_ecc_kw.c
Log:
fix email address

Modified: trunk/src/flash/nand_ecc_kw.c
===================================================================
--- trunk/src/flash/nand_ecc_kw.c	2009-09-14 07:48:28 UTC (rev 2705)
+++ trunk/src/flash/nand_ecc_kw.c	2009-09-14 08:03:57 UTC (rev 2706)
@@ -3,7 +3,7 @@
  * Copyright (C) 2009 Marvell Semiconductor, Inc.
  *
  * Authors: Lennert Buytenhek <buytenh at wantstofly.org>
- *          Nicolas Pitre <nico at cam.org>
+ *          Nicolas Pitre <nico at fluxnic.net>
  *
  * This file is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the



From oharboe at mail.berlios.de  Mon Sep 14 15:54:51 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 14 Sep 2009 15:54:51 +0200
Subject: [Openocd-svn] r2707 - trunk/src/helper
Message-ID: <200909141354.n8EDspOK026266@sheep.berlios.de>

Author: oharboe
Date: 2009-09-14 15:54:49 +0200 (Mon, 14 Sep 2009)
New Revision: 2707

Modified:
   trunk/src/helper/startup.tcl
Log:
error message upon recursive invocation of reset from reset event handlers

Modified: trunk/src/helper/startup.tcl
===================================================================
--- trunk/src/helper/startup.tcl	2009-09-14 08:03:57 UTC (rev 2706)
+++ trunk/src/helper/startup.tcl	2009-09-14 13:54:49 UTC (rev 2707)
@@ -134,8 +134,30 @@
 	reset halt
 }
 
+global in_process_reset
+set in_process_reset 0
+
+# Catch reset recursion
 proc ocd_process_reset { MODE } {
+	global in_process_reset
+	if {$in_process_reset} {
+		set in_process_reset 0
+		return -code error "'reset' can not be invoked recursively"
+	}
+	
+	set in_process_reset 1
+	set success [expr [catch {ocd_process_reset_inner $MODE} result]==0] 
+	set in_process_reset 0
+	
+	if {$success} {
+		return $result
+	} else {
+		return -code error $result
+	}
+}
 
+proc ocd_process_reset_inner { MODE } {
+
 	# If this target must be halted...
 	set halt -1
 	if { 0 == [string compare $MODE halt] } {



From mlu at mail.berlios.de  Tue Sep 15 00:36:46 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Tue, 15 Sep 2009 00:36:46 +0200
Subject: [Openocd-svn] r2708 - trunk/src/target
Message-ID: <200909142236.n8EMakE0028177@sheep.berlios.de>

Author: mlu
Date: 2009-09-15 00:36:27 +0200 (Tue, 15 Sep 2009)
New Revision: 2708

Modified:
   trunk/src/target/cortex_a8.c
Log:
Cache invalidation when writing to memory

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-14 13:54:49 UTC (rev 2707)
+++ trunk/src/target/cortex_a8.c	2009-09-14 22:36:27 UTC (rev 2708)
@@ -1253,6 +1253,24 @@
 			exit(-1);
 	}
 
+	/* The Cache handling will NOT work with MMU active, the wrong addresses will be invalidated */
+	/* invalidate I-Cache */
+	if (armv7a->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
+	{
+		/* Invalidate ICache single entry with MVA, repeat this for all cache
+		   lines in the address range, Cortex-A8 has fixed 64 byte line length */
+		/* Invalidate Cache single entry with MVA to PoU */
+		for (uint32_t cacheline=address; cacheline<address+size*count; cacheline+=64)
+			armv7a->write_cp15(target, 0, 1, 7, 5, cacheline); /* I-Cache to PoU */
+	}
+	/* invalidate D-Cache */
+	if (armv7a->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
+	{
+		/* Invalidate Cache single entry with MVA to PoC */
+		for (uint32_t cacheline=address; cacheline<address+size*count; cacheline+=64)
+			armv7a->write_cp15(target, 0, 1, 7, 6, cacheline); /* U/D cache to PoC */
+	}
+
 	return retval;
 }
 



From mlu at mail.berlios.de  Tue Sep 15 00:41:50 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Tue, 15 Sep 2009 00:41:50 +0200
Subject: [Openocd-svn] r2709 - trunk/src/target
Message-ID: <200909142241.n8EMfod9000408@sheep.berlios.de>

Author: mlu
Date: 2009-09-15 00:41:47 +0200 (Tue, 15 Sep 2009)
New Revision: 2709

Modified:
   trunk/src/target/cortex_a8.c
Log:
Check return values to avoid infinite wait in loop on error.

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-14 22:36:27 UTC (rev 2708)
+++ trunk/src/target/cortex_a8.c	2009-09-14 22:41:47 UTC (rev 2709)
@@ -153,7 +153,7 @@
 int cortex_a8_exec_opcode(target_t *target, uint32_t opcode)
 {
 	uint32_t dscr;
-	int retvalue;
+	int retval;
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	armv7a_common_t *armv7a = armv4_5->arch_info;
@@ -162,8 +162,10 @@
 	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
 	do
 	{
-		retvalue = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_read_atomic_u32(swjdp,
 				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0); /* Wait for InstrCompl bit to be set */
 
@@ -171,12 +173,14 @@
 
 	do
 	{
-		retvalue = mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_read_atomic_u32(swjdp,
 				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0); /* Wait for InstrCompl bit to be set */
 
-	return retvalue;
+	return retval;
 }
 
 /**************************************************************************



From oharboe at mail.berlios.de  Tue Sep 15 11:41:38 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 15 Sep 2009 11:41:38 +0200
Subject: [Openocd-svn] r2710 - trunk
Message-ID: <200909150941.n8F9fcRf018869@sheep.berlios.de>

Author: oharboe
Date: 2009-09-15 11:41:09 +0200 (Tue, 15 Sep 2009)
New Revision: 2710

Modified:
   trunk/TODO
Log:
added embedded ice programming while srst is asserted todo item

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2009-09-14 22:41:47 UTC (rev 2709)
+++ trunk/TODO	2009-09-15 09:41:09 UTC (rev 2710)
@@ -114,6 +114,10 @@
   https://lists.berlios.de/pipermail/openocd-development/2009-July/009426.html
 - regression: "reset halt" between 729(works) and 788(fails): @par
 https://lists.berlios.de/pipermail/openocd-development/2009-July/009206.html
+- ARM7/9:
+  - add reset option to allow programming embedded ice while srst is asserted.
+  Some CPUs will gate the JTAG clock when srst is asserted and in this case,
+  it is necessary to program embedded ice and then assert srst afterwards.
 - ARM923EJS:
   - reset run/halt/step is not robust; needs testing to map out problems.
 - ARM11 improvements (MB?)



From oharboe at mail.berlios.de  Tue Sep 15 16:20:38 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 15 Sep 2009 16:20:38 +0200
Subject: [Openocd-svn] r2711 - trunk/src/server
Message-ID: <200909151420.n8FEKcmq027740@sheep.berlios.de>

Author: oharboe
Date: 2009-09-15 16:20:37 +0200 (Tue, 15 Sep 2009)
New Revision: 2711

Modified:
   trunk/src/server/httpd.c
Log:
fix bug when using 32 instead of 64 bit value in callback, caught by -Wall

Modified: trunk/src/server/httpd.c
===================================================================
--- trunk/src/server/httpd.c	2009-09-15 09:41:09 UTC (rev 2710)
+++ trunk/src/server/httpd.c	2009-09-15 14:20:37 UTC (rev 2711)
@@ -223,7 +223,7 @@
 /* append data to each key */
 static int iterate_post(void *con_cls, enum MHD_ValueKind kind,
 		const char *key, const char *filename, const char *content_type,
-		const char *transfer_encoding, const char *data, size_t off,
+		const char *transfer_encoding, const char *data, uint64_t off,
 		size_t size)
 {
 	struct httpd_request *r = (struct httpd_request*) con_cls;



From mlu at mail.berlios.de  Tue Sep 15 17:41:16 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Tue, 15 Sep 2009 17:41:16 +0200
Subject: [Openocd-svn] r2712 - trunk/src/target
Message-ID: <200909151541.n8FFfGIt004633@sheep.berlios.de>

Author: mlu
Date: 2009-09-15 17:41:14 +0200 (Tue, 15 Sep 2009)
New Revision: 2712

Modified:
   trunk/src/target/armv7a.h
Log:
Definy symbolic values for VA to PA address translation operations

Modified: trunk/src/target/armv7a.h
===================================================================
--- trunk/src/target/armv7a.h	2009-09-15 14:20:37 UTC (rev 2711)
+++ trunk/src/target/armv7a.h	2009-09-15 15:41:14 UTC (rev 2712)
@@ -79,6 +79,16 @@
 #define ARMV4_5_COMMON_MAGIC 0x0A450A45
 #define ARMV7_COMMON_MAGIC 0x0A450999
 
+/* VA to PA translation operations opc2 values*/
+#define V2PCWPR  0
+#define V2PCWPW  1
+#define V2PCWUR  2
+#define V2PCWUW  3
+#define V2POWPR  4
+#define V2POWPW  5
+#define V2POWUR  6
+#define V2POWUW  7
+
 typedef struct armv7a_common_s
 {
 	int common_magic;



From mlu at mail.berlios.de  Tue Sep 15 17:50:12 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Tue, 15 Sep 2009 17:50:12 +0200
Subject: [Openocd-svn] r2713 - trunk/src/target
Message-ID: <200909151550.n8FFoCRB005590@sheep.berlios.de>

Author: mlu
Date: 2009-09-15 17:50:09 +0200 (Tue, 15 Sep 2009)
New Revision: 2713

Modified:
   trunk/src/target/armv7a.c
Log:
Updated mode string list.

Modified: trunk/src/target/armv7a.c
===================================================================
--- trunk/src/target/armv7a.c	2009-09-15 15:41:14 UTC (rev 2712)
+++ trunk/src/target/armv7a.c	2009-09-15 15:50:09 UTC (rev 2713)
@@ -70,8 +70,8 @@
 
 char * armv7a_mode_strings_list[] =
 {
-	"Illegal mode value", "System and User", "FIQ", "IRQ",
-	"Supervisor", "Abort", "Undefined", "Monitor"
+	"Illegal mode value", "User", "FIQ", "IRQ",
+	"Supervisor", "Abort", "Undefined", "System", "Monitor"
 };
 
 /* Hack! Yuk! allow -1 index, which simplifies codepaths elsewhere in the code */



From mlu at mail.berlios.de  Tue Sep 15 18:20:41 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Tue, 15 Sep 2009 18:20:41 +0200
Subject: [Openocd-svn] r2714 - trunk/src/target
Message-ID: <200909151620.n8FGKf7a009075@sheep.berlios.de>

Author: mlu
Date: 2009-09-15 18:20:39 +0200 (Tue, 15 Sep 2009)
New Revision: 2714

Modified:
   trunk/src/target/armv7a.h
Log:
Define debug_base, debug_ap, memory_ap in armv7a_common_t

Modified: trunk/src/target/armv7a.h
===================================================================
--- trunk/src/target/armv7a.h	2009-09-15 15:50:09 UTC (rev 2713)
+++ trunk/src/target/armv7a.h	2009-09-15 16:20:39 UTC (rev 2714)
@@ -98,6 +98,13 @@
 
 	/* arm adp debug port */
 	swjdp_common_t swjdp_info;
+
+	/* Core Debug Unit */
+	uint32_t debug_base;
+	uint8_t debug_ap;
+	uint8_t memory_ap;
+
+	/* Cache and Memory Management Unit */
 	armv4_5_mmu_common_t armv4_5_mmu;
 	armv4_5_common_t armv4_5_common;
 	void *arch_info;



From oharboe at mail.berlios.de  Wed Sep 16 14:38:34 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 16 Sep 2009 14:38:34 +0200
Subject: [Openocd-svn] r2715 - in trunk: doc src/flash tcl/board tcl/target
Message-ID: <200909161238.n8GCcYfp011051@sheep.berlios.de>

Author: oharboe
Date: 2009-09-16 14:38:26 +0200 (Wed, 16 Sep 2009)
New Revision: 2715

Added:
   trunk/src/flash/lpc2900.c
   trunk/src/flash/lpc2900.h
   trunk/tcl/board/hitex_lpc2929.cfg
   trunk/tcl/target/lpc2900.cfg
Modified:
   trunk/doc/openocd.texi
   trunk/src/flash/Makefile.am
   trunk/src/flash/flash.c
Log:
Rolf Meeser <rolfm_9dq at yahoo.de> adds flash support for NXP's LPC2900 family (ARM968E).

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-15 16:20:39 UTC (rev 2714)
+++ trunk/doc/openocd.texi	2009-09-16 12:38:26 UTC (rev 2715)
@@ -3309,7 +3309,15 @@
 
 @deffn {Flash Driver} lpc2000
 Most members of the LPC1700 and LPC2000 microcontroller families from NXP
-include internal flash and use Cortex-M3 (LPC1700) or ARM7TDMI (LPC2000)  cores.
+include internal flash and use Cortex-M3 (LPC1700) or ARM7TDMI (LPC2000) cores.
+
+ at quotation Note
+There are LPC2000 devices which are not supported by the @var{lpc2000}
+driver:
+The LPC2888 is supported by the @var{lpc288x} driver.
+The LPC29xx family is supported by the @var{lpc2900} driver.
+ at end quotation
+
 The @var{lpc2000} driver defines two mandatory and one optional parameters,
 which must appear in the following order:
 
@@ -3349,6 +3357,129 @@
 @end example
 @end deffn
 
+ at deffn {Flash Driver} lpc2900
+This driver supports the LPC29xx ARM968E based microcontroller family
+from NXP.
+
+The predefined parameters @var{base}, @var{size}, @var{chip_width} and
+ at var{bus_width} of the @code{flash bank} command are ignored. Flash size and
+sector layout are auto-configured by the driver.
+The driver has one additional mandatory parameter: The CPU clock rate
+(in kHz) at the time the flash operations will take place. Most of the time this
+will not be the crystal frequency, but a higher PLL frequency. The
+ at code{reset-init} event handler in the board script is usually the place where
+you start the PLL.
+
+The driver rejects flashless devices (currently the LPC2930).
+
+The EEPROM in LPC2900 devices is not mapped directly into the address space.
+It must be handled much more like NAND flash memory, and will therefore be
+handled by a separate @code{lpc2900_eeprom} driver (not yet available).
+
+Sector protection in terms of the LPC2900 is handled transparently. Every time a
+sector needs to be erased or programmed, it is automatically unprotected.
+What is shown as protection status in the @code{flash info} command, is
+actually the LPC2900 @emph{sector security}. This is a mechanism to prevent a
+sector from ever being erased or programmed again. As this is an irreversible
+mechanism, it is handled by a special command (@code{lpc2900 secure_sector}),
+and not by the standard @code{flash protect} command.
+
+Example for a 125 MHz clock frequency:
+ at example
+flash bank lpc2900 0 0 0 0 $_TARGETNAME 125000
+ at end example
+
+Some @code{lpc2900}-specific commands are defined. In the following command list,
+the @var{bank} parameter is the bank number as obtained by the
+ at code{flash banks} command.
+
+ at deffn Command {lpc2900 signature} bank
+Calculates a 128-bit hash value, the @emph{signature}, from the whole flash
+content. This is a hardware feature of the flash block, hence the calculation is
+very fast. You may use this to verify the content of a programmed device against
+a known signature.
+Example:
+ at example
+lpc2900 signature 0
+  signature: 0x5f40cdc8:0xc64e592e:0x10490f89:0x32a0f317
+ at end example
+ at end deffn
+
+ at deffn Command {lpc2900 read_custom} bank filename
+Reads the 912 bytes of customer information from the flash index sector, and
+saves it to a file in binary format.
+Example:
+ at example
+lpc2900 read_custom 0 /path_to/customer_info.bin
+ at end example
+ at end deffn
+
+The index sector of the flash is a @emph{write-only} sector. It cannot be
+erased! In order to guard against unintentional write access, all following
+commands need to be preceeded by a successful call to the @code{password}
+command:
+
+ at deffn Command {lpc2900 password} bank password
+You need to use this command right before each of the following commands:
+ at code{lpc2900 write_custom}, @code{lpc2900 secure_sector},
+ at code{lpc2900 secure_jtag}.
+
+The password string is fixed to "I_know_what_I_am_doing".
+Example:
+ at example
+lpc2900 password 0 I_know_what_I_am_doing
+  Potentially dangerous operation allowed in next command!
+ at end example
+ at end deffn
+
+ at deffn Command {lpc2900 write_custom} bank filename type
+Writes the content of the file into the customer info space of the flash index
+sector. The filetype can be specified with the @var{type} field. Possible values
+for @var{type} are: @var{bin} (binary), @var{ihex} (Intel hex format),
+ at var{elf} (ELF binary) or @var{s19} (Motorola S-records). The file must
+contain a single section, and the contained data length must be exactly
+912 bytes.
+ at quotation Attention
+This cannot be reverted! Be careful!
+ at end quotation
+Example:
+ at example
+lpc2900 write_custom 0 /path_to/customer_info.bin bin
+ at end example
+ at end deffn
+
+ at deffn Command {lpc2900 secure_sector} bank first last
+Secures the sector range from @var{first} to @var{last} (including) against
+further program and erase operations. The sector security will be effective
+after the next power cycle.
+ at quotation Attention
+This cannot be reverted! Be careful!
+ at end quotation
+Secured sectors appear as @emph{protected} in the @code{flash info} command.
+Example:
+ at example
+lpc2900 secure_sector 0 1 1
+flash info 0
+  #0 : lpc2900 at 0x20000000, size 0x000c0000, (...)
+          #  0: 0x00000000 (0x2000 8kB) not protected
+          #  1: 0x00002000 (0x2000 8kB) protected
+          #  2: 0x00004000 (0x2000 8kB) not protected
+ at end example
+ at end deffn
+
+ at deffn Command {lpc2900 secure_jtag} bank
+Irreversibly disable the JTAG port. The new JTAG security setting will be
+effective after the next power cycle.
+ at quotation Attention
+This cannot be reverted! Be careful!
+ at end quotation
+Examples:
+ at example
+lpc2900 secure_jtag 0
+ at end example
+ at end deffn
+ at end deffn
+
 @deffn {Flash Driver} ocl
 @emph{No idea what this is, other than using some arm7/arm9 core.}
 

Modified: trunk/src/flash/Makefile.am
===================================================================
--- trunk/src/flash/Makefile.am	2009-09-15 16:20:39 UTC (rev 2714)
+++ trunk/src/flash/Makefile.am	2009-09-16 12:38:26 UTC (rev 2715)
@@ -9,6 +9,8 @@
 	arm_nandio.c \
 	flash.c \
 	lpc2000.c \
+	lpc288x.c \
+	lpc2900.c \
 	cfi.c \
 	non_cfi.c \
 	at91sam7.c \
@@ -32,7 +34,6 @@
 	s3c2412_nand.c \
 	s3c2440_nand.c \
 	s3c2443_nand.c \
-	lpc288x.c \
 	ocl.c \
 	mflash.c \
 	pic32mx.c \
@@ -43,6 +44,8 @@
 	arm_nandio.h \
 	flash.h \
 	lpc2000.h \
+	lpc288x.h \
+	lpc2900.h \
 	cfi.h \
 	non_cfi.h \
 	at91sam7.h \
@@ -57,7 +60,6 @@
 	tms470.h \
 	s3c24xx_nand.h \
 	s3c24xx_regs_nand.h \
-	lpc288x.h \
 	mflash.h \
 	ocl.h \
 	pic32mx.h \

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-09-15 16:20:39 UTC (rev 2714)
+++ trunk/src/flash/flash.c	2009-09-16 12:38:26 UTC (rev 2715)
@@ -47,6 +47,8 @@
 /* flash drivers
  */
 extern flash_driver_t lpc2000_flash;
+extern flash_driver_t lpc288x_flash;
+extern flash_driver_t lpc2900_flash;
 extern flash_driver_t cfi_flash;
 extern flash_driver_t at91sam3_flash;
 extern flash_driver_t at91sam7_flash;
@@ -58,13 +60,14 @@
 extern flash_driver_t stm32x_flash;
 extern flash_driver_t tms470_flash;
 extern flash_driver_t ecosflash_flash;
-extern flash_driver_t lpc288x_flash;
 extern flash_driver_t ocl_flash;
 extern flash_driver_t pic32mx_flash;
 extern flash_driver_t avr_flash;
 
 flash_driver_t *flash_drivers[] = {
 	&lpc2000_flash,
+	&lpc288x_flash,
+	&lpc2900_flash,
 	&cfi_flash,
 	&at91sam7_flash,
 	&at91sam3_flash,
@@ -76,7 +79,6 @@
 	&stm32x_flash,
 	&tms470_flash,
 	&ecosflash_flash,
-	&lpc288x_flash,
 	&ocl_flash,
 	&pic32mx_flash,
 	&avr_flash,

Added: trunk/src/flash/lpc2900.c
===================================================================
--- trunk/src/flash/lpc2900.c	2009-09-15 16:20:39 UTC (rev 2714)
+++ trunk/src/flash/lpc2900.c	2009-09-16 12:38:26 UTC (rev 2715)
@@ -0,0 +1,1926 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by                                                 *
+ *   Rolf Meeser <rolfm_9dq at yahoo.de>                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+
+#include "image.h"
+
+#include "lpc2900.h"
+#include "binarybuffer.h"
+#include "armv4_5.h"
+
+
+/* 1024 bytes */
+#define KiB                 1024
+
+/* Some flash constants */
+#define FLASH_PAGE_SIZE     512     /* bytes */
+#define FLASH_ERASE_TIME    100000  /* microseconds */
+#define FLASH_PROGRAM_TIME  1000    /* microseconds */
+
+/* Chip ID / Feature Registers */
+#define CHIPID          0xE0000000  /* Chip ID */
+#define FEAT0           0xE0000100  /* Chip feature 0 */
+#define FEAT1           0xE0000104  /* Chip feature 1 */
+#define FEAT2           0xE0000108  /* Chip feature 2 (contains flash size indicator) */
+#define FEAT3           0xE000010C  /* Chip feature 3 */
+
+#define EXPECTED_CHIPID 0x209CE02B  /* Chip ID of all LPC2900 devices */
+
+/* Flash/EEPROM Control Registers */
+#define FCTR            0x20200000  /* Flash control */
+#define FPTR            0x20200008  /* Flash program-time */
+#define FTCTR           0x2020000C  /* Flash test control */
+#define FBWST           0x20200010  /* Flash bridge wait-state */
+#define FCRA            0x2020001C  /* Flash clock divider */
+#define FMSSTART        0x20200020  /* Flash Built-In Selft Test start address */
+#define FMSSTOP         0x20200024  /* Flash Built-In Selft Test stop address */
+#define FMS16           0x20200028  /* Flash 16-bit signature */
+#define FMSW0           0x2020002C  /* Flash 128-bit signature Word 0 */
+#define FMSW1           0x20200030  /* Flash 128-bit signature Word 1 */
+#define FMSW2           0x20200034  /* Flash 128-bit signature Word 2 */
+#define FMSW3           0x20200038  /* Flash 128-bit signature Word 3 */
+
+#define EECMD           0x20200080  /* EEPROM command */
+#define EEADDR          0x20200084  /* EEPROM address */
+#define EEWDATA         0x20200088  /* EEPROM write data */
+#define EERDATA         0x2020008C  /* EEPROM read data */
+#define EEWSTATE        0x20200090  /* EEPROM wait state */
+#define EECLKDIV        0x20200094  /* EEPROM clock divider */
+#define EEPWRDWN        0x20200098  /* EEPROM power-down/start */
+#define EEMSSTART       0x2020009C  /* EEPROM BIST start address */
+#define EEMSSTOP        0x202000A0  /* EEPROM BIST stop address */
+#define EEMSSIG         0x202000A4  /* EEPROM 24-bit BIST signature */
+
+#define INT_CLR_ENABLE  0x20200FD8  /* Flash/EEPROM interrupt clear enable */
+#define INT_SET_ENABLE  0x20200FDC  /* Flash/EEPROM interrupt set enable */
+#define INT_STATUS      0x20200FE0  /* Flash/EEPROM interrupt status */
+#define INT_ENABLE      0x20200FE4  /* Flash/EEPROM interrupt enable */
+#define INT_CLR_STATUS  0x20200FE8  /* Flash/EEPROM interrupt clear status */
+#define INT_SET_STATUS  0x20200FEC  /* Flash/EEPROM interrupt set status */
+
+/* Interrupt sources */
+#define INTSRC_END_OF_PROG    (1 << 28)
+#define INTSRC_END_OF_BIST    (1 << 27)
+#define INTSRC_END_OF_RDWR    (1 << 26)
+#define INTSRC_END_OF_MISR    (1 << 2)
+#define INTSRC_END_OF_BURN    (1 << 1)
+#define INTSRC_END_OF_ERASE   (1 << 0)
+
+
+/* FCTR bits */
+#define FCTR_FS_LOADREQ       (1 << 15)
+#define FCTR_FS_CACHECLR      (1 << 14)
+#define FCTR_FS_CACHEBYP      (1 << 13)
+#define FCTR_FS_PROGREQ       (1 << 12)
+#define FCTR_FS_RLS           (1 << 11)
+#define FCTR_FS_PDL           (1 << 10)
+#define FCTR_FS_PD            (1 << 9)
+#define FCTR_FS_WPB           (1 << 7)
+#define FCTR_FS_ISS           (1 << 6)
+#define FCTR_FS_RLD           (1 << 5)
+#define FCTR_FS_DCR           (1 << 4)
+#define FCTR_FS_WEB           (1 << 2)
+#define FCTR_FS_WRE           (1 << 1)
+#define FCTR_FS_CS            (1 << 0)
+/* FPTR bits */
+#define FPTR_EN_T             (1 << 15)
+/* FTCTR bits */
+#define FTCTR_FS_BYPASS_R     (1 << 29)
+#define FTCTR_FS_BYPASS_W     (1 << 28)
+/* FMSSTOP bits */
+#define FMSSTOP_MISR_START    (1 << 17)
+/* EEMSSTOP bits */
+#define EEMSSTOP_STRTBIST     (1 << 31)
+
+/* Index sector */
+#define ISS_CUSTOMER_START1   (0x830)
+#define ISS_CUSTOMER_END1     (0xA00)
+#define ISS_CUSTOMER_SIZE1    (ISS_CUSTOMER_END1 - ISS_CUSTOMER_START1)
+#define ISS_CUSTOMER_NWORDS1  (ISS_CUSTOMER_SIZE1 / 4)
+#define ISS_CUSTOMER_START2   (0xA40)
+#define ISS_CUSTOMER_END2     (0xC00)
+#define ISS_CUSTOMER_SIZE2    (ISS_CUSTOMER_END2 - ISS_CUSTOMER_START2)
+#define ISS_CUSTOMER_NWORDS2  (ISS_CUSTOMER_SIZE2 / 4)
+#define ISS_CUSTOMER_SIZE     (ISS_CUSTOMER_SIZE1 + ISS_CUSTOMER_SIZE2)
+
+
+
+/**
+ * Private data for \c lpc2900 flash driver.
+ */
+typedef struct lpc2900_flash_bank_s
+{
+	/**
+	 * Holds the value read from CHIPID register.
+	 * The driver will not load if the chipid doesn't match the expected
+	 * value of 0x209CE02B of the LPC2900 family. A probe will only be done
+	 * if the chipid does not yet contain the expected value.
+	 */
+	uint32_t chipid;
+
+	/**
+	 * String holding device name.
+	 * This string is set by the probe function to the type number of the
+	 * device. It takes the form "LPC29xx".
+	 */
+	char * target_name;
+
+	/**
+	 * System clock frequency.
+	 * Holds the clock frequency in Hz, as passed by the configuration file
+	 * to the <tt>flash bank</tt> command.
+	 */
+	uint32_t clk_sys_fmc;
+
+	/**
+	 * Flag to indicate that dangerous operations are possible.
+	 * This flag can be set by passing the correct password to the
+	 * <tt>lpc2900 password</tt> command. If set, other dangerous commands,
+	 * which operate on the index sector, can be executed.
+	 */
+	uint32_t risky;
+
+	/**
+	 * Maximum contiguous block of internal SRAM (bytes).
+	 * Autodetected by the driver. Not the total amount of SRAM, only the
+	 * the largest \em contiguous block!
+	 */
+	uint32_t max_ram_block;
+
+} lpc2900_flash_bank_t;
+
+
+
+
+static int lpc2900_register_commands(struct command_context_s *cmd_ctx);
+static int lpc2900_flash_bank_command(struct command_context_s *cmd_ctx,
+                                      char *cmd, char **args, int argc,
+                                      struct flash_bank_s *bank);
+static int lpc2900_erase(struct flash_bank_s *bank, int first, int last);
+static int lpc2900_protect(struct flash_bank_s *bank, int set, int first, int last);
+static int lpc2900_write(struct flash_bank_s *bank,
+                         uint8_t *buffer, uint32_t offset, uint32_t count);
+static int lpc2900_probe(struct flash_bank_s *bank);
+static int lpc2900_erase_check(struct flash_bank_s *bank);
+static int lpc2900_protect_check(struct flash_bank_s *bank);
+static int lpc2900_info(struct flash_bank_s *bank, char *buf, int buf_size);
+
+static uint32_t lpc2900_wait_status(flash_bank_t *bank, uint32_t mask, int timeout);
+static void lpc2900_setup(struct flash_bank_s *bank);
+static uint32_t lpc2900_is_ready(struct flash_bank_s *bank);
+static uint32_t lpc2900_read_security_status(struct flash_bank_s *bank);
+static uint32_t lpc2900_run_bist128(struct flash_bank_s *bank,
+                                    uint32_t addr_from, uint32_t addr_to,
+                                    uint32_t (*signature)[4] );
+static uint32_t lpc2900_address2sector(struct flash_bank_s *bank, uint32_t offset);
+static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time );
+
+
+/***********************  Helper functions  **************************/
+
+
+/**
+ * Wait for an event in mask to occur in INT_STATUS.
+ *
+ * Return when an event occurs, or after a timeout.
+ *
+ * @param[in] bank Pointer to the flash bank descriptor
+ * @param[in] mask Mask to be used for INT_STATUS
+ * @param[in] timeout Timeout in ms
+ */
+static uint32_t lpc2900_wait_status( flash_bank_t *bank,
+                                     uint32_t mask,
+                                     int timeout )
+{
+	uint32_t int_status;
+	target_t *target = bank->target;
+
+
+	do
+	{
+		alive_sleep(1);
+		timeout--;
+		target_read_u32(target, INT_STATUS, &int_status);
+	}
+	while( ((int_status & mask) == 0) && (timeout != 0) );
+
+	if (timeout == 0)
+	{
+		LOG_DEBUG("Timeout!");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Set up the flash for erase/program operations.
+ *
+ * Enable the flash, and set the correct CRA clock of 66 kHz.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static void lpc2900_setup( struct flash_bank_s *bank )
+{
+	uint32_t fcra;
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+
+	/* Power up the flash block */
+	target_write_u32( bank->target, FCTR, FCTR_FS_WEB | FCTR_FS_CS );
+
+
+	fcra = (lpc2900_info->clk_sys_fmc / (3 * 66000)) - 1;
+	target_write_u32( bank->target, FCRA, fcra );
+}
+
+
+
+/**
+ * Check if device is ready.
+ *
+ * Check if device is ready for flash operation:
+ * Must have been successfully probed.
+ * Must be halted.
+ */
+static uint32_t lpc2900_is_ready( struct flash_bank_s *bank )
+{
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	if( lpc2900_info->chipid != EXPECTED_CHIPID )
+	{
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	if( bank->target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Read the status of sector security from the index sector.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static uint32_t lpc2900_read_security_status( struct flash_bank_s *bank )
+{
+	uint32_t status;
+	if( (status = lpc2900_is_ready( bank )) != ERROR_OK )
+	{
+		return status;
+	}
+
+	target_t *target = bank->target;
+
+	/* Enable ISS access */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB | FCTR_FS_ISS);
+
+	/* Read the relevant block of memory from the ISS sector */
+	uint32_t iss_secured_field[ 0x230/16 ][ 4 ];
+	target_read_memory(target, bank->base + 0xC00, 4, 0x230/4,
+	                           (uint8_t *)iss_secured_field);
+
+	/* Disable ISS access */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+	/* Check status of each sector. Note that the sector numbering in the LPC2900
+	 * is different from the logical sector numbers used in OpenOCD!
+	 * Refer to the user manual for details.
+	 *
+	 * All zeros (16x 0x00) are treated as a secured sector (is_protected = 1)
+	 * All ones (16x 0xFF) are treated as a non-secured sector (is_protected = 0)
+	 * Anything else is undefined (is_protected = -1). This is treated as
+	 * a protected sector!
+	 */
+	int sector;
+	int index;
+	for( sector = 0; sector < bank->num_sectors; sector++ )
+	{
+		/* Convert logical sector number to physical sector number */
+		if( sector <= 4 )
+		{
+			index = sector + 11;
+		}
+		else if( sector <= 7 )
+		{
+			index = sector + 27;
+		}
+		else
+		{
+			index = sector - 8;
+		}
+
+		bank->sectors[sector].is_protected = -1;
+
+		if (
+		    (iss_secured_field[index][0] == 0x00000000) &&
+		    (iss_secured_field[index][1] == 0x00000000) &&
+		    (iss_secured_field[index][2] == 0x00000000) &&
+		    (iss_secured_field[index][3] == 0x00000000) )
+		{
+			bank->sectors[sector].is_protected = 1;
+		}
+
+		if (
+		    (iss_secured_field[index][0] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index][1] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index][2] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index][3] == 0xFFFFFFFF) )
+		{
+			bank->sectors[sector].is_protected = 0;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Use BIST to calculate a 128-bit hash value over a range of flash.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param addr_from
+ * @param addr_to
+ * @param signature
+ */
+static uint32_t lpc2900_run_bist128(struct flash_bank_s *bank,
+                                    uint32_t addr_from,
+                                    uint32_t addr_to,
+                                    uint32_t (*signature)[4] )
+{
+	target_t *target = bank->target;
+
+	/* Clear END_OF_MISR interrupt status */
+	target_write_u32( target, INT_CLR_STATUS, INTSRC_END_OF_MISR );
+
+	/* Start address */
+	target_write_u32( target, FMSSTART, addr_from >> 4);
+	/* End address, and issue start command */
+	target_write_u32( target, FMSSTOP, (addr_to >> 4) | FMSSTOP_MISR_START );
+
+	/* Poll for end of operation. Calculate a reasonable timeout. */
+	if( lpc2900_wait_status( bank, INTSRC_END_OF_MISR, 1000 ) != ERROR_OK )
+	{
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Return the signature */
+	target_read_memory( target, FMSW0, 4, 4, (uint8_t *)signature );
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Return sector number for given address.
+ *
+ * Return the (logical) sector number for a given relative address.
+ * No sanity check is done. It assumed that the address is valid.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param offset Offset address relative to bank start
+ */
+static uint32_t lpc2900_address2sector( struct flash_bank_s *bank,
+                                        uint32_t offset )
+{
+	uint32_t address = bank->base + offset;
+
+
+	/* Run through all sectors of this bank */
+	int sector;
+	for( sector = 0; sector < bank->num_sectors; sector++ )
+	{
+		/* Return immediately if address is within the current sector */
+		if( address < (bank->sectors[sector].offset + bank->sectors[sector].size) )
+		{
+			return sector;
+		}
+	}
+
+	/* We should never come here. If we do, return an arbitrary sector number. */
+	return 0;
+}
+
+
+
+
+/**
+ * Write one page to the index sector.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param pagenum Page number (0...7)
+ * @param page Page array (FLASH_PAGE_SIZE bytes)
+ */
+static int lpc2900_write_index_page( struct flash_bank_s *bank,
+                                     int pagenum,
+                                     uint8_t (*page)[FLASH_PAGE_SIZE] )
+{
+	/* Only pages 4...7 are user writable */
+	if( (pagenum < 4) || (pagenum > 7) )
+	{
+		LOG_ERROR( "Refuse to burn index sector page %" PRIu32, pagenum );
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	/* Get target, and check if it's halted */
+	target_t *target = bank->target;
+	if( target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Private info */
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Enable flash block and set the correct CRA clock of 66 kHz */
+	lpc2900_setup( bank );
+
+	/* Un-protect the index sector */
+	target_write_u32( target, bank->base, 0 );
+	target_write_u32( target, FCTR,
+	                  FCTR_FS_LOADREQ | FCTR_FS_WPB | FCTR_FS_ISS |
+	                  FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS );
+
+	/* Set latch load mode */
+	target_write_u32( target, FCTR,
+	                  FCTR_FS_ISS | FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS );
+
+	/* Write whole page to flash data latches */
+	if( target_write_memory( target,
+	                         bank->base + pagenum * FLASH_PAGE_SIZE,
+	                         4, FLASH_PAGE_SIZE / 4, (uint8_t *)page) != ERROR_OK )
+	{
+		LOG_ERROR( "Index sector write failed @ page %" PRIu32, pagenum );
+		target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Clear END_OF_BURN interrupt status */
+	target_write_u32( target, INT_CLR_STATUS, INTSRC_END_OF_BURN );
+
+	/* Set the program/erase time to FLASH_PROGRAM_TIME */
+	target_write_u32(target, FPTR,
+	                 FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
+	                                              FLASH_PROGRAM_TIME ));
+
+	/* Trigger flash write */
+	target_write_u32( target, FCTR,
+	                  FCTR_FS_PROGREQ | FCTR_FS_ISS |
+	                  FCTR_FS_WPB | FCTR_FS_WRE | FCTR_FS_CS );
+
+	/* Wait for the end of the write operation. If it's not over after one
+	 * second, something went dreadfully wrong... :-(
+	 */
+	if( lpc2900_wait_status( bank, INTSRC_END_OF_BURN, 1000 ) != ERROR_OK )
+	{
+		LOG_ERROR( "Index sector write failed @ page %" PRIu32, pagenum );
+		target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Calculate FPTR.TR register value for desired program/erase time.
+ *
+ * @param clock System clock in Hz
+ * @param time Program/erase time in ?s
+ */
+static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time )
+{
+	/*           ((time[?s]/1e6) * f[Hz]) + 511
+	 * FPTR.TR = -------------------------------
+	 *                         512
+	 *
+	 * The result is the 
+	 */
+
+	uint32_t tr_val = (uint32_t)((((time / 1e6) * clock) + 511.0) / 512.0);
+
+	return tr_val;
+}
+
+
+/***********************  Private flash commands  **************************/
+
+
+/**
+ * Command to determine the signature of the whole flash.
+ *
+ * Uses the Built-In-Self-Test (BIST) to generate a 128-bit hash value
+ * of the flash content.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_signature_command( struct command_context_s *cmd_ctx,
+                                             char *cmd, char **args, int argc )
+{
+	flash_bank_t *bank;
+	uint32_t status;
+	uint32_t signature[4];
+
+
+	if( argc < 1 )
+	{
+		LOG_WARNING( "Too few arguments. Call: lpc2900 signature <bank#>" );
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	/* Get the bank descriptor */
+	bank = get_flash_bank_by_num( strtoul(args[0], NULL, 0) );
+	if( !bank )
+	{
+		command_print( cmd_ctx, "flash bank '#%s' is out of bounds", args[0] );
+		return ERROR_OK;
+	}
+
+	if( bank->target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Run BIST over whole flash range */
+	if( (status = lpc2900_run_bist128( bank,
+	                                   bank->base,
+	                                   bank->base + (bank->size - 1),
+	                                   &signature)
+	                                 ) != ERROR_OK )
+	{
+		return status;
+	}
+
+	command_print( cmd_ctx, "signature: 0x%8.8" PRIx32
+	                                  ":0x%8.8" PRIx32
+	                                  ":0x%8.8" PRIx32
+	                                  ":0x%8.8" PRIx32,
+	              signature[3], signature[2], signature[1], signature[0] );
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Store customer info in file.
+ *
+ * Read customer info from index sector, and store that block of data into
+ * a disk file. The format is binary.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_read_custom_command( struct command_context_s *cmd_ctx,
+                                               char *cmd, char **args, int argc )
+{
+	flash_bank_t *bank;
+
+
+	if( argc < 2 )
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	bank = get_flash_bank_by_num( strtoul(args[0], NULL, 0) );
+	if( !bank )
+	{
+		command_print( cmd_ctx, "flash bank '#%s' is out of bounds", args[0] );
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+	lpc2900_info->risky = 0;
+
+	/* Get target, and check if it's halted */
+	target_t *target = bank->target;
+	if( target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Storage for customer info. Read in two parts */
+	uint32_t customer[ ISS_CUSTOMER_NWORDS1 + ISS_CUSTOMER_NWORDS2 ];
+
+	/* Enable access to index sector */
+	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB | FCTR_FS_ISS );
+
+	/* Read two parts */
+	target_read_memory( target, bank->base+ISS_CUSTOMER_START1, 4,
+	                            ISS_CUSTOMER_NWORDS1,
+	                            (uint8_t *)&customer[0] );
+	target_read_memory( target, bank->base+ISS_CUSTOMER_START2, 4,
+	                            ISS_CUSTOMER_NWORDS2,
+	                            (uint8_t *)&customer[ISS_CUSTOMER_NWORDS1] );
+
+	/* Deactivate access to index sector */
+	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+	/* Try and open the file */
+	fileio_t fileio;
+	char *filename = args[1];
+	int ret = fileio_open( &fileio, filename, FILEIO_WRITE, FILEIO_BINARY );
+	if( ret != ERROR_OK )
+	{
+		LOG_WARNING( "Could not open file %s", filename );
+		return ret;
+	}
+
+	uint32_t nwritten;
+	ret = fileio_write( &fileio, sizeof(customer),
+                        (const uint8_t *)customer, &nwritten );
+	if( ret != ERROR_OK )
+	{
+		LOG_ERROR( "Write operation to file %s failed", filename );
+		fileio_close( &fileio );
+		return ret;
+	}
+
+	fileio_close( &fileio );
+
+	return ERROR_OK;
+}
+
+
+
+
+/**
+ * Enter password to enable potentially dangerous options.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_password_command(struct command_context_s *cmd_ctx,
+                                           char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+
+
+	if (argc < 2)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+#define ISS_PASSWORD "I_know_what_I_am_doing"
+
+	lpc2900_info->risky = !strcmp( args[1], ISS_PASSWORD );
+
+	if( !lpc2900_info->risky )
+	{
+		command_print(cmd_ctx, "Wrong password (use '%s')", ISS_PASSWORD);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	command_print(cmd_ctx,
+                  "Potentially dangerous operation allowed in next command!");
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Write customer info from file to the index sector.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_write_custom_command( struct command_context_s *cmd_ctx,
+                                                char *cmd, char **args, int argc )
+{
+	if (argc < 2)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Check if command execution is allowed. */
+	if( !lpc2900_info->risky )
+	{
+		command_print( cmd_ctx, "Command execution not allowed!" );
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	lpc2900_info->risky = 0;
+
+	/* Get target, and check if it's halted */
+	target_t *target = bank->target;
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* The image will always start at offset 0 */
+	image_t image;
+	image.base_address_set = 1;
+	image.base_address = 0;
+	image.start_address_set = 0;
+
+	char *filename = args[1];
+	char *type = (argc >= 3) ? args[2] : NULL;
+	int retval = image_open(&image, filename, type);
+	if (retval != ERROR_OK)
+	{
+		return retval;
+	}
+
+	/* Do a sanity check: The image must be exactly the size of the customer
+	   programmable area. Any other size is rejected. */
+	if( image.num_sections != 1 )
+	{
+		LOG_ERROR("Only one section allowed in image file.");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	if( (image.sections[0].base_address != 0) ||
+        (image.sections[0].size != ISS_CUSTOMER_SIZE) )
+	{
+		LOG_ERROR("Incorrect image file size. Expected %" PRIu32 ", got %" PRIu32,
+                   ISS_CUSTOMER_SIZE, image.sections[0].size);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Well boys, I reckon this is it... */
+
+	/* Customer info is split into two blocks in pages 4 and 5. */
+	uint8_t page[FLASH_PAGE_SIZE];
+
+	/* Page 4 */
+	uint32_t offset = ISS_CUSTOMER_START1 % FLASH_PAGE_SIZE;
+	memset( page, 0xff, FLASH_PAGE_SIZE );
+	uint32_t size_read;
+	retval = image_read_section( &image, 0, 0,
+	                             ISS_CUSTOMER_SIZE1, &page[offset], &size_read);
+	if( retval != ERROR_OK )
+	{
+		LOG_ERROR("couldn't read from file '%s'", filename);
+		image_close(&image);
+		return retval;
+	}
+	if( (retval = lpc2900_write_index_page( bank, 4, &page )) != ERROR_OK )
+	{
+		image_close(&image);
+		return retval;
+	}
+
+	/* Page 5 */
+	offset = ISS_CUSTOMER_START2 % FLASH_PAGE_SIZE;
+	memset( page, 0xff, FLASH_PAGE_SIZE );
+	retval = image_read_section( &image, 0, ISS_CUSTOMER_SIZE1,
+	                             ISS_CUSTOMER_SIZE2, &page[offset], &size_read);
+	if( retval != ERROR_OK )
+	{
+		LOG_ERROR("couldn't read from file '%s'", filename);
+		image_close(&image);
+		return retval;
+	}
+	if( (retval = lpc2900_write_index_page( bank, 5, &page )) != ERROR_OK )
+	{
+		image_close(&image);
+		return retval;
+	}
+
+	image_close(&image);
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Activate 'sector security' for a range of sectors.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_secure_sector_command(struct command_context_s *cmd_ctx,
+                                                char *cmd, char **args, int argc)
+{
+	if (argc < 3)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Check if command execution is allowed. */
+	if( !lpc2900_info->risky )
+	{
+		command_print( cmd_ctx, "Command execution not allowed! "
+		"(use 'password' command first)");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	lpc2900_info->risky = 0;
+
+	/* Read sector range, and do a sanity check. */
+	int first = strtoul(args[1], NULL, 0);
+	int last = strtoul(args[2], NULL, 0);
+	if( (first >= bank->num_sectors) ||
+	    (last >= bank->num_sectors) ||
+	    (first > last) )
+	{
+		command_print( cmd_ctx, "Illegal sector range" );
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	uint8_t page[FLASH_PAGE_SIZE];
+	int sector;
+	int retval;
+
+	/* Sectors in page 6 */
+	if( (first <= 4) || (last >= 8) )
+	{
+		memset( &page, 0xff, FLASH_PAGE_SIZE );
+		for( sector = first; sector <= last; sector++ )
+		{
+			if( sector <= 4 )
+			{
+				memset( &page[0xB0 + 16*sector], 0, 16 );
+			}
+			else if( sector >= 8 )
+			{
+				memset( &page[0x00 + 16*(sector - 8)], 0, 16 );
+			}
+		}
+
+		if( (retval = lpc2900_write_index_page( bank, 6, &page )) != ERROR_OK )
+		{
+			LOG_ERROR("failed to update index sector page 6");
+			return retval;
+		}
+	}
+
+	/* Sectors in page 7 */
+	if( (first <= 7) && (last >= 5) )
+	{
+		memset( &page, 0xff, FLASH_PAGE_SIZE );
+		for( sector = first; sector <= last; sector++ )
+		{
+			if( (sector >= 5) && (sector <= 7) )
+			{
+				memset( &page[0x00 + 16*(sector - 5)], 0, 16 );
+			}
+		}
+
+		if( (retval = lpc2900_write_index_page( bank, 7, &page )) != ERROR_OK )
+		{
+			LOG_ERROR("failed to update index sector page 7");
+			return retval;
+		}
+	}
+
+	command_print( cmd_ctx,
+	        "Sectors security will become effective after next power cycle");
+
+	/* Update the sector security status */
+	if ( lpc2900_read_security_status(bank) != ERROR_OK )
+	{
+		LOG_ERROR( "Cannot determine sector security status" );
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Activate JTAG protection.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_secure_jtag_command(struct command_context_s *cmd_ctx,
+                                              char *cmd, char **args, int argc)
+{
+	if (argc < 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Check if command execution is allowed. */
+	if( !lpc2900_info->risky )
+	{
+		command_print( cmd_ctx, "Command execution not allowed! "
+		                        "(use 'password' command first)");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	lpc2900_info->risky = 0;
+
+	/* Prepare page */
+	uint8_t page[FLASH_PAGE_SIZE];
+	memset( &page, 0xff, FLASH_PAGE_SIZE );
+
+
+	/* Insert "soft" protection word */
+	page[0x30 + 15] = 0x7F;
+	page[0x30 + 11] = 0x7F;
+	page[0x30 +  7] = 0x7F;
+	page[0x30 +  3] = 0x7F;
+
+	/* Write to page 5 */
+	int retval;
+	if( (retval = lpc2900_write_index_page( bank, 5, &page ))
+			!= ERROR_OK )
+	{
+		LOG_ERROR("failed to update index sector page 5");
+		return retval;
+	}
+
+	LOG_INFO("JTAG security set. Good bye!");
+
+	return ERROR_OK;
+}
+
+
+
+/***********************  Flash interface functions  **************************/
+
+
+/**
+ * Register private command handlers.
+ *
+ * @param cmd_ctx
+ */
+static int lpc2900_register_commands(struct command_context_s *cmd_ctx)
+{
+	command_t *lpc2900_cmd = register_command(cmd_ctx, NULL, "lpc2900",
+	                                          NULL, COMMAND_ANY, NULL);
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "signature",
+	    lpc2900_handle_signature_command,
+	    COMMAND_EXEC,
+	    "<bank> | "
+            "print device signature of flash bank");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "read_custom",
+	    lpc2900_handle_read_custom_command,
+	    COMMAND_EXEC,
+	    "<bank> <filename> | "
+            "read customer information from index sector to file");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "password",
+	    lpc2900_handle_password_command,
+	    COMMAND_EXEC,
+	    "<bank> <password> | "
+            "enter password to enable 'dangerous' options");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "write_custom",
+	    lpc2900_handle_write_custom_command,
+	    COMMAND_EXEC,
+	    "<bank> <filename> [<type>] | "
+            "write customer info from file to index sector");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "secure_sector",
+	    lpc2900_handle_secure_sector_command,
+	    COMMAND_EXEC,
+	    "<bank> <first> <last> | "
+            "activate sector security for a range of sectors");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "secure_jtag",
+	    lpc2900_handle_secure_jtag_command,
+	    COMMAND_EXEC,
+	    "<bank> <level> | "
+            "activate JTAG security");
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Evaluate flash bank command.
+ *
+ * Syntax: flash bank lpc2900 0 0 0 0 target# system_base_clock
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_flash_bank_command(struct command_context_s *cmd_ctx,
+                                      char *cmd, char **args, int argc,
+                                      struct flash_bank_s *bank)
+{
+	lpc2900_flash_bank_t *lpc2900_info;
+
+	if (argc < 6)
+	{
+		LOG_WARNING("incomplete flash_bank LPC2900 configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	lpc2900_info = malloc(sizeof(lpc2900_flash_bank_t));
+	bank->driver_priv = lpc2900_info;
+
+	/* Get flash clock.
+	 * Reject it if we can't meet the requirements for program time
+	 * (if clock too slow), or for erase time (clock too fast).
+	 */
+	lpc2900_info->clk_sys_fmc = strtoul(args[6], NULL, 0) * 1000;
+
+	uint32_t clock_limit;
+	/* Check program time limit */
+	clock_limit = 512000000l / FLASH_PROGRAM_TIME;
+	if (lpc2900_info->clk_sys_fmc < clock_limit)
+	{
+		LOG_WARNING("flash clock must be at least %" PRIu32 " kHz",
+                    (clock_limit / 1000));
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	/* Check erase time limit */
+	clock_limit = (uint32_t)((32767.0 * 512.0 * 1e6) / FLASH_ERASE_TIME);
+	if (lpc2900_info->clk_sys_fmc > clock_limit)
+	{
+		LOG_WARNING("flash clock must be a maximum of %" PRIu32" kHz",
+                    (clock_limit / 1000));
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	/* Chip ID will be obtained by probing the device later */
+	lpc2900_info->chipid = 0;
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Erase sector(s).
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param first First sector to be erased
+ * @param last Last sector (including) to be erased
+ */
+static int lpc2900_erase(struct flash_bank_s *bank, int first, int last)
+{
+	uint32_t status;
+	int sector;
+	int last_unsecured_sector;
+	target_t *target = bank->target;
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+
+	status = lpc2900_is_ready(bank);
+	if (status != ERROR_OK)
+	{
+		return status;
+	}
+
+	/* Sanity check on sector range */
+	if ((first < 0) || (last < first) || (last >= bank->num_sectors))
+	{
+		LOG_INFO("Bad sector range");
+		return ERROR_FLASH_SECTOR_INVALID;
+	}
+
+	/* Update the info about secured sectors */
+	lpc2900_read_security_status( bank );
+
+	/* The selected sector range might include secured sectors. An attempt
+	 * to erase such a sector will cause the erase to fail also for unsecured
+	 * sectors. It is necessary to determine the last unsecured sector now,
+	 * because we have to treat the last relevant sector in the list in
+	 * a special way.
+	 */
+	last_unsecured_sector = -1;
+	for (sector = first; sector <= last; sector++)
+	{
+		if ( !bank->sectors[sector].is_protected )
+		{
+			last_unsecured_sector = sector;
+		}
+	}
+
+	/* Exit now, in case of the rare constellation where all sectors in range
+	 * are secured. This is regarded a success, since erasing/programming of
+	 * secured sectors shall be handled transparently.
+	 */
+	if ( last_unsecured_sector == -1 )
+	{
+		return ERROR_OK;
+	}
+
+	/* Enable flash block and set the correct CRA clock of 66 kHz */
+	lpc2900_setup(bank);
+
+	/* Clear END_OF_ERASE interrupt status */
+	target_write_u32(target, INT_CLR_STATUS, INTSRC_END_OF_ERASE);
+
+	/* Set the program/erase timer to FLASH_ERASE_TIME */
+	target_write_u32(target, FPTR,
+	                 FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
+	                                              FLASH_ERASE_TIME ));
+
+	/* Sectors are marked for erasure, then erased all together */
+	for (sector = first; sector <= last_unsecured_sector; sector++)
+	{
+		/* Only mark sectors that aren't secured. Any attempt to erase a group
+		 * of sectors will fail if any single one of them is secured!
+		 */
+		if ( !bank->sectors[sector].is_protected )
+		{
+			/* Unprotect the sector */
+			target_write_u32(target, bank->sectors[sector].offset, 0);
+			target_write_u32(target, FCTR,
+			                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
+			                 FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS);
+
+			/* Mark the sector for erasure. The last sector in the list
+			   triggers the erasure. */
+			target_write_u32(target, bank->sectors[sector].offset, 0);
+			if ( sector == last_unsecured_sector )
+			{
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_PROGREQ | FCTR_FS_WPB | FCTR_FS_CS);
+			}
+			else
+			{
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
+				                 FCTR_FS_WEB | FCTR_FS_CS);
+			}
+		}
+	}
+
+	/* Wait for the end of the erase operation. If it's not over after two seconds,
+	 * something went dreadfully wrong... :-(
+	 */
+	if( lpc2900_wait_status(bank, INTSRC_END_OF_ERASE, 2000) != ERROR_OK )
+	{
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Normal flash operating mode */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+	return ERROR_OK;
+}
+
+
+
+static int lpc2900_protect(struct flash_bank_s *bank, int set, int first, int last)
+{
+	/* This command is not supported.
+     * "Protection" in LPC2900 terms is handled transparently. Sectors will
+     * automatically be unprotected as needed.
+     * Instead we use the concept of sector security. A secured sector is shown
+     * as "protected" in OpenOCD. Sector security is a permanent feature, and
+     * cannot be disabled once activated.
+     */
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Write data to flash.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param buffer Buffer with data
+ * @param offset Start address (relative to bank start)
+ * @param count Number of bytes to be programmed
+ */
+static int lpc2900_write(struct flash_bank_s *bank, uint8_t *buffer,
+                         uint32_t offset, uint32_t count)
+{
+	uint8_t page[FLASH_PAGE_SIZE];
+	uint32_t status;
+	uint32_t num_bytes;
+	target_t *target = bank->target;
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+	int sector;
+	int retval;
+
+	static const uint32_t write_target_code[] = {
+		/* Set auto latch mode: FCTR=CS|WRE|WEB */
+		0xe3a0a007,   /* loop       mov r10, #0x007 */
+		0xe583a000,   /*            str r10,[r3,#0] */
+
+		/* Load complete page into latches */
+		0xe3a06020,   /*            mov r6,#(512/16) */
+		0xe8b00f00,   /* next       ldmia r0!,{r8-r11} */
+		0xe8a10f00,   /*            stmia r1!,{r8-r11} */
+		0xe2566001,   /*            subs r6,#1 */
+		0x1afffffb,   /*            bne next */
+
+		/* Clear END_OF_BURN interrupt status */
+		0xe3a0a002,   /*            mov r10,#(1 << 1) */
+		0xe583afe8,   /*            str r10,[r3,#0xfe8] */
+
+		/* Set the erase time to FLASH_PROGRAM_TIME */
+		0xe5834008,   /*            str r4,[r3,#8] */
+
+		/* Trigger flash write
+			FCTR = CS | WRE | WPB | PROGREQ */
+		0xe3a0a083,   /*            mov r10,#0x83 */
+		0xe38aaa01,   /*            orr r10,#0x1000 */
+		0xe583a000,   /*            str r10,[r3,#0] */
+
+		/* Wait for end of burn */
+		0xe593afe0,   /* wait       ldr r10,[r3,#0xfe0] */
+		0xe21aa002,   /*            ands r10,#(1 << 1) */
+		0x0afffffc,   /*            beq wait */
+
+		/* End? */
+		0xe2522001,   /*            subs r2,#1 */
+		0x1affffed,   /*            bne loop */
+
+		0xeafffffe    /* done       b done */
+	};
+
+
+	status = lpc2900_is_ready(bank);
+	if (status != ERROR_OK)
+	{
+		return status;
+	}
+
+	/* Enable flash block and set the correct CRA clock of 66 kHz */
+	lpc2900_setup(bank);
+
+	/* Update the info about secured sectors */
+	lpc2900_read_security_status( bank );
+
+	/* Unprotect all involved sectors */
+	for (sector = 0; sector < bank->num_sectors; sector++)
+	{
+		/* Start address in or before this sector? */
+		/* End address in or behind this sector? */
+		if ( ((bank->base + offset) <
+		          (bank->sectors[sector].offset + bank->sectors[sector].size)) &&
+		     ((bank->base + (offset + count - 1)) >= bank->sectors[sector].offset) )
+		{
+			/* This sector is involved and needs to be unprotected.
+				* Don't do it for secured sectors.
+				*/
+			if ( !bank->sectors[sector].is_protected )
+			{
+				target_write_u32(target, bank->sectors[sector].offset, 0);
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
+				                 FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS);
+			}
+		}
+	}
+
+	/* Set the program/erase time to FLASH_PROGRAM_TIME */
+	uint32_t prog_time = FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
+	                                                  FLASH_PROGRAM_TIME );
+
+	/* If there is a working area of reasonable size, use it to program via
+	   a target algorithm. If not, fall back to host programming. */
+
+	/* We need some room for target code. */
+	uint32_t target_code_size = sizeof(write_target_code);
+
+	/* Try working area allocation. Start with a large buffer, and try with
+	   reduced size if that fails. */
+	working_area_t *warea;
+	uint32_t buffer_size = lpc2900_info->max_ram_block - 1 * KiB;
+	while( (retval = target_alloc_working_area(target,
+	                                           buffer_size + target_code_size,
+	                                           &warea)) != ERROR_OK )
+	{
+		/* Try a smaller buffer now, and stop if it's too small. */
+		buffer_size -= 1 * KiB;
+		if (buffer_size < 2 * KiB)
+		{
+			LOG_INFO( "no (large enough) working area"
+			          ", falling back to host mode" );
+			warea = NULL;
+			break;
+		}
+	};
+
+	if( warea )
+	{
+		reg_param_t reg_params[5];
+		armv4_5_algorithm_t armv4_5_info;
+
+		/* We can use target mode. Download the algorithm. */
+		retval = target_write_buffer( target,
+		                              (warea->address)+buffer_size,
+		                              target_code_size,
+		                              (uint8_t *)write_target_code);
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("Unable to write block write code to target");
+			target_free_all_working_areas(target);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+		init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);
+		init_reg_param(&reg_params[4], "r4", 32, PARAM_OUT);
+
+		/* Write to flash in large blocks */
+		while ( count != 0 )
+		{
+			uint32_t this_npages;
+			uint8_t *this_buffer;
+			int start_sector = lpc2900_address2sector( bank, offset );
+
+			/* First page / last page / rest */
+			if( offset % FLASH_PAGE_SIZE )
+			{
+				/* Block doesn't start on page boundary.
+				   Burn first partial page separately. */
+				memset( &page, 0xff, sizeof(page) );
+				memcpy( &page[offset % FLASH_PAGE_SIZE],
+				        buffer,
+				        FLASH_PAGE_SIZE - (offset % FLASH_PAGE_SIZE) );
+				this_npages = 1;
+				this_buffer = &page[0];
+				count = count + (offset % FLASH_PAGE_SIZE);
+				offset = offset - (offset % FLASH_PAGE_SIZE);
+			}
+			else if( count < FLASH_PAGE_SIZE )
+			{
+				/* Download last incomplete page separately. */
+				memset( &page, 0xff, sizeof(page) );
+				memcpy( &page, buffer, count );
+				this_npages = 1;
+				this_buffer = &page[0];
+				count = FLASH_PAGE_SIZE;
+			}
+			else
+			{
+				/* Download as many full pages as possible */
+				this_npages = (count < buffer_size) ?
+				               count / FLASH_PAGE_SIZE :
+				               buffer_size / FLASH_PAGE_SIZE;
+				this_buffer = buffer;
+
+				/* Make sure we stop at the next secured sector */
+				int sector = start_sector + 1;
+				while( sector < bank->num_sectors )
+				{
+					/* Secured? */
+					if( bank->sectors[sector].is_protected )
+					{
+						/* Is that next sector within the current block? */
+						if( (bank->sectors[sector].offset - bank->base) <
+							(offset + (this_npages * FLASH_PAGE_SIZE)) )
+						{
+							/* Yes! Split the block */
+							this_npages =
+							  (bank->sectors[sector].offset - bank->base - offset)
+							      / FLASH_PAGE_SIZE;
+							break;
+						}
+					}
+
+					sector++;
+				}
+			}
+
+			/* Skip the current sector if it is secured */
+			if( bank->sectors[start_sector].is_protected )
+			{
+				LOG_DEBUG( "Skip secured sector %" PRIu32, start_sector );
+
+				/* Stop if this is the last sector */
+				if( start_sector == bank->num_sectors - 1 )
+				{
+					break;
+				}
+
+				/* Skip */
+				uint32_t nskip = bank->sectors[start_sector].size -
+				                 (offset % bank->sectors[start_sector].size);
+				offset += nskip;
+				buffer += nskip;
+				count = (count >= nskip) ? (count - nskip) : 0;
+				continue;
+			}
+
+			/* Execute buffer download */
+			if ((retval = target_write_buffer(target,
+			                                  warea->address,
+			                                  this_npages * FLASH_PAGE_SIZE,
+			                                  this_buffer)) != ERROR_OK)
+			{
+				LOG_ERROR("Unable to write data to target");
+				target_free_all_working_areas(target);
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+
+			/* Prepare registers */
+			buf_set_u32(reg_params[0].value, 0, 32, warea->address);
+			buf_set_u32(reg_params[1].value, 0, 32, offset);
+			buf_set_u32(reg_params[2].value, 0, 32, this_npages);
+			buf_set_u32(reg_params[3].value, 0, 32, FCTR);
+			buf_set_u32(reg_params[4].value, 0, 32, FPTR_EN_T | prog_time);
+
+			/* Execute algorithm, assume breakpoint for last instruction */
+			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+			armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+
+			retval = target_run_algorithm(target, 0, NULL, 5, reg_params,
+				(warea->address) + buffer_size,
+				(warea->address) + buffer_size + target_code_size - 4,
+				10000, /* 10s should be enough for max. 16 KiB of data */
+				&armv4_5_info);
+
+			if (retval != ERROR_OK)
+			{
+				LOG_ERROR("Execution of flash algorithm failed.");
+				target_free_all_working_areas(target);
+				retval = ERROR_FLASH_OPERATION_FAILED;
+				break;
+			}
+
+			count -= this_npages * FLASH_PAGE_SIZE;
+			buffer += this_npages * FLASH_PAGE_SIZE;
+			offset += this_npages * FLASH_PAGE_SIZE;
+		}
+
+		/* Free all resources */
+		destroy_reg_param(&reg_params[0]);
+		destroy_reg_param(&reg_params[1]);
+		destroy_reg_param(&reg_params[2]);
+		destroy_reg_param(&reg_params[3]);
+		destroy_reg_param(&reg_params[4]);
+		target_free_all_working_areas(target);
+	}
+	else
+	{
+		/* Write to flash memory page-wise */
+		while ( count != 0 )
+		{
+			/* How many bytes do we copy this time? */
+			num_bytes = (count >= FLASH_PAGE_SIZE) ?
+			            FLASH_PAGE_SIZE - (offset % FLASH_PAGE_SIZE) :
+			            count;
+
+			/* Don't do anything with it if the page is in a secured sector. */
+			if ( !bank->sectors[lpc2900_address2sector(bank, offset)].is_protected )
+			{
+				/* Set latch load mode */
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_CS | FCTR_FS_WRE | FCTR_FS_WEB);
+
+				/* Always clear the buffer (a little overhead, but who cares) */
+				memset(page, 0xFF, FLASH_PAGE_SIZE);
+
+				/* Copy them to the buffer */
+				memcpy( &page[offset % FLASH_PAGE_SIZE],
+				        &buffer[offset % FLASH_PAGE_SIZE],
+				        num_bytes );
+
+				/* Write whole page to flash data latches */
+				if (target_write_memory(
+				                 target,
+				                 bank->base + (offset - (offset % FLASH_PAGE_SIZE)),
+				                 4, FLASH_PAGE_SIZE / 4, page) != ERROR_OK)
+				{
+					LOG_ERROR("Write failed @ 0x%8.8" PRIx32, offset);
+					target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+					return ERROR_FLASH_OPERATION_FAILED;
+				}
+
+				/* Clear END_OF_BURN interrupt status */
+				target_write_u32(target, INT_CLR_STATUS, INTSRC_END_OF_BURN);
+
+				/* Set the programming time */
+				target_write_u32(target, FPTR, FPTR_EN_T | prog_time);
+
+				/* Trigger flash write */
+				target_write_u32(target, FCTR,
+				    FCTR_FS_CS | FCTR_FS_WRE | FCTR_FS_WPB | FCTR_FS_PROGREQ);
+
+				/* Wait for the end of the write operation. If it's not over
+				 * after one second, something went dreadfully wrong... :-(
+				 */
+				if (lpc2900_wait_status(bank, INTSRC_END_OF_BURN, 1000) != ERROR_OK)
+				{
+					LOG_ERROR("Write failed @ 0x%8.8" PRIx32, offset);
+					target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+					return ERROR_FLASH_OPERATION_FAILED;
+				}
+			}
+
+			/* Update pointers and counters */
+			offset += num_bytes;
+			buffer += num_bytes;
+			count -= num_bytes;
+		}
+
+		retval = ERROR_OK;
+	}
+
+	/* Normal flash operating mode */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+	return retval;
+}
+
+
+/**
+ * Try and identify the device.
+ *
+ * Determine type number and its memory layout.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_probe(struct flash_bank_s *bank)
+{
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+	target_t *target = bank->target;
+	int i = 0;
+	uint32_t offset;
+
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* We want to do this only once. Check if we already have a valid CHIPID,
+	 * because then we will have already successfully probed the device.
+	 */
+	if (lpc2900_info->chipid == EXPECTED_CHIPID)
+	{
+		return ERROR_OK;
+	}
+
+	/* Probing starts with reading the CHIPID register. We will continue only
+	 * if this identifies as an LPC2900 device.
+	 */
+	target_read_u32(target, CHIPID, &lpc2900_info->chipid);
+
+	if (lpc2900_info->chipid != EXPECTED_CHIPID)
+	{
+		LOG_WARNING("Device is not an LPC29xx");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* It's an LPC29xx device. Now read the feature register FEAT0...FEAT3. */
+	uint32_t feat0, feat1, feat2, feat3;
+	target_read_u32(target, FEAT0, &feat0);
+	target_read_u32(target, FEAT1, &feat1);
+	target_read_u32(target, FEAT2, &feat2);
+	target_read_u32(target, FEAT3, &feat3);
+
+	/* Base address */
+	bank->base = 0x20000000;
+
+	/* Determine flash layout from FEAT2 register */
+	uint32_t num_64k_sectors = (feat2 >> 16) & 0xFF;
+	uint32_t num_8k_sectors = (feat2 >> 0) & 0xFF;
+	bank->num_sectors = num_64k_sectors + num_8k_sectors;
+	bank->size = KiB * (64 * num_64k_sectors + 8 * num_8k_sectors);
+
+	/* Determine maximum contiguous RAM block */
+	lpc2900_info->max_ram_block = 16 * KiB;
+	if( (feat1 & 0x30) == 0x30 )
+	{
+		lpc2900_info->max_ram_block = 32 * KiB;
+		if( (feat1 & 0x0C) == 0x0C )
+		{
+			lpc2900_info->max_ram_block = 48 * KiB;
+		}
+	}
+
+	/* Determine package code and ITCM size */
+	uint32_t package_code = feat0 & 0x0F;
+	uint32_t itcm_code = (feat1 >> 16) & 0x1F;
+
+	/* Determine the exact type number. */
+	uint32_t found = 1;
+	if ( (package_code == 4) && (itcm_code == 5) )
+	{
+		/* Old LPC2917 or LPC2919 (non-/01 devices) */
+		lpc2900_info->target_name = (bank->size == 768*KiB) ? "LPC2919" : "LPC2917";
+	}
+	else
+	{
+		if ( package_code == 2 )
+		{
+			/* 100-pin package */
+			if ( bank->size == 128*KiB )
+			{
+				lpc2900_info->target_name = "LPC2921";
+			}
+			else if ( bank->size == 256*KiB )
+			{
+				lpc2900_info->target_name = "LPC2923";
+			}
+			else if ( bank->size == 512*KiB )
+			{
+				lpc2900_info->target_name = "LPC2925";
+			}
+			else
+			{
+				found = 0;
+			}
+		}
+		else if ( package_code == 4 )
+		{
+			/* 144-pin package */
+			if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFCF0) )
+			{
+				lpc2900_info->target_name = "LPC2917/01";
+			}
+			else if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFFF1) )
+			{
+				lpc2900_info->target_name = "LPC2927";
+			}
+			else if ( (bank->size == 768*KiB) && (feat3 == 0xFFFFFCF8) )
+			{
+				lpc2900_info->target_name = "LPC2919/01";
+			}
+			else if ( (bank->size == 768*KiB) && (feat3 == 0xFFFFFFF9) )
+			{
+				lpc2900_info->target_name = "LPC2929";
+			}
+			else
+			{
+				found = 0;
+			}
+		}
+		else if ( package_code == 5 )
+		{
+			/* 208-pin package */
+			lpc2900_info->target_name = (bank->size == 0) ? "LPC2930" : "LPC2939";
+		}
+		else
+		{
+			found = 0;
+		}
+	}
+
+	if ( !found )
+	{
+		LOG_WARNING("Unknown LPC29xx derivative");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Show detected device */
+	LOG_INFO("Flash bank %" PRIu32
+	         ": Device %s, %" PRIu32
+	         " KiB in %" PRIu32 " sectors",
+	         bank->bank_number,
+	         lpc2900_info->target_name, bank->size / KiB,
+	         bank->num_sectors);
+
+	/* Flashless devices cannot be handled */
+	if ( bank->num_sectors == 0 )
+	{
+		LOG_WARNING("Flashless device cannot be handled");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Sector layout.
+	 * These are logical sector numbers. When doing real flash operations,
+	 * the logical flash number are translated into the physical flash numbers
+	 * of the device.
+	 */
+	bank->sectors = malloc(sizeof(flash_sector_t) * bank->num_sectors);
+
+	offset = 0;
+	for (i = 0; i < bank->num_sectors; i++)
+	{
+		bank->sectors[i].offset = offset;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = -1;
+
+		if ( i <= 7 )
+		{
+			bank->sectors[i].size = 8 * KiB;
+		}
+		else if ( i <= 18 )
+		{
+			bank->sectors[i].size = 64 * KiB;
+		}
+		else
+		{
+			/* We shouldn't come here. But there might be a new part out there
+			 * that has more than 19 sectors. Politely ask for a fix then.
+			 */
+			bank->sectors[i].size = 0;
+			LOG_ERROR("Never heard about sector %" PRIu32 " (FIXME please)", i);
+		}
+
+		offset += bank->sectors[i].size;
+	}
+
+	/* Read sector security status */
+	if ( lpc2900_read_security_status(bank) != ERROR_OK )
+	{
+		LOG_ERROR("Cannot determine sector security status");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Run a blank check for each sector.
+ *
+ * For speed reasons, the device isn't read word by word.
+ * A hash value is calculated by the hardware ("BIST") for each sector.
+ * This value is then compared against the known hash of an empty sector.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_erase_check(struct flash_bank_s *bank)
+{
+	uint32_t status = lpc2900_is_ready(bank);
+	if (status != ERROR_OK)
+	{
+		LOG_INFO("Processor not halted/not probed");
+		return status;
+	}
+
+	/* Use the BIST (Built-In Selft Test) to generate a signature of each flash
+	 * sector. Compare against the expected signature of an empty sector.
+	 */
+	int sector;
+	for ( sector = 0; sector < bank->num_sectors; sector++ )
+	{
+		uint32_t signature[4];
+		if ( (status = lpc2900_run_bist128( bank,
+		                                    bank->sectors[sector].offset,
+		                                    bank->sectors[sector].offset +
+		                                       (bank->sectors[sector].size - 1),
+		                                    &signature)) != ERROR_OK )
+		{
+			return status;
+		}
+
+		/* The expected signatures for an empty sector are different
+		 * for 8 KiB and 64 KiB sectors.
+		 */
+		if ( bank->sectors[sector].size == 8*KiB )
+		{
+			bank->sectors[sector].is_erased =
+			    (signature[3] == 0x01ABAAAA) &&
+			    (signature[2] == 0xAAAAAAAA) &&
+			    (signature[1] == 0xAAAAAAAA) &&
+			    (signature[0] == 0xAAA00AAA);
+		}
+		if ( bank->sectors[sector].size == 64*KiB )
+		{
+			bank->sectors[sector].is_erased =
+			    (signature[3] == 0x11801222) &&
+			    (signature[2] == 0xB88844FF) &&
+			    (signature[1] == 0x11A22008) &&
+			    (signature[0] == 0x2B1BFE44);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Get protection (sector security) status.
+ *
+ * Determine the status of "sector security" for each sector.
+ * A secured sector is one that can never be erased/programmed again.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_protect_check(struct flash_bank_s *bank)
+{
+	return lpc2900_read_security_status(bank);
+}
+
+
+/**
+ * Print info about the driver (not the device).
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param buf Buffer to take the string
+ * @param buf_size Maximum number of characters that the buffer can take
+ */
+static int lpc2900_info(struct flash_bank_s *bank, char *buf, int buf_size)
+{
+	snprintf(buf, buf_size, "lpc2900 flash driver");
+
+	return ERROR_OK;
+}
+
+
+flash_driver_t lpc2900_flash =
+{
+	.name               = "lpc2900",
+	.register_commands  = lpc2900_register_commands,
+	.flash_bank_command = lpc2900_flash_bank_command,
+	.erase              = lpc2900_erase,
+	.protect            = lpc2900_protect,
+	.write              = lpc2900_write,
+	.probe              = lpc2900_probe,
+	.auto_probe         = lpc2900_probe,
+	.erase_check        = lpc2900_erase_check,
+	.protect_check      = lpc2900_protect_check,
+	.info               = lpc2900_info
+};

Added: trunk/src/flash/lpc2900.h
===================================================================
--- trunk/src/flash/lpc2900.h	2009-09-15 16:20:39 UTC (rev 2714)
+++ trunk/src/flash/lpc2900.h	2009-09-16 12:38:26 UTC (rev 2715)
@@ -0,0 +1,27 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by                                                 *
+ *   Rolf Meeser <rolfm_9dq at yahoo.de>                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef lpc2900_H
+#define lpc2900_H
+
+#include "flash.h"
+
+
+#endif /* lpc2900_H */

Added: trunk/tcl/board/hitex_lpc2929.cfg
===================================================================
--- trunk/tcl/board/hitex_lpc2929.cfg	2009-09-15 16:20:39 UTC (rev 2714)
+++ trunk/tcl/board/hitex_lpc2929.cfg	2009-09-16 12:38:26 UTC (rev 2715)
@@ -0,0 +1,105 @@
+# Hitex eval board for LPC2929/LPC2939
+# http://www.hitex.com/
+
+# Delays on reset lines
+jtag_nsrst_delay 50
+jtag_ntrst_delay 1
+
+# Maximum of 1/8 of clock frequency (XTAL = 16 MHz).
+# Adaptive clocking through RTCK is not supported.
+jtag_khz 2000
+
+# Target device: LPC29xx with ETB
+# The following variables are used by the LPC2900 script:
+#   HAS_ETB             Must be set to 1. The CPU on this board has ETB.
+#   FLASH_CLOCK         CPU frequency at the time of flash programming (in kHz)
+set HAS_ETB             1
+set FLASH_CLOCK         112000
+source [find target/lpc2900.cfg]
+
+# A working area will help speeding the flash programming
+#$_TARGETNAME configure -work-area-phys 0x80000000 -work-area-size 0x2000 -work-area-backup 0
+$_TARGETNAME configure -work-area-phys 0x58000000 -work-area-size 0x10000 -work-area-backup 0
+
+# Event handlers
+$_TARGETNAME configure -event reset-start {
+  # Back to the slow JTAG clock
+  jtag_khz 2000
+}
+
+# External 16-bit flash at chip select CS7 (SST39VF3201-70, 4 MiB)
+flash bank cfi 0x5C000000 0x400000 2 2 $_TARGETNAME jedec_probe
+
+
+$_TARGETNAME configure -event reset-init {
+  # Flash
+  mww 0x20200010 0x00000007     # FBWST: 7 wait states, not chached
+
+  # Use PLL
+  mww 0xFFFF8020 0x00000001     # XTAL_OSC_CONTROL: enable, 1-20 MHz
+  mww 0xFFFF8070 0x01000000     # SYS_CLK_CONF: Crystal
+  mww 0xFFFF8028 0x00000005     # PLL: (power down)
+  mww 0xFFFF8028 0x01060004     # PLL: M=7, 2P=2 (power up)
+                                # --> f=112 MHz, fcco=224 MHz
+  sleep 100
+  mww 0xFFFF8070 0x02000000     # SYS_CLK_CONF: PLL
+
+  # Increase JTAG speed
+  jtag_khz 6000
+
+  # Enable external memory bus (16-bit SRAM at CS6, 16-bit flash at CS7)
+  mww 0xE0001138 0x0000001F     # P1.14 = D0
+  mww 0xE000113C 0x0000001F     # P1.15 = D1
+  mww 0xE0001140 0x0000001F     # P1.16 = D2
+  mww 0xE0001144 0x0000001F     # P1.17 = D3
+  mww 0xE0001148 0x0000001F     # P1.18 = D4
+  mww 0xE000114C 0x0000001F     # P1.19 = D5
+  mww 0xE0001150 0x0000001F     # P1.20 = D6
+  mww 0xE0001154 0x0000001F     # P1.21 = D7
+  mww 0xE0001200 0x0000001F     # P2.0  = D8
+  mww 0xE0001204 0x0000001F     # P2.1  = D9
+  mww 0xE0001208 0x0000001F     # P2.2  = D10
+  mww 0xE000120C 0x0000001F     # P2.3  = D11
+  mww 0xE0001210 0x0000001F     # P2.4  = D12
+  mww 0xE0001214 0x0000001F     # P2.5  = D13
+  mww 0xE0001218 0x0000001F     # P2.6  = D14
+  mww 0xE000121C 0x0000001F     # P2.7  = D15
+  mww 0xE0001104 0x00000007     # P1.1  = A1
+  mww 0xE0001108 0x00000007     # P1.2  = A2
+  mww 0xE000110C 0x00000007     # P1.3  = A3
+  mww 0xE0001110 0x00000007     # P1.4  = A4
+  mww 0xE0001114 0x00000007     # P1.5  = A5
+  mww 0xE0001118 0x00000007     # P1.6  = A6
+  mww 0xE000111C 0x00000007     # P1.7  = A7
+  mww 0xE0001028 0x00000007     # P0.10 = A8
+  mww 0xE000102C 0x00000007     # P0.11 = A9
+  mww 0xE0001030 0x00000007     # P0.12 = A10
+  mww 0xE0001034 0x00000007     # P0.13 = A11
+  mww 0xE0001038 0x00000007     # P0.14 = A12
+  mww 0xE000103C 0x00000007     # P0.15 = A13
+  mww 0xE0001048 0x00000007     # P0.18 = A14
+  mww 0xE000104C 0x00000007     # P0.19 = A15
+  mww 0xE0001050 0x00000007     # P0.20 = A16
+  mww 0xE0001054 0x00000007     # P0.21 = A17
+  mww 0xE0001058 0x00000007     # P0.22 = A18
+  mww 0xE000105C 0x00000007     # P0.23 = A19
+  mww 0xE0001238 0x00000007     # P2.14 = BLS0
+  mww 0xE000123C 0x00000007     # P2.15 = BLS1
+  mww 0xE0001300 0x00000007     # P3.0  = CS6
+  mww 0xE0001304 0x00000007     # P3.1  = CS7
+  mww 0xE0001130 0x00000007     # P1.12 = OE_N
+  mww 0xE0001134 0x00000007     # P1.13 = WE_N
+  mww 0x600000BC 0x00000041     # Bank6 16-bit mode, RBLE=1
+  mww 0x600000B4 0x00000000     # Bank6 WSTOEN=0
+  mww 0x600000AC 0x00000005     # Bank6 WST1=5
+  mww 0x600000B8 0x00000001     # Bank6 WSTWEN=1
+  mww 0x600000B0 0x00000006     # Bank6 WST2=6
+  mww 0x600000A8 0x00000002     # Bank6 IDCY=2
+  mww 0x600000D8 0x00000041     # Bank7 16-bit mode, RBLE=1
+  mww 0x600000D0 0x00000000     # Bank7 WSTOEN=0
+  mww 0x600000C8 0x0000000A     # Bank7 WST1=10
+  mww 0x600000D4 0x00000001     # Bank7 WSTWEN=1
+  mww 0x600000CC 0x0000000C     # Bank7 WST2=8
+  mww 0x600000C4 0x00000002     # Bank7 IDCY=2
+}
+


Property changes on: trunk/tcl/board/hitex_lpc2929.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/lpc2900.cfg
===================================================================
--- trunk/tcl/target/lpc2900.cfg	2009-09-15 16:20:39 UTC (rev 2714)
+++ trunk/tcl/target/lpc2900.cfg	2009-09-16 12:38:26 UTC (rev 2715)
@@ -0,0 +1,65 @@
+
+if { [info exists CHIPNAME] } {
+    set  _CHIPNAME $CHIPNAME
+} else {
+    set  _CHIPNAME lpc2900
+}
+
+if { [info exists CPUTAPID ] } {
+    set _CPUTAPID $CPUTAPID
+} else {
+    set _CPUTAPID 0x0596802B
+}
+
+if { [info exists HAS_ETB ] } {
+} else {
+    # Set default (no ETB).
+    # Show a warning, because this should have been configured explicitely.
+    set HAS_ETB 0
+    # TODO   warning?
+}
+
+if { [info exists ETBTAPID ] } {
+    set _ETBTAPID $ETBTAPID
+} else {
+    set _ETBTAPID 0x1B900F0F
+}
+
+# TRST and SRST both exist, and can be controlled independently
+reset_config trst_and_srst separate
+
+# Define the _TARGETNAME
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+
+# Include the ETB tap controller if asked for.
+# Has to be done manually for newer devices (not an "old" LPC2917/2919).
+if { $HAS_ETB == 1 } {
+    # Clear the HAS_ETB flag. Must be set again for a new tap in the chain.
+    set HAS_ETB 0
+
+    # Add the ETB tap controller and the ARM9 core debug tap
+    jtag newtap $_CHIPNAME etb -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_ETBTAPID
+    jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+    # Create the ".cpu" target
+    target create $_TARGETNAME arm966e -endian little -chain-position $_TARGETNAME -variant arm966e
+
+    # Configure ETM and ETB
+    etm config $_TARGETNAME 8 normal full etb
+    etb config $_TARGETNAME $_CHIPNAME.etb
+
+} else {
+    # Add the ARM9 core debug tap
+    jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+    # Create the ".cpu" target
+    target create $_TARGETNAME arm966e -endian little -chain-position $_TARGETNAME -variant arm966e
+}
+
+arm7_9 dbgrq enable
+arm7_9 dcc_downloads enable
+
+# Flash bank configuration:
+# Flash:   flash bank lpc2900 0 0 0 0 <target#> <flash clock (CLK_SYS_FMC) in kHz>
+# Flash base address, total flash size, and number of sectors are all configured automatically.
+flash bank lpc2900         0 0 0 0 $_TARGETNAME $FLASH_CLOCK


Property changes on: trunk/tcl/target/lpc2900.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From mlu at mail.berlios.de  Wed Sep 16 20:17:29 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Wed, 16 Sep 2009 20:17:29 +0200
Subject: [Openocd-svn] r2716 - trunk/src/target
Message-ID: <200909161817.n8GIHT2c018735@sheep.berlios.de>

Author: mlu
Date: 2009-09-16 20:17:26 +0200 (Wed, 16 Sep 2009)
New Revision: 2716

Modified:
   trunk/src/target/cortex_a8.c
Log:
Use a variable armv7a->debug_base instead of hardedcoded  OMAP3530_DEBUG_BASE

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-16 12:38:26 UTC (rev 2715)
+++ trunk/src/target/cortex_a8.c	2009-09-16 18:17:26 UTC (rev 2716)
@@ -163,21 +163,21 @@
 	do
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
-				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
-	}
+		}
 	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0); /* Wait for InstrCompl bit to be set */
 
-	mem_ap_write_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_ITR, opcode);
+	mem_ap_write_u32(swjdp, armv7a->debug_base + CPUDBG_ITR, opcode);
 
 	do
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
-				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
-	}
+		}
 	while ((dscr & (1 << DSCR_INSTR_COMP)) == 0); /* Wait for InstrCompl bit to be set */
 
 	return retval;
@@ -221,7 +221,7 @@
 
 	/* Read DCCTX */
 	retval = mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
+			armv7a->debug_base + CPUDBG_DTRTX, value);
 
 	return retval;
 }
@@ -236,7 +236,7 @@
 	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
 	retval = mem_ap_write_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DTRRX, value);
+			armv7a->debug_base + CPUDBG_DTRRX, value);
 	/* Move DTRRX to r0 */
 	cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
 
@@ -291,12 +291,12 @@
 	do
 	{
 		retval = mem_ap_read_atomic_u32(swjdp,
-				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	}
 	while ((dscr & (1 << DSCR_DTR_TX_FULL)) == 0); /* Wait for DTRRXfull */
 
 	retval = mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DTRTX, value);
+			armv7a->debug_base + CPUDBG_DTRTX, value);
 
 	return retval;
 }
@@ -316,7 +316,7 @@
 
 	/* Write to DCCRX */
 	retval = mem_ap_write_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DTRRX, value);
+			armv7a->debug_base + CPUDBG_DTRRX, value);
 
 	if (Rd < 15)
 	{
@@ -359,7 +359,7 @@
 	uint8_t saved_apsel = dap_ap_get_select(swjdp);
 	dap_ap_select(swjdp, swjdp_debugap);
 	retval = mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 	{
 		dap_ap_select(swjdp, saved_apsel);
@@ -430,21 +430,21 @@
 	 * and then wait for the core to be halted.
 	 */
 	retval = mem_ap_write_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DRCR, 0x1);
+			armv7a->debug_base + CPUDBG_DRCR, 0x1);
 
 	/*
 	 * enter halting debug mode
 	 */
-	mem_ap_read_atomic_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+	mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	retval = mem_ap_write_atomic_u32(swjdp,
-		OMAP3530_DEBUG_BASE + CPUDBG_DSCR, dscr | (1 << DSCR_HALT_DBG_MODE));
+		armv7a->debug_base + CPUDBG_DSCR, dscr | (1 << DSCR_HALT_DBG_MODE));
 
 	if (retval != ERROR_OK)
 		goto out;
 
 	do {
 		mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	} while ((dscr & (1 << DSCR_CORE_HALTED)) == 0);
 
 	target->debug_reason = DBG_REASON_DBGRQ;
@@ -545,11 +545,11 @@
 
 #endif
 	/* Restart core and wait for it to be started */
-	mem_ap_write_atomic_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_DRCR, 0x2);
+	mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DRCR, 0x2);
 
 	do {
 		mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	} while ((dscr & (1 << DSCR_CORE_RESTARTED)) == 0);
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
@@ -596,10 +596,10 @@
 
 	/* Enable the ITR execution once we are in debug mode */
 	mem_ap_read_atomic_u32(swjdp,
-				OMAP3530_DEBUG_BASE + CPUDBG_DSCR, &dscr);
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	dscr |= (1 << DSCR_EXT_INT_EN);
 	retval = mem_ap_write_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DSCR, dscr);
+			armv7a->debug_base + CPUDBG_DSCR, dscr);
 
 	/* Examine debug reason */
 	switch ((cortex_a8->cpudbg_dscr >> 2)&0xF)
@@ -1029,10 +1029,10 @@
 		brp_list[brp_i].used = 1;
 		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
 		brp_list[brp_i].control = control;
-		target_write_u32(target, OMAP3530_DEBUG_BASE
+		target_write_u32(target, armv7a->debug_base
 				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].value);
-		target_write_u32(target, OMAP3530_DEBUG_BASE
+		target_write_u32(target, armv7a->debug_base
 				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
 		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
@@ -1095,10 +1095,10 @@
 		brp_list[brp_i].used = 0;
 		brp_list[brp_i].value = 0;
 		brp_list[brp_i].control = 0;
-		target_write_u32(target, OMAP3530_DEBUG_BASE
+		target_write_u32(target, armv7a->debug_base
 				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
-		target_write_u32(target, OMAP3530_DEBUG_BASE
+		target_write_u32(target, armv7a->debug_base
 				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].value);
 	}
@@ -1366,35 +1366,38 @@
 	uint32_t didr, ctypr, ttypr, cpuid;
 
 	LOG_DEBUG("TODO");
+	
+	/* Here we shall insert a proper ROM Table scan */
+	armv7a->debug_base = OMAP3530_DEBUG_BASE;
 
 	/* We do one extra read to ensure DAP is configured,
 	 * we call ahbap_debugport_init(swjdp) instead
 	 */
 	ahbap_debugport_init(swjdp);
-	mem_ap_read_atomic_u32(swjdp, OMAP3530_DEBUG_BASE + CPUDBG_CPUID, &cpuid);
+	mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_CPUID, &cpuid);
 	if ((retval = mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_CPUID, &cpuid)) != ERROR_OK)
+			armv7a->debug_base + CPUDBG_CPUID, &cpuid)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine failed");
 		return retval;
 	}
 
 	if ((retval = mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_CTYPR, &ctypr)) != ERROR_OK)
+			armv7a->debug_base + CPUDBG_CTYPR, &ctypr)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine failed");
 		return retval;
 	}
 
 	if ((retval = mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_TTYPR, &ttypr)) != ERROR_OK)
+			armv7a->debug_base + CPUDBG_TTYPR, &ttypr)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine failed");
 		return retval;
 	}
 
 	if ((retval = mem_ap_read_atomic_u32(swjdp,
-			OMAP3530_DEBUG_BASE + CPUDBG_DIDR, &didr)) != ERROR_OK)
+			armv7a->debug_base + CPUDBG_DIDR, &didr)) != ERROR_OK)
 	{
 		LOG_DEBUG("Examine failed");
 		return retval;



From mlu at mail.berlios.de  Wed Sep 16 20:18:46 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Wed, 16 Sep 2009 20:18:46 +0200
Subject: [Openocd-svn] r2717 - trunk/src/target
Message-ID: <200909161818.n8GIIkkH019290@sheep.berlios.de>

Author: mlu
Date: 2009-09-16 20:18:38 +0200 (Wed, 16 Sep 2009)
New Revision: 2717

Modified:
   trunk/src/target/cortex_a8.h
Log:
Remove unused varables (moved to armv7a)

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-09-16 18:17:26 UTC (rev 2716)
+++ trunk/src/target/cortex_a8.h	2009-09-16 18:18:38 UTC (rev 2717)
@@ -103,11 +103,6 @@
 	int common_magic;
 	arm_jtag_t jtag_info;
 
-	/* Core Debug Unit */
-	uint32_t debug_base;
-	uint8_t debug_ap;
-	uint8_t memory_ap;
-
 	/* Context information */
 	uint32_t cpudbg_dscr;
 	uint32_t nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */



From oharboe at mail.berlios.de  Thu Sep 17 13:23:54 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 17 Sep 2009 13:23:54 +0200
Subject: [Openocd-svn] r2720 - in trunk: doc src/jtag src/target
Message-ID: <200909171123.n8HBNsoL029798@sheep.berlios.de>

Author: oharboe
Date: 2009-09-17 13:23:41 +0200 (Thu, 17 Sep 2009)
New Revision: 2720

Modified:
   trunk/doc/openocd.texi
   trunk/src/jtag/jtag.h
   trunk/src/jtag/tcl.c
   trunk/src/target/arm7_9_common.c
Log:
srst_gates_jtag option. at91sam9260 needs retesting, and possibly srst_gates_jtag added to reset_config. Could i.MX27 be a case where srst does not pull trst, but really srst gates jtag clock?

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-17 08:02:43 UTC (rev 2719)
+++ trunk/doc/openocd.texi	2009-09-17 11:23:41 UTC (rev 2720)
@@ -2018,6 +2018,10 @@
 @option{combined} implies both @option{srst_pulls_trst} and
 @option{trst_pulls_srst}.
 
+ at option{srst_gates_jtag} indicates that asserting SRST gates the
+JTAG clock. This means that no communication can happen on JTAG
+while SRST is asserted. 
+
 The optional @var{trst_type} and @var{srst_type} parameters allow the
 driver mode of each reset line to be specified.  These values only affect
 JTAG interfaces with support for different driver modes, like the Amontec

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-09-17 08:02:43 UTC (rev 2719)
+++ trunk/src/jtag/jtag.h	2009-09-17 11:23:41 UTC (rev 2720)
@@ -277,6 +277,7 @@
 	RESET_TRST_PULLS_SRST = 0x8,
 	RESET_TRST_OPEN_DRAIN = 0x10,
 	RESET_SRST_PUSH_PULL  = 0x20,
+	RESET_SRST_GATES_JTAG = 0x40,
 };
 
 enum reset_types jtag_get_reset_config(void);

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-17 08:02:43 UTC (rev 2719)
+++ trunk/src/jtag/tcl.c	2009-09-17 11:23:41 UTC (rev 2720)
@@ -845,6 +845,14 @@
 		int tmp = 0;
 		int m;
 
+		m = RESET_SRST_GATES_JTAG;
+		tmp = 0;
+		if (strcmp(*args, "srst_gates_jtag") == 0)
+		{
+			tmp = RESET_SRST_GATES_JTAG;
+			goto next;
+		}
+
 		/* signals */
 		m = RESET_HAS_TRST | RESET_HAS_SRST;
 		if (strcmp(*args, "none") == 0)

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-09-17 08:02:43 UTC (rev 2719)
+++ trunk/src/target/arm7_9_common.c	2009-09-17 11:23:41 UTC (rev 2720)
@@ -1021,6 +1021,17 @@
 		return ERROR_FAIL;
 	}
 
+	/* at this point trst has been asserted/deasserted once. We want to
+	 * program embedded ice while SRST is asserted, but some CPUs gate
+	 * the JTAG clock while SRST is asserted
+	 */
+	bool srst_asserted = false;
+	if (((jtag_reset_config & RESET_SRST_PULLS_TRST) == 0) && ((jtag_reset_config & RESET_SRST_GATES_JTAG) == 0))
+	{
+		jtag_add_reset(0, 1);
+		srst_asserted = true;
+	}
+
 	if (target->reset_halt)
 	{
 		/*
@@ -1053,7 +1064,7 @@
 	if (jtag_reset_config & RESET_SRST_PULLS_TRST)
 	{
 		jtag_add_reset(1, 1);
-	} else
+	} else if (!srst_asserted)
 	{
 		jtag_add_reset(0, 1);
 	}



From oharboe at mail.berlios.de  Thu Sep 17 13:44:28 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 17 Sep 2009 13:44:28 +0200
Subject: [Openocd-svn] r2721 - trunk/src zy1000/trunk/build
	zy1000/trunk/build/menu
Message-ID: <200909171144.n8HBiSVS012634@sheep.berlios.de>

Author: oharboe
Date: 2009-09-17 13:44:14 +0200 (Thu, 17 Sep 2009)
New Revision: 2721

Modified:
   trunk/src/ecosboard.c
   zy1000/trunk/build/makefw.sh
   zy1000/trunk/build/menu/zy1000menu.xml
Log:
prefix zy1000_reboot command to avoid name conflicts

Modified: trunk/src/ecosboard.c
===================================================================
--- trunk/src/ecosboard.c	2009-09-17 11:23:41 UTC (rev 2720)
+++ trunk/src/ecosboard.c	2009-09-17 11:44:14 UTC (rev 2721)
@@ -503,7 +503,7 @@
 
 	Jim_CreateCommand(httpstate.jim_interp, "log", zylinjtag_Jim_Command_log,
 			NULL, NULL);
-	Jim_CreateCommand(httpstate.jim_interp, "reboot",
+	Jim_CreateCommand(httpstate.jim_interp, "zy1000_reboot",
 			zylinjtag_Jim_Command_reboot, NULL, NULL);
 	Jim_CreateCommand(httpstate.jim_interp, "threads",
 			zylinjtag_Jim_Command_threads, NULL, NULL);

Modified: zy1000/trunk/build/makefw.sh
===================================================================
--- zy1000/trunk/build/makefw.sh	2009-09-17 11:23:41 UTC (rev 2720)
+++ zy1000/trunk/build/makefw.sh	2009-09-17 11:44:14 UTC (rev 2721)
@@ -1,4 +1,4 @@
-arm-elf-objcopy -R .fastbss -O binary src/openocd src/openocd.bin
+arm-elf-objcopy -O binary src/openocd src/openocd.bin
 cat >deflateopenocd.bin $OPENOCD/deflate.bin
 cp src/openocd.bin openocd.bin
 rm -f openocd.bin.gz

Modified: zy1000/trunk/build/menu/zy1000menu.xml
===================================================================
--- zy1000/trunk/build/menu/zy1000menu.xml	2009-09-17 11:23:41 UTC (rev 2720)
+++ zy1000/trunk/build/menu/zy1000menu.xml	2009-09-17 11:44:14 UTC (rev 2721)
@@ -144,7 +144,7 @@
 			<tcl>
 				if {[string compare $form_action "Reboot ZY1000"]==0} {
 					append buffer "Rebooting ZY1000..."
-					reboot
+					zy1000_reboot
 				}
 			</tcl>
 
@@ -188,7 +188,7 @@
 			if {[string compare $form_action "Select and reload"]==0} {
 				capture "trunc /config/settings/openocd.cfg"
 				capture "append_file /config/settings/openocd.cfg script $form_target"
-				reboot 
+				zy1000_reboot 
 			}
 			
 			set form_target [load_target] 
@@ -410,7 +410,7 @@
 	
 				if {[string compare $form_action "Reload"]==0} {
 					append buffer "Reloading Config Scripts...<p>"
-					reboot
+					zy1000_reboot
 				}
 			</tcl>
 			<form enctype="multipart/form-data" action="reload.tcl" method="post">
@@ -1257,7 +1257,7 @@
 					if {[check_firmware $form_filecontent]} {
 						write_firmware $form_filecontent
 						append buffer "<br><div style='font-size:14px;'>Upgraded Zylin JTAG, rebooting (wait ca. 30 seconds)...</div><br>"
-						reboot
+						zy1000_reboot
 					} else {
 						append buffer "<br>Not a valid Zylin JTAG firmware file.<br>"
 					}
@@ -1271,7 +1271,7 @@
 						}
 					}				
 					rmdir /config/settings
-					reboot
+					zy1000_reboot
 					append buffer "Restoring factory settings (wait ca. 30 seconds)...<br>"
 				} else {
 					append buffer {<div style="font-size:14px;">Upgrade Zylin JTAG firmware + reboot. </div><p>}
@@ -1480,13 +1480,13 @@
 					$fp puts -nonewline "$form_ip,$form_mask,$form_gateway"
 					$fp close
 					append buffer "Set $form_ip,$form_mask,$form_gateway to $form_filename. Reloading settings..."
-					reboot
+					zy1000_reboot
 				} elseif {[string compare $form_action "Use DHCP"]==0} {
 					set fp [aio.open $form_filename w];
 					$fp puts -nonewline ""
 					$fp close
 					append buffer "Using DHCP. Reloading settings..."
-					reboot
+					zy1000_reboot
 				} else {
 				</tcl>
 					<form action="zy1000.tcl" method="post"> 



From oharboe at mail.berlios.de  Thu Sep 17 14:26:13 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 17 Sep 2009 14:26:13 +0200
Subject: [Openocd-svn] r2722 - trunk/src/jtag
Message-ID: <200909171226.n8HCQDvi013047@sheep.berlios.de>

Author: oharboe
Date: 2009-09-17 14:25:53 +0200 (Thu, 17 Sep 2009)
New Revision: 2722

Modified:
   trunk/src/jtag/ft2232.c
Log:
michal smulski <michal.smulski at ooma.com> fix regression in jtag_add_pathmove() which broke arm11 in r1825. Other uses of jtag_add_pathmove are svn + xsvf + xscale...

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-09-17 11:44:14 UTC (rev 2721)
+++ trunk/src/jtag/ft2232.c	2009-09-17 12:25:53 UTC (rev 2722)
@@ -766,33 +766,45 @@
  */
 static void ft2232_add_pathmove(tap_state_t* path, int num_states)
 {
-	int			tms_bits = 0;
-	int			state_ndx;
-	tap_state_t	walker = tap_get_state();
+	int state_count = 0;
 
 	assert((unsigned) num_states <= 32u);		/* tms_bits only holds 32 bits */
 
 	/* this loop verifies that the path is legal and logs each state in the path */
-	for (state_ndx = 0; state_ndx < num_states;  ++state_ndx)
+	while (num_states)
 	{
-		tap_state_t	desired_next_state = path[state_ndx];
+		unsigned char  tms_byte = 0;       /* zero this on each MPSSE batch */
 
-		if (tap_state_transition(walker, false) == desired_next_state)
-			;	/* bit within tms_bits at index state_ndx is already zero */
-		else if (tap_state_transition(walker, true) == desired_next_state)
-			tms_bits |= (1 << state_ndx);
-		else
+		int bit_count = 0;
+
+		int num_states_batch = num_states > 7 ? 7 : num_states;
+
+		/* command "Clock Data to TMS/CS Pin (no Read)" */
+		buffer_write(0x4b);
+
+		/* number of states remaining */
+		buffer_write(num_states_batch - 1);
+
+		while (num_states_batch--)
 		{
-			LOG_ERROR("BUG: %s -> %s isn't a valid TAP transition",
-					tap_state_name(walker), tap_state_name(desired_next_state));
-			exit(-1);
+		  if (tap_state_transition(tap_get_state(), false) == path[state_count])
+				buf_set_u32(&tms_byte, bit_count++, 1, 0x0);
+		  else if (tap_state_transition(tap_get_state(), true) == path[state_count])
+				buf_set_u32(&tms_byte, bit_count++, 1, 0x1);
+			else
+			{
+				LOG_ERROR( "BUG: %s -> %s isn't a valid TAP transition", tap_state_name(
+								 tap_get_state() ), tap_state_name(path[state_count]) );
+				exit(-1);
+			}
+
+		  tap_set_state(path[state_count]);
+			state_count++;
+			num_states--;
 		}
 
-		walker = desired_next_state;
-	}
-
-	clock_tms(0x4b,  tms_bits, num_states, 0);
-
+		buffer_write(tms_byte);
+	}	
 	tap_set_end_state(tap_get_state());
 }
 



From dbrownell at mail.berlios.de  Thu Sep 17 09:56:26 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Thu, 17 Sep 2009 09:56:26 +0200
Subject: [Openocd-svn] r2718 - trunk/doc
Message-ID: <200909170756.n8H7uQkw031442@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-17 09:56:24 +0200 (Thu, 17 Sep 2009)
New Revision: 2718

Modified:
   trunk/doc/openocd.texi
Log:
Doc update:  mention how ARM's WFI instruction affects
JTAG clocking by gating the core clock, and workarounds.
Most details are with the "halt" command, which is one
of the first places this issue will be noticed.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-16 18:18:38 UTC (rev 2717)
+++ trunk/doc/openocd.texi	2009-09-17 07:56:24 UTC (rev 2718)
@@ -1055,7 +1055,19 @@
 Before your @code{reset-init} handler has set up
 the PLLs and clocking, you may need to use
 a low JTAG clock rate; then you'd increase it later.
-(The rule of thumb for ARM-based processors is 1/8 the CPU clock.)
+For most ARM-based processors the fastest JTAG clock at footnote{A FAQ
+ at uref{http://www.arm.com/support/faqdev/4170.html} gives details.}
+is one sixth of the CPU clock; or one eighth for ARM11 cores.
+Consult chip documentation to determine the peak JTAG clock rate,
+which might be less than that.
+
+ at quotation Warning
+On most ARMs, JTAG clock detection is coupled to the core clock, so
+software using a @option{wait for interrupt} operation blocks JTAG access.
+Adaptive clocking provides a partial workaround, but a more complete
+solution just avoids using that instruction with JTAG debuggers.
+ at end quotation
+
 If the board supports adaptive clocking, use the @command{jtag_rclk}
 command, in case your board is used with JTAG adapter which
 also supports it.  Otherwise use @command{jtag_khz}.
@@ -1785,9 +1797,10 @@
 speeds.  The speed actually used won't be faster
 than the speed specified.
 
-As a rule of thumb, if you specify a clock rate make
-sure the JTAG clock is no more than @math{1/6th CPU-Clock}.
-This is especially true for synthesized cores (ARMxxx-S).
+Chip data sheets generally include a top JTAG clock rate.
+The actual rate is often a function of a CPU core clock,
+and is normally less than that peak rate.
+For example, most ARM cores accept at most one sixth of the CPU clock.
 
 Speed 0 (khz) selects RTCK method.
 @xref{FAQ RTCK}.
@@ -1799,6 +1812,7 @@
 @end deffn
 
 @defun jtag_rclk fallback_speed_kHz
+ at cindex adaptive clocking
 @cindex RTCK
 This Tcl proc (defined in @file{startup.tcl}) attempts to enable RTCK/RCLK.
 If that fails (maybe the interface, board, or target doesn't
@@ -4321,6 +4335,31 @@
 or 5 seconds if there is no parameter, for the target to halt
 (and enter debug mode).
 Using 0 as the @var{ms} parameter prevents OpenOCD from waiting.
+
+ at quotation Warning
+On ARM cores, software using the @emph{wait for interrupt} operation
+often blocks the JTAG access needed by a @command{halt} command.
+This is because that operation also puts the core into a low
+power mode by gating the core clock;
+but the core clock is needed to detect JTAG clock transitions.
+
+One partial workaround uses adaptive clocking:  when the core is
+interrupted the operation completes, then JTAG clocks are accepted
+at least until the interrupt handler completes.
+However, this workaround is often unusable since the processor, board,
+and JTAG adapter must all support adaptive JTAG clocking.
+Also, it can't work until an interrupt is issued.
+
+A more complete workaround is to not use that operation while you
+work with a JTAG debugger.
+Tasking environments generaly have idle loops where the body is the
+ at emph{wait for interrupt} operation.
+(On older cores, it is a coprocessor action;
+newer cores have a @option{wfi} instruction.)
+Such loops can just remove that operation, at the cost of higher
+power consumption (because the CPU is needlessly clocked).
+ at end quotation
+
 @end deffn
 
 @deffn Command resume [address]
@@ -5984,9 +6023,10 @@
 
 In most simple terms: Often the JTAG clock must be 1/10 to 1/12 of
 the target clock speed. But what that ``magic division'' is varies
-depending on the chips on your board. @b{ARM rule of thumb} Most ARM
-based systems require an 8:1 division. @b{Xilinx rule of thumb} is
-1/12 the clock speed.
+depending on the chips on your board.
+ at b{ARM rule of thumb} Most ARM based systems require an 6:1 division;
+ARM11 cores use an 8:1 division.
+ at b{Xilinx rule of thumb} is 1/12 the clock speed.
 
 Note: Many FTDI2232C based JTAG dongles are limited to 6MHz.
 
@@ -5999,11 +6039,18 @@
 sleep''. If you are careful - 98% of your problems can be debugged
 this way.
 
+Note that on ARM you may need to avoid using the @emph{wait for interrupt}
+operation in your idle loops even if you don't otherwise change the CPU
+clock rate.
+That operation gates the CPU clock, and thus the JTAG clock; which
+prevents JTAG access.  One consequence is not being able to @command{halt}
+cores which are executing that @emph{wait for interrupt} operation.
+
 To set the JTAG frequency use the command:
 
 @example
-        # Example: 1.234MHz
-        jtag_khz 1234
+# Example: 1.234MHz
+jtag_khz 1234
 @end example
 
 



From dbrownell at mail.berlios.de  Thu Sep 17 10:02:54 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Thu, 17 Sep 2009 10:02:54 +0200
Subject: [Openocd-svn] r2719 - in trunk: doc src/target
Message-ID: <200909170802.n8H82s0p031895@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-17 10:02:43 +0200 (Thu, 17 Sep 2009)
New Revision: 2719

Modified:
   trunk/doc/openocd.texi
   trunk/src/target/arm9tdmi.c
Log:
The "arm9tdmi.c" file is more of a generic ARM9 support file:

 - update comments to say so.
 - update docs to clarify that the "arm9tdmi" command prefix
   is a misnomer.
 - bugfix some messages that wrongly assume only ARM9TDMI
   based processors use this code.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-17 07:56:24 UTC (rev 2718)
+++ trunk/doc/openocd.texi	2009-09-17 08:02:43 UTC (rev 2719)
@@ -4932,13 +4932,18 @@
 and display the result.
 @end deffn
 
- at subsection ARM9TDMI specific commands
- at cindex ARM9TDMI
+ at subsection ARM9 specific commands
+ at cindex ARM9
 
-Many ARM9-family CPUs are built around ARM9TDMI integer cores,
-or processors resembling ARM9TDMI, and can use these commands.
+ARM9-family cores are built around ARM9TDMI or ARM9E (including ARM9EJS)
+integer processors.
 Such cores include the ARM920T, ARM926EJ-S, and ARM966.
 
+For historical reasons, one command shared by these cores starts
+with the @command{arm9tdmi} prefix.
+This is true even for ARM9E based processors, which implement the
+ARMv5TE architecture instead of ARMv4T.
+
 @c 9-june-2009:  tried this on arm920t, it didn't work.
 @c no-params always lists nothing caught, and that's how it acts.
 

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-09-17 07:56:24 UTC (rev 2718)
+++ trunk/src/target/arm9tdmi.c	2009-09-17 08:02:43 UTC (rev 2719)
@@ -31,6 +31,16 @@
 #include "target_type.h"
 
 
+/*
+ * NOTE:  this holds code that's used with multiple ARM9 processors:
+ *  - ARM9TDMI (ARMv4T) ... in ARM920, ARM922, and ARM940 cores
+ *  - ARM9E-S (ARMv5TE) ... in ARM946, ARM966, and ARM968 cores
+ *  - ARM9EJS (ARMv5TEJ) ... in ARM926 core
+ *
+ * In short, the file name is a misnomer ... it is NOT specific to
+ * that first generation ARM9 processor, or cores using it.
+ */
+
 #if 0
 #define _DEBUG_INSTRUCTION_EXECUTION_
 #endif
@@ -967,8 +977,12 @@
 	command_t *arm9tdmi_cmd;
 
 	retval = arm7_9_register_commands(cmd_ctx);
-	arm9tdmi_cmd = register_command(cmd_ctx, NULL, "arm9tdmi", NULL, COMMAND_ANY, "arm9tdmi specific commands");
-	register_command(cmd_ctx, arm9tdmi_cmd, "vector_catch", handle_arm9tdmi_catch_vectors_command, COMMAND_EXEC, "catch arm920t vectors ['all'|'none'|'<vec1 vec2 ...>']");
+	arm9tdmi_cmd = register_command(cmd_ctx, NULL, "arm9tdmi",
+			NULL, COMMAND_ANY,
+			"arm9tdmi specific commands");
+	register_command(cmd_ctx, arm9tdmi_cmd, "vector_catch",
+			handle_arm9tdmi_catch_vectors_command, COMMAND_EXEC,
+			"catch arm9 vectors ['all'|'none'|'<vec1 vec2 ...>']");
 
 	return retval;
 }
@@ -985,7 +999,7 @@
 
 	if (arm9tdmi_get_arch_pointers(target, &armv4_5, &arm7_9, &arm9tdmi) != ERROR_OK)
 	{
-		command_print(cmd_ctx, "current target isn't an ARM9TDMI based target");
+		command_print(cmd_ctx, "current target isn't an ARM9 based target");
 		return ERROR_OK;
 	}
 



From dbrownell at mail.berlios.de  Thu Sep 17 20:52:33 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Thu, 17 Sep 2009 20:52:33 +0200
Subject: [Openocd-svn] r2723 - trunk/src/helper
Message-ID: <200909171852.n8HIqXTp003424@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-17 20:52:32 +0200 (Thu, 17 Sep 2009)
New Revision: 2723

Modified:
   trunk/src/helper/jim.c
Log:
Fix coredump seen in some code paths.


Modified: trunk/src/helper/jim.c
===================================================================
--- trunk/src/helper/jim.c	2009-09-17 12:25:53 UTC (rev 2722)
+++ trunk/src/helper/jim.c	2009-09-17 18:52:32 UTC (rev 2723)
@@ -2828,6 +2828,9 @@
     int i;
     struct ScriptObj *script = (void*) objPtr->internalRep.ptr;
 
+    if (!script)
+	    return;
+
     script->inUse--;
     if (script->inUse != 0) return;
     for (i = 0; i < script->len; i++) {



From dbrownell at mail.berlios.de  Thu Sep 17 20:56:18 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Thu, 17 Sep 2009 20:56:18 +0200
Subject: [Openocd-svn] r2724 - in trunk: doc src/flash
Message-ID: <200909171856.n8HIuIvu004032@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-17 20:56:17 +0200 (Thu, 17 Sep 2009)
New Revision: 2724

Modified:
   trunk/doc/openocd.texi
   trunk/src/flash/nand.c
Log:
Minor fixes to NAND code and docs

Erase logic:
 - command invocation
    + treat "nand erase N" (no offset/length) as "erase whole chip N"
    + catch a few more bogus parameter cases, like length == 0 (sigh)
 - nand_erase() should be static
 - on error
    + say which block failed, and if it was a bad block
    + don't give up after the first error; try to erase the rest
 - on success, say which nand device was erased (name isn't unique)

Device list ("nand list"):
 - say how many blocks there are
 - split summary into two lines
 - give example in the docs

Doc tweaks:
 - Use @option{...} for DaVinci's supported hardware ECC options

For the record, I've observed that _sometimes_ erasing bad blocks causes
failure reports, and that manufacturer bad block markers aren't always
erasable (even when erasing their blocks doesn't trigger an error report).


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-17 18:52:32 UTC (rev 2723)
+++ trunk/doc/openocd.texi	2009-09-17 18:56:17 UTC (rev 2724)
@@ -3898,9 +3898,17 @@
 @end deffn
 
 @deffn Command {nand list}
-Prints a one-line summary of each device declared
+Prints a summary of each device declared
 using @command{nand device}, numbered from zero.
 Note that un-probed devices show no details.
+ at example
+> nand list
+#0: NAND 1GiB 3,3V 8-bit (Micron) pagesize: 2048, buswidth: 8,
+        blocksize: 131072, blocks: 8192
+#1: NAND 1GiB 3,3V 8-bit (Micron) pagesize: 2048, buswidth: 8,
+        blocksize: 131072, blocks: 8192
+>
+ at end example
 @end deffn
 
 @deffn Command {nand probe} num
@@ -3950,13 +3958,15 @@
 @end itemize
 @end deffn
 
- at deffn Command {nand erase} num offset length
+ at deffn Command {nand erase} num [offset length]
 @cindex NAND erasing
 @cindex NAND programming
 Erases blocks on the specified NAND device, starting at the
 specified @var{offset} and continuing for @var{length} bytes.
 Both of those values must be exact multiples of the device's
 block size, and the region they specify must fit entirely in the chip.
+If those parameters are not specified,
+the whole NAND chip will be erased.
 The @var{num} parameter is the value shown by @command{nand list}.
 
 @b{NOTE:} This command will try to erase bad blocks, when told
@@ -4079,7 +4089,8 @@
 chips from Texas Instruments.
 It takes three extra parameters:
 address of the NAND chip;
-hardware ECC mode to use (hwecc1, hwecc4, hwecc4_infix);
+hardware ECC mode to use (@option{hwecc1},
+ at option{hwecc4}, @option{hwecc4_infix});
 address of the AEMIF controller on this processor.
 @example
 nand device davinci dm355.arm 0x02000000 hwecc4 0x01e10000

Modified: trunk/src/flash/nand.c
===================================================================
--- trunk/src/flash/nand.c	2009-09-17 18:52:32 UTC (rev 2723)
+++ trunk/src/flash/nand.c	2009-09-17 18:56:17 UTC (rev 2724)
@@ -309,8 +309,9 @@
 						 "identify NAND flash device <num>");
 		register_command(cmd_ctx, nand_cmd, "check_bad_blocks", handle_nand_check_bad_blocks_command, COMMAND_EXEC,
 						 "check NAND flash device <num> for bad blocks [<offset> <length>]");
-		register_command(cmd_ctx, nand_cmd, "erase", handle_nand_erase_command, COMMAND_EXEC,
-						 "erase blocks on NAND flash device <num> <offset> <length>");
+		register_command(cmd_ctx, nand_cmd, "erase",
+				handle_nand_erase_command, COMMAND_EXEC,
+				"erase blocks on NAND flash device <num> [<offset> <length>]");
 		register_command(cmd_ctx, nand_cmd, "dump", handle_nand_dump_command, COMMAND_EXEC,
 						 "dump from NAND flash device <num> <filename> "
 						 "<offset> <length> [oob_raw | oob_only]");
@@ -637,7 +638,7 @@
 	return ERROR_OK;
 }
 
-int nand_erase(struct nand_device_s *device, int first_block, int last_block)
+static int nand_erase(struct nand_device_s *device, int first_block, int last_block)
 {
 	int i;
 	uint32_t page;
@@ -712,8 +713,11 @@
 
 		if (status & 0x1)
 		{
-			LOG_ERROR("erase operation didn't pass, status: 0x%2.2x", status);
-			return ERROR_NAND_OPERATION_FAILED;
+			LOG_ERROR("didn't erase %sblock %d; status: 0x%2.2x",
+					(device->blocks[i].is_bad == 1)
+						? "bad " : "",
+					i, status);
+			/* continue; other blocks might still be erasable */
 		}
 
 		device->blocks[i].is_erased = 1;
@@ -1075,8 +1079,12 @@
 	for (p = nand_devices, i = 0; p; p = p->next, i++)
 	{
 		if (p->device)
-			command_print(cmd_ctx, "#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i",
-				i, p->device->name, p->manufacturer->name, p->page_size, p->bus_width, p->erase_size);
+			command_print(cmd_ctx, "#%i: %s (%s) "
+				"pagesize: %i, buswidth: %i,\n\t"
+				"blocksize: %i, blocks: %i",
+				i, p->device->name, p->manufacturer->name,
+				p->page_size, p->bus_width,
+				p->erase_size, p->num_blocks);
 		else
 			command_print(cmd_ctx, "#%i: not probed", i);
 	}
@@ -1197,7 +1205,7 @@
 	nand_device_t *p;
 	int retval;
 
-	if (argc != 3)
+	if (argc != 1 && argc != 3)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
@@ -1210,27 +1218,37 @@
 		unsigned long offset;
 		unsigned long length;
 
-		offset = strtoul(args[1], &cp, 0);
-		if (*cp || offset == ULONG_MAX || offset % p->erase_size)
-		{
-			return ERROR_INVALID_ARGUMENTS;
-		}
-		offset /= p->erase_size;
+		/* erase specified part of the chip; or else everything */
+		if (argc == 3) {
+			unsigned long size = p->erase_size * p->num_blocks;
 
-		length = strtoul(args[2], &cp, 0);
-		if (*cp || length == ULONG_MAX || length % p->erase_size)
-		{
-			return ERROR_INVALID_ARGUMENTS;
+			offset = strtoul(args[1], &cp, 0);
+			if (*cp || (offset == ULONG_MAX)
+					|| (offset % p->erase_size) != 0
+					|| offset >= size)
+				return ERROR_INVALID_ARGUMENTS;
+
+			length = strtoul(args[2], &cp, 0);
+			if (*cp || (length == ULONG_MAX)
+					|| (length == 0)
+					|| (length % p->erase_size) != 0
+					|| (length + offset) > size)
+				return ERROR_INVALID_ARGUMENTS;
+
+			offset /= p->erase_size;
+			length /= p->erase_size;
+		} else {
+			offset = 0;
+			length = p->num_blocks;
 		}
-		length -= 1;
-		length /= p->erase_size;
 
-		retval = nand_erase(p, offset, offset + length);
+		retval = nand_erase(p, offset, offset + length - 1);
 		if (retval == ERROR_OK)
 		{
-			command_print(cmd_ctx, "successfully erased blocks "
-					"%lu to %lu on NAND flash device '%s'",
-					offset, offset + length, p->device->name);
+			command_print(cmd_ctx, "erased blocks %lu to %lu "
+					"on NAND flash device #%s '%s'",
+					offset, offset + length,
+					args[0], p->device->name);
 		}
 		else if (retval == ERROR_NAND_OPERATION_FAILED)
 		{



From dbrownell at mail.berlios.de  Thu Sep 17 21:20:19 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Thu, 17 Sep 2009 21:20:19 +0200
Subject: [Openocd-svn] r2725 - trunk/src/jtag
Message-ID: <200909171920.n8HJKJHh006524@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-17 21:20:18 +0200 (Thu, 17 Sep 2009)
New Revision: 2725

Modified:
   trunk/src/jtag/core.c
   trunk/src/jtag/tcl.c
Log:
Address codereview comment from Steve Grubb <sgrubb at redhat.com>:
avoid a duplicate test.

Plus other cleanup in the same code: be "static", sane line lengths
for source and diagnostics, and fix misleading variable names.


Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-17 18:56:17 UTC (rev 2724)
+++ trunk/src/jtag/core.c	2009-09-17 19:20:18 UTC (rev 2725)
@@ -385,7 +385,8 @@
 	interface_jtag_add_callback4(f, data0, data1, data2, data3);
 }
 
-int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value, uint8_t *in_check_mask, int num_bits);
+static int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value,
+		uint8_t *in_check_mask, int num_bits);
 
 static int jtag_check_value_mask_callback(jtag_callback_data_t data0, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
 {
@@ -727,7 +728,8 @@
 	jtag_set_error(interface_jtag_add_sleep(us));
 }
 
-int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value, uint8_t *in_check_mask, int num_bits)
+static int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value,
+		uint8_t *in_check_mask, int num_bits)
 {
 	int retval = ERROR_OK;
 
@@ -739,39 +741,32 @@
 		compare_failed = buf_cmp(captured, in_check_value, num_bits);
 
 	if (compare_failed) {
-		/* An error handler could have caught the failing check
-		 * only report a problem when there wasn't a handler, or if the handler
-		 * acknowledged the error
-		 */
-		/*
-		LOG_WARNING("TAP %s:",
-					jtag_tap_name(field->tap));
-					*/
-		if (compare_failed)
-		{
-			char *captured_char = buf_to_str(captured, (num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);
-			char *in_check_value_char = buf_to_str(in_check_value, (num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);
+		char *captured_str, *in_check_value_str;
+		int bits = (num_bits > DEBUG_JTAG_IOZ)
+				? DEBUG_JTAG_IOZ
+				: num_bits;
 
-			if (in_check_mask)
-			{
-				char *in_check_mask_char;
-				in_check_mask_char = buf_to_str(in_check_mask, (num_bits > DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);
-				LOG_WARNING("value captured during scan didn't pass the requested check:");
-				LOG_WARNING("captured: 0x%s check_value: 0x%s check_mask: 0x%s",
-							captured_char, in_check_value_char, in_check_mask_char);
-				free(in_check_mask_char);
-			}
-			else
-			{
-				LOG_WARNING("value captured during scan didn't pass the requested check: captured: 0x%s check_value: 0x%s", captured_char, in_check_value_char);
-			}
+		/* NOTE:  we've lost diagnostic context here -- 'which tap' */
 
-			free(captured_char);
-			free(in_check_value_char);
+		captured_str = buf_to_str(captured, bits, 16);
+		in_check_value_str = buf_to_str(in_check_value, bits, 16);
 
-			retval = ERROR_JTAG_QUEUE_FAILED;
+		LOG_WARNING("Bad value '%s' captured during DR or IR scan:",
+				captured_str);
+		LOG_WARNING(" check_value: 0x%s", in_check_value_str);
+
+		free(captured_str);
+		free(in_check_value_str);
+
+		if (in_check_mask) {
+			char *in_check_mask_str;
+
+			in_check_mask_str = buf_to_str(in_check_mask, bits, 16);
+			LOG_WARNING(" check_mask: 0x%s", in_check_mask_str);
+			free(in_check_mask_str);
 		}
 
+		retval = ERROR_JTAG_QUEUE_FAILED;
 	}
 	return retval;
 }
@@ -974,7 +969,7 @@
 
 /* Try to examine chain layout according to IEEE 1149.1 ?12
  */
-int jtag_examine_chain(void)
+static int jtag_examine_chain(void)
 {
 	uint8_t idcode_buffer[JTAG_MAX_CHAIN_SIZE * 4];
 	unsigned device_count = 0;

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-17 18:56:17 UTC (rev 2724)
+++ trunk/src/jtag/tcl.c	2009-09-17 19:20:18 UTC (rev 2725)
@@ -75,8 +75,6 @@
 static int handle_verify_jtag_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_tms_sequence_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-extern int jtag_examine_chain(void);
-extern int jtag_validate_chain(void);
 
 enum jtag_tap_cfg_param {
 	JCFG_EVENT



From dbrownell at mail.berlios.de  Fri Sep 18 02:12:01 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Fri, 18 Sep 2009 02:12:01 +0200
Subject: [Openocd-svn] r2726 - trunk/src/helper
Message-ID: <200909180012.n8I0C1DC014940@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-18 02:11:51 +0200 (Fri, 18 Sep 2009)
New Revision: 2726

Modified:
   trunk/src/helper/startup.tcl
Log:
Tweak TCL reset script ... mostly improving descriptions of
the various steps, but also calling [target names] only once.


Modified: trunk/src/helper/startup.tcl
===================================================================
--- trunk/src/helper/startup.tcl	2009-09-17 19:20:18 UTC (rev 2725)
+++ trunk/src/helper/startup.tcl	2009-09-18 00:11:51 UTC (rev 2726)
@@ -157,6 +157,7 @@
 }
 
 proc ocd_process_reset_inner { MODE } {
+	set targets [target names]
 
 	# If this target must be halted...
 	set halt -1
@@ -175,26 +176,38 @@
 
 	# Target event handlers *might* change which TAPs are enabled
 	# or disabled, so we fire all of them.  But don't issue any
-	# of the "arp_*" commands, which may issue JTAG transactions,
+	# target "arp_*" commands, which may issue JTAG transactions,
 	# unless we know the underlying TAP is active.
+	#
+	# NOTE:  ARP == "Advanced Reset Process" ... "advanced" is
+	# relative to a previous restrictive scheme
 
-	foreach t [ target names ] {
+	foreach t $targets {
 		# New event script.
 		$t invoke-event reset-start
 	}
 
-	# Init the tap controller.
+	# Use TRST or TMS/TCK operations to reset all the tap controllers.
+	# TAP reset events get reported; they might enable some taps.
+	#
+	# REVISIT arp_init-reset pulses SRST (if it can) with TRST active;
+	# but SRST events aren't reported (unlike "jtag arp_reset", below)
 	jtag arp_init-reset
 
 	# Examine all targets on enabled taps.
-	foreach t [ target names ] {
+	foreach t $targets {
 		if {[jtag tapisenabled [$t cget -chain-position]]} {
 			$t arp_examine
 		}
 	}
 
-	# Let the C code know we are asserting reset.
-	foreach t [ target names ] {
+	# Assert SRST, and report the pre/post events.
+	#
+	# REVISIT this presumes a single-target config, since SRST
+	# applies to the whole device-under-test.  When two targets
+	# both need special setup before SRST, it's only done for
+	# the first one...
+	foreach t $targets {
 		$t invoke-event reset-assert-pre
 		# C code needs to know if we expect to 'halt'
 		if {[jtag tapisenabled [$t cget -chain-position]]} {
@@ -203,8 +216,8 @@
 		$t invoke-event reset-assert-post
 	}
 
-	# Now de-assert reset.
-	foreach t [ target names ] {
+	# Now de-assert SRST, and report the pre/post events.
+	foreach t $targets {
 		$t invoke-event reset-deassert-pre
 		# Again, de-assert code needs to know..
 		if {[jtag tapisenabled [$t cget -chain-position]]} {
@@ -213,9 +226,11 @@
 		$t invoke-event reset-deassert-post
 	}
 
-	# Pass 1 - Now try to halt.
+	# Pass 1 - Now wait for any halt (requested as part of reset
+	# assert/deassert) to happen.  Ideally it takes effect without
+	# first executing any instructions.
 	if { $halt } {
-		foreach t [target names] {
+		foreach t $targets {
 			if {[jtag tapisenabled [$t cget -chain-position]] == 0} {
 				continue
 			}
@@ -239,7 +254,7 @@
 
 	#Pass 2 - if needed "init"
 	if { 0 == [string compare init $MODE] } {
-		foreach t [target names] {
+		foreach t $targets {
 			if {[jtag tapisenabled [$t cget -chain-position]] == 0} {
 				continue
 			}
@@ -252,7 +267,7 @@
 		}
 	}
 
-	foreach t [ target names ] {
+	foreach t $targets {
 		$t invoke-event reset-end
 	}
 }



From oharboe at mail.berlios.de  Fri Sep 18 09:09:48 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 18 Sep 2009 09:09:48 +0200
Subject: [Openocd-svn] r2727 - trunk/src/jtag/zy1000
Message-ID: <200909180709.n8I79mqr017531@sheep.berlios.de>

Author: oharboe
Date: 2009-09-18 09:09:44 +0200 (Fri, 18 Sep 2009)
New Revision: 2727

Modified:
   trunk/src/jtag/zy1000/zy1000.c
Log:
remove unused externs

Modified: trunk/src/jtag/zy1000/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000/zy1000.c	2009-09-18 00:11:51 UTC (rev 2726)
+++ trunk/src/jtag/zy1000/zy1000.c	2009-09-18 07:09:44 UTC (rev 2727)
@@ -657,9 +657,6 @@
 
 
 
-extern int jtag_nsrst_delay;
-extern int jtag_ntrst_delay;
-
 int interface_jtag_add_reset(int req_trst, int req_srst)
 {
 	zy1000_reset(req_trst, req_srst);



From mlu at mail.berlios.de  Fri Sep 18 17:11:54 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Fri, 18 Sep 2009 17:11:54 +0200
Subject: [Openocd-svn] r2728 - in trunk: src/target tcl/target
Message-ID: <200909181511.n8IFBskW010539@sheep.berlios.de>

Author: mlu
Date: 2009-09-18 17:11:46 +0200 (Fri, 18 Sep 2009)
New Revision: 2728

Modified:
   trunk/src/target/cortex_a8.c
   trunk/tcl/target/omap3530.cfg
Log:
Move Cortex A8 debug access initialisation from omap3530.cfg to cortex_a8.c

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-18 07:09:44 UTC (rev 2727)
+++ trunk/src/target/cortex_a8.c	2009-09-18 15:11:46 UTC (rev 2728)
@@ -120,34 +120,27 @@
  */
 int cortex_a8_init_debug_access(target_t *target)
 {
-#if 0
-# Unlocking the debug registers for modification
-mww 0x54011FB0 0xC5ACCE55 4
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
 
-# Clear Sticky Power Down status Bit to enable access to
-# the registers in the Core Power Domain
-mdw 0x54011314
-# Check that it is cleared
-mdw 0x54011314
-# Now we can read Core Debug Registers at offset 0x080
-mdw 0x54011080 4
-# We can also read RAM.
-mdw 0x80000000 32
+	int retval;
+	uint32_t dummy;
 
-mdw 0x5401d030
-mdw 0x54011FB8
+	LOG_DEBUG(" ");
 
-# Set DBGEN line for hardware debug (OMAP35xx)
-mww 0x5401d030 0x00002000
-
-#Check AUTHSTATUS
-mdw 0x54011FB8
-
-# Instr enable
-mww 0x54011088 0x2000
-mdw 0x54011080 4
-#endif
-	return ERROR_OK;
+	/* Unlocking the debug registers for modification */
+	/* The debugport might be uninitialised so try twice */
+	retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	if (retval != ERROR_OK)
+		mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	/* Clear Sticky Power Down status Bit in PRSR to enable access to
+	   the registers in the Core Power Domain */
+	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_PRSR, &dummy);
+	/* Enabling of instruction execution in debug mode is done in debug_entry code */ 
+	
+	return retval;
 }
 
 int cortex_a8_exec_opcode(target_t *target, uint32_t opcode)
@@ -1441,6 +1434,9 @@
 	LOG_DEBUG("Configured %i hw breakpoint pairs and %i hw watchpoint pairs",
 			cortex_a8->brp_num , cortex_a8->wrp_num);
 
+	/* Configure core debug access */
+	cortex_a8_init_debug_access(target);
+	
 	target->type->examined = 1;
 
 	return retval;
@@ -1559,6 +1555,17 @@
 }
 
 
+static int cortex_a8_handle_dbginit_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	target_t *target = get_current_target(cmd_ctx);
+
+	cortex_a8_init_debug_access(target);
+
+	return ERROR_OK;
+}
+
+
 int cortex_a8_register_commands(struct command_context_s *cmd_ctx)
 {
 	command_t *cortex_a8_cmd;
@@ -1575,5 +1582,9 @@
 			cortex_a8_handle_cache_info_command, COMMAND_EXEC,
 			"display information about target caches");
 
+	register_command(cmd_ctx, cortex_a8_cmd, "dbginit",
+			cortex_a8_handle_dbginit_command, COMMAND_EXEC,
+			"Initialize core debug");
+
 	return retval;
 }

Modified: trunk/tcl/target/omap3530.cfg
===================================================================
--- trunk/tcl/target/omap3530.cfg	2009-09-18 07:09:44 UTC (rev 2727)
+++ trunk/tcl/target/omap3530.cfg	2009-09-18 15:11:46 UTC (rev 2728)
@@ -47,24 +47,9 @@
 
      jtag tapenable omap3530.dap
      targets
-     # sleep 1000
-     # dap apsel 1
-     # sleep 1000
-     # dap apsel 1
-     # dap info 1
-
-     # 0xd401.0000 - ETM
-     # 0xd401.1000 - Cortex-A8
-     # 0xd401.9000 - TPIU (traceport)
-     # 0xd401.b000 - ETB
-     # 0xd401.d000 - DAPCTL
-
-     omap3.cpu mww 0x54011FB0 0xC5ACCE55
-
-     omap3.cpu mdw 0x54011314
-     omap3.cpu mdw 0x54011314
-     # omap3.cpu mdw 0x54011080
-
+     # General Cortex A8 debug initialisation
+     cortex_a8 dbginit
+     # Enable DBGU singal for OMAP353x
      omap3.cpu mww 0x5401d030 0x00002000
      poll on
 }



From dbrownell at mail.berlios.de  Sat Sep 19 08:42:59 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sat, 19 Sep 2009 08:42:59 +0200
Subject: [Openocd-svn] r2729 - trunk/doc
Message-ID: <200909190642.n8J6gxDO015231@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-19 08:42:50 +0200 (Sat, 19 Sep 2009)
New Revision: 2729

Modified:
   trunk/doc/openocd.texi
Log:
Minor tweaks to description of JTAG adapter/dongle issues.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-18 15:11:46 UTC (rev 2728)
+++ trunk/doc/openocd.texi	2009-09-19 06:42:50 UTC (rev 2729)
@@ -250,12 +250,16 @@
 
 @section Choosing a Dongle
 
-There are three things you should keep in mind when choosing a dongle. 
+There are several things you should keep in mind when choosing a dongle.
 
 @enumerate 
- at item @b{Voltage} What voltage is your target? 1.8, 2.8, 3.3, or 5V? Does your dongle support it?
- at item @b{Connection} Printer Ports - Does your computer have one?
- at item @b{Connection} Is that long printer bit-bang cable practical? 
+ at item @b{Voltage} What voltage is your target - 1.8, 2.8, 3.3, or 5V?
+Does your dongle support it?  You might need a level converter.
+ at item @b{Pinout} What pinout does your target board use?
+Does your dongle support it?  You may be able to use jumper
+wires, or an "octopus" connector, to convert pinouts.
+ at item @b{Connection} Does your computer have the USB, printer, or
+Ethernet port needed?
 @item @b{RTCK} Do you require RTCK? Also known as ``adaptive clocking'' 
 @end enumerate
 
@@ -356,6 +360,10 @@
 and the MacGraigor Wiggler. There are many clones and variations of
 these on the market.
 
+Note that parallel ports are becoming much less common, so if you
+have the choice you should probably avoid these adapters in favor
+of USB-based ones.
+
 @itemize @bullet
 
 @item @b{Wiggler} - There are many clones of this.



From dbrownell at mail.berlios.de  Sat Sep 19 08:49:41 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sat, 19 Sep 2009 08:49:41 +0200
Subject: [Openocd-svn] r2730 - in trunk/src: jtag target
Message-ID: <200909190649.n8J6nfUt016185@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-19 08:49:40 +0200 (Sat, 19 Sep 2009)
New Revision: 2730

Modified:
   trunk/src/jtag/core.c
   trunk/src/target/target.c
Log:
Minor behavior fixes for the two JTAG reset events (C/internal,
and Tcl/external):

 - Reorder so *both* paths (TCK/TMS or TRST) can enable TAPs with
   ICEpick ... first C code flags TAPs that got disabled, then call
   any Tcl code that might want to re-enable them.

 - Always call the C/internal handlers when JTAG operations can be
   issued; previously that wasn't done when TRST was used. 

Plus some small cleanups (whitespace, strings, better messaging
during debug and on some errors) to reset-related code.


Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-19 06:42:50 UTC (rev 2729)
+++ trunk/src/jtag/core.c	2009-09-19 06:49:40 UTC (rev 2730)
@@ -446,7 +446,7 @@
 		tap_state_t state)
 {
 	assert(state != TAP_RESET);
-	
+
 	jtag_prelude(state);
 
 	int retval;
@@ -458,7 +458,7 @@
 		tap_state_t state)
 {
 	assert(state != TAP_RESET);
-	
+
 	jtag_prelude(state);
 
 	int retval;
@@ -471,7 +471,6 @@
 		tap_state_t end_state)
 {
 	assert(end_state != TAP_RESET);
-	
 	assert(end_state != TAP_INVALID);
 
 	cmd_queue_cur_state = end_state;
@@ -486,9 +485,9 @@
 	jtag_prelude(TAP_RESET);
 	jtag_set_error(interface_jtag_add_tlr());
 
-	jtag_notify_reset();
-
+	/* NOTE: order here matches TRST path in jtag_add_reset() */
 	jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
+	jtag_notify_reset();
 }
 
 void jtag_add_pathmove(int num_states, const tap_state_t *path)
@@ -684,21 +683,19 @@
 	} else if (jtag_trst != new_trst) {
 		jtag_trst = new_trst;
 		if (jtag_trst) {
-			/* we just asserted nTRST, so we're now in TAP_RESET;
-			 * inform possible listeners about this
-			 *
-			 * REVISIT asserting TRST is less significant than
-			 * being in TAP_RESET ... both entries (TRST, TLR)
-			 * should trigger a callback.
-			 */
 			LOG_DEBUG("TRST line asserted");
 			tap_set_state(TAP_RESET);
-			jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
 		} else {
 			LOG_DEBUG("TRST line released");
 			if (jtag_ntrst_delay)
 				jtag_add_sleep(jtag_ntrst_delay * 1000);
 
+			/* We just asserted nTRST, so we're now in TAP_RESET.
+			 * Inform possible listeners about this, now that
+			 * JTAG instructions and data can be shifted.  This
+			 * sequence must match jtag_add_tlr().
+			 */
+			jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
 			jtag_notify_reset();
 		}
 	}
@@ -823,7 +820,8 @@
 {
 	jtag_tap_t *tap = priv;
 
-	LOG_DEBUG("-");
+	LOG_DEBUG("TAP %s event %s", tap->dotted_name,
+			jtag_event_strings[event]);
 
 	if (event == JTAG_TRST_ASSERTED)
 	{

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-09-19 06:42:50 UTC (rev 2729)
+++ trunk/src/target/target.c	2009-09-19 06:49:40 UTC (rev 2730)
@@ -4028,7 +4028,8 @@
 		break;
 	case TS_CMD_RESET:
 		if (goi.argc != 2) {
-			Jim_WrongNumArgs(interp, 2, argv, "t | f|assert | deassert BOOL");
+			Jim_WrongNumArgs(interp, 2, argv,
+					"([tT]|[fF]|assert|deassert) BOOL");
 			return JIM_ERR;
 		}
 		e = Jim_GetOpt_Nvp(&goi, nvp_assert, &n);



From dbrownell at mail.berlios.de  Sat Sep 19 08:54:03 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sat, 19 Sep 2009 08:54:03 +0200
Subject: [Openocd-svn] r2731 - trunk/src/jtag
Message-ID: <200909190654.n8J6s354016543@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-19 08:54:01 +0200 (Sat, 19 Sep 2009)
New Revision: 2731

Modified:
   trunk/src/jtag/ft2232.c
Log:
Style cleanup for the updated ft2232_add_pathmove().
Indentation, whitespace, line lengths.


Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-09-19 06:49:40 UTC (rev 2730)
+++ trunk/src/jtag/ft2232.c	2009-09-19 06:54:01 UTC (rev 2731)
@@ -773,38 +773,41 @@
 	/* this loop verifies that the path is legal and logs each state in the path */
 	while (num_states)
 	{
-		unsigned char  tms_byte = 0;       /* zero this on each MPSSE batch */
+		unsigned char	tms_byte = 0;       /* zero this on each MPSSE batch */
+		int		bit_count = 0;
+		int		num_states_batch = num_states > 7 ? 7 : num_states;
 
-		int bit_count = 0;
-
-		int num_states_batch = num_states > 7 ? 7 : num_states;
-
 		/* command "Clock Data to TMS/CS Pin (no Read)" */
 		buffer_write(0x4b);
 
 		/* number of states remaining */
 		buffer_write(num_states_batch - 1);
 
-		while (num_states_batch--)
-		{
-		  if (tap_state_transition(tap_get_state(), false) == path[state_count])
+		while (num_states_batch--) {
+			/* either TMS=0 or TMS=1 must work ... */
+			if (tap_state_transition(tap_get_state(), false)
+						== path[state_count])
 				buf_set_u32(&tms_byte, bit_count++, 1, 0x0);
-		  else if (tap_state_transition(tap_get_state(), true) == path[state_count])
+			else if (tap_state_transition(tap_get_state(), true)
+						== path[state_count])
 				buf_set_u32(&tms_byte, bit_count++, 1, 0x1);
-			else
-			{
-				LOG_ERROR( "BUG: %s -> %s isn't a valid TAP transition", tap_state_name(
-								 tap_get_state() ), tap_state_name(path[state_count]) );
+
+			/* ... or else the caller goofed BADLY */
+			else {
+				LOG_ERROR("BUG: %s -> %s isn't a valid "
+						"TAP state transition",
+					tap_state_name(tap_get_state()),
+					tap_state_name(path[state_count]));
 				exit(-1);
 			}
 
-		  tap_set_state(path[state_count]);
+			tap_set_state(path[state_count]);
 			state_count++;
 			num_states--;
 		}
 
 		buffer_write(tms_byte);
-	}	
+	}
 	tap_set_end_state(tap_get_state());
 }
 



From mlu at mail.berlios.de  Sat Sep 19 16:47:56 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Sat, 19 Sep 2009 16:47:56 +0200
Subject: [Openocd-svn] r2732 - trunk/tcl/target
Message-ID: <200909191447.n8JEluED006744@sheep.berlios.de>

Author: mlu
Date: 2009-09-19 16:47:53 +0200 (Sat, 19 Sep 2009)
New Revision: 2732

Modified:
   trunk/tcl/target/omap3530.cfg
Log:
Reduced sleep time after reset 

Modified: trunk/tcl/target/omap3530.cfg
===================================================================
--- trunk/tcl/target/omap3530.cfg	2009-09-19 06:54:01 UTC (rev 2731)
+++ trunk/tcl/target/omap3530.cfg	2009-09-19 14:47:53 UTC (rev 2732)
@@ -43,7 +43,7 @@
 proc omap3_dbginit { } {
      poll off
      reset
-     sleep 500
+     sleep 100
 
      jtag tapenable omap3530.dap
      targets
@@ -53,3 +53,4 @@
      omap3.cpu mww 0x5401d030 0x00002000
      poll on
 }
+



From mlu at mail.berlios.de  Sat Sep 19 16:50:20 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Sat, 19 Sep 2009 16:50:20 +0200
Subject: [Openocd-svn] r2733 - trunk/src/target
Message-ID: <200909191450.n8JEoK4Y007048@sheep.berlios.de>

Author: mlu
Date: 2009-09-19 16:50:18 +0200 (Sat, 19 Sep 2009)
New Revision: 2733

Modified:
   trunk/src/target/cortex_a8.c
Log:
Avoid cache invalidation when writing to hardware debug registers

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-19 14:47:53 UTC (rev 2732)
+++ trunk/src/target/cortex_a8.c	2009-09-19 14:50:18 UTC (rev 2733)
@@ -332,6 +332,21 @@
 	return retval;
 }
 
+/* Write to memory mapped registers directly with no cache or mmu handling */
+int cortex_a8_dap_write_memap_register_u32(target_t *target, uint32_t address, uint32_t value)
+{
+	int retval;
+
+	/* get pointers to arch-specific information */
+	armv4_5_common_t *armv4_5 = target->arch_info;
+	armv7a_common_t *armv7a = armv4_5->arch_info;
+	swjdp_common_t *swjdp = &armv7a->swjdp_info;
+
+	retval = mem_ap_write_atomic_u32(swjdp, address, value);
+
+	return retval;
+}
+
 /*
  * Cortex-A8 Run control
  */
@@ -1022,10 +1037,10 @@
 		brp_list[brp_i].used = 1;
 		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
 		brp_list[brp_i].control = control;
-		target_write_u32(target, armv7a->debug_base
+		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].value);
-		target_write_u32(target, armv7a->debug_base
+		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
 		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
@@ -1088,10 +1103,10 @@
 		brp_list[brp_i].used = 0;
 		brp_list[brp_i].value = 0;
 		brp_list[brp_i].control = 0;
-		target_write_u32(target, armv7a->debug_base
+		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
-		target_write_u32(target, armv7a->debug_base
+		cortex_a8_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].value);
 	}



From mlu at mail.berlios.de  Sat Sep 19 22:38:51 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Sat, 19 Sep 2009 22:38:51 +0200
Subject: [Openocd-svn] r2734 - trunk/src/target
Message-ID: <200909192038.n8JKcpjY000383@sheep.berlios.de>

Author: mlu
Date: 2009-09-19 22:38:38 +0200 (Sat, 19 Sep 2009)
New Revision: 2734

Modified:
   trunk/src/target/cortex_a8.h
Log:
Added  CPUDBG_WCR_BASE define

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-09-19 14:50:18 UTC (rev 2733)
+++ trunk/src/target/cortex_a8.h	2009-09-19 20:38:38 UTC (rev 2734)
@@ -53,6 +53,7 @@
 #define CPUDBG_BVR_BASE	0x100
 #define CPUDBG_BCR_BASE	0x140
 #define CPUDBG_WVR_BASE	0x180
+#define CPUDBG_WCR_BASE	0x1C0
 
 #define CPUDBG_OSLAR	0x300
 #define CPUDBG_OSLSR	0x304



From dbrownell at mail.berlios.de  Sun Sep 20 09:46:30 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 20 Sep 2009 09:46:30 +0200
Subject: [Openocd-svn] r2735 - trunk/src/jtag
Message-ID: <200909200746.n8K7kUd7021427@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-20 09:46:22 +0200 (Sun, 20 Sep 2009)
New Revision: 2735

Modified:
   trunk/src/jtag/tcl.c
Log:
Minor regression bugfix for the jtag_tap_handle_event() case
for disabling TAPs.  We don't actually know how to make any
JRCs which do that yet; but when we do, this will matter.


Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-19 20:38:38 UTC (rev 2734)
+++ trunk/src/jtag/tcl.c	2009-09-20 07:46:22 UTC (rev 2735)
@@ -373,13 +373,17 @@
 					Jim_GetString(jteap->body, NULL));
 			if (Jim_EvalObj(interp, jteap->body) != JIM_OK) {
 				Jim_PrintErrorMessage(interp);
-			} else {
+			} else switch (e) {
+			case JTAG_TAP_EVENT_ENABLE:
+			case JTAG_TAP_EVENT_DISABLE:
 				/* NOTE:  we currently assume the handlers
 				 * can't fail.  That presumes later code
 				 * will be verifying the scan chains ...
 				 */
-				if (e == JTAG_TAP_EVENT_ENABLE)
-					tap->enabled = true;
+				tap->enabled = (e == JTAG_TAP_EVENT_ENABLE);
+				break;
+			default:
+				break;
 			}
 		}
 



From dbrownell at mail.berlios.de  Sun Sep 20 09:55:16 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 20 Sep 2009 09:55:16 +0200
Subject: [Openocd-svn] r2736 - in trunk/src: jtag target
Message-ID: <200909200755.n8K7tGpr022453@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-20 09:55:11 +0200 (Sun, 20 Sep 2009)
New Revision: 2736

Modified:
   trunk/src/jtag/core.c
   trunk/src/jtag/tcl.c
   trunk/src/target/target.c
Log:
Debug message updates:

 - Shrink messaging during resets, primarily by getting rid of
   "nothing happened" noise that hides *useful* information.

 - Improve: the "no IDCODE" message by identifying which tap only
   supports BYPASS; and the TAP event strings.

Related minor code updates:

 - Remove two needless tests when examining the chain:  we know
   we have a TAP, and that all TAPs have names.

 - Clean up two loops, turning "while"s into "for"s which better
   show what's actually being done.


Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-20 07:46:22 UTC (rev 2735)
+++ trunk/src/jtag/core.c	2009-09-20 07:55:11 UTC (rev 2736)
@@ -60,9 +60,9 @@
 
 static const char *jtag_event_strings[] =
 {
-	[JTAG_TRST_ASSERTED] = "JTAG controller reset (TLR or TRST)",
+	[JTAG_TRST_ASSERTED] = "TAP reset",
 	[JTAG_TAP_EVENT_ENABLE] = "TAP enabled",
-	[JTAG_TAP_EVENT_POST_RESET] = "post reset",
+	[JTAG_TAP_EVENT_POST_RESET] = "TAP post reset",
 	[JTAG_TAP_EVENT_DISABLE] = "TAP disabled",
 };
 
@@ -820,9 +820,6 @@
 {
 	jtag_tap_t *tap = priv;
 
-	LOG_DEBUG("TAP %s event %s", tap->dotted_name,
-			jtag_event_strings[event]);
-
 	if (event == JTAG_TRST_ASSERTED)
 	{
 		tap->enabled = !tap->disabled_after_reset;
@@ -943,15 +940,10 @@
 	for (ii = 0; ii < tap->expected_ids_cnt; ii++)
 	{
 		if (tap->idcode == tap->expected_ids[ii])
-			break;
+			return true;
 	}
 
 	/* If none of the expected ids matched, log an error */
-	if (ii != tap->expected_ids_cnt)
-	{
-		LOG_DEBUG("JTAG Tap/device matched");
-		return true;
-	}
 	jtag_examine_chain_display(LOG_LVL_ERROR, "got",
 			tap->dotted_name, tap->idcode);
 	for (ii = 0; ii < tap->expected_ids_cnt; ii++)
@@ -994,7 +986,8 @@
 		if ((idcode & 1) == 0)
 		{
 			/* LSB must not be 0, this indicates a device in bypass */
-			LOG_WARNING("Tap/Device does not have IDCODE");
+			LOG_WARNING("TAP %s does not have IDCODE",
+					tap->dotted_name);
 			idcode = 0;
 			tap->hasidcode = false;
 
@@ -1017,15 +1010,11 @@
 			}
 
 			jtag_examine_chain_display(LOG_LVL_INFO, "tap/device found",
-					tap ? tap->dotted_name : "(not-named)",
-					idcode);
+					tap->dotted_name, idcode);
 
 			bit_count += 32;
 		}
 		device_count++;
-		if (!tap)
-			continue;
-
 		tap->idcode = idcode;
 
 		// ensure the TAP ID does matches what was expected

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-20 07:46:22 UTC (rev 2735)
+++ trunk/src/jtag/tcl.c	2009-09-20 07:55:11 UTC (rev 2736)
@@ -358,14 +358,9 @@
 static void jtag_tap_handle_event(jtag_tap_t *tap, enum jtag_event e)
 {
 	jtag_tap_event_action_t * jteap;
-	int done;
 
-	jteap = tap->event_action;
-
-	done = 0;
-	while (jteap) {
+	for (jteap = tap->event_action; jteap != NULL; jteap = jteap->next) {
 		if (jteap->event == e) {
-			done = 1;
 			LOG_DEBUG("JTAG tap: %s event: %d (%s) action: %s\n",
 					tap->dotted_name,
 					e,
@@ -386,15 +381,7 @@
 				break;
 			}
 		}
-
-		jteap = jteap->next;
 	}
-
-	if (!done) {
-		LOG_DEBUG("event %d %s - no action",
-				e,
-				Jim_Nvp_value2name_simple(nvp_jtag_tap_event, e)->name);
-	}
 }
 
 

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-09-20 07:46:22 UTC (rev 2735)
+++ trunk/src/target/target.c	2009-09-20 07:55:11 UTC (rev 2736)
@@ -3409,14 +3409,9 @@
 void target_handle_event(target_t *target, enum target_event e)
 {
 	target_event_action_t *teap;
-	int done;
 
-	teap = target->event_action;
-
-	done = 0;
-	while (teap) {
+	for (teap = target->event_action; teap != NULL; teap = teap->next) {
 		if (teap->event == e) {
-			done = 1;
 			LOG_DEBUG("target: (%d) %s (%s) event: %d (%s) action: %s",
 					   target->target_number,
 					   target->cmd_name,
@@ -3429,13 +3424,7 @@
 				Jim_PrintErrorMessage(interp);
 			}
 		}
-		teap = teap->next;
 	}
-	if (!done) {
-		LOG_DEBUG("event: %d %s - no action",
-				   e,
-				   Jim_Nvp_value2name_simple(nvp_target_event, e)->name);
-	}
 }
 
 enum target_cfg_param {



From dbrownell at mail.berlios.de  Sun Sep 20 23:17:10 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 20 Sep 2009 23:17:10 +0200
Subject: [Openocd-svn] r2737 - trunk/doc
Message-ID: <200909202117.n8KLHAKp029409@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-20 23:17:08 +0200 (Sun, 20 Sep 2009)
New Revision: 2737

Modified:
   trunk/doc/openocd.texi
Log:
Update the User's Guide to cover the scan chain verification step
done on exit from the config stage, how JTAG clocking issues can
trigger errors there, and how to avoid such problems.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-20 07:55:11 UTC (rev 2736)
+++ trunk/doc/openocd.texi	2009-09-20 21:17:08 UTC (rev 2737)
@@ -486,17 +486,29 @@
 --pipe       | -p       use pipes when talking to gdb
 @end verbatim
 
-By default OpenOCD reads the file configuration file ``openocd.cfg''
+By default OpenOCD reads the file configuration file @file{openocd.cfg}
 in the current directory.  To specify a different (or multiple)
 configuration file, you can use the ``-f'' option. For example:
 
 @example
-  openocd -f config1.cfg -f config2.cfg -f config3.cfg
+openocd -f config1.cfg -f config2.cfg -f config3.cfg
 @end example
 
-Once started, OpenOCD runs as a daemon, waiting for connections from
-clients (Telnet, GDB, Other).
+OpenOCD starts by processing the configuration commands provided
+on the command line or in @file{openocd.cfg}.
+ at xref{Configuration Stage}.
+At the end of the configuration stage it verifies the JTAG scan
+chain defined using those commands; your configuration should
+ensure that this always succeeds.
+Normally, OpenOCD then starts running as a daemon.
+Alternatively, commands may be used to terminate the configuration
+stage early, perform work (such as updating some flash memory),
+and then shut down without acting as a daemon.
 
+Once OpenOCD starts running as a daemon, it waits for connections from
+clients (Telnet, GDB, Other) and processes the commands issued through
+those channels.
+
 If you are having problems, you can enable internal debug messages via
 the ``-d'' option.
 
@@ -1061,8 +1073,16 @@
 @subsection JTAG Clock Rate
 
 Before your @code{reset-init} handler has set up
-the PLLs and clocking, you may need to use
-a low JTAG clock rate; then you'd increase it later.
+the PLLs and clocking, you may need to run with
+a low JTAG clock rate.
+ at xref{JTAG Speed}.
+Then you'd increase that rate after your handler has
+made it possible to use the faster JTAG clock.
+When the initial low speed is board-specific, for example
+because it depends on a board-specific oscillator speed, then
+you should probably set it up in the board config file;
+if it's target-specific, it belongs in the target config file.
+
 For most ARM-based processors the fastest JTAG clock at footnote{A FAQ
 @uref{http://www.arm.com/support/faqdev/4170.html} gives details.}
 is one sixth of the CPU clock; or one eighth for ARM11 cores.
@@ -1252,6 +1272,24 @@
 @code{reset-deassert-post} event handler that writes a chip
 register to report that JTAG debugging is being done.
 
+JTAG clocking constraints often change during reset, and in
+some cases target config files (rather than board config files)
+are the right places to handle some of those issues.
+For example, immediately after reset most chips run using a
+slower clock than they will use later.
+That means that after reset (and potentially, as OpenOCD
+first starts up) they must use a slower JTAG clock rate
+than they will use later.
+ at xref{JTAG Speed}.
+
+ at quotation Important
+When you are debugging code that runs right after chip
+reset, getting these issues right is critical.
+In particular, if you see intermittent failures when
+OpenOCD verifies the scan chain after reset,
+look at how you are setting up JTAG clocking.
+ at end quotation
+
 @subsection ARM Core Specific Hacks
 
 If the chip has a DCC, enable it. If the chip is an ARM9 with some
@@ -1298,6 +1336,7 @@
 used to specify what TCP/IP ports are used, and how GDB should be
 supported.
 
+ at anchor{Configuration Stage}
 @section Configuration Stage
 @cindex configuration stage
 @cindex config command
@@ -1318,6 +1357,18 @@
 After it leaves this stage, configuration commands may no
 longer be issued.
 
+The first thing OpenOCD does after leaving the configuration
+stage is to verify that it can talk to the scan chain
+(list of TAPs) which has been configured.
+It will warn if it doesn't find TAPs it expects to find,
+or finds TAPs that aren't supposed to be there.
+You should see no errors at this point.
+If you see errors, resolve them by correcting the
+commands you used to configure the server.
+Common errors include using an initial JTAG speed that's too
+fast, and not providing the right IDCODE values for the TAPs
+on the scan chain.
+
 @deffn {Config Command} init
 This command terminates the configuration stage and
 enters the normal command mode. This can be useful to add commands to
@@ -1787,10 +1838,29 @@
 oscillators used, the chip, the board design, and sometimes
 power management software that may be active.
 
-The speed used during reset can be adjusted using pre_reset
-and post_reset event handlers.
+The speed used during reset, and the scan chain verification which
+follows reset, can be adjusted using a @code{reset-start}
+target event handler.
+It can then be reconfigured to a faster speed by a
+ at code{reset-init} target event handler after it reprograms those
+CPU clocks, or manually (if something else, such as a boot loader,
+sets up those clocks).
 @xref{Target Events}.
+When the initial low JTAG speed is a chip characteristic, perhaps
+because of a required oscillator speed, provide such a handler
+in the target config file.
+When that speed is a function of a board-specific characteristic
+such as which speed oscillator is used, it belongs in the board
+config file instead.
+In both cases it's safest to also set the initial JTAG clock rate
+to that same slow speed, so that OpenOCD never starts up using a
+clock speed that's faster than the scan chain can support.
 
+ at example
+jtag_rclk 3000
+$_TARGET.cpu configure -event reset-start @{ jtag_rclk 3000 @}
+ at end example
+
 If your system supports adaptive clocking (RTCK), configuring
 JTAG to use that is probably the most robust approach.
 However, it introduces delays to synchronize clocks; so it
@@ -2892,20 +2962,16 @@
 @item @b{reset-assert-pre}
 @* Issued as part of @command{reset} processing
 after SRST and/or TRST were activated and deactivated,
-but before reset is asserted on the tap.
+but before SRST alone is re-asserted on the tap.
 @item @b{reset-assert-post}
 @* Issued as part of @command{reset} processing
-when reset is asserted on the tap.
+when SRST is asserted on the tap.
 @item @b{reset-deassert-pre}
 @* Issued as part of @command{reset} processing
-when reset is about to be released on the tap.
-
-For some chips, this may be a good place to make sure
-the JTAG clock is slow enough to work before the PLL
-has been set up to allow faster JTAG speeds.
+when SRST is about to be released on the tap.
 @item @b{reset-deassert-post}
 @* Issued as part of @command{reset} processing
-when reset has been released on the tap.
+when SRST has been released on the tap.
 @item @b{reset-end}
 @* Issued as the final step in @command{reset} processing.
 @ignore
@@ -2921,9 +2987,14 @@
 This is where you would configure PLLs and clocking, set up DRAM so
 you can download programs that don't fit in on-chip SRAM, set up pin
 multiplexing, and so on.
+(You may be able to switch to a fast JTAG clock rate here, after
+the target clocks are fully set up.)
 @item @b{reset-start}
 @* Issued as part of @command{reset} processing
 before either SRST or TRST are activated.
+
+This is the most robust place to switch to a low JTAG clock rate, if
+SRST disables PLLs needed to use a fast clock.
 @ignore
 @item @b{reset-wait-pos}
 @* Currently not used



From dbrownell at mail.berlios.de  Mon Sep 21 01:54:14 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 21 Sep 2009 01:54:14 +0200
Subject: [Openocd-svn] r2738 - trunk/src/flash
Message-ID: <200909202354.n8KNsEj9025098@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-21 01:54:13 +0200 (Mon, 21 Sep 2009)
New Revision: 2738

Modified:
   trunk/src/flash/stm32x.c
Log:
Enhancement: stm32 flash protection error message

This patch modifies an error message which, in its original state,
I find somewhat unhelpful. So a small hint was added.

Signed-off-by: Johnny Halfmoon <jhalfmoon at milksnot.com>


Modified: trunk/src/flash/stm32x.c
===================================================================
--- trunk/src/flash/stm32x.c	2009-09-20 21:17:08 UTC (rev 2737)
+++ trunk/src/flash/stm32x.c	2009-09-20 23:54:13 UTC (rev 2738)
@@ -410,7 +410,7 @@
 
 	if ((first && (first % stm32x_info->ppage_size)) || ((last + 1) && (last + 1) % stm32x_info->ppage_size))
 	{
-		LOG_WARNING("sector start/end incorrect - stm32 has %dK sector protection", stm32x_info->ppage_size);
+		LOG_WARNING("Error: start and end sectors must be on a %d sector boundary", stm32x_info->ppage_size);
 		return ERROR_FLASH_SECTOR_INVALID;
 	}
 



From dbrownell at mail.berlios.de  Mon Sep 21 02:04:36 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 21 Sep 2009 02:04:36 +0200
Subject: [Openocd-svn] r2739 - trunk/src/jtag
Message-ID: <200909210004.n8L04aKk025985@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-21 02:04:35 +0200 (Mon, 21 Sep 2009)
New Revision: 2739

Modified:
   trunk/src/jtag/core.c
Log:
Update the jtag-examine_chain() logic to verify that there's no
garbage after the expected data (from the TAPs' BYPASS or IDCODE
registers).

NOTE that there was previously some code that looked like it was
trying to do this ... which didn't work, because it was looping
over the list of expected TAPs, and never checked *after* that
list completed!  That could hide some *nasty* reset issues...

Also replace a now-obsolete scanchain length test with one that
behaves correctly; and update reporting of unexpected IDCODEs.


Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-20 23:54:13 UTC (rev 2738)
+++ trunk/src/jtag/core.c	2009-09-21 00:04:35 UTC (rev 2739)
@@ -837,13 +837,18 @@
 	alive_sleep(us/1000);
 }
 
-/// maximum number of JTAG devices expected in the chain
+/* Maximum number of enabled JTAG devices we expect in the scan chain,
+ * plus one (to detect garbage at the end).  Devices that don't support
+ * IDCODE take up fewer bits, possibly allowing a few more devices.
+ */
 #define JTAG_MAX_CHAIN_SIZE 20
 
 #define EXTRACT_MFG(X)  (((X) & 0xffe) >> 1)
 #define EXTRACT_PART(X) (((X) & 0xffff000) >> 12)
 #define EXTRACT_VER(X)  (((X) & 0xf0000000) >> 28)
 
+#define END_OF_CHAIN_FLAG	0x000000ff
+
 static int jtag_examine_chain_execute(uint8_t *idcode_buffer, unsigned num_idcode)
 {
 	scan_field_t field = {
@@ -855,7 +860,7 @@
 
 	// initialize to the end of chain ID value
 	for (unsigned i = 0; i < JTAG_MAX_CHAIN_SIZE; i++)
-		buf_set_u32(idcode_buffer, i * 32, 32, 0x000000FF);
+		buf_set_u32(idcode_buffer, i * 32, 32, END_OF_CHAIN_FLAG);
 
 	jtag_add_plain_dr_scan(1, &field, TAP_DRPAUSE);
 	jtag_add_tlr();
@@ -899,7 +904,12 @@
 
 static bool jtag_idcode_is_final(uint32_t idcode)
 {
-		return idcode == 0x000000FF || idcode == 0xFFFFFFFF;
+	/*
+	 * Some devices, such as AVR8, will output all 1's instead
+	 * of TDI input value at end of chain.  Allow those values
+	 * instead of failing.
+	 */
+	return idcode == END_OF_CHAIN_FLAG || idcode == 0xFFFFFFFF;
 }
 
 /**
@@ -907,8 +917,9 @@
  * all as expected, but a single JTAG device requires only 64 bits to be
  * read back correctly.  This can help identify and diagnose problems
  * with the JTAG chain earlier, gives more helpful/explicit error messages.
+ * Returns TRUE iff garbage was found.
  */
-static void jtag_examine_chain_end(uint8_t *idcodes, unsigned count, unsigned max)
+static bool jtag_examine_chain_end(uint8_t *idcodes, unsigned count, unsigned max)
 {
 	bool triggered = false;
 	for (; count < max - 31; count += 32)
@@ -921,19 +932,14 @@
 					count, (unsigned int)idcode);
 		triggered = true;
 	}
+	return triggered;
 }
 
 static bool jtag_examine_chain_match_tap(const struct jtag_tap_s *tap)
 {
-	if (0 == tap->expected_ids_cnt)
-	{
-		/// @todo Enable LOG_INFO to ask for reports about unknown TAP IDs.
-#if 0
-		LOG_INFO("Uknown JTAG TAP ID: 0x%08x", tap->idcode)
-		LOG_INFO("Please report the chip name and reported ID code to the openocd project");
-#endif
+	/* ignore expected BYPASS codes; warn otherwise */
+	if (0 == tap->expected_ids_cnt && !tap->idcode)
 		return true;
-	}
 
 	/* Loop over the expected identification codes and test for a match */
 	uint8_t ii;
@@ -944,7 +950,7 @@
 	}
 
 	/* If none of the expected ids matched, log an error */
-	jtag_examine_chain_display(LOG_LVL_ERROR, "got",
+	jtag_examine_chain_display(LOG_LVL_ERROR, "UNEXPECTED",
 			tap->dotted_name, tap->idcode);
 	for (ii = 0; ii < tap->expected_ids_cnt; ii++)
 	{
@@ -962,10 +968,12 @@
 static int jtag_examine_chain(void)
 {
 	uint8_t idcode_buffer[JTAG_MAX_CHAIN_SIZE * 4];
-	unsigned device_count = 0;
+	unsigned bit_count;
 
+	/* DR scan to collect BYPASS or IDCODE register contents.
+	 * Then make sure the scan data has both ones and zeroes.
+	 */
 	jtag_examine_chain_execute(idcode_buffer, JTAG_MAX_CHAIN_SIZE);
-
 	if (!jtag_examine_chain_check(idcode_buffer, JTAG_MAX_CHAIN_SIZE))
 		return ERROR_JTAG_INIT_FAILED;
 
@@ -977,7 +985,7 @@
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
-	for (unsigned bit_count = 0;
+	for (bit_count = 0;
 			tap && bit_count < (JTAG_MAX_CHAIN_SIZE * 32) - 31;
 			tap = jtag_tap_next_enabled(tap))
 	{
@@ -995,26 +1003,13 @@
 		}
 		else
 		{
+			/* Friendly devices support IDCODE */
 			tap->hasidcode = true;
-
-			/*
-			 * End of chain (invalid manufacturer ID) some devices, such
-			 * as AVR will output all 1's instead of TDI input value at
-			 * end of chain.
-			 */
-			if (jtag_idcode_is_final(idcode))
-			{
-				jtag_examine_chain_end(idcode_buffer,
-						bit_count + 32, JTAG_MAX_CHAIN_SIZE * 32);
-				break;
-			}
-
 			jtag_examine_chain_display(LOG_LVL_INFO, "tap/device found",
 					tap->dotted_name, idcode);
 
 			bit_count += 32;
 		}
-		device_count++;
 		tap->idcode = idcode;
 
 		// ensure the TAP ID does matches what was expected
@@ -1022,17 +1017,23 @@
 			return ERROR_JTAG_INIT_FAILED;
 	}
 
-	/* see if number of discovered devices matches configuration */
-	if (device_count != jtag_tap_count_enabled())
-	{
-		LOG_ERROR("number of discovered devices in JTAG chain (%i) "
-				"does not match (enabled) configuration (%i), total taps: %d",
-				device_count, jtag_tap_count_enabled(), jtag_tap_count());
-		LOG_ERROR("check the config file and ensure proper JTAG communication"
-				" (connections, speed, ...)");
+	/* Fail if too many TAPs were enabled for us to verify them all. */
+	if (tap) {
+		LOG_ERROR("Too many TAPs enabled; '%s' ignored.",
+				tap->dotted_name);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
+	/* After those IDCODE or BYPASS register values should be
+	 * only the data we fed into the scan chain.
+	 */
+	if (jtag_examine_chain_end(idcode_buffer, bit_count,
+			8 * sizeof(idcode_buffer))) {
+		LOG_ERROR("double-check your JTAG setup (interface, "
+				"speed, TAPs, ...)");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
 	return ERROR_OK;
 }
 



From dbrownell at mail.berlios.de  Mon Sep 21 02:38:17 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 21 Sep 2009 02:38:17 +0200
Subject: [Openocd-svn] r2740 - trunk/tcl/target
Message-ID: <200909210038.n8L0cHYr031075@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-21 02:37:58 +0200 (Mon, 21 Sep 2009)
New Revision: 2740

Modified:
   trunk/tcl/target/ti_dm355.cfg
   trunk/tcl/target/ti_dm365.cfg
   trunk/tcl/target/ti_dm6446.cfg
Log:
Ensure that DaVinci chips can't start with a too-fast JTAG clock.
It can be sped up later, once it's known the PLLs are active.

Note that modern tools from TI all use adaptive clocking; and
that if that's done with OpenOCD, "too fast" is also a non-issue.


Modified: trunk/tcl/target/ti_dm355.cfg
===================================================================
--- trunk/tcl/target/ti_dm355.cfg	2009-09-21 00:04:35 UTC (rev 2739)
+++ trunk/tcl/target/ti_dm355.cfg	2009-09-21 00:37:58 UTC (rev 2740)
@@ -86,6 +86,12 @@
 	-work-area-size 0x4000 \
 	-work-area-backup 0
 
+# be absolutely certain the JTAG clock will work with the worst-case
+# CLKIN = 24 MHz (best case: 36 MHz) even when no bootloader turns
+# on the PLL and starts using it.  OK to speed up after clock setup.
+jtag_rclk 1500
+$_TARGETNAME configure -event "reset-start" { jtag_rclk 1500 }
+
 arm7_9 fast_memory_access enable
 arm7_9 dcc_downloads enable
 

Modified: trunk/tcl/target/ti_dm365.cfg
===================================================================
--- trunk/tcl/target/ti_dm365.cfg	2009-09-21 00:04:35 UTC (rev 2739)
+++ trunk/tcl/target/ti_dm365.cfg	2009-09-21 00:37:58 UTC (rev 2740)
@@ -88,6 +88,12 @@
 	-work-area-size 0x4000 \
 	-work-area-backup 0
 
+# be absolutely certain the JTAG clock will work with the worst-case
+# CLKIN = 19.2 MHz (best case: 36 MHz) even when no bootloader turns
+# on the PLL and starts using it.  OK to speed up after clock setup.
+jtag_rclk 1500
+$_TARGETNAME configure -event "reset-start" { jtag_rclk 1500 }
+
 arm7_9 fast_memory_access enable
 arm7_9 dcc_downloads enable
 

Modified: trunk/tcl/target/ti_dm6446.cfg
===================================================================
--- trunk/tcl/target/ti_dm6446.cfg	2009-09-21 00:04:35 UTC (rev 2739)
+++ trunk/tcl/target/ti_dm6446.cfg	2009-09-21 00:37:58 UTC (rev 2740)
@@ -68,6 +68,12 @@
 target create $_TARGETNAME arm926ejs -chain-position $_TARGETNAME
 $_TARGETNAME configure -work-area-phys 0x0000a000 -work-area-size 0x2000
 
+# be absolutely certain the JTAG clock will work with the worst-case
+# CLKIN = 20 MHz (best case: 30 MHz) even when no bootloader turns
+# on the PLL and starts using it.  OK to speed up after clock setup.
+jtag_rclk 1500
+$_TARGETNAME configure -event "reset-start" { jtag_rclk 1500 }
+
 arm7_9 fast_memory_access enable
 arm7_9 dcc_downloads enable
 



From oharboe at mail.berlios.de  Mon Sep 21 11:25:54 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 21 Sep 2009 11:25:54 +0200
Subject: [Openocd-svn] r2741 - trunk/tcl/board
Message-ID: <200909210925.n8L9PsuS009750@sheep.berlios.de>

Author: oharboe
Date: 2009-09-21 11:25:52 +0200 (Mon, 21 Sep 2009)
New Revision: 2741

Added:
   trunk/tcl/board/csb732.cfg
Log:
Ethan Eade <ethan at evolution.com> board config script for Cogent CSB732 i.MX35 (arm1136)

Added: trunk/tcl/board/csb732.cfg
===================================================================
--- trunk/tcl/board/csb732.cfg	2009-09-21 00:37:58 UTC (rev 2740)
+++ trunk/tcl/board/csb732.cfg	2009-09-21 09:25:52 UTC (rev 2741)
@@ -0,0 +1,71 @@
+# The Cogent CSB732 board has a single i.MX35 chip
+source [find target/imx35.cfg]
+
+# Determined by trial and error
+reset_config trst_and_srst combined
+jtag_nsrst_delay 200
+jtag_ntrst_delay 200
+
+$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { csb732_init }
+
+# Bare-bones initialization of core clocks and SDRAM
+proc csb732_init { } {
+	
+	# Disable fast writing only for init
+	memwrite burst disable
+
+	# All delay loops are omitted.
+	# We assume the interpreter latency is enough.
+
+	# Allow access to all coprocessors
+	arm11 mcr imx35.cpu 15 0 15 1 0 0x2001
+
+	# Disable MMU, caches, write buffer
+	arm11 mcr imx35.cpu 15 0 1 0 0 0x78
+
+	# Grant manager access to all domains
+	arm11 mcr imx35.cpu 15 0 3 0 0 0xFFFFFFFF
+
+	# Set ARM clock to 532 MHz, AHB to 133 MHz
+	mww 0x53F80004 0x1000
+	
+	# Set core clock to 2 * 24 MHz * (11 + 1/12) = 532 MHz
+	mww 0x53F8001C 0xB2C01
+	
+	set ESDMISC 0xB8001010
+	set ESDCFG0 0xB8001004
+	set ESDCTL0 0xB8001000
+
+	# Enable DDR
+	mww $ESDMISC 0x4
+	
+	# Timing
+	mww $ESDCFG0 0x007fff3f
+
+	# CS0
+	mww $ESDCTL0 0x92120080
+
+	# Precharge all dummy write
+	mww 0x80000400 0
+
+	# Enable CS) auto-refresh
+	mww $ESDCTL0 0xA2120080
+	
+	# Refresh twice (dummy writes)
+	mww 0x80000000 0
+	mww 0x80000000 0
+
+	# Enable CS0 load mode register
+	mww $ESDCTL0 0xB2120080
+
+	# Dummy writes	
+	mwb 0x80000033 0x01
+	mwb 0x81000000 0x01
+
+	mww $ESDCTL0 0x82226080
+	mww 0x80000000 0
+
+	# Re-enable fast writing
+	memwrite burst enable
+}


Property changes on: trunk/tcl/board/csb732.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From dbrownell at mail.berlios.de  Mon Sep 21 20:40:58 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 21 Sep 2009 20:40:58 +0200
Subject: [Openocd-svn] r2742 - in trunk/src: . flash/ocl/at91sam7x helper
	jtag jtag/rlink server target target/xscale
Message-ID: <200909211840.n8LIewme019000@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-21 20:40:55 +0200 (Mon, 21 Sep 2009)
New Revision: 2742

Modified:
   trunk/src/Makefile.am
   trunk/src/flash/ocl/at91sam7x/at91sam7x_ram.ld
   trunk/src/flash/ocl/at91sam7x/crt.s
   trunk/src/flash/ocl/at91sam7x/makefile
   trunk/src/helper/Makefile.am
   trunk/src/helper/startup.tcl
   trunk/src/jtag/jlink.c
   trunk/src/jtag/rlink/call.m4
   trunk/src/server/gdb_server.c
   trunk/src/target/Makefile.am
   trunk/src/target/arm11.c
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm926ejs.c
   trunk/src/target/breakpoints.c
   trunk/src/target/cortex_a8.c
   trunk/src/target/mips_m4k.c
   trunk/src/target/target.c
   trunk/src/target/target.h
   trunk/src/target/xscale/debug_handler.S
   trunk/src/target/xscale/debug_handler.cmd
Log:
Remove annoying end-of-line whitespace from most src/*
files; omitted src/httpd


Modified: trunk/src/Makefile.am
===================================================================
--- trunk/src/Makefile.am	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/Makefile.am	2009-09-21 18:40:55 UTC (rev 2742)
@@ -9,7 +9,7 @@
 MAINFILE = main.c
 endif
 
-openocd_SOURCES = $(MAINFILE) 
+openocd_SOURCES = $(MAINFILE)
 openocd_LDADD = libopenocd.la
 
 libopenocd_la_SOURCES = openocd.c
@@ -38,7 +38,7 @@
 libopenocd_la_CPPFLAGS += $(AM_CPPFLAGS) $(CPPFLAGS)
 
 # the library search path.
-libopenocd_la_LDFLAGS = $(all_libraries) 
+libopenocd_la_LDFLAGS = $(all_libraries)
 
 if IS_MINGW
 MINGWLDADD = -lwsock32
@@ -97,6 +97,6 @@
 # assumption is: You are only rebuilding the EXE.... and everything
 # else is/was previously installed.
 #
-# use at your own risk 
+# use at your own risk
 quick: all install-binPROGRAMS
 

Modified: trunk/src/flash/ocl/at91sam7x/at91sam7x_ram.ld
===================================================================
--- trunk/src/flash/ocl/at91sam7x/at91sam7x_ram.ld	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/flash/ocl/at91sam7x/at91sam7x_ram.ld	2009-09-21 18:40:55 UTC (rev 2742)
@@ -1,30 +1,30 @@
 /****************************************************************************
 *  Copyright (c) 2006 by Michael Fischer. All rights reserved.
 *
-*  Redistribution and use in source and binary forms, with or without 
-*  modification, are permitted provided that the following conditions 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
 *  are met:
-*  
-*  1. Redistributions of source code must retain the above copyright 
+*
+*  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
-*     notice, this list of conditions and the following disclaimer in the 
+*     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
-*  3. Neither the name of the author nor the names of its contributors may 
-*     be used to endorse or promote products derived from this software 
+*  3. Neither the name of the author nor the names of its contributors may
+*     be used to endorse or promote products derived from this software
 *     without specific prior written permission.
 *
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL 
-*  THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
-*  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
-*  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
-*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
-*  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+*  THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+*  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+*  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+*  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 *
 ****************************************************************************
@@ -94,11 +94,11 @@
     *(COMMON)
     . = ALIGN(4);
     PROVIDE (__bss_end = .);
-    
+
     . = ALIGN(256);
-    
+
     PROVIDE (__stack_start = .);
-    
+
     PROVIDE (__stack_fiq_start = .);
     . += FIQ_STACK_SIZE;
     . = ALIGN(4);
@@ -124,9 +124,9 @@
     . = ALIGN(4);
     PROVIDE (__stack_svc_end = .);
     PROVIDE (__stack_end = .);
-    PROVIDE (__heap_start = .);   
+    PROVIDE (__heap_start = .);
   } > ram
-    
+
 }
 /*** EOF ***/
 

Modified: trunk/src/flash/ocl/at91sam7x/crt.s
===================================================================
--- trunk/src/flash/ocl/at91sam7x/crt.s	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/flash/ocl/at91sam7x/crt.s	2009-09-21 18:40:55 UTC (rev 2742)
@@ -1,30 +1,30 @@
 /****************************************************************************
 *  Copyright (c) 2006 by Michael Fischer. All rights reserved.
 *
-*  Redistribution and use in source and binary forms, with or without 
-*  modification, are permitted provided that the following conditions 
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
 *  are met:
-*  
-*  1. Redistributions of source code must retain the above copyright 
+*
+*  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
-*     notice, this list of conditions and the following disclaimer in the 
+*     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
-*  3. Neither the name of the author nor the names of its contributors may 
-*     be used to endorse or promote products derived from this software 
+*  3. Neither the name of the author nor the names of its contributors may
+*     be used to endorse or promote products derived from this software
 *     without specific prior written permission.
 *
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
-*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL 
-*  THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
-*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
-*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
-*  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
-*  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
-*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF 
-*  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+*  THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+*  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+*  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+*  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+*  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *  SUCH DAMAGE.
 *
 ****************************************************************************
@@ -33,14 +33,14 @@
 *
 *  18.12.06  mifi   First Version
 *                   The hardware initialization is based on the startup file
-*                   crtat91sam7x256_rom.S from NutOS 4.2.1. 
+*                   crtat91sam7x256_rom.S from NutOS 4.2.1.
 *                   Therefore partial copyright by egnite Software GmbH.
 ****************************************************************************/
 
 /*
  * Some defines for the program status registers
  */
-   ARM_MODE_USER  = 0x10      /* Normal User Mode                             */ 
+   ARM_MODE_USER  = 0x10      /* Normal User Mode                             */
    ARM_MODE_FIQ   = 0x11      /* FIQ Fast Interrupts Mode                     */
    ARM_MODE_IRQ   = 0x12      /* IRQ Standard Interrupts Mode                 */
    ARM_MODE_SVC   = 0x13      /* Supervisor Interrupts Mode                   */
@@ -48,10 +48,10 @@
    ARM_MODE_UNDEF = 0x1B      /* Undefined Instructions Mode                  */
    ARM_MODE_SYS   = 0x1F      /* System Running in Priviledged Operating Mode */
    ARM_MODE_MASK  = 0x1F
-   
+
    I_BIT          = 0x80      /* disable IRQ when I bit is set */
    F_BIT          = 0x40      /* disable IRQ when I bit is set */
-   
+
 /*
  * Register Base Address
  */
@@ -70,10 +70,10 @@
    MC_BASE          = 0xFFFFFF00
    MC_FMR_OFF       = 0x00000060
    MC_FWS_1FWS      = 0x00480100
-      
+
    .section .vectors,"ax"
    .code 32
-        
+
 /****************************************************************************/
 /*               Vector table and reset entry                               */
 /****************************************************************************/
@@ -101,7 +101,7 @@
 
    .section .init, "ax"
    .code 32
-   
+
    .global ResetHandler
    .global ExitFunction
    .extern main
@@ -116,7 +116,7 @@
    ldr   r0, =WDT_WDDIS
    str   r0, [r1, #WDT_MR_OFF]
 
-   
+
    /*
     * Enable user reset: assertion length programmed to 1ms
     */
@@ -124,7 +124,7 @@
    ldr   r1, =RSTC_MR
    str   r0, [r1, #0]
 
-   
+
    /*
     * Use 2 cycles for flash access.
     */
@@ -141,22 +141,22 @@
    str   r0, [r1, #AIC_EOICR_OFF]
    str   r0, [r1, #AIC_IDCR_OFF]
 
-    
+
    /*
     * Setup a stack for each mode
-    */    
-   msr   CPSR_c, #ARM_MODE_UNDEF | I_BIT | F_BIT   /* Undefined Instruction Mode */     
+    */
+   msr   CPSR_c, #ARM_MODE_UNDEF | I_BIT | F_BIT   /* Undefined Instruction Mode */
    ldr   sp, =__stack_und_end
-   
+
    msr   CPSR_c, #ARM_MODE_ABORT | I_BIT | F_BIT   /* Abort Mode */
    ldr   sp, =__stack_abt_end
-   
-   msr   CPSR_c, #ARM_MODE_FIQ | I_BIT | F_BIT     /* FIQ Mode */   
+
+   msr   CPSR_c, #ARM_MODE_FIQ | I_BIT | F_BIT     /* FIQ Mode */
    ldr   sp, =__stack_fiq_end
-   
-   msr   CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT     /* IRQ Mode */   
+
+   msr   CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT     /* IRQ Mode */
    ldr   sp, =__stack_irq_end
-   
+
    msr   CPSR_c, #ARM_MODE_SVC | I_BIT | F_BIT     /* Supervisor Mode */
    ldr   sp, =__stack_svc_end
 
@@ -171,35 +171,35 @@
    cmp   r1, r2
    strne r3, [r1], #+4
    bne   bss_clear_loop
-   
-   
+
+
    /*
     * Jump to main
     */
    mrs   r0, cpsr
    bic   r0, r0, #I_BIT | F_BIT     /* Enable FIQ and IRQ interrupt */
    msr   cpsr, r0
-   
+
    mov   r0, #0 /* No arguments */
    mov   r1, #0 /* No arguments */
    ldr   r2, =main
    mov   lr, pc
    bx    r2     /* And jump... */
-                       
+
 ExitFunction:
    nop
    nop
    nop
-   b ExitFunction   
-   
+   b ExitFunction
 
+
 /****************************************************************************/
 /*                         Default interrupt handler                        */
 /****************************************************************************/
 
 UndefHandler:
    b UndefHandler
-   
+
 SWIHandler:
    b SWIHandler
 
@@ -208,13 +208,13 @@
 
 DAbortHandler:
    b DAbortHandler
-   
+
 IRQHandler:
    b IRQHandler
-   
+
 FIQHandler:
    b FIQHandler
-   
+
    .weak ExitFunction
    .weak UndefHandler, PAbortHandler, DAbortHandler
    .weak IRQHandler, FIQHandler

Modified: trunk/src/flash/ocl/at91sam7x/makefile
===================================================================
--- trunk/src/flash/ocl/at91sam7x/makefile	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/flash/ocl/at91sam7x/makefile	2009-09-21 18:40:55 UTC (rev 2742)
@@ -13,19 +13,19 @@
 MCU  = arm7tdmi
 
 # List all default C defines here, like -D_DEBUG=1
-DDEFS = 
+DDEFS =
 
 # List all default ASM defines here, like -D_DEBUG=1
-DADEFS = 
+DADEFS =
 
 # List all default directories to look for include files here
-DINCDIR = 
+DINCDIR =
 
 # List the default directory to look for the libraries here
 DLIBDIR =
 
 # List all default libraries here
-DLIBS = 
+DLIBS =
 
 #
 # End of default section
@@ -42,10 +42,10 @@
 LDSCRIPT= at91sam7x_ram.ld
 
 # List all user C define here, like -D_DEBUG=1
-UDEFS = 
+UDEFS =
 
 # Define ASM defines here
-UADEFS = 
+UADEFS =
 
 # List C source files here
 SRC  = main.c dcc.c samflash.c
@@ -60,7 +60,7 @@
 ULIBDIR =
 
 # List all user libraries here
-ULIBS = 
+ULIBS =
 
 # Define optimisation level here
 OPT = -O2
@@ -122,7 +122,7 @@
 	-rm -f $(ASRC:.s=.lst)
 	-rm -fR .dep
 
-# 
+#
 # Include the dependency files, should be the last of the makefile
 #
 #-include $(shell mkdir .dep 2>/dev/null) $(wildcard .dep/*)

Modified: trunk/src/helper/Makefile.am
===================================================================
--- trunk/src/helper/Makefile.am	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/helper/Makefile.am	2009-09-21 18:40:55 UTC (rev 2742)
@@ -7,9 +7,9 @@
 noinst_LTLIBRARIES = libhelper.la
 
 if ECOSBOARD
-CONFIGFILES = 
+CONFIGFILES =
 else
-CONFIGFILES = options.c jim.c jim-eventloop.c 
+CONFIGFILES = options.c jim.c jim-eventloop.c
 endif
 
 

Modified: trunk/src/helper/startup.tcl
===================================================================
--- trunk/src/helper/startup.tcl	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/helper/startup.tcl	2009-09-21 18:40:55 UTC (rev 2742)
@@ -24,16 +24,16 @@
 
 # Show flash in human readable form
 # This is an example of a human readable form of a low level fn
-proc flash_banks {} { 
-	set i 0 	
+proc flash_banks {} {
+	set i 0
 	set result ""
 	foreach {a} [ocd_flash_banks] {
 		if {$i > 0} {
 			set result "$result\n"
 		}
 		set result [format "$result#%d: %s at 0x%08x, size 0x%08x, buswidth %d, chipwidth %d" $i $a(name) $a(base) $a(size) $a(bus_width) $a(chip_width)]
-		set i [expr $i+1]	
-	}	
+		set i [expr $i+1]
+	}
 	return $result
 }
 
@@ -56,7 +56,7 @@
 			set n 0
 			while 1 {
 				if {$n > [string length $h]} {break}
-				
+
 				set next_a [expr $n+$w]
 				if {[string length $h]>$n+$w} {
 					set xxxx [string range $h $n [expr $n+$w]]
@@ -67,8 +67,8 @@
 						set next_a [expr $lastpos+$n+1]
 					}
 				}
-				
-				
+
+
 				puts [format "%-25s %s" $cmdname [string range $h $n [expr $next_a-1]] ]
 				set cmdname ""
 				set n [expr $next_a]
@@ -144,11 +144,11 @@
 		set in_process_reset 0
 		return -code error "'reset' can not be invoked recursively"
 	}
-	
+
 	set in_process_reset 1
-	set success [expr [catch {ocd_process_reset_inner $MODE} result]==0] 
+	set success [expr [catch {ocd_process_reset_inner $MODE} result]==0]
 	set in_process_reset 0
-	
+
 	if {$success} {
 		return $result
 	} else {
@@ -239,13 +239,13 @@
 			# the JTAG tap reset signal might be hooked to a slow
 			# resistor/capacitor circuit - and it might take a while
 			# to charge
-			
+
 			# Catch, but ignore any errors.
 			catch { $t arp_waitstate halted 1000 }
-			
+
 			# Did we succeed?
 			set s [$t curstate]
-			
+
 			if { 0 != [string compare $s "halted" ] } {
 				return -error [format "TARGET: %s - Not halted" $t]
 			}
@@ -262,7 +262,7 @@
 			set err [catch "$t arp_waitstate halted 5000"]
 			# Did it halt?
 			if { $err == 0 } {
-				$t invoke-event reset-init		
+				$t invoke-event reset-init
 			}
 		}
 	}
@@ -294,13 +294,13 @@
 # A list of names of CPU and options required
 set ocd_cpu_list {
 	{
-		name IXP42x 
-		options {xscale -variant IXP42x} 
+		name IXP42x
+		options {xscale -variant IXP42x}
 		comment {IXP42x cpu}
 	}
 	{
-		name arm7 
-		options {arm7tdmi -variant arm7tdmi} 
+		name arm7
+		options {arm7tdmi -variant arm7tdmi}
 		comment {vanilla ARM7}
 	}
 }
@@ -312,7 +312,7 @@
 	global ocd_cpu_list
 	foreach a [lsort $ocd_cpu_list] {
 		if {[string length $args]==0||[string first [string toupper $name] [string toupper "$a(name)$a(options)$a(comment)"]]!=-1} {
-			lappend result $a 
+			lappend result $a
 		}
 	}
 	return $result
@@ -352,5 +352,5 @@
 	catch {
 		capture {uplevel $a}
 	} result
-	return $result 
+	return $result
 }

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/jtag/jlink.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -314,7 +314,7 @@
 		LOG_ERROR("Cannot find jlink Interface! Please check connection and permissions.");
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	/*
 	 *  The next three instructions were added after discovering a problem while using an oscilloscope.  For the V8
 	 *	SAM-ICE dongle (and likely other j-link device variants), the reset line to the target microprocessor was found to
@@ -324,7 +324,7 @@
 	 *	following a new USB session.  Keeping the processor in reset during the first read collecting version information
 	 *	seems to prevent errant "J-Link command EMU_CMD_VERSION failed" issues.
 	 */
-	
+
 	LOG_INFO("J-Link initialization started / target CPU reset initiated");
 	jlink_simple_command(EMU_CMD_HW_TRST0);
 	jlink_simple_command(EMU_CMD_HW_RESET0);
@@ -881,7 +881,7 @@
 
 	if (result->usb_handle)
 	{
-	
+
 		/* BE ***VERY CAREFUL*** ABOUT MAKING CHANGES IN THIS AREA!!!!!!!!!!!
 		 * The behavior of libusb is not completely consistent across Windows, Linux, and Mac OS X platforms.  The actions taken
 		 * in the following compiler conditionals may not agree with published documentation for libusb, but were found

Modified: trunk/src/jtag/rlink/call.m4
===================================================================
--- trunk/src/jtag/rlink/call.m4	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/jtag/rlink/call.m4	2009-09-21 18:40:55 UTC (rev 2742)
@@ -67,7 +67,7 @@
 	A.L = m4_low_nybble(`('$1`) / 2')
 	Y = A
 )')
-	
+
 m4_define(`m4_delay_loop',
 `; delay loop (m4_eval($1) cycles)'
 `m4_ifelse(m4_eval(`('$1`) < 6'), 1,
@@ -79,7 +79,7 @@
 )')
 
 m4_dnl These are utility macros for use with delays.  Specifically, there is code below which needs some predictability in code size for relative jumps to reach.  The m4_delay macro generates an extra NOP when an even delay is needed, and the m4_delay_loop macro generates an extra NOP when an odd delay is needed.  Using this for the argument to the respective macro rounds up the argument so that the extra NOP will not be generated.  There is also logic built in to cancel the rounding when the result is small enough that a loop would not be generated.
-	
+
 m4_define(`m4_delay_loop_round_up', `m4_ifelse(m4_eval($1` < 6'), 1, $1, m4_eval(`(('$1`) + 1) / 2 * 2'))')
 m4_define(`m4_delay_round_up', `m4_ifelse(m4_eval($1` < 6'), 1, $1, m4_eval(`(('$1`) / 2 * 2) + 1'))')
 
@@ -106,7 +106,7 @@
 	A.H = 0xc	; lookup table at 0x1550 + 0xc0 = 0x1610
 
 	; branch to address in lookup table
-	Y = A 
+	Y = A
 	A = <Y>
 	BRANCH
 
@@ -203,7 +203,7 @@
 ;	; Ack buffer 0 in download mode
 ;	A.L = 0x1
 ;	BUFFER_MNGT = A
-;	
+;
 ;	STATUS STOP
 
 
@@ -213,7 +213,7 @@
 
 	A = CMP01	; bits 3..0 contain the number of bytes to shift - 1
 	A.H = 0
-	Y = A		; loop counter 
+	Y = A		; loop counter
 
 	A = CMP01
 	EXCHANGE
@@ -262,7 +262,7 @@
 
 	A = CMP01	; bits 3..0 contain the number of bytes to shift - 1
 	A.H = 0
-	Y = A		; loop counter 
+	Y = A		; loop counter
 
 opcode_shift_tdo_bytes__loop:
 	SHIFT MPEG PIN0=>IN
@@ -303,7 +303,7 @@
 
 	JP sub_shift_tdio_bits
 opcode_shift_tdio_bytes__sub_return:
-	
+
 	A = CMP10	; byte loop counter
 	CP A=>X
 	CLC
@@ -323,7 +323,7 @@
 	A = CMP01	; bits 2..0 contain the number of bits to shift - 1
 	A.H = 0
 	BCLR 3		; set TMS=1 if bit 3 was set
-	CMP11 = A	; bit loop counter 
+	CMP11 = A	; bit loop counter
 
 	A.H = opcode_shift_tdio_bits__sub_return
 	A.L = opcode_shift_tdio_bits__sub_return
@@ -334,7 +334,7 @@
 	DR_CARD = A
 	JP sub_shift_tdio_bits
 opcode_shift_tdio_bits__sub_return:
-	
+
 	A = X
 ;DR_MPEG = A ; return TCK low, as str912 reset halt seems to require it
 	BRANCH
@@ -365,9 +365,9 @@
 m4_delay_loop(m4_delay_loop_round_up(SETUP_DELAY_CYCLES - 1))
 
 	BSET 2		; TCK high
-	DR_MPEG = A 
+	DR_MPEG = A
 
-	A = DR_MPEG	; set carry bit to TDO 
+	A = DR_MPEG	; set carry bit to TDO
 	CLC
 	BCLR 0
 	JP +2
@@ -431,7 +431,7 @@
 	BSET 3		; bit says whether to return TDO
 	JP +2
 	ADR_BUFFER1 -= X	; subroutine returns it, so undo that
-	
+
 	A = X
 	DR_MPEG = A ; return TCK low, as str912 reset halt seems to require it
 	BRANCH
@@ -443,7 +443,7 @@
 
 	A = CMP01	; bits 3..0 contain the number of bits to shift - 1 (only 1-8 bits is valid... no checking, just improper operation)
 	A.H = 0
-	CMP11 = A	; bit loop counter 
+	CMP11 = A	; bit loop counter
 
 	A = DATA_BUFFER0	; get byte from input buffer
 	ADR_BUFFER0 += X
@@ -467,7 +467,7 @@
 m4_delay_loop(SETUP_DELAY_CYCLES - 1)
 
 	BSET 2		; TCK high
-	DR_MPEG = A 
+	DR_MPEG = A
 
 m4_delay(HOLD_DELAY_CYCLES - 10)
 

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/server/gdb_server.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -822,7 +822,7 @@
 	log_remove_callback(gdb_log_callback, connection);
 
 	gdb_actual_connections--;
-	LOG_DEBUG("GDB Close, Target: %s, state: %s, gdb_actual_connections=%d", 
+	LOG_DEBUG("GDB Close, Target: %s, state: %s, gdb_actual_connections=%d",
 		  gdb_service->target->cmd_name,
 		  target_state_name(gdb_service->target),
 		  gdb_actual_connections);

Modified: trunk/src/target/Makefile.am
===================================================================
--- trunk/src/target/Makefile.am	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/Makefile.am	2009-09-21 18:40:55 UTC (rev 2742)
@@ -98,7 +98,7 @@
 	avrt.h
 
 nobase_dist_pkglib_DATA =
-nobase_dist_pkglib_DATA += xscale/debug_handler.bin 
+nobase_dist_pkglib_DATA += xscale/debug_handler.bin
 nobase_dist_pkglib_DATA += ecos/at91eb40a.elf
 
 MAINTAINERCLEANFILES = $(srcdir)/Makefile.in

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/arm11.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -1066,7 +1066,7 @@
 			retval = arm11_simulate_step(target, &next_pc);
 			if (retval != ERROR_OK)
 				return retval;
-				
+
 			brp[0].value	= next_pc;
 			brp[1].value	= 0x1 | (3 << 1) | (0x0F << 5) | (0 << 14) | (0 << 16) | (0 << 20) | (0 << 21);
 		}

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/arm7_9_common.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -95,7 +95,7 @@
 	{
 		LOG_ERROR("BUG: no hardware comparator available");
 	}
-	LOG_DEBUG("BPID: %d (0x%08" PRIx32 ") using hw wp: %d", 
+	LOG_DEBUG("BPID: %d (0x%08" PRIx32 ") using hw wp: %d",
 			  breakpoint->unique_id,
 			  breakpoint->address,
 			  breakpoint->set );
@@ -158,7 +158,7 @@
 		LOG_ERROR("BUG: both watchpoints used, but wp_available >= 1");
 		return ERROR_FAIL;
 	}
-	LOG_DEBUG("SW BP using hw wp: %d", 
+	LOG_DEBUG("SW BP using hw wp: %d",
 			  arm7_9->sw_breakpoints_added );
 
 	return jtag_execute_queue();
@@ -371,7 +371,7 @@
 
 	if (breakpoint->type == BKPT_HARD)
 	{
-		LOG_DEBUG("BPID: %d Releasing hw wp: %d", 
+		LOG_DEBUG("BPID: %d Releasing hw wp: %d",
 				  breakpoint->unique_id,
 				  breakpoint->set );
 		if (breakpoint->set == 1)

Modified: trunk/src/target/arm926ejs.c
===================================================================
--- trunk/src/target/arm926ejs.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/arm926ejs.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -174,12 +174,12 @@
 		{
 			return retval;
 		}
-		
+
 		if (buf_get_u32(&access, 0, 1) == 1)
 		{
 			break;
 		}
-		
+
 		/* 10ms timeout */
 		if ((timeval_ms()-then)>10)
 		{

Modified: trunk/src/target/breakpoints.c
===================================================================
--- trunk/src/target/breakpoints.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/breakpoints.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -54,7 +54,7 @@
 	{
 		n++;
 		if (breakpoint->address == address){
-			LOG_DEBUG("Duplicate Breakpoint address: 0x%08" PRIx32 " (BP %d)", 
+			LOG_DEBUG("Duplicate Breakpoint address: 0x%08" PRIx32 " (BP %d)",
 				  address, breakpoint->unique_id );
 			return ERROR_OK;
 		}
@@ -76,10 +76,10 @@
 		switch (retval)
 		{
 			case ERROR_TARGET_RESOURCE_NOT_AVAILABLE:
-				LOG_INFO("can't add %s breakpoint, resource not available (BPID=%d)", 
+				LOG_INFO("can't add %s breakpoint, resource not available (BPID=%d)",
 					 breakpoint_type_strings[(*breakpoint_p)->type],
 					 (*breakpoint_p)->unique_id );
-				
+
 				free((*breakpoint_p)->orig_instr);
 				free(*breakpoint_p);
 				*breakpoint_p = NULL;
@@ -87,7 +87,7 @@
 				break;
 			case ERROR_TARGET_NOT_HALTED:
 				LOG_INFO("can't add breakpoint while target is running (BPID: %d)",
-						 (*breakpoint_p)->unique_id );						 
+						 (*breakpoint_p)->unique_id );
 				free((*breakpoint_p)->orig_instr);
 				free(*breakpoint_p);
 				*breakpoint_p = NULL;
@@ -207,7 +207,7 @@
 		switch (retval)
 		{
 			case ERROR_TARGET_RESOURCE_NOT_AVAILABLE:
-				LOG_INFO("can't add %s watchpoint, resource not available (WPID: %d)", 
+				LOG_INFO("can't add %s watchpoint, resource not available (WPID: %d)",
 					 watchpoint_rw_strings[(*watchpoint_p)->rw],
 					 (*watchpoint_p)->unique_id );
 				free (*watchpoint_p);
@@ -230,7 +230,7 @@
 
 	LOG_DEBUG("added %s watchpoint at 0x%8.8" PRIx32 " of length 0x%8.8x (WPID: %d)",
 			  watchpoint_rw_strings[(*watchpoint_p)->rw],
-			  (*watchpoint_p)->address, 
+			  (*watchpoint_p)->address,
 			  (*watchpoint_p)->length,
 			  (*watchpoint_p)->unique_id );
 

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/cortex_a8.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -138,8 +138,8 @@
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
 	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_PRSR, &dummy);
-	/* Enabling of instruction execution in debug mode is done in debug_entry code */ 
-	
+	/* Enabling of instruction execution in debug mode is done in debug_entry code */
+
 	return retval;
 }
 
@@ -1374,7 +1374,7 @@
 	uint32_t didr, ctypr, ttypr, cpuid;
 
 	LOG_DEBUG("TODO");
-	
+
 	/* Here we shall insert a proper ROM Table scan */
 	armv7a->debug_base = OMAP3530_DEBUG_BASE;
 
@@ -1451,7 +1451,7 @@
 
 	/* Configure core debug access */
 	cortex_a8_init_debug_access(target);
-	
+
 	target->type->examined = 1;
 
 	return retval;

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/mips_m4k.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -524,7 +524,7 @@
 		target_write_u32(target, comparator_list[bp_num].reg_address, comparator_list[bp_num].bp_value);
 		target_write_u32(target, comparator_list[bp_num].reg_address + 0x08, 0x00000000);
 		target_write_u32(target, comparator_list[bp_num].reg_address + 0x18, 1);
-		LOG_DEBUG("bpid: %d, bp_num %i bp_value 0x%" PRIx32 "", 
+		LOG_DEBUG("bpid: %d, bp_num %i bp_value 0x%" PRIx32 "",
 				  breakpoint->unique_id,
 				  bp_num, comparator_list[bp_num].bp_value);
 	}
@@ -612,7 +612,7 @@
 		comparator_list[bp_num].used = 0;
 		comparator_list[bp_num].bp_value = 0;
 		target_write_u32(target, comparator_list[bp_num].reg_address + 0x18, 0);
-		
+
 	}
 	else
 	{
@@ -711,9 +711,9 @@
 	 * and exclude both load and store accesses from  watchpoint
 	 * condition evaluation
 	*/
-	int enable = EJTAG_DBCn_NOSB | EJTAG_DBCn_NOLB | EJTAG_DBCn_BE | 
+	int enable = EJTAG_DBCn_NOSB | EJTAG_DBCn_NOLB | EJTAG_DBCn_BE |
                 (0xff << EJTAG_DBCn_BLM_SHIFT);
-	
+
 	if (watchpoint->set)
 	{
 		LOG_WARNING("watchpoint already set");
@@ -765,7 +765,7 @@
 	target_write_u32(target, comparator_list[wp_num].reg_address + 0x18, enable);
 	target_write_u32(target, comparator_list[wp_num].reg_address + 0x20, 0);
 	LOG_DEBUG("wp_num %i bp_value 0x%" PRIx32 "", wp_num, comparator_list[wp_num].bp_value);
-	
+
 	return ERROR_OK;
 }
 
@@ -774,7 +774,7 @@
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target->arch_info;
 	mips32_comparator_t * comparator_list = mips32->data_break_list;
-	
+
 	if (!watchpoint->set)
 	{
 		LOG_WARNING("watchpoint not set");
@@ -804,7 +804,7 @@
 		LOG_INFO("no hardware watchpoints available");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
-		
+
 	mips32->num_data_bpoints_avail--;
 
 	mips_m4k_set_watchpoint(target, watchpoint);

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/target.c	2009-09-21 18:40:55 UTC (rev 2742)
@@ -1241,7 +1241,7 @@
 		address += aligned;
 		size -= aligned;
 	}
-	
+
 	/*prevent byte access when possible (avoid AHB access limitations in some cases)*/
 	if(size	>=2)
 	{

Modified: trunk/src/target/target.h
===================================================================
--- trunk/src/target/target.h	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/target.h	2009-09-21 18:40:55 UTC (rev 2742)
@@ -42,7 +42,7 @@
  * TARGET_RESET   = 3: the target is being held in reset (only a temporary state,
  * not sure how this is used with all the recent changes)
  * TARGET_DEBUG_RUNNING = 4: the target is running, but it is executing code on
- * behalf of the debugger (e.g. algorithm for flashing) 
+ * behalf of the debugger (e.g. algorithm for flashing)
  *
  * also see: target_state_name();
  */

Modified: trunk/src/target/xscale/debug_handler.S
===================================================================
--- trunk/src/target/xscale/debug_handler.S	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/xscale/debug_handler.S	2009-09-21 18:40:55 UTC (rev 2742)
@@ -30,7 +30,7 @@
 1:
 	mrc p14, 0, r15, c14, c0, 0
 	bvs 1b
-	mcr p14, 0, \reg, c8, c0, 0	
+	mcr p14, 0, \reg, c8, c0, 0
 .endm
 
 @ receive word from debugger
@@ -38,7 +38,7 @@
 1:
 	mrc p14, 0, r15, c14, c0, 0
 	bpl 1b
-	mrc p14, 0, \reg, c9, c0, 0	
+	mrc p14, 0, \reg, c9, c0, 0
 .endm
 
 @ save register on debugger, small
@@ -75,7 +75,7 @@
 	mrc p14, 0, r13, c10, c0
 	@ check if global enable bit (GE) is set
 	ands r13, r13, #0x80000000
-	
+
 	bne debug_handler
 
 	@ set global enable bit (GE)
@@ -111,7 +111,7 @@
 	cmp r1, #MODE_USR
 
 	bne not_user_mode
-	
+
 	@ replace USR mode with SYS
 	bic r0, r0, #MODE_MASK
 	orr r0, r0, #MODE_SYS
@@ -124,7 +124,7 @@
 @ wait for command from debugger, than execute desired function
 get_command:
 	bl receive_from_debugger
-	
+
 	@ 0x0n - register access
 	cmp r0, #0x0
 	beq get_banked_registers
@@ -145,10 +145,10 @@
 	@ 0x2n - write memory
 	cmp r0, #0x21
 	beq write_byte
-	
+
 	cmp r0, #0x22
 	beq write_half_word
-	
+
 	cmp r0, #0x24
 	beq write_word
 
@@ -172,7 +172,7 @@
 
 	cmp r0, #0x51
 	beq invalidate_d_cache
-	
+
 	cmp r0, #0x52
 	beq invalidate_i_cache
 
@@ -185,10 +185,10 @@
 
 	cmp r0, #0x61
 	beq read_trace_buffer
-	
+
 	cmp r0, #0x62
 	beq clean_trace_buffer
-	
+
 	@ return (back to get_command)
 	b get_command
 
@@ -221,11 +221,11 @@
 	m_receive_from_debugger lr
 
 	@ branch back to application code, restoring CPSR
-	subs pc, lr, #0	
+	subs pc, lr, #0
 
 @ get banked registers
-@ receive mode bits from host, then run into save_banked_registers to 
-	
+@ receive mode bits from host, then run into save_banked_registers to
+
 get_banked_registers:
 	bl receive_from_debugger
 
@@ -239,7 +239,7 @@
 
 	@ keep current mode bits in r1 for later use
 	and r1, r0, #MODE_MASK
-	
+
 	@ backup banked registers
 	m_send_to_debugger r8
 	m_send_to_debugger r9
@@ -251,7 +251,7 @@
 
 	@ if not in SYS mode (or USR, which we replaced with SYS before)
 	cmp r1, #MODE_SYS
-	
+
 	beq no_spsr_to_save
 
 	@ backup SPSR
@@ -271,8 +271,8 @@
 
 
 @ set banked registers
-@ receive mode bits from host, then run into save_banked_registers to 
-	
+@ receive mode bits from host, then run into save_banked_registers to
+
 set_banked_registers:
 	bl receive_from_debugger
 
@@ -286,7 +286,7 @@
 
 	@ keep current mode bits in r1 for later use
 	and r1, r0, #MODE_MASK
-	
+
 	@ set banked registers
 	m_receive_from_debugger r8
 	m_receive_from_debugger r9
@@ -298,7 +298,7 @@
 
 	@ if not in SYS mode (or USR, which we replaced with SYS before)
 	cmp r1, #MODE_SYS
-	
+
 	beq no_spsr_to_restore
 
 	@ set SPSR
@@ -327,7 +327,7 @@
 
 rb_loop:
 	ldrb r0, [r2], #1
-	
+
 	@ drain write- (and fill-) buffer to work around XScale errata
 	mcr p15, 0, r8, c7, c10, 4
 
@@ -335,7 +335,7 @@
 
 	subs r1, r1, #1
 	bne rb_loop
-	
+
 	@ return
 	b get_command
 
@@ -352,7 +352,7 @@
 
 rh_loop:
 	ldrh r0, [r2], #2
-	
+
 	@ drain write- (and fill-) buffer to work around XScale errata
 	mcr p15, 0, r8, c7, c10, 4
 
@@ -360,7 +360,7 @@
 
 	subs r1, r1, #1
 	bne rh_loop
-	
+
 	@ return
 	b get_command
 
@@ -377,7 +377,7 @@
 
 rw_loop:
 	ldr r0, [r2], #4
-	
+
 	@ drain write- (and fill-) buffer to work around XScale errata
 	mcr p15, 0, r8, c7, c10, 4
 
@@ -385,7 +385,7 @@
 
 	subs r1, r1, #1
 	bne rw_loop
-	
+
 	@ return
 	b get_command
 
@@ -409,7 +409,7 @@
 
 	subs r1, r1, #1
 	bne wb_loop
-	
+
 	@ return
 	b get_command
 
@@ -433,7 +433,7 @@
 
 	subs r1, r1, #1
 	bne wh_loop
-	
+
 	@ return
 	b get_command
 
@@ -457,7 +457,7 @@
 
 	subs r1, r1, #1
 	bne ww_loop
-	
+
 	@ return
 	b get_command
 
@@ -466,7 +466,7 @@
 clear_sa:
 	@ read DCSR
 	mrc p14, 0, r0, c10, c0
-	
+
 	@ clear SA bit
 	bic r0, r0, #0x20
 
@@ -481,7 +481,7 @@
 clean_d_cache:
 	@ r0: cache clean area
 	bl receive_from_debugger
-	
+
 	mov r1, #1024
 clean_loop:
 	mcr p15, 0, r0, c7, c2, 5
@@ -568,7 +568,7 @@
 	b read_cp_reg_reply
 
 read_cp_reg_reply:
-	bl send_to_debugger	
+	bl send_to_debugger
 
 	@ return
 	b get_command
@@ -641,14 +641,14 @@
 	@ dump checkpoint register 0
 	mrc p14, 0, r0, c12, c0, 0 @ XSCALE_CHKPT0 (0x10)
 	bl send_to_debugger
-	
+
 	@ dump checkpoint register 1
 	mrc p14, 0, r0, c13, c0, 0 @ XSCALE_CHKPT1 (0x11)
 	bl send_to_debugger
 
 	@ return
 	b get_command
-	
+
 @ ----
 
 clean_trace_buffer:
@@ -662,7 +662,7 @@
 
 	@ return
 	b get_command
-	
+
 @ ----
 
 
@@ -697,7 +697,7 @@
 	mcr p14, 0, r13, c10, c0, 0 @ XSCALE_DCSR
 
 	@ branch back to application code, restoring CPSR
-	subs pc, lr, #0	
+	subs pc, lr, #0
 
 undef_handler:
 swi_handler:

Modified: trunk/src/target/xscale/debug_handler.cmd
===================================================================
--- trunk/src/target/xscale/debug_handler.cmd	2009-09-21 09:25:52 UTC (rev 2741)
+++ trunk/src/target/xscale/debug_handler.cmd	2009-09-21 18:40:55 UTC (rev 2742)
@@ -2,14 +2,14 @@
 ENTRY(reset_handler)
 
 /* specify the mini-ICache memory areas  */
-MEMORY 
+MEMORY
 {
 	mini_icache_0 (x)  				: ORIGIN = 0x0, LENGTH = 1024	/* first part of mini icache (sets 0-31) */
 	mini_icache_1 (x)  				: ORIGIN = 0x400, LENGTH = 1024	/* second part of mini icache (sets 0-31) */
 }
 
 /* now define the output sections  */
-SECTIONS 
+SECTIONS
 {
 	.part1 :
 	{



From dbrownell at mail.berlios.de  Mon Sep 21 20:48:26 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 21 Sep 2009 20:48:26 +0200
Subject: [Openocd-svn] r2743 - in trunk/tcl: . board chip/atmel/at91
	chip/st/stm32 target test
Message-ID: <200909211848.n8LImQJ2021136@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-21 20:48:22 +0200 (Mon, 21 Sep 2009)
New Revision: 2743

Modified:
   trunk/tcl/bitsbytes.tcl
   trunk/tcl/board/arm_evaluator7t.cfg
   trunk/tcl/board/at91rm9200-dk.cfg
   trunk/tcl/board/at91sam9g20-ek.cfg
   trunk/tcl/board/atmel_at91sam9260-ek.cfg
   trunk/tcl/board/crossbow_tech_imote2.cfg
   trunk/tcl/board/csb732.cfg
   trunk/tcl/board/digi_connectcore_wi-9c.cfg
   trunk/tcl/board/eir.cfg
   trunk/tcl/board/hitex_str9-comstick.cfg
   trunk/tcl/board/imx27ads.cfg
   trunk/tcl/board/imx27lnst.cfg
   trunk/tcl/board/imx31pdk.cfg
   trunk/tcl/board/mini2440.cfg
   trunk/tcl/board/propox_mmnet1001.cfg
   trunk/tcl/board/pxa255_sst.cfg
   trunk/tcl/board/sheevaplug.cfg
   trunk/tcl/board/str910-eval.cfg
   trunk/tcl/board/telo.cfg
   trunk/tcl/board/unknown_at91sam9260.cfg
   trunk/tcl/board/x300t.cfg
   trunk/tcl/board/zy1000.cfg
   trunk/tcl/chip/atmel/at91/aic.tcl
   trunk/tcl/chip/atmel/at91/rtt.tcl
   trunk/tcl/chip/atmel/at91/usarts.tcl
   trunk/tcl/chip/st/stm32/stm32_rcc.tcl
   trunk/tcl/memory.tcl
   trunk/tcl/mmr_helpers.tcl
   trunk/tcl/readable.tcl
   trunk/tcl/target/aduc702x.cfg
   trunk/tcl/target/ar71xx.cfg
   trunk/tcl/target/at91eb40a.cfg
   trunk/tcl/target/at91r40008.cfg
   trunk/tcl/target/at91rm9200.cfg
   trunk/tcl/target/at91sam3uXX.cfg
   trunk/tcl/target/at91sam7sx.cfg
   trunk/tcl/target/at91sam9260.cfg
   trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
   trunk/tcl/target/c100.cfg
   trunk/tcl/target/c100config.tcl
   trunk/tcl/target/c100helper.tcl
   trunk/tcl/target/c100regs.tcl
   trunk/tcl/target/cs351x.cfg
   trunk/tcl/target/epc9301.cfg
   trunk/tcl/target/feroceon.cfg
   trunk/tcl/target/imx21.cfg
   trunk/tcl/target/imx27.cfg
   trunk/tcl/target/imx31.cfg
   trunk/tcl/target/imx35.cfg
   trunk/tcl/target/is5114.cfg
   trunk/tcl/target/ixp42x.cfg
   trunk/tcl/target/lm3s1968.cfg
   trunk/tcl/target/lm3s3748.cfg
   trunk/tcl/target/lm3s6965.cfg
   trunk/tcl/target/lm3s811.cfg
   trunk/tcl/target/lm3s9b9x.cfg
   trunk/tcl/target/lpc2103.cfg
   trunk/tcl/target/lpc2129.cfg
   trunk/tcl/target/lpc2148.cfg
   trunk/tcl/target/lpc2294.cfg
   trunk/tcl/target/netx500.cfg
   trunk/tcl/target/omap3530.cfg
   trunk/tcl/target/omap5912.cfg
   trunk/tcl/target/pic32mx.cfg
   trunk/tcl/target/pxa255.cfg
   trunk/tcl/target/pxa270.cfg
   trunk/tcl/target/readme.txt
   trunk/tcl/target/sam7se512.cfg
   trunk/tcl/target/sam7x256.cfg
   trunk/tcl/target/samsung_s3c2410.cfg
   trunk/tcl/target/samsung_s3c2440.cfg
   trunk/tcl/target/samsung_s3c2450.cfg
   trunk/tcl/target/samsung_s3c4510.cfg
   trunk/tcl/target/samsung_s3c6410.cfg
   trunk/tcl/target/sharp_lh79532.cfg
   trunk/tcl/target/stm32.cfg
   trunk/tcl/target/str710.cfg
   trunk/tcl/target/str730.cfg
   trunk/tcl/target/str750.cfg
   trunk/tcl/target/str912.cfg
   trunk/tcl/target/telo.cfg
   trunk/tcl/target/test_reset_syntax_error.cfg
   trunk/tcl/target/test_syntax_error.cfg
   trunk/tcl/target/xba_revA3.cfg
   trunk/tcl/test/syntax1.cfg
Log:
Remove annoying end-of-line whitespace from tcl/* files


Modified: trunk/tcl/bitsbytes.tcl
===================================================================
--- trunk/tcl/bitsbytes.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/bitsbytes.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -22,7 +22,7 @@
 # Create M bytes values
 #    __1M ... to __2048K
 for { set x 1  } { $x < 2048 } { set x [expr $x * 2]} {
-    set vn [format "__%dM" $x] 
+    set vn [format "__%dM" $x]
     global $vn
     set $vn [expr (1024 * 1024 * $x)]
 }

Modified: trunk/tcl/board/arm_evaluator7t.cfg
===================================================================
--- trunk/tcl/board/arm_evaluator7t.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/arm_evaluator7t.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -2,7 +2,7 @@
 
 source [find target/samsung_s3c4510.cfg]
 
-# 
+#
 # FIXME:
 #  Add (A) sdram configuration
 #  Add (B) flash cfi programing configuration

Modified: trunk/tcl/board/at91rm9200-dk.cfg
===================================================================
--- trunk/tcl/board/at91rm9200-dk.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/at91rm9200-dk.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -16,7 +16,7 @@
     # Try to run at 1khz... Yea, that slow!
     # Chip is really running @ 32khz
     jtag_khz 8
-    
+
     mww 0xfffffc64 0xffffffff
     ##  disable all clocks but system clock
     mww 0xfffffc04 0xfffffffe
@@ -37,14 +37,14 @@
     mww 0xfffffc30 0x202
     ## Sleep some - (go read)
     sleep 100
-    
+
     #========================================
     # CPU now runs at 180mhz
     # SYS runs at 60mhz.
     jtag_khz 40000
     #========================================
-    
-    
+
+
     ##  set memc for all memories
     mww 0xffffff60 0x02
     ##  program smc controller
@@ -55,7 +55,7 @@
     mww 0xffffff80 0x02
     ##  touch sdram chip to make it work
     mww 0x20000000 0
-    ##  sdram controller mode register 
+    ##  sdram controller mode register
     mww 0xffffff90 0x04
     mww 0x20000000 0
     mww 0x20000000 0

Modified: trunk/tcl/board/at91sam9g20-ek.cfg
===================================================================
--- trunk/tcl/board/at91sam9g20-ek.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/at91sam9g20-ek.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -62,7 +62,7 @@
 }
 
 proc at91sam9g20_init { } {
-	
+
 	# At reset AT91SAM9G20 chip runs on slow clock (32.768 kHz).  To shift over to a normal clock requires
 	# a number of steps that must be carefully performed.  The process outline below follows the
 	# recommended procedure outlined in the AT91SAM9G20 technical manual.
@@ -94,7 +94,7 @@
 
 	mww 0xfffffc30 0x00000101
 	while { [expr [read_register 0xfffffc68] & 0x08] != 8 } { sleep 1 }
-	
+
 	# Now change PMC_MCKR register to select PLLA.
 	# Wait for MCKRDY signal from PMC_SR to assert.
 

Modified: trunk/tcl/board/atmel_at91sam9260-ek.cfg
===================================================================
--- trunk/tcl/board/atmel_at91sam9260-ek.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/atmel_at91sam9260-ek.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -26,7 +26,7 @@
         # RSTC_MR : enable user reset, MMU may be enabled... use physical address
         arm926ejs mww_phys 0xfffffd08 0xa5000501
 }
-	
+
 $_TARGETNAME configure -event reset-init {
         mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
 
@@ -48,7 +48,7 @@
 
 	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
         mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
-        
+
         mww 0xffffef1c 0x00010002         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
 
 	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)

Modified: trunk/tcl/board/crossbow_tech_imote2.cfg
===================================================================
--- trunk/tcl/board/crossbow_tech_imote2.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/crossbow_tech_imote2.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -4,7 +4,7 @@
 source [find target/pxa270.cfg]
 
 # longer-than-normal reset delay
-jtag_nsrst_delay 800 
+jtag_nsrst_delay 800
 
 reset_config trst_and_srst separate
 

Modified: trunk/tcl/board/csb732.cfg
===================================================================
--- trunk/tcl/board/csb732.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/csb732.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -11,7 +11,7 @@
 
 # Bare-bones initialization of core clocks and SDRAM
 proc csb732_init { } {
-	
+
 	# Disable fast writing only for init
 	memwrite burst disable
 
@@ -29,17 +29,17 @@
 
 	# Set ARM clock to 532 MHz, AHB to 133 MHz
 	mww 0x53F80004 0x1000
-	
+
 	# Set core clock to 2 * 24 MHz * (11 + 1/12) = 532 MHz
 	mww 0x53F8001C 0xB2C01
-	
+
 	set ESDMISC 0xB8001010
 	set ESDCFG0 0xB8001004
 	set ESDCTL0 0xB8001000
 
 	# Enable DDR
 	mww $ESDMISC 0x4
-	
+
 	# Timing
 	mww $ESDCFG0 0x007fff3f
 
@@ -51,7 +51,7 @@
 
 	# Enable CS) auto-refresh
 	mww $ESDCTL0 0xA2120080
-	
+
 	# Refresh twice (dummy writes)
 	mww 0x80000000 0
 	mww 0x80000000 0
@@ -59,7 +59,7 @@
 	# Enable CS0 load mode register
 	mww $ESDCTL0 0xB2120080
 
-	# Dummy writes	
+	# Dummy writes
 	mwb 0x80000033 0x01
 	mwb 0x81000000 0x01
 

Modified: trunk/tcl/board/digi_connectcore_wi-9c.cfg
===================================================================
--- trunk/tcl/board/digi_connectcore_wi-9c.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/digi_connectcore_wi-9c.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -4,15 +4,15 @@
 
 reset_config trst_and_srst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME ns9360
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # This config file was defaulting to big endian..
    set  _ENDIAN big
 }
@@ -46,17 +46,17 @@
 	mww 0x90600104 0x33313333
 	mww 0xA0700000 0x00000001  # Enable the memory controller.
 	mww 0xA0700024 0x00000006  # Set the refresh counter 6
-	mww 0xA0700028 0x00000001  # 
+	mww 0xA0700028 0x00000001  #
 	mww 0xA0700030 0x00000001  # Set the precharge period
 	mww 0xA0700034 0x00000004  # Active to precharge command period is 16 clock cycles
 	mww 0xA070003C 0x00000001  # tAPR
 	mww 0xA0700040 0x00000005  # tDAL
 	mww 0xA0700044 0x00000001  # tWR
-	mww 0xA0700048 0x00000006  # tRC 32 clock cycles  
+	mww 0xA0700048 0x00000006  # tRC 32 clock cycles
 	mww 0xA070004C 0x00000006  # tRFC 32 clock cycles
 	mww 0xA0700054 0x00000001  # tRRD
 	mww 0xA0700058 0x00000001  # tMRD
-	mww 0xA0700100 0x00004280  # Dynamic Config 0 (cs4) 
+	mww 0xA0700100 0x00004280  # Dynamic Config 0 (cs4)
 	mww 0xA0700120 0x00004280  # Dynamic Config 1 (cs5)
 	mww 0xA0700140 0x00004280  # Dynamic Config 2 (cs6)
 	mww 0xA0700160 0x00004280  # Dynamic Config 3 (cs7)
@@ -79,11 +79,11 @@
 	mww 0xA0900000 0x00000002
 	mww 0xA0900000 0x00000002
 	#
-	mdw 0xA0900000 
-	mdw 0xA0900000 
-	mdw 0xA0900000 
-	mdw 0xA0900000 
-	mdw 0xA0900000 
+	mdw 0xA0900000
+	mdw 0xA0900000
+	mdw 0xA0900000
+	mdw 0xA0900000
+	mdw 0xA0900000
 	#
 	mww 0xA0700024 0x00000030 # Set the refresh counter to 30
 	mww 0xA0700020 0x00000083 # Issue SDRAM MODE command

Modified: trunk/tcl/board/eir.cfg
===================================================================
--- trunk/tcl/board/eir.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/eir.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -4,7 +4,7 @@
 source [find target/sam7se512.cfg]
 
 $_TARGETNAME configure -event reset-init {
-	# WDT_MR, disable watchdog 
+	# WDT_MR, disable watchdog
 	mww 0xFFFFFD44 0x00008000
 
 	# RSTC_MR, enable user reset
@@ -51,31 +51,31 @@
 
 	# Issue 16 bit SDRAM command: NOP
 	mww 0xffffffb0 0x00000011 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 
 	# Issue 16 bit SDRAM command: Precharge all
 	mww 0xffffffb0 0x00000012 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 
 	# Issue 8 auto-refresh cycles
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 	mww 0xffffffb0 0x00000014 # SDRAMC_MR_OFF
-	mww 0x20000000 0x00000000 
+	mww 0x20000000 0x00000000
 
-	# Issue 16 bit SDRAM command: Set mode register  
+	# Issue 16 bit SDRAM command: Set mode register
 	mww 0xffffffb0 0x00000013 # SDRAMC_MR_OFF
 	mww 0x20000014 0xcafedede
 

Modified: trunk/tcl/board/hitex_str9-comstick.cfg
===================================================================
--- trunk/tcl/board/hitex_str9-comstick.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/hitex_str9-comstick.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -14,15 +14,15 @@
 #jtag scan chain
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME str912
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -56,10 +56,10 @@
 $_TARGETNAME configure -event reset-init {
 	# We can increase speed now that we know the target is halted.
 	#jtag_rclk 3000
-	
+
 	# -- Enable 96K RAM
 	# PFQBC enabled / DTCM & AHB wait-states disabled
-	mww 0x5C002034 0x0191 
+	mww 0x5C002034 0x0191
 
 	str9x flash_config 0 4 2 0 0x80000
 	flash protect 0 0 7 off

Modified: trunk/tcl/board/imx27ads.cfg
===================================================================
--- trunk/tcl/board/imx27ads.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/imx27ads.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -24,52 +24,52 @@
 	# ========================================
 	#  Configure DDR on CSD0 -- initial reset
 	# ========================================
-	mww 0xD8001010 0x00000008 
+	mww 0xD8001010 0x00000008
 
 	# ========================================
-	#  Configure PSRAM on CS5 
+	#  Configure PSRAM on CS5
 	# ========================================
 	mww 0xd8002050 0x0000dcf6
-	mww 0xd8002054 0x444a4541 
-	mww 0xd8002058 0x44443302 
+	mww 0xd8002054 0x444a4541
+	mww 0xd8002058 0x44443302
 
 	#  ========================================
 	#         Configure16 bit NorFlash on CS0
 	#  ========================================
-	mww 0xd8002000 0x0000CC03 
-	mww 0xd8002004 0xa0330D01 
-	mww 0xd8002008 0x00220800 
+	mww 0xd8002000 0x0000CC03
+	mww 0xd8002004 0xa0330D01
+	mww 0xd8002008 0x00220800
 
 	# ========================================
-	#  Configure CPLD on CS4 
+	#  Configure CPLD on CS4
 	# ========================================
-	mww 0xd8002040 0x0000DCF6 
-	mww 0xd8002044 0x444A4541 
-	mww 0xd8002048 0x44443302 
+	mww 0xd8002040 0x0000DCF6
+	mww 0xd8002044 0x444A4541
+	mww 0xd8002048 0x44443302
 
 	# ========================================
-	#  Configure DDR on CSD0 -- wait 5000 cycle 
+	#  Configure DDR on CSD0 -- wait 5000 cycle
 	# ========================================
-	mww 0x10027828 0x55555555 
-	mww 0x10027830 0x55555555 
-	mww 0x10027834 0x55555555 
-	mww 0x10027838 0x00005005 
-	mww 0x1002783C 0x15555555 
+	mww 0x10027828 0x55555555
+	mww 0x10027830 0x55555555
+	mww 0x10027834 0x55555555
+	mww 0x10027838 0x00005005
+	mww 0x1002783C 0x15555555
 
-	mww 0xD8001010 0x00000004 
+	mww 0xD8001010 0x00000004
 
-	mww 0xD8001004 0x00795729 
+	mww 0xD8001004 0x00795729
 
-	mww 0xD8001000 0x92200000 
+	mww 0xD8001000 0x92200000
 	mww 0xA0000F00 0x0
 
-	mww 0xD8001000 0xA2200000 
+	mww 0xD8001000 0xA2200000
 	mww 0xA0000F00 0x0
 	mww 0xA0000F00 0x0
 
-	mww 0xD8001000 0xB2200000 
+	mww 0xD8001000 0xB2200000
 	mwb 0xA0000033 0xFF
 	mwb 0xA1000000 0xAA
 
-	mww 0xD8001000 0x82228085 
+	mww 0xD8001000 0x82228085
 }

Modified: trunk/tcl/board/imx27lnst.cfg
===================================================================
--- trunk/tcl/board/imx27lnst.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/imx27lnst.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -22,38 +22,38 @@
 	# ========================================
 	#  Configure DDR on CSD0 -- initial reset
 	# ========================================
-	mww 0xD8001010 0x00000008 
+	mww 0xD8001010 0x00000008
 
 	sleep 100
 
 	# ========================================
-	#  Configure DDR on CSD0 -- wait 5000 cycle 
+	#  Configure DDR on CSD0 -- wait 5000 cycle
 	# ========================================
-	mww 0x10027828 0x55555555 
-	mww 0x10027830 0x55555555 
-	mww 0x10027834 0x55555555 
-	mww 0x10027838 0x00005005 
-	mww 0x1002783C 0x15555555 
+	mww 0x10027828 0x55555555
+	mww 0x10027830 0x55555555
+	mww 0x10027834 0x55555555
+	mww 0x10027838 0x00005005
+	mww 0x1002783C 0x15555555
 
-	mww 0xD8001010 0x00000004 
+	mww 0xD8001010 0x00000004
 
-	mww 0xD8001004 0x00795729 
+	mww 0xD8001004 0x00795729
 
 	#mww 0xD8001000 0x92200000
 	mww 0xD8001000 0x91120000
 	mww 0xA0000F00 0x0
 
-	#mww 0xD8001000 0xA2200000 
+	#mww 0xD8001000 0xA2200000
 	mww 0xD8001000 0xA1120000
 	mww 0xA0000F00 0x0
 	mww 0xA0000F00 0x0
 
-	#mww 0xD8001000 0xB2200000 
+	#mww 0xD8001000 0xB2200000
 	mww 0xD8001000 0xB1120000
 	mwb 0xA0000033 0xFF
 	mwb 0xA1000000 0xAA
 
-	#mww 0xD8001000 0x82228085 
+	#mww 0xD8001000 0x82228085
 	mww 0xD8001000 0x81128080
 
 }

Modified: trunk/tcl/board/imx31pdk.cfg
===================================================================
--- trunk/tcl/board/imx31pdk.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/imx31pdk.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -25,7 +25,7 @@
 	mww 0x53F80010 0x00271C1B
 
 	# ========================================
-	# Configure CPLD on CS5 
+	# Configure CPLD on CS5
 	# ========================================
 	mww 0xb8002050 0x0000DCF6
 	mww 0xb8002054 0x444A4541

Modified: trunk/tcl/board/mini2440.cfg
===================================================================
--- trunk/tcl/board/mini2440.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/mini2440.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,7 +1,7 @@
 #-------------------------------------------------------------------------
 # Mini2440 Samsung s3c2440A Processor with 64MB DRAM, 64MB NAND, 2 MB N0R
 # NOTE: Configured for NAND boot (switch S2 in NANDBOOT)
-# 64 MB NAND (Samsung K9D1208V0M) 
+# 64 MB NAND (Samsung K9D1208V0M)
 # B Findlay  08/09
 #
 #   ----------- Important notes to help you on your way ----------
@@ -9,9 +9,9 @@
 #     NOR/NAND Boot Switch - I have not read the vivi source, but from
 #     what I could tell from reading the registers it appears that vivi
 #     loads itself into DRAM and then flips NFCONT (0x4E000004) bits
-#     Mode (bit 0 = 1), and REG_nCE (bit 1 = 0) which maps the NAND 
-#     FLASH at the bottom 64MB of memory. This essentially takes the 
-#     NOR Flash out of the circuit so you can't trash it. 
+#     Mode (bit 0 = 1), and REG_nCE (bit 1 = 0) which maps the NAND
+#     FLASH at the bottom 64MB of memory. This essentially takes the
+#     NOR Flash out of the circuit so you can't trash it.
 #
 #     I adapted the samsung_s3c2440.cfg file which is why I did not
 #     include "source [find target/samsung_s3c2440.cfg]".  I believe
@@ -22,9 +22,9 @@
 #     JTAG ADAPTER SPECIFIC
 #     IMPORTANT! Any JTAG device that uses ADAPTIVE CLOCKING will likely
 #     FAIL as the pin RTCK on the mini2440 10 pin JTAG Conn doesn't exist.
-#     This is Pin 11 (RTCK) on 20 pin JTAG connector. Therefore it is 
+#     This is Pin 11 (RTCK) on 20 pin JTAG connector. Therefore it is
 #     necessary to FORCE setting the clock. Normally this should be configured
-#     in the openocd.cfg file, but was placed here as it can be a tough 
+#     in the openocd.cfg file, but was placed here as it can be a tough
 #     problem to figure out.  THIS MAY NOT FIX YOUR PROBLEM.. I modified
 #     the openOCD driver jlink.c and posted it here. It may eventually end
 #     up changed in openOCD, but its a hack in the driver and really should
@@ -42,21 +42,21 @@
 #     But it should get you way ahead of the game from where I started.
 #     If you find problems (and fixes) please post them to
 #     openocd-development at lists.berlios.de and join the developers and
-#     check in fixes to this and anything else you find.  I do not 
-#     provide support, but if you ask really nice and I see anything 
+#     check in fixes to this and anything else you find.  I do not
+#     provide support, but if you ask really nice and I see anything
 #     obvious I will tell you.. mostly just dig, fix, and submit to openocd.
-#     
+#
 #     best!   brfindla at yahoo.com   Nashua, NH USA
 #
 #     Recommended resources:
 #       - first two are the best Mini2440 resources anywhere
 #       - maintained by buserror... thanks guy!
 #
-#       http://bliterness.blogspot.com/    
+#       http://bliterness.blogspot.com/
 #       http://code.google.com/p/mini2440/
 #
 #       others....
-# 
+#
 #       http://forum.sparkfun.com/viewforum.php?f=18
 #       http://labs.kernelconcepts.de/Publications/Micro24401/
 #       http://www.friendlyarm.net/home
@@ -75,19 +75,19 @@
 # Target configuration for the Samsung 2440 system on chip
 # Tested on a S3C2440 Evaluation board by keesj
 # Processor : ARM920Tid(wb) rev 0 (v4l)
-# Info: JTAG tap: s3c2440.cpu tap/device found: 0x0032409d 
+# Info: JTAG tap: s3c2440.cpu tap/device found: 0x0032409d
 #  (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)
 #-------------------------------------------------------------------------
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME s3c2440
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # this defaults to a bigendian
    set  _ENDIAN little
 }
@@ -108,16 +108,16 @@
 
 #reset configuration
 jtag_nsrst_delay 100
-jtag_ntrst_delay 100 
+jtag_ntrst_delay 100
 reset_config trst_and_srst
 
 #-------------------------------------------------------------------------
 # JTAG ADAPTER SPECIFIC
-# IMPORTANT! See README at top of this file. 
+# IMPORTANT! See README at top of this file.
 #-------------------------------------------------------------------------
 
-    jtag_khz 12000  
-    jtag interface   
+    jtag_khz 12000
+    jtag interface
 
 #-------------------------------------------------------------------------
 # GDB Setup
@@ -125,23 +125,23 @@
 
     gdb_port 3333
     gdb_detach resume
-    gdb_breakpoint_override hard 
+    gdb_breakpoint_override hard
     gdb_memory_map enable
-    gdb_flash_program enable 
+    gdb_flash_program enable
 
 #------------------------------------------------
 # ARM SPECIFIC
 #------------------------------------------------
 
-    targets 
+    targets
   #  arm7_9 dcc_downloads enable
   #  arm7_9 fast_memory_access enable
-  
- 
-    nand device s3c2440 0 
 
+
+    nand device s3c2440 0
+
     jtag_nsrst_delay 100
-    jtag_ntrst_delay 100 
+    jtag_ntrst_delay 100
     reset_config trst_and_srst
     init
 
@@ -180,62 +180,62 @@
     # OM2 OM3 pulled to ground so main clock and
     # usb clock are off 12mHz xtal
     #-----------------------------------------------
-   
+
     arm920t mww_phys 0x4C000014 0x00000005 #  Clock Divider control Reg
     arm920t mww_phys 0x4C000000 0xFFFFFFFF #  LOCKTIME count register
     arm920t mww_phys 0x4C000008 0x00038022 #  UPPLCON  USB clock config Reg
     arm920t mww_phys 0x4C000004 0x0007F021 #  MPPLCON  Proc clock config Reg
-	
+
     #-----------------------------------------------
     # Configure Memory controller
     # BWSCON configures all banks, NAND, NOR, DRAM
     # DRAM - 64MB - 32 bit bus, uses BANKCON6 BANKCON7
     #-----------------------------------------------
-	
+
     arm920t mww_phys 0x48000000 0x22111112 #  BWSCON - Bank and Bus Width
     arm920t mww_phys 0x48000010 0x00001112 #  BANKCON4 - ?
-    arm920t mww_phys 0x4800001c 0x00018009 #  BANKCON6 - DRAM	
-    arm920t mww_phys 0x48000020 0x00018009 #  BANKCON7 - DRAM	
-    arm920t mww_phys 0x48000024 0x008E04EB #  REFRESH  - DRAM		
-    arm920t mww_phys 0x48000028 0x000000B2 #  BANKSIZE - DRAM		
-    arm920t mww_phys 0x4800002C 0x00000030 #  MRSRB6 - DRAM		
-    arm920t mww_phys 0x48000030 0x00000030 #  MRSRB7 - DRAM					
-		
+    arm920t mww_phys 0x4800001c 0x00018009 #  BANKCON6 - DRAM
+    arm920t mww_phys 0x48000020 0x00018009 #  BANKCON7 - DRAM
+    arm920t mww_phys 0x48000024 0x008E04EB #  REFRESH  - DRAM
+    arm920t mww_phys 0x48000028 0x000000B2 #  BANKSIZE - DRAM
+    arm920t mww_phys 0x4800002C 0x00000030 #  MRSRB6 - DRAM
+    arm920t mww_phys 0x48000030 0x00000030 #  MRSRB7 - DRAM
+
     #-----------------------------------------------
     # Now port configuration for enables for memory
     # and other stuff.
     #-----------------------------------------------
-    
+
     arm920t mww_phys 0x56000000	0x007FFFFF #  GPACON
-    
-    arm920t mww_phys 0x56000010	0x00295559 #  GPBCON   
+
+    arm920t mww_phys 0x56000010	0x00295559 #  GPBCON
     arm920t mww_phys 0x56000018	0x000003FF #  GPBUP (PULLUP ENABLE)
-    arm920t mww_phys 0x56000014	0x000007C2 #  GPBDAT   	    
-    
-    arm920t mww_phys 0x56000020	0xAAAAA6AA #  GPCCON   	
+    arm920t mww_phys 0x56000014	0x000007C2 #  GPBDAT
+
+    arm920t mww_phys 0x56000020	0xAAAAA6AA #  GPCCON
     arm920t mww_phys 0x56000028	0x0000FFFF #  GPCUP
-    arm920t mww_phys 0x56000024	0x00000020 #  GPCDAT   	 	   	
-    
-    arm920t mww_phys 0x56000030	0xAAAAAAAA #  GPDCON   	
-    arm920t mww_phys 0x56000038	0x0000FFFF #  GPDUP    
-    
-    arm920t mww_phys 0x56000040	0xAAAAAAAA #  GPECON   	
-    arm920t mww_phys 0x56000048	0x0000FFFF #  GPEUP    
-    
-    arm920t mww_phys 0x56000050	0x00001555 #  GPFCON   	
-    arm920t mww_phys 0x56000058	0x0000007F #  GPFUP    
-    arm920t mww_phys 0x56000054	0x00000000 #  GPFDAT       
-     
-    arm920t mww_phys 0x56000060	0x00150114 #  GPGCON   	
-    arm920t mww_phys 0x56000068	0x0000007F #  GPGUP        
- 
-    arm920t mww_phys 0x56000070	0x0015AAAA #  GPHCON  
-    arm920t mww_phys 0x56000078	0x000003FF #  GPGUP       
+    arm920t mww_phys 0x56000024	0x00000020 #  GPCDAT
 
-}	
+    arm920t mww_phys 0x56000030	0xAAAAAAAA #  GPDCON
+    arm920t mww_phys 0x56000038	0x0000FFFF #  GPDUP
 
+    arm920t mww_phys 0x56000040	0xAAAAAAAA #  GPECON
+    arm920t mww_phys 0x56000048	0x0000FFFF #  GPEUP
 
+    arm920t mww_phys 0x56000050	0x00001555 #  GPFCON
+    arm920t mww_phys 0x56000058	0x0000007F #  GPFUP
+    arm920t mww_phys 0x56000054	0x00000000 #  GPFDAT
 
+    arm920t mww_phys 0x56000060	0x00150114 #  GPGCON
+    arm920t mww_phys 0x56000068	0x0000007F #  GPGUP
+
+    arm920t mww_phys 0x56000070	0x0015AAAA #  GPHCON
+    arm920t mww_phys 0x56000078	0x000003FF #  GPGUP
+
+}
+
+
+
 proc flash_config { } {
 
     #-----------------------------------------
@@ -243,7 +243,7 @@
     #-----------------------------------------
 
     halt
-    
+
     #flash configuration (K9D1208V0M: 512Mbit, x8, 3.3V, Mode: Normal, 1st gen)
     nand probe 0
     nand list
@@ -275,8 +275,8 @@
         echo "---- http://repo.or.cz/w/u-boot-openmoko/mini2440.git  ---"
         echo "---- Also this:                                        ---"
         echo "---- http://code.google.com/p/mini2440/wiki/MiniBringup --"
-        echo "----------------------------------------------------------"      
-  
+        echo "----------------------------------------------------------"
+
 	init_2440
 	echo "Loading /tftpboot/u-boot-nand512.bin"
 	load_image /tftpboot/u-boot-nand512.bin 0x33f80000 bin

Modified: trunk/tcl/board/propox_mmnet1001.cfg
===================================================================
--- trunk/tcl/board/propox_mmnet1001.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/propox_mmnet1001.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -9,7 +9,7 @@
 
 
 proc at91sam_init { } {
-	
+
 	# at reset chip runs at 32 kHz => 1/8 * 32 kHz = 4 kHz
 	jtag_rclk 4
 

Modified: trunk/tcl/board/pxa255_sst.cfg
===================================================================
--- trunk/tcl/board/pxa255_sst.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/pxa255_sst.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,7 +1,7 @@
 # A PXA255 test board with SST 39LF400A flash
 #
 # At reset the memory map is as follows. Note that
-# the memory map changes later on as the application 
+# the memory map changes later on as the application
 # starts...
 #
 # RAM at 0x4000000

Modified: trunk/tcl/board/sheevaplug.cfg
===================================================================
--- trunk/tcl/board/sheevaplug.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/sheevaplug.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,4 +1,4 @@
-# Marvell SheevaPlug 
+# Marvell SheevaPlug
 
 source [find interface/sheevaplug.cfg]
 source [find target/feroceon.cfg]

Modified: trunk/tcl/board/str910-eval.cfg
===================================================================
--- trunk/tcl/board/str910-eval.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/str910-eval.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,17 +1,17 @@
 # str910-eval eval board
-# 
-# Need reset scripts 
+#
+# Need reset scripts
 reset_config trst_and_srst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME str912
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -44,10 +44,10 @@
 $_TARGETNAME configure -event reset-init {
 	# We can increase speed now that we know the target is halted.
 	#jtag_rclk 3000
-	
+
 	# -- Enable 96K RAM
 	# PFQBC enabled / DTCM & AHB wait-states disabled
-	mww 0x5C002034 0x0191 
+	mww 0x5C002034 0x0191
 
 	str9x flash_config 0 4 2 0 0x80000
 	flash protect 0 0 7 off

Modified: trunk/tcl/board/telo.cfg
===================================================================
--- trunk/tcl/board/telo.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/telo.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -8,7 +8,7 @@
 
 
 # Telo board & C100 support trst and srst
-# however openocd does not support 
+# however openocd does not support
 # 1. setting srst reset pulse width
 # 2. setting delay between srst pulse and JTAG access
 # This really makes the srst useless for now.
@@ -23,7 +23,7 @@
 	# setup GPIO used as control signals for C100
 	setupGPIO
 	# This will allow acces to lower 8MB or NOR
-	lowGPIO5 
+	lowGPIO5
 	# setup NOR size,timing,etc.
 	setupNOR
 	# setup internals + PLL + DDR2
@@ -38,10 +38,10 @@
 	# Force target into ARM state.
 #	soft_reset_halt # not implemented on ARM11
 	puts "Detected SRSRT asserted on C100.CPU"
-	
+
 }
 
-proc power_restore {} { puts "Sensed power restore. No action." } 
+proc power_restore {} { puts "Sensed power restore. No action." }
 proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }
 
 

Modified: trunk/tcl/board/unknown_at91sam9260.cfg
===================================================================
--- trunk/tcl/board/unknown_at91sam9260.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/unknown_at91sam9260.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,4 +1,4 @@
-# Thanks to Pieter Conradie for this script! 
+# Thanks to Pieter Conradie for this script!
 #
 # Unknown vendor board contains:
 #
@@ -15,13 +15,13 @@
 $_TARGETNAME configure -event reset-start {
         # At reset CPU runs at 22 to 42 kHz.
         # JTAG Frequency must be 6 times slower.
-        jtag_rclk 3                        
+        jtag_rclk 3
         halt
 	# RSTC_MR : enable user reset, MMU may be enabled... use physical address
         arm926ejs mww_phys 0xfffffd08 0xa5000501
 }
-	
 
+
 $_TARGETNAME configure -event reset-init {
         mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
 
@@ -37,7 +37,7 @@
         sleep 10                          # wait 10 ms
 
 	# Increase JTAG Speed to 6 MHz if RCLK is not supported
-        jtag_rclk 6000                    
+        jtag_rclk 6000
 
 	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
 
@@ -51,7 +51,7 @@
 	mww 0xfffff870 0xffff0000         # PIO_ASR  : Select peripheral function for D15..D31
         mww 0xfffff804 0xffff0000         # PIO_PDR  : Disable PIO function for D15..D31
         mww 0xfffff860 0xffff0000         # PIO_PUDR : Disable D15..D31 pull-ups
-        
+
         mww 0xffffef1c 0x00010102         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM
                                           #            VDDIOMSEL set for +3V3 memory
                                           #            Disable D0..D15 pull-ups

Modified: trunk/tcl/board/x300t.cfg
===================================================================
--- trunk/tcl/board/x300t.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/x300t.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -18,13 +18,13 @@
 	mww 0xa0030000 0xE34111BA
 	mww 0xa003fffc 0xa4444
 	mww 0xa003fffc 0
-	
+
 	# remap boot vector in CPU local RAM
 	mww 0xa006f000 0x60000
-	
+
 	# map flash to CPU address space REG_BASE_cpu_block+CPU_remap4
 	mww 0x0006f010 0x48000000
-	
+
 	# map flash addr to REG_BASE_cpu_block + LR_XENV_LOCATION (normally done by XOS)
 	mww 0x00061ff0 0x48000000
 }

Modified: trunk/tcl/board/zy1000.cfg
===================================================================
--- trunk/tcl/board/zy1000.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/board/zy1000.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -10,19 +10,19 @@
 reset_config srst_only srst_pulls_trst
 
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME zy1000
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
- 
+
 #jtag scan chain
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
@@ -39,7 +39,7 @@
 arm7_9 dcc_downloads enable
 
 flash bank ecosflash 0x01000000 0x200000 2 2 0 ecos/at91eb40a.elf
-$_TARGETNAME configure -event reset-init { 
+$_TARGETNAME configure -event reset-init {
 	# Set up chip selects & timings
 	mww 0xFFE00000 0x0100273D
 	mww 0xFFE00004 0x08002125
@@ -51,12 +51,12 @@
 	mww 0xFFE0001c 0x70000000
 	mww 0xFFE00020 0x00000001
 	mww 0xFFE00024 0x00000000
-	
-	# remap  
-	mww 0xFFFFF124 0xFFFFFFFF  
+
+	# remap
+	mww 0xFFFFF124 0xFFFFFFFF
 	mww 0xffff0010 0x100
 	mww 0xffff0034 0x100
-	
+
 	#disable 16x5x UART interrupts
 	mww 0x08020004 0
 }
@@ -75,7 +75,7 @@
 # There is no return value from this procedure. If it is
 # successful it does not throw an exception
 #
-# Progress messages are output via puts 
+# Progress messages are output via puts
 proc production {firmwarefile serialnumber} {
 	if {[string length $serialnumber]!=12} {
 		puts "Invalid serial number"
@@ -92,11 +92,11 @@
 	verify_image $firmwarefile 0x1000000 bin
 
 	# Big endian... weee!!!!
-	puts "Setting MAC number to $serialnumber"	
+	puts "Setting MAC number to $serialnumber"
 	flash fillw [expr 0x1030000-0x8] "0x[string range $serialnumber 2 3][string range $serialnumber 0 1]0000" 1
 	flash fillw [expr 0x1030000-0x4] "0x[string range $serialnumber 10 11][string range $serialnumber 8 9][string range $serialnumber 6 7][string range $serialnumber 4 5]" 1
 	puts "Production successful"
-} 
+}
 
 
 proc production_test {} {

Modified: trunk/tcl/chip/atmel/at91/aic.tcl
===================================================================
--- trunk/tcl/chip/atmel/at91/aic.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/chip/atmel/at91/aic.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -85,12 +85,12 @@
 	incr x
 	puts [format "%2d: %5s 0x%08x" $x $AT91C_ID($x) $aaa($x)]
 	incr x
-    } 
+    }
 
     foreach REG {
-	AIC_IVR   AIC_FVR  AIC_ISR 
+	AIC_IVR   AIC_FVR  AIC_ISR
 	AIC_IPR  AIC_IMR  AIC_CISR  AIC_IECR AIC_IDCR
-	AIC_ICCR AIC_ISCR AIC_EOICR AIC_SPU  AIC_DCR     
+	AIC_ICCR AIC_ISCR AIC_EOICR AIC_SPU  AIC_DCR
 	AIC_FFER AIC_FFDR AIC_FFSR } {
 	if [catch { show_mmr32_reg $REG } msg ] {
 	    error $msg

Modified: trunk/tcl/chip/atmel/at91/rtt.tcl
===================================================================
--- trunk/tcl/chip/atmel/at91/rtt.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/chip/atmel/at91/rtt.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -13,7 +13,7 @@
     global BIT16 BIT17
     if { $rtpres == 0 } {
 	set rtpres 65536;
-    } 
+    }
     global AT91C_SLOWOSC_FREQ
     # Nasty hack, make this a float by tacking a .0 on the end
     # otherwise, jim makes the value an integer
@@ -47,7 +47,7 @@
 }
 
 proc show_RTTC { } {
-    
+
     show_mmr32_reg RTTC_RTMR
     show_mmr32_reg RTTC_RTAR
     show_mmr32_reg RTTC_RTVR

Modified: trunk/tcl/chip/atmel/at91/usarts.tcl
===================================================================
--- trunk/tcl/chip/atmel/at91/usarts.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/chip/atmel/at91/usarts.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -48,7 +48,7 @@
 
     set x [show_normalize_bitfield $VAL 11 9]
     set s "unknown"
-    switch -exact $x { 
+    switch -exact $x {
 	0 { set s "Even" }
 	1 { set s "Odd" }
 	2 { set s "Force=0" }
@@ -62,7 +62,7 @@
 	}
     }
     puts [format "\tParity: %s " $s]
-    
+
     set x [expr 5 + [show_normalize_bitfield $VAL 7 6]]
     puts [format "\tDatabits: %d" $x]
 
@@ -80,7 +80,7 @@
     set n AT91C_BASE_[set WHO]
     set str ""
 
-    # Only if it exists on the chip 
+    # Only if it exists on the chip
     if [ info exists $n ] {
 	# Hence: $n - is like AT91C_BASE_USx
 	# For every sub-register
@@ -114,12 +114,12 @@
 
 
 # For every sub-register
-foreach REG {DBGU_CR DBGU_MR DBGU_IER DBGU_IDR DBGU_IMR 
+foreach REG {DBGU_CR DBGU_MR DBGU_IER DBGU_IDR DBGU_IMR
     DBGU_CSR DBGU_RHR DBGU_THR DBGU_BRGR DBGU_CIDR DBGU_EXID DBGU_FNTR} {
 
     # Create a command for this specific register.
     proc show_$REG { } "show_mmr32_reg $REG"
-    
+
     # Add this command to the Device(as a whole) command
     set str "$str\nshow_$REG"
 }

Modified: trunk/tcl/chip/st/stm32/stm32_rcc.tcl
===================================================================
--- trunk/tcl/chip/st/stm32/stm32_rcc.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/chip/st/stm32/stm32_rcc.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -16,7 +16,7 @@
 	error $msg
     }
 
-    show_mmr_bitfield  0  0 $val HSI      { OFF ON } 
+    show_mmr_bitfield  0  0 $val HSI      { OFF ON }
     show_mmr_bitfield  1  1 $val HSIRDY   { NOTRDY RDY  }
     show_mmr_bitfield  7  3 $val HSITRIM  { _NUMBER_ }
     show_mmr_bitfield 15  8 $val HSICAL   { _NUMBER_ }
@@ -26,8 +26,8 @@
     show_mmr_bitfield 19 19 $val CSSON    { OFF ON }
     show_mmr_bitfield 24 24 $val PLLON    { OFF ON }
     show_mmr_bitfield 25 25 $val PLLRDY   { NOTRDY RDY }
-}    
-	
+}
+
 proc show_RCC_CFGR { } {
     if [ catch { set val [show_mmr32_reg RCC_CFGR] } msg ] {
 	error $msg
@@ -47,12 +47,12 @@
     show_mmr_bitfield 26 24 $val  MCO    { none none none none SysClk HSI HSE PLL_div2 }
 }
 
-    
+
 proc show_RCC_CIR { } {
     if [ catch { set val [show_mmr32_reg RCC_CIR] } msg ] {
 	error $msg
     }
- 
+
 }
 
 proc show_RCC_APB2RSTR { } {
@@ -106,7 +106,7 @@
     set bits(13) xxx
     set bits(12) xxx
     set bits(11) wwdg
-    set bits(10) xxx 
+    set bits(10) xxx
     set bits(9) xxx
     set bits(8) xxx
     set bits(7) xxx
@@ -118,7 +118,7 @@
     set bits(1) tim3
     set bits(0) tim2
     show_mmr32_bits bits $val
-    
+
 }
 
 proc show_RCC_AHBENR   { } {
@@ -141,7 +141,7 @@
     set bits(18) xxx
     set bits(17) xxx
     set bits(16) xxx
-    set bits(15) xxx  
+    set bits(15) xxx
     set bits(14) xxx
     set bits(13) xxx
     set bits(12) xxx
@@ -180,7 +180,7 @@
     set bits(18) xxx
     set bits(17) xxx
     set bits(16) xxx
-    set bits(15) adc3  
+    set bits(15) adc3
     set bits(14) usart1
     set bits(13) tim8
     set bits(12) spi1

Modified: trunk/tcl/memory.tcl
===================================================================
--- trunk/tcl/memory.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/memory.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,4 +1,4 @@
-# MEMORY 
+# MEMORY
 #
 # All Memory regions have two components.
 #    (1) A count of regions, in the form N_NAME
@@ -62,7 +62,7 @@
 }
 
 proc address_info { ADDRESS } {
-    
+
     foreach WHERE { FLASH RAM MMREGS XMEM UNKNOWN } {
 	if { info exists $WHERE } {
 	    set lmt [set N_[set WHERE]]
@@ -85,7 +85,7 @@
     } else {
 	error "memread32: $msg"
     }
-}    
+}
 
 proc memread16 {ADDR} {
     set foo(0) 0
@@ -94,7 +94,7 @@
     } else {
 	error "memread16: $msg"
     }
-}    
+}
 
 proc memread8 {ADDR} {
     set foo(0) 0
@@ -103,7 +103,7 @@
     } else {
 	error "memread8: $msg"
     }
-}    
+}
 
 proc memwrite32 {ADDR DATA} {
     set foo(0) $DATA
@@ -112,7 +112,7 @@
     } else {
 	error "memwrite32: $msg"
     }
-}    
+}
 
 proc memwrite16 {ADDR DATA} {
     set foo(0) $DATA
@@ -121,7 +121,7 @@
     } else {
 	error "memwrite16: $msg"
     }
-}    
+}
 
 proc memwrite8 {ADDR DATA} {
     set foo(0) $DATA
@@ -130,4 +130,4 @@
     } else {
 	error "memwrite8: $msg"
     }
-}    
+}

Modified: trunk/tcl/mmr_helpers.tcl
===================================================================
--- trunk/tcl/mmr_helpers.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/mmr_helpers.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -7,7 +7,7 @@
 
 # Give: REGISTER name - must be a global variable.
 proc show_mmr32_reg { NAME } {
-    
+
     global $NAME
     # we want $($NAME)
     set a [set [set NAME]]
@@ -41,7 +41,7 @@
 	set l [string length $N]
 	if { $l > $w } { set w $l }
     }
-    
+
     for { set x 24 } { $x >= 0 } { incr x -8 } {
 	puts -nonewline "  "
 	for { set y 7 } { $y >= 0 } { incr y -1 } {

Modified: trunk/tcl/readable.tcl
===================================================================
--- trunk/tcl/readable.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/readable.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -22,4 +22,3 @@
 }
 
 proc isreadable32 { ADDRESS } {
-    
\ No newline at end of file

Modified: trunk/tcl/target/aduc702x.cfg
===================================================================
--- trunk/tcl/target/aduc702x.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/aduc702x.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -2,22 +2,22 @@
 ##
 
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME aduc702x
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # This config file was defaulting to big endian..
    set  _ENDIAN little
 }
 
-if { [info exists CPUTAPID] } {	
-   set  _CPUTAPID $CPUTAPID    
-} else {	 
+if { [info exists CPUTAPID] } {
+   set  _CPUTAPID $CPUTAPID
+} else {
    set  _CPUTAPID 0x3f0f0f0f
 }
 
@@ -26,7 +26,7 @@
 jtag_ntrst_delay 200
 
 # This is for the case that TRST/SRST is not wired on your JTAG adaptor.
-# Don't really need them anyways.  
+# Don't really need them anyways.
 reset_config none
 
 ## JTAG scan chain

Modified: trunk/tcl/target/ar71xx.cfg
===================================================================
--- trunk/tcl/target/ar71xx.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/ar71xx.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -29,11 +29,11 @@
 	mww 0xb8050000 0x800f00e8       # clr pwrdwn & bypass
 	mww 0xb8050008 1		# set clock_switch bit
 	sleep 1                         # wait for lock
-	
+
 	# Setup DDR config and flash mapping
 	mww 0xb8000000 0xefbc8cd0       # DDR cfg cdl val (rst: 0x5bfc8d0)
 	mww 0xb8000004 0x8e7156a2       # DDR cfg2 cdl val (rst: 0x80d106a8)
-	
+
 	mww 0xb8000010 8		# force precharge all banks
 	mww 0xb8000010 1 		# force EMRS update cycle
 	mww 0xb800000c 0                # clr ext. mode register
@@ -47,7 +47,7 @@
 	mww 0xb8000020 0
 	mww 0xb8000024 0
 	mww 0xb8000028 0
-}	
+}
 
 # setup working area somewhere in RAM
 $TARGETNAME configure -work-area-phys 0xa0600000 -work-area-size 0x20000

Modified: trunk/tcl/target/at91eb40a.cfg
===================================================================
--- trunk/tcl/target/at91eb40a.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/at91eb40a.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 #Script for AT91EB40a
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME at91eb40a
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -28,7 +28,7 @@
 #SRST reset, which means that the CPU will run a number
 #of cycles before it can be halted(as much as milliseconds).
 reset_config srst_only srst_pulls_trst
- 
+
 #jtag scan chain
 #format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
@@ -53,9 +53,9 @@
 	# Reset script for AT91EB40a
 	reg cpsr 0x000000D3
 	mww 0xFFE00020 0x1
-	mww 0xFFE00024 0x00000000  
-	mww 0xFFE00000 0x01002539 
-	mww 0xFFFFF124 0xFFFFFFFF  
+	mww 0xFFE00024 0x00000000
+	mww 0xFFE00000 0x01002539
+	mww 0xFFFFF124 0xFFFFFFFF
 	mww 0xffff0010 0x100
 	mww 0xffff0034 0x100
 }

Modified: trunk/tcl/target/at91r40008.cfg
===================================================================
--- trunk/tcl/target/at91r40008.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/at91r40008.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME at9r40008
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/at91rm9200.cfg
===================================================================
--- trunk/tcl/target/at91rm9200.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/at91rm9200.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -3,15 +3,15 @@
 
 reset_config trst_and_srst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME at91rm9200
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -39,7 +39,7 @@
 
 # Create the GDB Target.
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME 
+target create $_TARGETNAME arm920t -endian $_ENDIAN -chain-position $_TARGETNAME
 
 # AT91RM9200 has a 16K block of sram @ 0x0020.0000
 $_TARGETNAME configure -work-area-virt 0x00200000 -work-area-phys 0x00200000 \

Modified: trunk/tcl/target/at91sam3uXX.cfg
===================================================================
--- trunk/tcl/target/at91sam3uXX.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/at91sam3uXX.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -7,15 +7,15 @@
 #  at91sam3u2c
 #  at91sam3u1c
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME sam3
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/at91sam7sx.cfg
===================================================================
--- trunk/tcl/target/at91sam7sx.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/at91sam7sx.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config srst_only srst_pulls_trst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME at91sam7s
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -24,26 +24,26 @@
 set _TARGETNAME $_CHIPNAME.cpu
 
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
-$_TARGETNAME configure -event reset-init { 
+$_TARGETNAME configure -event reset-init {
         soft_reset_halt
         # RSTC_CR : Reset peripherals
         mww 0xfffffd00 0xa5000004
         # disable watchdog
-	mww 0xfffffd44 0x00008000	
+	mww 0xfffffd44 0x00008000
 	# enable user reset
-	mww 0xfffffd08 0xa5000001	
+	mww 0xfffffd08 0xa5000001
 	# CKGR_MOR : enable the main oscillator
-	mww 0xfffffc20 0x00000601	
+	mww 0xfffffc20 0x00000601
 	sleep 10
 	# CKGR_PLLR: 96.1097 MHz
-	mww 0xfffffc2c 0x00481c0e 	
+	mww 0xfffffc2c 0x00481c0e
 	sleep 10
 	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
-	mww 0xfffffc30 0x00000007	
+	mww 0xfffffc30 0x00000007
 	sleep 10
 	# MC_FMR: flash mode (FWS=1,FMCN=73)
-	mww 0xffffff60 0x00490100	
-	sleep 100        
+	mww 0xffffff60 0x00490100
+	sleep 100
 }
 
 $_TARGETNAME configure -work-area-virt 0 -work-area-phys 0x00200000 -work-area-size 0x4000 -work-area-backup 0

Modified: trunk/tcl/target/at91sam9260.cfg
===================================================================
--- trunk/tcl/target/at91sam9260.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/at91sam9260.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -2,15 +2,15 @@
 # Target:    Atmel AT91SAM9260
 ######################################
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME at91sam9260
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
===================================================================
--- trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -8,15 +8,15 @@
 # Target:    Atmel AT91SAM9260
 ######################################
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME at91sam9260
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -59,7 +59,7 @@
 
 
 proc at91sam_init { } {
-	
+
 	# at reset chip runs at 32khz
 	jtag_khz 8
 	halt

Modified: trunk/tcl/target/c100.cfg
===================================================================
--- trunk/tcl/target/c100.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/c100.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -5,15 +5,15 @@
 # assume no PLL lock, start slowly
 jtag_khz 100
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME c100
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/c100config.tcl
===================================================================
--- trunk/tcl/target/c100config.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/c100config.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -3,7 +3,7 @@
 
 # set CFG_REFCLKFREQ [configC100 CFG_REFCLKFREQ]
 proc config {label} {
-    return [dict get [configC100] $label ]	
+    return [dict get [configC100] $label ]
 }
 
 # show the value for the param. with label
@@ -15,7 +15,7 @@
 # when there are more then one board config
 # use soft links to c100board-config.tcl
 # so that only the right board-config gets
-# included (just like include/configs/board-configs.h 
+# included (just like include/configs/board-configs.h
 # in u-boot.
 proc configC100 {} {
     # xtal freq. 24MHz
@@ -28,7 +28,7 @@
     # y = amba_clk * (w+1)*(x+1)*2/xtal_clk
     dict set configC100 y_amba [expr ([dict get $configC100 CONFIG_SYS_HZ_CLOCK] * ( ([dict get $configC100 w_amba]+1 ) * ([dict get $configC100 x_amba]+1 ) *2 ) / [dict get $configC100 CFG_REFCLKFREQ]) ]
 
-    # Arm Clk 450MHz, must be a multiple of 25 MHz 
+    # Arm Clk 450MHz, must be a multiple of 25 MHz
     dict set configC100 CFG_ARM_CLOCK      450000000
     dict set configC100 w_arm 0
     dict set configC100 x_arm 1
@@ -41,17 +41,17 @@
 proc setupNOR {} {
     puts "Setting up NOR: 16MB, 16-bit wide bus, CS0"
     # this is taken from u-boot/boards/mindspeed/ooma-darwin/board.c:nor_hw_init()
-    set EX_CSEN_REG	    [regs EX_CSEN_REG ]	
-    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]	
-    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]	
-    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]	
-    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]	
-    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]	
+    set EX_CSEN_REG	    [regs EX_CSEN_REG ]
+    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]
+    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]
+    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]
+    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]
+    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]
     set EX_CLOCK_DIV_REG    [regs EX_CLOCK_DIV_REG ]
-    set EX_MFSM_REG	    [regs EX_MFSM_REG ]	
-    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]	
-    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]	
-    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]	
+    set EX_MFSM_REG	    [regs EX_MFSM_REG ]
+    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]
+    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]
+    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]
 
     # enable Expansion Bus Clock + CS0 (NOR)
     mww $EX_CSEN_REG 0x3
@@ -62,7 +62,7 @@
     # set timings to NOR
     mww $EX_CS0_TMG1_REG 0x03034006
     mww $EX_CS0_TMG2_REG 0x04040002
-    #mww $EX_CS0_TMG3_REG 
+    #mww $EX_CS0_TMG3_REG
     # set EBUS clock 165/5=33MHz
     mww $EX_CLOCK_DIV_REG 0x5
     # everthing else is OK with default
@@ -72,7 +72,7 @@
     set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]
     set BLOCK_RESET_REG	       [regs BLOCK_RESET_REG]
     set DDR_RST		       [regs DDR_RST]
- 
+
     # put DDR controller in reset (so that it comes reset in u-boot)
     mmw $BLOCK_RESET_REG 0x0 $DDR_RST
     # setup CS0 controller for NOR
@@ -93,8 +93,8 @@
     #GPIO17 reset for DECT module.
     #GPIO29 CS_n for NAND
 
-    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
-    set GPIO_OE_REG		    [regs GPIO_OE_REG]	
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
+    set GPIO_OE_REG		    [regs GPIO_OE_REG]
 
     # set GPIO29=GPIO17=1, GPIO5=0
     mww $GPIO_OUTPUT_REG [expr 1<<29 | 1<<17]
@@ -104,14 +104,14 @@
 
 proc highGPIO5 {} {
     puts "GPIO5 high"
-    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
     # set GPIO5=1
     mmw $GPIO_OUTPUT_REG [expr 1 << 5] 0x0
 }
 
 proc lowGPIO5 {} {
     puts "GPIO5 low"
-    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
     # set GPIO5=0
     mmw $GPIO_OUTPUT_REG 0x0 [expr 1 << 5]
 }
@@ -119,31 +119,31 @@
 proc boardID {id} {
     # so far built:
     # 4'b1111
-    dict set boardID 15 name "EVT1"		
+    dict set boardID 15 name "EVT1"
     dict set boardID 15 ddr2size 128M
     # dict set boardID 15 nandsize 1G
     # dict set boardID 15 norsize 16M
     # 4'b0000
-    dict set boardID 0 name "EVT2"		
+    dict set boardID 0 name "EVT2"
     dict set boardID 0 ddr2size 128M
     # 4'b0001
-    dict set boardID 1 name "EVT3"		
+    dict set boardID 1 name "EVT3"
     dict set boardID 1 ddr2size 256M
     # 4'b1110
     dict set boardID 14 name "EVT3_old"
     dict set boardID 14 ddr2size 128M
     # 4'b0010
-    dict set boardID 2 name "EVT4"		
+    dict set boardID 2 name "EVT4"
     dict set boardID 2 ddr2size 256M
 
     return $boardID
 }
 
 # converted from u-boot/boards/mindspeed/ooma-darwin/board.c:ooma_board_detect()
-# figure out what board revision this is, uses BOOTSTRAP register to read stuffed resistors 
+# figure out what board revision this is, uses BOOTSTRAP register to read stuffed resistors
 proc ooma_board_detect {} {
     set GPIO_BOOTSTRAP_REG	[regs GPIO_BOOTSTRAP_REG]
-    
+
     # read the current value of the BOOTSRAP pins
     set tmp [mrw $GPIO_BOOTSTRAP_REG]
     puts [format "GPIO_BOOTSTRAP_REG  (0x%x): 0x%x" $GPIO_BOOTSTRAP_REG $tmp]
@@ -187,9 +187,9 @@
     set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]
 
 
-    set DENALI_CTL_02_VAL 0x0100010000010100 
+    set DENALI_CTL_02_VAL 0x0100010000010100
     set DENALI_CTL_11_VAL 0x433A42124A650A37
-    # set some default values     
+    # set some default values
     mw64bit $DENALI_CTL_00_DATA  0x0100000101010101
     mw64bit $DENALI_CTL_01_DATA  0x0100000100000101
     mw64bit $DENALI_CTL_02_DATA  $DENALI_CTL_02_VAL
@@ -218,7 +218,7 @@
     # wait int_status[2] (DRAM init complete)
     puts -nonewline "Waiting for DDR2 controller to init..."
     set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
-    while { [expr $tmp & 0x040000] == 0 } { 
+    while { [expr $tmp & 0x040000] == 0 } {
 	sleep 1
 	set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
     }
@@ -237,18 +237,18 @@
     set GPIO_IOCTRL_REG    [regs GPIO_IOCTRL_REG]
     set GPIO_IOCTRL_VAL    [regs GPIO_IOCTRL_VAL]
     set GPIO_IOCTRL_UART0  [regs GPIO_IOCTRL_UART0]
-    set UART0_LCR	            [regs UART0_LCR]	
-    set LCR_DLAB		    [regs LCR_DLAB]	
-    set UART0_DLL		    [regs UART0_DLL]		
-    set UART0_DLH		    [regs UART0_DLH]	
-    set UART0_IIR		    [regs UART0_IIR]	
-    set UART0_IER		    [regs UART0_IER]	
-    set LCR_ONE_STOP		    [regs LCR_ONE_STOP]		
-    set LCR_CHAR_LEN_8		    [regs LCR_CHAR_LEN_8]		
+    set UART0_LCR	            [regs UART0_LCR]
+    set LCR_DLAB		    [regs LCR_DLAB]
+    set UART0_DLL		    [regs UART0_DLL]
+    set UART0_DLH		    [regs UART0_DLH]
+    set UART0_IIR		    [regs UART0_IIR]
+    set UART0_IER		    [regs UART0_IER]
+    set LCR_ONE_STOP		    [regs LCR_ONE_STOP]
+    set LCR_CHAR_LEN_8		    [regs LCR_CHAR_LEN_8]
     set FCR_XMITRES		    [regs FCR_XMITRES]
-    set FCR_RCVRRES		    [regs FCR_RCVRRES]	
-    set FCR_FIFOEN		    [regs FCR_FIFOEN]	
-    set IER_UUE			    [regs IER_UUE]		
+    set FCR_RCVRRES		    [regs FCR_RCVRRES]
+    set FCR_FIFOEN		    [regs FCR_FIFOEN]
+    set IER_UUE			    [regs IER_UUE]
 
     # unlock writing to IOCTRL register
     mww $GPIO_LOCK_REG $GPIO_IOCTRL_VAL
@@ -274,7 +274,7 @@
 
 proc putcUART0 {char} {
 
-    set UART0_LSR	    [regs UART0_LSR]	
+    set UART0_LSR	    [regs UART0_LSR]
     set UART0_THR	    [regs UART0_THR]
     set LSR_TEMT	    [regs LSR_TEMT]
 
@@ -311,7 +311,7 @@
 proc flashUBOOT {} {
     # this will update uboot on NOR partition
     set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]
-    
+
     # setup CS0 controller for NOR
     setupNOR
     # make sure we are accessing the lower part of NOR

Modified: trunk/tcl/target/c100helper.tcl
===================================================================
--- trunk/tcl/target/c100helper.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/c100helper.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -61,17 +61,17 @@
 
 proc showNOR {} {
     puts "This is the current NOR setup"
-    set EX_CSEN_REG	    [regs EX_CSEN_REG ]	
-    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]	
-    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]	
-    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]	
-    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]	
-    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]	
+    set EX_CSEN_REG	    [regs EX_CSEN_REG ]
+    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]
+    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]
+    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]
+    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]
+    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]
     set EX_CLOCK_DIV_REG    [regs EX_CLOCK_DIV_REG ]
-    set EX_MFSM_REG	    [regs EX_MFSM_REG ]	
-    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]	
-    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]	
-    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]	
+    set EX_MFSM_REG	    [regs EX_MFSM_REG ]
+    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]
+    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]
+    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]
 
     puts [format "EX_CSEN_REG      (0x%x): 0x%x" $EX_CSEN_REG [mrw $EX_CSEN_REG]]
     puts [format "EX_CS0_SEG_REG   (0x%x): 0x%x" $EX_CS0_SEG_REG [mrw $EX_CS0_SEG_REG]]
@@ -91,21 +91,21 @@
 proc showGPIO {} {
     puts "This is the current GPIO register setup"
     # GPIO outputs register
-    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]		
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
     # GPIO Output Enable register
-    set GPIO_OE_REG		    [regs GPIO_OE_REG]		
-    set GPIO_HI_INT_ENABLE_REG	    [regs GPIO_HI_INT_ENABLE_REG]	
-    set GPIO_LO_INT_ENABLE_REG	    [regs GPIO_LO_INT_ENABLE_REG]	
+    set GPIO_OE_REG		    [regs GPIO_OE_REG]
+    set GPIO_HI_INT_ENABLE_REG	    [regs GPIO_HI_INT_ENABLE_REG]
+    set GPIO_LO_INT_ENABLE_REG	    [regs GPIO_LO_INT_ENABLE_REG]
     # GPIO input register
-    set GPIO_INPUT_REG		    [regs GPIO_INPUT_REG]		
-    set APB_ACCESS_WS_REG	    [regs APB_ACCESS_WS_REG]	
-    set MUX_CONF_REG		    [regs MUX_CONF_REG]		
-    set SYSCONF_REG		    [regs SYSCONF_REG]		
-    set GPIO_ARM_ID_REG		    [regs GPIO_ARM_ID_REG]		
-    set GPIO_BOOTSTRAP_REG	    [regs GPIO_BOOTSTRAP_REG]	
-    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]		
-    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]		
-    set GPIO_DEVID_REG		    [regs GPIO_DEVID_REG]		
+    set GPIO_INPUT_REG		    [regs GPIO_INPUT_REG]
+    set APB_ACCESS_WS_REG	    [regs APB_ACCESS_WS_REG]
+    set MUX_CONF_REG		    [regs MUX_CONF_REG]
+    set SYSCONF_REG		    [regs SYSCONF_REG]
+    set GPIO_ARM_ID_REG		    [regs GPIO_ARM_ID_REG]
+    set GPIO_BOOTSTRAP_REG	    [regs GPIO_BOOTSTRAP_REG]
+    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]
+    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]
+    set GPIO_DEVID_REG		    [regs GPIO_DEVID_REG]
 
     puts [format "GPIO_OUTPUT_REG       (0x%x): 0x%x" $GPIO_OUTPUT_REG [mrw $GPIO_OUTPUT_REG]]
     puts [format "GPIO_OE_REG           (0x%x): 0x%x" $GPIO_OE_REG [mrw $GPIO_OE_REG]]
@@ -129,7 +129,7 @@
     set CFG_REFCLKFREQ		     [config CFG_REFCLKFREQ]
     set CLKCORE_AHB_CLK_CNTRL	     [regs CLKCORE_AHB_CLK_CNTRL]
     set PLL_CLK_BYPASS	             [regs PLL_CLK_BYPASS]
-    
+
     puts [format "CLKCORE_AHB_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_AHB_CLK_CNTRL [mrw $CLKCORE_AHB_CLK_CNTRL]]
     ocd_mem2array value 32 $CLKCORE_AHB_CLK_CNTRL 1
     # see if the PLL is in bypass mode
@@ -153,13 +153,13 @@
 # converted from u-boot/cpu/arm1136/comcerto/bsp100.c (HAL_set_amba_clk())
 # this clock is useb by all peripherals (DDR2, ethernet, ebus, etc)
 proc setupAmbaClk {} {
-    set CLKCORE_PLL_STATUS           [regs CLKCORE_PLL_STATUS]       
+    set CLKCORE_PLL_STATUS           [regs CLKCORE_PLL_STATUS]
     set CLKCORE_AHB_CLK_CNTRL	     [regs CLKCORE_AHB_CLK_CNTRL]
     set ARM_PLL_BY_CTRL	    [regs ARM_PLL_BY_CTRL]
     set ARM_AHB_BYP	    [regs ARM_AHB_BYP]
     set PLL_DISABLE	    [regs PLL_DISABLE]
-    set PLL_CLK_BYPASS	    [regs PLL_CLK_BYPASS]	
-    set AHB_PLL_BY_CTRL	    [regs AHB_PLL_BY_CTRL]	
+    set PLL_CLK_BYPASS	    [regs PLL_CLK_BYPASS]
+    set AHB_PLL_BY_CTRL	    [regs AHB_PLL_BY_CTRL]
     set DIV_BYPASS	    [regs DIV_BYPASS]
     set AHBCLK_PLL_LOCK	    [regs AHBCLK_PLL_LOCK]
     set CFG_REFCLKFREQ		 [config CFG_REFCLKFREQ]
@@ -204,7 +204,7 @@
     set CFG_REFCLKFREQ		[config CFG_REFCLKFREQ]
     set CLKCORE_ARM_CLK_CNTRL	[regs CLKCORE_ARM_CLK_CNTRL]
     set PLL_CLK_BYPASS	        [regs PLL_CLK_BYPASS]
-    
+
     puts [format "CLKCORE_ARM_CLK_CNTRL       (0x%x): 0x%x" $CLKCORE_ARM_CLK_CNTRL [mrw $CLKCORE_ARM_CLK_CNTRL]]
     ocd_mem2array value 32 $CLKCORE_ARM_CLK_CNTRL 1
     # see if the PLL is in bypass mode
@@ -232,8 +232,8 @@
     set ARM_PLL_BY_CTRL	          [regs ARM_PLL_BY_CTRL]
     set ARM_AHB_BYP	          [regs ARM_AHB_BYP]
     set PLL_DISABLE	          [regs PLL_DISABLE]
-    set PLL_CLK_BYPASS	          [regs PLL_CLK_BYPASS]	
-    set AHB_PLL_BY_CTRL	          [regs AHB_PLL_BY_CTRL]	
+    set PLL_CLK_BYPASS	          [regs PLL_CLK_BYPASS]
+    set AHB_PLL_BY_CTRL	          [regs AHB_PLL_BY_CTRL]
     set DIV_BYPASS	          [regs DIV_BYPASS]
     set FCLK_PLL_LOCK	          [regs FCLK_PLL_LOCK]
     set CFG_REFCLKFREQ		[config CFG_REFCLKFREQ]
@@ -283,12 +283,12 @@
 # converted from u-boot/cpu/arm1136/bsp100.c:SoC_mem_init()
 proc setupDDR2 {} {
     puts "Configuring DDR2"
-    
+
     set MEMORY_BASE_ADDR	    [regs  MEMORY_BASE_ADDR]
-    set MEMORY_MAX_ADDR	            [regs  MEMORY_MAX_ADDR]        
+    set MEMORY_MAX_ADDR	            [regs  MEMORY_MAX_ADDR]
     set MEMORY_CR 		    [regs  MEMORY_CR]
-    set BLOCK_RESET_REG		    [regs  BLOCK_RESET_REG]		
-    set DDR_RST		            [regs  DDR_RST]        
+    set BLOCK_RESET_REG		    [regs  BLOCK_RESET_REG]
+    set DDR_RST		            [regs  DDR_RST]
 
     # put DDR controller in reset (so that it is reset and correctly configured)
     # this is only necessary if DDR was previously confiured
@@ -334,7 +334,7 @@
 
 
 proc showDDR2 {} {
- 
+
     set DENALI_CTL_00_DATA    [regs DENALI_CTL_00_DATA]
     set DENALI_CTL_01_DATA    [regs DENALI_CTL_01_DATA]
     set DENALI_CTL_02_DATA    [regs DENALI_CTL_02_DATA]
@@ -399,22 +399,22 @@
     puts [format "DENALI_CTL_19_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_19_DATA $tmp(1) $tmp(0)]
     set tmp [mr64bit $DENALI_CTL_20_DATA]
     puts [format "DENALI_CTL_20_DATA   (0x%x): 0x%08x%08x" $DENALI_CTL_20_DATA $tmp(1) $tmp(0)]
-    
+
 }
 
 proc initC100 {} {
-    # this follows u-boot/cpu/arm1136/start.S 
-    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]		
-    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]		
-    set GPIO_IOCTRL_VAL	            [regs GPIO_IOCTRL_VAL]	
+    # this follows u-boot/cpu/arm1136/start.S
+    set GPIO_LOCK_REG		    [regs GPIO_LOCK_REG]
+    set GPIO_IOCTRL_REG		    [regs GPIO_IOCTRL_REG]
+    set GPIO_IOCTRL_VAL	            [regs GPIO_IOCTRL_VAL]
     set APB_ACCESS_WS_REG           [regs APB_ACCESS_WS_REG]
     set ASA_ARAM_BASEADDR	    [regs ASA_ARAM_BASEADDR]
-    set ASA_ARAM_TC_CR_REG	    [regs ASA_ARAM_TC_CR_REG]	
+    set ASA_ARAM_TC_CR_REG	    [regs ASA_ARAM_TC_CR_REG]
     set ASA_EBUS_BASEADDR	    [regs ASA_EBUS_BASEADDR]
-    set ASA_EBUS_TC_CR_REG	    [regs ASA_EBUS_TC_CR_REG]	
+    set ASA_EBUS_TC_CR_REG	    [regs ASA_EBUS_TC_CR_REG]
     set ASA_TC_REQIDMAEN	    [regs ASA_TC_REQIDMAEN]
-    set ASA_TC_REQTDMEN	            [regs ASA_TC_REQTDMEN]        
-    set ASA_TC_REQIPSECUSBEN        [regs ASA_TC_REQIPSECUSBEN]    
+    set ASA_TC_REQTDMEN	            [regs ASA_TC_REQTDMEN]
+    set ASA_TC_REQIPSECUSBEN        [regs ASA_TC_REQIPSECUSBEN]
     set ASA_TC_REQARM0EN	    [regs ASA_TC_REQARM0EN]
     set ASA_TC_REQARM1EN	    [regs ASA_TC_REQARM1EN]
     set ASA_TC_REQMDMAEN	    [regs ASA_TC_REQMDMAEN]
@@ -428,7 +428,7 @@
     # set ARM into supervisor mode (SVC32)
     # disable IRQ, FIQ
     # Do I need this in JTAG mode?
-    # it really should be done as 'and ~0x1f | 0xd3 but 
+    # it really should be done as 'and ~0x1f | 0xd3 but
     # openocd does not support this yet
     reg cpsr 0xd3
     #	/*
@@ -444,12 +444,12 @@
     #	 * disable MMU stuff and caches
     #	 */
     #	mrc	p15, 0, r0, c1, c0, 0
-    arm11 mrc c100.cpu 15 0 1 0 0  
+    arm11 mrc c100.cpu 15 0 1 0 0
     #	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
     #	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
     #	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
     #	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
-    #	orr	r0, r0, #0x00400000	@ set bit 22 (U) 
+    #	orr	r0, r0, #0x00400000	@ set bit 22 (U)
     #	mcr	p15, 0, r0, c1, c0, 0
     arm11 mcr c100.cpu 15 0 1 0 0 0x401002
     # This is from bsp_init() in u-boot/boards/mindspeed/ooma-darwin/board.c
@@ -464,10 +464,10 @@
     mmw $ASA_EBUS_TC_CR_REG [expr $ASA_TC_REQIDMAEN | $ASA_TC_REQTDMEN | $ASA_TC_REQIPSECUSBEN | $ASA_TC_REQARM0EN | $ASA_TC_REQARM1EN | $ASA_TC_REQMDMAEN] 0x0
 
     # ARAM init
-    #	// disable pipeline mode in ARAM 
+    #	// disable pipeline mode in ARAM
     # I don't think this is documented anywhere?
     mww $INTC_ARM1_CONTROL_REG 0x1
-    # configure clocks 
+    # configure clocks
     setupPLL
     # enable cache
     # ? (u-boot does nothing here)
@@ -481,9 +481,9 @@
 # show current state of watchdog timer
 proc showWatchdog {} {
     set TIMER_WDT_HIGH_BOUND	[regs TIMER_WDT_HIGH_BOUND]
-    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]	
+    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]
     set TIMER_WDT_CURRENT_COUNT	[regs TIMER_WDT_CURRENT_COUNT]
-    
+
     puts [format "TIMER_WDT_HIGH_BOUND    (0x%x): 0x%x" $TIMER_WDT_HIGH_BOUND [mrw $TIMER_WDT_HIGH_BOUND]]
     puts [format "TIMER_WDT_CONTROL       (0x%x): 0x%x" $TIMER_WDT_CONTROL [mrw $TIMER_WDT_CONTROL]]
     puts [format "TIMER_WDT_CURRENT_COUNT (0x%x): 0x%x" $TIMER_WDT_CURRENT_COUNT [mrw $TIMER_WDT_CURRENT_COUNT]]
@@ -495,7 +495,7 @@
 # watchdog reset effectively works as hw. reset
 proc reboot {} {
     set TIMER_WDT_HIGH_BOUND	[regs TIMER_WDT_HIGH_BOUND]
-    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]	
+    set TIMER_WDT_CONTROL	[regs TIMER_WDT_CONTROL]
     set TIMER_WDT_CURRENT_COUNT	[regs TIMER_WDT_CURRENT_COUNT]
 
     # allow the counter to count to high value  before triggering
@@ -508,10 +508,10 @@
     mww $TIMER_WDT_CONTROL 0x1
     # wait until the reset
     puts -nonewline "Wating for watchdog to trigger..."
-    #while {[mrw $TIMER_WDT_CONTROL] == 1} { 
-    #    puts [format "TIMER_WDT_CURRENT_COUNT (0x%x): 0x%x" $TIMER_WDT_CURRENT_COUNT [mrw $TIMER_WDT_CURRENT_COUNT]]	    
-    #    sleep 1 
-    #    
+    #while {[mrw $TIMER_WDT_CONTROL] == 1} {
+    #    puts [format "TIMER_WDT_CURRENT_COUNT (0x%x): 0x%x" $TIMER_WDT_CURRENT_COUNT [mrw $TIMER_WDT_CURRENT_COUNT]]
+    #    sleep 1
+    #
     #}
     while {[c100.cpu curstate] != "running"} { sleep 1}
     puts "done."

Modified: trunk/tcl/target/c100regs.tcl
===================================================================
--- trunk/tcl/target/c100regs.tcl	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/c100regs.tcl	2009-09-21 18:48:22 UTC (rev 2743)
@@ -7,7 +7,7 @@
 # For example:
 # set EX_CS_TMG1_REG [regs EX_CS0_TMG1_REG]
 proc regs {reg} {
-    return [dict get [regsC100] $reg ]	
+    return [dict get [regsC100] $reg ]
 }
 
 proc showreg {reg} {
@@ -19,13 +19,13 @@
 #/* device memory base addresses */
 #// device memory sizes
 #/* ARAM SIZE=64K */
-dict set regsC100 ARAM_SIZE		0x00010000 
+dict set regsC100 ARAM_SIZE		0x00010000
 dict set regsC100 ARAM_BASEADDR	0x0A000000
 
 #/* Hardware Interface Units */
 dict set regsC100 APB_BASEADDR	0x10000000
 #/* APB_SIZE=16M address range */
-dict set regsC100 APB_SIZE		0x01000000 
+dict set regsC100 APB_SIZE		0x01000000
 
 dict set regsC100 EXP_CS0_BASEADDR       0x20000000
 dict set regsC100 EXP_CS1_BASEADDR       0x24000000
@@ -212,7 +212,7 @@
 
 # GPIO outputs register
 dict set regsC100 GPIO_OUTPUT_REG		[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x00]
-# GPIO Output Enable register	
+# GPIO Output Enable register
 dict set regsC100 GPIO_OE_REG		        [expr [dict get $regsC100 GPIO_BASEADDR ] + 0x04]
 dict set regsC100 GPIO_HI_INT_ENABLE_REG	[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x08]
 dict set regsC100 GPIO_LO_INT_ENABLE_REG	[expr [dict get $regsC100 GPIO_BASEADDR ] + 0x0C]
@@ -285,74 +285,74 @@
 dict set regsC100 UART1_SCR		[expr [dict get $regsC100 UART1_BASEADDR ] + 0x1C]
 
 # /* default */
-dict set regsC100 LCR_CHAR_LEN_5		0x00	  
+dict set regsC100 LCR_CHAR_LEN_5		0x00
 dict set regsC100 LCR_CHAR_LEN_6		0x01
 dict set regsC100 LCR_CHAR_LEN_7		0x02
 dict set regsC100 LCR_CHAR_LEN_8		0x03
 #/* One stop bit! - default */
 dict set regsC100 LCR_ONE_STOP		0x00
-#/* Two stop bit! */	  
-dict set regsC100 LCR_TWO_STOP		0x04	  
+#/* Two stop bit! */
+dict set regsC100 LCR_TWO_STOP		0x04
 #/* Parity Enable */
-dict set regsC100 LCR_PEN			0x08	  
+dict set regsC100 LCR_PEN			0x08
 dict set regsC100 LCR_PARITY_NONE		0x00
 #/* Even Parity Select */
-dict set regsC100 LCR_EPS			0x10	  
+dict set regsC100 LCR_EPS			0x10
 #/* Enable Parity  Stuff */
-dict set regsC100 LCR_PS			0x20	  
+dict set regsC100 LCR_PS			0x20
 #/* Start Break */
-dict set regsC100 LCR_SBRK		        0x40  
+dict set regsC100 LCR_SBRK		        0x40
 #/* Parity Stuff Bit */
-dict set regsC100 LCR_PSB			0x80	  
+dict set regsC100 LCR_PSB			0x80
 #/* UART 16550 Divisor Latch Assess */
-dict set regsC100 LCR_DLAB		        0x80  
+dict set regsC100 LCR_DLAB		        0x80
 
 #/* FIFO Error Status */
-dict set regsC100 LSR_FIFOE		[expr 1 << 7]	
+dict set regsC100 LSR_FIFOE		[expr 1 << 7]
 #/* Transmitter Empty */
 dict set regsC100 LSR_TEMT		[expr 1 << 6]
 #/* Transmit Data Request */
-dict set regsC100 LSR_TDRQ		[expr 1 << 5]	
+dict set regsC100 LSR_TDRQ		[expr 1 << 5]
 #/* Break Interrupt */
-dict set regsC100 LSR_BI			[expr 1 << 4]	
+dict set regsC100 LSR_BI			[expr 1 << 4]
 #/* Framing Error */
-dict set regsC100 LSR_FE			[expr 1 << 3]	
+dict set regsC100 LSR_FE			[expr 1 << 3]
 #/* Parity Error */
-dict set regsC100 LSR_PE			[expr 1 << 2]	
+dict set regsC100 LSR_PE			[expr 1 << 2]
 #/* Overrun Error */
-dict set regsC100 LSR_OE			[expr 1 << 1]	
+dict set regsC100 LSR_OE			[expr 1 << 1]
 #/* Data Ready */
-dict set regsC100 LSR_DR			[expr 1 << 0]	
+dict set regsC100 LSR_DR			[expr 1 << 0]
 
 #/* DMA Requests Enable */
-dict set regsC100 IER_DMAE		        [expr 1 << 7]	
+dict set regsC100 IER_DMAE		        [expr 1 << 7]
 #/* UART Unit Enable */
-dict set regsC100 IER_UUE			[expr 1 << 6]	
+dict set regsC100 IER_UUE			[expr 1 << 6]
 #/* NRZ coding Enable */
-dict set regsC100 IER_NRZE		        [expr 1 << 5]	
+dict set regsC100 IER_NRZE		        [expr 1 << 5]
 #/* Receiver Time Out Interrupt Enable */
-dict set regsC100 IER_RTIOE		        [expr 1 << 4]	
+dict set regsC100 IER_RTIOE		        [expr 1 << 4]
 #/* Modem Interrupt Enable */
-dict set regsC100 IER_MIE			[expr 1 << 3]	
+dict set regsC100 IER_MIE			[expr 1 << 3]
 #/* Receiver Line Status Interrupt Enable */
-dict set regsC100 IER_RLSE		        [expr 1 << 2]	
+dict set regsC100 IER_RLSE		        [expr 1 << 2]
 #/* Transmit Data request Interrupt Enable */
-dict set regsC100 IER_TIE			[expr 1 << 1]	
+dict set regsC100 IER_TIE			[expr 1 << 1]
 #/* Receiver Data Available Interrupt Enable */
-dict set regsC100 IER_RAVIE		        [expr 1 << 0]	
+dict set regsC100 IER_RAVIE		        [expr 1 << 0]
 
 #/* FIFO Mode Enable Status */
-dict set regsC100 IIR_FIFOES1		        [expr 1 << 7]	
+dict set regsC100 IIR_FIFOES1		        [expr 1 << 7]
 #/* FIFO Mode Enable Status */
-dict set regsC100 IIR_FIFOES0		        [expr 1 << 6]	
+dict set regsC100 IIR_FIFOES0		        [expr 1 << 6]
 #/* Time Out Detected */
-dict set regsC100 IIR_TOD			[expr 1 << 3]	
+dict set regsC100 IIR_TOD			[expr 1 << 3]
 #/* Interrupt Source Encoded */
-dict set regsC100 IIR_IID2		        [expr 1 << 2]	
+dict set regsC100 IIR_IID2		        [expr 1 << 2]
 #/* Interrupt Source Encoded */
-dict set regsC100 IIR_IID1		        [expr 1 << 1]	
+dict set regsC100 IIR_IID1		        [expr 1 << 1]
 #/* Interrupt Pending (active low) */
-dict set regsC100 IIR_IP			[expr 1 << 0]	
+dict set regsC100 IIR_IP			[expr 1 << 0]
 
 #/* UART 16550 FIFO Control Register */
 dict set regsC100 FCR_FIFOEN		0x01
@@ -362,14 +362,14 @@
 #/* Interrupt Enable Register */
 #// UART 16550
 #// Enable Received Data Available Interrupt
-dict set regsC100 IER_RXTH		0x01	
+dict set regsC100 IER_RXTH		0x01
 #// Enable Transmitter Empty Interrupt
-dict set regsC100 IER_TXTH		0x02	
+dict set regsC100 IER_TXTH		0x02
 
 
 
 #////////////////////////////////////////////////////////////
-#// CLK  + RESET block 
+#// CLK  + RESET block
 #////////////////////////////////////////////////////////////
 
 dict set regsC100 CLKCORE_ARM_CLK_CNTRL	[expr [dict get $regsC100 CLKCORE_BASEADDR ] + 0x00]

Modified: trunk/tcl/target/cs351x.cfg
===================================================================
--- trunk/tcl/target/cs351x.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/cs351x.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,12 +1,12 @@
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME cs351x
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/epc9301.cfg
===================================================================
--- trunk/tcl/target/epc9301.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/epc9301.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 # Cirrus Logic EP9301 processor on an Olimex CS-E9301 board.
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME ep9301
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/feroceon.cfg
===================================================================
--- trunk/tcl/target/feroceon.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/feroceon.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -2,15 +2,15 @@
 # Target:    Marvell Feroceon CPU core
 ######################################
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME feroceon
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/imx21.cfg
===================================================================
--- trunk/tcl/target/imx21.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/imx21.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -3,20 +3,20 @@
 # Hmmm.... should srst_pulls_trst be used here like i.MX27???
 reset_config trst_and_srst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME imx21
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
 
-# Note above there is 1 tap 
+# Note above there is 1 tap
 
 # The CPU tap
 if { [info exists CPUTAPID ] } {

Modified: trunk/tcl/target/imx27.cfg
===================================================================
--- trunk/tcl/target/imx27.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/imx27.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -6,20 +6,20 @@
 # failing, etc.
 reset_config trst_and_srst srst_pulls_trst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME imx27
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
 
-# Note above there are 2 taps 
+# Note above there are 2 taps
 
 # The bs tap
 if { [info exists BSTAPID ] } {

Modified: trunk/tcl/target/imx31.cfg
===================================================================
--- trunk/tcl/target/imx31.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/imx31.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -3,15 +3,15 @@
 
 reset_config trst_and_srst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME imx31
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -28,7 +28,7 @@
 }
 
 #========================================
-# The "system jtag controller" 
+# The "system jtag controller"
 # IMX31 reference manual, page 6-28 - figure 6-14
 if { [info exists SJCTAPID ] } {
    set _SJCTAPID $SJCTAPID
@@ -42,8 +42,8 @@
 # See diagram: 6-14
 #   SIGNAL NAME:
 #    SJC_MOD - controls multiplexer - disables ARM1136
-#    SDMA_BYPASS - disables SDMA    - 
-#  
+#    SDMA_BYPASS - disables SDMA    -
+#
 # Per ARM: DDI0211J_arm1136_r1p5_trm.pdf - the ARM 1136 as a 5 bit IR register
 jtag newtap $_CHIPNAME cpu -irlen 5 -ircapture 0x1 -irmask 0x1f -expected-id $_CPUTAPID
 
@@ -58,5 +58,5 @@
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
 
 
-proc power_restore {} { puts "Sensed power restore. No action." } 
+proc power_restore {} { puts "Sensed power restore. No action." }
 proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }

Modified: trunk/tcl/target/imx35.cfg
===================================================================
--- trunk/tcl/target/imx35.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/imx35.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 # imx35 config
 #
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME imx35
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -26,7 +26,7 @@
 }
 
 #========================================
-# The "system jtag controller" 
+# The "system jtag controller"
 # IMX31 reference manual, page 6-28 - figure 6-14
 if { [info exists SJCTAPID ] } {
    set _SJCTAPID $SJCTAPID
@@ -46,5 +46,5 @@
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm11 -endian $_ENDIAN -chain-position $_TARGETNAME
 
-proc power_restore {} { puts "Sensed power restore. No action." } 
+proc power_restore {} { puts "Sensed power restore. No action." }
 proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }

Modified: trunk/tcl/target/is5114.cfg
===================================================================
--- trunk/tcl/target/is5114.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/is5114.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -2,15 +2,15 @@
 # AKA: Atmel AT76C114 - an ARM946 chip
 # ATMEL sold his product line to Insilica...
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME is5114
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # this defaults to a little endian
    set  _ENDIAN little
 }
@@ -29,7 +29,7 @@
 
 # Do not specify a tap id here...
 #OLD SYNTAX: jtag_device 8 0x1 0x1 0xfe
-jtag newtap $_CHIPNAME unknown1 -irlen 8 -ircapture 0x01 -irmask 1 
+jtag newtap $_CHIPNAME unknown1 -irlen 8 -ircapture 0x01 -irmask 1
 #OLD SYNTAX: jtag_device 4 0x1 0xf 0xe
 # This is the "arm946" chip.
 jtag newtap $_CHIPNAME cpu      -irlen 4 -ircapture 0x0e -irmask 0xf
@@ -37,7 +37,7 @@
 jtag newtap $_CHIPNAME unknown2 -irlen 5 -ircapture 1 -irmask 1
 
 
-#arm946e-s and 
+#arm946e-s and
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm966e -endian $_ENDIAN  -chain-position $_TARGETNAME  -variant arm966e
 

Modified: trunk/tcl/target/ixp42x.cfg
===================================================================
--- trunk/tcl/target/ixp42x.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/ixp42x.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 #xscale ixp42x CPU
 
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME ixp42x
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # this defaults to a bigendian
    set  _ENDIAN big
 }

Modified: trunk/tcl/target/lm3s1968.cfg
===================================================================
--- trunk/tcl/target/lm3s1968.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lm3s1968.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,8 +1,8 @@
 # Script for TI/Luminary Stellaris LM3S1968
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lm3s1968
 }
 

Modified: trunk/tcl/target/lm3s3748.cfg
===================================================================
--- trunk/tcl/target/lm3s3748.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lm3s3748.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,8 +1,8 @@
 # TI/Luminary Stellaris lm3s3748
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lm3s3748
 }
 

Modified: trunk/tcl/target/lm3s6965.cfg
===================================================================
--- trunk/tcl/target/lm3s6965.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lm3s6965.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,8 +1,8 @@
 # TI/Luminary Stellaris lm3s6965
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lm3s6965
 }
 

Modified: trunk/tcl/target/lm3s811.cfg
===================================================================
--- trunk/tcl/target/lm3s811.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lm3s811.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,8 +1,8 @@
 # Script for TI/Luminary Stellaris LM3S811
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lm3s811
 }
 

Modified: trunk/tcl/target/lm3s9b9x.cfg
===================================================================
--- trunk/tcl/target/lm3s9b9x.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lm3s9b9x.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -5,9 +5,9 @@
 # http://www.luminarymicro.com/products/lm3s9b92.htm
 #
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lm3s9b9x
 }
 

Modified: trunk/tcl/target/lpc2103.cfg
===================================================================
--- trunk/tcl/target/lpc2103.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lpc2103.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,6 +1,6 @@
 # NXP LPC2103 ARM7TDMI-S with 32kB Flash and 8kB SRAM, clocked with 12MHz crystal
 
-if { [info exists CHIPNAME] } {	
+if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
 } else {
    set _CHIPNAME lpc2103
@@ -15,7 +15,7 @@
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-   set _CPUTAPID 0x4f1f0f0f 
+   set _CPUTAPID 0x4f1f0f0f
 }
 
 # LPC2000 -> SRST causes TRST

Modified: trunk/tcl/target/lpc2129.cfg
===================================================================
--- trunk/tcl/target/lpc2129.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lpc2129.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 #LPC-2129 CPU
 
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lpc2129
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/lpc2148.cfg
===================================================================
--- trunk/tcl/target/lpc2148.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lpc2148.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,9 +1,9 @@
-# Use RCLK. If RCLK is not available fall back to 500kHz. 
-# 
+# Use RCLK. If RCLK is not available fall back to 500kHz.
+#
 # Depending on cabling you might be able to eek this up to 2000kHz.
 jtag_rclk 500
 
-if { [info exists CHIPNAME] } {	
+if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
 } else {
    set _CHIPNAME lpc2148

Modified: trunk/tcl/target/lpc2294.cfg
===================================================================
--- trunk/tcl/target/lpc2294.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/lpc2294.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,12 +1,12 @@
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lpc2294
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/netx500.cfg
===================================================================
--- trunk/tcl/target/netx500.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/netx500.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 #Hilscher netX 500 CPU
 
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME netx500
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/omap3530.cfg
===================================================================
--- trunk/tcl/target/omap3530.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/omap3530.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -2,9 +2,9 @@
 #  http://focus.ti.com/docs/prod/folders/print/omap3530.html
 # Other OMAP3 chips remove DSP and/or the OpenGL support
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME omap3530
 }
 

Modified: trunk/tcl/target/omap5912.cfg
===================================================================
--- trunk/tcl/target/omap5912.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/omap5912.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 # TI OMAP5912 dual core processor
 # http://focus.ti.com/docs/prod/folders/print/omap5912.html
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME omap5912
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # this defaults to a bigendian
    set  _ENDIAN little
 }

Modified: trunk/tcl/target/pic32mx.cfg
===================================================================
--- trunk/tcl/target/pic32mx.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/pic32mx.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,13 +1,13 @@
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME pic32mx
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/pxa255.cfg
===================================================================
--- trunk/tcl/target/pxa255.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/pxa255.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 # PXA255 chip ... originally from Intel, PXA line was sold to Marvell.
 #  This chip is now at end-of-life.  Final orders have been taken.
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME pxa255
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/pxa270.cfg
===================================================================
--- trunk/tcl/target/pxa270.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/pxa270.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 #Marvell/Intel PXA270 Script
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME pxa270
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/readme.txt
===================================================================
--- trunk/tcl/target/readme.txt	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/readme.txt	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,5 +1,5 @@
 Prerequisites:
-The users of OpenOCD as well as computer programs interacting with OpenOCD are expecting that certain commands 
+The users of OpenOCD as well as computer programs interacting with OpenOCD are expecting that certain commands
 do the same thing across all the targets.
 
 Rules to follow when writing scripts:
@@ -8,20 +8,20 @@
 	reset
 	flash info <bank>
 and
-	reset 
+	reset
 	flash erase_address <start> <len>
 and
 	reset init
 	load
-	
-In most cases this can be accomplished by specifying the default startup mode as reset_init (target command 
+
+In most cases this can be accomplished by specifying the default startup mode as reset_init (target command
 in the configuration file).
- 
-2. If the target is correctly configured, flash must be writable without any other helper commands. It is 
+
+2. If the target is correctly configured, flash must be writable without any other helper commands. It is
 assumed that all write-protect mechanisms should be disabled.
 
 3. The configuration scripts should be defined such as the binary that was written to flash verifies
-(turn off remapping, checksums, etc...) 
+(turn off remapping, checksums, etc...)
 
 flash write_image [file] <parameters>
 verify_image [file] <parameters>

Modified: trunk/tcl/target/sam7se512.cfg
===================================================================
--- trunk/tcl/target/sam7se512.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/sam7se512.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,17 +1,17 @@
 
-# ATMEL sam7se512 
+# ATMEL sam7se512
 # Example: the "Elektor Internet Radio" - EIR
 # http://www.ethernut.de/en/hardware/eir/index.html
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME sam7se512
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 

Modified: trunk/tcl/target/sam7x256.cfg
===================================================================
--- trunk/tcl/target/sam7x256.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/sam7x256.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,15 +1,15 @@
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config srst_only srst_pulls_trst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME sam7x256
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -24,22 +24,22 @@
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 
-$_TARGETNAME configure -event reset-init { 
+$_TARGETNAME configure -event reset-init {
 	# disable watchdog
-	mww 0xfffffd44 0x00008000	
+	mww 0xfffffd44 0x00008000
 	# enable user reset
-	mww 0xfffffd08 0xa5000001	
+	mww 0xfffffd08 0xa5000001
 	# CKGR_MOR : enable the main oscillator
-	mww 0xfffffc20 0x00000601	
+	mww 0xfffffc20 0x00000601
 	sleep 10
 	# CKGR_PLLR: 96.1097 MHz
-	mww 0xfffffc2c 0x00481c0e 	
+	mww 0xfffffc2c 0x00481c0e
 	sleep 10
 	# PMC_MCKR : MCK = PLL / 2 ~= 48 MHz
-	mww 0xfffffc30 0x00000007	
+	mww 0xfffffc30 0x00000007
 	sleep 10
 	# MC_FMR: flash mode (FWS=1,FMCN=60)
-	mww 0xffffff60 0x003c0100	
+	mww 0xffffff60 0x003c0100
 	sleep 100
 }
 

Modified: trunk/tcl/target/samsung_s3c2410.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c2410.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/samsung_s3c2410.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,21 +1,21 @@
 # Found on the 'TinCanTools' Hammer board.
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME s3c2410
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # This config file was defaulting to big endian..
    set  _ENDIAN little
 }
 
-if { [info exists CPUTAPID] } {	
-   set  _CPUTAPID $CPUTAPID    
-} else {	 
+if { [info exists CPUTAPID] } {
+   set  _CPUTAPID $CPUTAPID
+} else {
    set  _CPUTAPID 0xffffffff
 }
 

Modified: trunk/tcl/target/samsung_s3c2440.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c2440.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/samsung_s3c2440.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -3,15 +3,15 @@
 # Processor       : ARM920Tid(wb) rev 0 (v4l)
 # Info:   JTAG tap: s3c2440.cpu tap/device found: 0x0032409d (Manufacturer: 0x04e, Part: 0x0324, Version: 0x0)
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME s3c2440
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # this defaults to a bigendian
    set  _ENDIAN little
 }

Modified: trunk/tcl/target/samsung_s3c2450.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c2450.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/samsung_s3c2450.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -4,9 +4,9 @@
 
 
 # FIX!!! what to use here?
-# 
+#
 # RCLK?
-# 
+#
 # jtag_khz 0
 #
 # Really low clock during reset?

Modified: trunk/tcl/target/samsung_s3c4510.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c4510.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/samsung_s3c4510.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,13 +1,13 @@
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME s3c4510
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -21,5 +21,5 @@
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME  
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
 

Modified: trunk/tcl/target/samsung_s3c6410.cfg
===================================================================
--- trunk/tcl/target/samsung_s3c6410.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/samsung_s3c6410.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -6,15 +6,15 @@
 # [Duane Ellis 27/nov/2008: Above 0x0032409d appears to be copy/paste from other places]
 # [and I do not believe it to be accurate, hence the 0xffffffff below]
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME s3c6410
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # this defaults to a bigendian
    set  _ENDIAN little
 }

Modified: trunk/tcl/target/sharp_lh79532.cfg
===================================================================
--- trunk/tcl/target/sharp_lh79532.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/sharp_lh79532.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 reset_config srst_only srst_pulls_trst
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME lh79532
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -21,6 +21,6 @@
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME  
+target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME
 
 

Modified: trunk/tcl/target/stm32.cfg
===================================================================
--- trunk/tcl/target/stm32.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/stm32.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 # script for stm32
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME stm32
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -54,7 +54,7 @@
   set _BSTAPID4 0x06414041
   # Connectivity line devices, Rev A and Rev Z
   set _BSTAPID5 0x06418041
-}   
+}
 jtag newtap $_CHIPNAME bs  -irlen 5 -ircapture 0x1 -irmask 0x1 -expected-id $_BSTAPID1 -expected-id $_BSTAPID2 -expected-id $_BSTAPID3 -expected-id $_BSTAPID4 -expected-id $_BSTAPID5
 
 set _TARGETNAME $_CHIPNAME.cpu

Modified: trunk/tcl/target/str710.cfg
===================================================================
--- trunk/tcl/target/str710.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/str710.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,21 +1,21 @@
 #start slow, speed up after reset
 jtag_khz 10
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME str710
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
-if { [info exists CPUTAPID] } {	
-   set  _CPUTAPID $CPUTAPID    
-} else {	 
+if { [info exists CPUTAPID] } {
+   set  _CPUTAPID $CPUTAPID
+} else {
    set  _CPUTAPID 0x3f0f0f0f
 }
 

Modified: trunk/tcl/target/str730.cfg
===================================================================
--- trunk/tcl/target/str730.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/str730.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -2,21 +2,21 @@
 
 jtag_khz 3000
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME str730
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
-if { [info exists CPUTAPID] } {	
-   set  _CPUTAPID $CPUTAPID    
-} else {	 
+if { [info exists CPUTAPID] } {
+   set  _CPUTAPID $CPUTAPID
+} else {
    set  _CPUTAPID 0x3f0f0f0f
 }
 

Modified: trunk/tcl/target/str750.cfg
===================================================================
--- trunk/tcl/target/str750.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/str750.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,20 +1,20 @@
 #STR750 CPU
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME str750
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
-if { [info exists CPUTAPID] } {	
-   set  _CPUTAPID $CPUTAPID    
-} else {	 
+if { [info exists CPUTAPID] } {
+   set  _CPUTAPID $CPUTAPID
+} else {
    set  _CPUTAPID 0x4f1f0041
 }
 

Modified: trunk/tcl/target/str912.cfg
===================================================================
--- trunk/tcl/target/str912.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/str912.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 # script for str9
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME str912
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
    set  _ENDIAN little
 }
 
@@ -51,10 +51,10 @@
 $_TARGETNAME configure -event reset-init {
 	# We can increase speed now that we know the target is halted.
 	#jtag_rclk 3000
-	
+
 	# -- Enable 96K RAM
 	# PFQBC enabled / DTCM & AHB wait-states disabled
-	mww 0x5C002034 0x0191 
+	mww 0x5C002034 0x0191
 
 	str9x flash_config 0 4 2 0 0x80000
 	flash protect 0 0 7 off

Modified: trunk/tcl/target/telo.cfg
===================================================================
--- trunk/tcl/target/telo.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/telo.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -4,6 +4,6 @@
 # it's really 16MB but the upper 8mb is controller via gpio?
 flash bank cfi 0x20000000 0x01000000 2 2 $_TARGETNAME
 
-# 
+#
 gdb_memory_map enable
 

Modified: trunk/tcl/target/test_reset_syntax_error.cfg
===================================================================
--- trunk/tcl/target/test_reset_syntax_error.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/test_reset_syntax_error.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -5,13 +5,13 @@
 
 #jtag scan chain
 set _CHIPNAME syntaxtest
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf 
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf
 
 #target configuration
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
-$_TARGETNAME configure -event reset-init { 
+$_TARGETNAME configure -event reset-init {
 
 	syntax error
 }

Modified: trunk/tcl/target/test_syntax_error.cfg
===================================================================
--- trunk/tcl/target/test_syntax_error.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/test_syntax_error.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,4 +1,4 @@
-# This script tests a syntax error in the startup 
+# This script tests a syntax error in the startup
 # config script
 
 syntax error here

Modified: trunk/tcl/target/xba_revA3.cfg
===================================================================
--- trunk/tcl/target/xba_revA3.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/target/xba_revA3.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -1,14 +1,14 @@
 #Written by: Michael Schwingen <rincewind at discworld.dascon.de>
 
-if { [info exists CHIPNAME] } {	
-   set  _CHIPNAME $CHIPNAME    
-} else {	 
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
    set  _CHIPNAME xba_reva3
 }
 
-if { [info exists ENDIAN] } {	
-   set  _ENDIAN $ENDIAN    
-} else {	 
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
   # default to big endian
    set  _ENDIAN big
 }
@@ -81,7 +81,7 @@
 
 flash bank cfi 0x50000000 0x400000 2 2 0
 
-init 
+init
 reset init
 # set big endian mode
 reg XSCALE_CTRL 0xF8

Modified: trunk/tcl/test/syntax1.cfg
===================================================================
--- trunk/tcl/test/syntax1.cfg	2009-09-21 18:40:55 UTC (rev 2742)
+++ trunk/tcl/test/syntax1.cfg	2009-09-21 18:48:22 UTC (rev 2743)
@@ -18,9 +18,9 @@
 set _TARGETNAME [format "%s.cpu" lpc2148]
 target create lpc2148.cpu arm7tdmi -endian little -work-area-size 0x4000 -work-area-phys 0x40000000 -work-area-virt 0 -work-area-backup 0
 
-$_TARGETNAME configure -event reset-init { 
-soft_reset_halt 
-mvb 0xE01FC040 0x01 
+$_TARGETNAME configure -event reset-init {
+soft_reset_halt
+mvb 0xE01FC040 0x01
 }
 
 



From dbrownell at mail.berlios.de  Mon Sep 21 20:52:49 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 21 Sep 2009 20:52:49 +0200
Subject: [Openocd-svn] r2744 - in trunk/doc: . manual manual/primer
	manual/target
Message-ID: <200909211852.n8LIqnB9022272@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-21 20:52:45 +0200 (Mon, 21 Sep 2009)
New Revision: 2744

Modified:
   trunk/doc/INSTALL.txt
   trunk/doc/manual/flash.txt
   trunk/doc/manual/jtag.txt
   trunk/doc/manual/primer/autotools.txt
   trunk/doc/manual/primer/docs.txt
   trunk/doc/manual/primer/jtag.txt
   trunk/doc/manual/primer/patches.txt
   trunk/doc/manual/primer/tcl.txt
   trunk/doc/manual/release.txt
   trunk/doc/manual/scripting.txt
   trunk/doc/manual/server.txt
   trunk/doc/manual/style.txt
   trunk/doc/manual/target/notarm.txt
   trunk/doc/openocd.1
   trunk/doc/openocd.texi
Log:
Remove annoying end-of-line whitespace from doc/* files.


Modified: trunk/doc/INSTALL.txt
===================================================================
--- trunk/doc/INSTALL.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/INSTALL.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -16,7 +16,7 @@
 Basic Installation
 ==================
 
-   OpenOCD is distributed without autotools generated files, i.e. without a 
+   OpenOCD is distributed without autotools generated files, i.e. without a
 configure script. Run ./bootstrap in the openocd directory to have all
 necessary files generated.
 
@@ -77,7 +77,7 @@
      documentation.
 
   4. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  
+     source code directory by typing `make clean'.
 
 Compilers and Options
 =====================

Modified: trunk/doc/manual/flash.txt
===================================================================
--- trunk/doc/manual/flash.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/flash.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -7,7 +7,7 @@
 
 The Flash module provides the following APIs:
 
-  - @subpage flashcfi 
+  - @subpage flashcfi
   - @subpage flashnand
   - @subpage flashtarget
 

Modified: trunk/doc/manual/jtag.txt
===================================================================
--- trunk/doc/manual/jtag.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/jtag.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -32,7 +32,7 @@
     - includes the Cable/TAP API (commands starting with @c tap_)
 
 - @subpage jtagdriver
-  - @b private minidriver API 
+  - @b private minidriver API
   - declared in @c src/jtag/minidriver.h
   - used @a only by the core and minidriver implementations:
     - @c jtag_driver.c (in-tree OpenOCD drivers)

Modified: trunk/doc/manual/primer/autotools.txt
===================================================================
--- trunk/doc/manual/primer/autotools.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/primer/autotools.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -144,7 +144,7 @@
 The <code>make distcheck</code> command produces an archive of the
 project deliverables (using <code>make dist</code>) and verifies its
 integrity for distribution by attemptng to use the package in the same
-manner as a user.  
+manner as a user.
 
 These checks includes the following steps:
 -# Unpack the project archive into its expected directory.

Modified: trunk/doc/manual/primer/docs.txt
===================================================================
--- trunk/doc/manual/primer/docs.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/primer/docs.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -90,7 +90,7 @@
 To support out-of-tree building of the documentation, the @c Doxyfile.in
 @c INPUT values will have all instances of the string @c "@srcdir@"
 replaced with the current value of the make variable
-<code>$(srcdir)</code>.  The Makefile uses a rule to convert 
+<code>$(srcdir)</code>.  The Makefile uses a rule to convert
 @c Doxyfile.in into the @c Doxyfile used by <code>make doxygen</code>.
 
 @section primerdoxyoocd OpenOCD Input Files
@@ -105,7 +105,7 @@
 New files containing valid Doxygen markup that are placed in or under
 that directory will be detected and included in The Manual automatically.
 
- at section primerdoxyman Doxygen Reference Manual 
+ at section primerdoxyman Doxygen Reference Manual
 
 The full documentation for Doxygen can be referenced on-line at the project
 home page: http://www.doxygen.org/index.html.  In HTML versions of this

Modified: trunk/doc/manual/primer/jtag.txt
===================================================================
--- trunk/doc/manual/primer/jtag.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/primer/jtag.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -1,14 +1,14 @@
 /** @page primerjtag OpenOCD JTAG Primer
 
-JTAG is unnecessarily confusing, because JTAG is often confused with 
+JTAG is unnecessarily confusing, because JTAG is often confused with
 boundary scan, which is just one of its possible functions.
 
-JTAG is simply a communication interface designed to allow communication 
-to functions contained on devices, for the designed purposes of 
-initialisation, programming, testing, debugging, and anything else you 
+JTAG is simply a communication interface designed to allow communication
+to functions contained on devices, for the designed purposes of
+initialisation, programming, testing, debugging, and anything else you
 want to use it for (as a chip designer).
 
-Think of JTAG as I2C for testing.  It doesn't define what it can do, 
+Think of JTAG as I2C for testing.  It doesn't define what it can do,
 just a logical interface that allows a uniform channel for communication.
 
 See @par
@@ -17,42 +17,42 @@
 and @par
 	http://www.inaccessnetworks.com/projects/ianjtag/jtag-intro/jtag-state-machine-large.png
 
-The first page (among other things) shows a logical representation 
-describing how multiple devices are wired up using JTAG.  JTAG does not 
-specify, data rates or interface levels (3.3V/1.8V, etc) each device can 
-support different data rates/interface logic levels.  How to wire them 
+The first page (among other things) shows a logical representation
+describing how multiple devices are wired up using JTAG.  JTAG does not
+specify, data rates or interface levels (3.3V/1.8V, etc) each device can
+support different data rates/interface logic levels.  How to wire them
 in a compatible way is an exercise for an engineer.
 
-Basically TMS controls which shift register is placed on the device, 
-between TDI and TDO.  The second diagram shows the state transitions on 
+Basically TMS controls which shift register is placed on the device,
+between TDI and TDO.  The second diagram shows the state transitions on
 TMS which will select different shift registers.
 
-The first thing you need to do is reset the state machine, because when 
-you connect to a chip you do not know what state the controller is in,you need 
-to clock TMS as 1, at least 7 times.  This will put you into "Test Logic 
-Reset" State.  Knowing this, you can, once reset, then track what each 
-transition on TMS will do, and hence know what state the JTAG state 
+The first thing you need to do is reset the state machine, because when
+you connect to a chip you do not know what state the controller is in,you need
+to clock TMS as 1, at least 7 times.  This will put you into "Test Logic
+Reset" State.  Knowing this, you can, once reset, then track what each
+transition on TMS will do, and hence know what state the JTAG state
 machine is in.
 
-There are 2 "types" of shift registers.  The Instruction shift register 
-and the data shift register.  The sizes of these are undefined, and can 
-change from chip to chip.  The Instruction register is used to select 
-which Data register/data register function is used, and the data 
+There are 2 "types" of shift registers.  The Instruction shift register
+and the data shift register.  The sizes of these are undefined, and can
+change from chip to chip.  The Instruction register is used to select
+which Data register/data register function is used, and the data
 register is used to read data from that function or write data to it.
 
-Each of the states control what happens to either the data register or 
+Each of the states control what happens to either the data register or
 instruction register.
 
-For example, one of the data registers will be known as "bypass" this is 
-(usually) a single bit which has no function and is used to bypass the 
-chip.  Assume we have 3 identical chips, wired up like the picture 
-and each has a 3 bit instruction register, and there are 2 known 
-instructions (110 = bypass, 010 = some other function) if we want to use 
-"some other function", on the second chip in the line, and not change 
+For example, one of the data registers will be known as "bypass" this is
+(usually) a single bit which has no function and is used to bypass the
+chip.  Assume we have 3 identical chips, wired up like the picture
+and each has a 3 bit instruction register, and there are 2 known
+instructions (110 = bypass, 010 = some other function) if we want to use
+"some other function", on the second chip in the line, and not change
 the other chips we would do the following transitions.
 
 From Test Logic Reset, TMS goes:
- 
+
   0 1 1 0 0
 
 which puts every chip in the chain into the "Shift IR state"
@@ -60,7 +60,7 @@
 
   0 1 1  0 1 0  0 1 1
 
-which puts the following values in the instruction shift register for 
+which puts the following values in the instruction shift register for
 each chip [110] [010] [110]
 
 The order is reversed, because we shift out the least significant bit
@@ -70,18 +70,18 @@
 
 which puts us in the "Shift DR state".
 
-Now when we clock data onto TDI (again while holding TMS to 0) , the 
-data shifts through the data registers, and because of the instruction 
-registers we selected (some other function has 8 bits in its data 
+Now when we clock data onto TDI (again while holding TMS to 0) , the
+data shifts through the data registers, and because of the instruction
+registers we selected (some other function has 8 bits in its data
 register), our total data register in the chain looks like this:
 
   0 00000000 0
 
-The first and last bit are in the "bypassed" chips, so values read from 
-them are irrelevant and data written to them is ignored.  But we need to 
+The first and last bit are in the "bypassed" chips, so values read from
+them are irrelevant and data written to them is ignored.  But we need to
 write bits for those registers, because they are in the chain.
 
-If we wanted to write 0xF5 to the data register we would clock out of 
+If we wanted to write 0xF5 to the data register we would clock out of
 TDI (holding TMS to 0):
 
   0 1 0 1 0 1 1 1 1 0
@@ -91,13 +91,13 @@
 
   1 1 0
 
-which updates the selected data register with the value 0xF5 and returns 
+which updates the selected data register with the value 0xF5 and returns
 us to run test idle.
 
-If we needed to read the data register before over-writing it with F5, 
-no sweat, that's already done, because the TDI/TDO are set up as a 
-circular shift register, so if you write enough bits to fill the shift 
-register, you will receive the "captured" contents of the data registers 
+If we needed to read the data register before over-writing it with F5,
+no sweat, that's already done, because the TDI/TDO are set up as a
+circular shift register, so if you write enough bits to fill the shift
+register, you will receive the "captured" contents of the data registers
 simultaneously on TDO.
 
 That's JTAG in a nutshell.  On top of this, you need to get specs for

Modified: trunk/doc/manual/primer/patches.txt
===================================================================
--- trunk/doc/manual/primer/patches.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/primer/patches.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -8,7 +8,7 @@
 The standard method for creating patches requires developers to:
 - checkout the Subversion repository (or bring a copy up-to-date),
 - make the necessary modifications to a working copy,
-- check with 'svn status' to see which files will be modified/added, and 
+- check with 'svn status' to see which files will be modified/added, and
 - use 'svn diff' to review the changes and produce a patch.
 
 It is important to minimize the changes to only those lines that contain
@@ -67,7 +67,7 @@
 <code>svn diff</code>.  Overlapping patches will be discussed in the
 next section.
 
-The remainder of this section provides 
+The remainder of this section provides
 
 @subsection primerpatchprops Subversion Properties
 
@@ -110,7 +110,7 @@
 svn diff foo | unix2dos | patch -R
 @endcode
 
-This is not a bug. 
+This is not a bug.
 
 @todo Does Subversion's treatment of line-endings for files marked with
 svn:eol-style=native continue to pose the problems described here, or

Modified: trunk/doc/manual/primer/tcl.txt
===================================================================
--- trunk/doc/manual/primer/tcl.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/primer/tcl.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -115,7 +115,7 @@
 
        set x "2 * 6"
        set foo([expr $x])  "twelve"
-       
+
 **************************************************
 ***************************************************
 === TCL TOUR ===
@@ -133,7 +133,7 @@
 In TCL, "FOR" is a funny thing, it is not what you think it is.
 
 Syntactically - FOR is a just a command, it is not language
-construct like for(;;) in C... 
+construct like for(;;) in C...
 
 The "for" command takes 4 parameters.
    (1) The "initial command" to execute.
@@ -215,7 +215,7 @@
  (2)  NAME( array )
       And the array must have some specific names:
           ( <idx>, THING )
-	    Where: THING is one of: 
+	    Where: THING is one of:
 		   CHIPSELECT
 		   BASE
 		   LEN
@@ -224,7 +224,7 @@
 		   RWX - the access ability.
 		   WIDTH - the accessible width.
 
-        ie: Some regions of memory are not 'word' 
+        ie: Some regions of memory are not 'word'
 	accessible.
 
 The function "address_info" - given an address should
@@ -237,14 +237,14 @@
 MAJOR FUNCTION:
 ==
 
-proc memread32 { ADDR } 
-proc memread16 { ADDR } 
-proc memread8 { ADDR } 
+proc memread32 { ADDR }
+proc memread16 { ADDR }
+proc memread8 { ADDR }
 
 All read memory - and return the contents.
 
 [ FIXME: 7/5/2008 - I need to create "memwrite" functions]
-		 
+
 **************************************************
 ***************************************************
 === TCL TOUR ===
@@ -265,13 +265,13 @@
      FOO_linux = "Penguins rule"
      FOO_winXP = "Broken Glass"
      FOO_mac   = "I like cat names"
-     
+
      # Pick one
      BUILD  = linux
      #BUILD = winXP
      #BUILD = mac
      FOO = ${FOO_${BUILD}}
-				
+
 The "double [set] square bracket" thing is the TCL way, nothing more.
 
 ----
@@ -290,7 +290,7 @@
 The "IF" command expects either 2 params, or 4 params.
 
  === Sidebar: About "commands" ===
-  
+
      Take a look at the internals of "jim.c"
      Look for the function: Jim_IfCoreCommand()
      And all those other "CoreCommands"
@@ -298,10 +298,10 @@
      You'll notice - they all have "argc" and "argv"
 
      Yea, the entire thing is done that way.
-     
+
      IF is a command. SO is "FOR" and "WHILE" and "DO" and the
      others. That is why I keep using the phase it is a "command"
-     
+
  === END: Sidebar: About "commands" ===
 
 Parameter 1 to the IF command is expected to be an expression.
@@ -315,7 +315,7 @@
 You give CATCH 1 or 2 parameters.
     The first 1st parameter is the "code to execute"
     The 2nd (optional) is where to put the error message.
-    
+
     CATCH returns 0 on success, 1 for failure.
     The "![catch command]" is self explaintory.
 
@@ -325,7 +325,7 @@
 be joined by exactly the words "else" or "elseif".
 
 The 4th parameter contains:
-    
+
     "error [format STRING....]"
 
 This lets me modify the previous lower level error by tacking more
@@ -346,7 +346,7 @@
 function pointer - and calling the function pointer.
 
 In this case - I execute a dynamic command. You can do some cool
-tricks with interpretors. 
+tricks with interpretors.
 
 ----------
 
@@ -380,7 +380,7 @@
 
 The "CHIP" file has defined some variables in a proper form.
 
-ie:   AT91C_BASE_US0 - for usart0, 
+ie:   AT91C_BASE_US0 - for usart0,
       AT91C_BASE_US1 - for usart1
       ... And so on ...
 
@@ -419,9 +419,9 @@
 With that little bit of code - I now have a bunch of functions like:
 
    show_US0, show_US1, show_US2, .... etc ...
-   
+
    And show_US0_MR, show_US0_IMR ... etc...
-  
+
 And - I have this for every USART... without having to create tons of
 boiler plate yucky code.
 

Modified: trunk/doc/manual/release.txt
===================================================================
--- trunk/doc/manual/release.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/release.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -113,7 +113,7 @@
 
 The OpenOCD release process must be carried out on a periodic basis, so
 the project can realize the benefits presented in answer to the question,
- at ref releasewhy.  
+ at ref releasewhy.
 
 Starting with the 0.2.0 release, the OpenOCD project should produce a
 new minor release every month or two, with a major release once a year.
@@ -132,7 +132,7 @@
 release.  This section presents guidelines for scheduling key points
 where the community must be informed of changing conditions.
 
-If T is the time of the next release, then the following schedule 
+If T is the time of the next release, then the following schedule
 might describe some of the key milestones of the new release cycle:
 
 - T minus one month: start of new development cycle
@@ -190,7 +190,7 @@
 The following steps should be followed to produce each release:
 
 -# Produce final patches to the trunk (or release branch):
-  -# Finalize @c NEWS file to describe the changes in the release 
+  -# Finalize @c NEWS file to describe the changes in the release
     - This file is Used to automatically post "blurbs" about the project.
     - This material should be produced during the development cycle.
     - Add a new item for each @c NEWS-worthy contribution, when committed.
@@ -208,7 +208,7 @@
 svn cp .../branches/${RELEASE_BRANCH} .../tags/${RELEASE_TAG}
 @endverbatim
   - For bug-fix releases produced in their respective branch, a tag
-    should be created in the repository: 
+    should be created in the repository:
 @verbatim
 svn cp .../branches/${RELEASE_BRANCH} .../tags/${RELEASE_TAG}
 @endverbatim

Modified: trunk/doc/manual/scripting.txt
===================================================================
--- trunk/doc/manual/scripting.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/scripting.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -5,7 +5,7 @@
 The scripting support is intended for developers of OpenOCD.
 It is not the intention that normal OpenOCD users will
 use tcl scripting extensively, write lots of clever scripts,
-or contribute back to OpenOCD. 
+or contribute back to OpenOCD.
 
 Target scripts can contain new procedures that end users may
 tinker to their needs without really understanding tcl.
@@ -31,7 +31,7 @@
     file format and structure of serialnumber. Tcl allows
     an argument to consist of e.g. a list so the structure of
     the serial number is not limited to a single string.
-  - reset handling. Precise control of how srst, trst & 
+  - reset handling. Precise control of how srst, trst &
     tms is handled.
 - replace some parts of the current command line handler.
   This is only to simplify the implementation of OpenOCD
@@ -42,7 +42,7 @@
   that return machine readable output. These low level tcl
   functions constitute the tcl api. flash_banks is such
   a low level tcl proc. "flash banks" is an example of
-  a command that has human readable output. The human 
+  a command that has human readable output. The human
   readable output is expected to change inbetween versions
   of OpenOCD. The output from flash_banks may not be
   in the preferred form for the client. The client then
@@ -50,8 +50,8 @@
   or b) write a small piece of tcl to output the
   flash_banks output to a more suitable form. The latter may
   be simpler.
-  
-  
+
+
 @section scriptingexternal External scripting
 
 The embedded Jim Tcl interpreter in OpenOCD is very limited

Modified: trunk/doc/manual/server.txt
===================================================================
--- trunk/doc/manual/server.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/server.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -32,14 +32,14 @@
 - the ablity to write a complex internal commands: native 'commands'
   inside of OpenOCD was complicated.
 
-Fundamentally, the basic problem with both of those would be solved 
+Fundamentally, the basic problem with both of those would be solved
 with a script language:
 
 -# <b>Internal</b>: simple, small, and self-contained.
 -# <b>Cross Language</b>: script friendly front-end
 -# <b>Cross Host</b>: GUI Host interface
 -# <b>Cross Debugger</b>: GUI-like interface
-  
+
 What follows hopefully shows how the plans to solve these problems
 materialized and help to explain the grand roadmap plan.
 
@@ -64,7 +64,7 @@
 
 The TCL Server port was added in mid-2008.  With embedded TCL, we can
 write scripts internally to help things, or we can write "C" code  that
-interfaces well with TCL. 
+interfaces well with TCL.
 
 From there, the developers wanted to create an external front-end that
 would be @a very usable and that that @a any language could utilize,
@@ -81,7 +81,7 @@
 Thus, the TCL server -- a 'machine' type socket interface -- was added
 with the hope was it would output simple "name-value" pair type
 data.  At the time, simple name/value pairs seemed reasonably easier to
-do at the time, though Maybe it should output JSON; 
+do at the time, though Maybe it should output JSON;
 
 See here:
 
@@ -101,11 +101,11 @@
 For example, Cygwin can be painful, Cygwin GUI packages want X11
 to be present, crossing the barrier between MinGW and Cygwin is
 painful, let alone getting the GUI front end to work on MacOS, and
-Linux, yuck yuck yuck. Painful. very very painful.  
+Linux, yuck yuck yuck. Painful. very very painful.
 
 What works easier and is less work is what is already present in every
 platform?  The answer: A web browser.  In other words, OpenOCD could
-serve out embedded web pages via "localhost" to your browser. 
+serve out embedded web pages via "localhost" to your browser.
 
 Long before OpenOCD had a TCL command line, Zylin AS built their ZY1000
 devince with a built-in HTTP server.  Later, they were willing to both
@@ -169,7 +169,7 @@
 
 During 2008, Duane Ellis created some TCL scripts to display peripheral
 register contents. For example, look at the sam7 TCL scripts, and the
-stm32 TCL scripts.  The hope was others would create more. 
+stm32 TCL scripts.  The hope was others would create more.
 
 
 A good example of this is display/view the peripheral registers on
@@ -215,7 +215,7 @@
 use of the feature.  In other words, one could write a Python/TK
 front-end, but it is only useable if you have Python/TK installed.
 Maybe this can be done via Ecllipse, but not all developers use Ecplise.
-Many devlopers use Emacs (possibly with GUD mode) or vim and will not 
+Many devlopers use Emacs (possibly with GUD mode) or vim and will not
 accept such an interface.  The next developer reading this might be
 using Insight (GDB-TK) - and somebody else - DDD..
 

Modified: trunk/doc/manual/style.txt
===================================================================
--- trunk/doc/manual/style.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/style.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -149,7 +149,7 @@
  * in blocks such as the one in which this example appears in the Style
  * Guide.  See the Doxygen Manual for the full list of commands.
  *
- * @param foo For a function, describe the parameters (e.g. @a foo). 
+ * @param foo For a function, describe the parameters (e.g. @a foo).
  * @returns The value(s) returned, or possible error conditions.
  */
 @endverbatim
@@ -229,7 +229,7 @@
 @endverbatim
 
 For an example, the Doxygen source for this Style Guide can be found in
- at c doc/manual/style.txt, alongside other parts of The Manual.  
+ at c doc/manual/style.txt, alongside other parts of The Manual.
 
  */
 /** @page styletexinfo Texinfo Style Guide
@@ -344,7 +344,7 @@
 This page provides some style guidelines for using Perl, a scripting
 language used by several small tools in the tree:
 
--# Ensure all Perl scripts use the proper suffix (@c .pl for scripts, and 
+-# Ensure all Perl scripts use the proper suffix (@c .pl for scripts, and
    @c .pm for modules)
 -# Pass files as script parameters or piped as input:
   - Do NOT code paths to files in the tree, as this breaks out-of-tree builds.

Modified: trunk/doc/manual/target/notarm.txt
===================================================================
--- trunk/doc/manual/target/notarm.txt	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/manual/target/notarm.txt	2009-09-21 18:52:45 UTC (rev 2744)
@@ -37,7 +37,7 @@
 @section targetnotarmsupport Target Support
 
 target.h is relatively CPU agnostic and
-the intention is to move in the direction of less 
+the intention is to move in the direction of less
 instruction set specific.
 
 Non-CPU targets are also supported, but there isn't
@@ -56,7 +56,7 @@
 The actual physical layer is a relatively modest part
 of the total OpenOCD system.
 
- 
+
 @section targetnotarmppc PowerPC
 
 there exists open source implementations of powerpc

Modified: trunk/doc/openocd.1
===================================================================
--- trunk/doc/openocd.1	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/openocd.1	2009-09-21 18:52:45 UTC (rev 2744)
@@ -8,19 +8,19 @@
 .B OpenOCD
 is an on\-chip debugging, in\-system programming and boundary\-scan
 testing tool for various ARM and MIPS systems.
-.PP 
+.PP
 The debugger uses an IEEE 1149\-1 compliant JTAG TAP bus master to access
 on\-chip debug functionality available on ARM based microcontrollers or
 system-on-chip solutions. For MIPS systems the EJTAG interface is supported.
-.PP 
+.PP
 User interaction is realized through a telnet command line interface,
 a gdb (the GNU debugger) remote protocol server, and a simplified RPC
 connection that can be used to interface with OpenOCD's Jim Tcl engine.
-.PP 
+.PP
 OpenOCD supports various different types of JTAG interfaces/programmers,
 please check the \fIopenocd\fR info page for the complete list.
 .SH "OPTIONS"
-.TP 
+.TP
 .B "\-f, \-\-file <filename>"
 Use configuration file
 .BR <filename> .
@@ -29,43 +29,43 @@
 arguments. If this option is omitted, the config file
 .B openocd.cfg
 in the current working directory will be used.
-.TP 
+.TP
 .B "\-s, \-\-search <dirname>"
 Search for config files and scripts in the directory
 .BR <dirname> .
 If this option is omitted, OpenOCD searches for config files and scripts
 in the current directory.
-.TP 
+.TP
 .B "\-d, \-\-debug <debuglevel>"
 Set debug level. Possible values are:
-.br 
+.br
 .RB "  * " 0 " (errors)"
-.br 
+.br
 .RB "  * " 1 " (warnings)"
-.br 
+.br
 .RB "  * " 2 " (informational messages)"
-.br 
+.br
 .RB "  * " 3 " (debug messages)"
-.br 
+.br
 The default level is
 .BR 2 .
-.TP 
+.TP
 .B "\-l, \-\-log_output <filename>"
 Redirect log output to the file
 .BR <filename> .
 Per default the log output is printed on
 .BR stderr .
-.TP 
+.TP
 .B "\-c, \-\-command <cmd>"
 Run the command
 .BR <cmd> .
-.TP 
+.TP
 .B "\-p, \-\-pipe"
 Use pipes when talking to gdb.
-.TP 
+.TP
 .B "\-h, \-\-help"
 Show a help text and exit.
-.TP 
+.TP
 .B "\-v, \-\-version"
 Show version information and exit.
 .SH "BUGS"
@@ -95,6 +95,6 @@
 .B http://openfacts.berlios.de/index-en.phtml?title=Open_On-Chip_Debugger
 .SH "AUTHORS"
 Please see the file AUTHORS.
-.PP 
+.PP
 This manual page was written by Uwe Hermann <uwe at hermann\-uwe.de>.
 It is licensed under the terms of the GNU GPL (version 2 or later).

Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-21 18:48:22 UTC (rev 2743)
+++ trunk/doc/openocd.texi	2009-09-21 18:52:45 UTC (rev 2744)
@@ -252,7 +252,7 @@
 
 There are several things you should keep in mind when choosing a dongle.
 
- at enumerate 
+ at enumerate
 @item @b{Voltage} What voltage is your target - 1.8, 2.8, 3.3, or 5V?
 Does your dongle support it?  You might need a level converter.
 @item @b{Pinout} What pinout does your target board use?
@@ -260,7 +260,7 @@
 wires, or an "octopus" connector, to convert pinouts.
 @item @b{Connection} Does your computer have the USB, printer, or
 Ethernet port needed?
- at item @b{RTCK} Do you require RTCK? Also known as ``adaptive clocking'' 
+ at item @b{RTCK} Do you require RTCK? Also known as ``adaptive clocking''
 @end enumerate
 
 @section Stand alone Systems
@@ -344,7 +344,7 @@
 @item @b{USBprog}
 @* Link: @url{http://www.embedded-projects.net/usbprog} - which uses an Atmel MEGA32 and a UBN9604
 
- at item @b{USB - Presto} 
+ at item @b{USB - Presto}
 @* Link: @url{http://tools.asix.net/prg_presto.htm}
 
 @item @b{Versaloon-Link}
@@ -2098,7 +2098,7 @@
 
 @option{srst_gates_jtag} indicates that asserting SRST gates the
 JTAG clock. This means that no communication can happen on JTAG
-while SRST is asserted. 
+while SRST is asserted.
 
 The optional @var{trst_type} and @var{srst_type} parameters allow the
 driver mode of each reset line to be specified.  These values only affect
@@ -4359,7 +4359,7 @@
 
 The target specific "dangerous" optimisation tweaking options may come and go
 as more robust and user friendly ways are found to ensure maximum throughput
-and robustness with a minimum of configuration. 
+and robustness with a minimum of configuration.
 
 Typically the "fast enable" is specified first on the command line:
 
@@ -4919,7 +4919,7 @@
 @deffn Command {armv4_5 reg}
 Display a table of all banked core registers, fetching the current value from every
 core mode if necessary. OpenOCD versions before rev. 60 didn't fetch the current
-register value. 
+register value.
 @end deffn
 
 @subsection ARM7 and ARM9 specific commands
@@ -4934,7 +4934,7 @@
 @deffn Command {arm7_9 dbgrq} (@option{enable}|@option{disable})
 Control use of the EmbeddedIce DBGRQ signal to force entry into debug mode,
 instead of breakpoints.  This should be
-safe for all but ARM7TDMI--S cores (like Philips LPC). 
+safe for all but ARM7TDMI--S cores (like Philips LPC).
 This feature is enabled by default on most ARM9 cores,
 including ARM9TDMI, ARM920T, and ARM926EJ-S.
 @end deffn
@@ -4952,7 +4952,7 @@
 Enable or disable memory writes and reads that don't check completion of
 the operation. This provides a huge speed increase, especially with USB JTAG
 cables (FT2232), but might be unsafe if used with targets running at very low
-speeds, like the 32kHz startup clock of an AT91RM9200. 
+speeds, like the 32kHz startup clock of an AT91RM9200.
 @end deffn
 
 @deffn {Debug Command} {arm7_9 write_core_reg} num mode word
@@ -5843,7 +5843,7 @@
 gdb_memory_map disable
 @end example
 For this to function correctly a valid flash configuration must also be set
-in OpenOCD. For faster performance you should also configure a valid 
+in OpenOCD. For faster performance you should also configure a valid
 working area.
 
 Informing GDB of the memory map of the target will enable GDB to protect any
@@ -5887,10 +5887,10 @@
 information as an argument to each proc.
 
 There are three main types of return values: single value, name value
-pair list and lists. 
+pair list and lists.
 
 Name value pair. The proc 'foo' below returns a name/value pair
-list. 
+list.
 
 @verbatim
 
@@ -5913,7 +5913,7 @@
                 puts "Name: $name, Value: $value"
      }
 @end verbatim
- 
+
 Lists returned must be relatively small. Otherwise a range
 should be passed in to the proc in question.
 
@@ -5949,7 +5949,7 @@
 variables. JimTCL, as implemented in OpenOCD creates $HostOS which
 holds one of the following values:
 
- at itemize @bullet 
+ at itemize @bullet
 @item @b{winxx}    Built using Microsoft Visual Studio
 @item @b{linux}    Linux is the underlying operating sytem
 @item @b{darwin}   Darwin (mac-os) is the underlying operating sytem.
@@ -6088,7 +6088,7 @@
 that ``deep sleeps'' at 32kHz between every keystroke. It can be
 painful.
 
- at b{Solution #1 - A special circuit} 
+ at b{Solution #1 - A special circuit}
 
 In order to make use of this, your JTAG dongle must support the RTCK
 feature. Not all dongles support this - keep reading!
@@ -6156,7 +6156,7 @@
 @item @b{Win32 Pathnames} Why don't backslashes work in Windows paths?
 
 OpenOCD uses Tcl and a backslash is an escape char. Use @{ and @}
-around Windows filenames. 
+around Windows filenames.
 
 @example
 > echo \a
@@ -6199,7 +6199,7 @@
 
 @item @b{Data Aborts} When debugging with OpenOCD and GDB (plain GDB, Insight, or Eclipse),
 I get lots of "Error: arm7_9_common.c:1771 arm7_9_read_memory():
-memory read caused data abort". 
+memory read caused data abort".
 
 The errors are non-fatal, and are the result of GDB trying to trace stack frames
 beyond the last valid frame. It might be possible to prevent this by setting up
@@ -6220,7 +6220,7 @@
 
 @b{Also note:} If you have a multi-threaded operating system, they
 often do not @b{in the intrest of saving memory} waste these few
-bytes. Painful... 
+bytes. Painful...
 
 
 @item @b{JTAG Reset Config} I get the following message in the OpenOCD console (or log file):
@@ -6342,7 +6342,7 @@
 
 @node Tcl Crash Course
 @chapter Tcl Crash Course
- at cindex Tcl 
+ at cindex Tcl
 
 Not everyone knows Tcl - this is not intended to be a replacement for
 learning Tcl, the intent of this chapter is to give you some idea of
@@ -6461,7 +6461,7 @@
 
 Commands are executed like this:
 
- at enumerate 
+ at enumerate
 @item Parse the next line into (argc) and (argv[]).
 @item Look up (argv[0]) in a table and call its function.
 @item Repeat until End Of File.
@@ -6609,7 +6609,7 @@
 @enumerate
 @item The SET command creates 2 variables, X and Y.
 @item The double [nested] EXPR command performs math
-@* The EXPR command produces numerical result as a string. 
+@* The EXPR command produces numerical result as a string.
 @* Refer to Rule #1
 @item The format command is executed, producing a single string
 @* Refer to Rule #1.
@@ -6632,7 +6632,7 @@
 #4 DANGER DANGER DANGER
    $_TARGETNAME configure -event foo "puts \"Time: [date]\""
 @end example
- at enumerate 
+ at enumerate
 @item The $_TARGETNAME is an OpenOCD variable convention.
 @*@b{$_TARGETNAME} represents the last target created, the value changes
 each time a new target is created. Remember the parsing rules. When
@@ -6699,9 +6699,9 @@
 OpenOCD comes with a target configuration script library. These scripts can be
 used as-is or serve as a starting point.
 
-The target library is published together with the OpenOCD executable and 
+The target library is published together with the OpenOCD executable and
 the path to the target library is in the OpenOCD script search path.
-Similarly there are example scripts for configuring the JTAG interface. 
+Similarly there are example scripts for configuring the JTAG interface.
 
 The command line below uses the example parport configuration script
 that ship with OpenOCD, then configures the str710.cfg target and



From dbrownell at mail.berlios.de  Mon Sep 21 23:35:57 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 21 Sep 2009 23:35:57 +0200
Subject: [Openocd-svn] r2745 - trunk/doc
Message-ID: <200909212135.n8LLZvKB008985@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-21 23:35:56 +0200 (Mon, 21 Sep 2009)
New Revision: 2745

Modified:
   trunk/doc/openocd.texi
Log:
Update presentation of TAP events and tap enable/disable.

Highlight that the "post-reset" event kicks in before the
scan chain is validated, which limits what can be done
in a post-reset handler.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-21 18:52:45 UTC (rev 2744)
+++ trunk/doc/openocd.texi	2009-09-21 21:35:56 UTC (rev 2745)
@@ -2343,12 +2343,69 @@
 @end itemize
 @end deffn
 
+ at section Other TAP commands
+
 @c @deffn Command {jtag arp_init-reset}
- at c ... more or less "init" ?
+ at c ... more or less "toggle TRST ... and SRST too, what the heck"
 
+ at deffn Command {jtag cget} dotted.name @option{-event} name
+ at deffnx Command {jtag configure} dotted.name @option{-event} name string
+At this writing this TAP attribute
+mechanism is used only for event handling.
+(It is not a direct analogue of the @code{cget}/@code{configure}
+mechanism for debugger targets.)
+See the next section for information about the available events.
+
+The @code{configure} subcommand assigns an event handler,
+a TCL string which is evaluated when the event is triggered.
+The @code{cget} subcommand returns that handler.
+ at end deffn
+
+ at anchor{TAP Events}
+ at section TAP Events
+ at cindex events
+ at cindex TAP events
+
+OpenOCD includes two event mechanisms.
+The one presented here applies to all JTAG TAPs.
+The other applies to debugger targets,
+which are associated with certain TAPs.
+
+The TAP events currently defined are:
+
+ at itemize @bullet
+ at item @b{post-reset}
+@* The TAP has just completed a JTAG reset.
+For the first such handler called, the tap is still
+in the JTAG @sc{reset} state.
+Because the scan chain has not yet been verified, handlers for these events
+ at emph{should not issue commands which scan the JTAG IR or DR registers}
+of any particular target.
+ at b{NOTE:} As this is written (September 2009), nothing prevents such access.
+ at item @b{tap-disable}
+@* The TAP needs to be disabled.  This handler should
+implement @command{jtag tapdisable}
+by issuing the relevant JTAG commands.
+ at item @b{tap-enable}
+@* The TAP needs to be enabled.  This handler should
+implement @command{jtag tapenable}
+by issuing the relevant JTAG commands.
+ at end itemize
+
+If you need some action after each JTAG reset, which isn't actually
+specific to any TAP (since you can't yet trust the scan chain's
+contents to be accurate), you might:
+
+ at example
+jtag configure CHIP.jrc -event post-reset @{
+  echo "Reset done"
+  ... non-scan jtag operations to be done after reset
+@}
+ at end example
+
+
 @anchor{Enabling and Disabling TAPs}
 @section Enabling and Disabling TAPs
- at cindex TAP events
 @cindex JTAG Route Controller
 @cindex jrc
 
@@ -2380,20 +2437,9 @@
 
 @c (a) currently the event handlers don't seem to be able to
 @c     fail in a way that could lead to no-change-of-state.
- at c (b) eventually non-event configuration should be possible,
- at c     in which case some this documentation must move.
 
- at deffn Command {jtag cget} dotted.name @option{-event} name
- at deffnx Command {jtag configure} dotted.name @option{-event} name string
-At this writing this mechanism is used only for event handling.
-Three events are available. Two events relate to TAP enabling
-and disabling, one to post reset handling.
-
-The @code{configure} subcommand assigns an event handler,
-a TCL string which is evaluated when the event is triggered.
-The @code{cget} subcommand returns that handler.
-The three possible values for an event @var{name} are @option{tap-disable}, @option{tap-enable} and @option{post-reset}.
-
+In OpenOCD, tap enabling/disabling is invoked by the Tcl commands
+shown below, and is implemented using TAP event handlers.
 So for example, when defining a TAP for a CPU connected to
 a JTAG router, you should define TAP event handlers using
 code that looks something like this:
@@ -2409,30 +2455,29 @@
 @}
 @end example
 
-If you need some post reset action, you can do:
+ at deffn Command {jtag tapdisable} dotted.name
+If necessary, disables the tap
+by sending it a @option{tap-disable} event.
+Returns the string "1" if the tap
+specified by @var{dotted.name} is enabled,
+and "0" if it is disbabled.
+ at end deffn
 
- at example
-jtag configure CHIP.cpu -event post-reset @{
-  echo "Reset done"
-  ... jtag operations to be done after reset
-@}
- at end example
+ at deffn Command {jtag tapenable} dotted.name
+If necessary, enables the tap
+by sending it a @option{tap-enable} event.
+Returns the string "1" if the tap
+specified by @var{dotted.name} is enabled,
+and "0" if it is disbabled.
 @end deffn
 
- at deffn Command {jtag tapdisable} dotted.name
- at deffnx Command {jtag tapenable} dotted.name
- at deffnx Command {jtag tapisenabled} dotted.name
-These three commands all return the string "1" if the tap
+ at deffn Command {jtag tapisenabled} dotted.name
+Returns the string "1" if the tap
 specified by @var{dotted.name} is enabled,
 and "0" if it is disbabled.
-The @command{tapenable} variant first enables the tap
-by sending it a @option{tap-enable} event.
-The @command{tapdisable} variant first disables the tap
-by sending it a @option{tap-disable} event.
 
 @quotation Note
 Humans will find the @command{scan_chain} command more helpful
-than the script-oriented @command{tapisenabled}
 for querying the state of the JTAG taps.
 @end quotation
 @end deffn
@@ -2889,6 +2934,7 @@
 
 @anchor{Target Events}
 @section Target Events
+ at cindex target events
 @cindex events
 At various times, certain things can happen, or you want them to happen.
 For example:



From dbrownell at mail.berlios.de  Tue Sep 22 07:39:11 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Tue, 22 Sep 2009 07:39:11 +0200
Subject: [Openocd-svn] r2746 - in trunk: doc src/flash
Message-ID: <200909220539.n8M5dBsK008180@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-22 07:39:06 +0200 (Tue, 22 Sep 2009)
New Revision: 2746

Modified:
   trunk/doc/openocd.texi
   trunk/src/flash/flash.c
Log:
Make it easier to erase or protect through to the end
of a (NOR) flash chip: allow passing "last" as an alias
for the number of the last sector.

Improve several aspects of error checking while we're at it.

From: Johnny Halfmoon <jhalfmoon at milksnot.com>


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-21 21:35:56 UTC (rev 2745)
+++ trunk/doc/openocd.texi	2009-09-22 05:39:06 UTC (rev 2746)
@@ -3187,8 +3187,11 @@
 
 @anchor{flash erase_sector}
 @deffn Command {flash erase_sector} num first last
-Erase sectors in bank @var{num}, starting at sector @var{first} up to and including
- at var{last}. Sector numbering starts at 0.
+Erase sectors in bank @var{num}, starting at sector @var{first}
+up to and including @var{last}.
+Sector numbering starts at 0.
+Providing a @var{last} sector of @option{last}
+specifies "to the end of the flash bank".
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
@@ -3247,7 +3250,7 @@
 The @var{num} parameter is a value shown by @command{flash banks}.
 This is the only operation that
 updates the erase state information displayed by @option{flash info}. That means you have
-to issue an @command{flash erase_check} command after erasing or programming the device
+to issue a @command{flash erase_check} command after erasing or programming the device
 to get updated information.
 (Code execution may have invalidated any state records kept by OpenOCD.)
 @end deffn
@@ -3259,9 +3262,12 @@
 @end deffn
 
 @anchor{flash protect}
- at deffn Command {flash protect} num first last (on|off)
-Enable (@var{on}) or disable (@var{off}) protection of flash sectors
- at var{first} to @var{last} of flash bank @var{num}.
+ at deffn Command {flash protect} num first last (@option{on}|@option{off})
+Enable (@option{on}) or disable (@option{off}) protection of flash sectors
+in flash bank @var{num}, starting at sector @var{first}
+and continuing up to and including @var{last}.
+Providing a @var{last} sector of @option{last}
+specifies "to the end of the flash bank".
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-09-21 21:35:56 UTC (rev 2745)
+++ trunk/src/flash/flash.c	2009-09-22 05:39:06 UTC (rev 2746)
@@ -559,82 +559,121 @@
 	return ERROR_OK;
 }
 
-static int handle_flash_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int flash_check_sector_parameters(struct command_context_s *cmd_ctx,
+		uint32_t first, uint32_t last, uint num_sectors)
 {
+	if (!(first <= last)) {
+		command_print(cmd_ctx, "ERROR: "
+				"first sector must be <= last sector");
+		return ERROR_FAIL;
+	}
+
+	if (!(last <= (num_sectors - 1))) {
+		command_print(cmd_ctx, "ERROR: "
+				"last sector must be <= %d", num_sectors - 1);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+static int handle_flash_erase_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
 	if (argc > 2)
 	{
-		int first = strtoul(args[1], NULL, 0);
-		int last = strtoul(args[2], NULL, 0);
+		uint32_t bank_nr;
+		uint32_t first;
+		uint32_t last;
 		int retval;
-		flash_bank_t *p = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-		duration_t duration;
-		char *duration_text;
 
-		duration_start_measure(&duration);
+		if ((retval = parse_u32(args[0], &bank_nr)) != ERROR_OK)
+			return retval;
 
+		flash_bank_t *p = get_flash_bank_by_num(bank_nr);
 		if (!p)
-		{
-			return ERROR_COMMAND_SYNTAX_ERROR;
-		}
+			return ERROR_OK;
 
-		if ((retval = flash_driver_erase(p, first, last)) == ERROR_OK)
-		{
-			if ((retval = duration_stop_measure(&duration, &duration_text)) != ERROR_OK)
-			{
+		if ((retval = parse_u32(args[1], &first)) != ERROR_OK)
+			return retval;
+		if (strcmp(args[2], "last") == 0)
+			last = p->num_sectors - 1;
+		else
+			if ((retval = parse_u32(args[2], &last)) != ERROR_OK)
 				return retval;
-			}
 
-			command_print(cmd_ctx, "erased sectors %i through %i on flash bank %li in %s",
-				first, last, strtoul(args[0], 0, 0), duration_text);
+		if ((retval = flash_check_sector_parameters(cmd_ctx,
+				first, last, p->num_sectors)) != ERROR_OK)
+			return retval;
+
+		duration_t duration;
+		char *duration_text;
+		duration_start_measure(&duration);
+
+		if ((retval = flash_driver_erase(p, first, last)) == ERROR_OK) {
+			if ((retval = duration_stop_measure(&duration,
+						&duration_text)) != ERROR_OK)
+				return retval;
+			command_print(cmd_ctx, "erased sectors %i through %i "
+					"on flash bank %i in %s",
+				first, last, bank_nr, duration_text);
 			free(duration_text);
 		}
 	}
 	else
-	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
 
 	return ERROR_OK;
 }
 
-static int handle_flash_protect_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_flash_protect_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
 {
 	if (argc > 3)
 	{
-		int first = strtoul(args[1], NULL, 0);
-		int last = strtoul(args[2], NULL, 0);
+		uint32_t bank_nr;
+		uint32_t first;
+		uint32_t last;
+		int retval;
 		int set;
-		int retval;
-		flash_bank_t *p = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+
+		if ((retval = parse_u32(args[0], &bank_nr)) != ERROR_OK)
+			return retval;
+
+		flash_bank_t *p = get_flash_bank_by_num(bank_nr);
 		if (!p)
-		{
-			command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
 			return ERROR_OK;
-		}
 
+		if ((retval = parse_u32(args[1], &first)) != ERROR_OK)
+			return retval;
+		if (strcmp(args[2], "last") == 0)
+			last = p->num_sectors - 1;
+		else
+			if ((retval = parse_u32(args[2], &last)) != ERROR_OK)
+				return retval;
+
 		if (strcmp(args[3], "on") == 0)
 			set = 1;
 		else if (strcmp(args[3], "off") == 0)
 			set = 0;
 		else
-		{
 			return ERROR_COMMAND_SYNTAX_ERROR;
-		}
 
+		if ((retval = flash_check_sector_parameters(cmd_ctx,
+				first, last, p->num_sectors)) != ERROR_OK)
+			return retval;
+
 		retval = flash_driver_protect(p, set, first, last);
-		if (retval == ERROR_OK)
-		{
-			command_print(cmd_ctx, "%s protection for sectors %i through %i on flash bank %li",
+		if (retval == ERROR_OK) {
+			command_print(cmd_ctx, "%s protection for sectors %i "
+					"through %i on flash bank %i",
 				(set) ? "set" : "cleared", first,
-				last, strtoul(args[0], 0, 0));
+				last, bank_nr);
 		}
 	}
 	else
-	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	}
-
 	return ERROR_OK;
 }
 



From ntfreak at mail.berlios.de  Tue Sep 22 16:50:48 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 22 Sep 2009 16:50:48 +0200
Subject: [Openocd-svn] r2747 - in trunk: src/flash tcl/board
Message-ID: <200909221450.n8MEomJb032672@sheep.berlios.de>

Author: ntfreak
Date: 2009-09-22 16:50:46 +0200 (Tue, 22 Sep 2009)
New Revision: 2747

Modified:
   trunk/src/flash/lpc2900.c
   trunk/src/flash/lpc2900.h
   trunk/tcl/board/csb337.cfg
   trunk/tcl/board/ek-lm3s3748.cfg
Log:
- add missing svn props from previous commit

Modified: trunk/src/flash/lpc2900.c
===================================================================
--- trunk/src/flash/lpc2900.c	2009-09-22 05:39:06 UTC (rev 2746)
+++ trunk/src/flash/lpc2900.c	2009-09-22 14:50:46 UTC (rev 2747)
@@ -1,1926 +1,1926 @@
-/***************************************************************************
- *   Copyright (C) 2009 by                                                 *
- *   Rolf Meeser <rolfm_9dq at yahoo.de>                                      *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-
-#include "image.h"
-
-#include "lpc2900.h"
-#include "binarybuffer.h"
-#include "armv4_5.h"
-
-
-/* 1024 bytes */
-#define KiB                 1024
-
-/* Some flash constants */
-#define FLASH_PAGE_SIZE     512     /* bytes */
-#define FLASH_ERASE_TIME    100000  /* microseconds */
-#define FLASH_PROGRAM_TIME  1000    /* microseconds */
-
-/* Chip ID / Feature Registers */
-#define CHIPID          0xE0000000  /* Chip ID */
-#define FEAT0           0xE0000100  /* Chip feature 0 */
-#define FEAT1           0xE0000104  /* Chip feature 1 */
-#define FEAT2           0xE0000108  /* Chip feature 2 (contains flash size indicator) */
-#define FEAT3           0xE000010C  /* Chip feature 3 */
-
-#define EXPECTED_CHIPID 0x209CE02B  /* Chip ID of all LPC2900 devices */
-
-/* Flash/EEPROM Control Registers */
-#define FCTR            0x20200000  /* Flash control */
-#define FPTR            0x20200008  /* Flash program-time */
-#define FTCTR           0x2020000C  /* Flash test control */
-#define FBWST           0x20200010  /* Flash bridge wait-state */
-#define FCRA            0x2020001C  /* Flash clock divider */
-#define FMSSTART        0x20200020  /* Flash Built-In Selft Test start address */
-#define FMSSTOP         0x20200024  /* Flash Built-In Selft Test stop address */
-#define FMS16           0x20200028  /* Flash 16-bit signature */
-#define FMSW0           0x2020002C  /* Flash 128-bit signature Word 0 */
-#define FMSW1           0x20200030  /* Flash 128-bit signature Word 1 */
-#define FMSW2           0x20200034  /* Flash 128-bit signature Word 2 */
-#define FMSW3           0x20200038  /* Flash 128-bit signature Word 3 */
-
-#define EECMD           0x20200080  /* EEPROM command */
-#define EEADDR          0x20200084  /* EEPROM address */
-#define EEWDATA         0x20200088  /* EEPROM write data */
-#define EERDATA         0x2020008C  /* EEPROM read data */
-#define EEWSTATE        0x20200090  /* EEPROM wait state */
-#define EECLKDIV        0x20200094  /* EEPROM clock divider */
-#define EEPWRDWN        0x20200098  /* EEPROM power-down/start */
-#define EEMSSTART       0x2020009C  /* EEPROM BIST start address */
-#define EEMSSTOP        0x202000A0  /* EEPROM BIST stop address */
-#define EEMSSIG         0x202000A4  /* EEPROM 24-bit BIST signature */
-
-#define INT_CLR_ENABLE  0x20200FD8  /* Flash/EEPROM interrupt clear enable */
-#define INT_SET_ENABLE  0x20200FDC  /* Flash/EEPROM interrupt set enable */
-#define INT_STATUS      0x20200FE0  /* Flash/EEPROM interrupt status */
-#define INT_ENABLE      0x20200FE4  /* Flash/EEPROM interrupt enable */
-#define INT_CLR_STATUS  0x20200FE8  /* Flash/EEPROM interrupt clear status */
-#define INT_SET_STATUS  0x20200FEC  /* Flash/EEPROM interrupt set status */
-
-/* Interrupt sources */
-#define INTSRC_END_OF_PROG    (1 << 28)
-#define INTSRC_END_OF_BIST    (1 << 27)
-#define INTSRC_END_OF_RDWR    (1 << 26)
-#define INTSRC_END_OF_MISR    (1 << 2)
-#define INTSRC_END_OF_BURN    (1 << 1)
-#define INTSRC_END_OF_ERASE   (1 << 0)
-
-
-/* FCTR bits */
-#define FCTR_FS_LOADREQ       (1 << 15)
-#define FCTR_FS_CACHECLR      (1 << 14)
-#define FCTR_FS_CACHEBYP      (1 << 13)
-#define FCTR_FS_PROGREQ       (1 << 12)
-#define FCTR_FS_RLS           (1 << 11)
-#define FCTR_FS_PDL           (1 << 10)
-#define FCTR_FS_PD            (1 << 9)
-#define FCTR_FS_WPB           (1 << 7)
-#define FCTR_FS_ISS           (1 << 6)
-#define FCTR_FS_RLD           (1 << 5)
-#define FCTR_FS_DCR           (1 << 4)
-#define FCTR_FS_WEB           (1 << 2)
-#define FCTR_FS_WRE           (1 << 1)
-#define FCTR_FS_CS            (1 << 0)
-/* FPTR bits */
-#define FPTR_EN_T             (1 << 15)
-/* FTCTR bits */
-#define FTCTR_FS_BYPASS_R     (1 << 29)
-#define FTCTR_FS_BYPASS_W     (1 << 28)
-/* FMSSTOP bits */
-#define FMSSTOP_MISR_START    (1 << 17)
-/* EEMSSTOP bits */
-#define EEMSSTOP_STRTBIST     (1 << 31)
-
-/* Index sector */
-#define ISS_CUSTOMER_START1   (0x830)
-#define ISS_CUSTOMER_END1     (0xA00)
-#define ISS_CUSTOMER_SIZE1    (ISS_CUSTOMER_END1 - ISS_CUSTOMER_START1)
-#define ISS_CUSTOMER_NWORDS1  (ISS_CUSTOMER_SIZE1 / 4)
-#define ISS_CUSTOMER_START2   (0xA40)
-#define ISS_CUSTOMER_END2     (0xC00)
-#define ISS_CUSTOMER_SIZE2    (ISS_CUSTOMER_END2 - ISS_CUSTOMER_START2)
-#define ISS_CUSTOMER_NWORDS2  (ISS_CUSTOMER_SIZE2 / 4)
-#define ISS_CUSTOMER_SIZE     (ISS_CUSTOMER_SIZE1 + ISS_CUSTOMER_SIZE2)
-
-
-
-/**
- * Private data for \c lpc2900 flash driver.
- */
-typedef struct lpc2900_flash_bank_s
-{
-	/**
-	 * Holds the value read from CHIPID register.
-	 * The driver will not load if the chipid doesn't match the expected
-	 * value of 0x209CE02B of the LPC2900 family. A probe will only be done
-	 * if the chipid does not yet contain the expected value.
-	 */
-	uint32_t chipid;
-
-	/**
-	 * String holding device name.
-	 * This string is set by the probe function to the type number of the
-	 * device. It takes the form "LPC29xx".
-	 */
-	char * target_name;
-
-	/**
-	 * System clock frequency.
-	 * Holds the clock frequency in Hz, as passed by the configuration file
-	 * to the <tt>flash bank</tt> command.
-	 */
-	uint32_t clk_sys_fmc;
-
-	/**
-	 * Flag to indicate that dangerous operations are possible.
-	 * This flag can be set by passing the correct password to the
-	 * <tt>lpc2900 password</tt> command. If set, other dangerous commands,
-	 * which operate on the index sector, can be executed.
-	 */
-	uint32_t risky;
-
-	/**
-	 * Maximum contiguous block of internal SRAM (bytes).
-	 * Autodetected by the driver. Not the total amount of SRAM, only the
-	 * the largest \em contiguous block!
-	 */
-	uint32_t max_ram_block;
-
-} lpc2900_flash_bank_t;
-
-
-
-
-static int lpc2900_register_commands(struct command_context_s *cmd_ctx);
-static int lpc2900_flash_bank_command(struct command_context_s *cmd_ctx,
-                                      char *cmd, char **args, int argc,
-                                      struct flash_bank_s *bank);
-static int lpc2900_erase(struct flash_bank_s *bank, int first, int last);
-static int lpc2900_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int lpc2900_write(struct flash_bank_s *bank,
-                         uint8_t *buffer, uint32_t offset, uint32_t count);
-static int lpc2900_probe(struct flash_bank_s *bank);
-static int lpc2900_erase_check(struct flash_bank_s *bank);
-static int lpc2900_protect_check(struct flash_bank_s *bank);
-static int lpc2900_info(struct flash_bank_s *bank, char *buf, int buf_size);
-
-static uint32_t lpc2900_wait_status(flash_bank_t *bank, uint32_t mask, int timeout);
-static void lpc2900_setup(struct flash_bank_s *bank);
-static uint32_t lpc2900_is_ready(struct flash_bank_s *bank);
-static uint32_t lpc2900_read_security_status(struct flash_bank_s *bank);
-static uint32_t lpc2900_run_bist128(struct flash_bank_s *bank,
-                                    uint32_t addr_from, uint32_t addr_to,
-                                    uint32_t (*signature)[4] );
-static uint32_t lpc2900_address2sector(struct flash_bank_s *bank, uint32_t offset);
-static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time );
-
-
-/***********************  Helper functions  **************************/
-
-
-/**
- * Wait for an event in mask to occur in INT_STATUS.
- *
- * Return when an event occurs, or after a timeout.
- *
- * @param[in] bank Pointer to the flash bank descriptor
- * @param[in] mask Mask to be used for INT_STATUS
- * @param[in] timeout Timeout in ms
- */
-static uint32_t lpc2900_wait_status( flash_bank_t *bank,
-                                     uint32_t mask,
-                                     int timeout )
-{
-	uint32_t int_status;
-	target_t *target = bank->target;
-
-
-	do
-	{
-		alive_sleep(1);
-		timeout--;
-		target_read_u32(target, INT_STATUS, &int_status);
-	}
-	while( ((int_status & mask) == 0) && (timeout != 0) );
-
-	if (timeout == 0)
-	{
-		LOG_DEBUG("Timeout!");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-
-
-/**
- * Set up the flash for erase/program operations.
- *
- * Enable the flash, and set the correct CRA clock of 66 kHz.
- *
- * @param bank Pointer to the flash bank descriptor
- */
-static void lpc2900_setup( struct flash_bank_s *bank )
-{
-	uint32_t fcra;
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-
-	/* Power up the flash block */
-	target_write_u32( bank->target, FCTR, FCTR_FS_WEB | FCTR_FS_CS );
-
-
-	fcra = (lpc2900_info->clk_sys_fmc / (3 * 66000)) - 1;
-	target_write_u32( bank->target, FCRA, fcra );
-}
-
-
-
-/**
- * Check if device is ready.
- *
- * Check if device is ready for flash operation:
- * Must have been successfully probed.
- * Must be halted.
- */
-static uint32_t lpc2900_is_ready( struct flash_bank_s *bank )
-{
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-	if( lpc2900_info->chipid != EXPECTED_CHIPID )
-	{
-		return ERROR_FLASH_BANK_NOT_PROBED;
-	}
-
-	if( bank->target->state != TARGET_HALTED )
-	{
-		LOG_ERROR( "Target not halted" );
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	return ERROR_OK;
-}
-
-
-/**
- * Read the status of sector security from the index sector.
- *
- * @param bank Pointer to the flash bank descriptor
- */
-static uint32_t lpc2900_read_security_status( struct flash_bank_s *bank )
-{
-	uint32_t status;
-	if( (status = lpc2900_is_ready( bank )) != ERROR_OK )
-	{
-		return status;
-	}
-
-	target_t *target = bank->target;
-
-	/* Enable ISS access */
-	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB | FCTR_FS_ISS);
-
-	/* Read the relevant block of memory from the ISS sector */
-	uint32_t iss_secured_field[ 0x230/16 ][ 4 ];
-	target_read_memory(target, bank->base + 0xC00, 4, 0x230/4,
-	                           (uint8_t *)iss_secured_field);
-
-	/* Disable ISS access */
-	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
-
-	/* Check status of each sector. Note that the sector numbering in the LPC2900
-	 * is different from the logical sector numbers used in OpenOCD!
-	 * Refer to the user manual for details.
-	 *
-	 * All zeros (16x 0x00) are treated as a secured sector (is_protected = 1)
-	 * All ones (16x 0xFF) are treated as a non-secured sector (is_protected = 0)
-	 * Anything else is undefined (is_protected = -1). This is treated as
-	 * a protected sector!
-	 */
-	int sector;
-	int index;
-	for( sector = 0; sector < bank->num_sectors; sector++ )
-	{
-		/* Convert logical sector number to physical sector number */
-		if( sector <= 4 )
-		{
-			index = sector + 11;
-		}
-		else if( sector <= 7 )
-		{
-			index = sector + 27;
-		}
-		else
-		{
-			index = sector - 8;
-		}
-
-		bank->sectors[sector].is_protected = -1;
-
-		if (
-		    (iss_secured_field[index][0] == 0x00000000) &&
-		    (iss_secured_field[index][1] == 0x00000000) &&
-		    (iss_secured_field[index][2] == 0x00000000) &&
-		    (iss_secured_field[index][3] == 0x00000000) )
-		{
-			bank->sectors[sector].is_protected = 1;
-		}
-
-		if (
-		    (iss_secured_field[index][0] == 0xFFFFFFFF) &&
-		    (iss_secured_field[index][1] == 0xFFFFFFFF) &&
-		    (iss_secured_field[index][2] == 0xFFFFFFFF) &&
-		    (iss_secured_field[index][3] == 0xFFFFFFFF) )
-		{
-			bank->sectors[sector].is_protected = 0;
-		}
-	}
-
-	return ERROR_OK;
-}
-
-
-/**
- * Use BIST to calculate a 128-bit hash value over a range of flash.
- *
- * @param bank Pointer to the flash bank descriptor
- * @param addr_from
- * @param addr_to
- * @param signature
- */
-static uint32_t lpc2900_run_bist128(struct flash_bank_s *bank,
-                                    uint32_t addr_from,
-                                    uint32_t addr_to,
-                                    uint32_t (*signature)[4] )
-{
-	target_t *target = bank->target;
-
-	/* Clear END_OF_MISR interrupt status */
-	target_write_u32( target, INT_CLR_STATUS, INTSRC_END_OF_MISR );
-
-	/* Start address */
-	target_write_u32( target, FMSSTART, addr_from >> 4);
-	/* End address, and issue start command */
-	target_write_u32( target, FMSSTOP, (addr_to >> 4) | FMSSTOP_MISR_START );
-
-	/* Poll for end of operation. Calculate a reasonable timeout. */
-	if( lpc2900_wait_status( bank, INTSRC_END_OF_MISR, 1000 ) != ERROR_OK )
-	{
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	/* Return the signature */
-	target_read_memory( target, FMSW0, 4, 4, (uint8_t *)signature );
-
-	return ERROR_OK;
-}
-
-
-/**
- * Return sector number for given address.
- *
- * Return the (logical) sector number for a given relative address.
- * No sanity check is done. It assumed that the address is valid.
- *
- * @param bank Pointer to the flash bank descriptor
- * @param offset Offset address relative to bank start
- */
-static uint32_t lpc2900_address2sector( struct flash_bank_s *bank,
-                                        uint32_t offset )
-{
-	uint32_t address = bank->base + offset;
-
-
-	/* Run through all sectors of this bank */
-	int sector;
-	for( sector = 0; sector < bank->num_sectors; sector++ )
-	{
-		/* Return immediately if address is within the current sector */
-		if( address < (bank->sectors[sector].offset + bank->sectors[sector].size) )
-		{
-			return sector;
-		}
-	}
-
-	/* We should never come here. If we do, return an arbitrary sector number. */
-	return 0;
-}
-
-
-
-
-/**
- * Write one page to the index sector.
- *
- * @param bank Pointer to the flash bank descriptor
- * @param pagenum Page number (0...7)
- * @param page Page array (FLASH_PAGE_SIZE bytes)
- */
-static int lpc2900_write_index_page( struct flash_bank_s *bank,
-                                     int pagenum,
-                                     uint8_t (*page)[FLASH_PAGE_SIZE] )
-{
-	/* Only pages 4...7 are user writable */
-	if( (pagenum < 4) || (pagenum > 7) )
-	{
-		LOG_ERROR( "Refuse to burn index sector page %" PRIu32, pagenum );
-		return ERROR_COMMAND_ARGUMENT_INVALID;
-	}
-
-	/* Get target, and check if it's halted */
-	target_t *target = bank->target;
-	if( target->state != TARGET_HALTED )
-	{
-		LOG_ERROR( "Target not halted" );
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* Private info */
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-	/* Enable flash block and set the correct CRA clock of 66 kHz */
-	lpc2900_setup( bank );
-
-	/* Un-protect the index sector */
-	target_write_u32( target, bank->base, 0 );
-	target_write_u32( target, FCTR,
-	                  FCTR_FS_LOADREQ | FCTR_FS_WPB | FCTR_FS_ISS |
-	                  FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS );
-
-	/* Set latch load mode */
-	target_write_u32( target, FCTR,
-	                  FCTR_FS_ISS | FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS );
-
-	/* Write whole page to flash data latches */
-	if( target_write_memory( target,
-	                         bank->base + pagenum * FLASH_PAGE_SIZE,
-	                         4, FLASH_PAGE_SIZE / 4, (uint8_t *)page) != ERROR_OK )
-	{
-		LOG_ERROR( "Index sector write failed @ page %" PRIu32, pagenum );
-		target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
-
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	/* Clear END_OF_BURN interrupt status */
-	target_write_u32( target, INT_CLR_STATUS, INTSRC_END_OF_BURN );
-
-	/* Set the program/erase time to FLASH_PROGRAM_TIME */
-	target_write_u32(target, FPTR,
-	                 FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
-	                                              FLASH_PROGRAM_TIME ));
-
-	/* Trigger flash write */
-	target_write_u32( target, FCTR,
-	                  FCTR_FS_PROGREQ | FCTR_FS_ISS |
-	                  FCTR_FS_WPB | FCTR_FS_WRE | FCTR_FS_CS );
-
-	/* Wait for the end of the write operation. If it's not over after one
-	 * second, something went dreadfully wrong... :-(
-	 */
-	if( lpc2900_wait_status( bank, INTSRC_END_OF_BURN, 1000 ) != ERROR_OK )
-	{
-		LOG_ERROR( "Index sector write failed @ page %" PRIu32, pagenum );
-		target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
-
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
-
-	return ERROR_OK;
-}
-
-
-
-/**
- * Calculate FPTR.TR register value for desired program/erase time.
- *
- * @param clock System clock in Hz
- * @param time Program/erase time in ?s
- */
-static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time )
-{
-	/*           ((time[?s]/1e6) * f[Hz]) + 511
-	 * FPTR.TR = -------------------------------
-	 *                         512
-	 *
-	 * The result is the 
-	 */
-
-	uint32_t tr_val = (uint32_t)((((time / 1e6) * clock) + 511.0) / 512.0);
-
-	return tr_val;
-}
-
-
-/***********************  Private flash commands  **************************/
-
-
-/**
- * Command to determine the signature of the whole flash.
- *
- * Uses the Built-In-Self-Test (BIST) to generate a 128-bit hash value
- * of the flash content.
- *
- * @param cmd_ctx
- * @param cmd
- * @param args
- * @param argc
- */
-static int lpc2900_handle_signature_command( struct command_context_s *cmd_ctx,
-                                             char *cmd, char **args, int argc )
-{
-	flash_bank_t *bank;
-	uint32_t status;
-	uint32_t signature[4];
-
-
-	if( argc < 1 )
-	{
-		LOG_WARNING( "Too few arguments. Call: lpc2900 signature <bank#>" );
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	/* Get the bank descriptor */
-	bank = get_flash_bank_by_num( strtoul(args[0], NULL, 0) );
-	if( !bank )
-	{
-		command_print( cmd_ctx, "flash bank '#%s' is out of bounds", args[0] );
-		return ERROR_OK;
-	}
-
-	if( bank->target->state != TARGET_HALTED )
-	{
-		LOG_ERROR( "Target not halted" );
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* Run BIST over whole flash range */
-	if( (status = lpc2900_run_bist128( bank,
-	                                   bank->base,
-	                                   bank->base + (bank->size - 1),
-	                                   &signature)
-	                                 ) != ERROR_OK )
-	{
-		return status;
-	}
-
-	command_print( cmd_ctx, "signature: 0x%8.8" PRIx32
-	                                  ":0x%8.8" PRIx32
-	                                  ":0x%8.8" PRIx32
-	                                  ":0x%8.8" PRIx32,
-	              signature[3], signature[2], signature[1], signature[0] );
-
-	return ERROR_OK;
-}
-
-
-
-/**
- * Store customer info in file.
- *
- * Read customer info from index sector, and store that block of data into
- * a disk file. The format is binary.
- *
- * @param cmd_ctx
- * @param cmd
- * @param args
- * @param argc
- */
-static int lpc2900_handle_read_custom_command( struct command_context_s *cmd_ctx,
-                                               char *cmd, char **args, int argc )
-{
-	flash_bank_t *bank;
-
-
-	if( argc < 2 )
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* Get the bank descriptor */
-	bank = get_flash_bank_by_num( strtoul(args[0], NULL, 0) );
-	if( !bank )
-	{
-		command_print( cmd_ctx, "flash bank '#%s' is out of bounds", args[0] );
-		return ERROR_OK;
-	}
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-	lpc2900_info->risky = 0;
-
-	/* Get target, and check if it's halted */
-	target_t *target = bank->target;
-	if( target->state != TARGET_HALTED )
-	{
-		LOG_ERROR( "Target not halted" );
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* Storage for customer info. Read in two parts */
-	uint32_t customer[ ISS_CUSTOMER_NWORDS1 + ISS_CUSTOMER_NWORDS2 ];
-
-	/* Enable access to index sector */
-	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB | FCTR_FS_ISS );
-
-	/* Read two parts */
-	target_read_memory( target, bank->base+ISS_CUSTOMER_START1, 4,
-	                            ISS_CUSTOMER_NWORDS1,
-	                            (uint8_t *)&customer[0] );
-	target_read_memory( target, bank->base+ISS_CUSTOMER_START2, 4,
-	                            ISS_CUSTOMER_NWORDS2,
-	                            (uint8_t *)&customer[ISS_CUSTOMER_NWORDS1] );
-
-	/* Deactivate access to index sector */
-	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
-
-	/* Try and open the file */
-	fileio_t fileio;
-	char *filename = args[1];
-	int ret = fileio_open( &fileio, filename, FILEIO_WRITE, FILEIO_BINARY );
-	if( ret != ERROR_OK )
-	{
-		LOG_WARNING( "Could not open file %s", filename );
-		return ret;
-	}
-
-	uint32_t nwritten;
-	ret = fileio_write( &fileio, sizeof(customer),
-                        (const uint8_t *)customer, &nwritten );
-	if( ret != ERROR_OK )
-	{
-		LOG_ERROR( "Write operation to file %s failed", filename );
-		fileio_close( &fileio );
-		return ret;
-	}
-
-	fileio_close( &fileio );
-
-	return ERROR_OK;
-}
-
-
-
-
-/**
- * Enter password to enable potentially dangerous options.
- *
- * @param cmd_ctx
- * @param cmd
- * @param args
- * @param argc
- */
-static int lpc2900_handle_password_command(struct command_context_s *cmd_ctx,
-                                           char *cmd, char **args, int argc)
-{
-	flash_bank_t *bank;
-
-
-	if (argc < 2)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* Get the bank descriptor */
-	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-#define ISS_PASSWORD "I_know_what_I_am_doing"
-
-	lpc2900_info->risky = !strcmp( args[1], ISS_PASSWORD );
-
-	if( !lpc2900_info->risky )
-	{
-		command_print(cmd_ctx, "Wrong password (use '%s')", ISS_PASSWORD);
-		return ERROR_COMMAND_ARGUMENT_INVALID;
-	}
-
-	command_print(cmd_ctx,
-                  "Potentially dangerous operation allowed in next command!");
-
-	return ERROR_OK;
-}
-
-
-
-/**
- * Write customer info from file to the index sector.
- *
- * @param cmd_ctx
- * @param cmd
- * @param args
- * @param argc
- */
-static int lpc2900_handle_write_custom_command( struct command_context_s *cmd_ctx,
-                                                char *cmd, char **args, int argc )
-{
-	if (argc < 2)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* Get the bank descriptor */
-	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-	/* Check if command execution is allowed. */
-	if( !lpc2900_info->risky )
-	{
-		command_print( cmd_ctx, "Command execution not allowed!" );
-		return ERROR_COMMAND_ARGUMENT_INVALID;
-	}
-	lpc2900_info->risky = 0;
-
-	/* Get target, and check if it's halted */
-	target_t *target = bank->target;
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* The image will always start at offset 0 */
-	image_t image;
-	image.base_address_set = 1;
-	image.base_address = 0;
-	image.start_address_set = 0;
-
-	char *filename = args[1];
-	char *type = (argc >= 3) ? args[2] : NULL;
-	int retval = image_open(&image, filename, type);
-	if (retval != ERROR_OK)
-	{
-		return retval;
-	}
-
-	/* Do a sanity check: The image must be exactly the size of the customer
-	   programmable area. Any other size is rejected. */
-	if( image.num_sections != 1 )
-	{
-		LOG_ERROR("Only one section allowed in image file.");
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-	if( (image.sections[0].base_address != 0) ||
-        (image.sections[0].size != ISS_CUSTOMER_SIZE) )
-	{
-		LOG_ERROR("Incorrect image file size. Expected %" PRIu32 ", got %" PRIu32,
-                   ISS_CUSTOMER_SIZE, image.sections[0].size);
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* Well boys, I reckon this is it... */
-
-	/* Customer info is split into two blocks in pages 4 and 5. */
-	uint8_t page[FLASH_PAGE_SIZE];
-
-	/* Page 4 */
-	uint32_t offset = ISS_CUSTOMER_START1 % FLASH_PAGE_SIZE;
-	memset( page, 0xff, FLASH_PAGE_SIZE );
-	uint32_t size_read;
-	retval = image_read_section( &image, 0, 0,
-	                             ISS_CUSTOMER_SIZE1, &page[offset], &size_read);
-	if( retval != ERROR_OK )
-	{
-		LOG_ERROR("couldn't read from file '%s'", filename);
-		image_close(&image);
-		return retval;
-	}
-	if( (retval = lpc2900_write_index_page( bank, 4, &page )) != ERROR_OK )
-	{
-		image_close(&image);
-		return retval;
-	}
-
-	/* Page 5 */
-	offset = ISS_CUSTOMER_START2 % FLASH_PAGE_SIZE;
-	memset( page, 0xff, FLASH_PAGE_SIZE );
-	retval = image_read_section( &image, 0, ISS_CUSTOMER_SIZE1,
-	                             ISS_CUSTOMER_SIZE2, &page[offset], &size_read);
-	if( retval != ERROR_OK )
-	{
-		LOG_ERROR("couldn't read from file '%s'", filename);
-		image_close(&image);
-		return retval;
-	}
-	if( (retval = lpc2900_write_index_page( bank, 5, &page )) != ERROR_OK )
-	{
-		image_close(&image);
-		return retval;
-	}
-
-	image_close(&image);
-
-	return ERROR_OK;
-}
-
-
-
-/**
- * Activate 'sector security' for a range of sectors.
- *
- * @param cmd_ctx
- * @param cmd
- * @param args
- * @param argc
- */
-static int lpc2900_handle_secure_sector_command(struct command_context_s *cmd_ctx,
-                                                char *cmd, char **args, int argc)
-{
-	if (argc < 3)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* Get the bank descriptor */
-	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-	/* Check if command execution is allowed. */
-	if( !lpc2900_info->risky )
-	{
-		command_print( cmd_ctx, "Command execution not allowed! "
-		"(use 'password' command first)");
-		return ERROR_COMMAND_ARGUMENT_INVALID;
-	}
-	lpc2900_info->risky = 0;
-
-	/* Read sector range, and do a sanity check. */
-	int first = strtoul(args[1], NULL, 0);
-	int last = strtoul(args[2], NULL, 0);
-	if( (first >= bank->num_sectors) ||
-	    (last >= bank->num_sectors) ||
-	    (first > last) )
-	{
-		command_print( cmd_ctx, "Illegal sector range" );
-		return ERROR_COMMAND_ARGUMENT_INVALID;
-	}
-
-	uint8_t page[FLASH_PAGE_SIZE];
-	int sector;
-	int retval;
-
-	/* Sectors in page 6 */
-	if( (first <= 4) || (last >= 8) )
-	{
-		memset( &page, 0xff, FLASH_PAGE_SIZE );
-		for( sector = first; sector <= last; sector++ )
-		{
-			if( sector <= 4 )
-			{
-				memset( &page[0xB0 + 16*sector], 0, 16 );
-			}
-			else if( sector >= 8 )
-			{
-				memset( &page[0x00 + 16*(sector - 8)], 0, 16 );
-			}
-		}
-
-		if( (retval = lpc2900_write_index_page( bank, 6, &page )) != ERROR_OK )
-		{
-			LOG_ERROR("failed to update index sector page 6");
-			return retval;
-		}
-	}
-
-	/* Sectors in page 7 */
-	if( (first <= 7) && (last >= 5) )
-	{
-		memset( &page, 0xff, FLASH_PAGE_SIZE );
-		for( sector = first; sector <= last; sector++ )
-		{
-			if( (sector >= 5) && (sector <= 7) )
-			{
-				memset( &page[0x00 + 16*(sector - 5)], 0, 16 );
-			}
-		}
-
-		if( (retval = lpc2900_write_index_page( bank, 7, &page )) != ERROR_OK )
-		{
-			LOG_ERROR("failed to update index sector page 7");
-			return retval;
-		}
-	}
-
-	command_print( cmd_ctx,
-	        "Sectors security will become effective after next power cycle");
-
-	/* Update the sector security status */
-	if ( lpc2900_read_security_status(bank) != ERROR_OK )
-	{
-		LOG_ERROR( "Cannot determine sector security status" );
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-
-
-/**
- * Activate JTAG protection.
- *
- * @param cmd_ctx
- * @param cmd
- * @param args
- * @param argc
- */
-static int lpc2900_handle_secure_jtag_command(struct command_context_s *cmd_ctx,
-                                              char *cmd, char **args, int argc)
-{
-	if (argc < 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* Get the bank descriptor */
-	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
-	if (!bank)
-	{
-		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
-		return ERROR_OK;
-	}
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-	/* Check if command execution is allowed. */
-	if( !lpc2900_info->risky )
-	{
-		command_print( cmd_ctx, "Command execution not allowed! "
-		                        "(use 'password' command first)");
-		return ERROR_COMMAND_ARGUMENT_INVALID;
-	}
-	lpc2900_info->risky = 0;
-
-	/* Prepare page */
-	uint8_t page[FLASH_PAGE_SIZE];
-	memset( &page, 0xff, FLASH_PAGE_SIZE );
-
-
-	/* Insert "soft" protection word */
-	page[0x30 + 15] = 0x7F;
-	page[0x30 + 11] = 0x7F;
-	page[0x30 +  7] = 0x7F;
-	page[0x30 +  3] = 0x7F;
-
-	/* Write to page 5 */
-	int retval;
-	if( (retval = lpc2900_write_index_page( bank, 5, &page ))
-			!= ERROR_OK )
-	{
-		LOG_ERROR("failed to update index sector page 5");
-		return retval;
-	}
-
-	LOG_INFO("JTAG security set. Good bye!");
-
-	return ERROR_OK;
-}
-
-
-
-/***********************  Flash interface functions  **************************/
-
-
-/**
- * Register private command handlers.
- *
- * @param cmd_ctx
- */
-static int lpc2900_register_commands(struct command_context_s *cmd_ctx)
-{
-	command_t *lpc2900_cmd = register_command(cmd_ctx, NULL, "lpc2900",
-	                                          NULL, COMMAND_ANY, NULL);
-
-	register_command(
-	    cmd_ctx,
-	    lpc2900_cmd,
-	    "signature",
-	    lpc2900_handle_signature_command,
-	    COMMAND_EXEC,
-	    "<bank> | "
-            "print device signature of flash bank");
-
-	register_command(
-	    cmd_ctx,
-	    lpc2900_cmd,
-	    "read_custom",
-	    lpc2900_handle_read_custom_command,
-	    COMMAND_EXEC,
-	    "<bank> <filename> | "
-            "read customer information from index sector to file");
-
-	register_command(
-	    cmd_ctx,
-	    lpc2900_cmd,
-	    "password",
-	    lpc2900_handle_password_command,
-	    COMMAND_EXEC,
-	    "<bank> <password> | "
-            "enter password to enable 'dangerous' options");
-
-	register_command(
-	    cmd_ctx,
-	    lpc2900_cmd,
-	    "write_custom",
-	    lpc2900_handle_write_custom_command,
-	    COMMAND_EXEC,
-	    "<bank> <filename> [<type>] | "
-            "write customer info from file to index sector");
-
-	register_command(
-	    cmd_ctx,
-	    lpc2900_cmd,
-	    "secure_sector",
-	    lpc2900_handle_secure_sector_command,
-	    COMMAND_EXEC,
-	    "<bank> <first> <last> | "
-            "activate sector security for a range of sectors");
-
-	register_command(
-	    cmd_ctx,
-	    lpc2900_cmd,
-	    "secure_jtag",
-	    lpc2900_handle_secure_jtag_command,
-	    COMMAND_EXEC,
-	    "<bank> <level> | "
-            "activate JTAG security");
-
-	return ERROR_OK;
-}
-
-
-/**
- * Evaluate flash bank command.
- *
- * Syntax: flash bank lpc2900 0 0 0 0 target# system_base_clock
- *
- * @param cmd_ctx
- * @param cmd
- * @param args
- * @param argc
- * @param bank Pointer to the flash bank descriptor
- */
-static int lpc2900_flash_bank_command(struct command_context_s *cmd_ctx,
-                                      char *cmd, char **args, int argc,
-                                      struct flash_bank_s *bank)
-{
-	lpc2900_flash_bank_t *lpc2900_info;
-
-	if (argc < 6)
-	{
-		LOG_WARNING("incomplete flash_bank LPC2900 configuration");
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	lpc2900_info = malloc(sizeof(lpc2900_flash_bank_t));
-	bank->driver_priv = lpc2900_info;
-
-	/* Get flash clock.
-	 * Reject it if we can't meet the requirements for program time
-	 * (if clock too slow), or for erase time (clock too fast).
-	 */
-	lpc2900_info->clk_sys_fmc = strtoul(args[6], NULL, 0) * 1000;
-
-	uint32_t clock_limit;
-	/* Check program time limit */
-	clock_limit = 512000000l / FLASH_PROGRAM_TIME;
-	if (lpc2900_info->clk_sys_fmc < clock_limit)
-	{
-		LOG_WARNING("flash clock must be at least %" PRIu32 " kHz",
-                    (clock_limit / 1000));
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	/* Check erase time limit */
-	clock_limit = (uint32_t)((32767.0 * 512.0 * 1e6) / FLASH_ERASE_TIME);
-	if (lpc2900_info->clk_sys_fmc > clock_limit)
-	{
-		LOG_WARNING("flash clock must be a maximum of %" PRIu32" kHz",
-                    (clock_limit / 1000));
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	/* Chip ID will be obtained by probing the device later */
-	lpc2900_info->chipid = 0;
-
-	return ERROR_OK;
-}
-
-
-/**
- * Erase sector(s).
- *
- * @param bank Pointer to the flash bank descriptor
- * @param first First sector to be erased
- * @param last Last sector (including) to be erased
- */
-static int lpc2900_erase(struct flash_bank_s *bank, int first, int last)
-{
-	uint32_t status;
-	int sector;
-	int last_unsecured_sector;
-	target_t *target = bank->target;
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-
-
-	status = lpc2900_is_ready(bank);
-	if (status != ERROR_OK)
-	{
-		return status;
-	}
-
-	/* Sanity check on sector range */
-	if ((first < 0) || (last < first) || (last >= bank->num_sectors))
-	{
-		LOG_INFO("Bad sector range");
-		return ERROR_FLASH_SECTOR_INVALID;
-	}
-
-	/* Update the info about secured sectors */
-	lpc2900_read_security_status( bank );
-
-	/* The selected sector range might include secured sectors. An attempt
-	 * to erase such a sector will cause the erase to fail also for unsecured
-	 * sectors. It is necessary to determine the last unsecured sector now,
-	 * because we have to treat the last relevant sector in the list in
-	 * a special way.
-	 */
-	last_unsecured_sector = -1;
-	for (sector = first; sector <= last; sector++)
-	{
-		if ( !bank->sectors[sector].is_protected )
-		{
-			last_unsecured_sector = sector;
-		}
-	}
-
-	/* Exit now, in case of the rare constellation where all sectors in range
-	 * are secured. This is regarded a success, since erasing/programming of
-	 * secured sectors shall be handled transparently.
-	 */
-	if ( last_unsecured_sector == -1 )
-	{
-		return ERROR_OK;
-	}
-
-	/* Enable flash block and set the correct CRA clock of 66 kHz */
-	lpc2900_setup(bank);
-
-	/* Clear END_OF_ERASE interrupt status */
-	target_write_u32(target, INT_CLR_STATUS, INTSRC_END_OF_ERASE);
-
-	/* Set the program/erase timer to FLASH_ERASE_TIME */
-	target_write_u32(target, FPTR,
-	                 FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
-	                                              FLASH_ERASE_TIME ));
-
-	/* Sectors are marked for erasure, then erased all together */
-	for (sector = first; sector <= last_unsecured_sector; sector++)
-	{
-		/* Only mark sectors that aren't secured. Any attempt to erase a group
-		 * of sectors will fail if any single one of them is secured!
-		 */
-		if ( !bank->sectors[sector].is_protected )
-		{
-			/* Unprotect the sector */
-			target_write_u32(target, bank->sectors[sector].offset, 0);
-			target_write_u32(target, FCTR,
-			                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
-			                 FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS);
-
-			/* Mark the sector for erasure. The last sector in the list
-			   triggers the erasure. */
-			target_write_u32(target, bank->sectors[sector].offset, 0);
-			if ( sector == last_unsecured_sector )
-			{
-				target_write_u32(target, FCTR,
-				                 FCTR_FS_PROGREQ | FCTR_FS_WPB | FCTR_FS_CS);
-			}
-			else
-			{
-				target_write_u32(target, FCTR,
-				                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
-				                 FCTR_FS_WEB | FCTR_FS_CS);
-			}
-		}
-	}
-
-	/* Wait for the end of the erase operation. If it's not over after two seconds,
-	 * something went dreadfully wrong... :-(
-	 */
-	if( lpc2900_wait_status(bank, INTSRC_END_OF_ERASE, 2000) != ERROR_OK )
-	{
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	/* Normal flash operating mode */
-	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
-
-	return ERROR_OK;
-}
-
-
-
-static int lpc2900_protect(struct flash_bank_s *bank, int set, int first, int last)
-{
-	/* This command is not supported.
-     * "Protection" in LPC2900 terms is handled transparently. Sectors will
-     * automatically be unprotected as needed.
-     * Instead we use the concept of sector security. A secured sector is shown
-     * as "protected" in OpenOCD. Sector security is a permanent feature, and
-     * cannot be disabled once activated.
-     */
-
-	return ERROR_OK;
-}
-
-
-/**
- * Write data to flash.
- *
- * @param bank Pointer to the flash bank descriptor
- * @param buffer Buffer with data
- * @param offset Start address (relative to bank start)
- * @param count Number of bytes to be programmed
- */
-static int lpc2900_write(struct flash_bank_s *bank, uint8_t *buffer,
-                         uint32_t offset, uint32_t count)
-{
-	uint8_t page[FLASH_PAGE_SIZE];
-	uint32_t status;
-	uint32_t num_bytes;
-	target_t *target = bank->target;
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-	int sector;
-	int retval;
-
-	static const uint32_t write_target_code[] = {
-		/* Set auto latch mode: FCTR=CS|WRE|WEB */
-		0xe3a0a007,   /* loop       mov r10, #0x007 */
-		0xe583a000,   /*            str r10,[r3,#0] */
-
-		/* Load complete page into latches */
-		0xe3a06020,   /*            mov r6,#(512/16) */
-		0xe8b00f00,   /* next       ldmia r0!,{r8-r11} */
-		0xe8a10f00,   /*            stmia r1!,{r8-r11} */
-		0xe2566001,   /*            subs r6,#1 */
-		0x1afffffb,   /*            bne next */
-
-		/* Clear END_OF_BURN interrupt status */
-		0xe3a0a002,   /*            mov r10,#(1 << 1) */
-		0xe583afe8,   /*            str r10,[r3,#0xfe8] */
-
-		/* Set the erase time to FLASH_PROGRAM_TIME */
-		0xe5834008,   /*            str r4,[r3,#8] */
-
-		/* Trigger flash write
-			FCTR = CS | WRE | WPB | PROGREQ */
-		0xe3a0a083,   /*            mov r10,#0x83 */
-		0xe38aaa01,   /*            orr r10,#0x1000 */
-		0xe583a000,   /*            str r10,[r3,#0] */
-
-		/* Wait for end of burn */
-		0xe593afe0,   /* wait       ldr r10,[r3,#0xfe0] */
-		0xe21aa002,   /*            ands r10,#(1 << 1) */
-		0x0afffffc,   /*            beq wait */
-
-		/* End? */
-		0xe2522001,   /*            subs r2,#1 */
-		0x1affffed,   /*            bne loop */
-
-		0xeafffffe    /* done       b done */
-	};
-
-
-	status = lpc2900_is_ready(bank);
-	if (status != ERROR_OK)
-	{
-		return status;
-	}
-
-	/* Enable flash block and set the correct CRA clock of 66 kHz */
-	lpc2900_setup(bank);
-
-	/* Update the info about secured sectors */
-	lpc2900_read_security_status( bank );
-
-	/* Unprotect all involved sectors */
-	for (sector = 0; sector < bank->num_sectors; sector++)
-	{
-		/* Start address in or before this sector? */
-		/* End address in or behind this sector? */
-		if ( ((bank->base + offset) <
-		          (bank->sectors[sector].offset + bank->sectors[sector].size)) &&
-		     ((bank->base + (offset + count - 1)) >= bank->sectors[sector].offset) )
-		{
-			/* This sector is involved and needs to be unprotected.
-				* Don't do it for secured sectors.
-				*/
-			if ( !bank->sectors[sector].is_protected )
-			{
-				target_write_u32(target, bank->sectors[sector].offset, 0);
-				target_write_u32(target, FCTR,
-				                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
-				                 FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS);
-			}
-		}
-	}
-
-	/* Set the program/erase time to FLASH_PROGRAM_TIME */
-	uint32_t prog_time = FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
-	                                                  FLASH_PROGRAM_TIME );
-
-	/* If there is a working area of reasonable size, use it to program via
-	   a target algorithm. If not, fall back to host programming. */
-
-	/* We need some room for target code. */
-	uint32_t target_code_size = sizeof(write_target_code);
-
-	/* Try working area allocation. Start with a large buffer, and try with
-	   reduced size if that fails. */
-	working_area_t *warea;
-	uint32_t buffer_size = lpc2900_info->max_ram_block - 1 * KiB;
-	while( (retval = target_alloc_working_area(target,
-	                                           buffer_size + target_code_size,
-	                                           &warea)) != ERROR_OK )
-	{
-		/* Try a smaller buffer now, and stop if it's too small. */
-		buffer_size -= 1 * KiB;
-		if (buffer_size < 2 * KiB)
-		{
-			LOG_INFO( "no (large enough) working area"
-			          ", falling back to host mode" );
-			warea = NULL;
-			break;
-		}
-	};
-
-	if( warea )
-	{
-		reg_param_t reg_params[5];
-		armv4_5_algorithm_t armv4_5_info;
-
-		/* We can use target mode. Download the algorithm. */
-		retval = target_write_buffer( target,
-		                              (warea->address)+buffer_size,
-		                              target_code_size,
-		                              (uint8_t *)write_target_code);
-		if (retval != ERROR_OK)
-		{
-			LOG_ERROR("Unable to write block write code to target");
-			target_free_all_working_areas(target);
-			return ERROR_FLASH_OPERATION_FAILED;
-		}
-
-		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
-		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
-		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
-		init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);
-		init_reg_param(&reg_params[4], "r4", 32, PARAM_OUT);
-
-		/* Write to flash in large blocks */
-		while ( count != 0 )
-		{
-			uint32_t this_npages;
-			uint8_t *this_buffer;
-			int start_sector = lpc2900_address2sector( bank, offset );
-
-			/* First page / last page / rest */
-			if( offset % FLASH_PAGE_SIZE )
-			{
-				/* Block doesn't start on page boundary.
-				   Burn first partial page separately. */
-				memset( &page, 0xff, sizeof(page) );
-				memcpy( &page[offset % FLASH_PAGE_SIZE],
-				        buffer,
-				        FLASH_PAGE_SIZE - (offset % FLASH_PAGE_SIZE) );
-				this_npages = 1;
-				this_buffer = &page[0];
-				count = count + (offset % FLASH_PAGE_SIZE);
-				offset = offset - (offset % FLASH_PAGE_SIZE);
-			}
-			else if( count < FLASH_PAGE_SIZE )
-			{
-				/* Download last incomplete page separately. */
-				memset( &page, 0xff, sizeof(page) );
-				memcpy( &page, buffer, count );
-				this_npages = 1;
-				this_buffer = &page[0];
-				count = FLASH_PAGE_SIZE;
-			}
-			else
-			{
-				/* Download as many full pages as possible */
-				this_npages = (count < buffer_size) ?
-				               count / FLASH_PAGE_SIZE :
-				               buffer_size / FLASH_PAGE_SIZE;
-				this_buffer = buffer;
-
-				/* Make sure we stop at the next secured sector */
-				int sector = start_sector + 1;
-				while( sector < bank->num_sectors )
-				{
-					/* Secured? */
-					if( bank->sectors[sector].is_protected )
-					{
-						/* Is that next sector within the current block? */
-						if( (bank->sectors[sector].offset - bank->base) <
-							(offset + (this_npages * FLASH_PAGE_SIZE)) )
-						{
-							/* Yes! Split the block */
-							this_npages =
-							  (bank->sectors[sector].offset - bank->base - offset)
-							      / FLASH_PAGE_SIZE;
-							break;
-						}
-					}
-
-					sector++;
-				}
-			}
-
-			/* Skip the current sector if it is secured */
-			if( bank->sectors[start_sector].is_protected )
-			{
-				LOG_DEBUG( "Skip secured sector %" PRIu32, start_sector );
-
-				/* Stop if this is the last sector */
-				if( start_sector == bank->num_sectors - 1 )
-				{
-					break;
-				}
-
-				/* Skip */
-				uint32_t nskip = bank->sectors[start_sector].size -
-				                 (offset % bank->sectors[start_sector].size);
-				offset += nskip;
-				buffer += nskip;
-				count = (count >= nskip) ? (count - nskip) : 0;
-				continue;
-			}
-
-			/* Execute buffer download */
-			if ((retval = target_write_buffer(target,
-			                                  warea->address,
-			                                  this_npages * FLASH_PAGE_SIZE,
-			                                  this_buffer)) != ERROR_OK)
-			{
-				LOG_ERROR("Unable to write data to target");
-				target_free_all_working_areas(target);
-				return ERROR_FLASH_OPERATION_FAILED;
-			}
-
-			/* Prepare registers */
-			buf_set_u32(reg_params[0].value, 0, 32, warea->address);
-			buf_set_u32(reg_params[1].value, 0, 32, offset);
-			buf_set_u32(reg_params[2].value, 0, 32, this_npages);
-			buf_set_u32(reg_params[3].value, 0, 32, FCTR);
-			buf_set_u32(reg_params[4].value, 0, 32, FPTR_EN_T | prog_time);
-
-			/* Execute algorithm, assume breakpoint for last instruction */
-			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
-			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
-			armv4_5_info.core_state = ARMV4_5_STATE_ARM;
-
-			retval = target_run_algorithm(target, 0, NULL, 5, reg_params,
-				(warea->address) + buffer_size,
-				(warea->address) + buffer_size + target_code_size - 4,
-				10000, /* 10s should be enough for max. 16 KiB of data */
-				&armv4_5_info);
-
-			if (retval != ERROR_OK)
-			{
-				LOG_ERROR("Execution of flash algorithm failed.");
-				target_free_all_working_areas(target);
-				retval = ERROR_FLASH_OPERATION_FAILED;
-				break;
-			}
-
-			count -= this_npages * FLASH_PAGE_SIZE;
-			buffer += this_npages * FLASH_PAGE_SIZE;
-			offset += this_npages * FLASH_PAGE_SIZE;
-		}
-
-		/* Free all resources */
-		destroy_reg_param(&reg_params[0]);
-		destroy_reg_param(&reg_params[1]);
-		destroy_reg_param(&reg_params[2]);
-		destroy_reg_param(&reg_params[3]);
-		destroy_reg_param(&reg_params[4]);
-		target_free_all_working_areas(target);
-	}
-	else
-	{
-		/* Write to flash memory page-wise */
-		while ( count != 0 )
-		{
-			/* How many bytes do we copy this time? */
-			num_bytes = (count >= FLASH_PAGE_SIZE) ?
-			            FLASH_PAGE_SIZE - (offset % FLASH_PAGE_SIZE) :
-			            count;
-
-			/* Don't do anything with it if the page is in a secured sector. */
-			if ( !bank->sectors[lpc2900_address2sector(bank, offset)].is_protected )
-			{
-				/* Set latch load mode */
-				target_write_u32(target, FCTR,
-				                 FCTR_FS_CS | FCTR_FS_WRE | FCTR_FS_WEB);
-
-				/* Always clear the buffer (a little overhead, but who cares) */
-				memset(page, 0xFF, FLASH_PAGE_SIZE);
-
-				/* Copy them to the buffer */
-				memcpy( &page[offset % FLASH_PAGE_SIZE],
-				        &buffer[offset % FLASH_PAGE_SIZE],
-				        num_bytes );
-
-				/* Write whole page to flash data latches */
-				if (target_write_memory(
-				                 target,
-				                 bank->base + (offset - (offset % FLASH_PAGE_SIZE)),
-				                 4, FLASH_PAGE_SIZE / 4, page) != ERROR_OK)
-				{
-					LOG_ERROR("Write failed @ 0x%8.8" PRIx32, offset);
-					target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
-
-					return ERROR_FLASH_OPERATION_FAILED;
-				}
-
-				/* Clear END_OF_BURN interrupt status */
-				target_write_u32(target, INT_CLR_STATUS, INTSRC_END_OF_BURN);
-
-				/* Set the programming time */
-				target_write_u32(target, FPTR, FPTR_EN_T | prog_time);
-
-				/* Trigger flash write */
-				target_write_u32(target, FCTR,
-				    FCTR_FS_CS | FCTR_FS_WRE | FCTR_FS_WPB | FCTR_FS_PROGREQ);
-
-				/* Wait for the end of the write operation. If it's not over
-				 * after one second, something went dreadfully wrong... :-(
-				 */
-				if (lpc2900_wait_status(bank, INTSRC_END_OF_BURN, 1000) != ERROR_OK)
-				{
-					LOG_ERROR("Write failed @ 0x%8.8" PRIx32, offset);
-					target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
-
-					return ERROR_FLASH_OPERATION_FAILED;
-				}
-			}
-
-			/* Update pointers and counters */
-			offset += num_bytes;
-			buffer += num_bytes;
-			count -= num_bytes;
-		}
-
-		retval = ERROR_OK;
-	}
-
-	/* Normal flash operating mode */
-	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
-
-	return retval;
-}
-
-
-/**
- * Try and identify the device.
- *
- * Determine type number and its memory layout.
- *
- * @param bank Pointer to the flash bank descriptor
- */
-static int lpc2900_probe(struct flash_bank_s *bank)
-{
-	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
-	target_t *target = bank->target;
-	int i = 0;
-	uint32_t offset;
-
-
-	if (target->state != TARGET_HALTED)
-	{
-		LOG_ERROR("Target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/* We want to do this only once. Check if we already have a valid CHIPID,
-	 * because then we will have already successfully probed the device.
-	 */
-	if (lpc2900_info->chipid == EXPECTED_CHIPID)
-	{
-		return ERROR_OK;
-	}
-
-	/* Probing starts with reading the CHIPID register. We will continue only
-	 * if this identifies as an LPC2900 device.
-	 */
-	target_read_u32(target, CHIPID, &lpc2900_info->chipid);
-
-	if (lpc2900_info->chipid != EXPECTED_CHIPID)
-	{
-		LOG_WARNING("Device is not an LPC29xx");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	/* It's an LPC29xx device. Now read the feature register FEAT0...FEAT3. */
-	uint32_t feat0, feat1, feat2, feat3;
-	target_read_u32(target, FEAT0, &feat0);
-	target_read_u32(target, FEAT1, &feat1);
-	target_read_u32(target, FEAT2, &feat2);
-	target_read_u32(target, FEAT3, &feat3);
-
-	/* Base address */
-	bank->base = 0x20000000;
-
-	/* Determine flash layout from FEAT2 register */
-	uint32_t num_64k_sectors = (feat2 >> 16) & 0xFF;
-	uint32_t num_8k_sectors = (feat2 >> 0) & 0xFF;
-	bank->num_sectors = num_64k_sectors + num_8k_sectors;
-	bank->size = KiB * (64 * num_64k_sectors + 8 * num_8k_sectors);
-
-	/* Determine maximum contiguous RAM block */
-	lpc2900_info->max_ram_block = 16 * KiB;
-	if( (feat1 & 0x30) == 0x30 )
-	{
-		lpc2900_info->max_ram_block = 32 * KiB;
-		if( (feat1 & 0x0C) == 0x0C )
-		{
-			lpc2900_info->max_ram_block = 48 * KiB;
-		}
-	}
-
-	/* Determine package code and ITCM size */
-	uint32_t package_code = feat0 & 0x0F;
-	uint32_t itcm_code = (feat1 >> 16) & 0x1F;
-
-	/* Determine the exact type number. */
-	uint32_t found = 1;
-	if ( (package_code == 4) && (itcm_code == 5) )
-	{
-		/* Old LPC2917 or LPC2919 (non-/01 devices) */
-		lpc2900_info->target_name = (bank->size == 768*KiB) ? "LPC2919" : "LPC2917";
-	}
-	else
-	{
-		if ( package_code == 2 )
-		{
-			/* 100-pin package */
-			if ( bank->size == 128*KiB )
-			{
-				lpc2900_info->target_name = "LPC2921";
-			}
-			else if ( bank->size == 256*KiB )
-			{
-				lpc2900_info->target_name = "LPC2923";
-			}
-			else if ( bank->size == 512*KiB )
-			{
-				lpc2900_info->target_name = "LPC2925";
-			}
-			else
-			{
-				found = 0;
-			}
-		}
-		else if ( package_code == 4 )
-		{
-			/* 144-pin package */
-			if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFCF0) )
-			{
-				lpc2900_info->target_name = "LPC2917/01";
-			}
-			else if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFFF1) )
-			{
-				lpc2900_info->target_name = "LPC2927";
-			}
-			else if ( (bank->size == 768*KiB) && (feat3 == 0xFFFFFCF8) )
-			{
-				lpc2900_info->target_name = "LPC2919/01";
-			}
-			else if ( (bank->size == 768*KiB) && (feat3 == 0xFFFFFFF9) )
-			{
-				lpc2900_info->target_name = "LPC2929";
-			}
-			else
-			{
-				found = 0;
-			}
-		}
-		else if ( package_code == 5 )
-		{
-			/* 208-pin package */
-			lpc2900_info->target_name = (bank->size == 0) ? "LPC2930" : "LPC2939";
-		}
-		else
-		{
-			found = 0;
-		}
-	}
-
-	if ( !found )
-	{
-		LOG_WARNING("Unknown LPC29xx derivative");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	/* Show detected device */
-	LOG_INFO("Flash bank %" PRIu32
-	         ": Device %s, %" PRIu32
-	         " KiB in %" PRIu32 " sectors",
-	         bank->bank_number,
-	         lpc2900_info->target_name, bank->size / KiB,
-	         bank->num_sectors);
-
-	/* Flashless devices cannot be handled */
-	if ( bank->num_sectors == 0 )
-	{
-		LOG_WARNING("Flashless device cannot be handled");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	/* Sector layout.
-	 * These are logical sector numbers. When doing real flash operations,
-	 * the logical flash number are translated into the physical flash numbers
-	 * of the device.
-	 */
-	bank->sectors = malloc(sizeof(flash_sector_t) * bank->num_sectors);
-
-	offset = 0;
-	for (i = 0; i < bank->num_sectors; i++)
-	{
-		bank->sectors[i].offset = offset;
-		bank->sectors[i].is_erased = -1;
-		bank->sectors[i].is_protected = -1;
-
-		if ( i <= 7 )
-		{
-			bank->sectors[i].size = 8 * KiB;
-		}
-		else if ( i <= 18 )
-		{
-			bank->sectors[i].size = 64 * KiB;
-		}
-		else
-		{
-			/* We shouldn't come here. But there might be a new part out there
-			 * that has more than 19 sectors. Politely ask for a fix then.
-			 */
-			bank->sectors[i].size = 0;
-			LOG_ERROR("Never heard about sector %" PRIu32 " (FIXME please)", i);
-		}
-
-		offset += bank->sectors[i].size;
-	}
-
-	/* Read sector security status */
-	if ( lpc2900_read_security_status(bank) != ERROR_OK )
-	{
-		LOG_ERROR("Cannot determine sector security status");
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-
-/**
- * Run a blank check for each sector.
- *
- * For speed reasons, the device isn't read word by word.
- * A hash value is calculated by the hardware ("BIST") for each sector.
- * This value is then compared against the known hash of an empty sector.
- *
- * @param bank Pointer to the flash bank descriptor
- */
-static int lpc2900_erase_check(struct flash_bank_s *bank)
-{
-	uint32_t status = lpc2900_is_ready(bank);
-	if (status != ERROR_OK)
-	{
-		LOG_INFO("Processor not halted/not probed");
-		return status;
-	}
-
-	/* Use the BIST (Built-In Selft Test) to generate a signature of each flash
-	 * sector. Compare against the expected signature of an empty sector.
-	 */
-	int sector;
-	for ( sector = 0; sector < bank->num_sectors; sector++ )
-	{
-		uint32_t signature[4];
-		if ( (status = lpc2900_run_bist128( bank,
-		                                    bank->sectors[sector].offset,
-		                                    bank->sectors[sector].offset +
-		                                       (bank->sectors[sector].size - 1),
-		                                    &signature)) != ERROR_OK )
-		{
-			return status;
-		}
-
-		/* The expected signatures for an empty sector are different
-		 * for 8 KiB and 64 KiB sectors.
-		 */
-		if ( bank->sectors[sector].size == 8*KiB )
-		{
-			bank->sectors[sector].is_erased =
-			    (signature[3] == 0x01ABAAAA) &&
-			    (signature[2] == 0xAAAAAAAA) &&
-			    (signature[1] == 0xAAAAAAAA) &&
-			    (signature[0] == 0xAAA00AAA);
-		}
-		if ( bank->sectors[sector].size == 64*KiB )
-		{
-			bank->sectors[sector].is_erased =
-			    (signature[3] == 0x11801222) &&
-			    (signature[2] == 0xB88844FF) &&
-			    (signature[1] == 0x11A22008) &&
-			    (signature[0] == 0x2B1BFE44);
-		}
-	}
-
-	return ERROR_OK;
-}
-
-
-/**
- * Get protection (sector security) status.
- *
- * Determine the status of "sector security" for each sector.
- * A secured sector is one that can never be erased/programmed again.
- *
- * @param bank Pointer to the flash bank descriptor
- */
-static int lpc2900_protect_check(struct flash_bank_s *bank)
-{
-	return lpc2900_read_security_status(bank);
-}
-
-
-/**
- * Print info about the driver (not the device).
- *
- * @param bank Pointer to the flash bank descriptor
- * @param buf Buffer to take the string
- * @param buf_size Maximum number of characters that the buffer can take
- */
-static int lpc2900_info(struct flash_bank_s *bank, char *buf, int buf_size)
-{
-	snprintf(buf, buf_size, "lpc2900 flash driver");
-
-	return ERROR_OK;
-}
-
-
-flash_driver_t lpc2900_flash =
-{
-	.name               = "lpc2900",
-	.register_commands  = lpc2900_register_commands,
-	.flash_bank_command = lpc2900_flash_bank_command,
-	.erase              = lpc2900_erase,
-	.protect            = lpc2900_protect,
-	.write              = lpc2900_write,
-	.probe              = lpc2900_probe,
-	.auto_probe         = lpc2900_probe,
-	.erase_check        = lpc2900_erase_check,
-	.protect_check      = lpc2900_protect_check,
-	.info               = lpc2900_info
-};
+/***************************************************************************
+ *   Copyright (C) 2009 by                                                 *
+ *   Rolf Meeser <rolfm_9dq at yahoo.de>                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+
+#include "image.h"
+
+#include "lpc2900.h"
+#include "binarybuffer.h"
+#include "armv4_5.h"
+
+
+/* 1024 bytes */
+#define KiB                 1024
+
+/* Some flash constants */
+#define FLASH_PAGE_SIZE     512     /* bytes */
+#define FLASH_ERASE_TIME    100000  /* microseconds */
+#define FLASH_PROGRAM_TIME  1000    /* microseconds */
+
+/* Chip ID / Feature Registers */
+#define CHIPID          0xE0000000  /* Chip ID */
+#define FEAT0           0xE0000100  /* Chip feature 0 */
+#define FEAT1           0xE0000104  /* Chip feature 1 */
+#define FEAT2           0xE0000108  /* Chip feature 2 (contains flash size indicator) */
+#define FEAT3           0xE000010C  /* Chip feature 3 */
+
+#define EXPECTED_CHIPID 0x209CE02B  /* Chip ID of all LPC2900 devices */
+
+/* Flash/EEPROM Control Registers */
+#define FCTR            0x20200000  /* Flash control */
+#define FPTR            0x20200008  /* Flash program-time */
+#define FTCTR           0x2020000C  /* Flash test control */
+#define FBWST           0x20200010  /* Flash bridge wait-state */
+#define FCRA            0x2020001C  /* Flash clock divider */
+#define FMSSTART        0x20200020  /* Flash Built-In Selft Test start address */
+#define FMSSTOP         0x20200024  /* Flash Built-In Selft Test stop address */
+#define FMS16           0x20200028  /* Flash 16-bit signature */
+#define FMSW0           0x2020002C  /* Flash 128-bit signature Word 0 */
+#define FMSW1           0x20200030  /* Flash 128-bit signature Word 1 */
+#define FMSW2           0x20200034  /* Flash 128-bit signature Word 2 */
+#define FMSW3           0x20200038  /* Flash 128-bit signature Word 3 */
+
+#define EECMD           0x20200080  /* EEPROM command */
+#define EEADDR          0x20200084  /* EEPROM address */
+#define EEWDATA         0x20200088  /* EEPROM write data */
+#define EERDATA         0x2020008C  /* EEPROM read data */
+#define EEWSTATE        0x20200090  /* EEPROM wait state */
+#define EECLKDIV        0x20200094  /* EEPROM clock divider */
+#define EEPWRDWN        0x20200098  /* EEPROM power-down/start */
+#define EEMSSTART       0x2020009C  /* EEPROM BIST start address */
+#define EEMSSTOP        0x202000A0  /* EEPROM BIST stop address */
+#define EEMSSIG         0x202000A4  /* EEPROM 24-bit BIST signature */
+
+#define INT_CLR_ENABLE  0x20200FD8  /* Flash/EEPROM interrupt clear enable */
+#define INT_SET_ENABLE  0x20200FDC  /* Flash/EEPROM interrupt set enable */
+#define INT_STATUS      0x20200FE0  /* Flash/EEPROM interrupt status */
+#define INT_ENABLE      0x20200FE4  /* Flash/EEPROM interrupt enable */
+#define INT_CLR_STATUS  0x20200FE8  /* Flash/EEPROM interrupt clear status */
+#define INT_SET_STATUS  0x20200FEC  /* Flash/EEPROM interrupt set status */
+
+/* Interrupt sources */
+#define INTSRC_END_OF_PROG    (1 << 28)
+#define INTSRC_END_OF_BIST    (1 << 27)
+#define INTSRC_END_OF_RDWR    (1 << 26)
+#define INTSRC_END_OF_MISR    (1 << 2)
+#define INTSRC_END_OF_BURN    (1 << 1)
+#define INTSRC_END_OF_ERASE   (1 << 0)
+
+
+/* FCTR bits */
+#define FCTR_FS_LOADREQ       (1 << 15)
+#define FCTR_FS_CACHECLR      (1 << 14)
+#define FCTR_FS_CACHEBYP      (1 << 13)
+#define FCTR_FS_PROGREQ       (1 << 12)
+#define FCTR_FS_RLS           (1 << 11)
+#define FCTR_FS_PDL           (1 << 10)
+#define FCTR_FS_PD            (1 << 9)
+#define FCTR_FS_WPB           (1 << 7)
+#define FCTR_FS_ISS           (1 << 6)
+#define FCTR_FS_RLD           (1 << 5)
+#define FCTR_FS_DCR           (1 << 4)
+#define FCTR_FS_WEB           (1 << 2)
+#define FCTR_FS_WRE           (1 << 1)
+#define FCTR_FS_CS            (1 << 0)
+/* FPTR bits */
+#define FPTR_EN_T             (1 << 15)
+/* FTCTR bits */
+#define FTCTR_FS_BYPASS_R     (1 << 29)
+#define FTCTR_FS_BYPASS_W     (1 << 28)
+/* FMSSTOP bits */
+#define FMSSTOP_MISR_START    (1 << 17)
+/* EEMSSTOP bits */
+#define EEMSSTOP_STRTBIST     (1 << 31)
+
+/* Index sector */
+#define ISS_CUSTOMER_START1   (0x830)
+#define ISS_CUSTOMER_END1     (0xA00)
+#define ISS_CUSTOMER_SIZE1    (ISS_CUSTOMER_END1 - ISS_CUSTOMER_START1)
+#define ISS_CUSTOMER_NWORDS1  (ISS_CUSTOMER_SIZE1 / 4)
+#define ISS_CUSTOMER_START2   (0xA40)
+#define ISS_CUSTOMER_END2     (0xC00)
+#define ISS_CUSTOMER_SIZE2    (ISS_CUSTOMER_END2 - ISS_CUSTOMER_START2)
+#define ISS_CUSTOMER_NWORDS2  (ISS_CUSTOMER_SIZE2 / 4)
+#define ISS_CUSTOMER_SIZE     (ISS_CUSTOMER_SIZE1 + ISS_CUSTOMER_SIZE2)
+
+
+
+/**
+ * Private data for \c lpc2900 flash driver.
+ */
+typedef struct lpc2900_flash_bank_s
+{
+	/**
+	 * Holds the value read from CHIPID register.
+	 * The driver will not load if the chipid doesn't match the expected
+	 * value of 0x209CE02B of the LPC2900 family. A probe will only be done
+	 * if the chipid does not yet contain the expected value.
+	 */
+	uint32_t chipid;
+
+	/**
+	 * String holding device name.
+	 * This string is set by the probe function to the type number of the
+	 * device. It takes the form "LPC29xx".
+	 */
+	char * target_name;
+
+	/**
+	 * System clock frequency.
+	 * Holds the clock frequency in Hz, as passed by the configuration file
+	 * to the <tt>flash bank</tt> command.
+	 */
+	uint32_t clk_sys_fmc;
+
+	/**
+	 * Flag to indicate that dangerous operations are possible.
+	 * This flag can be set by passing the correct password to the
+	 * <tt>lpc2900 password</tt> command. If set, other dangerous commands,
+	 * which operate on the index sector, can be executed.
+	 */
+	uint32_t risky;
+
+	/**
+	 * Maximum contiguous block of internal SRAM (bytes).
+	 * Autodetected by the driver. Not the total amount of SRAM, only the
+	 * the largest \em contiguous block!
+	 */
+	uint32_t max_ram_block;
+
+} lpc2900_flash_bank_t;
+
+
+
+
+static int lpc2900_register_commands(struct command_context_s *cmd_ctx);
+static int lpc2900_flash_bank_command(struct command_context_s *cmd_ctx,
+                                      char *cmd, char **args, int argc,
+                                      struct flash_bank_s *bank);
+static int lpc2900_erase(struct flash_bank_s *bank, int first, int last);
+static int lpc2900_protect(struct flash_bank_s *bank, int set, int first, int last);
+static int lpc2900_write(struct flash_bank_s *bank,
+                         uint8_t *buffer, uint32_t offset, uint32_t count);
+static int lpc2900_probe(struct flash_bank_s *bank);
+static int lpc2900_erase_check(struct flash_bank_s *bank);
+static int lpc2900_protect_check(struct flash_bank_s *bank);
+static int lpc2900_info(struct flash_bank_s *bank, char *buf, int buf_size);
+
+static uint32_t lpc2900_wait_status(flash_bank_t *bank, uint32_t mask, int timeout);
+static void lpc2900_setup(struct flash_bank_s *bank);
+static uint32_t lpc2900_is_ready(struct flash_bank_s *bank);
+static uint32_t lpc2900_read_security_status(struct flash_bank_s *bank);
+static uint32_t lpc2900_run_bist128(struct flash_bank_s *bank,
+                                    uint32_t addr_from, uint32_t addr_to,
+                                    uint32_t (*signature)[4] );
+static uint32_t lpc2900_address2sector(struct flash_bank_s *bank, uint32_t offset);
+static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time );
+
+
+/***********************  Helper functions  **************************/
+
+
+/**
+ * Wait for an event in mask to occur in INT_STATUS.
+ *
+ * Return when an event occurs, or after a timeout.
+ *
+ * @param[in] bank Pointer to the flash bank descriptor
+ * @param[in] mask Mask to be used for INT_STATUS
+ * @param[in] timeout Timeout in ms
+ */
+static uint32_t lpc2900_wait_status( flash_bank_t *bank,
+                                     uint32_t mask,
+                                     int timeout )
+{
+	uint32_t int_status;
+	target_t *target = bank->target;
+
+
+	do
+	{
+		alive_sleep(1);
+		timeout--;
+		target_read_u32(target, INT_STATUS, &int_status);
+	}
+	while( ((int_status & mask) == 0) && (timeout != 0) );
+
+	if (timeout == 0)
+	{
+		LOG_DEBUG("Timeout!");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Set up the flash for erase/program operations.
+ *
+ * Enable the flash, and set the correct CRA clock of 66 kHz.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static void lpc2900_setup( struct flash_bank_s *bank )
+{
+	uint32_t fcra;
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+
+	/* Power up the flash block */
+	target_write_u32( bank->target, FCTR, FCTR_FS_WEB | FCTR_FS_CS );
+
+
+	fcra = (lpc2900_info->clk_sys_fmc / (3 * 66000)) - 1;
+	target_write_u32( bank->target, FCRA, fcra );
+}
+
+
+
+/**
+ * Check if device is ready.
+ *
+ * Check if device is ready for flash operation:
+ * Must have been successfully probed.
+ * Must be halted.
+ */
+static uint32_t lpc2900_is_ready( struct flash_bank_s *bank )
+{
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	if( lpc2900_info->chipid != EXPECTED_CHIPID )
+	{
+		return ERROR_FLASH_BANK_NOT_PROBED;
+	}
+
+	if( bank->target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Read the status of sector security from the index sector.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static uint32_t lpc2900_read_security_status( struct flash_bank_s *bank )
+{
+	uint32_t status;
+	if( (status = lpc2900_is_ready( bank )) != ERROR_OK )
+	{
+		return status;
+	}
+
+	target_t *target = bank->target;
+
+	/* Enable ISS access */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB | FCTR_FS_ISS);
+
+	/* Read the relevant block of memory from the ISS sector */
+	uint32_t iss_secured_field[ 0x230/16 ][ 4 ];
+	target_read_memory(target, bank->base + 0xC00, 4, 0x230/4,
+	                           (uint8_t *)iss_secured_field);
+
+	/* Disable ISS access */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+	/* Check status of each sector. Note that the sector numbering in the LPC2900
+	 * is different from the logical sector numbers used in OpenOCD!
+	 * Refer to the user manual for details.
+	 *
+	 * All zeros (16x 0x00) are treated as a secured sector (is_protected = 1)
+	 * All ones (16x 0xFF) are treated as a non-secured sector (is_protected = 0)
+	 * Anything else is undefined (is_protected = -1). This is treated as
+	 * a protected sector!
+	 */
+	int sector;
+	int index;
+	for( sector = 0; sector < bank->num_sectors; sector++ )
+	{
+		/* Convert logical sector number to physical sector number */
+		if( sector <= 4 )
+		{
+			index = sector + 11;
+		}
+		else if( sector <= 7 )
+		{
+			index = sector + 27;
+		}
+		else
+		{
+			index = sector - 8;
+		}
+
+		bank->sectors[sector].is_protected = -1;
+
+		if (
+		    (iss_secured_field[index][0] == 0x00000000) &&
+		    (iss_secured_field[index][1] == 0x00000000) &&
+		    (iss_secured_field[index][2] == 0x00000000) &&
+		    (iss_secured_field[index][3] == 0x00000000) )
+		{
+			bank->sectors[sector].is_protected = 1;
+		}
+
+		if (
+		    (iss_secured_field[index][0] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index][1] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index][2] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index][3] == 0xFFFFFFFF) )
+		{
+			bank->sectors[sector].is_protected = 0;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Use BIST to calculate a 128-bit hash value over a range of flash.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param addr_from
+ * @param addr_to
+ * @param signature
+ */
+static uint32_t lpc2900_run_bist128(struct flash_bank_s *bank,
+                                    uint32_t addr_from,
+                                    uint32_t addr_to,
+                                    uint32_t (*signature)[4] )
+{
+	target_t *target = bank->target;
+
+	/* Clear END_OF_MISR interrupt status */
+	target_write_u32( target, INT_CLR_STATUS, INTSRC_END_OF_MISR );
+
+	/* Start address */
+	target_write_u32( target, FMSSTART, addr_from >> 4);
+	/* End address, and issue start command */
+	target_write_u32( target, FMSSTOP, (addr_to >> 4) | FMSSTOP_MISR_START );
+
+	/* Poll for end of operation. Calculate a reasonable timeout. */
+	if( lpc2900_wait_status( bank, INTSRC_END_OF_MISR, 1000 ) != ERROR_OK )
+	{
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Return the signature */
+	target_read_memory( target, FMSW0, 4, 4, (uint8_t *)signature );
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Return sector number for given address.
+ *
+ * Return the (logical) sector number for a given relative address.
+ * No sanity check is done. It assumed that the address is valid.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param offset Offset address relative to bank start
+ */
+static uint32_t lpc2900_address2sector( struct flash_bank_s *bank,
+                                        uint32_t offset )
+{
+	uint32_t address = bank->base + offset;
+
+
+	/* Run through all sectors of this bank */
+	int sector;
+	for( sector = 0; sector < bank->num_sectors; sector++ )
+	{
+		/* Return immediately if address is within the current sector */
+		if( address < (bank->sectors[sector].offset + bank->sectors[sector].size) )
+		{
+			return sector;
+		}
+	}
+
+	/* We should never come here. If we do, return an arbitrary sector number. */
+	return 0;
+}
+
+
+
+
+/**
+ * Write one page to the index sector.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param pagenum Page number (0...7)
+ * @param page Page array (FLASH_PAGE_SIZE bytes)
+ */
+static int lpc2900_write_index_page( struct flash_bank_s *bank,
+                                     int pagenum,
+                                     uint8_t (*page)[FLASH_PAGE_SIZE] )
+{
+	/* Only pages 4...7 are user writable */
+	if( (pagenum < 4) || (pagenum > 7) )
+	{
+		LOG_ERROR( "Refuse to burn index sector page %" PRIu32, pagenum );
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	/* Get target, and check if it's halted */
+	target_t *target = bank->target;
+	if( target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Private info */
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Enable flash block and set the correct CRA clock of 66 kHz */
+	lpc2900_setup( bank );
+
+	/* Un-protect the index sector */
+	target_write_u32( target, bank->base, 0 );
+	target_write_u32( target, FCTR,
+	                  FCTR_FS_LOADREQ | FCTR_FS_WPB | FCTR_FS_ISS |
+	                  FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS );
+
+	/* Set latch load mode */
+	target_write_u32( target, FCTR,
+	                  FCTR_FS_ISS | FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS );
+
+	/* Write whole page to flash data latches */
+	if( target_write_memory( target,
+	                         bank->base + pagenum * FLASH_PAGE_SIZE,
+	                         4, FLASH_PAGE_SIZE / 4, (uint8_t *)page) != ERROR_OK )
+	{
+		LOG_ERROR( "Index sector write failed @ page %" PRIu32, pagenum );
+		target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Clear END_OF_BURN interrupt status */
+	target_write_u32( target, INT_CLR_STATUS, INTSRC_END_OF_BURN );
+
+	/* Set the program/erase time to FLASH_PROGRAM_TIME */
+	target_write_u32(target, FPTR,
+	                 FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
+	                                              FLASH_PROGRAM_TIME ));
+
+	/* Trigger flash write */
+	target_write_u32( target, FCTR,
+	                  FCTR_FS_PROGREQ | FCTR_FS_ISS |
+	                  FCTR_FS_WPB | FCTR_FS_WRE | FCTR_FS_CS );
+
+	/* Wait for the end of the write operation. If it's not over after one
+	 * second, something went dreadfully wrong... :-(
+	 */
+	if( lpc2900_wait_status( bank, INTSRC_END_OF_BURN, 1000 ) != ERROR_OK )
+	{
+		LOG_ERROR( "Index sector write failed @ page %" PRIu32, pagenum );
+		target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Calculate FPTR.TR register value for desired program/erase time.
+ *
+ * @param clock System clock in Hz
+ * @param time Program/erase time in ?s
+ */
+static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time )
+{
+	/*           ((time[?s]/1e6) * f[Hz]) + 511
+	 * FPTR.TR = -------------------------------
+	 *                         512
+	 *
+	 * The result is the 
+	 */
+
+	uint32_t tr_val = (uint32_t)((((time / 1e6) * clock) + 511.0) / 512.0);
+
+	return tr_val;
+}
+
+
+/***********************  Private flash commands  **************************/
+
+
+/**
+ * Command to determine the signature of the whole flash.
+ *
+ * Uses the Built-In-Self-Test (BIST) to generate a 128-bit hash value
+ * of the flash content.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_signature_command( struct command_context_s *cmd_ctx,
+                                             char *cmd, char **args, int argc )
+{
+	flash_bank_t *bank;
+	uint32_t status;
+	uint32_t signature[4];
+
+
+	if( argc < 1 )
+	{
+		LOG_WARNING( "Too few arguments. Call: lpc2900 signature <bank#>" );
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	/* Get the bank descriptor */
+	bank = get_flash_bank_by_num( strtoul(args[0], NULL, 0) );
+	if( !bank )
+	{
+		command_print( cmd_ctx, "flash bank '#%s' is out of bounds", args[0] );
+		return ERROR_OK;
+	}
+
+	if( bank->target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Run BIST over whole flash range */
+	if( (status = lpc2900_run_bist128( bank,
+	                                   bank->base,
+	                                   bank->base + (bank->size - 1),
+	                                   &signature)
+	                                 ) != ERROR_OK )
+	{
+		return status;
+	}
+
+	command_print( cmd_ctx, "signature: 0x%8.8" PRIx32
+	                                  ":0x%8.8" PRIx32
+	                                  ":0x%8.8" PRIx32
+	                                  ":0x%8.8" PRIx32,
+	              signature[3], signature[2], signature[1], signature[0] );
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Store customer info in file.
+ *
+ * Read customer info from index sector, and store that block of data into
+ * a disk file. The format is binary.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_read_custom_command( struct command_context_s *cmd_ctx,
+                                               char *cmd, char **args, int argc )
+{
+	flash_bank_t *bank;
+
+
+	if( argc < 2 )
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	bank = get_flash_bank_by_num( strtoul(args[0], NULL, 0) );
+	if( !bank )
+	{
+		command_print( cmd_ctx, "flash bank '#%s' is out of bounds", args[0] );
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+	lpc2900_info->risky = 0;
+
+	/* Get target, and check if it's halted */
+	target_t *target = bank->target;
+	if( target->state != TARGET_HALTED )
+	{
+		LOG_ERROR( "Target not halted" );
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Storage for customer info. Read in two parts */
+	uint32_t customer[ ISS_CUSTOMER_NWORDS1 + ISS_CUSTOMER_NWORDS2 ];
+
+	/* Enable access to index sector */
+	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB | FCTR_FS_ISS );
+
+	/* Read two parts */
+	target_read_memory( target, bank->base+ISS_CUSTOMER_START1, 4,
+	                            ISS_CUSTOMER_NWORDS1,
+	                            (uint8_t *)&customer[0] );
+	target_read_memory( target, bank->base+ISS_CUSTOMER_START2, 4,
+	                            ISS_CUSTOMER_NWORDS2,
+	                            (uint8_t *)&customer[ISS_CUSTOMER_NWORDS1] );
+
+	/* Deactivate access to index sector */
+	target_write_u32( target, FCTR, FCTR_FS_CS | FCTR_FS_WEB );
+
+	/* Try and open the file */
+	fileio_t fileio;
+	char *filename = args[1];
+	int ret = fileio_open( &fileio, filename, FILEIO_WRITE, FILEIO_BINARY );
+	if( ret != ERROR_OK )
+	{
+		LOG_WARNING( "Could not open file %s", filename );
+		return ret;
+	}
+
+	uint32_t nwritten;
+	ret = fileio_write( &fileio, sizeof(customer),
+                        (const uint8_t *)customer, &nwritten );
+	if( ret != ERROR_OK )
+	{
+		LOG_ERROR( "Write operation to file %s failed", filename );
+		fileio_close( &fileio );
+		return ret;
+	}
+
+	fileio_close( &fileio );
+
+	return ERROR_OK;
+}
+
+
+
+
+/**
+ * Enter password to enable potentially dangerous options.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_password_command(struct command_context_s *cmd_ctx,
+                                           char *cmd, char **args, int argc)
+{
+	flash_bank_t *bank;
+
+
+	if (argc < 2)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+#define ISS_PASSWORD "I_know_what_I_am_doing"
+
+	lpc2900_info->risky = !strcmp( args[1], ISS_PASSWORD );
+
+	if( !lpc2900_info->risky )
+	{
+		command_print(cmd_ctx, "Wrong password (use '%s')", ISS_PASSWORD);
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	command_print(cmd_ctx,
+                  "Potentially dangerous operation allowed in next command!");
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Write customer info from file to the index sector.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_write_custom_command( struct command_context_s *cmd_ctx,
+                                                char *cmd, char **args, int argc )
+{
+	if (argc < 2)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Check if command execution is allowed. */
+	if( !lpc2900_info->risky )
+	{
+		command_print( cmd_ctx, "Command execution not allowed!" );
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	lpc2900_info->risky = 0;
+
+	/* Get target, and check if it's halted */
+	target_t *target = bank->target;
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* The image will always start at offset 0 */
+	image_t image;
+	image.base_address_set = 1;
+	image.base_address = 0;
+	image.start_address_set = 0;
+
+	char *filename = args[1];
+	char *type = (argc >= 3) ? args[2] : NULL;
+	int retval = image_open(&image, filename, type);
+	if (retval != ERROR_OK)
+	{
+		return retval;
+	}
+
+	/* Do a sanity check: The image must be exactly the size of the customer
+	   programmable area. Any other size is rejected. */
+	if( image.num_sections != 1 )
+	{
+		LOG_ERROR("Only one section allowed in image file.");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	if( (image.sections[0].base_address != 0) ||
+        (image.sections[0].size != ISS_CUSTOMER_SIZE) )
+	{
+		LOG_ERROR("Incorrect image file size. Expected %" PRIu32 ", got %" PRIu32,
+                   ISS_CUSTOMER_SIZE, image.sections[0].size);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Well boys, I reckon this is it... */
+
+	/* Customer info is split into two blocks in pages 4 and 5. */
+	uint8_t page[FLASH_PAGE_SIZE];
+
+	/* Page 4 */
+	uint32_t offset = ISS_CUSTOMER_START1 % FLASH_PAGE_SIZE;
+	memset( page, 0xff, FLASH_PAGE_SIZE );
+	uint32_t size_read;
+	retval = image_read_section( &image, 0, 0,
+	                             ISS_CUSTOMER_SIZE1, &page[offset], &size_read);
+	if( retval != ERROR_OK )
+	{
+		LOG_ERROR("couldn't read from file '%s'", filename);
+		image_close(&image);
+		return retval;
+	}
+	if( (retval = lpc2900_write_index_page( bank, 4, &page )) != ERROR_OK )
+	{
+		image_close(&image);
+		return retval;
+	}
+
+	/* Page 5 */
+	offset = ISS_CUSTOMER_START2 % FLASH_PAGE_SIZE;
+	memset( page, 0xff, FLASH_PAGE_SIZE );
+	retval = image_read_section( &image, 0, ISS_CUSTOMER_SIZE1,
+	                             ISS_CUSTOMER_SIZE2, &page[offset], &size_read);
+	if( retval != ERROR_OK )
+	{
+		LOG_ERROR("couldn't read from file '%s'", filename);
+		image_close(&image);
+		return retval;
+	}
+	if( (retval = lpc2900_write_index_page( bank, 5, &page )) != ERROR_OK )
+	{
+		image_close(&image);
+		return retval;
+	}
+
+	image_close(&image);
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Activate 'sector security' for a range of sectors.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_secure_sector_command(struct command_context_s *cmd_ctx,
+                                                char *cmd, char **args, int argc)
+{
+	if (argc < 3)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Check if command execution is allowed. */
+	if( !lpc2900_info->risky )
+	{
+		command_print( cmd_ctx, "Command execution not allowed! "
+		"(use 'password' command first)");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	lpc2900_info->risky = 0;
+
+	/* Read sector range, and do a sanity check. */
+	int first = strtoul(args[1], NULL, 0);
+	int last = strtoul(args[2], NULL, 0);
+	if( (first >= bank->num_sectors) ||
+	    (last >= bank->num_sectors) ||
+	    (first > last) )
+	{
+		command_print( cmd_ctx, "Illegal sector range" );
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+
+	uint8_t page[FLASH_PAGE_SIZE];
+	int sector;
+	int retval;
+
+	/* Sectors in page 6 */
+	if( (first <= 4) || (last >= 8) )
+	{
+		memset( &page, 0xff, FLASH_PAGE_SIZE );
+		for( sector = first; sector <= last; sector++ )
+		{
+			if( sector <= 4 )
+			{
+				memset( &page[0xB0 + 16*sector], 0, 16 );
+			}
+			else if( sector >= 8 )
+			{
+				memset( &page[0x00 + 16*(sector - 8)], 0, 16 );
+			}
+		}
+
+		if( (retval = lpc2900_write_index_page( bank, 6, &page )) != ERROR_OK )
+		{
+			LOG_ERROR("failed to update index sector page 6");
+			return retval;
+		}
+	}
+
+	/* Sectors in page 7 */
+	if( (first <= 7) && (last >= 5) )
+	{
+		memset( &page, 0xff, FLASH_PAGE_SIZE );
+		for( sector = first; sector <= last; sector++ )
+		{
+			if( (sector >= 5) && (sector <= 7) )
+			{
+				memset( &page[0x00 + 16*(sector - 5)], 0, 16 );
+			}
+		}
+
+		if( (retval = lpc2900_write_index_page( bank, 7, &page )) != ERROR_OK )
+		{
+			LOG_ERROR("failed to update index sector page 7");
+			return retval;
+		}
+	}
+
+	command_print( cmd_ctx,
+	        "Sectors security will become effective after next power cycle");
+
+	/* Update the sector security status */
+	if ( lpc2900_read_security_status(bank) != ERROR_OK )
+	{
+		LOG_ERROR( "Cannot determine sector security status" );
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+
+
+/**
+ * Activate JTAG protection.
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ */
+static int lpc2900_handle_secure_jtag_command(struct command_context_s *cmd_ctx,
+                                              char *cmd, char **args, int argc)
+{
+	if (argc < 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* Get the bank descriptor */
+	flash_bank_t *bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
+	if (!bank)
+	{
+		command_print(cmd_ctx, "flash bank '#%s' is out of bounds", args[0]);
+		return ERROR_OK;
+	}
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+	/* Check if command execution is allowed. */
+	if( !lpc2900_info->risky )
+	{
+		command_print( cmd_ctx, "Command execution not allowed! "
+		                        "(use 'password' command first)");
+		return ERROR_COMMAND_ARGUMENT_INVALID;
+	}
+	lpc2900_info->risky = 0;
+
+	/* Prepare page */
+	uint8_t page[FLASH_PAGE_SIZE];
+	memset( &page, 0xff, FLASH_PAGE_SIZE );
+
+
+	/* Insert "soft" protection word */
+	page[0x30 + 15] = 0x7F;
+	page[0x30 + 11] = 0x7F;
+	page[0x30 +  7] = 0x7F;
+	page[0x30 +  3] = 0x7F;
+
+	/* Write to page 5 */
+	int retval;
+	if( (retval = lpc2900_write_index_page( bank, 5, &page ))
+			!= ERROR_OK )
+	{
+		LOG_ERROR("failed to update index sector page 5");
+		return retval;
+	}
+
+	LOG_INFO("JTAG security set. Good bye!");
+
+	return ERROR_OK;
+}
+
+
+
+/***********************  Flash interface functions  **************************/
+
+
+/**
+ * Register private command handlers.
+ *
+ * @param cmd_ctx
+ */
+static int lpc2900_register_commands(struct command_context_s *cmd_ctx)
+{
+	command_t *lpc2900_cmd = register_command(cmd_ctx, NULL, "lpc2900",
+	                                          NULL, COMMAND_ANY, NULL);
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "signature",
+	    lpc2900_handle_signature_command,
+	    COMMAND_EXEC,
+	    "<bank> | "
+            "print device signature of flash bank");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "read_custom",
+	    lpc2900_handle_read_custom_command,
+	    COMMAND_EXEC,
+	    "<bank> <filename> | "
+            "read customer information from index sector to file");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "password",
+	    lpc2900_handle_password_command,
+	    COMMAND_EXEC,
+	    "<bank> <password> | "
+            "enter password to enable 'dangerous' options");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "write_custom",
+	    lpc2900_handle_write_custom_command,
+	    COMMAND_EXEC,
+	    "<bank> <filename> [<type>] | "
+            "write customer info from file to index sector");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "secure_sector",
+	    lpc2900_handle_secure_sector_command,
+	    COMMAND_EXEC,
+	    "<bank> <first> <last> | "
+            "activate sector security for a range of sectors");
+
+	register_command(
+	    cmd_ctx,
+	    lpc2900_cmd,
+	    "secure_jtag",
+	    lpc2900_handle_secure_jtag_command,
+	    COMMAND_EXEC,
+	    "<bank> <level> | "
+            "activate JTAG security");
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Evaluate flash bank command.
+ *
+ * Syntax: flash bank lpc2900 0 0 0 0 target# system_base_clock
+ *
+ * @param cmd_ctx
+ * @param cmd
+ * @param args
+ * @param argc
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_flash_bank_command(struct command_context_s *cmd_ctx,
+                                      char *cmd, char **args, int argc,
+                                      struct flash_bank_s *bank)
+{
+	lpc2900_flash_bank_t *lpc2900_info;
+
+	if (argc < 6)
+	{
+		LOG_WARNING("incomplete flash_bank LPC2900 configuration");
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	lpc2900_info = malloc(sizeof(lpc2900_flash_bank_t));
+	bank->driver_priv = lpc2900_info;
+
+	/* Get flash clock.
+	 * Reject it if we can't meet the requirements for program time
+	 * (if clock too slow), or for erase time (clock too fast).
+	 */
+	lpc2900_info->clk_sys_fmc = strtoul(args[6], NULL, 0) * 1000;
+
+	uint32_t clock_limit;
+	/* Check program time limit */
+	clock_limit = 512000000l / FLASH_PROGRAM_TIME;
+	if (lpc2900_info->clk_sys_fmc < clock_limit)
+	{
+		LOG_WARNING("flash clock must be at least %" PRIu32 " kHz",
+                    (clock_limit / 1000));
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	/* Check erase time limit */
+	clock_limit = (uint32_t)((32767.0 * 512.0 * 1e6) / FLASH_ERASE_TIME);
+	if (lpc2900_info->clk_sys_fmc > clock_limit)
+	{
+		LOG_WARNING("flash clock must be a maximum of %" PRIu32" kHz",
+                    (clock_limit / 1000));
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	/* Chip ID will be obtained by probing the device later */
+	lpc2900_info->chipid = 0;
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Erase sector(s).
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param first First sector to be erased
+ * @param last Last sector (including) to be erased
+ */
+static int lpc2900_erase(struct flash_bank_s *bank, int first, int last)
+{
+	uint32_t status;
+	int sector;
+	int last_unsecured_sector;
+	target_t *target = bank->target;
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+
+
+	status = lpc2900_is_ready(bank);
+	if (status != ERROR_OK)
+	{
+		return status;
+	}
+
+	/* Sanity check on sector range */
+	if ((first < 0) || (last < first) || (last >= bank->num_sectors))
+	{
+		LOG_INFO("Bad sector range");
+		return ERROR_FLASH_SECTOR_INVALID;
+	}
+
+	/* Update the info about secured sectors */
+	lpc2900_read_security_status( bank );
+
+	/* The selected sector range might include secured sectors. An attempt
+	 * to erase such a sector will cause the erase to fail also for unsecured
+	 * sectors. It is necessary to determine the last unsecured sector now,
+	 * because we have to treat the last relevant sector in the list in
+	 * a special way.
+	 */
+	last_unsecured_sector = -1;
+	for (sector = first; sector <= last; sector++)
+	{
+		if ( !bank->sectors[sector].is_protected )
+		{
+			last_unsecured_sector = sector;
+		}
+	}
+
+	/* Exit now, in case of the rare constellation where all sectors in range
+	 * are secured. This is regarded a success, since erasing/programming of
+	 * secured sectors shall be handled transparently.
+	 */
+	if ( last_unsecured_sector == -1 )
+	{
+		return ERROR_OK;
+	}
+
+	/* Enable flash block and set the correct CRA clock of 66 kHz */
+	lpc2900_setup(bank);
+
+	/* Clear END_OF_ERASE interrupt status */
+	target_write_u32(target, INT_CLR_STATUS, INTSRC_END_OF_ERASE);
+
+	/* Set the program/erase timer to FLASH_ERASE_TIME */
+	target_write_u32(target, FPTR,
+	                 FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
+	                                              FLASH_ERASE_TIME ));
+
+	/* Sectors are marked for erasure, then erased all together */
+	for (sector = first; sector <= last_unsecured_sector; sector++)
+	{
+		/* Only mark sectors that aren't secured. Any attempt to erase a group
+		 * of sectors will fail if any single one of them is secured!
+		 */
+		if ( !bank->sectors[sector].is_protected )
+		{
+			/* Unprotect the sector */
+			target_write_u32(target, bank->sectors[sector].offset, 0);
+			target_write_u32(target, FCTR,
+			                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
+			                 FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS);
+
+			/* Mark the sector for erasure. The last sector in the list
+			   triggers the erasure. */
+			target_write_u32(target, bank->sectors[sector].offset, 0);
+			if ( sector == last_unsecured_sector )
+			{
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_PROGREQ | FCTR_FS_WPB | FCTR_FS_CS);
+			}
+			else
+			{
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
+				                 FCTR_FS_WEB | FCTR_FS_CS);
+			}
+		}
+	}
+
+	/* Wait for the end of the erase operation. If it's not over after two seconds,
+	 * something went dreadfully wrong... :-(
+	 */
+	if( lpc2900_wait_status(bank, INTSRC_END_OF_ERASE, 2000) != ERROR_OK )
+	{
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Normal flash operating mode */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+	return ERROR_OK;
+}
+
+
+
+static int lpc2900_protect(struct flash_bank_s *bank, int set, int first, int last)
+{
+	/* This command is not supported.
+     * "Protection" in LPC2900 terms is handled transparently. Sectors will
+     * automatically be unprotected as needed.
+     * Instead we use the concept of sector security. A secured sector is shown
+     * as "protected" in OpenOCD. Sector security is a permanent feature, and
+     * cannot be disabled once activated.
+     */
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Write data to flash.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param buffer Buffer with data
+ * @param offset Start address (relative to bank start)
+ * @param count Number of bytes to be programmed
+ */
+static int lpc2900_write(struct flash_bank_s *bank, uint8_t *buffer,
+                         uint32_t offset, uint32_t count)
+{
+	uint8_t page[FLASH_PAGE_SIZE];
+	uint32_t status;
+	uint32_t num_bytes;
+	target_t *target = bank->target;
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+	int sector;
+	int retval;
+
+	static const uint32_t write_target_code[] = {
+		/* Set auto latch mode: FCTR=CS|WRE|WEB */
+		0xe3a0a007,   /* loop       mov r10, #0x007 */
+		0xe583a000,   /*            str r10,[r3,#0] */
+
+		/* Load complete page into latches */
+		0xe3a06020,   /*            mov r6,#(512/16) */
+		0xe8b00f00,   /* next       ldmia r0!,{r8-r11} */
+		0xe8a10f00,   /*            stmia r1!,{r8-r11} */
+		0xe2566001,   /*            subs r6,#1 */
+		0x1afffffb,   /*            bne next */
+
+		/* Clear END_OF_BURN interrupt status */
+		0xe3a0a002,   /*            mov r10,#(1 << 1) */
+		0xe583afe8,   /*            str r10,[r3,#0xfe8] */
+
+		/* Set the erase time to FLASH_PROGRAM_TIME */
+		0xe5834008,   /*            str r4,[r3,#8] */
+
+		/* Trigger flash write
+			FCTR = CS | WRE | WPB | PROGREQ */
+		0xe3a0a083,   /*            mov r10,#0x83 */
+		0xe38aaa01,   /*            orr r10,#0x1000 */
+		0xe583a000,   /*            str r10,[r3,#0] */
+
+		/* Wait for end of burn */
+		0xe593afe0,   /* wait       ldr r10,[r3,#0xfe0] */
+		0xe21aa002,   /*            ands r10,#(1 << 1) */
+		0x0afffffc,   /*            beq wait */
+
+		/* End? */
+		0xe2522001,   /*            subs r2,#1 */
+		0x1affffed,   /*            bne loop */
+
+		0xeafffffe    /* done       b done */
+	};
+
+
+	status = lpc2900_is_ready(bank);
+	if (status != ERROR_OK)
+	{
+		return status;
+	}
+
+	/* Enable flash block and set the correct CRA clock of 66 kHz */
+	lpc2900_setup(bank);
+
+	/* Update the info about secured sectors */
+	lpc2900_read_security_status( bank );
+
+	/* Unprotect all involved sectors */
+	for (sector = 0; sector < bank->num_sectors; sector++)
+	{
+		/* Start address in or before this sector? */
+		/* End address in or behind this sector? */
+		if ( ((bank->base + offset) <
+		          (bank->sectors[sector].offset + bank->sectors[sector].size)) &&
+		     ((bank->base + (offset + count - 1)) >= bank->sectors[sector].offset) )
+		{
+			/* This sector is involved and needs to be unprotected.
+				* Don't do it for secured sectors.
+				*/
+			if ( !bank->sectors[sector].is_protected )
+			{
+				target_write_u32(target, bank->sectors[sector].offset, 0);
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_LOADREQ | FCTR_FS_WPB |
+				                 FCTR_FS_WEB | FCTR_FS_WRE | FCTR_FS_CS);
+			}
+		}
+	}
+
+	/* Set the program/erase time to FLASH_PROGRAM_TIME */
+	uint32_t prog_time = FPTR_EN_T | lpc2900_calc_tr( lpc2900_info->clk_sys_fmc,
+	                                                  FLASH_PROGRAM_TIME );
+
+	/* If there is a working area of reasonable size, use it to program via
+	   a target algorithm. If not, fall back to host programming. */
+
+	/* We need some room for target code. */
+	uint32_t target_code_size = sizeof(write_target_code);
+
+	/* Try working area allocation. Start with a large buffer, and try with
+	   reduced size if that fails. */
+	working_area_t *warea;
+	uint32_t buffer_size = lpc2900_info->max_ram_block - 1 * KiB;
+	while( (retval = target_alloc_working_area(target,
+	                                           buffer_size + target_code_size,
+	                                           &warea)) != ERROR_OK )
+	{
+		/* Try a smaller buffer now, and stop if it's too small. */
+		buffer_size -= 1 * KiB;
+		if (buffer_size < 2 * KiB)
+		{
+			LOG_INFO( "no (large enough) working area"
+			          ", falling back to host mode" );
+			warea = NULL;
+			break;
+		}
+	};
+
+	if( warea )
+	{
+		reg_param_t reg_params[5];
+		armv4_5_algorithm_t armv4_5_info;
+
+		/* We can use target mode. Download the algorithm. */
+		retval = target_write_buffer( target,
+		                              (warea->address)+buffer_size,
+		                              target_code_size,
+		                              (uint8_t *)write_target_code);
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("Unable to write block write code to target");
+			target_free_all_working_areas(target);
+			return ERROR_FLASH_OPERATION_FAILED;
+		}
+
+		init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+		init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+		init_reg_param(&reg_params[2], "r2", 32, PARAM_OUT);
+		init_reg_param(&reg_params[3], "r3", 32, PARAM_OUT);
+		init_reg_param(&reg_params[4], "r4", 32, PARAM_OUT);
+
+		/* Write to flash in large blocks */
+		while ( count != 0 )
+		{
+			uint32_t this_npages;
+			uint8_t *this_buffer;
+			int start_sector = lpc2900_address2sector( bank, offset );
+
+			/* First page / last page / rest */
+			if( offset % FLASH_PAGE_SIZE )
+			{
+				/* Block doesn't start on page boundary.
+				   Burn first partial page separately. */
+				memset( &page, 0xff, sizeof(page) );
+				memcpy( &page[offset % FLASH_PAGE_SIZE],
+				        buffer,
+				        FLASH_PAGE_SIZE - (offset % FLASH_PAGE_SIZE) );
+				this_npages = 1;
+				this_buffer = &page[0];
+				count = count + (offset % FLASH_PAGE_SIZE);
+				offset = offset - (offset % FLASH_PAGE_SIZE);
+			}
+			else if( count < FLASH_PAGE_SIZE )
+			{
+				/* Download last incomplete page separately. */
+				memset( &page, 0xff, sizeof(page) );
+				memcpy( &page, buffer, count );
+				this_npages = 1;
+				this_buffer = &page[0];
+				count = FLASH_PAGE_SIZE;
+			}
+			else
+			{
+				/* Download as many full pages as possible */
+				this_npages = (count < buffer_size) ?
+				               count / FLASH_PAGE_SIZE :
+				               buffer_size / FLASH_PAGE_SIZE;
+				this_buffer = buffer;
+
+				/* Make sure we stop at the next secured sector */
+				int sector = start_sector + 1;
+				while( sector < bank->num_sectors )
+				{
+					/* Secured? */
+					if( bank->sectors[sector].is_protected )
+					{
+						/* Is that next sector within the current block? */
+						if( (bank->sectors[sector].offset - bank->base) <
+							(offset + (this_npages * FLASH_PAGE_SIZE)) )
+						{
+							/* Yes! Split the block */
+							this_npages =
+							  (bank->sectors[sector].offset - bank->base - offset)
+							      / FLASH_PAGE_SIZE;
+							break;
+						}
+					}
+
+					sector++;
+				}
+			}
+
+			/* Skip the current sector if it is secured */
+			if( bank->sectors[start_sector].is_protected )
+			{
+				LOG_DEBUG( "Skip secured sector %" PRIu32, start_sector );
+
+				/* Stop if this is the last sector */
+				if( start_sector == bank->num_sectors - 1 )
+				{
+					break;
+				}
+
+				/* Skip */
+				uint32_t nskip = bank->sectors[start_sector].size -
+				                 (offset % bank->sectors[start_sector].size);
+				offset += nskip;
+				buffer += nskip;
+				count = (count >= nskip) ? (count - nskip) : 0;
+				continue;
+			}
+
+			/* Execute buffer download */
+			if ((retval = target_write_buffer(target,
+			                                  warea->address,
+			                                  this_npages * FLASH_PAGE_SIZE,
+			                                  this_buffer)) != ERROR_OK)
+			{
+				LOG_ERROR("Unable to write data to target");
+				target_free_all_working_areas(target);
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+
+			/* Prepare registers */
+			buf_set_u32(reg_params[0].value, 0, 32, warea->address);
+			buf_set_u32(reg_params[1].value, 0, 32, offset);
+			buf_set_u32(reg_params[2].value, 0, 32, this_npages);
+			buf_set_u32(reg_params[3].value, 0, 32, FCTR);
+			buf_set_u32(reg_params[4].value, 0, 32, FPTR_EN_T | prog_time);
+
+			/* Execute algorithm, assume breakpoint for last instruction */
+			armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
+			armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
+			armv4_5_info.core_state = ARMV4_5_STATE_ARM;
+
+			retval = target_run_algorithm(target, 0, NULL, 5, reg_params,
+				(warea->address) + buffer_size,
+				(warea->address) + buffer_size + target_code_size - 4,
+				10000, /* 10s should be enough for max. 16 KiB of data */
+				&armv4_5_info);
+
+			if (retval != ERROR_OK)
+			{
+				LOG_ERROR("Execution of flash algorithm failed.");
+				target_free_all_working_areas(target);
+				retval = ERROR_FLASH_OPERATION_FAILED;
+				break;
+			}
+
+			count -= this_npages * FLASH_PAGE_SIZE;
+			buffer += this_npages * FLASH_PAGE_SIZE;
+			offset += this_npages * FLASH_PAGE_SIZE;
+		}
+
+		/* Free all resources */
+		destroy_reg_param(&reg_params[0]);
+		destroy_reg_param(&reg_params[1]);
+		destroy_reg_param(&reg_params[2]);
+		destroy_reg_param(&reg_params[3]);
+		destroy_reg_param(&reg_params[4]);
+		target_free_all_working_areas(target);
+	}
+	else
+	{
+		/* Write to flash memory page-wise */
+		while ( count != 0 )
+		{
+			/* How many bytes do we copy this time? */
+			num_bytes = (count >= FLASH_PAGE_SIZE) ?
+			            FLASH_PAGE_SIZE - (offset % FLASH_PAGE_SIZE) :
+			            count;
+
+			/* Don't do anything with it if the page is in a secured sector. */
+			if ( !bank->sectors[lpc2900_address2sector(bank, offset)].is_protected )
+			{
+				/* Set latch load mode */
+				target_write_u32(target, FCTR,
+				                 FCTR_FS_CS | FCTR_FS_WRE | FCTR_FS_WEB);
+
+				/* Always clear the buffer (a little overhead, but who cares) */
+				memset(page, 0xFF, FLASH_PAGE_SIZE);
+
+				/* Copy them to the buffer */
+				memcpy( &page[offset % FLASH_PAGE_SIZE],
+				        &buffer[offset % FLASH_PAGE_SIZE],
+				        num_bytes );
+
+				/* Write whole page to flash data latches */
+				if (target_write_memory(
+				                 target,
+				                 bank->base + (offset - (offset % FLASH_PAGE_SIZE)),
+				                 4, FLASH_PAGE_SIZE / 4, page) != ERROR_OK)
+				{
+					LOG_ERROR("Write failed @ 0x%8.8" PRIx32, offset);
+					target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+					return ERROR_FLASH_OPERATION_FAILED;
+				}
+
+				/* Clear END_OF_BURN interrupt status */
+				target_write_u32(target, INT_CLR_STATUS, INTSRC_END_OF_BURN);
+
+				/* Set the programming time */
+				target_write_u32(target, FPTR, FPTR_EN_T | prog_time);
+
+				/* Trigger flash write */
+				target_write_u32(target, FCTR,
+				    FCTR_FS_CS | FCTR_FS_WRE | FCTR_FS_WPB | FCTR_FS_PROGREQ);
+
+				/* Wait for the end of the write operation. If it's not over
+				 * after one second, something went dreadfully wrong... :-(
+				 */
+				if (lpc2900_wait_status(bank, INTSRC_END_OF_BURN, 1000) != ERROR_OK)
+				{
+					LOG_ERROR("Write failed @ 0x%8.8" PRIx32, offset);
+					target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+					return ERROR_FLASH_OPERATION_FAILED;
+				}
+			}
+
+			/* Update pointers and counters */
+			offset += num_bytes;
+			buffer += num_bytes;
+			count -= num_bytes;
+		}
+
+		retval = ERROR_OK;
+	}
+
+	/* Normal flash operating mode */
+	target_write_u32(target, FCTR, FCTR_FS_CS | FCTR_FS_WEB);
+
+	return retval;
+}
+
+
+/**
+ * Try and identify the device.
+ *
+ * Determine type number and its memory layout.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_probe(struct flash_bank_s *bank)
+{
+	lpc2900_flash_bank_t *lpc2900_info = bank->driver_priv;
+	target_t *target = bank->target;
+	int i = 0;
+	uint32_t offset;
+
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* We want to do this only once. Check if we already have a valid CHIPID,
+	 * because then we will have already successfully probed the device.
+	 */
+	if (lpc2900_info->chipid == EXPECTED_CHIPID)
+	{
+		return ERROR_OK;
+	}
+
+	/* Probing starts with reading the CHIPID register. We will continue only
+	 * if this identifies as an LPC2900 device.
+	 */
+	target_read_u32(target, CHIPID, &lpc2900_info->chipid);
+
+	if (lpc2900_info->chipid != EXPECTED_CHIPID)
+	{
+		LOG_WARNING("Device is not an LPC29xx");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* It's an LPC29xx device. Now read the feature register FEAT0...FEAT3. */
+	uint32_t feat0, feat1, feat2, feat3;
+	target_read_u32(target, FEAT0, &feat0);
+	target_read_u32(target, FEAT1, &feat1);
+	target_read_u32(target, FEAT2, &feat2);
+	target_read_u32(target, FEAT3, &feat3);
+
+	/* Base address */
+	bank->base = 0x20000000;
+
+	/* Determine flash layout from FEAT2 register */
+	uint32_t num_64k_sectors = (feat2 >> 16) & 0xFF;
+	uint32_t num_8k_sectors = (feat2 >> 0) & 0xFF;
+	bank->num_sectors = num_64k_sectors + num_8k_sectors;
+	bank->size = KiB * (64 * num_64k_sectors + 8 * num_8k_sectors);
+
+	/* Determine maximum contiguous RAM block */
+	lpc2900_info->max_ram_block = 16 * KiB;
+	if( (feat1 & 0x30) == 0x30 )
+	{
+		lpc2900_info->max_ram_block = 32 * KiB;
+		if( (feat1 & 0x0C) == 0x0C )
+		{
+			lpc2900_info->max_ram_block = 48 * KiB;
+		}
+	}
+
+	/* Determine package code and ITCM size */
+	uint32_t package_code = feat0 & 0x0F;
+	uint32_t itcm_code = (feat1 >> 16) & 0x1F;
+
+	/* Determine the exact type number. */
+	uint32_t found = 1;
+	if ( (package_code == 4) && (itcm_code == 5) )
+	{
+		/* Old LPC2917 or LPC2919 (non-/01 devices) */
+		lpc2900_info->target_name = (bank->size == 768*KiB) ? "LPC2919" : "LPC2917";
+	}
+	else
+	{
+		if ( package_code == 2 )
+		{
+			/* 100-pin package */
+			if ( bank->size == 128*KiB )
+			{
+				lpc2900_info->target_name = "LPC2921";
+			}
+			else if ( bank->size == 256*KiB )
+			{
+				lpc2900_info->target_name = "LPC2923";
+			}
+			else if ( bank->size == 512*KiB )
+			{
+				lpc2900_info->target_name = "LPC2925";
+			}
+			else
+			{
+				found = 0;
+			}
+		}
+		else if ( package_code == 4 )
+		{
+			/* 144-pin package */
+			if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFCF0) )
+			{
+				lpc2900_info->target_name = "LPC2917/01";
+			}
+			else if ( (bank->size == 512*KiB) && (feat3 == 0xFFFFFFF1) )
+			{
+				lpc2900_info->target_name = "LPC2927";
+			}
+			else if ( (bank->size == 768*KiB) && (feat3 == 0xFFFFFCF8) )
+			{
+				lpc2900_info->target_name = "LPC2919/01";
+			}
+			else if ( (bank->size == 768*KiB) && (feat3 == 0xFFFFFFF9) )
+			{
+				lpc2900_info->target_name = "LPC2929";
+			}
+			else
+			{
+				found = 0;
+			}
+		}
+		else if ( package_code == 5 )
+		{
+			/* 208-pin package */
+			lpc2900_info->target_name = (bank->size == 0) ? "LPC2930" : "LPC2939";
+		}
+		else
+		{
+			found = 0;
+		}
+	}
+
+	if ( !found )
+	{
+		LOG_WARNING("Unknown LPC29xx derivative");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Show detected device */
+	LOG_INFO("Flash bank %" PRIu32
+	         ": Device %s, %" PRIu32
+	         " KiB in %" PRIu32 " sectors",
+	         bank->bank_number,
+	         lpc2900_info->target_name, bank->size / KiB,
+	         bank->num_sectors);
+
+	/* Flashless devices cannot be handled */
+	if ( bank->num_sectors == 0 )
+	{
+		LOG_WARNING("Flashless device cannot be handled");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* Sector layout.
+	 * These are logical sector numbers. When doing real flash operations,
+	 * the logical flash number are translated into the physical flash numbers
+	 * of the device.
+	 */
+	bank->sectors = malloc(sizeof(flash_sector_t) * bank->num_sectors);
+
+	offset = 0;
+	for (i = 0; i < bank->num_sectors; i++)
+	{
+		bank->sectors[i].offset = offset;
+		bank->sectors[i].is_erased = -1;
+		bank->sectors[i].is_protected = -1;
+
+		if ( i <= 7 )
+		{
+			bank->sectors[i].size = 8 * KiB;
+		}
+		else if ( i <= 18 )
+		{
+			bank->sectors[i].size = 64 * KiB;
+		}
+		else
+		{
+			/* We shouldn't come here. But there might be a new part out there
+			 * that has more than 19 sectors. Politely ask for a fix then.
+			 */
+			bank->sectors[i].size = 0;
+			LOG_ERROR("Never heard about sector %" PRIu32 " (FIXME please)", i);
+		}
+
+		offset += bank->sectors[i].size;
+	}
+
+	/* Read sector security status */
+	if ( lpc2900_read_security_status(bank) != ERROR_OK )
+	{
+		LOG_ERROR("Cannot determine sector security status");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Run a blank check for each sector.
+ *
+ * For speed reasons, the device isn't read word by word.
+ * A hash value is calculated by the hardware ("BIST") for each sector.
+ * This value is then compared against the known hash of an empty sector.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_erase_check(struct flash_bank_s *bank)
+{
+	uint32_t status = lpc2900_is_ready(bank);
+	if (status != ERROR_OK)
+	{
+		LOG_INFO("Processor not halted/not probed");
+		return status;
+	}
+
+	/* Use the BIST (Built-In Selft Test) to generate a signature of each flash
+	 * sector. Compare against the expected signature of an empty sector.
+	 */
+	int sector;
+	for ( sector = 0; sector < bank->num_sectors; sector++ )
+	{
+		uint32_t signature[4];
+		if ( (status = lpc2900_run_bist128( bank,
+		                                    bank->sectors[sector].offset,
+		                                    bank->sectors[sector].offset +
+		                                       (bank->sectors[sector].size - 1),
+		                                    &signature)) != ERROR_OK )
+		{
+			return status;
+		}
+
+		/* The expected signatures for an empty sector are different
+		 * for 8 KiB and 64 KiB sectors.
+		 */
+		if ( bank->sectors[sector].size == 8*KiB )
+		{
+			bank->sectors[sector].is_erased =
+			    (signature[3] == 0x01ABAAAA) &&
+			    (signature[2] == 0xAAAAAAAA) &&
+			    (signature[1] == 0xAAAAAAAA) &&
+			    (signature[0] == 0xAAA00AAA);
+		}
+		if ( bank->sectors[sector].size == 64*KiB )
+		{
+			bank->sectors[sector].is_erased =
+			    (signature[3] == 0x11801222) &&
+			    (signature[2] == 0xB88844FF) &&
+			    (signature[1] == 0x11A22008) &&
+			    (signature[0] == 0x2B1BFE44);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+
+/**
+ * Get protection (sector security) status.
+ *
+ * Determine the status of "sector security" for each sector.
+ * A secured sector is one that can never be erased/programmed again.
+ *
+ * @param bank Pointer to the flash bank descriptor
+ */
+static int lpc2900_protect_check(struct flash_bank_s *bank)
+{
+	return lpc2900_read_security_status(bank);
+}
+
+
+/**
+ * Print info about the driver (not the device).
+ *
+ * @param bank Pointer to the flash bank descriptor
+ * @param buf Buffer to take the string
+ * @param buf_size Maximum number of characters that the buffer can take
+ */
+static int lpc2900_info(struct flash_bank_s *bank, char *buf, int buf_size)
+{
+	snprintf(buf, buf_size, "lpc2900 flash driver");
+
+	return ERROR_OK;
+}
+
+
+flash_driver_t lpc2900_flash =
+{
+	.name               = "lpc2900",
+	.register_commands  = lpc2900_register_commands,
+	.flash_bank_command = lpc2900_flash_bank_command,
+	.erase              = lpc2900_erase,
+	.protect            = lpc2900_protect,
+	.write              = lpc2900_write,
+	.probe              = lpc2900_probe,
+	.auto_probe         = lpc2900_probe,
+	.erase_check        = lpc2900_erase_check,
+	.protect_check      = lpc2900_protect_check,
+	.info               = lpc2900_info
+};


Property changes on: trunk/src/flash/lpc2900.c
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: trunk/src/flash/lpc2900.h
===================================================================
--- trunk/src/flash/lpc2900.h	2009-09-22 05:39:06 UTC (rev 2746)
+++ trunk/src/flash/lpc2900.h	2009-09-22 14:50:46 UTC (rev 2747)
@@ -1,27 +1,27 @@
-/***************************************************************************
- *   Copyright (C) 2009 by                                                 *
- *   Rolf Meeser <rolfm_9dq at yahoo.de>                                      *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef lpc2900_H
-#define lpc2900_H
-
-#include "flash.h"
-
-
-#endif /* lpc2900_H */
+/***************************************************************************
+ *   Copyright (C) 2009 by                                                 *
+ *   Rolf Meeser <rolfm_9dq at yahoo.de>                                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifndef lpc2900_H
+#define lpc2900_H
+
+#include "flash.h"
+
+
+#endif /* lpc2900_H */


Property changes on: trunk/src/flash/lpc2900.h
___________________________________________________________________
Name: svn:eol-style
   + native


Property changes on: trunk/tcl/board/csb337.cfg
___________________________________________________________________
Name: eol:style
   - native


Property changes on: trunk/tcl/board/ek-lm3s3748.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From ntfreak at mail.berlios.de  Tue Sep 22 17:39:23 2009
From: ntfreak at mail.berlios.de (ntfreak at BerliOS)
Date: Tue, 22 Sep 2009 17:39:23 +0200
Subject: [Openocd-svn] r2748 - trunk/src/flash
Message-ID: <200909221539.n8MFdNhw003856@sheep.berlios.de>

Author: ntfreak
Date: 2009-09-22 17:39:23 +0200 (Tue, 22 Sep 2009)
New Revision: 2748

Modified:
   trunk/src/flash/flash.c
Log:
- fix build issue under win32 (cygwin/msys) from svn r2746


Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-09-22 14:50:46 UTC (rev 2747)
+++ trunk/src/flash/flash.c	2009-09-22 15:39:23 UTC (rev 2748)
@@ -560,7 +560,7 @@
 }
 
 static int flash_check_sector_parameters(struct command_context_s *cmd_ctx,
-		uint32_t first, uint32_t last, uint num_sectors)
+		uint32_t first, uint32_t last, uint32_t num_sectors)
 {
 	if (!(first <= last)) {
 		command_print(cmd_ctx, "ERROR: "



From oharboe at mail.berlios.de  Wed Sep 23 09:14:11 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 23 Sep 2009 09:14:11 +0200
Subject: [Openocd-svn] r2749 - in trunk/src: flash helper
Message-ID: <200909230714.n8N7EBoi032129@sheep.berlios.de>

Author: oharboe
Date: 2009-09-23 09:14:03 +0200 (Wed, 23 Sep 2009)
New Revision: 2749

Modified:
   trunk/src/flash/at91sam3.c
   trunk/src/helper/jim.c
Log:
Nico Coesel <ncoesel at dealogic.nl> fix warnings. . I'm wondering why these
didn't turn up earlier. Is everyone still using gcc 3.x? Or is the x86
version of gcc 4.x much more relaxed?

Modified: trunk/src/flash/at91sam3.c
===================================================================
--- trunk/src/flash/at91sam3.c	2009-09-22 15:39:23 UTC (rev 2748)
+++ trunk/src/flash/at91sam3.c	2009-09-23 07:14:03 UTC (rev 2749)
@@ -1609,7 +1609,7 @@
 sam3_protect_check(struct flash_bank_s *bank)
 {
 	int r;
-	uint32_t v;
+	uint32_t v=0;
 	unsigned x;
 	struct sam3_bank_private *pPrivate;
 

Modified: trunk/src/helper/jim.c
===================================================================
--- trunk/src/helper/jim.c	2009-09-22 15:39:23 UTC (rev 2748)
+++ trunk/src/helper/jim.c	2009-09-23 07:14:03 UTC (rev 2749)
@@ -3235,7 +3235,7 @@
             Jim_InitHashTable(cmdPtr->staticVars, getJimVariablesHashTableType(),
                     interp);
             for (i = 0; i < len; i++) {
-                Jim_Obj *objPtr, *initObjPtr, *nameObjPtr;
+                Jim_Obj *objPtr=NULL, *initObjPtr=NULL, *nameObjPtr=NULL;
                 Jim_Var *varPtr;
                 int subLen;
 
@@ -7739,7 +7739,7 @@
     int scanned = 1;
     const char *str = Jim_GetString(strObjPtr, 0);
     Jim_Obj *resultList = 0;
-    Jim_Obj **resultVec;
+    Jim_Obj **resultVec =NULL;
     int resultc;
     Jim_Obj *emptyStr = 0;
     ScanFmtStringObj *fmtObj;
@@ -8823,9 +8823,9 @@
     }
 
     for (i = 0; i < num_args; i++) {
-        Jim_Obj *argObjPtr;
-        Jim_Obj *nameObjPtr;
-        Jim_Obj *valueObjPtr;
+        Jim_Obj *argObjPtr=NULL;
+        Jim_Obj *nameObjPtr=NULL;
+        Jim_Obj *valueObjPtr=NULL;
 
         Jim_ListIndex(interp, cmd->argListObjPtr, i, &argObjPtr, JIM_NONE);
         if (i + 1 >= cmd->arityMin) {
@@ -8849,7 +8849,7 @@
     }
     /* Set optional arguments */
     if (cmd->arityMax == -1) {
-        Jim_Obj *listObjPtr, *objPtr;
+        Jim_Obj *listObjPtr=NULL, *objPtr=NULL;
 
         i++;
         listObjPtr = Jim_NewListObj(interp, argv + i, argc-i);
@@ -9421,7 +9421,7 @@
     Jim_HashEntry *he;
     Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
     const char *pattern;
-    int patternLen;
+    int patternLen=0;
 
     pattern = patternObjPtr ? Jim_GetString(patternObjPtr, &patternLen) : NULL;
     htiter = Jim_GetHashTableIterator(&interp->commands);
@@ -9447,7 +9447,7 @@
     Jim_HashEntry *he;
     Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
     const char *pattern;
-    int patternLen;
+    int patternLen=0;
 
     pattern = patternObjPtr ? Jim_GetString(patternObjPtr, &patternLen) : NULL;
     if (mode == JIM_VARLIST_GLOBALS) {
@@ -9816,7 +9816,7 @@
         exprLen = expr->len;
 
         if (exprLen == 1) {
-            jim_wide wideValue;
+            jim_wide wideValue=0;
 
             if (expr->opcode[0] == JIM_EXPROP_VARIABLE) {
                 varAObjPtr = expr->obj[0];
@@ -9856,7 +9856,7 @@
             if (varAObjPtr)
                 Jim_DecrRefCount(interp, varAObjPtr);
         } else if (exprLen == 3) {
-            jim_wide wideValueA, wideValueB, cmpRes = 0;
+            jim_wide wideValueA, wideValueB=0, cmpRes = 0;
             int cmpType = expr->opcode[2];
 
             varAObjPtr = expr->obj[0];
@@ -9983,7 +9983,7 @@
     {
         ScriptObj *initScript, *incrScript;
         ExprByteCode *expr;
-        jim_wide start, stop, currentVal;
+        jim_wide start, stop=0, currentVal;
         unsigned jim_wide procEpoch = interp->procEpoch;
         Jim_Obj *varNamePtr, *stopVarNamePtr = NULL, *objPtr;
         int cmpType;
@@ -11013,7 +11013,7 @@
     if (argListLen) {
         const char *str;
         int len;
-        Jim_Obj *argPtr;
+        Jim_Obj *argPtr=NULL;
 
         /* Check for 'args' and adjust arityMin and arityMax if necessary */
         Jim_ListIndex(interp, argv[2], argListLen-1, &argPtr, JIM_NONE);
@@ -11132,7 +11132,7 @@
     value = Jim_Alloc(sizeof(Jim_Obj*)*numMaps);
     resultObjPtr = Jim_NewStringObj(interp, "", 0);
     for (i = 0; i < numMaps; i++) {
-        Jim_Obj *eleObjPtr;
+        Jim_Obj *eleObjPtr=NULL;
 
         Jim_ListIndex(interp, mapListObjPtr, i*2, &eleObjPtr, JIM_NONE);
         key[i] = Jim_GetString(eleObjPtr, &keyLen[i]);
@@ -11855,7 +11855,7 @@
     resObjPtr = Jim_NewStringObj(interp, NULL, 0);
     /* Split */
     for (i = 0; i < listLen; i++) {
-        Jim_Obj *objPtr;
+        Jim_Obj *objPtr=NULL;
 
         Jim_ListIndex(interp, argv[1], i, &objPtr, JIM_NONE);
         Jim_AppendObj(interp, resObjPtr, objPtr);
@@ -12119,7 +12119,7 @@
 static int Jim_RandCoreCommand(Jim_Interp *interp, int argc,
         Jim_Obj *const *argv)
 {
-    jim_wide min = 0, max, len, maxMul;
+    jim_wide min = 0, max =0, len, maxMul;
 
     if (argc < 1 || argc > 3) {
         Jim_WrongNumArgs(interp, 1, argv, "?min? max");
@@ -12311,7 +12311,7 @@
             Jim_GetString(interp->result, NULL));
     Jim_ListLength(interp, interp->stackTrace, &len);
     for (i = len-3; i >= 0; i-= 3) {
-        Jim_Obj *objPtr;
+        Jim_Obj *objPtr=NULL;
         const char *proc, *file, *line;
 
         Jim_ListIndex(interp, interp->stackTrace, i, &objPtr, JIM_NONE);



From dbrownell at mail.berlios.de  Wed Sep 23 09:49:38 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Wed, 23 Sep 2009 09:49:38 +0200
Subject: [Openocd-svn] r2750 - trunk/src/target
Message-ID: <200909230749.n8N7ncY0019001@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-23 09:49:38 +0200 (Wed, 23 Sep 2009)
New Revision: 2750

Modified:
   trunk/src/target/etm.c
   trunk/src/target/etm.h
Log:
Initial ETM cleanups.  Most of these are cosmetic:

 - Add a header comment
 - Line up the ETM context struct, pack it a bit
 - Remove unused context_id (this doesn't support ETMv2 yet)
 - Make most functions static
 - Remove unused string table and other needless lines of code
 - Correct "tracemode" helptext

Also provide and use an etm_reg_lookup() to find entries in the ETM
register cache.  This will help cope with corrected contents of that
cache, which doesn't include entires for non-existent registers.


Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-09-23 07:14:03 UTC (rev 2749)
+++ trunk/src/target/etm.c	2009-09-23 07:49:38 UTC (rev 2750)
@@ -28,20 +28,28 @@
 #include "arm_disassembler.h"
 
 
-/* ETM register access functionality
+/*
+ * ARM "Embedded Trace Macrocell" (ETM) support -- direct JTAG access.
  *
+ * ETM modules collect instruction and/or data trace information, compress
+ * it, and transfer it to a debugging host through either a (buffered) trace
+ * port (often a 38-pin Mictor connector) or an Embedded Trace Buffer (ETB).
+ *
+ * There are several generations of these modules.  Original versions have
+ * JTAG access through a dedicated scan chain.  Recent versions have added
+ * access via coprocessor instructions, memory addressing, and the ARM Debug
+ * Interface v5 (ADIv5); and phased out direct JTAG access.
+ *
+ * This code supports up to the ETMv1.3 architecture, as seen in ETM9 and
+ * most common ARM9 systems.  Note: "CoreSight ETM9" implements ETMv3.2,
+ * implying non-JTAG connectivity options.
+ *
+ * Relevant documentation includes:
+ *  ARM DDI 0157G ... ETM9 (r2p2) Technical Reference Manual
+ *  ARM DDI 0315B ... CoreSight ETM9 (r0p1) Technical Reference Manual
+ *  ARM IHI 0014O ... Embedded Trace Macrocell, Architecture Specification
  */
 
-#if 0
-static bitfield_desc_t etm_comms_ctrl_bitfield_desc[] =
-{
-	{"R", 1},
-	{"W", 1},
-	{"reserved", 26},
-	{"version", 4}
-};
-#endif
-
 static int etm_reg_arch_info[] =
 {
 	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
@@ -196,11 +204,39 @@
 static int etm_reg_arch_type = -1;
 
 static int etm_get_reg(reg_t *reg);
+static int etm_read_reg_w_check(reg_t *reg,
+		uint8_t* check_value, uint8_t* check_mask);
+static int etm_register_user_commands(struct command_context_s *cmd_ctx);
+static int etm_set_reg_w_exec(reg_t *reg, uint8_t *buf);
+static int etm_write_reg(reg_t *reg, uint32_t value);
 
-static command_t *etm_cmd = NULL;
+static command_t *etm_cmd;
 
-reg_cache_t* etm_build_reg_cache(target_t *target, arm_jtag_t *jtag_info, etm_context_t *etm_ctx)
+
+/* Look up register by ID ... most ETM instances only
+ * support a subset of the possible registers.
+ */
+static reg_t *etm_reg_lookup(etm_context_t *etm_ctx, unsigned id)
 {
+	reg_cache_t *cache = etm_ctx->reg_cache;
+	int i;
+
+	for (i = 0; i < cache->num_regs; i++) {
+		struct etm_reg_s *reg = cache->reg_list[i].arch_info;
+
+		if (reg->addr == (int) id)
+			return &cache->reg_list[i];
+	}
+
+	/* caller asking for nonexistent register is a bug! */
+	/* REVISIT say which of the N targets was involved */
+	LOG_ERROR("ETM: register 0x%02x not available", id);
+	return NULL;
+}
+
+reg_cache_t *etm_build_reg_cache(target_t *target,
+		arm_jtag_t *jtag_info, etm_context_t *etm_ctx)
+{
 	reg_cache_t *reg_cache = malloc(sizeof(reg_cache_t));
 	reg_t *reg_list = NULL;
 	etm_reg_t *arch_info = NULL;
@@ -226,10 +262,6 @@
 	{
 		reg_list[i].name = etm_reg_list[i];
 		reg_list[i].size = 32;
-		reg_list[i].dirty = 0;
-		reg_list[i].valid = 0;
-		reg_list[i].bitfield_desc = NULL;
-		reg_list[i].num_bitfields = 0;
 		reg_list[i].value = calloc(1, 4);
 		reg_list[i].arch_info = &arch_info[i];
 		reg_list[i].arch_type = etm_reg_arch_type;
@@ -264,6 +296,16 @@
 	return reg_cache;
 }
 
+static int etm_read_reg(reg_t *reg)
+{
+	return etm_read_reg_w_check(reg, NULL, NULL);
+}
+
+static int etm_store_reg(reg_t *reg)
+{
+	return etm_write_reg(reg, buf_get_u32(reg->value, 0, reg->size));
+}
+
 int etm_setup(target_t *target)
 {
 	int retval;
@@ -271,8 +313,12 @@
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5->arch_info;
 	etm_context_t *etm_ctx = arm7_9->etm_ctx;
-	reg_t *etm_ctrl_reg = &arm7_9->etm_ctx->reg_cache->reg_list[ETM_CTRL];
+	reg_t *etm_ctrl_reg;
 
+	etm_ctrl_reg = etm_reg_lookup(etm_ctx, ETM_CTRL);
+	if (!etm_ctrl_reg)
+		return ERROR_OK;
+
 	/* initialize some ETM control register settings */
 	etm_get_reg(etm_ctrl_reg);
 	etm_ctrl_value = buf_get_u32(etm_ctrl_reg->value, 0, etm_ctrl_reg->size);
@@ -299,7 +345,7 @@
 	return ERROR_OK;
 }
 
-int etm_get_reg(reg_t *reg)
+static int etm_get_reg(reg_t *reg)
 {
 	int retval;
 
@@ -318,7 +364,8 @@
 	return ERROR_OK;
 }
 
-int etm_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask)
+static int etm_read_reg_w_check(reg_t *reg,
+		uint8_t* check_value, uint8_t* check_mask)
 {
 	etm_reg_t *etm_reg = reg->arch_info;
 	uint8_t reg_addr = etm_reg->addr & 0x7f;
@@ -367,13 +414,8 @@
 	return ERROR_OK;
 }
 
-int etm_read_reg(reg_t *reg)
+static int etm_set_reg(reg_t *reg, uint32_t value)
 {
-	return etm_read_reg_w_check(reg, NULL, NULL);
-}
-
-int etm_set_reg(reg_t *reg, uint32_t value)
-{
 	int retval;
 
 	if ((retval = etm_write_reg(reg, value)) != ERROR_OK)
@@ -389,7 +431,7 @@
 	return ERROR_OK;
 }
 
-int etm_set_reg_w_exec(reg_t *reg, uint8_t *buf)
+static int etm_set_reg_w_exec(reg_t *reg, uint8_t *buf)
 {
 	int retval;
 
@@ -403,7 +445,7 @@
 	return ERROR_OK;
 }
 
-int etm_write_reg(reg_t *reg, uint32_t value)
+static int etm_write_reg(reg_t *reg, uint32_t value)
 {
 	etm_reg_t *etm_reg = reg->arch_info;
 	uint8_t reg_addr = etm_reg->addr & 0x7f;
@@ -441,10 +483,6 @@
 	return ERROR_OK;
 }
 
-int etm_store_reg(reg_t *reg)
-{
-	return etm_write_reg(reg, buf_get_u32(reg->value, 0, reg->size));
-}
 
 /* ETM trace analysis functionality
  *
@@ -464,18 +502,6 @@
 	NULL
 };
 
-char *etmv1v1_branch_reason_strings[] =
-{
-	"normal PC change",
-	"tracing enabled",
-	"trace restarted after overflow",
-	"exit from debug",
-	"periodic synchronization",
-	"reserved",
-	"reserved",
-	"reserved",
-};
-
 static int etm_read_instruction(etm_context_t *ctx, arm_instruction_t *instruction)
 {
 	int i;
@@ -1172,8 +1198,12 @@
 	/* only update ETM_CTRL register if tracemode changed */
 	if (arm7_9->etm_ctx->tracemode != tracemode)
 	{
-		reg_t *etm_ctrl_reg = &arm7_9->etm_ctx->reg_cache->reg_list[ETM_CTRL];
+		reg_t *etm_ctrl_reg;
 
+		etm_ctrl_reg = etm_reg_lookup(arm7_9->etm_ctx, ETM_CTRL);
+		if (!etm_ctrl_reg)
+			return ERROR_OK;
+
 		etm_get_reg(etm_ctrl_reg);
 
 		buf_set_u32(etm_ctrl_reg->value, 2, 2, tracemode & ETMV1_TRACE_MASK);
@@ -1319,7 +1349,6 @@
 	etm_ctx->last_branch_reason = 0x0;
 	etm_ctx->last_ptr = 0x0;
 	etm_ctx->ptr_ok = 0x0;
-	etm_ctx->context_id = 0x0;
 	etm_ctx->last_instruction = 0;
 
 	arm7_9->etm_ctx = etm_ctx;
@@ -1327,7 +1356,8 @@
 	return etm_register_user_commands(cmd_ctx);
 }
 
-int handle_etm_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+static int handle_etm_info_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
 {
 	target_t *target;
 	armv4_5_common_t *armv4_5;
@@ -1351,8 +1381,12 @@
 		return ERROR_OK;
 	}
 
-	etm_config_reg = &arm7_9->etm_ctx->reg_cache->reg_list[ETM_CONFIG];
-	etm_sys_config_reg = &arm7_9->etm_ctx->reg_cache->reg_list[ETM_SYS_CONFIG];
+	etm_config_reg = etm_reg_lookup(arm7_9->etm_ctx, ETM_CONFIG);
+	if (!etm_config_reg)
+		return ERROR_OK;
+	etm_sys_config_reg = etm_reg_lookup(arm7_9->etm_ctx, ETM_SYS_CONFIG);
+	if (!etm_sys_config_reg)
+		return ERROR_OK;
 
 	etm_get_reg(etm_config_reg);
 	command_print(cmd_ctx, "pairs of address comparators: %i", (int)buf_get_u32(etm_config_reg->value, 0, 4));
@@ -1732,7 +1766,10 @@
 	}
 	arm7_9->etm_ctx->trace_depth = 0;
 
-	etm_ctrl_reg = &arm7_9->etm_ctx->reg_cache->reg_list[ETM_CTRL];
+	etm_ctrl_reg = etm_reg_lookup(etm_ctx, ETM_CTRL);
+	if (!etm_ctrl_reg)
+		return ERROR_OK;
+
 	etm_get_reg(etm_ctrl_reg);
 
 	/* Clear programming bit (10), set port selection bit (11) */
@@ -1768,7 +1805,10 @@
 		return ERROR_OK;
 	}
 
-	etm_ctrl_reg = &arm7_9->etm_ctx->reg_cache->reg_list[ETM_CTRL];
+	etm_ctrl_reg = etm_reg_lookup(etm_ctx, ETM_CTRL);
+	if (!etm_ctrl_reg)
+		return ERROR_OK;
+
 	etm_get_reg(etm_ctrl_reg);
 
 	/* Set programming bit (10), clear port selection bit (11) */
@@ -1835,10 +1875,11 @@
 	return ERROR_OK;
 }
 
-int etm_register_user_commands(struct command_context_s *cmd_ctx)
+static int etm_register_user_commands(struct command_context_s *cmd_ctx)
 {
 	register_command(cmd_ctx, etm_cmd, "tracemode", handle_etm_tracemode_command,
-		COMMAND_EXEC, "configure trace mode <none | data | address | all> "
+		COMMAND_EXEC, "configure/display trace mode: "
+			"<none | data | address | all> "
 			"<context_id_bits> <cycle_accurate> <branch_output>");
 
 	register_command(cmd_ctx, etm_cmd, "info", handle_etm_info_command,

Modified: trunk/src/target/etm.h
===================================================================
--- trunk/src/target/etm.h	2009-09-23 07:14:03 UTC (rev 2749)
+++ trunk/src/target/etm.h	2009-09-23 07:49:38 UTC (rev 2750)
@@ -139,29 +139,28 @@
  */
 typedef struct etm_context_s
 {
-	target_t *target;				/* target this ETM is connected to */
-	reg_cache_t *reg_cache;			/* ETM register cache */
+	target_t *target;		/* target this ETM is connected to */
+	reg_cache_t *reg_cache;		/* ETM register cache */
 	etm_capture_driver_t *capture_driver;	/* driver used to access ETM data */
-	void *capture_driver_priv;		/* capture driver private data */
-	uint32_t trigger_percent;			/* percent of trace buffer to be filled after the trigger */
+	void *capture_driver_priv;	/* capture driver private data */
+	uint32_t trigger_percent;	/* how much trace buffer to fill after trigger */
 	trace_status_t capture_status;	/* current state of capture run */
 	etmv1_trace_data_t *trace_data;	/* trace data */
-	uint32_t trace_depth;				/* number of trace cycles to be analyzed, 0 if no trace data available */
-	etm_portmode_t portmode;		/* normal, multiplexed or demultiplexed */
-	etmv1_tracemode_t tracemode;	/* type of information the trace contains (data, addres, contextID, ...) */
-	armv4_5_state_t core_state;		/* current core state (ARM, Thumb, Jazelle) */
-	struct image_s *image;					/* source for target opcodes */
-	uint32_t pipe_index;					/* current trace cycle */
-	uint32_t data_index;					/* cycle holding next data packet */
-	int data_half;					/* port half on a 16 bit port */
-	uint32_t current_pc;					/* current program counter */
-	uint32_t pc_ok;						/* full PC has been acquired */
-	uint32_t last_branch;				/* last branch address output */
-	uint32_t last_branch_reason;			/* branch reason code for the last branch encountered */
-	uint32_t last_ptr;					/* address of the last data access */
-	uint32_t ptr_ok;						/* whether last_ptr is valid */
-	uint32_t context_id;					/* context ID of the code being traced */
-	uint32_t last_instruction;			/* index of last instruction executed (to calculate cycle timings) */
+	uint32_t trace_depth;		/* number of cycles to be analyzed, 0 if no data available */
+	etm_portmode_t portmode;	/* normal, multiplexed or demultiplexed */
+	etmv1_tracemode_t tracemode;	/* type of info trace contains */
+	armv4_5_state_t core_state;	/* current core state */
+	struct image_s *image;		/* source for target opcodes */
+	uint32_t pipe_index;		/* current trace cycle */
+	uint32_t data_index;		/* cycle holding next data packet */
+	bool data_half;			/* port half on a 16 bit port */
+	bool pc_ok;			/* full PC has been acquired */
+	bool ptr_ok;			/* whether last_ptr is valid */
+	uint32_t current_pc;		/* current program counter */
+	uint32_t last_branch;		/* last branch address output */
+	uint32_t last_branch_reason;	/* type of last branch encountered */
+	uint32_t last_ptr;		/* address of the last data access */
+	uint32_t last_instruction;	/* index of last executed (to calc timings) */
 } etm_context_t;
 
 /* PIPESTAT values */
@@ -190,20 +189,10 @@
 	BR_RSVD7   = 0x7, /* reserved */
 } etmv1_branch_reason_t;
 
-extern char *etmv1v1_branch_reason_strings[];
-
 extern reg_cache_t* etm_build_reg_cache(target_t *target, arm_jtag_t *jtag_info, etm_context_t *etm_ctx);
-extern int etm_read_reg(reg_t *reg);
-extern int etm_write_reg(reg_t *reg, uint32_t value);
-extern int etm_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
-extern int etm_store_reg(reg_t *reg);
-extern int etm_set_reg(reg_t *reg, uint32_t value);
-extern int etm_set_reg_w_exec(reg_t *reg, uint8_t *buf);
 extern int etm_setup(target_t *target);
 
 int etm_register_commands(struct command_context_s *cmd_ctx);
-int etm_register_user_commands(struct command_context_s *cmd_ctx);
-extern etm_context_t* etm_create_context(etm_portmode_t portmode, char *capture_driver_name);
 
 #define ERROR_ETM_INVALID_DRIVER	(-1300)
 #define ERROR_ETM_PORTMODE_NOT_SUPPORTED	(-1301)



From dbrownell at mail.berlios.de  Wed Sep 23 11:16:01 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Wed, 23 Sep 2009 11:16:01 +0200
Subject: [Openocd-svn] r2751 - trunk/src/target
Message-ID: <200909230916.n8N9G16t029360@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-23 11:16:00 +0200 (Wed, 23 Sep 2009)
New Revision: 2751

Modified:
   trunk/src/target/etm.c
   trunk/src/target/etm.h
Log:
Start cleaning up ETM register handling.  On one ARM926 ETM+ETB
system, removes 20 non-existent registers ... but still includes
over 45 (!) ETM registers which don't even exist there ...

 - Integrate the various tables to get one struct per register
 - Get rid of needless per-register dynamic allocation
 - Double check list of registers:
    * Remove sixteen (!) non-registers for data comparators
    * Remove four registers that imply newer ETM than we support
    * Change some names to match current architecture specs
 - Handle more register info
    * some are write-only
    * some are read-only
    * record which versions have them, just in case
 - Reorganize the registers to facilitate removing the extras
    * group e.g. comparator/counter #N registers together
    * add and use lookup-by-ID


Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-09-23 07:49:38 UTC (rev 2750)
+++ trunk/src/target/etm.c	2009-09-23 09:16:00 UTC (rev 2751)
@@ -50,155 +50,145 @@
  *  ARM IHI 0014O ... Embedded Trace Macrocell, Architecture Specification
  */
 
-static int etm_reg_arch_info[] =
-{
-	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
-	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
-	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
-	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
-	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
-	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
-	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
-	0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
-	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
-	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
-	0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
-	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x67,
-	0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+#define ARRAY_SIZE(x)	((int)(sizeof(x)/sizeof((x)[0])))
+
+enum {
+	RO,				/* read/only */
+	WO,				/* write/only */
+	RW,				/* read/write */
 };
 
-static int etm_reg_arch_size_info[] =
-{
-	32, 32, 17, 8, 3, 9, 32, 16,
-	17, 26, 25, 8, 17, 32, 32, 17,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	7, 7, 7, 7, 7, 7, 7, 7,
-	7, 7, 7, 7, 7, 7, 7, 7,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	16, 16, 16, 16, 18, 18, 18, 18,
-	17, 17, 17, 17, 16, 16, 16, 16,
-	17, 17, 17, 17, 17, 17, 2,
-	17, 17, 17, 17, 32, 32, 32, 32
+struct etm_reg_info {
+	uint8_t		addr;
+	uint8_t		size;		/* low-N of 32 bits */
+	uint8_t		mode;		/* RO, WO, RW */
+	uint8_t		bcd_vers;	/* 1.0, 2.0, etc */
+	char		*name;
 };
 
-static char* etm_reg_list[] =
-{
-	"ETM_CTRL",
-	"ETM_CONFIG",
-	"ETM_TRIG_EVENT",
-	"ETM_MMD_CTRL",
-	"ETM_STATUS",
-	"ETM_SYS_CONFIG",
-	"ETM_TRACE_RESOURCE_CTRL",
-	"ETM_TRACE_EN_CTRL2",
-	"ETM_TRACE_EN_EVENT",
-	"ETM_TRACE_EN_CTRL1",
-	"ETM_FIFOFULL_REGION",
-	"ETM_FIFOFULL_LEVEL",
-	"ETM_VIEWDATA_EVENT",
-	"ETM_VIEWDATA_CTRL1",
-	"ETM_VIEWDATA_CTRL2",
-	"ETM_VIEWDATA_CTRL3",
-	"ETM_ADDR_COMPARATOR_VALUE1",
-	"ETM_ADDR_COMPARATOR_VALUE2",
-	"ETM_ADDR_COMPARATOR_VALUE3",
-	"ETM_ADDR_COMPARATOR_VALUE4",
-	"ETM_ADDR_COMPARATOR_VALUE5",
-	"ETM_ADDR_COMPARATOR_VALUE6",
-	"ETM_ADDR_COMPARATOR_VALUE7",
-	"ETM_ADDR_COMPARATOR_VALUE8",
-	"ETM_ADDR_COMPARATOR_VALUE9",
-	"ETM_ADDR_COMPARATOR_VALUE10",
-	"ETM_ADDR_COMPARATOR_VALUE11",
-	"ETM_ADDR_COMPARATOR_VALUE12",
-	"ETM_ADDR_COMPARATOR_VALUE13",
-	"ETM_ADDR_COMPARATOR_VALUE14",
-	"ETM_ADDR_COMPARATOR_VALUE15",
-	"ETM_ADDR_COMPARATOR_VALUE16",
-	"ETM_ADDR_ACCESS_TYPE1",
-	"ETM_ADDR_ACCESS_TYPE2",
-	"ETM_ADDR_ACCESS_TYPE3",
-	"ETM_ADDR_ACCESS_TYPE4",
-	"ETM_ADDR_ACCESS_TYPE5",
-	"ETM_ADDR_ACCESS_TYPE6",
-	"ETM_ADDR_ACCESS_TYPE7",
-	"ETM_ADDR_ACCESS_TYPE8",
-	"ETM_ADDR_ACCESS_TYPE9",
-	"ETM_ADDR_ACCESS_TYPE10",
-	"ETM_ADDR_ACCESS_TYPE11",
-	"ETM_ADDR_ACCESS_TYPE12",
-	"ETM_ADDR_ACCESS_TYPE13",
-	"ETM_ADDR_ACCESS_TYPE14",
-	"ETM_ADDR_ACCESS_TYPE15",
-	"ETM_ADDR_ACCESS_TYPE16",
-	"ETM_DATA_COMPARATOR_VALUE1",
-	"ETM_DATA_COMPARATOR_VALUE2",
-	"ETM_DATA_COMPARATOR_VALUE3",
-	"ETM_DATA_COMPARATOR_VALUE4",
-	"ETM_DATA_COMPARATOR_VALUE5",
-	"ETM_DATA_COMPARATOR_VALUE6",
-	"ETM_DATA_COMPARATOR_VALUE7",
-	"ETM_DATA_COMPARATOR_VALUE8",
-	"ETM_DATA_COMPARATOR_VALUE9",
-	"ETM_DATA_COMPARATOR_VALUE10",
-	"ETM_DATA_COMPARATOR_VALUE11",
-	"ETM_DATA_COMPARATOR_VALUE12",
-	"ETM_DATA_COMPARATOR_VALUE13",
-	"ETM_DATA_COMPARATOR_VALUE14",
-	"ETM_DATA_COMPARATOR_VALUE15",
-	"ETM_DATA_COMPARATOR_VALUE16",
-	"ETM_DATA_COMPARATOR_MASK1",
-	"ETM_DATA_COMPARATOR_MASK2",
-	"ETM_DATA_COMPARATOR_MASK3",
-	"ETM_DATA_COMPARATOR_MASK4",
-	"ETM_DATA_COMPARATOR_MASK5",
-	"ETM_DATA_COMPARATOR_MASK6",
-	"ETM_DATA_COMPARATOR_MASK7",
-	"ETM_DATA_COMPARATOR_MASK8",
-	"ETM_DATA_COMPARATOR_MASK9",
-	"ETM_DATA_COMPARATOR_MASK10",
-	"ETM_DATA_COMPARATOR_MASK11",
-	"ETM_DATA_COMPARATOR_MASK12",
-	"ETM_DATA_COMPARATOR_MASK13",
-	"ETM_DATA_COMPARATOR_MASK14",
-	"ETM_DATA_COMPARATOR_MASK15",
-	"ETM_DATA_COMPARATOR_MASK16",
-	"ETM_COUNTER_INITAL_VALUE1",
-	"ETM_COUNTER_INITAL_VALUE2",
-	"ETM_COUNTER_INITAL_VALUE3",
-	"ETM_COUNTER_INITAL_VALUE4",
-	"ETM_COUNTER_ENABLE1",
-	"ETM_COUNTER_ENABLE2",
-	"ETM_COUNTER_ENABLE3",
-	"ETM_COUNTER_ENABLE4",
-	"ETM_COUNTER_RELOAD_VALUE1",
-	"ETM_COUNTER_RELOAD_VALUE2",
-	"ETM_COUNTER_RELOAD_VALUE3",
-	"ETM_COUNTER_RELOAD_VALUE4",
-	"ETM_COUNTER_VALUE1",
-	"ETM_COUNTER_VALUE2",
-	"ETM_COUNTER_VALUE3",
-	"ETM_COUNTER_VALUE4",
-	"ETM_SEQUENCER_CTRL1",
-	"ETM_SEQUENCER_CTRL2",
-	"ETM_SEQUENCER_CTRL3",
-	"ETM_SEQUENCER_CTRL4",
-	"ETM_SEQUENCER_CTRL5",
-	"ETM_SEQUENCER_CTRL6",
-	"ETM_SEQUENCER_STATE",
-	"ETM_EXTERNAL_OUTPUT1",
-	"ETM_EXTERNAL_OUTPUT2",
-	"ETM_EXTERNAL_OUTPUT3",
-	"ETM_EXTERNAL_OUTPUT4",
-	"ETM_CONTEXTID_COMPARATOR_VALUE1",
-	"ETM_CONTEXTID_COMPARATOR_VALUE2",
-	"ETM_CONTEXTID_COMPARATOR_VALUE3",
-	"ETM_CONTEXTID_COMPARATOR_MASK"
+/*
+ * Registers 0..0x7f are JTAG-addressable using scanchain 6.
+ * Newer versions of ETM make some W/O registers R/W, and
+ * provide definitions for some previously-unused bits.
+ */
+static const struct etm_reg_info reg[] = {
+	/* ETM Trace Registers */
+	{ ETM_CTRL, 32, RW, 0x10, "ETM_CTRL", },
+	{ ETM_CONFIG, 32, RO, 0x10, "ETM_CONFIG", },
+	{ ETM_TRIG_EVENT, 17, WO, 0x10, "ETM_TRIG_EVENT", },
+	{ ETM_ASIC_CTRL,  8, WO, 0x10, "ETM_ASIC_CTRL", },
+	{ ETM_STATUS,  3, RO, 0x11, "ETM_STATUS", },
+	{ ETM_SYS_CONFIG,  9, RO, 0x12, "ETM_SYS_CONFIG", },
+
+	/* TraceEnable configuration */
+	{ ETM_TRACE_RESOURCE_CTRL, 32, WO, 0x12, "ETM_TRACE_RESOURCE_CTRL", },
+	{ ETM_TRACE_EN_CTRL2, 16, WO, 0x12, "ETM_TRACE_EN_CTRL2", },
+	{ ETM_TRACE_EN_EVENT, 17, WO, 0x10, "ETM_TRACE_EN_EVENT", },
+	{ ETM_TRACE_EN_CTRL1, 26, WO, 0x10, "ETM_TRACE_EN_CTRL1", },
+
+	/* FIFOFULL configuration */
+	{ ETM_FIFOFULL_REGION, 25, WO, 0x10, "ETM_FIFOFULL_REGION", },
+	{ ETM_FIFOFULL_LEVEL,  8, WO, 0x10, "ETM_FIFOFULL_LEVEL", },
+
+	/* ViewData configuration (data trace) */
+	{ ETM_VIEWDATA_EVENT, 17, WO, 0x10, "ETM_VIEWDATA_EVENT", },
+	{ ETM_VIEWDATA_CTRL1, 32, WO, 0x10, "ETM_VIEWDATA_CTRL1", },
+	{ ETM_VIEWDATA_CTRL2, 32, WO, 0x10, "ETM_VIEWDATA_CTRL2", },
+	{ ETM_VIEWDATA_CTRL3, 17, WO, 0x10, "ETM_VIEWDATA_CTRL3", },
+
+	/* Address comparator register pairs */
+#define ADDR_COMPARATOR(i) \
+		{ ETM_ADDR_COMPARATOR_VALUE + (i), 32, WO, 0x10, \
+				"ETM_ADDR_COMPARATOR_VALUE" #i, }, \
+		{ ETM_ADDR_ACCESS_TYPE + (i),  7, WO, 0x10, \
+				"ETM_ADDR_ACCESS_TYPE" #i, }
+	ADDR_COMPARATOR(0),
+	ADDR_COMPARATOR(1),
+	ADDR_COMPARATOR(2),
+	ADDR_COMPARATOR(3),
+	ADDR_COMPARATOR(4),
+	ADDR_COMPARATOR(5),
+	ADDR_COMPARATOR(6),
+	ADDR_COMPARATOR(7),
+
+	ADDR_COMPARATOR(8),
+	ADDR_COMPARATOR(9),
+	ADDR_COMPARATOR(10),
+	ADDR_COMPARATOR(11),
+	ADDR_COMPARATOR(12),
+	ADDR_COMPARATOR(13),
+	ADDR_COMPARATOR(14),
+	ADDR_COMPARATOR(15),
+#undef ADDR_COMPARATOR
+
+	/* Data Value Comparators (NOTE: odd addresses are reserved) */
+#define DATA_COMPARATOR(i) \
+		{ ETM_DATA_COMPARATOR_VALUE + 2*(i), 32, WO, 0x10, \
+				"ETM_DATA_COMPARATOR_VALUE" #i, }, \
+		{ ETM_DATA_COMPARATOR_MASK + 2*(i), 32, WO, 0x10, \
+				"ETM_DATA_COMPARATOR_MASK" #i, }
+	DATA_COMPARATOR(0),
+	DATA_COMPARATOR(1),
+	DATA_COMPARATOR(2),
+	DATA_COMPARATOR(3),
+	DATA_COMPARATOR(4),
+	DATA_COMPARATOR(5),
+	DATA_COMPARATOR(6),
+	DATA_COMPARATOR(7),
+#undef DATA_COMPARATOR
+
+	/* Counters */
+#define COUNTER(i) \
+		{ ETM_COUNTER_RELOAD_VALUE + (i), 16, WO, 0x10, \
+				"ETM_COUNTER_RELOAD_VALUE" #i, }, \
+		{ ETM_COUNTER_ENABLE + (i), 18, WO, 0x10, \
+				"ETM_COUNTER_ENABLE" #i, }, \
+		{ ETM_COUNTER_RELOAD_EVENT + (i), 17, WO, 0x10, \
+				"ETM_COUNTER_RELOAD_EVENT" #i, }, \
+		{ ETM_COUNTER_VALUE + (i), 16, RO, 0x10, \
+				"ETM_COUNTER_VALUE" #i, }
+	COUNTER(0),
+	COUNTER(1),
+	COUNTER(2),
+	COUNTER(3),
+#undef COUNTER
+
+	/* Sequencers */
+#define SEQ(i) \
+		{ ETM_SEQUENCER_EVENT + (i), 17, WO, 0x10, \
+				"ETM_SEQUENCER_EVENT" #i, }
+	SEQ(0),				/* 1->2 */
+	SEQ(1),				/* 2->1 */
+	SEQ(2),				/* 2->3 */
+	SEQ(3),				/* 3->1 */
+	SEQ(4),				/* 3->2 */
+	SEQ(5),				/* 1->3 */
+#undef SEQ
+	/* 0x66 reserved */
+	{ ETM_SEQUENCER_STATE,  2, RO, 0x10, "ETM_SEQUENCER_STATE", },
+
+#define OUT(i) \
+		{ ETM_EXTERNAL_OUTPUT + (i), 17, WO, 0x10, \
+				"ETM_EXTERNAL_OUTPUT" #i, }
+
+	OUT(0),
+	OUT(1),
+	OUT(2),
+	OUT(3),
+#undef OUT
+
+#if 0
+	/* registers from 0x6c..0x7f were added after ETMv1.3 */
+
+	/* Context ID Comparators */
+	{ 0x6c, 32, RO, 0x20, "ETM_CONTEXTID_COMPARATOR_VALUE1", }
+	{ 0x6d, 32, RO, 0x20, "ETM_CONTEXTID_COMPARATOR_VALUE1", }
+	{ 0x6e, 32, RO, 0x20, "ETM_CONTEXTID_COMPARATOR_VALUE1", }
+	{ 0x6f, 32, RO, 0x20, "ETM_CONTEXTID_COMPARATOR_MASK", }
+
+	{ 0x78, 12, WO, 0x20, "ETM_SYNC_FREQ", },
+	{ 0x79, 32, RO, 0x20, "ETM_ID", },
+#endif
 };
 
 static int etm_reg_arch_type = -1;
@@ -224,7 +214,7 @@
 	for (i = 0; i < cache->num_regs; i++) {
 		struct etm_reg_s *reg = cache->reg_list[i].arch_info;
 
-		if (reg->addr == (int) id)
+		if (reg->reg_info->addr == id)
 			return &cache->reg_list[i];
 	}
 
@@ -240,7 +230,7 @@
 	reg_cache_t *reg_cache = malloc(sizeof(reg_cache_t));
 	reg_t *reg_list = NULL;
 	etm_reg_t *arch_info = NULL;
-	int num_regs = sizeof(etm_reg_arch_info)/sizeof(int);
+	int num_regs = ARRAY_SIZE(reg);
 	int i;
 
 	/* register a register arch-type for etm registers only once */
@@ -260,13 +250,15 @@
 	/* set up registers */
 	for (i = 0; i < num_regs; i++)
 	{
-		reg_list[i].name = etm_reg_list[i];
-		reg_list[i].size = 32;
-		reg_list[i].value = calloc(1, 4);
+		const struct etm_reg_info *r = reg + i;
+
+		reg_list[i].name = r->name;
+		reg_list[i].size = r->size;
+		reg_list[i].value = &arch_info[i].value;
 		reg_list[i].arch_info = &arch_info[i];
 		reg_list[i].arch_type = etm_reg_arch_type;
-		reg_list[i].size = etm_reg_arch_size_info[i];
-		arch_info[i].addr = etm_reg_arch_info[i];
+
+		arch_info[i].reg_info = r;
 		arch_info[i].jtag_info = jtag_info;
 	}
 
@@ -278,10 +270,6 @@
 		if (!etb)
 		{
 			LOG_ERROR("etb selected as etm capture driver, but no ETB configured");
-			for (i = 0; i < num_regs; i++)
-			{
-				free(reg_list[i].value);
-			}
 			free(reg_cache);
 			free(arch_info);
 			return ERROR_OK;
@@ -368,11 +356,17 @@
 		uint8_t* check_value, uint8_t* check_mask)
 {
 	etm_reg_t *etm_reg = reg->arch_info;
-	uint8_t reg_addr = etm_reg->addr & 0x7f;
+	const struct etm_reg_info *r = etm_reg->reg_info;
+	uint8_t reg_addr = r->addr & 0x7f;
 	scan_field_t fields[3];
 
-	LOG_DEBUG("%i", etm_reg->addr);
+	if (etm_reg->reg_info->mode == WO) {
+		LOG_ERROR("BUG: can't read write-only register %s", r->name);
+		return ERROR_INVALID_ARGUMENTS;
+	}
 
+	LOG_DEBUG("%s (%u)", r->name, reg_addr);
+
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(etm_reg->jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL);
@@ -448,11 +442,17 @@
 static int etm_write_reg(reg_t *reg, uint32_t value)
 {
 	etm_reg_t *etm_reg = reg->arch_info;
-	uint8_t reg_addr = etm_reg->addr & 0x7f;
+	const struct etm_reg_info *r = etm_reg->reg_info;
+	uint8_t reg_addr = r->addr & 0x7f;
 	scan_field_t fields[3];
 
-	LOG_DEBUG("%i: 0x%8.8" PRIx32 "", etm_reg->addr, value);
+	if (etm_reg->reg_info->mode == RO) {
+		LOG_ERROR("BUG: can't write read--only register %s", r->name);
+		return ERROR_INVALID_ARGUMENTS;
+	}
 
+	LOG_DEBUG("%s (%u): 0x%8.8" PRIx32 "", r->name, reg_addr, value);
+
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(etm_reg->jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg->jtag_info, etm_reg->jtag_info->intest_instr, NULL);

Modified: trunk/src/target/etm.h
===================================================================
--- trunk/src/target/etm.h	2009-09-23 07:49:38 UTC (rev 2750)
+++ trunk/src/target/etm.h	2009-09-23 09:16:00 UTC (rev 2751)
@@ -29,43 +29,52 @@
 
 struct image_s;
 
-/* ETM registers (V1.3 protocol) */
+/* ETM registers (JTAG protocol) */
 enum
 {
 	ETM_CTRL = 0x00,
 	ETM_CONFIG = 0x01,
 	ETM_TRIG_EVENT = 0x02,
-	ETM_MMD_CTRL = 0x03,
+	ETM_ASIC_CTRL = 0x03,
 	ETM_STATUS = 0x04,
 	ETM_SYS_CONFIG = 0x05,
 	ETM_TRACE_RESOURCE_CTRL = 0x06,
 	ETM_TRACE_EN_CTRL2 = 0x07,
 	ETM_TRACE_EN_EVENT = 0x08,
 	ETM_TRACE_EN_CTRL1 = 0x09,
+	/* optional FIFOFULL */
 	ETM_FIFOFULL_REGION = 0x0a,
 	ETM_FIFOFULL_LEVEL = 0x0b,
+	/* viewdata support */
 	ETM_VIEWDATA_EVENT = 0x0c,
 	ETM_VIEWDATA_CTRL1 = 0x0d,
-	ETM_VIEWDATA_CTRL2 = 0x0e,
+	ETM_VIEWDATA_CTRL2 = 0x0e,	/* optional */
 	ETM_VIEWDATA_CTRL3 = 0x0f,
+	/* N pairs of ADDR_{COMPARATOR,ACCESS} registers */
 	ETM_ADDR_COMPARATOR_VALUE = 0x10,
 	ETM_ADDR_ACCESS_TYPE = 0x20,
+	/* N pairs of DATA_COMPARATOR_{VALUE,MASK} registers */
 	ETM_DATA_COMPARATOR_VALUE = 0x30,
 	ETM_DATA_COMPARATOR_MASK = 0x40,
-	ETM_COUNTER_INITAL_VALUE = 0x50,
+	/* N quads of COUNTER_{RELOAD_{VALUE,EVENT},ENABLE,VALUE} registers */
+	ETM_COUNTER_RELOAD_VALUE = 0x50,
 	ETM_COUNTER_ENABLE = 0x54,
-	ETM_COUNTER_RELOAD_VALUE = 0x58,
+	ETM_COUNTER_RELOAD_EVENT = 0x58,
 	ETM_COUNTER_VALUE = 0x5c,
-	ETM_SEQUENCER_CTRL = 0x60,
+	/* 6 sequencer event transitions */
+	ETM_SEQUENCER_EVENT = 0x60,
 	ETM_SEQUENCER_STATE = 0x67,
+	/* N triggered outputs */
 	ETM_EXTERNAL_OUTPUT = 0x68,
+	/* N task contexts */
 	ETM_CONTEXTID_COMPARATOR_VALUE = 0x6c,
 	ETM_CONTEXTID_COMPARATOR_MASK = 0x6f,
 };
 
 typedef struct etm_reg_s
 {
-	int addr;
+	uint32_t value;
+	const struct etm_reg_info *reg_info;
 	arm_jtag_t *jtag_info;
 } etm_reg_t;
 



From dbrownell at mail.berlios.de  Wed Sep 23 23:52:40 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Wed, 23 Sep 2009 23:52:40 +0200
Subject: [Openocd-svn] r2752 - in trunk: doc src/target
Message-ID: <200909232152.n8NLqeNk009480@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-23 23:52:40 +0200 (Wed, 23 Sep 2009)
New Revision: 2752

Modified:
   trunk/doc/openocd.texi
   trunk/src/target/etm.c
   trunk/src/target/etm.h
Log:
When setting up an ETM, cache its ETM_CONFIG register.  Then
only expose the registers which are actually present.  They
could be missing for two basic reasons:

 - This version might not support them at all; e.g. ETMv1.1
   doesn't have some control/status registers.  (My sample of
   ARM9 boards shows all with ETMv1.3 support, FWIW.)

 - The configuration on this chip may not populate as many
   registers as possible; e.g. only two data value comparators
   instead of eight.

Includes a bugfix in the "etm info" command:  only one of the
two registers is missing on older silicon, so show the first
one before bailing.

Update ETM usage docs to explain that those registers need to be
written to configure what is traced, and that some ETM configs
are not yet handled.  Also, give some examples of the kinds of
constrained trace which could be arranged.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-23 09:16:00 UTC (rev 2751)
+++ trunk/doc/openocd.texi	2009-09-23 21:52:40 UTC (rev 2752)
@@ -4807,6 +4807,10 @@
 It's unclear how much of a common interface is shared
 with the current XScale trace support, or should be
 shared with eventual Nexus-style trace module support.
+At this writing (September 2009) only ARM7 and ARM9 support
+for ETM modules is available.  The code should be able to
+work with some newer cores; but not all of them support
+this original style of JTAG access.
 @end quotation
 
 @subsection ETM Configuration
@@ -4823,8 +4827,10 @@
 The @var{clocking} must be @option{half} or @option{full}.
 
 @quotation Note
-You can see the ETM registers using the @command{reg} command, although
-not all of those possible registers are present in every ETM.
+You can see the ETM registers using the @command{reg} command.
+Not all possible registers are present in every ETM.
+Most of the registers are write-only, and are used to configure
+what CPU activities are traced.
 @end quotation
 @end deffn
 
@@ -4867,6 +4873,36 @@
 That data can be exported to files for later analysis.
 It can also be parsed with OpenOCD, for basic sanity checking.
 
+To configure what is being traced, you will need to write
+various trace registers using @command{reg ETM_*} commands.
+For the definitions of these registers, read ARM publication
+ at emph{IHI 0014, ``Embedded Trace Macrocell, Architecture Specification''}.
+Be aware that most of the relevant registers are write-only,
+and that ETM resources are limited.  There are only a handful
+of address comparators, data comparators, counters, and so on.
+
+Examples of scenarios you might arrange to trace include:
+
+ at itemize
+ at item Code flow within a function, @emph{excluding} subroutines
+it calls.  Use address range comparators to enable tracing
+for instruction access within that function's body.
+ at item Code flow within a function, @emph{including} subroutines
+it calls.  Use the sequencer and address comparators to activate
+tracing on an ``entered function'' state, then deactivate it by
+exiting that state when the function's exit code is invoked.
+ at item Code flow starting at the fifth invocation of a function,
+combining one of the above models with a counter.
+ at item CPU data accesses to the registers for a particular device,
+using address range comparators and the ViewData logic.
+ at item Such data accesses only during IRQ handling, combining the above
+model with sequencer triggers which on entry and exit to the IRQ handler.
+ at item @emph{... more}
+ at end itemize
+
+At this writing, September 2009, there are no Tcl utility
+procedures to help set up any common tracing scenarios.
+
 @deffn Command {etm analyze}
 Reads trace data into memory, if it wasn't already present.
 Decodes and prints the data that was collected.

Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-09-23 09:16:00 UTC (rev 2751)
+++ trunk/src/target/etm.c	2009-09-23 21:52:40 UTC (rev 2752)
@@ -71,10 +71,14 @@
  * Newer versions of ETM make some W/O registers R/W, and
  * provide definitions for some previously-unused bits.
  */
-static const struct etm_reg_info reg[] = {
+
+/* basic registers that are always there given the right ETM version */
+static const struct etm_reg_info etm_core[] = {
+	/* NOTE: we "know" ETM_CONFIG is listed first */
+	{ ETM_CONFIG, 32, RO, 0x10, "ETM_CONFIG", },
+
 	/* ETM Trace Registers */
 	{ ETM_CTRL, 32, RW, 0x10, "ETM_CTRL", },
-	{ ETM_CONFIG, 32, RO, 0x10, "ETM_CONFIG", },
 	{ ETM_TRIG_EVENT, 17, WO, 0x10, "ETM_TRIG_EVENT", },
 	{ ETM_ASIC_CTRL,  8, WO, 0x10, "ETM_ASIC_CTRL", },
 	{ ETM_STATUS,  3, RO, 0x11, "ETM_STATUS", },
@@ -86,16 +90,25 @@
 	{ ETM_TRACE_EN_EVENT, 17, WO, 0x10, "ETM_TRACE_EN_EVENT", },
 	{ ETM_TRACE_EN_CTRL1, 26, WO, 0x10, "ETM_TRACE_EN_CTRL1", },
 
-	/* FIFOFULL configuration */
-	{ ETM_FIFOFULL_REGION, 25, WO, 0x10, "ETM_FIFOFULL_REGION", },
-	{ ETM_FIFOFULL_LEVEL,  8, WO, 0x10, "ETM_FIFOFULL_LEVEL", },
-
 	/* ViewData configuration (data trace) */
 	{ ETM_VIEWDATA_EVENT, 17, WO, 0x10, "ETM_VIEWDATA_EVENT", },
 	{ ETM_VIEWDATA_CTRL1, 32, WO, 0x10, "ETM_VIEWDATA_CTRL1", },
 	{ ETM_VIEWDATA_CTRL2, 32, WO, 0x10, "ETM_VIEWDATA_CTRL2", },
 	{ ETM_VIEWDATA_CTRL3, 17, WO, 0x10, "ETM_VIEWDATA_CTRL3", },
 
+	/* REVISIT exclude VIEWDATA_CTRL2 when it's not there */
+
+	{ 0x78, 12, WO, 0x20, "ETM_SYNC_FREQ", },
+	{ 0x79, 32, RO, 0x20, "ETM_ID", },
+};
+
+static const struct etm_reg_info etm_fifofull[] = {
+	/* FIFOFULL configuration */
+	{ ETM_FIFOFULL_REGION, 25, WO, 0x10, "ETM_FIFOFULL_REGION", },
+	{ ETM_FIFOFULL_LEVEL,  8, WO, 0x10, "ETM_FIFOFULL_LEVEL", },
+};
+
+static const struct etm_reg_info etm_addr_comp[] = {
 	/* Address comparator register pairs */
 #define ADDR_COMPARATOR(i) \
 		{ ETM_ADDR_COMPARATOR_VALUE + (i), 32, WO, 0x10, \
@@ -120,7 +133,9 @@
 	ADDR_COMPARATOR(14),
 	ADDR_COMPARATOR(15),
 #undef ADDR_COMPARATOR
+};
 
+static const struct etm_reg_info etm_data_comp[] = {
 	/* Data Value Comparators (NOTE: odd addresses are reserved) */
 #define DATA_COMPARATOR(i) \
 		{ ETM_DATA_COMPARATOR_VALUE + 2*(i), 32, WO, 0x10, \
@@ -136,8 +151,9 @@
 	DATA_COMPARATOR(6),
 	DATA_COMPARATOR(7),
 #undef DATA_COMPARATOR
+};
 
-	/* Counters */
+static const struct etm_reg_info etm_counters[] = {
 #define COUNTER(i) \
 		{ ETM_COUNTER_RELOAD_VALUE + (i), 16, WO, 0x10, \
 				"ETM_COUNTER_RELOAD_VALUE" #i, }, \
@@ -152,8 +168,9 @@
 	COUNTER(2),
 	COUNTER(3),
 #undef COUNTER
+};
 
-	/* Sequencers */
+static const struct etm_reg_info etm_sequencer[] = {
 #define SEQ(i) \
 		{ ETM_SEQUENCER_EVENT + (i), 17, WO, 0x10, \
 				"ETM_SEQUENCER_EVENT" #i, }
@@ -166,7 +183,9 @@
 #undef SEQ
 	/* 0x66 reserved */
 	{ ETM_SEQUENCER_STATE,  2, RO, 0x10, "ETM_SEQUENCER_STATE", },
+};
 
+static const struct etm_reg_info etm_outputs[] = {
 #define OUT(i) \
 		{ ETM_EXTERNAL_OUTPUT + (i), 17, WO, 0x10, \
 				"ETM_EXTERNAL_OUTPUT" #i, }
@@ -176,6 +195,7 @@
 	OUT(2),
 	OUT(3),
 #undef OUT
+};
 
 #if 0
 	/* registers from 0x6c..0x7f were added after ETMv1.3 */
@@ -185,11 +205,7 @@
 	{ 0x6d, 32, RO, 0x20, "ETM_CONTEXTID_COMPARATOR_VALUE1", }
 	{ 0x6e, 32, RO, 0x20, "ETM_CONTEXTID_COMPARATOR_VALUE1", }
 	{ 0x6f, 32, RO, 0x20, "ETM_CONTEXTID_COMPARATOR_MASK", }
-
-	{ 0x78, 12, WO, 0x20, "ETM_SYNC_FREQ", },
-	{ 0x79, 32, RO, 0x20, "ETM_ID", },
 #endif
-};
 
 static int etm_reg_arch_type = -1;
 
@@ -224,44 +240,138 @@
 	return NULL;
 }
 
+static void etm_reg_add(unsigned bcd_vers, arm_jtag_t *jtag_info,
+		reg_cache_t *cache, etm_reg_t *ereg,
+		const struct etm_reg_info *r, unsigned nreg)
+{
+	reg_t *reg = cache->reg_list;
+
+	reg += cache->num_regs;
+	ereg += cache->num_regs;
+
+	/* add up to "nreg" registers from "r", if supported by this
+	 * version of the ETM, to the specified cache.
+	 */
+	for (; nreg--; r++) {
+
+		/* this ETM may be too old to have some registers */
+		if (r->bcd_vers > bcd_vers)
+			continue;
+
+		reg->name = r->name;
+		reg->size = r->size;
+		reg->value = &ereg->value;
+		reg->arch_info = ereg;
+		reg->arch_type = etm_reg_arch_type;
+		reg++;
+		cache->num_regs++;
+
+		ereg->reg_info = r;
+		ereg->jtag_info = jtag_info;
+		ereg++;
+	}
+}
+
 reg_cache_t *etm_build_reg_cache(target_t *target,
 		arm_jtag_t *jtag_info, etm_context_t *etm_ctx)
 {
 	reg_cache_t *reg_cache = malloc(sizeof(reg_cache_t));
 	reg_t *reg_list = NULL;
 	etm_reg_t *arch_info = NULL;
-	int num_regs = ARRAY_SIZE(reg);
-	int i;
+	unsigned bcd_vers, config;
 
 	/* register a register arch-type for etm registers only once */
 	if (etm_reg_arch_type == -1)
-		etm_reg_arch_type = register_reg_arch_type(etm_get_reg, etm_set_reg_w_exec);
+		etm_reg_arch_type = register_reg_arch_type(etm_get_reg,
+				etm_set_reg_w_exec);
 
 	/* the actual registers are kept in two arrays */
-	reg_list = calloc(num_regs, sizeof(reg_t));
-	arch_info = calloc(num_regs, sizeof(etm_reg_t));
+	reg_list = calloc(128, sizeof(reg_t));
+	arch_info = calloc(128, sizeof(etm_reg_t));
 
 	/* fill in values for the reg cache */
 	reg_cache->name = "etm registers";
 	reg_cache->next = NULL;
 	reg_cache->reg_list = reg_list;
-	reg_cache->num_regs = num_regs;
+	reg_cache->num_regs = 0;
 
-	/* set up registers */
-	for (i = 0; i < num_regs; i++)
-	{
-		const struct etm_reg_info *r = reg + i;
+	/* add ETM_CONFIG, then parse its values to see
+	 * which other registers exist in this ETM
+	 */
+	etm_reg_add(0x10, jtag_info, reg_cache, arch_info,
+			etm_core, 1);
 
-		reg_list[i].name = r->name;
-		reg_list[i].size = r->size;
-		reg_list[i].value = &arch_info[i].value;
-		reg_list[i].arch_info = &arch_info[i];
-		reg_list[i].arch_type = etm_reg_arch_type;
+	etm_get_reg(reg_list);
+	etm_ctx->config = buf_get_u32((void *)&arch_info->value, 0, 32);
+	config = etm_ctx->config;
 
-		arch_info[i].reg_info = r;
-		arch_info[i].jtag_info = jtag_info;
+	/* figure ETM version then add base registers */
+	if (config & (1 << 31)) {
+		bcd_vers = 0x20;
+		LOG_WARNING("ETMv2+ support is incomplete");
+
+		/* REVISIT read ID register, distinguish ETMv3.3 etc;
+		 * don't presume trace start/stop support is present;
+		 * and include any context ID comparator registers.
+		 */
+	} else {
+		switch (config >> 28) {
+		case 7:
+		case 5:
+		case 3:
+			bcd_vers = 0x13;
+			break;
+		case 4:
+		case 2:
+			bcd_vers = 0x12;
+			break;
+		case 1:
+			bcd_vers = 0x11;
+			break;
+		case 0:
+			bcd_vers = 0x10;
+			break;
+		default:
+			LOG_WARNING("Bad ETMv1 protocol %d", config >> 28);
+			free(reg_cache);
+			free(reg_list);
+			free(arch_info);
+			return ERROR_OK;
+		}
 	}
+	etm_ctx->bcd_vers = bcd_vers;
+	LOG_INFO("ETM v%d.%d", bcd_vers >> 4, bcd_vers & 0xf);
 
+	etm_reg_add(bcd_vers, jtag_info, reg_cache, arch_info,
+			etm_core + 1, ARRAY_SIZE(etm_core) - 1);
+
+	/* address and data comparators; counters; outputs */
+	etm_reg_add(bcd_vers, jtag_info, reg_cache, arch_info,
+			etm_addr_comp, 4 * (0x0f & (config >> 0)));
+	etm_reg_add(bcd_vers, jtag_info, reg_cache, arch_info,
+			etm_data_comp, 2 * (0x0f & (config >> 4)));
+	etm_reg_add(bcd_vers, jtag_info, reg_cache, arch_info,
+			etm_counters, 4 * (0x07 & (config >> 13)));
+	etm_reg_add(bcd_vers, jtag_info, reg_cache, arch_info,
+			etm_outputs, (0x07 & (config >> 20)));
+
+	/* FIFOFULL presence is optional
+	 * REVISIT for ETMv1.2 and later, don't bother adding this
+	 * unless ETM_SYS_CONFIG says it's also *supported* ...
+	 */
+	if (config & (1 << 23))
+		etm_reg_add(bcd_vers, jtag_info, reg_cache, arch_info,
+				etm_fifofull, ARRAY_SIZE(etm_fifofull));
+
+	/* sequencer is optional (for state-dependant triggering) */
+	if (config & (1 << 16))
+		etm_reg_add(bcd_vers, jtag_info, reg_cache, arch_info,
+				etm_sequencer, ARRAY_SIZE(etm_sequencer));
+
+	/* REVISIT could realloc and likely save half the memory
+	 * in the two chunks we allocated...
+	 */
+
 	/* the ETM might have an ETB connected */
 	if (strcmp(etm_ctx->capture_driver->name, "etb") == 0)
 	{
@@ -271,6 +381,7 @@
 		{
 			LOG_ERROR("etb selected as etm capture driver, but no ETB configured");
 			free(reg_cache);
+			free(reg_list);
 			free(arch_info);
 			return ERROR_OK;
 		}
@@ -1362,7 +1473,7 @@
 	target_t *target;
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
-	reg_t *etm_config_reg;
+	etm_context_t *etm;
 	reg_t *etm_sys_config_reg;
 
 	int max_port_size;
@@ -1375,32 +1486,46 @@
 		return ERROR_OK;
 	}
 
-	if (!arm7_9->etm_ctx)
+	etm = arm7_9->etm_ctx;
+	if (!etm)
 	{
 		command_print(cmd_ctx, "current target doesn't have an ETM configured");
 		return ERROR_OK;
 	}
 
-	etm_config_reg = etm_reg_lookup(arm7_9->etm_ctx, ETM_CONFIG);
-	if (!etm_config_reg)
-		return ERROR_OK;
-	etm_sys_config_reg = etm_reg_lookup(arm7_9->etm_ctx, ETM_SYS_CONFIG);
+	command_print(cmd_ctx, "ETM v%d.%d",
+			etm->bcd_vers >> 4, etm->bcd_vers & 0xf);
+	command_print(cmd_ctx, "pairs of address comparators: %i",
+			(etm->config >> 0) & 0x0f);
+	command_print(cmd_ctx, "data comparators: %i",
+			(etm->config >> 4) & 0x0f);
+	command_print(cmd_ctx, "memory map decoders: %i",
+			(etm->config >> 8) & 0x1f);
+	command_print(cmd_ctx, "number of counters: %i",
+			(etm->config >> 13) & 0x07);
+	command_print(cmd_ctx, "sequencer %spresent",
+			(etm->config & (1 << 16)) ? "" : "not ");
+	command_print(cmd_ctx, "number of ext. inputs: %i",
+			(etm->config >> 17) & 0x07);
+	command_print(cmd_ctx, "number of ext. outputs: %i",
+			(etm->config >> 20) & 0x07);
+	command_print(cmd_ctx, "FIFO full %spresent",
+			(etm->config & (1 << 23)) ? "" : "not ");
+	if (etm->bcd_vers < 0x20)
+		command_print(cmd_ctx, "protocol version: %i",
+				(etm->config >> 28) & 0x07);
+	else {
+		command_print(cmd_ctx, "trace start/stop %spresent",
+				(etm->config & (1 << 26)) ? "" : "not ");
+		command_print(cmd_ctx, "number of context comparators: %i",
+				(etm->config >> 24) & 0x03);
+	}
+
+	/* SYS_CONFIG isn't present before ETMv1.2 */
+	etm_sys_config_reg = etm_reg_lookup(etm, ETM_SYS_CONFIG);
 	if (!etm_sys_config_reg)
 		return ERROR_OK;
 
-	etm_get_reg(etm_config_reg);
-	command_print(cmd_ctx, "pairs of address comparators: %i", (int)buf_get_u32(etm_config_reg->value, 0, 4));
-	command_print(cmd_ctx, "pairs of data comparators: %i", (int)buf_get_u32(etm_config_reg->value, 4, 4));
-	command_print(cmd_ctx, "memory map decoders: %i", (int)buf_get_u32(etm_config_reg->value, 8, 5));
-	command_print(cmd_ctx, "number of counters: %i", (int)buf_get_u32(etm_config_reg->value, 13, 3));
-	command_print(cmd_ctx, "sequencer %spresent",
-			(buf_get_u32(etm_config_reg->value, 16, 1) == 1) ? "" : "not ");
-	command_print(cmd_ctx, "number of ext. inputs: %i", (int)buf_get_u32(etm_config_reg->value, 17, 3));
-	command_print(cmd_ctx, "number of ext. outputs: %i",(int) buf_get_u32(etm_config_reg->value, 20, 3));
-	command_print(cmd_ctx, "FIFO full %spresent",
-			(buf_get_u32(etm_config_reg->value, 23, 1) == 1) ? "" : "not ");
-	command_print(cmd_ctx, "protocol version: %i", (int)buf_get_u32(etm_config_reg->value, 28, 3));
-
 	etm_get_reg(etm_sys_config_reg);
 
 	switch (buf_get_u32(etm_sys_config_reg->value, 0, 3))

Modified: trunk/src/target/etm.h
===================================================================
--- trunk/src/target/etm.h	2009-09-23 09:16:00 UTC (rev 2751)
+++ trunk/src/target/etm.h	2009-09-23 21:52:40 UTC (rev 2752)
@@ -165,6 +165,8 @@
 	bool data_half;			/* port half on a 16 bit port */
 	bool pc_ok;			/* full PC has been acquired */
 	bool ptr_ok;			/* whether last_ptr is valid */
+	uint8_t bcd_vers;		/* e.g. 0x13 == ETMv1.3 */
+	uint32_t config;		/* cache of ETM_CONFIG value */
 	uint32_t current_pc;		/* current program counter */
 	uint32_t last_branch;		/* last branch address output */
 	uint32_t last_branch_reason;	/* type of last branch encountered */



From dbrownell at mail.berlios.de  Thu Sep 24 00:03:41 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Thu, 24 Sep 2009 00:03:41 +0200
Subject: [Openocd-svn] r2753 - trunk/src/helper
Message-ID: <200909232203.n8NM3fwE010255@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-24 00:03:41 +0200 (Thu, 24 Sep 2009)
New Revision: 2753

Modified:
   trunk/src/helper/startup.tcl
Log:
Start handling the (second) SRST stage of reset better:
make sure that when there are two or more targets, their
various pre/post event reports are correctly ordered.

Previously, only the first target always saw its "pre"
method before SRST was asserted or deasserted.


Modified: trunk/src/helper/startup.tcl
===================================================================
--- trunk/src/helper/startup.tcl	2009-09-23 21:52:40 UTC (rev 2752)
+++ trunk/src/helper/startup.tcl	2009-09-23 22:03:41 UTC (rev 2753)
@@ -202,27 +202,32 @@
 	}
 
 	# Assert SRST, and report the pre/post events.
-	#
-	# REVISIT this presumes a single-target config, since SRST
-	# applies to the whole device-under-test.  When two targets
-	# both need special setup before SRST, it's only done for
-	# the first one...
+	# Note:  no target sees SRST before "pre" or after "post".
 	foreach t $targets {
 		$t invoke-event reset-assert-pre
+	}
+	foreach t $targets {
 		# C code needs to know if we expect to 'halt'
 		if {[jtag tapisenabled [$t cget -chain-position]]} {
 			$t arp_reset assert $halt
 		}
+	}
+	foreach t $targets {
 		$t invoke-event reset-assert-post
 	}
 
 	# Now de-assert SRST, and report the pre/post events.
+	# Note:  no target sees !SRST before "pre" or after "post".
 	foreach t $targets {
 		$t invoke-event reset-deassert-pre
-		# Again, de-assert code needs to know..
+	}
+	foreach t $targets {
+		# Again, de-assert code needs to know if we 'halt'
 		if {[jtag tapisenabled [$t cget -chain-position]]} {
 			$t arp_reset deassert $halt
 		}
+	}
+	foreach t $targets {
 		$t invoke-event reset-deassert-post
 	}
 



From oharboe at mail.berlios.de  Thu Sep 24 08:34:25 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Thu, 24 Sep 2009 08:34:25 +0200
Subject: [Openocd-svn] r2754 - trunk/src/server
Message-ID: <200909240634.n8O6YPxj027134@sheep.berlios.de>

Author: oharboe
Date: 2009-09-24 08:34:23 +0200 (Thu, 24 Sep 2009)
New Revision: 2754

Modified:
   trunk/src/server/gdb_server.c
   trunk/src/server/gdb_server.h
Log:
When attaching GDB to OpenOCD, the target state is no longer affected.
Added gdb_sync feature that allows GDB to sync up to target state.
Issue "monitor gdb_sync" and the next stepi, will return immediately
with updated register values to GDB.


Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-09-23 22:03:41 UTC (rev 2753)
+++ trunk/src/server/gdb_server.c	2009-09-24 06:34:23 UTC (rev 2754)
@@ -40,6 +40,8 @@
 #define _DEBUG_GDB_IO_
 #endif
 
+static gdb_connection_t *current_gdb_connection;
+
 static int gdb_breakpoint_override;
 static enum breakpoint_type gdb_breakpoint_override_type;
 
@@ -750,6 +752,7 @@
 	gdb_connection->closed = 0;
 	gdb_connection->busy = 0;
 	gdb_connection->noack_mode = 0;
+	gdb_connection->sync = true;
 
 	/* send ACK to GDB for debug request */
 	gdb_write(connection, "+", 1);
@@ -767,30 +770,6 @@
 	/* register callback to be informed about target events */
 	target_register_event_callback(gdb_target_callback_event_handler, connection);
 
-	/* a gdb session just attached, try to put the target in halt mode.
-	 *
-	 * DANGER!!!!
-	 *
-	 * If the halt fails(e.g. target needs a reset, JTAG communication not
-	 * working, etc.), then the GDB connect will succeed as
-	 * the get_gdb_reg_list() will lie and return a register list with
-	 * dummy values.
-	 *
-	 * This allows GDB monitor commands to be run from a GDB init script to
-	 * initialize the target
-	 *
-	 * Also, since the halt() is asynchronous target connect will be
-	 * instantaneous and thus avoiding annoying timeout problems during
-	 * connect.
-	 */
-	target_halt(gdb_service->target);
-	/* FIX!!!! could extended-remote work better here?
-	 *
-	 *  wait a tiny bit for halted state or we just continue. The
-	 * GDB register packet will then contain garbage
-	 */
-	target_wait_state(gdb_service->target, TARGET_HALTED, 500);
-
 	/* remove the initial ACK from the incoming buffer */
 	if ((retval = gdb_get_char(connection, &initial_ack)) != ERROR_OK)
 		return retval;
@@ -1609,7 +1588,11 @@
 			/* We want to print all debug output to GDB connection */
 			log_add_callback(gdb_log_callback, connection);
 			target_call_timer_callbacks_now();
+			/* some commands need to know the GDB connection, make note of current
+			 * GDB connection. */
+			current_gdb_connection = gdb_connection;
 			command_run_line(cmd_ctx, cmd);
+			current_gdb_connection = NULL;
 			target_call_timer_callbacks_now();
 			log_remove_callback(gdb_log_callback, connection);
 			free(cmd);
@@ -2107,20 +2090,52 @@
 				case 'c':
 				case 's':
 					{
-						if (target->state != TARGET_HALTED)
+						int retval = ERROR_OK;
+
+						gdb_connection_t *gdb_con = connection->priv;
+						log_add_callback(gdb_log_callback, connection);
+
+						bool nostep = false;
+						if (target->state == TARGET_RUNNING)
 						{
-							/* If the target isn't in the halted state, then we can't
+							LOG_WARNING("The target is already running. Halt target before stepi/continue.");
+							retval = target_halt(target);
+							if (retval == ERROR_OK)
+								retval = target_wait_state(target, TARGET_HALTED, 100);
+						} else if (target->state != TARGET_HALTED)
+						{
+							LOG_WARNING("The target is not in the halted nor running stated, stepi/continue ignored.");
+							nostep = true;
+						} else if ((packet[0] == 's') && gdb_con->sync)
+						{
+							/* Hmm..... when you issue a continue in GDB, then a "stepi" is
+							 * sent by GDB first to OpenOCD, thus defeating the check to
+							 * make only the single stepping have the sync feature...
+							 */
+							nostep = true;
+							LOG_WARNING("stepi ignored. GDB will now fetch the register state from the target.");
+						}
+						gdb_con->sync = false;
+
+						if ((retval!=ERROR_OK) || nostep)
+						{
+							/* Either the target isn't in the halted state, then we can't
 							 * step/continue. This might be early setup, etc.
+							 *
+							 * Or we want to allow GDB to pick up a fresh set of
+							 * register values without modifying the target state.
+							 *
 							 */
 							gdb_sig_halted(connection);
+
+							/* stop forwarding log packets! */
+							log_remove_callback(gdb_log_callback, connection);
 						} else
 						{
 							/* We're running/stepping, in which case we can
 							 * forward log output until the target is halted
 							 */
-							gdb_connection_t *gdb_con = connection->priv;
 							gdb_con->frontend_state = TARGET_RUNNING;
-							log_add_callback(gdb_log_callback, connection);
 							target_call_event_callbacks(target, TARGET_EVENT_GDB_START);
 							int retval = gdb_step_continue_packet(connection, target, packet, packet_size);
 							if (retval != ERROR_OK)
@@ -2255,6 +2270,25 @@
 	return ERROR_OK;
 }
 
+int handle_gdb_sync_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc != 0)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (current_gdb_connection == NULL)
+	{
+		command_print(cmd_ctx,
+				"gdb_sync command can only be run from within gdb using \"monitor gdb_sync\"");
+		return ERROR_FAIL;
+	}
+
+	current_gdb_connection->sync = true;
+
+	return ERROR_OK;
+}
+
 /* daemon configuration command gdb_port */
 int handle_gdb_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
@@ -2399,6 +2433,8 @@
 
 int gdb_register_commands(command_context_t *command_context)
 {
+	register_command(command_context, NULL, "gdb_sync", handle_gdb_sync_command,
+			COMMAND_ANY, "next stepi will return immediately allowing GDB fetch register state without affecting target state");
 	register_command(command_context, NULL, "gdb_port", handle_gdb_port_command,
 			COMMAND_ANY, "daemon configuration command gdb_port");
 	register_command(command_context, NULL, "gdb_detach", handle_gdb_detach_command,

Modified: trunk/src/server/gdb_server.h
===================================================================
--- trunk/src/server/gdb_server.h	2009-09-23 22:03:41 UTC (rev 2753)
+++ trunk/src/server/gdb_server.h	2009-09-24 06:34:23 UTC (rev 2754)
@@ -43,6 +43,10 @@
 	int closed;
 	int busy;
 	int noack_mode;
+	bool sync; 	/* set flag to true if you want the next stepi to return immediately.
+	               allowing GDB to pick up a fresh set of register values from the target
+	               without modifying the target state. */
+
 } gdb_connection_t;
 
 typedef struct gdb_service_s



From oharboe at mail.berlios.de  Fri Sep 25 13:11:43 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 25 Sep 2009 13:11:43 +0200
Subject: [Openocd-svn] r2755 - trunk/src/helper
Message-ID: <200909251111.n8PBBhHq026231@sheep.berlios.de>

Author: oharboe
Date: 2009-09-25 13:11:39 +0200 (Fri, 25 Sep 2009)
New Revision: 2755

Modified:
   trunk/src/helper/log.c
   trunk/src/helper/log.h
Log:
Try/catch scheme. Typed up the functionality and regression tested.
Ready for discussion and tiny patches that tries out this scheme.

Modified: trunk/src/helper/log.c
===================================================================
--- trunk/src/helper/log.c	2009-09-24 06:34:23 UTC (rev 2754)
+++ trunk/src/helper/log.c	2009-09-25 11:11:39 UTC (rev 2755)
@@ -64,6 +64,95 @@
 
 static int count = 0;
 
+
+static struct store_log_forward * log_head = NULL;
+static int log_forward_count = 0;
+
+struct store_log_forward
+{
+	struct store_log_forward * next;
+	const char * file;
+	int line;
+	const char * function;
+	const char * string;
+};
+
+/* either forward the log to the listeners or store it for possible forwarding later */
+static void log_forward(const char *file, int line, const char *function, const char *string)
+{
+	if (log_forward_count==0)
+	{
+		log_callback_t *cb, *next;
+		cb = log_callbacks;
+		/* DANGER!!!! the log callback can remove itself!!!! */
+		while (cb)
+		{
+			next = cb->next;
+			cb->fn(cb->priv, file, line, function, string);
+			cb = next;
+		}
+	} else
+	{
+		struct store_log_forward *log = malloc(sizeof (struct store_log_forward));
+		log->file = strdup(file);
+		log->line = line;
+		log->function = strdup(function);
+		log->string = strdup(string);
+		log->next = NULL;
+		if (log_head==NULL)
+			log_head = log;
+		else
+		{
+			/* append to tail */
+			struct store_log_forward * t;
+			t = log_head;
+			while (t->next!=NULL)
+			{
+				t = t->next;
+			}
+			t->next = log;
+		}
+	}
+}
+
+void log_try(void)
+{
+	log_forward_count++;
+}
+
+void log_catch(void)
+{
+	assert(log_forward_count>0);
+	log_forward_count--;
+}
+
+void log_rethrow(void)
+{
+	log_catch();
+	if (log_forward_count==0)
+	{
+		struct store_log_forward *log;
+
+		log = log_head;
+		while (log != NULL)
+		{
+			log_forward(log->file, log->line, log->function, log->string);
+
+			struct store_log_forward *t=log;
+			log = log->next;
+
+			free((void *)t->file);
+			free((void *)t->function);
+			free((void *)t->string);
+			free(t);
+
+		}
+
+		log_head = NULL;
+	}
+}
+
+
 /* The log_puts() serves to somewhat different goals:
  *
  * - logging
@@ -131,18 +220,11 @@
 	/* Never forward LOG_LVL_DEBUG, too verbose and they can be found in the log if need be */
 	if (level <= LOG_LVL_INFO)
 	{
-		log_callback_t *cb, *next;
-		cb = log_callbacks;
-		/* DANGER!!!! the log callback can remove itself!!!! */
-		while (cb)
-		{
-			next = cb->next;
-			cb->fn(cb->priv, file, line, function, string);
-			cb = next;
-		}
+		log_forward(file, line, function, string);
 	}
 }
 
+
 void log_printf(enum log_levels level, const char *file, int line, const char *function, const char *format, ...)
 {
 	char *string;

Modified: trunk/src/helper/log.h
===================================================================
--- trunk/src/helper/log.h	2009-09-24 06:34:23 UTC (rev 2754)
+++ trunk/src/helper/log.h	2009-09-25 11:11:39 UTC (rev 2755)
@@ -64,6 +64,15 @@
 extern void alive_sleep(int ms);
 extern void busy_sleep(int ms);
 
+
+/* log entries can be paused and replayed roughly according to the try/catch/rethrow
+ * concepts in C++
+ */
+void log_try(void);
+void log_catch(void);
+void log_rethrow(void);
+
+
 typedef void (*log_callback_fn)(void *priv, const char *file, int line,
 		const char *function, const char *string);
 



From oharboe at mail.berlios.de  Fri Sep 25 18:48:17 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Fri, 25 Sep 2009 18:48:17 +0200
Subject: [Openocd-svn] r2756 - in trunk/tcl: board target
Message-ID: <200909251648.n8PGmHmt011074@sheep.berlios.de>

Author: oharboe
Date: 2009-09-25 18:48:15 +0200 (Fri, 25 Sep 2009)
New Revision: 2756

Added:
   trunk/tcl/board/topas910.cfg
   trunk/tcl/board/topasa900.cfg
   trunk/tcl/target/tmpa900.cfg
   trunk/tcl/target/tmpa910.cfg
Log:
Michael Hasselberg <mh at open-engineering.de> target configuration files for Toshiba TX09 familiy

Added: trunk/tcl/board/topas910.cfg
===================================================================
--- trunk/tcl/board/topas910.cfg	2009-09-25 11:11:39 UTC (rev 2755)
+++ trunk/tcl/board/topas910.cfg	2009-09-25 16:48:15 UTC (rev 2756)
@@ -0,0 +1,118 @@
+######################################
+# Target:    Toshiba TOPAS910 -- TMPA910 Starterkit
+#
+######################################
+
+# We add to the minimal configuration.
+source [find target/tmpa910.cfg]
+
+######################
+# Target configuration
+######################
+
+#$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { topas910_init }
+
+proc topas910_init { } {
+# Init PLL
+# my settings
+	mww 0xf005000c 0x00000007
+	mww 0xf0050010 0x00000065
+	mww 0xf005000c 0x000000a7
+	sleep 10
+	mdw 0xf0050008
+	mww 0xf0050008 0x00000002
+	mww 0xf0050004 0x00000000
+# NEW: set CLKCR5
+	mww 0xf0050054 0x00000040
+#
+	sleep 10
+# Init SDRAM
+#  _PMCDRV          = 0x00000071;
+#  //
+#  // Initialize SDRAM timing paramater
+#  //
+#  _DMC_CAS_LATENCY = 0x00000006;
+#  _DMC_T_DQSS      = 0x00000000;
+#  _DMC_T_MRD       = 0x00000002;
+#  _DMC_T_RAS       = 0x00000007;
+#
+#  _DMC_T_RC        = 0x0000000A;
+#  _DMC_T_RCD       = 0x00000013;
+#
+#  _DMC_T_RFC       = 0x0000010A;
+#
+#  _DMC_T_RP        = 0x00000013;
+#  _DMC_T_RRD       = 0x00000002;
+#  _DMC_T_WR        = 0x00000002;
+#  _DMC_T_WTR       = 0x00000001;
+#  _DMC_T_XP        = 0x0000000A;
+#  _DMC_T_XSR       = 0x0000000B;
+#  _DMC_T_ESR       = 0x00000014;
+#
+#  //
+#  // Configure SDRAM type parameter
+#  _DMC_MEMORY_CFG  = 0x00008011;
+#  _DMC_USER_CONFIG = 0x00000011;   
+#  // 32 bit memory interface
+#
+#
+#  _DMC_REFRESH_PRD = 0x00000A60;
+#  _DMC_CHIP_0_CFG  = 0x000140FC;
+#
+#  _DMC_DIRECT_CMD  = 0x000C0000;
+#  _DMC_DIRECT_CMD  = 0x00000000;
+#
+#  _DMC_DIRECT_CMD  = 0x00040000;
+#  _DMC_DIRECT_CMD  = 0x00040000;
+#  _DMC_DIRECT_CMD  = 0x00080031;
+#  //
+#  // Finally start SDRAM
+#  //
+#  _DMC_MEMC_CMD    = MEMC_CMD_GO;
+#  */
+
+	mww 0xf0020260 0x00000071
+	mww 0xf4300014 0x00000006
+	mww 0xf4300018 0x00000000
+	mww 0xf430001C 0x00000002
+	mww 0xf4300020 0x00000007
+	mww 0xf4300024 0x0000000A
+	mww 0xf4300028 0x00000013
+	mww 0xf430002C 0x0000010A
+	mww 0xf4300030 0x00000013
+	mww 0xf4300034 0x00000002
+	mww 0xf4300038 0x00000002
+	mww 0xf430003C 0x00000001
+	mww 0xf4300040 0x0000000A
+	mww 0xf4300044 0x0000000B
+	mww 0xf4300048 0x00000014
+	mww 0xf430000C 0x00008011
+	mww 0xf4300304 0x00000011
+	mww 0xf4300010 0x00000A60
+	mww 0xf4300200 0x000140FC
+	mww 0xf4300008 0x000C0000
+	mww 0xf4300008 0x00000000
+	mww 0xf4300008 0x00040000
+	mww 0xf4300008 0x00040000
+	mww 0xf4300008 0x00080031
+	mww 0xf4300004 0x00000000
+
+	sleep 10
+#	jtag_speed 10000
+
+# remap off in case of IROM boot 
+	mww 0xf0000004 0x00000001
+
+}
+
+# comment the following out if usinf J-Link, it soes not support DCC
+arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+flash bank cfi 0x20000000 0x2000000 2 2 0


Property changes on: trunk/tcl/board/topas910.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/board/topasa900.cfg
===================================================================
--- trunk/tcl/board/topasa900.cfg	2009-09-25 11:11:39 UTC (rev 2755)
+++ trunk/tcl/board/topasa900.cfg	2009-09-25 16:48:15 UTC (rev 2756)
@@ -0,0 +1,125 @@
+# Thanks to Pieter Conradie for this script! 
+# Target:    Toshiba TOPAS900 -- TMPA900 Starterkit
+######################################
+
+# We add to the minimal configuration.
+source [find target/tmpa900.cfg]
+
+######################
+# Target configuration
+######################
+
+#$_TARGETNAME configure -event gdb-attach { reset init }
+$_TARGETNAME configure -event reset-init { topasa900_init }
+
+proc topasa900_init { } {
+# Init PLL
+# my settings
+	mww 0xf005000c 0x00000007
+	mww 0xf0050010 0x00000065
+	mww 0xf005000c 0x000000a7
+	sleep 10
+	mdw 0xf0050008
+	mww 0xf0050008 0x00000002
+	mww 0xf0050004 0x00000000
+# NEW: set CLKCR5
+	mww 0xf0050054 0x00000040
+#
+# bplan settings
+#	mww 0xf0050004 0x00000000
+#	mww 0xf005000c 0x000000a7
+#	sleep 10
+#	mdw 0xf0050008
+#	mww 0xf0050008 0x00000002
+#	mww 0xf0050010 0x00000065
+#	mww 0xf0050054 0x00000040
+	sleep 10
+# Init SDRAM
+#  _PMCDRV          = 0x00000071;
+#  //
+#  // Initialize SDRAM timing paramater
+#  //
+#  _DMC_CAS_LATENCY = 0x00000006;
+#  _DMC_T_DQSS      = 0x00000000;
+#  _DMC_T_MRD       = 0x00000002;
+#  _DMC_T_RAS       = 0x00000007;
+#
+#  _DMC_T_RC        = 0x0000000A;
+#  _DMC_T_RCD       = 0x00000013;
+#
+#  _DMC_T_RFC       = 0x0000010A;
+#
+#  _DMC_T_RP        = 0x00000013;
+#  _DMC_T_RRD       = 0x00000002;
+#  _DMC_T_WR        = 0x00000002;
+#  _DMC_T_WTR       = 0x00000001;
+#  _DMC_T_XP        = 0x0000000A;
+#  _DMC_T_XSR       = 0x0000000B;
+#  _DMC_T_ESR       = 0x00000014;
+#
+#  //
+#  // Configure SDRAM type parameter
+#  _DMC_MEMORY_CFG  = 0x00008011;
+#  _DMC_USER_CONFIG = 0x00000011;   // 32 bit memory interface
+#
+#
+#  _DMC_REFRESH_PRD = 0x00000A60;
+#  _DMC_CHIP_0_CFG  = 0x000140FC;
+#
+#  _DMC_DIRECT_CMD  = 0x000C0000;
+#  _DMC_DIRECT_CMD  = 0x00000000;
+#
+#  _DMC_DIRECT_CMD  = 0x00040000;
+#  _DMC_DIRECT_CMD  = 0x00040000;
+#  _DMC_DIRECT_CMD  = 0x00080031;
+#  //
+#  // Finally start SDRAM
+#  //
+#  _DMC_MEMC_CMD    = MEMC_CMD_GO;
+#  */
+
+	mww 0xf0020260 0x00000071
+	mww 0xf4300014 0x00000006
+	mww 0xf4300018 0x00000000
+	mww 0xf430001C 0x00000002
+	mww 0xf4300020 0x00000007
+	mww 0xf4300024 0x0000000A
+	mww 0xf4300028 0x00000013
+	mww 0xf430002C 0x0000010A
+	mww 0xf4300030 0x00000013
+	mww 0xf4300034 0x00000002
+	mww 0xf4300038 0x00000002
+	mww 0xf430003C 0x00000001
+	mww 0xf4300040 0x0000000A
+	mww 0xf4300044 0x0000000B
+	mww 0xf4300048 0x00000014
+	mww 0xf430000C 0x00008011
+	mww 0xf4300304 0x00000011
+	mww 0xf4300010 0x00000A60
+	mww 0xf4300200 0x000140FC
+	mww 0xf4300008 0x000C0000
+	mww 0xf4300008 0x00000000
+	mww 0xf4300008 0x00040000
+	mww 0xf4300008 0x00040000
+	mww 0xf4300008 0x00080031
+	mww 0xf4300004 0x00000000
+
+	sleep 10
+#	jtag_speed 10000
+
+# remap off in case of IROM boot 
+	mww 0xf0000004 0x00000001
+
+}
+
+# comment the following out if usinf J-Link, it soes not support DCC
+arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+
+#####################
+# Flash configuration
+#####################
+
+#flash bank cfi <base> <size> <chip width> <bus width> <target#>
+flash bank cfi 0x20000000 0x1000000 2 2 0
+


Property changes on: trunk/tcl/board/topasa900.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/tmpa900.cfg
===================================================================
--- trunk/tcl/target/tmpa900.cfg	2009-09-25 11:11:39 UTC (rev 2755)
+++ trunk/tcl/target/tmpa900.cfg	2009-09-25 16:48:15 UTC (rev 2756)
@@ -0,0 +1,56 @@
+######################################
+# Target:    Toshiba TMPA910
+######################################
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME tmpa910
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x07926031
+}
+
+#TMPA910 has following IDs:
+# CP15.0 register 0x41069265
+# CP15.1 register 0x1d152152
+# ARM core 0x07926031
+
+
+#
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+#use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config trst_and_srst
+jtag_nsrst_delay 20
+jtag_ntrst_delay 20
+
+######################
+# Target configuration
+######################
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+
+# built-in RAM0
+#working_area 0 0xf8004000 0x4000 nobackup
+# built-in RAM1
+#working_area 1 0xf8008000 0x4000 nobackup
+# built-in RAM2
+#working_area 2 0xf800c000 0x4000 nobackup
+# built-in RAM 0-2 48k total
+#working_area 0 0xf8004000 0xc000 nobackup
+
+# Internal sram1 memory
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0xf8004000 -work-area-size 0x8000 \
+-work-area-backup 0


Property changes on: trunk/tcl/target/tmpa900.cfg
___________________________________________________________________
Name: svn:eol-style
   + native

Added: trunk/tcl/target/tmpa910.cfg
===================================================================
--- trunk/tcl/target/tmpa910.cfg	2009-09-25 11:11:39 UTC (rev 2755)
+++ trunk/tcl/target/tmpa910.cfg	2009-09-25 16:48:15 UTC (rev 2756)
@@ -0,0 +1,56 @@
+######################################
+# Target:    Toshiba TMPA910
+######################################
+
+if { [info exists CHIPNAME] } {	
+   set  _CHIPNAME $CHIPNAME    
+} else {	 
+   set  _CHIPNAME tmpa910
+}
+
+if { [info exists ENDIAN] } {	
+   set  _ENDIAN $ENDIAN    
+} else {	 
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x07926031
+}
+
+#TMPA910 has following IDs:
+# CP15.0 register 0x41069265
+# CP15.1 register 0x1d152152
+# ARM core 0x07926031
+
+
+#
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+#use combined on interfaces or targets that can't set TRST/SRST separately
+reset_config trst_and_srst
+jtag_nsrst_delay 20
+jtag_ntrst_delay 20
+
+######################
+# Target configuration
+######################
+
+set _TARGETNAME [format "%s.cpu" $_CHIPNAME]
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+
+# built-in RAM0
+#working_area 0 0xf8004000 0x4000 nobackup
+# built-in RAM1
+#working_area 1 0xf8008000 0x4000 nobackup
+# built-in RAM2
+#working_area 2 0xf800c000 0x4000 nobackup
+# built-in RAM 0-2 48k total
+#working_area 0 0xf8004000 0xc000 nobackup
+
+# Internal sram1 memory
+$_TARGETNAME configure -work-area-virt 0 -work-area-phys 0xf8004000 -work-area-size 0xc000 \
+-work-area-backup 0


Property changes on: trunk/tcl/target/tmpa910.cfg
___________________________________________________________________
Name: svn:eol-style
   + native



From dbrownell at mail.berlios.de  Fri Sep 25 19:03:01 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Fri, 25 Sep 2009 19:03:01 +0200
Subject: [Openocd-svn] r2757 - trunk/tcl/target
Message-ID: <200909251703.n8PH31oo026600@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-25 19:02:59 +0200 (Fri, 25 Sep 2009)
New Revision: 2757

Modified:
   trunk/tcl/target/ti_dm355.cfg
Log:
Update DM355 target config to know about ICEpick.
Still defaults to nonstandard EMU0/EMU1 settings.


Modified: trunk/tcl/target/ti_dm355.cfg
===================================================================
--- trunk/tcl/target/ti_dm355.cfg	2009-09-25 16:48:15 UTC (rev 2756)
+++ trunk/tcl/target/ti_dm355.cfg	2009-09-25 17:02:59 UTC (rev 2757)
@@ -12,10 +12,17 @@
    set  _ENDIAN little
 }
 
+# TI boards default to EMU0/EMU1 *high* -- ARM and ETB are *disabled*
+# after JTAG reset until ICEpick is used to route them in.
+#set EMU01 "-disable"
+
+# With EMU0/EMU1 jumpered *low* ARM and ETB are *enabled* without
+# needing any ICEpick interaction.
+set EMU01 "-enable"
+
+source [find target/icepick.cfg]
+
 #
-# For now, expect EMU0/EMU1 jumpered LOW (not TI's default) so ARM and ETB
-# are enabled without making ICEpick route ARM and ETB into the JTAG chain.
-#
 # Also note:  when running without RTCK before the PLLs are set up, you
 # may need to slow the JTAG clock down quite a lot (under 2 MHz).
 #
@@ -26,7 +33,10 @@
 } else {
    set _ETB_TAPID 0x2b900f0f
 }
-jtag newtap $_CHIPNAME etb -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_ETB_TAPID
+jtag newtap $_CHIPNAME etb -irlen 4 -ircapture 0x1 -irmask 0xf \
+	-expected-id $_ETB_TAPID $EMU01
+jtag configure $_CHIPNAME.etb -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 1"
 
 # Subsidiary TAP: ARM926ejs with scan chains for ARM Debug, EmbeddedICE-RT, ETM.
 if { [info exists CPU_TAPID ] } {
@@ -34,7 +44,10 @@
 } else {
    set _CPU_TAPID 0x07926001
 }
-jtag newtap $_CHIPNAME arm -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPU_TAPID
+jtag newtap $_CHIPNAME arm -irlen 4 -ircapture 0x1 -irmask 0xf \
+	-expected-id $_CPU_TAPID $EMU01
+jtag configure $_CHIPNAME.arm -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 0"
 
 # Primary TAP: ICEpick (JTAG route controller) and boundary scan
 if { [info exists JRC_TAPID ] } {



From dbrownell at mail.berlios.de  Sat Sep 26 21:08:36 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sat, 26 Sep 2009 21:08:36 +0200
Subject: [Openocd-svn] r2758 - in trunk: doc src/jtag
Message-ID: <200909261908.n8QJ8aeF030734@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-26 21:08:34 +0200 (Sat, 26 Sep 2009)
New Revision: 2758

Modified:
   trunk/doc/openocd.texi
   trunk/src/jtag/tcl.c
Log:
Streamline Capture-IR handling and integrity test.

Change the handling of the "-ircapture" and "-irmask" parameters
to be slightly more sensible, given that the JTAG spec describes
what is required, and that we already require that conformance in
one place.  IR scan returns some bitstring with LSBs "01".

 - First, provide and use default values that satisfy the IEEE spec.
   Existing TAP configs will override the defaults, but those parms
   are no longer required.

 - Second, warn if any TAP gets set up to violate the JTAG spec.
   It's likely a bug, but maybe not; else this should be an error.
   Improve the related diagnostics to say which TAP is affected.

And associated minor fixes/cleanups to comments and diagnostics.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-25 17:02:59 UTC (rev 2757)
+++ trunk/doc/openocd.texi	2009-09-26 19:08:34 UTC (rev 2758)
@@ -2309,19 +2309,9 @@
 Every TAP requires at least the following @var{configparams}:
 
 @itemize @bullet
- at item @code{-ircapture} @var{NUMBER}
-@*The bit pattern loaded by the TAP into the JTAG shift register
-on entry to the @sc{ircapture} state, such as 0x01.
-JTAG requires the two LSBs of this value to be 01.
-The value is used to verify that instruction scans work correctly.
 @item @code{-irlen} @var{NUMBER}
 @*The length in bits of the
 instruction register, such as 4 or 5 bits.
- at item @code{-irmask} @var{NUMBER}
-@*A mask for the IR register.
-For some devices, there are bits in the IR that aren't used.
-This lets OpenOCD mask them off when doing IDCODE comparisons.
-In general, this should just be all ones for the size of the IR.
 @end itemize
 
 A TAP may also provide optional @var{configparams}:
@@ -2340,6 +2330,18 @@
 These codes are not required by all JTAG devices.
 @emph{Repeat the option} as many times as required if more than one
 ID code could appear (for example, multiple versions).
+ at item @code{-ircapture} @var{NUMBER}
+@*The bit pattern loaded by the TAP into the JTAG shift register
+on entry to the @sc{ircapture} state, such as 0x01.
+JTAG requires the two LSBs of this value to be 01.
+By default, @code{-ircapture} and @code{-irmask} are set
+up to verify that two-bit value; but you may provide
+additional bits, if you know them.
+ at item @code{-irmask} @var{NUMBER}
+@*A mask used with @code{-ircapture}
+to verify that instruction scans work correctly.
+Such scans are not used by OpenOCD except to verify that
+there seems to be no problems with JTAG scan chain operations.
 @end itemize
 @end deffn
 

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-25 17:02:59 UTC (rev 2757)
+++ trunk/src/jtag/tcl.c	2009-09-26 19:08:34 UTC (rev 2758)
@@ -242,13 +242,15 @@
 	LOG_DEBUG("Creating New Tap, Chip: %s, Tap: %s, Dotted: %s, %d params",
 			  pTap->chip, pTap->tapname, pTap->dotted_name, goi->argc);
 
-	/* deal with options */
-#define NTREQ_IRLEN      1
-#define NTREQ_IRCAPTURE  2
-#define NTREQ_IRMASK     4
+	/* IEEE specifies that the two LSBs of an IR scan are 01, so make
+	 * that the default.  The "-irlen" and "-irmask" options are only
+	 * needed to cope with nonstandard TAPs, or to specify more bits.
+	 */
+	pTap->ir_capture_mask = 0x03;
+	pTap->ir_capture_value = 0x01;
 
-	/* clear them as we find them */
-	reqbits = (NTREQ_IRLEN | NTREQ_IRCAPTURE | NTREQ_IRMASK);
+	/* clear flags for "required options" them as we find them */
+	reqbits = 1;
 
 	while (goi->argc) {
 		e = Jim_GetOpt_Nvp(goi, opts, &n);
@@ -308,31 +310,39 @@
 			switch (n->value) {
 			case NTAP_OPT_IRLEN:
 				if (w > (jim_wide) (8 * sizeof(pTap->ir_capture_value)))
-					LOG_WARNING("huge IR length %d", (int) w);
+					LOG_WARNING("%s: huge IR length %d",
+							pTap->dotted_name,
+							(int) w);
 				pTap->ir_length = w;
-				reqbits &= (~(NTREQ_IRLEN));
+				reqbits = 0;
 				break;
 			case NTAP_OPT_IRMASK:
 				if (is_bad_irval(pTap->ir_length, w)) {
-					LOG_ERROR("IR mask %x too big",
+					LOG_ERROR("%s: IR mask %x too big",
+							pTap->dotted_name,
 							(int) w);
 					free((void *)pTap->dotted_name);
 					free(pTap);
 					return ERROR_FAIL;
 				}
+				if ((w & 3) != 3)
+					LOG_WARNING("%s: nonstandard IR mask",
+							pTap->dotted_name);
 				pTap->ir_capture_mask = w;
-				reqbits &= (~(NTREQ_IRMASK));
 				break;
 			case NTAP_OPT_IRCAPTURE:
 				if (is_bad_irval(pTap->ir_length, w)) {
-					LOG_ERROR("IR capture %x too big",
+					LOG_ERROR("%s: IR capture %x too big",
+							pTap->dotted_name,
 							(int) w);
 					free((void *)pTap->dotted_name);
 					free(pTap);
 					return ERROR_FAIL;
 				}
+				if ((w & 3) != 1)
+					LOG_WARNING("%s: nonstandard IR value",
+							pTap->dotted_name);
 				pTap->ir_capture_value = w;
-				reqbits &= (~(NTREQ_IRCAPTURE));
 				break;
 			}
 		} /* switch (n->value) */



From dbrownell at mail.berlios.de  Sat Sep 26 21:18:42 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sat, 26 Sep 2009 21:18:42 +0200
Subject: [Openocd-svn] r2759 - in trunk/src: helper jtag
Message-ID: <200909261918.n8QJIgau032166@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-26 21:18:42 +0200 (Sat, 26 Sep 2009)
New Revision: 2759

Modified:
   trunk/src/helper/binarybuffer.h
   trunk/src/jtag/core.c
Log:
Updates to the initial scanchain validation code:
  - minor bug fixes
  - code cleanup
  - update comments
  - improve diagnostics
  - etc


Modified: trunk/src/helper/binarybuffer.h
===================================================================
--- trunk/src/helper/binarybuffer.h	2009-09-26 19:08:34 UTC (rev 2758)
+++ trunk/src/helper/binarybuffer.h	2009-09-26 19:18:42 UTC (rev 2759)
@@ -86,7 +86,7 @@
 struct scan_field_s;
 extern int buf_to_u32_handler(uint8_t *in_buf, void *priv, struct scan_field_s *field);
 
-#define CEIL(m, n)	((m + n - 1) / n)
+#define CEIL(m, n)	(((m) + (n) - 1) / (n))
 
 /* read a uint32_t from a buffer in target memory endianness */
 static inline uint32_t fast_target_buffer_get_u32(const uint8_t *buffer, int little)

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-26 19:08:34 UTC (rev 2758)
+++ trunk/src/jtag/core.c	2009-09-26 19:18:42 UTC (rev 2759)
@@ -847,6 +847,9 @@
 #define EXTRACT_PART(X) (((X) & 0xffff000) >> 12)
 #define EXTRACT_VER(X)  (((X) & 0xf0000000) >> 28)
 
+/* A reserved manufacturer ID is used in END_OF_CHAIN_FLAG, so we
+ * know that no valid TAP will have it as an IDCODE value.
+ */
 #define END_OF_CHAIN_FLAG	0x000000ff
 
 static int jtag_examine_chain_execute(uint8_t *idcode_buffer, unsigned num_idcode)
@@ -964,6 +967,7 @@
 }
 
 /* Try to examine chain layout according to IEEE 1149.1 ?12
+ * This is called a "blind interrogation" of the scan chain.
  */
 static int jtag_examine_chain(void)
 {
@@ -1037,7 +1041,12 @@
 	return ERROR_OK;
 }
 
-int jtag_validate_chain(void)
+/*
+ * Validate the date loaded by entry to the Capture-IR state, to help
+ * find errors related to scan chain configuration (wrong IR lengths)
+ * or communication.
+ */
+static int jtag_validate_ircapture(void)
 {
 	jtag_tap_t *tap;
 	int total_ir_length = 0;
@@ -1056,7 +1065,11 @@
 	}
 
 	total_ir_length += 2;
+
 	ir_test = malloc(CEIL(total_ir_length, 8));
+	if (ir_test == NULL)
+		return ERROR_FAIL;
+
 	buf_set_ones(ir_test, total_ir_length);
 
 	field.tap = NULL;
@@ -1082,24 +1095,37 @@
 			break;
 		}
 
+		/* Validate the two LSBs, which must be 01 per JTAG spec.
+		 * REVISIT we might be able to verify some MSBs too, using
+		 * ircapture/irmask attributes.
+		 */
 		val = buf_get_u32(ir_test, chain_pos, 2);
-		/* Only fail this check if we have IDCODE for this device */
-		if ((val != 0x1)&&(tap->hasidcode))
-		{
+		if (val != 1) {
 			char *cbuf = buf_to_str(ir_test, total_ir_length, 16);
-			LOG_ERROR("Could not validate JTAG scan chain, IR mismatch, scan returned 0x%s. tap=%s pos=%d expected 0x1 got %0x", cbuf, jtag_tap_name(tap), chain_pos, val);
-			free(cbuf);
-			free(ir_test);
-			return ERROR_JTAG_INIT_FAILED;
+
+			LOG_ERROR("%s: IR capture error; saw 0x%s not 0x..1",
+					jtag_tap_name(tap), cbuf);
+
+			/* Fail only if we have IDCODE for this device.
+			 * REVISIT -- why not fail-always?
+			 */
+			if (tap->hasidcode) {
+				free(cbuf);
+				free(ir_test);
+				return ERROR_JTAG_INIT_FAILED;
+			}
 		}
 		chain_pos += tap->ir_length;
 	}
 
+	/* verify the '11' sentinel we wrote is returned at the end */
 	val = buf_get_u32(ir_test, chain_pos, 2);
 	if (val != 0x3)
 	{
 		char *cbuf = buf_to_str(ir_test, total_ir_length, 16);
-		LOG_ERROR("Could not validate end of JTAG scan chain, IR mismatch, scan returned 0x%s. pos=%d expected 0x3 got %0x", cbuf, chain_pos, val);
+
+		LOG_ERROR("IR capture error at bit %d, saw 0x%s not 0x...3",
+				chain_pos, cbuf);
 		free(cbuf);
 		free(ir_test);
 		return ERROR_JTAG_INIT_FAILED;
@@ -1115,6 +1141,7 @@
 {
 	assert(0 != tap->ir_length);
 
+	/// @todo fix, this allocates one byte per bit for all three fields!
 	tap->expected = malloc(tap->ir_length);
 	tap->expected_mask = malloc(tap->ir_length);
 	tap->cur_instr = malloc(tap->ir_length);
@@ -1132,7 +1159,8 @@
 	LOG_DEBUG("Created Tap: %s @ abs position %d, "
 			"irlen %d, capture: 0x%x mask: 0x%x", tap->dotted_name,
 				tap->abs_chain_position, tap->ir_length,
-			  (unsigned int)(tap->ir_capture_value), (unsigned int)(tap->ir_capture_mask));
+				(unsigned) tap->ir_capture_value,
+				(unsigned) tap->ir_capture_mask);
 	jtag_tap_add(tap);
 }
 
@@ -1141,6 +1169,7 @@
 	jtag_unregister_event_callback(&jtag_reset_callback, tap);
 
 	/// @todo is anything missing? no memory leaks please
+	free((void *)tap->expected);
 	free((void *)tap->expected_ids);
 	free((void *)tap->chip);
 	free((void *)tap->tapname);
@@ -1212,9 +1241,9 @@
 		LOG_ERROR("trying to validate configured JTAG chain anyway...");
 	}
 
-	if (jtag_validate_chain() != ERROR_OK)
+	if (jtag_validate_ircapture() != ERROR_OK)
 	{
-		LOG_WARNING("Could not validate JTAG chain, continuing anyway...");
+		LOG_WARNING("Errors during IR capture, continuing anyway...");
 	}
 
 	return ERROR_OK;



From dbrownell at mail.berlios.de  Sun Sep 27 00:01:25 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 27 Sep 2009 00:01:25 +0200
Subject: [Openocd-svn] r2760 - trunk/src/jtag
Message-ID: <200909262201.n8QM1PeB018699@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-27 00:01:24 +0200 (Sun, 27 Sep 2009)
New Revision: 2760

Modified:
   trunk/src/jtag/core.c
Log:
Diagnostics tweaks for jtag_examine_chain() failure paths.


Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-26 19:18:42 UTC (rev 2759)
+++ trunk/src/jtag/core.c	2009-09-26 22:01:24 UTC (rev 2760)
@@ -885,8 +885,9 @@
 	 * the scan is not valid */
 	if (zero_check == 0x00 || one_check == 0xff)
 	{
-		LOG_ERROR("JTAG communication failure: check connection, "
-			"JTAG interface, target power etc.");
+		LOG_ERROR("JTAG scan chain interrogation failed: all %s",
+				(zero_check == 0x00) ? "zeroes" : "ones");
+		LOG_ERROR("Check JTAG interface, timings, target power, etc.");
 		return false;
 	}
 	return true;
@@ -1238,7 +1239,7 @@
 	/* examine chain first, as this could discover the real chain layout */
 	if (jtag_examine_chain() != ERROR_OK)
 	{
-		LOG_ERROR("trying to validate configured JTAG chain anyway...");
+		LOG_ERROR("Trying to use configured scan chain anyway...");
 	}
 
 	if (jtag_validate_ircapture() != ERROR_OK)



From dbrownell at mail.berlios.de  Sun Sep 27 00:08:54 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 27 Sep 2009 00:08:54 +0200
Subject: [Openocd-svn] r2761 - trunk/tcl/board
Message-ID: <200909262208.n8QM8sZ2019294@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-27 00:08:50 +0200 (Sun, 27 Sep 2009)
New Revision: 2761

Modified:
   trunk/tcl/board/dm355evm.cfg
Log:
On DM355 EVM board, associate NAND chips with $_TARGETNAME
instead of a target number.


Modified: trunk/tcl/board/dm355evm.cfg
===================================================================
--- trunk/tcl/board/dm355evm.cfg	2009-09-26 22:01:24 UTC (rev 2760)
+++ trunk/tcl/board/dm355evm.cfg	2009-09-26 22:08:50 UTC (rev 2761)
@@ -191,8 +191,8 @@
 # you either (a) have 'new' DM355 chips, with boot ROMs that don't need to
 # use "hwecc4_infix" for the UBL; or else (b) aren't updating anything that
 # needs infix layout ... like an old UBL, old U-Boot, old MVL kernel, etc.
-nand device davinci 0 0x02000000 hwecc4 0x01e10000
-nand device davinci 0 0x02004000 hwecc4 0x01e10000
+nand device davinci $_TARGETNAME 0x02000000 hwecc4 0x01e10000
+nand device davinci $_TARGETNAME 0x02004000 hwecc4 0x01e10000
 
 # FIXME
 #  - support writing UBL with its header (new layout only with new ROMs)



From dbrownell at mail.berlios.de  Sun Sep 27 09:59:12 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 27 Sep 2009 09:59:12 +0200
Subject: [Openocd-svn] r2762 - trunk/tcl/target
Message-ID: <200909270759.n8R7xC6g014239@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-27 09:59:10 +0200 (Sun, 27 Sep 2009)
New Revision: 2762

Modified:
   trunk/tcl/target/omap5912.cfg
Log:
Don't provide invalid OMAP5912 IR capture value/mask attributes


Modified: trunk/tcl/target/omap5912.cfg
===================================================================
--- trunk/tcl/target/omap5912.cfg	2009-09-26 22:08:50 UTC (rev 2761)
+++ trunk/tcl/target/omap5912.cfg	2009-09-27 07:59:10 UTC (rev 2762)
@@ -25,9 +25,9 @@
 # its standalone siblings (like TMS320VC5502) of the same era
 
 #jtag scan chain
-jtag newtap $_CHIPNAME dsp -irlen 38 -ircapture 0x0 -irmask 0x0 -expected-id 0x03df1d81
-jtag newtap $_CHIPNAME arm -irlen 4 -ircapture 0x1 -irmask 0x0 -expected-id $_CPUTAPID
-jtag newtap $_CHIPNAME unknown -irlen 8 -ircapture  0x0 -irmask 0x0
+jtag newtap $_CHIPNAME dsp -irlen 38 -expected-id 0x03df1d81
+jtag newtap $_CHIPNAME arm -irlen 4 -expected-id $_CPUTAPID
+jtag newtap $_CHIPNAME unknown -irlen 8
 
 set _TARGETNAME $_CHIPNAME.arm
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME



From dbrownell at mail.berlios.de  Sun Sep 27 18:55:53 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 27 Sep 2009 18:55:53 +0200
Subject: [Openocd-svn] r2763 - trunk/src/jtag
Message-ID: <200909271655.n8RGtrKo025344@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-27 18:55:52 +0200 (Sun, 27 Sep 2009)
New Revision: 2763

Modified:
   trunk/src/jtag/ft2232.c
Log:
Update FT2232 driver so that it reliably enters TAP_RESET.

When the OpenOCD server starts up it records its state as TAP_RESET,
even though it could be anything.  Then when it starts to examine
the scan chain, it calls jtag_add_tlr() which sees it doesn't have
any work to do, and so it does nothing.  This can make the next
operations fail because they start from the wrong TAP state...

Instead of caring about the current recorded state, always enter
TAP_RESET by forcing five clocks with TMS high.

(NOTE:  it seems most other JTAG adapter drivers have this same bug.)


Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-09-27 07:59:10 UTC (rev 2762)
+++ trunk/src/jtag/ft2232.c	2009-09-27 16:55:52 UTC (rev 2763)
@@ -1587,8 +1587,16 @@
 	}
 	ft2232_end_state(cmd->cmd.statemove->end_state);
 
-	/* move to end state */
-	if (tap_get_state() != tap_get_end_state())
+	/* For TAP_RESET, ignore the current recorded state.  It's often
+	 * wrong at server startup, and this transation is critical whenever
+	 * it's requested.
+	 */
+	if (tap_get_end_state() == TAP_RESET) {
+		clock_tms(0x4b,  0xff, 5, 0);
+		require_send = 1;
+
+	/* shortest-path move to desired end state */
+	} else if (tap_get_state() != tap_get_end_state())
 	{
 		move_to_state(tap_get_end_state());
 		require_send = 1;



From dbrownell at mail.berlios.de  Sun Sep 27 19:08:44 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Sun, 27 Sep 2009 19:08:44 +0200
Subject: [Openocd-svn] r2764 - trunk
Message-ID: <200909271708.n8RH8iIx005771@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-27 19:08:42 +0200 (Sun, 27 Sep 2009)
New Revision: 2764

Modified:
   trunk/TODO
Log:
Add list of JTAG adapter drivers with TAP_RESET statemove bug.


Modified: trunk/TODO
===================================================================
--- trunk/TODO	2009-09-27 16:55:52 UTC (rev 2763)
+++ trunk/TODO	2009-09-27 17:08:42 UTC (rev 2764)
@@ -60,6 +60,22 @@
 
 @subsection thelistjtaginterfaces JTAG Interfaces
 
+There are some known bugs to fix in JTAG adapter drivers:
+
+- For JTAG_STATEMOVE to TAP_RESET, all drivers must ignore the current
+  recorded state.  The tap_get_state() call won't necessarily return
+  the correct value, especially at server startup.  Fix is easy:  in
+  that case, always issue five clocks with TMS high.
+  - amt_jtagaccel.c
+  - arm-jtag-ew.c
+  - bitbang.c
+  - bitq.c
+  - gw16012.c
+  - jlink.c
+  - usbprog.c
+  - vsllink.c
+  - rlink/rlink.c
+
 The following tasks have been suggeted for improving OpenOCD's JTAG
 interface support:
 
@@ -69,7 +85,7 @@
 - J-Link driver:
   - fix to work with long scan chains, such as R.Doss's svf test.
 - FT2232 (libftdi):
-  - make performance comparable to alternatives
+  - make performance comparable to alternatives (on Win32, D2XX is faster)
   - make usability comparable to alternatives
 
 The following tasks have been suggested for adding new JTAG interfaces:



From dbrownell at mail.berlios.de  Mon Sep 28 06:55:25 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Mon, 28 Sep 2009 06:55:25 +0200
Subject: [Openocd-svn] r2765 - trunk/src/target
Message-ID: <200909280455.n8S4tPKF022863@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-28 06:55:23 +0200 (Mon, 28 Sep 2009)
New Revision: 2765

Modified:
   trunk/src/target/arm9tdmi.c
Log:
Shrink symbols exported from arm9tdmi.c and remove a forward ref.


Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-09-27 17:08:42 UTC (rev 2764)
+++ trunk/src/target/arm9tdmi.c	2009-09-28 04:55:23 UTC (rev 2765)
@@ -45,14 +45,10 @@
 #define _DEBUG_INSTRUCTION_EXECUTION_
 #endif
 
-/* cli handling */
-int handle_arm9tdmi_catch_vectors_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
-
 /* forward declarations */
-int arm9tdmi_target_create(struct target_s *target, Jim_Interp *interp);
+static int arm9tdmi_target_create(struct target_s *target, Jim_Interp *interp);
+static int arm9tdmi_quit(void);
 
-int arm9tdmi_quit(void);
-
 target_type_t arm9tdmi_target =
 {
 	.name = "arm9tdmi",
@@ -92,7 +88,7 @@
 	.quit = arm9tdmi_quit
 };
 
-arm9tdmi_vector_t arm9tdmi_vectors[] =
+static arm9tdmi_vector_t arm9tdmi_vectors[] =
 {
 	{"reset", ARM9TDMI_RESET_VECTOR},
 	{"undef", ARM9TDMI_UNDEF_VECTOR},
@@ -368,7 +364,8 @@
 	return ERROR_OK;
 }
 
-void arm9tdmi_change_to_arm(target_t *target, uint32_t *r0, uint32_t *pc)
+static void arm9tdmi_change_to_arm(target_t *target,
+		uint32_t *r0, uint32_t *pc)
 {
 	int retval = ERROR_OK;
 	/* get pointers to arch-specific information */
@@ -449,7 +446,8 @@
 	}
 }
 
-void arm9tdmi_read_core_regs_target_buffer(target_t *target, uint32_t mask, void* buffer, int size)
+static void arm9tdmi_read_core_regs_target_buffer(target_t *target,
+		uint32_t mask, void* buffer, int size)
 {
 	int i;
 	/* get pointers to arch-specific information */
@@ -490,7 +488,7 @@
 	}
 }
 
-void arm9tdmi_read_xpsr(target_t *target, uint32_t *xpsr, int spsr)
+static void arm9tdmi_read_xpsr(target_t *target, uint32_t *xpsr, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
@@ -514,7 +512,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, xpsr, 0);
 }
 
-void arm9tdmi_write_xpsr(target_t *target, uint32_t xpsr, int spsr)
+static void arm9tdmi_write_xpsr(target_t *target, uint32_t xpsr, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
@@ -550,7 +548,8 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void arm9tdmi_write_xpsr_im8(target_t *target, uint8_t xpsr_im, int rot, int spsr)
+static void arm9tdmi_write_xpsr_im8(target_t *target,
+		uint8_t xpsr_im, int rot, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
@@ -675,7 +674,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
 }
 
-void arm9tdmi_write_pc(target_t *target, uint32_t pc)
+static void arm9tdmi_write_pc(target_t *target, uint32_t pc)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target->arch_info;
@@ -712,7 +711,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
 }
 
-void arm9tdmi_branch_resume_thumb(target_t *target)
+static void arm9tdmi_branch_resume_thumb(target_t *target)
 {
 	LOG_DEBUG("-");
 
@@ -806,7 +805,7 @@
 	}
 }
 
-void arm9tdmi_build_reg_cache(target_t *target)
+static void arm9tdmi_build_reg_cache(target_t *target)
 {
 	reg_cache_t **cache_p = register_get_last_cache_p(&target->reg_cache);
 	/* get pointers to arch-specific information */
@@ -861,7 +860,7 @@
 	return ERROR_OK;
 }
 
-int arm9tdmi_quit(void)
+static int arm9tdmi_quit(void)
 {
 	return ERROR_OK;
 }
@@ -931,7 +930,9 @@
 	return ERROR_OK;
 }
 
-int arm9tdmi_get_arch_pointers(target_t *target, armv4_5_common_t **armv4_5_p, arm7_9_common_t **arm7_9_p, arm9tdmi_common_t **arm9tdmi_p)
+static int arm9tdmi_get_arch_pointers(target_t *target,
+		armv4_5_common_t **armv4_5_p, arm7_9_common_t **arm7_9_p,
+		arm9tdmi_common_t **arm9tdmi_p)
 {
 	armv4_5_common_t *armv4_5 = target->arch_info;
 	arm7_9_common_t *arm7_9;
@@ -961,7 +962,7 @@
 	return ERROR_OK;
 }
 
-int arm9tdmi_target_create(struct target_s *target, Jim_Interp *interp)
+static int arm9tdmi_target_create(struct target_s *target, Jim_Interp *interp)
 {
 	arm9tdmi_common_t *arm9tdmi = calloc(1,sizeof(arm9tdmi_common_t));
 
@@ -971,24 +972,9 @@
 	return ERROR_OK;
 }
 
-int arm9tdmi_register_commands(struct command_context_s *cmd_ctx)
+static int handle_arm9tdmi_catch_vectors_command(
+	struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	int retval;
-	command_t *arm9tdmi_cmd;
-
-	retval = arm7_9_register_commands(cmd_ctx);
-	arm9tdmi_cmd = register_command(cmd_ctx, NULL, "arm9tdmi",
-			NULL, COMMAND_ANY,
-			"arm9tdmi specific commands");
-	register_command(cmd_ctx, arm9tdmi_cmd, "vector_catch",
-			handle_arm9tdmi_catch_vectors_command, COMMAND_EXEC,
-			"catch arm9 vectors ['all'|'none'|'<vec1 vec2 ...>']");
-
-	return retval;
-}
-
-int handle_arm9tdmi_catch_vectors_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
-{
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -1069,3 +1055,20 @@
 
 	return ERROR_OK;
 }
+
+int arm9tdmi_register_commands(struct command_context_s *cmd_ctx)
+{
+	int retval;
+	command_t *arm9tdmi_cmd;
+
+	retval = arm7_9_register_commands(cmd_ctx);
+	arm9tdmi_cmd = register_command(cmd_ctx, NULL, "arm9tdmi",
+			NULL, COMMAND_ANY,
+			"arm9tdmi specific commands");
+	register_command(cmd_ctx, arm9tdmi_cmd, "vector_catch",
+			handle_arm9tdmi_catch_vectors_command, COMMAND_EXEC,
+			"catch arm9 vectors ['all'|'none'|'<vec1 vec2 ...>']");
+
+	return retval;
+}
+



From oharboe at mail.berlios.de  Mon Sep 28 14:13:50 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 28 Sep 2009 14:13:50 +0200
Subject: [Openocd-svn] r2766 - trunk/doc/manual
Message-ID: <200909281213.n8SCDo5k006128@sheep.berlios.de>

Author: oharboe
Date: 2009-09-28 14:13:49 +0200 (Mon, 28 Sep 2009)
New Revision: 2766

Modified:
   trunk/doc/manual/server.txt
Log:
spelling fix

Modified: trunk/doc/manual/server.txt
===================================================================
--- trunk/doc/manual/server.txt	2009-09-28 04:55:23 UTC (rev 2765)
+++ trunk/doc/manual/server.txt	2009-09-28 12:13:49 UTC (rev 2766)
@@ -111,7 +111,7 @@
 devince with a built-in HTTP server.  Later, they were willing to both
 contribute and integrate most of that work into the main tree.
 
- at subsection serverdocsother Other Options Concidered
+ at subsection serverdocsother Other Options Considered
 
 What if a web browser is not acceptable ie: You want to write your own
 front gadget in Eclipse, or KDevelop, or PerlTK, Ruby, or what ever



From oharboe at mail.berlios.de  Mon Sep 28 14:22:20 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Mon, 28 Sep 2009 14:22:20 +0200
Subject: [Openocd-svn] r2767 - trunk/src/jtag
Message-ID: <200909281222.n8SCMKJa006935@sheep.berlios.de>

Author: oharboe
Date: 2009-09-28 14:22:20 +0200 (Mon, 28 Sep 2009)
New Revision: 2767

Modified:
   trunk/src/jtag/ft2232.c
Log:
if srst pulls trst, then set state to TAP_RESET. 

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-09-28 12:13:49 UTC (rev 2766)
+++ trunk/src/jtag/ft2232.c	2009-09-28 12:22:20 UTC (rev 2767)
@@ -1,13 +1,16 @@
 /***************************************************************************
+*   Copyright (C) 2009 by ?yvind Harboe                                   *
+*	?yvind Harboe <oyvind.harboe at zylin.com>                               *
+*                                                                         *
+*   Copyright (C) 2009 by SoftPLC Corporation.  http://softplc.com        *
+*	Dick Hollenbeck <dick at softplc.com>                                    *
+*                                                                         *
 *   Copyright (C) 2004, 2006 by Dominic Rath                              *
 *   Dominic.Rath at gmx.de                                                   *
 *                                                                         *
 *   Copyright (C) 2008 by Spencer Oliver                                  *
 *   spen at spen-soft.co.uk                                                  *
 *                                                                         *
-*   Copyright (C) 2009 by SoftPLC Corporation.  http://softplc.com        *
-*	Dick Hollenbeck <dick at softplc.com>                                    *
-*                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
@@ -1709,6 +1712,11 @@
 		first_unsent = cmd;
 	}
 
+	if ((cmd->cmd.reset->trst == 1) || (cmd->cmd.reset->srst && (jtag_get_reset_config() & RESET_SRST_PULLS_TRST)))
+	{
+		tap_set_state(TAP_RESET);
+	}
+
 	layout->reset(cmd->cmd.reset->trst, cmd->cmd.reset->srst);
 	require_send = 1;
 



From oharboe at mail.berlios.de  Tue Sep 29 08:07:50 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 29 Sep 2009 08:07:50 +0200
Subject: [Openocd-svn] r2768 - trunk/src/jtag
Message-ID: <200909290607.n8T67oaI026592@sheep.berlios.de>

Author: oharboe
Date: 2009-09-29 08:07:50 +0200 (Tue, 29 Sep 2009)
New Revision: 2768

Modified:
   trunk/src/jtag/core.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/tcl.c
Log:
added t/nsrst_assert_width commands

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-28 12:22:20 UTC (rev 2767)
+++ trunk/src/jtag/core.c	2009-09-29 06:07:50 UTC (rev 2768)
@@ -93,6 +93,8 @@
 /* how long the OpenOCD should wait before attempting JTAG communication after reset lines deasserted (in ms) */
 static int jtag_nsrst_delay = 0; /* default to no nSRST delay */
 static int jtag_ntrst_delay = 0; /* default to no nTRST delay */
+static int jtag_nsrst_assert_width = 0; /* width of assertion */
+static int jtag_ntrst_assert_width = 0; /* width of assertion */
 
 typedef struct jtag_event_callback_s
 {
@@ -661,7 +663,11 @@
 	if (jtag_srst != new_srst) {
 		jtag_srst = new_srst;
 		if (jtag_srst)
+		{
 			LOG_DEBUG("SRST line asserted");
+			if (jtag_nsrst_assert_width)
+				jtag_add_sleep(jtag_nsrst_assert_width * 1000);
+		}
 		else {
 			LOG_DEBUG("SRST line released");
 			if (jtag_nsrst_delay)
@@ -685,6 +691,8 @@
 		if (jtag_trst) {
 			LOG_DEBUG("TRST line asserted");
 			tap_set_state(TAP_RESET);
+			if (jtag_ntrst_assert_width)
+				jtag_add_sleep(jtag_ntrst_assert_width * 1000);
 		} else {
 			LOG_DEBUG("TRST line released");
 			if (jtag_ntrst_delay)
@@ -1480,3 +1488,21 @@
 {
 	return jtag_ntrst_delay;
 }
+
+
+void jtag_set_nsrst_assert_width(unsigned delay)
+{
+	jtag_nsrst_assert_width = delay;
+}
+unsigned jtag_get_nsrst_assert_width(void)
+{
+	return jtag_nsrst_assert_width;
+}
+void jtag_set_ntrst_assert_width(unsigned delay)
+{
+	jtag_ntrst_assert_width = delay;
+}
+unsigned jtag_get_ntrst_assert_width(void)
+{
+	return jtag_ntrst_assert_width;
+}

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-09-28 12:22:20 UTC (rev 2767)
+++ trunk/src/jtag/jtag.h	2009-09-29 06:07:50 UTC (rev 2768)
@@ -289,6 +289,12 @@
 void jtag_set_ntrst_delay(unsigned delay);
 unsigned jtag_get_ntrst_delay(void);
 
+void jtag_set_nsrst_assert_width(unsigned delay);
+unsigned jtag_get_nsrst_assert_width(void);
+
+void jtag_set_ntrst_assert_width(unsigned delay);
+unsigned jtag_get_ntrst_assert_width(void);
+
 /// @returns The current state of TRST.
 int jtag_get_trst(void);
 /// @returns The current state of SRST.

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-09-28 12:22:20 UTC (rev 2767)
+++ trunk/src/jtag/tcl.c	2009-09-29 06:07:50 UTC (rev 2768)
@@ -61,6 +61,8 @@
 static int handle_reset_config_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_jtag_nsrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int handle_jtag_ntrst_delay_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_nsrst_assert_width_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+static int handle_jtag_ntrst_assert_width_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 static int handle_scan_chain_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
@@ -619,6 +621,10 @@
 		COMMAND_ANY, "jtag_nsrst_delay <ms> - delay after deasserting srst in ms");
 	register_command(cmd_ctx, NULL, "jtag_ntrst_delay", handle_jtag_ntrst_delay_command,
 		COMMAND_ANY, "jtag_ntrst_delay <ms> - delay after deasserting trst in ms");
+	register_command(cmd_ctx, NULL, "jtag_nsrst_assert_width", handle_jtag_nsrst_assert_width_command,
+		COMMAND_ANY, "jtag_nsrst_assert_width <ms> - delay after asserting srst in ms");
+	register_command(cmd_ctx, NULL, "jtag_ntrst_assert_width", handle_jtag_ntrst_assert_width_command,
+		COMMAND_ANY, "jtag_ntrst_assert_width <ms> - delay after asserting trst in ms");
 
 	register_command(cmd_ctx, NULL, "scan_chain", handle_scan_chain_command,
 		COMMAND_EXEC, "print current scan chain configuration");
@@ -979,6 +985,40 @@
 	return ERROR_OK;
 }
 
+static int handle_jtag_nsrst_assert_width_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	if (argc > 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (argc == 1)
+	{
+		unsigned delay;
+		int retval = parse_uint(args[0], &delay);
+		if (ERROR_OK != retval)
+			return retval;
+		jtag_set_nsrst_assert_width(delay);
+	}
+	command_print(cmd_ctx, "jtag_nsrst_assert_width: %u", jtag_get_nsrst_assert_width());
+	return ERROR_OK;
+}
+
+static int handle_jtag_ntrst_assert_width_command(struct command_context_s *cmd_ctx,
+		char *cmd, char **args, int argc)
+{
+	if (argc > 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (argc == 1)
+	{
+		unsigned delay;
+		int retval = parse_uint(args[0], &delay);
+		if (ERROR_OK != retval)
+			return retval;
+		jtag_set_ntrst_assert_width(delay);
+	}
+	command_print(cmd_ctx, "jtag_ntrst_assert_width: %u", jtag_get_ntrst_assert_width());
+	return ERROR_OK;
+}
+
 static int handle_jtag_speed_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int retval = ERROR_OK;



From oharboe at mail.berlios.de  Tue Sep 29 15:46:27 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 29 Sep 2009 15:46:27 +0200
Subject: [Openocd-svn] r2769 - in trunk: doc/manual src/server
Message-ID: <200909291346.n8TDkRa5022484@sheep.berlios.de>

Author: oharboe
Date: 2009-09-29 15:46:26 +0200 (Tue, 29 Sep 2009)
New Revision: 2769

Modified:
   trunk/doc/manual/server.txt
   trunk/src/server/httpd.c
Log:
httpd smoketest info

Modified: trunk/doc/manual/server.txt
===================================================================
--- trunk/doc/manual/server.txt	2009-09-29 06:07:50 UTC (rev 2768)
+++ trunk/doc/manual/server.txt	2009-09-29 13:46:26 UTC (rev 2769)
@@ -311,6 +311,15 @@
 
 /** @page serverhttp OpenOCD HTTP Server API
 
-This section needs to be expanded.
 
+Smoketest:
+
+configure --enable-httpd --enable-dummy --enable-ioutil
+
+openocd -s /usr/local/share/openocd -f httpd/httpd.tcl -f interface/dummy.cfg -f target/lpc2148.cfg
+
+Navigate to: http://localhost:8888/
+
+ 
+
  */

Modified: trunk/src/server/httpd.c
===================================================================
--- trunk/src/server/httpd.c	2009-09-29 06:07:50 UTC (rev 2768)
+++ trunk/src/server/httpd.c	2009-09-29 13:46:26 UTC (rev 2769)
@@ -1,9 +1,7 @@
 /***************************************************************************
- *   Copyright (C) 2007,2008 ?yvind Harboe                                 *
+ *   Copyright (C) 2007,2008,2009 ?yvind Harboe                            *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
- *   Copyright (C) 2008 Free Software Foundation
- *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -198,6 +196,7 @@
 		const char *data, size_t off, size_t size)
 {
 	Jim_Obj *keyObj = Jim_NewStringObj(interp, key, -1);
+	Jim_IncrRefCount(keyObj);
 	Jim_Obj *value = NULL;
 
 	Jim_Obj *dict = Jim_GetVariableStr(interp, "httppostdata", 0);
@@ -208,16 +207,32 @@
 		{
 			 value = NULL;
 		}
+		else
+		{
+			Jim_IncrRefCount(value);
+		}
 	}
+
 	if (value == NULL)
+	{
 		value = Jim_NewStringObj(interp, "", -1);
+		Jim_IncrRefCount(value);
 
+	}
+
 	/* create a new object we append to and insert into this location */
 	Jim_Obj *newObj = Jim_NewStringObj(interp, "", -1);
+	Jim_IncrRefCount(newObj);
 	Jim_AppendObj(interp, newObj, value);
 	Jim_AppendString(interp, newObj, data, size);
 	/* uhh... use name here of dictionary */
-	Jim_SetDictKeysVector(interp, Jim_NewStringObj(interp, "httppostdata", -1), &keyObj, 1, newObj);
+	dict = Jim_NewStringObj(interp, "httppostdata", -1);
+	Jim_IncrRefCount(dict);
+	Jim_SetDictKeysVector(interp, dict, &keyObj, 1, newObj);
+	Jim_DecrRefCount(interp, dict);
+	Jim_DecrRefCount(interp, value);
+	Jim_DecrRefCount(interp, newObj);
+	Jim_DecrRefCount(interp, keyObj);
 }
 
 /* append data to each key */



From oharboe at mail.berlios.de  Tue Sep 29 16:23:43 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 29 Sep 2009 16:23:43 +0200
Subject: [Openocd-svn] r2770 - trunk/src/jtag
Message-ID: <200909291423.n8TENhad026890@sheep.berlios.de>

Author: oharboe
Date: 2009-09-29 16:23:42 +0200 (Tue, 29 Sep 2009)
New Revision: 2770

Modified:
   trunk/src/jtag/driver.c
Log:
reentry assert

Modified: trunk/src/jtag/driver.c
===================================================================
--- trunk/src/jtag/driver.c	2009-09-29 13:46:26 UTC (rev 2769)
+++ trunk/src/jtag/driver.c	2009-09-29 14:23:42 UTC (rev 2770)
@@ -489,6 +489,11 @@
 
 int interface_jtag_execute_queue(void)
 {
+	static int reentry = 0;
+
+	assert(reentry==0);
+	reentry++;
+
 	int retval = default_interface_jtag_execute_queue();
 	if (retval == ERROR_OK)
 	{
@@ -504,6 +509,8 @@
 	jtag_command_queue_reset();
 	jtag_callback_queue_reset();
 
+	reentry--;
+
 	return retval;
 }
 



From oharboe at mail.berlios.de  Tue Sep 29 16:24:03 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Tue, 29 Sep 2009 16:24:03 +0200
Subject: [Openocd-svn] r2771 - trunk/src/server
Message-ID: <200909291424.n8TEO3mG026913@sheep.berlios.de>

Author: oharboe
Date: 2009-09-29 16:24:02 +0200 (Tue, 29 Sep 2009)
New Revision: 2771

Modified:
   trunk/src/server/httpd.c
Log:
handle single threading

Modified: trunk/src/server/httpd.c
===================================================================
--- trunk/src/server/httpd.c	2009-09-29 14:23:42 UTC (rev 2770)
+++ trunk/src/server/httpd.c	2009-09-29 14:24:02 UTC (rev 2771)
@@ -34,6 +34,20 @@
 
 #define PAGE_NOT_FOUND "<html><head><title > File not found</title></head><body > File not found</body></html>"
 
+static pthread_mutex_t mutex;
+
+void openocd_sleep_prelude(void)
+{
+	pthread_mutex_unlock(&mutex);
+}
+
+void openocd_sleep_postlude(void)
+{
+	pthread_mutex_lock(&mutex);
+}
+
+
+
 int loadFile(const char *name, void **data, size_t *len);
 
 static const char *appendf(const char *prev, const char *format, ...)
@@ -184,7 +198,9 @@
 
 	if (r->postprocessor)
 	{
+		openocd_sleep_postlude();
 		MHD_destroy_post_processor(r->postprocessor);
+		openocd_sleep_prelude();
 	}
 
 	free(r);
@@ -257,7 +273,7 @@
 }
 
 
-int handle_request(struct MHD_Connection * connection, const char * url)
+static int handle_request(struct MHD_Connection * connection, const char * url)
 {
 	struct MHD_Response * response;
 
@@ -335,7 +351,7 @@
 	}
 }
 
-static int ahc_echo(void * cls, struct MHD_Connection * connection,
+static int ahc_echo_inner(void * cls, struct MHD_Connection * connection,
 		const char * url, const char * method, const char * version,
 		const char * upload_data, unsigned int * upload_data_size, void ** ptr)
 {
@@ -423,10 +439,24 @@
 	return result;
 }
 
+
+static int ahc_echo(void * cls, struct MHD_Connection * connection,
+		const char * url, const char * method, const char * version,
+		const char * upload_data, unsigned int * upload_data_size, void ** ptr)
+{
+	int result;
+
+	openocd_sleep_postlude();
+
+	result = ahc_echo_inner(cls, connection, url, method, version, upload_data, upload_data_size, ptr);
+
+	openocd_sleep_prelude();
+
+	return result;
+}
+
 static struct MHD_Daemon * d;
-static pthread_mutex_t mutex;
 
-
 int httpd_start(void)
 {
 	pthread_mutexattr_t attr;
@@ -464,13 +494,3 @@
 	pthread_mutex_destroy(&mutex);
 }
 
-void openocd_sleep_prelude(void)
-{
-	pthread_mutex_unlock(&mutex);
-}
-
-void openocd_sleep_postlude(void)
-{
-	pthread_mutex_lock(&mutex);
-}
-



From dbrownell at mail.berlios.de  Tue Sep 29 20:06:27 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Tue, 29 Sep 2009 20:06:27 +0200
Subject: [Openocd-svn] r2772 - trunk/src/target
Message-ID: <200909291806.n8TI6Rt0001866@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-29 20:06:26 +0200 (Tue, 29 Sep 2009)
New Revision: 2772

Modified:
   trunk/src/target/etb.c
   trunk/src/target/etb.h
Log:
ETB: cleanup needless symbol exports and forward decls.


Modified: trunk/src/target/etb.c
===================================================================
--- trunk/src/target/etb.c	2009-09-29 14:24:02 UTC (rev 2771)
+++ trunk/src/target/etb.c	2009-09-29 18:06:26 UTC (rev 2772)
@@ -96,6 +96,33 @@
 	return ERROR_OK;
 }
 
+static int etb_read_reg_w_check(reg_t *, uint8_t *, uint8_t *);
+static int etb_set_reg_w_exec(reg_t *, uint8_t *);
+
+static int etb_read_reg(reg_t *reg)
+{
+	return etb_read_reg_w_check(reg, NULL, NULL);
+}
+
+static int etb_get_reg(reg_t *reg)
+{
+	int retval;
+
+	if ((retval = etb_read_reg(reg)) != ERROR_OK)
+	{
+		LOG_ERROR("BUG: error scheduling etm register read");
+		return retval;
+	}
+
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
+	{
+		LOG_ERROR("register read failed");
+		return retval;
+	}
+
+	return ERROR_OK;
+}
+
 reg_cache_t* etb_build_reg_cache(etb_t *etb)
 {
 	reg_cache_t *reg_cache = malloc(sizeof(reg_cache_t));
@@ -138,29 +165,10 @@
 	return reg_cache;
 }
 
-static int etb_get_reg(reg_t *reg)
+static void etb_getbuf(jtag_callback_data_t arg)
 {
-	int retval;
+	uint8_t *in = (uint8_t *)arg;
 
-	if ((retval = etb_read_reg(reg)) != ERROR_OK)
-	{
-		LOG_ERROR("BUG: error scheduling etm register read");
-		return retval;
-	}
-
-	if ((retval = jtag_execute_queue()) != ERROR_OK)
-	{
-		LOG_ERROR("register read failed");
-		return retval;
-	}
-
-	return ERROR_OK;
-}
-
-
-static void etb_getbuf(jtag_callback_data_t arg)
-{
-  uint8_t *in = (uint8_t *)arg;
 	*((uint32_t *)in) = buf_get_u32(in, 0, 32);
 }
 
@@ -218,7 +226,8 @@
 	return ERROR_OK;
 }
 
-int etb_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask)
+static int etb_read_reg_w_check(reg_t *reg,
+		uint8_t* check_value, uint8_t* check_mask)
 {
 	etb_reg_t *etb_reg = reg->arch_info;
 	uint8_t reg_addr = etb_reg->addr & 0x7f;
@@ -271,12 +280,9 @@
 	return ERROR_OK;
 }
 
-int etb_read_reg(reg_t *reg)
-{
-	return etb_read_reg_w_check(reg, NULL, NULL);
-}
+static int etb_write_reg(reg_t *, uint32_t);
 
-int etb_set_reg(reg_t *reg, uint32_t value)
+static int etb_set_reg(reg_t *reg, uint32_t value)
 {
 	int retval;
 
@@ -293,7 +299,7 @@
 	return ERROR_OK;
 }
 
-int etb_set_reg_w_exec(reg_t *reg, uint8_t *buf)
+static int etb_set_reg_w_exec(reg_t *reg, uint8_t *buf)
 {
 	int retval;
 
@@ -307,7 +313,7 @@
 	return ERROR_OK;
 }
 
-int etb_write_reg(reg_t *reg, uint32_t value)
+static int etb_write_reg(reg_t *reg, uint32_t value)
 {
 	etb_reg_t *etb_reg = reg->arch_info;
 	uint8_t reg_addr = etb_reg->addr & 0x7f;
@@ -345,11 +351,6 @@
 	return ERROR_OK;
 }
 
-int etb_store_reg(reg_t *reg)
-{
-	return etb_write_reg(reg, buf_get_u32(reg->value, 0, reg->size));
-}
-
 static int etb_register_commands(struct command_context_s *cmd_ctx)
 {
 	command_t *etb_cmd;

Modified: trunk/src/target/etb.h
===================================================================
--- trunk/src/target/etb.h	2009-09-29 14:24:02 UTC (rev 2771)
+++ trunk/src/target/etb.h	2009-09-29 18:06:26 UTC (rev 2772)
@@ -57,11 +57,5 @@
 extern etm_capture_driver_t etb_capture_driver;
 
 extern reg_cache_t* etb_build_reg_cache(etb_t *etb);
-extern int etb_read_reg(reg_t *reg);
-extern int etb_write_reg(reg_t *reg, uint32_t value);
-extern int etb_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
-extern int etb_store_reg(reg_t *reg);
-extern int etb_set_reg(reg_t *reg, uint32_t value);
-extern int etb_set_reg_w_exec(reg_t *reg, uint8_t *buf);
 
 #endif /* ETB_H */



From dbrownell at mail.berlios.de  Tue Sep 29 20:08:16 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Tue, 29 Sep 2009 20:08:16 +0200
Subject: [Openocd-svn] r2773 - trunk/src/target
Message-ID: <200909291808.n8TI8Gim002706@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-29 20:08:16 +0200 (Tue, 29 Sep 2009)
New Revision: 2773

Modified:
   trunk/src/target/etm.c
Log:
ETM: fix build issue on MinGW.

The Win32 global namespace is rather cluttered...


Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-09-29 18:06:26 UTC (rev 2772)
+++ trunk/src/target/etm.c	2009-09-29 18:08:16 UTC (rev 2773)
@@ -68,6 +68,7 @@
 
 /*
  * Registers 0..0x7f are JTAG-addressable using scanchain 6.
+ * (Or on some processors, through coprocessor operations.)
  * Newer versions of ETM make some W/O registers R/W, and
  * provide definitions for some previously-unused bits.
  */
@@ -154,7 +155,7 @@
 };
 
 static const struct etm_reg_info etm_counters[] = {
-#define COUNTER(i) \
+#define ETM_COUNTER(i) \
 		{ ETM_COUNTER_RELOAD_VALUE + (i), 16, WO, 0x10, \
 				"ETM_COUNTER_RELOAD_VALUE" #i, }, \
 		{ ETM_COUNTER_ENABLE + (i), 18, WO, 0x10, \
@@ -163,38 +164,38 @@
 				"ETM_COUNTER_RELOAD_EVENT" #i, }, \
 		{ ETM_COUNTER_VALUE + (i), 16, RO, 0x10, \
 				"ETM_COUNTER_VALUE" #i, }
-	COUNTER(0),
-	COUNTER(1),
-	COUNTER(2),
-	COUNTER(3),
-#undef COUNTER
+	ETM_COUNTER(0),
+	ETM_COUNTER(1),
+	ETM_COUNTER(2),
+	ETM_COUNTER(3),
+#undef ETM_COUNTER
 };
 
 static const struct etm_reg_info etm_sequencer[] = {
-#define SEQ(i) \
+#define ETM_SEQ(i) \
 		{ ETM_SEQUENCER_EVENT + (i), 17, WO, 0x10, \
 				"ETM_SEQUENCER_EVENT" #i, }
-	SEQ(0),				/* 1->2 */
-	SEQ(1),				/* 2->1 */
-	SEQ(2),				/* 2->3 */
-	SEQ(3),				/* 3->1 */
-	SEQ(4),				/* 3->2 */
-	SEQ(5),				/* 1->3 */
-#undef SEQ
+	ETM_SEQ(0),				/* 1->2 */
+	ETM_SEQ(1),				/* 2->1 */
+	ETM_SEQ(2),				/* 2->3 */
+	ETM_SEQ(3),				/* 3->1 */
+	ETM_SEQ(4),				/* 3->2 */
+	ETM_SEQ(5),				/* 1->3 */
+#undef ETM_SEQ
 	/* 0x66 reserved */
 	{ ETM_SEQUENCER_STATE,  2, RO, 0x10, "ETM_SEQUENCER_STATE", },
 };
 
 static const struct etm_reg_info etm_outputs[] = {
-#define OUT(i) \
+#define ETM_OUTPUT(i) \
 		{ ETM_EXTERNAL_OUTPUT + (i), 17, WO, 0x10, \
 				"ETM_EXTERNAL_OUTPUT" #i, }
 
-	OUT(0),
-	OUT(1),
-	OUT(2),
-	OUT(3),
-#undef OUT
+	ETM_OUTPUT(0),
+	ETM_OUTPUT(1),
+	ETM_OUTPUT(2),
+	ETM_OUTPUT(3),
+#undef ETM_OUTPUT
 };
 
 #if 0



From dbrownell at mail.berlios.de  Tue Sep 29 20:20:31 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Tue, 29 Sep 2009 20:20:31 +0200
Subject: [Openocd-svn] r2774 - trunk/doc
Message-ID: <200909291820.n8TIKVWT004224@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-29 20:20:30 +0200 (Tue, 29 Sep 2009)
New Revision: 2774

Modified:
   trunk/doc/openocd.texi
Log:
Doc updates:  add section on target software changes, minor fixes


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-29 18:08:16 UTC (rev 2773)
+++ trunk/doc/openocd.texi	2009-09-29 18:20:30 UTC (rev 2774)
@@ -845,7 +845,55 @@
 Other helper scripts might be used to write production system images,
 involving considerably more than just a three stage bootloader.
 
+ at section Target Software Changes
 
+Sometimes you may want to make some small changes to the software
+you're developing, to help make JTAG debugging work better.
+For example, in C or assembly language code you might
+use @code{#ifdef JTAG_DEBUG} (or its converse) around code
+handling issues like:
+
+ at itemize @bullet
+
+ at item @b{ARM Wait-For-Interrupt}...
+Many ARM chips synchronize the JTAG clock using the core clock.
+Low power states which stop that core clock thus prevent JTAG access.
+Idle loops in tasking environments often enter those low power states
+via the @code{WFI} instruction (or its coprocessor equivalent, before ARMv7).
+
+You may want to @emph{disable that instruction} in source code,
+or otherwise prevent using that state,
+to ensure you can get JTAG access at any time.
+For example, the OpenOCD @command{halt} command may not
+work for an idle processor otherwise.
+
+ at item @b{Delay after reset}...
+Not all chips have good support for debugger access
+right after reset; many LPC2xxx chips have issues here.
+Similarly, applications that reconfigure pins used for
+JTAG access as they start will also block debugger access.
+
+To work with boards like this, @emph{enable a short delay loop}
+the first thing after reset, before "real" startup activities.
+For example, one second's delay is usually more than enough
+time for a JTAG debugger to attach, so that
+early code execution can be debugged
+or firmware can be replaced.
+
+ at item @b{Debug Communications Channel (DCC)}...
+Some processors include mechanisms to send messages over JTAG.
+Many ARM cores support these, as do some cores from other vendors.
+(OpenOCD may be able to use this DCC internally, speeding up some
+operations like writing to memory.)
+
+Your application may want to deliver various debugging messages
+over JTAG, by @emph{linking with a small library of code}
+provided with OpenOCD and using the utilities there to send
+various kinds of message.
+ at xref{Software Debug Messages and Tracing}.
+
+ at end itemize
+
 @node Config File Guidelines
 @chapter Config File Guidelines
 
@@ -2462,7 +2510,7 @@
 by sending it a @option{tap-disable} event.
 Returns the string "1" if the tap
 specified by @var{dotted.name} is enabled,
-and "0" if it is disbabled.
+and "0" if it is disabled.
 @end deffn
 
 @deffn Command {jtag tapenable} dotted.name
@@ -2470,13 +2518,13 @@
 by sending it a @option{tap-enable} event.
 Returns the string "1" if the tap
 specified by @var{dotted.name} is enabled,
-and "0" if it is disbabled.
+and "0" if it is disabled.
 @end deffn
 
 @deffn Command {jtag tapisenabled} dotted.name
 Returns the string "1" if the tap
 specified by @var{dotted.name} is enabled,
-and "0" if it is disbabled.
+and "0" if it is disabled.
 
 @quotation Note
 Humans will find the @command{scan_chain} command more helpful
@@ -5600,7 +5648,7 @@
 otherwise the libdcc format is used.
 @end deffn
 
- at deffn Command {trace history} (@option{clear}|count)
+ at deffn Command {trace history} [@option{clear}|count]
 With no parameter, displays all the trace points that have triggered
 in the order they triggered.
 With the parameter @option{clear}, erases all current trace history records.
@@ -5608,7 +5656,7 @@
 history records.
 @end deffn
 
- at deffn Command {trace point} (@option{clear}|identifier)
+ at deffn Command {trace point} [@option{clear}|identifier]
 With no parameter, displays all trace point identifiers and how many times
 they have been triggered.
 With the parameter @option{clear}, erases all current trace point counters.



From dbrownell at mail.berlios.de  Tue Sep 29 20:26:23 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Tue, 29 Sep 2009 20:26:23 +0200
Subject: [Openocd-svn] r2775 - in trunk: doc src/jtag
Message-ID: <200909291826.n8TIQN7J004867@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-29 20:26:18 +0200 (Tue, 29 Sep 2009)
New Revision: 2775

Modified:
   trunk/doc/openocd.texi
   trunk/src/jtag/core.c
Log:
Make "-expected-id 0" suppress warnings; not unlike it used to do.


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-29 18:20:30 UTC (rev 2774)
+++ trunk/doc/openocd.texi	2009-09-29 18:26:18 UTC (rev 2775)
@@ -1253,7 +1253,7 @@
 values for @code{CHIPNAME}, so
 it adds a different TAP each time.
 
-If there are one or more nonzero @option{-expected-id} values,
+If there are nonzero @option{-expected-id} values,
 OpenOCD attempts to verify the actual tap id against those values.
 It will issue error messages if there is mismatch, which
 can help to pinpoint problems in OpenOCD configurations.
@@ -2373,11 +2373,13 @@
 (the TAP is linked in).
 @xref{Enabling and Disabling TAPs}.
 @item @code{-expected-id} @var{number}
-@*A non-zero value represents the expected 32-bit IDCODE
-found when the JTAG chain is examined.
+@*A non-zero @var{number} represents a 32-bit IDCODE
+which you expect to find when the scan chain is examined.
 These codes are not required by all JTAG devices.
 @emph{Repeat the option} as many times as required if more than one
 ID code could appear (for example, multiple versions).
+Specify @var{number} as zero to suppress warnings about IDCODE
+values that were found but not included in the list.
 @item @code{-ircapture} @var{NUMBER}
 @*The bit pattern loaded by the TAP into the JTAG shift register
 on entry to the @sc{ircapture} state, such as 0x01.

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-29 18:20:30 UTC (rev 2774)
+++ trunk/src/jtag/core.c	2009-09-29 18:26:18 UTC (rev 2775)
@@ -959,10 +959,14 @@
 	{
 		if (tap->idcode == tap->expected_ids[ii])
 			return true;
+
+		/* treat "-expected-id 0" as a "don't-warn" wildcard */
+		if (0 == tap->expected_ids[ii])
+			return true;
 	}
 
-	/* If none of the expected ids matched, log an error */
-	jtag_examine_chain_display(LOG_LVL_ERROR, "UNEXPECTED",
+	/* If none of the expected ids matched, warn */
+	jtag_examine_chain_display(LOG_LVL_WARNING, "UNEXPECTED",
 			tap->dotted_name, tap->idcode);
 	for (ii = 0; ii < tap->expected_ids_cnt; ii++)
 	{
@@ -1025,7 +1029,7 @@
 		}
 		tap->idcode = idcode;
 
-		// ensure the TAP ID does matches what was expected
+		/* ensure the TAP ID matches what was expected */
 		if (!jtag_examine_chain_match_tap(tap))
 			return ERROR_JTAG_INIT_FAILED;
 	}



From dbrownell at mail.berlios.de  Tue Sep 29 20:30:07 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Tue, 29 Sep 2009 20:30:07 +0200
Subject: [Openocd-svn] r2776 - in trunk: doc src/target
Message-ID: <200909291830.n8TIU7Qv005367@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-29 20:30:06 +0200 (Tue, 29 Sep 2009)
New Revision: 2776

Modified:
   trunk/doc/openocd.texi
   trunk/src/target/arm11.c
Log:
ARM11 command handling fixes

 - Commands were supposed to have been "arm11 memwrite ..."
   not "memwrite ..."
 - Get rid of obfuscatory macros
 - Re-alphabetize
 - Add docs for "arm11 vcr"


Modified: trunk/doc/openocd.texi
===================================================================
--- trunk/doc/openocd.texi	2009-09-29 18:26:18 UTC (rev 2775)
+++ trunk/doc/openocd.texi	2009-09-29 18:30:06 UTC (rev 2776)
@@ -5496,10 +5496,23 @@
 @deffn Command {arm11 step_irq_enable}  [value]
 Displays the value of the flag controlling whether
 IRQs are enabled during single stepping;
-they is disabled by default.
+they are disabled by default.
 If @var{value} is defined, first assigns that.
 @end deffn
 
+ at deffn Command {arm11 vcr} [value]
+ at cindex vector_catch
+Displays the value of the @emph{Vector Catch Register (VCR)},
+coprocessor 14 register 7.
+If @var{value} is defined, first assigns that.
+
+Vector Catch hardware provides dedicated breakpoints
+for certain hardware events.
+The specific bit values are core-specific (as in fact is using
+coprocessor 14 register 7 itself) but all current ARM11
+cores @emph{except the ARM1176} use the same six bits.
+ at end deffn
+
 @section ARMv7 Architecture
 @cindex ARMv7
 

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-09-29 18:26:18 UTC (rev 2775)
+++ trunk/src/target/arm11.c	2009-09-29 18:30:06 UTC (rev 2776)
@@ -1905,19 +1905,6 @@
 	return arm11_handle_bool(cmd_ctx, cmd, args, argc, &arm11_config_##name, print_name); \
 }
 
-#define RC_TOP(name, descr, more)  \
-{ \
-	command_t * new_cmd = register_command(cmd_ctx, top_cmd, name, NULL, COMMAND_ANY, descr);  \
-	command_t * top_cmd = new_cmd; \
-	more \
-}
-
-#define RC_FINAL(name, descr, handler)	\
-	register_command(cmd_ctx, top_cmd, name, handler, COMMAND_ANY, descr);
-
-#define RC_FINAL_BOOL(name, descr, var)  \
-	register_command(cmd_ctx, top_cmd, name, arm11_handle_bool_##var, COMMAND_ANY, descr);
-
 BOOL_WRAPPER(memwrite_burst,			"memory write burst mode")
 BOOL_WRAPPER(memwrite_error_fatal,		"fatal error mode for memory writes")
 BOOL_WRAPPER(memrw_no_increment,		"\"no increment\" mode for memory transfers")
@@ -2069,36 +2056,49 @@
 {
 	FNC_INFO;
 
-	command_t * top_cmd = NULL;
+	command_t *top_cmd, *mw_cmd;
 
-	RC_TOP("arm11",				"arm11 specific commands",
+	top_cmd = register_command(cmd_ctx, NULL, "arm11",
+			NULL, COMMAND_ANY, NULL);
 
-	RC_TOP("memwrite",				"Control memory write transfer mode",
+	/* "hardware_step" is only here to check if the default
+	 * simulate + breakpoint implementation is broken.
+	 * TEMPORARY! NOT DOCUMENTED!
+	 */
+	register_command(cmd_ctx, top_cmd, "hardware_step",
+			arm11_handle_bool_hardware_step, COMMAND_ANY,
+			"DEBUG ONLY - Hardware single stepping"
+				" (default: disabled)");
 
-		RC_FINAL_BOOL("burst",				"Enable/Disable non-standard but fast burst mode (default: enabled)",
-						memwrite_burst)
+	register_command(cmd_ctx, top_cmd, "mcr",
+			arm11_handle_mcr, COMMAND_ANY,
+			"Write Coprocessor register");
 
-		RC_FINAL_BOOL("error_fatal",			"Terminate program if transfer error was found (default: enabled)",
-						memwrite_error_fatal)
-) /* memwrite */
+	mw_cmd = register_command(cmd_ctx, top_cmd, "memwrite",
+			NULL, COMMAND_ANY, NULL);
+	register_command(cmd_ctx, mw_cmd, "burst",
+			arm11_handle_bool_memwrite_burst, COMMAND_ANY,
+			"Enable/Disable non-standard but fast burst mode"
+				" (default: enabled)");
+	register_command(cmd_ctx, mw_cmd, "error_fatal",
+			arm11_handle_bool_memwrite_error_fatal, COMMAND_ANY,
+			"Terminate program if transfer error was found"
+				" (default: enabled)");
 
-	RC_FINAL_BOOL("no_increment",			"Don't increment address on multi-read/-write (default: disabled)",
-						memrw_no_increment)
+	register_command(cmd_ctx, top_cmd, "mrc",
+			arm11_handle_mrc, COMMAND_ANY,
+			"Read Coprocessor register");
+	register_command(cmd_ctx, top_cmd, "no_increment",
+			arm11_handle_bool_memrw_no_increment, COMMAND_ANY,
+			"Don't increment address on multi-read/-write"
+				" (default: disabled)");
+	register_command(cmd_ctx, top_cmd, "step_irq_enable",
+			arm11_handle_bool_step_irq_enable, COMMAND_ANY,
+			"Enable interrupts while stepping"
+				" (default: disabled)");
+	register_command(cmd_ctx, top_cmd, "vcr",
+			arm11_handle_vcr, COMMAND_ANY,
+			"Control (Interrupt) Vector Catch Register");
 
-RC_FINAL_BOOL("step_irq_enable",		"Enable interrupts while stepping (default: disabled)",
-					step_irq_enable)
-RC_FINAL_BOOL("hardware_step",		"hardware single stepping. By default use simulate + breakpoint. This command is only here to check if simulate + breakpoint implementation is broken.",
-					hardware_step)
-
-	RC_FINAL("vcr",					"Control (Interrupt) Vector Catch Register",
-						arm11_handle_vcr)
-
-	RC_FINAL("mrc",					"Read Coprocessor register",
-						arm11_handle_mrc)
-
-	RC_FINAL("mcr",					"Write Coprocessor register",
-						arm11_handle_mcr)
-) /* arm11 */
-
 	return ERROR_OK;
 }



From dbrownell at mail.berlios.de  Tue Sep 29 21:28:10 2009
From: dbrownell at mail.berlios.de (dbrownell at BerliOS)
Date: Tue, 29 Sep 2009 21:28:10 +0200
Subject: [Openocd-svn] r2777 - trunk/src/jtag
Message-ID: <200909291928.n8TJSAP5011900@sheep.berlios.de>

Author: dbrownell
Date: 2009-09-29 21:28:08 +0200 (Tue, 29 Sep 2009)
New Revision: 2777

Modified:
   trunk/src/jtag/core.c
Log:
Streamline Capture-IR validation code

 - Don't issue needless JTAG resets ... only do them after
   errors. Normal exit now leaves every TAP in BYPASS.
   
 - Fix an unlikely memory leak on one fault path.

 - Remove the oddball limitation that invalid capture LSBs 
   trigger errors only for TAPs that support IDCODE.

Re the JTAG reset:  there are too many of them, and they can
(and do!) change system state.  So the needless ones should
get removed.  This one was especially pointless.


Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-09-29 18:30:06 UTC (rev 2776)
+++ trunk/src/jtag/core.c	2009-09-29 19:28:08 UTC (rev 2777)
@@ -1058,6 +1058,9 @@
  * Validate the date loaded by entry to the Capture-IR state, to help
  * find errors related to scan chain configuration (wrong IR lengths)
  * or communication.
+ *
+ * Entry state can be anything.  On non-error exit, all TAPs are in
+ * bypass mode.  On error exits, the scan chain is reset.
  */
 static int jtag_validate_ircapture(void)
 {
@@ -1066,23 +1069,21 @@
 	uint8_t *ir_test = NULL;
 	scan_field_t field;
 	int chain_pos = 0;
+	int retval;
 
-	tap = NULL;
-	total_ir_length = 0;
-	for (;;) {
-		tap = jtag_tap_next_enabled(tap);
-		if (tap == NULL) {
-			break;
-		}
-		total_ir_length += tap->ir_length;
-	}
+	for (tap = NULL, total_ir_length = 0;
+			(tap = jtag_tap_next_enabled(tap)) != NULL;
+			total_ir_length += tap->ir_length)
+		continue;
 
+	/* increase length to add 2 bit sentinel after scan */
 	total_ir_length += 2;
 
 	ir_test = malloc(CEIL(total_ir_length, 8));
 	if (ir_test == NULL)
 		return ERROR_FAIL;
 
+	/* after this scan, all TAPs will capture BYPASS instructions */
 	buf_set_ones(ir_test, total_ir_length);
 
 	field.tap = NULL;
@@ -1090,14 +1091,12 @@
 	field.out_value = ir_test;
 	field.in_value = ir_test;
 
+	jtag_add_plain_ir_scan(1, &field, TAP_IDLE);
 
-	jtag_add_plain_ir_scan(1, &field, TAP_IRPAUSE);
-	jtag_add_tlr();
-
-	int retval;
+	LOG_DEBUG("IR capture validation scan");
 	retval = jtag_execute_queue();
 	if (retval != ERROR_OK)
-		return retval;
+		goto done;
 
 	tap = NULL;
 	chain_pos = 0;
@@ -1119,14 +1118,9 @@
 			LOG_ERROR("%s: IR capture error; saw 0x%s not 0x..1",
 					jtag_tap_name(tap), cbuf);
 
-			/* Fail only if we have IDCODE for this device.
-			 * REVISIT -- why not fail-always?
-			 */
-			if (tap->hasidcode) {
-				free(cbuf);
-				free(ir_test);
-				return ERROR_JTAG_INIT_FAILED;
-			}
+			free(cbuf);
+			retval = ERROR_JTAG_INIT_FAILED;
+			goto done;
 		}
 		chain_pos += tap->ir_length;
 	}
@@ -1140,13 +1134,16 @@
 		LOG_ERROR("IR capture error at bit %d, saw 0x%s not 0x...3",
 				chain_pos, cbuf);
 		free(cbuf);
-		free(ir_test);
-		return ERROR_JTAG_INIT_FAILED;
+		retval = ERROR_JTAG_INIT_FAILED;
 	}
 
+done:
 	free(ir_test);
-
-	return ERROR_OK;
+	if (retval != ERROR_OK) {
+		jtag_add_tlr();
+		jtag_execute_queue();
+	}
+	return retval;
 }
 
 



From oharboe at mail.berlios.de  Wed Sep 30 07:37:41 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 30 Sep 2009 07:37:41 +0200
Subject: [Openocd-svn] r2778 - in trunk/tcl: board target
Message-ID: <200909300537.n8U5bfT7013886@sheep.berlios.de>

Author: oharboe
Date: 2009-09-30 07:37:32 +0200 (Wed, 30 Sep 2009)
New Revision: 2778

Modified:
   trunk/tcl/board/telo.cfg
   trunk/tcl/target/c100config.tcl
   trunk/tcl/target/telo.cfg
Log:
michal smulski <michal.smulski at ooma.com> reset now works

Modified: trunk/tcl/board/telo.cfg
===================================================================
--- trunk/tcl/board/telo.cfg	2009-09-29 19:28:08 UTC (rev 2777)
+++ trunk/tcl/board/telo.cfg	2009-09-30 05:37:32 UTC (rev 2778)
@@ -1,33 +1,34 @@
-source [find target/c100.cfg]
+source [find c100.cfg]
 # basic register defintion for C100
-source [find target/c100regs.tcl]
+source [find c100regs.tcl]
 # board-config info
-source [find target/c100config.tcl]
+source [find c100config.tcl]
 # C100 helper functions
-source [find target/c100helper.tcl]
+source [find c100helper.tcl]
 
 
 # Telo board & C100 support trst and srst
-# however openocd does not support
-# 1. setting srst reset pulse width
-# 2. setting delay between srst pulse and JTAG access
-# This really makes the srst useless for now.
+# Note that libftd2xx.so tries to assert srst
+# which break this script
+# use libftdi.so library instead with this script
+# make the reset asserted to 
+# allow RC circuit to discharge for: [ms]
+jtag_nsrst_assert_width 100
+jtag_ntrst_assert_width 100
+# don't talk to JTAG after reset for: [ms]
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
 reset_config trst_and_srst separate
 
 
 
+
 # issue telnet: reset init
 # issue gdb: monitor reset init
 $_TARGETNAME configure -event reset-init {
 	jtag_khz 100
-	# setup GPIO used as control signals for C100
-	setupGPIO
-	# This will allow acces to lower 8MB or NOR
-	lowGPIO5
-	# setup NOR size,timing,etc.
-	setupNOR
-	# setup internals + PLL + DDR2
-	initC100
+	# this will setup Telo board
+	setupTelo
 	#turn up the JTAG speed
 	jtag_khz 3000
 	puts "JTAG speek now 3MHz"
@@ -38,10 +39,15 @@
 	# Force target into ARM state.
 #	soft_reset_halt # not implemented on ARM11
 	puts "Detected SRSRT asserted on C100.CPU"
+	
+}
 
+$_TARGETNAME configure -event reset-assert-post {
+  puts "Assering reset"
+  #sleep 10
 }
 
-proc power_restore {} { puts "Sensed power restore. No action." }
+proc power_restore {} { puts "Sensed power restore. No action." } 
 proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }
 
 

Modified: trunk/tcl/target/c100config.tcl
===================================================================
--- trunk/tcl/target/c100config.tcl	2009-09-29 19:28:08 UTC (rev 2777)
+++ trunk/tcl/target/c100config.tcl	2009-09-30 05:37:32 UTC (rev 2778)
@@ -3,7 +3,7 @@
 
 # set CFG_REFCLKFREQ [configC100 CFG_REFCLKFREQ]
 proc config {label} {
-    return [dict get [configC100] $label ]
+    return [dict get [configC100] $label ]	
 }
 
 # show the value for the param. with label
@@ -15,7 +15,7 @@
 # when there are more then one board config
 # use soft links to c100board-config.tcl
 # so that only the right board-config gets
-# included (just like include/configs/board-configs.h
+# included (just like include/configs/board-configs.h 
 # in u-boot.
 proc configC100 {} {
     # xtal freq. 24MHz
@@ -28,7 +28,7 @@
     # y = amba_clk * (w+1)*(x+1)*2/xtal_clk
     dict set configC100 y_amba [expr ([dict get $configC100 CONFIG_SYS_HZ_CLOCK] * ( ([dict get $configC100 w_amba]+1 ) * ([dict get $configC100 x_amba]+1 ) *2 ) / [dict get $configC100 CFG_REFCLKFREQ]) ]
 
-    # Arm Clk 450MHz, must be a multiple of 25 MHz
+    # Arm Clk 450MHz, must be a multiple of 25 MHz 
     dict set configC100 CFG_ARM_CLOCK      450000000
     dict set configC100 w_arm 0
     dict set configC100 x_arm 1
@@ -38,20 +38,34 @@
 
 }
 
+# This should be called for reset init event handler
+proc setupTelo {} {
+
+    # setup GPIO used as control signals for C100
+    setupGPIO
+    # This will allow acces to lower 8MB or NOR
+    lowGPIO5 
+    # setup NOR size,timing,etc.
+    setupNOR
+    # setup internals + PLL + DDR2
+    initC100
+}
+
+
 proc setupNOR {} {
     puts "Setting up NOR: 16MB, 16-bit wide bus, CS0"
     # this is taken from u-boot/boards/mindspeed/ooma-darwin/board.c:nor_hw_init()
-    set EX_CSEN_REG	    [regs EX_CSEN_REG ]
-    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]
-    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]
-    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]
-    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]
-    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]
+    set EX_CSEN_REG	    [regs EX_CSEN_REG ]	
+    set EX_CS0_SEG_REG	    [regs EX_CS0_SEG_REG ]	
+    set EX_CS0_CFG_REG	    [regs EX_CS0_CFG_REG ]	
+    set EX_CS0_TMG1_REG	    [regs EX_CS0_TMG1_REG ]	
+    set EX_CS0_TMG2_REG	    [regs EX_CS0_TMG2_REG ]	
+    set EX_CS0_TMG3_REG	    [regs EX_CS0_TMG3_REG ]	
     set EX_CLOCK_DIV_REG    [regs EX_CLOCK_DIV_REG ]
-    set EX_MFSM_REG	    [regs EX_MFSM_REG ]
-    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]
-    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]
-    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]
+    set EX_MFSM_REG	    [regs EX_MFSM_REG ]	
+    set EX_CSFSM_REG	    [regs EX_CSFSM_REG ]	
+    set EX_WRFSM_REG	    [regs EX_WRFSM_REG ]	
+    set EX_RDFSM_REG	    [regs EX_RDFSM_REG ]	
 
     # enable Expansion Bus Clock + CS0 (NOR)
     mww $EX_CSEN_REG 0x3
@@ -62,7 +76,7 @@
     # set timings to NOR
     mww $EX_CS0_TMG1_REG 0x03034006
     mww $EX_CS0_TMG2_REG 0x04040002
-    #mww $EX_CS0_TMG3_REG
+    #mww $EX_CS0_TMG3_REG 
     # set EBUS clock 165/5=33MHz
     mww $EX_CLOCK_DIV_REG 0x5
     # everthing else is OK with default
@@ -72,7 +86,7 @@
     set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]
     set BLOCK_RESET_REG	       [regs BLOCK_RESET_REG]
     set DDR_RST		       [regs DDR_RST]
-
+ 
     # put DDR controller in reset (so that it comes reset in u-boot)
     mmw $BLOCK_RESET_REG 0x0 $DDR_RST
     # setup CS0 controller for NOR
@@ -93,8 +107,8 @@
     #GPIO17 reset for DECT module.
     #GPIO29 CS_n for NAND
 
-    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
-    set GPIO_OE_REG		    [regs GPIO_OE_REG]
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
+    set GPIO_OE_REG		    [regs GPIO_OE_REG]	
 
     # set GPIO29=GPIO17=1, GPIO5=0
     mww $GPIO_OUTPUT_REG [expr 1<<29 | 1<<17]
@@ -104,14 +118,14 @@
 
 proc highGPIO5 {} {
     puts "GPIO5 high"
-    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
     # set GPIO5=1
     mmw $GPIO_OUTPUT_REG [expr 1 << 5] 0x0
 }
 
 proc lowGPIO5 {} {
     puts "GPIO5 low"
-    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]
+    set GPIO_OUTPUT_REG		    [regs GPIO_OUTPUT_REG]	
     # set GPIO5=0
     mmw $GPIO_OUTPUT_REG 0x0 [expr 1 << 5]
 }
@@ -119,31 +133,32 @@
 proc boardID {id} {
     # so far built:
     # 4'b1111
-    dict set boardID 15 name "EVT1"
+    dict set boardID 15 name "EVT1"		
     dict set boardID 15 ddr2size 128M
     # dict set boardID 15 nandsize 1G
     # dict set boardID 15 norsize 16M
     # 4'b0000
-    dict set boardID 0 name "EVT2"
+    dict set boardID 0 name "EVT2"		
     dict set boardID 0 ddr2size 128M
     # 4'b0001
-    dict set boardID 1 name "EVT3"
+    dict set boardID 1 name "EVT3"		
     dict set boardID 1 ddr2size 256M
     # 4'b1110
     dict set boardID 14 name "EVT3_old"
     dict set boardID 14 ddr2size 128M
     # 4'b0010
-    dict set boardID 2 name "EVT4"
+    dict set boardID 2 name "EVT4"		
     dict set boardID 2 ddr2size 256M
 
     return $boardID
 }
 
+
 # converted from u-boot/boards/mindspeed/ooma-darwin/board.c:ooma_board_detect()
-# figure out what board revision this is, uses BOOTSTRAP register to read stuffed resistors
+# figure out what board revision this is, uses BOOTSTRAP register to read stuffed resistors 
 proc ooma_board_detect {} {
     set GPIO_BOOTSTRAP_REG	[regs GPIO_BOOTSTRAP_REG]
-
+    
     # read the current value of the BOOTSRAP pins
     set tmp [mrw $GPIO_BOOTSTRAP_REG]
     puts [format "GPIO_BOOTSTRAP_REG  (0x%x): 0x%x" $GPIO_BOOTSTRAP_REG $tmp]
@@ -152,12 +167,77 @@
 
     # display board ID
     puts [format "This is %s (0x%x)" [dict get [boardID $gpbt] $gpbt name] $gpbt]
+    # show it on serial console
+    putsUART0 [format "This is %s (0x%x)\n" [dict get [boardID $gpbt] $gpbt name] $gpbt]
     # return the ddr2 size, used to configure DDR2 on a given board.
     return [dict get [boardID $gpbt] $gpbt ddr2size]
 }
 
 proc configureDDR2regs_256M {} {
-    puts "ConfigureDDR2regs_256M TBD"
+    
+    set DENALI_CTL_00_DATA    [regs DENALI_CTL_00_DATA]
+    set DENALI_CTL_01_DATA    [regs DENALI_CTL_01_DATA]
+    set DENALI_CTL_02_DATA    [regs DENALI_CTL_02_DATA]
+    set DENALI_CTL_03_DATA    [regs DENALI_CTL_03_DATA]
+    set DENALI_CTL_04_DATA    [regs DENALI_CTL_04_DATA]
+    set DENALI_CTL_05_DATA    [regs DENALI_CTL_05_DATA]
+    set DENALI_CTL_06_DATA    [regs DENALI_CTL_06_DATA]
+    set DENALI_CTL_07_DATA    [regs DENALI_CTL_07_DATA]
+    set DENALI_CTL_08_DATA    [regs DENALI_CTL_08_DATA]
+    set DENALI_CTL_09_DATA    [regs DENALI_CTL_09_DATA]
+    set DENALI_CTL_10_DATA    [regs DENALI_CTL_10_DATA]
+    set DENALI_CTL_11_DATA    [regs DENALI_CTL_11_DATA]
+    set DENALI_CTL_12_DATA    [regs DENALI_CTL_12_DATA]
+    set DENALI_CTL_13_DATA    [regs DENALI_CTL_13_DATA]
+    set DENALI_CTL_14_DATA    [regs DENALI_CTL_14_DATA]
+    set DENALI_CTL_15_DATA    [regs DENALI_CTL_15_DATA]
+    set DENALI_CTL_16_DATA    [regs DENALI_CTL_16_DATA]
+    set DENALI_CTL_17_DATA    [regs DENALI_CTL_17_DATA]
+    set DENALI_CTL_18_DATA    [regs DENALI_CTL_18_DATA]
+    set DENALI_CTL_19_DATA    [regs DENALI_CTL_19_DATA]
+    set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]
+
+    set DENALI_CTL_02_VAL 0x0100000000010100
+    set DENALI_CTL_11_VAL 0x433a32164a560a00
+
+    mw64bit $DENALI_CTL_00_DATA  0x0100000101010101
+    # 01_DATA mod [40]=1, enable BA2
+    mw64bit $DENALI_CTL_01_DATA  0x0100010100000001
+    mw64bit $DENALI_CTL_02_DATA  $DENALI_CTL_02_VAL
+    mw64bit $DENALI_CTL_03_DATA  0x0102020202020201
+    mw64bit $DENALI_CTL_04_DATA  0x0000010100000001
+    mw64bit $DENALI_CTL_05_DATA  0x0203010300010101
+    mw64bit $DENALI_CTL_06_DATA  0x060a020200020202
+    mw64bit $DENALI_CTL_07_DATA  0x0000000300000206 
+    mw64bit $DENALI_CTL_08_DATA  0x6400003f3f0a0209
+    mw64bit $DENALI_CTL_09_DATA  0x1a000000001a1a1a
+    mw64bit $DENALI_CTL_10_DATA  0x0120202020191a18
+    # 11_DATA mod [39-32]=16,more refresh
+    mw64bit $DENALI_CTL_11_DATA  $DENALI_CTL_11_VAL
+    mw64bit $DENALI_CTL_12_DATA  0x0000000000000800
+    mw64bit $DENALI_CTL_13_DATA  0x0010002000100040
+    mw64bit $DENALI_CTL_14_DATA  0x0010004000100040
+    mw64bit $DENALI_CTL_15_DATA  0x04f8000000000000
+    mw64bit $DENALI_CTL_16_DATA  0x000000002cca0000
+    mw64bit $DENALI_CTL_17_DATA  0x0000000000000000
+    mw64bit $DENALI_CTL_18_DATA  0x0302000000000000
+    mw64bit $DENALI_CTL_19_DATA  0x00001300c8030600
+    mw64bit $DENALI_CTL_20_DATA  0x0000000081fe00c8 
+    
+    set wr_dqs_shift 0x40
+    # start DDRC
+    mw64bit $DENALI_CTL_02_DATA [expr $DENALI_CTL_02_VAL | (1 << 32)]
+    # wait int_status[2] (DRAM init complete)
+    puts -nonewline "Waiting for DDR2 controller to init..."
+    set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
+    while { [expr $tmp & 0x040000] == 0 } { 
+	sleep 1
+	set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
+    }
+    puts "done."
+
+    # do ddr2 training sequence
+    # TBD (for now, if you need it, run trainDDR command)
 }
 
 # converted from u-boot/cpu/arm1136/comcerto/bsp100.c:config_board99()
@@ -187,9 +267,9 @@
     set DENALI_CTL_20_DATA    [regs DENALI_CTL_20_DATA]
 
 
-    set DENALI_CTL_02_VAL 0x0100010000010100
+    set DENALI_CTL_02_VAL 0x0100010000010100 
     set DENALI_CTL_11_VAL 0x433A42124A650A37
-    # set some default values
+    # set some default values     
     mw64bit $DENALI_CTL_00_DATA  0x0100000101010101
     mw64bit $DENALI_CTL_01_DATA  0x0100000100000101
     mw64bit $DENALI_CTL_02_DATA  $DENALI_CTL_02_VAL
@@ -218,11 +298,12 @@
     # wait int_status[2] (DRAM init complete)
     puts -nonewline "Waiting for DDR2 controller to init..."
     set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
-    while { [expr $tmp & 0x040000] == 0 } {
+    while { [expr $tmp & 0x040000] == 0 } { 
 	sleep 1
 	set tmp [mrw [expr $DENALI_CTL_08_DATA + 4]]
     }
-   mw64bit $DENALI_CTL_11_DATA [expr ($DENALI_CTL_11_VAL  & ~0x00007F0000000000) | ($wr_dqs_shift << 40) ]
+    # This is not necessary
+    #mw64bit $DENALI_CTL_11_DATA [expr ($DENALI_CTL_11_VAL  & ~0x00007F0000000000) | ($wr_dqs_shift << 40) ]
     puts "done."
 
     # do ddr2 training sequence
@@ -237,18 +318,18 @@
     set GPIO_IOCTRL_REG    [regs GPIO_IOCTRL_REG]
     set GPIO_IOCTRL_VAL    [regs GPIO_IOCTRL_VAL]
     set GPIO_IOCTRL_UART0  [regs GPIO_IOCTRL_UART0]
-    set UART0_LCR	            [regs UART0_LCR]
-    set LCR_DLAB		    [regs LCR_DLAB]
-    set UART0_DLL		    [regs UART0_DLL]
-    set UART0_DLH		    [regs UART0_DLH]
-    set UART0_IIR		    [regs UART0_IIR]
-    set UART0_IER		    [regs UART0_IER]
-    set LCR_ONE_STOP		    [regs LCR_ONE_STOP]
-    set LCR_CHAR_LEN_8		    [regs LCR_CHAR_LEN_8]
+    set UART0_LCR	            [regs UART0_LCR]	
+    set LCR_DLAB		    [regs LCR_DLAB]	
+    set UART0_DLL		    [regs UART0_DLL]		
+    set UART0_DLH		    [regs UART0_DLH]	
+    set UART0_IIR		    [regs UART0_IIR]	
+    set UART0_IER		    [regs UART0_IER]	
+    set LCR_ONE_STOP		    [regs LCR_ONE_STOP]		
+    set LCR_CHAR_LEN_8		    [regs LCR_CHAR_LEN_8]		
     set FCR_XMITRES		    [regs FCR_XMITRES]
-    set FCR_RCVRRES		    [regs FCR_RCVRRES]
-    set FCR_FIFOEN		    [regs FCR_FIFOEN]
-    set IER_UUE			    [regs IER_UUE]
+    set FCR_RCVRRES		    [regs FCR_RCVRRES]	
+    set FCR_FIFOEN		    [regs FCR_FIFOEN]	
+    set IER_UUE			    [regs IER_UUE]		
 
     # unlock writing to IOCTRL register
     mww $GPIO_LOCK_REG $GPIO_IOCTRL_VAL
@@ -274,7 +355,7 @@
 
 proc putcUART0 {char} {
 
-    set UART0_LSR	    [regs UART0_LSR]
+    set UART0_LSR	    [regs UART0_LSR]	
     set UART0_THR	    [regs UART0_THR]
     set LSR_TEMT	    [regs LSR_TEMT]
 
@@ -308,17 +389,24 @@
     resume
 }
 
-proc flashUBOOT {} {
+proc flashUBOOT {file} {
     # this will update uboot on NOR partition
     set EXP_CS0_BASEADDR       [regs EXP_CS0_BASEADDR]
-
+    
     # setup CS0 controller for NOR
     setupNOR
     # make sure we are accessing the lower part of NOR
     lowGPIO5
     flash probe 0
     puts "Erasing sectors 0-3 for uboot"
+    putsUART0 "Erasing sectors 0-3 for uboot\n"
     flash erase_sector 0 0 3
-    puts "Programming u-boot, takes about 4-5 min for 256kb"
-    flash write_image ./images/u-boot.bin $EXP_CS0_BASEADDR
+    puts "Programming u-boot"
+    putsUART0 "Programming u-boot..."
+    memwrite burst enable
+    flash write_image $file $EXP_CS0_BASEADDR
+    memwrite burst disable
+    putsUART0 "done.\n"
+    putsUART0 "Rebooting, please wait!\n"
+    reboot
 }
\ No newline at end of file

Modified: trunk/tcl/target/telo.cfg
===================================================================
--- trunk/tcl/target/telo.cfg	2009-09-29 19:28:08 UTC (rev 2777)
+++ trunk/tcl/target/telo.cfg	2009-09-30 05:37:32 UTC (rev 2778)
@@ -1,9 +1,60 @@
 source [find c100.cfg]
+# basic register defintion for C100
+source [find c100regs.tcl]
+# board-config info
+source [find c100config.tcl]
+# C100 helper functions
+source [find c100helper.tcl]
 
+
+# Telo board & C100 support trst and srst
+# Note that libftd2xx.so tries to assert srst
+# which break this script
+# use libftdi.so library instead with this script
+# make the reset asserted to 
+# allow RC circuit to discharge for: [ms]
+jtag_nsrst_assert_width 100
+jtag_ntrst_assert_width 100
+# don't talk to JTAG after reset for: [ms]
+jtag_nsrst_delay 100
+jtag_ntrst_delay 100
+reset_config trst_and_srst separate
+
+
+
+
+# issue telnet: reset init
+# issue gdb: monitor reset init
+$_TARGETNAME configure -event reset-init {
+	jtag_khz 100
+	# this will setup Telo board
+	setupTelo
+	#turn up the JTAG speed
+	jtag_khz 3000
+	puts "JTAG speek now 3MHz"
+	puts "type helpC100 to get help on C100"
+}
+
+$_TARGETNAME configure -event reset-deassert-post {
+	# Force target into ARM state.
+#	soft_reset_halt # not implemented on ARM11
+	puts "Detected SRSRT asserted on C100.CPU"
+	
+}
+
+$_TARGETNAME configure -event reset-assert-post {
+  puts "Assering reset"
+  #sleep 10
+}
+
+proc power_restore {} { puts "Sensed power restore. No action." } 
+proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }
+
+
 # boots from NOR on CS0:  8 MBytes CFI flash, 16-bit bus
-# it's really 16MB but the upper 8mb is controller via gpio?
+# it's really 16MB but the upper 8mb is controller via gpio
+# openocd does not support 'complex reads/writes' to NOR
 flash bank cfi 0x20000000 0x01000000 2 2 $_TARGETNAME
 
-#
-gdb_memory_map enable
-
+# writing data to memory does not work without this
+memwrite burst disable
\ No newline at end of file



From oharboe at mail.berlios.de  Wed Sep 30 07:40:41 2009
From: oharboe at mail.berlios.de (oharboe at BerliOS)
Date: Wed, 30 Sep 2009 07:40:41 +0200
Subject: [Openocd-svn] r2779 - in trunk/tcl: board target
Message-ID: <200909300540.n8U5efAO017525@sheep.berlios.de>

Author: oharboe
Date: 2009-09-30 07:40:40 +0200 (Wed, 30 Sep 2009)
New Revision: 2779

Modified:
   trunk/tcl/board/mini2440.cfg
   trunk/tcl/target/at91sam3uXX.cfg
Log:
strip gdb config options

Modified: trunk/tcl/board/mini2440.cfg
===================================================================
--- trunk/tcl/board/mini2440.cfg	2009-09-30 05:37:32 UTC (rev 2778)
+++ trunk/tcl/board/mini2440.cfg	2009-09-30 05:40:40 UTC (rev 2779)
@@ -123,11 +123,7 @@
 # GDB Setup
 #-------------------------------------------------------------------------
 
-    gdb_port 3333
-    gdb_detach resume
     gdb_breakpoint_override hard
-    gdb_memory_map enable
-    gdb_flash_program enable
 
 #------------------------------------------------
 # ARM SPECIFIC

Modified: trunk/tcl/target/at91sam3uXX.cfg
===================================================================
--- trunk/tcl/target/at91sam3uXX.cfg	2009-09-30 05:37:32 UTC (rev 2778)
+++ trunk/tcl/target/at91sam3uXX.cfg	2009-09-30 05:40:40 UTC (rev 2779)
@@ -37,11 +37,6 @@
 
 reset_config srst_only
 
-# GDB can use this
-gdb_memory_map enable
-# And GDB can flash the chip
-gdb_flash_program enable
-
 $_TARGETNAME configure -event gdb-flash-erase-start {
     halt
 }



From mlu at mail.berlios.de  Wed Sep 30 19:24:59 2009
From: mlu at mail.berlios.de (mlu at mail.berlios.de)
Date: Wed, 30 Sep 2009 19:24:59 +0200
Subject: [Openocd-svn] r2780 - trunk/src/target
Message-ID: <200909301724.n8UHOxxm003938@sheep.berlios.de>

Author: mlu
Date: 2009-09-30 19:24:43 +0200 (Wed, 30 Sep 2009)
New Revision: 2780

Modified:
   trunk/src/target/cortex_a8.h
Log:
Add DSCR_DTR_RX_FULL bit define

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-09-30 05:40:40 UTC (rev 2779)
+++ trunk/src/target/cortex_a8.h	2009-09-30 17:24:43 UTC (rev 2780)
@@ -80,6 +80,7 @@
 #define DSCR_MON_DBG_MODE 		15
 #define DSCR_INSTR_COMP 		24
 #define DSCR_DTR_TX_FULL 		29
+#define DSCR_DTR_RX_FULL 		30
 
 typedef struct  cortex_a8_brp_s
 {



