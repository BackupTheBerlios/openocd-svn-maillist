From ntfreak at users.sourceforge.net  Thu Jun  3 11:40:59 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu,  3 Jun 2010 09:40:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-274-g6315147
Message-ID: <E1OK6vF-0005p6-8o@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  631514724db1772f9e08e1dcb564fe9205def57e (commit)
      from  d944a0bed73c63fe52cf546a7121823318e8b593 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 631514724db1772f9e08e1dcb564fe9205def57e
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Jun 3 10:20:06 2010 +0100

    NEWS: updates
    
    Add new features since 0.4.0 release.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index a744da3..db4485d 100644
--- a/NEWS
+++ b/NEWS
@@ -13,10 +13,14 @@ JTAG Layer:
 	   	jtag_khz	... is now adapter_khz
 		jtag_nsrst_delay ... is now adapter_nsrst_delay
 		jtag_nsrst_assert_width ... is now adapter_nsrst_assert_width
+	Support Voipac VPACLink JTAG Adapter.
 
 Boundary Scan:
 
 Target Layer:
+	ARM:
+		- basic semihosting support (ARMv7M).
+		- renamed "armv7m" command prefix as "arm"
 	MIPS:
 		- "ejtag_srst" variant removed. The same functionality is
 		  obtained by using "reset_config none".
@@ -31,9 +35,17 @@ Flash Layer:
 		re-enabling hardware debugging).
 	PIC32MX now uses algorithm for flash programming, this
 		has increased the performance by approx 96%.
+	New 'pic32mx unlock' cmd to remove readout protection.
+	New STM32 Value Line Support.
+	New 'virtual' flash driver, used to associate other addresses
+		with a flash bank. See pic32mx.cfg for usage.
+	New iMX27 NAND flash controller driver.
 
 Board, Target, and Interface Configuration Scripts:
 	Support IAR LPC1768 kickstart board (by Olimex)
+	Support Voipac PXA270/PXA270M module.
+	New $PARPORTADDR tcl variable used to change default
+		parallel port address used.
 
 Core Jim/TCL Scripting:
 	New "add_script_search_dir" command, behaviour is the same

-----------------------------------------------------------------------

Summary of changes:
 NEWS |   12 ++++++++++++
 1 files changed, 12 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun  3 20:42:15 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  3 Jun 2010 18:42:15 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-275-ga1cf1b5
Message-ID: <E1OKFMu-00035l-QI@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a1cf1b52444c67b6c56ad58fe29be5a285b244cb (commit)
      from  631514724db1772f9e08e1dcb564fe9205def57e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a1cf1b52444c67b6c56ad58fe29be5a285b244cb
Author: gcembed <gcembed at gmail.com>
Date:   Tue Jun 1 13:48:22 2010 +0200

    stm32 : change returned value of mass_erase function
    
    Hello,
    "stm32x mass_erase" return ERROR_OK even if something goes wrong.
    Here is a summary of changes :
    * in stm32x_mass_erase : return ERROR_FLASH_OPERATION_FAILED when error
    detected in FLASH_SR register;
    * in COMMAND_HANDLER(stm32x_handle_mass_erase_command) : return the
    returned value of stm32x_mass_erase().
    
    I don't know if there is reason to always return ERROR_OK ?
    
    Ga??tan

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 8a3b832..47ed640 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -1196,13 +1196,13 @@ static int stm32x_mass_erase(struct flash_bank *bank)
 	if (status & FLASH_WRPRTERR)
 	{
 		LOG_ERROR("stm32x device protected");
-		return ERROR_OK;
+		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	if (status & FLASH_PGERR)
 	{
 		LOG_ERROR("stm32x device programming failed");
-		return ERROR_OK;
+		return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	return ERROR_OK;
@@ -1223,7 +1223,8 @@ COMMAND_HANDLER(stm32x_handle_mass_erase_command)
 	if (ERROR_OK != retval)
 		return retval;
 
-	if (stm32x_mass_erase(bank) == ERROR_OK)
+	retval = stm32x_mass_erase(bank);
+	if (retval == ERROR_OK)
 	{
 		/* set all sectors as erased */
 		for (i = 0; i < bank->num_sectors; i++)
@@ -1238,7 +1239,7 @@ COMMAND_HANDLER(stm32x_handle_mass_erase_command)
 		command_print(CMD_CTX, "stm32x mass erase failed");
 	}
 
-	return ERROR_OK;
+	return retval;
 }
 
 static const struct command_registration stm32x_exec_command_handlers[] = {

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stm32x.c |    9 +++++----
 1 files changed, 5 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun  7 15:10:18 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  7 Jun 2010 13:10:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-276-g00635e2
Message-ID: <E1OLc5v-0003eL-WF@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  00635e28ba5c405742cae261d8551f165dc78ba3 (commit)
      from  a1cf1b52444c67b6c56ad58fe29be5a285b244cb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 00635e28ba5c405742cae261d8551f165dc78ba3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sat Jun 5 11:30:49 2010 +0200

    jtag: rename JTAG_MOVESTATE to JTAG_TLR_RESET
    
    JTAG_MOVESTATE is misleading, this cmd is only used
    for reset.
    
    JTAG_PATHMOVE should be used otherwise.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/commands.h b/src/jtag/commands.h
index 87bd9c5..d591814 100644
--- a/src/jtag/commands.h
+++ b/src/jtag/commands.h
@@ -139,7 +139,14 @@ union jtag_command_container {
  */
 enum jtag_command_type {
 	JTAG_SCAN         = 1,
-	JTAG_STATEMOVE    = 2,
+	/* JTAG_TLR_RESET's non-minidriver implementation is a
+	 * vestige from a statemove cmd. The statemove command
+	 * is obsolete and replaced by pathmove.
+	 *
+	 * pathmove does not support reset as one of it's states,
+	 * hence the need for an explicit statemove command.
+	 */
+	JTAG_TLR_RESET    = 2,
 	JTAG_RUNTEST      = 3,
 	JTAG_RESET        = 4,
 	JTAG_PATHMOVE     = 6,
diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
index 121649b..fca8cfe 100644
--- a/src/jtag/drivers/amt_jtagaccel.c
+++ b/src/jtag/drivers/amt_jtagaccel.c
@@ -356,7 +356,7 @@ static int amt_jtagaccel_execute_queue(void)
 				amt_jtagaccel_end_state(cmd->cmd.runtest->end_state);
 				amt_jtagaccel_runtest(cmd->cmd.runtest->num_cycles);
 				break;
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 #ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
 #endif
diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index e54c8c6..9d8b8b1 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -117,7 +117,7 @@ static int armjtagew_execute_queue(void)
 				armjtagew_runtest(cmd->cmd.runtest->num_cycles);
 				break;
 
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 				DEBUG_JTAG_IO("statemove end in %i", cmd->cmd.statemove->end_state);
 
 				armjtagew_end_state(cmd->cmd.statemove->end_state);
diff --git a/src/jtag/drivers/bitbang.c b/src/jtag/drivers/bitbang.c
index 6159ef7..4548cb5 100644
--- a/src/jtag/drivers/bitbang.c
+++ b/src/jtag/drivers/bitbang.c
@@ -304,7 +304,7 @@ int bitbang_execute_queue(void)
 				bitbang_stableclocks(cmd->cmd.stableclocks->num_cycles);
 				break;
 
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 #ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG("statemove end in %s", tap_state_name(cmd->cmd.statemove->end_state));
 #endif
diff --git a/src/jtag/drivers/bitq.c b/src/jtag/drivers/bitq.c
index 79ca349..a58f633 100644
--- a/src/jtag/drivers/bitq.c
+++ b/src/jtag/drivers/bitq.c
@@ -323,7 +323,7 @@ int bitq_execute_queue(void)
 			bitq_runtest(cmd->cmd.runtest->num_cycles);
 			break;
 
-		case JTAG_STATEMOVE:
+		case JTAG_TLR_RESET:
 #ifdef _DEBUG_JTAG_IO_
 			LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
 #endif
diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
index 99210d2..1c433a9 100644
--- a/src/jtag/drivers/buspirate.c
+++ b/src/jtag/drivers/buspirate.c
@@ -146,7 +146,7 @@ static int buspirate_execute_queue(void)
 			buspirate_runtest(cmd->cmd.runtest
 					->num_cycles);
 			break;
-		case JTAG_STATEMOVE:
+		case JTAG_TLR_RESET:
 			DEBUG_JTAG_IO("statemove end in %s",
 				tap_state_name(cmd->cmd.statemove
 						->end_state));
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 7f7f879..49f4024 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -338,7 +338,7 @@ int interface_jtag_add_tlr(void)
 
 	jtag_queue_command(cmd);
 
-	cmd->type = JTAG_STATEMOVE;
+	cmd->type = JTAG_TLR_RESET;
 
 	cmd->cmd.statemove = cmd_queue_alloc(sizeof(struct statemove_command));
 	cmd->cmd.statemove->end_state = state;
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 93d1c4a..2ac410a 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -1978,7 +1978,7 @@ static int ft2232_execute_command(struct jtag_command *cmd)
 	{
 	case JTAG_RESET:	retval = ft2232_execute_reset(cmd); break;
 	case JTAG_RUNTEST:	retval = ft2232_execute_runtest(cmd); break;
-	case JTAG_STATEMOVE: retval = ft2232_execute_statemove(cmd); break;
+	case JTAG_TLR_RESET: retval = ft2232_execute_statemove(cmd); break;
 	case JTAG_PATHMOVE:	retval = ft2232_execute_pathmove(cmd); break;
 	case JTAG_SCAN:		retval = ft2232_execute_scan(cmd); break;
 	case JTAG_SLEEP:	retval = ft2232_execute_sleep(cmd); break;
diff --git a/src/jtag/drivers/gw16012.c b/src/jtag/drivers/gw16012.c
index 0e9f3fe..cb29d33 100644
--- a/src/jtag/drivers/gw16012.c
+++ b/src/jtag/drivers/gw16012.c
@@ -344,7 +344,7 @@ static int gw16012_execute_queue(void)
 				gw16012_end_state(cmd->cmd.runtest->end_state);
 				gw16012_runtest(cmd->cmd.runtest->num_cycles);
 				break;
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 #ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
 #endif
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 21dfab2..34fce38 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -202,7 +202,7 @@ static void jlink_execute_command(struct jtag_command *cmd)
 	switch (cmd->type)
 	{
 	case JTAG_RUNTEST:   jlink_execute_runtest(cmd); break;
-	case JTAG_STATEMOVE: jlink_execute_statemove(cmd); break;
+	case JTAG_TLR_RESET: jlink_execute_statemove(cmd); break;
 	case JTAG_PATHMOVE:  jlink_execute_pathmove(cmd); break;
 	case JTAG_SCAN:      jlink_execute_scan(cmd); break;
 	case JTAG_RESET:     jlink_execute_reset(cmd); break;
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 43f1940..0060baf 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -1398,7 +1398,7 @@ int rlink_execute_queue(void)
 		switch (cmd->type)
 		{
 			case JTAG_RUNTEST:
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 			case JTAG_PATHMOVE:
 			case JTAG_SCAN:
 				break;
@@ -1430,7 +1430,7 @@ int rlink_execute_queue(void)
 					rlink_end_state(cmd->cmd.runtest->end_state);
 				rlink_runtest(cmd->cmd.runtest->num_cycles);
 				break;
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 #ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
 #endif
diff --git a/src/jtag/drivers/usbprog.c b/src/jtag/drivers/usbprog.c
index 0d51b27..cc78555 100644
--- a/src/jtag/drivers/usbprog.c
+++ b/src/jtag/drivers/usbprog.c
@@ -131,7 +131,7 @@ static int usbprog_execute_queue(void)
 				usbprog_end_state(cmd->cmd.runtest->end_state);
 				usbprog_runtest(cmd->cmd.runtest->num_cycles);
 				break;
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 #ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG("statemove end in %i", cmd->cmd.statemove->end_state);
 #endif
diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index a985677..450ce06 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -165,7 +165,7 @@ static int vsllink_execute_queue(void)
 				vsllink_runtest(cmd->cmd.runtest->num_cycles);
 				break;
 
-			case JTAG_STATEMOVE:
+			case JTAG_TLR_RESET:
 				DEBUG_JTAG_IO("statemove end in %s",
 					tap_state_name(cmd->cmd.statemove
 							->end_state));

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/commands.h              |    9 ++++++++-
 src/jtag/drivers/amt_jtagaccel.c |    2 +-
 src/jtag/drivers/arm-jtag-ew.c   |    2 +-
 src/jtag/drivers/bitbang.c       |    2 +-
 src/jtag/drivers/bitq.c          |    2 +-
 src/jtag/drivers/buspirate.c     |    2 +-
 src/jtag/drivers/driver.c        |    2 +-
 src/jtag/drivers/ft2232.c        |    2 +-
 src/jtag/drivers/gw16012.c       |    2 +-
 src/jtag/drivers/jlink.c         |    2 +-
 src/jtag/drivers/rlink.c         |    4 ++--
 src/jtag/drivers/usbprog.c       |    2 +-
 src/jtag/drivers/vsllink.c       |    2 +-
 13 files changed, 21 insertions(+), 14 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun  8 10:38:19 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Jun 2010 08:38:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-277-g54f3f8e
Message-ID: <E1OLuKF-0001oe-Re@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  54f3f8e4c1477bec077e132cdccd8097938332e2 (commit)
      from  00635e28ba5c405742cae261d8551f165dc78ba3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 54f3f8e4c1477bec077e132cdccd8097938332e2
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 7 15:14:04 2010 +0200

    gdb-server: fix error reporting bugs
    
    GDB and OpenOCD has two different error number
    spaces and no mapping exists between them.
    
    If a specific error number is to be reported
    to GDB then this has to be done at the calling
    site, rather than as a generic routine that
    tries to map "retval" to GDB error number speak.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index a84c618..029bdf8 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -1219,29 +1219,14 @@ static int gdb_set_register_packet(struct connection *connection,
 	return ERROR_OK;
 }
 
+/* No attempt is made to translate the "retval" to
+ * GDB speak. This has to be done at the calling
+ * site as no mapping really exists.
+ */
 static int gdb_error(struct connection *connection, int retval)
 {
-	switch (retval)
-	{
-		case ERROR_TARGET_DATA_ABORT:
-			gdb_send_error(connection, EIO);
-			break;
-		case ERROR_TARGET_TRANSLATION_FAULT:
-			gdb_send_error(connection, EFAULT);
-			break;
-		case ERROR_TARGET_UNALIGNED_ACCESS:
-			gdb_send_error(connection, EFAULT);
-			break;
-		case ERROR_TARGET_NOT_HALTED:
-			gdb_send_error(connection, EFAULT);
-			break;
-		default:
-			/* This could be that the target reset itself. */
-			LOG_ERROR("unexpected error %i", retval);
-			gdb_send_error(connection, EFAULT);
-			break;
-	}
-
+	LOG_DEBUG("Reporting %i to GDB as generic error", retval);
+	gdb_send_error(connection, EFAULT);
 	return ERROR_OK;
 }
 
@@ -1719,7 +1704,7 @@ static int gdb_memory_map(struct connection *connection,
 		if (retval != ERROR_OK)
 		{
 			free(banks);
-			gdb_send_error(connection, retval);
+			gdb_error(connection, retval);
 			return retval;
 		}
 		banks[i] = p;
@@ -1801,7 +1786,7 @@ static int gdb_memory_map(struct connection *connection,
 	xml_printf(&retval, &xml, &pos, &size, "</memory-map>\n");
 
 	if (retval != ERROR_OK) {
-		gdb_send_error(connection, retval);
+		gdb_error(connection, retval);
 		return retval;
 	}
 
@@ -1952,7 +1937,7 @@ static int gdb_query_packet(struct connection *connection,
 
 		if (retval != ERROR_OK)
 		{
-			gdb_send_error(connection, retval);
+			gdb_error(connection, retval);
 			return retval;
 		}
 

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c |   33 +++++++++------------------------
 1 files changed, 9 insertions(+), 24 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun  8 10:47:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Jun 2010 08:47:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-278-g31bbb3c
Message-ID: <E1OLuTA-0002K1-KB@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  31bbb3cf0c9cffb98dbda1a357356bbf519a456f (commit)
      from  54f3f8e4c1477bec077e132cdccd8097938332e2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 31bbb3cf0c9cffb98dbda1a357356bbf519a456f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 5 19:00:21 2010 +0200

    verify: display up to 128 diff's
    
    Showing up to 128 differences.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index c8c1012..01d9441 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2682,6 +2682,7 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 	}
 
 	image_size = 0x0;
+	int diffs = 0;
 	retval = ERROR_OK;
 	for (i = 0; i < image.num_sections; i++)
 	{
@@ -2716,7 +2717,10 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 				/* failed crc checksum, fall back to a binary compare */
 				uint8_t *data;
 
-				command_print(CMD_CTX, "checksum mismatch - attempting binary compare");
+				if (diffs == 0)
+				{
+					LOG_ERROR("checksum mismatch - attempting binary compare");
+				}
 
 				data = (uint8_t*)malloc(buf_cnt);
 
@@ -2737,22 +2741,22 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 						if (data[t] != buffer[t])
 						{
 							command_print(CMD_CTX,
-										  "Verify operation failed address 0x%08x. Was 0x%02x instead of 0x%02x\n",
+										  "diff %d address 0x%08x. Was 0x%02x instead of 0x%02x",
+										  diffs,
 										  (unsigned)(t + image.sections[i].base_address),
 										  data[t],
 										  buffer[t]);
-							free(data);
-							free(buffer);
-							retval = ERROR_FAIL;
-							goto done;
-						}
-						if ((t%16384) == 0)
-						{
-							keep_alive();
+							if (diffs++ >= 127)
+							{
+								command_print(CMD_CTX, "More than 128 errors, the rest are not printed.");
+								free(data);
+								free(buffer);
+								goto done;
+							}
 						}
+						keep_alive();
 					}
 				}
-
 				free(data);
 			}
 		} else
@@ -2766,6 +2770,10 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 		image_size += buf_cnt;
 	}
 done:
+	if (diffs > 0)
+	{
+		retval = ERROR_FAIL;
+	}
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "verified %" PRIu32 " bytes "

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |   30 +++++++++++++++++++-----------
 1 files changed, 19 insertions(+), 11 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun  8 10:49:36 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  8 Jun 2010 08:49:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-279-g14c112e
Message-ID: <E1OLuV9-0007hT-Si@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  14c112e992c405442a751342bb6bca4adb0ae90a (commit)
      from  31bbb3cf0c9cffb98dbda1a357356bbf519a456f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 14c112e992c405442a751342bb6bca4adb0ae90a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 5 16:18:50 2010 +0200

    cfi: fix GDB keep alive bug
    
    Long running CFI writes could cause GDB timeout.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 8c1aaca..f0ab332 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1232,6 +1232,8 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 		buffer += thisrun_count;
 		address += thisrun_count;
 		count -= thisrun_count;
+
+		keep_alive();
 	}
 
 	/* free up resources */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun  9 16:02:20 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  9 Jun 2010 14:02:20 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-282-g49e6c61
Message-ID: <E1OMLrK-0006Nw-Kn@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  49e6c61bcc9a176119721c38004eca02b3e77f19 (commit)
       via  c63468038473420bf4f25d2b93e3ce7620d0b572 (commit)
      from  f6236ade0e0b62129b4a16f0d7897f79756189f0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 49e6c61bcc9a176119721c38004eca02b3e77f19
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 9 16:01:10 2010 +0200

    flash: flash erase_address takes unsigned arguments
    
    fixed bug where address was parsed as a signed, rather
    than unsigned it.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index b3dbd7b..cf1ca4a 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -199,8 +199,8 @@ COMMAND_HANDLER(handle_flash_erase_address_command)
 {
 	struct flash_bank *p;
 	int retval = ERROR_OK;
-	int address;
-	int length;
+	uint32_t address;
+	uint32_t length;
 	bool do_pad = false;
 	bool do_unlock = false;
 	struct target *target = get_current_target(CMD_CTX);
@@ -229,8 +229,8 @@ COMMAND_HANDLER(handle_flash_erase_address_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], address);
-	COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], length);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
 
 	if (length <= 0)
 	{

commit c63468038473420bf4f25d2b93e3ce7620d0b572
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 7 16:14:51 2010 +0200

    zy1000: fix optimisation gaffe
    
    DCC optimisation was broken on targets w/multiple TAP's.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index f578058..13685f8 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -820,14 +820,35 @@ static void jtag_pre_post_bits(struct jtag_tap *tap, int *pre, int *post)
 	*post = post_bits;
 }
 
+/*
+	static const int embeddedice_num_bits[] = {32, 6};
+	uint32_t values[2];
+
+	values[0] = value;
+	values[1] = (1 << 5) | reg_addr;
+
+	jtag_add_dr_out(tap,
+			2,
+			embeddedice_num_bits,
+			values,
+			TAP_IDLE);
+*/
+
 void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
 {
-
+#if 0
+	int i;
+	for (i = 0; i < count; i++)
+	{
+		embeddedice_write_reg_inner(tap, reg_addr, fast_target_buffer_get_u32(buffer, little));
+		buffer += 4;
+	}
+#else
 	int pre_bits;
 	int post_bits;
 	jtag_pre_post_bits(tap, &pre_bits, &post_bits);
 
-	if (pre_bits + post_bits + 6 > 32)
+	if ((pre_bits > 32) || (post_bits + 6 > 32))
 	{
 		int i;
 		for (i = 0; i < count; i++)
@@ -837,18 +858,20 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 		}
 	} else
 	{
-		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
 		int i;
-		for (i = 0; i < count - 1; i++)
+		for (i = 0; i < count; i++)
 		{
 			/* Fewer pokes means we get to use the FIFO more efficiently */
+			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
 			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, little));
-			shiftValueInner(TAP_DRSHIFT, TAP_IDLE, 6 + post_bits + pre_bits, (reg_addr | (1 << 5)));
+			/* Danger! here we need to exit into the TAP_IDLE state to make
+			 * DCC pick up this value.
+			 */
+			shiftValueInner(TAP_DRSHIFT, TAP_IDLE, 6 + post_bits, (reg_addr | (1 << 5)));
 			buffer += 4;
 		}
-		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, little));
-		shiftValueInner(TAP_DRSHIFT, TAP_IDLE, 6 + post_bits, (reg_addr | (1 << 5)));
 	}
+#endif
 }
 
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/tcl.c      |    8 ++++----
 src/jtag/zy1000/zy1000.c |   37 ++++++++++++++++++++++++++++++-------
 2 files changed, 34 insertions(+), 11 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun  9 17:13:45 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  9 Jun 2010 15:13:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-283-g9ab7636
Message-ID: <E1OMMyS-0002DG-96@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9ab7636ce6276d222662be431a1e6be96d9d34c0 (commit)
      from  49e6c61bcc9a176119721c38004eca02b3e77f19 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9ab7636ce6276d222662be431a1e6be96d9d34c0
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 9 17:12:52 2010 +0200

    flash: add error message if image is too big for flash
    
    replaced assert() w/error message if the image is
    too big.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 1bd09b4..429bad6 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -636,7 +636,11 @@ int flash_write_unlock(struct target *target, struct image *image,
 				LOG_INFO("Padding image section %d with %d bytes", section_last-1, pad_bytes);
 		}
 
-		assert (run_address + run_size - 1 <= c->base + c->size - 1);
+		if (run_address + run_size - 1 > c->base + c->size - 1)
+		{
+			LOG_ERROR("The image is too big for the flash");
+			return ERROR_FAIL;
+		}
 
 		/* If we're applying any sector automagic, then pad this
 		 * (maybe-combined) segment to the end of its last sector.

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/core.c |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 10 17:32:37 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 10 Jun 2010 15:32:37 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-284-g73aaaf4
Message-ID: <E1OMjkF-0004MC-93@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  73aaaf483035cfe79fe339d6c073e851bc9f8f9a (commit)
      from  9ab7636ce6276d222662be431a1e6be96d9d34c0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 73aaaf483035cfe79fe339d6c073e851bc9f8f9a
Author: Thomas Koeller <thomas.koeller at baslerweb.com>
Date:   Thu Jun 10 16:54:25 2010 +0200

    jtag: added mising header
    
    Distributions created by 'make dist' were incomplete due to a
    missing header file.
    
    Signed-off-by: Thomas Koeller <thomas.koeller at baslerweb.com>

diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
index 875fbcb..910affc 100644
--- a/src/jtag/Makefile.am
+++ b/src/jtag/Makefile.am
@@ -62,6 +62,7 @@ libjtag_la_SOURCES = \
 
 noinst_HEADERS = \
 	commands.h \
+	driver.h \
 	interface.h \
 	interfaces.h \
 	minidriver.h \

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/Makefile.am |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jun 11 15:54:48 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 11 Jun 2010 13:54:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-287-g4532dc7
Message-ID: <E1ON4hA-00036d-71@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4532dc78314a543f205e15d37d1bc7fa03df7595 (commit)
       via  0538081246fafbfb74d554bb1b758412534aa254 (commit)
       via  ecc8041c0f4c30a7310c0f8414a5261ee7a090ca (commit)
      from  73aaaf483035cfe79fe339d6c073e851bc9f8f9a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4532dc78314a543f205e15d37d1bc7fa03df7595
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Jun 11 08:10:39 2010 +0200

    flash: add error handling to get_flash_by_addr/name
    
    autoprobing can fail and this error has to be
    reported up the call stack.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 429bad6..d2f2754 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -197,7 +197,7 @@ struct flash_bank *get_flash_bank_by_name_noprobe(const char *name)
 	return NULL;
 }
 
-struct flash_bank *get_flash_bank_by_name(const char *name)
+int get_flash_bank_by_name(const char *name, struct flash_bank **bank_result)
 {
 	struct flash_bank *bank;
 	int retval;
@@ -210,11 +210,12 @@ struct flash_bank *get_flash_bank_by_name(const char *name)
 		if (retval != ERROR_OK)
 		{
 			LOG_ERROR("auto_probe failed %d\n", retval);
-			return NULL;
+			return retval;
 		}
 	}
 
-	return bank;
+	*bank_result = bank;
+	return ERROR_OK;
 }
 
 int get_flash_bank_by_num(int num, struct flash_bank **bank)
@@ -238,8 +239,9 @@ int get_flash_bank_by_num(int num, struct flash_bank **bank)
 	return ERROR_OK;
 }
 
-/* lookup flash bank by address */
-struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
+/* lookup flash bank by address, bank not found is success, but
+ * result_bank is set to NULL. */
+int get_flash_bank_by_addr(struct target *target, uint32_t addr, bool check, struct flash_bank **result_bank)
 {
 	struct flash_bank *c;
 
@@ -252,14 +254,22 @@ struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
 		if (retval != ERROR_OK)
 		{
 			LOG_ERROR("auto_probe failed %d\n", retval);
-			return NULL;
+			return retval;
 		}
 		/* check whether address belongs to this flash bank */
 		if ((addr >= c->base) && (addr <= c->base + (c->size - 1)) && target == c->target)
-			return c;
+		{
+			*result_bank = c;
+			return ERROR_OK;
+		}
 	}
-	LOG_ERROR("No flash at address 0x%08" PRIx32 "\n", addr);
-	return NULL;
+	*result_bank = NULL;
+	if (check)
+	{
+		LOG_ERROR("No flash at address 0x%08" PRIx32 "\n", addr);
+		return ERROR_FAIL;
+	}
+	return ERROR_OK;
 }
 
 int default_flash_mem_blank_check(struct flash_bank *bank)
@@ -379,8 +389,9 @@ static int flash_iterate_address_range(struct target *target,
 	int last = -1;
 	int i;
 
-	if ((c = get_flash_bank_by_addr(target, addr)) == NULL)
-		return ERROR_FLASH_DST_OUT_OF_BANK; /* no corresponding bank found */
+	int retval = get_flash_bank_by_addr(target, addr, true, &c);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (c->size == 0 || c->num_sectors == 0)
 	{
@@ -588,7 +599,11 @@ int flash_write_unlock(struct target *target, struct image *image,
 		}
 
 		/* find the corresponding flash bank */
-		if ((c = get_flash_bank_by_addr(target, run_address)) == NULL)
+		int retval;
+		retval = get_flash_bank_by_addr(target, run_address, false, &c);
+		if (retval != ERROR_OK)
+			return retval;
+		if (c == NULL)
 		{
 			section++; /* and skip it */
 			section_offset = 0;
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index 17f1c53..ff14df0 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -168,7 +168,7 @@ int default_flash_mem_blank_check(struct flash_bank *bank);
  * bank number: when two str9x banks are defined, then 'str9x.1' refers
  * to the second.
  */
-struct flash_bank *get_flash_bank_by_name(const char *name);
+int get_flash_bank_by_name(const char *name, struct flash_bank **bank_result);
 /**
  * Returns the flash bank specified by @a name, which matches the
  * driver name and a suffix (option) specify the driver-specific
@@ -206,8 +206,9 @@ struct flash_bank *get_flash_bank_by_num_noprobe(int num);
  * Returns the flash bank located at a specified address.
  * @param target The target, presumed to contain one or more banks.
  * @param addr An address that is within the range of the bank.
+ * @param check return ERROR_OK and result_bank NULL if the bank does not exist
  * @returns The struct flash_bank located at @a addr, or NULL.
  */
-struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr);
+int get_flash_bank_by_addr(struct target *target, uint32_t addr, bool check, struct flash_bank **result_bank);
 
 #endif // FLASH_NOR_CORE_H
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index cf1ca4a..3d67327 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -35,7 +35,9 @@ COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
 		struct flash_bank **bank)
 {
 	const char *name = CMD_ARGV[name_index];
-	*bank = get_flash_bank_by_name(name);
+	int retval = get_flash_bank_by_name(name, bank);
+	if (retval != ERROR_OK)
+		return retval;
 	if (*bank)
 		return ERROR_OK;
 
@@ -238,11 +240,9 @@ COMMAND_HANDLER(handle_flash_erase_address_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	p = get_flash_bank_by_addr(target, address);
-	if (p == NULL)
-	{
-		return ERROR_FAIL;
-	}
+	retval = get_flash_bank_by_addr(target, address, true, &p);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* We can't know if we did a resume + halt, in which case we no longer know the erased state */
 	flash_set_dirty();
@@ -544,12 +544,9 @@ COMMAND_HANDLER(handle_flash_fill_command)
 	{
 		struct flash_bank *bank;
 
-		bank = get_flash_bank_by_addr(target, address);
-		if (bank == NULL)
-		{
-			retval = ERROR_FAIL;
+		retval = get_flash_bank_by_addr(target, address, true, &bank );
+		if (retval != ERROR_OK)
 			goto done;
-		}
 
 		cur_size = MIN((count * wordsize - wrote), chunksize);
 		err = flash_driver_write(bank, chunk, address - bank->base + wrote, cur_size);

commit 0538081246fafbfb74d554bb1b758412534aa254
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Jun 10 16:18:14 2010 +0200

    arm mmu: error propagation added for address translation
    
    The return value for MMU translation was a mess, either
    error or value.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 0093360..867eb94 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -260,7 +260,10 @@ static int arm720_virt2phys(struct target *target,
 	uint32_t ap;
 	struct arm720t_common *arm720t = target_to_arm720(target);
 
-	uint32_t ret = armv4_5_mmu_translate_va(target, &arm720t->armv4_5_mmu, virtual, &type, &cb, &domain, &ap);
+	uint32_t ret;
+	int retval = armv4_5_mmu_translate_va(target, &arm720t->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
+	if (retval != ERROR_OK)
+		return retval;
 	if (type == -1)
 	{
 		return ret;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 658315b..3175196 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -514,8 +514,11 @@ static int arm920_virt2phys(struct target *target,
 	uint32_t ap;
 	struct arm920t_common *arm920t = target_to_arm920(target);
 
-	uint32_t ret = armv4_5_mmu_translate_va(target,
-			&arm920t->armv4_5_mmu, virt, &type, &cb, &domain, &ap);
+	uint32_t ret;
+	int retval = armv4_5_mmu_translate_va(target,
+			&arm920t->armv4_5_mmu, virt, &type, &cb, &domain, &ap, &ret);
+	if (retval != ERROR_OK)
+		return retval;
 	if (type == -1)
 	{
 		return ret;
@@ -589,8 +592,10 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 		/*
 		 * We need physical address and cb
 		 */
-		pa = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu,
-				address, &type, &cb, &domain, &ap);
+		int retval = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu,
+				address, &type, &cb, &domain, &ap, &pa);
+		if (retval != ERROR_OK)
+			return retval;
 		if (type == -1)
 			return pa;
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 1f753a6..a7aac55 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -726,7 +726,10 @@ static int arm926ejs_virt2phys(struct target *target, uint32_t virtual, uint32_t
 	uint32_t ap;
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 
-	uint32_t ret = armv4_5_mmu_translate_va(target, &arm926ejs->armv4_5_mmu, virtual, &type, &cb, &domain, &ap);
+	uint32_t ret;
+	int retval = armv4_5_mmu_translate_va(target, &arm926ejs->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
+	if (retval != ERROR_OK)
+		return retval;
 	if (type == -1)
 	{
 		return ret;
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index fc1dde7..6990d13 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -26,15 +26,18 @@
 #include "armv4_5_mmu.h"
 
 
-uint32_t armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, int *type, uint32_t *cb, int *domain, uint32_t *ap)
+int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, int *type, uint32_t *cb, int *domain, uint32_t *ap, uint32_t *val)
 {
 	uint32_t first_lvl_descriptor = 0x0;
 	uint32_t second_lvl_descriptor = 0x0;
 	uint32_t ttb = armv4_5_mmu->get_ttb(target);
+	int retval;
 
-	armv4_5_mmu_read_physical(target, armv4_5_mmu,
+	retval = armv4_5_mmu_read_physical(target, armv4_5_mmu,
 		(ttb & 0xffffc000) | ((va & 0xfff00000) >> 18),
 		4, 1, (uint8_t*)&first_lvl_descriptor);
+	if (retval != ERROR_OK)
+	  return retval;
 	first_lvl_descriptor = target_buffer_get_u32(target, (uint8_t*)&first_lvl_descriptor);
 
 	LOG_DEBUG("1st lvl desc: %8.8" PRIx32 "", first_lvl_descriptor);
@@ -62,22 +65,27 @@ uint32_t armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_comm
 		*type = ARMV4_5_SECTION;
 		*cb = (first_lvl_descriptor & 0xc) >> 2;
 		*ap = (first_lvl_descriptor & 0xc00) >> 10;
-		return (first_lvl_descriptor & 0xfff00000) | (va & 0x000fffff);
+		*val = (first_lvl_descriptor & 0xfff00000) | (va & 0x000fffff);
+		return ERROR_OK;
 	}
 
 	if ((first_lvl_descriptor & 0x3) == 1)
 	{
 		/* coarse page table */
-		armv4_5_mmu_read_physical(target, armv4_5_mmu,
+		retval = armv4_5_mmu_read_physical(target, armv4_5_mmu,
 			(first_lvl_descriptor & 0xfffffc00) | ((va & 0x000ff000) >> 10),
 			4, 1, (uint8_t*)&second_lvl_descriptor);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 	else if ((first_lvl_descriptor & 0x3) == 3)
 	{
 		/* fine page table */
-		armv4_5_mmu_read_physical(target, armv4_5_mmu,
+		retval = armv4_5_mmu_read_physical(target, armv4_5_mmu,
 			(first_lvl_descriptor & 0xfffff000) | ((va & 0x000ffc00) >> 8),
 			4, 1, (uint8_t*)&second_lvl_descriptor);
+		if (retval != ERROR_OK)
+			return retval;
 	}
 
 	second_lvl_descriptor = target_buffer_get_u32(target, (uint8_t*)&second_lvl_descriptor);
@@ -99,7 +107,8 @@ uint32_t armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_comm
 		/* large page descriptor */
 		*type = ARMV4_5_LARGE_PAGE;
 		*ap = (second_lvl_descriptor & 0xff0) >> 4;
-		return (second_lvl_descriptor & 0xffff0000) | (va & 0x0000ffff);
+		*val = (second_lvl_descriptor & 0xffff0000) | (va & 0x0000ffff);
+		return ERROR_OK;
 	}
 
 	if ((second_lvl_descriptor & 0x3) == 2)
@@ -107,7 +116,8 @@ uint32_t armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_comm
 		/* small page descriptor */
 		*type = ARMV4_5_SMALL_PAGE;
 		*ap = (second_lvl_descriptor & 0xff0) >> 4;
-		return (second_lvl_descriptor & 0xfffff000) | (va & 0x00000fff);
+		*val = (second_lvl_descriptor & 0xfffff000) | (va & 0x00000fff);
+		return ERROR_OK;
 	}
 
 	if ((second_lvl_descriptor & 0x3) == 3)
@@ -115,7 +125,8 @@ uint32_t armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_comm
 		/* tiny page descriptor */
 		*type = ARMV4_5_TINY_PAGE;
 		*ap = (second_lvl_descriptor & 0x30) >> 4;
-		return (second_lvl_descriptor & 0xfffffc00) | (va & 0x000003ff);
+		*val = (second_lvl_descriptor & 0xfffffc00) | (va & 0x000003ff);
+		return ERROR_OK;
 	}
 
 	/* should not happen */
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 6b9ed34..3a6851f 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -43,9 +43,9 @@ enum
 
 extern char* armv4_5_page_type_names[];
 
-uint32_t armv4_5_mmu_translate_va(struct target *target,
+int armv4_5_mmu_translate_va(struct target *target,
 		struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, int *type,
-		uint32_t *cb, int *domain, uint32_t *ap);
+		uint32_t *cb, int *domain, uint32_t *ap, uint32_t *val);
 
 int armv4_5_mmu_read_physical(struct target *target,
 		struct armv4_5_mmu_common *armv4_5_mmu,
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index aa0e030..2edb9e3 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1817,8 +1817,11 @@ static int cortex_a8_virt2phys(struct target *target,
         cortex_a8->current_address_mode = ARM_MODE_USR;
     else /* Linux kernel */
         cortex_a8->current_address_mode = ARM_MODE_SVC;
-	uint32_t ret = armv4_5_mmu_translate_va(target,
-			&armv7a->armv4_5_mmu, virt, &type, &cb, &domain, &ap);
+	uint32_t ret;
+	int retval = armv4_5_mmu_translate_va(target,
+			&armv7a->armv4_5_mmu, virt, &type, &cb, &domain, &ap, &ret);
+	if (retval != ERROR_OK)
+		return retval;
     /* Reset the flag. We don't want someone else to use it by error */
     cortex_a8->current_address_mode = ARM_MODE_ANY;
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index ed0eef3..ab7eee3 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3226,7 +3226,10 @@ static int xscale_virt2phys(struct target *target,
 		return ERROR_TARGET_INVALID;
 	}
 
-	uint32_t ret = armv4_5_mmu_translate_va(target, &xscale->armv4_5_mmu, virtual, &type, &cb, &domain, &ap);
+	uint32_t ret;
+	int retval = armv4_5_mmu_translate_va(target, &xscale->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
+	if (retval != ERROR_OK)
+		return retval;
 	if (type == -1)
 	{
 		return ret;

commit ecc8041c0f4c30a7310c0f8414a5261ee7a090ca
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Jun 10 15:27:35 2010 +0200

    cfi: fix error propagation
    
    any read/write operation to memory can fail.
    
    block write algorithm error propagation was broken
    in that it would continue after an error was reported
    writing data to ram or the algorithm failing.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index f0ab332..f911bb7 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -146,37 +146,45 @@ static int cfi_send_command(struct flash_bank *bank, uint8_t cmd, uint32_t addre
  * flash banks are expected to be made of similar chips
  * the query result should be the same for all
  */
-static uint8_t cfi_query_u8(struct flash_bank *bank, int sector, uint32_t offset)
+static int cfi_query_u8(struct flash_bank *bank, int sector, uint32_t offset, uint8_t *val)
 {
 	struct target *target = bank->target;
 	uint8_t data[CFI_MAX_BUS_WIDTH];
 
-	target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 1, data);
+	int retval;
+	retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 1, data);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
-		return data[0];
+		*val = data[0];
 	else
-		return data[bank->bus_width - 1];
+		*val = data[bank->bus_width - 1];
+
+	return ERROR_OK;
 }
 
 /* read unsigned 8-bit value from the bank
  * in case of a bank made of multiple chips,
  * the individual values are ORed
  */
-static uint8_t cfi_get_u8(struct flash_bank *bank, int sector, uint32_t offset)
+static int cfi_get_u8(struct flash_bank *bank, int sector, uint32_t offset, uint8_t *val)
 {
 	struct target *target = bank->target;
 	uint8_t data[CFI_MAX_BUS_WIDTH];
 	int i;
 
-	target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 1, data);
+	int retval;
+	retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 1, data);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
 	{
 		for (i = 0; i < bank->bus_width / bank->chip_width; i++)
 			data[0] |= data[i];
 
-		return data[0];
+		*val = data[0];
 	}
 	else
 	{
@@ -184,53 +192,75 @@ static uint8_t cfi_get_u8(struct flash_bank *bank, int sector, uint32_t offset)
 		for (i = 0; i < bank->bus_width / bank->chip_width; i++)
 			value |= data[bank->bus_width - 1 - i];
 
-		return value;
+		*val = value;
 	}
+	return ERROR_OK;
 }
 
-static uint16_t cfi_query_u16(struct flash_bank *bank, int sector, uint32_t offset)
+static int cfi_query_u16(struct flash_bank *bank, int sector, uint32_t offset, uint16_t *val)
 {
 	struct target *target = bank->target;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	uint8_t data[CFI_MAX_BUS_WIDTH * 2];
+	int retval;
 
 	if (cfi_info->x16_as_x8)
 	{
 		uint8_t i;
 		for (i = 0;i < 2;i++)
-			target_read_memory(target, flash_address(bank, sector, offset + i), bank->bus_width, 1,
+		{
+			retval = target_read_memory(target, flash_address(bank, sector, offset + i), bank->bus_width, 1,
 				&data[i*bank->bus_width]);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	} else
+	{
+		retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 2, data);
+		if (retval != ERROR_OK)
+			return retval;
 	}
-	else
-		target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 2, data);
 
 	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
-		return data[0] | data[bank->bus_width] << 8;
+		*val = data[0] | data[bank->bus_width] << 8;
 	else
-		return data[bank->bus_width - 1] | data[(2 * bank->bus_width) - 1] << 8;
+		*val = data[bank->bus_width - 1] | data[(2 * bank->bus_width) - 1] << 8;
+
+	return ERROR_OK;
 }
 
-static uint32_t cfi_query_u32(struct flash_bank *bank, int sector, uint32_t offset)
+static int cfi_query_u32(struct flash_bank *bank, int sector, uint32_t offset, uint32_t *val)
 {
 	struct target *target = bank->target;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	uint8_t data[CFI_MAX_BUS_WIDTH * 4];
+	int retval;
 
 	if (cfi_info->x16_as_x8)
 	{
 		uint8_t i;
 		for (i = 0;i < 4;i++)
-			target_read_memory(target, flash_address(bank, sector, offset + i), bank->bus_width, 1,
+		{
+			retval = target_read_memory(target, flash_address(bank, sector, offset + i), bank->bus_width, 1,
 				&data[i*bank->bus_width]);
+			if (retval != ERROR_OK)
+				return retval;
+		}
 	}
 	else
-		target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 4, data);
+	{
+		retval = target_read_memory(target, flash_address(bank, sector, offset), bank->bus_width, 4, data);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	if (bank->target->endianness == TARGET_LITTLE_ENDIAN)
-		return data[0] | data[bank->bus_width] << 8 | data[bank->bus_width * 2] << 16 | data[bank->bus_width * 3] << 24;
+		*val = data[0] | data[bank->bus_width] << 8 | data[bank->bus_width * 2] << 16 | data[bank->bus_width * 3] << 24;
 	else
-		return data[bank->bus_width - 1] | data[(2* bank->bus_width) - 1] << 8 |
+		*val = data[bank->bus_width - 1] | data[(2* bank->bus_width) - 1] << 8 |
 				data[(3 * bank->bus_width) - 1] << 16 | data[(4 * bank->bus_width) - 1] << 24;
+
+	return ERROR_OK;
 }
 
 static int cfi_reset(struct flash_bank *bank)
@@ -275,13 +305,27 @@ static void cfi_intel_clear_status_register(struct flash_bank *bank)
 	cfi_send_command(bank, 0x50, flash_address(bank, 0, 0x0));
 }
 
-static uint8_t cfi_intel_wait_status_busy(struct flash_bank *bank, int timeout)
+static int cfi_intel_wait_status_busy(struct flash_bank *bank, int timeout, uint8_t *val)
 {
 	uint8_t status;
 
-	while ((!((status = cfi_get_u8(bank, 0, 0x0)) & 0x80)) && (timeout-- > 0))
+	int retval = ERROR_OK;
+
+	for (;;)
 	{
-		LOG_DEBUG("status: 0x%x", status);
+		if (timeout-- < 0)
+		{
+		  LOG_ERROR("timeout while waiting for WSM to become ready");
+		  return ERROR_FAIL;
+		}
+
+		retval = cfi_get_u8(bank, 0, 0x0, &status);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if (status & 0x80)
+			break;
+
 		alive_sleep(1);
 	}
 
@@ -290,11 +334,7 @@ static uint8_t cfi_intel_wait_status_busy(struct flash_bank *bank, int timeout)
 
 	LOG_DEBUG("status: 0x%x", status);
 
-	if ((status & 0x80) != 0x80)
-	{
-		LOG_ERROR("timeout while waiting for WSM to become ready");
-	}
-	else if (status != 0x80)
+	if (status != 0x80)
 	{
 		LOG_ERROR("status register: 0x%x", status);
 		if (status & 0x2)
@@ -311,24 +351,38 @@ static uint8_t cfi_intel_wait_status_busy(struct flash_bank *bank, int timeout)
 			LOG_ERROR("Block Erase Suspended");
 
 		cfi_intel_clear_status_register(bank);
+
+		retval = ERROR_FAIL;
 	}
 
-	return status;
+	*val = status;
+	return retval;
 }
 
 static int cfi_spansion_wait_status_busy(struct flash_bank *bank, int timeout)
 {
 	uint8_t status, oldstatus;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
+	int retval;
 
-	oldstatus = cfi_get_u8(bank, 0, 0x0);
+	retval = cfi_get_u8(bank, 0, 0x0, &oldstatus);
+	if (retval != ERROR_OK)
+		return retval;
 
 	do {
-		status = cfi_get_u8(bank, 0, 0x0);
+		retval = cfi_get_u8(bank, 0, 0x0, &status);
+
+		if (retval != ERROR_OK)
+			return retval;
+
 		if ((status ^ oldstatus) & 0x40) {
 			if (status & cfi_info->status_poll_mask & 0x20) {
-				oldstatus = cfi_get_u8(bank, 0, 0x0);
-				status = cfi_get_u8(bank, 0, 0x0);
+				retval = cfi_get_u8(bank, 0, 0x0, &oldstatus);
+				if (retval != ERROR_OK)
+					return retval;
+				retval = cfi_get_u8(bank, 0, 0x0, &status);
+				if (retval != ERROR_OK)
+					return retval;
 				if ((status ^ oldstatus) & 0x40) {
 					LOG_ERROR("dq5 timeout, status: 0x%x", status);
 					return(ERROR_FLASH_OPERATION_FAILED);
@@ -368,9 +422,15 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 	}
 	cfi_info->pri_ext = pri_ext;
 
-	pri_ext->pri[0] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0);
-	pri_ext->pri[1] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 1);
-	pri_ext->pri[2] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 2);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0, &pri_ext->pri[0]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 1, &pri_ext->pri[1]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 2, &pri_ext->pri[2]);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((pri_ext->pri[0] != 'P') || (pri_ext->pri[1] != 'R') || (pri_ext->pri[2] != 'I'))
 	{
@@ -382,36 +442,58 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
-	pri_ext->major_version = cfi_query_u8(bank, 0, cfi_info->pri_addr + 3);
-	pri_ext->minor_version = cfi_query_u8(bank, 0, cfi_info->pri_addr + 4);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 3, &pri_ext->major_version);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 4, &pri_ext->minor_version);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", pri_ext->pri[0], pri_ext->pri[1], pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
 
-	pri_ext->feature_support = cfi_query_u32(bank, 0, cfi_info->pri_addr + 5);
-	pri_ext->suspend_cmd_support = cfi_query_u8(bank, 0, cfi_info->pri_addr + 9);
-	pri_ext->blk_status_reg_mask = cfi_query_u16(bank, 0, cfi_info->pri_addr + 0xa);
+	retval = cfi_query_u32(bank, 0, cfi_info->pri_addr + 5, &pri_ext->feature_support);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 9, &pri_ext->suspend_cmd_support);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u16(bank, 0, cfi_info->pri_addr + 0xa, &pri_ext->blk_status_reg_mask);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("feature_support: 0x%" PRIx32 ", suspend_cmd_support: 0x%x, blk_status_reg_mask: 0x%x",
 		  pri_ext->feature_support,
 		  pri_ext->suspend_cmd_support,
 		  pri_ext->blk_status_reg_mask);
 
-	pri_ext->vcc_optimal = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xc);
-	pri_ext->vpp_optimal = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xd);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xc, &pri_ext->vcc_optimal);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xd, &pri_ext->vpp_optimal);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("Vcc opt: %x.%x, Vpp opt: %u.%x",
 		  (pri_ext->vcc_optimal & 0xf0) >> 4, pri_ext->vcc_optimal & 0x0f,
 		  (pri_ext->vpp_optimal & 0xf0) >> 4, pri_ext->vpp_optimal & 0x0f);
 
-	pri_ext->num_protection_fields = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xe);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0xe, &pri_ext->num_protection_fields);
+	if (retval != ERROR_OK)
+		return retval;
 	if (pri_ext->num_protection_fields != 1)
 	{
 		LOG_WARNING("expected one protection register field, but found %i", pri_ext->num_protection_fields);
 	}
 
-	pri_ext->prot_reg_addr = cfi_query_u16(bank, 0, cfi_info->pri_addr + 0xf);
-	pri_ext->fact_prot_reg_size = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0x11);
-	pri_ext->user_prot_reg_size = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0x12);
+	retval = cfi_query_u16(bank, 0, cfi_info->pri_addr + 0xf, &pri_ext->prot_reg_addr);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0x11, &pri_ext->fact_prot_reg_size);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0x12, &pri_ext->user_prot_reg_size);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("protection_fields: %i, prot_reg_addr: 0x%x, factory pre-programmed: %i, user programmable: %i", pri_ext->num_protection_fields, pri_ext->prot_reg_addr, 1 << pri_ext->fact_prot_reg_size, 1 << pri_ext->user_prot_reg_size);
 
@@ -435,9 +517,15 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 	}
 	cfi_info->pri_ext = pri_ext;
 
-	pri_ext->pri[0] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0);
-	pri_ext->pri[1] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 1);
-	pri_ext->pri[2] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 2);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0, &pri_ext->pri[0]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 1, &pri_ext->pri[1]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 2, &pri_ext->pri[2]);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((pri_ext->pri[0] != 'P') || (pri_ext->pri[1] != 'R') || (pri_ext->pri[2] != 'I'))
 	{
@@ -449,22 +537,48 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
-	pri_ext->major_version = cfi_query_u8(bank, 0, cfi_info->pri_addr + 3);
-	pri_ext->minor_version = cfi_query_u8(bank, 0, cfi_info->pri_addr + 4);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 3, &pri_ext->major_version);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 4, &pri_ext->minor_version);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", pri_ext->pri[0], pri_ext->pri[1], pri_ext->pri[2], pri_ext->major_version, pri_ext->minor_version);
 
-	pri_ext->SiliconRevision = cfi_query_u8(bank, 0, cfi_info->pri_addr + 5);
-	pri_ext->EraseSuspend    = cfi_query_u8(bank, 0, cfi_info->pri_addr + 6);
-	pri_ext->BlkProt         = cfi_query_u8(bank, 0, cfi_info->pri_addr + 7);
-	pri_ext->TmpBlkUnprotect = cfi_query_u8(bank, 0, cfi_info->pri_addr + 8);
-	pri_ext->BlkProtUnprot   = cfi_query_u8(bank, 0, cfi_info->pri_addr + 9);
-	pri_ext->SimultaneousOps = cfi_query_u8(bank, 0, cfi_info->pri_addr + 10);
-	pri_ext->BurstMode       = cfi_query_u8(bank, 0, cfi_info->pri_addr + 11);
-	pri_ext->PageMode        = cfi_query_u8(bank, 0, cfi_info->pri_addr + 12);
-	pri_ext->VppMin          = cfi_query_u8(bank, 0, cfi_info->pri_addr + 13);
-	pri_ext->VppMax          = cfi_query_u8(bank, 0, cfi_info->pri_addr + 14);
-	pri_ext->TopBottom       = cfi_query_u8(bank, 0, cfi_info->pri_addr + 15);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 5, &pri_ext->SiliconRevision);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 6, &pri_ext->EraseSuspend);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 7, &pri_ext->BlkProt);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 8, &pri_ext->TmpBlkUnprotect);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 9, &pri_ext->BlkProtUnprot);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 10, &pri_ext->SimultaneousOps);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 11, &pri_ext->BurstMode);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 12, &pri_ext->PageMode);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 13, &pri_ext->VppMin);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 14, &pri_ext->VppMax);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 15, &pri_ext->TopBottom);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("Silicon Revision: 0x%x, Erase Suspend: 0x%x, Block protect: 0x%x", pri_ext->SiliconRevision,
 	      pri_ext->EraseSuspend, pri_ext->BlkProt);
@@ -515,9 +629,15 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 
 	cfi_info->pri_ext = pri_ext;
 
-	atmel_pri_ext.pri[0] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0);
-	atmel_pri_ext.pri[1] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 1);
-	atmel_pri_ext.pri[2] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 2);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0, &atmel_pri_ext.pri[0]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 1, &atmel_pri_ext.pri[1]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 2, &atmel_pri_ext.pri[2]);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if ((atmel_pri_ext.pri[0] != 'P') || (atmel_pri_ext.pri[1] != 'R') || (atmel_pri_ext.pri[2] != 'I'))
 	{
@@ -533,18 +653,30 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 	pri_ext->pri[1] = atmel_pri_ext.pri[1];
 	pri_ext->pri[2] = atmel_pri_ext.pri[2];
 
-	atmel_pri_ext.major_version = cfi_query_u8(bank, 0, cfi_info->pri_addr + 3);
-	atmel_pri_ext.minor_version = cfi_query_u8(bank, 0, cfi_info->pri_addr + 4);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 3, &atmel_pri_ext.major_version);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 4, &atmel_pri_ext.minor_version);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("pri: '%c%c%c', version: %c.%c", atmel_pri_ext.pri[0], atmel_pri_ext.pri[1], atmel_pri_ext.pri[2], atmel_pri_ext.major_version, atmel_pri_ext.minor_version);
 
 	pri_ext->major_version = atmel_pri_ext.major_version;
 	pri_ext->minor_version = atmel_pri_ext.minor_version;
 
-	atmel_pri_ext.features = cfi_query_u8(bank, 0, cfi_info->pri_addr + 5);
-	atmel_pri_ext.bottom_boot = cfi_query_u8(bank, 0, cfi_info->pri_addr + 6);
-	atmel_pri_ext.burst_mode = cfi_query_u8(bank, 0, cfi_info->pri_addr + 7);
-	atmel_pri_ext.page_mode = cfi_query_u8(bank, 0, cfi_info->pri_addr + 8);
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 5, &atmel_pri_ext.features);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 6, &atmel_pri_ext.bottom_boot);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 7, &atmel_pri_ext.burst_mode);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, cfi_info->pri_addr + 8, &atmel_pri_ext.page_mode);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("features: 0x%2.2x, bottom_boot: 0x%2.2x, burst_mode: 0x%2.2x, page_mode: 0x%2.2x",
 		atmel_pri_ext.features, atmel_pri_ext.bottom_boot, atmel_pri_ext.burst_mode, atmel_pri_ext.page_mode);
@@ -697,7 +829,7 @@ FLASH_BANK_COMMAND_HANDLER(cfi_flash_bank_command)
 	cfi_info->write_algorithm = NULL;
 
 	/* bank wasn't probed yet */
-	cfi_info->qry[0] = -1;
+	cfi_info->qry[0] = 0xff;
 
 	return ERROR_OK;
 }
@@ -722,7 +854,12 @@ static int cfi_intel_erase(struct flash_bank *bank, int first, int last)
 			return retval;
 		}
 
-		if (cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->block_erase_timeout_typ)) == 0x80)
+		uint8_t status;
+		retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->block_erase_timeout_typ), &status);
+		if (retval != ERROR_OK)
+			return retval;
+
+		if (status == 0x80)
 			bank->sectors[i].is_erased = 1;
 		else
 		{
@@ -873,7 +1010,10 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 		if (!(pri_ext->feature_support & 0x20))
 		{
 			/* Clear lock bits operation may take up to 1.4s */
-			cfi_intel_wait_status_busy(bank, 1400);
+			uint8_t status;
+			retval = cfi_intel_wait_status_busy(bank, 1400, &status);
+			if (retval != ERROR_OK)
+				return retval;
 		}
 		else
 		{
@@ -883,7 +1023,9 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 			{
 				return retval;
 			}
-			block_status = cfi_get_u8(bank, i, 0x2);
+			retval = cfi_get_u8(bank, i, 0x2, &block_status);
+			if (retval != ERROR_OK)
+				return retval;
 
 			if ((block_status & 0x1) != set)
 			{
@@ -892,7 +1034,10 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 				{
 					return retval;
 				}
-				cfi_intel_wait_status_busy(bank, 10);
+				uint8_t status;
+				retval = cfi_intel_wait_status_busy(bank, 10, &status);
+				if (retval != ERROR_OK)
+					return retval;
 
 				if (retry > 10)
 					return ERROR_FLASH_OPERATION_FAILED;
@@ -937,7 +1082,10 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 					return retval;
 				}
 
-				cfi_intel_wait_status_busy(bank, 100);
+				uint8_t status;
+				retval = cfi_intel_wait_status_busy(bank, 100, &status);
+				if (retval != ERROR_OK)
+					return retval;
 			}
 		}
 	}
@@ -1223,7 +1371,8 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 		if (wsm_error)
 		{
 			/* read status register (outputs debug inforation) */
-			cfi_intel_wait_status_busy(bank, 100);
+			uint8_t status;
+			cfi_intel_wait_status_busy(bank, 100, &status);
 			cfi_intel_clear_status_register(bank);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			goto cleanup;
@@ -1268,8 +1417,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 	struct working_area *source;
 	uint32_t buffer_size = 32768;
 	uint32_t status;
-	int retval, retvaltemp;
-	int exit_code = ERROR_OK;
+	int retval = ERROR_OK;
 
 	/* input parameters - */
 	/*	R0 = source address */
@@ -1515,7 +1663,11 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 	{
 		uint32_t thisrun_count = (count > buffer_size) ? buffer_size : count;
 
-		retvaltemp = target_write_buffer(target, source->address, thisrun_count, buffer);
+		retval = target_write_buffer(target, source->address, thisrun_count, buffer);
+		if (retval != ERROR_OK)
+		{
+			break;
+		}
 
 		buf_set_u32(reg_params[0].value, 0, 32, source->address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
@@ -1531,13 +1683,16 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 						     cfi_info->write_algorithm->address,
 						     cfi_info->write_algorithm->address + ((target_code_size) - 4),
 						     10000, &armv4_5_info);
+		if (retval != ERROR_OK)
+		{
+			break;
+		}
 
 		status = buf_get_u32(reg_params[5].value, 0, 32);
-
-		if ((retval != ERROR_OK) || (retvaltemp != ERROR_OK) || status != 0x80)
+		if (status != 0x80)
 		{
-			LOG_DEBUG("status: 0x%" PRIx32 , status);
-			exit_code = ERROR_FLASH_OPERATION_FAILED;
+			LOG_ERROR("flash write block failed status: 0x%" PRIx32 , status);
+			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 
@@ -1559,7 +1714,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 	destroy_reg_param(&reg_params[8]);
 	destroy_reg_param(&reg_params[9]);
 
-	return exit_code;
+	return retval;
 }
 
 static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t address)
@@ -1579,7 +1734,9 @@ static int cfi_intel_write_word(struct flash_bank *bank, uint8_t *word, uint32_t
 		return retval;
 	}
 
-	if (cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max)) != 0x80)
+	uint8_t status;
+	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->word_write_timeout_max), &status);
+	if (retval != 0x80)
 	{
 		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
@@ -1629,7 +1786,11 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	{
 		return retval;
 	}
-	if (cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max)) != 0x80)
+	uint8_t status;
+	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max), &status);
+	if (retval != ERROR_OK)
+		return retval;
+	if (status != 0x80)
 	{
 		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
@@ -1656,7 +1817,12 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	{
 		return retval;
 	}
-	if (cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max)) != 0x80)
+
+	retval = cfi_intel_wait_status_busy(bank, 1000 * (1 << cfi_info->buf_write_timeout_max), &status);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (status != 0x80)
 	{
 		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
 		{
@@ -2098,9 +2264,15 @@ static int cfi_query_string(struct flash_bank *bank, int address)
 		return retval;
 	}
 
-	cfi_info->qry[0] = cfi_query_u8(bank, 0, 0x10);
-	cfi_info->qry[1] = cfi_query_u8(bank, 0, 0x11);
-	cfi_info->qry[2] = cfi_query_u8(bank, 0, 0x12);
+	retval = cfi_query_u8(bank, 0, 0x10, &cfi_info->qry[0]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, 0x11, &cfi_info->qry[1]);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cfi_query_u8(bank, 0, 0x12, &cfi_info->qry[2]);
+	if (retval != ERROR_OK)
+		return retval;
 
 	LOG_DEBUG("CFI qry returned: 0x%2.2x 0x%2.2x 0x%2.2x", cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2]);
 
@@ -2236,25 +2408,57 @@ static int cfi_probe(struct flash_bank *bank)
 		if (retval != ERROR_OK)
 			return retval;
 
-		cfi_info->pri_id = cfi_query_u16(bank, 0, 0x13);
-		cfi_info->pri_addr = cfi_query_u16(bank, 0, 0x15);
-		cfi_info->alt_id = cfi_query_u16(bank, 0, 0x17);
-		cfi_info->alt_addr = cfi_query_u16(bank, 0, 0x19);
+		retval = cfi_query_u16(bank, 0, 0x13, &cfi_info->pri_id);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u16(bank, 0, 0x15, &cfi_info->pri_addr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u16(bank, 0, 0x17, &cfi_info->alt_id);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u16(bank, 0, 0x19, &cfi_info->alt_addr);
+		if (retval != ERROR_OK)
+			return retval;
 
 		LOG_DEBUG("qry: '%c%c%c', pri_id: 0x%4.4x, pri_addr: 0x%4.4x, alt_id: 0x%4.4x, alt_addr: 0x%4.4x", cfi_info->qry[0], cfi_info->qry[1], cfi_info->qry[2], cfi_info->pri_id, cfi_info->pri_addr, cfi_info->alt_id, cfi_info->alt_addr);
 
-		cfi_info->vcc_min = cfi_query_u8(bank, 0, 0x1b);
-		cfi_info->vcc_max = cfi_query_u8(bank, 0, 0x1c);
-		cfi_info->vpp_min = cfi_query_u8(bank, 0, 0x1d);
-		cfi_info->vpp_max = cfi_query_u8(bank, 0, 0x1e);
-		cfi_info->word_write_timeout_typ = cfi_query_u8(bank, 0, 0x1f);
-		cfi_info->buf_write_timeout_typ = cfi_query_u8(bank, 0, 0x20);
-		cfi_info->block_erase_timeout_typ = cfi_query_u8(bank, 0, 0x21);
-		cfi_info->chip_erase_timeout_typ = cfi_query_u8(bank, 0, 0x22);
-		cfi_info->word_write_timeout_max = cfi_query_u8(bank, 0, 0x23);
-		cfi_info->buf_write_timeout_max = cfi_query_u8(bank, 0, 0x24);
-		cfi_info->block_erase_timeout_max = cfi_query_u8(bank, 0, 0x25);
-		cfi_info->chip_erase_timeout_max = cfi_query_u8(bank, 0, 0x26);
+		retval = cfi_query_u8(bank, 0, 0x1b, &cfi_info->vcc_min);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x1c, &cfi_info->vcc_max);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x1d, &cfi_info->vpp_min);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x1e, &cfi_info->vpp_max);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x1f, &cfi_info->word_write_timeout_typ);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x20, &cfi_info->buf_write_timeout_typ);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x21, &cfi_info->block_erase_timeout_typ);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x22, &cfi_info->chip_erase_timeout_typ);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x23, &cfi_info->word_write_timeout_max);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x24, &cfi_info->buf_write_timeout_max);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x25, &cfi_info->block_erase_timeout_max);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x26, &cfi_info->chip_erase_timeout_max);
+		if (retval != ERROR_OK)
+			return retval;
 
 		LOG_DEBUG("Vcc min: %x.%x, Vcc max: %x.%x, Vpp min: %u.%x, Vpp max: %u.%x",
 			(cfi_info->vcc_min & 0xf0) >> 4, cfi_info->vcc_min & 0x0f,
@@ -2268,10 +2472,21 @@ static int cfi_probe(struct flash_bank *bank)
 			(1 << cfi_info->block_erase_timeout_max) * (1 << cfi_info->block_erase_timeout_typ),
 			(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
 
-		cfi_info->dev_size = 1 << cfi_query_u8(bank, 0, 0x27);
-		cfi_info->interface_desc = cfi_query_u16(bank, 0, 0x28);
-		cfi_info->max_buf_write_size = cfi_query_u16(bank, 0, 0x2a);
-		cfi_info->num_erase_regions = cfi_query_u8(bank, 0, 0x2c);
+		uint8_t data;
+		retval = 1 << cfi_query_u8(bank, 0, 0x27, &data);
+		if (retval != ERROR_OK)
+			return retval;
+		cfi_info->dev_size = data;
+
+		retval = cfi_query_u16(bank, 0, 0x28, &cfi_info->interface_desc);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u16(bank, 0, 0x2a, &cfi_info->max_buf_write_size);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cfi_query_u8(bank, 0, 0x2c, &cfi_info->num_erase_regions);
+		if (retval != ERROR_OK)
+			return retval;
 
 		LOG_DEBUG("size: 0x%" PRIx32 ", interface desc: %i, max buffer write size: %x", cfi_info->dev_size, cfi_info->interface_desc, (1 << cfi_info->max_buf_write_size));
 
@@ -2280,7 +2495,9 @@ static int cfi_probe(struct flash_bank *bank)
 			cfi_info->erase_region_info = malloc(4 * cfi_info->num_erase_regions);
 			for (i = 0; i < cfi_info->num_erase_regions; i++)
 			{
-				cfi_info->erase_region_info[i] = cfi_query_u32(bank, 0, 0x2d + (4 * i));
+				retval = cfi_query_u32(bank, 0, 0x2d + (4 * i), &cfi_info->erase_region_info[i]);
+				if (retval != ERROR_OK)
+					return retval;
 				LOG_DEBUG("erase region[%i]: %" PRIu32 " blocks of size 0x%" PRIx32 "",
 					  i,
 					  (cfi_info->erase_region_info[i] & 0xffff) + 1,
@@ -2417,7 +2634,10 @@ static int cfi_intel_protect_check(struct flash_bank *bank)
 
 	for (i = 0; i < bank->num_sectors; i++)
 	{
-		uint8_t block_status = cfi_get_u8(bank, i, 0x2);
+		uint8_t block_status;
+		retval = cfi_get_u8(bank, i, 0x2, &block_status);
+		if (retval != ERROR_OK)
+			return retval;
 
 		if (block_status & 1)
 			bank->sectors[i].is_protected = 1;
@@ -2452,7 +2672,10 @@ static int cfi_spansion_protect_check(struct flash_bank *bank)
 
 	for (i = 0; i < bank->num_sectors; i++)
 	{
-		uint8_t block_status = cfi_get_u8(bank, i, 0x2);
+		uint8_t block_status;
+		retval = cfi_get_u8(bank, i, 0x2, &block_status);
+		if (retval != ERROR_OK)
+			return retval;
 
 		if (block_status & 1)
 			bank->sectors[i].is_protected = 1;
@@ -2498,7 +2721,7 @@ static int cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 	int printed;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 
-	if (cfi_info->qry[0] == (char)-1)
+	if (cfi_info->qry[0] == 0xff)
 	{
 		printed = snprintf(buf, buf_size, "\ncfi flash bank not probed yet\n");
 		return ERROR_OK;
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index fa717dc..e2ff808 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -35,7 +35,7 @@ struct cfi_flash_bank
 	uint16_t manufacturer;
 	uint16_t device_id;
 
-	char qry[3];
+	uint8_t qry[3];
 
 	/* identification string */
 	uint16_t pri_id;
@@ -76,7 +76,7 @@ struct cfi_flash_bank
  */
 struct cfi_intel_pri_ext
 {
-	char pri[3];
+	uint8_t pri[3];
 	uint8_t major_version;
 	uint8_t minor_version;
 	uint32_t feature_support;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c      |  455 ++++++++++++++++++++++++++++++++++------------
 src/flash/nor/cfi.h      |    4 +-
 src/flash/nor/core.c     |   39 +++--
 src/flash/nor/core.h     |    5 +-
 src/flash/nor/tcl.c      |   19 +-
 src/target/arm720t.c     |    5 +-
 src/target/arm920t.c     |   13 +-
 src/target/arm926ejs.c   |    5 +-
 src/target/armv4_5_mmu.c |   27 ++-
 src/target/armv4_5_mmu.h |    4 +-
 src/target/cortex_a8.c   |    7 +-
 src/target/xscale.c      |    5 +-
 12 files changed, 426 insertions(+), 162 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Jun 12 12:10:35 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 12 Jun 2010 10:10:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-291-g9e62f86
Message-ID: <E1ONNfj-0001pp-E9@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9e62f86f24dbd1a3f8d1a84fbfd18dc15dc23002 (commit)
       via  ce58ab9a4ef7f014eac4d2e30d2b54b2c3e53895 (commit)
       via  dcc7de4f9b4dfa58ed8a8712c4c146a3c83aba17 (commit)
       via  20724e33250c48aa8f1e9332d1704dd8d58cda9b (commit)
      from  4532dc78314a543f205e15d37d1bc7fa03df7595 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9e62f86f24dbd1a3f8d1a84fbfd18dc15dc23002
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 12 11:58:50 2010 +0800

    TARGET: removed unsed parameter
    
    Parameter "type" of function armv4_5_mmu_translate_va()
    is now not used.
    Remove the parameter and the "enum" listing its values.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index e7672b4..d450224 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -254,14 +254,14 @@ static int arm720_mmu(struct target *target, int *enabled)
 static int arm720_virt2phys(struct target *target,
 		uint32_t virtual, uint32_t *physical)
 {
-	int type;
 	uint32_t cb;
 	int domain;
 	uint32_t ap;
 	struct arm720t_common *arm720t = target_to_arm720(target);
 
 	uint32_t ret;
-	int retval = armv4_5_mmu_translate_va(target, &arm720t->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
+	int retval = armv4_5_mmu_translate_va(target,
+			&arm720t->armv4_5_mmu, virtual, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*physical = ret;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index fe2ff01..b8ff819 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -508,7 +508,6 @@ static int arm920_mmu(struct target *target, int *enabled)
 static int arm920_virt2phys(struct target *target,
 		uint32_t virt, uint32_t *phys)
 {
-	int type;
 	uint32_t cb;
 	int domain;
 	uint32_t ap;
@@ -516,7 +515,7 @@ static int arm920_virt2phys(struct target *target,
 
 	uint32_t ret;
 	int retval = armv4_5_mmu_translate_va(target,
-			&arm920t->armv4_5_mmu, virt, &type, &cb, &domain, &ap, &ret);
+			&arm920t->armv4_5_mmu, virt, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*phys = ret;
@@ -579,7 +578,6 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 		 * in memory marked read only
 		 * by MMU
 		 */
-		int type;
 		uint32_t cb;
 		int domain;
 		uint32_t ap;
@@ -589,7 +587,7 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 		 * We need physical address and cb
 		 */
 		retval = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu,
-				address, &type, &cb, &domain, &ap, &pa);
+				address, &cb, &domain, &ap, &pa);
 		if (retval != ERROR_OK)
 			return retval;
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index bfa2ab4..dd1d365 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -720,14 +720,14 @@ COMMAND_HANDLER(arm926ejs_handle_cache_info_command)
 
 static int arm926ejs_virt2phys(struct target *target, uint32_t virtual, uint32_t *physical)
 {
-	int type;
 	uint32_t cb;
 	int domain;
 	uint32_t ap;
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 
 	uint32_t ret;
-	int retval = armv4_5_mmu_translate_va(target, &arm926ejs->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
+	int retval = armv4_5_mmu_translate_va(target, &arm926ejs->armv4_5_mmu,
+			virtual, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*physical = ret;
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 52756c1..78163f1 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -26,7 +26,7 @@
 #include "armv4_5_mmu.h"
 
 
-int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, int *type, uint32_t *cb, int *domain, uint32_t *ap, uint32_t *val)
+int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, uint32_t *cb, int *domain, uint32_t *ap, uint32_t *val)
 {
 	uint32_t first_lvl_descriptor = 0x0;
 	uint32_t second_lvl_descriptor = 0x0;
@@ -60,7 +60,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	if ((first_lvl_descriptor & 0x3) == 2)
 	{
 		/* section descriptor */
-		*type = ARMV4_5_SECTION;
 		*cb = (first_lvl_descriptor & 0xc) >> 2;
 		*ap = (first_lvl_descriptor & 0xc00) >> 10;
 		*val = (first_lvl_descriptor & 0xfff00000) | (va & 0x000fffff);
@@ -102,7 +101,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	if ((second_lvl_descriptor & 0x3) == 1)
 	{
 		/* large page descriptor */
-		*type = ARMV4_5_LARGE_PAGE;
 		*ap = (second_lvl_descriptor & 0xff0) >> 4;
 		*val = (second_lvl_descriptor & 0xffff0000) | (va & 0x0000ffff);
 		return ERROR_OK;
@@ -111,7 +109,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	if ((second_lvl_descriptor & 0x3) == 2)
 	{
 		/* small page descriptor */
-		*type = ARMV4_5_SMALL_PAGE;
 		*ap = (second_lvl_descriptor & 0xff0) >> 4;
 		*val = (second_lvl_descriptor & 0xfffff000) | (va & 0x00000fff);
 		return ERROR_OK;
@@ -120,7 +117,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	if ((second_lvl_descriptor & 0x3) == 3)
 	{
 		/* tiny page descriptor */
-		*type = ARMV4_5_TINY_PAGE;
 		*ap = (second_lvl_descriptor & 0x30) >> 4;
 		*val = (second_lvl_descriptor & 0xfffffc00) | (va & 0x000003ff);
 		return ERROR_OK;
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 3a6851f..8f540a6 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -36,15 +36,8 @@ struct armv4_5_mmu_common
 	int mmu_enabled;
 };
 
-enum
-{
-	ARMV4_5_SECTION, ARMV4_5_LARGE_PAGE, ARMV4_5_SMALL_PAGE, ARMV4_5_TINY_PAGE
-};
-
-extern char* armv4_5_page_type_names[];
-
 int armv4_5_mmu_translate_va(struct target *target,
-		struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, int *type,
+		struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va,
 		uint32_t *cb, int *domain, uint32_t *ap, uint32_t *val);
 
 int armv4_5_mmu_read_physical(struct target *target,
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index f154179..e26bb3d 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1801,7 +1801,6 @@ static int cortex_a8_mmu(struct target *target, int *enabled)
 static int cortex_a8_virt2phys(struct target *target,
 		uint32_t virt, uint32_t *phys)
 {
-	int type;
 	uint32_t cb;
 	int domain;
 	uint32_t ap;
@@ -1819,7 +1818,7 @@ static int cortex_a8_virt2phys(struct target *target,
         cortex_a8->current_address_mode = ARM_MODE_SVC;
 	uint32_t ret;
 	int retval = armv4_5_mmu_translate_va(target,
-			&armv7a->armv4_5_mmu, virt, &type, &cb, &domain, &ap, &ret);
+			&armv7a->armv4_5_mmu, virt, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
     /* Reset the flag. We don't want someone else to use it by error */
diff --git a/src/target/xscale.c b/src/target/xscale.c
index d16f8ec..e2b4b6d 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3216,7 +3216,6 @@ static int xscale_virt2phys(struct target *target,
 		uint32_t virtual, uint32_t *physical)
 {
 	struct xscale_common *xscale = target_to_xscale(target);
-	int type;
 	uint32_t cb;
 	int domain;
 	uint32_t ap;
@@ -3227,7 +3226,8 @@ static int xscale_virt2phys(struct target *target,
 	}
 
 	uint32_t ret;
-	int retval = armv4_5_mmu_translate_va(target, &xscale->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
+	int retval = armv4_5_mmu_translate_va(target, &xscale->armv4_5_mmu,
+			virtual, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*physical = ret;

commit ce58ab9a4ef7f014eac4d2e30d2b54b2c3e53895
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 12 11:46:56 2010 +0800

    TARGET: fix handling return code of MMU translation
    
    Function armv4_5_mmu_translate_va() now properly signals
    errors in the return value.
    Remove former error handling by setting variable "type" to
    value "-1".
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 867eb94..e7672b4 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -264,10 +264,6 @@ static int arm720_virt2phys(struct target *target,
 	int retval = armv4_5_mmu_translate_va(target, &arm720t->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
-	if (type == -1)
-	{
-		return ret;
-	}
 	*physical = ret;
 	return ERROR_OK;
 }
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index d709648..fe2ff01 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -519,10 +519,6 @@ static int arm920_virt2phys(struct target *target,
 			&arm920t->armv4_5_mmu, virt, &type, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
-	if (type == -1)
-	{
-		return ret;
-	}
 	*phys = ret;
 	return ERROR_OK;
 }
@@ -596,8 +592,6 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 				address, &type, &cb, &domain, &ap, &pa);
 		if (retval != ERROR_OK)
 			return retval;
-		if (type == -1)
-			return pa;
 
 		if (arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		{
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index a7aac55..bfa2ab4 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -730,10 +730,6 @@ static int arm926ejs_virt2phys(struct target *target, uint32_t virtual, uint32_t
 	int retval = armv4_5_mmu_translate_va(target, &arm926ejs->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
-	if (type == -1)
-	{
-		return ret;
-	}
 	*physical = ret;
 	return ERROR_OK;
 }
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 6990d13..52756c1 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -44,14 +44,12 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 
 	if ((first_lvl_descriptor & 0x3) == 0)
 	{
-		*type = -1;
 		LOG_ERROR("Address translation failure");
 		return ERROR_TARGET_TRANSLATION_FAULT;
 	}
 
 	if (!armv4_5_mmu->has_tiny_pages && ((first_lvl_descriptor & 0x3) == 3))
 	{
-		*type = -1;
 		LOG_ERROR("Address translation failure");
 		return ERROR_TARGET_TRANSLATION_FAULT;
 	}
@@ -94,7 +92,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 
 	if ((second_lvl_descriptor & 0x3) == 0)
 	{
-		*type = -1;
 		LOG_ERROR("Address translation failure");
 		return ERROR_TARGET_TRANSLATION_FAULT;
 	}
@@ -130,7 +127,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	}
 
 	/* should not happen */
-	*type = -1;
 	LOG_ERROR("Address translation failure");
 	return ERROR_TARGET_TRANSLATION_FAULT;
 }
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 2edb9e3..f154179 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1825,10 +1825,6 @@ static int cortex_a8_virt2phys(struct target *target,
     /* Reset the flag. We don't want someone else to use it by error */
     cortex_a8->current_address_mode = ARM_MODE_ANY;
 
-	if (type == -1)
-	{
-		return ret;
-	}
 	*phys = ret;
 	return ERROR_OK;
 }
diff --git a/src/target/xscale.c b/src/target/xscale.c
index ab7eee3..d16f8ec 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3230,10 +3230,6 @@ static int xscale_virt2phys(struct target *target,
 	int retval = armv4_5_mmu_translate_va(target, &xscale->armv4_5_mmu, virtual, &type, &cb, &domain, &ap, &ret);
 	if (retval != ERROR_OK)
 		return retval;
-	if (type == -1)
-	{
-		return ret;
-	}
 	*physical = ret;
 	return ERROR_OK;
 }

commit dcc7de4f9b4dfa58ed8a8712c4c146a3c83aba17
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 12 11:07:47 2010 +0800

    TARGET/ARM920T: fix return value
    
    Function arm920t_write_memory() default return value
    should be ERROR_OK.
    All cases of local errors are handled immediately and
    not further propagated.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 03aa233..d709648 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -711,7 +711,7 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 		}
 	}
 
-	return retval;
+	return ERROR_OK;
 }
 
 // EXPORTED to FA256

commit 20724e33250c48aa8f1e9332d1704dd8d58cda9b
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 12 11:01:24 2010 +0800

    TARGET/ARM920T: fix compile warning
    
    Commit 0538081246fafbfb74d554bb1b758412534aa254
    introduces a compile time warning:
    arm920t.c: In function ???arm920t_write_memory???:
    arm920t.c:567: warning: ???retval??? may be used uninitialized in this function
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 3175196..03aa233 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -592,7 +592,7 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 		/*
 		 * We need physical address and cb
 		 */
-		int retval = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu,
+		retval = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu,
 				address, &type, &cb, &domain, &ap, &pa);
 		if (retval != ERROR_OK)
 			return retval;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm720t.c     |    8 ++------
 src/target/arm920t.c     |   16 ++++------------
 src/target/arm926ejs.c   |    8 ++------
 src/target/armv4_5_mmu.c |   10 +---------
 src/target/armv4_5_mmu.h |    9 +--------
 src/target/cortex_a8.c   |    7 +------
 src/target/xscale.c      |    8 ++------
 7 files changed, 13 insertions(+), 53 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Jun 12 16:46:53 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 12 Jun 2010 14:46:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-292-gbac52fb
Message-ID: <E1ONRz5-0007wn-9R@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bac52fbac83f0d04fb51a2547e6ae76fff1ac1dc (commit)
      from  9e62f86f24dbd1a3f8d1a84fbfd18dc15dc23002 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bac52fbac83f0d04fb51a2547e6ae76fff1ac1dc
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 12 18:35:06 2010 +0800

    TARGET: removed unused parameters
    
    Parameters "domain" and "ap" of function armv4_5_mmu_translate_va()
    are not used.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index d450224..8db0b5d 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -255,13 +255,11 @@ static int arm720_virt2phys(struct target *target,
 		uint32_t virtual, uint32_t *physical)
 {
 	uint32_t cb;
-	int domain;
-	uint32_t ap;
 	struct arm720t_common *arm720t = target_to_arm720(target);
 
 	uint32_t ret;
 	int retval = armv4_5_mmu_translate_va(target,
-			&arm720t->armv4_5_mmu, virtual, &cb, &domain, &ap, &ret);
+			&arm720t->armv4_5_mmu, virtual, &cb, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*physical = ret;
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index b8ff819..b99b4d5 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -509,13 +509,11 @@ static int arm920_virt2phys(struct target *target,
 		uint32_t virt, uint32_t *phys)
 {
 	uint32_t cb;
-	int domain;
-	uint32_t ap;
 	struct arm920t_common *arm920t = target_to_arm920(target);
 
 	uint32_t ret;
 	int retval = armv4_5_mmu_translate_va(target,
-			&arm920t->armv4_5_mmu, virt, &cb, &domain, &ap, &ret);
+			&arm920t->armv4_5_mmu, virt, &cb, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*phys = ret;
@@ -579,15 +577,13 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 		 * by MMU
 		 */
 		uint32_t cb;
-		int domain;
-		uint32_t ap;
 		uint32_t pa;
 
 		/*
 		 * We need physical address and cb
 		 */
 		retval = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu,
-				address, &cb, &domain, &ap, &pa);
+				address, &cb, &pa);
 		if (retval != ERROR_OK)
 			return retval;
 
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index dd1d365..918306d 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -721,13 +721,11 @@ COMMAND_HANDLER(arm926ejs_handle_cache_info_command)
 static int arm926ejs_virt2phys(struct target *target, uint32_t virtual, uint32_t *physical)
 {
 	uint32_t cb;
-	int domain;
-	uint32_t ap;
 	struct arm926ejs_common *arm926ejs = target_to_arm926(target);
 
 	uint32_t ret;
 	int retval = armv4_5_mmu_translate_va(target, &arm926ejs->armv4_5_mmu,
-			virtual, &cb, &domain, &ap, &ret);
+			virtual, &cb, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*physical = ret;
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
index 78163f1..861410d 100644
--- a/src/target/armv4_5_mmu.c
+++ b/src/target/armv4_5_mmu.c
@@ -26,7 +26,7 @@
 #include "armv4_5_mmu.h"
 
 
-int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, uint32_t *cb, int *domain, uint32_t *ap, uint32_t *val)
+int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va, uint32_t *cb, uint32_t *val)
 {
 	uint32_t first_lvl_descriptor = 0x0;
 	uint32_t second_lvl_descriptor = 0x0;
@@ -54,14 +54,10 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 		return ERROR_TARGET_TRANSLATION_FAULT;
 	}
 
-	/* domain is always specified in bits 8-5 */
-	*domain = (first_lvl_descriptor & 0x1e0) >> 5;
-
 	if ((first_lvl_descriptor & 0x3) == 2)
 	{
 		/* section descriptor */
 		*cb = (first_lvl_descriptor & 0xc) >> 2;
-		*ap = (first_lvl_descriptor & 0xc00) >> 10;
 		*val = (first_lvl_descriptor & 0xfff00000) | (va & 0x000fffff);
 		return ERROR_OK;
 	}
@@ -101,7 +97,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	if ((second_lvl_descriptor & 0x3) == 1)
 	{
 		/* large page descriptor */
-		*ap = (second_lvl_descriptor & 0xff0) >> 4;
 		*val = (second_lvl_descriptor & 0xffff0000) | (va & 0x0000ffff);
 		return ERROR_OK;
 	}
@@ -109,7 +104,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	if ((second_lvl_descriptor & 0x3) == 2)
 	{
 		/* small page descriptor */
-		*ap = (second_lvl_descriptor & 0xff0) >> 4;
 		*val = (second_lvl_descriptor & 0xfffff000) | (va & 0x00000fff);
 		return ERROR_OK;
 	}
@@ -117,7 +111,6 @@ int armv4_5_mmu_translate_va(struct target *target, struct armv4_5_mmu_common *a
 	if ((second_lvl_descriptor & 0x3) == 3)
 	{
 		/* tiny page descriptor */
-		*ap = (second_lvl_descriptor & 0x30) >> 4;
 		*val = (second_lvl_descriptor & 0xfffffc00) | (va & 0x000003ff);
 		return ERROR_OK;
 	}
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
index 8f540a6..24f3993 100644
--- a/src/target/armv4_5_mmu.h
+++ b/src/target/armv4_5_mmu.h
@@ -38,7 +38,7 @@ struct armv4_5_mmu_common
 
 int armv4_5_mmu_translate_va(struct target *target,
 		struct armv4_5_mmu_common *armv4_5_mmu, uint32_t va,
-		uint32_t *cb, int *domain, uint32_t *ap, uint32_t *val);
+		uint32_t *cb, uint32_t *val);
 
 int armv4_5_mmu_read_physical(struct target *target,
 		struct armv4_5_mmu_common *armv4_5_mmu,
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index e26bb3d..c2d61a3 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1802,8 +1802,6 @@ static int cortex_a8_virt2phys(struct target *target,
 		uint32_t virt, uint32_t *phys)
 {
 	uint32_t cb;
-	int domain;
-	uint32_t ap;
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	// struct armv7a_common *armv7a = &cortex_a8->armv7a_common;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -1818,7 +1816,7 @@ static int cortex_a8_virt2phys(struct target *target,
         cortex_a8->current_address_mode = ARM_MODE_SVC;
 	uint32_t ret;
 	int retval = armv4_5_mmu_translate_va(target,
-			&armv7a->armv4_5_mmu, virt, &cb, &domain, &ap, &ret);
+			&armv7a->armv4_5_mmu, virt, &cb, &ret);
 	if (retval != ERROR_OK)
 		return retval;
     /* Reset the flag. We don't want someone else to use it by error */
diff --git a/src/target/xscale.c b/src/target/xscale.c
index e2b4b6d..d5c2129 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3217,8 +3217,6 @@ static int xscale_virt2phys(struct target *target,
 {
 	struct xscale_common *xscale = target_to_xscale(target);
 	uint32_t cb;
-	int domain;
-	uint32_t ap;
 
 	if (xscale->common_magic != XSCALE_COMMON_MAGIC) {
 		LOG_ERROR(xscale_not);
@@ -3227,7 +3225,7 @@ static int xscale_virt2phys(struct target *target,
 
 	uint32_t ret;
 	int retval = armv4_5_mmu_translate_va(target, &xscale->armv4_5_mmu,
-			virtual, &cb, &domain, &ap, &ret);
+			virtual, &cb, &ret);
 	if (retval != ERROR_OK)
 		return retval;
 	*physical = ret;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm720t.c     |    4 +---
 src/target/arm920t.c     |    8 ++------
 src/target/arm926ejs.c   |    4 +---
 src/target/armv4_5_mmu.c |    9 +--------
 src/target/armv4_5_mmu.h |    2 +-
 src/target/cortex_a8.c   |    4 +---
 src/target/xscale.c      |    4 +---
 7 files changed, 8 insertions(+), 27 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 14 09:35:27 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 14 Jun 2010 07:35:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-293-gaa2de47
Message-ID: <E1OO4Cf-0008SG-Mb@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  aa2de47d3ce4d484c124f0449702f511aab49112 (commit)
      from  bac52fbac83f0d04fb51a2547e6ae76fff1ac1dc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit aa2de47d3ce4d484c124f0449702f511aab49112
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 09:30:37 2010 +0200

    target: fix retval gaffe in mwX commands
    
    failure to write to memory was not propagated.
    
    This is an interesting case of broken error handling:
    with exceptions we wouldn't have had this at all,
    and I also wonder if there is a GCC option to warn
    about these kinds of potential bugs.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 01d9441..435d7b6 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2378,7 +2378,7 @@ static int target_fill_mem(struct target *target,
 		{
 			current = chunk_size;
 		}
-		int retval = fn(target, address + x * data_size, data_size, current, target_buf);
+		retval = fn(target, address + x * data_size, data_size, current, target_buf);
 		if (retval != ERROR_OK)
 		{
 			break;

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 14 10:00:47 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 14 Jun 2010 08:00:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-294-g18918a0
Message-ID: <E1OO4bB-0001Qc-Rq@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  18918a0423e04180f580a4a9453e190488aab17d (commit)
      from  aa2de47d3ce4d484c124f0449702f511aab49112 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 18918a0423e04180f580a4a9453e190488aab17d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 09:47:33 2010 +0200

    cfi: fix gaffe introduced in previous version
    
    flash probe broke w/in last commit.
    
    ecc8041c0f4c30a7310c0f8414a5261ee7a090ca
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index f911bb7..714cbe4 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -2473,10 +2473,10 @@ static int cfi_probe(struct flash_bank *bank)
 			(1 << cfi_info->chip_erase_timeout_max) * (1 << cfi_info->chip_erase_timeout_typ));
 
 		uint8_t data;
-		retval = 1 << cfi_query_u8(bank, 0, 0x27, &data);
+		retval = cfi_query_u8(bank, 0, 0x27, &data);
 		if (retval != ERROR_OK)
 			return retval;
-		cfi_info->dev_size = data;
+		cfi_info->dev_size = 1 << data;
 
 		retval = cfi_query_u16(bank, 0, 0x28, &cfi_info->interface_desc);
 		if (retval != ERROR_OK)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 14 12:29:36 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 14 Jun 2010 10:29:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-296-gb6a8254
Message-ID: <E1OO6vE-0001yK-Ex@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b6a82540654f02dbf4caaed1be538044220dd3dc (commit)
       via  f3ae52cace69f9568bac719d50af3a62993e96ad (commit)
      from  18918a0423e04180f580a4a9453e190488aab17d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b6a82540654f02dbf4caaed1be538044220dd3dc
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 12:08:46 2010 +0200

    flash: fix bug in error propagation of flash write_image
    
    when a write/unlock/erase failed during write_image, then
    an error was not propagated back up so e.g. flash write
    image from tcl scripts would not throw an exception.
    
    Also flash filling speed was printed even when the
    operation failed. Output is now less confusing.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 714cbe4..c134317 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -2383,8 +2383,6 @@ static int cfi_probe(struct flash_bank *bank)
 	 */
 	if (cfi_info->not_cfi == 0)
 	{
-		int retval;
-
 		/* enter CFI query mode
 		 * according to JEDEC Standard No. 68.01,
 		 * a single bus sequence with address = 0x55, data = 0x98 should put
@@ -2716,7 +2714,7 @@ static int cfi_protect_check(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
-static int cfi_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_cfi_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	int printed;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
@@ -2806,5 +2804,5 @@ struct flash_driver cfi_flash = {
 	/* FIXME: access flash at bus_width size */
 	.erase_check = default_flash_blank_check,
 	.protect_check = cfi_protect_check,
-	.info = cfi_info,
+	.info = get_cfi_info,
 };
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index d2f2754..84408e6 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -599,7 +599,6 @@ int flash_write_unlock(struct target *target, struct image *image,
 		}
 
 		/* find the corresponding flash bank */
-		int retval;
 		retval = get_flash_bank_by_addr(target, run_address, false, &c);
 		if (retval != ERROR_OK)
 			return retval;
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 3d67327..28a504e 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -576,7 +576,7 @@ COMMAND_HANDLER(handle_flash_fill_command)
 		}
 	}
 
-	if (duration_measure(&bench) == ERROR_OK)
+	if ((retval == ERROR_OK) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "wrote %" PRIu32 " bytes to 0x%8.8" PRIx32
 				" in %fs (%0.3f KiB/s)", wrote, address,

commit f3ae52cace69f9568bac719d50af3a62993e96ad
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 12:10:35 2010 +0200

    helper: fix -Wshadow warning in number parsing
    
    use obtuse local variable names in macros to avoid
    interfering with global name space
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.h b/src/helper/command.h
index 2c19241..1bf2cb4 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -387,11 +387,11 @@ DECLARE_PARSE_WRAPPER(_s8, int8_t);
  */
 #define COMMAND_PARSE_NUMBER(type, in, out) \
 	do { \
-		int retval = parse_##type(in, &(out)); \
-		if (ERROR_OK != retval) { \
+		int retval_macro_tmp = parse_##type(in, &(out)); \
+		if (ERROR_OK != retval_macro_tmp) { \
 			command_print(CMD_CTX, stringify(out) \
 				" option value ('%s') is not valid", in); \
-			return retval; \
+			return retval_macro_tmp; \
 		} \
 	} while (0)
 
@@ -404,13 +404,13 @@ DECLARE_PARSE_WRAPPER(_s8, int8_t);
 #define COMMAND_PARSE_BOOL(in, out, on, off) \
 	do { \
 		bool value; \
-		int retval = command_parse_bool_arg(in, &value); \
-		if (ERROR_OK != retval) { \
+		int retval_macro_tmp = command_parse_bool_arg(in, &value); \
+		if (ERROR_OK != retval_macro_tmp) { \
 			command_print(CMD_CTX, stringify(out) \
 				" option value ('%s') is not valid", in); \
 			command_print(CMD_CTX, "  choices are '%s' or '%s'", \
 				on, off); \
-			return retval; \
+			return retval_macro_tmp; \
 		} \
 		out = value; \
 	} while (0)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c  |    6 ++----
 src/flash/nor/core.c |    1 -
 src/flash/nor/tcl.c  |    2 +-
 src/helper/command.h |   12 ++++++------
 4 files changed, 9 insertions(+), 12 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 14 15:43:56 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 14 Jun 2010 13:43:56 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-297-g9132f70
Message-ID: <E1OO9xI-0008BN-FY@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9132f7083d01510eb1c2471a7c3f3247e35cdf3b (commit)
      from  b6a82540654f02dbf4caaed1be538044220dd3dc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9132f7083d01510eb1c2471a7c3f3247e35cdf3b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 15:42:39 2010 +0200

    cfi: add LOG_ERROR() in case of unsupported intel erase algorithm
    
    found by code inspection. There are many other places in
    CFI where LOG_ERROR() should be called similarly...
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index c134317..96aca48 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -979,7 +979,10 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 	 * instant individual block locking (bit 5).
 	 */
 	if (!(pri_ext->feature_support & 0x28))
+	{
+		LOG_ERROR("lock/unlock not supported on flash");
 		return ERROR_FLASH_OPERATION_FAILED;
+	}
 
 	cfi_intel_clear_status_register(bank);
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 14 22:12:54 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 14 Jun 2010 20:12:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-298-g3e51d89
Message-ID: <E1OOG1g-0004MQ-MU@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3e51d893ed3d1273b5487e05196f00fe3d14773d (commit)
      from  9132f7083d01510eb1c2471a7c3f3247e35cdf3b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3e51d893ed3d1273b5487e05196f00fe3d14773d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 11:51:25 2010 +0200

    -Wshadow fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/common.c b/src/flash/common.c
index 17bc81c..46cb243 100644
--- a/src/flash/common.c
+++ b/src/flash/common.c
@@ -25,13 +25,13 @@
 
 unsigned get_flash_name_index(const char *name)
 {
-	const char *index = strrchr(name, '.');
-	if (NULL == index)
+	const char *name_index = strrchr(name, '.');
+	if (NULL == name_index)
 		return 0;
-	if (index[1] < '0' || index[1] > '9')
+	if (name_index[1] < '0' || name_index[1] > '9')
 		return ~0U;
 	unsigned requested;
-	int retval = parse_uint(index + 1, &requested);
+	int retval = parse_uint(name_index + 1, &requested);
 	// detect parsing error by forcing past end of bank list
 	return (ERROR_OK == retval) ? requested : ~0U;
 }
diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index 40324f2..93d00d5 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -649,7 +649,7 @@ static int lpc3180_write_page(struct nand_device *nand, uint32_t page, uint8_t *
                *
                **********************************************************************/
         
-               int retval,i=0,target_mem_base;
+               int i=0,target_mem_base;
                uint8_t *ecc_flash_buffer;
                struct working_area *pworking_area;
     
diff --git a/src/helper/fileio.c b/src/helper/fileio.c
index 8f2ce22..71e807f 100644
--- a/src/helper/fileio.c
+++ b/src/helper/fileio.c
@@ -33,24 +33,24 @@
 
 static inline int fileio_open_local(struct fileio *fileio)
 {
-	char access[4];
+	char file_access[4];
 
 	switch (fileio->access)
 	{
 		case FILEIO_READ:
-			strcpy(access, "r");
+			strcpy(file_access, "r");
 			break;
 		case FILEIO_WRITE:
-			strcpy(access, "w");
+			strcpy(file_access, "w");
 			break;
 		case FILEIO_READWRITE:
-			strcpy(access, "w+");
+			strcpy(file_access, "w+");
 			break;
 		case FILEIO_APPEND:
-			strcpy(access, "a");
+			strcpy(file_access, "a");
 			break;
 		case FILEIO_APPENDREAD:
-			strcpy(access, "a+");
+			strcpy(file_access, "a+");
 			break;
 		default:
 			LOG_ERROR("BUG: access neither read, write nor readwrite");
@@ -62,10 +62,10 @@ static inline int fileio_open_local(struct fileio *fileio)
 	if (fileio->type == FILEIO_BINARY)
 #endif
 	{
-		strcat(access, "b");
+		strcat(file_access, "b");
 	}
 
-	if (!(fileio->file = open_file_from_path (fileio->url, access)))
+	if (!(fileio->file = open_file_from_path (fileio->url, file_access)))
 	{
 		LOG_ERROR("couldn't open %s", fileio->url);
 		return ERROR_FILEIO_OPERATION_FAILED;
diff --git a/src/server/server.c b/src/server/server.c
index 57c4016..7d8ad51 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -264,7 +264,7 @@ int server_loop(struct command_context *command_context)
 {
 	struct service *service;
 
-	bool poll = true;
+	bool poll_ok = true;
 
 	/* used in select() */
 	fd_set read_fds;
@@ -322,7 +322,7 @@ int server_loop(struct command_context *command_context)
 
 		struct timeval tv;
 		tv.tv_sec = 0;
-		if (poll)
+		if (poll_ok)
 		{
 			/* we're just polling this iteration, this is faster on embedded
 			 * hosts */
@@ -375,11 +375,11 @@ int server_loop(struct command_context *command_context)
 			FD_ZERO(&read_fds); /* eCos leaves read_fds unchanged in this case!  */
 
 			/* We timed out/there was nothing to do, timeout rather than poll next time */
-			poll = false;
+			poll_ok = false;
 		} else
 		{
 			/* There was something to do, next time we'll just poll */
-			poll = true;
+			poll_ok = true;
 		}
 
 		for (service = services; service; service = service->next)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/common.c       |    8 ++++----
 src/flash/nand/lpc3180.c |    2 +-
 src/helper/fileio.c      |   16 ++++++++--------
 src/server/server.c      |    8 ++++----
 4 files changed, 17 insertions(+), 17 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 07:40:26 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 05:40:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-299-gbf3410f
Message-ID: <E1OOOst-0005HN-UH@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bf3410fcc711f6601f1f8eb39c5df57cf8cfe535 (commit)
      from  3e51d893ed3d1273b5487e05196f00fe3d14773d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bf3410fcc711f6601f1f8eb39c5df57cf8cfe535
Author: michal smulski <michal.smulski at ooma.com>
Date:   Mon Jun 14 15:13:09 2010 -0700

    arm1136 scripts
    
    Here is a patch to fix a startup in C100 (arm1136). Basically make sure
    that UART is configured before using it.
    
    Michal
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/c100helper.tcl b/tcl/target/c100helper.tcl
index 477fe5c..2a12c36 100644
--- a/tcl/target/c100helper.tcl
+++ b/tcl/target/c100helper.tcl
@@ -469,11 +469,12 @@ proc initC100 {} {
     mww $INTC_ARM1_CONTROL_REG 0x1
     # configure clocks
     setupPLL
+    # setupUART0 must be run before setupDDR2 as setupDDR2 uses UART.
+    setupUART0
     # enable cache
     # ? (u-boot does nothing here)
     # DDR2 memory init
     setupDDR2
-    setupUART0
     putsUART0 "C100 initialization complete.\n"
     puts "C100 initialization complete."
 }

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/c100helper.tcl |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 10:40:33 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 08:40:33 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-300-gc9e2d13
Message-ID: <E1OORhH-0003h2-E9@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c9e2d13cf9410b48612fef023a91b8e29c4a090d (commit)
      from  bf3410fcc711f6601f1f8eb39c5df57cf8cfe535 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c9e2d13cf9410b48612fef023a91b8e29c4a090d
Author: Thomas Koeller <thomas.koeller at baslerweb.com>
Date:   Tue Jun 15 10:37:05 2010 +0200

    DM36x: pll & clock setup
    
    Added a function 'pll_v03_setup' to set up PLLs and clock
    dividers on DM365 and DM368.
    
    Signed-off-by: Thomas Koeller <thomas.koeller at baslerweb.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/davinci.cfg b/tcl/target/davinci.cfg
index ee840c8..31750dd 100644
--- a/tcl/target/davinci.cfg
+++ b/tcl/target/davinci.cfg
@@ -143,6 +143,133 @@ proc pll_v02_setup {pll_addr mult config} {
 	mww $pll_ctrl_addr $pll_ctrl
 }
 
+# PLL version 0x03: tested on dm365
+proc pll_v03_setup {pll_addr mult config} {
+	set pll_ctrl_addr [expr $pll_addr + 0x100]
+	set pll_secctrl_addr [expr $pll_addr + 0x108]
+	set pll_ctrl [mrw $pll_ctrl_addr]
+
+	# 1 - power up the PLL
+	set pll_ctrl [expr $pll_ctrl & ~0x0002]
+	mww $pll_ctrl_addr $pll_ctrl
+
+	# 2 - clear PLLENSRC (bit 5)
+	set pll_ctrl [expr $pll_ctrl & ~0x0020]
+	mww $pll_ctrl_addr $pll_ctrl
+
+	# 2 - clear PLLEN (bit 0) ... enter bypass mode
+	set pll_ctrl [expr $pll_ctrl & ~0x0001]
+	mww $pll_ctrl_addr $pll_ctrl
+
+	# 3 - wait at least 4 refclk cycles
+	sleep 1
+
+	# 4 - set PLLRST (bit 3)
+	set pll_ctrl [expr $pll_ctrl | 0x0008]
+	mww $pll_ctrl_addr $pll_ctrl
+
+	# 5 - wait at least 5 usec
+	sleep 1
+
+	# 6 - clear PLLRST (bit 3)
+	set pll_ctrl [expr $pll_ctrl & ~0x0008]
+	mww $pll_ctrl_addr $pll_ctrl
+
+	# 9 - optional:  write prediv, postdiv, and pllm
+	mww [expr $pll_addr + 0x0110] [expr ($mult / 2) & 0x1ff]
+	if { [dict exists $config prediv] } {
+		set div [dict get $config prediv]
+		set div [expr ($div - 1)]
+		mww [expr $pll_addr + 0x0114] $div
+	}
+	if { [dict exists $config postdiv] } {
+		set div [dict get $config postdiv]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0128] $div
+	}
+
+	# 10 - write start sequence to PLLSECCTL
+	mww $pll_secctrl_addr 0x00470000
+	mww $pll_secctrl_addr 0x00460000
+	mww $pll_secctrl_addr 0x00400000
+	mww $pll_secctrl_addr 0x00410000
+
+	# 11 - optional:  set plldiv1, plldiv2, ...
+	# NOTE:  this assumes some registers have their just-reset values:
+	#	- PLLSTAT.GOSTAT is clear when we enter
+	#	- ALNCTL has everything set
+	set aln 0
+	if { [dict exists $config div1] } {
+		set div [dict get $config div1]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0118] $div
+		set aln [expr $aln | 0x1]
+	}
+	if { [dict exists $config div2] } {
+		set div [dict get $config div2]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x011c] $div
+		set aln [expr $aln | 0x2]
+	}
+	if { [dict exists $config div3] } {
+		set div [dict get $config div3]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0120] $div
+		set aln [expr $aln | 0x4]
+	}
+	if { [dict exists $config div4] } {
+		set div [dict get $config div4]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0160] $div
+		set aln [expr $aln | 0x8]
+	}
+	if { [dict exists $config div5] } {
+		set div [dict get $config div5]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0164] $div
+		set aln [expr $aln | 0x10]
+	}
+	if { [dict exists $config div6] } {
+		set div [dict get $config div6]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0168] $div
+		set aln [expr $aln | 0x20]
+	}
+	if { [dict exists $config div7] } {
+		set div [dict get $config div7]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x016c] $div
+		set aln [expr $aln | 0x40]
+	}
+	if { [dict exists $config div8] } {
+		set div [dict get $config div8]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0170] $div
+		set aln [expr $aln | 0x80]
+	}
+	if { [dict exists $config div9] } {
+		set div [dict get $config div9]
+		set div [expr 0x8000 | ($div - 1)]
+		mww [expr $pll_addr + 0x0174] $div
+		set aln [expr $aln | 0x100]
+	}
+	if {$aln != 0} {
+		# write alingment flags
+		mww [expr $pll_addr + 0x0140] $aln
+		# write pllcmd.GO; poll pllstat.GO
+		mww [expr $pll_addr + 0x0138] 0x01
+		set pllstat [expr $pll_addr + 0x013c]
+		while {[expr [mrw $pllstat] & 0x01] != 0} { sleep 1 }
+	}
+	mww [expr $pll_addr + 0x0138] 0x00
+	set addr [dict get $config ctladdr]
+	while {[expr [mrw $addr] & 0x0e000000] != 0x0e000000} { sleep 1 }
+
+	# 12 - set PLLEN (bit 0) ... leave bypass mode
+	set pll_ctrl [expr $pll_ctrl | 0x0001]
+	mww $pll_ctrl_addr $pll_ctrl
+}
+
 # NOTE:  dm6446 requires EMURSTIE set in MDCTL before certain
 # modules can be enabled.
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/davinci.cfg |  127 ++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 127 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 22:45:51 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 20:45:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-302-g3c8a0e7
Message-ID: <E1OOd19-0006Pp-0a@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3c8a0e72f38e47bfc78dc7ab44ce2ec16cfac53b (commit)
       via  2eba49b8b135fd6cbf95920f2794b411027f3d2e (commit)
      from  c9e2d13cf9410b48612fef023a91b8e29c4a090d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3c8a0e72f38e47bfc78dc7ab44ce2ec16cfac53b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 22:29:41 2010 +0200

    jim: more jim -Wshadow fixes that should be straightforward
    
    this bunch was a bit less obvious, but looked
    straightforward.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/jim.c b/src/helper/jim.c
index b8d856f..8b0014f 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -3039,12 +3039,12 @@ int SetScriptFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
 
     JimParserInit(&parser, scriptText, scriptTextLen, initialLineNumber);
     while (!JimParserEof(&parser)) {
-        char *token;
+        char *token_t;
         int len, type, linenr;
 
         JimParseScript(&parser);
-        token = JimParserGetToken(&parser, &len, &type, &linenr);
-        ScriptObjAddToken(interp, script, token, len, type,
+        token_t = JimParserGetToken(&parser, &len, &type, &linenr);
+        ScriptObjAddToken(interp, script, token_t, len, type,
                 propagateSourceInfo ? script->fileName : NULL,
                 linenr);
     }
@@ -4505,7 +4505,7 @@ void Jim_FreeInterp(Jim_Interp *i)
     /* Check that the live object list is empty, otherwise
      * there is a memory leak. */
     if (i->liveList != NULL) {
-        Jim_Obj *objPtr = i->liveList;
+        objPtr = i->liveList;
 
         Jim_fprintf(i, i->cookie_stdout,JIM_NL "-------------------------------------" JIM_NL);
         Jim_fprintf(i, i->cookie_stdout,"Objects still in the free list:" JIM_NL);
@@ -5170,7 +5170,7 @@ void UpdateStringOfList(struct Jim_Obj *objPtr)
     realLength = 0;
     for (i = 0; i < objPtr->internalRep.listValue.len; i++) {
         int len, qlen;
-        const char *strRep = Jim_GetString(ele[i], &len);
+        strRep = Jim_GetString(ele[i], &len);
         char *q;
 
         switch (quotingType[i]) {
@@ -5745,7 +5745,7 @@ void UpdateStringOfDict(struct Jim_Obj *objPtr)
     realLength = 0;
     for (i = 0; i < objc; i++) {
         int len, qlen;
-        const char *strRep = Jim_GetString(objv[i], &len);
+        strRep = Jim_GetString(objv[i], &len);
         char *q;
 
         switch (quotingType[i]) {
@@ -11030,7 +11030,6 @@ static int Jim_ProcCoreCommand(Jim_Interp *interp, int argc,
 
         /* Check for default arguments and reduce arityMin if necessary */
         while (arityMin > 1) {
-            int len;
             Jim_ListIndex(interp, argv[2], arityMin - 2, &argPtr, JIM_NONE);
             Jim_ListLength(interp, argPtr, &len);
             if (len != 2) {

commit 2eba49b8b135fd6cbf95920f2794b411027f3d2e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 14 22:24:22 2010 +0200

    jim: -Wshadow fixes
    
    this batch of fixes should be pretty straightforward
    rename of 'index' and an 'i' local variable shadowing.
    
    'index' conflicts with a global name.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/jim.c b/src/helper/jim.c
index 53d1a75..b8d856f 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -397,14 +397,14 @@ int JimStringCompare(const char *s1, int l1, const char *s2, int l2,
 /* Search 's1' inside 's2', starting to search from char 'index' of 's2'.
  * The index of the first occurrence of s1 in s2 is returned.
  * If s1 is not found inside s2, -1 is returned. */
-int JimStringFirst(const char *s1, int l1, const char *s2, int l2, int index)
+int JimStringFirst(const char *s1, int l1, const char *s2, int l2, int index_t)
 {
     int i;
 
     if (!l1 || !l2 || l1 > l2) return -1;
-    if (index < 0) index = 0;
-    s2 += index;
-    for (i = index; i <= l2-l1; i++) {
+    if (index_t < 0) index_t = 0;
+    s2 += index_t;
+    for (i = index_t; i <= l2-l1; i++) {
         if (memcmp(s2, s1, l1) == 0)
             return i;
         s2++;
@@ -759,18 +759,18 @@ int Jim_ExpandHashTable(Jim_HashTable *ht, unsigned int size)
 /* Add an element to the target hash table */
 int Jim_AddHashEntry(Jim_HashTable *ht, const void *key, void *val)
 {
-    int index;
+    int index_t;
     Jim_HashEntry *entry;
 
     /* Get the index of the new element, or -1 if
      * the element already exists. */
-    if ((index = JimInsertHashEntry(ht, key)) == -1)
+    if ((index_t = JimInsertHashEntry(ht, key)) == -1)
         return JIM_ERR;
 
     /* Allocates the memory and stores key */
     entry = Jim_Alloc(sizeof(*entry));
-    entry->next = ht->table[index];
-    ht->table[index] = entry;
+    entry->next = ht->table[index_t];
+    ht->table[index_t] = entry;
 
     /* Set the hash entry fields. */
     Jim_SetHashKey(ht, entry, key);
@@ -2148,11 +2148,11 @@ int Jim_StringCompareObj(Jim_Obj *firstObjPtr,
  * This function may return negative values, or values
  * bigger or equal to the length of the list if the index
  * is out of range. */
-static int JimRelToAbsIndex(int len, int index)
+static int JimRelToAbsIndex(int len, int index_t)
 {
-    if (index < 0)
-        return len + index;
-    return index;
+    if (index_t < 0)
+        return len + index_t;
+    return index_t;
 }
 
 /* Convert a pair of index as normalize by JimRelToAbsIndex(),
@@ -5357,7 +5357,7 @@ void ListAppendElement(Jim_Obj *listPtr, Jim_Obj *objPtr)
  *
  * NOTE: this function can be called only against objects
  * with internal type of List. */
-void ListInsertElements(Jim_Obj *listPtr, int index, int elemc,
+void ListInsertElements(Jim_Obj *listPtr, int index_t, int elemc,
         Jim_Obj *const *elemVec)
 {
     int currentLen = listPtr->internalRep.listValue.len;
@@ -5373,8 +5373,8 @@ void ListInsertElements(Jim_Obj *listPtr, int index, int elemc,
                     sizeof(Jim_Obj*)*maxLen);
         listPtr->internalRep.listValue.maxLen = maxLen;
     }
-    point = listPtr->internalRep.listValue.ele + index;
-    memmove(point + elemc, point, (currentLen-index) * sizeof(Jim_Obj*));
+    point = listPtr->internalRep.listValue.ele + index_t;
+    memmove(point + elemc, point, (currentLen-index_t) * sizeof(Jim_Obj*));
     for (i = 0; i < elemc; ++i) {
         point[i] = elemVec[i];
         Jim_IncrRefCount(point[i]);
@@ -5433,57 +5433,57 @@ void Jim_ListLength(Jim_Interp *interp, Jim_Obj *listPtr, int *intPtr)
     *intPtr = listPtr->internalRep.listValue.len;
 }
 
-void Jim_ListInsertElements(Jim_Interp *interp, Jim_Obj *listPtr, int index,
+void Jim_ListInsertElements(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
         int objc, Jim_Obj *const *objVec)
 {
     if (Jim_IsShared(listPtr))
         Jim_Panic(interp,"Jim_ListInsertElement called with shared object");
     if (listPtr->typePtr != &listObjType)
         SetListFromAny(interp, listPtr);
-    if (index >= 0 && index > listPtr->internalRep.listValue.len)
-        index = listPtr->internalRep.listValue.len;
-    else if (index < 0)
-        index = 0;
+    if (index_t >= 0 && index_t > listPtr->internalRep.listValue.len)
+        index_t = listPtr->internalRep.listValue.len;
+    else if (index_t < 0)
+        index_t = 0;
     Jim_InvalidateStringRep(listPtr);
-    ListInsertElements(listPtr, index, objc, objVec);
+    ListInsertElements(listPtr, index_t, objc, objVec);
 }
 
-int Jim_ListIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index,
+int Jim_ListIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
         Jim_Obj **objPtrPtr, int flags)
 {
     if (listPtr->typePtr != &listObjType)
         SetListFromAny(interp, listPtr);
-    if ((index >= 0 && index >= listPtr->internalRep.listValue.len) ||
-        (index < 0 && (-index-1) >= listPtr->internalRep.listValue.len)) {
+    if ((index_t >= 0 && index_t >= listPtr->internalRep.listValue.len) ||
+        (index_t < 0 && (-index_t-1) >= listPtr->internalRep.listValue.len)) {
         if (flags & JIM_ERRMSG) {
             Jim_SetResultString(interp,
                 "list index out of range", -1);
         }
         return JIM_ERR;
     }
-    if (index < 0)
-        index = listPtr->internalRep.listValue.len + index;
-    *objPtrPtr = listPtr->internalRep.listValue.ele[index];
+    if (index_t < 0)
+        index_t = listPtr->internalRep.listValue.len + index_t;
+    *objPtrPtr = listPtr->internalRep.listValue.ele[index_t];
     return JIM_OK;
 }
 
-static int ListSetIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index,
+static int ListSetIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
         Jim_Obj *newObjPtr, int flags)
 {
     if (listPtr->typePtr != &listObjType)
         SetListFromAny(interp, listPtr);
-    if ((index >= 0 && index >= listPtr->internalRep.listValue.len) ||
-        (index < 0 && (-index-1) >= listPtr->internalRep.listValue.len)) {
+    if ((index_t >= 0 && index_t >= listPtr->internalRep.listValue.len) ||
+        (index_t < 0 && (-index_t-1) >= listPtr->internalRep.listValue.len)) {
         if (flags & JIM_ERRMSG) {
             Jim_SetResultString(interp,
-                "list index out of range", -1);
+                "list index_t out of range", -1);
         }
         return JIM_ERR;
     }
-    if (index < 0)
-        index = listPtr->internalRep.listValue.len + index;
-    Jim_DecrRefCount(interp, listPtr->internalRep.listValue.ele[index]);
-    listPtr->internalRep.listValue.ele[index] = newObjPtr;
+    if (index_t < 0)
+        index_t = listPtr->internalRep.listValue.len + index_t;
+    Jim_DecrRefCount(interp, listPtr->internalRep.listValue.ele[index_t]);
+    listPtr->internalRep.listValue.ele[index_t] = newObjPtr;
     Jim_IncrRefCount(newObjPtr);
     return JIM_OK;
 }
@@ -5495,7 +5495,7 @@ int Jim_SetListIndex(Jim_Interp *interp, Jim_Obj *varNamePtr,
         Jim_Obj *const *indexv, int indexc, Jim_Obj *newObjPtr)
 {
     Jim_Obj *varObjPtr, *objPtr, *listObjPtr;
-    int shared, i, index;
+    int shared, i, index_t;
 
     varObjPtr = objPtr = Jim_GetVariable(interp, varNamePtr, JIM_ERRMSG);
     if (objPtr == NULL)
@@ -5504,21 +5504,21 @@ int Jim_SetListIndex(Jim_Interp *interp, Jim_Obj *varNamePtr,
         varObjPtr = objPtr = Jim_DuplicateObj(interp, objPtr);
     for (i = 0; i < indexc-1; i++) {
         listObjPtr = objPtr;
-        if (Jim_GetIndex(interp, indexv[i], &index) != JIM_OK)
+        if (Jim_GetIndex(interp, indexv[i], &index_t) != JIM_OK)
             goto err;
-        if (Jim_ListIndex(interp, listObjPtr, index, &objPtr,
+        if (Jim_ListIndex(interp, listObjPtr, index_t, &objPtr,
                     JIM_ERRMSG) != JIM_OK) {
             goto err;
         }
         if (Jim_IsShared(objPtr)) {
             objPtr = Jim_DuplicateObj(interp, objPtr);
-            ListSetIndex(interp, listObjPtr, index, objPtr, JIM_NONE);
+            ListSetIndex(interp, listObjPtr, index_t, objPtr, JIM_NONE);
         }
         Jim_InvalidateStringRep(listObjPtr);
     }
-    if (Jim_GetIndex(interp, indexv[indexc-1], &index) != JIM_OK)
+    if (Jim_GetIndex(interp, indexv[indexc-1], &index_t) != JIM_OK)
         goto err;
-    if (ListSetIndex(interp, objPtr, index, newObjPtr, JIM_ERRMSG) == JIM_ERR)
+    if (ListSetIndex(interp, objPtr, index_t, newObjPtr, JIM_ERRMSG) == JIM_ERR)
         goto err;
     Jim_InvalidateStringRep(objPtr);
     Jim_InvalidateStringRep(varObjPtr);
@@ -6050,21 +6050,21 @@ void UpdateStringOfIndex(struct Jim_Obj *objPtr)
 
 int SetIndexFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
 {
-    int index, end = 0;
+    int index_t, end = 0;
     const char *str;
 
     /* Get the string representation */
     str = Jim_GetString(objPtr, NULL);
     /* Try to convert into an index */
     if (!strcmp(str, "end")) {
-        index = 0;
+        index_t = 0;
         end = 1;
     } else {
         if (!strncmp(str, "end-", 4)) {
             str += 4;
             end = 1;
         }
-        if (Jim_StringToIndex(str, &index) != JIM_OK) {
+        if (Jim_StringToIndex(str, &index_t) != JIM_OK) {
             Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
             Jim_AppendStrings(interp, Jim_GetResult(interp),
                     "bad index \"", Jim_GetString(objPtr, NULL), "\": "
@@ -6073,16 +6073,16 @@ int SetIndexFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
         }
     }
     if (end) {
-        if (index < 0)
-            index = INT_MAX;
+        if (index_t < 0)
+            index_t = INT_MAX;
         else
-            index = -(index + 1);
-    } else if (index < 0)
-        index = -INT_MAX;
+            index_t = -(index_t + 1);
+    } else if (index_t < 0)
+        index_t = -INT_MAX;
     /* Free the old internal repr and set the new one. */
     Jim_FreeIntRep(interp, objPtr);
     objPtr->typePtr = &indexObjType;
-    objPtr->internalRep.indexValue = index;
+    objPtr->internalRep.indexValue = index_t;
     return JIM_OK;
 }
 
@@ -6617,20 +6617,20 @@ static void ExprShareLiterals(Jim_Interp *interp, ExprByteCode *expr,
 static void ExprMakeLazy(Jim_Interp *interp, ExprByteCode *expr)
 {
     while (1) {
-        int index = -1, leftindex, arity, i, offset;
+        int index_t = -1, leftindex, arity, i, offset;
         Jim_ExprOperator *op;
 
         /* Search for || or && */
         for (i = 0; i < expr->len; i++) {
             if (expr->opcode[i] == JIM_EXPROP_LOGICAND ||
                 expr->opcode[i] == JIM_EXPROP_LOGICOR) {
-                index = i;
+                index_t = i;
                 break;
             }
         }
-        if (index == -1) return;
+        if (index_t == -1) return;
         /* Search for the end of the first operator */
-        leftindex = index-1;
+        leftindex = index_t-1;
         arity = 1;
         while (arity) {
             switch (expr->opcode[leftindex]) {
@@ -6660,23 +6660,23 @@ static void ExprMakeLazy(Jim_Interp *interp, ExprByteCode *expr)
         memmove(&expr->obj[leftindex + 2], &expr->obj[leftindex],
                 sizeof(Jim_Obj*)*(expr->len-leftindex));
         expr->len += 2;
-        index += 2;
-        offset = (index-leftindex)-1;
-        Jim_DecrRefCount(interp, expr->obj[index]);
-        if (expr->opcode[index] == JIM_EXPROP_LOGICAND) {
+        index_t += 2;
+        offset = (index_t-leftindex)-1;
+        Jim_DecrRefCount(interp, expr->obj[index_t]);
+        if (expr->opcode[index_t] == JIM_EXPROP_LOGICAND) {
             expr->opcode[leftindex + 1] = JIM_EXPROP_LOGICAND_LEFT;
-            expr->opcode[index] = JIM_EXPROP_LOGICAND_RIGHT;
+            expr->opcode[index_t] = JIM_EXPROP_LOGICAND_RIGHT;
             expr->obj[leftindex + 1] = Jim_NewStringObj(interp, "&L", -1);
-            expr->obj[index] = Jim_NewStringObj(interp, "&R", -1);
+            expr->obj[index_t] = Jim_NewStringObj(interp, "&R", -1);
         } else {
             expr->opcode[leftindex + 1] = JIM_EXPROP_LOGICOR_LEFT;
-            expr->opcode[index] = JIM_EXPROP_LOGICOR_RIGHT;
+            expr->opcode[index_t] = JIM_EXPROP_LOGICOR_RIGHT;
             expr->obj[leftindex + 1] = Jim_NewStringObj(interp, "|L", -1);
-            expr->obj[index] = Jim_NewStringObj(interp, "|R", -1);
+            expr->obj[index_t] = Jim_NewStringObj(interp, "|R", -1);
         }
         expr->opcode[leftindex] = JIM_EXPROP_NUMBER;
         expr->obj[leftindex] = Jim_NewIntObj(interp, offset);
-        Jim_IncrRefCount(expr->obj[index]);
+        Jim_IncrRefCount(expr->obj[index_t]);
         Jim_IncrRefCount(expr->obj[leftindex]);
         Jim_IncrRefCount(expr->obj[leftindex + 1]);
     }
@@ -7558,9 +7558,9 @@ JimScanAString(Jim_Interp *interp, const char *sdescr, const char *str)
         while (*sdescr) {
             if (sdescr[1] == '-' && sdescr[2] != 0) {
                 /* Handle range definitions */
-                int i;
-                for (i = sdescr[0]; i <= sdescr[2]; ++i)
-                    JimSetBit(charset, (char)i);
+                int i_t;
+                for (i_t = sdescr[0]; i_t <= sdescr[2]; ++i_t)
+                    JimSetBit(charset, (char)i_t);
                 sdescr += 3;
             } else {
                 /* Handle verbatim character definitions */
@@ -7591,7 +7591,7 @@ JimScanAString(Jim_Interp *interp, const char *sdescr, const char *str)
  * already scanned thru */
 
 static int ScanOneEntry(Jim_Interp *interp, const char *str, long pos,
-        ScanFmtStringObj *fmtObj, long index, Jim_Obj **valObjPtr)
+        ScanFmtStringObj *fmtObj, long index_t, Jim_Obj **valObjPtr)
 {
 #   define MAX_SIZE (sizeof(jim_wide) > sizeof(double) \
         ? sizeof(jim_wide)                             \
@@ -7599,7 +7599,7 @@ static int ScanOneEntry(Jim_Interp *interp, const char *str, long pos,
     char buffer[MAX_SIZE];
     char *value = buffer;
     const char *tok;
-    const ScanFmtPartDescr *descr = &fmtObj->descr[index];
+    const ScanFmtPartDescr *descr = &fmtObj->descr[index_t];
     size_t sLen = strlen(&str[pos]), scanned = 0;
     size_t anchor = pos;
     int i;
@@ -10473,7 +10473,7 @@ static int Jim_LindexCoreCommand(Jim_Interp *interp, int argc,
 {
     Jim_Obj *objPtr, *listObjPtr;
     int i;
-    int index;
+    int index_t;
 
     if (argc < 3) {
         Jim_WrongNumArgs(interp, 1, argv, "list index ?...?");
@@ -10483,11 +10483,11 @@ static int Jim_LindexCoreCommand(Jim_Interp *interp, int argc,
     Jim_IncrRefCount(objPtr);
     for (i = 2; i < argc; i++) {
         listObjPtr = objPtr;
-        if (Jim_GetIndex(interp, argv[i], &index) != JIM_OK) {
+        if (Jim_GetIndex(interp, argv[i], &index_t) != JIM_OK) {
             Jim_DecrRefCount(interp, listObjPtr);
             return JIM_ERR;
         }
-        if (Jim_ListIndex(interp, listObjPtr, index, &objPtr,
+        if (Jim_ListIndex(interp, listObjPtr, index_t, &objPtr,
                     JIM_NONE) != JIM_OK) {
             /* Returns an empty object if the index
              * is out of range. */
@@ -10556,7 +10556,7 @@ static int Jim_LappendCoreCommand(Jim_Interp *interp, int argc,
 static int Jim_LinsertCoreCommand(Jim_Interp *interp, int argc,
         Jim_Obj *const *argv)
 {
-    int index, len;
+    int index_t, len;
     Jim_Obj *listPtr;
 
     if (argc < 4) {
@@ -10567,14 +10567,14 @@ static int Jim_LinsertCoreCommand(Jim_Interp *interp, int argc,
     listPtr = argv[1];
     if (Jim_IsShared(listPtr))
         listPtr = Jim_DuplicateObj(interp, listPtr);
-    if (Jim_GetIndex(interp, argv[2], &index) != JIM_OK)
+    if (Jim_GetIndex(interp, argv[2], &index_t) != JIM_OK)
         goto err;
     Jim_ListLength(interp, listPtr, &len);
-    if (index >= len)
-        index = len;
-    else if (index < 0)
-        index = len + index + 1;
-    Jim_ListInsertElements(interp, listPtr, index, argc-3, &argv[3]);
+    if (index_t >= len)
+        index_t = len;
+    else if (index_t < 0)
+        index_t = len + index_t + 1;
+    Jim_ListInsertElements(interp, listPtr, index_t, argc-3, &argv[3]);
     Jim_SetResult(interp, listPtr);
     return JIM_OK;
 err:
@@ -11304,27 +11304,27 @@ static int Jim_StringCoreCommand(Jim_Interp *interp, int argc,
         Jim_SetResult(interp, objPtr);
         return JIM_OK;
     } else if (option == OPT_INDEX) {
-        int index, len;
+        int index_t, len;
         const char *str;
 
         if (argc != 4) {
             Jim_WrongNumArgs(interp, 2, argv, "string index");
             return JIM_ERR;
         }
-        if (Jim_GetIndex(interp, argv[3], &index) != JIM_OK)
+        if (Jim_GetIndex(interp, argv[3], &index_t) != JIM_OK)
             return JIM_ERR;
         str = Jim_GetString(argv[2], &len);
-        if (index != INT_MIN && index != INT_MAX)
-            index = JimRelToAbsIndex(len, index);
-        if (index < 0 || index >= len) {
+        if (index_t != INT_MIN && index_t != INT_MAX)
+            index_t = JimRelToAbsIndex(len, index_t);
+        if (index_t < 0 || index_t >= len) {
             Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
             return JIM_OK;
         } else {
-            Jim_SetResult(interp, Jim_NewStringObj(interp, str + index, 1));
+            Jim_SetResult(interp, Jim_NewStringObj(interp, str + index_t, 1));
             return JIM_OK;
         }
     } else if (option == OPT_FIRST) {
-        int index = 0, l1, l2;
+        int index_t = 0, l1, l2;
         const char *s1, *s2;
 
         if (argc != 4 && argc != 5) {
@@ -11334,12 +11334,12 @@ static int Jim_StringCoreCommand(Jim_Interp *interp, int argc,
         s1 = Jim_GetString(argv[2], &l1);
         s2 = Jim_GetString(argv[3], &l2);
         if (argc == 5) {
-            if (Jim_GetIndex(interp, argv[4], &index) != JIM_OK)
+            if (Jim_GetIndex(interp, argv[4], &index_t) != JIM_OK)
                 return JIM_ERR;
-            index = JimRelToAbsIndex(l2, index);
+            index_t = JimRelToAbsIndex(l2, index_t);
         }
         Jim_SetResult(interp, Jim_NewIntObj(interp,
-                    JimStringFirst(s1, l1, s2, l2, index)));
+                    JimStringFirst(s1, l1, s2, l2, index_t)));
         return JIM_OK;
     } else if (option == OPT_TOLOWER) {
         if (argc != 3) {

-----------------------------------------------------------------------

Summary of changes:
 src/helper/jim.c |  189 +++++++++++++++++++++++++++---------------------------
 1 files changed, 94 insertions(+), 95 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 22:48:44 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 20:48:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-303-g00017c9
Message-ID: <E1OOd3t-0006ad-Kx@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  00017c90ae82d3237f5a4784caa695459c5897d2 (commit)
      from  3c8a0e72f38e47bfc78dc7ab44ce2ec16cfac53b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 00017c90ae82d3237f5a4784caa695459c5897d2
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 22:47:52 2010 +0200

    jim: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/jim.c b/src/helper/#jim.c#
similarity index 99%
copy from src/helper/jim.c
copy to src/helper/#jim.c#
index 8b0014f..c8583de 100644
--- a/src/helper/jim.c
+++ b/src/helper/#jim.c#
@@ -3,7 +3,7 @@
  * Copyright 2005 Salvatore Sanfilippo <antirez at invece.org>
  * Copyright 2005 Clemens Hintze <c.hintze at gmx.net>
  * Copyright 2005 patthoyts - Pat Thoyts <patthoyts at users.sf.net>
- * Copyright 2008,2009 oharboe - ??yvind Harboe - oyvind.harboe at zylin.com
+ * Copyright 2008,2009 oharboe - ??yvind Harboe - oyvind.harboe at zylin.com
  * Copyright 2008 Andrew Lunn <andrew at lunn.ch>
  * Copyright 2008 Duane Ellis <openocd at duaneellis.com>
  * Copyright 2008 Uwe Klein <uklein at klein-messgeraete.de>
@@ -11907,15 +11907,15 @@ static int Jim_ScanCoreCommand(Jim_Interp *interp, int argc,
     }
     if (argc > 3) {
         int maxPos = FormatGetMaxPos(argv[2]);
-        int count = FormatGetCnvCount(argv[2]);
+        int arg_count = FormatGetCnvCount(argv[2]);
         if (maxPos > argc-3) {
             Jim_SetResultString(interp, "\"%n$\" argument index out of range", -1);
             return JIM_ERR;
-        } else if (count != 0 && count < argc-3) {
+        } else if (arg_count != 0 && arg_count < argc-3) {
             Jim_SetResultString(interp, "variable is not assigned by any "
                 "conversion specifiers", -1);
             return JIM_ERR;
-        } else if (count > argc-3) {
+        } else if (arg_count > argc-3) {
             Jim_SetResultString(interp, "different numbers of variable names and "
                 "field specifiers", -1);
             return JIM_ERR;
@@ -11934,26 +11934,7 @@ static int Jim_ScanCoreCommand(Jim_Interp *interp, int argc,
         }
         JimListGetElements(interp, listPtr, &outc, &outVec);
         for (i = 0; i < outc; ++i) {
-            if (Jim_Length(outVec[i]) > 0) {
-                ++count;
-                if (Jim_SetVariable(interp, argv[3 + i], outVec[i]) != JIM_OK)
-                    goto err;
-            }
-        }
-        Jim_FreeNewObj(interp, listPtr);
-        Jim_SetResult(interp, Jim_NewIntObj(interp, count));
-    } else {
-        if (listPtr == (Jim_Obj*)EOF) {
-            Jim_SetResult(interp, Jim_NewListObj(interp, 0, 0));
-            return JIM_OK;
-        }
-        Jim_SetResult(interp, listPtr);
-    }
-    return JIM_OK;
-err:
-    Jim_FreeNewObj(interp, listPtr);
-    return JIM_ERR;
-}
+            if (Jim_Len
 
 /* [error] */
 static int Jim_ErrorCoreCommand(Jim_Interp *interp, int argc,
diff --git a/src/helper/jim.c b/src/helper/jim.c
index 8b0014f..8538954 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -11907,15 +11907,15 @@ static int Jim_ScanCoreCommand(Jim_Interp *interp, int argc,
     }
     if (argc > 3) {
         int maxPos = FormatGetMaxPos(argv[2]);
-        int count = FormatGetCnvCount(argv[2]);
+        int arg_count = FormatGetCnvCount(argv[2]);
         if (maxPos > argc-3) {
             Jim_SetResultString(interp, "\"%n$\" argument index out of range", -1);
             return JIM_ERR;
-        } else if (count != 0 && count < argc-3) {
+        } else if (arg_count != 0 && arg_count < argc-3) {
             Jim_SetResultString(interp, "variable is not assigned by any "
                 "conversion specifiers", -1);
             return JIM_ERR;
-        } else if (count > argc-3) {
+        } else if (arg_count > argc-3) {
             Jim_SetResultString(interp, "different numbers of variable names and "
                 "field specifiers", -1);
             return JIM_ERR;

-----------------------------------------------------------------------

Summary of changes:
 src/helper/{jim.c => #jim.c#} |   29 +++++------------------------
 src/helper/jim.c              |    6 +++---
 2 files changed, 8 insertions(+), 27 deletions(-)
 copy src/helper/{jim.c => #jim.c#} (99%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 23:04:44 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 21:04:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-306-g83ebddd
Message-ID: <E1OOdJO-0007Vh-Mt@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  83ebddd519b2adecd5dace2d268243ad4bd34c9e (commit)
       via  9161b5fc5c4655b5320b16d52f1ab3311d69e97d (commit)
       via  395d3bff8ce59d6c5a34e0a626010343ca9909ba (commit)
      from  00017c90ae82d3237f5a4784caa695459c5897d2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 83ebddd519b2adecd5dace2d268243ad4bd34c9e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:04:22 2010 +0200

    breakpoint: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index 637f681..dc44642 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -105,7 +105,7 @@ fail:
 }
 
 /* free up a breakpoint */
-static void breakpoint_free(struct target *target, struct breakpoint *breakpoint_remove)
+static void breakpoint_free(struct target *target, struct breakpoint *breakpoint_to_remove)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 	struct breakpoint **breakpoint_p = &target->breakpoints;
@@ -113,7 +113,7 @@ static void breakpoint_free(struct target *target, struct breakpoint *breakpoint
 
 	while (breakpoint)
 	{
-		if (breakpoint == breakpoint_remove)
+		if (breakpoint == breakpoint_to_remove)
 			break;
 		breakpoint_p = &breakpoint->next;
 		breakpoint = breakpoint->next;
@@ -246,7 +246,7 @@ bye:
 	return ERROR_OK;
 }
 
-static void watchpoint_free(struct target *target, struct watchpoint *watchpoint_remove)
+static void watchpoint_free(struct target *target, struct watchpoint *watchpoint_to_remove)
 {
 	struct watchpoint *watchpoint = target->watchpoints;
 	struct watchpoint **watchpoint_p = &target->watchpoints;
@@ -254,7 +254,7 @@ static void watchpoint_free(struct target *target, struct watchpoint *watchpoint
 
 	while (watchpoint)
 	{
-		if (watchpoint == watchpoint_remove)
+		if (watchpoint == watchpoint_to_remove)
 			break;
 		watchpoint_p = &watchpoint->next;
 		watchpoint = watchpoint->next;

commit 9161b5fc5c4655b5320b16d52f1ab3311d69e97d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:02:46 2010 +0200

    zy1000: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 13685f8..b50e96a 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -508,7 +508,7 @@ static void shiftValueInnerFlip(const tap_state_t state, const tap_state_t endSt
 #endif
 
 // here we shuffle N bits out/in
-static __inline void scanBits(const uint8_t *out_value, uint8_t *in_value, int num_bits, bool pause, tap_state_t shiftState, tap_state_t end_state)
+static __inline void scanBits(const uint8_t *out_value, uint8_t *in_value, int num_bits, bool pause_now, tap_state_t shiftState, tap_state_t end_state)
 {
 	tap_state_t pause_state = shiftState;
 	for (int j = 0; j < num_bits; j += 32)
@@ -518,7 +518,7 @@ static __inline void scanBits(const uint8_t *out_value, uint8_t *in_value, int n
 		{
 			k = 32;
 			/* we have more to shift out */
-		} else if (pause)
+		} else if (pause_now)
 		{
 			/* this was the last to shift out this time */
 			pause_state = end_state;

commit 395d3bff8ce59d6c5a34e0a626010343ca9909ba
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:01:42 2010 +0200

    fileio: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/fileio.c b/src/helper/fileio.c
index 71e807f..ba62397 100644
--- a/src/helper/fileio.c
+++ b/src/helper/fileio.c
@@ -98,12 +98,12 @@ static inline int fileio_open_local(struct fileio *fileio)
 	return ERROR_OK;
 }
 
-int fileio_open(struct fileio *fileio, const char *url, enum fileio_access access,	enum fileio_type type)
+int fileio_open(struct fileio *fileio, const char *url, enum fileio_access access_type,	enum fileio_type type)
 {
 	int retval = ERROR_OK;
 
 	fileio->type = type;
-	fileio->access = access;
+	fileio->access = access_type;
 	fileio->url = strdup(url);
 
 	retval = fileio_open_local(fileio);

-----------------------------------------------------------------------

Summary of changes:
 src/helper/fileio.c      |    4 ++--
 src/jtag/zy1000/zy1000.c |    4 ++--
 src/target/breakpoints.c |    8 ++++----
 3 files changed, 8 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 23:08:13 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 21:08:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-307-g64cf05f
Message-ID: <E1OOdMl-0007hn-2d@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  64cf05f0c4dd5bd3856a57043c73933be0b2ba04 (commit)
      from  83ebddd519b2adecd5dace2d268243ad4bd34c9e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 64cf05f0c4dd5bd3856a57043c73933be0b2ba04
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:07:45 2010 +0200

    target: -Wshdaow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 435d7b6..9599fec 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3065,8 +3065,8 @@ static void writeGmon(uint32_t *samples, uint32_t sampleNum, const char *filenam
 		long long a = address-min;
 		long long b = length-1;
 		long long c = addressSpace-1;
-		int index = (a*b)/c; /* danger!!!! int32 overflows */
-		buckets[index]++;
+		int index_t = (a*b)/c; /* danger!!!! int32 overflows */
+		buckets[index_t]++;
 	}
 
 	/* append binary memory gmon.out &profile_hist_hdr ((char*)&profile_hist_hdr + sizeof(struct gmon_hist_hdr)) */
@@ -3894,14 +3894,14 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 			break;
 		case TCFG_CHAIN_POSITION:
 			if (goi->isconfigure) {
-				Jim_Obj *o;
+				Jim_Obj *o_t;
 				struct jtag_tap *tap;
 				target_free_all_working_areas(target);
-				e = Jim_GetOpt_Obj(goi, &o);
+				e = Jim_GetOpt_Obj(goi, &o_t);
 				if (e != JIM_OK) {
 					return e;
 				}
-				tap = jtag_tap_by_jim_obj(goi->interp, o);
+				tap = jtag_tap_by_jim_obj(goi->interp, o_t);
 				if (tap == NULL) {
 					return JIM_ERR;
 				}

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 23:27:36 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 21:27:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-320-g4d0d649
Message-ID: <E1OOdfW-0002dB-5v@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4d0d649ef9a066c8662e2ffcc597614fe917fefc (commit)
       via  26a77f71e1d44d12af549c618a1b7010ff83ac2b (commit)
       via  e85fe0a637d1be9c652ac1779218c1297aaaafec (commit)
       via  43a9282203d5fc0cf9086a18590c8ff89184b320 (commit)
       via  78b7a571e9f9c836189c06c095eb98a57761bc4f (commit)
       via  4bd415d01b70d3afb3aa5d4142dd0cc49a495fe0 (commit)
       via  8cfd25d29e5ce786eb001461e6d1ab9355b18597 (commit)
       via  97197c98ebd3c62061729fd5b4eb94eece262edb (commit)
       via  da5979c38d7b373f6aa345ff8f961f5401e67902 (commit)
       via  ab6e62ab76226a4596f7f728d8915acb61507b44 (commit)
       via  66f42b6f74125a98fed6d9402f6dc83a0f829100 (commit)
       via  a09d6020e08ce1b81e8bf2647cd88ecab5c25887 (commit)
       via  748863c2e23aca05a81007ca87129a30eac005c4 (commit)
      from  64cf05f0c4dd5bd3856a57043c73933be0b2ba04 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4d0d649ef9a066c8662e2ffcc597614fe917fefc
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:27:08 2010 +0200

    mips_ejtag: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index 84ad529..33507b5 100644
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -304,7 +304,7 @@ int mips_ejtag_init(struct mips_ejtag *ejtag_info)
 	return ERROR_OK;
 }
 
-int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t *data)
+int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_t *data)
 {
 	struct jtag_tap *tap;
 	tap = ejtag_info->tap;
@@ -325,7 +325,7 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write, uint32_t
 	fields[1].num_bits = 32;
 	fields[1].out_value = t;
 
-	if (write)
+	if (write_t)
 	{
 		fields[1].in_value = NULL;
 		buf_set_u32(t, 0, 32, *data);

commit 26a77f71e1d44d12af549c618a1b7010ff83ac2b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:26:16 2010 +0200

    mips32_pracc: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
index d96867a..236f389 100644
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -928,7 +928,7 @@ int mips32_pracc_read_regs(struct mips_ejtag *ejtag_info, uint32_t *regs)
  * 3. data ...
  */
 int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_area *source,
-								int write, uint32_t addr, int count, uint32_t *buf)
+								int write_t, uint32_t addr, int count, uint32_t *buf)
 {
 	uint32_t handler_code[] = {
 		/* caution when editing, table is modified below */
@@ -973,7 +973,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	if (source->size < MIPS32_FASTDATA_HANDLER_SIZE)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
-	if (write)
+	if (write_t)
 	{
 		handler_code[8] = MIPS32_LW(11,0,8);	/* load data from probe at fastdata area */
 		handler_code[9] = MIPS32_SW(11,0,9);	/* store data to RAM @ r9 */
@@ -1030,7 +1030,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 	for (i = 0; i < count; i++)
 	{
 		/* Send the data out using fastdata (clears the access pending bit) */
-		if ((retval = mips_ejtag_fastdata_scan(ejtag_info, write, buf++)) != ERROR_OK)
+		if ((retval = mips_ejtag_fastdata_scan(ejtag_info, write_t, buf++)) != ERROR_OK)
 			return retval;
 	}
 

commit e85fe0a637d1be9c652ac1779218c1297aaaafec
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:25:32 2010 +0200

    mips_m4k: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index 5604b6a..e258b71 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -951,7 +951,7 @@ int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
 	struct working_area *source;
 	int retval;
-	int write = 1;
+	int write_t = 1;
 
 	LOG_DEBUG("address: 0x%8.8" PRIx32 ", count: 0x%8.8" PRIx32 "", address, count);
 
@@ -984,7 +984,7 @@ int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		}
 	}
 
-	retval = mips32_pracc_fastdata_xfer(ejtag_info, source, write, address,
+	retval = mips32_pracc_fastdata_xfer(ejtag_info, source, write_t, address,
 			count, (uint32_t*) buffer);
 	if (retval != ERROR_OK)
 	{

commit 43a9282203d5fc0cf9086a18590c8ff89184b320
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:24:47 2010 +0200

    mips32: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/mips32.c b/src/target/mips32.c
index 0923a79..2547b01 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -388,7 +388,7 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 	}
 
 	/* refresh core register cache */
-	for (unsigned i = 0; i < MIPS32NUMCOREREGS; i++)
+	for (i = 0; i < MIPS32NUMCOREREGS; i++)
 	{
 		if (!mips32->core_cache->reg_list[i].valid)
 			mips32->read_core_reg(target, i);
@@ -404,7 +404,7 @@ int mips32_run_algorithm(struct target *target, int num_mem_params,
 		}
 	}
 
-	for (int i = 0; i < num_reg_params; i++)
+	for (i = 0; i < num_reg_params; i++)
 	{
 		struct reg *reg = register_get_by_name(mips32->core_cache, reg_params[i].reg_name, 0);
 

commit 78b7a571e9f9c836189c06c095eb98a57761bc4f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:23:16 2010 +0200

    cortex_a8: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index c2d61a3..0b12abe 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -473,7 +473,7 @@ static int cortex_a8_instr_read_data_r0(struct arm_dpm *dpm,
 	return cortex_a8_read_dcc(a8, data, &dscr);
 }
 
-static int cortex_a8_bpwp_enable(struct arm_dpm *dpm, unsigned index,
+static int cortex_a8_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
 		uint32_t addr, uint32_t control)
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
@@ -481,7 +481,7 @@ static int cortex_a8_bpwp_enable(struct arm_dpm *dpm, unsigned index,
 	uint32_t cr = a8->armv7a_common.debug_base;
 	int retval;
 
-	switch (index) {
+	switch (index_t) {
 	case 0 ... 15:		/* breakpoints */
 		vr += CPUDBG_BVR_BASE;
 		cr += CPUDBG_BCR_BASE;
@@ -489,13 +489,13 @@ static int cortex_a8_bpwp_enable(struct arm_dpm *dpm, unsigned index,
 	case 16 ... 31:		/* watchpoints */
 		vr += CPUDBG_WVR_BASE;
 		cr += CPUDBG_WCR_BASE;
-		index -= 16;
+		index_t -= 16;
 		break;
 	default:
 		return ERROR_FAIL;
 	}
-	vr += 4 * index;
-	cr += 4 * index;
+	vr += 4 * index_t;
+	cr += 4 * index_t;
 
 	LOG_DEBUG("A8: bpwp enable, vr %08x cr %08x",
 			(unsigned) vr, (unsigned) cr);
@@ -509,23 +509,23 @@ static int cortex_a8_bpwp_enable(struct arm_dpm *dpm, unsigned index,
 	return retval;
 }
 
-static int cortex_a8_bpwp_disable(struct arm_dpm *dpm, unsigned index)
+static int cortex_a8_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
 {
 	struct cortex_a8_common *a8 = dpm_to_a8(dpm);
 	uint32_t cr;
 
-	switch (index) {
+	switch (index_t) {
 	case 0 ... 15:
 		cr = a8->armv7a_common.debug_base + CPUDBG_BCR_BASE;
 		break;
 	case 16 ... 31:
 		cr = a8->armv7a_common.debug_base + CPUDBG_WCR_BASE;
-		index -= 16;
+		index_t -= 16;
 		break;
 	default:
 		return ERROR_FAIL;
 	}
-	cr += 4 * index;
+	cr += 4 * index_t;
 
 	LOG_DEBUG("A8: bpwp disable, cr %08x", (unsigned) cr);
 

commit 4bd415d01b70d3afb3aa5d4142dd0cc49a495fe0
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:22:24 2010 +0200

    arm11_dbgtap: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 18bf255..9ecd08f 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -898,7 +898,7 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 		}
 
 		/* Timeout here so we don't get stuck. */
-		int i = 0;
+		int i_n = 0;
 		while (1)
 		{
 			JTAG_DEBUG("SC7 <= c%-3d Data %08x %s",
@@ -917,11 +917,11 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 
 			long long then = 0;
 
-			if (i == 1000)
+			if (i_n == 1000)
 			{
 				then = timeval_ms();
 			}
-			if (i >= 1000)
+			if (i_n >= 1000)
 			{
 				if ((timeval_ms()-then) > 1000)
 				{
@@ -930,7 +930,7 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 				}
 			}
 
-			i++;
+			i_n++;
 		}
 
 		if (!nRW)
@@ -1086,7 +1086,7 @@ static int arm11_dpm_instr_read_data_r0(struct arm_dpm *dpm,
  * and watchpoint operations instead of running them right away.  Since we
  * pre-allocated our vector, we don't need to worry about space.
  */
-static int arm11_bpwp_enable(struct arm_dpm *dpm, unsigned index,
+static int arm11_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
 		uint32_t addr, uint32_t control)
 {
 	struct arm11_common *arm11 = dpm_to_arm11(dpm);
@@ -1104,15 +1104,15 @@ static int arm11_bpwp_enable(struct arm_dpm *dpm, unsigned index,
 	action[0].value = addr;
 	action[1].value = control;
 
-	switch (index) {
+	switch (index_t) {
 	case 0 ... 15:
-		action[0].address = ARM11_SC7_BVR0 + index;
-		action[1].address = ARM11_SC7_BCR0 + index;
+		action[0].address = ARM11_SC7_BVR0 + index_t;
+		action[1].address = ARM11_SC7_BCR0 + index_t;
 		break;
 	case 16 ... 32:
-		index -= 16;
-		action[0].address = ARM11_SC7_WVR0 + index;
-		action[1].address = ARM11_SC7_WCR0 + index;
+		index_t -= 16;
+		action[0].address = ARM11_SC7_WVR0 + index_t;
+		action[1].address = ARM11_SC7_WCR0 + index_t;
 		break;
 	default:
 		return ERROR_FAIL;
@@ -1123,7 +1123,7 @@ static int arm11_bpwp_enable(struct arm_dpm *dpm, unsigned index,
 	return ERROR_OK;
 }
 
-static int arm11_bpwp_disable(struct arm_dpm *dpm, unsigned index)
+static int arm11_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
 {
 	struct arm11_common *arm11 = dpm_to_arm11(dpm);
 	struct arm11_sc7_action *action;
@@ -1133,13 +1133,13 @@ static int arm11_bpwp_disable(struct arm_dpm *dpm, unsigned index)
 	action[0].write = true;
 	action[0].value = 0;
 
-	switch (index) {
+	switch (index_t) {
 	case 0 ... 15:
-		action[0].address = ARM11_SC7_BCR0 + index;
+		action[0].address = ARM11_SC7_BCR0 + index_t;
 		break;
 	case 16 ... 32:
-		index -= 16;
-		action[0].address = ARM11_SC7_WCR0 + index;
+		index_t -= 16;
+		action[0].address = ARM11_SC7_WCR0 + index_t;
 		break;
 	default:
 		return ERROR_FAIL;

commit 8cfd25d29e5ce786eb001461e6d1ab9355b18597
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:20:00 2010 +0200

    arm926ejs: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 918306d..d68e5ca 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -59,7 +59,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	struct scan_field fields[4];
 	uint8_t address_buf[2] = {0, 0};
 	uint8_t nr_w_buf = 0;
-	uint8_t access = 1;
+	uint8_t access_t = 1;
 
 	buf_set_u32(address_buf, 0, 14, address);
 
@@ -74,8 +74,8 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	fields[0].in_value = (uint8_t *)value;
 
 	fields[1].num_bits = 1;
-	fields[1].out_value = &access;
-	fields[1].in_value = &access;
+	fields[1].out_value = &access_t;
+	fields[1].in_value = &access_t;
 
 	fields[2].num_bits = 14;
 	fields[2].out_value = address_buf;
@@ -92,7 +92,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 	for (;;)
 	{
 		/* rescan with NOP, to wait for the access to complete */
-		access = 0;
+		access_t = 0;
 		nr_w_buf = 0;
 		jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
@@ -103,7 +103,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 			return retval;
 		}
 
-		if (buf_get_u32(&access, 0, 1) == 1)
+		if (buf_get_u32(&access_t, 0, 1) == 1)
 		{
 			break;
 		}
@@ -146,7 +146,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	uint8_t value_buf[4];
 	uint8_t address_buf[2] = {0, 0};
 	uint8_t nr_w_buf = 1;
-	uint8_t access = 1;
+	uint8_t access_t = 1;
 
 	buf_set_u32(address_buf, 0, 14, address);
 	buf_set_u32(value_buf, 0, 32, value);
@@ -162,8 +162,8 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	fields[0].in_value = NULL;
 
 	fields[1].num_bits = 1;
-	fields[1].out_value = &access;
-	fields[1].in_value = &access;
+	fields[1].out_value = &access_t;
+	fields[1].in_value = &access_t;
 
 	fields[2].num_bits = 14;
 	fields[2].out_value = address_buf;
@@ -180,7 +180,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 	for (;;)
 	{
 		/* rescan with NOP, to wait for the access to complete */
-		access = 0;
+		access_t = 0;
 		nr_w_buf = 0;
 		jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -188,7 +188,7 @@ static int arm926ejs_cp15_write(struct target *target, uint32_t op1, uint32_t op
 			return retval;
 		}
 
-		if (buf_get_u32(&access, 0, 1) == 1)
+		if (buf_get_u32(&access_t, 0, 1) == 1)
 		{
 			break;
 		}

commit 97197c98ebd3c62061729fd5b4eb94eece262edb
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:18:44 2010 +0200

    arm920t: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index b99b4d5..fe9bba7 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -1,3 +1,4 @@
+
 /***************************************************************************
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
@@ -841,7 +842,7 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 	int i;
 	FILE *output;
 	struct arm920t_cache_line d_cache[8][64], i_cache[8][64];
-	int segment, index;
+	int segment, index_t;
 	struct reg *r;
 
 	retval = arm920t_verify_pointer(CMD_CTX, arm920t);
@@ -910,12 +911,12 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 		arm920t_write_cp15_physical(target,
 				CP15PHYS_TESTSTATE, cp15c15);
 
-		for (index = 0; index < 64; index++)
+		for (index_t = 0; index_t < 64; index_t++)
 		{
 			/* Ra:
 			 * r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0)
 			 */
-			regs[0] = 0x0 | (segment << 5) | (index << 26);
+			regs[0] = 0x0 | (segment << 5) | (index_t << 26);
 			arm9tdmi_write_core_regs(target, 0x1, regs);
 
 			/* set interpret mode */
@@ -949,18 +950,18 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				return retval;
 			}
 
-			d_cache[segment][index].cam = regs[9];
+			d_cache[segment][index_t].cam = regs[9];
 
 			/* mask LFSR[6] */
 			regs[9] &= 0xfffffffe;
 			fprintf(output, "\nsegment: %i, index: %i, CAM: 0x%8.8"
 				PRIx32 ", content (%s):\n",
-				segment, index, regs[9],
+				segment, index_t, regs[9],
 				(regs[9] & 0x10) ? "valid" : "invalid");
 
 			for (i = 1; i < 9; i++)
 			{
-				 d_cache[segment][index].data[i] = regs[i];
+				 d_cache[segment][index_t].data[i] = regs[i];
 				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n",
 						i-1, regs[i]);
 			}
@@ -1018,12 +1019,12 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 		arm920t_write_cp15_physical(target,
 				CP15PHYS_TESTSTATE, cp15c15);
 
-		for (index = 0; index < 64; index++)
+		for (index_t = 0; index_t < 64; index_t++)
 		{
 			/* Ra:
 			 * r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0)
 			 */
-			regs[0] = 0x0 | (segment << 5) | (index << 26);
+			regs[0] = 0x0 | (segment << 5) | (index_t << 26);
 			arm9tdmi_write_core_regs(target, 0x1, regs);
 
 			/* set interpret mode */
@@ -1057,18 +1058,18 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				return retval;
 			}
 
-			i_cache[segment][index].cam = regs[9];
+			i_cache[segment][index_t].cam = regs[9];
 
 			/* mask LFSR[6] */
 			regs[9] &= 0xfffffffe;
 			fprintf(output, "\nsegment: %i, index: %i, "
 				"CAM: 0x%8.8" PRIx32 ", content (%s):\n",
-				segment, index, regs[9],
+				segment, index_t, regs[9],
 				(regs[9] & 0x10) ? "valid" : "invalid");
 
 			for (i = 1; i < 9; i++)
 			{
-				 i_cache[segment][index].data[i] = regs[i];
+				 i_cache[segment][index_t].data[i] = regs[i];
 				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n",
 						i-1, regs[i]);
 			}

commit da5979c38d7b373f6aa345ff8f961f5401e67902
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:17:00 2010 +0200

    arm720t: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index 8db0b5d..0ea6cb2 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -41,7 +41,7 @@
 #endif
 
 static int arm720t_scan_cp15(struct target *target,
-		uint32_t out, uint32_t *in, int instruction, int clock)
+		uint32_t out, uint32_t *in, int instruction, int clock_arg)
 {
 	int retval;
 	struct arm720t_common *arm720t = target_to_arm720(target);
@@ -81,7 +81,7 @@ static int arm720t_scan_cp15(struct target *target,
 		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
 	}
 
-	if (clock)
+	if (clock_arg)
 		jtag_add_runtest(0, TAP_DRPAUSE);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
@@ -93,9 +93,9 @@ static int arm720t_scan_cp15(struct target *target,
 	if (in)
 		LOG_DEBUG("out: %8.8x, in: %8.8x, instruction: %i, clock: %i", out, *in, instruction, clock);
 	else
-		LOG_DEBUG("out: %8.8x, instruction: %i, clock: %i", out, instruction, clock);
+		LOG_DEBUG("out: %8.8x, instruction: %i, clock: %i", out, instruction, clock_arg);
 #else
-		LOG_DEBUG("out: %8.8" PRIx32 ", instruction: %i, clock: %i", out, instruction, clock);
+		LOG_DEBUG("out: %8.8" PRIx32 ", instruction: %i, clock: %i", out, instruction, clock_arg);
 #endif
 
 	return ERROR_OK;

commit ab6e62ab76226a4596f7f728d8915acb61507b44
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:15:50 2010 +0200

    adi_v5_jtag: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 04c6ae7..b368708 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -366,15 +366,15 @@ static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
 /** Select the AP register bank matching bits 7:4 of reg. */
 static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
-	uint32_t select = reg & 0x000000F0;
+	uint32_t select_ap_bank = reg & 0x000000F0;
 
-	if (select == dap->ap_bank_value)
+	if (select_ap_bank == dap->ap_bank_value)
 		return ERROR_OK;
-	dap->ap_bank_value = select;
+	dap->ap_bank_value = select_ap_bank;
 
-	select |= dap->apsel;
+	select_ap_bank |= dap->apsel;
 
-	return jtag_dp_q_write(dap, DP_SELECT, select);
+	return jtag_dp_q_write(dap, DP_SELECT, select_ap_bank);
 }
 
 static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,

commit 66f42b6f74125a98fed6d9402f6dc83a0f829100
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:14:41 2010 +0200

    arm_adi: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 8f43f78..aae60fc 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -102,11 +102,11 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  */
 void dap_ap_select(struct adiv5_dap *dap,uint8_t apsel)
 {
-	uint32_t select = (apsel << 24) & 0xFF000000;
+	uint32_t select_apsel = (apsel << 24) & 0xFF000000;
 
-	if (select != dap->apsel)
+	if (select_apsel != dap->apsel)
 	{
-		dap->apsel = select;
+		dap->apsel = select_apsel;
 		/* Switching AP invalidates cached values.
 		 * Values MUST BE UPDATED BEFORE AP ACCESS.
 		 */

commit a09d6020e08ce1b81e8bf2647cd88ecab5c25887
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:14:20 2010 +0200

    arm_simulator: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
index 730f588..0f6fe3f 100644
--- a/src/target/arm_simulator.c
+++ b/src/target/arm_simulator.c
@@ -364,42 +364,42 @@ static int arm_simulate_step_core(struct target *target,
 	/* branch instructions */
 	if ((instruction.type >= ARM_B) && (instruction.type <= ARM_BLX))
 	{
-		uint32_t target;
+		uint32_t target_address;
 
 		if (instruction.info.b_bl_bx_blx.reg_operand == -1)
 		{
-			target = instruction.info.b_bl_bx_blx.target_address;
+			target_address = instruction.info.b_bl_bx_blx.target_address;
 		}
 		else
 		{
-			target = sim->get_reg_mode(sim, instruction.info.b_bl_bx_blx.reg_operand);
+			target_address = sim->get_reg_mode(sim, instruction.info.b_bl_bx_blx.reg_operand);
 			if (instruction.info.b_bl_bx_blx.reg_operand == 15)
 			{
-				target += 2 * instruction_size;
+				target_address += 2 * instruction_size;
 			}
 		}
 
 		if (dry_run_pc)
 		{
-			*dry_run_pc = target & ~1;
+			*dry_run_pc = target_address & ~1;
 			return ERROR_OK;
 		}
 		else
 		{
 			if (instruction.type == ARM_B)
 			{
-				sim->set_reg(sim, 15, target);
+				sim->set_reg(sim, 15, target_address);
 			}
 			else if (instruction.type == ARM_BL)
 			{
 				uint32_t old_pc = sim->get_reg(sim, 15);
 				int T = (sim->get_state(sim) == ARM_STATE_THUMB);
 				sim->set_reg_mode(sim, 14, old_pc + 4 + T);
-				sim->set_reg(sim, 15, target);
+				sim->set_reg(sim, 15, target_address);
 			}
 			else if (instruction.type == ARM_BX)
 			{
-				if (target & 0x1)
+				if (target_address & 0x1)
 				{
 					sim->set_state(sim, ARM_STATE_THUMB);
 				}
@@ -407,7 +407,7 @@ static int arm_simulate_step_core(struct target *target,
 				{
 					sim->set_state(sim, ARM_STATE_ARM);
 				}
-				sim->set_reg(sim, 15, target & 0xfffffffe);
+				sim->set_reg(sim, 15, target_address & 0xfffffffe);
 			}
 			else if (instruction.type == ARM_BLX)
 			{
@@ -415,7 +415,7 @@ static int arm_simulate_step_core(struct target *target,
 				int T = (sim->get_state(sim) == ARM_STATE_THUMB);
 				sim->set_reg_mode(sim, 14, old_pc + 4 + T);
 
-				if (target & 0x1)
+				if (target_address & 0x1)
 				{
 					sim->set_state(sim, ARM_STATE_THUMB);
 				}
@@ -423,7 +423,7 @@ static int arm_simulate_step_core(struct target *target,
 				{
 					sim->set_state(sim, ARM_STATE_ARM);
 				}
-				sim->set_reg(sim, 15, target & 0xfffffffe);
+				sim->set_reg(sim, 15, target_address & 0xfffffffe);
 			}
 
 			return ERROR_OK;

commit 748863c2e23aca05a81007ca87129a30eac005c4
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:09:12 2010 +0200

    arm_dpm: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 213afbd..4fbe5e3 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -773,11 +773,11 @@ static int dpm_remove_breakpoint(struct target *target, struct breakpoint *bp)
 	return retval;
 }
 
-static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
+static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
 		struct watchpoint *wp)
 {
 	int retval;
-	struct dpm_wp *dwp = dpm->dwp + index;
+	struct dpm_wp *dwp = dpm->dwp + index_t;
 	uint32_t control;
 
 	/* this hardware doesn't support data value matching or masking */
@@ -804,7 +804,7 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
 	}
 	dwp->bpwp.control = control;
 
-	dpm->dwp[index].wp = wp;
+	dpm->dwp[index_t].wp = wp;
 
 	return retval;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c   |   10 +++++-----
 src/target/arm11_dbgtap.c  |   32 ++++++++++++++++----------------
 src/target/arm720t.c       |    8 ++++----
 src/target/arm920t.c       |   23 ++++++++++++-----------
 src/target/arm926ejs.c     |   20 ++++++++++----------
 src/target/arm_adi_v5.c    |    6 +++---
 src/target/arm_dpm.c       |    6 +++---
 src/target/arm_simulator.c |   22 +++++++++++-----------
 src/target/cortex_a8.c     |   18 +++++++++---------
 src/target/mips32.c        |    4 ++--
 src/target/mips32_pracc.c  |    6 +++---
 src/target/mips_ejtag.c    |    4 ++--
 src/target/mips_m4k.c      |    4 ++--
 13 files changed, 82 insertions(+), 81 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 23:29:31 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 21:29:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-321-g9045452
Message-ID: <E1OOdhM-0002nV-Iy@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  90454525b6119b95226e02754d3a5c6e125c5922 (commit)
      from  4d0d649ef9a066c8662e2ffcc597614fe917fefc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 90454525b6119b95226e02754d3a5c6e125c5922
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:29:08 2010 +0200

    flash: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 28a504e..3dc6cff 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -467,7 +467,7 @@ COMMAND_HANDLER(handle_flash_fill_command)
 	uint32_t cur_size = 0;
 	uint32_t chunk_count;
 	struct target *target = get_current_target(CMD_CTX);
-	uint32_t i;
+	unsigned i;
 	uint32_t wordsize;
 	int retval = ERROR_OK;
 
@@ -563,7 +563,6 @@ COMMAND_HANDLER(handle_flash_fill_command)
 			goto done;
 		}
 
-		unsigned i;
 		for (i = 0; i < cur_size; i++)
 		{
 			if (readback[i]!=chunk[i])

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/tcl.c |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 15 23:33:06 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 21:33:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-323-g953d96f
Message-ID: <E1OOdku-0005kI-Jt@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  953d96f1e2c6619da76f4925fdb62b7f54f0e0fd (commit)
       via  88aa5e31d1496c078c32c95708c62e464959496f (commit)
      from  90454525b6119b95226e02754d3a5c6e125c5922 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 953d96f1e2c6619da76f4925fdb62b7f54f0e0fd
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:32:47 2010 +0200

    ecos flash: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index f9c3285..945852d 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -173,7 +173,6 @@ static int loadDriver(struct ecosflash_flash_bank *info)
 	for (i = 0; i < image.num_sections; i++)
 	{
 		void *buffer = malloc(image.sections[i].size);
-		int retval;
 		if ((retval = image_read_section(&image, i, 0x0, image.sections[i].size, buffer, &buf_cnt)) != ERROR_OK)
 		{
 			free(buffer);
@@ -305,7 +304,6 @@ static int eCosBoard_flash(struct ecosflash_flash_bank *info, void *data, uint32
 			t = chunk;
 		}
 
-		int retval;
 		retval = target_write_buffer(target, buffer, t, ((uint8_t *)data) + i);
 		if (retval != ERROR_OK)
 			return retval;

commit 88aa5e31d1496c078c32c95708c62e464959496f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:31:36 2010 +0200

    at91sam7: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index 606cc32..3a809e2 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -298,7 +298,7 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 	uint32_t ext_freq;
 	uint32_t bank_size;
 	uint32_t base_address = 0;
-	char *target_name = "Unknown";
+	char *target_name_t = "Unknown";
 
 	at91sam7_info = t_bank->driver_priv;
 
@@ -386,7 +386,7 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 			if (arch == 0x70)
 			{
 				num_nvmbits = 2;
-				target_name = "AT91SAM7S161/16";
+				target_name_t = "AT91SAM7S161/16";
 			}
 			break;
 
@@ -399,12 +399,12 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 			if (arch == 0x70)
 			{
 				num_nvmbits = 2;
-				target_name = "AT91SAM7S321/32";
+				target_name_t = "AT91SAM7S321/32";
 			}
 			if (arch == 0x72)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7SE32";
+				target_name_t = "AT91SAM7SE32";
 			}
 			break;
 
@@ -417,7 +417,7 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 			if (arch == 0x70)
 			{
 				num_nvmbits = 2;
-				target_name = "AT91SAM7S64";
+				target_name_t = "AT91SAM7S64";
 			}
 			break;
 
@@ -430,22 +430,22 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 			if (arch == 0x70)
 			{
 				num_nvmbits = 2;
-				target_name = "AT91SAM7S128";
+				target_name_t = "AT91SAM7S128";
 			}
 			if (arch == 0x71)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7XC128";
+				target_name_t = "AT91SAM7XC128";
 			}
 			if (arch == 0x72)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7SE128";
+				target_name_t = "AT91SAM7SE128";
 			}
 			if (arch == 0x75)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7X128";
+				target_name_t = "AT91SAM7X128";
 			}
 			break;
 
@@ -458,27 +458,27 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 			if (arch == 0x60)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7A3";
+				target_name_t = "AT91SAM7A3";
 			}
 			if (arch == 0x70)
 			{
 				num_nvmbits = 2;
-				target_name = "AT91SAM7S256";
+				target_name_t = "AT91SAM7S256";
 			}
 			if (arch == 0x71)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7XC256";
+				target_name_t = "AT91SAM7XC256";
 			}
 			if (arch == 0x72)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7SE256";
+				target_name_t = "AT91SAM7SE256";
 			}
 			if (arch == 0x75)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7X256";
+				target_name_t = "AT91SAM7X256";
 			}
 			break;
 
@@ -491,22 +491,22 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 			if (arch == 0x70)
 			{
 				num_nvmbits = 2;
-				target_name = "AT91SAM7S512";
+				target_name_t = "AT91SAM7S512";
 			}
 			if (arch == 0x71)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7XC512";
+				target_name_t = "AT91SAM7XC512";
 			}
 			if (arch == 0x72)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7SE512";
+				target_name_t = "AT91SAM7SE512";
 			}
 			if (arch == 0x75)
 			{
 				num_nvmbits = 3;
-				target_name = "AT91SAM7X512";
+				target_name_t = "AT91SAM7X512";
 			}
 			break;
 
@@ -517,7 +517,7 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 			break;
 	}
 
-	if (strcmp(target_name, "Unknown") == 0)
+	if (strcmp(target_name_t, "Unknown") == 0)
 	{
 		LOG_ERROR("Target autodetection failed! Please specify target parameters in configuration file");
 		return ERROR_FLASH_OPERATION_FAILED;
@@ -573,7 +573,7 @@ static int at91sam7_read_part_info(struct flash_bank *bank)
 		at91sam7_info->cidr_eproc = (cidr >> 5)&0x0007;
 		at91sam7_info->cidr_version = cidr&0x001F;
 
-		at91sam7_info->target_name  = target_name;
+		at91sam7_info->target_name  = target_name_t;
 		at91sam7_info->flashmode = 0;
 		at91sam7_info->ext_freq = ext_freq;
 		at91sam7_info->num_nvmbits = num_nvmbits;
@@ -731,7 +731,7 @@ FLASH_BANK_COMMAND_HANDLER(at91sam7_flash_bank_command)
 	uint16_t page_size;
 	uint16_t num_nvmbits;
 
-	char *target_name;
+	char *target_name_t;
 
 	int bnk, sec;
 
@@ -775,8 +775,8 @@ FLASH_BANK_COMMAND_HANDLER(at91sam7_flash_bank_command)
 		return ERROR_OK;
 	}
 
-	target_name = calloc(strlen(CMD_ARGV[7]) + 1, sizeof(char));
-	strcpy(target_name, CMD_ARGV[7]);
+	target_name_t = calloc(strlen(CMD_ARGV[7]) + 1, sizeof(char));
+	strcpy(target_name_t, CMD_ARGV[7]);
 
 	/* calculate bank size  */
 	bank_size = num_sectors * pages_per_sector * page_size;
@@ -816,7 +816,7 @@ FLASH_BANK_COMMAND_HANDLER(at91sam7_flash_bank_command)
 
 		at91sam7_info = t_bank->driver_priv;
 
-		at91sam7_info->target_name  = target_name;
+		at91sam7_info->target_name  = target_name_t;
 		at91sam7_info->flashmode = 0;
 		at91sam7_info->ext_freq  = ext_freq;
 		at91sam7_info->num_nvmbits = num_nvmbits;
@@ -1034,7 +1034,7 @@ static int at91sam7_probe(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
-static int at91sam7_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_at91sam7_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	int printed;
 	struct at91sam7_flash_bank *at91sam7_info = bank->driver_priv;
@@ -1212,5 +1212,5 @@ struct flash_driver at91sam7_flash = {
 	.auto_probe = at91sam7_probe,
 	.erase_check = at91sam7_erase_check,
 	.protect_check = at91sam7_protect_check,
-	.info = at91sam7_info,
+	.info = get_at91sam7_info,
 };

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/at91sam7.c |   52 +++++++++++++++++++++++-----------------------
 src/flash/nor/ecos.c     |    2 -
 2 files changed, 26 insertions(+), 28 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 16 00:03:18 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 22:03:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-328-g8022940
Message-ID: <E1OOeE4-0007wL-NL@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8022940c5c3a12ecdbc8f8866351ee0ef5de1d35 (commit)
       via  72eb87673cefbd046416fc27579507b1192fae94 (commit)
       via  e53836718664e507a9cb431444a0fc9021ebae04 (commit)
       via  0a837fc36bee177094cc064d8146c2a96e4a8f1d (commit)
       via  0365225c4860d5926c3aacbc2a91a98f873a364e (commit)
      from  953d96f1e2c6619da76f4925fdb62b7f54f0e0fd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8022940c5c3a12ecdbc8f8866351ee0ef5de1d35
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 00:02:58 2010 +0200

    str7x: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 46510ed..4c450af 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -625,7 +625,7 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 	if (bytes_remaining)
 	{
 		uint8_t last_dword[8] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-		int i = 0;
+		i = 0;
 
 		while (bytes_remaining > 0)
 		{
@@ -680,7 +680,7 @@ COMMAND_HANDLER(str7x_handle_part_id_command)
 }
 #endif
 
-static int str7x_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_str7x_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	snprintf(buf, buf_size, "str7x flash driver info");
 	/* STR7x flash doesn't support sector protection interrogation.
@@ -795,5 +795,5 @@ struct flash_driver str7x_flash = {
 	.auto_probe = str7x_probe,
 	.erase_check = default_flash_blank_check,
 	.protect_check = str7x_protect_check,
-	.info = str7x_info,
+	.info = get_str7x_info,
 };

commit 72eb87673cefbd046416fc27579507b1192fae94
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 00:00:57 2010 +0200

    stm32x: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 47ed640..5ce5d45 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -814,7 +814,7 @@ COMMAND_HANDLER(stm32x_handle_part_id_command)
 }
 #endif
 
-static int stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_stm32x_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	struct target *target = bank->target;
 	uint32_t device_id;
@@ -1305,5 +1305,5 @@ struct flash_driver stm32x_flash = {
 	.auto_probe = stm32x_auto_probe,
 	.erase_check = default_flash_mem_blank_check,
 	.protect_check = stm32x_protect_check,
-	.info = stm32x_info,
+	.info = get_stm32x_info,
 };

commit e53836718664e507a9cb431444a0fc9021ebae04
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:59:21 2010 +0200

    stellaris: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index f7e2e8d..ff1c2e4 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -255,7 +255,7 @@ FLASH_BANK_COMMAND_HANDLER(stellaris_flash_bank_command)
 	return ERROR_OK;
 }
 
-static int stellaris_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_stellaris_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	int printed, device_class;
 	struct stellaris_flash_bank *stellaris_info = bank->driver_priv;
@@ -1272,5 +1272,5 @@ struct flash_driver stellaris_flash = {
 	.auto_probe = stellaris_probe,
 	.erase_check = default_flash_mem_blank_check,
 	.protect_check = stellaris_protect_check,
-	.info = stellaris_info,
+	.info = get_stellaris_info,
 };

commit 0a837fc36bee177094cc064d8146c2a96e4a8f1d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:58:19 2010 +0200

    lpc2900: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 3ae7bb4..e17823e 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -306,39 +306,39 @@ static uint32_t lpc2900_read_security_status( struct flash_bank *bank )
 	 * a protected sector!
 	 */
 	int sector;
-	int index;
+	int index_t;
 	for( sector = 0; sector < bank->num_sectors; sector++ )
 	{
 		/* Convert logical sector number to physical sector number */
 		if( sector <= 4 )
 		{
-			index = sector + 11;
+			index_t = sector + 11;
 		}
 		else if( sector <= 7 )
 		{
-			index = sector + 27;
+			index_t = sector + 27;
 		}
 		else
 		{
-			index = sector - 8;
+			index_t = sector - 8;
 		}
 
 		bank->sectors[sector].is_protected = -1;
 
 		if (
-		    (iss_secured_field[index][0] == 0x00000000) &&
-		    (iss_secured_field[index][1] == 0x00000000) &&
-		    (iss_secured_field[index][2] == 0x00000000) &&
-		    (iss_secured_field[index][3] == 0x00000000) )
+		    (iss_secured_field[index_t][0] == 0x00000000) &&
+		    (iss_secured_field[index_t][1] == 0x00000000) &&
+		    (iss_secured_field[index_t][2] == 0x00000000) &&
+		    (iss_secured_field[index_t][3] == 0x00000000) )
 		{
 			bank->sectors[sector].is_protected = 1;
 		}
 
 		if (
-		    (iss_secured_field[index][0] == 0xFFFFFFFF) &&
-		    (iss_secured_field[index][1] == 0xFFFFFFFF) &&
-		    (iss_secured_field[index][2] == 0xFFFFFFFF) &&
-		    (iss_secured_field[index][3] == 0xFFFFFFFF) )
+		    (iss_secured_field[index_t][0] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index_t][1] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index_t][2] == 0xFFFFFFFF) &&
+		    (iss_secured_field[index_t][3] == 0xFFFFFFFF) )
 		{
 			bank->sectors[sector].is_protected = 0;
 		}
@@ -507,7 +507,7 @@ static int lpc2900_write_index_page( struct flash_bank *bank,
  * @param clock System clock in Hz
  * @param time Program/erase time in ??s
  */
-static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time )
+static uint32_t lpc2900_calc_tr( uint32_t clock_var, uint32_t time_var )
 {
 	/*           ((time[??s]/1e6) * f[Hz]) + 511
 	 * FPTR.TR = -------------------------------
@@ -516,7 +516,7 @@ static uint32_t lpc2900_calc_tr( uint32_t clock, uint32_t time )
 	 * The result is the
 	 */
 
-	uint32_t tr_val = (uint32_t)((((time / 1e6) * clock) + 511.0) / 512.0);
+	uint32_t tr_val = (uint32_t)((((time_var / 1e6) * clock_var) + 511.0) / 512.0);
 
 	return tr_val;
 }
@@ -1365,7 +1365,7 @@ static int lpc2900_write(struct flash_bank *bank, uint8_t *buffer,
 				this_buffer = buffer;
 
 				/* Make sure we stop at the next secured sector */
-				int sector = start_sector + 1;
+				sector = start_sector + 1;
 				while( sector < bank->num_sectors )
 				{
 					/* Secured? */

commit 0365225c4860d5926c3aacbc2a91a98f873a364e
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 15 23:53:36 2010 +0200

    lpc2000: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 154248c..866be50 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -594,7 +594,6 @@ static int lpc2000_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offs
 	if ((offset == 0) && (count >= 0x20) && lpc2000_info->calc_checksum)
 	{
 		uint32_t checksum = 0;
-		int i;
 		for (i = 0; i < 8; i++)
 		{
 			LOG_DEBUG("Vector 0x%2.2x: 0x%8.8" PRIx32, i * 4, buf_get_u32(buffer + (i * 4), 0, 32));
@@ -740,7 +739,7 @@ static int lpc2000_protect_check(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
-static int lpc2000_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_lpc2000_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	struct lpc2000_flash_bank *lpc2000_info = bank->driver_priv;
 
@@ -819,5 +818,5 @@ struct flash_driver lpc2000_flash = {
 	.auto_probe = lpc2000_probe,
 	.erase_check = lpc2000_erase_check,
 	.protect_check = lpc2000_protect_check,
-	.info = lpc2000_info,
+	.info = get_lpc2000_info,
 };

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/lpc2000.c   |    5 ++---
 src/flash/nor/lpc2900.c   |   30 +++++++++++++++---------------
 src/flash/nor/stellaris.c |    4 ++--
 src/flash/nor/stm32x.c    |    4 ++--
 src/flash/nor/str7x.c     |    6 +++---
 5 files changed, 24 insertions(+), 25 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 16 00:04:47 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 22:04:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-329-gf1ce4fe
Message-ID: <E1OOeFV-0005IS-79@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f1ce4fe288dc3a2682b8335177a2800980316ce3 (commit)
      from  8022940c5c3a12ecdbc8f8866351ee0ef5de1d35 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f1ce4fe288dc3a2682b8335177a2800980316ce3
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 00:04:23 2010 +0200

    oops... backup file snuck in, remove it.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/#jim.c# b/src/helper/#jim.c#
deleted file mode 100644
index c8583de..0000000
--- a/src/helper/#jim.c#
+++ /dev/null
@@ -1,12823 +0,0 @@
-/* Jim - A small embeddable Tcl interpreter
- *
- * Copyright 2005 Salvatore Sanfilippo <antirez at invece.org>
- * Copyright 2005 Clemens Hintze <c.hintze at gmx.net>
- * Copyright 2005 patthoyts - Pat Thoyts <patthoyts at users.sf.net>
- * Copyright 2008,2009 oharboe - ??yvind Harboe - oyvind.harboe at zylin.com
- * Copyright 2008 Andrew Lunn <andrew at lunn.ch>
- * Copyright 2008 Duane Ellis <openocd at duaneellis.com>
- * Copyright 2008 Uwe Klein <uklein at klein-messgeraete.de>
- * Copyright 2008 Steve Bennett <steveb at workware.net.au>
- * Copyright 2009 Nico Coesel <ncoesel at dealogic.nl>
- * Copyright 2009 Zachary T Welch zw at superlucidity.net
- * Copyright 2009 David Brownell
- *
- * The FreeBSD license
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above
- *    copyright notice, this list of conditions and the following
- *    disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE JIM TCL PROJECT ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * JIM TCL PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * The views and conclusions contained in the software and documentation
- * are those of the authors and should not be interpreted as representing
- * official policies, either expressed or implied, of the Jim Tcl Project.
- **/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#define __JIM_CORE__
-#define JIM_OPTIMIZATION /* comment to avoid optimizations and reduce size */
-
-#ifdef __ECOS
-#include <pkgconf/jimtcl.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-typedef CYG_ADDRWORD intptr_t;
-
-#include <string.h>
-#include <stdarg.h>
-#include <ctype.h>
-#include <limits.h>
-#include <assert.h>
-#include <errno.h>
-#include <time.h>
-#endif
-#ifndef JIM_ANSIC
-#define JIM_DYNLIB      /* Dynamic library support for UNIX and WIN32 */
-#endif /* JIM_ANSIC */
-
-#include <stdarg.h>
-#include <limits.h>
-
-/* Include the platform dependent libraries for
- * dynamic loading of libraries. */
-#ifdef JIM_DYNLIB
-#if defined(_WIN32) || defined(WIN32)
-#ifndef WIN32
-#define WIN32 1
-#endif
-#ifndef STRICT
-#define STRICT
-#endif
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#if _MSC_VER >= 1000
-#pragma warning(disable:4146)
-#endif /* _MSC_VER */
-#else
-#include <dlfcn.h>
-#endif /* WIN32 */
-#endif /* JIM_DYNLIB */
-
-#ifdef __ECOS
-#include <cyg/jimtcl/jim.h>
-#else
-#include "jim.h"
-#endif
-
-#ifdef HAVE_BACKTRACE
-#include <execinfo.h>
-#endif
-
-/* -----------------------------------------------------------------------------
- * Global variables
- * ---------------------------------------------------------------------------*/
-
-/* A shared empty string for the objects string representation.
- * Jim_InvalidateStringRep knows about it and don't try to free. */
-static char *JimEmptyStringRep = (char*) "";
-
-/* -----------------------------------------------------------------------------
- * Required prototypes of not exported functions
- * ---------------------------------------------------------------------------*/
-static void JimChangeCallFrameId(Jim_Interp *interp, Jim_CallFrame *cf);
-static void JimFreeCallFrame(Jim_Interp *interp, Jim_CallFrame *cf, int flags);
-static void JimRegisterCoreApi(Jim_Interp *interp);
-
-static Jim_HashTableType *getJimVariablesHashTableType(void);
-
-/* -----------------------------------------------------------------------------
- * Utility functions
- * ---------------------------------------------------------------------------*/
-
-static char *
-jim_vasprintf(const char *fmt, va_list ap)
-{
-#ifndef HAVE_VASPRINTF
-	/* yucky way */
-static char buf[2048];
-	vsnprintf(buf, sizeof(buf), fmt, ap);
-	/* garentee termination */
-	buf[sizeof(buf)-1] = 0;
-#else
-	char *buf;
-	int result;
-	result = vasprintf(&buf, fmt, ap);
-	if (result < 0) exit(-1);
-#endif
-	return buf;
-}
-
-static void
-jim_vasprintf_done(void *buf)
-{
-#ifndef HAVE_VASPRINTF
-	(void)(buf);
-#else
-	free(buf);
-#endif
-}
-
-
-/*
- * Convert a string to a jim_wide INTEGER.
- * This function originates from BSD.
- *
- * Ignores `locale' stuff.  Assumes that the upper and lower case
- * alphabets and digits are each contiguous.
- */
-#ifdef HAVE_LONG_LONG_INT
-#define JimIsAscii(c) (((c) & ~0x7f) == 0)
-static jim_wide JimStrtoll(const char *nptr, char **endptr, register int base)
-{
-    register const char *s;
-    register unsigned jim_wide acc;
-    register unsigned char c;
-    register unsigned jim_wide qbase, cutoff;
-    register int neg, any, cutlim;
-
-    /*
-     * Skip white space and pick up leading +/- sign if any.
-     * If base is 0, allow 0x for hex and 0 for octal, else
-     * assume decimal; if base is already 16, allow 0x.
-     */
-    s = nptr;
-    do {
-        c = *s++;
-    } while (isspace(c));
-    if (c == '-') {
-        neg = 1;
-        c = *s++;
-    } else {
-        neg = 0;
-        if (c == '+')
-            c = *s++;
-    }
-    if ((base == 0 || base == 16) &&
-        c == '0' && (*s == 'x' || *s == 'X')) {
-        c = s[1];
-        s += 2;
-        base = 16;
-    }
-    if (base == 0)
-        base = c == '0' ? 8 : 10;
-
-    /*
-     * Compute the cutoff value between legal numbers and illegal
-     * numbers.  That is the largest legal value, divided by the
-     * base.  An input number that is greater than this value, if
-     * followed by a legal input character, is too big.  One that
-     * is equal to this value may be valid or not; the limit
-     * between valid and invalid numbers is then based on the last
-     * digit.  For instance, if the range for quads is
-     * [-9223372036854775808..9223372036854775807] and the input base
-     * is 10, cutoff will be set to 922337203685477580 and cutlim to
-     * either 7 (neg == 0) or 8 (neg == 1), meaning that if we have
-     * accumulated a value > 922337203685477580, or equal but the
-     * next digit is > 7 (or 8), the number is too big, and we will
-     * return a range error.
-     *
-     * Set any if any `digits' consumed; make it negative to indicate
-     * overflow.
-     */
-    qbase = (unsigned)base;
-    cutoff = neg ? (unsigned jim_wide)-(LLONG_MIN + LLONG_MAX) + LLONG_MAX
-        : LLONG_MAX;
-    cutlim = (int)(cutoff % qbase);
-    cutoff /= qbase;
-    for (acc = 0, any = 0;; c = *s++) {
-        if (!JimIsAscii(c))
-            break;
-        if (isdigit(c))
-            c -= '0';
-        else if (isalpha(c))
-            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
-        else
-            break;
-        if (c >= base)
-            break;
-        if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
-            any = -1;
-        else {
-            any = 1;
-            acc *= qbase;
-            acc += c;
-        }
-    }
-    if (any < 0) {
-        acc = neg ? LLONG_MIN : LLONG_MAX;
-        errno = ERANGE;
-    } else if (neg)
-        acc = -acc;
-    if (endptr != 0)
-        *endptr = (char *)(any ? s - 1 : nptr);
-    return (acc);
-}
-#endif
-
-/* Glob-style pattern matching. */
-static int JimStringMatch(const char *pattern, int patternLen,
-        const char *string, int stringLen, int nocase)
-{
-    while (patternLen) {
-        switch (pattern[0]) {
-        case '*':
-            while (pattern[1] == '*') {
-                pattern++;
-                patternLen--;
-            }
-            if (patternLen == 1)
-                return 1; /* match */
-            while (stringLen) {
-                if (JimStringMatch(pattern + 1, patternLen-1,
-                            string, stringLen, nocase))
-                    return 1; /* match */
-                string++;
-                stringLen--;
-            }
-            return 0; /* no match */
-            break;
-        case '?':
-            if (stringLen == 0)
-                return 0; /* no match */
-            string++;
-            stringLen--;
-            break;
-        case '[':
-        {
-            int not, match;
-
-            pattern++;
-            patternLen--;
-            not = pattern[0] == '^';
-            if (not) {
-                pattern++;
-                patternLen--;
-            }
-            match = 0;
-            while (1) {
-                if (pattern[0] == '\\') {
-                    pattern++;
-                    patternLen--;
-                    if (pattern[0] == string[0])
-                        match = 1;
-                } else if (pattern[0] == ']') {
-                    break;
-                } else if (patternLen == 0) {
-                    pattern--;
-                    patternLen++;
-                    break;
-                } else if (pattern[1] == '-' && patternLen >= 3) {
-                    int start = pattern[0];
-                    int end = pattern[2];
-                    int c = string[0];
-                    if (start > end) {
-                        int t = start;
-                        start = end;
-                        end = t;
-                    }
-                    if (nocase) {
-                        start = tolower(start);
-                        end = tolower(end);
-                        c = tolower(c);
-                    }
-                    pattern += 2;
-                    patternLen -= 2;
-                    if (c >= start && c <= end)
-                        match = 1;
-                } else {
-                    if (!nocase) {
-                        if (pattern[0] == string[0])
-                            match = 1;
-                    } else {
-                        if (tolower((int)pattern[0]) == tolower((int)string[0]))
-                            match = 1;
-                    }
-                }
-                pattern++;
-                patternLen--;
-            }
-            if (not)
-                match = !match;
-            if (!match)
-                return 0; /* no match */
-            string++;
-            stringLen--;
-            break;
-        }
-        case '\\':
-            if (patternLen >= 2) {
-                pattern++;
-                patternLen--;
-            }
-            /* fall through */
-        default:
-            if (!nocase) {
-                if (pattern[0] != string[0])
-                    return 0; /* no match */
-            } else {
-                if (tolower((int)pattern[0]) != tolower((int)string[0]))
-                    return 0; /* no match */
-            }
-            string++;
-            stringLen--;
-            break;
-        }
-        pattern++;
-        patternLen--;
-        if (stringLen == 0) {
-            while (*pattern == '*') {
-                pattern++;
-                patternLen--;
-            }
-            break;
-        }
-    }
-    if (patternLen == 0 && stringLen == 0)
-        return 1;
-    return 0;
-}
-
-int JimStringCompare(const char *s1, int l1, const char *s2, int l2,
-        int nocase)
-{
-    unsigned char *u1 = (unsigned char*) s1, *u2 = (unsigned char*) s2;
-
-    if (nocase == 0) {
-        while (l1 && l2) {
-            if (*u1 != *u2)
-                return (int)*u1-*u2;
-            u1++; u2++; l1--; l2--;
-        }
-        if (!l1 && !l2) return 0;
-        return l1-l2;
-    } else {
-        while (l1 && l2) {
-            if (tolower((int)*u1) != tolower((int)*u2))
-                return tolower((int)*u1)-tolower((int)*u2);
-            u1++; u2++; l1--; l2--;
-        }
-        if (!l1 && !l2) return 0;
-        return l1-l2;
-    }
-}
-
-/* Search 's1' inside 's2', starting to search from char 'index' of 's2'.
- * The index of the first occurrence of s1 in s2 is returned.
- * If s1 is not found inside s2, -1 is returned. */
-int JimStringFirst(const char *s1, int l1, const char *s2, int l2, int index_t)
-{
-    int i;
-
-    if (!l1 || !l2 || l1 > l2) return -1;
-    if (index_t < 0) index_t = 0;
-    s2 += index_t;
-    for (i = index_t; i <= l2-l1; i++) {
-        if (memcmp(s2, s1, l1) == 0)
-            return i;
-        s2++;
-    }
-    return -1;
-}
-
-int Jim_WideToString(char *buf, jim_wide wideValue)
-{
-    const char *fmt = "%" JIM_WIDE_MODIFIER;
-    return sprintf(buf, fmt, wideValue);
-}
-
-int Jim_StringToWide(const char *str, jim_wide *widePtr, int base)
-{
-    char *endptr;
-
-#ifdef HAVE_LONG_LONG_INT
-    *widePtr = JimStrtoll(str, &endptr, base);
-#else
-    *widePtr = strtol(str, &endptr, base);
-#endif
-    if ((str[0] == '\0') || (str == endptr))
-        return JIM_ERR;
-    if (endptr[0] != '\0') {
-        while (*endptr) {
-            if (!isspace((int)*endptr))
-                return JIM_ERR;
-            endptr++;
-        }
-    }
-    return JIM_OK;
-}
-
-int Jim_StringToIndex(const char *str, int *intPtr)
-{
-    char *endptr;
-
-    *intPtr = strtol(str, &endptr, 10);
-    if ((str[0] == '\0') || (str == endptr))
-        return JIM_ERR;
-    if (endptr[0] != '\0') {
-        while (*endptr) {
-            if (!isspace((int)*endptr))
-                return JIM_ERR;
-            endptr++;
-        }
-    }
-    return JIM_OK;
-}
-
-/* The string representation of references has two features in order
- * to make the GC faster. The first is that every reference starts
- * with a non common character '~', in order to make the string matching
- * fater. The second is that the reference string rep his 32 characters
- * in length, this allows to avoid to check every object with a string
- * repr < 32, and usually there are many of this objects. */
-
-#define JIM_REFERENCE_SPACE (35 + JIM_REFERENCE_TAGLEN)
-
-static int JimFormatReference(char *buf, Jim_Reference *refPtr, jim_wide id)
-{
-    const char *fmt = "<reference.<%s>.%020" JIM_WIDE_MODIFIER ">";
-    sprintf(buf, fmt, refPtr->tag, id);
-    return JIM_REFERENCE_SPACE;
-}
-
-int Jim_DoubleToString(char *buf, double doubleValue)
-{
-    char *s;
-    int len;
-
-    len = sprintf(buf, "%.17g", doubleValue);
-    s = buf;
-    while (*s) {
-        if (*s == '.') return len;
-        s++;
-    }
-    /* Add a final ".0" if it's a number. But not
-     * for NaN or InF */
-    if (isdigit((int)buf[0])
-        || ((buf[0] == '-' || buf[0] == '+')
-            && isdigit((int)buf[1]))) {
-        s[0] = '.';
-        s[1] = '0';
-        s[2] = '\0';
-        return len + 2;
-    }
-    return len;
-}
-
-int Jim_StringToDouble(const char *str, double *doublePtr)
-{
-    char *endptr;
-
-    *doublePtr = strtod(str, &endptr);
-    if (str[0] == '\0' || endptr[0] != '\0' || (str == endptr))
-        return JIM_ERR;
-    return JIM_OK;
-}
-
-static jim_wide JimPowWide(jim_wide b, jim_wide e)
-{
-    jim_wide i, res = 1;
-    if ((b == 0 && e != 0) || (e < 0)) return 0;
-    for (i = 0; i < e; i++) {res *= b;}
-    return res;
-}
-
-/* -----------------------------------------------------------------------------
- * Special functions
- * ---------------------------------------------------------------------------*/
-
-/* Note that 'interp' may be NULL if not available in the
- * context of the panic. It's only useful to get the error
- * file descriptor, it will default to stderr otherwise. */
-void Jim_Panic(Jim_Interp *interp, const char *fmt, ...)
-{
-    va_list ap;
-
-    va_start(ap, fmt);
-	/*
-	 * Send it here first.. Assuming STDIO still works
-	 */
-    fprintf(stderr, JIM_NL "JIM INTERPRETER PANIC: ");
-    vfprintf(stderr, fmt, ap);
-    fprintf(stderr, JIM_NL JIM_NL);
-    va_end(ap);
-
-#ifdef HAVE_BACKTRACE
-    {
-        void *array[40];
-        int size, i;
-        char **strings;
-
-        size = backtrace(array, 40);
-        strings = backtrace_symbols(array, size);
-        for (i = 0; i < size; i++)
-            fprintf(fp,"[backtrace] %s" JIM_NL, strings[i]);
-        fprintf(fp,"[backtrace] Include the above lines and the output" JIM_NL);
-        fprintf(fp,"[backtrace] of 'nm <executable>' in the bug report." JIM_NL);
-    }
-#endif
-
-	/* This may actually crash... we do it last */
-	if (interp && interp->cookie_stderr) {
-		Jim_fprintf(interp, interp->cookie_stderr, JIM_NL "JIM INTERPRETER PANIC: ");
-		Jim_vfprintf(interp, interp->cookie_stderr, fmt, ap);
-		Jim_fprintf(interp, interp->cookie_stderr, JIM_NL JIM_NL);
-	}
-    abort();
-}
-
-/* -----------------------------------------------------------------------------
- * Memory allocation
- * ---------------------------------------------------------------------------*/
-
-/* Macro used for memory debugging.
- * In order for they to work you have to rename Jim_Alloc into _Jim_Alloc
- * and similary for Jim_Realloc and Jim_Free */
-#if 0
-#define Jim_Alloc(s) (printf("%s %d: Jim_Alloc(%d)\n",__FILE__,__LINE__,s),_Jim_Alloc(s))
-#define Jim_Free(p) (printf("%s %d: Jim_Free(%p)\n",__FILE__,__LINE__,p),_Jim_Free(p))
-#define Jim_Realloc(p,s) (printf("%s %d: Jim_Realloc(%p,%d)\n",__FILE__,__LINE__,p,s),_Jim_Realloc(p,s))
-#endif
-
-void *Jim_Alloc(int size)
-{
-	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
-	if (size == 0)
-		size = 1;
-    void *p = malloc(size);
-    if (p == NULL)
-        Jim_Panic(NULL,"malloc: Out of memory");
-    return p;
-}
-
-void Jim_Free(void *ptr) {
-    free(ptr);
-}
-
-void *Jim_Realloc(void *ptr, int size)
-{
-	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
-	if (size == 0)
-		size = 1;
-    void *p = realloc(ptr, size);
-    if (p == NULL)
-        Jim_Panic(NULL,"realloc: Out of memory");
-    return p;
-}
-
-char *Jim_StrDup(const char *s)
-{
-    int l = strlen(s);
-    char *copy = Jim_Alloc(l + 1);
-
-    memcpy(copy, s, l + 1);
-    return copy;
-}
-
-char *Jim_StrDupLen(const char *s, int l)
-{
-    char *copy = Jim_Alloc(l + 1);
-
-    memcpy(copy, s, l + 1);
-    copy[l] = 0;    /* Just to be sure, original could be substring */
-    return copy;
-}
-
-/* -----------------------------------------------------------------------------
- * Time related functions
- * ---------------------------------------------------------------------------*/
-/* Returns microseconds of CPU used since start. */
-static jim_wide JimClock(void)
-{
-#if (defined WIN32) && !(defined JIM_ANSIC)
-    LARGE_INTEGER t, f;
-    QueryPerformanceFrequency(&f);
-    QueryPerformanceCounter(&t);
-    return (long)((t.QuadPart * 1000000) / f.QuadPart);
-#else /* !WIN32 */
-    clock_t clocks = clock();
-
-    return (long)(clocks*(1000000/CLOCKS_PER_SEC));
-#endif /* WIN32 */
-}
-
-/* -----------------------------------------------------------------------------
- * Hash Tables
- * ---------------------------------------------------------------------------*/
-
-/* -------------------------- private prototypes ---------------------------- */
-static int JimExpandHashTableIfNeeded(Jim_HashTable *ht);
-static unsigned int JimHashTableNextPower(unsigned int size);
-static int JimInsertHashEntry(Jim_HashTable *ht, const void *key);
-
-/* -------------------------- hash functions -------------------------------- */
-
-/* Thomas Wang's 32 bit Mix Function */
-unsigned int Jim_IntHashFunction(unsigned int key)
-{
-    key += ~(key << 15);
-    key ^=  (key >> 10);
-    key +=  (key << 3);
-    key ^=  (key >> 6);
-    key += ~(key << 11);
-    key ^=  (key >> 16);
-    return key;
-}
-
-/* Identity hash function for integer keys */
-unsigned int Jim_IdentityHashFunction(unsigned int key)
-{
-    return key;
-}
-
-/* Generic hash function (we are using to multiply by 9 and add the byte
- * as Tcl) */
-unsigned int Jim_GenHashFunction(const unsigned char *buf, int len)
-{
-    unsigned int h = 0;
-    while (len--)
-        h += (h << 3)+*buf++;
-    return h;
-}
-
-/* ----------------------------- API implementation ------------------------- */
-/* reset an hashtable already initialized with ht_init().
- * NOTE: This function should only called by ht_destroy(). */
-static void JimResetHashTable(Jim_HashTable *ht)
-{
-    ht->table = NULL;
-    ht->size = 0;
-    ht->sizemask = 0;
-    ht->used = 0;
-    ht->collisions = 0;
-}
-
-/* Initialize the hash table */
-int Jim_InitHashTable(Jim_HashTable *ht, Jim_HashTableType *type,
-        void *privDataPtr)
-{
-    JimResetHashTable(ht);
-    ht->type = type;
-    ht->privdata = privDataPtr;
-    return JIM_OK;
-}
-
-/* Resize the table to the minimal size that contains all the elements,
- * but with the invariant of a USER/BUCKETS ration near to <= 1 */
-int Jim_ResizeHashTable(Jim_HashTable *ht)
-{
-    int minimal = ht->used;
-
-    if (minimal < JIM_HT_INITIAL_SIZE)
-        minimal = JIM_HT_INITIAL_SIZE;
-    return Jim_ExpandHashTable(ht, minimal);
-}
-
-/* Expand or create the hashtable */
-int Jim_ExpandHashTable(Jim_HashTable *ht, unsigned int size)
-{
-    Jim_HashTable n; /* the new hashtable */
-    unsigned int realsize = JimHashTableNextPower(size), i;
-
-    /* the size is invalid if it is smaller than the number of
-     * elements already inside the hashtable */
-    if (ht->used >= size)
-        return JIM_ERR;
-
-    Jim_InitHashTable(&n, ht->type, ht->privdata);
-    n.size = realsize;
-    n.sizemask = realsize-1;
-    n.table = Jim_Alloc(realsize*sizeof(Jim_HashEntry*));
-
-    /* Initialize all the pointers to NULL */
-    memset(n.table, 0, realsize*sizeof(Jim_HashEntry*));
-
-    /* Copy all the elements from the old to the new table:
-     * note that if the old hash table is empty ht->size is zero,
-     * so Jim_ExpandHashTable just creates an hash table. */
-    n.used = ht->used;
-    for (i = 0; i < ht->size && ht->used > 0; i++) {
-        Jim_HashEntry *he, *nextHe;
-
-        if (ht->table[i] == NULL) continue;
-
-        /* For each hash entry on this slot... */
-        he = ht->table[i];
-        while (he) {
-            unsigned int h;
-
-            nextHe = he->next;
-            /* Get the new element index */
-            h = Jim_HashKey(ht, he->key) & n.sizemask;
-            he->next = n.table[h];
-            n.table[h] = he;
-            ht->used--;
-            /* Pass to the next element */
-            he = nextHe;
-        }
-    }
-    assert(ht->used == 0);
-    Jim_Free(ht->table);
-
-    /* Remap the new hashtable in the old */
-    *ht = n;
-    return JIM_OK;
-}
-
-/* Add an element to the target hash table */
-int Jim_AddHashEntry(Jim_HashTable *ht, const void *key, void *val)
-{
-    int index_t;
-    Jim_HashEntry *entry;
-
-    /* Get the index of the new element, or -1 if
-     * the element already exists. */
-    if ((index_t = JimInsertHashEntry(ht, key)) == -1)
-        return JIM_ERR;
-
-    /* Allocates the memory and stores key */
-    entry = Jim_Alloc(sizeof(*entry));
-    entry->next = ht->table[index_t];
-    ht->table[index_t] = entry;
-
-    /* Set the hash entry fields. */
-    Jim_SetHashKey(ht, entry, key);
-    Jim_SetHashVal(ht, entry, val);
-    ht->used++;
-    return JIM_OK;
-}
-
-/* Add an element, discarding the old if the key already exists */
-int Jim_ReplaceHashEntry(Jim_HashTable *ht, const void *key, void *val)
-{
-    Jim_HashEntry *entry;
-
-    /* Try to add the element. If the key
-     * does not exists Jim_AddHashEntry will suceed. */
-    if (Jim_AddHashEntry(ht, key, val) == JIM_OK)
-        return JIM_OK;
-    /* It already exists, get the entry */
-    entry = Jim_FindHashEntry(ht, key);
-    /* Free the old value and set the new one */
-    Jim_FreeEntryVal(ht, entry);
-    Jim_SetHashVal(ht, entry, val);
-    return JIM_OK;
-}
-
-/* Search and remove an element */
-int Jim_DeleteHashEntry(Jim_HashTable *ht, const void *key)
-{
-    unsigned int h;
-    Jim_HashEntry *he, *prevHe;
-
-    if (ht->size == 0)
-        return JIM_ERR;
-    h = Jim_HashKey(ht, key) & ht->sizemask;
-    he = ht->table[h];
-
-    prevHe = NULL;
-    while (he) {
-        if (Jim_CompareHashKeys(ht, key, he->key)) {
-            /* Unlink the element from the list */
-            if (prevHe)
-                prevHe->next = he->next;
-            else
-                ht->table[h] = he->next;
-            Jim_FreeEntryKey(ht, he);
-            Jim_FreeEntryVal(ht, he);
-            Jim_Free(he);
-            ht->used--;
-            return JIM_OK;
-        }
-        prevHe = he;
-        he = he->next;
-    }
-    return JIM_ERR; /* not found */
-}
-
-/* Destroy an entire hash table */
-int Jim_FreeHashTable(Jim_HashTable *ht)
-{
-    unsigned int i;
-
-    /* Free all the elements */
-    for (i = 0; i < ht->size && ht->used > 0; i++) {
-        Jim_HashEntry *he, *nextHe;
-
-        if ((he = ht->table[i]) == NULL) continue;
-        while (he) {
-            nextHe = he->next;
-            Jim_FreeEntryKey(ht, he);
-            Jim_FreeEntryVal(ht, he);
-            Jim_Free(he);
-            ht->used--;
-            he = nextHe;
-        }
-    }
-    /* Free the table and the allocated cache structure */
-    Jim_Free(ht->table);
-    /* Re-initialize the table */
-    JimResetHashTable(ht);
-    return JIM_OK; /* never fails */
-}
-
-Jim_HashEntry *Jim_FindHashEntry(Jim_HashTable *ht, const void *key)
-{
-    Jim_HashEntry *he;
-    unsigned int h;
-
-    if (ht->size == 0) return NULL;
-    h = Jim_HashKey(ht, key) & ht->sizemask;
-    he = ht->table[h];
-    while (he) {
-        if (Jim_CompareHashKeys(ht, key, he->key))
-            return he;
-        he = he->next;
-    }
-    return NULL;
-}
-
-Jim_HashTableIterator *Jim_GetHashTableIterator(Jim_HashTable *ht)
-{
-    Jim_HashTableIterator *iter = Jim_Alloc(sizeof(*iter));
-
-    iter->ht = ht;
-    iter->index = -1;
-    iter->entry = NULL;
-    iter->nextEntry = NULL;
-    return iter;
-}
-
-Jim_HashEntry *Jim_NextHashEntry(Jim_HashTableIterator *iter)
-{
-    while (1) {
-        if (iter->entry == NULL) {
-            iter->index++;
-            if (iter->index >=
-                    (signed)iter->ht->size) break;
-            iter->entry = iter->ht->table[iter->index];
-        } else {
-            iter->entry = iter->nextEntry;
-        }
-        if (iter->entry) {
-            /* We need to save the 'next' here, the iterator user
-             * may delete the entry we are returning. */
-            iter->nextEntry = iter->entry->next;
-            return iter->entry;
-        }
-    }
-    return NULL;
-}
-
-/* ------------------------- private functions ------------------------------ */
-
-/* Expand the hash table if needed */
-static int JimExpandHashTableIfNeeded(Jim_HashTable *ht)
-{
-    /* If the hash table is empty expand it to the intial size,
-     * if the table is "full" dobule its size. */
-    if (ht->size == 0)
-        return Jim_ExpandHashTable(ht, JIM_HT_INITIAL_SIZE);
-    if (ht->size == ht->used)
-        return Jim_ExpandHashTable(ht, ht->size*2);
-    return JIM_OK;
-}
-
-/* Our hash table capability is a power of two */
-static unsigned int JimHashTableNextPower(unsigned int size)
-{
-    unsigned int i = JIM_HT_INITIAL_SIZE;
-
-    if (size >= 2147483648U)
-        return 2147483648U;
-    while (1) {
-        if (i >= size)
-            return i;
-        i *= 2;
-    }
-}
-
-/* Returns the index of a free slot that can be populated with
- * an hash entry for the given 'key'.
- * If the key already exists, -1 is returned. */
-static int JimInsertHashEntry(Jim_HashTable *ht, const void *key)
-{
-    unsigned int h;
-    Jim_HashEntry *he;
-
-    /* Expand the hashtable if needed */
-    if (JimExpandHashTableIfNeeded(ht) == JIM_ERR)
-        return -1;
-    /* Compute the key hash value */
-    h = Jim_HashKey(ht, key) & ht->sizemask;
-    /* Search if this slot does not already contain the given key */
-    he = ht->table[h];
-    while (he) {
-        if (Jim_CompareHashKeys(ht, key, he->key))
-            return -1;
-        he = he->next;
-    }
-    return h;
-}
-
-/* ----------------------- StringCopy Hash Table Type ------------------------*/
-
-static unsigned int JimStringCopyHTHashFunction(const void *key)
-{
-    return Jim_GenHashFunction(key, strlen(key));
-}
-
-static const void *JimStringCopyHTKeyDup(void *privdata, const void *key)
-{
-    int len = strlen(key);
-    char *copy = Jim_Alloc(len + 1);
-    JIM_NOTUSED(privdata);
-
-    memcpy(copy, key, len);
-    copy[len] = '\0';
-    return copy;
-}
-
-static void *JimStringKeyValCopyHTValDup(void *privdata, const void *val)
-{
-    int len = strlen(val);
-    char *copy = Jim_Alloc(len + 1);
-    JIM_NOTUSED(privdata);
-
-    memcpy(copy, val, len);
-    copy[len] = '\0';
-    return copy;
-}
-
-static int JimStringCopyHTKeyCompare(void *privdata, const void *key1,
-        const void *key2)
-{
-    JIM_NOTUSED(privdata);
-
-    return strcmp(key1, key2) == 0;
-}
-
-static void JimStringCopyHTKeyDestructor(void *privdata, const void *key)
-{
-    JIM_NOTUSED(privdata);
-
-    Jim_Free((void*)key); /* ATTENTION: const cast */
-}
-
-static void JimStringKeyValCopyHTValDestructor(void *privdata, void *val)
-{
-    JIM_NOTUSED(privdata);
-
-    Jim_Free((void*)val); /* ATTENTION: const cast */
-}
-
-static Jim_HashTableType JimStringCopyHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,              /* key dup */
-    NULL,                               /* val dup */
-    JimStringCopyHTKeyCompare,          /* key compare */
-    JimStringCopyHTKeyDestructor,       /* key destructor */
-    NULL                                /* val destructor */
-};
-
-/* This is like StringCopy but does not auto-duplicate the key.
- * It's used for intepreter's shared strings. */
-static Jim_HashTableType JimSharedStringsHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    NULL,                               /* key dup */
-    NULL,                               /* val dup */
-    JimStringCopyHTKeyCompare,          /* key compare */
-    JimStringCopyHTKeyDestructor,       /* key destructor */
-    NULL                                /* val destructor */
-};
-
-/* This is like StringCopy but also automatically handle dynamic
- * allocated C strings as values. */
-static Jim_HashTableType JimStringKeyValCopyHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,              /* key dup */
-    JimStringKeyValCopyHTValDup,        /* val dup */
-    JimStringCopyHTKeyCompare,          /* key compare */
-    JimStringCopyHTKeyDestructor,       /* key destructor */
-    JimStringKeyValCopyHTValDestructor, /* val destructor */
-};
-
-typedef struct AssocDataValue {
-    Jim_InterpDeleteProc *delProc;
-    void *data;
-} AssocDataValue;
-
-static void JimAssocDataHashTableValueDestructor(void *privdata, void *data)
-{
-    AssocDataValue *assocPtr = (AssocDataValue *)data;
-    if (assocPtr->delProc != NULL)
-        assocPtr->delProc((Jim_Interp *)privdata, assocPtr->data);
-    Jim_Free(data);
-}
-
-static Jim_HashTableType JimAssocDataHashTableType = {
-    JimStringCopyHTHashFunction,         /* hash function */
-    JimStringCopyHTKeyDup,               /* key dup */
-    NULL,                                /* val dup */
-    JimStringCopyHTKeyCompare,           /* key compare */
-    JimStringCopyHTKeyDestructor,        /* key destructor */
-    JimAssocDataHashTableValueDestructor /* val destructor */
-};
-
-/* -----------------------------------------------------------------------------
- * Stack - This is a simple generic stack implementation. It is used for
- * example in the 'expr' expression compiler.
- * ---------------------------------------------------------------------------*/
-void Jim_InitStack(Jim_Stack *stack)
-{
-    stack->len = 0;
-    stack->maxlen = 0;
-    stack->vector = NULL;
-}
-
-void Jim_FreeStack(Jim_Stack *stack)
-{
-    Jim_Free(stack->vector);
-}
-
-int Jim_StackLen(Jim_Stack *stack)
-{
-    return stack->len;
-}
-
-void Jim_StackPush(Jim_Stack *stack, void *element) {
-    int neededLen = stack->len + 1;
-    if (neededLen > stack->maxlen) {
-        stack->maxlen = neededLen*2;
-        stack->vector = Jim_Realloc(stack->vector, sizeof(void*)*stack->maxlen);
-    }
-    stack->vector[stack->len] = element;
-    stack->len++;
-}
-
-void *Jim_StackPop(Jim_Stack *stack)
-{
-    if (stack->len == 0) return NULL;
-    stack->len--;
-    return stack->vector[stack->len];
-}
-
-void *Jim_StackPeek(Jim_Stack *stack)
-{
-    if (stack->len == 0) return NULL;
-    return stack->vector[stack->len-1];
-}
-
-void Jim_FreeStackElements(Jim_Stack *stack, void (*freeFunc)(void *ptr))
-{
-    int i;
-
-    for (i = 0; i < stack->len; i++)
-        freeFunc(stack->vector[i]);
-}
-
-/* -----------------------------------------------------------------------------
- * Parser
- * ---------------------------------------------------------------------------*/
-
-/* Token types */
-#define JIM_TT_NONE -1        /* No token returned */
-#define JIM_TT_STR 0        /* simple string */
-#define JIM_TT_ESC 1        /* string that needs escape chars conversion */
-#define JIM_TT_VAR 2        /* var substitution */
-#define JIM_TT_DICTSUGAR 3    /* Syntax sugar for [dict get], $foo(bar) */
-#define JIM_TT_CMD 4        /* command substitution */
-#define JIM_TT_SEP 5        /* word separator */
-#define JIM_TT_EOL 6        /* line separator */
-
-/* Additional token types needed for expressions */
-#define JIM_TT_SUBEXPR_START 7
-#define JIM_TT_SUBEXPR_END 8
-#define JIM_TT_EXPR_NUMBER 9
-#define JIM_TT_EXPR_OPERATOR 10
-
-/* Parser states */
-#define JIM_PS_DEF 0        /* Default state */
-#define JIM_PS_QUOTE 1        /* Inside "" */
-
-/* Parser context structure. The same context is used both to parse
- * Tcl scripts and lists. */
-struct JimParserCtx {
-    const char *prg;     /* Program text */
-    const char *p;       /* Pointer to the point of the program we are parsing */
-    int len;             /* Left length of 'prg' */
-    int linenr;          /* Current line number */
-    const char *tstart;
-    const char *tend;    /* Returned token is at tstart-tend in 'prg'. */
-    int tline;           /* Line number of the returned token */
-    int tt;              /* Token type */
-    int eof;             /* Non zero if EOF condition is true. */
-    int state;           /* Parser state */
-    int comment;         /* Non zero if the next chars may be a comment. */
-};
-
-#define JimParserEof(c) ((c)->eof)
-#define JimParserTstart(c) ((c)->tstart)
-#define JimParserTend(c) ((c)->tend)
-#define JimParserTtype(c) ((c)->tt)
-#define JimParserTline(c) ((c)->tline)
-
-static int JimParseScript(struct JimParserCtx *pc);
-static int JimParseSep(struct JimParserCtx *pc);
-static int JimParseEol(struct JimParserCtx *pc);
-static int JimParseCmd(struct JimParserCtx *pc);
-static int JimParseVar(struct JimParserCtx *pc);
-static int JimParseBrace(struct JimParserCtx *pc);
-static int JimParseStr(struct JimParserCtx *pc);
-static int JimParseComment(struct JimParserCtx *pc);
-static char *JimParserGetToken(struct JimParserCtx *pc,
-        int *lenPtr, int *typePtr, int *linePtr);
-
-/* Initialize a parser context.
- * 'prg' is a pointer to the program text, linenr is the line
- * number of the first line contained in the program. */
-void JimParserInit(struct JimParserCtx *pc, const char *prg,
-        int len, int linenr)
-{
-    pc->prg = prg;
-    pc->p = prg;
-    pc->len = len;
-    pc->tstart = NULL;
-    pc->tend = NULL;
-    pc->tline = 0;
-    pc->tt = JIM_TT_NONE;
-    pc->eof = 0;
-    pc->state = JIM_PS_DEF;
-    pc->linenr = linenr;
-    pc->comment = 1;
-}
-
-int JimParseScript(struct JimParserCtx *pc)
-{
-    while (1) { /* the while is used to reiterate with continue if needed */
-        if (!pc->len) {
-            pc->tstart = pc->p;
-            pc->tend = pc->p-1;
-            pc->tline = pc->linenr;
-            pc->tt = JIM_TT_EOL;
-            pc->eof = 1;
-            return JIM_OK;
-        }
-        switch (*(pc->p)) {
-        case '\\':
-            if (*(pc->p + 1) == '\n')
-                return JimParseSep(pc);
-            else {
-                pc->comment = 0;
-                return JimParseStr(pc);
-            }
-            break;
-        case ' ':
-        case '\t':
-        case '\r':
-            if (pc->state == JIM_PS_DEF)
-                return JimParseSep(pc);
-            else {
-                pc->comment = 0;
-                return JimParseStr(pc);
-            }
-            break;
-        case '\n':
-        case ';':
-            pc->comment = 1;
-            if (pc->state == JIM_PS_DEF)
-                return JimParseEol(pc);
-            else
-                return JimParseStr(pc);
-            break;
-        case '[':
-            pc->comment = 0;
-            return JimParseCmd(pc);
-            break;
-        case '$':
-            pc->comment = 0;
-            if (JimParseVar(pc) == JIM_ERR) {
-                pc->tstart = pc->tend = pc->p++; pc->len--;
-                pc->tline = pc->linenr;
-                pc->tt = JIM_TT_STR;
-                return JIM_OK;
-            } else
-                return JIM_OK;
-            break;
-        case '#':
-            if (pc->comment) {
-                JimParseComment(pc);
-                continue;
-            } else {
-                return JimParseStr(pc);
-            }
-        default:
-            pc->comment = 0;
-            return JimParseStr(pc);
-            break;
-        }
-        return JIM_OK;
-    }
-}
-
-int JimParseSep(struct JimParserCtx *pc)
-{
-    pc->tstart = pc->p;
-    pc->tline = pc->linenr;
-    while (*pc->p == ' ' || *pc->p == '\t' || *pc->p == '\r' ||
-           (*pc->p == '\\' && *(pc->p + 1) == '\n')) {
-        if (*pc->p == '\\') {
-            pc->p++; pc->len--;
-            pc->linenr++;
-        }
-        pc->p++; pc->len--;
-    }
-    pc->tend = pc->p-1;
-    pc->tt = JIM_TT_SEP;
-    return JIM_OK;
-}
-
-int JimParseEol(struct JimParserCtx *pc)
-{
-    pc->tstart = pc->p;
-    pc->tline = pc->linenr;
-    while (*pc->p == ' ' || *pc->p == '\n' ||
-           *pc->p == '\t' || *pc->p == '\r' || *pc->p == ';') {
-        if (*pc->p == '\n')
-            pc->linenr++;
-        pc->p++; pc->len--;
-    }
-    pc->tend = pc->p-1;
-    pc->tt = JIM_TT_EOL;
-    return JIM_OK;
-}
-
-/* Todo. Don't stop if ']' appears inside {} or quoted.
- * Also should handle the case of puts [string length "]"] */
-int JimParseCmd(struct JimParserCtx *pc)
-{
-    int level = 1;
-    int blevel = 0;
-
-    pc->tstart = ++pc->p; pc->len--;
-    pc->tline = pc->linenr;
-    while (1) {
-        if (pc->len == 0) {
-            break;
-        } else if (*pc->p == '[' && blevel == 0) {
-            level++;
-        } else if (*pc->p == ']' && blevel == 0) {
-            level--;
-            if (!level) break;
-        } else if (*pc->p == '\\') {
-            pc->p++; pc->len--;
-        } else if (*pc->p == '{') {
-            blevel++;
-        } else if (*pc->p == '}') {
-            if (blevel != 0)
-                blevel--;
-        } else if (*pc->p == '\n')
-            pc->linenr++;
-        pc->p++; pc->len--;
-    }
-    pc->tend = pc->p-1;
-    pc->tt = JIM_TT_CMD;
-    if (*pc->p == ']') {
-        pc->p++; pc->len--;
-    }
-    return JIM_OK;
-}
-
-int JimParseVar(struct JimParserCtx *pc)
-{
-    int brace = 0, stop = 0, ttype = JIM_TT_VAR;
-
-    pc->tstart = ++pc->p; pc->len--; /* skip the $ */
-    pc->tline = pc->linenr;
-    if (*pc->p == '{') {
-        pc->tstart = ++pc->p; pc->len--;
-        brace = 1;
-    }
-    if (brace) {
-        while (!stop) {
-            if (*pc->p == '}' || pc->len == 0) {
-                pc->tend = pc->p-1;
-                stop = 1;
-                if (pc->len == 0)
-                    break;
-            }
-            else if (*pc->p == '\n')
-                pc->linenr++;
-            pc->p++; pc->len--;
-        }
-    } else {
-        /* Include leading colons */
-        while (*pc->p == ':') {
-            pc->p++;
-            pc->len--;
-        }
-        while (!stop) {
-            if (!((*pc->p >= 'a' && *pc->p <= 'z') ||
-                (*pc->p >= 'A' && *pc->p <= 'Z') ||
-                (*pc->p >= '0' && *pc->p <= '9') || *pc->p == '_'))
-                stop = 1;
-            else {
-                pc->p++; pc->len--;
-            }
-        }
-        /* Parse [dict get] syntax sugar. */
-        if (*pc->p == '(') {
-            while (*pc->p != ')' && pc->len) {
-                pc->p++; pc->len--;
-                if (*pc->p == '\\' && pc->len >= 2) {
-                    pc->p += 2; pc->len -= 2;
-                }
-            }
-            if (*pc->p != '\0') {
-                pc->p++; pc->len--;
-            }
-            ttype = JIM_TT_DICTSUGAR;
-        }
-        pc->tend = pc->p-1;
-    }
-    /* Check if we parsed just the '$' character.
-     * That's not a variable so an error is returned
-     * to tell the state machine to consider this '$' just
-     * a string. */
-    if (pc->tstart == pc->p) {
-        pc->p--; pc->len++;
-        return JIM_ERR;
-    }
-    pc->tt = ttype;
-    return JIM_OK;
-}
-
-int JimParseBrace(struct JimParserCtx *pc)
-{
-    int level = 1;
-
-    pc->tstart = ++pc->p; pc->len--;
-    pc->tline = pc->linenr;
-    while (1) {
-        if (*pc->p == '\\' && pc->len >= 2) {
-            pc->p++; pc->len--;
-            if (*pc->p == '\n')
-                pc->linenr++;
-        } else if (*pc->p == '{') {
-            level++;
-        } else if (pc->len == 0 || *pc->p == '}') {
-            level--;
-            if (pc->len == 0 || level == 0) {
-                pc->tend = pc->p-1;
-                if (pc->len != 0) {
-                    pc->p++; pc->len--;
-                }
-                pc->tt = JIM_TT_STR;
-                return JIM_OK;
-            }
-        } else if (*pc->p == '\n') {
-            pc->linenr++;
-        }
-        pc->p++; pc->len--;
-    }
-    return JIM_OK; /* unreached */
-}
-
-int JimParseStr(struct JimParserCtx *pc)
-{
-    int newword = (pc->tt == JIM_TT_SEP || pc->tt == JIM_TT_EOL ||
-            pc->tt == JIM_TT_NONE || pc->tt == JIM_TT_STR);
-    if (newword && *pc->p == '{') {
-        return JimParseBrace(pc);
-    } else if (newword && *pc->p == '"') {
-        pc->state = JIM_PS_QUOTE;
-        pc->p++; pc->len--;
-    }
-    pc->tstart = pc->p;
-    pc->tline = pc->linenr;
-    while (1) {
-        if (pc->len == 0) {
-            pc->tend = pc->p-1;
-            pc->tt = JIM_TT_ESC;
-            return JIM_OK;
-        }
-        switch (*pc->p) {
-        case '\\':
-            if (pc->state == JIM_PS_DEF &&
-                *(pc->p + 1) == '\n') {
-                pc->tend = pc->p-1;
-                pc->tt = JIM_TT_ESC;
-                return JIM_OK;
-            }
-            if (pc->len >= 2) {
-                pc->p++; pc->len--;
-            }
-            break;
-        case '$':
-        case '[':
-            pc->tend = pc->p-1;
-            pc->tt = JIM_TT_ESC;
-            return JIM_OK;
-        case ' ':
-        case '\t':
-        case '\n':
-        case '\r':
-        case ';':
-            if (pc->state == JIM_PS_DEF) {
-                pc->tend = pc->p-1;
-                pc->tt = JIM_TT_ESC;
-                return JIM_OK;
-            } else if (*pc->p == '\n') {
-                pc->linenr++;
-            }
-            break;
-        case '"':
-            if (pc->state == JIM_PS_QUOTE) {
-                pc->tend = pc->p-1;
-                pc->tt = JIM_TT_ESC;
-                pc->p++; pc->len--;
-                pc->state = JIM_PS_DEF;
-                return JIM_OK;
-            }
-            break;
-        }
-        pc->p++; pc->len--;
-    }
-    return JIM_OK; /* unreached */
-}
-
-int JimParseComment(struct JimParserCtx *pc)
-{
-    while (*pc->p) {
-        if (*pc->p == '\n') {
-            pc->linenr++;
-            if (*(pc->p-1) != '\\') {
-                pc->p++; pc->len--;
-                return JIM_OK;
-            }
-        }
-        pc->p++; pc->len--;
-    }
-    return JIM_OK;
-}
-
-/* xdigitval and odigitval are helper functions for JimParserGetToken() */
-static int xdigitval(int c)
-{
-    if (c >= '0' && c <= '9') return c-'0';
-    if (c >= 'a' && c <= 'f') return c-'a'+10;
-    if (c >= 'A' && c <= 'F') return c-'A'+10;
-    return -1;
-}
-
-static int odigitval(int c)
-{
-    if (c >= '0' && c <= '7') return c-'0';
-    return -1;
-}
-
-/* Perform Tcl escape substitution of 's', storing the result
- * string into 'dest'. The escaped string is guaranteed to
- * be the same length or shorted than the source string.
- * Slen is the length of the string at 's', if it's -1 the string
- * length will be calculated by the function.
- *
- * The function returns the length of the resulting string. */
-static int JimEscape(char *dest, const char *s, int slen)
-{
-    char *p = dest;
-    int i, len;
-
-    if (slen == -1)
-        slen = strlen(s);
-
-    for (i = 0; i < slen; i++) {
-        switch (s[i]) {
-        case '\\':
-            switch (s[i + 1]) {
-            case 'a': *p++ = 0x7; i++; break;
-            case 'b': *p++ = 0x8; i++; break;
-            case 'f': *p++ = 0xc; i++; break;
-            case 'n': *p++ = 0xa; i++; break;
-            case 'r': *p++ = 0xd; i++; break;
-            case 't': *p++ = 0x9; i++; break;
-            case 'v': *p++ = 0xb; i++; break;
-            case '\0': *p++ = '\\'; i++; break;
-            case '\n': *p++ = ' '; i++; break;
-            default:
-                  if (s[i + 1] == 'x') {
-                    int val = 0;
-                    int c = xdigitval(s[i + 2]);
-                    if (c == -1) {
-                        *p++ = 'x';
-                        i++;
-                        break;
-                    }
-                    val = c;
-                    c = xdigitval(s[i + 3]);
-                    if (c == -1) {
-                        *p++ = val;
-                        i += 2;
-                        break;
-                    }
-                    val = (val*16) + c;
-                    *p++ = val;
-                    i += 3;
-                    break;
-                  } else if (s[i + 1] >= '0' && s[i + 1] <= '7')
-                  {
-                    int val = 0;
-                    int c = odigitval(s[i + 1]);
-                    val = c;
-                    c = odigitval(s[i + 2]);
-                    if (c == -1) {
-                        *p++ = val;
-                        i ++;
-                        break;
-                    }
-                    val = (val*8) + c;
-                    c = odigitval(s[i + 3]);
-                    if (c == -1) {
-                        *p++ = val;
-                        i += 2;
-                        break;
-                    }
-                    val = (val*8) + c;
-                    *p++ = val;
-                    i += 3;
-                  } else {
-                    *p++ = s[i + 1];
-                    i++;
-                  }
-                  break;
-            }
-            break;
-        default:
-            *p++ = s[i];
-            break;
-        }
-    }
-    len = p-dest;
-    *p++ = '\0';
-    return len;
-}
-
-/* Returns a dynamically allocated copy of the current token in the
- * parser context. The function perform conversion of escapes if
- * the token is of type JIM_TT_ESC.
- *
- * Note that after the conversion, tokens that are grouped with
- * braces in the source code, are always recognizable from the
- * identical string obtained in a different way from the type.
- *
- * For exmple the string:
- *
- * {expand}$a
- *
- * will return as first token "expand", of type JIM_TT_STR
- *
- * While the string:
- *
- * expand$a
- *
- * will return as first token "expand", of type JIM_TT_ESC
- */
-char *JimParserGetToken(struct JimParserCtx *pc,
-        int *lenPtr, int *typePtr, int *linePtr)
-{
-    const char *start, *end;
-    char *token;
-    int len;
-
-    start = JimParserTstart(pc);
-    end = JimParserTend(pc);
-    if (start > end) {
-        if (lenPtr) *lenPtr = 0;
-        if (typePtr) *typePtr = JimParserTtype(pc);
-        if (linePtr) *linePtr = JimParserTline(pc);
-        token = Jim_Alloc(1);
-        token[0] = '\0';
-        return token;
-    }
-    len = (end-start) + 1;
-    token = Jim_Alloc(len + 1);
-    if (JimParserTtype(pc) != JIM_TT_ESC) {
-        /* No escape conversion needed? Just copy it. */
-        memcpy(token, start, len);
-        token[len] = '\0';
-    } else {
-        /* Else convert the escape chars. */
-        len = JimEscape(token, start, len);
-    }
-    if (lenPtr) *lenPtr = len;
-    if (typePtr) *typePtr = JimParserTtype(pc);
-    if (linePtr) *linePtr = JimParserTline(pc);
-    return token;
-}
-
-/* The following functin is not really part of the parsing engine of Jim,
- * but it somewhat related. Given an string and its length, it tries
- * to guess if the script is complete or there are instead " " or { }
- * open and not completed. This is useful for interactive shells
- * implementation and for [info complete].
- *
- * If 'stateCharPtr' != NULL, the function stores ' ' on complete script,
- * '{' on scripts incomplete missing one or more '}' to be balanced.
- * '"' on scripts incomplete missing a '"' char.
- *
- * If the script is complete, 1 is returned, otherwise 0. */
-int Jim_ScriptIsComplete(const char *s, int len, char *stateCharPtr)
-{
-    int level = 0;
-    int state = ' ';
-
-    while (len) {
-        switch (*s) {
-            case '\\':
-                if (len > 1)
-                    s++;
-                break;
-            case '"':
-                if (state == ' ') {
-                    state = '"';
-                } else if (state == '"') {
-                    state = ' ';
-                }
-                break;
-            case '{':
-                if (state == '{') {
-                    level++;
-                } else if (state == ' ') {
-                    state = '{';
-                    level++;
-                }
-                break;
-            case '}':
-                if (state == '{') {
-                    level--;
-                    if (level == 0)
-                        state = ' ';
-                }
-                break;
-        }
-        s++;
-        len--;
-    }
-    if (stateCharPtr)
-        *stateCharPtr = state;
-    return state == ' ';
-}
-
-/* -----------------------------------------------------------------------------
- * Tcl Lists parsing
- * ---------------------------------------------------------------------------*/
-static int JimParseListSep(struct JimParserCtx *pc);
-static int JimParseListStr(struct JimParserCtx *pc);
-
-int JimParseList(struct JimParserCtx *pc)
-{
-    if (pc->len == 0) {
-        pc->tstart = pc->tend = pc->p;
-        pc->tline = pc->linenr;
-        pc->tt = JIM_TT_EOL;
-        pc->eof = 1;
-        return JIM_OK;
-    }
-    switch (*pc->p) {
-    case ' ':
-    case '\n':
-    case '\t':
-    case '\r':
-        if (pc->state == JIM_PS_DEF)
-            return JimParseListSep(pc);
-        else
-            return JimParseListStr(pc);
-        break;
-    default:
-        return JimParseListStr(pc);
-        break;
-    }
-    return JIM_OK;
-}
-
-int JimParseListSep(struct JimParserCtx *pc)
-{
-    pc->tstart = pc->p;
-    pc->tline = pc->linenr;
-    while (*pc->p == ' ' || *pc->p == '\t' || *pc->p == '\r' || *pc->p == '\n')
-    {
-        pc->p++; pc->len--;
-    }
-    pc->tend = pc->p-1;
-    pc->tt = JIM_TT_SEP;
-    return JIM_OK;
-}
-
-int JimParseListStr(struct JimParserCtx *pc)
-{
-    int newword = (pc->tt == JIM_TT_SEP || pc->tt == JIM_TT_EOL ||
-            pc->tt == JIM_TT_NONE);
-    if (newword && *pc->p == '{') {
-        return JimParseBrace(pc);
-    } else if (newword && *pc->p == '"') {
-        pc->state = JIM_PS_QUOTE;
-        pc->p++; pc->len--;
-    }
-    pc->tstart = pc->p;
-    pc->tline = pc->linenr;
-    while (1) {
-        if (pc->len == 0) {
-            pc->tend = pc->p-1;
-            pc->tt = JIM_TT_ESC;
-            return JIM_OK;
-        }
-        switch (*pc->p) {
-        case '\\':
-            pc->p++; pc->len--;
-            break;
-        case ' ':
-        case '\t':
-        case '\n':
-        case '\r':
-            if (pc->state == JIM_PS_DEF) {
-                pc->tend = pc->p-1;
-                pc->tt = JIM_TT_ESC;
-                return JIM_OK;
-            } else if (*pc->p == '\n') {
-                pc->linenr++;
-            }
-            break;
-        case '"':
-            if (pc->state == JIM_PS_QUOTE) {
-                pc->tend = pc->p-1;
-                pc->tt = JIM_TT_ESC;
-                pc->p++; pc->len--;
-                pc->state = JIM_PS_DEF;
-                return JIM_OK;
-            }
-            break;
-        }
-        pc->p++; pc->len--;
-    }
-    return JIM_OK; /* unreached */
-}
-
-/* -----------------------------------------------------------------------------
- * Jim_Obj related functions
- * ---------------------------------------------------------------------------*/
-
-/* Return a new initialized object. */
-Jim_Obj *Jim_NewObj(Jim_Interp *interp)
-{
-    Jim_Obj *objPtr;
-
-    /* -- Check if there are objects in the free list -- */
-    if (interp->freeList != NULL) {
-        /* -- Unlink the object from the free list -- */
-        objPtr = interp->freeList;
-        interp->freeList = objPtr->nextObjPtr;
-    } else {
-        /* -- No ready to use objects: allocate a new one -- */
-        objPtr = Jim_Alloc(sizeof(*objPtr));
-    }
-
-    /* Object is returned with refCount of 0. Every
-     * kind of GC implemented should take care to don't try
-     * to scan objects with refCount == 0. */
-    objPtr->refCount = 0;
-    /* All the other fields are left not initialized to save time.
-     * The caller will probably want set they to the right
-     * value anyway. */
-
-    /* -- Put the object into the live list -- */
-    objPtr->prevObjPtr = NULL;
-    objPtr->nextObjPtr = interp->liveList;
-    if (interp->liveList)
-        interp->liveList->prevObjPtr = objPtr;
-    interp->liveList = objPtr;
-
-    return objPtr;
-}
-
-/* Free an object. Actually objects are never freed, but
- * just moved to the free objects list, where they will be
- * reused by Jim_NewObj(). */
-void Jim_FreeObj(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    /* Check if the object was already freed, panic. */
-    if (objPtr->refCount != 0)  {
-        Jim_Panic(interp,"!!!Object %p freed with bad refcount %d", objPtr,
-                objPtr->refCount);
-    }
-    /* Free the internal representation */
-    Jim_FreeIntRep(interp, objPtr);
-    /* Free the string representation */
-    if (objPtr->bytes != NULL) {
-        if (objPtr->bytes != JimEmptyStringRep)
-            Jim_Free(objPtr->bytes);
-    }
-    /* Unlink the object from the live objects list */
-    if (objPtr->prevObjPtr)
-        objPtr->prevObjPtr->nextObjPtr = objPtr->nextObjPtr;
-    if (objPtr->nextObjPtr)
-        objPtr->nextObjPtr->prevObjPtr = objPtr->prevObjPtr;
-    if (interp->liveList == objPtr)
-        interp->liveList = objPtr->nextObjPtr;
-    /* Link the object into the free objects list */
-    objPtr->prevObjPtr = NULL;
-    objPtr->nextObjPtr = interp->freeList;
-    if (interp->freeList)
-        interp->freeList->prevObjPtr = objPtr;
-    interp->freeList = objPtr;
-    objPtr->refCount = -1;
-}
-
-/* Invalidate the string representation of an object. */
-void Jim_InvalidateStringRep(Jim_Obj *objPtr)
-{
-    if (objPtr->bytes != NULL) {
-        if (objPtr->bytes != JimEmptyStringRep)
-            Jim_Free(objPtr->bytes);
-    }
-    objPtr->bytes = NULL;
-}
-
-#define Jim_SetStringRep(o, b, l) \
-    do { (o)->bytes = b; (o)->length = l; } while (0)
-
-/* Set the initial string representation for an object.
- * Does not try to free an old one. */
-void Jim_InitStringRep(Jim_Obj *objPtr, const char *bytes, int length)
-{
-    if (length == 0) {
-        objPtr->bytes = JimEmptyStringRep;
-        objPtr->length = 0;
-    } else {
-        objPtr->bytes = Jim_Alloc(length + 1);
-        objPtr->length = length;
-        memcpy(objPtr->bytes, bytes, length);
-        objPtr->bytes[length] = '\0';
-    }
-}
-
-/* Duplicate an object. The returned object has refcount = 0. */
-Jim_Obj *Jim_DuplicateObj(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_Obj *dupPtr;
-
-    dupPtr = Jim_NewObj(interp);
-    if (objPtr->bytes == NULL) {
-        /* Object does not have a valid string representation. */
-        dupPtr->bytes = NULL;
-    } else {
-        Jim_InitStringRep(dupPtr, objPtr->bytes, objPtr->length);
-    }
-    if (objPtr->typePtr != NULL) {
-        if (objPtr->typePtr->dupIntRepProc == NULL) {
-            dupPtr->internalRep = objPtr->internalRep;
-        } else {
-            objPtr->typePtr->dupIntRepProc(interp, objPtr, dupPtr);
-        }
-        dupPtr->typePtr = objPtr->typePtr;
-    } else {
-        dupPtr->typePtr = NULL;
-    }
-    return dupPtr;
-}
-
-/* Return the string representation for objPtr. If the object
- * string representation is invalid, calls the method to create
- * a new one starting from the internal representation of the object. */
-const char *Jim_GetString(Jim_Obj *objPtr, int *lenPtr)
-{
-    if (objPtr->bytes == NULL) {
-        /* Invalid string repr. Generate it. */
-        if (objPtr->typePtr->updateStringProc == NULL) {
-            Jim_Panic(NULL,"UpdataStringProc called against '%s' type.",
-                objPtr->typePtr->name);
-        }
-        objPtr->typePtr->updateStringProc(objPtr);
-    }
-    if (lenPtr)
-        *lenPtr = objPtr->length;
-    return objPtr->bytes;
-}
-
-/* Just returns the length of the object's string rep */
-int Jim_Length(Jim_Obj *objPtr)
-{
-    int len;
-
-    Jim_GetString(objPtr, &len);
-    return len;
-}
-
-/* -----------------------------------------------------------------------------
- * String Object
- * ---------------------------------------------------------------------------*/
-static void DupStringInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static int SetStringFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType stringObjType = {
-    "string",
-    NULL,
-    DupStringInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-void DupStringInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-
-    /* This is a bit subtle: the only caller of this function
-     * should be Jim_DuplicateObj(), that will copy the
-     * string representaion. After the copy, the duplicated
-     * object will not have more room in teh buffer than
-     * srcPtr->length bytes. So we just set it to length. */
-    dupPtr->internalRep.strValue.maxLength = srcPtr->length;
-}
-
-int SetStringFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    /* Get a fresh string representation. */
-    (void) Jim_GetString(objPtr, NULL);
-    /* Free any other internal representation. */
-    Jim_FreeIntRep(interp, objPtr);
-    /* Set it as string, i.e. just set the maxLength field. */
-    objPtr->typePtr = &stringObjType;
-    objPtr->internalRep.strValue.maxLength = objPtr->length;
-    return JIM_OK;
-}
-
-Jim_Obj *Jim_NewStringObj(Jim_Interp *interp, const char *s, int len)
-{
-    Jim_Obj *objPtr = Jim_NewObj(interp);
-
-    if (len == -1)
-        len = strlen(s);
-    /* Alloc/Set the string rep. */
-    if (len == 0) {
-        objPtr->bytes = JimEmptyStringRep;
-        objPtr->length = 0;
-    } else {
-        objPtr->bytes = Jim_Alloc(len + 1);
-        objPtr->length = len;
-        memcpy(objPtr->bytes, s, len);
-        objPtr->bytes[len] = '\0';
-    }
-
-    /* No typePtr field for the vanilla string object. */
-    objPtr->typePtr = NULL;
-    return objPtr;
-}
-
-/* This version does not try to duplicate the 's' pointer, but
- * use it directly. */
-Jim_Obj *Jim_NewStringObjNoAlloc(Jim_Interp *interp, char *s, int len)
-{
-    Jim_Obj *objPtr = Jim_NewObj(interp);
-
-    if (len == -1)
-        len = strlen(s);
-    Jim_SetStringRep(objPtr, s, len);
-    objPtr->typePtr = NULL;
-    return objPtr;
-}
-
-/* Low-level string append. Use it only against objects
- * of type "string". */
-void StringAppendString(Jim_Obj *objPtr, const char *str, int len)
-{
-    int needlen;
-
-    if (len == -1)
-        len = strlen(str);
-    needlen = objPtr->length + len;
-    if (objPtr->internalRep.strValue.maxLength < needlen ||
-        objPtr->internalRep.strValue.maxLength == 0) {
-        if (objPtr->bytes == JimEmptyStringRep) {
-            objPtr->bytes = Jim_Alloc((needlen*2) + 1);
-        } else {
-            objPtr->bytes = Jim_Realloc(objPtr->bytes, (needlen*2) + 1);
-        }
-        objPtr->internalRep.strValue.maxLength = needlen*2;
-    }
-    memcpy(objPtr->bytes + objPtr->length, str, len);
-    objPtr->bytes[objPtr->length + len] = '\0';
-    objPtr->length += len;
-}
-
-/* Low-level wrapper to append an object. */
-void StringAppendObj(Jim_Obj *objPtr, Jim_Obj *appendObjPtr)
-{
-    int len;
-    const char *str;
-
-    str = Jim_GetString(appendObjPtr, &len);
-    StringAppendString(objPtr, str, len);
-}
-
-/* Higher level API to append strings to objects. */
-void Jim_AppendString(Jim_Interp *interp, Jim_Obj *objPtr, const char *str,
-        int len)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,"Jim_AppendString called with shared object");
-    if (objPtr->typePtr != &stringObjType)
-        SetStringFromAny(interp, objPtr);
-    StringAppendString(objPtr, str, len);
-}
-
-void Jim_AppendString_sprintf(Jim_Interp *interp, Jim_Obj *objPtr, const char *fmt, ...)
-{
-	char *buf;
-	va_list ap;
-
-	va_start(ap, fmt);
-	buf = jim_vasprintf(fmt, ap);
-	va_end(ap);
-
-	if (buf) {
-		Jim_AppendString(interp, objPtr, buf, -1);
-		jim_vasprintf_done(buf);
-	}
-}
-
-
-void Jim_AppendObj(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *appendObjPtr)
-{
-    int len;
-    const char *str;
-
-    str = Jim_GetString(appendObjPtr, &len);
-    Jim_AppendString(interp, objPtr, str, len);
-}
-
-void Jim_AppendStrings(Jim_Interp *interp, Jim_Obj *objPtr, ...)
-{
-    va_list ap;
-
-    if (objPtr->typePtr != &stringObjType)
-        SetStringFromAny(interp, objPtr);
-    va_start(ap, objPtr);
-    while (1) {
-        char *s = va_arg(ap, char*);
-
-        if (s == NULL) break;
-        Jim_AppendString(interp, objPtr, s, -1);
-    }
-    va_end(ap);
-}
-
-int Jim_StringEqObj(Jim_Obj *aObjPtr, Jim_Obj *bObjPtr, int nocase)
-{
-    const char *aStr, *bStr;
-    int aLen, bLen, i;
-
-    if (aObjPtr == bObjPtr) return 1;
-    aStr = Jim_GetString(aObjPtr, &aLen);
-    bStr = Jim_GetString(bObjPtr, &bLen);
-    if (aLen != bLen) return 0;
-    if (nocase == 0)
-        return memcmp(aStr, bStr, aLen) == 0;
-    for (i = 0; i < aLen; i++) {
-        if (tolower((int)aStr[i]) != tolower((int)bStr[i]))
-            return 0;
-    }
-    return 1;
-}
-
-int Jim_StringMatchObj(Jim_Obj *patternObjPtr, Jim_Obj *objPtr,
-        int nocase)
-{
-    const char *pattern, *string;
-    int patternLen, stringLen;
-
-    pattern = Jim_GetString(patternObjPtr, &patternLen);
-    string = Jim_GetString(objPtr, &stringLen);
-    return JimStringMatch(pattern, patternLen, string, stringLen, nocase);
-}
-
-int Jim_StringCompareObj(Jim_Obj *firstObjPtr,
-        Jim_Obj *secondObjPtr, int nocase)
-{
-    const char *s1, *s2;
-    int l1, l2;
-
-    s1 = Jim_GetString(firstObjPtr, &l1);
-    s2 = Jim_GetString(secondObjPtr, &l2);
-    return JimStringCompare(s1, l1, s2, l2, nocase);
-}
-
-/* Convert a range, as returned by Jim_GetRange(), into
- * an absolute index into an object of the specified length.
- * This function may return negative values, or values
- * bigger or equal to the length of the list if the index
- * is out of range. */
-static int JimRelToAbsIndex(int len, int index_t)
-{
-    if (index_t < 0)
-        return len + index_t;
-    return index_t;
-}
-
-/* Convert a pair of index as normalize by JimRelToAbsIndex(),
- * into a range stored in *firstPtr, *lastPtr, *rangeLenPtr, suitable
- * for implementation of commands like [string range] and [lrange].
- *
- * The resulting range is guaranteed to address valid elements of
- * the structure. */
-static void JimRelToAbsRange(int len, int first, int last,
-        int *firstPtr, int *lastPtr, int *rangeLenPtr)
-{
-    int rangeLen;
-
-    if (first > last) {
-        rangeLen = 0;
-    } else {
-        rangeLen = last-first + 1;
-        if (rangeLen) {
-            if (first < 0) {
-                rangeLen += first;
-                first = 0;
-            }
-            if (last >= len) {
-                rangeLen -= (last-(len-1));
-                last = len-1;
-            }
-        }
-    }
-    if (rangeLen < 0) rangeLen = 0;
-
-    *firstPtr = first;
-    *lastPtr = last;
-    *rangeLenPtr = rangeLen;
-}
-
-Jim_Obj *Jim_StringRangeObj(Jim_Interp *interp,
-        Jim_Obj *strObjPtr, Jim_Obj *firstObjPtr, Jim_Obj *lastObjPtr)
-{
-    int first, last;
-    const char *str;
-    int len, rangeLen;
-
-    if (Jim_GetIndex(interp, firstObjPtr, &first) != JIM_OK ||
-        Jim_GetIndex(interp, lastObjPtr, &last) != JIM_OK)
-        return NULL;
-    str = Jim_GetString(strObjPtr, &len);
-    first = JimRelToAbsIndex(len, first);
-    last = JimRelToAbsIndex(len, last);
-    JimRelToAbsRange(len, first, last, &first, &last, &rangeLen);
-    return Jim_NewStringObj(interp, str + first, rangeLen);
-}
-
-static Jim_Obj *JimStringToLower(Jim_Interp *interp, Jim_Obj *strObjPtr)
-{
-    char *buf;
-    int i;
-    if (strObjPtr->typePtr != &stringObjType) {
-        SetStringFromAny(interp, strObjPtr);
-    }
-
-    buf = Jim_Alloc(strObjPtr->length + 1);
-
-    memcpy(buf, strObjPtr->bytes, strObjPtr->length + 1);
-    for (i = 0; i < strObjPtr->length; i++)
-        buf[i] = tolower((unsigned)buf[i]);
-    return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr->length);
-}
-
-static Jim_Obj *JimStringToUpper(Jim_Interp *interp, Jim_Obj *strObjPtr)
-{
-    char *buf;
-    int i;
-    if (strObjPtr->typePtr != &stringObjType) {
-        SetStringFromAny(interp, strObjPtr);
-    }
-
-    buf = Jim_Alloc(strObjPtr->length + 1);
-
-    memcpy(buf, strObjPtr->bytes, strObjPtr->length + 1);
-    for (i = 0; i < strObjPtr->length; i++)
-        buf[i] = toupper((unsigned)buf[i]);
-    return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr->length);
-}
-
-/* This is the core of the [format] command.
- * TODO: Lots of things work - via a hack
- *       However, no format item can be >= JIM_MAX_FMT
- */
-#define JIM_MAX_FMT 2048
-static Jim_Obj *Jim_FormatString_Inner(Jim_Interp *interp, Jim_Obj *fmtObjPtr,
-        int objc, Jim_Obj *const *objv, char *sprintf_buf)
-{
-    const char *fmt, *_fmt;
-    int fmtLen;
-    Jim_Obj *resObjPtr;
-
-
-    fmt = Jim_GetString(fmtObjPtr, &fmtLen);
-	_fmt = fmt;
-    resObjPtr = Jim_NewStringObj(interp, "", 0);
-    while (fmtLen) {
-        const char *p = fmt;
-        char spec[2], c;
-        jim_wide wideValue;
-		double doubleValue;
-		/* we cheat and use Sprintf()! */
-		char fmt_str[100];
-		char *cp;
-		int width;
-		int ljust;
-		int zpad;
-		int spad;
-		int altfm;
-		int forceplus;
-		int prec;
-		int inprec;
-		int haveprec;
-		int accum;
-
-        while (*fmt != '%' && fmtLen) {
-            fmt++; fmtLen--;
-        }
-        Jim_AppendString(interp, resObjPtr, p, fmt-p);
-        if (fmtLen == 0)
-            break;
-        fmt++; fmtLen--; /* skip '%' */
-		zpad = 0;
-		spad = 0;
-		width = -1;
-		ljust = 0;
-		altfm = 0;
-		forceplus = 0;
-		inprec = 0;
-		haveprec = 0;
-		prec = -1; /* not found yet */
-    next_fmt:
-		if (fmtLen <= 0) {
-			break;
-		}
-		switch (*fmt) {
-			/* terminals */
-        case 'b': /* binary - not all printfs() do this */
-		case 's': /* string */
-		case 'i': /* integer */
-		case 'd': /* decimal */
-		case 'x': /* hex */
-		case 'X': /* CAP hex */
-		case 'c': /* char */
-		case 'o': /* octal */
-		case 'u': /* unsigned */
-		case 'f': /* float */
-			break;
-
-			/* non-terminals */
-		case '0': /* zero pad */
-			zpad = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case '+':
-			forceplus = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case ' ': /* sign space */
-			spad = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case '-':
-			ljust = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case '#':
-			altfm = 1;
-			fmt++; fmtLen--;
- 			goto next_fmt;
-
-		case '.':
-			inprec = 1;
-			fmt++; fmtLen--;
- 			goto next_fmt;
-			break;
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		case '8':
-		case '9':
-			accum = 0;
-			while (isdigit((unsigned)*fmt) && (fmtLen > 0)) {
-				accum = (accum * 10) + (*fmt - '0');
-				fmt++;  fmtLen--;
-			}
-			if (inprec) {
-				haveprec = 1;
-				prec = accum;
-			} else {
-				width = accum;
-			}
-			goto next_fmt;
-		case '*':
-			/* suck up the next item as an integer */
-			fmt++;  fmtLen--;
-			objc--;
-			if (objc <= 0) {
-				goto not_enough_args;
-			}
-			if (Jim_GetWide(interp,objv[0],&wideValue)== JIM_ERR) {
-				Jim_FreeNewObj(interp, resObjPtr);
-				return NULL;
-			}
-			if (inprec) {
-				haveprec = 1;
-				prec = wideValue;
-				if (prec < 0) {
-					/* man 3 printf says */
-					/* if prec is negative, it is zero */
-					prec = 0;
-				}
-			} else {
-			width = wideValue;
-			if (width < 0) {
-				ljust = 1;
-				width = -width;
-			}
-			}
-			objv++;
-			goto next_fmt;
-			break;
-		}
-
-
-		if (*fmt != '%') {
-            if (objc == 0) {
-			not_enough_args:
-                Jim_FreeNewObj(interp, resObjPtr);
-                Jim_SetResultString(interp,
-									"not enough arguments for all format specifiers", -1);
-                return NULL;
-            } else {
-                objc--;
-            }
-        }
-
-		/*
-		 * Create the formatter
-		 * cause we cheat and use sprintf()
-		 */
-		cp = fmt_str;
-		*cp++ = '%';
-		if (altfm) {
-			*cp++ = '#';
-		}
-		if (forceplus) {
-			*cp++ = '+';
-		} else if (spad) {
-			/* PLUS overrides */
-			*cp++ = ' ';
-		}
-		if (ljust) {
-			*cp++ = '-';
-		}
-		if (zpad) {
-			*cp++ = '0';
-		}
-		if (width > 0) {
-			sprintf(cp, "%d", width);
-			/* skip ahead */
-			cp = strchr(cp,0);
-		}
-		/* did we find a period? */
-		if (inprec) {
-			/* then add it */
-			*cp++ = '.';
-			/* did something occur after the period? */
-			if (haveprec) {
-				sprintf(cp, "%d", prec);
-			}
-			cp = strchr(cp,0);
-		}
-		*cp = 0;
-
-		/* here we do the work */
-		/* actually - we make sprintf() do it for us */
-        switch (*fmt) {
-        case 's':
-			*cp++ = 's';
-			*cp   = 0;
-			/* BUG: we do not handled embeded NULLs */
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, Jim_GetString(objv[0], NULL));
-            break;
-        case 'c':
-			*cp++ = 'c';
-			*cp   = 0;
-            if (Jim_GetWide(interp, objv[0], &wideValue) == JIM_ERR) {
-                Jim_FreeNewObj(interp, resObjPtr);
-                return NULL;
-            }
-            c = (char) wideValue;
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, c);
-            break;
-		case 'f':
-		case 'F':
-		case 'g':
-		case 'G':
-		case 'e':
-		case 'E':
-			*cp++ = *fmt;
-			*cp   = 0;
-			if (Jim_GetDouble(interp, objv[0], &doubleValue) == JIM_ERR) {
-				Jim_FreeNewObj(interp, resObjPtr);
-				return NULL;
-			}
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, doubleValue);
-			break;
-        case 'b':
-        case 'd':
-        case 'o':
-		case 'i':
-		case 'u':
-		case 'x':
-		case 'X':
-			/* jim widevaluse are 64bit */
-			if (sizeof(jim_wide) == sizeof(long long)) {
-				*cp++ = 'l';
-				*cp++ = 'l';
-			} else {
-				*cp++ = 'l';
-			}
-			*cp++ = *fmt;
-			*cp   = 0;
-            if (Jim_GetWide(interp, objv[0], &wideValue) == JIM_ERR) {
-                Jim_FreeNewObj(interp, resObjPtr);
-                return NULL;
-            }
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, wideValue);
-            break;
-        case '%':
-			sprintf_buf[0] = '%';
-			sprintf_buf[1] = 0;
-			objv--; /* undo the objv++ below */
-            break;
-        default:
-            spec[0] = *fmt; spec[1] = '\0';
-            Jim_FreeNewObj(interp, resObjPtr);
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    "bad field specifier \"",  spec, "\"", NULL);
-            return NULL;
-        }
-		/* force terminate */
-#if 0
-		printf("FMT was: %s\n", fmt_str);
-		printf("RES was: |%s|\n", sprintf_buf);
-#endif
-
-		sprintf_buf[ JIM_MAX_FMT - 1] = 0;
-		Jim_AppendString(interp, resObjPtr, sprintf_buf, strlen(sprintf_buf));
-		/* next obj */
-		objv++;
-        fmt++;
-        fmtLen--;
-    }
-    return resObjPtr;
-}
-
-Jim_Obj *Jim_FormatString(Jim_Interp *interp, Jim_Obj *fmtObjPtr,
-        int objc, Jim_Obj *const *objv)
-{
-	char *sprintf_buf = malloc(JIM_MAX_FMT);
-	Jim_Obj *t = Jim_FormatString_Inner(interp, fmtObjPtr, objc, objv, sprintf_buf);
-	free(sprintf_buf);
-	return t;
-}
-
-/* -----------------------------------------------------------------------------
- * Compared String Object
- * ---------------------------------------------------------------------------*/
-
-/* This is strange object that allows to compare a C literal string
- * with a Jim object in very short time if the same comparison is done
- * multiple times. For example every time the [if] command is executed,
- * Jim has to check if a given argument is "else". This comparions if
- * the code has no errors are true most of the times, so we can cache
- * inside the object the pointer of the string of the last matching
- * comparison. Because most C compilers perform literal sharing,
- * so that: char *x = "foo", char *y = "foo", will lead to x == y,
- * this works pretty well even if comparisons are at different places
- * inside the C code. */
-
-static Jim_ObjType comparedStringObjType = {
-    "compared-string",
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* The only way this object is exposed to the API is via the following
- * function. Returns true if the string and the object string repr.
- * are the same, otherwise zero is returned.
- *
- * Note: this isn't binary safe, but it hardly needs to be.*/
-int Jim_CompareStringImmediate(Jim_Interp *interp, Jim_Obj *objPtr,
-        const char *str)
-{
-    if (objPtr->typePtr == &comparedStringObjType &&
-        objPtr->internalRep.ptr == str)
-        return 1;
-    else {
-        const char *objStr = Jim_GetString(objPtr, NULL);
-        if (strcmp(str, objStr) != 0) return 0;
-        if (objPtr->typePtr != &comparedStringObjType) {
-            Jim_FreeIntRep(interp, objPtr);
-            objPtr->typePtr = &comparedStringObjType;
-        }
-        objPtr->internalRep.ptr = (char*)str; /*ATTENTION: const cast */
-        return 1;
-    }
-}
-
-int qsortCompareStringPointers(const void *a, const void *b)
-{
-    char * const *sa = (char * const *)a;
-    char * const *sb = (char * const *)b;
-    return strcmp(*sa, *sb);
-}
-
-int Jim_GetEnum(Jim_Interp *interp, Jim_Obj *objPtr,
-        const char * const *tablePtr, int *indexPtr, const char *name, int flags)
-{
-    const char * const *entryPtr = NULL;
-    char **tablePtrSorted;
-    int i, count = 0;
-
-    *indexPtr = -1;
-    for (entryPtr = tablePtr, i = 0; *entryPtr != NULL; entryPtr++, i++) {
-        if (Jim_CompareStringImmediate(interp, objPtr, *entryPtr)) {
-            *indexPtr = i;
-            return JIM_OK;
-        }
-        count++; /* If nothing matches, this will reach the len of tablePtr */
-    }
-    if (flags & JIM_ERRMSG) {
-        if (name == NULL)
-            name = "option";
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "bad ", name, " \"", Jim_GetString(objPtr, NULL), "\": must be one of ",
-            NULL);
-        tablePtrSorted = Jim_Alloc(sizeof(char*)*count);
-        memcpy(tablePtrSorted, tablePtr, sizeof(char*)*count);
-        qsort(tablePtrSorted, count, sizeof(char*), qsortCompareStringPointers);
-        for (i = 0; i < count; i++) {
-            if (i + 1 == count && count > 1)
-                Jim_AppendString(interp, Jim_GetResult(interp), "or ", -1);
-            Jim_AppendString(interp, Jim_GetResult(interp),
-                    tablePtrSorted[i], -1);
-            if (i + 1 != count)
-                Jim_AppendString(interp, Jim_GetResult(interp), ", ", -1);
-        }
-        Jim_Free(tablePtrSorted);
-    }
-    return JIM_ERR;
-}
-
-int Jim_GetNvp(Jim_Interp *interp,
-			   Jim_Obj *objPtr,
-			   const Jim_Nvp *nvp_table,
-			   const Jim_Nvp ** result)
-{
-	Jim_Nvp *n;
-	int e;
-
-	e = Jim_Nvp_name2value_obj(interp, nvp_table, objPtr, &n);
-	if (e == JIM_ERR) {
-		return e;
-	}
-
-	/* Success? found? */
-	if (n->name) {
-		/* remove const */
-		*result = (Jim_Nvp *)n;
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-/* -----------------------------------------------------------------------------
- * Source Object
- *
- * This object is just a string from the language point of view, but
- * in the internal representation it contains the filename and line number
- * where this given token was read. This information is used by
- * Jim_EvalObj() if the object passed happens to be of type "source".
- *
- * This allows to propagate the information about line numbers and file
- * names and give error messages with absolute line numbers.
- *
- * Note that this object uses shared strings for filenames, and the
- * pointer to the filename together with the line number is taken into
- * the space for the "inline" internal represenation of the Jim_Object,
- * so there is almost memory zero-overhead.
- *
- * Also the object will be converted to something else if the given
- * token it represents in the source file is not something to be
- * evaluated (not a script), and will be specialized in some other way,
- * so the time overhead is alzo null.
- * ---------------------------------------------------------------------------*/
-
-static void FreeSourceInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupSourceInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-
-static Jim_ObjType sourceObjType = {
-    "source",
-    FreeSourceInternalRep,
-    DupSourceInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-void FreeSourceInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_ReleaseSharedString(interp,
-            objPtr->internalRep.sourceValue.fileName);
-}
-
-void DupSourceInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    dupPtr->internalRep.sourceValue.fileName =
-        Jim_GetSharedString(interp,
-                srcPtr->internalRep.sourceValue.fileName);
-    dupPtr->internalRep.sourceValue.lineNumber =
-        dupPtr->internalRep.sourceValue.lineNumber;
-    dupPtr->typePtr = &sourceObjType;
-}
-
-static void JimSetSourceInfo(Jim_Interp *interp, Jim_Obj *objPtr,
-        const char *fileName, int lineNumber)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,"JimSetSourceInfo called with shared object");
-    if (objPtr->typePtr != NULL)
-        Jim_Panic(interp,"JimSetSourceInfo called with typePtr != NULL");
-    objPtr->internalRep.sourceValue.fileName =
-        Jim_GetSharedString(interp, fileName);
-    objPtr->internalRep.sourceValue.lineNumber = lineNumber;
-    objPtr->typePtr = &sourceObjType;
-}
-
-/* -----------------------------------------------------------------------------
- * Script Object
- * ---------------------------------------------------------------------------*/
-
-#define JIM_CMDSTRUCT_EXPAND -1
-
-static void FreeScriptInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupScriptInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static int SetScriptFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType scriptObjType = {
-    "script",
-    FreeScriptInternalRep,
-    DupScriptInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* The ScriptToken structure represents every token into a scriptObj.
- * Every token contains an associated Jim_Obj that can be specialized
- * by commands operating on it. */
-typedef struct ScriptToken {
-    int type;
-    Jim_Obj *objPtr;
-    int linenr;
-} ScriptToken;
-
-/* This is the script object internal representation. An array of
- * ScriptToken structures, with an associated command structure array.
- * The command structure is a pre-computed representation of the
- * command length and arguments structure as a simple liner array
- * of integers.
- *
- * For example the script:
- *
- * puts hello
- * set $i $x$y [foo]BAR
- *
- * will produce a ScriptObj with the following Tokens:
- *
- * ESC puts
- * SEP
- * ESC hello
- * EOL
- * ESC set
- * EOL
- * VAR i
- * SEP
- * VAR x
- * VAR y
- * SEP
- * CMD foo
- * ESC BAR
- * EOL
- *
- * This is a description of the tokens, separators, and of lines.
- * The command structure instead represents the number of arguments
- * of every command, followed by the tokens of which every argument
- * is composed. So for the example script, the cmdstruct array will
- * contain:
- *
- * 2 1 1 4 1 1 2 2
- *
- * Because "puts hello" has two args (2), composed of single tokens (1 1)
- * While "set $i $x$y [foo]BAR" has four (4) args, the first two
- * composed of single tokens (1 1) and the last two of double tokens
- * (2 2).
- *
- * The precomputation of the command structure makes Jim_Eval() faster,
- * and simpler because there aren't dynamic lengths / allocations.
- *
- * -- {expand} handling --
- *
- * Expand is handled in a special way. When a command
- * contains at least an argument with the {expand} prefix,
- * the command structure presents a -1 before the integer
- * describing the number of arguments. This is used in order
- * to send the command exection to a different path in case
- * of {expand} and guarantee a fast path for the more common
- * case. Also, the integers describing the number of tokens
- * are expressed with negative sign, to allow for fast check
- * of what's an {expand}-prefixed argument and what not.
- *
- * For example the command:
- *
- * list {expand}{1 2}
- *
- * Will produce the following cmdstruct array:
- *
- * -1 2 1 -2
- *
- * -- the substFlags field of the structure --
- *
- * The scriptObj structure is used to represent both "script" objects
- * and "subst" objects. In the second case, the cmdStruct related
- * fields are not used at all, but there is an additional field used
- * that is 'substFlags': this represents the flags used to turn
- * the string into the intenral representation used to perform the
- * substitution. If this flags are not what the application requires
- * the scriptObj is created again. For example the script:
- *
- * subst -nocommands $string
- * subst -novariables $string
- *
- * Will recreate the internal representation of the $string object
- * two times.
- */
-typedef struct ScriptObj {
-    int len; /* Length as number of tokens. */
-    int commands; /* number of top-level commands in script. */
-    ScriptToken *token; /* Tokens array. */
-    int *cmdStruct; /* commands structure */
-    int csLen; /* length of the cmdStruct array. */
-    int substFlags; /* flags used for the compilation of "subst" objects */
-    int inUse; /* Used to share a ScriptObj. Currently
-              only used by Jim_EvalObj() as protection against
-              shimmering of the currently evaluated object. */
-    char *fileName;
-} ScriptObj;
-
-void FreeScriptInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int i;
-    struct ScriptObj *script = (void*) objPtr->internalRep.ptr;
-
-    if (!script)
-	    return;
-
-    script->inUse--;
-    if (script->inUse != 0) return;
-    for (i = 0; i < script->len; i++) {
-        if (script->token[i].objPtr != NULL)
-            Jim_DecrRefCount(interp, script->token[i].objPtr);
-    }
-    Jim_Free(script->token);
-    Jim_Free(script->cmdStruct);
-    Jim_Free(script->fileName);
-    Jim_Free(script);
-}
-
-void DupScriptInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(srcPtr);
-
-    /* Just returns an simple string. */
-    dupPtr->typePtr = NULL;
-}
-
-/* Add a new token to the internal repr of a script object */
-static void ScriptObjAddToken(Jim_Interp *interp, struct ScriptObj *script,
-        char *strtoken, int len, int type, char *filename, int linenr)
-{
-    int prevtype;
-    struct ScriptToken *token;
-
-    prevtype = (script->len == 0) ? JIM_TT_EOL : \
-        script->token[script->len-1].type;
-    /* Skip tokens without meaning, like words separators
-     * following a word separator or an end of command and
-     * so on. */
-    if (prevtype == JIM_TT_EOL) {
-        if (type == JIM_TT_EOL || type == JIM_TT_SEP) {
-            Jim_Free(strtoken);
-            return;
-        }
-    } else if (prevtype == JIM_TT_SEP) {
-        if (type == JIM_TT_SEP) {
-            Jim_Free(strtoken);
-            return;
-        } else if (type == JIM_TT_EOL) {
-            /* If an EOL is following by a SEP, drop the previous
-             * separator. */
-            script->len--;
-            Jim_DecrRefCount(interp, script->token[script->len].objPtr);
-        }
-    } else if (prevtype != JIM_TT_EOL && prevtype != JIM_TT_SEP &&
-            type == JIM_TT_ESC && len == 0)
-    {
-        /* Don't add empty tokens used in interpolation */
-        Jim_Free(strtoken);
-        return;
-    }
-    /* Make space for a new istruction */
-    script->len++;
-    script->token = Jim_Realloc(script->token,
-            sizeof(ScriptToken)*script->len);
-    /* Initialize the new token */
-    token = script->token + (script->len-1);
-    token->type = type;
-    /* Every object is intially as a string, but the
-     * internal type may be specialized during execution of the
-     * script. */
-    token->objPtr = Jim_NewStringObjNoAlloc(interp, strtoken, len);
-    /* To add source info to SEP and EOL tokens is useless because
-     * they will never by called as arguments of Jim_EvalObj(). */
-    if (filename && type != JIM_TT_SEP && type != JIM_TT_EOL)
-        JimSetSourceInfo(interp, token->objPtr, filename, linenr);
-    Jim_IncrRefCount(token->objPtr);
-    token->linenr = linenr;
-}
-
-/* Add an integer into the command structure field of the script object. */
-static void ScriptObjAddInt(struct ScriptObj *script, int val)
-{
-    script->csLen++;
-    script->cmdStruct = Jim_Realloc(script->cmdStruct,
-                    sizeof(int)*script->csLen);
-    script->cmdStruct[script->csLen-1] = val;
-}
-
-/* Search a Jim_Obj contained in 'script' with the same stinrg repr.
- * of objPtr. Search nested script objects recursively. */
-static Jim_Obj *ScriptSearchLiteral(Jim_Interp *interp, ScriptObj *script,
-        ScriptObj *scriptBarrier, Jim_Obj *objPtr)
-{
-    int i;
-
-    for (i = 0; i < script->len; i++) {
-        if (script->token[i].objPtr != objPtr &&
-            Jim_StringEqObj(script->token[i].objPtr, objPtr, 0)) {
-            return script->token[i].objPtr;
-        }
-        /* Enter recursively on scripts only if the object
-         * is not the same as the one we are searching for
-         * shared occurrences. */
-        if (script->token[i].objPtr->typePtr == &scriptObjType &&
-            script->token[i].objPtr != objPtr) {
-            Jim_Obj *foundObjPtr;
-
-            ScriptObj *subScript =
-                script->token[i].objPtr->internalRep.ptr;
-            /* Don't recursively enter the script we are trying
-             * to make shared to avoid circular references. */
-            if (subScript == scriptBarrier) continue;
-            if (subScript != script) {
-                foundObjPtr =
-                    ScriptSearchLiteral(interp, subScript,
-                            scriptBarrier, objPtr);
-                if (foundObjPtr != NULL)
-                    return foundObjPtr;
-            }
-        }
-    }
-    return NULL;
-}
-
-/* Share literals of a script recursively sharing sub-scripts literals. */
-static void ScriptShareLiterals(Jim_Interp *interp, ScriptObj *script,
-        ScriptObj *topLevelScript)
-{
-    int i, j;
-
-    return;
-    /* Try to share with toplevel object. */
-    if (topLevelScript != NULL) {
-        for (i = 0; i < script->len; i++) {
-            Jim_Obj *foundObjPtr;
-            char *str = script->token[i].objPtr->bytes;
-
-            if (script->token[i].objPtr->refCount != 1) continue;
-            if (script->token[i].objPtr->typePtr == &scriptObjType) continue;
-            if (strchr(str, ' ') || strchr(str, '\n')) continue;
-            foundObjPtr = ScriptSearchLiteral(interp,
-                    topLevelScript,
-                    script, /* barrier */
-                    script->token[i].objPtr);
-            if (foundObjPtr != NULL) {
-                Jim_IncrRefCount(foundObjPtr);
-                Jim_DecrRefCount(interp,
-                        script->token[i].objPtr);
-                script->token[i].objPtr = foundObjPtr;
-            }
-        }
-    }
-    /* Try to share locally */
-    for (i = 0; i < script->len; i++) {
-        char *str = script->token[i].objPtr->bytes;
-
-        if (script->token[i].objPtr->refCount != 1) continue;
-        if (strchr(str, ' ') || strchr(str, '\n')) continue;
-        for (j = 0; j < script->len; j++) {
-            if (script->token[i].objPtr !=
-                    script->token[j].objPtr &&
-                Jim_StringEqObj(script->token[i].objPtr,
-                            script->token[j].objPtr, 0))
-            {
-                Jim_IncrRefCount(script->token[j].objPtr);
-                Jim_DecrRefCount(interp,
-                        script->token[i].objPtr);
-                script->token[i].objPtr =
-                    script->token[j].objPtr;
-            }
-        }
-    }
-}
-
-/* This method takes the string representation of an object
- * as a Tcl script, and generates the pre-parsed internal representation
- * of the script. */
-int SetScriptFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    int scriptTextLen;
-    const char *scriptText = Jim_GetString(objPtr, &scriptTextLen);
-    struct JimParserCtx parser;
-    struct ScriptObj *script = Jim_Alloc(sizeof(*script));
-    ScriptToken *token;
-    int args, tokens, start, end, i;
-    int initialLineNumber;
-    int propagateSourceInfo = 0;
-
-    script->len = 0;
-    script->csLen = 0;
-    script->commands = 0;
-    script->token = NULL;
-    script->cmdStruct = NULL;
-    script->inUse = 1;
-    /* Try to get information about filename / line number */
-    if (objPtr->typePtr == &sourceObjType) {
-        script->fileName =
-            Jim_StrDup(objPtr->internalRep.sourceValue.fileName);
-        initialLineNumber = objPtr->internalRep.sourceValue.lineNumber;
-        propagateSourceInfo = 1;
-    } else {
-        script->fileName = Jim_StrDup("");
-        initialLineNumber = 1;
-    }
-
-    JimParserInit(&parser, scriptText, scriptTextLen, initialLineNumber);
-    while (!JimParserEof(&parser)) {
-        char *token_t;
-        int len, type, linenr;
-
-        JimParseScript(&parser);
-        token_t = JimParserGetToken(&parser, &len, &type, &linenr);
-        ScriptObjAddToken(interp, script, token_t, len, type,
-                propagateSourceInfo ? script->fileName : NULL,
-                linenr);
-    }
-    token = script->token;
-
-    /* Compute the command structure array
-     * (see the ScriptObj struct definition for more info) */
-    start = 0; /* Current command start token index */
-    end = -1; /* Current command end token index */
-    while (1) {
-        int expand = 0; /* expand flag. set to 1 on {expand} form. */
-        int interpolation = 0; /* set to 1 if there is at least one
-                      argument of the command obtained via
-                      interpolation of more tokens. */
-        /* Search for the end of command, while
-         * count the number of args. */
-        start = ++end;
-        if (start >= script->len) break;
-        args = 1; /* Number of args in current command */
-        while (token[end].type != JIM_TT_EOL) {
-            if (end == 0 || token[end-1].type == JIM_TT_SEP ||
-                    token[end-1].type == JIM_TT_EOL)
-            {
-                if (token[end].type == JIM_TT_STR &&
-                    token[end + 1].type != JIM_TT_SEP &&
-                    token[end + 1].type != JIM_TT_EOL &&
-                    (!strcmp(token[end].objPtr->bytes, "expand") ||
-                     !strcmp(token[end].objPtr->bytes, "*")))
-                    expand++;
-            }
-            if (token[end].type == JIM_TT_SEP)
-                args++;
-            end++;
-        }
-        interpolation = !((end-start + 1) == args*2);
-        /* Add the 'number of arguments' info into cmdstruct.
-         * Negative value if there is list expansion involved. */
-        if (expand)
-            ScriptObjAddInt(script, -1);
-        ScriptObjAddInt(script, args);
-        /* Now add info about the number of tokens. */
-        tokens = 0; /* Number of tokens in current argument. */
-        expand = 0;
-        for (i = start; i <= end; i++) {
-            if (token[i].type == JIM_TT_SEP ||
-                token[i].type == JIM_TT_EOL)
-            {
-                if (tokens == 1 && expand)
-                    expand = 0;
-                ScriptObjAddInt(script,
-                        expand ? -tokens : tokens);
-
-                expand = 0;
-                tokens = 0;
-                continue;
-            } else if (tokens == 0 && token[i].type == JIM_TT_STR &&
-                   (!strcmp(token[i].objPtr->bytes, "expand") ||
-                    !strcmp(token[i].objPtr->bytes, "*")))
-            {
-                expand++;
-            }
-            tokens++;
-        }
-    }
-    /* Perform literal sharing, but only for objects that appear
-     * to be scripts written as literals inside the source code,
-     * and not computed at runtime. Literal sharing is a costly
-     * operation that should be done only against objects that
-     * are likely to require compilation only the first time, and
-     * then are executed multiple times. */
-    if (propagateSourceInfo && interp->framePtr->procBodyObjPtr) {
-        Jim_Obj *bodyObjPtr = interp->framePtr->procBodyObjPtr;
-        if (bodyObjPtr->typePtr == &scriptObjType) {
-            ScriptObj *bodyScript =
-                bodyObjPtr->internalRep.ptr;
-            ScriptShareLiterals(interp, script, bodyScript);
-        }
-    } else if (propagateSourceInfo) {
-        ScriptShareLiterals(interp, script, NULL);
-    }
-    /* Free the old internal rep and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    Jim_SetIntRepPtr(objPtr, script);
-    objPtr->typePtr = &scriptObjType;
-    return JIM_OK;
-}
-
-ScriptObj *Jim_GetScript(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    if (objPtr->typePtr != &scriptObjType) {
-        SetScriptFromAny(interp, objPtr);
-    }
-    return (ScriptObj*) Jim_GetIntRepPtr(objPtr);
-}
-
-/* -----------------------------------------------------------------------------
- * Commands
- * ---------------------------------------------------------------------------*/
-
-/* Commands HashTable Type.
- *
- * Keys are dynamic allocated strings, Values are Jim_Cmd structures. */
-static void Jim_CommandsHT_ValDestructor(void *interp, void *val)
-{
-    Jim_Cmd *cmdPtr = (void*) val;
-
-    if (cmdPtr->cmdProc == NULL) {
-        Jim_DecrRefCount(interp, cmdPtr->argListObjPtr);
-        Jim_DecrRefCount(interp, cmdPtr->bodyObjPtr);
-        if (cmdPtr->staticVars) {
-            Jim_FreeHashTable(cmdPtr->staticVars);
-            Jim_Free(cmdPtr->staticVars);
-        }
-    } else if (cmdPtr->delProc != NULL) {
-            /* If it was a C coded command, call the delProc if any */
-            cmdPtr->delProc(interp, cmdPtr->privData);
-    }
-    Jim_Free(val);
-}
-
-static Jim_HashTableType JimCommandsHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,        /* key dup */
-    NULL,                    /* val dup */
-    JimStringCopyHTKeyCompare,        /* key compare */
-    JimStringCopyHTKeyDestructor,        /* key destructor */
-    Jim_CommandsHT_ValDestructor        /* val destructor */
-};
-
-/* ------------------------- Commands related functions --------------------- */
-
-int Jim_CreateCommand(Jim_Interp *interp, const char *cmdName,
-        Jim_CmdProc cmdProc, void *privData, Jim_DelCmdProc delProc)
-{
-    Jim_HashEntry *he;
-    Jim_Cmd *cmdPtr;
-
-    he = Jim_FindHashEntry(&interp->commands, cmdName);
-    if (he == NULL) { /* New command to create */
-        cmdPtr = Jim_Alloc(sizeof(*cmdPtr));
-        Jim_AddHashEntry(&interp->commands, cmdName, cmdPtr);
-    } else {
-        Jim_InterpIncrProcEpoch(interp);
-        /* Free the arglist/body objects if it was a Tcl procedure */
-        cmdPtr = he->val;
-        if (cmdPtr->cmdProc == NULL) {
-            Jim_DecrRefCount(interp, cmdPtr->argListObjPtr);
-            Jim_DecrRefCount(interp, cmdPtr->bodyObjPtr);
-            if (cmdPtr->staticVars) {
-                Jim_FreeHashTable(cmdPtr->staticVars);
-                Jim_Free(cmdPtr->staticVars);
-            }
-            cmdPtr->staticVars = NULL;
-        } else if (cmdPtr->delProc != NULL) {
-            /* If it was a C coded command, call the delProc if any */
-            cmdPtr->delProc(interp, cmdPtr->privData);
-        }
-    }
-
-    /* Store the new details for this proc */
-    cmdPtr->delProc = delProc;
-    cmdPtr->cmdProc = cmdProc;
-    cmdPtr->privData = privData;
-
-    /* There is no need to increment the 'proc epoch' because
-     * creation of a new procedure can never affect existing
-     * cached commands. We don't do negative caching. */
-    return JIM_OK;
-}
-
-int Jim_CreateProcedure(Jim_Interp *interp, const char *cmdName,
-        Jim_Obj *argListObjPtr, Jim_Obj *staticsListObjPtr, Jim_Obj *bodyObjPtr,
-        int arityMin, int arityMax)
-{
-    Jim_Cmd *cmdPtr;
-
-    cmdPtr = Jim_Alloc(sizeof(*cmdPtr));
-    cmdPtr->cmdProc = NULL; /* Not a C coded command */
-    cmdPtr->argListObjPtr = argListObjPtr;
-    cmdPtr->bodyObjPtr = bodyObjPtr;
-    Jim_IncrRefCount(argListObjPtr);
-    Jim_IncrRefCount(bodyObjPtr);
-    cmdPtr->arityMin = arityMin;
-    cmdPtr->arityMax = arityMax;
-    cmdPtr->staticVars = NULL;
-
-    /* Create the statics hash table. */
-    if (staticsListObjPtr) {
-        int len, i;
-
-        Jim_ListLength(interp, staticsListObjPtr, &len);
-        if (len != 0) {
-            cmdPtr->staticVars = Jim_Alloc(sizeof(Jim_HashTable));
-            Jim_InitHashTable(cmdPtr->staticVars, getJimVariablesHashTableType(),
-                    interp);
-            for (i = 0; i < len; i++) {
-                Jim_Obj *objPtr=NULL, *initObjPtr=NULL, *nameObjPtr=NULL;
-                Jim_Var *varPtr;
-                int subLen;
-
-                Jim_ListIndex(interp, staticsListObjPtr, i, &objPtr, JIM_NONE);
-                /* Check if it's composed of two elements. */
-                Jim_ListLength(interp, objPtr, &subLen);
-                if (subLen == 1 || subLen == 2) {
-                    /* Try to get the variable value from the current
-                     * environment. */
-                    Jim_ListIndex(interp, objPtr, 0, &nameObjPtr, JIM_NONE);
-                    if (subLen == 1) {
-                        initObjPtr = Jim_GetVariable(interp, nameObjPtr,
-                                JIM_NONE);
-                        if (initObjPtr == NULL) {
-                            Jim_SetResult(interp,
-                                    Jim_NewEmptyStringObj(interp));
-                            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                                "variable for initialization of static \"",
-                                Jim_GetString(nameObjPtr, NULL),
-                                "\" not found in the local context",
-                                NULL);
-                            goto err;
-                        }
-                    } else {
-                        Jim_ListIndex(interp, objPtr, 1, &initObjPtr, JIM_NONE);
-                    }
-                    varPtr = Jim_Alloc(sizeof(*varPtr));
-                    varPtr->objPtr = initObjPtr;
-                    Jim_IncrRefCount(initObjPtr);
-                    varPtr->linkFramePtr = NULL;
-                    if (Jim_AddHashEntry(cmdPtr->staticVars,
-                            Jim_GetString(nameObjPtr, NULL),
-                            varPtr) != JIM_OK)
-                    {
-                        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-                        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                            "static variable name \"",
-                            Jim_GetString(objPtr, NULL), "\"",
-                            " duplicated in statics list", NULL);
-                        Jim_DecrRefCount(interp, initObjPtr);
-                        Jim_Free(varPtr);
-                        goto err;
-                    }
-                } else {
-                    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-                    Jim_AppendStrings(interp, Jim_GetResult(interp),
-                        "too many fields in static specifier \"",
-                        objPtr, "\"", NULL);
-                    goto err;
-                }
-            }
-        }
-    }
-
-    /* Add the new command */
-
-    /* it may already exist, so we try to delete the old one */
-    if (Jim_DeleteHashEntry(&interp->commands, cmdName) != JIM_ERR) {
-        /* There was an old procedure with the same name, this requires
-         * a 'proc epoch' update. */
-        Jim_InterpIncrProcEpoch(interp);
-    }
-    /* If a procedure with the same name didn't existed there is no need
-     * to increment the 'proc epoch' because creation of a new procedure
-     * can never affect existing cached commands. We don't do
-     * negative caching. */
-    Jim_AddHashEntry(&interp->commands, cmdName, cmdPtr);
-    return JIM_OK;
-
-err:
-    Jim_FreeHashTable(cmdPtr->staticVars);
-    Jim_Free(cmdPtr->staticVars);
-    Jim_DecrRefCount(interp, argListObjPtr);
-    Jim_DecrRefCount(interp, bodyObjPtr);
-    Jim_Free(cmdPtr);
-    return JIM_ERR;
-}
-
-int Jim_DeleteCommand(Jim_Interp *interp, const char *cmdName)
-{
-    if (Jim_DeleteHashEntry(&interp->commands, cmdName) == JIM_ERR)
-        return JIM_ERR;
-    Jim_InterpIncrProcEpoch(interp);
-    return JIM_OK;
-}
-
-int Jim_RenameCommand(Jim_Interp *interp, const char *oldName,
-        const char *newName)
-{
-    Jim_Cmd *cmdPtr;
-    Jim_HashEntry *he;
-    Jim_Cmd *copyCmdPtr;
-
-    if (newName[0] == '\0') /* Delete! */
-        return Jim_DeleteCommand(interp, oldName);
-    /* Rename */
-    he = Jim_FindHashEntry(&interp->commands, oldName);
-    if (he == NULL)
-        return JIM_ERR; /* Invalid command name */
-    cmdPtr = he->val;
-    copyCmdPtr = Jim_Alloc(sizeof(Jim_Cmd));
-    *copyCmdPtr = *cmdPtr;
-    /* In order to avoid that a procedure will get arglist/body/statics
-     * freed by the hash table methods, fake a C-coded command
-     * setting cmdPtr->cmdProc as not NULL */
-    cmdPtr->cmdProc = (void*)1;
-    /* Also make sure delProc is NULL. */
-    cmdPtr->delProc = NULL;
-    /* Destroy the old command, and make sure the new is freed
-     * as well. */
-    Jim_DeleteHashEntry(&interp->commands, oldName);
-    Jim_DeleteHashEntry(&interp->commands, newName);
-    /* Now the new command. We are sure it can't fail because
-     * the target name was already freed. */
-    Jim_AddHashEntry(&interp->commands, newName, copyCmdPtr);
-    /* Increment the epoch */
-    Jim_InterpIncrProcEpoch(interp);
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Command object
- * ---------------------------------------------------------------------------*/
-
-static int SetCommandFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType commandObjType = {
-    "command",
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-int SetCommandFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_HashEntry *he;
-    const char *cmdName;
-
-    /* Get the string representation */
-    cmdName = Jim_GetString(objPtr, NULL);
-    /* Lookup this name into the commands hash table */
-    he = Jim_FindHashEntry(&interp->commands, cmdName);
-    if (he == NULL)
-        return JIM_ERR;
-
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &commandObjType;
-    objPtr->internalRep.cmdValue.procEpoch = interp->procEpoch;
-    objPtr->internalRep.cmdValue.cmdPtr = (void*)he->val;
-    return JIM_OK;
-}
-
-/* This function returns the command structure for the command name
- * stored in objPtr. It tries to specialize the objPtr to contain
- * a cached info instead to perform the lookup into the hash table
- * every time. The information cached may not be uptodate, in such
- * a case the lookup is performed and the cache updated. */
-Jim_Cmd *Jim_GetCommand(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
-{
-    if ((objPtr->typePtr != &commandObjType ||
-        objPtr->internalRep.cmdValue.procEpoch != interp->procEpoch) &&
-        SetCommandFromAny(interp, objPtr) == JIM_ERR) {
-        if (flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "invalid command name \"", objPtr->bytes, "\"",
-                NULL);
-        }
-        return NULL;
-    }
-    return objPtr->internalRep.cmdValue.cmdPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * Variables
- * ---------------------------------------------------------------------------*/
-
-/* Variables HashTable Type.
- *
- * Keys are dynamic allocated strings, Values are Jim_Var structures. */
-static void JimVariablesHTValDestructor(void *interp, void *val)
-{
-    Jim_Var *varPtr = (void*) val;
-
-    Jim_DecrRefCount(interp, varPtr->objPtr);
-    Jim_Free(val);
-}
-
-static Jim_HashTableType JimVariablesHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,              /* key dup */
-    NULL,                               /* val dup */
-    JimStringCopyHTKeyCompare,        /* key compare */
-    JimStringCopyHTKeyDestructor,     /* key destructor */
-    JimVariablesHTValDestructor       /* val destructor */
-};
-
-static Jim_HashTableType *getJimVariablesHashTableType(void)
-{
-	return &JimVariablesHashTableType;
-}
-
-/* -----------------------------------------------------------------------------
- * Variable object
- * ---------------------------------------------------------------------------*/
-
-#define JIM_DICT_SUGAR 100 /* Only returned by SetVariableFromAny() */
-
-static int SetVariableFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType variableObjType = {
-    "variable",
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* Return true if the string "str" looks like syntax sugar for [dict]. I.e.
- * is in the form "varname(key)". */
-static int Jim_NameIsDictSugar(const char *str, int len)
-{
-    if (len == -1)
-        len = strlen(str);
-    if (len && str[len-1] == ')' && strchr(str, '(') != NULL)
-        return 1;
-    return 0;
-}
-
-/* This method should be called only by the variable API.
- * It returns JIM_OK on success (variable already exists),
- * JIM_ERR if it does not exists, JIM_DICT_GLUE if it's not
- * a variable name, but syntax glue for [dict] i.e. the last
- * character is ')' */
-int SetVariableFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    Jim_HashEntry *he;
-    const char *varName;
-    int len;
-
-    /* Check if the object is already an uptodate variable */
-    if (objPtr->typePtr == &variableObjType &&
-        objPtr->internalRep.varValue.callFrameId == interp->framePtr->id)
-        return JIM_OK; /* nothing to do */
-    /* Get the string representation */
-    varName = Jim_GetString(objPtr, &len);
-    /* Make sure it's not syntax glue to get/set dict. */
-    if (Jim_NameIsDictSugar(varName, len))
-            return JIM_DICT_SUGAR;
-    if (varName[0] == ':' && varName[1] == ':') {
-        he = Jim_FindHashEntry(&interp->topFramePtr->vars, varName + 2);
-        if (he == NULL) {
-            return JIM_ERR;
-        }
-    }
-    else {
-        /* Lookup this name into the variables hash table */
-        he = Jim_FindHashEntry(&interp->framePtr->vars, varName);
-        if (he == NULL) {
-            /* Try with static vars. */
-            if (interp->framePtr->staticVars == NULL)
-                return JIM_ERR;
-            if (!(he = Jim_FindHashEntry(interp->framePtr->staticVars, varName)))
-                return JIM_ERR;
-        }
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &variableObjType;
-    objPtr->internalRep.varValue.callFrameId = interp->framePtr->id;
-    objPtr->internalRep.varValue.varPtr = (void*)he->val;
-    return JIM_OK;
-}
-
-/* -------------------- Variables related functions ------------------------- */
-static int JimDictSugarSet(Jim_Interp *interp, Jim_Obj *ObjPtr,
-        Jim_Obj *valObjPtr);
-static Jim_Obj *JimDictSugarGet(Jim_Interp *interp, Jim_Obj *ObjPtr);
-
-/* For now that's dummy. Variables lookup should be optimized
- * in many ways, with caching of lookups, and possibly with
- * a table of pre-allocated vars in every CallFrame for local vars.
- * All the caching should also have an 'epoch' mechanism similar
- * to the one used by Tcl for procedures lookup caching. */
-
-int Jim_SetVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr, Jim_Obj *valObjPtr)
-{
-    const char *name;
-    Jim_Var *var;
-    int err;
-
-    if ((err = SetVariableFromAny(interp, nameObjPtr)) != JIM_OK) {
-        /* Check for [dict] syntax sugar. */
-        if (err == JIM_DICT_SUGAR)
-            return JimDictSugarSet(interp, nameObjPtr, valObjPtr);
-        /* New variable to create */
-        name = Jim_GetString(nameObjPtr, NULL);
-
-        var = Jim_Alloc(sizeof(*var));
-        var->objPtr = valObjPtr;
-        Jim_IncrRefCount(valObjPtr);
-        var->linkFramePtr = NULL;
-        /* Insert the new variable */
-        if (name[0] == ':' && name[1] == ':') {
-            /* Into to the top evel frame */
-            Jim_AddHashEntry(&interp->topFramePtr->vars, name + 2, var);
-        }
-        else {
-            Jim_AddHashEntry(&interp->framePtr->vars, name, var);
-        }
-        /* Make the object int rep a variable */
-        Jim_FreeIntRep(interp, nameObjPtr);
-        nameObjPtr->typePtr = &variableObjType;
-        nameObjPtr->internalRep.varValue.callFrameId =
-            interp->framePtr->id;
-        nameObjPtr->internalRep.varValue.varPtr = var;
-    } else {
-        var = nameObjPtr->internalRep.varValue.varPtr;
-        if (var->linkFramePtr == NULL) {
-            Jim_IncrRefCount(valObjPtr);
-            Jim_DecrRefCount(interp, var->objPtr);
-            var->objPtr = valObjPtr;
-        } else { /* Else handle the link */
-            Jim_CallFrame *savedCallFrame;
-
-            savedCallFrame = interp->framePtr;
-            interp->framePtr = var->linkFramePtr;
-            err = Jim_SetVariable(interp, var->objPtr, valObjPtr);
-            interp->framePtr = savedCallFrame;
-            if (err != JIM_OK)
-                return err;
-        }
-    }
-    return JIM_OK;
-}
-
-int Jim_SetVariableStr(Jim_Interp *interp, const char *name, Jim_Obj *objPtr)
-{
-    Jim_Obj *nameObjPtr;
-    int result;
-
-    nameObjPtr = Jim_NewStringObj(interp, name, -1);
-    Jim_IncrRefCount(nameObjPtr);
-    result = Jim_SetVariable(interp, nameObjPtr, objPtr);
-    Jim_DecrRefCount(interp, nameObjPtr);
-    return result;
-}
-
-int Jim_SetGlobalVariableStr(Jim_Interp *interp, const char *name, Jim_Obj *objPtr)
-{
-    Jim_CallFrame *savedFramePtr;
-    int result;
-
-    savedFramePtr = interp->framePtr;
-    interp->framePtr = interp->topFramePtr;
-    result = Jim_SetVariableStr(interp, name, objPtr);
-    interp->framePtr = savedFramePtr;
-    return result;
-}
-
-int Jim_SetVariableStrWithStr(Jim_Interp *interp, const char *name, const char *val)
-{
-    Jim_Obj *nameObjPtr, *valObjPtr;
-    int result;
-
-    nameObjPtr = Jim_NewStringObj(interp, name, -1);
-    valObjPtr = Jim_NewStringObj(interp, val, -1);
-    Jim_IncrRefCount(nameObjPtr);
-    Jim_IncrRefCount(valObjPtr);
-    result = Jim_SetVariable(interp, nameObjPtr, valObjPtr);
-    Jim_DecrRefCount(interp, nameObjPtr);
-    Jim_DecrRefCount(interp, valObjPtr);
-    return result;
-}
-
-int Jim_SetVariableLink(Jim_Interp *interp, Jim_Obj *nameObjPtr,
-        Jim_Obj *targetNameObjPtr, Jim_CallFrame *targetCallFrame)
-{
-    const char *varName;
-    int len;
-
-    /* Check for cycles. */
-    if (interp->framePtr == targetCallFrame) {
-        Jim_Obj *objPtr = targetNameObjPtr;
-        Jim_Var *varPtr;
-        /* Cycles are only possible with 'uplevel 0' */
-        while (1) {
-            if (Jim_StringEqObj(objPtr, nameObjPtr, 0)) {
-                Jim_SetResultString(interp,
-                    "can't upvar from variable to itself", -1);
-                return JIM_ERR;
-            }
-            if (SetVariableFromAny(interp, objPtr) != JIM_OK)
-                break;
-            varPtr = objPtr->internalRep.varValue.varPtr;
-            if (varPtr->linkFramePtr != targetCallFrame) break;
-            objPtr = varPtr->objPtr;
-        }
-    }
-    varName = Jim_GetString(nameObjPtr, &len);
-    if (Jim_NameIsDictSugar(varName, len)) {
-        Jim_SetResultString(interp,
-            "Dict key syntax invalid as link source", -1);
-        return JIM_ERR;
-    }
-    /* Perform the binding */
-    Jim_SetVariable(interp, nameObjPtr, targetNameObjPtr);
-    /* We are now sure 'nameObjPtr' type is variableObjType */
-    nameObjPtr->internalRep.varValue.varPtr->linkFramePtr = targetCallFrame;
-    return JIM_OK;
-}
-
-/* Return the Jim_Obj pointer associated with a variable name,
- * or NULL if the variable was not found in the current context.
- * The same optimization discussed in the comment to the
- * 'SetVariable' function should apply here. */
-Jim_Obj *Jim_GetVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr, int flags)
-{
-    int err;
-
-    /* All the rest is handled here */
-    if ((err = SetVariableFromAny(interp, nameObjPtr)) != JIM_OK) {
-        /* Check for [dict] syntax sugar. */
-        if (err == JIM_DICT_SUGAR)
-            return JimDictSugarGet(interp, nameObjPtr);
-        if (flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "can't read \"", nameObjPtr->bytes,
-                "\": no such variable", NULL);
-        }
-        return NULL;
-    } else {
-        Jim_Var *varPtr;
-        Jim_Obj *objPtr;
-        Jim_CallFrame *savedCallFrame;
-
-        varPtr = nameObjPtr->internalRep.varValue.varPtr;
-        if (varPtr->linkFramePtr == NULL)
-            return varPtr->objPtr;
-        /* The variable is a link? Resolve it. */
-        savedCallFrame = interp->framePtr;
-        interp->framePtr = varPtr->linkFramePtr;
-        objPtr = Jim_GetVariable(interp, varPtr->objPtr, JIM_NONE);
-        if (objPtr == NULL && flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "can't read \"", nameObjPtr->bytes,
-                "\": no such variable", NULL);
-        }
-        interp->framePtr = savedCallFrame;
-        return objPtr;
-    }
-}
-
-Jim_Obj *Jim_GetGlobalVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr,
-        int flags)
-{
-    Jim_CallFrame *savedFramePtr;
-    Jim_Obj *objPtr;
-
-    savedFramePtr = interp->framePtr;
-    interp->framePtr = interp->topFramePtr;
-    objPtr = Jim_GetVariable(interp, nameObjPtr, flags);
-    interp->framePtr = savedFramePtr;
-
-    return objPtr;
-}
-
-Jim_Obj *Jim_GetVariableStr(Jim_Interp *interp, const char *name, int flags)
-{
-    Jim_Obj *nameObjPtr, *varObjPtr;
-
-    nameObjPtr = Jim_NewStringObj(interp, name, -1);
-    Jim_IncrRefCount(nameObjPtr);
-    varObjPtr = Jim_GetVariable(interp, nameObjPtr, flags);
-    Jim_DecrRefCount(interp, nameObjPtr);
-    return varObjPtr;
-}
-
-Jim_Obj *Jim_GetGlobalVariableStr(Jim_Interp *interp, const char *name,
-        int flags)
-{
-    Jim_CallFrame *savedFramePtr;
-    Jim_Obj *objPtr;
-
-    savedFramePtr = interp->framePtr;
-    interp->framePtr = interp->topFramePtr;
-    objPtr = Jim_GetVariableStr(interp, name, flags);
-    interp->framePtr = savedFramePtr;
-
-    return objPtr;
-}
-
-/* Unset a variable.
- * Note: On success unset invalidates all the variable objects created
- * in the current call frame incrementing. */
-int Jim_UnsetVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr, int flags)
-{
-    const char *name;
-    Jim_Var *varPtr;
-    int err;
-
-    if ((err = SetVariableFromAny(interp, nameObjPtr)) != JIM_OK) {
-        /* Check for [dict] syntax sugar. */
-        if (err == JIM_DICT_SUGAR)
-            return JimDictSugarSet(interp, nameObjPtr, NULL);
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "can't unset \"", nameObjPtr->bytes,
-            "\": no such variable", NULL);
-        return JIM_ERR; /* var not found */
-    }
-    varPtr = nameObjPtr->internalRep.varValue.varPtr;
-    /* If it's a link call UnsetVariable recursively */
-    if (varPtr->linkFramePtr) {
-        int retval;
-
-        Jim_CallFrame *savedCallFrame;
-
-        savedCallFrame = interp->framePtr;
-        interp->framePtr = varPtr->linkFramePtr;
-        retval = Jim_UnsetVariable(interp, varPtr->objPtr, JIM_NONE);
-        interp->framePtr = savedCallFrame;
-        if (retval != JIM_OK && flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "can't unset \"", nameObjPtr->bytes,
-                "\": no such variable", NULL);
-        }
-        return retval;
-    } else {
-        name = Jim_GetString(nameObjPtr, NULL);
-        if (Jim_DeleteHashEntry(&interp->framePtr->vars, name)
-                != JIM_OK) return JIM_ERR;
-        /* Change the callframe id, invalidating var lookup caching */
-        JimChangeCallFrameId(interp, interp->framePtr);
-        return JIM_OK;
-    }
-}
-
-/* ----------  Dict syntax sugar (similar to array Tcl syntax) -------------- */
-
-/* Given a variable name for [dict] operation syntax sugar,
- * this function returns two objects, the first with the name
- * of the variable to set, and the second with the rispective key.
- * For example "foo(bar)" will return objects with string repr. of
- * "foo" and "bar".
- *
- * The returned objects have refcount = 1. The function can't fail. */
-static void JimDictSugarParseVarKey(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj **varPtrPtr, Jim_Obj **keyPtrPtr)
-{
-    const char *str, *p;
-    char *t;
-    int len, keyLen, nameLen;
-    Jim_Obj *varObjPtr, *keyObjPtr;
-
-    str = Jim_GetString(objPtr, &len);
-    p = strchr(str, '(');
-    p++;
-    keyLen = len-((p-str) + 1);
-    nameLen = (p-str)-1;
-    /* Create the objects with the variable name and key. */
-    t = Jim_Alloc(nameLen + 1);
-    memcpy(t, str, nameLen);
-    t[nameLen] = '\0';
-    varObjPtr = Jim_NewStringObjNoAlloc(interp, t, nameLen);
-
-    t = Jim_Alloc(keyLen + 1);
-    memcpy(t, p, keyLen);
-    t[keyLen] = '\0';
-    keyObjPtr = Jim_NewStringObjNoAlloc(interp, t, keyLen);
-
-    Jim_IncrRefCount(varObjPtr);
-    Jim_IncrRefCount(keyObjPtr);
-    *varPtrPtr = varObjPtr;
-    *keyPtrPtr = keyObjPtr;
-}
-
-/* Helper of Jim_SetVariable() to deal with dict-syntax variable names.
- * Also used by Jim_UnsetVariable() with valObjPtr = NULL. */
-static int JimDictSugarSet(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *valObjPtr)
-{
-    Jim_Obj *varObjPtr, *keyObjPtr;
-    int err = JIM_OK;
-
-    JimDictSugarParseVarKey(interp, objPtr, &varObjPtr, &keyObjPtr);
-    err = Jim_SetDictKeysVector(interp, varObjPtr, &keyObjPtr, 1,
-            valObjPtr);
-    Jim_DecrRefCount(interp, varObjPtr);
-    Jim_DecrRefCount(interp, keyObjPtr);
-    return err;
-}
-
-/* Helper of Jim_GetVariable() to deal with dict-syntax variable names */
-static Jim_Obj *JimDictSugarGet(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_Obj *varObjPtr, *keyObjPtr, *dictObjPtr, *resObjPtr;
-
-    JimDictSugarParseVarKey(interp, objPtr, &varObjPtr, &keyObjPtr);
-    dictObjPtr = Jim_GetVariable(interp, varObjPtr, JIM_ERRMSG);
-    if (!dictObjPtr) {
-        resObjPtr = NULL;
-        goto err;
-    }
-    if (Jim_DictKey(interp, dictObjPtr, keyObjPtr, &resObjPtr, JIM_ERRMSG)
-            != JIM_OK) {
-        resObjPtr = NULL;
-    }
-err:
-    Jim_DecrRefCount(interp, varObjPtr);
-    Jim_DecrRefCount(interp, keyObjPtr);
-    return resObjPtr;
-}
-
-/* --------- $var(INDEX) substitution, using a specialized object ----------- */
-
-static void FreeDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr,
-        Jim_Obj *dupPtr);
-
-static Jim_ObjType dictSubstObjType = {
-    "dict-substitution",
-    FreeDictSubstInternalRep,
-    DupDictSubstInternalRep,
-    NULL,
-    JIM_TYPE_NONE,
-};
-
-void FreeDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_DecrRefCount(interp, objPtr->internalRep.dictSubstValue.varNameObjPtr);
-    Jim_DecrRefCount(interp, objPtr->internalRep.dictSubstValue.indexObjPtr);
-}
-
-void DupDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr,
-        Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-
-    dupPtr->internalRep.dictSubstValue.varNameObjPtr =
-        srcPtr->internalRep.dictSubstValue.varNameObjPtr;
-    dupPtr->internalRep.dictSubstValue.indexObjPtr =
-        srcPtr->internalRep.dictSubstValue.indexObjPtr;
-    dupPtr->typePtr = &dictSubstObjType;
-}
-
-/* This function is used to expand [dict get] sugar in the form
- * of $var(INDEX). The function is mainly used by Jim_EvalObj()
- * to deal with tokens of type JIM_TT_DICTSUGAR. objPtr points to an
- * object that is *guaranteed* to be in the form VARNAME(INDEX).
- * The 'index' part is [subst]ituted, and is used to lookup a key inside
- * the [dict]ionary contained in variable VARNAME. */
-Jim_Obj *Jim_ExpandDictSugar(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_Obj *varObjPtr, *keyObjPtr, *dictObjPtr, *resObjPtr;
-    Jim_Obj *substKeyObjPtr = NULL;
-
-    if (objPtr->typePtr != &dictSubstObjType) {
-        JimDictSugarParseVarKey(interp, objPtr, &varObjPtr, &keyObjPtr);
-        Jim_FreeIntRep(interp, objPtr);
-        objPtr->typePtr = &dictSubstObjType;
-        objPtr->internalRep.dictSubstValue.varNameObjPtr = varObjPtr;
-        objPtr->internalRep.dictSubstValue.indexObjPtr = keyObjPtr;
-    }
-    if (Jim_SubstObj(interp, objPtr->internalRep.dictSubstValue.indexObjPtr,
-                &substKeyObjPtr, JIM_NONE)
-            != JIM_OK) {
-        substKeyObjPtr = NULL;
-        goto err;
-    }
-    Jim_IncrRefCount(substKeyObjPtr);
-    dictObjPtr = Jim_GetVariable(interp,
-            objPtr->internalRep.dictSubstValue.varNameObjPtr, JIM_ERRMSG);
-    if (!dictObjPtr) {
-        resObjPtr = NULL;
-        goto err;
-    }
-    if (Jim_DictKey(interp, dictObjPtr, substKeyObjPtr, &resObjPtr, JIM_ERRMSG)
-            != JIM_OK) {
-        resObjPtr = NULL;
-        goto err;
-    }
-err:
-    if (substKeyObjPtr) Jim_DecrRefCount(interp, substKeyObjPtr);
-    return resObjPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * CallFrame
- * ---------------------------------------------------------------------------*/
-
-static Jim_CallFrame *JimCreateCallFrame(Jim_Interp *interp)
-{
-    Jim_CallFrame *cf;
-    if (interp->freeFramesList) {
-        cf = interp->freeFramesList;
-        interp->freeFramesList = cf->nextFramePtr;
-    } else {
-        cf = Jim_Alloc(sizeof(*cf));
-        cf->vars.table = NULL;
-    }
-
-    cf->id = interp->callFrameEpoch++;
-    cf->parentCallFrame = NULL;
-    cf->argv = NULL;
-    cf->argc = 0;
-    cf->procArgsObjPtr = NULL;
-    cf->procBodyObjPtr = NULL;
-    cf->nextFramePtr = NULL;
-    cf->staticVars = NULL;
-    if (cf->vars.table == NULL)
-        Jim_InitHashTable(&cf->vars, &JimVariablesHashTableType, interp);
-    return cf;
-}
-
-/* Used to invalidate every caching related to callframe stability. */
-static void JimChangeCallFrameId(Jim_Interp *interp, Jim_CallFrame *cf)
-{
-    cf->id = interp->callFrameEpoch++;
-}
-
-#define JIM_FCF_NONE 0 /* no flags */
-#define JIM_FCF_NOHT 1 /* don't free the hash table */
-static void JimFreeCallFrame(Jim_Interp *interp, Jim_CallFrame *cf,
-        int flags)
-{
-    if (cf->procArgsObjPtr) Jim_DecrRefCount(interp, cf->procArgsObjPtr);
-    if (cf->procBodyObjPtr) Jim_DecrRefCount(interp, cf->procBodyObjPtr);
-    if (!(flags & JIM_FCF_NOHT))
-        Jim_FreeHashTable(&cf->vars);
-    else {
-        int i;
-        Jim_HashEntry **table = cf->vars.table, *he;
-
-        for (i = 0; i < JIM_HT_INITIAL_SIZE; i++) {
-            he = table[i];
-            while (he != NULL) {
-                Jim_HashEntry *nextEntry = he->next;
-                Jim_Var *varPtr = (void*) he->val;
-
-                Jim_DecrRefCount(interp, varPtr->objPtr);
-                Jim_Free(he->val);
-                Jim_Free((void*)he->key); /* ATTENTION: const cast */
-                Jim_Free(he);
-                table[i] = NULL;
-                he = nextEntry;
-            }
-        }
-        cf->vars.used = 0;
-    }
-    cf->nextFramePtr = interp->freeFramesList;
-    interp->freeFramesList = cf;
-}
-
-/* -----------------------------------------------------------------------------
- * References
- * ---------------------------------------------------------------------------*/
-
-/* References HashTable Type.
- *
- * Keys are jim_wide integers, dynamically allocated for now but in the
- * future it's worth to cache this 8 bytes objects. Values are poitners
- * to Jim_References. */
-static void JimReferencesHTValDestructor(void *interp, void *val)
-{
-    Jim_Reference *refPtr = (void*) val;
-
-    Jim_DecrRefCount(interp, refPtr->objPtr);
-    if (refPtr->finalizerCmdNamePtr != NULL) {
-        Jim_DecrRefCount(interp, refPtr->finalizerCmdNamePtr);
-    }
-    Jim_Free(val);
-}
-
-unsigned int JimReferencesHTHashFunction(const void *key)
-{
-    /* Only the least significant bits are used. */
-    const jim_wide *widePtr = key;
-    unsigned int intValue = (unsigned int) *widePtr;
-    return Jim_IntHashFunction(intValue);
-}
-
-unsigned int JimReferencesHTDoubleHashFunction(const void *key)
-{
-    /* Only the least significant bits are used. */
-    const jim_wide *widePtr = key;
-    unsigned int intValue = (unsigned int) *widePtr;
-    return intValue; /* identity function. */
-}
-
-const void *JimReferencesHTKeyDup(void *privdata, const void *key)
-{
-    void *copy = Jim_Alloc(sizeof(jim_wide));
-    JIM_NOTUSED(privdata);
-
-    memcpy(copy, key, sizeof(jim_wide));
-    return copy;
-}
-
-int JimReferencesHTKeyCompare(void *privdata, const void *key1,
-        const void *key2)
-{
-    JIM_NOTUSED(privdata);
-
-    return memcmp(key1, key2, sizeof(jim_wide)) == 0;
-}
-
-void JimReferencesHTKeyDestructor(void *privdata, const void *key)
-{
-    JIM_NOTUSED(privdata);
-
-    Jim_Free((void*)key);
-}
-
-static Jim_HashTableType JimReferencesHashTableType = {
-    JimReferencesHTHashFunction,    /* hash function */
-    JimReferencesHTKeyDup,          /* key dup */
-    NULL,                           /* val dup */
-    JimReferencesHTKeyCompare,      /* key compare */
-    JimReferencesHTKeyDestructor,   /* key destructor */
-    JimReferencesHTValDestructor    /* val destructor */
-};
-
-/* -----------------------------------------------------------------------------
- * Reference object type and References API
- * ---------------------------------------------------------------------------*/
-
-static void UpdateStringOfReference(struct Jim_Obj *objPtr);
-
-static Jim_ObjType referenceObjType = {
-    "reference",
-    NULL,
-    NULL,
-    UpdateStringOfReference,
-    JIM_TYPE_REFERENCES,
-};
-
-void UpdateStringOfReference(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_REFERENCE_SPACE + 1];
-    Jim_Reference *refPtr;
-
-    refPtr = objPtr->internalRep.refValue.refPtr;
-    len = JimFormatReference(buf, refPtr, objPtr->internalRep.refValue.id);
-    objPtr->bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr->bytes, buf, len + 1);
-    objPtr->length = len;
-}
-
-/* returns true if 'c' is a valid reference tag character.
- * i.e. inside the range [_a-zA-Z0-9] */
-static int isrefchar(int c)
-{
-    if (c == '_' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
-        (c >= '0' && c <= '9')) return 1;
-    return 0;
-}
-
-int SetReferenceFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    jim_wide wideValue;
-    int i, len;
-    const char *str, *start, *end;
-    char refId[21];
-    Jim_Reference *refPtr;
-    Jim_HashEntry *he;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &len);
-    /* Check if it looks like a reference */
-    if (len < JIM_REFERENCE_SPACE) goto badformat;
-    /* Trim spaces */
-    start = str;
-    end = str + len-1;
-    while (*start == ' ') start++;
-    while (*end == ' ' && end > start) end--;
-    if (end-start + 1 != JIM_REFERENCE_SPACE) goto badformat;
-    /* <reference.<1234567>.%020> */
-    if (memcmp(start, "<reference.<", 12) != 0) goto badformat;
-    if (start[12 + JIM_REFERENCE_TAGLEN] != '>' || end[0] != '>') goto badformat;
-    /* The tag can't contain chars other than a-zA-Z0-9 + '_'. */
-    for (i = 0; i < JIM_REFERENCE_TAGLEN; i++) {
-        if (!isrefchar(start[12 + i])) goto badformat;
-    }
-    /* Extract info from the refernece. */
-    memcpy(refId, start + 14 + JIM_REFERENCE_TAGLEN, 20);
-    refId[20] = '\0';
-    /* Try to convert the ID into a jim_wide */
-    if (Jim_StringToWide(refId, &wideValue, 10) != JIM_OK) goto badformat;
-    /* Check if the reference really exists! */
-    he = Jim_FindHashEntry(&interp->references, &wideValue);
-    if (he == NULL) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "Invalid reference ID \"", str, "\"", NULL);
-        return JIM_ERR;
-    }
-    refPtr = he->val;
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &referenceObjType;
-    objPtr->internalRep.refValue.id = wideValue;
-    objPtr->internalRep.refValue.refPtr = refPtr;
-    return JIM_OK;
-
-badformat:
-    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-    Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "expected reference but got \"", str, "\"", NULL);
-    return JIM_ERR;
-}
-
-/* Returns a new reference pointing to objPtr, having cmdNamePtr
- * as finalizer command (or NULL if there is no finalizer).
- * The returned reference object has refcount = 0. */
-Jim_Obj *Jim_NewReference(Jim_Interp *interp, Jim_Obj *objPtr, Jim_Obj *tagPtr,
-        Jim_Obj *cmdNamePtr)
-{
-    struct Jim_Reference *refPtr;
-    jim_wide wideValue = interp->referenceNextId;
-    Jim_Obj *refObjPtr;
-    const char *tag;
-    int tagLen, i;
-
-    /* Perform the Garbage Collection if needed. */
-    Jim_CollectIfNeeded(interp);
-
-    refPtr = Jim_Alloc(sizeof(*refPtr));
-    refPtr->objPtr = objPtr;
-    Jim_IncrRefCount(objPtr);
-    refPtr->finalizerCmdNamePtr = cmdNamePtr;
-    if (cmdNamePtr)
-        Jim_IncrRefCount(cmdNamePtr);
-    Jim_AddHashEntry(&interp->references, &wideValue, refPtr);
-    refObjPtr = Jim_NewObj(interp);
-    refObjPtr->typePtr = &referenceObjType;
-    refObjPtr->bytes = NULL;
-    refObjPtr->internalRep.refValue.id = interp->referenceNextId;
-    refObjPtr->internalRep.refValue.refPtr = refPtr;
-    interp->referenceNextId++;
-    /* Set the tag. Trimmered at JIM_REFERENCE_TAGLEN. Everything
-     * that does not pass the 'isrefchar' test is replaced with '_' */
-    tag = Jim_GetString(tagPtr, &tagLen);
-    if (tagLen > JIM_REFERENCE_TAGLEN)
-        tagLen = JIM_REFERENCE_TAGLEN;
-    for (i = 0; i < JIM_REFERENCE_TAGLEN; i++) {
-        if (i < tagLen)
-            refPtr->tag[i] = tag[i];
-        else
-            refPtr->tag[i] = '_';
-    }
-    refPtr->tag[JIM_REFERENCE_TAGLEN] = '\0';
-    return refObjPtr;
-}
-
-Jim_Reference *Jim_GetReference(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    if (objPtr->typePtr != &referenceObjType &&
-        SetReferenceFromAny(interp, objPtr) == JIM_ERR)
-        return NULL;
-    return objPtr->internalRep.refValue.refPtr;
-}
-
-int Jim_SetFinalizer(Jim_Interp *interp, Jim_Obj *objPtr, Jim_Obj *cmdNamePtr)
-{
-    Jim_Reference *refPtr;
-
-    if ((refPtr = Jim_GetReference(interp, objPtr)) == NULL)
-        return JIM_ERR;
-    Jim_IncrRefCount(cmdNamePtr);
-    if (refPtr->finalizerCmdNamePtr)
-        Jim_DecrRefCount(interp, refPtr->finalizerCmdNamePtr);
-    refPtr->finalizerCmdNamePtr = cmdNamePtr;
-    return JIM_OK;
-}
-
-int Jim_GetFinalizer(Jim_Interp *interp, Jim_Obj *objPtr, Jim_Obj **cmdNamePtrPtr)
-{
-    Jim_Reference *refPtr;
-
-    if ((refPtr = Jim_GetReference(interp, objPtr)) == NULL)
-        return JIM_ERR;
-    *cmdNamePtrPtr = refPtr->finalizerCmdNamePtr;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * References Garbage Collection
- * ---------------------------------------------------------------------------*/
-
-/* This the hash table type for the "MARK" phase of the GC */
-static Jim_HashTableType JimRefMarkHashTableType = {
-    JimReferencesHTHashFunction,    /* hash function */
-    JimReferencesHTKeyDup,          /* key dup */
-    NULL,                           /* val dup */
-    JimReferencesHTKeyCompare,      /* key compare */
-    JimReferencesHTKeyDestructor,   /* key destructor */
-    NULL                            /* val destructor */
-};
-
-/* #define JIM_DEBUG_GC 1 */
-
-/* Performs the garbage collection. */
-int Jim_Collect(Jim_Interp *interp)
-{
-    Jim_HashTable marks;
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj *objPtr;
-    int collected = 0;
-
-    /* Avoid recursive calls */
-    if (interp->lastCollectId == -1) {
-        /* Jim_Collect() already running. Return just now. */
-        return 0;
-    }
-    interp->lastCollectId = -1;
-
-    /* Mark all the references found into the 'mark' hash table.
-     * The references are searched in every live object that
-     * is of a type that can contain references. */
-    Jim_InitHashTable(&marks, &JimRefMarkHashTableType, NULL);
-    objPtr = interp->liveList;
-    while (objPtr) {
-        if (objPtr->typePtr == NULL ||
-            objPtr->typePtr->flags & JIM_TYPE_REFERENCES) {
-            const char *str, *p;
-            int len;
-
-            /* If the object is of type reference, to get the
-             * Id is simple... */
-            if (objPtr->typePtr == &referenceObjType) {
-                Jim_AddHashEntry(&marks,
-                    &objPtr->internalRep.refValue.id, NULL);
-#ifdef JIM_DEBUG_GC
-                Jim_fprintf(interp,interp->cookie_stdout,
-                    "MARK (reference): %d refcount: %d" JIM_NL,
-                    (int) objPtr->internalRep.refValue.id,
-                    objPtr->refCount);
-#endif
-                objPtr = objPtr->nextObjPtr;
-                continue;
-            }
-            /* Get the string repr of the object we want
-             * to scan for references. */
-            p = str = Jim_GetString(objPtr, &len);
-            /* Skip objects too little to contain references. */
-            if (len < JIM_REFERENCE_SPACE) {
-                objPtr = objPtr->nextObjPtr;
-                continue;
-            }
-            /* Extract references from the object string repr. */
-            while (1) {
-                int i;
-                jim_wide id;
-                char buf[21];
-
-                if ((p = strstr(p, "<reference.<")) == NULL)
-                    break;
-                /* Check if it's a valid reference. */
-                if (len-(p-str) < JIM_REFERENCE_SPACE) break;
-                if (p[41] != '>' || p[19] != '>' || p[20] != '.') break;
-                for (i = 21; i <= 40; i++)
-                    if (!isdigit((int)p[i]))
-                        break;
-                /* Get the ID */
-                memcpy(buf, p + 21, 20);
-                buf[20] = '\0';
-                Jim_StringToWide(buf, &id, 10);
-
-                /* Ok, a reference for the given ID
-                 * was found. Mark it. */
-                Jim_AddHashEntry(&marks, &id, NULL);
-#ifdef JIM_DEBUG_GC
-                Jim_fprintf(interp,interp->cookie_stdout,"MARK: %d" JIM_NL, (int)id);
-#endif
-                p += JIM_REFERENCE_SPACE;
-            }
-        }
-        objPtr = objPtr->nextObjPtr;
-    }
-
-    /* Run the references hash table to destroy every reference that
-     * is not referenced outside (not present in the mark HT). */
-    htiter = Jim_GetHashTableIterator(&interp->references);
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        const jim_wide *refId;
-        Jim_Reference *refPtr;
-
-        refId = he->key;
-        /* Check if in the mark phase we encountered
-         * this reference. */
-        if (Jim_FindHashEntry(&marks, refId) == NULL) {
-#ifdef JIM_DEBUG_GC
-            Jim_fprintf(interp,interp->cookie_stdout,"COLLECTING %d" JIM_NL, (int)*refId);
-#endif
-            collected++;
-            /* Drop the reference, but call the
-             * finalizer first if registered. */
-            refPtr = he->val;
-            if (refPtr->finalizerCmdNamePtr) {
-                char *refstr = Jim_Alloc(JIM_REFERENCE_SPACE + 1);
-                Jim_Obj *objv[3], *oldResult;
-
-                JimFormatReference(refstr, refPtr, *refId);
-
-                objv[0] = refPtr->finalizerCmdNamePtr;
-                objv[1] = Jim_NewStringObjNoAlloc(interp,
-                        refstr, 32);
-                objv[2] = refPtr->objPtr;
-                Jim_IncrRefCount(objv[0]);
-                Jim_IncrRefCount(objv[1]);
-                Jim_IncrRefCount(objv[2]);
-
-                /* Drop the reference itself */
-                Jim_DeleteHashEntry(&interp->references, refId);
-
-                /* Call the finalizer. Errors ignored. */
-                oldResult = interp->result;
-                Jim_IncrRefCount(oldResult);
-                Jim_EvalObjVector(interp, 3, objv);
-                Jim_SetResult(interp, oldResult);
-                Jim_DecrRefCount(interp, oldResult);
-
-                Jim_DecrRefCount(interp, objv[0]);
-                Jim_DecrRefCount(interp, objv[1]);
-                Jim_DecrRefCount(interp, objv[2]);
-            } else {
-                Jim_DeleteHashEntry(&interp->references, refId);
-            }
-        }
-    }
-    Jim_FreeHashTableIterator(htiter);
-    Jim_FreeHashTable(&marks);
-    interp->lastCollectId = interp->referenceNextId;
-    interp->lastCollectTime = time(NULL);
-    return collected;
-}
-
-#define JIM_COLLECT_ID_PERIOD 5000
-#define JIM_COLLECT_TIME_PERIOD 300
-
-void Jim_CollectIfNeeded(Jim_Interp *interp)
-{
-    jim_wide elapsedId;
-    int elapsedTime;
-
-    elapsedId = interp->referenceNextId - interp->lastCollectId;
-    elapsedTime = time(NULL) - interp->lastCollectTime;
-
-
-    if (elapsedId > JIM_COLLECT_ID_PERIOD ||
-        elapsedTime > JIM_COLLECT_TIME_PERIOD) {
-        Jim_Collect(interp);
-    }
-}
-
-/* -----------------------------------------------------------------------------
- * Interpreter related functions
- * ---------------------------------------------------------------------------*/
-
-Jim_Interp *Jim_CreateInterp(void)
-{
-    Jim_Interp *i = Jim_Alloc(sizeof(*i));
-    Jim_Obj *pathPtr;
-
-    i->errorLine = 0;
-    i->errorFileName = Jim_StrDup("");
-    i->numLevels = 0;
-    i->maxNestingDepth = JIM_MAX_NESTING_DEPTH;
-    i->returnCode = JIM_OK;
-    i->exitCode = 0;
-    i->procEpoch = 0;
-    i->callFrameEpoch = 0;
-    i->liveList = i->freeList = NULL;
-    i->scriptFileName = Jim_StrDup("");
-    i->referenceNextId = 0;
-    i->lastCollectId = 0;
-    i->lastCollectTime = time(NULL);
-    i->freeFramesList = NULL;
-    i->prngState = NULL;
-    i->evalRetcodeLevel = -1;
-    i->cookie_stdin = stdin;
-    i->cookie_stdout = stdout;
-    i->cookie_stderr = stderr;
-	i->cb_fwrite   = ((size_t (*)(const void *, size_t, size_t, void *))(fwrite));
-	i->cb_fread    = ((size_t (*)(void *, size_t, size_t, void *))(fread));
-	i->cb_vfprintf = ((int    (*)(void *, const char *fmt, va_list))(vfprintf));
-	i->cb_fflush   = ((int    (*)(void *))(fflush));
-	i->cb_fgets    = ((char * (*)(char *, int, void *))(fgets));
-
-    /* Note that we can create objects only after the
-     * interpreter liveList and freeList pointers are
-     * initialized to NULL. */
-    Jim_InitHashTable(&i->commands, &JimCommandsHashTableType, i);
-    Jim_InitHashTable(&i->references, &JimReferencesHashTableType, i);
-    Jim_InitHashTable(&i->sharedStrings, &JimSharedStringsHashTableType,
-            NULL);
-    Jim_InitHashTable(&i->stub, &JimStringCopyHashTableType, NULL);
-    Jim_InitHashTable(&i->assocData, &JimAssocDataHashTableType, i);
-    Jim_InitHashTable(&i->packages, &JimStringKeyValCopyHashTableType, NULL);
-    i->framePtr = i->topFramePtr = JimCreateCallFrame(i);
-    i->emptyObj = Jim_NewEmptyStringObj(i);
-    i->result = i->emptyObj;
-    i->stackTrace = Jim_NewListObj(i, NULL, 0);
-    i->unknown = Jim_NewStringObj(i, "unknown", -1);
-    i->unknown_called = 0;
-    Jim_IncrRefCount(i->emptyObj);
-    Jim_IncrRefCount(i->result);
-    Jim_IncrRefCount(i->stackTrace);
-    Jim_IncrRefCount(i->unknown);
-
-    /* Initialize key variables every interpreter should contain */
-    pathPtr = Jim_NewStringObj(i, "./", -1);
-    Jim_SetVariableStr(i, "jim_libpath", pathPtr);
-    Jim_SetVariableStrWithStr(i, "jim_interactive", "0");
-
-    /* Export the core API to extensions */
-    JimRegisterCoreApi(i);
-    return i;
-}
-
-/* This is the only function Jim exports directly without
- * to use the STUB system. It is only used by embedders
- * in order to get an interpreter with the Jim API pointers
- * registered. */
-Jim_Interp *ExportedJimCreateInterp(void)
-{
-    return Jim_CreateInterp();
-}
-
-void Jim_FreeInterp(Jim_Interp *i)
-{
-    Jim_CallFrame *cf = i->framePtr, *prevcf, *nextcf;
-    Jim_Obj *objPtr, *nextObjPtr;
-
-    Jim_DecrRefCount(i, i->emptyObj);
-    Jim_DecrRefCount(i, i->result);
-    Jim_DecrRefCount(i, i->stackTrace);
-    Jim_DecrRefCount(i, i->unknown);
-    Jim_Free((void*)i->errorFileName);
-    Jim_Free((void*)i->scriptFileName);
-    Jim_FreeHashTable(&i->commands);
-    Jim_FreeHashTable(&i->references);
-    Jim_FreeHashTable(&i->stub);
-    Jim_FreeHashTable(&i->assocData);
-    Jim_FreeHashTable(&i->packages);
-    Jim_Free(i->prngState);
-    /* Free the call frames list */
-    while (cf) {
-        prevcf = cf->parentCallFrame;
-        JimFreeCallFrame(i, cf, JIM_FCF_NONE);
-        cf = prevcf;
-    }
-    /* Check that the live object list is empty, otherwise
-     * there is a memory leak. */
-    if (i->liveList != NULL) {
-        objPtr = i->liveList;
-
-        Jim_fprintf(i, i->cookie_stdout,JIM_NL "-------------------------------------" JIM_NL);
-        Jim_fprintf(i, i->cookie_stdout,"Objects still in the free list:" JIM_NL);
-        while (objPtr) {
-            const char *type = objPtr->typePtr ?
-                objPtr->typePtr->name : "";
-            Jim_fprintf(i, i->cookie_stdout,"%p \"%-10s\": '%.20s' (refCount: %d)" JIM_NL,
-                    objPtr, type,
-                    objPtr->bytes ? objPtr->bytes
-                    : "(null)", objPtr->refCount);
-            if (objPtr->typePtr == &sourceObjType) {
-                Jim_fprintf(i, i->cookie_stdout, "FILE %s LINE %d" JIM_NL,
-                objPtr->internalRep.sourceValue.fileName,
-                objPtr->internalRep.sourceValue.lineNumber);
-            }
-            objPtr = objPtr->nextObjPtr;
-        }
-        Jim_fprintf(i, i->cookie_stdout, "-------------------------------------" JIM_NL JIM_NL);
-        Jim_Panic(i,"Live list non empty freeing the interpreter! Leak?");
-    }
-    /* Free all the freed objects. */
-    objPtr = i->freeList;
-    while (objPtr) {
-        nextObjPtr = objPtr->nextObjPtr;
-        Jim_Free(objPtr);
-        objPtr = nextObjPtr;
-    }
-    /* Free cached CallFrame structures */
-    cf = i->freeFramesList;
-    while (cf) {
-        nextcf = cf->nextFramePtr;
-        if (cf->vars.table != NULL)
-            Jim_Free(cf->vars.table);
-        Jim_Free(cf);
-        cf = nextcf;
-    }
-    /* Free the sharedString hash table. Make sure to free it
-     * after every other Jim_Object was freed. */
-    Jim_FreeHashTable(&i->sharedStrings);
-    /* Free the interpreter structure. */
-    Jim_Free(i);
-}
-
-/* Store the call frame relative to the level represented by
- * levelObjPtr into *framePtrPtr. If levelObjPtr == NULL, the
- * level is assumed to be '1'.
- *
- * If a newLevelptr int pointer is specified, the function stores
- * the absolute level integer value of the new target callframe into
- * *newLevelPtr. (this is used to adjust interp->numLevels
- * in the implementation of [uplevel], so that [info level] will
- * return a correct information).
- *
- * This function accepts the 'level' argument in the form
- * of the commands [uplevel] and [upvar].
- *
- * For a function accepting a relative integer as level suitable
- * for implementation of [info level ?level?] check the
- * GetCallFrameByInteger() function. */
-int Jim_GetCallFrameByLevel(Jim_Interp *interp, Jim_Obj *levelObjPtr,
-        Jim_CallFrame **framePtrPtr, int *newLevelPtr)
-{
-    long level;
-    const char *str;
-    Jim_CallFrame *framePtr;
-
-    if (newLevelPtr) *newLevelPtr = interp->numLevels;
-    if (levelObjPtr) {
-        str = Jim_GetString(levelObjPtr, NULL);
-        if (str[0] == '#') {
-            char *endptr;
-            /* speedup for the toplevel (level #0) */
-            if (str[1] == '0' && str[2] == '\0') {
-                if (newLevelPtr) *newLevelPtr = 0;
-                *framePtrPtr = interp->topFramePtr;
-                return JIM_OK;
-            }
-
-            level = strtol(str + 1, &endptr, 0);
-            if (str[1] == '\0' || endptr[0] != '\0' || level < 0)
-                goto badlevel;
-            /* An 'absolute' level is converted into the
-             * 'number of levels to go back' format. */
-            level = interp->numLevels - level;
-            if (level < 0) goto badlevel;
-        } else {
-            if (Jim_GetLong(interp, levelObjPtr, &level) != JIM_OK || level < 0)
-                goto badlevel;
-        }
-    } else {
-        str = "1"; /* Needed to format the error message. */
-        level = 1;
-    }
-    /* Lookup */
-    framePtr = interp->framePtr;
-    if (newLevelPtr) *newLevelPtr = (*newLevelPtr)-level;
-    while (level--) {
-        framePtr = framePtr->parentCallFrame;
-        if (framePtr == NULL) goto badlevel;
-    }
-    *framePtrPtr = framePtr;
-    return JIM_OK;
-badlevel:
-    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-    Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "bad level \"", str, "\"", NULL);
-    return JIM_ERR;
-}
-
-/* Similar to Jim_GetCallFrameByLevel() but the level is specified
- * as a relative integer like in the [info level ?level?] command. */
-static int JimGetCallFrameByInteger(Jim_Interp *interp, Jim_Obj *levelObjPtr,
-        Jim_CallFrame **framePtrPtr)
-{
-    jim_wide level;
-    jim_wide relLevel; /* level relative to the current one. */
-    Jim_CallFrame *framePtr;
-
-    if (Jim_GetWide(interp, levelObjPtr, &level) != JIM_OK)
-        goto badlevel;
-    if (level > 0) {
-        /* An 'absolute' level is converted into the
-         * 'number of levels to go back' format. */
-        relLevel = interp->numLevels - level;
-    } else {
-        relLevel = -level;
-    }
-    /* Lookup */
-    framePtr = interp->framePtr;
-    while (relLevel--) {
-        framePtr = framePtr->parentCallFrame;
-        if (framePtr == NULL) goto badlevel;
-    }
-    *framePtrPtr = framePtr;
-    return JIM_OK;
-badlevel:
-    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-    Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "bad level \"", Jim_GetString(levelObjPtr, NULL), "\"", NULL);
-    return JIM_ERR;
-}
-
-static void JimSetErrorFileName(Jim_Interp *interp, char *filename)
-{
-    Jim_Free((void*)interp->errorFileName);
-    interp->errorFileName = Jim_StrDup(filename);
-}
-
-static void JimSetErrorLineNumber(Jim_Interp *interp, int linenr)
-{
-    interp->errorLine = linenr;
-}
-
-static void JimResetStackTrace(Jim_Interp *interp)
-{
-    Jim_DecrRefCount(interp, interp->stackTrace);
-    interp->stackTrace = Jim_NewListObj(interp, NULL, 0);
-    Jim_IncrRefCount(interp->stackTrace);
-}
-
-static void JimAppendStackTrace(Jim_Interp *interp, const char *procname,
-        const char *filename, int linenr)
-{
-    /* No need to add this dummy entry to the stack trace */
-    if (strcmp(procname, "unknown") == 0) {
-        return;
-    }
-
-    if (Jim_IsShared(interp->stackTrace)) {
-        interp->stackTrace =
-            Jim_DuplicateObj(interp, interp->stackTrace);
-        Jim_IncrRefCount(interp->stackTrace);
-    }
-    Jim_ListAppendElement(interp, interp->stackTrace,
-            Jim_NewStringObj(interp, procname, -1));
-    Jim_ListAppendElement(interp, interp->stackTrace,
-            Jim_NewStringObj(interp, filename, -1));
-    Jim_ListAppendElement(interp, interp->stackTrace,
-            Jim_NewIntObj(interp, linenr));
-}
-
-int Jim_SetAssocData(Jim_Interp *interp, const char *key, Jim_InterpDeleteProc *delProc, void *data)
-{
-    AssocDataValue *assocEntryPtr = (AssocDataValue *)Jim_Alloc(sizeof(AssocDataValue));
-    assocEntryPtr->delProc = delProc;
-    assocEntryPtr->data = data;
-    return Jim_AddHashEntry(&interp->assocData, key, assocEntryPtr);
-}
-
-void *Jim_GetAssocData(Jim_Interp *interp, const char *key)
-{
-    Jim_HashEntry *entryPtr = Jim_FindHashEntry(&interp->assocData, key);
-    if (entryPtr != NULL) {
-        AssocDataValue *assocEntryPtr = (AssocDataValue *)entryPtr->val;
-        return assocEntryPtr->data;
-    }
-    return NULL;
-}
-
-int Jim_DeleteAssocData(Jim_Interp *interp, const char *key)
-{
-    return Jim_DeleteHashEntry(&interp->assocData, key);
-}
-
-int Jim_GetExitCode(Jim_Interp *interp) {
-    return interp->exitCode;
-}
-
-void *Jim_SetStdin(Jim_Interp *interp, void *fp)
-{
-    if (fp != NULL) interp->cookie_stdin = fp;
-    return interp->cookie_stdin;
-}
-
-void *Jim_SetStdout(Jim_Interp *interp, void *fp)
-{
-    if (fp != NULL) interp->cookie_stdout = fp;
-    return interp->cookie_stdout;
-}
-
-void *Jim_SetStderr(Jim_Interp *interp, void  *fp)
-{
-    if (fp != NULL) interp->cookie_stderr = fp;
-    return interp->cookie_stderr;
-}
-
-/* -----------------------------------------------------------------------------
- * Shared strings.
- * Every interpreter has an hash table where to put shared dynamically
- * allocate strings that are likely to be used a lot of times.
- * For example, in the 'source' object type, there is a pointer to
- * the filename associated with that object. Every script has a lot
- * of this objects with the identical file name, so it is wise to share
- * this info.
- *
- * The API is trivial: Jim_GetSharedString(interp, "foobar")
- * returns the pointer to the shared string. Every time a reference
- * to the string is no longer used, the user should call
- * Jim_ReleaseSharedString(interp, stringPointer). Once no one is using
- * a given string, it is removed from the hash table.
- * ---------------------------------------------------------------------------*/
-const char *Jim_GetSharedString(Jim_Interp *interp, const char *str)
-{
-    Jim_HashEntry *he = Jim_FindHashEntry(&interp->sharedStrings, str);
-
-    if (he == NULL) {
-        char *strCopy = Jim_StrDup(str);
-
-        Jim_AddHashEntry(&interp->sharedStrings, strCopy, (void*)1);
-        return strCopy;
-    } else {
-        intptr_t refCount = (intptr_t) he->val;
-
-        refCount++;
-        he->val = (void*) refCount;
-        return he->key;
-    }
-}
-
-void Jim_ReleaseSharedString(Jim_Interp *interp, const char *str)
-{
-    intptr_t refCount;
-    Jim_HashEntry *he = Jim_FindHashEntry(&interp->sharedStrings, str);
-
-    if (he == NULL)
-        Jim_Panic(interp,"Jim_ReleaseSharedString called with "
-              "unknown shared string '%s'", str);
-    refCount = (intptr_t) he->val;
-    refCount--;
-    if (refCount == 0) {
-        Jim_DeleteHashEntry(&interp->sharedStrings, str);
-    } else {
-        he->val = (void*) refCount;
-    }
-}
-
-/* -----------------------------------------------------------------------------
- * Integer object
- * ---------------------------------------------------------------------------*/
-#define JIM_INTEGER_SPACE 24
-
-static void UpdateStringOfInt(struct Jim_Obj *objPtr);
-static int SetIntFromAny(Jim_Interp *interp, Jim_Obj *objPtr, int flags);
-
-static Jim_ObjType intObjType = {
-    "int",
-    NULL,
-    NULL,
-    UpdateStringOfInt,
-    JIM_TYPE_NONE,
-};
-
-void UpdateStringOfInt(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_INTEGER_SPACE + 1];
-
-    len = Jim_WideToString(buf, objPtr->internalRep.wideValue);
-    objPtr->bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr->bytes, buf, len + 1);
-    objPtr->length = len;
-}
-
-int SetIntFromAny(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
-{
-    jim_wide wideValue;
-    const char *str;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, NULL);
-    /* Try to convert into a jim_wide */
-    if (Jim_StringToWide(str, &wideValue, 0) != JIM_OK) {
-        if (flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    "expected integer but got \"", str, "\"", NULL);
-        }
-        return JIM_ERR;
-    }
-    if ((wideValue == JIM_WIDE_MIN || wideValue == JIM_WIDE_MAX) &&
-        errno == ERANGE) {
-        Jim_SetResultString(interp,
-            "Integer value too big to be represented", -1);
-        return JIM_ERR;
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &intObjType;
-    objPtr->internalRep.wideValue = wideValue;
-    return JIM_OK;
-}
-
-int Jim_GetWide(Jim_Interp *interp, Jim_Obj *objPtr, jim_wide *widePtr)
-{
-    if (objPtr->typePtr != &intObjType &&
-        SetIntFromAny(interp, objPtr, JIM_ERRMSG) == JIM_ERR)
-        return JIM_ERR;
-    *widePtr = objPtr->internalRep.wideValue;
-    return JIM_OK;
-}
-
-/* Get a wide but does not set an error if the format is bad. */
-static int JimGetWideNoErr(Jim_Interp *interp, Jim_Obj *objPtr,
-        jim_wide *widePtr)
-{
-    if (objPtr->typePtr != &intObjType &&
-        SetIntFromAny(interp, objPtr, JIM_NONE) == JIM_ERR)
-        return JIM_ERR;
-    *widePtr = objPtr->internalRep.wideValue;
-    return JIM_OK;
-}
-
-int Jim_GetLong(Jim_Interp *interp, Jim_Obj *objPtr, long *longPtr)
-{
-    jim_wide wideValue;
-    int retval;
-
-    retval = Jim_GetWide(interp, objPtr, &wideValue);
-    if (retval == JIM_OK) {
-        *longPtr = (long) wideValue;
-        return JIM_OK;
-    }
-    return JIM_ERR;
-}
-
-void Jim_SetWide(Jim_Interp *interp, Jim_Obj *objPtr, jim_wide wideValue)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,"Jim_SetWide called with shared object");
-    if (objPtr->typePtr != &intObjType) {
-        Jim_FreeIntRep(interp, objPtr);
-        objPtr->typePtr = &intObjType;
-    }
-    Jim_InvalidateStringRep(objPtr);
-    objPtr->internalRep.wideValue = wideValue;
-}
-
-Jim_Obj *Jim_NewIntObj(Jim_Interp *interp, jim_wide wideValue)
-{
-    Jim_Obj *objPtr;
-
-    objPtr = Jim_NewObj(interp);
-    objPtr->typePtr = &intObjType;
-    objPtr->bytes = NULL;
-    objPtr->internalRep.wideValue = wideValue;
-    return objPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * Double object
- * ---------------------------------------------------------------------------*/
-#define JIM_DOUBLE_SPACE 30
-
-static void UpdateStringOfDouble(struct Jim_Obj *objPtr);
-static int SetDoubleFromAny(Jim_Interp *interp, Jim_Obj *objPtr);
-
-static Jim_ObjType doubleObjType = {
-    "double",
-    NULL,
-    NULL,
-    UpdateStringOfDouble,
-    JIM_TYPE_NONE,
-};
-
-void UpdateStringOfDouble(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_DOUBLE_SPACE + 1];
-
-    len = Jim_DoubleToString(buf, objPtr->internalRep.doubleValue);
-    objPtr->bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr->bytes, buf, len + 1);
-    objPtr->length = len;
-}
-
-int SetDoubleFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    double doubleValue;
-    const char *str;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, NULL);
-    /* Try to convert into a double */
-    if (Jim_StringToDouble(str, &doubleValue) != JIM_OK) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "expected number but got '", str, "'", NULL);
-        return JIM_ERR;
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &doubleObjType;
-    objPtr->internalRep.doubleValue = doubleValue;
-    return JIM_OK;
-}
-
-int Jim_GetDouble(Jim_Interp *interp, Jim_Obj *objPtr, double *doublePtr)
-{
-    if (objPtr->typePtr != &doubleObjType &&
-        SetDoubleFromAny(interp, objPtr) == JIM_ERR)
-        return JIM_ERR;
-    *doublePtr = objPtr->internalRep.doubleValue;
-    return JIM_OK;
-}
-
-void Jim_SetDouble(Jim_Interp *interp, Jim_Obj *objPtr, double doubleValue)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,"Jim_SetDouble called with shared object");
-    if (objPtr->typePtr != &doubleObjType) {
-        Jim_FreeIntRep(interp, objPtr);
-        objPtr->typePtr = &doubleObjType;
-    }
-    Jim_InvalidateStringRep(objPtr);
-    objPtr->internalRep.doubleValue = doubleValue;
-}
-
-Jim_Obj *Jim_NewDoubleObj(Jim_Interp *interp, double doubleValue)
-{
-    Jim_Obj *objPtr;
-
-    objPtr = Jim_NewObj(interp);
-    objPtr->typePtr = &doubleObjType;
-    objPtr->bytes = NULL;
-    objPtr->internalRep.doubleValue = doubleValue;
-    return objPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * List object
- * ---------------------------------------------------------------------------*/
-static void ListAppendElement(Jim_Obj *listPtr, Jim_Obj *objPtr);
-static void FreeListInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupListInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static void UpdateStringOfList(struct Jim_Obj *objPtr);
-static int SetListFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-/* Note that while the elements of the list may contain references,
- * the list object itself can't. This basically means that the
- * list object string representation as a whole can't contain references
- * that are not presents in the single elements. */
-static Jim_ObjType listObjType = {
-    "list",
-    FreeListInternalRep,
-    DupListInternalRep,
-    UpdateStringOfList,
-    JIM_TYPE_NONE,
-};
-
-void FreeListInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int i;
-
-    for (i = 0; i < objPtr->internalRep.listValue.len; i++) {
-        Jim_DecrRefCount(interp, objPtr->internalRep.listValue.ele[i]);
-    }
-    Jim_Free(objPtr->internalRep.listValue.ele);
-}
-
-void DupListInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    int i;
-    JIM_NOTUSED(interp);
-
-    dupPtr->internalRep.listValue.len = srcPtr->internalRep.listValue.len;
-    dupPtr->internalRep.listValue.maxLen = srcPtr->internalRep.listValue.maxLen;
-    dupPtr->internalRep.listValue.ele =
-        Jim_Alloc(sizeof(Jim_Obj*)*srcPtr->internalRep.listValue.maxLen);
-    memcpy(dupPtr->internalRep.listValue.ele, srcPtr->internalRep.listValue.ele,
-            sizeof(Jim_Obj*)*srcPtr->internalRep.listValue.len);
-    for (i = 0; i < dupPtr->internalRep.listValue.len; i++) {
-        Jim_IncrRefCount(dupPtr->internalRep.listValue.ele[i]);
-    }
-    dupPtr->typePtr = &listObjType;
-}
-
-/* The following function checks if a given string can be encoded
- * into a list element without any kind of quoting, surrounded by braces,
- * or using escapes to quote. */
-#define JIM_ELESTR_SIMPLE 0
-#define JIM_ELESTR_BRACE 1
-#define JIM_ELESTR_QUOTE 2
-static int ListElementQuotingType(const char *s, int len)
-{
-    int i, level, trySimple = 1;
-
-    /* Try with the SIMPLE case */
-    if (len == 0) return JIM_ELESTR_BRACE;
-    if (s[0] == '"' || s[0] == '{') {
-        trySimple = 0;
-        goto testbrace;
-    }
-    for (i = 0; i < len; i++) {
-        switch (s[i]) {
-        case ' ':
-        case '$':
-        case '"':
-        case '[':
-        case ']':
-        case ';':
-        case '\\':
-        case '\r':
-        case '\n':
-        case '\t':
-        case '\f':
-        case '\v':
-            trySimple = 0;
-        case '{':
-        case '}':
-            goto testbrace;
-        }
-    }
-    return JIM_ELESTR_SIMPLE;
-
-testbrace:
-    /* Test if it's possible to do with braces */
-    if (s[len-1] == '\\' ||
-        s[len-1] == ']') return JIM_ELESTR_QUOTE;
-    level = 0;
-    for (i = 0; i < len; i++) {
-        switch (s[i]) {
-        case '{': level++; break;
-        case '}': level--;
-              if (level < 0) return JIM_ELESTR_QUOTE;
-              break;
-        case '\\':
-              if (s[i + 1] == '\n')
-                  return JIM_ELESTR_QUOTE;
-              else
-                  if (s[i + 1] != '\0') i++;
-              break;
-        }
-    }
-    if (level == 0) {
-        if (!trySimple) return JIM_ELESTR_BRACE;
-        for (i = 0; i < len; i++) {
-            switch (s[i]) {
-            case ' ':
-            case '$':
-            case '"':
-            case '[':
-            case ']':
-            case ';':
-            case '\\':
-            case '\r':
-            case '\n':
-            case '\t':
-            case '\f':
-            case '\v':
-                return JIM_ELESTR_BRACE;
-                break;
-            }
-        }
-        return JIM_ELESTR_SIMPLE;
-    }
-    return JIM_ELESTR_QUOTE;
-}
-
-/* Returns the malloc-ed representation of a string
- * using backslash to quote special chars. */
-char *BackslashQuoteString(const char *s, int len, int *qlenPtr)
-{
-    char *q = Jim_Alloc(len*2 + 1), *p;
-
-    p = q;
-    while (*s) {
-        switch (*s) {
-        case ' ':
-        case '$':
-        case '"':
-        case '[':
-        case ']':
-        case '{':
-        case '}':
-        case ';':
-        case '\\':
-            *p++ = '\\';
-            *p++ = *s++;
-            break;
-        case '\n': *p++ = '\\'; *p++ = 'n'; s++; break;
-        case '\r': *p++ = '\\'; *p++ = 'r'; s++; break;
-        case '\t': *p++ = '\\'; *p++ = 't'; s++; break;
-        case '\f': *p++ = '\\'; *p++ = 'f'; s++; break;
-        case '\v': *p++ = '\\'; *p++ = 'v'; s++; break;
-        default:
-            *p++ = *s++;
-            break;
-        }
-    }
-    *p = '\0';
-    *qlenPtr = p-q;
-    return q;
-}
-
-void UpdateStringOfList(struct Jim_Obj *objPtr)
-{
-    int i, bufLen, realLength;
-    const char *strRep;
-    char *p;
-    int *quotingType;
-    Jim_Obj **ele = objPtr->internalRep.listValue.ele;
-
-    /* (Over) Estimate the space needed. */
-    quotingType = Jim_Alloc(sizeof(int)*objPtr->internalRep.listValue.len + 1);
-    bufLen = 0;
-    for (i = 0; i < objPtr->internalRep.listValue.len; i++) {
-        int len;
-
-        strRep = Jim_GetString(ele[i], &len);
-        quotingType[i] = ListElementQuotingType(strRep, len);
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE: bufLen += len; break;
-        case JIM_ELESTR_BRACE: bufLen += len + 2; break;
-        case JIM_ELESTR_QUOTE: bufLen += len*2; break;
-        }
-        bufLen++; /* elements separator. */
-    }
-    bufLen++;
-
-    /* Generate the string rep. */
-    p = objPtr->bytes = Jim_Alloc(bufLen + 1);
-    realLength = 0;
-    for (i = 0; i < objPtr->internalRep.listValue.len; i++) {
-        int len, qlen;
-        strRep = Jim_GetString(ele[i], &len);
-        char *q;
-
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE:
-            memcpy(p, strRep, len);
-            p += len;
-            realLength += len;
-            break;
-        case JIM_ELESTR_BRACE:
-            *p++ = '{';
-            memcpy(p, strRep, len);
-            p += len;
-            *p++ = '}';
-            realLength += len + 2;
-            break;
-        case JIM_ELESTR_QUOTE:
-            q = BackslashQuoteString(strRep, len, &qlen);
-            memcpy(p, q, qlen);
-            Jim_Free(q);
-            p += qlen;
-            realLength += qlen;
-            break;
-        }
-        /* Add a separating space */
-        if (i + 1 != objPtr->internalRep.listValue.len) {
-            *p++ = ' ';
-            realLength ++;
-        }
-    }
-    *p = '\0'; /* nul term. */
-    objPtr->length = realLength;
-    Jim_Free(quotingType);
-}
-
-int SetListFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    struct JimParserCtx parser;
-    const char *str;
-    int strLen;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &strLen);
-
-    /* Free the old internal repr just now and initialize the
-     * new one just now. The string->list conversion can't fail. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &listObjType;
-    objPtr->internalRep.listValue.len = 0;
-    objPtr->internalRep.listValue.maxLen = 0;
-    objPtr->internalRep.listValue.ele = NULL;
-
-    /* Convert into a list */
-    JimParserInit(&parser, str, strLen, 1);
-    while (!JimParserEof(&parser)) {
-        char *token;
-        int tokenLen, type;
-        Jim_Obj *elementPtr;
-
-        JimParseList(&parser);
-        if (JimParserTtype(&parser) != JIM_TT_STR &&
-            JimParserTtype(&parser) != JIM_TT_ESC)
-            continue;
-        token = JimParserGetToken(&parser, &tokenLen, &type, NULL);
-        elementPtr = Jim_NewStringObjNoAlloc(interp, token, tokenLen);
-        ListAppendElement(objPtr, elementPtr);
-    }
-    return JIM_OK;
-}
-
-Jim_Obj *Jim_NewListObj(Jim_Interp *interp, Jim_Obj *const *elements,
-        int len)
-{
-    Jim_Obj *objPtr;
-    int i;
-
-    objPtr = Jim_NewObj(interp);
-    objPtr->typePtr = &listObjType;
-    objPtr->bytes = NULL;
-    objPtr->internalRep.listValue.ele = NULL;
-    objPtr->internalRep.listValue.len = 0;
-    objPtr->internalRep.listValue.maxLen = 0;
-    for (i = 0; i < len; i++) {
-        ListAppendElement(objPtr, elements[i]);
-    }
-    return objPtr;
-}
-
-/* Return a vector of Jim_Obj with the elements of a Jim list, and the
- * length of the vector. Note that the user of this function should make
- * sure that the list object can't shimmer while the vector returned
- * is in use, this vector is the one stored inside the internal representation
- * of the list object. This function is not exported, extensions should
- * always access to the List object elements using Jim_ListIndex(). */
-static void JimListGetElements(Jim_Interp *interp, Jim_Obj *listObj, int *argc,
-        Jim_Obj ***listVec)
-{
-    Jim_ListLength(interp, listObj, argc);
-    assert(listObj->typePtr == &listObjType);
-    *listVec = listObj->internalRep.listValue.ele;
-}
-
-/* ListSortElements type values */
-enum {JIM_LSORT_ASCII, JIM_LSORT_NOCASE, JIM_LSORT_ASCII_DECR,
-      JIM_LSORT_NOCASE_DECR};
-
-/* Sort the internal rep of a list. */
-static int ListSortString(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 0);
-}
-
-static int ListSortStringDecr(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 0) * -1;
-}
-
-static int ListSortStringNoCase(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 1);
-}
-
-static int ListSortStringNoCaseDecr(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 1) * -1;
-}
-
-/* Sort a list *in place*. MUST be called with non-shared objects. */
-static void ListSortElements(Jim_Interp *interp, Jim_Obj *listObjPtr, int type)
-{
-    typedef int (qsort_comparator)(const void *, const void *);
-    int (*fn)(Jim_Obj**, Jim_Obj**);
-    Jim_Obj **vector;
-    int len;
-
-    if (Jim_IsShared(listObjPtr))
-        Jim_Panic(interp,"Jim_ListSortElements called with shared object");
-    if (listObjPtr->typePtr != &listObjType)
-        SetListFromAny(interp, listObjPtr);
-
-    vector = listObjPtr->internalRep.listValue.ele;
-    len = listObjPtr->internalRep.listValue.len;
-    switch (type) {
-        case JIM_LSORT_ASCII: fn = ListSortString;  break;
-        case JIM_LSORT_NOCASE: fn = ListSortStringNoCase;  break;
-        case JIM_LSORT_ASCII_DECR: fn = ListSortStringDecr;  break;
-        case JIM_LSORT_NOCASE_DECR: fn = ListSortStringNoCaseDecr;  break;
-        default:
-            fn = NULL; /* avoid warning */
-            Jim_Panic(interp,"ListSort called with invalid sort type");
-    }
-    qsort(vector, len, sizeof(Jim_Obj *), (qsort_comparator *)fn);
-    Jim_InvalidateStringRep(listObjPtr);
-}
-
-/* This is the low-level function to append an element to a list.
- * The higher-level Jim_ListAppendElement() performs shared object
- * check and invalidate the string repr. This version is used
- * in the internals of the List Object and is not exported.
- *
- * NOTE: this function can be called only against objects
- * with internal type of List. */
-void ListAppendElement(Jim_Obj *listPtr, Jim_Obj *objPtr)
-{
-    int requiredLen = listPtr->internalRep.listValue.len + 1;
-
-    if (requiredLen > listPtr->internalRep.listValue.maxLen) {
-        int maxLen = requiredLen * 2;
-
-        listPtr->internalRep.listValue.ele =
-            Jim_Realloc(listPtr->internalRep.listValue.ele,
-                    sizeof(Jim_Obj*)*maxLen);
-        listPtr->internalRep.listValue.maxLen = maxLen;
-    }
-    listPtr->internalRep.listValue.ele[listPtr->internalRep.listValue.len] =
-        objPtr;
-    listPtr->internalRep.listValue.len ++;
-    Jim_IncrRefCount(objPtr);
-}
-
-/* This is the low-level function to insert elements into a list.
- * The higher-level Jim_ListInsertElements() performs shared object
- * check and invalidate the string repr. This version is used
- * in the internals of the List Object and is not exported.
- *
- * NOTE: this function can be called only against objects
- * with internal type of List. */
-void ListInsertElements(Jim_Obj *listPtr, int index_t, int elemc,
-        Jim_Obj *const *elemVec)
-{
-    int currentLen = listPtr->internalRep.listValue.len;
-    int requiredLen = currentLen + elemc;
-    int i;
-    Jim_Obj **point;
-
-    if (requiredLen > listPtr->internalRep.listValue.maxLen) {
-        int maxLen = requiredLen * 2;
-
-        listPtr->internalRep.listValue.ele =
-            Jim_Realloc(listPtr->internalRep.listValue.ele,
-                    sizeof(Jim_Obj*)*maxLen);
-        listPtr->internalRep.listValue.maxLen = maxLen;
-    }
-    point = listPtr->internalRep.listValue.ele + index_t;
-    memmove(point + elemc, point, (currentLen-index_t) * sizeof(Jim_Obj*));
-    for (i = 0; i < elemc; ++i) {
-        point[i] = elemVec[i];
-        Jim_IncrRefCount(point[i]);
-    }
-    listPtr->internalRep.listValue.len += elemc;
-}
-
-/* Appends every element of appendListPtr into listPtr.
- * Both have to be of the list type. */
-void ListAppendList(Jim_Obj *listPtr, Jim_Obj *appendListPtr)
-{
-    int i, oldLen = listPtr->internalRep.listValue.len;
-    int appendLen = appendListPtr->internalRep.listValue.len;
-    int requiredLen = oldLen + appendLen;
-
-    if (requiredLen > listPtr->internalRep.listValue.maxLen) {
-        int maxLen = requiredLen * 2;
-
-        listPtr->internalRep.listValue.ele =
-            Jim_Realloc(listPtr->internalRep.listValue.ele,
-                    sizeof(Jim_Obj*)*maxLen);
-        listPtr->internalRep.listValue.maxLen = maxLen;
-    }
-    for (i = 0; i < appendLen; i++) {
-        Jim_Obj *objPtr = appendListPtr->internalRep.listValue.ele[i];
-        listPtr->internalRep.listValue.ele[oldLen + i] = objPtr;
-        Jim_IncrRefCount(objPtr);
-    }
-    listPtr->internalRep.listValue.len += appendLen;
-}
-
-void Jim_ListAppendElement(Jim_Interp *interp, Jim_Obj *listPtr, Jim_Obj *objPtr)
-{
-    if (Jim_IsShared(listPtr))
-        Jim_Panic(interp,"Jim_ListAppendElement called with shared object");
-    if (listPtr->typePtr != &listObjType)
-        SetListFromAny(interp, listPtr);
-    Jim_InvalidateStringRep(listPtr);
-    ListAppendElement(listPtr, objPtr);
-}
-
-void Jim_ListAppendList(Jim_Interp *interp, Jim_Obj *listPtr, Jim_Obj *appendListPtr)
-{
-    if (Jim_IsShared(listPtr))
-        Jim_Panic(interp,"Jim_ListAppendList called with shared object");
-    if (listPtr->typePtr != &listObjType)
-        SetListFromAny(interp, listPtr);
-    Jim_InvalidateStringRep(listPtr);
-    ListAppendList(listPtr, appendListPtr);
-}
-
-void Jim_ListLength(Jim_Interp *interp, Jim_Obj *listPtr, int *intPtr)
-{
-    if (listPtr->typePtr != &listObjType)
-        SetListFromAny(interp, listPtr);
-    *intPtr = listPtr->internalRep.listValue.len;
-}
-
-void Jim_ListInsertElements(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
-        int objc, Jim_Obj *const *objVec)
-{
-    if (Jim_IsShared(listPtr))
-        Jim_Panic(interp,"Jim_ListInsertElement called with shared object");
-    if (listPtr->typePtr != &listObjType)
-        SetListFromAny(interp, listPtr);
-    if (index_t >= 0 && index_t > listPtr->internalRep.listValue.len)
-        index_t = listPtr->internalRep.listValue.len;
-    else if (index_t < 0)
-        index_t = 0;
-    Jim_InvalidateStringRep(listPtr);
-    ListInsertElements(listPtr, index_t, objc, objVec);
-}
-
-int Jim_ListIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
-        Jim_Obj **objPtrPtr, int flags)
-{
-    if (listPtr->typePtr != &listObjType)
-        SetListFromAny(interp, listPtr);
-    if ((index_t >= 0 && index_t >= listPtr->internalRep.listValue.len) ||
-        (index_t < 0 && (-index_t-1) >= listPtr->internalRep.listValue.len)) {
-        if (flags & JIM_ERRMSG) {
-            Jim_SetResultString(interp,
-                "list index out of range", -1);
-        }
-        return JIM_ERR;
-    }
-    if (index_t < 0)
-        index_t = listPtr->internalRep.listValue.len + index_t;
-    *objPtrPtr = listPtr->internalRep.listValue.ele[index_t];
-    return JIM_OK;
-}
-
-static int ListSetIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
-        Jim_Obj *newObjPtr, int flags)
-{
-    if (listPtr->typePtr != &listObjType)
-        SetListFromAny(interp, listPtr);
-    if ((index_t >= 0 && index_t >= listPtr->internalRep.listValue.len) ||
-        (index_t < 0 && (-index_t-1) >= listPtr->internalRep.listValue.len)) {
-        if (flags & JIM_ERRMSG) {
-            Jim_SetResultString(interp,
-                "list index_t out of range", -1);
-        }
-        return JIM_ERR;
-    }
-    if (index_t < 0)
-        index_t = listPtr->internalRep.listValue.len + index_t;
-    Jim_DecrRefCount(interp, listPtr->internalRep.listValue.ele[index_t]);
-    listPtr->internalRep.listValue.ele[index_t] = newObjPtr;
-    Jim_IncrRefCount(newObjPtr);
-    return JIM_OK;
-}
-
-/* Modify the list stored into the variable named 'varNamePtr'
- * setting the element specified by the 'indexc' indexes objects in 'indexv',
- * with the new element 'newObjptr'. */
-int Jim_SetListIndex(Jim_Interp *interp, Jim_Obj *varNamePtr,
-        Jim_Obj *const *indexv, int indexc, Jim_Obj *newObjPtr)
-{
-    Jim_Obj *varObjPtr, *objPtr, *listObjPtr;
-    int shared, i, index_t;
-
-    varObjPtr = objPtr = Jim_GetVariable(interp, varNamePtr, JIM_ERRMSG);
-    if (objPtr == NULL)
-        return JIM_ERR;
-    if ((shared = Jim_IsShared(objPtr)))
-        varObjPtr = objPtr = Jim_DuplicateObj(interp, objPtr);
-    for (i = 0; i < indexc-1; i++) {
-        listObjPtr = objPtr;
-        if (Jim_GetIndex(interp, indexv[i], &index_t) != JIM_OK)
-            goto err;
-        if (Jim_ListIndex(interp, listObjPtr, index_t, &objPtr,
-                    JIM_ERRMSG) != JIM_OK) {
-            goto err;
-        }
-        if (Jim_IsShared(objPtr)) {
-            objPtr = Jim_DuplicateObj(interp, objPtr);
-            ListSetIndex(interp, listObjPtr, index_t, objPtr, JIM_NONE);
-        }
-        Jim_InvalidateStringRep(listObjPtr);
-    }
-    if (Jim_GetIndex(interp, indexv[indexc-1], &index_t) != JIM_OK)
-        goto err;
-    if (ListSetIndex(interp, objPtr, index_t, newObjPtr, JIM_ERRMSG) == JIM_ERR)
-        goto err;
-    Jim_InvalidateStringRep(objPtr);
-    Jim_InvalidateStringRep(varObjPtr);
-    if (Jim_SetVariable(interp, varNamePtr, varObjPtr) != JIM_OK)
-        goto err;
-    Jim_SetResult(interp, varObjPtr);
-    return JIM_OK;
-err:
-    if (shared) {
-        Jim_FreeNewObj(interp, varObjPtr);
-    }
-    return JIM_ERR;
-}
-
-Jim_Obj *Jim_ConcatObj(Jim_Interp *interp, int objc, Jim_Obj *const *objv)
-{
-    int i;
-
-    /* If all the objects in objv are lists without string rep.
-     * it's possible to return a list as result, that's the
-     * concatenation of all the lists. */
-    for (i = 0; i < objc; i++) {
-        if (objv[i]->typePtr != &listObjType || objv[i]->bytes)
-            break;
-    }
-    if (i == objc) {
-        Jim_Obj *objPtr = Jim_NewListObj(interp, NULL, 0);
-        for (i = 0; i < objc; i++)
-            Jim_ListAppendList(interp, objPtr, objv[i]);
-        return objPtr;
-    } else {
-        /* Else... we have to glue strings together */
-        int len = 0, objLen;
-        char *bytes, *p;
-
-        /* Compute the length */
-        for (i = 0; i < objc; i++) {
-            Jim_GetString(objv[i], &objLen);
-            len += objLen;
-        }
-        if (objc) len += objc-1;
-        /* Create the string rep, and a stinrg object holding it. */
-        p = bytes = Jim_Alloc(len + 1);
-        for (i = 0; i < objc; i++) {
-            const char *s = Jim_GetString(objv[i], &objLen);
-            while (objLen && (*s == ' ' || *s == '\t' || *s == '\n'))
-            {
-                s++; objLen--; len--;
-            }
-            while (objLen && (s[objLen-1] == ' ' ||
-                s[objLen-1] == '\n' || s[objLen-1] == '\t')) {
-                objLen--; len--;
-            }
-            memcpy(p, s, objLen);
-            p += objLen;
-            if (objLen && i + 1 != objc) {
-                *p++ = ' ';
-            } else if (i + 1 != objc) {
-                /* Drop the space calcuated for this
-                 * element that is instead null. */
-                len--;
-            }
-        }
-        *p = '\0';
-        return Jim_NewStringObjNoAlloc(interp, bytes, len);
-    }
-}
-
-/* Returns a list composed of the elements in the specified range.
- * first and start are directly accepted as Jim_Objects and
- * processed for the end?-index? case. */
-Jim_Obj *Jim_ListRange(Jim_Interp *interp, Jim_Obj *listObjPtr, Jim_Obj *firstObjPtr, Jim_Obj *lastObjPtr)
-{
-    int first, last;
-    int len, rangeLen;
-
-    if (Jim_GetIndex(interp, firstObjPtr, &first) != JIM_OK ||
-        Jim_GetIndex(interp, lastObjPtr, &last) != JIM_OK)
-        return NULL;
-    Jim_ListLength(interp, listObjPtr, &len); /* will convert into list */
-    first = JimRelToAbsIndex(len, first);
-    last = JimRelToAbsIndex(len, last);
-    JimRelToAbsRange(len, first, last, &first, &last, &rangeLen);
-    return Jim_NewListObj(interp,
-            listObjPtr->internalRep.listValue.ele + first, rangeLen);
-}
-
-/* -----------------------------------------------------------------------------
- * Dict object
- * ---------------------------------------------------------------------------*/
-static void FreeDictInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupDictInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static void UpdateStringOfDict(struct Jim_Obj *objPtr);
-static int SetDictFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-/* Dict HashTable Type.
- *
- * Keys and Values are Jim objects. */
-
-unsigned int JimObjectHTHashFunction(const void *key)
-{
-    const char *str;
-    Jim_Obj *objPtr = (Jim_Obj*) key;
-    int len, h;
-
-    str = Jim_GetString(objPtr, &len);
-    h = Jim_GenHashFunction((unsigned char*)str, len);
-    return h;
-}
-
-int JimObjectHTKeyCompare(void *privdata, const void *key1, const void *key2)
-{
-    JIM_NOTUSED(privdata);
-
-    return Jim_StringEqObj((Jim_Obj*)key1, (Jim_Obj*)key2, 0);
-}
-
-static void JimObjectHTKeyValDestructor(void *interp, void *val)
-{
-    Jim_Obj *objPtr = val;
-
-    Jim_DecrRefCount(interp, objPtr);
-}
-
-static Jim_HashTableType JimDictHashTableType = {
-    JimObjectHTHashFunction,            /* hash function */
-    NULL,                               /* key dup */
-    NULL,                               /* val dup */
-    JimObjectHTKeyCompare,              /* key compare */
-    (void(*)(void*, const void*))       /* ATTENTION: const cast */
-        JimObjectHTKeyValDestructor,    /* key destructor */
-    JimObjectHTKeyValDestructor         /* val destructor */
-};
-
-/* Note that while the elements of the dict may contain references,
- * the list object itself can't. This basically means that the
- * dict object string representation as a whole can't contain references
- * that are not presents in the single elements. */
-static Jim_ObjType dictObjType = {
-    "dict",
-    FreeDictInternalRep,
-    DupDictInternalRep,
-    UpdateStringOfDict,
-    JIM_TYPE_NONE,
-};
-
-void FreeDictInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    JIM_NOTUSED(interp);
-
-    Jim_FreeHashTable(objPtr->internalRep.ptr);
-    Jim_Free(objPtr->internalRep.ptr);
-}
-
-void DupDictInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    Jim_HashTable *ht, *dupHt;
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-
-    /* Create a new hash table */
-    ht = srcPtr->internalRep.ptr;
-    dupHt = Jim_Alloc(sizeof(*dupHt));
-    Jim_InitHashTable(dupHt, &JimDictHashTableType, interp);
-    if (ht->size != 0)
-        Jim_ExpandHashTable(dupHt, ht->size);
-    /* Copy every element from the source to the dup hash table */
-    htiter = Jim_GetHashTableIterator(ht);
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        const Jim_Obj *keyObjPtr = he->key;
-        Jim_Obj *valObjPtr = he->val;
-
-        Jim_IncrRefCount((Jim_Obj*)keyObjPtr);  /* ATTENTION: const cast */
-        Jim_IncrRefCount(valObjPtr);
-        Jim_AddHashEntry(dupHt, keyObjPtr, valObjPtr);
-    }
-    Jim_FreeHashTableIterator(htiter);
-
-    dupPtr->internalRep.ptr = dupHt;
-    dupPtr->typePtr = &dictObjType;
-}
-
-void UpdateStringOfDict(struct Jim_Obj *objPtr)
-{
-    int i, bufLen, realLength;
-    const char *strRep;
-    char *p;
-    int *quotingType, objc;
-    Jim_HashTable *ht;
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj **objv;
-
-    /* Trun the hash table into a flat vector of Jim_Objects. */
-    ht = objPtr->internalRep.ptr;
-    objc = ht->used*2;
-    objv = Jim_Alloc(objc*sizeof(Jim_Obj*));
-    htiter = Jim_GetHashTableIterator(ht);
-    i = 0;
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        objv[i++] = (Jim_Obj*)he->key;  /* ATTENTION: const cast */
-        objv[i++] = he->val;
-    }
-    Jim_FreeHashTableIterator(htiter);
-    /* (Over) Estimate the space needed. */
-    quotingType = Jim_Alloc(sizeof(int)*objc);
-    bufLen = 0;
-    for (i = 0; i < objc; i++) {
-        int len;
-
-        strRep = Jim_GetString(objv[i], &len);
-        quotingType[i] = ListElementQuotingType(strRep, len);
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE: bufLen += len; break;
-        case JIM_ELESTR_BRACE: bufLen += len + 2; break;
-        case JIM_ELESTR_QUOTE: bufLen += len*2; break;
-        }
-        bufLen++; /* elements separator. */
-    }
-    bufLen++;
-
-    /* Generate the string rep. */
-    p = objPtr->bytes = Jim_Alloc(bufLen + 1);
-    realLength = 0;
-    for (i = 0; i < objc; i++) {
-        int len, qlen;
-        strRep = Jim_GetString(objv[i], &len);
-        char *q;
-
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE:
-            memcpy(p, strRep, len);
-            p += len;
-            realLength += len;
-            break;
-        case JIM_ELESTR_BRACE:
-            *p++ = '{';
-            memcpy(p, strRep, len);
-            p += len;
-            *p++ = '}';
-            realLength += len + 2;
-            break;
-        case JIM_ELESTR_QUOTE:
-            q = BackslashQuoteString(strRep, len, &qlen);
-            memcpy(p, q, qlen);
-            Jim_Free(q);
-            p += qlen;
-            realLength += qlen;
-            break;
-        }
-        /* Add a separating space */
-        if (i + 1 != objc) {
-            *p++ = ' ';
-            realLength ++;
-        }
-    }
-    *p = '\0'; /* nul term. */
-    objPtr->length = realLength;
-    Jim_Free(quotingType);
-    Jim_Free(objv);
-}
-
-int SetDictFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    struct JimParserCtx parser;
-    Jim_HashTable *ht;
-    Jim_Obj *objv[2];
-    const char *str;
-    int i, strLen;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &strLen);
-
-    /* Free the old internal repr just now and initialize the
-     * new one just now. The string->list conversion can't fail. */
-    Jim_FreeIntRep(interp, objPtr);
-    ht = Jim_Alloc(sizeof(*ht));
-    Jim_InitHashTable(ht, &JimDictHashTableType, interp);
-    objPtr->typePtr = &dictObjType;
-    objPtr->internalRep.ptr = ht;
-
-    /* Convert into a dict */
-    JimParserInit(&parser, str, strLen, 1);
-    i = 0;
-    while (!JimParserEof(&parser)) {
-        char *token;
-        int tokenLen, type;
-
-        JimParseList(&parser);
-        if (JimParserTtype(&parser) != JIM_TT_STR &&
-            JimParserTtype(&parser) != JIM_TT_ESC)
-            continue;
-        token = JimParserGetToken(&parser, &tokenLen, &type, NULL);
-        objv[i++] = Jim_NewStringObjNoAlloc(interp, token, tokenLen);
-        if (i == 2) {
-            i = 0;
-            Jim_IncrRefCount(objv[0]);
-            Jim_IncrRefCount(objv[1]);
-            if (Jim_AddHashEntry(ht, objv[0], objv[1]) != JIM_OK) {
-                Jim_HashEntry *he;
-                he = Jim_FindHashEntry(ht, objv[0]);
-                Jim_DecrRefCount(interp, objv[0]);
-                /* ATTENTION: const cast */
-                Jim_DecrRefCount(interp, (Jim_Obj*)he->val);
-                he->val = objv[1];
-            }
-        }
-    }
-    if (i) {
-        Jim_FreeNewObj(interp, objv[0]);
-        objPtr->typePtr = NULL;
-        Jim_FreeHashTable(ht);
-        Jim_SetResultString(interp, "invalid dictionary value: must be a list with an even number of elements", -1);
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* Dict object API */
-
-/* Add an element to a dict. objPtr must be of the "dict" type.
- * The higer-level exported function is Jim_DictAddElement().
- * If an element with the specified key already exists, the value
- * associated is replaced with the new one.
- *
- * if valueObjPtr == NULL, the key is instead removed if it exists. */
-static void DictAddElement(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *keyObjPtr, Jim_Obj *valueObjPtr)
-{
-    Jim_HashTable *ht = objPtr->internalRep.ptr;
-
-    if (valueObjPtr == NULL) { /* unset */
-        Jim_DeleteHashEntry(ht, keyObjPtr);
-        return;
-    }
-    Jim_IncrRefCount(keyObjPtr);
-    Jim_IncrRefCount(valueObjPtr);
-    if (Jim_AddHashEntry(ht, keyObjPtr, valueObjPtr) != JIM_OK) {
-        Jim_HashEntry *he = Jim_FindHashEntry(ht, keyObjPtr);
-        Jim_DecrRefCount(interp, keyObjPtr);
-        /* ATTENTION: const cast */
-        Jim_DecrRefCount(interp, (Jim_Obj*)he->val);
-        he->val = valueObjPtr;
-    }
-}
-
-/* Add an element, higher-level interface for DictAddElement().
- * If valueObjPtr == NULL, the key is removed if it exists. */
-int Jim_DictAddElement(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *keyObjPtr, Jim_Obj *valueObjPtr)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,"Jim_DictAddElement called with shared object");
-    if (objPtr->typePtr != &dictObjType) {
-        if (SetDictFromAny(interp, objPtr) != JIM_OK)
-            return JIM_ERR;
-    }
-    DictAddElement(interp, objPtr, keyObjPtr, valueObjPtr);
-    Jim_InvalidateStringRep(objPtr);
-    return JIM_OK;
-}
-
-Jim_Obj *Jim_NewDictObj(Jim_Interp *interp, Jim_Obj *const *elements, int len)
-{
-    Jim_Obj *objPtr;
-    int i;
-
-    if (len % 2)
-        Jim_Panic(interp,"Jim_NewDicObj() 'len' argument must be even");
-
-    objPtr = Jim_NewObj(interp);
-    objPtr->typePtr = &dictObjType;
-    objPtr->bytes = NULL;
-    objPtr->internalRep.ptr = Jim_Alloc(sizeof(Jim_HashTable));
-    Jim_InitHashTable(objPtr->internalRep.ptr, &JimDictHashTableType, interp);
-    for (i = 0; i < len; i += 2)
-        DictAddElement(interp, objPtr, elements[i], elements[i + 1]);
-    return objPtr;
-}
-
-/* Return the value associated to the specified dict key */
-int Jim_DictKey(Jim_Interp *interp, Jim_Obj *dictPtr, Jim_Obj *keyPtr,
-        Jim_Obj **objPtrPtr, int flags)
-{
-    Jim_HashEntry *he;
-    Jim_HashTable *ht;
-
-    if (dictPtr->typePtr != &dictObjType) {
-        if (SetDictFromAny(interp, dictPtr) != JIM_OK)
-            return JIM_ERR;
-    }
-    ht = dictPtr->internalRep.ptr;
-    if ((he = Jim_FindHashEntry(ht, keyPtr)) == NULL) {
-        if (flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    "key \"", Jim_GetString(keyPtr, NULL),
-                    "\" not found in dictionary", NULL);
-        }
-        return JIM_ERR;
-    }
-    *objPtrPtr = he->val;
-    return JIM_OK;
-}
-
-/* Return the value associated to the specified dict keys */
-int Jim_DictKeysVector(Jim_Interp *interp, Jim_Obj *dictPtr,
-        Jim_Obj *const *keyv, int keyc, Jim_Obj **objPtrPtr, int flags)
-{
-    Jim_Obj *objPtr = NULL;
-    int i;
-
-    if (keyc == 0) {
-        *objPtrPtr = dictPtr;
-        return JIM_OK;
-    }
-
-    for (i = 0; i < keyc; i++) {
-        if (Jim_DictKey(interp, dictPtr, keyv[i], &objPtr, flags)
-                != JIM_OK)
-            return JIM_ERR;
-        dictPtr = objPtr;
-    }
-    *objPtrPtr = objPtr;
-    return JIM_OK;
-}
-
-/* Modify the dict stored into the variable named 'varNamePtr'
- * setting the element specified by the 'keyc' keys objects in 'keyv',
- * with the new value of the element 'newObjPtr'.
- *
- * If newObjPtr == NULL the operation is to remove the given key
- * from the dictionary. */
-int Jim_SetDictKeysVector(Jim_Interp *interp, Jim_Obj *varNamePtr,
-        Jim_Obj *const *keyv, int keyc, Jim_Obj *newObjPtr)
-{
-    Jim_Obj *varObjPtr, *objPtr, *dictObjPtr;
-    int shared, i;
-
-    varObjPtr = objPtr = Jim_GetVariable(interp, varNamePtr, JIM_ERRMSG);
-    if (objPtr == NULL) {
-        if (newObjPtr == NULL) /* Cannot remove a key from non existing var */
-            return JIM_ERR;
-        varObjPtr = objPtr = Jim_NewDictObj(interp, NULL, 0);
-        if (Jim_SetVariable(interp, varNamePtr, objPtr) != JIM_OK) {
-            Jim_FreeNewObj(interp, varObjPtr);
-            return JIM_ERR;
-        }
-    }
-    if ((shared = Jim_IsShared(objPtr)))
-        varObjPtr = objPtr = Jim_DuplicateObj(interp, objPtr);
-    for (i = 0; i < keyc-1; i++) {
-        dictObjPtr = objPtr;
-
-        /* Check if it's a valid dictionary */
-        if (dictObjPtr->typePtr != &dictObjType) {
-            if (SetDictFromAny(interp, dictObjPtr) != JIM_OK)
-                goto err;
-        }
-        /* Check if the given key exists. */
-        Jim_InvalidateStringRep(dictObjPtr);
-        if (Jim_DictKey(interp, dictObjPtr, keyv[i], &objPtr,
-            newObjPtr ? JIM_NONE : JIM_ERRMSG) == JIM_OK)
-        {
-            /* This key exists at the current level.
-             * Make sure it's not shared!. */
-            if (Jim_IsShared(objPtr)) {
-                objPtr = Jim_DuplicateObj(interp, objPtr);
-                DictAddElement(interp, dictObjPtr, keyv[i], objPtr);
-            }
-        } else {
-            /* Key not found. If it's an [unset] operation
-             * this is an error. Only the last key may not
-             * exist. */
-            if (newObjPtr == NULL)
-                goto err;
-            /* Otherwise set an empty dictionary
-             * as key's value. */
-            objPtr = Jim_NewDictObj(interp, NULL, 0);
-            DictAddElement(interp, dictObjPtr, keyv[i], objPtr);
-        }
-    }
-    if (Jim_DictAddElement(interp, objPtr, keyv[keyc-1], newObjPtr)
-            != JIM_OK)
-        goto err;
-    Jim_InvalidateStringRep(objPtr);
-    Jim_InvalidateStringRep(varObjPtr);
-    if (Jim_SetVariable(interp, varNamePtr, varObjPtr) != JIM_OK)
-        goto err;
-    Jim_SetResult(interp, varObjPtr);
-    return JIM_OK;
-err:
-    if (shared) {
-        Jim_FreeNewObj(interp, varObjPtr);
-    }
-    return JIM_ERR;
-}
-
-/* -----------------------------------------------------------------------------
- * Index object
- * ---------------------------------------------------------------------------*/
-static void UpdateStringOfIndex(struct Jim_Obj *objPtr);
-static int SetIndexFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType indexObjType = {
-    "index",
-    NULL,
-    NULL,
-    UpdateStringOfIndex,
-    JIM_TYPE_NONE,
-};
-
-void UpdateStringOfIndex(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_INTEGER_SPACE + 1];
-
-    if (objPtr->internalRep.indexValue >= 0)
-        len = sprintf(buf, "%d", objPtr->internalRep.indexValue);
-    else if (objPtr->internalRep.indexValue == -1)
-        len = sprintf(buf, "end");
-    else {
-        len = sprintf(buf, "end%d", objPtr->internalRep.indexValue + 1);
-    }
-    objPtr->bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr->bytes, buf, len + 1);
-    objPtr->length = len;
-}
-
-int SetIndexFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int index_t, end = 0;
-    const char *str;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, NULL);
-    /* Try to convert into an index */
-    if (!strcmp(str, "end")) {
-        index_t = 0;
-        end = 1;
-    } else {
-        if (!strncmp(str, "end-", 4)) {
-            str += 4;
-            end = 1;
-        }
-        if (Jim_StringToIndex(str, &index_t) != JIM_OK) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    "bad index \"", Jim_GetString(objPtr, NULL), "\": "
-                    "must be integer or end?-integer?", NULL);
-            return JIM_ERR;
-        }
-    }
-    if (end) {
-        if (index_t < 0)
-            index_t = INT_MAX;
-        else
-            index_t = -(index_t + 1);
-    } else if (index_t < 0)
-        index_t = -INT_MAX;
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &indexObjType;
-    objPtr->internalRep.indexValue = index_t;
-    return JIM_OK;
-}
-
-int Jim_GetIndex(Jim_Interp *interp, Jim_Obj *objPtr, int *indexPtr)
-{
-    /* Avoid shimmering if the object is an integer. */
-    if (objPtr->typePtr == &intObjType) {
-        jim_wide val = objPtr->internalRep.wideValue;
-        if (!(val < LONG_MIN) && !(val > LONG_MAX)) {
-            *indexPtr = (val < 0) ? -INT_MAX : (long)val;;
-            return JIM_OK;
-        }
-    }
-    if (objPtr->typePtr != &indexObjType &&
-        SetIndexFromAny(interp, objPtr) == JIM_ERR)
-        return JIM_ERR;
-    *indexPtr = objPtr->internalRep.indexValue;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Return Code Object.
- * ---------------------------------------------------------------------------*/
-
-static int SetReturnCodeFromAny(Jim_Interp *interp, Jim_Obj *objPtr);
-
-static Jim_ObjType returnCodeObjType = {
-    "return-code",
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_NONE,
-};
-
-int SetReturnCodeFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    const char *str;
-    int strLen, returnCode;
-    jim_wide wideValue;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &strLen);
-    /* Try to convert into an integer */
-    if (JimGetWideNoErr(interp, objPtr, &wideValue) != JIM_ERR)
-        returnCode = (int) wideValue;
-    else if (!JimStringCompare(str, strLen, "ok", 2, JIM_NOCASE))
-        returnCode = JIM_OK;
-    else if (!JimStringCompare(str, strLen, "error", 5, JIM_NOCASE))
-        returnCode = JIM_ERR;
-    else if (!JimStringCompare(str, strLen, "return", 6, JIM_NOCASE))
-        returnCode = JIM_RETURN;
-    else if (!JimStringCompare(str, strLen, "break", 5, JIM_NOCASE))
-        returnCode = JIM_BREAK;
-    else if (!JimStringCompare(str, strLen, "continue", 8, JIM_NOCASE))
-        returnCode = JIM_CONTINUE;
-    else if (!JimStringCompare(str, strLen, "eval", 4, JIM_NOCASE))
-        returnCode = JIM_EVAL;
-    else if (!JimStringCompare(str, strLen, "exit", 4, JIM_NOCASE))
-        returnCode = JIM_EXIT;
-    else {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "expected return code but got '", str, "'",
-                NULL);
-        return JIM_ERR;
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr->typePtr = &returnCodeObjType;
-    objPtr->internalRep.returnCode = returnCode;
-    return JIM_OK;
-}
-
-int Jim_GetReturnCode(Jim_Interp *interp, Jim_Obj *objPtr, int *intPtr)
-{
-    if (objPtr->typePtr != &returnCodeObjType &&
-        SetReturnCodeFromAny(interp, objPtr) == JIM_ERR)
-        return JIM_ERR;
-    *intPtr = objPtr->internalRep.returnCode;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Expression Parsing
- * ---------------------------------------------------------------------------*/
-static int JimParseExprOperator(struct JimParserCtx *pc);
-static int JimParseExprNumber(struct JimParserCtx *pc);
-static int JimParseExprIrrational(struct JimParserCtx *pc);
-
-/* Exrp's Stack machine operators opcodes. */
-
-/* Binary operators (numbers) */
-#define JIM_EXPROP_BINARY_NUM_FIRST 0 /* first */
-#define JIM_EXPROP_MUL 0
-#define JIM_EXPROP_DIV 1
-#define JIM_EXPROP_MOD 2
-#define JIM_EXPROP_SUB 3
-#define JIM_EXPROP_ADD 4
-#define JIM_EXPROP_LSHIFT 5
-#define JIM_EXPROP_RSHIFT 6
-#define JIM_EXPROP_ROTL 7
-#define JIM_EXPROP_ROTR 8
-#define JIM_EXPROP_LT 9
-#define JIM_EXPROP_GT 10
-#define JIM_EXPROP_LTE 11
-#define JIM_EXPROP_GTE 12
-#define JIM_EXPROP_NUMEQ 13
-#define JIM_EXPROP_NUMNE 14
-#define JIM_EXPROP_BITAND 15
-#define JIM_EXPROP_BITXOR 16
-#define JIM_EXPROP_BITOR 17
-#define JIM_EXPROP_LOGICAND 18
-#define JIM_EXPROP_LOGICOR 19
-#define JIM_EXPROP_LOGICAND_LEFT 20
-#define JIM_EXPROP_LOGICOR_LEFT 21
-#define JIM_EXPROP_POW 22
-#define JIM_EXPROP_BINARY_NUM_LAST 22 /* last */
-
-/* Binary operators (strings) */
-#define JIM_EXPROP_STREQ 23
-#define JIM_EXPROP_STRNE 24
-
-/* Unary operators (numbers) */
-#define JIM_EXPROP_NOT 25
-#define JIM_EXPROP_BITNOT 26
-#define JIM_EXPROP_UNARYMINUS 27
-#define JIM_EXPROP_UNARYPLUS 28
-#define JIM_EXPROP_LOGICAND_RIGHT 29
-#define JIM_EXPROP_LOGICOR_RIGHT 30
-
-/* Ternary operators */
-#define JIM_EXPROP_TERNARY 31
-
-/* Operands */
-#define JIM_EXPROP_NUMBER 32
-#define JIM_EXPROP_COMMAND 33
-#define JIM_EXPROP_VARIABLE 34
-#define JIM_EXPROP_DICTSUGAR 35
-#define JIM_EXPROP_SUBST 36
-#define JIM_EXPROP_STRING 37
-
-/* Operators table */
-typedef struct Jim_ExprOperator {
-    const char *name;
-    int precedence;
-    int arity;
-    int opcode;
-} Jim_ExprOperator;
-
-/* name - precedence - arity - opcode */
-static struct Jim_ExprOperator Jim_ExprOperators[] = {
-    {"!", 300, 1, JIM_EXPROP_NOT},
-    {"~", 300, 1, JIM_EXPROP_BITNOT},
-    {"unarymin", 300, 1, JIM_EXPROP_UNARYMINUS},
-    {"unaryplus", 300, 1, JIM_EXPROP_UNARYPLUS},
-
-    {"**", 250, 2, JIM_EXPROP_POW},
-
-    {"*", 200, 2, JIM_EXPROP_MUL},
-    {"/", 200, 2, JIM_EXPROP_DIV},
-    {"%", 200, 2, JIM_EXPROP_MOD},
-
-    {"-", 100, 2, JIM_EXPROP_SUB},
-    {"+", 100, 2, JIM_EXPROP_ADD},
-
-    {"<<<", 90, 3, JIM_EXPROP_ROTL},
-    {">>>", 90, 3, JIM_EXPROP_ROTR},
-    {"<<", 90, 2, JIM_EXPROP_LSHIFT},
-    {">>", 90, 2, JIM_EXPROP_RSHIFT},
-
-    {"<",  80, 2, JIM_EXPROP_LT},
-    {">",  80, 2, JIM_EXPROP_GT},
-    {"<=", 80, 2, JIM_EXPROP_LTE},
-    {">=", 80, 2, JIM_EXPROP_GTE},
-
-    {"==", 70, 2, JIM_EXPROP_NUMEQ},
-    {"!=", 70, 2, JIM_EXPROP_NUMNE},
-
-    {"eq", 60, 2, JIM_EXPROP_STREQ},
-    {"ne", 60, 2, JIM_EXPROP_STRNE},
-
-    {"&", 50, 2, JIM_EXPROP_BITAND},
-    {"^", 49, 2, JIM_EXPROP_BITXOR},
-    {"|", 48, 2, JIM_EXPROP_BITOR},
-
-    {"&&", 10, 2, JIM_EXPROP_LOGICAND},
-    {"||", 10, 2, JIM_EXPROP_LOGICOR},
-
-    {"?", 5, 3, JIM_EXPROP_TERNARY},
-    /* private operators */
-    {NULL, 10, 2, JIM_EXPROP_LOGICAND_LEFT},
-    {NULL, 10, 1, JIM_EXPROP_LOGICAND_RIGHT},
-    {NULL, 10, 2, JIM_EXPROP_LOGICOR_LEFT},
-    {NULL, 10, 1, JIM_EXPROP_LOGICOR_RIGHT},
-};
-
-#define JIM_EXPR_OPERATORS_NUM \
-    (sizeof(Jim_ExprOperators)/sizeof(struct Jim_ExprOperator))
-
-int JimParseExpression(struct JimParserCtx *pc)
-{
-    /* Discard spaces and quoted newline */
-    while (*(pc->p) == ' ' ||
-          *(pc->p) == '\t' ||
-          *(pc->p) == '\r' ||
-          *(pc->p) == '\n' ||
-            (*(pc->p) == '\\' && *(pc->p + 1) == '\n')) {
-        pc->p++; pc->len--;
-    }
-
-    if (pc->len == 0) {
-        pc->tstart = pc->tend = pc->p;
-        pc->tline = pc->linenr;
-        pc->tt = JIM_TT_EOL;
-        pc->eof = 1;
-        return JIM_OK;
-    }
-    switch (*(pc->p)) {
-    case '(':
-        pc->tstart = pc->tend = pc->p;
-        pc->tline = pc->linenr;
-        pc->tt = JIM_TT_SUBEXPR_START;
-        pc->p++; pc->len--;
-        break;
-    case ')':
-        pc->tstart = pc->tend = pc->p;
-        pc->tline = pc->linenr;
-        pc->tt = JIM_TT_SUBEXPR_END;
-        pc->p++; pc->len--;
-        break;
-    case '[':
-        return JimParseCmd(pc);
-        break;
-    case '$':
-        if (JimParseVar(pc) == JIM_ERR)
-            return JimParseExprOperator(pc);
-        else
-            return JIM_OK;
-        break;
-    case '-':
-        if ((pc->tt == JIM_TT_NONE || pc->tt == JIM_TT_EXPR_OPERATOR) &&
-            isdigit((int)*(pc->p + 1)))
-            return JimParseExprNumber(pc);
-        else
-            return JimParseExprOperator(pc);
-        break;
-    case '0': case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8': case '9': case '.':
-        return JimParseExprNumber(pc);
-        break;
-    case '"':
-    case '{':
-        /* Here it's possible to reuse the List String parsing. */
-        pc->tt = JIM_TT_NONE; /* Make sure it's sensed as a new word. */
-        return JimParseListStr(pc);
-        break;
-    case 'N': case 'I':
-    case 'n': case 'i':
-        if (JimParseExprIrrational(pc) == JIM_ERR)
-            return JimParseExprOperator(pc);
-        break;
-    default:
-        return JimParseExprOperator(pc);
-        break;
-    }
-    return JIM_OK;
-}
-
-int JimParseExprNumber(struct JimParserCtx *pc)
-{
-    int allowdot = 1;
-    int allowhex = 0;
-
-    pc->tstart = pc->p;
-    pc->tline = pc->linenr;
-    if (*pc->p == '-') {
-        pc->p++; pc->len--;
-    }
-    while (isdigit((int)*pc->p)
-          || (allowhex && isxdigit((int)*pc->p))
-          || (allowdot && *pc->p == '.')
-          || (pc->p-pc->tstart == 1 && *pc->tstart == '0' &&
-              (*pc->p == 'x' || *pc->p == 'X'))
-)
-    {
-        if ((*pc->p == 'x') || (*pc->p == 'X')) {
-            allowhex = 1;
-            allowdot = 0;
-		}
-        if (*pc->p == '.')
-            allowdot = 0;
-        pc->p++; pc->len--;
-        if (!allowdot && *pc->p == 'e' && *(pc->p + 1) == '-') {
-            pc->p += 2; pc->len -= 2;
-        }
-    }
-    pc->tend = pc->p-1;
-    pc->tt = JIM_TT_EXPR_NUMBER;
-    return JIM_OK;
-}
-
-int JimParseExprIrrational(struct JimParserCtx *pc)
-{
-    const char *Tokens[] = {"NaN", "nan", "NAN", "Inf", "inf", "INF", NULL};
-    const char **token;
-    for (token = Tokens; *token != NULL; token++) {
-        int len = strlen(*token);
-        if (strncmp(*token, pc->p, len) == 0) {
-            pc->tstart = pc->p;
-            pc->tend = pc->p + len - 1;
-            pc->p += len; pc->len -= len;
-            pc->tline = pc->linenr;
-            pc->tt = JIM_TT_EXPR_NUMBER;
-            return JIM_OK;
-        }
-    }
-    return JIM_ERR;
-}
-
-int JimParseExprOperator(struct JimParserCtx *pc)
-{
-    int i;
-    int bestIdx = -1, bestLen = 0;
-
-    /* Try to get the longest match. */
-    for (i = 0; i < (signed)JIM_EXPR_OPERATORS_NUM; i++) {
-        const char *opname;
-        int oplen;
-
-        opname = Jim_ExprOperators[i].name;
-        if (opname == NULL) continue;
-        oplen = strlen(opname);
-
-        if (strncmp(opname, pc->p, oplen) == 0 && oplen > bestLen) {
-            bestIdx = i;
-            bestLen = oplen;
-        }
-    }
-    if (bestIdx == -1) return JIM_ERR;
-    pc->tstart = pc->p;
-    pc->tend = pc->p + bestLen - 1;
-    pc->p += bestLen; pc->len -= bestLen;
-    pc->tline = pc->linenr;
-    pc->tt = JIM_TT_EXPR_OPERATOR;
-    return JIM_OK;
-}
-
-struct Jim_ExprOperator *JimExprOperatorInfo(const char *opname)
-{
-    int i;
-    for (i = 0; i < (signed)JIM_EXPR_OPERATORS_NUM; i++)
-        if (Jim_ExprOperators[i].name &&
-            strcmp(opname, Jim_ExprOperators[i].name) == 0)
-            return &Jim_ExprOperators[i];
-    return NULL;
-}
-
-struct Jim_ExprOperator *JimExprOperatorInfoByOpcode(int opcode)
-{
-    int i;
-    for (i = 0; i < (signed)JIM_EXPR_OPERATORS_NUM; i++)
-        if (Jim_ExprOperators[i].opcode == opcode)
-            return &Jim_ExprOperators[i];
-    return NULL;
-}
-
-/* -----------------------------------------------------------------------------
- * Expression Object
- * ---------------------------------------------------------------------------*/
-static void FreeExprInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupExprInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static int SetExprFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType exprObjType = {
-    "expression",
-    FreeExprInternalRep,
-    DupExprInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* Expr bytecode structure */
-typedef struct ExprByteCode {
-    int *opcode;        /* Integer array of opcodes. */
-    Jim_Obj **obj;      /* Array of associated Jim Objects. */
-    int len;            /* Bytecode length */
-    int inUse;          /* Used for sharing. */
-} ExprByteCode;
-
-void FreeExprInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int i;
-    ExprByteCode *expr = (void*) objPtr->internalRep.ptr;
-
-    expr->inUse--;
-    if (expr->inUse != 0) return;
-    for (i = 0; i < expr->len; i++)
-        Jim_DecrRefCount(interp, expr->obj[i]);
-    Jim_Free(expr->opcode);
-    Jim_Free(expr->obj);
-    Jim_Free(expr);
-}
-
-void DupExprInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(srcPtr);
-
-    /* Just returns an simple string. */
-    dupPtr->typePtr = NULL;
-}
-
-/* Add a new instruction to an expression bytecode structure. */
-static void ExprObjAddInstr(Jim_Interp *interp, ExprByteCode *expr,
-        int opcode, char *str, int len)
-{
-    expr->opcode = Jim_Realloc(expr->opcode, sizeof(int)*(expr->len + 1));
-    expr->obj = Jim_Realloc(expr->obj, sizeof(Jim_Obj*)*(expr->len + 1));
-    expr->opcode[expr->len] = opcode;
-    expr->obj[expr->len] = Jim_NewStringObjNoAlloc(interp, str, len);
-    Jim_IncrRefCount(expr->obj[expr->len]);
-    expr->len++;
-}
-
-/* Check if an expr program looks correct. */
-static int ExprCheckCorrectness(ExprByteCode *expr)
-{
-    int i;
-    int stacklen = 0;
-
-    /* Try to check if there are stack underflows,
-     * and make sure at the end of the program there is
-     * a single result on the stack. */
-    for (i = 0; i < expr->len; i++) {
-        switch (expr->opcode[i]) {
-        case JIM_EXPROP_NUMBER:
-        case JIM_EXPROP_STRING:
-        case JIM_EXPROP_SUBST:
-        case JIM_EXPROP_VARIABLE:
-        case JIM_EXPROP_DICTSUGAR:
-        case JIM_EXPROP_COMMAND:
-            stacklen++;
-            break;
-        case JIM_EXPROP_NOT:
-        case JIM_EXPROP_BITNOT:
-        case JIM_EXPROP_UNARYMINUS:
-        case JIM_EXPROP_UNARYPLUS:
-            /* Unary operations */
-            if (stacklen < 1) return JIM_ERR;
-            break;
-        case JIM_EXPROP_ADD:
-        case JIM_EXPROP_SUB:
-        case JIM_EXPROP_MUL:
-        case JIM_EXPROP_DIV:
-        case JIM_EXPROP_MOD:
-        case JIM_EXPROP_LT:
-        case JIM_EXPROP_GT:
-        case JIM_EXPROP_LTE:
-        case JIM_EXPROP_GTE:
-        case JIM_EXPROP_ROTL:
-        case JIM_EXPROP_ROTR:
-        case JIM_EXPROP_LSHIFT:
-        case JIM_EXPROP_RSHIFT:
-        case JIM_EXPROP_NUMEQ:
-        case JIM_EXPROP_NUMNE:
-        case JIM_EXPROP_STREQ:
-        case JIM_EXPROP_STRNE:
-        case JIM_EXPROP_BITAND:
-        case JIM_EXPROP_BITXOR:
-        case JIM_EXPROP_BITOR:
-        case JIM_EXPROP_LOGICAND:
-        case JIM_EXPROP_LOGICOR:
-        case JIM_EXPROP_POW:
-            /* binary operations */
-            if (stacklen < 2) return JIM_ERR;
-            stacklen--;
-            break;
-        default:
-            Jim_Panic(NULL,"Default opcode reached ExprCheckCorrectness");
-            break;
-        }
-    }
-    if (stacklen != 1) return JIM_ERR;
-    return JIM_OK;
-}
-
-static void ExprShareLiterals(Jim_Interp *interp, ExprByteCode *expr,
-        ScriptObj *topLevelScript)
-{
-    int i;
-
-    return;
-    for (i = 0; i < expr->len; i++) {
-        Jim_Obj *foundObjPtr;
-
-        if (expr->obj[i] == NULL) continue;
-        foundObjPtr = ScriptSearchLiteral(interp, topLevelScript,
-                NULL, expr->obj[i]);
-        if (foundObjPtr != NULL) {
-            Jim_IncrRefCount(foundObjPtr);
-            Jim_DecrRefCount(interp, expr->obj[i]);
-            expr->obj[i] = foundObjPtr;
-        }
-    }
-}
-
-/* This procedure converts every occurrence of || and && opereators
- * in lazy unary versions.
- *
- * a b || is converted into:
- *
- * a <offset> |L b |R
- *
- * a b && is converted into:
- *
- * a <offset> &L b &R
- *
- * "|L" checks if 'a' is true:
- *   1) if it is true pushes 1 and skips <offset> istructions to reach
- *      the opcode just after |R.
- *   2) if it is false does nothing.
- * "|R" checks if 'b' is true:
- *   1) if it is true pushes 1, otherwise pushes 0.
- *
- * "&L" checks if 'a' is true:
- *   1) if it is true does nothing.
- *   2) If it is false pushes 0 and skips <offset> istructions to reach
- *      the opcode just after &R
- * "&R" checks if 'a' is true:
- *      if it is true pushes 1, otherwise pushes 0.
- */
-static void ExprMakeLazy(Jim_Interp *interp, ExprByteCode *expr)
-{
-    while (1) {
-        int index_t = -1, leftindex, arity, i, offset;
-        Jim_ExprOperator *op;
-
-        /* Search for || or && */
-        for (i = 0; i < expr->len; i++) {
-            if (expr->opcode[i] == JIM_EXPROP_LOGICAND ||
-                expr->opcode[i] == JIM_EXPROP_LOGICOR) {
-                index_t = i;
-                break;
-            }
-        }
-        if (index_t == -1) return;
-        /* Search for the end of the first operator */
-        leftindex = index_t-1;
-        arity = 1;
-        while (arity) {
-            switch (expr->opcode[leftindex]) {
-            case JIM_EXPROP_NUMBER:
-            case JIM_EXPROP_COMMAND:
-            case JIM_EXPROP_VARIABLE:
-            case JIM_EXPROP_DICTSUGAR:
-            case JIM_EXPROP_SUBST:
-            case JIM_EXPROP_STRING:
-                break;
-            default:
-                op = JimExprOperatorInfoByOpcode(expr->opcode[leftindex]);
-                if (op == NULL) {
-                    Jim_Panic(interp,"Default reached in ExprMakeLazy()");
-                }
-                arity += op->arity;
-                break;
-            }
-            arity--;
-            leftindex--;
-        }
-        leftindex++;
-        expr->opcode = Jim_Realloc(expr->opcode, sizeof(int)*(expr->len + 2));
-        expr->obj = Jim_Realloc(expr->obj, sizeof(Jim_Obj*)*(expr->len + 2));
-        memmove(&expr->opcode[leftindex + 2], &expr->opcode[leftindex],
-                sizeof(int)*(expr->len-leftindex));
-        memmove(&expr->obj[leftindex + 2], &expr->obj[leftindex],
-                sizeof(Jim_Obj*)*(expr->len-leftindex));
-        expr->len += 2;
-        index_t += 2;
-        offset = (index_t-leftindex)-1;
-        Jim_DecrRefCount(interp, expr->obj[index_t]);
-        if (expr->opcode[index_t] == JIM_EXPROP_LOGICAND) {
-            expr->opcode[leftindex + 1] = JIM_EXPROP_LOGICAND_LEFT;
-            expr->opcode[index_t] = JIM_EXPROP_LOGICAND_RIGHT;
-            expr->obj[leftindex + 1] = Jim_NewStringObj(interp, "&L", -1);
-            expr->obj[index_t] = Jim_NewStringObj(interp, "&R", -1);
-        } else {
-            expr->opcode[leftindex + 1] = JIM_EXPROP_LOGICOR_LEFT;
-            expr->opcode[index_t] = JIM_EXPROP_LOGICOR_RIGHT;
-            expr->obj[leftindex + 1] = Jim_NewStringObj(interp, "|L", -1);
-            expr->obj[index_t] = Jim_NewStringObj(interp, "|R", -1);
-        }
-        expr->opcode[leftindex] = JIM_EXPROP_NUMBER;
-        expr->obj[leftindex] = Jim_NewIntObj(interp, offset);
-        Jim_IncrRefCount(expr->obj[index_t]);
-        Jim_IncrRefCount(expr->obj[leftindex]);
-        Jim_IncrRefCount(expr->obj[leftindex + 1]);
-    }
-}
-
-/* This method takes the string representation of an expression
- * and generates a program for the Expr's stack-based VM. */
-int SetExprFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    int exprTextLen;
-    const char *exprText = Jim_GetString(objPtr, &exprTextLen);
-    struct JimParserCtx parser;
-    int i, shareLiterals;
-    ExprByteCode *expr = Jim_Alloc(sizeof(*expr));
-    Jim_Stack stack;
-    Jim_ExprOperator *op;
-
-    /* Perform literal sharing with the current procedure
-     * running only if this expression appears to be not generated
-     * at runtime. */
-    shareLiterals = objPtr->typePtr == &sourceObjType;
-
-    expr->opcode = NULL;
-    expr->obj = NULL;
-    expr->len = 0;
-    expr->inUse = 1;
-
-    Jim_InitStack(&stack);
-    JimParserInit(&parser, exprText, exprTextLen, 1);
-    while (!JimParserEof(&parser)) {
-        char *token;
-        int len, type;
-
-        if (JimParseExpression(&parser) != JIM_OK) {
-            Jim_SetResultString(interp, "Syntax error in expression", -1);
-            goto err;
-        }
-        token = JimParserGetToken(&parser, &len, &type, NULL);
-        if (type == JIM_TT_EOL) {
-            Jim_Free(token);
-            break;
-        }
-        switch (type) {
-        case JIM_TT_STR:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_STRING, token, len);
-            break;
-        case JIM_TT_ESC:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_SUBST, token, len);
-            break;
-        case JIM_TT_VAR:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_VARIABLE, token, len);
-            break;
-        case JIM_TT_DICTSUGAR:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_DICTSUGAR, token, len);
-            break;
-        case JIM_TT_CMD:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_COMMAND, token, len);
-            break;
-        case JIM_TT_EXPR_NUMBER:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_NUMBER, token, len);
-            break;
-        case JIM_TT_EXPR_OPERATOR:
-            op = JimExprOperatorInfo(token);
-            while (1) {
-                Jim_ExprOperator *stackTopOp;
-
-                if (Jim_StackPeek(&stack) != NULL) {
-                    stackTopOp = JimExprOperatorInfo(Jim_StackPeek(&stack));
-                } else {
-                    stackTopOp = NULL;
-                }
-                if (Jim_StackLen(&stack) && op->arity != 1 &&
-                    stackTopOp && stackTopOp->precedence >= op->precedence)
-                {
-                    ExprObjAddInstr(interp, expr, stackTopOp->opcode,
-                        Jim_StackPeek(&stack), -1);
-                    Jim_StackPop(&stack);
-                } else {
-                    break;
-                }
-            }
-            Jim_StackPush(&stack, token);
-            break;
-        case JIM_TT_SUBEXPR_START:
-            Jim_StackPush(&stack, Jim_StrDup("("));
-            Jim_Free(token);
-            break;
-        case JIM_TT_SUBEXPR_END:
-            {
-                int found = 0;
-                while (Jim_StackLen(&stack)) {
-                    char *opstr = Jim_StackPop(&stack);
-                    if (!strcmp(opstr, "(")) {
-                        Jim_Free(opstr);
-                        found = 1;
-                        break;
-                    }
-                    op = JimExprOperatorInfo(opstr);
-                    ExprObjAddInstr(interp, expr, op->opcode, opstr, -1);
-                }
-                if (!found) {
-                    Jim_SetResultString(interp,
-                        "Unexpected close parenthesis", -1);
-                    goto err;
-                }
-            }
-            Jim_Free(token);
-            break;
-        default:
-            Jim_Panic(interp,"Default reached in SetExprFromAny()");
-            break;
-        }
-    }
-    while (Jim_StackLen(&stack)) {
-        char *opstr = Jim_StackPop(&stack);
-        op = JimExprOperatorInfo(opstr);
-        if (op == NULL && !strcmp(opstr, "(")) {
-            Jim_Free(opstr);
-            Jim_SetResultString(interp, "Missing close parenthesis", -1);
-            goto err;
-        }
-        ExprObjAddInstr(interp, expr, op->opcode, opstr, -1);
-    }
-    /* Check program correctness. */
-    if (ExprCheckCorrectness(expr) != JIM_OK) {
-        Jim_SetResultString(interp, "Invalid expression", -1);
-        goto err;
-    }
-
-    /* Free the stack used for the compilation. */
-    Jim_FreeStackElements(&stack, Jim_Free);
-    Jim_FreeStack(&stack);
-
-    /* Convert || and && operators in unary |L |R and &L &R for lazyness */
-    ExprMakeLazy(interp, expr);
-
-    /* Perform literal sharing */
-    if (shareLiterals && interp->framePtr->procBodyObjPtr) {
-        Jim_Obj *bodyObjPtr = interp->framePtr->procBodyObjPtr;
-        if (bodyObjPtr->typePtr == &scriptObjType) {
-            ScriptObj *bodyScript = bodyObjPtr->internalRep.ptr;
-            ExprShareLiterals(interp, expr, bodyScript);
-        }
-    }
-
-    /* Free the old internal rep and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    Jim_SetIntRepPtr(objPtr, expr);
-    objPtr->typePtr = &exprObjType;
-    return JIM_OK;
-
-err:    /* we jump here on syntax/compile errors. */
-    Jim_FreeStackElements(&stack, Jim_Free);
-    Jim_FreeStack(&stack);
-    Jim_Free(expr->opcode);
-    for (i = 0; i < expr->len; i++) {
-        Jim_DecrRefCount(interp,expr->obj[i]);
-    }
-    Jim_Free(expr->obj);
-    Jim_Free(expr);
-    return JIM_ERR;
-}
-
-ExprByteCode *Jim_GetExpression(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    if (objPtr->typePtr != &exprObjType) {
-        if (SetExprFromAny(interp, objPtr) != JIM_OK)
-            return NULL;
-    }
-    return (ExprByteCode*) Jim_GetIntRepPtr(objPtr);
-}
-
-/* -----------------------------------------------------------------------------
- * Expressions evaluation.
- * Jim uses a specialized stack-based virtual machine for expressions,
- * that takes advantage of the fact that expr's operators
- * can't be redefined.
- *
- * Jim_EvalExpression() uses the bytecode compiled by
- * SetExprFromAny() method of the "expression" object.
- *
- * On success a Tcl Object containing the result of the evaluation
- * is stored into expResultPtrPtr (having refcount of 1), and JIM_OK is
- * returned.
- * On error the function returns a retcode != to JIM_OK and set a suitable
- * error on the interp.
- * ---------------------------------------------------------------------------*/
-#define JIM_EE_STATICSTACK_LEN 10
-
-int Jim_EvalExpression(Jim_Interp *interp, Jim_Obj *exprObjPtr,
-        Jim_Obj **exprResultPtrPtr)
-{
-    ExprByteCode *expr;
-    Jim_Obj **stack, *staticStack[JIM_EE_STATICSTACK_LEN];
-    int stacklen = 0, i, error = 0, errRetCode = JIM_ERR;
-
-    Jim_IncrRefCount(exprObjPtr);
-    expr = Jim_GetExpression(interp, exprObjPtr);
-    if (!expr) {
-        Jim_DecrRefCount(interp, exprObjPtr);
-        return JIM_ERR; /* error in expression. */
-    }
-    /* In order to avoid that the internal repr gets freed due to
-     * shimmering of the exprObjPtr's object, we make the internal rep
-     * shared. */
-    expr->inUse++;
-
-    /* The stack-based expr VM itself */
-
-    /* Stack allocation. Expr programs have the feature that
-     * a program of length N can't require a stack longer than
-     * N. */
-    if (expr->len > JIM_EE_STATICSTACK_LEN)
-        stack = Jim_Alloc(sizeof(Jim_Obj*)*expr->len);
-    else
-        stack = staticStack;
-
-    /* Execute every istruction */
-    for (i = 0; i < expr->len; i++) {
-        Jim_Obj *A, *B, *objPtr;
-        jim_wide wA, wB, wC;
-        double dA, dB, dC;
-        const char *sA, *sB;
-        int Alen, Blen, retcode;
-        int opcode = expr->opcode[i];
-
-        if (opcode == JIM_EXPROP_NUMBER || opcode == JIM_EXPROP_STRING) {
-            stack[stacklen++] = expr->obj[i];
-            Jim_IncrRefCount(expr->obj[i]);
-        } else if (opcode == JIM_EXPROP_VARIABLE) {
-            objPtr = Jim_GetVariable(interp, expr->obj[i], JIM_ERRMSG);
-            if (objPtr == NULL) {
-                error = 1;
-                goto err;
-            }
-            stack[stacklen++] = objPtr;
-            Jim_IncrRefCount(objPtr);
-        } else if (opcode == JIM_EXPROP_SUBST) {
-            if ((retcode = Jim_SubstObj(interp, expr->obj[i],
-                        &objPtr, JIM_NONE)) != JIM_OK)
-            {
-                error = 1;
-                errRetCode = retcode;
-                goto err;
-            }
-            stack[stacklen++] = objPtr;
-            Jim_IncrRefCount(objPtr);
-        } else if (opcode == JIM_EXPROP_DICTSUGAR) {
-            objPtr = Jim_ExpandDictSugar(interp, expr->obj[i]);
-            if (objPtr == NULL) {
-                error = 1;
-                goto err;
-            }
-            stack[stacklen++] = objPtr;
-            Jim_IncrRefCount(objPtr);
-        } else if (opcode == JIM_EXPROP_COMMAND) {
-            if ((retcode = Jim_EvalObj(interp, expr->obj[i])) != JIM_OK) {
-                error = 1;
-                errRetCode = retcode;
-                goto err;
-            }
-            stack[stacklen++] = interp->result;
-            Jim_IncrRefCount(interp->result);
-        } else if (opcode >= JIM_EXPROP_BINARY_NUM_FIRST &&
-                   opcode <= JIM_EXPROP_BINARY_NUM_LAST)
-        {
-            /* Note that there isn't to increment the
-             * refcount of objects. the references are moved
-             * from stack to A and B. */
-            B = stack[--stacklen];
-            A = stack[--stacklen];
-
-            /* --- Integer --- */
-            if ((A->typePtr == &doubleObjType && !A->bytes) ||
-                (B->typePtr == &doubleObjType && !B->bytes) ||
-                JimGetWideNoErr(interp, A, &wA) != JIM_OK ||
-                JimGetWideNoErr(interp, B, &wB) != JIM_OK) {
-                goto trydouble;
-            }
-            Jim_DecrRefCount(interp, A);
-            Jim_DecrRefCount(interp, B);
-            switch (expr->opcode[i]) {
-            case JIM_EXPROP_ADD: wC = wA + wB; break;
-            case JIM_EXPROP_SUB: wC = wA-wB; break;
-            case JIM_EXPROP_MUL: wC = wA*wB; break;
-            case JIM_EXPROP_LT: wC = wA < wB; break;
-            case JIM_EXPROP_GT: wC = wA > wB; break;
-            case JIM_EXPROP_LTE: wC = wA <= wB; break;
-            case JIM_EXPROP_GTE: wC = wA >= wB; break;
-            case JIM_EXPROP_LSHIFT: wC = wA << wB; break;
-            case JIM_EXPROP_RSHIFT: wC = wA >> wB; break;
-            case JIM_EXPROP_NUMEQ: wC = wA == wB; break;
-            case JIM_EXPROP_NUMNE: wC = wA != wB; break;
-            case JIM_EXPROP_BITAND: wC = wA&wB; break;
-            case JIM_EXPROP_BITXOR: wC = wA^wB; break;
-            case JIM_EXPROP_BITOR: wC = wA | wB; break;
-            case JIM_EXPROP_POW: wC = JimPowWide(wA,wB); break;
-            case JIM_EXPROP_LOGICAND_LEFT:
-                if (wA == 0) {
-                    i += (int)wB;
-                    wC = 0;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_LOGICOR_LEFT:
-                if (wA != 0) {
-                    i += (int)wB;
-                    wC = 1;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_DIV:
-                if (wB == 0) goto divbyzero;
-                wC = wA/wB;
-                break;
-            case JIM_EXPROP_MOD:
-                if (wB == 0) goto divbyzero;
-                wC = wA%wB;
-                break;
-            case JIM_EXPROP_ROTL: {
-                /* uint32_t would be better. But not everyone has inttypes.h?*/
-                unsigned long uA = (unsigned long)wA;
-#ifdef _MSC_VER
-                wC = _rotl(uA,(unsigned long)wB);
-#else
-                const unsigned int S = sizeof(unsigned long) * 8;
-                wC = (unsigned long)((uA << wB) | (uA >> (S-wB)));
-#endif
-                break;
-            }
-            case JIM_EXPROP_ROTR: {
-                unsigned long uA = (unsigned long)wA;
-#ifdef _MSC_VER
-                wC = _rotr(uA,(unsigned long)wB);
-#else
-                const unsigned int S = sizeof(unsigned long) * 8;
-                wC = (unsigned long)((uA >> wB) | (uA << (S-wB)));
-#endif
-                break;
-            }
-
-            default:
-                wC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewIntObj(interp, wC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-            continue;
-trydouble:
-            /* --- Double --- */
-            if (Jim_GetDouble(interp, A, &dA) != JIM_OK ||
-                Jim_GetDouble(interp, B, &dB) != JIM_OK) {
-
-                /* Hmmm! For compatibility, maybe convert != and == into ne and eq */
-                if (expr->opcode[i] == JIM_EXPROP_NUMNE) {
-                    opcode = JIM_EXPROP_STRNE;
-                    goto retry_as_string;
-                }
-                else if (expr->opcode[i] == JIM_EXPROP_NUMEQ) {
-                    opcode = JIM_EXPROP_STREQ;
-                    goto retry_as_string;
-                }
-                Jim_DecrRefCount(interp, A);
-                Jim_DecrRefCount(interp, B);
-                error = 1;
-                goto err;
-            }
-            Jim_DecrRefCount(interp, A);
-            Jim_DecrRefCount(interp, B);
-            switch (expr->opcode[i]) {
-            case JIM_EXPROP_ROTL:
-            case JIM_EXPROP_ROTR:
-            case JIM_EXPROP_LSHIFT:
-            case JIM_EXPROP_RSHIFT:
-            case JIM_EXPROP_BITAND:
-            case JIM_EXPROP_BITXOR:
-            case JIM_EXPROP_BITOR:
-            case JIM_EXPROP_MOD:
-            case JIM_EXPROP_POW:
-                Jim_SetResultString(interp,
-                    "Got floating-point value where integer was expected", -1);
-                error = 1;
-                goto err;
-            case JIM_EXPROP_ADD: dC = dA + dB; break;
-            case JIM_EXPROP_SUB: dC = dA-dB; break;
-            case JIM_EXPROP_MUL: dC = dA*dB; break;
-            case JIM_EXPROP_LT: dC = dA < dB; break;
-            case JIM_EXPROP_GT: dC = dA > dB; break;
-            case JIM_EXPROP_LTE: dC = dA <= dB; break;
-            case JIM_EXPROP_GTE: dC = dA >= dB; break;
-	    /* FIXME comparing floats for equality/inequality is bad juju */
-            case JIM_EXPROP_NUMEQ: dC = dA == dB; break;
-            case JIM_EXPROP_NUMNE: dC = dA != dB; break;
-            case JIM_EXPROP_LOGICAND_LEFT:
-                if (dA == 0) {
-                    i += (int)dB;
-                    dC = 0;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_LOGICOR_LEFT:
-                if (dA != 0) {
-                    i += (int)dB;
-                    dC = 1;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_DIV:
-                if (dB == 0) goto divbyzero;
-                dC = dA/dB;
-                break;
-            default:
-                dC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewDoubleObj(interp, dC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-        } else if (opcode == JIM_EXPROP_STREQ || opcode == JIM_EXPROP_STRNE) {
-            B = stack[--stacklen];
-            A = stack[--stacklen];
-retry_as_string:
-            sA = Jim_GetString(A, &Alen);
-            sB = Jim_GetString(B, &Blen);
-            switch (opcode) {
-            case JIM_EXPROP_STREQ:
-                if (Alen == Blen && memcmp(sA, sB, Alen) ==0)
-                    wC = 1;
-                else
-                    wC = 0;
-                break;
-            case JIM_EXPROP_STRNE:
-                if (Alen != Blen || memcmp(sA, sB, Alen) != 0)
-                    wC = 1;
-                else
-                    wC = 0;
-                break;
-            default:
-                wC = 0; /* avoid gcc warning */
-                break;
-            }
-            Jim_DecrRefCount(interp, A);
-            Jim_DecrRefCount(interp, B);
-            stack[stacklen] = Jim_NewIntObj(interp, wC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-        } else if (opcode == JIM_EXPROP_NOT ||
-                   opcode == JIM_EXPROP_BITNOT ||
-                   opcode == JIM_EXPROP_LOGICAND_RIGHT ||
-                   opcode == JIM_EXPROP_LOGICOR_RIGHT) {
-            /* Note that there isn't to increment the
-             * refcount of objects. the references are moved
-             * from stack to A and B. */
-            A = stack[--stacklen];
-
-            /* --- Integer --- */
-            if ((A->typePtr == &doubleObjType && !A->bytes) ||
-                JimGetWideNoErr(interp, A, &wA) != JIM_OK) {
-                goto trydouble_unary;
-            }
-            Jim_DecrRefCount(interp, A);
-            switch (expr->opcode[i]) {
-            case JIM_EXPROP_NOT: wC = !wA; break;
-            case JIM_EXPROP_BITNOT: wC = ~wA; break;
-            case JIM_EXPROP_LOGICAND_RIGHT:
-            case JIM_EXPROP_LOGICOR_RIGHT: wC = (wA != 0); break;
-            default:
-                wC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewIntObj(interp, wC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-            continue;
-trydouble_unary:
-            /* --- Double --- */
-            if (Jim_GetDouble(interp, A, &dA) != JIM_OK) {
-                Jim_DecrRefCount(interp, A);
-                error = 1;
-                goto err;
-            }
-            Jim_DecrRefCount(interp, A);
-            switch (expr->opcode[i]) {
-            case JIM_EXPROP_NOT: dC = !dA; break;
-            case JIM_EXPROP_LOGICAND_RIGHT:
-            case JIM_EXPROP_LOGICOR_RIGHT: dC = (dA != 0); break;
-            case JIM_EXPROP_BITNOT:
-                Jim_SetResultString(interp,
-                    "Got floating-point value where integer was expected", -1);
-                error = 1;
-                goto err;
-                break;
-            default:
-                dC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewDoubleObj(interp, dC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-        } else {
-            Jim_Panic(interp,"Unknown opcode in Jim_EvalExpression");
-        }
-    }
-err:
-    /* There is no need to decerement the inUse field because
-     * this reference is transfered back into the exprObjPtr. */
-    Jim_FreeIntRep(interp, exprObjPtr);
-    exprObjPtr->typePtr = &exprObjType;
-    Jim_SetIntRepPtr(exprObjPtr, expr);
-    Jim_DecrRefCount(interp, exprObjPtr);
-    if (!error) {
-        *exprResultPtrPtr = stack[0];
-        Jim_IncrRefCount(stack[0]);
-        errRetCode = JIM_OK;
-    }
-    for (i = 0; i < stacklen; i++) {
-        Jim_DecrRefCount(interp, stack[i]);
-    }
-    if (stack != staticStack)
-        Jim_Free(stack);
-    return errRetCode;
-divbyzero:
-    error = 1;
-    Jim_SetResultString(interp, "Division by zero", -1);
-    goto err;
-}
-
-int Jim_GetBoolFromExpr(Jim_Interp *interp, Jim_Obj *exprObjPtr, int *boolPtr)
-{
-    int retcode;
-    jim_wide wideValue;
-    double doubleValue;
-    Jim_Obj *exprResultPtr;
-
-    retcode = Jim_EvalExpression(interp, exprObjPtr, &exprResultPtr);
-    if (retcode != JIM_OK)
-        return retcode;
-    if (JimGetWideNoErr(interp, exprResultPtr, &wideValue) != JIM_OK) {
-        if (Jim_GetDouble(interp, exprResultPtr, &doubleValue) != JIM_OK)
-        {
-            Jim_DecrRefCount(interp, exprResultPtr);
-            return JIM_ERR;
-        } else {
-            Jim_DecrRefCount(interp, exprResultPtr);
-            *boolPtr = doubleValue != 0;
-            return JIM_OK;
-        }
-    }
-    Jim_DecrRefCount(interp, exprResultPtr);
-    *boolPtr = wideValue != 0;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * ScanFormat String Object
- * ---------------------------------------------------------------------------*/
-
-/* This Jim_Obj will held a parsed representation of a format string passed to
- * the Jim_ScanString command. For error diagnostics, the scanformat string has
- * to be parsed in its entirely first and then, if correct, can be used for
- * scanning. To avoid endless re-parsing, the parsed representation will be
- * stored in an internal representation and re-used for performance reason. */
-
-/* A ScanFmtPartDescr will held the information of /one/ part of the whole
- * scanformat string. This part will later be used to extract information
- * out from the string to be parsed by Jim_ScanString */
-
-typedef struct ScanFmtPartDescr {
-    char type;         /* Type of conversion (e.g. c, d, f) */
-    char modifier;     /* Modify type (e.g. l - long, h - short */
-    size_t  width;     /* Maximal width of input to be converted */
-    int  pos;          /* -1 - no assign, 0 - natural pos, >0 - XPG3 pos */
-    char *arg;         /* Specification of a CHARSET conversion */
-    char *prefix;      /* Prefix to be scanned literally before conversion */
-} ScanFmtPartDescr;
-
-/* The ScanFmtStringObj will held the internal representation of a scanformat
- * string parsed and separated in part descriptions. Furthermore it contains
- * the original string representation of the scanformat string to allow for
- * fast update of the Jim_Obj's string representation part.
- *
- * As add-on the internal object representation add some scratch pad area
- * for usage by Jim_ScanString to avoid endless allocating and freeing of
- * memory for purpose of string scanning.
- *
- * The error member points to a static allocated string in case of a mal-
- * formed scanformat string or it contains '0' (NULL) in case of a valid
- * parse representation.
- *
- * The whole memory of the internal representation is allocated as a single
- * area of memory that will be internally separated. So freeing and duplicating
- * of such an object is cheap */
-
-typedef struct ScanFmtStringObj {
-    jim_wide        size;         /* Size of internal repr in bytes */
-    char            *stringRep;   /* Original string representation */
-    size_t          count;        /* Number of ScanFmtPartDescr contained */
-    size_t          convCount;    /* Number of conversions that will assign */
-    size_t          maxPos;       /* Max position index if XPG3 is used */
-    const char      *error;       /* Ptr to error text (NULL if no error */
-    char            *scratch;     /* Some scratch pad used by Jim_ScanString */
-    ScanFmtPartDescr descr[1];    /* The vector of partial descriptions */
-} ScanFmtStringObj;
-
-
-static void FreeScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static void UpdateStringOfScanFmt(Jim_Obj *objPtr);
-
-static Jim_ObjType scanFmtStringObjType = {
-    "scanformatstring",
-    FreeScanFmtInternalRep,
-    DupScanFmtInternalRep,
-    UpdateStringOfScanFmt,
-    JIM_TYPE_NONE,
-};
-
-void FreeScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    JIM_NOTUSED(interp);
-    Jim_Free((char*)objPtr->internalRep.ptr);
-    objPtr->internalRep.ptr = 0;
-}
-
-void DupScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    size_t size = (size_t)((ScanFmtStringObj*)srcPtr->internalRep.ptr)->size;
-    ScanFmtStringObj *newVec = (ScanFmtStringObj*)Jim_Alloc(size);
-
-    JIM_NOTUSED(interp);
-    memcpy(newVec, srcPtr->internalRep.ptr, size);
-    dupPtr->internalRep.ptr = newVec;
-    dupPtr->typePtr = &scanFmtStringObjType;
-}
-
-void UpdateStringOfScanFmt(Jim_Obj *objPtr)
-{
-    char *bytes = ((ScanFmtStringObj*)objPtr->internalRep.ptr)->stringRep;
-
-    objPtr->bytes = Jim_StrDup(bytes);
-    objPtr->length = strlen(bytes);
-}
-
-/* SetScanFmtFromAny will parse a given string and create the internal
- * representation of the format specification. In case of an error
- * the error data member of the internal representation will be set
- * to an descriptive error text and the function will be left with
- * JIM_ERR to indicate unsucessful parsing (aka. malformed scanformat
- * specification */
-
-static int SetScanFmtFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    ScanFmtStringObj *fmtObj;
-    char *buffer;
-    int maxCount, i, approxSize, lastPos = -1;
-    const char *fmt = objPtr->bytes;
-    int maxFmtLen = objPtr->length;
-    const char *fmtEnd = fmt + maxFmtLen;
-    int curr;
-
-    Jim_FreeIntRep(interp, objPtr);
-    /* Count how many conversions could take place maximally */
-    for (i = 0, maxCount = 0; i < maxFmtLen; ++i)
-        if (fmt[i] == '%')
-            ++maxCount;
-    /* Calculate an approximation of the memory necessary */
-    approxSize = sizeof(ScanFmtStringObj)           /* Size of the container */
-        + (maxCount + 1) * sizeof(ScanFmtPartDescr) /* Size of all partials */
-        + maxFmtLen * sizeof(char) + 3 + 1          /* Scratch + "%n" + '\0' */
-        + maxFmtLen * sizeof(char) + 1              /* Original stringrep */
-        + maxFmtLen * sizeof(char)                  /* Arg for CHARSETs */
-        + (maxCount +1) * sizeof(char)              /* '\0' for every partial */
-        + 1;                                        /* safety byte */
-    fmtObj = (ScanFmtStringObj*)Jim_Alloc(approxSize);
-    memset(fmtObj, 0, approxSize);
-    fmtObj->size = approxSize;
-    fmtObj->maxPos = 0;
-    fmtObj->scratch = (char*)&fmtObj->descr[maxCount + 1];
-    fmtObj->stringRep = fmtObj->scratch + maxFmtLen + 3 + 1;
-    memcpy(fmtObj->stringRep, fmt, maxFmtLen);
-    buffer = fmtObj->stringRep + maxFmtLen + 1;
-    objPtr->internalRep.ptr = fmtObj;
-    objPtr->typePtr = &scanFmtStringObjType;
-    for (i = 0, curr = 0; fmt < fmtEnd; ++fmt) {
-        int width = 0, skip;
-        ScanFmtPartDescr *descr = &fmtObj->descr[curr];
-        fmtObj->count++;
-        descr->width = 0;                   /* Assume width unspecified */
-        /* Overread and store any "literal" prefix */
-        if (*fmt != '%' || fmt[1] == '%') {
-            descr->type = 0;
-            descr->prefix = &buffer[i];
-            for (; fmt < fmtEnd; ++fmt) {
-                if (*fmt == '%') {
-                    if (fmt[1] != '%') break;
-                    ++fmt;
-                }
-                buffer[i++] = *fmt;
-            }
-            buffer[i++] = 0;
-        }
-        /* Skip the conversion introducing '%' sign */
-        ++fmt;
-        /* End reached due to non-conversion literal only? */
-        if (fmt >= fmtEnd)
-            goto done;
-        descr->pos = 0;                     /* Assume "natural" positioning */
-        if (*fmt == '*') {
-            descr->pos = -1;       /* Okay, conversion will not be assigned */
-            ++fmt;
-        } else
-            fmtObj->convCount++;    /* Otherwise count as assign-conversion */
-        /* Check if next token is a number (could be width or pos */
-        if (sscanf(fmt, "%d%n", &width, &skip) == 1) {
-            fmt += skip;
-            /* Was the number a XPG3 position specifier? */
-            if (descr->pos != -1 && *fmt == '$') {
-                int prev;
-                ++fmt;
-                descr->pos = width;
-                width = 0;
-                /* Look if "natural" postioning and XPG3 one was mixed */
-                if ((lastPos == 0 && descr->pos > 0)
-                        || (lastPos > 0 && descr->pos == 0)) {
-                    fmtObj->error = "cannot mix \"%\" and \"%n$\" conversion specifiers";
-                    return JIM_ERR;
-                }
-                /* Look if this position was already used */
-                for (prev = 0; prev < curr; ++prev) {
-                    if (fmtObj->descr[prev].pos == -1) continue;
-                    if (fmtObj->descr[prev].pos == descr->pos) {
-                        fmtObj->error = "same \"%n$\" conversion specifier "
-                            "used more than once";
-                        return JIM_ERR;
-                    }
-                }
-                /* Try to find a width after the XPG3 specifier */
-                if (sscanf(fmt, "%d%n", &width, &skip) == 1) {
-                    descr->width = width;
-                    fmt += skip;
-                }
-                if (descr->pos > 0 && (size_t)descr->pos > fmtObj->maxPos)
-                    fmtObj->maxPos = descr->pos;
-            } else {
-                /* Number was not a XPG3, so it has to be a width */
-                descr->width = width;
-            }
-        }
-        /* If positioning mode was undetermined yet, fix this */
-        if (lastPos == -1)
-            lastPos = descr->pos;
-        /* Handle CHARSET conversion type ... */
-        if (*fmt == '[') {
-            int swapped = 1, beg = i, end, j;
-            descr->type = '[';
-            descr->arg = &buffer[i];
-            ++fmt;
-            if (*fmt == '^') buffer[i++] = *fmt++;
-            if (*fmt == ']') buffer[i++] = *fmt++;
-            while (*fmt && *fmt != ']') buffer[i++] = *fmt++;
-            if (*fmt != ']') {
-                fmtObj->error = "unmatched [ in format string";
-                return JIM_ERR;
-            }
-            end = i;
-            buffer[i++] = 0;
-            /* In case a range fence was given "backwards", swap it */
-            while (swapped) {
-                swapped = 0;
-                for (j = beg + 1; j < end-1; ++j) {
-                    if (buffer[j] == '-' && buffer[j-1] > buffer[j + 1]) {
-                        char tmp = buffer[j-1];
-                        buffer[j-1] = buffer[j + 1];
-                        buffer[j + 1] = tmp;
-                        swapped = 1;
-                    }
-                }
-            }
-        } else {
-            /* Remember any valid modifier if given */
-            if (strchr("hlL", *fmt) != 0)
-                descr->modifier = tolower((int)*fmt++);
-
-            descr->type = *fmt;
-            if (strchr("efgcsndoxui", *fmt) == 0) {
-                fmtObj->error = "bad scan conversion character";
-                return JIM_ERR;
-            } else if (*fmt == 'c' && descr->width != 0) {
-                fmtObj->error = "field width may not be specified in %c "
-                    "conversion";
-                return JIM_ERR;
-            } else if (*fmt == 'u' && descr->modifier == 'l') {
-                fmtObj->error = "unsigned wide not supported";
-                return JIM_ERR;
-            }
-        }
-        curr++;
-    }
-done:
-    if (fmtObj->convCount == 0) {
-        fmtObj->error = "no any conversion specifier given";
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* Some accessor macros to allow lowlevel access to fields of internal repr */
-
-#define FormatGetCnvCount(_fo_) \
-    ((ScanFmtStringObj*)((_fo_)->internalRep.ptr))->convCount
-#define FormatGetMaxPos(_fo_) \
-    ((ScanFmtStringObj*)((_fo_)->internalRep.ptr))->maxPos
-#define FormatGetError(_fo_) \
-    ((ScanFmtStringObj*)((_fo_)->internalRep.ptr))->error
-
-/* Some Bit testing/setting/cleaning routines. For now only used in handling
- * charsets ([a-z123]) within scanning. Later on perhaps a base for a
- * bitvector implementation in Jim? */
-
-static int JimTestBit(const char *bitvec, char ch)
-{
-    div_t pos = div(ch-1, 8);
-    return bitvec[pos.quot] & (1 << pos.rem);
-}
-
-static void JimSetBit(char *bitvec, char ch)
-{
-    div_t pos = div(ch-1, 8);
-    bitvec[pos.quot] |= (1 << pos.rem);
-}
-
-#if 0 /* currently not used */
-static void JimClearBit(char *bitvec, char ch)
-{
-    div_t pos = div(ch-1, 8);
-    bitvec[pos.quot] &= ~(1 << pos.rem);
-}
-#endif
-
-/* JimScanAString is used to scan an unspecified string that ends with
- * next WS, or a string that is specified via a charset. The charset
- * is currently implemented in a way to only allow for usage with
- * ASCII. Whenever we will switch to UNICODE, another idea has to
- * be born :-/
- *
- * FIXME: Works only with ASCII */
-
-static Jim_Obj *
-JimScanAString(Jim_Interp *interp, const char *sdescr, const char *str)
-{
-    size_t i;
-    Jim_Obj *result;
-    char charset[256/8 + 1];  /* A Charset may contain max 256 chars */
-    char *buffer = Jim_Alloc(strlen(str) + 1), *anchor = buffer;
-
-    /* First init charset to nothing or all, depending if a specified
-     * or an unspecified string has to be parsed */
-    memset(charset, (sdescr ? 0 : 255), sizeof(charset));
-    if (sdescr) {
-        /* There was a set description given, that means we are parsing
-         * a specified string. So we have to build a corresponding
-         * charset reflecting the description */
-        int notFlag = 0;
-        /* Should the set be negated at the end? */
-        if (*sdescr == '^') {
-            notFlag = 1;
-            ++sdescr;
-        }
-        /* Here '-' is meant literally and not to define a range */
-        if (*sdescr == '-') {
-            JimSetBit(charset, '-');
-            ++sdescr;
-        }
-        while (*sdescr) {
-            if (sdescr[1] == '-' && sdescr[2] != 0) {
-                /* Handle range definitions */
-                int i_t;
-                for (i_t = sdescr[0]; i_t <= sdescr[2]; ++i_t)
-                    JimSetBit(charset, (char)i_t);
-                sdescr += 3;
-            } else {
-                /* Handle verbatim character definitions */
-                JimSetBit(charset, *sdescr++);
-            }
-        }
-        /* Negate the charset if there was a NOT given */
-        for (i = 0; notFlag && i < sizeof(charset); ++i)
-            charset[i] = ~charset[i];
-    }
-    /* And after all the mess above, the real work begin ... */
-    while (str && *str) {
-        if (!sdescr && isspace((int)*str))
-            break; /* EOS via WS if unspecified */
-        if (JimTestBit(charset, *str)) *buffer++ = *str++;
-        else break;             /* EOS via mismatch if specified scanning */
-    }
-    *buffer = 0;                /* Close the string properly ... */
-    result = Jim_NewStringObj(interp, anchor, -1);
-    Jim_Free(anchor);           /* ... and free it afer usage */
-    return result;
-}
-
-/* ScanOneEntry will scan one entry out of the string passed as argument.
- * It use the sscanf() function for this task. After extracting and
- * converting of the value, the count of scanned characters will be
- * returned of -1 in case of no conversion tool place and string was
- * already scanned thru */
-
-static int ScanOneEntry(Jim_Interp *interp, const char *str, long pos,
-        ScanFmtStringObj *fmtObj, long index_t, Jim_Obj **valObjPtr)
-{
-#   define MAX_SIZE (sizeof(jim_wide) > sizeof(double) \
-        ? sizeof(jim_wide)                             \
-        : sizeof(double))
-    char buffer[MAX_SIZE];
-    char *value = buffer;
-    const char *tok;
-    const ScanFmtPartDescr *descr = &fmtObj->descr[index_t];
-    size_t sLen = strlen(&str[pos]), scanned = 0;
-    size_t anchor = pos;
-    int i;
-
-    /* First pessimiticly assume, we will not scan anything :-) */
-    *valObjPtr = 0;
-    if (descr->prefix) {
-        /* There was a prefix given before the conversion, skip it and adjust
-         * the string-to-be-parsed accordingly */
-        for (i = 0; str[pos] && descr->prefix[i]; ++i) {
-            /* If prefix require, skip WS */
-            if (isspace((int)descr->prefix[i]))
-                while (str[pos] && isspace((int)str[pos])) ++pos;
-            else if (descr->prefix[i] != str[pos])
-                break;  /* Prefix do not match here, leave the loop */
-            else
-                ++pos;  /* Prefix matched so far, next round */
-        }
-        if (str[pos] == 0)
-            return -1;  /* All of str consumed: EOF condition */
-        else if (descr->prefix[i] != 0)
-            return 0;   /* Not whole prefix consumed, no conversion possible */
-    }
-    /* For all but following conversion, skip leading WS */
-    if (descr->type != 'c' && descr->type != '[' && descr->type != 'n')
-        while (isspace((int)str[pos])) ++pos;
-    /* Determine how much skipped/scanned so far */
-    scanned = pos - anchor;
-    if (descr->type == 'n') {
-        /* Return pseudo conversion means: how much scanned so far? */
-        *valObjPtr = Jim_NewIntObj(interp, anchor + scanned);
-    } else if (str[pos] == 0) {
-        /* Cannot scan anything, as str is totally consumed */
-        return -1;
-    } else {
-        /* Processing of conversions follows ... */
-        if (descr->width > 0) {
-            /* Do not try to scan as fas as possible but only the given width.
-             * To ensure this, we copy the part that should be scanned. */
-            size_t tLen = descr->width > sLen ? sLen : descr->width;
-            tok = Jim_StrDupLen(&str[pos], tLen);
-        } else {
-            /* As no width was given, simply refer to the original string */
-            tok = &str[pos];
-        }
-        switch (descr->type) {
-            case 'c':
-                *valObjPtr = Jim_NewIntObj(interp, *tok);
-                scanned += 1;
-                break;
-            case 'd': case 'o': case 'x': case 'u': case 'i': {
-                jim_wide jwvalue = 0;
-                long lvalue = 0;
-                char *endp;  /* Position where the number finished */
-                int base = descr->type == 'o' ? 8
-                    : descr->type == 'x' ? 16
-                    : descr->type == 'i' ? 0
-                    : 10;
-
-                do {
-                    /* Try to scan a number with the given base */
-                    if (descr->modifier == 'l')
-                    {
-#ifdef HAVE_LONG_LONG_INT
-                        jwvalue = JimStrtoll(tok, &endp, base),
-#else
-                        jwvalue = strtol(tok, &endp, base),
-#endif
-                        memcpy(value, &jwvalue, sizeof(jim_wide));
-                    }
-                    else
-                    {
-                      if (descr->type == 'u')
-                        lvalue = strtoul(tok, &endp, base);
-                      else
-                        lvalue = strtol(tok, &endp, base);
-                      memcpy(value, &lvalue, sizeof(lvalue));
-                    }
-                    /* If scanning failed, and base was undetermined, simply
-                     * put it to 10 and try once more. This should catch the
-                     * case where %i begin to parse a number prefix (e.g.
-                     * '0x' but no further digits follows. This will be
-                     * handled as a ZERO followed by a char 'x' by Tcl */
-                    if (endp == tok && base == 0) base = 10;
-                    else break;
-                } while (1);
-                if (endp != tok) {
-                    /* There was some number sucessfully scanned! */
-                    if (descr->modifier == 'l')
-                        *valObjPtr = Jim_NewIntObj(interp, jwvalue);
-                    else
-                        *valObjPtr = Jim_NewIntObj(interp, lvalue);
-                    /* Adjust the number-of-chars scanned so far */
-                    scanned += endp - tok;
-                } else {
-                    /* Nothing was scanned. We have to determine if this
-                     * happened due to e.g. prefix mismatch or input str
-                     * exhausted */
-                    scanned = *tok ? 0 : -1;
-                }
-                break;
-            }
-            case 's': case '[': {
-                *valObjPtr = JimScanAString(interp, descr->arg, tok);
-                scanned += Jim_Length(*valObjPtr);
-                break;
-            }
-            case 'e': case 'f': case 'g': {
-                char *endp;
-
-                double dvalue = strtod(tok, &endp);
-                memcpy(value, &dvalue, sizeof(double));
-                if (endp != tok) {
-                    /* There was some number sucessfully scanned! */
-                    *valObjPtr = Jim_NewDoubleObj(interp, dvalue);
-                    /* Adjust the number-of-chars scanned so far */
-                    scanned += endp - tok;
-                } else {
-                    /* Nothing was scanned. We have to determine if this
-                     * happened due to e.g. prefix mismatch or input str
-                     * exhausted */
-                    scanned = *tok ? 0 : -1;
-                }
-                break;
-            }
-        }
-        /* If a substring was allocated (due to pre-defined width) do not
-         * forget to free it */
-        if (tok != &str[pos])
-            Jim_Free((char*)tok);
-    }
-    return scanned;
-}
-
-/* Jim_ScanString is the workhorse of string scanning. It will scan a given
- * string and returns all converted (and not ignored) values in a list back
- * to the caller. If an error occured, a NULL pointer will be returned */
-
-Jim_Obj *Jim_ScanString(Jim_Interp *interp, Jim_Obj *strObjPtr,
-        Jim_Obj *fmtObjPtr, int flags)
-{
-    size_t i, pos;
-    int scanned = 1;
-    const char *str = Jim_GetString(strObjPtr, 0);
-    Jim_Obj *resultList = 0;
-    Jim_Obj **resultVec =NULL;
-    int resultc;
-    Jim_Obj *emptyStr = 0;
-    ScanFmtStringObj *fmtObj;
-
-    /* If format specification is not an object, convert it! */
-    if (fmtObjPtr->typePtr != &scanFmtStringObjType)
-        SetScanFmtFromAny(interp, fmtObjPtr);
-    fmtObj = (ScanFmtStringObj*)fmtObjPtr->internalRep.ptr;
-    /* Check if format specification was valid */
-    if (fmtObj->error != 0) {
-        if (flags & JIM_ERRMSG)
-            Jim_SetResultString(interp, fmtObj->error, -1);
-        return 0;
-    }
-    /* Allocate a new "shared" empty string for all unassigned conversions */
-    emptyStr = Jim_NewEmptyStringObj(interp);
-    Jim_IncrRefCount(emptyStr);
-    /* Create a list and fill it with empty strings up to max specified XPG3 */
-    resultList = Jim_NewListObj(interp, 0, 0);
-    if (fmtObj->maxPos > 0) {
-        for (i = 0; i < fmtObj->maxPos; ++i)
-            Jim_ListAppendElement(interp, resultList, emptyStr);
-        JimListGetElements(interp, resultList, &resultc, &resultVec);
-    }
-    /* Now handle every partial format description */
-    for (i = 0, pos = 0; i < fmtObj->count; ++i) {
-        ScanFmtPartDescr *descr = &(fmtObj->descr[i]);
-        Jim_Obj *value = 0;
-        /* Only last type may be "literal" w/o conversion - skip it! */
-        if (descr->type == 0) continue;
-        /* As long as any conversion could be done, we will proceed */
-        if (scanned > 0)
-            scanned = ScanOneEntry(interp, str, pos, fmtObj, i, &value);
-        /* In case our first try results in EOF, we will leave */
-        if (scanned == -1 && i == 0)
-            goto eof;
-        /* Advance next pos-to-be-scanned for the amount scanned already */
-        pos += scanned;
-        /* value == 0 means no conversion took place so take empty string */
-        if (value == 0)
-            value = Jim_NewEmptyStringObj(interp);
-        /* If value is a non-assignable one, skip it */
-        if (descr->pos == -1) {
-            Jim_FreeNewObj(interp, value);
-        } else if (descr->pos == 0)
-            /* Otherwise append it to the result list if no XPG3 was given */
-            Jim_ListAppendElement(interp, resultList, value);
-        else if (resultVec[descr->pos-1] == emptyStr) {
-            /* But due to given XPG3, put the value into the corr. slot */
-            Jim_DecrRefCount(interp, resultVec[descr->pos-1]);
-            Jim_IncrRefCount(value);
-            resultVec[descr->pos-1] = value;
-        } else {
-            /* Otherwise, the slot was already used - free obj and ERROR */
-            Jim_FreeNewObj(interp, value);
-            goto err;
-        }
-    }
-    Jim_DecrRefCount(interp, emptyStr);
-    return resultList;
-eof:
-    Jim_DecrRefCount(interp, emptyStr);
-    Jim_FreeNewObj(interp, resultList);
-    return (Jim_Obj*)EOF;
-err:
-    Jim_DecrRefCount(interp, emptyStr);
-    Jim_FreeNewObj(interp, resultList);
-    return 0;
-}
-
-/* -----------------------------------------------------------------------------
- * Pseudo Random Number Generation
- * ---------------------------------------------------------------------------*/
-static void JimPrngSeed(Jim_Interp *interp, const unsigned char *seed,
-        int seedLen);
-
-/* Initialize the sbox with the numbers from 0 to 255 */
-static void JimPrngInit(Jim_Interp *interp)
-{
-    int i;
-    unsigned int seed[256];
-
-    interp->prngState = Jim_Alloc(sizeof(Jim_PrngState));
-    for (i = 0; i < 256; i++)
-        seed[i] = (rand() ^ time(NULL) ^ clock());
-    JimPrngSeed(interp, (unsigned char*) seed, sizeof(int)*256);
-}
-
-/* Generates N bytes of random data */
-static void JimRandomBytes(Jim_Interp *interp, void *dest, unsigned int len)
-{
-    Jim_PrngState *prng;
-    unsigned char *destByte = (unsigned char*) dest;
-    unsigned int si, sj, x;
-
-    /* initialization, only needed the first time */
-    if (interp->prngState == NULL)
-        JimPrngInit(interp);
-    prng = interp->prngState;
-    /* generates 'len' bytes of pseudo-random numbers */
-    for (x = 0; x < len; x++) {
-        prng->i = (prng->i + 1) & 0xff;
-        si = prng->sbox[prng->i];
-        prng->j = (prng->j + si) & 0xff;
-        sj = prng->sbox[prng->j];
-        prng->sbox[prng->i] = sj;
-        prng->sbox[prng->j] = si;
-        *destByte++ = prng->sbox[(si + sj)&0xff];
-    }
-}
-
-/* Re-seed the generator with user-provided bytes */
-static void JimPrngSeed(Jim_Interp *interp, const unsigned char *seed,
-        int seedLen)
-{
-    int i;
-    unsigned char buf[256];
-    Jim_PrngState *prng;
-
-    /* initialization, only needed the first time */
-    if (interp->prngState == NULL)
-        JimPrngInit(interp);
-    prng = interp->prngState;
-
-    /* Set the sbox[i] with i */
-    for (i = 0; i < 256; i++)
-        prng->sbox[i] = i;
-    /* Now use the seed to perform a random permutation of the sbox */
-    for (i = 0; i < seedLen; i++) {
-        unsigned char t;
-
-        t = prng->sbox[i&0xFF];
-        prng->sbox[i&0xFF] = prng->sbox[seed[i]];
-        prng->sbox[seed[i]] = t;
-    }
-    prng->i = prng->j = 0;
-    /* discard the first 256 bytes of stream. */
-    JimRandomBytes(interp, buf, 256);
-}
-
-/* -----------------------------------------------------------------------------
- * Dynamic libraries support (WIN32 not supported)
- * ---------------------------------------------------------------------------*/
-
-#ifdef JIM_DYNLIB
-#ifdef WIN32
-#define RTLD_LAZY 0
-void * dlopen(const char *path, int mode)
-{
-    JIM_NOTUSED(mode);
-
-    return (void *)LoadLibraryA(path);
-}
-int dlclose(void *handle)
-{
-    FreeLibrary((HANDLE)handle);
-    return 0;
-}
-void *dlsym(void *handle, const char *symbol)
-{
-    return GetProcAddress((HMODULE)handle, symbol);
-}
-static char win32_dlerror_string[121];
-const char *dlerror(void)
-{
-    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
-                   LANG_NEUTRAL, win32_dlerror_string, 120, NULL);
-    return win32_dlerror_string;
-}
-#endif /* WIN32 */
-
-int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
-{
-    Jim_Obj *libPathObjPtr;
-    int prefixc, i;
-    void *handle;
-    int (*onload)(Jim_Interp *interp);
-
-    libPathObjPtr = Jim_GetGlobalVariableStr(interp, "jim_libpath", JIM_NONE);
-    if (libPathObjPtr == NULL) {
-        prefixc = 0;
-        libPathObjPtr = NULL;
-    } else {
-        Jim_IncrRefCount(libPathObjPtr);
-        Jim_ListLength(interp, libPathObjPtr, &prefixc);
-    }
-
-    for (i = -1; i < prefixc; i++) {
-        if (i < 0) {
-            handle = dlopen(pathName, RTLD_LAZY);
-        } else {
-            FILE *fp;
-            char buf[JIM_PATH_LEN];
-            const char *prefix;
-            int prefixlen;
-            Jim_Obj *prefixObjPtr;
-
-            buf[0] = '\0';
-            if (Jim_ListIndex(interp, libPathObjPtr, i,
-                    &prefixObjPtr, JIM_NONE) != JIM_OK)
-                continue;
-            prefix = Jim_GetString(prefixObjPtr, &prefixlen);
-            if (prefixlen + strlen(pathName) + 1 >= JIM_PATH_LEN)
-                continue;
-            if (*pathName == '/') {
-                strcpy(buf, pathName);
-            }
-            else if (prefixlen && prefix[prefixlen-1] == '/')
-                sprintf(buf, "%s%s", prefix, pathName);
-            else
-                sprintf(buf, "%s/%s", prefix, pathName);
-            fp = fopen(buf, "r");
-            if (fp == NULL)
-                continue;
-            fclose(fp);
-            handle = dlopen(buf, RTLD_LAZY);
-        }
-        if (handle == NULL) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "error loading extension \"", pathName,
-                "\": ", dlerror(), NULL);
-            if (i < 0)
-                continue;
-            goto err;
-        }
-        if ((onload = dlsym(handle, "Jim_OnLoad")) == NULL) {
-            Jim_SetResultString(interp,
-                    "No Jim_OnLoad symbol found on extension", -1);
-            goto err;
-        }
-        if (onload(interp) == JIM_ERR) {
-            dlclose(handle);
-            goto err;
-        }
-        Jim_SetEmptyResult(interp);
-        if (libPathObjPtr != NULL)
-            Jim_DecrRefCount(interp, libPathObjPtr);
-        return JIM_OK;
-    }
-err:
-    if (libPathObjPtr != NULL)
-        Jim_DecrRefCount(interp, libPathObjPtr);
-    return JIM_ERR;
-}
-#else /* JIM_DYNLIB */
-int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(pathName);
-
-    Jim_SetResultString(interp, "the Jim binary has no support for [load]", -1);
-    return JIM_ERR;
-}
-#endif/* JIM_DYNLIB */
-
-/* -----------------------------------------------------------------------------
- * Packages handling
- * ---------------------------------------------------------------------------*/
-
-#define JIM_PKG_ANY_VERSION -1
-
-/* Convert a string of the type "1.2" into an integer.
- * MAJOR.MINOR is converted as MAJOR*100 + MINOR, so "1.2" is converted
- * to the integer with value 102 */
-static int JimPackageVersionToInt(Jim_Interp *interp, const char *v,
-        int *intPtr, int flags)
-{
-    char *copy;
-    jim_wide major, minor;
-    char *majorStr, *minorStr, *p;
-
-    if (v[0] == '\0') {
-        *intPtr = JIM_PKG_ANY_VERSION;
-        return JIM_OK;
-    }
-
-    copy = Jim_StrDup(v);
-    p = strchr(copy, '.');
-    if (p == NULL) goto badfmt;
-    *p = '\0';
-    majorStr = copy;
-    minorStr = p + 1;
-
-    if (Jim_StringToWide(majorStr, &major, 10) != JIM_OK ||
-        Jim_StringToWide(minorStr, &minor, 10) != JIM_OK)
-        goto badfmt;
-    *intPtr = (int)(major*100 + minor);
-    Jim_Free(copy);
-    return JIM_OK;
-
-badfmt:
-    Jim_Free(copy);
-    if (flags & JIM_ERRMSG) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "invalid package version '", v, "'", NULL);
-    }
-    return JIM_ERR;
-}
-
-#define JIM_MATCHVER_EXACT (1 << JIM_PRIV_FLAG_SHIFT)
-static int JimPackageMatchVersion(int needed, int actual, int flags)
-{
-    if (needed == JIM_PKG_ANY_VERSION) return 1;
-    if (flags & JIM_MATCHVER_EXACT) {
-        return needed == actual;
-    } else {
-        return needed/100 == actual/100 && (needed <= actual);
-    }
-}
-
-int Jim_PackageProvide(Jim_Interp *interp, const char *name, const char *ver,
-        int flags)
-{
-    int intVersion;
-    /* Check if the version format is ok */
-    if (JimPackageVersionToInt(interp, ver, &intVersion, JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-    /* If the package was already provided returns an error. */
-    if (Jim_FindHashEntry(&interp->packages, name) != NULL) {
-        if (flags & JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    "package '", name, "' was already provided", NULL);
-        }
-        return JIM_ERR;
-    }
-    Jim_AddHashEntry(&interp->packages, name, (char*) ver);
-    return JIM_OK;
-}
-
-#ifndef JIM_ANSIC
-
-#ifndef WIN32
-# include <sys/types.h>
-# include <dirent.h>
-#else
-# include <io.h>
-/* Posix dirent.h compatiblity layer for WIN32.
- * Copyright Kevlin Henney, 1997, 2003. All rights reserved.
- * Copyright Salvatore Sanfilippo ,2005.
- *
- * Permission to use, copy, modify, and distribute this software and its
- * documentation for any purpose is hereby granted without fee, provided
- * that this copyright and permissions notice appear in all copies and
- * derivatives.
- *
- * This software is supplied "as is" without express or implied warranty.
- * This software was modified by Salvatore Sanfilippo for the Jim Interpreter.
- */
-
-struct dirent {
-    char *d_name;
-};
-
-typedef struct DIR {
-    long                handle; /* -1 for failed rewind */
-    struct _finddata_t  info;
-    struct dirent       result; /* d_name null iff first time */
-    char                *name;  /* null-terminated char string */
-} DIR;
-
-DIR *opendir(const char *name)
-{
-    DIR *dir = 0;
-
-    if (name && name[0]) {
-        size_t base_length = strlen(name);
-        const char *all = /* search pattern must end with suitable wildcard */
-            strchr("/\\", name[base_length - 1]) ? "*" : "/*";
-
-        if ((dir = (DIR *) Jim_Alloc(sizeof *dir)) != 0 &&
-           (dir->name = (char *) Jim_Alloc(base_length + strlen(all) + 1)) != 0)
-        {
-            strcat(strcpy(dir->name, name), all);
-
-            if ((dir->handle = (long) _findfirst(dir->name, &dir->info)) != -1)
-                dir->result.d_name = 0;
-            else { /* rollback */
-                Jim_Free(dir->name);
-                Jim_Free(dir);
-                dir = 0;
-            }
-        } else { /* rollback */
-            Jim_Free(dir);
-            dir   = 0;
-            errno = ENOMEM;
-        }
-    } else {
-        errno = EINVAL;
-    }
-    return dir;
-}
-
-int closedir(DIR *dir)
-{
-    int result = -1;
-
-    if (dir) {
-        if (dir->handle != -1)
-            result = _findclose(dir->handle);
-        Jim_Free(dir->name);
-        Jim_Free(dir);
-    }
-    if (result == -1) /* map all errors to EBADF */
-        errno = EBADF;
-    return result;
-}
-
-struct dirent *readdir(DIR *dir)
-{
-    struct dirent *result = 0;
-
-    if (dir && dir->handle != -1) {
-        if (!dir->result.d_name || _findnext(dir->handle, &dir->info) != -1) {
-            result         = &dir->result;
-            result->d_name = dir->info.name;
-        }
-    } else {
-        errno = EBADF;
-    }
-    return result;
-}
-
-#endif /* WIN32 */
-
-static char *JimFindBestPackage(Jim_Interp *interp, char **prefixes,
-        int prefixc, const char *pkgName, int pkgVer, int flags)
-{
-    int bestVer = -1, i;
-    int pkgNameLen = strlen(pkgName);
-    char *bestPackage = NULL;
-    struct dirent *de;
-
-    for (i = 0; i < prefixc; i++) {
-        DIR *dir;
-        char buf[JIM_PATH_LEN];
-        int prefixLen;
-
-        if (prefixes[i] == NULL) continue;
-        strncpy(buf, prefixes[i], JIM_PATH_LEN);
-        buf[JIM_PATH_LEN-1] = '\0';
-        prefixLen = strlen(buf);
-        if (prefixLen && buf[prefixLen-1] == '/')
-            buf[prefixLen-1] = '\0';
-
-        if ((dir = opendir(buf)) == NULL) continue;
-        while ((de = readdir(dir)) != NULL) {
-            char *fileName = de->d_name;
-            int fileNameLen = strlen(fileName);
-
-            if (strncmp(fileName, "jim-", 4) == 0 &&
-                strncmp(fileName + 4, pkgName, pkgNameLen) == 0 &&
-                *(fileName + 4+pkgNameLen) == '-' &&
-                fileNameLen > 4 && /* note that this is not really useful */
-                (strncmp(fileName + fileNameLen-4, ".tcl", 4) == 0 ||
-                 strncmp(fileName + fileNameLen-4, ".dll", 4) == 0 ||
-                 strncmp(fileName + fileNameLen-3, ".so", 3) == 0))
-            {
-                char ver[6]; /* xx.yy < nulterm> */
-                char *p = strrchr(fileName, '.');
-                int verLen, fileVer;
-
-                verLen = p - (fileName + 4+pkgNameLen + 1);
-                if (verLen < 3 || verLen > 5) continue;
-                memcpy(ver, fileName + 4+pkgNameLen + 1, verLen);
-                ver[verLen] = '\0';
-                if (JimPackageVersionToInt(interp, ver, &fileVer, JIM_NONE)
-                        != JIM_OK) continue;
-                if (JimPackageMatchVersion(pkgVer, fileVer, flags) &&
-                    (bestVer == -1 || bestVer < fileVer))
-                {
-                    bestVer = fileVer;
-                    Jim_Free(bestPackage);
-                    bestPackage = Jim_Alloc(strlen(buf) + strlen(fileName) + 2);
-                    sprintf(bestPackage, "%s/%s", buf, fileName);
-                }
-            }
-        }
-        closedir(dir);
-    }
-    return bestPackage;
-}
-
-#else /* JIM_ANSIC */
-
-static char *JimFindBestPackage(Jim_Interp *interp, char **prefixes,
-        int prefixc, const char *pkgName, int pkgVer, int flags)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(prefixes);
-    JIM_NOTUSED(prefixc);
-    JIM_NOTUSED(pkgName);
-    JIM_NOTUSED(pkgVer);
-    JIM_NOTUSED(flags);
-    return NULL;
-}
-
-#endif /* JIM_ANSIC */
-
-/* Search for a suitable package under every dir specified by jim_libpath
- * and load it if possible. If a suitable package was loaded with success
- * JIM_OK is returned, otherwise JIM_ERR is returned. */
-static int JimLoadPackage(Jim_Interp *interp, const char *name, int ver,
-        int flags)
-{
-    Jim_Obj *libPathObjPtr;
-    char **prefixes, *best;
-    int prefixc, i, retCode = JIM_OK;
-
-    libPathObjPtr = Jim_GetGlobalVariableStr(interp, "jim_libpath", JIM_NONE);
-    if (libPathObjPtr == NULL) {
-        prefixc = 0;
-        libPathObjPtr = NULL;
-    } else {
-        Jim_IncrRefCount(libPathObjPtr);
-        Jim_ListLength(interp, libPathObjPtr, &prefixc);
-    }
-
-    prefixes = Jim_Alloc(sizeof(char*)*prefixc);
-    for (i = 0; i < prefixc; i++) {
-            Jim_Obj *prefixObjPtr;
-            if (Jim_ListIndex(interp, libPathObjPtr, i,
-                    &prefixObjPtr, JIM_NONE) != JIM_OK)
-            {
-                prefixes[i] = NULL;
-                continue;
-            }
-            prefixes[i] = Jim_StrDup(Jim_GetString(prefixObjPtr, NULL));
-    }
-    /* Scan every directory to find the "best" package. */
-    best = JimFindBestPackage(interp, prefixes, prefixc, name, ver, flags);
-    if (best != NULL) {
-        char *p = strrchr(best, '.');
-        /* Try to load/source it */
-        if (p && strcmp(p, ".tcl") == 0) {
-            retCode = Jim_EvalFile(interp, best);
-        } else {
-            retCode = Jim_LoadLibrary(interp, best);
-        }
-    } else {
-        retCode = JIM_ERR;
-    }
-    Jim_Free(best);
-    for (i = 0; i < prefixc; i++)
-        Jim_Free(prefixes[i]);
-    Jim_Free(prefixes);
-    if (libPathObjPtr)
-        Jim_DecrRefCount(interp, libPathObjPtr);
-    return retCode;
-}
-
-const char *Jim_PackageRequire(Jim_Interp *interp, const char *name,
-        const char *ver, int flags)
-{
-    Jim_HashEntry *he;
-    int requiredVer;
-
-    /* Start with an empty error string */
-    Jim_SetResultString(interp, "", 0);
-
-    if (JimPackageVersionToInt(interp, ver, &requiredVer, JIM_ERRMSG) != JIM_OK)
-        return NULL;
-    he = Jim_FindHashEntry(&interp->packages, name);
-    if (he == NULL) {
-        /* Try to load the package. */
-        if (JimLoadPackage(interp, name, requiredVer, flags) == JIM_OK) {
-            he = Jim_FindHashEntry(&interp->packages, name);
-            if (he == NULL) {
-                return "?";
-            }
-            return he->val;
-        }
-        /* No way... return an error. */
-        if (flags & JIM_ERRMSG) {
-            int len;
-            Jim_GetString(Jim_GetResult(interp), &len);
-            Jim_AppendStrings(interp, Jim_GetResult(interp), len ? "\n" : "",
-                    "Can't find package '", name, "'", NULL);
-        }
-        return NULL;
-    } else {
-        int actualVer;
-        if (JimPackageVersionToInt(interp, he->val, &actualVer, JIM_ERRMSG)
-                != JIM_OK)
-        {
-            return NULL;
-        }
-        /* Check if version matches. */
-        if (JimPackageMatchVersion(requiredVer, actualVer, flags) == 0) {
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    "Package '", name, "' already loaded, but with version ",
-                    he->val, NULL);
-            return NULL;
-        }
-        return he->val;
-    }
-}
-
-/* -----------------------------------------------------------------------------
- * Eval
- * ---------------------------------------------------------------------------*/
-#define JIM_EVAL_SARGV_LEN 8 /* static arguments vector length */
-#define JIM_EVAL_SINTV_LEN 8 /* static interpolation vector length */
-
-static int JimCallProcedure(Jim_Interp *interp, Jim_Cmd *cmd, int argc,
-        Jim_Obj *const *argv);
-
-/* Handle calls to the [unknown] command */
-static int JimUnknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-    Jim_Obj **v, *sv[JIM_EVAL_SARGV_LEN];
-    int retCode;
-
-    /* If JimUnknown() is recursively called (e.g. error in the unknown proc,
-     * done here
-     */
-    if (interp->unknown_called) {
-        return JIM_ERR;
-    }
-
-    /* If the [unknown] command does not exists returns
-     * just now */
-    if (Jim_GetCommand(interp, interp->unknown, JIM_NONE) == NULL)
-        return JIM_ERR;
-
-    /* The object interp->unknown just contains
-     * the "unknown" string, it is used in order to
-     * avoid to lookup the unknown command every time
-     * but instread to cache the result. */
-    if (argc + 1 <= JIM_EVAL_SARGV_LEN)
-        v = sv;
-    else
-        v = Jim_Alloc(sizeof(Jim_Obj*)*(argc + 1));
-    /* Make a copy of the arguments vector, but shifted on
-     * the right of one position. The command name of the
-     * command will be instead the first argument of the
-     * [unknonw] call. */
-    memcpy(v + 1, argv, sizeof(Jim_Obj*)*argc);
-    v[0] = interp->unknown;
-    /* Call it */
-    interp->unknown_called++;
-    retCode = Jim_EvalObjVector(interp, argc + 1, v);
-    interp->unknown_called--;
-
-    /* Clean up */
-    if (v != sv)
-        Jim_Free(v);
-    return retCode;
-}
-
-/* Eval the object vector 'objv' composed of 'objc' elements.
- * Every element is used as single argument.
- * Jim_EvalObj() will call this function every time its object
- * argument is of "list" type, with no string representation.
- *
- * This is possible because the string representation of a
- * list object generated by the UpdateStringOfList is made
- * in a way that ensures that every list element is a different
- * command argument. */
-int Jim_EvalObjVector(Jim_Interp *interp, int objc, Jim_Obj *const *objv)
-{
-    int i, retcode;
-    Jim_Cmd *cmdPtr;
-
-    /* Incr refcount of arguments. */
-    for (i = 0; i < objc; i++)
-        Jim_IncrRefCount(objv[i]);
-    /* Command lookup */
-    cmdPtr = Jim_GetCommand(interp, objv[0], JIM_ERRMSG);
-    if (cmdPtr == NULL) {
-        retcode = JimUnknown(interp, objc, objv);
-    } else {
-        /* Call it -- Make sure result is an empty object. */
-        Jim_SetEmptyResult(interp);
-        if (cmdPtr->cmdProc) {
-            interp->cmdPrivData = cmdPtr->privData;
-            retcode = cmdPtr->cmdProc(interp, objc, objv);
-            if (retcode == JIM_ERR_ADDSTACK) {
-                //JimAppendStackTrace(interp, "", script->fileName, token[i-argc*2].linenr);
-                retcode = JIM_ERR;
-            }
-        } else {
-            retcode = JimCallProcedure(interp, cmdPtr, objc, objv);
-            if (retcode == JIM_ERR) {
-                JimAppendStackTrace(interp,
-                    Jim_GetString(objv[0], NULL), "", 1);
-            }
-        }
-    }
-    /* Decr refcount of arguments and return the retcode */
-    for (i = 0; i < objc; i++)
-        Jim_DecrRefCount(interp, objv[i]);
-    return retcode;
-}
-
-/* Interpolate the given tokens into a unique Jim_Obj returned by reference
- * via *objPtrPtr. This function is only called by Jim_EvalObj().
- * The returned object has refcount = 0. */
-int Jim_InterpolateTokens(Jim_Interp *interp, ScriptToken *token,
-        int tokens, Jim_Obj **objPtrPtr)
-{
-    int totlen = 0, i, retcode;
-    Jim_Obj **intv;
-    Jim_Obj *sintv[JIM_EVAL_SINTV_LEN];
-    Jim_Obj *objPtr;
-    char *s;
-
-    if (tokens <= JIM_EVAL_SINTV_LEN)
-        intv = sintv;
-    else
-        intv = Jim_Alloc(sizeof(Jim_Obj*)*
-                tokens);
-    /* Compute every token forming the argument
-     * in the intv objects vector. */
-    for (i = 0; i < tokens; i++) {
-        switch (token[i].type) {
-        case JIM_TT_ESC:
-        case JIM_TT_STR:
-            intv[i] = token[i].objPtr;
-            break;
-        case JIM_TT_VAR:
-            intv[i] = Jim_GetVariable(interp, token[i].objPtr, JIM_ERRMSG);
-            if (!intv[i]) {
-                retcode = JIM_ERR;
-                goto err;
-            }
-            break;
-        case JIM_TT_DICTSUGAR:
-            intv[i] = Jim_ExpandDictSugar(interp, token[i].objPtr);
-            if (!intv[i]) {
-                retcode = JIM_ERR;
-                goto err;
-            }
-            break;
-        case JIM_TT_CMD:
-            retcode = Jim_EvalObj(interp, token[i].objPtr);
-            if (retcode != JIM_OK)
-                goto err;
-            intv[i] = Jim_GetResult(interp);
-            break;
-        default:
-            Jim_Panic(interp,
-              "default token type reached "
-              "in Jim_InterpolateTokens().");
-            break;
-        }
-        Jim_IncrRefCount(intv[i]);
-        /* Make sure there is a valid
-         * string rep, and add the string
-         * length to the total legnth. */
-        Jim_GetString(intv[i], NULL);
-        totlen += intv[i]->length;
-    }
-    /* Concatenate every token in an unique
-     * object. */
-    objPtr = Jim_NewStringObjNoAlloc(interp,
-            NULL, 0);
-    s = objPtr->bytes = Jim_Alloc(totlen + 1);
-    objPtr->length = totlen;
-    for (i = 0; i < tokens; i++) {
-        memcpy(s, intv[i]->bytes, intv[i]->length);
-        s += intv[i]->length;
-        Jim_DecrRefCount(interp, intv[i]);
-    }
-    objPtr->bytes[totlen] = '\0';
-    /* Free the intv vector if not static. */
-    if (tokens > JIM_EVAL_SINTV_LEN)
-        Jim_Free(intv);
-    *objPtrPtr = objPtr;
-    return JIM_OK;
-err:
-    i--;
-    for (; i >= 0; i--)
-        Jim_DecrRefCount(interp, intv[i]);
-    if (tokens > JIM_EVAL_SINTV_LEN)
-        Jim_Free(intv);
-    return retcode;
-}
-
-/* Helper of Jim_EvalObj() to perform argument expansion.
- * Basically this function append an argument to 'argv'
- * (and increments argc by reference accordingly), performing
- * expansion of the list object if 'expand' is non-zero, or
- * just adding objPtr to argv if 'expand' is zero. */
-void Jim_ExpandArgument(Jim_Interp *interp, Jim_Obj ***argv,
-        int *argcPtr, int expand, Jim_Obj *objPtr)
-{
-    if (!expand) {
-        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr) + 1));
-        /* refcount of objPtr not incremented because
-         * we are actually transfering a reference from
-         * the old 'argv' to the expanded one. */
-        (*argv)[*argcPtr] = objPtr;
-        (*argcPtr)++;
-    } else {
-        int len, i;
-
-        Jim_ListLength(interp, objPtr, &len);
-        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr) + len));
-        for (i = 0; i < len; i++) {
-            (*argv)[*argcPtr] = objPtr->internalRep.listValue.ele[i];
-            Jim_IncrRefCount(objPtr->internalRep.listValue.ele[i]);
-            (*argcPtr)++;
-        }
-        /* The original object reference is no longer needed,
-         * after the expansion it is no longer present on
-         * the argument vector, but the single elements are
-         * in its place. */
-        Jim_DecrRefCount(interp, objPtr);
-    }
-}
-
-int Jim_EvalObj(Jim_Interp *interp, Jim_Obj *scriptObjPtr)
-{
-    int i, j = 0, len;
-    ScriptObj *script;
-    ScriptToken *token;
-    int *cs; /* command structure array */
-    int retcode = JIM_OK;
-    Jim_Obj *sargv[JIM_EVAL_SARGV_LEN], **argv = NULL, *tmpObjPtr;
-
-    interp->errorFlag = 0;
-
-    /* If the object is of type "list" and there is no
-     * string representation for this object, we can call
-     * a specialized version of Jim_EvalObj() */
-    if (scriptObjPtr->typePtr == &listObjType &&
-        scriptObjPtr->internalRep.listValue.len &&
-        scriptObjPtr->bytes == NULL) {
-        Jim_IncrRefCount(scriptObjPtr);
-        retcode = Jim_EvalObjVector(interp,
-                scriptObjPtr->internalRep.listValue.len,
-                scriptObjPtr->internalRep.listValue.ele);
-        Jim_DecrRefCount(interp, scriptObjPtr);
-        return retcode;
-    }
-
-    Jim_IncrRefCount(scriptObjPtr); /* Make sure it's shared. */
-    script = Jim_GetScript(interp, scriptObjPtr);
-    /* Now we have to make sure the internal repr will not be
-     * freed on shimmering.
-     *
-     * Think for example to this:
-     *
-     * set x {llength $x; ... some more code ...}; eval $x
-     *
-     * In order to preserve the internal rep, we increment the
-     * inUse field of the script internal rep structure. */
-    script->inUse++;
-
-    token = script->token;
-    len = script->len;
-    cs = script->cmdStruct;
-    i = 0; /* 'i' is the current token index. */
-
-    /* Reset the interpreter result. This is useful to
-     * return the emtpy result in the case of empty program. */
-    Jim_SetEmptyResult(interp);
-
-    /* Execute every command sequentially, returns on
-     * error (i.e. if a command does not return JIM_OK) */
-    while (i < len) {
-        int expand = 0;
-        int argc = *cs++; /* Get the number of arguments */
-        Jim_Cmd *cmd;
-
-        /* Set the expand flag if needed. */
-        if (argc == -1) {
-            expand++;
-            argc = *cs++;
-        }
-        /* Allocate the arguments vector */
-        if (argc <= JIM_EVAL_SARGV_LEN)
-            argv = sargv;
-        else
-            argv = Jim_Alloc(sizeof(Jim_Obj*)*argc);
-        /* Populate the arguments objects. */
-        for (j = 0; j < argc; j++) {
-            int tokens = *cs++;
-
-            /* tokens is negative if expansion is needed.
-             * for this argument. */
-            if (tokens < 0) {
-                tokens = (-tokens)-1;
-                i++;
-            }
-            if (tokens == 1) {
-                /* Fast path if the token does not
-                 * need interpolation */
-                switch (token[i].type) {
-                case JIM_TT_ESC:
-                case JIM_TT_STR:
-                    argv[j] = token[i].objPtr;
-                    break;
-                case JIM_TT_VAR:
-                    tmpObjPtr = Jim_GetVariable(interp, token[i].objPtr,
-                            JIM_ERRMSG);
-                    if (!tmpObjPtr) {
-                        retcode = JIM_ERR;
-                        goto err;
-                    }
-                    argv[j] = tmpObjPtr;
-                    break;
-                case JIM_TT_DICTSUGAR:
-                    tmpObjPtr = Jim_ExpandDictSugar(interp, token[i].objPtr);
-                    if (!tmpObjPtr) {
-                        retcode = JIM_ERR;
-                        goto err;
-                    }
-                    argv[j] = tmpObjPtr;
-                    break;
-                case JIM_TT_CMD:
-                    retcode = Jim_EvalObj(interp, token[i].objPtr);
-                    if (retcode != JIM_OK)
-                        goto err;
-                    argv[j] = Jim_GetResult(interp);
-                    break;
-                default:
-                    Jim_Panic(interp,
-                      "default token type reached "
-                      "in Jim_EvalObj().");
-                    break;
-                }
-                Jim_IncrRefCount(argv[j]);
-                i += 2;
-            } else {
-                /* For interpolation we call an helper
-                 * function doing the work for us. */
-                if ((retcode = Jim_InterpolateTokens(interp,
-                        token + i, tokens, &tmpObjPtr)) != JIM_OK)
-                {
-                    goto err;
-                }
-                argv[j] = tmpObjPtr;
-                Jim_IncrRefCount(argv[j]);
-                i += tokens + 1;
-            }
-        }
-        /* Handle {expand} expansion */
-        if (expand) {
-            int *ecs = cs - argc;
-            int eargc = 0;
-            Jim_Obj **eargv = NULL;
-
-            for (j = 0; j < argc; j++) {
-                Jim_ExpandArgument(interp, &eargv, &eargc,
-                        ecs[j] < 0, argv[j]);
-            }
-            if (argv != sargv)
-                Jim_Free(argv);
-            argc = eargc;
-            argv = eargv;
-            j = argc;
-            if (argc == 0) {
-                /* Nothing to do with zero args. */
-                Jim_Free(eargv);
-                continue;
-            }
-        }
-        /* Lookup the command to call */
-        cmd = Jim_GetCommand(interp, argv[0], JIM_ERRMSG);
-        if (cmd != NULL) {
-            /* Call it -- Make sure result is an empty object. */
-            Jim_SetEmptyResult(interp);
-            if (cmd->cmdProc) {
-                interp->cmdPrivData = cmd->privData;
-                retcode = cmd->cmdProc(interp, argc, argv);
-                if ((retcode == JIM_ERR)||(retcode == JIM_ERR_ADDSTACK)) {
-                    JimAppendStackTrace(interp, "", script->fileName, token[i-argc*2].linenr);
-                    retcode = JIM_ERR;
-                }
-            } else {
-                retcode = JimCallProcedure(interp, cmd, argc, argv);
-                if (retcode == JIM_ERR) {
-                    JimAppendStackTrace(interp,
-                        Jim_GetString(argv[0], NULL), script->fileName,
-                        token[i-argc*2].linenr);
-                }
-            }
-        } else {
-            /* Call [unknown] */
-            retcode = JimUnknown(interp, argc, argv);
-            if (retcode == JIM_ERR) {
-                JimAppendStackTrace(interp,
-                    "", script->fileName,
-                    token[i-argc*2].linenr);
-            }
-        }
-        if (retcode != JIM_OK) {
-            i -= argc*2; /* point to the command name. */
-            goto err;
-        }
-        /* Decrement the arguments count */
-        for (j = 0; j < argc; j++) {
-            Jim_DecrRefCount(interp, argv[j]);
-        }
-
-        if (argv != sargv) {
-            Jim_Free(argv);
-            argv = NULL;
-        }
-    }
-    /* Note that we don't have to decrement inUse, because the
-     * following code transfers our use of the reference again to
-     * the script object. */
-    j = 0; /* on normal termination, the argv array is already
-          Jim_DecrRefCount-ed. */
-err:
-    /* Handle errors. */
-    if (retcode == JIM_ERR && !interp->errorFlag) {
-        interp->errorFlag = 1;
-        JimSetErrorFileName(interp, script->fileName);
-        JimSetErrorLineNumber(interp, token[i].linenr);
-        JimResetStackTrace(interp);
-    }
-    Jim_FreeIntRep(interp, scriptObjPtr);
-    scriptObjPtr->typePtr = &scriptObjType;
-    Jim_SetIntRepPtr(scriptObjPtr, script);
-    Jim_DecrRefCount(interp, scriptObjPtr);
-    for (i = 0; i < j; i++) {
-        Jim_DecrRefCount(interp, argv[i]);
-    }
-    if (argv != sargv)
-        Jim_Free(argv);
-    return retcode;
-}
-
-/* Call a procedure implemented in Tcl.
- * It's possible to speed-up a lot this function, currently
- * the callframes are not cached, but allocated and
- * destroied every time. What is expecially costly is
- * to create/destroy the local vars hash table every time.
- *
- * This can be fixed just implementing callframes caching
- * in JimCreateCallFrame() and JimFreeCallFrame(). */
-int JimCallProcedure(Jim_Interp *interp, Jim_Cmd *cmd, int argc,
-        Jim_Obj *const *argv)
-{
-    int i, retcode;
-    Jim_CallFrame *callFramePtr;
-    int num_args;
-
-    /* Check arity */
-    if (argc < cmd->arityMin || (cmd->arityMax != -1 &&
-        argc > cmd->arityMax)) {
-        Jim_Obj *objPtr = Jim_NewEmptyStringObj(interp);
-        Jim_AppendStrings(interp, objPtr,
-            "wrong # args: should be \"", Jim_GetString(argv[0], NULL),
-            (cmd->arityMin > 1) ? " " : "",
-            Jim_GetString(cmd->argListObjPtr, NULL), "\"", NULL);
-        Jim_SetResult(interp, objPtr);
-        return JIM_ERR;
-    }
-    /* Check if there are too nested calls */
-    if (interp->numLevels == interp->maxNestingDepth) {
-        Jim_SetResultString(interp,
-            "Too many nested calls. Infinite recursion?", -1);
-        return JIM_ERR;
-    }
-    /* Create a new callframe */
-    callFramePtr = JimCreateCallFrame(interp);
-    callFramePtr->parentCallFrame = interp->framePtr;
-    callFramePtr->argv = argv;
-    callFramePtr->argc = argc;
-    callFramePtr->procArgsObjPtr = cmd->argListObjPtr;
-    callFramePtr->procBodyObjPtr = cmd->bodyObjPtr;
-    callFramePtr->staticVars = cmd->staticVars;
-    Jim_IncrRefCount(cmd->argListObjPtr);
-    Jim_IncrRefCount(cmd->bodyObjPtr);
-    interp->framePtr = callFramePtr;
-    interp->numLevels ++;
-
-    /* Set arguments */
-    Jim_ListLength(interp, cmd->argListObjPtr, &num_args);
-
-    /* If last argument is 'args', don't set it here */
-    if (cmd->arityMax == -1) {
-        num_args--;
-    }
-
-    for (i = 0; i < num_args; i++) {
-        Jim_Obj *argObjPtr=NULL;
-        Jim_Obj *nameObjPtr=NULL;
-        Jim_Obj *valueObjPtr=NULL;
-
-        Jim_ListIndex(interp, cmd->argListObjPtr, i, &argObjPtr, JIM_NONE);
-        if (i + 1 >= cmd->arityMin) {
-            /* The name is the first element of the list */
-            Jim_ListIndex(interp, argObjPtr, 0, &nameObjPtr, JIM_NONE);
-        }
-        else {
-            /* The element arg is the name */
-            nameObjPtr = argObjPtr;
-        }
-
-        if (i + 1 >= argc) {
-            /* No more values, so use default */
-            /* The value is the second element of the list */
-            Jim_ListIndex(interp, argObjPtr, 1, &valueObjPtr, JIM_NONE);
-        }
-        else {
-            valueObjPtr = argv[i + 1];
-        }
-        Jim_SetVariable(interp, nameObjPtr, valueObjPtr);
-    }
-    /* Set optional arguments */
-    if (cmd->arityMax == -1) {
-        Jim_Obj *listObjPtr=NULL, *objPtr=NULL;
-
-        i++;
-        listObjPtr = Jim_NewListObj(interp, argv + i, argc-i);
-        Jim_ListIndex(interp, cmd->argListObjPtr, num_args, &objPtr, JIM_NONE);
-        Jim_SetVariable(interp, objPtr, listObjPtr);
-    }
-    /* Eval the body */
-    retcode = Jim_EvalObj(interp, cmd->bodyObjPtr);
-
-    /* Destroy the callframe */
-    interp->numLevels --;
-    interp->framePtr = interp->framePtr->parentCallFrame;
-    if (callFramePtr->vars.size != JIM_HT_INITIAL_SIZE) {
-        JimFreeCallFrame(interp, callFramePtr, JIM_FCF_NONE);
-    } else {
-        JimFreeCallFrame(interp, callFramePtr, JIM_FCF_NOHT);
-    }
-    /* Handle the JIM_EVAL return code */
-    if (retcode == JIM_EVAL && interp->evalRetcodeLevel != interp->numLevels) {
-        int savedLevel = interp->evalRetcodeLevel;
-
-        interp->evalRetcodeLevel = interp->numLevels;
-        while (retcode == JIM_EVAL) {
-            Jim_Obj *resultScriptObjPtr = Jim_GetResult(interp);
-            Jim_IncrRefCount(resultScriptObjPtr);
-            retcode = Jim_EvalObj(interp, resultScriptObjPtr);
-            Jim_DecrRefCount(interp, resultScriptObjPtr);
-        }
-        interp->evalRetcodeLevel = savedLevel;
-    }
-    /* Handle the JIM_RETURN return code */
-    if (retcode == JIM_RETURN) {
-        retcode = interp->returnCode;
-        interp->returnCode = JIM_OK;
-    }
-    return retcode;
-}
-
-int Jim_Eval_Named(Jim_Interp *interp, const char *script, const char *filename, int lineno)
-{
-    int retval;
-    Jim_Obj *scriptObjPtr;
-
-	scriptObjPtr = Jim_NewStringObj(interp, script, -1);
-    Jim_IncrRefCount(scriptObjPtr);
-
-
-	if (filename) {
-		JimSetSourceInfo(interp, scriptObjPtr, filename, lineno);
-	}
-
-    retval = Jim_EvalObj(interp, scriptObjPtr);
-    Jim_DecrRefCount(interp, scriptObjPtr);
-    return retval;
-}
-
-int Jim_Eval(Jim_Interp *interp, const char *script)
-{
-	return Jim_Eval_Named(interp, script, NULL, 0);
-}
-
-
-
-/* Execute script in the scope of the global level */
-int Jim_EvalGlobal(Jim_Interp *interp, const char *script)
-{
-    Jim_CallFrame *savedFramePtr;
-    int retval;
-
-    savedFramePtr = interp->framePtr;
-    interp->framePtr = interp->topFramePtr;
-    retval = Jim_Eval(interp, script);
-    interp->framePtr = savedFramePtr;
-    return retval;
-}
-
-int Jim_EvalObjBackground(Jim_Interp *interp, Jim_Obj *scriptObjPtr)
-{
-    Jim_CallFrame *savedFramePtr;
-    int retval;
-
-    savedFramePtr = interp->framePtr;
-    interp->framePtr = interp->topFramePtr;
-    retval = Jim_EvalObj(interp, scriptObjPtr);
-    interp->framePtr = savedFramePtr;
-    /* Try to report the error (if any) via the bgerror proc */
-    if (retval != JIM_OK) {
-        Jim_Obj *objv[2];
-
-        objv[0] = Jim_NewStringObj(interp, "bgerror", -1);
-        objv[1] = Jim_GetResult(interp);
-        Jim_IncrRefCount(objv[0]);
-        Jim_IncrRefCount(objv[1]);
-        if (Jim_EvalObjVector(interp, 2, objv) != JIM_OK) {
-            /* Report the error to stderr. */
-            Jim_fprintf(interp, interp->cookie_stderr, "Background error:" JIM_NL);
-            Jim_PrintErrorMessage(interp);
-        }
-        Jim_DecrRefCount(interp, objv[0]);
-        Jim_DecrRefCount(interp, objv[1]);
-    }
-    return retval;
-}
-
-int Jim_EvalFile(Jim_Interp *interp, const char *filename)
-{
-    char *prg = NULL;
-    FILE *fp;
-    int nread, totread, maxlen, buflen;
-    int retval;
-    Jim_Obj *scriptObjPtr;
-
-    if ((fp = fopen(filename, "r")) == NULL) {
-    	const int cwd_len = 2048;
-		char *cwd = malloc(cwd_len);
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-	if (!getcwd(cwd, cwd_len)) strcpy(cwd, "unknown");
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-	"Error loading script \"", filename, "\"",
-	    " cwd: ", cwd,
-	    " err: ", strerror(errno), NULL);
-	    free(cwd);
-        return JIM_ERR;
-    }
-    buflen = 1024;
-    maxlen = totread = 0;
-    while (1) {
-        if (maxlen < totread + buflen + 1) {
-            maxlen = totread + buflen + 1;
-            prg = Jim_Realloc(prg, maxlen);
-        }
-		/* do not use Jim_fread() - this is really a file */
-        if ((nread = fread(prg + totread, 1, buflen, fp)) == 0) break;
-        totread += nread;
-    }
-    prg[totread] = '\0';
-	/* do not use Jim_fclose() - this is really a file */
-    fclose(fp);
-
-    scriptObjPtr = Jim_NewStringObjNoAlloc(interp, prg, totread);
-    JimSetSourceInfo(interp, scriptObjPtr, filename, 1);
-    Jim_IncrRefCount(scriptObjPtr);
-    retval = Jim_EvalObj(interp, scriptObjPtr);
-    Jim_DecrRefCount(interp, scriptObjPtr);
-    return retval;
-}
-
-/* -----------------------------------------------------------------------------
- * Subst
- * ---------------------------------------------------------------------------*/
-static int JimParseSubstStr(struct JimParserCtx *pc)
-{
-    pc->tstart = pc->p;
-    pc->tline = pc->linenr;
-    while (*pc->p && *pc->p != '$' && *pc->p != '[') {
-        pc->p++; pc->len--;
-    }
-    pc->tend = pc->p-1;
-    pc->tt = JIM_TT_ESC;
-    return JIM_OK;
-}
-
-static int JimParseSubst(struct JimParserCtx *pc, int flags)
-{
-    int retval;
-
-    if (pc->len == 0) {
-        pc->tstart = pc->tend = pc->p;
-        pc->tline = pc->linenr;
-        pc->tt = JIM_TT_EOL;
-        pc->eof = 1;
-        return JIM_OK;
-    }
-    switch (*pc->p) {
-    case '[':
-        retval = JimParseCmd(pc);
-        if (flags & JIM_SUBST_NOCMD) {
-            pc->tstart--;
-            pc->tend++;
-            pc->tt = (flags & JIM_SUBST_NOESC) ?
-                JIM_TT_STR : JIM_TT_ESC;
-        }
-        return retval;
-        break;
-    case '$':
-        if (JimParseVar(pc) == JIM_ERR) {
-            pc->tstart = pc->tend = pc->p++; pc->len--;
-            pc->tline = pc->linenr;
-            pc->tt = JIM_TT_STR;
-        } else {
-            if (flags & JIM_SUBST_NOVAR) {
-                pc->tstart--;
-                if (flags & JIM_SUBST_NOESC)
-                    pc->tt = JIM_TT_STR;
-                else
-                    pc->tt = JIM_TT_ESC;
-                if (*pc->tstart == '{') {
-                    pc->tstart--;
-                    if (*(pc->tend + 1))
-                        pc->tend++;
-                }
-            }
-        }
-        break;
-    default:
-        retval = JimParseSubstStr(pc);
-        if (flags & JIM_SUBST_NOESC)
-            pc->tt = JIM_TT_STR;
-        return retval;
-        break;
-    }
-    return JIM_OK;
-}
-
-/* The subst object type reuses most of the data structures and functions
- * of the script object. Script's data structures are a bit more complex
- * for what is needed for [subst]itution tasks, but the reuse helps to
- * deal with a single data structure at the cost of some more memory
- * usage for substitutions. */
-static Jim_ObjType substObjType = {
-    "subst",
-    FreeScriptInternalRep,
-    DupScriptInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* This method takes the string representation of an object
- * as a Tcl string where to perform [subst]itution, and generates
- * the pre-parsed internal representation. */
-int SetSubstFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr, int flags)
-{
-    int scriptTextLen;
-    const char *scriptText = Jim_GetString(objPtr, &scriptTextLen);
-    struct JimParserCtx parser;
-    struct ScriptObj *script = Jim_Alloc(sizeof(*script));
-
-    script->len = 0;
-    script->csLen = 0;
-    script->commands = 0;
-    script->token = NULL;
-    script->cmdStruct = NULL;
-    script->inUse = 1;
-    script->substFlags = flags;
-    script->fileName = NULL;
-
-    JimParserInit(&parser, scriptText, scriptTextLen, 1);
-    while (1) {
-        char *token;
-        int len, type, linenr;
-
-        JimParseSubst(&parser, flags);
-        if (JimParserEof(&parser)) break;
-        token = JimParserGetToken(&parser, &len, &type, &linenr);
-        ScriptObjAddToken(interp, script, token, len, type,
-                NULL, linenr);
-    }
-    /* Free the old internal rep and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    Jim_SetIntRepPtr(objPtr, script);
-    objPtr->typePtr = &scriptObjType;
-    return JIM_OK;
-}
-
-ScriptObj *Jim_GetSubst(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
-{
-    struct ScriptObj *script = Jim_GetIntRepPtr(objPtr);
-
-    if (objPtr->typePtr != &substObjType || script->substFlags != flags)
-        SetSubstFromAny(interp, objPtr, flags);
-    return (ScriptObj*) Jim_GetIntRepPtr(objPtr);
-}
-
-/* Performs commands,variables,blackslashes substitution,
- * storing the result object (with refcount 0) into
- * resObjPtrPtr. */
-int Jim_SubstObj(Jim_Interp *interp, Jim_Obj *substObjPtr,
-        Jim_Obj **resObjPtrPtr, int flags)
-{
-    ScriptObj *script;
-    ScriptToken *token;
-    int i, len, retcode = JIM_OK;
-    Jim_Obj *resObjPtr, *savedResultObjPtr;
-
-    script = Jim_GetSubst(interp, substObjPtr, flags);
-#ifdef JIM_OPTIMIZATION
-    /* Fast path for a very common case with array-alike syntax,
-     * that's: $foo($bar) */
-    if (script->len == 1 && script->token[0].type == JIM_TT_VAR) {
-        Jim_Obj *varObjPtr = script->token[0].objPtr;
-
-        Jim_IncrRefCount(varObjPtr);
-        resObjPtr = Jim_GetVariable(interp, varObjPtr, JIM_ERRMSG);
-        if (resObjPtr == NULL) {
-            Jim_DecrRefCount(interp, varObjPtr);
-            return JIM_ERR;
-        }
-        Jim_DecrRefCount(interp, varObjPtr);
-        *resObjPtrPtr = resObjPtr;
-        return JIM_OK;
-    }
-#endif
-
-    Jim_IncrRefCount(substObjPtr); /* Make sure it's shared. */
-    /* In order to preserve the internal rep, we increment the
-     * inUse field of the script internal rep structure. */
-    script->inUse++;
-
-    token = script->token;
-    len = script->len;
-
-    /* Save the interp old result, to set it again before
-     * to return. */
-    savedResultObjPtr = interp->result;
-    Jim_IncrRefCount(savedResultObjPtr);
-
-    /* Perform the substitution. Starts with an empty object
-     * and adds every token (performing the appropriate
-     * var/command/escape substitution). */
-    resObjPtr = Jim_NewStringObj(interp, "", 0);
-    for (i = 0; i < len; i++) {
-        Jim_Obj *objPtr;
-
-        switch (token[i].type) {
-        case JIM_TT_STR:
-        case JIM_TT_ESC:
-            Jim_AppendObj(interp, resObjPtr, token[i].objPtr);
-            break;
-        case JIM_TT_VAR:
-            objPtr = Jim_GetVariable(interp, token[i].objPtr, JIM_ERRMSG);
-            if (objPtr == NULL) goto err;
-            Jim_IncrRefCount(objPtr);
-            Jim_AppendObj(interp, resObjPtr, objPtr);
-            Jim_DecrRefCount(interp, objPtr);
-            break;
-        case JIM_TT_DICTSUGAR:
-            objPtr = Jim_ExpandDictSugar(interp, token[i].objPtr);
-            if (!objPtr) {
-                retcode = JIM_ERR;
-                goto err;
-            }
-            break;
-        case JIM_TT_CMD:
-            if (Jim_EvalObj(interp, token[i].objPtr) != JIM_OK)
-                goto err;
-            Jim_AppendObj(interp, resObjPtr, interp->result);
-            break;
-        default:
-            Jim_Panic(interp,
-              "default token type (%d) reached "
-              "in Jim_SubstObj().", token[i].type);
-            break;
-        }
-    }
-ok:
-    if (retcode == JIM_OK)
-        Jim_SetResult(interp, savedResultObjPtr);
-    Jim_DecrRefCount(interp, savedResultObjPtr);
-    /* Note that we don't have to decrement inUse, because the
-     * following code transfers our use of the reference again to
-     * the script object. */
-    Jim_FreeIntRep(interp, substObjPtr);
-    substObjPtr->typePtr = &scriptObjType;
-    Jim_SetIntRepPtr(substObjPtr, script);
-    Jim_DecrRefCount(interp, substObjPtr);
-    *resObjPtrPtr = resObjPtr;
-    return retcode;
-err:
-    Jim_FreeNewObj(interp, resObjPtr);
-    retcode = JIM_ERR;
-    goto ok;
-}
-
-/* -----------------------------------------------------------------------------
- * API Input/Export functions
- * ---------------------------------------------------------------------------*/
-
-int Jim_GetApi(Jim_Interp *interp, const char *funcname, void *targetPtrPtr)
-{
-    Jim_HashEntry *he;
-
-    he = Jim_FindHashEntry(&interp->stub, funcname);
-    if (!he)
-        return JIM_ERR;
-    memcpy(targetPtrPtr, &he->val, sizeof(void*));
-    return JIM_OK;
-}
-
-int Jim_RegisterApi(Jim_Interp *interp, const char *funcname, void *funcptr)
-{
-    return Jim_AddHashEntry(&interp->stub, funcname, funcptr);
-}
-
-#define JIM_REGISTER_API(name) \
-    Jim_RegisterApi(interp, "Jim_" #name, (void *)Jim_ ## name)
-
-void JimRegisterCoreApi(Jim_Interp *interp)
-{
-  interp->getApiFuncPtr = Jim_GetApi;
-  JIM_REGISTER_API(Alloc);
-  JIM_REGISTER_API(Free);
-  JIM_REGISTER_API(Eval);
-  JIM_REGISTER_API(Eval_Named);
-  JIM_REGISTER_API(EvalGlobal);
-  JIM_REGISTER_API(EvalFile);
-  JIM_REGISTER_API(EvalObj);
-  JIM_REGISTER_API(EvalObjBackground);
-  JIM_REGISTER_API(EvalObjVector);
-  JIM_REGISTER_API(InitHashTable);
-  JIM_REGISTER_API(ExpandHashTable);
-  JIM_REGISTER_API(AddHashEntry);
-  JIM_REGISTER_API(ReplaceHashEntry);
-  JIM_REGISTER_API(DeleteHashEntry);
-  JIM_REGISTER_API(FreeHashTable);
-  JIM_REGISTER_API(FindHashEntry);
-  JIM_REGISTER_API(ResizeHashTable);
-  JIM_REGISTER_API(GetHashTableIterator);
-  JIM_REGISTER_API(NextHashEntry);
-  JIM_REGISTER_API(NewObj);
-  JIM_REGISTER_API(FreeObj);
-  JIM_REGISTER_API(InvalidateStringRep);
-  JIM_REGISTER_API(InitStringRep);
-  JIM_REGISTER_API(DuplicateObj);
-  JIM_REGISTER_API(GetString);
-  JIM_REGISTER_API(Length);
-  JIM_REGISTER_API(InvalidateStringRep);
-  JIM_REGISTER_API(NewStringObj);
-  JIM_REGISTER_API(NewStringObjNoAlloc);
-  JIM_REGISTER_API(AppendString);
-  JIM_REGISTER_API(AppendString_sprintf);
-  JIM_REGISTER_API(AppendObj);
-  JIM_REGISTER_API(AppendStrings);
-  JIM_REGISTER_API(StringEqObj);
-  JIM_REGISTER_API(StringMatchObj);
-  JIM_REGISTER_API(StringRangeObj);
-  JIM_REGISTER_API(FormatString);
-  JIM_REGISTER_API(CompareStringImmediate);
-  JIM_REGISTER_API(NewReference);
-  JIM_REGISTER_API(GetReference);
-  JIM_REGISTER_API(SetFinalizer);
-  JIM_REGISTER_API(GetFinalizer);
-  JIM_REGISTER_API(CreateInterp);
-  JIM_REGISTER_API(FreeInterp);
-  JIM_REGISTER_API(GetExitCode);
-  JIM_REGISTER_API(SetStdin);
-  JIM_REGISTER_API(SetStdout);
-  JIM_REGISTER_API(SetStderr);
-  JIM_REGISTER_API(CreateCommand);
-  JIM_REGISTER_API(CreateProcedure);
-  JIM_REGISTER_API(DeleteCommand);
-  JIM_REGISTER_API(RenameCommand);
-  JIM_REGISTER_API(GetCommand);
-  JIM_REGISTER_API(SetVariable);
-  JIM_REGISTER_API(SetVariableStr);
-  JIM_REGISTER_API(SetGlobalVariableStr);
-  JIM_REGISTER_API(SetVariableStrWithStr);
-  JIM_REGISTER_API(SetVariableLink);
-  JIM_REGISTER_API(GetVariable);
-  JIM_REGISTER_API(GetCallFrameByLevel);
-  JIM_REGISTER_API(Collect);
-  JIM_REGISTER_API(CollectIfNeeded);
-  JIM_REGISTER_API(GetIndex);
-  JIM_REGISTER_API(NewListObj);
-  JIM_REGISTER_API(ListAppendElement);
-  JIM_REGISTER_API(ListAppendList);
-  JIM_REGISTER_API(ListLength);
-  JIM_REGISTER_API(ListIndex);
-  JIM_REGISTER_API(SetListIndex);
-  JIM_REGISTER_API(ConcatObj);
-  JIM_REGISTER_API(NewDictObj);
-  JIM_REGISTER_API(DictKey);
-  JIM_REGISTER_API(DictKeysVector);
-  JIM_REGISTER_API(GetIndex);
-  JIM_REGISTER_API(GetReturnCode);
-  JIM_REGISTER_API(EvalExpression);
-  JIM_REGISTER_API(GetBoolFromExpr);
-  JIM_REGISTER_API(GetWide);
-  JIM_REGISTER_API(GetLong);
-  JIM_REGISTER_API(SetWide);
-  JIM_REGISTER_API(NewIntObj);
-  JIM_REGISTER_API(GetDouble);
-  JIM_REGISTER_API(SetDouble);
-  JIM_REGISTER_API(NewDoubleObj);
-  JIM_REGISTER_API(WrongNumArgs);
-  JIM_REGISTER_API(SetDictKeysVector);
-  JIM_REGISTER_API(SubstObj);
-  JIM_REGISTER_API(RegisterApi);
-  JIM_REGISTER_API(PrintErrorMessage);
-  JIM_REGISTER_API(InteractivePrompt);
-  JIM_REGISTER_API(RegisterCoreCommands);
-  JIM_REGISTER_API(GetSharedString);
-  JIM_REGISTER_API(ReleaseSharedString);
-  JIM_REGISTER_API(Panic);
-  JIM_REGISTER_API(StrDup);
-  JIM_REGISTER_API(UnsetVariable);
-  JIM_REGISTER_API(GetVariableStr);
-  JIM_REGISTER_API(GetGlobalVariable);
-  JIM_REGISTER_API(GetGlobalVariableStr);
-  JIM_REGISTER_API(GetAssocData);
-  JIM_REGISTER_API(SetAssocData);
-  JIM_REGISTER_API(DeleteAssocData);
-  JIM_REGISTER_API(GetEnum);
-  JIM_REGISTER_API(ScriptIsComplete);
-  JIM_REGISTER_API(PackageRequire);
-  JIM_REGISTER_API(PackageProvide);
-  JIM_REGISTER_API(InitStack);
-  JIM_REGISTER_API(FreeStack);
-  JIM_REGISTER_API(StackLen);
-  JIM_REGISTER_API(StackPush);
-  JIM_REGISTER_API(StackPop);
-  JIM_REGISTER_API(StackPeek);
-  JIM_REGISTER_API(FreeStackElements);
-  JIM_REGISTER_API(fprintf);
-  JIM_REGISTER_API(vfprintf);
-  JIM_REGISTER_API(fwrite);
-  JIM_REGISTER_API(fread);
-  JIM_REGISTER_API(fflush);
-  JIM_REGISTER_API(fgets);
-  JIM_REGISTER_API(GetNvp);
-  JIM_REGISTER_API(Nvp_name2value);
-  JIM_REGISTER_API(Nvp_name2value_simple);
-  JIM_REGISTER_API(Nvp_name2value_obj);
-  JIM_REGISTER_API(Nvp_name2value_nocase);
-  JIM_REGISTER_API(Nvp_name2value_obj_nocase);
-
-  JIM_REGISTER_API(Nvp_value2name);
-  JIM_REGISTER_API(Nvp_value2name_simple);
-  JIM_REGISTER_API(Nvp_value2name_obj);
-
-  JIM_REGISTER_API(GetOpt_Setup);
-  JIM_REGISTER_API(GetOpt_Debug);
-  JIM_REGISTER_API(GetOpt_Obj);
-  JIM_REGISTER_API(GetOpt_String);
-  JIM_REGISTER_API(GetOpt_Double);
-  JIM_REGISTER_API(GetOpt_Wide);
-  JIM_REGISTER_API(GetOpt_Nvp);
-  JIM_REGISTER_API(GetOpt_NvpUnknown);
-  JIM_REGISTER_API(GetOpt_Enum);
-
-  JIM_REGISTER_API(Debug_ArgvString);
-  JIM_REGISTER_API(SetResult_sprintf);
-  JIM_REGISTER_API(SetResult_NvpUnknown);
-
-}
-
-/* -----------------------------------------------------------------------------
- * Core commands utility functions
- * ---------------------------------------------------------------------------*/
-void Jim_WrongNumArgs(Jim_Interp *interp, int argc, Jim_Obj *const *argv,
-        const char *msg)
-{
-    int i;
-    Jim_Obj *objPtr = Jim_NewEmptyStringObj(interp);
-
-    Jim_AppendString(interp, objPtr, "wrong # args: should be \"", -1);
-    for (i = 0; i < argc; i++) {
-        Jim_AppendObj(interp, objPtr, argv[i]);
-        if (!(i + 1 == argc && msg[0] == '\0'))
-            Jim_AppendString(interp, objPtr, " ", 1);
-    }
-    Jim_AppendString(interp, objPtr, msg, -1);
-    Jim_AppendString(interp, objPtr, "\"", 1);
-    Jim_SetResult(interp, objPtr);
-}
-
-static Jim_Obj *JimCommandsList(Jim_Interp *interp, Jim_Obj *patternObjPtr)
-{
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
-    const char *pattern;
-    int patternLen=0;
-
-    pattern = patternObjPtr ? Jim_GetString(patternObjPtr, &patternLen) : NULL;
-    htiter = Jim_GetHashTableIterator(&interp->commands);
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        if (pattern && !JimStringMatch(pattern, patternLen, he->key,
-                    strlen((const char*)he->key), 0))
-            continue;
-        Jim_ListAppendElement(interp, listObjPtr,
-                Jim_NewStringObj(interp, he->key, -1));
-    }
-    Jim_FreeHashTableIterator(htiter);
-    return listObjPtr;
-}
-
-#define JIM_VARLIST_GLOBALS 0
-#define JIM_VARLIST_LOCALS 1
-#define JIM_VARLIST_VARS 2
-
-static Jim_Obj *JimVariablesList(Jim_Interp *interp, Jim_Obj *patternObjPtr,
-        int mode)
-{
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
-    const char *pattern;
-    int patternLen=0;
-
-    pattern = patternObjPtr ? Jim_GetString(patternObjPtr, &patternLen) : NULL;
-    if (mode == JIM_VARLIST_GLOBALS) {
-        htiter = Jim_GetHashTableIterator(&interp->topFramePtr->vars);
-    } else {
-        /* For [info locals], if we are at top level an emtpy list
-         * is returned. I don't agree, but we aim at compatibility (SS) */
-        if (mode == JIM_VARLIST_LOCALS &&
-            interp->framePtr == interp->topFramePtr)
-            return listObjPtr;
-        htiter = Jim_GetHashTableIterator(&interp->framePtr->vars);
-    }
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        Jim_Var *varPtr = (Jim_Var*) he->val;
-        if (mode == JIM_VARLIST_LOCALS) {
-            if (varPtr->linkFramePtr != NULL)
-                continue;
-        }
-        if (pattern && !JimStringMatch(pattern, patternLen, he->key,
-                    strlen((const char*)he->key), 0))
-            continue;
-        Jim_ListAppendElement(interp, listObjPtr,
-                Jim_NewStringObj(interp, he->key, -1));
-    }
-    Jim_FreeHashTableIterator(htiter);
-    return listObjPtr;
-}
-
-static int JimInfoLevel(Jim_Interp *interp, Jim_Obj *levelObjPtr,
-        Jim_Obj **objPtrPtr)
-{
-    Jim_CallFrame *targetCallFrame;
-
-    if (JimGetCallFrameByInteger(interp, levelObjPtr, &targetCallFrame)
-            != JIM_OK)
-        return JIM_ERR;
-    /* No proc call at toplevel callframe */
-    if (targetCallFrame == interp->topFramePtr) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "bad level \"",
-                Jim_GetString(levelObjPtr, NULL), "\"", NULL);
-        return JIM_ERR;
-    }
-    *objPtrPtr = Jim_NewListObj(interp,
-            targetCallFrame->argv,
-            targetCallFrame->argc);
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Core commands
- * ---------------------------------------------------------------------------*/
-
-/* fake [puts] -- not the real puts, just for debugging. */
-static int Jim_PutsCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *str;
-    int len, nonewline = 0;
-
-    if (argc != 2 && argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "-nonewline string");
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        if (!Jim_CompareStringImmediate(interp, argv[1], "-nonewline"))
-        {
-            Jim_SetResultString(interp, "The second argument must "
-                    "be -nonewline", -1);
-            return JIM_OK;
-        } else {
-            nonewline = 1;
-            argv++;
-        }
-    }
-    str = Jim_GetString(argv[1], &len);
-    Jim_fwrite(interp, str, 1, len, interp->cookie_stdout);
-    if (!nonewline) Jim_fprintf(interp, interp->cookie_stdout, JIM_NL);
-    return JIM_OK;
-}
-
-/* Helper for [+] and [*] */
-static int Jim_AddMulHelper(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv, int op)
-{
-    jim_wide wideValue, res;
-    double doubleValue, doubleRes;
-    int i;
-
-    res = (op == JIM_EXPROP_ADD) ? 0 : 1;
-
-    for (i = 1; i < argc; i++) {
-        if (Jim_GetWide(interp, argv[i], &wideValue) != JIM_OK)
-            goto trydouble;
-        if (op == JIM_EXPROP_ADD)
-            res += wideValue;
-        else
-            res *= wideValue;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, res));
-    return JIM_OK;
-trydouble:
-    doubleRes = (double) res;
-    for (;i < argc; i++) {
-        if (Jim_GetDouble(interp, argv[i], &doubleValue) != JIM_OK)
-            return JIM_ERR;
-        if (op == JIM_EXPROP_ADD)
-            doubleRes += doubleValue;
-        else
-            doubleRes *= doubleValue;
-    }
-    Jim_SetResult(interp, Jim_NewDoubleObj(interp, doubleRes));
-    return JIM_OK;
-}
-
-/* Helper for [-] and [/] */
-static int Jim_SubDivHelper(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv, int op)
-{
-    jim_wide wideValue, res = 0;
-    double doubleValue, doubleRes = 0;
-    int i = 2;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "number ?number ... number?");
-        return JIM_ERR;
-    } else if (argc == 2) {
-        /* The arity = 2 case is different. For [- x] returns -x,
-         * while [/ x] returns 1/x. */
-        if (Jim_GetWide(interp, argv[1], &wideValue) != JIM_OK) {
-            if (Jim_GetDouble(interp, argv[1], &doubleValue) !=
-                    JIM_OK)
-            {
-                return JIM_ERR;
-            } else {
-                if (op == JIM_EXPROP_SUB)
-                    doubleRes = -doubleValue;
-                else
-                    doubleRes = 1.0/doubleValue;
-                Jim_SetResult(interp, Jim_NewDoubleObj(interp,
-                            doubleRes));
-                return JIM_OK;
-            }
-        }
-        if (op == JIM_EXPROP_SUB) {
-            res = -wideValue;
-            Jim_SetResult(interp, Jim_NewIntObj(interp, res));
-        } else {
-            doubleRes = 1.0/wideValue;
-            Jim_SetResult(interp, Jim_NewDoubleObj(interp,
-                        doubleRes));
-        }
-        return JIM_OK;
-    } else {
-        if (Jim_GetWide(interp, argv[1], &res) != JIM_OK) {
-            if (Jim_GetDouble(interp, argv[1], &doubleRes)
-                    != JIM_OK) {
-                return JIM_ERR;
-            } else {
-                goto trydouble;
-            }
-        }
-    }
-    for (i = 2; i < argc; i++) {
-        if (Jim_GetWide(interp, argv[i], &wideValue) != JIM_OK) {
-            doubleRes = (double) res;
-            goto trydouble;
-        }
-        if (op == JIM_EXPROP_SUB)
-            res -= wideValue;
-        else
-            res /= wideValue;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, res));
-    return JIM_OK;
-trydouble:
-    for (;i < argc; i++) {
-        if (Jim_GetDouble(interp, argv[i], &doubleValue) != JIM_OK)
-            return JIM_ERR;
-        if (op == JIM_EXPROP_SUB)
-            doubleRes -= doubleValue;
-        else
-            doubleRes /= doubleValue;
-    }
-    Jim_SetResult(interp, Jim_NewDoubleObj(interp, doubleRes));
-    return JIM_OK;
-}
-
-
-/* [+] */
-static int Jim_AddCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_AddMulHelper(interp, argc, argv, JIM_EXPROP_ADD);
-}
-
-/* [*] */
-static int Jim_MulCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_AddMulHelper(interp, argc, argv, JIM_EXPROP_MUL);
-}
-
-/* [-] */
-static int Jim_SubCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_SubDivHelper(interp, argc, argv, JIM_EXPROP_SUB);
-}
-
-/* [/] */
-static int Jim_DivCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_SubDivHelper(interp, argc, argv, JIM_EXPROP_DIV);
-}
-
-/* [set] */
-static int Jim_SetCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 2 && argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "varName ?newValue?");
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        Jim_Obj *objPtr;
-        objPtr = Jim_GetVariable(interp, argv[1], JIM_ERRMSG);
-        if (!objPtr)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    }
-    /* argc == 3 case. */
-    if (Jim_SetVariable(interp, argv[1], argv[2]) != JIM_OK)
-        return JIM_ERR;
-    Jim_SetResult(interp, argv[2]);
-    return JIM_OK;
-}
-
-/* [unset] */
-static int Jim_UnsetCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int i;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "varName ?varName ...?");
-        return JIM_ERR;
-    }
-    for (i = 1; i < argc; i++) {
-        if (Jim_UnsetVariable(interp, argv[i], JIM_ERRMSG) != JIM_OK)
-            return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [incr] */
-static int Jim_IncrCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    jim_wide wideValue, increment = 1;
-    Jim_Obj *intObjPtr;
-
-    if (argc != 2 && argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "varName ?increment?");
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        if (Jim_GetWide(interp, argv[2], &increment) != JIM_OK)
-            return JIM_ERR;
-    }
-    intObjPtr = Jim_GetVariable(interp, argv[1], JIM_ERRMSG);
-    if (!intObjPtr) return JIM_ERR;
-    if (Jim_GetWide(interp, intObjPtr, &wideValue) != JIM_OK)
-        return JIM_ERR;
-    if (Jim_IsShared(intObjPtr)) {
-        intObjPtr = Jim_NewIntObj(interp, wideValue + increment);
-        if (Jim_SetVariable(interp, argv[1], intObjPtr) != JIM_OK) {
-            Jim_FreeNewObj(interp, intObjPtr);
-            return JIM_ERR;
-        }
-    } else {
-        Jim_SetWide(interp, intObjPtr, wideValue + increment);
-        /* The following step is required in order to invalidate the
-         * string repr of "FOO" if the var name is on the form of "FOO(IDX)" */
-        if (Jim_SetVariable(interp, argv[1], intObjPtr) != JIM_OK) {
-            return JIM_ERR;
-        }
-    }
-    Jim_SetResult(interp, intObjPtr);
-    return JIM_OK;
-}
-
-/* [while] */
-static int Jim_WhileCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "condition body");
-        return JIM_ERR;
-    }
-    /* Try to run a specialized version of while if the expression
-     * is in one of the following forms:
-     *
-     *   $a < CONST, $a < $b
-     *   $a <= CONST, $a <= $b
-     *   $a > CONST, $a > $b
-     *   $a >= CONST, $a >= $b
-     *   $a != CONST, $a != $b
-     *   $a == CONST, $a == $b
-     *   $a
-     *   !$a
-     *   CONST
-     */
-
-#ifdef JIM_OPTIMIZATION
-    {
-        ExprByteCode *expr;
-        Jim_Obj *varAObjPtr = NULL, *varBObjPtr = NULL, *objPtr;
-        int exprLen, retval;
-
-        /* STEP 1 -- Check if there are the conditions to run the specialized
-         * version of while */
-
-        if ((expr = Jim_GetExpression(interp, argv[1])) == NULL) goto noopt;
-        if (expr->len <= 0 || expr->len > 3) goto noopt;
-        switch (expr->len) {
-        case 1:
-            if (expr->opcode[0] != JIM_EXPROP_VARIABLE &&
-                expr->opcode[0] != JIM_EXPROP_NUMBER)
-                goto noopt;
-            break;
-        case 2:
-            if (expr->opcode[1] != JIM_EXPROP_NOT ||
-                expr->opcode[0] != JIM_EXPROP_VARIABLE)
-                goto noopt;
-            break;
-        case 3:
-            if (expr->opcode[0] != JIM_EXPROP_VARIABLE ||
-                (expr->opcode[1] != JIM_EXPROP_NUMBER &&
-                 expr->opcode[1] != JIM_EXPROP_VARIABLE))
-                goto noopt;
-            switch (expr->opcode[2]) {
-            case JIM_EXPROP_LT:
-            case JIM_EXPROP_LTE:
-            case JIM_EXPROP_GT:
-            case JIM_EXPROP_GTE:
-            case JIM_EXPROP_NUMEQ:
-            case JIM_EXPROP_NUMNE:
-                /* nothing to do */
-                break;
-            default:
-                goto noopt;
-            }
-            break;
-        default:
-            Jim_Panic(interp,
-                "Unexpected default reached in Jim_WhileCoreCommand()");
-            break;
-        }
-
-        /* STEP 2 -- conditions meet. Initialization. Take different
-         * branches for different expression lengths. */
-        exprLen = expr->len;
-
-        if (exprLen == 1) {
-            jim_wide wideValue=0;
-
-            if (expr->opcode[0] == JIM_EXPROP_VARIABLE) {
-                varAObjPtr = expr->obj[0];
-                Jim_IncrRefCount(varAObjPtr);
-            } else {
-                if (Jim_GetWide(interp, expr->obj[0], &wideValue) != JIM_OK)
-                    goto noopt;
-            }
-            while (1) {
-                if (varAObjPtr) {
-                    if (!(objPtr =
-                               Jim_GetVariable(interp, varAObjPtr, JIM_NONE)) ||
-                        Jim_GetWide(interp, objPtr, &wideValue) != JIM_OK)
-                    {
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        goto noopt;
-                    }
-                }
-                if (!wideValue) break;
-                if ((retval = Jim_EvalObj(interp, argv[2])) != JIM_OK) {
-                    switch (retval) {
-                    case JIM_BREAK:
-                        if (varAObjPtr)
-                            Jim_DecrRefCount(interp, varAObjPtr);
-                        goto out;
-                        break;
-                    case JIM_CONTINUE:
-                        continue;
-                        break;
-                    default:
-                        if (varAObjPtr)
-                            Jim_DecrRefCount(interp, varAObjPtr);
-                        return retval;
-                    }
-                }
-            }
-            if (varAObjPtr)
-                Jim_DecrRefCount(interp, varAObjPtr);
-        } else if (exprLen == 3) {
-            jim_wide wideValueA, wideValueB=0, cmpRes = 0;
-            int cmpType = expr->opcode[2];
-
-            varAObjPtr = expr->obj[0];
-            Jim_IncrRefCount(varAObjPtr);
-            if (expr->opcode[1] == JIM_EXPROP_VARIABLE) {
-                varBObjPtr = expr->obj[1];
-                Jim_IncrRefCount(varBObjPtr);
-            } else {
-                if (Jim_GetWide(interp, expr->obj[1], &wideValueB) != JIM_OK)
-                    goto noopt;
-            }
-            while (1) {
-                if (!(objPtr = Jim_GetVariable(interp, varAObjPtr, JIM_NONE)) ||
-                    Jim_GetWide(interp, objPtr, &wideValueA) != JIM_OK)
-                {
-                    Jim_DecrRefCount(interp, varAObjPtr);
-                    if (varBObjPtr)
-                        Jim_DecrRefCount(interp, varBObjPtr);
-                    goto noopt;
-                }
-                if (varBObjPtr) {
-                    if (!(objPtr =
-                               Jim_GetVariable(interp, varBObjPtr, JIM_NONE)) ||
-                        Jim_GetWide(interp, objPtr, &wideValueB) != JIM_OK)
-                    {
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        Jim_DecrRefCount(interp, varBObjPtr);
-                        goto noopt;
-                    }
-                }
-                switch (cmpType) {
-                case JIM_EXPROP_LT:
-                    cmpRes = wideValueA < wideValueB; break;
-                case JIM_EXPROP_LTE:
-                    cmpRes = wideValueA <= wideValueB; break;
-                case JIM_EXPROP_GT:
-                    cmpRes = wideValueA > wideValueB; break;
-                case JIM_EXPROP_GTE:
-                    cmpRes = wideValueA >= wideValueB; break;
-                case JIM_EXPROP_NUMEQ:
-                    cmpRes = wideValueA == wideValueB; break;
-                case JIM_EXPROP_NUMNE:
-                    cmpRes = wideValueA != wideValueB; break;
-                }
-                if (!cmpRes) break;
-                if ((retval = Jim_EvalObj(interp, argv[2])) != JIM_OK) {
-                    switch (retval) {
-                    case JIM_BREAK:
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        if (varBObjPtr)
-                            Jim_DecrRefCount(interp, varBObjPtr);
-                        goto out;
-                        break;
-                    case JIM_CONTINUE:
-                        continue;
-                        break;
-                    default:
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        if (varBObjPtr)
-                            Jim_DecrRefCount(interp, varBObjPtr);
-                        return retval;
-                    }
-                }
-            }
-            Jim_DecrRefCount(interp, varAObjPtr);
-            if (varBObjPtr)
-                Jim_DecrRefCount(interp, varBObjPtr);
-        } else {
-            /* TODO: case for len == 2 */
-            goto noopt;
-        }
-        Jim_SetEmptyResult(interp);
-        return JIM_OK;
-    }
-noopt:
-#endif
-
-    /* The general purpose implementation of while starts here */
-    while (1) {
-        int boolean, retval;
-
-        if ((retval = Jim_GetBoolFromExpr(interp, argv[1],
-                        &boolean)) != JIM_OK)
-            return retval;
-        if (!boolean) break;
-        if ((retval = Jim_EvalObj(interp, argv[2])) != JIM_OK) {
-            switch (retval) {
-            case JIM_BREAK:
-                goto out;
-                break;
-            case JIM_CONTINUE:
-                continue;
-                break;
-            default:
-                return retval;
-            }
-        }
-    }
-out:
-    Jim_SetEmptyResult(interp);
-    return JIM_OK;
-}
-
-/* [for] */
-static int Jim_ForCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int retval;
-
-    if (argc != 5) {
-        Jim_WrongNumArgs(interp, 1, argv, "start test next body");
-        return JIM_ERR;
-    }
-    /* Check if the for is on the form:
-     *      for {set i CONST} {$i < CONST} {incr i}
-     *      for {set i CONST} {$i < $j} {incr i}
-     *      for {set i CONST} {$i <= CONST} {incr i}
-     *      for {set i CONST} {$i <= $j} {incr i}
-     * XXX: NOTE: if variable traces are implemented, this optimization
-     * need to be modified to check for the proc epoch at every variable
-     * update. */
-#ifdef JIM_OPTIMIZATION
-    {
-        ScriptObj *initScript, *incrScript;
-        ExprByteCode *expr;
-        jim_wide start, stop=0, currentVal;
-        unsigned jim_wide procEpoch = interp->procEpoch;
-        Jim_Obj *varNamePtr, *stopVarNamePtr = NULL, *objPtr;
-        int cmpType;
-        struct Jim_Cmd *cmdPtr;
-
-        /* Do it only if there aren't shared arguments */
-        if (argv[1] == argv[2] || argv[2] == argv[3] || argv[1] == argv[3])
-            goto evalstart;
-        initScript = Jim_GetScript(interp, argv[1]);
-        expr = Jim_GetExpression(interp, argv[2]);
-        incrScript = Jim_GetScript(interp, argv[3]);
-
-        /* Ensure proper lengths to start */
-        if (initScript->len != 6) goto evalstart;
-        if (incrScript->len != 4) goto evalstart;
-        if (expr->len != 3) goto evalstart;
-        /* Ensure proper token types. */
-        if (initScript->token[2].type != JIM_TT_ESC ||
-            initScript->token[4].type != JIM_TT_ESC ||
-            incrScript->token[2].type != JIM_TT_ESC ||
-            expr->opcode[0] != JIM_EXPROP_VARIABLE ||
-            (expr->opcode[1] != JIM_EXPROP_NUMBER &&
-             expr->opcode[1] != JIM_EXPROP_VARIABLE) ||
-            (expr->opcode[2] != JIM_EXPROP_LT &&
-             expr->opcode[2] != JIM_EXPROP_LTE))
-            goto evalstart;
-        cmpType = expr->opcode[2];
-        /* Initialization command must be [set] */
-        cmdPtr = Jim_GetCommand(interp, initScript->token[0].objPtr, JIM_NONE);
-        if (cmdPtr == NULL || cmdPtr->cmdProc != Jim_SetCoreCommand)
-            goto evalstart;
-        /* Update command must be incr */
-        cmdPtr = Jim_GetCommand(interp, incrScript->token[0].objPtr, JIM_NONE);
-        if (cmdPtr == NULL || cmdPtr->cmdProc != Jim_IncrCoreCommand)
-            goto evalstart;
-        /* set, incr, expression must be about the same variable */
-        if (!Jim_StringEqObj(initScript->token[2].objPtr,
-                            incrScript->token[2].objPtr, 0))
-            goto evalstart;
-        if (!Jim_StringEqObj(initScript->token[2].objPtr,
-                            expr->obj[0], 0))
-            goto evalstart;
-        /* Check that the initialization and comparison are valid integers */
-        if (Jim_GetWide(interp, initScript->token[4].objPtr, &start) == JIM_ERR)
-            goto evalstart;
-        if (expr->opcode[1] == JIM_EXPROP_NUMBER &&
-            Jim_GetWide(interp, expr->obj[1], &stop) == JIM_ERR)
-        {
-            goto evalstart;
-        }
-
-        /* Initialization */
-        varNamePtr = expr->obj[0];
-        if (expr->opcode[1] == JIM_EXPROP_VARIABLE) {
-            stopVarNamePtr = expr->obj[1];
-            Jim_IncrRefCount(stopVarNamePtr);
-        }
-        Jim_IncrRefCount(varNamePtr);
-
-        /* --- OPTIMIZED FOR --- */
-        /* Start to loop */
-        objPtr = Jim_NewIntObj(interp, start);
-        if (Jim_SetVariable(interp, varNamePtr, objPtr) != JIM_OK) {
-            Jim_DecrRefCount(interp, varNamePtr);
-            if (stopVarNamePtr) Jim_DecrRefCount(interp, stopVarNamePtr);
-            Jim_FreeNewObj(interp, objPtr);
-            goto evalstart;
-        }
-        while (1) {
-            /* === Check condition === */
-            /* Common code: */
-            objPtr = Jim_GetVariable(interp, varNamePtr, JIM_NONE);
-            if (objPtr == NULL ||
-                Jim_GetWide(interp, objPtr, &currentVal) != JIM_OK)
-            {
-                Jim_DecrRefCount(interp, varNamePtr);
-                if (stopVarNamePtr) Jim_DecrRefCount(interp, stopVarNamePtr);
-                goto testcond;
-            }
-            /* Immediate or Variable? get the 'stop' value if the latter. */
-            if (stopVarNamePtr) {
-                objPtr = Jim_GetVariable(interp, stopVarNamePtr, JIM_NONE);
-                if (objPtr == NULL ||
-                    Jim_GetWide(interp, objPtr, &stop) != JIM_OK)
-                {
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    Jim_DecrRefCount(interp, stopVarNamePtr);
-                    goto testcond;
-                }
-            }
-            if (cmpType == JIM_EXPROP_LT) {
-                if (currentVal >= stop) break;
-            } else {
-                if (currentVal > stop) break;
-            }
-            /* Eval body */
-            if ((retval = Jim_EvalObj(interp, argv[4])) != JIM_OK) {
-                switch (retval) {
-                case JIM_BREAK:
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    goto out;
-                case JIM_CONTINUE:
-                    /* nothing to do */
-                    break;
-                default:
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    return retval;
-                }
-            }
-            /* If there was a change in procedures/command continue
-             * with the usual [for] command implementation */
-            if (procEpoch != interp->procEpoch) {
-                if (stopVarNamePtr)
-                    Jim_DecrRefCount(interp, stopVarNamePtr);
-                Jim_DecrRefCount(interp, varNamePtr);
-                goto evalnext;
-            }
-            /* Increment */
-            objPtr = Jim_GetVariable(interp, varNamePtr, JIM_ERRMSG);
-            if (objPtr->refCount == 1 && objPtr->typePtr == &intObjType) {
-                objPtr->internalRep.wideValue ++;
-                Jim_InvalidateStringRep(objPtr);
-            } else {
-                Jim_Obj *auxObjPtr;
-
-                if (Jim_GetWide(interp, objPtr, &currentVal) == JIM_ERR) {
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    goto evalnext;
-                }
-                auxObjPtr = Jim_NewIntObj(interp, currentVal + 1);
-                if (Jim_SetVariable(interp, varNamePtr, auxObjPtr) == JIM_ERR) {
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    Jim_FreeNewObj(interp, auxObjPtr);
-                    goto evalnext;
-                }
-            }
-        }
-        if (stopVarNamePtr)
-            Jim_DecrRefCount(interp, stopVarNamePtr);
-        Jim_DecrRefCount(interp, varNamePtr);
-        Jim_SetEmptyResult(interp);
-        return JIM_OK;
-    }
-#endif
-evalstart:
-    /* Eval start */
-    if ((retval = Jim_EvalObj(interp, argv[1])) != JIM_OK)
-        return retval;
-    while (1) {
-        int boolean;
-testcond:
-        /* Test the condition */
-        if ((retval = Jim_GetBoolFromExpr(interp, argv[2], &boolean))
-                != JIM_OK)
-            return retval;
-        if (!boolean) break;
-        /* Eval body */
-        if ((retval = Jim_EvalObj(interp, argv[4])) != JIM_OK) {
-            switch (retval) {
-            case JIM_BREAK:
-                goto out;
-                break;
-            case JIM_CONTINUE:
-                /* Nothing to do */
-                break;
-            default:
-                return retval;
-            }
-        }
-evalnext:
-        /* Eval next */
-        if ((retval = Jim_EvalObj(interp, argv[3])) != JIM_OK) {
-            switch (retval) {
-            case JIM_BREAK:
-                goto out;
-                break;
-            case JIM_CONTINUE:
-                continue;
-                break;
-            default:
-                return retval;
-            }
-        }
-    }
-out:
-    Jim_SetEmptyResult(interp);
-    return JIM_OK;
-}
-
-/* foreach + lmap implementation. */
-static int JimForeachMapHelper(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv, int doMap)
-{
-    int result = JIM_ERR, i, nbrOfLists, *listsIdx, *listsEnd;
-    int nbrOfLoops = 0;
-    Jim_Obj *emptyStr, *script, *mapRes = NULL;
-
-    if (argc < 4 || argc % 2 != 0) {
-        Jim_WrongNumArgs(interp, 1, argv, "varList list ?varList list ...? script");
-        return JIM_ERR;
-    }
-    if (doMap) {
-        mapRes = Jim_NewListObj(interp, NULL, 0);
-        Jim_IncrRefCount(mapRes);
-    }
-    emptyStr = Jim_NewEmptyStringObj(interp);
-    Jim_IncrRefCount(emptyStr);
-    script = argv[argc-1];            /* Last argument is a script */
-    nbrOfLists = (argc - 1 - 1) / 2;  /* argc - 'foreach' - script */
-    listsIdx = (int*)Jim_Alloc(nbrOfLists * sizeof(int));
-    listsEnd = (int*)Jim_Alloc(nbrOfLists*2 * sizeof(int));
-    /* Initialize iterators and remember max nbr elements each list */
-    memset(listsIdx, 0, nbrOfLists * sizeof(int));
-    /* Remember lengths of all lists and calculate how much rounds to loop */
-    for (i = 0; i < nbrOfLists*2; i += 2) {
-        div_t cnt;
-        int count;
-        Jim_ListLength(interp, argv[i + 1], &listsEnd[i]);
-        Jim_ListLength(interp, argv[i + 2], &listsEnd[i + 1]);
-        if (listsEnd[i] == 0) {
-            Jim_SetResultString(interp, "foreach varlist is empty", -1);
-            goto err;
-        }
-        cnt = div(listsEnd[i + 1], listsEnd[i]);
-        count = cnt.quot + (cnt.rem ? 1 : 0);
-        if (count > nbrOfLoops)
-            nbrOfLoops = count;
-    }
-    for (; nbrOfLoops-- > 0;) {
-        for (i = 0; i < nbrOfLists; ++i) {
-            int varIdx = 0, var = i * 2;
-            while (varIdx < listsEnd[var]) {
-                Jim_Obj *varName, *ele;
-                int lst = i * 2 + 1;
-                if (Jim_ListIndex(interp, argv[var + 1], varIdx, &varName, JIM_ERRMSG)
-                        != JIM_OK)
-                        goto err;
-                if (listsIdx[i] < listsEnd[lst]) {
-                    if (Jim_ListIndex(interp, argv[lst + 1], listsIdx[i], &ele, JIM_ERRMSG)
-                        != JIM_OK)
-                        goto err;
-                    if (Jim_SetVariable(interp, varName, ele) != JIM_OK) {
-                        Jim_SetResultString(interp, "couldn't set loop variable: ", -1);
-                        goto err;
-                    }
-                    ++listsIdx[i];  /* Remember next iterator of current list */
-                } else if (Jim_SetVariable(interp, varName, emptyStr) != JIM_OK) {
-                    Jim_SetResultString(interp, "couldn't set loop variable: ", -1);
-                    goto err;
-                }
-                ++varIdx;  /* Next variable */
-            }
-        }
-        switch (result = Jim_EvalObj(interp, script)) {
-            case JIM_OK:
-                if (doMap)
-                    Jim_ListAppendElement(interp, mapRes, interp->result);
-                break;
-            case JIM_CONTINUE:
-                break;
-            case JIM_BREAK:
-                goto out;
-                break;
-            default:
-                goto err;
-        }
-    }
-out:
-    result = JIM_OK;
-    if (doMap)
-        Jim_SetResult(interp, mapRes);
-    else
-        Jim_SetEmptyResult(interp);
-err:
-    if (doMap)
-        Jim_DecrRefCount(interp, mapRes);
-    Jim_DecrRefCount(interp, emptyStr);
-    Jim_Free(listsIdx);
-    Jim_Free(listsEnd);
-    return result;
-}
-
-/* [foreach] */
-static int Jim_ForeachCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return JimForeachMapHelper(interp, argc, argv, 0);
-}
-
-/* [lmap] */
-static int Jim_LmapCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return JimForeachMapHelper(interp, argc, argv, 1);
-}
-
-/* [if] */
-static int Jim_IfCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int boolean, retval, current = 1, falsebody = 0;
-    if (argc >= 3) {
-        while (1) {
-            /* Far not enough arguments given! */
-            if (current >= argc) goto err;
-            if ((retval = Jim_GetBoolFromExpr(interp,
-                        argv[current++], &boolean))
-                    != JIM_OK)
-                return retval;
-            /* There lacks something, isn't it? */
-            if (current >= argc) goto err;
-            if (Jim_CompareStringImmediate(interp, argv[current],
-                        "then")) current++;
-            /* Tsk tsk, no then-clause? */
-            if (current >= argc) goto err;
-            if (boolean)
-                return Jim_EvalObj(interp, argv[current]);
-             /* Ok: no else-clause follows */
-            if (++current >= argc) {
-            	Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            	return JIM_OK;
-            }
-            falsebody = current++;
-            if (Jim_CompareStringImmediate(interp, argv[falsebody],
-                        "else")) {
-                /* IIICKS - else-clause isn't last cmd? */
-                if (current != argc-1) goto err;
-                return Jim_EvalObj(interp, argv[current]);
-            } else if (Jim_CompareStringImmediate(interp,
-                        argv[falsebody], "elseif"))
-                /* Ok: elseif follows meaning all the stuff
-                 * again (how boring...) */
-                continue;
-            /* OOPS - else-clause is not last cmd?*/
-            else if (falsebody != argc-1)
-                goto err;
-            return Jim_EvalObj(interp, argv[falsebody]);
-        }
-        return JIM_OK;
-    }
-err:
-    Jim_WrongNumArgs(interp, 1, argv, "condition ?then? trueBody ?elseif ...? ?else? falseBody");
-    return JIM_ERR;
-}
-
-enum {SWITCH_EXACT, SWITCH_GLOB, SWITCH_RE, SWITCH_CMD, SWITCH_UNKNOWN};
-
-/* [switch] */
-static int Jim_SwitchCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int retcode = JIM_ERR, matchOpt = SWITCH_EXACT, opt = 1, patCount, i;
-    Jim_Obj *command = 0, *const *caseList = 0, *strObj;
-    Jim_Obj *script = 0;
-    if (argc < 3) goto wrongnumargs;
-    for (opt = 1; opt < argc; ++opt) {
-        const char *option = Jim_GetString(argv[opt], 0);
-        if (*option != '-') break;
-        else if (strncmp(option, "--", 2) == 0) { ++opt; break; }
-        else if (strncmp(option, "-exact", 2) == 0) matchOpt = SWITCH_EXACT;
-        else if (strncmp(option, "-glob", 2) == 0) matchOpt = SWITCH_GLOB;
-        else if (strncmp(option, "-regexp", 2) == 0) matchOpt = SWITCH_RE;
-        else if (strncmp(option, "-command", 2) == 0) { matchOpt = SWITCH_CMD;
-            if ((argc - opt) < 2) goto wrongnumargs;
-            command = argv[++opt];
-        } else {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "bad option \"", option, "\": must be -exact, -glob, "
-                "-regexp, -command procname or --", 0);
-            goto err;
-        }
-        if ((argc - opt) < 2) goto wrongnumargs;
-    }
-    strObj = argv[opt++];
-    patCount = argc - opt;
-    if (patCount == 1) {
-        Jim_Obj **vector;
-        JimListGetElements(interp, argv[opt], &patCount, &vector);
-        caseList = vector;
-    } else
-        caseList = &argv[opt];
-    if (patCount == 0 || patCount % 2 != 0) goto wrongnumargs;
-    for (i = 0; script == 0 && i < patCount; i += 2) {
-        Jim_Obj *patObj = caseList[i];
-        if (!Jim_CompareStringImmediate(interp, patObj, "default")
-            || i < (patCount-2)) {
-            switch (matchOpt) {
-                case SWITCH_EXACT:
-                    if (Jim_StringEqObj(strObj, patObj, 0))
-                        script = caseList[i + 1];
-                    break;
-                case SWITCH_GLOB:
-                    if (Jim_StringMatchObj(patObj, strObj, 0))
-                        script = caseList[i + 1];
-                    break;
-                case SWITCH_RE:
-                    command = Jim_NewStringObj(interp, "regexp", -1);
-                    /* Fall thru intentionally */
-                case SWITCH_CMD: {
-                    Jim_Obj *parms[] = {command, patObj, strObj};
-                    int rc = Jim_EvalObjVector(interp, 3, parms);
-                    long matching;
-                    /* After the execution of a command we need to
-                     * make sure to reconvert the object into a list
-                     * again. Only for the single-list style [switch]. */
-                    if (argc-opt == 1) {
-                        Jim_Obj **vector;
-                        JimListGetElements(interp, argv[opt], &patCount,
-                                &vector);
-                        caseList = vector;
-                    }
-                    /* command is here already decref'd */
-                    if (rc != JIM_OK) {
-                        retcode = rc;
-                        goto err;
-                    }
-                    rc = Jim_GetLong(interp, Jim_GetResult(interp), &matching);
-                    if (rc != JIM_OK) {
-                        retcode = rc;
-                        goto err;
-                    }
-                    if (matching)
-                        script = caseList[i + 1];
-                    break;
-                }
-                default:
-                    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-                    Jim_AppendStrings(interp, Jim_GetResult(interp),
-                        "internal error: no such option implemented", 0);
-                    goto err;
-            }
-        } else {
-          script = caseList[i + 1];
-        }
-    }
-    for (; i < patCount && Jim_CompareStringImmediate(interp, script, "-");
-        i += 2)
-        script = caseList[i + 1];
-    if (script && Jim_CompareStringImmediate(interp, script, "-")) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "no body specified for pattern \"",
-            Jim_GetString(caseList[i-2], 0), "\"", 0);
-        goto err;
-    }
-    retcode = JIM_OK;
-    Jim_SetEmptyResult(interp);
-    if (script != 0)
-        retcode = Jim_EvalObj(interp, script);
-    return retcode;
-wrongnumargs:
-    Jim_WrongNumArgs(interp, 1, argv, "?options? string "
-        "pattern body ... ?default body?   or   "
-        "{pattern body ?pattern body ...?}");
-err:
-    return retcode;
-}
-
-/* [list] */
-static int Jim_ListCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *listObjPtr;
-
-    listObjPtr = Jim_NewListObj(interp, argv + 1, argc-1);
-    Jim_SetResult(interp, listObjPtr);
-    return JIM_OK;
-}
-
-/* [lindex] */
-static int Jim_LindexCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr, *listObjPtr;
-    int i;
-    int index_t;
-
-    if (argc < 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "list index ?...?");
-        return JIM_ERR;
-    }
-    objPtr = argv[1];
-    Jim_IncrRefCount(objPtr);
-    for (i = 2; i < argc; i++) {
-        listObjPtr = objPtr;
-        if (Jim_GetIndex(interp, argv[i], &index_t) != JIM_OK) {
-            Jim_DecrRefCount(interp, listObjPtr);
-            return JIM_ERR;
-        }
-        if (Jim_ListIndex(interp, listObjPtr, index_t, &objPtr,
-                    JIM_NONE) != JIM_OK) {
-            /* Returns an empty object if the index
-             * is out of range. */
-            Jim_DecrRefCount(interp, listObjPtr);
-            Jim_SetEmptyResult(interp);
-            return JIM_OK;
-        }
-        Jim_IncrRefCount(objPtr);
-        Jim_DecrRefCount(interp, listObjPtr);
-    }
-    Jim_SetResult(interp, objPtr);
-    Jim_DecrRefCount(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [llength] */
-static int Jim_LlengthCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int len;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "list");
-        return JIM_ERR;
-    }
-    Jim_ListLength(interp, argv[1], &len);
-    Jim_SetResult(interp, Jim_NewIntObj(interp, len));
-    return JIM_OK;
-}
-
-/* [lappend] */
-static int Jim_LappendCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *listObjPtr;
-    int shared, i;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "varName ?value value ...?");
-        return JIM_ERR;
-    }
-    listObjPtr = Jim_GetVariable(interp, argv[1], JIM_NONE);
-    if (!listObjPtr) {
-        /* Create the list if it does not exists */
-        listObjPtr = Jim_NewListObj(interp, NULL, 0);
-        if (Jim_SetVariable(interp, argv[1], listObjPtr) != JIM_OK) {
-            Jim_FreeNewObj(interp, listObjPtr);
-            return JIM_ERR;
-        }
-    }
-    shared = Jim_IsShared(listObjPtr);
-    if (shared)
-        listObjPtr = Jim_DuplicateObj(interp, listObjPtr);
-    for (i = 2; i < argc; i++)
-        Jim_ListAppendElement(interp, listObjPtr, argv[i]);
-    if (Jim_SetVariable(interp, argv[1], listObjPtr) != JIM_OK) {
-        if (shared)
-            Jim_FreeNewObj(interp, listObjPtr);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, listObjPtr);
-    return JIM_OK;
-}
-
-/* [linsert] */
-static int Jim_LinsertCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int index_t, len;
-    Jim_Obj *listPtr;
-
-    if (argc < 4) {
-        Jim_WrongNumArgs(interp, 1, argv, "list index element "
-            "?element ...?");
-        return JIM_ERR;
-    }
-    listPtr = argv[1];
-    if (Jim_IsShared(listPtr))
-        listPtr = Jim_DuplicateObj(interp, listPtr);
-    if (Jim_GetIndex(interp, argv[2], &index_t) != JIM_OK)
-        goto err;
-    Jim_ListLength(interp, listPtr, &len);
-    if (index_t >= len)
-        index_t = len;
-    else if (index_t < 0)
-        index_t = len + index_t + 1;
-    Jim_ListInsertElements(interp, listPtr, index_t, argc-3, &argv[3]);
-    Jim_SetResult(interp, listPtr);
-    return JIM_OK;
-err:
-    if (listPtr != argv[1]) {
-        Jim_FreeNewObj(interp, listPtr);
-    }
-    return JIM_ERR;
-}
-
-/* [lset] */
-static int Jim_LsetCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc < 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "listVar ?index...? newVal");
-        return JIM_ERR;
-    } else if (argc == 3) {
-        if (Jim_SetVariable(interp, argv[1], argv[2]) != JIM_OK)
-            return JIM_ERR;
-        Jim_SetResult(interp, argv[2]);
-        return JIM_OK;
-    }
-    if (Jim_SetListIndex(interp, argv[1], argv + 2, argc-3, argv[argc-1])
-            == JIM_ERR) return JIM_ERR;
-    return JIM_OK;
-}
-
-/* [lsort] */
-static int Jim_LsortCoreCommand(Jim_Interp *interp, int argc, Jim_Obj *const argv[])
-{
-    const char *options[] = {
-        "-ascii", "-nocase", "-increasing", "-decreasing", NULL
-    };
-    enum {OPT_ASCII, OPT_NOCASE, OPT_INCREASING, OPT_DECREASING};
-    Jim_Obj *resObj;
-    int i, lsortType = JIM_LSORT_ASCII; /* default sort type */
-    int decreasing = 0;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "?options? list");
-        return JIM_ERR;
-    }
-    for (i = 1; i < (argc-1); i++) {
-        int option;
-
-        if (Jim_GetEnum(interp, argv[i], options, &option, "option", JIM_ERRMSG)
-                != JIM_OK)
-            return JIM_ERR;
-        switch (option) {
-        case OPT_ASCII: lsortType = JIM_LSORT_ASCII; break;
-        case OPT_NOCASE: lsortType = JIM_LSORT_NOCASE; break;
-        case OPT_INCREASING: decreasing = 0; break;
-        case OPT_DECREASING: decreasing = 1; break;
-        }
-    }
-    if (decreasing) {
-        switch (lsortType) {
-        case JIM_LSORT_ASCII: lsortType = JIM_LSORT_ASCII_DECR; break;
-        case JIM_LSORT_NOCASE: lsortType = JIM_LSORT_NOCASE_DECR; break;
-        }
-    }
-    resObj = Jim_DuplicateObj(interp, argv[argc-1]);
-    ListSortElements(interp, resObj, lsortType);
-    Jim_SetResult(interp, resObj);
-    return JIM_OK;
-}
-
-/* [append] */
-static int Jim_AppendCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *stringObjPtr;
-    int shared, i;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "varName ?value value ...?");
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        stringObjPtr = Jim_GetVariable(interp, argv[1], JIM_ERRMSG);
-        if (!stringObjPtr) return JIM_ERR;
-    } else {
-        stringObjPtr = Jim_GetVariable(interp, argv[1], JIM_NONE);
-        if (!stringObjPtr) {
-            /* Create the string if it does not exists */
-            stringObjPtr = Jim_NewEmptyStringObj(interp);
-            if (Jim_SetVariable(interp, argv[1], stringObjPtr)
-                    != JIM_OK) {
-                Jim_FreeNewObj(interp, stringObjPtr);
-                return JIM_ERR;
-            }
-        }
-    }
-    shared = Jim_IsShared(stringObjPtr);
-    if (shared)
-        stringObjPtr = Jim_DuplicateObj(interp, stringObjPtr);
-    for (i = 2; i < argc; i++)
-        Jim_AppendObj(interp, stringObjPtr, argv[i]);
-    if (Jim_SetVariable(interp, argv[1], stringObjPtr) != JIM_OK) {
-        if (shared)
-            Jim_FreeNewObj(interp, stringObjPtr);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, stringObjPtr);
-    return JIM_OK;
-}
-
-/* [debug] */
-static int Jim_DebugCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *options[] = {
-        "refcount", "objcount", "objects", "invstr", "scriptlen", "exprlen",
-        "exprbc",
-        NULL
-    };
-    enum {
-        OPT_REFCOUNT, OPT_OBJCOUNT, OPT_OBJECTS, OPT_INVSTR, OPT_SCRIPTLEN,
-        OPT_EXPRLEN, OPT_EXPRBC
-    };
-    int option;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "option ?...?");
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], options, &option, "option",
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-    if (option == OPT_REFCOUNT) {
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "object");
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp, Jim_NewIntObj(interp, argv[2]->refCount));
-        return JIM_OK;
-    } else if (option == OPT_OBJCOUNT) {
-        int freeobj = 0, liveobj = 0;
-        char buf[256];
-        Jim_Obj *objPtr;
-
-        if (argc != 2) {
-            Jim_WrongNumArgs(interp, 2, argv, "");
-            return JIM_ERR;
-        }
-        /* Count the number of free objects. */
-        objPtr = interp->freeList;
-        while (objPtr) {
-            freeobj++;
-            objPtr = objPtr->nextObjPtr;
-        }
-        /* Count the number of live objects. */
-        objPtr = interp->liveList;
-        while (objPtr) {
-            liveobj++;
-            objPtr = objPtr->nextObjPtr;
-        }
-        /* Set the result string and return. */
-        sprintf(buf, "free %d used %d", freeobj, liveobj);
-        Jim_SetResultString(interp, buf, -1);
-        return JIM_OK;
-    } else if (option == OPT_OBJECTS) {
-        Jim_Obj *objPtr, *listObjPtr, *subListObjPtr;
-        /* Count the number of live objects. */
-        objPtr = interp->liveList;
-        listObjPtr = Jim_NewListObj(interp, NULL, 0);
-        while (objPtr) {
-            char buf[128];
-            const char *type = objPtr->typePtr ?
-                objPtr->typePtr->name : "";
-            subListObjPtr = Jim_NewListObj(interp, NULL, 0);
-            sprintf(buf, "%p", objPtr);
-            Jim_ListAppendElement(interp, subListObjPtr,
-                Jim_NewStringObj(interp, buf, -1));
-            Jim_ListAppendElement(interp, subListObjPtr,
-                Jim_NewStringObj(interp, type, -1));
-            Jim_ListAppendElement(interp, subListObjPtr,
-                Jim_NewIntObj(interp, objPtr->refCount));
-            Jim_ListAppendElement(interp, subListObjPtr, objPtr);
-            Jim_ListAppendElement(interp, listObjPtr, subListObjPtr);
-            objPtr = objPtr->nextObjPtr;
-        }
-        Jim_SetResult(interp, listObjPtr);
-        return JIM_OK;
-    } else if (option == OPT_INVSTR) {
-        Jim_Obj *objPtr;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "object");
-            return JIM_ERR;
-        }
-        objPtr = argv[2];
-        if (objPtr->typePtr != NULL)
-            Jim_InvalidateStringRep(objPtr);
-        Jim_SetEmptyResult(interp);
-        return JIM_OK;
-    } else if (option == OPT_SCRIPTLEN) {
-        ScriptObj *script;
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "script");
-            return JIM_ERR;
-        }
-        script = Jim_GetScript(interp, argv[2]);
-        Jim_SetResult(interp, Jim_NewIntObj(interp, script->len));
-        return JIM_OK;
-    } else if (option == OPT_EXPRLEN) {
-        ExprByteCode *expr;
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "expression");
-            return JIM_ERR;
-        }
-        expr = Jim_GetExpression(interp, argv[2]);
-        if (expr == NULL)
-            return JIM_ERR;
-        Jim_SetResult(interp, Jim_NewIntObj(interp, expr->len));
-        return JIM_OK;
-    } else if (option == OPT_EXPRBC) {
-        Jim_Obj *objPtr;
-        ExprByteCode *expr;
-        int i;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "expression");
-            return JIM_ERR;
-        }
-        expr = Jim_GetExpression(interp, argv[2]);
-        if (expr == NULL)
-            return JIM_ERR;
-        objPtr = Jim_NewListObj(interp, NULL, 0);
-        for (i = 0; i < expr->len; i++) {
-            const char *type;
-            Jim_ExprOperator *op;
-
-            switch (expr->opcode[i]) {
-            case JIM_EXPROP_NUMBER: type = "number"; break;
-            case JIM_EXPROP_COMMAND: type = "command"; break;
-            case JIM_EXPROP_VARIABLE: type = "variable"; break;
-            case JIM_EXPROP_DICTSUGAR: type = "dictsugar"; break;
-            case JIM_EXPROP_SUBST: type = "subst"; break;
-            case JIM_EXPROP_STRING: type = "string"; break;
-            default:
-                op = JimExprOperatorInfo(Jim_GetString(expr->obj[i], NULL));
-                if (op == NULL) {
-                    type = "private";
-                } else {
-                    type = "operator";
-                }
-                break;
-            }
-            Jim_ListAppendElement(interp, objPtr,
-                    Jim_NewStringObj(interp, type, -1));
-            Jim_ListAppendElement(interp, objPtr, expr->obj[i]);
-        }
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else {
-        Jim_SetResultString(interp,
-            "bad option. Valid options are refcount, "
-            "objcount, objects, invstr", -1);
-        return JIM_ERR;
-    }
-    return JIM_OK; /* unreached */
-}
-
-/* [eval] */
-static int Jim_EvalCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc == 2) {
-        return Jim_EvalObj(interp, argv[1]);
-    } else if (argc > 2) {
-        Jim_Obj *objPtr;
-        int retcode;
-
-        objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
-        Jim_IncrRefCount(objPtr);
-        retcode = Jim_EvalObj(interp, objPtr);
-        Jim_DecrRefCount(interp, objPtr);
-        return retcode;
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, "script ?...?");
-        return JIM_ERR;
-    }
-}
-
-/* [uplevel] */
-static int Jim_UplevelCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc >= 2) {
-        int retcode, newLevel, oldLevel;
-        Jim_CallFrame *savedCallFrame, *targetCallFrame;
-        Jim_Obj *objPtr;
-        const char *str;
-
-        /* Save the old callframe pointer */
-        savedCallFrame = interp->framePtr;
-
-        /* Lookup the target frame pointer */
-        str = Jim_GetString(argv[1], NULL);
-        if ((str[0] >= '0' && str[0] <= '9') || str[0] == '#')
-        {
-            if (Jim_GetCallFrameByLevel(interp, argv[1],
-                        &targetCallFrame,
-                        &newLevel) != JIM_OK)
-                return JIM_ERR;
-            argc--;
-            argv++;
-        } else {
-            if (Jim_GetCallFrameByLevel(interp, NULL,
-                        &targetCallFrame,
-                        &newLevel) != JIM_OK)
-                return JIM_ERR;
-        }
-        if (argc < 2) {
-            argc++;
-            argv--;
-            Jim_WrongNumArgs(interp, 1, argv,
-                    "?level? command ?arg ...?");
-            return JIM_ERR;
-        }
-        /* Eval the code in the target callframe. */
-        interp->framePtr = targetCallFrame;
-        oldLevel = interp->numLevels;
-        interp->numLevels = newLevel;
-        if (argc == 2) {
-            retcode = Jim_EvalObj(interp, argv[1]);
-        } else {
-            objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
-            Jim_IncrRefCount(objPtr);
-            retcode = Jim_EvalObj(interp, objPtr);
-            Jim_DecrRefCount(interp, objPtr);
-        }
-        interp->numLevels = oldLevel;
-        interp->framePtr = savedCallFrame;
-        return retcode;
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, "?level? command ?arg ...?");
-        return JIM_ERR;
-    }
-}
-
-/* [expr] */
-static int Jim_ExprCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *exprResultPtr;
-    int retcode;
-
-    if (argc == 2) {
-        retcode = Jim_EvalExpression(interp, argv[1], &exprResultPtr);
-    } else if (argc > 2) {
-        Jim_Obj *objPtr;
-
-        objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
-        Jim_IncrRefCount(objPtr);
-        retcode = Jim_EvalExpression(interp, objPtr, &exprResultPtr);
-        Jim_DecrRefCount(interp, objPtr);
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, "expression ?...?");
-        return JIM_ERR;
-    }
-    if (retcode != JIM_OK) return retcode;
-    Jim_SetResult(interp, exprResultPtr);
-    Jim_DecrRefCount(interp, exprResultPtr);
-    return JIM_OK;
-}
-
-/* [break] */
-static int Jim_BreakCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 1) {
-        Jim_WrongNumArgs(interp, 1, argv, "");
-        return JIM_ERR;
-    }
-    return JIM_BREAK;
-}
-
-/* [continue] */
-static int Jim_ContinueCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 1) {
-        Jim_WrongNumArgs(interp, 1, argv, "");
-        return JIM_ERR;
-    }
-    return JIM_CONTINUE;
-}
-
-/* [return] */
-static int Jim_ReturnCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc == 1) {
-        return JIM_RETURN;
-    } else if (argc == 2) {
-        Jim_SetResult(interp, argv[1]);
-        interp->returnCode = JIM_OK;
-        return JIM_RETURN;
-    } else if (argc == 3 || argc == 4) {
-        int returnCode;
-        if (Jim_GetReturnCode(interp, argv[2], &returnCode) == JIM_ERR)
-            return JIM_ERR;
-        interp->returnCode = returnCode;
-        if (argc == 4)
-            Jim_SetResult(interp, argv[3]);
-        return JIM_RETURN;
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, "?-code code? ?result?");
-        return JIM_ERR;
-    }
-    return JIM_RETURN; /* unreached */
-}
-
-/* [tailcall] */
-static int Jim_TailcallCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr;
-
-    objPtr = Jim_NewListObj(interp, argv + 1, argc-1);
-    Jim_SetResult(interp, objPtr);
-    return JIM_EVAL;
-}
-
-/* [proc] */
-static int Jim_ProcCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int argListLen;
-    int arityMin, arityMax;
-
-    if (argc != 4 && argc != 5) {
-        Jim_WrongNumArgs(interp, 1, argv, "name arglist ?statics? body");
-        return JIM_ERR;
-    }
-    Jim_ListLength(interp, argv[2], &argListLen);
-    arityMin = arityMax = argListLen + 1;
-
-    if (argListLen) {
-        const char *str;
-        int len;
-        Jim_Obj *argPtr=NULL;
-
-        /* Check for 'args' and adjust arityMin and arityMax if necessary */
-        Jim_ListIndex(interp, argv[2], argListLen-1, &argPtr, JIM_NONE);
-        str = Jim_GetString(argPtr, &len);
-        if (len == 4 && memcmp(str, "args", 4) == 0) {
-            arityMin--;
-            arityMax = -1;
-        }
-
-        /* Check for default arguments and reduce arityMin if necessary */
-        while (arityMin > 1) {
-            Jim_ListIndex(interp, argv[2], arityMin - 2, &argPtr, JIM_NONE);
-            Jim_ListLength(interp, argPtr, &len);
-            if (len != 2) {
-                /* No default argument */
-                break;
-            }
-            arityMin--;
-        }
-    }
-    if (argc == 4) {
-        return Jim_CreateProcedure(interp, Jim_GetString(argv[1], NULL),
-                argv[2], NULL, argv[3], arityMin, arityMax);
-    } else {
-        return Jim_CreateProcedure(interp, Jim_GetString(argv[1], NULL),
-                argv[2], argv[3], argv[4], arityMin, arityMax);
-    }
-}
-
-/* [concat] */
-static int Jim_ConcatCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_SetResult(interp, Jim_ConcatObj(interp, argc-1, argv + 1));
-    return JIM_OK;
-}
-
-/* [upvar] */
-static int Jim_UpvarCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *str;
-    int i;
-    Jim_CallFrame *targetCallFrame;
-
-    /* Lookup the target frame pointer */
-    str = Jim_GetString(argv[1], NULL);
-    if (argc > 3 &&
-        ((str[0] >= '0' && str[0] <= '9') || str[0] == '#'))
-    {
-        if (Jim_GetCallFrameByLevel(interp, argv[1],
-                    &targetCallFrame, NULL) != JIM_OK)
-            return JIM_ERR;
-        argc--;
-        argv++;
-    } else {
-        if (Jim_GetCallFrameByLevel(interp, NULL,
-                    &targetCallFrame, NULL) != JIM_OK)
-            return JIM_ERR;
-    }
-    /* Check for arity */
-    if (argc < 3 || ((argc-1)%2) != 0) {
-        Jim_WrongNumArgs(interp, 1, argv, "?level? otherVar localVar ?otherVar localVar ...?");
-        return JIM_ERR;
-    }
-    /* Now... for every other/local couple: */
-    for (i = 1; i < argc; i += 2) {
-        if (Jim_SetVariableLink(interp, argv[i + 1], argv[i],
-                targetCallFrame) != JIM_OK) return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [global] */
-static int Jim_GlobalCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int i;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "varName ?varName ...?");
-        return JIM_ERR;
-    }
-    /* Link every var to the toplevel having the same name */
-    if (interp->numLevels == 0) return JIM_OK; /* global at toplevel... */
-    for (i = 1; i < argc; i++) {
-        if (Jim_SetVariableLink(interp, argv[i], argv[i],
-                interp->topFramePtr) != JIM_OK) return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* does the [string map] operation. On error NULL is returned,
- * otherwise a new string object with the result, having refcount = 0,
- * is returned. */
-static Jim_Obj *JimStringMap(Jim_Interp *interp, Jim_Obj *mapListObjPtr,
-        Jim_Obj *objPtr, int nocase)
-{
-    int numMaps;
-    const char **key, *str, *noMatchStart = NULL;
-    Jim_Obj **value;
-    int *keyLen, strLen, i;
-    Jim_Obj *resultObjPtr;
-
-    Jim_ListLength(interp, mapListObjPtr, &numMaps);
-    if (numMaps % 2) {
-        Jim_SetResultString(interp,
-                "list must contain an even number of elements", -1);
-        return NULL;
-    }
-    /* Initialization */
-    numMaps /= 2;
-    key = Jim_Alloc(sizeof(char*)*numMaps);
-    keyLen = Jim_Alloc(sizeof(int)*numMaps);
-    value = Jim_Alloc(sizeof(Jim_Obj*)*numMaps);
-    resultObjPtr = Jim_NewStringObj(interp, "", 0);
-    for (i = 0; i < numMaps; i++) {
-        Jim_Obj *eleObjPtr=NULL;
-
-        Jim_ListIndex(interp, mapListObjPtr, i*2, &eleObjPtr, JIM_NONE);
-        key[i] = Jim_GetString(eleObjPtr, &keyLen[i]);
-        Jim_ListIndex(interp, mapListObjPtr, i*2 + 1, &eleObjPtr, JIM_NONE);
-        value[i] = eleObjPtr;
-    }
-    str = Jim_GetString(objPtr, &strLen);
-    /* Map it */
-    while (strLen) {
-        for (i = 0; i < numMaps; i++) {
-            if (strLen >= keyLen[i] && keyLen[i]) {
-                if (!JimStringCompare(str, keyLen[i], key[i], keyLen[i],
-                            nocase))
-                {
-                    if (noMatchStart) {
-                        Jim_AppendString(interp, resultObjPtr,
-                                noMatchStart, str-noMatchStart);
-                        noMatchStart = NULL;
-                    }
-                    Jim_AppendObj(interp, resultObjPtr, value[i]);
-                    str += keyLen[i];
-                    strLen -= keyLen[i];
-                    break;
-                }
-            }
-        }
-        if (i == numMaps) { /* no match */
-            if (noMatchStart == NULL)
-                noMatchStart = str;
-            str ++;
-            strLen --;
-        }
-    }
-    if (noMatchStart) {
-        Jim_AppendString(interp, resultObjPtr,
-            noMatchStart, str-noMatchStart);
-    }
-    Jim_Free((void*)key);
-    Jim_Free(keyLen);
-    Jim_Free(value);
-    return resultObjPtr;
-}
-
-/* [string] */
-static int Jim_StringCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int option;
-    const char *options[] = {
-        "length", "compare", "match", "equal", "range", "map", "repeat",
-        "index", "first", "tolower", "toupper", NULL
-    };
-    enum {
-        OPT_LENGTH, OPT_COMPARE, OPT_MATCH, OPT_EQUAL, OPT_RANGE,
-        OPT_MAP, OPT_REPEAT, OPT_INDEX, OPT_FIRST, OPT_TOLOWER, OPT_TOUPPER
-    };
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "option ?arguments ...?");
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], options, &option, "option",
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-
-    if (option == OPT_LENGTH) {
-        int len;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "string");
-            return JIM_ERR;
-        }
-        Jim_GetString(argv[2], &len);
-        Jim_SetResult(interp, Jim_NewIntObj(interp, len));
-        return JIM_OK;
-    } else if (option == OPT_COMPARE) {
-        int nocase = 0;
-        if ((argc != 4 && argc != 5) ||
-            (argc == 5 && Jim_CompareStringImmediate(interp,
-                argv[2], "-nocase") == 0)) {
-            Jim_WrongNumArgs(interp, 2, argv, "string1 string2");
-            return JIM_ERR;
-        }
-        if (argc == 5) {
-            nocase = 1;
-            argv++;
-        }
-        Jim_SetResult(interp, Jim_NewIntObj(interp,
-                    Jim_StringCompareObj(argv[2],
-                            argv[3], nocase)));
-        return JIM_OK;
-    } else if (option == OPT_MATCH) {
-        int nocase = 0;
-        if ((argc != 4 && argc != 5) ||
-            (argc == 5 && Jim_CompareStringImmediate(interp,
-                argv[2], "-nocase") == 0)) {
-            Jim_WrongNumArgs(interp, 2, argv, "?-nocase? pattern "
-                    "string");
-            return JIM_ERR;
-        }
-        if (argc == 5) {
-            nocase = 1;
-            argv++;
-        }
-        Jim_SetResult(interp,
-            Jim_NewIntObj(interp, Jim_StringMatchObj(argv[2],
-                    argv[3], nocase)));
-        return JIM_OK;
-    } else if (option == OPT_EQUAL) {
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, "string1 string2");
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp,
-            Jim_NewIntObj(interp, Jim_StringEqObj(argv[2],
-                    argv[3], 0)));
-        return JIM_OK;
-    } else if (option == OPT_RANGE) {
-        Jim_Obj *objPtr;
-
-        if (argc != 5) {
-            Jim_WrongNumArgs(interp, 2, argv, "string first last");
-            return JIM_ERR;
-        }
-        objPtr = Jim_StringRangeObj(interp, argv[2], argv[3], argv[4]);
-        if (objPtr == NULL)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_MAP) {
-        int nocase = 0;
-        Jim_Obj *objPtr;
-
-        if ((argc != 4 && argc != 5) ||
-            (argc == 5 && Jim_CompareStringImmediate(interp,
-                argv[2], "-nocase") == 0)) {
-            Jim_WrongNumArgs(interp, 2, argv, "?-nocase? mapList "
-                    "string");
-            return JIM_ERR;
-        }
-        if (argc == 5) {
-            nocase = 1;
-            argv++;
-        }
-        objPtr = JimStringMap(interp, argv[2], argv[3], nocase);
-        if (objPtr == NULL)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_REPEAT) {
-        Jim_Obj *objPtr;
-        jim_wide count;
-
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, "string count");
-            return JIM_ERR;
-        }
-        if (Jim_GetWide(interp, argv[3], &count) != JIM_OK)
-            return JIM_ERR;
-        objPtr = Jim_NewStringObj(interp, "", 0);
-        while (count--) {
-            Jim_AppendObj(interp, objPtr, argv[2]);
-        }
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_INDEX) {
-        int index_t, len;
-        const char *str;
-
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, "string index");
-            return JIM_ERR;
-        }
-        if (Jim_GetIndex(interp, argv[3], &index_t) != JIM_OK)
-            return JIM_ERR;
-        str = Jim_GetString(argv[2], &len);
-        if (index_t != INT_MIN && index_t != INT_MAX)
-            index_t = JimRelToAbsIndex(len, index_t);
-        if (index_t < 0 || index_t >= len) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            return JIM_OK;
-        } else {
-            Jim_SetResult(interp, Jim_NewStringObj(interp, str + index_t, 1));
-            return JIM_OK;
-        }
-    } else if (option == OPT_FIRST) {
-        int index_t = 0, l1, l2;
-        const char *s1, *s2;
-
-        if (argc != 4 && argc != 5) {
-            Jim_WrongNumArgs(interp, 2, argv, "subString string ?startIndex?");
-            return JIM_ERR;
-        }
-        s1 = Jim_GetString(argv[2], &l1);
-        s2 = Jim_GetString(argv[3], &l2);
-        if (argc == 5) {
-            if (Jim_GetIndex(interp, argv[4], &index_t) != JIM_OK)
-                return JIM_ERR;
-            index_t = JimRelToAbsIndex(l2, index_t);
-        }
-        Jim_SetResult(interp, Jim_NewIntObj(interp,
-                    JimStringFirst(s1, l1, s2, l2, index_t)));
-        return JIM_OK;
-    } else if (option == OPT_TOLOWER) {
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "string");
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp, JimStringToLower(interp, argv[2]));
-    } else if (option == OPT_TOUPPER) {
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "string");
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp, JimStringToUpper(interp, argv[2]));
-    }
-    return JIM_OK;
-}
-
-/* [time] */
-static int Jim_TimeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    long i, count = 1;
-    jim_wide start, elapsed;
-    char buf [256];
-    const char *fmt = "%" JIM_WIDE_MODIFIER " microseconds per iteration";
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "script ?count?");
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        if (Jim_GetLong(interp, argv[2], &count) != JIM_OK)
-            return JIM_ERR;
-    }
-    if (count < 0)
-        return JIM_OK;
-    i = count;
-    start = JimClock();
-    while (i-- > 0) {
-        int retval;
-
-        if ((retval = Jim_EvalObj(interp, argv[1])) != JIM_OK)
-            return retval;
-    }
-    elapsed = JimClock() - start;
-    sprintf(buf, fmt, elapsed/count);
-    Jim_SetResultString(interp, buf, -1);
-    return JIM_OK;
-}
-
-/* [exit] */
-static int Jim_ExitCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    long exitCode = 0;
-
-    if (argc > 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "?exitCode?");
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        if (Jim_GetLong(interp, argv[1], &exitCode) != JIM_OK)
-            return JIM_ERR;
-    }
-    interp->exitCode = exitCode;
-    return JIM_EXIT;
-}
-
-/* [catch] */
-static int Jim_CatchCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int exitCode = 0;
-
-    if (argc != 2 && argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "script ?varName?");
-        return JIM_ERR;
-    }
-    exitCode = Jim_EvalObj(interp, argv[1]);
-    if (argc == 3) {
-        if (Jim_SetVariable(interp, argv[2], Jim_GetResult(interp))
-                != JIM_OK)
-            return JIM_ERR;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, exitCode));
-    return JIM_OK;
-}
-
-/* [ref] */
-static int Jim_RefCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 3 && argc != 4) {
-        Jim_WrongNumArgs(interp, 1, argv, "string tag ?finalizer?");
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        Jim_SetResult(interp, Jim_NewReference(interp, argv[1], argv[2], NULL));
-    } else {
-        Jim_SetResult(interp, Jim_NewReference(interp, argv[1], argv[2],
-                    argv[3]));
-    }
-    return JIM_OK;
-}
-
-/* [getref] */
-static int Jim_GetrefCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Reference *refPtr;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "reference");
-        return JIM_ERR;
-    }
-    if ((refPtr = Jim_GetReference(interp, argv[1])) == NULL)
-        return JIM_ERR;
-    Jim_SetResult(interp, refPtr->objPtr);
-    return JIM_OK;
-}
-
-/* [setref] */
-static int Jim_SetrefCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Reference *refPtr;
-
-    if (argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "reference newValue");
-        return JIM_ERR;
-    }
-    if ((refPtr = Jim_GetReference(interp, argv[1])) == NULL)
-        return JIM_ERR;
-    Jim_IncrRefCount(argv[2]);
-    Jim_DecrRefCount(interp, refPtr->objPtr);
-    refPtr->objPtr = argv[2];
-    Jim_SetResult(interp, argv[2]);
-    return JIM_OK;
-}
-
-/* [collect] */
-static int Jim_CollectCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 1) {
-        Jim_WrongNumArgs(interp, 1, argv, "");
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, Jim_Collect(interp)));
-    return JIM_OK;
-}
-
-/* [finalize] reference ?newValue? */
-static int Jim_FinalizeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 2 && argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "reference ?finalizerProc?");
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        Jim_Obj *cmdNamePtr;
-
-        if (Jim_GetFinalizer(interp, argv[1], &cmdNamePtr) != JIM_OK)
-            return JIM_ERR;
-        if (cmdNamePtr != NULL) /* otherwise the null string is returned. */
-            Jim_SetResult(interp, cmdNamePtr);
-    } else {
-        if (Jim_SetFinalizer(interp, argv[1], argv[2]) != JIM_OK)
-            return JIM_ERR;
-        Jim_SetResult(interp, argv[2]);
-    }
-    return JIM_OK;
-}
-
-/* TODO */
-/* [info references] (list of all the references/finalizers) */
-
-/* [rename] */
-static int Jim_RenameCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *oldName, *newName;
-
-    if (argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "oldName newName");
-        return JIM_ERR;
-    }
-    oldName = Jim_GetString(argv[1], NULL);
-    newName = Jim_GetString(argv[2], NULL);
-    if (Jim_RenameCommand(interp, oldName, newName) != JIM_OK) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "can't rename \"", oldName, "\": ",
-            "command doesn't exist", NULL);
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [dict] */
-static int Jim_DictCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int option;
-    const char *options[] = {
-        "create", "get", "set", "unset", "exists", NULL
-    };
-    enum {
-        OPT_CREATE, OPT_GET, OPT_SET, OPT_UNSET, OPT_EXIST
-    };
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "option ?arguments ...?");
-        return JIM_ERR;
-    }
-
-    if (Jim_GetEnum(interp, argv[1], options, &option, "option",
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-
-    if (option == OPT_CREATE) {
-        Jim_Obj *objPtr;
-
-        if (argc % 2) {
-            Jim_WrongNumArgs(interp, 2, argv, "?key value ...?");
-            return JIM_ERR;
-        }
-        objPtr = Jim_NewDictObj(interp, argv + 2, argc-2);
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_GET) {
-        Jim_Obj *objPtr;
-
-        if (Jim_DictKeysVector(interp, argv[2], argv + 3, argc-3, &objPtr,
-                JIM_ERRMSG) != JIM_OK)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_SET) {
-        if (argc < 5) {
-            Jim_WrongNumArgs(interp, 2, argv, "varName key ?key ...? value");
-            return JIM_ERR;
-        }
-        return Jim_SetDictKeysVector(interp, argv[2], argv + 3, argc-4,
-                    argv[argc-1]);
-    } else if (option == OPT_UNSET) {
-        if (argc < 4) {
-            Jim_WrongNumArgs(interp, 2, argv, "varName key ?key ...?");
-            return JIM_ERR;
-        }
-        return Jim_SetDictKeysVector(interp, argv[2], argv + 3, argc-3,
-                    NULL);
-    } else if (option == OPT_EXIST) {
-        Jim_Obj *objPtr;
-        int exists;
-
-        if (Jim_DictKeysVector(interp, argv[2], argv + 3, argc-3, &objPtr,
-                JIM_ERRMSG) == JIM_OK)
-            exists = 1;
-        else
-            exists = 0;
-        Jim_SetResult(interp, Jim_NewIntObj(interp, exists));
-        return JIM_OK;
-    } else {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            "bad option \"", Jim_GetString(argv[1], NULL), "\":",
-            " must be create, get, set", NULL);
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [load] */
-static int Jim_LoadCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "libaryFile");
-        return JIM_ERR;
-    }
-    return Jim_LoadLibrary(interp, Jim_GetString(argv[1], NULL));
-}
-
-/* [subst] */
-static int Jim_SubstCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int i, flags = 0;
-    Jim_Obj *objPtr;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv,
-            "?-nobackslashes? ?-nocommands? ?-novariables? string");
-        return JIM_ERR;
-    }
-    i = argc-2;
-    while (i--) {
-        if (Jim_CompareStringImmediate(interp, argv[i + 1],
-                    "-nobackslashes"))
-            flags |= JIM_SUBST_NOESC;
-        else if (Jim_CompareStringImmediate(interp, argv[i + 1],
-                    "-novariables"))
-            flags |= JIM_SUBST_NOVAR;
-        else if (Jim_CompareStringImmediate(interp, argv[i + 1],
-                    "-nocommands"))
-            flags |= JIM_SUBST_NOCMD;
-        else {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "bad option \"", Jim_GetString(argv[i + 1], NULL),
-                "\": must be -nobackslashes, -nocommands, or "
-                "-novariables", NULL);
-            return JIM_ERR;
-        }
-    }
-    if (Jim_SubstObj(interp, argv[argc-1], &objPtr, flags) != JIM_OK)
-        return JIM_ERR;
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [info] */
-static int Jim_InfoCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int cmd, result = JIM_OK;
-    static const char *commands[] = {
-        "body", "commands", "exists", "globals", "level", "locals",
-        "vars", "version", "complete", "args", "hostname", NULL
-    };
-    enum {INFO_BODY, INFO_COMMANDS, INFO_EXISTS, INFO_GLOBALS, INFO_LEVEL,
-          INFO_LOCALS, INFO_VARS, INFO_VERSION, INFO_COMPLETE, INFO_ARGS, INFO_HOSTNAME};
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "command ?args ...?");
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], commands, &cmd, "command", JIM_ERRMSG)
-        != JIM_OK) {
-        return JIM_ERR;
-    }
-
-    if (cmd == INFO_COMMANDS) {
-        if (argc != 2 && argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "?pattern?");
-            return JIM_ERR;
-        }
-        if (argc == 3)
-            Jim_SetResult(interp,JimCommandsList(interp, argv[2]));
-        else
-            Jim_SetResult(interp, JimCommandsList(interp, NULL));
-    } else if (cmd == INFO_EXISTS) {
-        Jim_Obj *exists;
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "varName");
-            return JIM_ERR;
-        }
-        exists = Jim_GetVariable(interp, argv[2], 0);
-        Jim_SetResult(interp, Jim_NewIntObj(interp, exists != 0));
-    } else if (cmd == INFO_GLOBALS || cmd == INFO_LOCALS || cmd == INFO_VARS) {
-        int mode;
-        switch (cmd) {
-            case INFO_GLOBALS: mode = JIM_VARLIST_GLOBALS; break;
-            case INFO_LOCALS:  mode = JIM_VARLIST_LOCALS; break;
-            case INFO_VARS:    mode = JIM_VARLIST_VARS; break;
-            default: mode = 0; /* avoid warning */; break;
-        }
-        if (argc != 2 && argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "?pattern?");
-            return JIM_ERR;
-        }
-        if (argc == 3)
-            Jim_SetResult(interp,JimVariablesList(interp, argv[2], mode));
-        else
-            Jim_SetResult(interp, JimVariablesList(interp, NULL, mode));
-    } else if (cmd == INFO_LEVEL) {
-        Jim_Obj *objPtr;
-        switch (argc) {
-            case 2:
-                Jim_SetResult(interp,
-                              Jim_NewIntObj(interp, interp->numLevels));
-                break;
-            case 3:
-                if (JimInfoLevel(interp, argv[2], &objPtr) != JIM_OK)
-                    return JIM_ERR;
-                Jim_SetResult(interp, objPtr);
-                break;
-            default:
-                Jim_WrongNumArgs(interp, 2, argv, "?levelNum?");
-                return JIM_ERR;
-        }
-    } else if (cmd == INFO_BODY || cmd == INFO_ARGS) {
-        Jim_Cmd *cmdPtr;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "procname");
-            return JIM_ERR;
-        }
-        if ((cmdPtr = Jim_GetCommand(interp, argv[2], JIM_ERRMSG)) == NULL)
-            return JIM_ERR;
-        if (cmdPtr->cmdProc != NULL) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "command \"", Jim_GetString(argv[2], NULL),
-                "\" is not a procedure", NULL);
-            return JIM_ERR;
-        }
-        if (cmd == INFO_BODY)
-            Jim_SetResult(interp, cmdPtr->bodyObjPtr);
-        else
-            Jim_SetResult(interp, cmdPtr->argListObjPtr);
-    } else if (cmd == INFO_VERSION) {
-        char buf[(JIM_INTEGER_SPACE * 2) + 1];
-        sprintf(buf, "%d.%d",
-                JIM_VERSION / 100, JIM_VERSION % 100);
-        Jim_SetResultString(interp, buf, -1);
-    } else if (cmd == INFO_COMPLETE) {
-        const char *s;
-        int len;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, "script");
-            return JIM_ERR;
-        }
-        s = Jim_GetString(argv[2], &len);
-        Jim_SetResult(interp,
-                Jim_NewIntObj(interp, Jim_ScriptIsComplete(s, len, NULL)));
-    } else if (cmd == INFO_HOSTNAME) {
-        /* Redirect to os.hostname if it exists */
-        Jim_Obj *command = Jim_NewStringObj(interp, "os.gethostname", -1);
-        result = Jim_EvalObjVector(interp, 1, &command);
-    }
-    return result;
-}
-
-/* [split] */
-static int Jim_SplitCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *str, *splitChars, *noMatchStart;
-    int splitLen, strLen, i;
-    Jim_Obj *resObjPtr;
-
-    if (argc != 2 && argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "string ?splitChars?");
-        return JIM_ERR;
-    }
-    /* Init */
-    if (argc == 2) {
-        splitChars = " \n\t\r";
-        splitLen = 4;
-    } else {
-        splitChars = Jim_GetString(argv[2], &splitLen);
-    }
-    str = Jim_GetString(argv[1], &strLen);
-    if (!strLen) return JIM_OK;
-    noMatchStart = str;
-    resObjPtr = Jim_NewListObj(interp, NULL, 0);
-    /* Split */
-    if (splitLen) {
-        while (strLen) {
-            for (i = 0; i < splitLen; i++) {
-                if (*str == splitChars[i]) {
-                    Jim_Obj *objPtr;
-
-                    objPtr = Jim_NewStringObj(interp, noMatchStart,
-                            (str-noMatchStart));
-                    Jim_ListAppendElement(interp, resObjPtr, objPtr);
-                    noMatchStart = str + 1;
-                    break;
-                }
-            }
-            str ++;
-            strLen --;
-        }
-        Jim_ListAppendElement(interp, resObjPtr,
-                Jim_NewStringObj(interp, noMatchStart, (str-noMatchStart)));
-    } else {
-        /* This handles the special case of splitchars eq {}. This
-         * is trivial but we want to perform object sharing as Tcl does. */
-        Jim_Obj *objCache[256];
-        const unsigned char *u = (unsigned char*) str;
-        memset(objCache, 0, sizeof(objCache));
-        for (i = 0; i < strLen; i++) {
-            int c = u[i];
-
-            if (objCache[c] == NULL)
-                objCache[c] = Jim_NewStringObj(interp, (char*)u + i, 1);
-            Jim_ListAppendElement(interp, resObjPtr, objCache[c]);
-        }
-    }
-    Jim_SetResult(interp, resObjPtr);
-    return JIM_OK;
-}
-
-/* [join] */
-static int Jim_JoinCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *joinStr;
-    int joinStrLen, i, listLen;
-    Jim_Obj *resObjPtr;
-
-    if (argc != 2 && argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "list ?joinString?");
-        return JIM_ERR;
-    }
-    /* Init */
-    if (argc == 2) {
-        joinStr = " ";
-        joinStrLen = 1;
-    } else {
-        joinStr = Jim_GetString(argv[2], &joinStrLen);
-    }
-    Jim_ListLength(interp, argv[1], &listLen);
-    resObjPtr = Jim_NewStringObj(interp, NULL, 0);
-    /* Split */
-    for (i = 0; i < listLen; i++) {
-        Jim_Obj *objPtr=NULL;
-
-        Jim_ListIndex(interp, argv[1], i, &objPtr, JIM_NONE);
-        Jim_AppendObj(interp, resObjPtr, objPtr);
-        if (i + 1 != listLen) {
-            Jim_AppendString(interp, resObjPtr, joinStr, joinStrLen);
-        }
-    }
-    Jim_SetResult(interp, resObjPtr);
-    return JIM_OK;
-}
-
-/* [format] */
-static int Jim_FormatCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr;
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "formatString ?arg arg ...?");
-        return JIM_ERR;
-    }
-    objPtr = Jim_FormatString(interp, argv[1], argc-2, argv + 2);
-    if (objPtr == NULL)
-        return JIM_ERR;
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [scan] */
-static int Jim_ScanCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *listPtr, **outVec;
-    int outc, i, count = 0;
-
-    if (argc < 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "string formatString ?varName ...?");
-        return JIM_ERR;
-    }
-    if (argv[2]->typePtr != &scanFmtStringObjType)
-        SetScanFmtFromAny(interp, argv[2]);
-    if (FormatGetError(argv[2]) != 0) {
-        Jim_SetResultString(interp, FormatGetError(argv[2]), -1);
-        return JIM_ERR;
-    }
-    if (argc > 3) {
-        int maxPos = FormatGetMaxPos(argv[2]);
-        int arg_count = FormatGetCnvCount(argv[2]);
-        if (maxPos > argc-3) {
-            Jim_SetResultString(interp, "\"%n$\" argument index out of range", -1);
-            return JIM_ERR;
-        } else if (arg_count != 0 && arg_count < argc-3) {
-            Jim_SetResultString(interp, "variable is not assigned by any "
-                "conversion specifiers", -1);
-            return JIM_ERR;
-        } else if (arg_count > argc-3) {
-            Jim_SetResultString(interp, "different numbers of variable names and "
-                "field specifiers", -1);
-            return JIM_ERR;
-        }
-    }
-    listPtr = Jim_ScanString(interp, argv[1], argv[2], JIM_ERRMSG);
-    if (listPtr == 0)
-        return JIM_ERR;
-    if (argc > 3) {
-        int len = 0;
-        if (listPtr != 0 && listPtr != (Jim_Obj*)EOF)
-            Jim_ListLength(interp, listPtr, &len);
-        if (listPtr == (Jim_Obj*)EOF || len == 0) { // XXX
-            Jim_SetResult(interp, Jim_NewIntObj(interp, -1));
-            return JIM_OK;
-        }
-        JimListGetElements(interp, listPtr, &outc, &outVec);
-        for (i = 0; i < outc; ++i) {
-            if (Jim_Len
-
-/* [error] */
-static int Jim_ErrorCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "message");
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, argv[1]);
-    return JIM_ERR;
-}
-
-/* [lrange] */
-static int Jim_LrangeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr;
-
-    if (argc != 4) {
-        Jim_WrongNumArgs(interp, 1, argv, "list first last");
-        return JIM_ERR;
-    }
-    if ((objPtr = Jim_ListRange(interp, argv[1], argv[2], argv[3])) == NULL)
-        return JIM_ERR;
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [env] */
-static int Jim_EnvCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *key;
-    char *val;
-
-    if (argc == 1) {
-
-#ifdef NEED_ENVIRON_EXTERN
-        extern char **environ;
-#endif
-
-        int i;
-        Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
-
-        for (i = 0; environ[i]; i++) {
-            const char *equals = strchr(environ[i], '=');
-            if (equals) {
-                Jim_ListAppendElement(interp, listObjPtr, Jim_NewStringObj(interp, environ[i], equals - environ[i]));
-                Jim_ListAppendElement(interp, listObjPtr, Jim_NewStringObj(interp, equals + 1, -1));
-            }
-        }
-
-        Jim_SetResult(interp, listObjPtr);
-        return JIM_OK;
-    }
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "varName");
-        return JIM_ERR;
-    }
-    key = Jim_GetString(argv[1], NULL);
-    val = getenv(key);
-    if (val == NULL) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                "environment variable \"",
-                key, "\" does not exist", NULL);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, Jim_NewStringObj(interp, val, -1));
-    return JIM_OK;
-}
-
-/* [source] */
-static int Jim_SourceCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int retval;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "fileName");
-        return JIM_ERR;
-    }
-    retval = Jim_EvalFile(interp, Jim_GetString(argv[1], NULL));
-    if (retval == JIM_ERR) {
-        return JIM_ERR_ADDSTACK;
-    }
-    if (retval == JIM_RETURN)
-        return JIM_OK;
-    return retval;
-}
-
-/* [lreverse] */
-static int Jim_LreverseCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *revObjPtr, **ele;
-    int len;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "list");
-        return JIM_ERR;
-    }
-    JimListGetElements(interp, argv[1], &len, &ele);
-    len--;
-    revObjPtr = Jim_NewListObj(interp, NULL, 0);
-    while (len >= 0)
-        ListAppendElement(revObjPtr, ele[len--]);
-    Jim_SetResult(interp, revObjPtr);
-    return JIM_OK;
-}
-
-static int JimRangeLen(jim_wide start, jim_wide end, jim_wide step)
-{
-    jim_wide len;
-
-    if (step == 0) return -1;
-    if (start == end) return 0;
-    else if (step > 0 && start > end) return -1;
-    else if (step < 0 && end > start) return -1;
-    len = end-start;
-    if (len < 0) len = -len; /* abs(len) */
-    if (step < 0) step = -step; /* abs(step) */
-    len = 1 + ((len-1)/step);
-    /* We can truncate safely to INT_MAX, the range command
-     * will always return an error for a such long range
-     * because Tcl lists can't be so long. */
-    if (len > INT_MAX) len = INT_MAX;
-    return (int)((len < 0) ? -1 : len);
-}
-
-/* [range] */
-static int Jim_RangeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    jim_wide start = 0, end, step = 1;
-    int len, i;
-    Jim_Obj *objPtr;
-
-    if (argc < 2 || argc > 4) {
-        Jim_WrongNumArgs(interp, 1, argv, "?start? end ?step?");
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        if (Jim_GetWide(interp, argv[1], &end) != JIM_OK)
-            return JIM_ERR;
-    } else {
-        if (Jim_GetWide(interp, argv[1], &start) != JIM_OK ||
-            Jim_GetWide(interp, argv[2], &end) != JIM_OK)
-            return JIM_ERR;
-        if (argc == 4 && Jim_GetWide(interp, argv[3], &step) != JIM_OK)
-            return JIM_ERR;
-    }
-    if ((len = JimRangeLen(start, end, step)) == -1) {
-        Jim_SetResultString(interp, "Invalid (infinite?) range specified", -1);
-        return JIM_ERR;
-    }
-    objPtr = Jim_NewListObj(interp, NULL, 0);
-    for (i = 0; i < len; i++)
-        ListAppendElement(objPtr, Jim_NewIntObj(interp, start + i*step));
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [rand] */
-static int Jim_RandCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    jim_wide min = 0, max =0, len, maxMul;
-
-    if (argc < 1 || argc > 3) {
-        Jim_WrongNumArgs(interp, 1, argv, "?min? max");
-        return JIM_ERR;
-    }
-    if (argc == 1) {
-        max = JIM_WIDE_MAX;
-    } else if (argc == 2) {
-        if (Jim_GetWide(interp, argv[1], &max) != JIM_OK)
-            return JIM_ERR;
-    } else if (argc == 3) {
-        if (Jim_GetWide(interp, argv[1], &min) != JIM_OK ||
-            Jim_GetWide(interp, argv[2], &max) != JIM_OK)
-            return JIM_ERR;
-    }
-    len = max-min;
-    if (len < 0) {
-        Jim_SetResultString(interp, "Invalid arguments (max < min)", -1);
-        return JIM_ERR;
-    }
-    maxMul = JIM_WIDE_MAX - (len ? (JIM_WIDE_MAX%len) : 0);
-    while (1) {
-        jim_wide r;
-
-        JimRandomBytes(interp, &r, sizeof(jim_wide));
-        if (r < 0 || r >= maxMul) continue;
-        r = (len == 0) ? 0 : r%len;
-        Jim_SetResult(interp, Jim_NewIntObj(interp, min + r));
-        return JIM_OK;
-    }
-}
-
-/* [package] */
-static int Jim_PackageCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int option;
-    const char *options[] = {
-        "require", "provide", NULL
-    };
-    enum {OPT_REQUIRE, OPT_PROVIDE};
-
-    if (argc < 2) {
-        Jim_WrongNumArgs(interp, 1, argv, "option ?arguments ...?");
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], options, &option, "option",
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-
-    if (option == OPT_REQUIRE) {
-        int exact = 0;
-        const char *ver;
-
-        if (Jim_CompareStringImmediate(interp, argv[2], "-exact")) {
-            exact = 1;
-            argv++;
-            argc--;
-        }
-        if (argc != 3 && argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, "?-exact? package ?version?");
-            return JIM_ERR;
-        }
-        ver = Jim_PackageRequire(interp, Jim_GetString(argv[2], NULL),
-                argc == 4 ? Jim_GetString(argv[3], NULL) : "",
-                JIM_ERRMSG);
-        if (ver == NULL)
-            return JIM_ERR_ADDSTACK;
-        Jim_SetResultString(interp, ver, -1);
-    } else if (option == OPT_PROVIDE) {
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, "package version");
-            return JIM_ERR;
-        }
-        return Jim_PackageProvide(interp, Jim_GetString(argv[2], NULL),
-                    Jim_GetString(argv[3], NULL), JIM_ERRMSG);
-    }
-    return JIM_OK;
-}
-
-static struct {
-    const char *name;
-    Jim_CmdProc cmdProc;
-} Jim_CoreCommandsTable[] = {
-    {"set", Jim_SetCoreCommand},
-    {"unset", Jim_UnsetCoreCommand},
-    {"puts", Jim_PutsCoreCommand},
-    {"+", Jim_AddCoreCommand},
-    {"*", Jim_MulCoreCommand},
-    {"-", Jim_SubCoreCommand},
-    {"/", Jim_DivCoreCommand},
-    {"incr", Jim_IncrCoreCommand},
-    {"while", Jim_WhileCoreCommand},
-    {"for", Jim_ForCoreCommand},
-    {"foreach", Jim_ForeachCoreCommand},
-    {"lmap", Jim_LmapCoreCommand},
-    {"if", Jim_IfCoreCommand},
-    {"switch", Jim_SwitchCoreCommand},
-    {"list", Jim_ListCoreCommand},
-    {"lindex", Jim_LindexCoreCommand},
-    {"lset", Jim_LsetCoreCommand},
-    {"llength", Jim_LlengthCoreCommand},
-    {"lappend", Jim_LappendCoreCommand},
-    {"linsert", Jim_LinsertCoreCommand},
-    {"lsort", Jim_LsortCoreCommand},
-    {"append", Jim_AppendCoreCommand},
-    {"debug", Jim_DebugCoreCommand},
-    {"eval", Jim_EvalCoreCommand},
-    {"uplevel", Jim_UplevelCoreCommand},
-    {"expr", Jim_ExprCoreCommand},
-    {"break", Jim_BreakCoreCommand},
-    {"continue", Jim_ContinueCoreCommand},
-    {"proc", Jim_ProcCoreCommand},
-    {"concat", Jim_ConcatCoreCommand},
-    {"return", Jim_ReturnCoreCommand},
-    {"upvar", Jim_UpvarCoreCommand},
-    {"global", Jim_GlobalCoreCommand},
-    {"string", Jim_StringCoreCommand},
-    {"time", Jim_TimeCoreCommand},
-    {"exit", Jim_ExitCoreCommand},
-    {"catch", Jim_CatchCoreCommand},
-    {"ref", Jim_RefCoreCommand},
-    {"getref", Jim_GetrefCoreCommand},
-    {"setref", Jim_SetrefCoreCommand},
-    {"finalize", Jim_FinalizeCoreCommand},
-    {"collect", Jim_CollectCoreCommand},
-    {"rename", Jim_RenameCoreCommand},
-    {"dict", Jim_DictCoreCommand},
-    {"load", Jim_LoadCoreCommand},
-    {"subst", Jim_SubstCoreCommand},
-    {"info", Jim_InfoCoreCommand},
-    {"split", Jim_SplitCoreCommand},
-    {"join", Jim_JoinCoreCommand},
-    {"format", Jim_FormatCoreCommand},
-    {"scan", Jim_ScanCoreCommand},
-    {"error", Jim_ErrorCoreCommand},
-    {"lrange", Jim_LrangeCoreCommand},
-    {"env", Jim_EnvCoreCommand},
-    {"source", Jim_SourceCoreCommand},
-    {"lreverse", Jim_LreverseCoreCommand},
-    {"range", Jim_RangeCoreCommand},
-    {"rand", Jim_RandCoreCommand},
-    {"package", Jim_PackageCoreCommand},
-    {"tailcall", Jim_TailcallCoreCommand},
-    {NULL, NULL},
-};
-
-/* Some Jim core command is actually a procedure written in Jim itself. */
-static void Jim_RegisterCoreProcedures(Jim_Interp *interp)
-{
-    Jim_Eval(interp, (char*)
-"proc lambda {arglist args} {\n"
-"    set name [ref {} function lambdaFinalizer]\n"
-"    uplevel 1 [list proc $name $arglist {expand}$args]\n"
-"    return $name\n"
-"}\n"
-"proc lambdaFinalizer {name val} {\n"
-"    rename $name {}\n"
-"}\n"
-);
-}
-
-void Jim_RegisterCoreCommands(Jim_Interp *interp)
-{
-    int i = 0;
-
-    while (Jim_CoreCommandsTable[i].name != NULL) {
-        Jim_CreateCommand(interp,
-                Jim_CoreCommandsTable[i].name,
-                Jim_CoreCommandsTable[i].cmdProc,
-                NULL, NULL);
-        i++;
-    }
-    Jim_RegisterCoreProcedures(interp);
-}
-
-/* -----------------------------------------------------------------------------
- * Interactive prompt
- * ---------------------------------------------------------------------------*/
-void Jim_PrintErrorMessage(Jim_Interp *interp)
-{
-    int len, i;
-
-    if (*interp->errorFileName) {
-        Jim_fprintf(interp, interp->cookie_stderr, "Runtime error, file \"%s\", line %d:" JIM_NL "    ",
-                                    interp->errorFileName, interp->errorLine);
-    }
-    Jim_fprintf(interp,interp->cookie_stderr, "%s" JIM_NL,
-            Jim_GetString(interp->result, NULL));
-    Jim_ListLength(interp, interp->stackTrace, &len);
-    for (i = len-3; i >= 0; i-= 3) {
-        Jim_Obj *objPtr=NULL;
-        const char *proc, *file, *line;
-
-        Jim_ListIndex(interp, interp->stackTrace, i, &objPtr, JIM_NONE);
-        proc = Jim_GetString(objPtr, NULL);
-        Jim_ListIndex(interp, interp->stackTrace, i + 1, &objPtr,
-                JIM_NONE);
-        file = Jim_GetString(objPtr, NULL);
-        Jim_ListIndex(interp, interp->stackTrace, i + 2, &objPtr,
-                JIM_NONE);
-        line = Jim_GetString(objPtr, NULL);
-        if (*proc) {
-            Jim_fprintf(interp, interp->cookie_stderr,
-                    "in procedure '%s' ", proc);
-        }
-        if (*file) {
-            Jim_fprintf(interp, interp->cookie_stderr,
-                    "called at file \"%s\", line %s",
-                    file, line);
-        }
-        if (*file || *proc) {
-            Jim_fprintf(interp, interp->cookie_stderr, JIM_NL);
-        }
-    }
-}
-
-int Jim_InteractivePrompt(Jim_Interp *interp)
-{
-    int retcode = JIM_OK;
-    Jim_Obj *scriptObjPtr;
-
-    Jim_fprintf(interp,interp->cookie_stdout, "Welcome to Jim version %d.%d, "
-           "Copyright (c) 2005-8 Salvatore Sanfilippo" JIM_NL,
-           JIM_VERSION / 100, JIM_VERSION % 100);
-     Jim_SetVariableStrWithStr(interp, "jim_interactive", "1");
-    while (1) {
-        char buf[1024];
-        const char *result;
-        const char *retcodestr[] = {
-            "ok", "error", "return", "break", "continue", "eval", "exit"
-        };
-        int reslen;
-
-        if (retcode != 0) {
-            if (retcode >= 2 && retcode <= 6)
-                Jim_fprintf(interp,interp->cookie_stdout, "[%s] . ", retcodestr[retcode]);
-            else
-                Jim_fprintf(interp,interp->cookie_stdout, "[%d] . ", retcode);
-        } else
-            Jim_fprintf(interp, interp->cookie_stdout, ". ");
-        Jim_fflush(interp, interp->cookie_stdout);
-        scriptObjPtr = Jim_NewStringObj(interp, "", 0);
-        Jim_IncrRefCount(scriptObjPtr);
-        while (1) {
-            const char *str;
-            char state;
-            int len;
-
-            if (Jim_fgets(interp, buf, 1024, interp->cookie_stdin) == NULL) {
-                Jim_DecrRefCount(interp, scriptObjPtr);
-                goto out;
-            }
-            Jim_AppendString(interp, scriptObjPtr, buf, -1);
-            str = Jim_GetString(scriptObjPtr, &len);
-            if (Jim_ScriptIsComplete(str, len, &state))
-                break;
-            Jim_fprintf(interp, interp->cookie_stdout, "%c> ", state);
-            Jim_fflush(interp, interp->cookie_stdout);
-        }
-        retcode = Jim_EvalObj(interp, scriptObjPtr);
-        Jim_DecrRefCount(interp, scriptObjPtr);
-        result = Jim_GetString(Jim_GetResult(interp), &reslen);
-        if (retcode == JIM_ERR) {
-            Jim_PrintErrorMessage(interp);
-        } else if (retcode == JIM_EXIT) {
-            exit(Jim_GetExitCode(interp));
-        } else {
-            if (reslen) {
-				Jim_fwrite(interp, result, 1, reslen, interp->cookie_stdout);
-				Jim_fprintf(interp,interp->cookie_stdout, JIM_NL);
-            }
-        }
-    }
-out:
-    return 0;
-}
-
-/* -----------------------------------------------------------------------------
- * Jim's idea of STDIO..
- * ---------------------------------------------------------------------------*/
-
-int Jim_fprintf(Jim_Interp *interp, void *cookie, const char *fmt, ...)
-{
-	int r;
-
-	va_list ap;
-	va_start(ap,fmt);
-	r = Jim_vfprintf(interp, cookie, fmt,ap);
-	va_end(ap);
-	return r;
-}
-
-int Jim_vfprintf(Jim_Interp *interp, void *cookie, const char *fmt, va_list ap)
-{
-	if ((interp == NULL) || (interp->cb_vfprintf == NULL)) {
-		errno = ENOTSUP;
-		return -1;
-	}
-	return (*(interp->cb_vfprintf))(cookie, fmt, ap);
-}
-
-size_t Jim_fwrite(Jim_Interp *interp, const void *ptr, size_t size, size_t n, void *cookie)
-{
-	if ((interp == NULL) || (interp->cb_fwrite == NULL)) {
-		errno = ENOTSUP;
-		return 0;
-	}
-	return (*(interp->cb_fwrite))(ptr, size, n, cookie);
-}
-
-size_t Jim_fread(Jim_Interp *interp, void *ptr, size_t size, size_t n, void *cookie)
-{
-	if ((interp == NULL) || (interp->cb_fread == NULL)) {
-		errno = ENOTSUP;
-		return 0;
-	}
-	return (*(interp->cb_fread))(ptr, size, n, cookie);
-}
-
-int Jim_fflush(Jim_Interp *interp, void *cookie)
-{
-	if ((interp == NULL) || (interp->cb_fflush == NULL)) {
-		/* pretend all is well */
-		return 0;
-	}
-	return (*(interp->cb_fflush))(cookie);
-}
-
-char* Jim_fgets(Jim_Interp *interp, char *s, int size, void *cookie)
-{
-	if ((interp == NULL) || (interp->cb_fgets == NULL)) {
-		errno = ENOTSUP;
-		return NULL;
-	}
-	return (*(interp->cb_fgets))(s, size, cookie);
-}
-Jim_Nvp *
-Jim_Nvp_name2value_simple(const Jim_Nvp *p, const char *name)
-{
-	while (p->name) {
-		if (0 == strcmp(name, p->name)) {
-			break;
-		}
-		p++;
-	}
-	return ((Jim_Nvp *)(p));
-}
-
-Jim_Nvp *
-Jim_Nvp_name2value_nocase_simple(const Jim_Nvp *p, const char *name)
-{
-	while (p->name) {
-		if (0 == strcasecmp(name, p->name)) {
-			break;
-		}
-		p++;
-	}
-	return ((Jim_Nvp *)(p));
-}
-
-int
-Jim_Nvp_name2value_obj(Jim_Interp *interp,
-						const Jim_Nvp *p,
-						Jim_Obj *o,
-						Jim_Nvp **result)
-{
-	return Jim_Nvp_name2value(interp, p, Jim_GetString(o, NULL), result);
-}
-
-
-int
-Jim_Nvp_name2value(Jim_Interp *interp,
-					const Jim_Nvp *_p,
-					const char *name,
-					Jim_Nvp **result)
-{
-	const Jim_Nvp *p;
-
-	p = Jim_Nvp_name2value_simple(_p, name);
-
-	/* result */
-	if (result) {
-		*result = (Jim_Nvp *)(p);
-	}
-
-	/* found? */
-	if (p->name) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-int
-Jim_Nvp_name2value_obj_nocase(Jim_Interp *interp, const Jim_Nvp *p, Jim_Obj *o, Jim_Nvp **puthere)
-{
-	return Jim_Nvp_name2value_nocase(interp, p, Jim_GetString(o, NULL), puthere);
-}
-
-int
-Jim_Nvp_name2value_nocase(Jim_Interp *interp, const Jim_Nvp *_p, const char *name, Jim_Nvp **puthere)
-{
-	const Jim_Nvp *p;
-
-	p = Jim_Nvp_name2value_nocase_simple(_p, name);
-
-	if (puthere) {
-		*puthere = (Jim_Nvp *)(p);
-	}
-	/* found */
-	if (p->name) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-
-int
-Jim_Nvp_value2name_obj(Jim_Interp *interp, const Jim_Nvp *p, Jim_Obj *o, Jim_Nvp **result)
-{
-	int e;;
-	jim_wide w;
-
-	e = Jim_GetWide(interp, o, &w);
-	if (e != JIM_OK) {
-		return e;
-	}
-
-	return Jim_Nvp_value2name(interp, p, w, result);
-}
-
-Jim_Nvp *
-Jim_Nvp_value2name_simple(const Jim_Nvp *p, int value)
-{
-	while (p->name) {
-		if (value == p->value) {
-			break;
-		}
-		p++;
-	}
-	return ((Jim_Nvp *)(p));
-}
-
-
-int
-Jim_Nvp_value2name(Jim_Interp *interp, const Jim_Nvp *_p, int value, Jim_Nvp **result)
-{
-	const Jim_Nvp *p;
-
-	p = Jim_Nvp_value2name_simple(_p, value);
-
-	if (result) {
-		*result = (Jim_Nvp *)(p);
-	}
-
-	if (p->name) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-
-int
-Jim_GetOpt_Setup(Jim_GetOptInfo *p, Jim_Interp *interp, int argc, Jim_Obj * const *  argv)
-{
-	memset(p, 0, sizeof(*p));
-	p->interp = interp;
-	p->argc   = argc;
-	p->argv   = argv;
-
-	return JIM_OK;
-}
-
-void
-Jim_GetOpt_Debug(Jim_GetOptInfo *p)
-{
-	int x;
-
-	Jim_fprintf(p->interp, p->interp->cookie_stderr, "---args---\n");
-	for (x = 0 ; x < p->argc ; x++) {
-		Jim_fprintf(p->interp, p->interp->cookie_stderr,
-					 "%2d) %s\n",
-					 x,
-					 Jim_GetString(p->argv[x], NULL));
-	}
-	Jim_fprintf(p->interp, p->interp->cookie_stderr, "-------\n");
-}
-
-
-int
-Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere)
-{
-	Jim_Obj *o;
-
-	o = NULL; // failure
-	if (goi->argc) {
-		// success
-		o = goi->argv[0];
-		goi->argc -= 1;
-		goi->argv += 1;
-	}
-	if (puthere) {
-		*puthere = o;
-	}
-	if (o != NULL) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-int
-Jim_GetOpt_String(Jim_GetOptInfo *goi, char **puthere, int *len)
-{
-	int r;
-	Jim_Obj *o;
-	const char *cp;
-
-
-	r = Jim_GetOpt_Obj(goi, &o);
-	if (r == JIM_OK) {
-		cp = Jim_GetString(o, len);
-		if (puthere) {
-			/* remove const */
-			*puthere = (char *)(cp);
-		}
-	}
-	return r;
-}
-
-int
-Jim_GetOpt_Double(Jim_GetOptInfo *goi, double *puthere)
-{
-	int r;
-	Jim_Obj *o;
-	double _safe;
-
-	if (puthere == NULL) {
-		puthere = &_safe;
-	}
-
-	r = Jim_GetOpt_Obj(goi, &o);
-	if (r == JIM_OK) {
-		r = Jim_GetDouble(goi->interp, o, puthere);
-		if (r != JIM_OK) {
-			Jim_SetResult_sprintf(goi->interp,
-								   "not a number: %s",
-								   Jim_GetString(o, NULL));
-		}
-	}
-	return r;
-}
-
-int
-Jim_GetOpt_Wide(Jim_GetOptInfo *goi, jim_wide *puthere)
-{
-	int r;
-	Jim_Obj *o;
-	jim_wide _safe;
-
-	if (puthere == NULL) {
-		puthere = &_safe;
-	}
-
-	r = Jim_GetOpt_Obj(goi, &o);
-	if (r == JIM_OK) {
-		r = Jim_GetWide(goi->interp, o, puthere);
-	}
-	return r;
-}
-
-int Jim_GetOpt_Nvp(Jim_GetOptInfo *goi,
-					const Jim_Nvp *nvp,
-					Jim_Nvp **puthere)
-{
-	Jim_Nvp *_safe;
-	Jim_Obj *o;
-	int e;
-
-	if (puthere == NULL) {
-		puthere = &_safe;
-	}
-
-	e = Jim_GetOpt_Obj(goi, &o);
-	if (e == JIM_OK) {
-		e = Jim_Nvp_name2value_obj(goi->interp,
-									nvp,
-									o,
-									puthere);
-	}
-
-	return e;
-}
-
-void
-Jim_GetOpt_NvpUnknown(Jim_GetOptInfo *goi,
-					   const Jim_Nvp *nvptable,
-					   int hadprefix)
-{
-	if (hadprefix) {
-		Jim_SetResult_NvpUnknown(goi->interp,
-								  goi->argv[-2],
-								  goi->argv[-1],
-								  nvptable);
-	} else {
-		Jim_SetResult_NvpUnknown(goi->interp,
-								  NULL,
-								  goi->argv[-1],
-								  nvptable);
-	}
-}
-
-
-int
-Jim_GetOpt_Enum(Jim_GetOptInfo *goi,
-				 const char * const *  lookup,
-				 int *puthere)
-{
-	int _safe;
-	Jim_Obj *o;
-	int e;
-
-	if (puthere == NULL) {
-		puthere = &_safe;
-	}
-	e = Jim_GetOpt_Obj(goi, &o);
-	if (e == JIM_OK) {
-		e = Jim_GetEnum(goi->interp,
-						 o,
-						 lookup,
-						 puthere,
-						 "option",
-						 JIM_ERRMSG);
-	}
-	return e;
-}
-
-
-
-int
-Jim_SetResult_sprintf(Jim_Interp *interp, const char *fmt,...)
-{
-	va_list ap;
-	char *buf;
-
-	va_start(ap,fmt);
-	buf = jim_vasprintf(fmt, ap);
-	va_end(ap);
-	if (buf) {
-		Jim_SetResultString(interp, buf, -1);
-		jim_vasprintf_done(buf);
-	}
-	return JIM_OK;
-}
-
-
-void
-Jim_SetResult_NvpUnknown(Jim_Interp *interp,
-						  Jim_Obj *param_name,
-						  Jim_Obj *param_value,
-						  const Jim_Nvp *nvp)
-{
-	if (param_name) {
-		Jim_SetResult_sprintf(interp,
-							   "%s: Unknown: %s, try one of: ",
-							   Jim_GetString(param_name, NULL),
-							   Jim_GetString(param_value, NULL));
-	} else {
-		Jim_SetResult_sprintf(interp,
-							   "Unknown param: %s, try one of: ",
-							   Jim_GetString(param_value, NULL));
-	}
-	while (nvp->name) {
-		const char *a;
-		const char *b;
-
-		if ((nvp + 1)->name) {
-			a = nvp->name;
-			b = ", ";
-		} else {
-			a = "or ";
-			b = nvp->name;
-		}
-		Jim_AppendStrings(interp,
-						   Jim_GetResult(interp),
-						   a, b, NULL);
-		nvp++;
-	}
-}
-
-
-static Jim_Obj *debug_string_obj;
-
-const char *
-Jim_Debug_ArgvString(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	int x;
-
-	if (debug_string_obj) {
-		Jim_FreeObj(interp, debug_string_obj);
-	}
-
-	debug_string_obj = Jim_NewEmptyStringObj(interp);
-	for (x = 0 ; x < argc ; x++) {
-		Jim_AppendStrings(interp,
-						   debug_string_obj,
-						   Jim_GetString(argv[x], NULL),
-						   " ",
-						   NULL);
-	}
-
-	return Jim_GetString(debug_string_obj, NULL);
-}

-----------------------------------------------------------------------

Summary of changes:
 src/helper/#jim.c# |12823 ----------------------------------------------------
 1 files changed, 0 insertions(+), 12823 deletions(-)
 delete mode 100644 src/helper/#jim.c#


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 16 00:09:29 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 15 Jun 2010 22:09:29 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-332-g72d227c
Message-ID: <E1OOeK3-0008Ha-8i@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  72d227cd5e32a6b141026e31ca4702cd69c79e62 (commit)
       via  42c84c59b1a733c27e164920cca58716cd7e8740 (commit)
       via  f9acaa894fbb15ec93463bc4f5eaceb23e0ba3c1 (commit)
      from  f1ce4fe288dc3a2682b8335177a2800980316ce3 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 72d227cd5e32a6b141026e31ca4702cd69c79e62
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 00:08:58 2010 +0200

    tms470: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
index 343c43e..2f02e5d 100644
--- a/src/flash/nor/tms470.c
+++ b/src/flash/nor/tms470.c
@@ -1215,7 +1215,7 @@ static int tms470_protect_check(struct flash_bank *bank)
 
 /* ---------------------------------------------------------------------- */
 
-static int tms470_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_tms470_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	int used = 0;
 	struct tms470_flash_bank *tms470_info = bank->driver_priv;
@@ -1275,5 +1275,5 @@ struct flash_driver tms470_flash = {
 	.auto_probe = tms470_auto_probe,
 	.erase_check = tms470_erase_check,
 	.protect_check = tms470_protect_check,
-	.info = tms470_info,
+	.info = get_tms470_info,
 };

commit 42c84c59b1a733c27e164920cca58716cd7e8740
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 00:07:59 2010 +0200

    str9xpec: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 073dfe1..f8b705e 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -665,7 +665,7 @@ static int str9xpec_write(struct flash_bank *bank, uint8_t *buffer,
 	if (bytes_remaining)
 	{
 		uint8_t last_dword[8] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-		int i = 0;
+		i = 0;
 
 		while (bytes_remaining > 0)
 		{
@@ -762,7 +762,7 @@ static int str9xpec_erase_check(struct flash_bank *bank)
 	return str9xpec_blank_check(bank, 0, bank->num_sectors - 1);
 }
 
-static int str9xpec_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_str9xpec_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	snprintf(buf, buf_size, "str9xpec flash driver info");
 	return ERROR_OK;
@@ -1252,5 +1252,5 @@ struct flash_driver str9xpec_flash = {
 	.auto_probe = str9xpec_probe,
 	.erase_check = str9xpec_erase_check,
 	.protect_check = str9xpec_protect_check,
-	.info = str9xpec_info,
+	.info = get_str9xpec_info,
 };

commit f9acaa894fbb15ec93463bc4f5eaceb23e0ba3c1
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 00:05:58 2010 +0200

    str9x: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index e8e942e..103af16 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -564,7 +564,7 @@ static int str9x_write(struct flash_bank *bank,
 	if (bytes_remaining)
 	{
 		uint8_t last_halfword[2] = {0xff, 0xff};
-		int i = 0;
+		i = 0;
 
 		while (bytes_remaining > 0)
 		{
@@ -621,7 +621,7 @@ COMMAND_HANDLER(str9x_handle_part_id_command)
 }
 #endif
 
-static int str9x_info(struct flash_bank *bank, char *buf, int buf_size)
+static int get_str9x_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	snprintf(buf, buf_size, "str9x flash driver info");
 	return ERROR_OK;
@@ -706,5 +706,5 @@ struct flash_driver str9x_flash = {
 	.auto_probe = str9x_probe,
 	.erase_check = default_flash_blank_check,
 	.protect_check = str9x_protect_check,
-	.info = str9x_info,
+	.info = get_str9x_info,
 };

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str9x.c    |    6 +++---
 src/flash/nor/str9xpec.c |    6 +++---
 src/flash/nor/tms470.c   |    4 ++--
 3 files changed, 8 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 16 07:43:01 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 16 Jun 2010 05:43:01 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-335-gf4958d6
Message-ID: <E1OOlPC-0003H7-EA@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f4958d61ef4188ed02629968d21c3a4de3a89121 (commit)
       via  94f373b404b93a1e1b6c693061f2ed504e4d36aa (commit)
       via  6de2b2d14b0b80f392d0faa05db915141cbd40cf (commit)
      from  72d227cd5e32a6b141026e31ca4702cd69c79e62 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f4958d61ef4188ed02629968d21c3a4de3a89121
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 07:42:41 2010 +0200

    mflash: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index d307858..90e9888 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -209,7 +209,7 @@ static int mg_init_gpio (void)
 	return ret;
 }
 
-static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time)
+static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time_var)
 {
 	uint8_t status, error;
 	struct target *target = mflash_bank->target;
@@ -220,7 +220,7 @@ static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time)
 	struct duration bench;
 	duration_start(&bench);
 
-	while (time) {
+	while (time_var) {
 
 		ret = target_read_u8(target, mg_task_reg + MG_REG_STATUS, &status);
 		if (ret != ERROR_OK)
@@ -280,7 +280,7 @@ static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time)
 		else
 			LOG_ERROR("mflash: duration measurement failed: %d", ret);
 
-		if (t > time)
+		if (t > time_var)
 			break;
 	}
 

commit 94f373b404b93a1e1b6c693061f2ed504e4d36aa
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 07:41:43 2010 +0200

    arm_io: -Wshadow warning fix
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nand/arm_io.c b/src/flash/nand/arm_io.c
index 7c7148e..7a6ceb3 100644
--- a/src/flash/nand/arm_io.c
+++ b/src/flash/nand/arm_io.c
@@ -100,7 +100,7 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 	struct arm		*armv4_5 = target->arch_info;
 	struct reg_param	reg_params[3];
 	uint32_t		target_buf;
-	uint32_t		exit = 0;
+	uint32_t		exit_var = 0;
 	int			retval;
 
 	/* Inputs:
@@ -153,11 +153,11 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 
 	/* armv4 must exit using a hardware breakpoint */
 	if (armv4_5->is_armv4)
-		exit = nand->copy_area->address + sizeof(code) - 4;
+		exit_var = nand->copy_area->address + sizeof(code) - 4;
 
 	/* use alg to write data from work area to NAND chip */
 	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
-			nand->copy_area->address, exit, 1000, &algo);
+			nand->copy_area->address, exit_var, 1000, &algo);
 	if (retval != ERROR_OK)
 		LOG_ERROR("error executing hosted NAND write");
 
@@ -184,7 +184,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 	struct arm *armv4_5 = target->arch_info;
 	struct reg_param reg_params[3];
 	uint32_t target_buf;
-	uint32_t exit = 0;
+	uint32_t exit_var = 0;
 	int retval;
 
 	/* Inputs:
@@ -229,11 +229,11 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 
 	/* armv4 must exit using a hardware breakpoint */
 	if (armv4_5->is_armv4)
-		exit = nand->copy_area->address + sizeof(code) - 4;
+		exit_var = nand->copy_area->address + sizeof(code) - 4;
 
 	/* use alg to write data from NAND chip to work area */
 	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
-			nand->copy_area->address, exit, 1000, &algo);
+			nand->copy_area->address, exit_var, 1000, &algo);
 	if (retval != ERROR_OK)
 		LOG_ERROR("error executing hosted NAND read");
 

commit 6de2b2d14b0b80f392d0faa05db915141cbd40cf
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 07:39:46 2010 +0200

    nand: when verify failed, it didn't return an error
    
    when the verify failed, it didn't return an error,
    which breaks e.g. tcl scripts that rely on this for
    exceptions to work.
    
    Found by -Wshadow
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 1272bf6..592277e 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -336,13 +336,14 @@ COMMAND_HANDLER(handle_nand_verify_command)
 
 	while (file.size > 0)
 	{
-		int retval = nand_read_page(nand, dev.address / dev.page_size,
+		retval = nand_read_page(nand, dev.address / dev.page_size,
 				dev.page, dev.page_size, dev.oob, dev.oob_size);
 		if (ERROR_OK != retval)
 		{
 			command_print(CMD_CTX, "reading NAND flash page failed");
 			nand_fileio_cleanup(&dev);
-			return nand_fileio_cleanup(&file);
+			nand_fileio_cleanup(&file);
+			return retval;
 		}
 
 		int bytes_read = nand_fileio_read(nand, &file);
@@ -350,7 +351,8 @@ COMMAND_HANDLER(handle_nand_verify_command)
 		{
 			command_print(CMD_CTX, "error while reading file");
 			nand_fileio_cleanup(&dev);
-			return nand_fileio_cleanup(&file);
+			nand_fileio_cleanup(&file);
+			return ERROR_FAIL;
 		}
 
 		if ((dev.page && memcmp(dev.page, file.page, dev.page_size)) ||
@@ -359,7 +361,8 @@ COMMAND_HANDLER(handle_nand_verify_command)
 			command_print(CMD_CTX, "NAND flash contents differ "
 						"at 0x%8.8" PRIx32, dev.address);
 			nand_fileio_cleanup(&dev);
-			return nand_fileio_cleanup(&file);
+			nand_fileio_cleanup(&file);
+			return ERROR_FAIL;
 		}
 
 		file.size -= bytes_read;
@@ -389,12 +392,13 @@ COMMAND_HANDLER(handle_nand_dump_command)
 	while (s.size > 0)
 	{
 		size_t size_written;
-		int retval = nand_read_page(nand, s.address / nand->page_size,
+		retval = nand_read_page(nand, s.address / nand->page_size,
 				s.page, s.page_size, s.oob, s.oob_size);
 		if (ERROR_OK != retval)
 		{
 			command_print(CMD_CTX, "reading NAND flash page failed");
-			return nand_fileio_cleanup(&s);
+			nand_fileio_cleanup(&s);
+			return retval;
 		}
 
 		if (NULL != s.page)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/mflash.c      |    6 +++---
 src/flash/nand/arm_io.c |   12 ++++++------
 src/flash/nand/tcl.c    |   16 ++++++++++------
 3 files changed, 19 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 16 09:02:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 16 Jun 2010 07:02:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-340-g814c2a8
Message-ID: <E1OOmdw-0001PA-2e@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  814c2a8f9a41a6445f131ee35474dced4bbed210 (commit)
       via  818120d4092be0d0a7cae50140dc339581cae7fc (commit)
       via  5104d56e5c37defaf2f6c5c8607bac45b8b49b32 (commit)
       via  cd9c61cc068635fa707981decfea600ee7e94201 (commit)
       via  9bbbbdc0bd244b09f846b1acdf28327da2a166d8 (commit)
      from  f4958d61ef4188ed02629968d21c3a4de3a89121 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 814c2a8f9a41a6445f131ee35474dced4bbed210
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 08:33:32 2010 +0200

    build: enable -Wshadow by default
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/configure.in b/configure.in
index d93b21a..7f31e1d 100644
--- a/configure.in
+++ b/configure.in
@@ -1090,7 +1090,7 @@ fi
 AC_DEFINE([_GNU_SOURCE],[1],[Use GNU C library extensions (e.g. stdndup).])
 
 # set default gcc warnings
-GCC_WARNINGS="-Wall -Wstrict-prototypes -Wformat-security"
+GCC_WARNINGS="-Wall -Wstrict-prototypes -Wformat-security -Wshadow"
 if test "${gcc_wextra}" = yes; then
   GCC_WARNINGS="${GCC_WARNINGS} -Wextra -Wno-unused-parameter"
   GCC_WARNINGS="${GCC_WARNINGS} -Wbad-function-cast"

commit 818120d4092be0d0a7cae50140dc339581cae7fc
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 08:27:50 2010 +0200

    gdb: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 8ed9e74..a1ff7c8 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2245,7 +2245,6 @@ static int gdb_input_inner(struct connection *connection)
 				case 'c':
 				case 's':
 					{
-						struct gdb_connection *gdb_con = connection->priv;
 						log_add_callback(gdb_log_callback, connection);
 
 						if (gdb_con->mem_write_error)

commit 5104d56e5c37defaf2f6c5c8607bac45b8b49b32
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 08:24:51 2010 +0200

    gdb: clean up error handling in step/continue
    
    if step/continue fails, then the error should be
    reported to the calling fn.
    
    The calling fn decides if the connection has to be
    aborted or if packet processing can continue.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 029bdf8..8ed9e74 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2151,7 +2151,17 @@ static int gdb_input_inner(struct connection *connection)
 	struct gdb_connection *gdb_con = connection->priv;
 	static int extended_protocol = 0;
 
-	/* drain input buffer */
+	/* drain input buffer. If one of the packets fail, then an error
+	 * packet is replied, if applicable.
+	 *
+	 * This loop will terminate and the error code is returned.
+	 *
+	 * The calling fn will check if this error is something that
+	 * can be recovered from, or if the connection must be closed.
+	 *
+	 * If the error is recoverable, this fn is called again to
+	 * drain the rest of the buffer.
+	 */
 	do
 	{
 		packet_size = GDB_BUFFER_SIZE-1;
@@ -2235,8 +2245,6 @@ static int gdb_input_inner(struct connection *connection)
 				case 'c':
 				case 's':
 					{
-						int retval = ERROR_OK;
-
 						struct gdb_connection *gdb_con = connection->priv;
 						log_add_callback(gdb_log_callback, connection);
 
@@ -2271,7 +2279,7 @@ static int gdb_input_inner(struct connection *connection)
 						}
 						gdb_con->sync = false;
 
-						if ((retval!=ERROR_OK) || (!already_running && nostep))
+						if (!already_running && nostep)
 						{
 							/* Either the target isn't in the halted state, then we can't
 							 * step/continue. This might be early setup, etc.
@@ -2294,7 +2302,9 @@ static int gdb_input_inner(struct connection *connection)
 
 							if (!already_running)
 							{
-								int retval = gdb_step_continue_packet(connection, target, packet, packet_size);
+								/* Here we don't want packet processing to stop even if this fails,
+								 * so we use a local variable instead of retval. */
+								retval = gdb_step_continue_packet(connection, target, packet, packet_size);
 								if (retval != ERROR_OK)
 								{
 									/* we'll never receive a halted condition... issue a false one.. */

commit cd9c61cc068635fa707981decfea600ee7e94201
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 08:19:25 2010 +0200

    xsvf: -Wshadow warning fixes
    
    I think this fixed an error message where the error
    message would show the *previous* uc code rather than
    the current unsupported uc code.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index dff1a1e..51d0e7b 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -269,7 +269,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 		 */
 		if (collecting_path) {
 			tap_state_t	mystate;
-			uint8_t		uc;
 
 			switch (opcode) {
 			case XCOMMENT:
@@ -565,7 +564,6 @@ COMMAND_HANDLER(handle_xsvf_command)
 		case XSTATE:
 			{
 				tap_state_t	mystate;
-				uint8_t			uc;
 
 				if (read(xsvf_fd, &uc, 1) < 0)
 				{

commit 9bbbbdc0bd244b09f846b1acdf28327da2a166d8
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 16 08:17:27 2010 +0200

    svf: -Wshadow warning fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/svf/svf.c b/src/svf/svf.c
index 6e951e2..62e2324 100644
--- a/src/svf/svf.c
+++ b/src/svf/svf.c
@@ -272,7 +272,7 @@ static unsigned svf_get_mask_u32(int bitlen)
 int svf_add_statemove(tap_state_t state_to)
 {
 	tap_state_t state_from = cmd_queue_cur_state;
-	uint8_t index;
+	unsigned index_var;
 
 	/* when resetting, be paranoid and ignore current state */
 	if (state_to == TAP_RESET) {
@@ -280,18 +280,18 @@ int svf_add_statemove(tap_state_t state_to)
 		return ERROR_OK;
 	}
 
-	for (index = 0; index < ARRAY_SIZE(svf_statemoves); index++)
+	for (index_var = 0; index_var < ARRAY_SIZE(svf_statemoves); index_var++)
 	{
-		if ((svf_statemoves[index].from == state_from)
-			&& (svf_statemoves[index].to == state_to))
+		if ((svf_statemoves[index_var].from == state_from)
+			&& (svf_statemoves[index_var].to == state_to))
 		{
 			/* recorded path includes current state ... avoid extra TCKs! */
-			if (svf_statemoves[index].num_of_moves > 1)
-				jtag_add_pathmove(svf_statemoves[index].num_of_moves - 1,
-						svf_statemoves[index].paths + 1);
+			if (svf_statemoves[index_var].num_of_moves > 1)
+				jtag_add_pathmove(svf_statemoves[index_var].num_of_moves - 1,
+						svf_statemoves[index_var].paths + 1);
 			else
-				jtag_add_pathmove(svf_statemoves[index].num_of_moves,
-						svf_statemoves[index].paths);
+				jtag_add_pathmove(svf_statemoves[index_var].num_of_moves,
+						svf_statemoves[index_var].paths);
 			return ERROR_OK;
 		}
 	}
@@ -723,22 +723,22 @@ static int svf_copy_hexstring_to_binary(char *str, uint8_t **bin, int orig_bit_l
 
 static int svf_check_tdo(void)
 {
-	int i, len, index;
+	int i, len, index_var;
 
 	for (i = 0; i < svf_check_tdo_para_index; i++)
 	{
-		index = svf_check_tdo_para[i].buffer_offset;
+		index_var = svf_check_tdo_para[i].buffer_offset;
 		len = svf_check_tdo_para[i].bit_len;
 		if ((svf_check_tdo_para[i].enabled)
-			&& buf_cmp_mask(&svf_tdi_buffer[index], &svf_tdo_buffer[index], &svf_mask_buffer[index], len))
+			&& buf_cmp_mask(&svf_tdi_buffer[index_var], &svf_tdo_buffer[index_var], &svf_mask_buffer[index_var], len))
 		{
 			unsigned bitmask;
 			unsigned received, expected, tapmask;
 			bitmask = svf_get_mask_u32(svf_check_tdo_para[i].bit_len);
 
-			memcpy(&received, svf_tdi_buffer + index, sizeof(unsigned));
-			memcpy(&expected, svf_tdo_buffer + index, sizeof(unsigned));
-			memcpy(&tapmask, svf_mask_buffer + index, sizeof(unsigned));
+			memcpy(&received, svf_tdi_buffer + index_var, sizeof(unsigned));
+			memcpy(&expected, svf_tdo_buffer + index_var, sizeof(unsigned));
+			memcpy(&tapmask, svf_mask_buffer + index_var, sizeof(unsigned));
 			LOG_ERROR("tdo check error at line %d",
 					  svf_check_tdo_para[i].line_num);
 			LOG_ERROR("read = 0x%X, want = 0x%X, mask = 0x%X",

-----------------------------------------------------------------------

Summary of changes:
 configure.in            |    2 +-
 src/server/gdb_server.c |   21 +++++++++++++++------
 src/svf/svf.c           |   30 +++++++++++++++---------------
 src/xsvf/xsvf.c         |    2 --
 4 files changed, 31 insertions(+), 24 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 17 07:24:41 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Jun 2010 05:24:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-342-gb89462d
Message-ID: <E1OP7an-00081i-Kq@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b89462d7dc5f5ba7a025f891474a7506a5cd1294 (commit)
       via  984bf158213b7cc040975c52aada4830d8d98e79 (commit)
      from  814c2a8f9a41a6445f131ee35474dced4bbed210 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b89462d7dc5f5ba7a025f891474a7506a5cd1294
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Mon Jun 14 12:31:13 2010 +0800

    helper: remove helper membuf
    
    Helper is now unused. Can be removed.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 3ec4f31..27ae1e2 100644
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -22,8 +22,7 @@ libhelper_la_SOURCES = \
 	command.c \
 	time_support.c \
 	replacements.c \
-	fileio.c \
-	membuf.c
+	fileio.c
 
 if IOUTIL
 libhelper_la_SOURCES += ioutil.c
@@ -44,7 +43,6 @@ noinst_HEADERS = \
 	types.h \
 	log.h \
 	command.h \
-	membuf.h \
 	time_support.h \
 	replacements.h \
 	fileio.h \
diff --git a/src/helper/membuf.c b/src/helper/membuf.c
deleted file mode 100644
index 766364a..0000000
--- a/src/helper/membuf.c
+++ /dev/null
@@ -1,240 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2009 By Duane Ellis                                     *
- *   openocd at duaneellis.com                                                *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "membuf.h"
-
-struct membuf {
-    // buflen is alway "+1" bigger then
-    // what is shown here, the +1 is for
-    // the NULL string terminator
-#define DEFAULT_BUFSIZE 100
-    size_t maxlen; // allocated size
-    size_t curlen; // where we are inserting at
-    char *_strtoklast;
-    void *buf;
-};
-
-
-#define space_avail(pBuf)  (pBuf->maxlen - pBuf->curlen)
-#define dataend(pBuf)      (((char *)(pBuf->buf)) + pBuf->curlen)
-
-size_t
-membuf_len(struct membuf *pBuf)
-{
-    return pBuf->curlen;
-}
-
-const void *
-membuf_datapointer(struct membuf *pBuf)
-{
-    return ((void *)(pBuf->buf));
-}
-
-const char *
-membuf_strtok(struct membuf *pBuf, const char *sep, void **pLast)
-{
-    if (pBuf) {
-	pBuf->_strtoklast = NULL;
-	*pLast = pBuf;
-	// this should be "strtok_r()" but windows lacks */
-	return strtok(((char *)(pBuf->buf)), sep);
-    } else {
-	// recover our pBuf
-	pBuf = *((struct membuf **)(pLast));
-	// this should be "strtok_r()" but windows lacks */
-	return strtok( NULL, sep);
-    }
-}
-
-
-
-struct membuf *
-membuf_new(void)
-{
-    // by default - parameters are zero.
-    struct membuf *pBuf;
-
-    pBuf = calloc(1, sizeof(*pBuf));
-    if (pBuf) {
-	// we *ALWAYS* allocate +1 for null terminator.
-	pBuf->buf = calloc(DEFAULT_BUFSIZE + 1, sizeof(char));
-	if (pBuf->buf == NULL) {
-	    free(pBuf);
-	    pBuf = NULL;
-	} else {
-	    pBuf->maxlen = DEFAULT_BUFSIZE;
-	}
-    }
-    return pBuf;
-}
-
-
-struct membuf *
-membuf_grow(struct membuf *pBuf, int n)
-{
-    void *vp;
-    signed int newsize;
-
-    // this is a *SIGNED* value
-    newsize = ((int)(pBuf->maxlen)) + n;
-
-    // do not go negative, or too small
-    if (newsize < DEFAULT_BUFSIZE) {
-	newsize = DEFAULT_BUFSIZE;
-    }
-
-    // always alloc +1 for the null terminator
-    vp = realloc(pBuf->buf, newsize + 1);
-    if (vp) {
-	pBuf->buf    = vp;
-	pBuf->maxlen = newsize;
-	return pBuf;
-    } else {
-	return NULL;
-    }
-}
-
-
-void membuf_reset(struct membuf *pBuf)
-{
-    pBuf->curlen = 0;
-}
-
-
-void membuf_delete(struct membuf *pBuf)
-{
-    if (pBuf) {
-	if (pBuf->buf) {
-	    // wack data so it cannot be reused
-	    memset(pBuf->buf,0,pBuf->maxlen);
-	    free(pBuf->buf);
-	}
-	// wack dat so it cannot be reused
-	memset(pBuf,0,sizeof(pBuf));
-	free(pBuf);
-    }
-}
-
-int
-membuf_sprintf(struct membuf *pBuf , const char *fmt, ...)
-{
-    int r;
-    va_list ap;
-    va_start(ap, fmt);
-    r = membuf_vsprintf(pBuf, fmt, ap);
-    va_end(ap);
-    return r;
-}
-
-int
-membuf_vsprintf(struct membuf *pBuf, const char *fmt, va_list ap)
-{
-    int r;
-    size_t sa;
-    int grew;
-
-
-    grew = 0;
-    for (;;) {
-	sa = space_avail(pBuf);
-
-	// do work
-	r = vsnprintf(dataend(pBuf),
-		       sa,
-		       fmt,
-		       ap);
-	if ((r > 0) && (((size_t)(r)) < sa)) {
-	    // Success!
-	    pBuf->curlen += ((size_t)(r));
-	    // remember: We always alloc'ed +1
-	    // so this does not overflow
-	    ((char *)(pBuf->buf))[ pBuf->curlen ] = 0;
-	    r = 0;
-	    break;
-	}
-
-	// failure
-	if (r < 0) {
-	    // Option(A) format error
-	    // Option(B) glibc2.0 bug
-	    // assume (B).
-	    r = (4 * DEFAULT_BUFSIZE);
-	}
-
-	// don't do this again
-	if (grew) {
-	    r = -1;
-	    break;
-	}
-	grew = 1;
-	pBuf = membuf_grow(pBuf, r);
-	if (pBuf == NULL) {
-	    // grow failed
-	    r = -1;
-	    break;
-	}
-    }
-    return r;
-}
-
-struct membuf *
-membuf_strcat(struct membuf *pBuf, const char *pStr)
-{
-    return membuf_append(pBuf, pStr, strlen(pStr));
-}
-
-struct membuf *
-membuf_append(struct membuf *pBuf, const void *pData, size_t len)
-{
-    size_t sa;
-    int r;
-
-    // how much room is there?
-    sa = space_avail(pBuf);
-
-    // will it fit?
-    if (sa < len) {
-	// if not, how much do we need?
-	r = ((int)(sa - len));
-	// do the grow.
-	pBuf = membuf_grow(pBuf, r);
-	// failed?
-	if (pBuf == NULL) {
-	    return pBuf;
-	}
-    }
-    // append
-    memcpy(dataend(pBuf),
-	    pData,
-	    len);
-    pBuf->curlen += len;
-    return pBuf;
-}
-
-
-
-
-
-
diff --git a/src/helper/membuf.h b/src/helper/membuf.h
deleted file mode 100644
index fa96998..0000000
--- a/src/helper/membuf.h
+++ /dev/null
@@ -1,137 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2009 By Duane Ellis                                     *
- *   openocd at duaneellis.com                                                *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef HELPER_MEMBUF_H
-#define HELPER_MEMBUF_H
-
-/** @file
- * MEMBUF - an auto-growing string buffer
- *
- * With OpenOCD often, one must write code that sends text to
- * different places.. the historical command_ctx, or JIM output,
- * and/or other places.
- *
- * This is a simple 'string buffer' that auto-grows.
- *
- * More correctly put, this is a "memory buffer"
- * it may contain binary data
- *
- * Note: Internally the buffer always has a 'null terminator'
- */
-
-/* contents of this structure are 'opaque' */
-struct membuf;
-
-
-/** Create a new membuf
- * By default the memory buffer has "some non-zero-size"
- * (couple hundred bytes, exact amount is opaque)
- */
-struct membuf *membuf_new(void);
-
-/** delete (destroy) the mem buffer
- * @param pBuf - buffer to release
- */
-void membuf_delete(struct membuf *pBuf);
-
-
-/** grow/shrink a membuf by specified amount.
- * @param pBuf   - the buffer
- * @param amount - the amount to grow or shrink by.
- *
- * Symantics of 'realloc()' return NULL on failure
- */
-struct membuf *membuf_grow(struct membuf *pBuf, int amount);
-
-/** how long is this buffer (memlen(), strlen())
- * @param pBuf - the buffer
- *
- * @returns: length of current buffer.
- */
-size_t membuf_len(struct membuf *pBuf);
-
-
-/** reset an membuf to zero length.
- * @param pBuf - buffer to reset
- *
- * Note this does not 'release' the memory buffer
- */
-void membuf_reset(struct membuf *pBuf);
-
-
-/** sprintf() to the string buffer
- * @param pBuf - buffer to capture sprintf() data into
- * @param fmt  - printf format
- *
- * Returns 0 on success
- * Returns non-zero on failure
- */
-int membuf_sprintf(struct membuf *pBuf , const char *fmt, ...);
-
-/** vsprintf() to the string buffer
- * @param pBuf - buffer to capture sprintf() data into
- * @param fmt  - printf format
- * @param ap   - va_list for fmt
- *
- * Returns 0 on success
- * Returns non-zero on failure
- */
-int membuf_vsprintf(struct membuf *pBuf , const char *fmt, va_list ap);
-
-/** Tokenize lines using strtok()
- * @param pBuf - buffer to tokenize
- * @param delim - delimiter parameter for strtok_r()
- * @param pSave - pointer to string context for tokenization
- *
- * Identical to "strtok()" - pass "pBuff = NULL" on second call
- *
- * NOTE: This call is <b > destructive</b> to the buffer.
- */
-const char *membuf_strtok(struct membuf *pBuf, const char *delim, void **pSave);
-
-/** Return pointer to the memory in the buffer
- * @param pBuf - buffer
- *
- * NOTE: Thou shall not modify this pointer, it is <b > CONST</b>
- */
-const void *membuf_datapointer(struct membuf *pBuf);
-
-
-/** Append data to the buffer
- * @param pBuf  - buffer to append
- * @param pData - pointer to data to append
- * @param len   - length of data to append
- *
- * Modified symantics of "memcpy()".  On memory allocation failure
- * returns NULL.  On success, returns pointer to orginal membuf.
- */
-struct membuf *membuf_append(struct membuf *pBuf, const void *pData, size_t len);
-
-
-/** Append string to the buffer
- * @param pBuf  - buffer to append
- * @param str   - string to append
- *
- * Modified symantics of "strcat()".  On memory allocation failure
- * returns NULL.  On success, returns pointer to orginal membuf.
- */
-struct membuf *membuf_strcat(struct membuf *pBuf, const char *str);
-
-
-#endif

commit 984bf158213b7cc040975c52aada4830d8d98e79
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Mon Jun 14 12:22:10 2010 +0800

    nor/at91sam3: replace helper membuf
    
    Helper ./src/helper/membuf.c is only used in at91sam3.c
    
    1) Replace membuf with LOG_*
    
    2) The original code in sam3_GetDetails() invalidates
       all the buffered output of sam3_GetInfo(). The new
       code skips sam3_GetInfo() if its output should not
       be printed.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 06b84cd..8fa6dd4 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -59,7 +59,6 @@
 
 #include "imp.h"
 #include "at91sam3.h"
-#include <helper/membuf.h>
 #include <helper/time_support.h>
 
 #define REG_NAME_WIDTH  (12)
@@ -211,8 +210,6 @@ struct sam3_chip {
 	struct sam3_chip_details details;
 	struct target *target;
 	struct sam3_cfg cfg;
-
-	struct membuf *mbuf;
 };
 
 
@@ -1000,20 +997,6 @@ FLASHD_Lock(struct sam3_bank_private *pPrivate,
 /****** END SAM3 CODE ********/
 
 /* begin helpful debug code */
-
-static void
-sam3_sprintf(struct sam3_chip *pChip , const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap,fmt);
-	if (pChip->mbuf == NULL) {
-		return;
-	}
-
-	membuf_vsprintf(pChip->mbuf, fmt, ap);
-	va_end(ap);
-}
-
 // print the fieldname, the field value, in dec & hex, and return field value
 static uint32_t
 sam3_reg_fieldname(struct sam3_chip *pChip,
@@ -1038,7 +1021,7 @@ sam3_reg_fieldname(struct sam3_chip *pChip,
 	}
 
 	// show the basics
-	sam3_sprintf(pChip, "\t%*s: %*d [0x%0*x] ",
+	LOG_USER_N("\t%*s: %*d [0x%0*x] ",
 				  REG_NAME_WIDTH, regname,
 				  dwidth, v,
 				  hwidth, v);
@@ -1173,16 +1156,16 @@ sam3_explain_ckgr_mor(struct sam3_chip *pChip)
 	uint32_t rcen;
 
 	v = sam3_reg_fieldname(pChip, "MOSCXTEN", pChip->cfg.CKGR_MOR, 0, 1);
-	sam3_sprintf(pChip, "(main xtal enabled: %s)\n",
+	LOG_USER_N("(main xtal enabled: %s)\n",
 				  _yes_or_no(v));
 	v = sam3_reg_fieldname(pChip, "MOSCXTBY", pChip->cfg.CKGR_MOR, 1, 1);
-	sam3_sprintf(pChip, "(main osc bypass: %s)\n",
+	LOG_USER_N("(main osc bypass: %s)\n",
 				  _yes_or_no(v));
 	rcen = sam3_reg_fieldname(pChip, "MOSCRCEN", pChip->cfg.CKGR_MOR, 2, 1);
-	sam3_sprintf(pChip, "(onchip RC-OSC enabled: %s)\n",
+	LOG_USER_N("(onchip RC-OSC enabled: %s)\n",
 				  _yes_or_no(rcen));
 	v = sam3_reg_fieldname(pChip, "MOSCRCF", pChip->cfg.CKGR_MOR, 4, 3);
-	sam3_sprintf(pChip, "(onchip RC-OSC freq: %s)\n",
+	LOG_USER_N("(onchip RC-OSC freq: %s)\n",
 				  _rc_freq[v]);
 
 	pChip->cfg.rc_freq = 0;
@@ -1203,14 +1186,14 @@ sam3_explain_ckgr_mor(struct sam3_chip *pChip)
 	}
 
 	v = sam3_reg_fieldname(pChip,"MOSCXTST", pChip->cfg.CKGR_MOR, 8, 8);
-	sam3_sprintf(pChip, "(startup clks, time= %f uSecs)\n",
+	LOG_USER_N("(startup clks, time= %f uSecs)\n",
 				  ((float)(v * 1000000)) / ((float)(pChip->cfg.slow_freq)));
 	v = sam3_reg_fieldname(pChip, "MOSCSEL", pChip->cfg.CKGR_MOR, 24, 1);
-	sam3_sprintf(pChip, "(mainosc source: %s)\n",
+	LOG_USER_N("(mainosc source: %s)\n",
 				  v ? "external xtal" : "internal RC");
 
 	v = sam3_reg_fieldname(pChip,"CFDEN", pChip->cfg.CKGR_MOR, 25, 1);
-	sam3_sprintf(pChip, "(clock failure enabled: %s)\n",
+	LOG_USER_N("(clock failure enabled: %s)\n",
 				 _yes_or_no(v));
 }
 
@@ -1224,19 +1207,19 @@ sam3_explain_chipid_cidr(struct sam3_chip *pChip)
 	const char *cp;
 
 	sam3_reg_fieldname(pChip, "Version", pChip->cfg.CHIPID_CIDR, 0, 5);
-	sam3_sprintf(pChip,"\n");
+	LOG_USER_N("\n");
 
 	v = sam3_reg_fieldname(pChip, "EPROC", pChip->cfg.CHIPID_CIDR, 5, 3);
-	sam3_sprintf(pChip, "%s\n", eproc_names[v]);
+	LOG_USER_N("%s\n", eproc_names[v]);
 
 	v = sam3_reg_fieldname(pChip, "NVPSIZE", pChip->cfg.CHIPID_CIDR, 8, 4);
-	sam3_sprintf(pChip, "%s\n", nvpsize[v]);
+	LOG_USER_N("%s\n", nvpsize[v]);
 
 	v = sam3_reg_fieldname(pChip, "NVPSIZE2", pChip->cfg.CHIPID_CIDR, 12, 4);
-	sam3_sprintf(pChip, "%s\n", nvpsize2[v]);
+	LOG_USER_N("%s\n", nvpsize2[v]);
 
 	v = sam3_reg_fieldname(pChip, "SRAMSIZE", pChip->cfg.CHIPID_CIDR, 16,4);
-	sam3_sprintf(pChip, "%s\n", sramsize[ v ]);
+	LOG_USER_N("%s\n", sramsize[ v ]);
 
 	v = sam3_reg_fieldname(pChip, "ARCH", pChip->cfg.CHIPID_CIDR, 20, 8);
 	cp = _unknown;
@@ -1247,13 +1230,13 @@ sam3_explain_chipid_cidr(struct sam3_chip *pChip)
 		}
 	}
 
-	sam3_sprintf(pChip, "%s\n", cp);
+	LOG_USER_N("%s\n", cp);
 
 	v = sam3_reg_fieldname(pChip, "NVPTYP", pChip->cfg.CHIPID_CIDR, 28, 3);
-	sam3_sprintf(pChip, "%s\n", nvptype[ v ]);
+	LOG_USER_N("%s\n", nvptype[ v ]);
 
 	v = sam3_reg_fieldname(pChip, "EXTID", pChip->cfg.CHIPID_CIDR, 31, 1);
-	sam3_sprintf(pChip, "(exists: %s)\n", _yes_or_no(v));
+	LOG_USER_N("(exists: %s)\n", _yes_or_no(v));
 }
 
 static void
@@ -1263,14 +1246,14 @@ sam3_explain_ckgr_mcfr(struct sam3_chip *pChip)
 
 
 	v = sam3_reg_fieldname(pChip, "MAINFRDY", pChip->cfg.CKGR_MCFR, 16, 1);
-	sam3_sprintf(pChip, "(main ready: %s)\n", _yes_or_no(v));
+	LOG_USER_N("(main ready: %s)\n", _yes_or_no(v));
 
 	v = sam3_reg_fieldname(pChip, "MAINF", pChip->cfg.CKGR_MCFR, 0, 16);
 
 	v = (v * pChip->cfg.slow_freq) / 16;
 	pChip->cfg.mainosc_freq = v;
 
-	sam3_sprintf(pChip, "(%3.03f Mhz (%d.%03dkhz slowclk)\n",
+	LOG_USER_N("(%3.03f Mhz (%d.%03dkhz slowclk)\n",
 				 _tomhz(v),
 				 pChip->cfg.slow_freq / 1000,
 				 pChip->cfg.slow_freq % 1000);
@@ -1283,17 +1266,17 @@ sam3_explain_ckgr_plla(struct sam3_chip *pChip)
 	uint32_t mula,diva;
 
 	diva = sam3_reg_fieldname(pChip, "DIVA", pChip->cfg.CKGR_PLLAR, 0, 8);
-	sam3_sprintf(pChip,"\n");
+	LOG_USER_N("\n");
 	mula = sam3_reg_fieldname(pChip, "MULA", pChip->cfg.CKGR_PLLAR, 16, 11);
-	sam3_sprintf(pChip,"\n");
+	LOG_USER_N("\n");
 	pChip->cfg.plla_freq = 0;
 	if (mula == 0) {
-		sam3_sprintf(pChip,"\tPLLA Freq: (Disabled,mula = 0)\n");
+		LOG_USER_N("\tPLLA Freq: (Disabled,mula = 0)\n");
 	} else if (diva == 0) {
-		sam3_sprintf(pChip,"\tPLLA Freq: (Disabled,diva = 0)\n");
+		LOG_USER_N("\tPLLA Freq: (Disabled,diva = 0)\n");
 	} else if (diva == 1) {
 		pChip->cfg.plla_freq = (pChip->cfg.mainosc_freq * (mula + 1));
-		sam3_sprintf(pChip,"\tPLLA Freq: %3.03f MHz\n",
+		LOG_USER_N("\tPLLA Freq: %3.03f MHz\n",
 					 _tomhz(pChip->cfg.plla_freq));
 	}
 }
@@ -1334,7 +1317,7 @@ sam3_explain_mckr(struct sam3_chip *pChip)
 		break;
 	}
 
-	sam3_sprintf(pChip, "%s (%3.03f Mhz)\n",
+	LOG_USER_N("%s (%3.03f Mhz)\n",
 				  cp,
 				  _tomhz(fin));
 	pres = sam3_reg_fieldname(pChip, "PRES", pChip->cfg.PMC_MCKR, 4, 3);
@@ -1374,14 +1357,14 @@ sam3_explain_mckr(struct sam3_chip *pChip)
 		assert(0);
 		break;
 	}
-	sam3_sprintf(pChip, "(%s)\n", cp);
+	LOG_USER_N("(%s)\n", cp);
 	fin = fin / pdiv;
 	// sam3 has a *SINGLE* clock -
 	// other at91 series parts have divisors for these.
 	pChip->cfg.cpu_freq = fin;
 	pChip->cfg.mclk_freq = fin;
 	pChip->cfg.fclk_freq = fin;
-	sam3_sprintf(pChip, "\t\tResult CPU Freq: %3.03f\n",
+	LOG_USER_N("\t\tResult CPU Freq: %3.03f\n",
 				  _tomhz(fin));
 }
 
@@ -1538,15 +1521,12 @@ sam3_GetInfo(struct sam3_chip *pChip)
 	const struct sam3_reg_list *pReg;
 	uint32_t regval;
 
-	membuf_reset(pChip->mbuf);
-
-
 	pReg = &(sam3_all_regs[0]);
 	while (pReg->name) {
 		// display all regs
 		LOG_DEBUG("Start: %s", pReg->name);
 		regval = *sam3_get_reg_ptr(&(pChip->cfg), pReg);
-		sam3_sprintf(pChip, "%*s: [0x%08x] -> 0x%08x\n",
+		LOG_USER_N("%*s: [0x%08x] -> 0x%08x\n",
 					 REG_NAME_WIDTH,
 					 pReg->name,
 					 pReg->address,
@@ -1557,14 +1537,14 @@ sam3_GetInfo(struct sam3_chip *pChip)
 		LOG_DEBUG("End: %s", pReg->name);
 		pReg++;
 	}
-	sam3_sprintf(pChip,"   rc-osc: %3.03f MHz\n", _tomhz(pChip->cfg.rc_freq));
-	sam3_sprintf(pChip,"  mainosc: %3.03f MHz\n", _tomhz(pChip->cfg.mainosc_freq));
-	sam3_sprintf(pChip,"     plla: %3.03f MHz\n", _tomhz(pChip->cfg.plla_freq));
-	sam3_sprintf(pChip," cpu-freq: %3.03f MHz\n", _tomhz(pChip->cfg.cpu_freq));
-	sam3_sprintf(pChip,"mclk-freq: %3.03f MHz\n", _tomhz(pChip->cfg.mclk_freq));
+	LOG_USER_N("   rc-osc: %3.03f MHz\n", _tomhz(pChip->cfg.rc_freq));
+	LOG_USER_N("  mainosc: %3.03f MHz\n", _tomhz(pChip->cfg.mainosc_freq));
+	LOG_USER_N("     plla: %3.03f MHz\n", _tomhz(pChip->cfg.plla_freq));
+	LOG_USER_N(" cpu-freq: %3.03f MHz\n", _tomhz(pChip->cfg.cpu_freq));
+	LOG_USER_N("mclk-freq: %3.03f MHz\n", _tomhz(pChip->cfg.mclk_freq));
 
 
-	sam3_sprintf(pChip, " UniqueId: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+	LOG_USER_N(" UniqueId: 0x%08x 0x%08x 0x%08x 0x%08x\n",
 				  pChip->cfg.unique_id[0],
 				  pChip->cfg.unique_id[1],
 				  pChip->cfg.unique_id[2],
@@ -1664,11 +1644,6 @@ FLASH_BANK_COMMAND_HANDLER(sam3_flash_bank_command)
 		// assumption is this runs at 32khz
 		pChip->cfg.slow_freq = 32768;
 		pChip->probed = 0;
-		pChip->mbuf = membuf_new();
-		if (!(pChip->mbuf)) {
-			LOG_ERROR("no memory");
-			return ERROR_FAIL;
-		}
 	}
 
 	switch (bank->base) {
@@ -1702,11 +1677,8 @@ sam3_GetDetails(struct sam3_bank_private *pPrivate)
 {
 	const struct sam3_chip_details *pDetails;
 	struct sam3_chip *pChip;
-	void *vp;
 	struct flash_bank *saved_banks[SAM3_MAX_FLASH_BANKS];
-
 	unsigned x;
-	const char *cp;
 
 	LOG_DEBUG("Begin");
 	pDetails = all_sam3_details;
@@ -1721,16 +1693,9 @@ sam3_GetDetails(struct sam3_bank_private *pPrivate)
 		LOG_ERROR("SAM3 ChipID 0x%08x not found in table (perhaps you can this chip?)",
 				  (unsigned int)(pPrivate->pChip->cfg.CHIPID_CIDR));
 		// Help the victim, print details about the chip
-		membuf_reset(pPrivate->pChip->mbuf);
-		membuf_sprintf(pPrivate->pChip->mbuf,
-						"SAM3 CHIPID_CIDR: 0x%08x decodes as follows\n",
+		LOG_INFO_N("SAM3 CHIPID_CIDR: 0x%08x decodes as follows\n",
 						pPrivate->pChip->cfg.CHIPID_CIDR);
 		sam3_explain_chipid_cidr(pPrivate->pChip);
-		cp = membuf_strtok(pPrivate->pChip->mbuf, "\n", &vp);
-		while (cp) {
-			LOG_INFO("%s", cp);
-			cp = membuf_strtok(NULL, "\n", &vp);
-		}
 		return ERROR_FAIL;
 	}
 
@@ -1798,18 +1763,14 @@ _sam3_probe(struct flash_bank *bank, int noise)
 
 
 	LOG_DEBUG("Here");
-	r = sam3_GetInfo(pPrivate->pChip);
+	if (pPrivate->pChip->probed) {
+		r = sam3_GetInfo(pPrivate->pChip);
+	} else {
+		r = sam3_GetDetails(pPrivate);
+	}
 	if (r != ERROR_OK) {
 		return r;
 	}
-	if (!(pPrivate->pChip->probed)) {
-		pPrivate->pChip->probed = 1;
-		LOG_DEBUG("Here");
-		r = sam3_GetDetails(pPrivate);
-		if (r != ERROR_OK) {
-			return r;
-		}
-	}
 
 	// update the flash bank size
 	for (x = 0 ; x < SAM3_MAX_FLASH_BANKS ; x++) {
@@ -2256,8 +2217,6 @@ sam3_write(struct flash_bank *bank,
 COMMAND_HANDLER(sam3_handle_info_command)
 {
 	struct sam3_chip *pChip;
-	void *vp;
-	const char *cp;
 	unsigned x;
 	int r;
 
@@ -2319,13 +2278,6 @@ COMMAND_HANDLER(sam3_handle_info_command)
 		return r;
 	}
 
-
-	// print results
-	cp = membuf_strtok(pChip->mbuf, "\n", &vp);
-	while (cp) {
-		command_print(CMD_CTX,"%s", cp);
-		cp = membuf_strtok(NULL, "\n", &vp);
-	}
 	return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/at91sam3.c |  126 ++++++++-----------------
 src/helper/Makefile.am   |    4 +-
 src/helper/membuf.c      |  240 ----------------------------------------------
 src/helper/membuf.h      |  137 --------------------------
 4 files changed, 40 insertions(+), 467 deletions(-)
 delete mode 100644 src/helper/membuf.c
 delete mode 100644 src/helper/membuf.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 17 12:17:23 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Jun 2010 10:17:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-343-g80eb7e2
Message-ID: <E1OPCA4-0000pM-7I@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  80eb7e2a789939263662cf37e564d0afcdb0e188 (commit)
      from  b89462d7dc5f5ba7a025f891474a7506a5cd1294 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 80eb7e2a789939263662cf37e564d0afcdb0e188
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Jun 17 09:04:46 2010 +0200

    zy1000: fix arm11 optimisation
    
    copy & paste error + added FIFO throttling to work around
    lockup bug in FPGA.
    
    The arm11 optimisation was introduced post v0.4.0, so this
    is not a regression compared to previous release.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index b50e96a..013d865 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -878,101 +878,100 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 
 int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count)
 {
-#if 0
-	int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count);
-	return arm11_run_instr_data_to_core_noack_inner_default(tap, opcode, data, count);
-#else
-	static const int bits[] = {32, 2};
-	uint32_t values[] = {0, 0};
-
-	/* FIX!!!!!! the target_write_memory() API started this nasty problem
-	 * with unaligned uint32_t * pointers... */
-	const uint8_t *t = (const uint8_t *)data;
-
-
 	/* bypass bits before and after */
 	int pre_bits;
 	int post_bits;
 	jtag_pre_post_bits(tap, &pre_bits, &post_bits);
-
-	bool found = false;
-	struct jtag_tap *cur_tap, *nextTap;
-	for (cur_tap = jtag_tap_next_enabled(NULL); cur_tap!= NULL; cur_tap = nextTap)
-	{
-		nextTap = jtag_tap_next_enabled(cur_tap);
-		if (cur_tap == tap)
-		{
-			found = true;
-		} else
-		{
-			if (found)
-			{
-				post_bits++;
-			} else
-			{
-				pre_bits++;
-			}
-		}
-	}
-
 	post_bits+=2;
 
-
-	while (--count > 0)
+	if ((pre_bits > 32) || (post_bits > 32))
 	{
-		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
-
-		uint32_t value;
-		value = *t++;
-		value |= (*t++<<8);
-		value |= (*t++<<16);
-		value |= (*t++<<24);
+		int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count);
+		return arm11_run_instr_data_to_core_noack_inner_default(tap, opcode, data, count);
+	} else
+	{
+		static const int bits[] = {32, 2};
+		uint32_t values[] = {0, 0};
 
-		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, value);
-		/* minimum 2 bits */
-		shiftValueInner(TAP_DRSHIFT, TAP_DRPAUSE, post_bits, 0);
+		/* FIX!!!!!! the target_write_memory() API started this nasty problem
+		 * with unaligned uint32_t * pointers... */
+		const uint8_t *t = (const uint8_t *)data;
 
+		while (--count > 0)
+		{
 #if 1
-		/* copy & paste from arm11_dbgtap.c */
-		//TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+			/* Danger! This code doesn't update cmd_queue_cur_state, so
+			 * invoking jtag_add_pathmove() before jtag_add_dr_out() after
+			 * this loop would fail!
+			 */
+			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, pre_bits, 0);
 
-		waitIdle();
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
-		/* we don't have to wait for the queue to empty here. waitIdle();	 */
-		ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_DRSHIFT);
+			uint32_t value;
+			value = *t++;
+			value |= (*t++<<8);
+			value |= (*t++<<16);
+			value |= (*t++<<24);
+
+			shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, value);
+			/* minimum 2 bits */
+			shiftValueInner(TAP_DRSHIFT, TAP_DRPAUSE, post_bits, 0);
+
+			/* copy & paste from arm11_dbgtap.c */
+			//TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+			/* KLUDGE! we have to flush the fifo or the Nios CPU locks up.
+			 * This is probably a bug in the Avalon bus(cross clocking bridge?)
+			 * or in the jtag registers module.
+			 */
+			waitIdle();
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			/* we don't have to wait for the queue to empty here */
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_DRSHIFT);
+			waitIdle();
 #else
-		static const tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
-		{
-			TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
-		};
-
-		jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
-			arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
+			static const tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
+			{
+				TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+			};
+
+			values[0] = *t++;
+			values[0] |= (*t++<<8);
+			values[0] |= (*t++<<16);
+			values[0] |= (*t++<<24);
+
+			jtag_add_dr_out(tap,
+				2,
+				bits,
+				values,
+				TAP_IDLE);
+
+			jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
+				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
 #endif
-	}
+		}
 
-	values[0] = *t++;
-	values[0] |= (*t++<<8);
-	values[0] |= (*t++<<16);
-	values[0] |= (*t++<<24);
+		values[0] = *t++;
+		values[0] |= (*t++<<8);
+		values[0] |= (*t++<<16);
+		values[0] |= (*t++<<24);
 
-	/* This will happen on the last iteration updating the current tap state
-	 * so we don't have to track it during the common code path */
-	jtag_add_dr_out(tap,
-		2,
-		bits,
-		values,
-		TAP_IDLE);
+		/* This will happen on the last iteration updating cmd_queue_cur_state
+		 * so we don't have to track it during the common code path
+		 */
+		jtag_add_dr_out(tap,
+			2,
+			bits,
+			values,
+			TAP_IDLE);
 
-	return jtag_execute_queue();
-#endif
+		return jtag_execute_queue();
+	}
 }
 
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |  157 +++++++++++++++++++++++-----------------------
 1 files changed, 78 insertions(+), 79 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 17 15:41:44 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Jun 2010 13:41:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-344-g8a28086
Message-ID: <E1OPFLl-0007QO-Su@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8a2808681e932b6644f572717885c8f8f360e9fa (commit)
      from  80eb7e2a789939263662cf37e564d0afcdb0e188 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8a2808681e932b6644f572717885c8f8f360e9fa
Author: Oyvind Harboe <oyvind.harboe at zylin.com>
Date:   Thu Jun 17 15:30:25 2010 +0200

    gdb-server: fix -Wshadow warning
    
    This warning was only reproducable with
    Cygwin.
    
    Cygwin now builds without warnings for the basic
    case.
    
    Signed-off-by: Oyvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index a1ff7c8..e97839d 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -1,3 +1,4 @@
+
 /***************************************************************************
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
@@ -760,22 +761,22 @@ static void gdb_frontend_halted(struct target *target, struct connection *connec
 	if (gdb_connection->frontend_state == TARGET_RUNNING)
 	{
 		char sig_reply[4];
-		int signal;
+		int signal_var;
 
 		/* stop forwarding log packets! */
 		log_remove_callback(gdb_log_callback, connection);
 
 		if (gdb_connection->ctrl_c)
 		{
-			signal = 0x2;
+			signal_var = 0x2;
 			gdb_connection->ctrl_c = 0;
 		}
 		else
 		{
-			signal = gdb_last_signal(target);
+			signal_var = gdb_last_signal(target);
 		}
 
-		snprintf(sig_reply, 4, "T%2.2x", signal);
+		snprintf(sig_reply, 4, "T%2.2x", signal_var);
 		gdb_put_packet(connection, sig_reply, 3);
 		gdb_connection->frontend_state = TARGET_HALTED;
 	}
@@ -945,11 +946,11 @@ static int gdb_last_signal_packet(struct connection *connection,
 		struct target *target, char* packet, int packet_size)
 {
 	char sig_reply[4];
-	int signal;
+	int signal_var;
 
-	signal = gdb_last_signal(target);
+	signal_var = gdb_last_signal(target);
 
-	snprintf(sig_reply, 4, "S%2.2x", signal);
+	snprintf(sig_reply, 4, "S%2.2x", signal_var);
 	gdb_put_packet(connection, sig_reply, 3);
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c |   15 ++++++++-------
 1 files changed, 8 insertions(+), 7 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 17 18:14:40 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Jun 2010 16:14:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-346-gf2f798f
Message-ID: <E1OPHjn-0004E7-Bm@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f2f798fdd3a4c6d221569ba278945385c2f47504 (commit)
       via  d4e4da0fa177c640196e5bc3476ed03c3a70be00 (commit)
      from  8a2808681e932b6644f572717885c8f8f360e9fa (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f2f798fdd3a4c6d221569ba278945385c2f47504
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Thu Jun 17 23:13:08 2010 +0800

    jlink: fix -Wshadow warning
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 34fce38..52f12b4 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -712,9 +712,9 @@ static void jlink_tap_ensure_space(int scans, int bits)
 
 static void jlink_tap_append_step(int tms, int tdi)
 {
-	int index = tap_length / 8;
+	int index_var = tap_length / 8;
 
-	if (index >= JLINK_TAP_BUFFER_SIZE)
+	if (index_var >= JLINK_TAP_BUFFER_SIZE)
 	{
 		LOG_ERROR("jlink_tap_append_step: overflow");
 		*(uint32_t *)0xFFFFFFFF = 0;
@@ -727,18 +727,18 @@ static void jlink_tap_append_step(int tms, int tdi)
 	// we do not pad TMS, so be sure to initialize all bits
 	if (0 == bit_index)
 	{
-		tms_buffer[index] = tdi_buffer[index] = 0;
+		tms_buffer[index_var] = tdi_buffer[index_var] = 0;
 	}
 
 	if (tms)
-		tms_buffer[index] |= bit;
+		tms_buffer[index_var] |= bit;
 	else
-		tms_buffer[index] &= ~bit;
+		tms_buffer[index_var] &= ~bit;
 
 	if (tdi)
-		tdi_buffer[index] |= bit;
+		tdi_buffer[index_var] |= bit;
 	else
-		tdi_buffer[index] &= ~bit;
+		tdi_buffer[index_var] &= ~bit;
 
 	tap_length++;
 }

commit d4e4da0fa177c640196e5bc3476ed03c3a70be00
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Thu Jun 17 23:12:48 2010 +0800

    vsllink: fix -Wshadow warning
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
index 450ce06..7533a09 100644
--- a/src/jtag/drivers/vsllink.c
+++ b/src/jtag/drivers/vsllink.c
@@ -699,20 +699,20 @@ static void vsllink_tap_ensure_pending(int scans)
 
 static void vsllink_tap_append_step(int tms, int tdi)
 {
-	int index = tap_length / 8;
+	int index_var = tap_length / 8;
 
 	int bit_index = tap_length % 8;
 	uint8_t bit = 1 << bit_index;
 
 	if (tms)
-		tms_buffer[index] |= bit;
+		tms_buffer[index_var] |= bit;
 	else
-		tms_buffer[index] &= ~bit;
+		tms_buffer[index_var] &= ~bit;
 
 	if (tdi)
-		tdi_buffer[index] |= bit;
+		tdi_buffer[index_var] |= bit;
 	else
-		tdi_buffer[index] &= ~bit;
+		tdi_buffer[index_var] &= ~bit;
 
 	tap_length++;
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/jlink.c   |   14 +++++++-------
 src/jtag/drivers/vsllink.c |   10 +++++-----
 2 files changed, 12 insertions(+), 12 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Jun 17 21:11:06 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 17 Jun 2010 19:11:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-350-gada8f59
Message-ID: <E1OPKUW-0004Ci-Hw@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ada8f5963d0263d9e839c371641fdb4dd611f436 (commit)
       via  3eaab9b55b92a4b52e0a31b9c06da8a904a1dddb (commit)
       via  647fe050db9ea709f7624c7330c1315251eb9114 (commit)
       via  b1cd202f9ad8c95a70548d946ca3073553a340cf (commit)
      from  f2f798fdd3a4c6d221569ba278945385c2f47504 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ada8f5963d0263d9e839c371641fdb4dd611f436
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Thu Jun 17 20:30:23 2010 +0200

    mingw32: -Wshadow fixes in arm-jtag-ew.c
    
    (error: declaration of ???stat??? shadows a global declaration; /usr/local/lib/gcc/i686-w64-mingw32/4.4.2/../../../../i686-w64-mingw32/include/sys/stat.h:279: error: shadowed declaration is here)
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index 9d8b8b1..7a6c178 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -659,11 +659,11 @@ static int armjtagew_tap_execute(void)
 
 		if (result == 0)
 		{
-			int stat;
+			int stat_local;
 
-			stat = (int)buf_get_u32(usb_in_buffer + byte_length, 0, 32);
-			if (stat) {
-				LOG_ERROR("armjtagew_tap_execute, emulator returned error code %d for a CMD_TAP_SHIFT command", stat);
+			stat_local = (int)buf_get_u32(usb_in_buffer + byte_length, 0, 32);
+			if (stat_local) {
+				LOG_ERROR("armjtagew_tap_execute, emulator returned error code %d for a CMD_TAP_SHIFT command", stat_local);
 				return ERROR_JTAG_QUEUE_FAILED;
 			}
 

commit 3eaab9b55b92a4b52e0a31b9c06da8a904a1dddb
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Thu Jun 17 20:26:48 2010 +0200

    mingw32: -Wshadow fixes in rlink.c
    
    (error: declaration of ???byte??? shadows a global declaration; /usr/local/lib/gcc/i686-w64-mingw32/4.4.2/../../../../i686-w64-mingw32/include/rpcndr.h:50: error: shadowed declaration is here)
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 2905bf2..dde117b 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -824,21 +824,21 @@ int
 tap_state_queue_run(void) {
 	int	i;
 	int	bits;
-	uint8_t	byte;
+	uint8_t	byte_param;
 	int	retval;
 
 	retval = 0;
 	if (!tap_state_queue.length) return(retval);
 	bits = 1;
-	byte = 0;
+	byte_param = 0;
 	for (i = tap_state_queue.length; i--;) {
 
-		byte <<= 1;
+		byte_param <<= 1;
 		if (tap_state_queue.buffer & 1) {
-			byte |= 1;
+			byte_param |= 1;
 		}
 		if ((bits >= 8) || !i) {
-			byte <<= (8 - bits);
+			byte_param <<= (8 - bits);
 
 			/* make sure there's room for stop, byte op, and one byte */
 			if (dtc_queue.cmd_index >= (sizeof(dtc_queue.cmd_buffer) - (1 + 1 + 1))) {
@@ -860,9 +860,9 @@ tap_state_queue_run(void) {
 #endif
 
 			dtc_queue.cmd_buffer[dtc_queue.cmd_index++] =
-				byte;
+				byte_param;
 
-			byte = 0;
+			byte_param = 0;
 			bits = 1;
 		} else {
 			bits++;

commit 647fe050db9ea709f7624c7330c1315251eb9114
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Thu Jun 17 20:24:46 2010 +0200

    rlink: -Wshadows fixes
    
    (error: declaration of ???pHDev??? shadows a global declaration; ../../../../src/jtag/drivers/rlink.c:102: error: shadowed declaration is here)
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
index 0060baf..2905bf2 100644
--- a/src/jtag/drivers/rlink.c
+++ b/src/jtag/drivers/rlink.c
@@ -110,7 +110,7 @@ static usb_dev_handle *pHDev;
 static
 int
 ep1_generic_commandl(
-	usb_dev_handle	*pHDev,
+	usb_dev_handle	*pHDev_param,
 	size_t		length,
 	...
 ) {
@@ -138,7 +138,7 @@ ep1_generic_commandl(
 );
 
 	usb_ret = usb_bulk_write(
-		pHDev,
+		pHDev_param,
 		USB_EP1OUT_ADDR,
 		(char *)usb_buffer, sizeof(usb_buffer),
 		USB_TIMEOUT_MS
@@ -219,7 +219,7 @@ ep1_memory_read(
 static
 ssize_t
 ep1_memory_write(
-	usb_dev_handle	*pHDev,
+	usb_dev_handle	*pHDev_param,
 	uint16_t	addr,
 	size_t		length,
 	uint8_t	const	*buffer
@@ -256,7 +256,7 @@ ep1_memory_write(
 );
 
 			usb_ret = usb_bulk_write(
-			pHDev, USB_EP1OUT_ADDR,
+			pHDev_param, USB_EP1OUT_ADDR,
 			(char *)usb_buffer, sizeof(usb_buffer),
 			USB_TIMEOUT_MS
 );
@@ -324,7 +324,7 @@ static uint8_t dtc_entry_download;
 static
 int
 dtc_load_from_buffer(
-	usb_dev_handle	*pHDev,
+	usb_dev_handle	*pHDev_param,
 	const uint8_t		*buffer,
 	size_t			length
 ) {
@@ -341,7 +341,7 @@ dtc_load_from_buffer(
 
 	/* Stop the DTC before loading anything. */
 	usb_err = ep1_generic_commandl(
-		pHDev, 1,
+		pHDev_param, 1,
 		EP1_CMD_DTC_STOP
 );
 	if (usb_err < 0) return(usb_err);
@@ -375,7 +375,7 @@ dtc_load_from_buffer(
 			case DTCLOAD_LOAD:
 				/* Send the DTC program to ST7 RAM. */
 				usb_err = ep1_memory_write(
-					pHDev,
+					pHDev_param,
 					DTC_LOAD_BUFFER,
 					header->length + 1, buffer
 );
@@ -383,7 +383,7 @@ dtc_load_from_buffer(
 
 				/* Load it into the DTC. */
 				usb_err = ep1_generic_commandl(
-					pHDev, 3,
+					pHDev_param, 3,
 					EP1_CMD_DTC_LOAD,
 						(DTC_LOAD_BUFFER >> 8),
 						DTC_LOAD_BUFFER
@@ -394,7 +394,7 @@ dtc_load_from_buffer(
 
 			case DTCLOAD_RUN:
 				usb_err = ep1_generic_commandl(
-					pHDev, 3,
+					pHDev_param, 3,
 					EP1_CMD_DTC_CALL,
 						buffer[0],
 					EP1_CMD_DTC_WAIT
@@ -409,7 +409,7 @@ dtc_load_from_buffer(
 
 			case DTCLOAD_LUT:
 				usb_err = ep1_memory_write(
-					pHDev,
+					pHDev_param,
 					ST7_USB_BUF_EP0OUT + lut_start,
 					header->length + 1, buffer
 );
@@ -494,7 +494,7 @@ dtc_start_download(void) {
 static
 int
 dtc_run_download(
-	usb_dev_handle	*pHDev,
+	usb_dev_handle	*pHDev_param,
 	uint8_t	*command_buffer,
 	int	command_buffer_size,
 	uint8_t	*reply_buffer,
@@ -507,7 +507,7 @@ dtc_run_download(
 	LOG_DEBUG(": %d/%d\n", command_buffer_size, reply_buffer_size);
 
 	usb_err = usb_bulk_write(
-		pHDev,
+		pHDev_param,
 		USB_EP2OUT_ADDR,
 		(char *)command_buffer, USB_EP2BANK_SIZE,
 		USB_TIMEOUT_MS
@@ -518,7 +518,7 @@ dtc_run_download(
 	/* Wait for DTC to finish running command buffer */
 	for (i = 10;;) {
 		usb_err = ep1_generic_commandl(
-			pHDev, 4,
+			pHDev_param, 4,
 
 			EP1_CMD_MEMORY_READ,
 				DTC_STATUS_POLL_BYTE >> 8,
@@ -528,7 +528,7 @@ dtc_run_download(
 		if (usb_err < 0) return(usb_err);
 
 		usb_err = usb_bulk_read(
-			pHDev,
+			pHDev_param,
 			USB_EP1IN_ADDR,
 			(char *)ep2_buffer, 1,
 			USB_TIMEOUT_MS
@@ -549,7 +549,7 @@ dtc_run_download(
 	if (!reply_buffer) reply_buffer_size = 0;
 	if (reply_buffer_size) {
 		usb_err = usb_bulk_read(
-			pHDev,
+			pHDev_param,
 			USB_EP2IN_ADDR,
 			(char *)ep2_buffer, sizeof(ep2_buffer),
 			USB_TIMEOUT_MS

commit b1cd202f9ad8c95a70548d946ca3073553a340cf
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Thu Jun 17 20:06:28 2010 +0200

    mingw32: -Wshadow fixes
    
    in jim.c (error: declaration of ???boolean??? shadows a global declaration; /usr/local/lib/gcc/i686-w64-mingw32/4.4.2/../../../../i686-w64-mingw32/include/rpcndr.h:52: error: shadowed declaration is here)
    
    Signed-off-by: Freddie Chopin <freddie_chopin at op.pl>

diff --git a/src/helper/jim.c b/src/helper/jim.c
index 8538954..e9a6ec5 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -9942,12 +9942,12 @@ noopt:
 
     /* The general purpose implementation of while starts here */
     while (1) {
-        int boolean, retval;
+        int local_boolean, retval;
 
         if ((retval = Jim_GetBoolFromExpr(interp, argv[1],
-                        &boolean)) != JIM_OK)
+                        &local_boolean)) != JIM_OK)
             return retval;
-        if (!boolean) break;
+        if (!local_boolean) break;
         if ((retval = Jim_EvalObj(interp, argv[2])) != JIM_OK) {
             switch (retval) {
             case JIM_BREAK:
@@ -10146,13 +10146,13 @@ evalstart:
     if ((retval = Jim_EvalObj(interp, argv[1])) != JIM_OK)
         return retval;
     while (1) {
-        int boolean;
+        int local_boolean;
 testcond:
         /* Test the condition */
-        if ((retval = Jim_GetBoolFromExpr(interp, argv[2], &boolean))
+        if ((retval = Jim_GetBoolFromExpr(interp, argv[2], &local_boolean))
                 != JIM_OK)
             return retval;
-        if (!boolean) break;
+        if (!local_boolean) break;
         /* Eval body */
         if ((retval = Jim_EvalObj(interp, argv[4])) != JIM_OK) {
             switch (retval) {
@@ -10297,13 +10297,13 @@ static int Jim_LmapCoreCommand(Jim_Interp *interp, int argc,
 static int Jim_IfCoreCommand(Jim_Interp *interp, int argc,
         Jim_Obj *const *argv)
 {
-    int boolean, retval, current = 1, falsebody = 0;
+    int local_boolean, retval, current = 1, falsebody = 0;
     if (argc >= 3) {
         while (1) {
             /* Far not enough arguments given! */
             if (current >= argc) goto err;
             if ((retval = Jim_GetBoolFromExpr(interp,
-                        argv[current++], &boolean))
+                        argv[current++], &local_boolean))
                     != JIM_OK)
                 return retval;
             /* There lacks something, isn't it? */
@@ -10312,7 +10312,7 @@ static int Jim_IfCoreCommand(Jim_Interp *interp, int argc,
                         "then")) current++;
             /* Tsk tsk, no then-clause? */
             if (current >= argc) goto err;
-            if (boolean)
+            if (local_boolean)
                 return Jim_EvalObj(interp, argv[current]);
              /* Ok: no else-clause follows */
             if (++current >= argc) {

-----------------------------------------------------------------------

Summary of changes:
 src/helper/jim.c               |   18 ++++++++--------
 src/jtag/drivers/arm-jtag-ew.c |    8 +++---
 src/jtag/drivers/rlink.c       |   44 ++++++++++++++++++++--------------------
 3 files changed, 35 insertions(+), 35 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jun 18 07:53:48 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Jun 2010 05:53:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-352-gc3ee63b
Message-ID: <E1OPUWU-0003Ed-LV@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c3ee63be77476af770134b39d31758eb6a0ef69f (commit)
       via  cebd817cee515fda9d697c5c8d23992254805346 (commit)
      from  ada8f5963d0263d9e839c371641fdb4dd611f436 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c3ee63be77476af770134b39d31758eb6a0ef69f
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Jun 18 11:43:09 2010 +0800

    helper/jim: review unused symbols
    
    Remove unused functions:
    - Jim_IdentityHashFunction
    - StringAppendObj
    - JimReferencesHTDoubleHashFunction
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/jim.c b/src/helper/jim.c
index 91f1ea5..7fdf52c 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -656,12 +656,6 @@ static unsigned int Jim_IntHashFunction(unsigned int key)
     return key;
 }
 
-/* Identity hash function for integer keys */
-unsigned int Jim_IdentityHashFunction(unsigned int key)
-{
-    return key;
-}
-
 /* Generic hash function (we are using to multiply by 9 and add the byte
  * as Tcl) */
 static unsigned int Jim_GenHashFunction(const unsigned char *buf, int len)
@@ -2040,16 +2034,6 @@ static void StringAppendString(Jim_Obj *objPtr, const char *str, int len)
     objPtr->length += len;
 }
 
-/* Low-level wrapper to append an object. */
-void StringAppendObj(Jim_Obj *objPtr, Jim_Obj *appendObjPtr)
-{
-    int len;
-    const char *str;
-
-    str = Jim_GetString(appendObjPtr, &len);
-    StringAppendString(objPtr, str, len);
-}
-
 /* Higher level API to append strings to objects. */
 void Jim_AppendString(Jim_Interp *interp, Jim_Obj *objPtr, const char *str,
         int len)
@@ -4029,14 +4013,6 @@ static unsigned int JimReferencesHTHashFunction(const void *key)
     return Jim_IntHashFunction(intValue);
 }
 
-unsigned int JimReferencesHTDoubleHashFunction(const void *key)
-{
-    /* Only the least significant bits are used. */
-    const jim_wide *widePtr = key;
-    unsigned int intValue = (unsigned int) *widePtr;
-    return intValue; /* identity function. */
-}
-
 static const void *JimReferencesHTKeyDup(void *privdata, const void *key)
 {
     void *copy = Jim_Alloc(sizeof(jim_wide));

commit cebd817cee515fda9d697c5c8d23992254805346
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Jun 18 11:39:43 2010 +0800

    helper/jim: review scope of symbols
    
    Add "static" qualifier to private functions.
    
    Function Jim_InterpolateTokens() is private, but has not
    been changed to "static".
    This function is called only once, so compiler inlines it.
    After inline, there is a warning for variable uninitialized.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/jim.c b/src/helper/jim.c
index e9a6ec5..91f1ea5 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -370,7 +370,7 @@ static int JimStringMatch(const char *pattern, int patternLen,
     return 0;
 }
 
-int JimStringCompare(const char *s1, int l1, const char *s2, int l2,
+static int JimStringCompare(const char *s1, int l1, const char *s2, int l2,
         int nocase)
 {
     unsigned char *u1 = (unsigned char*) s1, *u2 = (unsigned char*) s2;
@@ -397,7 +397,7 @@ int JimStringCompare(const char *s1, int l1, const char *s2, int l2,
 /* Search 's1' inside 's2', starting to search from char 'index' of 's2'.
  * The index of the first occurrence of s1 in s2 is returned.
  * If s1 is not found inside s2, -1 is returned. */
-int JimStringFirst(const char *s1, int l1, const char *s2, int l2, int index_t)
+static int JimStringFirst(const char *s1, int l1, const char *s2, int l2, int index_t)
 {
     int i;
 
@@ -412,13 +412,13 @@ int JimStringFirst(const char *s1, int l1, const char *s2, int l2, int index_t)
     return -1;
 }
 
-int Jim_WideToString(char *buf, jim_wide wideValue)
+static int Jim_WideToString(char *buf, jim_wide wideValue)
 {
     const char *fmt = "%" JIM_WIDE_MODIFIER;
     return sprintf(buf, fmt, wideValue);
 }
 
-int Jim_StringToWide(const char *str, jim_wide *widePtr, int base)
+static int Jim_StringToWide(const char *str, jim_wide *widePtr, int base)
 {
     char *endptr;
 
@@ -439,7 +439,7 @@ int Jim_StringToWide(const char *str, jim_wide *widePtr, int base)
     return JIM_OK;
 }
 
-int Jim_StringToIndex(const char *str, int *intPtr)
+static int Jim_StringToIndex(const char *str, int *intPtr)
 {
     char *endptr;
 
@@ -472,7 +472,7 @@ static int JimFormatReference(char *buf, Jim_Reference *refPtr, jim_wide id)
     return JIM_REFERENCE_SPACE;
 }
 
-int Jim_DoubleToString(char *buf, double doubleValue)
+static int Jim_DoubleToString(char *buf, double doubleValue)
 {
     char *s;
     int len;
@@ -496,7 +496,7 @@ int Jim_DoubleToString(char *buf, double doubleValue)
     return len;
 }
 
-int Jim_StringToDouble(const char *str, double *doublePtr)
+static int Jim_StringToDouble(const char *str, double *doublePtr)
 {
     char *endptr;
 
@@ -586,7 +586,7 @@ void Jim_Free(void *ptr) {
     free(ptr);
 }
 
-void *Jim_Realloc(void *ptr, int size)
+static void *Jim_Realloc(void *ptr, int size)
 {
 	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
 	if (size == 0)
@@ -606,7 +606,7 @@ char *Jim_StrDup(const char *s)
     return copy;
 }
 
-char *Jim_StrDupLen(const char *s, int l)
+static char *Jim_StrDupLen(const char *s, int l)
 {
     char *copy = Jim_Alloc(l + 1);
 
@@ -645,7 +645,7 @@ static int JimInsertHashEntry(Jim_HashTable *ht, const void *key);
 /* -------------------------- hash functions -------------------------------- */
 
 /* Thomas Wang's 32 bit Mix Function */
-unsigned int Jim_IntHashFunction(unsigned int key)
+static unsigned int Jim_IntHashFunction(unsigned int key)
 {
     key += ~(key << 15);
     key ^=  (key >> 10);
@@ -664,7 +664,7 @@ unsigned int Jim_IdentityHashFunction(unsigned int key)
 
 /* Generic hash function (we are using to multiply by 9 and add the byte
  * as Tcl) */
-unsigned int Jim_GenHashFunction(const unsigned char *buf, int len)
+static unsigned int Jim_GenHashFunction(const unsigned char *buf, int len)
 {
     unsigned int h = 0;
     while (len--)
@@ -1168,7 +1168,7 @@ static char *JimParserGetToken(struct JimParserCtx *pc,
 /* Initialize a parser context.
  * 'prg' is a pointer to the program text, linenr is the line
  * number of the first line contained in the program. */
-void JimParserInit(struct JimParserCtx *pc, const char *prg,
+static void JimParserInit(struct JimParserCtx *pc, const char *prg,
         int len, int linenr)
 {
     pc->prg = prg;
@@ -1706,7 +1706,7 @@ int Jim_ScriptIsComplete(const char *s, int len, char *stateCharPtr)
 static int JimParseListSep(struct JimParserCtx *pc);
 static int JimParseListStr(struct JimParserCtx *pc);
 
-int JimParseList(struct JimParserCtx *pc)
+static int JimParseList(struct JimParserCtx *pc)
 {
     if (pc->len == 0) {
         pc->tstart = pc->tend = pc->p;
@@ -2019,7 +2019,7 @@ Jim_Obj *Jim_NewStringObjNoAlloc(Jim_Interp *interp, char *s, int len)
 
 /* Low-level string append. Use it only against objects
  * of type "string". */
-void StringAppendString(Jim_Obj *objPtr, const char *str, int len)
+static void StringAppendString(Jim_Obj *objPtr, const char *str, int len)
 {
     int needlen;
 
@@ -2132,7 +2132,7 @@ int Jim_StringMatchObj(Jim_Obj *patternObjPtr, Jim_Obj *objPtr,
     return JimStringMatch(pattern, patternLen, string, stringLen, nocase);
 }
 
-int Jim_StringCompareObj(Jim_Obj *firstObjPtr,
+static int Jim_StringCompareObj(Jim_Obj *firstObjPtr,
         Jim_Obj *secondObjPtr, int nocase)
 {
     const char *s1, *s2;
@@ -2579,7 +2579,7 @@ int Jim_CompareStringImmediate(Jim_Interp *interp, Jim_Obj *objPtr,
     }
 }
 
-int qsortCompareStringPointers(const void *a, const void *b)
+static int qsortCompareStringPointers(const void *a, const void *b)
 {
     char * const *sa = (char * const *)a;
     char * const *sb = (char * const *)b;
@@ -3132,7 +3132,7 @@ int SetScriptFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
     return JIM_OK;
 }
 
-ScriptObj *Jim_GetScript(Jim_Interp *interp, Jim_Obj *objPtr)
+static ScriptObj *Jim_GetScript(Jim_Interp *interp, Jim_Obj *objPtr)
 {
     if (objPtr->typePtr != &scriptObjType) {
         SetScriptFromAny(interp, objPtr);
@@ -3899,7 +3899,7 @@ void DupDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr,
  * object that is *guaranteed* to be in the form VARNAME(INDEX).
  * The 'index' part is [subst]ituted, and is used to lookup a key inside
  * the [dict]ionary contained in variable VARNAME. */
-Jim_Obj *Jim_ExpandDictSugar(Jim_Interp *interp, Jim_Obj *objPtr)
+static Jim_Obj *Jim_ExpandDictSugar(Jim_Interp *interp, Jim_Obj *objPtr)
 {
     Jim_Obj *varObjPtr, *keyObjPtr, *dictObjPtr, *resObjPtr;
     Jim_Obj *substKeyObjPtr = NULL;
@@ -4021,7 +4021,7 @@ static void JimReferencesHTValDestructor(void *interp, void *val)
     Jim_Free(val);
 }
 
-unsigned int JimReferencesHTHashFunction(const void *key)
+static unsigned int JimReferencesHTHashFunction(const void *key)
 {
     /* Only the least significant bits are used. */
     const jim_wide *widePtr = key;
@@ -4037,7 +4037,7 @@ unsigned int JimReferencesHTDoubleHashFunction(const void *key)
     return intValue; /* identity function. */
 }
 
-const void *JimReferencesHTKeyDup(void *privdata, const void *key)
+static const void *JimReferencesHTKeyDup(void *privdata, const void *key)
 {
     void *copy = Jim_Alloc(sizeof(jim_wide));
     JIM_NOTUSED(privdata);
@@ -4046,7 +4046,7 @@ const void *JimReferencesHTKeyDup(void *privdata, const void *key)
     return copy;
 }
 
-int JimReferencesHTKeyCompare(void *privdata, const void *key1,
+static int JimReferencesHTKeyCompare(void *privdata, const void *key1,
         const void *key2)
 {
     JIM_NOTUSED(privdata);
@@ -4054,7 +4054,7 @@ int JimReferencesHTKeyCompare(void *privdata, const void *key1,
     return memcmp(key1, key2, sizeof(jim_wide)) == 0;
 }
 
-void JimReferencesHTKeyDestructor(void *privdata, const void *key)
+static void JimReferencesHTKeyDestructor(void *privdata, const void *key)
 {
     JIM_NOTUSED(privdata);
 
@@ -4106,7 +4106,7 @@ static int isrefchar(int c)
     return 0;
 }
 
-int SetReferenceFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
+static int SetReferenceFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
 {
     jim_wide wideValue;
     int i, len;
@@ -5106,7 +5106,7 @@ testbrace:
 
 /* Returns the malloc-ed representation of a string
  * using backslash to quote special chars. */
-char *BackslashQuoteString(const char *s, int len, int *qlenPtr)
+static char *BackslashQuoteString(const char *s, int len, int *qlenPtr)
 {
     char *q = Jim_Alloc(len*2 + 1), *p;
 
@@ -5357,7 +5357,7 @@ void ListAppendElement(Jim_Obj *listPtr, Jim_Obj *objPtr)
  *
  * NOTE: this function can be called only against objects
  * with internal type of List. */
-void ListInsertElements(Jim_Obj *listPtr, int index_t, int elemc,
+static void ListInsertElements(Jim_Obj *listPtr, int index_t, int elemc,
         Jim_Obj *const *elemVec)
 {
     int currentLen = listPtr->internalRep.listValue.len;
@@ -5384,7 +5384,7 @@ void ListInsertElements(Jim_Obj *listPtr, int index_t, int elemc,
 
 /* Appends every element of appendListPtr into listPtr.
  * Both have to be of the list type. */
-void ListAppendList(Jim_Obj *listPtr, Jim_Obj *appendListPtr)
+static void ListAppendList(Jim_Obj *listPtr, Jim_Obj *appendListPtr)
 {
     int i, oldLen = listPtr->internalRep.listValue.len;
     int appendLen = appendListPtr->internalRep.listValue.len;
@@ -5590,7 +5590,8 @@ Jim_Obj *Jim_ConcatObj(Jim_Interp *interp, int objc, Jim_Obj *const *objv)
 /* Returns a list composed of the elements in the specified range.
  * first and start are directly accepted as Jim_Objects and
  * processed for the end?-index? case. */
-Jim_Obj *Jim_ListRange(Jim_Interp *interp, Jim_Obj *listObjPtr, Jim_Obj *firstObjPtr, Jim_Obj *lastObjPtr)
+static Jim_Obj *Jim_ListRange(Jim_Interp *interp, Jim_Obj *listObjPtr,
+		Jim_Obj *firstObjPtr, Jim_Obj *lastObjPtr)
 {
     int first, last;
     int len, rangeLen;
@@ -5618,7 +5619,7 @@ static int SetDictFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
  *
  * Keys and Values are Jim objects. */
 
-unsigned int JimObjectHTHashFunction(const void *key)
+static unsigned int JimObjectHTHashFunction(const void *key)
 {
     const char *str;
     Jim_Obj *objPtr = (Jim_Obj*) key;
@@ -5629,7 +5630,7 @@ unsigned int JimObjectHTHashFunction(const void *key)
     return h;
 }
 
-int JimObjectHTKeyCompare(void *privdata, const void *key1, const void *key2)
+static int JimObjectHTKeyCompare(void *privdata, const void *key1, const void *key2)
 {
     JIM_NOTUSED(privdata);
 
@@ -5867,7 +5868,7 @@ static void DictAddElement(Jim_Interp *interp, Jim_Obj *objPtr,
 
 /* Add an element, higher-level interface for DictAddElement().
  * If valueObjPtr == NULL, the key is removed if it exists. */
-int Jim_DictAddElement(Jim_Interp *interp, Jim_Obj *objPtr,
+static int Jim_DictAddElement(Jim_Interp *interp, Jim_Obj *objPtr,
         Jim_Obj *keyObjPtr, Jim_Obj *valueObjPtr)
 {
     if (Jim_IsShared(objPtr))
@@ -6282,7 +6283,7 @@ static struct Jim_ExprOperator Jim_ExprOperators[] = {
 #define JIM_EXPR_OPERATORS_NUM \
     (sizeof(Jim_ExprOperators)/sizeof(struct Jim_ExprOperator))
 
-int JimParseExpression(struct JimParserCtx *pc)
+static int JimParseExpression(struct JimParserCtx *pc)
 {
     /* Discard spaces and quoted newline */
     while (*(pc->p) == ' ' ||
@@ -6430,7 +6431,7 @@ int JimParseExprOperator(struct JimParserCtx *pc)
     return JIM_OK;
 }
 
-struct Jim_ExprOperator *JimExprOperatorInfo(const char *opname)
+static struct Jim_ExprOperator *JimExprOperatorInfo(const char *opname)
 {
     int i;
     for (i = 0; i < (signed)JIM_EXPR_OPERATORS_NUM; i++)
@@ -6440,7 +6441,7 @@ struct Jim_ExprOperator *JimExprOperatorInfo(const char *opname)
     return NULL;
 }
 
-struct Jim_ExprOperator *JimExprOperatorInfoByOpcode(int opcode)
+static struct Jim_ExprOperator *JimExprOperatorInfoByOpcode(int opcode)
 {
     int i;
     for (i = 0; i < (signed)JIM_EXPR_OPERATORS_NUM; i++)
@@ -6840,7 +6841,7 @@ err:    /* we jump here on syntax/compile errors. */
     return JIM_ERR;
 }
 
-ExprByteCode *Jim_GetExpression(Jim_Interp *interp, Jim_Obj *objPtr)
+static ExprByteCode *Jim_GetExpression(Jim_Interp *interp, Jim_Obj *objPtr)
 {
     if (objPtr->typePtr != &exprObjType) {
         if (SetExprFromAny(interp, objPtr) != JIM_OK)
@@ -7917,7 +7918,7 @@ const char *dlerror(void)
 }
 #endif /* WIN32 */
 
-int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
+static int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
 {
     Jim_Obj *libPathObjPtr;
     int prefixc, i;
@@ -7992,7 +7993,7 @@ err:
     return JIM_ERR;
 }
 #else /* JIM_DYNLIB */
-int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
+static int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
 {
     JIM_NOTUSED(interp);
     JIM_NOTUSED(pathName);
@@ -8532,7 +8533,7 @@ err:
  * (and increments argc by reference accordingly), performing
  * expansion of the list object if 'expand' is non-zero, or
  * just adding objPtr to argv if 'expand' is zero. */
-void Jim_ExpandArgument(Jim_Interp *interp, Jim_Obj ***argv,
+static void Jim_ExpandArgument(Jim_Interp *interp, Jim_Obj ***argv,
         int *argcPtr, int expand, Jim_Obj *objPtr)
 {
     if (!expand) {
@@ -9086,7 +9087,7 @@ static Jim_ObjType substObjType = {
 /* This method takes the string representation of an object
  * as a Tcl string where to perform [subst]itution, and generates
  * the pre-parsed internal representation. */
-int SetSubstFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr, int flags)
+static int SetSubstFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr, int flags)
 {
     int scriptTextLen;
     const char *scriptText = Jim_GetString(objPtr, &scriptTextLen);
@@ -9120,7 +9121,7 @@ int SetSubstFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr, int flags)
     return JIM_OK;
 }
 
-ScriptObj *Jim_GetSubst(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
+static ScriptObj *Jim_GetSubst(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
 {
     struct ScriptObj *script = Jim_GetIntRepPtr(objPtr);
 

-----------------------------------------------------------------------

Summary of changes:
 src/helper/jim.c |  103 +++++++++++++++++++++---------------------------------
 1 files changed, 40 insertions(+), 63 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jun 18 08:05:47 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Jun 2010 06:05:47 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-353-g127f9da
Message-ID: <E1OPUi8-0006qT-QK@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  127f9da4fe0a3e2eaa86c5cd32bb45b6a7083171 (commit)
      from  c3ee63be77476af770134b39d31758eb6a0ef69f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 127f9da4fe0a3e2eaa86c5cd32bb45b6a7083171
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Fri Jun 18 00:48:47 2010 +0200

    don't add confusing source info to Jim
    
    When an interactive command fails, the Jim stack trace prints references to
    the line in "command.c" where the interpreter was invoked. Since that
    location has no relation to the actual command that failed, the information
    serves only to add confusion.
    
    By not adding the useless source info to Jim the noise can be reduced,
    while still printing a useful trace for nested commands.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.c b/src/helper/command.c
index be262f2..ea768b2 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -362,7 +362,7 @@ static int register_command_handler(struct command_context *cmd_ctx,
 	if (NULL == override_name)
 		return JIM_ERR;
 
-	retval = Jim_Eval_Named(interp, override_name, __THIS__FILE__ , __LINE__);
+	retval = Jim_Eval_Named(interp, override_name, 0, 0);
 	free((void *)override_name);
 
 	return retval;
@@ -651,7 +651,7 @@ int command_run_line(struct command_context *context, char *line)
 		retcode = Jim_SetAssocData(interp, "retval", NULL, &retval);
 		if (retcode == JIM_OK)
 		{
-			retcode = Jim_Eval_Named(interp, line, __THIS__FILE__, __LINE__);
+			retcode = Jim_Eval_Named(interp, line, 0, 0);
 
 			Jim_DeleteAssocData(interp, "retval");
 		}

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jun 18 09:53:28 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Jun 2010 07:53:28 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-354-g3f9d377
Message-ID: <E1OPWOI-0004Jm-8z@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3f9d377ce788365844f9225064cb9b0f0b4542ef (commit)
      from  127f9da4fe0a3e2eaa86c5cd32bb45b6a7083171 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3f9d377ce788365844f9225064cb9b0f0b4542ef
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Fri Jun 18 01:33:22 2010 +0200

    reverse order of Jim stack trace output
    
    The stack traces makes much more sense this way.
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/helper/jim.c b/src/helper/jim.c
index 7fdf52c..071e557 100644
--- a/src/helper/jim.c
+++ b/src/helper/jim.c
@@ -12291,7 +12291,7 @@ void Jim_PrintErrorMessage(Jim_Interp *interp)
     Jim_fprintf(interp,interp->cookie_stderr, "%s" JIM_NL,
             Jim_GetString(interp->result, NULL));
     Jim_ListLength(interp, interp->stackTrace, &len);
-    for (i = len-3; i >= 0; i-= 3) {
+    for (i = 0; i < len; i += 3) {
         Jim_Obj *objPtr=NULL;
         const char *proc, *file, *line;
 

-----------------------------------------------------------------------

Summary of changes:
 src/helper/jim.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jun 18 10:03:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 18 Jun 2010 08:03:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-356-gb8f8d75
Message-ID: <E1OPWY4-00022X-3r@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b8f8d756a255936ccfb60ac3dda076e4e06108a6 (commit)
       via  2319caff7d9ddf27311a9d592f6d143d71cd5602 (commit)
      from  3f9d377ce788365844f9225064cb9b0f0b4542ef (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b8f8d756a255936ccfb60ac3dda076e4e06108a6
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Jun 18 14:30:26 2010 +0800

    target/dsp563xx: review unused symbols
    
    Remove unused functions:
    - dsp563xx_jtag_senddat
    - dsp563xx_write_ir_u16
    - dsp563xx_write_dr_u16
    - dsp563xx_write_ir_u32
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 48e559e..a454c76 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -51,8 +51,6 @@ static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t i
 
 /* IR and DR functions */
 static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out);
-int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
-			  int len);
 
 #define ASM_REG_R_R0	0x607000
 #define ASM_REG_R_R1	0x617000
@@ -819,12 +817,6 @@ static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint
 	return ERROR_OK;
 }
 
-int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
-			  int len)
-{
-	return dsp563xx_write_dr_u32(tap, dr_in, dr_out, len, 1);
-}
-
 static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
 {
 	return dsp563xx_write_ir_u8(tap, ir_in, ir_out, DSP563XX_JTAG_INS_LEN, 1);
@@ -896,48 +888,6 @@ int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * dr_in, uint8_t dr_out,
 	return ERROR_OK;
 }
 
-int dsp563xx_write_ir_u16(struct jtag_tap *tap, uint16_t * ir_in, uint16_t ir_out,
-			  int ir_len, int rti)
-{
-	if (ir_len > 16)
-	{
-		LOG_ERROR("ir_len overflow, maxium is 16");
-		return ERROR_FAIL;
-	}
-
-	dsp563xx_write_ir(tap, (uint8_t *) ir_in, (uint8_t *) & ir_out, ir_len, rti);
-
-	return ERROR_OK;
-}
-
-int dsp563xx_write_dr_u16(struct jtag_tap *tap, uint16_t * dr_in, uint16_t dr_out,
-			  int dr_len, int rti)
-{
-	if (dr_len > 16)
-	{
-		LOG_ERROR("dr_len overflow, maxium is 16");
-		return ERROR_FAIL;
-	}
-
-	dsp563xx_write_dr(tap, (uint8_t *) dr_in, (uint8_t *) & dr_out, dr_len, rti);
-
-	return ERROR_OK;
-}
-
-int dsp563xx_write_ir_u32(struct jtag_tap *tap, uint32_t * ir_in, uint32_t ir_out,
-			  int ir_len, int rti)
-{
-	if (ir_len > 32)
-	{
-		LOG_ERROR("ir_len overflow, maxium is 32");
-		return ERROR_FAIL;
-	}
-
-	dsp563xx_write_ir(tap, (uint8_t *) ir_in, (uint8_t *) & ir_out, ir_len, rti);
-
-	return ERROR_OK;
-}
-
 int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
 			  int dr_len, int rti)
 {
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
index 3258faa..f8070fa 100644
--- a/src/target/dsp563xx.h
+++ b/src/target/dsp563xx.h
@@ -68,12 +68,6 @@ static inline struct dsp563xx_common *target_to_dsp563xx(struct target *target)
 
 int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
 			 int dr_len, int rti);
-int dsp563xx_write_ir_u16(struct jtag_tap *tap, uint16_t * ir_in, uint16_t ir_out,
-			  int ir_len, int rti);
-int dsp563xx_write_dr_u16(struct jtag_tap *tap, uint16_t * ir_in, uint16_t ir_out,
-			  int dr_len, int rti);
-int dsp563xx_write_ir_u32(struct jtag_tap *tap, uint32_t * ir_in, uint32_t ir_out,
-			  int ir_len, int rti);
 int dsp563xx_write_dr_u32(struct jtag_tap *tap, uint32_t * ir_in, uint32_t ir_out,
 			  int dr_len, int rti);
 

commit 2319caff7d9ddf27311a9d592f6d143d71cd5602
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Jun 18 14:28:01 2010 +0800

    target/dsp563xx: review scope of symbols
    
    Add "static" qualifier to private functions.
    Remove private prototypes from include file.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index b42e7b3..48e559e 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -46,31 +46,14 @@
 #define JTAG_INSTR_BYPASS		0x0F
 
 /* forward declarations */
-int dsp563xx_target_create(struct target *target, Jim_Interp * interp);
-int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target);
-
-int dsp563xx_arch_state(struct target *target);
-int dsp563xx_poll(struct target *target);
-int dsp563xx_halt(struct target *target);
-int dsp563xx_resume(struct target *target, int current, uint32_t address,
-		    int handle_breakpoints, int debug_execution);
-int dsp563xx_step(struct target *target, int current, uint32_t address,
-		  int handle_breakpoints);
-
-int dsp563xx_assert_reset(struct target *target);
-int dsp563xx_deassert_reset(struct target *target);
-int dsp563xx_soft_reset_halt(struct target *target);
+static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
+		int ir_len, int rti);
 
 /* IR and DR functions */
-int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out);
+static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out);
 int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_out,
 			  int len);
 
-int dsp563xx_read_memory_p(struct target *target, uint32_t address, uint32_t size,
-			   uint32_t count, uint8_t * buffer);
-int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size,
-			    uint32_t count, uint8_t * buffer);
-
 #define ASM_REG_R_R0	0x607000
 #define ASM_REG_R_R1	0x617000
 #define ASM_REG_R_R2	0x627000
@@ -269,7 +252,7 @@ static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_lis
 
 }
 
-int dsp563xx_read_core_reg(struct target *target, int num)
+static int dsp563xx_read_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
 	struct dsp563xx_core_reg *dsp563xx_core_reg;
@@ -287,7 +270,7 @@ int dsp563xx_read_core_reg(struct target *target, int num)
 	return ERROR_OK;
 }
 
-int dsp563xx_write_core_reg(struct target *target, int num)
+static int dsp563xx_write_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
 	struct dsp563xx_core_reg *dsp563xx_core_reg;
@@ -305,7 +288,7 @@ int dsp563xx_write_core_reg(struct target *target, int num)
 	return ERROR_OK;
 }
 
-int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
+static int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
 {
 	struct dsp563xx_common *dsp563xx = calloc(1, sizeof(struct dsp563xx_common));
 
@@ -317,7 +300,7 @@ int dsp563xx_target_create(struct target *target, Jim_Interp * interp)
 	return ERROR_OK;
 }
 
-int dsp563xx_get_core_reg(struct reg *reg)
+static int dsp563xx_get_core_reg(struct reg *reg)
 {
 	int retval = 0;
 
@@ -337,7 +320,7 @@ int dsp563xx_get_core_reg(struct reg *reg)
 	return retval;
 }
 
-int dsp563xx_set_core_reg(struct reg *reg, uint8_t * buf)
+static int dsp563xx_set_core_reg(struct reg *reg, uint8_t * buf)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 
@@ -357,7 +340,7 @@ int dsp563xx_set_core_reg(struct reg *reg, uint8_t * buf)
 	return ERROR_OK;
 }
 
-int dsp563xx_save_context(struct target *target)
+static int dsp563xx_save_context(struct target *target)
 {
 	int i;
 	uint32_t data = 0;
@@ -388,7 +371,7 @@ int dsp563xx_save_context(struct target *target)
 	return ERROR_OK;
 }
 
-int dsp563xx_restore_context(struct target *target)
+static int dsp563xx_restore_context(struct target *target)
 {
 	int i;
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
@@ -416,7 +399,7 @@ static const struct reg_arch_type dsp563xx_reg_type = {
 	.set = dsp563xx_set_core_reg,
 };
 
-int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target)
+static int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target)
 {
 	/* get pointers to arch-specific information */
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
@@ -459,13 +442,13 @@ int dsp563xx_init_target(struct command_context *cmd_ctx, struct target *target)
 	return ERROR_OK;
 }
 
-int dsp563xx_arch_state(struct target *target)
+static int dsp563xx_arch_state(struct target *target)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
 }
 
-int dsp563xx_jtag_status(struct target *target, uint8_t * status)
+static int dsp563xx_jtag_status(struct target *target, uint8_t * status)
 {
 	uint8_t ir_in;
 
@@ -479,7 +462,7 @@ int dsp563xx_jtag_status(struct target *target, uint8_t * status)
 	return ERROR_OK;
 }
 
-int dsp563xx_jtag_debug_request(struct target *target)
+static int dsp563xx_jtag_debug_request(struct target *target)
 {
 	uint8_t ir_in = 0;
 	uint32_t retry = 0;
@@ -506,7 +489,7 @@ int dsp563xx_jtag_debug_request(struct target *target)
 	return ERROR_OK;
 }
 
-int dsp563xx_poll(struct target *target)
+static int dsp563xx_poll(struct target *target)
 {
 	uint8_t jtag_status;
 	uint32_t once_status;
@@ -537,7 +520,7 @@ int dsp563xx_poll(struct target *target)
 	return ERROR_OK;
 }
 
-int dsp563xx_halt(struct target *target)
+static int dsp563xx_halt(struct target *target)
 {
 	uint8_t jtag_status;
 	uint32_t once_status;
@@ -582,7 +565,7 @@ int dsp563xx_halt(struct target *target)
 
 #define DSP563XX_ASM_CMD_JUMP	0x0AF080
 
-int dsp563xx_resume(struct target *target, int current, uint32_t address,
+static int dsp563xx_resume(struct target *target, int current, uint32_t address,
 		    int handle_breakpoints, int debug_execution)
 {
 	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
@@ -616,7 +599,7 @@ int dsp563xx_resume(struct target *target, int current, uint32_t address,
 	return ERROR_OK;
 }
 
-int dsp563xx_step(struct target *target, int current, uint32_t address,
+static int dsp563xx_step(struct target *target, int current, uint32_t address,
 		  int handle_breakpoints)
 {
 	uint32_t once_status;
@@ -708,7 +691,7 @@ int dsp563xx_step(struct target *target, int current, uint32_t address,
 	return ERROR_OK;
 }
 
-int dsp563xx_assert_reset(struct target *target)
+static int dsp563xx_assert_reset(struct target *target)
 {
 	target->state = TARGET_RESET;
 
@@ -716,7 +699,7 @@ int dsp563xx_assert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-int dsp563xx_deassert_reset(struct target *target)
+static int dsp563xx_deassert_reset(struct target *target)
 {
 	target->state = TARGET_RUNNING;
 
@@ -724,7 +707,7 @@ int dsp563xx_deassert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-int dsp563xx_soft_reset_halt(struct target *target)
+static int dsp563xx_soft_reset_halt(struct target *target)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
@@ -752,7 +735,7 @@ int dsp563xx_soft_reset_halt(struct target *target)
 * 076190		movem             r0,p:(r1)
 *
 */
-int dsp563xx_read_memory_p(struct target *target, uint32_t address,
+static int dsp563xx_read_memory_p(struct target *target, uint32_t address,
 			   uint32_t size, uint32_t count, uint8_t * buffer)
 {
 	uint32_t i, x;
@@ -793,7 +776,7 @@ int dsp563xx_read_memory_p(struct target *target, uint32_t address,
 	return ERROR_OK;
 }
 
-int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size,
+static int dsp563xx_write_memory_p(struct target *target, uint32_t address, uint32_t size,
 			    uint32_t count, uint8_t * buffer)
 {
 	uint32_t i, x;
@@ -842,13 +825,13 @@ int dsp563xx_jtag_senddat(struct jtag_tap *tap, uint32_t * dr_in, uint32_t dr_ou
 	return dsp563xx_write_dr_u32(tap, dr_in, dr_out, len, 1);
 }
 
-int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
+static int dsp563xx_jtag_sendinstr(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out)
 {
 	return dsp563xx_write_ir_u8(tap, ir_in, ir_out, DSP563XX_JTAG_INS_LEN, 1);
 }
 
 /* IR and DR functions */
-int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
+static int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
 		      int ir_len, int rti)
 {
 	if (NULL == tap)
@@ -869,7 +852,7 @@ int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
 	return ERROR_OK;
 }
 
-int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
+static int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
 		      int dr_len, int rti)
 {
 	if (NULL == tap)
@@ -885,7 +868,7 @@ int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
 	return ERROR_OK;
 }
 
-int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
+static int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
 			 int ir_len, int rti)
 {
 	if (ir_len > 8)
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
index 73050b6..3258faa 100644
--- a/src/target/dsp563xx.h
+++ b/src/target/dsp563xx.h
@@ -66,12 +66,6 @@ static inline struct dsp563xx_common *target_to_dsp563xx(struct target *target)
 	return target->arch_info;
 }
 
-int dsp563xx_write_ir(struct jtag_tap *tap, uint8_t * ir_in, uint8_t * ir_out,
-		      int ir_len, int rti);
-int dsp563xx_write_dr(struct jtag_tap *tap, uint8_t * dr_in, uint8_t * dr_out,
-		      int dr_len, int rti);
-int dsp563xx_write_ir_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
-			 int ir_len, int rti);
 int dsp563xx_write_dr_u8(struct jtag_tap *tap, uint8_t * ir_in, uint8_t ir_out,
 			 int dr_len, int rti);
 int dsp563xx_write_ir_u16(struct jtag_tap *tap, uint16_t * ir_in, uint16_t ir_out,

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c |  121 +++++++++++--------------------------------------
 src/target/dsp563xx.h |   12 -----
 2 files changed, 27 insertions(+), 106 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Jun 19 09:27:44 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 19 Jun 2010 07:27:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-357-g2a25c96
Message-ID: <E1OPsSw-0005Us-BY@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2a25c968bf4ffec39ee76da0a164e46bd4215134 (commit)
      from  b8f8d756a255936ccfb60ac3dda076e4e06108a6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2a25c968bf4ffec39ee76da0a164e46bd4215134
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Jun 18 15:35:52 2010 +0200

    cortex a8: fix segfault for unexamined targets
    
    print error message instead of segfaulting for
    unexamined targets.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 4ee36ff..92469eb 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -232,6 +232,7 @@ struct dap_ops {
 static inline int dap_queue_idcode_read(struct adiv5_dap *dap,
 		uint8_t *ack, uint32_t *data)
 {
+	assert(dap->ops != NULL);
 	return dap->ops->queue_idcode_read(dap, ack, data);
 }
 
@@ -250,6 +251,7 @@ static inline int dap_queue_idcode_read(struct adiv5_dap *dap,
 static inline int dap_queue_dp_read(struct adiv5_dap *dap,
 		unsigned reg, uint32_t *data)
 {
+	assert(dap->ops != NULL);
 	return dap->ops->queue_dp_read(dap, reg, data);
 }
 
@@ -267,6 +269,7 @@ static inline int dap_queue_dp_read(struct adiv5_dap *dap,
 static inline int dap_queue_dp_write(struct adiv5_dap *dap,
 		unsigned reg, uint32_t data)
 {
+	assert(dap->ops != NULL);
 	return dap->ops->queue_dp_write(dap, reg, data);
 }
 
@@ -283,6 +286,7 @@ static inline int dap_queue_dp_write(struct adiv5_dap *dap,
 static inline int dap_queue_ap_read(struct adiv5_dap *dap,
 		unsigned reg, uint32_t *data)
 {
+	assert(dap->ops != NULL);
 	return dap->ops->queue_ap_read(dap, reg, data);
 }
 
@@ -298,6 +302,7 @@ static inline int dap_queue_ap_read(struct adiv5_dap *dap,
 static inline int dap_queue_ap_write(struct adiv5_dap *dap,
 		unsigned reg, uint32_t data)
 {
+	assert(dap->ops != NULL);
 	return dap->ops->queue_ap_write(dap, reg, data);
 }
 
@@ -314,6 +319,7 @@ static inline int dap_queue_ap_write(struct adiv5_dap *dap,
  */
 static inline int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
+	assert(dap->ops != NULL);
 	return dap->ops->queue_ap_abort(dap, ack);
 }
 
@@ -329,6 +335,7 @@ static inline int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
  */
 static inline int dap_run(struct adiv5_dap *dap)
 {
+	assert(dap->ops != NULL);
 	return dap->ops->run(dap);
 }
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 0b12abe..cfec48b 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1839,10 +1839,13 @@ COMMAND_HANDLER(cortex_a8_handle_cache_info_command)
 COMMAND_HANDLER(cortex_a8_handle_dbginit_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
+	if (!target_was_examined(target))
+	{
+		LOG_ERROR("target not examined yet");
+		return ERROR_FAIL;
+	}
 
-	cortex_a8_init_debug_access(target);
-
-	return ERROR_OK;
+	return cortex_a8_init_debug_access(target);
 }
 
 static const struct command_registration cortex_a8_exec_command_handlers[] = {

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.h |    7 +++++++
 src/target/cortex_a8.c  |    9 ++++++---
 2 files changed, 13 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat Jun 19 11:37:39 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 19 Jun 2010 09:37:39 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-358-gacee9d1
Message-ID: <E1OPuUl-0004nr-1H@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  acee9d1c65bd97bbd5aa2b633e2455e87edbe836 (commit)
      from  2a25c968bf4ffec39ee76da0a164e46bd4215134 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit acee9d1c65bd97bbd5aa2b633e2455e87edbe836
Author: Andreas Fritiofson <andreas.fritiofson at gmail.com>
Date:   Sat Jun 19 11:12:12 2010 +0200

    arm-jtag-ew: -Wshadow fix
    
    declaration of ???index??? shadows a global declaration
    in /usr/include/string.h
    
    Signed-off-by: Andreas Fritiofson <andreas.fritiofson at gmail.com>

diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
index 7a6c178..72c756e 100644
--- a/src/jtag/drivers/arm-jtag-ew.c
+++ b/src/jtag/drivers/arm-jtag-ew.c
@@ -568,29 +568,29 @@ static void armjtagew_tap_ensure_space(int scans, int bits)
 static void armjtagew_tap_append_step(int tms, int tdi)
 {
 	last_tms = tms;
-	int index = tap_length / 8;
+	int index_local = tap_length / 8;
 
-	if (index < ARMJTAGEW_TAP_BUFFER_SIZE)
+	if (index_local < ARMJTAGEW_TAP_BUFFER_SIZE)
 	{
 		int bit_index = tap_length % 8;
 		uint8_t bit = 1 << bit_index;
 
 		if (tms)
 		{
-			tms_buffer[index] |= bit;
+			tms_buffer[index_local] |= bit;
 		}
 		else
 		{
-			tms_buffer[index] &= ~bit;
+			tms_buffer[index_local] &= ~bit;
 		}
 
 		if (tdi)
 		{
-			tdi_buffer[index] |= bit;
+			tdi_buffer[index_local] |= bit;
 		}
 		else
 		{
-			tdi_buffer[index] &= ~bit;
+			tdi_buffer[index_local] &= ~bit;
 		}
 
 		tap_length++;

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/arm-jtag-ew.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 21 10:49:38 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 21 Jun 2010 08:49:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-360-g7013b96
Message-ID: <E1OQchM-0007zd-ET@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7013b960feeb0d4ab3aeae40d5ac17dda6d79a3a (commit)
       via  8d1dcb9bcde55ff29c1967d86c5f8985620df923 (commit)
      from  acee9d1c65bd97bbd5aa2b633e2455e87edbe836 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7013b960feeb0d4ab3aeae40d5ac17dda6d79a3a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 09:02:53 2010 +0200

    adi_v5_jtag: add missing error handling
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index b368708..44f624f 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -259,7 +259,11 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
 		/* Check power to debug regions */
 		if ((ctrlstat & 0xf0000000) != 0xf0000000)
-			 ahbap_debugport_init(dap);
+		{
+			retval = ahbap_debugport_init(dap);
+			if (retval != ERROR_OK)
+				return retval;
+		}
 		else
 		{
 			uint32_t mem_ap_csw, mem_ap_tar;

commit 8d1dcb9bcde55ff29c1967d86c5f8985620df923
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 09:02:02 2010 +0200

    cortex a8: add missing error handling
    
    cortex examine was missing error handling.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index cfec48b..933b42e 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1523,8 +1523,14 @@ static int cortex_a8_examine_first(struct target *target)
 	/* We do one extra read to ensure DAP is configured,
 	 * we call ahbap_debugport_init(swjdp) instead
 	 */
-	ahbap_debugport_init(swjdp);
-	mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	retval = ahbap_debugport_init(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	if (retval != ERROR_OK)
+		return retval;
+
 	if ((retval = mem_ap_read_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_CPUID, &cpuid)) != ERROR_OK)
 	{
@@ -1559,7 +1565,9 @@ static int cortex_a8_examine_first(struct target *target)
 	LOG_DEBUG("didr = 0x%08" PRIx32, didr);
 
 	armv7a->armv4_5_common.core_type = ARM_MODE_MON;
-	cortex_a8_dpm_setup(cortex_a8, didr);
+	retval = cortex_a8_dpm_setup(cortex_a8, didr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Setup Breakpoint Register Pairs */
 	cortex_a8->brp_num = ((didr >> 24) & 0x0F) + 1;

-----------------------------------------------------------------------

Summary of changes:
 src/target/adi_v5_jtag.c |    6 +++++-
 src/target/cortex_a8.c   |   14 +++++++++++---
 2 files changed, 16 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 21 15:03:19 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 21 Jun 2010 13:03:19 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-362-g2fbb0b5
Message-ID: <E1OQger-0005L7-4v@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2fbb0b5972b04e10090e39137817e9f359fb6105 (commit)
       via  dcba0709580cd8b0d2869894d2f7e22195b7e3d7 (commit)
      from  7013b960feeb0d4ab3aeae40d5ac17dda6d79a3a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2fbb0b5972b04e10090e39137817e9f359fb6105
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 13:32:16 2010 +0200

    jtag: retire jtag_get_error()
    
    This fn is an implementation detail of jtag_execute_queue()
    that is not to be exposed externally.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 65ca824..782f10f 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -52,9 +52,9 @@ static void jtag_add_scan_check(struct jtag_tap *active,
  * when an error occurs during processing that should be reported during
  * jtag_execute_queue().
  *
- * Tts value may be checked with jtag_get_error() and cleared with
- * jtag_error_clear().  This value is returned (and cleared) by
- * jtag_execute_queue().
+ * The value is set and cleared, but never read by normal application code.
+ *
+ * This value is returned (and cleared) by jtag_execute_queue().
  */
 static int jtag_error = ERROR_OK;
 
@@ -131,10 +131,7 @@ void jtag_set_error(int error)
 		return;
 	jtag_error = error;
 }
-int jtag_get_error(void)
-{
-	return jtag_error;
-}
+
 int jtag_error_clear(void)
 {
 	int temp = jtag_error;
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index cdc02ab..97ceb01 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -661,8 +661,6 @@ void jtag_sleep(uint32_t us);
  * called with a non-zero error code.
  */
 void jtag_set_error(int error);
-/// @returns The current value of jtag_error
-int jtag_get_error(void);
 /**
  * Resets jtag_error to ERROR_OK, returning its previous value.
  * @returns The previous value of @c jtag_error.

commit dcba0709580cd8b0d2869894d2f7e22195b7e3d7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 13:25:06 2010 +0200

    jtag: do not use jtag_get_error()
    
    normal code should not call jtag_get_error(), but rather check
    the return code from jtag_execute_queue().
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 44f624f..0a374be 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -120,7 +120,7 @@ int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		jtag_add_runtest(dap->memaccess_tck,
 				TAP_IDLE);
 
-	return jtag_get_error();
+	return ERROR_OK;
 }
 
 /**
@@ -343,14 +343,11 @@ static int jtag_idcode_q_read(struct adiv5_dap *dap,
 	fields[0].in_value = (void *) data;
 
 	jtag_add_dr_scan(jtag_info->tap, 1, fields, TAP_IDLE);
-	retval = jtag_get_error();
-	if (retval != ERROR_OK)
-		return retval;
 
 	jtag_add_callback(arm_le_to_h_u32,
 			(jtag_callback_data_t) data);
 
-	return retval;
+	return ERROR_OK;
 }
 
 static int jtag_dp_q_read(struct adiv5_dap *dap, unsigned reg,
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index 51d0e7b..f4d09ff 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -331,7 +331,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 				else
 					jtag_add_pathmove(pathlen, path);
 
-				result = jtag_get_error();
+				result = jtag_execute_queue();
 				if (result != ERROR_OK) {
 					LOG_ERROR("XSVF: pathmove error %d",
 							result);

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c          |   11 ++++-------
 src/jtag/jtag.h          |    2 --
 src/target/adi_v5_jtag.c |    7 ++-----
 src/xsvf/xsvf.c          |    2 +-
 4 files changed, 7 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Jun 21 16:56:13 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 21 Jun 2010 14:56:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-373-gf747b16
Message-ID: <E1OQiQ3-0003BL-9F@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f747b16e4e14f25f19e391b4811db9fa70be919a (commit)
       via  9b5572857a3e42e0984b0daa3c478561337a0451 (commit)
       via  bc7fa896e69d5a325776da4e5b423940cb1124dd (commit)
       via  190986eb8c6967cebafe0b415733c72305489f76 (commit)
       via  ff1c09fbeabc568c7cd6e29b4681e15e5d0d184c (commit)
       via  decd417064b63c8eda69ad523a63fefd22036d16 (commit)
       via  d26b5236bac524ca33799f2c10f40f65755bdd08 (commit)
       via  3f59fcf77e5eb1d8c504a337b05bb1a5797e656f (commit)
       via  b978dcbbee628ed30286b90cecf7085eb2cb7a82 (commit)
       via  3cfbf705597732c7b6a5b11a556c818529ea725b (commit)
       via  ec073e89435785375dece2fb7c4664002c22859c (commit)
      from  2fbb0b5972b04e10090e39137817e9f359fb6105 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f747b16e4e14f25f19e391b4811db9fa70be919a
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 18:40:02 2010 +0800

    nand/mx2: review scope of symbols
    
    Add "static" qualifier to private variable.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nand/mx2.c b/src/flash/nand/mx2.c
index 83e1cb1..147546d 100644
--- a/src/flash/nand/mx2.c
+++ b/src/flash/nand/mx2.c
@@ -61,7 +61,7 @@ static const char sram_buffer_bounds_err_msg[] =
 	"trying to access out of SRAM buffer bound (addr=0x%" PRIx32 ")";
 static const char get_status_register_err_msg[] = "can't get NAND status";
 static uint32_t in_sram_address;
-unsigned char sign_of_sequental_byte_read;
+static unsigned char sign_of_sequental_byte_read;
 
 static int initialize_nf_controller(struct nand_device *nand);
 static int get_next_byte_from_sram_buffer(struct target * target, uint8_t * value);

commit 9b5572857a3e42e0984b0daa3c478561337a0451
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 17:44:24 2010 +0800

    nor/str7x: review scope of symbols
    
    Add "static" qualifier to private function.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 4c450af..069e90c 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -394,7 +394,7 @@ static int str7x_protect(struct flash_bank *bank, int set, int first, int last)
 	return ERROR_OK;
 }
 
-int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
+static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		uint32_t offset, uint32_t count)
 {
 	struct str7x_flash_bank *str7x_info = bank->driver_priv;

commit bc7fa896e69d5a325776da4e5b423940cb1124dd
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 17:40:28 2010 +0800

    openocd.c: review scope of symbols
    
    Add "static" qualifier to private data.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/openocd.c b/src/openocd.c
index 81c2dcd..623bd0c 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -210,7 +210,7 @@ static int openocd_register_commands(struct command_context *cmd_ctx)
 struct command_context *global_cmd_ctx;
 
 /* NB! this fn can be invoked outside this file for non PC hosted builds */
-struct command_context *setup_command_handler(Jim_Interp *interp)
+static struct command_context *setup_command_handler(Jim_Interp *interp)
 {
 	log_init();
 	LOG_DEBUG("log_init: complete");

commit 190986eb8c6967cebafe0b415733c72305489f76
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 17:38:19 2010 +0800

    nor/virtual: review scope of symbols
    
    Add "static" qualifier to private functions.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/virtual.c b/src/flash/nor/virtual.c
index eb1885e..e91dfc7 100644
--- a/src/flash/nor/virtual.c
+++ b/src/flash/nor/virtual.c
@@ -195,7 +195,7 @@ static int virtual_info(struct flash_bank *bank, char *buf, int buf_size)
 	return ERROR_OK;
 }
 
-int virtual_blank_check(struct flash_bank *bank)
+static int virtual_blank_check(struct flash_bank *bank)
 {
 	struct flash_bank *master_bank = virtual_get_master_bank(bank);
 	int retval;
@@ -211,7 +211,7 @@ int virtual_blank_check(struct flash_bank *bank)
 	return ERROR_OK;
 }
 
-int virtual_flash_read(struct flash_bank *bank,
+static int virtual_flash_read(struct flash_bank *bank,
 		uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	struct flash_bank *master_bank = virtual_get_master_bank(bank);

commit ff1c09fbeabc568c7cd6e29b4681e15e5d0d184c
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 13:05:56 2010 +0800

    target/avrt: review unused symbols
    
    Remove unused functions:
    - mcu_write_dr_u16
    - mcu_write_dr_u8
    - mcu_write_ir_u16
    - mcu_write_ir_u32
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/avrt.c b/src/target/avrt.c
index 3861199..1ddf24d 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -46,10 +46,6 @@ static int avr_soft_reset_halt(struct target *target);
 static int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
 static int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti);
 static int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti);
-int mcu_write_dr_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int dr_len, int rti);
-int mcu_write_ir_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti);
-int mcu_write_dr_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int dr_len, int rti);
-int mcu_write_ir_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti);
 static int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
 
 struct target_type avr_target =
@@ -225,58 +221,6 @@ static int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in,
 	return ERROR_OK;
 }
 
-int mcu_write_dr_u8(struct jtag_tap *tap, uint8_t *dr_in, uint8_t dr_out, int dr_len, int rti)
-{
-	if (dr_len > 8)
-	{
-		LOG_ERROR("dr_len overflow, maxium is 8");
-		return ERROR_FAIL;
-	}
-
-	mcu_write_dr(tap, dr_in, &dr_out, dr_len, rti);
-
-	return ERROR_OK;
-}
-
-int mcu_write_ir_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti)
-{
-	if (ir_len > 16)
-	{
-		LOG_ERROR("ir_len overflow, maxium is 16");
-		return ERROR_FAIL;
-	}
-
-	mcu_write_ir(tap, (uint8_t*)ir_in, (uint8_t*)&ir_out, ir_len, rti);
-
-	return ERROR_OK;
-}
-
-int mcu_write_dr_u16(struct jtag_tap *tap, uint16_t *dr_in, uint16_t dr_out, int dr_len, int rti)
-{
-	if (dr_len > 16)
-	{
-		LOG_ERROR("dr_len overflow, maxium is 16");
-		return ERROR_FAIL;
-	}
-
-	mcu_write_dr(tap, (uint8_t*)dr_in, (uint8_t*)&dr_out, dr_len, rti);
-
-	return ERROR_OK;
-}
-
-int mcu_write_ir_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti)
-{
-	if (ir_len > 32)
-	{
-		LOG_ERROR("ir_len overflow, maxium is 32");
-		return ERROR_FAIL;
-	}
-
-	mcu_write_ir(tap, (uint8_t*)ir_in, (uint8_t*)&ir_out, ir_len, rti);
-
-	return ERROR_OK;
-}
-
 static int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *dr_in,
 		uint32_t dr_out, int dr_len, int rti)
 {

commit decd417064b63c8eda69ad523a63fefd22036d16
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 12:52:07 2010 +0800

    target/avr: review scope of symbols
    
    Add "static" qualifier to private functions.
    Move duplicated global declarations from "target/avrt.c"
    and "nor/avrf.c" to "target/avrt.h".
    Remove unused declarations form "nor/avrf.c".
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index 8472d83..4dc7c23 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -59,19 +59,6 @@ static struct avrf_type avft_chips_info[] =
 	{"at90can128",	0x9781, 256, 512, 8, 512},
 };
 
-int avr_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out);
-int avr_jtag_senddat(struct jtag_tap *tap, uint32_t *dr_in, uint32_t dr_out, int len);
-
-int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
-int mcu_write_dr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int dr_len, int rti);
-int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti);
-int mcu_write_dr_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int dr_len, int rti);
-int mcu_write_ir_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti);
-int mcu_write_dr_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int dr_len, int rti);
-int mcu_write_ir_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti);
-int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
-int mcu_execute_queue(void);
-
 /* avr program functions */
 static int avr_jtag_reset(struct avr_common *avr, uint32_t reset)
 {
diff --git a/src/target/avrt.c b/src/target/avrt.c
index 17f7c24..3861199 100644
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -29,32 +29,28 @@
 #define AVR_JTAG_INS_LEN	4
 
 /* forward declarations */
-int avr_target_create(struct target *target, Jim_Interp *interp);
-int avr_init_target(struct command_context *cmd_ctx, struct target *target);
+static int avr_target_create(struct target *target, Jim_Interp *interp);
+static int avr_init_target(struct command_context *cmd_ctx, struct target *target);
 
-int avr_arch_state(struct target *target);
-int avr_poll(struct target *target);
-int avr_halt(struct target *target);
-int avr_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
-int avr_step(struct target *target, int current, uint32_t address, int handle_breakpoints);
+static int avr_arch_state(struct target *target);
+static int avr_poll(struct target *target);
+static int avr_halt(struct target *target);
+static int avr_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+static int avr_step(struct target *target, int current, uint32_t address, int handle_breakpoints);
 
-int avr_assert_reset(struct target *target);
-int avr_deassert_reset(struct target *target);
-int avr_soft_reset_halt(struct target *target);
+static int avr_assert_reset(struct target *target);
+static int avr_deassert_reset(struct target *target);
+static int avr_soft_reset_halt(struct target *target);
 
 /* IR and DR functions */
-int avr_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out);
-int avr_jtag_senddat(struct jtag_tap *tap, uint32_t *dr_in, uint32_t dr_out, int len);
-
-int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
-int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti);
-int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti);
+static int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
+static int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti);
+static int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti);
 int mcu_write_dr_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int dr_len, int rti);
 int mcu_write_ir_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti);
 int mcu_write_dr_u16(struct jtag_tap *tap, uint16_t *ir_in, uint16_t ir_out, int dr_len, int rti);
 int mcu_write_ir_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti);
-int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
-int mcu_execute_queue(void);
+static int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
 
 struct target_type avr_target =
 {
@@ -92,7 +88,7 @@ struct target_type avr_target =
 	.init_target = avr_init_target,
 };
 
-int avr_target_create(struct target *target, Jim_Interp *interp)
+static int avr_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct avr_common *avr = calloc(1, sizeof(struct avr_common));
 
@@ -102,19 +98,19 @@ int avr_target_create(struct target *target, Jim_Interp *interp)
 	return ERROR_OK;
 }
 
-int avr_init_target(struct command_context *cmd_ctx, struct target *target)
+static int avr_init_target(struct command_context *cmd_ctx, struct target *target)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
 }
 
-int avr_arch_state(struct target *target)
+static int avr_arch_state(struct target *target)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
 }
 
-int avr_poll(struct target *target)
+static int avr_poll(struct target *target)
 {
 	if ((target->state == TARGET_RUNNING) || (target->state == TARGET_DEBUG_RUNNING))
 	{
@@ -125,25 +121,26 @@ int avr_poll(struct target *target)
 	return ERROR_OK;
 }
 
-int avr_halt(struct target *target)
+static int avr_halt(struct target *target)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
 }
 
-int avr_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
+static int avr_resume(struct target *target, int current, uint32_t address,
+		int handle_breakpoints, int debug_execution)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
 }
 
-int avr_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
+static int avr_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
 }
 
-int avr_assert_reset(struct target *target)
+static int avr_assert_reset(struct target *target)
 {
 	target->state = TARGET_RESET;
 
@@ -151,7 +148,7 @@ int avr_assert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-int avr_deassert_reset(struct target *target)
+static int avr_deassert_reset(struct target *target)
 {
 	target->state = TARGET_RUNNING;
 
@@ -159,13 +156,14 @@ int avr_deassert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-int avr_soft_reset_halt(struct target *target)
+static int avr_soft_reset_halt(struct target *target)
 {
 	LOG_DEBUG("%s", __FUNCTION__);
 	return ERROR_OK;
 }
 
-int avr_jtag_senddat(struct jtag_tap *tap, uint32_t* dr_in, uint32_t dr_out, int len)
+int avr_jtag_senddat(struct jtag_tap *tap, uint32_t* dr_in, uint32_t dr_out,
+		int len)
 {
 	return mcu_write_dr_u32(tap, dr_in, dr_out, len, 1);
 }
@@ -176,7 +174,8 @@ int avr_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out)
 }
 
 /* IR and DR functions */
-int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti)
+static int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out,
+		int ir_len, int rti)
 {
 	if (NULL == tap)
 	{
@@ -196,7 +195,8 @@ int mcu_write_ir(struct jtag_tap *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_l
 	return ERROR_OK;
 }
 
-int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti)
+static int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out,
+		int dr_len, int rti)
 {
 	if (NULL == tap)
 	{
@@ -211,7 +211,8 @@ int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_l
 	return ERROR_OK;
 }
 
-int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti)
+static int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in,
+		uint8_t ir_out, int ir_len, int rti)
 {
 	if (ir_len > 8)
 	{
@@ -276,7 +277,8 @@ int mcu_write_ir_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int
 	return ERROR_OK;
 }
 
-int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *dr_in, uint32_t dr_out, int dr_len, int rti)
+static int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *dr_in,
+		uint32_t dr_out, int dr_len, int rti)
 {
 	if (dr_len > 32)
 	{
diff --git a/src/target/avrt.h b/src/target/avrt.h
index 221296a..221f924 100644
--- a/src/target/avrt.h
+++ b/src/target/avrt.h
@@ -32,4 +32,9 @@ struct avr_common
 	struct mcu_jtag jtag_info;
 };
 
+int mcu_execute_queue(void);
+int avr_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out);
+int avr_jtag_senddat(struct jtag_tap *tap, uint32_t *dr_in, uint32_t dr_out,
+		int len);
+
 #endif /* AVRT_H */

commit d26b5236bac524ca33799f2c10f40f65755bdd08
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 12:20:01 2010 +0800

    target/feroceon: review scope of symbols
    
    Add "static" qualifier to private functions.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index efd3040..ea22ca0 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -59,7 +59,7 @@
 #include "arm_opcodes.h"
 
 
-int feroceon_assert_reset(struct target *target)
+static int feroceon_assert_reset(struct target *target)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -72,7 +72,7 @@ int feroceon_assert_reset(struct target *target)
 	return arm7_9_assert_reset(target);
 }
 
-int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
+static int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 {
 	struct scan_field fields[3];
 	uint8_t out_buf[4];
@@ -107,7 +107,8 @@ int feroceon_dummy_clock_out(struct arm_jtag *jtag_info, uint32_t instr)
 	return ERROR_OK;
 }
 
-void feroceon_change_to_arm(struct target *target, uint32_t *r0, uint32_t *pc)
+static void feroceon_change_to_arm(struct target *target, uint32_t *r0,
+		uint32_t *pc)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -153,7 +154,8 @@ void feroceon_change_to_arm(struct target *target, uint32_t *r0, uint32_t *pc)
 	*pc -= (12 + 4);
 }
 
-void feroceon_read_core_regs(struct target *target, uint32_t mask, uint32_t* core_regs[16])
+static void feroceon_read_core_regs(struct target *target,
+		uint32_t mask, uint32_t* core_regs[16])
 {
 	int i;
 	struct arm *armv4_5 = target->arch_info;
@@ -172,7 +174,8 @@ void feroceon_read_core_regs(struct target *target, uint32_t mask, uint32_t* cor
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_read_core_regs_target_buffer(struct target *target, uint32_t mask, void* buffer, int size)
+static void feroceon_read_core_regs_target_buffer(struct target *target,
+		uint32_t mask, void* buffer, int size)
 {
 	int i;
 	struct arm *armv4_5 = target->arch_info;
@@ -209,7 +212,7 @@ void feroceon_read_core_regs_target_buffer(struct target *target, uint32_t mask,
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_read_xpsr(struct target *target, uint32_t *xpsr, int spsr)
+static void feroceon_read_xpsr(struct target *target, uint32_t *xpsr, int spsr)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -232,7 +235,7 @@ void feroceon_read_xpsr(struct target *target, uint32_t *xpsr, int spsr)
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_write_xpsr(struct target *target, uint32_t xpsr, int spsr)
+static void feroceon_write_xpsr(struct target *target, uint32_t xpsr, int spsr)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -273,7 +276,8 @@ void feroceon_write_xpsr(struct target *target, uint32_t xpsr, int spsr)
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_write_xpsr_im8(struct target *target, uint8_t xpsr_im, int rot, int spsr)
+static void feroceon_write_xpsr_im8(struct target *target,
+		uint8_t xpsr_im, int rot, int spsr)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -290,7 +294,8 @@ void feroceon_write_xpsr_im8(struct target *target, uint8_t xpsr_im, int rot, in
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_write_core_regs(struct target *target, uint32_t mask, uint32_t core_regs[16])
+static void feroceon_write_core_regs(struct target *target,
+		uint32_t mask, uint32_t core_regs[16])
 {
 	int i;
 	struct arm *armv4_5 = target->arch_info;
@@ -310,7 +315,7 @@ void feroceon_write_core_regs(struct target *target, uint32_t mask, uint32_t cor
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_branch_resume(struct target *target)
+static void feroceon_branch_resume(struct target *target)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -325,7 +330,7 @@ void feroceon_branch_resume(struct target *target)
 	arm7_9->need_bypass_before_restart = 1;
 }
 
-void feroceon_branch_resume_thumb(struct target *target)
+static void feroceon_branch_resume_thumb(struct target *target)
 {
 	LOG_DEBUG("-");
 
@@ -360,7 +365,8 @@ void feroceon_branch_resume_thumb(struct target *target)
 	arm7_9->need_bypass_before_restart = 1;
 }
 
-int feroceon_read_cp15(struct target *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
+static int feroceon_read_cp15(struct target *target, uint32_t op1,
+		uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -382,7 +388,8 @@ int feroceon_read_cp15(struct target *target, uint32_t op1, uint32_t op2, uint32
 	return jtag_execute_queue();
 }
 
-int feroceon_write_cp15(struct target *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
+static int feroceon_write_cp15(struct target *target, uint32_t op1,
+		uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -401,7 +408,7 @@ int feroceon_write_cp15(struct target *target, uint32_t op1, uint32_t op2, uint3
 	return arm7_9_execute_sys_speed(target);
 }
 
-void feroceon_set_dbgrq(struct target *target)
+static void feroceon_set_dbgrq(struct target *target)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -411,7 +418,7 @@ void feroceon_set_dbgrq(struct target *target)
 	embeddedice_store_reg(dbg_ctrl);
 }
 
-void feroceon_enable_single_step(struct target *target, uint32_t next_pc)
+static void feroceon_enable_single_step(struct target *target, uint32_t next_pc)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -424,7 +431,7 @@ void feroceon_enable_single_step(struct target *target, uint32_t next_pc)
 	embeddedice_write_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_MASK], 0xf7);
 }
 
-void feroceon_disable_single_step(struct target *target)
+static void feroceon_disable_single_step(struct target *target)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -436,7 +443,7 @@ void feroceon_disable_single_step(struct target *target)
 	embeddedice_store_reg(&arm7_9->eice_cache->reg_list[EICE_W0_CONTROL_VALUE]);
 }
 
-int feroceon_examine_debug_reason(struct target *target)
+static int feroceon_examine_debug_reason(struct target *target)
 {
 	/* the MOE is not implemented */
 	if (target->debug_reason != DBG_REASON_SINGLESTEP)
@@ -447,7 +454,8 @@ int feroceon_examine_debug_reason(struct target *target)
 	return ERROR_OK;
 }
 
-int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+static int feroceon_bulk_write_memory(struct target *target,
+		uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 	struct arm *armv4_5 = target->arch_info;
@@ -576,13 +584,14 @@ int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 	return retval;
 }
 
-int feroceon_init_target(struct command_context *cmd_ctx, struct target *target)
+static int feroceon_init_target(struct command_context *cmd_ctx,
+		struct target *target)
 {
 	arm9tdmi_init_target(cmd_ctx, target);
 	return ERROR_OK;
 }
 
-void feroceon_common_setup(struct target *target)
+static void feroceon_common_setup(struct target *target)
 {
 	struct arm *armv4_5 = target->arch_info;
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
@@ -615,7 +624,7 @@ void feroceon_common_setup(struct target *target)
 	arm7_9->wp1_used_default = -1;
 }
 
-int feroceon_target_create(struct target *target, Jim_Interp *interp)
+static int feroceon_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct arm926ejs_common *arm926ejs = calloc(1,sizeof(struct arm926ejs_common));
 
@@ -629,7 +638,7 @@ int feroceon_target_create(struct target *target, Jim_Interp *interp)
 	return ERROR_OK;
 }
 
-int dragonite_target_create(struct target *target, Jim_Interp *interp)
+static int dragonite_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct arm966e_common *arm966e = calloc(1,sizeof(struct arm966e_common));
 
@@ -639,7 +648,7 @@ int dragonite_target_create(struct target *target, Jim_Interp *interp)
 	return ERROR_OK;
 }
 
-int feroceon_examine(struct target *target)
+static int feroceon_examine(struct target *target)
 {
 	struct arm *armv4_5;
 	struct arm7_9_common *arm7_9;

commit 3f59fcf77e5eb1d8c504a337b05bb1a5797e656f
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sun Jun 20 00:22:12 2010 +0800

    target/mips_m4k: review scope of symbols
    
    Add "static" qualifier to private functions.
    Remove private prototypes from include file.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
index e258b71..21ff0ba 100644
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -32,7 +32,14 @@
 #include "target_type.h"
 #include "register.h"
 
-int mips_m4k_examine_debug_reason(struct target *target)
+static void mips_m4k_enable_breakpoints(struct target *target);
+static void mips_m4k_enable_watchpoints(struct target *target);
+static int mips_m4k_set_breakpoint(struct target *target,
+		struct breakpoint *breakpoint);
+static int mips_m4k_unset_breakpoint(struct target *target,
+		struct breakpoint *breakpoint);
+
+static int mips_m4k_examine_debug_reason(struct target *target)
 {
 	uint32_t break_status;
 	int retval;
@@ -66,7 +73,7 @@ int mips_m4k_examine_debug_reason(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_debug_entry(struct target *target)
+static int mips_m4k_debug_entry(struct target *target)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -104,7 +111,7 @@ int mips_m4k_debug_entry(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_poll(struct target *target)
+static int mips_m4k_poll(struct target *target)
 {
 	int retval;
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -162,7 +169,7 @@ int mips_m4k_poll(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_halt(struct target *target)
+static int mips_m4k_halt(struct target *target)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -207,7 +214,7 @@ int mips_m4k_halt(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_assert_reset(struct target *target)
+static int mips_m4k_assert_reset(struct target *target)
 {
 	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
 	struct mips_ejtag *ejtag_info = &mips_m4k->mips32.ejtag_info;
@@ -286,7 +293,7 @@ int mips_m4k_assert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_deassert_reset(struct target *target)
+static int mips_m4k_deassert_reset(struct target *target)
 {
 	LOG_DEBUG("target->state: %s",
 		target_state_name(target));
@@ -297,13 +304,13 @@ int mips_m4k_deassert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_soft_reset_halt(struct target *target)
+static int mips_m4k_soft_reset_halt(struct target *target)
 {
 	/* TODO */
 	return ERROR_OK;
 }
 
-int mips_m4k_single_step_core(struct target *target)
+static int mips_m4k_single_step_core(struct target *target)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -322,7 +329,8 @@ int mips_m4k_single_step_core(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
+static int mips_m4k_resume(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -397,7 +405,8 @@ int mips_m4k_resume(struct target *target, int current, uint32_t address, int ha
 	return ERROR_OK;
 }
 
-int mips_m4k_step(struct target *target, int current, uint32_t address, int handle_breakpoints)
+static int mips_m4k_step(struct target *target, int current,
+		uint32_t address, int handle_breakpoints)
 {
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -452,7 +461,7 @@ int mips_m4k_step(struct target *target, int current, uint32_t address, int hand
 	return ERROR_OK;
 }
 
-void mips_m4k_enable_breakpoints(struct target *target)
+static void mips_m4k_enable_breakpoints(struct target *target)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 
@@ -465,7 +474,8 @@ void mips_m4k_enable_breakpoints(struct target *target)
 	}
 }
 
-int mips_m4k_set_breakpoint(struct target *target, struct breakpoint *breakpoint)
+static int mips_m4k_set_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips32_comparator * comparator_list = mips32->inst_break_list;
@@ -557,7 +567,8 @@ int mips_m4k_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 	return ERROR_OK;
 }
 
-int mips_m4k_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
+static int mips_m4k_unset_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
 {
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -636,7 +647,7 @@ int mips_m4k_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 	return ERROR_OK;
 }
 
-int mips_m4k_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
+static int mips_m4k_add_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 
@@ -656,7 +667,8 @@ int mips_m4k_add_breakpoint(struct target *target, struct breakpoint *breakpoint
 	return ERROR_OK;
 }
 
-int mips_m4k_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
+static int mips_m4k_remove_breakpoint(struct target *target,
+		struct breakpoint *breakpoint)
 {
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -678,7 +690,8 @@ int mips_m4k_remove_breakpoint(struct target *target, struct breakpoint *breakpo
 	return ERROR_OK;
 }
 
-int mips_m4k_set_watchpoint(struct target *target, struct watchpoint *watchpoint)
+static int mips_m4k_set_watchpoint(struct target *target,
+		struct watchpoint *watchpoint)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips32_comparator *comparator_list = mips32->data_break_list;
@@ -745,7 +758,8 @@ int mips_m4k_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 	return ERROR_OK;
 }
 
-int mips_m4k_unset_watchpoint(struct target *target, struct watchpoint *watchpoint)
+static int mips_m4k_unset_watchpoint(struct target *target,
+		struct watchpoint *watchpoint)
 {
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -771,7 +785,7 @@ int mips_m4k_unset_watchpoint(struct target *target, struct watchpoint *watchpoi
 	return ERROR_OK;
 }
 
-int mips_m4k_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
+static int mips_m4k_add_watchpoint(struct target *target, struct watchpoint *watchpoint)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 
@@ -787,7 +801,8 @@ int mips_m4k_add_watchpoint(struct target *target, struct watchpoint *watchpoint
 	return ERROR_OK;
 }
 
-int mips_m4k_remove_watchpoint(struct target *target, struct watchpoint *watchpoint)
+static int mips_m4k_remove_watchpoint(struct target *target,
+		struct watchpoint *watchpoint)
 {
 	/* get pointers to arch-specific information */
 	struct mips32_common *mips32 = target_to_mips32(target);
@@ -808,7 +823,7 @@ int mips_m4k_remove_watchpoint(struct target *target, struct watchpoint *watchpo
 	return ERROR_OK;
 }
 
-void mips_m4k_enable_watchpoints(struct target *target)
+static void mips_m4k_enable_watchpoints(struct target *target)
 {
 	struct watchpoint *watchpoint = target->watchpoints;
 
@@ -821,7 +836,8 @@ void mips_m4k_enable_watchpoints(struct target *target)
 	}
 }
 
-int mips_m4k_read_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+static int mips_m4k_read_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -853,8 +869,8 @@ int mips_m4k_read_memory(struct target *target, uint32_t address, uint32_t size,
 	return ERROR_OK;
 }
 
-int mips_m4k_write_memory(struct target *target, uint32_t address, uint32_t size,
-		uint32_t count, uint8_t *buffer)
+static int mips_m4k_write_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
 	struct mips_ejtag *ejtag_info = &mips32->ejtag_info;
@@ -882,15 +898,16 @@ int mips_m4k_write_memory(struct target *target, uint32_t address, uint32_t size
 		return mips32_dmaacc_write_mem(ejtag_info, address, size, count, (void *)buffer);
 }
 
-int mips_m4k_init_target(struct command_context *cmd_ctx, struct target *target)
+static int mips_m4k_init_target(struct command_context *cmd_ctx,
+		struct target *target)
 {
 	mips32_build_reg_cache(target);
 
 	return ERROR_OK;
 }
 
-int mips_m4k_init_arch_info(struct target *target, struct mips_m4k_common *mips_m4k,
-		struct jtag_tap *tap)
+static int mips_m4k_init_arch_info(struct target *target,
+		struct mips_m4k_common *mips_m4k, struct jtag_tap *tap)
 {
 	struct mips32_common *mips32 = &mips_m4k->mips32;
 
@@ -903,7 +920,7 @@ int mips_m4k_init_arch_info(struct target *target, struct mips_m4k_common *mips_
 	return ERROR_OK;
 }
 
-int mips_m4k_target_create(struct target *target, Jim_Interp *interp)
+static int mips_m4k_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct mips_m4k_common *mips_m4k = calloc(1, sizeof(struct mips_m4k_common));
 
@@ -912,7 +929,7 @@ int mips_m4k_target_create(struct target *target, Jim_Interp *interp)
 	return ERROR_OK;
 }
 
-int mips_m4k_examine(struct target *target)
+static int mips_m4k_examine(struct target *target)
 {
 	int retval;
 	struct mips_m4k_common *mips_m4k = target_to_m4k(target);
@@ -944,7 +961,7 @@ int mips_m4k_examine(struct target *target)
 	return ERROR_OK;
 }
 
-int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
+static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 		uint32_t count, uint8_t *buffer)
 {
 	struct mips32_common *mips32 = target_to_mips32(target);
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
index 5eb2029..bb37ee2 100644
--- a/src/target/mips_m4k.h
+++ b/src/target/mips_m4k.h
@@ -43,19 +43,4 @@ target_to_m4k(struct target *target)
 			struct mips_m4k_common, mips32);
 }
 
-int mips_m4k_bulk_write_memory(struct target *target,
-		uint32_t address, uint32_t count, uint8_t *buffer);
-
-void mips_m4k_enable_breakpoints(struct target *target);
-int mips_m4k_set_breakpoint(struct target *target, struct breakpoint *bp);
-int mips_m4k_unset_breakpoint(struct target *target, struct breakpoint *bp);
-int mips_m4k_add_breakpoint(struct target *target, struct breakpoint *bp);
-int mips_m4k_remove_breakpoint(struct target *target, struct breakpoint *bp);
-
-void mips_m4k_enable_watchpoints(struct target *target);
-int mips_m4k_set_watchpoint(struct target *target, struct watchpoint *wp);
-int mips_m4k_unset_watchpoint(struct target *target, struct watchpoint *wp);
-int mips_m4k_add_watchpoint(struct target *target, struct watchpoint *wp);
-int mips_m4k_remove_watchpoint(struct target *target, struct watchpoint *wp);
-
 #endif	/*MIPS_M4K_H*/

commit b978dcbbee628ed30286b90cecf7085eb2cb7a82
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 19 23:46:46 2010 +0800

    helper/jim-eventloop.h: review unused definitions
    
    Remove unused typedef and define
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/helper/jim-eventloop.h b/src/helper/jim-eventloop.h
index 77ee8fe..95c31d6 100644
--- a/src/helper/jim-eventloop.h
+++ b/src/helper/jim-eventloop.h
@@ -53,7 +53,6 @@
 #define __JIM_EVENTLOOP_H__
 
 typedef int Jim_FileProc(Jim_Interp *interp, void *clientData, int mask);
-typedef int Jim_SignalProc(Jim_Interp *interp, void *clientData, void *msg);
 typedef void Jim_TimeProc(Jim_Interp *interp, void *clientData);
 typedef void Jim_EventFinalizerProc(Jim_Interp *interp, void *clientData);
 
@@ -63,8 +62,6 @@ typedef void Jim_EventFinalizerProc(Jim_Interp *interp, void *clientData);
 #define JIM_EVENT_EXCEPTION 4
 #define JIM_EVENT_FEOF 8
 
-#define JIM_API(x) x
-
 int Jim_EventLoopOnLoad(Jim_Interp *interp);
 
 /* --- POSIX version of Jim_ProcessEvents, for now the only available --- */
@@ -73,16 +70,6 @@ int Jim_EventLoopOnLoad(Jim_Interp *interp);
 #define JIM_ALL_EVENTS (JIM_FILE_EVENTS | JIM_TIME_EVENTS)
 #define JIM_DONT_WAIT 4
 
-int JIM_API(Jim_ProcessEvents) (Jim_Interp *interp, int flags);
-
-#undef JIM_API
-
-#ifndef __JIM_EVENTLOOP_CORE__
-
-#define JIM_GET_API(name) \
-    Jim_GetApi(interp, "Jim_" #name, ((void *)&Jim_ ## name))
-
-#undef JIM_GET_API
-#endif /* __JIM_EVENTLOOP_CORE__ */
+int Jim_ProcessEvents(Jim_Interp *interp, int flags);
 
 #endif /* __JIM_EVENTLOOP_H__ */

commit 3cfbf705597732c7b6a5b11a556c818529ea725b
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 19 23:37:33 2010 +0800

    helper/jim-eventloop: review unused symbols
    
    Remove unused functions:
    - Jim_CreateSignalHandler
    - Jim_DeleteSignalHandler
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/helper/jim-eventloop.c b/src/helper/jim-eventloop.c
index 23115fe..fe2d685 100644
--- a/src/helper/jim-eventloop.c
+++ b/src/helper/jim-eventloop.c
@@ -131,16 +131,6 @@ static void Jim_DeleteFileHandler(Jim_Interp *interp, void *handle)
     }
 }
 
-// The same for signals.
-void Jim_CreateSignalHandler(Jim_Interp *interp, int signum,
-        Jim_FileProc *proc, void *clientData,
-        Jim_EventFinalizerProc *finalizerProc)
-{
-}
-void Jim_DeleteSignalHandler(Jim_Interp *interp, int signum)
-{
-}
-
 /* That's another part of this extension that needs to be ported
  * to WIN32. */
 static void JimGetTime(long *seconds, long *milliseconds)

commit ec073e89435785375dece2fb7c4664002c22859c
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Sat Jun 19 23:34:05 2010 +0800

    helper/jim-eventloop: review scope of symbols
    
    Add "static" qualifier to private functions.
    Remove private prototypes from include file.
    Remove empty definition of JIM_STATIC.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/helper/jim-eventloop.c b/src/helper/jim-eventloop.c
index fae46e8..23115fe 100644
--- a/src/helper/jim-eventloop.c
+++ b/src/helper/jim-eventloop.c
@@ -90,7 +90,7 @@ typedef struct Jim_EventLoop {
     Jim_TimeEvent *timeEventHead;
 } Jim_EventLoop;
 
-void Jim_CreateFileHandler(Jim_Interp *interp, void *handle, int mask,
+static void Jim_CreateFileHandler(Jim_Interp *interp, void *handle, int mask,
         Jim_FileProc *proc, void *clientData,
         Jim_EventFinalizerProc *finalizerProc)
 {
@@ -109,7 +109,7 @@ void Jim_CreateFileHandler(Jim_Interp *interp, void *handle, int mask,
 	// fprintf(stderr,"raus\n");
 }
 
-void Jim_DeleteFileHandler(Jim_Interp *interp, void *handle)
+static void Jim_DeleteFileHandler(Jim_Interp *interp, void *handle)
 {
     Jim_FileEvent *fe, *prev = NULL;
     Jim_EventLoop *eventLoop = Jim_GetAssocData(interp, "eventloop");
@@ -152,7 +152,7 @@ static void JimGetTime(long *seconds, long *milliseconds)
     *milliseconds = tv.tv_usec/1000;
 }
 
-jim_wide Jim_CreateTimeHandler(Jim_Interp *interp, jim_wide milliseconds,
+static jim_wide Jim_CreateTimeHandler(Jim_Interp *interp, jim_wide milliseconds,
         Jim_TimeProc *proc, void *clientData,
         Jim_EventFinalizerProc *finalizerProc)
 {
@@ -181,7 +181,7 @@ jim_wide Jim_CreateTimeHandler(Jim_Interp *interp, jim_wide milliseconds,
     return id;
 }
 
-jim_wide Jim_DeleteTimeHandler(Jim_Interp *interp, jim_wide id)
+static jim_wide Jim_DeleteTimeHandler(Jim_Interp *interp, jim_wide id)
 {
     Jim_TimeEvent *te, *prev = NULL;
     Jim_EventLoop *eventLoop = Jim_GetAssocData(interp, "eventloop");
@@ -391,7 +391,7 @@ int Jim_ProcessEvents(Jim_Interp *interp, int flags)
 }
 /* ---------------------------------------------------------------------- */
 
-void JimELAssocDataDeleProc(Jim_Interp *interp, void *data)
+static void JimELAssocDataDeleProc(Jim_Interp *interp, void *data)
 {
     void *next;
     Jim_FileEvent *fe;
@@ -446,14 +446,14 @@ static int JimELVwaitCommand(Jim_Interp *interp, int argc,
     return JIM_OK;
 }
 
-void JimAfterTimeHandler(Jim_Interp *interp, void *clientData)
+static void JimAfterTimeHandler(Jim_Interp *interp, void *clientData)
 {
     Jim_Obj *objPtr = clientData;
 
     Jim_EvalObjBackground(interp, objPtr);
 }
 
-void JimAfterTimeEventFinalizer(Jim_Interp *interp, void *clientData)
+static void JimAfterTimeEventFinalizer(Jim_Interp *interp, void *clientData)
 {
     Jim_Obj *objPtr = clientData;
 
diff --git a/src/helper/jim-eventloop.h b/src/helper/jim-eventloop.h
index ddb6fc9..77ee8fe 100644
--- a/src/helper/jim-eventloop.h
+++ b/src/helper/jim-eventloop.h
@@ -64,9 +64,8 @@ typedef void Jim_EventFinalizerProc(Jim_Interp *interp, void *clientData);
 #define JIM_EVENT_FEOF 8
 
 #define JIM_API(x) x
-#define JIM_STATIC
 
-JIM_STATIC int Jim_EventLoopOnLoad(Jim_Interp *interp);
+int Jim_EventLoopOnLoad(Jim_Interp *interp);
 
 /* --- POSIX version of Jim_ProcessEvents, for now the only available --- */
 #define JIM_FILE_EVENTS 1
@@ -74,20 +73,8 @@ JIM_STATIC int Jim_EventLoopOnLoad(Jim_Interp *interp);
 #define JIM_ALL_EVENTS (JIM_FILE_EVENTS | JIM_TIME_EVENTS)
 #define JIM_DONT_WAIT 4
 
-JIM_STATIC void JIM_API(Jim_CreateFileHandler) (Jim_Interp *interp,
-        void *handle, int mask,
-        Jim_FileProc *proc, void *clientData,
-        Jim_EventFinalizerProc *finalizerProc);
-JIM_STATIC void JIM_API(Jim_DeleteFileHandler) (Jim_Interp *interp,
-        void *handle);
-JIM_STATIC jim_wide JIM_API(Jim_CreateTimeHandler) (Jim_Interp *interp,
-        jim_wide milliseconds,
-        Jim_TimeProc *proc, void *clientData,
-        Jim_EventFinalizerProc *finalizerProc);
-JIM_STATIC jim_wide JIM_API(Jim_DeleteTimeHandler) (Jim_Interp *interp, jim_wide id);
-JIM_STATIC int JIM_API(Jim_ProcessEvents) (Jim_Interp *interp, int flags);
+int JIM_API(Jim_ProcessEvents) (Jim_Interp *interp, int flags);
 
-#undef JIM_STATIC
 #undef JIM_API
 
 #ifndef __JIM_EVENTLOOP_CORE__

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/mx2.c       |    2 +-
 src/flash/nor/avrf.c       |   13 -----
 src/flash/nor/str7x.c      |    2 +-
 src/flash/nor/virtual.c    |    4 +-
 src/helper/jim-eventloop.c |   24 +++------
 src/helper/jim-eventloop.h |   30 +----------
 src/openocd.c              |    2 +-
 src/target/avrt.c          |  124 ++++++++++++-------------------------------
 src/target/avrt.h          |    5 ++
 src/target/feroceon.c      |   55 +++++++++++--------
 src/target/mips_m4k.c      |   75 ++++++++++++++++----------
 src/target/mips_m4k.h      |   15 -----
 12 files changed, 132 insertions(+), 219 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 22 08:21:45 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 22 Jun 2010 06:21:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-380-gfe1f7f6
Message-ID: <E1OQwrj-0001y5-MH@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fe1f7f63b628ae485609500b8710bfea3bac61a6 (commit)
       via  9a8fe44c83e466b93ef67d4c47b6fc84578d8e3d (commit)
       via  b50bb632adbfaa21d7a4d3705932aeaebf889f23 (commit)
       via  4d238c7f91a73beebe1e71594b19ac39c62ff408 (commit)
       via  59bf45be1f37bd10c97bcfb1309f3c4c826b2a5a (commit)
       via  37cfbe491777a32a4e04b17620bd5f327a6aed92 (commit)
       via  19925e4d7f4ea3059c05e4ededa2e4f16eca67bf (commit)
      from  f747b16e4e14f25f19e391b4811db9fa70be919a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fe1f7f63b628ae485609500b8710bfea3bac61a6
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 16:07:25 2010 +0200

    board: add alpha am3517evm ti board config file
    
    Signs of life: reset(kinda), halt, resume and memory
    display/modify.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/am3517evm.cfg b/tcl/board/am3517evm.cfg
new file mode 100644
index 0000000..a639fa6
--- /dev/null
+++ b/tcl/board/am3517evm.cfg
@@ -0,0 +1,97 @@
+# DANGER!!!! early work in progress for this PCB/target.
+#
+# The most basic operations work well enough that it is
+# useful to have this in the repository for cooperation
+# alpha testing purposes.
+#
+# TI AM3517
+#
+# http://focus.ti.com/docs/prod/folders/print/am3517.html
+# http://processors.wiki.ti.com/index.php/Debug_Access_Port_(DAP)
+# http://processors.wiki.ti.com/index.php?title=How_to_Find_the_Silicon_Revision_of_your_OMAP35x
+
+# Slooow during startup
+adapter_khz 10
+
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME am3517
+}
+
+set JRC_TAPID 0
+
+set DAP_TAPID 0x0b86802f
+
+# Subsidiary TAP: CoreSight Debug Access Port (DAP)
+if { [info exists DAP_TAPID ] } {
+   set _DAP_TAPID $DAP_TAPID
+} else {
+   set _DAP_TAPID 0x0b6d602f
+}
+
+
+# Primary TAP: ICEpick-C (JTAG route controller) and boundary scan
+if { [info exists JRC_TAPID ] } {
+   set _JRC_TAPID $JRC_TAPID
+} else {
+   set _JRC_TAPID 0x0b7ae02f
+}
+
+# ICEpick-C ... used to route Cortex, and more not shown here
+source [find target/icepick.cfg]
+
+
+jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0x1 -irmask 0xf \
+	-expected-id $_DAP_TAPID -disable
+jtag configure $_CHIPNAME.dap -event tap-enable \
+	"icepick_c_tapenable $_CHIPNAME.jrc 3"
+
+jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x1 -irmask 0x3f \
+	-expected-id $_JRC_TAPID
+
+
+
+# GDB target:  Cortex-A8, using DAP
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME cortex_a8 -chain-position $_CHIPNAME.dap
+
+# SRAM: 64K at 0x4020.0000; use the first 16K
+$_TARGETNAME configure -work-area-phys 0x40200000 -work-area-size 0x4000
+
+###################
+
+# the reset sequence is event-driven
+# and kind of finicky...
+
+# some TCK tycles are required to activate the DEBUG power domain
+jtag configure $_CHIPNAME.jrc -event post-reset "runtest 100"
+
+# have the DAP "always" be active
+jtag configure $_CHIPNAME.jrc -event setup "jtag tapenable $_CHIPNAME.dap"
+
+proc omap3_dbginit {target} {
+
+     # General Cortex A8 debug initialisation
+     cortex_a8 dbginit
+     # Enable DBGU signal for OMAP353x
+     $target mww 0x5401d030 0x00002000
+}
+
+# be absolutely certain the JTAG clock will work with the worst-case
+# 16.8MHz/2 = 8.4MHz core clock, even before a bootloader kicks in.
+# OK to speed up *after* PLL and clock tree setup.
+
+$_TARGETNAME configure -event "reset-start" { adapter_khz 10; halt; halt }
+
+# Assume SRST is unavailable (e.g. TI-14 JTAG), so we must assert reset
+# ourselves using PRM_RSTCTRL.  RST_GS (2) is a warm reset, like ICEpick
+# would issue.  RST_DPLL3 (4) is a cold reset.
+set PRM_RSTCTRL 0x48307250
+$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww $PRM_RSTCTRL 2"
+
+$_TARGETNAME configure -event reset-assert-post "omap3_dbginit $_TARGETNAME; adapter_khz 1000"
+
+
+reset_config trst_only

commit 9a8fe44c83e466b93ef67d4c47b6fc84578d8e3d
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 16:07:00 2010 +0200

    gitignore: start list of emacs temp files to ignore
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/.gitignore b/.gitignore
index e37ee5a..0491508 100644
--- a/.gitignore
+++ b/.gitignore
@@ -73,3 +73,6 @@ patches
 .project
 .cproject
 .settings
+
+# Emacs temp files
+*~

commit b50bb632adbfaa21d7a4d3705932aeaebf889f23
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 14:34:07 2010 +0200

    cortex a8: print message that locking debug access succeeded on second try
    
    when locking the debug access fails on the first try, it's a
    bit noisy, so print out message that it succeeded on second try.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index ee79d63..ea07579 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -92,6 +92,10 @@ static int cortex_a8_init_debug_access(struct target *target)
 	{
 		/* try again */
 		retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		if (retval == ERROR_OK)
+		{
+			LOG_USER("Locking debug access failed on first, but succeeded on second try.");
+		}
 	}
 	if (retval != ERROR_OK)
 		return retval;

commit 4d238c7f91a73beebe1e71594b19ac39c62ff408
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 14:26:19 2010 +0200

    cortex a8: add error propagation for poll/resume
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index c39dba3..ee79d63 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -98,12 +98,15 @@ static int cortex_a8_init_debug_access(struct target *target)
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
 	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_PRSR, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
 	/* Enabling of instruction execution in debug mode is done in debug_entry code */
 
 	/* Resync breakpoint registers */
 
 	/* Since this is likley called from init or reset, update targtet state information*/
-	cortex_a8_poll(target);
+	retval = cortex_a8_poll(target);
 
 	return retval;
 }
@@ -1005,6 +1008,7 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	struct breakpoint *breakpoint = NULL;
 	struct breakpoint stepbreakpoint;
 	struct reg *r;
+	int retval;
 
 	int timeout = 100;
 
@@ -1048,15 +1052,19 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 
 	target->debug_reason = DBG_REASON_SINGLESTEP;
 
-	cortex_a8_resume(target, 1, address, 0, 0);
+	retval = cortex_a8_resume(target, 1, address, 0, 0);
+	if (retval != ERROR_OK)
+		return retval;
 
 	while (target->state != TARGET_HALTED)
 	{
-		cortex_a8_poll(target);
+		retval = cortex_a8_poll(target);
+		if (retval != ERROR_OK)
+			return retval;
 		if (--timeout == 0)
 		{
-			LOG_WARNING("timeout waiting for target halt");
-			break;
+			LOG_ERROR("timeout waiting for target halt");
+			return ERROR_FAIL;
 		}
 	}
 
@@ -1313,6 +1321,8 @@ static int cortex_a8_deassert_reset(struct target *target)
 	jtag_add_reset(0, 0);
 
 	retval = cortex_a8_poll(target);
+	if (retval != ERROR_OK)
+		return retval;
 
 	if (target->reset_halt) {
 		if (target->state != TARGET_HALTED) {

commit 59bf45be1f37bd10c97bcfb1309f3c4c826b2a5a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 14:14:31 2010 +0200

    cortex a8: add timeouts waiting for restart, prepare and halt
    
    It would previously sit in an infinite loop rather
    than reporting an error.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 1577c26..c39dba3 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -39,6 +39,7 @@
 #include "target_request.h"
 #include "target_type.h"
 #include "arm_opcodes.h"
+#include <helper/time_support.h>
 
 static int cortex_a8_poll(struct target *target);
 static int cortex_a8_debug_entry(struct target *target);
@@ -364,13 +365,22 @@ static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 	int retval;
 
 	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
-	do {
+	long long then = timeval_ms();
+	for (;;)
+	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
 		if (retval != ERROR_OK)
 			return retval;
-	} while ((dscr & DSCR_INSTR_COMP) == 0);
+		if ((dscr & DSCR_INSTR_COMP) != 0)
+			break;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for dpm prepare");
+			return ERROR_FAIL;
+		}
+	}
 
 	/* this "should never happen" ... */
 	if (dscr & DSCR_DTR_RX_FULL) {
@@ -668,12 +678,23 @@ static int cortex_a8_halt(struct target *target)
 	if (retval != ERROR_OK)
 		goto out;
 
-	do {
+	long long then = timeval_ms();
+	for (;;)
+	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			goto out;
-	} while ((dscr & DSCR_CORE_HALTED) == 0);
+		if ((dscr & DSCR_CORE_HALTED) != 0)
+		{
+			break;
+		}
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for halt");
+			return ERROR_FAIL;
+		}
+	}
 
 	target->debug_reason = DBG_REASON_DBGRQ;
 
@@ -776,12 +797,21 @@ static int cortex_a8_resume(struct target *target, int current,
 	if (retval != ERROR_OK)
 		return retval;
 
-	do {
+	long long then = timeval_ms();
+	for (;;)
+	{
 		retval = mem_ap_read_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
-	} while ((dscr & DSCR_CORE_RESTARTED) == 0);
+		if ((dscr & DSCR_CORE_RESTARTED) != 0)
+			break;
+		if (timeval_ms() > then + 1000)
+		{
+			LOG_ERROR("Timeout waiting for resume");
+			return ERROR_FAIL;
+		}
+	}
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
 	target->state = TARGET_RUNNING;

commit 37cfbe491777a32a4e04b17620bd5f327a6aed92
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 13:58:52 2010 +0200

    cortex a8: add error propagation for mem_ap_read/write_atomic_u32
    
    Error propagation avoids e.g. infinite loops waiting
    for target to halt, etc.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 933b42e..1577c26 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -88,7 +88,12 @@ static int cortex_a8_init_debug_access(struct target *target)
 	/* The debugport might be uninitialised so try twice */
 	retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
 	if (retval != ERROR_OK)
-		mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	{
+		/* try again */
+		retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	}
+	if (retval != ERROR_OK)
+		return retval;
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
 	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_PRSR, &dummy);
@@ -363,6 +368,8 @@ static int cortex_a8_dpm_prepare(struct arm_dpm *dpm)
 		retval = mem_ap_read_atomic_u32(swjdp,
 				a8->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	} while ((dscr & DSCR_INSTR_COMP) == 0);
 
 	/* this "should never happen" ... */
@@ -646,20 +653,26 @@ static int cortex_a8_halt(struct target *target)
 	 */
 	retval = mem_ap_write_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DRCR, 0x1);
+	if (retval != ERROR_OK)
+		goto out;
 
 	/*
 	 * enter halting debug mode
 	 */
-	mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = mem_ap_read_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto out;
+
 	retval = mem_ap_write_atomic_u32(swjdp,
 		armv7a->debug_base + CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
-
 	if (retval != ERROR_OK)
 		goto out;
 
 	do {
-		mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_read_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			goto out;
 	} while ((dscr & DSCR_CORE_HALTED) == 0);
 
 	target->debug_reason = DBG_REASON_DBGRQ;
@@ -675,6 +688,7 @@ static int cortex_a8_resume(struct target *target, int current,
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &armv7a->armv4_5_common;
 	struct adiv5_dap *swjdp = &armv7a->dap;
+	int retval;
 
 //	struct breakpoint *breakpoint = NULL;
 	uint32_t resume_pc, dscr;
@@ -758,11 +772,15 @@ static int cortex_a8_resume(struct target *target, int current,
 	 * REVISIT: for single stepping, we probably want to
 	 * disable IRQs by default, with optional override...
 	 */
-	mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DRCR, 0x2);
+	retval = mem_ap_write_atomic_u32(swjdp, armv7a->debug_base + CPUDBG_DRCR, 0x2);
+	if (retval != ERROR_OK)
+		return retval;
 
 	do {
-		mem_ap_read_atomic_u32(swjdp,
+		retval = mem_ap_read_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
 	} while ((dscr & DSCR_CORE_RESTARTED) == 0);
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
@@ -804,8 +822,10 @@ static int cortex_a8_debug_entry(struct target *target)
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a8->cpudbg_dscr);
 
 	/* REVISIT surely we should not re-read DSCR !! */
-	mem_ap_read_atomic_u32(swjdp,
+	retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* REVISIT see A8 TRM 12.11.4 steps 2..3 -- make sure that any
 	 * imprecise data aborts get discarded by issuing a Data
@@ -816,6 +836,8 @@ static int cortex_a8_debug_entry(struct target *target)
 	dscr |= DSCR_ITR_EN;
 	retval = mem_ap_write_atomic_u32(swjdp,
 			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* Examine debug reason */
 	arm_dpm_report_dscr(&armv7a->dpm, cortex_a8->cpudbg_dscr);
@@ -827,6 +849,8 @@ static int cortex_a8_debug_entry(struct target *target)
 		retval = mem_ap_read_atomic_u32(swjdp,
 				armv7a->debug_base + CPUDBG_WFAR,
 				&wfar);
+		if (retval != ERROR_OK)
+			return retval;
 		arm_dpm_report_wfar(&armv7a->dpm, wfar);
 	}
 

commit 19925e4d7f4ea3059c05e4ededa2e4f16eca67bf
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Jun 21 13:41:53 2010 +0200

    arm_adi_v5: error propagation fixes
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index aae60fc..b4f49e7 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -603,43 +603,47 @@ int mem_ap_read_buf_u32(struct adiv5_dap *dap, uint8_t *buffer,
 		 */
 
 		/* Scan out first read */
-		adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
+		retval = adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
 				DPAP_READ, 0, NULL, NULL);
+		if (retval != ERROR_OK)
+			return retval;
 		for (readcount = 0; readcount < blocksize - 1; readcount++)
 		{
 			/* Scan out next read; scan in posted value for the
 			 * previous one.  Assumes read is acked "OK/FAULT",
 			 * and CTRL_STAT says that meant "OK".
 			 */
-			adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
+			retval = adi_jtag_dp_scan(dap, JTAG_DP_APACC, AP_REG_DRW,
 					DPAP_READ, 0, buffer + 4 * readcount,
 					&dap->ack);
+			if (retval != ERROR_OK)
+				return retval;
 		}
 
 		/* Scan in last posted value; RDBUFF has no other effect,
 		 * assuming ack is OK/FAULT and CTRL_STAT says "OK".
 		 */
-		adi_jtag_dp_scan(dap, JTAG_DP_DPACC, DP_RDBUFF,
+		retval = adi_jtag_dp_scan(dap, JTAG_DP_DPACC, DP_RDBUFF,
 				DPAP_READ, 0, buffer + 4 * readcount,
 				&dap->ack);
-		if (dap_run(dap) == ERROR_OK)
-		{
-			wcount = wcount - blocksize;
-			address += 4 * blocksize;
-			buffer += 4 * blocksize;
-		}
-		else
-		{
-			errorcount++;
-		}
+		if (retval != ERROR_OK)
+			return retval;
 
-		if (errorcount > 1)
+		retval = dap_run(dap);
+		if (retval != ERROR_OK)
 		{
-			LOG_WARNING("Block read error address 0x%" PRIx32
-				", count 0x%x", address, count);
-			/* REVISIT return the *actual* fault code */
-			return ERROR_JTAG_DEVICE_ERROR;
+			errorcount++;
+			if (errorcount <= 1)
+			{
+				/* try again */
+				continue;
+			}
+			LOG_WARNING("Block read error address 0x%" PRIx32, address);
+			return retval;
 		}
+		wcount = wcount - blocksize;
+		address += 4 * blocksize;
+		buffer += 4 * blocksize;
 	}
 
 	/* if we have an unaligned access - reorder data */

-----------------------------------------------------------------------

Summary of changes:
 .gitignore                                       |    3 +
 src/target/arm_adi_v5.c                          |   40 +++++----
 src/target/cortex_a8.c                           |  104 ++++++++++++++++++----
 tcl/{target/omap3530.cfg => board/am3517evm.cfg} |   53 ++++++++---
 4 files changed, 149 insertions(+), 51 deletions(-)
 copy tcl/{target/omap3530.cfg => board/am3517evm.cfg} (73%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 22 08:24:43 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 22 Jun 2010 06:24:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-383-gf44eeba
Message-ID: <E1OQwub-00028k-5W@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f44eeba16f3e9bebfbc78fd0841124d8b2556246 (commit)
       via  bf8d954352465826e84a245bd4ec8c958eb91c21 (commit)
       via  bef497aeb069314cae3a13dd339a181a3ecf67cd (commit)
      from  fe1f7f63b628ae485609500b8710bfea3bac61a6 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f44eeba16f3e9bebfbc78fd0841124d8b2556246
Author: Edgar Grimberg <edgar.grimberg at zylin.com>
Date:   Mon Jun 21 23:06:15 2010 +0200

    xsvf: Fix shadow issues on Mac
    
    wait is declared in /usr/include/sys/wait.h
    
    Signed-off-by: Edgar Grimberg <edgar.grimberg at zylin.com>

diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
index f4d09ff..157d728 100644
--- a/src/xsvf/xsvf.c
+++ b/src/xsvf/xsvf.c
@@ -760,7 +760,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 				   XWAIT <uint8_t wait_state> <uint8_t end_state> <uint32_t usecs>
 				*/
 
-				uint8_t	wait;
+				uint8_t	wait_local;
 				uint8_t	end;
 				uint8_t	delay_buf[4];
 
@@ -768,7 +768,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 				tap_state_t end_state;
 				int	delay;
 
-				if (read(xsvf_fd, &wait, 1) < 0
+				if (read(xsvf_fd, &wait_local, 1) < 0
 				  || read(xsvf_fd, &end, 1) < 0
 				  || read(xsvf_fd, delay_buf, 4) < 0)
 				{
@@ -776,7 +776,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					break;
 				}
 
-				wait_state = xsvf_to_tap(wait);
+				wait_state = xsvf_to_tap(wait_local);
 				end_state  = xsvf_to_tap(end);
 				delay      = be_to_h_u32(delay_buf);
 
@@ -804,14 +804,14 @@ COMMAND_HANDLER(handle_xsvf_command)
 
 				uint8_t  clock_buf[4];
 				uint8_t	usecs_buf[4];
-				uint8_t	wait;
+				uint8_t	wait_local;
 				uint8_t	end;
 				tap_state_t wait_state;
 				tap_state_t end_state;
 				int clock_count;
 				int usecs;
 
-				if (read(xsvf_fd, &wait, 1) < 0
+				if (read(xsvf_fd, &wait_local, 1) < 0
 				 ||  read(xsvf_fd, &end, 1) < 0
 				 ||  read(xsvf_fd, clock_buf, 4) < 0
 				 ||  read(xsvf_fd, usecs_buf, 4) < 0)
@@ -820,7 +820,7 @@ COMMAND_HANDLER(handle_xsvf_command)
 					break;
 				}
 
-				wait_state = xsvf_to_tap(wait);
+				wait_state = xsvf_to_tap(wait_local);
 				end_state  = xsvf_to_tap(end);
 
 				clock_count = be_to_h_u32(clock_buf);

commit bf8d954352465826e84a245bd4ec8c958eb91c21
Author: Edgar Grimberg <edgar.grimberg at zylin.com>
Date:   Mon Jun 21 23:04:16 2010 +0200

    target: Fix shadow issues on Mac
    
    wait is declared in /usr/include/sys/wait.h
    
    Signed-off-by: Edgar Grimberg <edgar.grimberg at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 9599fec..7513346 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2135,11 +2135,11 @@ COMMAND_HANDLER(handle_halt_command)
 
 	if (CMD_ARGC == 1)
 	{
-		unsigned wait;
-		retval = parse_uint(CMD_ARGV[0], &wait);
+		unsigned wait_local;
+		retval = parse_uint(CMD_ARGV[0], &wait_local);
 		if (ERROR_OK != retval)
 			return ERROR_COMMAND_SYNTAX_ERROR;
-		if (!wait)
+		if (!wait_local)
 			return ERROR_OK;
 	}
 

commit bef497aeb069314cae3a13dd339a181a3ecf67cd
Author: Edgar Grimberg <edgar.grimberg at zylin.com>
Date:   Mon Jun 21 23:02:41 2010 +0200

    flash: fix shadow issues on Mac
    
    Wait is declared in /usr/include/sys/wait.h
    
    Signed-off-by: Edgar Grimberg <edgar.grimberg at zylin.com>

diff --git a/src/flash/mflash.c b/src/flash/mflash.c
index 90e9888..4372128 100644
--- a/src/flash/mflash.c
+++ b/src/flash/mflash.c
@@ -209,7 +209,7 @@ static int mg_init_gpio (void)
 	return ret;
 }
 
-static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time_var)
+static int mg_dsk_wait(mg_io_type_wait wait_local, uint32_t time_var)
 {
 	uint8_t status, error;
 	struct target *target = mflash_bank->target;
@@ -228,10 +228,10 @@ static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time_var)
 
 		if (status & mg_io_rbit_status_busy)
 		{
-			if (wait == mg_io_wait_bsy)
+			if (wait_local == mg_io_wait_bsy)
 				return ERROR_OK;
 		} else {
-			switch (wait)
+			switch (wait_local)
 			{
 				case mg_io_wait_not_bsy:
 					return ERROR_OK;
@@ -259,7 +259,7 @@ static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time_var)
 				return ERROR_MG_IO;
 			}
 
-			switch (wait)
+			switch (wait_local)
 			{
 				case mg_io_wait_rdy:
 					if (status & mg_io_rbit_status_ready)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/mflash.c  |    8 ++++----
 src/target/target.c |    6 +++---
 src/xsvf/xsvf.c     |   12 ++++++------
 3 files changed, 13 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Jun 22 14:35:10 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 22 Jun 2010 12:35:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-387-g4fa3cc7
Message-ID: <E1OR2h6-000739-Of@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4fa3cc7746d661f048f39a53c39b692369426e24 (commit)
       via  d236a48e8fd93504bf219fa9113a3af157ba5e1b (commit)
       via  33e7696cfaca149e83a471212394484054ff05b6 (commit)
       via  8b82171f75df84c1eb51e4824852079cb601df80 (commit)
      from  f44eeba16f3e9bebfbc78fd0841124d8b2556246 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4fa3cc7746d661f048f39a53c39b692369426e24
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 22 12:49:56 2010 +0200

    am3517 evm: use physical write to memory while target is running
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/am3517evm.cfg b/tcl/board/am3517evm.cfg
index a639fa6..db76255 100644
--- a/tcl/board/am3517evm.cfg
+++ b/tcl/board/am3517evm.cfg
@@ -76,20 +76,20 @@ proc omap3_dbginit {target} {
      # General Cortex A8 debug initialisation
      cortex_a8 dbginit
      # Enable DBGU signal for OMAP353x
-     $target mww 0x5401d030 0x00002000
+     $target mww phys 0x5401d030 0x00002000
 }
 
 # be absolutely certain the JTAG clock will work with the worst-case
 # 16.8MHz/2 = 8.4MHz core clock, even before a bootloader kicks in.
 # OK to speed up *after* PLL and clock tree setup.
 
-$_TARGETNAME configure -event "reset-start" { adapter_khz 10; halt; halt }
+$_TARGETNAME configure -event "reset-start" { adapter_khz 10}
 
 # Assume SRST is unavailable (e.g. TI-14 JTAG), so we must assert reset
 # ourselves using PRM_RSTCTRL.  RST_GS (2) is a warm reset, like ICEpick
 # would issue.  RST_DPLL3 (4) is a cold reset.
 set PRM_RSTCTRL 0x48307250
-$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww $PRM_RSTCTRL 2"
+$_TARGETNAME configure -event reset-assert "$_TARGETNAME mww phys $PRM_RSTCTRL 2"
 
 $_TARGETNAME configure -event reset-assert-post "omap3_dbginit $_TARGETNAME; adapter_khz 1000"
 

commit d236a48e8fd93504bf219fa9113a3af157ba5e1b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 22 12:47:30 2010 +0200

    cortex a8: only physical read/write's are available when target is running
    
    Memory read/writes to virtual memory, requires that the CPU is
    halted.
    
    Use 'phys' option to write to memory while target is running.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index ea07579..afe5b6c 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -1381,12 +1381,16 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 {
         int enabled = 0;
         uint32_t virt, phys;
+        int retval;
 
 	/* cortex_a8 handles unaligned memory access */
 
 // ???	dap_ap_select(swjdp, swjdp_memoryap);
         LOG_DEBUG("Reading memory at address 0x%x; size %d; count %d", address, size, count);
-        cortex_a8_mmu(target, &enabled);
+        retval = cortex_a8_mmu(target, &enabled);
+        if (retval != ERROR_OK)
+        	return retval;
+
         if(enabled)
         {
             virt = address;
@@ -1484,11 +1488,14 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 {
         int enabled = 0;
         uint32_t virt, phys;
+        int retval;
 
 // ???  dap_ap_select(swjdp, swjdp_memoryap);
 
         LOG_DEBUG("Writing memory to address 0x%x; size %d; count %d", address, size, count);
-        cortex_a8_mmu(target, &enabled);
+        retval = cortex_a8_mmu(target, &enabled);
+        if (retval != ERROR_OK)
+        	return retval;
         if(enabled)
         {
             virt = address;

commit 33e7696cfaca149e83a471212394484054ff05b6
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 22 12:35:00 2010 +0200

    target: $_TARGET mdw now has a phys option
    
    just like the mdw command
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index d6efe5b..3bf6824 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -4021,23 +4021,36 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
 
-	/* danger! goi.argc will be modified below! */
-	argc = goi.argc;
-
-	if ((argc != 1) && (argc != 2))
+	if ((goi.argc < 1) || (goi.argc > 3))
 	{
 		Jim_SetResult_sprintf(goi.interp,
-				"usage: %s <address> [<count>]", cmd_name);
+				"usage: %s [phys] <address> [<count>]", cmd_name);
 		return JIM_ERR;
 	}
 
+	int (*fn)(struct target *target,
+			uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	fn=target_read_memory;
+
+	int e;
+	if (strcmp(Jim_GetString(argv[1], NULL), "phys") == 0)
+	{
+		/* consume it */
+		struct Jim_Obj *obj;
+		e = Jim_GetOpt_Obj(&goi, &obj);
+		if (e != JIM_OK)
+			return e;
+
+		fn=target_read_phys_memory;
+	}
+
 	jim_wide a;
-	int e = Jim_GetOpt_Wide(&goi, &a);
+	e = Jim_GetOpt_Wide(&goi, &a);
 	if (e != JIM_OK) {
 		return JIM_ERR;
 	}
 	jim_wide c;
-	if (argc == 2) {
+	if (goi.argc == 1) {
 		e = Jim_GetOpt_Wide(&goi, &c);
 		if (e != JIM_OK) {
 			return JIM_ERR;
@@ -4045,6 +4058,13 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	} else {
 		c = 1;
 	}
+
+	/* all args must be consumed */
+	if (goi.argc != 0)
+	{
+		return JIM_ERR;
+	}
+
 	jim_wide b = 1; /* shut up gcc */
 	if (strcasecmp(cmd_name, "mdw") == 0)
 		b = 4;
@@ -4068,7 +4088,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		if (y > 16) {
 			y = 16;
 		}
-		e = target_read_memory(target, a, b, y / b, target_buf);
+		e = fn(target, a, b, y / b, target_buf);
 		if (e != ERROR_OK) {
 			Jim_SetResult_sprintf(interp, "error reading target @ 0x%08lx", (int)(a));
 			return JIM_ERR;

commit 8b82171f75df84c1eb51e4824852079cb601df80
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 22 11:49:00 2010 +0200

    target: mwX on target object now supporst phys argument
    
    $_TARGETNAME mww phys 0x10 0xdeadbeef
    
    => write 0xdeadbeef to physical address 0x10
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 7513346..d6efe5b 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3950,19 +3950,30 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
 
-	/* danger! goi.argc will be modified below! */
-	argc = goi.argc;
-
-	if (argc != 2 && argc != 3)
+	if (goi.argc < 2 || goi.argc > 4)
 	{
 		Jim_SetResult_sprintf(goi.interp,
-				"usage: %s <address> <data> [<count>]", cmd_name);
+				"usage: %s [phys] <address> <data> [<count>]", cmd_name);
 		return JIM_ERR;
 	}
 
+	target_write_fn fn;
+	fn = target_write_memory_fast;
+
+	int e;
+	if (strcmp(Jim_GetString(argv[1], NULL), "phys") == 0)
+	{
+		/* consume it */
+		struct Jim_Obj *obj;
+		e = Jim_GetOpt_Obj(&goi, &obj);
+		if (e != JIM_OK)
+			return e;
+
+		fn = target_write_phys_memory;
+	}
 
 	jim_wide a;
-	int e = Jim_GetOpt_Wide(&goi, &a);
+	e = Jim_GetOpt_Wide(&goi, &a);
 	if (e != JIM_OK)
 		return e;
 
@@ -3972,13 +3983,19 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return e;
 
 	jim_wide c = 1;
-	if (argc == 3)
+	if (goi.argc == 1)
 	{
 		e = Jim_GetOpt_Wide(&goi, &c);
 		if (e != JIM_OK)
 			return e;
 	}
 
+	/* all args must be consumed */
+	if (goi.argc != 0)
+	{
+		return JIM_ERR;
+	}
+
 	struct target *target = Jim_CmdPrivData(goi.interp);
 	unsigned data_size;
 	if (strcasecmp(cmd_name, "mww") == 0) {
@@ -3994,7 +4011,7 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return JIM_ERR;
 	}
 
-	return (target_fill_mem(target, a, target_write_memory_fast, data_size, b, c) == ERROR_OK) ? JIM_OK : JIM_ERR;
+	return (target_fill_mem(target, a, fn, data_size, b, c) == ERROR_OK) ? JIM_OK : JIM_ERR;
 }
 
 static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)

-----------------------------------------------------------------------

Summary of changes:
 src/target/cortex_a8.c  |   11 ++++++-
 src/target/target.c     |   69 ++++++++++++++++++++++++++++++++++++-----------
 tcl/board/am3517evm.cfg |    6 ++--
 3 files changed, 65 insertions(+), 21 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 23 08:01:07 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 23 Jun 2010 06:01:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-388-g6cb2d6d
Message-ID: <E1ORJ1I-0000G2-OW@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6cb2d6dd7ae6049dce47dfb0b7c389dcf606119f (commit)
      from  4fa3cc7746d661f048f39a53c39b692369426e24 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6cb2d6dd7ae6049dce47dfb0b7c389dcf606119f
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed Jun 23 00:53:17 2010 +0800

    error number: review
    
    Review allocation of error numbers in openocd
    to avoid overlap.
    Put brackets around negative numbers to avoid
    issues during macro expansion.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/common.h b/src/flash/common.h
index 4098873..c78f24c 100644
--- a/src/flash/common.h
+++ b/src/flash/common.h
@@ -36,13 +36,13 @@ unsigned get_flash_name_index(const char *name);
  */
 bool flash_driver_name_matches(const char *name, const char *expected);
 
-#define ERROR_FLASH_BANK_INVALID -900
-#define ERROR_FLASH_SECTOR_INVALID -901
-#define ERROR_FLASH_OPERATION_FAILED -902
-#define ERROR_FLASH_DST_OUT_OF_BANK -903
-#define ERROR_FLASH_DST_BREAKS_ALIGNMENT -904
-#define ERROR_FLASH_BUSY -905
-#define ERROR_FLASH_SECTOR_NOT_ERASED -906
-#define ERROR_FLASH_BANK_NOT_PROBED -907
+#define ERROR_FLASH_BANK_INVALID         (-900)
+#define ERROR_FLASH_SECTOR_INVALID       (-901)
+#define ERROR_FLASH_OPERATION_FAILED     (-902)
+#define ERROR_FLASH_DST_OUT_OF_BANK      (-903)
+#define ERROR_FLASH_DST_BREAKS_ALIGNMENT (-904)
+#define ERROR_FLASH_BUSY                 (-905)
+#define ERROR_FLASH_SECTOR_NOT_ERASED    (-906)
+#define ERROR_FLASH_BANK_NOT_PROBED      (-907)
 
 #endif // FLASH_COMMON_H
diff --git a/src/target/trace.h b/src/target/trace.h
index 5fbedc4..53502d4 100644
--- a/src/target/trace.h
+++ b/src/target/trace.h
@@ -59,7 +59,7 @@ typedef enum trace_status
 int trace_point(struct target *target, uint32_t number);
 int trace_register_commands(struct command_context *cmd_ctx);
 
-#define ERROR_TRACE_IMAGE_UNAVAILABLE		-(1500)
-#define ERROR_TRACE_INSTRUCTION_UNAVAILABLE	-(1501)
+#define ERROR_TRACE_IMAGE_UNAVAILABLE		(-1500)
+#define ERROR_TRACE_INSTRUCTION_UNAVAILABLE	(-1501)
 
 #endif /* TRACE_H */
diff --git a/src/target/xscale.h b/src/target/xscale.h
index 82f4e37..d429336 100644
--- a/src/target/xscale.h
+++ b/src/target/xscale.h
@@ -176,6 +176,6 @@ enum
 	XSCALE_TXRXCTRL,
 };
 
-#define ERROR_XSCALE_NO_TRACE_DATA	(-1500)
+#define ERROR_XSCALE_NO_TRACE_DATA	(-700)
 
 #endif /* XSCALE_H */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/common.h  |   16 ++++++++--------
 src/target/trace.h  |    4 ++--
 src/target/xscale.h |    2 +-
 3 files changed, 11 insertions(+), 11 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 23 11:10:18 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 23 Jun 2010 09:10:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-389-ge5d1bef
Message-ID: <E1ORLyO-0001CN-Fu@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e5d1befe43c1d666551cf2bc93de276d4e997476 (commit)
      from  6cb2d6dd7ae6049dce47dfb0b7c389dcf606119f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e5d1befe43c1d666551cf2bc93de276d4e997476
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Jun 23 10:47:54 2010 +0200

    arm11: fix gaffe in no-ack transfers
    
    The code did not transfer the last word in no-ack transfers.
    
    The strange thing is that this did not lead to any
    observable errors.
    
    This gaffe was introduced in commit 1f5883ea56cb058221f
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 9ecd08f..b2c6287 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -679,7 +679,7 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opc
 
 	int retval = arm11_run_instr_data_to_core_noack_inner(arm11->arm.target->tap, opcode, data, count);
 
-	if (retval != ERROR_FAIL)
+	if (retval != ERROR_OK)
 		return retval;
 
 	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11_dbgtap.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Jun 23 11:46:21 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 23 Jun 2010 09:46:21 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-390-gfb96b86
Message-ID: <E1ORMXI-0003Hj-0s@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fb96b8607a0c2a9038df3352b0ef828d78c5e418 (commit)
      from  e5d1befe43c1d666551cf2bc93de276d4e997476 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fb96b8607a0c2a9038df3352b0ef828d78c5e418
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Jun 22 13:02:00 2010 +0200

    openocd: setup_command_handler() must not be static
    
    when OpenOCD is linked with an app this fn can be used from
    the outside.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/openocd.c b/src/openocd.c
index 623bd0c..96de50c 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -209,8 +209,10 @@ static int openocd_register_commands(struct command_context *cmd_ctx)
 
 struct command_context *global_cmd_ctx;
 
-/* NB! this fn can be invoked outside this file for non PC hosted builds */
-static struct command_context *setup_command_handler(Jim_Interp *interp)
+/* NB! this fn can be invoked outside this file for non PC hosted builds
+ * NB! do not change to 'static'!!!!
+ */
+struct command_context *setup_command_handler(Jim_Interp *interp)
 {
 	log_init();
 	LOG_DEBUG("log_init: complete");

-----------------------------------------------------------------------

Summary of changes:
 src/openocd.c |    6 ++++--
 1 files changed, 4 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Jun 25 21:38:09 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 25 Jun 2010 19:38:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-391-g2986320
Message-ID: <E1OSEj8-0000AN-3y@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2986320cde399b0b0ee006a4fecbdec83bebc248 (commit)
      from  fb96b8607a0c2a9038df3352b0ef828d78c5e418 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2986320cde399b0b0ee006a4fecbdec83bebc248
Author: Olaf L??ke <olaf at uni-paderborn.de>
Date:   Fri Jun 25 20:21:31 2010 +0200

    at91sam3s* support
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 8fa6dd4..221832c 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -2,6 +2,10 @@
  *   Copyright (C) 2009 by Duane Ellis                                     *
  *   openocd at duaneellis.com                                                *
  *                                                                         *
+ *   Copyright (C) 2010 by Olaf L??ke (at91sam3s* support)                  *
+ *   olaf at uni-paderborn.de                                                 *
+ *                                                                         *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -63,9 +67,12 @@
 
 #define REG_NAME_WIDTH  (12)
 
+// at91sam3u series (has one or two flash banks)
+#define FLASH_BANK0_BASE_U   0x00080000
+#define FLASH_BANK1_BASE_U   0x00100000
 
-#define FLASH_BANK0_BASE   0x00080000
-#define FLASH_BANK1_BASE   0x00100000
+// at91sam3s series (has always one flash bank)
+#define FLASH_BANK_BASE_S   0x00400000
 
 #define 	AT91C_EFC_FCMD_GETD                 (0x0) // (EFC) Get Flash Descriptor
 #define 	AT91C_EFC_FCMD_WP                   (0x1) // (EFC) Write Page
@@ -254,6 +261,7 @@ get_current_sam3(struct command_context *cmd_ctx)
 
 // these are used to *initialize* the "pChip->details" structure.
 static const struct sam3_chip_details all_sam3_details[] = {
+	// Start at91sam3u* series
 	{
 		.chipid_cidr    = 0x28100960,
 		.name           = "at91sam3u4e",
@@ -284,7 +292,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE,
+			.base_address = FLASH_BANK0_BASE_U,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -299,7 +307,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 1,
-			.base_address = FLASH_BANK1_BASE,
+			.base_address = FLASH_BANK1_BASE_U,
 			.controller_address = 0x400e0a00,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -333,7 +341,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE,
+			.base_address = FLASH_BANK0_BASE_U,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -374,7 +382,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE,
+			.base_address = FLASH_BANK0_BASE_U,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes =  64 * 1024,
@@ -422,7 +430,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE,
+			.base_address = FLASH_BANK0_BASE_U,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -436,7 +444,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 1,
-			.base_address = FLASH_BANK1_BASE,
+			.base_address = FLASH_BANK1_BASE_U,
 			.controller_address = 0x400e0a00,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -470,7 +478,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE,
+			.base_address = FLASH_BANK0_BASE_U,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -511,7 +519,7 @@ static const struct sam3_chip_details all_sam3_details[] = {
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE,
+			.base_address = FLASH_BANK0_BASE_U,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes =  64 * 1024,
@@ -529,6 +537,300 @@ static const struct sam3_chip_details all_sam3_details[] = {
 		},
 	},
 
+	// Start at91sam3s* series
+
+	// Note: The preliminary at91sam3s datasheet says on page 302
+	// that the flash controller is at address 0x400E0800.
+	// This is _not_ the case, the controller resides at address 0x400e0a0.
+	{
+		.chipid_cidr    = 0x28A00960,
+		.name           = "at91sam3s4c",
+		.total_flash_size     = 256 * 1024,
+		.total_sram_size      = 48 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  256 * 1024,
+			.nsectors   =  32,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+
+	{
+		.chipid_cidr    = 0x28900960,
+		.name           = "at91sam3s4b",
+		.total_flash_size     = 256 * 1024,
+		.total_sram_size      = 48 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  256 * 1024,
+			.nsectors   =  32,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	{
+		.chipid_cidr    = 0x28800960,
+		.name           = "at91sam3s4a",
+		.total_flash_size     = 256 * 1024,
+		.total_sram_size      = 48 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  256 * 1024,
+			.nsectors   =  32,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	{
+		.chipid_cidr    = 0x28AA0760,
+		.name           = "at91sam3s2c",
+		.total_flash_size     = 128 * 1024,
+		.total_sram_size      = 32 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  128 * 1024,
+			.nsectors   =  16,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	{
+		.chipid_cidr    = 0x289A0760,
+		.name           = "at91sam3s2b",
+		.total_flash_size     = 128 * 1024,
+		.total_sram_size      = 32 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  128 * 1024,
+			.nsectors   =  16,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	{
+		.chipid_cidr    = 0x288A0760,
+		.name           = "at91sam3s2a",
+		.total_flash_size     = 128 * 1024,
+		.total_sram_size      = 32 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  128 * 1024,
+			.nsectors   =  16,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	{
+		.chipid_cidr    = 0x28A90560,
+		.name           = "at91sam3s1c",
+		.total_flash_size     = 64 * 1024,
+		.total_sram_size      = 16 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  64 * 1024,
+			.nsectors   =  8,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	{
+		.chipid_cidr    = 0x28990560,
+		.name           = "at91sam3s1b",
+		.total_flash_size     = 64 * 1024,
+		.total_sram_size      = 16 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  64 * 1024,
+			.nsectors   =  8,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
+	{
+		.chipid_cidr    = 0x28890560,
+		.name           = "at91sam3s1a",
+		.total_flash_size     = 64 * 1024,
+		.total_sram_size      = 16 * 1024,
+		.n_gpnvms       = 2,
+		.n_banks        = 1,
+		{
+//		.bank[0] = {
+		  {
+			.probed = 0,
+			.pChip  = NULL,
+			.pBank  = NULL,
+			.bank_number = 0,
+			.base_address = FLASH_BANK_BASE_S,
+
+			.controller_address = 0x400e0a00,
+			.present = 1,
+			.size_bytes =  64 * 1024,
+			.nsectors   =  8,
+			.sector_size = 8192,
+			.page_size   = 256,
+		  },
+//		.bank[1] = {
+		  {
+			.present = 0,
+			.probed = 0,
+			.bank_number = 1,
+
+		  },
+		},
+	},
 	// terminate
 	{
 		.chipid_cidr	= 0,
@@ -1648,23 +1950,34 @@ FLASH_BANK_COMMAND_HANDLER(sam3_flash_bank_command)
 
 	switch (bank->base) {
 	default:
-		LOG_ERROR("Address 0x%08x invalid bank address (try 0x%08x or 0x%08x)",
+		LOG_ERROR("Address 0x%08x invalid bank address (try 0x%08x or 0x%08x \
+			[at91sam3u series] or 0x%08x [at91sam3s series])",
 				  ((unsigned int)(bank->base)),
-				  ((unsigned int)(FLASH_BANK0_BASE)),
-				  ((unsigned int)(FLASH_BANK1_BASE)));
+				  ((unsigned int)(FLASH_BANK0_BASE_U)),
+				  ((unsigned int)(FLASH_BANK1_BASE_U)),
+				  ((unsigned int)(FLASH_BANK_BASE_S)));
 		return ERROR_FAIL;
 		break;
-	case FLASH_BANK0_BASE:
+
+	// at91sam3u series
+	case FLASH_BANK0_BASE_U:
 		bank->driver_priv = &(pChip->details.bank[0]);
 		bank->bank_number = 0;
 		pChip->details.bank[0].pChip = pChip;
 		pChip->details.bank[0].pBank = bank;
 		break;
-	case FLASH_BANK1_BASE:
+	case FLASH_BANK1_BASE_U:
 		bank->driver_priv = &(pChip->details.bank[1]);
 		bank->bank_number = 1;
 		pChip->details.bank[1].pChip = pChip;
 		pChip->details.bank[1].pBank = bank;
+
+	// at91sam3s series
+	case FLASH_BANK_BASE_S:
+		bank->driver_priv = &(pChip->details.bank[0]);
+		bank->bank_number = 0;
+		pChip->details.bank[0].pChip = pChip;
+		pChip->details.bank[0].pBank = bank;
 		break;
 	}
 
diff --git a/tcl/board/atmel_sam3s_ek.cfg b/tcl/board/atmel_sam3s_ek.cfg
new file mode 100644
index 0000000..38b54b7
--- /dev/null
+++ b/tcl/board/atmel_sam3s_ek.cfg
@@ -0,0 +1,3 @@
+source [find target/at91sam3sXX.cfg]
+
+$_TARGETNAME configure -event gdb-attach { reset init }
diff --git a/tcl/target/at91sam3uXX.cfg b/tcl/target/at91sam3XXX.cfg
similarity index 78%
copy from tcl/target/at91sam3uXX.cfg
copy to tcl/target/at91sam3XXX.cfg
index b948c64..517a871 100644
--- a/tcl/target/at91sam3uXX.cfg
+++ b/tcl/target/at91sam3XXX.cfg
@@ -1,11 +1,21 @@
 # script for ATMEL sam3, a CORTEX-M3 chip
 #
-#  at91sam3u4e
-#  at91sam3u2e
-#  at91sam3u1e
-#  at91sam3u4c
-#  at91sam3u2c
-#  at91sam3u1c
+# at91sam3u4e
+# at91sam3u2e
+# at91sam3u1e
+# at91sam3u4c
+# at91sam3u2c
+# at91sam3u1c
+#
+# at91sam3s4c
+# at91sam3s4b
+# at91sam3s4a
+# at91sam3s2c
+# at91sam3s2b
+# at91sam3s2a
+# at91sam3s1c
+# at91sam3s1b
+# at91sam3s1a
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
diff --git a/tcl/target/at91sam3sXX.cfg b/tcl/target/at91sam3sXX.cfg
new file mode 100644
index 0000000..ca7092b
--- /dev/null
+++ b/tcl/target/at91sam3sXX.cfg
@@ -0,0 +1,16 @@
+# script for ATMEL sam3, a CORTEX-M3 chip
+#
+# at91sam3s4c
+# at91sam3s4b
+# at91sam3s4a
+# at91sam3s2c
+# at91sam3s2b
+# at91sam3s2a
+# at91sam3s1c
+# at91sam3s1b
+# at91sam3s1a
+
+source [find target/at91sam3XXX.cfg]
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME at91sam3 0x00400000 0 1 1 $_TARGETNAME
diff --git a/tcl/target/at91sam3uXX.cfg b/tcl/target/at91sam3uXX.cfg
index b948c64..a11afc0 100644
--- a/tcl/target/at91sam3uXX.cfg
+++ b/tcl/target/at91sam3uXX.cfg
@@ -1,40 +1,11 @@
 # script for ATMEL sam3, a CORTEX-M3 chip
 #
-#  at91sam3u4e
-#  at91sam3u2e
-#  at91sam3u1e
-#  at91sam3u4c
-#  at91sam3u2c
-#  at91sam3u1c
+# at91sam3u4e
+# at91sam3u2e
+# at91sam3u1e
+# at91sam3u4c
+# at91sam3u2c
+# at91sam3u1c
 
-if { [info exists CHIPNAME] } {
-   set  _CHIPNAME $CHIPNAME
-} else {
-   set  _CHIPNAME sam3
-}
+source [find target/at91sam3XXX.cfg]
 
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
-
-#jtag scan chain
-if { [info exists CPUTAPID ] } {
-   set _CPUTAPID $CPUTAPID
-} else {
-   set _CPUTAPID 0x4ba00477
-}
-
-jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
-
-set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNAME
-
-# 16K is plenty, the smallest chip has this much
-$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size 16384 -work-area-backup 0
-
-$_TARGETNAME configure -event gdb-flash-erase-start {
-    halt
-}

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/at91sam3.c                        |  343 ++++++++++++++++++++++-
 tcl/board/atmel_sam3s_ek.cfg                    |    3 +
 tcl/target/{at91sam3uXX.cfg => at91sam3XXX.cfg} |   22 +-
 tcl/target/at91sam3sXX.cfg                      |   16 +
 tcl/target/at91sam3uXX.cfg                      |   43 +---
 5 files changed, 370 insertions(+), 57 deletions(-)
 create mode 100644 tcl/board/atmel_sam3s_ek.cfg
 copy tcl/target/{at91sam3uXX.cfg => at91sam3XXX.cfg} (78%)
 create mode 100644 tcl/target/at91sam3sXX.cfg


hooks/post-receive
-- 
Main OpenOCD repository


