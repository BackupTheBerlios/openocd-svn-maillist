<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-129-g9ddb94c
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-October/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-129-g9ddb94c&In-Reply-To=%3Cmailman.206.1331736158.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002720.html">
   <LINK REL="Next"  HREF="002722.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-129-g9ddb94c</H1>
    <B>OpenOCD-Gerrit</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-129-g9ddb94c&In-Reply-To=%3Cmailman.206.1331736158.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-129-g9ddb94c">openocd-gerrit at users.sourceforge.net
       </A><BR>
    <I>Wed Oct 19 13:05:56 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002720.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-128-g36e3009
</A></li>
        <LI>Next message: <A HREF="002722.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-130-g1c1771e
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2721">[ date ]</a>
              <a href="thread.html#2721">[ thread ]</a>
              <a href="subject.html#2721">[ subject ]</a>
              <a href="author.html#2721">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  9ddb94c1f3227b4fc693e9aaba5df0ee4f9171e6 (commit)
      from  36e3009ff9ddd449a394b8e4aed0cc68c77b5a4b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9ddb94c1f3227b4fc693e9aaba5df0ee4f9171e6
Author: Marc Willam / Holger Wech &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">openocd.fseu at de.fujitsu.com</A>&gt;
Date:   Thu Oct 13 14:43:06 2011 +0100

    Updated fm3.c, added Flash type 2 support, error handling improved
    
    Change-Id: I684aca11c4554290d0e57c6d3318d8082980c1ef
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
    Signed-off-by: Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">ntfreak at users.sourceforge.net</A>&gt;
    Reviewed-on: <A HREF="http://openocd.zylin.com/10">http://openocd.zylin.com/10</A>
    Tested-by: jenkins
    Reviewed-by: Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;

diff --git a/src/flash/nor/fm3.c b/src/flash/nor/fm3.c
index a584964..1e2adf5 100644
--- a/src/flash/nor/fm3.c
+++ b/src/flash/nor/fm3.c
@@ -1,6 +1,7 @@
 /***************************************************************************
  *   Copyright (C) 2011 by Marc Willam, Holger Wech                        *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">m.willam at gmx.eu</A>                                                       *
+ *   openOCD.fseu(AT)de.fujitsu.com                                        *
+ *                                                                         *
  *   Copyright (C) 2011 Ronny Strutz                                       *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -18,6 +19,7 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
+
 #ifdef HAVE_CONFIG_H
 #include &quot;config.h&quot;
 #endif
@@ -27,23 +29,37 @@
 #include &lt;target/algorithm.h&gt;
 #include &lt;target/armv7m.h&gt;
 
-#define FLASH_DQ6 0x00000040	/* Data toggle flag bit (TOGG) position */
-#define FLASH_DQ5 0x00000020	/* Time limit exceeding flag bit (TLOV) position */
+#define FLASH_DQ6 0x00000040	/* Data toggle flag bit (TOGG) */
+#define FLASH_DQ5 0x00000020	/* Time limit exceeding flag bit (TLOV) */
 
 enum fm3_variant
 {
-	mb9bfxx1,
+	mb9bfxx1,	/* Flash Type '1' */
 	mb9bfxx2,
 	mb9bfxx3,
 	mb9bfxx4,
 	mb9bfxx5,
-	mb9bfxx6
+	mb9bfxx6,
+	mb9afxx1,	/* Flash Type '2' */
+	mb9afxx2,
+	mb9afxx3,
+	mb9afxx4,
+	mb9afxx5,
+	mb9afxx6
+};
+
+enum fm3_flash_type
+{
+	fm3_no_flash_type = 0,
+	fm3_flash_type1   = 1,
+	fm3_flash_type2   = 2
 };
 
 struct fm3_flash_bank
 {
 	struct working_area *write_algorithm;
 	enum fm3_variant variant;
+	enum fm3_flash_type flashtype;
 	int probed;
 };
 
@@ -57,36 +73,74 @@ FLASH_BANK_COMMAND_HANDLER(fm3_flash_bank_command)
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
-	LOG_INFO(&quot;******HWE* FLASH CMD Parameter %s&quot;, CMD_ARGV[5]);
-
 	fm3_info = malloc(sizeof(struct fm3_flash_bank));
 	bank-&gt;driver_priv = fm3_info;
 
+	/* Flash type '1' */
 	if (strcmp(CMD_ARGV[5], &quot;mb9bfxx1.cpu&quot;) == 0)
 	{
 		fm3_info-&gt;variant = mb9bfxx1;
+		fm3_info-&gt;flashtype = fm3_flash_type1;
 	}
 	else if (strcmp(CMD_ARGV[5], &quot;mb9bfxx2.cpu&quot;) == 0)
 	{
 		fm3_info-&gt;variant = mb9bfxx2;
+		fm3_info-&gt;flashtype = fm3_flash_type1;
 	}
 	else if (strcmp(CMD_ARGV[5], &quot;mb9bfxx3.cpu&quot;) == 0)
 	{
 		fm3_info-&gt;variant = mb9bfxx3;
+		fm3_info-&gt;flashtype = fm3_flash_type1;
 	}
 	else if (strcmp(CMD_ARGV[5], &quot;mb9bfxx4.cpu&quot;) == 0)
 	{
 		fm3_info-&gt;variant = mb9bfxx4;
+		fm3_info-&gt;flashtype = fm3_flash_type1;
 	}
 	else if (strcmp(CMD_ARGV[5], &quot;mb9bfxx5.cpu&quot;) == 0)
 	{
 		fm3_info-&gt;variant = mb9bfxx5;
+		fm3_info-&gt;flashtype = fm3_flash_type1;
 	}
 	else if (strcmp(CMD_ARGV[5], &quot;mb9bfxx6.cpu&quot;) == 0)
 	{
 		fm3_info-&gt;variant = mb9bfxx6;
-		LOG_INFO(&quot;******HWE* fm3 Variant set to: mb9bfxx6&quot;);
+		fm3_info-&gt;flashtype = fm3_flash_type1;
+	}
+
+	/* Flash type '2' */
+	else if (strcmp(CMD_ARGV[5], &quot;mb9afxx1.cpu&quot;) == 0)
+	{
+		fm3_info-&gt;variant = mb9afxx1;
+		fm3_info-&gt;flashtype = fm3_flash_type2;
+	}
+	else if (strcmp(CMD_ARGV[5], &quot;mb9afxx2.cpu&quot;) == 0)
+	{
+		fm3_info-&gt;variant = mb9afxx2;
+		fm3_info-&gt;flashtype = fm3_flash_type2;
+	}
+	else if (strcmp(CMD_ARGV[5], &quot;mb9afxx3.cpu&quot;) == 0)
+	{
+		fm3_info-&gt;variant = mb9afxx3;
+		fm3_info-&gt;flashtype = fm3_flash_type2;
+	}
+	else if (strcmp(CMD_ARGV[5], &quot;mb9afxx4.cpu&quot;) == 0)
+	{
+		fm3_info-&gt;variant = mb9afxx4;
+		fm3_info-&gt;flashtype = fm3_flash_type2;
+	}
+	else if (strcmp(CMD_ARGV[5], &quot;mb9afxx5.cpu&quot;) == 0)
+	{
+		fm3_info-&gt;variant = mb9afxx5;
+		fm3_info-&gt;flashtype = fm3_flash_type2;
+	}
+	else if (strcmp(CMD_ARGV[5], &quot;mb9afxx6.cpu&quot;) == 0)
+	{
+		fm3_info-&gt;variant = mb9afxx6;
+		fm3_info-&gt;flashtype = fm3_flash_type2;
 	}
+
+	/* unknown Flash type */
 	else
 	{
 		LOG_ERROR(&quot;unknown fm3 variant: %s&quot;, CMD_ARGV[5]);
@@ -100,34 +154,68 @@ FLASH_BANK_COMMAND_HANDLER(fm3_flash_bank_command)
 	return ERROR_OK;
 }
 
+/* Data polling algorithm */
 static int fm3_busy_wait(struct target *target, uint32_t offset, int timeout_ms)
 {
 	int retval = ERROR_OK;
 	uint16_t state1, state2;
 	int ms = 0;
 
-	while(1) {
-		target_read_u16(target, offset, &amp;state1);	/* dummy-read - see flash manual */
-		target_read_u16(target, offset, &amp;state1);
-		target_read_u16(target, offset, &amp;state2);
+	/* While(1) loop exit via &quot;break&quot; and &quot;return&quot; on error */
+	while(1)
+	{
+		/* dummy-read - see flash manual */
+		retval = target_read_u16(target, offset, &amp;state1);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* Data polling 1 */
+		retval = target_read_u16(target, offset, &amp;state1);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* Data polling 2 */
+		retval = target_read_u16(target, offset, &amp;state2);
+		if (retval != ERROR_OK)
+			return retval;
 
-		if ( (state1 &amp; FLASH_DQ6) == (state2 &amp; FLASH_DQ6) ) {
+		/* Flash command finished via polled data equal? */
+		if ( (state1 &amp; FLASH_DQ6) == (state2 &amp; FLASH_DQ6) )
+		{
 			break;
 		}
-		else if (state1 &amp; FLASH_DQ5) {
-			target_read_u16(target, offset, &amp;state1);
-			target_read_u16(target, offset, &amp;state2);
+		/* Timeout Flag? */
+		else if (state1 &amp; FLASH_DQ5)
+		{
+			/* Retry data polling */
+
+			/* Data polling 1 */
+			retval = target_read_u16(target, offset, &amp;state1);
+			if (retval != ERROR_OK)
+				return retval;
+
+			/* Data polling 2 */
+			retval = target_read_u16(target, offset, &amp;state2);
+			if (retval != ERROR_OK)
+				return retval;
+
+			/* Flash command finished via polled data equal? */
 			if ( (state1 &amp; FLASH_DQ6) != (state2 &amp; FLASH_DQ6) )
-				retval = ERROR_FLASH_OPERATION_FAILED;
+			{
+				return ERROR_FLASH_OPERATION_FAILED;
+			}
+
+			/* finish anyway */
 			break;
 		}
 		usleep(1000);
 		++ms;
 
-		if (ms &gt; timeout_ms) {
-			LOG_ERROR(&quot;toggle bit reading timed out!&quot;);
-			retval = ERROR_FLASH_OPERATION_FAILED;
-			break;
+		/* Polling time exceeded? */
+		if (ms &gt; timeout_ms)
+		{
+			LOG_ERROR(&quot;Polling data reading timed out!&quot;);
+			return ERROR_FLASH_OPERATION_FAILED;
 		}
 	}
 
@@ -139,10 +227,32 @@ static int fm3_busy_wait(struct target *target, uint32_t offset, int timeout_ms)
 
 static int fm3_erase(struct flash_bank *bank, int first, int last)
 {
+	struct fm3_flash_bank *fm3_info = bank-&gt;driver_priv;
 	struct target *target = bank-&gt;target;
 	int retval = ERROR_OK;
 	uint32_t u32DummyRead;
 	int sector, odd;
+	uint32_t u32FlashType;
+	uint32_t u32FlashSeqAddress1;
+	uint32_t u32FlashSeqAddress2;
+
+	u32FlashType = (uint32_t) fm3_info-&gt;flashtype;
+
+	if (u32FlashType == fm3_flash_type1)
+	{
+		u32FlashSeqAddress1 = 0x00001550;
+		u32FlashSeqAddress2 = 0x00000AA8;
+	}
+	else if (u32FlashType == fm3_flash_type2)
+	{
+		u32FlashSeqAddress1 = 0x00000AA8;
+		u32FlashSeqAddress2 = 0x00000554;
+	}
+	else
+	{
+		LOG_ERROR(&quot;Flash/Device type unknown!&quot;);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
 
 	if (target-&gt;state != TARGET_HALTED) {
 		LOG_ERROR(&quot;Target not halted&quot;);
@@ -151,180 +261,248 @@ static int fm3_erase(struct flash_bank *bank, int first, int last)
 
 	LOG_INFO(&quot;Fujitsu MB9Bxxx: Sector Erase ... (%d to %d)&quot;, first, last);
 
-	target_write_u32(target, 0x40000000, 0x0001);		/* FASZR = 0x01, Enables CPU Programming Mode */
-	target_read_u32(target, 0x40000000, &amp;u32DummyRead); /* dummy read of FASZR */
+	/* FASZR = 0x01, Enables CPU Programming Mode (16-bit Flash acccess) */
+	retval = target_write_u32(target, 0x40000000, 0x0001);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* dummy read of FASZR */
+	retval = target_read_u32(target, 0x40000000, &amp;u32DummyRead);
+	if (retval != ERROR_OK)
+		return retval;
 
-	for (sector = first ; sector &lt;= last ; sector++) {
+	for (sector = first ; sector &lt;= last ; sector++)
+	{
 		uint32_t offset = bank-&gt;sectors[sector].offset;
 
-		for (odd = 0; odd &lt; 2 ; odd++) {
-
+		for (odd = 0; odd &lt; 2 ; odd++)
+		{
 			if (odd)
 				offset += 4;
 
-			target_write_u16(target, 0x1550, 0x00AA);
-			target_write_u16(target, 0x0AA8, 0x0055);
-			target_write_u16(target, 0x1550, 0x0080);
-			target_write_u16(target, 0x1550, 0x00AA);
-			target_write_u16(target, 0x0AA8, 0x0055);
-			target_write_u16(target, offset, 0x0030);
+			/* Flash unlock sequence */
+			retval = target_write_u16(target, u32FlashSeqAddress1, 0x00AA);
+			if (retval != ERROR_OK)
+				return retval;
 
-			retval = fm3_busy_wait(target, offset, 500);
+			retval = target_write_u16(target, u32FlashSeqAddress2, 0x0055);
+			if (retval != ERROR_OK)
+				return retval;
 
+			retval = target_write_u16(target, u32FlashSeqAddress1, 0x0080);
 			if (retval != ERROR_OK)
-				break;
+				return retval;
+
+			retval = target_write_u16(target, u32FlashSeqAddress1, 0x00AA);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = target_write_u16(target, u32FlashSeqAddress2, 0x0055);
+			if (retval != ERROR_OK)
+				return retval;
+
+			/* Sector erase command (0x0030) */
+			retval = target_write_u16(target, offset, 0x0030);
+			if (retval != ERROR_OK)
+				return retval;
+
+			retval = fm3_busy_wait(target, offset, 500);
+			if (retval != ERROR_OK)
+				return retval;
 		}
 		bank-&gt;sectors[sector].is_erased = 1;
 	}
 
-	target_write_u32(target, 0x40000000, 0x0002);
-	target_read_u32(target, 0x40000000, &amp;u32DummyRead); /* dummy read of FASZR */
+	/* FASZR = 0x02, Enables CPU Run Mode (32-bit Flash acccess) */
+	retval = target_write_u32(target, 0x40000000, 0x0002);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* dummy read of FASZR */
+	retval = target_read_u32(target, 0x40000000, &amp;u32DummyRead);
 
 	return retval;
 }
 
-static int fm3_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+static int fm3_write_block(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
 {
 	struct fm3_flash_bank *fm3_info = bank-&gt;driver_priv;
 	struct target *target = bank-&gt;target;
-	uint32_t buffer_size = 8192;
+	uint32_t buffer_size = 2048;		/* 8192 for MB9Bxx6! */
 	struct working_area *source;
 	uint32_t address = bank-&gt;base + offset;
-	struct reg_param reg_params[4];
+	struct reg_param reg_params[6];
 	struct armv7m_algorithm armv7m_info;
 	int retval = ERROR_OK;
+	uint32_t u32FlashType;
+	uint32_t u32FlashSeqAddress1;
+	uint32_t u32FlashSeqAddress2;
+
+	u32FlashType = (uint32_t) fm3_info-&gt;flashtype;
+
+	if (u32FlashType == fm3_flash_type1)
+	{
+		u32FlashSeqAddress1 = 0x00001550;
+		u32FlashSeqAddress2 = 0x00000AA8;
+	}
+	else if (u32FlashType == fm3_flash_type2)
+	{
+		u32FlashSeqAddress1 = 0x00000AA8;
+		u32FlashSeqAddress2 = 0x00000554;
+	}
+	else
+	{
+		LOG_ERROR(&quot;Flash/Device type unknown!&quot;);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
 
 	/* RAMCODE used for fm3 Flash programming:                 */
 	/* R0 keeps source start address         (u32Source)       */
 	/* R1 keeps target start address         (u32Target)       */
 	/* R2 keeps number of halfwords to write (u32Count)        */
-	/* R3 returns result value               (u32FlashResult)  */
+	/* R3 keeps Flash Sequence address 1     (u32FlashSeq1)    */
+	/* R4 keeps Flash Sequence address 2     (u32FlashSeq2)    */
+	/* R5 returns result value               (u32FlashResult)  */
 
 	const uint8_t fm3_flash_write_code[] = {
-								/*    fm3_FLASH_IF-&gt;FASZ &amp;= 0xFFFD;                               */
-	0x00, 0xBF,                 /*        NOP                                                     */
-	0x5F, 0xF0, 0x80, 0x43,     /*        MOVS.W   R3, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	0x4F, 0xF6, 0xFD, 0x74,     /*        MOVW     R4, #0xFFFD                                    */
-	0x23, 0x40,                 /*        ANDS     R3, R3, R4                                     */
-	0x5F, 0xF0, 0x80, 0x44,     /*        MOVS.W   R4, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x23, 0x60,                 /*        STR      R3, [R4]                                       */
-								/*    fm3_FLASH_IF-&gt;FASZ |= 1;                                    */
-	0x5F, 0xF0, 0x80, 0x43,     /*        MOVS.W   R3, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	0x53, 0xF0, 0x01, 0x03,     /*        ORRS.W   R3, R3, #1                                     */
-	0x5F, 0xF0, 0x80, 0x44,     /*        MOVS.W   R4, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x23, 0x60,                 /*        STR      R3, [R4]                                       */
-	                            /*    u32DummyRead = fm3_FLASH_IF-&gt;FASZ;                          */
-	0x2B, 0x4B,                 /*        LDR.N    R3, ??u32DummyRead                             */
-	0x5F, 0xF0, 0x80, 0x44,     /*        MOVS.W   R4, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x24, 0x68,                 /*        LDR      R4, [R4]                                       */
-	0x1C, 0x60,                 /*        STR      R4, [R3]                                       */
-	                            /*    u32FlashResult = FLASH_WRITE_NO_RESULT                      */
-	0x2A, 0x4B,                 /*        LDR.N    R3, ??u32FlashResult                           */
-	0x00, 0x24,                 /*        MOVS     R4, #0                                         */
-	0x1C, 0x60,                 /*        STR      R4, [R3]                                       */
-	                            /*    while ((u32Count &gt; 0 ) &amp;&amp; (u32FlashResult                   */
-	                            /*      == FLASH_WRITE_NO_RESULT))                                */
-	0x01, 0x2A,                 /* L0:    CMP      R2, #1                                         */
-	0x32, 0xDB,                 /*        BLT.N    L1                                             */
-	0x27, 0x4B,                 /*        LDR.N    R3, ??u32FlashResult                           */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	0x00, 0x2B,                 /*        CMP      R3, #0                                         */
-	0x2E, 0xD1,                 /*        BNE.N    L1                                             */
-	                            /*    *(FLASH_SEQ_1550) = FLASH_WRITE_1;                          */
-	0x41, 0xF2, 0x50, 0x53,     /*        MOVW     R3, #0x1550                                    */
-	0xAA, 0x24,                 /*        MOVS     R4. #0xAA                                      */
-	0x1C, 0x80,                 /*        STRH     R4, [R3]                                       */
-	                            /*    *(FLASH_SEQ_0AA8) = FLASH_WRITE_2;                          */
-	0x40, 0xF6, 0xA8, 0x23,     /*        MOVW     R3, #0x0AA8                                    */
-	0x55, 0x24,                 /*        MOVS     R4. #0x55                                      */
-	0x1C, 0x80,                 /*        STRH     R4, [R3]                                       */
-	                            /*    *(FLASH_SEQ_1550) = FLASH_WRITE_3;                          */
-	0x41, 0xF2, 0x50, 0x53,     /*        MOVW     R3, #0x1550                                    */
-	0xA0, 0x24,                 /*        MOVS     R4. #0xA0                                      */
-	0x1C, 0x80,                 /*        STRH     R4, [R3]                                       */
-	                            /*    *(volatile uint16_t*)u32Target                              */
-	                            /*      = *(volatile uint16_t*)u32Source;                         */
-	0x03, 0x88,                 /*        LDRH     R3, [R0]                                       */
-	0x0B, 0x80,                 /*        STRH     R3, [R1]                                       */
-	                            /*    while (u32FlashResult == FLASH_WRITE_NO_RESTULT)            */
-	0x1E, 0x4B,                 /* L2:    LDR.N    R3, ??u32FlashResult                           */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	0x00, 0x2B,                 /*        CMP      R3, #0                                         */
-	0x11, 0xD1,                 /*        BNE.N    L3                                             */
-	                            /*    if ((*(volatile uint16_t*)u32Target &amp; FLASH_DQ5)             */
-	                            /*      == FLASH_DQ5)                                             */
-	0x0B, 0x88,                 /*        LDRH     R3, [R1]                                       */
-	0x9B, 0x06,                 /*        LSLS     R3, R3, #0x1A                                  */
-	0x02, 0xD5,                 /*        BPL.N    L4                                             */
-	                            /*    u32FlashResult = FLASH_WRITE_TIMEOUT                        */
-	0x1B, 0x4B,                 /*        LDR.N    R3, ??u32FlashResult                           */
-	0x02, 0x24,                 /*        MOVS     R4, #2                                         */
-	0x1C, 0x60,                 /*        STR      R4, [R3]                                       */
-	                            /*    if ((*(volatile uint16_t *)u32Target &amp; FLASH_DQ7)            */
-	                            /*      == (*(volatile uint16_t*)u32Source &amp; FLASH_DQ7))          */
-	0x0B, 0x88,                 /* L4:    LDRH     R3, [R1]                                       */
-	0x13, 0xF0, 0x80, 0x03,     /*        ANDS.W   R3, R3, #0x80                                  */
-	0x04, 0x88,                 /*        LDRH     R4, [R0]                                       */
-	0x14, 0xF0, 0x80, 0x04,     /*        ANDS.W   R4, R4, #0x80                                  */
-	0xA3, 0x42,                 /*        CMP      R3, R4                                         */
-	0xED, 0xD1,                 /*        BNE.N    L2                                             */
-	                            /*    u32FlashResult = FLASH_WRITE_OKAY                           */
-	0x15, 0x4B,                 /*        LDR.N    R3, ??u32FlashResult                           */
-	0x01, 0x24,                 /*        MOVS     R4, #1                                         */
-	0x1C, 0x60,                 /*        STR      R4, [R3]                                       */
-	0xE9, 0xE7,                 /*        B.N      L2                                             */
-	                            /*    if (u32FlashResult != FLASH_WRITE_TIMEOUT)                   */
-	0x13, 0x4B,                 /*        LDR.N    R3, ??u32FlashResult                           */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	0x02, 0x2B,                 /*        CMP      R3, #2                                         */
-	0x02, 0xD0,                 /*        BEQ.N    L5                                             */
-	                            /*    u32FlashResult = FLASH_WRITE_NO_RESULT                      */
-	0x11, 0x4B,                 /*        LDR.N    R3, ??u32FlashResult                           */
-	0x00, 0x24,                 /*        MOVS     R4, #0                                         */
-	0x1C, 0x60,                 /*        STR      R4, [R3]                                       */
-	                            /*    u32Count--;                                                 */
-	0x52, 0x1E,                 /* L5:    SUBS     R2, R2, #1                                     */
-	                            /*    u32Source += 2;                                             */
-	0x80, 0x1C,                 /*        ADDS     R0, R0, #2                                     */
-	                            /*    u32Target += 2;                                             */
-	0x89, 0x1C,                 /*        ADDS     R1, R1, #2                                     */
-	0xCA, 0xE7,                 /*        B.N      L0                                             */
-	                            /*    fm3_FLASH_IF-&gt;FASZ &amp;= 0xFFFE;                               */
-	0x5F, 0xF0, 0x80, 0x43,     /* L1:    MOVS.W   R3, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	0x4F, 0xF6, 0xFE, 0x74,     /*        MOVW     R4, #0xFFFE                                    */
-	0x23, 0x40,                 /*        ANDS     R3, R3, R4                                     */
-	0x5F, 0xF0, 0x80, 0x44,     /*        MOVS.W   R4, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x23, 0x60,                 /*        STR      R3, [R4]                                       */
-	                            /*    fm3_FLASH_IF-&gt;FASZ |= 2;                                    */
-	0x5F, 0xF0, 0x80, 0x43,     /*        MOVS.W   R3, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	0x53, 0xF0, 0x02, 0x03,     /*        ORRS.W   R3, R3, #2                                     */
-	0x5F, 0xF0, 0x80, 0x44,     /*        MOVS.W   R4, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x23, 0x60,                 /*        STR      R4, [R3]                                       */
-	                            /*    u32DummyRead = fm3_FLASH_IF-&gt;FASZ;                          */
-	0x04, 0x4B,                 /*        LDR.N    R3, ??u32DummyRead                             */
-	0x5F, 0xF0, 0x80, 0x44,     /*        MOVS.W   R4, #(fm3_FLASH_IF-&gt;FASZ)                      */
-	0x24, 0x68,                 /*        LDR      R4, [R4]                                       */
-	0x1C, 0x60,                 /*        STR      R4, [R3]                                       */
-	                            /*    copy u32FlashResult to R3 for return value                  */
-	0xDF, 0xF8, 0x0C, 0x30,     /*        LDR.W    R3, ??u32FlashResult                           */
-	0x1B, 0x68,                 /*        LDR      R3, [R3]                                       */
-	                            /*    Breakpoint here                                             */
-	0x00, 0xBE,                 /* Breakpoint #0                                                  */
-	0x00, 0x00,                 /*    alignment padding bytes                                     */
-	0x00, 0x80, 0xFF, 0x1F,     /* u32DummyRead address in RAM (0x1FFF8000)                       */
-	0x04, 0x80, 0xFF, 0x1F      /* u32FlashResult address in RAM (0x1FFF8004)                     */
+								/*    fm3_FLASH_IF-&gt;FASZ &amp;= 0xFFFD;           */
+	0x5F, 0xF0, 0x80, 0x45,		/*        MOVS.W   R5, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x2D, 0x68,					/*        LDR      R5, [R5]                   */
+	0x4F, 0xF6, 0xFD, 0x76,		/*        MOVW     R6, #0xFFFD                */
+	0x35, 0x40,					/*        ANDS     R5, R5, R6                 */
+	0x5F, 0xF0, 0x80, 0x46,		/*        MOVS.W   R6, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x35, 0x60,					/*        STR      R5, [R6]                   */
+								/*    fm3_FLASH_IF-&gt;FASZ |= 1;                */
+	0x5F, 0xF0, 0x80, 0x45,		/*        MOVS.W   R5, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x2D, 0x68,					/*        LDR      R5, [R3]                   */
+	0x55, 0xF0, 0x01, 0x05,		/*        ORRS.W   R5, R5, #1                 */
+	0x5F, 0xF0, 0x80, 0x46,		/*        MOVS.W   R6, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x35, 0x60,					/*        STR      R5, [R6]                   */
+								/*    u32DummyRead = fm3_FLASH_IF-&gt;FASZ;      */
+	0x28, 0x4D,					/*        LDR.N    R5, ??u32DummyRead         */
+	0x5F, 0xF0, 0x80, 0x46,		/*        MOVS.W   R6, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x36, 0x68,					/*        LDR      R6, [R6]                   */
+	0x2E, 0x60,					/*        STR      R6, [R5]                   */
+								/*    u32FlashResult = FLASH_WRITE_NO_RESULT  */
+	0x26, 0x4D,					/*        LDR.N    R5, ??u32FlashResult       */
+	0x00, 0x26,					/*        MOVS     R6, #0                     */
+	0x2E, 0x60,					/*        STR      R6, [R5]                   */
+								/*    while ((u32Count &gt; 0 )                  */
+								/*      &amp;&amp; (u32FlashResult                    */
+								/*          == FLASH_WRITE_NO_RESULT))        */
+	0x01, 0x2A,					/* L0:    CMP      R2, #1                     */
+	0x2C, 0xDB,					/*        BLT.N    L1                         */
+	0x24, 0x4D,					/*        LDR.N    R5, ??u32FlashResult       */
+	0x2D, 0x68,					/*        LDR      R5, [R5]                   */
+	0x00, 0x2D,					/*        CMP      R5, #0                     */
+	0x28, 0xD1,					/*        BNE.N    L1                         */
+								/*    *u32FlashSeq1 = FLASH_WRITE_1;          */
+	0xAA, 0x25,					/*        MOVS     R5, #0xAA                  */
+	0x1D, 0x60,					/*        STR      R5, [R3]                   */
+								/*    *u32FlashSeq2 = FLASH_WRITE_2;          */
+	0x55, 0x25,					/*        MOVS     R5, #0x55                  */
+	0x25, 0x60,					/*        STR      R5, [R4]                   */
+								/*    *u32FlashSeq1 = FLASH_WRITE_3;          */
+	0xA0, 0x25,					/*        MOVS     R5, #0xA0                  */
+	0x1D, 0x60,					/*        STRH     R5, [R3]                   */
+								/*    *(volatile uint16_t*)u32Target          */
+								/*      = *(volatile uint16_t*)u32Source;     */
+	0x05, 0x88,					/*        LDRH     R5, [R0]                   */
+	0x0D, 0x80,					/*        STRH     R5, [R1]                   */
+								/*    while (u32FlashResult                   */
+								/*           == FLASH_WRITE_NO_RESTULT)       */
+	0x1E, 0x4D,					/* L2:    LDR.N    R5, ??u32FlashResult       */
+	0x2D, 0x68,					/*        LDR      R5, [R5]                   */
+	0x00, 0x2D,					/*        CMP      R5, #0                     */
+	0x11, 0xD1,					/*        BNE.N    L3                         */
+								/*    if ((*(volatile uint16_t*)u32Target     */
+								/*        &amp; FLASH_DQ5) == FLASH_DQ5)          */
+	0x0D, 0x88,					/*        LDRH     R5, [R1]                   */
+	0xAD, 0x06,					/*        LSLS     R5, R5, #0x1A              */
+	0x02, 0xD5,					/*        BPL.N    L4                         */
+								/*    u32FlashResult = FLASH_WRITE_TIMEOUT    */
+	0x1A, 0x4D,					/*        LDR.N    R5, ??u32FlashResult       */
+	0x02, 0x26,					/*        MOVS     R6, #2                     */
+	0x2E, 0x60,					/*        STR      R6, [R5]                   */
+								/*    if ((*(volatile uint16_t *)u32Target    */
+								/*         &amp; FLASH_DQ7)                       */
+								/*        == (*(volatile uint16_t*)u32Source  */
+								/*            &amp; FLASH_DQ7))                   */
+	0x0D, 0x88,					/* L4:    LDRH     R5, [R1]                   */
+	0x15, 0xF0, 0x80, 0x05,		/*        ANDS.W   R5, R5, #0x80              */
+	0x06, 0x88,					/*        LDRH     R6, [R0]                   */
+	0x16, 0xF0, 0x80, 0x06,		/*        ANDS.W   R6, R6, #0x80              */
+	0xB5, 0x42,					/*        CMP      R5, R6                     */
+	0xED, 0xD1,					/*        BNE.N    L2                         */
+								/*    u32FlashResult = FLASH_WRITE_OKAY       */
+	0x15, 0x4D,					/*        LDR.N    R5, ??u32FlashResult       */
+	0x01, 0x26,					/*        MOVS     R6, #1                     */
+	0x2E, 0x60,					/*        STR      R6, [R5]                   */
+	0xE9, 0xE7,					/*        B.N      L2                         */
+								/*    if (u32FlashResult                      */
+								/*        != FLASH_WRITE_TIMEOUT)             */
+	0x13, 0x4D,					/*        LDR.N    R5, ??u32FlashResult       */
+	0x2D, 0x68,					/*        LDR      R5, [R5]                   */
+	0x02, 0x2D,					/*        CMP      R5, #2                     */
+	0x02, 0xD0,					/*        BEQ.N    L5                         */
+								/*    u32FlashResult = FLASH_WRITE_NO_RESULT  */
+	0x11, 0x4D,					/*        LDR.N    R5, ??u32FlashResult       */
+	0x00, 0x26,					/*        MOVS     R6, #0                     */
+	0x2E, 0x60,					/*        STR      R6, [R5]                   */
+								/*    u32Count--;                             */
+	0x52, 0x1E,					/* L5:    SUBS     R2, R2, #1                 */
+								/*    u32Source += 2;                         */
+	0x80, 0x1C,					/*        ADDS     R0, R0, #2                 */
+								/*    u32Target += 2;                         */
+	0x89, 0x1C,					/*        ADDS     R1, R1, #2                 */
+	0xD0, 0xE7,					/*        B.N      L0                         */
+								/*    fm3_FLASH_IF-&gt;FASZ &amp;= 0xFFFE;           */
+	0x5F, 0xF0, 0x80, 0x45,		/* L1:    MOVS.W   R5, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x2D, 0x68,					/*        LDR      R5, [R5]                   */
+	0x4F, 0xF6, 0xFE, 0x76,		/*        MOVW     R6, #0xFFFE                */
+	0x35, 0x40,					/*        ANDS     R5, R5, R6                 */
+	0x5F, 0xF0, 0x80, 0x46,		/*        MOVS.W   R6, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x35, 0x60,					/*        STR      R5, [R6]                   */
+								/*    fm3_FLASH_IF-&gt;FASZ |= 2;                */
+	0x5F, 0xF0, 0x80, 0x45,		/*        MOVS.W   R5, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x2D, 0x68,					/*        LDR      R5, [R5]                   */
+	0x55, 0xF0, 0x02, 0x05,		/*        ORRS.W   R5, R5, #2                 */
+	0x5F, 0xF0, 0x80, 0x46,		/*        MOVS.W   R6, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x35, 0x60,					/*        STR      R5, [R6]                   */
+								/*    u32DummyRead = fm3_FLASH_IF-&gt;FASZ;      */
+	0x04, 0x4D,					/*        LDR.N    R5, ??u32DummyRead         */
+	0x5F, 0xF0, 0x80, 0x46,		/*        MOVS.W   R6, #(fm3_FLASH_IF-&gt;FASZ)  */
+	0x36, 0x68,					/*        LDR      R6, [R6]                   */
+	0x2E, 0x60,					/*        STR      R6, [R5]                   */
+								/*    copy u32FlashResult to R3 for return    */
+								/*      value                                 */
+	0xDF, 0xF8, 0x08, 0x50,		/*        LDR.W    R5, ??u32FlashResult       */
+	0x2D, 0x68,					/*        LDR      R5, [R5]                   */
+								/*    Breakpoint here                         */
+	0x00, 0xBE,					/*        BKPT     #0                         */
+
+	/* The following address pointers assume, that the code is running from   */
+	/* address 0x1FFF8008. These address pointers will be patched, if a       */
+	/* different start address in RAM is used (e.g. for Flash type 2)!        */
+	0x00, 0x80, 0xFF, 0x1F,		/* u32DummyRead address in RAM (0x1FFF8000)   */
+	0x04, 0x80, 0xFF, 0x1F		/* u32FlashResult address in RAM (0x1FFF8004) */
 	};
 
 	LOG_INFO(&quot;Fujitsu MB9B500: FLASH Write ...&quot;);
 
 	/* disable HW watchdog */
-	target_write_u32(target, 0x40011C00, 0x1ACCE551);
-	target_write_u32(target, 0x40011C00, 0xE5331AAE);
-	target_write_u32(target, 0x40011008, 0x00000000);
+	retval = target_write_u32(target, 0x40011C00, 0x1ACCE551);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, 0x40011C00, 0xE5331AAE);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u32(target, 0x40011008, 0x00000000);
+	if (retval != ERROR_OK)
+		return retval;
 
 	count = count / 2;		/* number bytes -&gt; number halfwords */
 
@@ -360,7 +538,7 @@ static int fm3_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 				target_free_working_area(target, fm3_info-&gt;write_algorithm);
 			}
 
-			LOG_WARNING(&quot;no large enough working area available, can't do block memory writes&quot;);
+			LOG_WARNING(&quot;No large enough working area available, can't do block memory writes&quot;);
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
 	}
@@ -368,60 +546,65 @@ static int fm3_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARMV7M_MODE_ANY;
 
-	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT); // source start address
-	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT); // target start address
-	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT); // number of halfwords to program
-	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_IN);  // result
+	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT); /* source start address */
+	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT); /* target start address */
+	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT); /* number of halfwords to program */
+	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_OUT); /* Flash Sequence address 1 */
+	init_reg_param(&amp;reg_params[4], &quot;r4&quot;, 32, PARAM_OUT); /* Flash Sequence address 1 */
+	init_reg_param(&amp;reg_params[5], &quot;r5&quot;, 32, PARAM_IN);  /* result */
 
-	/* write code buffer and use Flash programming code within fm3           */
-	/* Set breakpoint to 0 with time-out of 1000 ms                          */
+	/* write code buffer and use Flash programming code within fm3 */
+	/* Set breakpoint to 0 with time-out of 1000 ms */
 	while (count &gt; 0)
 	{
 		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
 
-		/* for some reason the first 8 byte of code are corrupt when target_run_algorithm() returns */
-		/* need some more investigation on this                                                     */
-		retval = target_write_buffer(target,
-				fm3_info-&gt;write_algorithm-&gt;address, 8, fm3_flash_write_code);
+		retval = target_write_buffer(target, fm3_info-&gt;write_algorithm-&gt;address,
+				8, fm3_flash_write_code);
 		if (retval != ERROR_OK)
-			return retval;
+			break;
+
+		/* Patching 'local variable address' for different RAM addresses */
+		if (fm3_info-&gt;write_algorithm-&gt;address != 0x1FFF8008)
+		{
+			/* Algorithm: u32DummyRead: */
+			retval = target_write_u32(target, (fm3_info-&gt;write_algorithm-&gt;address)
+					+ sizeof(fm3_flash_write_code) - 8,
+					(fm3_info-&gt;write_algorithm-&gt;address) - 8);
+			if (retval != ERROR_OK)
+				break;
 
+			/* Algorithm: u32FlashResult: */
+			retval = target_write_u32(target, (fm3_info-&gt;write_algorithm-&gt;address)
+					+ sizeof(fm3_flash_write_code) - 4, (fm3_info-&gt;write_algorithm-&gt;address) - 4);
+			if (retval != ERROR_OK)
+				break;
+		}
 
-		retval = target_write_buffer(target,
-				source-&gt;address, thisrun_count * 2, buffer);
+		retval = target_write_buffer(target, source-&gt;address, thisrun_count * 2,
+				buffer);
 		if (retval != ERROR_OK)
 			break;
 
 		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
+		buf_set_u32(reg_params[3].value, 0, 32, u32FlashSeqAddress1);
+		buf_set_u32(reg_params[4].value, 0, 32, u32FlashSeqAddress2);
 
-
-		retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
+		retval = target_run_algorithm(target, 0, NULL, 6, reg_params,
 				fm3_info-&gt;write_algorithm-&gt;address, 0, 1000, &amp;armv7m_info);
 		if (retval != ERROR_OK)
 		{
-			LOG_ERROR(&quot;error executing fm3 Flash programming algorithm&quot;);
+			LOG_ERROR(&quot;Error executing fm3 Flash programming algorithm&quot;);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 
-#if 0
-		/* debug the corrupted 8 bytes */
-		unsigned char buf[256];
-		retval = target_read_buffer(target, fm3_info-&gt;write_algorithm-&gt;address, 256, buf);
-		if (retval != ERROR_OK)
-			printf(&quot;cannot read buffer\n&quot;);
-		unsigned int i;
-		for ( i = 0; i &lt; sizeof(fm3_flash_write_code); i++)
-			if (buf[i] != fm3_flash_write_code[i])
-				printf(&quot;broken: %d %02x != %02x\n&quot;, i, buf[i], fm3_flash_write_code[i]);
-#endif
-
-		if (buf_get_u32(reg_params[3].value, 0, 32) != ERROR_OK)
+		if (buf_get_u32(reg_params[5].value, 0, 32) != ERROR_OK)
 		{
-			LOG_ERROR(&quot;Fujitsu MB9B500: FLASH programming ERROR (Timeout) -&gt; Reg R3: %x&quot;,
-					buf_get_u32(reg_params[3].value, 0, 32));
+			LOG_ERROR(&quot;Fujitsu MB9[A/B]FXXX: Flash programming ERROR (Timeout) \
+					-&gt; Reg R3: %x&quot;, buf_get_u32(reg_params[5].value, 0, 32));
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
@@ -438,6 +621,8 @@ static int fm3_write_block(struct flash_bank *bank, uint8_t *buffer, uint32_t of
 	destroy_reg_param(&amp;reg_params[1]);
 	destroy_reg_param(&amp;reg_params[2]);
 	destroy_reg_param(&amp;reg_params[3]);
+	destroy_reg_param(&amp;reg_params[4]);
+	destroy_reg_param(&amp;reg_params[5]);
 
 	return retval;
 }
@@ -471,7 +656,7 @@ static int fm3_probe(struct flash_bank *bank)
 	bank-&gt;sectors[1].is_erased = -1;
 	bank-&gt;sectors[1].is_protected = -1;
 
-	if (fm3_info-&gt;variant == mb9bfxx1)
+	if ((fm3_info-&gt;variant == mb9bfxx1) || (fm3_info-&gt;variant == mb9afxx1))
 	{
 		num_pages = 3;
 		bank-&gt;size = 64 * 1024; /* bytes */
@@ -483,13 +668,17 @@ static int fm3_probe(struct flash_bank *bank)
 		bank-&gt;sectors[2].is_protected = -1;
 	}
 
-	if (  (fm3_info-&gt;variant == mb9bfxx2)
+	if ((fm3_info-&gt;variant == mb9bfxx2)
 		|| (fm3_info-&gt;variant == mb9bfxx4)
 		|| (fm3_info-&gt;variant == mb9bfxx5)
-		|| (fm3_info-&gt;variant == mb9bfxx6))
+		|| (fm3_info-&gt;variant == mb9bfxx6)
+		|| (fm3_info-&gt;variant == mb9afxx2)
+		|| (fm3_info-&gt;variant == mb9afxx4)
+		|| (fm3_info-&gt;variant == mb9afxx5)
+		|| (fm3_info-&gt;variant == mb9afxx6))
 	{
 		num_pages = 3;
-		bank-&gt;size = 128 * 1024; // bytes
+		bank-&gt;size = 128 * 1024; /* bytes */
 		bank-&gt;num_sectors = num_pages;
 
 		bank-&gt;sectors[2].offset = 0x8000;
@@ -498,12 +687,15 @@ static int fm3_probe(struct flash_bank *bank)
 		bank-&gt;sectors[2].is_protected = -1;
 	}
 
-	if ( (fm3_info-&gt;variant == mb9bfxx4)
+	if ((fm3_info-&gt;variant == mb9bfxx4)
 		|| (fm3_info-&gt;variant == mb9bfxx5)
-		|| (fm3_info-&gt;variant == mb9bfxx6))
+		|| (fm3_info-&gt;variant == mb9bfxx6)
+		|| (fm3_info-&gt;variant == mb9afxx4)
+		|| (fm3_info-&gt;variant == mb9afxx5)
+		|| (fm3_info-&gt;variant == mb9afxx6))
 	{
 		num_pages = 4;
-		bank-&gt;size = 256 * 1024; // bytes
+		bank-&gt;size = 256 * 1024; /* bytes */
 		bank-&gt;num_sectors = num_pages;
 
 		bank-&gt;sectors[3].offset = 0x20000;
@@ -512,11 +704,13 @@ static int fm3_probe(struct flash_bank *bank)
 		bank-&gt;sectors[3].is_protected = -1;
 	}
 
-	if ( (fm3_info-&gt;variant == mb9bfxx5)
-		|| (fm3_info-&gt;variant == mb9bfxx6))
+	if ((fm3_info-&gt;variant == mb9bfxx5)
+		|| (fm3_info-&gt;variant == mb9bfxx6)
+		|| (fm3_info-&gt;variant == mb9afxx5)
+		|| (fm3_info-&gt;variant == mb9afxx6))
 	{
 		num_pages = 5;
-		bank-&gt;size = 384 * 1024; // bytes
+		bank-&gt;size = 384 * 1024; /* bytes */
 		bank-&gt;num_sectors = num_pages;
 
 		bank-&gt;sectors[4].offset = 0x40000;
@@ -525,10 +719,11 @@ static int fm3_probe(struct flash_bank *bank)
 		bank-&gt;sectors[4].is_protected = -1;
 	}
 
-	if (fm3_info-&gt;variant == mb9bfxx6)
+	if ((fm3_info-&gt;variant == mb9bfxx6)
+		|| (fm3_info-&gt;variant == mb9afxx6))
 	{
 		num_pages = 6;
-		bank-&gt;size = 512 * 1024; // bytes
+		bank-&gt;size = 512 * 1024; /* bytes */
 		bank-&gt;num_sectors = num_pages;
 
 		bank-&gt;sectors[5].offset = 0x60000;
@@ -550,7 +745,7 @@ static int fm3_auto_probe(struct flash_bank *bank)
 	return fm3_probe(bank);
 }
 
-static int fm3_info(struct flash_bank *bank, char *buf, int buf_size)
+static int fm3_info_cmd(struct flash_bank *bank, char *buf, int buf_size)
 {
 	snprintf(buf, buf_size, &quot;Fujitsu fm3 Device does not support Chip-ID (Type unknown)&quot;);
 	return ERROR_OK;
@@ -559,8 +754,32 @@ static int fm3_info(struct flash_bank *bank, char *buf, int buf_size)
 static int fm3_chip_erase(struct flash_bank *bank)
 {
 	struct target *target = bank-&gt;target;
+	struct fm3_flash_bank *fm3_info = bank-&gt;driver_priv;
 	int retval = ERROR_OK;
 	uint32_t u32DummyRead;
+	uint32_t u32FlashType;
+	uint32_t u32FlashSeqAddress1;
+	uint32_t u32FlashSeqAddress2;
+
+	u32FlashType = (uint32_t) fm3_info-&gt;flashtype;
+
+	if (u32FlashType == fm3_flash_type1)
+	{
+		LOG_INFO(&quot;*** Erasing mb9bfxxx type&quot;);
+		u32FlashSeqAddress1 = 0x00001550;
+		u32FlashSeqAddress2 = 0x00000AA8;
+	}
+	else if (u32FlashType == fm3_flash_type2)
+	{
+		LOG_INFO(&quot;*** Erasing mb9afxxx type&quot;);
+		u32FlashSeqAddress1 = 0x00000AA8;
+		u32FlashSeqAddress2 = 0x00000554;
+	}
+	else
+	{
+		LOG_ERROR(&quot;Flash/Device type unknown!&quot;);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -568,23 +787,57 @@ static int fm3_chip_erase(struct flash_bank *bank)
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	LOG_INFO(&quot;Fujitsu MB9Bxxx: Chip Erase ... (may take several seconds)&quot;);
+	LOG_INFO(&quot;Fujitsu MB9[AB]xxx: Chip Erase ... (may take several seconds)&quot;);
 
 	/* Implement Flash chip erase (mass erase) completely on host */
-	target_write_u32(target, 0x40000000, 0x0001);		/* FASZR = 0x01, Enables CPU Programming Mode (16-bit Flash access) */
-	target_read_u32(target, 0x40000000, &amp;u32DummyRead); /* dummy read of FASZR */
 
-	target_write_u16(target, 0x00001550, 0x00AA); 		/* Flash unlock sequence */
-	target_write_u16(target, 0x00000AA8, 0x0055);
-	target_write_u16(target, 0x00001550, 0x0080);
-	target_write_u16(target, 0x00001550, 0x00AA);
-	target_write_u16(target, 0x00000AA8, 0x0055);
-	target_write_u16(target, 0x00001550, 0x0010); 		/* Chip Erase command */
+	/* FASZR = 0x01, Enables CPU Programming Mode (16-bit Flash access) */
+	retval = target_write_u32(target, 0x40000000, 0x0001);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* dummy read of FASZR */
+	retval = target_read_u32(target, 0x40000000, &amp;u32DummyRead);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Flash unlock sequence */
+	retval = target_write_u16(target, u32FlashSeqAddress1, 0x00AA);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u16(target, u32FlashSeqAddress2, 0x0055);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u16(target, u32FlashSeqAddress1, 0x0080);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u16(target, u32FlashSeqAddress1, 0x00AA);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = target_write_u16(target, u32FlashSeqAddress2, 0x0055);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Chip Erase command (0x0010) */
+	retval = target_write_u16(target, u32FlashSeqAddress1, 0x0010);
+	if (retval != ERROR_OK)
+		return retval;
 
-	retval = fm3_busy_wait(target, 0xAA8, 20000);
+	retval = fm3_busy_wait(target, u32FlashSeqAddress2, 20000);	/* 20s timeout */
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* FASZR = 0x02, Re-enables CPU Run Mode (32-bit Flash access) */
+	retval = target_write_u32(target, 0x40000000, 0x0002);
+	if (retval != ERROR_OK)
+		return retval;
 
-	target_write_u32(target, 0x40000000, 0x0002);
-	target_read_u32(target, 0x40000000, &amp;u32DummyRead); /* dummy read of FASZR */
+	/* dummy read of FASZR */
+	retval = target_read_u32(target, 0x40000000, &amp;u32DummyRead);
 
 	return retval;
 }
@@ -650,5 +903,5 @@ struct flash_driver fm3_flash = {
 	.probe = fm3_probe,
 	.auto_probe = fm3_auto_probe,
 	.erase_check = default_flash_mem_blank_check,
-	.info = fm3_info,
+	.info = fm3_info_cmd,
 };

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/fm3.c |  687 +++++++++++++++++++++++++++++++++++----------------
 1 files changed, 470 insertions(+), 217 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002720.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-128-g36e3009
</A></li>
	<LI>Next message: <A HREF="002722.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-130-g1c1771e
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2721">[ date ]</a>
              <a href="thread.html#2721">[ thread ]</a>
              <a href="subject.html#2721">[ subject ]</a>
              <a href="author.html#2721">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
