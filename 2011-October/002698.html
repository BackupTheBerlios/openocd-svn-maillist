<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-104-g92b14f8
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-October/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-104-g92b14f8&In-Reply-To=%3Cmailman.183.1331736158.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002697.html">
   <LINK REL="Next"  HREF="002699.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-104-g92b14f8</H1>
    <B>Andreas Fritiofson</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-104-g92b14f8&In-Reply-To=%3Cmailman.183.1331736158.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-104-g92b14f8">nattgris at users.sourceforge.net
       </A><BR>
    <I>Sun Oct  9 00:36:52 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002697.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-99-ge56e5a3
</A></li>
        <LI>Next message: <A HREF="002699.html">[openocd-svn] Main OpenOCD repository branch, v0.3.1,	deleted. v0.3.1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2698">[ date ]</a>
              <a href="thread.html#2698">[ thread ]</a>
              <a href="subject.html#2698">[ subject ]</a>
              <a href="author.html#2698">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  92b14f8ca96e87715697be74a08907595a7d4dcb (commit)
       via  a147563ac1e96e3dbe56770a9f958a7b47cc0fc8 (commit)
       via  1163435e19f316a4a97fd33f1467f5c1684db654 (commit)
       via  9d4c466c219039bd6a2ea03467cd3ee8be2a0e76 (commit)
       via  3f6ef7a40bcff5e1278b662248902c45a1dc8f81 (commit)
      from  e56e5a3929a05d18e560c8e37f1985aeb4b95cc9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 92b14f8ca96e87715697be74a08907595a7d4dcb
Author: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;
Date:   Sun Jul 31 10:31:56 2011 +0200

    stm32f1x: use async algorithm in flash programming routine
    
    Let the target algorithm be running in the background and buffer data
    continuously through a FIFO. This reduces or removes the effect of latency
    because only a very small number of queue executions needs to be done per
    buffer fill. Previously, the many repeated target state changes, register
    accesses (really inefficient) and algorithm uploads caused the flash
    programming to be latency bound in many cases. Now it should scale better
    with increased throughput.
    
    Signed-off-by: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;

diff --git a/contrib/loaders/flash/stm32x.S b/contrib/loaders/flash/stm32f1x.S
similarity index 51%
rename from contrib/loaders/flash/stm32x.S
rename to contrib/loaders/flash/stm32f1x.S
index 01494b8..125c76a 100644
--- a/contrib/loaders/flash/stm32x.S
+++ b/contrib/loaders/flash/stm32f1x.S
@@ -1,6 +1,6 @@
 /***************************************************************************
- *   Copyright (C) 2010 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
+ *   Copyright (C) 2011 by Andreas Fritiofson                              *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>                                          *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -25,34 +25,47 @@
 	.thumb_func
 	.global write
 
-/*
-	r0 - source address
-	r1 - target address
-	r2 - count (halfword-16bit)
-	r3 - sector offet in : result out
-	r4 - flash base
-*/
+	/* Params:
+	 * r0 - flash base (in), status (out)
+	 * r1 - count (halfword-16bit)
+	 * r2 - workarea start
+	 * r3 - workarea end
+	 * r4 - target address
+	 * Clobbered:
+	 * r5 - rp
+	 * r6 - wp, tmp
+	 */
 
-#define STM32_FLASH_CR_OFFSET	0x10			/* offset of CR register in FLASH struct */
-#define STM32_FLASH_SR_OFFSET	0x0c			/* offset of CR register in FLASH struct */
+#define STM32_FLASH_CR_OFFSET 0x10 /* offset of CR register from flash reg base */
+#define STM32_FLASH_SR_OFFSET 0x0c /* offset of SR register from flash reg base */
 
-write:
-	ldr		r4, STM32_FLASH_BASE
-	add		r4, r3								/* add offset 0x00 for sector 0 : 0x40 for sector 1 */
-write_half_word:
-	movs	r3, #0x01
-	str		r3, [r4, #STM32_FLASH_CR_OFFSET]	/* PG (bit0) == 1 =&gt; flash programming enabled */
-	ldrh 	r3, [r0], #0x02						/* read one half-word from src, increment ptr */
-	strh 	r3, [r1], #0x02						/* write one half-word from src, increment ptr */
+wait_fifo:
+	ldr 	r6, [r2, #0]	/* read wp */
+	cmp 	r6, #0			/* abort if wp == 0 */
+	beq 	exit
+	ldr 	r5, [r2, #4]	/* read rp */
+	cmp 	r5, r6			/* wait until rp != wp */
+	beq 	wait_fifo
+	movs	r6, #1			/* set PG flag to enable flash programming */
+	str 	r6, [r0, #STM32_FLASH_CR_OFFSET]
+	ldrh	r6, [r5], #2	/* &quot;*target_address++ = *rp++&quot; */
+	strh	r6, [r4], #2
 busy:
-	ldr 	r3, [r4, #STM32_FLASH_SR_OFFSET]
-	tst 	r3, #0x01							/* BSY (bit0) == 1 =&gt; operation in progress */
-	beq 	busy								/* wait more... */
-	tst		r3, #0x14							/* PGERR (bit2) == 1 or WRPRTERR (bit4) == 1 =&gt; error */
-	bne		exit								/* fail... */
-	subs	r2, r2, #0x01						/* decrement counter */
-	bne		write_half_word						/* write next half-word if anything left */
+	ldr 	r6, [r0, #STM32_FLASH_SR_OFFSET]	/* wait until BSY flag is reset */
+	tst 	r6, #1
+	bne 	busy
+	tst 	r6, #0x14		/* check the error bits */
+	bne 	error
+	cmp 	r5, r3			/* wrap rp at end of buffer */
+	it  	cs
+	addcs	r5, r2, #8
+	str 	r5, [r2, #4]	/* store rp */
+	subs	r1, r1, #1		/* decrement halfword count */
+	cbz 	r1, exit		/* loop if not done */
+	b		wait_fifo
+error:
+	movs	r0, #0
+	str 	r0, [r2, #2]	/* set rp = 0 on error */
 exit:
-	bkpt	#0x00
-
-STM32_FLASH_BASE: .word 0x40022000				/* base address of FLASH struct */
+	mov		r0, r6			/* return status in r0 */
+	bkpt	#0
diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
index 142b03e..a0520c7 100644
--- a/src/flash/nor/stm32f1x.c
+++ b/src/flash/nor/stm32f1x.c
@@ -5,6 +5,9 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
  *                                                                         *
+ *   Copyright (C) 2011 by Andreas Fritiofson                              *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>                                          *
+ *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -623,34 +626,45 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 	uint32_t buffer_size = 16384;
 	struct working_area *source;
 	uint32_t address = bank-&gt;base + offset;
-	struct reg_param reg_params[4];
+	struct reg_param reg_params[5];
 	struct armv7m_algorithm armv7m_info;
 	int retval = ERROR_OK;
 
-	/* see contib/loaders/flash/stm32x.s for src */
+	/* see contrib/loaders/flash/stm32f1x.S for src */
 
 	static const uint8_t stm32x_flash_write_code[] = {
-									/* #define STM32_FLASH_CR_OFFSET	0x10 */
-									/* #define STM32_FLASH_SR_OFFSET	0x0C */
-									/* write: */
-		0x08, 0x4c,					/* ldr	r4, STM32_FLASH_BASE */
-		0x1c, 0x44,					/* add	r4, r3 */
-									/* write_half_word: */
-		0x01, 0x23,					/* movs	r3, #0x01 */
-		0x23, 0x61,					/* str	r3, [r4, #STM32_FLASH_CR_OFFSET] */
-		0x30, 0xf8, 0x02, 0x3b,		/* ldrh	r3, [r0], #0x02 */
-		0x21, 0xf8, 0x02, 0x3b,		/* strh	r3, [r1], #0x02 */
-									/* busy: */
-		0xe3, 0x68,					/* ldr	r3, [r4, #STM32_FLASH_SR_OFFSET] */
-		0x13, 0xf0, 0x01, 0x0f,		/* tst	r3, #0x01 */
-		0xfb, 0xd0,					/* beq	busy */
-		0x13, 0xf0, 0x14, 0x0f,		/* tst	r3, #0x14 */
-		0x01, 0xd1,					/* bne	exit */
-		0x01, 0x3a,					/* subs	r2, r2, #0x01 */
-		0xf0, 0xd1,					/* bne	write_half_word */
-									/* exit: */
-		0x00, 0xbe,					/* bkpt	#0x00 */
-		0x00, 0x20, 0x02, 0x40,		/* STM32_FLASH_BASE: .word 0x40022000 */
+		/* #define STM32_FLASH_CR_OFFSET 0x10 */
+		/* #define STM32_FLASH_SR_OFFSET 0x0C */
+		/* wait_fifo: */
+			0x16, 0x68,             /* ldr  	r6, [r2, #0] */
+			0x00, 0x2e,             /* cmp  	r6, #0 */
+			0x1a, 0xd0,             /* beq  	exit */
+			0x55, 0x68,             /* ldr  	r5, [r2, #4] */
+			0xb5, 0x42,             /* cmp  	r5, r6 */
+			0xf9, 0xd0,             /* beq  	wait_fifo */
+			0x01, 0x26,             /* movs 	r6, #1 */
+			0x06, 0x61,             /* str  	r6, [r0, #STM32_FLASH_CR_OFFSET] */
+			0x35, 0xf8, 0x02, 0x6b, /* ldrh 	r6, [r5], #2 */
+			0x24, 0xf8, 0x02, 0x6b, /* strh 	r6, [r4], #2 */
+		/* busy: */
+			0xc6, 0x68,             /* ldr  	r6, [r0, #STM32_FLASH_SR_OFFSET] */
+			0x16, 0xf0, 0x01, 0x0f, /* tst  	r6, #1 */
+			0xfb, 0xd1,             /* bne  	busy */
+			0x16, 0xf0, 0x14, 0x0f, /* tst  	r6, #0x14 */
+			0x07, 0xd1,             /* bne  	error */
+			0x9d, 0x42,             /* cmp  	r5, r3 */
+			0x28, 0xbf,             /* it   	cs */
+			0x02, 0xf1, 0x08, 0x05, /* addcs	r5, r2, #8 */
+			0x55, 0x60,             /* str  	r5, [r2, #4] */
+			0x01, 0x39,             /* subs 	r1, r1, #1 */
+			0x19, 0xb1,             /* cbz  	r1, exit */
+			0xe4, 0xe7,             /* b    	wait_fifo */
+		/* error: */
+			0x00, 0x20,             /* movs 	r0, #0 */
+			0xc2, 0xf8,	0x02, 0x00, /* str  	r0, [r2, #2] */
+		/* exit: */
+			0x30, 0x46,             /* mov  	r0, r6 */
+			0x00, 0xbe,             /* bkpt 	#0 */
 	};
 
 	/* flash write code */
@@ -670,6 +684,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 	while (target_alloc_working_area_try(target, buffer_size, &amp;source) != ERROR_OK)
 	{
 		buffer_size /= 2;
+		buffer_size &amp;= ~3UL; // Make sure it's 4 byte aligned
 		if (buffer_size &lt;= 256)
 		{
 			/* if we already allocated the writing code, but failed to get a
@@ -682,60 +697,152 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		}
 	};
 
+	/* Set up working area. First word is write pointer, second word is read pointer,
+	 * rest is fifo data area. */
+	uint32_t wp_addr = source-&gt;address;
+	uint32_t rp_addr = source-&gt;address + 4;
+	uint32_t fifo_start_addr = source-&gt;address + 8;
+	uint32_t fifo_end_addr = source-&gt;address + source-&gt;size;
+
+	uint32_t wp = fifo_start_addr;
+	uint32_t rp = fifo_start_addr;
+
+	retval = target_write_u32(target, wp_addr, wp);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = target_write_u32(target, rp_addr, rp);
+	if (retval != ERROR_OK)
+		return retval;
+
+	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_IN_OUT);	/* flash base (in), status (out) */
+	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);	/* count (halfword-16bit) */
+	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);	/* buffer start */
+	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_OUT);	/* buffer end */
+	init_reg_param(&amp;reg_params[4], &quot;r4&quot;, 32, PARAM_IN_OUT);	/* target address */
+
+	buf_set_u32(reg_params[0].value, 0, 32, stm32x_info-&gt;register_base);
+	buf_set_u32(reg_params[1].value, 0, 32, count);
+	buf_set_u32(reg_params[2].value, 0, 32, source-&gt;address);
+	buf_set_u32(reg_params[3].value, 0, 32, source-&gt;address + source-&gt;size);
+	buf_set_u32(reg_params[4].value, 0, 32, address);
+
 	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARMV7M_MODE_ANY;
 
-	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);
-	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_IN_OUT);
+	/* Start up algorithm on target and let it idle while writing the first chunk */
+	if ((retval = target_start_algorithm(target, 0, NULL, 5, reg_params,
+			stm32x_info-&gt;write_algorithm-&gt;address,
+			0,
+			&amp;armv7m_info)) != ERROR_OK)
+	{
+		LOG_ERROR(&quot;error starting stm32x flash write algorithm&quot;);
+		goto cleanup;
+	}
 
 	while (count &gt; 0)
 	{
-		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ?
-				(buffer_size / 2) : count;
-
-		if ((retval = target_write_buffer(target, source-&gt;address,
-				thisrun_count * 2, buffer)) != ERROR_OK)
+		retval = target_read_u32(target, rp_addr, &amp;rp);
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR(&quot;failed to get read pointer&quot;);
 			break;
+		}
 
-		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
-		buf_set_u32(reg_params[1].value, 0, 32, address);
-		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
-		buf_set_u32(reg_params[3].value, 0, 32, stm32x_info-&gt;register_base - FLASH_REG_BASE_B0);
+		LOG_DEBUG(&quot;count 0x%&quot;PRIx32&quot; wp 0x%&quot;PRIx32&quot; rp 0x%&quot;PRIx32, count, wp, rp);
 
-		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
-				stm32x_info-&gt;write_algorithm-&gt;address,
-				0,
-				10000, &amp;armv7m_info)) != ERROR_OK)
+		if (rp == 0)
 		{
-			LOG_ERROR(&quot;error executing stm32x flash write algorithm&quot;);
+			LOG_ERROR(&quot;flash write algorithm aborted by target&quot;);
+			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 
-		if (buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_PGERR)
+		if ((rp &amp; 1) || rp &lt; fifo_start_addr || rp &gt;= fifo_end_addr)
+		{
+			LOG_ERROR(&quot;corrupted fifo read pointer 0x%&quot;PRIx32, rp);
+			break;
+		}
+
+		/* Count the number of bytes available in the fifo without
+		 * crossing the wrap around. Make sure to not fill it completely,
+		 * because that would make wp == rp and that's the empty condition. */
+		uint32_t thisrun_bytes;
+		if (rp &gt; wp)
+			thisrun_bytes = rp - wp - 2;
+		else if (rp &gt; fifo_start_addr)
+			thisrun_bytes = fifo_end_addr - wp;
+		else
+			thisrun_bytes = fifo_end_addr - wp - 2;
+
+		if (thisrun_bytes == 0)
+		{
+			/* Throttle polling a bit if transfer is (much) faster than flash
+			 * programming. The exact delay shouldn't matter as long as it's
+			 * less than buffer size / flash speed. This is very unlikely to
+			 * run when using high latency connections such as USB. */
+			alive_sleep(10);
+			continue;
+		}
+
+		/* Limit to the amount of data we actually want to write */
+		if (thisrun_bytes &gt; count * 2)
+			thisrun_bytes = count * 2;
+
+		/* Write data to fifo */
+		retval = target_write_buffer(target, wp, thisrun_bytes, buffer);
+		if (retval != ERROR_OK)
+			break;
+
+		/* Update counters and wrap write pointer */
+		buffer += thisrun_bytes;
+		count -= thisrun_bytes / 2;
+		wp += thisrun_bytes;
+		if (wp &gt;= fifo_end_addr)
+			wp = fifo_start_addr;
+
+		/* Store updated write pointer to target */
+		retval = target_write_u32(target, wp_addr, wp);
+		if (retval != ERROR_OK)
+			break;
+	}
+
+	if (retval != ERROR_OK)
+	{
+		/* abort flash write algorithm on target */
+		target_write_u32(target, wp_addr, 0);
+	}
+
+	int retval2;
+	if ((retval2 = target_wait_algorithm(target, 0, NULL, 5, reg_params,
+			0,
+			10000,
+			&amp;armv7m_info)) != ERROR_OK)
+	{
+		LOG_ERROR(&quot;error waiting for stm32x flash write algorithm&quot;);
+		retval = retval2;
+	}
+
+	if (retval == ERROR_FLASH_OPERATION_FAILED)
+	{
+		LOG_ERROR(&quot;flash write failed at address 0x%&quot;PRIx32,
+				buf_get_u32(reg_params[4].value, 0, 32));
+
+		if (buf_get_u32(reg_params[0].value, 0, 32) &amp; FLASH_PGERR)
 		{
 			LOG_ERROR(&quot;flash memory not erased before writing&quot;);
 			/* Clear but report errors */
 			target_write_u32(target, STM32_FLASH_SR_B0, FLASH_PGERR);
-			retval = ERROR_FAIL;
-			break;
 		}
 
-		if (buf_get_u32(reg_params[3].value, 0, 32) &amp; FLASH_WRPRTERR)
+		if (buf_get_u32(reg_params[0].value, 0, 32) &amp; FLASH_WRPRTERR)
 		{
 			LOG_ERROR(&quot;flash memory write protected&quot;);
 			/* Clear but report errors */
 			target_write_u32(target, STM32_FLASH_SR_B0, FLASH_WRPRTERR);
-			retval = ERROR_FAIL;
-			break;
 		}
-
-		buffer += thisrun_count * 2;
-		address += thisrun_count * 2;
-		count -= thisrun_count;
 	}
 
+cleanup:
 	target_free_working_area(target, source);
 	target_free_working_area(target, stm32x_info-&gt;write_algorithm);
 
@@ -743,6 +850,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 	destroy_reg_param(&amp;reg_params[1]);
 	destroy_reg_param(&amp;reg_params[2]);
 	destroy_reg_param(&amp;reg_params[3]);
+	destroy_reg_param(&amp;reg_params[4]);
 
 	return retval;
 }

commit a147563ac1e96e3dbe56770a9f958a7b47cc0fc8
Author: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;
Date:   Sun Jul 17 14:07:26 2011 +0200

    stm32f1x: use register base instead of register offset
    
    Access the different flash banks' registers using a bank specific register
    base and a register specific offset. This is equivalent but feels more
    natural.
    
    Some accesses were discovered that maybe should not be hard coded to bank0
    registers. Add a note about that.
    
    Signed-off-by: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;

diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
index 4927fb8..142b03e 100644
--- a/src/flash/nor/stm32f1x.c
+++ b/src/flash/nor/stm32f1x.c
@@ -31,14 +31,29 @@
 
 /* stm32x register locations */
 
-#define STM32_FLASH_ACR		0x40022000
-#define STM32_FLASH_KEYR	0x40022004
-#define STM32_FLASH_OPTKEYR	0x40022008
-#define STM32_FLASH_SR		0x4002200C
-#define STM32_FLASH_CR		0x40022010
-#define STM32_FLASH_AR		0x40022014
-#define STM32_FLASH_OBR		0x4002201C
-#define STM32_FLASH_WRPR	0x40022020
+#define FLASH_REG_BASE_B0 0x40022000
+#define FLASH_REG_BASE_B1 0x40022040
+
+#define STM32_FLASH_ACR     0x00
+#define STM32_FLASH_KEYR    0x04
+#define STM32_FLASH_OPTKEYR 0x08
+#define STM32_FLASH_SR      0x0C
+#define STM32_FLASH_CR      0x10
+#define STM32_FLASH_AR      0x14
+#define STM32_FLASH_OBR     0x1C
+#define STM32_FLASH_WRPR    0x20
+
+/* TODO: Check if code using these really should be hard coded to bank 0.
+ * There are valid cases, on dual flash devices the protection of the
+ * second bank is done on the bank0 reg's. */
+#define STM32_FLASH_ACR_B0     0x40022000
+#define STM32_FLASH_KEYR_B0    0x40022004
+#define STM32_FLASH_OPTKEYR_B0 0x40022008
+#define STM32_FLASH_SR_B0      0x4002200C
+#define STM32_FLASH_CR_B0      0x40022010
+#define STM32_FLASH_AR_B0      0x40022014
+#define STM32_FLASH_OBR_B0     0x4002201C
+#define STM32_FLASH_WRPR_B0    0x40022020
 
 /* option byte location */
 
@@ -83,12 +98,6 @@
 #define KEY1			0x45670123
 #define KEY2			0xCDEF89AB
 
-/* we use an offset to access the second bank on dual flash devices
- * strangely the protection of the second bank is done on the bank0 reg's */
-
-#define FLASH_OFFSET_B0	0x00
-#define FLASH_OFFSET_B1 0x40
-
 struct stm32x_options
 {
 	uint16_t RDP;
@@ -104,10 +113,8 @@ struct stm32x_flash_bank
 	int probed;
 
 	bool has_dual_banks;
-	/* used to access dual flash bank stm32xl
-	 * 0x00 will address bank 0 flash
-	 * 0x40 will address bank 1 flash */
-	int register_offset;
+	/* used to access dual flash bank stm32xl */
+	uint32_t register_base;
 };
 
 static int stm32x_mass_erase(struct flash_bank *bank);
@@ -130,7 +137,7 @@ FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
 	stm32x_info-&gt;write_algorithm = NULL;
 	stm32x_info-&gt;probed = 0;
 	stm32x_info-&gt;has_dual_banks = false;
-	stm32x_info-&gt;register_offset = FLASH_OFFSET_B0;
+	stm32x_info-&gt;register_base = FLASH_REG_BASE_B0;
 
 	return ERROR_OK;
 }
@@ -138,7 +145,7 @@ FLASH_BANK_COMMAND_HANDLER(stm32x_flash_bank_command)
 static inline int stm32x_get_flash_reg(struct flash_bank *bank, uint32_t reg)
 {
 	struct stm32x_flash_bank *stm32x_info = bank-&gt;driver_priv;
-	return reg + stm32x_info-&gt;register_offset;
+	return reg + stm32x_info-&gt;register_base;
 }
 
 static inline int stm32x_get_flash_status(struct flash_bank *bank, uint32_t *status)
@@ -200,7 +207,7 @@ int stm32x_check_operation_supported(struct flash_bank *bank)
 
 	/* if we have a dual flash bank device then
 	 * we need to perform option byte stuff on bank0 only */
-	if (stm32x_info-&gt;register_offset != FLASH_OFFSET_B0)
+	if (stm32x_info-&gt;register_base != FLASH_REG_BASE_B0)
 	{
 		LOG_ERROR(&quot;Option Byte Operation's must use bank0&quot;);
 		return ERROR_FLASH_OPERATION_FAILED;
@@ -218,7 +225,7 @@ static int stm32x_read_options(struct flash_bank *bank)
 	stm32x_info = bank-&gt;driver_priv;
 
 	/* read current option bytes */
-	int retval = target_read_u32(target, STM32_FLASH_OBR, &amp;optiondata);
+	int retval = target_read_u32(target, STM32_FLASH_OBR_B0, &amp;optiondata);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -229,7 +236,7 @@ static int stm32x_read_options(struct flash_bank *bank)
 		LOG_INFO(&quot;Device Security Bit Set&quot;);
 
 	/* each bit refers to a 4bank protection */
-	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;optiondata);
+	retval = target_read_u32(target, STM32_FLASH_WRPR_B0, &amp;optiondata);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -252,27 +259,27 @@ static int stm32x_erase_options(struct flash_bank *bank)
 	stm32x_read_options(bank);
 
 	/* unlock flash registers */
-	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	int retval = target_write_u32(target, STM32_FLASH_KEYR_B0, KEY1);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	retval = target_write_u32(target, STM32_FLASH_KEYR_B0, KEY2);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* unlock option flash registers */
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY1);
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY1);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY2);
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY2);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* erase option bytes */
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTER | FLASH_OPTWRE);
+	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_OPTER | FLASH_OPTWRE);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTER | FLASH_STRT | FLASH_OPTWRE);
+	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_OPTER | FLASH_STRT | FLASH_OPTWRE);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -295,23 +302,23 @@ static int stm32x_write_options(struct flash_bank *bank)
 	stm32x_info = bank-&gt;driver_priv;
 
 	/* unlock flash registers */
-	int retval = target_write_u32(target, STM32_FLASH_KEYR, KEY1);
+	int retval = target_write_u32(target, STM32_FLASH_KEYR_B0, KEY1);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_KEYR, KEY2);
+	retval = target_write_u32(target, STM32_FLASH_KEYR_B0, KEY2);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* unlock option flash registers */
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY1);
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY1);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, STM32_FLASH_OPTKEYR, KEY2);
+	retval = target_write_u32(target, STM32_FLASH_OPTKEYR_B0, KEY2);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* program option bytes */
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_OPTPG | FLASH_OPTWRE);
+	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_OPTPG | FLASH_OPTWRE);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -369,7 +376,7 @@ static int stm32x_write_options(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+	retval = target_write_u32(target, STM32_FLASH_CR_B0, FLASH_LOCK);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -398,7 +405,7 @@ static int stm32x_protect_check(struct flash_bank *bank)
 
 	/* medium density - each bit refers to a 4bank protection
 	 * high density - each bit refers to a 2bank protection */
-	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;protection);
+	retval = target_read_u32(target, STM32_FLASH_WRPR_B0, &amp;protection);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -544,7 +551,7 @@ static int stm32x_protect(struct flash_bank *bank, int set, int first, int last)
 
 	/* medium density - each bit refers to a 4bank protection
 	 * high density - each bit refers to a 2bank protection */
-	retval = target_read_u32(target, STM32_FLASH_WRPR, &amp;protection);
+	retval = target_read_u32(target, STM32_FLASH_WRPR_B0, &amp;protection);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -695,7 +702,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, thisrun_count);
-		buf_set_u32(reg_params[3].value, 0, 32, stm32x_info-&gt;register_offset);
+		buf_set_u32(reg_params[3].value, 0, 32, stm32x_info-&gt;register_base - FLASH_REG_BASE_B0);
 
 		if ((retval = target_run_algorithm(target, 0, NULL, 4, reg_params,
 				stm32x_info-&gt;write_algorithm-&gt;address,
@@ -710,7 +717,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		{
 			LOG_ERROR(&quot;flash memory not erased before writing&quot;);
 			/* Clear but report errors */
-			target_write_u32(target, STM32_FLASH_SR, FLASH_PGERR);
+			target_write_u32(target, STM32_FLASH_SR_B0, FLASH_PGERR);
 			retval = ERROR_FAIL;
 			break;
 		}
@@ -719,7 +726,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		{
 			LOG_ERROR(&quot;flash memory write protected&quot;);
 			/* Clear but report errors */
-			target_write_u32(target, STM32_FLASH_SR, FLASH_WRPRTERR);
+			target_write_u32(target, STM32_FLASH_SR_B0, FLASH_WRPRTERR);
 			retval = ERROR_FAIL;
 			break;
 		}
@@ -832,7 +839,7 @@ static int stm32x_write(struct flash_bank *bank, uint8_t *buffer,
 			return retval;
 	}
 
-	return target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
+	return target_write_u32(target, STM32_FLASH_CR_B0, FLASH_LOCK);
 }
 
 static int stm32x_probe(struct flash_bank *bank)
@@ -846,7 +853,7 @@ static int stm32x_probe(struct flash_bank *bank)
 	uint32_t base_address = 0x08000000;
 
 	stm32x_info-&gt;probed = 0;
-	stm32x_info-&gt;register_offset = FLASH_OFFSET_B0;
+	stm32x_info-&gt;register_base = FLASH_REG_BASE_B0;
 
 	/* read stm32 device id register */
 	int retval = target_read_u32(target, 0xE0042000, &amp;device_id);
@@ -980,7 +987,7 @@ static int stm32x_probe(struct flash_bank *bank)
 		{
 			num_pages -= 512;
 			/* bank1 also uses a register offset */
-			stm32x_info-&gt;register_offset = FLASH_OFFSET_B1;
+			stm32x_info-&gt;register_base = FLASH_REG_BASE_B1;
 			base_address = 0x08080000;
 		}
 	}
@@ -1328,7 +1335,7 @@ COMMAND_HANDLER(stm32x_handle_options_read_command)
 	if (ERROR_OK != retval)
 		return retval;
 
-	retval = target_read_u32(target, STM32_FLASH_OBR, &amp;optionbyte);
+	retval = target_read_u32(target, STM32_FLASH_OBR_B0, &amp;optionbyte);
 	if (retval != ERROR_OK)
 		return retval;
 	command_print(CMD_CTX, &quot;Option Byte: 0x%&quot; PRIx32 &quot;&quot;, optionbyte);

commit 1163435e19f316a4a97fd33f1467f5c1684db654
Author: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;
Date:   Fri Jul 15 22:21:34 2011 +0200

    cortex_m3: use armv7m's async algorithm implementation
    
    Signed-off-by: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;

diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 98a775c..a2f8b78 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -2329,6 +2329,8 @@ struct target_type cortexm3_target =
 	.blank_check_memory = armv7m_blank_check_memory,
 
 	.run_algorithm = armv7m_run_algorithm,
+	.start_algorithm = armv7m_start_algorithm,
+	.wait_algorithm = armv7m_wait_algorithm,
 
 	.add_breakpoint = cortex_m3_add_breakpoint,
 	.remove_breakpoint = cortex_m3_remove_breakpoint,

commit 9d4c466c219039bd6a2ea03467cd3ee8be2a0e76
Author: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;
Date:   Fri Jul 15 22:20:34 2011 +0200

    armv7m: implement async algorithm functions
    
    Split armv7m_run_algorithm into two pieces and use them to reimplement it.
    The arch_info parameter is used to keep context between the two calls, so
    both calls must refer to the same armv7m_algorithm struct. Ugly but works
    for a proof-of-concept.
    
    Signed-off-by: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;

diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index fff5dd8..39a89b9 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -287,53 +287,42 @@ int armv7m_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int
 	return ERROR_OK;
 }
 
-/* run to exit point. return error if exit point was not reached. */
-static int armv7m_run_and_wait(struct target *target, uint32_t entry_point, int timeout_ms, uint32_t exit_point, struct armv7m_common *armv7m)
+/** Runs a Thumb algorithm in the target. */
+int armv7m_run_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t entry_point, uint32_t exit_point,
+	int timeout_ms, void *arch_info)
 {
-	uint32_t pc;
 	int retval;
-	/* This code relies on the target specific  resume() and  poll()-&gt;debug_entry()
-	 * sequence to write register values to the processor and the read them back */
-	if ((retval = target_resume(target, 0, entry_point, 1, 1)) != ERROR_OK)
-	{
-		return retval;
-	}
 
-	retval = target_wait_state(target, TARGET_HALTED, timeout_ms);
-	/* If the target fails to halt due to the breakpoint, force a halt */
-	if (retval != ERROR_OK || target-&gt;state != TARGET_HALTED)
-	{
-		if ((retval = target_halt(target)) != ERROR_OK)
-			return retval;
-		if ((retval = target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
-		{
-			return retval;
-		}
-		return ERROR_TARGET_TIMEOUT;
-	}
+	retval = armv7m_start_algorithm(target,
+			num_mem_params, mem_params,
+			num_reg_params, reg_params,
+			entry_point, exit_point,
+			arch_info);
 
-	armv7m-&gt;load_core_reg_u32(target, ARMV7M_REGISTER_CORE_GP, 15, &amp;pc);
-	if (exit_point &amp;&amp; (pc != exit_point))
-	{
-		LOG_DEBUG(&quot;failed algorithm halted at 0x%&quot; PRIx32 &quot; &quot;, pc);
-		return ERROR_TARGET_TIMEOUT;
-	}
+	if (retval == ERROR_OK)
+		retval = armv7m_wait_algorithm(target,
+				num_mem_params, mem_params,
+				num_reg_params, reg_params,
+				exit_point, timeout_ms,
+				arch_info);
 
-	return ERROR_OK;
+	return retval;
 }
 
-/** Runs a Thumb algorithm in the target. */
-int armv7m_run_algorithm(struct target *target,
+/** Starts a Thumb algorithm in the target. */
+int armv7m_start_algorithm(struct target *target,
 	int num_mem_params, struct mem_param *mem_params,
 	int num_reg_params, struct reg_param *reg_params,
 	uint32_t entry_point, uint32_t exit_point,
-	int timeout_ms, void *arch_info)
+	void *arch_info)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct armv7m_algorithm *armv7m_algorithm_info = arch_info;
 	enum armv7m_mode core_mode = armv7m-&gt;core_mode;
 	int retval = ERROR_OK;
-	uint32_t context[ARMV7M_NUM_REGS];
 
 	/* NOTE: armv7m_run_algorithm requires that each algorithm uses a software breakpoint
 	 * at the exit point */
@@ -356,11 +345,12 @@ int armv7m_run_algorithm(struct target *target,
 	{
 		if (!armv7m-&gt;core_cache-&gt;reg_list[i].valid)
 			armv7m-&gt;read_core_reg(target, i);
-		context[i] = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[i].value, 0, 32);
+		armv7m_algorithm_info-&gt;context[i] = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[i].value, 0, 32);
 	}
 
 	for (int i = 0; i &lt; num_mem_params; i++)
 	{
+		// TODO: Write only out params
 		if ((retval = target_write_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
 			return retval;
 	}
@@ -394,12 +384,52 @@ int armv7m_run_algorithm(struct target *target,
 		armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_CONTROL].dirty = 1;
 		armv7m-&gt;core_cache-&gt;reg_list[ARMV7M_CONTROL].valid = 1;
 	}
+	armv7m_algorithm_info-&gt;core_mode = core_mode;
 
-	retval = armv7m_run_and_wait(target, entry_point, timeout_ms, exit_point, armv7m);
+	retval = target_resume(target, 0, entry_point, 1, 1);
 
-	if (retval != ERROR_OK)
+	return retval;
+}
+
+/** Waits for an algorithm in the target. */
+int armv7m_wait_algorithm(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t exit_point, int timeout_ms,
+	void *arch_info)
+{
+	struct armv7m_common *armv7m = target_to_armv7m(target);
+	struct armv7m_algorithm *armv7m_algorithm_info = arch_info;
+	int retval = ERROR_OK;
+	uint32_t pc;
+
+	/* NOTE: armv7m_run_algorithm requires that each algorithm uses a software breakpoint
+	 * at the exit point */
+
+	if (armv7m_algorithm_info-&gt;common_magic != ARMV7M_COMMON_MAGIC)
 	{
-		return retval;
+		LOG_ERROR(&quot;current target isn't an ARMV7M target&quot;);
+		return ERROR_TARGET_INVALID;
+	}
+
+	retval = target_wait_state(target, TARGET_HALTED, timeout_ms);
+	/* If the target fails to halt due to the breakpoint, force a halt */
+	if (retval != ERROR_OK || target-&gt;state != TARGET_HALTED)
+	{
+		if ((retval = target_halt(target)) != ERROR_OK)
+			return retval;
+		if ((retval = target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
+		{
+			return retval;
+		}
+		return ERROR_TARGET_TIMEOUT;
+	}
+
+	armv7m-&gt;load_core_reg_u32(target, ARMV7M_REGISTER_CORE_GP, 15, &amp;pc);
+	if (exit_point &amp;&amp; (pc != exit_point))
+	{
+		LOG_DEBUG(&quot;failed algorithm halted at 0x%&quot; PRIx32 &quot;, expected 0x%&quot; PRIx32 , pc, exit_point);
+		return ERROR_TARGET_TIMEOUT;
 	}
 
 	/* Read memory values to mem_params[] */
@@ -439,18 +469,18 @@ int armv7m_run_algorithm(struct target *target,
 	{
 		uint32_t regvalue;
 		regvalue = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[i].value, 0, 32);
-		if (regvalue != context[i])
+		if (regvalue != armv7m_algorithm_info-&gt;context[i])
 		{
 			LOG_DEBUG(&quot;restoring register %s with value 0x%8.8&quot; PRIx32,
-				armv7m-&gt;core_cache-&gt;reg_list[i].name, context[i]);
+				armv7m-&gt;core_cache-&gt;reg_list[i].name, armv7m_algorithm_info-&gt;context[i]);
 			buf_set_u32(armv7m-&gt;core_cache-&gt;reg_list[i].value,
-					0, 32, context[i]);
+					0, 32, armv7m_algorithm_info-&gt;context[i]);
 			armv7m-&gt;core_cache-&gt;reg_list[i].valid = 1;
 			armv7m-&gt;core_cache-&gt;reg_list[i].dirty = 1;
 		}
 	}
 
-	armv7m-&gt;core_mode = core_mode;
+	armv7m-&gt;core_mode = armv7m_algorithm_info-&gt;core_mode;
 
 	return retval;
 }
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 8ef3800..ca92146 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -142,6 +142,8 @@ struct armv7m_algorithm
 	int common_magic;
 
 	enum armv7m_mode core_mode;
+
+	uint32_t context[ARMV7M_CONTROL + 1]; //ARMV7M_NUM_REGS
 };
 
 struct armv7m_core_reg
@@ -168,6 +170,18 @@ int armv7m_run_algorithm(struct target *target,
 		uint32_t entry_point, uint32_t exit_point,
 		int timeout_ms, void *arch_info);
 
+int armv7m_start_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		void *arch_info);
+
+int armv7m_wait_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t exit_point, int timeout_ms,
+		void *arch_info);
+
 int armv7m_invalidate_core_regs(struct target *target);
 
 int armv7m_restore_context(struct target *target);

commit 3f6ef7a40bcff5e1278b662248902c45a1dc8f81
Author: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;
Date:   Fri Jul 15 22:18:39 2011 +0200

    target: add async algorithm entries to the target type
    
    On supported targets, this may be used to start a long running algorithm in
    the background so the target may be interacted with during execution and
    later wait for its completion.
    
    The most obvious use case is a double buffered flash algorithm that can
    upload the next block of data while the algorithm is flashing the current.
    
    Signed-off-by: Andreas Fritiofson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andreas.fritiofson at gmail.com</A>&gt;

diff --git a/src/target/target.c b/src/target/target.c
index be9742f..6a60b4e 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -732,6 +732,81 @@ done:
 	return retval;
 }
 
+/**
+ * Downloads a target-specific native code algorithm to the target,
+ * executes and leaves it running.
+ *
+ * @param target used to run the algorithm
+ * @param arch_info target-specific description of the algorithm.
+ */
+int target_start_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		void *arch_info)
+{
+	int retval = ERROR_FAIL;
+
+	if (!target_was_examined(target))
+	{
+		LOG_ERROR(&quot;Target not examined yet&quot;);
+		goto done;
+	}
+	if (!target-&gt;type-&gt;start_algorithm) {
+		LOG_ERROR(&quot;Target type '%s' does not support %s&quot;,
+				target_type_name(target), __func__);
+		goto done;
+	}
+	if (target-&gt;running_alg) {
+		LOG_ERROR(&quot;Target is already running an algorithm&quot;);
+		goto done;
+	}
+
+	target-&gt;running_alg = true;
+	retval = target-&gt;type-&gt;start_algorithm(target,
+			num_mem_params, mem_params,
+			num_reg_params, reg_params,
+			entry_point, exit_point, arch_info);
+
+done:
+	return retval;
+}
+
+/**
+ * Waits for an algorithm started with target_start_algorithm() to complete.
+ *
+ * @param target used to run the algorithm
+ * @param arch_info target-specific description of the algorithm.
+ */
+int target_wait_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t exit_point, int timeout_ms,
+		void *arch_info)
+{
+	int retval = ERROR_FAIL;
+
+	if (!target-&gt;type-&gt;wait_algorithm) {
+		LOG_ERROR(&quot;Target type '%s' does not support %s&quot;,
+				target_type_name(target), __func__);
+		goto done;
+	}
+	if (!target-&gt;running_alg) {
+		LOG_ERROR(&quot;Target is not running an algorithm&quot;);
+		goto done;
+	}
+
+	retval = target-&gt;type-&gt;wait_algorithm(target,
+			num_mem_params, mem_params,
+			num_reg_params, reg_params,
+			exit_point, timeout_ms, arch_info);
+	if (retval != ERROR_TARGET_TIMEOUT)
+		target-&gt;running_alg = false;
+
+done:
+	return retval;
+}
+
 
 int target_read_memory(struct target *target,
 		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
diff --git a/src/target/target.h b/src/target/target.h
index 5248d69..12726bd 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -432,6 +432,28 @@ int target_run_algorithm(struct target *target,
 		int timeout_ms, void *arch_info);
 
 /**
+ * Starts an algorithm in the background on the @a target given.
+ *
+ * This routine is a wrapper for target-&gt;type-&gt;start_algorithm.
+ */
+int target_start_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t entry_point, uint32_t exit_point,
+		void *arch_info);
+
+/**
+ * Wait for an algorithm on the @a target given.
+ *
+ * This routine is a wrapper for target-&gt;type-&gt;wait_algorithm.
+ */
+int target_wait_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint32_t exit_point, int timeout_ms,
+		void *arch_info);
+
+/**
  * Read @a count items of @a size bytes from the memory of @a target at
  * the @a address given.
  *
diff --git a/src/target/target_type.h b/src/target/target_type.h
index fc062da..10b6f33 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -171,6 +171,8 @@ struct target_type
 	 * use target_run_algorithm() instead.
 	 */
 	int (*run_algorithm)(struct target *target, int num_mem_params, struct mem_param *mem_params, int num_reg_params, struct reg_param *reg_param, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
+	int (*start_algorithm)(struct target *target, int num_mem_params, struct mem_param *mem_params, int num_reg_params, struct reg_param *reg_param, uint32_t entry_point, uint32_t exit_point, void *arch_info);
+	int (*wait_algorithm)(struct target *target, int num_mem_params, struct mem_param *mem_params, int num_reg_params, struct reg_param *reg_param, uint32_t exit_point, int timeout_ms, void *arch_info);
 
 	const struct command_registration *commands;
 

-----------------------------------------------------------------------

Summary of changes:
 contrib/loaders/flash/{stm32x.S =&gt; stm32f1x.S} |   71 ++++---
 src/flash/nor/stm32f1x.c                       |  303 ++++++++++++++++--------
 src/target/armv7m.c                            |  110 ++++++---
 src/target/armv7m.h                            |   14 +
 src/target/cortex_m3.c                         |    2 +
 src/target/target.c                            |   75 ++++++
 src/target/target.h                            |   22 ++
 src/target/target_type.h                       |    2 +
 8 files changed, 436 insertions(+), 163 deletions(-)
 rename contrib/loaders/flash/{stm32x.S =&gt; stm32f1x.S} (51%)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002697.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-99-ge56e5a3
</A></li>
	<LI>Next message: <A HREF="002699.html">[openocd-svn] Main OpenOCD repository branch, v0.3.1,	deleted. v0.3.1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2698">[ date ]</a>
              <a href="thread.html#2698">[ thread ]</a>
              <a href="subject.html#2698">[ subject ]</a>
              <a href="author.html#2698">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
