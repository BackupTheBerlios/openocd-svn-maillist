From gowinex at users.sourceforge.net  Mon May  3 11:58:20 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  3 May 2010 09:58:20 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-201-g14f4606
Message-ID: <E1O8sPu-0003Ag-DE@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  14f4606dcb0533ab64562406edd157008108e0db (commit)
      from  da9f72ca0a3305cf6f961834dc441496a36c85de (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 14f4606dcb0533ab64562406edd157008108e0db
Author: Tobias Ringstr??m <tobias at ringis.se>
Date:   Fri Apr 30 14:04:14 2010 +0200

    STM32 flash erase timeout fix
    
    The current timeout for STM32 flash block erase and flash mass erase is
    10 (ms), which is too tight, and fails around 50% of the time for me.
    The data sheet for STM32F107VC specifies a maximum erase time of 40 ms
    (for both operations).
    
    I'd also consider it a bug that the code does not detect a timeout, but
    just assumes that the operation has completed.  The attached patch does
    not address this bug.
    
    The attached patch increases the timeouts from 10 to 100 ms.  Please apply.
    
    /Tobias

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 818c474..0fdd148 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -331,7 +331,7 @@ static int stm32x_erase(struct flash_bank *bank, int first, int last)
 		target_write_u32(target, STM32_FLASH_AR, bank->base + bank->sectors[i].offset);
 		target_write_u32(target, STM32_FLASH_CR, FLASH_PER | FLASH_STRT);
 
-		status = stm32x_wait_status_busy(bank, 10);
+		status = stm32x_wait_status_busy(bank, 100);
 
 		if (status & FLASH_WRPRTERR)
 			return ERROR_FLASH_OPERATION_FAILED;
@@ -1183,7 +1183,7 @@ static int stm32x_mass_erase(struct flash_bank *bank)
 	target_write_u32(target, STM32_FLASH_CR, FLASH_MER);
 	target_write_u32(target, STM32_FLASH_CR, FLASH_MER | FLASH_STRT);
 
-	status = stm32x_wait_status_busy(bank, 10);
+	status = stm32x_wait_status_busy(bank, 100);
 
 	target_write_u32(target, STM32_FLASH_CR, FLASH_LOCK);
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stm32x.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May  4 09:16:08 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  4 May 2010 07:16:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-202-gfe60480
Message-ID: <E1O9CMW-0004gQ-IU@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fe60480b7a8f5c94147e3185bae235241c33c9ce (commit)
      from  14f4606dcb0533ab64562406edd157008108e0db (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fe60480b7a8f5c94147e3185bae235241c33c9ce
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue May 4 07:25:30 2010 +0200

    cfi: made som info output debug output
    
    E.g. how much target memory that is used during flashing
    is debug info.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index a64d78f..f88f16c 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1141,7 +1141,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 	busy_pattern_val  = cfi_command_val(bank, 0x80);
 	error_pattern_val = cfi_command_val(bank, 0x7e);
 
-	LOG_INFO("Using target buffer at 0x%08" PRIx32 " and of size 0x%04" PRIx32, source->address, buffer_size);
+	LOG_DEBUG("Using target buffer at 0x%08" PRIx32 " and of size 0x%04" PRIx32, source->address, buffer_size);
 
 	/* Programming main loop */
 	while (count > 0)
@@ -1162,7 +1162,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 		buf_set_u32(reg_params[5].value, 0, 32, busy_pattern_val);
 		buf_set_u32(reg_params[6].value, 0, 32, error_pattern_val);
 
-		LOG_INFO("Write 0x%04" PRIx32 " bytes to flash at 0x%08" PRIx32 , thisrun_count, address);
+		LOG_DEBUG("Write 0x%04" PRIx32 " bytes to flash at 0x%08" PRIx32 , thisrun_count, address);
 
 		/* Execute algorithm, assume breakpoint for last instruction */
 		retval = target_run_algorithm(target, 0, NULL, 7, reg_params,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May  4 09:16:36 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  4 May 2010 07:16:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-203-g32e647a
Message-ID: <E1O9CMv-0004rb-Hz@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  32e647acf40bc11858a524e5ee73183ce0d9449b (commit)
      from  fe60480b7a8f5c94147e3185bae235241c33c9ce (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 32e647acf40bc11858a524e5ee73183ce0d9449b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue May 4 07:36:05 2010 +0200

    zy1000: wait for srst to deassert
    
    make wait for srst deassert more long latency friendly
    (JTAG over TCP/IP), print actual time if it was more than
    1ms.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 80731aa..092e3cd 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -49,6 +49,7 @@
 #include <jtag/minidriver.h>
 #include <jtag/interface.h>
 #include <time.h>
+#include <helper/time_support.h>
 
 #include <netinet/tcp.h>
 
@@ -176,28 +177,41 @@ void zy1000_reset(int trst, int srst)
 	}
 
 	/* wait for srst to float back up */
-	if (!srst)
+	if ((!srst && ((jtag_get_reset_config() & RESET_TRST_PULLS_SRST) == 0))||
+		(!srst && !trst && (jtag_get_reset_config() & RESET_TRST_PULLS_SRST)))
 	{
-		int i;
-		for (i = 0; i < 1000; i++)
-		{
+		bool first = true;
+		long long start;
+		long total = 0;
+		for (;;)
+		{	
 			// We don't want to sense our own reset, so we clear here.
 			// There is of course a timing hole where we could loose
 			// a "real" reset.
 			if (!readSRST())
+			{
+				if (total > 1)
+				{
+				  LOG_USER("SRST took %dms to deassert", (int)total);
+				}
 				break;
+			}
 
-			/* wait 1ms */
-			alive_sleep(1);
-		}
+			if (first)
+			{
+			    first = false;
+			    start = timeval_ms();
+			}
 
-		if (i == 1000)
-		{
-			LOG_USER("SRST didn't deassert after %dms", i);
-		} else if (i > 1)
-		{
-			LOG_USER("SRST took %dms to deassert", i);
+			total = timeval_ms() - start;
+
+			if (total > 5000)
+			{
+				LOG_ERROR("SRST took too long to deassert: %dms", (int)total);
+			    break;
+			}
 		}
+
 	}
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   40 +++++++++++++++++++++++++++-------------
 1 files changed, 27 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May  4 09:19:31 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  4 May 2010 07:19:31 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-206-g282e89c
Message-ID: <E1O9CPk-0004rV-Jx@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  282e89c878fd43ba90f0a9416adce81c5f596af7 (commit)
       via  70226c221f5879bb6126ff3f2ec9ae64c68d80d6 (commit)
       via  8865209545dae9c2745927758a51c60f922e02ca (commit)
      from  32e647acf40bc11858a524e5ee73183ce0d9449b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 282e89c878fd43ba90f0a9416adce81c5f596af7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon May 3 18:11:34 2010 +0200

    flash: less bogus errors
    
    Removed bogus errors when trying to allocate a large
    a target memory buffer as possible.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 57c591d..82ea2bc 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -227,7 +227,7 @@ static int aduc702x_write_block(struct flash_bank *bank, uint8_t *buffer, uint32
 	}
 
 	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= 256)
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index f88f16c..9967652 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1116,7 +1116,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, uint8_t *buffer, uint3
 	/* Get a workspace buffer for the data to flash starting with 32k size.
 	   Half size until buffer would be smaller 256 Bytem then fail back */
 	/* FIXME Why 256 bytes, why not 32 bytes (smallest flash write page */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= 256)
@@ -1444,7 +1444,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 	}
 	/* the following code still assumes target code is fixed 24*4 bytes */
 
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= 256)
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 360c14d..5b00495 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1288,7 +1288,7 @@ static int lpc2900_write(struct flash_bank *bank, uint8_t *buffer,
 	   reduced size if that fails. */
 	struct working_area *warea;
 	uint32_t buffer_size = lpc2900_info->max_ram_block - 1 * KiB;
-	while( (retval = target_alloc_working_area(target,
+	while( (retval = target_alloc_working_area_try(target,
 	                                           buffer_size + target_code_size,
 	                                           &warea)) != ERROR_OK )
 	{
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 2540342..4ebd256 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -322,7 +322,7 @@ static int pic32mx_write_block(struct flash_bank *bank, uint8_t *buffer,
 		return retval;
 
 	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= 256)
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 0b7c45a..cce5f37 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -846,7 +846,7 @@ static int stellaris_write_block(struct flash_bank *bank,
 		buffer_size = wcount * 4;
 
 	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= buf_min)
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 0fdd148..7afd959 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -481,7 +481,7 @@ static int stm32x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		return retval;
 
 	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= 256)
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 3d8b84b..2208fe3 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -385,7 +385,7 @@ static int str9x_write_block(struct flash_bank *bank,
 			(uint8_t*)str9x_flash_write_code);
 
 	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= 256)

commit 70226c221f5879bb6126ff3f2ec9ae64c68d80d6
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon May 3 15:50:39 2010 +0200

    str7x: fix bogus error messages
    
    Remove bogus error messages when trying to allocate a
    large chunk of target memory and then falling back to
    a smaller one.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index d5e8e28..556dec2 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -355,10 +355,9 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
 	};
 
 	/* flash write code */
-	if (target_alloc_working_area(target, sizeof(str7x_flash_write_code),
+	if (target_alloc_working_area_try(target, sizeof(str7x_flash_write_code),
 			&str7x_info->write_algorithm) != ERROR_OK)
 	{
-		LOG_WARNING("no working area available, can't do block memory writes");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
@@ -367,7 +366,7 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
 			(uint8_t*)str7x_flash_write_code);
 
 	/* memory buffer */
-	while (target_alloc_working_area(target, buffer_size, &source) != ERROR_OK)
+	while (target_alloc_working_area_try(target, buffer_size, &source) != ERROR_OK)
 	{
 		buffer_size /= 2;
 		if (buffer_size <= 256)
@@ -499,6 +498,9 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 				/* if block write failed (no sufficient working area),
 				 * we use normal (slow) single dword accesses */
 				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
+			} else
+			{
+				return retval;
 			}
 			else if (retval == ERROR_FLASH_OPERATION_FAILED)
 			{

commit 8865209545dae9c2745927758a51c60f922e02ca
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon May 3 15:49:23 2010 +0200

    target: clean up target memory allocation error messages
    
    target memory allocation can be implemented not to show
    bogus error messages.
    
    E.g. when trying a big allocation first and then a
    smaller one if that fails.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.c b/src/target/target.c
index 73594fb..a3a1b0a 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1111,7 +1111,7 @@ int target_call_timer_callbacks_now(void)
 	return target_call_timer_callbacks_check_time(0);
 }
 
-int target_alloc_working_area(struct target *target, uint32_t size, struct working_area **area)
+int target_alloc_working_area_try(struct target *target, uint32_t size, struct working_area **area)
 {
 	struct working_area *c = target->working_areas;
 	struct working_area *new_wa = NULL;
@@ -1189,8 +1189,6 @@ int target_alloc_working_area(struct target *target, uint32_t size, struct worki
 
 		if (free_size < size)
 		{
-			LOG_WARNING("not enough working area available(requested %u, free %u)",
-				    (unsigned)(size), (unsigned)(free_size));
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
 
@@ -1231,6 +1229,19 @@ int target_alloc_working_area(struct target *target, uint32_t size, struct worki
 	return ERROR_OK;
 }
 
+int target_alloc_working_area(struct target *target, uint32_t size, struct working_area **area)
+{
+	int retval;
+
+	retval = target_alloc_working_area_try(target, size, area);
+	if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
+	{
+		LOG_WARNING("not enough working area available(requested %u)", (unsigned)(size));
+	}
+	return retval;
+
+}
+
 static int target_free_working_area_restore(struct target *target, struct working_area *area, int restore)
 {
 	if (area->free)
diff --git a/src/target/target.h b/src/target/target.h
index 0292945..4a48e5a 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -452,6 +452,14 @@ const char *target_state_name( struct target *target );
  */
 int target_alloc_working_area(struct target *target,
 		uint32_t size, struct working_area **area);
+/* Same as target_alloc_working_area, except that no error is logged
+ * when ERROR_TARGET_RESOURCE_NOT_AVAILABLE is returned.
+ *
+ * This allows the calling code to *try* to allocate target memory
+ * and have a fallback to another behavior(slower?).
+ */
+int target_alloc_working_area_try(struct target *target,
+		uint32_t size, struct working_area **area);
 int target_free_working_area(struct target *target, struct working_area *area);
 void target_free_all_working_areas(struct target *target);
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/aduc702x.c  |    2 +-
 src/flash/nor/cfi.c       |    4 ++--
 src/flash/nor/lpc2900.c   |    2 +-
 src/flash/nor/pic32mx.c   |    2 +-
 src/flash/nor/stellaris.c |    2 +-
 src/flash/nor/stm32x.c    |    2 +-
 src/flash/nor/str7x.c     |    8 +++++---
 src/flash/nor/str9x.c     |    2 +-
 src/target/target.c       |   17 ++++++++++++++---
 src/target/target.h       |    8 ++++++++
 10 files changed, 35 insertions(+), 14 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue May  4 16:53:16 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue,  4 May 2010 14:53:16 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-207-g909130e
Message-ID: <E1O9JUr-0004Bp-Pc@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  909130e16ee70157d3de6cd5c15fdea0f8fe6a6f (commit)
      from  282e89c878fd43ba90f0a9416adce81c5f596af7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 909130e16ee70157d3de6cd5c15fdea0f8fe6a6f
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue May 4 15:51:43 2010 +0100

    str71x: fix previous commit
    
    fix build issue with 70226c221f5879bb6126ff3f2ec9ae64c68d80d6 commit
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 556dec2..adabad7 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -498,9 +498,6 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 				/* if block write failed (no sufficient working area),
 				 * we use normal (slow) single dword accesses */
 				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
-			} else
-			{
-				return retval;
 			}
 			else if (retval == ERROR_FLASH_OPERATION_FAILED)
 			{
@@ -510,6 +507,10 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 				LOG_ERROR("flash writing failed with error code: 0x%x", retval);
 				return ERROR_FLASH_OPERATION_FAILED;
 			}
+			else
+			{
+				return retval;
+			}
 		}
 		else
 		{

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str7x.c |    7 ++++---
 1 files changed, 4 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May  5 11:13:13 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  5 May 2010 09:13:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-209-gca0f6a5
Message-ID: <E1O9afL-0004MY-Db@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ca0f6a5c58fb94d590362d9a7d99543919fbbf43 (commit)
      from  80660288e0ff0f2a1887287e5177e52c54b14347 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ca0f6a5c58fb94d590362d9a7d99543919fbbf43
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Wed May 5 10:39:20 2010 +0200

    documentation typo
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 7d54247..49df159 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -332,7 +332,7 @@ and one can be used for a UART adapter at the same time the
 other one is used to provide a debug adapter.
 
 Also, some development boards integrate an FT2232 chip to serve as
-a built-in low coast debug adapter and usb-to-serial solution.
+a built-in low cost debug adapter and usb-to-serial solution.
 
 @itemize @bullet
 @item @b{usbjtag}

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May  5 15:42:46 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed,  5 May 2010 13:42:46 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-213-g31b0501
Message-ID: <E1O9esD-0002Sx-3a@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  31b050108a1cd740b326dddfa7a2f1322ee8c186 (commit)
       via  91b9f3de0b8e3277ab5c584c6076ddfe491ffc86 (commit)
       via  7e33f87b3d25331f3ac366c88e0b0ebb196422ec (commit)
       via  0d8f60e28f0f6e2bf65c674154b129fffae9eca8 (commit)
      from  ca0f6a5c58fb94d590362d9a7d99543919fbbf43 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 31b050108a1cd740b326dddfa7a2f1322ee8c186
Author: Matthias Bode <papabaer.embedded at googlemail.com>
Date:   Mon May 3 22:35:38 2010 +0200

    Fixed bug in tcl-server
    
    No segmentationfault when sending commands to tcl-server.
    
    	modified:   src/server/server.c
    	modified:   src/server/tcl_server.c
    	modified:   src/server/tcl_server.h

diff --git a/src/server/server.c b/src/server/server.c
index 0d3273b..7e57228 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -513,7 +513,7 @@ int server_preinit(void)
 
 int server_init(struct command_context *cmd_ctx)
 {
-	int ret = tcl_init(cmd_ctx);
+	int ret = tcl_init();
 	if (ERROR_OK != ret)
 		return ret;
 
diff --git a/src/server/tcl_server.c b/src/server/tcl_server.c
index a88c436..7c8e130 100644
--- a/src/server/tcl_server.c
+++ b/src/server/tcl_server.c
@@ -81,7 +81,7 @@ static int tcl_new_connection(struct connection *connection)
 
 static int tcl_input(struct connection *connection)
 {
-	Jim_Interp *interp = (Jim_Interp *)connection->priv;
+	Jim_Interp *interp = (Jim_Interp *)connection->cmd_ctx->interp;
 	int retval;
 	int i;
 	ssize_t rlen;
@@ -157,7 +157,7 @@ static int tcl_closed(struct connection *connection)
 	return ERROR_OK;
 }
 
-int tcl_init(struct command_context *cmd_ctx)
+int tcl_init(void)
 {
 	int retval;
 
@@ -169,7 +169,7 @@ int tcl_init(struct command_context *cmd_ctx)
 
 	retval = add_service("tcl", CONNECTION_TCP, tcl_port, 1,
 			&tcl_new_connection, &tcl_input,
-			&tcl_closed, cmd_ctx->interp);
+			&tcl_closed, NULL);
 	return retval;
 }
 
diff --git a/src/server/tcl_server.h b/src/server/tcl_server.h
index 68ad821..8035a04 100644
--- a/src/server/tcl_server.h
+++ b/src/server/tcl_server.h
@@ -22,7 +22,7 @@
 
 #include <server/server.h>
 
-int tcl_init(struct command_context *cmd_ctx);
+int tcl_init(void);
 int tcl_register_commands(struct command_context *cmd_ctx);
 
 #endif /* _TCL_SERVER_H_ */

commit 91b9f3de0b8e3277ab5c584c6076ddfe491ffc86
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon May 3 17:01:53 2010 +0200

    command context: fix errors when running certain commands on startup
    
    Various commands, e.g. "arm mcr xxxx" would fail if invoked upon startup
    since it there was no command context defined for the jim interpreter
    in that case.
    
    A Jim interpreter is now associated with a command context(telnet,
    gdb server's) or the default global command context.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/command.c b/src/helper/command.c
index 3625508..be262f2 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -167,14 +167,18 @@ static const char **script_command_args_alloc(
 	return words;
 }
 
-static struct command_context *current_command_context(Jim_Interp *interp)
+struct command_context *current_command_context(Jim_Interp *interp)
 {
 	/* grab the command context from the associated data */
 	struct command_context *cmd_ctx = Jim_GetAssocData(interp, "context");
 	if (NULL == cmd_ctx)
 	{
 		/* Tcl can invoke commands directly instead of via command_run_line(). This would
-		 * happen when the Jim Tcl interpreter is provided by eCos.
+		 * happen when the Jim Tcl interpreter is provided by eCos or if we are running
+		 * commands in a startup script.
+		 *
+		 * A telnet or gdb server would provide a non-default command context to
+		 * handle piping of error output, have a separate current target, etc.
 		 */
 		cmd_ctx = global_cmd_ctx;
 	}
diff --git a/src/helper/command.h b/src/helper/command.h
index 8a418d3..2c19241 100644
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -311,6 +311,10 @@ void command_set_output_handler(struct command_context* context,
 
 int command_context_mode(struct command_context *context, enum command_mode mode);
 
+/* Return the current command context associated with the Jim interpreter or
+ * alternatively the global default command interpreter
+ */
+struct command_context *current_command_context(Jim_Interp *interp);
 /**
  * Creates a new command context using the startup TCL provided and
  * the existing Jim interpreter, if any. If interp == NULL, then command_init
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 579ca9e..ea6d07e 100644
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -684,7 +684,7 @@ static int jim_jtag_arp_init(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		Jim_WrongNumArgs(goi.interp, 1, goi.argv-1, "(no params)");
 		return JIM_ERR;
 	}
-	struct command_context *context = Jim_GetAssocData(interp, "context");
+	struct command_context *context = current_command_context(interp);
 	int e = jtag_init_inner(context);
 	if (e != ERROR_OK) {
 		Jim_SetResult_sprintf(goi.interp, "error: %d", e);
@@ -701,7 +701,7 @@ static int jim_jtag_arp_init_reset(Jim_Interp *interp, int argc, Jim_Obj *const
 		Jim_WrongNumArgs(goi.interp, 1, goi.argv-1, "(no params)");
 		return JIM_ERR;
 	}
-	struct command_context *context = Jim_GetAssocData(interp, "context");
+	struct command_context *context = current_command_context(interp);
 	int e = jtag_init_reset(context);
 	if (e != ERROR_OK) {
 		Jim_SetResult_sprintf(goi.interp, "error: %d", e);
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index eeb6694..1a84a5f 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -820,11 +820,9 @@ static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	struct arm *arm;
 	int retval;
 
-	context = Jim_GetAssocData(interp, "context");
-	if (context == NULL) {
-		LOG_ERROR("%s: no command context", __func__);
-		return JIM_ERR;
-	}
+	context = current_command_context(interp);
+	assert( context != NULL);
+
 	target = get_current_target(context);
 	if (target == NULL) {
 		LOG_ERROR("%s: no current target", __func__);
diff --git a/src/target/target.c b/src/target/target.c
index a3a1b0a..d17bb74 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3236,12 +3236,9 @@ static int jim_mem2array(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	struct command_context *context;
 	struct target *target;
 
-	context = Jim_GetAssocData(interp, "context");
-	if (context == NULL)
-	{
-		LOG_ERROR("mem2array: no command context");
-		return JIM_ERR;
-	}
+	context = current_command_context(interp);
+	assert (context != NULL);
+
 	target = get_current_target(context);
 	if (target == NULL)
 	{
@@ -3432,11 +3429,9 @@ static int jim_array2mem(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	struct command_context *context;
 	struct target *target;
 
-	context = Jim_GetAssocData(interp, "context");
-	if (context == NULL) {
-		LOG_ERROR("array2mem: no command context");
-		return JIM_ERR;
-	}
+	context = current_command_context(interp);
+	assert (context != NULL);
+
 	target = get_current_target(context);
 	if (target == NULL) {
 		LOG_ERROR("array2mem: no current target");
@@ -4318,7 +4313,9 @@ static int jim_target_wait_state(Jim_Interp *interp, int argc, Jim_Obj *const *a
  */
 static int jim_target_event_list(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
-	struct command_context *cmd_ctx = Jim_GetAssocData(interp, "context");
+	struct command_context *cmd_ctx = current_command_context(interp);
+	assert (cmd_ctx != NULL);
+
 	struct target *target = Jim_CmdPrivData(interp);
 	struct target_event_action *teap = target->event_action;
 	command_print(cmd_ctx, "Event actions for target (%d) %s\n",
@@ -4512,7 +4509,9 @@ static int target_create(Jim_GetOptInfo *goi)
 	struct target *target;
 	struct command_context *cmd_ctx;
 
-	cmd_ctx = Jim_GetAssocData(goi->interp, "context");
+	cmd_ctx = current_command_context(goi->interp);
+	assert (cmd_ctx != NULL);
+
 	if (goi->argc < 3) {
 		Jim_WrongNumArgs(goi->interp, 1, goi->argv, "?name? ?type? ..options...");
 		return JIM_ERR;
@@ -4686,7 +4685,9 @@ static int jim_target_current(Jim_Interp *interp, int argc, Jim_Obj *const *argv
 		Jim_WrongNumArgs(interp, 1, argv, "Too many parameters");
 		return JIM_ERR;
 	}
-	struct command_context *cmd_ctx = Jim_GetAssocData(interp, "context");
+	struct command_context *cmd_ctx = current_command_context(interp);
+	assert (cmd_ctx != NULL);
+
 	Jim_SetResultString(interp, get_current_target(cmd_ctx)->cmd_name, -1);
 	return JIM_OK;
 }

commit 7e33f87b3d25331f3ac366c88e0b0ebb196422ec
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue May 4 07:29:40 2010 +0200

    flash: more flash write_image bugfixes
    
    Remove/fix lots of bugs in handling of non-contigious sections
    and out of order sections.
    
    Fix a gaffe introduced in previous commit to src/flash/nor/core.c
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 9a77353..e6c0eeb 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -602,15 +602,12 @@ int flash_write_unlock(struct target *target, struct image *image,
 		while ((run_address + run_size - 1 < c->base + c->size - 1)
 				&& (section_last + 1 < image->num_sections))
 		{
-			if (sections[section_last + 1]->base_address < (run_address + run_size))
+			/* sections are sorted */
+			assert(sections[section_last + 1]->base_address >= c->base);
+			if (sections[section_last + 1]->base_address >= (c->base + c->size))
 			{
-				LOG_DEBUG("section %d out of order "
-						"(surprising, but supported)",
-						section_last + 1);
-				/* REVISIT this can break with autoerase ...
-				 * clobbering data after it's written.
-				 */
-				break;
+			  /* Done with this bank */
+			  break;
 			}
 
 			/* FIXME This needlessly touches sectors BETWEEN the
@@ -631,8 +628,6 @@ int flash_write_unlock(struct target *target, struct image *image,
 			 * flash programming could fail due to alignment issues
 			 * attempt to rebuild a consecutive buffer for the flash loader */
 			pad_bytes = (sections[section_last + 1]->base_address) - (run_address + run_size);
-			if ((run_address + run_size + pad_bytes) > (c->base + c->size))
-				break;
 			padding[section_last] = pad_bytes;
 			run_size += sections[++section_last]->size;
 			run_size += pad_bytes;
@@ -641,16 +636,7 @@ int flash_write_unlock(struct target *target, struct image *image,
 				LOG_INFO("Padding image section %d with %d bytes", section_last-1, pad_bytes);
 		}
 
-		/* fit the run into bank constraints */
-		if (run_address + run_size - 1 > c->base + c->size - 1)
-		{
-			/* REVISIT isn't this superfluous, given the while()
-			 * loop conditions above??
-			 */
-			LOG_WARNING("writing %d bytes only - as image section is %d bytes and bank is only %d bytes", \
-				    (int)(c->base + c->size - run_address), (int)(run_size), (int)(c->size));
-			run_size = c->base + c->size - run_address;
-		}
+		assert (run_address + run_size - 1 <= c->base + c->size - 1);
 
 		/* If we're applying any sector automagic, then pad this
 		 * (maybe-combined) segment to the end of its last sector.
@@ -691,8 +677,12 @@ int flash_write_unlock(struct target *target, struct image *image,
 			 * #??%#"%??% we have to figure out the section # from the sorted
 			 * list of pointers to sections to invoke image_read_section()...
 			 */
-			int t_section_num = (sections[section] - image->sections) / sizeof(struct imageection);
+			intptr_t diff = (intptr_t)sections[section] - (intptr_t)image->sections;
+			int t_section_num = diff / sizeof(struct imageection);
 
+			LOG_DEBUG("image_read_section: section = %d, t_section_num = %d, section_offset = %d, buffer_size = %d, size_read = %d", 
+				 (int)section,
+(int)t_section_num, (int)section_offset, (int)buffer_size, (int)size_read);
 			if ((retval = image_read_section(image, t_section_num, section_offset,
 					size_read, buffer + buffer_size, &size_read)) != ERROR_OK || size_read == 0)
 			{

commit 0d8f60e28f0f6e2bf65c674154b129fffae9eca8
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon May 3 15:25:35 2010 +0200

    str7x: improve error handling
    
    clean up error handling a bit. No change in behavior.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index adabad7..3d52341 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -5,6 +5,9 @@
  *   Copyright (C) 2008 by Spencer Oliver                                  *
  *   spen at spen-soft.co.uk                                                  *
  *                                                                         *
+ *   Copyright (C) 2010 ??yvind Harboe                                      *
+ *   oyvind.harboe at zylin.com                                               *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -162,22 +165,88 @@ FLASH_BANK_COMMAND_HANDLER(str7x_flash_bank_command)
 	return ERROR_OK;
 }
 
-static uint32_t str7x_status(struct flash_bank *bank)
+/* wait for flash to become idle or report errors.
+
+   FIX!!! what's the maximum timeout??? The documentation doesn't
+   state any maximum time.... by inspection it seems > 1000ms is to be
+   expected.
+
+   10000ms is long enough that it should cover anything, yet not
+   quite be equivalent to an infinite loop.
+
+ */
+static int str7x_waitbusy(struct flash_bank *bank)
 {
+	int err;
+	int i;
 	struct target *target = bank->target;
-	uint32_t retval;
+	struct str7x_flash_bank *str7x_info = bank->driver_priv;
 
-	target_read_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), &retval);
+	for (i = 0 ; i < 10000; i++)
+	{
+		uint32_t retval;
+		err = target_read_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), &retval);
+		if (err != ERROR_OK)
+			return err;
 
-	return retval;
+		if ((retval & str7x_info->busy_bits) == 0)
+			return ERROR_OK;
+
+		alive_sleep(1);
+	}
+	LOG_ERROR("Timed out waiting for str7x flash");
+	return ERROR_FAIL;
 }
 
-static uint32_t str7x_result(struct flash_bank *bank)
+
+static int str7x_result(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
 	uint32_t retval;
 
-	target_read_u32(target, str7x_get_flash_adr(bank, FLASH_ER), &retval);
+	int err;
+	err = target_read_u32(target, str7x_get_flash_adr(bank, FLASH_ER), &retval);
+	if (err != ERROR_OK)
+		return err;
+
+	if (retval & FLASH_WPF)
+	{
+		LOG_ERROR("str7x hw write protection set");
+		err = ERROR_FAIL;
+	}
+	if (retval & FLASH_RESER)
+	{
+		LOG_ERROR("str7x suspended program erase not resumed");
+		err = ERROR_FAIL;
+	}
+	if (retval & FLASH_10ER)
+	{
+		LOG_ERROR("str7x trying to set bit to 1 when it is already 0");
+		err = ERROR_FAIL;
+	}
+	if (retval & FLASH_PGER)
+	{
+		LOG_ERROR("str7x program error");
+		err = ERROR_FAIL;
+	}
+	if (retval & FLASH_ERER)
+	{
+		LOG_ERROR("str7x erase error");
+		err = ERROR_FAIL;
+	}
+	if (err == ERROR_OK)
+	{
+		if (retval & FLASH_ERR)
+		{
+			/* this should always be set if one of the others are set... */
+			LOG_ERROR("str7x write operation failed / bad setup");
+			err = ERROR_FAIL;
+		}
+	}
+	if (err != ERROR_OK)
+	{
+		LOG_ERROR("FLASH_ER register contents: 0x%" PRIx32, retval);
+	}
 
 	return retval;
 }
@@ -216,8 +285,8 @@ static int str7x_erase(struct flash_bank *bank, int first, int last)
 
 	int i;
 	uint32_t cmd;
-	uint32_t retval;
 	uint32_t sectors = 0;
+	int err;
 
 	if (bank->target->state != TARGET_HALTED)
 	{
@@ -233,28 +302,32 @@ static int str7x_erase(struct flash_bank *bank, int first, int last)
 	LOG_DEBUG("sectors: 0x%" PRIx32 "", sectors);
 
 	/* clear FLASH_ER register */
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_ER), 0x0);
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_ER), 0x0);
+	if (err != ERROR_OK)
+		return err;
 
 	cmd = FLASH_SER;
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
+	if (err != ERROR_OK)
+		return err;
 
 	cmd = sectors;
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR1), cmd);
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR1), cmd);
+	if (err != ERROR_OK)
+		return err;
 
 	cmd = FLASH_SER | FLASH_WMS;
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
+	if (err != ERROR_OK)
+		return err;
 
-	while (((retval = str7x_status(bank)) & str7x_info->busy_bits)) {
-		alive_sleep(1);
-	}
+	err = str7x_waitbusy(bank);
+	if (err != ERROR_OK)
+		return err;
 
-	retval = str7x_result(bank);
-
-	if (retval)
-	{
-		LOG_ERROR("error erasing flash bank, FLASH_ER: 0x%" PRIx32 "", retval);
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
+	err = str7x_result(bank);
+	if (err != ERROR_OK)
+		return err;
 
 	for (i = first; i <= last; i++)
 		bank->sectors[i].is_erased = 1;
@@ -268,7 +341,6 @@ static int str7x_protect(struct flash_bank *bank, int set, int first, int last)
 	struct target *target = bank->target;
 	int i;
 	uint32_t cmd;
-	uint32_t retval;
 	uint32_t protect_blocks;
 
 	if (bank->target->state != TARGET_HALTED)
@@ -286,37 +358,43 @@ static int str7x_protect(struct flash_bank *bank, int set, int first, int last)
 	}
 
 	/* clear FLASH_ER register */
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_ER), 0x0);
+	int err;
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_ER), 0x0);
+	if (err != ERROR_OK)
+		return err;
 
 	cmd = FLASH_SPR;
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
+	if (err != ERROR_OK)
+		return err;
 
 	cmd = str7x_get_flash_adr(bank, FLASH_NVWPAR);
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), cmd);
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), cmd);
+	if (err != ERROR_OK)
+		return err;
 
 	cmd = protect_blocks;
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_DR0), cmd);
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_DR0), cmd);
+	if (err != ERROR_OK)
+		return err;
 
 	cmd = FLASH_SPR | FLASH_WMS;
-	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-
-	while (((retval = str7x_status(bank)) & str7x_info->busy_bits)) {
-		alive_sleep(1);
-	}
+	err = target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
+	if (err != ERROR_OK)
+		return err;
 
-	retval = str7x_result(bank);
+	err = str7x_waitbusy(bank);
+	if (err != ERROR_OK)
+		return err;
 
-	LOG_DEBUG("retval: 0x%8.8" PRIx32 "", retval);
-
-	if (retval & FLASH_ERER)
-		return ERROR_FLASH_SECTOR_NOT_ERASED;
-	else if (retval & FLASH_WPF)
-		return ERROR_FLASH_OPERATION_FAILED;
+	err = str7x_result(bank);
+	if (err != ERROR_OK)
+		return err;
 
 	return ERROR_OK;
 }
 
-static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
+int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
 		uint32_t offset, uint32_t count)
 {
 	struct str7x_flash_bank *str7x_info = bank->driver_priv;
@@ -409,14 +487,12 @@ static int str7x_write_block(struct flash_bank *bank, uint8_t *buffer,
 				str7x_info->write_algorithm->address + (sizeof(str7x_flash_write_code) - 4),
 				10000, &armv4_5_info)) != ERROR_OK)
 		{
-			LOG_ERROR("error executing str7x flash write algorithm");
-			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 
 		if (buf_get_u32(reg_params[4].value, 0, 32) != 0x00)
 		{
-			retval = ERROR_FLASH_OPERATION_FAILED;
+			retval = str7x_result(bank);
 			break;
 		}
 
@@ -442,7 +518,6 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 		uint32_t offset, uint32_t count)
 {
 	struct target *target = bank->target;
-	struct str7x_flash_bank *str7x_info = bank->driver_priv;
 	uint32_t dwords_remaining = (count / 8);
 	uint32_t bytes_remaining = (count & 0x00000007);
 	uint32_t address = bank->base + offset;
@@ -498,16 +573,7 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 				/* if block write failed (no sufficient working area),
 				 * we use normal (slow) single dword accesses */
 				LOG_WARNING("couldn't use block writes, falling back to single memory accesses");
-			}
-			else if (retval == ERROR_FLASH_OPERATION_FAILED)
-			{
-				/* if an error occured, we examine the reason, and quit */
-				retval = str7x_result(bank);
-
-				LOG_ERROR("flash writing failed with error code: 0x%x", retval);
-				return ERROR_FLASH_OPERATION_FAILED;
-			}
-			else
+			} else
 			{
 				return retval;
 			}
@@ -543,17 +609,14 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 		cmd = FLASH_DWPG | FLASH_WMS;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
 
-		while (((retval = str7x_status(bank)) & str7x_info->busy_bits))
-		{
-			alive_sleep(1);
-		}
-
-		retval = str7x_result(bank);
+		int err;
+		err = str7x_waitbusy(bank);
+		if (err != ERROR_OK)
+			return err;
 
-		if (retval & FLASH_PGER)
-			return ERROR_FLASH_OPERATION_FAILED;
-		else if (retval & FLASH_WPF)
-			return ERROR_FLASH_OPERATION_FAILED;
+		err = str7x_result(bank);
+		if (err != ERROR_OK)
+			return err;
 
 		dwords_remaining--;
 		address += 8;
@@ -592,17 +655,14 @@ static int str7x_write(struct flash_bank *bank, uint8_t *buffer,
 		cmd = FLASH_DWPG | FLASH_WMS;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
 
-		while (((retval = str7x_status(bank)) & str7x_info->busy_bits))
-		{
-			alive_sleep(1);
-		}
-
-		retval = str7x_result(bank);
+		int err;
+		err = str7x_waitbusy(bank);
+		if (err != ERROR_OK)
+			return err;
 
-		if (retval & FLASH_PGER)
-			return ERROR_FLASH_OPERATION_FAILED;
-		else if (retval & FLASH_WPF)
-			return ERROR_FLASH_OPERATION_FAILED;
+		err = str7x_result(bank);
+		if (err != ERROR_OK)
+			return err;
 	}
 
 	return ERROR_OK;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/core.c    |   32 +++-----
 src/flash/nor/str7x.c   |  206 ++++++++++++++++++++++++++++++-----------------
 src/helper/command.c    |    8 ++-
 src/helper/command.h    |    4 +
 src/jtag/tcl.c          |    4 +-
 src/server/server.c     |    2 +-
 src/server/tcl_server.c |    6 +-
 src/server/tcl_server.h |    2 +-
 src/target/armv4_5.c    |    8 +-
 src/target/target.c     |   29 ++++---
 10 files changed, 179 insertions(+), 122 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  6 07:40:41 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  6 May 2010 05:40:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-214-g812e21a
Message-ID: <E1O9tpF-00059O-6g@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  812e21ac396247767da0144748b5f52ad11b3e17 (commit)
      from  31b050108a1cd740b326dddfa7a2f1322ee8c186 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 812e21ac396247767da0144748b5f52ad11b3e17
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue May 4 12:28:05 2010 +0200

    zy1000: fix keep_alive() bug
    
    introduced in latest commit. Should have held off merging
    that commit. Sigh....
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 092e3cd..2fac176 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -205,6 +205,8 @@ void zy1000_reset(int trst, int srst)
 
 			total = timeval_ms() - start;
 
+			keep_alive();
+
 			if (total > 5000)
 			{
 				LOG_ERROR("SRST took too long to deassert: %dms", (int)total);

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  6 07:41:10 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  6 May 2010 05:41:10 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-215-g82ea640
Message-ID: <E1O9tpf-0005Bz-Q1@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  82ea640830fe13f9ab8ef33c65a76480b697f856 (commit)
      from  812e21ac396247767da0144748b5f52ad11b3e17 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 82ea640830fe13f9ab8ef33c65a76480b697f856
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue May 4 13:26:52 2010 +0200

    gdb: connect will now fail if flash autoprobe fails
    
    This stops GDB from launching with an empty memory map,
    making gdb load w/flashing fail for no obvious reason.
    
    The error message points in the direction of the gdb-attach
    event that can be set up to issue a halt or "reset init"
    which will put GDB in a well defined stated upon attach
    and thus have a robust flash autoprobe.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index e6c0eeb..232d503 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -220,22 +220,25 @@ struct flash_bank *get_flash_bank_by_name(const char *name)
 	return NULL;
 }
 
-struct flash_bank *get_flash_bank_by_num(int num)
+int get_flash_bank_by_num(int num, struct flash_bank **bank)
 {
 	struct flash_bank *p = get_flash_bank_by_num_noprobe(num);
 	int retval;
 
 	if (p == NULL)
-		return NULL;
+	{
+		return ERROR_FAIL;
+	}
 
 	retval = p->driver->auto_probe(p);
 
 	if (retval != ERROR_OK)
 	{
 		LOG_ERROR("auto_probe failed %d\n", retval);
-		return NULL;
+		return retval;
 	}
-	return p;
+	*bank = p;
+	return ERROR_OK;
 }
 
 /* lookup flash bank by address */
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index 68220af..797cf68 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -157,9 +157,10 @@ struct flash_bank *get_flash_bank_by_name(const char *name);
 /**
  * Returns a flash bank by the specified flash_bank_s bank_number, @a num.
  * @param num The flash bank number.
- * @returns A struct flash_bank for flash bank @a num, or NULL
+ * @param bank returned bank if fn returns ERROR_OK
+ * @returns ERROR_OK if successful
  */
-struct flash_bank *get_flash_bank_by_num(int num);
+int get_flash_bank_by_num(int num, struct flash_bank **bank);
 /**
  * Retreives @a bank from a command argument, reporting errors parsing
  * the bank identifier or retreiving the specified bank.  The bank
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index aed55c0..66b8ac3 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -42,13 +42,7 @@ COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
 	unsigned bank_num;
 	COMMAND_PARSE_NUMBER(uint, name, bank_num);
 
-	*bank = get_flash_bank_by_num(bank_num);
-	if (!*bank)
-	{
-		command_print(CMD_CTX, "flash bank '%s' not found", name);
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	return ERROR_OK;
+	return get_flash_bank_by_num(bank_num, bank);
 }
 
 
@@ -310,9 +304,12 @@ COMMAND_HANDLER(handle_flash_erase_command)
 	uint32_t last;
 
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
-	if (!p)
-		return ERROR_OK;
+
+	struct flash_bank *p;
+	int retval;
+	retval = get_flash_bank_by_num(bank_nr, &p);
+	if (retval != ERROR_OK)
+		return retval;
 
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
 	if (strcmp(CMD_ARGV[2], "last") == 0)
@@ -320,7 +317,6 @@ COMMAND_HANDLER(handle_flash_erase_command)
 	else
 		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
 
-	int retval;
 	if ((retval = flash_check_sector_parameters(CMD_CTX,
 			first, last, p->num_sectors)) != ERROR_OK)
 		return retval;
@@ -350,9 +346,10 @@ COMMAND_HANDLER(handle_flash_protect_command)
 	uint32_t last;
 
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
-	if (!p)
-		return ERROR_OK;
+	struct flash_bank *p;
+	int retval = get_flash_bank_by_num(bank_nr, &p);
+	if (retval != ERROR_OK)
+		return retval;
 
 	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
 	if (strcmp(CMD_ARGV[2], "last") == 0)
@@ -363,7 +360,6 @@ COMMAND_HANDLER(handle_flash_protect_command)
 	bool set;
 	COMMAND_PARSE_ON_OFF(CMD_ARGV[3], set);
 
-	int retval;
 	if ((retval = flash_check_sector_parameters(CMD_CTX,
 			first, last, p->num_sectors)) != ERROR_OK)
 		return retval;
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index f46980e..275d414 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -855,6 +855,26 @@ static int gdb_new_connection(struct connection *connection)
 		gdb_putback_char(connection, initial_ack);
 	target_call_event_callbacks(gdb_service->target, TARGET_EVENT_GDB_ATTACH);
 
+	if (gdb_use_memory_map)
+	{
+		/* Connect must fail if the memory map can't be set up correctly.
+		 *
+		 * This will cause an auto_probe to be invoked, which is either
+		 * a no-op or it will fail when the target isn't ready(e.g. not halted).
+		 */
+		int i;
+		for (i = 0; i < flash_get_bank_count(); i++)
+		{
+			struct flash_bank *p;
+			retval = get_flash_bank_by_num(i, &p);
+			if (retval != ERROR_OK)
+			{
+				LOG_ERROR("Connect failed. Consider setting up a gdb-attach event for the target to prepare target for GDB connect.");
+				return retval;
+			}
+		}
+	}
+
 	gdb_actual_connections++;
 	LOG_DEBUG("New GDB Connection: %d, Target %s, state: %s",
 		  gdb_actual_connections,
@@ -1692,10 +1712,10 @@ static int gdb_memory_map(struct connection *connection,
 	banks = malloc(sizeof(struct flash_bank *)*flash_get_bank_count());
 
 	for (i = 0; i < flash_get_bank_count(); i++) {
-		p = get_flash_bank_by_num(i);
-		if (p == NULL) {
+		retval = get_flash_bank_by_num(i, &p);
+		if (retval != ERROR_OK)
+		{
 			free(banks);
-			retval = ERROR_FAIL;
 			gdb_send_error(connection, retval);
 			return retval;
 		}

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/core.c    |   11 +++++++----
 src/flash/nor/core.h    |    5 +++--
 src/flash/nor/tcl.c     |   26 +++++++++++---------------
 src/server/gdb_server.c |   26 +++++++++++++++++++++++---
 4 files changed, 44 insertions(+), 24 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  6 07:41:35 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  6 May 2010 05:41:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-216-g2fba796
Message-ID: <E1O9tq5-0005EA-1D@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2fba796e27fe37076380f90aa4df986db2b06685 (commit)
      from  82ea640830fe13f9ab8ef33c65a76480b697f856 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2fba796e27fe37076380f90aa4df986db2b06685
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 5 08:19:40 2010 +0200

    zy1000: fix tcl command to read power dropout status
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 2fac176..b3f94e5 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -434,10 +434,9 @@ zylinjtag_Jim_Command_powerstatus(Jim_Interp *interp,
 		return JIM_ERR;
 	}
 
-	uint32_t status;
-	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, status);
+	bool dropout = readPowerDropout();
 
-	Jim_SetResult(interp, Jim_NewIntObj(interp, (status&0x80) != 0));
+	Jim_SetResult(interp, Jim_NewIntObj(interp, dropout));
 
 	return JIM_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |    5 ++---
 1 files changed, 2 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  6 07:41:59 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  6 May 2010 05:41:59 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-217-g3077f58
Message-ID: <E1O9tqS-0004dA-Ut@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3077f5845f197c5e21fc4ed917722297c74ef754 (commit)
      from  2fba796e27fe37076380f90aa4df986db2b06685 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3077f5845f197c5e21fc4ed917722297c74ef754
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 5 09:32:03 2010 +0200

    cfi: fix error handling for protect fn
    
    No error was propagated.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 9967652..92b553b 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -3,6 +3,7 @@
  *   Dominic.Rath at gmx.de                                                   *
  *   Copyright (C) 2009 Michael Schwingen                                  *
  *   michael at schwingen.org                                                 *
+ *   Copyright (C) 2010 ??yvind Harboe <oyvind.harboe at zylin.com>            *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -887,6 +888,7 @@ static int cfi_protect(struct flash_bank *bank, int set, int first, int last)
 
 	if ((first < 0) || (last < first) || (last >= bank->num_sectors))
 	{
+		LOG_ERROR("Invalid sector range");
 		return ERROR_FLASH_SECTOR_INVALID;
 	}
 
@@ -897,14 +899,12 @@ static int cfi_protect(struct flash_bank *bank, int set, int first, int last)
 	{
 		case 1:
 		case 3:
-			cfi_intel_protect(bank, set, first, last);
+			return cfi_intel_protect(bank, set, first, last);
 			break;
 		default:
 			LOG_ERROR("protect: cfi primary command set %i unsupported", cfi_info->pri_id);
-			break;
+			return ERROR_FAIL;
 	}
-
-	return ERROR_OK;
 }
 
 /* FIXME Replace this by a simple memcpy() - still unsure about sideeffects */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  6 07:42:35 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  6 May 2010 05:42:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-218-gf7e0f3c
Message-ID: <E1O9tr2-0004gr-UY@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f7e0f3c285e9b1578184da886792e02d253ea687 (commit)
      from  3077f5845f197c5e21fc4ed917722297c74ef754 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f7e0f3c285e9b1578184da886792e02d253ea687
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 5 09:32:43 2010 +0200

    flash: erase_address now has an unlock option
    
    Quite useful to be able to unlock the flash, just like in
    the flash write_image cmd.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 49df159..d311c8e 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -21,7 +21,7 @@ of the Open On-Chip Debugger (OpenOCD).
 @itemize @bullet
 @item Copyright @copyright{} 2008 The OpenOCD Project
 @item Copyright @copyright{} 2007-2008 Spencer Oliver @email{spen@@spen-soft.co.uk}
- at item Copyright @copyright{} 2008 Oyvind Harboe @email{oyvind.harboe@@zylin.com}
+ at item Copyright @copyright{} 2008-2010 Oyvind Harboe @email{oyvind.harboe@@zylin.com}
 @item Copyright @copyright{} 2008 Duane Ellis @email{openocd@@duaneellis.com}
 @item Copyright @copyright{} 2009-2010 David Brownell
 @end itemize
@@ -4043,7 +4043,7 @@ specifies "to the end of the flash bank".
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
- at deffn Command {flash erase_address} [@option{pad}] address length
+ at deffn Command {flash erase_address} [@option{pad}] [@option{unlock}] address length
 Erase sectors starting at @var{address} for @var{length} bytes.
 Unless @option{pad} is specified, @math{address} must begin a
 flash sector, and @math{address + length - 1} must end a sector.
@@ -4053,6 +4053,8 @@ The flash bank to use is inferred from the @var{address}, and
 the specified length must stay within that bank.
 As a special case, when @var{length} is zero and @var{address} is
 the start of the bank, the whole flash is erased.
+If @option{unlock} is specified, then the flash is unprotected
+before erase starts. 
 @end deffn
 
 @deffn Command {flash fillw} address word length
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 232d503..e07ca1f 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -502,7 +502,7 @@ static int flash_driver_unprotect(struct flash_bank *bank, int first, int last)
 	return flash_driver_protect(bank, 0, first, last);
 }
 
-static int flash_unlock_address_range(struct target *target, uint32_t addr, uint32_t length)
+int flash_unlock_address_range(struct target *target, uint32_t addr, uint32_t length)
 {
 	/* By default, pad to sector boundaries ... the real issue here
 	 * is that our (only) caller *permanently* removes protection,
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index 797cf68..b152677 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -108,6 +108,9 @@ int flash_register_commands(struct command_context *cmd_ctx);
 int flash_erase_address_range(struct target *target,
 		bool pad, uint32_t addr, uint32_t length);
 
+int flash_unlock_address_range(struct target *target, uint32_t addr,
+		uint32_t length);
+
 /**
  * Writes @a image into the @a target flash.  The @a written parameter
  * will contain the
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 66b8ac3..947fd04 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -194,32 +194,40 @@ COMMAND_HANDLER(handle_flash_erase_check_command)
 COMMAND_HANDLER(handle_flash_erase_address_command)
 {
 	struct flash_bank *p;
-	int retval;
+	int retval = ERROR_OK;
 	int address;
 	int length;
 	bool do_pad = false;
+	bool do_unlock = false;
 	struct target *target = get_current_target(CMD_CTX);
 
-	switch (CMD_ARGC) {
-	case 3:
+	while (CMD_ARGC >= 3)
+	{
 		/* Optionally pad out the address range to block/sector
 		 * boundaries.  We can't know if there's data in that part
 		 * of the flash; only do padding if we're told to.
 		 */
-		if (strcmp("pad", CMD_ARGV[0]) != 0)
+		if (strcmp("pad", CMD_ARGV[0]) == 0)
+		{
+			do_pad = true;
+		} else if (strcmp("unlock", CMD_ARGV[0]) == 0)
+		{
+			do_unlock = true;
+		} else
+		{
 			return ERROR_COMMAND_SYNTAX_ERROR;
-		do_pad = true;
+		}
 		CMD_ARGC--;
 		CMD_ARGV++;
-		/* FALL THROUGH */
-	case 2:
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], address);
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], length);
-		break;
-	default:
+	}
+	if (CMD_ARGC != 2)
+	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], length);
+
 	if (length <= 0)
 	{
 		command_print(CMD_CTX, "Length must be >0");
@@ -238,7 +246,15 @@ COMMAND_HANDLER(handle_flash_erase_address_command)
 	struct duration bench;
 	duration_start(&bench);
 
-	retval = flash_erase_address_range(target, do_pad, address, length);
+	if (do_unlock)
+	{
+		retval = flash_unlock_address_range(target, address, length);
+	}
+
+	if (retval == ERROR_OK)
+	{
+		retval = flash_erase_address_range(target, do_pad, address, length);
+	}
 
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
@@ -709,12 +725,15 @@ static const struct command_registration flash_exec_command_handlers[] = {
 		.name = "erase_address",
 		.handler = handle_flash_erase_address_command,
 		.mode = COMMAND_EXEC,
-		.usage = "['pad'] address length",
+		.usage = "['pad'] ['unlock'] address length",
 		.help = "Erase flash sectors starting at address and "
 			"continuing for length bytes.  If 'pad' is specified, "
 			"data outside that range may also be erased: the start "
 			"address may be decreased, and length increased, so "
-			"that all of the first and last sectors are erased.",
+			"that all of the first and last sectors are erased. "
+			"If 'unlock' is specified, then the flash is unprotected "
+			"before erasing.",
+
 	},
 	{
 		.name = "fillw",

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi     |    6 ++++--
 src/flash/nor/core.c |    2 +-
 src/flash/nor/core.h |    3 +++
 src/flash/nor/tcl.c  |   47 +++++++++++++++++++++++++++++++++--------------
 4 files changed, 41 insertions(+), 17 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May  6 07:43:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  6 May 2010 05:43:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-219-g737c9b6
Message-ID: <E1O9ts0-0005Nd-1f@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  737c9b6258c6e68714ae264ff36126eb5d382d6a (commit)
      from  f7e0f3c285e9b1578184da886792e02d253ea687 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 737c9b6258c6e68714ae264ff36126eb5d382d6a
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 5 15:08:34 2010 +0200

    flash: stop caching protection state
    
    There are a million reasons why cached protection state might
    be stale: power cycling of target, reset, code executing on
    the target, etc.
    
    The "flash protect_check" command is now gone. This is *always*
    executed when running a "flash info".
    
    As a bonus for more a more robust approach, lots of code could
    be deleted.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index d311c8e..a4c4de2 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4129,9 +4129,8 @@ The @var{num} parameter is a value shown by @command{flash banks}.
 @deffn Command {flash info} num
 Print info about flash bank @var{num}
 The @var{num} parameter is a value shown by @command{flash banks}.
-The information includes per-sector protect status, which may be
-incorrect (outdated) unless you first issue a
- at command{flash protect_check num} command.
+This command will first query the hardware, it does not print cached
+and possibly stale information.
 @end deffn
 
 @anchor{flash protect}
@@ -4144,14 +4143,6 @@ specifies "to the end of the flash bank".
 The @var{num} parameter is a value shown by @command{flash banks}.
 @end deffn
 
- at deffn Command {flash protect_check} num
-Check protection state of sectors in flash bank @var{num}.
-The @var{num} parameter is a value shown by @command{flash banks}.
- at comment @option{flash erase_sector} using the same syntax.
-This updates the protection information displayed by @option{flash info}.
-(Code execution may have invalidated any state records kept by OpenOCD.)
- at end deffn
-
 @anchor{Flash Driver List}
 @section Flash Driver List
 As noted above, the @command{flash bank} command requires a driver name,
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 92b553b..4ef41b9 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -852,6 +852,17 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 	 */
 	if ((!set) && (!(pri_ext->feature_support & 0x20)))
 	{
+		/* FIX!!! this code path is broken!!!
+		 *
+		 * The correct approach is:
+		 *
+		 * 1. read out current protection status
+		 *
+		 * 2. override read out protection status w/unprotected.
+		 *
+		 * 3. re-protect what should be protected.
+		 *
+		 */
 		for (i = 0; i < bank->num_sectors; i++)
 		{
 			if (bank->sectors[i].is_protected == 1)
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index e07ca1f..936f07c 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -54,74 +54,27 @@ int flash_driver_erase(struct flash_bank *bank, int first, int last)
 int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
 {
 	int retval;
-	bool updated = false;
-
-	/* NOTE: "first == last" means (un?)protect just that sector.
-	 code including Lower level ddrivers may rely on this "first <= last"
-	 * invariant.
-	*/
 
 	/* callers may not supply illegal parameters ... */
 	if (first < 0 || first > last || last >= bank->num_sectors)
+	{
+		LOG_ERROR("illegal sector range");
 		return ERROR_FAIL;
+	}
 
 	/* force "set" to 0/1 */
 	set = !!set;
 
-	/*
-	 * Filter out what trivial nonsense we can, so drivers don't have to.
+	/* DANGER!
 	 *
-	 * Don't tell drivers to change to the current state...  it's needless,
-	 * and reducing the amount of work to be done (potentially to nothing)
-	 * speeds at least some things up.
-	 */
-scan:
-	for (int i = first; i <= last; i++) {
-		struct flash_sector *sector = bank->sectors + i;
-
-		/* Only filter requests to protect the already-protected, or
-		 * to unprotect the already-unprotected.  Changing from the
-		 * unknown state (-1) to a known one is unwise but allowed;
-		 * protection status is best checked first.
-		 */
-		if (sector->is_protected != set)
-			continue;
-
-		/* Shrink this range of sectors from the start; don't overrun
-		 * the end.  Also shrink from the end; don't overun the start.
-		 *
-		 * REVISIT we could handle discontiguous regions by issuing
-		 * more than one driver request.  How much would that matter?
-		 */
-		if (i == first && i != last) {
-			updated = true;
-			first++;
-		} else if (i == last && i != first) {
-			updated = true;
-			last--;
-		}
-	}
-
-	/* updating the range affects the tests in the scan loop above; so
-	 * re-scan, to make sure we didn't miss anything.
-	 */
-	if (updated) {
-		updated = false;
-		goto scan;
-	}
-
-	/* Single sector, already protected?  Nothing to do!
-	 * We may have trimmed our parameters into this degenerate case.
+	 * We must not use any cached information about protection state!!!!
 	 *
-	 * FIXME repeating the "is_protected==set" test is a giveaway that
-	 * this fast-exit belongs earlier, in the trim-it-down loop; mve.
-	 * */
-	if (first == last && bank->sectors[first].is_protected == set)
-		return ERROR_OK;
-
-
-	/* Note that we don't pass illegal parameters to drivers; any
-	 * trimming just turns one valid range into another one.
+	 * There are a million things that could change the protect state:
+	 *
+	 * the target could have reset, power cycled, been hot plugged,
+	 * the application could have run, etc.
+	 *
+	 * Drivers only receive valid sector range.
 	 */
 	retval = bank->driver->protect(bank, set, first, last);
 	if (retval != ERROR_OK)
@@ -754,34 +707,3 @@ int flash_write(struct target *target, struct image *image,
 {
 	return flash_write_unlock(target, image, written, erase, false);
 }
-
-/**
- * Invalidates cached flash state which a target can change as it runs.
- *
- * @param target The target being resumed
- *
- * OpenOCD caches some flash state for brief periods.  For example, a sector
- * that is protected must be unprotected before OpenOCD tries to write it,
- * Also, a sector that's not erased must be erased before it's written.
- *
- * As a rule, OpenOCD and target firmware can both modify the flash, so when
- * a target starts running, OpenOCD needs to invalidate its cached state.
- */
-void nor_resume(struct target *target)
-{
-	struct flash_bank *bank;
-
-	for (bank = flash_banks; bank; bank = bank->next) {
-		int i;
-
-		if (bank->target != target)
-			continue;
-
-		for (i = 0; i < bank->num_sectors; i++) {
-			struct flash_sector *sector = bank->sectors + i;
-
-			sector->is_erased = -1;
-			sector->is_protected = -1;
-		}
-	}
-}
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index b152677..1dfd721 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -53,6 +53,10 @@ struct flash_sector
 	 * Indication of protection status: 0 = unprotected/unlocked,
 	 * 1 = protected/locked, other = unknown.  Set by
 	 * @c flash_driver_s::protect_check.
+	 *
+	 * This information must be considered stale immediately.
+	 * A million things could make it stale: power cycle,
+	 * reset of target, code running on target, etc.
 	 */
 	int is_protected;
 };
@@ -124,9 +128,6 @@ int flash_unlock_address_range(struct target *target, uint32_t addr,
 int flash_write(struct target *target,
 		struct image *image, uint32_t *written, int erase);
 
-/* invalidate cached state (targets may modify their own flash) */
-void nor_resume(struct target *target);
-
 /**
  * Forces targets to re-examine their erase/protection state.
  * This routine must be called when the system may modify the status.
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 947fd04..17c6e91 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -70,6 +70,11 @@ COMMAND_HANDLER(handle_flash_info_command)
 		if ((retval = p->driver->auto_probe(p)) != ERROR_OK)
 			return retval;
 
+		/* We must query the hardware to avoid printing stale information! */
+		retval = p->driver->protect_check(p);
+		if (retval != ERROR_OK)
+			return retval;
+
 		command_print(CMD_CTX,
 			      "#%" PRIi32 " : %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", buswidth %i, chipwidth %i",
 			      i,
@@ -266,32 +271,6 @@ COMMAND_HANDLER(handle_flash_erase_address_command)
 	return retval;
 }
 
-COMMAND_HANDLER(handle_flash_protect_check_command)
-{
-	if (CMD_ARGC != 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	struct flash_bank *p;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if ((retval = p->driver->protect_check(p)) == ERROR_OK)
-	{
-		command_print(CMD_CTX, "successfully checked protect state");
-	}
-	else if (retval == ERROR_FLASH_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, "checking protection state failed (possibly unsupported) by flash #%s at 0x%8.8" PRIx32, CMD_ARGV[0], p->base);
-	}
-	else
-	{
-		command_print(CMD_CTX, "unknown error when checking protection state of flash bank '#%s' at 0x%8.8" PRIx32, CMD_ARGV[0], p->base);
-	}
-
-	return ERROR_OK;
-}
-
 static int flash_check_sector_parameters(struct command_context *cmd_ctx,
 		uint32_t first, uint32_t last, uint32_t num_sectors)
 {
@@ -707,14 +686,6 @@ static const struct command_registration flash_exec_command_handlers[] = {
 			"flash bank.",
 	},
 	{
-		.name = "protect_check",
-		.handler = handle_flash_protect_check_command,
-		.mode = COMMAND_EXEC,
-		.usage = "bank_id",
-		.help = "Check protection state of all blocks in a "
-			"flash bank.",
-	},
-	{
 		.name = "erase_sector",
 		.handler = handle_flash_erase_command,
 		.mode = COMMAND_EXEC,
diff --git a/src/target/target.c b/src/target/target.c
index d17bb74..37e515a 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -474,19 +474,6 @@ int target_resume(struct target *target, int current, uint32_t address, int hand
 	if ((retval = target->type->resume(target, current, address, handle_breakpoints, debug_execution)) != ERROR_OK)
 		return retval;
 
-	/* Invalidate any cached protect/erase/... flash status, since
-	 * almost all targets will now be able modify the flash by
-	 * themselves.  We want flash drivers and infrastructure to
-	 * be able to rely on (non-invalidated) cached state.
-	 *
-	 * For now we require that algorithms provided by OpenOCD are
-	 * used only by code which properly maintains that  cached state.
-	 * state
-	 *
-	 * REVISIT do the same for NAND ; maybe other flash flavors too...
-	 */
-		if (!target->running_alg)
-		nor_resume(target);
 	return retval;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi     |   13 +-----
 src/flash/nor/cfi.c  |   11 +++++
 src/flash/nor/core.c |  100 +++++--------------------------------------------
 src/flash/nor/core.h |    7 ++-
 src/flash/nor/tcl.c  |   39 ++-----------------
 src/target/target.c  |   13 ------
 6 files changed, 33 insertions(+), 150 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu May  6 23:52:51 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu,  6 May 2010 21:52:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-220-gf32492c
Message-ID: <E1OA900-00059c-U2@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f32492c74f29f7efd0d73f8118d0b988bc24f56a (commit)
      from  737c9b6258c6e68714ae264ff36126eb5d382d6a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f32492c74f29f7efd0d73f8118d0b988bc24f56a
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu May 6 22:51:20 2010 +0100

    server: incorrectly display socket port number
    
    c->sin.sin_port does not contain a valid port number so just use
    service->port as this is always correct.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/server/server.c b/src/server/server.c
index 7e57228..57c4016 100644
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -78,7 +78,7 @@ static int add_connection(struct service *service, struct command_context *cmd_c
 				(char *)&flag,		/* the cast is historical cruft */
 				sizeof(int));		/* length of option value */
 
-		LOG_INFO("accepting '%s' connection from %i", service->name, c->sin.sin_port);
+		LOG_INFO("accepting '%s' connection from %i", service->name, service->port);
 		if ((retval = service->new_connection(c)) != ERROR_OK)
 		{
 			close_socket(c->fd);

-----------------------------------------------------------------------

Summary of changes:
 src/server/server.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri May  7 18:02:48 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri,  7 May 2010 16:02:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-221-gcf811d8
Message-ID: <E1OAQ0n-000721-GN@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  cf811d8e6b7228348658f9211e0628fb725c5466 (commit)
      from  f32492c74f29f7efd0d73f8118d0b988bc24f56a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit cf811d8e6b7228348658f9211e0628fb725c5466
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri May 7 14:24:13 2010 +0100

    cfg: add stm32eval board configs
    
    Increase working area for stm3210e_eval.cfg.
    Add new configs for the following boards:
    STM321000B-EVAL, STM32100C-EVAL, STM32100B-EVAL
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/stm32100b_eval.cfg b/tcl/board/stm32100b_eval.cfg
new file mode 100644
index 0000000..ba9058c
--- /dev/null
+++ b/tcl/board/stm32100b_eval.cfg
@@ -0,0 +1,7 @@
+# This is an STM32 eval board with a single STM32F100VB chip on it.
+# http://www.st.com/mcu/contentid-100-110-STM32100B_EVAL.html
+
+# we only have 8k sram
+set WORKAREASIZE 8192
+
+source [find target/stm32.cfg]
diff --git a/tcl/board/stm3210b_eval.cfg b/tcl/board/stm3210b_eval.cfg
new file mode 100644
index 0000000..5e0a5ea
--- /dev/null
+++ b/tcl/board/stm3210b_eval.cfg
@@ -0,0 +1,8 @@
+# This is an STM32 eval board with a single STM32F100VBT6 chip on it.
+# http://www.st.com/mcu/contentid-100-110-STM3210B_EVAL.html
+
+# increase working area for faster flash programming
+
+set WORKAREASIZE 32768
+
+source [find target/stm32.cfg]
diff --git a/tcl/board/stm3210c_eval.cfg b/tcl/board/stm3210c_eval.cfg
new file mode 100644
index 0000000..fad8737
--- /dev/null
+++ b/tcl/board/stm3210c_eval.cfg
@@ -0,0 +1,8 @@
+# This is an STM32 eval board with a single STM32F107VCT chip on it.
+# http://www.st.com/mcu/contentid-100-110-STM3210C_EVAL.html
+
+# increase working area for faster flash programming
+
+set WORKAREASIZE 32768
+
+source [find target/stm32.cfg]
diff --git a/tcl/board/stm3210e_eval.cfg b/tcl/board/stm3210e_eval.cfg
index ab2f64f..83ce488 100644
--- a/tcl/board/stm3210e_eval.cfg
+++ b/tcl/board/stm3210e_eval.cfg
@@ -1,3 +1,8 @@
-# This is an STM32 eval board with a single STM32F103ZET6 chip on it.
+# This is an STM32 eval board with a single STM32F103ZE chip on it.
+# http://www.st.com/mcu/contentid-100-110-STM3210E_EVAL.html
+
+# increase working area for faster flash programming
+
+set WORKAREASIZE 32768
 
 source [find target/stm32.cfg]

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/stm32100b_eval.cfg |    7 +++++++
 tcl/board/stm3210b_eval.cfg  |    8 ++++++++
 tcl/board/stm3210c_eval.cfg  |    8 ++++++++
 tcl/board/stm3210e_eval.cfg  |    7 ++++++-
 4 files changed, 29 insertions(+), 1 deletions(-)
 create mode 100644 tcl/board/stm32100b_eval.cfg
 create mode 100644 tcl/board/stm3210b_eval.cfg
 create mode 100644 tcl/board/stm3210c_eval.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue May 11 13:49:13 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue, 11 May 2010 11:49:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-224-g3650981
Message-ID: <E1OBnxd-0004Ar-Iu@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3650981de7e5854b5023fddeb1a4656794a0aae0 (commit)
       via  2ae192699f5aaa911a874b85669fc803e4a29804 (commit)
       via  bbc8f4e6cec361a34028dad4b5000c136f4f48b2 (commit)
      from  cf811d8e6b7228348658f9211e0628fb725c5466 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3650981de7e5854b5023fddeb1a4656794a0aae0
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 10 14:15:12 2010 +0100

    mips32: 20 second timeout/megabyte for CRC check
    
    There was a fixed 20 second timeout which is too little
    for large, slow timeout checks.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/mips32.c b/src/target/mips32.c
index de8253f..0923a79 100644
--- a/src/target/mips32.c
+++ b/src/target/mips32.c
@@ -662,8 +662,10 @@ int mips32_checksum_memory(struct target *target, uint32_t address,
 	init_reg_param(&reg_params[1], "a1", 32, PARAM_OUT);
 	buf_set_u32(reg_params[1].value, 0, 32, count);
 
+	int timeout = 20000 * (1 + (count / (1024 * 1024)));
+
 	if ((retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
-			crc_algorithm->address, crc_algorithm->address + (sizeof(mips_crc_code)-4), 10000,
+			crc_algorithm->address, crc_algorithm->address + (sizeof(mips_crc_code)-4), timeout,
 			&mips32_info)) != ERROR_OK)
 	{
 		destroy_reg_param(&reg_params[0]);

commit 2ae192699f5aaa911a874b85669fc803e4a29804
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 10 14:14:57 2010 +0100

    armv7m: 20 second timeout/megabyte for CRC check
    
    There was a fixed 20 second timeout which is too little
    for large, slow timeout checks.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 83335a5..bd5aa14 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -615,8 +615,10 @@ int armv7m_checksum_memory(struct target *target,
 	buf_set_u32(reg_params[0].value, 0, 32, address);
 	buf_set_u32(reg_params[1].value, 0, 32, count);
 
+	int timeout = 20000 * (1 + (count / (1024 * 1024)));
+
 	if ((retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
-		crc_algorithm->address, crc_algorithm->address + (sizeof(cortex_m3_crc_code)-6), 20000, &armv7m_info)) != ERROR_OK)
+		crc_algorithm->address, crc_algorithm->address + (sizeof(cortex_m3_crc_code)-6), timeout, &armv7m_info)) != ERROR_OK)
 	{
 		LOG_ERROR("error executing cortex_m3 crc algorithm");
 		destroy_reg_param(&reg_params[0]);

commit bbc8f4e6cec361a34028dad4b5000c136f4f48b2
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 10 12:23:41 2010 +0100

    cfi: add Numonyx M29W128G reset workaround
    
    The ST/Numonix M29W128G has an issue when a 0xff cmd is sent,
    it cause an internal undefined state. The workaround according
    to the Numonyx is to send another 0xf0 reset cmd
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 4ef41b9..aa4540a 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -104,7 +104,6 @@ static __inline__ uint32_t flash_address(struct flash_bank *bank, int sector, ui
 		}
 		return bank->base + bank->sectors[sector].offset + offset * bank->bus_width;
 	}
-
 }
 
 static void cfi_command(struct flash_bank *bank, uint8_t cmd, uint8_t *cmd_buf)
@@ -232,6 +231,35 @@ static uint32_t cfi_query_u32(struct flash_bank *bank, int sector, uint32_t offs
 				data[(3 * bank->bus_width) - 1] << 16 | data[(4 * bank->bus_width) - 1] << 24;
 }
 
+static int cfi_reset(struct flash_bank *bank)
+{
+	struct cfi_flash_bank *cfi_info = bank->driver_priv;
+	int retval = ERROR_OK;
+
+	if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
+	{
+		return retval;
+	}
+
+	if (cfi_info->manufacturer == 0x20 &&
+			(cfi_info->device_id == 0x227E || cfi_info->device_id == 0x7E))
+	{
+		/* Numonix M29W128G is cmd 0xFF intolerant - causes internal undefined state
+		 * so we send an extra 0xF0 reset to fix the bug */
+		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x00))) != ERROR_OK)
+		{
+			return retval;
+		}
+	}
+
+	return retval;
+}
+
 static void cfi_intel_clear_status_register(struct flash_bank *bank)
 {
 	struct target *target = bank->target;
@@ -335,11 +363,7 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 
 	if ((pri_ext->pri[0] != 'P') || (pri_ext->pri[1] != 'R') || (pri_ext->pri[2] != 'I'))
 	{
-		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
-		{
-			return retval;
-		}
-		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
+		if ((retval = cfi_reset(bank)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -1977,11 +2001,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 	}
 
 	/* return to read array mode, so we can read from flash again for padding */
-	if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
-	{
-		return retval;
-	}
-	if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
+	if ((retval = cfi_reset(bank)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2015,11 +2035,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 	}
 
 	/* return to read array mode */
-	if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
-	{
-		return retval;
-	}
-	return cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0));
+	return cfi_reset(bank);
 }
 
 static void cfi_fixup_atmel_reversed_erase_regions(struct flash_bank *bank, void *param)
@@ -2083,11 +2099,7 @@ static int cfi_query_string(struct flash_bank *bank, int address)
 
 	if ((cfi_info->qry[0] != 'Q') || (cfi_info->qry[1] != 'R') || (cfi_info->qry[2] != 'Y'))
 	{
-		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
-		{
-			return retval;
-		}
-		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
+		if ((retval = cfi_reset(bank)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -2168,11 +2180,7 @@ static int cfi_probe(struct flash_bank *bank)
 
 	LOG_INFO("Flash Manufacturer/Device: 0x%04x 0x%04x", cfi_info->manufacturer, cfi_info->device_id);
 	/* switch back to read array mode */
-	if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x00))) != ERROR_OK)
-	{
-		return retval;
-	}
-	if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x00))) != ERROR_OK)
+	if ((retval = cfi_reset(bank)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -2289,11 +2297,7 @@ static int cfi_probe(struct flash_bank *bank)
 		/* return to read array mode
 		 * we use both reset commands, as some Intel flashes fail to recognize the 0xF0 command
 		 */
-		if ((retval = cfi_send_command(bank, 0xf0, flash_address(bank, 0, 0x0))) != ERROR_OK)
-		{
-			return retval;
-		}
-		if ((retval = cfi_send_command(bank, 0xff, flash_address(bank, 0, 0x0))) != ERROR_OK)
+		if ((retval = cfi_reset(bank)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -2377,7 +2381,6 @@ static int cfi_auto_probe(struct flash_bank *bank)
 	return cfi_probe(bank);
 }
 
-
 static int cfi_intel_protect_check(struct flash_bank *bank)
 {
 	int retval;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |   67 ++++++++++++++++++++++++++------------------------
 src/target/armv7m.c |    4 ++-
 src/target/mips32.c |    4 ++-
 3 files changed, 41 insertions(+), 34 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May 11 20:01:48 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 11 May 2010 18:01:48 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-226-g4e02288
Message-ID: <E1OBtm9-0002Sp-V1@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4e022886d63bc05502ae51264ce9ba85e8c188c1 (commit)
       via  4cf13101e5a75ffa0a84070133c2a5f764315d53 (commit)
      from  3650981de7e5854b5023fddeb1a4656794a0aae0 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4e022886d63bc05502ae51264ce9ba85e8c188c1
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Tue May 11 07:59:22 2010 +0200

    Documentation: consistency in GDB command name
    
    Always use the complete name of the GDB command, not an abbreviation.

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 5e703f1..c95803a 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -537,7 +537,7 @@ command interpreter today is a mixture of (newer)
 JIM-Tcl commands, and (older) the orginal command interpreter.
 
 @item @b{Commands}
-@* At the OpenOCD telnet command line (or via the GDB mon command) one
+@* At the OpenOCD telnet command line (or via the GDB monitor command) one
 can type a Tcl for() loop, set variables, etc.
 Some of the commands documented in this guide are implemented
 as Tcl scripts, from a @file{startup.tcl} file internal to the server.

commit 4cf13101e5a75ffa0a84070133c2a5f764315d53
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Tue May 11 07:58:57 2010 +0200

    Documentation : arm920t implements armv4
    
    There is a small typo in the cpu list, arm920t is armv4.

diff --git a/doc/openocd.texi b/doc/openocd.texi
index a4c4de2..5e703f1 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -3432,7 +3432,7 @@ At this writing, the supported CPU types and variants are:
 @item @code{arm11} -- this is a generation of ARMv6 cores
 @item @code{arm720t} -- this is an ARMv4 core with an MMU
 @item @code{arm7tdmi} -- this is an ARMv4 core
- at item @code{arm920t} -- this is an ARMv5 core with an MMU
+ at item @code{arm920t} -- this is an ARMv4 core with an MMU
 @item @code{arm926ejs} -- this is an ARMv5 core with an MMU
 @item @code{arm966e} -- this is an ARMv5 core
 @item @code{arm9tdmi} -- this is an ARMv4 core

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May 11 20:17:36 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 11 May 2010 18:17:36 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-227-g6f03e92
Message-ID: <E1OBu1R-0003I2-JZ@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  6f03e92959008708ac6808df679f5729f6683166 (commit)
      from  4e022886d63bc05502ae51264ce9ba85e8c188c1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 6f03e92959008708ac6808df679f5729f6683166
Author: Karl Kurbjun <kkurbjun at gmail.com>
Date:   Mon May 10 22:18:24 2010 -0600

    Fujitsu MBM29SL800TE flash support
    
    Hi,
    
    This is my first post to the list.  First, I would like to thank
    everyone for their work on OpenOCD, it is a great tool to work with.  I
    have been using it to debug code on hardware for the Rockbox project
    (www.rockbox.org).
    
    The target that I primarily work with has a Spansion/Fujitsu NOR flash
    (MBM29SL800TE).  I attached a patch that adds support for this flash.  I
    hope it can be included in the main repository.  If there is something
    that needs to be changed with the patch before inclusion please let me
    know.
    
    -Karl Kurbjun

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index aa4540a..2235c85 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -57,6 +57,7 @@ static const struct cfi_fixup cfi_0002_fixups[] = {
 	{CFI_MFR_SST, 0x00D7, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_SST, 0x2780, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_ATMEL, 0x00C8, cfi_fixup_atmel_reversed_erase_regions, NULL},
+   {CFI_MFR_FUJITSU, 0x22ea, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_FUJITSU, 0x226b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_5555_2AAA]},
 	{CFI_MFR_AMIC, 0xb31a, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
 	{CFI_MFR_MX, 0x225b, cfi_fixup_0002_unlock_addresses, &cfi_unlock_addresses[CFI_UNLOCK_555_2AA]},
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index b49e441..e0ea568 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -280,6 +280,23 @@ static struct non_cfi non_cfi_flashes[] = {
 			ERASE_REGION(15, 64*KB)
 		}
 	},
+   {
+		.mfr = CFI_MFR_FUJITSU,
+		.id = 0x22ea,				/* MBM29SL800TE */
+		.pri_id = 0x02,
+		.dev_size = 1*MB,
+		.interface_desc = 0x2,		/* x8 or x16 device with nBYTE */
+		.max_buf_write_size = 0x0,
+		.status_poll_mask = CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7,
+		.num_erase_regions = 4,
+		.erase_region_info =
+		{
+			ERASE_REGION(15, 64*KB),
+			ERASE_REGION(1,  32*KB),
+			ERASE_REGION(2,  8*KB),
+			ERASE_REGION(1,  16*KB)
+		}
+	},
 	{
 		.mfr = CFI_MFR_FUJITSU,
 		.id = 0xba,				/* 29LV400BC */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c     |    1 +
 src/flash/nor/non_cfi.c |   17 +++++++++++++++++
 2 files changed, 18 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May 12 13:49:41 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 12 May 2010 11:49:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-229-g7b76da5
Message-ID: <E1OCARb-0002fC-9e@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  7b76da57f471e77a24519c10927aab79890783a9 (commit)
       via  b05f8171c965bc3875df82f4469f952a13e2c504 (commit)
      from  6f03e92959008708ac6808df679f5729f6683166 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 7b76da57f471e77a24519c10927aab79890783a9
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed May 12 13:45:04 2010 +0200

    zy1000.cfg: gdb connect will fail first time without gdb-attach
    
    gdb-attach does a reset init to make sure that the CFI probe
    will succeed upon first gdb connect.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/zy1000.cfg b/tcl/board/zy1000.cfg
index ee7afcd..d2561e9 100644
--- a/tcl/board/zy1000.cfg
+++ b/tcl/board/zy1000.cfg
@@ -63,6 +63,11 @@ $_TARGETNAME configure -event reset-init {
 	mww 0x08020004 0
 }
 
+$_TARGETNAME configure -event gdb-attach {
+	# Without this gdb-attach will first time as probe will fail
+	reset init
+}
+
 # required for usable performance. Used for lots of
 # other things than flash programming.
 $_TARGETNAME configure -work-area-phys 0x00020000 -work-area-size 0x20000 -work-area-backup 0

commit b05f8171c965bc3875df82f4469f952a13e2c504
Author: Jun Ma <jma at hfut.edu.cn>
Date:   Mon May 10 22:54:25 2010 +0800

    fix instruction refilling bug when using software breakpoints on a big-endian arm926ej-s system
    
    Signed-off-by: Jun Ma <sync.jma at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 9f1bb2e..ac18b37 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -377,6 +377,7 @@ static int arm7_9_unset_breakpoint(struct target *target, struct breakpoint *bre
 			{
 				return retval;
 			}
+                        current_instr = target_buffer_get_u32(target, (uint8_t *)&current_instr);
 			if (current_instr == arm7_9->arm_bkpt)
 				if ((retval = target_write_memory(target, breakpoint->address, 4, 1, breakpoint->orig_instr)) != ERROR_OK)
 				{

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c |    1 +
 tcl/board/zy1000.cfg       |    5 +++++
 2 files changed, 6 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu May 13 21:48:18 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 13 May 2010 19:48:18 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-232-g215a5f7
Message-ID: <E1OCeOJ-0004PL-Tk@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  215a5f7442773693045613cff9e3ce3c7f7e9678 (commit)
       via  a7fb60dc7b23a78be0ad5876b0e76a0e76875d5c (commit)
       via  7b36d2a229ecde1a497773233ee1850bb10d80a7 (commit)
      from  7b76da57f471e77a24519c10927aab79890783a9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 215a5f7442773693045613cff9e3ce3c7f7e9678
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed May 12 23:04:57 2010 +0100

    scripts: update flash bank names
    
    As the flash bank name is now unique update the scripts to suit.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/hitex_str9-comstick.cfg b/tcl/board/hitex_str9-comstick.cfg
index 4d1bb2e..c85681b 100644
--- a/tcl/board/hitex_str9-comstick.cfg
+++ b/tcl/board/hitex_str9-comstick.cfg
@@ -73,7 +73,7 @@ $_TARGETNAME configure -event reset-init {
 $_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-area-backup 0
 
 #flash bank <driver> <base> <size> <chip_width> <bus_width>
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 0
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 0
diff --git a/tcl/board/lubbock.cfg b/tcl/board/lubbock.cfg
index 095c60a..b58ad5a 100644
--- a/tcl/board/lubbock.cfg
+++ b/tcl/board/lubbock.cfg
@@ -12,9 +12,9 @@ jtag_ntrst_delay 250
 
 # CS0, CS1 -- two banks of CFI flash, 32 MBytes each
 # each bank is 32-bits wide, two 16-bit chips in parallel
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME cfi 0x00000000 0x02000000 2 4 $_TARGETNAME
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME cfi 0x04000000 0x02000000 2 4 $_TARGETNAME
 
 # CS2 low -- FPGA registers
diff --git a/tcl/board/str910-eval.cfg b/tcl/board/str910-eval.cfg
index a2772a8..9e3f881 100644
--- a/tcl/board/str910-eval.cfg
+++ b/tcl/board/str910-eval.cfg
@@ -58,9 +58,9 @@ $_TARGETNAME configure -event reset-init {
 }
 
 #flash bank str9x <base> <size> 0 0 <target#> <variant>
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 0
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 0
 
 # For more information about the configuration files, take a look at:
diff --git a/tcl/target/at91sam3u4c.cfg b/tcl/target/at91sam3u4c.cfg
index e281287..5cacbcb 100644
--- a/tcl/target/at91sam3u4c.cfg
+++ b/tcl/target/at91sam3u4c.cfg
@@ -2,10 +2,10 @@
 source [find target/at91sam3uxx.cfg]
 
 # size is automatically "calculated" by probing
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
 # This is a 256K chip, it has the 2nd bank
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME at91sam3 0x000100000 0 1 1 $_TARGETNAME
 
 
diff --git a/tcl/target/at91sam3u4e.cfg b/tcl/target/at91sam3u4e.cfg
index e549185..6f6e0d8 100644
--- a/tcl/target/at91sam3u4e.cfg
+++ b/tcl/target/at91sam3u4e.cfg
@@ -2,10 +2,10 @@
 source [find target/at91sam3uXX.cfg]
 
 # size is automatically "calculated" by probing
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME at91sam3 0x000080000 0 1 1 $_TARGETNAME
 # This is a 256K chip - it has the 2nd bank
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME at91sam3 0x000100000 0 1 1 $_TARGETNAME
 
 
diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index 673d254..0b99cdb 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -67,9 +67,9 @@ $_TARGETNAME configure -event reset-init {
 	mww 0xbf882030 $_PIC32MX_PROGSIZE
 }
 
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME pic32mx 0x1fc00000 0 0 0 $_TARGETNAME
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME pic32mx 0x1d000000 0 0 0 $_TARGETNAME
 
 # For more information about the configuration files, take a look at:
diff --git a/tcl/target/str710.cfg b/tcl/target/str710.cfg
index 4d68586..a5955b6 100644
--- a/tcl/target/str710.cfg
+++ b/tcl/target/str710.cfg
@@ -47,9 +47,9 @@ $_TARGETNAME configure -event gdb-flash-erase-start {
 $_TARGETNAME configure -work-area-phys 0x2000C000 -work-area-size 0x4000 -work-area-backup 0
 
 #flash bank str7x <base> <size> 0 0 <target#> <variant>
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str7x 0x40000000 0x00040000 0 0 $_TARGETNAME STR71x
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str7x 0x400C0000 0x00004000 0 0 $_TARGETNAME STR71x
 
 # For more information about the configuration files, take a look at:
diff --git a/tcl/target/str750.cfg b/tcl/target/str750.cfg
index 8a64226..7d9f034 100644
--- a/tcl/target/str750.cfg
+++ b/tcl/target/str750.cfg
@@ -53,8 +53,8 @@ $_TARGETNAME configure -event gdb-flash-erase-start {
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
 #flash bank <driver> <base> <size> <chip_width> <bus_width>
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str7x 0x20000000 0x00040000 0 0 $_TARGETNAME STR75x
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str7x 0x200C0000 0x00004000 0 0 $_TARGETNAME STR75x
 
diff --git a/tcl/target/str912.cfg b/tcl/target/str912.cfg
index 6f2981a..a16c83a 100644
--- a/tcl/target/str912.cfg
+++ b/tcl/target/str912.cfg
@@ -63,9 +63,9 @@ $_TARGETNAME configure -event reset-init {
 $_TARGETNAME configure -work-area-phys 0x50000000 -work-area-size 16384 -work-area-backup 0
 
 #flash bank str9x <base> <size> 0 0 <target#> <variant>
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME str9x 0x00000000 0x00080000 0 0 $_TARGETNAME
-set _FLASHNAME $_CHIPNAME.flash
+set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME str9x 0x00080000 0x00008000 0 0 $_TARGETNAME
 
 # For more information about the configuration files, take a look at:

commit a7fb60dc7b23a78be0ad5876b0e76a0e76875d5c
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed May 12 22:42:26 2010 +0100

    flash: require unique flash bank name
    
    Make sure the flash bank name is unique
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index a3efd80..a6e942e 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -795,6 +795,14 @@ COMMAND_HANDLER(handle_flash_bank_command)
 		return ERROR_FAIL;
 	}
 
+	/* check the flash bank name is unique */
+	if (get_flash_bank_by_name(bank_name) != NULL)
+	{
+		/* flash bank name already exists  */
+		LOG_ERROR("flash bank name '%s' already exists", bank_name);
+		return ERROR_FAIL;
+	}
+
 	/* register flash specific commands */
 	if (NULL != driver->commands)
 	{

commit 7b36d2a229ecde1a497773233ee1850bb10d80a7
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed May 12 22:40:19 2010 +0100

    flash: add flash bank name support
    
    flash cmds can now be passed either the bank name or the bank number.
    For example.
    flash info stm32.flash
    flash info 0
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 17c6e91..a3efd80 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -49,21 +49,18 @@ COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
 COMMAND_HANDLER(handle_flash_info_command)
 {
 	struct flash_bank *p;
-	uint32_t i = 0;
 	int j = 0;
 	int retval;
 
 	if (CMD_ARGC != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	unsigned bank_nr;
-	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
+	if (retval != ERROR_OK)
+		return retval;
 
-	for (p = flash_bank_list(); p; p = p->next, i++)
+	if (p != NULL)
 	{
-		if (i != bank_nr)
-			continue;
-
 		char buf[1024];
 
 		/* attempt auto probe */
@@ -76,8 +73,8 @@ COMMAND_HANDLER(handle_flash_info_command)
 			return retval;
 
 		command_print(CMD_CTX,
-			      "#%" PRIi32 " : %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", buswidth %i, chipwidth %i",
-			      i,
+			      "#%" PRIu32 " : %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", buswidth %i, chipwidth %i",
+			      p->bank_number,
 			      p->driver->name,
 			      p->base,
 			      p->size,
@@ -115,6 +112,7 @@ COMMAND_HANDLER(handle_flash_info_command)
 
 COMMAND_HANDLER(handle_flash_probe_command)
 {
+	struct flash_bank *p;
 	int retval;
 
 	if (CMD_ARGC != 1)
@@ -122,9 +120,10 @@ COMMAND_HANDLER(handle_flash_probe_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	unsigned bank_nr;
-	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num_noprobe(bank_nr);
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
+	if (retval != ERROR_OK)
+		return retval;
+
 	if (p)
 	{
 		if ((retval = p->driver->probe(p)) == ERROR_OK)
@@ -294,15 +293,13 @@ COMMAND_HANDLER(handle_flash_erase_command)
 	if (CMD_ARGC != 3)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t bank_nr;
 	uint32_t first;
 	uint32_t last;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
-
 	struct flash_bank *p;
 	int retval;
-	retval = get_flash_bank_by_num(bank_nr, &p);
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -325,7 +322,7 @@ COMMAND_HANDLER(handle_flash_erase_command)
 	{
 		command_print(CMD_CTX, "erased sectors %" PRIu32 " "
 				"through %" PRIu32" on flash bank %" PRIu32 " "
-				"in %fs", first, last, bank_nr, duration_elapsed(&bench));
+				"in %fs", first, last, p->bank_number, duration_elapsed(&bench));
 	}
 
 	return ERROR_OK;
@@ -336,13 +333,13 @@ COMMAND_HANDLER(handle_flash_protect_command)
 	if (CMD_ARGC != 4)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t bank_nr;
 	uint32_t first;
 	uint32_t last;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
 	struct flash_bank *p;
-	int retval = get_flash_bank_by_num(bank_nr, &p);
+	int retval;
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &p);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -362,9 +359,9 @@ COMMAND_HANDLER(handle_flash_protect_command)
 	retval = flash_driver_protect(p, set, first, last);
 	if (retval == ERROR_OK) {
 		command_print(CMD_CTX, "%s protection for sectors %i "
-				"through %i on flash bank %i",
+				"through %i on flash bank %" PRIu32 "",
 			(set) ? "set" : "cleared", (int) first,
-			(int) last, (int) bank_nr);
+			(int) last, p->bank_number);
 	}
 
 	return ERROR_OK;
@@ -847,8 +844,8 @@ COMMAND_HANDLER(handle_flash_banks_command)
 	unsigned n = 0;
 	for (struct flash_bank *p = flash_bank_list(); p; p = p->next, n++)
 	{
-		LOG_USER("#%u: %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", "
-			"buswidth %u, chipwidth %u", n,
+		LOG_USER("#%" PRIu32 " : %s at 0x%8.8" PRIx32 ", size 0x%8.8" PRIx32 ", "
+			"buswidth %u, chipwidth %u", p->bank_number,
 			p->driver->name, p->base, p->size,
 			p->bus_width, p->chip_width);
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/tcl.c               |   53 ++++++++++++++++++++----------------
 tcl/board/hitex_str9-comstick.cfg |    4 +-
 tcl/board/lubbock.cfg             |    4 +-
 tcl/board/str910-eval.cfg         |    4 +-
 tcl/target/at91sam3u4c.cfg        |    4 +-
 tcl/target/at91sam3u4e.cfg        |    4 +-
 tcl/target/pic32mx.cfg            |    4 +-
 tcl/target/str710.cfg             |    4 +-
 tcl/target/str750.cfg             |    4 +-
 tcl/target/str912.cfg             |    4 +-
 10 files changed, 47 insertions(+), 42 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri May 14 13:27:07 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 14 May 2010 11:27:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-234-gdcca0b7
Message-ID: <E1OCt2u-0005tB-Me@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  dcca0b7694d23dbee6f1554dfbc4bffc4bedb4f2 (commit)
       via  0eb7fb59a0afe9c82f1f3d3f88fb88e3f04d706a (commit)
      from  215a5f7442773693045613cff9e3ce3c7f7e9678 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dcca0b7694d23dbee6f1554dfbc4bffc4bedb4f2
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Thu May 13 18:31:42 2010 +0900

    NAND: fix first and last handling in nand_build_bbt
    
    Last block was being skipped, fix by changing the loop test from "<" to "<="
    
    First block argument was ignored, always started from block 0 (and counted
    the wrong blocks as bad if first was nonzero). Now we use it.
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index e763491..44b13ce 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -222,8 +222,9 @@ COMMAND_HELPER(nand_command_get_device, unsigned name_index,
 
 int nand_build_bbt(struct nand_device *nand, int first, int last)
 {
-	uint32_t page = 0x0;
+	uint32_t page;
 	int i;
+	int pages_per_block = (nand->erase_size / nand->page_size);
 	uint8_t oob[6];
 
 	if ((first < 0) || (first >= nand->num_blocks))
@@ -232,7 +233,8 @@ int nand_build_bbt(struct nand_device *nand, int first, int last)
 	if ((last >= nand->num_blocks) || (last == -1))
 		last = nand->num_blocks - 1;
 
-	for (i = first; i < last; i++)
+	page = first * pages_per_block;
+	for (i = first; i <= last; i++)
 	{
 		nand_read_page(nand, page, NULL, 0, oob, 6);
 
@@ -248,7 +250,7 @@ int nand_build_bbt(struct nand_device *nand, int first, int last)
 			nand->blocks[i].is_bad = 0;
 		}
 
-		page += (nand->erase_size / nand->page_size);
+		page += pages_per_block;
 	}
 
 	return ERROR_OK;

commit 0eb7fb59a0afe9c82f1f3d3f88fb88e3f04d706a
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Thu May 13 18:31:41 2010 +0900

    NAND: fix off-by-one error in erase command argument range
    
    The last_block argument to nand_erase() is checked against nand->num_blocks,
    but the highest valid block number is (total - 1), the test for invalid should
    be ">=" rather than ">".
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 9013812..e763491 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -528,7 +528,7 @@ int nand_erase(struct nand_device *nand, int first_block, int last_block)
 	if (!nand->device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
 
-	if ((first_block < 0) || (last_block > nand->num_blocks))
+	if ((first_block < 0) || (last_block >= nand->num_blocks))
 		return ERROR_INVALID_ARGUMENTS;
 
 	/* make sure we know if a block is bad before erasing it */

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/core.c |   10 ++++++----
 1 files changed, 6 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri May 14 15:25:27 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 14 May 2010 13:25:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-235-g9597dce
Message-ID: <E1OCutN-0003Sg-VV@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  9597dcefaaf1282aa6721349e5b7472114b8bb54 (commit)
      from  dcca0b7694d23dbee6f1554dfbc4bffc4bedb4f2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 9597dcefaaf1282aa6721349e5b7472114b8bb54
Author: Jun Ma <sync.jma at gmail.com>
Date:   Fri May 14 21:04:14 2010 +0800

    missing pointer's declaration when enable macro -D_DEBUG_GDB_IO_.
    
    reproducable when "./configure --enable-maintainer-mode CFLAGS=-D_DEBUG_GDB_IO_"
    
    Signed-off-by: Jun Ma <sync.jma at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 275d414..5b4fb7a 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -171,6 +171,9 @@ static int gdb_get_char_inner(struct connection *connection, int* next_char)
 	struct gdb_connection *gdb_con = connection->priv;
 	int retval = ERROR_OK;
 
+#ifdef _DEBUG_GDB_IO_
+	char *debug_buffer;
+#endif
 	for (;;)
 	{
 		if (connection->service->type == CONNECTION_PIPE)

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sat May 15 10:08:14 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sat, 15 May 2010 08:08:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-236-gb8c54b3
Message-ID: <E1ODCPx-0005wp-R5@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b8c54b362b395e50baf749366f6ec9e29fcba27e (commit)
      from  9597dcefaaf1282aa6721349e5b7472114b8bb54 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b8c54b362b395e50baf749366f6ec9e29fcba27e
Author: Jun Ma <sync.jma at gmail.com>
Date:   Fri May 14 21:43:11 2010 +0800

    comments on doc/manual/primer/jtag.txt
    
    1. fix some errors in jtag.txt(in my personal opinion, please review).
    2. remove a broken link
    
    Signed-off-by: Jun Ma <sync.jma at gmail.com>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/doc/manual/primer/jtag.txt b/doc/manual/primer/jtag.txt
index 0c67528..997f53b 100644
--- a/doc/manual/primer/jtag.txt
+++ b/doc/manual/primer/jtag.txt
@@ -29,7 +29,7 @@ TMS which will select different shift registers.
 
 The first thing you need to do is reset the state machine, because when
 you connect to a chip you do not know what state the controller is in,you need
-to clock TMS as 1, at least 7 times.  This will put you into "Test Logic
+to clock TMS as 1, at least 5 times.  This will put you into "Test Logic
 Reset" State.  Knowing this, you can, once reset, then track what each
 transition on TMS will do, and hence know what state the JTAG state
 machine is in.
@@ -45,9 +45,9 @@ instruction register.
 
 For example, one of the data registers will be known as "bypass" this is
 (usually) a single bit which has no function and is used to bypass the
-chip.  Assume we have 3 identical chips, wired up like the picture
-and each has a 3 bit instruction register, and there are 2 known
-instructions (110 = bypass, 010 = some other function) if we want to use
+chip.  Assume we have 3 identical chips, wired up like the picture(wikipedia)
+and each has a 3 bits instruction register, and there are 2 known
+instructions (110 = bypass, 010 = "some other function") if we want to use
 "some other function", on the second chip in the line, and not change
 the other chips we would do the following transitions.
 
@@ -66,13 +66,13 @@ each chip [110] [010] [110]
 The order is reversed, because we shift out the least significant bit
 first.  Then we transition TMS:
 
-  1 1 1 1 0 0
+  1 1 1 0 0
 
 which puts us in the "Shift DR state".
 
 Now when we clock data onto TDI (again while holding TMS to 0) , the
 data shifts through the data registers, and because of the instruction
-registers we selected (some other function has 8 bits in its data
+registers we selected ("some other function" has 8 bits in its data
 register), our total data register in the chain looks like this:
 
   0 00000000 0
@@ -107,10 +107,6 @@ gets interesting.  But in and of itself, JTAG is actually very simple.
 
 @section primerjtag More Reading
 
-The following link goes to an HTML (or PDF) introduction to JTAG,
-written by one of the original members of the JTAG committee: @par
-http://www.asset-intertech.com/products/boundscan.htm
-
 A separate primer contains information about @subpage primerjtagbs for
 developers that want to extend OpenOCD for such purposes.
 

-----------------------------------------------------------------------

Summary of changes:
 doc/manual/primer/jtag.txt |   16 ++++++----------
 1 files changed, 6 insertions(+), 10 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun May 16 13:42:20 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 16 May 2010 11:42:20 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-247-g76b8168
Message-ID: <E1ODcEg-0007Il-0a@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  76b81682eeea804518cf69c4d916ccc78c2f3093 (commit)
       via  602685e66f163f26179f41215cf302b0a894803e (commit)
       via  bc8be110ff314cab0e09792a05b6871672c18302 (commit)
       via  24ebfffff54f5201f1503256df56717900e65e2d (commit)
       via  feb95fbb7b1af02bf62a7b06ce2fcfb972d41040 (commit)
       via  ebdd3a1670b8561e238f5c16245cefefd56b6f71 (commit)
       via  34f70956ed31c2739d34bae23fa6ca620e5299f8 (commit)
       via  a69cbf0f74015993d749bdfe1a80f4b5a8bb6dc3 (commit)
       via  61bb0d3d235c659eb407a7032aa9ec70a914dc03 (commit)
       via  89747f81f22084b255f35d92f709facd3b4553a1 (commit)
       via  c7b269ace1bbe07d5db7a562bb9242f4be32be67 (commit)
      from  b8c54b362b395e50baf749366f6ec9e29fcba27e (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 76b81682eeea804518cf69c4d916ccc78c2f3093
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Tue May 11 11:48:09 2010 +0800

    NOR/CFI: minor code cleanup
    
    Remove few LOG_DEBUG() messages, together with code and
    variables required to build such messages.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 72c95dd..b19b945 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -805,8 +805,6 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct cfi_intel_pri_ext *pri_ext = cfi_info->pri_ext;
-	struct target *target = bank->target; /* FIXME: to be removed */
-	uint8_t command[CFI_MAX_BUS_WIDTH]; /* FIXME: to be removed */
 	int retry = 0;
 	int i;
 
@@ -820,16 +818,12 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 
 	for (i = first; i <= last; i++)
 	{
-		cfi_command(bank, 0x60, command); /* FIXME: to be removed */
-		LOG_DEBUG("address: 0x%4.4" PRIx32 ", command: 0x%4.4" PRIx32, flash_address(bank, i, 0x0), target_buffer_get_u32(target, command));
 		if ((retval = cfi_send_command(bank, 0x60, flash_address(bank, i, 0x0))) != ERROR_OK)
 		{
 			return retval;
 		}
 		if (set)
 		{
-			cfi_command(bank, 0x01, command); /* FIXME: to be removed */
-			LOG_DEBUG("address: 0x%4.4" PRIx32 ", command: 0x%4.4" PRIx32 , flash_address(bank, i, 0x0), target_buffer_get_u32(target, command));
 			if ((retval = cfi_send_command(bank, 0x01, flash_address(bank, i, 0x0))) != ERROR_OK)
 			{
 				return retval;
@@ -838,8 +832,6 @@ static int cfi_intel_protect(struct flash_bank *bank, int set, int first, int la
 		}
 		else
 		{
-			cfi_command(bank, 0xd0, command); /* FIXME: to be removed */
-			LOG_DEBUG("address: 0x%4.4" PRIx32 ", command: 0x%4.4" PRIx32, flash_address(bank, i, 0x0), target_buffer_get_u32(target, command));
 			if ((retval = cfi_send_command(bank, 0xd0, flash_address(bank, i, 0x0))) != ERROR_OK)
 			{
 				return retval;

commit 602685e66f163f26179f41215cf302b0a894803e
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Tue May 11 11:35:28 2010 +0800

    NOR/CFI: add cfi_read() implementation
    
    Final step to force bus_width size during CFI flash
    read.
    
    Added CFI specific implementation cfi_read() that uses
    only accesses at bus_width size.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 1b080ac..72c95dd 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -4,6 +4,7 @@
  *   Copyright (C) 2009 Michael Schwingen                                  *
  *   michael at schwingen.org                                                 *
  *   Copyright (C) 2010 ??yvind Harboe <oyvind.harboe at zylin.com>            *
+ *   Copyright (C) 2010 by Antonio Borneo <borneo.antonio at gmail.com>       *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -1799,6 +1800,76 @@ static int cfi_write_words(struct flash_bank *bank, uint8_t *word, uint32_t word
 	return ERROR_FLASH_OPERATION_FAILED;
 }
 
+static int cfi_read(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	struct cfi_flash_bank *cfi_info = bank->driver_priv;
+	struct target *target = bank->target;
+	uint32_t address = bank->base + offset;
+	uint32_t read_p;
+	int align;	/* number of unaligned bytes */
+	uint8_t current_word[CFI_MAX_BUS_WIDTH];
+	int i;
+	int retval;
+
+	LOG_DEBUG("reading buffer of %i byte at 0x%8.8x",
+		(int)count, (unsigned)offset);
+
+	if (bank->target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (offset + count > bank->size)
+		return ERROR_FLASH_DST_OUT_OF_BANK;
+
+	if (cfi_info->qry[0] != 'Q')
+		return ERROR_FLASH_BANK_NOT_PROBED;
+
+	/* start at the first byte of the first word (bus_width size) */
+	read_p = address & ~(bank->bus_width - 1);
+	if ((align = address - read_p) != 0)
+	{
+		LOG_INFO("Fixup %d unaligned read head bytes", align);
+
+		/* read a complete word from flash */
+		if ((retval = target_read_memory(target, read_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+			return retval;
+
+		/* take only bytes we need */
+		for (i = align; (i < bank->bus_width) && (count > 0); i++, count--)
+			*buffer++ = current_word[i];
+
+		read_p += bank->bus_width;
+	}
+
+	align = count / bank->bus_width;
+	if (align)
+	{
+		if ((retval = target_read_memory(target, read_p, bank->bus_width, align, buffer)) != ERROR_OK)
+			return retval;
+
+		read_p += align * bank->bus_width;
+		buffer += align * bank->bus_width;
+		count -= align * bank->bus_width;
+	}
+
+	if (count)
+	{
+		LOG_INFO("Fixup %d unaligned read tail bytes", count);
+
+		/* read a complete word from flash */
+		if ((retval = target_read_memory(target, read_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+			return retval;
+
+		/* take only bytes we need */
+		for (i = 0; (i < bank->bus_width) && (count > 0); i++, count--)
+			*buffer++ = current_word[i];
+	}
+
+	return ERROR_OK;
+}
+
 static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
@@ -2467,8 +2538,7 @@ struct flash_driver cfi_flash = {
 	.erase = cfi_erase,
 	.protect = cfi_protect,
 	.write = cfi_write,
-	/* FIXME: access flash at bus_width size */
-	.read = default_flash_read,
+	.read = cfi_read,
 	.probe = cfi_probe,
 	.auto_probe = cfi_auto_probe,
 	/* FIXME: access flash at bus_width size */

commit bc8be110ff314cab0e09792a05b6871672c18302
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Tue May 11 11:16:33 2010 +0800

    NOR: add read() callback to struct flash_driver
    
    Final target is to force bus_width size during CFI flash
    read.
    In this first step I need to replace default flash read
    with flash specific implementation.
    This patch introduces:
    - flash_driver_read() layer;
    - default_flash_read(), backward compatible;
    - read() callback in struct flash_driver;
    - proper initialization in every flash_driver instance.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 82ea2bc..40ee321 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -417,6 +417,7 @@ struct flash_driver aduc702x_flash = {
 	.erase = aduc702x_erase,
 	.protect = aduc702x_protect,
 	.write = aduc702x_write,
+	.read = default_flash_read,
 	.probe = aduc702x_probe,
 	.auto_probe = aduc702x_probe,
 	.erase_check = default_flash_blank_check,
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index 5f013ed..06b84cd 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -2505,6 +2505,7 @@ struct flash_driver at91sam3_flash = {
 	.erase = sam3_erase,
 	.protect = sam3_protect,
 	.write = sam3_write,
+	.read = default_flash_read,
 	.probe = sam3_probe,
 	.auto_probe = sam3_auto_probe,
 	.erase_check = sam3_erase_check,
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index cca0cf2..606cc32 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -1207,6 +1207,7 @@ struct flash_driver at91sam7_flash = {
 	.erase = at91sam7_erase,
 	.protect = at91sam7_protect,
 	.write = at91sam7_write,
+	.read = default_flash_read,
 	.probe = at91sam7_probe,
 	.auto_probe = at91sam7_probe,
 	.erase_check = at91sam7_erase_check,
diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index 15b8b27..7cdab51 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -497,6 +497,7 @@ struct flash_driver avr_flash = {
 	.erase = avrf_erase,
 	.protect = avrf_protect,
 	.write = avrf_write,
+	.read = default_flash_read,
 	.probe = avrf_probe,
 	.auto_probe = avrf_auto_probe,
 	.erase_check = default_flash_mem_blank_check,
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 94ff7b9..1b080ac 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -2467,6 +2467,8 @@ struct flash_driver cfi_flash = {
 	.erase = cfi_erase,
 	.protect = cfi_protect,
 	.write = cfi_write,
+	/* FIXME: access flash at bus_width size */
+	.read = default_flash_read,
 	.probe = cfi_probe,
 	.auto_probe = cfi_auto_probe,
 	/* FIXME: access flash at bus_width size */
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 936f07c..00f73f2 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -3,6 +3,7 @@
  *   Copyright (C) 2007-2010 ??yvind Harboe <oyvind.harboe at zylin.com>       *
  *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
  *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *   Copyright (C) 2010 by Antonio Borneo <borneo.antonio at gmail.com>       *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -100,6 +101,29 @@ int flash_driver_write(struct flash_bank *bank,
 	return retval;
 }
 
+int flash_driver_read(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	int retval;
+
+	LOG_DEBUG("call flash_driver_read()");
+
+	retval = bank->driver->read(bank, buffer, offset, count);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR("error reading to flash at address 0x%08" PRIx32 " at offset 0x%8.8" PRIx32 " (%d)",
+			  bank->base, offset, retval);
+	}
+
+	return retval;
+}
+
+int default_flash_read(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	return target_read_buffer(bank->target, offset + bank->base, count, buffer);
+}
+
 void flash_bank_add(struct flash_bank *bank)
 {
 	/* put flash bank in linked list */
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index 1dfd721..a35f64f 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -3,6 +3,7 @@
  *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
  *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
  *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *   Copyright (C) 2010 by Antonio Borneo <borneo.antonio at gmail.com>       *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -136,6 +137,16 @@ void flash_set_dirty(void);
 /// @returns The number of flash banks currently defined.
 int flash_get_bank_count(void);
 /**
+ * Provides default read implementation for flash memory.
+ * @param bank The bank to read.
+ * @param buffer The data bytes read.
+ * @param offset The offset into the chip to read.
+ * @param count The number of bytes to read.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int default_flash_read(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count);
+/**
  * Provides default erased-bank check handling. Checks to see if
  * the flash driver knows they are erased; if things look uncertain,
  * this routine will call default_flash_mem_blank_check() to confirm.
diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
index 0e77132..3757442 100644
--- a/src/flash/nor/driver.h
+++ b/src/flash/nor/driver.h
@@ -3,6 +3,7 @@
  *   Copyright (C) 2007,2008 ??yvind Harboe <oyvind.harboe at zylin.com>       *
  *   Copyright (C) 2008 by Spencer Oliver <spen at spen-soft.co.uk>           *
  *   Copyright (C) 2009 Zachary T Welch <zw at superlucidity.net>             *
+ *   Copyright (C) 2010 by Antonio Borneo <borneo.antonio at gmail.com>       *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
@@ -131,6 +132,20 @@ struct flash_driver
 			uint8_t *buffer, uint32_t offset, uint32_t count);
 
 	/**
+	 * Read data from the flash. Note CPU address will be
+	 * "bank->base + offset", while the physical address is
+	 * dependent upon current target MMU mappings.
+	 *
+	 * @param bank The bank to read.
+	 * @param buffer The data bytes read.
+	 * @param offset The offset into the chip to read.
+	 * @param count The number of bytes to read.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	 int (*read)(struct flash_bank *bank,
+			uint8_t *buffer, uint32_t offset, uint32_t count);
+
+	/**
 	 * Probe to determine what kind of flash is present.
 	 * This is invoked by the "probe" script command.
 	 *
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 783a40c..f9c3285 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -436,6 +436,7 @@ struct flash_driver ecosflash_flash = {
 	.erase = ecosflash_erase,
 	.protect = ecosflash_protect,
 	.write = ecosflash_write,
+	.read = default_flash_read,
 	.probe = ecosflash_probe,
 	.auto_probe = ecosflash_probe,
 	.erase_check = default_flash_blank_check,
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
index e1e77ea..92851ed 100644
--- a/src/flash/nor/faux.c
+++ b/src/flash/nor/faux.c
@@ -141,6 +141,7 @@ struct flash_driver faux_flash = {
 	.erase = faux_erase,
 	.protect = faux_protect,
 	.write = faux_write,
+	.read = default_flash_read,
 	.probe = faux_probe,
 	.auto_probe = faux_probe,
 	.erase_check = default_flash_blank_check,
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 34ccbe4..de1bc9e 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -40,6 +40,8 @@ int flash_driver_erase(struct flash_bank *bank, int first, int last);
 int flash_driver_protect(struct flash_bank *bank, int set, int first, int last);
 int flash_driver_write(struct flash_bank *bank,
 		uint8_t *buffer, uint32_t offset, uint32_t count);
+int flash_driver_read(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count);
 
 /* write (optional verify) an image to flash memory of the given target */
 int flash_write_unlock(struct target *target, struct image *image,
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 438ab54..154248c 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -814,6 +814,7 @@ struct flash_driver lpc2000_flash = {
 	.erase = lpc2000_erase,
 	.protect = lpc2000_protect,
 	.write = lpc2000_write,
+	.read = default_flash_read,
 	.probe = lpc2000_probe,
 	.auto_probe = lpc2000_probe,
 	.erase_check = lpc2000_erase_check,
diff --git a/src/flash/nor/lpc288x.c b/src/flash/nor/lpc288x.c
index 5ab4e9c..b6d207e 100644
--- a/src/flash/nor/lpc288x.c
+++ b/src/flash/nor/lpc288x.c
@@ -478,6 +478,7 @@ struct flash_driver lpc288x_flash = {
 	.erase = lpc288x_erase,
 	.protect = lpc288x_protect,
 	.write = lpc288x_write,
+	.read = default_flash_read,
 	.probe = lpc288x_probe,
 	.auto_probe = lpc288x_probe,
 	.erase_check = lpc288x_erase_check,
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index 5b00495..3ae7bb4 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -1830,6 +1830,7 @@ struct flash_driver lpc2900_flash =
 	.erase              = lpc2900_erase,
 	.protect            = lpc2900_protect,
 	.write              = lpc2900_write,
+	.read               = default_flash_read,
 	.probe              = lpc2900_probe,
 	.auto_probe         = lpc2900_probe,
 	.erase_check        = lpc2900_erase_check,
diff --git a/src/flash/nor/ocl.c b/src/flash/nor/ocl.c
index 5d93724..9a295eb 100644
--- a/src/flash/nor/ocl.c
+++ b/src/flash/nor/ocl.c
@@ -353,6 +353,7 @@ struct flash_driver ocl_flash = {
 	.erase = ocl_erase,
 	.protect = ocl_protect,
 	.write = ocl_write,
+	.read = default_flash_read,
 	.probe = ocl_probe,
 	.erase_check = ocl_erase_check,
 	.protect_check = ocl_protect_check,
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 4ebd256..58009ae 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -766,6 +766,7 @@ struct flash_driver pic32mx_flash = {
 	.erase = pic32mx_erase,
 	.protect = pic32mx_protect,
 	.write = pic32mx_write,
+	.read = default_flash_read,
 	.probe = pic32mx_probe,
 	.auto_probe = pic32mx_auto_probe,
 	.erase_check = default_flash_mem_blank_check,
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index cce5f37..38374ff 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -1261,6 +1261,7 @@ struct flash_driver stellaris_flash = {
 	.erase = stellaris_erase,
 	.protect = stellaris_protect,
 	.write = stellaris_write,
+	.read = default_flash_read,
 	.probe = stellaris_probe,
 	.auto_probe = stellaris_probe,
 	.erase_check = default_flash_mem_blank_check,
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 7afd959..d11a8ed 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -1293,6 +1293,7 @@ struct flash_driver stm32x_flash = {
 	.erase = stm32x_erase,
 	.protect = stm32x_protect,
 	.write = stm32x_write,
+	.read = default_flash_read,
 	.probe = stm32x_probe,
 	.auto_probe = stm32x_auto_probe,
 	.erase_check = default_flash_mem_blank_check,
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index 3d52341..46510ed 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -790,6 +790,7 @@ struct flash_driver str7x_flash = {
 	.erase = str7x_erase,
 	.protect = str7x_protect,
 	.write = str7x_write,
+	.read = default_flash_read,
 	.probe = str7x_probe,
 	.auto_probe = str7x_probe,
 	.erase_check = default_flash_blank_check,
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 2208fe3..e8e942e 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -701,6 +701,7 @@ struct flash_driver str9x_flash = {
 	.erase = str9x_erase,
 	.protect = str9x_protect,
 	.write = str9x_write,
+	.read = default_flash_read,
 	.probe = str9x_probe,
 	.auto_probe = str9x_probe,
 	.erase_check = default_flash_blank_check,
diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 861d70b..073dfe1 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -1247,6 +1247,7 @@ struct flash_driver str9xpec_flash = {
 	.erase = str9xpec_erase,
 	.protect = str9xpec_protect,
 	.write = str9xpec_write,
+	.read = default_flash_read,
 	.probe = str9xpec_probe,
 	.auto_probe = str9xpec_probe,
 	.erase_check = str9xpec_erase_check,
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index ad21812..af655c6 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -559,7 +559,7 @@ COMMAND_HANDLER(handle_flash_fill_command)
 			goto done;
 		}
 
-		err = target_read_buffer(target, address + wrote, cur_size, readback);
+		err = flash_driver_read(bank, readback, address - bank->base + wrote, cur_size);
 		if (err != ERROR_OK)
 		{
 			retval = err;
diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
index edb43af..c1681f1 100644
--- a/src/flash/nor/tms470.c
+++ b/src/flash/nor/tms470.c
@@ -1264,6 +1264,7 @@ struct flash_driver tms470_flash = {
 	.erase = tms470_erase,
 	.protect = tms470_protect,
 	.write = tms470_write,
+	.read = default_flash_read,
 	.probe = tms470_probe,
 	.auto_probe = tms470_auto_probe,
 	.erase_check = tms470_erase_check,

commit 24ebfffff54f5201f1503256df56717900e65e2d
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Mon May 10 17:07:28 2010 +0800

    NOR/TCL: fix typo in error message
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index a6e942e..ad21812 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -571,7 +571,7 @@ COMMAND_HANDLER(handle_flash_fill_command)
 		{
 			if (readback[i]!=chunk[i])
 			{
-				LOG_ERROR("Verfication error address 0x%08" PRIx32 ", read back 0x%02x, expected 0x%02x",
+				LOG_ERROR("Verification error address 0x%08" PRIx32 ", read back 0x%02x, expected 0x%02x",
 						  address + wrote + i, readback[i], chunk[i]);
 				retval = ERROR_FAIL;
 				goto done;

commit feb95fbb7b1af02bf62a7b06ce2fcfb972d41040
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri May 7 17:04:32 2010 +0800

    NOR: fix comment for Doxygen
    
    Either bus_width and chip_width are in bytes.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
index de71a39..0e77132 100644
--- a/src/flash/nor/driver.h
+++ b/src/flash/nor/driver.h
@@ -75,11 +75,12 @@ struct flash_driver
 	 * CMD_ARGV[2] = baseaddress
 	 * CMD_ARGV[3] = lengthbytes
 	 * CMD_ARGV[4] = chip_width_in bytes
-	 * CMD_ARGV[5] = bus_width_bytes
+	 * CMD_ARGV[5] = bus_width_in_bytes
 	 * CMD_ARGV[6] = driver-specific parameters
 	 * @endcode
 	 *
-	 * For example, CMD_ARGV[4] = 16 bit flash, CMD_ARGV[5] = 32bit bus.
+	 * For example, CMD_ARGV[4] = 2 (for 16 bit flash),
+	 *	CMD_ARGV[5] = 4 (for 32 bit bus).
 	 *
 	 * If extra arguments are provided (@a CMD_ARGC > 6), they will
 	 * start in @a CMD_ARGV[6].  These can be used to implement

commit ebdd3a1670b8561e238f5c16245cefefd56b6f71
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri May 7 14:03:39 2010 +0800

    NOR/CFI: remove use of cfi_add_byte()
    
    Remove the function cfi_add_byte() and rewrite the only
    instance of it.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index b2d184d..94ff7b9 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -953,40 +953,6 @@ static int cfi_protect(struct flash_bank *bank, int set, int first, int last)
 	}
 }
 
-/* FIXME Replace this by a simple memcpy() - still unsure about sideeffects */
-static void cfi_add_byte(struct flash_bank *bank, uint8_t *word, uint8_t byte)
-{
-	/* struct target *target = bank->target; */
-
-	int i;
-
-	/* NOTE:
-	 * The data to flash must not be changed in endian! We write a bytestrem in
-	 * target byte order already. Only the control and status byte lane of the flash
-	 * WSM is interpreted by the CPU in different ways, when read a uint16_t or uint32_t
-	 * word (data seems to be in the upper or lower byte lane for uint16_t accesses).
-	 */
-
-#if 0
-	if (target->endianness == TARGET_LITTLE_ENDIAN)
-	{
-#endif
-		/* shift bytes */
-		for (i = 0; i < bank->bus_width - 1; i++)
-			word[i] = word[i + 1];
-		word[bank->bus_width - 1] = byte;
-#if 0
-	}
-	else
-	{
-		/* shift bytes */
-		for (i = bank->bus_width - 1; i > 0; i--)
-			word[i] = word[i - 1];
-		word[0] = byte;
-	}
-#endif
-}
-
 /* Convert code image to target endian */
 /* FIXME create general block conversion fcts in target.c?) */
 static void cfi_fix_code_endian(struct target *target, uint8_t *dest, const uint32_t *src, uint32_t count)
@@ -1936,12 +1902,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 				if (fallback)
 				{
 					for (i = 0; i < bank->bus_width; i++)
-						current_word[i] = 0;
-
-					for (i = 0; i < bank->bus_width; i++)
-					{
-						cfi_add_byte(bank, current_word, *buffer++);
-					}
+						current_word[i] = *buffer++;
 
 					retval = cfi_write_word(bank, current_word, write_p);
 					if (retval != ERROR_OK)

commit 34f70956ed31c2739d34bae23fa6ca620e5299f8
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri May 7 13:50:42 2010 +0800

    NOR/CFI: use bus_width for memory access in cfi_write()
    
    During cfi_write(), head and tail of destination area
    could be not aligned to bus_width.
    Since write operation must be at bus_width size, source
    buffer size is extended and buffer padded with current
    values read from flash.
    
    Force using bus_width to read current value from flash.
    Do not use cfi_add_byte() anymore, to allow removing this
    function later on.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index a6165c6..b2d184d 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1838,7 +1838,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
 	struct target *target = bank->target;
 	uint32_t address = bank->base + offset;	/* address of first byte to be programmed */
-	uint32_t write_p, copy_p;
+	uint32_t write_p;
 	int align;	/* number of unaligned bytes */
 	int blk_count; /* number of bus_width bytes for block copy */
 	uint8_t current_word[CFI_MAX_BUS_WIDTH * 4];	/* word (bus_width size) currently being programmed */
@@ -1863,46 +1863,18 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 	{
 		LOG_INFO("Fixup %d unaligned head bytes", align);
 
-		for (i = 0; i < bank->bus_width; i++)
-			current_word[i] = 0;
-		copy_p = write_p;
-
-		/* copy bytes before the first write address */
-		for (i = 0; i < align; ++i, ++copy_p)
-		{
-			uint8_t byte;
-			/* FIXME: access flash at bus_width size */
-			if ((retval = target_read_memory(target, copy_p, 1, 1, &byte)) != ERROR_OK)
-			{
-				return retval;
-			}
-			cfi_add_byte(bank, current_word, byte);
-		}
-
-		/* add bytes from the buffer */
-		for (; (i < bank->bus_width) && (count > 0); i++)
-		{
-			cfi_add_byte(bank, current_word, *buffer++);
-			count--;
-			copy_p++;
-		}
+		/* read a complete word from flash */
+		if ((retval = target_read_memory(target, write_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+			return retval;
 
-		/* if the buffer is already finished, copy bytes after the last write address */
-		for (; (count == 0) && (i < bank->bus_width); ++i, ++copy_p)
-		{
-			uint8_t byte;
-			/* FIXME: access flash at bus_width size */
-			if ((retval = target_read_memory(target, copy_p, 1, 1, &byte)) != ERROR_OK)
-			{
-				return retval;
-			}
-			cfi_add_byte(bank, current_word, byte);
-		}
+		/* replace only bytes that must be written */
+		for (i = align; (i < bank->bus_width) && (count > 0); i++, count--)
+			current_word[i] = *buffer++;
 
 		retval = cfi_write_word(bank, current_word, write_p);
 		if (retval != ERROR_OK)
 			return retval;
-		write_p = copy_p;
+		write_p += bank->bus_width;
 	}
 
 	/* handle blocks of bus_size aligned bytes */
@@ -1995,25 +1967,14 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 	{
 		LOG_INFO("Fixup %" PRId32 " unaligned tail bytes", count);
 
-		copy_p = write_p;
-		for (i = 0; i < bank->bus_width; i++)
-			current_word[i] = 0;
+		/* read a complete word from flash */
+		if ((retval = target_read_memory(target, write_p, bank->bus_width, 1, current_word)) != ERROR_OK)
+			return retval;
+
+		/* replace only bytes that must be written */
+		for (i = 0; (i < bank->bus_width) && (count > 0); i++, count--)
+			current_word[i] = *buffer++;
 
-		for (i = 0; (i < bank->bus_width) && (count > 0); ++i, ++copy_p)
-		{
-			cfi_add_byte(bank, current_word, *buffer++);
-			count--;
-		}
-		for (; i < bank->bus_width; ++i, ++copy_p)
-		{
-			uint8_t byte;
-			/* FIXME: access flash at bus_width size */
-			if ((retval = target_read_memory(target, copy_p, 1, 1, &byte)) != ERROR_OK)
-			{
-				return retval;
-			}
-			cfi_add_byte(bank, current_word, byte);
-		}
 		retval = cfi_write_word(bank, current_word, write_p);
 		if (retval != ERROR_OK)
 			return retval;

commit a69cbf0f74015993d749bdfe1a80f4b5a8bb6dc3
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Apr 23 12:07:53 2010 +0800

    NOR/CFI: use bus_width for memory access on flash ID.
    
    NOR flash structure requires each access to be bus_width wide.
    Fix read of flash ID accordingly to rule above.
    Add case (chip_width == 4), allowed by CFI spec and coherent
    with current value of CFI_MAX_CHIP_WIDTH but currently not
    used by any target.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index ca2fb0b..a6165c6 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -2105,6 +2105,7 @@ static int cfi_probe(struct flash_bank *bank)
 	uint32_t unlock1 = 0x555;
 	uint32_t unlock2 = 0x2aa;
 	int retval;
+	uint8_t value_buf0[CFI_MAX_BUS_WIDTH], value_buf1[CFI_MAX_BUS_WIDTH];
 
 	if (bank->target->state != TARGET_HALTED)
 	{
@@ -2137,34 +2138,30 @@ static int cfi_probe(struct flash_bank *bank)
 		return retval;
 	}
 
-	if (bank->chip_width == 1)
+	if ((retval = target_read_memory(target, flash_address(bank, 0, 0x00), bank->bus_width, 1, value_buf0)) != ERROR_OK)
 	{
-		uint8_t manufacturer, device_id;
-		/* FIXME: access flash at bus_width size */
-		if ((retval = target_read_u8(target, flash_address(bank, 0, 0x00), &manufacturer)) != ERROR_OK)
-		{
-			return retval;
-		}
-		/* FIXME: access flash at bus_width size */
-		if ((retval = target_read_u8(target, flash_address(bank, 0, 0x01), &device_id)) != ERROR_OK)
-		{
-			return retval;
-		}
-		cfi_info->manufacturer = manufacturer;
-		cfi_info->device_id = device_id;
+		return retval;
 	}
-	else if (bank->chip_width == 2)
+	if ((retval = target_read_memory(target, flash_address(bank, 0, 0x01), bank->bus_width, 1, value_buf1)) != ERROR_OK)
 	{
-		/* FIXME: access flash at bus_width size */
-		if ((retval = target_read_u16(target, flash_address(bank, 0, 0x00), &cfi_info->manufacturer)) != ERROR_OK)
-		{
-			return retval;
-		}
-		/* FIXME: access flash at bus_width size */
-		if ((retval = target_read_u16(target, flash_address(bank, 0, 0x01), &cfi_info->device_id)) != ERROR_OK)
-		{
-			return retval;
-		}
+		return retval;
+	}
+	switch (bank->chip_width) {
+		case 1:
+			cfi_info->manufacturer = *value_buf0;
+			cfi_info->device_id = *value_buf1;
+			break;
+		case 2:
+			cfi_info->manufacturer = target_buffer_get_u16(target, value_buf0);
+			cfi_info->device_id = target_buffer_get_u16(target, value_buf1);
+			break;
+		case 4:
+			cfi_info->manufacturer = target_buffer_get_u32(target, value_buf0);
+			cfi_info->device_id = target_buffer_get_u32(target, value_buf1);
+			break;
+		default:
+			LOG_ERROR("Unsupported bank chipwidth %d, can't probe memory", bank->chip_width);
+			return ERROR_FLASH_OPERATION_FAILED;
 	}
 
 	LOG_INFO("Flash Manufacturer/Device: 0x%04x 0x%04x", cfi_info->manufacturer, cfi_info->device_id);

commit 61bb0d3d235c659eb407a7032aa9ec70a914dc03
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Tue Apr 20 12:15:49 2010 +0800

    NOR/CFI: identify memory accesses not using "bus_width".
    
    Since NOR flash devices does not handle "byte enable lanes",
    each read/write access involves the whole "chip_width".
    When multiple devices are in parallel, usually all chips are
    enabled during each access.
    All such cases are compatible with flash accesses at
    "bus_width" size.
    
    Access at "bus_width" size is mandatory for write access to
    avoid transferring of garbage values to flash.
    During read access the flash controller should take care,
    and discard unneeded bytes. Anyway, it is good practice to
    use "bus_width" size also for read.
    
    Every memory access that does not respect "bus_width" size
    is marked with a "FIXME" comment.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index f2ea947..ca2fb0b 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1871,6 +1871,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 		for (i = 0; i < align; ++i, ++copy_p)
 		{
 			uint8_t byte;
+			/* FIXME: access flash at bus_width size */
 			if ((retval = target_read_memory(target, copy_p, 1, 1, &byte)) != ERROR_OK)
 			{
 				return retval;
@@ -1890,6 +1891,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 		for (; (count == 0) && (i < bank->bus_width); ++i, ++copy_p)
 		{
 			uint8_t byte;
+			/* FIXME: access flash at bus_width size */
 			if ((retval = target_read_memory(target, copy_p, 1, 1, &byte)) != ERROR_OK)
 			{
 				return retval;
@@ -2005,6 +2007,7 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 		for (; i < bank->bus_width; ++i, ++copy_p)
 		{
 			uint8_t byte;
+			/* FIXME: access flash at bus_width size */
 			if ((retval = target_read_memory(target, copy_p, 1, 1, &byte)) != ERROR_OK)
 			{
 				return retval;
@@ -2137,10 +2140,12 @@ static int cfi_probe(struct flash_bank *bank)
 	if (bank->chip_width == 1)
 	{
 		uint8_t manufacturer, device_id;
+		/* FIXME: access flash at bus_width size */
 		if ((retval = target_read_u8(target, flash_address(bank, 0, 0x00), &manufacturer)) != ERROR_OK)
 		{
 			return retval;
 		}
+		/* FIXME: access flash at bus_width size */
 		if ((retval = target_read_u8(target, flash_address(bank, 0, 0x01), &device_id)) != ERROR_OK)
 		{
 			return retval;
@@ -2150,10 +2155,12 @@ static int cfi_probe(struct flash_bank *bank)
 	}
 	else if (bank->chip_width == 2)
 	{
+		/* FIXME: access flash at bus_width size */
 		if ((retval = target_read_u16(target, flash_address(bank, 0, 0x00), &cfi_info->manufacturer)) != ERROR_OK)
 		{
 			return retval;
 		}
+		/* FIXME: access flash at bus_width size */
 		if ((retval = target_read_u16(target, flash_address(bank, 0, 0x01), &cfi_info->device_id)) != ERROR_OK)
 		{
 			return retval;
@@ -2543,6 +2550,7 @@ struct flash_driver cfi_flash = {
 	.write = cfi_write,
 	.probe = cfi_probe,
 	.auto_probe = cfi_auto_probe,
+	/* FIXME: access flash at bus_width size */
 	.erase_check = default_flash_blank_check,
 	.protect_check = cfi_protect_check,
 	.info = cfi_info,

commit 89747f81f22084b255f35d92f709facd3b4553a1
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Mon Apr 19 16:40:08 2010 +0800

    NOR/CFI: simplify bufferwsize computation
    
    Review and simplify computation of bufferwsize.
    Add comments about variables' meaning.
    
    The same code is present 3 times in the file.
    Current patch updates all the 3 instances.
    
    Step 1)
      Replace "switch(bank->chip_width) {...}".
      Illegal values of bank->chip_width are already dropped.
      For legal values, the code is equivalent to:
            bufferwsize = buffersize / bank->chip_width;
    
    Step 2)
      The above code replacement plus the following line:
            bufferwsize /= (bank->bus_width / bank->chip_width);
      is merged in a single formula:
            bufferwsize = (buffersize / bank->chip_width) /
                    (bank->bus_width / bank->chip_width);
      and simplified as:
            bufferwsize = buffersize / bank->bus_width;
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index ba2d909..f2ea947 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1604,9 +1604,11 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 	struct target *target = bank->target;
 
 	/* Calculate buffer size and boundary mask */
+	/* buffersize is (buffer size per chip) * (number of chips) */
+	/* bufferwsize is buffersize in words */
 	uint32_t buffersize = (1UL << cfi_info->max_buf_write_size) * (bank->bus_width / bank->chip_width);
 	uint32_t buffermask = buffersize-1;
-	uint32_t bufferwsize;
+	uint32_t bufferwsize = buffersize / bank->bus_width;
 
 	/* Check for valid range */
 	if (address & buffermask)
@@ -1615,18 +1617,6 @@ static int cfi_intel_write_words(struct flash_bank *bank, uint8_t *word, uint32_
 			  bank->base, address, cfi_info->max_buf_write_size);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
-	switch (bank->chip_width)
-	{
-	case 4 : bufferwsize = buffersize / 4; break;
-	case 2 : bufferwsize = buffersize / 2; break;
-	case 1 : bufferwsize = buffersize; break;
-	default:
-		LOG_ERROR("Unsupported chip width %d", bank->chip_width);
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	bufferwsize/=(bank->bus_width / bank->chip_width);
-
 
 	/* Check for valid size */
 	if (wordcount > bufferwsize)
@@ -1733,9 +1723,11 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 	struct cfi_spansion_pri_ext *pri_ext = cfi_info->pri_ext;
 
 	/* Calculate buffer size and boundary mask */
+	/* buffersize is (buffer size per chip) * (number of chips) */
+	/* bufferwsize is buffersize in words */
 	uint32_t buffersize = (1UL << cfi_info->max_buf_write_size) * (bank->bus_width / bank->chip_width);
 	uint32_t buffermask = buffersize-1;
-	uint32_t bufferwsize;
+	uint32_t bufferwsize = buffersize / bank->bus_width;
 
 	/* Check for valid range */
 	if (address & buffermask)
@@ -1743,17 +1735,6 @@ static int cfi_spansion_write_words(struct flash_bank *bank, uint8_t *word, uint
 		LOG_ERROR("Write address at base 0x%" PRIx32 ", address %" PRIx32 " not aligned to 2^%d boundary", bank->base, address, cfi_info->max_buf_write_size);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
-	switch (bank->chip_width)
-	{
-	case 4 : bufferwsize = buffersize / 4; break;
-	case 2 : bufferwsize = buffersize / 2; break;
-	case 1 : bufferwsize = buffersize; break;
-	default:
-		LOG_ERROR("Unsupported chip width %d", bank->chip_width);
-		return ERROR_FLASH_OPERATION_FAILED;
-	}
-
-	bufferwsize/=(bank->bus_width / bank->chip_width);
 
 	/* Check for valid size */
 	if (wordcount > bufferwsize)
@@ -1950,22 +1931,12 @@ static int cfi_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset,
 	{
 		if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
 		{
-			//adjust buffersize for chip width
+			/* Calculate buffer size and boundary mask */
+			/* buffersize is (buffer size per chip) * (number of chips) */
+			/* bufferwsize is buffersize in words */
 			uint32_t buffersize = (1UL << cfi_info->max_buf_write_size) * (bank->bus_width / bank->chip_width);
 			uint32_t buffermask = buffersize-1;
-			uint32_t bufferwsize;
-
-			switch (bank->chip_width)
-			{
-			case 4 : bufferwsize = buffersize / 4; break;
-			case 2 : bufferwsize = buffersize / 2; break;
-			case 1 : bufferwsize = buffersize; break;
-			default:
-				LOG_ERROR("Unsupported chip width %d", bank->chip_width);
-				return ERROR_FLASH_OPERATION_FAILED;
-			}
-
-			bufferwsize/=(bank->bus_width / bank->chip_width);
+			uint32_t bufferwsize = buffersize / bank->bus_width;
 
 			/* fall back to memory writes */
 			while (count >= (uint32_t)bank->bus_width)

commit c7b269ace1bbe07d5db7a562bb9242f4be32be67
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Fri Apr 16 01:17:01 2010 +0800

    NOR/CFI: check "flash bank" command arguments
    
    Arguments chip_width and bus_width of command "flash bank" are
    not fully checked.
    While bus_width is later on redundantly checked in several other
    parts (e.g. in cfi_command_val()) and generates run-time error,
    chip_width is never checked, nor related to actual bus_width
    value.
    Added check to avoid:
    - (chip_width == 0), that would mean no memory chip at all,
      avoiding also division by zero e.g. in cfi_get_u8();
    - (bus_width == 0), that would mean no bus at all;
    - unsupported cases of chip_width or bus_width value not power
      of 2;
    - unsupported case of chip width wider than bus.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 2235c85..ba2d909 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -624,8 +624,18 @@ FLASH_BANK_COMMAND_HANDLER(cfi_flash_bank_command)
 		return ERROR_FLASH_BANK_INVALID;
 	}
 
+	/* both widths must:
+	 * - not exceed max value;
+	 * - not be null;
+	 * - be equal to a power of 2.
+	 * bus must be wide enought to hold one chip */
 	if ((bank->chip_width > CFI_MAX_CHIP_WIDTH)
-			|| (bank->bus_width > CFI_MAX_BUS_WIDTH))
+			|| (bank->bus_width > CFI_MAX_BUS_WIDTH)
+			|| (bank->chip_width == 0)
+			|| (bank->bus_width == 0)
+			|| (bank->chip_width & (bank->chip_width - 1))
+			|| (bank->bus_width & (bank->bus_width - 1))
+			|| (bank->chip_width > bank->bus_width))
 	{
 		LOG_ERROR("chip and bus width have to specified in bytes");
 		return ERROR_FLASH_BANK_INVALID;

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/aduc702x.c  |    1 +
 src/flash/nor/at91sam3.c  |    1 +
 src/flash/nor/at91sam7.c  |    1 +
 src/flash/nor/avrf.c      |    1 +
 src/flash/nor/cfi.c       |  292 ++++++++++++++++++++-------------------------
 src/flash/nor/core.c      |   24 ++++
 src/flash/nor/core.h      |   11 ++
 src/flash/nor/driver.h    |   20 +++-
 src/flash/nor/ecos.c      |    1 +
 src/flash/nor/faux.c      |    1 +
 src/flash/nor/imp.h       |    2 +
 src/flash/nor/lpc2000.c   |    1 +
 src/flash/nor/lpc288x.c   |    1 +
 src/flash/nor/lpc2900.c   |    1 +
 src/flash/nor/ocl.c       |    1 +
 src/flash/nor/pic32mx.c   |    1 +
 src/flash/nor/stellaris.c |    1 +
 src/flash/nor/stm32x.c    |    1 +
 src/flash/nor/str7x.c     |    1 +
 src/flash/nor/str9x.c     |    1 +
 src/flash/nor/str9xpec.c  |    1 +
 src/flash/nor/tcl.c       |    4 +-
 src/flash/nor/tms470.c    |    1 +
 23 files changed, 206 insertions(+), 164 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Sun May 16 13:55:45 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Sun, 16 May 2010 11:55:45 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-248-g5fd1c2d
Message-ID: <E1ODcRh-00046i-7F@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5fd1c2db9ad43cc893d6287549262f82e6932e90 (commit)
      from  76b81682eeea804518cf69c4d916ccc78c2f3093 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5fd1c2db9ad43cc893d6287549262f82e6932e90
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Thu May 13 12:20:20 2010 +0900

    Change kb/s to KiB/s in messages about kibibytes
    
    Change download rate messages about kibibytes from "kb/s" to "KiB/s" units.
    See: http://en.wikipedia.org/wiki/Data_rate_units
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>

diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 86dbd67..1272bf6 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -309,7 +309,7 @@ COMMAND_HANDLER(handle_nand_write_command)
 	if (nand_fileio_finish(&s))
 	{
 		command_print(CMD_CTX, "wrote file %s to NAND flash %s up to "
-				"offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
+				"offset 0x%8.8" PRIx32 " in %fs (%0.3f KiB/s)",
 				CMD_ARGV[1], CMD_ARGV[0], s.address, duration_elapsed(&s.bench),
 				duration_kbps(&s.bench, total_bytes));
 	}
@@ -369,7 +369,7 @@ COMMAND_HANDLER(handle_nand_verify_command)
 	if (nand_fileio_finish(&file) == ERROR_OK)
 	{
 		command_print(CMD_CTX, "verified file %s in NAND flash %s "
-				"up to offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
+				"up to offset 0x%8.8" PRIx32 " in %fs (%0.3f KiB/s)",
 				CMD_ARGV[1], CMD_ARGV[0], dev.address, duration_elapsed(&file.bench),
 				duration_kbps(&file.bench, dev.size));
 	}
@@ -409,7 +409,7 @@ COMMAND_HANDLER(handle_nand_dump_command)
 
 	if (nand_fileio_finish(&s) == ERROR_OK)
 	{
-		command_print(CMD_CTX, "dumped %ld bytes in %fs (%0.3f kb/s)", 
+		command_print(CMD_CTX, "dumped %ld bytes in %fs (%0.3f KiB/s)",
 				(long)s.fileio.size, duration_elapsed(&s.bench),
 				duration_kbps(&s.bench, s.fileio.size));
 	}
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index af655c6..80d9a27 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -263,7 +263,7 @@ COMMAND_HANDLER(handle_flash_erase_address_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "erased address 0x%8.8x (length %i)"
-				" in %fs (%0.3f kb/s)", address, length,
+				" in %fs (%0.3f KiB/s)", address, length,
 				duration_elapsed(&bench), duration_kbps(&bench, length));
 	}
 
@@ -448,7 +448,7 @@ COMMAND_HANDLER(handle_flash_write_image_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "wrote %" PRIu32 " bytes from file %s "
-				"in %fs (%0.3f kb/s)", written, CMD_ARGV[0],
+				"in %fs (%0.3f KiB/s)", written, CMD_ARGV[0],
 				duration_elapsed(&bench), duration_kbps(&bench, written));
 	}
 
@@ -582,7 +582,7 @@ COMMAND_HANDLER(handle_flash_fill_command)
 	if (duration_measure(&bench) == ERROR_OK)
 	{
 		command_print(CMD_CTX, "wrote %" PRIu32 " bytes to 0x%8.8" PRIx32
-				" in %fs (%0.3f kb/s)", wrote, address,
+				" in %fs (%0.3f KiB/s)", wrote, address,
 				duration_elapsed(&bench), duration_kbps(&bench, wrote));
 	}
 
@@ -634,7 +634,7 @@ COMMAND_HANDLER(handle_flash_write_bank_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "wrote %ld bytes from file %s to flash bank %u"
-				" at offset 0x%8.8" PRIx32 " in %fs (%0.3f kb/s)",
+				" at offset 0x%8.8" PRIx32 " in %fs (%0.3f KiB/s)",
 				(long)fileio.size, CMD_ARGV[1], p->bank_number, offset,
 				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));
 	}
diff --git a/src/target/target.c b/src/target/target.c
index 37e515a..c8c1012 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2560,7 +2560,7 @@ COMMAND_HANDLER(handle_load_image_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "downloaded %" PRIu32 " bytes "
-				"in %fs (%0.3f kb/s)", image_size,
+				"in %fs (%0.3f KiB/s)", image_size,
 				duration_elapsed(&bench), duration_kbps(&bench, image_size));
 	}
 
@@ -2626,7 +2626,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX,
-				"dumped %ld bytes in %fs (%0.3f kb/s)", (long)fileio.size,
+				"dumped %ld bytes in %fs (%0.3f KiB/s)", (long)fileio.size,
 				duration_elapsed(&bench), duration_kbps(&bench, fileio.size));
 	}
 
@@ -2769,7 +2769,7 @@ done:
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "verified %" PRIu32 " bytes "
-				"in %fs (%0.3f kb/s)", image_size,
+				"in %fs (%0.3f KiB/s)", image_size,
 				duration_elapsed(&bench), duration_kbps(&bench, image_size));
 	}
 
@@ -4949,7 +4949,7 @@ COMMAND_HANDLER(handle_fast_load_image_command)
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK))
 	{
 		command_print(CMD_CTX, "Loaded %" PRIu32 " bytes "
-				"in %fs (%0.3f kb/s)", image_size, 
+				"in %fs (%0.3f KiB/s)", image_size,
 				duration_elapsed(&bench), duration_kbps(&bench, image_size));
 
 		command_print(CMD_CTX,

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/tcl.c |    6 +++---
 src/flash/nor/tcl.c  |    8 ++++----
 src/target/target.c  |    8 ++++----
 3 files changed, 11 insertions(+), 11 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon May 17 11:19:34 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 17 May 2010 09:19:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-249-g3ecc191
Message-ID: <E1ODwU5-0007mJ-E3@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3ecc191b361d913d3bdf156568454de57f093aee (commit)
      from  5fd1c2db9ad43cc893d6287549262f82e6932e90 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3ecc191b361d913d3bdf156568454de57f093aee
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 17 10:17:21 2010 +0100

    gdbserver: gdb cmds returning failure on success
    
    The gdb_memory_map cmd for example fell through and returned
    ERROR_COMMAND_SYNTAX_ERROR on success - behaviour is now as expected.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 5b4fb7a..a84c618 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2503,26 +2503,29 @@ COMMAND_HANDLER(handle_gdb_port_command)
 
 COMMAND_HANDLER(handle_gdb_memory_map_command)
 {
-	if (CMD_ARGC == 1)
-		COMMAND_PARSE_ENABLE(CMD_ARGV[0], gdb_use_memory_map);
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	return ERROR_COMMAND_SYNTAX_ERROR;
+	COMMAND_PARSE_ENABLE(CMD_ARGV[0], gdb_use_memory_map);
+	return ERROR_OK;
 }
 
 COMMAND_HANDLER(handle_gdb_flash_program_command)
 {
-	if (CMD_ARGC == 1)
-		COMMAND_PARSE_ENABLE(CMD_ARGV[0], gdb_flash_program);
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	return ERROR_COMMAND_SYNTAX_ERROR;
+	COMMAND_PARSE_ENABLE(CMD_ARGV[0], gdb_flash_program);
+	return ERROR_OK;
 }
 
 COMMAND_HANDLER(handle_gdb_report_data_abort_command)
 {
-	if (CMD_ARGC == 1)
-		COMMAND_PARSE_ENABLE(CMD_ARGV[0], gdb_report_data_abort);
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	return ERROR_COMMAND_SYNTAX_ERROR;
+	COMMAND_PARSE_ENABLE(CMD_ARGV[0], gdb_report_data_abort);
+	return ERROR_OK;
 }
 
 /* gdb_breakpoint_override */

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c |   21 ++++++++++++---------
 1 files changed, 12 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May 18 09:23:51 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 18 May 2010 07:23:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-250-gfafed75
Message-ID: <E1OEH9d-0003oJ-T1@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fafed75d9831c8038c5504fc94e941f0ee9770e5 (commit)
      from  3ecc191b361d913d3bdf156568454de57f093aee (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fafed75d9831c8038c5504fc94e941f0ee9770e5
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Mon May 17 16:15:35 2010 +0900

    NAND: catch read errors when building BBT
    
    nand_build_bbt() was ignoring the return value from nand_read_page() and
    blindly continuing.
    It now passes the return value up to the caller if the read fails.
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>

diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 44b13ce..b3220e2 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -226,6 +226,7 @@ int nand_build_bbt(struct nand_device *nand, int first, int last)
 	int i;
 	int pages_per_block = (nand->erase_size / nand->page_size);
 	uint8_t oob[6];
+	int ret;
 
 	if ((first < 0) || (first >= nand->num_blocks))
 		first = 0;
@@ -236,7 +237,9 @@ int nand_build_bbt(struct nand_device *nand, int first, int last)
 	page = first * pages_per_block;
 	for (i = first; i <= last; i++)
 	{
-		nand_read_page(nand, page, NULL, 0, oob, 6);
+		ret = nand_read_page(nand, page, NULL, 0, oob, 6);
+		if (ret != ERROR_OK)
+			return ret;
 
 		if (((nand->device->options & NAND_BUSWIDTH_16) && ((oob[0] & oob[1]) != 0xff))
 			|| (((nand->page_size == 512) && (oob[5] != 0xff)) ||

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/core.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May 18 09:25:11 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 18 May 2010 07:25:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-251-gdc464ad
Message-ID: <E1OEHAv-0003u5-53@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  dc464ad88e7b7c5e0014a1784edcdb2fdcb448fd (commit)
      from  fafed75d9831c8038c5504fc94e941f0ee9770e5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit dc464ad88e7b7c5e0014a1784edcdb2fdcb448fd
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Mon May 17 16:16:22 2010 +0900

    NAND/davinci: Fix segfault for hwecc4_infix reads
    
    Page reads using hwecc4_infix layout segfaulted for check_bad_blocks because
    the read assumed a valid data buffer, which check_bad_blocks does not use
    (it only passes a 6 byte buffer for the start of OOB).
    
    This version copes with undersized or missing data or oob buffers and uses
    random read commands within the page to skip unwanted areas of data/OOB for
    speed.
    
    NOTE: Running check_bad_blocks with this layout will be reading infix
    OOB locations, not manufacturer bad block markers. This means that if you
    check blocks written in infix layout they will appear good, but manufacturer-
    marked bad blocks may also appear good.
    If you want to scan for manufactuer-marked bad blocks, you need to enable
    raw_access before running check_bad_blocks, or use the non-infix layout.
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>
    CC: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 96cbfea..90219c6 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -338,6 +338,27 @@ static void davinci_write_pagecmd(struct nand_device *nand, uint8_t cmd, uint32_
 		target_write_u8(target, info->addr, page >> 24);
 }
 
+static int davinci_seek_column(struct nand_device *nand, uint16_t column)
+{
+	struct davinci_nand *info = nand->controller_priv;
+	struct target *target = info->target;
+
+	/* Random read, we must have issued a page read already */
+	target_write_u8(target, info->cmd, NAND_CMD_RNDOUT);
+
+	target_write_u8(target, info->addr, column);
+
+	if (nand->page_size > 512) {
+		target_write_u8(target, info->addr, column >> 8);
+		target_write_u8(target, info->cmd, NAND_CMD_RNDOUTSTART);
+	}
+
+	if (!davinci_nand_ready(nand, 100))
+		return ERROR_NAND_OPERATION_TIMEOUT;
+
+	return ERROR_OK;
+}
+
 static int davinci_writepage_tail(struct nand_device *nand,
 		uint8_t *oob, uint32_t oob_size)
 {
@@ -599,6 +620,10 @@ static int davinci_write_page_ecc4infix(struct nand_device *nand, uint32_t page,
 static int davinci_read_page_ecc4infix(struct nand_device *nand, uint32_t page,
 		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
+	int read_size;
+	int want_col, at_col;
+	int ret;
+
 	davinci_write_pagecmd(nand, NAND_CMD_READ0, page);
 
 	/* large page devices need a start command */
@@ -610,18 +635,43 @@ static int davinci_read_page_ecc4infix(struct nand_device *nand, uint32_t page,
 
 	/* NOTE:  not bothering to compute and use ECC data for now */
 
-	do {
-		/* write 512 bytes */
-		davinci_read_block_data(nand, data, 512);
-		data += 512;
-		data_size -= 512;
-
-		/* read this "out-of-band" data -- infix */
-		davinci_read_block_data(nand, oob, 16);
-		oob += 16;
-		oob_size -= 16;
-	} while (data_size);
-
+	want_col = 0;
+	at_col = 0;
+	while ((data && data_size) || (oob && oob_size)) {
+
+		if (data && data_size) {
+			if (want_col != at_col) {
+				/* Reads are slow, so seek past them when we can */
+				ret  = davinci_seek_column(nand, want_col);
+				if (ret != ERROR_OK)
+					return ret;
+				at_col = want_col;
+			}
+			/* read 512 bytes or data_size, whichever is smaller*/
+			read_size = data_size > 512 ? 512 : data_size;
+			davinci_read_block_data(nand, data, read_size);
+			data += read_size;
+			data_size -= read_size;
+			at_col += read_size;
+		}
+		want_col += 512;
+
+		if (oob && oob_size) {
+			if (want_col != at_col) {
+				ret  = davinci_seek_column(nand, want_col);
+				if (ret != ERROR_OK)
+					return ret;
+				at_col = want_col;
+			}
+			/* read this "out-of-band" data -- infix */
+			read_size = oob_size > 16 ? 16 : oob_size;
+			davinci_read_block_data(nand, oob, read_size);
+			oob += read_size;
+			oob_size -= read_size;
+			at_col += read_size;
+		}
+		want_col += 16;
+	}
 	return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/davinci.c |   74 ++++++++++++++++++++++++++++++++++++++-------
 1 files changed, 62 insertions(+), 12 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May 18 11:48:43 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 18 May 2010 09:48:43 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-252-ge92b203
Message-ID: <E1OEJPr-0006Qv-9X@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e92b203a768731fdbc1499c59b0a60e1a2b290a7 (commit)
      from  dc464ad88e7b7c5e0014a1784edcdb2fdcb448fd (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e92b203a768731fdbc1499c59b0a60e1a2b290a7
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Tue May 18 11:38:01 2010 +0200

    at91rm9200 : reset_config should go to the board config file
    
    Let other boards do other things with srst and trst.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/at91rm9200-dk.cfg b/tcl/board/at91rm9200-dk.cfg
index 402ed05..f484fde 100644
--- a/tcl/board/at91rm9200-dk.cfg
+++ b/tcl/board/at91rm9200-dk.cfg
@@ -5,6 +5,9 @@
 #
 # It has atmel at91rm9200 chip.
 source [find target/at91rm9200.cfg]
+
+reset_config trst_and_srst
+
 $_TARGETNAME configure -event gdb-attach { reset init }
 $_TARGETNAME configure -event reset-init { at91rm9200_dk_init }
 
diff --git a/tcl/target/at91rm9200.cfg b/tcl/target/at91rm9200.cfg
index e2972d7..a9cda19 100644
--- a/tcl/target/at91rm9200.cfg
+++ b/tcl/target/at91rm9200.cfg
@@ -1,8 +1,6 @@
 # Atmel AT91rm9200
 # http://atmel.com/products/at91/
 
-reset_config trst_and_srst
-
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
 } else {

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/at91rm9200-dk.cfg |    3 +++
 tcl/target/at91rm9200.cfg   |    2 --
 2 files changed, 3 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May 18 12:32:51 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 18 May 2010 10:32:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-253-ge804a34
Message-ID: <E1OEK6X-0006V3-2g@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e804a34a632345effd706872605a0cc382a4da70 (commit)
      from  e92b203a768731fdbc1499c59b0a60e1a2b290a7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e804a34a632345effd706872605a0cc382a4da70
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue May 18 12:10:24 2010 +0200

    zy1000: fix false positive warning about unitialized local variable
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index b3f94e5..442a09f 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -181,7 +181,7 @@ void zy1000_reset(int trst, int srst)
 		(!srst && !trst && (jtag_get_reset_config() & RESET_TRST_PULLS_SRST)))
 	{
 		bool first = true;
-		long long start;
+		long long start = 0;
 		long total = 0;
 		for (;;)
 		{	

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue May 18 12:47:53 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue, 18 May 2010 10:47:53 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-254-gc86d7bd
Message-ID: <E1OEKL5-0001Ja-IY@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c86d7bdad4418f4fc3d81a68398187c6480316fa (commit)
      from  e804a34a632345effd706872605a0cc382a4da70 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c86d7bdad4418f4fc3d81a68398187c6480316fa
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue May 18 12:34:12 2010 +0200

    jim: fix bug in tcl "puts"
    
    tcl "puts" didn't work because the logging code sensored strings
    that did not include a '\n'. The correct thing is to sensor
    empty strings, which are used to keep gdb connection alive.
    
    The tcl "puts" code broke apart strings which do contain '\n' in
    order to implement the -nonewline argument, which is how it
    got hurt by the bug in log.c
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/log.c b/src/helper/log.c
index 7ace930..da227bd 100644
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -139,7 +139,7 @@ static void log_puts(enum log_levels level, const char *file, int line, const ch
 	if (f != NULL)
 		file = f + 1;
 
-	if (strchr(string, '\n') != NULL)
+	if (strlen(string) > 0)
 	{
 		if (debug_level >= LOG_LVL_DEBUG)
 		{
@@ -163,17 +163,12 @@ static void log_puts(enum log_levels level, const char *file, int line, const ch
 		{
 			/* if we are using gdb through pipes then we do not want any output
 			 * to the pipe otherwise we get repeated strings */
-			if (strcmp(string, "\n") != 0)
-			{
-				/* print human readable output - but skip empty lines */
-				fprintf(log_output, "%s%s",
-						(level > LOG_LVL_USER)?log_strings[level + 1]:"", string);
-			}
+			fprintf(log_output, "%s%s",
+					(level > LOG_LVL_USER)?log_strings[level + 1]:"", string);
 		}
 	} else
 	{
-		/* only entire lines are logged. Otherwise it's
-		 * single chars intended for the log callbacks. */
+		/* Empty strings are sent to log callbacks to keep e.g. gdbserver alive, here we do nothing. */
 	}
 
 	fflush(log_output);

-----------------------------------------------------------------------

Summary of changes:
 src/helper/log.c |   13 ++++---------
 1 files changed, 4 insertions(+), 9 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed May 19 07:37:26 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 19 May 2010 05:37:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-256-g8465e99
Message-ID: <E1OEbyE-0000cm-Kf@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8465e9944291a03a216fa15e0d7ed6eb9d44ba92 (commit)
       via  b80d0501b66002cba1b3bc97a027d4f79932f20d (commit)
      from  c86d7bdad4418f4fc3d81a68398187c6480316fa (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8465e9944291a03a216fa15e0d7ed6eb9d44ba92
Author: Gary Carlson <gcarlson at carlson-minot.com>
Date:   Tue May 18 20:59:07 2010 -0700

    reset: fix reset halt bug
    
    I was finally able to figure out the cause of this problem.  There are two
    parts to the patch.  The first patch modifies the configuration file I
    originally generated for the Atmel AT91SAM9G20 board and achieves the
    following:
    
    +++ Splits the reset-init handler into a reset-start handler for some of the
    initial configuration activities and keeps the remainder in the reset-init
    handler as was the case before.  This was the real issue that was causing
    the timing problems I identified before.  This solution was confirmed with
    an o-scope on actual target hardware.
    
    +++ Adds a new instruction in the reset-start handler to disable fast memory
    accesses in the reset-start handler.  When the target jtag clock is started
    out at 2 kHz during system clock initialization, memory writes (i.e.
    register write to enable external reset pin -- basically to RSTC_MR) are
    naturally slow and cause GDB keep-alive issues (refer to PATCH 2/2 for
    additional fixes).
    
    +++ Modifies the configuration file to use srst_only reset action. The
    reset-start/reset-init handler split also now allows the correct behavior to
    be used in the configuration file (previously had to use both SRST and TRST
    even though only SRST is actually used and connected on the evaluation
    board).
    
    +++ Adds external NandFlash configuration support to take advantage of flash
    driver added earlier.  Doesn't fix any bugs but adds functionality that was
    marked as TBD before and thrown in when I did other work on the
    configuration file.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
index c3eb952..b50e8c8 100644
--- a/tcl/board/at91sam9g20-ek.cfg
+++ b/tcl/board/at91sam9g20-ek.cfg
@@ -13,16 +13,15 @@
 # the AT91SAM9260 and shares the same tap ID as it.
 
 set _CHIPNAME at91sam9g20
+set _FLASHTYPE nandflash_cs3
 set _ENDIAN little
 set _CPUTAPID 0x0792603f
 
-# Set reset type.  Note that the AT91SAM9G20-EK board has the trst signal disconnected.  In theory this script
-# therefore should require "srst_only".  With some J-Link debuggers at least, "srst_only" causes a temporary USB
-# communication fault.  This appears to be more likely attributed to an internal proprietary firmware quirk inside the
-# dongle itself.  Using "trst_and_srst" works fine, however.  So if you can't beat them -- join them.  If you are using
-# something other the a J-Link dongle you may be able to change this back to "srst_only".
+# Set reset type.  Note that the AT91SAM9G20-EK board has the trst signal disconnected.  Therefore
+# the reset needs to be configured for "srst_only".  If for some reason, a zero-ohm jumper is
+# added to the board to connect the trst signal, then this parameter may need to be changed.
 
-reset_config trst_and_srst
+reset_config srst_only
 
 # Set up the CPU and generate a new jtag tap for AT91SAM9G20.
 
@@ -55,10 +54,16 @@ $_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x4000 -work-a
 # an event handler where these special activities can take place.
 
 scan_chain
-$_TARGETNAME configure -event reset-init {at91sam9g20_init}
+$_TARGETNAME configure -event reset-init {at91sam9g20_reset_init}
+$_TARGETNAME configure -event reset-start {at91sam9g20_reset_start}
 
 # NandFlash configuration and definition
-# Future TBD
+
+nand device nandflash_cs3 at91sam9 $_TARGETNAME 0x40000000 0xfffffe800
+at91sam9 cle 0 22
+at91sam9 ale 0 21
+at91sam9 rdy_busy 0 0xfffff800 13
+at91sam9 ce 0 0xfffff800 14
 
 proc read_register {register} {
         set result ""
@@ -66,7 +71,22 @@ proc read_register {register} {
         return $result(0)
 }
 
-proc at91sam9g20_init { } {
+proc at91sam9g20_reset_start { } {
+
+	# Make sure that the the jtag is running slow, since there are a number of different ways the board
+	# can be configured coming into this state that can cause communication problems with the jtag
+	# adapter.  Also since this call can be made following a "reset init" where fast memory accesses
+	# are enabled, need to temporarily shut this down so that the RSTC_MR register can be written at slower
+	# jtag speed without causing GDB keep alive problem.
+
+	arm7_9 fast_memory_access disable
+	adapter_khz 2                   # Slow-speed oscillator enabled at reset, so run jtag speed slow.
+	halt                            # Make sure processor is halted, or error will result in following steps.
+	wait_halt 10000
+	mww 0xfffffd08 0xa5000501       # RSTC_MR : enable user reset.
+}
+
+proc at91sam9g20_reset_init { } {
 
 	# At reset AT91SAM9G20 chip runs on slow clock (32.768 kHz).  To shift over to a normal clock requires
 	# a number of steps that must be carefully performed.  The process outline below follows the
@@ -77,9 +97,6 @@ proc at91sam9g20_init { } {
 	# means the master clock (MCLK) must be at or below 133 MHz or timing errors will occur.  The processor
 	# core can operate up to 400 MHz and therefore PCLK must be at or below this to function properly.
 
-	adapter_khz 2			# Slow-speed oscillator enabled at reset, so run jtag speed slow.
-	halt				# Make sure processor is halted, or error will result in following steps.
-	mww 0xfffffd08 0xa5000501	# RSTC_MR : enable user reset.
 	mww 0xfffffd44 0x00008000	# WDT_MR : disable watchdog.
 
 	# Enable the main 18.432 MHz oscillator in CKGR_MOR register.
@@ -114,9 +131,10 @@ proc at91sam9g20_init { } {
 
 	adapter_khz 0
 
-	# Enable faster DCC downloads.
+	# Enable faster DCC downloads and memory accesses.
 
 	arm7_9 dcc_downloads enable
+	arm7_9 fast_memory_access enable
 
 	# To be able to use external SDRAM, several peripheral configuration registers must
 	# be modified.  The first change is made to PIO_ASR to select peripheral functions
@@ -134,16 +152,34 @@ proc at91sam9g20_init { } {
 
 	# The AT91SAM9G20-EK evaluation board has built-in NandFlash.  The exact physical timing characteristics
 	# for the memory type used on the current board (MT29F2G08AACWP) can be established by setting
-	# four registers in order:  SMC_SETUP3, SMC_PULSE3, SMC_CYCLE3, and SMC_MODE3.
-
-	mww 0xffffec30 0x00020002
-	mww 0xffffec34 0x04040404
-	mww 0xffffec38 0x00070007
-	mww 0xffffec3c 0x00030003
-
-	# Identify NandFlash bank 0.  Disabled at the moment because a memory driver is not yet complete.
-
-#	nand probe 0
+	# a number of registers.  The first step involves setting up the general I/O pins on the processor
+	# to be able to interface and support the external memory.
+
+	mww 0xfffffc10 0x00000010	# PMC_PCER : enable PIOC clock
+	mww 0xfffff800 0x00006000	# PIOC_PER : enable PIO function for 13(RDY/~BSY) and 14(~CS)
+	mww 0xfffff810 0x00004000	# PIOC_OER : enable output on 14
+	mww 0xfffff814 0x00002000	# PIOC_ODR : disable output on 13
+    	mww 0xfffff830 0x00004000	# PIOC_SODR : set 14 to disable NAND
+
+	# The exact physical timing characteristics for the memory type used on the current board
+	# (MT29F2G08AACWP) can be established by setting four registers in order:  SMC_SETUP3,
+	# SMC_PULSE3, SMC_CYCLE3, and SMC_MODE3.  Computing the exact values of these registers
+	# is a little tedious to do here.  If you have questions about how to do this, Atmel has
+	# a decent application note #6255B that covers this process. 
+
+	mww 0xffffec30 0x00020002	# SMC_SETUP3 : 2 clock cycle setup for NRD and NWE
+	mww 0xffffec34 0x04040404	# SMC_PULSE3 : 4 clock cycle pulse for all signals
+	mww 0xffffec38 0x00070006	# SMC_CYCLE3 : 7 clock cycle NRD and 6 NWE cycle
+	mww 0xffffec3C 0x00020003	# SMC_MODE3 : NRD and NWE control, no NWAIT, 8-bit DBW, 
+   
+	mww 0xffffe800 0x00000001	# ECC_CR : reset the ECC parity registers
+	mww 0xffffe804 0x00000002	# ECC_MR : page size is 2112 words (word is 8 bits)
+
+	# Identify NandFlash bank 0.
+
+	nand probe nandflash_cs3
+
+	# The AT91SAM9G20-EK evaluation board has build-in serial data flash also.
 
 	# Now setup SDRAM.  This is tricky and configuration is very important for reliability!  The current calculations
 	# are based on 2 x Micron MT48LC16M16A2-75 memory (4 M x 16 bit x 4 banks).  If you use this file as a reference

commit b80d0501b66002cba1b3bc97a027d4f79932f20d
Author: Gary Carlson <gcarlson at carlson-minot.com>
Date:   Tue May 18 20:59:00 2010 -0700

    target: slow targets could cause GDB to time out
    
    This second half of the patch is proposed to clean up some GDB keep alive
    issues on arm7_9 targets that start up with very slow clocks.  If an attempt
    is made to write to key registers on the processor with a slow jtag speed,
    GDB timeout warnings appear on the console (at least mine) when "reset halt"
    or "reset init" commands are issued from the gdb client:
    
    *** BEFORE PATCH ***
    
    (gdb) monitor reset init
    fast memory access is disabled
    2 kHz
    keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not
    sent! (1026). Workaround: increase "set remotetimeout" in GDB
    JTAG tap: at91sam9g20.cpu tap/device found: 0x0792603f (mfg: 0x01f, part:
    0x7926, ver: 0x0)
    target state: halted
    target halted in ARM state due to breakpoint, current mode: Supervisor
    cpsr: 0x000000d3 pc: 0x00000000
    MMU: disabled, D-Cache: disabled, I-Cache: disabled
    keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not
    sent! (1027). Workaround: increase "set remotetimeout" in GDB
    keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not
    sent! (1006). Workaround: increase "set remotetimeout" in GDB
    keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not
    sent! (1006). Workaround: increase "set remotetimeout" in GDB
    keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not
    sent! (1006). Workaround: increase "set remotetimeout" in GDB
    keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not
    sent! (1004). Workaround: increase "set remotetimeout" in GDB
    RCLK - adaptive
    dcc downloads are enabled
    fast memory access is enabled
    NAND flash device 'NAND 256MiB 3,3V 8-bit' found
    (gdb)
    
    I added additional keep alive steps in areas that troubleshooting revealed
    were causing problems.  I only did this however for non-fast write memory
    accesses.  I don't think most people would be using fast memory accesses to
    write to memory when the jtag and system clocks are slow anyway.
    
    If you disagree with my feeling, think there is a more elegant way to handle
    the problem, or think the patch will cause other unforeseen problems with
    other targets, let me know.  As you can see below, the patch does eliminate
    the problem on my development station and I suspect that it will benefit
    others.
    
    *** AFTER PATCH ***
    
    (gdb) monitor reset init
    fast memory access is disabled
    2 kHz
    JTAG tap: at91sam9g20.cpu tap/device found: 0x0792603f (mfg: 0x01f, part:
    0x7926, ver: 0x0)
    target state: halted
    target halted in ARM state due to breakpoint, current mode: Supervisor
    cpsr: 0x000000d3 pc: 0x00000000
    MMU: disabled, D-Cache: disabled, I-Cache: disabled
    RCLK - adaptive
    dcc downloads are enabled
    fast memory access is enabled
    NAND flash device 'NAND 256MiB 3,3V 8-bit' found
    (gdb)
    
    Gary Carlson
    
    Gary Carlson, MSEE
    Principal Engineer
    Carlson-Minot Inc.

diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index ac18b37..abe0c2f 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2463,7 +2463,20 @@ int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size,
 				if (arm7_9->fast_memory_access)
 					retval = arm7_9_execute_fast_sys_speed(target);
 				else
+				{
 					retval = arm7_9_execute_sys_speed(target);
+
+					/*
+					 * if memory writes are made when the clock is running slow
+					 * (i.e. 32 kHz) which is necessary in some scripts to reconfigure
+					 * processor operations after a "reset halt" or "reset init",
+					 * need to immediately stroke the keep alive or will end up with
+					 * gdb "keep alive not sent error message" problem.
+					 */
+
+					keep_alive();
+				}
+
 				if (retval != ERROR_OK)
 				{
 					return retval;
@@ -2499,7 +2512,20 @@ int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size,
 					if (arm7_9->fast_memory_access)
 						retval = arm7_9_execute_fast_sys_speed(target);
 					else
+					{
 						retval = arm7_9_execute_sys_speed(target);
+
+	                                        /*
+        	                                 * if memory writes are made when the clock is running slow
+                	                         * (i.e. 32 kHz) which is necessary in some scripts to reconfigure
+                        	                 * processor operations after a "reset halt" or "reset init",
+                                	         * need to immediately stroke the keep alive or will end up with
+                                	         * gdb "keep alive not sent error message" problem.
+                                        	 */     
+
+                                      		keep_alive();
+					}
+
 					if (retval != ERROR_OK)
 					{
 						return retval;
@@ -2534,7 +2560,20 @@ int arm7_9_write_memory(struct target *target, uint32_t address, uint32_t size,
 					if (arm7_9->fast_memory_access)
 						retval = arm7_9_execute_fast_sys_speed(target);
 					else
-						retval = arm7_9_execute_sys_speed(target);
+                                        {
+                                                retval = arm7_9_execute_sys_speed(target);
+
+                                                /*
+                                                 * if memory writes are made when the clock is running slow
+                                                 * (i.e. 32 kHz) which is necessary in some scripts to reconfigure
+                                                 * processor operations after a "reset halt" or "reset init",
+                                                 * need to immediately stroke the keep alive or will end up with
+                                                 * gdb "keep alive not sent error message" problem.
+                                                 */
+
+                                                keep_alive();
+                                        }
+
 					if (retval != ERROR_OK)
 					{
 						return retval;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm7_9_common.c   |   41 ++++++++++++++++++++-
 tcl/board/at91sam9g20-ek.cfg |   82 ++++++++++++++++++++++++++++++------------
 2 files changed, 99 insertions(+), 24 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu May 20 08:29:21 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 20 May 2010 06:29:21 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-257-gf40faeb
Message-ID: <E1OEzG1-0006Jn-H5@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f40faeb349e417e566bf100aa08a9246501a82c5 (commit)
      from  8465e9944291a03a216fa15e0d7ed6eb9d44ba92 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f40faeb349e417e566bf100aa08a9246501a82c5
Author: gcembed <gcembed at gmail.com>
Date:   Thu May 20 08:25:09 2010 +0200

    nand : Add Freescale iMX27 nand flash controller support
    
    This patch add support of iMX27 nand flash controller. This is based on
    driver for imx31 nand flash controller.
    OOB functionality is not fully working. As in mx31 controller, mx2 NFC
    has a bug that swap two bytes between SPARE and MAIN buffer.
    I used this driver for several months and no problems appear.

diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index a495dfd..259a9cb 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -18,6 +18,7 @@ NAND_DRIVERS = \
 	nonce.c \
 	davinci.c \
 	lpc3180.c \
+	mx2.c \
 	mx3.c \
 	orion.c \
 	s3c24xx.c \
@@ -35,6 +36,7 @@ noinst_HEADERS = \
 	fileio.h \
 	imp.h \
 	lpc3180.h \
+	mx2.h \
 	mx3.h \
 	s3c24xx.h \
 	s3c24xx_regs.h
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
index 1c28dbc..597d78a 100644
--- a/src/flash/nand/driver.c
+++ b/src/flash/nand/driver.c
@@ -37,6 +37,7 @@ extern struct nand_flash_controller s3c2412_nand_controller;
 extern struct nand_flash_controller s3c2440_nand_controller;
 extern struct nand_flash_controller s3c2443_nand_controller;
 extern struct nand_flash_controller s3c6400_nand_controller;
+extern struct nand_flash_controller imx27_nand_flash_controller;
 extern struct nand_flash_controller imx31_nand_flash_controller;
 extern struct nand_flash_controller at91sam9_nand_controller;
 
@@ -53,6 +54,7 @@ static struct nand_flash_controller *nand_flash_controllers[] =
 	&s3c2440_nand_controller,
 	&s3c2443_nand_controller,
 	&s3c6400_nand_controller,
+	&imx27_nand_flash_controller,
 	&imx31_nand_flash_controller,
 	&at91sam9_nand_controller,
 /*	&boundary_scan_nand_controller, */
diff --git a/src/flash/nand/mx2.c b/src/flash/nand/mx2.c
new file mode 100644
index 0000000..83e1cb1
--- /dev/null
+++ b/src/flash/nand/mx2.c
@@ -0,0 +1,776 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Alexei Babich                                   *
+ *   Rezonans plc., Chelyabinsk, Russia                                    *
+ *   impatt at mail.ru                                                        *
+ *                                                                         *
+ *   Copyright (C) 2010 by Gaetan CARLIER                                  *
+ *   Trump s.a., Belgium                                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/*
+ * Freescale iMX2* OpenOCD NAND Flash controller support.
+ * based on Freescale iMX3* OpenOCD NAND Flash controller support.
+ */
+
+/*
+ * driver tested with Samsung K9F2G08UXA and Numonyx/ST NAND02G-B2D @imx27
+ * tested "nand probe #", "nand erase # 0 #", "nand dump # file 0 #", 
+ * "nand write # file 0", "nand verify"
+ *
+ * get_next_halfword_from_sram_buffer() not tested
+ * !! all function only tested with 2k page nand device; imx27_write_page
+ *    writes the 4 MAIN_BUFFER's and is not compatible with < 2k page
+ * !! oob must be be used due to NFS bug
+*/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+#include "mx2.h"
+#include <target/target.h>
+
+/* This permits to print (in LOG_INFO) how much bytes
+ * has been written after a page read or write.
+ * This is useful when OpenOCD is used with a graphical
+ * front-end to estimate progression of the global read/write
+ */
+#undef _MX2_PRINT_STAT
+//#define _MX2_PRINT_STAT
+
+static const char target_not_halted_err_msg[] =
+	"target must be halted to use mx2 NAND flash controller";
+static const char data_block_size_err_msg[] =
+	"minimal granularity is one half-word, %" PRId32 " is incorrect";
+static const char sram_buffer_bounds_err_msg[] =
+	"trying to access out of SRAM buffer bound (addr=0x%" PRIx32 ")";
+static const char get_status_register_err_msg[] = "can't get NAND status";
+static uint32_t in_sram_address;
+unsigned char sign_of_sequental_byte_read;
+
+static int initialize_nf_controller(struct nand_device *nand);
+static int get_next_byte_from_sram_buffer(struct target * target, uint8_t * value);
+static int get_next_halfword_from_sram_buffer(struct target * target,
+					       uint16_t * value);
+static int poll_for_complete_op(struct target * target, const char *text);
+static int validate_target_state(struct nand_device *nand);
+static int do_data_output(struct nand_device *nand);
+
+static int imx27_command(struct nand_device *nand, uint8_t command);
+static int imx27_address(struct nand_device *nand, uint8_t address);
+static int imx27_controller_ready(struct nand_device *nand, int tout);
+
+NAND_DEVICE_COMMAND_HANDLER(imx27_nand_device_command)
+{
+	struct mx2_nf_controller *mx2_nf_info;
+	int hwecc_needed;
+	int x;
+	mx2_nf_info = malloc(sizeof(struct mx2_nf_controller));
+	if (mx2_nf_info == NULL) {
+		LOG_ERROR("no memory for nand controller");
+		return ERROR_FAIL;
+	}
+
+	nand->controller_priv = mx2_nf_info;
+	mx2_nf_info->target = get_target(CMD_ARGV[1]);
+	if (mx2_nf_info->target == NULL) {
+		LOG_ERROR("target '%s' not defined", CMD_ARGV[1]);
+		return ERROR_FAIL;
+	}
+	if (CMD_ARGC < 3) {
+		LOG_ERROR("use \"nand device imx27 target noecc|hwecc\"");
+		return ERROR_FAIL;
+	}
+	/*
+	 * check hwecc requirements
+	 */
+
+	hwecc_needed = strcmp(CMD_ARGV[2], "hwecc");
+	if (hwecc_needed == 0) 
+		mx2_nf_info->flags.hw_ecc_enabled = 1;
+	else
+		mx2_nf_info->flags.hw_ecc_enabled = 0;
+
+	mx2_nf_info->optype = MX2_NF_DATAOUT_PAGE;
+	mx2_nf_info->fin = MX2_NF_FIN_NONE;
+	mx2_nf_info->flags.target_little_endian =
+	(mx2_nf_info->target->endianness == TARGET_LITTLE_ENDIAN);
+	/*
+	 * testing host endianess
+	 */
+	x = 1;
+	if (*(char *) &x == 1)
+		mx2_nf_info->flags.host_little_endian = 1;
+	else
+		mx2_nf_info->flags.host_little_endian = 0;
+	return ERROR_OK;
+}
+
+static int imx27_init(struct nand_device *nand)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+
+	int validate_target_result;
+	uint16_t buffsize_register_content;
+	uint32_t pcsr_register_content;
+	int retval;
+	uint16_t nand_status_content;
+	/*
+	 * validate target state
+	 */
+	validate_target_result = validate_target_state(nand);
+	if (validate_target_result != ERROR_OK)
+		return validate_target_result;
+
+	target_read_u16(target, MX2_NF_BUFSIZ, &buffsize_register_content);
+	mx2_nf_info->flags.one_kb_sram = !(buffsize_register_content & 0x000f);
+
+	target_read_u32(target, MX2_FMCR, &pcsr_register_content);
+	if (!nand->bus_width) {
+		/* bus_width not yet defined. Read it from MX2_FMCR */
+		nand->bus_width =
+		    (pcsr_register_content & MX2_FMCR_NF_16BIT_SEL) ? 16 : 8;
+	} else {
+		/* bus_width forced in soft. Sync it to MX2_FMCR */
+		pcsr_register_content |=
+		    ((nand->bus_width == 16) ? MX2_FMCR_NF_16BIT_SEL : 0x00000000);
+		target_write_u32(target, MX2_FMCR, pcsr_register_content);
+	}
+	if (nand->bus_width == 16)
+		LOG_DEBUG("MX2_NF : bus is 16-bit width");
+	else
+		LOG_DEBUG("MX2_NF : bus is 8-bit width");
+
+	if (!nand->page_size) {
+		nand->page_size =
+		    (pcsr_register_content & MX2_FMCR_NF_FMS) ? 2048 : 512;
+	} else {
+		pcsr_register_content |=
+		    ((nand->page_size == 2048) ? MX2_FMCR_NF_FMS : 0x00000000);
+		target_write_u32(target, MX2_FMCR, pcsr_register_content);
+	}
+	if (mx2_nf_info->flags.one_kb_sram && (nand->page_size == 2048)) {
+		LOG_ERROR("NAND controller have only 1 kb SRAM, so "
+		          "pagesize 2048 is incompatible with it");
+	} else {
+		LOG_DEBUG("MX2_NF : NAND controller can handle pagesize of 2048");
+	}
+
+	initialize_nf_controller(nand);
+
+	retval = ERROR_OK;
+	retval |= imx27_command(nand, NAND_CMD_STATUS);
+	retval |= imx27_address(nand, 0x00);
+	retval |= do_data_output(nand);
+	if (retval != ERROR_OK) {
+		LOG_ERROR(get_status_register_err_msg);
+		return ERROR_FAIL;
+	}
+	target_read_u16(target, MX2_NF_MAIN_BUFFER0, &nand_status_content);
+	if (!(nand_status_content & 0x0080)) {
+		LOG_INFO("NAND read-only");
+		mx2_nf_info->flags.nand_readonly = 1;
+	} else {
+		mx2_nf_info->flags.nand_readonly = 0;
+	}
+	return ERROR_OK;
+}
+
+static int imx27_read_data(struct nand_device *nand, void *data)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	int validate_target_result;
+	int try_data_output_from_nand_chip;
+	/*
+	 * validate target state
+	 */
+	validate_target_result = validate_target_state(nand);
+	if (validate_target_result != ERROR_OK)
+		return validate_target_result;
+
+	/*
+	 * get data from nand chip
+	 */
+	try_data_output_from_nand_chip = do_data_output(nand);
+	if (try_data_output_from_nand_chip != ERROR_OK) {
+		LOG_ERROR("imx27_read_data : read data failed : '%x'",
+		          try_data_output_from_nand_chip);
+		return try_data_output_from_nand_chip;
+	}
+
+	if (nand->bus_width == 16)
+	    get_next_halfword_from_sram_buffer(target, data);
+	else
+	    get_next_byte_from_sram_buffer(target, data);
+
+	return ERROR_OK;
+}
+
+static int imx27_write_data(struct nand_device *nand, uint16_t data)
+{
+	LOG_ERROR("write_data() not implemented");
+	return ERROR_NAND_OPERATION_FAILED;
+}
+
+static int imx27_nand_ready(struct nand_device *nand, int timeout)
+{
+	return imx27_controller_ready(nand, timeout);
+}
+
+static int imx27_reset(struct nand_device *nand)
+{
+	/*
+	 * validate target state
+	 */
+	int validate_target_result;
+	validate_target_result = validate_target_state(nand);
+	if (validate_target_result != ERROR_OK)
+	    return validate_target_result;
+	initialize_nf_controller(nand);
+	return ERROR_OK;
+}
+
+static int imx27_command(struct nand_device *nand, uint8_t command)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	int validate_target_result;
+	int poll_result;
+	/*
+	 * validate target state
+	 */
+	validate_target_result = validate_target_state(nand);
+	if (validate_target_result != ERROR_OK)
+		return validate_target_result;
+
+	switch(command) {
+	case NAND_CMD_READOOB:
+		command = NAND_CMD_READ0;
+		/* set read point for data_read() and read_block_data() to
+		 * spare area in SRAM buffer
+		 */
+		in_sram_address = MX2_NF_SPARE_BUFFER0;	
+		break;
+	case NAND_CMD_READ1:
+		command = NAND_CMD_READ0;
+		/*
+		 * offset == one half of page size
+		 */
+		in_sram_address =
+		    MX2_NF_MAIN_BUFFER0 + (nand->page_size >> 1);
+		break;
+	default:
+		in_sram_address = MX2_NF_MAIN_BUFFER0;
+		break;
+	}
+
+	target_write_u16(target, MX2_NF_FCMD, command);
+	/*
+	 * start command input operation (set MX2_NF_BIT_OP_DONE==0)
+	 */
+	target_write_u16(target, MX2_NF_CFG2, MX2_NF_BIT_OP_FCI);
+	poll_result = poll_for_complete_op(target, "command");
+	if (poll_result != ERROR_OK)
+		return poll_result;
+	/*
+	 * reset cursor to begin of the buffer
+	 */
+	sign_of_sequental_byte_read = 0;
+	/* Handle special read command and adjust NF_CFG2(FDO) */
+	switch(command) {
+	case NAND_CMD_READID:
+		mx2_nf_info->optype = MX2_NF_DATAOUT_NANDID;
+		mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+		break;
+	case NAND_CMD_STATUS:
+		mx2_nf_info->optype = MX2_NF_DATAOUT_NANDSTATUS;
+		mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+                target_write_u16 (target, MX2_NF_BUFADDR, 0);
+                in_sram_address = 0;
+		break;
+	case NAND_CMD_READ0:
+		mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+		mx2_nf_info->optype = MX2_NF_DATAOUT_PAGE;
+		break;
+	default:
+		/* Ohter command use the default 'One page data out' FDO */
+		mx2_nf_info->optype = MX2_NF_DATAOUT_PAGE;
+		break;
+	}
+	return ERROR_OK;
+}
+
+static int imx27_address(struct nand_device *nand, uint8_t address)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	int validate_target_result;
+	int poll_result;
+	/*
+	 * validate target state
+	 */
+	validate_target_result = validate_target_state(nand);
+	if (validate_target_result != ERROR_OK)
+		return validate_target_result;
+
+	target_write_u16(target, MX2_NF_FADDR, address);
+	/*
+	 * start address input operation (set MX2_NF_BIT_OP_DONE==0)
+	 */
+	target_write_u16(target, MX2_NF_CFG2, MX2_NF_BIT_OP_FAI);
+	poll_result = poll_for_complete_op(target, "address");
+	if (poll_result != ERROR_OK)
+		return poll_result;
+
+	return ERROR_OK;
+}
+
+static int imx27_controller_ready(struct nand_device *nand, int tout)
+{
+	uint16_t poll_complete_status;
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	int validate_target_result;
+
+	/*
+	 * validate target state
+	 */
+	validate_target_result = validate_target_state(nand);
+	if (validate_target_result != ERROR_OK)
+		return validate_target_result;
+
+	do {
+		target_read_u16(target, MX2_NF_CFG2, &poll_complete_status);
+		if (poll_complete_status & MX2_NF_BIT_OP_DONE)
+			return tout;
+
+		alive_sleep(1);
+	}
+	while (tout-- > 0);
+	return tout;
+}
+
+static int imx27_write_page(struct nand_device *nand, uint32_t page,
+			     uint8_t * data, uint32_t data_size, uint8_t * oob,
+			     uint32_t oob_size)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	int retval;
+	uint16_t nand_status_content;
+	uint16_t swap1, swap2, new_swap1;
+	int poll_result;
+	if (data_size % 2) {
+		LOG_ERROR(data_block_size_err_msg, data_size);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	if (oob_size % 2) {
+		LOG_ERROR(data_block_size_err_msg, oob_size);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	if (!data) {
+		LOG_ERROR("nothing to program");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	/*
+	 * validate target state
+	 */
+	retval = validate_target_state(nand);
+	if (retval != ERROR_OK)
+		return retval;
+
+	in_sram_address = MX2_NF_MAIN_BUFFER0;
+	sign_of_sequental_byte_read = 0;
+	retval = ERROR_OK;
+	retval |= imx27_command(nand, NAND_CMD_SEQIN);
+	retval |= imx27_address(nand, 0); //col
+	retval |= imx27_address(nand, 0); //col
+	retval |= imx27_address(nand, page & 0xff); //page address
+	retval |= imx27_address(nand, (page >> 8) & 0xff); //page address
+	retval |= imx27_address(nand, (page >> 16) & 0xff); //page address
+	
+	target_write_buffer(target, MX2_NF_MAIN_BUFFER0, data_size, data);
+	if (oob) {
+		if (mx2_nf_info->flags.hw_ecc_enabled) {
+			/*
+			 * part of spare block will be overrided by hardware
+			 * ECC generator
+			 */
+			LOG_DEBUG("part of spare block will be overrided "
+			          "by hardware ECC generator");
+		}
+		target_write_buffer(target, MX2_NF_SPARE_BUFFER0, oob_size,
+		                    oob);
+	}
+	//BI-swap -  work-around of imx27 NFC for NAND device with page == 2kb
+	target_read_u16(target, MX2_NF_MAIN_BUFFER3 + 464, &swap1);
+	if (oob) {
+		LOG_ERROR("Due to NFC Bug, oob is not correctly implemented "
+		          "in mx2 driver");
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	//target_read_u16 (target, MX2_NF_SPARE_BUFFER3 + 4, &swap2);
+	swap2 = 0xffff;  //Spare buffer unused forced to 0xffff
+        new_swap1 = (swap1 & 0xFF00) | (swap2 >> 8);
+        swap2 = (swap1 << 8) | (swap2 & 0xFF);
+
+	target_write_u16(target, MX2_NF_MAIN_BUFFER3 + 464, new_swap1);
+	target_write_u16(target, MX2_NF_SPARE_BUFFER3 + 4, swap2);
+	/*
+	 * start data input operation (set MX2_NF_BIT_OP_DONE==0)
+	 */
+	target_write_u16(target, MX2_NF_BUFADDR, 0);
+	target_write_u16(target, MX2_NF_CFG2, MX2_NF_BIT_OP_FDI);
+	poll_result = poll_for_complete_op(target, "data input");
+	if (poll_result != ERROR_OK)
+		return poll_result;
+	
+	target_write_u16(target, MX2_NF_BUFADDR, 1);
+	target_write_u16(target, MX2_NF_CFG2, MX2_NF_BIT_OP_FDI);
+	poll_result = poll_for_complete_op(target, "data input");
+	if (poll_result != ERROR_OK)
+		return poll_result;
+	
+	target_write_u16(target, MX2_NF_BUFADDR, 2);
+	target_write_u16(target, MX2_NF_CFG2, MX2_NF_BIT_OP_FDI);
+	poll_result = poll_for_complete_op(target, "data input");
+	if (poll_result != ERROR_OK)
+		return poll_result;
+	
+	target_write_u16(target, MX2_NF_BUFADDR, 3);
+	target_write_u16(target, MX2_NF_CFG2, MX2_NF_BIT_OP_FDI);
+	poll_result = poll_for_complete_op(target, "data input");
+	if (poll_result != ERROR_OK)
+		return poll_result;
+
+	retval |= imx27_command(nand, NAND_CMD_PAGEPROG);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/*
+	 * check status register
+	 */
+        retval = ERROR_OK;
+        retval |= imx27_command(nand, NAND_CMD_STATUS);
+        target_write_u16 (target, MX2_NF_BUFADDR, 0);
+        mx2_nf_info->optype = MX2_NF_DATAOUT_NANDSTATUS;
+        mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+        retval |= do_data_output(nand);
+        if (retval != ERROR_OK) {
+                LOG_ERROR (get_status_register_err_msg);
+                return retval;
+        }
+        target_read_u16 (target, MX2_NF_MAIN_BUFFER0, &nand_status_content);
+        if (nand_status_content & 0x0001) {
+                /*
+                 * page not correctly written
+                 */
+                return ERROR_NAND_OPERATION_FAILED;
+        }
+#ifdef _MX2_PRINT_STAT
+	LOG_INFO("%d bytes newly written", data_size);
+#endif
+	return ERROR_OK;
+}
+
+static int imx27_read_page(struct nand_device *nand, uint32_t page,
+			    uint8_t * data, uint32_t data_size, uint8_t * oob,
+			    uint32_t oob_size)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	int retval;
+	uint16_t swap1, swap2, new_swap1;
+	if (data_size % 2) {
+	    LOG_ERROR(data_block_size_err_msg, data_size);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+	if (oob_size % 2) {
+	    LOG_ERROR(data_block_size_err_msg, oob_size);
+	    return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	/*
+	 * validate target state
+	 */
+	retval = validate_target_state(nand);
+	if (retval != ERROR_OK) {
+		return retval;
+	}
+	/* Reset address_cycles before imx27_command ?? */
+	retval = ERROR_OK;
+	retval |= imx27_command(nand, NAND_CMD_READ0);
+
+	retval |= imx27_address(nand, 0); //col
+	retval |= imx27_address(nand, 0); //col
+	retval |= imx27_address(nand, page & 0xff); //page address
+	retval |= imx27_address(nand, (page >> 8) & 0xff); //page address
+	retval |= imx27_address(nand, (page >> 16) & 0xff); //page address
+	retval |= imx27_command(nand, NAND_CMD_READSTART);
+
+	target_write_u16(target, MX2_NF_BUFADDR, 0);
+	mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+	retval = do_data_output(nand);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MX2_NF : Error reading page 0");
+		return retval;
+	}
+	//Test nand page size to know how much MAIN_BUFFER must be written
+	target_write_u16(target, MX2_NF_BUFADDR, 1);
+	mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+	retval = do_data_output(nand);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MX2_NF : Error reading page 1");
+		return retval;
+	}
+	target_write_u16(target, MX2_NF_BUFADDR, 2);
+	mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+	retval = do_data_output(nand);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MX2_NF : Error reading page 2");
+		return retval;
+	}
+	target_write_u16(target, MX2_NF_BUFADDR, 3);
+	mx2_nf_info->fin = MX2_NF_FIN_DATAOUT;
+	retval = do_data_output(nand);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("MX2_NF : Error reading page 3");
+		return retval;
+	}
+	//BI-swap -  work-around of imx27 NFC for NAND device with page == 2k
+	target_read_u16(target, MX2_NF_MAIN_BUFFER3 + 464, &swap1);
+	target_read_u16(target, MX2_NF_SPARE_BUFFER3 + 4, &swap2);
+        new_swap1 = (swap1 & 0xFF00) | (swap2 >> 8);
+        swap2 = (swap1 << 8) | (swap2 & 0xFF);
+	target_write_u16(target, MX2_NF_MAIN_BUFFER3 + 464, new_swap1);
+	target_write_u16(target, MX2_NF_SPARE_BUFFER3 + 4, swap2);
+
+	if (data)
+		target_read_buffer(target, MX2_NF_MAIN_BUFFER0, data_size, data);
+	if (oob)
+		target_read_buffer(target, MX2_NF_SPARE_BUFFER0, oob_size,
+		                    oob);
+#ifdef _MX2_PRINT_STAT
+	if (data_size > 0) {
+		/* When Operation Status is read (when page is erased),
+		 * this function is used but data_size is null.
+		 */
+		LOG_INFO("%d bytes newly read", data_size);
+	}
+#endif
+	return ERROR_OK;
+}
+
+static int initialize_nf_controller(struct nand_device *nand)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	uint16_t work_mode;
+	uint16_t temp;
+	/*
+	 * resets NAND flash controller in zero time ? I dont know.
+	 */
+	target_write_u16(target, MX2_NF_CFG1, MX2_NF_BIT_RESET_EN);
+	work_mode = MX2_NF_BIT_INT_DIS;	/* disable interrupt */
+	if (target->endianness == TARGET_BIG_ENDIAN) {
+		LOG_DEBUG("MX2_NF : work in Big Endian mode");
+		work_mode |= MX2_NF_BIT_BE_EN;
+	} else {
+		LOG_DEBUG("MX2_NF : work in Little Endian mode");
+	}
+	if (mx2_nf_info->flags.hw_ecc_enabled) {
+		LOG_DEBUG("MX2_NF : work with ECC mode");
+		work_mode |= MX2_NF_BIT_ECC_EN;
+	} else {
+		LOG_DEBUG("MX2_NF : work without ECC mode");
+	}
+	target_write_u16(target, MX2_NF_CFG1, work_mode);
+	/*
+	 * unlock SRAM buffer for write; 2 mean "Unlock", other values means "Lock"
+	 */
+	target_write_u16(target, MX2_NF_BUFCFG, 2);
+	target_read_u16(target, MX2_NF_FWP, &temp);
+	if ((temp & 0x0007) == 1) {
+		LOG_ERROR("NAND flash is tight-locked, reset needed");
+		return ERROR_FAIL;
+	}
+
+	/*
+	 * unlock NAND flash for write
+	 */
+	target_write_u16(target, MX2_NF_FWP, 4);
+	target_write_u16(target, MX2_NF_LOCKSTART, 0x0000);
+	target_write_u16(target, MX2_NF_LOCKEND, 0xFFFF);
+	/*
+	 * 0x0000 means that first SRAM buffer @0xD800_0000 will be used
+	 */
+	target_write_u16(target, MX2_NF_BUFADDR, 0x0000);
+	/*
+	 * address of SRAM buffer
+	 */
+	in_sram_address = MX2_NF_MAIN_BUFFER0;
+	sign_of_sequental_byte_read = 0;
+	return ERROR_OK;
+}
+
+static int get_next_byte_from_sram_buffer(struct target * target, uint8_t * value)
+{
+	static uint8_t even_byte = 0;
+	uint16_t temp;
+	/*
+	 * host-big_endian ??
+	 */
+	if (sign_of_sequental_byte_read == 0)
+		even_byte = 0;
+	
+	if (in_sram_address > MX2_NF_LAST_BUFFER_ADDR) {
+		LOG_ERROR(sram_buffer_bounds_err_msg, in_sram_address);
+		*value = 0;
+		sign_of_sequental_byte_read = 0;
+		even_byte = 0;
+		return ERROR_NAND_OPERATION_FAILED;
+	} else {
+		target_read_u16(target, in_sram_address, &temp);
+		if (even_byte) {
+			*value = temp >> 8;
+			even_byte = 0;
+			in_sram_address += 2;
+		} else {
+			*value = temp & 0xff;
+			even_byte = 1;
+		}
+	}
+	sign_of_sequental_byte_read = 1;
+	return ERROR_OK;
+}
+
+static int get_next_halfword_from_sram_buffer(struct target * target,
+					       uint16_t * value)
+{
+	if (in_sram_address > MX2_NF_LAST_BUFFER_ADDR) {
+		LOG_ERROR(sram_buffer_bounds_err_msg, in_sram_address);
+		*value = 0;
+		return ERROR_NAND_OPERATION_FAILED;
+	} else {
+		target_read_u16(target, in_sram_address, value);
+		in_sram_address += 2;
+	}
+	return ERROR_OK;
+}
+
+static int poll_for_complete_op(struct target * target, const char *text)
+{
+	uint16_t poll_complete_status;
+	for (int poll_cycle_count = 0; poll_cycle_count < 100; poll_cycle_count++) {
+		target_read_u16(target, MX2_NF_CFG2, &poll_complete_status);
+		if (poll_complete_status & MX2_NF_BIT_OP_DONE)
+			break;
+
+		usleep(10);
+	}
+	if (!(poll_complete_status & MX2_NF_BIT_OP_DONE)) {
+		LOG_ERROR("%s sending timeout", text);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	return ERROR_OK;
+}
+
+static int validate_target_state(struct nand_device *nand)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR(target_not_halted_err_msg);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (mx2_nf_info->flags.target_little_endian != 
+	     (target->endianness == TARGET_LITTLE_ENDIAN)) {
+		/*
+		 * endianness changed after NAND controller probed
+		 */
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	return ERROR_OK;
+}
+
+static int do_data_output(struct nand_device *nand)
+{
+	struct mx2_nf_controller *mx2_nf_info = nand->controller_priv;
+	struct target *target = mx2_nf_info->target;
+	int poll_result;
+	uint16_t ecc_status;
+	switch(mx2_nf_info->fin) {
+	case MX2_NF_FIN_DATAOUT:
+		/*
+		 * start data output operation (set MX2_NF_BIT_OP_DONE==0)
+		 */
+		target_write_u16(target, MX2_NF_CFG2, MX2_NF_BIT_DATAOUT_TYPE(mx2_nf_info->optype));
+		poll_result = poll_for_complete_op(target, "data output");
+		if (poll_result != ERROR_OK)
+			return poll_result;
+
+		mx2_nf_info->fin = MX2_NF_FIN_NONE;
+		/*
+		 * ECC stuff
+		 */
+		if ((mx2_nf_info->optype == MX2_NF_DATAOUT_PAGE) && mx2_nf_info->flags.hw_ecc_enabled) {
+			target_read_u16(target, MX2_NF_ECCSTATUS, &ecc_status);
+			switch(ecc_status & 0x000c) {
+			case 1 << 2:
+				LOG_INFO("main area readed with 1 (correctable) error");
+				break;
+			case 2 << 2:
+				LOG_INFO("main area readed with more than 1 (incorrectable) error");
+				return ERROR_NAND_OPERATION_FAILED;
+		    		break;
+			}
+			switch(ecc_status & 0x0003) {
+			case 1:
+				LOG_INFO("spare area readed with 1 (correctable) error");
+				break;
+			case 2:
+				LOG_INFO("main area readed with more than 1 (incorrectable) error");
+				return ERROR_NAND_OPERATION_FAILED;
+				break;
+			}
+		}
+		break;
+	case MX2_NF_FIN_NONE:
+		break;
+	}
+	return ERROR_OK;
+}
+
+struct nand_flash_controller imx27_nand_flash_controller = {
+	.name			= "imx27",
+	.nand_device_command 	= &imx27_nand_device_command,
+	.init			= &imx27_init,
+	.reset			= &imx27_reset,
+	.command		= &imx27_command,
+	.address		= &imx27_address,
+	.write_data		= &imx27_write_data,
+	.read_data		= &imx27_read_data,
+	.write_page		= &imx27_write_page,
+	.read_page		= &imx27_read_page,
+	.controller_ready	= &imx27_controller_ready,
+	.nand_ready		= &imx27_nand_ready,
+};
diff --git a/src/flash/nand/mx2.h b/src/flash/nand/mx2.h
new file mode 100644
index 0000000..5d0b942
--- /dev/null
+++ b/src/flash/nand/mx2.h
@@ -0,0 +1,120 @@
+
+/***************************************************************************
+ *   Copyright (C) 2009 by Alexei Babich                                   *
+ *   Rezonans plc., Chelyabinsk, Russia                                    *
+ *   impatt at mail.ru                                                        *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/*
+ * Freescale iMX2* OpenOCD NAND Flash controller support.
+ * based on Freescale iMX3* OpenOCD NAND Flash controller support.
+ *
+ * Many thanks to Ben Dooks for writing s3c24xx driver.
+ */
+
+#define		MX2_NF_BASE_ADDR		0xd8000000
+#define		MX2_NF_BUFSIZ			(MX2_NF_BASE_ADDR + 0xe00)
+#define		MX2_NF_BUFADDR			(MX2_NF_BASE_ADDR + 0xe04)
+#define		MX2_NF_FADDR			(MX2_NF_BASE_ADDR + 0xe06)
+#define		MX2_NF_FCMD				(MX2_NF_BASE_ADDR + 0xe08)
+#define		MX2_NF_BUFCFG			(MX2_NF_BASE_ADDR + 0xe0a)
+#define		MX2_NF_ECCSTATUS			(MX2_NF_BASE_ADDR + 0xe0c)
+#define		MX2_NF_ECCMAINPOS			(MX2_NF_BASE_ADDR + 0xe0e)
+#define		MX2_NF_ECCSPAREPOS			(MX2_NF_BASE_ADDR + 0xe10)
+#define		MX2_NF_FWP			(MX2_NF_BASE_ADDR + 0xe12)
+#define		MX2_NF_LOCKSTART			(MX2_NF_BASE_ADDR + 0xe14)
+#define		MX2_NF_LOCKEND			(MX2_NF_BASE_ADDR + 0xe16)
+#define		MX2_NF_FWPSTATUS			(MX2_NF_BASE_ADDR + 0xe18)
+ /*
+  * all bits not marked as self-clearing bit
+  */
+#define		MX2_NF_CFG1			(MX2_NF_BASE_ADDR + 0xe1a)
+#define		MX2_NF_CFG2			(MX2_NF_BASE_ADDR + 0xe1c)
+
+#define		MX2_NF_MAIN_BUFFER0		(MX2_NF_BASE_ADDR + 0x0000)
+#define		MX2_NF_MAIN_BUFFER1		(MX2_NF_BASE_ADDR + 0x0200)
+#define		MX2_NF_MAIN_BUFFER2		(MX2_NF_BASE_ADDR + 0x0400)
+#define		MX2_NF_MAIN_BUFFER3		(MX2_NF_BASE_ADDR + 0x0600)
+#define		MX2_NF_SPARE_BUFFER0	(MX2_NF_BASE_ADDR + 0x0800)
+#define		MX2_NF_SPARE_BUFFER1	(MX2_NF_BASE_ADDR + 0x0810)
+#define		MX2_NF_SPARE_BUFFER2	(MX2_NF_BASE_ADDR + 0x0820)
+#define		MX2_NF_SPARE_BUFFER3	(MX2_NF_BASE_ADDR + 0x0830)
+#define		MX2_NF_MAIN_BUFFER_LEN	512
+#define		MX2_NF_SPARE_BUFFER_LEN	16
+#define		MX2_NF_LAST_BUFFER_ADDR	((MX2_NF_SPARE_BUFFER3) + MX2_NF_SPARE_BUFFER_LEN - 2)
+
+/* bits in MX2_NF_CFG1 register */
+#define		MX2_NF_BIT_SPARE_ONLY_EN	(1<<2)
+#define		MX2_NF_BIT_ECC_EN			(1<<3)
+#define		MX2_NF_BIT_INT_DIS			(1<<4)
+#define		MX2_NF_BIT_BE_EN			(1<<5)
+#define		MX2_NF_BIT_RESET_EN			(1<<6)
+#define		MX2_NF_BIT_FORCE_CE			(1<<7)
+
+/* bits in MX2_NF_CFG2 register */
+
+/*Flash Command Input*/
+#define		MX2_NF_BIT_OP_FCI			(1<<0)
+ /*
+  * Flash Address Input
+  */
+#define		MX2_NF_BIT_OP_FAI			(1<<1)
+ /*
+  * Flash Data Input
+  */
+#define		MX2_NF_BIT_OP_FDI			(1<<2)
+
+/* see "enum mx_dataout_type" below */
+#define		MX2_NF_BIT_DATAOUT_TYPE(x)	((x)<<3)
+#define		MX2_NF_BIT_OP_DONE			(1<<15)
+
+#define		MX2_CCM_CGR2		0x53f80028
+#define		MX2_GPR				0x43fac008
+//#define		MX2_PCSR			0x53f8000c
+#define		MX2_FMCR			0x10027814
+#define		MX2_FMCR_NF_16BIT_SEL		(1<<4)
+#define		MX2_FMCR_NF_FMS			(1<<5)
+
+enum mx_dataout_type
+{
+	MX2_NF_DATAOUT_PAGE = 1,
+	MX2_NF_DATAOUT_NANDID = 2,
+	MX2_NF_DATAOUT_NANDSTATUS = 4,
+};
+enum mx_nf_finalize_action
+{
+	MX2_NF_FIN_NONE,
+	MX2_NF_FIN_DATAOUT,
+};
+
+struct mx2_nf_flags
+{
+	unsigned host_little_endian:1;
+	unsigned target_little_endian:1;
+	unsigned nand_readonly:1;
+	unsigned one_kb_sram:1;
+	unsigned hw_ecc_enabled:1;
+};
+
+struct mx2_nf_controller
+{
+	struct target *target;
+	enum mx_dataout_type optype;
+	enum mx_nf_finalize_action fin;
+	struct mx2_nf_flags flags;
+};

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nand/Makefile.am |    2 +
 src/flash/nand/driver.c    |    2 +
 src/flash/nand/mx2.c       |  776 ++++++++++++++++++++++++++++++++++++++++++++
 src/flash/nand/mx2.h       |  120 +++++++
 4 files changed, 900 insertions(+), 0 deletions(-)
 create mode 100644 src/flash/nand/mx2.c
 create mode 100644 src/flash/nand/mx2.h


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri May 21 07:32:06 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 21 May 2010 05:32:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-258-g72ba8ec
Message-ID: <E1OFKqA-0003Jj-BB@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  72ba8ec90e42a3fc4470e7e0d1c0f8b1d060529a (commit)
      from  f40faeb349e417e566bf100aa08a9246501a82c5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 72ba8ec90e42a3fc4470e7e0d1c0f8b1d060529a
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Fri May 21 12:34:46 2010 +0900

    board: dm355evm.cfg SDTIMR0/1 minor naming fix
    
    Register name fix; ref. TI document sprueh7d
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/dm355evm.cfg b/tcl/board/dm355evm.cfg
index db47b8d..02c4c86 100644
--- a/tcl/board/dm355evm.cfg
+++ b/tcl/board/dm355evm.cfg
@@ -117,7 +117,7 @@ proc dm355evm_init {} {
 	mmw [expr $addr + 0x08] 0x00800000 0
 	mmw [expr $addr + 0x08] 0x0013c632 0x03870fff
 
-	# SDTIMR, SDTIMR2
+	# SDTIMR0, SDTIMR1
 	mww [expr $addr + 0x10] 0x2a923249
 	mww [expr $addr + 0x14] 0x4c17c763
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/dm355evm.cfg |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri May 21 12:50:38 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri, 21 May 2010 10:50:38 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-260-g82ef847
Message-ID: <E1OFPoN-0007a4-W7@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  82ef8472bf6986d09f595dbea151413502b42280 (commit)
       via  c0cdb7c63189edf0d96a1b0242d80c94532b30e7 (commit)
      from  72ba8ec90e42a3fc4470e7e0d1c0f8b1d060529a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 82ef8472bf6986d09f595dbea151413502b42280
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri May 21 11:45:40 2010 +0100

    cfg: update stm32 performance stick config
    
     - As this is a complete unit, including jtag we might as welli nclude
    the jtag cfg.
     - Add missing id for the str750 that is also in the jtag chain.
     - Reduce jtag startup speed to 500kHz.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/board/hitex_stm32-performancestick.cfg b/tcl/board/hitex_stm32-performancestick.cfg
index 509f98a..515f7e0 100644
--- a/tcl/board/hitex_stm32-performancestick.cfg
+++ b/tcl/board/hitex_stm32-performancestick.cfg
@@ -1,9 +1,16 @@
 # Hitex stm32 performance stick
 
+reset_config trst_and_srst
+
+source [find interface/stm32-stick.cfg]
+
 set  CHIPNAME stm32_hitex
 source [find target/stm32.cfg]
 
 # configure str750 connected to jtag chain
 # FIXME -- source [find target/str750.cfg] after cleaning that up
-jtag newtap $_CHIPNAME unknown -irlen 4 -ircapture 0x1 -irmask 0x0f
+jtag newtap str750 cpu -irlen 4 -ircapture 0x1 -irmask 0x0f -expected-id 0x4f1f0041
+
+# for some reason this board like to startup @ 500kHz
+adapter_khz 500
 

commit c0cdb7c63189edf0d96a1b0242d80c94532b30e7
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Fri May 21 11:43:17 2010 +0100

    arm_adi_v5: correct ahbap_debugport_init mem-ap id (bug #23)
    
    We request a id register read at the end of ahbap_debugport_init
    but we never actually run the queue. In some cases this causes a
    segfault.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 8b18fa3..8f43f78 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -967,6 +967,9 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &idreg);
 	retval = dap_queue_ap_read(dap, AP_REG_BASE, &romaddr);
 
+	if ((retval = dap_run(dap)) != ERROR_OK)
+		return retval;
+
 	LOG_DEBUG("MEM-AP #%" PRId32 " ID Register 0x%" PRIx32
 		", Debug ROM Address 0x%" PRIx32,
 		dap->apsel, idreg, romaddr);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c                    |    3 +++
 tcl/board/hitex_stm32-performancestick.cfg |    9 ++++++++-
 2 files changed, 11 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri May 21 14:09:05 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 21 May 2010 12:09:05 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-261-g2e1eaaa
Message-ID: <E1OFR2I-0003SO-SZ@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  2e1eaaae35e506efe6190817876b1078885a83d7 (commit)
      from  82ef8472bf6986d09f595dbea151413502b42280 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 2e1eaaae35e506efe6190817876b1078885a83d7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri May 21 13:56:05 2010 +0200

    at91sam9260: use RCLK
    
    It might be possible to get this target going without
    RCLK, but it would require more careful analysis and
    usage of the reset events.
    
    Enable fast memory accesses.
    
    Tested on an at91sam9260 custom board w/external DRAM
    and flash.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
index d2bf66f..535ae0f 100644
--- a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
+++ b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
@@ -1,8 +1,4 @@
-
-
-
-adapter_khz 4
-
+jtag_rclk 4
 
 ######################################
 # Target:    Atmel AT91SAM9260
@@ -44,26 +40,29 @@ jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CP
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
 
-$_TARGETNAME invoke-event halted
-
 # Internal sram1 memory
 $_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x1000 -work-area-backup 1
 
 scan_chain
-$_TARGETNAME configure -event reset-deassert-post {at91sam_init}
+$_TARGETNAME configure -event reset-start {
+	# at reset chip runs at 32khz
+	jtag_rclk 8
+}
 
+$_TARGETNAME configure -event reset-init {at91sam_init}
 
 # Flash configuration
 #flash bank <name> cfi <base> <size> <chip width> <bus width> <target>
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME cfi 0x10000000 0x01000000 2 2 $_TARGETNAME
 
+# Faster memory downloads. This is disabled automatically during
+# reset init since all reset init sequences are too short for
+# fast memory access
+arm7_9 dcc_downloads enable     
+arm7_9 fast_memory_access enable
 
 proc at91sam_init { } {
-
-	# at reset chip runs at 32khz
-	adapter_khz 8
-	halt
 	mww 0xfffffd08 0xa5000501         # RSTC_MR : enable user reset
 	mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
 
@@ -79,16 +78,13 @@ proc at91sam_init { } {
 	sleep 10                          # wait 10 ms
 
 	# Now run at anything fast... ie: 10mhz!
-	adapter_khz 10000                    # Increase JTAG Speed to 6 MHz
-	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+	jtag_rclk 10000                    # Increase JTAG Speed to 6 MHz
 
 	mww 0xffffec00 0x0a0a0a0a         # SMC_SETUP0 : Setup SMC for Intel NOR Flash JS28F128P30T85 128MBit
 	mww 0xffffec04 0x0b0b0b0b         # SMC_PULSE0
 	mww 0xffffec08 0x00160016         # SMC_CYCLE0
 	mww 0xffffec0c 0x00161003         # SMC_MODE0
 
-	flash probe 0                     # Identify flash bank 0
-
 	mww 0xfffff870 0xffff0000         # PIO_ASR : Select peripheral function for D15..D31
 	mww 0xfffff804 0xffff0000         # PIO_PDR : Disable PIO function for D15..D31
 
@@ -123,6 +119,3 @@ proc at91sam_init { } {
 	mww 0x20000000 0
 	mww 0xffffea04 0x5d2              # SDRAMC_TR : Set refresh timer count to 15us
 }
-
-
-

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/at91sam9260_ext_RAM_ext_flash.cfg |   31 ++++++++++----------------
 1 files changed, 12 insertions(+), 19 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Mon May 24 10:22:58 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Mon, 24 May 2010 08:22:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-266-gf1c1bed
Message-ID: <E1OGSw8-0000aL-7C@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f1c1bed39a29ae7eca2a43bccdf8feab1033e35d (commit)
       via  e2c9518eda9d8416894dabe9ecad3a8227f95d09 (commit)
       via  9c3b4cfc5d47052df955d72e88fcb4d6a1e79a60 (commit)
       via  0e4f4bacdc3a5237fbc358d968ee7a8d72868d74 (commit)
       via  06df4664a928c5b6de78e6ccd28499a4589d80f8 (commit)
      from  2e1eaaae35e506efe6190817876b1078885a83d7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f1c1bed39a29ae7eca2a43bccdf8feab1033e35d
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Sat May 22 09:51:07 2010 +0200

    There are no variants of arm7tdmi target
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
index 1e79dcb..714267f 100644
--- a/tcl/target/lpc2103.cfg
+++ b/tcl/target/lpc2103.cfg
@@ -22,7 +22,7 @@ jtag_ntrst_delay 100
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
 
 # 8kB of internal SRAM
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x2000 -work-area-backup 0
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index 082e312..c511589 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -25,7 +25,7 @@ adapter_khz 1000
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index dedd714..103f18e 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -23,7 +23,7 @@ jtag_ntrst_delay 100
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index 07ca929..cbf3058 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -27,7 +27,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
 
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index fdec728..8ed6352 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -21,7 +21,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
 #flash configuration
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index 7ff572d..65b554c 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -22,7 +22,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
 
 # LPC2378 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x8000 -work-area-backup 0
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index aa1cbee..df46c10 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -22,7 +22,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
 
 # LPC2478 has 64kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x10000 -work-area-backup 0

commit e2c9518eda9d8416894dabe9ecad3a8227f95d09
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Fri May 21 18:02:58 2010 +0200

    All LPC2xxx chips are little endian and that cannot be changed - update config scripts
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
index b0a66bc..1e79dcb 100644
--- a/tcl/target/lpc2103.cfg
+++ b/tcl/target/lpc2103.cfg
@@ -6,12 +6,6 @@ if { [info exists CHIPNAME] } {
    set _CHIPNAME lpc2103
 }
 
-if { [info exists ENDIAN] } {
-   set _ENDIAN $ENDIAN
-} else {
-   set _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
@@ -28,7 +22,7 @@ jtag_ntrst_delay 100
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 # 8kB of internal SRAM
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x2000 -work-area-backup 0
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index 259088d..082e312 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -1,4 +1,4 @@
-#LPC-2124 CPU
+# NXP LPC2124
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
@@ -6,20 +6,12 @@ if { [info exists CHIPNAME] } {
    set  _CHIPNAME lpc2124
 }
 
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
     set _CPUTAPID 0x4f1f0f0f
 }
 
-
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config trst_and_srst srst_pulls_trst
 
@@ -33,11 +25,10 @@ adapter_khz 1000
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
-
 # flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14745 calc_checksum
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index 374a395..dedd714 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -6,12 +6,6 @@ if { [info exists CHIPNAME] } {
    set  _CHIPNAME lpc2129
 }
 
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
@@ -29,7 +23,7 @@ jtag_ntrst_delay 100
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index 2199abc..07ca929 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -9,12 +9,6 @@ if { [info exists CHIPNAME] } {
    set _CHIPNAME lpc2148
 }
 
-if { [info exists ENDIAN] } {
-   set _ENDIAN $ENDIAN
-} else {
-   set _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
@@ -33,7 +27,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index 023b445..fdec728 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -4,12 +4,6 @@ if { [info exists CHIPNAME] } {
    set  _CHIPNAME lpc2294
 }
 
-if { [info exists ENDIAN] } {
-   set  _ENDIAN $ENDIAN
-} else {
-   set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
@@ -27,7 +21,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
 #flash configuration
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index a3c0992..7ff572d 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -6,12 +6,6 @@ if { [info exists CHIPNAME] } {
 	set  _CHIPNAME lpc2378
 }
 
-if { [info exists ENDIAN] } {
-	set  _ENDIAN $ENDIAN
-} else {
-	set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
 	set _CPUTAPID $CPUTAPID
 } else {
@@ -28,7 +22,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 # LPC2378 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x8000 -work-area-backup 0
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index c430e43..aa1cbee 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -6,12 +6,6 @@ if { [info exists CHIPNAME] } {
 	set  _CHIPNAME lpc2478
 }
 
-if { [info exists ENDIAN] } {
-	set  _ENDIAN $ENDIAN
-} else {
-	set  _ENDIAN little
-}
-
 if { [info exists CPUTAPID ] } {
 	set _CPUTAPID $CPUTAPID
 } else {
@@ -28,7 +22,7 @@ reset_config trst_and_srst srst_pulls_trst
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
-target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 
 # LPC2478 has 64kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x10000 -work-area-backup 0

commit 9c3b4cfc5d47052df955d72e88fcb4d6a1e79a60
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Fri May 21 17:57:10 2010 +0200

    add correct CPUTAPID value for LPC2129
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index 1ecf7d0..374a395 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -1,5 +1,4 @@
-#LPC-2129 CPU
-
+# NXP LPC2129
 
 if { [info exists CHIPNAME] } {
    set  _CHIPNAME $CHIPNAME
@@ -16,11 +15,9 @@ if { [info exists ENDIAN] } {
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
+   set _CPUTAPID 0xcf1f0f0f
 }
 
-
 #use combined on interfaces or targets that can't set TRST/SRST separately
 reset_config trst_and_srst srst_pulls_trst
 
@@ -31,7 +28,6 @@ jtag_ntrst_delay 100
 #jtag scan chain
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
-
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi-s_r4
 

commit 0e4f4bacdc3a5237fbc358d968ee7a8d72868d74
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Fri May 21 17:52:25 2010 +0200

    Update "flash bank" helper comments for LPC2xxx chips
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index 82a097f..fc00d78 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -42,6 +42,7 @@ $_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size 0x8000
 
 # LPC1768 has 512kB of flash memory, managed by ROM code (including a
 # boot loader which verifies the flash exception table's checksum).
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x80000 0 0 $_TARGETNAME \
 	lpc1700 $_CCLK calc_checksum
diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
index 2ebe91a..b0a66bc 100644
--- a/tcl/target/lpc2103.cfg
+++ b/tcl/target/lpc2103.cfg
@@ -34,6 +34,6 @@ target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAM
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x2000 -work-area-backup 0
 
 # 32kB of internal Flash, core clocked with 12MHz crystal
-# flash bank lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc_checksum]
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x8000 0 0 $_TARGETNAME lpc2000_v2 12000 calc_checksum
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
index 1b60c15..259088d 100644
--- a/tcl/target/lpc2124.cfg
+++ b/tcl/target/lpc2124.cfg
@@ -38,6 +38,6 @@ target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAM
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
 
-#flash bank <driver> <base> <size> <chip_width> <bus_width>
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14745 calc_checksum
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
index 5b2a2f7..1ecf7d0 100644
--- a/tcl/target/lpc2129.cfg
+++ b/tcl/target/lpc2129.cfg
@@ -37,6 +37,6 @@ target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAM
 
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
-#flash bank <driver> <base> <size> <chip_width> <bus_width>
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14765 calc_checksum
diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
index 502a355..2199abc 100644
--- a/tcl/target/lpc2148.cfg
+++ b/tcl/target/lpc2148.cfg
@@ -51,6 +51,6 @@ $_TARGETNAME configure -event reset-init {
 	mwb 0xE01FC040 0x01
 }
 
-# flash bank lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc_checksum]
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x7d000 0 0 $_TARGETNAME lpc2000_v2 14765 calc_checksum
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
index 9ac3c6c..023b445 100644
--- a/tcl/target/lpc2294.cfg
+++ b/tcl/target/lpc2294.cfg
@@ -31,7 +31,7 @@ target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAM
 $_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
 
 #flash configuration
-#flash bank lpc2000 <base> <size> 0 0 <target#> <variant>
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x40000 0 0 $_TARGETNAME lpc2000_v1 14765 calc_checksum
 
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
index 1a42e07..a3c0992 100644
--- a/tcl/target/lpc2378.cfg
+++ b/tcl/target/lpc2378.cfg
@@ -42,7 +42,7 @@ $_TARGETNAME configure -event reset-init {
 
 # LPC2378 has 512kB of FLASH, but upper 8kB are occupied by bootloader.
 # After reset the chip uses its internal 4MHz RC oscillator
-#flash bank lpc2000 <base> <size> 0 0 <target#> <variant>
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x0007D000 0 0 $_TARGETNAME lpc2000_v2 4000 calc_checksum
 
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index 57aa36f..c430e43 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -42,7 +42,7 @@ $_TARGETNAME configure -event reset-init {
 
 # LPC2378 has 512kB of FLASH, but upper 8kB are occupied by bootloader.
 # After reset the chip uses its internal 4MHz RC oscillator.
-# flash bank lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
+# flash bank <name> lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
 flash bank $_FLASHNAME lpc2000 0x0 0x7D000 0 0 $_TARGETNAME lpc2000_v2 4000 calc_checksum
 

commit 06df4664a928c5b6de78e6ccd28499a4589d80f8
Author: Freddie Chopin <freddie_chopin at op.pl>
Date:   Fri May 21 17:46:40 2010 +0200

    LPC23xx and LPC24xx after reset run on internal 4MHz RC oscillator, so "flash bank" parameter should be 4000 (not 12000)
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
index 950ef63..57aa36f 100644
--- a/tcl/target/lpc2478.cfg
+++ b/tcl/target/lpc2478.cfg
@@ -44,7 +44,7 @@ $_TARGETNAME configure -event reset-init {
 # After reset the chip uses its internal 4MHz RC oscillator.
 # flash bank lpc2000 <base> <size> 0 0 <target#> <variant> <clock> [calc checksum]
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME lpc2000 0x0 0x7D000 0 0 $_TARGETNAME lpc2000_v2 12000 calc_checksum
+flash bank $_FLASHNAME lpc2000 0x0 0x7D000 0 0 $_TARGETNAME lpc2000_v2 4000 calc_checksum
 
 # Try to use RCLK, if RCLK is not available use "normal" mode. 4MHz / 6 = 666kHz, so use 500.
 jtag_rclk 500

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc1768.cfg |    1 +
 tcl/target/lpc2103.cfg |   10 ++--------
 tcl/target/lpc2124.cfg |   15 +++------------
 tcl/target/lpc2129.cfg |   18 ++++--------------
 tcl/target/lpc2148.cfg |   10 ++--------
 tcl/target/lpc2294.cfg |   10 ++--------
 tcl/target/lpc2378.cfg |   10 ++--------
 tcl/target/lpc2478.cfg |   12 +++---------
 8 files changed, 19 insertions(+), 67 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed May 26 12:09:13 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed, 26 May 2010 10:09:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-267-gef72484
Message-ID: <E1OHDY5-0000JK-7j@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ef72484b785ec7462a0415afea679d08b864c7fb (commit)
      from  f1c1bed39a29ae7eca2a43bccdf8feab1033e35d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ef72484b785ec7462a0415afea679d08b864c7fb
Author: Antonio Borneo <borneo.antonio at gmail.com>
Date:   Wed May 26 10:04:03 2010 +0800

    NOR/CFI: fix memory leak; check malloc return value
    
    Every time command "flash probe #" is executed, memory
    structures are re-allocated without preventive free()
    of former areas, causing memory leak.
    Also, memory allocation does not check return value,
    determining segmentation fault in case of out of memory.
    
    Signed-off-by: Antonio Borneo <borneo.antonio at gmail.com>
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index b19b945..8c1aaca 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -355,8 +355,17 @@ static int cfi_read_intel_pri_ext(struct flash_bank *bank)
 {
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
-	struct cfi_intel_pri_ext *pri_ext = malloc(sizeof(struct cfi_intel_pri_ext));
+	struct cfi_intel_pri_ext *pri_ext;
 
+	if (cfi_info->pri_ext)
+		free(cfi_info->pri_ext);
+
+	pri_ext = malloc(sizeof(struct cfi_intel_pri_ext));
+	if (pri_ext == NULL)
+	{
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
 	cfi_info->pri_ext = pri_ext;
 
 	pri_ext->pri[0] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0);
@@ -413,8 +422,17 @@ static int cfi_read_spansion_pri_ext(struct flash_bank *bank)
 {
 	int retval;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
-	struct cfi_spansion_pri_ext *pri_ext = malloc(sizeof(struct cfi_spansion_pri_ext));
+	struct cfi_spansion_pri_ext *pri_ext;
 
+	if (cfi_info->pri_ext)
+		free(cfi_info->pri_ext);
+
+	pri_ext = malloc(sizeof(struct cfi_spansion_pri_ext));
+	if (pri_ext == NULL)
+	{
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
 	cfi_info->pri_ext = pri_ext;
 
 	pri_ext->pri[0] = cfi_query_u8(bank, 0, cfi_info->pri_addr + 0);
@@ -476,7 +494,17 @@ static int cfi_read_atmel_pri_ext(struct flash_bank *bank)
 	int retval;
 	struct cfi_atmel_pri_ext atmel_pri_ext;
 	struct cfi_flash_bank *cfi_info = bank->driver_priv;
-	struct cfi_spansion_pri_ext *pri_ext = malloc(sizeof(struct cfi_spansion_pri_ext));
+	struct cfi_spansion_pri_ext *pri_ext;
+
+	if (cfi_info->pri_ext)
+		free(cfi_info->pri_ext);
+
+	pri_ext = malloc(sizeof(struct cfi_spansion_pri_ext));
+	if (pri_ext == NULL)
+	{
+		LOG_ERROR("Out of memory");
+		return ERROR_FAIL;
+	}
 
 	/* ATMEL devices use the same CFI primary command set (0x2) as AMD/Spansion,
 	 * but a different primary extended query table.
@@ -644,6 +672,8 @@ FLASH_BANK_COMMAND_HANDLER(cfi_flash_bank_command)
 
 	cfi_info = malloc(sizeof(struct cfi_flash_bank));
 	cfi_info->probed = 0;
+	cfi_info->erase_region_info = 0;
+	cfi_info->pri_ext = NULL;
 	bank->driver_priv = cfi_info;
 
 	cfi_info->write_algorithm = NULL;
@@ -1426,6 +1456,11 @@ static int cfi_spansion_write_block(struct flash_bank *bank, uint8_t *buffer, ui
 
 		/* convert bus-width dependent algorithm code to correct endiannes */
 		target_code = malloc(target_code_size);
+		if (target_code == NULL)
+		{
+			LOG_ERROR("Out of memory");
+			return ERROR_FAIL;
+		}
 		cfi_fix_code_endian(target, target_code, target_code_src, target_code_size / 4);
 
 		/* allocate working area */
@@ -2099,6 +2134,16 @@ static int cfi_probe(struct flash_bank *bank)
 	}
 
 	cfi_info->probed = 0;
+	if (bank->sectors)
+	{
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+	if(cfi_info->erase_region_info)
+	{
+		free(cfi_info->erase_region_info);
+		cfi_info->erase_region_info = NULL;
+	}
 
 	/* JEDEC standard JESD21C uses 0x5555 and 0x2aaa as unlock addresses,
 	 * while CFI compatible AMD/Spansion flashes use 0x555 and 0x2aa

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/cfi.c |   51 ++++++++++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 48 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu May 27 22:32:12 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu, 27 May 2010 20:32:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-271-g215353e
Message-ID: <E1OHjkT-00040w-Uq@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  215353ef67434e41b13f8948dc7dceefc110e3fe (commit)
       via  ee4106ee995a1fc81778f4ebd496d6782e592b63 (commit)
       via  94dc7c0a939c042c71767b5cbdc1e1327ccecbea (commit)
       via  5319ccd7eb4761f1481dcbb041b256848efc005e (commit)
      from  ef72484b785ec7462a0415afea679d08b864c7fb (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 215353ef67434e41b13f8948dc7dceefc110e3fe
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 24 12:32:58 2010 +0100

    flash: virtual driver update for get_flash_bank_by_name_noprobe
    
    Make sure we do not probe a flash when getting info.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/virtual.c b/src/flash/nor/virtual.c
index 4908c0c..eb1885e 100644
--- a/src/flash/nor/virtual.c
+++ b/src/flash/nor/virtual.c
@@ -27,7 +27,7 @@ static struct flash_bank* virtual_get_master_bank(struct flash_bank *bank)
 {
 	struct flash_bank* master_bank;
 
-	master_bank = get_flash_bank_by_name(bank->driver_priv);
+	master_bank = get_flash_bank_by_name_noprobe(bank->driver_priv);
 	if (master_bank == NULL) {
 		LOG_ERROR("master flash bank '%s' does not exist", (char*)bank->driver_priv);
 	}
@@ -61,7 +61,7 @@ FLASH_BANK_COMMAND_HANDLER(virtual_flash_bank_command)
 
 	/* get the master flash bank */
 	const char *bank_name = CMD_ARGV[6];
-	struct flash_bank *master_bank = get_flash_bank_by_name(bank_name);
+	struct flash_bank *master_bank = get_flash_bank_by_name_noprobe(bank_name);
 
 	if (master_bank == NULL)
 	{

commit ee4106ee995a1fc81778f4ebd496d6782e592b63
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 24 12:30:29 2010 +0100

    nor: add get_flash_bank_by_name autoprobe
    
    When a flash cmd is called using the flash name the autoprobe
    function is not called. autoprobe is called if flash_command_get_bank
    falls through to get_flash_bank_by_num.
    
    This makes both get_flash_bank_by_name and get_flash_bank_by_num
    behave the same.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 00f73f2..1bd09b4 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -178,7 +178,7 @@ int flash_get_bank_count(void)
 	return i;
 }
 
-struct flash_bank *get_flash_bank_by_name(const char *name)
+struct flash_bank *get_flash_bank_by_name_noprobe(const char *name)
 {
 	unsigned requested = get_flash_name_index(name);
 	unsigned found = 0;
@@ -197,6 +197,26 @@ struct flash_bank *get_flash_bank_by_name(const char *name)
 	return NULL;
 }
 
+struct flash_bank *get_flash_bank_by_name(const char *name)
+{
+	struct flash_bank *bank;
+	int retval;
+
+	bank = get_flash_bank_by_name_noprobe(name);
+	if (bank != NULL)
+	{
+		retval = bank->driver->auto_probe(bank);
+
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR("auto_probe failed %d\n", retval);
+			return NULL;
+		}
+	}
+
+	return bank;
+}
+
 int get_flash_bank_by_num(int num, struct flash_bank **bank)
 {
 	struct flash_bank *p = get_flash_bank_by_num_noprobe(num);
@@ -660,7 +680,7 @@ int flash_write_unlock(struct target *target, struct image *image,
 			intptr_t diff = (intptr_t)sections[section] - (intptr_t)image->sections;
 			int t_section_num = diff / sizeof(struct imageection);
 
-			LOG_DEBUG("image_read_section: section = %d, t_section_num = %d, section_offset = %d, buffer_size = %d, size_read = %d", 
+			LOG_DEBUG("image_read_section: section = %d, t_section_num = %d, section_offset = %d, buffer_size = %d, size_read = %d",
 				 (int)section,
 (int)t_section_num, (int)section_offset, (int)buffer_size, (int)size_read);
 			if ((retval = image_read_section(image, t_section_num, section_offset,
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index a35f64f..17f1c53 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -170,7 +170,15 @@ int default_flash_mem_blank_check(struct flash_bank *bank);
  */
 struct flash_bank *get_flash_bank_by_name(const char *name);
 /**
- * Returns a flash bank by the specified flash_bank_s bank_number, @a num.
+ * Returns the flash bank specified by @a name, which matches the
+ * driver name and a suffix (option) specify the driver-specific
+ * bank number. The suffix consists of the '.' and the driver-specific
+ * bank number: when two str9x banks are defined, then 'str9x.1' refers
+ * to the second.
+ */
+struct flash_bank *get_flash_bank_by_name_noprobe(const char *name);
+/**
+ * Returns the flash bank like get_flash_bank_by_name(), without probing.
  * @param num The flash bank number.
  * @param bank returned bank if fn returns ERROR_OK
  * @returns ERROR_OK if successful
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 80d9a27..b3dbd7b 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -796,7 +796,7 @@ COMMAND_HANDLER(handle_flash_bank_command)
 	}
 
 	/* check the flash bank name is unique */
-	if (get_flash_bank_by_name(bank_name) != NULL)
+	if (get_flash_bank_by_name_noprobe(bank_name) != NULL)
 	{
 		/* flash bank name already exists  */
 		LOG_ERROR("flash bank name '%s' already exists", bank_name);

commit 94dc7c0a939c042c71767b5cbdc1e1327ccecbea
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 24 11:43:09 2010 +0100

    cfg: add pic32 virtual banks
    
    make use of the new virtual bank flash driver.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
index 0b99cdb..202668b 100644
--- a/tcl/target/pic32mx.cfg
+++ b/tcl/target/pic32mx.cfg
@@ -69,8 +69,15 @@ $_TARGETNAME configure -event reset-init {
 
 set _FLASHNAME $_CHIPNAME.flash0
 flash bank $_FLASHNAME pic32mx 0x1fc00000 0 0 0 $_TARGETNAME
+# add virtual banks for kseg0 and kseg1
+flash bank vbank0 virtual 0xbfc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+flash bank vbank1 virtual 0x9fc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+
 set _FLASHNAME $_CHIPNAME.flash1
 flash bank $_FLASHNAME pic32mx 0x1d000000 0 0 0 $_TARGETNAME
+# add virtual banks for kseg0 and kseg1
+flash bank vbank2 virtual 0xbd000000 0 0 0 $_TARGETNAME $_FLASHNAME
+flash bank vbank3 virtual 0x9d000000 0 0 0 $_TARGETNAME $_FLASHNAME
 
 # For more information about the configuration files, take a look at:
 # openocd.texi

commit 5319ccd7eb4761f1481dcbb041b256848efc005e
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Mon May 24 11:41:50 2010 +0100

    flash: add virtual flash bank driver
    
    This adds a virtual flash bank driver that allows virtual banks to
    be defined that refer to an existing flash bank.
    
    For example the real address for bank0 on the pic32 is 0x1fc00000
    but the user program will either be in kseg0 (0xbfc00000) or
    kseg1 (0x9fc00000).
    This also means that gdb will be aware of all the read only flash
    addresses.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index c95803a..a3ca124 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4672,6 +4672,26 @@ the flash clock.
 @end deffn
 @end deffn
 
+ at deffn {Flash Driver} virtual
+This is a special driver that maps a previously defined bank to another
+address. All bank settings will be copied from the master physical bank.
+
+The @var{virtual} driver defines one mandatory parameters,
+
+ at itemize
+ at item @var{master_bank} The bank that this virtual address refers to.
+ at end itemize
+
+So in the following example addresses 0xbfc00000 and 0x9fc00000 refer to
+the flash bank defined at address 0x1fc00000. Any cmds executed on
+the virtual banks are actually performed on the physical banks.
+ at example
+flash bank $_FLASHNAME pic32mx 0x1fc00000 0 0 0 $_TARGETNAME
+flash bank vbank0 virtual 0xbfc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+flash bank vbank1 virtual 0x9fc00000 0 0 0 $_TARGETNAME $_FLASHNAME
+ at end example
+ at end deffn
+
 @subsection str9xpec driver
 @cindex str9xpec
 
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 5d0a4df..eec6f50 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -28,7 +28,8 @@ NOR_DRIVERS = \
 	str7x.c \
 	str9x.c \
 	str9xpec.c \
-	tms470.c
+	tms470.c \
+	virtual.c
 
 noinst_HEADERS = \
 	at91sam7.h \
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index 3e09a00..68f2f88 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -39,6 +39,7 @@ extern struct flash_driver ocl_flash;
 extern struct flash_driver pic32mx_flash;
 extern struct flash_driver avr_flash;
 extern struct flash_driver faux_flash;
+extern struct flash_driver virtual_flash;
 
 /**
  * The list of built-in flash drivers.
@@ -63,6 +64,7 @@ static struct flash_driver *flash_drivers[] = {
 	&pic32mx_flash,
 	&avr_flash,
 	&faux_flash,
+	&virtual_flash,
 	NULL,
 };
 
diff --git a/src/flash/nor/virtual.c b/src/flash/nor/virtual.c
new file mode 100644
index 0000000..4908c0c
--- /dev/null
+++ b/src/flash/nor/virtual.c
@@ -0,0 +1,244 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Spencer Oliver                                  *
+ *   spen at spen-soft.co.uk                                                  *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "imp.h"
+
+static struct flash_bank* virtual_get_master_bank(struct flash_bank *bank)
+{
+	struct flash_bank* master_bank;
+
+	master_bank = get_flash_bank_by_name(bank->driver_priv);
+	if (master_bank == NULL) {
+		LOG_ERROR("master flash bank '%s' does not exist", (char*)bank->driver_priv);
+	}
+
+	return master_bank;
+}
+
+static void virtual_update_bank_info(struct flash_bank *bank)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+
+	if (master_bank == NULL) {
+		return;
+	}
+
+	/* update the info we do not have */
+	bank->size = master_bank->size;
+	bank->chip_width = master_bank->chip_width;
+	bank->bus_width = master_bank->bus_width;
+	bank->num_sectors = master_bank->num_sectors;
+	bank->sectors = master_bank->sectors;
+}
+
+FLASH_BANK_COMMAND_HANDLER(virtual_flash_bank_command)
+{
+	if (CMD_ARGC < 7)
+	{
+		LOG_WARNING("incomplete flash_bank virtual configuration");
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* get the master flash bank */
+	const char *bank_name = CMD_ARGV[6];
+	struct flash_bank *master_bank = get_flash_bank_by_name(bank_name);
+
+	if (master_bank == NULL)
+	{
+		LOG_ERROR("master flash bank '%s' does not exist", bank_name);
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* save master bank name - use this to get settings later */
+	bank->driver_priv = strdup(bank_name);
+
+	return ERROR_OK;
+}
+
+static int virtual_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->protect(master_bank, set,
+			first, last)) != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int virtual_protect_check(struct flash_bank *bank)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->protect_check(master_bank)) != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int virtual_erase(struct flash_bank *bank, int first, int last)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->erase(master_bank,
+			first, last)) != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int virtual_write(struct flash_bank *bank, uint8_t *buffer,
+		uint32_t offset, uint32_t count)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->write(master_bank, buffer,
+			offset, count)) != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int virtual_probe(struct flash_bank *bank)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->probe(master_bank)) != ERROR_OK)
+		return retval;
+
+	/* update the info we do not have */
+	virtual_update_bank_info(bank);
+
+	return ERROR_OK;
+}
+
+static int virtual_auto_probe(struct flash_bank *bank)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->auto_probe(master_bank)) != ERROR_OK)
+		return retval;
+
+	/* update the info we do not have */
+	virtual_update_bank_info(bank);
+
+	return ERROR_OK;
+}
+
+static int virtual_info(struct flash_bank *bank, char *buf, int buf_size)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	snprintf(buf, buf_size, "%s driver for flash bank %s at 0x%8.8" PRIx32 "",
+			bank->driver->name, master_bank->name, master_bank->base);
+
+	return ERROR_OK;
+}
+
+int virtual_blank_check(struct flash_bank *bank)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->erase_check(master_bank)) != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+int virtual_flash_read(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	struct flash_bank *master_bank = virtual_get_master_bank(bank);
+	int retval;
+
+	if (master_bank == NULL) {
+		return ERROR_FLASH_OPERATION_FAILED;
+	}
+
+	/* call master handler */
+	if ((retval = master_bank->driver->read(master_bank, buffer,
+			offset, count)) != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+struct flash_driver virtual_flash = {
+	.name = "virtual",
+	.flash_bank_command = virtual_flash_bank_command,
+	.erase = virtual_erase,
+	.protect = virtual_protect,
+	.write = virtual_write,
+	.read = virtual_flash_read,
+	.probe = virtual_probe,
+	.auto_probe = virtual_auto_probe,
+	.erase_check = virtual_blank_check,
+	.protect_check = virtual_protect_check,
+	.info = virtual_info,
+};

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi          |   20 ++++
 src/flash/nor/Makefile.am |    3 +-
 src/flash/nor/core.c      |   24 ++++-
 src/flash/nor/core.h      |   10 ++-
 src/flash/nor/drivers.c   |    2 +
 src/flash/nor/tcl.c       |    2 +-
 src/flash/nor/virtual.c   |  244 +++++++++++++++++++++++++++++++++++++++++++++
 tcl/target/pic32mx.cfg    |    7 ++
 8 files changed, 307 insertions(+), 5 deletions(-)
 create mode 100644 src/flash/nor/virtual.c


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Sat May 29 16:45:28 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Sat, 29 May 2010 14:45:28 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-272-g86e851e
Message-ID: <E1OINI5-0000l4-3u@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  86e851e1e263c79f19eb9db52553de99f19b8bb9 (commit)
      from  215353ef67434e41b13f8948dc7dceefc110e3fe (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 86e851e1e263c79f19eb9db52553de99f19b8bb9
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Sat May 29 15:43:42 2010 +0100

    nor: fix memory leaks during probe
    
    Fix similar memory leaks as per commit:
    ef72484b785ec7462a0415afea679d08b864c7fb
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index 7cdab51..8472d83 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -324,6 +324,12 @@ static int avrf_probe(struct flash_bank *bank)
 
 	if (avr_info != NULL)
 	{
+		if (bank->sectors)
+		{
+			free(bank->sectors);
+			bank->sectors = NULL;
+		}
+
 		// chip found
 		bank->base = 0x00000000;
 		bank->size = (avr_info->flash_page_size * avr_info->flash_page_num);
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index 58009ae..2fe864d 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -560,6 +560,12 @@ static int pic32mx_probe(struct flash_bank *bank)
 
 	LOG_INFO("flash size = %" PRId32 "kbytes", num_pages / 1024);
 
+	if (bank->sectors)
+	{
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
 	/* calculate numbers of pages */
 	num_pages /= page_size;
 	bank->size = (num_pages * page_size);
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 38374ff..f7e2e8d 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -1065,6 +1065,12 @@ static int stellaris_probe(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
+	if (bank->sectors)
+	{
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
 	/* provide this for the benefit of the NOR flash framework */
 	bank->size = 1024 * stellaris_info->num_pages;
 	bank->num_sectors = stellaris_info->num_pages;
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index d11a8ed..8a3b832 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -775,6 +775,12 @@ static int stm32x_probe(struct flash_bank *bank)
 	/* calculate numbers of pages */
 	num_pages /= (page_size / 1024);
 
+	if (bank->sectors)
+	{
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
 	bank->base = 0x08000000;
 	bank->size = (num_pages * page_size);
 	bank->num_sectors = num_pages;
diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
index c1681f1..343c43e 100644
--- a/src/flash/nor/tms470.c
+++ b/src/flash/nor/tms470.c
@@ -139,6 +139,12 @@ static int tms470_read_part_info(struct flash_bank *bank)
 	rom_flash = (device_ident_reg >> 10) & 1;
 	part_number = (device_ident_reg >> 3) & 0x7f;
 
+	if (bank->sectors)
+	{
+		free(bank->sectors);
+		bank->sectors = NULL;
+	}
+
 	/*
 	 * If the part number is known, determine if the flash bank is valid
 	 * based on the base address being within the known flash bank

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/avrf.c      |    6 ++++++
 src/flash/nor/pic32mx.c   |    6 ++++++
 src/flash/nor/stellaris.c |    6 ++++++
 src/flash/nor/stm32x.c    |    6 ++++++
 src/flash/nor/tms470.c    |    6 ++++++
 5 files changed, 30 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon May 31 07:14:57 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 31 May 2010 05:14:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-273-gd944a0b
Message-ID: <E1OIxL2-0005Es-As@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d944a0bed73c63fe52cf546a7121823318e8b593 (commit)
      from  86e851e1e263c79f19eb9db52553de99f19b8bb9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d944a0bed73c63fe52cf546a7121823318e8b593
Author: Jon Povey <jon.povey at racelogic.co.uk>
Date:   Mon May 31 11:56:42 2010 +0900

    etm: print something when trace buffer empty
    
    ETM analyze produced no output when the trace buffer was empty.
    This patch provides users with a clue.
    
    Signed-off-by: Jon Povey <jon.povey at racelogic.co.uk>
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/etm.c b/src/target/etm.c
index 4f4bf9a..61ee99a 100644
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -882,6 +882,11 @@ static int etmv1_analyze_trace(struct etm_context *ctx, struct command_context *
 	if (ctx->trace_depth == 0)
 		ctx->capture_driver->read_trace(ctx);
 
+	if (ctx->trace_depth == 0) {
+		command_print(cmd_ctx, "Trace is empty.");
+		return ERROR_OK;
+	}
+
 	/* start at the beginning of the captured trace */
 	ctx->pipe_index = 0;
 	ctx->data_index = 0;

-----------------------------------------------------------------------

Summary of changes:
 src/target/etm.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


