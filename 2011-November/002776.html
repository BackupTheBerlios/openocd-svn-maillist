<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-184-gefbafd9
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-November/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-184-gefbafd9&In-Reply-To=%3Cmailman.261.1331736158.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002775.html">
   <LINK REL="Next"  HREF="002777.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-184-gefbafd9</H1>
    <B>OpenOCD-Gerrit</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-184-gefbafd9&In-Reply-To=%3Cmailman.261.1331736158.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-184-gefbafd9">openocd-gerrit at users.sourceforge.net
       </A><BR>
    <I>Thu Nov  3 23:56:41 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002775.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-183-gbab6db1
</A></li>
        <LI>Next message: <A HREF="002777.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-185-gce3905a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2776">[ date ]</a>
              <a href="thread.html#2776">[ thread ]</a>
              <a href="subject.html#2776">[ subject ]</a>
              <a href="author.html#2776">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  efbafd9dc8c30b66755a3a840fe58bd573cec1db (commit)
      from  bab6db1fd98e3f31f6cd1981756f95773ce9f256 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit efbafd9dc8c30b66755a3a840fe58bd573cec1db
Author: Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;
Date:   Thu Nov 3 19:22:19 2011 +0000

    tools: add checkpatch script
    
    Change-Id: I3579028fc1c6ee8bea58c82e5f0eecba7794d7cb
    Signed-off-by: Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;

diff --git a/tools/scripts/checkpatch.pl b/tools/scripts/checkpatch.pl
new file mode 100644
index 0000000..0b3e35c
--- /dev/null
+++ b/tools/scripts/checkpatch.pl
@@ -0,0 +1,3337 @@
+#!/usr/bin/perl -w
+# (c) 2001, Dave Jones. (the file handling bit)
+# (c) 2005, Joel Schopp &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">jschopp at austin.ibm.com</A>&gt; (the ugly bit)
+# (c) 2007,2008, Andy Whitcroft &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">apw at uk.ibm.com</A>&gt; (new conditions, test suite)
+# (c) 2008-2010 Andy Whitcroft &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">apw at canonical.com</A>&gt;
+# Licensed under the terms of the GNU GPL License version 2
+
+use strict;
+
+my $P = $0;
+$P =~ <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">s at .</A>*/@@g;
+
+my $V = '0.32';
+
+use Getopt::Long qw(:config no_auto_abbrev);
+
+my $quiet = 0;
+my $tree = 1;
+my $chk_signoff = 1;
+my $chk_patch = 1;
+my $tst_only;
+my $emacs = 0;
+my $terse = 0;
+my $file = 0;
+my $check = 0;
+my $summary = 1;
+my $mailback = 0;
+my $summary_file = 0;
+my $show_types = 0;
+my $root;
+my %debug;
+my %ignore_type = ();
+my @ignore = ();
+my $help = 0;
+my $configuration_file = &quot;.checkpatch.conf&quot;;
+
+sub help {
+	my ($exitcode) = @_;
+
+	print &lt;&lt; &quot;EOM&quot;;
+Usage: $P [OPTION]... [FILE]...
+Version: $V
+
+Options:
+  -q, --quiet                quiet
+  --no-tree                  run without a kernel tree
+  --no-signoff               do not check for 'Signed-off-by' line
+  --patch                    treat FILE as patchfile (default)
+  --emacs                    emacs compile window format
+  --terse                    one line per report
+  -f, --file                 treat FILE as regular source file
+  --subjective, --strict     enable more subjective tests
+  --ignore TYPE(,TYPE2...)   ignore various comma separated message types
+  --show-types               show the message &quot;types&quot; in the output
+  --root=PATH                PATH to the kernel tree root
+  --no-summary               suppress the per-file summary
+  --mailback                 only produce a report in case of warnings/errors
+  --summary-file             include the filename in summary
+  --debug KEY=[0|1]          turn on/off debugging of KEY, where KEY is one of
+                             'values', 'possible', 'type', and 'attr' (default
+                             is all off)
+  --test-only=WORD           report only warnings/errors containing WORD
+                             literally
+  -h, --help, --version      display this help and exit
+
+When FILE is - read standard input.
+EOM
+
+	exit($exitcode);
+}
+
+my $conf = which_conf($configuration_file);
+if (-f $conf) {
+	my @conf_args;
+	open(my $conffile, '&lt;', &quot;$conf&quot;)
+	    or warn &quot;$P: Can't find a readable $configuration_file file $!\n&quot;;
+
+	while (&lt;$conffile&gt;) {
+		my $line = $_;
+
+		$line =~ s/\s*\n?$//g;
+		$line =~ s/^\s*//g;
+		$line =~ s/\s+/ /g;
+
+		next if ($line =~ m/^\s*#/);
+		next if ($line =~ m/^\s*$/);
+
+		my @words = split(&quot; &quot;, $line);
+		foreach my $word (@words) {
+			last if ($word =~ m/^#/);
+			push (@conf_args, $word);
+		}
+	}
+	close($conffile);
+	unshift(@ARGV, @conf_args) if @conf_args;
+}
+
+GetOptions(
+	'q|quiet+'	=&gt; \$quiet,
+	'tree!'		=&gt; \$tree,
+	'signoff!'	=&gt; \$chk_signoff,
+	'patch!'	=&gt; \$chk_patch,
+	'emacs!'	=&gt; \$emacs,
+	'terse!'	=&gt; \$terse,
+	'f|file!'	=&gt; \$file,
+	'subjective!'	=&gt; \$check,
+	'strict!'	=&gt; \$check,
+	'ignore=s'	=&gt; \@ignore,
+	'show-types!'	=&gt; \$show_types,
+	'root=s'	=&gt; \$root,
+	'summary!'	=&gt; \$summary,
+	'mailback!'	=&gt; \$mailback,
+	'summary-file!'	=&gt; \$summary_file,
+
+	'debug=s'	=&gt; \%debug,
+	'test-only=s'	=&gt; \$tst_only,
+	'h|help'	=&gt; \$help,
+	'version'	=&gt; \$help
+) or help(1);
+
+help(0) if ($help);
+
+my $exit = 0;
+
+if ($#ARGV &lt; 0) {
+	print &quot;$P: no input files\n&quot;;
+	exit(1);
+}
+
<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">+ at ignore</A> = split(/,/, join(','<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">, at ignore</A>));
+foreach my $word (@ignore) {
+	$word =~ s/\s*\n?$//g;
+	$word =~ s/^\s*//g;
+	$word =~ s/\s+/ /g;
+	$word =~ tr/[a-z]/[A-Z]/;
+
+	next if ($word =~ m/^\s*#/);
+	next if ($word =~ m/^\s*$/);
+
+	$ignore_type{$word}++;
+}
+
+my $dbg_values = 0;
+my $dbg_possible = 0;
+my $dbg_type = 0;
+my $dbg_attr = 0;
+for my $key (keys %debug) {
+	## no critic
+	eval &quot;\${dbg_$key} = '$debug{$key}';&quot;;
+	die &quot;$@&quot; if ($@);
+}
+
+my $rpt_cleaners = 0;
+
+if ($terse) {
+	$emacs = 1;
+	$quiet++;
+}
+
+if ($tree) {
+	if (defined $root) {
+		if (!top_of_kernel_tree($root)) {
+			die &quot;$P: $root: --root does not point at a valid tree\n&quot;;
+		}
+	} else {
+		if (top_of_kernel_tree('.')) {
+			$root = '.';
+		} elsif ($0 =~ m@(.*)/scripts/[^/]*$@ &amp;&amp;
+						top_of_kernel_tree($1)) {
+			$root = $1;
+		}
+	}
+
+	if (!defined $root) {
+		print &quot;Must be run from the top-level dir. of a kernel tree\n&quot;;
+		exit(2);
+	}
+}
+
+my $emitted_corrupt = 0;
+
+our $Ident	= qr{
+			[A-Za-z_][A-Za-z\d_]*
+			(?:\s*\#\#\s*[A-Za-z_][A-Za-z\d_]*)*
+		}x;
+our $Storage	= qr{extern|static|asmlinkage};
+our $Sparse	= qr{
+			__user|
+			__kernel|
+			__force|
+			__iomem|
+			__must_check|
+			__init_refok|
+			__kprobes|
+			__ref|
+			__rcu
+		}x;
+
+# Notes to $Attribute:
+# We need \b after 'init' otherwise 'initconst' will cause a false positive in a check
+our $Attribute	= qr{
+			const|
+			__percpu|
+			__nocast|
+			__safe|
+			__bitwise__|
+			__packed__|
+			__packed2__|
+			__naked|
+			__maybe_unused|
+			__always_unused|
+			__noreturn|
+			__used|
+			__cold|
+			__noclone|
+			__deprecated|
+			__read_mostly|
+			__kprobes|
+			__(?:mem|cpu|dev|)(?:initdata|initconst|init\b)|
+			____cacheline_aligned|
+			____cacheline_aligned_in_smp|
+			____cacheline_internodealigned_in_smp|
+			__weak
+		  }x;
+our $Modifier;
+our $Inline	= qr{inline|__always_inline|noinline};
+our $Member	= qr{-&gt;$Ident|\.$Ident|\[[^]]*\]};
+our $Lval	= qr{$Ident(?:$Member)*};
+
+our $Constant	= qr{(?:[0-9]+|0x[0-9a-fA-F]+)[UL]*};
+our $Assignment	= qr{(?:\*\=|/=|%=|\+=|-=|&lt;&lt;=|&gt;&gt;=|&amp;=|\^=|\|=|=)};
+our $Compare    = qr{&lt;=|&gt;=|==|!=|&lt;|&gt;};
+our $Operators	= qr{
+			&lt;=|&gt;=|==|!=|
+			=&gt;|-&gt;|&lt;&lt;|&gt;&gt;|&lt;|&gt;|!|~|
+			&amp;&amp;|\|\||,|\^|\+\+|--|&amp;|\||\+|-|\*|\/|%
+		  }x;
+
+our $NonptrType;
+our $Type;
+our $Declare;
+
+our $UTF8	= qr {
+	[\x09\x0A\x0D\x20-\x7E]              # ASCII
+	| [\xC2-\xDF][\x80-\xBF]             # non-overlong 2-byte
+	|  \xE0[\xA0-\xBF][\x80-\xBF]        # excluding overlongs
+	| [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}  # straight 3-byte
+	|  \xED[\x80-\x9F][\x80-\xBF]        # excluding surrogates
+	|  \xF0[\x90-\xBF][\x80-\xBF]{2}     # planes 1-3
+	| [\xF1-\xF3][\x80-\xBF]{3}          # planes 4-15
+	|  \xF4[\x80-\x8F][\x80-\xBF]{2}     # plane 16
+}x;
+
+our $typeTypedefs = qr{(?x:
+	(?:__)?(?:u|s|be|le)(?:8|16|32|64)|
+	atomic_t
+)};
+
+our $logFunctions = qr{(?x:
+	printk(?:_ratelimited|_once|)|
+	[a-z0-9]+_(?:printk|emerg|alert|crit|err|warning|warn|notice|info|debug|dbg|vdbg|devel|cont|WARN)(?:_ratelimited|_once|)|
+	WARN(?:_RATELIMIT|_ONCE|)|
+	panic|
+	MODULE_[A-Z_]+
+)};
+
+our $signature_tags = qr{(?xi:
+	Signed-off-by:|
+	Acked-by:|
+	Tested-by:|
+	Reviewed-by:|
+	Reported-by:|
+	To:|
+	Cc:
+)};
+
+our @typeList = (
+	qr{void},
+	qr{(?:unsigned\s+)?char},
+	qr{(?:unsigned\s+)?short},
+	qr{(?:unsigned\s+)?int},
+	qr{(?:unsigned\s+)?long},
+	qr{(?:unsigned\s+)?long\s+int},
+	qr{(?:unsigned\s+)?long\s+long},
+	qr{(?:unsigned\s+)?long\s+long\s+int},
+	qr{unsigned},
+	qr{float},
+	qr{double},
+	qr{bool},
+	qr{struct\s+$Ident},
+	qr{union\s+$Ident},
+	qr{enum\s+$Ident},
+	qr{${Ident}_t},
+	qr{${Ident}_handler},
+	qr{${Ident}_handler_fn},
+);
+our @modifierList = (
+	qr{fastcall},
+);
+
+our $allowed_asm_includes = qr{(?x:
+	irq|
+	memory
+)};
+# memory.h: ARM has a custom one
+
+sub build_types {
+	my $mods = &quot;(?x:  \n&quot; . join(&quot;|\n  &quot;, @modifierList) . &quot;\n)&quot;;
+	my $all = &quot;(?x:  \n&quot; . join(&quot;|\n  &quot;, @typeList) . &quot;\n)&quot;;
+	$Modifier	= qr{(?:$Attribute|$Sparse|$mods)};
+	$NonptrType	= qr{
+			(?:$Modifier\s+|const\s+)*
+			(?:
+				(?:typeof|__typeof__)\s*\(\s*\**\s*$Ident\s*\)|
+				(?:$typeTypedefs\b)|
+				(?:${all}\b)
+			)
+			(?:\s+$Modifier|\s+const)*
+		  }x;
+	$Type	= qr{
+			$NonptrType
+			(?:[\s\*]+\s*const|[\s\*]+|(?:\s*\[\s*\])+)?
+			(?:\s+$Inline|\s+$Modifier)*
+		  }x;
+	$Declare	= qr{(?:$Storage\s+)?$Type};
+}
+build_types();
+
+our $match_balanced_parentheses = qr/(\((?:[^\(\)]+|(-1))*\))/;
+
+our $Typecast	= qr{\s*(\(\s*$NonptrType\s*\)){0,1}\s*};
+our $LvalOrFunc	= qr{($Lval)\s*($match_balanced_parentheses{0,1})\s*};
+
+sub deparenthesize {
+	my ($string) = @_;
+	return &quot;&quot; if (!defined($string));
+	$string =~ s@^\s*\(\s*@@g;
+	$string =~ s@\s*\)\s*$@@g;
+	$string =~ s@\s+@ @g;
+	return $string;
+}
+
+$chk_signoff = 0 if ($file);
+
+my @dep_includes = ();
+my @dep_functions = ();
+my $removal = &quot;Documentation/feature-removal-schedule.txt&quot;;
+if ($tree &amp;&amp; -f &quot;$root/$removal&quot;) {
+	open(my $REMOVE, '&lt;', &quot;$root/$removal&quot;) ||
+				die &quot;$P: $removal: open failed - $!\n&quot;;
+	while (&lt;$REMOVE&gt;) {
+		if (/^Check:\s+(.*\S)/) {
+			for my $entry (split(/[, ]+/, $1)) {
+				if ($entry =~ <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">m at include</A>/(.*)@) {
+					push(@dep_includes, $1);
+
+				} elsif ($entry !~ m@/@) {
+					push(@dep_functions, $entry);
+				}
+			}
+		}
+	}
+	close($REMOVE);
+}
+
+my @rawlines = ();
+my @lines = ();
+my $vname;
+for my $filename (@ARGV) {
+	my $FILE;
+	if ($file) {
+		open($FILE, '-|', &quot;diff -u /dev/null $filename&quot;) ||
+			die &quot;$P: $filename: diff failed - $!\n&quot;;
+	} elsif ($filename eq '-') {
+		open($FILE, '&lt;&amp;STDIN');
+	} else {
+		open($FILE, '&lt;', &quot;$filename&quot;) ||
+			die &quot;$P: $filename: open failed - $!\n&quot;;
+	}
+	if ($filename eq '-') {
+		$vname = 'Your patch';
+	} else {
+		$vname = $filename;
+	}
+	while (&lt;$FILE&gt;) {
+		chomp;
+		push(@rawlines, $_);
+	}
+	close($FILE);
+	if (!process($filename)) {
+		$exit = 1;
+	}
+	@rawlines = ();
+	@lines = ();
+}
+
+exit($exit);
+
+sub top_of_kernel_tree {
+	my ($root) = @_;
+
+	my @tree_check = (
+		&quot;COPYING&quot;, &quot;CREDITS&quot;, &quot;Kbuild&quot;, &quot;MAINTAINERS&quot;, &quot;Makefile&quot;,
+		&quot;README&quot;, &quot;Documentation&quot;, &quot;arch&quot;, &quot;include&quot;, &quot;drivers&quot;,
+		&quot;fs&quot;, &quot;init&quot;, &quot;ipc&quot;, &quot;kernel&quot;, &quot;lib&quot;, &quot;scripts&quot;,
+	);
+
+	foreach my $check (@tree_check) {
+		if (! -e $root . '/' . $check) {
+			return 0;
+		}
+	}
+	return 1;
+    }
+
+sub parse_email {
+	my ($formatted_email) = @_;
+
+	my $name = &quot;&quot;;
+	my $address = &quot;&quot;;
+	my $comment = &quot;&quot;;
+
+	if ($formatted_email =~ /^(.*)&lt;(\S+\@\S+)&gt;(.*)$/) {
+		$name = $1;
+		$address = $2;
+		$comment = $3 if defined $3;
+	} elsif ($formatted_email =~ /^\s*&lt;(\S+\@\S+)&gt;(.*)$/) {
+		$address = $1;
+		$comment = $2 if defined $2;
+	} elsif ($formatted_email =~ /(\S+\@\S+)(.*)$/) {
+		$address = $1;
+		$comment = $2 if defined $2;
+		$formatted_email =~ s/$address.*$//;
+		$name = $formatted_email;
+		$name =~ s/^\s+|\s+$//g;
+		$name =~ s/^\&quot;|\&quot;$//g;
+		# If there's a name left after stripping spaces and
+		# leading quotes, and the address doesn't have both
+		# leading and trailing angle brackets, the address
+		# is invalid. ie:
+		#   &quot;joe smith <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">joe at smith.com</A>&quot; bad
+		#   &quot;joe smith &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">joe at smith.com</A>&quot; bad
+		if ($name ne &quot;&quot; &amp;&amp; $address !~ /^&lt;[^&gt;]+&gt;$/) {
+			$name = &quot;&quot;;
+			$address = &quot;&quot;;
+			$comment = &quot;&quot;;
+		}
+	}
+
+	$name =~ s/^\s+|\s+$//g;
+	$name =~ s/^\&quot;|\&quot;$//g;
+	$address =~ s/^\s+|\s+$//g;
+	$address =~ s/^\&lt;|\&gt;$//g;
+
+	if ($name =~ /[^\w \-]/i) { ##has &quot;must quote&quot; chars
+		$name =~ s/(?&lt;!\\)&quot;/\\&quot;/g; ##escape quotes
+		$name = &quot;\&quot;$name\&quot;&quot;;
+	}
+
+	return ($name, $address, $comment);
+}
+
+sub format_email {
+	my ($name, $address) = @_;
+
+	my $formatted_email;
+
+	$name =~ s/^\s+|\s+$//g;
+	$name =~ s/^\&quot;|\&quot;$//g;
+	$address =~ s/^\s+|\s+$//g;
+
+	if ($name =~ /[^\w \-]/i) { ##has &quot;must quote&quot; chars
+		$name =~ s/(?&lt;!\\)&quot;/\\&quot;/g; ##escape quotes
+		$name = &quot;\&quot;$name\&quot;&quot;;
+	}
+
+	if (&quot;$name&quot; eq &quot;&quot;) {
+		$formatted_email = &quot;$address&quot;;
+	} else {
+		$formatted_email = &quot;$name &lt;$address&gt;&quot;;
+	}
+
+	return $formatted_email;
+}
+
+sub which_conf {
+	my ($conf) = @_;
+
+	foreach my $path (split(/:/, &quot;.:$ENV{HOME}:.scripts&quot;)) {
+		if (-e &quot;$path/$conf&quot;) {
+			return &quot;$path/$conf&quot;;
+		}
+	}
+
+	return &quot;&quot;;
+}
+
+sub expand_tabs {
+	my ($str) = @_;
+
+	my $res = '';
+	my $n = 0;
+	for my $c (split(//, $str)) {
+		if ($c eq &quot;\t&quot;) {
+			$res .= ' ';
+			$n++;
+			for (; ($n % 8) != 0; $n++) {
+				$res .= ' ';
+			}
+			next;
+		}
+		$res .= $c;
+		$n++;
+	}
+
+	return $res;
+}
+sub copy_spacing {
+	(my $res = shift) =~ tr/\t/ /c;
+	return $res;
+}
+
+sub line_stats {
+	my ($line) = @_;
+
+	# Drop the diff line leader and expand tabs
+	$line =~ s/^.//;
+	$line = expand_tabs($line);
+
+	# Pick the indent from the front of the line.
+	my ($white) = ($line =~ /^(\s*)/);
+
+	return (length($line), length($white));
+}
+
+my $sanitise_quote = '';
+
+sub sanitise_line_reset {
+	my ($in_comment) = @_;
+
+	if ($in_comment) {
+		$sanitise_quote = '*/';
+	} else {
+		$sanitise_quote = '';
+	}
+}
+sub sanitise_line {
+	my ($line) = @_;
+
+	my $res = '';
+	my $l = '';
+
+	my $qlen = 0;
+	my $off = 0;
+	my $c;
+
+	# Always copy over the diff marker.
+	$res = substr($line, 0, 1);
+
+	for ($off = 1; $off &lt; length($line); $off++) {
+		$c = substr($line, $off, 1);
+
+		# Comments we are wacking completly including the begin
+		# and end, all to $;.
+		if ($sanitise_quote eq '' &amp;&amp; substr($line, $off, 2) eq '/*') {
+			$sanitise_quote = '*/';
+
+			substr($res, $off, 2, &quot;$;$;&quot;);
+			$off++;
+			next;
+		}
+		if ($sanitise_quote eq '*/' &amp;&amp; substr($line, $off, 2) eq '*/') {
+			$sanitise_quote = '';
+			substr($res, $off, 2, &quot;$;$;&quot;);
+			$off++;
+			next;
+		}
+		if ($sanitise_quote eq '' &amp;&amp; substr($line, $off, 2) eq '//') {
+			$sanitise_quote = '//';
+
+			substr($res, $off, 2, $sanitise_quote);
+			$off++;
+			next;
+		}
+
+		# A \ in a string means ignore the next character.
+		if (($sanitise_quote eq &quot;'&quot; || $sanitise_quote eq '&quot;') &amp;&amp;
+		    $c eq &quot;\\&quot;) {
+			substr($res, $off, 2, 'XX');
+			$off++;
+			next;
+		}
+		# Regular quotes.
+		if ($c eq &quot;'&quot; || $c eq '&quot;') {
+			if ($sanitise_quote eq '') {
+				$sanitise_quote = $c;
+
+				substr($res, $off, 1, $c);
+				next;
+			} elsif ($sanitise_quote eq $c) {
+				$sanitise_quote = '';
+			}
+		}
+
+		#print &quot;c&lt;$c&gt; SQ&lt;$sanitise_quote&gt;\n&quot;;
+		if ($off != 0 &amp;&amp; $sanitise_quote eq '*/' &amp;&amp; $c ne &quot;\t&quot;) {
+			substr($res, $off, 1, $;);
+		} elsif ($off != 0 &amp;&amp; $sanitise_quote eq '//' &amp;&amp; $c ne &quot;\t&quot;) {
+			substr($res, $off, 1, $;);
+		} elsif ($off != 0 &amp;&amp; $sanitise_quote &amp;&amp; $c ne &quot;\t&quot;) {
+			substr($res, $off, 1, 'X');
+		} else {
+			substr($res, $off, 1, $c);
+		}
+	}
+
+	if ($sanitise_quote eq '//') {
+		$sanitise_quote = '';
+	}
+
+	# The pathname on a #include may be surrounded by '&lt;' and '&gt;'.
+	if ($res =~ /^.\s*\#\s*include\s+\&lt;(.*)\&gt;/) {
+		my $clean = 'X' x length($1);
+		$res =~ s@\&lt;.*\&gt;@&lt;$clean&gt;@;
+
+	# The whole of a #error is a string.
+	} elsif ($res =~ /^.\s*\#\s*(?:error|warning)\s+(.*)\b/) {
+		my $clean = 'X' x length($1);
+		$res =~ s@(\#\s*(?:error|warning)\s+).*@$1$clean@;
+	}
+
+	return $res;
+}
+
+sub ctx_statement_block {
+	my ($linenr, $remain, $off) = @_;
+	my $line = $linenr - 1;
+	my $blk = '';
+	my $soff = $off;
+	my $coff = $off - 1;
+	my $coff_set = 0;
+
+	my $loff = 0;
+
+	my $type = '';
+	my $level = 0;
+	my @stack = ();
+	my $p;
+	my $c;
+	my $len = 0;
+
+	my $remainder;
+	while (1) {
+		@stack = (['', 0]) if ($#stack == -1);
+
+		#warn &quot;CSB: blk&lt;$blk&gt; remain&lt;$remain&gt;\n&quot;;
+		# If we are about to drop off the end, pull in more
+		# context.
+		if ($off &gt;= $len) {
+			for (; $remain &gt; 0; $line++) {
+				last if (!defined $lines[$line]);
+				next if ($lines[$line] =~ /^-/);
+				$remain--;
+				$loff = $len;
+				$blk .= $lines[$line] . &quot;\n&quot;;
+				$len = length($blk);
+				$line++;
+				last;
+			}
+			# Bail if there is no further context.
+			#warn &quot;CSB: blk&lt;$blk&gt; off&lt;$off&gt; len&lt;$len&gt;\n&quot;;
+			if ($off &gt;= $len) {
+				last;
+			}
+		}
+		$p = $c;
+		$c = substr($blk, $off, 1);
+		$remainder = substr($blk, $off);
+
+		#warn &quot;CSB: c&lt;$c&gt; type&lt;$type&gt; level&lt;$level&gt; remainder&lt;$remainder&gt; coff_set&lt;$coff_set&gt;\n&quot;;
+
+		# Handle nested #if/#else.
+		if ($remainder =~ /^#\s*(?:ifndef|ifdef|if)\s/) {
+			push(@stack, [ $type, $level ]);
+		} elsif ($remainder =~ /^#\s*(?:else|elif)\b/) {
+			($type, $level) = @{$stack[$#stack - 1]};
+		} elsif ($remainder =~ /^#\s*endif\b/) {
+			($type, $level) = @{pop(@stack)};
+		}
+
+		# Statement ends at the ';' or a close '}' at the
+		# outermost level.
+		if ($level == 0 &amp;&amp; $c eq ';') {
+			last;
+		}
+
+		# An else is really a conditional as long as its not else if
+		if ($level == 0 &amp;&amp; $coff_set == 0 &amp;&amp;
+				(!defined($p) || $p =~ /(?:\s|\}|\+)/) &amp;&amp;
+				$remainder =~ /^(else)(?:\s|{)/ &amp;&amp;
+				$remainder !~ /^else\s+if\b/) {
+			$coff = $off + length($1) - 1;
+			$coff_set = 1;
+			#warn &quot;CSB: mark coff&lt;$coff&gt; soff&lt;$soff&gt; 1&lt;$1&gt;\n&quot;;
+			#warn &quot;[&quot; . substr($blk, $soff, $coff - $soff + 1) . &quot;]\n&quot;;
+		}
+
+		if (($type eq '' || $type eq '(') &amp;&amp; $c eq '(') {
+			$level++;
+			$type = '(';
+		}
+		if ($type eq '(' &amp;&amp; $c eq ')') {
+			$level--;
+			$type = ($level != 0)? '(' : '';
+
+			if ($level == 0 &amp;&amp; $coff &lt; $soff) {
+				$coff = $off;
+				$coff_set = 1;
+				#warn &quot;CSB: mark coff&lt;$coff&gt;\n&quot;;
+			}
+		}
+		if (($type eq '' || $type eq '{') &amp;&amp; $c eq '{') {
+			$level++;
+			$type = '{';
+		}
+		if ($type eq '{' &amp;&amp; $c eq '}') {
+			$level--;
+			$type = ($level != 0)? '{' : '';
+
+			if ($level == 0) {
+				if (substr($blk, $off + 1, 1) eq ';') {
+					$off++;
+				}
+				last;
+			}
+		}
+		$off++;
+	}
+	# We are truly at the end, so shuffle to the next line.
+	if ($off == $len) {
+		$loff = $len + 1;
+		$line++;
+		$remain--;
+	}
+
+	my $statement = substr($blk, $soff, $off - $soff + 1);
+	my $condition = substr($blk, $soff, $coff - $soff + 1);
+
+	#warn &quot;STATEMENT&lt;$statement&gt;\n&quot;;
+	#warn &quot;CONDITION&lt;$condition&gt;\n&quot;;
+
+	#print &quot;coff&lt;$coff&gt; soff&lt;$off&gt; loff&lt;$loff&gt;\n&quot;;
+
+	return ($statement, $condition,
+			$line, $remain + 1, $off - $loff + 1, $level);
+}
+
+sub statement_lines {
+	my ($stmt) = @_;
+
+	# Strip the diff line prefixes and rip blank lines at start and end.
+	$stmt =~ s/(^|\n)./$1/g;
+	$stmt =~ s/^\s*//;
+	$stmt =~ s/\s*$//;
+
+	my @stmt_lines = ($stmt =~ /\n/g);
+
+	return $#stmt_lines + 2;
+}
+
+sub statement_rawlines {
+	my ($stmt) = @_;
+
+	my @stmt_lines = ($stmt =~ /\n/g);
+
+	return $#stmt_lines + 2;
+}
+
+sub statement_block_size {
+	my ($stmt) = @_;
+
+	$stmt =~ s/(^|\n)./$1/g;
+	$stmt =~ s/^\s*{//;
+	$stmt =~ s/}\s*$//;
+	$stmt =~ s/^\s*//;
+	$stmt =~ s/\s*$//;
+
+	my @stmt_lines = ($stmt =~ /\n/g);
+	my @stmt_statements = ($stmt =~ /;/g);
+
+	my $stmt_lines = $#stmt_lines + 2;
+	my $stmt_statements = $#stmt_statements + 1;
+
+	if ($stmt_lines &gt; $stmt_statements) {
+		return $stmt_lines;
+	} else {
+		return $stmt_statements;
+	}
+}
+
+sub ctx_statement_full {
+	my ($linenr, $remain, $off) = @_;
+	my ($statement, $condition, $level);
+
+	my (@chunks);
+
+	# Grab the first conditional/block pair.
+	($statement, $condition, $linenr, $remain, $off, $level) =
+				ctx_statement_block($linenr, $remain, $off);
+	#print &quot;F: c&lt;$condition&gt; s&lt;$statement&gt; remain&lt;$remain&gt;\n&quot;;
+	push(@chunks, [ $condition, $statement ]);
+	if (!($remain &gt; 0 &amp;&amp; $condition =~ /^\s*(?:\n[+-])?\s*(?:if|else|do)\b/s)) {
+		return ($level, $linenr, @chunks);
+	}
+
+	# Pull in the following conditional/block pairs and see if they
+	# could continue the statement.
+	for (;;) {
+		($statement, $condition, $linenr, $remain, $off, $level) =
+				ctx_statement_block($linenr, $remain, $off);
+		#print &quot;C: c&lt;$condition&gt; s&lt;$statement&gt; remain&lt;$remain&gt;\n&quot;;
+		last if (!($remain &gt; 0 &amp;&amp; $condition =~ /^(?:\s*\n[+-])*\s*(?:else|do)\b/s));
+		#print &quot;C: push\n&quot;;
+		push(@chunks, [ $condition, $statement ]);
+	}
+
+	return ($level, $linenr, @chunks);
+}
+
+sub ctx_block_get {
+	my ($linenr, $remain, $outer, $open, $close, $off) = @_;
+	my $line;
+	my $start = $linenr - 1;
+	my $blk = '';
+	my @o;
+	my @c;
+	my @res = ();
+
+	my $level = 0;
+	my @stack = ($level);
+	for ($line = $start; $remain &gt; 0; $line++) {
+		next if ($rawlines[$line] =~ /^-/);
+		$remain--;
+
+		$blk .= $rawlines[$line];
+
+		# Handle nested #if/#else.
+		if ($lines[$line] =~ /^.\s*#\s*(?:ifndef|ifdef|if)\s/) {
+			push(@stack, $level);
+		} elsif ($lines[$line] =~ /^.\s*#\s*(?:else|elif)\b/) {
+			$level = $stack[$#stack - 1];
+		} elsif ($lines[$line] =~ /^.\s*#\s*endif\b/) {
+			$level = pop(@stack);
+		}
+
+		foreach my $c (split(//, $lines[$line])) {
+			##print &quot;C&lt;$c&gt;L&lt;$level&gt;&lt;$open$close&gt;O&lt;$off&gt;\n&quot;;
+			if ($off &gt; 0) {
+				$off--;
+				next;
+			}
+
+			if ($c eq $close &amp;&amp; $level &gt; 0) {
+				$level--;
+				last if ($level == 0);
+			} elsif ($c eq $open) {
+				$level++;
+			}
+		}
+
+		if (!$outer || $level &lt;= 1) {
+			push(@res, $rawlines[$line]);
+		}
+
+		last if ($level == 0);
+	}
+
+	return ($level, @res);
+}
+sub ctx_block_outer {
+	my ($linenr, $remain) = @_;
+
+	my ($level, @r) = ctx_block_get($linenr, $remain, 1, '{', '}', 0);
+	return @r;
+}
+sub ctx_block {
+	my ($linenr, $remain) = @_;
+
+	my ($level, @r) = ctx_block_get($linenr, $remain, 0, '{', '}', 0);
+	return @r;
+}
+sub ctx_statement {
+	my ($linenr, $remain, $off) = @_;
+
+	my ($level, @r) = ctx_block_get($linenr, $remain, 0, '(', ')', $off);
+	return @r;
+}
+sub ctx_block_level {
+	my ($linenr, $remain) = @_;
+
+	return ctx_block_get($linenr, $remain, 0, '{', '}', 0);
+}
+sub ctx_statement_level {
+	my ($linenr, $remain, $off) = @_;
+
+	return ctx_block_get($linenr, $remain, 0, '(', ')', $off);
+}
+
+sub ctx_locate_comment {
+	my ($first_line, $end_line) = @_;
+
+	# Catch a comment on the end of the line itself.
+	my ($current_comment) = ($rawlines[$end_line - 1] =~ <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">m at .</A>*(/\*.*\*/)\s*(?:\\\s*)?$@);
+	return $current_comment if (defined $current_comment);
+
+	# Look through the context and try and figure out if there is a
+	# comment.
+	my $in_comment = 0;
+	$current_comment = '';
+	for (my $linenr = $first_line; $linenr &lt; $end_line; $linenr++) {
+		my $line = $rawlines[$linenr - 1];
+		#warn &quot;           $line\n&quot;;
+		if ($linenr == $first_line and $line =~ m@^.\s*\*@) {
+			$in_comment = 1;
+		}
+		if ($line =~ m@/\*@) {
+			$in_comment = 1;
+		}
+		if (!$in_comment &amp;&amp; $current_comment ne '') {
+			$current_comment = '';
+		}
+		$current_comment .= $line . &quot;\n&quot; if ($in_comment);
+		if ($line =~ m@\*/@) {
+			$in_comment = 0;
+		}
+	}
+
+	chomp($current_comment);
+	return($current_comment);
+}
+sub ctx_has_comment {
+	my ($first_line, $end_line) = @_;
+	my $cmt = ctx_locate_comment($first_line, $end_line);
+
+	##print &quot;LINE: $rawlines[$end_line - 1 ]\n&quot;;
+	##print &quot;CMMT: $cmt\n&quot;;
+
+	return ($cmt ne '');
+}
+
+sub raw_line {
+	my ($linenr, $cnt) = @_;
+
+	my $offset = $linenr - 1;
+	$cnt++;
+
+	my $line;
+	while ($cnt) {
+		$line = $rawlines[$offset++];
+		next if (defined($line) &amp;&amp; $line =~ /^-/);
+		$cnt--;
+	}
+
+	return $line;
+}
+
+sub cat_vet {
+	my ($vet) = @_;
+	my ($res, $coded);
+
+	$res = '';
+	while ($vet =~ /([^[:cntrl:]]*)([[:cntrl:]]|$)/g) {
+		$res .= $1;
+		if ($2 ne '') {
+			$coded = sprintf(&quot;^%c&quot;, unpack('C', $2) + 64);
+			$res .= $coded;
+		}
+	}
+	$res =~ s/$/\$/;
+
+	return $res;
+}
+
+my $av_preprocessor = 0;
+my $av_pending;
+my @av_paren_type;
+my $av_pend_colon;
+
+sub annotate_reset {
+	$av_preprocessor = 0;
+	$av_pending = '_';
+	@av_paren_type = ('E');
+	$av_pend_colon = 'O';
+}
+
+sub annotate_values {
+	my ($stream, $type) = @_;
+
+	my $res;
+	my $var = '_' x length($stream);
+	my $cur = $stream;
+
+	print &quot;$stream\n&quot; if ($dbg_values &gt; 1);
+
+	while (length($cur)) {
+		@av_paren_type = ('E') if ($#av_paren_type &lt; 0);
+		print &quot; &lt;&quot; . join('', @av_paren_type) .
+				&quot;&gt; &lt;$type&gt; &lt;$av_pending&gt;&quot; if ($dbg_values &gt; 1);
+		if ($cur =~ /^(\s+)/o) {
+			print &quot;WS($1)\n&quot; if ($dbg_values &gt; 1);
+			if ($1 =~ /\n/ &amp;&amp; $av_preprocessor) {
+				$type = pop(@av_paren_type);
+				$av_preprocessor = 0;
+			}
+
+		} elsif ($cur =~ /^(\(\s*$Type\s*)\)/ &amp;&amp; $av_pending eq '_') {
+			print &quot;CAST($1)\n&quot; if ($dbg_values &gt; 1);
+			push(@av_paren_type, $type);
+			$type = 'C';
+
+		} elsif ($cur =~ /^($Type)\s*(?:$Ident|,|\)|\(|\s*$)/) {
+			print &quot;DECLARE($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'T';
+
+		} elsif ($cur =~ /^($Modifier)\s*/) {
+			print &quot;MODIFIER($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'T';
+
+		} elsif ($cur =~ /^(\#\s*define\s*$Ident)(\(?)/o) {
+			print &quot;DEFINE($1,$2)\n&quot; if ($dbg_values &gt; 1);
+			$av_preprocessor = 1;
+			push(@av_paren_type, $type);
+			if ($2 ne '') {
+				$av_pending = 'N';
+			}
+			$type = 'E';
+
+		} elsif ($cur =~ /^(\#\s*(?:undef\s*$Ident|include\b))/o) {
+			print &quot;UNDEF($1)\n&quot; if ($dbg_values &gt; 1);
+			$av_preprocessor = 1;
+			push(@av_paren_type, $type);
+
+		} elsif ($cur =~ /^(\#\s*(?:ifdef|ifndef|if))/o) {
+			print &quot;PRE_START($1)\n&quot; if ($dbg_values &gt; 1);
+			$av_preprocessor = 1;
+
+			push(@av_paren_type, $type);
+			push(@av_paren_type, $type);
+			$type = 'E';
+
+		} elsif ($cur =~ /^(\#\s*(?:else|elif))/o) {
+			print &quot;PRE_RESTART($1)\n&quot; if ($dbg_values &gt; 1);
+			$av_preprocessor = 1;
+
+			push(@av_paren_type, $av_paren_type[$#av_paren_type]);
+
+			$type = 'E';
+
+		} elsif ($cur =~ /^(\#\s*(?:endif))/o) {
+			print &quot;PRE_END($1)\n&quot; if ($dbg_values &gt; 1);
+
+			$av_preprocessor = 1;
+
+			# Assume all arms of the conditional end as this
+			# one does, and continue as if the #endif was not here.
+			pop(@av_paren_type);
+			push(@av_paren_type, $type);
+			$type = 'E';
+
+		} elsif ($cur =~ /^(\\\n)/o) {
+			print &quot;PRECONT($1)\n&quot; if ($dbg_values &gt; 1);
+
+		} elsif ($cur =~ /^(__attribute__)\s*\(?/o) {
+			print &quot;ATTR($1)\n&quot; if ($dbg_values &gt; 1);
+			$av_pending = $type;
+			$type = 'N';
+
+		} elsif ($cur =~ /^(sizeof)\s*(\()?/o) {
+			print &quot;SIZEOF($1)\n&quot; if ($dbg_values &gt; 1);
+			if (defined $2) {
+				$av_pending = 'V';
+			}
+			$type = 'N';
+
+		} elsif ($cur =~ /^(if|while|for)\b/o) {
+			print &quot;COND($1)\n&quot; if ($dbg_values &gt; 1);
+			$av_pending = 'E';
+			$type = 'N';
+
+		} elsif ($cur =~/^(case)/o) {
+			print &quot;CASE($1)\n&quot; if ($dbg_values &gt; 1);
+			$av_pend_colon = 'C';
+			$type = 'N';
+
+		} elsif ($cur =~/^(return|else|goto|typeof|__typeof__)\b/o) {
+			print &quot;KEYWORD($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'N';
+
+		} elsif ($cur =~ /^(\()/o) {
+			print &quot;PAREN('$1')\n&quot; if ($dbg_values &gt; 1);
+			push(@av_paren_type, $av_pending);
+			$av_pending = '_';
+			$type = 'N';
+
+		} elsif ($cur =~ /^(\))/o) {
+			my $new_type = pop(@av_paren_type);
+			if ($new_type ne '_') {
+				$type = $new_type;
+				print &quot;PAREN('$1') -&gt; $type\n&quot;
+							if ($dbg_values &gt; 1);
+			} else {
+				print &quot;PAREN('$1')\n&quot; if ($dbg_values &gt; 1);
+			}
+
+		} elsif ($cur =~ /^($Ident)\s*\(/o) {
+			print &quot;FUNC($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'V';
+			$av_pending = 'V';
+
+		} elsif ($cur =~ /^($Ident\s*):(?:\s*\d+\s*(,|=|;))?/) {
+			if (defined $2 &amp;&amp; $type eq 'C' || $type eq 'T') {
+				$av_pend_colon = 'B';
+			} elsif ($type eq 'E') {
+				$av_pend_colon = 'L';
+			}
+			print &quot;IDENT_COLON($1,$type&gt;$av_pend_colon)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'V';
+
+		} elsif ($cur =~ /^($Ident|$Constant)/o) {
+			print &quot;IDENT($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'V';
+
+		} elsif ($cur =~ /^($Assignment)/o) {
+			print &quot;ASSIGN($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'N';
+
+		} elsif ($cur =~/^(;|{|})/) {
+			print &quot;END($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'E';
+			$av_pend_colon = 'O';
+
+		} elsif ($cur =~/^(,)/) {
+			print &quot;COMMA($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'C';
+
+		} elsif ($cur =~ /^(\?)/o) {
+			print &quot;QUESTION($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'N';
+
+		} elsif ($cur =~ /^(:)/o) {
+			print &quot;COLON($1,$av_pend_colon)\n&quot; if ($dbg_values &gt; 1);
+
+			substr($var, length($res), 1, $av_pend_colon);
+			if ($av_pend_colon eq 'C' || $av_pend_colon eq 'L') {
+				$type = 'E';
+			} else {
+				$type = 'N';
+			}
+			$av_pend_colon = 'O';
+
+		} elsif ($cur =~ /^(\[)/o) {
+			print &quot;CLOSE($1)\n&quot; if ($dbg_values &gt; 1);
+			$type = 'N';
+
+		} elsif ($cur =~ /^(-(?![-&gt;])|\+(?!\+)|\*|\&amp;\&amp;|\&amp;)/o) {
+			my $variant;
+
+			print &quot;OPV($1)\n&quot; if ($dbg_values &gt; 1);
+			if ($type eq 'V') {
+				$variant = 'B';
+			} else {
+				$variant = 'U';
+			}
+
+			substr($var, length($res), 1, $variant);
+			$type = 'N';
+
+		} elsif ($cur =~ /^($Operators)/o) {
+			print &quot;OP($1)\n&quot; if ($dbg_values &gt; 1);
+			if ($1 ne '++' &amp;&amp; $1 ne '--') {
+				$type = 'N';
+			}
+
+		} elsif ($cur =~ /(^.)/o) {
+			print &quot;C($1)\n&quot; if ($dbg_values &gt; 1);
+		}
+		if (defined $1) {
+			$cur = substr($cur, length($1));
+			$res .= $type x length($1);
+		}
+	}
+
+	return ($res, $var);
+}
+
+sub possible {
+	my ($possible, $line) = @_;
+	my $notPermitted = qr{(?:
+		^(?:
+			$Modifier|
+			$Storage|
+			$Type|
+			DEFINE_\S+
+		)$|
+		^(?:
+			goto|
+			return|
+			case|
+			else|
+			asm|__asm__|
+			do
+		)(?:\s|$)|
+		^(?:typedef|struct|enum)\b
+	    )}x;
+	warn &quot;CHECK&lt;$possible&gt; ($line)\n&quot; if ($dbg_possible &gt; 2);
+	if ($possible !~ $notPermitted) {
+		# Check for modifiers.
+		$possible =~ s/\s*$Storage\s*//g;
+		$possible =~ s/\s*$Sparse\s*//g;
+		if ($possible =~ /^\s*$/) {
+
+		} elsif ($possible =~ /\s/) {
+			$possible =~ s/\s*$Type\s*//g;
+			for my $modifier (split(' ', $possible)) {
+				if ($modifier !~ $notPermitted) {
+					warn &quot;MODIFIER: $modifier ($possible) ($line)\n&quot; if ($dbg_possible);
+					push(@modifierList, $modifier);
+				}
+			}
+
+		} else {
+			warn &quot;POSSIBLE: $possible ($line)\n&quot; if ($dbg_possible);
+			push(@typeList, $possible);
+		}
+		build_types();
+	} else {
+		warn &quot;NOTPOSS: $possible ($line)\n&quot; if ($dbg_possible &gt; 1);
+	}
+}
+
+my $prefix = '';
+
+sub show_type {
+       return !defined $ignore_type{$_[0]};
+}
+
+sub report {
+	if (!show_type($_[1]) ||
+	    (defined $tst_only &amp;&amp; $_[2] !~ /\Q$tst_only\E/)) {
+		return 0;
+	}
+	my $line;
+	if ($show_types) {
+		$line = &quot;$prefix$_[0]:$_[1]: $_[2]\n&quot;;
+	} else {
+		$line = &quot;$prefix$_[0]: $_[2]\n&quot;;
+	}
+	$line = (split('\n', $line))[0] . &quot;\n&quot; if ($terse);
+
+	push(our @report, $line);
+
+	return 1;
+}
+sub report_dump {
+	our @report;
+}
+
+sub ERROR {
+	if (report(&quot;ERROR&quot;, $_[0], $_[1])) {
+		our $clean = 0;
+		our $cnt_error++;
+	}
+}
+sub WARN {
+	if (report(&quot;WARNING&quot;, $_[0], $_[1])) {
+		our $clean = 0;
+		our $cnt_warn++;
+	}
+}
+sub CHK {
+	if ($check &amp;&amp; report(&quot;CHECK&quot;, $_[0], $_[1])) {
+		our $clean = 0;
+		our $cnt_chk++;
+	}
+}
+
+sub check_absolute_file {
+	my ($absolute, $herecurr) = @_;
+	my $file = $absolute;
+
+	##print &quot;absolute&lt;$absolute&gt;\n&quot;;
+
+	# See if any suffix of this path is a path within the tree.
+	while ($file =~ s@^[^/]*/@@) {
+		if (-f &quot;$root/$file&quot;) {
+			##print &quot;file&lt;$file&gt;\n&quot;;
+			last;
+		}
+	}
+	if (! -f _)  {
+		return 0;
+	}
+
+	# It is, so see if the prefix is acceptable.
+	my $prefix = $absolute;
+	substr($prefix, -length($file)) = '';
+
+	##print &quot;prefix&lt;$prefix&gt;\n&quot;;
+	if ($prefix ne &quot;.../&quot;) {
+		WARN(&quot;USE_RELATIVE_PATH&quot;,
+		     &quot;use relative pathname instead of absolute in changelog text\n&quot; . $herecurr);
+	}
+}
+
+sub process {
+	my $filename = shift;
+
+	my $linenr=0;
+	my $prevline=&quot;&quot;;
+	my $prevrawline=&quot;&quot;;
+	my $stashline=&quot;&quot;;
+	my $stashrawline=&quot;&quot;;
+
+	my $length;
+	my $indent;
+	my $previndent=0;
+	my $stashindent=0;
+
+	our $clean = 1;
+	my $signoff = 0;
+	my $is_patch = 0;
+
+	our @report = ();
+	our $cnt_lines = 0;
+	our $cnt_error = 0;
+	our $cnt_warn = 0;
+	our $cnt_chk = 0;
+
+	# Trace the real file/line as we go.
+	my $realfile = '';
+	my $realline = 0;
+	my $realcnt = 0;
+	my $here = '';
+	my $in_comment = 0;
+	my $comment_edge = 0;
+	my $first_line = 0;
+	my $p1_prefix = '';
+
+	my $prev_values = 'E';
+
+	# suppression flags
+	my %suppress_ifbraces;
+	my %suppress_whiletrailers;
+	my %suppress_export;
+
+	# Pre-scan the patch sanitizing the lines.
+	# Pre-scan the patch looking for any __setup documentation.
+	#
+	my @setup_docs = ();
+	my $setup_docs = 0;
+
+	sanitise_line_reset();
+	my $line;
+	foreach my $rawline (@rawlines) {
+		$linenr++;
+		$line = $rawline;
+
+		if ($rawline=~/^\+\+\+\s+(\S+)/) {
+			$setup_docs = 0;
+			if ($1 =~ <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">m at Documentation</A>/kernel-parameters.txt$@) {
+				$setup_docs = 1;
+			}
+			#next;
+		}
+		if ($rawline=~/^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@/) {
+			$realline=$1-1;
+			if (defined $2) {
+				$realcnt=$3+1;
+			} else {
+				$realcnt=1+1;
+			}
+			$in_comment = 0;
+
+			# Guestimate if this is a continuing comment.  Run
+			# the context looking for a comment &quot;edge&quot;.  If this
+			# edge is a close comment then we must be in a comment
+			# at context start.
+			my $edge;
+			my $cnt = $realcnt;
+			for (my $ln = $linenr + 1; $cnt &gt; 0; $ln++) {
+				next if (defined $rawlines[$ln - 1] &amp;&amp;
+					 $rawlines[$ln - 1] =~ /^-/);
+				$cnt--;
+				#print &quot;RAW&lt;$rawlines[$ln - 1]&gt;\n&quot;;
+				last if (!defined $rawlines[$ln - 1]);
+				if ($rawlines[$ln - 1] =~ m@(/\*|\*/)@ &amp;&amp;
+				    $rawlines[$ln - 1] !~ m@&quot;[^&quot;]*(?:/\*|\*/)[^&quot;]*&quot;@) {
+					($edge) = $1;
+					last;
+				}
+			}
+			if (defined $edge &amp;&amp; $edge eq '*/') {
+				$in_comment = 1;
+			}
+
+			# Guestimate if this is a continuing comment.  If this
+			# is the start of a diff block and this line starts
+			# ' *' then it is very likely a comment.
+			if (!defined $edge &amp;&amp;
+			    $rawlines[$linenr] =~ m@^.\s*(?:\*\*+| \*)(?:\s|$)@)
+			{
+				$in_comment = 1;
+			}
+
+			##print &quot;COMMENT:$in_comment edge&lt;$edge&gt; $rawline\n&quot;;
+			sanitise_line_reset($in_comment);
+
+		} elsif ($realcnt &amp;&amp; $rawline =~ /^(?:\+| |$)/) {
+			# Standardise the strings and chars within the input to
+			# simplify matching -- only bother with positive lines.
+			$line = sanitise_line($rawline);
+		}
+		push(@lines, $line);
+
+		if ($realcnt &gt; 1) {
+			$realcnt-- if ($line =~ /^(?:\+| |$)/);
+		} else {
+			$realcnt = 0;
+		}
+
+		#print &quot;==&gt;$rawline\n&quot;;
+		#print &quot;--&gt;$line\n&quot;;
+
+		if ($setup_docs &amp;&amp; $line =~ /^\+/) {
+			push(@setup_docs, $line);
+		}
+	}
+
+	$prefix = '';
+
+	$realcnt = 0;
+	$linenr = 0;
+	foreach my $line (@lines) {
+		$linenr++;
+
+		my $rawline = $rawlines[$linenr - 1];
+
+#extract the line range in the file after the patch is applied
+		if ($line=~/^\@\@ -\d+(?:,\d+)? \+(\d+)(,(\d+))? \@\@/) {
+			$is_patch = 1;
+			$first_line = $linenr + 1;
+			$realline=$1-1;
+			if (defined $2) {
+				$realcnt=$3+1;
+			} else {
+				$realcnt=1+1;
+			}
+			annotate_reset();
+			$prev_values = 'E';
+
+			%suppress_ifbraces = ();
+			%suppress_whiletrailers = ();
+			%suppress_export = ();
+			next;
+
+# track the line number as we move through the hunk, note that
+# new versions of GNU diff omit the leading space on completely
+# blank context lines so we need to count that too.
+		} elsif ($line =~ /^( |\+|$)/) {
+			$realline++;
+			$realcnt-- if ($realcnt != 0);
+
+			# Measure the line length and indent.
+			($length, $indent) = line_stats($rawline);
+
+			# Track the previous line.
+			($prevline, $stashline) = ($stashline, $line);
+			($previndent, $stashindent) = ($stashindent, $indent);
+			($prevrawline, $stashrawline) = ($stashrawline, $rawline);
+
+			#warn &quot;line&lt;$line&gt;\n&quot;;
+
+		} elsif ($realcnt == 1) {
+			$realcnt--;
+		}
+
+		my $hunk_line = ($realcnt != 0);
+
+#make up the handle for any error we report on this line
+		$prefix = &quot;$filename:$realline: &quot; if ($emacs &amp;&amp; $file);
+		$prefix = &quot;$filename:$linenr: &quot; if ($emacs &amp;&amp; !$file);
+
+		$here = &quot;#$linenr: &quot; if (!$file);
+		$here = &quot;#$realline: &quot; if ($file);
+
+		# extract the filename as it passes
+		if ($line =~ /^diff --git.*?(\S+)$/) {
+			$realfile = $1;
+			$realfile =~ s@^([^/]*)/@@;
+
+		} elsif ($line =~ /^\+\+\+\s+(\S+)/) {
+			$realfile = $1;
+			$realfile =~ s@^([^/]*)/@@;
+
+			$p1_prefix = $1;
+			if (!$file &amp;&amp; $tree &amp;&amp; $p1_prefix ne '' &amp;&amp;
+			    -e &quot;$root/$p1_prefix&quot;) {
+				WARN(&quot;PATCH_PREFIX&quot;,
+				     &quot;patch prefix '$p1_prefix' exists, appears to be a -p0 patch\n&quot;);
+			}
+
+			if ($realfile =~ m@^include/asm/@) {
+				ERROR(&quot;MODIFIED_INCLUDE_ASM&quot;,
+				      &quot;do not modify files in include/asm, change architecture specific files in include/asm-&lt;architecture&gt;\n&quot; . &quot;$here$rawline\n&quot;);
+			}
+			next;
+		}
+
+		$here .= &quot;FILE: $realfile:$realline:&quot; if ($realcnt != 0);
+
+		my $hereline = &quot;$here\n$rawline\n&quot;;
+		my $herecurr = &quot;$here\n$rawline\n&quot;;
+		my $hereprev = &quot;$here\n$prevrawline\n$rawline\n&quot;;
+
+		$cnt_lines++ if ($realcnt != 0);
+
+# Check for incorrect file permissions
+		if ($line =~ /^new (file )?mode.*[7531]\d{0,2}$/) {
+			my $permhere = $here . &quot;FILE: $realfile\n&quot;;
+			if ($realfile =~ /(Makefile|Kconfig|\.c|\.h|\.S|\.tmpl)$/) {
+				ERROR(&quot;EXECUTE_PERMISSIONS&quot;,
+				      &quot;do not set execute permissions for source files\n&quot; . $permhere);
+			}
+		}
+
+# Check the patch for a signoff:
+		if ($line =~ /^\s*signed-off-by:/i) {
+			$signoff++;
+		}
+
+# Check signature styles
+		if ($line =~ /^(\s*)($signature_tags)(\s*)(.*)/) {
+			my $space_before = $1;
+			my $sign_off = $2;
+			my $space_after = $3;
+			my $email = $4;
+			my $ucfirst_sign_off = ucfirst(lc($sign_off));
+
+			if (defined $space_before &amp;&amp; $space_before ne &quot;&quot;) {
+				WARN(&quot;BAD_SIGN_OFF&quot;,
+				     &quot;Do not use whitespace before $ucfirst_sign_off\n&quot; . $herecurr);
+			}
+			if ($sign_off =~ /-by:$/i &amp;&amp; $sign_off ne $ucfirst_sign_off) {
+				WARN(&quot;BAD_SIGN_OFF&quot;,
+				     &quot;'$ucfirst_sign_off' is the preferred signature form\n&quot; . $herecurr);
+			}
+			if (!defined $space_after || $space_after ne &quot; &quot;) {
+				WARN(&quot;BAD_SIGN_OFF&quot;,
+				     &quot;Use a single space after $ucfirst_sign_off\n&quot; . $herecurr);
+			}
+
+			my ($email_name, $email_address, $comment) = parse_email($email);
+			my $suggested_email = format_email(($email_name, $email_address));
+			if ($suggested_email eq &quot;&quot;) {
+				ERROR(&quot;BAD_SIGN_OFF&quot;,
+				      &quot;Unrecognized email address: '$email'\n&quot; . $herecurr);
+			} else {
+				my $dequoted = $suggested_email;
+				$dequoted =~ s/^&quot;//;
+				$dequoted =~ s/&quot; &lt;/ &lt;/;
+				# Don't force email to have quotes
+				# Allow just an angle bracketed address
+				if (&quot;$dequoted$comment&quot; ne $email &amp;&amp;
+				    &quot;&lt;$email_address&gt;$comment&quot; ne $email &amp;&amp;
+				    &quot;$suggested_email$comment&quot; ne $email) {
+					WARN(&quot;BAD_SIGN_OFF&quot;,
+					     &quot;email address '$email' might be better as '$suggested_email$comment'\n&quot; . $herecurr);
+				}
+			}
+		}
+
+# Check for wrappage within a valid hunk of the file
+		if ($realcnt != 0 &amp;&amp; $line !~ m{^(?:\+|-| |\\ No newline|$)}) {
+			ERROR(&quot;CORRUPTED_PATCH&quot;,
+			      &quot;patch seems to be corrupt (line wrapped?)\n&quot; .
+				$herecurr) if (!$emitted_corrupt++);
+		}
+
+# Check for absolute kernel paths.
+		if ($tree) {
+			while ($line =~ m{(?:^|\s)(/\S*)}g) {
+				my $file = $1;
+
+				if ($file =~ m{^(.*?)(?::\d+)+:?$} &amp;&amp;
+				    check_absolute_file($1, $herecurr)) {
+					#
+				} else {
+					check_absolute_file($file, $herecurr);
+				}
+			}
+		}
+
+# UTF-8 regex found at <A HREF="http://www.w3.org/International/questions/qa-forms-utf-8.en.php">http://www.w3.org/International/questions/qa-forms-utf-8.en.php</A>
+		if (($realfile =~ /^$/ || $line =~ /^\+/) &amp;&amp;
+		    $rawline !~ m/^$UTF8*$/) {
+			my ($utf8_prefix) = ($rawline =~ /^($UTF8*)/);
+
+			my $blank = copy_spacing($rawline);
+			my $ptr = substr($blank, 0, length($utf8_prefix)) . &quot;^&quot;;
+			my $hereptr = &quot;$hereline$ptr\n&quot;;
+
+			CHK(&quot;INVALID_UTF8&quot;,
+			    &quot;Invalid UTF-8, patch and commit message should be encoded in UTF-8\n&quot; . $hereptr);
+		}
+
+# ignore non-hunk lines and lines being removed
+		next if (!$hunk_line || $line =~ /^-/);
+
+#trailing whitespace
+		if ($line =~ /^\+.*\015/) {
+			my $herevet = &quot;$here\n&quot; . cat_vet($rawline) . &quot;\n&quot;;
+			ERROR(&quot;DOS_LINE_ENDINGS&quot;,
+			      &quot;DOS line endings\n&quot; . $herevet);
+
+		} elsif ($rawline =~ /^\+.*\S\s+$/ || $rawline =~ /^\+\s+$/) {
+			my $herevet = &quot;$here\n&quot; . cat_vet($rawline) . &quot;\n&quot;;
+			ERROR(&quot;TRAILING_WHITESPACE&quot;,
+			      &quot;trailing whitespace\n&quot; . $herevet);
+			$rpt_cleaners = 1;
+		}
+
+# check for Kconfig help text having a real description
+# Only applies when adding the entry originally, after that we do not have
+# sufficient context to determine whether it is indeed long enough.
+		if ($realfile =~ /Kconfig/ &amp;&amp;
+		    $line =~ /\+\s*(?:---)?help(?:---)?$/) {
+			my $length = 0;
+			my $cnt = $realcnt;
+			my $ln = $linenr + 1;
+			my $f;
+			my $is_end = 0;
+			while ($cnt &gt; 0 &amp;&amp; defined $lines[$ln - 1]) {
+				$f = $lines[$ln - 1];
+				$cnt-- if ($lines[$ln - 1] !~ /^-/);
+				$is_end = $lines[$ln - 1] =~ /^\+/;
+				$ln++;
+
+				next if ($f =~ /^-/);
+				$f =~ s/^.//;
+				$f =~ s/#.*//;
+				$f =~ s/^\s+//;
+				next if ($f =~ /^$/);
+				if ($f =~ /^\s*config\s/) {
+					$is_end = 1;
+					last;
+				}
+				$length++;
+			}
+			WARN(&quot;CONFIG_DESCRIPTION&quot;,
+			     &quot;please write a paragraph that describes the config symbol fully\n&quot; . $herecurr) if ($is_end &amp;&amp; $length &lt; 4);
+			#print &quot;is_end&lt;$is_end&gt; length&lt;$length&gt;\n&quot;;
+		}
+
+# check we are in a valid source file if not then ignore this hunk
+		next if ($realfile !~ /\.(h|c|s|S|pl|sh)$/);
+
+#80 column limit
+		if ($line =~ /^\+/ &amp;&amp; $prevrawline !~ /\/\*\*/ &amp;&amp;
+		    $rawline !~ /^.\s*\*\s*\@$Ident\s/ &amp;&amp;
+		    !($line =~ /^\+\s*$logFunctions\s*\(\s*(?:(KERN_\S+\s*|[^&quot;]*))?&quot;[X\t]*&quot;\s*(?:|,|\)\s*;)\s*$/ ||
+		    $line =~ /^\+\s*&quot;[^&quot;]*&quot;\s*(?:\s*|,|\)\s*;)\s*$/) &amp;&amp;
+		    $length &gt; 80)
+		{
+			WARN(&quot;LONG_LINE&quot;,
+			     &quot;line over 80 characters\n&quot; . $herecurr);
+		}
+
+# check for spaces before a quoted newline
+		if ($rawline =~ /^.*\&quot;.*\s\\n/) {
+			WARN(&quot;QUOTED_WHITESPACE_BEFORE_NEWLINE&quot;,
+			     &quot;unnecessary whitespace before a quoted newline\n&quot; . $herecurr);
+		}
+
+# check for adding lines without a newline.
+		if ($line =~ /^\+/ &amp;&amp; defined $lines[$linenr] &amp;&amp; $lines[$linenr] =~ /^\\ No newline at end of file/) {
+			WARN(&quot;MISSING_EOF_NEWLINE&quot;,
+			     &quot;adding a line without newline at end of file\n&quot; . $herecurr);
+		}
+
+# Blackfin: use hi/lo macros
+		if ($realfile =~ <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">m at arch</A>/blackfin/.*\.S$@) {
+			if ($line =~ /\.[lL][[:space:]]*=.*&amp;[[:space:]]*0x[fF][fF][fF][fF]/) {
+				my $herevet = &quot;$here\n&quot; . cat_vet($line) . &quot;\n&quot;;
+				ERROR(&quot;LO_MACRO&quot;,
+				      &quot;use the LO() macro, not (... &amp; 0xFFFF)\n&quot; . $herevet);
+			}
+			if ($line =~ /\.[hH][[:space:]]*=.*&gt;&gt;[[:space:]]*16/) {
+				my $herevet = &quot;$here\n&quot; . cat_vet($line) . &quot;\n&quot;;
+				ERROR(&quot;HI_MACRO&quot;,
+				      &quot;use the HI() macro, not (... &gt;&gt; 16)\n&quot; . $herevet);
+			}
+		}
+
+# check we are in a valid source file C or perl if not then ignore this hunk
+		next if ($realfile !~ /\.(h|c|pl)$/);
+
+# at the beginning of a line any tabs must come first and anything
+# more than 8 must use tabs.
+		if ($rawline =~ /^\+\s* \t\s*\S/ ||
+		    $rawline =~ /^\+\s*        \s*/) {
+			my $herevet = &quot;$here\n&quot; . cat_vet($rawline) . &quot;\n&quot;;
+			ERROR(&quot;CODE_INDENT&quot;,
+			      &quot;code indent should use tabs where possible\n&quot; . $herevet);
+			$rpt_cleaners = 1;
+		}
+
+# check for space before tabs.
+		if ($rawline =~ /^\+/ &amp;&amp; $rawline =~ / \t/) {
+			my $herevet = &quot;$here\n&quot; . cat_vet($rawline) . &quot;\n&quot;;
+			WARN(&quot;SPACE_BEFORE_TAB&quot;,
+			     &quot;please, no space before tabs\n&quot; . $herevet);
+		}
+
+# check for spaces at the beginning of a line.
+# Exceptions:
+#  1) within comments
+#  2) indented preprocessor commands
+#  3) hanging labels
+		if ($rawline =~ /^\+ / &amp;&amp; $line !~ /\+ *(?:$;|#|$Ident:)/)  {
+			my $herevet = &quot;$here\n&quot; . cat_vet($rawline) . &quot;\n&quot;;
+			WARN(&quot;LEADING_SPACE&quot;,
+			     &quot;please, no spaces at the start of a line\n&quot; . $herevet);
+		}
+
+# check we are in a valid C source file if not then ignore this hunk
+		next if ($realfile !~ /\.(h|c)$/);
+
+# check for RCS/CVS revision markers
+		if ($rawline =~ /^\+.*\$(Revision|Log|Id)(?:\$|)/) {
+			WARN(&quot;CVS_KEYWORD&quot;,
+			     &quot;CVS style keyword markers, these will _not_ be updated\n&quot;. $herecurr);
+		}
+
+# Blackfin: don't use __builtin_bfin_[cs]sync
+		if ($line =~ /__builtin_bfin_csync/) {
+			my $herevet = &quot;$here\n&quot; . cat_vet($line) . &quot;\n&quot;;
+			ERROR(&quot;CSYNC&quot;,
+			      &quot;use the CSYNC() macro in asm/blackfin.h\n&quot; . $herevet);
+		}
+		if ($line =~ /__builtin_bfin_ssync/) {
+			my $herevet = &quot;$here\n&quot; . cat_vet($line) . &quot;\n&quot;;
+			ERROR(&quot;SSYNC&quot;,
+			      &quot;use the SSYNC() macro in asm/blackfin.h\n&quot; . $herevet);
+		}
+
+# Check for potential 'bare' types
+		my ($stat, $cond, $line_nr_next, $remain_next, $off_next,
+		    $realline_next);
+		if ($realcnt &amp;&amp; $line =~ /.\s*\S/) {
+			($stat, $cond, $line_nr_next, $remain_next, $off_next) =
+				ctx_statement_block($linenr, $realcnt, 0);
+			$stat =~ s/\n./\n /g;
+			$cond =~ s/\n./\n /g;
+
+			# Find the real next line.
+			$realline_next = $line_nr_next;
+			if (defined $realline_next &amp;&amp;
+			    (!defined $lines[$realline_next - 1] ||
+			     substr($lines[$realline_next - 1], $off_next) =~ /^\s*$/)) {
+				$realline_next++;
+			}
+
+			my $s = $stat;
+			$s =~ s/{.*$//s;
+
+			# Ignore goto labels.
+			if ($s =~ /$Ident:\*$/s) {
+
+			# Ignore functions being called
+			} elsif ($s =~ /^.\s*$Ident\s*\(/s) {
+
+			} elsif ($s =~ /^.\s*else\b/s) {
+
+			# declarations always start with types
+			} elsif ($prev_values eq 'E' &amp;&amp; $s =~ /^.\s*(?:$Storage\s+)?(?:$Inline\s+)?(?:const\s+)?((?:\s*$Ident)+?)\b(?:\s+$Sparse)?\s*\**\s*(?:$Ident|\(\*[^\)]*\))(?:\s*$Modifier)?\s*(?:;|=|,|\()/s) {
+				my $type = $1;
+				$type =~ s/\s+/ /g;
+				possible($type, &quot;A:&quot; . $s);
+
+			# definitions in global scope can only start with types
+			} elsif ($s =~ /^.(?:$Storage\s+)?(?:$Inline\s+)?(?:const\s+)?($Ident)\b\s*(?!:)/s) {
+				possible($1, &quot;B:&quot; . $s);
+			}
+
+			# any (foo ... *) is a pointer cast, and foo is a type
+			while ($s =~ /\(($Ident)(?:\s+$Sparse)*[\s\*]+\s*\)/sg) {
+				possible($1, &quot;C:&quot; . $s);
+			}
+
+			# Check for any sort of function declaration.
+			# int foo(something bar, other baz);
+			# void (*store_gdt)(x86_descr_ptr *);
+			if ($prev_values eq 'E' &amp;&amp; $s =~ /^(.(?:typedef\s*)?(?:(?:$Storage|$Inline)\s*)*\s*$Type\s*(?:\b$Ident|\(\*\s*$Ident\))\s*)\(/s) {
+				my ($name_len) = length($1);
+
+				my $ctx = $s;
+				substr($ctx, 0, $name_len + 1, '');
+				$ctx =~ s/\)[^\)]*$//;
+
+				for my $arg (split(/\s*,\s*/, $ctx)) {
+					if ($arg =~ /^(?:const\s+)?($Ident)(?:\s+$Sparse)*\s*\**\s*(:?\b$Ident)?$/s || $arg =~ /^($Ident)$/s) {
+
+						possible($1, &quot;D:&quot; . $s);
+					}
+				}
+			}
+
+		}
+
+#
+# Checks which may be anchored in the context.
+#
+
+# Check for switch () and associated case and default
+# statements should be at the same indent.
+		if ($line=~/\bswitch\s*\(.*\)/) {
+			my $err = '';
+			my $sep = '';
+			my @ctx = ctx_block_outer($linenr, $realcnt);
+			shift(@ctx);
+			for my $ctx (@ctx) {
+				my ($clen, $cindent) = line_stats($ctx);
+				if ($ctx =~ /^\+\s*(case\s+|default:)/ &amp;&amp;
+							$indent != $cindent) {
+					$err .= &quot;$sep$ctx\n&quot;;
+					$sep = '';
+				} else {
+					$sep = &quot;[...]\n&quot;;
+				}
+			}
+			if ($err ne '') {
+				ERROR(&quot;SWITCH_CASE_INDENT_LEVEL&quot;,
+				      &quot;switch and case should be at the same indent\n$hereline$err&quot;);
+			}
+		}
+
+# if/while/etc brace do not go on next line, unless defining a do while loop,
+# or if that brace on the next line is for something else
+		if ($line =~ /(.*)\b((?:if|while|for|switch)\s*\(|do\b|else\b)/ &amp;&amp; $line !~ /^.\s*\#/) {
+			my $pre_ctx = &quot;$1$2&quot;;
+
+			my ($level, @ctx) = ctx_statement_level($linenr, $realcnt, 0);
+			my $ctx_cnt = $realcnt - $#ctx - 1;
+			my $ctx = join(&quot;\n&quot;, @ctx);
+
+			my $ctx_ln = $linenr;
+			my $ctx_skip = $realcnt;
+
+			while ($ctx_skip &gt; $ctx_cnt || ($ctx_skip == $ctx_cnt &amp;&amp;
+					defined $lines[$ctx_ln - 1] &amp;&amp;
+					$lines[$ctx_ln - 1] =~ /^-/)) {
+				##print &quot;SKIP&lt;$ctx_skip&gt; CNT&lt;$ctx_cnt&gt;\n&quot;;
+				$ctx_skip-- if (!defined $lines[$ctx_ln - 1] || $lines[$ctx_ln - 1] !~ /^-/);
+				$ctx_ln++;
+			}
+
+			#print &quot;realcnt&lt;$realcnt&gt; ctx_cnt&lt;$ctx_cnt&gt;\n&quot;;
+			#print &quot;pre&lt;$pre_ctx&gt;\nline&lt;$line&gt;\nctx&lt;$ctx&gt;\nnext&lt;$lines[$ctx_ln - 1]&gt;\n&quot;;
+
+			if ($ctx !~ /{\s*/ &amp;&amp; defined($lines[$ctx_ln -1]) &amp;&amp; $lines[$ctx_ln - 1] =~ /^\+\s*{/) {
+				ERROR(&quot;OPEN_BRACE&quot;,
+				      &quot;that open brace { should be on the previous line\n&quot; .
+					&quot;$here\n$ctx\n$rawlines[$ctx_ln - 1]\n&quot;);
+			}
+			if ($level == 0 &amp;&amp; $pre_ctx !~ /}\s*while\s*\($/ &amp;&amp;
+			    $ctx =~ /\)\s*\;\s*$/ &amp;&amp;
+			    defined $lines[$ctx_ln - 1])
+			{
+				my ($nlength, $nindent) = line_stats($lines[$ctx_ln - 1]);
+				if ($nindent &gt; $indent) {
+					WARN(&quot;TRAILING_SEMICOLON&quot;,
+					     &quot;trailing semicolon indicates no statements, indent implies otherwise\n&quot; .
+						&quot;$here\n$ctx\n$rawlines[$ctx_ln - 1]\n&quot;);
+				}
+			}
+		}
+
+# Check relative indent for conditionals and blocks.
+		if ($line =~ /\b(?:(?:if|while|for)\s*\(|do\b)/ &amp;&amp; $line !~ /^.\s*#/ &amp;&amp; $line !~ /\}\s*while\s*/) {
+			my ($s, $c) = ($stat, $cond);
+
+			substr($s, 0, length($c), '');
+
+			# Make sure we remove the line prefixes as we have
+			# none on the first line, and are going to readd them
+			# where necessary.
+			$s =~ s/\n./\n/gs;
+
+			# Find out how long the conditional actually is.
+			my @newlines = ($c =~ /\n/gs);
+			my $cond_lines = 1 + $#newlines;
+
+			# We want to check the first line inside the block
+			# starting at the end of the conditional, so remove:
+			#  1) any blank line termination
+			#  2) any opening brace { on end of the line
+			#  3) any do (...) {
+			my $continuation = 0;
+			my $check = 0;
+			$s =~ s/^.*\bdo\b//;
+			$s =~ s/^\s*{//;
+			if ($s =~ s/^\s*\\//) {
+				$continuation = 1;
+			}
+			if ($s =~ s/^\s*?\n//) {
+				$check = 1;
+				$cond_lines++;
+			}
+
+			# Also ignore a loop construct at the end of a
+			# preprocessor statement.
+			if (($prevline =~ /^.\s*#\s*define\s/ ||
+			    $prevline =~ /\\\s*$/) &amp;&amp; $continuation == 0) {
+				$check = 0;
+			}
+
+			my $cond_ptr = -1;
+			$continuation = 0;
+			while ($cond_ptr != $cond_lines) {
+				$cond_ptr = $cond_lines;
+
+				# If we see an #else/#elif then the code
+				# is not linear.
+				if ($s =~ /^\s*\#\s*(?:else|elif)/) {
+					$check = 0;
+				}
+
+				# Ignore:
+				#  1) blank lines, they should be at 0,
+				#  2) preprocessor lines, and
+				#  3) labels.
+				if ($continuation ||
+				    $s =~ /^\s*?\n/ ||
+				    $s =~ /^\s*#\s*?/ ||
+				    $s =~ /^\s*$Ident\s*:/) {
+					$continuation = ($s =~ /^.*?\\\n/) ? 1 : 0;
+					if ($s =~ s/^.*?\n//) {
+						$cond_lines++;
+					}
+				}
+			}
+
+			my (undef, $sindent) = line_stats(&quot;+&quot; . $s);
+			my $stat_real = raw_line($linenr, $cond_lines);
+
+			# Check if either of these lines are modified, else
+			# this is not this patch's fault.
+			if (!defined($stat_real) ||
+			    $stat !~ /^\+/ &amp;&amp; $stat_real !~ /^\+/) {
+				$check = 0;
+			}
+			if (defined($stat_real) &amp;&amp; $cond_lines &gt; 1) {
+				$stat_real = &quot;[...]\n$stat_real&quot;;
+			}
+
+			#print &quot;line&lt;$line&gt; prevline&lt;$prevline&gt; indent&lt;$indent&gt; sindent&lt;$sindent&gt; check&lt;$check&gt; continuation&lt;$continuation&gt; s&lt;$s&gt; cond_lines&lt;$cond_lines&gt; stat_real&lt;$stat_real&gt; stat&lt;$stat&gt;\n&quot;;
+
+			if ($check &amp;&amp; (($sindent % 8) != 0 ||
+			    ($sindent &lt;= $indent &amp;&amp; $s ne ''))) {
+				WARN(&quot;SUSPECT_CODE_INDENT&quot;,
+				     &quot;suspect code indent for conditional statements ($indent, $sindent)\n&quot; . $herecurr . &quot;$stat_real\n&quot;);
+			}
+		}
+
+		# Track the 'values' across context and added lines.
+		my $opline = $line; $opline =~ s/^./ /;
+		my ($curr_values, $curr_vars) =
+				annotate_values($opline . &quot;\n&quot;, $prev_values);
+		$curr_values = $prev_values . $curr_values;
+		if ($dbg_values) {
+			my $outline = $opline; $outline =~ s/\t/ /g;
+			print &quot;$linenr &gt; .$outline\n&quot;;
+			print &quot;$linenr &gt; $curr_values\n&quot;;
+			print &quot;$linenr &gt;  $curr_vars\n&quot;;
+		}
+		$prev_values = substr($curr_values, -1);
+
+#ignore lines not being added
+		if ($line=~/^[^\+]/) {next;}
+
+# TEST: allow direct testing of the type matcher.
+		if ($dbg_type) {
+			if ($line =~ /^.\s*$Declare\s*$/) {
+				ERROR(&quot;TEST_TYPE&quot;,
+				      &quot;TEST: is type\n&quot; . $herecurr);
+			} elsif ($dbg_type &gt; 1 &amp;&amp; $line =~ /^.+($Declare)/) {
+				ERROR(&quot;TEST_NOT_TYPE&quot;,
+				      &quot;TEST: is not type ($1 is)\n&quot;. $herecurr);
+			}
+			next;
+		}
+# TEST: allow direct testing of the attribute matcher.
+		if ($dbg_attr) {
+			if ($line =~ /^.\s*$Modifier\s*$/) {
+				ERROR(&quot;TEST_ATTR&quot;,
+				      &quot;TEST: is attr\n&quot; . $herecurr);
+			} elsif ($dbg_attr &gt; 1 &amp;&amp; $line =~ /^.+($Modifier)/) {
+				ERROR(&quot;TEST_NOT_ATTR&quot;,
+				      &quot;TEST: is not attr ($1 is)\n&quot;. $herecurr);
+			}
+			next;
+		}
+
+# check for initialisation to aggregates open brace on the next line
+		if ($line =~ /^.\s*{/ &amp;&amp;
+		    $prevline =~ /(?:^|[^=])=\s*$/) {
+			ERROR(&quot;OPEN_BRACE&quot;,
+			      &quot;that open brace { should be on the previous line\n&quot; . $hereprev);
+		}
+
+#
+# Checks which are anchored on the added line.
+#
+
+# check for malformed paths in #include statements (uses RAW line)
+		if ($rawline =~ m{^.\s*\#\s*include\s+[&lt;&quot;](.*)[&quot;&gt;]}) {
+			my $path = $1;
+			if ($path =~ m{//}) {
+				ERROR(&quot;MALFORMED_INCLUDE&quot;,
+				      &quot;malformed #include filename\n&quot; .
+					$herecurr);
+			}
+		}
+
+# no C99 // comments
+		if ($line =~ m{//}) {
+			ERROR(&quot;C99_COMMENTS&quot;,
+			      &quot;do not use C99 // comments\n&quot; . $herecurr);
+		}
+		# Remove C99 comments.
+		$line =~ s@//.*@@;
+		$opline =~ s@//.*@@;
+
+# EXPORT_SYMBOL should immediately follow the thing it is exporting, consider
+# the whole statement.
+#print &quot;APW &lt;$lines[$realline_next - 1]&gt;\n&quot;;
+		if (defined $realline_next &amp;&amp;
+		    exists $lines[$realline_next - 1] &amp;&amp;
+		    !defined $suppress_export{$realline_next} &amp;&amp;
+		    ($lines[$realline_next - 1] =~ /EXPORT_SYMBOL.*\((.*)\)/ ||
+		     $lines[$realline_next - 1] =~ /EXPORT_UNUSED_SYMBOL.*\((.*)\)/)) {
+			# Handle definitions which produce identifiers with
+			# a prefix:
+			#   XXX(foo);
+			#   EXPORT_SYMBOL(something_foo);
+			my $name = $1;
+			if ($stat =~ /^.([A-Z_]+)\s*\(\s*($Ident)/ &amp;&amp;
+			    $name =~ /^${Ident}_$2/) {
+#print &quot;FOO C name&lt;$name&gt;\n&quot;;
+				$suppress_export{$realline_next} = 1;
+
+			} elsif ($stat !~ /(?:
+				\n.}\s*$|
+				^.DEFINE_$Ident\(\Q$name\E\)|
+				^.DECLARE_$Ident\(\Q$name\E\)|
+				^.LIST_HEAD\(\Q$name\E\)|
+				^.(?:$Storage\s+)?$Type\s*\(\s*\*\s*\Q$name\E\s*\)\s*\(|
+				\b\Q$name\E(?:\s+$Attribute)*\s*(?:;|=|\[|\()
+			    )/x) {
+#print &quot;FOO A&lt;$lines[$realline_next - 1]&gt; stat&lt;$stat&gt; name&lt;$name&gt;\n&quot;;
+				$suppress_export{$realline_next} = 2;
+			} else {
+				$suppress_export{$realline_next} = 1;
+			}
+		}
+		if (!defined $suppress_export{$linenr} &amp;&amp;
+		    $prevline =~ /^.\s*$/ &amp;&amp;
+		    ($line =~ /EXPORT_SYMBOL.*\((.*)\)/ ||
+		     $line =~ /EXPORT_UNUSED_SYMBOL.*\((.*)\)/)) {
+#print &quot;FOO B &lt;$lines[$linenr - 1]&gt;\n&quot;;
+			$suppress_export{$linenr} = 2;
+		}
+		if (defined $suppress_export{$linenr} &amp;&amp;
+		    $suppress_export{$linenr} == 2) {
+			WARN(&quot;EXPORT_SYMBOL&quot;,
+			     &quot;EXPORT_SYMBOL(foo); should immediately follow its function/variable\n&quot; . $herecurr);
+		}
+
+# check for global initialisers.
+		if ($line =~ /^.$Type\s*$Ident\s*(?:\s+$Modifier)*\s*=\s*(0|NULL|false)\s*;/) {
+			ERROR(&quot;GLOBAL_INITIALISERS&quot;,
+			      &quot;do not initialise globals to 0 or NULL\n&quot; .
+				$herecurr);
+		}
+# check for static initialisers.
+		if ($line =~ /\bstatic\s.*=\s*(0|NULL|false)\s*;/) {
+			ERROR(&quot;INITIALISED_STATIC&quot;,
+			      &quot;do not initialise statics to 0 or NULL\n&quot; .
+				$herecurr);
+		}
+
+# check for static const char * arrays.
+		if ($line =~ /\bstatic\s+const\s+char\s*\*\s*(\w+)\s*\[\s*\]\s*=\s*/) {
+			WARN(&quot;STATIC_CONST_CHAR_ARRAY&quot;,
+			     &quot;static const char * array should probably be static const char * const\n&quot; .
+				$herecurr);
+               }
+
+# check for static char foo[] = &quot;bar&quot; declarations.
+		if ($line =~ /\bstatic\s+char\s+(\w+)\s*\[\s*\]\s*=\s*&quot;/) {
+			WARN(&quot;STATIC_CONST_CHAR_ARRAY&quot;,
+			     &quot;static char array declaration should probably be static const char\n&quot; .
+				$herecurr);
+               }
+
+# check for declarations of struct pci_device_id
+		if ($line =~ /\bstruct\s+pci_device_id\s+\w+\s*\[\s*\]\s*\=\s*\{/) {
+			WARN(&quot;DEFINE_PCI_DEVICE_TABLE&quot;,
+			     &quot;Use DEFINE_PCI_DEVICE_TABLE for struct pci_device_id\n&quot; . $herecurr);
+		}
+
+# check for new typedefs, only function parameters and sparse annotations
+# make sense.
+		if ($line =~ /\btypedef\s/ &amp;&amp;
+		    $line !~ /\btypedef\s+$Type\s*\(\s*\*?$Ident\s*\)\s*\(/ &amp;&amp;
+		    $line !~ /\btypedef\s+$Type\s+$Ident\s*\(/ &amp;&amp;
+		    $line !~ /\b$typeTypedefs\b/ &amp;&amp;
+		    $line !~ /\b__bitwise(?:__|)\b/) {
+			WARN(&quot;NEW_TYPEDEFS&quot;,
+			     &quot;do not add new typedefs\n&quot; . $herecurr);
+		}
+
+# * goes on variable not on type
+		# (char*[ const])
+		if ($line =~ m{\($NonptrType(\s*(?:$Modifier\b\s*|\*\s*)+)\)}) {
+			my ($from, $to) = ($1, $1);
+
+			# Should start with a space.
+			$to =~ s/^(\S)/ $1/;
+			# Should not end with a space.
+			$to =~ s/\s+$//;
+			# '*'s should not have spaces between.
+			while ($to =~ s/\*\s+\*/\*\*/) {
+			}
+
+			#print &quot;from&lt;$from&gt; to&lt;$to&gt;\n&quot;;
+			if ($from ne $to) {
+				ERROR(&quot;POINTER_LOCATION&quot;,
+				      &quot;\&quot;(foo$from)\&quot; should be \&quot;(foo$to)\&quot;\n&quot; .  $herecurr);
+			}
+		} elsif ($line =~ m{\b$NonptrType(\s*(?:$Modifier\b\s*|\*\s*)+)($Ident)}) {
+			my ($from, $to, $ident) = ($1, $1, $2);
+
+			# Should start with a space.
+			$to =~ s/^(\S)/ $1/;
+			# Should not end with a space.
+			$to =~ s/\s+$//;
+			# '*'s should not have spaces between.
+			while ($to =~ s/\*\s+\*/\*\*/) {
+			}
+			# Modifiers should have spaces.
+			$to =~ s/(\b$Modifier$)/$1 /;
+
+			#print &quot;from&lt;$from&gt; to&lt;$to&gt; ident&lt;$ident&gt;\n&quot;;
+			if ($from ne $to &amp;&amp; $ident !~ /^$Modifier$/) {
+				ERROR(&quot;POINTER_LOCATION&quot;,
+				      &quot;\&quot;foo${from}bar\&quot; should be \&quot;foo${to}bar\&quot;\n&quot; .  $herecurr);
+			}
+		}
+
+# # no BUG() or BUG_ON()
+# 		if ($line =~ /\b(BUG|BUG_ON)\b/) {
+# 			print &quot;Try to use WARN_ON &amp; Recovery code rather than BUG() or BUG_ON()\n&quot;;
+# 			print &quot;$herecurr&quot;;
+# 			$clean = 0;
+# 		}
+
+		if ($line =~ /\bLINUX_VERSION_CODE\b/) {
+			WARN(&quot;LINUX_VERSION_CODE&quot;,
+			     &quot;LINUX_VERSION_CODE should be avoided, code should be for the version to which it is merged\n&quot; . $herecurr);
+		}
+
+# check for uses of printk_ratelimit
+		if ($line =~ /\bprintk_ratelimit\s*\(/) {
+			WARN(&quot;PRINTK_RATELIMITED&quot;,
+&quot;Prefer printk_ratelimited or pr_&lt;level&gt;_ratelimited to printk_ratelimit\n&quot; . $herecurr);
+		}
+
+# printk should use KERN_* levels.  Note that follow on printk's on the
+# same line do not need a level, so we use the current block context
+# to try and find and validate the current printk.  In summary the current
+# printk includes all preceding printk's which have no newline on the end.
+# we assume the first bad printk is the one to report.
+		if ($line =~ /\bprintk\((?!KERN_)\s*&quot;/) {
+			my $ok = 0;
+			for (my $ln = $linenr - 1; $ln &gt;= $first_line; $ln--) {
+				#print &quot;CHECK&lt;$lines[$ln - 1]\n&quot;;
+				# we have a preceding printk if it ends
+				# with &quot;\n&quot; ignore it, else it is to blame
+				if ($lines[$ln - 1] =~ m{\bprintk\(}) {
+					if ($rawlines[$ln - 1] !~ m{\\n&quot;}) {
+						$ok = 1;
+					}
+					last;
+				}
+			}
+			if ($ok == 0) {
+				WARN(&quot;PRINTK_WITHOUT_KERN_LEVEL&quot;,
+				     &quot;printk() should include KERN_ facility level\n&quot; . $herecurr);
+			}
+		}
+
+# function brace can't be on same line, except for #defines of do while,
+# or if closed on same line
+		if (($line=~/$Type\s*$Ident\(.*\).*\s{/) and
+		    !($line=~/\#\s*define.*do\s{/) and !($line=~/}/)) {
+			ERROR(&quot;OPEN_BRACE&quot;,
+			      &quot;open brace '{' following function declarations go on the next line\n&quot; . $herecurr);
+		}
+
+# open braces for enum, union and struct go on the same line.
+		if ($line =~ /^.\s*{/ &amp;&amp;
+		    $prevline =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident)?\s*$/) {
+			ERROR(&quot;OPEN_BRACE&quot;,
+			      &quot;open brace '{' following $1 go on the same line\n&quot; . $hereprev);
+		}
+
+# missing space after union, struct or enum definition
+		if ($line =~ /^.\s*(?:typedef\s+)?(enum|union|struct)(?:\s+$Ident)?(?:\s+$Ident)?[=\{]/) {
+		    WARN(&quot;SPACING&quot;,
+			 &quot;missing space after $1 definition\n&quot; . $herecurr);
+		}
+
+# check for spacing round square brackets; allowed:
+#  1. with a type on the left -- int [] a;
+#  2. at the beginning of a line for slice initialisers -- [0...10] = 5,
+#  3. inside a curly brace -- = { [0...10] = 5 }
+		while ($line =~ /(.*?\s)\[/g) {
+			my ($where, $prefix) = ($-[1], $1);
+			if ($prefix !~ /$Type\s+$/ &amp;&amp;
+			    ($where != 0 || $prefix !~ /^.\s+$/) &amp;&amp;
+			    $prefix !~ /{\s+$/) {
+				ERROR(&quot;BRACKET_SPACE&quot;,
+				      &quot;space prohibited before open square bracket '['\n&quot; . $herecurr);
+			}
+		}
+
+# check for spaces between functions and their parentheses.
+		while ($line =~ /($Ident)\s+\(/g) {
+			my $name = $1;
+			my $ctx_before = substr($line, 0, $-[1]);
+			my $ctx = &quot;$ctx_before$name&quot;;
+
+			# Ignore those directives where spaces _are_ permitted.
+			if ($name =~ /^(?:
+				if|for|while|switch|return|case|
+				volatile|__volatile__|
+				__attribute__|format|__extension__|
+				asm|__asm__)$/x)
+			{
+
+			# cpp #define statements have non-optional spaces, ie
+			# if there is a space between the name and the open
+			# parenthesis it is simply not a parameter group.
+			} elsif ($ctx_before =~ /^.\s*\#\s*define\s*$/) {
+
+			# cpp #elif statement condition may start with a (
+			} elsif ($ctx =~ /^.\s*\#\s*elif\s*$/) {
+
+			# If this whole things ends with a type its most
+			# likely a typedef for a function.
+			} elsif ($ctx =~ /$Type$/) {
+
+			} else {
+				WARN(&quot;SPACING&quot;,
+				     &quot;space prohibited between function name and open parenthesis '('\n&quot; . $herecurr);
+			}
+		}
+# Check operator spacing.
+		if (!($line=~/\#\s*include/)) {
+			my $ops = qr{
+				&lt;&lt;=|&gt;&gt;=|&lt;=|&gt;=|==|!=|
+				\+=|-=|\*=|\/=|%=|\^=|\|=|&amp;=|
+				=&gt;|-&gt;|&lt;&lt;|&gt;&gt;|&lt;|&gt;|=|!|~|
+				&amp;&amp;|\|\||,|\^|\+\+|--|&amp;|\||\+|-|\*|\/|%|
+				\?|:
+			}x;
+			my @elements = split(/($ops|;)/, $opline);
+			my $off = 0;
+
+			my $blank = copy_spacing($opline);
+
+			for (my $n = 0; $n &lt; $#elements; $n += 2) {
+				$off += length($elements[$n]);
+
+				# Pick up the preceding and succeeding characters.
+				my $ca = substr($opline, 0, $off);
+				my $cc = '';
+				if (length($opline) &gt;= ($off + length($elements[$n + 1]))) {
+					$cc = substr($opline, $off + length($elements[$n + 1]));
+				}
+				my $cb = &quot;$ca$;$cc&quot;;
+
+				my $a = '';
+				$a = 'V' if ($elements[$n] ne '');
+				$a = 'W' if ($elements[$n] =~ /\s$/);
+				$a = 'C' if ($elements[$n] =~ /$;$/);
+				$a = 'B' if ($elements[$n] =~ /(\[|\()$/);
+				$a = 'O' if ($elements[$n] eq '');
+				$a = 'E' if ($ca =~ /^\s*$/);
+
+				my $op = $elements[$n + 1];
+
+				my $c = '';
+				if (defined $elements[$n + 2]) {
+					$c = 'V' if ($elements[$n + 2] ne '');
+					$c = 'W' if ($elements[$n + 2] =~ /^\s/);
+					$c = 'C' if ($elements[$n + 2] =~ /^$;/);
+					$c = 'B' if ($elements[$n + 2] =~ /^(\)|\]|;)/);
+					$c = 'O' if ($elements[$n + 2] eq '');
+					$c = 'E' if ($elements[$n + 2] =~ /^\s*\\$/);
+				} else {
+					$c = 'E';
+				}
+
+				my $ctx = &quot;${a}x${c}&quot;;
+
+				my $at = &quot;(ctx:$ctx)&quot;;
+
+				my $ptr = substr($blank, 0, $off) . &quot;^&quot;;
+				my $hereptr = &quot;$hereline$ptr\n&quot;;
+
+				# Pull out the value of this operator.
+				my $op_type = substr($curr_values, $off + 1, 1);
+
+				# Get the full operator variant.
+				my $opv = $op . substr($curr_vars, $off, 1);
+
+				# Ignore operators passed as parameters.
+				if ($op_type ne 'V' &amp;&amp;
+				    $ca =~ /\s$/ &amp;&amp; $cc =~ /^\s*,/) {
+
+#				# Ignore comments
+#				} elsif ($op =~ /^$;+$/) {
+
+				# ; should have either the end of line or a space or \ after it
+				} elsif ($op eq ';') {
+					if ($ctx !~ /.x[WEBC]/ &amp;&amp;
+					    $cc !~ /^\\/ &amp;&amp; $cc !~ /^;/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space required after that '$op' $at\n&quot; . $hereptr);
+					}
+
+				# // is a comment
+				} elsif ($op eq '//') {
+
+				# No spaces for:
+				#   -&gt;
+				#   :   when part of a bitfield
+				} elsif ($op eq '-&gt;' || $opv eq ':B') {
+					if ($ctx =~ /Wx.|.xW/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;spaces prohibited around that '$op' $at\n&quot; . $hereptr);
+					}
+
+				# , must have a space on the right.
+				} elsif ($op eq ',') {
+					if ($ctx !~ /.x[WEC]/ &amp;&amp; $cc !~ /^}/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space required after that '$op' $at\n&quot; . $hereptr);
+					}
+
+				# '*' as part of a type definition -- reported already.
+				} elsif ($opv eq '*_') {
+					#warn &quot;'*' is part of type\n&quot;;
+
+				# unary operators should have a space before and
+				# none after.  May be left adjacent to another
+				# unary operator, or a cast
+				} elsif ($op eq '!' || $op eq '~' ||
+					 $opv eq '*U' || $opv eq '-U' ||
+					 $opv eq '&amp;U' || $opv eq '&amp;&amp;U') {
+					if ($ctx !~ /[WEBC]x./ &amp;&amp; $ca !~ /(?:\)|!|~|\*|-|\&amp;|\||\+\+|\-\-|\{)$/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space required before that '$op' $at\n&quot; . $hereptr);
+					}
+					if ($op eq '*' &amp;&amp; $cc =~/\s*$Modifier\b/) {
+						# A unary '*' may be const
+
+					} elsif ($ctx =~ /.xW/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space prohibited after that '$op' $at\n&quot; . $hereptr);
+					}
+
+				# unary ++ and unary -- are allowed no space on one side.
+				} elsif ($op eq '++' or $op eq '--') {
+					if ($ctx !~ /[WEOBC]x[^W]/ &amp;&amp; $ctx !~ /[^W]x[WOBEC]/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space required one side of that '$op' $at\n&quot; . $hereptr);
+					}
+					if ($ctx =~ /Wx[BE]/ ||
+					    ($ctx =~ /Wx./ &amp;&amp; $cc =~ /^;/)) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space prohibited before that '$op' $at\n&quot; . $hereptr);
+					}
+					if ($ctx =~ /ExW/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space prohibited after that '$op' $at\n&quot; . $hereptr);
+					}
+
+
+				# &lt;&lt; and &gt;&gt; may either have or not have spaces both sides
+				} elsif ($op eq '&lt;&lt;' or $op eq '&gt;&gt;' or
+					 $op eq '&amp;' or $op eq '^' or $op eq '|' or
+					 $op eq '+' or $op eq '-' or
+					 $op eq '*' or $op eq '/' or
+					 $op eq '%')
+				{
+					if ($ctx =~ /Wx[^WCE]|[^WCE]xW/) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;need consistent spacing around '$op' $at\n&quot; .
+							$hereptr);
+					}
+
+				# A colon needs no spaces before when it is
+				# terminating a case value or a label.
+				} elsif ($opv eq ':C' || $opv eq ':L') {
+					if ($ctx =~ /Wx./) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;space prohibited before that '$op' $at\n&quot; . $hereptr);
+					}
+
+				# All the others need spaces both sides.
+				} elsif ($ctx !~ /[EWC]x[CWE]/) {
+					my $ok = 0;
+
+					# Ignore email addresses &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">foo at bar</A>&gt;
+					if (($op eq '&lt;' &amp;&amp;
+					     $cc =~ /^\S+\@\S+&gt;/) ||
+					    ($op eq '&gt;' &amp;&amp;
+					     $ca =~ /&lt;\S+\@\S+$/))
+					{
+					    	$ok = 1;
+					}
+
+					# Ignore ?:
+					if (($opv eq ':O' &amp;&amp; $ca =~ /\?$/) ||
+					    ($op eq '?' &amp;&amp; $cc =~ /^:/)) {
+					    	$ok = 1;
+					}
+
+					if ($ok == 0) {
+						ERROR(&quot;SPACING&quot;,
+						      &quot;spaces required around that '$op' $at\n&quot; . $hereptr);
+					}
+				}
+				$off += length($elements[$n + 1]);
+			}
+		}
+
+# check for multiple assignments
+		if ($line =~ /^.\s*$Lval\s*=\s*$Lval\s*=(?!=)/) {
+			CHK(&quot;MULTIPLE_ASSIGNMENTS&quot;,
+			    &quot;multiple assignments should be avoided\n&quot; . $herecurr);
+		}
+
+## # check for multiple declarations, allowing for a function declaration
+## # continuation.
+## 		if ($line =~ /^.\s*$Type\s+$Ident(?:\s*=[^,{]*)?\s*,\s*$Ident.*/ &amp;&amp;
+## 		    $line !~ /^.\s*$Type\s+$Ident(?:\s*=[^,{]*)?\s*,\s*$Type\s*$Ident.*/) {
+##
+## 			# Remove any bracketed sections to ensure we do not
+## 			# falsly report the parameters of functions.
+## 			my $ln = $line;
+## 			while ($ln =~ s/\([^\(\)]*\)//g) {
+## 			}
+## 			if ($ln =~ /,/) {
+## 				WARN(&quot;MULTIPLE_DECLARATION&quot;,
+##				     &quot;declaring multiple variables together should be avoided\n&quot; . $herecurr);
+## 			}
+## 		}
+
+#need space before brace following if, while, etc
+		if (($line =~ /\(.*\){/ &amp;&amp; $line !~ /\($Type\){/) ||
+		    $line =~ /do{/) {
+			ERROR(&quot;SPACING&quot;,
+			      &quot;space required before the open brace '{'\n&quot; . $herecurr);
+		}
+
+# closing brace should have a space following it when it has anything
+# on the line
+		if ($line =~ /}(?!(?:,|;|\)))\S/) {
+			ERROR(&quot;SPACING&quot;,
+			      &quot;space required after that close brace '}'\n&quot; . $herecurr);
+		}
+
+# check spacing on square brackets
+		if ($line =~ /\[\s/ &amp;&amp; $line !~ /\[\s*$/) {
+			ERROR(&quot;SPACING&quot;,
+			      &quot;space prohibited after that open square bracket '['\n&quot; . $herecurr);
+		}
+		if ($line =~ /\s\]/) {
+			ERROR(&quot;SPACING&quot;,
+			      &quot;space prohibited before that close square bracket ']'\n&quot; . $herecurr);
+		}
+
+# check spacing on parentheses
+		if ($line =~ /\(\s/ &amp;&amp; $line !~ /\(\s*(?:\\)?$/ &amp;&amp;
+		    $line !~ /for\s*\(\s+;/) {
+			ERROR(&quot;SPACING&quot;,
+			      &quot;space prohibited after that open parenthesis '('\n&quot; . $herecurr);
+		}
+		if ($line =~ /(\s+)\)/ &amp;&amp; $line !~ /^.\s*\)/ &amp;&amp;
+		    $line !~ /for\s*\(.*;\s+\)/ &amp;&amp;
+		    $line !~ /:\s+\)/) {
+			ERROR(&quot;SPACING&quot;,
+			      &quot;space prohibited before that close parenthesis ')'\n&quot; . $herecurr);
+		}
+
+#goto labels aren't indented, allow a single space however
+		if ($line=~/^.\s+[A-Za-z\d_]+:(?![0-9]+)/ and
+		   !($line=~/^. [A-Za-z\d_]+:/) and !($line=~/^.\s+default:/)) {
+			WARN(&quot;INDENTED_LABEL&quot;,
+			     &quot;labels should not be indented\n&quot; . $herecurr);
+		}
+
+# Return is not a function.
+		if (defined($stat) &amp;&amp; $stat =~ /^.\s*return(\s*)(\(.*);/s) {
+			my $spacing = $1;
+			my $value = $2;
+
+			# Flatten any parentheses
+			$value =~ s/\(/ \(/g;
+			$value =~ s/\)/\) /g;
+			while ($value =~ s/\[[^\{\}]*\]/1/ ||
+			       $value !~ /(?:$Ident|-?$Constant)\s*
+					     $Compare\s*
+					     (?:$Ident|-?$Constant)/x &amp;&amp;
+			       $value =~ s/\([^\(\)]*\)/1/) {
+			}
+#print &quot;value&lt;$value&gt;\n&quot;;
+			if ($value =~ /^\s*(?:$Ident|-?$Constant)\s*$/) {
+				ERROR(&quot;RETURN_PARENTHESES&quot;,
+				      &quot;return is not a function, parentheses are not required\n&quot; . $herecurr);
+
+			} elsif ($spacing !~ /\s+/) {
+				ERROR(&quot;SPACING&quot;,
+				      &quot;space required before the open parenthesis '('\n&quot; . $herecurr);
+			}
+		}
+# Return of what appears to be an errno should normally be -'ve
+		if ($line =~ /^.\s*return\s*(E[A-Z]*)\s*;/) {
+			my $name = $1;
+			if ($name ne 'EOF' &amp;&amp; $name ne 'ERROR') {
+				WARN(&quot;USE_NEGATIVE_ERRNO&quot;,
+				     &quot;return of an errno should typically be -ve (return -$1)\n&quot; . $herecurr);
+			}
+		}
+
+# typecasts on min/max could be min_t/max_t
+		if ($line =~ /^\+(?:.*?)\b(min|max)\s*\($Typecast{0,1}($LvalOrFunc)\s*,\s*$Typecast{0,1}($LvalOrFunc)\s*\)/) {
+			if (defined $2 || defined $8) {
+				my $call = $1;
+				my $cast1 = deparenthesize($2);
+				my $arg1 = $3;
+				my $cast2 = deparenthesize($8);
+				my $arg2 = $9;
+				my $cast;
+
+				if ($cast1 ne &quot;&quot; &amp;&amp; $cast2 ne &quot;&quot;) {
+					$cast = &quot;$cast1 or $cast2&quot;;
+				} elsif ($cast1 ne &quot;&quot;) {
+					$cast = $cast1;
+				} else {
+					$cast = $cast2;
+				}
+				WARN(&quot;MINMAX&quot;,
+				     &quot;$call() should probably be ${call}_t($cast, $arg1, $arg2)\n&quot; . $herecurr);
+			}
+		}
+
+# Need a space before open parenthesis after if, while etc
+		if ($line=~/\b(if|while|for|switch)\(/) {
+			ERROR(&quot;SPACING&quot;, &quot;space required before the open parenthesis '('\n&quot; . $herecurr);
+		}
+
+# Check for illegal assignment in if conditional -- and check for trailing
+# statements after the conditional.
+		if ($line =~ /do\s*(?!{)/) {
+			my ($stat_next) = ctx_statement_block($line_nr_next,
+						$remain_next, $off_next);
+			$stat_next =~ s/\n./\n /g;
+			##print &quot;stat&lt;$stat&gt; stat_next&lt;$stat_next&gt;\n&quot;;
+
+			if ($stat_next =~ /^\s*while\b/) {
+				# If the statement carries leading newlines,
+				# then count those as offsets.
+				my ($whitespace) =
+					($stat_next =~ /^((?:\s*\n[+-])*\s*)/s);
+				my $offset =
+					statement_rawlines($whitespace) - 1;
+
+				$suppress_whiletrailers{$line_nr_next +
+								$offset} = 1;
+			}
+		}
+		if (!defined $suppress_whiletrailers{$linenr} &amp;&amp;
+		    $line =~ /\b(?:if|while|for)\s*\(/ &amp;&amp; $line !~ /^.\s*#/) {
+			my ($s, $c) = ($stat, $cond);
+
+			if ($c =~ /\bif\s*\(.*[^&lt;&gt;!=]=[^=].*/s) {
+				ERROR(&quot;ASSIGN_IN_IF&quot;,
+				      &quot;do not use assignment in if condition\n&quot; . $herecurr);
+			}
+
+			# Find out what is on the end of the line after the
+			# conditional.
+			substr($s, 0, length($c), '');
+			$s =~ s/\n.*//g;
+			$s =~ s/$;//g; 	# Remove any comments
+			if (length($c) &amp;&amp; $s !~ /^\s*{?\s*\\*\s*$/ &amp;&amp;
+			    $c !~ /}\s*while\s*/)
+			{
+				# Find out how long the conditional actually is.
+				my @newlines = ($c =~ /\n/gs);
+				my $cond_lines = 1 + $#newlines;
+				my $stat_real = '';
+
+				$stat_real = raw_line($linenr, $cond_lines)
+							. &quot;\n&quot; if ($cond_lines);
+				if (defined($stat_real) &amp;&amp; $cond_lines &gt; 1) {
+					$stat_real = &quot;[...]\n$stat_real&quot;;
+				}
+
+				ERROR(&quot;TRAILING_STATEMENTS&quot;,
+				      &quot;trailing statements should be on next line\n&quot; . $herecurr . $stat_real);
+			}
+		}
+
+# Check for bitwise tests written as boolean
+		if ($line =~ /
+			(?:
+				(?:\[|\(|\&amp;\&amp;|\|\|)
+				\s*0[xX][0-9]+\s*
+				(?:\&amp;\&amp;|\|\|)
+			|
+				(?:\&amp;\&amp;|\|\|)
+				\s*0[xX][0-9]+\s*
+				(?:\&amp;\&amp;|\|\||\)|\])
+			)/x)
+		{
+			WARN(&quot;HEXADECIMAL_BOOLEAN_TEST&quot;,
+			     &quot;boolean test with hexadecimal, perhaps just 1 \&amp; or \|?\n&quot; . $herecurr);
+		}
+
+# if and else should not have general statements after it
+		if ($line =~ /^.\s*(?:}\s*)?else\b(.*)/) {
+			my $s = $1;
+			$s =~ s/$;//g; 	# Remove any comments
+			if ($s !~ /^\s*(?:\sif|(?:{|)\s*\\?\s*$)/) {
+				ERROR(&quot;TRAILING_STATEMENTS&quot;,
+				      &quot;trailing statements should be on next line\n&quot; . $herecurr);
+			}
+		}
+# if should not continue a brace
+		if ($line =~ /}\s*if\b/) {
+			ERROR(&quot;TRAILING_STATEMENTS&quot;,
+			      &quot;trailing statements should be on next line\n&quot; .
+				$herecurr);
+		}
+# case and default should not have general statements after them
+		if ($line =~ /^.\s*(?:case\s*.*|default\s*):/g &amp;&amp;
+		    $line !~ /\G(?:
+			(?:\s*$;*)(?:\s*{)?(?:\s*$;*)(?:\s*\\)?\s*$|
+			\s*return\s+
+		    )/xg)
+		{
+			ERROR(&quot;TRAILING_STATEMENTS&quot;,
+			      &quot;trailing statements should be on next line\n&quot; . $herecurr);
+		}
+
+		# Check for }&lt;nl&gt;else {, these must be at the same
+		# indent level to be relevant to each other.
+		if ($prevline=~/}\s*$/ and $line=~/^.\s*else\s*/ and
+						$previndent == $indent) {
+			ERROR(&quot;ELSE_AFTER_BRACE&quot;,
+			      &quot;else should follow close brace '}'\n&quot; . $hereprev);
+		}
+
+		if ($prevline=~/}\s*$/ and $line=~/^.\s*while\s*/ and
+						$previndent == $indent) {
+			my ($s, $c) = ctx_statement_block($linenr, $realcnt, 0);
+
+			# Find out what is on the end of the line after the
+			# conditional.
+			substr($s, 0, length($c), '');
+			$s =~ s/\n.*//g;
+
+			if ($s =~ /^\s*;/) {
+				ERROR(&quot;WHILE_AFTER_BRACE&quot;,
+				      &quot;while should follow close brace '}'\n&quot; . $hereprev);
+			}
+		}
+
+#studly caps, commented out until figure out how to distinguish between use of existing and adding new
+#		if (($line=~/[\w_][a-z\d]+[A-Z]/) and !($line=~/print/)) {
+#		    print &quot;No studly caps, use _\n&quot;;
+#		    print &quot;$herecurr&quot;;
+#		    $clean = 0;
+#		}
+
+#no spaces allowed after \ in define
+		if ($line=~/\#\s*define.*\\\s$/) {
+			WARN(&quot;WHITESPACE_AFTER_LINE_CONTINUATION&quot;,
+			     &quot;Whitepspace after \\ makes next lines useless\n&quot; . $herecurr);
+		}
+
+#warn if &lt;asm/foo.h&gt; is #included and &lt;linux/foo.h&gt; is available (uses RAW line)
+		if ($tree &amp;&amp; $rawline =~ m{^.\s*\#\s*include\s*\&lt;asm\/(.*)\.h\&gt;}) {
+			my $file = &quot;$1.h&quot;;
+			my $checkfile = &quot;include/linux/$file&quot;;
+			if (-f &quot;$root/$checkfile&quot; &amp;&amp;
+			    $realfile ne $checkfile &amp;&amp;
+			    $1 !~ /$allowed_asm_includes/)
+			{
+				if ($realfile =~ m{^arch/}) {
+					CHK(&quot;ARCH_INCLUDE_LINUX&quot;,
+					    &quot;Consider using #include &lt;linux/$file&gt; instead of &lt;asm/$file&gt;\n&quot; . $herecurr);
+				} else {
+					WARN(&quot;INCLUDE_LINUX&quot;,
+					     &quot;Use #include &lt;linux/$file&gt; instead of &lt;asm/$file&gt;\n&quot; . $herecurr);
+				}
+			}
+		}
+
+# multi-statement macros should be enclosed in a do while loop, grab the
+# first statement and ensure its the whole macro if its not enclosed
+# in a known good container
+		if ($realfile !~ m@/vmlinux.lds.h$@ &amp;&amp;
+		    $line =~ /^.\s*\#\s*define\s*$Ident(\()?/) {
+			my $ln = $linenr;
+			my $cnt = $realcnt;
+			my ($off, $dstat, $dcond, $rest);
+			my $ctx = '';
+
+			my $args = defined($1);
+
+			# Find the end of the macro and limit our statement
+			# search to that.
+			while ($cnt &gt; 0 &amp;&amp; defined $lines[$ln - 1] &amp;&amp;
+				$lines[$ln - 1] =~ /^(?:-|..*\\$)/)
+			{
+				$ctx .= $rawlines[$ln - 1] . &quot;\n&quot;;
+				$cnt-- if ($lines[$ln - 1] !~ /^-/);
+				$ln++;
+			}
+			$ctx .= $rawlines[$ln - 1];
+
+			($dstat, $dcond, $ln, $cnt, $off) =
+				ctx_statement_block($linenr, $ln - $linenr + 1, 0);
+			#print &quot;dstat&lt;$dstat&gt; dcond&lt;$dcond&gt; cnt&lt;$cnt&gt; off&lt;$off&gt;\n&quot;;
+			#print &quot;LINE&lt;$lines[$ln-1]&gt; len&lt;&quot; . length($lines[$ln-1]) . &quot;\n&quot;;
+
+			# Extract the remainder of the define (if any) and
+			# rip off surrounding spaces, and trailing \'s.
+			$rest = '';
+			while ($off != 0 || ($cnt &gt; 0 &amp;&amp; $rest =~ /\\\s*$/)) {
+				#print &quot;ADDING cnt&lt;$cnt&gt; $off &lt;&quot; . substr($lines[$ln - 1], $off) . &quot;&gt; rest&lt;$rest&gt;\n&quot;;
+				if ($off != 0 || $lines[$ln - 1] !~ /^-/) {
+					$rest .= substr($lines[$ln - 1], $off) . &quot;\n&quot;;
+					$cnt--;
+				}
+				$ln++;
+				$off = 0;
+			}
+			$rest =~ s/\\\n.//g;
+			$rest =~ s/^\s*//s;
+			$rest =~ s/\s*$//s;
+
+			# Clean up the original statement.
+			if ($args) {
+				substr($dstat, 0, length($dcond), '');
+			} else {
+				$dstat =~ s/^.\s*\#\s*define\s+$Ident\s*//;
+			}
+			$dstat =~ s/$;//g;
+			$dstat =~ s/\\\n.//g;
+			$dstat =~ s/^\s*//s;
+			$dstat =~ s/\s*$//s;
+
+			# Flatten any parentheses and braces
+			while ($dstat =~ s/\([^\(\)]*\)/1/ ||
+			       $dstat =~ s/\{[^\{\}]*\}/1/ ||
+			       $dstat =~ s/\[[^\{\}]*\]/1/)
+			{
+			}
+
+			my $exceptions = qr{
+				$Declare|
+				module_param_named|
+				MODULE_PARAM_DESC|
+				DECLARE_PER_CPU|
+				DEFINE_PER_CPU|
+				__typeof__\(|
+				union|
+				struct|
+				\.$Ident\s*=\s*|
+				^\&quot;|\&quot;$
+			}x;
+			#print &quot;REST&lt;$rest&gt; dstat&lt;$dstat&gt; ctx&lt;$ctx&gt;\n&quot;;
+			if ($rest ne '' &amp;&amp; $rest ne ',') {
+				if ($rest !~ /while\s*\(/ &amp;&amp;
+				    $dstat !~ /$exceptions/)
+				{
+					ERROR(&quot;MULTISTATEMENT_MACRO_USE_DO_WHILE&quot;,
+					      &quot;Macros with multiple statements should be enclosed in a do - while loop\n&quot; . &quot;$here\n$ctx\n&quot;);
+				}
+
+			} elsif ($ctx !~ /;/) {
+				if ($dstat ne '' &amp;&amp;
+				    $dstat !~ /^(?:$Ident|-?$Constant)$/ &amp;&amp;
+				    $dstat !~ /$exceptions/ &amp;&amp;
+				    $dstat !~ /^\.$Ident\s*=/ &amp;&amp;
+				    $dstat =~ /$Operators/)
+				{
+					ERROR(&quot;COMPLEX_MACRO&quot;,
+					      &quot;Macros with complex values should be enclosed in parenthesis\n&quot; . &quot;$here\n$ctx\n&quot;);
+				}
+			}
+		}
+
+# make sure symbols are always wrapped with VMLINUX_SYMBOL() ...
+# all assignments may have only one of the following with an assignment:
+#	.
+#	ALIGN(...)
+#	VMLINUX_SYMBOL(...)
+		if ($realfile eq 'vmlinux.lds.h' &amp;&amp; $line =~ /(?:(?:^|\s)$Ident\s*=|=\s*$Ident(?:\s|$))/) {
+			WARN(&quot;MISSING_VMLINUX_SYMBOL&quot;,
+			     &quot;vmlinux.lds.h needs VMLINUX_SYMBOL() around C-visible symbols\n&quot; . $herecurr);
+		}
+
+# check for redundant bracing round if etc
+		if ($line =~ /(^.*)\bif\b/ &amp;&amp; $1 !~ /else\s*$/) {
+			my ($level, $endln, @chunks) =
+				ctx_statement_full($linenr, $realcnt, 1);
+			#print &quot;chunks&lt;$#chunks&gt; linenr&lt;$linenr&gt; endln&lt;$endln&gt; level&lt;$level&gt;\n&quot;;
+			#print &quot;APW: &lt;&lt;$chunks[1][0]&gt;&gt;&lt;&lt;$chunks[1][1]&gt;&gt;\n&quot;;
+			if ($#chunks &gt; 0 &amp;&amp; $level == 0) {
+				my $allowed = 0;
+				my $seen = 0;
+				my $herectx = $here . &quot;\n&quot;;
+				my $ln = $linenr - 1;
+				for my $chunk (@chunks) {
+					my ($cond, $block) = @{$chunk};
+
+					# If the condition carries leading newlines, then count those as offsets.
+					my ($whitespace) = ($cond =~ /^((?:\s*\n[+-])*\s*)/s);
+					my $offset = statement_rawlines($whitespace) - 1;
+
+					#print &quot;COND&lt;$cond&gt; whitespace&lt;$whitespace&gt; offset&lt;$offset&gt;\n&quot;;
+
+					# We have looked at and allowed this specific line.
+					$suppress_ifbraces{$ln + $offset} = 1;
+
+					$herectx .= &quot;$rawlines[$ln + $offset]\n[...]\n&quot;;
+					$ln += statement_rawlines($block) - 1;
+
+					substr($block, 0, length($cond), '');
+
+					$seen++ if ($block =~ /^\s*{/);
+
+					#print &quot;cond&lt;$cond&gt; block&lt;$block&gt; allowed&lt;$allowed&gt;\n&quot;;
+					if (statement_lines($cond) &gt; 1) {
+						#print &quot;APW: ALLOWED: cond&lt;$cond&gt;\n&quot;;
+						$allowed = 1;
+					}
+					if ($block =~/\b(?:if|for|while)\b/) {
+						#print &quot;APW: ALLOWED: block&lt;$block&gt;\n&quot;;
+						$allowed = 1;
+					}
+					if (statement_block_size($block) &gt; 1) {
+						#print &quot;APW: ALLOWED: lines block&lt;$block&gt;\n&quot;;
+						$allowed = 1;
+					}
+				}
+				if ($seen &amp;&amp; !$allowed) {
+					WARN(&quot;BRACES&quot;,
+					     &quot;braces {} are not necessary for any arm of this statement\n&quot; . $herectx);
+				}
+			}
+		}
+		if (!defined $suppress_ifbraces{$linenr - 1} &amp;&amp;
+					$line =~ /\b(if|while|for|else)\b/) {
+			my $allowed = 0;
+
+			# Check the pre-context.
+			if (substr($line, 0, $-[0]) =~ /(\}\s*)$/) {
+				#print &quot;APW: ALLOWED: pre&lt;$1&gt;\n&quot;;
+				$allowed = 1;
+			}
+
+			my ($level, $endln, @chunks) =
+				ctx_statement_full($linenr, $realcnt, $-[0]);
+
+			# Check the condition.
+			my ($cond, $block) = @{$chunks[0]};
+			#print &quot;CHECKING&lt;$linenr&gt; cond&lt;$cond&gt; block&lt;$block&gt;\n&quot;;
+			if (defined $cond) {
+				substr($block, 0, length($cond), '');
+			}
+			if (statement_lines($cond) &gt; 1) {
+				#print &quot;APW: ALLOWED: cond&lt;$cond&gt;\n&quot;;
+				$allowed = 1;
+			}
+			if ($block =~/\b(?:if|for|while)\b/) {
+				#print &quot;APW: ALLOWED: block&lt;$block&gt;\n&quot;;
+				$allowed = 1;
+			}
+			if (statement_block_size($block) &gt; 1) {
+				#print &quot;APW: ALLOWED: lines block&lt;$block&gt;\n&quot;;
+				$allowed = 1;
+			}
+			# Check the post-context.
+			if (defined $chunks[1]) {
+				my ($cond, $block) = @{$chunks[1]};
+				if (defined $cond) {
+					substr($block, 0, length($cond), '');
+				}
+				if ($block =~ /^\s*\{/) {
+					#print &quot;APW: ALLOWED: chunk-1 block&lt;$block&gt;\n&quot;;
+					$allowed = 1;
+				}
+			}
+			if ($level == 0 &amp;&amp; $block =~ /^\s*\{/ &amp;&amp; !$allowed) {
+				my $herectx = $here . &quot;\n&quot;;
+				my $cnt = statement_rawlines($block);
+
+				for (my $n = 0; $n &lt; $cnt; $n++) {
+					$herectx .= raw_line($linenr, $n) . &quot;\n&quot;;
+				}
+
+				WARN(&quot;BRACES&quot;,
+				     &quot;braces {} are not necessary for single statement blocks\n&quot; . $herectx);
+			}
+		}
+
+# don't include deprecated include files (uses RAW line)
+		for my $inc (@dep_includes) {
+			if ($rawline =~ m@^.\s*\#\s*include\s*\&lt;$inc&gt;@) {
+				ERROR(&quot;DEPRECATED_INCLUDE&quot;,
+				      &quot;Don't use &lt;$inc&gt;: see Documentation/feature-removal-schedule.txt\n&quot; . $herecurr);
+			}
+		}
+
+# don't use deprecated functions
+		for my $func (@dep_functions) {
+			if ($line =~ /\b$func\b/) {
+				ERROR(&quot;DEPRECATED_FUNCTION&quot;,
+				      &quot;Don't use $func(): see Documentation/feature-removal-schedule.txt\n&quot; . $herecurr);
+			}
+		}
+
+# no volatiles please
+		my $asm_volatile = qr{\b(__asm__|asm)\s+(__volatile__|volatile)\b};
+		if ($line =~ /\bvolatile\b/ &amp;&amp; $line !~ /$asm_volatile/) {
+			WARN(&quot;VOLATILE&quot;,
+			     &quot;Use of volatile is usually wrong: see Documentation/volatile-considered-harmful.txt\n&quot; . $herecurr);
+		}
+
+# warn about #if 0
+		if ($line =~ /^.\s*\#\s*if\s+0\b/) {
+			CHK(&quot;REDUNDANT_CODE&quot;,
+			    &quot;if this code is redundant consider removing it\n&quot; .
+				$herecurr);
+		}
+
+# check for needless kfree() checks
+		if ($prevline =~ /\bif\s*\(([^\)]*)\)/) {
+			my $expr = $1;
+			if ($line =~ /\bkfree\(\Q$expr\E\);/) {
+				WARN(&quot;NEEDLESS_KFREE&quot;,
+				     &quot;kfree(NULL) is safe this check is probably not required\n&quot; . $hereprev);
+			}
+		}
+# check for needless usb_free_urb() checks
+		if ($prevline =~ /\bif\s*\(([^\)]*)\)/) {
+			my $expr = $1;
+			if ($line =~ /\busb_free_urb\(\Q$expr\E\);/) {
+				WARN(&quot;NEEDLESS_USB_FREE_URB&quot;,
+				     &quot;usb_free_urb(NULL) is safe this check is probably not required\n&quot; . $hereprev);
+			}
+		}
+
+# prefer usleep_range over udelay
+		if ($line =~ /\budelay\s*\(\s*(\w+)\s*\)/) {
+			# ignore udelay's &lt; 10, however
+			if (! (($1 =~ /(\d+)/) &amp;&amp; ($1 &lt; 10)) ) {
+				CHK(&quot;USLEEP_RANGE&quot;,
+				    &quot;usleep_range is preferred over udelay; see Documentation/timers/timers-howto.txt\n&quot; . $line);
+			}
+		}
+
+# warn about unexpectedly long msleep's
+		if ($line =~ /\bmsleep\s*\((\d+)\);/) {
+			if ($1 &lt; 20) {
+				WARN(&quot;MSLEEP&quot;,
+				     &quot;msleep &lt; 20ms can sleep for up to 20ms; see Documentation/timers/timers-howto.txt\n&quot; . $line);
+			}
+		}
+
+# warn about #ifdefs in C files
+#		if ($line =~ /^.\s*\#\s*if(|n)def/ &amp;&amp; ($realfile =~ /\.c$/)) {
+#			print &quot;#ifdef in C files should be avoided\n&quot;;
+#			print &quot;$herecurr&quot;;
+#			$clean = 0;
+#		}
+
+# warn about spacing in #ifdefs
+		if ($line =~ /^.\s*\#\s*(ifdef|ifndef|elif)\s\s+/) {
+			ERROR(&quot;SPACING&quot;,
+			      &quot;exactly one space required after that #$1\n&quot; . $herecurr);
+		}
+
+# check for spinlock_t definitions without a comment.
+		if ($line =~ /^.\s*(struct\s+mutex|spinlock_t)\s+\S+;/ ||
+		    $line =~ /^.\s*(DEFINE_MUTEX)\s*\(/) {
+			my $which = $1;
+			if (!ctx_has_comment($first_line, $linenr)) {
+				CHK(&quot;UNCOMMENTED_DEFINITION&quot;,
+				    &quot;$1 definition without comment\n&quot; . $herecurr);
+			}
+		}
+# check for memory barriers without a comment.
+		if ($line =~ /\b(mb|rmb|wmb|read_barrier_depends|smp_mb|smp_rmb|smp_wmb|smp_read_barrier_depends)\(/) {
+			if (!ctx_has_comment($first_line, $linenr)) {
+				CHK(&quot;MEMORY_BARRIER&quot;,
+				    &quot;memory barrier without comment\n&quot; . $herecurr);
+			}
+		}
+# check of hardware specific defines
+		if ($line =~ m@^.\s*\#\s*if.*\b(__i386__|__powerpc64__|__sun__|__s390x__)\b@ &amp;&amp; $realfile !~ <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">m at include</A>/asm-@) {
+			CHK(&quot;ARCH_DEFINES&quot;,
+			    &quot;architecture specific defines should be avoided\n&quot; .  $herecurr);
+		}
+
+# Check that the storage class is at the beginning of a declaration
+		if ($line =~ /\b$Storage\b/ &amp;&amp; $line !~ /^.\s*$Storage\b/) {
+			WARN(&quot;STORAGE_CLASS&quot;,
+			     &quot;storage class should be at the beginning of the declaration\n&quot; . $herecurr)
+		}
+
+# check the location of the inline attribute, that it is between
+# storage class and type.
+		if ($line =~ /\b$Type\s+$Inline\b/ ||
+		    $line =~ /\b$Inline\s+$Storage\b/) {
+			ERROR(&quot;INLINE_LOCATION&quot;,
+			      &quot;inline keyword should sit between storage class and type\n&quot; . $herecurr);
+		}
+
+# Check for __inline__ and __inline, prefer inline
+		if ($line =~ /\b(__inline__|__inline)\b/) {
+			WARN(&quot;INLINE&quot;,
+			     &quot;plain inline is preferred over $1\n&quot; . $herecurr);
+		}
+
+# Check for __attribute__ packed, prefer __packed
+		if ($line =~ /\b__attribute__\s*\(\s*\(.*\bpacked\b/) {
+			WARN(&quot;PREFER_PACKED&quot;,
+			     &quot;__packed is preferred over __attribute__((packed))\n&quot; . $herecurr);
+		}
+
+# Check for __attribute__ aligned, prefer __aligned
+		if ($line =~ /\b__attribute__\s*\(\s*\(.*aligned/) {
+			WARN(&quot;PREFER_ALIGNED&quot;,
+			     &quot;__aligned(size) is preferred over __attribute__((aligned(size)))\n&quot; . $herecurr);
+		}
+
+# check for sizeof(&amp;)
+		if ($line =~ /\bsizeof\s*\(\s*\&amp;/) {
+			WARN(&quot;SIZEOF_ADDRESS&quot;,
+			     &quot;sizeof(&amp; should be avoided\n&quot; . $herecurr);
+		}
+
+# check for line continuations in quoted strings with odd counts of &quot;
+		if ($rawline =~ /\\$/ &amp;&amp; $rawline =~ tr/&quot;/&quot;/ % 2) {
+			WARN(&quot;LINE_CONTINUATIONS&quot;,
+			     &quot;Avoid line continuations in quoted strings\n&quot; . $herecurr);
+		}
+
+# check for new externs in .c files.
+		if ($realfile =~ /\.c$/ &amp;&amp; defined $stat &amp;&amp;
+		    $stat =~ /^.\s*(?:extern\s+)?$Type\s+($Ident)(\s*)\(/s)
+		{
+			my $function_name = $1;
+			my $paren_space = $2;
+
+			my $s = $stat;
+			if (defined $cond) {
+				substr($s, 0, length($cond), '');
+			}
+			if ($s =~ /^\s*;/ &amp;&amp;
+			    $function_name ne 'uninitialized_var')
+			{
+				WARN(&quot;AVOID_EXTERNS&quot;,
+				     &quot;externs should be avoided in .c files\n&quot; .  $herecurr);
+			}
+
+			if ($paren_space =~ /\n/) {
+				WARN(&quot;FUNCTION_ARGUMENTS&quot;,
+				     &quot;arguments for function declarations should follow identifier\n&quot; . $herecurr);
+			}
+
+		} elsif ($realfile =~ /\.c$/ &amp;&amp; defined $stat &amp;&amp;
+		    $stat =~ /^.\s*extern\s+/)
+		{
+			WARN(&quot;AVOID_EXTERNS&quot;,
+			     &quot;externs should be avoided in .c files\n&quot; .  $herecurr);
+		}
+
+# checks for new __setup's
+		if ($rawline =~ /\b__setup\(&quot;([^&quot;]*)&quot;/) {
+			my $name = $1;
+
+			if (!grep(/$name/, @setup_docs)) {
+				CHK(&quot;UNDOCUMENTED_SETUP&quot;,
+				    &quot;__setup appears un-documented -- check Documentation/kernel-parameters.txt\n&quot; . $herecurr);
+			}
+		}
+
+# check for pointless casting of kmalloc return
+		if ($line =~ /\*\s*\)\s*[kv][czm]alloc(_node){0,1}\b/) {
+			WARN(&quot;UNNECESSARY_CASTS&quot;,
+			     &quot;unnecessary cast may hide bugs, see <A HREF="http://c-faq.com/malloc/mallocnocast.html\n">http://c-faq.com/malloc/mallocnocast.html\n</A>&quot; . $herecurr);
+		}
+
+# check for multiple semicolons
+		if ($line =~ /;\s*;\s*$/) {
+		    WARN(&quot;ONE_SEMICOLON&quot;,
+			 &quot;Statements terminations use 1 semicolon\n&quot; . $herecurr);
+		}
+
+# check for gcc specific __FUNCTION__
+		if ($line =~ /__FUNCTION__/) {
+			WARN(&quot;USE_FUNC&quot;,
+			     &quot;__func__ should be used instead of gcc specific __FUNCTION__\n&quot;  . $herecurr);
+		}
+
+# check for semaphores initialized locked
+		if ($line =~ /^.\s*sema_init.+,\W?0\W?\)/) {
+			WARN(&quot;CONSIDER_COMPLETION&quot;,
+			     &quot;consider using a completion\n&quot; . $herecurr);
+
+		}
+# recommend kstrto* over simple_strto*
+		if ($line =~ /\bsimple_(strto.*?)\s*\(/) {
+			WARN(&quot;CONSIDER_KSTRTO&quot;,
+			     &quot;consider using kstrto* in preference to simple_$1\n&quot; . $herecurr);
+		}
+# check for __initcall(), use device_initcall() explicitly please
+		if ($line =~ /^.\s*__initcall\s*\(/) {
+			WARN(&quot;USE_DEVICE_INITCALL&quot;,
+			     &quot;please use device_initcall() instead of __initcall()\n&quot; . $herecurr);
+		}
+# check for various ops structs, ensure they are const.
+		my $struct_ops = qr{acpi_dock_ops|
+				address_space_operations|
+				backlight_ops|
+				block_device_operations|
+				dentry_operations|
+				dev_pm_ops|
+				dma_map_ops|
+				extent_io_ops|
+				file_lock_operations|
+				file_operations|
+				hv_ops|
+				ide_dma_ops|
+				intel_dvo_dev_ops|
+				item_operations|
+				iwl_ops|
+				kgdb_arch|
+				kgdb_io|
+				kset_uevent_ops|
+				lock_manager_operations|
+				microcode_ops|
+				mtrr_ops|
+				neigh_ops|
+				nlmsvc_binding|
+				pci_raw_ops|
+				pipe_buf_operations|
+				platform_hibernation_ops|
+				platform_suspend_ops|
+				proto_ops|
+				rpc_pipe_ops|
+				seq_operations|
+				snd_ac97_build_ops|
+				soc_pcmcia_socket_ops|
+				stacktrace_ops|
+				sysfs_ops|
+				tty_operations|
+				usb_mon_operations|
+				wd_ops}x;
+		if ($line !~ /\bconst\b/ &amp;&amp;
+		    $line =~ /\bstruct\s+($struct_ops)\b/) {
+			WARN(&quot;CONST_STRUCT&quot;,
+			     &quot;struct $1 should normally be const\n&quot; .
+				$herecurr);
+		}
+
+# use of NR_CPUS is usually wrong
+# ignore definitions of NR_CPUS and usage to define arrays as likely right
+		if ($line =~ /\bNR_CPUS\b/ &amp;&amp;
+		    $line !~ /^.\s*\s*#\s*if\b.*\bNR_CPUS\b/ &amp;&amp;
+		    $line !~ /^.\s*\s*#\s*define\b.*\bNR_CPUS\b/ &amp;&amp;
+		    $line !~ /^.\s*$Declare\s.*\[[^\]]*NR_CPUS[^\]]*\]/ &amp;&amp;
+		    $line !~ /\[[^\]]*\.\.\.[^\]]*NR_CPUS[^\]]*\]/ &amp;&amp;
+		    $line !~ /\[[^\]]*NR_CPUS[^\]]*\.\.\.[^\]]*\]/)
+		{
+			WARN(&quot;NR_CPUS&quot;,
+			     &quot;usage of NR_CPUS is often wrong - consider using cpu_possible(), num_possible_cpus(), for_each_possible_cpu(), etc\n&quot; . $herecurr);
+		}
+
+# check for %L{u,d,i} in strings
+		my $string;
+		while ($line =~ /(?:^|&quot;)([X\t]*)(?:&quot;|$)/g) {
+			$string = substr($rawline, $-[1], $+[1] - $-[1]);
+			$string =~ s/%%/__/g;
+			if ($string =~ /(?&lt;!%)%L[udi]/) {
+				WARN(&quot;PRINTF_L&quot;,
+				     &quot;\%Ld/%Lu are not-standard C, use %lld/%llu\n&quot; . $herecurr);
+				last;
+			}
+		}
+
+# whine mightly about in_atomic
+		if ($line =~ /\bin_atomic\s*\(/) {
+			if ($realfile =~ m@^drivers/@) {
+				ERROR(&quot;IN_ATOMIC&quot;,
+				      &quot;do not use in_atomic in drivers\n&quot; . $herecurr);
+			} elsif ($realfile !~ m@^kernel/@) {
+				WARN(&quot;IN_ATOMIC&quot;,
+				     &quot;use of in_atomic() is incorrect outside core kernel code\n&quot; . $herecurr);
+			}
+		}
+
+# check for lockdep_set_novalidate_class
+		if ($line =~ /^.\s*lockdep_set_novalidate_class\s*\(/ ||
+		    $line =~ /__lockdep_no_validate__\s*\)/ ) {
+			if ($realfile !~ m@^kernel/lockdep@ &amp;&amp;
+			    $realfile !~ m@^include/linux/lockdep@ &amp;&amp;
+			    $realfile !~ m@^drivers/base/core@) {
+				ERROR(&quot;LOCKDEP&quot;,
+				      &quot;lockdep_no_validate class is reserved for device-&gt;mutex.\n&quot; . $herecurr);
+			}
+		}
+
+		if ($line =~ /debugfs_create_file.*S_IWUGO/ ||
+		    $line =~ /DEVICE_ATTR.*S_IWUGO/ ) {
+			WARN(&quot;EXPORTED_WORLD_WRITABLE&quot;,
+			     &quot;Exporting world writable files is usually an error. Consider more restrictive permissions.\n&quot; . $herecurr);
+		}
+
+		# Check for memset with swapped arguments
+		if ($line =~ /memset.*\,(\ |)(0x|)0(\ |0|)\);/) {
+			ERROR(&quot;MEMSET&quot;,
+			      &quot;memset size is 3rd argument, not the second.\n&quot; . $herecurr);
+		}
+	}
+
+	# If we have no input at all, then there is nothing to report on
+	# so just keep quiet.
+	if ($#rawlines == -1) {
+		exit(0);
+	}
+
+	# In mailback mode only produce a report in the negative, for
+	# things that appear to be patches.
+	if ($mailback &amp;&amp; ($clean == 1 || !$is_patch)) {
+		exit(0);
+	}
+
+	# This is not a patch, and we are are in 'no-patch' mode so
+	# just keep quiet.
+	if (!$chk_patch &amp;&amp; !$is_patch) {
+		exit(0);
+	}
+
+	if (!$is_patch) {
+		ERROR(&quot;NOT_UNIFIED_DIFF&quot;,
+		      &quot;Does not appear to be a unified-diff format patch\n&quot;);
+	}
+	if ($is_patch &amp;&amp; $chk_signoff &amp;&amp; $signoff == 0) {
+		ERROR(&quot;MISSING_SIGN_OFF&quot;,
+		      &quot;Missing Signed-off-by: line(s)\n&quot;);
+	}
+
+	print report_dump();
+	if ($summary &amp;&amp; !($clean == 1 &amp;&amp; $quiet == 1)) {
+		print &quot;$filename &quot; if ($summary_file);
+		print &quot;total: $cnt_error errors, $cnt_warn warnings, &quot; .
+			(($check)? &quot;$cnt_chk checks, &quot; : &quot;&quot;) .
+			&quot;$cnt_lines lines checked\n&quot;;
+		print &quot;\n&quot; if ($quiet == 0);
+	}
+
+	if ($quiet == 0) {
+		# If there were whitespace errors which cleanpatch can fix
+		# then suggest that.
+		if ($rpt_cleaners) {
+			print &quot;NOTE: whitespace errors detected, you may wish to use scripts/cleanpatch or\n&quot;;
+			print &quot;      scripts/cleanfile\n\n&quot;;
+			$rpt_cleaners = 0;
+		}
+	}
+
+	if (keys %ignore_type) {
+	    print &quot;NOTE: Ignored message types:&quot;;
+	    foreach my $ignore (sort keys %ignore_type) {
+		print &quot; $ignore&quot;;
+	    }
+	    print &quot;\n&quot;;
+	    print &quot;\n&quot; if ($quiet == 0);
+	}
+
+	if ($clean == 1 &amp;&amp; $quiet == 0) {
+		print &quot;$vname has no obvious style problems and is ready for submission.\n&quot;
+	}
+	if ($clean == 0 &amp;&amp; $quiet == 0) {
+		print &lt;&lt; &quot;EOM&quot;;
+$vname has style problems, please review.
+
+If any of these errors are false positives, please report
+them to the maintainer, see CHECKPATCH in MAINTAINERS.
+EOM
+	}
+
+	return $clean;
+}

-----------------------------------------------------------------------

Summary of changes:
 tools/scripts/checkpatch.pl | 3337 +++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 3337 insertions(+), 0 deletions(-)
 create mode 100644 tools/scripts/checkpatch.pl


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002775.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-183-gbab6db1
</A></li>
	<LI>Next message: <A HREF="002777.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-185-gce3905a
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2776">[ date ]</a>
              <a href="thread.html#2776">[ thread ]</a>
              <a href="subject.html#2776">[ subject ]</a>
              <a href="author.html#2776">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
