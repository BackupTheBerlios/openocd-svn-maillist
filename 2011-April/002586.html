<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-866-gd291162
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-April/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-866-gd291162&In-Reply-To=%3Cmailman.71.1331736154.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002585.html">
   <LINK REL="Next"  HREF="002587.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-866-gd291162</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-866-gd291162&In-Reply-To=%3Cmailman.71.1331736154.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-866-gd291162">gowinex at users.sourceforge.net
       </A><BR>
    <I>Thu Apr 28 12:28:02 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002585.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-862-g36d60ee
</A></li>
        <LI>Next message: <A HREF="002587.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-867-g5c739b1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2586">[ date ]</a>
              <a href="thread.html#2586">[ thread ]</a>
              <a href="subject.html#2586">[ subject ]</a>
              <a href="author.html#2586">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  d2911627d236ecf3d4ee537fb4e3f17de77a60bb (commit)
       via  1e7e59445287c3389b52903a7cacdb5635248f32 (commit)
       via  5578935eff66ed6db4a8f6b6957ab671dd36732b (commit)
       via  b778b36f29b74d6d571df85f984ae684672ea162 (commit)
      from  36d60ee6c8d3aa1865dac2378c481954ba402910 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d2911627d236ecf3d4ee537fb4e3f17de77a60bb
Author: Michel Jaouen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A>&gt;
Date:   Tue Apr 19 09:39:21 2011 +0200

    u8500.cfg : ste u8500 support

diff --git a/tcl/target/u8500.cfg b/tcl/target/u8500.cfg
new file mode 100644
index 0000000..f6e2091
--- /dev/null
+++ b/tcl/target/u8500.cfg
@@ -0,0 +1,326 @@
+#  Copyright (C) ST-Ericsson SA 2011
+#  Author : <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A>
+#  U8500 target 
+
+proc mmu_off {} {
+	set cp [arm mrc 15 0 1 0 0]
+	set cp [expr ($cp &amp; ~1)]
+	arm mcr 15 0 1 0 0 $cp
+}
+
+proc mmu_on {} {
+	set cp [arm mrc 15 0 1 0 0]
+	set cp [expr ($cp | 1)]
+	arm mcr 15 0 1 0 0 $cp
+}
+
+proc ocd_gdb_restart {target_id} {
+    global  _TARGETNAME_1
+	global _SMP
+    targets $_TARGETNAME_1
+	if { [expr ($_SMP == 1)] } {
+	cortex_a8 smp_off
+	}
+	rst_run
+	halt
+	if { [expr ($_SMP == 1)]} {
+	cortex_a8 smp_on
+	}
+}
+
+proc smp_reg {} {
+	global  _TARGETNAME_1
+    global  _TARGETNAME_2
+    targets $_TARGETNAME_1 
+	echo &quot;$_TARGETNAME_1&quot;
+	set pc1 [reg pc]
+	set stck1 [reg sp_svc]
+	targets  $_TARGETNAME_2
+	echo &quot;$_TARGETNAME_1&quot;
+	set pc2 [reg pc]
+	set stck2 [reg sp_svc]
+}
+
+
+proc u8500_tapenable {chip val} {
+	echo &quot;JTAG tap enable $chip&quot;
+}
+
+
+proc pwrsts { } {
+	global _CHIPNAME
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 0
+	set pwrsts [drscan $_CHIPNAME.jrc 16 0]
+    echo &quot;pwrsts =&quot;$pwrsts
+    set a9 [expr (0x$pwrsts &amp; 0xc)]
+	set ape [expr (0x$pwrsts &amp; 0x3)]
+	if {[string equal &quot;0&quot; $ape]} {
+		echo &quot;ape off&quot;
+	} else {
+		echo &quot;ape on&quot;
+	}
+	echo &quot;$a9&quot;
+	switch $a9 {
+		4 {
+			echo &quot;A9 in retention&quot;
+		  }
+		8 {
+			echo &quot;A9 100% DVFS&quot;
+		  }
+		c { 
+			echo &quot;A9 50% DVFS&quot;
+		}
+	}
+}
+
+proc poll_pwrsts { } {
+	global _CHIPNAME
+	set result 1
+	set i 0
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 0 
+	set pwrsts [drscan $_CHIPNAME.jrc 16 0]    
+	set pwrsts [expr (0x$pwrsts &amp; 0xc)]
+	while {[string equal &quot;4&quot; $pwrsts] &amp;&amp; $i&lt;20} {
+		irscan $_CHIPNAME.jrc 0x3a
+		drscan $_CHIPNAME.jrc 4 0; 
+		set pwrsts [drscan $_CHIPNAME.jrc 16 0]    
+		set pwrsts [expr (0x$pwrsts &amp; 0xc)]
+		if {![string equal &quot;4&quot; $pwrsts]} {
+			set result 1
+		} else {
+			set result 0
+			sleep 200
+			echo &quot;loop $i&quot;
+		}
+		incr i
+	}
+	return $result
+}
+
+proc halt_ { } {
+	if {[poll_pwrsts]==1} { 
+		halt
+	} else {
+		echo &quot;halt failed : target in retention&quot;
+	}
+}
+
+
+proc u8500_dapenable {chip} {
+}
+
+proc u8500_tapdisable {chip val} {
+	echo &quot;JTAG tap disable $chip&quot;
+}
+
+
+proc enable_apetap {} {
+	global  _CHIPNAME
+	global _TARGETNAME_2 
+    global _TARGETNAME_1
+	poll off
+	irscan $_CHIPNAME.jrc 0x3e
+	drscan $_CHIPNAME.jrc 8 0xcf 
+	jtag tapenable $_CHIPNAME.dap
+	irscan $_CHIPNAME.jrc 0x6
+	drscan $_CHIPNAME.jrc 32 0
+	irscan $_CHIPNAME.jrc 0x6
+	drscan $_CHIPNAME.jrc 32 0
+	set status [$_TARGETNAME_1 curstate]
+    if {[string equal &quot;unknown&quot; $status]} {
+	$_TARGETNAME_1 arp_examine
+	}
+	set status [$_TARGETNAME_2 curstate]
+    if {[string equal &quot;unknown&quot; $status]} {
+	$_TARGETNAME_2 arp_examine
+	}
+	}
+
+tcl_port 5555
+telnet_port 4444
+gdb_port 3333
+ 
+if { [info exists CHIPNAME] } {	
+global _CHIPNAME 
+    set  _CHIPNAME $CHIPNAME    
+} else {
+global _CHIPNAME 
+	set  _CHIPNAME u8500
+}
+
+if { [info exists ENDIAN] } {	
+	set  _ENDIAN $ENDIAN    
+} else {	 
+ # this defaults to a bigendian
+	set  _ENDIAN little
+}
+
+
+
+# Subsidiary TAP: APE with scan chains for ARM Debug, EmbeddedICE-RT,
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+	set _CPUTAPID 0x4ba00477
+}
+jtag newtap $_CHIPNAME dap -irlen 4 -ircapture 0xe -irmask 0xf -expected-id $_CPUTAPID -disable
+jtag configure $_CHIPNAME.dap -event tap-enable \
+	&quot;u8500_dapenable $_CHIPNAME.dap&quot;
+jtag configure $_CHIPNAME.dap -event tap-disable \
+	&quot;u8500_tapdisable $_CHIPNAME.dap 0xc0&quot;
+
+
+#CLTAPC TAP JRC equivalent
+if { [info exists CLTAPC_ID ] } {
+   set _CLTAPC_ID $CLTAPC_ID
+} else {
+   set _CLTAPC_ID 0x22286041
+}
+jtag newtap $_CHIPNAME jrc -irlen 6 -ircapture 0x6 -irmask 0xf -expected-id $_CLTAPC_ID -ignore-version
+
+
+if { ![info exists TARGETNAME_1 ] } {
+global  _TARGETNAME_1
+set _TARGETNAME_1 $_CHIPNAME.cpu1
+} else {
+global  _TARGETNAME_1
+set _TARGETNAME_1 $TARGETNAME_1
+}
+
+if { [info exists  DAP_DBG1] } {
+	set _DAP_DBG1 $DAP_DBG1
+} else {
+	set _DAP_DBG1 0x801A8000 
+}
+if { [info exists  DAP_DBG2] } {
+	set _DAP_DBG2 $DAP_DBG2
+} else {
+	set _DAP_DBG2 0x801AA000 
+}
+
+target create $_TARGETNAME_1 cortex_a8 -chain-position $_CHIPNAME.dap -dbgbase $_DAP_DBG1 -coreid 0
+
+$_TARGETNAME_1 configure -event gdb-attach {
+	halt
+}
+
+
+if { ![info exists TARGETNAME_2 ] } {
+global  _TARGETNAME_2
+set _TARGETNAME_2 $_CHIPNAME.cpu2
+} else {
+global  _TARGETNAME_2
+set _TARGETNAME_2 $TARGETNAME_2
+}
+
+target create $_TARGETNAME_2 cortex_a8 -chain-position $_CHIPNAME.dap -dbgbase $_DAP_DBG2 -coreid 1
+
+$_TARGETNAME_2 configure -event gdb-attach {
+	halt
+}
+
+
+if {![info exists SMP]} {
+global _SMP
+set _SMP 1
+} else {
+global _SMP
+set _SMP $SMP
+}
+global SMP
+if { $_SMP == 1} { 
+target smp $_CHIPNAME.cpu2 $_CHIPNAME.cpu1
+}
+
+proc secsts1 { } {
+	global _CHIPNAME
+        irscan $_CHIPNAME.jrc 0x3a
+		drscan $_CHIPNAME.jrc 4 4
+	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+	echo &quot;secsts1 =&quot;$secsts1
+	set secsts1 [expr (0x$secsts1 &amp; 0x4)]
+	if {![string equal &quot;4&quot; $secsts1]} {
+	echo &quot;APE target secured&quot;
+        } else {
+        echo &quot;APE target not secured&quot;
+        }
+}
+
+proc att { } {
+	global _CHIPNAME
+	jtag arp_init
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 4
+	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+	echo &quot;secsts1 =&quot;$secsts1
+	set secsts1 [expr (0x$secsts1 &amp; 0x4)]
+	if {[string equal &quot;4&quot; $secsts1]} {
+		if {[poll_pwrsts]==1} {
+		enable_apetap
+                } else {
+		echo &quot;target in retention&quot;
+		}
+	} else {
+		echo &quot;target secured&quot;
+	}
+}
+
+
+
+proc rst_run { } {
+	global _CHIPNAME
+	global _TARGETNAME_2
+	global _TARGETNAME_1
+	set status [$_TARGETNAME_1 curstate]
+	if {[string equal &quot;halted&quot; $status]} {
+	resume
+	targets $_TARGETNAME_1
+	}
+    set status [$_TARGETNAME_2 curstate]
+	if {[string equal &quot;halted&quot; $status]} {
+	resume
+	targets $_TARGETNAME_2
+	}
+   	poll off
+	jtag arp_init
+	reset
+	sleep 20
+	irscan $_CHIPNAME.jrc 0x3a
+	drscan $_CHIPNAME.jrc 4 4
+	set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+	echo &quot;secsts1 =&quot;$secsts1
+	set secsts1 [expr (0x$secsts1 &amp; 0x4)]
+	while {![string equal &quot;4&quot; $secsts1]} {
+		irscan u8500.jrc 0x3a
+		drscan u8500.jrc 4 4
+		set secsts1 [drscan $_CHIPNAME.jrc 16 0]
+		echo &quot;secsts1 =&quot;$secsts1
+		set secsts1 [expr (0x$secsts1 &amp; 0x4)]
+	}
+	echo &quot;ape debugable&quot;
+	enable_apetap
+	poll on
+	targets $_TARGETNAME_1
+	dap apsel 1
+}
+
+if {![info exists MAXSPEED]} {
+global _MAXSPEED
+set _MAXSPEED 15000
+} else {
+global _MAXSPEED 
+set _MAXSPEED $MAXSPEED
+}
+global _MAXSPEED 
+adapter_khz $_MAXSPEED
+
+
+gdb_breakpoint_override hard
+set mem inaccessible-by-default-off
+
+jtag_ntrst_delay 100
+reset_config trst_and_srst combined
+
+

commit 1e7e59445287c3389b52903a7cacdb5635248f32
Author: Michel Jaouen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A>&gt;
Date:   Tue Apr 19 09:36:41 2011 +0200

    gdb_server : 'R' command replied by OK

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index aeb4e2e..9c1d245 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -2363,6 +2363,7 @@ static int gdb_input_inner(struct connection *connection)
 					command_run_linef(connection-&gt;cmd_ctx,
 							&quot;ocd_gdb_restart %s&quot;,
 							target_name(target));
+					gdb_put_packet(connection, &quot;OK&quot;, 2);
 					break;
 
 				case 'j':

commit 5578935eff66ed6db4a8f6b6957ab671dd36732b
Author: Michel Jaouen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A>&gt;
Date:   Tue Apr 19 08:50:00 2011 +0200

    cortex_a : smp support
    
    Conflicts:
    
    	src/target/cortex_a.c

diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 934f75a..9b8ba41 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -14,6 +14,9 @@
  *   Copyright (C) 2010 &#195;&#152;yvind Harboe                                      *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A> : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -671,7 +674,54 @@ static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 
 	return retval;
 }
+static struct target *get_cortex_a8(struct target *target, int32_t coreid)
+{
+struct target_list *head;
+struct target *curr;
 
+	head = target-&gt;head;
+	while(head != (struct target_list*)NULL)
+	{
+		curr = head-&gt;target;
+		if ((curr-&gt;coreid == coreid) &amp;&amp; (curr-&gt;state == TARGET_HALTED))
+		{
+        return curr;
+		}
+		head = head-&gt;next;
+	}
+   return target;
+}
+static int cortex_a8_halt(struct target *target);
+
+static int cortex_a8_halt_smp(struct target *target)
+{
+	int retval = 0;
+	struct target_list *head;
+	struct target *curr;
+	head = target-&gt;head;
+	while(head != (struct target_list*)NULL)
+	{
+		curr = head-&gt;target;
+		if ((curr != target) &amp;&amp; (curr-&gt;state!= TARGET_HALTED))
+		{
+			retval += cortex_a8_halt(curr);
+		}
+		head = head-&gt;next;
+	}
+	return retval;
+}
+
+static int update_halt_gdb(struct target *target)
+{
+	int retval = 0;
+	if (target-&gt;gdb_service-&gt;core[0]==-1)
+	{
+		target-&gt;gdb_service-&gt;target = target;
+		target-&gt;gdb_service-&gt;core[0] = target-&gt;coreid;
+		retval += cortex_a8_halt_smp(target);
+	}
+	return retval;
+}
 
 /*
  * Cortex-A8 Run control
@@ -685,7 +735,20 @@ static int cortex_a8_poll(struct target *target)
 	struct armv7a_common *armv7a = &amp;cortex_a8-&gt;armv7a_common;
 	struct adiv5_dap *swjdp = armv7a-&gt;armv4_5_common.dap;
 	enum target_state prev_target_state = target-&gt;state;
-
+	//  toggle to another core is done by gdb as follow
+	//  maint packet J core_id
+	//  continue
+	//  the next polling trigger an halt event sent to gdb
+	if ((target-&gt;state == TARGET_HALTED) &amp;&amp; (target-&gt;smp) &amp;&amp;
+			(target-&gt;gdb_service) &amp;&amp;
+			(target-&gt;gdb_service-&gt;target==NULL) )
+	{
+		target-&gt;gdb_service-&gt;target =
+			get_cortex_a8(target, target-&gt;gdb_service-&gt;core[1]);
+		target_call_event_callbacks(target,
+				TARGET_EVENT_HALTED);
+		return retval;
+	}
 	retval = mem_ap_sel_read_atomic_u32(swjdp, swjdp_debugap,
 			armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
 	if (retval != ERROR_OK)
@@ -707,7 +770,12 @@ static int cortex_a8_poll(struct target *target)
 				retval = cortex_a8_debug_entry(target);
 				if (retval != ERROR_OK)
 					return retval;
-
+				if (target-&gt;smp)
+				{
+					retval = update_halt_gdb(target);
+					if (retval != ERROR_OK)
+						return retval;
+				}
 				target_call_event_callbacks(target,
 						TARGET_EVENT_HALTED);
 			}
@@ -718,6 +786,12 @@ static int cortex_a8_poll(struct target *target)
 				retval = cortex_a8_debug_entry(target);
 				if (retval != ERROR_OK)
 					return retval;
+				if (target-&gt;smp)
+				{
+					retval = update_halt_gdb(target);
+					if (retval != ERROR_OK)
+						return retval;
+				}
 
 				target_call_event_callbacks(target,
 						TARGET_EVENT_DEBUG_HALTED);
@@ -789,16 +863,13 @@ static int cortex_a8_halt(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_a8_resume(struct target *target, int current,
-		uint32_t address, int handle_breakpoints, int debug_execution)
+static int cortex_a8_internal_restore(struct target *target, int current,
+		uint32_t *address, int handle_breakpoints, int debug_execution)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *armv4_5 = &amp;armv7a-&gt;armv4_5_common;
-	struct adiv5_dap *swjdp = armv7a-&gt;armv4_5_common.dap;
 	int retval;
-
-//	struct breakpoint *breakpoint = NULL;
-	uint32_t resume_pc, dscr;
+	uint32_t resume_pc;
 
 	if (!debug_execution)
 		target_free_all_working_areas(target);
@@ -827,7 +898,9 @@ static int cortex_a8_resume(struct target *target, int current,
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
 	resume_pc = buf_get_u32(armv4_5-&gt;pc-&gt;value, 0, 32);
 	if (!current)
-		resume_pc = address;
+		resume_pc = *address;
+	else
+		*address = resume_pc;
 
 	/* Make sure that the Armv7 gdb thumb fixups does not
 	 * kill the return address
@@ -856,6 +929,11 @@ static int cortex_a8_resume(struct target *target, int current,
 	retval = cortex_a8_restore_context(target, handle_breakpoints);
 	if (retval != ERROR_OK)
 		return retval;
+    target-&gt;debug_reason = DBG_REASON_NOTHALTED;
+	target-&gt;state = TARGET_RUNNING;
+
+	/* registers are now invalid */
+	register_cache_invalidate(armv4_5-&gt;core_cache);
 
 #if 0
 	/* the front-end may request us not to handle breakpoints */
@@ -872,8 +950,17 @@ static int cortex_a8_resume(struct target *target, int current,
 	}
 
 #endif
+	return retval;
+}
 
-	/*
+static int cortex_a8_internal_restart(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *armv4_5 = &amp;armv7a-&gt;armv4_5_common;
+	struct adiv5_dap *swjdp = armv4_5-&gt;dap;
+	int retval;
+	uint32_t dscr;
+/*
 	 * Restart core and wait for it to be started.  Clear ITRen and sticky
 	 * exception flags: see ARMv7 ARM, C5.9.
 	 *
@@ -895,7 +982,8 @@ static int cortex_a8_resume(struct target *target, int current,
 		return retval;
 
 	retval = mem_ap_sel_write_atomic_u32(swjdp, swjdp_debugap,
-			armv7a-&gt;debug_base + CPUDBG_DRCR, DRCR_RESTART | DRCR_CLEAR_EXCEPTIONS);
+			armv7a-&gt;debug_base + CPUDBG_DRCR, DRCR_RESTART |
+			DRCR_CLEAR_EXCEPTIONS);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -921,17 +1009,64 @@ static int cortex_a8_resume(struct target *target, int current,
 	/* registers are now invalid */
 	register_cache_invalidate(armv4_5-&gt;core_cache);
 
+	return ERROR_OK;
+}
+
+static int cortex_a8_restore_smp(struct target *target,int handle_breakpoints)
+{
+	int retval = 0;
+	struct target_list *head;
+	struct target *curr;
+    uint32_t address;
+	head = target-&gt;head;
+	while(head != (struct target_list*)NULL)
+	{
+		curr = head-&gt;target;
+		if ((curr != target) &amp;&amp; (curr-&gt;state != TARGET_RUNNING))
+		{
+		/*  resume current address , not in step mode */
+		retval += cortex_a8_internal_restore(curr, 1, &amp;address,
+				handle_breakpoints, 0);
+		  retval += cortex_a8_internal_restart(curr);
+		}
+		head = head-&gt;next;
+
+	}
+	return retval;
+}
+
+static int cortex_a8_resume(struct target *target, int current,
+		uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	int retval = 0;
+	/*   dummy resume for smp toggle in order to reduce gdb impact  */
+	if ((target-&gt;smp) &amp;&amp; (target-&gt;gdb_service-&gt;core[1]!=-1))
+	{
+		/*   simulate a start and halt of target */
+		target-&gt;gdb_service-&gt;target = NULL;
+		target-&gt;gdb_service-&gt;core[0] = target-&gt;gdb_service-&gt;core[1];
+		/*  fake resume at next poll we play the  target core[1], see poll*/
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		return 0;
+	}
+	cortex_a8_internal_restore(target, current, &amp;address, handle_breakpoints, debug_execution);
+	if (target-&gt;smp)
+	{   target-&gt;gdb_service-&gt;core[0] = -1;
+		retval += cortex_a8_restore_smp(target, handle_breakpoints);
+	}
+	cortex_a8_internal_restart(target);
+
 	if (!debug_execution)
 	{
 		target-&gt;state = TARGET_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG(&quot;target resumed at 0x%&quot; PRIx32, resume_pc);
+		LOG_DEBUG(&quot;target resumed at 0x%&quot; PRIx32, address);
 	}
 	else
 	{
 		target-&gt;state = TARGET_DEBUG_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG(&quot;target debug resumed at 0x%&quot; PRIx32, resume_pc);
+		LOG_DEBUG(&quot;target debug resumed at 0x%&quot; PRIx32, address);
 	}
 
 	return ERROR_OK;
@@ -1624,7 +1759,6 @@ static int cortex_a8_read_phys_memory(struct target *target,
 						buffer, count, address);
 				break;
 			}
-
 		} else {
 
 			/* read memory through APB-AP */
@@ -1664,6 +1798,7 @@ static int cortex_a8_read_memory(struct target *target, uint32_t address,
 		if (retval != ERROR_OK)
 			return retval;
 
+
 		if(enabled)
 		{
 			virt = address;
@@ -2032,7 +2167,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 
 	/* Leave (only) generic DAP stuff for debugport_init() */
 	dap-&gt;jtag_info = &amp;cortex_a8-&gt;jtag_info;
-	dap-&gt;memaccess_tck = 80;
 
 	/* Number of bits for tar autoincrement, impl. dep. at least 10 */
 	dap-&gt;tar_autoincr_block = (1 &lt;&lt; 10);
@@ -2270,6 +2404,68 @@ COMMAND_HANDLER(cortex_a8_handle_dbginit_command)
 
 	return cortex_a8_init_debug_access(target);
 }
+COMMAND_HANDLER(cortex_a8_handle_smp_off_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+    /* check target is an smp target */
+    struct target_list *head;
+	struct target *curr;
+	head = target-&gt;head;
+	target-&gt;smp = 0;
+	if (head != (struct target_list*)NULL)
+	{
+		while (head != (struct target_list*)NULL)
+		{
+			curr = head-&gt;target;
+			curr-&gt;smp = 0;
+			head = head-&gt;next;
+		}
+		/*  fixes the target display to the debugger */
+		target-&gt;gdb_service-&gt;target = target;
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(cortex_a8_handle_smp_on_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	struct target *curr;
+	head = target-&gt;head;
+	if (head != (struct target_list*)NULL)
+	{   target-&gt;smp=1;
+		while (head != (struct target_list*)NULL)
+		{
+			curr = head-&gt;target;
+			curr-&gt;smp = 1;
+			head = head-&gt;next;
+		}
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(cortex_a8_handle_smp_gdb_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	int retval = ERROR_OK;
+	struct target_list *head;
+	head = target-&gt;head;
+	if (head != (struct target_list*)NULL)
+	{
+		if (CMD_ARGC == 1)
+		{
+			int coreid = 0;
+			COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], coreid);
+			if (ERROR_OK != retval)
+				return retval;
+			target-&gt;gdb_service-&gt;core[1]=coreid;
+
+		}
+		command_print(CMD_CTX, &quot;gdb coreid  %d -&gt; %d&quot;, target-&gt;gdb_service-&gt;core[0]
+				, target-&gt;gdb_service-&gt;core[1]);
+	}
+	return ERROR_OK;
+}
 
 static const struct command_registration cortex_a8_exec_command_handlers[] = {
 	{
@@ -2284,6 +2480,25 @@ static const struct command_registration cortex_a8_exec_command_handlers[] = {
 		.mode = COMMAND_EXEC,
 		.help = &quot;Initialize core debug&quot;,
 	},
+	{   .name =&quot;smp_off&quot;,
+	    .handler = cortex_a8_handle_smp_off_command,
+		.mode = COMMAND_EXEC,
+		.help = &quot;Stop smp handling&quot;,
+	},
+	{
+        .name =&quot;smp_on&quot;,
+        .handler = cortex_a8_handle_smp_on_command,
+		.mode = COMMAND_EXEC,
+		.help = &quot;Restart smp handling&quot;,
+	},
+	{
+        .name =&quot;smp_gdb&quot;,
+        .handler = cortex_a8_handle_smp_gdb_command,
+		.mode = COMMAND_EXEC,
+		.help = &quot;display/fix current core played to gdb&quot;,
+	},
+
+
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration cortex_a8_command_handlers[] = {

commit b778b36f29b74d6d571df85f984ae684672ea162
Author: Michel Jaouen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A>&gt;
Date:   Tue Apr 19 08:43:33 2011 +0200

    smp : infra for smp minimum support

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 0b80858..aeb4e2e 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -11,6 +11,9 @@
  *   Copyright (C) 2011 by Broadcom Corporation                            *
  *   Evan Hunter - <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">ehunter at broadcom.com</A>                                    *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A> : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -39,6 +42,7 @@
 #include &lt;target/image.h&gt;
 #include &lt;jtag/jtag.h&gt;
 #include &quot;rtos/rtos.h&quot;
+#include &quot;target/smp.h&quot;
 
 
 /**
@@ -62,7 +66,7 @@ struct gdb_connection
 	int closed;
 	int busy;
 	int noack_mode;
-	bool sync; 	/* set flag to true if you want the next stepi to return immediately.
+	bool sync;	/* set flag to true if you want the next stepi to return immediately.
 	               allowing GDB to pick up a fresh set of register values from the target
 	               without modifying the target state. */
 	/* We delay reporting memory write errors until next step/continue or memory
@@ -2360,6 +2364,24 @@ static int gdb_input_inner(struct connection *connection)
 							&quot;ocd_gdb_restart %s&quot;,
 							target_name(target));
 					break;
+
+				case 'j':
+				    /*  packet supported only by smp target i.e cortex_a.c*/
+					/* handle smp packet replying coreid played to gbd */
+					gdb_read_smp_packet(
+							connection, target,
+							packet, packet_size);
+					break;
+
+				case 'J':
+					/*  packet supported only by smp target i.e cortex_a.c */
+					/*  handle smp packet setting coreid to be played at next
+					 *  resume to gdb */
+					gdb_write_smp_packet(
+							connection, target,
+							packet, packet_size);
+					break;
+
 				default:
 					/* ignore unknown packets */
 					LOG_DEBUG(&quot;ignoring 0x%2.2x packet&quot;, packet[0]);
@@ -2411,21 +2433,43 @@ static int gdb_input(struct connection *connection)
 
 static int gdb_target_start(struct target *target, const char *port)
 {
-	struct gdb_service *gdb_service = malloc(sizeof(struct gdb_service));
+
+	struct gdb_service *gdb_service;
+	int ret;
+	gdb_service = malloc(sizeof(struct gdb_service));
+
 	if (NULL == gdb_service)
 		return -ENOMEM;
 
 	gdb_service-&gt;target = target;
+	gdb_service-&gt;core[0] = -1;
+	gdb_service-&gt;core[1] = -1;
+	target-&gt;gdb_service = gdb_service;
 
-	return add_service(&quot;gdb&quot;,
+	ret = add_service(&quot;gdb&quot;,
 			port, 1, &amp;gdb_new_connection, &amp;gdb_input,
 			&amp;gdb_connection_closed, gdb_service);
+	/* initialialize all targets gdb service with the same pointer */
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target-&gt;head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head-&gt;target;
+			if (curr != target) curr-&gt;gdb_service = gdb_service;
+			head = head-&gt;next;	
+		}
+	}
+	return ret;
 }
 
 static int gdb_target_add_one(struct target *target)
 {
+	/*  one gdb instance per smp list */
+	if ((target-&gt;smp) &amp;&amp; (target-&gt;gdb_service)) return ERROR_OK;
 	int retval = gdb_target_start(target, gdb_port_next);
-	if (retval == ERROR_OK)
+	if (retval == ERROR_OK) 
 	{
 		long portnumber;
 		/* If we can parse the port number
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index cb3962f..e393fb7 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -30,15 +30,11 @@
 #define GDB_SERVER_H
 
 struct image;
+struct reg;
 #include &lt;target/target.h&gt;
 
 #define GDB_BUFFER_SIZE	16384
 
-struct gdb_service
-{
-	struct target *target;
-};
-
 int gdb_target_add_all(struct target *target);
 int gdb_register_commands(struct command_context *command_context);
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 5907e83..1a2fbd6 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -42,7 +42,8 @@ TARGET_CORE_SRC = \
 	breakpoints.c \
 	target.c \
 	target_request.c \
-	testee.c
+	testee.c \
+	smp.c
 
 ARMV4_5_SRC = \
 	armv4_5.c \
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
index 917dfc7..80f98dc 100644
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -2,6 +2,9 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A> : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -42,10 +45,11 @@ static char *watchpoint_rw_strings[] =
 // monotonic counter/id-number for breakpoints and watch points
 static int bpwp_unique_id;
 
-int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enum breakpoint_type type)
+int breakpoint_add_internal(struct target *target, uint32_t address, uint32_t length, enum breakpoint_type type)
 {
 	struct breakpoint *breakpoint = target-&gt;breakpoints;
 	struct breakpoint **breakpoint_p = &amp;target-&gt;breakpoints;
+	char *reason;
 	int retval;
 	int n;
 
@@ -76,9 +80,19 @@ int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enu
 	(*breakpoint_p)-&gt;unique_id = bpwp_unique_id++;
 
 	retval = target_add_breakpoint(target, *breakpoint_p);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR(&quot;could not add breakpoint&quot;);
+	switch (retval) {
+	case ERROR_OK:
+		break;
+	case ERROR_TARGET_RESOURCE_NOT_AVAILABLE:
+		reason = &quot;resource not available&quot;;
+		goto fail;
+	case ERROR_TARGET_NOT_HALTED:
+		reason = &quot;target running&quot;;
+		goto fail;
+	default:
+		reason = &quot;unknown reason&quot;;
+fail:
+		LOG_ERROR(&quot;can't add breakpoint: %s&quot;, reason);
 		free((*breakpoint_p)-&gt;orig_instr);
 		free(*breakpoint_p);
 		*breakpoint_p = NULL;
@@ -93,6 +107,29 @@ int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enu
 	return ERROR_OK;
 }
 
+int breakpoint_add(struct target *target, uint32_t address, uint32_t length, enum breakpoint_type type)
+{
+
+int retval = ERROR_OK;
+    if (target-&gt;smp)
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target-&gt;head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head-&gt;target;
+			retval = breakpoint_add_internal(curr, address,length, type);
+			if (retval != ERROR_OK) return retval;
+			head = head-&gt;next;	
+		}
+		return retval;
+	}
+	else
+	return(breakpoint_add_internal(target, address, length, type));
+
+}
+
 /* free up a breakpoint */
 static void breakpoint_free(struct target *target, struct breakpoint *breakpoint_to_remove)
 {
@@ -119,7 +156,7 @@ static void breakpoint_free(struct target *target, struct breakpoint *breakpoint
 	free(breakpoint);
 }
 
-void breakpoint_remove(struct target *target, uint32_t address)
+void breakpoint_remove_internal(struct target *target, uint32_t address)
 {
 	struct breakpoint *breakpoint = target-&gt;breakpoints;
 	struct breakpoint **breakpoint_p = &amp;target-&gt;breakpoints;
@@ -141,8 +178,24 @@ void breakpoint_remove(struct target *target, uint32_t address)
 		LOG_ERROR(&quot;no breakpoint at address 0x%8.8&quot; PRIx32 &quot; found&quot;, address);
 	}
 }
+void breakpoint_remove(struct target *target, uint32_t address)
+{
+    if ((target-&gt;smp))
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target-&gt;head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head-&gt;target;
+			breakpoint_remove_internal(curr, address);
+			head = head-&gt;next;	
+		}
+	}
+	else  breakpoint_remove_internal(target, address);
+}
 
-void breakpoint_clear_target(struct target *target)
+void breakpoint_clear_target_internal(struct target *target)
 {
 	struct breakpoint *breakpoint;
 
@@ -154,6 +207,25 @@ void breakpoint_clear_target(struct target *target)
 	}
 }
 
+void breakpoint_clear_target(struct target *target)
+{
+    if (target-&gt;smp)
+	{
+		struct target_list *head;
+		struct target *curr;
+		head = target-&gt;head;
+		while(head != (struct target_list*)NULL)
+		{
+			curr = head-&gt;target;
+		    breakpoint_clear_target_internal(curr);
+			head = head-&gt;next;	
+		}
+     }
+	 else breakpoint_clear_target_internal(target);
+	
+}
+
+
 struct breakpoint* breakpoint_find(struct target *target, uint32_t address)
 {
 	struct breakpoint *breakpoint = target-&gt;breakpoints;
@@ -174,6 +246,7 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 	struct watchpoint *watchpoint = target-&gt;watchpoints;
 	struct watchpoint **watchpoint_p = &amp;target-&gt;watchpoints;
 	int retval;
+	char *reason;
 
 	while (watchpoint)
 	{
@@ -204,11 +277,21 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 	(*watchpoint_p)-&gt;unique_id = bpwp_unique_id++;
 
 	retval = target_add_watchpoint(target, *watchpoint_p);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR(&quot;can't add %s watchpoint at 0x%8.8&quot; PRIx32,
+	switch (retval) {
+	case ERROR_OK:
+		break;
+	case ERROR_TARGET_RESOURCE_NOT_AVAILABLE:
+		reason = &quot;resource not available&quot;;
+		goto bye;
+	case ERROR_TARGET_NOT_HALTED:
+		reason = &quot;target running&quot;;
+		goto bye;
+	default:
+		reason = &quot;unrecognized error&quot;;
+bye:
+		LOG_ERROR(&quot;can't add %s watchpoint at 0x%8.8&quot; PRIx32 &quot;, %s&quot;,
 			 watchpoint_rw_strings[(*watchpoint_p)-&gt;rw],
-			 address);
+			 address, reason);
 		free (*watchpoint_p);
 		*watchpoint_p = NULL;
 		return retval;
diff --git a/src/target/smp.c b/src/target/smp.c
new file mode 100644
index 0000000..aabfa5b
--- /dev/null
+++ b/src/target/smp.c
@@ -0,0 +1,116 @@
+/***************************************************************************
+ *                                                                         *
+ * Copyright (C) ST-Ericsson SA 2011                                       *
+ * Author: Michel Jaouen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A>&gt; for ST-Ericsson.   *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;server/server.h&quot;
+#include &lt;helper/types.h&gt;
+
+#include &quot;target/target.h&quot;
+
+#include &quot;server/gdb_server.h&quot;
+#include &quot;smp.h&quot;
+
+
+/*  implementation of new packet in gdb interface for smp feature          */
+/*                                                                         */
+/*   j : smp  status request                                               */
+/*   J : smp  set request                                                  */
+/*                                                                         */
+/*   jc :read core id displayed by gdb connection                          */
+/*   reply XXXXXXXX core id is int32_t , 8 hex digits                      */
+/*                                                                         */
+/*   Reply ENN error not supported (target not smp)                        */
+/*                                                                         */
+/*   JcXX  set core id displayed at next gdb continue                      */
+/*   maximum 8 bytes described core id int32_t (8 hex digits)              */
+/*  (core id -1 , reserved for returning to normal continue mode) */
+/*  Reply ENN error not supported(target not smp,core id out of range)     */
+/*  Reply OK : for success                                                 */
+/*                                                                         */
+/*  handling of this packet within gdb can be done by the creation         */
+/*  internal variable by mean of function allocate_computed_value          */
+/*  set $_core 1 =&gt; Jc01 packet is sent                                    */
+/*  print $_core =&gt; jc packet is sent and result is affected in $          */
+/*  Another way to test this packet is the usage of maintenance packet     */
+/*  maint packet Jc01                                                      */
+/*  maint packet jc                                                        */
+                                                
+static const char DIGITS[16] = &quot;0123456789abcdef&quot;;
+
+
+/* packet j :smp status request */
+int gdb_read_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size)
+{
+	uint32_t len = sizeof(int32_t);
+	uint8_t *buffer;
+	char *hex_buffer;
+	int retval = ERROR_OK;
+	if (target-&gt;smp)
+	{
+		if (strstr(packet, &quot;jc&quot;))
+		{
+			hex_buffer = malloc(len * 2 + 1);
+			buffer = (uint8_t *)&amp;target-&gt;gdb_service-&gt;core[0];
+			uint32_t i;
+			for (i = 0; i &lt; 4; i++)
+			{
+				uint8_t t = buffer[i];
+				hex_buffer[2 * i] = DIGITS[(t &gt;&gt; 4) &amp; 0xf];
+				hex_buffer[2 * i + 1] = DIGITS[t &amp; 0xf];
+			}
+
+			gdb_put_packet(connection, hex_buffer, len * 2);
+
+			free(hex_buffer);
+		}
+	}
+	else
+		retval = gdb_put_packet(connection,&quot;E01&quot;,3);
+	return retval;
+}
+
+/* J :  smp set request */
+int gdb_write_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size)
+{
+	char *separator;
+	int coreid = 0;
+    int retval = ERROR_OK;
+
+	/* skip command character */
+	if (target-&gt;smp)
+	{
+		if (strstr(packet, &quot;Jc&quot;))
+		{
+			packet+=2;
+			coreid = strtoul(packet, &amp;separator, 16);
+			target-&gt;gdb_service-&gt;core[1] = coreid;
+			gdb_put_packet(connection, &quot;OK&quot;, 2);
+		}
+	}
+	else
+	{
+		retval = gdb_put_packet(connection,&quot;E01&quot;,3);
+	}
+	return ERROR_OK;
+}
diff --git a/src/target/smp.h b/src/target/smp.h
new file mode 100644
index 0000000..f85c9a4
--- /dev/null
+++ b/src/target/smp.h
@@ -0,0 +1,25 @@
+/***************************************************************************
+ *                                                                         *
+ * Copyright (C) ST-Ericsson SA 2011                                       *
+ * Author: Michel Jaouen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A>&gt; for ST-Ericsson.   *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#include &quot;server/server.h&quot;
+int gdb_read_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size);
+int gdb_write_smp_packet(struct connection *connection,
+		struct target *target, char *packet, int packet_size);
+
diff --git a/src/target/target.c b/src/target/target.c
index abe1b43..a2e3ccf 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -17,6 +17,9 @@
  *   Copyright (C) 2011 by Broadcom Corporation                            *
  *   Evan Hunter - <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">ehunter at broadcom.com</A>                                    *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A> : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -729,7 +732,7 @@ int target_bulk_write_memory(struct target *target,
 int target_add_breakpoint(struct target *target,
 		struct breakpoint *breakpoint)
 {
-	if (target-&gt;state != TARGET_HALTED) {
+	if ((target-&gt;state != TARGET_HALTED)&amp;&amp;(breakpoint-&gt;type!=BKPT_HARD)) {
 		LOG_WARNING(&quot;target %s is not halted&quot;, target-&gt;cmd_name);
 		return ERROR_TARGET_NOT_HALTED;
 	}
@@ -3931,6 +3934,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 			/* loop for more e*/
 			break;
 
+
 		case TCFG_ENDIAN:
 			if (goi-&gt;isconfigure) {
 				e = Jim_GetOpt_Nvp(goi, nvp_target_endian, &amp;n);
@@ -3981,7 +3985,7 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 				if (e != JIM_OK) {
 					return e;
 				}
-				target-&gt;coreid = (int)w;
+				target-&gt;coreid = (int32_t)w;
 			} else {
 				if (goi-&gt;argc != 0) {
 					goto no_params;
@@ -4893,6 +4897,61 @@ static int jim_target_names(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	return JIM_OK;
 }
 
+static int jim_target_smp(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	int i;
+	const char *targetname;
+	int retval,len;
+	struct target *target;
+	struct target_list *head, *curr, *new;
+    curr = (struct target_list*) NULL;
+	head = (struct target_list*) NULL;
+	new = (struct target_list*) NULL;
+
+	retval = 0;
+	LOG_DEBUG(&quot;%d&quot;,argc);
+	/* argv[1] = target to associate in smp
+	 * argv[2] = target to assoicate in smp 
+	 * argv[3] ...
+	 */
+
+	for(i=1;i&lt;argc;i++)
+	{
+
+		targetname = Jim_GetString(argv[i], &amp;len);
+		target = get_target(targetname);
+		LOG_DEBUG(&quot;%s &quot;,targetname);
+		if (target)
+		{
+			new=malloc(sizeof(struct target_list));
+			new-&gt;target = target;
+			new-&gt;next = (struct target_list*)NULL;
+			if (head == (struct target_list*)NULL)
+			{
+				head = new;
+				curr = head;
+			}
+			else
+			{
+				curr-&gt;next = new;
+				curr = new;
+			}
+		}
+	}
+    /*  now parse the list of cpu and put the target in smp mode*/
+	curr=head;
+
+    while(curr!=(struct target_list *)NULL)
+	{
+    target=curr-&gt;target;
+	target-&gt;smp = 1;
+	target-&gt;head = head;
+	curr=curr-&gt;next;
+	}
+	return retval; 
+}
+
+
 static int jim_target_create(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	Jim_GetOptInfo goi;
@@ -5008,6 +5067,14 @@ static const struct command_registration target_subcommand_handlers[] = {
 		.help = &quot;Returns the number of targets as an integer &quot;
 			&quot;(DEPRECATED)&quot;,
 	},
+	{
+		.name = &quot;smp&quot;,
+		.mode = COMMAND_ANY,
+		.jim_handler = jim_target_smp,
+		.usage = &quot;targetname1 targetname2 ...&quot;,
+		.help = &quot;gather several target in a smp list&quot;
+	},
+
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/target/target.h b/src/target/target.h
index 5b67bf3..74f74de 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -11,6 +11,9 @@
  *   Copyright (C) 2011 by Broadcom Corporation                            *
  *   Evan Hunter - <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">ehunter at broadcom.com</A>                                    *
  *                                                                         *
+ *   Copyright (C) ST-Ericsson SA 2011                                     *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">michel.jaouen at stericsson.com</A> : smp minimum support                    *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
@@ -38,7 +41,7 @@ struct breakpoint;
 struct watchpoint;
 struct mem_param;
 struct reg_param;
-
+struct target_list;
 
 /*
  * TARGET_UNKNOWN = 0: we don't know anything about the target yet
@@ -102,6 +105,17 @@ struct working_area
 	struct working_area **user;
 	struct working_area *next;
 };
+ 
+struct gdb_service
+{
+	struct target *target;
+	/*  field for smp display  */
+	/*  element 0 coreid currently displayed ( 1 till n) */
+    /*  element 1 coreid to be displayed at next resume 1 till n 0 means resume
+	 *  all cores
+	  core displayed  */
+	int32_t core[2];
+};
 
 // target_type.h contains the full definitionof struct targe_type
 struct target
@@ -110,7 +124,7 @@ struct target
 	const char *cmd_name;				/* tcl Name of target */
 	int target_number;					/* DO NOT USE!  field to be removed in 2010 */
 	struct jtag_tap *tap;					/* where on the jtag chain is this */
-	int coreid;							/* which device on the TAP? */
+	int32_t coreid;							/* which device on the TAP? */
 	const char *variant;				/* what variant of this chip is it? */
 
 	/**
@@ -166,6 +180,20 @@ struct target
 	struct rtos *rtos;					/* Instance of Real Time Operating System support */
 	bool rtos_auto_detect;				/* A flag that indicates that the RTOS has been specified as &quot;auto&quot; 
 	                                     * and must be detected when symbols are offered */
+
+	int smp;								/*  add some target attributes for smp support */
+	struct target_list *head;
+	/*  the gdb service is there in case of smp , we have only one gdb server
+	 *  for all smp target
+	 *  the target attached to the gdb is changing dynamically by changing
+	 *  gdb_service-&gt;target pointer */
+	struct gdb_service *gdb_service;
+};
+
+
+struct target_list {
+	struct target *target;
+	struct target_list *next;
 };
 
 /** Returns the instance-specific name of the specified target. */

-----------------------------------------------------------------------

Summary of changes:
 src/server/gdb_server.c                     |   53 ++++-
 src/server/gdb_server.h                     |    6 +-
 src/target/Makefile.am                      |    3 +-
 src/target/breakpoints.c                    |  103 ++++++++-
 src/target/cortex_a.c                       |  245 +++++++++++++++++++--
 src/target/smp.c                            |  116 ++++++++++
 src/{helper/ioutil_stubs.c =&gt; target/smp.h} |   19 +-
 src/target/target.c                         |   71 ++++++-
 src/target/target.h                         |   32 +++-
 tcl/target/u8500.cfg                        |  326 +++++++++++++++++++++++++++
 10 files changed, 923 insertions(+), 51 deletions(-)
 create mode 100644 src/target/smp.c
 copy src/{helper/ioutil_stubs.c =&gt; target/smp.h} (77%)
 create mode 100644 tcl/target/u8500.cfg


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002585.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-862-g36d60ee
</A></li>
	<LI>Next message: <A HREF="002587.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-867-g5c739b1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2586">[ date ]</a>
              <a href="thread.html#2586">[ thread ]</a>
              <a href="subject.html#2586">[ subject ]</a>
              <a href="author.html#2586">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
