<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2279 - trunk/src/target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2279%20-%20trunk/src/target&In-Reply-To=%3C200906180710.n5I7ALVe016239%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001062.html">
   <LINK REL="Next"  HREF="001064.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2279 - trunk/src/target</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2279%20-%20trunk/src/target&In-Reply-To=%3C200906180710.n5I7ALVe016239%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2279 - trunk/src/target">zwelch at mail.berlios.de
       </A><BR>
    <I>Thu Jun 18 09:10:21 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001062.html">[Openocd-svn] r2278 - trunk/src/target
</A></li>
        <LI>Next message: <A HREF="001064.html">[Openocd-svn] r2280 - trunk/src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1063">[ date ]</a>
              <a href="thread.html#1063">[ thread ]</a>
              <a href="subject.html#1063">[ subject ]</a>
              <a href="author.html#1063">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-18 09:09:35 +0200 (Thu, 18 Jun 2009)
New Revision: 2279

Modified:
   trunk/src/target/algorithm.c
   trunk/src/target/algorithm.h
   trunk/src/target/avrt.c
   trunk/src/target/breakpoints.c
   trunk/src/target/breakpoints.h
   trunk/src/target/cortex_a8.c
   trunk/src/target/cortex_a8.h
   trunk/src/target/cortex_m3.c
   trunk/src/target/cortex_m3.h
   trunk/src/target/embeddedice.c
   trunk/src/target/embeddedice.h
   trunk/src/target/etb.c
   trunk/src/target/etb.h
   trunk/src/target/etm.c
   trunk/src/target/etm.h
   trunk/src/target/feroceon.c
   trunk/src/target/image.c
   trunk/src/target/image.h
   trunk/src/target/mips32.c
   trunk/src/target/mips32.h
   trunk/src/target/mips32_dmaacc.c
   trunk/src/target/mips32_dmaacc.h
   trunk/src/target/mips32_pracc.c
   trunk/src/target/mips32_pracc.h
   trunk/src/target/mips_ejtag.c
   trunk/src/target/mips_ejtag.h
   trunk/src/target/mips_m4k.c
   trunk/src/target/mips_m4k.h
   trunk/src/target/oocd_trace.c
   trunk/src/target/register.h
   trunk/src/target/target.c
   trunk/src/target/target.h
   trunk/src/target/target_request.c
   trunk/src/target/target_request.h
   trunk/src/target/target_type.h
   trunk/src/target/trace.c
   trunk/src/target/trace.h
   trunk/src/target/xscale.c
   trunk/src/target/xscale.h
Log:
Transform 'u32' to 'uint32_t' in src/target
- Replace '\([^_]\)u32' with '\1uint32_t'.
- Replace '^u32' with 'uint32_t'.


Modified: trunk/src/target/algorithm.c
===================================================================
--- trunk/src/target/algorithm.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/algorithm.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -25,7 +25,7 @@
 #include &quot;binarybuffer.h&quot;
 
 
-void init_mem_param(mem_param_t *param, u32 address, u32 size, enum param_direction direction)
+void init_mem_param(mem_param_t *param, uint32_t address, uint32_t size, enum param_direction direction)
 {
 	param-&gt;address = address;
 	param-&gt;size = size;
@@ -39,7 +39,7 @@
 	param-&gt;value = NULL;
 }
 
-void init_reg_param(reg_param_t *param, char *reg_name, u32 size, enum param_direction direction)
+void init_reg_param(reg_param_t *param, char *reg_name, uint32_t size, enum param_direction direction)
 {
 	param-&gt;reg_name = reg_name;
 	param-&gt;size = size;

Modified: trunk/src/target/algorithm.h
===================================================================
--- trunk/src/target/algorithm.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/algorithm.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -31,8 +31,8 @@
 
 typedef struct mem_param_s
 {
-	u32 address;
-	u32 size;
+	uint32_t address;
+	uint32_t size;
 	uint8_t *value;
 	enum param_direction direction;
 } mem_param_t; 
@@ -40,14 +40,14 @@
 typedef struct reg_param_s
 {
 	char *reg_name;
-	u32 size;
+	uint32_t size;
 	uint8_t *value;
 	enum param_direction direction;
 } reg_param_t;
 
-extern void init_mem_param(mem_param_t *param, u32 address, u32 size, enum param_direction direction);
+extern void init_mem_param(mem_param_t *param, uint32_t address, uint32_t size, enum param_direction direction);
 extern void destroy_mem_param(mem_param_t *param);
-extern void init_reg_param(reg_param_t *param, char *reg_name, u32 size, enum param_direction direction);
+extern void init_reg_param(reg_param_t *param, char *reg_name, uint32_t size, enum param_direction direction);
 extern void destroy_reg_param(reg_param_t *param);
 
 #endif /* ALGORITHM_H */

Modified: trunk/src/target/avrt.c
===================================================================
--- trunk/src/target/avrt.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/avrt.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -39,8 +39,8 @@
 int avr_arch_state(struct target_s *target);
 int avr_poll(target_t *target);
 int avr_halt(target_t *target);
-int avr_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
-int avr_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
+int avr_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+int avr_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints);
 
 int avr_assert_reset(target_t *target);
 int avr_deassert_reset(target_t *target);
@@ -48,7 +48,7 @@
 
 /* IR and DR functions */
 int avr_jtag_sendinstr(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out);
-int avr_jtag_senddat(jtag_tap_t *tap, u32 *dr_in, u32 dr_out, int len);
+int avr_jtag_senddat(jtag_tap_t *tap, uint32_t *dr_in, uint32_t dr_out, int len);
 
 int mcu_write_ir(jtag_tap_t *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
 int mcu_write_dr(jtag_tap_t *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti);
@@ -56,8 +56,8 @@
 int mcu_write_dr_u8(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out, int dr_len, int rti);
 int mcu_write_ir_u16(jtag_tap_t *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti);
 int mcu_write_dr_u16(jtag_tap_t *tap, uint16_t *ir_in, uint16_t ir_out, int dr_len, int rti);
-int mcu_write_ir_u32(jtag_tap_t *tap, u32 *ir_in, u32 ir_out, int ir_len, int rti);
-int mcu_write_dr_u32(jtag_tap_t *tap, u32 *ir_in, u32 ir_out, int dr_len, int rti);
+int mcu_write_ir_u32(jtag_tap_t *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti);
+int mcu_write_dr_u32(jtag_tap_t *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
 int mcu_execute_queue(void);
 
 target_type_t avr_target =
@@ -153,13 +153,13 @@
 	return ERROR_OK;
 }
 
-int avr_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
+int avr_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
 	return ERROR_OK;
 }
 
-int avr_step(struct target_s *target, int current, u32 address, int handle_breakpoints)
+int avr_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	LOG_DEBUG(&quot;%s&quot;, __FUNCTION__);
 	return ERROR_OK;
@@ -187,7 +187,7 @@
 	return ERROR_OK;
 }
 
-int avr_jtag_senddat(jtag_tap_t *tap, u32* dr_in, u32 dr_out, int len)
+int avr_jtag_senddat(jtag_tap_t *tap, uint32_t* dr_in, uint32_t dr_out, int len)
 {
 	return mcu_write_dr_u32(tap, dr_in, dr_out, len, 1);
 }
@@ -297,7 +297,7 @@
 	return ERROR_OK;
 }
 
-int mcu_write_ir_u32(jtag_tap_t *tap, u32 *ir_in, u32 ir_out, int ir_len, int rti)
+int mcu_write_ir_u32(jtag_tap_t *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti)
 {
 	if (ir_len &gt; 32)
 	{
@@ -310,7 +310,7 @@
 	return ERROR_OK;
 }
 
-int mcu_write_dr_u32(jtag_tap_t *tap, u32 *dr_in, u32 dr_out, int dr_len, int rti)
+int mcu_write_dr_u32(jtag_tap_t *tap, uint32_t *dr_in, uint32_t dr_out, int dr_len, int rti)
 {
 	if (dr_len &gt; 32)
 	{

Modified: trunk/src/target/breakpoints.c
===================================================================
--- trunk/src/target/breakpoints.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/breakpoints.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -39,7 +39,7 @@
 	&quot;access&quot;
 };
 
-int breakpoint_add(target_t *target, u32 address, u32 length, enum breakpoint_type type)
+int breakpoint_add(target_t *target, uint32_t address, uint32_t length, enum breakpoint_type type)
 {
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 	breakpoint_t **breakpoint_p = &amp;target-&gt;breakpoints;
@@ -115,7 +115,7 @@
 	free(breakpoint);
 }
 
-void breakpoint_remove(target_t *target, u32 address)
+void breakpoint_remove(target_t *target, uint32_t address)
 {
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 	breakpoint_t **breakpoint_p = &amp;target-&gt;breakpoints;
@@ -147,7 +147,7 @@
 	}
 }
 
-breakpoint_t* breakpoint_find(target_t *target, u32 address)
+breakpoint_t* breakpoint_find(target_t *target, uint32_t address)
 {
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 	
@@ -161,7 +161,7 @@
 	return NULL;
 }
 
-int watchpoint_add(target_t *target, u32 address, u32 length, enum watchpoint_rw rw, u32 value, u32 mask)
+int watchpoint_add(target_t *target, uint32_t address, uint32_t length, enum watchpoint_rw rw, uint32_t value, uint32_t mask)
 {
 	watchpoint_t *watchpoint = target-&gt;watchpoints;
 	watchpoint_t **watchpoint_p = &amp;target-&gt;watchpoints;
@@ -234,7 +234,7 @@
 	free(watchpoint);
 }
 
-void watchpoint_remove(target_t *target, u32 address)
+void watchpoint_remove(target_t *target, uint32_t address)
 {
 	watchpoint_t *watchpoint = target-&gt;watchpoints;
 	watchpoint_t **watchpoint_p = &amp;target-&gt;watchpoints;

Modified: trunk/src/target/breakpoints.h
===================================================================
--- trunk/src/target/breakpoints.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/breakpoints.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -37,7 +37,7 @@
 
 typedef struct breakpoint_s
 {
-	u32 address;
+	uint32_t address;
 	int length;
 	enum breakpoint_type type;
 	int set;
@@ -47,21 +47,21 @@
 
 typedef struct watchpoint_s
 {
-	u32 address;
+	uint32_t address;
 	int length;
-	u32 mask;
-	u32 value;
+	uint32_t mask;
+	uint32_t value;
 	enum watchpoint_rw rw;
 	int set;
 	struct watchpoint_s *next;
 } watchpoint_t;
 
 extern void breakpoint_clear_target(struct target_s *target);
-extern int breakpoint_add(struct target_s *target, u32 address, u32 length, enum breakpoint_type type);
-extern void breakpoint_remove(struct target_s *target, u32 address);
-extern breakpoint_t* breakpoint_find(struct target_s *target, u32 address);
-extern int watchpoint_add(struct target_s *target, u32 address, u32 length, enum watchpoint_rw rw, u32 value, u32 mask);
-extern void watchpoint_remove(struct target_s *target, u32 address);
+extern int breakpoint_add(struct target_s *target, uint32_t address, uint32_t length, enum breakpoint_type type);
+extern void breakpoint_remove(struct target_s *target, uint32_t address);
+extern breakpoint_t* breakpoint_find(struct target_s *target, uint32_t address);
+extern int watchpoint_add(struct target_s *target, uint32_t address, uint32_t length, enum watchpoint_rw rw, uint32_t value, uint32_t mask);
+extern void watchpoint_remove(struct target_s *target, uint32_t address);
 extern void watchpoint_clear_target(struct target_s *target);
 
 #endif /* BREAKPOINTS_H */

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/cortex_a8.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -104,7 +104,7 @@
 	return ERROR_OK;
 }
 
-int cortex_a8_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int cortex_a8_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -136,7 +136,7 @@
 	return retval;
 }
 
-int cortex_a8_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int cortex_a8_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -187,7 +187,7 @@
 		/* check if we have data */
 		if (ctrl &amp; (1 &lt;&lt; 0))
 		{
-			u32 request;
+			uint32_t request;
 
 			/* we assume target is quick enough */
 			request = data;

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/cortex_a8.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -48,17 +48,17 @@
 {
 	int used;
 	int type;
-	u32 fpcr_value;
-	u32 fpcr_address;
+	uint32_t fpcr_value;
+	uint32_t fpcr_address;
 } cortex_a8_fp_comparator_t;
 
 typedef struct  cortex_a8_dwt_comparator_s
 {
 	int used;
-	u32 comp;
-	u32 mask;
-	u32 function;
-	u32 dwt_comparator_address;
+	uint32_t comp;
+	uint32_t mask;
+	uint32_t function;
+	uint32_t dwt_comparator_address;
 } cortex_a8_dwt_comparator_t;
 
 typedef struct cortex_a8_common_s
@@ -67,9 +67,9 @@
 	arm_jtag_t jtag_info;
 
 	/* Context information */
-	u32 dcb_dhcsr;
-	u32 nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */
-	u32 nvic_icsr;  /* Interrupt Control State Register - shows active and pending IRQ */
+	uint32_t dcb_dhcsr;
+	uint32_t nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */
+	uint32_t nvic_icsr;  /* Interrupt Control State Register - shows active and pending IRQ */
 
 	/* Flash Patch and Breakpoint (FPB) */
 	int fp_num_lit;
@@ -86,14 +86,14 @@
 
 	/* Interrupts */
 	int intlinesnum;
-	u32 *intsetenable;
+	uint32_t *intsetenable;
 
 	armv7m_common_t armv7m;
 	void *arch_info;
 } cortex_a8_common_t;
 
 extern int cortex_a8_init_arch_info(target_t *target, cortex_a8_common_t *cortex_a8, jtag_tap_t *tap);
-int cortex_a8_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int cortex_a8_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int cortex_a8_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int cortex_a8_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 #endif /* CORTEX_A8_H */

Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/cortex_m3.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -46,9 +46,9 @@
 int cortex_m3_target_create(struct target_s *target, Jim_Interp *interp);
 int cortex_m3_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int cortex_m3_quit(void);
-int cortex_m3_load_core_reg_u32(target_t *target, enum armv7m_regtype type, u32 num, u32 *value);
-int cortex_m3_store_core_reg_u32(target_t *target, enum armv7m_regtype type, u32 num, u32 value);
-int cortex_m3_target_request_data(target_t *target, u32 size, uint8_t *buffer);
+int cortex_m3_load_core_reg_u32(target_t *target, enum armv7m_regtype type, uint32_t num, uint32_t *value);
+int cortex_m3_store_core_reg_u32(target_t *target, enum armv7m_regtype type, uint32_t num, uint32_t value);
+int cortex_m3_target_request_data(target_t *target, uint32_t size, uint8_t *buffer);
 int cortex_m3_examine(struct target_s *target);
 
 #ifdef ARMV7_GDB_HACKS
@@ -95,10 +95,10 @@
 	.quit = cortex_m3_quit
 };
 
-int cortexm3_dap_read_coreregister_u32(swjdp_common_t *swjdp, u32 *value, int regnum)
+int cortexm3_dap_read_coreregister_u32(swjdp_common_t *swjdp, uint32_t *value, int regnum)
 {
 	int retval;
-	u32 dcrdr;
+	uint32_t dcrdr;
 
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we gave to save/restore the DCB_DCRDR when used */
@@ -120,10 +120,10 @@
 	return retval;
 }
 
-int cortexm3_dap_write_coreregister_u32(swjdp_common_t *swjdp, u32 value, int regnum)
+int cortexm3_dap_write_coreregister_u32(swjdp_common_t *swjdp, uint32_t value, int regnum)
 {
 	int retval;
-	u32 dcrdr;
+	uint32_t dcrdr;
 
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we gave to save/restore the DCB_DCRDR when used */
@@ -146,7 +146,7 @@
 }
 
 
-int cortex_m3_write_debug_halt_mask(target_t *target, u32 mask_on, u32 mask_off)
+int cortex_m3_write_debug_halt_mask(target_t *target, uint32_t mask_on, uint32_t mask_off)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -186,7 +186,7 @@
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	cortex_m3_common_t *cortex_m3 = armv7m-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u32 dhcsr_save;
+	uint32_t dhcsr_save;
 
 	/* backup dhcsr reg */
 	dhcsr_save = cortex_m3-&gt;dcb_dhcsr;
@@ -204,12 +204,12 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_exec_opcode(target_t *target,u32 opcode, int len /* MODE, r0_invalue, &amp;r0_outvalue */ )
+int cortex_m3_exec_opcode(target_t *target,uint32_t opcode, int len /* MODE, r0_invalue, &amp;r0_outvalue */ )
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u32 savedram;
+	uint32_t savedram;
 	int retvalue;
 
 	mem_ap_read_u32(swjdp, 0x20000000, &amp;savedram);
@@ -224,13 +224,13 @@
 
 #if 0
 /* Enable interrupts */
-int cortex_m3_cpsie(target_t *target, u32 IF)
+int cortex_m3_cpsie(target_t *target, uint32_t IF)
 {
 	return cortex_m3_exec_opcode(target, ARMV7M_T_CPSIE(IF), 2);
 }
 
 /* Disable interrupts */
-int cortex_m3_cpsid(target_t *target, u32 IF)
+int cortex_m3_cpsid(target_t *target, uint32_t IF)
 {
 	return cortex_m3_exec_opcode(target, ARMV7M_T_CPSID(IF), 2);
 }
@@ -239,7 +239,7 @@
 int cortex_m3_endreset_event(target_t *target)
 {
 	int i;
-	u32 dcb_demcr;
+	uint32_t dcb_demcr;
 
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -323,7 +323,7 @@
 
 int cortex_m3_examine_exception_reason(target_t *target)
 {
-	u32 shcsr, except_sr, cfsr = -1, except_ar = -1;
+	uint32_t shcsr, except_sr, cfsr = -1, except_ar = -1;
 
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -374,7 +374,7 @@
 int cortex_m3_debug_entry(target_t *target)
 {
 	int i;
-	u32 xPSR;
+	uint32_t xPSR;
 	int retval;
 
 	/* get pointers to arch-specific information */
@@ -443,7 +443,7 @@
 
 	LOG_DEBUG(&quot;entered debug state in core mode: %s at PC 0x%x, target-&gt;state: %s&quot;,
 		armv7m_mode_strings[armv7m-&gt;core_mode],
-		*(u32*)(armv7m-&gt;core_cache-&gt;reg_list[15].value),
+		*(uint32_t*)(armv7m-&gt;core_cache-&gt;reg_list[15].value),
 		Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name);
 
 	if (armv7m-&gt;post_debug_entry)
@@ -574,7 +574,7 @@
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	cortex_m3_common_t *cortex_m3 = armv7m-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u32 dcb_dhcsr = 0;
+	uint32_t dcb_dhcsr = 0;
 	int retval, timeout = 0;
 
 	/* Enter debug state on reset, cf. end_reset_event() */
@@ -609,12 +609,12 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
+int cortex_m3_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	breakpoint_t *breakpoint = NULL;
-	u32 resume_pc;
+	uint32_t resume_pc;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -695,7 +695,7 @@
 }
 
 /* int irqstepcount=0; */
-int cortex_m3_step(struct target_s *target, int current, u32 address, int handle_breakpoints)
+int cortex_m3_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -797,7 +797,7 @@
 		/* get revision of lm3s target, only early silicon has this issue
 		 * Fury Rev B, DustDevil Rev B, Tempest all ok */
 
-		u32 did0;
+		uint32_t did0;
 
 		if (target_read_u32(target, 0x400fe000, &amp;did0) == ERROR_OK)
 		{
@@ -839,7 +839,7 @@
 		{
 			/* I do not know why this is necessary, but it fixes strange effects
 			 * (step/resume cause a NMI after reset) on LM3S6918 -- Michael Schwingen */
-			u32 tmp;
+			uint32_t tmp;
 			mem_ap_read_atomic_u32(swjdp, NVIC_AIRCR, &amp;tmp);
 		}
 	}
@@ -887,7 +887,7 @@
 {
 	int retval;
 	int fp_num=0;
-	u32 hilo;
+	uint32_t hilo;
 
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -1076,7 +1076,7 @@
 int cortex_m3_set_watchpoint(struct target_s *target, watchpoint_t *watchpoint)
 {
 	int dwt_num=0;
-	u32 mask, temp;
+	uint32_t mask, temp;
 
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -1218,7 +1218,7 @@
 	}
 }
 
-int cortex_m3_load_core_reg_u32(struct target_s *target, enum armv7m_regtype type, u32 num, u32 * value)
+int cortex_m3_load_core_reg_u32(struct target_s *target, enum armv7m_regtype type, uint32_t num, uint32_t * value)
 {
 	int retval;
 	/* get pointers to arch-specific information */
@@ -1271,10 +1271,10 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_store_core_reg_u32(struct target_s *target, enum armv7m_regtype type, u32 num, u32 value)
+int cortex_m3_store_core_reg_u32(struct target_s *target, enum armv7m_regtype type, uint32_t num, uint32_t value)
 {
 	int retval;
-	u32 reg;
+	uint32_t reg;
 
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -1339,7 +1339,7 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int cortex_m3_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -1371,7 +1371,7 @@
 	return retval;
 }
 
-int cortex_m3_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int cortex_m3_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -1401,7 +1401,7 @@
 	return retval;
 }
 
-int cortex_m3_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
+int cortex_m3_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	return cortex_m3_write_memory(target, address, 4, count, buffer);
 }
@@ -1420,7 +1420,7 @@
 int cortex_m3_examine(struct target_s *target)
 {
 	int retval;
-	u32 cpuid, fpcr, dwtcr, ictr;
+	uint32_t cpuid, fpcr, dwtcr, ictr;
 	int i;
 
 	/* get pointers to arch-specific information */
@@ -1508,13 +1508,13 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_target_request_data(target_t *target, u32 size, uint8_t *buffer)
+int cortex_m3_target_request_data(target_t *target, uint32_t size, uint8_t *buffer)
 {
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
 	uint8_t data;
 	uint8_t ctrl;
-	u32 i;
+	uint32_t i;
 
 	for (i = 0; i &lt; (size * 4); i++)
 	{
@@ -1546,7 +1546,7 @@
 		/* check if we have data */
 		if (ctrl &amp; (1 &lt;&lt; 0))
 		{
-			u32 request;
+			uint32_t request;
 
 			/* we assume target is quick enough */
 			request = data;

Modified: trunk/src/target/cortex_m3.h
===================================================================
--- trunk/src/target/cortex_m3.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/cortex_m3.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -121,17 +121,17 @@
 {
 	int used;
 	int type;
-	u32 fpcr_value;
-	u32 fpcr_address;
+	uint32_t fpcr_value;
+	uint32_t fpcr_address;
 } cortex_m3_fp_comparator_t;
 
 typedef struct  cortex_m3_dwt_comparator_s
 {
 	int used;
-	u32 comp;
-	u32 mask;
-	u32 function;
-	u32 dwt_comparator_address;
+	uint32_t comp;
+	uint32_t mask;
+	uint32_t function;
+	uint32_t dwt_comparator_address;
 } cortex_m3_dwt_comparator_t;
 
 typedef struct cortex_m3_common_s
@@ -140,9 +140,9 @@
 	arm_jtag_t jtag_info;
 	
 	/* Context information */
-	u32 dcb_dhcsr;
-	u32 nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */
-	u32 nvic_icsr;  /* Interrupt Control State Register - shows active and pending IRQ */
+	uint32_t dcb_dhcsr;
+	uint32_t nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */
+	uint32_t nvic_icsr;  /* Interrupt Control State Register - shows active and pending IRQ */
 	
 	/* Flash Patch and Breakpoint (FPB) */
 	int fp_num_lit;
@@ -159,7 +159,7 @@
 	
 	/* Interrupts */
 	int intlinesnum;
-	u32 *intsetenable;
+	uint32_t *intsetenable;
 	
 	armv7m_common_t armv7m;
 //	swjdp_common_t swjdp_info;
@@ -170,16 +170,16 @@
 
 int cortex_m3_poll(target_t *target);
 int cortex_m3_halt(target_t *target);
-int cortex_m3_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
-int cortex_m3_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
+int cortex_m3_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+int cortex_m3_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints);
 
 int cortex_m3_assert_reset(target_t *target);
 int cortex_m3_deassert_reset(target_t *target);
 int cortex_m3_soft_reset_halt(struct target_s *target);
 
-int cortex_m3_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int cortex_m3_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int cortex_m3_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
+int cortex_m3_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int cortex_m3_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int cortex_m3_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer);
 
 int cortex_m3_set_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
 int cortex_m3_unset_breakpoint(struct target_s *target, breakpoint_t *breakpoint);

Modified: trunk/src/target/embeddedice.c
===================================================================
--- trunk/src/target/embeddedice.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/embeddedice.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -287,7 +287,7 @@
  * we pretend the target is always going to be fast enough
  * (relative to the JTAG clock), so we don't need to handshake
  */
-int embeddedice_receive(arm_jtag_t *jtag_info, u32 *data, u32 size)
+int embeddedice_receive(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size)
 {
 	scan_field_t fields[3];
 	uint8_t field1_out[1];
@@ -340,7 +340,7 @@
 	return embeddedice_read_reg_w_check(reg, NULL, NULL);
 }
 
-void embeddedice_set_reg(reg_t *reg, u32 value)
+void embeddedice_set_reg(reg_t *reg, uint32_t value)
 {
 	embeddedice_write_reg(reg, value);
 
@@ -363,7 +363,7 @@
 	return ERROR_OK;
 }
 
-void embeddedice_write_reg(reg_t *reg, u32 value)
+void embeddedice_write_reg(reg_t *reg, uint32_t value)
 {
 	embeddedice_reg_t *ice_reg = reg-&gt;arch_info;
 
@@ -388,7 +388,7 @@
  * we pretend the target is always going to be fast enough
  * (relative to the JTAG clock), so we don't need to handshake
  */
-int embeddedice_send(arm_jtag_t *jtag_info, u32 *data, u32 size)
+int embeddedice_send(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size)
 {
 	scan_field_t fields[3];
 	uint8_t field0_out[4];
@@ -432,14 +432,14 @@
 
 /* wait for DCC control register R/W handshake bit to become active
  */
-int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, u32 timeout)
+int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, uint32_t timeout)
 {
 	scan_field_t fields[3];
 	uint8_t field0_in[4];
 	uint8_t field1_out[1];
 	uint8_t field2_out[1];
 	int retval;
-	u32 hsact;
+	uint32_t hsact;
 	struct timeval lap;
 	struct timeval now;
 
@@ -484,7 +484,7 @@
 
 		gettimeofday(&amp;now, NULL);
 	}
-	while ((u32)((now.tv_sec-lap.tv_sec)*1000 + (now.tv_usec-lap.tv_usec)/1000) &lt;= timeout);
+	while ((uint32_t)((now.tv_sec-lap.tv_sec)*1000 + (now.tv_usec-lap.tv_usec)/1000) &lt;= timeout);
 
 	return ERROR_TARGET_TIMEOUT;
 }

Modified: trunk/src/target/embeddedice.h
===================================================================
--- trunk/src/target/embeddedice.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/embeddedice.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -96,22 +96,22 @@
 extern reg_cache_t* embeddedice_build_reg_cache(target_t *target, arm7_9_common_t *arm7_9);
 extern int embeddedice_setup(target_t *target);
 extern int embeddedice_read_reg(reg_t *reg);
-extern void embeddedice_write_reg(reg_t *reg, u32 value);
+extern void embeddedice_write_reg(reg_t *reg, uint32_t value);
 extern int embeddedice_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
 extern void embeddedice_store_reg(reg_t *reg);
-extern void embeddedice_set_reg(reg_t *reg, u32 value);
+extern void embeddedice_set_reg(reg_t *reg, uint32_t value);
 extern int embeddedice_set_reg_w_exec(reg_t *reg, uint8_t *buf);
-extern int embeddedice_receive(arm_jtag_t *jtag_info, u32 *data, u32 size);
-extern int embeddedice_send(arm_jtag_t *jtag_info, u32 *data, u32 size);
-extern int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, u32 timeout);
+extern int embeddedice_receive(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size);
+extern int embeddedice_send(arm_jtag_t *jtag_info, uint32_t *data, uint32_t size);
+extern int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, uint32_t timeout);
 
 /* If many embeddedice_write_reg() follow eachother, then the &gt;1 invocations can be this faster version of
  * embeddedice_write_reg
  */
-static __inline__ void embeddedice_write_reg_inner( jtag_tap_t *tap, int reg_addr, u32 value)
+static __inline__ void embeddedice_write_reg_inner( jtag_tap_t *tap, int reg_addr, uint32_t value)
 {
 	static const int embeddedice_num_bits[]={32,5,1};
-	u32 values[3];
+	uint32_t values[3];
 
 	values[0]=value;
 	values[1]=reg_addr;

Modified: trunk/src/target/etb.c
===================================================================
--- trunk/src/target/etb.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/etb.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -44,7 +44,7 @@
 
 static int handle_etb_config_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-static int etb_set_instr(etb_t *etb, u32 new_instr)
+static int etb_set_instr(etb_t *etb, uint32_t new_instr)
 {
 	jtag_tap_t *tap;
 
@@ -71,7 +71,7 @@
 	return ERROR_OK;
 }
 
-static int etb_scann(etb_t *etb, u32 new_scan_chain)
+static int etb_scann(etb_t *etb, uint32_t new_scan_chain)
 {
 	if (etb-&gt;cur_scan_chain != new_scan_chain)
 	{
@@ -160,11 +160,11 @@
 
 static void etb_getbuf(uint8_t *in)
 {
-	*((u32 *)in)=buf_get_u32(in, 0, 32);
+	*((uint32_t *)in)=buf_get_u32(in, 0, 32);
 }
 
 
-static int etb_read_ram(etb_t *etb, u32 *data, int num_frames)
+static int etb_read_ram(etb_t *etb, uint32_t *data, int num_frames)
 {
 	scan_field_t fields[3];
 	int i;
@@ -275,7 +275,7 @@
 	return etb_read_reg_w_check(reg, NULL, NULL);
 }
 
-int etb_set_reg(reg_t *reg, u32 value)
+int etb_set_reg(reg_t *reg, uint32_t value)
 {
 	int retval;
 
@@ -306,7 +306,7 @@
 	return ERROR_OK;
 }
 
-int etb_write_reg(reg_t *reg, u32 value)
+int etb_write_reg(reg_t *reg, uint32_t value)
 {
 	etb_reg_t *etb_reg = reg-&gt;arch_info;
 	uint8_t reg_addr = etb_reg-&gt;addr &amp; 0x7f;
@@ -491,7 +491,7 @@
 	etb_t *etb = etm_ctx-&gt;capture_driver_priv;
 	int first_frame = 0;
 	int num_frames = etb-&gt;ram_depth;
-	u32 *trace_data = NULL;
+	uint32_t *trace_data = NULL;
 	int i, j;
 
 	etb_read_reg(&amp;etb-&gt;reg_cache-&gt;reg_list[ETB_STATUS]);
@@ -514,7 +514,7 @@
 	etb_write_reg(&amp;etb-&gt;reg_cache-&gt;reg_list[ETB_RAM_READ_POINTER], first_frame);
 
 	/* read data into temporary array for unpacking */
-	trace_data = malloc(sizeof(u32) * num_frames);
+	trace_data = malloc(sizeof(uint32_t) * num_frames);
 	etb_read_ram(etb, trace_data, num_frames);
 
 	if (etm_ctx-&gt;trace_depth &gt; 0)
@@ -639,8 +639,8 @@
 static int etb_start_capture(etm_context_t *etm_ctx)
 {
 	etb_t *etb = etm_ctx-&gt;capture_driver_priv;
-	u32 etb_ctrl_value = 0x1;
-	u32 trigger_count;
+	uint32_t etb_ctrl_value = 0x1;
+	uint32_t trigger_count;
 
 	if ((etm_ctx-&gt;portmode &amp; ETM_PORT_MODE_MASK) == ETM_PORT_DEMUXED)
 	{

Modified: trunk/src/target/etb.h
===================================================================
--- trunk/src/target/etb.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/etb.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -40,17 +40,17 @@
 {
 	etm_context_t *etm_ctx;
 	jtag_tap_t *tap;
-	u32 cur_scan_chain;
+	uint32_t cur_scan_chain;
 	reg_cache_t *reg_cache;
 
 	/* ETB parameters */
-	u32 ram_depth;
-	u32 ram_width;
+	uint32_t ram_depth;
+	uint32_t ram_width;
 } etb_t;
 
 typedef struct etb_reg_s
 {
-	u32 addr;
+	uint32_t addr;
 	etb_t *etb;
 } etb_reg_t;
 
@@ -58,10 +58,10 @@
 
 extern reg_cache_t* etb_build_reg_cache(etb_t *etb);
 extern int etb_read_reg(reg_t *reg);
-extern int etb_write_reg(reg_t *reg, u32 value);
+extern int etb_write_reg(reg_t *reg, uint32_t value);
 extern int etb_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
 extern int etb_store_reg(reg_t *reg);
-extern int etb_set_reg(reg_t *reg, u32 value);
+extern int etb_set_reg(reg_t *reg, uint32_t value);
 extern int etb_set_reg_w_exec(reg_t *reg, uint8_t *buf);
 
 #endif /* ETB_H */

Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/etm.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -261,7 +261,7 @@
 int etm_setup(target_t *target)
 {
 	int retval;
-	u32 etm_ctrl_value;
+	uint32_t etm_ctrl_value;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	etm_context_t *etm_ctx = arm7_9-&gt;etm_ctx;
@@ -366,7 +366,7 @@
 	return etm_read_reg_w_check(reg, NULL, NULL);
 }
 
-int etm_set_reg(reg_t *reg, u32 value)
+int etm_set_reg(reg_t *reg, uint32_t value)
 {
 	int retval;
 
@@ -397,7 +397,7 @@
 	return ERROR_OK;
 }
 
-int etm_write_reg(reg_t *reg, u32 value)
+int etm_write_reg(reg_t *reg, uint32_t value)
 {
 	etm_reg_t *etm_reg = reg-&gt;arch_info;
 	uint8_t reg_addr = etm_reg-&gt;addr &amp; 0x7f;
@@ -474,8 +474,8 @@
 {
 	int i;
 	int section = -1;
-	u32 size_read;
-	u32 opcode;
+	uint32_t size_read;
+	uint32_t opcode;
 	int retval;
 
 	if (!ctx-&gt;image)
@@ -609,7 +609,7 @@
 	uint8_t packet;
 	int shift = 0;
 	int apo;
-	u32 i;
+	uint32_t i;
 
 	/* quit analysis if less than two cycles are left in the trace
 	 * because we can't extract the APO */
@@ -689,7 +689,7 @@
 	return 0;
 }
 
-static int etmv1_data(etm_context_t *ctx, int size, u32 *data)
+static int etmv1_data(etm_context_t *ctx, int size, uint32_t *data)
 {
 	int j;
 	uint8_t buf[4];
@@ -739,12 +739,12 @@
 	while (ctx-&gt;pipe_index &lt; ctx-&gt;trace_depth)
 	{
 		uint8_t pipestat = ctx-&gt;trace_data[ctx-&gt;pipe_index].pipestat;
-		u32 next_pc = ctx-&gt;current_pc;
-		u32 old_data_index = ctx-&gt;data_index;
-		u32 old_data_half = ctx-&gt;data_half;
-		u32 old_index = ctx-&gt;pipe_index;
-		u32 last_instruction = ctx-&gt;last_instruction;
-		u32 cycles = 0;
+		uint32_t next_pc = ctx-&gt;current_pc;
+		uint32_t old_data_index = ctx-&gt;data_index;
+		uint32_t old_data_half = ctx-&gt;data_half;
+		uint32_t old_index = ctx-&gt;pipe_index;
+		uint32_t last_instruction = ctx-&gt;last_instruction;
+		uint32_t cycles = 0;
 		int current_pc_ok = ctx-&gt;pc_ok;
 
 		if (ctx-&gt;trace_data[ctx-&gt;pipe_index].flags &amp; ETMV1_TRIGGER_CYCLE)
@@ -888,8 +888,8 @@
 
 		if ((pipestat == STAT_ID) || (pipestat == STAT_BD))
 		{
-			u32 new_data_index = ctx-&gt;data_index;
-			u32 new_data_half = ctx-&gt;data_half;
+			uint32_t new_data_index = ctx-&gt;data_index;
+			uint32_t new_data_half = ctx-&gt;data_half;
 
 			/* in case of a branch with data, the branch target address was consumed before
 			 * we temporarily go back to the saved data index */
@@ -930,7 +930,7 @@
 					{
 						if (instruction.info.load_store_multiple.register_list &amp; (1 &lt;&lt; i))
 						{
-							u32 data;
+							uint32_t data;
 							if (etmv1_data(ctx, 4, &amp;data) != 0)
 								return ERROR_ETM_ANALYSIS_FAILED;
 							command_print(cmd_ctx, &quot;data: 0x%8.8x&quot;, data);
@@ -939,7 +939,7 @@
 				}
 				else if ((instruction.type &gt;= ARM_LDR) &amp;&amp; (instruction.type &lt;= ARM_STRH))
 				{
-					u32 data;
+					uint32_t data;
 					if (etmv1_data(ctx, arm_access_size(&amp;instruction), &amp;data) != 0)
 						return ERROR_ETM_ANALYSIS_FAILED;
 					command_print(cmd_ctx, &quot;data: 0x%8.8x&quot;, data);
@@ -1504,7 +1504,7 @@
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
 	etm_context_t *etm_ctx;
-	u32 i;
+	uint32_t i;
 
 	if (argc != 1)
 	{
@@ -1572,7 +1572,7 @@
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
 	etm_context_t *etm_ctx;
-	u32 i;
+	uint32_t i;
 
 	if (argc != 1)
 	{
@@ -1633,7 +1633,7 @@
 
 	for (i = 0; i &lt; etm_ctx-&gt;trace_depth; i++)
 	{
-		u32 pipestat, packet, flags;
+		uint32_t pipestat, packet, flags;
 		fileio_read_u32(&amp;file, &amp;pipestat);
 		fileio_read_u32(&amp;file, &amp;packet);
 		fileio_read_u32(&amp;file, &amp;flags);
@@ -1670,7 +1670,7 @@
 
 	if (argc &gt; 0)
 	{
-		u32 new_value = strtoul(args[0], NULL, 0);
+		uint32_t new_value = strtoul(args[0], NULL, 0);
 
 		if ((new_value &lt; 2) || (new_value &gt; 100))
 		{

Modified: trunk/src/target/etm.h
===================================================================
--- trunk/src/target/etm.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/etm.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -143,25 +143,25 @@
 	reg_cache_t *reg_cache;			/* ETM register cache */
 	etm_capture_driver_t *capture_driver;	/* driver used to access ETM data */
 	void *capture_driver_priv;		/* capture driver private data */
-	u32 trigger_percent;			/* percent of trace buffer to be filled after the trigger */
+	uint32_t trigger_percent;			/* percent of trace buffer to be filled after the trigger */
 	trace_status_t capture_status;	/* current state of capture run */
 	etmv1_trace_data_t *trace_data;	/* trace data */
-	u32 trace_depth;				/* number of trace cycles to be analyzed, 0 if no trace data available */
+	uint32_t trace_depth;				/* number of trace cycles to be analyzed, 0 if no trace data available */
 	etm_portmode_t portmode;		/* normal, multiplexed or demultiplexed */
 	etmv1_tracemode_t tracemode;	/* type of information the trace contains (data, addres, contextID, ...) */
 	armv4_5_state_t core_state;		/* current core state (ARM, Thumb, Jazelle) */
 	struct image_s *image;					/* source for target opcodes */
-	u32 pipe_index;					/* current trace cycle */
-	u32 data_index;					/* cycle holding next data packet */
+	uint32_t pipe_index;					/* current trace cycle */
+	uint32_t data_index;					/* cycle holding next data packet */
 	int data_half;					/* port half on a 16 bit port */
-	u32 current_pc;					/* current program counter */
-	u32 pc_ok;						/* full PC has been acquired */
-	u32 last_branch;				/* last branch address output */
-	u32 last_branch_reason;			/* branch reason code for the last branch encountered */
-	u32 last_ptr;					/* address of the last data access */
-	u32 ptr_ok;						/* whether last_ptr is valid */
-	u32 context_id;					/* context ID of the code being traced */
-	u32 last_instruction;			/* index of last instruction executed (to calculate cycle timings) */
+	uint32_t current_pc;					/* current program counter */
+	uint32_t pc_ok;						/* full PC has been acquired */
+	uint32_t last_branch;				/* last branch address output */
+	uint32_t last_branch_reason;			/* branch reason code for the last branch encountered */
+	uint32_t last_ptr;					/* address of the last data access */
+	uint32_t ptr_ok;						/* whether last_ptr is valid */
+	uint32_t context_id;					/* context ID of the code being traced */
+	uint32_t last_instruction;			/* index of last instruction executed (to calculate cycle timings) */
 } etm_context_t;
 
 /* PIPESTAT values */
@@ -194,10 +194,10 @@
 
 extern reg_cache_t* etm_build_reg_cache(target_t *target, arm_jtag_t *jtag_info, etm_context_t *etm_ctx);
 extern int etm_read_reg(reg_t *reg);
-extern int etm_write_reg(reg_t *reg, u32 value);
+extern int etm_write_reg(reg_t *reg, uint32_t value);
 extern int etm_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
 extern int etm_store_reg(reg_t *reg);
-extern int etm_set_reg(reg_t *reg, u32 value);
+extern int etm_set_reg(reg_t *reg, uint32_t value);
 extern int etm_set_reg_w_exec(reg_t *reg, uint8_t *buf);
 extern int etm_setup(target_t *target);
 

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/feroceon.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -55,7 +55,7 @@
 
 int feroceon_examine(struct target_s *target);
 int feroceon_target_create(struct target_s *target, Jim_Interp *interp);
-int feroceon_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
+int feroceon_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer);
 int feroceon_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int feroceon_quit(void);
 
@@ -112,7 +112,7 @@
 };
 
 
-int feroceon_dummy_clock_out(arm_jtag_t *jtag_info, u32 instr)
+int feroceon_dummy_clock_out(arm_jtag_t *jtag_info, uint32_t instr)
 {
 	scan_field_t fields[3];
 	uint8_t out_buf[4];
@@ -166,7 +166,7 @@
 	return ERROR_OK;
 }
 
-void feroceon_change_to_arm(target_t *target, u32 *r0, u32 *pc)
+void feroceon_change_to_arm(target_t *target, uint32_t *r0, uint32_t *pc)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -212,7 +212,7 @@
 	*pc -= (12 + 4);
 }
 
-void feroceon_read_core_regs(target_t *target, u32 mask, u32* core_regs[16])
+void feroceon_read_core_regs(target_t *target, uint32_t mask, uint32_t* core_regs[16])
 {
 	int i;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -231,14 +231,14 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_read_core_regs_target_buffer(target_t *target, u32 mask, void* buffer, int size)
+void feroceon_read_core_regs_target_buffer(target_t *target, uint32_t mask, void* buffer, int size)
 {
 	int i;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	int be = (target-&gt;endianness == TARGET_BIG_ENDIAN) ? 1 : 0;
-	u32 *buf_u32 = buffer;
+	uint32_t *buf_u32 = buffer;
 	uint16_t *buf_u16 = buffer;
 	uint8_t *buf_u8 = buffer;
 
@@ -268,7 +268,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_read_xpsr(target_t *target, u32 *xpsr, int spsr)
+void feroceon_read_xpsr(target_t *target, uint32_t *xpsr, int spsr)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -291,7 +291,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_write_xpsr(target_t *target, u32 xpsr, int spsr)
+void feroceon_write_xpsr(target_t *target, uint32_t xpsr, int spsr)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -349,7 +349,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_write_core_regs(target_t *target, u32 mask, u32 core_regs[16])
+void feroceon_write_core_regs(target_t *target, uint32_t mask, uint32_t core_regs[16])
 {
 	int i;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -391,8 +391,8 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	u32 r0 = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[0].value, 0, 32);
-	u32 pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	uint32_t r0 = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[0].value, 0, 32);
+	uint32_t pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 	(void)(r0); // use R0...
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -420,7 +420,7 @@
 	arm7_9-&gt;need_bypass_before_restart = 1;
 }
 
-int feroceon_read_cp15(target_t *target, u32 op1, u32 op2, u32 CRn, u32 CRm, u32 *value)
+int feroceon_read_cp15(target_t *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -442,7 +442,7 @@
 	return jtag_execute_queue();
 }
 
-int feroceon_write_cp15(target_t *target, u32 op1, u32 op2, u32 CRn, u32 CRm, u32 value)
+int feroceon_write_cp15(target_t *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -471,7 +471,7 @@
 	embeddedice_store_reg(dbg_ctrl);
 }
 
-void feroceon_enable_single_step(target_t *target, u32 next_pc)
+void feroceon_enable_single_step(target_t *target, uint32_t next_pc)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -507,20 +507,20 @@
 	return ERROR_OK;
 }
 
-int feroceon_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
+int feroceon_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	enum armv4_5_state core_state = armv4_5-&gt;core_state;
-	u32 x, flip, shift, save[7];
-	u32 i;
+	uint32_t x, flip, shift, save[7];
+	uint32_t i;
 
 	/*
 	 * We can't use the dcc flow control bits, so let's transfer data
 	 * with 31 bits and flip the MSB each time a new data word is sent.
 	 */
-	static u32 dcc_code[] =
+	static uint32_t dcc_code[] =
 	{
 		0xee115e10,	/* 3:	mrc	p14, 0, r5, c1, c0, 0	*/
 		0xe3a0301e,	/* 1:	mov	r3, #30			*/
@@ -544,7 +544,7 @@
 		0xeafffff3,	/*	b	3b			*/
 	};
 
-	u32 dcc_size = sizeof(dcc_code);
+	uint32_t dcc_size = sizeof(dcc_code);
 
 	if (!arm7_9-&gt;dcc_downloads)
 		return target_write_memory(target, address, 4, count, buffer);
@@ -592,8 +592,8 @@
 	shift = 1;
 	for (i = 0; i &lt; count; i++)
 	{
-		u32 y = target_buffer_get_u32(target, buffer);
-		u32 z = (x &gt;&gt; 1) | (y &gt;&gt; shift) | (flip ^= 0x80000000);
+		uint32_t y = target_buffer_get_u32(target, buffer);
+		uint32_t z = (x &gt;&gt; 1) | (y &gt;&gt; shift) | (flip ^= 0x80000000);
 		embeddedice_write_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA], z);
 		x = y &lt;&lt; (32 - shift);
 		if (++shift &gt;= 32 || i + 1 &gt;= count)

Modified: trunk/src/target/image.c
===================================================================
--- trunk/src/target/image.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/image.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -45,7 +45,7 @@
 {
 	int retval;
 	fileio_t fileio;
-	u32 read_bytes;
+	uint32_t read_bytes;
 	uint8_t buffer[9];
 
 	/* read the first 4 bytes of image */
@@ -148,8 +148,8 @@
 {
 	image_ihex_t *ihex = image-&gt;type_private;
 	fileio_t *fileio = &amp;ihex-&gt;fileio;
-	u32 full_address = 0x0;
-	u32 cooked_bytes;
+	uint32_t full_address = 0x0;
+	uint32_t cooked_bytes;
 	int i;
 	char lpszLine[1023];
 
@@ -167,12 +167,12 @@
 
 	while (fileio_fgets(fileio, 1023, lpszLine) == ERROR_OK)
 	{
-		u32 count;
-		u32 address;
-		u32 record_type;
-		u32 checksum;
+		uint32_t count;
+		uint32_t address;
+		uint32_t record_type;
+		uint32_t checksum;
 		uint8_t cal_checksum = 0;
-		u32 bytes_read = 0;
+		uint32_t bytes_read = 0;
 
 		if (sscanf(&amp;lpszLine[bytes_read], &quot;:%2x%4x%2x&quot;, &amp;count, &amp;address, &amp;record_type) != 3)
 		{
@@ -263,7 +263,7 @@
 		}
 		else if (record_type == 3) /* Start Segment Address Record */
 		{
-			u32 dummy;
+			uint32_t dummy;
 
 			/* &quot;Start Segment Address Record&quot; will not be supported */
 			/* but we must consume it, and do not create an error.  */
@@ -303,7 +303,7 @@
 		}
 		else if (record_type == 5) /* Start Linear Address Record */
 		{
-			u32 start_address;
+			uint32_t start_address;
 
 			sscanf(&amp;lpszLine[bytes_read], &quot;%8x&quot;, &amp;start_address);
 			cal_checksum += (uint8_t)(start_address &gt;&gt; 24);
@@ -339,8 +339,8 @@
 static int image_elf_read_headers(image_t *image)
 {
 	image_elf_t *elf = image-&gt;type_private;
-	u32 read_bytes;
-	u32 i,j;
+	uint32_t read_bytes;
+	uint32_t i,j;
 	int retval;
 
 	elf-&gt;header = malloc(sizeof(Elf32_Ehdr));
@@ -437,11 +437,11 @@
 	return ERROR_OK;
 }
 
-static int image_elf_read_section(image_t *image, int section, u32 offset, u32 size, uint8_t *buffer, u32 *size_read)
+static int image_elf_read_section(image_t *image, int section, uint32_t offset, uint32_t size, uint8_t *buffer, uint32_t *size_read)
 {
 	image_elf_t *elf = image-&gt;type_private;
 	Elf32_Phdr *segment = (Elf32_Phdr *)image-&gt;sections[section].private;
-	u32 read_size,really_read;
+	uint32_t read_size,really_read;
 	int retval;
 
 	*size_read = 0;
@@ -482,8 +482,8 @@
 {
 	image_mot_t *mot = image-&gt;type_private;
 	fileio_t *fileio = &amp;mot-&gt;fileio;
-	u32 full_address = 0x0;
-	u32 cooked_bytes;
+	uint32_t full_address = 0x0;
+	uint32_t cooked_bytes;
 	int i;
 	char lpszLine[1023];
 
@@ -501,12 +501,12 @@
 
 	while (fileio_fgets(fileio, 1023, lpszLine) == ERROR_OK)
 	{
-		u32 count;
-		u32 address;
-		u32 record_type;
-		u32 checksum;
+		uint32_t count;
+		uint32_t address;
+		uint32_t record_type;
+		uint32_t checksum;
 		uint8_t cal_checksum = 0;
-		u32 bytes_read = 0;
+		uint32_t bytes_read = 0;
 
 		/* get record type and record length */
 		if (sscanf(&amp;lpszLine[bytes_read], &quot;S%1x%2x&quot;, &amp;record_type, &amp;count) != 2)
@@ -599,7 +599,7 @@
 		else if (record_type == 5)
 		{
 			/* S5 is the data count record, we ignore it */
-			u32 dummy;
+			uint32_t dummy;
 
 			while (count-- &gt; 0)
 			{
@@ -776,7 +776,7 @@
 	return retval;
 };
 
-int image_read_section(image_t *image, int section, u32 offset, u32 size, uint8_t *buffer, u32 *size_read)
+int image_read_section(image_t *image, int section, uint32_t offset, uint32_t size, uint8_t *buffer, uint32_t *size_read)
 {
 	int retval;
 
@@ -822,13 +822,13 @@
 	else if (image-&gt;type == IMAGE_MEMORY)
 	{
 		image_memory_t *image_memory = image-&gt;type_private;
-		u32 address = image-&gt;sections[section].base_address + offset;
+		uint32_t address = image-&gt;sections[section].base_address + offset;
 
 		*size_read = 0;
 
 		while ((size - *size_read) &gt; 0)
 		{
-			u32 size_in_cache;
+			uint32_t size_in_cache;
 
 			if (!image_memory-&gt;cache
 				|| (address &lt; image_memory-&gt;cache_address)
@@ -876,7 +876,7 @@
 	return ERROR_OK;
 }
 
-int image_add_section(image_t *image, u32 base, u32 size, int flags, uint8_t *data)
+int image_add_section(image_t *image, uint32_t base, uint32_t size, int flags, uint8_t *data)
 {
 	image_section_t *section;
 
@@ -997,12 +997,12 @@
 	}
 }
 
-int image_calculate_checksum(uint8_t* buffer, u32 nbytes, u32* checksum)
+int image_calculate_checksum(uint8_t* buffer, uint32_t nbytes, uint32_t* checksum)
 {
-	u32 crc = 0xffffffff;
+	uint32_t crc = 0xffffffff;
 	LOG_DEBUG(&quot;Calculating checksum&quot;);
 
-	u32 crc32_table[256];
+	uint32_t crc32_table[256];
 
 	/* Initialize the CRC table and the decoding table.  */
 	int i, j;

Modified: trunk/src/target/image.h
===================================================================
--- trunk/src/target/image.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/image.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -49,8 +49,8 @@
 
 typedef struct image_section_s
 {
-	u32 base_address;
-	u32 size;
+	uint32_t base_address;
+	uint32_t size;
 	int flags;
 	void *private;		/* private data */
 } image_section_t;
@@ -64,7 +64,7 @@
 	int base_address_set;	/* whether the image has a base address set (for relocation purposes) */
 	int base_address;		/* base address, if one is set */
 	int start_address_set;	/* whether the image has a start address (entry point) associated */
-	u32 start_address;		/* start address, if one is set */
+	uint32_t start_address;		/* start address, if one is set */
 } image_t;
 
 typedef struct image_binary_s
@@ -82,7 +82,7 @@
 {
 	struct target_s *target;
 	uint8_t *cache;
-	u32 cache_address;
+	uint32_t cache_address;
 } image_memory_t;
 
 typedef struct fileio_elf_s
@@ -90,7 +90,7 @@
 	fileio_t fileio;
 	Elf32_Ehdr *header;
 	Elf32_Phdr *segments;
-	u32 segment_count;
+	uint32_t segment_count;
 	uint8_t endianness;
 } image_elf_t;
 
@@ -101,11 +101,11 @@
 } image_mot_t;
 
 extern int image_open(image_t *image, char *url, char *type_string);
-extern int image_read_section(image_t *image, int section, u32 offset, u32 size, uint8_t *buffer, u32 *size_read);
+extern int image_read_section(image_t *image, int section, uint32_t offset, uint32_t size, uint8_t *buffer, uint32_t *size_read);
 extern void image_close(image_t *image);
-extern int image_add_section(image_t *image, u32 base, u32 size, int flags, uint8_t *data);
+extern int image_add_section(image_t *image, uint32_t base, uint32_t size, int flags, uint8_t *data);
 
-extern int image_calculate_checksum(uint8_t* buffer, u32 nbytes, u32* checksum);
+extern int image_calculate_checksum(uint8_t* buffer, uint32_t nbytes, uint32_t* checksum);
 
 #define ERROR_IMAGE_FORMAT_ERROR	(-1400)
 #define ERROR_IMAGE_TYPE_UNKNOWN	(-1401)

Modified: trunk/src/target/mips32.c
===================================================================
--- trunk/src/target/mips32.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips32.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -116,7 +116,7 @@
 {
 	mips32_core_reg_t *mips32_reg = reg-&gt;arch_info;
 	target_t *target = mips32_reg-&gt;target;
-	u32 value = buf_get_u32(buf, 0, 32);
+	uint32_t value = buf_get_u32(buf, 0, 32);
 		
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -132,7 +132,7 @@
 
 int mips32_read_core_reg(struct target_s *target, int num)
 {
-	u32 reg_value;
+	uint32_t reg_value;
 	mips32_core_reg_t *mips_core_reg;
 	
 	/* get pointers to arch-specific information */
@@ -152,7 +152,7 @@
 
 int mips32_write_core_reg(struct target_s *target, int num)
 {
-	u32 reg_value;
+	uint32_t reg_value;
 	mips32_core_reg_t *mips_core_reg;
 	
 	/* get pointers to arch-specific information */
@@ -336,7 +336,7 @@
 	return ERROR_OK;
 }
 
-int mips32_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info)
+int mips32_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
 	/*TODO*/
 	return ERROR_OK;
@@ -366,7 +366,7 @@
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	int retval;
-	u32 dcr, bpinfo;
+	uint32_t dcr, bpinfo;
 	int i;
 	
 	if (mips32-&gt;bp_scanned)
@@ -425,7 +425,7 @@
 {
 	int retval;
 	int update = 0;
-	u32 dcr;
+	uint32_t dcr;
 	
 	/* read debug control register */
 	if ((retval = target_read_u32(target, EJTAG_DCR, &amp;dcr)) != ERROR_OK)

Modified: trunk/src/target/mips32.h
===================================================================
--- trunk/src/target/mips32.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips32.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -41,17 +41,17 @@
 {
 	int used;
 	//int type;
-	u32 bp_value;
-	u32 reg_address;
+	uint32_t bp_value;
+	uint32_t reg_address;
 } mips32_comparator_t;
 
 typedef struct mips32_common_s
 {
-	u32 common_magic;
+	uint32_t common_magic;
 	void *arch_info;
 	reg_cache_t *core_cache;
 	mips_ejtag_t ejtag_info;
-	u32 core_regs[MIPS32NUMCOREREGS];
+	uint32_t core_regs[MIPS32NUMCOREREGS];
 	
 	int bp_scanned;
 	int num_inst_bpoints;
@@ -68,7 +68,7 @@
 
 typedef struct mips32_core_reg_s
 {
-	u32 num;
+	uint32_t num;
 	struct target_s *target;
 	mips32_common_t *mips32_common;
 } mips32_core_reg_t;
@@ -129,7 +129,7 @@
 extern int mips32_restore_context(target_t *target);
 extern int mips32_save_context(target_t *target);
 extern reg_cache_t *mips32_build_reg_cache(target_t *target);
-extern int mips32_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info);
+extern int mips32_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
 extern int mips32_configure_break_unit(struct target_s *target);
 extern int mips32_enable_interrupts(struct target_s *target, int enable);
 extern int mips32_examine(struct target_s *target);

Modified: trunk/src/target/mips32_dmaacc.c
===================================================================
--- trunk/src/target/mips32_dmaacc.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips32_dmaacc.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -39,10 +39,10 @@
  * displaying/modifying memory and memory mapped registers.
  */
 
-static int ejtag_dma_read(mips_ejtag_t *ejtag_info, u32 addr, u32 *data)
+static int ejtag_dma_read(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t *data)
 {
-	u32 v;
-	u32 ejtag_ctrl;
+	uint32_t v;
+	uint32_t ejtag_ctrl;
 	int retries = RETRY_ATTEMPTS;
 
 begin_ejtag_dma_read:
@@ -85,10 +85,10 @@
 	return ERROR_OK;
 }
 
-static int ejtag_dma_read_h(mips_ejtag_t *ejtag_info, u32 addr, uint16_t *data)
+static int ejtag_dma_read_h(mips_ejtag_t *ejtag_info, uint32_t addr, uint16_t *data)
 {
-	u32 v;
-	u32 ejtag_ctrl;
+	uint32_t v;
+	uint32_t ejtag_ctrl;
 	int retries = RETRY_ATTEMPTS;
 
 begin_ejtag_dma_read_h:
@@ -137,10 +137,10 @@
 	return ERROR_OK;
 }
 
-static int ejtag_dma_read_b(mips_ejtag_t *ejtag_info, u32 addr, uint8_t *data)
+static int ejtag_dma_read_b(mips_ejtag_t *ejtag_info, uint32_t addr, uint8_t *data)
 {
-	u32 v;
-	u32 ejtag_ctrl;
+	uint32_t v;
+	uint32_t ejtag_ctrl;
 	int retries = RETRY_ATTEMPTS;
 
 begin_ejtag_dma_read_b:
@@ -199,10 +199,10 @@
 	return ERROR_OK;
 }
 
-static int ejtag_dma_write(mips_ejtag_t *ejtag_info, u32 addr, u32 data)
+static int ejtag_dma_write(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t data)
 {
-	u32 v;
-	u32 ejtag_ctrl;
+	uint32_t v;
+	uint32_t ejtag_ctrl;
 	int retries = RETRY_ATTEMPTS;
 
 begin_ejtag_dma_write:
@@ -246,10 +246,10 @@
 	return ERROR_OK;
 }
 
-static int ejtag_dma_write_h(mips_ejtag_t *ejtag_info, u32 addr, u32 data)
+static int ejtag_dma_write_h(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t data)
 {
-	u32 v;
-	u32 ejtag_ctrl;
+	uint32_t v;
+	uint32_t ejtag_ctrl;
 	int retries = RETRY_ATTEMPTS;
 
 	/* Handle the bigendian/littleendian */
@@ -297,10 +297,10 @@
 	return ERROR_OK;
 }
 
-static int ejtag_dma_write_b(mips_ejtag_t *ejtag_info, u32 addr, u32 data)
+static int ejtag_dma_write_b(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t data)
 {
-	u32 v;
-	u32 ejtag_ctrl;
+	uint32_t v;
+	uint32_t ejtag_ctrl;
 	int retries = RETRY_ATTEMPTS;
 
 	/* Handle the bigendian/littleendian */
@@ -349,7 +349,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_read_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf)
+int mips32_dmaacc_read_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
 	switch (size)
 	{
@@ -358,13 +358,13 @@
 		case 2:
 			return mips32_dmaacc_read_mem16(ejtag_info, addr, count, (uint16_t*)buf);
 		case 4:
-			return mips32_dmaacc_read_mem32(ejtag_info, addr, count, (u32*)buf);
+			return mips32_dmaacc_read_mem32(ejtag_info, addr, count, (uint32_t*)buf);
 	}
 
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf)
+int mips32_dmaacc_read_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf)
 {
 	int i;
 	int	retval;
@@ -377,7 +377,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf)
+int mips32_dmaacc_read_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf)
 {
 	int i;
 	int retval;
@@ -390,7 +390,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
+int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf)
 {
 	int i;
 	int retval;
@@ -403,7 +403,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_write_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf)
+int mips32_dmaacc_write_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
 	switch (size)
 	{
@@ -412,13 +412,13 @@
 		case 2:
 			return mips32_dmaacc_write_mem16(ejtag_info, addr, count,(uint16_t*)buf);
 		case 4:
-			return mips32_dmaacc_write_mem32(ejtag_info, addr, count, (u32*)buf);
+			return mips32_dmaacc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);
 	}
 
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf)
+int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf)
 {
 	int i;
 	int retval;
@@ -431,7 +431,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf)
+int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf)
 {
 	int i;
 	int retval;
@@ -444,7 +444,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
+int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf)
 {
 	int i;
 	int retval;

Modified: trunk/src/target/mips32_dmaacc.h
===================================================================
--- trunk/src/target/mips32_dmaacc.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips32_dmaacc.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -34,15 +34,15 @@
 
 #define RETRY_ATTEMPTS	0
 
-extern int mips32_dmaacc_read_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
-extern int mips32_dmaacc_write_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
+extern int mips32_dmaacc_read_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
+extern int mips32_dmaacc_write_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
 
-extern int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
-extern int mips32_dmaacc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf);
-extern int mips32_dmaacc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
+extern int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
+extern int mips32_dmaacc_read_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
+extern int mips32_dmaacc_read_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
 
-extern int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
-extern int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf);
-extern int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
+extern int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
+extern int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
+extern int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
 
 #endif

Modified: trunk/src/target/mips32_pracc.c
===================================================================
--- trunk/src/target/mips32_pracc.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips32_pracc.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -78,20 +78,20 @@
 #include &quot;mips32_pracc.h&quot;
 
 typedef struct {
-	u32 *local_iparam;
+	uint32_t *local_iparam;
 	int num_iparam;
-	u32 *local_oparam;
+	uint32_t *local_oparam;
 	int num_oparam;
-	u32 *code;
+	uint32_t *code;
 	int code_len;
-	u32 stack[32];
+	uint32_t stack[32];
 	int stack_offset;
 	mips_ejtag_t *ejtag_info;
 } mips32_pracc_context;
 
-static int wait_for_pracc_rw(mips_ejtag_t *ejtag_info, u32 *ctrl)
+static int wait_for_pracc_rw(mips_ejtag_t *ejtag_info, uint32_t *ctrl)
 {
-	u32 ejtag_ctrl;
+	uint32_t ejtag_ctrl;
 	
 	while (1) 
 	{
@@ -108,11 +108,11 @@
 	return ERROR_OK;
 }
 
-static int mips32_pracc_exec_read(mips32_pracc_context *ctx, u32 address)
+static int mips32_pracc_exec_read(mips32_pracc_context *ctx, uint32_t address)
 {
 	mips_ejtag_t *ejtag_info = ctx-&gt;ejtag_info;
 	int offset;
-	u32 ejtag_ctrl, data;
+	uint32_t ejtag_ctrl, data;
 
 	if ((address &gt;= MIPS32_PRACC_PARAM_IN)
 		&amp;&amp; (address &lt;= MIPS32_PRACC_PARAM_IN + ctx-&gt;num_iparam * 4))
@@ -164,9 +164,9 @@
 	return ERROR_OK;
 }
 
-static int mips32_pracc_exec_write(mips32_pracc_context *ctx, u32 address)
+static int mips32_pracc_exec_write(mips32_pracc_context *ctx, uint32_t address)
 {
-	u32 ejtag_ctrl,data;
+	uint32_t ejtag_ctrl,data;
 	int offset;
 	mips_ejtag_t *ejtag_info = ctx-&gt;ejtag_info;
 
@@ -207,10 +207,10 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_exec( mips_ejtag_t *ejtag_info, int code_len, u32 *code, int num_param_in, u32 *param_in, int num_param_out, u32 *param_out, int cycle)
+int mips32_pracc_exec( mips_ejtag_t *ejtag_info, int code_len, uint32_t *code, int num_param_in, uint32_t *param_in, int num_param_out, uint32_t *param_out, int cycle)
 {
-	u32 ejtag_ctrl;
-	u32 address, data;
+	uint32_t ejtag_ctrl;
+	uint32_t address, data;
 	mips32_pracc_context ctx;
 	int retval;
 	int pass = 0;
@@ -269,7 +269,7 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf)
+int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
 	switch (size)
 	{
@@ -279,17 +279,17 @@
 			return mips32_pracc_read_mem16(ejtag_info, addr, count, (uint16_t*)buf);
 		case 4:
 			if(count==1)
-				return mips32_pracc_read_u32(ejtag_info, addr, (u32*)buf);
+				return mips32_pracc_read_u32(ejtag_info, addr, (uint32_t*)buf);
 			else
-				return mips32_pracc_read_mem32(ejtag_info, addr, count, (u32*)buf);
+				return mips32_pracc_read_mem32(ejtag_info, addr, count, (uint32_t*)buf);
 	}
 	
 	return ERROR_OK;
 }
 
-int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf)
+int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf)
 {	
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -334,7 +334,7 @@
 	int retval = ERROR_OK;
 	int blocksize;
 	int bytesread;
-	u32 param_in[2];
+	uint32_t param_in[2];
 	
 	bytesread = 0;
 	
@@ -361,9 +361,9 @@
 	return retval;
 }
 
-int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf)
+int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t *buf)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -382,12 +382,12 @@
 	};
 
 	int retval = ERROR_OK;
-	u32 param_in[1];
+	uint32_t param_in[1];
 
 	param_in[0] = addr;
 
 	if ((retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, 
-		sizeof(param_in)/sizeof(param_in[0]), param_in, sizeof(u32), buf, 1)) != ERROR_OK)
+		sizeof(param_in)/sizeof(param_in[0]), param_in, sizeof(uint32_t), buf, 1)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -395,9 +395,9 @@
 	return retval;
 }
 
-int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf)
+int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -439,13 +439,13 @@
 	};
 
 //	/* TODO remove array */
-	u32 param_out[count];
+	uint32_t param_out[count];
 	int i;
 	
 //	int retval;
 	int blocksize;
 	int bytesread;
-	u32 param_in[2];
+	uint32_t param_in[2];
 	
 	bytesread = 0;
 	
@@ -474,9 +474,9 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
+int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -518,13 +518,13 @@
 	};
 	
 //	/* TODO remove array */
-	u32 param_out[count];
+	uint32_t param_out[count];
 	int i;
 	
 //	int retval;
 	int blocksize;
 	int bytesread;
-	u32 param_in[2];
+	uint32_t param_in[2];
 	
 	bytesread = 0;
 	
@@ -553,7 +553,7 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf)
+int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf)
 {
 	switch (size)
 	{
@@ -563,19 +563,19 @@
 			return mips32_pracc_write_mem16(ejtag_info, addr, count,(uint16_t*)buf);
 		case 4:
 			if(count==1)
-				return mips32_pracc_write_u32(ejtag_info, addr, (u32*)buf);
+				return mips32_pracc_write_u32(ejtag_info, addr, (uint32_t*)buf);
 			else
-				return mips32_pracc_write_mem32(ejtag_info, addr, count, (u32*)buf);
+				return mips32_pracc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);
 	}
 	
 	return ERROR_OK;
 }
 
-int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf)
+int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf)
 {
 
 //NC: use destination pointer as loop counter (last address is in $10)
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -608,11 +608,11 @@
 	};
 	
 	/* TODO remove array */
-	u32 param_in[count+2];
+	uint32_t param_in[count+2];
 	param_in[0] = addr;
-	param_in[1] = addr + count * sizeof(u32);	//last address
+	param_in[1] = addr + count * sizeof(uint32_t);	//last address
     
-	memcpy(&amp;param_in[2], buf, count * sizeof(u32));
+	memcpy(&amp;param_in[2], buf, count * sizeof(uint32_t));
 	
 	mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 		sizeof(param_in)/sizeof(param_in[0]),param_in, 0, NULL, 1);
@@ -620,9 +620,9 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf)
+int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t *buf)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -643,7 +643,7 @@
 	};
 
 	/* TODO remove array */
-	u32 param_in[1+1];
+	uint32_t param_in[1+1];
 	param_in[0] = addr;
 	param_in[1] = *buf;
 
@@ -653,9 +653,9 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf)
+int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -697,7 +697,7 @@
 	};
 	
 	/* TODO remove array */
-	u32 param_in[count+2];
+	uint32_t param_in[count+2];
 	int i;
 	param_in[0] = addr;
 	param_in[1] = count;
@@ -713,9 +713,9 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
+int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
 		MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 		/* $15 = MIPS32_PRACC_STACK */
@@ -757,7 +757,7 @@
 	};
 	
 	/* TODO remove array */
-	u32 param_in[count+2];
+	uint32_t param_in[count+2];
 	int retval;
 	int i;
 	param_in[0] = addr;
@@ -774,9 +774,9 @@
 	return retval;
 }
 
-int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, u32 *regs)
+int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, uint32_t *regs)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 														/* start: */
 		MIPS32_LUI(2,UPPER16(MIPS32_PRACC_PARAM_IN)), 	/* $2 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(2,2,LOWER16(MIPS32_PRACC_PARAM_IN)),
@@ -846,9 +846,9 @@
 	return retval;
 }
 
-int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, u32 *regs)
+int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, uint32_t *regs)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 														/* start: */
 		MIPS32_MTC0(2,31,0),							/* move $2 to COP0 DeSave */
 		MIPS32_LUI(2,UPPER16(MIPS32_PRACC_PARAM_OUT)), 	/* $2 = MIPS32_PRACC_PARAM_OUT */

Modified: trunk/src/target/mips32_pracc.h
===================================================================
--- trunk/src/target/mips32_pracc.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips32_pracc.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -32,27 +32,27 @@
 #define MIPS32_PRACC_PARAM_OUT		(MIPS32_PRACC_PARAM_IN + MIPS32_PRACC_PARAM_IN_SIZE)
 #define MIPS32_PRACC_PARAM_OUT_SIZE	0x1000
 
-#define UPPER16(u32) (u32 &gt;&gt; 16)
-#define LOWER16(u32) (u32 &amp; 0xFFFF)
+#define UPPER16(uint32_t) (uint32_t &gt;&gt; 16)
+#define LOWER16(uint32_t) (uint32_t &amp; 0xFFFF)
 #define NEG16(v) (((~(v)) + 1) &amp; 0xFFFF)
 /*#define NEG18(v) ( ((~(v)) + 1) &amp; 0x3FFFF )*/
 
-extern int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
-extern int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
+extern int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
+extern int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info, uint32_t addr, int size, int count, void *buf);
 
-extern int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
-extern int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf);
-extern int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
-extern int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);
+extern int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
+extern int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
+extern int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
+extern int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t *buf);
 
-extern int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
-extern int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, uint16_t *buf);
-extern int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
-extern int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);
+extern int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint8_t *buf);
+extern int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint16_t *buf);
+extern int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf);
+extern int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, uint32_t addr, uint32_t *buf);
 
-extern int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, u32 *regs);
-extern int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, u32 *regs);
+extern int mips32_pracc_read_regs(mips_ejtag_t *ejtag_info, uint32_t *regs);
+extern int mips32_pracc_write_regs(mips_ejtag_t *ejtag_info, uint32_t *regs);
 
-extern int mips32_pracc_exec( mips_ejtag_t *ejtag_info, int code_len, u32 *code, int num_param_in, u32 *param_in, int num_param_out, u32 *param_out, int cycle);
+extern int mips32_pracc_exec( mips_ejtag_t *ejtag_info, int code_len, uint32_t *code, int num_param_in, uint32_t *param_in, int num_param_out, uint32_t *param_out, int cycle);
 
 #endif

Modified: trunk/src/target/mips_ejtag.c
===================================================================
--- trunk/src/target/mips_ejtag.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips_ejtag.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -35,7 +35,7 @@
 	if (tap==NULL)
 		return ERROR_FAIL;
 
-	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != (u32)new_instr)
+	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != (uint32_t)new_instr)
 	{
 		scan_field_t field;
 		uint8_t t[4];
@@ -56,7 +56,7 @@
 	return ERROR_OK;
 }
 
-int mips_ejtag_get_idcode(mips_ejtag_t *ejtag_info, u32 *idcode)
+int mips_ejtag_get_idcode(mips_ejtag_t *ejtag_info, uint32_t *idcode)
 {
 	scan_field_t field;
 
@@ -83,7 +83,7 @@
 	return ERROR_OK;
 }
 
-int mips_ejtag_get_impcode(mips_ejtag_t *ejtag_info, u32 *impcode)
+int mips_ejtag_get_impcode(mips_ejtag_t *ejtag_info, uint32_t *impcode)
 {
 	scan_field_t field;
 
@@ -110,7 +110,7 @@
 	return ERROR_OK;
 }
 
-int mips_ejtag_drscan_32(mips_ejtag_t *ejtag_info, u32 *data)
+int mips_ejtag_drscan_32(mips_ejtag_t *ejtag_info, uint32_t *data)
 {
 	jtag_tap_t *tap;
 	tap  = ejtag_info-&gt;tap;
@@ -148,7 +148,7 @@
 
 int mips_ejtag_step_enable(mips_ejtag_t *ejtag_info)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 			MIPS32_MTC0(1,31,0),			/* move $1 to COP0 DeSave */
 			MIPS32_MFC0(1,23,0),			/* move COP0 Debug to $1 */
 			MIPS32_ORI(1,1,0x0100),			/* set SSt bit in debug reg */
@@ -166,7 +166,7 @@
 }
 int mips_ejtag_step_disable(mips_ejtag_t *ejtag_info)
 {
-	u32 code[] = {
+	uint32_t code[] = {
 			MIPS32_MTC0(15,31,0),							/* move $15 to COP0 DeSave */
 			MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 	/* $15 = MIPS32_PRACC_STACK */
 			MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
@@ -200,7 +200,7 @@
 
 int mips_ejtag_enter_debug(mips_ejtag_t *ejtag_info)
 {
-	u32 ejtag_ctrl;
+	uint32_t ejtag_ctrl;
 	jtag_set_end_state(TAP_IDLE);
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
 
@@ -220,7 +220,7 @@
 
 int mips_ejtag_exit_debug(mips_ejtag_t *ejtag_info)
 {
-	u32 inst;
+	uint32_t inst;
 	inst = MIPS32_DRET;
 	
 	/* execute our dret instruction */
@@ -229,10 +229,10 @@
 	return ERROR_OK;
 }
 
-int mips_ejtag_read_debug(mips_ejtag_t *ejtag_info, u32* debug_reg)
+int mips_ejtag_read_debug(mips_ejtag_t *ejtag_info, uint32_t* debug_reg)
 {
 	/* read ejtag ECR */
-	u32 code[] = {
+	uint32_t code[] = {
 			MIPS32_MTC0(15,31,0),							/* move $15 to COP0 DeSave */
 			MIPS32_LUI(15,UPPER16(MIPS32_PRACC_STACK)), 	/* $15 = MIPS32_PRACC_STACK */
 			MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
@@ -258,7 +258,7 @@
 
 int mips_ejtag_init(mips_ejtag_t *ejtag_info)
 {
-	u32 ejtag_version;
+	uint32_t ejtag_version;
 
 	mips_ejtag_get_impcode(ejtag_info, &amp;ejtag_info-&gt;impcode);
 	LOG_DEBUG(&quot;impcode: 0x%8.8x&quot;, ejtag_info-&gt;impcode);

Modified: trunk/src/target/mips_ejtag.h
===================================================================
--- trunk/src/target/mips_ejtag.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips_ejtag.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -100,21 +100,21 @@
 typedef struct mips_ejtag_s
 {
 	jtag_tap_t *tap;
-	u32 impcode;
-	u32 idcode;
+	uint32_t impcode;
+	uint32_t idcode;
 	/*int use_dma;*/
-	u32 ejtag_ctrl;
+	uint32_t ejtag_ctrl;
 } mips_ejtag_t;
 
 extern int mips_ejtag_set_instr(mips_ejtag_t *ejtag_info, int new_instr, void *delete_me_and_submit_patch);
 extern int mips_ejtag_enter_debug(mips_ejtag_t *ejtag_info);
 extern int mips_ejtag_exit_debug(mips_ejtag_t *ejtag_info);
-extern int mips_ejtag_get_impcode(mips_ejtag_t *ejtag_info, u32 *impcode);
-extern int mips_ejtag_get_idcode(mips_ejtag_t *ejtag_info, u32 *idcode);
-extern int mips_ejtag_drscan_32(mips_ejtag_t *ejtag_info, u32 *data);
+extern int mips_ejtag_get_impcode(mips_ejtag_t *ejtag_info, uint32_t *impcode);
+extern int mips_ejtag_get_idcode(mips_ejtag_t *ejtag_info, uint32_t *idcode);
+extern int mips_ejtag_drscan_32(mips_ejtag_t *ejtag_info, uint32_t *data);
 
 extern int mips_ejtag_init(mips_ejtag_t *ejtag_info);
 extern int mips_ejtag_config_step(mips_ejtag_t *ejtag_info, int enable_step);
-extern int mips_ejtag_read_debug(mips_ejtag_t *ejtag_info, u32* debug_reg);
+extern int mips_ejtag_read_debug(mips_ejtag_t *ejtag_info, uint32_t* debug_reg);
 
 #endif /* MIPS_EJTAG */

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips_m4k.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -35,10 +35,10 @@
 int mips_m4k_poll(target_t *target);
 int mips_m4k_halt(struct target_s *target);
 int mips_m4k_soft_reset_halt(struct target_s *target);
-int mips_m4k_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
-int mips_m4k_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
-int mips_m4k_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int mips_m4k_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int mips_m4k_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+int mips_m4k_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints);
+int mips_m4k_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int mips_m4k_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int mips_m4k_register_commands(struct command_context_s *cmd_ctx);
 int mips_m4k_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int mips_m4k_quit(void);
@@ -47,7 +47,7 @@
 int mips_m4k_examine(struct target_s *target);
 int mips_m4k_assert_reset(target_t *target);
 int mips_m4k_deassert_reset(target_t *target);
-int mips_m4k_checksum_memory(target_t *target, u32 address, u32 size, u32 *checksum);
+int mips_m4k_checksum_memory(target_t *target, uint32_t address, uint32_t size, uint32_t *checksum);
 
 target_type_t mips_m4k_target =
 {
@@ -90,7 +90,7 @@
 
 int mips_m4k_examine_debug_reason(target_t *target)
 {
-	u32 break_status;
+	uint32_t break_status;
 	int retval;
 
 	if ((target-&gt;debug_reason != DBG_REASON_DBGRQ)
@@ -126,7 +126,7 @@
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	u32 debug_reg;
+	uint32_t debug_reg;
 
 	/* read debug register */
 	mips_ejtag_read_debug(ejtag_info, &amp;debug_reg);
@@ -147,7 +147,7 @@
 	mips32_save_context(target);
 
 	LOG_DEBUG(&quot;entered debug state at PC 0x%x, target-&gt;state: %s&quot;,
-		*(u32*)(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value),
+		*(uint32_t*)(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value),
 		  Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name);
 
 	return ERROR_OK;
@@ -158,7 +158,7 @@
 	int retval;
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	u32 ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl;
+	uint32_t ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl;
 
 	/* read ejtag control reg */
 	jtag_set_end_state(TAP_IDLE);
@@ -288,7 +288,7 @@
 
 	if (strcmp(target-&gt;variant, &quot;ejtag_srst&quot;) == 0)
 	{
-		u32 ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
+		uint32_t ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
 		LOG_DEBUG(&quot;Using EJTAG reset (PRRST) to reset processor...&quot;);
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
 		mips_ejtag_drscan_32(ejtag_info, &amp;ejtag_ctrl);
@@ -357,12 +357,12 @@
 	return ERROR_OK;
 }
 
-int mips_m4k_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
+int mips_m4k_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
 	breakpoint_t *breakpoint = NULL;
-	u32 resume_pc;
+	uint32_t resume_pc;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -428,7 +428,7 @@
 	return ERROR_OK;
 }
 
-int mips_m4k_step(struct target_s *target, int current, u32 address, int handle_breakpoints)
+int mips_m4k_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
@@ -529,7 +529,7 @@
 	{
 		if (breakpoint-&gt;length == 4)
 		{
-			u32 verify = 0xffffffff;
+			uint32_t verify = 0xffffffff;
 			
 			if((retval = target_read_memory(target, breakpoint-&gt;address, breakpoint-&gt;length, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
 			{
@@ -610,7 +610,7 @@
 		/* restore original instruction (kept in target endianness) */
 		if (breakpoint-&gt;length == 4)
 		{
-			u32 current_instr;
+			uint32_t current_instr;
 			
 			/* check that user program has not modified breakpoint instruction */
 			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
@@ -728,7 +728,7 @@
 	}
 }
 
-int mips_m4k_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int mips_m4k_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
@@ -760,7 +760,7 @@
 	/* TAP data register is loaded LSB first (little endian) */
 	if (target-&gt;endianness == TARGET_BIG_ENDIAN) 
 	{
-		u32 i, t32;
+		uint32_t i, t32;
 		uint16_t t16;
 
 		for(i = 0; i &lt; (count*size); i += size)
@@ -782,7 +782,7 @@
 	return ERROR_OK;
 }
 
-int mips_m4k_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int mips_m4k_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
@@ -805,7 +805,7 @@
 	/* TAP data register is loaded LSB first (little endian) */
 	if (target-&gt;endianness == TARGET_BIG_ENDIAN)
 	{
-		u32 i, t32;
+		uint32_t i, t32;
 		uint16_t t16;
 
 		for(i = 0; i &lt; (count*size); i += size)
@@ -878,7 +878,7 @@
 	int retval;
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	u32 idcode = 0;
+	uint32_t idcode = 0;
 
 	if (!target_was_examined(target))
 	{
@@ -904,12 +904,12 @@
 	return ERROR_OK;
 }
 
-int mips_m4k_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
+int mips_m4k_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	return mips_m4k_write_memory(target, address, 4, count, buffer);
 }
 
-int mips_m4k_checksum_memory(target_t *target, u32 address, u32 size, u32 *checksum)
+int mips_m4k_checksum_memory(target_t *target, uint32_t address, uint32_t size, uint32_t *checksum)
 {
 	return ERROR_FAIL; /* use bulk read method */
 }

Modified: trunk/src/target/mips_m4k.h
===================================================================
--- trunk/src/target/mips_m4k.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/mips_m4k.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -35,7 +35,7 @@
 	mips32_common_t mips32_common;
 } mips_m4k_common_t;
 
-extern int mips_m4k_bulk_write_memory(struct target_s *target, u32 address, u32 count, uint8_t *buffer);
+extern int mips_m4k_bulk_write_memory(struct target_s *target, uint32_t address, uint32_t count, uint8_t *buffer);
 
 extern void mips_m4k_enable_breakpoints(struct target_s *target);
 extern int mips_m4k_set_breakpoint(struct target_s *target, breakpoint_t *breakpoint);

Modified: trunk/src/target/oocd_trace.c
===================================================================
--- trunk/src/target/oocd_trace.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/oocd_trace.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -32,7 +32,7 @@
 
 static int oocd_trace_register_commands(struct command_context_s *cmd_ctx);
 
-static int oocd_trace_read_reg(oocd_trace_t *oocd_trace, int reg, u32 *value)
+static int oocd_trace_read_reg(oocd_trace_t *oocd_trace, int reg, uint32_t *value)
 {
 	size_t bytes_written, bytes_read, bytes_to_read;
 	uint8_t cmd;
@@ -52,7 +52,7 @@
 	return ERROR_OK;
 }
 
-static int oocd_trace_write_reg(oocd_trace_t *oocd_trace, int reg, u32 value)
+static int oocd_trace_write_reg(oocd_trace_t *oocd_trace, int reg, uint32_t value)
 {
 	size_t bytes_written;
 	uint8_t data[5];
@@ -69,7 +69,7 @@
 	return ERROR_OK;
 }
 
-static int oocd_trace_read_memory(oocd_trace_t *oocd_trace, uint8_t *data, u32 address, u32 size)
+static int oocd_trace_read_memory(oocd_trace_t *oocd_trace, uint8_t *data, uint32_t address, uint32_t size)
 {
 	size_t bytes_written, bytes_to_read;
 	ssize_t bytes_read;
@@ -146,7 +146,7 @@
 static trace_status_t oocd_trace_status(etm_context_t *etm_ctx)
 {
 	oocd_trace_t *oocd_trace = etm_ctx-&gt;capture_driver_priv;
-	u32 status;
+	uint32_t status;
 
 	oocd_trace_read_reg(oocd_trace, OOCD_TRACE_STATUS, &amp;status);
 
@@ -178,11 +178,11 @@
 static int oocd_trace_read_trace(etm_context_t *etm_ctx)
 {
 	oocd_trace_t *oocd_trace = etm_ctx-&gt;capture_driver_priv;
-	u32 status, address;
-	u32 first_frame = 0x0;
-	u32 num_frames = 1048576;
+	uint32_t status, address;
+	uint32_t first_frame = 0x0;
+	uint32_t num_frames = 1048576;
 	uint8_t *trace_data;
-	u32 i;
+	uint32_t i;
 
 	oocd_trace_read_reg(oocd_trace, OOCD_TRACE_STATUS, &amp;status);
 	oocd_trace_read_reg(oocd_trace, OOCD_TRACE_ADDRESS, &amp;address);
@@ -236,8 +236,8 @@
 static int oocd_trace_start_capture(etm_context_t *etm_ctx)
 {
 	oocd_trace_t *oocd_trace = etm_ctx-&gt;capture_driver_priv;
-	u32 control = 0x1;	/* 0x1: enabled */
-	u32 trigger_count;
+	uint32_t control = 0x1;	/* 0x1: enabled */
+	uint32_t trigger_count;
 
 	if (((etm_ctx-&gt;portmode &amp; ETM_PORT_MODE_MASK) != ETM_PORT_NORMAL)
 		|| ((etm_ctx-&gt;portmode &amp; ETM_PORT_WIDTH_MASK) != ETM_PORT_4BIT))
@@ -333,7 +333,7 @@
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
 	oocd_trace_t *oocd_trace;
-	u32 status;
+	uint32_t status;
 
 	target = get_current_target(cmd_ctx);
 

Modified: trunk/src/target/register.h
===================================================================
--- trunk/src/target/register.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/register.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -39,7 +39,7 @@
 	void *value;
 	int dirty;
 	int valid;
-	u32 size;
+	uint32_t size;
 	bitfield_desc_t *bitfield_desc;
 	int num_bitfields;
 	void *arch_info;

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/target.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -271,8 +271,8 @@
 
 static int target_continuous_poll = 1;
 
-/* read a u32 from a buffer in target memory endianness */
-u32 target_buffer_get_u32(target_t *target, const uint8_t *buffer)
+/* read a uint32_t from a buffer in target memory endianness */
+uint32_t target_buffer_get_u32(target_t *target, const uint8_t *buffer)
 {
 	if (target-&gt;endianness == TARGET_LITTLE_ENDIAN)
 		return le_to_h_u32(buffer);
@@ -295,8 +295,8 @@
 	return *buffer &amp; 0x0ff;
 }
 
-/* write a u32 to a buffer in target memory endianness */
-void target_buffer_set_u32(target_t *target, uint8_t *buffer, u32 value)
+/* write a uint32_t to a buffer in target memory endianness */
+void target_buffer_set_u32(target_t *target, uint8_t *buffer, uint32_t value)
 {
 	if (target-&gt;endianness == TARGET_LITTLE_ENDIAN)
 		h_u32_to_le(buffer, value);
@@ -400,7 +400,7 @@
 	return target-&gt;type-&gt;halt(target);
 }
 
-int target_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
+int target_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	int retval;
 
@@ -455,7 +455,7 @@
 	return retval;
 }
 
-static int default_virt2phys(struct target_s *target, u32 virtual, u32 *physical)
+static int default_virt2phys(struct target_s *target, uint32_t virtual, uint32_t *physical)
 {
 	*physical = virtual;
 	return ERROR_OK;
@@ -518,7 +518,7 @@
 	return target-&gt;type-&gt;name;
 }
 
-static int target_write_memory_imp(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+static int target_write_memory_imp(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	if (!target_was_examined(target))
 	{
@@ -528,7 +528,7 @@
 	return target-&gt;type-&gt;write_memory_imp(target, address, size, count, buffer);
 }
 
-static int target_read_memory_imp(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+static int target_read_memory_imp(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	if (!target_was_examined(target))
 	{
@@ -548,7 +548,7 @@
 	return target-&gt;type-&gt;soft_reset_halt_imp(target);
 }
 
-static int target_run_algorithm_imp(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info)
+static int target_run_algorithm_imp(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
 	if (!target_was_examined(target))
 	{
@@ -559,18 +559,18 @@
 }
 
 int target_read_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, uint8_t *buffer)
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	return target-&gt;type-&gt;read_memory(target, address, size, count, buffer);
 }
 
 int target_write_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, uint8_t *buffer)
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	return target-&gt;type-&gt;write_memory(target, address, size, count, buffer);
 }
 int target_bulk_write_memory(struct target_s *target,
-		u32 address, u32 count, uint8_t *buffer)
+		uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	return target-&gt;type-&gt;bulk_write_memory(target, address, count, buffer);
 }
@@ -603,7 +603,7 @@
 	return target-&gt;type-&gt;get_gdb_reg_list(target, reg_list, reg_list_size);
 }
 int target_step(struct target_s *target,
-		int current, u32 address, int handle_breakpoints)
+		int current, uint32_t address, int handle_breakpoints)
 {
 	return target-&gt;type-&gt;step(target, current, address, handle_breakpoints);
 }
@@ -612,7 +612,7 @@
 int target_run_algorithm(struct target_s *target,
 		int num_mem_params, mem_param_t *mem_params,
 		int num_reg_params, reg_param_t *reg_param,
-		u32 entry_point, u32 exit_point,
+		uint32_t entry_point, uint32_t exit_point,
 		int timeout_ms, void *arch_info)
 {
 	return target-&gt;type-&gt;run_algorithm(target,
@@ -904,7 +904,7 @@
 	return target_call_timer_callbacks_check_time(0);
 }
 
-int target_alloc_working_area(struct target_s *target, u32 size, working_area_t **area)
+int target_alloc_working_area(struct target_s *target, uint32_t size, working_area_t **area)
 {
 	working_area_t *c = target-&gt;working_areas;
 	working_area_t *new_wa = NULL;
@@ -951,8 +951,8 @@
 	if (!new_wa)
 	{
 		working_area_t **p = &amp;target-&gt;working_areas;
-		u32 first_free = target-&gt;working_area;
-		u32 free_size = target-&gt;working_area_size;
+		uint32_t first_free = target-&gt;working_area;
+		uint32_t free_size = target-&gt;working_area_size;
 
 		LOG_DEBUG(&quot;allocating new working area&quot;);
 
@@ -1096,7 +1096,7 @@
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_write_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer)
+int target_write_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer)
 {
 	int retval;
 	LOG_DEBUG(&quot;writing buffer of %i byte at 0x%8.8x&quot;, size, address);
@@ -1126,7 +1126,7 @@
 	/* handle unaligned head bytes */
 	if (address % 4)
 	{
-		u32 unaligned = 4 - (address % 4);
+		uint32_t unaligned = 4 - (address % 4);
 
 		if (unaligned &gt; size)
 			unaligned = size;
@@ -1175,7 +1175,7 @@
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_read_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer)
+int target_read_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer)
 {
 	int retval;
 	LOG_DEBUG(&quot;reading buffer of %i byte at 0x%8.8x&quot;, size, address);
@@ -1205,7 +1205,7 @@
 	/* handle unaligned head bytes */
 	if (address % 4)
 	{
-		u32 unaligned = 4 - (address % 4);
+		uint32_t unaligned = 4 - (address % 4);
 
 		if (unaligned &gt; size)
 			unaligned = size;
@@ -1241,12 +1241,12 @@
 	return ERROR_OK;
 }
 
-int target_checksum_memory(struct target_s *target, u32 address, u32 size, u32* crc)
+int target_checksum_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t* crc)
 {
 	uint8_t *buffer;
 	int retval;
-	u32 i;
-	u32 checksum = 0;
+	uint32_t i;
+	uint32_t checksum = 0;
 	if (!target_was_examined(target))
 	{
 		LOG_ERROR(&quot;Target not examined yet&quot;);
@@ -1270,11 +1270,11 @@
 		}
 
 		/* convert to target endianess */
-		for (i = 0; i &lt; (size/sizeof(u32)); i++)
+		for (i = 0; i &lt; (size/sizeof(uint32_t)); i++)
 		{
-			u32 target_data;
-			target_data = target_buffer_get_u32(target, &amp;buffer[i*sizeof(u32)]);
-			target_buffer_set_u32(target, &amp;buffer[i*sizeof(u32)], target_data);
+			uint32_t target_data;
+			target_data = target_buffer_get_u32(target, &amp;buffer[i*sizeof(uint32_t)]);
+			target_buffer_set_u32(target, &amp;buffer[i*sizeof(uint32_t)], target_data);
 		}
 
 		retval = image_calculate_checksum( buffer, size, &amp;checksum );
@@ -1286,7 +1286,7 @@
 	return retval;
 }
 
-int target_blank_check_memory(struct target_s *target, u32 address, u32 size, u32* blank)
+int target_blank_check_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t* blank)
 {
 	int retval;
 	if (!target_was_examined(target))
@@ -1303,7 +1303,7 @@
 	return retval;
 }
 
-int target_read_u32(struct target_s *target, u32 address, u32 *value)
+int target_read_u32(struct target_s *target, uint32_t address, uint32_t *value)
 {
 	uint8_t value_buf[4];
 	if (!target_was_examined(target))
@@ -1328,7 +1328,7 @@
 	return retval;
 }
 
-int target_read_u16(struct target_s *target, u32 address, uint16_t *value)
+int target_read_u16(struct target_s *target, uint32_t address, uint16_t *value)
 {
 	uint8_t value_buf[2];
 	if (!target_was_examined(target))
@@ -1353,7 +1353,7 @@
 	return retval;
 }
 
-int target_read_u8(struct target_s *target, u32 address, uint8_t *value)
+int target_read_u8(struct target_s *target, uint32_t address, uint8_t *value)
 {
 	int retval = target_read_memory(target, address, 1, 1, value);
 	if (!target_was_examined(target))
@@ -1375,7 +1375,7 @@
 	return retval;
 }
 
-int target_write_u32(struct target_s *target, u32 address, u32 value)
+int target_write_u32(struct target_s *target, uint32_t address, uint32_t value)
 {
 	int retval;
 	uint8_t value_buf[4];
@@ -1396,7 +1396,7 @@
 	return retval;
 }
 
-int target_write_u16(struct target_s *target, u32 address, uint16_t value)
+int target_write_u16(struct target_s *target, uint32_t address, uint16_t value)
 {
 	int retval;
 	uint8_t value_buf[2];
@@ -1417,7 +1417,7 @@
 	return retval;
 }
 
-int target_write_u8(struct target_s *target, u32 address, uint8_t value)
+int target_write_u8(struct target_s *target, uint32_t address, uint8_t value)
 {
 	int retval;
 	if (!target_was_examined(target))
@@ -1976,7 +1976,7 @@
 	/* with no args, resume from current pc, addr = 0,
 	 * with one arguments, addr = args[0],
 	 * handle breakpoints, not debugging */
-	u32 addr = 0;
+	uint32_t addr = 0;
 	if (argc == 1)
 	{
 		int retval = parse_u32(args[0], &amp;addr);
@@ -1997,7 +1997,7 @@
 	/* with no args, step from current pc, addr = 0,
 	 * with one argument addr = args[0],
 	 * handle breakpoints, debugging */
-	u32 addr = 0;
+	uint32_t addr = 0;
 	if (argc == 1)
 	{
 		int retval = parse_u32(args[0], &amp;addr);
@@ -2010,7 +2010,7 @@
 }
 
 static void handle_md_output(struct command_context_s *cmd_ctx,
-		struct target_s *target, u32 address, unsigned size,
+		struct target_s *target, uint32_t address, unsigned size,
 		unsigned count, const uint8_t *buffer)
 {
 	const unsigned line_bytecnt = 32;
@@ -2038,7 +2038,7 @@
 					&quot;0x%8.8x: &quot;, address + (i*size));
 		}
 
-		u32 value=0;
+		uint32_t value=0;
 		const uint8_t *value_ptr = buffer + i * size;
 		switch (size) {
 		case 4: value = target_buffer_get_u32(target, value_ptr); break;
@@ -2070,7 +2070,7 @@
 	default: return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	u32 address;
+	uint32_t address;
 	int retval = parse_u32(args[0], &amp;address);
 	if (ERROR_OK != retval)
 		return retval;
@@ -2101,12 +2101,12 @@
 	 if ((argc &lt; 2) || (argc &gt; 3))
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	u32 address;
+	uint32_t address;
 	int retval = parse_u32(args[0], &amp;address);
 	if (ERROR_OK != retval)
 		return retval;
 
-	u32 value;
+	uint32_t value;
 	retval = parse_u32(args[1], &amp;value);
 	if (ERROR_OK != retval)
 		return retval;
@@ -2153,7 +2153,7 @@
 }
 
 static int parse_load_image_command_args(char **args, int argc,
-		image_t *image, u32 *min_address, u32 *max_address)
+		image_t *image, uint32_t *min_address, uint32_t *max_address)
 {
 	if (argc &lt; 1 || argc &gt; 5)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -2162,7 +2162,7 @@
 	 * default to 0x0 (i.e. don't relocate) */
 	if (argc &gt;= 2)
 	{
-		u32 addr;
+		uint32_t addr;
 		int retval = parse_u32(args[1], &amp;addr);
 		if (ERROR_OK != retval)
 			return ERROR_COMMAND_SYNTAX_ERROR;
@@ -2198,10 +2198,10 @@
 static int handle_load_image_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	uint8_t *buffer;
-	u32 buf_cnt;
-	u32 image_size;
-	u32 min_address = 0;
-	u32 max_address = 0xffffffff;
+	uint32_t buf_cnt;
+	uint32_t image_size;
+	uint32_t min_address = 0;
+	uint32_t max_address = 0xffffffff;
 	int i;
 	int retvaltemp;
 
@@ -2240,8 +2240,8 @@
 			break;
 		}
 
-		u32 offset=0;
-		u32 length=buf_cnt;
+		uint32_t offset=0;
+		uint32_t length=buf_cnt;
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
@@ -2308,12 +2308,12 @@
 		return ERROR_OK;
 	}
 
-	u32 address;
+	uint32_t address;
 	int retval = parse_u32(args[1], &amp;address);
 	if (ERROR_OK != retval)
 		return retval;
 
-	u32 size;
+	uint32_t size;
 	retval = parse_u32(args[2], &amp;size);
 	if (ERROR_OK != retval)
 		return retval;
@@ -2327,8 +2327,8 @@
 
 	while (size &gt; 0)
 	{
-		u32 size_written;
-		u32 this_run_size = (size &gt; 560) ? 560 : size;
+		uint32_t size_written;
+		uint32_t this_run_size = (size &gt; 560) ? 560 : size;
 
 		retval = target_read_buffer(target, address, this_run_size, buffer);
 		if (retval != ERROR_OK)
@@ -2365,12 +2365,12 @@
 static int handle_verify_image_command_internal(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, int verify)
 {
 	uint8_t *buffer;
-	u32 buf_cnt;
-	u32 image_size;
+	uint32_t buf_cnt;
+	uint32_t image_size;
 	int i;
 	int retval, retvaltemp;
-	u32 checksum = 0;
-	u32 mem_checksum = 0;
+	uint32_t checksum = 0;
+	uint32_t mem_checksum = 0;
 
 	image_t image;
 
@@ -2394,7 +2394,7 @@
 
 	if (argc &gt;= 2)
 	{
-		u32 addr;
+		uint32_t addr;
 		retval = parse_u32(args[1], &amp;addr);
 		if (ERROR_OK != retval)
 			return ERROR_COMMAND_SYNTAX_ERROR;
@@ -2462,7 +2462,7 @@
 				retval = target_read_memory(target, image.sections[i].base_address, size, count, data);
 				if (retval == ERROR_OK)
 				{
-					u32 t;
+					uint32_t t;
 					for (t = 0; t &lt; buf_cnt; t++)
 					{
 						if (data[t] != buffer[t])
@@ -2546,7 +2546,7 @@
 }
 
 static int handle_bp_command_set(struct command_context_s *cmd_ctx,
-		u32 addr, u32 length, int hw)
+		uint32_t addr, uint32_t length, int hw)
 {
 	target_t *target = get_current_target(cmd_ctx);
 	int retval = breakpoint_add(target, addr, length, hw);
@@ -2569,12 +2569,12 @@
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	u32 addr;
+	uint32_t addr;
 	int retval = parse_u32(args[0], &amp;addr);
 	if (ERROR_OK != retval)
 		return retval;
 
-	u32 length;
+	uint32_t length;
 	retval = parse_u32(args[1], &amp;length);
 	if (ERROR_OK != retval)
 		return retval;
@@ -2596,7 +2596,7 @@
 	if (argc != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	u32 addr;
+	uint32_t addr;
 	int retval = parse_u32(args[0], &amp;addr);
 	if (ERROR_OK != retval)
 		return retval;
@@ -2624,10 +2624,10 @@
 	}
 
 	enum watchpoint_rw type = WPT_ACCESS;
-	u32 addr = 0;
-	u32 length = 0;
-	u32 data_value = 0x0;
-	u32 data_mask = 0xffffffff;
+	uint32_t addr = 0;
+	uint32_t length = 0;
+	uint32_t data_value = 0x0;
+	uint32_t data_mask = 0xffffffff;
 	int retval;
 
 	switch (argc)
@@ -2686,7 +2686,7 @@
 	if (argc != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	u32 addr;
+	uint32_t addr;
 	int retval = parse_u32(args[0], &amp;addr);
 	if (ERROR_OK != retval)
 		return retval;
@@ -2710,11 +2710,11 @@
 	if (argc != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	u32 va;
+	uint32_t va;
 	int retval = parse_u32(args[0], &amp;va);
 	if (ERROR_OK != retval)
 		return retval;
-	u32 pa;
+	uint32_t pa;
 
 	target_t *target = get_current_target(cmd_ctx);
 	retval = target-&gt;type-&gt;virt2phys(target, va, &amp;pa);
@@ -2748,9 +2748,9 @@
 }
 
 /* Dump a gmon.out histogram file. */
-static void writeGmon(u32 *samples, u32 sampleNum, char *filename)
+static void writeGmon(uint32_t *samples, uint32_t sampleNum, char *filename)
 {
-	u32 i;
+	uint32_t i;
 	FILE *f=fopen(filename, &quot;w&quot;);
 	if (f==NULL)
 		return;
@@ -2764,8 +2764,8 @@
 	writeData(f, &amp;zero, 1);
 
 	/* figure out bucket size */
-	u32 min=samples[0];
-	u32 max=samples[0];
+	uint32_t min=samples[0];
+	uint32_t max=samples[0];
 	for (i=0; i&lt;sampleNum; i++)
 	{
 		if (min&gt;samples[i])
@@ -2780,8 +2780,8 @@
 
 	int addressSpace=(max-min+1);
 
-	static const u32 maxBuckets = 256 * 1024; /* maximum buckets. */
-	u32 length = addressSpace;
+	static const uint32_t maxBuckets = 256 * 1024; /* maximum buckets. */
+	uint32_t length = addressSpace;
 	if (length &gt; maxBuckets)
 	{
 		length=maxBuckets;
@@ -2795,7 +2795,7 @@
 	memset(buckets, 0, sizeof(int)*length);
 	for (i=0; i&lt;sampleNum;i++)
 	{
-		u32 address=samples[i];
+		uint32_t address=samples[i];
 		long long a=address-min;
 		long long b=length-1;
 		long long c=addressSpace-1;
@@ -2861,7 +2861,7 @@
 	command_print(cmd_ctx, &quot;Starting profiling. Halting and resuming the target as often as we can...&quot;);
 
 	static const int maxSample=10000;
-	u32 *samples=malloc(sizeof(u32)*maxSample);
+	uint32_t *samples=malloc(sizeof(uint32_t)*maxSample);
 	if (samples==NULL)
 		return ERROR_OK;
 
@@ -2874,7 +2874,7 @@
 		target_poll(target);
 		if (target-&gt;state == TARGET_HALTED)
 		{
-			u32 t=*((u32 *)reg-&gt;value);
+			uint32_t t=*((uint32_t *)reg-&gt;value);
 			samples[numSamples++]=t;
 			retval = target_resume(target, 1, 0, 0, 0); /* current pc, addr = 0, do not handle breakpoints, not debugging */
 			target_poll(target);
@@ -2926,7 +2926,7 @@
 	return ERROR_OK;
 }
 
-static int new_int_array_element(Jim_Interp * interp, const char *varname, int idx, u32 val)
+static int new_int_array_element(Jim_Interp * interp, const char *varname, int idx, uint32_t val)
 {
 	char *namebuf;
 	Jim_Obj *nameObjPtr, *valObjPtr;
@@ -2978,15 +2978,15 @@
 static int target_mem2array(Jim_Interp *interp, target_t *target, int argc, Jim_Obj *const *argv)
 {
 	long l;
-	u32 width;
+	uint32_t width;
 	int len;
-	u32 addr;
-	u32 count;
-	u32 v;
+	uint32_t addr;
+	uint32_t count;
+	uint32_t v;
 	const char *varname;
 	uint8_t buffer[4096];
 	int  n, e, retval;
-	u32 i;
+	uint32_t i;
 
 	/* argv[1] = name of array to receive the data
 	 * argv[2] = desired width
@@ -3107,7 +3107,7 @@
 	return JIM_OK;
 }
 
-static int get_int_array_element(Jim_Interp * interp, const char *varname, int idx, u32 *val)
+static int get_int_array_element(Jim_Interp * interp, const char *varname, int idx, uint32_t *val)
 {
 	char *namebuf;
 	Jim_Obj *nameObjPtr, *valObjPtr;
@@ -3160,15 +3160,15 @@
 static int target_array2mem(Jim_Interp *interp, target_t *target, int argc, Jim_Obj *const *argv)
 {
 	long l;
-	u32 width;
+	uint32_t width;
 	int len;
-	u32 addr;
-	u32 count;
-	u32 v;
+	uint32_t addr;
+	uint32_t count;
+	uint32_t v;
 	const char *varname;
 	uint8_t buffer[4096];
 	int  n, e, retval;
-	u32 i;
+	uint32_t i;
 
 	/* argv[1] = name of array to get the data
 	 * argv[2] = desired width
@@ -4309,7 +4309,7 @@
 
 struct FastLoad
 {
-	u32 address;
+	uint32_t address;
 	uint8_t *data;
 	int length;
 
@@ -4339,10 +4339,10 @@
 static int handle_fast_load_image_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	uint8_t *buffer;
-	u32 buf_cnt;
-	u32 image_size;
-	u32 min_address=0;
-	u32 max_address=0xffffffff;
+	uint32_t buf_cnt;
+	uint32_t image_size;
+	uint32_t min_address=0;
+	uint32_t max_address=0xffffffff;
 	int i;
 
 	image_t image;
@@ -4387,8 +4387,8 @@
 			break;
 		}
 
-		u32 offset=0;
-		u32 length=buf_cnt;
+		uint32_t offset=0;
+		uint32_t length=buf_cnt;
 
 
 		/* DANGER!!! beware of unsigned comparision here!!! */

Modified: trunk/src/target/target.h
===================================================================
--- trunk/src/target/target.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/target.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -97,8 +97,8 @@
 
 typedef struct working_area_s
 {
-	u32 address;
-	u32 size;
+	uint32_t address;
+	uint32_t size;
 	int free;
 	uint8_t *backup;
 	struct working_area_s **user;
@@ -122,12 +122,12 @@
 	target_event_action_t *event_action;
 
 	int reset_halt;						/* attempt resetting the CPU into the halted mode? */
-	u32 working_area;					/* working area (initialized RAM). Evaluated
+	uint32_t working_area;					/* working area (initialized RAM). Evaluated
 										 * upon first allocation from virtual/physical address. */
-	u32 working_area_virt;				/* virtual address */
-	u32 working_area_phys;				/* physical address */
-	u32 working_area_size;				/* size in bytes */
-	u32 backup_working_area;			/* whether the content of the working area has to be preserved */
+	uint32_t working_area_virt;				/* virtual address */
+	uint32_t working_area_phys;				/* physical address */
+	uint32_t working_area_size;				/* size in bytes */
+	uint32_t backup_working_area;			/* whether the content of the working area has to be preserved */
 	struct working_area_s *working_areas;/* list of allocated working areas */
 	enum target_debug_reason debug_reason;/* reason why the target entered debug state */
 	enum target_endianess endianness;	/* target endianess */
@@ -137,7 +137,7 @@
 	struct watchpoint_s *watchpoints;	/* list of watchpoints */
 	struct trace_s *trace_info;			/* generic trace information */
 	struct debug_msg_receiver_s *dbgmsg;/* list of debug message receivers */
-	u32 dbg_msg_enabled;				/* debug message status */
+	uint32_t dbg_msg_enabled;				/* debug message status */
 	void *arch_info;					/* architecture specific information */
 	struct target_s *next;				/* next target in list */
 
@@ -229,7 +229,7 @@
 extern int target_register_event_callback(int (*callback)(struct target_s *target, enum target_event event, void *priv), void *priv);
 extern int target_unregister_event_callback(int (*callback)(struct target_s *target, enum target_event event, void *priv), void *priv);
 extern int target_poll(target_t *target);
-extern int target_resume(target_t *target, int current, u32 address, int handle_breakpoints, int debug_execution);
+extern int target_resume(target_t *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
 extern int target_halt(target_t *target);
 extern int target_call_event_callbacks(target_t *target, enum target_event event);
 
@@ -312,7 +312,7 @@
  * This routine is a wrapper for target-&gt;type-&gt;step.
  */
 int target_step(struct target_s *target,
-		int current, u32 address, int handle_breakpoints);
+		int current, uint32_t address, int handle_breakpoints);
 /**
  * Run an algorithm on the @a target given.
  *
@@ -321,7 +321,7 @@
 extern int target_run_algorithm(struct target_s *target,
 		int num_mem_params, mem_param_t *mem_params,
 		int num_reg_params, reg_param_t *reg_param,
-		u32 entry_point, u32 exit_point,
+		uint32_t entry_point, uint32_t exit_point,
 		int timeout_ms, void *arch_info);
 
 /**
@@ -331,7 +331,7 @@
  * This routine is a wrapper for target-&gt;type-&gt;read_memory.
  */
 extern int target_read_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, uint8_t *buffer);
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 /**
  * Write @a count items of @a size bytes to the memory of @a target at
  * the @a address given.
@@ -339,7 +339,7 @@
  * This routine is wrapper for target-&gt;type-&gt;write_memory.
  */
 extern int target_write_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, uint8_t *buffer);
+		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 /**
  * Write @a count items of 4 bytes to the memory of @a target at
@@ -349,12 +349,12 @@
  * This routine is wrapper for target-&gt;type-&gt;bulk_write_memory.
  */
 extern int target_bulk_write_memory(struct target_s *target,
-		u32 address, u32 count, uint8_t *buffer);
+		uint32_t address, uint32_t count, uint8_t *buffer);
 
-extern int target_write_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer);
-extern int target_read_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer);
-extern int target_checksum_memory(struct target_s *target, u32 address, u32 size, u32* crc);
-extern int target_blank_check_memory(struct target_s *target, u32 address, u32 size, u32* blank);
+extern int target_write_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer);
+extern int target_read_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer);
+extern int target_checksum_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t* crc);
+extern int target_blank_check_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t* blank);
 extern int target_wait_state(target_t *target, enum target_state state, int ms);
 
 /* DANGER!!!!!
@@ -368,7 +368,7 @@
  * upon resuming or resetting the CPU.
  *
  */
-extern int target_alloc_working_area(struct target_s *target, u32 size, working_area_t **area);
+extern int target_alloc_working_area(struct target_s *target, uint32_t size, working_area_t **area);
 extern int target_free_working_area(struct target_s *target, working_area_t *area);
 extern int target_free_working_area_restore(struct target_s *target, working_area_t *area, int restore);
 extern void target_free_all_working_areas(struct target_s *target);
@@ -379,19 +379,19 @@
 extern target_event_callback_t *target_event_callbacks;
 extern target_timer_callback_t *target_timer_callbacks;
 
-extern u32 target_buffer_get_u32(target_t *target, const uint8_t *buffer);
+extern uint32_t target_buffer_get_u32(target_t *target, const uint8_t *buffer);
 extern uint16_t target_buffer_get_u16(target_t *target, const uint8_t *buffer);
 extern uint8_t  target_buffer_get_u8 (target_t *target, const uint8_t *buffer);
-extern void target_buffer_set_u32(target_t *target, uint8_t *buffer, u32 value);
+extern void target_buffer_set_u32(target_t *target, uint8_t *buffer, uint32_t value);
 extern void target_buffer_set_u16(target_t *target, uint8_t *buffer, uint16_t value);
 extern void target_buffer_set_u8 (target_t *target, uint8_t *buffer, uint8_t  value);
 
-int target_read_u32(struct target_s *target, u32 address, u32 *value);
-int target_read_u16(struct target_s *target, u32 address, uint16_t *value);
-int target_read_u8(struct target_s *target, u32 address, uint8_t *value);
-int target_write_u32(struct target_s *target, u32 address, u32 value);
-int target_write_u16(struct target_s *target, u32 address, uint16_t value);
-int target_write_u8(struct target_s *target, u32 address, uint8_t value);
+int target_read_u32(struct target_s *target, uint32_t address, uint32_t *value);
+int target_read_u16(struct target_s *target, uint32_t address, uint16_t *value);
+int target_read_u8(struct target_s *target, uint32_t address, uint8_t *value);
+int target_write_u32(struct target_s *target, uint32_t address, uint32_t value);
+int target_write_u16(struct target_s *target, uint32_t address, uint16_t value);
+int target_write_u8(struct target_s *target, uint32_t address, uint8_t value);
 
 /* Issues USER() statements with target state information */
 int target_arch_state(struct target_s *target);

Modified: trunk/src/target/target_request.c
===================================================================
--- trunk/src/target/target_request.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/target_request.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -37,7 +37,7 @@
 static command_t *target_request_cmd = NULL;
 static int charmsg_mode = 0;
 
-static int target_asciimsg(target_t *target, u32 length)
+static int target_asciimsg(target_t *target, uint32_t length)
 {
 	char *msg = malloc(CEIL(length + 1, 4) * 4);
 	debug_msg_receiver_t *c = target-&gt;dbgmsg;
@@ -63,13 +63,13 @@
 	return ERROR_OK;
 }
 
-static int target_hexmsg(target_t *target, int size, u32 length)
+static int target_hexmsg(target_t *target, int size, uint32_t length)
 {
 	uint8_t *data = malloc(CEIL(length * size, 4) * 4);
 	char line[128];
 	int line_len;
 	debug_msg_receiver_t *c = target-&gt;dbgmsg;
-	u32 i;
+	uint32_t i;
 
 	LOG_DEBUG(&quot;size: %i, length: %i&quot;, size, length);
 
@@ -113,7 +113,7 @@
 /* handle requests from the target received by a target specific
  * side-band channel (e.g. ARM7/9 DCC)
  */
-int target_request(target_t *target, u32 request)
+int target_request(target_t *target, uint32_t request)
 {
 	target_req_cmd_t target_req_cmd = request &amp; 0xff;
 

Modified: trunk/src/target/target_request.h
===================================================================
--- trunk/src/target/target_request.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/target_request.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -42,7 +42,7 @@
 	struct debug_msg_receiver_s *next;
 } debug_msg_receiver_t;
 
-extern int target_request(target_t *target, u32 request);
+extern int target_request(target_t *target, uint32_t request);
 extern int delete_debug_msg_receiver(struct command_context_s *cmd_ctx, target_t *target);
 extern int target_request_register_commands(struct command_context_s *cmd_ctx);
 

Modified: trunk/src/target/target_type.h
===================================================================
--- trunk/src/target/target_type.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/target_type.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -28,12 +28,12 @@
 	int (*arch_state)(struct target_s *target);
 
 	/* target request support */
-	int (*target_request_data)(struct target_s *target, u32 size, uint8_t *buffer);
+	int (*target_request_data)(struct target_s *target, uint32_t size, uint8_t *buffer);
 
 	/* halt will log a warning, but return ERROR_OK if the target is already halted. */
 	int (*halt)(struct target_s *target);
-	int (*resume)(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
-	int (*step)(struct target_s *target, int current, u32 address, int handle_breakpoints);
+	int (*resume)(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+	int (*step)(struct target_s *target, int current, uint32_t address, int handle_breakpoints);
 
 	/* target reset control. assert reset can be invoked when OpenOCD and
 	 * the target is out of sync.
@@ -72,28 +72,28 @@
 	* size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
 	* count: number of items of &lt;size&gt;
 	*/
-	int (*read_memory_imp)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+	int (*read_memory_imp)(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	/**
 	 * Target memory read callback.  Do @b not call this function
 	 * directly, use target_read_memory() instead.
 	 */
-	int (*read_memory)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-	int (*write_memory_imp)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+	int (*read_memory)(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*write_memory_imp)(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	/**
 	 * Target memory write callback.  Do @b not call this function
 	 * directly, use target_write_memory() instead.
 	 */
-	int (*write_memory)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+	int (*write_memory)(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 	/**
 	 * Write target memory in multiples of 4 bytes, optimized for
 	 * writing large quantities of data.  Do @b not call this
 	 * function directly, use target_bulk_write_memory() instead.
 	 */
-	int (*bulk_write_memory)(struct target_s *target, u32 address, u32 count, uint8_t *buffer);
+	int (*bulk_write_memory)(struct target_s *target, uint32_t address, uint32_t count, uint8_t *buffer);
 
-	int (*checksum_memory)(struct target_s *target, u32 address, u32 count, u32* checksum);
-	int (*blank_check_memory)(struct target_s *target, u32 address, u32 count, u32* blank);
+	int (*checksum_memory)(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum);
+	int (*blank_check_memory)(struct target_s *target, uint32_t address, uint32_t count, uint32_t* blank);
 
 	/*
 	 * target break-/watchpoint control
@@ -119,12 +119,12 @@
 	int (*remove_watchpoint)(struct target_s *target, watchpoint_t *watchpoint);
 
 	/* target algorithm support */
-	int (*run_algorithm_imp)(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info);
+	int (*run_algorithm_imp)(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
 	/**
 	 * Target algorithm support.  Do @b not call this method directly,
 	 * use target_run_algorithm() instead.
 	 */
-	int (*run_algorithm)(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info);
+	int (*run_algorithm)(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
 
 	int (*register_commands)(struct command_context_s *cmd_ctx);
 
@@ -155,7 +155,7 @@
 	int (*init_target)(struct command_context_s *cmd_ctx, struct target_s *target);
 	int (*quit)(void);
 
-	int (*virt2phys)(struct target_s *target, u32 address, u32 *physical);
+	int (*virt2phys)(struct target_s *target, uint32_t address, uint32_t *physical);
 	int (*mmu)(struct target_s *target, int *enabled);
 
 };

Modified: trunk/src/target/trace.c
===================================================================
--- trunk/src/target/trace.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/trace.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -25,7 +25,7 @@
 #include &quot;trace.h&quot;
 #include &quot;target.h&quot;
 
-int trace_point(target_t *target, u32 number)
+int trace_point(target_t *target, uint32_t number)
 {
 	trace_t *trace = target-&gt;trace_info;
 
@@ -54,7 +54,7 @@
 	
 	if (argc == 0)
 	{
-		u32 i;
+		uint32_t i;
 		
 		for (i = 0; i &lt; trace-&gt;num_trace_points; i++)
 		{
@@ -113,15 +113,15 @@
 			free(trace-&gt;trace_history);
 		
 		trace-&gt;trace_history_size = strtoul(args[0], NULL, 0);
-		trace-&gt;trace_history = malloc(sizeof(u32) * trace-&gt;trace_history_size);
+		trace-&gt;trace_history = malloc(sizeof(uint32_t) * trace-&gt;trace_history_size);
 		
 		command_print(cmd_ctx, &quot;new trace history size: %i&quot;, trace-&gt;trace_history_size);
 	}
 	else
 	{
-		u32 i;
-		u32 first = 0;
-		u32 last = trace-&gt;trace_history_pos;
+		uint32_t i;
+		uint32_t first = 0;
+		uint32_t last = trace-&gt;trace_history_pos;
 
 		if ( !trace-&gt;trace_history_size ) {
 			command_print(cmd_ctx, &quot;trace history buffer is not allocated&quot;);
@@ -137,7 +137,7 @@
 		{
 			if (trace-&gt;trace_history[i % trace-&gt;trace_history_size] &lt; trace-&gt;num_trace_points)
 			{
-				u32 address;
+				uint32_t address;
 				address = trace-&gt;trace_points[trace-&gt;trace_history[i % trace-&gt;trace_history_size]].address;
 				command_print(cmd_ctx, &quot;trace point %i: 0x%8.8x&quot;,
 					trace-&gt;trace_history[i % trace-&gt;trace_history_size],

Modified: trunk/src/target/trace.h
===================================================================
--- trunk/src/target/trace.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/trace.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -27,18 +27,18 @@
 
 typedef struct trace_point_s
 {
-	u32 address;
+	uint32_t address;
 	u64 hit_counter;
 } trace_point_t;
 
 typedef struct trace_s
 {
-	u32 num_trace_points;
-	u32 trace_points_size;
+	uint32_t num_trace_points;
+	uint32_t trace_points_size;
 	trace_point_t *trace_points;
-	u32 trace_history_size;
-	u32 *trace_history;
-	u32 trace_history_pos;
+	uint32_t trace_history_size;
+	uint32_t *trace_history;
+	uint32_t trace_history_pos;
 	int trace_history_overflowed;
 } trace_t;
 
@@ -51,7 +51,7 @@
 	TRACE_OVERFLOWED = 0x8,
 } trace_status_t;
 
-extern int trace_point(struct target_s *target, u32 number);
+extern int trace_point(struct target_s *target, uint32_t number);
 extern int trace_register_commands(struct command_context_s *cmd_ctx);
 
 #define ERROR_TRACE_IMAGE_UNAVAILABLE		-(1500)

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/xscale.c	2009-06-18 07:09:35 UTC (rev 2279)
@@ -43,8 +43,8 @@
 int xscale_arch_state(struct target_s *target);
 int xscale_poll(target_t *target);
 int xscale_halt(target_t *target);
-int xscale_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
-int xscale_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
+int xscale_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+int xscale_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints);
 int xscale_debug_entry(target_t *target);
 int xscale_restore_context(target_t *target);
 
@@ -52,14 +52,14 @@
 int xscale_deassert_reset(target_t *target);
 int xscale_soft_reset_halt(struct target_s *target);
 
-int xscale_set_reg_u32(reg_t *reg, u32 value);
+int xscale_set_reg_u32(reg_t *reg, uint32_t value);
 
 int xscale_read_core_reg(struct target_s *target, int num, enum armv4_5_mode mode);
-int xscale_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, u32 value);
+int xscale_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, uint32_t value);
 
-int xscale_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int xscale_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int xscale_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
+int xscale_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int xscale_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int xscale_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer);
 
 int xscale_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
 int xscale_remove_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
@@ -69,7 +69,7 @@
 int xscale_remove_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
 void xscale_enable_watchpoints(struct target_s *target);
 void xscale_enable_breakpoints(struct target_s *target);
-static int xscale_virt2phys(struct target_s *target, u32 virtual, u32 *physical);
+static int xscale_virt2phys(struct target_s *target, uint32_t virtual, uint32_t *physical);
 static int xscale_mmu(struct target_s *target, int *enabled);
 
 int xscale_read_trace(target_t *target);
@@ -195,7 +195,7 @@
 	return ERROR_OK;
 }
 
-int xscale_jtag_set_instr(jtag_tap_t *tap, u32 new_instr)
+int xscale_jtag_set_instr(jtag_tap_t *tap, uint32_t new_instr)
 {
 	if (tap==NULL)
 		return ERROR_FAIL;
@@ -295,10 +295,10 @@
 
 static void xscale_getbuf(uint8_t *in)
 {
-	*((u32 *)in)=buf_get_u32(in, 0, 32);
+	*((uint32_t *)in)=buf_get_u32(in, 0, 32);
 }
 
-int xscale_receive(target_t *target, u32 *buffer, int num_words)
+int xscale_receive(target_t *target, uint32_t *buffer, int num_words)
 {
 	if (num_words==0)
 		return ERROR_INVALID_ARGUMENTS;
@@ -313,7 +313,7 @@
 	uint8_t *field0 = malloc(num_words * 1);
 	uint8_t field0_check_value = 0x2;
 	uint8_t field0_check_mask = 0x6;
-	u32 *field1 = malloc(num_words * 4);
+	uint32_t *field1 = malloc(num_words * 4);
 	uint8_t field2_check_value = 0x0;
 	uint8_t field2_check_mask = 0x1;
 	int words_done = 0;
@@ -608,7 +608,7 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u32 t[3];
+	uint32_t t[3];
 	int bits[3];
 
 	int retval;
@@ -671,7 +671,7 @@
 	return ERROR_OK;
 }
 
-int xscale_send_u32(target_t *target, u32 value)
+int xscale_send_u32(target_t *target, uint32_t value)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
@@ -754,7 +754,7 @@
 	return (0x6996 &gt;&gt; v) &amp; 1;
 }
 
-int xscale_load_ic(target_t *target, int mini, u32 va, u32 buffer[8])
+int xscale_load_ic(target_t *target, int mini, uint32_t va, uint32_t buffer[8])
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
@@ -812,8 +812,8 @@
 	{
 		buf_set_u32(packet, 0, 32, buffer[word]);
 
-		u32 value;
-		memcpy(&amp;value, packet, sizeof(u32));
+		uint32_t value;
+		memcpy(&amp;value, packet, sizeof(uint32_t));
 		cmd = parity(value);
 
 		jtag_add_dr_scan(2, fields, jtag_get_end_state());
@@ -824,7 +824,7 @@
 	return ERROR_OK;
 }
 
-int xscale_invalidate_ic_line(target_t *target, u32 va)
+int xscale_invalidate_ic_line(target_t *target, uint32_t va)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
@@ -874,7 +874,7 @@
 	int i;
 	int retval;
 
-	u32 low_reset_branch, high_reset_branch;
+	uint32_t low_reset_branch, high_reset_branch;
 
 	for (i = 1; i &lt; 8; i++)
 	{
@@ -1018,12 +1018,12 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u32 pc;
-	u32 buffer[10];
+	uint32_t pc;
+	uint32_t buffer[10];
 	int i;
 	int retval;
 
-	u32 moe;
+	uint32_t moe;
 
 	/* clear external dbg break (will be written on next DCSR read) */
 	xscale-&gt;external_debug_break = 0;
@@ -1157,7 +1157,7 @@
 	/* on the first debug entry, identify cache type */
 	if (xscale-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
-		u32 cache_type_reg;
+		uint32_t cache_type_reg;
 
 		/* read cp15 cache type register */
 		xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CACHETYPE]);
@@ -1230,7 +1230,7 @@
 	return ERROR_OK;
 }
 
-int xscale_enable_single_step(struct target_s *target, u32 next_pc)
+int xscale_enable_single_step(struct target_s *target, uint32_t next_pc)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale= armv4_5-&gt;arch_info;
@@ -1271,13 +1271,13 @@
 	return ERROR_OK;
 }
 
-int xscale_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
+int xscale_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale= armv4_5-&gt;arch_info;
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 
-	u32 current_pc;
+	uint32_t current_pc;
 
 	int retval;
 	int i;
@@ -1317,7 +1317,7 @@
 	{
 		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))))
 		{
-			u32 next_pc;
+			uint32_t next_pc;
 
 			/* there's a breakpoint at the current PC, we have to step over it */
 			LOG_DEBUG(&quot;unset breakpoint at 0x%8.8x&quot;, breakpoint-&gt;address);
@@ -1326,7 +1326,7 @@
 			/* calculate PC of next instruction */
 			if ((retval = arm_simulate_step(target, &amp;next_pc)) != ERROR_OK)
 			{
-				u32 current_opcode;
+				uint32_t current_opcode;
 				target_read_u32(target, current_pc, &amp;current_opcode);
 				LOG_ERROR(&quot;BUG: couldn't calculate PC of next instruction, current opcode was 0x%8.8x&quot;, current_opcode);
 			}
@@ -1427,12 +1427,12 @@
 	return ERROR_OK;
 }
 
-static int xscale_step_inner(struct target_s *target, int current, u32 address, int handle_breakpoints)
+static int xscale_step_inner(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 
-	u32 next_pc;
+	uint32_t next_pc;
 	int retval;
 	int i;
 
@@ -1441,7 +1441,7 @@
 	/* calculate PC of next instruction */
 	if ((retval = arm_simulate_step(target, &amp;next_pc)) != ERROR_OK)
 	{
-		u32 current_opcode, current_pc;
+		uint32_t current_opcode, current_pc;
 		current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 
 		target_read_u32(target, current_pc, &amp;current_opcode);
@@ -1507,12 +1507,12 @@
 	return ERROR_OK;
 }
 
-int xscale_step(struct target_s *target, int current, u32 address, int handle_breakpoints)
+int xscale_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 
-	u32 current_pc;
+	uint32_t current_pc;
 	int retval;
 
 	if (target-&gt;state != TARGET_HALTED)
@@ -1609,11 +1609,11 @@
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 
 	fileio_t debug_handler;
-	u32 address;
-	u32 binary_size;
+	uint32_t address;
+	uint32_t binary_size;
 
-	u32 buf_cnt;
-	u32 i;
+	uint32_t buf_cnt;
+	uint32_t i;
 	int retval;
 
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
@@ -1677,7 +1677,7 @@
 		address = xscale-&gt;handler_address;
 		while (binary_size &gt; 0)
 		{
-			u32 cache_line[8];
+			uint32_t cache_line[8];
 			uint8_t buffer[32];
 
 			if ((retval = fileio_read(&amp;debug_handler, 32, buffer, &amp;buf_cnt)) != ERROR_OK)
@@ -1687,7 +1687,7 @@
 
 			for (i = 0; i &lt; buf_cnt; i += 4)
 			{
-				/* convert LE buffer to host-endian u32 */
+				/* convert LE buffer to host-endian uint32_t */
 				cache_line[i / 4] = le_to_h_u32(&amp;buffer[i]);
 			}
 
@@ -1754,7 +1754,7 @@
 	return ERROR_OK;
 }
 
-int xscale_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, u32 value)
+int xscale_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, uint32_t value)
 {
 
 	return ERROR_OK;
@@ -1764,7 +1764,7 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 
-	u32 *buffer;
+	uint32_t *buffer;
 
 	int i, j;
 
@@ -1796,7 +1796,7 @@
 
 		if (!valid)
 		{
-			u32 tmp_cpsr;
+			uint32_t tmp_cpsr;
 
 			/* request banked registers */
 			xscale_send_u32(target, 0x0);
@@ -1875,7 +1875,7 @@
 
 		if (dirty)
 		{
-			u32 tmp_cpsr;
+			uint32_t tmp_cpsr;
 
 			/* send banked registers */
 			xscale_send_u32(target, 0x1);
@@ -1905,12 +1905,12 @@
 	return ERROR_OK;
 }
 
-int xscale_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int xscale_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u32 *buf32;
-	u32 i;
+	uint32_t *buf32;
+	uint32_t i;
 	int retval;
 
 	LOG_DEBUG(&quot;address: 0x%8.8x, size: 0x%8.8x, count: 0x%8.8x&quot;, address, size, count);
@@ -1984,7 +1984,7 @@
 	return ERROR_OK;
 }
 
-int xscale_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int xscale_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
@@ -2062,16 +2062,16 @@
 	return ERROR_OK;
 }
 
-int xscale_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
+int xscale_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	return xscale_write_memory(target, address, 4, count, buffer);
 }
 
-u32 xscale_get_ttb(target_t *target)
+uint32_t xscale_get_ttb(target_t *target)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u32 ttb;
+	uint32_t ttb;
 
 	xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_TTB]);
 	ttb = buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_TTB].value, 0, 32);
@@ -2083,7 +2083,7 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL]);
@@ -2122,7 +2122,7 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	xscale_get_reg(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_CTRL]);
@@ -2164,7 +2164,7 @@
 
 	if (breakpoint-&gt;type == BKPT_HARD)
 	{
-		u32 value = breakpoint-&gt;address | 1;
+		uint32_t value = breakpoint-&gt;address | 1;
 		if (!xscale-&gt;ibcr0_used)
 		{
 			xscale_set_reg_u32(&amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_IBCR0], value);
@@ -2331,7 +2331,7 @@
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 	uint8_t enable=0;
 	reg_t *dbcon = &amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DBCON];
-	u32 dbcon_value = buf_get_u32(dbcon-&gt;value, 0, 32);
+	uint32_t dbcon_value = buf_get_u32(dbcon-&gt;value, 0, 32);
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -2412,7 +2412,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 	reg_t *dbcon = &amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DBCON];
-	u32 dbcon_value = buf_get_u32(dbcon-&gt;value, 0, 32);
+	uint32_t dbcon_value = buf_get_u32(dbcon-&gt;value, 0, 32);
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -2541,7 +2541,7 @@
 	target_t *target = arch_info-&gt;target;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u32 value = buf_get_u32(buf, 0, 32);
+	uint32_t value = buf_get_u32(buf, 0, 32);
 
 	/* DCSR, TX and RX are accessible via JTAG */
 	if (strcmp(reg-&gt;name, &quot;XSCALE_DCSR&quot;) == 0)
@@ -2581,7 +2581,7 @@
 }
 
 /* convenience wrapper to access XScale specific registers */
-int xscale_set_reg_u32(reg_t *reg, u32 value)
+int xscale_set_reg_u32(reg_t *reg, uint32_t value)
 {
 	uint8_t buf[4];
 
@@ -2590,7 +2590,7 @@
 	return xscale_set_reg(reg, buf);
 }
 
-int xscale_write_dcsr_sw(target_t *target, u32 value)
+int xscale_write_dcsr_sw(target_t *target, uint32_t value)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -2622,7 +2622,7 @@
 	 * 256 trace buffer entries
 	 * 2 checkpoint addresses
 	 */
-	u32 trace_buffer[258];
+	uint32_t trace_buffer[258];
 	int is_address[256];
 	int i, j;
 
@@ -2697,8 +2697,8 @@
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 	int i;
 	int section = -1;
-	u32 size_read;
-	u32 opcode;
+	uint32_t size_read;
+	uint32_t opcode;
 	int retval;
 
 	if (!xscale-&gt;trace.image)
@@ -2756,7 +2756,7 @@
 	return ERROR_OK;
 }
 
-int xscale_branch_address(xscale_trace_data_t *trace_data, int i, u32 *target)
+int xscale_branch_address(xscale_trace_data_t *trace_data, int i, uint32_t *target)
 {
 	/* if there are less than four entries prior to the indirect branch message
 	 * we can't extract the address */
@@ -2777,7 +2777,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 	int next_pc_ok = 0;
-	u32 next_pc = 0x0;
+	uint32_t next_pc = 0x0;
 	xscale_trace_data_t *trace_data = xscale-&gt;trace.data;
 	int retval;
 
@@ -3018,7 +3018,7 @@
 int xscale_init_arch_info(target_t *target, xscale_common_t *xscale, jtag_tap_t *tap, const char *variant)
 {
 	armv4_5_common_t *armv4_5;
-	u32 high_reset_branch, low_reset_branch;
+	uint32_t high_reset_branch, low_reset_branch;
 	int i;
 
 	armv4_5 = &amp;xscale-&gt;armv4_5_common;
@@ -3140,7 +3140,7 @@
 	armv4_5_common_t *armv4_5;
 	xscale_common_t *xscale;
 
-	u32 handler_address;
+	uint32_t handler_address;
 
 	if (argc &lt; 2)
 	{
@@ -3181,7 +3181,7 @@
 	armv4_5_common_t *armv4_5;
 	xscale_common_t *xscale;
 
-	u32 cache_clean_address;
+	uint32_t cache_clean_address;
 
 	if (argc &lt; 2)
 	{
@@ -3228,21 +3228,21 @@
 	return armv4_5_handle_cache_info_command(cmd_ctx, &amp;xscale-&gt;armv4_5_mmu.armv4_5_cache);
 }
 
-static int xscale_virt2phys(struct target_s *target, u32 virtual, u32 *physical)
+static int xscale_virt2phys(struct target_s *target, uint32_t virtual, uint32_t *physical)
 {
 	armv4_5_common_t *armv4_5;
 	xscale_common_t *xscale;
 	int retval;
 	int type;
-	u32 cb;
+	uint32_t cb;
 	int domain;
-	u32 ap;
+	uint32_t ap;
 
 	if ((retval = xscale_get_arch_pointers(target, &amp;armv4_5, &amp;xscale)) != ERROR_OK)
 	{
 		return retval;
 	}
-	u32 ret = armv4_5_mmu_translate_va(target, &amp;xscale-&gt;armv4_5_mmu, virtual, &amp;type, &amp;cb, &amp;domain, &amp;ap);
+	uint32_t ret = armv4_5_mmu_translate_va(target, &amp;xscale-&gt;armv4_5_mmu, virtual, &amp;type, &amp;cb, &amp;domain, &amp;ap);
 	if (type == -1)
 	{
 		return ret;
@@ -3388,7 +3388,7 @@
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	xscale_common_t *xscale;
-	u32 dcsr_value;
+	uint32_t dcsr_value;
 
 	if (xscale_get_arch_pointers(target, &amp;armv4_5, &amp;xscale) != ERROR_OK)
 	{
@@ -3603,7 +3603,7 @@
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
 		return ERROR_OK;
 	}
-	u32 reg_no = 0;
+	uint32_t reg_no = 0;
 	reg_t *reg = NULL;
 	if(argc &gt; 0)
 	{
@@ -3644,7 +3644,7 @@
 	}
 	if(argc == 1)
 	{
-		u32 value;
+		uint32_t value;
 
 		/* read cp15 control register */
 		xscale_get_reg(reg);
@@ -3654,7 +3654,7 @@
 	else if(argc == 2)
 	{
 
-		u32 value = strtoul(args[1], NULL, 0);
+		uint32_t value = strtoul(args[1], NULL, 0);
 
 		/* send CP write request (command 0x41) */
 		xscale_send_u32(target, 0x41);

Modified: trunk/src/target/xscale.h
===================================================================
--- trunk/src/target/xscale.h	2009-06-18 07:08:52 UTC (rev 2278)
+++ trunk/src/target/xscale.h	2009-06-18 07:09:35 UTC (rev 2279)
@@ -36,10 +36,10 @@
 
 	/* IR length and instructions */	
 	int ir_length;
-	u32 dbgrx;
-	u32 dbgtx;
-	u32 ldic;
-	u32 dcsr;
+	uint32_t dbgrx;
+	uint32_t dbgtx;
+	uint32_t ldic;
+	uint32_t dcsr;
 } xscale_jtag_t;
 
 enum xscale_debug_reason
@@ -65,9 +65,9 @@
 {
 	xscale_trace_entry_t *entries;
 	int depth;
-	u32 chkpt0;
-	u32 chkpt1;
-	u32 last_instruction;
+	uint32_t chkpt0;
+	uint32_t chkpt1;
+	uint32_t last_instruction;
 	struct xscale_trace_data_s *next;
 } xscale_trace_data_t;
 
@@ -79,7 +79,7 @@
 	int buffer_enabled;				/* whether trace buffer is enabled */
 	int buffer_fill;				/* maximum number of trace runs to read (-1 for wrap-around) */
 	int pc_ok;
-	u32 current_pc;
+	uint32_t current_pc;
 	armv4_5_state_t core_state;		/* current core state (ARM, Thumb, Jazelle) */
 } xscale_trace_t;
 
@@ -98,20 +98,20 @@
 	/* current state of the debug handler */
 	int handler_installed;
 	int handler_running;
-	u32 handler_address;
+	uint32_t handler_address;
 	
 	/* target-endian buffers with exception vectors */
-	u32 low_vectors[8];
-	u32 high_vectors[8];
+	uint32_t low_vectors[8];
+	uint32_t high_vectors[8];
 	
 	/* static low vectors */
 	uint8_t static_low_vectors_set;	/* bit field with static vectors set by the user */
 	uint8_t static_high_vectors_set; /* bit field with static vectors set by the user */
-	u32 static_low_vectors[8];
-	u32 static_high_vectors[8];
+	uint32_t static_low_vectors[8];
+	uint32_t static_high_vectors[8];
 
 	/* DCache cleaning */	
-	u32 cache_clean_address;
+	uint32_t cache_clean_address;
 	
 	/* whether hold_rst and ext_dbg_break should be set */
 	int hold_rst;
@@ -124,7 +124,7 @@
 	int ibcr_available;
 	int ibcr0_used;
 	int	ibcr1_used;
-	u32 arm_bkpt;
+	uint32_t arm_bkpt;
 	uint16_t thumb_bkpt;
 	
 	uint8_t vector_catch;
@@ -138,7 +138,7 @@
 	
 	/* MMU/Caches */
 	armv4_5_mmu_common_t armv4_5_mmu;
-	u32 cp15_control_reg;
+	uint32_t cp15_control_reg;
 	
 	/* possible future enhancements that go beyond XScale common stuff */
 	void *arch_info;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001062.html">[Openocd-svn] r2278 - trunk/src/target
</A></li>
	<LI>Next message: <A HREF="001064.html">[Openocd-svn] r2280 - trunk/src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1063">[ date ]</a>
              <a href="thread.html#1063">[ thread ]</a>
              <a href="subject.html#1063">[ subject ]</a>
              <a href="author.html#1063">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
