<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2372 - in trunk: src src/flash	src/flash/ocl/at91sam7x src/helper src/jtag	src/jtag/minidummy src/jtag/rlink src/jtag/zy1000 src/pld	src/server src/target src/xsvf testing/examples/cortex
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2372%20-%20in%20trunk%3A%20src%20src/flash%0A%09src/flash/ocl/at91sam7x%20src/helper%20src/jtag%0A%09src/jtag/minidummy%20src/jtag/rlink%20src/jtag/zy1000%20src/pld%0A%09src/server%20src/target%20src/xsvf%20testing/examples/cortex&In-Reply-To=%3C200906232244.n5NMiCrv019235%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001155.html">
   <LINK REL="Next"  HREF="001157.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2372 - in trunk: src src/flash	src/flash/ocl/at91sam7x src/helper src/jtag	src/jtag/minidummy src/jtag/rlink src/jtag/zy1000 src/pld	src/server src/target src/xsvf testing/examples/cortex</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2372%20-%20in%20trunk%3A%20src%20src/flash%0A%09src/flash/ocl/at91sam7x%20src/helper%20src/jtag%0A%09src/jtag/minidummy%20src/jtag/rlink%20src/jtag/zy1000%20src/pld%0A%09src/server%20src/target%20src/xsvf%20testing/examples/cortex&In-Reply-To=%3C200906232244.n5NMiCrv019235%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2372 - in trunk: src src/flash	src/flash/ocl/at91sam7x src/helper src/jtag	src/jtag/minidummy src/jtag/rlink src/jtag/zy1000 src/pld	src/server src/target src/xsvf testing/examples/cortex">zwelch at mail.berlios.de
       </A><BR>
    <I>Wed Jun 24 00:44:12 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001155.html">[Openocd-svn] r2371 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
</A></li>
        <LI>Next message: <A HREF="001157.html">[Openocd-svn] r2373 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target xsvf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1156">[ date ]</a>
              <a href="thread.html#1156">[ thread ]</a>
              <a href="subject.html#1156">[ subject ]</a>
              <a href="author.html#1156">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-24 00:42:54 +0200 (Wed, 24 Jun 2009)
New Revision: 2372

Modified:
   trunk/src/ecosboard.c
   trunk/src/flash/at91sam7.c
   trunk/src/flash/cfi.c
   trunk/src/flash/ecos.c
   trunk/src/flash/flash.c
   trunk/src/flash/flash.h
   trunk/src/flash/lpc2000.c
   trunk/src/flash/mflash.c
   trunk/src/flash/ocl.c
   trunk/src/flash/ocl/at91sam7x/main.c
   trunk/src/flash/ocl/at91sam7x/samflash.c
   trunk/src/flash/pic32mx.c
   trunk/src/flash/stm32x.c
   trunk/src/flash/str9x.c
   trunk/src/flash/tms470.c
   trunk/src/helper/binarybuffer.h
   trunk/src/helper/command.c
   trunk/src/helper/configuration.c
   trunk/src/helper/ioutil.c
   trunk/src/helper/jim.c
   trunk/src/helper/jim.h
   trunk/src/helper/log.c
   trunk/src/helper/options.c
   trunk/src/helper/time_support.c
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/commands.c
   trunk/src/jtag/commands.h
   trunk/src/jtag/core.c
   trunk/src/jtag/driver.c
   trunk/src/jtag/dummy.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/gw16012.c
   trunk/src/jtag/interface.h
   trunk/src/jtag/jlink.c
   trunk/src/jtag/minidummy/minidummy.c
   trunk/src/jtag/parport.c
   trunk/src/jtag/presto.c
   trunk/src/jtag/rlink/rlink.c
   trunk/src/jtag/tcl.c
   trunk/src/jtag/usbprog.c
   trunk/src/jtag/zy1000/jtag_minidriver.h
   trunk/src/jtag/zy1000/zy1000.c
   trunk/src/openocd.c
   trunk/src/pld/virtex2.c
   trunk/src/server/gdb_server.c
   trunk/src/server/httpd.c
   trunk/src/server/server.c
   trunk/src/server/telnet_server.c
   trunk/src/target/arm11_dbgtap.c
   trunk/src/target/arm720t.c
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm920t.c
   trunk/src/target/arm926ejs.c
   trunk/src/target/arm9tdmi.c
   trunk/src/target/arm_adi_v5.c
   trunk/src/target/arm_jtag.h
   trunk/src/target/armv4_5.c
   trunk/src/target/armv4_5.h
   trunk/src/target/armv7m.c
   trunk/src/target/cortex_m3.c
   trunk/src/target/embeddedice.c
   trunk/src/target/etb.c
   trunk/src/target/etm.c
   trunk/src/target/image.c
   trunk/src/target/mips32_dmaacc.c
   trunk/src/target/mips32_pracc.c
   trunk/src/target/mips_m4k.c
   trunk/src/target/target.c
   trunk/src/target/target.h
   trunk/src/target/xscale.c
   trunk/src/xsvf/xsvf.c
   trunk/testing/examples/cortex/test.c
Log:
- Fixes '=' whitespace
- Replace ')\(=\)\(\w\)' with ') \1 \2'.
- Replace '\(\w\)\(=\)(' with '\1 \2 ('.
- Replace '\(\w\)\(=\)\(\w\)' with '\1 \2 \3'.


Modified: trunk/src/ecosboard.c
===================================================================
--- trunk/src/ecosboard.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/ecosboard.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -975,13 +975,13 @@
 	}
 
 	mkdir(zylin_config_dir, 0777);
-	char *dirname=alloc_printf(&quot;%s/target&quot;, zylin_config_dir);
+	char *dirname = alloc_printf(&quot;%s/target&quot;, zylin_config_dir);
 	mkdir(dirname, 0777);
 	free(dirname);
-	dirname=alloc_printf(&quot;%s/board&quot;, zylin_config_dir);
+	dirname = alloc_printf(&quot;%s/board&quot;, zylin_config_dir);
 	mkdir(dirname, 0777);
 	free(dirname);
-	dirname=alloc_printf(&quot;%s/event&quot;, zylin_config_dir);
+	dirname = alloc_printf(&quot;%s/event&quot;, zylin_config_dir);
 	mkdir(dirname, 0777);
 	free(dirname);
 
@@ -1036,7 +1036,7 @@
 	if (logAllToSerial)
 	{
 		diag_printf(
-				 &quot;%s/logserial=1 =&gt; sending log output to serial port using \&quot;debug_level 3\&quot; as default.\n&quot;, zylin_config_dir);
+				 &quot;%s/logserial = 1 =&gt; sending log output to serial port using \&quot;debug_level 3\&quot; as default.\n&quot;, zylin_config_dir);
 		command_run_line(cmd_ctx, &quot;debug_level 3&quot;);
 	}
 

Modified: trunk/src/flash/at91sam7.c
===================================================================
--- trunk/src/flash/at91sam7.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/at91sam7.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -232,10 +232,10 @@
 		if (fmcn &gt; 0xFF)
 			fmcn = 0xFF;
 
-		/* Only allow fmcn=0 if clock period is &gt; 30 us = 33kHz. */
+		/* Only allow fmcn = 0 if clock period is &gt; 30 us = 33kHz. */
 		if (at91sam7_info-&gt;mck_freq &lt;= 33333ul)
 			fmcn = 0;
-		/* Only allow fws=0 if clock frequency is &lt; 30 MHz. */
+		/* Only allow fws = 0 if clock frequency is &lt; 30 MHz. */
 		if (at91sam7_info-&gt;mck_freq &gt; 30000000ul)
 			fws = 1;
 
@@ -550,7 +550,7 @@
 	/* calculate bank size  */
 	bank_size = sectors_num * pages_per_sector * page_size;
 
-	for (bnk=0; bnk&lt;banks_num; bnk++)
+	for (bnk = 0; bnk&lt;banks_num; bnk++)
 	{
 		if (bnk &gt; 0)
 		{
@@ -575,7 +575,7 @@
 
 		/* allocate sectors */
 		t_bank-&gt;sectors = malloc(sectors_num * sizeof(flash_sector_t));
-		for (sec=0; sec&lt;sectors_num; sec++)
+		for (sec = 0; sec&lt;sectors_num; sec++)
 		{
 			t_bank-&gt;sectors[sec].offset = sec * pages_per_sector * page_size;
 			t_bank-&gt;sectors[sec].size = pages_per_sector * page_size;
@@ -639,7 +639,7 @@
 	at91sam7_set_flash_mode(bank, FMR_TIMING_FLASH);
 
 	fast_check = 1;
-	for (nSector=0; nSector&lt;bank-&gt;num_sectors; nSector++)
+	for (nSector = 0; nSector&lt;bank-&gt;num_sectors; nSector++)
 	{
 		retval = target_blank_check_memory(target, bank-&gt;base+bank-&gt;sectors[nSector].offset,
 			bank-&gt;sectors[nSector].size, &amp;blank);
@@ -662,7 +662,7 @@
 	LOG_USER(&quot;Running slow fallback erase check - add working memory&quot;);
 
 	buffer = malloc(bank-&gt;sectors[0].size);
-	for (nSector=0; nSector&lt;bank-&gt;num_sectors; nSector++)
+	for (nSector = 0; nSector&lt;bank-&gt;num_sectors; nSector++)
 	{
 		bank-&gt;sectors[nSector].is_erased = 1;
 		retval = target_read_memory(target, bank-&gt;base+bank-&gt;sectors[nSector].offset, 4,
@@ -670,7 +670,7 @@
 		if (retval != ERROR_OK)
 			return retval;
 
-		for (nByte=0; nByte&lt;bank-&gt;sectors[nSector].size; nByte++)
+		for (nByte = 0; nByte&lt;bank-&gt;sectors[nSector].size; nByte++)
 		{
 			if (buffer[nByte] != 0xFF)
 			{
@@ -705,7 +705,7 @@
 	at91sam7_info-&gt;lockbits = (status &gt;&gt; 16);
 
 	at91sam7_info-&gt;num_lockbits_on = 0;
-	for (lock_pos=0; lock_pos&lt;bank-&gt;num_sectors; lock_pos++)
+	for (lock_pos = 0; lock_pos&lt;bank-&gt;num_sectors; lock_pos++)
 	{
 		if ( ((status &gt;&gt; (16+lock_pos))&amp;(0x0001)) == 1)
 		{
@@ -723,7 +723,7 @@
 	at91sam7_info-&gt;nvmbits = (status &gt;&gt; 8)&amp;0xFF;
 
 	at91sam7_info-&gt;num_nvmbits_on = 0;
-	for (gpnvm_pos=0; gpnvm_pos&lt;at91sam7_info-&gt;num_nvmbits; gpnvm_pos++)
+	for (gpnvm_pos = 0; gpnvm_pos&lt;at91sam7_info-&gt;num_nvmbits; gpnvm_pos++)
 	{
 		if ( ((status &gt;&gt; (8+gpnvm_pos))&amp;(0x01)) == 1)
 		{
@@ -809,7 +809,7 @@
 	/* calculate bank size  */
 	bank_size = num_sectors * pages_per_sector * page_size;
 
-	for (bnk=0; bnk&lt;banks_num; bnk++)
+	for (bnk = 0; bnk&lt;banks_num; bnk++)
 	{
 		if (bnk &gt; 0)
 		{
@@ -834,7 +834,7 @@
 
 		/* allocate sectors */
 		t_bank-&gt;sectors = malloc(num_sectors * sizeof(flash_sector_t));
-		for (sec=0; sec&lt;num_sectors; sec++)
+		for (sec = 0; sec&lt;num_sectors; sec++)
 		{
 			t_bank-&gt;sectors[sec].offset = sec * pages_per_sector * page_size;
 			t_bank-&gt;sectors[sec].size = pages_per_sector * page_size;
@@ -902,7 +902,7 @@
 		/* allocate and clean buffer  */
 		nbytes = (last - first + 1) * bank-&gt;sectors[first].size;
 		buffer = malloc(nbytes * sizeof(uint8_t));
-		for (pos=0; pos&lt;nbytes; pos++)
+		for (pos = 0; pos&lt;nbytes; pos++)
 		{
 			buffer[pos] = 0xFF;
 		}
@@ -916,7 +916,7 @@
 	}
 
 	/* mark erased sectors */
-	for (sec=first; sec &lt;= last; sec++)
+	for (sec = first; sec &lt;= last; sec++)
 	{
 		bank-&gt;sectors[sec].is_erased = 1;
 	}
@@ -952,7 +952,7 @@
 	at91sam7_read_clock_info(bank);
 	at91sam7_set_flash_mode(bank, FMR_TIMING_NVBITS);
 
-	for (sector=first; sector &lt;= last; sector++)
+	for (sector = first; sector &lt;= last; sector++)
 	{
 		if (set)
 			cmd = SLB;
@@ -1016,7 +1016,7 @@
 	at91sam7_read_clock_info(bank);
 	at91sam7_set_flash_mode(bank, FMR_TIMING_FLASH);
 
-	for (pagen=first_page; pagen&lt;last_page; pagen++)
+	for (pagen = first_page; pagen&lt;last_page; pagen++)
 	{
 		if (bytes_remaining&lt;dst_min_alignment)
 			count = bytes_remaining;

Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/cfi.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -212,7 +212,7 @@
 	if (cfi_info-&gt;x16_as_x8)
 	{
 		uint8_t i;
-		for (i=0;i&lt;2;i++)
+		for (i = 0;i&lt;2;i++)
 			target_read_memory(target, flash_address(bank, sector, offset+i), bank-&gt;bus_width, 1,
 				&amp;data[i*bank-&gt;bus_width] );
 	}
@@ -234,7 +234,7 @@
 	if (cfi_info-&gt;x16_as_x8)
 	{
 		uint8_t i;
-		for (i=0;i&lt;4;i++)
+		for (i = 0;i&lt;4;i++)
 			target_read_memory(target, flash_address(bank, sector, offset+i), bank-&gt;bus_width, 1,
 				&amp;data[i*bank-&gt;bus_width] );
 	}
@@ -1011,7 +1011,7 @@
 static void cfi_fix_code_endian(target_t *target, uint8_t *dest, const uint32_t *src, uint32_t count)
 {
 	uint32_t i;
-	for (i=0; i&lt; count; i++)
+	for (i = 0; i&lt; count; i++)
 	{
 		target_buffer_set_u32(target, dest, *src);
 		dest += 4;
@@ -1452,7 +1452,7 @@
 		cfi_fix_code_endian(target, target_code, src, target_code_size / 4);
 
 		/* allocate working area */
-		retval=target_alloc_working_area(target, target_code_size,
+		retval = target_alloc_working_area(target, target_code_size,
 				&amp;cfi_info-&gt;write_algorithm);
 		if (retval != ERROR_OK)
 		{
@@ -1987,7 +1987,7 @@
 						buffer += buffersize;
 						write_p += buffersize;
 						count -= buffersize;
-						fallback=0;
+						fallback = 0;
 					}
 				}
 				/* try the slow way? */

Modified: trunk/src/flash/ecos.c
===================================================================
--- trunk/src/flash/ecos.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/ecos.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -66,7 +66,7 @@
 	uint32_t start_address;
 } ecosflash_flash_bank_t;
 
-static const int sectorSize=0x10000;
+static const int sectorSize = 0x10000;
 
 char *
 flash_errmsg(int err);
@@ -145,7 +145,7 @@
 		exit(-1);
 	}
 	bank-&gt;driver_priv = info;
-	info-&gt;driverPath=strdup(args[6]);
+	info-&gt;driverPath = strdup(args[6]);
 
 	/* eCos flash sector sizes are not exposed to OpenOCD, use 0x10000 as
 	 * a way to improve impeadance matach between OpenOCD and eCos flash
@@ -153,7 +153,7 @@
 	 */
 	int i = 0;
 	uint32_t offset = 0;
-	bank-&gt;num_sectors=bank-&gt;size/sectorSize;
+	bank-&gt;num_sectors = bank-&gt;size/sectorSize;
 	bank-&gt;sectors = malloc(sizeof(flash_sector_t) * bank-&gt;num_sectors);
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
 	{
@@ -181,15 +181,15 @@
 
 	image.base_address_set = 0;
 	image.start_address_set = 0;
-	target_t *target=info-&gt;target;
+	target_t *target = info-&gt;target;
 	int retval;
 
-	if ((retval=image_open(&amp;image, info-&gt;driverPath, NULL)) != ERROR_OK)
+	if ((retval = image_open(&amp;image, info-&gt;driverPath, NULL)) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	info-&gt;start_address=image.start_address;
+	info-&gt;start_address = image.start_address;
 
 	image_size = 0x0;
 	int i;
@@ -215,12 +215,12 @@
 	return ERROR_OK;
 }
 
-static int const OFFSET_ERASE=0x0;
-static int const OFFSET_ERASE_SIZE=0x8;
-static int const OFFSET_FLASH=0xc;
-static int const OFFSET_FLASH_SIZE=0x8;
-static int const OFFSET_GET_WORKAREA=0x18;
-static int const OFFSET_GET_WORKAREA_SIZE=0x4;
+static int const OFFSET_ERASE = 0x0;
+static int const OFFSET_ERASE_SIZE = 0x8;
+static int const OFFSET_FLASH = 0xc;
+static int const OFFSET_FLASH_SIZE = 0x8;
+static int const OFFSET_GET_WORKAREA = 0x18;
+static int const OFFSET_GET_WORKAREA_SIZE = 0x4;
 
 static int runCode(ecosflash_flash_bank_t *info,
 		uint32_t codeStart, uint32_t codeStop, uint32_t r0, uint32_t r1, uint32_t r2,
@@ -228,7 +228,7 @@
 		/* timeout in ms */
 		int timeout)
 {
-	target_t *target=info-&gt;target;
+	target_t *target = info-&gt;target;
 
 	reg_param_t reg_params[3];
 	armv4_5_algorithm_t armv4_5_info;
@@ -254,7 +254,7 @@
 		return retval;
 	}
 
-	*result=buf_get_u32(reg_params[0].value, 0, 32);
+	*result = buf_get_u32(reg_params[0].value, 0, 32);
 
 	destroy_reg_param(&amp;reg_params[0]);
 	destroy_reg_param(&amp;reg_params[1]);
@@ -268,12 +268,12 @@
 	int retval;
 	int timeout = (len / 20480 + 1) * 1000; /*asume 20 KB/s*/
 
-	retval=loadDriver(info);
+	retval = loadDriver(info);
 	if (retval != ERROR_OK)
 		return retval;
 
 	uint32_t flashErr;
-	retval=runCode(info,
+	retval = runCode(info,
 			info-&gt;start_address+OFFSET_ERASE,
 			info-&gt;start_address+OFFSET_ERASE+OFFSET_ERASE_SIZE,
 			address,
@@ -296,17 +296,17 @@
 
 static int eCosBoard_flash(ecosflash_flash_bank_t *info, void *data, uint32_t address, uint32_t len)
 {
-	target_t *target=info-&gt;target;
-	const int chunk=8192;
-	int retval=ERROR_OK;
+	target_t *target = info-&gt;target;
+	const int chunk = 8192;
+	int retval = ERROR_OK;
 	int timeout = (chunk / 20480 + 1) * 1000; /*asume 20 KB/s + 1 second*/
 
-	retval=loadDriver(info);
+	retval = loadDriver(info);
 	if (retval != ERROR_OK)
 		return retval;
 
 	uint32_t buffer;
-	retval=runCode(info,
+	retval = runCode(info,
 			info-&gt;start_address+OFFSET_GET_WORKAREA,
 			info-&gt;start_address+OFFSET_GET_WORKAREA+OFFSET_GET_WORKAREA_SIZE,
 			0,
@@ -319,21 +319,21 @@
 
 
 	uint32_t i;
-	for (i=0; i&lt;len; i += chunk)
+	for (i = 0; i&lt;len; i += chunk)
 	{
-		int t=len-i;
+		int t = len-i;
 		if (t&gt;chunk)
 		{
-			t=chunk;
+			t = chunk;
 		}
 
 		int retval;
-		retval=target_write_buffer(target, buffer, t, ((uint8_t *)data)+i);
+		retval = target_write_buffer(target, buffer, t, ((uint8_t *)data)+i);
 		if (retval != ERROR_OK)
 			return retval;
 
 		uint32_t flashErr;
-		retval=runCode(info,
+		retval = runCode(info,
 				info-&gt;start_address+OFFSET_FLASH,
 				info-&gt;start_address+OFFSET_FLASH+OFFSET_FLASH_SIZE,
 				buffer,
@@ -408,7 +408,7 @@
 
 static int ecosflash_erase(struct flash_bank_s *bank, int first, int last)
 {
-	struct flash_bank_s *c=bank;
+	struct flash_bank_s *c = bank;
 	ecosflash_flash_bank_t *info = bank-&gt;driver_priv;
 	return eCosBoard_erase(info, c-&gt;base+first*sectorSize, sectorSize*(last-first+1));
 }
@@ -421,7 +421,7 @@
 static int ecosflash_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	ecosflash_flash_bank_t *info = bank-&gt;driver_priv;
-	struct flash_bank_s *c=bank;
+	struct flash_bank_s *c = bank;
 	return eCosBoard_flash(info, buffer, c-&gt;base+offset, count);
 }
 

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/flash.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -89,7 +89,7 @@
 {
 	int retval;
 
-	retval=bank-&gt;driver-&gt;write(bank, buffer, offset, count);
+	retval = bank-&gt;driver-&gt;write(bank, buffer, offset, count);
 	if (retval != ERROR_OK)
 	{
 		LOG_ERROR(&quot;error writing to flash at address 0x%08&quot; PRIx32 &quot; at offset 0x%8.8&quot; PRIx32 &quot; (%d)&quot;, 
@@ -103,7 +103,7 @@
 {
 	int retval;
 
-	retval=bank-&gt;driver-&gt;erase(bank, first, last);
+	retval = bank-&gt;driver-&gt;erase(bank, first, last);
 	if (retval != ERROR_OK)
 	{
 		LOG_ERROR(&quot;failed erasing sectors %d to %d (%d)&quot;, first, last, retval);
@@ -116,7 +116,7 @@
 {
 	int retval;
 
-	retval=bank-&gt;driver-&gt;protect(bank, set, first, last);
+	retval = bank-&gt;driver-&gt;protect(bank, set, first, last);
 	if (retval != ERROR_OK)
 	{
 		LOG_ERROR(&quot;failed setting protection for areas %d to %d (%d)&quot;, first, last, retval);
@@ -142,10 +142,10 @@
 		return JIM_ERR;
 	}
 
-	Jim_Obj *list=Jim_NewListObj(interp, NULL, 0);
+	Jim_Obj *list = Jim_NewListObj(interp, NULL, 0);
 	for (p = flash_banks; p; p = p-&gt;next)
 	{
-		Jim_Obj *elem=Jim_NewListObj(interp, NULL, 0);
+		Jim_Obj *elem = Jim_NewListObj(interp, NULL, 0);
 
 		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, &quot;name&quot;, -1));
 		Jim_ListAppendElement(interp, elem, Jim_NewStringObj(interp, p-&gt;driver-&gt;name, -1));
@@ -291,7 +291,7 @@
 			c-&gt;sectors = NULL;
 			c-&gt;next = NULL;
 
-			if ((retval=flash_drivers[i]-&gt;flash_bank_command(cmd_ctx, cmd, args, argc, c)) != ERROR_OK)
+			if ((retval = flash_drivers[i]-&gt;flash_bank_command(cmd_ctx, cmd, args, argc, c)) != ERROR_OK)
 			{
 				LOG_ERROR(&quot;'%s' driver rejected flash bank at 0x%8.8&quot; PRIx32 , args[0], c-&gt;base);
 				free(c);
@@ -754,13 +754,13 @@
 	switch (cmd[4])
 	{
 	case 'w':
-		wordsize=4;
+		wordsize = 4;
 		break;
 	case 'h':
-		wordsize=2;
+		wordsize = 2;
 		break;
 	case 'b':
-		wordsize=1;
+		wordsize = 1;
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -791,7 +791,7 @@
 
 	duration_start_measure(&amp;duration);
 
-	for (wrote=0; wrote&lt;(count*wordsize); wrote += cur_size)
+	for (wrote = 0; wrote&lt;(count*wordsize); wrote += cur_size)
 	{
 		cur_size = MIN( (count*wordsize - wrote), sizeof(chunk) );
 		flash_bank_t *bank;
@@ -809,7 +809,7 @@
 			return err;
 
 		unsigned i;
-		for (i=0; i&lt;cur_size; i++)
+		for (i = 0; i&lt;cur_size; i++)
 		{
 			if (readback[i]!=chunk[i])
 			{
@@ -829,7 +829,7 @@
 	if (err == ERROR_OK)
 	{
 		float speed;
-		speed=wrote / 1024.0;
+		speed = wrote / 1024.0;
 		speed/=((float)duration.duration.tv_sec + ((float)duration.duration.tv_usec / 1000000.0));
 		command_print(cmd_ctx, 
 					  &quot;wrote %&quot; PRId32 &quot; bytes to 0x%8.8&quot; PRIx32 &quot; in %s (%f kb/s)&quot;,
@@ -1003,7 +1003,7 @@
 /* write (optional verify) an image to flash memory of the given target */
 int flash_write(target_t *target, image_t *image, uint32_t *written, int erase)
 {
-	int retval=ERROR_OK;
+	int retval = ERROR_OK;
 
 	int section;
 	uint32_t section_offset;

Modified: trunk/src/flash/flash.h
===================================================================
--- trunk/src/flash/flash.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/flash.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -45,13 +45,13 @@
 	/// Number of bytes in this flash sector.
 	uint32_t size;
 	/**
-	 * Indication of erasure status: 0=not erased, 1=erased,
-	 * other=unknown.  Set by @c flash_driver_s::erase_check.
+	 * Indication of erasure status: 0 = not erased, 1 = erased,
+	 * other = unknown.  Set by @c flash_driver_s::erase_check.
 	 */
 	int is_erased;
 	/**
-	 * Indication of protection status: 0=unprotected/unlocked,
-	 * 1=protected/locked, other=unknown.  Set by
+	 * Indication of protection status: 0 = unprotected/unlocked,
+	 * 1 = protected/locked, other = unknown.  Set by
 	 * @c flash_driver_s::protect_check.
 	 */
 	int is_protected;

Modified: trunk/src/flash/lpc2000.c
===================================================================
--- trunk/src/flash/lpc2000.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/lpc2000.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -525,7 +525,7 @@
 		checksum = 0 - checksum;
 		LOG_DEBUG(&quot;checksum: 0x%8.8&quot; PRIx32, checksum);
 
-		uint32_t original_value=buf_get_u32(buffer + (5 * 4), 0, 32);
+		uint32_t original_value = buf_get_u32(buffer + (5 * 4), 0, 32);
 		if (original_value != checksum)
 		{
 			LOG_WARNING(&quot;Verification will fail since checksum in image(0x%8.8&quot; PRIx32 &quot;) written to flash was different from calculated vector checksum(0x%8.8&quot; PRIx32 &quot;).&quot;,

Modified: trunk/src/flash/mflash.c
===================================================================
--- trunk/src/flash/mflash.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/mflash.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -217,7 +217,7 @@
 	uint32_t mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
 	duration_t duration;
 	int ret;
-	long long t=0;
+	long long t = 0;
 
 	duration_start_measure(&amp;duration);
 
@@ -277,7 +277,7 @@
 
 		duration_stop_measure(&amp;duration, NULL);
 
-		t=duration.duration.tv_usec/1000;
+		t = duration.duration.tv_usec/1000;
 		t += duration.duration.tv_sec*1000;
 
 		if (t &gt; time)
@@ -871,7 +871,7 @@
 {
 	int i, M;
 
-	for (i = 1, M=0; i &lt; 512; i &lt;&lt;= 1, feedback_div &gt;&gt;= 1)
+	for (i = 1, M = 0; i &lt; 512; i &lt;&lt;= 1, feedback_div &gt;&gt;= 1)
 		M += (feedback_div &amp; 1) * i;
 
 	return M + 2;

Modified: trunk/src/flash/ocl/at91sam7x/main.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/main.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/ocl/at91sam7x/main.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -39,19 +39,19 @@
 	int pagenum;
 	int result;
 
-	adr=dcc_rd();
-	len=cmd&amp;0xffff;
-	ofs=adr%flash_page_size;
-	bi_start=ofs/4;
-	bi_end=(ofs+len+3)/4;
+	adr = dcc_rd();
+	len = cmd&amp;0xffff;
+	ofs = adr%flash_page_size;
+	bi_start = ofs/4;
+	bi_end = (ofs+len+3)/4;
 
 	if (bi_end&gt;BUFSIZE) {
 		dcc_wr(OCL_BUFF_OVER);
 		return;
 	}
 
-	chksum=OCL_CHKS_INIT;
-	for (bi=0; bi&lt;bi_end; bi++) chksum^=buffer[bi]=dcc_rd();
+	chksum = OCL_CHKS_INIT;
+	for (bi = 0; bi&lt;bi_end; bi++) chksum^=buffer[bi]=dcc_rd();
 
 	if (dcc_rd() != chksum) {
 		dcc_wr(OCL_CHKS_FAIL);
@@ -59,18 +59,18 @@
 	}
 
 	/* fill in unused positions with unprogrammed values */
-	for (bi=0; bi&lt;bi_start; bi++) buffer[bi]=0xffffffff;
-	for (bi=bi_end; bi%flash_page_size; bi++) buffer[bi]=0xffffffff;
+	for (bi = 0; bi&lt;bi_start; bi++) buffer[bi]=0xffffffff;
+	for (bi = bi_end; bi%flash_page_size; bi++) buffer[bi]=0xffffffff;
 
-	result=0;
-	pagenum=adr/flash_page_size;
-	for (bi=0; bi&lt;bi_end; bi += flash_page_size/4) {
-		result=flash_page_program(buffer+bi, pagenum++);
+	result = 0;
+	pagenum = adr/flash_page_size;
+	for (bi = 0; bi&lt;bi_end; bi += flash_page_size/4) {
+		result = flash_page_program(buffer+bi, pagenum++);
 		if (result) break;
 	}
 
 	/* verify written data */
-	if (!result) result=flash_verify(adr, len, ((uint8 *)buffer)+ofs);
+	if (!result) result = flash_verify(adr, len, ((uint8 *)buffer)+ofs);
 
 	dcc_wr(OCL_CMD_DONE|result);
 }
@@ -81,7 +81,7 @@
 	uint32 cmd;
 
 	for (;;) {
-		cmd=dcc_rd();
+		cmd = dcc_rd();
 		switch (cmd&amp;OCL_CMD_MASK) {
 			case OCL_PROBE:
 				dcc_wr(OCL_CMD_DONE|flash_init());

Modified: trunk/src/flash/ocl/at91sam7x/samflash.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -20,11 +20,11 @@
 #include &quot;samflash.h&quot;
 
 
-unsigned int flash_page_count=1024;
-unsigned int flash_page_size=256;
+unsigned int flash_page_count = 1024;
+unsigned int flash_page_size = 256;
 
 /* pages per lock bit */
-unsigned int flash_lock_pages=1024/16;
+unsigned int flash_lock_pages = 1024/16;
 
 
 /* detect chip and set loader parameters */
@@ -32,38 +32,38 @@
 {
 	unsigned int nvpsiz;
 
-	nvpsiz=(inr(DBGU_CIDR) &gt;&gt; 8)&amp;0xf;
+	nvpsiz = (inr(DBGU_CIDR) &gt;&gt; 8)&amp;0xf;
 
 	switch (nvpsiz) {
 		case 3:
 			/* AT91SAM7x32 */
-			flash_page_count=256;
-			flash_page_size=128;
-			flash_lock_pages=256/8;
+			flash_page_count = 256;
+			flash_page_size = 128;
+			flash_lock_pages = 256/8;
 			break;
 		case 5:
 			/* AT91SAM7x64 */
-			flash_page_count=512;
-			flash_page_size=128;
-			flash_lock_pages=512/16;
+			flash_page_count = 512;
+			flash_page_size = 128;
+			flash_lock_pages = 512/16;
 			break;
 		case 7:
 			/* AT91SAM7x128*/
-			flash_page_count=512;
-			flash_page_size=256;
-			flash_lock_pages=512/8;
+			flash_page_count = 512;
+			flash_page_size = 256;
+			flash_lock_pages = 512/8;
 			break;
 		case 9:
 			/* AT91SAM7x256 */
-			flash_page_count=1024;
-			flash_page_size=256;
-			flash_lock_pages=1024/16;
+			flash_page_count = 1024;
+			flash_page_size = 256;
+			flash_lock_pages = 1024/16;
 			break;
 		case 10:
 			/* AT91SAM7x512 */
-			flash_page_count=2048;
-			flash_page_size=256;
-			flash_lock_pages=2048/32;
+			flash_page_count = 2048;
+			flash_page_size = 256;
+			flash_lock_pages = 2048/32;
 			break;
 		default:
 			return FLASH_STAT_INITE;
@@ -82,19 +82,19 @@
 	uint32 *data_ptr;
 
 	/* select proper controller */
-	if (page_num &gt;= 1024) efc_ofs=0x10;
-	else efc_ofs=0;
+	if (page_num &gt;= 1024) efc_ofs = 0x10;
+	else efc_ofs = 0;
 
 	/* wait until FLASH is ready, just for sure */
 	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* calculate page address, only lower 8 bits are used to address the latch,
 		 but the upper part of address is needed for writing to proper EFC */
-	flash_ptr=(uint32 *)(FLASH_AREA_ADDR+(page_num*flash_page_size));
-	data_ptr=data;
+	flash_ptr = (uint32 *)(FLASH_AREA_ADDR+(page_num*flash_page_size));
+	data_ptr = data;
 
 	/* copy data to latch */
-	for (i=flash_page_size/4; i; i--) {
+	for (i = flash_page_size/4; i; i--) {
 		/* we do not use memcpy to be sure that only 32 bit access is used */
 		*(flash_ptr++)=*(data_ptr++);
 	}
@@ -111,10 +111,10 @@
 
 #if 0
 	/* verify written data */
-	flash_ptr=(uint32 *)(FLASH_AREA_ADDR+(page_num*flash_page_size));
-	data_ptr=data;
+	flash_ptr = (uint32 *)(FLASH_AREA_ADDR+(page_num*flash_page_size));
+	data_ptr = data;
 
-	for (i=flash_page_size/4; i; i--) {
+	for (i = flash_page_size/4; i; i--) {
 		if (*(flash_ptr++)!=*(data_ptr++)) return FLASH_STAT_VERIFE;
 	}
 #endif
@@ -128,8 +128,8 @@
 	unsigned int lockbits;
 	int page_num;
 
-	page_num=0;
-	lockbits=inr(MC_FSR+efc_ofs) &gt;&gt; 16;
+	page_num = 0;
+	lockbits = inr(MC_FSR+efc_ofs) &gt;&gt; 16;
 	while (lockbits) {
 		if (lockbits&amp;1) {
 
@@ -175,10 +175,10 @@
 {
 	int result;
 	
-	if ((result=flash_erase_plane(0)) != FLASH_STAT_OK) return result;
+	if ((result = flash_erase_plane(0)) != FLASH_STAT_OK) return result;
 
 	/* the second flash controller, if any */
-	if (flash_page_count&gt;1024) result=flash_erase_plane(0x10);
+	if (flash_page_count&gt;1024) result = flash_erase_plane(0x10);
 
 	return result;
 }
@@ -188,7 +188,7 @@
 {
 	unsigned char *flash_ptr;
 
-	flash_ptr=(uint8 *)FLASH_AREA_ADDR+adr;
+	flash_ptr = (uint8 *)FLASH_AREA_ADDR+adr;
 	for ( ;len; len--) {
 		if (*(flash_ptr++)!=*(src++)) return FLASH_STAT_VERIFE;
 	}

Modified: trunk/src/flash/ocl.c
===================================================================
--- trunk/src/flash/ocl.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/ocl.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -200,7 +200,7 @@
 		chksum = OCL_CHKS_INIT;
 
 		/* copy data to DCC buffer in proper byte order and properly aligned */
-		for (i=0; i&lt;runlen; i++)
+		for (i = 0; i&lt;runlen; i++)
 		{
 			switch (byteofs++)
 			{
@@ -332,7 +332,7 @@
 		return ERROR_FLASH_BANK_INVALID;
 	}
 	sectsize = bank-&gt;size / bank-&gt;num_sectors;
-	for (i=0; i&lt;bank-&gt;num_sectors; i++)
+	for (i = 0; i&lt;bank-&gt;num_sectors; i++)
 	{
 		bank-&gt;sectors[i].offset = i * sectsize;
 		bank-&gt;sectors[i].size = sectsize;

Modified: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/pic32mx.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -388,7 +388,7 @@
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	if ((retval=target_write_buffer(target, pic32mx_info-&gt;write_algorithm-&gt;address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code)) != ERROR_OK)
+	if ((retval = target_write_buffer(target, pic32mx_info-&gt;write_algorithm-&gt;address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code)) != ERROR_OK)
 		return retval;
 #endif
 
@@ -435,12 +435,12 @@
 #endif
 		status = pic32mx_write_row(bank, address, source-&gt;address);
 		if ( status &amp; NVMCON_NVMERR ) {
-			LOG_ERROR(&quot;Flash write error NVMERR (status=0x%08&quot; PRIx32 &quot;)&quot;, status);
+			LOG_ERROR(&quot;Flash write error NVMERR (status = 0x%08&quot; PRIx32 &quot;)&quot;, status);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 		if ( status &amp; NVMCON_LVDERR ) {
-			LOG_ERROR(&quot;Flash write error LVDERR (status=0x%08&quot; PRIx32 &quot;)&quot;, status);
+			LOG_ERROR(&quot;Flash write error LVDERR (status = 0x%08&quot; PRIx32 &quot;)&quot;, status);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
@@ -459,12 +459,12 @@
 
 		uint32_t status = pic32mx_write_word(bank, address, value);
 		if ( status &amp; NVMCON_NVMERR ) {
-			LOG_ERROR(&quot;Flash write error NVMERR (status=0x%08&quot; PRIx32 &quot;)&quot;, status);
+			LOG_ERROR(&quot;Flash write error NVMERR (status = 0x%08&quot; PRIx32 &quot;)&quot;, status);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 		if ( status &amp; NVMCON_LVDERR ) {
-			LOG_ERROR(&quot;Flash write error LVDERR (status=0x%08&quot; PRIx32 &quot;)&quot;, status);
+			LOG_ERROR(&quot;Flash write error LVDERR (status = 0x%08&quot; PRIx32 &quot;)&quot;, status);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
@@ -620,7 +620,7 @@
 		num_pages = 12;
 	} else {
 		/* 0xBD000000: Program flash size varies with device */
-		for (i=0; pic32mx_devs[i].name != NULL; i++)
+		for (i = 0; pic32mx_devs[i].name != NULL; i++)
 			if (pic32mx_devs[i].devid == ((device_id &gt;&gt; 12) &amp; 0xff)) {
 				num_pages = pic32mx_devs[i].pfm_size;
 				break;
@@ -704,7 +704,7 @@
 				 PIC32MX_MANUF_ID);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
-	for (i=0; pic32mx_devs[i].name != NULL; i++)
+	for (i = 0; pic32mx_devs[i].name != NULL; i++)
 		if (pic32mx_devs[i].devid == ((device_id &gt;&gt; 12) &amp; 0xff)) {
 			printed = snprintf(buf, buf_size, &quot;PIC32MX%s&quot;, pic32mx_devs[i].name);
 			break;
@@ -939,7 +939,7 @@
 	if (res == ERROR_OK)
 		command_print(cmd_ctx, &quot;pic32mx pgm word complete&quot;);
 	else
-		command_print(cmd_ctx, &quot;pic32mx pgm word failed (status=0x%x)&quot;, status);
+		command_print(cmd_ctx, &quot;pic32mx pgm word failed (status = 0x%x)&quot;, status);
 
 	return ERROR_OK;
 }

Modified: trunk/src/flash/stm32x.c
===================================================================
--- trunk/src/flash/stm32x.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/stm32x.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -517,7 +517,7 @@
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	if ((retval=target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address, sizeof(stm32x_flash_write_code), stm32x_flash_write_code)) != ERROR_OK)
+	if ((retval = target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address, sizeof(stm32x_flash_write_code), stm32x_flash_write_code)) != ERROR_OK)
 		return retval;
 
 	/* memory buffer */

Modified: trunk/src/flash/str9x.c
===================================================================
--- trunk/src/flash/str9x.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/str9x.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -198,11 +198,11 @@
 		if (str9x_info-&gt;bank1)
 		{
 			adr = bank1start + 0x18;
-			if ((retval=target_write_u16(target, adr, 0x90)) != ERROR_OK)
+			if ((retval = target_write_u16(target, adr, 0x90)) != ERROR_OK)
 			{
 				return retval;
 			}
-			if ((retval=target_read_u16(target, adr, &amp;hstatus)) != ERROR_OK)
+			if ((retval = target_read_u16(target, adr, &amp;hstatus)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -211,11 +211,11 @@
 		else
 		{
 			adr = bank1start + 0x14;
-			if ((retval=target_write_u16(target, adr, 0x90)) != ERROR_OK)
+			if ((retval = target_write_u16(target, adr, 0x90)) != ERROR_OK)
 			{
 				return retval;
 			}
-			if ((retval=target_read_u32(target, adr, &amp;status)) != ERROR_OK)
+			if ((retval = target_read_u32(target, adr, &amp;status)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -224,11 +224,11 @@
 	else
 	{
 		adr = bank1start + 0x10;
-		if ((retval=target_write_u16(target, adr, 0x90)) != ERROR_OK)
+		if ((retval = target_write_u16(target, adr, 0x90)) != ERROR_OK)
 		{
 			return retval;
 		}
-		if ((retval=target_read_u16(target, adr, &amp;hstatus)) != ERROR_OK)
+		if ((retval = target_read_u16(target, adr, &amp;hstatus)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -236,7 +236,7 @@
 	}
 
 	/* read array command */
-	if ((retval=target_write_u16(target, adr, 0xFF)) != ERROR_OK)
+	if ((retval = target_write_u16(target, adr, 0xFF)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -284,24 +284,24 @@
 		adr = bank-&gt;base + bank-&gt;sectors[i].offset;
 
 		/* erase sectors */
-		if ((retval=target_write_u16(target, adr, erase_cmd)) != ERROR_OK)
+		if ((retval = target_write_u16(target, adr, erase_cmd)) != ERROR_OK)
 		{
 			return retval;
 		}
-		if ((retval=target_write_u16(target, adr, 0xD0)) != ERROR_OK)
+		if ((retval = target_write_u16(target, adr, 0xD0)) != ERROR_OK)
 		{
 			return retval;
 		}
 
 		/* get status */
-		if ((retval=target_write_u16(target, adr, 0x70)) != ERROR_OK)
+		if ((retval = target_write_u16(target, adr, 0x70)) != ERROR_OK)
 		{
 			return retval;
 		}
 
 		int timeout;
-		for (timeout=0; timeout&lt;1000; timeout++) {
-			if ((retval=target_read_u8(target, adr, &amp;status)) != ERROR_OK)
+		for (timeout = 0; timeout&lt;1000; timeout++) {
+			if ((retval = target_read_u8(target, adr, &amp;status)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -316,13 +316,13 @@
 		}
 
 		/* clear status, also clear read array */
-		if ((retval=target_write_u16(target, adr, 0x50)) != ERROR_OK)
+		if ((retval = target_write_u16(target, adr, 0x50)) != ERROR_OK)
 		{
 			return retval;
 		}
 
 		/* read array command */
-		if ((retval=target_write_u16(target, adr, 0xFF)) != ERROR_OK)
+		if ((retval = target_write_u16(target, adr, 0xFF)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -575,7 +575,7 @@
 		target_write_u16(target, bank_adr, 0x70);
 
 		int timeout;
-		for (timeout=0; timeout&lt;1000; timeout++)
+		for (timeout = 0; timeout&lt;1000; timeout++)
 		{
 			target_read_u8(target, bank_adr, &amp;status);
 			if ( status &amp; 0x80 )
@@ -624,7 +624,7 @@
 		target_write_u16(target, bank_adr, 0x70);
 
 		int timeout;
-		for (timeout=0; timeout&lt;1000; timeout++)
+		for (timeout = 0; timeout&lt;1000; timeout++)
 		{
 			target_read_u8(target, bank_adr, &amp;status);
 			if ( status &amp; 0x80 )

Modified: trunk/src/flash/tms470.c
===================================================================
--- trunk/src/flash/tms470.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/flash/tms470.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -150,7 +150,7 @@
 	/* read and parse the device identification register */
 	target_read_u32(target, 0xFFFFFFF0, &amp;device_ident_reg);
 
-	LOG_INFO(&quot;device_ident_reg=0x%08&quot; PRIx32 &quot;&quot;, device_ident_reg);
+	LOG_INFO(&quot;device_ident_reg = 0x%08&quot; PRIx32 &quot;&quot;, device_ident_reg);
 
 	if ((device_ident_reg &amp; 7) == 0)
 	{
@@ -432,7 +432,7 @@
 	uint32_t fmbbusy;
 
 	target_read_u32(target, 0xFFE89C08, &amp;fmbbusy);
-	LOG_INFO(&quot;tms470 fmbbusy=0x%08&quot; PRIx32 &quot; -&gt; %s&quot;, fmbbusy, fmbbusy &amp; 0x8000 ? &quot;unlocked&quot; : &quot;LOCKED&quot;);
+	LOG_INFO(&quot;tms470 fmbbusy = 0x%08&quot; PRIx32 &quot; -&gt; %s&quot;, fmbbusy, fmbbusy &amp; 0x8000 ? &quot;unlocked&quot; : &quot;LOCKED&quot;);
 	return fmbbusy &amp; 0x8000 ? ERROR_OK : ERROR_FLASH_OPERATION_FAILED;
 }
 
@@ -482,7 +482,7 @@
 			 */
 			target_read_u32(target, 0x00001FF0 + 4 * i, &amp;tmp);
 
-			LOG_INFO(&quot;tms470 writing fmpkey=0x%08&quot; PRIx32 &quot;&quot;, key_set[i]);
+			LOG_INFO(&quot;tms470 writing fmpkey = 0x%08&quot; PRIx32 &quot;&quot;, key_set[i]);
 			target_write_u32(target, 0xFFE89C0C, key_set[i]);
 		}
 
@@ -570,7 +570,7 @@
 	fmmac2 &amp;= ~0x0007;
 	fmmac2 |= (tms470_info-&gt;ordinal &amp; 7);
 	target_write_u32(target, 0xFFE8BC04, fmmac2);
-	LOG_DEBUG(&quot;set fmmac2=0x%04&quot; PRIx32 &quot;&quot;, fmmac2);
+	LOG_DEBUG(&quot;set fmmac2 = 0x%04&quot; PRIx32 &quot;&quot;, fmmac2);
 
 	/*
 	 * Disable level 1 sector protection by setting bit 15 of FMMAC1.
@@ -578,25 +578,25 @@
 	target_read_u32(target, 0xFFE8BC00, &amp;fmmac1);
 	fmmac1 |= 0x8000;
 	target_write_u32(target, 0xFFE8BC00, fmmac1);
-	LOG_DEBUG(&quot;set fmmac1=0x%04&quot; PRIx32 &quot;&quot;, fmmac1);
+	LOG_DEBUG(&quot;set fmmac1 = 0x%04&quot; PRIx32 &quot;&quot;, fmmac1);
 
 	/*
-	 * FMTCREG=0x2fc0;
+	 * FMTCREG = 0x2fc0;
 	 */
 	target_write_u32(target, 0xFFE8BC10, 0x2fc0);
-	LOG_DEBUG(&quot;set fmtcreg=0x2fc0&quot;);
+	LOG_DEBUG(&quot;set fmtcreg = 0x2fc0&quot;);
 
 	/*
-	 * MAXPP=50
+	 * MAXPP = 50
 	 */
 	target_write_u32(target, 0xFFE8A07C, 50);
-	LOG_DEBUG(&quot;set fmmaxpp=50&quot;);
+	LOG_DEBUG(&quot;set fmmaxpp = 50&quot;);
 
 	/*
-	 * MAXCP=0xf000+2000
+	 * MAXCP = 0xf000+2000
 	 */
 	target_write_u32(target, 0xFFE8A084, 0xf000 + 2000);
-	LOG_DEBUG(&quot;set fmmaxcp=0x%04x&quot;, 0xf000 + 2000);
+	LOG_DEBUG(&quot;set fmmaxcp = 0x%04x&quot;, 0xf000 + 2000);
 
 	/*
 	 * configure VHV
@@ -606,22 +606,22 @@
 	{
 		fmmaxep = 0xf000 + 4095;
 		target_write_u32(target, 0xFFE8A80C, 0x9964);
-		LOG_DEBUG(&quot;set fmptr3=0x9964&quot;);
+		LOG_DEBUG(&quot;set fmptr3 = 0x9964&quot;);
 	}
 	else
 	{
 		fmmaxep = 0xa000 + 4095;
 		target_write_u32(target, 0xFFE8A80C, 0x9b64);
-		LOG_DEBUG(&quot;set fmptr3=0x9b64&quot;);
+		LOG_DEBUG(&quot;set fmptr3 = 0x9b64&quot;);
 	}
 	target_write_u32(target, 0xFFE8A080, fmmaxep);
-	LOG_DEBUG(&quot;set fmmaxep=0x%04&quot; PRIx32 &quot;&quot;, fmmaxep);
+	LOG_DEBUG(&quot;set fmmaxep = 0x%04&quot; PRIx32 &quot;&quot;, fmmaxep);
 
 	/*
-	 * FMPTR4=0xa000
+	 * FMPTR4 = 0xa000
 	 */
 	target_write_u32(target, 0xFFE8A810, 0xa000);
-	LOG_DEBUG(&quot;set fmptr4=0xa000&quot;);
+	LOG_DEBUG(&quot;set fmptr4 = 0xa000&quot;);
 
 	/*
 	 * FMPESETUP, delay parameter selected based on clock frequency.
@@ -635,56 +635,56 @@
 	sysclk = (plldis ? 1 : (glbctrl &amp; 0x08) ? 4 : 8) * oscMHz / (1 + (glbctrl &amp; 7));
 	delay = (sysclk &gt; 10) ? (sysclk + 1) / 2 : 5;
 	target_write_u32(target, 0xFFE8A018, (delay &lt;&lt; 4) | (delay &lt;&lt; 8));
-	LOG_DEBUG(&quot;set fmpsetup=0x%04&quot; PRIx32 &quot;&quot;, (delay &lt;&lt; 4) | (delay &lt;&lt; 8));
+	LOG_DEBUG(&quot;set fmpsetup = 0x%04&quot; PRIx32 &quot;&quot;, (delay &lt;&lt; 4) | (delay &lt;&lt; 8));
 
 	/*
 	 * FMPVEVACCESS, based on delay.
 	 */
 	k = delay | (delay &lt;&lt; 8);
 	target_write_u32(target, 0xFFE8A05C, k);
-	LOG_DEBUG(&quot;set fmpvevaccess=0x%04&quot; PRIx32 &quot;&quot;, k);
+	LOG_DEBUG(&quot;set fmpvevaccess = 0x%04&quot; PRIx32 &quot;&quot;, k);
 
 	/*
 	 * FMPCHOLD, FMPVEVHOLD, FMPVEVSETUP, based on delay.
 	 */
 	k &lt;&lt;= 1;
 	target_write_u32(target, 0xFFE8A034, k);
-	LOG_DEBUG(&quot;set fmpchold=0x%04&quot; PRIx32 &quot;&quot;, k);
+	LOG_DEBUG(&quot;set fmpchold = 0x%04&quot; PRIx32 &quot;&quot;, k);
 	target_write_u32(target, 0xFFE8A040, k);
-	LOG_DEBUG(&quot;set fmpvevhold=0x%04&quot; PRIx32 &quot;&quot;, k);
+	LOG_DEBUG(&quot;set fmpvevhold = 0x%04&quot; PRIx32 &quot;&quot;, k);
 	target_write_u32(target, 0xFFE8A024, k);
-	LOG_DEBUG(&quot;set fmpvevsetup=0x%04&quot; PRIx32 &quot;&quot;, k);
+	LOG_DEBUG(&quot;set fmpvevsetup = 0x%04&quot; PRIx32 &quot;&quot;, k);
 
 	/*
 	 * FMCVACCESS, based on delay.
 	 */
 	k = delay * 16;
 	target_write_u32(target, 0xFFE8A060, k);
-	LOG_DEBUG(&quot;set fmcvaccess=0x%04&quot; PRIx32 &quot;&quot;, k);
+	LOG_DEBUG(&quot;set fmcvaccess = 0x%04&quot; PRIx32 &quot;&quot;, k);
 
 	/*
 	 * FMCSETUP, based on delay.
 	 */
 	k = 0x3000 | delay * 20;
 	target_write_u32(target, 0xFFE8A020, k);
-	LOG_DEBUG(&quot;set fmcsetup=0x%04&quot; PRIx32 &quot;&quot;, k);
+	LOG_DEBUG(&quot;set fmcsetup = 0x%04&quot; PRIx32 &quot;&quot;, k);
 
 	/*
 	 * FMEHOLD, based on delay.
 	 */
 	k = (delay * 20) &lt;&lt; 2;
 	target_write_u32(target, 0xFFE8A038, k);
-	LOG_DEBUG(&quot;set fmehold=0x%04&quot; PRIx32 &quot;&quot;, k);
+	LOG_DEBUG(&quot;set fmehold = 0x%04&quot; PRIx32 &quot;&quot;, k);
 
 	/*
 	 * PWIDTH, CWIDTH, EWIDTH, based on delay.
 	 */
 	target_write_u32(target, 0xFFE8A050, delay * 8);
-	LOG_DEBUG(&quot;set fmpwidth=0x%04&quot; PRIx32 &quot;&quot;, delay * 8);
+	LOG_DEBUG(&quot;set fmpwidth = 0x%04&quot; PRIx32 &quot;&quot;, delay * 8);
 	target_write_u32(target, 0xFFE8A058, delay * 1000);
-	LOG_DEBUG(&quot;set fmcwidth=0x%04&quot; PRIx32 &quot;&quot;, delay * 1000);
+	LOG_DEBUG(&quot;set fmcwidth = 0x%04&quot; PRIx32 &quot;&quot;, delay * 1000);
 	target_write_u32(target, 0xFFE8A054, delay * 5400);
-	LOG_DEBUG(&quot;set fmewidth=0x%04&quot; PRIx32 &quot;&quot;, delay * 5400);
+	LOG_DEBUG(&quot;set fmewidth = 0x%04&quot; PRIx32 &quot;&quot;, delay * 5400);
 
 	return result;
 }
@@ -698,7 +698,7 @@
 	uint32_t fmmstat;
 
 	target_read_u32(target, 0xFFE8BC0C, &amp;fmmstat);
-	LOG_DEBUG(&quot;set fmmstat=0x%04&quot; PRIx32 &quot;&quot;, fmmstat);
+	LOG_DEBUG(&quot;set fmmstat = 0x%04&quot; PRIx32 &quot;&quot;, fmmstat);
 
 	if (fmmstat &amp; 0x0080)
 	{
@@ -760,12 +760,12 @@
 	 */
 	target_read_u32(target, 0xFFFFFFDC, &amp;glbctrl);
 	target_write_u32(target, 0xFFFFFFDC, glbctrl | 0x10);
-	LOG_DEBUG(&quot;set glbctrl=0x%08&quot; PRIx32 &quot;&quot;, glbctrl | 0x10);
+	LOG_DEBUG(&quot;set glbctrl = 0x%08&quot; PRIx32 &quot;&quot;, glbctrl | 0x10);
 
 	/* Force normal read mode. */
 	target_read_u32(target, 0xFFE89C00, &amp;orig_fmregopt);
 	target_write_u32(target, 0xFFE89C00, 0);
-	LOG_DEBUG(&quot;set fmregopt=0x%08x&quot;, 0);
+	LOG_DEBUG(&quot;set fmregopt = 0x%08x&quot;, 0);
 
 	(void)tms470_flash_initialize_internal_state_machine(bank);
 
@@ -777,13 +777,13 @@
 	{
 		target_read_u32(target, 0xFFE88008, &amp;fmbsea);
 		target_write_u32(target, 0xFFE88008, fmbsea | (1 &lt;&lt; sector));
-		LOG_DEBUG(&quot;set fmbsea=0x%04&quot; PRIx32 &quot;&quot;, fmbsea | (1 &lt;&lt; sector));
+		LOG_DEBUG(&quot;set fmbsea = 0x%04&quot; PRIx32 &quot;&quot;, fmbsea | (1 &lt;&lt; sector));
 	}
 	else
 	{
 		target_read_u32(target, 0xFFE8800C, &amp;fmbseb);
 		target_write_u32(target, 0xFFE8800C, fmbseb | (1 &lt;&lt; (sector - 16)));
-		LOG_DEBUG(&quot;set fmbseb=0x%04&quot; PRIx32 &quot;&quot;, fmbseb | (1 &lt;&lt; (sector - 16)));
+		LOG_DEBUG(&quot;set fmbseb = 0x%04&quot; PRIx32 &quot;&quot;, fmbseb | (1 &lt;&lt; (sector - 16)));
 	}
 	bank-&gt;sectors[sector].is_protected = 0;
 
@@ -816,19 +816,19 @@
 	if (sector &lt; 16)
 	{
 		target_write_u32(target, 0xFFE88008, fmbsea);
-		LOG_DEBUG(&quot;set fmbsea=0x%04&quot; PRIx32 &quot;&quot;, fmbsea);
+		LOG_DEBUG(&quot;set fmbsea = 0x%04&quot; PRIx32 &quot;&quot;, fmbsea);
 		bank-&gt;sectors[sector].is_protected = fmbsea &amp; (1 &lt;&lt; sector) ? 0 : 1;
 	}
 	else
 	{
 		target_write_u32(target, 0xFFE8800C, fmbseb);
-		LOG_DEBUG(&quot;set fmbseb=0x%04&quot; PRIx32 &quot;&quot;, fmbseb);
+		LOG_DEBUG(&quot;set fmbseb = 0x%04&quot; PRIx32 &quot;&quot;, fmbseb);
 		bank-&gt;sectors[sector].is_protected = fmbseb &amp; (1 &lt;&lt; (sector - 16)) ? 0 : 1;
 	}
 	target_write_u32(target, 0xFFE89C00, orig_fmregopt);
-	LOG_DEBUG(&quot;set fmregopt=0x%08&quot; PRIx32 &quot;&quot;, orig_fmregopt);
+	LOG_DEBUG(&quot;set fmregopt = 0x%08&quot; PRIx32 &quot;&quot;, orig_fmregopt);
 	target_write_u32(target, 0xFFFFFFDC, glbctrl);
-	LOG_DEBUG(&quot;set glbctrl=0x%08&quot; PRIx32 &quot;&quot;, glbctrl);
+	LOG_DEBUG(&quot;set glbctrl = 0x%08&quot; PRIx32 &quot;&quot;, glbctrl);
 
 	if (result == ERROR_OK)
 	{
@@ -1028,7 +1028,7 @@
 
 			if (fmmstat &amp; 0x3ff)
 			{
-				LOG_ERROR(&quot;fmstat=0x%04&quot; PRIx32 &quot;&quot;, fmmstat);
+				LOG_ERROR(&quot;fmstat = 0x%04&quot; PRIx32 &quot;&quot;, fmmstat);
 				LOG_ERROR(&quot;Could not program word 0x%04x at address 0x%08&quot; PRIx32 &quot;.&quot;, word, addr);
 				result = ERROR_FLASH_OPERATION_FAILED;
 				break;
@@ -1105,7 +1105,7 @@
 	target_read_u32(target, 0xFFE8BC04, &amp;fmmac2);
 	target_write_u32(target, 0xFFE8BC04, (fmmac2 &amp; ~7) | tms470_info-&gt;ordinal);
 
-	/* TCR=0 */
+	/* TCR = 0 */
 	target_write_u32(target, 0xFFE8BC10, 0x2fc0);
 
 	/* clear TEZ in fmbrdy */

Modified: trunk/src/helper/binarybuffer.h
===================================================================
--- trunk/src/helper/binarybuffer.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/binarybuffer.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -42,7 +42,7 @@
 	{
 		unsigned int i;
 		
-		for (i=first; i&lt;first+num; i++)
+		for (i = first; i&lt;first+num; i++)
 		{
 			if (((value &gt;&gt; (i-first))&amp;1) == 1)
 				buffer[i/8] |= 1 &lt;&lt; (i%8);
@@ -61,7 +61,7 @@
 		uint32_t result = 0;
 		unsigned int i;
 		
-		for (i=first; i&lt;first+num; i++)
+		for (i = first; i&lt;first+num; i++)
 		{
 			if (((buffer[i/8]&gt;&gt;(i%8))&amp;1) == 1)
 				result |= 1 &lt;&lt; (i-first);

Modified: trunk/src/helper/command.c
===================================================================
--- trunk/src/helper/command.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/command.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -54,7 +54,7 @@
 
 static void tcl_output(void *privData, const char *file, int line, const char *function, const char *string)
 {
-	Jim_Obj *tclOutput=(Jim_Obj *)privData;
+	Jim_Obj *tclOutput = (Jim_Obj *)privData;
 
 	Jim_AppendString(interp, tclOutput, string, strlen(string));
 }
@@ -108,7 +108,7 @@
 	for (i = 0; i &lt; argc; i++)
 	{
 		int len;
-		const char *w=Jim_GetString(argv[i], &amp;len);
+		const char *w = Jim_GetString(argv[i], &amp;len);
 		if (*w=='#')
 		{
 			/* hit an end of line comment */
@@ -228,26 +228,26 @@
 	/* maximum of two levels :-) */
 	if (c-&gt;parent != NULL)
 	{
-		t1=c-&gt;parent-&gt;name;
+		t1 = c-&gt;parent-&gt;name;
 		t2=&quot;_&quot;;
 	}
-	t3=c-&gt;name;
-	const char *full_name=alloc_printf(&quot;ocd_%s%s%s&quot;, t1, t2, t3);
+	t3 = c-&gt;name;
+	const char *full_name = alloc_printf(&quot;ocd_%s%s%s&quot;, t1, t2, t3);
 	Jim_CreateCommand(interp, full_name, script_command, c, NULL);
 	free((void *)full_name);
 
 	/* we now need to add an overrideable proc */
-	const char *override_name=alloc_printf(&quot;proc %s%s%s {args} {if {[catch {eval ocd_%s%s%s $args}]==0} {return \&quot;\&quot;} else { return -code error }&quot;, t1, t2, t3, t1, t2, t3);
+	const char *override_name = alloc_printf(&quot;proc %s%s%s {args} {if {[catch {eval ocd_%s%s%s $args}]==0} {return \&quot;\&quot;} else { return -code error }&quot;, t1, t2, t3, t1, t2, t3);
 	Jim_Eval_Named(interp, override_name, __THIS__FILE__, __LINE__ );
 	free((void *)override_name);
 
 	/* accumulate help text in Tcl helptext list.  */
-	Jim_Obj *helptext=Jim_GetGlobalVariableStr(interp, &quot;ocd_helptext&quot;, JIM_ERRMSG);
+	Jim_Obj *helptext = Jim_GetGlobalVariableStr(interp, &quot;ocd_helptext&quot;, JIM_ERRMSG);
 	if (Jim_IsShared(helptext))
 		helptext = Jim_DuplicateObj(interp, helptext);
-	Jim_Obj *cmd_entry=Jim_NewListObj(interp, NULL, 0);
+	Jim_Obj *cmd_entry = Jim_NewListObj(interp, NULL, 0);
 
-	Jim_Obj *cmd_list=Jim_NewListObj(interp, NULL, 0);
+	Jim_Obj *cmd_list = Jim_NewListObj(interp, NULL, 0);
 
 	/* maximum of two levels :-) */
 	if (c-&gt;parent != NULL)
@@ -404,7 +404,7 @@
 
 int run_command(command_context_t *context, command_t *c, char *words[], int num_words)
 {
-	int start_word=0;
+	int start_word = 0;
 	if (!((context-&gt;mode == COMMAND_CONFIG) || (c-&gt;mode == COMMAND_ANY) || (c-&gt;mode == context-&gt;mode) ))
 	{
 		/* Config commands can not run after the config stage */
@@ -422,10 +422,10 @@
 		/* maximum of two levels :-) */
 		if (c-&gt;parent != NULL)
 		{
-			t1=c-&gt;parent-&gt;name;
+			t1 = c-&gt;parent-&gt;name;
 			t2=&quot; &quot;;
 		}
-		t3=c-&gt;name;
+		t3 = c-&gt;name;
 		command_run_linef(context, &quot;help {%s%s%s}&quot;, t1, t2, t3);
 	}
 	else if (retval == ERROR_COMMAND_CLOSE_CONNECTION)
@@ -450,7 +450,7 @@
 	 * results
 	 */
 	/* run the line thru a script engine */
-	int retval=ERROR_FAIL;
+	int retval = ERROR_FAIL;
 	int retcode;
 	/* Beware! This code needs to be reentrant. It is also possible
 	 * for OpenOCD commands to be invoked directly from Tcl. This would
@@ -508,21 +508,21 @@
 			}
 			LOG_USER_N(&quot;%s&quot;, &quot;\n&quot;);
 		}
-		retval=ERROR_OK;
+		retval = ERROR_OK;
 	}
 	return retval;
 }
 
 int command_run_linef(command_context_t *context, const char *format, ...)
 {
-	int retval=ERROR_FAIL;
+	int retval = ERROR_FAIL;
 	char *string;
 	va_list ap;
 	va_start(ap, format);
 	string = alloc_vprintf(format, ap);
 	if (string != NULL)
 	{
-		retval=command_run_line(context, string);
+		retval = command_run_line(context, string);
 	}
 	va_end(ap);
 	return retval;
@@ -837,13 +837,13 @@
 
 	/* FIX!!! it would be prettier to invoke add_help_text...
 	 * accumulate help text in Tcl helptext list.  */
-	Jim_Obj *helptext=Jim_GetGlobalVariableStr(interp, &quot;ocd_helptext&quot;, JIM_ERRMSG);
+	Jim_Obj *helptext = Jim_GetGlobalVariableStr(interp, &quot;ocd_helptext&quot;, JIM_ERRMSG);
 	if (Jim_IsShared(helptext))
 		helptext = Jim_DuplicateObj(interp, helptext);
 
-	Jim_Obj *cmd_entry=Jim_NewListObj(interp, NULL, 0);
+	Jim_Obj *cmd_entry = Jim_NewListObj(interp, NULL, 0);
 
-	Jim_Obj *cmd_list=Jim_NewListObj(interp, NULL, 0);
+	Jim_Obj *cmd_list = Jim_NewListObj(interp, NULL, 0);
 	Jim_ListAppendElement(interp, cmd_list, Jim_NewStringObj(interp, name, -1));
 
 	Jim_ListAppendElement(interp, cmd_entry, cmd_list);
@@ -854,7 +854,7 @@
 /* return global variable long value or 0 upon failure */
 long jim_global_long(const char *variable)
 {
-	Jim_Obj *objPtr=Jim_GetGlobalVariableStr(interp, variable, JIM_ERRMSG);
+	Jim_Obj *objPtr = Jim_GetGlobalVariableStr(interp, variable, JIM_ERRMSG);
 	long t;
 	if (Jim_GetLong(interp, objPtr, &amp;t) == JIM_OK)
 	{

Modified: trunk/src/helper/configuration.c
===================================================================
--- trunk/src/helper/configuration.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/configuration.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -93,7 +93,7 @@
 		return fopen(file, mode);
 	} else
 	{
-		char *full_path=find_file(file);
+		char *full_path = find_file(file);
 		if (full_path == NULL)
 			return NULL;
 		FILE *fp = NULL;
@@ -115,7 +115,7 @@
 
 	while (*cfg)
 	{
-		retval=command_run_line(cmd_ctx, *cfg);
+		retval = command_run_line(cmd_ctx, *cfg);
 		if (retval != ERROR_OK)
 			return retval;
 		cfg++;

Modified: trunk/src/helper/ioutil.c
===================================================================
--- trunk/src/helper/ioutil.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/ioutil.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -215,7 +215,7 @@
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	int retval=ERROR_FAIL;
+	int retval = ERROR_FAIL;
 	FILE *config_file = NULL;
 	config_file = fopen(args[0], &quot;a&quot;);
 	if (config_file != NULL)
@@ -235,7 +235,7 @@
 		}
 		if ((i == argc) &amp;&amp; (fwrite(&quot;\n&quot;, 1, 1, config_file) == 1))
 		{
-			retval=ERROR_OK;
+			retval = ERROR_OK;
 		}
 		fclose(config_file);
 	}

Modified: trunk/src/helper/jim.c
===================================================================
--- trunk/src/helper/jim.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/jim.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -504,7 +504,7 @@
 {
     jim_wide i, res = 1;
     if ((b == 0 &amp;&amp; e != 0) || (e&lt;0)) return 0;
-    for (i=0; i&lt;e; i++) {res *= b;}
+    for (i = 0; i&lt;e; i++) {res *= b;}
     return res;
 }
 
@@ -569,7 +569,7 @@
 {
 	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
 	if (size == 0)
-		size=1;
+		size = 1;
     void *p = malloc(size);
     if (p == NULL)
         Jim_Panic(NULL,&quot;malloc: Out of memory&quot;);
@@ -584,7 +584,7 @@
 {
 	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
 	if (size == 0)
-		size=1;
+		size = 1;
     void *p = realloc(ptr, size);
     if (p == NULL)
         Jim_Panic(NULL,&quot;realloc: Out of memory&quot;);
@@ -2521,8 +2521,8 @@
 Jim_Obj *Jim_FormatString(Jim_Interp *interp, Jim_Obj *fmtObjPtr,
         int objc, Jim_Obj *const *objv)
 {
-	char *sprintf_buf=malloc(JIM_MAX_FMT);
-	Jim_Obj *t=Jim_FormatString_Inner(interp, fmtObjPtr, objc, objv, sprintf_buf);
+	char *sprintf_buf = malloc(JIM_MAX_FMT);
+	Jim_Obj *t = Jim_FormatString_Inner(interp, fmtObjPtr, objc, objv, sprintf_buf);
 	free(sprintf_buf);
 	return t; 
 }
@@ -5366,7 +5366,7 @@
     }
     point = listPtr-&gt;internalRep.listValue.ele + index;
     memmove(point+elemc, point, (currentLen-index) * sizeof(Jim_Obj*));
-    for (i=0; i &lt; elemc; ++i) {
+    for (i = 0; i &lt; elemc; ++i) {
         point[i] = elemVec[i];
         Jim_IncrRefCount(point[i]);
     }
@@ -7335,7 +7335,7 @@
 
     Jim_FreeIntRep(interp, objPtr);
     /* Count how many conversions could take place maximally */
-    for (i=0, maxCount=0; i &lt; maxFmtLen; ++i)
+    for (i = 0, maxCount = 0; i &lt; maxFmtLen; ++i)
         if (fmt[i] == '%')
             ++maxCount;
     /* Calculate an approximation of the memory necessary */
@@ -7356,8 +7356,8 @@
     buffer = fmtObj-&gt;stringRep + maxFmtLen + 1;
     objPtr-&gt;internalRep.ptr = fmtObj;
     objPtr-&gt;typePtr = &scanFmtStringObjType;
-    for (i=0, curr=0; fmt &lt; fmtEnd; ++fmt) {
-        int width=0, skip;
+    for (i = 0, curr = 0; fmt &lt; fmtEnd; ++fmt) {
+        int width = 0, skip;
         ScanFmtPartDescr *descr = &amp;fmtObj-&gt;descr[curr];
         fmtObj-&gt;count++;
         descr-&gt;width = 0;                   /* Assume width unspecified */ 
@@ -7401,7 +7401,7 @@
                     return JIM_ERR;
                 }
                 /* Look if this position was already used */
-                for (prev=0; prev &lt; curr; ++prev) {
+                for (prev = 0; prev &lt; curr; ++prev) {
                     if (fmtObj-&gt;descr[prev].pos == -1) continue;
                     if (fmtObj-&gt;descr[prev].pos == descr-&gt;pos) {
                         fmtObj-&gt;error = &quot;same \&quot;%n$\&quot; conversion specifier &quot;
@@ -7442,7 +7442,7 @@
             /* In case a range fence was given &quot;backwards&quot;, swap it */
             while (swapped) {
                 swapped = 0;
-                for (j=beg+1; j &lt; end-1; ++j) {
+                for (j = beg+1; j &lt; end-1; ++j) {
                     if (buffer[j] == '-' &amp;&amp; buffer[j-1] &gt; buffer[j+1]) {
                         char tmp = buffer[j-1];
                         buffer[j-1] = buffer[j+1];
@@ -7550,7 +7550,7 @@
             if (sdescr[1] == '-' &amp;&amp; sdescr[2] != 0) {
                 /* Handle range definitions */
                 int i;
-                for (i=sdescr[0]; i &lt;= sdescr[2]; ++i)
+                for (i = sdescr[0]; i &lt;= sdescr[2]; ++i)
                     JimSetBit(charset, (char)i);
                 sdescr += 3;
             } else {
@@ -7559,7 +7559,7 @@
             }
         }
         /* Negate the charset if there was a NOT given */
-        for (i=0; notFlag &amp;&amp; i &lt; sizeof(charset); ++i)
+        for (i = 0; notFlag &amp;&amp; i &lt; sizeof(charset); ++i)
             charset[i] = ~charset[i];
     } 
     /* And after all the mess above, the real work begin ... */
@@ -7600,7 +7600,7 @@
     if (descr-&gt;prefix) {
         /* There was a prefix given before the conversion, skip it and adjust
          * the string-to-be-parsed accordingly */
-        for (i=0; str[pos] &amp;&amp; descr-&gt;prefix[i]; ++i) {
+        for (i = 0; str[pos] &amp;&amp; descr-&gt;prefix[i]; ++i) {
             /* If prefix require, skip WS */
             if (isspace((int)descr-&gt;prefix[i]))
                 while (str[pos] &amp;&amp; isspace((int)str[pos])) ++pos;
@@ -7757,12 +7757,12 @@
     /* Create a list and fill it with empty strings up to max specified XPG3 */
     resultList = Jim_NewListObj(interp, 0, 0);
     if (fmtObj-&gt;maxPos &gt; 0) {
-        for (i=0; i &lt; fmtObj-&gt;maxPos; ++i)
+        for (i = 0; i &lt; fmtObj-&gt;maxPos; ++i)
             Jim_ListAppendElement(interp, resultList, emptyStr);
         JimListGetElements(interp, resultList, &amp;resultc, &amp;resultVec);
     }
     /* Now handle every partial format description */
-    for (i=0, pos=0; i &lt; fmtObj-&gt;count; ++i) {
+    for (i = 0, pos = 0; i &lt; fmtObj-&gt;count; ++i) {
         ScanFmtPartDescr *descr = &amp;(fmtObj-&gt;descr[i]);
         Jim_Obj *value = 0;
         /* Only last type may be &quot;literal&quot; w/o conversion - skip it! */
@@ -8960,8 +8960,8 @@
     Jim_Obj *scriptObjPtr;
     
     if ((fp = fopen(filename, &quot;r&quot;)) == NULL) {
-    	const int cwd_len=2048;
-		char *cwd=malloc(cwd_len);
+    	const int cwd_len = 2048;
+		char *cwd = malloc(cwd_len);
         Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 	if (!getcwd( cwd, cwd_len )) strcpy(cwd, &quot;unknown&quot;);
         Jim_AppendStrings(interp, Jim_GetResult(interp),
@@ -10203,7 +10203,7 @@
     /* Initialize iterators and remember max nbr elements each list */
     memset(listsIdx, 0, nbrOfLists * sizeof(int));
     /* Remember lengths of all lists and calculate how much rounds to loop */
-    for (i=0; i &lt; nbrOfLists*2; i += 2) {
+    for (i = 0; i &lt; nbrOfLists*2; i += 2) {
         div_t cnt;
         int count;
         Jim_ListLength(interp, argv[i+1], &amp;listsEnd[i]);
@@ -10218,7 +10218,7 @@
             nbrOfLoops = count;
     }
     for (; nbrOfLoops-- &gt; 0; ) {
-        for (i=0; i &lt; nbrOfLists; ++i) {
+        for (i = 0; i &lt; nbrOfLists; ++i) {
             int varIdx = 0, var = i * 2;
             while (varIdx &lt; listsEnd[var]) {
                 Jim_Obj *varName, *ele;
@@ -10340,11 +10340,11 @@
 static int Jim_SwitchCoreCommand(Jim_Interp *interp, int argc, 
         Jim_Obj *const *argv)
 {
-    int retcode = JIM_ERR, matchOpt = SWITCH_EXACT, opt=1, patCount, i;
+    int retcode = JIM_ERR, matchOpt = SWITCH_EXACT, opt = 1, patCount, i;
     Jim_Obj *command = 0, *const *caseList = 0, *strObj;
     Jim_Obj *script = 0;
     if (argc &lt; 3) goto wrongnumargs;
-    for (opt=1; opt &lt; argc; ++opt) {
+    for (opt = 1; opt &lt; argc; ++opt) {
         const char *option = Jim_GetString(argv[opt], 0);
         if (*option != '-') break;
         else if (strncmp(option, &quot;--&quot;, 2) == 0) { ++opt; break; }
@@ -10372,7 +10372,7 @@
     } else
         caseList = &amp;argv[opt];
     if (patCount == 0 || patCount % 2 != 0) goto wrongnumargs;
-    for (i=0; script == 0 &amp;&amp; i &lt; patCount; i += 2) {
+    for (i = 0; script == 0 &amp;&amp; i &lt; patCount; i += 2) {
         Jim_Obj *patObj = caseList[i];
         if (!Jim_CompareStringImmediate(interp, patObj, &quot;default&quot;)
             || i &lt; (patCount-2)) {

Modified: trunk/src/helper/jim.h
===================================================================
--- trunk/src/helper/jim.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/jim.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -575,7 +575,7 @@
  * known string, or there may be multiple strings (aliases) that mean then same
  * thing.
  *
- * An NVP Table is terminated with &quot;.name=NULL&quot;.
+ * An NVP Table is terminated with &quot;.name = NULL&quot;.
  *
  * During the 'name2value' operation, if no matching string is found
  * the pointer to the terminal element (with p-&gt;name == NULL) is returned.
@@ -966,7 +966,7 @@
  * Usefull when dealing with command options.
  * that may come in any order...
  *
- * Does not support &quot;-foo=123&quot; type options.
+ * Does not support &quot;-foo = 123&quot; type options.
  * Only supports tcl type options, like &quot;-foo 123&quot;
  */
 
@@ -1097,7 +1097,7 @@
  *
  * This function assumes the previous option argv[-1] is the unknown string.
  *
- * If this option had some prefix, then pass &quot;hadprefix=1&quot; else pass &quot;hadprefix=0&quot;
+ * If this option had some prefix, then pass &quot;hadprefix = 1&quot; else pass &quot;hadprefix = 0&quot;
  *
  * Example:
  * \code
@@ -1107,7 +1107,7 @@
  *     e = Jim_GetOpt_Nvp( &amp;goi, cmd_options, &amp;n );
  *     if ( e != JIM_OK ){
  *          // option was not recognized
- *          // pass 'hadprefix=0' because there is no prefix
+ *          // pass 'hadprefix = 0' because there is no prefix
  *          Jim_GetOpt_NvpUnknown( &amp;goi, cmd_options, 0 );
  *          return e;
  *     }

Modified: trunk/src/helper/log.c
===================================================================
--- trunk/src/helper/log.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/log.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -94,7 +94,7 @@
 		if (debug_level &gt;= LOG_LVL_DEBUG)
 		{
 			/* print with count and time information */
-			int t=(int)(timeval_ms()-start);
+			int t = (int)(timeval_ms()-start);
 #ifdef _DEBUG_FREE_SPACE_
 			struct mallinfo info;
 			info = mallinfo();
@@ -136,9 +136,9 @@
 		/* DANGER!!!! the log callback can remove itself!!!! */
 		while (cb)
 		{
-			next=cb-&gt;next;
+			next = cb-&gt;next;
 			cb-&gt;fn(cb-&gt;priv, file, line, function, string);
-			cb=next;
+			cb = next;
 		}
 	}
 }
@@ -259,7 +259,7 @@
 		log_output = stderr;
 	}
 
-	start=last_time=timeval_ms();
+	start = last_time = timeval_ms();
 
 	return ERROR_OK;
 }
@@ -383,7 +383,7 @@
  */
 void keep_alive()
 {
-	current_time=timeval_ms();
+	current_time = timeval_ms();
 	if (current_time-last_time&gt;1000)
 	{
 		extern int gdb_actual_connections;
@@ -413,28 +413,28 @@
 		 * These functions should be invoked at a well defined spot in server.c
 		 */
 
-		last_time=current_time;
+		last_time = current_time;
 	}
 }
 
 /* reset keep alive timer without sending message */
 void kept_alive()
 {
-	current_time=timeval_ms();
-	last_time=current_time;
+	current_time = timeval_ms();
+	last_time = current_time;
 }
 
 /* if we sleep for extended periods of time, we must invoke keep_alive() intermittantly */
 void alive_sleep(int ms)
 {
 	int i;
-	int napTime=10;
-	for (i=0; i&lt;ms; i += napTime)
+	int napTime = 10;
+	for (i = 0; i&lt;ms; i += napTime)
 	{
-		int sleep_a_bit=ms-i;
+		int sleep_a_bit = ms-i;
 		if (sleep_a_bit&gt;napTime)
 		{
-			sleep_a_bit=napTime;
+			sleep_a_bit = napTime;
 		}
 		usleep(sleep_a_bit*1000);
 		keep_alive();
@@ -444,7 +444,7 @@
 void busy_sleep(int ms)
 {
 	long long then;
-	then=timeval_ms();
+	then = timeval_ms();
 	while ((timeval_ms()-then)&lt;ms)
 	{
 		/* busy wait */

Modified: trunk/src/helper/options.c
===================================================================
--- trunk/src/helper/options.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/options.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -70,7 +70,7 @@
 		/* Either this code will *always* work or it will SEGFAULT giving
 		 * excellent information on the culprit. 
 		 */
-		*strrchr(strExePath, '\\')=0;
+		*strrchr(strExePath, '\\') = 0;
 		strcat(strExePath, &quot;\\..&quot;);
 		add_script_search_dir(strExePath);
 	}
@@ -88,9 +88,9 @@
 		char strExePath [MAX_PATH];
 		char *p;
 		GetModuleFileName (NULL, strExePath, MAX_PATH);
-		*strrchr(strExePath, '\\')=0;
+		*strrchr(strExePath, '\\') = 0;
 		strcat(strExePath, &quot;/../lib/&quot;PACKAGE);
-		for (p=strExePath; *p; p++) {
+		for (p = strExePath; *p; p++) {
 			if (*p == '\\')
 				*p = '/';
 		}

Modified: trunk/src/helper/time_support.c
===================================================================
--- trunk/src/helper/time_support.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/helper/time_support.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -99,7 +99,7 @@
 	if (text)
 	{
 		float t;
-		t=duration-&gt;duration.tv_sec;
+		t = duration-&gt;duration.tv_sec;
 		t += (float)duration-&gt;duration.tv_usec/1000000.0;
 		*text = malloc(100);
 		snprintf(*text, 100, &quot;%fs&quot;, t);
@@ -111,7 +111,7 @@
 long long timeval_ms()
 {
 	struct timeval now; 
-	long long t=0;
+	long long t = 0;
 	gettimeofday(&amp;now, NULL);
 	
 	t += now.tv_usec/1000;

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/bitbang.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -47,7 +47,7 @@
  *
  * If someone can submit a patch with an explanation it will be greatly
  * appreciated, but as far as I can tell (&#216;H) DCLK is generated upon
- * clk=0 in TAP_IDLE. Good luck deducing that from the ARM documentation!
+ * clk = 0 in TAP_IDLE. Good luck deducing that from the ARM documentation!
  * The ARM documentation uses the term &quot;DCLK is asserted while in the TAP_IDLE
  * state&quot;. With hardware there is no such thing as *while* in a state. There
  * are only edges. So clk =&gt; 0 is in fact a very subtle state transition that
@@ -76,7 +76,7 @@
 
 static void bitbang_state_move(int skip)
 {
-	int i=0, tms=0;
+	int i = 0, tms = 0;
 	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
@@ -188,24 +188,24 @@
 
 	for (bit_cnt = 0; bit_cnt &lt; scan_size; bit_cnt++)
 	{
-		int val=0;
-		int tms=(bit_cnt == scan_size-1) ? 1 : 0;
+		int val = 0;
+		int tms = (bit_cnt == scan_size-1) ? 1 : 0;
 		int tdi;
-		int bytec=bit_cnt/8;
-		int bcval=1 &lt;&lt; (bit_cnt % 8);
+		int bytec = bit_cnt/8;
+		int bcval = 1 &lt;&lt; (bit_cnt % 8);
 
 		/* if we're just reading the scan, but don't care about the output
 		 * default to outputting 'low', this also makes valgrind traces more readable,
 		 * as it removes the dependency on an uninitialised value
 		 */
-		tdi=0;
+		tdi = 0;
 		if ((type != SCAN_IN) &amp;&amp; (buffer[bytec] &amp; bcval))
-			tdi=1;
+			tdi = 1;
 
 		bitbang_interface-&gt;write(0, tms, tdi);
 
 		if (type != SCAN_OUT)
-			val=bitbang_interface-&gt;read();
+			val = bitbang_interface-&gt;read();
 
 		bitbang_interface-&gt;write(1, tms, tdi);
 

Modified: trunk/src/jtag/commands.c
===================================================================
--- trunk/src/jtag/commands.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/commands.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -117,7 +117,7 @@
 	offset = (*p_page)-&gt;used;
 	(*p_page)-&gt;used += size;
 
-	t=(uint8_t *)((*p_page)-&gt;address);
+	t = (uint8_t *)((*p_page)-&gt;address);
 	return t + offset;
 }
 

Modified: trunk/src/jtag/commands.h
===================================================================
--- trunk/src/jtag/commands.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/commands.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -90,9 +90,9 @@
 
 typedef struct reset_command_s
 {
-	/// Set TRST output: 0=deassert, 1=assert, -1=no change
+	/// Set TRST output: 0 = deassert, 1 = assert, -1 = no change
 	int trst;
-	/// Set SRST output: 0=deassert, 1=assert, -1=no change
+	/// Set SRST output: 0 = deassert, 1 = assert, -1 = no change
 	int srst;
 } reset_command_t;
 

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/core.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -333,8 +333,8 @@
 			/* if we are to run a verification of the ir scan, we need to get the input back.
 			 * We may have to allocate space if the caller didn't ask for the input back.
 			 */
-			in_fields[j].check_value=in_fields[j].tap-&gt;expected;
-			in_fields[j].check_mask=in_fields[j].tap-&gt;expected_mask;
+			in_fields[j].check_value = in_fields[j].tap-&gt;expected;
+			in_fields[j].check_mask = in_fields[j].tap-&gt;expected_mask;
 		}
 		jtag_add_scan_check(jtag_add_ir_scan_noverify, in_num_fields, in_fields, state);
 	} else
@@ -754,7 +754,7 @@
 
 	jtag_execute_queue_noclear();
 
-	int retval=jtag_check_value_inner(field-&gt;in_value, value, mask, field-&gt;num_bits);
+	int retval = jtag_check_value_inner(field-&gt;in_value, value, mask, field-&gt;num_bits);
 	jtag_set_error(retval);
 }
 
@@ -1157,7 +1157,7 @@
 	}
 
 	jtag_add_tlr();
-	if ((retval=jtag_execute_queue()) != ERROR_OK)
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	/* examine chain first, as this could discover the real chain layout */
@@ -1192,7 +1192,7 @@
 {
 	int retval;
 
-	if ((retval=jtag_interface_init(cmd_ctx)) != ERROR_OK)
+	if ((retval = jtag_interface_init(cmd_ctx)) != ERROR_OK)
 		return retval;
 
 	LOG_DEBUG(&quot;Trying to bring the JTAG controller to life by asserting TRST / RESET&quot;);
@@ -1236,7 +1236,7 @@
 int jtag_init(struct command_context_s *cmd_ctx)
 {
 	int retval;
-	if ((retval=jtag_interface_init(cmd_ctx)) != ERROR_OK)
+	if ((retval = jtag_interface_init(cmd_ctx)) != ERROR_OK)
 		return retval;
 	if (jtag_init_inner(cmd_ctx) == ERROR_OK)
 	{

Modified: trunk/src/jtag/driver.c
===================================================================
--- trunk/src/jtag/driver.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/driver.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -467,23 +467,23 @@
 /* add callback to end of queue */
 void interface_jtag_add_callback4(jtag_callback_t callback, jtag_callback_data_t data0, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
 {
-	struct jtag_callback_entry *entry=cmd_queue_alloc(sizeof(struct jtag_callback_entry));
+	struct jtag_callback_entry *entry = cmd_queue_alloc(sizeof(struct jtag_callback_entry));
 
-	entry-&gt;next=NULL;
-	entry-&gt;callback=callback;
-	entry-&gt;data0=data0;
-	entry-&gt;data1=data1;
-	entry-&gt;data2=data2;
-	entry-&gt;data3=data3;
+	entry-&gt;next = NULL;
+	entry-&gt;callback = callback;
+	entry-&gt;data0 = data0;
+	entry-&gt;data1 = data1;
+	entry-&gt;data2 = data2;
+	entry-&gt;data3 = data3;
 
 	if (jtag_callback_queue_head == NULL)
 	{
-		jtag_callback_queue_head=entry;
-		jtag_callback_queue_tail=entry;
+		jtag_callback_queue_head = entry;
+		jtag_callback_queue_tail = entry;
 	} else
 	{
-		jtag_callback_queue_tail-&gt;next=entry;
-		jtag_callback_queue_tail=entry;
+		jtag_callback_queue_tail-&gt;next = entry;
+		jtag_callback_queue_tail = entry;
 	}
 }
 
@@ -493,9 +493,9 @@
 	if (retval == ERROR_OK)
 	{
 		struct jtag_callback_entry *entry;
-		for (entry=jtag_callback_queue_head; entry != NULL; entry=entry-&gt;next)
+		for (entry = jtag_callback_queue_head; entry != NULL; entry = entry-&gt;next)
 		{
-			retval=entry-&gt;callback(entry-&gt;data0, entry-&gt;data1, entry-&gt;data2, entry-&gt;data3);
+			retval = entry-&gt;callback(entry-&gt;data0, entry-&gt;data1, entry-&gt;data2, entry-&gt;data3);
 			if (retval != ERROR_OK)
 				break;
 		}

Modified: trunk/src/jtag/dummy.c
===================================================================
--- trunk/src/jtag/dummy.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/dummy.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -133,11 +133,11 @@
 {
 	if (khz == 0)
 	{
-		*jtag_speed=0;
+		*jtag_speed = 0;
 	}
 	else
 	{
-		*jtag_speed=64000/khz;
+		*jtag_speed = 64000/khz;
 	}
 	return ERROR_OK;
 }
@@ -150,7 +150,7 @@
 	}
 	else
 	{
-		*khz=64000/speed;
+		*khz = 64000/speed;
 	}
 
 	return ERROR_OK;

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/ft2232.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -257,7 +257,7 @@
 
 	assert(tms_count &gt; 0);
 
-//	LOG_DEBUG(&quot;mpsse cmd=%02x, tms_bits=0x%08x, bit_count=%d&quot;, mpsse_cmd, tms_bits, tms_count);
+//	LOG_DEBUG(&quot;mpsse cmd=%02x, tms_bits = 0x%08x, bit_count=%d&quot;, mpsse_cmd, tms_bits, tms_count);
 
 	for (tms_byte = tms_ndx = i = 0;   i &lt; tms_count;   ++i, tms_bits&gt;&gt;=1)
 	{
@@ -470,7 +470,7 @@
 	ft2232_adaptive_clocking(speed);
 
 	buf[0] = 0x86;			/* command &quot;set divisor&quot; */
-	buf[1] = speed &amp; 0xff;          /* valueL (0=6MHz, 1=3MHz, 2=2.0MHz, ...*/
+	buf[1] = speed &amp; 0xff;          /* valueL (0 = 6MHz, 1 = 3MHz, 2 = 2.0MHz, ...*/
 	buf[2] = (speed &gt;&gt; 8) &amp; 0xff;   /* valueH */
 
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
@@ -623,8 +623,8 @@
 	int             scan_size;
 	enum scan_type  type;
 	int             retval;
-	uint32_t             bytes_written=0;
-	uint32_t             bytes_read=0;
+	uint32_t             bytes_written = 0;
+	uint32_t             bytes_read = 0;
 
 #ifdef _DEBUG_USB_IO_
 	struct timeval  start, inter, inter2, end;
@@ -2194,8 +2194,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, xRST high) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, xRST high) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2218,8 +2218,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2289,8 +2289,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2372,8 +2372,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2440,8 +2440,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE[12]=out, n[ST]srst=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE[12]=out, n[ST]srst = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2487,8 +2487,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2528,8 +2528,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2572,8 +2572,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2616,8 +2616,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in */
+	buf[1] = low_output; /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
@@ -2667,8 +2667,8 @@
 
 	/* initialize low byte for jtag */
 	buf[0] = 0x80;          /* command &quot;set data bits low byte&quot; */
-	buf[1] = low_output;    /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
-	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
+	buf[1] = low_output;    /* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction; /* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))

Modified: trunk/src/jtag/gw16012.c
===================================================================
--- trunk/src/jtag/gw16012.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/gw16012.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -196,7 +196,7 @@
 
 static void gw16012_state_move(void)
 {
-	int i=0, tms=0;
+	int i = 0, tms = 0;
 	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 

Modified: trunk/src/jtag/interface.h
===================================================================
--- trunk/src/jtag/interface.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/interface.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -228,7 +228,7 @@
 	int (*quit)(void);
 
 	/**
-	 * Returns JTAG maxium speed for KHz. 0=RTCK. The function returns
+	 * Returns JTAG maxium speed for KHz. 0 = RTCK. The function returns
 	 *  a failure if it can't support the KHz/RTCK.
 	 *
 	 *  WARNING!!!! if RTCK is *slow* then think carefully about

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/jlink.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -669,7 +669,7 @@
 /* J-Link tap functions */
 
 
-static unsigned tap_length=0;
+static unsigned tap_length = 0;
 static uint8_t tms_buffer[JLINK_TAP_BUFFER_SIZE];
 static uint8_t tdi_buffer[JLINK_TAP_BUFFER_SIZE];
 static uint8_t tdo_buffer[JLINK_TAP_BUFFER_SIZE];
@@ -931,13 +931,13 @@
 		result2 = jlink_usb_read_emu_result(jlink_jtag);
 		if (1 != result2)
 		{
-			LOG_ERROR(&quot;jlink_usb_read_emu_result retried requested=1, result=%d, in_length=%i&quot;, result2,in_length);
+			LOG_ERROR(&quot;jlink_usb_read_emu_result retried requested = 1, result=%d, in_length=%i&quot;, result2,in_length);
 			/* Try again once, should only happen if (in_length%64 == 0) */
 			result2 = jlink_usb_read_emu_result(jlink_jtag);
 			if (1 != result2)
 			{
 				LOG_ERROR(&quot;jlink_usb_read_emu_result failed &quot;
-					&quot;(requested=1, result=%d)&quot;, result2);
+					&quot;(requested = 1, result=%d)&quot;, result2);
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 		}

Modified: trunk/src/jtag/minidummy/minidummy.c
===================================================================
--- trunk/src/jtag/minidummy/minidummy.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/minidummy/minidummy.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -145,7 +145,7 @@
 
 	state_count = 0;
 
-	tap_state_t cur_state=cmd_queue_cur_state;
+	tap_state_t cur_state = cmd_queue_cur_state;
 
 	while (num_states)
 	{

Modified: trunk/src/jtag/parport.c
===================================================================
--- trunk/src/jtag/parport.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/parport.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -344,7 +344,7 @@
 	LOG_DEBUG(&quot;...open&quot;);
 
 #if !defined(__FreeBSD__) &amp;&amp; !defined(__FreeBSD_kernel__)
-	i=ioctl(device_handle, PPCLAIM);
+	i = ioctl(device_handle, PPCLAIM);
 	if (i&lt;0)
 	{
 		LOG_ERROR(&quot;cannot claim device&quot;);

Modified: trunk/src/jtag/presto.c
===================================================================
--- trunk/src/jtag/presto.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/presto.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -292,7 +292,7 @@
 
 		presto_data = 0;
 		for (i = 0; i &lt; 4 * 62; i++)
-			if ((presto-&gt;status=FT_Write(presto-&gt;handle, &amp;presto_data, 1, &amp;ftbytes)) != FT_OK)
+			if ((presto-&gt;status = FT_Write(presto-&gt;handle, &amp;presto_data, 1, &amp;ftbytes)) != FT_OK)
 				return ERROR_JTAG_DEVICE_ERROR;
 
 		usleep(100000);
@@ -407,21 +407,21 @@
 
 static int presto_open(char *req_serial)
 {
-	presto-&gt;buff_out_pos=0;
-	presto-&gt;buff_in_pos=0;
-	presto-&gt;buff_in_len=0;
-	presto-&gt;buff_in_exp=0;
+	presto-&gt;buff_out_pos = 0;
+	presto-&gt;buff_in_pos = 0;
+	presto-&gt;buff_in_len = 0;
+	presto-&gt;buff_in_exp = 0;
 
-	presto-&gt;total_out=0;
-	presto-&gt;total_in=0;
+	presto-&gt;total_out = 0;
+	presto-&gt;total_in = 0;
 
-	presto-&gt;jtag_tms=0;
-	presto-&gt;jtag_tck=0;
-	presto-&gt;jtag_rst=0;
-	presto-&gt;jtag_tdi_data=0;
-	presto-&gt;jtag_tdi_count=0;
+	presto-&gt;jtag_tms = 0;
+	presto-&gt;jtag_tck = 0;
+	presto-&gt;jtag_rst = 0;
+	presto-&gt;jtag_tdi_data = 0;
+	presto-&gt;jtag_tdi_count = 0;
 
-	presto-&gt;jtag_speed=0;
+	presto-&gt;jtag_speed = 0;
 
 #if BUILD_PRESTO_FTD2XX == 1
 	return presto_open_ftd2xx(req_serial);
@@ -625,14 +625,14 @@
 	}
 
 	/* delay with TCK low */
-	for (i=presto-&gt;jtag_speed; i&gt;1; i--)
+	for (i = presto-&gt;jtag_speed; i&gt;1; i--)
 		presto_sendbyte(cmd);
 
 	cmd |= 0x04;
 	presto_sendbyte(cmd | (tdo_req ? 0x10 : 0));
 
 	/* delay with TCK high */
-	for (i=presto-&gt;jtag_speed; i&gt;1; i--)
+	for (i = presto-&gt;jtag_speed; i&gt;1; i--)
 		presto_sendbyte(cmd);
 
 	presto-&gt;jtag_tck = 1;
@@ -707,7 +707,7 @@
 {
 	if (khz &lt; 0)
 	{
-		*jtag_speed=0;
+		*jtag_speed = 0;
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
@@ -721,7 +721,7 @@
 {
 	if ((speed &lt; 0) || (speed &gt; 1000))
 	{
-		*khz=0;
+		*khz = 0;
 		return ERROR_INVALID_ARGUMENTS;
 	}
 

Modified: trunk/src/jtag/rlink/rlink.c
===================================================================
--- trunk/src/jtag/rlink/rlink.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/rlink/rlink.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -915,7 +915,7 @@
 static
 void rlink_state_move(void) {
 
-	int i=0, tms=0;
+	int i = 0, tms = 0;
 	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
@@ -1131,7 +1131,7 @@
 
 
 #if 0
-	printf(&quot;scan_size = %d, type=0x%x\n&quot;, scan_size, type);
+	printf(&quot;scan_size = %d, type = 0x%x\n&quot;, scan_size, type);
 	{
 		int   i;
 
@@ -1620,8 +1620,8 @@
 	struct usb_bus *busses;
 	struct usb_bus *bus;
 	int i, j, retries;
-	int found=0;
-	int success=0;
+	int found = 0;
+	int success = 0;
 	uint8_t reply_buffer[USB_EP1IN_SIZE];
 
 	usb_init();
@@ -1654,7 +1654,7 @@
 						break;
 					}
 
-					pHDev=usb_open(dev);
+					pHDev = usb_open(dev);
 					if ( !pHDev )
 						LOG_ERROR (&quot;Failed to open device.\n&quot;);
 					else
@@ -1692,7 +1692,7 @@
 								break;
 							}
 							else
-								success=1;
+								success = 1;
 						}
 					}
 				} while (0);

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/tcl.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -721,13 +721,13 @@
 
 static int default_power_dropout(int *dropout)
 {
-	*dropout=0; /* by default we can't detect power dropout */
+	*dropout = 0; /* by default we can't detect power dropout */
 	return ERROR_OK;
 }
 
 static int default_srst_asserted(int *srst_asserted)
 {
-	*srst_asserted=0; /* by default we can't detect srst asserted */
+	*srst_asserted = 0; /* by default we can't detect srst asserted */
 	return ERROR_OK;
 }
 
@@ -1331,7 +1331,7 @@
 		return JIM_ERR;
 	}
 
-	num_fields=(argc-2)/2;
+	num_fields = (argc-2)/2;
 	fields = malloc(sizeof(scan_field_t) * num_fields);
 	for (i = 2; i &lt; argc; i += 2)
 	{
@@ -1359,7 +1359,7 @@
 		return JIM_ERR;
 	}
 
-	field_count=0;
+	field_count = 0;
 	Jim_Obj *list = Jim_NewListObj(interp, NULL, 0);
 	for (i = 2; i &lt; argc; i += 2)
 	{
@@ -1396,7 +1396,7 @@
 	script_debug(interp, &quot;pathmove&quot;, argc, args);
 
 	int i;
-	for (i=0; i&lt;argc-1; i++)
+	for (i = 0; i&lt;argc-1; i++)
 	{
 		const char *cp;
 		cp = Jim_GetString( args[i+1], NULL );

Modified: trunk/src/jtag/usbprog.c
===================================================================
--- trunk/src/jtag/usbprog.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/usbprog.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -370,7 +370,7 @@
 
 static void usbprog_write(int tck, int tms, int tdi)
 {
-	unsigned char output_value=0x00;
+	unsigned char output_value = 0x00;
 
 	if (tms)
 		output_value |= (1 &lt;&lt; TMS_BIT);

Modified: trunk/src/jtag/zy1000/jtag_minidriver.h
===================================================================
--- trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -28,7 +28,7 @@
 #if 0
 int  diag_printf( const char *fmt, ... );
 #define ZY1000_POKE(a, b) HAL_WRITE_UINT32(a, b); diag_printf(&quot;poke 0x%08x,0x%08x\n&quot;, a, b)
-#define ZY1000_PEEK(a, b) HAL_READ_UINT32(a, b); diag_printf(&quot;peek 0x%08x=0x%08x\n&quot;, a, b)
+#define ZY1000_PEEK(a, b) HAL_READ_UINT32(a, b); diag_printf(&quot;peek 0x%08x = 0x%08x\n&quot;, a, b)
 #else
 #define ZY1000_POKE(a, b) HAL_WRITE_UINT32(a, b)
 #define ZY1000_PEEK(a, b) HAL_READ_UINT32(a, b)
@@ -62,15 +62,15 @@
 static void setCurrentState(enum tap_state state)
 {
 	cyg_uint32 a;
-	a=state;
-	int repeat=0;
+	a = state;
+	int repeat = 0;
 	if (state == TAP_RESET)
 	{
 		// The FPGA nor we know the current state of the CPU TAP
 		// controller. This will move it to TAP for sure.
 		//
 		// 5 should be enough here, 7 is what OpenOCD uses
-		repeat=7;
+		repeat = 7;
 	}
 	waitQueue();
 	sampleShiftRegister();
@@ -85,8 +85,8 @@
 static __inline__ void shiftValueInner(const enum tap_state state, const enum tap_state endState, int repeat, cyg_uint32 value)
 {
 	cyg_uint32 a,b;
-	a=state;
-	b=endState;
+	a = state;
+	b = endState;
 	waitQueue();
 	sampleShiftRegister();
 	ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value);
@@ -96,13 +96,13 @@
 	{
 		int i;
 		setCurrentState(state);
-		for (i=0; i&lt;repeat; i++)
+		for (i = 0; i&lt;repeat; i++)
 		{
 			int tms;
-			tms=0;
+			tms = 0;
 			if ((i == repeat-1) &amp;&amp; (state != endState))
 			{
-				tms=1;
+				tms = 1;
 			}
 			/* shift out value */
 			waitIdle();
@@ -128,7 +128,7 @@
 	{
 		int i;
 		/* sample shift register for every bit. */
-		for (i=0; i&lt;repeat-1; i++)
+		for (i = 0; i&lt;repeat-1; i++)
 		{
 			sampleShiftRegister();
 			ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value &gt;&gt; i);
@@ -157,9 +157,9 @@
 	enum tap_state pause_state = TAP_DRSHIFT;
 
 	jtag_tap_t *tap, *nextTap;
-	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap=nextTap)
+	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
-		nextTap=jtag_tap_next_enabled(tap);
+		nextTap = jtag_tap_next_enabled(tap);
 		if (nextTap == NULL)
 		{
 			pause_state = end_state;
@@ -167,7 +167,7 @@
 		if (tap == target_tap)
 		{
 			int j;
-			for (j=0; j&lt;(num_fields-1); j++)
+			for (j = 0; j&lt;(num_fields-1); j++)
 			{
 				shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, num_bits[j], value[j]);
 			}
@@ -187,7 +187,7 @@
 		enum tap_state end_state)
 {
 
-	int singletap=(jtag_tap_next_enabled(jtag_tap_next_enabled(NULL)) == NULL);
+	int singletap = (jtag_tap_next_enabled(jtag_tap_next_enabled(NULL)) == NULL);
 	if ((singletap) &amp;&amp; (num_fields == 3))
 	{
 		/* used by embeddedice_write_reg_inner() */

Modified: trunk/src/jtag/zy1000/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -51,11 +51,11 @@
 {
 	if (khz == 0)
 	{
-		*jtag_speed=0;
+		*jtag_speed = 0;
 	}
 	else
 	{
-		*jtag_speed=64000/khz;
+		*jtag_speed = 64000/khz;
 	}
 	return ERROR_OK;
 }
@@ -68,7 +68,7 @@
 	}
 	else
 	{
-		*khz=64000/speed;
+		*khz = 64000/speed;
 	}
 
 	return ERROR_OK;
@@ -99,13 +99,13 @@
 
 static int zy1000_srst_asserted(int *srst_asserted)
 {
-	*srst_asserted=readSRST();
+	*srst_asserted = readSRST();
 	return ERROR_OK;
 }
 
 static int zy1000_power_dropout(int *dropout)
 {
-	*dropout=readPowerDropout();
+	*dropout = readPowerDropout();
 	return ERROR_OK;
 }
 
@@ -164,7 +164,7 @@
 	if (!srst)
 	{
 		int i;
-		for (i=0; i&lt;1000; i++)
+		for (i = 0; i&lt;1000; i++)
 		{
 			// We don't want to sense our own reset, so we clear here.
 			// There is of course a timing hole where we could loose
@@ -260,11 +260,11 @@
 	if ((argc &lt; 1) || (argc &gt; 2))
 		return JIM_ERR;
 	char buff[128];
-	const char *version_str=NULL;
+	const char *version_str = NULL;
 
 	if (argc == 1)
 	{
-		version_str=ZYLIN_OPENOCD_VERSION;
+		version_str = ZYLIN_OPENOCD_VERSION;
 	} else
 	{
 		const char *str = Jim_GetString(argv[1], NULL);
@@ -273,15 +273,15 @@
 			int revision;
 			revision = atol(ZYLIN_OPENOCD+strlen(&quot;XRevision: &quot;));
 			sprintf(buff, &quot;%d&quot;, revision);
-			version_str=buff;
+			version_str = buff;
 		}
 		else if (strcmp(&quot;zy1000&quot;, str) == 0)
 		{
-			version_str=ZYLIN_VERSION;
+			version_str = ZYLIN_VERSION;
 		}
 		else if (strcmp(&quot;date&quot;, str) == 0)
 		{
-			version_str=ZYLIN_DATE;
+			version_str = ZYLIN_DATE;
 		}
 		else
 		{
@@ -402,8 +402,8 @@
 {
 	VERBOSE(LOG_INFO(&quot;shiftValueInner %s %s %d %08x (flipped)&quot;, tap_state_name(state), tap_state_name(endState), repeat, value));
 	cyg_uint32 a,b;
-	a=state;
-	b=endState;
+	a = state;
+	b = endState;
 	ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value);
 	ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (1 &lt;&lt; 15)|(repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
 	VERBOSE(getShiftValueFlip());
@@ -422,40 +422,40 @@
 	{
 		cyg_uint32 value;
 
-		uint8_t *inBuffer=NULL;
+		uint8_t *inBuffer = NULL;
 
 
 		// figure out where to store the input data
-		int num_bits=fields[i].num_bits;
+		int num_bits = fields[i].num_bits;
 		if (fields[i].in_value != NULL)
 		{
-			inBuffer=fields[i].in_value;
+			inBuffer = fields[i].in_value;
 		}
 
 		// here we shuffle N bits out/in
-		j=0;
+		j = 0;
 		while (j&lt;num_bits)
 		{
 			tap_state_t pause_state;
 			int l;
-			k=num_bits-j;
-			pause_state=(shiftState == TAP_DRSHIFT)?TAP_DRSHIFT:TAP_IRSHIFT;
+			k = num_bits-j;
+			pause_state = (shiftState == TAP_DRSHIFT)?TAP_DRSHIFT:TAP_IRSHIFT;
 			if (k&gt;32)
 			{
-				k=32;
+				k = 32;
 				/* we have more to shift out */
 			} else if (i == num_fields-1)
 			{
 				/* this was the last to shift out this time */
-				pause_state=end_state;
+				pause_state = end_state;
 			}
 
 			// we have (num_bits+7)/8 bytes of bits to toggle out.
 			// bits are pushed out LSB to MSB
-			value=0;
+			value = 0;
 			if (fields[i].out_value != NULL)
 			{
-				for (l=0; l&lt;k; l += 8)
+				for (l = 0; l&lt;k; l += 8)
 				{
 					value|=fields[i].out_value[(j+l)/8]&lt;&lt;l;
 				}
@@ -468,11 +468,11 @@
 			if (inBuffer != NULL)
 			{
 				// data in, LSB to MSB
-				value=getShiftValue();
+				value = getShiftValue();
 				// we're shifting in data to MSB, shift data to be aligned for returning the value
 				value &gt;&gt;= 32-k;
 
-				for (l=0; l&lt;k; l += 8)
+				for (l = 0; l&lt;k; l += 8)
 				{
 					inBuffer[(j+l)/8]=(value &gt;&gt; l)&amp;0xff;
 				}
@@ -494,9 +494,9 @@
 	int j;
 	int scan_size = 0;
 	jtag_tap_t *tap, *nextTap;
-	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap=nextTap)
+	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
-		nextTap=jtag_tap_next_enabled(tap);
+		nextTap = jtag_tap_next_enabled(tap);
 		tap_state_t end_state;
 		if (nextTap == NULL)
 		{
@@ -511,7 +511,7 @@
 		scan_size = tap-&gt;ir_length;
 
 		/* search the list */
-		for (j=0; j &lt; num_fields; j++)
+		for (j = 0; j &lt; num_fields; j++)
 		{
 			if (tap == fields[j].tap)
 			{
@@ -563,10 +563,10 @@
 
 	int j;
 	jtag_tap_t *tap, *nextTap;
-	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap=nextTap)
+	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap = nextTap)
 	{
-		nextTap=jtag_tap_next_enabled(tap);
-		int found=0;
+		nextTap = jtag_tap_next_enabled(tap);
+		int found = 0;
 		tap_state_t end_state;
 		if (nextTap == NULL)
 		{
@@ -576,7 +576,7 @@
 			end_state = TAP_DRSHIFT;
 		}
 
-		for (j=0; j &lt; num_fields; j++)
+		for (j = 0; j &lt; num_fields; j++)
 		{
 			if (tap == fields[j].tap)
 			{
@@ -634,13 +634,13 @@
 
 	/* execute num_cycles, 32 at the time. */
 	int i;
-	for (i=0; i&lt;num_cycles; i += 32)
+	for (i = 0; i&lt;num_cycles; i += 32)
 	{
 		int num;
-		num=32;
+		num = 32;
 		if (num_cycles-i&lt;num)
 		{
-			num=num_cycles-i;
+			num = num_cycles-i;
 		}
 		shiftValueInner(clockstate, clockstate, num, 0);
 	}
@@ -649,7 +649,7 @@
 	/* finish in end_state */
 	setCurrentState(state);
 #else
-	tap_state_t t=TAP_IDLE;
+	tap_state_t t = TAP_IDLE;
 	/* test manual drive code on any target */
 	int tms;
 	uint8_t tms_scan = tap_get_tms_path(t, state);
@@ -695,7 +695,7 @@
 
 	state_count = 0;
 
-	tap_state_t cur_state=cmd_queue_cur_state;
+	tap_state_t cur_state = cmd_queue_cur_state;
 
 	while (num_states)
 	{
@@ -730,8 +730,8 @@
 
 void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, uint8_t *buffer, int little, int count)
 {
-//	static int const reg_addr=0x5;
-	tap_state_t end_state=jtag_get_end_state();
+//	static int const reg_addr = 0x5;
+	tap_state_t end_state = jtag_get_end_state();
 	if (jtag_tap_next_enabled(jtag_tap_next_enabled(NULL)) == NULL)
 	{
 		/* better performance via code duplication */

Modified: trunk/src/openocd.c
===================================================================
--- trunk/src/openocd.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/openocd.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -87,10 +87,10 @@
 	switch (event)
 	{
 		case TARGET_EVENT_GDB_START:
-			target-&gt;display=0;
+			target-&gt;display = 0;
 			break;
 		case TARGET_EVENT_GDB_END:
-			target-&gt;display=1;
+			target-&gt;display = 1;
 			break;
 		case TARGET_EVENT_HALTED:
 			if (target-&gt;display)
@@ -116,11 +116,11 @@
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	int retval;
-	static int initialized=0;
+	static int initialized = 0;
 	if (initialized)
 		return ERROR_OK;
 
-	initialized=1;
+	initialized = 1;
 
 	atexit(exit_handler);
 
@@ -128,7 +128,7 @@
 		return ERROR_FAIL;
 	LOG_DEBUG(&quot;target init complete&quot;);
 
-	if ((retval=jtag_interface_init(cmd_ctx)) != ERROR_OK)
+	if ((retval = jtag_interface_init(cmd_ctx)) != ERROR_OK)
 	{
 		/* we must be able to set up the jtag interface */
 		return retval;

Modified: trunk/src/pld/virtex2.c
===================================================================
--- trunk/src/pld/virtex2.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/pld/virtex2.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -90,7 +90,7 @@
 
 static __inline__ void virtexflip32(jtag_callback_data_t arg)
 {
-  uint8_t *in=(uint8_t *)arg;
+  uint8_t *in = (uint8_t *)arg;
 	*((uint32_t *)in) = flip_u32(le_to_h_u32(in), 32);
 }
 

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/server/gdb_server.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -107,7 +107,7 @@
 	int t;
 	if (got_data == NULL)
 		got_data=&t;
-	*got_data=0;
+	*got_data = 0;
 
 	if (gdb_con-&gt;buf_cnt&gt;0)
 	{
@@ -133,14 +133,14 @@
 			return ERROR_OK;
 		}
 	}
-	*got_data=FD_ISSET(connection-&gt;fd, &amp;read_fds) != 0;
+	*got_data = FD_ISSET(connection-&gt;fd, &amp;read_fds) != 0;
 	return ERROR_OK;
 }
 
 int gdb_get_char(connection_t *connection, int* next_char)
 {
 	gdb_connection_t *gdb_con = connection-&gt;priv;
-	int retval=ERROR_OK;
+	int retval = ERROR_OK;
 
 #ifdef _DEBUG_GDB_IO_
 	char *debug_buffer;
@@ -313,7 +313,7 @@
 	int gotdata;
 	for (;;)
 	{
-		if ((retval=check_pending(connection, 0, &amp;gotdata)) != ERROR_OK)
+		if ((retval = check_pending(connection, 0, &amp;gotdata)) != ERROR_OK)
 			return retval;
 		if (!gotdata)
 			break;
@@ -409,7 +409,7 @@
 			} else {
 
 				LOG_ERROR(&quot;unknown character(1) 0x%2.2x in reply, dropping connection&quot;, reply);
-				gdb_con-&gt;closed=1;
+				gdb_con-&gt;closed = 1;
 				return ERROR_SERVER_REMOTE_CLOSED;
 			}
 		}
@@ -421,7 +421,7 @@
 		else
 		{
 			LOG_ERROR(&quot;unknown character(2) 0x%2.2x in reply, dropping connection&quot;, reply);
-			gdb_con-&gt;closed=1;
+			gdb_con-&gt;closed = 1;
 			return ERROR_SERVER_REMOTE_CLOSED;
 		}
 	}
@@ -547,7 +547,7 @@
 
 	if (!noack)
 	{
-		*checksum_ok=(my_checksum == strtoul(checksum, NULL, 16));
+		*checksum_ok = (my_checksum == strtoul(checksum, NULL, 16));
 	}
 
 	return ERROR_OK;
@@ -600,11 +600,11 @@
 		 */
 		if (gdb_con-&gt;noack_mode)
 		{
-			if ((retval=fetch_packet(connection, &amp;checksum_ok, 1, len, buffer)) != ERROR_OK)
+			if ((retval = fetch_packet(connection, &amp;checksum_ok, 1, len, buffer)) != ERROR_OK)
 				return retval;
 		} else
 		{
-			if ((retval=fetch_packet(connection, &amp;checksum_ok, 0, len, buffer)) != ERROR_OK)
+			if ((retval = fetch_packet(connection, &amp;checksum_ok, 0, len, buffer)) != ERROR_OK)
 				return retval;
 		}
 
@@ -649,7 +649,7 @@
 		return ERROR_GDB_BUFFER_TOO_SMALL;
 
 	hex_buffer[0] = 'O';
-	for (i=0; i&lt;bin_size; i++)
+	for (i = 0; i&lt;bin_size; i++)
 		snprintf(hex_buffer + 1 + i*2, 3, &quot;%2.2x&quot;, line[i]);
 	hex_buffer[bin_size*2+1] = 0;
 
@@ -904,7 +904,7 @@
 	{
 		return c-'0';
 	}
-	c=toupper(c);
+	c = toupper(c);
 	if (c&gt;='A'&amp;&amp;c&lt;='F')
 	{
 		return c-'A'+10;
@@ -1199,7 +1199,7 @@
 		 * gained by involving the user in this problem that hopefully will get resolved
 		 * eventually
 		 *
-		 * <A HREF="http://sourceware.org/cgi-bin/gnatsweb.pl?cmd=view%20audit-trail&amp;database=gdb&amp;pr=2395">http://sourceware.org/cgi-bin/gnatsweb.pl?cmd=view%20audit-trail&amp;database=gdb&amp;pr=2395</A>
+		 * <A HREF="http://sourceware.org/cgi-bin/gnatsweb.pl?cmd">http://sourceware.org/cgi-bin/gnatsweb.pl?cmd</A> = view%20audit-trail&amp;database = gdb&amp;pr = 2395
 		 *
 		 * For now, the default is to fix up things to make current GDB versions work.
 		 * This can be overwritten using the gdb_report_data_abort &lt;'enable'|'disable'&gt; command.
@@ -1268,7 +1268,7 @@
 
 	LOG_DEBUG(&quot;addr: 0x%8.8&quot; PRIx32 &quot;, len: 0x%8.8&quot; PRIx32 &quot;&quot;, addr, len);
 
-	for (i=0; i&lt;len; i++)
+	for (i = 0; i&lt;len; i++)
 	{
 		uint32_t tmp;
 		sscanf(separator + 2*i, &quot;%2&quot; SCNx32 , &amp;tmp);
@@ -1343,7 +1343,7 @@
 {
 	int current = 0;
 	uint32_t address = 0x0;
-	int retval=ERROR_OK;
+	int retval = ERROR_OK;
 
 	LOG_DEBUG(&quot;-&quot;);
 
@@ -1361,7 +1361,7 @@
 	{
 		LOG_DEBUG(&quot;continue&quot;);
 		target_handle_event( target, TARGET_EVENT_OLD_pre_resume );
-		retval=target_resume(target, current, address, 0, 0); /* resume at current address, don't handle breakpoints, not debugging */
+		retval = target_resume(target, current, address, 0, 0); /* resume at current address, don't handle breakpoints, not debugging */
 	}
 	else if (packet[0] == 's')
 	{
@@ -1399,7 +1399,7 @@
 
 	if (gdb_breakpoint_override &amp;&amp; ((bp_type == BKPT_SOFT)||(bp_type == BKPT_HARD)))
 	{
-		bp_type=gdb_breakpoint_override_type;
+		bp_type = gdb_breakpoint_override_type;
 	}
 
 	if (*separator != ',')
@@ -1584,7 +1584,7 @@
 			char *cmd;
 			int i;
 			cmd = malloc((packet_size - 6)/2 + 1);
-			for (i=0; i &lt; (packet_size - 6)/2; i++)
+			for (i = 0; i &lt; (packet_size - 6)/2; i++)
 			{
 				uint32_t tmp;
 				sscanf(packet + 6 + 2*i, &quot;%2&quot; SCNx32 , &amp;tmp);
@@ -1699,10 +1699,10 @@
 		read/write) by default for GDB.
 		GDB does not have a concept of non-cacheable read/write memory.
 		 */
-		flash_bank_t **banks=malloc(sizeof(flash_bank_t *)*flash_get_bank_count());
+		flash_bank_t **banks = malloc(sizeof(flash_bank_t *)*flash_get_bank_count());
 		int i;
 
-		for (i=0; i&lt;flash_get_bank_count(); i++)
+		for (i = 0; i&lt;flash_get_bank_count(); i++)
 		{
 			p = get_flash_bank_by_num(i);
 			if (p == NULL)
@@ -1717,8 +1717,8 @@
 
 		qsort(banks, flash_get_bank_count(), sizeof(flash_bank_t *), compare_bank);
 
-		uint32_t ram_start=0;
-		for (i=0; i&lt;flash_get_bank_count(); i++)
+		uint32_t ram_start = 0;
+		for (i = 0; i&lt;flash_get_bank_count(); i++)
 		{
 			p = banks[i];
 
@@ -1736,7 +1736,7 @@
 				&quot;&lt;property name=\&quot;blocksize\&quot;&gt;0x%x&lt;/property&gt;\n&quot; \
 				&quot;&lt;/memory&gt;\n&quot;, \
 				p-&gt;base, p-&gt;size, blocksize);
-			ram_start=p-&gt;base+p-&gt;size;
+			ram_start = p-&gt;base+p-&gt;size;
 		}
 		if (ram_start != 0)
 		{
@@ -2018,7 +2018,7 @@
 {
 	gdb_service_t *gdb_service = connection-&gt;service-&gt;priv;
 	target_t *target = gdb_service-&gt;target;
-	char *packet=gdb_packet_buffer;
+	char *packet = gdb_packet_buffer;
 	int packet_size;
 	int retval;
 	gdb_connection_t *gdb_con = connection-&gt;priv;
@@ -2108,7 +2108,7 @@
 							gdb_con-&gt;frontend_state = TARGET_RUNNING;
 							log_add_callback(gdb_log_callback, connection);
 							target_call_event_callbacks(target, TARGET_EVENT_GDB_START);
-							int retval=gdb_step_continue_packet(connection, target, packet, packet_size);
+							int retval = gdb_step_continue_packet(connection, target, packet, packet_size);
 							if (retval != ERROR_OK)
 							{
 								/* we'll never receive a halted condition... issue a false one.. */
@@ -2354,10 +2354,10 @@
 		gdb_breakpoint_override = 1;
 		if (strcmp(args[0], &quot;hard&quot;) == 0)
 		{
-			gdb_breakpoint_override_type=BKPT_HARD;
+			gdb_breakpoint_override_type = BKPT_HARD;
 		} else if (strcmp(args[0], &quot;soft&quot;) == 0)
 		{
-			gdb_breakpoint_override_type=BKPT_SOFT;
+			gdb_breakpoint_override_type = BKPT_SOFT;
 		} else if (strcmp(args[0], &quot;disable&quot;) == 0)
 		{
 			gdb_breakpoint_override = 0;

Modified: trunk/src/server/httpd.c
===================================================================
--- trunk/src/server/httpd.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/server/httpd.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -402,7 +402,7 @@
 	if (!*url)
 		url=&quot;index.tcl&quot;;
 
-	const char *file_name=alloc_printf(&quot;%s/%s&quot;, httpd_dir, url);
+	const char *file_name = alloc_printf(&quot;%s/%s&quot;, httpd_dir, url);
 	int result = handle_request(connection, file_name);
 	free((void *)file_name);
 	return result;

Modified: trunk/src/server/server.c
===================================================================
--- trunk/src/server/server.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/server/server.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -51,7 +51,7 @@
 	socklen_t address_size;
 	connection_t *c, **p;
 	int retval;
-	int flag=1;
+	int flag = 1;
 	
 	c = malloc(sizeof(connection_t));
 	c-&gt;fd = -1;
@@ -70,7 +70,7 @@
 		
 		/* This increases performance dramatically for e.g. GDB load which
 		 * does not have a sliding window protocol. */
-		retval=setsockopt(c-&gt;fd,	/* socket affected */
+		retval = setsockopt(c-&gt;fd,	/* socket affected */
 				IPPROTO_TCP,		/* set option at TCP level */
 				TCP_NODELAY,		/* name of option */
 				(char *)&amp;flag,		/* the cast is historical cruft */
@@ -183,7 +183,7 @@
 		}
 		
 #ifndef _WIN32
-		int segsize=65536;
+		int segsize = 65536;
 		setsockopt(c-&gt;fd, IPPROTO_TCP, TCP_MAXSEG,  &amp;segsize, sizeof(int));
 #endif
 		int window_size = 128 * 1024;	

Modified: trunk/src/server/telnet_server.c
===================================================================
--- trunk/src/server/telnet_server.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/server/telnet_server.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -130,7 +130,7 @@
 	/* put the command line to its previous state */
 	telnet_prompt(connection);
 	telnet_write(connection, t_con-&gt;line, t_con-&gt;line_size);
-	for (i=t_con-&gt;line_size; i&gt;t_con-&gt;line_cursor; i--)
+	for (i = t_con-&gt;line_size; i&gt;t_con-&gt;line_cursor; i--)
 		telnet_write(connection, &quot;\b&quot;, 1);
 }
 

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm11_dbgtap.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -237,7 +237,7 @@
 
 	arm11-&gt;last_dscr = dscr;
 
-	*value=dscr;
+	*value = dscr;
 
 	return ERROR_OK;
 }

Modified: trunk/src/target/arm720t.c
===================================================================
--- trunk/src/target/arm720t.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm720t.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -373,9 +373,9 @@
 		return retval;
 	}
 
-	long long then=timeval_ms();
+	long long then = timeval_ms();
 	int timeout;
-	while (!(timeout=((timeval_ms()-then)&gt;1000)))
+	while (!(timeout = ((timeval_ms()-then)&gt;1000)))
 	{
 		if (buf_get_u32(dbg_stat-&gt;value, EICE_DBG_STATUS_DBGACK, 1) == 0)
 		{

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm7_9_common.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -118,11 +118,11 @@
 	/* pick a breakpoint unit */
 	if (!arm7_9-&gt;wp0_used)
 	{
-		arm7_9-&gt;sw_breakpoints_added=1;
+		arm7_9-&gt;sw_breakpoints_added = 1;
 		arm7_9-&gt;wp0_used = 3;
 	} else if (!arm7_9-&gt;wp1_used)
 	{
-		arm7_9-&gt;sw_breakpoints_added=2;
+		arm7_9-&gt;sw_breakpoints_added = 2;
 		arm7_9-&gt;wp1_used = 3;
 	}
 	else
@@ -218,7 +218,7 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
-	int retval=ERROR_OK;
+	int retval = ERROR_OK;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -259,11 +259,11 @@
 			return ERROR_OK;
 		}
 
-		retval=jtag_execute_queue();
+		retval = jtag_execute_queue();
 	}
 	else if (breakpoint-&gt;type == BKPT_SOFT)
 	{
-		if ((retval=arm7_9_set_software_breakpoints(arm7_9)) != ERROR_OK)
+		if ((retval = arm7_9_set_software_breakpoints(arm7_9)) != ERROR_OK)
 			return retval;
 
 		/* did we already set this breakpoint? */
@@ -700,9 +700,9 @@
 	}
 	arm_jtag_set_instr(jtag_info, 0x4, NULL);
 
-	long long then=timeval_ms();
+	long long then = timeval_ms();
 	int timeout;
-	while (!(timeout=((timeval_ms()-then)&gt;1000)))
+	while (!(timeout = ((timeval_ms()-then)&gt;1000)))
 	{
 		/* read debug status register */
 		embeddedice_read_reg(dbg_stat);
@@ -738,7 +738,7 @@
  */
 int arm7_9_execute_fast_sys_speed(struct target_s *target)
 {
-	static int set=0;
+	static int set = 0;
 	static uint8_t check_value[4], check_mask[4];
 
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -764,7 +764,7 @@
 		 * */
 		buf_set_u32(check_value, 0, 32, 0x9);
 		buf_set_u32(check_mask, 0, 32, 0x9);
-		set=1;
+		set = 1;
 	}
 
 	/* read debug status register */
@@ -900,7 +900,7 @@
 		}
 		if ((target-&gt;state == TARGET_RUNNING) || (target-&gt;state == TARGET_RESET))
 		{
-			int check_pc=0;
+			int check_pc = 0;
 			if (target-&gt;state == TARGET_RESET)
 			{
 				if (target-&gt;reset_halt)
@@ -1042,7 +1042,7 @@
  */
 int arm7_9_deassert_reset(target_t *target)
 {
-	int retval=ERROR_OK;
+	int retval = ERROR_OK;
 	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
 		Jim_Nvp_value2name_simple( nvp_target_state,target-&gt;state)-&gt;name);
 
@@ -1057,12 +1057,12 @@
 		if ((retval = target_examine_one(target)) != ERROR_OK)
 			return retval;
 
-		if ((retval=target_poll(target)) != ERROR_OK)
+		if ((retval = target_poll(target)) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if ((retval=target_halt(target)) != ERROR_OK)
+		if ((retval = target_halt(target)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -1147,17 +1147,17 @@
 	int i;
 	int retval;
 
-	if ((retval=target_halt(target)) != ERROR_OK)
+	if ((retval = target_halt(target)) != ERROR_OK)
 		return retval;
 
-	long long then=timeval_ms();
+	long long then = timeval_ms();
 	int timeout;
-	while (!(timeout=((timeval_ms()-then)&gt;1000)))
+	while (!(timeout = ((timeval_ms()-then)&gt;1000)))
 	{
 		if (buf_get_u32(dbg_stat-&gt;value, EICE_DBG_STATUS_DBGACK, 1) != 0)
 			break;
 		embeddedice_read_reg(dbg_stat);
-		if ((retval=jtag_execute_queue()) != ERROR_OK)
+		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		if (debug_level &gt;= 3)
 		{
@@ -1428,7 +1428,7 @@
 	if (armv4_5_mode_to_number(armv4_5-&gt;core_mode)==-1)
 		return ERROR_FAIL;
 
-	for (i=0; i &lt;= 15; i++)
+	for (i = 0; i &lt;= 15; i++)
 	{
 		LOG_DEBUG(&quot;r%i: 0x%8.8&quot; PRIx32 &quot;&quot;, i, context[i]);
 		buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, i).value, 0, 32, context[i]);
@@ -2240,7 +2240,7 @@
 	reg[0] = address;
 	arm7_9-&gt;write_core_regs(target, 0x1, reg);
 
-	int j=0;
+	int j = 0;
 
 	switch (size)
 	{
@@ -2362,7 +2362,7 @@
 	if (armv4_5_mode_to_number(armv4_5-&gt;core_mode)==-1)
 		return ERROR_FAIL;
 
-	for (i=0; i &lt;= last_reg; i++)
+	for (i = 0; i &lt;= last_reg; i++)
 		ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, i).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, i).valid;
 
 	arm7_9-&gt;read_xpsr(target, &amp;cpsr, 0);
@@ -2545,7 +2545,7 @@
 	if (armv4_5_mode_to_number(armv4_5-&gt;core_mode)==-1)
 		return ERROR_FAIL;
 
-	for (i=0; i &lt;= last_reg; i++)
+	for (i = 0; i &lt;= last_reg; i++)
 		ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, i).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, i).valid;
 
 	arm7_9-&gt;read_xpsr(target, &amp;cpsr, 0);
@@ -2576,12 +2576,12 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 
-	if ((retval=target_wait_state(target, TARGET_DEBUG_RUNNING, 500)) != ERROR_OK)
+	if ((retval = target_wait_state(target, TARGET_DEBUG_RUNNING, 500)) != ERROR_OK)
 		return retval;
 
-	int little=target-&gt;endianness == TARGET_LITTLE_ENDIAN;
-	int count=dcc_count;
-	uint8_t *buffer=dcc_buffer;
+	int little = target-&gt;endianness == TARGET_LITTLE_ENDIAN;
+	int count = dcc_count;
+	uint8_t *buffer = dcc_buffer;
 	if (count&gt;2)
 	{
 		/* Handle first &amp; last using standard embeddedice_write_reg and the middle ones w/the
@@ -2669,18 +2669,18 @@
 
 	buf_set_u32(reg_params[0].value, 0, 32, address);
 
-	dcc_count=count;
-	dcc_buffer=buffer;
+	dcc_count = count;
+	dcc_buffer = buffer;
 	retval = armv4_5_run_algorithm_inner(target, 0, NULL, 1, reg_params,
 			arm7_9-&gt;dcc_working_area-&gt;address, arm7_9-&gt;dcc_working_area-&gt;address+6*4, 20*1000, &amp;armv4_5_info, arm7_9_dcc_completion);
 
 	if (retval == ERROR_OK)
 	{
-		uint32_t endaddress=buf_get_u32(reg_params[0].value, 0, 32);
+		uint32_t endaddress = buf_get_u32(reg_params[0].value, 0, 32);
 		if (endaddress != (address+count*4))
 		{
 			LOG_ERROR(&quot;DCC write failed, expected end address 0x%08&quot; PRIx32 &quot; got 0x%0&quot; PRIx32 &quot;&quot;, (address+count*4), endaddress);
-			retval=ERROR_FAIL;
+			retval = ERROR_FAIL;
 		}
 	}
 
@@ -2734,7 +2734,7 @@
 	/* convert flash writing code into a buffer in target endianness */
 	for (i = 0; i &lt; (sizeof(arm7_9_crc_code)/sizeof(uint32_t)); i++)
 	{
-		if ((retval=target_write_u32(target, crc_algorithm-&gt;address + i*sizeof(uint32_t), arm7_9_crc_code[i])) != ERROR_OK)
+		if ((retval = target_write_u32(target, crc_algorithm-&gt;address + i*sizeof(uint32_t), arm7_9_crc_code[i])) != ERROR_OK)
 		{
 			return retval;
 		}

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm7tdmi.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -216,9 +216,9 @@
 
 void arm_endianness(uint8_t *tmp, void *in, int size, int be, int flip)
 {
-	uint32_t readback=le_to_h_u32(tmp);
+	uint32_t readback = le_to_h_u32(tmp);
 	if (flip)
-		readback=flip_u32(readback, 32);
+		readback = flip_u32(readback, 32);
 	switch (size)
 	{
 		case 4:
@@ -247,7 +247,7 @@
 
 static int arm7endianness(jtag_callback_data_t arg, jtag_callback_data_t size, jtag_callback_data_t be, jtag_callback_data_t captured)
 {
-  uint8_t *in=(uint8_t *)arg;
+  uint8_t *in = (uint8_t *)arg;
 	arm_endianness((uint8_t *)captured, in, (int)size, (int)be, 1);
 	return ERROR_OK;
 }
@@ -724,7 +724,7 @@
 	{
 		/* get pointers to arch-specific information */
 		reg_cache_t **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
-		reg_cache_t *t=embeddedice_build_reg_cache(target, arm7_9);
+		reg_cache_t *t = embeddedice_build_reg_cache(target, arm7_9);
 		if (t == NULL)
 			return ERROR_FAIL;
 
@@ -739,13 +739,13 @@
 		}
 		target_set_examined(target);
 	}
-	if ((retval=embeddedice_setup(target)) != ERROR_OK)
+	if ((retval = embeddedice_setup(target)) != ERROR_OK)
 		return retval;
-	if ((retval=arm7_9_setup(target)) != ERROR_OK)
+	if ((retval = arm7_9_setup(target)) != ERROR_OK)
 		return retval;
 	if (arm7_9-&gt;etm_ctx)
 	{
-		if ((retval=etm_setup(target)) != ERROR_OK)
+		if ((retval = etm_setup(target)) != ERROR_OK)
 			return retval;
 	}
 	return ERROR_OK;

Modified: trunk/src/target/arm920t.c
===================================================================
--- trunk/src/target/arm920t.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm920t.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -572,9 +572,9 @@
 		return retval;
 	}
 
-	long long then=timeval_ms();
+	long long then = timeval_ms();
 	int timeout;
-	while (!(timeout=((timeval_ms()-then)&gt;1000)))
+	while (!(timeout = ((timeval_ms()-then)&gt;1000)))
 	{
 		if (buf_get_u32(dbg_stat-&gt;value, EICE_DBG_STATUS_DBGACK, 1) == 0)
 		{

Modified: trunk/src/target/arm926ejs.c
===================================================================
--- trunk/src/target/arm926ejs.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm926ejs.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -317,7 +317,7 @@
 			 * openocd development mailing list if you have hardware
 			 * to donate to look into this problem....
 			 */
-			LOG_ERROR(&quot;mystery debug reason MOE=0xc. Try issuing a resume + halt.&quot;);
+			LOG_ERROR(&quot;mystery debug reason MOE = 0xc. Try issuing a resume + halt.&quot;);
 			target-&gt;debug_reason = DBG_REASON_DBGRQ;
 			retval = ERROR_TARGET_FAILURE;
 			break;
@@ -572,9 +572,9 @@
 		return retval;
 	}
 
-	long long then=timeval_ms();
+	long long then = timeval_ms();
 	int timeout;
-	while (!(timeout=((timeval_ms()-then)&gt;1000)))
+	while (!(timeout = ((timeval_ms()-then)&gt;1000)))
 	{
 		if (buf_get_u32(dbg_stat-&gt;value, EICE_DBG_STATUS_DBGACK, 1) == 0)
 		{

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm9tdmi.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -203,7 +203,7 @@
 
 	if (in)
 	{
-		fields[0].in_value=(uint8_t *)in;
+		fields[0].in_value = (uint8_t *)in;
 		jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
 		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
@@ -294,7 +294,7 @@
 
 static int arm9endianness(jtag_callback_data_t arg, jtag_callback_data_t size, jtag_callback_data_t be, jtag_callback_data_t captured)
 {
-  uint8_t *in=(uint8_t *)arg;
+  uint8_t *in = (uint8_t *)arg;
 	arm_endianness((uint8_t *)captured, in, (int)size, (int)be, 0);
 	return ERROR_OK;
 }
@@ -817,7 +817,7 @@
 		reg_cache_t **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
 		reg_cache_t *t;
 		/* one extra register (vector catch) */
-		t=embeddedice_build_reg_cache(target, arm7_9);
+		t = embeddedice_build_reg_cache(target, arm7_9);
 		if (t == NULL)
 			return ERROR_FAIL;
 		(*cache_p) = t;
@@ -831,13 +831,13 @@
 		}
 		target_set_examined(target);
 	}
-	if ((retval=embeddedice_setup(target)) != ERROR_OK)
+	if ((retval = embeddedice_setup(target)) != ERROR_OK)
 		return retval;
-	if ((retval=arm7_9_setup(target)) != ERROR_OK)
+	if ((retval = arm7_9_setup(target)) != ERROR_OK)
 		return retval;
 	if (arm7_9-&gt;etm_ctx)
 	{
-		if ((retval=etm_setup(target)) != ERROR_OK)
+		if ((retval = etm_setup(target)) != ERROR_OK)
 			return retval;
 	}
 	return ERROR_OK;

Modified: trunk/src/target/arm_adi_v5.c
===================================================================
--- trunk/src/target/arm_adi_v5.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm_adi_v5.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -152,7 +152,7 @@
 		adi_jtag_dp_scan(swjdp, DAP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
 	}
 
-	/* In TRANS_MODE_ATOMIC all DAP_IR_APACC transactions wait for ack=OK/FAULT and the check CTRL_STAT */
+	/* In TRANS_MODE_ATOMIC all DAP_IR_APACC transactions wait for ack = OK/FAULT and the check CTRL_STAT */
 	if ((instr == DAP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
 	{
 		return swjdp_transaction_endcheck(swjdp);
@@ -170,7 +170,7 @@
 		adi_jtag_dp_scan_u32(swjdp, DAP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
 	}
 
-	/* In TRANS_MODE_ATOMIC all DAP_IR_APACC transactions wait for ack=OK/FAULT and then check CTRL_STAT */
+	/* In TRANS_MODE_ATOMIC all DAP_IR_APACC transactions wait for ack = OK/FAULT and then check CTRL_STAT */
 	if ((instr == DAP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
 	{
 		return swjdp_transaction_endcheck(swjdp);
@@ -195,7 +195,7 @@
 
 	<A HREF="https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html">https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html</A>
 	*/
-	if ((retval=jtag_execute_queue()) != ERROR_OK)
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;BUG: Why does this fail the first time????&quot;);
 	}
@@ -203,14 +203,14 @@
 #endif
 
 	scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	if ((retval=jtag_execute_queue()) != ERROR_OK)
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
 
 	if (swjdp-&gt;ack != 2)
 	{
-		long long then=timeval_ms();
+		long long then = timeval_ms();
 		while (swjdp-&gt;ack != 2)
 		{
 			if (swjdp-&gt;ack == 1)
@@ -228,7 +228,7 @@
 			}
 
 			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval=jtag_execute_queue()) != ERROR_OK)
+			if ((retval = jtag_execute_queue()) != ERROR_OK)
 				return retval;
 			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
 		}
@@ -261,19 +261,19 @@
 			/* Clear Sticky Error Bits */
 			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_WRITE, swjdp-&gt;dp_ctrl_stat | SSTICKYORUN | SSTICKYERR, NULL);
 			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval=jtag_execute_queue()) != ERROR_OK)
+			if ((retval = jtag_execute_queue()) != ERROR_OK)
 				return retval;
 
 			LOG_DEBUG(&quot;swjdp: status 0x%&quot; PRIx32 &quot;&quot;, ctrlstat);
 
 			dap_ap_read_reg_u32(swjdp, AP_REG_CSW, &amp;mem_ap_csw);
 			dap_ap_read_reg_u32(swjdp, AP_REG_TAR, &amp;mem_ap_tar);
-			if ((retval=jtag_execute_queue()) != ERROR_OK)
+			if ((retval = jtag_execute_queue()) != ERROR_OK)
 				return retval;
 			LOG_ERROR(&quot;Read MEM_AP_CSW 0x%&quot; PRIx32 &quot;, MEM_AP_TAR 0x%&quot; PRIx32 &quot;&quot;, mem_ap_csw, mem_ap_tar);
 
 		}
-		if ((retval=jtag_execute_queue()) != ERROR_OK)
+		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
@@ -971,7 +971,7 @@
 
 	dap_dp_write_reg(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
 	dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-	if ((retval=jtag_execute_queue()) != ERROR_OK)
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	/* Check that we have debug power domains activated */
@@ -979,7 +979,7 @@
 	{
 		LOG_DEBUG(&quot;swjdp: wait CDBGPWRUPACK&quot;);
 		dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-		if ((retval=jtag_execute_queue()) != ERROR_OK)
+		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
@@ -988,7 +988,7 @@
 	{
 		LOG_DEBUG(&quot;swjdp: wait CSYSPWRUPACK&quot;);
 		dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-		if ((retval=jtag_execute_queue()) != ERROR_OK)
+		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}

Modified: trunk/src/target/arm_jtag.h
===================================================================
--- trunk/src/target/arm_jtag.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/arm_jtag.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -60,14 +60,14 @@
 /* use this as a static so we can inline it in -O3 and refer to it via a pointer  */
 static __inline__ void arm7flip32(jtag_callback_data_t arg)
 {
-  uint8_t *in=(uint8_t *)arg;
-  *((uint32_t *)in)=flip_u32(le_to_h_u32(in), 32);
+  uint8_t *in = (uint8_t *)arg;
+  *((uint32_t *)in) = flip_u32(le_to_h_u32(in), 32);
 }
 
 static __inline__ void arm_le_to_h_u32(jtag_callback_data_t arg)
 {
-  uint8_t *in=(uint8_t *)arg;
-  *((uint32_t *)in)=le_to_h_u32(in);
+  uint8_t *in = (uint8_t *)arg;
+  *((uint32_t *)in) = le_to_h_u32(in);
 }
 
 

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/armv4_5.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -501,9 +501,9 @@
 	}
 	if (target-&gt;state != TARGET_HALTED)
 	{
-		if ((retval=target_halt(target)) != ERROR_OK)
+		if ((retval = target_halt(target)) != ERROR_OK)
 			return retval;
-		if ((retval=target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
+		if ((retval = target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -614,7 +614,7 @@
 		return retval;
 	}
 	int retvaltemp;
-	retval=run_it(target, exit_point, timeout_ms, arch_info);
+	retval = run_it(target, exit_point, timeout_ms, arch_info);
 
 	breakpoint_remove(target, exit_point);
 

Modified: trunk/src/target/armv4_5.h
===================================================================
--- trunk/src/target/armv4_5.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/armv4_5.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -154,7 +154,7 @@
  * Rn: base register
  * List: for each bit in list: store register
  * S: in priviledged mode: store user-mode registers
- * W=1: update the base register. W=0: leave the base register untouched
+ * W = 1: update the base register. W = 0: leave the base register untouched
  */
 #define ARMV4_5_STMIA(Rn, List, S, W)	(0xe8800000 | ((S) &lt;&lt; 22) | ((W) &lt;&lt; 21) | ((Rn) &lt;&lt; 16) | (List))
 
@@ -162,7 +162,7 @@
  * Rn: base register
  * List: for each bit in list: store register
  * S: in priviledged mode: store user-mode registers
- * W=1: update the base register. W=0: leave the base register untouched
+ * W = 1: update the base register. W = 0: leave the base register untouched
  */
 #define ARMV4_5_LDMIA(Rn, List, S, W)	(0xe8900000 | ((S) &lt;&lt; 22) | ((W) &lt;&lt; 21) | ((Rn) &lt;&lt; 16) | (List))
 
@@ -170,7 +170,7 @@
 #define ARMV4_5_NOP					(0xe1a08008)
 
 /* Move PSR to general purpose register
- * R=1: SPSR R=0: CPSR
+ * R = 1: SPSR R = 0: CPSR
  * Rn: target register
  */
 #define ARMV4_5_MRS(Rn, R)			(0xe10f0000 | ((R) &lt;&lt; 22) | ((Rn) &lt;&lt; 12))
@@ -188,7 +188,7 @@
 #define ARMV4_5_LDR(Rd, Rn)			(0xe5900000 | ((Rd) &lt;&lt; 12) | ((Rn) &lt;&lt; 16))
 
 /* Move general purpose register to PSR
- * R=1: SPSR R=0: CPSR
+ * R = 1: SPSR R = 0: CPSR
  * Field: Field mask
  * 1: control field 2: extension field 4: status field 8: flags field
  * Rm: source register

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/armv7m.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -304,9 +304,9 @@
 	/* If the target fails to halt due to the breakpoint, force a halt */
 	if (retval != ERROR_OK || target-&gt;state != TARGET_HALTED)
 	{
-		if ((retval=target_halt(target)) != ERROR_OK)
+		if ((retval = target_halt(target)) != ERROR_OK)
 			return retval;
-		if ((retval=target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
+		if ((retval = target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -356,7 +356,7 @@
 
 	for (i = 0; i &lt; num_mem_params; i++)
 	{
-		if ((retval=target_write_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
+		if ((retval = target_write_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
 			return retval;
 	}
 

Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/cortex_m3.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -694,7 +694,7 @@
 	return ERROR_OK;
 }
 
-/* int irqstepcount=0; */
+/* int irqstepcount = 0; */
 int cortex_m3_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	/* get pointers to arch-specific information */
@@ -886,7 +886,7 @@
 int cortex_m3_set_breakpoint(struct target_s *target, breakpoint_t *breakpoint)
 {
 	int retval;
-	int fp_num=0;
+	int fp_num = 0;
 	uint32_t hilo;
 
 	/* get pointers to arch-specific information */
@@ -1075,7 +1075,7 @@
 
 int cortex_m3_set_watchpoint(struct target_s *target, watchpoint_t *watchpoint)
 {
-	int dwt_num=0;
+	int dwt_num = 0;
 	uint32_t mask, temp;
 
 	/* get pointers to arch-specific information */
@@ -1285,7 +1285,7 @@
 	 * in &quot;thumb&quot; mode, or an INVSTATE exception will occur. This is a
 	 * hack to deal with the fact that gdb will sometimes &quot;forge&quot;
 	 * return addresses, and doesn't set the LSB correctly (i.e., when
-	 * printing expressions containing function calls, it sets LR=0.) */
+	 * printing expressions containing function calls, it sets LR = 0.) */
 
 	if (num == 14)
 		value |= 0x01;

Modified: trunk/src/target/embeddedice.c
===================================================================
--- trunk/src/target/embeddedice.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/embeddedice.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -125,7 +125,7 @@
 
 	/* identify EmbeddedICE version by reading DCC control register */
 	embeddedice_read_reg(&amp;reg_list[EICE_COMMS_CTRL]);
-	if ((retval=jtag_execute_queue()) != ERROR_OK)
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		for (i = 0; i &lt; num_regs; i++)
 		{
@@ -204,7 +204,7 @@
 		reg_t *dbg_ctrl = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL];
 
 		embeddedice_read_reg(dbg_ctrl);
-		if ((retval=jtag_execute_queue()) != ERROR_OK)
+		if ((retval = jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		buf_set_u32(dbg_ctrl-&gt;value, 4, 1, 0);
 		embeddedice_set_reg_w_exec(dbg_ctrl, dbg_ctrl-&gt;value);

Modified: trunk/src/target/etb.c
===================================================================
--- trunk/src/target/etb.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/etb.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -160,8 +160,8 @@
 
 static void etb_getbuf(jtag_callback_data_t arg)
 {
-  uint8_t *in=(uint8_t *)arg;
-	*((uint32_t *)in)=buf_get_u32(in, 0, 32);
+  uint8_t *in = (uint8_t *)arg;
+	*((uint32_t *)in) = buf_get_u32(in, 0, 32);
 }
 
 

Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/etm.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -282,10 +282,10 @@
 	buf_set_u32(etm_ctrl_reg-&gt;value, 0, etm_ctrl_reg-&gt;size, etm_ctrl_value);
 	etm_store_reg(etm_ctrl_reg);
 
-	if ((retval=jtag_execute_queue()) != ERROR_OK)
+	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
-	if ((retval=etm_ctx-&gt;capture_driver-&gt;init(etm_ctx)) != ERROR_OK)
+	if ((retval = etm_ctx-&gt;capture_driver-&gt;init(etm_ctx)) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;ETM capture driver initialization failed&quot;);
 		return retval;
@@ -1266,12 +1266,12 @@
 		return ERROR_FAIL;
 	}
 
-	for (i=0; etm_capture_drivers[i]; i++)
+	for (i = 0; etm_capture_drivers[i]; i++)
 	{
 		if (strcmp(args[4], etm_capture_drivers[i]-&gt;name) == 0)
 		{
 			int retval;
-			if ((retval=etm_capture_drivers[i]-&gt;register_commands(cmd_ctx)) != ERROR_OK)
+			if ((retval = etm_capture_drivers[i]-&gt;register_commands(cmd_ctx)) != ERROR_OK)
 			{
 				free(etm_ctx);
 				return retval;

Modified: trunk/src/target/image.c
===================================================================
--- trunk/src/target/image.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/image.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -59,7 +59,7 @@
 	{
 		if (read_bytes != 9)
 		{
-			retval=ERROR_FILEIO_OPERATION_FAILED;
+			retval = ERROR_FILEIO_OPERATION_FAILED;
 		}
 	}
 	fileio_close(&amp;fileio);
@@ -414,12 +414,12 @@
 
 	/* count useful segments (loadable), ignore BSS section */
 	image-&gt;num_sections = 0;
-	for (i=0;i&lt;elf-&gt;segment_count;i++)
+	for (i = 0;i&lt;elf-&gt;segment_count;i++)
 		if ((field32(elf, elf-&gt;segments[i].p_type) == PT_LOAD) &amp;&amp; (field32(elf, elf-&gt;segments[i].p_filesz) != 0))
 			image-&gt;num_sections++;
 	/* alloc and fill sections array with loadable segments */
 	image-&gt;sections = malloc(image-&gt;num_sections * sizeof(image_section_t));
-	for (i=0,j=0;i&lt;elf-&gt;segment_count;i++)
+	for (i = 0,j = 0;i&lt;elf-&gt;segment_count;i++)
 	{
 		if ((field32(elf, elf-&gt;segments[i].p_type) == PT_LOAD) &amp;&amp; (field32(elf, elf-&gt;segments[i].p_filesz) != 0))
 		{
@@ -446,7 +446,7 @@
 
 	*size_read = 0;
 
-	LOG_DEBUG(&quot;load segment %d at 0x%&quot; PRIx32 &quot; (sz=0x%&quot; PRIx32 &quot;)&quot;,section,offset,size);
+	LOG_DEBUG(&quot;load segment %d at 0x%&quot; PRIx32 &quot; (sz = 0x%&quot; PRIx32 &quot;)&quot;,section,offset,size);
 
 	/* read initialized data in current segment if any */
 	if (offset&lt;field32(elf,segment-&gt;p_filesz))
@@ -762,15 +762,15 @@
 	{
 		/* relocate */
 		int section;
-		for (section=0; section &lt; image-&gt;num_sections; section++)
+		for (section = 0; section &lt; image-&gt;num_sections; section++)
 		{
 			image-&gt;sections[section].base_address += image-&gt;base_address;
 		}
 		/* we're done relocating. The two statements below are mainly
 		 * for documenation purposes: stop anyone from empirically
 		 * thinking they should use these values henceforth. */
-		image-&gt;base_address=0;
-		image-&gt;base_address_set=0;
+		image-&gt;base_address = 0;
+		image-&gt;base_address_set = 0;
 	}
 
 	return retval;
@@ -1017,10 +1017,10 @@
 
 	while (nbytes&gt;0)
 	{
-		int run=nbytes;
+		int run = nbytes;
 		if (run&gt;32768)
 		{
-			run=32768;
+			run = 32768;
 		}
 		nbytes -= run;
 		while (run--)

Modified: trunk/src/target/mips32_dmaacc.c
===================================================================
--- trunk/src/target/mips32_dmaacc.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/mips32_dmaacc.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -369,7 +369,7 @@
 	int i;
 	int	retval;
 
-	for (i=0; i&lt;count; i++) {
+	for (i = 0; i&lt;count; i++) {
 		if ((retval = ejtag_dma_read(ejtag_info, addr+i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
 			return retval;
 	}
@@ -382,7 +382,7 @@
 	int i;
 	int retval;
 
-	for (i=0; i&lt;count; i++) {
+	for (i = 0; i&lt;count; i++) {
 		if ((retval = ejtag_dma_read_h(ejtag_info, addr+i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
 			return retval;
 	}
@@ -395,7 +395,7 @@
 	int i;
 	int retval;
 
-	for (i=0; i&lt;count; i++) {
+	for (i = 0; i&lt;count; i++) {
 		if ((retval = ejtag_dma_read_b(ejtag_info, addr+i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
 			return retval;
 	}
@@ -423,7 +423,7 @@
 	int i;
 	int retval;
 
-	for (i=0; i&lt;count; i++) {
+	for (i = 0; i&lt;count; i++) {
 		if ((retval = ejtag_dma_write(ejtag_info, addr+i*sizeof(*buf), buf[i])) != ERROR_OK)
 			return retval;
 	}
@@ -436,7 +436,7 @@
 	int i;
 	int retval;
 
-	for (i=0; i&lt;count; i++) {
+	for (i = 0; i&lt;count; i++) {
 		if ((retval = ejtag_dma_write_h(ejtag_info, addr+i*sizeof(*buf), buf[i])) != ERROR_OK)
 			return retval;
 	}
@@ -449,7 +449,7 @@
 	int i;
 	int retval;
 
-	for (i=0; i&lt;count; i++) {
+	for (i = 0; i&lt;count; i++) {
 		if ((retval = ejtag_dma_write_b(ejtag_info, addr+i*sizeof(*buf), buf[i])) != ERROR_OK)
 			return retval;
 	}

Modified: trunk/src/target/mips32_pracc.c
===================================================================
--- trunk/src/target/mips32_pracc.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/mips32_pracc.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -301,9 +301,9 @@
 			
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
-		MIPS32_LW(9,0,8),									/* $9=mem[$8]; read addr */
-		MIPS32_LW(10,4,8),									/* $10=mem[$8+4]; read count */
-		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)), 	/* $11=MIPS32_PRACC_PARAM_OUT */
+		MIPS32_LW(9,0,8),									/* $9 = mem[$8]; read addr */
+		MIPS32_LW(10,4,8),									/* $10 = mem[$8+4]; read count */
+		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)), 	/* $11 = MIPS32_PRACC_PARAM_OUT */
 		MIPS32_ORI(11,11,LOWER16(MIPS32_PRACC_PARAM_OUT)),
 		MIPS32_NOP,
 															/* loop: */
@@ -409,9 +409,9 @@
 			
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
-		MIPS32_LW(9,0,8),									/* $9=mem[$8]; read addr */
-		MIPS32_LW(10,4,8),									/* $10=mem[$8+4]; read count */
-		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)),		/* $11=MIPS32_PRACC_PARAM_OUT */
+		MIPS32_LW(9,0,8),									/* $9 = mem[$8]; read addr */
+		MIPS32_LW(10,4,8),									/* $10 = mem[$8+4]; read count */
+		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)),		/* $11 = MIPS32_PRACC_PARAM_OUT */
 		MIPS32_ORI(11,11,LOWER16(MIPS32_PRACC_PARAM_OUT)),
 		MIPS32_NOP,
 															/* loop: */
@@ -488,9 +488,9 @@
 			
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)), 		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
-		MIPS32_LW(9,0,8), 									/* $9=mem[$8]; read addr */
-		MIPS32_LW(10,4,8), 									/* $10=mem[$8+4]; read count */
-		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)), 	/* $11=MIPS32_PRACC_PARAM_OUT */
+		MIPS32_LW(9,0,8), 									/* $9 = mem[$8]; read addr */
+		MIPS32_LW(10,4,8), 									/* $10 = mem[$8+4]; read count */
+		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)), 	/* $11 = MIPS32_PRACC_PARAM_OUT */
 		MIPS32_ORI(11,11,LOWER16(MIPS32_PRACC_PARAM_OUT)),
 		MIPS32_NOP,
 															/* loop: */

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/mips_m4k.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -209,7 +209,7 @@
 		target-&gt;state = TARGET_RUNNING;
 	}
 
-//	LOG_DEBUG(&quot;ctrl=0x%08X&quot;, ejtag_ctrl);
+//	LOG_DEBUG(&quot;ctrl = 0x%08X&quot;, ejtag_ctrl);
 
 	return ERROR_OK;
 }

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/target.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -1091,7 +1091,7 @@
 	if (target-&gt;state != TARGET_HALTED)
 		return ERROR_OK;
 
-	retval=target-&gt;type-&gt;arch_state(target);
+	retval = target-&gt;type-&gt;arch_state(target);
 	return retval;
 }
 
@@ -1466,8 +1466,8 @@
 
 	/* script procedures */
 	register_command(cmd_ctx, NULL, &quot;profile&quot;, handle_profile_command, COMMAND_EXEC, &quot;profiling samples the CPU PC&quot;);
-	register_jim(cmd_ctx, &quot;ocd_mem2array&quot;, jim_mem2array, &quot;read memory and return as a TCL array for script processing &lt;ARRAYNAME&gt; &lt;WIDTH=32/16/8&gt; &lt;ADDRESS&gt; &lt;COUNT&gt;&quot;);
-	register_jim(cmd_ctx, &quot;ocd_array2mem&quot;, jim_array2mem, &quot;convert a TCL array to memory locations and write the values  &lt;ARRAYNAME&gt; &lt;WIDTH=32/16/8&gt; &lt;ADDRESS&gt; &lt;COUNT&gt;&quot;);
+	register_jim(cmd_ctx, &quot;ocd_mem2array&quot;, jim_mem2array, &quot;read memory and return as a TCL array for script processing &lt;ARRAYNAME&gt; &lt;WIDTH = 32/16/8&gt; &lt;ADDRESS&gt; &lt;COUNT&gt;&quot;);
+	register_jim(cmd_ctx, &quot;ocd_array2mem&quot;, jim_array2mem, &quot;convert a TCL array to memory locations and write the values  &lt;ARRAYNAME&gt; &lt;WIDTH = 32/16/8&gt; &lt;ADDRESS&gt; &lt;COUNT&gt;&quot;);
 
 	register_command(cmd_ctx, NULL, &quot;fast_load_image&quot;, handle_fast_load_image_command, COMMAND_ANY,
 			&quot;same args as load_image, image stored in memory - mainly for profiling purposes&quot;);
@@ -1584,7 +1584,7 @@
 	static int prevPowerdropout = 0;
 
 	int retval;
-	if ((retval=jtag_power_dropout(&amp;powerDropout)) != ERROR_OK)
+	if ((retval = jtag_power_dropout(&amp;powerDropout)) != ERROR_OK)
 		return retval;
 
 	int powerRestored;
@@ -1603,7 +1603,7 @@
 		lastPower = current;
 	}
 
-	if ((retval=jtag_srst_asserted(&amp;srstAsserted)) != ERROR_OK)
+	if ((retval = jtag_srst_asserted(&amp;srstAsserted)) != ERROR_OK)
 		return retval;
 
 	int srstDeasserted;
@@ -1681,10 +1681,10 @@
 
 		/* clear action flags */
 
-		runSrstAsserted=0;
-		runSrstDeasserted=0;
-		runPowerRestore=0;
-		runPowerDropout=0;
+		runSrstAsserted = 0;
+		runSrstDeasserted = 0;
+		runPowerRestore = 0;
+		runPowerDropout = 0;
 
 		recursive = 0;
 	}
@@ -1904,12 +1904,12 @@
 int target_wait_state(target_t *target, enum target_state state, int ms)
 {
 	int retval;
-	long long then=0, cur;
-	int once=1;
+	long long then = 0, cur;
+	int once = 1;
 
 	for (;;)
 	{
-		if ((retval=target_poll(target)) != ERROR_OK)
+		if ((retval = target_poll(target)) != ERROR_OK)
 			return retval;
 		if (target-&gt;state == state)
 		{
@@ -1918,7 +1918,7 @@
 		cur = timeval_ms();
 		if (once)
 		{
-			once=0;
+			once = 0;
 			then = timeval_ms();
 			LOG_DEBUG(&quot;waiting for target %s...&quot;,
 				Jim_Nvp_value2name_simple(nvp_target_state,state)-&gt;name);
@@ -2070,7 +2070,7 @@
 					(unsigned)(address + (i*size)));
 		}
 
-		uint32_t value=0;
+		uint32_t value = 0;
 		const uint8_t *value_ptr = buffer + i * size;
 		switch (size) {
 		case 4: value = target_buffer_get_u32(target, value_ptr); break;
@@ -2274,8 +2274,8 @@
 			break;
 		}
 
-		uint32_t offset=0;
-		uint32_t length=buf_cnt;
+		uint32_t offset = 0;
+		uint32_t length = buf_cnt;
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
@@ -2447,13 +2447,13 @@
 
 	image.start_address_set = 0;
 
-	if ((retval=image_open(&amp;image, args[0], (argc == 3) ? args[2] : NULL)) != ERROR_OK)
+	if ((retval = image_open(&amp;image, args[0], (argc == 3) ? args[2] : NULL)) != ERROR_OK)
 	{
 		return retval;
 	}
 
 	image_size = 0x0;
-	retval=ERROR_OK;
+	retval = ERROR_OK;
 	for (i = 0; i &lt; image.num_sections; i++)
 	{
 		buffer = malloc(image.sections[i].size);
@@ -2514,7 +2514,7 @@
 										  buffer[t]);
 							free(data);
 							free(buffer);
-							retval=ERROR_FAIL;
+							retval = ERROR_FAIL;
 							goto done;
 						}
 						if ((t%16384) == 0)
@@ -2790,9 +2790,9 @@
 static void writeLong(FILE *f, int l)
 {
 	int i;
-	for (i=0; i&lt;4; i++)
+	for (i = 0; i&lt;4; i++)
 	{
-		char c=(l &gt;&gt; (i*8))&amp;0xff;
+		char c = (l &gt;&gt; (i*8))&amp;0xff;
 		writeData(f, &amp;c, 1);
 	}
 
@@ -2807,7 +2807,7 @@
 static void writeGmon(uint32_t *samples, uint32_t sampleNum, char *filename)
 {
 	uint32_t i;
-	FILE *f=fopen(filename, &quot;w&quot;);
+	FILE *f = fopen(filename, &quot;w&quot;);
 	if (f == NULL)
 		return;
 	writeString(f, &quot;gmon&quot;);
@@ -2820,42 +2820,42 @@
 	writeData(f, &amp;zero, 1);
 
 	/* figure out bucket size */
-	uint32_t min=samples[0];
-	uint32_t max=samples[0];
-	for (i=0; i&lt;sampleNum; i++)
+	uint32_t min = samples[0];
+	uint32_t max = samples[0];
+	for (i = 0; i&lt;sampleNum; i++)
 	{
 		if (min&gt;samples[i])
 		{
-			min=samples[i];
+			min = samples[i];
 		}
 		if (max&lt;samples[i])
 		{
-			max=samples[i];
+			max = samples[i];
 		}
 	}
 
-	int addressSpace=(max-min+1);
+	int addressSpace = (max-min+1);
 
 	static const uint32_t maxBuckets = 256 * 1024; /* maximum buckets. */
 	uint32_t length = addressSpace;
 	if (length &gt; maxBuckets)
 	{
-		length=maxBuckets;
+		length = maxBuckets;
 	}
-	int *buckets=malloc(sizeof(int)*length);
+	int *buckets = malloc(sizeof(int)*length);
 	if (buckets == NULL)
 	{
 		fclose(f);
 		return;
 	}
 	memset(buckets, 0, sizeof(int)*length);
-	for (i=0; i&lt;sampleNum;i++)
+	for (i = 0; i&lt;sampleNum;i++)
 	{
-		uint32_t address=samples[i];
-		long long a=address-min;
-		long long b=length-1;
-		long long c=addressSpace-1;
-		int index=(a*b)/c; /* danger!!!! int32 overflows */
+		uint32_t address = samples[i];
+		long long a = address-min;
+		long long b = length-1;
+		long long c = addressSpace-1;
+		int index = (a*b)/c; /* danger!!!! int32 overflows */
 		buckets[index]++;
 	}
 
@@ -2865,22 +2865,22 @@
 	writeLong(f, length);		/* # of samples */
 	writeLong(f, 64000000); 	/* 64MHz */
 	writeString(f, &quot;seconds&quot;);
-	for (i=0; i&lt;(15-strlen(&quot;seconds&quot;)); i++)
+	for (i = 0; i&lt;(15-strlen(&quot;seconds&quot;)); i++)
 		writeData(f, &amp;zero, 1);
 	writeString(f, &quot;s&quot;);
 
 	/*append binary memory gmon.out profile_hist_data (profile_hist_data + profile_hist_hdr.hist_size) */
 
-	char *data=malloc(2*length);
+	char *data = malloc(2*length);
 	if (data != NULL)
 	{
-		for (i=0; i&lt;length;i++)
+		for (i = 0; i&lt;length;i++)
 		{
 			int val;
-			val=buckets[i];
+			val = buckets[i];
 			if (val&gt;65535)
 			{
-				val=65535;
+				val = 65535;
 			}
 			data[i*2]=val&amp;0xff;
 			data[i*2+1]=(val &gt;&gt; 8)&amp;0xff;
@@ -2916,12 +2916,12 @@
 
 	command_print(cmd_ctx, &quot;Starting profiling. Halting and resuming the target as often as we can...&quot;);
 
-	static const int maxSample=10000;
-	uint32_t *samples=malloc(sizeof(uint32_t)*maxSample);
+	static const int maxSample = 10000;
+	uint32_t *samples = malloc(sizeof(uint32_t)*maxSample);
 	if (samples == NULL)
 		return ERROR_OK;
 
-	int numSamples=0;
+	int numSamples = 0;
 	/* hopefully it is safe to cache! We want to stop/restart as quickly as possible. */
 	reg_t *reg = register_get_by_name(target-&gt;reg_cache, &quot;pc&quot;, 1);
 
@@ -2946,7 +2946,7 @@
 		} else
 		{
 			command_print(cmd_ctx, &quot;Target not halted or running&quot;);
-			retval=ERROR_OK;
+			retval = ERROR_OK;
 			break;
 		}
 		if (retval != ERROR_OK)
@@ -4206,7 +4206,7 @@
 	if (target-&gt;tap == NULL)
 	{
 		Jim_SetResultString( interp, &quot;-chain-position required when creating target&quot;, -1);
-		e=JIM_ERR;
+		e = JIM_ERR;
 	}
 
 	if ( e != JIM_OK ){
@@ -4389,13 +4389,13 @@
 	if (fastload != NULL)
 	{
 		int i;
-		for (i=0; i&lt;fastload_num; i++)
+		for (i = 0; i&lt;fastload_num; i++)
 		{
 			if (fastload[i].data)
 				free(fastload[i].data);
 		}
 		free(fastload);
-		fastload=NULL;
+		fastload = NULL;
 	}
 }
 
@@ -4407,8 +4407,8 @@
 	uint8_t *buffer;
 	uint32_t buf_cnt;
 	uint32_t image_size;
-	uint32_t min_address=0;
-	uint32_t max_address=0xffffffff;
+	uint32_t min_address = 0;
+	uint32_t max_address = 0xffffffff;
 	int i;
 
 	image_t image;
@@ -4430,8 +4430,8 @@
 
 	image_size = 0x0;
 	retval = ERROR_OK;
-	fastload_num=image.num_sections;
-	fastload=(struct FastLoad *)malloc(sizeof(struct FastLoad)*image.num_sections);
+	fastload_num = image.num_sections;
+	fastload = (struct FastLoad *)malloc(sizeof(struct FastLoad)*image.num_sections);
 	if (fastload == NULL)
 	{
 		image_close(&amp;image);
@@ -4454,8 +4454,8 @@
 			break;
 		}
 
-		uint32_t offset=0;
-		uint32_t length=buf_cnt;
+		uint32_t offset = 0;
+		uint32_t length = buf_cnt;
 
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
@@ -4475,15 +4475,15 @@
 				length -= (image.sections[i].base_address+buf_cnt)-max_address;
 			}
 
-			fastload[i].address=image.sections[i].base_address+offset;
-			fastload[i].data=malloc(length);
+			fastload[i].address = image.sections[i].base_address+offset;
+			fastload[i].data = malloc(length);
 			if (fastload[i].data == NULL)
 			{
 				free(buffer);
 				break;
 			}
 			memcpy(fastload[i].data, buffer+offset, length);
-			fastload[i].length=length;
+			fastload[i].length = length;
 
 			image_size += length;
 			command_print(cmd_ctx, &quot;%u byte written at address 0x%8.8x&quot;, 
@@ -4522,10 +4522,10 @@
 		return ERROR_FAIL;
 	}
 	int i;
-	int ms=timeval_ms();
-	int size=0;
-	int retval=ERROR_OK;
-	for (i=0; i&lt;fastload_num;i++)
+	int ms = timeval_ms();
+	int size = 0;
+	int retval = ERROR_OK;
+	for (i = 0; i&lt;fastload_num;i++)
 	{
 		target_t *target = get_current_target(cmd_ctx);
 		command_print(cmd_ctx, &quot;Write to 0x%08x, length 0x%08x&quot;, 
@@ -4537,7 +4537,7 @@
 		}
 		size += fastload[i].length;
 	}
-	int after=timeval_ms();
+	int after = timeval_ms();
 	command_print(cmd_ctx, &quot;Loaded image %f kBytes/s&quot;, (float)(size/1024.0)/((float)(after-ms)/1000.0));
 	return retval;
 }

Modified: trunk/src/target/target.h
===================================================================
--- trunk/src/target/target.h	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/target.h	2009-06-23 22:42:54 UTC (rev 2372)
@@ -87,7 +87,7 @@
 
 enum target_endianess
 {
-	TARGET_ENDIAN_UNKNOWN=0,
+	TARGET_ENDIAN_UNKNOWN = 0,
 	TARGET_BIG_ENDIAN = 1, TARGET_LITTLE_ENDIAN = 2
 };
 

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/target/xscale.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -295,8 +295,8 @@
 
 static void xscale_getbuf(jtag_callback_data_t arg)
 {
-  uint8_t *in=(uint8_t *)arg;
-	*((uint32_t *)in)=buf_get_u32(in, 0, 32);
+  uint8_t *in = (uint8_t *)arg;
+	*((uint32_t *)in) = buf_get_u32(in, 0, 32);
 }
 
 int xscale_receive(target_t *target, uint32_t *buffer, int num_words)
@@ -304,7 +304,7 @@
 	if (num_words == 0)
 		return ERROR_INVALID_ARGUMENTS;
 
-	int retval=ERROR_OK;
+	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 
@@ -351,7 +351,7 @@
 	jtag_add_runtest(1, jtag_get_end_state()); /* ensures that we're in the TAP_IDLE state as the above could be a no-op */
 
 	/* repeat until all words have been collected */
-	int attempts=0;
+	int attempts = 0;
 	while (words_done &lt; num_words)
 	{
 		/* schedule reads */
@@ -397,7 +397,7 @@
 			if (attempts++==1000)
 			{
 				LOG_ERROR(&quot;Failed to receiving data from debug handler after 1000 attempts&quot;);
-				retval=ERROR_TARGET_TIMEOUT;
+				retval = ERROR_TARGET_TIMEOUT;
 				break;
 			}
 		}
@@ -886,7 +886,7 @@
 		}
 		else
 		{
-			retval=target_read_u32(target, 0xffff0000 + 4*i, &amp;xscale-&gt;high_vectors[i]);
+			retval = target_read_u32(target, 0xffff0000 + 4*i, &amp;xscale-&gt;high_vectors[i]);
 			if (retval == ERROR_TARGET_TIMEOUT)
 				return retval;
 			if (retval != ERROR_OK)
@@ -905,7 +905,7 @@
 		}
 		else
 		{
-			retval=target_read_u32(target, 0x0 + 4*i, &amp;xscale-&gt;low_vectors[i]);
+			retval = target_read_u32(target, 0x0 + 4*i, &amp;xscale-&gt;low_vectors[i]);
 			if (retval == ERROR_TARGET_TIMEOUT)
 				return retval;
 			if (retval != ERROR_OK)
@@ -973,7 +973,7 @@
 
 int xscale_poll(target_t *target)
 {
-	int retval=ERROR_OK;
+	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
 
@@ -1028,11 +1028,11 @@
 
 	/* clear external dbg break (will be written on next DCSR read) */
 	xscale-&gt;external_debug_break = 0;
-	if ((retval=xscale_read_dcsr(target)) != ERROR_OK)
+	if ((retval = xscale_read_dcsr(target)) != ERROR_OK)
 		return retval;
 
 	/* get r0, pc, r1 to r7 and cpsr */
-	if ((retval=xscale_receive(target, buffer, 10)) != ERROR_OK)
+	if ((retval = xscale_receive(target, buffer, 10)) != ERROR_OK)
 		return retval;
 
 	/* move r0 from buffer to register cache */
@@ -1253,7 +1253,7 @@
 		}
 	}
 
-	if ((retval=xscale_set_reg_u32(ibcr0, next_pc | 0x1)) != ERROR_OK)
+	if ((retval = xscale_set_reg_u32(ibcr0, next_pc | 0x1)) != ERROR_OK)
 		return retval;
 
 	return ERROR_OK;
@@ -1266,7 +1266,7 @@
 	reg_t *ibcr0 = &amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_IBCR0];
 	int retval;
 
-	if ((retval=xscale_set_reg_u32(ibcr0, 0x0)) != ERROR_OK)
+	if ((retval = xscale_set_reg_u32(ibcr0, 0x0)) != ERROR_OK)
 		return retval;
 
 	return ERROR_OK;
@@ -1297,7 +1297,7 @@
 	}
 
 	/* update vector tables */
-	if ((retval=xscale_update_vectors(target)) != ERROR_OK)
+	if ((retval = xscale_update_vectors(target)) != ERROR_OK)
 		return retval;
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
@@ -1451,56 +1451,56 @@
 	}
 
 	LOG_DEBUG(&quot;enable single-step&quot;);
-	if ((retval=xscale_enable_single_step(target, next_pc)) != ERROR_OK)
+	if ((retval = xscale_enable_single_step(target, next_pc)) != ERROR_OK)
 		return retval;
 
 	/* restore banked registers */
-	if ((retval=xscale_restore_context(target)) != ERROR_OK)
+	if ((retval = xscale_restore_context(target)) != ERROR_OK)
 		return retval;
 
 	/* send resume request (command 0x30 or 0x31)
 	 * clean the trace buffer if it is to be enabled (0x62) */
 	if (xscale-&gt;trace.buffer_enabled)
 	{
-		if ((retval=xscale_send_u32(target, 0x62)) != ERROR_OK)
+		if ((retval = xscale_send_u32(target, 0x62)) != ERROR_OK)
 			return retval;
-		if ((retval=xscale_send_u32(target, 0x31)) != ERROR_OK)
+		if ((retval = xscale_send_u32(target, 0x31)) != ERROR_OK)
 			return retval;
 	}
 	else
-		if ((retval=xscale_send_u32(target, 0x30)) != ERROR_OK)
+		if ((retval = xscale_send_u32(target, 0x30)) != ERROR_OK)
 			return retval;
 
 	/* send CPSR */
-	if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32))) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32))) != ERROR_OK)
 		return retval;
 	LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
 
 	for (i = 7; i &gt;= 0; i--)
 	{
 		/* send register */
-		if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[i].value, 0, 32))) != ERROR_OK)
+		if ((retval = xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[i].value, 0, 32))) != ERROR_OK)
 			return retval;
 		LOG_DEBUG(&quot;writing r%i with value 0x%8.8&quot; PRIx32 &quot;&quot;, i, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[i].value, 0, 32));
 	}
 
 	/* send PC */
-	if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))) != ERROR_OK)
 		return retval;
 	LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
 
 	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 
 	/* registers are now invalid */
-	if ((retval=armv4_5_invalidate_core_regs(target)) != ERROR_OK)
+	if ((retval = armv4_5_invalidate_core_regs(target)) != ERROR_OK)
 		return retval;
 
 	/* wait for and process debug entry */
-	if ((retval=xscale_debug_entry(target)) != ERROR_OK)
+	if ((retval = xscale_debug_entry(target)) != ERROR_OK)
 		return retval;
 
 	LOG_DEBUG(&quot;disable single-step&quot;);
-	if ((retval=xscale_disable_single_step(target)) != ERROR_OK)
+	if ((retval = xscale_disable_single_step(target)) != ERROR_OK)
 		return retval;
 
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
@@ -1531,7 +1531,7 @@
 	/* if we're at the reset vector, we have to simulate the step */
 	if (current_pc == 0x0)
 	{
-		if ((retval=arm_simulate_step(target, NULL)) != ERROR_OK)
+		if ((retval = arm_simulate_step(target, NULL)) != ERROR_OK)
 			return retval;
 		current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 
@@ -1545,7 +1545,7 @@
 	if (handle_breakpoints)
 		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))))
 		{
-			if ((retval=xscale_unset_breakpoint(target, breakpoint)) != ERROR_OK)
+			if ((retval = xscale_unset_breakpoint(target, breakpoint)) != ERROR_OK)
 				return retval;
 		}
 
@@ -1930,20 +1930,20 @@
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
 	/* send memory read request (command 0x1n, n: access size) */
-	if ((retval=xscale_send_u32(target, 0x10 | size)) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, 0x10 | size)) != ERROR_OK)
 		return retval;
 
 	/* send base address for read request */
-	if ((retval=xscale_send_u32(target, address)) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, address)) != ERROR_OK)
 		return retval;
 
 	/* send number of requested data words */
-	if ((retval=xscale_send_u32(target, count)) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, count)) != ERROR_OK)
 		return retval;
 
 	/* receive data from target (count times 32-bit words in host endianness) */
 	buf32 = malloc(4 * count);
-	if ((retval=xscale_receive(target, buf32, count)) != ERROR_OK)
+	if ((retval = xscale_receive(target, buf32, count)) != ERROR_OK)
 		return retval;
 
 	/* extract data from host-endian buffer into byte stream */
@@ -1971,12 +1971,12 @@
 	free(buf32);
 
 	/* examine DCSR, to see if Sticky Abort (SA) got set */
-	if ((retval=xscale_read_dcsr(target)) != ERROR_OK)
+	if ((retval = xscale_read_dcsr(target)) != ERROR_OK)
 		return retval;
 	if (buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value, 5, 1) == 1)
 	{
 		/* clear SA bit */
-		if ((retval=xscale_send_u32(target, 0x60)) != ERROR_OK)
+		if ((retval = xscale_send_u32(target, 0x60)) != ERROR_OK)
 			return retval;
 
 		return ERROR_TARGET_DATA_ABORT;
@@ -2007,15 +2007,15 @@
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
 	/* send memory write request (command 0x2n, n: access size) */
-	if ((retval=xscale_send_u32(target, 0x20 | size)) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, 0x20 | size)) != ERROR_OK)
 		return retval;
 
 	/* send base address for read request */
-	if ((retval=xscale_send_u32(target, address)) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, address)) != ERROR_OK)
 		return retval;
 
 	/* send number of requested data words to be written*/
-	if ((retval=xscale_send_u32(target, count)) != ERROR_OK)
+	if ((retval = xscale_send_u32(target, count)) != ERROR_OK)
 		return retval;
 
 	/* extract data from host-endian buffer into byte stream */
@@ -2045,16 +2045,16 @@
 		}
 	}
 #endif
-	if ((retval=xscale_send(target, buffer, count, size)) != ERROR_OK)
+	if ((retval = xscale_send(target, buffer, count, size)) != ERROR_OK)
 		return retval;
 
 	/* examine DCSR, to see if Sticky Abort (SA) got set */
-	if ((retval=xscale_read_dcsr(target)) != ERROR_OK)
+	if ((retval = xscale_read_dcsr(target)) != ERROR_OK)
 		return retval;
 	if (buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value, 5, 1) == 1)
 	{
 		/* clear SA bit */
-		if ((retval=xscale_send_u32(target, 0x60)) != ERROR_OK)
+		if ((retval = xscale_send_u32(target, 0x60)) != ERROR_OK)
 			return retval;
 
 		return ERROR_TARGET_DATA_ABORT;
@@ -2330,7 +2330,7 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	uint8_t enable=0;
+	uint8_t enable = 0;
 	reg_t *dbcon = &amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DBCON];
 	uint32_t dbcon_value = buf_get_u32(dbcon-&gt;value, 0, 32);
 

Modified: trunk/src/xsvf/xsvf.c
===================================================================
--- trunk/src/xsvf/xsvf.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/src/xsvf/xsvf.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -366,7 +366,7 @@
 
 				LOG_DEBUG(&quot;%s %d&quot;, op_name, xsdrsize);
 
-				for ( attempt=0; attempt&lt;limit;  ++attempt )
+				for ( attempt = 0; attempt&lt;limit;  ++attempt )
 				{
 					scan_field_t field;
 
@@ -836,7 +836,7 @@
 				if (limit &lt; 1)
 					limit = 1;
 
-				for ( attempt=0; attempt&lt;limit;  ++attempt )
+				for ( attempt = 0; attempt&lt;limit;  ++attempt )
 				{
 					scan_field_t field;
 

Modified: trunk/testing/examples/cortex/test.c
===================================================================
--- trunk/testing/examples/cortex/test.c	2009-06-23 22:42:03 UTC (rev 2371)
+++ trunk/testing/examples/cortex/test.c	2009-06-23 22:42:54 UTC (rev 2372)
@@ -12,7 +12,7 @@
 monitor reg pc 0x20002000
 stepi
 
-arm-elf-gcc -mthumb -mcpu=cortex-m3 -nostdlib -Ttest.ld test.c
+arm-elf-gcc -mthumb -mcpu = cortex-m3 -nostdlib -Ttest.ld test.c
 
 
 */
@@ -20,7 +20,7 @@
 void _start()
 {
   int i;
-  for (i=0; i&lt;1000; i++)
+  for (i = 0; i&lt;1000; i++)
     {
       j++;
     }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001155.html">[Openocd-svn] r2371 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
</A></li>
	<LI>Next message: <A HREF="001157.html">[Openocd-svn] r2373 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target xsvf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1156">[ date ]</a>
              <a href="thread.html#1156">[ thread ]</a>
              <a href="subject.html#1156">[ subject ]</a>
              <a href="author.html#1156">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
