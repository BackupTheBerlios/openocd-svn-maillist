<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2371 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2371%20-%20in%20trunk/src%3A%20flash%20flash/ocl/at91sam7x%0A%09helper%20jtag%20jtag/zy1000%20server%20target&In-Reply-To=%3C200906232242.n5NMgnnU018290%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001154.html">
   <LINK REL="Next"  HREF="001156.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2371 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2371%20-%20in%20trunk/src%3A%20flash%20flash/ocl/at91sam7x%0A%09helper%20jtag%20jtag/zy1000%20server%20target&In-Reply-To=%3C200906232242.n5NMgnnU018290%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2371 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target">zwelch at mail.berlios.de
       </A><BR>
    <I>Wed Jun 24 00:42:49 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001154.html">[Openocd-svn] r2370 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
</A></li>
        <LI>Next message: <A HREF="001156.html">[Openocd-svn] r2372 - in trunk: src src/flash	src/flash/ocl/at91sam7x src/helper src/jtag	src/jtag/minidummy src/jtag/rlink src/jtag/zy1000 src/pld	src/server src/target src/xsvf testing/examples/cortex
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1155">[ date ]</a>
              <a href="thread.html#1155">[ thread ]</a>
              <a href="subject.html#1155">[ subject ]</a>
              <a href="author.html#1155">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-24 00:42:03 +0200 (Wed, 24 Jun 2009)
New Revision: 2371

Modified:
   trunk/src/flash/at91sam7.c
   trunk/src/flash/flash.c
   trunk/src/flash/ocl.c
   trunk/src/flash/ocl/at91sam7x/dcc.c
   trunk/src/flash/ocl/at91sam7x/samflash.c
   trunk/src/flash/str9x.c
   trunk/src/helper/binarybuffer.h
   trunk/src/helper/command.c
   trunk/src/helper/configuration.c
   trunk/src/helper/ioutil.c
   trunk/src/helper/jim.c
   trunk/src/helper/jim.h
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/bitq.c
   trunk/src/jtag/core.c
   trunk/src/jtag/driver.c
   trunk/src/jtag/dummy.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/presto.c
   trunk/src/jtag/tcl.c
   trunk/src/jtag/usbprog.c
   trunk/src/jtag/zy1000/jtag_minidriver.h
   trunk/src/jtag/zy1000/zy1000.c
   trunk/src/server/gdb_server.c
   trunk/src/target/arm11.c
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm9tdmi.c
   trunk/src/target/arm_adi_v5.c
   trunk/src/target/arm_disassembler.c
   trunk/src/target/arm_jtag.c
   trunk/src/target/breakpoints.c
   trunk/src/target/etb.c
   trunk/src/target/image.c
   trunk/src/target/mips32_pracc.c
   trunk/src/target/mips_ejtag.c
   trunk/src/target/target.c
   trunk/src/target/xscale.c
Log:
- Fixes '==' whitespace
- Replace ')\(==\)\(\w\)' with ') \1 \2'.
- Replace '\(\w\)\(==\)\(\w\)' with '\1 \2 \3'.


Modified: trunk/src/flash/at91sam7.c
===================================================================
--- trunk/src/flash/at91sam7.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/flash/at91sam7.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -284,7 +284,7 @@
 	target_write_u32(target, MC_FCR[bank-&gt;bank_number], fcr);
 	LOG_DEBUG(&quot;Flash command: 0x%&quot; PRIx32 &quot;, flash bank: %i, page number: %u&quot;, fcr, bank-&gt;bank_number+1, pagen);
 
-	if ((at91sam7_info-&gt;cidr_arch == 0x60) &amp;&amp; ((cmd==SLB)|(cmd==CLB)))
+	if ((at91sam7_info-&gt;cidr_arch == 0x60) &amp;&amp; ((cmd == SLB)|(cmd == CLB)))
 	{
 		/* Lock bit manipulation on AT91SAM7A3 waits for FC_FSR bit 1, EOL */
 		if (at91sam7_wait_status_busy(bank, MC_FSR_EOL, 10)&amp;0x0C)

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/flash/flash.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -654,7 +654,7 @@
 	/* flash auto-erase is disabled by default*/
 	int auto_erase = 0;
 
-	if (strcmp(args[0], &quot;erase&quot;)==0)
+	if (strcmp(args[0], &quot;erase&quot;) == 0)
 	{
 		auto_erase = 1;
 		args++;
@@ -894,7 +894,7 @@
 		fileio_close(&amp;fileio);
 		return retvaltemp;
 	}
-	if (retval==ERROR_OK)
+	if (retval == ERROR_OK)
 	{
 	command_print(cmd_ctx, 
 				  &quot;wrote  %lld byte from file %s to flash bank %li at offset 0x%8.8&quot; PRIx32 &quot; in %s (%f kb/s)&quot;,

Modified: trunk/src/flash/ocl/at91sam7x/dcc.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/dcc.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/flash/ocl/at91sam7x/dcc.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -27,7 +27,7 @@
 
 	do {
 		asm volatile (&quot;mrc p14, 0, %0, C0, C0&quot; : &quot;=r&quot; (dcc_reg) : );
-	} while ((dcc_reg&amp;1)==0);
+	} while ((dcc_reg&amp;1) == 0);
 
 	asm volatile (&quot;mrc p14, 0, %0, C1, C0&quot; : &quot;=r&quot; (dcc_reg) : );
 	return dcc_reg;

Modified: trunk/src/flash/ocl/at91sam7x/samflash.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -86,7 +86,7 @@
 	else efc_ofs=0;
 
 	/* wait until FLASH is ready, just for sure */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY)==0);
+	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* calculate page address, only lower 8 bits are used to address the latch,
 		 but the upper part of address is needed for writing to proper EFC */
@@ -103,7 +103,7 @@
 	outr(MC_FCR+efc_ofs, ((page_num&amp;0x3ff) &lt;&lt; 8) | MC_KEY | MC_FCMD_WP);
 
 	/* wait until it's done */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY)==0);
+	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* check for errors */
 	if ((inr(MC_FSR+efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
@@ -134,12 +134,12 @@
 		if (lockbits&amp;1) {
 
 			/* wait until FLASH is ready, just for sure */
-			while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY)==0);
+			while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
 
 			outr(MC_FCR+efc_ofs, ((page_num&amp;0x3ff) &lt;&lt; 8) | 0x5a000004);
 
 			/* wait until it's done */
-			while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY)==0);
+			while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
 
 			/* check for errors */
 			if ((inr(MC_FSR+efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
@@ -151,13 +151,13 @@
 	}
 
 	/* wait until FLASH is ready, just for sure */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY)==0);
+	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* erase all command to FCR */
 	outr(MC_FCR+efc_ofs, 0x5a000008);
 
 	/* wait until it's done */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY)==0);
+	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* check for errors */
 	if ((inr(MC_FSR+efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;

Modified: trunk/src/flash/ocl.c
===================================================================
--- trunk/src/flash/ocl.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/flash/ocl.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -172,7 +172,7 @@
 	int i;
 
 	/* check preconditions */
-	if (ocl-&gt;buflen == 0 || ocl-&gt;bufalign==0)
+	if (ocl-&gt;buflen == 0 || ocl-&gt;bufalign == 0)
 		return ERROR_FLASH_BANK_NOT_PROBED;
 
 	if (bank-&gt;target-&gt;state != TARGET_RUNNING)
@@ -373,7 +373,7 @@
 {
 	ocl_priv_t *ocl = bank-&gt;driver_priv;
 
-	if (ocl-&gt;buflen == 0 || ocl-&gt;bufalign==0)
+	if (ocl-&gt;buflen == 0 || ocl-&gt;bufalign == 0)
 		return ERROR_FLASH_BANK_NOT_PROBED;
 
 	return ERROR_OK;

Modified: trunk/src/flash/str9x.c
===================================================================
--- trunk/src/flash/str9x.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/flash/str9x.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -309,7 +309,7 @@
 				break;
 			alive_sleep(1);
 		}
-		if (timeout==1000)
+		if (timeout == 1000)
 		{
 			LOG_ERROR(&quot;erase timed out&quot;);
 			return ERROR_FAIL;
@@ -582,7 +582,7 @@
 				break;
 			alive_sleep(1);
 		}
-		if (timeout==1000)
+		if (timeout == 1000)
 		{
 			LOG_ERROR(&quot;write timed out&quot;);
 			return ERROR_FAIL;
@@ -631,7 +631,7 @@
 				break;
 			alive_sleep(1);
 		}
-		if (timeout==1000)
+		if (timeout == 1000)
 		{
 			LOG_ERROR(&quot;write timed out&quot;);
 			return ERROR_FAIL;

Modified: trunk/src/helper/binarybuffer.h
===================================================================
--- trunk/src/helper/binarybuffer.h	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/helper/binarybuffer.h	2009-06-23 22:42:03 UTC (rev 2371)
@@ -32,7 +32,7 @@
 /* inlining this will help show what fn that is taking time during profiling. */
 static inline void buf_set_u32(uint8_t* buffer, unsigned int first, unsigned int num, uint32_t value)
 {
-	if ((num==32) &amp;&amp; (first==0))
+	if ((num == 32) &amp;&amp; (first == 0))
 	{
 		buffer[3]=(value &gt;&gt; 24)&amp;0xff;
 		buffer[2]=(value &gt;&gt; 16)&amp;0xff;
@@ -53,7 +53,7 @@
 }
 static inline uint32_t buf_get_u32(const uint8_t* buffer, unsigned int first, unsigned int num)
 {
-	if ((num==32) &amp;&amp; (first==0))
+	if ((num == 32) &amp;&amp; (first == 0))
 	{
 		return (((uint32_t)buffer[3]) &lt;&lt; 24)|(((uint32_t)buffer[2]) &lt;&lt; 16)|(((uint32_t)buffer[1]) &lt;&lt; 8)|(((uint32_t)buffer[0]) &lt;&lt; 0);
 	} else

Modified: trunk/src/helper/command.c
===================================================================
--- trunk/src/helper/command.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/helper/command.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -94,9 +94,9 @@
 	 * to the fn and fish it out manually.
 	 */
 	c = interp-&gt;cmdPrivData;
-	if (c==NULL)
+	if (c == NULL)
 	{
-		LOG_ERROR(&quot;BUG: interp-&gt;cmdPrivData==NULL&quot;);
+		LOG_ERROR(&quot;BUG: interp-&gt;cmdPrivData == NULL&quot;);
 		return JIM_ERR;
 	}
 	target_call_timer_callbacks_now();
@@ -157,7 +157,7 @@
 		*return_retval = retval;
 	}
 
-	return (retval==ERROR_OK)?JIM_OK:JIM_ERR;
+	return (retval == ERROR_OK)?JIM_OK:JIM_ERR;
 }
 
 /* nice short description of source file */
@@ -212,7 +212,7 @@
 	}
 
 	/* just a placeholder, no handler */
-	if (c-&gt;handler==NULL)
+	if (c-&gt;handler == NULL)
 		return c;
 
 	/* If this is a two level command, e.g. &quot;flash banks&quot;, then the
@@ -478,7 +478,7 @@
 			/* We do not print the connection closed error message */
 			Jim_PrintErrorMessage(interp);
 		}
-		if (retval==ERROR_OK)
+		if (retval == ERROR_OK)
 		{
 			/* It wasn't a low level OpenOCD command that failed */
 			return ERROR_FAIL;
@@ -745,7 +745,7 @@
 #if !BUILD_ECOSBOARD
 	Jim_EventLoopOnLoad(interp);
 #endif
-	if (Jim_Eval_Named(interp, startup_tcl, &quot;embedded:startup.tcl&quot;,1)==JIM_ERR)
+	if (Jim_Eval_Named(interp, startup_tcl, &quot;embedded:startup.tcl&quot;,1) == JIM_ERR)
 	{
 		LOG_ERROR(&quot;Failed to run startup.tcl (embedded into OpenOCD compile time)&quot;);
 		Jim_PrintErrorMessage(interp);
@@ -812,7 +812,7 @@
 	if (argc != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	fast_and_dangerous = strcmp(&quot;enable&quot;, args[0])==0;
+	fast_and_dangerous = strcmp(&quot;enable&quot;, args[0]) == 0;
 
 	return ERROR_OK;
 }
@@ -856,7 +856,7 @@
 {
 	Jim_Obj *objPtr=Jim_GetGlobalVariableStr(interp, variable, JIM_ERRMSG);
 	long t;
-	if (Jim_GetLong(interp, objPtr, &amp;t)==JIM_OK)
+	if (Jim_GetLong(interp, objPtr, &amp;t) == JIM_OK)
 	{
 		return t;
 	}

Modified: trunk/src/helper/configuration.c
===================================================================
--- trunk/src/helper/configuration.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/helper/configuration.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -94,7 +94,7 @@
 	} else
 	{
 		char *full_path=find_file(file);
-		if (full_path==NULL)
+		if (full_path == NULL)
 			return NULL;
 		FILE *fp = NULL;
 		fp = fopen(full_path, mode);

Modified: trunk/src/helper/ioutil.c
===================================================================
--- trunk/src/helper/ioutil.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/helper/ioutil.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -84,7 +84,7 @@
 
 	FILE * pFile;
 	pFile = fopen(fileName,&quot;rb&quot;);
-	if (pFile==NULL)
+	if (pFile == NULL)
 	{
 		LOG_ERROR(&quot;Can't open %s\n&quot;, fileName);
 		return ERROR_FAIL;
@@ -111,7 +111,7 @@
 		return ERROR_FAIL;
 	}
 	*data = malloc(*len + 1);
-	if (*data==NULL)
+	if (*data == NULL)
 	{
 		LOG_ERROR(&quot;Can't open %s\n&quot;, fileName);
 		fclose(pFile);
@@ -233,7 +233,7 @@
 					break;
 			}
 		}
-		if ((i==argc) &amp;&amp; (fwrite(&quot;\n&quot;, 1, 1, config_file)==1))
+		if ((i == argc) &amp;&amp; (fwrite(&quot;\n&quot;, 1, 1, config_file) == 1))
 		{
 			retval=ERROR_OK;
 		}
@@ -274,7 +274,7 @@
 			chunk = maxChunk;
 		}
 
-		if ((retval==ERROR_OK) &amp;&amp; (fwrite(((char *)data)+pos, 1, chunk, f) != chunk))
+		if ((retval == ERROR_OK) &amp;&amp; (fwrite(((char *)data)+pos, 1, chunk, f) != chunk))
 			retval = ERROR_INVALID_ARGUMENTS;
 
 		if (retval != ERROR_OK)
@@ -363,7 +363,7 @@
 	DIR *dirp;
 
 	dirp = opendir(destdir);
-	if (dirp==NULL)
+	if (dirp == NULL)
 	{
 		mkdir(destdir, 0777);
 	} else
@@ -477,7 +477,7 @@
 		if (entry == NULL)
 			break;
 
-		if ((strcmp(&quot;.&quot;, entry-&gt;d_name)==0)||(strcmp(&quot;..&quot;, entry-&gt;d_name)==0))
+		if ((strcmp(&quot;.&quot;, entry-&gt;d_name) == 0)||(strcmp(&quot;..&quot;, entry-&gt;d_name) == 0))
 			continue;
 
         Jim_ListAppendElement(interp, objPtr, Jim_NewStringObj(interp, entry-&gt;d_name, strlen(entry-&gt;d_name)));

Modified: trunk/src/helper/jim.c
===================================================================
--- trunk/src/helper/jim.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/helper/jim.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -198,7 +198,7 @@
      * digit.  For instance, if the range for quads is
      * [-9223372036854775808..9223372036854775807] and the input base
      * is 10, cutoff will be set to 922337203685477580 and cutlim to
-     * either 7 (neg==0) or 8 (neg==1), meaning that if we have
+     * either 7 (neg == 0) or 8 (neg == 1), meaning that if we have
      * accumulated a value &gt; 922337203685477580, or equal but the
      * next digit is &gt; 7 (or 8), the number is too big, and we will
      * return a range error.
@@ -503,7 +503,7 @@
 static jim_wide JimPowWide(jim_wide b, jim_wide e)
 {
     jim_wide i, res = 1;
-    if ((b==0 &amp;&amp; e != 0) || (e&lt;0)) return 0;
+    if ((b == 0 &amp;&amp; e != 0) || (e&lt;0)) return 0;
     for (i=0; i&lt;e; i++) {res *= b;}
     return res;
 }
@@ -568,7 +568,7 @@
 void *Jim_Alloc(int size)
 {
 	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
-	if (size==0)
+	if (size == 0)
 		size=1;
     void *p = malloc(size);
     if (p == NULL)
@@ -583,7 +583,7 @@
 void *Jim_Realloc(void *ptr, int size)
 {
 	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
-	if (size==0)
+	if (size == 0)
 		size=1;
     void *p = realloc(ptr, size);
     if (p == NULL)
@@ -6959,7 +6959,7 @@
             case JIM_EXPROP_GTE: wC = wA &gt;= wB; break;
             case JIM_EXPROP_LSHIFT: wC = wA &lt;&lt; wB; break;
             case JIM_EXPROP_RSHIFT: wC = wA &gt;&gt; wB; break;
-            case JIM_EXPROP_NUMEQ: wC = wA==wB; break;
+            case JIM_EXPROP_NUMEQ: wC = wA == wB; break;
             case JIM_EXPROP_NUMNE: wC = wA != wB; break;
             case JIM_EXPROP_BITAND: wC = wA&wB; break;
             case JIM_EXPROP_BITXOR: wC = wA^wB; break;
@@ -7062,7 +7062,7 @@
             case JIM_EXPROP_GT: dC = dA&gt;dB; break;
             case JIM_EXPROP_LTE: dC = dA &lt;= dB; break;
             case JIM_EXPROP_GTE: dC = dA &gt;= dB; break;
-            case JIM_EXPROP_NUMEQ: dC = dA==dB; break;
+            case JIM_EXPROP_NUMEQ: dC = dA == dB; break;
             case JIM_EXPROP_NUMNE: dC = dA != dB; break;
             case JIM_EXPROP_LOGICAND_LEFT:
                 if (dA == 0) {

Modified: trunk/src/helper/jim.h
===================================================================
--- trunk/src/helper/jim.h	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/helper/jim.h	2009-06-23 22:42:03 UTC (rev 2371)
@@ -578,7 +578,7 @@
  * An NVP Table is terminated with &quot;.name=NULL&quot;.
  *
  * During the 'name2value' operation, if no matching string is found
- * the pointer to the terminal element (with p-&gt;name==NULL) is returned.
+ * the pointer to the terminal element (with p-&gt;name == NULL) is returned.
  *
  * Example:
  * \code

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/bitbang.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -189,7 +189,7 @@
 	for (bit_cnt = 0; bit_cnt &lt; scan_size; bit_cnt++)
 	{
 		int val=0;
-		int tms=(bit_cnt==scan_size-1) ? 1 : 0;
+		int tms=(bit_cnt == scan_size-1) ? 1 : 0;
 		int tdi;
 		int bytec=bit_cnt/8;
 		int bcval=1 &lt;&lt; (bit_cnt % 8);

Modified: trunk/src/jtag/bitq.c
===================================================================
--- trunk/src/jtag/bitq.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/bitq.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -51,7 +51,7 @@
 	while (bitq_in_state.cmd)
 	{
 		/* only JTAG_SCAN command may return data */
-		if (bitq_in_state.cmd-&gt;type==JTAG_SCAN)
+		if (bitq_in_state.cmd-&gt;type == JTAG_SCAN)
 		{
 			/* loop through the fields */
 			while (bitq_in_state.field_idx&lt;bitq_in_state.cmd-&gt;cmd.scan-&gt;num_fields)
@@ -59,7 +59,7 @@
 				field = &amp;bitq_in_state.cmd-&gt;cmd.scan-&gt;fields[bitq_in_state.field_idx];
 				if (field-&gt;in_value)
 				{
-					if (bitq_in_state.bit_pos==0)
+					if (bitq_in_state.bit_pos == 0)
 					{
 						/* initialize field scanning */
 						in_mask = 0x01;
@@ -83,7 +83,7 @@
 									bitq_in_bufsize *= 2;
 							}
 							/* if necessary, allocate buffer and check for malloc error */
-							if (bitq_in_buffer==NULL &amp;&amp; ( bitq_in_buffer = malloc(bitq_in_bufsize) )==NULL)
+							if (bitq_in_buffer == NULL &amp;&amp; ( bitq_in_buffer = malloc(bitq_in_bufsize) ) == NULL)
 							{
 								LOG_ERROR(&quot;malloc error&quot;);
 								exit(-1);
@@ -102,11 +102,11 @@
 #endif
 							return;
 						}
-						if (in_mask==0x01)
+						if (in_mask == 0x01)
 							in_buff[in_idx] = 0;
 						if (tdo)
 							in_buff[in_idx] |= in_mask;
-						if (in_mask==0x80)
+						if (in_mask == 0x80)
 						{
 							in_mask = 0x01;
 							in_idx++;
@@ -226,7 +226,7 @@
 	else
 		tdo_req = 0;
 
-	if (field-&gt;out_value==NULL)
+	if (field-&gt;out_value == NULL)
 	{
 		/* just send zeros and request data from TDO */
 		for (bit_cnt = field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
@@ -242,7 +242,7 @@
 		for (bit_cnt = field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
 		{
 			bitq_io(0, ( (*out_ptr) &amp; out_mask ) != 0, tdo_req);
-			if (out_mask==0x80)
+			if (out_mask == 0x80)
 			{
 				out_mask = 0x01;
 				out_ptr++;
@@ -257,9 +257,9 @@
 	if (pause)
 	{
 		bitq_io(0, 0, 0);
-		if (tap_get_state()==TAP_IRSHIFT)
+		if (tap_get_state() == TAP_IRSHIFT)
 			tap_set_state(TAP_IRPAUSE);
-		else if (tap_get_state()==TAP_DRSHIFT)
+		else if (tap_get_state() == TAP_DRSHIFT)
 			tap_set_state(TAP_DRPAUSE);
 	}
 }

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/core.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -508,9 +508,9 @@
 		tap_state_name(goal_state) );
 
 
-	if (goal_state==cur_state )
+	if (goal_state == cur_state )
 		;	/* nothing to do */
-	else if ( goal_state==TAP_RESET )
+	else if ( goal_state == TAP_RESET )
 	{
 		jtag_add_tlr();
 	}
@@ -576,7 +576,7 @@
 	 */
 	if ((jtag_reset_config &amp; RESET_HAS_SRST)&amp;&amp;
 			(jtag_reset_config &amp; RESET_HAS_TRST)&amp;&amp;
-			((jtag_reset_config &amp; RESET_SRST_PULLS_TRST)==0))
+			((jtag_reset_config &amp; RESET_SRST_PULLS_TRST) == 0))
 	{
 		if (((req_tlr_or_trst&amp;&amp;!jtag_trst)||
 				(!req_tlr_or_trst &amp;&amp; jtag_trst))&amp;&amp;
@@ -746,7 +746,7 @@
 {
 	assert(field-&gt;in_value != NULL);
 
-	if (value==NULL)
+	if (value == NULL)
 	{
 		/* no checking to do */
 		return;
@@ -1216,7 +1216,7 @@
 	if (jtag_reset_config &amp; RESET_HAS_SRST)
 	{
 		jtag_add_reset(1, 1);
-		if ((jtag_reset_config &amp; RESET_SRST_PULLS_TRST)==0)
+		if ((jtag_reset_config &amp; RESET_SRST_PULLS_TRST) == 0)
 			jtag_add_reset(0, 1);
 	}
 	jtag_add_reset(0, 0);
@@ -1238,7 +1238,7 @@
 	int retval;
 	if ((retval=jtag_interface_init(cmd_ctx)) != ERROR_OK)
 		return retval;
-	if (jtag_init_inner(cmd_ctx)==ERROR_OK)
+	if (jtag_init_inner(cmd_ctx) == ERROR_OK)
 	{
 		return ERROR_OK;
 	}

Modified: trunk/src/jtag/driver.c
===================================================================
--- trunk/src/jtag/driver.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/driver.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -476,7 +476,7 @@
 	entry-&gt;data2=data2;
 	entry-&gt;data3=data3;
 
-	if (jtag_callback_queue_head==NULL)
+	if (jtag_callback_queue_head == NULL)
 	{
 		jtag_callback_queue_head=entry;
 		jtag_callback_queue_tail=entry;

Modified: trunk/src/jtag/dummy.c
===================================================================
--- trunk/src/jtag/dummy.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/dummy.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -131,7 +131,7 @@
 
 static int dummy_khz(int khz, int *jtag_speed)
 {
-	if (khz==0)
+	if (khz == 0)
 	{
 		*jtag_speed=0;
 	}
@@ -144,7 +144,7 @@
 
 static int dummy_speed_div(int speed, int *khz)
 {
-	if (speed==0)
+	if (speed == 0)
 	{
 		*khz = 0;
 	}

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/ft2232.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -50,7 +50,7 @@
 
 #include &lt;assert.h&gt;
 
-#if (BUILD_FT2232_FTD2XX==1 &amp;&amp; BUILD_FT2232_LIBFTDI==1)
+#if (BUILD_FT2232_FTD2XX == 1 &amp;&amp; BUILD_FT2232_LIBFTDI == 1)
 #error &quot;BUILD_FT2232_FTD2XX &amp;&amp; BUILD_FT2232_LIBFTDI are mutually exclusive&quot;
 #elif (BUILD_FT2232_FTD2XX != 1 &amp;&amp; BUILD_FT2232_LIBFTDI != 1)
 #error &quot;BUILD_FT2232_FTD2XX || BUILD_FT2232_LIBFTDI must be chosen&quot;
@@ -274,7 +274,7 @@
 		*/
 		++tms_ndx;
 
-		if (tms_ndx==7  || i==tms_count-1)
+		if (tms_ndx == 7  || i == tms_count-1)
 		{
 			buffer_write(mpsse_cmd);
 			buffer_write(tms_ndx - 1);
@@ -498,7 +498,7 @@
 
 static int ft2232_khz(int khz, int* jtag_speed)
 {
-	if (khz==0)
+	if (khz == 0)
 	{
 #ifdef BUILD_FTD2XX_HIGHSPEED
 		*jtag_speed = 0;
@@ -2049,7 +2049,7 @@
 	const ft2232_layout_t* cur_layout = ft2232_layouts;
 	int i;
 
-	if (tap_get_tms_path_len(TAP_IRPAUSE,TAP_IRPAUSE)==7)
+	if (tap_get_tms_path_len(TAP_IRPAUSE,TAP_IRPAUSE) == 7)
 	{
 		LOG_DEBUG(&quot;ft2232 interface using 7 step jtag state transitions&quot;);
 	}

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/jlink.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -770,7 +770,7 @@
 
 	/* JLink returns an extra NULL in packet when size of in message is a multiple of 64, creates problems with usb comms */
 	/* WARNING This will interfere with tap state counting */
-	while ((TAP_SCAN_BYTES(tap_length)%64)==0)
+	while ((TAP_SCAN_BYTES(tap_length)%64) == 0)
 	{
 		jlink_tap_append_step((tap_get_state() == TAP_RESET)?1:0, 0);
 	}
@@ -932,7 +932,7 @@
 		if (1 != result2)
 		{
 			LOG_ERROR(&quot;jlink_usb_read_emu_result retried requested=1, result=%d, in_length=%i&quot;, result2,in_length);
-			/* Try again once, should only happen if (in_length%64==0) */
+			/* Try again once, should only happen if (in_length%64 == 0) */
 			result2 = jlink_usb_read_emu_result(jlink_jtag);
 			if (1 != result2)
 			{

Modified: trunk/src/jtag/presto.c
===================================================================
--- trunk/src/jtag/presto.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/presto.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -534,7 +534,7 @@
 	if (presto-&gt;buff_out_pos &gt;= BUFFER_SIZE)
 #elif BUILD_PRESTO_LIBFTDI == 1
 	/* libftdi does not do background read, be sure that USB IN buffer does not overflow (128 bytes only!) */
-	if (presto-&gt;buff_out_pos &gt;= BUFFER_SIZE || presto-&gt;buff_in_exp==128)
+	if (presto-&gt;buff_out_pos &gt;= BUFFER_SIZE || presto-&gt;buff_in_exp == 128)
 #endif
 		return presto_flush();
 

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/tcl.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -1208,7 +1208,7 @@
 	for (i = 0; i &lt; num_fields; i++)
 	{
 		tap = jtag_tap_by_string( args[i*2] );
-		if (tap==NULL)
+		if (tap == NULL)
 		{
 			command_print( cmd_ctx, &quot;Tap: %s unknown&quot;, args[i*2] );
 			return ERROR_FAIL;

Modified: trunk/src/jtag/usbprog.c
===================================================================
--- trunk/src/jtag/usbprog.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/usbprog.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -591,7 +591,7 @@
 		{
 			send_bits = size;
 			loops = size/8;
-			/* if (loops==0) */
+			/* if (loops == 0) */
 			loops++;
 			size = 0;
 		}

Modified: trunk/src/jtag/zy1000/jtag_minidriver.h
===================================================================
--- trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:42:03 UTC (rev 2371)
@@ -41,7 +41,7 @@
 	do
 	{
 		ZY1000_PEEK(ZY1000_JTAG_BASE+0x10, empty);
-	} while ((empty &amp; 0x100)==0);
+	} while ((empty &amp; 0x100) == 0);
 }
 
 static __inline__ void waitQueue(void)
@@ -64,7 +64,7 @@
 	cyg_uint32 a;
 	a=state;
 	int repeat=0;
-	if (state==TAP_RESET)
+	if (state == TAP_RESET)
 	{
 		// The FPGA nor we know the current state of the CPU TAP
 		// controller. This will move it to TAP for sure.
@@ -92,7 +92,7 @@
 	ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value);
 #if 1
 #if TEST_MANUAL()
-	if ((state==TAP_DRSHIFT) &amp;&amp; (endState != TAP_DRSHIFT))
+	if ((state == TAP_DRSHIFT) &amp;&amp; (endState != TAP_DRSHIFT))
 	{
 		int i;
 		setCurrentState(state);
@@ -100,7 +100,7 @@
 		{
 			int tms;
 			tms=0;
-			if ((i==repeat-1) &amp;&amp; (state != endState))
+			if ((i == repeat-1) &amp;&amp; (state != endState))
 			{
 				tms=1;
 			}
@@ -124,7 +124,7 @@
 #endif
 #else
 	/* maximum debug version */
-	if ((repeat&gt;0) &amp;&amp; ((state==TAP_DRSHIFT)||(state==TAP_SI)))
+	if ((repeat&gt;0) &amp;&amp; ((state == TAP_DRSHIFT)||(state == TAP_SI)))
 	{
 		int i;
 		/* sample shift register for every bit. */
@@ -160,7 +160,7 @@
 	for (tap = jtag_tap_next_enabled(NULL); tap!= NULL; tap=nextTap)
 	{
 		nextTap=jtag_tap_next_enabled(tap);
-		if (nextTap==NULL)
+		if (nextTap == NULL)
 		{
 			pause_state = end_state;
 		}
@@ -187,14 +187,14 @@
 		enum tap_state end_state)
 {
 
-	int singletap=(jtag_tap_next_enabled(jtag_tap_next_enabled(NULL))==NULL);
-	if ((singletap) &amp;&amp; (num_fields==3))
+	int singletap=(jtag_tap_next_enabled(jtag_tap_next_enabled(NULL)) == NULL);
+	if ((singletap) &amp;&amp; (num_fields == 3))
 	{
 		/* used by embeddedice_write_reg_inner() */
 		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, num_bits[0], value[0]);
 		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, num_bits[1], value[1]);
 		shiftValueInner(TAP_DRSHIFT, end_state, num_bits[2], value[2]);
-	} else if ((singletap) &amp;&amp; (num_fields==2))
+	} else if ((singletap) &amp;&amp; (num_fields == 2))
 	{
 		/* used by arm7 code */
 		shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, num_bits[0], value[0]);

Modified: trunk/src/jtag/zy1000/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -49,7 +49,7 @@
 
 static int zy1000_khz(int khz, int *jtag_speed)
 {
-	if (khz==0)
+	if (khz == 0)
 	{
 		*jtag_speed=0;
 	}
@@ -62,7 +62,7 @@
 
 static int zy1000_speed_div(int speed, int *khz)
 {
-	if (speed==0)
+	if (speed == 0)
 	{
 		*khz = 0;
 	}
@@ -176,7 +176,7 @@
 			alive_sleep(1);
 		}
 
-		if (i==1000)
+		if (i == 1000)
 		{
 			LOG_USER(&quot;SRST didn't deassert after %dms&quot;, i);
 		} else if (i&gt;1)
@@ -439,7 +439,7 @@
 			tap_state_t pause_state;
 			int l;
 			k=num_bits-j;
-			pause_state=(shiftState==TAP_DRSHIFT)?TAP_DRSHIFT:TAP_IRSHIFT;
+			pause_state=(shiftState == TAP_DRSHIFT)?TAP_DRSHIFT:TAP_IRSHIFT;
 			if (k&gt;32)
 			{
 				k=32;
@@ -498,7 +498,7 @@
 	{
 		nextTap=jtag_tap_next_enabled(tap);
 		tap_state_t end_state;
-		if (nextTap==NULL)
+		if (nextTap == NULL)
 		{
 			end_state = state;
 		} else
@@ -568,7 +568,7 @@
 		nextTap=jtag_tap_next_enabled(tap);
 		int found=0;
 		tap_state_t end_state;
-		if (nextTap==NULL)
+		if (nextTap == NULL)
 		{
 			end_state = state;
 		} else
@@ -732,7 +732,7 @@
 {
 //	static int const reg_addr=0x5;
 	tap_state_t end_state=jtag_get_end_state();
-	if (jtag_tap_next_enabled(jtag_tap_next_enabled(NULL))==NULL)
+	if (jtag_tap_next_enabled(jtag_tap_next_enabled(NULL)) == NULL)
 	{
 		/* better performance via code duplication */
 		if (little)

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/server/gdb_server.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -105,7 +105,7 @@
 	fd_set read_fds;
 	gdb_connection_t *gdb_con = connection-&gt;priv;
 	int t;
-	if (got_data==NULL)
+	if (got_data == NULL)
 		got_data=&t;
 	*got_data=0;
 
@@ -1397,7 +1397,7 @@
 	else if (type == 4) /* access watchpoint */
 		wp_type = WPT_ACCESS;
 
-	if (gdb_breakpoint_override &amp;&amp; ((bp_type==BKPT_SOFT)||(bp_type==BKPT_HARD)))
+	if (gdb_breakpoint_override &amp;&amp; ((bp_type == BKPT_SOFT)||(bp_type == BKPT_HARD)))
 	{
 		bp_type=gdb_breakpoint_override_type;
 	}
@@ -1560,7 +1560,7 @@
 	b1=*((flash_bank_t **)a);
 	b2=*((flash_bank_t **)b);
 
-	if (b1-&gt;base==b2-&gt;base)
+	if (b1-&gt;base == b2-&gt;base)
 	{
 		return 0;
 	} else if (b1-&gt;base&gt;b2-&gt;base)
@@ -2349,13 +2349,13 @@
 	if (argc == 0)
 	{
 
-	} else if (argc==1)
+	} else if (argc == 1)
 	{
 		gdb_breakpoint_override = 1;
-		if (strcmp(args[0], &quot;hard&quot;)==0)
+		if (strcmp(args[0], &quot;hard&quot;) == 0)
 		{
 			gdb_breakpoint_override_type=BKPT_HARD;
-		} else if (strcmp(args[0], &quot;soft&quot;)==0)
+		} else if (strcmp(args[0], &quot;soft&quot;) == 0)
 		{
 			gdb_breakpoint_override_type=BKPT_SOFT;
 		} else if (strcmp(args[0], &quot;disable&quot;) == 0)
@@ -2368,7 +2368,7 @@
 	}
 	if (gdb_breakpoint_override)
 	{
-		LOG_USER(&quot;force %s breakpoints&quot;, (gdb_breakpoint_override_type==BKPT_HARD)?&quot;hard&quot;:&quot;soft&quot;);
+		LOG_USER(&quot;force %s breakpoints&quot;, (gdb_breakpoint_override_type == BKPT_HARD)?&quot;hard&quot;:&quot;soft&quot;);
 	} else
 	{
 		LOG_USER(&quot;breakpoint type is not overriden&quot;);

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/arm11.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -1540,7 +1540,7 @@
 
 	arm11-&gt;target = target;
 
-	if (target-&gt;tap==NULL)
+	if (target-&gt;tap == NULL)
 		return ERROR_FAIL;
 
 	if (target-&gt;tap-&gt;ir_length != 5)

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/arm7_9_common.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -131,7 +131,7 @@
 		return ERROR_FAIL;
 	}
 
-	if (arm7_9-&gt;sw_breakpoints_added==1)
+	if (arm7_9-&gt;sw_breakpoints_added == 1)
 	{
 		embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_DATA_VALUE], arm7_9-&gt;arm_bkpt);
 		embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_DATA_MASK], 0x0);
@@ -139,7 +139,7 @@
 		embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_CONTROL_MASK], ~EICE_W_CTRL_nOPC &amp; 0xff);
 		embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_CONTROL_VALUE], EICE_W_CTRL_ENABLE);
 	}
-	else if (arm7_9-&gt;sw_breakpoints_added==2)
+	else if (arm7_9-&gt;sw_breakpoints_added == 2)
 	{
 		embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W1_DATA_VALUE], arm7_9-&gt;arm_bkpt);
 		embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W1_DATA_MASK], 0x0);
@@ -232,12 +232,12 @@
 		uint32_t mask = (breakpoint-&gt;length == 4) ? 0x3u : 0x1u;
 
 		/* reassign a hw breakpoint */
-		if (breakpoint-&gt;set==0)
+		if (breakpoint-&gt;set == 0)
 		{
 			arm7_9_assign_wp(arm7_9, breakpoint);
 		}
 
-		if (breakpoint-&gt;set==1)
+		if (breakpoint-&gt;set == 1)
 		{
 			embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_ADDR_VALUE], breakpoint-&gt;address);
 			embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_ADDR_MASK], mask);
@@ -245,7 +245,7 @@
 			embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_CONTROL_MASK], ~EICE_W_CTRL_nOPC &amp; 0xff);
 			embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W0_CONTROL_VALUE], EICE_W_CTRL_ENABLE);
 		}
-		else if (breakpoint-&gt;set==2)
+		else if (breakpoint-&gt;set == 2)
 		{
 			embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W1_ADDR_VALUE], breakpoint-&gt;address);
 			embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W1_ADDR_MASK], mask);
@@ -377,7 +377,7 @@
 			{
 				return retval;
 			}
-			if (current_instr==arm7_9-&gt;arm_bkpt)
+			if (current_instr == arm7_9-&gt;arm_bkpt)
 				if ((retval = target_write_memory(target, breakpoint-&gt;address, 4, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
 				{
 					return retval;
@@ -391,7 +391,7 @@
 			{
 				return retval;
 			}
-			if (current_instr==arm7_9-&gt;thumb_bkpt)
+			if (current_instr == arm7_9-&gt;thumb_bkpt)
 				if ((retval = target_write_memory(target, breakpoint-&gt;address, 2, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
 				{
 					return retval;
@@ -423,7 +423,7 @@
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	if (arm7_9-&gt;breakpoint_count==0)
+	if (arm7_9-&gt;breakpoint_count == 0)
 	{
 		/* make sure we don't have any dangling breakpoints. This is vital upon
 		 * GDB connect/disconnect
@@ -478,7 +478,7 @@
 		arm7_9-&gt;wp_available++;
 
 	arm7_9-&gt;breakpoint_count--;
-	if (arm7_9-&gt;breakpoint_count==0)
+	if (arm7_9-&gt;breakpoint_count == 0)
 	{
 		/* make sure we don't have any dangling breakpoints */
 		if ((retval = arm7_9_clear_watchpoints(arm7_9)) != ERROR_OK)
@@ -906,7 +906,7 @@
 				if (target-&gt;reset_halt)
 				{
 					enum reset_types jtag_reset_config = jtag_get_reset_config();
-					if ((jtag_reset_config &amp; RESET_SRST_PULLS_TRST)==0)
+					if ((jtag_reset_config &amp; RESET_SRST_PULLS_TRST) == 0)
 					{
 						check_pc = 1;
 					}
@@ -1022,7 +1022,7 @@
 
 	armv4_5_invalidate_core_regs(target);
 
-	if ((target-&gt;reset_halt) &amp;&amp; ((jtag_reset_config &amp; RESET_SRST_PULLS_TRST)==0))
+	if ((target-&gt;reset_halt) &amp;&amp; ((jtag_reset_config &amp; RESET_SRST_PULLS_TRST) == 0))
 	{
 		/* debug entry was already prepared in arm7_9_assert_reset() */
 		target-&gt;debug_reason = DBG_REASON_DBGRQ;
@@ -1246,7 +1246,7 @@
  */
 int arm7_9_halt(target_t *target)
 {
-	if (target-&gt;state==TARGET_RESET)
+	if (target-&gt;state == TARGET_RESET)
 	{
 		LOG_ERROR(&quot;BUG: arm7/9 does not support halt during reset. This is handled in arm7_9_assert_reset()&quot;);
 		return ERROR_OK;
@@ -2272,7 +2272,7 @@
 				buffer += thisrun_accesses * 4;
 				num_accesses += thisrun_accesses;
 
-				if ((j++%1024)==0)
+				if ((j++%1024) == 0)
 				{
 					keep_alive();
 				}
@@ -2310,7 +2310,7 @@
 				buffer += thisrun_accesses * 2;
 				num_accesses += thisrun_accesses;
 
-				if ((j++%1024)==0)
+				if ((j++%1024) == 0)
 				{
 					keep_alive();
 				}
@@ -2347,7 +2347,7 @@
 				buffer += thisrun_accesses * 1;
 				num_accesses += thisrun_accesses;
 
-				if ((j++%1024)==0)
+				if ((j++%1024) == 0)
 				{
 					keep_alive();
 				}
@@ -2579,7 +2579,7 @@
 	if ((retval=target_wait_state(target, TARGET_DEBUG_RUNNING, 500)) != ERROR_OK)
 		return retval;
 
-	int little=target-&gt;endianness==TARGET_LITTLE_ENDIAN;
+	int little=target-&gt;endianness == TARGET_LITTLE_ENDIAN;
 	int count=dcc_count;
 	uint8_t *buffer=dcc_buffer;
 	if (count&gt;2)
@@ -2674,7 +2674,7 @@
 	retval = armv4_5_run_algorithm_inner(target, 0, NULL, 1, reg_params,
 			arm7_9-&gt;dcc_working_area-&gt;address, arm7_9-&gt;dcc_working_area-&gt;address+6*4, 20*1000, &amp;armv4_5_info, arm7_9_dcc_completion);
 
-	if (retval==ERROR_OK)
+	if (retval == ERROR_OK)
 	{
 		uint32_t endaddress=buf_get_u32(reg_params[0].value, 0, 32);
 		if (endaddress != (address+count*4))

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/arm7tdmi.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -254,7 +254,7 @@
 
 /* clock the target, and read the databus
  * the *in pointer points to a buffer where elements of 'size' bytes
- * are stored in big (be==1) or little (be==0) endianness
+ * are stored in big (be == 1) or little (be == 0) endianness
  */
 int arm7tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info, void *in, int size, int be)
 {
@@ -725,7 +725,7 @@
 		/* get pointers to arch-specific information */
 		reg_cache_t **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
 		reg_cache_t *t=embeddedice_build_reg_cache(target, arm7_9);
-		if (t==NULL)
+		if (t == NULL)
 			return ERROR_FAIL;
 
 		(*cache_p) = t;

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/arm9tdmi.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -301,7 +301,7 @@
 
 /* clock the target, and read the databus
  * the *in pointer points to a buffer where elements of 'size' bytes
- * are stored in big (be==1) or little (be==0) endianness
+ * are stored in big (be == 1) or little (be == 0) endianness
  */
 int arm9tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info, void *in, int size, int be)
 {
@@ -818,7 +818,7 @@
 		reg_cache_t *t;
 		/* one extra register (vector catch) */
 		t=embeddedice_build_reg_cache(target, arm7_9);
-		if (t==NULL)
+		if (t == NULL)
 			return ERROR_FAIL;
 		(*cache_p) = t;
 		arm7_9-&gt;eice_cache = (*cache_p);

Modified: trunk/src/target/arm_adi_v5.c
===================================================================
--- trunk/src/target/arm_adi_v5.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/arm_adi_v5.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -165,7 +165,7 @@
 {
 	adi_jtag_dp_scan_u32(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
-	if ((RnW==DPAP_READ) &amp;&amp; (invalue != NULL))
+	if ((RnW == DPAP_READ) &amp;&amp; (invalue != NULL))
 	{
 		adi_jtag_dp_scan_u32(swjdp, DAP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
 	}
@@ -1108,7 +1108,7 @@
 				command_print(cmd_ctx, &quot;\t\tComponent cid1 0x%&quot; PRIx32 &quot;, class is %s&quot;,c_cid1,class_description[(c_cid1 &gt;&gt; 4)&amp;0xF]); /* Se ARM DDI 0314 C Table 2.2 */
 				command_print(cmd_ctx, &quot;\t\tCID3 0x%&quot; PRIx32 &quot;, CID2 0x%&quot; PRIx32 &quot;, CID1 0x%&quot; PRIx32 &quot;, CID0, 0x%&quot; PRIx32 &quot;&quot;,c_cid3,c_cid2,c_cid1,c_cid0);
 				command_print(cmd_ctx, &quot;\t\tPID3 0x%&quot; PRIx32 &quot;, PID2 0x%&quot; PRIx32 &quot;, PID1 0x%&quot; PRIx32 &quot;, PID0, 0x%&quot; PRIx32 &quot;&quot;,c_pid3,c_pid2,c_pid1,c_pid0);
-				/* For CoreSight components,  (c_cid1 &gt;&gt; 4)&amp;0xF==9 , we also read 0xFC8 DevId and 0xFCC DevType */
+				/* For CoreSight components,  (c_cid1 &gt;&gt; 4)&amp;0xF == 9 , we also read 0xFC8 DevId and 0xFCC DevType */
 			}
 			else
 			{

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/arm_disassembler.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -1158,7 +1158,7 @@
 	}
 	else if ((op == 0xd) || (op == 0xf)) /* &lt;opcode1&gt;{&lt;cond&gt;}{S} &lt;Rd&gt;, &lt;shifter_operand&gt; */
 	{
-		if (opcode==0xe1a00000) /* print MOV r0,r0 as NOP */
+		if (opcode == 0xe1a00000) /* print MOV r0,r0 as NOP */
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tNOP&quot;,address, opcode);
 		else
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, %s&quot;,
@@ -1327,7 +1327,7 @@
 	char *mnemonic = NULL;
 	
 	/* sign extend 11-bit offset */
-	if (((opc==0) || (opc==2)) &amp;&amp; (offset &amp; 0x00000400))
+	if (((opc == 0) || (opc == 2)) &amp;&amp; (offset &amp; 0x00000400))
 		offset = 0xfffff800 | offset;
 	
 	target_address = address + 4 + (offset &lt;&lt; 1);
@@ -1435,7 +1435,7 @@
 			break;
 	}
 
-	if ((imm==0) &amp;&amp; (opc != 0))
+	if ((imm == 0) &amp;&amp; (opc != 0))
 		imm = 32;
 
 	instruction-&gt;info.data_proc.Rd = Rd;
@@ -1748,7 +1748,7 @@
 		mnemonic = &quot;STR&quot;;
 	}
 
-	if ((opcode&amp;0xF000)==0x8000)
+	if ((opcode&amp;0xF000) == 0x8000)
 	{
 		suffix = 'H';
 		shift = 1;

Modified: trunk/src/target/arm_jtag.c
===================================================================
--- trunk/src/target/arm_jtag.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/arm_jtag.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -35,7 +35,7 @@
 {
 	jtag_tap_t *tap;
 	tap = jtag_info-&gt;tap;
-	if (tap==NULL)
+	if (tap == NULL)
 		return ERROR_FAIL;
 
 	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != new_instr)
@@ -51,7 +51,7 @@
 		
 
 
-		if (no_verify_capture==NULL)
+		if (no_verify_capture == NULL)
 		{
 			jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());
 		} else

Modified: trunk/src/target/breakpoints.c
===================================================================
--- trunk/src/target/breakpoints.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/breakpoints.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -99,13 +99,13 @@
 	
 	while (breakpoint)
 	{
-		if (breakpoint==breakpoint_remove)
+		if (breakpoint == breakpoint_remove)
 			break;
 		breakpoint_p = &amp;breakpoint-&gt;next;
 		breakpoint = breakpoint-&gt;next;
 	}
 	
-	if (breakpoint==NULL)
+	if (breakpoint == NULL)
 		return;
 	
 	target_remove_breakpoint(target, breakpoint);
@@ -227,7 +227,7 @@
 		watchpoint = watchpoint-&gt;next;
 	}
 	
-	if (watchpoint==NULL)
+	if (watchpoint == NULL)
 		return;
 	target_remove_watchpoint(target, watchpoint);
 	(*watchpoint_p) = watchpoint-&gt;next;

Modified: trunk/src/target/etb.c
===================================================================
--- trunk/src/target/etb.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/etb.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -49,7 +49,7 @@
 	jtag_tap_t *tap;
 
 	tap = etb-&gt;tap;
-	if (tap==NULL)
+	if (tap == NULL)
 		return ERROR_FAIL;
 
 	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != new_instr)

Modified: trunk/src/target/image.c
===================================================================
--- trunk/src/target/image.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/image.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -34,11 +34,11 @@
 
 /* convert ELF header field to host endianness */
 #define field16(elf,field)\
-	((elf-&gt;endianness==ELFDATA2LSB)? \
+	((elf-&gt;endianness == ELFDATA2LSB)? \
 		le_to_h_u16((uint8_t*)&amp;field):be_to_h_u16((uint8_t*)&amp;field))
 
 #define field32(elf,field)\
-	((elf-&gt;endianness==ELFDATA2LSB)? \
+	((elf-&gt;endianness == ELFDATA2LSB)? \
 		le_to_h_u32((uint8_t*)&amp;field):be_to_h_u32((uint8_t*)&amp;field))
 
 static int autodetect_image_type(image_t *image, char *url)
@@ -55,7 +55,7 @@
 	}
 	retval = fileio_read(&amp;fileio, 9, buffer, &amp;read_bytes);
 
-	if (retval==ERROR_OK)
+	if (retval == ERROR_OK)
 	{
 		if (read_bytes != 9)
 		{
@@ -68,7 +68,7 @@
 		return retval;
 
 	/* check header against known signatures */
-	if (strncmp((char*)buffer,ELFMAG,SELFMAG)==0)
+	if (strncmp((char*)buffer,ELFMAG,SELFMAG) == 0)
 	{
 		LOG_DEBUG(&quot;ELF image detected.&quot;);
 		image-&gt;type = IMAGE_ELF;
@@ -382,7 +382,7 @@
 	}
 
 	elf-&gt;segment_count = field16(elf,elf-&gt;header-&gt;e_phnum);
-	if (elf-&gt;segment_count==0)
+	if (elf-&gt;segment_count == 0)
 	{
 		LOG_ERROR(&quot;invalid ELF file, no program headers&quot;);
 		return ERROR_IMAGE_FORMAT_ERROR;

Modified: trunk/src/target/mips32_pracc.c
===================================================================
--- trunk/src/target/mips32_pracc.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/mips32_pracc.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -278,7 +278,7 @@
 		case 2:
 			return mips32_pracc_read_mem16(ejtag_info, addr, count, (uint16_t*)buf);
 		case 4:
-			if (count==1)
+			if (count == 1)
 				return mips32_pracc_read_u32(ejtag_info, addr, (uint32_t*)buf);
 			else
 				return mips32_pracc_read_mem32(ejtag_info, addr, count, (uint32_t*)buf);
@@ -562,7 +562,7 @@
 		case 2:
 			return mips32_pracc_write_mem16(ejtag_info, addr, count,(uint16_t*)buf);
 		case 4:
-			if (count==1)
+			if (count == 1)
 				return mips32_pracc_write_u32(ejtag_info, addr, (uint32_t*)buf);
 			else
 				return mips32_pracc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);

Modified: trunk/src/target/mips_ejtag.c
===================================================================
--- trunk/src/target/mips_ejtag.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/mips_ejtag.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -32,7 +32,7 @@
 	jtag_tap_t *tap;
 
 	tap = ejtag_info-&gt;tap;
-	if (tap==NULL)
+	if (tap == NULL)
 		return ERROR_FAIL;
 
 	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != (uint32_t)new_instr)
@@ -115,7 +115,7 @@
 	jtag_tap_t *tap;
 	tap  = ejtag_info-&gt;tap;
 
-	if (tap==NULL)
+	if (tap == NULL)
 		return ERROR_FAIL;
 	scan_field_t field;
 	uint8_t t[4], r[4];

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/target.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -1079,7 +1079,7 @@
 int target_arch_state(struct target_s *target)
 {
 	int retval;
-	if (target==NULL)
+	if (target == NULL)
 	{
 		LOG_USER(&quot;No target has been configured&quot;);
 		return ERROR_OK;
@@ -1851,7 +1851,7 @@
 			return retval;
 
 	}
-	else if (argc==1)
+	else if (argc == 1)
 	{
 		if (strcmp(args[0], &quot;on&quot;) == 0)
 		{
@@ -2314,7 +2314,7 @@
 		return retvaltemp;
 	}
 
-	if (retval==ERROR_OK)
+	if (retval == ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;downloaded %u byte in %s&quot;, 
 					  (unsigned int)image_size, 
@@ -2390,7 +2390,7 @@
 	if ((retvaltemp = duration_stop_measure(&amp;duration, &amp;duration_text)) != ERROR_OK)
 		return retvaltemp;
 
-	if (retval==ERROR_OK)
+	if (retval == ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;dumped %lld byte in %s&quot;,
 				fileio.size, duration_text);
@@ -2517,7 +2517,7 @@
 							retval=ERROR_FAIL;
 							goto done;
 						}
-						if ((t%16384)==0)
+						if ((t%16384) == 0)
 						{
 							keep_alive();
 						}
@@ -2544,7 +2544,7 @@
 		return retvaltemp;
 	}
 
-	if (retval==ERROR_OK)
+	if (retval == ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;verified %u bytes in %s&quot;, 
 					  (unsigned int)image_size, 
@@ -2808,7 +2808,7 @@
 {
 	uint32_t i;
 	FILE *f=fopen(filename, &quot;w&quot;);
-	if (f==NULL)
+	if (f == NULL)
 		return;
 	writeString(f, &quot;gmon&quot;);
 	writeLong(f, 0x00000001); /* Version */
@@ -2843,7 +2843,7 @@
 		length=maxBuckets;
 	}
 	int *buckets=malloc(sizeof(int)*length);
-	if (buckets==NULL)
+	if (buckets == NULL)
 	{
 		fclose(f);
 		return;
@@ -2918,7 +2918,7 @@
 
 	static const int maxSample=10000;
 	uint32_t *samples=malloc(sizeof(uint32_t)*maxSample);
-	if (samples==NULL)
+	if (samples == NULL)
 		return ERROR_OK;
 
 	int numSamples=0;
@@ -4432,7 +4432,7 @@
 	retval = ERROR_OK;
 	fastload_num=image.num_sections;
 	fastload=(struct FastLoad *)malloc(sizeof(struct FastLoad)*image.num_sections);
-	if (fastload==NULL)
+	if (fastload == NULL)
 	{
 		image_close(&amp;image);
 		return ERROR_FAIL;
@@ -4477,7 +4477,7 @@
 
 			fastload[i].address=image.sections[i].base_address+offset;
 			fastload[i].data=malloc(length);
-			if (fastload[i].data==NULL)
+			if (fastload[i].data == NULL)
 			{
 				free(buffer);
 				break;
@@ -4495,7 +4495,7 @@
 	}
 
 	duration_stop_measure(&amp;duration, &amp;duration_text);
-	if (retval==ERROR_OK)
+	if (retval == ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;Loaded %u bytes in %s&quot;, (unsigned int)image_size, duration_text);
 		command_print(cmd_ctx, &quot;NB!!! image has not been loaded to target, issue a subsequent 'fast_load' to do so.&quot;);
@@ -4516,7 +4516,7 @@
 {
 	if (argc&gt;0)
 		return ERROR_COMMAND_SYNTAX_ERROR;
-	if (fastload==NULL)
+	if (fastload == NULL)
 	{
 		LOG_ERROR(&quot;No image in memory&quot;);
 		return ERROR_FAIL;
@@ -4531,7 +4531,7 @@
 		command_print(cmd_ctx, &quot;Write to 0x%08x, length 0x%08x&quot;, 
 					  (unsigned int)(fastload[i].address), 
 					  (unsigned int)(fastload[i].length));
-		if (retval==ERROR_OK)
+		if (retval == ERROR_OK)
 		{
 			retval = target_write_buffer(target, fastload[i].address, fastload[i].length, fastload[i].data);
 		}

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-06-23 22:41:13 UTC (rev 2370)
+++ trunk/src/target/xscale.c	2009-06-23 22:42:03 UTC (rev 2371)
@@ -197,7 +197,7 @@
 
 int xscale_jtag_set_instr(jtag_tap_t *tap, uint32_t new_instr)
 {
-	if (tap==NULL)
+	if (tap == NULL)
 		return ERROR_FAIL;
 
 	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != new_instr)
@@ -301,7 +301,7 @@
 
 int xscale_receive(target_t *target, uint32_t *buffer, int num_words)
 {
-	if (num_words==0)
+	if (num_words == 0)
 		return ERROR_INVALID_ARGUMENTS;
 
 	int retval=ERROR_OK;
@@ -392,7 +392,7 @@
 				words_scheduled--;
 			}
 		}
-		if (words_scheduled==0)
+		if (words_scheduled == 0)
 		{
 			if (attempts++==1000)
 			{


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001154.html">[Openocd-svn] r2370 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
</A></li>
	<LI>Next message: <A HREF="001156.html">[Openocd-svn] r2372 - in trunk: src src/flash	src/flash/ocl/at91sam7x src/helper src/jtag	src/jtag/minidummy src/jtag/rlink src/jtag/zy1000 src/pld	src/server src/target src/xsvf testing/examples/cortex
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1155">[ date ]</a>
              <a href="thread.html#1155">[ thread ]</a>
              <a href="subject.html#1155">[ subject ]</a>
              <a href="author.html#1155">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
