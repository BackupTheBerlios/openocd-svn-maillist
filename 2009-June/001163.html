<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2379 - in trunk/src: flash flash/ocl/at91sam7x	target target/xscale
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2379%20-%20in%20trunk/src%3A%20flash%20flash/ocl/at91sam7x%0A%09target%20target/xscale&In-Reply-To=%3C200906232250.n5NMo4gk023777%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001162.html">
   <LINK REL="Next"  HREF="001164.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2379 - in trunk/src: flash flash/ocl/at91sam7x	target target/xscale</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2379%20-%20in%20trunk/src%3A%20flash%20flash/ocl/at91sam7x%0A%09target%20target/xscale&In-Reply-To=%3C200906232250.n5NMo4gk023777%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2379 - in trunk/src: flash flash/ocl/at91sam7x	target target/xscale">zwelch at mail.berlios.de
       </A><BR>
    <I>Wed Jun 24 00:50:04 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001162.html">[Openocd-svn] r2378 - in trunk/src: flash helper jtag pld server	target
</A></li>
        <LI>Next message: <A HREF="001164.html">[Openocd-svn] r2380 - in trunk: src/helper src/jtag src/server	src/svf src/xsvf testing/examples/AT91R40008Test/inc	testing/examples/AT91R40008Test/src testing/examples/LPC2148Test/inc	testing/examples/LPC2148Test/src testing/examples/LPC2294Test/inc	testing/examples/LPC2294Test/src testing/examples/PIC32	testing/examples/SAM7S256Test/inc testing/examples/SAM7S256Test/src	testing/examples/SAM7X256Test/inc testing/examples/SAM7X256Test/src	testing/examples/STR710JtagSpeed/inc	testing/examples/STR710JtagSpeed/src testing/examples/STR710Test/inc	testing/examples/STR710Test/src testing/examples/STR912Test/inc	testing/examples/STR912Test/src testing/examples/cortex	testing/examples/ledtest-imx27ads testing/examples/ledtest-imx31pdk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1163">[ date ]</a>
              <a href="thread.html#1163">[ thread ]</a>
              <a href="subject.html#1163">[ subject ]</a>
              <a href="author.html#1163">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-24 00:49:23 +0200 (Wed, 24 Jun 2009)
New Revision: 2379

Modified:
   trunk/src/flash/aduc702x.c
   trunk/src/flash/at91sam7.c
   trunk/src/flash/cfi.c
   trunk/src/flash/flash.c
   trunk/src/flash/flash.h
   trunk/src/flash/mflash.c
   trunk/src/flash/nand.c
   trunk/src/flash/ocl/at91sam7x/samflash.c
   trunk/src/flash/pic32mx.c
   trunk/src/flash/stellaris.c
   trunk/src/flash/str7x.c
   trunk/src/flash/tms470.c
   trunk/src/target/algorithm.h
   trunk/src/target/arm11.c
   trunk/src/target/arm926ejs.h
   trunk/src/target/arm9tdmi.h
   trunk/src/target/arm_adi_v5.h
   trunk/src/target/arm_disassembler.c
   trunk/src/target/arm_disassembler.h
   trunk/src/target/arm_jtag.c
   trunk/src/target/arm_simulator.c
   trunk/src/target/armv4_5.c
   trunk/src/target/armv7m.c
   trunk/src/target/armv7m.h
   trunk/src/target/breakpoints.c
   trunk/src/target/cortex_m3.h
   trunk/src/target/feroceon.c
   trunk/src/target/mips32.c
   trunk/src/target/mips32.h
   trunk/src/target/mips32_dmaacc.c
   trunk/src/target/mips32_pracc.c
   trunk/src/target/mips_ejtag.c
   trunk/src/target/mips_m4k.c
   trunk/src/target/target.c
   trunk/src/target/trace.c
   trunk/src/target/xscale.h
   trunk/src/target/xscale/protocol.h
Log:
Remove whitespace at end of lines, step 1.
- Replace '\s*$' with ''.


Modified: trunk/src/flash/aduc702x.c
===================================================================
--- trunk/src/flash/aduc702x.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/aduc702x.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -109,10 +109,10 @@
 static int aduc702x_build_sector_list(struct flash_bank_s *bank)
 {
 	//aduc7026_flash_bank_t *aduc7026_info = bank-&gt;driver_priv;
-	
+
         int i = 0;
         uint32_t offset = 0;
-		
+
         // sector size is 512
         bank-&gt;num_sectors = bank-&gt;size / 512;
         bank-&gt;sectors = malloc(sizeof(flash_sector_t) * bank-&gt;num_sectors);
@@ -203,7 +203,7 @@
 	reg_param_t reg_params[6];
 	armv4_5_algorithm_t armv4_5_info;
 	int retval = ERROR_OK;
-	
+
         /* parameters:
 
         r0 - address of source data (absolute)
@@ -240,7 +240,7 @@
         //&lt;done&gt;:
                 0xeafffffe 	// b	1003c &lt;done&gt;
 	};
-	
+
 	/* flash write code */
 	if (target_alloc_working_area(target, sizeof(aduc702x_flash_write_code),
                 &amp;aduc702x_info-&gt;write_algorithm) != ERROR_OK)
@@ -248,8 +248,8 @@
 		LOG_WARNING(&quot;no working area available, can't do block memory writes&quot;);
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
-	
-	target_write_buffer(target, aduc702x_info-&gt;write_algorithm-&gt;address, 
+
+	target_write_buffer(target, aduc702x_info-&gt;write_algorithm-&gt;address,
                 sizeof(aduc702x_flash_write_code), (uint8_t*)aduc702x_flash_write_code);
 
 	/* memory buffer */
@@ -261,26 +261,26 @@
 			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
 			if (aduc702x_info-&gt;write_algorithm)
 				target_free_working_area(target, aduc702x_info-&gt;write_algorithm);
-			
+
 			LOG_WARNING(&quot;no large enough working area available, can't do block memory writes&quot;);
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
 	}
-	
+
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
 	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
-	
+
 	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT);
 	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);
 	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);
 	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_IN);
 	init_reg_param(&amp;reg_params[4], &quot;r4&quot;, 32, PARAM_OUT);
-	
+
 	while (count &gt; 0)
 	{
 		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
-		
+
 		target_write_buffer(target, source-&gt;address, thisrun_count * 2, buffer);
 
 		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
@@ -288,16 +288,16 @@
 		buf_set_u32(reg_params[2].value, 0, 32, address);
 		buf_set_u32(reg_params[4].value, 0, 32, 0xFFFFF800);
 
-		if ((retval = target_run_algorithm(target, 0, NULL, 5, 
-                        reg_params, aduc702x_info-&gt;write_algorithm-&gt;address, 
-                        aduc702x_info-&gt;write_algorithm-&gt;address + sizeof(aduc702x_flash_write_code) - 4, 
+		if ((retval = target_run_algorithm(target, 0, NULL, 5,
+                        reg_params, aduc702x_info-&gt;write_algorithm-&gt;address,
+                        aduc702x_info-&gt;write_algorithm-&gt;address + sizeof(aduc702x_flash_write_code) - 4,
                         10000, &amp;armv4_5_info)) != ERROR_OK)
 		{
 			LOG_ERROR(&quot;error executing aduc702x flash write algorithm&quot;);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
-	
+
 		if ((buf_get_u32(reg_params[3].value, 0, 32) &amp; 1) != 1) {
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
@@ -310,24 +310,24 @@
 
 	target_free_working_area(target, source);
 	target_free_working_area(target, aduc702x_info-&gt;write_algorithm);
-	
+
 	destroy_reg_param(&amp;reg_params[0]);
 	destroy_reg_param(&amp;reg_params[1]);
 	destroy_reg_param(&amp;reg_params[2]);
 	destroy_reg_param(&amp;reg_params[3]);
 	destroy_reg_param(&amp;reg_params[4]);
-	
+
 	return retval;
 }
 
-/* All-JTAG, single-access method.  Very slow.  Used only if there is no 
+/* All-JTAG, single-access method.  Very slow.  Used only if there is no
  * working area available. */
 static int aduc702x_write_single(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	uint32_t x;
         uint8_t b;
 	target_t *target = bank-&gt;target;
-	
+
         aduc702x_set_write_enable(target, 1);
 
 	for (x = 0; x &lt; count; x += 2) {
@@ -373,13 +373,13 @@
                 if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
                 {
                         /* if block write failed (no sufficient working area),
-                         * use normal (slow) JTAG method */ 
+                         * use normal (slow) JTAG method */
                         LOG_WARNING(&quot;couldn't use block writes, falling back to single memory accesses&quot;);
 
                         if ((retval = aduc702x_write_single(bank, buffer, offset, count)) != ERROR_OK)
                         {
                                 LOG_ERROR(&quot;slow write failed&quot;);
-                                return ERROR_FLASH_OPERATION_FAILED; 
+                                return ERROR_FLASH_OPERATION_FAILED;
                         }
                 }
                 else if (retval == ERROR_FLASH_OPERATION_FAILED)

Modified: trunk/src/flash/at91sam7.c
===================================================================
--- trunk/src/flash/at91sam7.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/at91sam7.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -57,7 +57,7 @@
 static uint32_t at91sam7_get_flash_status(target_t *target, int bank_number);
 static void at91sam7_set_flash_mode(flash_bank_t *bank, int mode);
 static uint32_t at91sam7_wait_status_busy(flash_bank_t *bank, uint32_t waitbits, int timeout);
-static int at91sam7_flash_command(struct flash_bank_s *bank, uint8_t cmd, uint16_t pagen); 
+static int at91sam7_flash_command(struct flash_bank_s *bank, uint8_t cmd, uint16_t pagen);
 static int at91sam7_handle_gpnvm_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 flash_driver_t at91sam7_flash =
@@ -85,8 +85,8 @@
 static long SRAMSIZ[16] = {
 	-1,
 	0x0400,		/*  1K */
-	0x0800,		/*  2K */ 
-	-1, 
+	0x0800,		/*  2K */
+	-1,
 	0x1c000,	/* 112K */
 	0x1000,		/*   4K */
 	0x14000,	/*  80K */
@@ -135,10 +135,10 @@
 	target_read_u32(target, PMC_MCKR, &amp;mckr);
 	/* Read Clock Generator PLL Register  */
 	target_read_u32(target, CKGR_PLLR, &amp;pllr);
-	
+
 	at91sam7_info-&gt;mck_valid = 0;
 	at91sam7_info-&gt;mck_freq = 0;
-	switch (mckr &amp; PMC_MCKR_CSS) 
+	switch (mckr &amp; PMC_MCKR_CSS)
 	{
 		case 0:			/* Slow Clock */
 			at91sam7_info-&gt;mck_valid = 1;
@@ -146,7 +146,7 @@
 			break;
 
 		case 1:			/* Main Clock */
-			if ((mcfr &amp; CKGR_MCFR_MAINRDY) &amp;&amp; 
+			if ((mcfr &amp; CKGR_MCFR_MAINRDY) &amp;&amp;
 				(at91sam7_info-&gt;ext_freq == 0))
 			{
 				at91sam7_info-&gt;mck_valid = 1;
@@ -163,8 +163,8 @@
 			break;
 
 		case 3:			/* PLL Clock */
-			if ((mcfr &amp; CKGR_MCFR_MAINRDY) &amp;&amp; 
-				(at91sam7_info-&gt;ext_freq == 0)) 
+			if ((mcfr &amp; CKGR_MCFR_MAINRDY) &amp;&amp;
+				(at91sam7_info-&gt;ext_freq == 0))
 			{
 				target_read_u32(target, CKGR_PLLR, &amp;pllr);
 				if (!(pllr &amp; CKGR_PLLR_DIV))
@@ -280,7 +280,7 @@
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
 
-	fcr = (0x5A &lt;&lt; 24) | ((pagen&amp;0x3FF) &lt;&lt; 8) | cmd; 
+	fcr = (0x5A &lt;&lt; 24) | ((pagen&amp;0x3FF) &lt;&lt; 8) | cmd;
 	target_write_u32(target, MC_FCR[bank-&gt;bank_number], fcr);
 	LOG_DEBUG(&quot;Flash command: 0x%&quot; PRIx32 &quot;, flash bank: %i, page number: %u&quot;, fcr, bank-&gt;bank_number + 1, pagen);
 
@@ -294,7 +294,7 @@
 		return ERROR_OK;
 	}
 
-	if (at91sam7_wait_status_busy(bank, MC_FSR_FRDY, 10)&amp;0x0C) 
+	if (at91sam7_wait_status_busy(bank, MC_FSR_FRDY, 10)&amp;0x0C)
 	{
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
@@ -635,7 +635,7 @@
 	}
 
 	/* Configure the flash controller timing */
-	at91sam7_read_clock_info(bank); 
+	at91sam7_read_clock_info(bank);
 	at91sam7_set_flash_mode(bank, FMR_TIMING_FLASH);
 
 	fast_check = 1;
@@ -892,7 +892,7 @@
 
 	if (erase_all)
 	{
-		if (at91sam7_flash_command(bank, EA, 0) != ERROR_OK) 
+		if (at91sam7_flash_command(bank, EA, 0) != ERROR_OK)
 		{
 			return ERROR_FLASH_OPERATION_FAILED;
 		}
@@ -1079,13 +1079,13 @@
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, 
+	printed = snprintf(buf,
 			   buf_size,
 			   &quot; Cidr: 0x%8.8&quot; PRIx32 &quot; | Arch: 0x%4.4x | Eproc: %s | Version: 0x%3.3x | Flashsize: 0x%8.8&quot; PRIx32 &quot;\n&quot;,
-			   at91sam7_info-&gt;cidr, 
-			   at91sam7_info-&gt;cidr_arch, 
+			   at91sam7_info-&gt;cidr,
+			   at91sam7_info-&gt;cidr_arch,
 			   EPROC[at91sam7_info-&gt;cidr_eproc],
-			   at91sam7_info-&gt;cidr_version, 
+			   at91sam7_info-&gt;cidr_version,
 			   bank-&gt;size);
 
 	buf += printed;
@@ -1117,10 +1117,10 @@
 	return ERROR_OK;
 }
 
-/* 
-* On AT91SAM7S: When the gpnvm bits are set with 
+/*
+* On AT91SAM7S: When the gpnvm bits are set with
 * &gt; at91sam7 gpnvm bitnr set
-* the changes are not visible in the flash controller status register MC_FSR 
+* the changes are not visible in the flash controller status register MC_FSR
 * until the processor has been reset.
 * On the Olimex board this requires a power cycle.
 * Note that the AT91SAM7S has the following errata (doc6175.pdf sec 14.1.3):
@@ -1191,7 +1191,7 @@
 	/* Configure the flash controller timing */
 	at91sam7_read_clock_info(bank);
 	at91sam7_set_flash_mode(bank, FMR_TIMING_NVBITS);
-	
+
 	if (at91sam7_flash_command(bank, flashcmd, bit) != ERROR_OK)
 	{
 		return ERROR_FLASH_OPERATION_FAILED;
@@ -1203,6 +1203,6 @@
 
 	/* check protect state */
 	at91sam7_protect_check(bank);
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/cfi.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -378,9 +378,9 @@
 	pri_ext-&gt;suspend_cmd_support = cfi_query_u8(bank, 0, cfi_info-&gt;pri_addr + 9);
 	pri_ext-&gt;blk_status_reg_mask = cfi_query_u16(bank, 0, cfi_info-&gt;pri_addr + 0xa);
 
-	LOG_DEBUG(&quot;feature_support: 0x%&quot; PRIx32 &quot;, suspend_cmd_support: 0x%x, blk_status_reg_mask: 0x%x&quot;, 
-		  pri_ext-&gt;feature_support, 
-		  pri_ext-&gt;suspend_cmd_support, 
+	LOG_DEBUG(&quot;feature_support: 0x%&quot; PRIx32 &quot;, suspend_cmd_support: 0x%x, blk_status_reg_mask: 0x%x&quot;,
+		  pri_ext-&gt;feature_support,
+		  pri_ext-&gt;suspend_cmd_support,
 		  pri_ext-&gt;blk_status_reg_mask);
 
 	pri_ext-&gt;vcc_optimal = cfi_query_u8(bank, 0, cfi_info-&gt;pri_addr + 0xc);
@@ -1597,7 +1597,7 @@
 	/* Check for valid range */
 	if (address &amp; buffermask)
 	{
-		LOG_ERROR(&quot;Write address at base 0x%&quot; PRIx32 &quot;, address %&quot; PRIx32 &quot; not aligned to 2^%d boundary&quot;, 
+		LOG_ERROR(&quot;Write address at base 0x%&quot; PRIx32 &quot;, address %&quot; PRIx32 &quot; not aligned to 2^%d boundary&quot;,
 			  bank-&gt;base, address, cfi_info-&gt;max_buf_write_size);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
@@ -2279,9 +2279,9 @@
 			for (i = 0; i &lt; cfi_info-&gt;num_erase_regions; i++)
 			{
 				cfi_info-&gt;erase_region_info[i] = cfi_query_u32(bank, 0, 0x2d + (4 * i));
-				LOG_DEBUG(&quot;erase region[%i]: %&quot; PRIu32 &quot; blocks of size 0x%&quot; PRIx32 &quot;&quot;, 
-					  i, 
-					  (cfi_info-&gt;erase_region_info[i] &amp; 0xffff) + 1, 
+				LOG_DEBUG(&quot;erase region[%i]: %&quot; PRIu32 &quot; blocks of size 0x%&quot; PRIx32 &quot;&quot;,
+					  i,
+					  (cfi_info-&gt;erase_region_info[i] &amp; 0xffff) + 1,
 					  (cfi_info-&gt;erase_region_info[i] &gt;&gt; 16) * 256);
 			}
 		}

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/flash.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -92,7 +92,7 @@
 	retval = bank-&gt;driver-&gt;write(bank, buffer, offset, count);
 	if (retval != ERROR_OK)
 	{
-		LOG_ERROR(&quot;error writing to flash at address 0x%08&quot; PRIx32 &quot; at offset 0x%8.8&quot; PRIx32 &quot; (%d)&quot;, 
+		LOG_ERROR(&quot;error writing to flash at address 0x%08&quot; PRIx32 &quot; at offset 0x%8.8&quot; PRIx32 &quot; (%d)&quot;,
 			  bank-&gt;base, offset, retval);
 	}
 
@@ -350,13 +350,13 @@
 			if ((retval = p-&gt;driver-&gt;auto_probe(p)) != ERROR_OK)
 				return retval;
 
-			command_print(cmd_ctx, 
+			command_print(cmd_ctx,
 				      &quot;#%&quot; PRIi32 &quot; : %s at 0x%8.8&quot; PRIx32 &quot;, size 0x%8.8&quot; PRIx32 &quot;, buswidth %i, chipwidth %i&quot;,
 				      i,
-				      p-&gt;driver-&gt;name, 
-				      p-&gt;base, 
-				      p-&gt;size, 
-				      p-&gt;bus_width, 
+				      p-&gt;driver-&gt;name,
+				      p-&gt;base,
+				      p-&gt;size,
+				      p-&gt;bus_width,
 				      p-&gt;chip_width);
 			for (j = 0; j &lt; p-&gt;num_sectors; j++)
 			{
@@ -369,11 +369,11 @@
 				else
 					protect_state = &quot;protection state unknown&quot;;
 
-				command_print(cmd_ctx, 
+				command_print(cmd_ctx,
 					      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
 					      j,
-					      p-&gt;sectors[j].offset, 
-					      p-&gt;sectors[j].size, 
+					      p-&gt;sectors[j].offset,
+					      p-&gt;sectors[j].size,
 					      p-&gt;sectors[j].size &gt;&gt; 10,
 					      protect_state);
 			}
@@ -462,9 +462,9 @@
 
 			command_print(cmd_ctx,
 				      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
-				      j, 
-				      p-&gt;sectors[j].offset, 
-				      p-&gt;sectors[j].size, 
+				      j,
+				      p-&gt;sectors[j].offset,
+				      p-&gt;sectors[j].size,
 				      p-&gt;sectors[j].size &gt;&gt; 10,
 				      erase_state);
 		}
@@ -708,10 +708,10 @@
 	}
 	if (retval == ERROR_OK)
 	{
-		command_print(cmd_ctx, 
+		command_print(cmd_ctx,
 					  &quot;wrote %&quot; PRIu32 &quot; byte from file %s in %s (%f kb/s)&quot;,
 					  written,
-					  args[0], 
+					  args[0],
 					  duration_text,
 					  (float)written / 1024.0 / ((float)duration.duration.tv_sec + ((float)duration.duration.tv_usec / 1000000.0)));
 	}
@@ -813,7 +813,7 @@
 		{
 			if (readback[i]!=chunk[i])
 			{
-				LOG_ERROR(&quot;Verfication error address 0x%08&quot; PRIx32 &quot;, read back 0x%02x, expected 0x%02x&quot;, 
+				LOG_ERROR(&quot;Verfication error address 0x%08&quot; PRIx32 &quot;, read back 0x%02x, expected 0x%02x&quot;,
 						  address + wrote + i, readback[i], chunk[i]);
 				return ERROR_FAIL;
 			}
@@ -831,10 +831,10 @@
 		float speed;
 		speed = wrote / 1024.0;
 		speed/=((float)duration.duration.tv_sec + ((float)duration.duration.tv_usec / 1000000.0));
-		command_print(cmd_ctx, 
+		command_print(cmd_ctx,
 					  &quot;wrote %&quot; PRId32 &quot; bytes to 0x%8.8&quot; PRIx32 &quot; in %s (%f kb/s)&quot;,
-					  count*wordsize, 
-					  address, 
+					  count*wordsize,
+					  address,
 					  duration_text,
 					  speed);
 	}
@@ -896,12 +896,12 @@
 	}
 	if (retval == ERROR_OK)
 	{
-	command_print(cmd_ctx, 
+	command_print(cmd_ctx,
 				  &quot;wrote  %lld byte from file %s to flash bank %li at offset 0x%8.8&quot; PRIx32 &quot; in %s (%f kb/s)&quot;,
-				  fileio.size, 
-				  args[1], 
-				  strtoul(args[0], NULL, 0), 
-				  offset, 
+				  fileio.size,
+				  args[1],
+				  strtoul(args[0], NULL, 0),
+				  offset,
 				  duration_text,
 				  (float)fileio.size / 1024.0 / ((float)duration.duration.tv_sec + ((float)duration.duration.tv_usec / 1000000.0)));
 	}

Modified: trunk/src/flash/flash.h
===================================================================
--- trunk/src/flash/flash.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/flash.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -81,13 +81,13 @@
  */
 typedef struct flash_driver_s
 {
-	/** 
+	/**
 	 * Gives a human-readable name of this flash driver,
 	 * This field is used to select and initialize the driver.
 	 */
 	char *name;
 
-	/** 
+	/**
 	 * Registers driver-specific commands.  When called (during the
 	 * &quot;flash bank&quot; command), the driver may register addition
 	 * commands to support new flash chip functions.
@@ -96,12 +96,12 @@
 	 */
 	int (*register_commands)(struct command_context_s *cmd_ctx);
 
-	/** 
+	/**
 	 * Finish the &quot;flash bank&quot; command for @a bank.  The
 	 * @a bank parameter will have been filled in by the core flash
 	 * layer when this routine is called, and the driver can store
 	 * additional information in its flash_bank_t::driver_priv field.
-	 * 
+	 *
 	 * @param cmd_ctx - the command context
 	 * @param cmd     - the command, in this case 'flash'
 	 * @param args    - parameters, see below
@@ -112,7 +112,7 @@
 	 * @code
 	 * args[0] = bank
 	 * args[1] = drivername {name above}
-	 * args[2] = baseaddress 
+	 * args[2] = baseaddress
 	 * args[3] = lengthbytes
 	 * args[4] = chip_width_in bytes
 	 * args[5] = bus_width_bytes
@@ -129,7 +129,7 @@
 	 */
 	int (*flash_bank_command)(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 
-	/** 
+	/**
 	 * Bank/sector erase routine (target-specific).  When
 	 * called, the flash driver should erase the specified sectors
 	 * using whatever means are at its disposal.
@@ -141,7 +141,7 @@
 	 */
 	int (*erase)(struct flash_bank_s *bank, int first, int last);
 
-	/** 
+	/**
 	 * Bank/sector protection routine (target-specific).
 	 * When called, the driver should disable 'flash write' bits (or
 	 * enable 'erase protection' bits) for the given @a bank and @a
@@ -155,7 +155,7 @@
 	 */
 	int (*protect)(struct flash_bank_s *bank, int set, int first, int last);
 
-	/** 
+	/**
 	 * Program data into the flash.  Note CPU address will be
 	 * &quot;bank-&gt;base + offset&quot;, while the physical address is
 	 * dependent upon current target MMU mappings.
@@ -168,7 +168,7 @@
 	 */
 	int (*write)(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 
-	/** 
+	/**
 	 * Probe to determine what kind of flash is present.
 	 * This is invoked by the &quot;probe&quot; script command.
 	 *
@@ -176,8 +176,8 @@
 	 * @returns ERROR_OK if successful; otherwise, an error code.
 	 */
 	int (*probe)(struct flash_bank_s *bank);
-	
-	/** 
+
+	/**
 	 * Check the erasure status of a flash bank.
 	 * When called, the driver routine must perform the required
 	 * checks and then set the @c flash_sector_s::is_erased field
@@ -209,7 +209,7 @@
 	 * @param char - where to put the text for the human to read
 	 * @param buf_size - the size of the human buffer.
 	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */ 
+	 */
 	int (*info)(struct flash_bank_s *bank, char *buf, int buf_size);
 
 	/**
@@ -228,7 +228,7 @@
 	int (*auto_probe)(struct flash_bank_s *bank);
 } flash_driver_t;
 
-/** 
+/**
  * Provides details of a flash bank, available either on-chip or through
  * a major interface.
  *
@@ -276,7 +276,7 @@
 extern int flash_erase_address_range(struct target_s *target, uint32_t addr, uint32_t length);
 /**
  * Writes @a image into the @a target flash.  The @a written parameter
- * will contain the 
+ * will contain the
  * @param target The target with the flash to be programmed.
  * @param image The image that will be programmed to flash.
  * @param written On return, contains the number of bytes written.

Modified: trunk/src/flash/mflash.c
===================================================================
--- trunk/src/flash/mflash.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/mflash.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -474,7 +474,7 @@
 	residue = sect_cnt % 256;
 
 	for (i = 0; i &lt; quotient; i++) {
-		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIu32 &quot; buff : 0x%0lx&quot;, sect_num, 
+		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIu32 &quot; buff : 0x%0lx&quot;, sect_num,
 			(unsigned long)buff_ptr);
 		ret = mg_mflash_do_read_sects(buff_ptr, sect_num, 256);
 		if (ret != ERROR_OK)
@@ -485,7 +485,7 @@
 	}
 
 	if (residue) {
-		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIx32 &quot; buff : %0lx&quot;, sect_num, 
+		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIx32 &quot; buff : %0lx&quot;, sect_num,
 			(unsigned long)buff_ptr);
 		return mg_mflash_do_read_sects(buff_ptr, sect_num, residue);
 	}
@@ -517,7 +517,7 @@
 		ret = target_write_memory(target, address, 2, MG_MFLASH_SECTOR_SIZE / 2, buff_ptr);
 		if (ret != ERROR_OK)
 			return ret;
-		
+
 		buff_ptr += MG_MFLASH_SECTOR_SIZE;
 
 		ret = target_write_u8(target, mflash_bank-&gt;base + MG_REG_OFFSET + MG_REG_COMMAND, mg_io_cmd_confirm_write);
@@ -552,7 +552,7 @@
 	residue = sect_cnt % 256;
 
 	for (i = 0; i &lt; quotient; i++) {
-		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIu32 &quot;buff : %p&quot;, sect_num, 
+		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIu32 &quot;buff : %p&quot;, sect_num,
 			buff_ptr);
 		ret = mg_mflash_do_write_sects(buff_ptr, sect_num, 256, mg_io_cmd_write);
 		if (ret != ERROR_OK)
@@ -563,7 +563,7 @@
 	}
 
 	if (residue) {
-		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIu32 &quot; buff : %p&quot;, sect_num, 
+		LOG_DEBUG(&quot;mflash: sect num : %&quot; PRIu32 &quot; buff : %p&quot;, sect_num,
 			buff_ptr);
 		return mg_mflash_do_write_sects(buff_ptr, sect_num, residue, mg_io_cmd_write);
 	}
@@ -741,10 +741,10 @@
 			goto mg_write_cmd_err;
 		address += MG_FILEIO_CHUNK;
 	}
- 
+
 	if (res) {
 		if ((ret = fileio_read(&amp;fileio, res, buffer, &amp;buf_cnt)) != ERROR_OK)
-			goto mg_write_cmd_err;			
+			goto mg_write_cmd_err;
 		if ((ret = mg_mflash_write(address, buffer, res)) != ERROR_OK)
 			goto mg_write_cmd_err;
 	}
@@ -789,7 +789,7 @@
 	ret = fileio_open(&amp;fileio, args[1], FILEIO_WRITE, FILEIO_BINARY);
 	if (ret != ERROR_OK)
 		return ret;
- 
+
 	buffer = malloc(MG_FILEIO_CHUNK);
 	if (!buffer) {
 		fileio_close(&amp;fileio);
@@ -798,7 +798,7 @@
 
 	cnt = size / MG_FILEIO_CHUNK;
 	res = size % MG_FILEIO_CHUNK;
- 
+
 	duration_start_measure(&amp;duration);
 
 	for (i = 0; i &lt; cnt; i++) {
@@ -809,7 +809,7 @@
 			goto mg_dump_cmd_err;
 		address += MG_FILEIO_CHUNK;
 	}
- 
+
 	if (res) {
 		if ((ret = mg_mflash_read(address, buffer, res)) != ERROR_OK)
 			goto mg_dump_cmd_err;
@@ -834,8 +834,8 @@
 	free(duration_text);
  	free(buffer);
 	fileio_close(&amp;fileio);
- 
-	return ret;	
+
+	return ret;
 }
 
 static int mg_set_feature(mg_feature_id feature, mg_feature_val config)
@@ -1229,7 +1229,7 @@
 
 	switch (argc) {
 		case 2:
-			if (!strcmp(args[1], &quot;boot&quot;)) 
+			if (!strcmp(args[1], &quot;boot&quot;))
 				return mg_boot_config();
 			else if (!strcmp(args[1], &quot;storage&quot;))
 				return mg_storage_config();
@@ -1252,7 +1252,7 @@
 					return ERROR_MG_INVALID_PLL;
 				}
 
-				LOG_INFO(&quot;mflash: Fout=%&quot; PRIu32 &quot; Hz, feedback=%u,&quot; 
+				LOG_INFO(&quot;mflash: Fout=%&quot; PRIu32 &quot; Hz, feedback=%u,&quot;
 						&quot;indiv=%u, outdiv=%u, lock=%u&quot;,
 						(uint32_t)fout, pll.feedback_div,
 						pll.input_div, pll.output_div,

Modified: trunk/src/flash/nand.c
===================================================================
--- trunk/src/flash/nand.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/nand.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -1138,12 +1138,12 @@
 				else
 					bad_state = &quot; (block condition unknown)&quot;;
 
-				command_print(cmd_ctx, 
+				command_print(cmd_ctx,
 					      &quot;\t#%i: 0x%8.8&quot; PRIx32 &quot; (%&quot; PRId32 &quot;kB) %s%s&quot;,
 					      j,
-					      p-&gt;blocks[j].offset, 
+					      p-&gt;blocks[j].offset,
 					      p-&gt;blocks[j].size / 1024,
-					      erase_state, 
+					      erase_state,
 					      bad_state);
 			}
 		}

Modified: trunk/src/flash/ocl/at91sam7x/samflash.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -174,7 +174,7 @@
 int flash_erase_all(void)
 {
 	int result;
-	
+
 	if ((result = flash_erase_plane(0)) != FLASH_STAT_OK) return result;
 
 	/* the second flash controller, if any */

Modified: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/pic32mx.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -603,10 +603,10 @@
 	pic32mx_info-&gt;probed = 0;
 
 	device_id = ejtag_info-&gt;idcode;
-	LOG_INFO(&quot;device id = 0x%08&quot; PRIx32 &quot; (manuf 0x%03x dev 0x%02x, ver 0x%03x)&quot;, 
+	LOG_INFO(&quot;device id = 0x%08&quot; PRIx32 &quot; (manuf 0x%03x dev 0x%02x, ver 0x%03x)&quot;,
 			  device_id,
-			  (unsigned)((device_id &gt;&gt; 1)&amp;0x7ff), 
-			  (unsigned)((device_id &gt;&gt; 12)&amp;0xff), 
+			  (unsigned)((device_id &gt;&gt; 1)&amp;0x7ff),
+			  (unsigned)((device_id &gt;&gt; 12)&amp;0xff),
 			  (unsigned)((device_id &gt;&gt; 20)&amp;0xfff));
 
 	if (((device_id &gt;&gt; 1)&amp;0x7ff) != PIC32MX_MANUF_ID) {
@@ -698,9 +698,9 @@
 	device_id = ejtag_info-&gt;idcode;
 
 	if (((device_id &gt;&gt; 1)&amp;0x7ff) != PIC32MX_MANUF_ID) {
-		snprintf(buf, buf_size, 
-				 &quot;Cannot identify target as a PIC32MX family (manufacturer 0x%03d != 0x%03d)\n&quot;, 
-				 (unsigned)((device_id &gt;&gt; 1)&amp;0x7ff), 
+		snprintf(buf, buf_size,
+				 &quot;Cannot identify target as a PIC32MX family (manufacturer 0x%03d != 0x%03d)\n&quot;,
+				 (unsigned)((device_id &gt;&gt; 1)&amp;0x7ff),
 				 PIC32MX_MANUF_ID);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
@@ -715,7 +715,7 @@
 	}
 	buf += printed;
 	buf_size -= printed;
-	printed = snprintf(buf, buf_size, &quot;  Ver: 0x%03x&quot;, 
+	printed = snprintf(buf, buf_size, &quot;  Ver: 0x%03x&quot;,
 					   (unsigned)((device_id &gt;&gt; 20)&amp;0xfff));
 
 	return ERROR_OK;

Modified: trunk/src/flash/stellaris.c
===================================================================
--- trunk/src/flash/stellaris.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/stellaris.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -292,32 +292,32 @@
 	{
 		device_class = 0;
 	}
-	printed = snprintf(buf, 
+	printed = snprintf(buf,
 			   buf_size,
 			   &quot;\nLMI Stellaris information: Chip is class %i(%s) %s v%c.%i\n&quot;,
-			   device_class, 
-			   StellarisClassname[device_class], 
+			   device_class,
+			   StellarisClassname[device_class],
 			   stellaris_info-&gt;target_name,
 			   (int)('A' + ((stellaris_info-&gt;did0 &gt;&gt; 8) &amp; 0xFF)),
 			   (int)((stellaris_info-&gt;did0) &amp; 0xFF));
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, 
-			   buf_size, 
+	printed = snprintf(buf,
+			   buf_size,
 			   &quot;did1: 0x%8.8&quot; PRIx32 &quot;, arch: 0x%4.4&quot; PRIx32 &quot;, eproc: %s, ramsize:%ik, flashsize: %ik\n&quot;,
-			   stellaris_info-&gt;did1, 
-			   stellaris_info-&gt;did1, 
-			   &quot;ARMV7M&quot;, 
+			   stellaris_info-&gt;did1,
+			   stellaris_info-&gt;did1,
+			   &quot;ARMV7M&quot;,
 			   (int)((1 + ((stellaris_info-&gt;dc0 &gt;&gt; 16) &amp; 0xFFFF))/4),
 			   (int)((1 + (stellaris_info-&gt;dc0 &amp; 0xFFFF))*2));
 	buf += printed;
 	buf_size -= printed;
 
-	printed = snprintf(buf, 
+	printed = snprintf(buf,
 			   buf_size,
 			   &quot;master clock(estimated): %ikHz, rcc is 0x%&quot; PRIx32 &quot; \n&quot;,
-			   (int)(stellaris_info-&gt;mck_freq / 1000), 
+			   (int)(stellaris_info-&gt;mck_freq / 1000),
 			   stellaris_info-&gt;rcc);
 	buf += printed;
 	buf_size -= printed;
@@ -326,9 +326,9 @@
 	{
 		printed = snprintf(buf,
 				   buf_size,
-				   &quot;pagesize: %&quot; PRIi32 &quot;, lockbits: %i 0x%4.4&quot; PRIx32 &quot;, pages in lock region: %i \n&quot;, 
-				   stellaris_info-&gt;pagesize, 
-				   stellaris_info-&gt;num_lockbits, 
+				   &quot;pagesize: %&quot; PRIi32 &quot;, lockbits: %i 0x%4.4&quot; PRIx32 &quot;, pages in lock region: %i \n&quot;,
+				   stellaris_info-&gt;pagesize,
+				   stellaris_info-&gt;num_lockbits,
 				   stellaris_info-&gt;lockbits,
 				   (int)(stellaris_info-&gt;num_pages/stellaris_info-&gt;num_lockbits));
 		buf += printed;

Modified: trunk/src/flash/str7x.c
===================================================================
--- trunk/src/flash/str7x.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/str7x.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -75,10 +75,10 @@
 static int str7x_register_commands(struct command_context_s *cmd_ctx)
 {
 	command_t *str7x_cmd = register_command(cmd_ctx, NULL, &quot;str7x&quot;, NULL, COMMAND_ANY, NULL);
-	
+
 	register_command(cmd_ctx, str7x_cmd, &quot;disable_jtag&quot;, str7x_handle_disable_jtag_command, COMMAND_EXEC,
 					 &quot;disable jtag access&quot;);
-					 
+
 	return ERROR_OK;
 }
 
@@ -95,7 +95,7 @@
 	int i;
 	int num_sectors;
 	int b0_sectors = 0, b1_sectors = 0;
-		
+
 	switch (bank-&gt;size)
 	{
 		case 16 * 1024:
@@ -114,15 +114,15 @@
 			LOG_ERROR(&quot;BUG: unknown bank-&gt;size encountered&quot;);
 			exit(-1);
 	}
-		
+
 	num_sectors = b0_sectors + b1_sectors;
-	
+
 	bank-&gt;num_sectors = num_sectors;
 	bank-&gt;sectors = malloc(sizeof(flash_sector_t) * num_sectors);
 	str7x_info-&gt;sector_bits = malloc(sizeof(uint32_t) * num_sectors);
-	
+
 	num_sectors = 0;
-	
+
 	for (i = 0; i &lt; b0_sectors; i++)
 	{
 		bank-&gt;sectors[num_sectors].offset = mem_layout_str7bank0[i].sector_start;
@@ -131,7 +131,7 @@
 		bank-&gt;sectors[num_sectors].is_protected = 1;
 		str7x_info-&gt;sector_bits[num_sectors++] = mem_layout_str7bank0[i].sector_bit;
 	}
-	
+
 	for (i = 0; i &lt; b1_sectors; i++)
 	{
 		bank-&gt;sectors[num_sectors].offset = mem_layout_str7bank1[i].sector_start;
@@ -140,7 +140,7 @@
 		bank-&gt;sectors[num_sectors].is_protected = 1;
 		str7x_info-&gt;sector_bits[num_sectors++] = mem_layout_str7bank1[i].sector_bit;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -149,20 +149,20 @@
 static int str7x_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank)
 {
 	str7x_flash_bank_t *str7x_info;
-	
+
 	if (argc &lt; 7)
 	{
 		LOG_WARNING(&quot;incomplete flash_bank str7x configuration&quot;);
 		return ERROR_FLASH_BANK_INVALID;
 	}
-	
+
 	str7x_info = malloc(sizeof(str7x_flash_bank_t));
 	bank-&gt;driver_priv = str7x_info;
-	
+
 	/* set default bits for str71x flash */
 	str7x_info-&gt;busy_bits = (FLASH_LOCK | FLASH_BSYA1 | FLASH_BSYA0);
 	str7x_info-&gt;disable_bit = (1 &lt;&lt; 1);
-	
+
 	if (strcmp(args[6], &quot;STR71x&quot;) == 0)
 	{
 		str7x_info-&gt;register_base = 0x40100000;
@@ -185,9 +185,9 @@
 	}
 
 	str7x_build_block_list(bank);
-	
+
 	str7x_info-&gt;write_algorithm = NULL;
-	
+
 	return ERROR_OK;
 }
 
@@ -207,7 +207,7 @@
 	uint32_t retval;
 
 	target_read_u32(target, str7x_get_flash_adr(bank, FLASH_ER), &amp;retval);
-	
+
 	return retval;
 }
 
@@ -215,7 +215,7 @@
 {
 	str7x_flash_bank_t *str7x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	
+
 	int i;
 	uint32_t retval;
 
@@ -242,12 +242,12 @@
 {
 	str7x_flash_bank_t *str7x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	
+
 	int i;
 	uint32_t cmd;
 	uint32_t retval;
 	uint32_t sectors = 0;
-	
+
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;Target not halted&quot;);
@@ -258,33 +258,33 @@
 	{
 		sectors |= str7x_info-&gt;sector_bits[i];
 	}
-	
+
 	LOG_DEBUG(&quot;sectors: 0x%&quot; PRIx32 &quot;&quot;, sectors);
-	
-	/* clear FLASH_ER register */	
+
+	/* clear FLASH_ER register */
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_ER), 0x0);
-	
+
 	cmd = FLASH_SER;
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-	
+
 	cmd = sectors;
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR1), cmd);
-	
+
 	cmd = FLASH_SER | FLASH_WMS;
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-	
+
 	while (((retval = str7x_status(bank)) &amp; str7x_info-&gt;busy_bits)) {
 		alive_sleep(1);
 	}
-	
+
 	retval = str7x_result(bank);
-	
+
 	if (retval)
 	{
 		LOG_ERROR(&quot;error erasing flash bank, FLASH_ER: 0x%&quot; PRIx32 &quot;&quot;, retval);
 		return ERROR_FLASH_OPERATION_FAILED;
 	}
-	
+
 	for (i = first; i &lt;= last; i++)
 		bank-&gt;sectors[i].is_erased = 1;
 
@@ -299,13 +299,13 @@
 	uint32_t cmd;
 	uint32_t retval;
 	uint32_t protect_blocks;
-	
+
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;Target not halted&quot;);
 		return ERROR_TARGET_NOT_HALTED;
 	}
-	
+
 	protect_blocks = 0xFFFFFFFF;
 
 	if (set)
@@ -313,30 +313,30 @@
 		for (i = first; i &lt;= last; i++)
 			protect_blocks &amp;= ~(str7x_info-&gt;sector_bits[i]);
 	}
-	
-	/* clear FLASH_ER register */	
+
+	/* clear FLASH_ER register */
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_ER), 0x0);
 
 	cmd = FLASH_SPR;
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-	
+
 	cmd = str7x_get_flash_adr(bank, FLASH_NVWPAR);
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), cmd);
-	
+
 	cmd = protect_blocks;
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_DR0), cmd);
-	
+
 	cmd = FLASH_SPR | FLASH_WMS;
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-	
+
 	while (((retval = str7x_status(bank)) &amp; str7x_info-&gt;busy_bits)) {
 		alive_sleep(1);
 	}
-	
+
 	retval = str7x_result(bank);
-	
+
 	LOG_DEBUG(&quot;retval: 0x%8.8&quot; PRIx32 &quot;&quot;, retval);
-	
+
 	if (retval &amp; FLASH_ERER)
 		return ERROR_FLASH_SECTOR_NOT_ERASED;
 	else if (retval &amp; FLASH_WPF)
@@ -355,7 +355,7 @@
 	reg_param_t reg_params[6];
 	armv4_5_algorithm_t armv4_5_info;
 	int retval = ERROR_OK;
-	
+
 	uint32_t str7x_flash_write_code[] = {
 					/* write:				*/
 		0xe3a04201, /*	mov r4, #0x10000000	*/
@@ -381,14 +381,14 @@
 					/* exit:				*/
 		0xeafffffe, /*	b exit				*/
 	};
-	
+
 	/* flash write code */
 	if (target_alloc_working_area(target, 4 * 20, &amp;str7x_info-&gt;write_algorithm) != ERROR_OK)
 	{
 		LOG_WARNING(&quot;no working area available, can't do block memory writes&quot;);
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
-	
+
 	target_write_buffer(target, str7x_info-&gt;write_algorithm-&gt;address, 20 * 4, (uint8_t*)str7x_flash_write_code);
 
 	/* memory buffer */
@@ -400,63 +400,63 @@
 			/* if we already allocated the writing code, but failed to get a buffer, free the algorithm */
 			if (str7x_info-&gt;write_algorithm)
 				target_free_working_area(target, str7x_info-&gt;write_algorithm);
-			
+
 			LOG_WARNING(&quot;no large enough working area available, can't do block memory writes&quot;);
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
 	}
-	
+
 	armv4_5_info.common_magic = ARMV4_5_COMMON_MAGIC;
 	armv4_5_info.core_mode = ARMV4_5_MODE_SVC;
 	armv4_5_info.core_state = ARMV4_5_STATE_ARM;
-	
+
 	init_reg_param(&amp;reg_params[0], &quot;r0&quot;, 32, PARAM_OUT);
 	init_reg_param(&amp;reg_params[1], &quot;r1&quot;, 32, PARAM_OUT);
 	init_reg_param(&amp;reg_params[2], &quot;r2&quot;, 32, PARAM_OUT);
 	init_reg_param(&amp;reg_params[3], &quot;r3&quot;, 32, PARAM_OUT);
 	init_reg_param(&amp;reg_params[4], &quot;r4&quot;, 32, PARAM_IN);
 	init_reg_param(&amp;reg_params[5], &quot;r5&quot;, 32, PARAM_OUT);
-	
+
 	while (count &gt; 0)
 	{
 		uint32_t thisrun_count = (count &gt; (buffer_size / 8)) ? (buffer_size / 8) : count;
-		
+
 		target_write_buffer(target, source-&gt;address, thisrun_count * 8, buffer);
-		
+
 		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);
 		buf_set_u32(reg_params[1].value, 0, 32, address);
 		buf_set_u32(reg_params[2].value, 0, 32, str7x_get_flash_adr(bank, FLASH_CR0));
 		buf_set_u32(reg_params[3].value, 0, 32, thisrun_count);
 		buf_set_u32(reg_params[5].value, 0, 32, str7x_info-&gt;busy_bits);
-	
+
 		if ((retval = target_run_algorithm(target, 0, NULL, 6, reg_params, str7x_info-&gt;write_algorithm-&gt;address, str7x_info-&gt;write_algorithm-&gt;address + (19 * 4), 10000, &amp;armv4_5_info)) != ERROR_OK)
 		{
 			LOG_ERROR(&quot;error executing str7x flash write algorithm&quot;);
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
-	
+
 		if (buf_get_u32(reg_params[4].value, 0, 32) != 0x00)
 		{
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
-		
+
 		buffer += thisrun_count * 8;
 		address += thisrun_count * 8;
 		count -= thisrun_count;
 	}
-	
+
 	target_free_working_area(target, source);
 	target_free_working_area(target, str7x_info-&gt;write_algorithm);
-	
+
 	destroy_reg_param(&amp;reg_params[0]);
 	destroy_reg_param(&amp;reg_params[1]);
 	destroy_reg_param(&amp;reg_params[2]);
 	destroy_reg_param(&amp;reg_params[3]);
 	destroy_reg_param(&amp;reg_params[4]);
 	destroy_reg_param(&amp;reg_params[5]);
-	
+
 	return retval;
 }
 
@@ -472,7 +472,7 @@
 	int retval;
 	uint32_t check_address = offset;
 	int i;
-	
+
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;Target not halted&quot;);
@@ -484,12 +484,12 @@
 		LOG_WARNING(&quot;offset 0x%&quot; PRIx32 &quot; breaks required 8-byte alignment&quot;, offset);
 		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
 	}
-	
+
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
 	{
 		uint32_t sec_start = bank-&gt;sectors[i].offset;
 		uint32_t sec_end = sec_start + bank-&gt;sectors[i].size;
-		
+
 		/* check if destination falls within the current sector */
 		if ((check_address &gt;= sec_start) &amp;&amp; (check_address &lt; sec_end))
 		{
@@ -500,15 +500,15 @@
 				check_address = sec_end;
 		}
 	}
-	
+
 	if (check_address != offset + count)
 		return ERROR_FLASH_DST_OUT_OF_BANK;
-		
-	/* clear FLASH_ER register */	
+
+	/* clear FLASH_ER register */
 	target_write_u32(target, str7x_get_flash_adr(bank, FLASH_ER), 0x0);
 
 	/* multiple dwords (8-byte) to be programmed? */
-	if (dwords_remaining &gt; 0) 
+	if (dwords_remaining &gt; 0)
 	{
 		/* try using a block write */
 		if ((retval = str7x_write_block(bank, buffer, offset, dwords_remaining)) != ERROR_OK)
@@ -516,14 +516,14 @@
 			if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
 			{
 				/* if block write failed (no sufficient working area),
-				 * we use normal (slow) single dword accesses */ 
+				 * we use normal (slow) single dword accesses */
 				LOG_WARNING(&quot;couldn't use block writes, falling back to single memory accesses&quot;);
 			}
 			else if (retval == ERROR_FLASH_OPERATION_FAILED)
 			{
 				/* if an error occured, we examine the reason, and quit */
 				retval = str7x_result(bank);
-				
+
 				LOG_ERROR(&quot;flash writing failed with error code: 0x%x&quot;, retval);
 				return ERROR_FLASH_OPERATION_FAILED;
 			}
@@ -541,29 +541,29 @@
 		/* command */
 		cmd = FLASH_DWPG;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-		
+
 		/* address */
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), address);
-		
+
 		/* data word 1 */
 		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR0), 4, 1, buffer + bytes_written);
 		bytes_written += 4;
-		
+
 		/* data word 2 */
 		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR1), 4, 1, buffer + bytes_written);
 		bytes_written += 4;
-		
+
 		/* start programming cycle */
 		cmd = FLASH_DWPG | FLASH_WMS;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-		
+
 		while (((retval = str7x_status(bank)) &amp; str7x_info-&gt;busy_bits))
 		{
 			alive_sleep(1);
 		}
-		
+
 		retval = str7x_result(bank);
-		
+
 		if (retval &amp; FLASH_PGER)
 			return ERROR_FLASH_OPERATION_FAILED;
 		else if (retval &amp; FLASH_WPF)
@@ -572,51 +572,51 @@
 		dwords_remaining--;
 		address += 8;
 	}
-	
+
 	if (bytes_remaining)
 	{
 		uint8_t last_dword[8] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
 		int i = 0;
-				
+
 		while (bytes_remaining &gt; 0)
 		{
-			last_dword[i++] = *(buffer + bytes_written); 
+			last_dword[i++] = *(buffer + bytes_written);
 			bytes_remaining--;
 			bytes_written++;
 		}
-		
+
 		/* command */
 		cmd = FLASH_DWPG;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-		
+
 		/* address */
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), address);
-		
+
 		/* data word 1 */
 		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR0), 4, 1, last_dword);
 		bytes_written += 4;
-		
+
 		/* data word 2 */
 		target_write_memory(target, str7x_get_flash_adr(bank, FLASH_DR1), 4, 1, last_dword + 4);
 		bytes_written += 4;
-		
+
 		/* start programming cycle */
 		cmd = FLASH_DWPG | FLASH_WMS;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), cmd);
-		
+
 		while (((retval = str7x_status(bank)) &amp; str7x_info-&gt;busy_bits))
 		{
 			alive_sleep(1);
 		}
-		
+
 		retval = str7x_result(bank);
-		
+
 		if (retval &amp; FLASH_PGER)
 			return ERROR_FLASH_OPERATION_FAILED;
 		else if (retval &amp; FLASH_WPF)
 			return ERROR_FLASH_OPERATION_FAILED;
 	}
-		
+
 	return ERROR_OK;
 }
 
@@ -643,35 +643,35 @@
 	flash_bank_t *bank;
 	target_t *target = NULL;
 	str7x_flash_bank_t *str7x_info = NULL;
-	
+
 	uint32_t flash_cmd;
 	uint32_t retval;
 	uint16_t ProtectionLevel = 0;
 	uint16_t ProtectionRegs;
-	
+
 	if (argc &lt; 1)
 	{
 		command_print(cmd_ctx, &quot;str7x disable_jtag &lt;bank&gt;&quot;);
-		return ERROR_OK;	
+		return ERROR_OK;
 	}
-	
+
 	bank = get_flash_bank_by_num(strtoul(args[0], NULL, 0));
 	if (!bank)
 	{
 		command_print(cmd_ctx, &quot;str7x disable_jtag &lt;bank&gt; ok&quot;);
 		return ERROR_OK;
 	}
-	
+
 	str7x_info = bank-&gt;driver_priv;
-	
+
 	target = bank-&gt;target;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_ERROR(&quot;Target not halted&quot;);
 		return ERROR_TARGET_NOT_HALTED;
 	}
-	
+
 	/* first we get protection status */
 	target_read_u32(target, str7x_get_flash_adr(bank, FLASH_NVAPR0), &amp;retval);
 
@@ -679,7 +679,7 @@
 	{
 		ProtectionLevel = 1;
 	}
-	
+
 	target_read_u32(target, str7x_get_flash_adr(bank, FLASH_NVAPR1), &amp;retval);
 	ProtectionRegs = ~(retval &gt;&gt; 16);
 
@@ -688,7 +688,7 @@
 		ProtectionRegs &gt;&gt;= 1;
 		ProtectionLevel++;
 	}
-	
+
 	if (ProtectionLevel == 0)
 	{
 		flash_cmd = FLASH_SPR;
@@ -707,6 +707,6 @@
 		flash_cmd = FLASH_SPR | FLASH_WMS;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), flash_cmd);
 	}
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/flash/tms470.c
===================================================================
--- trunk/src/flash/tms470.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/flash/tms470.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -49,7 +49,7 @@
 	.info = tms470_info
 };
 
-/* ---------------------------------------------------------------------- 
+/* ----------------------------------------------------------------------
                       Internal Support, Helpers
    ---------------------------------------------------------------------- */
 
@@ -288,10 +288,10 @@
 	bank-&gt;chip_width = 32;
 	bank-&gt;bus_width = 32;
 
-	LOG_INFO(&quot;Identified %s, ver=%d, core=%s, nvmem=%s.&quot;, 
+	LOG_INFO(&quot;Identified %s, ver=%d, core=%s, nvmem=%s.&quot;,
 		 part_name,
 		 (int)(silicon_version),
-		 (technology_family ? &quot;1.8v&quot; : &quot;3.3v&quot;), 
+		 (technology_family ? &quot;1.8v&quot; : &quot;3.3v&quot;),
 		 (rom_flash ? &quot;rom&quot; : &quot;flash&quot;));
 
 	tms470_info-&gt;device_ident_reg = device_ident_reg;
@@ -347,7 +347,7 @@
 
 	if (keysSet)
 	{
-		command_print(cmd_ctx, &quot;using flash keys 0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;&quot;, 
+		command_print(cmd_ctx, &quot;using flash keys 0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;&quot;,
 			      flashKeys[0], flashKeys[1], flashKeys[2], flashKeys[3]);
 	}
 	else
@@ -488,7 +488,7 @@
 
 		if (ERROR_OK == tms470_check_flash_unlocked(target))
 		{
-			/* 
+			/*
 			 * There seems to be a side-effect of reading the FMPKEY
 			 * register in that it re-enables the protection.  So we
 			 * re-enable it.
@@ -754,7 +754,7 @@
 	uint32_t flashAddr = bank-&gt;base + bank-&gt;sectors[sector].offset;
 	int result = ERROR_OK;
 
-	/* 
+	/*
 	 * Set the bit GLBCTRL4 of the GLBCTRL register (in the System
 	 * module) to enable writing to the flash registers }.
 	 */
@@ -787,8 +787,8 @@
 	}
 	bank-&gt;sectors[sector].is_protected = 0;
 
-	/* 
-	 * clear status regiser, sent erase command, kickoff erase 
+	/*
+	 * clear status regiser, sent erase command, kickoff erase
 	 */
 	target_write_u16(target, flashAddr, 0x0040);
 	LOG_DEBUG(&quot;write *(uint16_t *)0x%08&quot; PRIx32 &quot;=0x0040&quot;, flashAddr);
@@ -838,7 +838,7 @@
 	return result;
 }
 
-/* ---------------------------------------------------------------------- 
+/* ----------------------------------------------------------------------
               Implementation of Flash Driver Interfaces
    ---------------------------------------------------------------------- */
 
@@ -1115,7 +1115,7 @@
 	target_read_u32(target, 0xFFE88004, &amp;fmbac2);
 	target_write_u32(target, 0xFFE88004, fmbac2 | 0xff);
 
-	/* 
+	/*
 	 * The TI primitives inspect the flash memory by reading one 32-bit
 	 * word at a time.  Here we read an entire sector and inspect it in
 	 * an attempt to reduce the JTAG overhead.

Modified: trunk/src/target/algorithm.h
===================================================================
--- trunk/src/target/algorithm.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/algorithm.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -35,7 +35,7 @@
 	uint32_t size;
 	uint8_t *value;
 	enum param_direction direction;
-} mem_param_t; 
+} mem_param_t;
 
 typedef struct reg_param_s
 {

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm11.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -1888,7 +1888,7 @@
 		if (values[i] &gt; arm11_coproc_instruction_limits[i])
 		{
 			LOG_ERROR(&quot;Parameter %ld out of bounds (%&quot; PRId32 &quot; max). %s&quot;,
-				  (long)(i + 2), 
+				  (long)(i + 2),
 				  arm11_coproc_instruction_limits[i],
 				read ? arm11_mrc_syntax : arm11_mcr_syntax);
 			return -1;
@@ -1913,10 +1913,10 @@
 		arm11_run_instr_data_from_core_via_r0(arm11, instr, &amp;result);
 
 		LOG_INFO(&quot;MRC p%d, %d, R0, c%d, c%d, %d = 0x%08&quot; PRIx32 &quot; (%&quot; PRId32 &quot;)&quot;,
-			 (int)(values[0]), 
-			 (int)(values[1]), 
-			 (int)(values[2]), 
-			 (int)(values[3]), 
+			 (int)(values[0]),
+			 (int)(values[1]),
+			 (int)(values[2]),
+			 (int)(values[3]),
 			 (int)(values[4]), result, result);
 	}
 	else

Modified: trunk/src/target/arm926ejs.h
===================================================================
--- trunk/src/target/arm926ejs.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm926ejs.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -39,9 +39,9 @@
 } arm926ejs_common_t;
 
 extern int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap);
-extern int arm926ejs_register_commands(struct command_context_s *cmd_ctx); 
-extern int arm926ejs_arch_state(struct target_s *target); 
-extern int arm926ejs_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer); 
+extern int arm926ejs_register_commands(struct command_context_s *cmd_ctx);
+extern int arm926ejs_arch_state(struct target_s *target);
+extern int arm926ejs_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 extern int arm926ejs_soft_reset_halt(struct target_s *target);
 
 #endif /* ARM926EJS_H */

Modified: trunk/src/target/arm9tdmi.h
===================================================================
--- trunk/src/target/arm9tdmi.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm9tdmi.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -59,7 +59,7 @@
 
 extern int arm9tdmi_clock_out(arm_jtag_t *jtag_info, uint32_t instr, uint32_t out, uint32_t *in, int sysspeed);
 extern int arm9tdmi_clock_data_in(arm_jtag_t *jtag_info, uint32_t *in);
-extern int arm9tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info, void *in, int size, int be); 
+extern int arm9tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info, void *in, int size, int be);
 extern void arm9tdmi_read_core_regs(target_t *target, uint32_t mask, uint32_t* core_regs[16]);
 extern void arm9tdmi_write_core_regs(target_t *target, uint32_t mask, uint32_t core_regs[16]);
 

Modified: trunk/src/target/arm_adi_v5.h
===================================================================
--- trunk/src/target/arm_adi_v5.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm_adi_v5.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -104,7 +104,7 @@
 
 } swjdp_common_t;
 
-/* Accessor function for currently selected DAP-AP number */ 
+/* Accessor function for currently selected DAP-AP number */
 static inline uint8_t dap_ap_get_select(swjdp_common_t *swjdp)
 {
 	return (uint8_t)(swjdp -&gt;apsel &gt;&gt; 24);

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm_disassembler.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -33,9 +33,9 @@
 };
 
 /* make up for C's missing ROR */
-uint32_t ror(uint32_t value, int places) 
-{ 
-	return (value &gt;&gt; places) | (value &lt;&lt; (32 - places)); 
+uint32_t ror(uint32_t value, int places)
+{
+	return (value &gt;&gt; places) | (value &lt;&lt; (32 - places));
 }
 
 int evaluate_pld(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
@@ -44,9 +44,9 @@
 	if ((opcode &amp; 0x0d70f0000) == 0x0550f000)
 	{
 		instruction-&gt;type = ARM_PLD;
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tPLD ...TODO...&quot;, address, opcode);
-		
+
 		return ERROR_OK;
 	}
 	else
@@ -54,7 +54,7 @@
 		instruction-&gt;type = ARM_UNDEFINED_INSTRUCTION;
 		return ERROR_OK;
 	}
-	
+
 	LOG_ERROR(&quot;should never reach this point&quot;);
 	return -1;
 }
@@ -62,9 +62,9 @@
 int evaluate_swi(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	instruction-&gt;type = ARM_SWI;
-	
+
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tSWI 0x%6.6&quot; PRIx32 &quot;&quot;, address, opcode, (opcode &amp; 0xffffff));
-	
+
 	return ERROR_OK;
 }
 
@@ -73,30 +73,30 @@
 	int offset;
 	uint32_t immediate;
 	uint32_t target_address;
-	
+
 	instruction-&gt;type = ARM_BLX;
 	immediate = opcode &amp; 0x00ffffff;
-	
+
 	/* sign extend 24-bit immediate */
 	if (immediate &amp; 0x00800000)
 		offset = 0xff000000 | immediate;
 	else
 		offset = immediate;
-	
+
 	/* shift two bits left */
 	offset &lt;&lt;= 2;
-	
+
 	/* odd/event halfword */
 	if (opcode &amp; 0x01000000)
 		offset |= 0x2;
-	
+
 	target_address = address + 8 + offset;
-	
+
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tBLX 0x%8.8&quot; PRIx32 &quot;&quot;, address, opcode, target_address);
-	
+
 	instruction-&gt;info.b_bl_bx_blx.reg_operand = -1;
 	instruction-&gt;info.b_bl_bx_blx.target_address = target_address;
-	
+
 	return ERROR_OK;
 }
 
@@ -106,32 +106,32 @@
 	uint32_t immediate;
 	int offset;
 	uint32_t target_address;
-	
+
 	immediate = opcode &amp; 0x00ffffff;
 	L = (opcode &amp; 0x01000000) &gt;&gt; 24;
-	
+
 	/* sign extend 24-bit immediate */
 	if (immediate &amp; 0x00800000)
 		offset = 0xff000000 | immediate;
 	else
 		offset = immediate;
-	
+
 	/* shift two bits left */
 	offset &lt;&lt;= 2;
-	
+
 	target_address = address + 8 + offset;
 
 	if (L)
 		instruction-&gt;type = ARM_BL;
 	else
 		instruction-&gt;type = ARM_B;
-	
+
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tB%s%s 0x%8.8&quot; PRIx32 , address, opcode,
 			 (L) ? &quot;L&quot; : &quot;&quot;, COND(opcode), target_address);
-	
+
 	instruction-&gt;info.b_bl_bx_blx.reg_operand = -1;
 	instruction-&gt;info.b_bl_bx_blx.target_address = target_address;
-	
+
 	return ERROR_OK;
 }
 
@@ -140,32 +140,32 @@
 int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t cp_num = (opcode &amp; 0xf00) &gt;&gt; 8;
-	
+
 	/* MCRR or MRRC */
 	if (((opcode &amp; 0x0ff00000) == 0x0c400000) || ((opcode &amp; 0x0ff00000) == 0x0c400000))
 	{
 		uint8_t cp_opcode, Rd, Rn, CRm;
 		char *mnemonic;
-		
+
 		cp_opcode = (opcode &amp; 0xf0) &gt;&gt; 4;
 		Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
 		Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
 		CRm = (opcode &amp; 0xf);
-		
+
 		/* MCRR */
 		if ((opcode &amp; 0x0ff00000) == 0x0c400000)
 		{
 			instruction-&gt;type = ARM_MCRR;
 			mnemonic = &quot;MCRR&quot;;
 		}
-		
+
 		/* MRRC */
 		if ((opcode &amp; 0x0ff00000) == 0x0c500000)
 		{
 			instruction-&gt;type = ARM_MRRC;
 			mnemonic = &quot;MRRC&quot;;
 		}
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s p%i, %x, r%i, r%i, c%i&quot;,
 				 address, opcode, mnemonic, COND(opcode), cp_num, cp_opcode, Rd, Rn, CRm);
 	}
@@ -175,11 +175,11 @@
 		uint8_t U, N;
 		char *mnemonic;
 		char addressing_mode[32];
-		
+
 		CRd = (opcode &amp; 0xf000) &gt;&gt; 12;
 		Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
 		offset = (opcode &amp; 0xff);
-		
+
 		/* load/store */
 		if (opcode &amp; 0x00100000)
 		{
@@ -191,10 +191,10 @@
 			instruction-&gt;type = ARM_STC;
 			mnemonic = &quot;STC&quot;;
 		}
-		
+
 		U = (opcode &amp; 0x00800000) &gt;&gt; 23;
 		N = (opcode &amp; 0x00400000) &gt;&gt; 22;
-		
+
 		/* addressing modes */
 		if ((opcode &amp; 0x01200000) == 0x01000000) /* immediate offset */
 			snprintf(addressing_mode, 32, &quot;[r%i, #%s0x%2.2x*4]&quot;, Rn, (U) ? &quot;&quot; : &quot;-&quot;, offset);
@@ -210,7 +210,7 @@
 				 (N) ? &quot;L&quot; : &quot;&quot;,
 				 cp_num, CRd, addressing_mode);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -222,14 +222,14 @@
 	char* cond;
 	char* mnemonic;
 	uint8_t cp_num, opcode_1, CRd_Rd, CRn, CRm, opcode_2;
-	
+
 	cond = ((opcode &amp; 0xf0000000) == 0xf0000000) ? &quot;2&quot; : COND(opcode);
 	cp_num = (opcode &amp; 0xf00) &gt;&gt; 8;
 	CRd_Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
 	CRn = (opcode &amp; 0xf0000) &gt;&gt; 16;
 	CRm = (opcode &amp; 0xf);
 	opcode_2 = (opcode &amp; 0xe0) &gt;&gt; 5;
-	
+
 	/* CDP or MRC/MCR */
 	if (opcode &amp; 0x00000010) /* bit 4 set -&gt; MRC/MCR */
 	{
@@ -243,9 +243,9 @@
 			instruction-&gt;type = ARM_MCR;
 			mnemonic = &quot;MCR&quot;;
 		}
-		
+
 		opcode_1 = (opcode &amp; 0x00e00000) &gt;&gt; 21;
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s p%i, 0x%2.2x, r%i, c%i, c%i, 0x%2.2x&quot;,
 				 address, opcode, mnemonic, cond,
 				 cp_num, opcode_1, CRd_Rd, CRn, CRm, opcode_2);
@@ -254,14 +254,14 @@
 	{
 		instruction-&gt;type = ARM_CDP;
 		mnemonic = &quot;CDP&quot;;
-		
+
 		opcode_1 = (opcode &amp; 0x00f00000) &gt;&gt; 20;
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s p%i, 0x%2.2x, c%i, c%i, c%i, 0x%2.2x&quot;,
 				 address, opcode, mnemonic, cond,
 				 cp_num, opcode_1, CRd_Rd, CRn, CRm, opcode_2);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -273,7 +273,7 @@
 	char *operation; /* &quot;LDR&quot; or &quot;STR&quot; */
 	char *suffix; /* &quot;&quot;, &quot;B&quot;, &quot;T&quot;, &quot;BT&quot; */
 	char offset[32];
-	
+
 	/* examine flags */
 	I = (opcode &amp; 0x02000000) &gt;&gt; 25;
 	P = (opcode &amp; 0x01000000) &gt;&gt; 24;
@@ -281,13 +281,13 @@
 	B = (opcode &amp; 0x00400000) &gt;&gt; 22;
 	W = (opcode &amp; 0x00200000) &gt;&gt; 21;
 	L = (opcode &amp; 0x00100000) &gt;&gt; 20;
-	
+
 	/* target register */
 	Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
-	
+
 	/* base register */
 	Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
-	
+
 	instruction-&gt;info.load_store.Rd = Rd;
 	instruction-&gt;info.load_store.Rn = Rn;
 	instruction-&gt;info.load_store.U = U;
@@ -297,7 +297,7 @@
 		operation = &quot;LDR&quot;;
 	else
 		operation = &quot;STR&quot;;
-	
+
 	/* determine instruction type and suffix */
 	if (B)
 	{
@@ -337,7 +337,7 @@
 			suffix = &quot;&quot;;
 		}
 	}
-	
+
 	if (!I) /* #+-&lt;offset_12&gt; */
 	{
 		uint32_t offset_12 = (opcode &amp; 0xfff);
@@ -345,7 +345,7 @@
 			snprintf(offset, 32, &quot;, #%s0x%&quot; PRIx32 &quot;&quot;, (U) ? &quot;&quot; : &quot;-&quot;, offset_12);
 		else
 			snprintf(offset, 32, &quot;%s&quot;, &quot;&quot;);
-		
+
 		instruction-&gt;info.load_store.offset_mode = 0;
 		instruction-&gt;info.load_store.offset.offset = offset_12;
 	}
@@ -353,15 +353,15 @@
 	{
 		uint8_t shift_imm, shift;
 		uint8_t Rm;
-		
+
 		shift_imm = (opcode &amp; 0xf80) &gt;&gt; 7;
 		shift = (opcode &amp; 0x60) &gt;&gt; 5;
 		Rm = (opcode &amp; 0xf);
-		
+
 		/* LSR encodes a shift by 32 bit as 0x0 */
 		if ((shift == 0x1) &amp;&amp; (shift_imm == 0x0))
 			shift_imm = 0x20;
-		
+
 		/* ASR encodes a shift by 32 bit as 0x0 */
 		if ((shift == 0x2) &amp;&amp; (shift_imm == 0x0))
 			shift_imm = 0x20;
@@ -369,7 +369,7 @@
 		/* ROR by 32 bit is actually a RRX */
 		if ((shift == 0x3) &amp;&amp; (shift_imm == 0x0))
 			shift = 0x4;
-		
+
 		instruction-&gt;info.load_store.offset_mode = 1;
 		instruction-&gt;info.load_store.offset.reg.Rm = Rm;
 		instruction-&gt;info.load_store.offset.reg.shift = shift;
@@ -401,7 +401,7 @@
 			}
 		}
 	}
-	
+
 	if (P == 1)
 	{
 		if (W == 0) /* offset */
@@ -409,7 +409,7 @@
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, [r%i%s]&quot;,
 					 address, opcode, operation, COND(opcode), suffix,
 					 Rd, Rn, offset);
-			
+
 			instruction-&gt;info.load_store.index_mode = 0;
 		}
 		else /* pre-indexed */
@@ -417,7 +417,7 @@
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, [r%i%s]!&quot;,
 					 address, opcode, operation, COND(opcode), suffix,
 					 Rd, Rn, offset);
-			
+
 			instruction-&gt;info.load_store.index_mode = 1;
 		}
 	}
@@ -426,10 +426,10 @@
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, [r%i]%s&quot;,
 				 address, opcode, operation, COND(opcode), suffix,
 				 Rd, Rn, offset);
-		
+
 		instruction-&gt;info.load_store.index_mode = 2;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -441,7 +441,7 @@
 	char *operation; /* &quot;LDR&quot; or &quot;STR&quot; */
 	char *suffix; /* &quot;H&quot;, &quot;SB&quot;, &quot;SH&quot;, &quot;D&quot; */
 	char offset[32];
-	
+
 	/* examine flags */
 	P = (opcode &amp; 0x01000000) &gt;&gt; 24;
 	U = (opcode &amp; 0x00800000) &gt;&gt; 23;
@@ -450,17 +450,17 @@
 	L = (opcode &amp; 0x00100000) &gt;&gt; 20;
 	S = (opcode &amp; 0x00000040) &gt;&gt; 6;
 	H = (opcode &amp; 0x00000020) &gt;&gt; 5;
-	
+
 	/* target register */
 	Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
-	
+
 	/* base register */
 	Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
-	
+
 	instruction-&gt;info.load_store.Rd = Rd;
 	instruction-&gt;info.load_store.Rn = Rn;
 	instruction-&gt;info.load_store.U = U;
-	
+
 	/* determine instruction type and suffix */
 	if (S) /* signed */
 	{
@@ -508,12 +508,12 @@
 			instruction-&gt;type = ARM_STRH;
 		}
 	}
-	
+
 	if (I) /* Immediate offset/index (#+-&lt;offset_8&gt;)*/
 	{
 		uint32_t offset_8 = ((opcode &amp; 0xf00) &gt;&gt; 4) | (opcode &amp; 0xf);
 		snprintf(offset, 32, &quot;#%s0x%&quot; PRIx32 &quot;&quot;, (U) ? &quot;&quot; : &quot;-&quot;, offset_8);
-		
+
 		instruction-&gt;info.load_store.offset_mode = 0;
 		instruction-&gt;info.load_store.offset.offset = offset_8;
 	}
@@ -522,13 +522,13 @@
 		uint8_t Rm;
 		Rm = (opcode &amp; 0xf);
 		snprintf(offset, 32, &quot;%sr%i&quot;, (U) ? &quot;&quot; : &quot;-&quot;, Rm);
-		
+
 		instruction-&gt;info.load_store.offset_mode = 1;
 		instruction-&gt;info.load_store.offset.reg.Rm = Rm;
 		instruction-&gt;info.load_store.offset.reg.shift = 0x0;
 		instruction-&gt;info.load_store.offset.reg.shift_imm = 0x0;
 	}
-	
+
 	if (P == 1)
 	{
 		if (W == 0) /* offset */
@@ -536,7 +536,7 @@
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, [r%i, %s]&quot;,
 					 address, opcode, operation, COND(opcode), suffix,
 					 Rd, Rn, offset);
-			
+
 			instruction-&gt;info.load_store.index_mode = 0;
 		}
 		else /* pre-indexed */
@@ -544,7 +544,7 @@
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, [r%i, %s]!&quot;,
 					 address, opcode, operation, COND(opcode), suffix,
 					 Rd, Rn, offset);
-		
+
 			instruction-&gt;info.load_store.index_mode = 1;
 		}
 	}
@@ -553,10 +553,10 @@
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, [r%i], %s&quot;,
 				 address, opcode, operation, COND(opcode), suffix,
 				 Rd, Rn, offset);
-	
+
 		instruction-&gt;info.load_store.index_mode = 2;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -571,7 +571,7 @@
 	char *reg_list_p;
 	int i;
 	int first_reg = 1;
-	
+
 	P = (opcode &amp; 0x01000000) &gt;&gt; 24;
 	U = (opcode &amp; 0x00800000) &gt;&gt; 23;
 	S = (opcode &amp; 0x00400000) &gt;&gt; 22;
@@ -579,12 +579,12 @@
 	L = (opcode &amp; 0x00100000) &gt;&gt; 20;
 	register_list = (opcode &amp; 0xffff);
 	Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
-	
+
 	instruction-&gt;info.load_store_multiple.Rn = Rn;
 	instruction-&gt;info.load_store_multiple.register_list = register_list;
 	instruction-&gt;info.load_store_multiple.S = S;
 	instruction-&gt;info.load_store_multiple.W = W;
-	
+
 	if (L)
 	{
 		instruction-&gt;type = ARM_LDM;
@@ -595,7 +595,7 @@
 		instruction-&gt;type = ARM_STM;
 		mnemonic = &quot;STM&quot;;
 	}
-	
+
 	if (P)
 	{
 		if (U)
@@ -622,7 +622,7 @@
 			addressing_mode = &quot;DA&quot;;
 		}
 	}
-	
+
 	reg_list_p = reg_list;
 	for (i = 0; i &lt;= 15; i++)
 	{
@@ -639,11 +639,11 @@
 			}
 		}
 	}
-	
+
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i%s, {%s}%s&quot;,
 			 address, opcode, mnemonic, COND(opcode), addressing_mode,
 			 Rn, (W) ? &quot;!&quot; : &quot;&quot;, reg_list, (S) ? &quot;^&quot; : &quot;&quot;);
-	
+
 	return ERROR_OK;
 }
 
@@ -662,7 +662,7 @@
 			Rn = (opcode &amp; 0xf000) &gt;&gt; 12;
 			Rd = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			S = (opcode &amp; 0x00100000) &gt;&gt; 20;
-			
+
 			/* examine A bit (accumulate) */
 			if (opcode &amp; 0x00200000)
 			{
@@ -676,10 +676,10 @@
 				snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tMUL%s%s r%i, r%i, r%i&quot;,
 						 address, opcode, COND(opcode), (S) ? &quot;S&quot; : &quot;&quot;, Rd, Rm, Rs);
 			}
-			
+
 			return ERROR_OK;
 		}
-		
+
 		/* Multiply (accumulate) long */
 		if ((opcode &amp; 0x0f800000) == 0x00800000)
 		{
@@ -690,7 +690,7 @@
 			RdHi = (opcode &amp; 0xf000) &gt;&gt; 12;
 			RdLow = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			S = (opcode &amp; 0x00100000) &gt;&gt; 20;
-			
+
 			switch ((opcode &amp; 0x00600000) &gt;&gt; 21)
 			{
 				case 0x0:
@@ -710,14 +710,14 @@
 					mnemonic = &quot;SMLAL&quot;;
 					break;
 			}
-			
+
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, r%i, r%i, r%i&quot;,
 						address, opcode, mnemonic, COND(opcode), (S) ? &quot;S&quot; : &quot;&quot;,
 						RdLow, RdHi, Rm, Rs);
-			
+
 			return ERROR_OK;
 		}
-		
+
 		/* Swap/swap byte */
 		if ((opcode &amp; 0x0f800000) == 0x01000000)
 		{
@@ -725,17 +725,17 @@
 			Rm = opcode &amp; 0xf;
 			Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
 			Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
-			
+
 			/* examine B flag */
 			instruction-&gt;type = (opcode &amp; 0x00400000) ? ARM_SWPB : ARM_SWP;
-			
+
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s r%i, r%i, [r%i]&quot;,
 					 address, opcode, (opcode &amp; 0x00400000) ? &quot;SWPB&quot; : &quot;SWP&quot;, COND(opcode), Rd, Rm, Rn);
 			return ERROR_OK;
 		}
-		
+
 	}
-	
+
 	return evaluate_misc_load_store(opcode, address, instruction);
 }
 
@@ -743,18 +743,18 @@
 {
 	int R = (opcode &amp; 0x00400000) &gt;&gt; 22;
 	char *PSR = (R) ? &quot;SPSR&quot; : &quot;CPSR&quot;;
-		
+
 	/* Move register to status register (MSR) */
 	if (opcode &amp; 0x00200000)
 	{
 		instruction-&gt;type = ARM_MSR;
-			
+
 		/* immediate variant */
 		if (opcode &amp; 0x02000000)
 		{
 			uint8_t immediate = (opcode &amp; 0xff);
 			uint8_t rotate = (opcode &amp; 0xf00);
-			
+
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tMSR%s %s_%s%s%s%s, 0x%8.8&quot; PRIx32 ,
 					 address, opcode, COND(opcode), PSR,
 					 (opcode &amp; 0x10000) ? &quot;c&quot; : &quot;&quot;,
@@ -776,19 +776,19 @@
 					 Rm
 );
 		}
-		
+
 	}
 	else /* Move status register to register (MRS) */
 	{
 		uint8_t Rd;
-		
+
 		instruction-&gt;type = ARM_MRS;
 		Rd = (opcode &amp; 0x0000f000) &gt;&gt; 12;
-			
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tMRS%s r%i, %s&quot;,
 				 address, opcode, COND(opcode), Rd, PSR);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -800,21 +800,21 @@
 	{
 		evaluate_mrs_msr(opcode, address, instruction);
 	}
-	
+
 	/* BX */
 	if ((opcode &amp; 0x006000f0) == 0x00200010)
 	{
 		uint8_t Rm;
 		instruction-&gt;type = ARM_BX;
 		Rm = opcode &amp; 0xf;
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tBX%s r%i&quot;,
 				 address, opcode, COND(opcode), Rm);
-		
+
 		instruction-&gt;info.b_bl_bx_blx.reg_operand = Rm;
 		instruction-&gt;info.b_bl_bx_blx.target_address = -1;
 	}
-	
+
 	/* CLZ */
 	if ((opcode &amp; 0x006000f0) == 0x00600010)
 	{
@@ -826,21 +826,21 @@
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tCLZ%s r%i, r%i&quot;,
 				 address, opcode, COND(opcode), Rd, Rm);
 	}
-	
+
 	/* BLX(2) */
 	if ((opcode &amp; 0x006000f0) == 0x00200030)
 	{
 		uint8_t Rm;
 		instruction-&gt;type = ARM_BLX;
 		Rm = opcode &amp; 0xf;
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tBLX%s r%i&quot;,
 				 address, opcode, COND(opcode), Rm);
-				 
+
 		instruction-&gt;info.b_bl_bx_blx.reg_operand = Rm;
 		instruction-&gt;info.b_bl_bx_blx.target_address = -1;
 	}
-	
+
 	/* Enhanced DSP add/subtracts */
 	if ((opcode &amp; 0x0000000f0) == 0x00000050)
 	{
@@ -849,7 +849,7 @@
 		Rm = opcode &amp; 0xf;
 		Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
 		Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
-		
+
 		switch ((opcode &amp; 0x00600000) &gt;&gt; 21)
 		{
 			case 0x0:
@@ -869,28 +869,28 @@
 				mnemonic = &quot;QDSUB&quot;;
 				break;
 		}
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s r%i, r%i, r%i&quot;,
 				 address, opcode, mnemonic, COND(opcode), Rd, Rm, Rn);
 	}
-	
+
 	/* Software breakpoints */
 	if ((opcode &amp; 0x0000000f0) == 0x00000070)
 	{
 		uint32_t immediate;
 		instruction-&gt;type = ARM_BKPT;
 		immediate = ((opcode &amp; 0x000fff00) &gt;&gt; 4) | (opcode &amp; 0xf);
-		
+
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tBKPT 0x%4.4&quot; PRIx32 &quot;&quot;,
-				 address, opcode, immediate);	
+				 address, opcode, immediate);
 	}
-	
+
 	/* Enhanced DSP multiplies */
 	if ((opcode &amp; 0x000000090) == 0x00000080)
 	{
 		int x = (opcode &amp; 0x20) &gt;&gt; 5;
 		int y = (opcode &amp; 0x40) &gt;&gt; 6;
-		
+
 		/* SMLA &lt; x&gt;&lt;y&gt; */
 		if ((opcode &amp; 0x00600000) == 0x00000000)
 		{
@@ -900,12 +900,12 @@
 			Rm = (opcode &amp; 0xf);
 			Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
 			Rn = (opcode &amp; 0xf000) &gt;&gt; 12;
-			
+
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tSMLA%s%s%s r%i, r%i, r%i, r%i&quot;,
 					 address, opcode, (x) ? &quot;T&quot; : &quot;B&quot;, (y) ? &quot;T&quot; : &quot;B&quot;, COND(opcode),
 					 Rd, Rm, Rs, Rn);
 		}
-		
+
 		/* SMLAL &lt; x&gt;&lt;y&gt; */
 		if ((opcode &amp; 0x00600000) == 0x00400000)
 		{
@@ -915,12 +915,12 @@
 			RdLow = (opcode &amp; 0xf000) &gt;&gt; 12;
 			Rm = (opcode &amp; 0xf);
 			Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
-			
+
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tSMLA%s%s%s r%i, r%i, r%i, r%i&quot;,
 					 address, opcode, (x) ? &quot;T&quot; : &quot;B&quot;, (y) ? &quot;T&quot; : &quot;B&quot;, COND(opcode),
 					 RdLow, RdHi, Rm, Rs);
 		}
-		
+
 		/* SMLAW &lt; y&gt; */
 		if (((opcode &amp; 0x00600000) == 0x00100000) &amp;&amp; (x == 0))
 		{
@@ -935,7 +935,7 @@
 					 address, opcode, (y) ? &quot;T&quot; : &quot;B&quot;, COND(opcode),
 					 Rd, Rm, Rs, Rn);
 		}
-		
+
 		/* SMUL &lt; x&gt;&lt;y&gt; */
 		if ((opcode &amp; 0x00600000) == 0x00300000)
 		{
@@ -944,12 +944,12 @@
 			Rd = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			Rm = (opcode &amp; 0xf);
 			Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
-			
+
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tSMULW%s%s%s r%i, r%i, r%i&quot;,
 					 address, opcode, (x) ? &quot;T&quot; : &quot;B&quot;, (y) ? &quot;T&quot; : &quot;B&quot;, COND(opcode),
 					 Rd, Rm, Rs);
 		}
-		
+
 		/* SMULW &lt; y&gt; */
 		if (((opcode &amp; 0x00600000) == 0x00100000) &amp;&amp; (x == 1))
 		{
@@ -958,13 +958,13 @@
 			Rd = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			Rm = (opcode &amp; 0xf);
 			Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
-			
+
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tSMULW%s%s r%i, r%i, r%i&quot;,
 					 address, opcode, (y) ? &quot;T&quot; : &quot;B&quot;, COND(opcode),
 					 Rd, Rm, Rs);
 		}
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -973,14 +973,14 @@
 	uint8_t I, op, S, Rn, Rd;
 	char *mnemonic = NULL;
 	char shifter_operand[32];
-	
+
 	I = (opcode &amp; 0x02000000) &gt;&gt; 25;
 	op = (opcode &amp; 0x01e00000) &gt;&gt; 21;
 	S = (opcode &amp; 0x00100000) &gt;&gt; 20;
-	
+
 	Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
 	Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
-	
+
 	instruction-&gt;info.data_proc.Rd = Rd;
 	instruction-&gt;info.data_proc.Rn = Rn;
 	instruction-&gt;info.data_proc.S = S;
@@ -1052,17 +1052,17 @@
 			mnemonic = &quot;MVN&quot;;
 			break;
 	}
-	
+
 	if (I) /* immediate shifter operand (#&lt;immediate&gt;)*/
 	{
 		uint8_t immed_8 = opcode &amp; 0xff;
 		uint8_t rotate_imm = (opcode &amp; 0xf00) &gt;&gt; 8;
 		uint32_t immediate;
-		
+
 		immediate = ror(immed_8, rotate_imm * 2);
-		
+
 		snprintf(shifter_operand, 32, &quot;#0x%&quot; PRIx32 &quot;&quot;, immediate);
-		
+
 		instruction-&gt;info.data_proc.variant = 0;
 		instruction-&gt;info.data_proc.shifter_operand.immediate.immediate = immediate;
 	}
@@ -1071,7 +1071,7 @@
 		uint8_t shift, Rm;
 		shift = (opcode &amp; 0x60) &gt;&gt; 5;
 		Rm = (opcode &amp; 0xf);
-		
+
 		if ((opcode &amp; 0x10) != 0x10) /* Immediate shifts (&quot;&lt;Rm&gt;&quot; or &quot;&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_immediate&gt;&quot;) */
 		{
 			uint8_t shift_imm;
@@ -1081,11 +1081,11 @@
 			instruction-&gt;info.data_proc.shifter_operand.immediate_shift.Rm = Rm;
 			instruction-&gt;info.data_proc.shifter_operand.immediate_shift.shift_imm = shift_imm;
 			instruction-&gt;info.data_proc.shifter_operand.immediate_shift.shift = shift;
-		
+
 			/* LSR encodes a shift by 32 bit as 0x0 */
 			if ((shift == 0x1) &amp;&amp; (shift_imm == 0x0))
 				shift_imm = 0x20;
-		
+
 			/* ASR encodes a shift by 32 bit as 0x0 */
 			if ((shift == 0x2) &amp;&amp; (shift_imm == 0x0))
 				shift_imm = 0x20;
@@ -1093,7 +1093,7 @@
 			/* ROR by 32 bit is actually a RRX */
 			if ((shift == 0x3) &amp;&amp; (shift_imm == 0x0))
 				shift = 0x4;
-			
+
 			if ((shift_imm == 0x0) &amp;&amp; (shift == 0x0))
 			{
 				snprintf(shifter_operand, 32, &quot;r%i&quot;, Rm);
@@ -1125,12 +1125,12 @@
 		else /* Register shifts (&quot;&lt;Rm&gt;, &lt;shift&gt; &lt;Rs&gt;&quot;) */
 		{
 			uint8_t Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
-			
+
 			instruction-&gt;info.data_proc.variant = 2;
 			instruction-&gt;info.data_proc.shifter_operand.register_shift.Rm = Rm;
 			instruction-&gt;info.data_proc.shifter_operand.register_shift.Rs = Rs;
 			instruction-&gt;info.data_proc.shifter_operand.register_shift.shift = shift;
-			
+
 			if (shift == 0x0) /* LSL */
 			{
 				snprintf(shifter_operand, 32, &quot;r%i, LSL r%i&quot;, Rm, Rs);
@@ -1149,7 +1149,7 @@
 			}
 		}
 	}
-	
+
 	if ((op &lt; 0x8) || (op == 0xc) || (op == 0xe)) /* &lt;opcode3&gt;{&lt;cond&gt;}{S} &lt;Rd&gt;, &lt;Rn&gt;, &lt;shifter_operand&gt; */
 	{
 		snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\t%s%s%s r%i, r%i, %s&quot;,
@@ -1171,23 +1171,23 @@
 				 address, opcode, mnemonic, COND(opcode),
 				 Rn, shifter_operand);
 	}
-	
+
 	return ERROR_OK;
 }
-		
+
 int arm_evaluate_opcode(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	/* clear fields, to avoid confusion */
 	memset(instruction, 0, sizeof(arm_instruction_t));
 	instruction-&gt;opcode = opcode;
-	
+
 	/* catch opcodes with condition field [31:28] = b1111 */
 	if ((opcode &amp; 0xf0000000) == 0xf0000000)
 	{
 		/* Undefined instruction (or ARMv5E cache preload PLD) */
 		if ((opcode &amp; 0x08000000) == 0x00000000)
 			return evaluate_pld(opcode, address, instruction);
-		
+
 		/* Undefined instruction */
 		if ((opcode &amp; 0x0e000000) == 0x08000000)
 		{
@@ -1195,24 +1195,24 @@
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tUNDEFINED INSTRUCTION&quot;, address, opcode);
 			return ERROR_OK;
 		}
-		
+
 		/* Branch and branch with link and change to Thumb */
 		if ((opcode &amp; 0x0e000000) == 0x0a000000)
 			return evaluate_blx_imm(opcode, address, instruction);
-		
+
 		/* Extended coprocessor opcode space (ARMv5 and higher)*/
 		/* Coprocessor load/store and double register transfers */
 		if ((opcode &amp; 0x0e000000) == 0x0c000000)
 			return evaluate_ldc_stc_mcrr_mrrc(opcode, address, instruction);
-		
+
 		/* Coprocessor data processing */
 		if ((opcode &amp; 0x0f000100) == 0x0c000000)
 			return evaluate_cdp_mcr_mrc(opcode, address, instruction);
-		
+
 		/* Coprocessor register transfers */
 		if ((opcode &amp; 0x0f000010) == 0x0c000010)
 			return evaluate_cdp_mcr_mrc(opcode, address, instruction);
-		
+
 		/* Undefined instruction */
 		if ((opcode &amp; 0x0f000000) == 0x0f000000)
 		{
@@ -1221,21 +1221,21 @@
 			return ERROR_OK;
 		}
 	}
-	
+
 	/* catch opcodes with [27:25] = b000 */
 	if ((opcode &amp; 0x0e000000) == 0x00000000)
 	{
 		/* Multiplies, extra load/stores */
 		if ((opcode &amp; 0x00000090) == 0x00000090)
 			return evaluate_mul_and_extra_ld_st(opcode, address, instruction);
-		
+
 		/* Miscellaneous instructions */
 		if ((opcode &amp; 0x0f900000) == 0x01000000)
 			return evaluate_misc_instr(opcode, address, instruction);
-		
+
 		return evaluate_data_proc(opcode, address, instruction);
 	}
-	
+
 	/* catch opcodes with [27:25] = b001 */
 	if ((opcode &amp; 0x0e000000) == 0x02000000)
 	{
@@ -1246,22 +1246,22 @@
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tUNDEFINED INSTRUCTION&quot;, address, opcode);
 			return ERROR_OK;
 		}
-				
+
 		/* Move immediate to status register */
 		if ((opcode &amp; 0x0fb00000) == 0x03200000)
 			return evaluate_mrs_msr(opcode, address, instruction);
-		
+
 		return evaluate_data_proc(opcode, address, instruction);
 
 	}
-	
+
 	/* catch opcodes with [27:25] = b010 */
 	if ((opcode &amp; 0x0e000000) == 0x04000000)
 	{
 		/* Load/store immediate offset */
 		return evaluate_load_store(opcode, address, instruction);
 	}
-	
+
 	/* catch opcodes with [27:25] = b011 */
 	if ((opcode &amp; 0x0e000000) == 0x06000000)
 	{
@@ -1272,49 +1272,49 @@
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%8.8&quot; PRIx32 &quot;\tUNDEFINED INSTRUCTION&quot;, address, opcode);
 			return ERROR_OK;
 		}
-		
+
 		/* Load/store register offset */
 		return evaluate_load_store(opcode, address, instruction);
 
 	}
-	
+
 	/* catch opcodes with [27:25] = b100 */
 	if ((opcode &amp; 0x0e000000) == 0x08000000)
 	{
 		/* Load/store multiple */
 		return evaluate_ldm_stm(opcode, address, instruction);
 	}
-	
+
 	/* catch opcodes with [27:25] = b101 */
 	if ((opcode &amp; 0x0e000000) == 0x0a000000)
 	{
 		/* Branch and branch with link */
 		return evaluate_b_bl(opcode, address, instruction);
 	}
-	
+
 	/* catch opcodes with [27:25] = b110 */
 	if ((opcode &amp; 0x0e000000) == 0x0a000000)
 	{
 		/* Coprocessor load/store and double register transfers */
 		return evaluate_ldc_stc_mcrr_mrrc(opcode, address, instruction);
 	}
-	
+
 	/* catch opcodes with [27:25] = b111 */
 	if ((opcode &amp; 0x0e000000) == 0x0e000000)
 	{
 		/* Software interrupt */
 		if ((opcode &amp; 0x0f000000) == 0x0f000000)
 			return evaluate_swi(opcode, address, instruction);
-		
+
 		/* Coprocessor data processing */
 		if ((opcode &amp; 0x0f000010) == 0x0e000000)
 			return evaluate_cdp_mcr_mrc(opcode, address, instruction);
-		
+
 		/* Coprocessor register transfers */
 		if ((opcode &amp; 0x0f000010) == 0x0e000010)
 			return evaluate_cdp_mcr_mrc(opcode, address, instruction);
 	}
-	
+
 	LOG_ERROR(&quot;should never reach this point&quot;);
 	return -1;
 }
@@ -1325,11 +1325,11 @@
 	uint32_t opc = (opcode &gt;&gt; 11) &amp; 0x3;
 	uint32_t target_address;
 	char *mnemonic = NULL;
-	
+
 	/* sign extend 11-bit offset */
 	if (((opc == 0) || (opc == 2)) &amp;&amp; (offset &amp; 0x00000400))
 		offset = 0xfffff800 | offset;
-	
+
 	target_address = address + 4 + (offset &lt;&lt; 1);
 
 	switch (opc)
@@ -1359,7 +1359,7 @@
 	/* TODO: deals correctly with dual opcodes BL/BLX ... */
 
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\t%s 0x%8.8&quot; PRIx32 , address, opcode,mnemonic, target_address);
-	
+
 	instruction-&gt;info.b_bl_bx_blx.reg_operand = -1;
 	instruction-&gt;info.b_bl_bx_blx.target_address = target_address;
 
@@ -1374,7 +1374,7 @@
 	uint32_t opc = opcode &amp; (1 &lt;&lt; 9);
 	uint32_t reg_imm  = opcode &amp; (1 &lt;&lt; 10);
 	char *mnemonic;
-	
+
 	if (opc)
 	{
 		instruction-&gt;type = ARM_SUB;
@@ -1385,7 +1385,7 @@
 		instruction-&gt;type = ARM_ADD;
 		mnemonic = &quot;ADDS&quot;;
 	}
-	
+
 	instruction-&gt;info.data_proc.Rd = Rd;
 	instruction-&gt;info.data_proc.Rn = Rn;
 	instruction-&gt;info.data_proc.S = 1;
@@ -1415,7 +1415,7 @@
 	uint8_t imm = (opcode &gt;&gt; 6) &amp; 0x1f;
 	uint8_t opc = (opcode &gt;&gt; 11) &amp; 0x3;
 	char *mnemonic = NULL;
-	
+
 	switch (opc)
 	{
 		case 0:
@@ -1458,13 +1458,13 @@
 	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7;
 	uint32_t opc = (opcode &gt;&gt; 11) &amp; 0x3;
 	char *mnemonic = NULL;
-	
+
 	instruction-&gt;info.data_proc.Rd = Rd;
 	instruction-&gt;info.data_proc.Rn = Rd;
 	instruction-&gt;info.data_proc.S = 1;
 	instruction-&gt;info.data_proc.variant = 0; /*immediate*/
 	instruction-&gt;info.data_proc.shifter_operand.immediate.immediate = imm;
-	
+
 	switch (opc)
 	{
 		case 0:
@@ -1486,7 +1486,7 @@
 			mnemonic = &quot;SUBS&quot;;
 			break;
 	}
-	
+
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\t%s r%i, #0x%02x&quot; ,
 				 address, opcode, mnemonic, Rd, imm);
 
@@ -1497,15 +1497,15 @@
 {
 	uint8_t high_reg, op, Rm, Rd,H1,H2;
 	char *mnemonic = NULL;
-	
+
 	high_reg = (opcode &amp; 0x0400) &gt;&gt; 10;
 	op = (opcode &amp; 0x03C0) &gt;&gt; 6;
-	
+
 	Rd = (opcode &amp; 0x0007);
 	Rm = (opcode &amp; 0x0038) &gt;&gt; 3;
 	H1 = (opcode &amp; 0x0080) &gt;&gt; 7;
 	H2 = (opcode &amp; 0x0040) &gt;&gt; 6;
-	
+
 	instruction-&gt;info.data_proc.Rd = Rd;
 	instruction-&gt;info.data_proc.Rn = Rd;
 	instruction-&gt;info.data_proc.S = (!high_reg || (instruction-&gt;type == ARM_CMP));
@@ -1517,7 +1517,7 @@
 		Rd |= H1 &lt;&lt; 3;
 		Rm |= H2 &lt;&lt; 3;
 		op &gt;&gt;= 2;
-	
+
 		switch (op)
 		{
 			case 0x0:
@@ -1552,7 +1552,7 @@
 					instruction-&gt;type = ARM_UNDEFINED_INSTRUCTION;
 					snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\tUNDEFINED INSTRUCTION&quot;, address, opcode);
 				}
-				return ERROR_OK;	
+				return ERROR_OK;
 				break;
 		}
 	}
@@ -1655,7 +1655,7 @@
 int evaluate_load_literal_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t immediate;
-	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7;
 
 	instruction-&gt;type = ARM_LDR;
 	immediate = opcode &amp; 0x000000ff;
@@ -1673,10 +1673,10 @@
 
 int evaluate_load_store_reg_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
-	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
-	uint8_t Rm = (opcode &gt;&gt; 6) &amp; 0x7; 
-	uint8_t opc = (opcode &gt;&gt; 9) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7;
+	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7;
+	uint8_t Rm = (opcode &gt;&gt; 6) &amp; 0x7;
+	uint8_t opc = (opcode &gt;&gt; 9) &amp; 0x7;
 	char *mnemonic = NULL;
 
 	switch (opc)
@@ -1716,7 +1716,7 @@
 	}
 
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\t%s r%i, [r%i, r%i]&quot;, address, opcode, mnemonic, Rd, Rn, Rm);
-	
+
 	instruction-&gt;info.load_store.Rd = Rd;
 	instruction-&gt;info.load_store.Rn = Rn;
 	instruction-&gt;info.load_store.index_mode = 0; /*offset*/
@@ -1729,8 +1729,8 @@
 int evaluate_load_store_imm_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t offset = (opcode &gt;&gt; 6) &amp; 0x1f;
-	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
-	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7;
+	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7;
 	uint32_t L = opcode &amp; (1 &lt;&lt; 11);
 	uint32_t B = opcode &amp; (1 &lt;&lt; 12);
 	char *mnemonic;
@@ -1760,7 +1760,7 @@
 	}
 
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\t%s%c r%i, [r%i, #0x%&quot; PRIx32 &quot;]&quot;, address, opcode, mnemonic, suffix, Rd, Rn, offset &lt;&lt; shift);
-	
+
 	instruction-&gt;info.load_store.Rd = Rd;
 	instruction-&gt;info.load_store.Rn = Rn;
 	instruction-&gt;info.load_store.index_mode = 0; /*offset*/
@@ -1773,7 +1773,7 @@
 int evaluate_load_store_stack_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t offset = opcode  &amp; 0xff;
-	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7;
 	uint32_t L = opcode &amp; (1 &lt;&lt; 11);
 	char *mnemonic;
 
@@ -1789,7 +1789,7 @@
 	}
 
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\t%s r%i, [SP, #0x%&quot; PRIx32 &quot;]&quot;, address, opcode, mnemonic, Rd, offset*4);
-	
+
 	instruction-&gt;info.load_store.Rd = Rd;
 	instruction-&gt;info.load_store.Rn = 13 /*SP*/;
 	instruction-&gt;info.load_store.index_mode = 0; /*offset*/
@@ -1802,13 +1802,13 @@
 int evaluate_add_sp_pc_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t imm = opcode  &amp; 0xff;
-	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7;
 	uint8_t Rn;
 	uint32_t SP = opcode &amp; (1 &lt;&lt; 11);
 	char *reg_name;
 
 	instruction-&gt;type = ARM_ADD;
-	
+
 	if (SP)
 	{
 		reg_name = &quot;SP&quot;;
@@ -1836,7 +1836,7 @@
 	uint8_t opc = opcode &amp; (1 &lt;&lt; 7);
 	char *mnemonic;
 
-	
+
 	if (opc)
 	{
 		instruction-&gt;type = ARM_SUB;
@@ -1861,7 +1861,7 @@
 int evaluate_breakpoint_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint32_t imm = opcode  &amp; 0xff;
-	
+
 	instruction-&gt;type = ARM_BKPT;
 
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\tBKPT 0x%02&quot; PRIx32 &quot;&quot;, address, opcode, imm);
@@ -1880,7 +1880,7 @@
 	char *reg_names_p;
 	char *mnemonic;
 	char ptr_name[7] = &quot;&quot;;
-	int i;	
+	int i;
 
 	if ((opcode &amp; 0xf000) == 0xc000)
 	{ /* generic load/store multiple */
@@ -1958,12 +1958,12 @@
 	/* sign extend 8-bit offset */
 	if (offset &amp; 0x00000080)
 		offset = 0xffffff00 | offset;
-	
+
 	target_address = address + 4 + (offset &lt;&lt; 1);
 
 	snprintf(instruction-&gt;text, 128, &quot;0x%8.8&quot; PRIx32 &quot;\t0x%4.4x\tB%s 0x%8.8&quot; PRIx32 , address, opcode,
 			 arm_condition_strings[cond], target_address);
-	
+
 	instruction-&gt;type = ARM_B;
 	instruction-&gt;info.b_bl_bx_blx.reg_operand = -1;
 	instruction-&gt;info.b_bl_bx_blx.target_address = target_address;
@@ -1976,7 +1976,7 @@
 	/* clear fields, to avoid confusion */
 	memset(instruction, 0, sizeof(arm_instruction_t));
 	instruction-&gt;opcode = opcode;
-	
+
 	if ((opcode &amp; 0xe000) == 0x0000)
 	{
 		/* add/substract register or immediate */
@@ -1986,19 +1986,19 @@
 		else
 			return evaluate_shift_imm_thumb(opcode, address, instruction);
 	}
-	
+
 	/* Add/substract/compare/move immediate */
 	if ((opcode &amp; 0xe000) == 0x2000)
 	{
 		return evaluate_data_proc_imm_thumb(opcode, address, instruction);
 	}
-	
+
 	/* Data processing instructions */
 	if ((opcode &amp; 0xf800) == 0x4000)
 	{
 		return evaluate_data_proc_thumb(opcode, address, instruction);
 	}
-	
+
 	/* Load from literal pool */
 	if ((opcode &amp; 0xf800) == 0x4800)
 	{
@@ -2017,7 +2017,7 @@
 	{
 		return evaluate_load_store_imm_thumb(opcode, address, instruction);
 	}
-	
+
 	/* Load/Store from/to stack */
 	if ((opcode &amp; 0xf000) == 0x9000)
 	{
@@ -2058,7 +2058,7 @@
 	{
 		return evaluate_cond_branch_thumb(opcode, address, instruction);
 	}
-	
+
 	if ((opcode &amp; 0xe000) == 0xe000)
 	{
 		/* Undefined instructions */

Modified: trunk/src/target/arm_disassembler.h
===================================================================
--- trunk/src/target/arm_disassembler.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm_disassembler.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -25,13 +25,13 @@
 enum arm_instruction_type
 {
 	ARM_UNKNOWN_INSTUCTION,
-	
+
 	/* Branch instructions */
 	ARM_B,
 	ARM_BL,
 	ARM_BX,
 	ARM_BLX,
-	
+
 	/* Data processing instructions */
 	ARM_AND,
 	ARM_EOR,
@@ -49,32 +49,32 @@
 	ARM_MOV,
 	ARM_BIC,
 	ARM_MVN,
-	
+
 	/* Load/store instructions */
 	ARM_LDR,
 	ARM_LDRB,
 	ARM_LDRT,
 	ARM_LDRBT,
-	
+
 	ARM_LDRH,
 	ARM_LDRSB,
 	ARM_LDRSH,
-	
+
 	ARM_LDM,
 
 	ARM_STR,
 	ARM_STRB,
 	ARM_STRT,
 	ARM_STRBT,
-	
+
 	ARM_STRH,
-	
+
 	ARM_STM,
-	
+
 	/* Status register access instructions */
 	ARM_MRS,
 	ARM_MSR,
-	
+
 	/* Multiply instructions */
 	ARM_MUL,
 	ARM_MLA,
@@ -82,25 +82,25 @@
 	ARM_SMLAL,
 	ARM_UMULL,
 	ARM_UMLAL,
-	
+
 	/* Miscellaneous instructions */
 	ARM_CLZ,
-	
+
 	/* Exception generating instructions */
 	ARM_BKPT,
 	ARM_SWI,
-	
+
 	/* Coprocessor instructions */
 	ARM_CDP,
 	ARM_LDC,
 	ARM_STC,
 	ARM_MCR,
 	ARM_MRC,
-	
+
 	/* Semaphore instructions */
 	ARM_SWP,
 	ARM_SWPB,
-	
+
 	/* Enhanced DSP extensions */
 	ARM_MCRR,
 	ARM_MRRC,
@@ -184,7 +184,7 @@
 	enum arm_instruction_type type;
 	char text[128];
 	uint32_t opcode;
-	
+
 	union {
 		arm_b_bl_bx_blx_instr_t b_bl_bx_blx;
 		arm_data_proc_instr_t data_proc;

Modified: trunk/src/target/arm_jtag.c
===================================================================
--- trunk/src/target/arm_jtag.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm_jtag.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -48,9 +48,9 @@
 		field.out_value = t;
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 		field.in_value = NULL;
-		
 
 
+
 		if (no_verify_capture == NULL)
 		{
 			jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());

Modified: trunk/src/target/arm_simulator.c
===================================================================
--- trunk/src/target/arm_simulator.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/arm_simulator.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -35,7 +35,7 @@
 {
 	uint32_t return_value = 0;
 	shift_amount &amp;= 0xff;
-	
+
 	if (shift == 0x0) /* LSL */
 	{
 		if ((shift_amount &gt; 0) &amp;&amp; (shift_amount &lt;= 32))
@@ -118,7 +118,7 @@
 			Rm |= 0x80000000;
 		*carry = Rm &amp; 0x1;
 	}
-	
+
 	return return_value;
 }
 
@@ -126,14 +126,14 @@
 {
 	uint32_t return_value;
 	int instruction_size;
-	
+
 	if (armv4_5-&gt;core_state == ARMV4_5_STATE_ARM)
 		instruction_size = 4;
 	else
 		instruction_size = 2;
-	
+
 	*shifter_carry_out = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
-	
+
 	if (variant == 0) /* 32-bit immediate */
 	{
 		return_value = shifter_operand.immediate.immediate;
@@ -141,22 +141,22 @@
 	else if (variant == 1) /* immediate shift */
 	{
 		uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.immediate_shift.Rm).value, 0, 32);
-		
+
 		/* adjust RM in case the PC is being read */
 		if (shifter_operand.immediate_shift.Rm == 15)
 			Rm += 2 * instruction_size;
-		
+
 		return_value = arm_shift(shifter_operand.immediate_shift.shift, Rm, shifter_operand.immediate_shift.shift_imm, shifter_carry_out);
 	}
 	else if (variant == 2) /* register shift */
 	{
 		uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.register_shift.Rm).value, 0, 32);
 		uint32_t Rs = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.register_shift.Rs).value, 0, 32);
-		
+
 		/* adjust RM in case the PC is being read */
 		if (shifter_operand.register_shift.Rm == 15)
 			Rm += 2 * instruction_size;
-			
+
 		return_value = arm_shift(shifter_operand.immediate_shift.shift, Rm, Rs, shifter_carry_out);
 	}
 	else
@@ -164,7 +164,7 @@
 		LOG_ERROR(&quot;BUG: shifter_operand.variant not 0, 1 or 2&quot;);
 		return_value = 0xffffffff;
 	}
-	
+
 	return return_value;
 }
 
@@ -251,16 +251,16 @@
 		case 0xe:
 		case 0xf:
 			return 1;
-				
+
 	}
-	
+
 	LOG_ERROR(&quot;BUG: should never get here&quot;);
 	return 0;
 }
 
 int thumb_pass_branch_condition(uint32_t cpsr, uint16_t opcode)
 {
-	return pass_condition(cpsr, (opcode &amp; 0x0f00) &lt;&lt; 20); 
+	return pass_condition(cpsr, (opcode &amp; 0x0f00) &lt;&lt; 20);
 }
 
 /* simulate a single step (if possible)
@@ -274,11 +274,11 @@
 	arm_instruction_t instruction;
 	int instruction_size;
 	int retval = ERROR_OK;
-	
+
 	if (armv4_5-&gt;core_state == ARMV4_5_STATE_ARM)
 	{
 		uint32_t opcode;
-		
+
 		/* get current instruction, and identify it */
 		if ((retval = target_read_u32(target, current_pc, &amp;opcode)) != ERROR_OK)
 		{
@@ -289,7 +289,7 @@
 			return retval;
 		}
 		instruction_size = 4;
-		
+
 		/* check condition code (for all instructions) */
 		if (!pass_condition(buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32), opcode))
 		{
@@ -301,14 +301,14 @@
 			{
 				buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, current_pc + instruction_size);
 			}
-			
+
 			return ERROR_OK;
 		}
 	}
 	else
 	{
 		uint16_t opcode;
-		
+
 		if ((retval = target_read_u16(target, current_pc, &amp;opcode)) != ERROR_OK)
 		{
 			return retval;
@@ -318,7 +318,7 @@
 			return retval;
 			}
 		instruction_size = 2;
-		
+
 		/* check condition code (only for branch instructions) */
 		if ((!thumb_pass_branch_condition(buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32), opcode)) &amp;&amp;
 			(instruction.type == ARM_B))
@@ -331,33 +331,33 @@
 			{
 				buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, current_pc + instruction_size);
 			}
-			
+
 			return ERROR_OK;
 		}
 	}
-	
+
 	/* examine instruction type */
 
 	/* branch instructions */
 	if ((instruction.type &gt;= ARM_B) &amp;&amp; (instruction.type &lt;= ARM_BLX))
 	{
 		uint32_t target;
-		
+
 		if (instruction.info.b_bl_bx_blx.reg_operand == -1)
 		{
 			target = instruction.info.b_bl_bx_blx.target_address;
 		}
 		else
 		{
-			target = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.b_bl_bx_blx.reg_operand).value, 0, 32); 
+			target = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.b_bl_bx_blx.reg_operand).value, 0, 32);
 			if (instruction.info.b_bl_bx_blx.reg_operand == 15)
 			{
 				target += 2 * instruction_size;
 			}
 		}
-		
+
 		if (dry_run_pc)
-		{	
+		{
 			*dry_run_pc = target;
 			return ERROR_OK;
 		}
@@ -400,7 +400,7 @@
 				}
 				buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, target &amp; 0xfffffffe);
 			}
-			
+
 			return ERROR_OK;
 		}
 	}
@@ -411,7 +411,7 @@
 		uint32_t Rd, Rn, shifter_operand;
 		uint8_t C = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
 		uint8_t carry_out;
-		
+
 		Rd = 0x0;
 		/* ARM_MOV and ARM_MVN does not use Rn */
 		if ((instruction.type != ARM_MOV) &amp;&amp; (instruction.type != ARM_MVN))
@@ -424,7 +424,7 @@
 		/* adjust Rn in case the PC is being read */
 		if (instruction.info.data_proc.Rn == 15)
 			Rn += 2 * instruction_size;
-				
+
 		if (instruction.type == ARM_AND)
 			Rd = Rn &amp; shifter_operand;
 		else if (instruction.type == ARM_EOR)
@@ -451,7 +451,7 @@
 			Rd = ~shifter_operand;
 		else
 			LOG_WARNING(&quot;unhandled instruction type&quot;);
-		
+
 		if (dry_run_pc)
 		{
 			if (instruction.info.data_proc.Rd == 15)
@@ -463,7 +463,7 @@
 			{
 				*dry_run_pc = current_pc + instruction_size;
 			}
-			
+
 			return ERROR_OK;
 		}
 		else
@@ -471,7 +471,7 @@
 			buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.data_proc.Rd).value, 0, 32, Rd);
 			LOG_WARNING(&quot;no updating of flags yet&quot;);
 
-			if (instruction.info.data_proc.Rd == 15)  
+			if (instruction.info.data_proc.Rd == 15)
 				return ERROR_OK;
 		}
 	}
@@ -493,11 +493,11 @@
 	{
 		uint32_t load_address = 0, modified_address = 0, load_value;
 		uint32_t Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.Rn).value, 0, 32);
-		
+
 		/* adjust Rn in case the PC is being read */
 		if (instruction.info.load_store.Rn == 15)
 			Rn += 2 * instruction_size;
-		
+
 		if (instruction.info.load_store.offset_mode == 0)
 		{
 			if (instruction.info.load_store.U)
@@ -512,9 +512,9 @@
 			uint8_t shift = instruction.info.load_store.offset.reg.shift;
 			uint8_t shift_imm = instruction.info.load_store.offset.reg.shift_imm;
 			uint8_t carry = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
-			
+
 			offset = arm_shift(shift, Rm, shift_imm, &amp;carry);
-			
+
 			if (instruction.info.load_store.U)
 				modified_address = Rn + offset;
 			else
@@ -524,7 +524,7 @@
 		{
 			LOG_ERROR(&quot;BUG: offset_mode neither 0 (offset) nor 1 (scaled register)&quot;);
 		}
-		
+
 		if (instruction.info.load_store.index_mode == 0)
 		{
 			/* offset mode
@@ -544,7 +544,7 @@
 			 * we load from the unmodified address, and write the modified address back */
 			 load_address = Rn;
 		}
-		
+
 		if ((!dry_run_pc) || (instruction.info.load_store.Rd == 15))
 		{
 			if ((retval = target_read_u32(target, load_address, &amp;load_value)) != ERROR_OK)
@@ -552,7 +552,7 @@
 				return retval;
 			}
 		}
-		
+
 		if (dry_run_pc)
 		{
 			if (instruction.info.load_store.Rd == 15)
@@ -564,7 +564,7 @@
 			{
 				*dry_run_pc = current_pc + instruction_size;
 			}
-			
+
 			return ERROR_OK;
 		}
 		else
@@ -573,9 +573,9 @@
 				(instruction.info.load_store.index_mode == 2))
 			{
 				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.Rn).value, 0, 32, modified_address);
-			} 
+			}
 			buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.Rd).value, 0, 32, load_value);
-			
+
 			if (instruction.info.load_store.Rd == 15)
 				return ERROR_OK;
 		}
@@ -593,7 +593,7 @@
 			if (instruction.info.load_store_multiple.register_list &amp; (1 &lt;&lt; i))
 				bits_set++;
 		}
-		
+
 		switch (instruction.info.load_store_multiple.addressing_mode)
 		{
 			case 0: /* Increment after */
@@ -603,7 +603,7 @@
 				Rn = Rn + 4;
 				break;
 			case 2: /* Decrement after */
-				Rn = Rn - (bits_set * 4) + 4; 
+				Rn = Rn - (bits_set * 4) + 4;
 				break;
 			case 3: /* Decrement before */
 				Rn = Rn - (bits_set * 4);
@@ -621,7 +621,7 @@
 				Rn += 4;
 			}
 		}
-		
+
 		if (dry_run_pc)
 		{
 			if (instruction.info.load_store_multiple.register_list &amp; 0x8000)
@@ -650,17 +650,17 @@
 					buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, mode, i).value, 0, 32, load_values[i]);
 				}
 			}
-			
+
 			if (update_cpsr)
 			{
 				uint32_t spsr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 16).value, 0, 32);
 				buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32, spsr);
 			}
-			
+
 			/* base register writeback */
 			if (instruction.info.load_store_multiple.W)
-				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32, Rn); 
-			
+				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32, Rn);
+
 			if (instruction.info.load_store_multiple.register_list &amp; 0x8000)
 				return ERROR_OK;
 		}
@@ -685,12 +685,12 @@
 				if (instruction.info.load_store_multiple.register_list &amp; (1 &lt;&lt; i))
 					bits_set++;
 			}
-			
+
 			if (instruction.info.load_store_multiple.S)
 			{
 				mode = ARMV4_5_MODE_USR;
 			}
-			
+
 			switch (instruction.info.load_store_multiple.addressing_mode)
 			{
 				case 0: /* Increment after */
@@ -700,13 +700,13 @@
 					Rn = Rn + 4;
 					break;
 				case 2: /* Decrement after */
-					Rn = Rn - (bits_set * 4) + 4; 
+					Rn = Rn - (bits_set * 4) + 4;
 					break;
 				case 3: /* Decrement before */
 					Rn = Rn - (bits_set * 4);
 					break;
 			}
-			
+
 			for (i = 0; i &lt; 16; i++)
 			{
 				if (instruction.info.load_store_multiple.register_list &amp; (1 &lt;&lt; i))
@@ -715,11 +715,11 @@
 					Rn += 4;
 				}
 			}
-			
+
 			/* base register writeback */
 			if (instruction.info.load_store_multiple.W)
-				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32, Rn); 
-			
+				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32, Rn);
+
 		}
 	}
 	else if (!dry_run_pc)
@@ -728,7 +728,7 @@
 		 */
 		return ERROR_ARM_SIMULATOR_NOT_IMPLEMENTED;
 	}
-	
+
 	if (dry_run_pc)
 	{
 		*dry_run_pc = current_pc + instruction_size;
@@ -739,5 +739,5 @@
 		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, current_pc + instruction_size);
 		return ERROR_OK;
 	}
-	
+
 }

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/armv4_5.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -339,9 +339,9 @@
 			{
 				armv4_5-&gt;full_context(target);
 			}
-			output_len += snprintf(output + output_len, 
-					       128 - output_len, 
-					       &quot;%8s: %8.8&quot; PRIx32 &quot; &quot;, 
+			output_len += snprintf(output + output_len,
+					       128 - output_len,
+					       &quot;%8s: %8.8&quot; PRIx32 &quot; &quot;,
 					       ARMV4_5_CORE_REG_MODENUM(armv4_5-&gt;core_cache, mode, num).name,
 					       buf_get_u32(ARMV4_5_CORE_REG_MODENUM(armv4_5-&gt;core_cache, mode, num).value, 0, 32));
 		}

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/armv7m.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -543,7 +543,7 @@
 {
 	command_t *arm_adi_v5_dap_cmd;
 
-	arm_adi_v5_dap_cmd = register_command(cmd_ctx, NULL, &quot;dap&quot;, NULL, COMMAND_ANY, &quot;cortex dap specific commands&quot;);		
+	arm_adi_v5_dap_cmd = register_command(cmd_ctx, NULL, &quot;dap&quot;, NULL, COMMAND_ANY, &quot;cortex dap specific commands&quot;);
 	register_command(cmd_ctx, arm_adi_v5_dap_cmd, &quot;info&quot;, handle_dap_info_command, COMMAND_EXEC, &quot;Displays dap info for ap [num], default currently selected AP&quot;);
 	register_command(cmd_ctx, arm_adi_v5_dap_cmd, &quot;apsel&quot;, handle_dap_apsel_command, COMMAND_EXEC, &quot;Select a different AP [num] (default 0)&quot;);
 	register_command(cmd_ctx, arm_adi_v5_dap_cmd, &quot;apid&quot;, handle_dap_apid_command, COMMAND_EXEC, &quot;Displays id reg from AP [num], default currently selected AP&quot;);
@@ -710,7 +710,7 @@
 	apsel = swjdp-&gt;apsel;
 	apselsave = swjdp-&gt;apsel;
 	if (argc &gt; 0)
-	{	
+	{
 		apsel = strtoul(args[0], NULL, 0);
 	}
 	if (apselsave != apsel)
@@ -745,7 +745,7 @@
 	apsel = swjdp-&gt;apsel;
 	apselsave = swjdp-&gt;apsel;
 	if (argc &gt; 0)
-	{	
+	{
 		apsel = strtoul(args[0], NULL, 0);
 	}
 
@@ -775,7 +775,7 @@
 
 	apsel = 0;
 	if (argc &gt; 0)
-	{	
+	{
 		apsel = strtoul(args[0], NULL, 0);
 	}
 
@@ -796,7 +796,7 @@
 
 	memaccess_tck = swjdp-&gt;memaccess_tck;
 	if (argc &gt; 0)
-	{	
+	{
 		memaccess_tck = strtoul(args[0], NULL, 0);
 	}
 
@@ -816,10 +816,10 @@
 
 	apsel =  swjdp-&gt;apsel;
 	if (argc &gt; 0)
-	{	
+	{
 		apsel = strtoul(args[0], NULL, 0);
 	}
-	
+
 	retval = dap_info_command(cmd_ctx, swjdp, apsel);
 
 	return retval;

Modified: trunk/src/target/armv7m.h
===================================================================
--- trunk/src/target/armv7m.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/armv7m.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -55,7 +55,7 @@
 extern char *armv7m_exception_string(int number);
 
 /* offsets into armv7m core register cache */
-enum 
+enum
 {
 	ARMV7M_PC = 15,
 	ARMV7M_xPSR = 16,
@@ -78,18 +78,18 @@
 	int exception_number;
 	swjdp_common_t swjdp_info;
 
-	
+
 	/* Direct processor core register read and writes */
 	int (*load_core_reg_u32)(struct target_s *target, enum armv7m_regtype type, uint32_t num, uint32_t *value);
 	int (*store_core_reg_u32)(struct target_s *target, enum armv7m_regtype type, uint32_t num, uint32_t value);
 	/* register cache to processor synchronization */
 	int (*read_core_reg)(struct target_s *target, int num);
 	int (*write_core_reg)(struct target_s *target, int num);
-	
+
 	int (*examine_debug_reason)(target_t *target);
 	void (*pre_debug_entry)(target_t *target);
 	void (*post_debug_entry)(target_t *target);
-	
+
 	void (*pre_restore_context)(target_t *target);
 	void (*post_restore_context)(target_t *target);
 
@@ -99,7 +99,7 @@
 typedef struct armv7m_algorithm_s
 {
 	int common_magic;
-	
+
 	enum armv7m_mode core_mode;
 } armv7m_algorithm_t;
 
@@ -133,28 +133,28 @@
 
 /* Thumb mode instructions
  */
- 
+
 /* Move to Register from Special Register  (Thumb mode) 32 bit Thumb2 instruction
  * Rd: destination register
  * SYSm: source special register
  */
-#define ARMV7M_T_MRS(Rd, SYSm)	((0xF3EF) | ((0x8000 | (Rd &lt;&lt; 8) | SYSm) &lt;&lt; 16)) 
+#define ARMV7M_T_MRS(Rd, SYSm)	((0xF3EF) | ((0x8000 | (Rd &lt;&lt; 8) | SYSm) &lt;&lt; 16))
 
 /* Move from Register from Special Register  (Thumb mode) 32 bit Thumb2 instruction
  * Rd: source register
  * SYSm: destination special register
  */
-#define ARMV7M_T_MSR(SYSm, Rn)	((0xF380 | (Rn &lt;&lt; 8)) | ((0x8800 | SYSm) &lt;&lt; 16)) 
+#define ARMV7M_T_MSR(SYSm, Rn)	((0xF380 | (Rn &lt;&lt; 8)) | ((0x8800 | SYSm) &lt;&lt; 16))
 
-/* Change Processor State. The instruction modifies the PRIMASK and FAULTMASK 
+/* Change Processor State. The instruction modifies the PRIMASK and FAULTMASK
  * special-purpose register values  (Thumb mode) 16 bit Thumb2 instruction
  * Rd: source register
- * IF: 
+ * IF:
  */
 #define I_FLAG 2
-#define F_FLAG 1  
-#define ARMV7M_T_CPSID(IF)	((0xB660 | (1 &lt;&lt; 8) | (IF&amp;0x3)) | ((0xB660 | (1 &lt;&lt; 8) | (IF&amp;0x3)) &lt;&lt; 16)) 
-#define ARMV7M_T_CPSIE(IF)	((0xB660 | (0 &lt;&lt; 8) | (IF&amp;0x3)) | ((0xB660 | (0 &lt;&lt; 8) | (IF&amp;0x3)) &lt;&lt; 16)) 
+#define F_FLAG 1
+#define ARMV7M_T_CPSID(IF)	((0xB660 | (1 &lt;&lt; 8) | (IF&amp;0x3)) | ((0xB660 | (1 &lt;&lt; 8) | (IF&amp;0x3)) &lt;&lt; 16))
+#define ARMV7M_T_CPSIE(IF)	((0xB660 | (0 &lt;&lt; 8) | (IF&amp;0x3)) | ((0xB660 | (0 &lt;&lt; 8) | (IF&amp;0x3)) &lt;&lt; 16))
 
 /* Breakpoint (Thumb mode) v5 onwards
  * Im: immediate value used by debugger
@@ -178,12 +178,12 @@
  * List: for each bit in list: store register
  */
 #define ARMV7M_T_LDMIA(Rn, List) ((0xc800 | (Rn &lt;&lt; 8) | List) | ((0xc800 | (Rn &lt;&lt; 8) | List) &lt;&lt; 16))
- 
+
 /* Load register with PC relative addressing
  * Rd: register to load
  */
-#define ARMV7M_T_LDR_PCREL(Rd)	((0x4800 | (Rd &lt;&lt; 8)) | ((0x4800 | (Rd &lt;&lt; 8)) &lt;&lt; 16)) 
- 
+#define ARMV7M_T_LDR_PCREL(Rd)	((0x4800 | (Rd &lt;&lt; 8)) | ((0x4800 | (Rd &lt;&lt; 8)) &lt;&lt; 16))
+
 /* Move hi register (Thumb mode)
  * Rd: destination register
  * Rm: source register

Modified: trunk/src/target/breakpoints.c
===================================================================
--- trunk/src/target/breakpoints.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/breakpoints.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -44,7 +44,7 @@
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 	breakpoint_t **breakpoint_p = &amp;target-&gt;breakpoints;
 	int retval;
-	
+
 	while (breakpoint)
 	{
 		if (breakpoint-&gt;address == address)
@@ -52,7 +52,7 @@
 		breakpoint_p = &amp;breakpoint-&gt;next;
 		breakpoint = breakpoint-&gt;next;
 	}
-		
+
 	(*breakpoint_p) = malloc(sizeof(breakpoint_t));
 	(*breakpoint_p)-&gt;address = address;
 	(*breakpoint_p)-&gt;length = length;
@@ -60,7 +60,7 @@
 	(*breakpoint_p)-&gt;set = 0;
 	(*breakpoint_p)-&gt;orig_instr = malloc(length);
 	(*breakpoint_p)-&gt;next = NULL;
-	
+
 	if ((retval = target_add_breakpoint(target, *breakpoint_p)) != ERROR_OK)
 	{
 		switch (retval)
@@ -83,11 +83,11 @@
 				break;
 		}
 	}
-	
-	LOG_DEBUG(&quot;added %s breakpoint at 0x%8.8&quot; PRIx32 &quot; of length 0x%8.8x&quot;, 
+
+	LOG_DEBUG(&quot;added %s breakpoint at 0x%8.8&quot; PRIx32 &quot; of length 0x%8.8x&quot;,
 		breakpoint_type_strings[(*breakpoint_p)-&gt;type],
 		(*breakpoint_p)-&gt;address, (*breakpoint_p)-&gt;length);
-	
+
 	return ERROR_OK;
 }
 
@@ -96,7 +96,7 @@
 {
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 	breakpoint_t **breakpoint_p = &amp;target-&gt;breakpoints;
-	
+
 	while (breakpoint)
 	{
 		if (breakpoint == breakpoint_remove)
@@ -104,12 +104,12 @@
 		breakpoint_p = &amp;breakpoint-&gt;next;
 		breakpoint = breakpoint-&gt;next;
 	}
-	
+
 	if (breakpoint == NULL)
 		return;
-	
+
 	target_remove_breakpoint(target, breakpoint);
-	
+
 	(*breakpoint_p) = breakpoint-&gt;next;
 	free(breakpoint-&gt;orig_instr);
 	free(breakpoint);
@@ -119,7 +119,7 @@
 {
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
 	breakpoint_t **breakpoint_p = &amp;target-&gt;breakpoints;
-	
+
 	while (breakpoint)
 	{
 		if (breakpoint-&gt;address == address)
@@ -127,7 +127,7 @@
 		breakpoint_p = &amp;breakpoint-&gt;next;
 		breakpoint = breakpoint-&gt;next;
 	}
-	
+
 	if (breakpoint)
 	{
 		breakpoint_free(target, breakpoint);
@@ -150,14 +150,14 @@
 breakpoint_t* breakpoint_find(target_t *target, uint32_t address)
 {
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
-	
+
 	while (breakpoint)
 	{
 		if (breakpoint-&gt;address == address)
 			return breakpoint;
 		breakpoint = breakpoint-&gt;next;
 	}
-	
+
 	return NULL;
 }
 
@@ -166,7 +166,7 @@
 	watchpoint_t *watchpoint = target-&gt;watchpoints;
 	watchpoint_t **watchpoint_p = &amp;target-&gt;watchpoints;
 	int retval;
-		
+
 	while (watchpoint)
 	{
 		if (watchpoint-&gt;address == address)
@@ -174,7 +174,7 @@
 		watchpoint_p = &amp;watchpoint-&gt;next;
 		watchpoint = watchpoint-&gt;next;
 	}
-	
+
 	(*watchpoint_p) = malloc(sizeof(watchpoint_t));
 	(*watchpoint_p)-&gt;address = address;
 	(*watchpoint_p)-&gt;length = length;
@@ -183,7 +183,7 @@
 	(*watchpoint_p)-&gt;rw = rw;
 	(*watchpoint_p)-&gt;set = 0;
 	(*watchpoint_p)-&gt;next = NULL;
-		
+
 	if ((retval = target_add_watchpoint(target, *watchpoint_p)) != ERROR_OK)
 	{
 		switch (retval)
@@ -206,11 +206,11 @@
 				break;
 		}
 	}
-	
+
 	LOG_DEBUG(&quot;added %s watchpoint at 0x%8.8&quot; PRIx32 &quot; of length 0x%8.8x&quot;,
 		watchpoint_rw_strings[(*watchpoint_p)-&gt;rw],
 		(*watchpoint_p)-&gt;address, (*watchpoint_p)-&gt;length);
-	
+
 	return ERROR_OK;
 }
 
@@ -226,7 +226,7 @@
 		watchpoint_p = &amp;watchpoint-&gt;next;
 		watchpoint = watchpoint-&gt;next;
 	}
-	
+
 	if (watchpoint == NULL)
 		return;
 	target_remove_watchpoint(target, watchpoint);
@@ -238,7 +238,7 @@
 {
 	watchpoint_t *watchpoint = target-&gt;watchpoints;
 	watchpoint_t **watchpoint_p = &amp;target-&gt;watchpoints;
-	
+
 	while (watchpoint)
 	{
 		if (watchpoint-&gt;address == address)
@@ -246,7 +246,7 @@
 		watchpoint_p = &amp;watchpoint-&gt;next;
 		watchpoint = watchpoint-&gt;next;
 	}
-	
+
 	if (watchpoint)
 	{
 		watchpoint_free(target, watchpoint);

Modified: trunk/src/target/cortex_m3.h
===================================================================
--- trunk/src/target/cortex_m3.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/cortex_m3.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -44,7 +44,7 @@
 #define DCB_DCRDR	0xE000EDF8
 #define DCB_DEMCR	0xE000EDFC
 
-#define DCRSR_WnR	(1 &lt;&lt; 16)	
+#define DCRSR_WnR	(1 &lt;&lt; 16)
 
 #define DWT_CTRL	0xE0001000
 #define DWT_COMP0	0xE0001020
@@ -138,12 +138,12 @@
 {
 	int common_magic;
 	arm_jtag_t jtag_info;
-	
+
 	/* Context information */
 	uint32_t dcb_dhcsr;
 	uint32_t nvic_dfsr;  /* Debug Fault Status Register - shows reason for debug halt */
 	uint32_t nvic_icsr;  /* Interrupt Control State Register - shows active and pending IRQ */
-	
+
 	/* Flash Patch and Breakpoint (FPB) */
 	int fp_num_lit;
 	int fp_num_code;
@@ -151,16 +151,16 @@
 	int fpb_enabled;
 	int auto_bp_type;
 	cortex_m3_fp_comparator_t *fp_comparator_list;
-	
+
 	/* Data Watchpoint and Trace (DWT) */
 	int dwt_num_comp;
 	int dwt_comp_available;
 	cortex_m3_dwt_comparator_t *dwt_comparator_list;
-	
+
 	/* Interrupts */
 	int intlinesnum;
 	uint32_t *intsetenable;
-	
+
 	armv7m_common_t armv7m;
 //	swjdp_common_t swjdp_info;
 	void *arch_info;

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/feroceon.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -132,33 +132,33 @@
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
-	
+
 	fields[0].in_value = NULL;
-	
-	
-	
-	
 
+
+
+
+
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = &amp;sysspeed_buf;
-	
+
 	fields[1].in_value = NULL;
-	
-	
-	
-	
 
+
+
+
+
 	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = instr_buf;
-	
+
 	fields[2].in_value = NULL;
-	
-	
-	
-	
 
+
+
+
+
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
 	/* no jtag_add_runtest(0, jtag_get_end_state()) here */

Modified: trunk/src/target/mips32.c
===================================================================
--- trunk/src/target/mips32.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/mips32.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -38,7 +38,7 @@
 	&quot;status&quot;, &quot;lo&quot;, &quot;hi&quot;, &quot;badvaddr&quot;, &quot;cause&quot;, &quot;pc&quot;
 };
 
-mips32_core_reg_t mips32_core_reg_list_arch_info[MIPS32NUMCOREREGS] = 
+mips32_core_reg_t mips32_core_reg_list_arch_info[MIPS32NUMCOREREGS] =
 {
 	{0, NULL, NULL},
 	{1, NULL, NULL},
@@ -72,7 +72,7 @@
 	{29, NULL, NULL},
 	{30, NULL, NULL},
 	{31, NULL, NULL},
-	
+
 	{32, NULL, NULL},
 	{33, NULL, NULL},
 	{34, NULL, NULL},
@@ -101,14 +101,14 @@
 	mips32_core_reg_t *mips32_reg = reg-&gt;arch_info;
 	target_t *target = mips32_reg-&gt;target;
 	mips32_common_t *mips32_target = target-&gt;arch_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
 	retval = mips32_target-&gt;read_core_reg(target, mips32_reg-&gt;num);
-	
+
 	return retval;
 }
 
@@ -117,12 +117,12 @@
 	mips32_core_reg_t *mips32_reg = reg-&gt;arch_info;
 	target_t *target = mips32_reg-&gt;target;
 	uint32_t value = buf_get_u32(buf, 0, 32);
-		
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		return ERROR_TARGET_NOT_HALTED;
 	}
-		
+
 	buf_set_u32(reg-&gt;value, 0, 32, value);
 	reg-&gt;dirty = 1;
 	reg-&gt;valid = 1;
@@ -134,10 +134,10 @@
 {
 	uint32_t reg_value;
 	mips32_core_reg_t *mips_core_reg;
-	
+
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
-		
+
 	if ((num &lt; 0) || (num &gt;= MIPS32NUMCOREREGS))
 		return ERROR_INVALID_ARGUMENTS;
 
@@ -146,28 +146,28 @@
 	buf_set_u32(mips32-&gt;core_cache-&gt;reg_list[num].value, 0, 32, reg_value);
 	mips32-&gt;core_cache-&gt;reg_list[num].valid = 1;
 	mips32-&gt;core_cache-&gt;reg_list[num].dirty = 0;
-	
-	return ERROR_OK;	
+
+	return ERROR_OK;
 }
 
 int mips32_write_core_reg(struct target_s *target, int num)
 {
 	uint32_t reg_value;
 	mips32_core_reg_t *mips_core_reg;
-	
+
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
 
 	if ((num &lt; 0) || (num &gt;= MIPS32NUMCOREREGS))
 		return ERROR_INVALID_ARGUMENTS;
-	
+
 	reg_value = buf_get_u32(mips32-&gt;core_cache-&gt;reg_list[num].value, 0, 32);
 	mips_core_reg = mips32-&gt;core_cache-&gt;reg_list[num].arch_info;
 	mips32-&gt;core_regs[num] = reg_value;
 	LOG_DEBUG(&quot;write core reg %i value 0x%&quot; PRIx32 &quot;&quot;, num , reg_value);
 	mips32-&gt;core_cache-&gt;reg_list[num].valid = 1;
 	mips32-&gt;core_cache-&gt;reg_list[num].dirty = 0;
-	
+
 	return ERROR_OK;
 }
 
@@ -176,13 +176,13 @@
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	int i;
-	
+
 	for (i = 0; i &lt; mips32-&gt;core_cache-&gt;num_regs; i++)
 	{
 		mips32-&gt;core_cache-&gt;reg_list[i].valid = 0;
 		mips32-&gt;core_cache-&gt;reg_list[i].dirty = 0;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -191,16 +191,16 @@
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	int i;
-	
+
 	/* include floating point registers */
 	*reg_list_size = MIPS32NUMCOREREGS + MIPS32NUMFPREGS;
 	*reg_list = malloc(sizeof(reg_t*) * (*reg_list_size));
-	
+
 	for (i = 0; i &lt; MIPS32NUMCOREREGS; i++)
 	{
 		(*reg_list)[i] = &amp;mips32-&gt;core_cache-&gt;reg_list[i];
 	}
-	
+
 	/* add dummy floating points regs */
 	for (i = MIPS32NUMCOREREGS; i &lt; (MIPS32NUMCOREREGS + MIPS32NUMFPREGS); i++)
 	{
@@ -213,14 +213,14 @@
 int mips32_save_context(target_t *target)
 {
 	int i;
-	
+
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	
+
 	/* read core registers */
 	mips32_pracc_read_regs(ejtag_info, mips32-&gt;core_regs);
-	
+
 	for (i = 0; i &lt; MIPS32NUMCOREREGS; i++)
 	{
 		if (!mips32-&gt;core_cache-&gt;reg_list[i].valid)
@@ -228,18 +228,18 @@
 			mips32-&gt;read_core_reg(target, i);
 		}
 	}
-	
-	return ERROR_OK;		
+
+	return ERROR_OK;
 }
 
 int mips32_restore_context(target_t *target)
 {
 	int i;
-	
+
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	
+
 	for (i = 0; i &lt; MIPS32NUMCOREREGS; i++)
 	{
 		if (mips32-&gt;core_cache-&gt;reg_list[i].dirty)
@@ -247,27 +247,27 @@
 			mips32-&gt;write_core_reg(target, i);
 		}
 	}
-	
+
 	/* write core regs */
 	mips32_pracc_write_regs(ejtag_info, mips32-&gt;core_regs);
-	
-	return ERROR_OK;		
+
+	return ERROR_OK;
 }
 
 int mips32_arch_state(struct target_s *target)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
-	
+
 	if (mips32-&gt;common_magic != MIPS32_COMMON_MAGIC)
 	{
 		LOG_ERROR(&quot;BUG: called for a non-MIPS32 target&quot;);
 		exit(-1);
 	}
-	
+
 	LOG_USER(&quot;target halted due to %s, pc: 0x%8.8&quot; PRIx32 &quot;&quot;,
 		Jim_Nvp_value2name_simple(nvp_target_debug_reason, target-&gt;debug_reason)-&gt;name ,
 		buf_get_u32(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value, 0, 32));
-	
+
 	return ERROR_OK;
 }
 
@@ -282,20 +282,20 @@
 	reg_t *reg_list = malloc(sizeof(reg_t) * num_regs);
 	mips32_core_reg_t *arch_info = malloc(sizeof(mips32_core_reg_t) * num_regs);
 	int i;
-	
+
 	if (mips32_core_reg_arch_type == -1)
 		mips32_core_reg_arch_type = register_reg_arch_type(mips32_get_core_reg, mips32_set_core_reg);
 
 	register_init_dummy(&amp;mips32_gdb_dummy_fp_reg);
 
-	/* Build the process context cache */ 
+	/* Build the process context cache */
 	cache-&gt;name = &quot;mips32 registers&quot;;
 	cache-&gt;next = NULL;
 	cache-&gt;reg_list = reg_list;
 	cache-&gt;num_regs = num_regs;
 	(*cache_p) = cache;
 	mips32-&gt;core_cache = cache;
-	
+
 	for (i = 0; i &lt; num_regs; i++)
 	{
 		arch_info[i] = mips32_core_reg_list_arch_info[i];
@@ -311,7 +311,7 @@
 		reg_list[i].arch_type = mips32_core_reg_arch_type;
 		reg_list[i].arch_info = &amp;arch_info[i];
 	}
-	
+
 	return cache;
 }
 
@@ -319,15 +319,15 @@
 {
 	target-&gt;arch_info = mips32;
 	mips32-&gt;common_magic = MIPS32_COMMON_MAGIC;
-	
+
 	/* has breakpoint/watchpint unit been scanned */
 	mips32-&gt;bp_scanned = 0;
 	mips32-&gt;data_break_list = NULL;
-	
+
 	mips32-&gt;ejtag_info.tap = tap;
 	mips32-&gt;read_core_reg = mips32_read_core_reg;
 	mips32-&gt;write_core_reg = mips32_write_core_reg;
-	
+
 	return ERROR_OK;
 }
 
@@ -345,11 +345,11 @@
 int mips32_examine(struct target_s *target)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
-	
+
 	if (!target_was_examined(target))
 	{
 		target_set_examined(target);
-	
+
 		/* we will configure later */
 		mips32-&gt;bp_scanned = 0;
 		mips32-&gt;num_inst_bpoints = 0;
@@ -357,7 +357,7 @@
 		mips32-&gt;num_inst_bpoints_avail = 0;
 		mips32-&gt;num_data_bpoints_avail = 0;
 	}
-		
+
 	return ERROR_OK;
 }
 
@@ -368,20 +368,20 @@
 	int retval;
 	uint32_t dcr, bpinfo;
 	int i;
-	
+
 	if (mips32-&gt;bp_scanned)
 		return ERROR_OK;
-	
+
 	/* get info about breakpoint support */
 	if ((retval = target_read_u32(target, EJTAG_DCR, &amp;dcr)) != ERROR_OK)
 		return retval;
-	
+
 	if (dcr &amp; (1 &lt;&lt; 16))
 	{
 		/* get number of inst breakpoints */
 		if ((retval = target_read_u32(target, EJTAG_IBS, &amp;bpinfo)) != ERROR_OK)
 			return retval;
-		
+
 		mips32-&gt;num_inst_bpoints = (bpinfo &gt;&gt; 24) &amp; 0x0F;
 		mips32-&gt;num_inst_bpoints_avail = mips32-&gt;num_inst_bpoints;
 		mips32-&gt;inst_break_list = calloc(mips32-&gt;num_inst_bpoints, sizeof(mips32_comparator_t));
@@ -389,18 +389,18 @@
 		{
 			mips32-&gt;inst_break_list[i].reg_address = EJTAG_IBA1 + (0x100 * i);
 		}
-		
+
 		/* clear IBIS reg */
 		if ((retval = target_write_u32(target, EJTAG_IBS, 0)) != ERROR_OK)
 			return retval;
 	}
-	
+
 	if (dcr &amp; (1 &lt;&lt; 17))
 	{
 		/* get number of data breakpoints */
 		if ((retval = target_read_u32(target, EJTAG_DBS, &amp;bpinfo)) != ERROR_OK)
 			return retval;
-		
+
 		mips32-&gt;num_data_bpoints = (bpinfo &gt;&gt; 24) &amp; 0x0F;
 		mips32-&gt;num_data_bpoints_avail = mips32-&gt;num_data_bpoints;
 		mips32-&gt;data_break_list = calloc(mips32-&gt;num_data_bpoints, sizeof(mips32_comparator_t));
@@ -408,16 +408,16 @@
 		{
 			mips32-&gt;data_break_list[i].reg_address = EJTAG_DBA1 + (0x100 * i);
 		}
-		
+
 		/* clear DBIS reg */
 		if ((retval = target_write_u32(target, EJTAG_DBS, 0)) != ERROR_OK)
 			return retval;
 	}
-	
+
 	LOG_DEBUG(&quot;DCR 0x%&quot; PRIx32 &quot; numinst %i numdata %i&quot;, dcr, mips32-&gt;num_inst_bpoints, mips32-&gt;num_data_bpoints);
-	
+
 	mips32-&gt;bp_scanned = 1;
-	
+
 	return ERROR_OK;
 }
 
@@ -426,11 +426,11 @@
 	int retval;
 	int update = 0;
 	uint32_t dcr;
-	
+
 	/* read debug control register */
 	if ((retval = target_read_u32(target, EJTAG_DCR, &amp;dcr)) != ERROR_OK)
 		return retval;
-	
+
 	if (enable)
 	{
 		if (!(dcr &amp; (1 &lt;&lt; 4)))
@@ -449,12 +449,12 @@
 			update = 1;
 		}
 	}
-	
+
 	if (update)
 	{
 		if ((retval = target_write_u32(target, EJTAG_DCR, dcr)) != ERROR_OK)
 			return retval;
 	}
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/target/mips32.h
===================================================================
--- trunk/src/target/mips32.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/mips32.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -31,7 +31,7 @@
 #define MIPS32_COMMON_MAGIC		0xB320B320
 
 /* offsets into mips32 core register cache */
-enum 
+enum
 {
 	MIPS32_PC = 37,
 	MIPS32NUMCOREREGS
@@ -52,7 +52,7 @@
 	reg_cache_t *core_cache;
 	mips_ejtag_t ejtag_info;
 	uint32_t core_regs[MIPS32NUMCOREREGS];
-	
+
 	int bp_scanned;
 	int num_inst_bpoints;
 	int num_data_bpoints;
@@ -60,7 +60,7 @@
 	int num_data_bpoints_avail;
 	mips32_comparator_t *inst_break_list;
 	mips32_comparator_t *data_break_list;
-	
+
 	/* register cache to processor synchronization */
 	int (*read_core_reg)(struct target_s *target, int num);
 	int (*write_core_reg)(struct target_s *target, int num);

Modified: trunk/src/target/mips32_dmaacc.c
===================================================================
--- trunk/src/target/mips32_dmaacc.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/mips32_dmaacc.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -191,7 +191,7 @@
 		case 2:
 			*data = (v &gt;&gt; 16) &amp; 0xff;
 			break;
-		case 3: 
+		case 3:
 			*data = (v &gt;&gt; 24) &amp; 0xff;
 			break;
 	}

Modified: trunk/src/target/mips32_pracc.c
===================================================================
--- trunk/src/target/mips32_pracc.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/mips32_pracc.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -26,7 +26,7 @@
 - write word
 - write array of words
 
-One thing to be aware of is that the MIPS32 cpu will execute the 
+One thing to be aware of is that the MIPS32 cpu will execute the
 instruction after a branch instruction (one delay slot).
 
 For example:
@@ -36,7 +36,7 @@
     B foo
     LW $1, ($2 +100)
 
-The LW $1, ($2 +100) instruction is also executed. If this is 
+The LW $1, ($2 +100) instruction is also executed. If this is
 not wanted a NOP can be inserted:
 
     LW $2, ($5 +10)
@@ -92,8 +92,8 @@
 static int wait_for_pracc_rw(mips_ejtag_t *ejtag_info, uint32_t *ctrl)
 {
 	uint32_t ejtag_ctrl;
-	
-	while (1) 
+
+	while (1)
 	{
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
 		ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl;
@@ -103,7 +103,7 @@
 		LOG_DEBUG(&quot;DEBUGMODULE: No memory access in progress!\n&quot;);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
-	
+
 	*ctrl = ejtag_ctrl;
 	return ERROR_OK;
 }
@@ -141,12 +141,12 @@
 	{
 		/* TODO: send JMP 0xFF200000 instruction. Hopefully processor jump back
 		 * to start of debug vector */
-		
+
 		data = 0;
 		LOG_ERROR(&quot;Error reading unexpected address %8.8&quot; PRIx32 &quot;&quot;, address);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
-	
+
 	/* Send the data out */
 	mips_ejtag_set_instr(ctx-&gt;ejtag_info, EJTAG_INST_DATA, NULL);
 	mips_ejtag_drscan_32(ctx-&gt;ejtag_info, &amp;data);
@@ -159,8 +159,8 @@
 
 	jtag_add_clocks(5);
 	jtag_execute_queue();
-	
 
+
 	return ERROR_OK;
 }
 
@@ -172,7 +172,7 @@
 
 	mips_ejtag_set_instr(ctx-&gt;ejtag_info, EJTAG_INST_DATA, NULL);
 	mips_ejtag_drscan_32(ctx-&gt;ejtag_info, &amp;data);
-	
+
 	/* Clear access pending bit */
 	ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl &amp; ~EJTAG_CTRL_PRACC;
 	mips_ejtag_set_instr(ctx-&gt;ejtag_info, EJTAG_INST_CONTROL, NULL);
@@ -180,7 +180,7 @@
 
 	jtag_add_clocks(5);
 	jtag_execute_queue();
-	
+
 	if ((address &gt;= MIPS32_PRACC_PARAM_IN)
 		&amp;&amp; (address &lt;= MIPS32_PRACC_PARAM_IN + ctx-&gt;num_iparam * 4))
 	{
@@ -203,7 +203,7 @@
 		LOG_ERROR(&quot;Error writing unexpected address %8.8&quot; PRIx32 &quot;&quot;, address);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -214,7 +214,7 @@
 	mips32_pracc_context ctx;
 	int retval;
 	int pass = 0;
-	
+
 	ctx.local_iparam = param_in;
 	ctx.local_oparam = param_out;
 	ctx.num_iparam = num_param_in;
@@ -223,18 +223,18 @@
 	ctx.code_len = code_len;
 	ctx.ejtag_info = ejtag_info;
 	ctx.stack_offset = 0;
-	
+
 	while (1)
 	{
 		if ((retval = wait_for_pracc_rw(ejtag_info, &amp;ejtag_ctrl)) != ERROR_OK)
 			return retval;
-		
+
 		address = data = 0;
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_ADDRESS, NULL);
 		mips_ejtag_drscan_32(ejtag_info, &amp;address);
 
 //		printf(&quot;Adres: %.8x\n&quot;, address);
-		
+
 		/* Check for read or write */
 		if (ejtag_ctrl &amp; EJTAG_CTRL_PRNW)
 		{
@@ -250,22 +250,22 @@
 			{
 				break;
 			}
-			
+
 			if ((retval = mips32_pracc_exec_read(&amp;ctx, address)) != ERROR_OK)
 				return retval;
 
 		}
-		
+
 		if (cycle == 0)
 			break;
 	}
-	
+
 	/* stack sanity check */
 	if (ctx.stack_offset != 0)
 	{
 		LOG_DEBUG(&quot;Pracc Stack not zero&quot;);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -283,12 +283,12 @@
 			else
 				return mips32_pracc_read_mem32(ejtag_info, addr, count, (uint32_t*)buf);
 	}
-	
+
 	return ERROR_OK;
 }
 
 int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, uint32_t addr, int count, uint32_t *buf)
-{	
+{
 	uint32_t code[] = {
 															/* start: */
 		MIPS32_MTC0(15,31,0),								/* move $15 to COP0 DeSave */
@@ -298,7 +298,7 @@
 		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
 		MIPS32_SW(10,0,15), 								/* sw $10,($15) */
 		MIPS32_SW(11,0,15), 								/* sw $11,($15) */
-			
+
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8),									/* $9 = mem[$8]; read addr */
@@ -309,14 +309,14 @@
 															/* loop: */
 		MIPS32_BEQ(0,10,9),									/* beq 0, $10, end */
 		MIPS32_NOP,
-		
+
 		MIPS32_LW(8,0,9), 									/* lw $8,0($9), Load $8 with the word @mem[$9] */
 		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
-		
+
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,4), 								/* $1 += 4 */
 		MIPS32_ADDI(11,11,4), 								/* $11 += 4 */
-		
+
 		MIPS32_NOP,
 		MIPS32_B(NEG16(9)),									/* b loop */
 		MIPS32_NOP,
@@ -330,29 +330,29 @@
 		MIPS32_B(NEG16(31)),								/* b start */
 		MIPS32_NOP,
 	};
-	
+
 	int retval = ERROR_OK;
 	int blocksize;
 	int bytesread;
 	uint32_t param_in[2];
-	
+
 	bytesread = 0;
-	
+
 	while (count &gt; 0)
-	{	
+	{
 		blocksize = count;
 		if (count &gt; 0x400)
 			blocksize = 0x400;
-		
+
 		param_in[0] = addr;
 		param_in[1] = blocksize;
-		
-		if ((retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, 
+
+		if ((retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code,
 			sizeof(param_in)/sizeof(param_in[0]), param_in, blocksize, &amp;buf[bytesread], 1)) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		count -= blocksize;
 		addr += blocksize;
 		bytesread += blocksize;
@@ -386,7 +386,7 @@
 
 	param_in[0] = addr;
 
-	if ((retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, 
+	if ((retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code,
 		sizeof(param_in)/sizeof(param_in[0]), param_in, sizeof(uint32_t), buf, 1)) != ERROR_OK)
 	{
 		return retval;
@@ -406,7 +406,7 @@
 		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
 		MIPS32_SW(10,0,15), 								/* sw $10,($15) */
 		MIPS32_SW(11,0,15), 								/* sw $11,($15) */
-			
+
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8),									/* $9 = mem[$8]; read addr */
@@ -417,10 +417,10 @@
 															/* loop: */
 		MIPS32_BEQ(0,10,9), 								/* beq 0, $10, end */
 		MIPS32_NOP,
-		
+
 		MIPS32_LHU(8,0,9), 									/* lw $8,0($9), Load $8 with the halfword @mem[$9] */
 		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
-		
+
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,2), 								/* $9 += 2 */
 		MIPS32_ADDI(11,11,4), 								/* $11 += 4 */
@@ -441,36 +441,36 @@
 //	/* TODO remove array */
 	uint32_t param_out[count];
 	int i;
-	
+
 //	int retval;
 	int blocksize;
 	int bytesread;
 	uint32_t param_in[2];
-	
+
 	bytesread = 0;
-	
+
 	//while (count &gt; 0)
-	{	
+	{
 		blocksize = count;
 		if (count &gt; 0x400)
 			blocksize = 0x400;
-		
+
 		param_in[0] = addr;
 		param_in[1] = blocksize;
-		
+
 		mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 			sizeof(param_in)/sizeof(param_in[0]), param_in, count, param_out, 1);
-		
+
 //		count -= blocksize;
 //		addr += blocksize;
 //		bytesread += blocksize;
 	}
-	
+
 	for (i = 0; i &lt; count; i++)
 	{
 		buf[i] = param_out[i];
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -485,7 +485,7 @@
 		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
 		MIPS32_SW(10,0,15), 								/* sw $10,($15) */
 		MIPS32_SW(11,0,15), 								/* sw $11,($15) */
-			
+
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)), 		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8), 									/* $9 = mem[$8]; read addr */
@@ -496,10 +496,10 @@
 															/* loop: */
 		MIPS32_BEQ(0,10,9), 								/* beq 0, $10, end */
 		MIPS32_NOP,
-		
+
 		MIPS32_LBU(8,0,9), 									/* lw $8,0($9), Load t4 with the byte @mem[t1] */
 		MIPS32_SW(8,0,11), 									/* sw $8,0($11) */
-		
+
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,1), 								/* $9 += 1 */
 		MIPS32_ADDI(11,11,4), 								/* $11 += 4 */
@@ -516,35 +516,35 @@
 		MIPS32_B(NEG16(31)),								/* b start */
 		MIPS32_NOP,
 	};
-	
+
 //	/* TODO remove array */
 	uint32_t param_out[count];
 	int i;
-	
+
 //	int retval;
 	int blocksize;
 	int bytesread;
 	uint32_t param_in[2];
-	
+
 	bytesread = 0;
-	
+
 //	while (count &gt; 0)
-	{	
+	{
 		blocksize = count;
 		if (count &gt; 0x400)
 			blocksize = 0x400;
-		
+
 		param_in[0] = addr;
 		param_in[1] = blocksize;
-		
+
 		mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 			sizeof(param_in)/sizeof(param_in[0]), param_in, count, param_out, 1);
-		
+
 //		count -= blocksize;
 //		addr += blocksize;
 //		bytesread += blocksize;
 	}
-	
+
 	for (i = 0; i &lt; count; i++)
 	{
 		buf[i] = param_out[i];
@@ -567,7 +567,7 @@
 			else
 				return mips32_pracc_write_mem32(ejtag_info, addr, count, (uint32_t*)buf);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -584,7 +584,7 @@
 		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
 		MIPS32_SW(10,0,15), 								/* sw $10,($15) */
 		MIPS32_SW(11,0,15), 								/* sw $11,($15) */
-		
+
 		MIPS32_ADDI(8,15,NEG16(MIPS32_PRACC_STACK-MIPS32_PRACC_PARAM_IN)),  //$8= MIPS32_PRACC_PARAM_IN
 		MIPS32_LW(9,0,8), 									/* Load write addr to $9 */
 		MIPS32_LW(10,4,8),	//last address 									/* Load write count to $10 */
@@ -593,7 +593,7 @@
 //loop:
 		MIPS32_LW(11,0,8), 									/* lw $11,0($8), Load $11 with the word @mem[$8] */
 		MIPS32_SW(11,0,9), 									/* sw $11,0($9) */
-		
+
 		MIPS32_ADDI(9,9,4), 								/* $9 += 4 */
 		MIPS32_BNE(10,9,NEG16(4)),  //was 9 BNE $10, 9, loop									/* b loop */
 		MIPS32_ADDI(8,8,4),  //this instruction is part of the loop (one delay slot)!	/* $8 += 4 */
@@ -606,14 +606,14 @@
 		MIPS32_MFC0(15,31,0),								/* move COP0 DeSave to $15 */
 		MIPS32_NOP, //this one will not be executed
 	};
-	
+
 	/* TODO remove array */
 	uint32_t param_in[count + 2];
 	param_in[0] = addr;
 	param_in[1] = addr + count * sizeof(uint32_t);	//last address
-    
+
 	memcpy(&amp;param_in[2], buf, count * sizeof(uint32_t));
-	
+
 	mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 		sizeof(param_in)/sizeof(param_in[0]),param_in, 0, NULL, 1);
 
@@ -629,7 +629,7 @@
 		MIPS32_ORI(15,15,LOWER16(MIPS32_PRACC_STACK)),
 		MIPS32_SW(8,0,15), 									/* sw $8,($15) */
 		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
-	
+
 		MIPS32_LW(8,NEG16((MIPS32_PRACC_STACK-MIPS32_PRACC_PARAM_IN)-4), 15),  //load R8 @ param_in[1] = data
 		MIPS32_LW(9,NEG16(MIPS32_PRACC_STACK-MIPS32_PRACC_PARAM_IN), 15),  //load R9 @ param_in[0] = address
 
@@ -664,7 +664,7 @@
 		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
 		MIPS32_SW(10,0,15), 								/* sw $10,($15) */
 		MIPS32_SW(11,0,15), 								/* sw $11,($15) */
-		
+
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)), 		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8), 									/* Load write addr to $9 */
@@ -674,14 +674,14 @@
 															/* loop: */
 		MIPS32_BEQ(0,10,9),									/* beq $0, $10, end */
 		MIPS32_NOP,
-		
+
 		MIPS32_LW(11,0,8), 									/* lw $11,0($8), Load $11 with the word @mem[$8] */
 		MIPS32_SH(11,0,9), 									/* sh $11,0($9) */
-		
+
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,2), 								/* $9 += 2 */
 		MIPS32_ADDI(8,8,4), 								/* $8 += 4 */
-		
+
 		MIPS32_NOP,
 		MIPS32_B(NEG16(9)),									/* b loop */
 		MIPS32_NOP,
@@ -695,18 +695,18 @@
 		MIPS32_B(NEG16(30)),								/* b start */
 		MIPS32_NOP,
 	};
-	
+
 	/* TODO remove array */
 	uint32_t param_in[count + 2];
 	int i;
 	param_in[0] = addr;
 	param_in[1] = count;
-	
+
 	for (i = 0; i &lt; count; i++)
 	{
 		param_in[i + 2] = buf[i];
 	}
-	
+
 	mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 		sizeof(param_in)/sizeof(param_in[0]), param_in, 0, NULL, 1);
 
@@ -724,7 +724,7 @@
 		MIPS32_SW(9,0,15), 									/* sw $9,($15) */
 		MIPS32_SW(10,0,15), 								/* sw $10,($15) */
 		MIPS32_SW(11,0,15), 								/* sw $11,($15) */
-		
+
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)), 		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8), 									/* Load write addr to $9 */
@@ -734,14 +734,14 @@
 															/* loop: */
 		MIPS32_BEQ(0,10,9),									/* beq $0, $10, end */
 		MIPS32_NOP,
-		
+
 		MIPS32_LW(11,0,8), 									/* lw $11,0($8), Load $11 with the word @mem[$8] */
 		MIPS32_SB(11,0,9), 									/* sb $11,0($9) */
-		
+
 		MIPS32_ADDI(10,10,NEG16(1)), 						/* $10-- */
 		MIPS32_ADDI(9,9,1), 								/* $9 += 1 */
 		MIPS32_ADDI(8,8,4), 								/* $8 += 4 */
-		
+
 		MIPS32_NOP,
 		MIPS32_B(NEG16(9)),									/* b loop */
 		MIPS32_NOP,
@@ -755,19 +755,19 @@
 		MIPS32_B(NEG16(30)),								/* b start */
 		MIPS32_NOP,
 	};
-	
+
 	/* TODO remove array */
 	uint32_t param_in[count + 2];
 	int retval;
 	int i;
 	param_in[0] = addr;
 	param_in[1] = count;
-	
+
 	for (i = 0; i &lt; count; i++)
 	{
 		param_in[i + 2] = buf[i];
 	}
-	
+
 	retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 		sizeof(param_in)/sizeof(param_in[0]), param_in, 0, NULL, 1);
 
@@ -816,7 +816,7 @@
 		MIPS32_LW(29,29*4,1), 							/* lw $29,29*4($1) */
 		MIPS32_LW(30,30*4,1), 							/* lw $30,30*4($1) */
 		MIPS32_LW(31,31*4,1), 							/* lw $31,31*4($1) */
-		
+
 		MIPS32_LW(2,32*4,1), 							/* lw $2,32*4($1) */
 		MIPS32_MTC0(2,12,0),							/* move $2 to status */
 		MIPS32_LW(2,33*4,1), 							/* lw $2,33*4($1) */
@@ -829,7 +829,7 @@
 		MIPS32_MTC0(2,13,0),							/* move $2 to cause*/
 		MIPS32_LW(2,37*4,1), 							/* lw $2,37*4($1) */
 		MIPS32_MTC0(2,24,0),							/* move $2 to pc */
-		
+
 		MIPS32_LW(2,2*4,1), 							/* lw $2,2*4($1) */
 		MIPS32_LW(1,0,15), 								/* lw $1,($15) */
 		MIPS32_MFC0(15,31,0),							/* move COP0 DeSave to $15 */
@@ -837,12 +837,12 @@
 		MIPS32_B(NEG16(55)),							/* b start */
 		MIPS32_NOP,
 	};
-	
+
 	int retval;
-	
+
 	retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 		38, regs, 0, NULL, 1);
-	
+
 	return retval;
 }
 
@@ -893,7 +893,7 @@
 		MIPS32_SW(29,29*4,1), 							/* sw $29,29*4($1) */
 		MIPS32_SW(30,30*4,1), 							/* sw $30,30*4($1) */
 		MIPS32_SW(31,31*4,1), 							/* sw $31,31*4($1) */
-		
+
 		MIPS32_MFC0(2,12,0),							/* move status to $2 */
 		MIPS32_SW(2,32*4,1), 							/* sw $2,32*4($1) */
 		MIPS32_MFLO(2),									/* move lo to $2 */
@@ -906,7 +906,7 @@
 		MIPS32_SW(2,36*4,1), 							/* sw $2,36*4($1) */
 		MIPS32_MFC0(2,24,0),							/* move pc to $2 */
 		MIPS32_SW(2,37*4,1), 							/* sw $2,37*4($1) */
-		
+
 		MIPS32_LW(2,0,15), 								/* lw $2,($15) */
 		MIPS32_LW(1,0,15), 								/* lw $1,($15) */
 		MIPS32_MFC0(15,31,0),							/* move COP0 DeSave to $15 */
@@ -914,11 +914,11 @@
 		MIPS32_B(NEG16(60)),							/* b start */
 		MIPS32_NOP,
 	};
-	
+
 	int retval;
-	
+
 	retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
 		0, NULL, 38, regs, 1);
-	
+
 	return retval;
 }

Modified: trunk/src/target/mips_ejtag.c
===================================================================
--- trunk/src/target/mips_ejtag.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/mips_ejtag.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -46,10 +46,10 @@
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
 		field.in_value = NULL;
-		
-		
-		
-		
+
+
+
+
 		jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());
 	}
 
@@ -69,10 +69,10 @@
 	field.out_value = NULL;
 
 	field.in_value = (void*)idcode;
-	
-	
-	
-	
+
+
+
+
 	jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
 
 	if (jtag_execute_queue() != ERROR_OK)
@@ -96,10 +96,10 @@
 	field.out_value = NULL;
 
 	field.in_value = (void*)impcode;
-	
-	
-	
-	
+
+
+
+
 	jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
 
 	if (jtag_execute_queue() != ERROR_OK)
@@ -127,10 +127,10 @@
 	buf_set_u32(field.out_value, 0, field.num_bits, *data);
 
 	field.in_value = r;
-	
-	
-	
-	
+
+
+
+
 	jtag_add_dr_scan(1, &amp;field, jtag_get_end_state());
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -222,7 +222,7 @@
 {
 	uint32_t inst;
 	inst = MIPS32_DRET;
-	
+
 	/* execute our dret instruction */
 	mips32_pracc_exec(ejtag_info, 1, &amp;inst, 0, NULL, 0, NULL, 0);
 

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/mips_m4k.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -348,7 +348,7 @@
 
 	/* disable interrupts while stepping */
 	mips32_enable_interrupts(target, 0);
-	
+
 	/* exit debug mode */
 	mips_ejtag_exit_debug(ejtag_info);
 
@@ -404,7 +404,7 @@
 
 	/* enable interrupts if we are running */
 	mips32_enable_interrupts(target, !debug_execution);
-	
+
 	/* exit debug mode */
 	mips_ejtag_exit_debug(ejtag_info);
 	target-&gt;debug_reason = DBG_REASON_NOTHALTED;
@@ -462,7 +462,7 @@
 
 	/* disable interrupts while stepping */
 	mips32_enable_interrupts(target, 0);
-		
+
 	/* exit debug mode */
 	mips_ejtag_exit_debug(ejtag_info);
 
@@ -498,7 +498,7 @@
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips32_comparator_t * comparator_list = mips32-&gt;inst_break_list;
 	int retval;
-	
+
 	if (breakpoint-&gt;set)
 	{
 		LOG_WARNING(&quot;breakpoint already set&quot;);
@@ -530,7 +530,7 @@
 		if (breakpoint-&gt;length == 4)
 		{
 			uint32_t verify = 0xffffffff;
-			
+
 			if ((retval = target_read_memory(target, breakpoint-&gt;address, breakpoint-&gt;length, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
 			{
 				return retval;
@@ -539,7 +539,7 @@
 			{
 				return retval;
 			}
-			
+
 			if ((retval = target_read_u32(target, breakpoint-&gt;address, &amp;verify)) != ERROR_OK)
 			{
 				return retval;
@@ -553,7 +553,7 @@
 		else
 		{
 			uint16_t verify = 0xffff;
-			
+
 			if ((retval = target_read_memory(target, breakpoint-&gt;address, breakpoint-&gt;length, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
 			{
 				return retval;
@@ -562,7 +562,7 @@
 			{
 				return retval;
 			}
-			
+
 			if ((retval = target_read_u16(target, breakpoint-&gt;address, &amp;verify)) != ERROR_OK)
 			{
 				return retval;
@@ -573,7 +573,7 @@
 				return ERROR_OK;
 			}
 		}
-		
+
 		breakpoint-&gt;set = 20; /* Any nice value but 0 */
 	}
 
@@ -586,7 +586,7 @@
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips32_comparator_t * comparator_list = mips32-&gt;inst_break_list;
 	int retval;
-	
+
 	if (!breakpoint-&gt;set)
 	{
 		LOG_WARNING(&quot;breakpoint not set&quot;);
@@ -611,7 +611,7 @@
 		if (breakpoint-&gt;length == 4)
 		{
 			uint32_t current_instr;
-			
+
 			/* check that user program has not modified breakpoint instruction */
 			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
 			{
@@ -628,13 +628,13 @@
 		else
 		{
 			uint16_t current_instr;
-			
+
 			/* check that user program has not modified breakpoint instruction */
 			if ((retval = target_read_memory(target, breakpoint-&gt;address, 2, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
-			
+
 			if (current_instr == MIPS16_SDBBP)
 			{
 				if ((retval = target_write_memory(target, breakpoint-&gt;address, 2, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
@@ -660,9 +660,9 @@
 			LOG_INFO(&quot;no hardware breakpoint available&quot;);
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
-		
+
 		mips32-&gt;num_inst_bpoints_avail--;
-	}	
+	}
 
 	mips_m4k_set_breakpoint(target, breakpoint);
 
@@ -758,7 +758,7 @@
 		return retval;
 
 	/* TAP data register is loaded LSB first (little endian) */
-	if (target-&gt;endianness == TARGET_BIG_ENDIAN) 
+	if (target-&gt;endianness == TARGET_BIG_ENDIAN)
 	{
 		uint32_t i, t32;
 		uint16_t t16;
@@ -810,7 +810,7 @@
 
 		for (i = 0; i &lt; (count*size); i += size)
 		{
-			switch (size) 
+			switch (size)
 			{
 				case 4:
 					t32 = be_to_h_u32(&amp;buffer[i]);
@@ -822,7 +822,7 @@
 					break;
 			}
 		}
-	}	   
+	}
 
 	/* if noDMA off, use DMAACC mode for memory write */
 	if (ejtag_info-&gt;impcode &amp; EJTAG_IMP_NODMA)
@@ -884,7 +884,7 @@
 	{
 		mips_ejtag_get_idcode(ejtag_info, &amp;idcode);
 		ejtag_info-&gt;idcode = idcode;
-		
+
 		if (((idcode &gt;&gt; 1) &amp; 0x7FF) == 0x29)
 		{
 			/* we are using a pic32mx so select ejtag port

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/target.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -969,7 +969,7 @@
 
 		if (free_size &lt; size)
 		{
-			LOG_WARNING(&quot;not enough working area available(requested %u, free %u)&quot;, 
+			LOG_WARNING(&quot;not enough working area available(requested %u, free %u)&quot;,
 				    (unsigned)(size), (unsigned)(free_size));
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
@@ -1102,7 +1102,7 @@
 int target_write_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer)
 {
 	int retval;
-	LOG_DEBUG(&quot;writing buffer of %i byte at 0x%8.8x&quot;, 
+	LOG_DEBUG(&quot;writing buffer of %i byte at 0x%8.8x&quot;,
 		  (int)size, (unsigned)address);
 
 	if (!target_was_examined(target))
@@ -1118,8 +1118,8 @@
 	if ((address + size - 1) &lt; address)
 	{
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR(&quot;address + size wrapped(0x%08x, 0x%08x)&quot;, 
-				  (unsigned)address, 
+		LOG_ERROR(&quot;address + size wrapped(0x%08x, 0x%08x)&quot;,
+				  (unsigned)address,
 				  (unsigned)size);
 		return ERROR_FAIL;
 	}
@@ -1184,7 +1184,7 @@
 int target_read_buffer(struct target_s *target, uint32_t address, uint32_t size, uint8_t *buffer)
 {
 	int retval;
-	LOG_DEBUG(&quot;reading buffer of %i byte at 0x%8.8x&quot;, 
+	LOG_DEBUG(&quot;reading buffer of %i byte at 0x%8.8x&quot;,
 			  (int)size, (unsigned)address);
 
 	if (!target_was_examined(target))
@@ -1200,8 +1200,8 @@
 	if ((address + size - 1) &lt; address)
 	{
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR(&quot;address + size wrapped(0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;)&quot;, 
-				  address, 
+		LOG_ERROR(&quot;address + size wrapped(0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;)&quot;,
+				  address,
 				  size);
 		return ERROR_FAIL;
 	}
@@ -1326,14 +1326,14 @@
 	if (retval == ERROR_OK)
 	{
 		*value = target_buffer_get_u32(target, value_buf);
-		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%8.8&quot; PRIx32 &quot;&quot;, 
-				  address, 
+		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%8.8&quot; PRIx32 &quot;&quot;,
+				  address,
 				  *value);
 	}
 	else
 	{
 		*value = 0x0;
-		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot; failed&quot;, 
+		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot; failed&quot;,
 				  address);
 	}
 
@@ -1354,14 +1354,14 @@
 	if (retval == ERROR_OK)
 	{
 		*value = target_buffer_get_u16(target, value_buf);
-		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%4.4x&quot;, 
-				  address, 
+		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%4.4x&quot;,
+				  address,
 				  *value);
 	}
 	else
 	{
 		*value = 0x0;
-		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot; failed&quot;, 
+		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot; failed&quot;,
 				  address);
 	}
 
@@ -1379,14 +1379,14 @@
 
 	if (retval == ERROR_OK)
 	{
-		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%2.2x&quot;, 
-				  address, 
+		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%2.2x&quot;,
+				  address,
 				  *value);
 	}
 	else
 	{
 		*value = 0x0;
-		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot; failed&quot;, 
+		LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot; failed&quot;,
 				  address);
 	}
 
@@ -1403,8 +1403,8 @@
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%8.8&quot; PRIx32 &quot;&quot;, 
-			  address, 
+	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%8.8&quot; PRIx32 &quot;&quot;,
+			  address,
 			  value);
 
 	target_buffer_set_u32(target, value_buf, value);
@@ -1426,8 +1426,8 @@
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%8.8x&quot;, 
-			  address, 
+	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%8.8x&quot;,
+			  address,
 			  value);
 
 	target_buffer_set_u16(target, value_buf, value);
@@ -1448,7 +1448,7 @@
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%2.2x&quot;, 
+	LOG_DEBUG(&quot;address: 0x%8.8&quot; PRIx32 &quot;, value: 0x%2.2x&quot;,
 			  address, value);
 
 	if ((retval = target_write_memory(target, address, 1, 1, &amp;value)) != ERROR_OK)
@@ -1734,12 +1734,12 @@
 			for (i = 0; i &lt; cache-&gt;num_regs; i++)
 			{
 				value = buf_to_str(cache-&gt;reg_list[i].value, cache-&gt;reg_list[i].size, 16);
-				command_print(cmd_ctx, &quot;(%i) %s (/%i): 0x%s (dirty: %i, valid: %i)&quot;, 
-							  count++, 
-							  cache-&gt;reg_list[i].name, 
+				command_print(cmd_ctx, &quot;(%i) %s (/%i): 0x%s (dirty: %i, valid: %i)&quot;,
+							  count++,
+							  cache-&gt;reg_list[i].name,
 							  (int)(cache-&gt;reg_list[i].size),
-							  value, 
-							  cache-&gt;reg_list[i].dirty, 
+							  value,
+							  cache-&gt;reg_list[i].dirty,
 							  cache-&gt;reg_list[i].valid);
 				free(value);
 			}
@@ -2066,7 +2066,7 @@
 		{
 			output_len += snprintf(output + output_len,
 					sizeof(output) - output_len,
-					&quot;0x%8.8x: &quot;, 
+					&quot;0x%8.8x: &quot;,
 					(unsigned)(address + (i*size)));
 		}
 
@@ -2241,7 +2241,7 @@
 
 	duration_t duration;
 	char *duration_text;
-	
+
 	int retval = parse_load_image_command_args(args, argc,
 			&amp;image, &amp;min_address, &amp;max_address);
 	if (ERROR_OK != retval)
@@ -2262,8 +2262,8 @@
 		buffer = malloc(image.sections[i].size);
 		if (buffer == NULL)
 		{
-			command_print(cmd_ctx, 
-						  &quot;error allocating buffer for section (%d bytes)&quot;, 
+			command_print(cmd_ctx,
+						  &quot;error allocating buffer for section (%d bytes)&quot;,
 						  (int)(image.sections[i].size));
 			break;
 		}
@@ -2300,8 +2300,8 @@
 				break;
 			}
 			image_size += length;
-			command_print(cmd_ctx, &quot;%u byte written at address 0x%8.8&quot; PRIx32 &quot;&quot;, 
-						  (unsigned int)length, 
+			command_print(cmd_ctx, &quot;%u byte written at address 0x%8.8&quot; PRIx32 &quot;&quot;,
+						  (unsigned int)length,
 						  image.sections[i].base_address + offset);
 		}
 
@@ -2316,8 +2316,8 @@
 
 	if (retval == ERROR_OK)
 	{
-		command_print(cmd_ctx, &quot;downloaded %u byte in %s&quot;, 
-					  (unsigned int)image_size, 
+		command_print(cmd_ctx, &quot;downloaded %u byte in %s&quot;,
+					  (unsigned int)image_size,
 					  duration_text);
 	}
 	free(duration_text);
@@ -2459,8 +2459,8 @@
 		buffer = malloc(image.sections[i].size);
 		if (buffer == NULL)
 		{
-			command_print(cmd_ctx, 
-						  &quot;error allocating buffer for section (%d bytes)&quot;, 
+			command_print(cmd_ctx,
+						  &quot;error allocating buffer for section (%d bytes)&quot;,
 						  (int)(image.sections[i].size));
 			break;
 		}
@@ -2507,10 +2507,10 @@
 					{
 						if (data[t] != buffer[t])
 						{
-							command_print(cmd_ctx, 
-										  &quot;Verify operation failed address 0x%08x. Was 0x%02x instead of 0x%02x\n&quot;, 
-										  (unsigned)(t + image.sections[i].base_address), 
-										  data[t], 
+							command_print(cmd_ctx,
+										  &quot;Verify operation failed address 0x%08x. Was 0x%02x instead of 0x%02x\n&quot;,
+										  (unsigned)(t + image.sections[i].base_address),
+										  data[t],
 										  buffer[t]);
 							free(data);
 							free(buffer);
@@ -2528,8 +2528,8 @@
 			}
 		} else
 		{
-			command_print(cmd_ctx, &quot;address 0x%08&quot; PRIx32 &quot; length 0x%08&quot; PRIx32 &quot;&quot;, 
-						  image.sections[i].base_address, 
+			command_print(cmd_ctx, &quot;address 0x%08&quot; PRIx32 &quot; length 0x%08&quot; PRIx32 &quot;&quot;,
+						  image.sections[i].base_address,
 						  buf_cnt);
 		}
 
@@ -2546,8 +2546,8 @@
 
 	if (retval == ERROR_OK)
 	{
-		command_print(cmd_ctx, &quot;verified %u bytes in %s&quot;, 
-					  (unsigned int)image_size, 
+		command_print(cmd_ctx, &quot;verified %u bytes in %s&quot;,
+					  (unsigned int)image_size,
 					  duration_text);
 	}
 	free(duration_text);
@@ -2578,7 +2578,7 @@
 			char* buf = buf_to_str(breakpoint-&gt;orig_instr,
 					breakpoint-&gt;length, 16);
 			command_print(cmd_ctx, &quot;0x%8.8&quot; PRIx32 &quot;, 0x%x, %i, 0x%s&quot;,
-					breakpoint-&gt;address, 
+					breakpoint-&gt;address,
 					breakpoint-&gt;length,
 					breakpoint-&gt;set, buf);
 			free(buf);
@@ -2586,7 +2586,7 @@
 		else
 		{
 			command_print(cmd_ctx, &quot;0x%8.8&quot; PRIx32 &quot;, 0x%x, %i&quot;,
-						  breakpoint-&gt;address, 
+						  breakpoint-&gt;address,
 						  breakpoint-&gt;length, breakpoint-&gt;set);
 		}
 
@@ -2667,9 +2667,9 @@
 
 		while (watchpoint)
 		{
-			command_print(cmd_ctx, 
-						  &quot;address: 0x%8.8&quot; PRIx32 &quot;, len: 0x%8.8x, r/w/a: %i, value: 0x%8.8&quot; PRIx32 &quot;, mask: 0x%8.8&quot; PRIx32 &quot;&quot;, 
-						  watchpoint-&gt;address, 
+			command_print(cmd_ctx,
+						  &quot;address: 0x%8.8&quot; PRIx32 &quot;, len: 0x%8.8x, r/w/a: %i, value: 0x%8.8&quot; PRIx32 &quot;, mask: 0x%8.8&quot; PRIx32 &quot;&quot;,
+						  watchpoint-&gt;address,
 						  watchpoint-&gt;length,
 						  (int)(watchpoint-&gt;rw),
 						  watchpoint-&gt;value,
@@ -3111,8 +3111,8 @@
 	} else {
 		char buf[100];
 		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		sprintf(buf, &quot;mem2array address: 0x%08&quot; PRIx32 &quot; is not aligned for %&quot; PRId32 &quot; byte reads&quot;, 
-				addr, 
+		sprintf(buf, &quot;mem2array address: 0x%08&quot; PRIx32 &quot; is not aligned for %&quot; PRId32 &quot; byte reads&quot;,
+				addr,
 				width);
 		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
 		return JIM_ERR;
@@ -3135,9 +3135,9 @@
 		retval = target_read_memory(target, addr, width, count, buffer);
 		if (retval != ERROR_OK) {
 			/* BOO !*/
-			LOG_ERROR(&quot;mem2array: Read @ 0x%08x, w=%d, cnt=%d, failed&quot;, 
-					  (unsigned int)addr, 
-					  (int)width, 
+			LOG_ERROR(&quot;mem2array: Read @ 0x%08x, w=%d, cnt=%d, failed&quot;,
+					  (unsigned int)addr,
+					  (int)width,
 					  (int)count);
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 			Jim_AppendStrings(interp, Jim_GetResult(interp), &quot;mem2array: cannot read memory&quot;, NULL);
@@ -3298,8 +3298,8 @@
 	} else {
 		char buf[100];
 		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		sprintf(buf, &quot;array2mem address: 0x%08x is not aligned for %d byte reads&quot;, 
-				(unsigned int)addr, 
+		sprintf(buf, &quot;array2mem address: 0x%08x is not aligned for %d byte reads&quot;,
+				(unsigned int)addr,
 				(int)width);
 		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
 		return JIM_ERR;
@@ -3339,9 +3339,9 @@
 		retval = target_write_memory(target, addr, width, count, buffer);
 		if (retval != ERROR_OK) {
 			/* BOO !*/
-			LOG_ERROR(&quot;array2mem: Write @ 0x%08x, w=%d, cnt=%d, failed&quot;, 
-					  (unsigned int)addr, 
-					  (int)width, 
+			LOG_ERROR(&quot;array2mem: Write @ 0x%08x, w=%d, cnt=%d, failed&quot;,
+					  (unsigned int)addr,
+					  (int)width,
 					  (int)count);
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 			Jim_AppendStrings(interp, Jim_GetResult(interp), &quot;array2mem: cannot read memory&quot;, NULL);
@@ -4443,7 +4443,7 @@
 		buffer = malloc(image.sections[i].size);
 		if (buffer == NULL)
 		{
-			command_print(cmd_ctx, &quot;error allocating buffer for section (%d bytes)&quot;, 
+			command_print(cmd_ctx, &quot;error allocating buffer for section (%d bytes)&quot;,
 						  (int)(image.sections[i].size));
 			break;
 		}
@@ -4486,8 +4486,8 @@
 			fastload[i].length = length;
 
 			image_size += length;
-			command_print(cmd_ctx, &quot;%u byte written at address 0x%8.8x&quot;, 
-						  (unsigned int)length, 
+			command_print(cmd_ctx, &quot;%u byte written at address 0x%8.8x&quot;,
+						  (unsigned int)length,
 						  ((unsigned int)(image.sections[i].base_address + offset)));
 		}
 
@@ -4528,8 +4528,8 @@
 	for (i = 0; i &lt; fastload_num;i++)
 	{
 		target_t *target = get_current_target(cmd_ctx);
-		command_print(cmd_ctx, &quot;Write to 0x%08x, length 0x%08x&quot;, 
-					  (unsigned int)(fastload[i].address), 
+		command_print(cmd_ctx, &quot;Write to 0x%08x, length 0x%08x&quot;,
+					  (unsigned int)(fastload[i].address),
 					  (unsigned int)(fastload[i].length));
 		if (retval == ERROR_OK)
 		{
@@ -4544,7 +4544,7 @@
 
 
 /*
- * Local Variables: 
+ * Local Variables:
  * c-basic-offset: 4
  * tab-width: 4
  * End:

Modified: trunk/src/target/trace.c
===================================================================
--- trunk/src/target/trace.c	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/trace.c	2009-06-23 22:49:23 UTC (rev 2379)
@@ -30,7 +30,7 @@
 	trace_t *trace = target-&gt;trace_info;
 
 	LOG_DEBUG(&quot;tracepoint: %i&quot;, (int)number);
-	
+
 	if (number &lt; trace-&gt;num_trace_points)
 		trace-&gt;trace_points[number].hit_counter++;
 
@@ -43,7 +43,7 @@
 			trace-&gt;trace_history_overflowed = 1;
 		}
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -51,11 +51,11 @@
 {
 	target_t *target = get_current_target(cmd_ctx);
 	trace_t *trace = target-&gt;trace_info;
-	
+
 	if (argc == 0)
 	{
 		uint32_t i;
-		
+
 		for (i = 0; i &lt; trace-&gt;num_trace_points; i++)
 		{
 			command_print(cmd_ctx, &quot;trace point 0x%8.8&quot; PRIx32 &quot; (%lld times hit)&quot;,
@@ -65,7 +65,7 @@
 
 		return ERROR_OK;
 	}
-	
+
 	if (!strcmp(args[0], &quot;clear&quot;))
 	{
 		if (trace-&gt;trace_points)
@@ -75,21 +75,21 @@
 		}
 		trace-&gt;num_trace_points = 0;
 		trace-&gt;trace_points_size = 0;
-		
+
 		return ERROR_OK;
 	}
-	
+
 	/* resize array if necessary */
 	if (!trace-&gt;trace_points || (trace-&gt;trace_points_size == trace-&gt;num_trace_points))
 	{
 		trace-&gt;trace_points = realloc(trace-&gt;trace_points, sizeof(trace_point_t) * (trace-&gt;trace_points_size + 32));
 		trace-&gt;trace_points_size += 32;
 	}
-	
+
 	trace-&gt;trace_points[trace-&gt;num_trace_points].address = strtoul(args[0], NULL, 0);
 	trace-&gt;trace_points[trace-&gt;num_trace_points].hit_counter = 0;
 	trace-&gt;num_trace_points++;
-	
+
 	return ERROR_OK;
 }
 
@@ -97,7 +97,7 @@
 {
 	target_t *target = get_current_target(cmd_ctx);
 	trace_t *trace = target-&gt;trace_info;
-	
+
 	if (argc &gt; 0)
 	{
 		trace-&gt;trace_history_pos = 0;
@@ -108,13 +108,13 @@
 			/* clearing is implicit, we've just reset position anyway */
 			return ERROR_OK;
 		}
-		
+
 		if (trace-&gt;trace_history)
 			free(trace-&gt;trace_history);
-		
+
 		trace-&gt;trace_history_size = strtoul(args[0], NULL, 0);
 		trace-&gt;trace_history = malloc(sizeof(uint32_t) * trace-&gt;trace_history_size);
-		
+
 		command_print(cmd_ctx, &quot;new trace history size: %i&quot;, (int)(trace-&gt;trace_history_size));
 	}
 	else
@@ -132,7 +132,7 @@
 			first = trace-&gt;trace_history_pos;
 			last = trace-&gt;trace_history_pos - 1;
 		}
-		
+
 		for (i = first; (i % trace-&gt;trace_history_size) != last; i++)
 		{
 			if (trace-&gt;trace_history[i % trace-&gt;trace_history_size] &lt; trace-&gt;num_trace_points)
@@ -158,7 +158,7 @@
 {
 	command_t *trace_cmd =
 		register_command(cmd_ctx, NULL, &quot;trace&quot;, NULL, COMMAND_ANY, &quot;trace commands&quot;);
-	
+
 	register_command(cmd_ctx, trace_cmd, &quot;history&quot;, handle_trace_history_command,
 		COMMAND_EXEC, &quot;display trace history, ['clear'] history or set [size]&quot;);
 

Modified: trunk/src/target/xscale/protocol.h
===================================================================
--- trunk/src/target/xscale/protocol.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/xscale/protocol.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -37,10 +37,10 @@
 #define REG_CPSR 16
 #define REG_SPSR 17
 
-#define MODE_USR 0x10 
+#define MODE_USR 0x10
 #define MODE_FIQ 0x11
-#define MODE_IRQ 0x12 
-#define MODE_SVC 0x13 
+#define MODE_IRQ 0x12
+#define MODE_SVC 0x13
 #define MODE_ABT 0x17
 #define MODE_UND 0x1b
 #define MODE_SYS 0x1f

Modified: trunk/src/target/xscale.h
===================================================================
--- trunk/src/target/xscale.h	2009-06-23 22:49:06 UTC (rev 2378)
+++ trunk/src/target/xscale.h	2009-06-23 22:49:23 UTC (rev 2379)
@@ -34,7 +34,7 @@
 	/* position in JTAG scan chain */
 	jtag_tap_t *tap;
 
-	/* IR length and instructions */	
+	/* IR length and instructions */
 	int ir_length;
 	uint32_t dbgrx;
 	uint32_t dbgtx;
@@ -86,7 +86,7 @@
 typedef struct xscale_common_s
 {
 	int common_magic;
-	
+
 	/* XScale registers (CP15, DBG) */
 	reg_cache_t *reg_cache;
 
@@ -94,29 +94,29 @@
 	char *variant;
 
 	xscale_jtag_t jtag_info;
-	
+
 	/* current state of the debug handler */
 	int handler_installed;
 	int handler_running;
 	uint32_t handler_address;
-	
+
 	/* target-endian buffers with exception vectors */
 	uint32_t low_vectors[8];
 	uint32_t high_vectors[8];
-	
+
 	/* static low vectors */
 	uint8_t static_low_vectors_set;	/* bit field with static vectors set by the user */
 	uint8_t static_high_vectors_set; /* bit field with static vectors set by the user */
 	uint32_t static_low_vectors[8];
 	uint32_t static_high_vectors[8];
 
-	/* DCache cleaning */	
+	/* DCache cleaning */
 	uint32_t cache_clean_address;
-	
+
 	/* whether hold_rst and ext_dbg_break should be set */
 	int hold_rst;
 	int external_debug_break;
-	
+
 	/* breakpoint / watchpoint handling */
 	int dbr_available;
 	int dbr0_used;
@@ -126,23 +126,23 @@
 	int	ibcr1_used;
 	uint32_t arm_bkpt;
 	uint16_t thumb_bkpt;
-	
+
 	uint8_t vector_catch;
 
 	xscale_trace_t trace;
-	
+
 	int arch_debug_reason;
-	
+
 	/* armv4/5 common stuff */
 	armv4_5_common_t armv4_5_common;
-	
+
 	/* MMU/Caches */
 	armv4_5_mmu_common_t armv4_5_mmu;
 	uint32_t cp15_control_reg;
-	
+
 	/* possible future enhancements that go beyond XScale common stuff */
 	void *arch_info;
-	
+
 	int fast_memory_access;
 } xscale_common_t;
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001162.html">[Openocd-svn] r2378 - in trunk/src: flash helper jtag pld server	target
</A></li>
	<LI>Next message: <A HREF="001164.html">[Openocd-svn] r2380 - in trunk: src/helper src/jtag src/server	src/svf src/xsvf testing/examples/AT91R40008Test/inc	testing/examples/AT91R40008Test/src testing/examples/LPC2148Test/inc	testing/examples/LPC2148Test/src testing/examples/LPC2294Test/inc	testing/examples/LPC2294Test/src testing/examples/PIC32	testing/examples/SAM7S256Test/inc testing/examples/SAM7S256Test/src	testing/examples/SAM7X256Test/inc testing/examples/SAM7X256Test/src	testing/examples/STR710JtagSpeed/inc	testing/examples/STR710JtagSpeed/src testing/examples/STR710Test/inc	testing/examples/STR710Test/src testing/examples/STR912Test/inc	testing/examples/STR912Test/src testing/examples/cortex	testing/examples/ledtest-imx27ads testing/examples/ledtest-imx31pdk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1163">[ date ]</a>
              <a href="thread.html#1163">[ thread ]</a>
              <a href="subject.html#1163">[ subject ]</a>
              <a href="author.html#1163">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
