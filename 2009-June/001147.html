<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2363 - in trunk/src: . flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2363%20-%20in%20trunk/src%3A%20.%20flash%20flash/ocl/at91sam7x%0A%09helper%20jtag%20jtag/zy1000%20server%20target&In-Reply-To=%3C200906232239.n5NMdCeU013481%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001146.html">
   <LINK REL="Next"  HREF="001148.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2363 - in trunk/src: . flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2363%20-%20in%20trunk/src%3A%20.%20flash%20flash/ocl/at91sam7x%0A%09helper%20jtag%20jtag/zy1000%20server%20target&In-Reply-To=%3C200906232239.n5NMdCeU013481%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2363 - in trunk/src: . flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target">zwelch at mail.berlios.de
       </A><BR>
    <I>Wed Jun 24 00:39:12 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001146.html">[Openocd-svn] r2362 - in trunk/src: server target
</A></li>
        <LI>Next message: <A HREF="001148.html">[Openocd-svn] r2364 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1147">[ date ]</a>
              <a href="thread.html#1147">[ thread ]</a>
              <a href="subject.html#1147">[ subject ]</a>
              <a href="author.html#1147">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-24 00:38:12 +0200 (Wed, 24 Jun 2009)
New Revision: 2363

Modified:
   trunk/src/flash/ecos.c
   trunk/src/flash/flash.c
   trunk/src/flash/lpc2000.c
   trunk/src/flash/ocl/at91sam7x/main.c
   trunk/src/flash/ocl/at91sam7x/samflash.c
   trunk/src/flash/pic32mx.c
   trunk/src/flash/stm32x.c
   trunk/src/flash/str9x.c
   trunk/src/helper/command.c
   trunk/src/helper/configuration.c
   trunk/src/helper/ioutil.c
   trunk/src/helper/jim.c
   trunk/src/helper/log.c
   trunk/src/helper/replacements.c
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/bitq.c
   trunk/src/jtag/core.c
   trunk/src/jtag/driver.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/presto.c
   trunk/src/jtag/tcl.c
   trunk/src/jtag/zy1000/jtag_minidriver.h
   trunk/src/jtag/zy1000/zy1000.c
   trunk/src/openocd.c
   trunk/src/server/gdb_server.c
   trunk/src/server/httpd.c
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm9tdmi.c
   trunk/src/target/arm_adi_v5.c
   trunk/src/target/arm_disassembler.c
   trunk/src/target/armv4_5.c
   trunk/src/target/armv7m.c
   trunk/src/target/breakpoints.c
   trunk/src/target/cortex_m3.c
   trunk/src/target/embeddedice.c
   trunk/src/target/etm.c
   trunk/src/target/feroceon.c
   trunk/src/target/image.c
   trunk/src/target/mips_m4k.c
   trunk/src/target/target.c
   trunk/src/target/xscale.c
Log:
- Fixes '!=' whitespace
- Replace ')\(!=\)\(\w\)' with ') \1 \2'.
- Replace '\(\w\)\(!=\)(' with '\1 \2 ('.
- Replace '\(\w\)\(!=\)\(\w\)' with '\1 \2 \3'.


Modified: trunk/src/flash/ecos.c
===================================================================
--- trunk/src/flash/ecos.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/ecos.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -269,7 +269,7 @@
 	int timeout = (len / 20480 + 1) * 1000; /*asume 20 KB/s*/
 
 	retval=loadDriver(info);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 		return retval;
 
 	uint32_t flashErr;
@@ -282,7 +282,7 @@
 			&amp;flashErr,
 			timeout
 			);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 		return retval;
 
 	if (flashErr != 0x0)
@@ -302,7 +302,7 @@
 	int timeout = (chunk / 20480 + 1) * 1000; /*asume 20 KB/s + 1 second*/
 
 	retval=loadDriver(info);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 		return retval;
 
 	uint32_t buffer;
@@ -314,7 +314,7 @@
 			0,
 			&amp;buffer,
 			1000);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 		return retval;
 
 

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/flash.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -90,7 +90,7 @@
 	int retval;
 
 	retval=bank-&gt;driver-&gt;write(bank, buffer, offset, count);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 	{
 		LOG_ERROR(&quot;error writing to flash at address 0x%08&quot; PRIx32 &quot; at offset 0x%8.8&quot; PRIx32 &quot; (%d)&quot;, 
 			  bank-&gt;base, offset, retval);
@@ -104,7 +104,7 @@
 	int retval;
 
 	retval=bank-&gt;driver-&gt;erase(bank, first, last);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 	{
 		LOG_ERROR(&quot;failed erasing sectors %d to %d (%d)&quot;, first, last, retval);
 	}
@@ -117,7 +117,7 @@
 	int retval;
 
 	retval=bank-&gt;driver-&gt;protect(bank, set, first, last);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 	{
 		LOG_ERROR(&quot;failed setting protection for areas %d to %d (%d)&quot;, first, last, retval);
 	}
@@ -801,11 +801,11 @@
 			return ERROR_FAIL;
 		}
 		err = flash_driver_write(bank, chunk, address - bank-&gt;base + wrote, cur_size);
-		if (err!=ERROR_OK)
+		if (err != ERROR_OK)
 			return err;
 
 		err = target_read_buffer(target, address + wrote, cur_size, readback);
-		if (err!=ERROR_OK)
+		if (err != ERROR_OK)
 			return err;
 
 		unsigned i;

Modified: trunk/src/flash/lpc2000.c
===================================================================
--- trunk/src/flash/lpc2000.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/lpc2000.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -526,7 +526,7 @@
 		LOG_DEBUG(&quot;checksum: 0x%8.8&quot; PRIx32, checksum);
 
 		uint32_t original_value=buf_get_u32(buffer + (5 * 4), 0, 32);
-		if (original_value!=checksum)
+		if (original_value != checksum)
 		{
 			LOG_WARNING(&quot;Verification will fail since checksum in image(0x%8.8&quot; PRIx32 &quot;) written to flash was different from calculated vector checksum(0x%8.8&quot; PRIx32 &quot;).&quot;,
 					original_value, checksum);

Modified: trunk/src/flash/ocl/at91sam7x/main.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/main.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/ocl/at91sam7x/main.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -53,7 +53,7 @@
 	chksum=OCL_CHKS_INIT;
 	for (bi=0; bi&lt;bi_end; bi++) chksum^=buffer[bi]=dcc_rd();
 
-	if (dcc_rd()!=chksum) {
+	if (dcc_rd() != chksum) {
 		dcc_wr(OCL_CHKS_FAIL);
 		return;
 	}

Modified: trunk/src/flash/ocl/at91sam7x/samflash.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -175,7 +175,7 @@
 {
 	int result;
 	
-	if ((result=flash_erase_plane(0))!=FLASH_STAT_OK) return result;
+	if ((result=flash_erase_plane(0)) != FLASH_STAT_OK) return result;
 
 	/* the second flash controller, if any */
 	if (flash_page_count&gt;1024) result=flash_erase_plane(0x10);

Modified: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/pic32mx.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -388,7 +388,7 @@
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	if ((retval=target_write_buffer(target, pic32mx_info-&gt;write_algorithm-&gt;address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code))!=ERROR_OK)
+	if ((retval=target_write_buffer(target, pic32mx_info-&gt;write_algorithm-&gt;address, sizeof(pic32mx_flash_write_code), pic32mx_flash_write_code)) != ERROR_OK)
 		return retval;
 #endif
 
@@ -409,7 +409,7 @@
 	{
 		uint32_t status;
 
-		if ((retval = target_write_buffer(target, source-&gt;address, buffer_size, buffer))!=ERROR_OK) {
+		if ((retval = target_write_buffer(target, source-&gt;address, buffer_size, buffer)) != ERROR_OK) {
 			LOG_ERROR(&quot;Failed to write row buffer (%d words) to RAM&quot;, (int)(buffer_size/4));
 			break;
 		}

Modified: trunk/src/flash/stm32x.c
===================================================================
--- trunk/src/flash/stm32x.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/stm32x.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -517,7 +517,7 @@
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	if ((retval=target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address, sizeof(stm32x_flash_write_code), stm32x_flash_write_code))!=ERROR_OK)
+	if ((retval=target_write_buffer(target, stm32x_info-&gt;write_algorithm-&gt;address, sizeof(stm32x_flash_write_code), stm32x_flash_write_code)) != ERROR_OK)
 		return retval;
 
 	/* memory buffer */
@@ -547,7 +547,7 @@
 	{
 		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
 
-		if ((retval = target_write_buffer(target, source-&gt;address, thisrun_count * 2, buffer))!=ERROR_OK)
+		if ((retval = target_write_buffer(target, source-&gt;address, thisrun_count * 2, buffer)) != ERROR_OK)
 			break;
 
 		buf_set_u32(reg_params[0].value, 0, 32, source-&gt;address);

Modified: trunk/src/flash/str9x.c
===================================================================
--- trunk/src/flash/str9x.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/flash/str9x.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -198,11 +198,11 @@
 		if (str9x_info-&gt;bank1)
 		{
 			adr = bank1start + 0x18;
-			if ((retval=target_write_u16(target, adr, 0x90))!=ERROR_OK)
+			if ((retval=target_write_u16(target, adr, 0x90)) != ERROR_OK)
 			{
 				return retval;
 			}
-			if ((retval=target_read_u16(target, adr, &amp;hstatus))!=ERROR_OK)
+			if ((retval=target_read_u16(target, adr, &amp;hstatus)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -211,11 +211,11 @@
 		else
 		{
 			adr = bank1start + 0x14;
-			if ((retval=target_write_u16(target, adr, 0x90))!=ERROR_OK)
+			if ((retval=target_write_u16(target, adr, 0x90)) != ERROR_OK)
 			{
 				return retval;
 			}
-			if ((retval=target_read_u32(target, adr, &amp;status))!=ERROR_OK)
+			if ((retval=target_read_u32(target, adr, &amp;status)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -224,11 +224,11 @@
 	else
 	{
 		adr = bank1start + 0x10;
-		if ((retval=target_write_u16(target, adr, 0x90))!=ERROR_OK)
+		if ((retval=target_write_u16(target, adr, 0x90)) != ERROR_OK)
 		{
 			return retval;
 		}
-		if ((retval=target_read_u16(target, adr, &amp;hstatus))!=ERROR_OK)
+		if ((retval=target_read_u16(target, adr, &amp;hstatus)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -236,7 +236,7 @@
 	}
 
 	/* read array command */
-	if ((retval=target_write_u16(target, adr, 0xFF))!=ERROR_OK)
+	if ((retval=target_write_u16(target, adr, 0xFF)) != ERROR_OK)
 	{
 		return retval;
 	}
@@ -284,24 +284,24 @@
 		adr = bank-&gt;base + bank-&gt;sectors[i].offset;
 
 		/* erase sectors */
-		if ((retval=target_write_u16(target, adr, erase_cmd))!=ERROR_OK)
+		if ((retval=target_write_u16(target, adr, erase_cmd)) != ERROR_OK)
 		{
 			return retval;
 		}
-		if ((retval=target_write_u16(target, adr, 0xD0))!=ERROR_OK)
+		if ((retval=target_write_u16(target, adr, 0xD0)) != ERROR_OK)
 		{
 			return retval;
 		}
 
 		/* get status */
-		if ((retval=target_write_u16(target, adr, 0x70))!=ERROR_OK)
+		if ((retval=target_write_u16(target, adr, 0x70)) != ERROR_OK)
 		{
 			return retval;
 		}
 
 		int timeout;
 		for (timeout=0; timeout&lt;1000; timeout++) {
-			if ((retval=target_read_u8(target, adr, &amp;status))!=ERROR_OK)
+			if ((retval=target_read_u8(target, adr, &amp;status)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -316,13 +316,13 @@
 		}
 
 		/* clear status, also clear read array */
-		if ((retval=target_write_u16(target, adr, 0x50))!=ERROR_OK)
+		if ((retval=target_write_u16(target, adr, 0x50)) != ERROR_OK)
 		{
 			return retval;
 		}
 
 		/* read array command */
-		if ((retval=target_write_u16(target, adr, 0xFF))!=ERROR_OK)
+		if ((retval=target_write_u16(target, adr, 0xFF)) != ERROR_OK)
 		{
 			return retval;
 		}

Modified: trunk/src/helper/command.c
===================================================================
--- trunk/src/helper/command.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/helper/command.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -226,7 +226,7 @@
 	const char *t2=&quot;&quot;;
 	const char *t3=&quot;&quot;;
 	/* maximum of two levels :-) */
-	if (c-&gt;parent!=NULL)
+	if (c-&gt;parent != NULL)
 	{
 		t1=c-&gt;parent-&gt;name;
 		t2=&quot;_&quot;;
@@ -250,7 +250,7 @@
 	Jim_Obj *cmd_list=Jim_NewListObj(interp, NULL, 0);
 
 	/* maximum of two levels :-) */
-	if (c-&gt;parent!=NULL)
+	if (c-&gt;parent != NULL)
 	{
 		Jim_ListAppendElement(interp, cmd_list, Jim_NewStringObj(interp, c-&gt;parent-&gt;name, -1));
 	}
@@ -420,7 +420,7 @@
 		const char *t2=&quot;&quot;;
 		const char *t3=&quot;&quot;;
 		/* maximum of two levels :-) */
-		if (c-&gt;parent!=NULL)
+		if (c-&gt;parent != NULL)
 		{
 			t1=c-&gt;parent-&gt;name;
 			t2=&quot; &quot;;
@@ -473,7 +473,7 @@
 		Jim_DeleteAssocData(interp, &quot;context&quot;);
 	}
 	if (retcode == JIM_ERR) {
-		if (retval!=ERROR_COMMAND_CLOSE_CONNECTION)
+		if (retval != ERROR_COMMAND_CLOSE_CONNECTION)
 		{
 			/* We do not print the connection closed error message */
 			Jim_PrintErrorMessage(interp);
@@ -520,7 +520,7 @@
 	va_list ap;
 	va_start(ap, format);
 	string = alloc_vprintf(format, ap);
-	if (string!=NULL)
+	if (string != NULL)
 	{
 		retval=command_run_line(context, string);
 	}
@@ -809,7 +809,7 @@
 
 int handle_fast_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	if (argc!=1)
+	if (argc != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	fast_and_dangerous = strcmp(&quot;enable&quot;, args[0])==0;

Modified: trunk/src/helper/configuration.c
===================================================================
--- trunk/src/helper/configuration.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/helper/configuration.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -116,7 +116,7 @@
 	while (*cfg)
 	{
 		retval=command_run_line(cmd_ctx, *cfg);
-		if (retval!=ERROR_OK)
+		if (retval != ERROR_OK)
 			return retval;
 		cfg++;
 	}

Modified: trunk/src/helper/ioutil.c
===================================================================
--- trunk/src/helper/ioutil.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/helper/ioutil.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -89,7 +89,7 @@
 		LOG_ERROR(&quot;Can't open %s\n&quot;, fileName);
 		return ERROR_FAIL;
 	}
-	if (fseek(pFile, 0, SEEK_END)!=0)
+	if (fseek(pFile, 0, SEEK_END) != 0)
 	{
 		LOG_ERROR(&quot;Can't open %s\n&quot;, fileName);
 		fclose(pFile);
@@ -104,7 +104,7 @@
 	}
 	*len = fsize;
 
-	if (fseek(pFile, 0, SEEK_SET)!=0)
+	if (fseek(pFile, 0, SEEK_SET) != 0)
 	{
 		LOG_ERROR(&quot;Can't open %s\n&quot;, fileName);
 		fclose(pFile);
@@ -225,11 +225,11 @@
 
 		for (i = 1; i &lt; argc; i++)
 		{
-			if (fwrite(args[i], 1, strlen(args[i]), config_file)!=strlen(args[i]))
+			if (fwrite(args[i], 1, strlen(args[i]), config_file) != strlen(args[i]))
 				break;
 			if (i != argc - 1)
 			{
-				if (fwrite(&quot; &quot;, 1, 1, config_file)!=1)
+				if (fwrite(&quot; &quot;, 1, 1, config_file) != 1)
 					break;
 			}
 		}
@@ -274,7 +274,7 @@
 			chunk = maxChunk;
 		}
 
-		if ((retval==ERROR_OK)&amp;&amp;(fwrite(((char *)data)+pos, 1, chunk, f)!=chunk))
+		if ((retval==ERROR_OK)&amp;&amp;(fwrite(((char *)data)+pos, 1, chunk, f) != chunk))
 			retval = ERROR_INVALID_ARGUMENTS;
 
 		if (retval != ERROR_OK)
@@ -613,7 +613,7 @@
 	{
 		//if (ifr-&gt;ifr_addr.sa_family == AF_INET)
 		{
-			if (strcmp(&quot;eth0&quot;, ifr-&gt;ifr_name)!=0)
+			if (strcmp(&quot;eth0&quot;, ifr-&gt;ifr_name) != 0)
 				continue;
 			strncpy(ifreq.ifr_name, ifr-&gt;ifr_name, sizeof(ifreq.ifr_name));
 			if (ioctl(SockFD, SIOCGIFHWADDR, &amp;ifreq) &lt; 0)

Modified: trunk/src/helper/jim.c
===================================================================
--- trunk/src/helper/jim.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/helper/jim.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -503,7 +503,7 @@
 static jim_wide JimPowWide(jim_wide b, jim_wide e)
 {
     jim_wide i, res = 1;
-    if ((b==0 &amp;&amp; e!=0) || (e&lt;0)) return 0;
+    if ((b==0 &amp;&amp; e != 0) || (e&lt;0)) return 0;
     for (i=0; i&lt;e; i++) {res *= b;}
     return res;
 }
@@ -6960,7 +6960,7 @@
             case JIM_EXPROP_LSHIFT: wC = wA&lt;&lt;wB; break;
             case JIM_EXPROP_RSHIFT: wC = wA&gt;&gt;wB; break;
             case JIM_EXPROP_NUMEQ: wC = wA==wB; break;
-            case JIM_EXPROP_NUMNE: wC = wA!=wB; break;
+            case JIM_EXPROP_NUMNE: wC = wA != wB; break;
             case JIM_EXPROP_BITAND: wC = wA&wB; break;
             case JIM_EXPROP_BITXOR: wC = wA^wB; break;
             case JIM_EXPROP_BITOR: wC = wA|wB; break;
@@ -7063,7 +7063,7 @@
             case JIM_EXPROP_LTE: dC = dA&lt;=dB; break;
             case JIM_EXPROP_GTE: dC = dA&gt;=dB; break;
             case JIM_EXPROP_NUMEQ: dC = dA==dB; break;
-            case JIM_EXPROP_NUMNE: dC = dA!=dB; break;
+            case JIM_EXPROP_NUMNE: dC = dA != dB; break;
             case JIM_EXPROP_LOGICAND_LEFT:
                 if (dA == 0) {
                     i += (int)dB;

Modified: trunk/src/helper/log.c
===================================================================
--- trunk/src/helper/log.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/helper/log.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -89,7 +89,7 @@
 	if (f != NULL)
 		file = f + 1;
 
-	if (strchr(string, '\n')!=NULL)
+	if (strchr(string, '\n') != NULL)
 	{
 		if (debug_level &gt;= LOG_LVL_DEBUG)
 		{

Modified: trunk/src/helper/replacements.c
===================================================================
--- trunk/src/helper/replacements.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/helper/replacements.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -35,7 +35,7 @@
 void *clear_malloc(size_t size)
 {
 	void *t = malloc(size);
-	if (t!=NULL)
+	if (t != NULL)
 	{
 		memset(t, 0x00, size);
 	}
@@ -45,7 +45,7 @@
 void *fill_malloc(size_t size)
 {
 	void *t = malloc(size);
-	if (t!=NULL)
+	if (t != NULL)
 	{
 		/* We want to initialize memory to some known bad state.  */
 		/* 0 and 0xff yields 0 and -1 as integers, which often		*/

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/bitbang.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -204,7 +204,7 @@
 
 		bitbang_interface-&gt;write(0, tms, tdi);
 
-		if (type!=SCAN_OUT)
+		if (type != SCAN_OUT)
 			val=bitbang_interface-&gt;read();
 
 		bitbang_interface-&gt;write(1, tms, tdi);

Modified: trunk/src/jtag/bitq.c
===================================================================
--- trunk/src/jtag/bitq.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/bitq.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -72,7 +72,7 @@
 							if (field-&gt;num_bits&gt;bitq_in_bufsize * 8)
 							{
 								/* buffer previously allocated? */
-								if (bitq_in_buffer!=NULL)
+								if (bitq_in_buffer != NULL)
 								{
 									/* free it */
 									free(bitq_in_buffer);
@@ -241,7 +241,7 @@
 		out_ptr  = field-&gt;out_value;
 		for (bit_cnt = field-&gt;num_bits; bit_cnt&gt;1; bit_cnt--)
 		{
-			bitq_io(0, ( (*out_ptr) &amp; out_mask )!=0, tdo_req);
+			bitq_io(0, ( (*out_ptr) &amp; out_mask ) != 0, tdo_req);
 			if (out_mask==0x80)
 			{
 				out_mask = 0x01;
@@ -251,7 +251,7 @@
 				out_mask &lt;&lt;= 1;
 		}
 
-		bitq_io(pause, ( (*out_ptr) &amp; out_mask )!=0, tdo_req);
+		bitq_io(pause, ( (*out_ptr) &amp; out_mask ) != 0, tdo_req);
 	}
 
 	if (pause)
@@ -382,7 +382,7 @@
 
 void bitq_cleanup(void)
 {
-	if (bitq_in_buffer!=NULL)
+	if (bitq_in_buffer != NULL)
 	{
 		free(bitq_in_buffer);
 		bitq_in_buffer = NULL;

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/core.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -302,7 +302,7 @@
 {
 	jtag_checks();
 
-	assert(state!=TAP_INVALID);
+	assert(state != TAP_INVALID);
 
 	cmd_queue_cur_state = state;
 }
@@ -676,7 +676,7 @@
 		LOG_ERROR(&quot;BUG: TAP_DRSHIFT/IRSHIFT can't be end state. Calling code should use a larger scan field&quot;);
 	}
 
-	if (state!=TAP_INVALID)
+	if (state != TAP_INVALID)
 		cmd_queue_end_state = state;
 	return cmd_queue_end_state;
 }
@@ -1157,7 +1157,7 @@
 	}
 
 	jtag_add_tlr();
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
+	if ((retval=jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	/* examine chain first, as this could discover the real chain layout */

Modified: trunk/src/jtag/driver.c
===================================================================
--- trunk/src/jtag/driver.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/driver.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -493,10 +493,10 @@
 	if (retval == ERROR_OK)
 	{
 		struct jtag_callback_entry *entry;
-		for (entry=jtag_callback_queue_head; entry!=NULL; entry=entry-&gt;next)
+		for (entry=jtag_callback_queue_head; entry != NULL; entry=entry-&gt;next)
 		{
 			retval=entry-&gt;callback(entry-&gt;data0, entry-&gt;data1, entry-&gt;data2, entry-&gt;data3);
-			if (retval!=ERROR_OK)
+			if (retval != ERROR_OK)
 				break;
 		}
 	}

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/ft2232.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -52,7 +52,7 @@
 
 #if (BUILD_FT2232_FTD2XX==1 &amp;&amp; BUILD_FT2232_LIBFTDI==1)
 #error &quot;BUILD_FT2232_FTD2XX &amp;&amp; BUILD_FT2232_LIBFTDI are mutually exclusive&quot;
-#elif (BUILD_FT2232_FTD2XX!=1 &amp;&amp; BUILD_FT2232_LIBFTDI!=1)
+#elif (BUILD_FT2232_FTD2XX != 1 &amp;&amp; BUILD_FT2232_LIBFTDI != 1)
 #error &quot;BUILD_FT2232_FTD2XX || BUILD_FT2232_LIBFTDI must be chosen&quot;
 #endif
 

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/jlink.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -751,7 +751,7 @@
 	for (i = 0; i &lt; length; i++)
 	{
 		int tms = (i &lt; (length - 1)) ? 0 : 1;
-		int tdi = (buffer[i / 8] &amp; (1 &lt;&lt; (i % 8)))!=0;
+		int tdi = (buffer[i / 8] &amp; (1 &lt;&lt; (i % 8))) != 0;
 		jlink_tap_append_step(tms, tdi);
 	}
 	pending_scan_results_length++;

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/jtag.h	2009-06-23 22:38:12 UTC (rev 2363)
@@ -614,7 +614,7 @@
  * matter if the operation was executed *before* jtag_execute_queue(),
  * jtag_execute_queue() will still return an error code.
  *
- * All jtag_add_xxx() calls that have in_handler!=NULL will have been
+ * All jtag_add_xxx() calls that have in_handler != NULL will have been
  * executed when this fn returns, but if what has been queued only
  * clocks data out, without reading anything back, then JTAG could
  * be running *after* jtag_execute_queue() returns. The API does

Modified: trunk/src/jtag/presto.c
===================================================================
--- trunk/src/jtag/presto.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/presto.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -279,7 +279,7 @@
 	if ((presto-&gt;status = FT_Read(presto-&gt;handle, &amp;presto_data, 1, &amp;ftbytes)) != FT_OK)
 		return ERROR_JTAG_DEVICE_ERROR;
 
-	if (ftbytes!=1)
+	if (ftbytes != 1)
 	{
 		LOG_DEBUG(&quot;PRESTO reset&quot;);
 
@@ -313,7 +313,7 @@
 		if ((presto-&gt;status = FT_Read(presto-&gt;handle, &amp;presto_data, 1, &amp;ftbytes)) != FT_OK)
 			return ERROR_JTAG_DEVICE_ERROR;
 
-		if (ftbytes!=1)
+		if (ftbytes != 1)
 		{
 			LOG_DEBUG(&quot;PRESTO not responding&quot;);
 			return ERROR_JTAG_DEVICE_ERROR;

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/tcl.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -1262,7 +1262,7 @@
 	*     args[N-2] = &quot;-endstate&quot;
 	 *     args[N-1] = statename
 	 */
-	if ((argc &lt; 4) || ((argc % 2)!=0))
+	if ((argc &lt; 4) || ((argc % 2) != 0))
 	{
 		Jim_WrongNumArgs(interp, 1, args, &quot;wrong arguments&quot;);
 		return JIM_ERR;

Modified: trunk/src/jtag/zy1000/jtag_minidriver.h
===================================================================
--- trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:38:12 UTC (rev 2363)
@@ -79,7 +79,7 @@
 }
 
 /*
- * Enter state and cause repeat transitions *out* of that state. So if the endState!=state, then
+ * Enter state and cause repeat transitions *out* of that state. So if the endState != state, then
  * the transition from state to endState counts as a transition out of state.
  */
 static __inline__ void shiftValueInner(const enum tap_state state, const enum tap_state endState, int repeat, cyg_uint32 value)
@@ -92,7 +92,7 @@
 	ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value);
 #if 1
 #if TEST_MANUAL()
-	if ((state==TAP_DRSHIFT)&amp;&amp;(endState!=TAP_DRSHIFT))
+	if ((state==TAP_DRSHIFT)&amp;&amp;(endState != TAP_DRSHIFT))
 	{
 		int i;
 		setCurrentState(state);
@@ -100,7 +100,7 @@
 		{
 			int tms;
 			tms=0;
-			if ((i==repeat-1)&amp;&amp;(state!=endState))
+			if ((i==repeat-1)&amp;&amp;(state != endState))
 			{
 				tms=1;
 			}

Modified: trunk/src/jtag/zy1000/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -133,7 +133,7 @@
 	}
 	else
 	{
-		/* Danger!!! if clk!=0 when in
+		/* Danger!!! if clk != 0 when in
 		 * idle in TAP_IDLE, reset halt on str912 will fail.
 		 */
 		ZY1000_POKE(ZY1000_JTAG_BASE+0x10, 0x00000001);
@@ -309,7 +309,7 @@
 	cyg_uint32 status;
 	ZY1000_PEEK(ZY1000_JTAG_BASE+0x10, status);
 
-	Jim_SetResult(interp, Jim_NewIntObj(interp, (status&amp;0x80)!=0));
+	Jim_SetResult(interp, Jim_NewIntObj(interp, (status&amp;0x80) != 0));
 
 	return JIM_OK;
 }
@@ -363,7 +363,7 @@
 	/* clear JTAG error register */
 	ZY1000_POKE(ZY1000_JTAG_BASE+0x14, 0x400);
 
-	if ((empty&amp;0x400)!=0)
+	if ((empty&amp;0x400) != 0)
 	{
 		LOG_WARNING(&quot;RCLK timeout&quot;);
 		/* the error is informative only as we don't want to break the firmware if there
@@ -427,7 +427,7 @@
 
 		// figure out where to store the input data
 		int num_bits=fields[i].num_bits;
-		if (fields[i].in_value!=NULL)
+		if (fields[i].in_value != NULL)
 		{
 			inBuffer=fields[i].in_value;
 		}
@@ -453,7 +453,7 @@
 			// we have (num_bits+7)/8 bytes of bits to toggle out.
 			// bits are pushed out LSB to MSB
 			value=0;
-			if (fields[i].out_value!=NULL)
+			if (fields[i].out_value != NULL)
 			{
 				for (l=0; l&lt;k; l+=8)
 				{
@@ -465,7 +465,7 @@
 
 			shiftValueInner(shiftState, pause_state, k, value);
 
-			if (inBuffer!=NULL)
+			if (inBuffer != NULL)
 			{
 				// data in, LSB to MSB
 				value=getShiftValue();

Modified: trunk/src/openocd.c
===================================================================
--- trunk/src/openocd.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/openocd.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -69,7 +69,7 @@
 /* Give TELNET a way to find out what version this is */
 static int handle_version_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	if (argc!=0)
+	if (argc != 0)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	command_print(cmd_ctx, OPENOCD_VERSION);
@@ -112,7 +112,7 @@
 static int handle_init_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 
-	if (argc!=0)
+	if (argc != 0)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	int retval;
@@ -268,14 +268,14 @@
 		return EXIT_FAILURE;
 
 #if BUILD_HTTPD
-	if (httpd_start()!=ERROR_OK)
+	if (httpd_start() != ERROR_OK)
 		return EXIT_FAILURE;
 #endif
 
 	if (ret != ERROR_COMMAND_CLOSE_CONNECTION)
 	{
 		command_context_mode(cmd_ctx, COMMAND_EXEC);
-		if (command_run_line(cmd_ctx, &quot;init&quot;)!=ERROR_OK)
+		if (command_run_line(cmd_ctx, &quot;init&quot;) != ERROR_OK)
 			return EXIT_FAILURE;
 
 		/* handle network connections */

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/server/gdb_server.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -133,7 +133,7 @@
 			return ERROR_OK;
 		}
 	}
-	*got_data=FD_ISSET(connection-&gt;fd, &amp;read_fds)!=0;
+	*got_data=FD_ISSET(connection-&gt;fd, &amp;read_fds) != 0;
 	return ERROR_OK;
 }
 
@@ -313,7 +313,7 @@
 	int gotdata;
 	for (;;)
 	{
-		if ((retval=check_pending(connection, 0, &amp;gotdata))!=ERROR_OK)
+		if ((retval=check_pending(connection, 0, &amp;gotdata)) != ERROR_OK)
 			return retval;
 		if (!gotdata)
 			break;
@@ -600,11 +600,11 @@
 		 */
 		if (gdb_con-&gt;noack_mode)
 		{
-			if ((retval=fetch_packet(connection, &amp;checksum_ok, 1, len, buffer))!=ERROR_OK)
+			if ((retval=fetch_packet(connection, &amp;checksum_ok, 1, len, buffer)) != ERROR_OK)
 				return retval;
 		} else
 		{
-			if ((retval=fetch_packet(connection, &amp;checksum_ok, 0, len, buffer))!=ERROR_OK)
+			if ((retval=fetch_packet(connection, &amp;checksum_ok, 0, len, buffer)) != ERROR_OK)
 				return retval;
 		}
 
@@ -1190,7 +1190,7 @@
 
 	retval = target_read_buffer(target, addr, len, buffer);
 
-	if ((retval!=ERROR_OK)&amp;&amp;!gdb_report_data_abort)
+	if ((retval != ERROR_OK)&amp;&amp;!gdb_report_data_abort)
 	{
 		/* TODO : Here we have to lie and send back all zero's lest stack traces won't work.
 		 * At some point this might be fixed in GDB, in which case this code can be removed.
@@ -1738,7 +1738,7 @@
 				p-&gt;base, p-&gt;size, blocksize);
 			ram_start=p-&gt;base+p-&gt;size;
 		}
-		if (ram_start!=0)
+		if (ram_start != 0)
 		{
 			xml_printf(&amp;retval, &amp;xml, &amp;pos, &amp;size, &quot;&lt;memory type=\&quot;ram\&quot; start=\&quot;0x%x\&quot; length=\&quot;0x%x\&quot;/&gt;\n&quot;,
 				ram_start, 0-ram_start);
@@ -2109,7 +2109,7 @@
 							log_add_callback(gdb_log_callback, connection);
 							target_call_event_callbacks(target, TARGET_EVENT_GDB_START);
 							int retval=gdb_step_continue_packet(connection, target, packet, packet_size);
-							if (retval!=ERROR_OK)
+							if (retval != ERROR_OK)
 							{
 								/* we'll never receive a halted condition... issue a false one.. */
 								gdb_frontend_halted(target, connection);

Modified: trunk/src/server/httpd.c
===================================================================
--- trunk/src/server/httpd.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/server/httpd.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -142,7 +142,7 @@
                                    int argc,
                                    Jim_Obj *const *argv)
 {
-    if (argc!=2)
+    if (argc != 2)
     {
         Jim_WrongNumArgs(interp, 1, argv, &quot;method ?args ...?&quot;);
         return JIM_ERR;
@@ -202,7 +202,7 @@
 
 	Jim_Obj *dict = Jim_GetVariableStr(interp, &quot;httppostdata&quot;, 0);
 
-	if (dict!=NULL)
+	if (dict != NULL)
 	{
 		if (Jim_DictKey(interp, dict, keyObj, &amp;value, 0) != JIM_OK)
 		{

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/arm7_9_common.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -263,7 +263,7 @@
 	}
 	else if (breakpoint-&gt;type == BKPT_SOFT)
 	{
-		if ((retval=arm7_9_set_software_breakpoints(arm7_9))!=ERROR_OK)
+		if ((retval=arm7_9_set_software_breakpoints(arm7_9)) != ERROR_OK)
 			return retval;
 
 		/* did we already set this breakpoint? */
@@ -922,7 +922,7 @@
 			{
 				reg_t *reg = register_get_by_name(target-&gt;reg_cache, &quot;pc&quot;, 1);
 				uint32_t t=*((uint32_t *)reg-&gt;value);
-				if (t!=0)
+				if (t != 0)
 				{
 					LOG_ERROR(&quot;PC was not 0. Does this target need srst_pulls_trst?&quot;);
 				}
@@ -1050,19 +1050,19 @@
 	jtag_add_reset(0, 0);
 
 	enum reset_types jtag_reset_config = jtag_get_reset_config();
-	if (target-&gt;reset_halt&amp;&amp;(jtag_reset_config &amp; RESET_SRST_PULLS_TRST)!=0)
+	if (target-&gt;reset_halt&amp;&amp;(jtag_reset_config &amp; RESET_SRST_PULLS_TRST) != 0)
 	{
 		LOG_WARNING(&quot;srst pulls trst - can not reset into halted mode. Issuing halt after reset.&quot;);
 		/* set up embedded ice registers again */
 		if ((retval = target_examine_one(target)) != ERROR_OK)
 			return retval;
 
-		if ((retval=target_poll(target))!=ERROR_OK)
+		if ((retval=target_poll(target)) != ERROR_OK)
 		{
 			return retval;
 		}
 
-		if ((retval=target_halt(target))!=ERROR_OK)
+		if ((retval=target_halt(target)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -1147,7 +1147,7 @@
 	int i;
 	int retval;
 
-	if ((retval=target_halt(target))!=ERROR_OK)
+	if ((retval=target_halt(target)) != ERROR_OK)
 		return retval;
 
 	long long then=timeval_ms();
@@ -1157,7 +1157,7 @@
 		if (buf_get_u32(dbg_stat-&gt;value, EICE_DBG_STATUS_DBGACK, 1) != 0)
 			break;
 		embeddedice_read_reg(dbg_stat);
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
+		if ((retval=jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		if (debug_level&gt;=3)
 		{
@@ -2576,7 +2576,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 
-	if ((retval=target_wait_state(target, TARGET_DEBUG_RUNNING, 500))!=ERROR_OK)
+	if ((retval=target_wait_state(target, TARGET_DEBUG_RUNNING, 500)) != ERROR_OK)
 		return retval;
 
 	int little=target-&gt;endianness==TARGET_LITTLE_ENDIAN;
@@ -2677,7 +2677,7 @@
 	if (retval==ERROR_OK)
 	{
 		uint32_t endaddress=buf_get_u32(reg_params[0].value, 0, 32);
-		if (endaddress!=(address+count*4))
+		if (endaddress != (address+count*4))
 		{
 			LOG_ERROR(&quot;DCC write failed, expected end address 0x%08&quot; PRIx32 &quot; got 0x%0&quot; PRIx32 &quot;&quot;, (address+count*4), endaddress);
 			retval=ERROR_FAIL;
@@ -2734,7 +2734,7 @@
 	/* convert flash writing code into a buffer in target endianness */
 	for (i = 0; i &lt; (sizeof(arm7_9_crc_code)/sizeof(uint32_t)); i++)
 	{
-		if ((retval=target_write_u32(target, crc_algorithm-&gt;address + i*sizeof(uint32_t), arm7_9_crc_code[i]))!=ERROR_OK)
+		if ((retval=target_write_u32(target, crc_algorithm-&gt;address + i*sizeof(uint32_t), arm7_9_crc_code[i])) != ERROR_OK)
 		{
 			return retval;
 		}

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/arm7tdmi.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -739,13 +739,13 @@
 		}
 		target_set_examined(target);
 	}
-	if ((retval=embeddedice_setup(target))!=ERROR_OK)
+	if ((retval=embeddedice_setup(target)) != ERROR_OK)
 		return retval;
-	if ((retval=arm7_9_setup(target))!=ERROR_OK)
+	if ((retval=arm7_9_setup(target)) != ERROR_OK)
 		return retval;
 	if (arm7_9-&gt;etm_ctx)
 	{
-		if ((retval=etm_setup(target))!=ERROR_OK)
+		if ((retval=etm_setup(target)) != ERROR_OK)
 			return retval;
 	}
 	return ERROR_OK;

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/arm9tdmi.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -831,13 +831,13 @@
 		}
 		target_set_examined(target);
 	}
-	if ((retval=embeddedice_setup(target))!=ERROR_OK)
+	if ((retval=embeddedice_setup(target)) != ERROR_OK)
 		return retval;
-	if ((retval=arm7_9_setup(target))!=ERROR_OK)
+	if ((retval=arm7_9_setup(target)) != ERROR_OK)
 		return retval;
 	if (arm7_9-&gt;etm_ctx)
 	{
-		if ((retval=etm_setup(target))!=ERROR_OK)
+		if ((retval=etm_setup(target)) != ERROR_OK)
 			return retval;
 	}
 	return ERROR_OK;

Modified: trunk/src/target/arm_adi_v5.c
===================================================================
--- trunk/src/target/arm_adi_v5.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/arm_adi_v5.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -195,7 +195,7 @@
 
 	<A HREF="https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html">https://lists.berlios.de/pipermail/openocd-development/2008-September/003107.html</A>
 	*/
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
+	if ((retval=jtag_execute_queue()) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;BUG: Why does this fail the first time????&quot;);
 	}
@@ -203,7 +203,7 @@
 #endif
 
 	scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
+	if ((retval=jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
@@ -228,7 +228,7 @@
 			}
 
 			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval=jtag_execute_queue())!=ERROR_OK)
+			if ((retval=jtag_execute_queue()) != ERROR_OK)
 				return retval;
 			swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
 		}
@@ -261,19 +261,19 @@
 			/* Clear Sticky Error Bits */
 			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_WRITE, swjdp-&gt;dp_ctrl_stat | SSTICKYORUN | SSTICKYERR, NULL);
 			scan_inout_check_u32(swjdp, DAP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-			if ((retval=jtag_execute_queue())!=ERROR_OK)
+			if ((retval=jtag_execute_queue()) != ERROR_OK)
 				return retval;
 
 			LOG_DEBUG(&quot;swjdp: status 0x%&quot; PRIx32 &quot;&quot;, ctrlstat);
 
 			dap_ap_read_reg_u32(swjdp, AP_REG_CSW, &amp;mem_ap_csw);
 			dap_ap_read_reg_u32(swjdp, AP_REG_TAR, &amp;mem_ap_tar);
-			if ((retval=jtag_execute_queue())!=ERROR_OK)
+			if ((retval=jtag_execute_queue()) != ERROR_OK)
 				return retval;
 			LOG_ERROR(&quot;Read MEM_AP_CSW 0x%&quot; PRIx32 &quot;, MEM_AP_TAR 0x%&quot; PRIx32 &quot;&quot;, mem_ap_csw, mem_ap_tar);
 
 		}
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
+		if ((retval=jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
@@ -971,7 +971,7 @@
 
 	dap_dp_write_reg(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
 	dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
+	if ((retval=jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	/* Check that we have debug power domains activated */
@@ -979,7 +979,7 @@
 	{
 		LOG_DEBUG(&quot;swjdp: wait CDBGPWRUPACK&quot;);
 		dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
+		if ((retval=jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
@@ -988,7 +988,7 @@
 	{
 		LOG_DEBUG(&quot;swjdp: wait CSYSPWRUPACK&quot;);
 		dap_dp_read_reg(swjdp, &amp;ctrlstat, DP_CTRL_STAT);
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
+		if ((retval=jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		alive_sleep(10);
 	}
@@ -1027,7 +1027,7 @@
 	dap_ap_read_reg_u32(swjdp, 0xFC, &amp;apid);
 	swjdp_transaction_endcheck(swjdp);
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-	mem_ap = ((apid&amp;0x10000)&amp;&amp;((apid&amp;0x0F)!=0));
+	mem_ap = ((apid&amp;0x10000)&amp;&amp;((apid&amp;0x0F) != 0));
 	command_print(cmd_ctx, &quot;ap identification register 0x%8.8&quot; PRIx32 &quot;&quot;, apid);
 	if (apid)
 	{

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/arm_disassembler.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -1435,7 +1435,7 @@
 			break;
 	}
 
-	if ((imm==0) &amp;&amp; (opc!=0))
+	if ((imm==0) &amp;&amp; (opc != 0))
 		imm = 32;
 
 	instruction-&gt;info.data_proc.Rd = Rd;

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/armv4_5.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -501,9 +501,9 @@
 	}
 	if (target-&gt;state != TARGET_HALTED)
 	{
-		if ((retval=target_halt(target))!=ERROR_OK)
+		if ((retval=target_halt(target)) != ERROR_OK)
 			return retval;
-		if ((retval=target_wait_state(target, TARGET_HALTED, 500))!=ERROR_OK)
+		if ((retval=target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -618,7 +618,7 @@
 
 	breakpoint_remove(target, exit_point);
 
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 		return retval;
 
 	for (i = 0; i &lt; num_mem_params; i++)

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/armv7m.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -304,9 +304,9 @@
 	/* If the target fails to halt due to the breakpoint, force a halt */
 	if (retval != ERROR_OK || target-&gt;state != TARGET_HALTED)
 	{
-		if ((retval=target_halt(target))!=ERROR_OK)
+		if ((retval=target_halt(target)) != ERROR_OK)
 			return retval;
-		if ((retval=target_wait_state(target, TARGET_HALTED, 500))!=ERROR_OK)
+		if ((retval=target_wait_state(target, TARGET_HALTED, 500)) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -356,7 +356,7 @@
 
 	for (i = 0; i &lt; num_mem_params; i++)
 	{
-		if ((retval=target_write_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value))!=ERROR_OK)
+		if ((retval=target_write_buffer(target, mem_params[i].address, mem_params[i].size, mem_params[i].value)) != ERROR_OK)
 			return retval;
 	}
 

Modified: trunk/src/target/breakpoints.c
===================================================================
--- trunk/src/target/breakpoints.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/breakpoints.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -141,7 +141,7 @@
 void breakpoint_clear_target(target_t *target)
 {
 	breakpoint_t *breakpoint;
-	while ((breakpoint = target-&gt;breakpoints)!=NULL)
+	while ((breakpoint = target-&gt;breakpoints) != NULL)
 	{
 		breakpoint_free(target, breakpoint);
 	}
@@ -260,7 +260,7 @@
 void watchpoint_clear_target(target_t *target)
 {
 	watchpoint_t *watchpoint;
-	while ((watchpoint = target-&gt;watchpoints)!=NULL)
+	while ((watchpoint = target-&gt;watchpoints) != NULL)
 	{
 		watchpoint_free(target, watchpoint);
 	}

Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/cortex_m3.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -852,7 +852,7 @@
 	if (target-&gt;reset_halt)
 	{
 		int retval;
-		if ((retval = target_halt(target))!=ERROR_OK)
+		if ((retval = target_halt(target)) != ERROR_OK)
 			return retval;
 	}
 

Modified: trunk/src/target/embeddedice.c
===================================================================
--- trunk/src/target/embeddedice.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/embeddedice.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -125,7 +125,7 @@
 
 	/* identify EmbeddedICE version by reading DCC control register */
 	embeddedice_read_reg(&amp;reg_list[EICE_COMMS_CTRL]);
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
+	if ((retval=jtag_execute_queue()) != ERROR_OK)
 	{
 		for (i = 0; i &lt; num_regs; i++)
 		{
@@ -204,7 +204,7 @@
 		reg_t *dbg_ctrl = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL];
 
 		embeddedice_read_reg(dbg_ctrl);
-		if ((retval=jtag_execute_queue())!=ERROR_OK)
+		if ((retval=jtag_execute_queue()) != ERROR_OK)
 			return retval;
 		buf_set_u32(dbg_ctrl-&gt;value, 4, 1, 0);
 		embeddedice_set_reg_w_exec(dbg_ctrl, dbg_ctrl-&gt;value);

Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/etm.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -282,7 +282,7 @@
 	buf_set_u32(etm_ctrl_reg-&gt;value, 0, etm_ctrl_reg-&gt;size, etm_ctrl_value);
 	etm_store_reg(etm_ctrl_reg);
 
-	if ((retval=jtag_execute_queue())!=ERROR_OK)
+	if ((retval=jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	if ((retval=etm_ctx-&gt;capture_driver-&gt;init(etm_ctx)) != ERROR_OK)

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/feroceon.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -688,7 +688,7 @@
 	int retval;
 
 	retval = arm9tdmi_examine(target);
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 		return retval;
 
 	armv4_5 = target-&gt;arch_info;

Modified: trunk/src/target/image.c
===================================================================
--- trunk/src/target/image.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/image.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -64,7 +64,7 @@
 	}
 	fileio_close(&amp;fileio);
 
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 		return retval;
 
 	/* check header against known signatures */
@@ -362,7 +362,7 @@
 		return ERROR_FILEIO_OPERATION_FAILED;
 	}
 
-	if (strncmp((char*)elf-&gt;header-&gt;e_ident,ELFMAG,SELFMAG)!=0)
+	if (strncmp((char*)elf-&gt;header-&gt;e_ident,ELFMAG,SELFMAG) != 0)
 	{
 		LOG_ERROR(&quot;invalid ELF file, bad magic number&quot;);
 		return ERROR_IMAGE_FORMAT_ERROR;
@@ -374,8 +374,8 @@
 	}
 
 	elf-&gt;endianness = elf-&gt;header-&gt;e_ident[EI_DATA];
-	if ((elf-&gt;endianness!=ELFDATA2LSB)
-		 &amp;&amp;(elf-&gt;endianness!=ELFDATA2MSB))
+	if ((elf-&gt;endianness != ELFDATA2LSB)
+		 &amp;&amp;(elf-&gt;endianness != ELFDATA2MSB))
 	{
 		LOG_ERROR(&quot;invalid ELF file, unknown endianess setting&quot;);
 		return ERROR_IMAGE_FORMAT_ERROR;

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/mips_m4k.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -314,7 +314,7 @@
 	if (target-&gt;reset_halt)
 	{
 		int retval;
-		if ((retval = target_halt(target))!=ERROR_OK)
+		if ((retval = target_halt(target)) != ERROR_OK)
 			return retval;
 	}
 

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/target.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -1088,7 +1088,7 @@
 	LOG_USER(&quot;target state: %s&quot;,
 		 Jim_Nvp_value2name_simple(nvp_target_state,target-&gt;state)-&gt;name);
 
-	if (target-&gt;state!=TARGET_HALTED)
+	if (target-&gt;state != TARGET_HALTED)
 		return ERROR_OK;
 
 	retval=target-&gt;type-&gt;arch_state(target);
@@ -1584,7 +1584,7 @@
 	static int prevPowerdropout = 0;
 
 	int retval;
-	if ((retval=jtag_power_dropout(&amp;powerDropout))!=ERROR_OK)
+	if ((retval=jtag_power_dropout(&amp;powerDropout)) != ERROR_OK)
 		return retval;
 
 	int powerRestored;
@@ -1603,7 +1603,7 @@
 		lastPower = current;
 	}
 
-	if ((retval=jtag_srst_asserted(&amp;srstAsserted))!=ERROR_OK)
+	if ((retval=jtag_srst_asserted(&amp;srstAsserted)) != ERROR_OK)
 		return retval;
 
 	int srstDeasserted;
@@ -1909,7 +1909,7 @@
 
 	for (;;)
 	{
-		if ((retval=target_poll(target))!=ERROR_OK)
+		if ((retval=target_poll(target)) != ERROR_OK)
 			return retval;
 		if (target-&gt;state == state)
 		{
@@ -2872,7 +2872,7 @@
 	/*append binary memory gmon.out profile_hist_data (profile_hist_data + profile_hist_hdr.hist_size) */
 
 	char *data=malloc(2*length);
-	if (data!=NULL)
+	if (data != NULL)
 	{
 		for (i=0; i&lt;length;i++)
 		{
@@ -2903,7 +2903,7 @@
 	struct timeval timeout, now;
 
 	gettimeofday(&amp;timeout, NULL);
-	if (argc!=2)
+	if (argc != 2)
 	{
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
@@ -2949,7 +2949,7 @@
 			retval=ERROR_OK;
 			break;
 		}
-		if (retval!=ERROR_OK)
+		if (retval != ERROR_OK)
 		{
 			break;
 		}
@@ -3388,7 +3388,7 @@
 					   e,
 					   Jim_Nvp_value2name_simple( nvp_target_event, e )-&gt;name,
 					   Jim_GetString( teap-&gt;body, NULL ) );
-			if (Jim_EvalObj( interp, teap-&gt;body )!=JIM_OK)
+			if (Jim_EvalObj( interp, teap-&gt;body ) != JIM_OK)
 			{
 				Jim_PrintErrorMessage(interp);
 			}
@@ -4386,7 +4386,7 @@
 
 static void free_fastload(void)
 {
-	if (fastload!=NULL)
+	if (fastload != NULL)
 	{
 		int i;
 		for (i=0; i&lt;fastload_num; i++)
@@ -4504,7 +4504,7 @@
 
 	image_close(&amp;image);
 
-	if (retval!=ERROR_OK)
+	if (retval != ERROR_OK)
 	{
 		free_fastload();
 	}

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-06-23 22:37:56 UTC (rev 2362)
+++ trunk/src/target/xscale.c	2009-06-23 22:38:12 UTC (rev 2363)
@@ -889,7 +889,7 @@
 			retval=target_read_u32(target, 0xffff0000 + 4*i, &amp;xscale-&gt;high_vectors[i]);
 			if (retval == ERROR_TARGET_TIMEOUT)
 				return retval;
-			if (retval!=ERROR_OK)
+			if (retval != ERROR_OK)
 			{
 				/* Some of these reads will fail as part of normal execution */
 				xscale-&gt;high_vectors[i] = ARMV4_5_B(0xfffffe, 0);
@@ -908,7 +908,7 @@
 			retval=target_read_u32(target, 0x0 + 4*i, &amp;xscale-&gt;low_vectors[i]);
 			if (retval == ERROR_TARGET_TIMEOUT)
 				return retval;
-			if (retval!=ERROR_OK)
+			if (retval != ERROR_OK)
 			{
 				/* Some of these reads will fail as part of normal execution */
 				xscale-&gt;low_vectors[i] = ARMV4_5_B(0xfffffe, 0);
@@ -1028,11 +1028,11 @@
 
 	/* clear external dbg break (will be written on next DCSR read) */
 	xscale-&gt;external_debug_break = 0;
-	if ((retval=xscale_read_dcsr(target))!=ERROR_OK)
+	if ((retval=xscale_read_dcsr(target)) != ERROR_OK)
 		return retval;
 
 	/* get r0, pc, r1 to r7 and cpsr */
-	if ((retval=xscale_receive(target, buffer, 10))!=ERROR_OK)
+	if ((retval=xscale_receive(target, buffer, 10)) != ERROR_OK)
 		return retval;
 
 	/* move r0 from buffer to register cache */
@@ -1253,7 +1253,7 @@
 		}
 	}
 
-	if ((retval=xscale_set_reg_u32(ibcr0, next_pc | 0x1))!=ERROR_OK)
+	if ((retval=xscale_set_reg_u32(ibcr0, next_pc | 0x1)) != ERROR_OK)
 		return retval;
 
 	return ERROR_OK;
@@ -1266,7 +1266,7 @@
 	reg_t *ibcr0 = &amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_IBCR0];
 	int retval;
 
-	if ((retval=xscale_set_reg_u32(ibcr0, 0x0))!=ERROR_OK)
+	if ((retval=xscale_set_reg_u32(ibcr0, 0x0)) != ERROR_OK)
 		return retval;
 
 	return ERROR_OK;
@@ -1297,7 +1297,7 @@
 	}
 
 	/* update vector tables */
-	if ((retval=xscale_update_vectors(target))!=ERROR_OK)
+	if ((retval=xscale_update_vectors(target)) != ERROR_OK)
 		return retval;
 
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
@@ -1451,56 +1451,56 @@
 	}
 
 	LOG_DEBUG(&quot;enable single-step&quot;);
-	if ((retval=xscale_enable_single_step(target, next_pc))!=ERROR_OK)
+	if ((retval=xscale_enable_single_step(target, next_pc)) != ERROR_OK)
 		return retval;
 
 	/* restore banked registers */
-	if ((retval=xscale_restore_context(target))!=ERROR_OK)
+	if ((retval=xscale_restore_context(target)) != ERROR_OK)
 		return retval;
 
 	/* send resume request (command 0x30 or 0x31)
 	 * clean the trace buffer if it is to be enabled (0x62) */
 	if (xscale-&gt;trace.buffer_enabled)
 	{
-		if ((retval=xscale_send_u32(target, 0x62))!=ERROR_OK)
+		if ((retval=xscale_send_u32(target, 0x62)) != ERROR_OK)
 			return retval;
-		if ((retval=xscale_send_u32(target, 0x31))!=ERROR_OK)
+		if ((retval=xscale_send_u32(target, 0x31)) != ERROR_OK)
 			return retval;
 	}
 	else
-		if ((retval=xscale_send_u32(target, 0x30))!=ERROR_OK)
+		if ((retval=xscale_send_u32(target, 0x30)) != ERROR_OK)
 			return retval;
 
 	/* send CPSR */
-	if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32)))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32))) != ERROR_OK)
 		return retval;
 	LOG_DEBUG(&quot;writing cpsr with value 0x%8.8&quot; PRIx32 &quot;&quot;, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32));
 
 	for (i = 7; i &gt;= 0; i--)
 	{
 		/* send register */
-		if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[i].value, 0, 32)))!=ERROR_OK)
+		if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[i].value, 0, 32))) != ERROR_OK)
 			return retval;
 		LOG_DEBUG(&quot;writing r%i with value 0x%8.8&quot; PRIx32 &quot;&quot;, i, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[i].value, 0, 32));
 	}
 
 	/* send PC */
-	if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32)))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))) != ERROR_OK)
 		return retval;
 	LOG_DEBUG(&quot;writing PC with value 0x%8.8&quot; PRIx32, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32));
 
 	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 
 	/* registers are now invalid */
-	if ((retval=armv4_5_invalidate_core_regs(target))!=ERROR_OK)
+	if ((retval=armv4_5_invalidate_core_regs(target)) != ERROR_OK)
 		return retval;
 
 	/* wait for and process debug entry */
-	if ((retval=xscale_debug_entry(target))!=ERROR_OK)
+	if ((retval=xscale_debug_entry(target)) != ERROR_OK)
 		return retval;
 
 	LOG_DEBUG(&quot;disable single-step&quot;);
-	if ((retval=xscale_disable_single_step(target))!=ERROR_OK)
+	if ((retval=xscale_disable_single_step(target)) != ERROR_OK)
 		return retval;
 
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
@@ -1531,7 +1531,7 @@
 	/* if we're at the reset vector, we have to simulate the step */
 	if (current_pc == 0x0)
 	{
-		if ((retval=arm_simulate_step(target, NULL))!=ERROR_OK)
+		if ((retval=arm_simulate_step(target, NULL)) != ERROR_OK)
 			return retval;
 		current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 
@@ -1545,7 +1545,7 @@
 	if (handle_breakpoints)
 		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32))))
 		{
-			if ((retval=xscale_unset_breakpoint(target, breakpoint))!=ERROR_OK)
+			if ((retval=xscale_unset_breakpoint(target, breakpoint)) != ERROR_OK)
 				return retval;
 		}
 
@@ -1597,7 +1597,7 @@
     if (target-&gt;reset_halt)
     {
 	int retval;
-		if ((retval = target_halt(target))!=ERROR_OK)
+		if ((retval = target_halt(target)) != ERROR_OK)
 			return retval;
     }
 
@@ -1930,20 +1930,20 @@
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
 	/* send memory read request (command 0x1n, n: access size) */
-	if ((retval=xscale_send_u32(target, 0x10 | size))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, 0x10 | size)) != ERROR_OK)
 		return retval;
 
 	/* send base address for read request */
-	if ((retval=xscale_send_u32(target, address))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, address)) != ERROR_OK)
 		return retval;
 
 	/* send number of requested data words */
-	if ((retval=xscale_send_u32(target, count))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, count)) != ERROR_OK)
 		return retval;
 
 	/* receive data from target (count times 32-bit words in host endianness) */
 	buf32 = malloc(4 * count);
-	if ((retval=xscale_receive(target, buf32, count))!=ERROR_OK)
+	if ((retval=xscale_receive(target, buf32, count)) != ERROR_OK)
 		return retval;
 
 	/* extract data from host-endian buffer into byte stream */
@@ -1971,12 +1971,12 @@
 	free(buf32);
 
 	/* examine DCSR, to see if Sticky Abort (SA) got set */
-	if ((retval=xscale_read_dcsr(target))!=ERROR_OK)
+	if ((retval=xscale_read_dcsr(target)) != ERROR_OK)
 		return retval;
 	if (buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value, 5, 1) == 1)
 	{
 		/* clear SA bit */
-		if ((retval=xscale_send_u32(target, 0x60))!=ERROR_OK)
+		if ((retval=xscale_send_u32(target, 0x60)) != ERROR_OK)
 			return retval;
 
 		return ERROR_TARGET_DATA_ABORT;
@@ -2007,15 +2007,15 @@
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 
 	/* send memory write request (command 0x2n, n: access size) */
-	if ((retval=xscale_send_u32(target, 0x20 | size))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, 0x20 | size)) != ERROR_OK)
 		return retval;
 
 	/* send base address for read request */
-	if ((retval=xscale_send_u32(target, address))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, address)) != ERROR_OK)
 		return retval;
 
 	/* send number of requested data words to be written*/
-	if ((retval=xscale_send_u32(target, count))!=ERROR_OK)
+	if ((retval=xscale_send_u32(target, count)) != ERROR_OK)
 		return retval;
 
 	/* extract data from host-endian buffer into byte stream */
@@ -2045,16 +2045,16 @@
 		}
 	}
 #endif
-	if ((retval=xscale_send(target, buffer, count, size))!=ERROR_OK)
+	if ((retval=xscale_send(target, buffer, count, size)) != ERROR_OK)
 		return retval;
 
 	/* examine DCSR, to see if Sticky Abort (SA) got set */
-	if ((retval=xscale_read_dcsr(target))!=ERROR_OK)
+	if ((retval=xscale_read_dcsr(target)) != ERROR_OK)
 		return retval;
 	if (buf_get_u32(xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value, 5, 1) == 1)
 	{
 		/* clear SA bit */
-		if ((retval=xscale_send_u32(target, 0x60))!=ERROR_OK)
+		if ((retval=xscale_send_u32(target, 0x60)) != ERROR_OK)
 			return retval;
 
 		return ERROR_TARGET_DATA_ABORT;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001146.html">[Openocd-svn] r2362 - in trunk/src: server target
</A></li>
	<LI>Next message: <A HREF="001148.html">[Openocd-svn] r2364 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1147">[ date ]</a>
              <a href="thread.html#1147">[ thread ]</a>
              <a href="subject.html#1147">[ subject ]</a>
              <a href="author.html#1147">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
