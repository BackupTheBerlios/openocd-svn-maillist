<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2278 - trunk/src/target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2278%20-%20trunk/src/target&In-Reply-To=%3C200906180709.n5I79TmT016057%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001061.html">
   <LINK REL="Next"  HREF="001063.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2278 - trunk/src/target</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2278%20-%20trunk/src/target&In-Reply-To=%3C200906180709.n5I79TmT016057%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2278 - trunk/src/target">zwelch at mail.berlios.de
       </A><BR>
    <I>Thu Jun 18 09:09:29 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001061.html">[Openocd-svn] r2277 - in trunk/src: flash helper jtag jtag/rlink	target
</A></li>
        <LI>Next message: <A HREF="001063.html">[Openocd-svn] r2279 - trunk/src/target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1062">[ date ]</a>
              <a href="thread.html#1062">[ thread ]</a>
              <a href="subject.html#1062">[ subject ]</a>
              <a href="author.html#1062">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-18 09:08:52 +0200 (Thu, 18 Jun 2009)
New Revision: 2278

Modified:
   trunk/src/target/arm11.c
   trunk/src/target/arm11.h
   trunk/src/target/arm11_dbgtap.c
   trunk/src/target/arm720t.c
   trunk/src/target/arm720t.h
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7_9_common.h
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm920t.c
   trunk/src/target/arm920t.h
   trunk/src/target/arm926ejs.c
   trunk/src/target/arm926ejs.h
   trunk/src/target/arm966e.c
   trunk/src/target/arm966e.h
   trunk/src/target/arm9tdmi.c
   trunk/src/target/arm9tdmi.h
   trunk/src/target/arm_adi_v5.c
   trunk/src/target/arm_adi_v5.h
   trunk/src/target/arm_disassembler.c
   trunk/src/target/arm_disassembler.h
   trunk/src/target/arm_jtag.c
   trunk/src/target/arm_jtag.h
   trunk/src/target/arm_simulator.c
   trunk/src/target/arm_simulator.h
   trunk/src/target/armv4_5.c
   trunk/src/target/armv4_5.h
   trunk/src/target/armv4_5_cache.c
   trunk/src/target/armv4_5_cache.h
   trunk/src/target/armv4_5_mmu.c
   trunk/src/target/armv4_5_mmu.h
   trunk/src/target/armv7m.c
   trunk/src/target/armv7m.h
Log:
Transform 'u32' to 'uint32_t' in src/target/arm*
- Replace '\([^_]\)u32' with '\1uint32_t'.
- Replace '^u32' with 'uint32_t'.


Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm11.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -50,7 +50,7 @@
 
 bool	arm11_config_memwrite_burst				= true;
 bool	arm11_config_memwrite_error_fatal		= true;
-u32		arm11_vcr								= 0;
+uint32_t		arm11_vcr								= 0;
 bool	arm11_config_memrw_no_increment			= false;
 bool	arm11_config_step_irq_enable			= false;
 
@@ -132,7 +132,7 @@
 typedef struct arm11_reg_defs_s
 {
 	char *					name;
-	u32						num;
+	uint32_t						num;
 	int						gdb_num;
 	enum arm11_regtype		type;
 } arm11_reg_defs_t;
@@ -311,11 +311,11 @@
  *					available a pointer to a word holding the
  *					DSCR can be passed. Otherwise use NULL.
  */
-int arm11_check_init(arm11_common_t * arm11, u32 * dscr)
+int arm11_check_init(arm11_common_t * arm11, uint32_t * dscr)
 {
 	FNC_INFO;
 
-	u32			dscr_local_tmp_copy;
+	uint32_t			dscr_local_tmp_copy;
 
 	if (!dscr)
 	{
@@ -408,7 +408,7 @@
 	/* ARM1176 spec says this is needed only for wDTR/rDTR's &quot;ITR mode&quot;, but not to issue ITRs
 	   ARM1136 seems to require this to issue ITR's as well */
 
-	u32 new_dscr = R(DSCR) | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
+	uint32_t new_dscr = R(DSCR) | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
 
 	/* this executes JTAG queue: */
 
@@ -430,7 +430,7 @@
 		/* mcr	   15, 0, r0, cr7, cr10, {4} */
 		arm11_run_instr_no_data1(arm11, 0xee070f9a);
 
-		u32 dscr = arm11_read_DSCR(arm11);
+		uint32_t dscr = arm11_read_DSCR(arm11);
 
 		LOG_DEBUG(&quot;DRAIN, DSCR %08x&quot;, dscr);
 
@@ -579,7 +579,7 @@
 	/* spec says clear wDTR and rDTR; we assume they are clear as
 	   otherwise our programming would be sloppy */
 	{
-		u32 DSCR;
+		uint32_t DSCR;
 
 		CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;DSCR));
 
@@ -668,7 +668,7 @@
 	if (arm11-&gt;trst_active)
 		return ERROR_OK;
 
-	u32	dscr;
+	uint32_t	dscr;
 
 	CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
 
@@ -717,7 +717,7 @@
 }
 
 /* target request support */
-int arm11_target_request_data(struct target_s *target, u32 size, uint8_t *buffer)
+int arm11_target_request_data(struct target_s *target, uint32_t size, uint8_t *buffer)
 {
 	FNC_INFO_NOTIMPLEMENTED;
 
@@ -755,7 +755,7 @@
 
 	CHECK_RETVAL(jtag_execute_queue());
 
-	u32 dscr;
+	uint32_t dscr;
 
 	while (1)
 	{
@@ -779,7 +779,7 @@
 	return ERROR_OK;
 }
 
-int arm11_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
+int arm11_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	FNC_INFO;
 
@@ -856,7 +856,7 @@
 
 	while (1)
 	{
-		u32 dscr;
+		uint32_t dscr;
 
 		CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
 
@@ -884,7 +884,7 @@
 	return ERROR_OK;
 }
 
-int arm11_step(struct target_s *target, int current, u32 address, int handle_breakpoints)
+int arm11_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	FNC_INFO;
 
@@ -906,7 +906,7 @@
 
 	/** \todo TODO: Thumb not supported here */
 
-	u32	next_instruction;
+	uint32_t	next_instruction;
 
 	CHECK_RETVAL(arm11_read_memory_word(arm11, R(PC), &amp;next_instruction));
 
@@ -975,7 +975,7 @@
 
 		while (1)
 		{
-			u32 dscr;
+			uint32_t dscr;
 
 			CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
 
@@ -1090,9 +1090,9 @@
  * size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
  * count: number of items of &lt;size&gt;
  */
-int arm11_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm11_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
-	/** \todo TODO: check if buffer cast to u32* and uint16_t* might cause alignment problems */
+	/** \todo TODO: check if buffer cast to uint32_t* and uint16_t* might cause alignment problems */
 
 	FNC_INFO;
 
@@ -1124,7 +1124,7 @@
 			arm11_run_instr_no_data1(arm11,
 					!arm11_config_memrw_no_increment ? 0xe4d01001 : 0xe5d01000);
 
-			u32 res;
+			uint32_t res;
 			/* MCR p14,0,R1,c0,c5,0 */
 			arm11_run_instr_data_from_core(arm11, 0xEE001E15, &amp;res, 1);
 
@@ -1143,7 +1143,7 @@
 				arm11_run_instr_no_data1(arm11,
 					!arm11_config_memrw_no_increment ? 0xe0d010b2 : 0xe1d010b0);
 
-				u32 res;
+				uint32_t res;
 
 				/* MCR p14,0,R1,c0,c5,0 */
 				arm11_run_instr_data_from_core(arm11, 0xEE001E15, &amp;res, 1);
@@ -1157,9 +1157,9 @@
 
 	case 4:
 		{
-		u32 instr = !arm11_config_memrw_no_increment ? 0xecb05e01 : 0xed905e00;
-		/** \todo TODO: buffer cast to u32* causes alignment warnings */
-		u32 *words = (u32 *)buffer;
+		uint32_t instr = !arm11_config_memrw_no_increment ? 0xecb05e01 : 0xed905e00;
+		/** \todo TODO: buffer cast to uint32_t* causes alignment warnings */
+		uint32_t *words = (uint32_t *)buffer;
 
 		/* LDC p14,c5,[R0],#4 */
 		/* LDC p14,c5,[R0] */
@@ -1173,7 +1173,7 @@
 	return ERROR_OK;
 }
 
-int arm11_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm11_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	FNC_INFO;
 
@@ -1234,10 +1234,10 @@
 		}
 
 	case 4: {
-		u32 instr = !arm11_config_memrw_no_increment ? 0xeca05e01 : 0xed805e00;
+		uint32_t instr = !arm11_config_memrw_no_increment ? 0xeca05e01 : 0xed805e00;
 
-		/** \todo TODO: buffer cast to u32* causes alignment warnings */
-		u32 *words = (u32*)buffer;
+		/** \todo TODO: buffer cast to uint32_t* causes alignment warnings */
+		uint32_t *words = (uint32_t*)buffer;
 
 		if (!arm11_config_memwrite_burst)
 		{
@@ -1260,7 +1260,7 @@
 	/* r0 verification */
 	if (!arm11_config_memrw_no_increment)
 	{
-		u32 r0;
+		uint32_t r0;
 
 		/* MCR p14,0,R0,c0,c5,0 */
 		arm11_run_instr_data_from_core(arm11, 0xEE000E15, &amp;r0, 1);
@@ -1285,7 +1285,7 @@
 
 
 /* write target memory in multiples of 4 byte, optimized for writing large quantities of data */
-int arm11_bulk_write_memory(struct target_s *target, u32 address, u32 count, uint8_t *buffer)
+int arm11_bulk_write_memory(struct target_s *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	FNC_INFO;
 
@@ -1302,7 +1302,7 @@
  * fallback code will read data from the target and calculate the CRC on the
  * host.
  */
-int arm11_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum)
+int arm11_checksum_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum)
 {
 	return ERROR_FAIL;
 }
@@ -1369,14 +1369,14 @@
 // HACKHACKHACK - FIXME mode/state
 /* target algorithm support */
 int arm11_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params,
-			int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point,
+			int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point,
 			int timeout_ms, void *arch_info)
 {
 		arm11_common_t *arm11 = target-&gt;arch_info;
 //	enum armv4_5_state core_state = arm11-&gt;core_state;
 //	enum armv4_5_mode core_mode = arm11-&gt;core_mode;
-	u32 context[16];
-	u32 cpsr;
+	uint32_t context[16];
+	uint32_t cpsr;
 	int exit_breakpoint_size = 0;
 	int retval = ERROR_OK;
 		LOG_DEBUG(&quot;Running algorithm&quot;);
@@ -1819,7 +1819,7 @@
 	return ERROR_OK;
 }
 
-const u32 arm11_coproc_instruction_limits[] =
+const uint32_t arm11_coproc_instruction_limits[] =
 {
 	15,				/* coprocessor */
 	7,				/* opcode 1 */
@@ -1879,7 +1879,7 @@
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	u32	values[6];
+	uint32_t	values[6];
 
 	for (size_t i = 0; i &lt; (read ? 5 : 6); i++)
 	{
@@ -1894,7 +1894,7 @@
 		}
 	}
 
-	u32 instr = 0xEE000010	|
+	uint32_t instr = 0xEE000010	|
 		(values[0] &lt;&lt;  8) |
 		(values[1] &lt;&lt; 21) |
 		(values[2] &lt;&lt; 16) |
@@ -1908,7 +1908,7 @@
 
 	if (read)
 	{
-		u32 result;
+		uint32_t result;
 		arm11_run_instr_data_from_core_via_r0(arm11, instr, &amp;result);
 
 		LOG_INFO(&quot;MRC p%d, %d, R0, c%d, c%d, %d = 0x%08x (%d)&quot;,

Modified: trunk/src/target/arm11.h
===================================================================
--- trunk/src/target/arm11.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm11.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -65,7 +65,7 @@
 
 typedef struct arm11_register_history_s
 {
-	u32		value;
+	uint32_t		value;
 	uint8_t		valid;
 }arm11_register_history_t;
 
@@ -84,8 +84,8 @@
 	/** \name Processor type detection */
 	/*@{*/
 
-	u32		device_id;		/**&lt; IDCODE readout				*/
-	u32		didr;			/**&lt; DIDR readout (debug capabilities)	*/
+	uint32_t		device_id;		/**&lt; IDCODE readout				*/
+	uint32_t		didr;			/**&lt; DIDR readout (debug capabilities)	*/
 	uint8_t		implementor;	/**&lt; DIDR Implementor readout		*/
 
 	size_t	brp;			/**&lt; Number of Breakpoint Register Pairs from DIDR	*/
@@ -95,7 +95,7 @@
 		debug_version;		/**&lt; ARM debug architecture from DIDR	*/
 	/*@}*/
 
-	u32		last_dscr;		/**&lt; Last retrieved DSCR value;
+	uint32_t		last_dscr;		/**&lt; Last retrieved DSCR value;
 							     Use only for debug message generation		*/
 
 	bool	trst_active;
@@ -108,7 +108,7 @@
 	/*@{*/
 
 	reg_t *	reg_list;							/**&lt; target register list */
-	u32		reg_values[ARM11_REGCACHE_COUNT];	/**&lt; data for registers */
+	uint32_t		reg_values[ARM11_REGCACHE_COUNT];	/**&lt; data for registers */
 
 	/*@}*/
 
@@ -181,7 +181,7 @@
 
 typedef struct arm11_reg_state_s
 {
-	u32				def_index;
+	uint32_t				def_index;
 	target_t *			target;
 } arm11_reg_state_t;
 
@@ -191,12 +191,12 @@
 int arm11_arch_state(struct target_s *target);
 
 /* target request support */
-int arm11_target_request_data(struct target_s *target, u32 size, uint8_t *buffer);
+int arm11_target_request_data(struct target_s *target, uint32_t size, uint8_t *buffer);
 
 /* target execution control */
 int arm11_halt(struct target_s *target);
-int arm11_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
-int arm11_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
+int arm11_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+int arm11_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints);
 int arm11_examine(struct target_s *target);
 
 /* target reset control */
@@ -211,13 +211,13 @@
 * size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
 * count: number of items of &lt;size&gt;
 */
-int arm11_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int arm11_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm11_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int arm11_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 /* write target memory in multiples of 4 byte, optimized for writing large quantities of data */
-int arm11_bulk_write_memory(struct target_s *target, u32 address, u32 count, uint8_t *buffer);
+int arm11_bulk_write_memory(struct target_s *target, uint32_t address, uint32_t count, uint8_t *buffer);
 
-int arm11_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum);
+int arm11_checksum_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum);
 
 /* target break-/watchpoint control
 * rw: 0 = write, 1 = read, 2 = access
@@ -228,7 +228,7 @@
 int arm11_remove_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
 
 /* target algorithm support */
-int arm11_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info);
+int arm11_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_param, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
 
 int arm11_register_commands(struct command_context_s *cmd_ctx);
 int arm11_target_create(struct target_s *target, Jim_Interp *interp);
@@ -248,22 +248,22 @@
 void arm11_setup_field			(arm11_common_t * arm11, int num_bits, void * in_data, void * out_data, scan_field_t * field);
 void arm11_add_IR				(arm11_common_t * arm11, uint8_t instr, tap_state_t state);
 void arm11_add_debug_SCAN_N		(arm11_common_t * arm11, uint8_t chain, tap_state_t state);
-void arm11_add_debug_INST		(arm11_common_t * arm11, u32 inst, uint8_t * flag, tap_state_t state);
-int arm11_read_DSCR				(arm11_common_t * arm11, u32 *dscr);
-int arm11_write_DSCR			(arm11_common_t * arm11, u32 dscr);
+void arm11_add_debug_INST		(arm11_common_t * arm11, uint32_t inst, uint8_t * flag, tap_state_t state);
+int arm11_read_DSCR				(arm11_common_t * arm11, uint32_t *dscr);
+int arm11_write_DSCR			(arm11_common_t * arm11, uint32_t dscr);
 
-enum target_debug_reason arm11_get_DSCR_debug_reason(u32 dscr);
+enum target_debug_reason arm11_get_DSCR_debug_reason(uint32_t dscr);
 
 void arm11_run_instr_data_prepare			(arm11_common_t * arm11);
 void arm11_run_instr_data_finish			(arm11_common_t * arm11);
-int arm11_run_instr_no_data					(arm11_common_t * arm11, u32 * opcode, size_t count);
-void arm11_run_instr_no_data1				(arm11_common_t * arm11, u32 opcode);
-int arm11_run_instr_data_to_core			(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
-int arm11_run_instr_data_to_core_noack		(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
-int arm11_run_instr_data_to_core1			(arm11_common_t * arm11, u32 opcode, u32 data);
-int arm11_run_instr_data_from_core			(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count);
-void arm11_run_instr_data_from_core_via_r0	(arm11_common_t * arm11, u32 opcode, u32 * data);
-void arm11_run_instr_data_to_core_via_r0	(arm11_common_t * arm11, u32 opcode, u32 data);
+int arm11_run_instr_no_data					(arm11_common_t * arm11, uint32_t * opcode, size_t count);
+void arm11_run_instr_no_data1				(arm11_common_t * arm11, uint32_t opcode);
+int arm11_run_instr_data_to_core			(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count);
+int arm11_run_instr_data_to_core_noack		(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count);
+int arm11_run_instr_data_to_core1			(arm11_common_t * arm11, uint32_t opcode, uint32_t data);
+int arm11_run_instr_data_from_core			(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count);
+void arm11_run_instr_data_from_core_via_r0	(arm11_common_t * arm11, uint32_t opcode, uint32_t * data);
+void arm11_run_instr_data_to_core_via_r0	(arm11_common_t * arm11, uint32_t opcode, uint32_t data);
 
 int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state);
 int arm11_add_ir_scan_vc(int num_fields, scan_field_t *fields, tap_state_t state);
@@ -276,7 +276,7 @@
 {
 	bool	write;				/**&lt; Access mode: true for write, false for read.	*/
 	uint8_t		address;			/**&lt; Register address mode. Use enum #arm11_sc7		*/
-	u32		value;				/**&lt; If write then set this to value to be written.
+	uint32_t		value;				/**&lt; If write then set this to value to be written.
 									 In read mode this receives the read value when the
 									 function returns.					*/
 } arm11_sc7_action_t;
@@ -285,8 +285,8 @@
 
 /* Mid-level helper functions */
 void arm11_sc7_clear_vbw(arm11_common_t * arm11);
-void arm11_sc7_set_vcr(arm11_common_t * arm11, u32 value);
+void arm11_sc7_set_vcr(arm11_common_t * arm11, uint32_t value);
 
-int arm11_read_memory_word(arm11_common_t * arm11, u32 address, u32 * result);
+int arm11_read_memory_word(arm11_common_t * arm11, uint32_t address, uint32_t * result);
 
 #endif /* ARM11_H */

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm11_dbgtap.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -195,7 +195,7 @@
  *
  * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
-void arm11_add_debug_INST(arm11_common_t * arm11, u32 inst, uint8_t * flag, tap_state_t state)
+void arm11_add_debug_INST(arm11_common_t * arm11, uint32_t inst, uint8_t * flag, tap_state_t state)
 {
 	JTAG_DEBUG(&quot;INST &lt;= 0x%08x&quot;, inst);
 
@@ -217,13 +217,13 @@
  *
  * \remarks			This is a stand-alone function that executes the JTAG command queue.
  */
-int arm11_read_DSCR(arm11_common_t * arm11, u32 *value)
+int arm11_read_DSCR(arm11_common_t * arm11, uint32_t *value)
 {
 	arm11_add_debug_SCAN_N(arm11, 0x01, ARM11_TAP_DEFAULT);
 
 	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
 
-	u32				dscr;
+	uint32_t				dscr;
 	scan_field_t	chain1_field;
 
 	arm11_setup_field(arm11, 32, NULL, &amp;dscr, &amp;chain1_field);
@@ -251,7 +251,7 @@
  *
  * \remarks			This is a stand-alone function that executes the JTAG command queue.
  */
-int arm11_write_DSCR(arm11_common_t * arm11, u32 dscr)
+int arm11_write_DSCR(arm11_common_t * arm11, uint32_t dscr)
 {
 	arm11_add_debug_SCAN_N(arm11, 0x01, ARM11_TAP_DEFAULT);
 
@@ -280,7 +280,7 @@
  * \return			Debug reason
  *
  */
-enum target_debug_reason arm11_get_DSCR_debug_reason(u32 dscr)
+enum target_debug_reason arm11_get_DSCR_debug_reason(uint32_t dscr)
 {
 	switch (dscr &amp; ARM11_DSCR_METHOD_OF_DEBUG_ENTRY_MASK)
 	{
@@ -364,7 +364,7 @@
  * \param count		Number of opcodes to execute
  *
  */
-int arm11_run_instr_no_data(arm11_common_t * arm11, u32 * opcode, size_t count)
+int arm11_run_instr_no_data(arm11_common_t * arm11, uint32_t * opcode, size_t count)
 {
 	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
@@ -396,7 +396,7 @@
  * \param opcode	ARM opcode
  *
  */
-void arm11_run_instr_no_data1(arm11_common_t * arm11, u32 opcode)
+void arm11_run_instr_no_data1(arm11_common_t * arm11, uint32_t opcode)
 {
 	arm11_run_instr_no_data(arm11, &amp;opcode, 1);
 }
@@ -415,7 +415,7 @@
  * \param count		Number of data words and instruction repetitions
  *
  */
-int arm11_run_instr_data_to_core(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count)
+int arm11_run_instr_data_to_core(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count)
 {
 	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
@@ -425,7 +425,7 @@
 
 	scan_field_t	chain5_fields[3];
 
-	u32				Data;
+	uint32_t				Data;
 	uint8_t				Ready;
 	uint8_t				nRetry;
 
@@ -502,7 +502,7 @@
  * \param count		Number of data words and instruction repetitions
  *
  */
-int arm11_run_instr_data_to_core_noack(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count)
+int arm11_run_instr_data_to_core_noack(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count)
 {
 	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
@@ -573,7 +573,7 @@
  * \param data		Data word to be passed to the core via DTR
  *
  */
-int arm11_run_instr_data_to_core1(arm11_common_t * arm11, u32 opcode, u32 data)
+int arm11_run_instr_data_to_core1(arm11_common_t * arm11, uint32_t opcode, uint32_t data)
 {
 	return arm11_run_instr_data_to_core(arm11, opcode, &amp;data, 1);
 }
@@ -592,7 +592,7 @@
  * \param count		Number of data words and instruction repetitions
  *
  */
-int arm11_run_instr_data_from_core(arm11_common_t * arm11, u32 opcode, u32 * data, size_t count)
+int arm11_run_instr_data_from_core(arm11_common_t * arm11, uint32_t opcode, uint32_t * data, size_t count)
 {
 	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
 
@@ -602,7 +602,7 @@
 
 	scan_field_t	chain5_fields[3];
 
-	u32			Data;
+	uint32_t			Data;
 	uint8_t			Ready;
 	uint8_t			nRetry;
 
@@ -640,7 +640,7 @@
  * \param data		Pointer to a data word that receives the value from r0 after \p opcode was executed.
  *
  */
-void arm11_run_instr_data_from_core_via_r0(arm11_common_t * arm11, u32 opcode, u32 * data)
+void arm11_run_instr_data_from_core_via_r0(arm11_common_t * arm11, uint32_t opcode, uint32_t * data)
 {
 	arm11_run_instr_no_data1(arm11, opcode);
 
@@ -660,7 +660,7 @@
  * \param data		Data word that will be written to r0 before \p opcode is executed
  *
  */
-void arm11_run_instr_data_to_core_via_r0(arm11_common_t * arm11, u32 opcode, u32 data)
+void arm11_run_instr_data_to_core_via_r0(arm11_common_t * arm11, uint32_t opcode, uint32_t data)
 {
 	/* MRC p14,0,r0,c0,c5,0 */
 	arm11_run_instr_data_to_core1(arm11, 0xEE100E15, data);
@@ -686,10 +686,10 @@
 	scan_field_t	chain7_fields[3];
 
 	uint8_t				nRW;
-	u32				DataOut;
+	uint32_t				DataOut;
 	uint8_t				AddressOut;
 	uint8_t				Ready;
-	u32				DataIn;
+	uint32_t				DataIn;
 	uint8_t				AddressIn;
 
 	arm11_setup_field(arm11,  1, &amp;nRW,			&amp;Ready,		chain7_fields + 0);
@@ -786,7 +786,7 @@
  * \param arm11		Target state variable.
  * \param value		Value to be written
  */
-void arm11_sc7_set_vcr(arm11_common_t * arm11, u32 value)
+void arm11_sc7_set_vcr(arm11_common_t * arm11, uint32_t value)
 {
 	arm11_sc7_action_t		set_vcr;
 
@@ -807,7 +807,7 @@
  * \param result	Pointer where to store result
  *
  */
-int arm11_read_memory_word(arm11_common_t * arm11, u32 address, u32 * result)
+int arm11_read_memory_word(arm11_common_t * arm11, uint32_t address, uint32_t * result)
 {
 	arm11_run_instr_data_prepare(arm11);
 

Modified: trunk/src/target/arm720t.c
===================================================================
--- trunk/src/target/arm720t.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm720t.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -43,8 +43,8 @@
 int arm720t_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm720t_quit(void);
 int arm720t_arch_state(struct target_s *target);
-int arm720t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int arm720t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm720t_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int arm720t_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int arm720t_soft_reset_halt(struct target_s *target);
 
 target_type_t arm720t_target =
@@ -84,7 +84,7 @@
 	.quit = arm720t_quit
 };
 
-int arm720t_scan_cp15(target_t *target, u32 out, u32 *in, int instruction, int clock)
+int arm720t_scan_cp15(target_t *target, uint32_t out, uint32_t *in, int instruction, int clock)
 {
 	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -146,7 +146,7 @@
 	return ERROR_OK;
 }
 
-int arm720t_read_cp15(target_t *target, u32 opcode, u32 *value)
+int arm720t_read_cp15(target_t *target, uint32_t opcode, uint32_t *value)
 {
 	/* fetch CP15 opcode */
 	arm720t_scan_cp15(target, opcode, NULL, 1, 1);
@@ -163,7 +163,7 @@
 	return ERROR_OK;
 }
 
-int arm720t_write_cp15(target_t *target, u32 opcode, u32 value)
+int arm720t_write_cp15(target_t *target, uint32_t opcode, uint32_t value)
 {
 	/* fetch CP15 opcode */
 	arm720t_scan_cp15(target, opcode, NULL, 1, 1);
@@ -179,9 +179,9 @@
 	return ERROR_OK;
 }
 
-u32 arm720t_get_ttb(target_t *target)
+uint32_t arm720t_get_ttb(target_t *target)
 {
-	u32 ttb = 0x0;
+	uint32_t ttb = 0x0;
 
 	arm720t_read_cp15(target, 0xee120f10, &amp;ttb);
 	jtag_execute_queue();
@@ -193,7 +193,7 @@
 
 void arm720t_disable_mmu_caches(target_t *target, int mmu, int d_u_cache, int i_cache)
 {
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
@@ -210,7 +210,7 @@
 
 void arm720t_enable_mmu_caches(target_t *target, int mmu, int d_u_cache, int i_cache)
 {
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
@@ -329,7 +329,7 @@
 	return ERROR_OK;
 }
 
-int arm720t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm720t_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -349,7 +349,7 @@
 	return retval;
 }
 
-int arm720t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm720t_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 
@@ -527,11 +527,11 @@
 	/* one or more argument, access a single register (write if second argument is given */
 	if (argc &gt;= 1)
 	{
-		u32 opcode = strtoul(args[0], NULL, 0);
+		uint32_t opcode = strtoul(args[0], NULL, 0);
 
 		if (argc == 1)
 		{
-			u32 value;
+			uint32_t value;
 			if ((retval = arm720t_read_cp15(target, opcode, &amp;value)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't access cp15 with opcode 0x%8.8x&quot;, opcode);
@@ -547,7 +547,7 @@
 		}
 		else if (argc == 2)
 		{
-			u32 value = strtoul(args[1], NULL, 0);
+			uint32_t value = strtoul(args[1], NULL, 0);
 			if ((retval = arm720t_write_cp15(target, opcode, value)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't access cp15 with opcode 0x%8.8x&quot;, opcode);

Modified: trunk/src/target/arm720t.h
===================================================================
--- trunk/src/target/arm720t.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm720t.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -27,12 +27,12 @@
 
 typedef struct arm720t_common_s
 {
-	u32 common_magic;
+	uint32_t common_magic;
 	armv4_5_mmu_common_t armv4_5_mmu;
 	arm7tdmi_common_t arm7tdmi_common;
-	u32 cp15_control_reg;
-	u32 fsr_reg;
-	u32 far_reg;
+	uint32_t cp15_control_reg;
+	uint32_t fsr_reg;
+	uint32_t far_reg;
 } arm720t_common_t;
 
 #endif /* ARM720T_H */

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm7_9_common.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -229,7 +229,7 @@
 	if (breakpoint-&gt;type == BKPT_HARD)
 	{
 		/* either an ARM (4 byte) or Thumb (2 byte) breakpoint */
-		u32 mask = (breakpoint-&gt;length == 4) ? 0x3u : 0x1u;
+		uint32_t mask = (breakpoint-&gt;length == 4) ? 0x3u : 0x1u;
 
 		/* reassign a hw breakpoint */
 		if (breakpoint-&gt;set==0)
@@ -272,7 +272,7 @@
 
 		if (breakpoint-&gt;length == 4)
 		{
-			u32 verify = 0xffffffff;
+			uint32_t verify = 0xffffffff;
 			/* keep the original instruction in target endianness */
 			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
 			{
@@ -371,7 +371,7 @@
 		/* restore original instruction (kept in target endianness) */
 		if (breakpoint-&gt;length == 4)
 		{
-			u32 current_instr;
+			uint32_t current_instr;
 			/* check that user program as not modified breakpoint instruction */
 			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
 			{
@@ -506,7 +506,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	int rw_mask = 1;
-	u32 mask;
+	uint32_t mask;
 
 	mask = watchpoint-&gt;length - 1;
 
@@ -781,16 +781,16 @@
  * @param buffer Pointer to the buffer that will hold the data
  * @return The result of receiving data from the Embedded ICE unit
  */
-int arm7_9_target_request_data(target_t *target, u32 size, uint8_t *buffer)
+int arm7_9_target_request_data(target_t *target, uint32_t size, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	u32 *data;
+	uint32_t *data;
 	int retval = ERROR_OK;
-	u32 i;
+	uint32_t i;
 
-	data = malloc(size * (sizeof(u32)));
+	data = malloc(size * (sizeof(uint32_t)));
 
 	retval = embeddedice_receive(jtag_info, data, size);
 
@@ -840,7 +840,7 @@
 		/* check W bit */
 		if (buf_get_u32(dcc_control-&gt;value, 1, 1) == 1)
 		{
-			u32 request;
+			uint32_t request;
 
 			if ((retval = embeddedice_receive(jtag_info, &amp;request, 1)) != ERROR_OK)
 			{
@@ -921,7 +921,7 @@
 			if (check_pc)
 			{
 				reg_t *reg = register_get_by_name(target-&gt;reg_cache, &quot;pc&quot;, 1);
-				u32 t=*((u32 *)reg-&gt;value);
+				uint32_t t=*((uint32_t *)reg-&gt;value);
 				if (t!=0)
 				{
 					LOG_ERROR(&quot;PC was not 0. Does this target need srst_pulls_trst?&quot;);
@@ -1190,7 +1190,7 @@
 	/* if the target is in Thumb state, change to ARM state */
 	if (buf_get_u32(dbg_stat-&gt;value, EICE_DBG_STATUS_ITBIT, 1))
 	{
-		u32 r0_thumb, pc_thumb;
+		uint32_t r0_thumb, pc_thumb;
 		LOG_DEBUG(&quot;target entered debug from Thumb state, changing to ARM&quot;);
 		/* Entered debug from Thumb mode */
 		armv4_5-&gt;core_state = ARMV4_5_STATE_THUMB;
@@ -1310,10 +1310,10 @@
 int arm7_9_debug_entry(target_t *target)
 {
 	int i;
-	u32 context[16];
-	u32* context_p[16];
-	u32 r0_thumb, pc_thumb;
-	u32 cpsr;
+	uint32_t context[16];
+	uint32_t* context_p[16];
+	uint32_t r0_thumb, pc_thumb;
+	uint32_t cpsr;
 	int retval;
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -1444,7 +1444,7 @@
 	/* exceptions other than USR &amp; SYS have a saved program status register */
 	if ((armv4_5-&gt;core_mode != ARMV4_5_MODE_USR) &amp;&amp; (armv4_5-&gt;core_mode != ARMV4_5_MODE_SYS))
 	{
-		u32 spsr;
+		uint32_t spsr;
 		arm7_9-&gt;read_xpsr(target, &amp;spsr, 1);
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
@@ -1500,8 +1500,8 @@
 	 */
 	for (i = 0; i &lt; 6; i++)
 	{
-		u32 mask = 0;
-		u32* reg_p[16];
+		uint32_t mask = 0;
+		uint32_t* reg_p[16];
 		int j;
 		int valid = 1;
 
@@ -1515,7 +1515,7 @@
 
 		if (!valid)
 		{
-			u32 tmp_cpsr;
+			uint32_t tmp_cpsr;
 
 			/* change processor mode (and mask T bit) */
 			tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
@@ -1527,7 +1527,7 @@
 			{
 				if (ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), j).valid == 0)
 				{
-					reg_p[j] = (u32*)ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), j).value;
+					reg_p[j] = (uint32_t*)ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), j).value;
 					mask |= 1 &lt;&lt; j;
 					ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), j).valid = 1;
 					ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), j).dirty = 0;
@@ -1541,7 +1541,7 @@
 			/* check if the PSR has to be read */
 			if (ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), 16).valid == 0)
 			{
-				arm7_9-&gt;read_xpsr(target, (u32*)ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), 16).value, 1);
+				arm7_9-&gt;read_xpsr(target, (uint32_t*)ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), 16).value, 1);
 				ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), 16).valid = 1;
 				ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_number_to_mode(i), 16).dirty = 0;
 			}
@@ -1633,13 +1633,13 @@
 
 		if (dirty)
 		{
-			u32 mask = 0x0;
+			uint32_t mask = 0x0;
 			int num_regs = 0;
-			u32 regs[16];
+			uint32_t regs[16];
 
 			if (mode_change)
 			{
-				u32 tmp_cpsr;
+				uint32_t tmp_cpsr;
 
 				/* change processor mode (mask T bit) */
 				tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
@@ -1684,7 +1684,7 @@
 	if ((armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty == 0) &amp;&amp; (armv4_5-&gt;core_mode != current_mode))
 	{
 		/* restore processor mode (mask T bit) */
-		u32 tmp_cpsr;
+		uint32_t tmp_cpsr;
 
 		tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
 		tmp_cpsr |= armv4_5_number_to_mode(i);
@@ -1774,7 +1774,7 @@
 	}
 }
 
-int arm7_9_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution)
+int arm7_9_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -1799,7 +1799,7 @@
 	if (!current)
 		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, address);
 
-	u32 current_pc;
+	uint32_t current_pc;
 	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 
 	/* the front-end may request us not to handle breakpoints */
@@ -1814,10 +1814,10 @@
 			}
 
 			/* calculate PC of next instruction */
-			u32 next_pc;
+			uint32_t next_pc;
 			if ((retval = arm_simulate_step(target, &amp;next_pc)) != ERROR_OK)
 			{
-				u32 current_opcode;
+				uint32_t current_opcode;
 				target_read_u32(target, current_pc, &amp;current_opcode);
 				LOG_ERROR(&quot;BUG: couldn't calculate PC of next instruction, current opcode was 0x%8.8x&quot;, current_opcode);
 				return retval;
@@ -1934,12 +1934,12 @@
 	return ERROR_OK;
 }
 
-void arm7_9_enable_eice_step(target_t *target, u32 next_pc)
+void arm7_9_enable_eice_step(target_t *target, uint32_t next_pc)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 
-	u32 current_pc;
+	uint32_t current_pc;
 	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 
 	if(next_pc != current_pc)
@@ -1988,7 +1988,7 @@
 	embeddedice_store_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_W1_CONTROL_VALUE]);
 }
 
-int arm7_9_step(struct target_s *target, int current, u32 address, int handle_breakpoints)
+int arm7_9_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -2005,7 +2005,7 @@
 	if (!current)
 		buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, address);
 
-	u32 current_pc;
+	uint32_t current_pc;
 	current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 
 	/* the front-end may request us not to handle breakpoints */
@@ -2019,10 +2019,10 @@
 	target-&gt;debug_reason = DBG_REASON_SINGLESTEP;
 
 	/* calculate PC of next instruction */
-	u32 next_pc;
+	uint32_t next_pc;
 	if ((retval = arm_simulate_step(target, &amp;next_pc)) != ERROR_OK)
 	{
-		u32 current_opcode;
+		uint32_t current_opcode;
 		target_read_u32(target, current_pc, &amp;current_opcode);
 		LOG_ERROR(&quot;BUG: couldn't calculate PC of next instruction, current opcode was 0x%8.8x&quot;, current_opcode);
 		return retval;
@@ -2083,8 +2083,8 @@
 
 int arm7_9_read_core_reg(struct target_s *target, int num, enum armv4_5_mode mode)
 {
-	u32* reg_p[16];
-	u32 value;
+	uint32_t* reg_p[16];
+	uint32_t value;
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -2101,7 +2101,7 @@
 			&amp;&amp; (mode != armv4_5-&gt;core_mode)
 			&amp;&amp; (reg_mode != ARMV4_5_MODE_ANY))
 	{
-		u32 tmp_cpsr;
+		uint32_t tmp_cpsr;
 
 		/* change processor mode (mask T bit) */
 		tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
@@ -2147,9 +2147,9 @@
 	return ERROR_OK;
 }
 
-int arm7_9_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, u32 value)
+int arm7_9_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, uint32_t value)
 {
-	u32 reg[16];
+	uint32_t reg[16];
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 
@@ -2164,7 +2164,7 @@
 	if ((mode != ARMV4_5_MODE_ANY)
 			&amp;&amp; (mode != armv4_5-&gt;core_mode)
 			&amp;&amp; (reg_mode != ARMV4_5_MODE_ANY))	{
-		u32 tmp_cpsr;
+		uint32_t tmp_cpsr;
 
 		/* change processor mode (mask T bit) */
 		tmp_cpsr = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8) &amp; 0xE0;
@@ -2208,16 +2208,16 @@
 	return jtag_execute_queue();
 }
 
-int arm7_9_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm7_9_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 
-	u32 reg[16];
-	u32 num_accesses = 0;
+	uint32_t reg[16];
+	uint32_t num_accesses = 0;
 	int thisrun_accesses;
 	int i;
-	u32 cpsr;
+	uint32_t cpsr;
 	int retval;
 	int last_reg = 0;
 
@@ -2247,7 +2247,7 @@
 		case 4:
 			while (num_accesses &lt; count)
 			{
-				u32 reg_list;
+				uint32_t reg_list;
 				thisrun_accesses = ((count - num_accesses) &gt;= 14) ? 14 : (count - num_accesses);
 				reg_list = (0xffff &gt;&gt; (15 - thisrun_accesses)) &amp; 0xfffe;
 
@@ -2281,7 +2281,7 @@
 		case 2:
 			while (num_accesses &lt; count)
 			{
-				u32 reg_list;
+				uint32_t reg_list;
 				thisrun_accesses = ((count - num_accesses) &gt;= 14) ? 14 : (count - num_accesses);
 				reg_list = (0xffff &gt;&gt; (15 - thisrun_accesses)) &amp; 0xfffe;
 
@@ -2319,7 +2319,7 @@
 		case 1:
 			while (num_accesses &lt; count)
 			{
-				u32 reg_list;
+				uint32_t reg_list;
 				thisrun_accesses = ((count - num_accesses) &gt;= 14) ? 14 : (count - num_accesses);
 				reg_list = (0xffff &gt;&gt; (15 - thisrun_accesses)) &amp; 0xfffe;
 
@@ -2384,17 +2384,17 @@
 	return ERROR_OK;
 }
 
-int arm7_9_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm7_9_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	reg_t *dbg_ctrl = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL];
 
-	u32 reg[16];
-	u32 num_accesses = 0;
+	uint32_t reg[16];
+	uint32_t num_accesses = 0;
 	int thisrun_accesses;
 	int i;
-	u32 cpsr;
+	uint32_t cpsr;
 	int retval;
 	int last_reg = 0;
 
@@ -2428,7 +2428,7 @@
 		case 4:
 			while (num_accesses &lt; count)
 			{
-				u32 reg_list;
+				uint32_t reg_list;
 				thisrun_accesses = ((count - num_accesses) &gt;= 14) ? 14 : (count - num_accesses);
 				reg_list = (0xffff &gt;&gt; (15 - thisrun_accesses)) &amp; 0xfffe;
 
@@ -2462,7 +2462,7 @@
 		case 2:
 			while (num_accesses &lt; count)
 			{
-				u32 reg_list;
+				uint32_t reg_list;
 				thisrun_accesses = ((count - num_accesses) &gt;= 14) ? 14 : (count - num_accesses);
 				reg_list = (0xffff &gt;&gt; (15 - thisrun_accesses)) &amp; 0xfffe;
 
@@ -2499,7 +2499,7 @@
 		case 1:
 			while (num_accesses &lt; count)
 			{
-				u32 reg_list;
+				uint32_t reg_list;
 				thisrun_accesses = ((count - num_accesses) &gt;= 14) ? 14 : (count - num_accesses);
 				reg_list = (0xffff &gt;&gt; (15 - thisrun_accesses)) &amp; 0xfffe;
 
@@ -2570,7 +2570,7 @@
 static int dcc_count;
 static uint8_t *dcc_buffer;
 
-static int arm7_9_dcc_completion(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info)
+static int arm7_9_dcc_completion(struct target_s *target, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
 	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -2615,15 +2615,15 @@
 	return target_wait_state(target, TARGET_HALTED, 500);
 }
 
-static const u32 dcc_code[] =
+static const uint32_t dcc_code[] =
 {
 	/* MRC      TST         BNE         MRC         STR         B */
 	0xee101e10, 0xe3110001, 0x0afffffc, 0xee111e10, 0xe4801004, 0xeafffff9
 };
 
-int armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info));
+int armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, uint32_t exit_point, int timeout_ms, void *arch_info));
 
-int arm7_9_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
+int arm7_9_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -2676,7 +2676,7 @@
 
 	if (retval==ERROR_OK)
 	{
-		u32 endaddress=buf_get_u32(reg_params[0].value, 0, 32);
+		uint32_t endaddress=buf_get_u32(reg_params[0].value, 0, 32);
 		if (endaddress!=(address+count*4))
 		{
 			LOG_ERROR(&quot;DCC write failed, expected end address 0x%08x got 0x%0x&quot;, (address+count*4), endaddress);
@@ -2689,14 +2689,14 @@
 	return retval;
 }
 
-int arm7_9_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum)
+int arm7_9_checksum_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum)
 {
 	working_area_t *crc_algorithm;
 	armv4_5_algorithm_t armv4_5_info;
 	reg_param_t reg_params[2];
 	int retval;
 
-	u32 arm7_9_crc_code[] = {
+	uint32_t arm7_9_crc_code[] = {
 		0xE1A02000,				/* mov		r2, r0 */
 		0xE3E00000,				/* mov		r0, #0xffffffff */
 		0xE1A03001,				/* mov		r3, r1 */
@@ -2724,7 +2724,7 @@
 		0x04C11DB7				/* CRC32XOR:	.word 0x04C11DB7 */
 	};
 
-	u32 i;
+	uint32_t i;
 
 	if (target_alloc_working_area(target, sizeof(arm7_9_crc_code), &amp;crc_algorithm) != ERROR_OK)
 	{
@@ -2732,9 +2732,9 @@
 	}
 
 	/* convert flash writing code into a buffer in target endianness */
-	for (i = 0; i &lt; (sizeof(arm7_9_crc_code)/sizeof(u32)); i++)
+	for (i = 0; i &lt; (sizeof(arm7_9_crc_code)/sizeof(uint32_t)); i++)
 	{
-		if ((retval=target_write_u32(target, crc_algorithm-&gt;address + i*sizeof(u32), arm7_9_crc_code[i]))!=ERROR_OK)
+		if ((retval=target_write_u32(target, crc_algorithm-&gt;address + i*sizeof(uint32_t), arm7_9_crc_code[i]))!=ERROR_OK)
 		{
 			return retval;
 		}
@@ -2770,15 +2770,15 @@
 	return ERROR_OK;
 }
 
-int arm7_9_blank_check_memory(struct target_s *target, u32 address, u32 count, u32* blank)
+int arm7_9_blank_check_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* blank)
 {
 	working_area_t *erase_check_algorithm;
 	reg_param_t reg_params[3];
 	armv4_5_algorithm_t armv4_5_info;
 	int retval;
-	u32 i;
+	uint32_t i;
 
-	u32 erase_check_code[] =
+	uint32_t erase_check_code[] =
 	{
 						/* loop: */
 		0xe4d03001,		/* ldrb r3, [r0], #1	*/
@@ -2796,8 +2796,8 @@
 	}
 
 	/* convert flash writing code into a buffer in target endianness */
-	for (i = 0; i &lt; (sizeof(erase_check_code)/sizeof(u32)); i++)
-		if ((retval = target_write_u32(target, erase_check_algorithm-&gt;address + i*sizeof(u32), erase_check_code[i])) != ERROR_OK)
+	for (i = 0; i &lt; (sizeof(erase_check_code)/sizeof(uint32_t)); i++)
+		if ((retval = target_write_u32(target, erase_check_algorithm-&gt;address + i*sizeof(uint32_t), erase_check_code[i])) != ERROR_OK)
 		{
 			return retval;
 		}
@@ -2863,7 +2863,7 @@
 
 int handle_arm7_9_write_xpsr_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u32 value;
+	uint32_t value;
 	int spsr;
 	int retval;
 	target_t *target = get_current_target(cmd_ctx);
@@ -2907,7 +2907,7 @@
 
 int handle_arm7_9_write_xpsr_im8_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u32 value;
+	uint32_t value;
 	int rotate;
 	int spsr;
 	int retval;
@@ -2949,8 +2949,8 @@
 
 int handle_arm7_9_write_core_reg_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u32 value;
-	u32 mode;
+	uint32_t value;
+	uint32_t mode;
 	int num;
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;

Modified: trunk/src/target/arm7_9_common.h
===================================================================
--- trunk/src/target/arm7_9_common.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm7_9_common.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -39,12 +39,12 @@
  */
 typedef struct arm7_9_common_s
 {
-	u32 common_magic;
+	uint32_t common_magic;
 
 	arm_jtag_t jtag_info; /**&lt; JTAG information for target */
 	reg_cache_t *eice_cache; /**&lt; Embedded ICE register cache */
 
-	u32 arm_bkpt; /**&lt; ARM breakpoint instruction */
+	uint32_t arm_bkpt; /**&lt; ARM breakpoint instruction */
 	uint16_t thumb_bkpt; /**&lt; Thumb breakpoint instruction */
 	int sw_breakpoints_added; /**&lt; Specifies which watchpoint software breakpoints are setup on */
 	int breakpoint_count; /**&lt; Current number of set breakpoints */
@@ -73,29 +73,29 @@
 
 	int (*examine_debug_reason)(target_t *target); /**&lt; Function for determining why debug state was entered */
 
-	void (*change_to_arm)(target_t *target, u32 *r0, u32 *pc); /**&lt; Function for changing from Thumb to ARM mode */
+	void (*change_to_arm)(target_t *target, uint32_t *r0, uint32_t *pc); /**&lt; Function for changing from Thumb to ARM mode */
 
-	void (*read_core_regs)(target_t *target, u32 mask, u32 *core_regs[16]); /**&lt; Function for reading the core registers */
-	void (*read_core_regs_target_buffer)(target_t *target, u32 mask, void *buffer, int size);
-	void (*read_xpsr)(target_t *target, u32 *xpsr, int spsr); /**&lt; Function for reading CPSR or SPSR */
+	void (*read_core_regs)(target_t *target, uint32_t mask, uint32_t *core_regs[16]); /**&lt; Function for reading the core registers */
+	void (*read_core_regs_target_buffer)(target_t *target, uint32_t mask, void *buffer, int size);
+	void (*read_xpsr)(target_t *target, uint32_t *xpsr, int spsr); /**&lt; Function for reading CPSR or SPSR */
 
-	void (*write_xpsr)(target_t *target, u32 xpsr, int spsr); /**&lt; Function for writing to CPSR or SPSR */
+	void (*write_xpsr)(target_t *target, uint32_t xpsr, int spsr); /**&lt; Function for writing to CPSR or SPSR */
 	void (*write_xpsr_im8)(target_t *target, uint8_t xpsr_im, int rot, int spsr); /**&lt; Function for writing an immediate value to CPSR or SPSR */
-	void (*write_core_regs)(target_t *target, u32 mask, u32 core_regs[16]);
+	void (*write_core_regs)(target_t *target, uint32_t mask, uint32_t core_regs[16]);
 
-	void (*load_word_regs)(target_t *target, u32 mask);
+	void (*load_word_regs)(target_t *target, uint32_t mask);
 	void (*load_hword_reg)(target_t *target, int num);
 	void (*load_byte_reg)(target_t *target, int num);
 
-	void (*store_word_regs)(target_t *target, u32 mask);
+	void (*store_word_regs)(target_t *target, uint32_t mask);
 	void (*store_hword_reg)(target_t *target, int num);
 	void (*store_byte_reg)(target_t *target, int num);
 
-	void (*write_pc)(target_t *target, u32 pc); /**&lt; Function for writing to the program counter */
+	void (*write_pc)(target_t *target, uint32_t pc); /**&lt; Function for writing to the program counter */
 	void (*branch_resume)(target_t *target);
 	void (*branch_resume_thumb)(target_t *target);
 
-	void (*enable_single_step)(target_t *target, u32 next_pc);
+	void (*enable_single_step)(target_t *target, uint32_t next_pc);
 	void (*disable_single_step)(target_t *target);
 
 	void (*set_special_dbgrq)(target_t *target); /**&lt; Function for setting DBGRQ if the normal way won't work */
@@ -115,7 +115,7 @@
 
 int arm7_9_poll(target_t *target);
 
-int arm7_9_target_request_data(target_t *target, u32 size, uint8_t *buffer);
+int arm7_9_target_request_data(target_t *target, uint32_t size, uint8_t *buffer);
 
 int arm7_9_setup(target_t *target);
 int arm7_9_assert_reset(target_t *target);
@@ -128,23 +128,23 @@
 int arm7_9_halt(target_t *target);
 int arm7_9_full_context(target_t *target);
 int arm7_9_restore_context(target_t *target);
-int arm7_9_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
-int arm7_9_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
+int arm7_9_resume(struct target_s *target, int current, uint32_t address, int handle_breakpoints, int debug_execution);
+int arm7_9_step(struct target_s *target, int current, uint32_t address, int handle_breakpoints);
 int arm7_9_read_core_reg(struct target_s *target, int num, enum armv4_5_mode mode);
-int arm7_9_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int arm7_9_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int arm7_9_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
-int arm7_9_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum);
-int arm7_9_blank_check_memory(struct target_s *target, u32 address, u32 count, u32* blank);
+int arm7_9_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int arm7_9_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int arm7_9_bulk_write_memory(target_t *target, uint32_t address, uint32_t count, uint8_t *buffer);
+int arm7_9_checksum_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum);
+int arm7_9_blank_check_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* blank);
 
-int arm7_9_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_prams, reg_param_t *reg_param, u32 entry_point, void *arch_info);
+int arm7_9_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_prams, reg_param_t *reg_param, uint32_t entry_point, void *arch_info);
 
 int arm7_9_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
 int arm7_9_remove_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
 int arm7_9_add_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
 int arm7_9_remove_watchpoint(struct target_s *target, watchpoint_t *watchpoint);
 
-void arm7_9_enable_eice_step(target_t *target, u32 next_pc);
+void arm7_9_enable_eice_step(target_t *target, uint32_t next_pc);
 void arm7_9_disable_eice_step(target_t *target);
 
 int arm7_9_execute_sys_speed(struct target_s *target);

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm7tdmi.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -139,9 +139,9 @@
 }
 
 static int arm7tdmi_num_bits[]={1, 32};
-static __inline int arm7tdmi_clock_out_inner(arm_jtag_t *jtag_info, u32 out, int breakpoint)
+static __inline int arm7tdmi_clock_out_inner(arm_jtag_t *jtag_info, uint32_t out, int breakpoint)
 {
-	u32 values[2]={breakpoint, flip_u32(out, 32)};
+	uint32_t values[2]={breakpoint, flip_u32(out, 32)};
 
 	jtag_add_dr_out(jtag_info-&gt;tap,
 			2,
@@ -155,7 +155,7 @@
 }
 
 /* put an instruction in the ARM7TDMI pipeline or write the data bus, and optionally read data */
-static __inline int arm7tdmi_clock_out(arm_jtag_t *jtag_info, u32 out, u32 *deprecated, int breakpoint)
+static __inline int arm7tdmi_clock_out(arm_jtag_t *jtag_info, uint32_t out, uint32_t *deprecated, int breakpoint)
 {
 	jtag_set_end_state(TAP_DRPAUSE);
 	arm_jtag_scann(jtag_info, 0x1);
@@ -165,7 +165,7 @@
 }
 
 /* clock the target, reading the databus */
-int arm7tdmi_clock_data_in(arm_jtag_t *jtag_info, u32 *in)
+int arm7tdmi_clock_data_in(arm_jtag_t *jtag_info, uint32_t *in)
 {
 	int retval = ERROR_OK;
 	scan_field_t fields[2];
@@ -216,7 +216,7 @@
 
 void arm_endianness(uint8_t *tmp, void *in, int size, int be, int flip)
 {
-	u32 readback=le_to_h_u32(tmp);
+	uint32_t readback=le_to_h_u32(tmp);
 	if (flip)
 		readback=flip_u32(readback, 32);
 	switch (size)
@@ -292,7 +292,7 @@
 
 		if (in)
 		{
-			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *(u32*)in);
+			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *(uint32_t*)in);
 		}
 		else
 		{
@@ -304,7 +304,7 @@
 	return ERROR_OK;
 }
 
-void arm7tdmi_change_to_arm(target_t *target, u32 *r0, u32 *pc)
+void arm7tdmi_change_to_arm(target_t *target, uint32_t *r0, uint32_t *pc)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -361,7 +361,7 @@
  * The solution is to arrange for a large out/in scan in this loop and
  * and convert data afterwards.
  */
-void arm7tdmi_read_core_regs(target_t *target, u32 mask, u32* core_regs[16])
+void arm7tdmi_read_core_regs(target_t *target, uint32_t mask, uint32_t* core_regs[16])
 {
 	int i;
 	/* get pointers to arch-specific information */
@@ -387,7 +387,7 @@
 	}
 }
 
-void arm7tdmi_read_core_regs_target_buffer(target_t *target, u32 mask, void* buffer, int size)
+void arm7tdmi_read_core_regs_target_buffer(target_t *target, uint32_t mask, void* buffer, int size)
 {
 	int i;
 	/* get pointers to arch-specific information */
@@ -395,7 +395,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	int be = (target-&gt;endianness == TARGET_BIG_ENDIAN) ? 1 : 0;
-	u32 *buf_u32 = buffer;
+	uint32_t *buf_u32 = buffer;
 	uint16_t *buf_u16 = buffer;
 	uint8_t *buf_u8 = buffer;
 
@@ -430,7 +430,7 @@
 	}
 }
 
-void arm7tdmi_read_xpsr(target_t *target, u32 *xpsr, int spsr)
+void arm7tdmi_read_xpsr(target_t *target, uint32_t *xpsr, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -450,7 +450,7 @@
 	arm7tdmi_clock_data_in(jtag_info, xpsr);
 }
 
-void arm7tdmi_write_xpsr(target_t *target, u32 xpsr, int spsr)
+void arm7tdmi_write_xpsr(target_t *target, uint32_t xpsr, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -500,7 +500,7 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 }
 
-void arm7tdmi_write_core_regs(target_t *target, u32 mask, u32 core_regs[16])
+void arm7tdmi_write_core_regs(target_t *target, uint32_t mask, uint32_t core_regs[16])
 {
 	int i;
 	/* get pointers to arch-specific information */
@@ -527,7 +527,7 @@
 	arm7tdmi_clock_out_inner(jtag_info, ARMV4_5_NOP, 0);
 }
 
-void arm7tdmi_load_word_regs(target_t *target, u32 mask)
+void arm7tdmi_load_word_regs(target_t *target, uint32_t mask)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -566,7 +566,7 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_LDRB_IP(num, 0), NULL, 0);
 }
 
-void arm7tdmi_store_word_regs(target_t *target, u32 mask)
+void arm7tdmi_store_word_regs(target_t *target, uint32_t mask)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -605,7 +605,7 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_STRB_IP(num, 0), NULL, 0);
 }
 
-void arm7tdmi_write_pc(target_t *target, u32 pc)
+void arm7tdmi_write_pc(target_t *target, uint32_t pc)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;

Modified: trunk/src/target/arm920t.c
===================================================================
--- trunk/src/target/arm920t.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm920t.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -48,8 +48,8 @@
 int arm920t_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm920t_quit(void);
 int arm920t_arch_state(struct target_s *target);
-int arm920t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-int arm920t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm920t_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+int arm920t_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 int arm920t_soft_reset_halt(struct target_s *target);
 
 #define ARM920T_CP15_PHYS_ADDR(x, y, z) ((x &lt;&lt; 5) | (y &lt;&lt; 1) &lt;&lt; (z))
@@ -93,7 +93,7 @@
 	.quit = arm920t_quit
 };
 
-int arm920t_read_cp15_physical(target_t *target, int reg_addr, u32 *value)
+int arm920t_read_cp15_physical(target_t *target, int reg_addr, uint32_t *value)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -143,7 +143,7 @@
 	return ERROR_OK;
 }
 
-int arm920t_write_cp15_physical(target_t *target, int reg_addr, u32 value)
+int arm920t_write_cp15_physical(target_t *target, int reg_addr, uint32_t value)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -189,7 +189,7 @@
 	return ERROR_OK;
 }
 
-int arm920t_execute_cp15(target_t *target, u32 cp15_opcode, u32 arm_opcode)
+int arm920t_execute_cp15(target_t *target, uint32_t cp15_opcode, uint32_t arm_opcode)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -244,12 +244,12 @@
 	return ERROR_OK;
 }
 
-int arm920t_read_cp15_interpreted(target_t *target, u32 cp15_opcode, u32 address, u32 *value)
+int arm920t_read_cp15_interpreted(target_t *target, uint32_t cp15_opcode, uint32_t address, uint32_t *value)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
-	u32* regs_p[1];
-	u32 regs[2];
-	u32 cp15c15 = 0x0;
+	uint32_t* regs_p[1];
+	uint32_t regs[2];
+	uint32_t cp15c15 = 0x0;
 
 	/* load address into R1 */
 	regs[1] = address;
@@ -287,11 +287,11 @@
 	return ERROR_OK;
 }
 
-int arm920t_write_cp15_interpreted(target_t *target, u32 cp15_opcode, u32 value, u32 address)
+int arm920t_write_cp15_interpreted(target_t *target, uint32_t cp15_opcode, uint32_t value, uint32_t address)
 {
-	u32 cp15c15 = 0x0;
+	uint32_t cp15c15 = 0x0;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
-	u32 regs[2];
+	uint32_t regs[2];
 
 	/* load value, address into R0, R1 */
 	regs[0] = value;
@@ -325,10 +325,10 @@
 	return ERROR_OK;
 }
 
-u32 arm920t_get_ttb(target_t *target)
+uint32_t arm920t_get_ttb(target_t *target)
 {
 	int retval;
-	u32 ttb = 0x0;
+	uint32_t ttb = 0x0;
 
 	if ((retval = arm920t_read_cp15_interpreted(target, 0xeebf0f51, 0x0, &amp;ttb)) != ERROR_OK)
 		return retval;
@@ -338,7 +338,7 @@
 
 void arm920t_disable_mmu_caches(target_t *target, int mmu, int d_u_cache, int i_cache)
 {
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	arm920t_read_cp15_physical(target, 0x2, &amp;cp15_control);
@@ -358,7 +358,7 @@
 
 void arm920t_enable_mmu_caches(target_t *target, int mmu, int d_u_cache, int i_cache)
 {
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	arm920t_read_cp15_physical(target, 0x2, &amp;cp15_control);
@@ -378,7 +378,7 @@
 
 void arm920t_post_debug_entry(target_t *target)
 {
-	u32 cp15c15;
+	uint32_t cp15c15;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
@@ -391,7 +391,7 @@
 
 	if (arm920t-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
-		u32 cache_type_reg;
+		uint32_t cache_type_reg;
 		/* identify caches */
 		arm920t_read_cp15_physical(target, 0x1, &amp;cache_type_reg);
 		jtag_execute_queue();
@@ -424,7 +424,7 @@
 
 void arm920t_pre_restore_context(target_t *target)
 {
-	u32 cp15c15;
+	uint32_t cp15c15;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
@@ -518,7 +518,7 @@
 	return ERROR_OK;
 }
 
-int arm920t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm920t_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 
@@ -527,7 +527,7 @@
 	return retval;
 }
 
-int arm920t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm920t_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -543,7 +543,7 @@
 		if (arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		{
 			LOG_DEBUG(&quot;D-Cache enabled, writing through to main memory&quot;);
-			u32 pa, cb, ap;
+			uint32_t pa, cb, ap;
 			int type, domain;
 
 			pa = armv4_5_mmu_translate_va(target, &amp;arm920t-&gt;armv4_5_mmu, address, &amp;type, &amp;cb, &amp;domain, &amp;ap);
@@ -731,11 +731,11 @@
 	arm9tdmi_common_t *arm9tdmi;
 	arm920t_common_t *arm920t;
 	arm_jtag_t *jtag_info;
-	u32 cp15c15;
-	u32 cp15_ctrl, cp15_ctrl_saved;
-	u32 regs[16];
-	u32 *regs_p[16];
-	u32 C15_C_D_Ind, C15_C_I_Ind;
+	uint32_t cp15c15;
+	uint32_t cp15_ctrl, cp15_ctrl_saved;
+	uint32_t regs[16];
+	uint32_t *regs_p[16];
+	uint32_t C15_C_D_Ind, C15_C_I_Ind;
 	int i;
 	FILE *output;
 	arm920t_cache_line_t d_cache[8][64], i_cache[8][64];
@@ -983,13 +983,13 @@
 	arm9tdmi_common_t *arm9tdmi;
 	arm920t_common_t *arm920t;
 	arm_jtag_t *jtag_info;
-	u32 cp15c15;
-	u32 cp15_ctrl, cp15_ctrl_saved;
-	u32 regs[16];
-	u32 *regs_p[16];
+	uint32_t cp15c15;
+	uint32_t cp15_ctrl, cp15_ctrl_saved;
+	uint32_t regs[16];
+	uint32_t *regs_p[16];
 	int i;
 	FILE *output;
-	u32 Dlockdown, Ilockdown;
+	uint32_t Dlockdown, Ilockdown;
 	arm920t_tlb_entry_t d_tlb[64], i_tlb[64];
 	int victim;
 
@@ -1293,7 +1293,7 @@
 
 		if (argc == 1)
 		{
-			u32 value;
+			uint32_t value;
 			if ((retval = arm920t_read_cp15_physical(target, address, &amp;value)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't access reg %i&quot;, address);
@@ -1308,7 +1308,7 @@
 		}
 		else if (argc == 2)
 		{
-			u32 value = strtoul(args[1], NULL, 0);
+			uint32_t value = strtoul(args[1], NULL, 0);
 			if ((retval = arm920t_write_cp15_physical(target, address, value)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't access reg %i&quot;, address);
@@ -1348,11 +1348,11 @@
 	/* one or more argument, access a single register (write if second argument is given */
 	if (argc &gt;= 1)
 	{
-		u32 opcode = strtoul(args[0], NULL, 0);
+		uint32_t opcode = strtoul(args[0], NULL, 0);
 
 		if (argc == 1)
 		{
-			u32 value;
+			uint32_t value;
 			if ((retval = arm920t_read_cp15_interpreted(target, opcode, 0x0, &amp;value)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't execute %8.8x&quot;, opcode);
@@ -1363,7 +1363,7 @@
 		}
 		else if (argc == 2)
 		{
-			u32 value = strtoul(args[1], NULL, 0);
+			uint32_t value = strtoul(args[1], NULL, 0);
 			if ((retval = arm920t_write_cp15_interpreted(target, opcode, value, 0)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't execute %8.8x&quot;, opcode);
@@ -1373,8 +1373,8 @@
 		}
 		else if (argc == 3)
 		{
-			u32 value = strtoul(args[1], NULL, 0);
-			u32 address = strtoul(args[2], NULL, 0);
+			uint32_t value = strtoul(args[1], NULL, 0);
+			uint32_t address = strtoul(args[2], NULL, 0);
 			if ((retval = arm920t_write_cp15_interpreted(target, opcode, value, address)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't execute %8.8x&quot;, opcode);

Modified: trunk/src/target/arm920t.h
===================================================================
--- trunk/src/target/arm920t.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm920t.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -27,28 +27,28 @@
 
 typedef struct arm920t_common_s
 {
-	u32 common_magic;
+	uint32_t common_magic;
 	armv4_5_mmu_common_t armv4_5_mmu;
 	arm9tdmi_common_t arm9tdmi_common;
-	u32 cp15_control_reg;
-	u32 d_fsr;
-	u32 i_fsr;
-	u32 d_far;
-	u32 i_far;
+	uint32_t cp15_control_reg;
+	uint32_t d_fsr;
+	uint32_t i_fsr;
+	uint32_t d_far;
+	uint32_t i_far;
 	int preserve_cache;
 } arm920t_common_t;
 
 typedef struct arm920t_cache_line_s
 {
-	u32 cam;
-	u32 data[8];
+	uint32_t cam;
+	uint32_t data[8];
 } arm920t_cache_line_t;
 
 typedef struct arm920t_tlb_entry_s
 {
-	u32 cam;
-	u32 ram1;
-	u32 ram2;
+	uint32_t cam;
+	uint32_t ram1;
+	uint32_t ram2;
 } arm920t_tlb_entry_t;
 
 #endif /* ARM920T_H */

Modified: trunk/src/target/arm926ejs.c
===================================================================
--- trunk/src/target/arm926ejs.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm926ejs.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -45,9 +45,9 @@
 int arm926ejs_target_create(struct target_s *target, Jim_Interp *interp);
 int arm926ejs_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm926ejs_quit(void);
-int arm926ejs_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm926ejs_read_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
-static int arm926ejs_virt2phys(struct target_s *target, u32 virtual, u32 *physical);
+static int arm926ejs_virt2phys(struct target_s *target, uint32_t virtual, uint32_t *physical);
 static int arm926ejs_mmu(struct target_s *target, int *enabled);
 
 target_type_t arm926ejs_target =
@@ -115,13 +115,13 @@
 
 #define ARM926EJS_CP15_ADDR(opcode_1, opcode_2, CRn, CRm) ((opcode_1 &lt;&lt; 11) | (opcode_2 &lt;&lt; 8) | (CRn &lt;&lt; 4) | (CRm &lt;&lt; 0))
 
-int arm926ejs_cp15_read(target_t *target, u32 op1, u32 op2, u32 CRn, u32 CRm, u32 *value)
+int arm926ejs_cp15_read(target_t *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
 {
 	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	u32 address = ARM926EJS_CP15_ADDR(op1, op2, CRn, CRm);
+	uint32_t address = ARM926EJS_CP15_ADDR(op1, op2, CRn, CRm);
 	scan_field_t fields[4];
 	uint8_t address_buf[2];
 	uint8_t nr_w_buf = 0;
@@ -184,13 +184,13 @@
 	return ERROR_OK;
 }
 
-int arm926ejs_cp15_write(target_t *target, u32 op1, u32 op2, u32 CRn, u32 CRm, u32 value)
+int arm926ejs_cp15_write(target_t *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
 {
 	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	u32 address = ARM926EJS_CP15_ADDR(op1, op2, CRn, CRm);
+	uint32_t address = ARM926EJS_CP15_ADDR(op1, op2, CRn, CRm);
 	scan_field_t fields[4];
 	uint8_t value_buf[4];
 	uint8_t address_buf[2];
@@ -333,14 +333,14 @@
 	return retval;
 }
 
-u32 arm926ejs_get_ttb(target_t *target)
+uint32_t arm926ejs_get_ttb(target_t *target)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm926ejs_common_t *arm926ejs = arm9tdmi-&gt;arch_info;
 	int retval;
-	u32 ttb = 0x0;
+	uint32_t ttb = 0x0;
 
 	if ((retval = arm926ejs-&gt;read_cp15(target, 0, 0, 2, 0, &amp;ttb)) != ERROR_OK)
 		return retval;
@@ -354,7 +354,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm926ejs_common_t *arm926ejs = arm9tdmi-&gt;arch_info;
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;cp15_control);
@@ -370,7 +370,7 @@
 
 	if (d_u_cache)
 	{
-		u32 debug_override;
+		uint32_t debug_override;
 		/* read-modify-write CP15 debug override register
 		 * to enable &quot;test and clean all&quot; */
 		arm926ejs-&gt;read_cp15(target, 0, 0, 15, 0, &amp;debug_override);
@@ -405,7 +405,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm926ejs_common_t *arm926ejs = arm9tdmi-&gt;arch_info;
-	u32 cp15_control;
+	uint32_t cp15_control;
 
 	/* read cp15 control register */
 	arm926ejs-&gt;read_cp15(target, 0, 0, 1, 0, &amp;cp15_control);
@@ -437,7 +437,7 @@
 
 	if (arm926ejs-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
-		u32 cache_type_reg;
+		uint32_t cache_type_reg;
 		/* identify caches */
 		arm926ejs-&gt;read_cp15(target, 0, 1, 0, 0, &amp;cache_type_reg);
 		jtag_execute_queue();
@@ -456,7 +456,7 @@
 	LOG_DEBUG(&quot;D FSR: 0x%8.8x, D FAR: 0x%8.8x, I FSR: 0x%8.8x&quot;,
 		arm926ejs-&gt;d_fsr, arm926ejs-&gt;d_far, arm926ejs-&gt;i_fsr);
 
-	u32 cache_dbg_ctrl;
+	uint32_t cache_dbg_ctrl;
 
 	/* read-modify-write CP15 cache debug control register
 	 * to disable I/D-cache linefills and force WT */
@@ -477,7 +477,7 @@
 	arm926ejs-&gt;write_cp15(target, 0, 1, 5, 0, arm926ejs-&gt;i_fsr);
 	arm926ejs-&gt;write_cp15(target, 0, 0, 6, 0, arm926ejs-&gt;d_far);
 
-	u32 cache_dbg_ctrl;
+	uint32_t cache_dbg_ctrl;
 
 	/* read-modify-write CP15 cache debug control register
 	 * to reenable I/D-cache linefills and disable WT */
@@ -625,7 +625,7 @@
 	return target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 }
 
-int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
+int arm926ejs_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -778,7 +778,7 @@
 
 	if (argc == 4)
 	{
-		u32 value;
+		uint32_t value;
 		if ((retval = arm926ejs-&gt;read_cp15(target, opcode_1, opcode_2, CRn, CRm, &amp;value)) != ERROR_OK)
 		{
 			command_print(cmd_ctx, &quot;couldn't access register&quot;);
@@ -793,7 +793,7 @@
 	}
 	else
 	{
-		u32 value = strtoul(args[4], NULL, 0);
+		uint32_t value = strtoul(args[4], NULL, 0);
 		if ((retval = arm926ejs-&gt;write_cp15(target, opcode_1, opcode_2, CRn, CRm, value)) != ERROR_OK)
 		{
 			command_print(cmd_ctx, &quot;couldn't access register&quot;);
@@ -900,13 +900,13 @@
 	return armv4_5_mmu_handle_mw_phys_command(cmd_ctx, cmd, args, argc, target, &amp;arm926ejs-&gt;armv4_5_mmu);
 }
 
-static int arm926ejs_virt2phys(struct target_s *target, u32 virtual, u32 *physical)
+static int arm926ejs_virt2phys(struct target_s *target, uint32_t virtual, uint32_t *physical)
 {
 	int retval;
 	int type;
-	u32 cb;
+	uint32_t cb;
 	int domain;
-	u32 ap;
+	uint32_t ap;
 
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -917,7 +917,7 @@
 	{
 		return retval;
 	}
-	u32 ret = armv4_5_mmu_translate_va(target, &amp;arm926ejs-&gt;armv4_5_mmu, virtual, &amp;type, &amp;cb, &amp;domain, &amp;ap);
+	uint32_t ret = armv4_5_mmu_translate_va(target, &amp;arm926ejs-&gt;armv4_5_mmu, virtual, &amp;type, &amp;cb, &amp;domain, &amp;ap);
 	if (type == -1)
 	{
 		return ret;

Modified: trunk/src/target/arm926ejs.h
===================================================================
--- trunk/src/target/arm926ejs.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm926ejs.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -27,21 +27,21 @@
 
 typedef struct arm926ejs_common_s
 {
-	u32 common_magic;
+	uint32_t common_magic;
 	armv4_5_mmu_common_t armv4_5_mmu;
 	arm9tdmi_common_t arm9tdmi_common;
-	int (*read_cp15)(target_t *target, u32 op1, u32 op2, u32 CRn, u32 CRm, u32 *value);
-	int (*write_cp15)(target_t *target, u32 op1, u32 op2, u32 CRn, u32 CRm, u32 value);
-	u32 cp15_control_reg;
-	u32 d_fsr;
-	u32 i_fsr;
-	u32 d_far;
+	int (*read_cp15)(target_t *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value);
+	int (*write_cp15)(target_t *target, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value);
+	uint32_t cp15_control_reg;
+	uint32_t d_fsr;
+	uint32_t i_fsr;
+	uint32_t d_far;
 } arm926ejs_common_t;
 
 extern int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap);
 extern int arm926ejs_register_commands(struct command_context_s *cmd_ctx); 
 extern int arm926ejs_arch_state(struct target_s *target); 
-extern int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer); 
+extern int arm926ejs_write_memory(struct target_s *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer); 
 extern int arm926ejs_soft_reset_halt(struct target_s *target);
 
 #endif /* ARM926EJS_H */

Modified: trunk/src/target/arm966e.c
===================================================================
--- trunk/src/target/arm966e.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm966e.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -157,7 +157,7 @@
 	return ERROR_OK;
 }
 
-int arm966e_read_cp15(target_t *target, int reg_addr, u32 *value)
+int arm966e_read_cp15(target_t *target, int reg_addr, uint32_t *value)
 {
 	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -209,7 +209,7 @@
 	return ERROR_OK;
 }
 
-int arm966e_write_cp15(target_t *target, int reg_addr, u32 value)
+int arm966e_write_cp15(target_t *target, int reg_addr, uint32_t value)
 {
 	int retval = ERROR_OK;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -284,7 +284,7 @@
 
 		if (argc == 1)
 		{
-			u32 value;
+			uint32_t value;
 			if ((retval = arm966e_read_cp15(target, address, &amp;value)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't access reg %i&quot;, address);
@@ -299,7 +299,7 @@
 		}
 		else if (argc == 2)
 		{
-			u32 value = strtoul(args[1], NULL, 0);
+			uint32_t value = strtoul(args[1], NULL, 0);
 			if ((retval = arm966e_write_cp15(target, address, value)) != ERROR_OK)
 			{
 				command_print(cmd_ctx, &quot;couldn't access reg %i&quot;, address);

Modified: trunk/src/target/arm966e.h
===================================================================
--- trunk/src/target/arm966e.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm966e.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -31,10 +31,10 @@
 {
 	int common_magic;
 	arm9tdmi_common_t arm9tdmi_common;
-	u32 cp15_control_reg;
+	uint32_t cp15_control_reg;
 } arm966e_common_t;
 
-extern int arm966e_read_cp15(target_t *target, int reg_addr, u32 *value);
-extern int arm966e_write_cp15(target_t *target, int reg_addr, u32 value);
+extern int arm966e_read_cp15(target_t *target, int reg_addr, uint32_t *value);
+extern int arm966e_write_cp15(target_t *target, int reg_addr, uint32_t value);
 
 #endif /* ARM966E_H */

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm9tdmi.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -162,7 +162,7 @@
 }
 
 /* put an instruction in the ARM9TDMI pipeline or write the data bus, and optionally read data */
-int arm9tdmi_clock_out(arm_jtag_t *jtag_info, u32 instr, u32 out, u32 *in, int sysspeed)
+int arm9tdmi_clock_out(arm_jtag_t *jtag_info, uint32_t instr, uint32_t out, uint32_t *in, int sysspeed)
 {
 	int retval = ERROR_OK;
 	scan_field_t fields[3];
@@ -235,7 +235,7 @@
 }
 
 /* just read data (instruction and data-out = don't care) */
-int arm9tdmi_clock_data_in(arm_jtag_t *jtag_info, u32 *in)
+int arm9tdmi_clock_data_in(arm_jtag_t *jtag_info, uint32_t *in)
 {
 	int retval = ERROR_OK;;
 	scan_field_t fields[3];
@@ -345,7 +345,7 @@
 
 		if (in)
 		{
-			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *(u32*)in);
+			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *(uint32_t*)in);
 		}
 		else
 		{
@@ -357,7 +357,7 @@
 	return ERROR_OK;
 }
 
-void arm9tdmi_change_to_arm(target_t *target, u32 *r0, u32 *pc)
+void arm9tdmi_change_to_arm(target_t *target, uint32_t *r0, uint32_t *pc)
 {
 	int retval = ERROR_OK;
 	/* get pointers to arch-specific information */
@@ -412,7 +412,7 @@
 	*pc -= 0xc;
 }
 
-void arm9tdmi_read_core_regs(target_t *target, u32 mask, u32* core_regs[16])
+void arm9tdmi_read_core_regs(target_t *target, uint32_t mask, uint32_t* core_regs[16])
 {
 	int i;
 	/* get pointers to arch-specific information */
@@ -438,7 +438,7 @@
 	}
 }
 
-void arm9tdmi_read_core_regs_target_buffer(target_t *target, u32 mask, void* buffer, int size)
+void arm9tdmi_read_core_regs_target_buffer(target_t *target, uint32_t mask, void* buffer, int size)
 {
 	int i;
 	/* get pointers to arch-specific information */
@@ -446,7 +446,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	int be = (target-&gt;endianness == TARGET_BIG_ENDIAN) ? 1 : 0;
-	u32 *buf_u32 = buffer;
+	uint32_t *buf_u32 = buffer;
 	uint16_t *buf_u16 = buffer;
 	uint8_t *buf_u8 = buffer;
 
@@ -479,7 +479,7 @@
 	}
 }
 
-void arm9tdmi_read_xpsr(target_t *target, u32 *xpsr, int spsr)
+void arm9tdmi_read_xpsr(target_t *target, uint32_t *xpsr, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -503,7 +503,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, xpsr, 0);
 }
 
-void arm9tdmi_write_xpsr(target_t *target, u32 xpsr, int spsr)
+void arm9tdmi_write_xpsr(target_t *target, uint32_t xpsr, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -565,7 +565,7 @@
 	}
 }
 
-void arm9tdmi_write_core_regs(target_t *target, u32 mask, u32 core_regs[16])
+void arm9tdmi_write_core_regs(target_t *target, uint32_t mask, uint32_t core_regs[16])
 {
 	int i;
 	/* get pointers to arch-specific information */
@@ -592,7 +592,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void arm9tdmi_load_word_regs(target_t *target, u32 mask)
+void arm9tdmi_load_word_regs(target_t *target, uint32_t mask)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -628,7 +628,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
 }
 
-void arm9tdmi_store_word_regs(target_t *target, u32 mask)
+void arm9tdmi_store_word_regs(target_t *target, uint32_t mask)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -664,7 +664,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
 }
 
-void arm9tdmi_write_pc(target_t *target, u32 pc)
+void arm9tdmi_write_pc(target_t *target, uint32_t pc)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -761,7 +761,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 }
 
-void arm9tdmi_enable_single_step(target_t *target, u32 next_pc)
+void arm9tdmi_enable_single_step(target_t *target, uint32_t next_pc)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -978,7 +978,7 @@
 	arm7_9_common_t *arm7_9;
 	arm9tdmi_common_t *arm9tdmi;
 	reg_t *vector_catch;
-	u32 vector_catch_value;
+	uint32_t vector_catch_value;
 	int i, j;
 
 	if (arm9tdmi_get_arch_pointers(target, &amp;armv4_5, &amp;arm7_9, &amp;arm9tdmi) != ERROR_OK)

Modified: trunk/src/target/arm9tdmi.h
===================================================================
--- trunk/src/target/arm9tdmi.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm9tdmi.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -37,7 +37,7 @@
 typedef struct arm9tdmi_vector_s
 {
 	char *name;
-	u32 value;
+	uint32_t value;
 } arm9tdmi_vector_t;
 
 enum arm9tdmi_vector
@@ -57,10 +57,10 @@
 extern int arm9tdmi_init_arch_info(target_t *target, arm9tdmi_common_t *arm9tdmi, jtag_tap_t *tap);
 extern int arm9tdmi_register_commands(struct command_context_s *cmd_ctx);
 
-extern int arm9tdmi_clock_out(arm_jtag_t *jtag_info, u32 instr, u32 out, u32 *in, int sysspeed);
-extern int arm9tdmi_clock_data_in(arm_jtag_t *jtag_info, u32 *in);
+extern int arm9tdmi_clock_out(arm_jtag_t *jtag_info, uint32_t instr, uint32_t out, uint32_t *in, int sysspeed);
+extern int arm9tdmi_clock_data_in(arm_jtag_t *jtag_info, uint32_t *in);
 extern int arm9tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info, void *in, int size, int be); 
-extern void arm9tdmi_read_core_regs(target_t *target, u32 mask, u32* core_regs[16]);
-extern void arm9tdmi_write_core_regs(target_t *target, u32 mask, u32 core_regs[16]);
+extern void arm9tdmi_read_core_regs(target_t *target, uint32_t mask, uint32_t* core_regs[16]);
+extern void arm9tdmi_write_core_regs(target_t *target, uint32_t mask, uint32_t core_regs[16]);
 
 #endif /* ARM9TDMI_H */

Modified: trunk/src/target/arm_adi_v5.c
===================================================================
--- trunk/src/target/arm_adi_v5.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_adi_v5.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -56,10 +56,10 @@
 /* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
 
 /*
-	u32 tar_block_size(u32 address)
+	uint32_t tar_block_size(uint32_t address)
 	Return the largest block starting at address that does not cross a tar block size alignment boundary
 */
-static u32 max_tar_block_size(u32 tar_autoincr_block, u32 address)
+static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
 {
 	return (tar_autoincr_block - ((tar_autoincr_block - 1) &amp; address)) &gt;&gt; 2;
 }
@@ -100,8 +100,8 @@
 	return ERROR_OK;
 }
 
-/* Scan out and in from host ordered u32 variables */
-int adi_jtag_dp_scan_u32(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, u32 outvalue, u32 *invalue, uint8_t *ack)
+/* Scan out and in from host ordered uint32_t variables */
+int adi_jtag_dp_scan_u32(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
 {
 	arm_jtag_t *jtag_info = swjdp-&gt;jtag_info;
 	scan_field_t fields[2];
@@ -161,7 +161,7 @@
 	return ERROR_OK;
 }
 
-int scan_inout_check_u32(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, u32 outvalue, u32 *invalue)
+int scan_inout_check_u32(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint32_t outvalue, uint32_t *invalue)
 {
 	adi_jtag_dp_scan_u32(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
@@ -182,7 +182,7 @@
 int swjdp_transaction_endcheck(swjdp_common_t *swjdp)
 {
 	int retval;
-	u32 ctrlstat;
+	uint32_t ctrlstat;
 
 	/* too expensive to call keep_alive() here */
 
@@ -248,7 +248,7 @@
 		}
 		else
 		{
-			u32 mem_ap_csw, mem_ap_tar;
+			uint32_t mem_ap_csw, mem_ap_tar;
 
 			/* Print information about last AHBAP access */
 			LOG_ERROR(&quot;AHBAP Cached values: dp_select 0x%x, ap_csw 0x%x, ap_tar 0x%x&quot;, swjdp-&gt;dp_select_value, swjdp-&gt;ap_csw_value, swjdp-&gt;ap_tar_value);
@@ -287,19 +287,19 @@
  *                                                                         *
 ***************************************************************************/
 
-int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, uint8_t reg_addr)
+int dap_dp_write_reg(swjdp_common_t *swjdp, uint32_t value, uint8_t reg_addr)
 {
 	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_WRITE, value, NULL);
 }
 
-int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, uint8_t reg_addr)
+int dap_dp_read_reg(swjdp_common_t *swjdp, uint32_t *value, uint8_t reg_addr)
 {
 	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_READ, 0, value);
 }
 
 int dap_ap_select(swjdp_common_t *swjdp,uint8_t apsel)
 {
-	u32 select;
+	uint32_t select;
 	select = (apsel&lt;&lt;24) &amp; 0xFF000000;
 
 	if (select != swjdp-&gt;apsel)
@@ -314,9 +314,9 @@
 	return ERROR_OK;
 }
 
-int dap_dp_bankselect(swjdp_common_t *swjdp,u32 ap_reg)
+int dap_dp_bankselect(swjdp_common_t *swjdp,uint32_t ap_reg)
 {
-	u32 select;
+	uint32_t select;
 	select = (ap_reg &amp; 0x000000F0);
 
 	if (select != swjdp-&gt;dp_select_value)
@@ -328,7 +328,7 @@
 	return ERROR_OK;
 }
 
-int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t* out_value_buf)
+int dap_ap_write_reg(swjdp_common_t *swjdp, uint32_t reg_addr, uint8_t* out_value_buf)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
@@ -336,14 +336,14 @@
 	return ERROR_OK;
 }
 
-int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t *in_value_buf)
+int dap_ap_read_reg(swjdp_common_t *swjdp, uint32_t reg_addr, uint8_t *in_value_buf)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_READ, 0, in_value_buf);
 
 	return ERROR_OK;
 }
-int dap_ap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value)
+int dap_ap_write_reg_u32(swjdp_common_t *swjdp, uint32_t reg_addr, uint32_t value)
 {
 	uint8_t out_value_buf[4];
 
@@ -354,7 +354,7 @@
 	return ERROR_OK;
 }
 
-int dap_ap_read_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 *value)
+int dap_ap_read_reg_u32(swjdp_common_t *swjdp, uint32_t reg_addr, uint32_t *value)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
 	scan_inout_check_u32(swjdp, DAP_IR_APACC, reg_addr, DPAP_READ, 0, value);
@@ -368,7 +368,7 @@
  *                                                                         *
 ***************************************************************************/
 
-int dap_setup_accessport(swjdp_common_t *swjdp, u32 csw, u32 tar)
+int dap_setup_accessport(swjdp_common_t *swjdp, uint32_t csw, uint32_t tar)
 {
 	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
 	if (csw != swjdp-&gt;ap_csw_value)
@@ -393,13 +393,13 @@
 
 /*****************************************************************************
 *                                                                            *
-* mem_ap_read_u32(swjdp_common_t *swjdp, u32 address, u32 *value)      *
+* mem_ap_read_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value)      *
 *                                                                            *
-* Read a u32 value from memory or system register                            *
-* Functionally equivalent to target_read_u32(target, address, u32 *value),   *
+* Read a uint32_t value from memory or system register                            *
+* Functionally equivalent to target_read_u32(target, address, uint32_t *value),   *
 * but with less overhead                                                     *
 *****************************************************************************/
-int mem_ap_read_u32(swjdp_common_t *swjdp, u32 address, u32 *value)
+int mem_ap_read_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value)
 {
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
 
@@ -409,7 +409,7 @@
 	return ERROR_OK;
 }
 
-int mem_ap_read_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 *value)
+int mem_ap_read_atomic_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value)
 {
 	mem_ap_read_u32(swjdp, address, value);
 
@@ -418,12 +418,12 @@
 
 /*****************************************************************************
 *                                                                            *
-* mem_ap_write_u32(swjdp_common_t *swjdp, u32 address, u32 value)      *
+* mem_ap_write_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value)      *
 *                                                                            *
-* Write a u32 value to memory or memory mapped register                              *
+* Write a uint32_t value to memory or memory mapped register                              *
 *                                                                            *
 *****************************************************************************/
-int mem_ap_write_u32(swjdp_common_t *swjdp, u32 address, u32 value)
+int mem_ap_write_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value)
 {
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
 
@@ -433,7 +433,7 @@
 	return ERROR_OK;
 }
 
-int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value)
+int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value)
 {
 	mem_ap_write_u32(swjdp, address, value);
 
@@ -442,15 +442,15 @@
 
 /*****************************************************************************
 *                                                                            *
-* mem_ap_write_buf(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address) *
+* mem_ap_write_buf(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address) *
 *                                                                            *
 * Write a buffer in target order (little endian)                             *
 *                                                                            *
 *****************************************************************************/
-int mem_ap_write_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_write_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
-	u32 adr = address;
+	uint32_t adr = address;
 	uint8_t* pBuffer = buffer;
 
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
@@ -464,8 +464,8 @@
 		for (writecount = 0; writecount &lt; count; writecount++)
 		{
 			int i;
-			u32 outvalue;
-			memcpy(&amp;outvalue, pBuffer, sizeof(u32));
+			uint32_t outvalue;
+			memcpy(&amp;outvalue, pBuffer, sizeof(uint32_t));
 
 			for (i = 0; i &lt; 4; i++ )
 			{
@@ -473,7 +473,7 @@
 				outvalue &gt;&gt;= 8;
 				adr++;
 			}
-			pBuffer += sizeof(u32);
+			pBuffer += sizeof(uint32_t);
 		}
 	}
 
@@ -516,7 +516,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_packed_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_write_buf_packed_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -558,8 +558,8 @@
 			}
 			else
 			{
-				u32 outvalue;
-				memcpy(&amp;outvalue, buffer, sizeof(u32));
+				uint32_t outvalue;
+				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
 
 				for (i = 0; i &lt; nbytes; i++ )
 				{
@@ -568,7 +568,7 @@
 					address++;
 				}
 
-				memcpy(&amp;outvalue, buffer, sizeof(u32));
+				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
 				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
 				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
 				{
@@ -587,7 +587,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_write_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
@@ -601,7 +601,7 @@
 		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
 		uint16_t svalue;
 		memcpy(&amp;svalue, buffer, sizeof(uint16_t));
-		u32 outvalue = (u32)svalue &lt;&lt; 8 * (address &amp; 0x3);
+		uint32_t outvalue = (uint32_t)svalue &lt;&lt; 8 * (address &amp; 0x3);
 		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue );
 		retval = swjdp_transaction_endcheck(swjdp);
 		count -= 2;
@@ -612,7 +612,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_packed_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_write_buf_packed_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -650,8 +650,8 @@
 			}
 			else
 			{
-				u32 outvalue;
-				memcpy(&amp;outvalue, buffer, sizeof(u32));
+				uint32_t outvalue;
+				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
 
 				for (i = 0; i &lt; nbytes; i++ )
 				{
@@ -660,7 +660,7 @@
 					address++;
 				}
 
-				memcpy(&amp;outvalue, buffer, sizeof(u32));
+				memcpy(&amp;outvalue, buffer, sizeof(uint32_t));
 				dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue);
 				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
 				{
@@ -679,7 +679,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_write_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int retval = ERROR_OK;
 
@@ -691,7 +691,7 @@
 	while (count &gt; 0)
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
-		u32 outvalue = (u32)*buffer &lt;&lt; 8 * (address &amp; 0x3);
+		uint32_t outvalue = (uint32_t)*buffer &lt;&lt; 8 * (address &amp; 0x3);
 		dap_ap_write_reg_u32(swjdp, AP_REG_DRW, outvalue );
 		retval = swjdp_transaction_endcheck(swjdp);
 		count--;
@@ -704,15 +704,15 @@
 
 /*********************************************************************************
 *                                                                                *
-* mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)  *
+* mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)  *
 *                                                                                *
 * Read block fast in target order (little endian) into a buffer                  *
 *                                                                                *
 **********************************************************************************/
-int mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
 	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
-	u32 adr = address;
+	uint32_t adr = address;
 	uint8_t* pBuffer = buffer;
 
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
@@ -767,8 +767,8 @@
 		for (readcount = 0; readcount &lt; count; readcount++)
 		{
 			int i;
-			u32 data;
-			memcpy(&amp;data, pBuffer, sizeof(u32));
+			uint32_t data;
+			memcpy(&amp;data, pBuffer, sizeof(uint32_t));
 
 			for (i = 0; i &lt; 4; i++ )
 			{
@@ -782,9 +782,9 @@
 	return retval;
 }
 
-int mem_ap_read_buf_packed_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_read_buf_packed_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
-	u32 invalue;
+	uint32_t invalue;
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
 
@@ -834,9 +834,9 @@
 	return retval;
 }
 
-int mem_ap_read_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_read_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
-	u32 invalue, i;
+	uint32_t invalue, i;
 	int retval = ERROR_OK;
 
 	if (count &gt;= 4)
@@ -877,9 +877,9 @@
  * The solution is to arrange for a large out/in scan in this loop and
  * and convert data afterwards.
  */
-int mem_ap_read_buf_packed_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_read_buf_packed_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
-	u32 invalue;
+	uint32_t invalue;
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
 
@@ -926,9 +926,9 @@
 	return retval;
 }
 
-int mem_ap_read_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
+int mem_ap_read_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address)
 {
-	u32 invalue;
+	uint32_t invalue;
 	int retval = ERROR_OK;
 
 	if (count &gt;= 4)
@@ -952,8 +952,8 @@
 
 int ahbap_debugport_init(swjdp_common_t *swjdp)
 {
-	u32 idreg, romaddr, dummy;
-	u32 ctrlstat;
+	uint32_t idreg, romaddr, dummy;
+	uint32_t ctrlstat;
 	int cnt = 0;
 	int retval;
 
@@ -1016,10 +1016,10 @@
 int dap_info_command(struct command_context_s *cmd_ctx, swjdp_common_t *swjdp, int apsel)
 {
 
-	u32 dbgbase,apid;
+	uint32_t dbgbase,apid;
 	int romtable_present = 0;
 	uint8_t mem_ap;
-	u32 apselold;
+	uint32_t apselold;
 
 	apselold = swjdp-&gt;apsel;
 	dap_ap_select(swjdp, apsel);
@@ -1056,7 +1056,7 @@
 	romtable_present = ((mem_ap)&amp;&amp;(dbgbase != 0xFFFFFFFF));
 	if (romtable_present)
 	{
-		u32 cid0,cid1,cid2,cid3,memtype,romentry;
+		uint32_t cid0,cid1,cid2,cid3,memtype,romentry;
 		uint16_t entry_offset;
 		/* bit 16 of apid indicates a memory access port */
 		if (dbgbase&amp;0x02)
@@ -1092,8 +1092,8 @@
 			command_print(cmd_ctx, &quot;\tROMTABLE[0x%x] = 0x%x&quot;,entry_offset,romentry);
 			if (romentry&amp;0x01)
 			{
-				u32 c_cid0,c_cid1,c_cid2,c_cid3,c_pid0,c_pid1,c_pid2,c_pid3,c_pid4,component_start;
-				u32 component_base = (u32)((dbgbase&amp;0xFFFFF000)+(int)(romentry&amp;0xFFFFF000));
+				uint32_t c_cid0,c_cid1,c_cid2,c_cid3,c_pid0,c_pid1,c_pid2,c_pid3,c_pid4,component_start;
+				uint32_t component_base = (uint32_t)((dbgbase&amp;0xFFFFF000)+(int)(romentry&amp;0xFFFFF000));
 				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE0, &amp;c_pid0);
 				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE4, &amp;c_pid1);
 				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE8, &amp;c_pid2);

Modified: trunk/src/target/arm_adi_v5.h
===================================================================
--- trunk/src/target/arm_adi_v5.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_adi_v5.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -86,21 +86,21 @@
 {
 	arm_jtag_t *jtag_info;
 	/* Control config */
-	u32 dp_ctrl_stat;
+	uint32_t dp_ctrl_stat;
 	/* Support for several AP's in one DAP */
-	u32 apsel;
+	uint32_t apsel;
 	/* Register select cache */
-	u32 dp_select_value;
-	u32 ap_csw_value;
-	u32 ap_tar_value;
+	uint32_t dp_select_value;
+	uint32_t ap_csw_value;
+	uint32_t ap_tar_value;
 	/* information about current pending SWjDP-AHBAP transaction */
 	uint8_t  trans_mode;
 	uint8_t  trans_rw;
 	uint8_t  ack;
 	/* extra tck clocks for memory bus access */
-	u32	memaccess_tck;
+	uint32_t	memaccess_tck;
 	/* Size of TAR autoincrement block, ARM ADI Specification requires at least 10 bits */
-	u32 tar_autoincr_block;
+	uint32_t tar_autoincr_block;
 
 } swjdp_common_t;
 
@@ -111,36 +111,36 @@
 }
 
 /* Internal functions used in the module, partial transactions, use with caution */
-extern int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, uint8_t reg_addr);
-/* extern int swjdp_write_apacc(swjdp_common_t *swjdp, u32 value, uint8_t reg_addr); */
-extern int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, uint8_t reg_addr);
-/* extern int swjdp_read_apacc(swjdp_common_t *swjdp, u32 *value, uint8_t reg_addr); */
-extern int dap_setup_accessport(swjdp_common_t *swjdp, u32 csw, u32 tar);
+extern int dap_dp_write_reg(swjdp_common_t *swjdp, uint32_t value, uint8_t reg_addr);
+/* extern int swjdp_write_apacc(swjdp_common_t *swjdp, uint32_t value, uint8_t reg_addr); */
+extern int dap_dp_read_reg(swjdp_common_t *swjdp, uint32_t *value, uint8_t reg_addr);
+/* extern int swjdp_read_apacc(swjdp_common_t *swjdp, uint32_t *value, uint8_t reg_addr); */
+extern int dap_setup_accessport(swjdp_common_t *swjdp, uint32_t csw, uint32_t tar);
 extern int dap_ap_select(swjdp_common_t *swjdp,uint8_t apsel);
 
-extern int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t* out_value_buf);
-extern int dap_ap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value);
-extern int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t *in_value_buf);
-extern int dap_ap_read_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 *value);
+extern int dap_ap_write_reg(swjdp_common_t *swjdp, uint32_t reg_addr, uint8_t* out_value_buf);
+extern int dap_ap_write_reg_u32(swjdp_common_t *swjdp, uint32_t reg_addr, uint32_t value);
+extern int dap_ap_read_reg(swjdp_common_t *swjdp, uint32_t reg_addr, uint8_t *in_value_buf);
+extern int dap_ap_read_reg_u32(swjdp_common_t *swjdp, uint32_t reg_addr, uint32_t *value);
 
 /* External interface, partial operations must be completed with swjdp_transaction_endcheck() */
 extern int swjdp_transaction_endcheck(swjdp_common_t *swjdp);
 
-/* MEM-AP memory mapped bus single u32 register transfers, without endcheck */
-extern int mem_ap_read_u32(swjdp_common_t *swjdp, u32 address, u32 *value);
-extern int mem_ap_write_u32(swjdp_common_t *swjdp, u32 address, u32 value);
+/* MEM-AP memory mapped bus single uint32_t register transfers, without endcheck */
+extern int mem_ap_read_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value);
+extern int mem_ap_write_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value);
 
 /* MEM-AP memory mapped bus transfers, single registers, complete transactions */
-extern int mem_ap_read_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 *value);
-extern int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value);
+extern int mem_ap_read_atomic_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t *value);
+extern int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, uint32_t address, uint32_t value);
 
 /* MEM-AP memory mapped bus block transfers */
-extern int mem_ap_read_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
-extern int mem_ap_read_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
-extern int mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
-extern int mem_ap_write_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
-extern int mem_ap_write_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
-extern int mem_ap_write_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
+extern int mem_ap_read_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
+extern int mem_ap_read_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
+extern int mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
+extern int mem_ap_write_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
+extern int mem_ap_write_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
+extern int mem_ap_write_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, uint32_t address);
 
 /* Initialisation of the debug system, power domains and registers */
 extern int ahbap_debugport_init(swjdp_common_t *swjdp);

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_disassembler.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -33,12 +33,12 @@
 };
 
 /* make up for C's missing ROR */
-u32 ror(u32 value, int places) 
+uint32_t ror(uint32_t value, int places) 
 { 
 	return (value &gt;&gt; places) | (value &lt;&lt; (32 - places)); 
 }
 
-int evaluate_pld(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_pld(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	/* PLD */
 	if ((opcode &amp; 0x0d70f0000) == 0x0550f000)
@@ -59,7 +59,7 @@
 	return -1;
 }
 
-int evaluate_swi(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_swi(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	instruction-&gt;type = ARM_SWI;
 	
@@ -68,11 +68,11 @@
 	return ERROR_OK;
 }
 
-int evaluate_blx_imm(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_blx_imm(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	int offset;
-	u32 immediate;
-	u32 target_address;
+	uint32_t immediate;
+	uint32_t target_address;
 	
 	instruction-&gt;type = ARM_BLX;
 	immediate = opcode &amp; 0x00ffffff;
@@ -100,12 +100,12 @@
 	return ERROR_OK;
 }
 
-int evaluate_b_bl(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_b_bl(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t L;
-	u32 immediate;
+	uint32_t immediate;
 	int offset;
-	u32 target_address;
+	uint32_t target_address;
 	
 	immediate = opcode &amp; 0x00ffffff;
 	L = (opcode &amp; 0x01000000) &gt;&gt; 24;
@@ -137,7 +137,7 @@
 
 /* Coprocessor load/store and double register transfers */
 /* both normal and extended instruction space (condition field b1111) */
-int evaluate_ldc_stc_mcrr_mrrc(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_ldc_stc_mcrr_mrrc(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t cp_num = (opcode &amp; 0xf00) &gt;&gt; 8;
 	
@@ -217,7 +217,7 @@
 /* Coprocessor data processing instructions */
 /* Coprocessor register transfer instructions */
 /* both normal and extended instruction space (condition field b1111) */
-int evaluate_cdp_mcr_mrc(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_cdp_mcr_mrc(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	char* cond;
 	char* mnemonic;
@@ -266,7 +266,7 @@
 }
 
 /* Load/store instructions */
-int evaluate_load_store(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_load_store(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t I, P, U, B, W, L;
 	uint8_t Rn, Rd;
@@ -340,7 +340,7 @@
 	
 	if (!I) /* #+-&lt;offset_12&gt; */
 	{
-		u32 offset_12 = (opcode &amp; 0xfff);
+		uint32_t offset_12 = (opcode &amp; 0xfff);
 		if (offset_12)
 			snprintf(offset, 32, &quot;, #%s0x%x&quot;, (U) ? &quot;&quot; : &quot;-&quot;, offset_12);
 		else
@@ -434,7 +434,7 @@
 }
 
 /* Miscellaneous load/store instructions */
-int evaluate_misc_load_store(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_misc_load_store(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t P, U, I, W, L, S, H;
 	uint8_t Rn, Rd;
@@ -511,7 +511,7 @@
 	
 	if (I) /* Immediate offset/index (#+-&lt;offset_8&gt;)*/
 	{
-		u32 offset_8 = ((opcode &amp; 0xf00) &gt;&gt; 4) | (opcode &amp; 0xf);
+		uint32_t offset_8 = ((opcode &amp; 0xf00) &gt;&gt; 4) | (opcode &amp; 0xf);
 		snprintf(offset, 32, &quot;#%s0x%x&quot;, (U) ? &quot;&quot; : &quot;-&quot;, offset_8);
 		
 		instruction-&gt;info.load_store.offset_mode = 0;
@@ -561,10 +561,10 @@
 }
 
 /* Load/store multiples instructions */
-int evaluate_ldm_stm(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_ldm_stm(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t P, U, S, W, L, Rn;
-	u32 register_list;
+	uint32_t register_list;
 	char *addressing_mode;
 	char *mnemonic;
 	char reg_list[69];
@@ -648,7 +648,7 @@
 }
 
 /* Multiplies, extra load/stores */
-int evaluate_mul_and_extra_ld_st(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_mul_and_extra_ld_st(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	/* Multiply (accumulate) (long) and Swap/swap byte */
 	if ((opcode &amp; 0x000000f0) == 0x00000090)
@@ -739,7 +739,7 @@
 	return evaluate_misc_load_store(opcode, address, instruction);
 }
 
-int evaluate_mrs_msr(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_mrs_msr(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	int R = (opcode &amp; 0x00400000) &gt;&gt; 22;
 	char *PSR = (R) ? &quot;SPSR&quot; : &quot;CPSR&quot;;
@@ -793,7 +793,7 @@
 }
 
 /* Miscellaneous instructions */
-int evaluate_misc_instr(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_misc_instr(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	/* MRS/MSR */
 	if ((opcode &amp; 0x000000f0) == 0x00000000)
@@ -877,7 +877,7 @@
 	/* Software breakpoints */
 	if ((opcode &amp; 0x0000000f0) == 0x00000070)
 	{
-		u32 immediate;
+		uint32_t immediate;
 		instruction-&gt;type = ARM_BKPT;
 		immediate = ((opcode &amp; 0x000fff00) &gt;&gt; 4) | (opcode &amp; 0xf);
 		
@@ -968,7 +968,7 @@
 	return ERROR_OK;
 }
 
-int evaluate_data_proc(u32 opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_data_proc(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t I, op, S, Rn, Rd;
 	char *mnemonic = NULL;
@@ -1057,7 +1057,7 @@
 	{
 		uint8_t immed_8 = opcode &amp; 0xff;
 		uint8_t rotate_imm = (opcode &amp; 0xf00) &gt;&gt; 8;
-		u32 immediate;
+		uint32_t immediate;
 		
 		immediate = ror(immed_8, rotate_imm * 2);
 		
@@ -1175,7 +1175,7 @@
 	return ERROR_OK;
 }
 		
-int arm_evaluate_opcode(u32 opcode, u32 address, arm_instruction_t *instruction)
+int arm_evaluate_opcode(uint32_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	/* clear fields, to avoid confusion */
 	memset(instruction, 0, sizeof(arm_instruction_t));
@@ -1319,11 +1319,11 @@
 	return -1;
 }
 
-int evaluate_b_bl_blx_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_b_bl_blx_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 offset = opcode &amp; 0x7ff;
-	u32 opc = (opcode &gt;&gt; 11) &amp; 0x3;
-	u32 target_address;
+	uint32_t offset = opcode &amp; 0x7ff;
+	uint32_t opc = (opcode &gt;&gt; 11) &amp; 0x3;
+	uint32_t target_address;
 	char *mnemonic = NULL;
 	
 	/* sign extend 11-bit offset */
@@ -1366,13 +1366,13 @@
 	return ERROR_OK;
 }
 
-int evaluate_add_sub_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_add_sub_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7;
 	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7;
 	uint8_t Rm_imm = (opcode &gt;&gt; 6) &amp; 0x7;
-	u32 opc = opcode &amp; (1&lt;&lt;9);
-	u32 reg_imm  = opcode &amp; (1&lt;&lt;10);
+	uint32_t opc = opcode &amp; (1&lt;&lt;9);
+	uint32_t reg_imm  = opcode &amp; (1&lt;&lt;10);
 	char *mnemonic;
 	
 	if (opc)
@@ -1408,7 +1408,7 @@
 	return ERROR_OK;
 }
 
-int evaluate_shift_imm_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_shift_imm_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7;
 	uint8_t Rm = (opcode &gt;&gt; 3) &amp; 0x7;
@@ -1452,11 +1452,11 @@
 	return ERROR_OK;
 }
 
-int evaluate_data_proc_imm_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_data_proc_imm_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t imm = opcode &amp; 0xff;
 	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7;
-	u32 opc = (opcode &gt;&gt; 11) &amp; 0x3;
+	uint32_t opc = (opcode &gt;&gt; 11) &amp; 0x3;
 	char *mnemonic = NULL;
 	
 	instruction-&gt;info.data_proc.Rd = Rd;
@@ -1493,7 +1493,7 @@
 	return ERROR_OK;
 }
 
-int evaluate_data_proc_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_data_proc_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t high_reg, op, Rm, Rd,H1,H2;
 	char *mnemonic = NULL;
@@ -1652,9 +1652,9 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_literal_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_load_literal_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 immediate;
+	uint32_t immediate;
 	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
 
 	instruction-&gt;type = ARM_LDR;
@@ -1671,7 +1671,7 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_reg_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_load_store_reg_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
 	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
@@ -1726,16 +1726,16 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_imm_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_load_store_imm_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 offset = (opcode &gt;&gt; 6) &amp; 0x1f;
+	uint32_t offset = (opcode &gt;&gt; 6) &amp; 0x1f;
 	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
 	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
-	u32 L = opcode &amp; (1&lt;&lt;11);
-	u32 B = opcode &amp; (1&lt;&lt;12);
+	uint32_t L = opcode &amp; (1&lt;&lt;11);
+	uint32_t B = opcode &amp; (1&lt;&lt;12);
 	char *mnemonic;
 	char suffix = ' ';
-	u32 shift = 2;
+	uint32_t shift = 2;
 
 	if (L)
 	{
@@ -1770,11 +1770,11 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_stack_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_load_store_stack_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 offset = opcode  &amp; 0xff;
+	uint32_t offset = opcode  &amp; 0xff;
 	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
-	u32 L = opcode &amp; (1&lt;&lt;11);
+	uint32_t L = opcode &amp; (1&lt;&lt;11);
 	char *mnemonic;
 
 	if (L)
@@ -1799,12 +1799,12 @@
 	return ERROR_OK;
 }
 
-int evaluate_add_sp_pc_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_add_sp_pc_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 imm = opcode  &amp; 0xff;
+	uint32_t imm = opcode  &amp; 0xff;
 	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
 	uint8_t Rn;
-	u32 SP = opcode &amp; (1&lt;&lt;11);
+	uint32_t SP = opcode &amp; (1&lt;&lt;11);
 	char *reg_name;
 
 	instruction-&gt;type = ARM_ADD;
@@ -1830,9 +1830,9 @@
 	return ERROR_OK;
 }
 
-int evaluate_adjust_stack_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_adjust_stack_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 imm = opcode  &amp; 0x7f;
+	uint32_t imm = opcode  &amp; 0x7f;
 	uint8_t opc = opcode &amp; (1&lt;&lt;7);
 	char *mnemonic;
 
@@ -1858,9 +1858,9 @@
 	return ERROR_OK;
 }
 
-int evaluate_breakpoint_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_breakpoint_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 imm = opcode  &amp; 0xff;
+	uint32_t imm = opcode  &amp; 0xff;
 	
 	instruction-&gt;type = ARM_BKPT;
 
@@ -1869,11 +1869,11 @@
 	return ERROR_OK;
 }
 
-int evaluate_load_store_multiple_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_load_store_multiple_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 reg_list = opcode  &amp; 0xff;
-	u32 L = opcode &amp; (1&lt;&lt;11);
-	u32 R = opcode &amp; (1&lt;&lt;8);
+	uint32_t reg_list = opcode  &amp; 0xff;
+	uint32_t L = opcode &amp; (1&lt;&lt;11);
+	uint32_t R = opcode &amp; (1&lt;&lt;8);
 	uint8_t Rn = (opcode &gt;&gt; 8) &amp; 7;
 	uint8_t addr_mode = 0 /* IA */;
 	char reg_names[40];
@@ -1936,11 +1936,11 @@
 	return ERROR_OK;
 }
 
-int evaluate_cond_branch_thumb(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int evaluate_cond_branch_thumb(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
-	u32 offset = opcode  &amp; 0xff;
+	uint32_t offset = opcode  &amp; 0xff;
 	uint8_t cond = (opcode &gt;&gt; 8) &amp; 0xf;
-	u32 target_address;
+	uint32_t target_address;
 
 	if (cond == 0xf)
 	{
@@ -1971,7 +1971,7 @@
 	return ERROR_OK;
 }
 
-int thumb_evaluate_opcode(uint16_t opcode, u32 address, arm_instruction_t *instruction)
+int thumb_evaluate_opcode(uint16_t opcode, uint32_t address, arm_instruction_t *instruction)
 {
 	/* clear fields, to avoid confusion */
 	memset(instruction, 0, sizeof(arm_instruction_t));

Modified: trunk/src/target/arm_disassembler.h
===================================================================
--- trunk/src/target/arm_disassembler.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_disassembler.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -123,13 +123,13 @@
 typedef struct arm_b_bl_bx_blx_instr_s
 {
 	int reg_operand;
-	u32 target_address;
+	uint32_t target_address;
 } arm_b_bl_bx_blx_instr_t;
 
 union arm_shifter_operand
 {
 	struct {
-		u32 immediate;
+		uint32_t immediate;
 	} immediate;
 	struct {
 		uint8_t Rm;
@@ -161,7 +161,7 @@
 	int offset_mode; /* 0: immediate, 1: (scaled) register */
 	union
 	{
-		u32 offset;
+		uint32_t offset;
 		struct {
 			uint8_t Rm;
 			uint8_t shift; /* 0: LSL, 1: LSR, 2: ASR, 3: ROR, 4: RRX */
@@ -173,7 +173,7 @@
 typedef struct arm_load_store_multiple_instr_s
 {
 	uint8_t Rn;
-	u32 register_list;
+	uint32_t register_list;
 	uint8_t addressing_mode; /* 0: IA, 1: IB, 2: DA, 3: DB */
 	uint8_t S;
 	uint8_t W;
@@ -183,7 +183,7 @@
 {
 	enum arm_instruction_type type;
 	char text[128];
-	u32 opcode;
+	uint32_t opcode;
 	
 	union {
 		arm_b_bl_bx_blx_instr_t b_bl_bx_blx;
@@ -194,8 +194,8 @@
 
 } arm_instruction_t;
 
-extern int arm_evaluate_opcode(u32 opcode, u32 address, arm_instruction_t *instruction);
-extern int thumb_evaluate_opcode(uint16_t opcode, u32 address, arm_instruction_t *instruction);
+extern int arm_evaluate_opcode(uint32_t opcode, uint32_t address, arm_instruction_t *instruction);
+extern int thumb_evaluate_opcode(uint16_t opcode, uint32_t address, arm_instruction_t *instruction);
 extern int arm_access_size(arm_instruction_t *instruction);
 
 #define COND(opcode) (arm_condition_strings[(opcode &amp; 0xf0000000)&gt;&gt;28])

Modified: trunk/src/target/arm_jtag.c
===================================================================
--- trunk/src/target/arm_jtag.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_jtag.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -31,7 +31,7 @@
 #define _ARM_JTAG_SCAN_N_CHECK_
 #endif
 
-int arm_jtag_set_instr(arm_jtag_t *jtag_info, u32 new_instr,  void *no_verify_capture)
+int arm_jtag_set_instr(arm_jtag_t *jtag_info, uint32_t new_instr,  void *no_verify_capture)
 {
 	jtag_tap_t *tap;
 	tap = jtag_info-&gt;tap;
@@ -66,12 +66,12 @@
 	return ERROR_OK;
 }
 
-int arm_jtag_scann(arm_jtag_t *jtag_info, u32 new_scan_chain)
+int arm_jtag_scann(arm_jtag_t *jtag_info, uint32_t new_scan_chain)
 {
 	int retval = ERROR_OK;
 	if(jtag_info-&gt;cur_scan_chain != new_scan_chain)
 	{
-		u32 values[1];
+		uint32_t values[1];
 		int num_bits[1];
 
 		values[0]=new_scan_chain;
@@ -115,15 +115,15 @@
 	return jtag_register_event_callback(arm_jtag_reset_callback, jtag_info);
 }
 
-/* read JTAG buffer into host-endian u32, flipping bit-order */
+/* read JTAG buffer into host-endian uint32_t, flipping bit-order */
 int arm_jtag_buf_to_u32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	u32 *dest = priv;
+	uint32_t *dest = priv;
 	*dest = flip_u32(le_to_h_u32(in_buf), 32);
 	return ERROR_OK;
 }
 
-/* read JTAG buffer into little-endian u32, flipping bit-order */
+/* read JTAG buffer into little-endian uint32_t, flipping bit-order */
 int arm_jtag_buf_to_le32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
 	h_u32_to_le(((uint8_t*)priv), flip_u32(le_to_h_u32(in_buf), 32));
@@ -137,7 +137,7 @@
 	return ERROR_OK;
 }
 
-/* read JTAG buffer into big-endian u32, flipping bit-order */
+/* read JTAG buffer into big-endian uint32_t, flipping bit-order */
 int arm_jtag_buf_to_be32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
 	h_u32_to_be(((uint8_t*)priv), flip_u32(le_to_h_u32(in_buf), 32));
@@ -160,15 +160,15 @@
 }
 
 /* not-flipping variants */
-/* read JTAG buffer into host-endian u32 */
+/* read JTAG buffer into host-endian uint32_t */
 int arm_jtag_buf_to_u32(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	u32 *dest = priv;
+	uint32_t *dest = priv;
 	*dest = le_to_h_u32(in_buf);
 	return ERROR_OK;
 }
 
-/* read JTAG buffer into little-endian u32 */
+/* read JTAG buffer into little-endian uint32_t */
 int arm_jtag_buf_to_le32(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
 	h_u32_to_le(((uint8_t*)priv), le_to_h_u32(in_buf));
@@ -182,7 +182,7 @@
 	return ERROR_OK;
 }
 
-/* read JTAG buffer into big-endian u32 */
+/* read JTAG buffer into big-endian uint32_t */
 int arm_jtag_buf_to_be32(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
 	h_u32_to_be(((uint8_t*)priv), le_to_h_u32(in_buf));

Modified: trunk/src/target/arm_jtag.h
===================================================================
--- trunk/src/target/arm_jtag.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_jtag.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -29,15 +29,15 @@
 {
 	jtag_tap_t *tap;
 
-	u32 scann_size;
-	u32 scann_instr;
-	u32 cur_scan_chain;
+	uint32_t scann_size;
+	uint32_t scann_instr;
+	uint32_t cur_scan_chain;
 
-	u32 intest_instr;
+	uint32_t intest_instr;
 } arm_jtag_t;
 
-extern int arm_jtag_set_instr(arm_jtag_t *jtag_info, u32 new_instr, void *verify_capture);
-extern int arm_jtag_scann(arm_jtag_t *jtag_info, u32 new_scan_chain);
+extern int arm_jtag_set_instr(arm_jtag_t *jtag_info, uint32_t new_instr, void *verify_capture);
+extern int arm_jtag_scann(arm_jtag_t *jtag_info, uint32_t new_scan_chain);
 extern int arm_jtag_setup_connection(arm_jtag_t *jtag_info);
 
 /* JTAG buffers to host, be and le buffers, flipping variants */
@@ -60,12 +60,12 @@
 /* use this as a static so we can inline it in -O3 and refer to it via a pointer  */
 static __inline__ void arm7flip32(uint8_t *in)
 {
-	*((u32 *)in)=flip_u32(le_to_h_u32(in), 32);
+	*((uint32_t *)in)=flip_u32(le_to_h_u32(in), 32);
 }
 
 static __inline__ void arm_le_to_h_u32(uint8_t *in)
 {
-	*((u32 *)in)=le_to_h_u32(in);
+	*((uint32_t *)in)=le_to_h_u32(in);
 }
 
 

Modified: trunk/src/target/arm_simulator.c
===================================================================
--- trunk/src/target/arm_simulator.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_simulator.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -31,9 +31,9 @@
 #include &quot;binarybuffer.h&quot;
 
 
-u32 arm_shift(uint8_t shift, u32 Rm, u32 shift_amount, uint8_t *carry)
+uint32_t arm_shift(uint8_t shift, uint32_t Rm, uint32_t shift_amount, uint8_t *carry)
 {
-	u32 return_value = 0;
+	uint32_t return_value = 0;
 	shift_amount &amp;= 0xff;
 	
 	if (shift == 0x0) /* LSL */
@@ -122,9 +122,9 @@
 	return return_value;
 }
 
-u32 arm_shifter_operand(armv4_5_common_t *armv4_5, int variant, union arm_shifter_operand shifter_operand, uint8_t *shifter_carry_out)
+uint32_t arm_shifter_operand(armv4_5_common_t *armv4_5, int variant, union arm_shifter_operand shifter_operand, uint8_t *shifter_carry_out)
 {
-	u32 return_value;
+	uint32_t return_value;
 	int instruction_size;
 	
 	if (armv4_5-&gt;core_state == ARMV4_5_STATE_ARM)
@@ -140,7 +140,7 @@
 	}
 	else if (variant == 1) /* immediate shift */
 	{
-		u32 Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.immediate_shift.Rm).value, 0, 32);
+		uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.immediate_shift.Rm).value, 0, 32);
 		
 		/* adjust RM in case the PC is being read */
 		if (shifter_operand.immediate_shift.Rm == 15)
@@ -150,8 +150,8 @@
 	}
 	else if (variant == 2) /* register shift */
 	{
-		u32 Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.register_shift.Rm).value, 0, 32);
-		u32 Rs = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.register_shift.Rs).value, 0, 32);
+		uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.register_shift.Rm).value, 0, 32);
+		uint32_t Rs = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, shifter_operand.register_shift.Rs).value, 0, 32);
 		
 		/* adjust RM in case the PC is being read */
 		if (shifter_operand.register_shift.Rm == 15)
@@ -168,7 +168,7 @@
 	return return_value;
 }
 
-int pass_condition(u32 cpsr, u32 opcode)
+int pass_condition(uint32_t cpsr, uint32_t opcode)
 {
 	switch ((opcode &amp; 0xf0000000) &gt;&gt; 28)
 	{
@@ -258,7 +258,7 @@
 	return 0;
 }
 
-int thumb_pass_branch_condition(u32 cpsr, uint16_t opcode)
+int thumb_pass_branch_condition(uint32_t cpsr, uint16_t opcode)
 {
 	return pass_condition(cpsr, (opcode &amp; 0x0f00) &lt;&lt; 20); 
 }
@@ -267,17 +267,17 @@
  * if the dry_run_pc argument is provided, no state is changed,
  * but the new pc is stored in the variable pointed at by the argument
  */
-int arm_simulate_step(target_t *target, u32 *dry_run_pc)
+int arm_simulate_step(target_t *target, uint32_t *dry_run_pc)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
-	u32 current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+	uint32_t current_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 	arm_instruction_t instruction;
 	int instruction_size;
 	int retval = ERROR_OK;
 	
 	if (armv4_5-&gt;core_state == ARMV4_5_STATE_ARM)
 	{
-		u32 opcode;
+		uint32_t opcode;
 		
 		/* get current instruction, and identify it */
 		if((retval = target_read_u32(target, current_pc, &amp;opcode)) != ERROR_OK)
@@ -341,7 +341,7 @@
 	/* branch instructions */
 	if ((instruction.type &gt;= ARM_B) &amp;&amp; (instruction.type &lt;= ARM_BLX))
 	{
-		u32 target;
+		uint32_t target;
 		
 		if (instruction.info.b_bl_bx_blx.reg_operand == -1)
 		{
@@ -369,7 +369,7 @@
 			}
 			else if (instruction.type == ARM_BL)
 			{
-				u32 old_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+				uint32_t old_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 14).value, 0, 32, old_pc + 4);
 				buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, target);
 			}
@@ -387,7 +387,7 @@
 			}
 			else if (instruction.type == ARM_BLX)
 			{
-				u32 old_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
+				uint32_t old_pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
 				buf_set_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 14).value, 0, 32, old_pc + 4);
 
 				if (target &amp; 0x1)
@@ -408,7 +408,7 @@
 	else if (((instruction.type &gt;= ARM_AND) &amp;&amp; (instruction.type &lt;= ARM_RSC))
 			|| ((instruction.type &gt;= ARM_ORR) &amp;&amp; (instruction.type &lt;= ARM_MVN)))
 	{
-		u32 Rd, Rn, shifter_operand;
+		uint32_t Rd, Rn, shifter_operand;
 		uint8_t C = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
 		uint8_t carry_out;
 		
@@ -491,8 +491,8 @@
 	/* load register instructions */
 	else if ((instruction.type &gt;= ARM_LDR) &amp;&amp; (instruction.type &lt;= ARM_LDRSH))
 	{
-		u32 load_address = 0, modified_address = 0, load_value;
-		u32 Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.Rn).value, 0, 32);
+		uint32_t load_address = 0, modified_address = 0, load_value;
+		uint32_t Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.Rn).value, 0, 32);
 		
 		/* adjust Rn in case the PC is being read */
 		if (instruction.info.load_store.Rn == 15)
@@ -507,8 +507,8 @@
 		}
 		else if (instruction.info.load_store.offset_mode == 1)
 		{
-			u32 offset;
-			u32 Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.offset.reg.Rm).value, 0, 32);
+			uint32_t offset;
+			uint32_t Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.offset.reg.Rm).value, 0, 32);
 			uint8_t shift = instruction.info.load_store.offset.reg.shift;
 			uint8_t shift_imm = instruction.info.load_store.offset.reg.shift_imm;
 			uint8_t carry = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
@@ -584,8 +584,8 @@
 	else if (instruction.type == ARM_LDM)
 	{
 		int i;
-		u32 Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32);
-		u32 load_values[16];
+		uint32_t Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32);
+		uint32_t load_values[16];
 		int bits_set = 0;
 
 		for (i = 0; i &lt; 16; i++)
@@ -653,7 +653,7 @@
 			
 			if (update_cpsr)
 			{
-				u32 spsr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 16).value, 0, 32);
+				uint32_t spsr = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 16).value, 0, 32);
 				buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32, spsr);
 			}
 			
@@ -676,7 +676,7 @@
 		}
 		else
 		{
-			u32 Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32);
+			uint32_t Rn = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store_multiple.Rn).value, 0, 32);
 			int bits_set = 0;
 			enum armv4_5_mode mode = armv4_5-&gt;core_mode;
 

Modified: trunk/src/target/arm_simulator.h
===================================================================
--- trunk/src/target/arm_simulator.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/arm_simulator.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -24,7 +24,7 @@
 
 struct target_s;
 
-extern int arm_simulate_step(struct target_s *target, u32 *dry_run_pc);
+extern int arm_simulate_step(struct target_s *target, uint32_t *dry_run_pc);
 
 #define ERROR_ARM_SIMULATOR_NOT_IMPLEMENTED	(-700)
 

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv4_5.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -190,7 +190,7 @@
 	armv4_5_core_reg_t *armv4_5 = reg-&gt;arch_info;
 	target_t *target = armv4_5-&gt;target;
 	armv4_5_common_t *armv4_5_target = target-&gt;arch_info;
-	u32 value = buf_get_u32(buf, 0, 32);
+	uint32_t value = buf_get_u32(buf, 0, 32);
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -388,11 +388,11 @@
 	int retval = ERROR_OK;
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
-	u32 address;
+	uint32_t address;
 	int count;
 	int i;
 	arm_instruction_t cur_instruction;
-	u32 opcode;
+	uint32_t opcode;
 	uint16_t thumb_opcode;
 	int thumb = 0;
 
@@ -486,7 +486,7 @@
 }
 
 /* wait for execution to complete and check exit point */
-static int armv4_5_run_algorithm_completion(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info)
+static int armv4_5_run_algorithm_completion(struct target_s *target, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -515,14 +515,14 @@
 	return ERROR_OK;
 }
 
-int armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info))
+int armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, uint32_t exit_point, int timeout_ms, void *arch_info))
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	armv4_5_algorithm_t *armv4_5_algorithm_info = arch_info;
 	enum armv4_5_state core_state = armv4_5-&gt;core_state;
 	enum armv4_5_mode core_mode = armv4_5-&gt;core_mode;
-	u32 context[17];
-	u32 cpsr;
+	uint32_t context[17];
+	uint32_t cpsr;
 	int exit_breakpoint_size = 0;
 	int i;
 	int retval = ERROR_OK;
@@ -650,7 +650,7 @@
 
 	for (i = 0; i &lt;= 16; i++)
 	{
-		u32 regvalue;
+		uint32_t regvalue;
 		regvalue = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5_algorithm_info-&gt;core_mode, i).value, 0, 32);
 		if (regvalue != context[i])
 		{
@@ -670,7 +670,7 @@
 	return retval;
 }
 
-int armv4_5_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info)
+int armv4_5_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
 	return armv4_5_run_algorithm_inner(target, num_mem_params, mem_params, num_reg_params, reg_params, entry_point, exit_point, timeout_ms, arch_info, armv4_5_run_algorithm_completion);
 }

Modified: trunk/src/target/armv4_5.h
===================================================================
--- trunk/src/target/armv4_5.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv4_5.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -78,7 +78,7 @@
 	enum armv4_5_state core_state;
 	int (*full_context)(struct target_s *target);
 	int (*read_core_reg)(struct target_s *target, int num, enum armv4_5_mode mode);
-	int (*write_core_reg)(struct target_s *target, int num, enum armv4_5_mode mode, u32 value);
+	int (*write_core_reg)(struct target_s *target, int num, enum armv4_5_mode mode, uint32_t value);
 	void *arch_info;
 } armv4_5_common_t;
 
@@ -143,7 +143,7 @@
 extern int armv4_5_register_commands(struct command_context_s *cmd_ctx);
 extern int armv4_5_init_arch_info(target_t *target, armv4_5_common_t *armv4_5);
 
-extern int armv4_5_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info);
+extern int armv4_5_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
 
 extern int armv4_5_invalidate_core_regs(target_t *target);
 

Modified: trunk/src/target/armv4_5_cache.c
===================================================================
--- trunk/src/target/armv4_5_cache.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv4_5_cache.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -24,7 +24,7 @@
 #include &quot;armv4_5_cache.h&quot;
 #include &quot;log.h&quot;
 
-int armv4_5_identify_cache(u32 cache_type_reg, armv4_5_cache_common_t *cache)
+int armv4_5_identify_cache(uint32_t cache_type_reg, armv4_5_cache_common_t *cache)
 {
 	int size, assoc, M, len, multiplier;
 

Modified: trunk/src/target/armv4_5_cache.h
===================================================================
--- trunk/src/target/armv4_5_cache.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv4_5_cache.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -42,8 +42,8 @@
 	int d_u_cache_enabled;
 } armv4_5_cache_common_t;
 
-extern int armv4_5_identify_cache(u32 cache_type_reg, armv4_5_cache_common_t *cache);
-extern int armv4_5_cache_state(u32 cp15_control_reg, armv4_5_cache_common_t *cache);
+extern int armv4_5_identify_cache(uint32_t cache_type_reg, armv4_5_cache_common_t *cache);
+extern int armv4_5_cache_state(uint32_t cp15_control_reg, armv4_5_cache_common_t *cache);
 
 extern int armv4_5_handle_cache_info_command(struct command_context_s *cmd_ctx, armv4_5_cache_common_t *armv4_5_cache);
 

Modified: trunk/src/target/armv4_5_mmu.c
===================================================================
--- trunk/src/target/armv4_5_mmu.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv4_5_mmu.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -25,18 +25,18 @@
 #include &quot;armv4_5_mmu.h&quot;
 
 
-u32 armv4mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 va, int *type, u32 *cb, int *domain, u32 *ap);
+uint32_t armv4mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t va, int *type, uint32_t *cb, int *domain, uint32_t *ap);
 
 char* armv4_5_mmu_page_type_names[] =
 {
 	&quot;section&quot;, &quot;large page&quot;, &quot;small page&quot;, &quot;tiny page&quot;
 };
 
-u32 armv4_5_mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 va, int *type, u32 *cb, int *domain, u32 *ap)
+uint32_t armv4_5_mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t va, int *type, uint32_t *cb, int *domain, uint32_t *ap)
 {
-	u32 first_lvl_descriptor = 0x0;
-	u32 second_lvl_descriptor = 0x0;
-	u32 ttb = armv4_5_mmu-&gt;get_ttb(target);
+	uint32_t first_lvl_descriptor = 0x0;
+	uint32_t second_lvl_descriptor = 0x0;
+	uint32_t ttb = armv4_5_mmu-&gt;get_ttb(target);
 
 	armv4_5_mmu_read_physical(target, armv4_5_mmu,
 		(ttb &amp; 0xffffc000) | ((va &amp; 0xfff00000) &gt;&gt; 18),
@@ -130,7 +130,7 @@
 	return ERROR_TARGET_TRANSLATION_FAULT;
 }
 
-int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer)
+int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 
@@ -150,7 +150,7 @@
 	return retval;
 }
 
-int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer)
+int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 
@@ -172,12 +172,12 @@
 
 int armv4_5_mmu_handle_virt2phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc, target_t *target, armv4_5_mmu_common_t *armv4_5_mmu)
 {
-	u32 va;
-	u32 pa;
+	uint32_t va;
+	uint32_t pa;
 	int type;
-	u32 cb;
+	uint32_t cb;
 	int domain;
-	u32 ap;
+	uint32_t ap;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -219,7 +219,7 @@
 {
 	int count = 1;
 	int size = 4;
-	u32 address = 0;
+	uint32_t address = 0;
 	int i;
 
 	char output[128];
@@ -311,8 +311,8 @@
 
 int armv4_5_mmu_handle_mw_phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc, target_t *target, armv4_5_mmu_common_t *armv4_5_mmu)
 {
-	u32 address = 0;
-	u32 value = 0;
+	uint32_t address = 0;
+	uint32_t value = 0;
 	int retval;
 	uint8_t value_buf[4];
 

Modified: trunk/src/target/armv4_5_mmu.h
===================================================================
--- trunk/src/target/armv4_5_mmu.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv4_5_mmu.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -25,9 +25,9 @@
 
 typedef struct armv4_5_mmu_common_s
 {
-	u32 (*get_ttb)(target_t *target);
-	int (*read_memory)(target_t *target, u32 address, u32 size, u32 count, uint8_t *buffer);
-	int (*write_memory)(target_t *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+	uint32_t (*get_ttb)(target_t *target);
+	int (*read_memory)(target_t *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*write_memory)(target_t *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 	void (*disable_mmu_caches)(target_t *target, int mmu, int d_u_cache, int i_cache);
 	void (*enable_mmu_caches)(target_t *target, int mmu, int d_u_cache, int i_cache);
 	armv4_5_cache_common_t armv4_5_cache;
@@ -42,9 +42,9 @@
 
 extern char* armv4_5_page_type_names[];
 
-extern u32 armv4_5_mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 va, int *type, u32 *cb, int *domain, u32 *ap);
-extern int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer);
-extern int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer);
+extern uint32_t armv4_5_mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t va, int *type, uint32_t *cb, int *domain, uint32_t *ap);
+extern int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+extern int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 extern int armv4_5_mmu_handle_virt2phys_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, target_t *target, armv4_5_mmu_common_t *armv4_5_mmu);
 extern int armv4_5_mmu_handle_md_phys_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, target_t *target, armv4_5_mmu_common_t *armv4_5_mmu);

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv7m.c	2009-06-18 07:08:52 UTC (rev 2278)
@@ -175,7 +175,7 @@
 {
 	armv7m_core_reg_t *armv7m_reg = reg-&gt;arch_info;
 	target_t *target = armv7m_reg-&gt;target;
-	u32 value = buf_get_u32(buf, 0, 32);
+	uint32_t value = buf_get_u32(buf, 0, 32);
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -191,7 +191,7 @@
 
 int armv7m_read_core_reg(struct target_s *target, int num)
 {
-	u32 reg_value;
+	uint32_t reg_value;
 	int retval;
 	armv7m_core_reg_t * armv7m_core_reg;
 
@@ -213,7 +213,7 @@
 int armv7m_write_core_reg(struct target_s *target, int num)
 {
 	int retval;
-	u32 reg_value;
+	uint32_t reg_value;
 	armv7m_core_reg_t *armv7m_core_reg;
 
 	/* get pointers to arch-specific information */
@@ -289,9 +289,9 @@
 }
 
 /* run to exit point. return error if exit point was not reached. */
-static int armv7m_run_and_wait(struct target_s *target, u32 entry_point, int timeout_ms, u32 exit_point, armv7m_common_t *armv7m)
+static int armv7m_run_and_wait(struct target_s *target, uint32_t entry_point, int timeout_ms, uint32_t exit_point, armv7m_common_t *armv7m)
 {
-	u32 pc;
+	uint32_t pc;
 	int retval;
 	/* This code relies on the target specific  resume() and  poll()-&gt;debug_entry()
 	 * sequence to write register values to the processor and the read them back */
@@ -323,7 +323,7 @@
 	return ERROR_OK;
 }
 
-int armv7m_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info)
+int armv7m_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -331,7 +331,7 @@
 	enum armv7m_mode core_mode = armv7m-&gt;core_mode;
 	int retval = ERROR_OK;
 	int i;
-	u32 context[ARMV7NUMCOREREGS];
+	uint32_t context[ARMV7NUMCOREREGS];
 
 	if (armv7m_algorithm_info-&gt;common_magic != ARMV7M_COMMON_MAGIC)
 	{
@@ -363,7 +363,7 @@
 	for (i = 0; i &lt; num_reg_params; i++)
 	{
 		reg_t *reg = register_get_by_name(armv7m-&gt;core_cache, reg_params[i].reg_name, 0);
-//		u32 regvalue;
+//		uint32_t regvalue;
 
 		if (!reg)
 		{
@@ -440,7 +440,7 @@
 
 	for (i = ARMV7NUMCOREREGS-1; i &gt;= 0; i--)
 	{
-		u32 regvalue;
+		uint32_t regvalue;
 		regvalue = buf_get_u32(armv7m-&gt;core_cache-&gt;reg_list[i].value, 0, 32);
 		if (regvalue != context[i])
 		{
@@ -553,7 +553,7 @@
 	return ERROR_OK;
 }
 
-int armv7m_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum)
+int armv7m_checksum_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum)
 {
 	working_area_t *crc_algorithm;
 	armv7m_algorithm_t armv7m_info;
@@ -591,7 +591,7 @@
 		0x1DB7, 0x04C1			/* CRC32XOR:	.word 0x04C11DB7 */
 	};
 
-	u32 i;
+	uint32_t i;
 
 	if (target_alloc_working_area(target, sizeof(cortex_m3_crc_code), &amp;crc_algorithm) != ERROR_OK)
 	{
@@ -634,13 +634,13 @@
 	return ERROR_OK;
 }
 
-int armv7m_blank_check_memory(struct target_s *target, u32 address, u32 count, u32* blank)
+int armv7m_blank_check_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* blank)
 {
 	working_area_t *erase_check_algorithm;
 	reg_param_t reg_params[3];
 	armv7m_algorithm_t armv7m_info;
 	int retval;
-	u32 i;
+	uint32_t i;
 
 	uint16_t erase_check_code[] =
 	{
@@ -704,7 +704,7 @@
 	target_t *target = get_current_target(cmd_ctx);
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u32 apsel, apselsave, baseaddr;
+	uint32_t apsel, apselsave, baseaddr;
 	int retval;
 
 	apsel = swjdp-&gt;apsel;
@@ -739,7 +739,7 @@
 	target_t *target = get_current_target(cmd_ctx);
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u32 apsel, apselsave, apid;
+	uint32_t apsel, apselsave, apid;
 	int retval;
 
 	apsel = swjdp-&gt;apsel;
@@ -770,7 +770,7 @@
 	target_t *target = get_current_target(cmd_ctx);
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u32 apsel, apid;
+	uint32_t apsel, apid;
 	int retval;
 
 	apsel = 0;
@@ -792,7 +792,7 @@
 	target_t *target = get_current_target(cmd_ctx);
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u32 memaccess_tck;
+	uint32_t memaccess_tck;
 
 	memaccess_tck = swjdp-&gt;memaccess_tck;
 	if (argc &gt; 0)
@@ -812,7 +812,7 @@
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
 	int retval;
-	u32 apsel;
+	uint32_t apsel;
 
 	apsel =  swjdp-&gt;apsel;
 	if (argc &gt; 0)

Modified: trunk/src/target/armv7m.h
===================================================================
--- trunk/src/target/armv7m.h	2009-06-18 07:07:59 UTC (rev 2277)
+++ trunk/src/target/armv7m.h	2009-06-18 07:08:52 UTC (rev 2278)
@@ -80,8 +80,8 @@
 
 	
 	/* Direct processor core register read and writes */
-	int (*load_core_reg_u32)(struct target_s *target, enum armv7m_regtype type, u32 num, u32 *value);
-	int (*store_core_reg_u32)(struct target_s *target, enum armv7m_regtype type, u32 num, u32 value);
+	int (*load_core_reg_u32)(struct target_s *target, enum armv7m_regtype type, uint32_t num, uint32_t *value);
+	int (*store_core_reg_u32)(struct target_s *target, enum armv7m_regtype type, uint32_t num, uint32_t value);
 	/* register cache to processor synchronization */
 	int (*read_core_reg)(struct target_s *target, int num);
 	int (*write_core_reg)(struct target_s *target, int num);
@@ -105,7 +105,7 @@
 
 typedef struct armv7m_core_reg_s
 {
-	u32 num;
+	uint32_t num;
 	enum armv7m_regtype type;
 	enum armv7m_mode mode;
 	target_t *target;
@@ -122,14 +122,14 @@
 extern int armv7m_register_commands(struct command_context_s *cmd_ctx);
 extern int armv7m_init_arch_info(target_t *target, armv7m_common_t *armv7m);
 
-extern int armv7m_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info);
+extern int armv7m_run_algorithm(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, uint32_t entry_point, uint32_t exit_point, int timeout_ms, void *arch_info);
 
 extern int armv7m_invalidate_core_regs(target_t *target);
 
 extern int armv7m_restore_context(target_t *target);
 
-extern int armv7m_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum);
-extern int armv7m_blank_check_memory(struct target_s *target, u32 address, u32 count, u32* blank);
+extern int armv7m_checksum_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* checksum);
+extern int armv7m_blank_check_memory(struct target_s *target, uint32_t address, uint32_t count, uint32_t* blank);
 
 /* Thumb mode instructions
  */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001061.html">[Openocd-svn] r2277 - in trunk/src: flash helper jtag jtag/rlink	target
</A></li>
	<LI>Next message: <A HREF="001063.html">[Openocd-svn] r2279 - trunk/src/target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1062">[ date ]</a>
              <a href="thread.html#1062">[ thread ]</a>
              <a href="subject.html#1062">[ subject ]</a>
              <a href="author.html#1062">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
