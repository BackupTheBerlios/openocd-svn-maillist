<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2373 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target xsvf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2373%20-%20in%20trunk/src%3A%20flash%20flash/ocl/at91sam7x%0A%09helper%20jtag%20jtag/zy1000%20server%20target%20xsvf&In-Reply-To=%3C200906232245.n5NMj8gv020271%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001156.html">
   <LINK REL="Next"  HREF="001158.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2373 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target xsvf</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2373%20-%20in%20trunk/src%3A%20flash%20flash/ocl/at91sam7x%0A%09helper%20jtag%20jtag/zy1000%20server%20target%20xsvf&In-Reply-To=%3C200906232245.n5NMj8gv020271%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2373 - in trunk/src: flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 server target xsvf">zwelch at mail.berlios.de
       </A><BR>
    <I>Wed Jun 24 00:45:08 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001156.html">[Openocd-svn] r2372 - in trunk: src src/flash	src/flash/ocl/at91sam7x src/helper src/jtag	src/jtag/minidummy src/jtag/rlink src/jtag/zy1000 src/pld	src/server src/target src/xsvf testing/examples/cortex
</A></li>
        <LI>Next message: <A HREF="001158.html">[Openocd-svn] r2374 - in trunk/src: . flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1157">[ date ]</a>
              <a href="thread.html#1157">[ thread ]</a>
              <a href="subject.html#1157">[ subject ]</a>
              <a href="author.html#1157">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-24 00:44:17 +0200 (Wed, 24 Jun 2009)
New Revision: 2373

Modified:
   trunk/src/flash/at91sam7.c
   trunk/src/flash/cfi.c
   trunk/src/flash/ecos.c
   trunk/src/flash/flash.c
   trunk/src/flash/mflash.c
   trunk/src/flash/mflash.h
   trunk/src/flash/nand.c
   trunk/src/flash/ocl.c
   trunk/src/flash/ocl/at91sam7x/main.c
   trunk/src/flash/ocl/at91sam7x/samflash.c
   trunk/src/flash/pic32mx.c
   trunk/src/flash/pic32mx.h
   trunk/src/flash/stellaris.c
   trunk/src/flash/str7x.c
   trunk/src/flash/str9x.c
   trunk/src/flash/tms470.c
   trunk/src/helper/binarybuffer.h
   trunk/src/helper/command.c
   trunk/src/helper/configuration.c
   trunk/src/helper/ioutil.c
   trunk/src/helper/jim-eventloop.c
   trunk/src/helper/jim.c
   trunk/src/helper/jim.h
   trunk/src/helper/log.c
   trunk/src/helper/log.h
   trunk/src/helper/replacements.c
   trunk/src/jtag/arm-jtag-ew.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/presto.c
   trunk/src/jtag/tcl.c
   trunk/src/jtag/vsllink.c
   trunk/src/jtag/zy1000/jtag_minidriver.h
   trunk/src/jtag/zy1000/zy1000.c
   trunk/src/server/gdb_server.c
   trunk/src/server/telnet_server.c
   trunk/src/target/arm11.c
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm9tdmi.c
   trunk/src/target/arm_adi_v5.c
   trunk/src/target/armv4_5.c
   trunk/src/target/etb.c
   trunk/src/target/fa526.c
   trunk/src/target/image.c
   trunk/src/target/mips32_dmaacc.c
   trunk/src/target/mips32_pracc.c
   trunk/src/target/oocd_trace.c
   trunk/src/target/target.c
   trunk/src/target/xscale.c
   trunk/src/xsvf/xsvf.c
Log:
- Fixes '+' whitespace
- Replace ')\(+\)(' with ') \1 ('.
- Replace ')\(+\)\(\w\)' with ') \1 \2'.
- Replace '\(\w\)\(+\)(' with '\1 \2 ('.
- Replace '\(\w\)\(+\)\(\w\)' with '\1 \2 \3'.


Modified: trunk/src/flash/at91sam7.c
===================================================================
--- trunk/src/flash/at91sam7.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/at91sam7.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -213,19 +213,19 @@
 			if (at91sam7_info-&gt;cidr_arch == 0x60)
 			{
 				/* AT91SAM7A3 uses master clocks in 100 ns */
-				fmcn = (at91sam7_info-&gt;mck_freq/10000000ul)+1;
+				fmcn = (at91sam7_info-&gt;mck_freq/10000000ul) + 1;
 			}
 			else
 			{
 				/* master clocks in 1uS for ARCH 0x7 types */
-				fmcn = (at91sam7_info-&gt;mck_freq/1000000ul)+1;
+				fmcn = (at91sam7_info-&gt;mck_freq/1000000ul) + 1;
 			}
 		}
 		else if (mode == FMR_TIMING_FLASH)
 		{
 			/* main clocks in 1.5uS */
 			fmcn = (at91sam7_info-&gt;mck_freq/1000000ul)+
-				(at91sam7_info-&gt;mck_freq/2000000ul)+1;
+				(at91sam7_info-&gt;mck_freq/2000000ul) + 1;
 		}
 
 		/* hard overclocking */
@@ -282,7 +282,7 @@
 
 	fcr = (0x5A &lt;&lt; 24) | ((pagen&amp;0x3FF) &lt;&lt; 8) | cmd; 
 	target_write_u32(target, MC_FCR[bank-&gt;bank_number], fcr);
-	LOG_DEBUG(&quot;Flash command: 0x%&quot; PRIx32 &quot;, flash bank: %i, page number: %u&quot;, fcr, bank-&gt;bank_number+1, pagen);
+	LOG_DEBUG(&quot;Flash command: 0x%&quot; PRIx32 &quot;, flash bank: %i, page number: %u&quot;, fcr, bank-&gt;bank_number + 1, pagen);
 
 	if ((at91sam7_info-&gt;cidr_arch == 0x60) &amp;&amp; ((cmd == SLB)|(cmd == CLB)))
 	{
@@ -641,7 +641,7 @@
 	fast_check = 1;
 	for (nSector = 0; nSector&lt;bank-&gt;num_sectors; nSector++)
 	{
-		retval = target_blank_check_memory(target, bank-&gt;base+bank-&gt;sectors[nSector].offset,
+		retval = target_blank_check_memory(target, bank-&gt;base + bank-&gt;sectors[nSector].offset,
 			bank-&gt;sectors[nSector].size, &amp;blank);
 		if (retval != ERROR_OK)
 		{
@@ -665,7 +665,7 @@
 	for (nSector = 0; nSector&lt;bank-&gt;num_sectors; nSector++)
 	{
 		bank-&gt;sectors[nSector].is_erased = 1;
-		retval = target_read_memory(target, bank-&gt;base+bank-&gt;sectors[nSector].offset, 4,
+		retval = target_read_memory(target, bank-&gt;base + bank-&gt;sectors[nSector].offset, 4,
 			bank-&gt;sectors[nSector].size/4, buffer);
 		if (retval != ERROR_OK)
 			return retval;
@@ -707,7 +707,7 @@
 	at91sam7_info-&gt;num_lockbits_on = 0;
 	for (lock_pos = 0; lock_pos&lt;bank-&gt;num_sectors; lock_pos++)
 	{
-		if ( ((status &gt;&gt; (16+lock_pos))&amp;(0x0001)) == 1)
+		if ( ((status &gt;&gt; (16 + lock_pos))&amp;(0x0001)) == 1)
 		{
 			at91sam7_info-&gt;num_lockbits_on++;
 			bank-&gt;sectors[lock_pos].is_protected = 1;
@@ -725,7 +725,7 @@
 	at91sam7_info-&gt;num_nvmbits_on = 0;
 	for (gpnvm_pos = 0; gpnvm_pos&lt;at91sam7_info-&gt;num_nvmbits; gpnvm_pos++)
 	{
-		if ( ((status &gt;&gt; (8+gpnvm_pos))&amp;(0x01)) == 1)
+		if ( ((status &gt;&gt; (8 + gpnvm_pos))&amp;(0x01)) == 1)
 		{
 			at91sam7_info-&gt;num_nvmbits_on++;
 		}
@@ -803,7 +803,7 @@
 	page_size = atoi(args[11]);
 	num_nvmbits = atoi(args[12]);
 
-	target_name = calloc(strlen(args[7])+1, sizeof(char));
+	target_name = calloc(strlen(args[7]) + 1, sizeof(char));
 	strcpy(target_name, args[7]);
 
 	/* calculate bank size  */
@@ -1027,7 +1027,7 @@
 		/* Write one block to the PageWriteBuffer */
 		buffer_pos = (pagen-first_page)*dst_min_alignment;
 		wcount = CEIL(count,4);
-		if ((retval = target_write_memory(target, bank-&gt;base+pagen*dst_min_alignment, 4, wcount, buffer+buffer_pos)) != ERROR_OK)
+		if ((retval = target_write_memory(target, bank-&gt;base + pagen*dst_min_alignment, 4, wcount, buffer + buffer_pos)) != ERROR_OK)
 		{
 			return retval;
 		}

Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/cfi.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -213,7 +213,7 @@
 	{
 		uint8_t i;
 		for (i = 0;i&lt;2;i++)
-			target_read_memory(target, flash_address(bank, sector, offset+i), bank-&gt;bus_width, 1,
+			target_read_memory(target, flash_address(bank, sector, offset + i), bank-&gt;bus_width, 1,
 				&amp;data[i*bank-&gt;bus_width] );
 	}
 	else
@@ -235,7 +235,7 @@
 	{
 		uint8_t i;
 		for (i = 0;i&lt;4;i++)
-			target_read_memory(target, flash_address(bank, sector, offset+i), bank-&gt;bus_width, 1,
+			target_read_memory(target, flash_address(bank, sector, offset + i), bank-&gt;bus_width, 1,
 				&amp;data[i*bank-&gt;bus_width] );
 	}
 	else

Modified: trunk/src/flash/ecos.c
===================================================================
--- trunk/src/flash/ecos.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/ecos.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -274,8 +274,8 @@
 
 	uint32_t flashErr;
 	retval = runCode(info,
-			info-&gt;start_address+OFFSET_ERASE,
-			info-&gt;start_address+OFFSET_ERASE+OFFSET_ERASE_SIZE,
+			info-&gt;start_address + OFFSET_ERASE,
+			info-&gt;start_address + OFFSET_ERASE + OFFSET_ERASE_SIZE,
 			address,
 			len,
 			0,
@@ -307,8 +307,8 @@
 
 	uint32_t buffer;
 	retval = runCode(info,
-			info-&gt;start_address+OFFSET_GET_WORKAREA,
-			info-&gt;start_address+OFFSET_GET_WORKAREA+OFFSET_GET_WORKAREA_SIZE,
+			info-&gt;start_address + OFFSET_GET_WORKAREA,
+			info-&gt;start_address + OFFSET_GET_WORKAREA + OFFSET_GET_WORKAREA_SIZE,
 			0,
 			0,
 			0,
@@ -328,16 +328,16 @@
 		}
 
 		int retval;
-		retval = target_write_buffer(target, buffer, t, ((uint8_t *)data)+i);
+		retval = target_write_buffer(target, buffer, t, ((uint8_t *)data) + i);
 		if (retval != ERROR_OK)
 			return retval;
 
 		uint32_t flashErr;
 		retval = runCode(info,
-				info-&gt;start_address+OFFSET_FLASH,
-				info-&gt;start_address+OFFSET_FLASH+OFFSET_FLASH_SIZE,
+				info-&gt;start_address + OFFSET_FLASH,
+				info-&gt;start_address + OFFSET_FLASH + OFFSET_FLASH_SIZE,
 				buffer,
-				address+i,
+				address + i,
 				t,
 				&amp;flashErr,
 				timeout);
@@ -410,7 +410,7 @@
 {
 	struct flash_bank_s *c = bank;
 	ecosflash_flash_bank_t *info = bank-&gt;driver_priv;
-	return eCosBoard_erase(info, c-&gt;base+first*sectorSize, sectorSize*(last-first+1));
+	return eCosBoard_erase(info, c-&gt;base + first*sectorSize, sectorSize*(last-first + 1));
 }
 
 static int ecosflash_protect(struct flash_bank_s *bank, int set, int first, int last)
@@ -422,7 +422,7 @@
 {
 	ecosflash_flash_bank_t *info = bank-&gt;driver_priv;
 	struct flash_bank_s *c = bank;
-	return eCosBoard_flash(info, buffer, c-&gt;base+offset, count);
+	return eCosBoard_flash(info, buffer, c-&gt;base + offset, count);
 }
 
 static int ecosflash_protect_check(struct flash_bank_s *bank)

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/flash.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -1110,7 +1110,7 @@
 
 			/* see if we need to pad the section */
 			while (padding[section]--)
-				 (buffer+buffer_size)[size_read++] = 0xff;
+				 (buffer + buffer_size)[size_read++] = 0xff;
 
 			buffer_size += size_read;
 			section_offset += size_read;

Modified: trunk/src/flash/mflash.c
===================================================================
--- trunk/src/flash/mflash.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/mflash.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -923,7 +923,7 @@
 
 				CLK_OUT = XIN * ((double)M / N) / NO;
 
-				if ((int)((CLK_OUT+ROUND) / DIV)
+				if ((int)((CLK_OUT + ROUND) / DIV)
 						== (int)(MG_PLL_CLK_OUT / DIV))	{
 					if (mg_is_valid_pll(XIN, N, CLK_OUT, NO) == ERROR_OK)
 					{

Modified: trunk/src/flash/mflash.h
===================================================================
--- trunk/src/flash/mflash.h	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/mflash.h	2009-06-23 22:44:17 UTC (rev 2373)
@@ -294,7 +294,7 @@
 typedef enum _mg_opmode
 {
 	mg_op_mode_xip = 1, /* TRUE XIP */
-	mg_op_mode_snd = 2, /* BOOT+Storage */
+	mg_op_mode_snd = 2, /* BOOT + Storage */
 	mg_op_mode_stg = 0  /* Only Storage */
 } mg_opmode;
 

Modified: trunk/src/flash/nand.c
===================================================================
--- trunk/src/flash/nand.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/nand.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -518,9 +518,9 @@
 	{
 		if (device-&gt;bus_width == 8)
 		{
-			device-&gt;controller-&gt;read_data(device, id_buff+3);
-			device-&gt;controller-&gt;read_data(device, id_buff+4);
-			device-&gt;controller-&gt;read_data(device, id_buff+5);
+			device-&gt;controller-&gt;read_data(device, id_buff + 3);
+			device-&gt;controller-&gt;read_data(device, id_buff + 4);
+			device-&gt;controller-&gt;read_data(device, id_buff + 5);
 		}
 		else
 		{
@@ -1420,7 +1420,7 @@
 				uint8_t ecc[3];
 				memset(oob, 0xff, oob_size);
 				for (i = 0, j = 0; i &lt; page_size; i += 256) {
-					nand_calculate_ecc(p, page+i, ecc);
+					nand_calculate_ecc(p, page + i, ecc);
 					oob[eccpos[j++]] = ecc[0];
 					oob[eccpos[j++]] = ecc[1];
 					oob[eccpos[j++]] = ecc[2];
@@ -1437,7 +1437,7 @@
 				uint8_t *ecc = oob + oob_size - page_size/512 * 10;
 				memset(oob, 0xff, oob_size);
 				for (i = 0; i &lt; page_size; i += 512) {
-					nand_calculate_ecc_kw(p, page+i, ecc);
+					nand_calculate_ecc_kw(p, page + i, ecc);
 					ecc += 10;
 				}
 			}

Modified: trunk/src/flash/ocl/at91sam7x/main.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/main.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/ocl/at91sam7x/main.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -43,7 +43,7 @@
 	len = cmd&amp;0xffff;
 	ofs = adr%flash_page_size;
 	bi_start = ofs/4;
-	bi_end = (ofs+len+3)/4;
+	bi_end = (ofs + len + 3)/4;
 
 	if (bi_end&gt;BUFSIZE) {
 		dcc_wr(OCL_BUFF_OVER);
@@ -65,12 +65,12 @@
 	result = 0;
 	pagenum = adr/flash_page_size;
 	for (bi = 0; bi&lt;bi_end; bi += flash_page_size/4) {
-		result = flash_page_program(buffer+bi, pagenum++);
+		result = flash_page_program(buffer + bi, pagenum++);
 		if (result) break;
 	}
 
 	/* verify written data */
-	if (!result) result = flash_verify(adr, len, ((uint8 *)buffer)+ofs);
+	if (!result) result = flash_verify(adr, len, ((uint8 *)buffer) + ofs);
 
 	dcc_wr(OCL_CMD_DONE|result);
 }

Modified: trunk/src/flash/ocl/at91sam7x/samflash.c
===================================================================
--- trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/ocl/at91sam7x/samflash.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -86,11 +86,11 @@
 	else efc_ofs = 0;
 
 	/* wait until FLASH is ready, just for sure */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
+	while ((inr(MC_FSR + efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* calculate page address, only lower 8 bits are used to address the latch,
 		 but the upper part of address is needed for writing to proper EFC */
-	flash_ptr = (uint32 *)(FLASH_AREA_ADDR+(page_num*flash_page_size));
+	flash_ptr = (uint32 *)(FLASH_AREA_ADDR + (page_num*flash_page_size));
 	data_ptr = data;
 
 	/* copy data to latch */
@@ -100,18 +100,18 @@
 	}
 
 	/* page number and page write command to FCR */
-	outr(MC_FCR+efc_ofs, ((page_num&amp;0x3ff) &lt;&lt; 8) | MC_KEY | MC_FCMD_WP);
+	outr(MC_FCR + efc_ofs, ((page_num&amp;0x3ff) &lt;&lt; 8) | MC_KEY | MC_FCMD_WP);
 
 	/* wait until it's done */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
+	while ((inr(MC_FSR + efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* check for errors */
-	if ((inr(MC_FSR+efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
-	if ((inr(MC_FSR+efc_ofs)&amp;MC_LOCKE)) return FLASH_STAT_LOCKE;
+	if ((inr(MC_FSR + efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
+	if ((inr(MC_FSR + efc_ofs)&amp;MC_LOCKE)) return FLASH_STAT_LOCKE;
 
 #if 0
 	/* verify written data */
-	flash_ptr = (uint32 *)(FLASH_AREA_ADDR+(page_num*flash_page_size));
+	flash_ptr = (uint32 *)(FLASH_AREA_ADDR + (page_num*flash_page_size));
 	data_ptr = data;
 
 	for (i = flash_page_size/4; i; i--) {
@@ -129,21 +129,21 @@
 	int page_num;
 
 	page_num = 0;
-	lockbits = inr(MC_FSR+efc_ofs) &gt;&gt; 16;
+	lockbits = inr(MC_FSR + efc_ofs) &gt;&gt; 16;
 	while (lockbits) {
 		if (lockbits&amp;1) {
 
 			/* wait until FLASH is ready, just for sure */
-			while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
+			while ((inr(MC_FSR + efc_ofs)&amp;MC_FRDY) == 0);
 
-			outr(MC_FCR+efc_ofs, ((page_num&amp;0x3ff) &lt;&lt; 8) | 0x5a000004);
+			outr(MC_FCR + efc_ofs, ((page_num&amp;0x3ff) &lt;&lt; 8) | 0x5a000004);
 
 			/* wait until it's done */
-			while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
+			while ((inr(MC_FSR + efc_ofs)&amp;MC_FRDY) == 0);
 
 			/* check for errors */
-			if ((inr(MC_FSR+efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
-			if ((inr(MC_FSR+efc_ofs)&amp;MC_LOCKE)) return FLASH_STAT_LOCKE;
+			if ((inr(MC_FSR + efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
+			if ((inr(MC_FSR + efc_ofs)&amp;MC_LOCKE)) return FLASH_STAT_LOCKE;
 
 		}
 		if ((page_num += flash_lock_pages)&gt;flash_page_count) break;
@@ -151,20 +151,20 @@
 	}
 
 	/* wait until FLASH is ready, just for sure */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
+	while ((inr(MC_FSR + efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* erase all command to FCR */
-	outr(MC_FCR+efc_ofs, 0x5a000008);
+	outr(MC_FCR + efc_ofs, 0x5a000008);
 
 	/* wait until it's done */
-	while ((inr(MC_FSR+efc_ofs)&amp;MC_FRDY) == 0);
+	while ((inr(MC_FSR + efc_ofs)&amp;MC_FRDY) == 0);
 
 	/* check for errors */
-	if ((inr(MC_FSR+efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
-	if ((inr(MC_FSR+efc_ofs)&amp;MC_LOCKE)) return FLASH_STAT_LOCKE;
+	if ((inr(MC_FSR + efc_ofs)&amp;MC_PROGE)) return FLASH_STAT_PROGE;
+	if ((inr(MC_FSR + efc_ofs)&amp;MC_LOCKE)) return FLASH_STAT_LOCKE;
 
 	/* set no erase before programming */
-	outr(MC_FMR+efc_ofs, inr(MC_FMR+efc_ofs)|0x80);
+	outr(MC_FMR + efc_ofs, inr(MC_FMR + efc_ofs)|0x80);
 
 	return FLASH_STAT_OK;
 }
@@ -188,7 +188,7 @@
 {
 	unsigned char *flash_ptr;
 
-	flash_ptr = (uint8 *)FLASH_AREA_ADDR+adr;
+	flash_ptr = (uint8 *)FLASH_AREA_ADDR + adr;
 	for ( ;len; len--) {
 		if (*(flash_ptr++)!=*(src++)) return FLASH_STAT_VERIFE;
 	}

Modified: trunk/src/flash/ocl.c
===================================================================
--- trunk/src/flash/ocl.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/ocl.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -139,7 +139,7 @@
 	}
 
 	/* receive response */
-	if ((retval = embeddedice_receive(ocl-&gt;jtag_info, dcc_buffer+1, 1) != ERROR_OK))
+	if ((retval = embeddedice_receive(ocl-&gt;jtag_info, dcc_buffer + 1, 1) != ERROR_OK))
 		return retval;
 
 	if (dcc_buffer[1] != OCL_CMD_DONE)
@@ -182,7 +182,7 @@
 	}
 
 	/* allocate buffer for max. ocl buffer + overhead */
-	dcc_buffer = malloc(sizeof(uint32_t)*(ocl-&gt;buflen/4+3));
+	dcc_buffer = malloc(sizeof(uint32_t)*(ocl-&gt;buflen/4 + 3));
 
 	while (count)
 	{

Modified: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/pic32mx.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -923,7 +923,7 @@
 		command_print(cmd_ctx, &quot;flash bank '#%s' is out of bounds&quot;, args[2]);
 		return ERROR_OK;
 	}
-	if (address &lt; bank-&gt;base || address &gt;= (bank-&gt;base+bank-&gt;size))
+	if (address &lt; bank-&gt;base || address &gt;= (bank-&gt;base + bank-&gt;size))
 	{
 		command_print(cmd_ctx, &quot;flash address '%s' is out of bounds&quot;, args[0]);
 		return ERROR_OK;

Modified: trunk/src/flash/pic32mx.h
===================================================================
--- trunk/src/flash/pic32mx.h	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/pic32mx.h	2009-06-23 22:44:17 UTC (rev 2373)
@@ -62,9 +62,9 @@
  * Note: These macros only work for KSEG0/KSEG1 addresses.
  */
 #define KS1Virt2Phys(vaddr)			((vaddr)-0xA0000000)
-#define Phys2KS1Virt(paddr)			((paddr)+0xA0000000)
+#define Phys2KS1Virt(paddr)			((paddr) + 0xA0000000)
 #define KS0Virt2Phys(vaddr)			((vaddr)-0x80000000)
-#define Phys2KS0Virt(paddr)			((paddr)+0x80000000)
+#define Phys2KS0Virt(paddr)			((paddr) + 0x80000000)
 
 /* pic32mx configuration register locations */
 

Modified: trunk/src/flash/stellaris.c
===================================================================
--- trunk/src/flash/stellaris.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/stellaris.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -309,8 +309,8 @@
 			   stellaris_info-&gt;did1, 
 			   stellaris_info-&gt;did1, 
 			   &quot;ARMV7M&quot;, 
-			   (int)((1+((stellaris_info-&gt;dc0 &gt;&gt; 16) &amp; 0xFFFF))/4),
-			   (int)((1+(stellaris_info-&gt;dc0 &amp; 0xFFFF))*2));
+			   (int)((1 + ((stellaris_info-&gt;dc0 &gt;&gt; 16) &amp; 0xFFFF))/4),
+			   (int)((1 + (stellaris_info-&gt;dc0 &amp; 0xFFFF))*2));
 	buf += printed;
 	buf_size -= printed;
 
@@ -396,7 +396,7 @@
 		mainfreq = 200000000; /* PLL out frec */
 
 	if (usesysdiv)
-		stellaris_info-&gt;mck_freq = mainfreq/(1+sysdiv);
+		stellaris_info-&gt;mck_freq = mainfreq/(1 + sysdiv);
 	else
 		stellaris_info-&gt;mck_freq = mainfreq;
 
@@ -499,7 +499,7 @@
 	stellaris_info-&gt;did1 = did1;
 
 	stellaris_info-&gt;num_lockbits = 1 + (stellaris_info-&gt;dc0 &amp; 0xFFFF);
-	stellaris_info-&gt;num_pages = 2 *(1+(stellaris_info-&gt;dc0 &amp; 0xFFFF));
+	stellaris_info-&gt;num_pages = 2 *(1 + (stellaris_info-&gt;dc0 &amp; 0xFFFF));
 	stellaris_info-&gt;pagesize = 1024;
 	bank-&gt;size = 1024 * stellaris_info-&gt;num_pages;
 	stellaris_info-&gt;pages_in_lockregion = 2;

Modified: trunk/src/flash/str7x.c
===================================================================
--- trunk/src/flash/str7x.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/str7x.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -703,7 +703,7 @@
 		flash_cmd = FLASH_SPR;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), flash_cmd);
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_AR), 0x4010DFBC);
-		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_DR0), ~(1 &lt;&lt; (15+ProtectionLevel)));
+		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_DR0), ~(1 &lt;&lt; (15 + ProtectionLevel)));
 		flash_cmd = FLASH_SPR | FLASH_WMS;
 		target_write_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), flash_cmd);
 	}

Modified: trunk/src/flash/str9x.c
===================================================================
--- trunk/src/flash/str9x.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/str9x.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -145,7 +145,7 @@
 		if (str9x_info-&gt;variant)
 			str9x_info-&gt;sector_bits[num_sectors++] = (1 &lt;&lt; i);
 		else
-			str9x_info-&gt;sector_bits[num_sectors++] = (1 &lt;&lt; (i+8));
+			str9x_info-&gt;sector_bits[num_sectors++] = (1 &lt;&lt; (i + 8));
 	}
 
 	return ERROR_OK;

Modified: trunk/src/flash/tms470.c
===================================================================
--- trunk/src/flash/tms470.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/flash/tms470.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -593,7 +593,7 @@
 	LOG_DEBUG(&quot;set fmmaxpp = 50&quot;);
 
 	/*
-	 * MAXCP = 0xf000+2000
+	 * MAXCP = 0xf000 + 2000
 	 */
 	target_write_u32(target, 0xFFE8A084, 0xf000 + 2000);
 	LOG_DEBUG(&quot;set fmmaxcp = 0x%04x&quot;, 0xf000 + 2000);

Modified: trunk/src/helper/binarybuffer.h
===================================================================
--- trunk/src/helper/binarybuffer.h	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/binarybuffer.h	2009-06-23 22:44:17 UTC (rev 2373)
@@ -42,7 +42,7 @@
 	{
 		unsigned int i;
 		
-		for (i = first; i&lt;first+num; i++)
+		for (i = first; i&lt;first + num; i++)
 		{
 			if (((value &gt;&gt; (i-first))&amp;1) == 1)
 				buffer[i/8] |= 1 &lt;&lt; (i%8);
@@ -61,7 +61,7 @@
 		uint32_t result = 0;
 		unsigned int i;
 		
-		for (i = first; i&lt;first+num; i++)
+		for (i = first; i&lt;first + num; i++)
 		{
 			if (((buffer[i/8]&gt;&gt;(i%8))&amp;1) == 1)
 				result |= 1 &lt;&lt; (i-first);

Modified: trunk/src/helper/command.c
===================================================================
--- trunk/src/helper/command.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/command.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -495,14 +495,14 @@
 		if (reslen&gt;0)
 		{
 			int i;
-			char buff[256+1];
+			char buff[256 + 1];
 			for (i = 0; i &lt; reslen; i += 256)
 			{
 				int chunk;
 				chunk = reslen - i;
 				if (chunk &gt; 256)
 					chunk = 256;
-				strncpy(buff, result+i, chunk);
+				strncpy(buff, result + i, chunk);
 				buff[chunk] = 0;
 				LOG_USER_N(&quot;%s&quot;, buff);
 			}
@@ -599,7 +599,7 @@
 	}
 	/* GRR we must chunk - not null terminated */
 	while (nbytes) {
-		char chunk[128+1];
+		char chunk[128 + 1];
 		int x;
 
 		x = nbytes;

Modified: trunk/src/helper/configuration.c
===================================================================
--- trunk/src/helper/configuration.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/configuration.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -37,7 +37,7 @@
 void add_script_search_dir (const char *dir)
 {
 	num_script_dirs++;
-	script_search_dirs = (char **)realloc(script_search_dirs, (num_script_dirs+1) * sizeof (char *));
+	script_search_dirs = (char **)realloc(script_search_dirs, (num_script_dirs + 1) * sizeof (char *));
 
 	script_search_dirs[num_script_dirs-1] = strdup(dir);
 	script_search_dirs[num_script_dirs] = NULL;
@@ -46,7 +46,7 @@
 void add_config_command (const char *cfg)
 {
 	num_config_files++;
-	config_file_names = (char **)realloc(config_file_names, (num_config_files+1) * sizeof (char *));
+	config_file_names = (char **)realloc(config_file_names, (num_config_files + 1) * sizeof (char *));
 
 	config_file_names[num_config_files-1] = strdup(cfg);
 	config_file_names[num_config_files] = NULL;

Modified: trunk/src/helper/ioutil.c
===================================================================
--- trunk/src/helper/ioutil.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/ioutil.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -274,7 +274,7 @@
 			chunk = maxChunk;
 		}
 
-		if ((retval == ERROR_OK) &amp;&amp; (fwrite(((char *)data)+pos, 1, chunk, f) != chunk))
+		if ((retval == ERROR_OK) &amp;&amp; (fwrite(((char *)data) + pos, 1, chunk, f) != chunk))
 			retval = ERROR_INVALID_ARGUMENTS;
 
 		if (retval != ERROR_OK)

Modified: trunk/src/helper/jim-eventloop.c
===================================================================
--- trunk/src/helper/jim-eventloop.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/jim-eventloop.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -310,7 +310,7 @@
 		// fprintf(stderr,&quot;No Event\n&quot;);
         }
 
-        retval = select(maxfd+1, &amp;rfds, &amp;wfds, &amp;efds, tvp);
+        retval = select(maxfd + 1, &amp;rfds, &amp;wfds, &amp;efds, tvp);
         if (retval &lt; 0) {
 	   switch (errno) {
 	       case EINTR:   fprintf(stderr,&quot;select EINTR\n&quot;); break;

Modified: trunk/src/helper/jim.c
===================================================================
--- trunk/src/helper/jim.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/jim.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -255,7 +255,7 @@
             if (patternLen == 1)
                 return 1; /* match */
             while (stringLen) {
-                if (JimStringMatch(pattern+1, patternLen-1,
+                if (JimStringMatch(pattern + 1, patternLen-1,
                             string, stringLen, nocase))
                     return 1; /* match */
                 string++;
@@ -457,7 +457,7 @@
  * in length, this allows to avoid to check every object with a string
  * repr &lt; 32, and usually there are many of this objects. */
 
-#define JIM_REFERENCE_SPACE (35+JIM_REFERENCE_TAGLEN)
+#define JIM_REFERENCE_SPACE (35 + JIM_REFERENCE_TAGLEN)
 
 static int JimFormatReference(char *buf, Jim_Reference *refPtr, jim_wide id)
 {
@@ -485,7 +485,7 @@
         s[0] = '.';
         s[1] = '0';
         s[2] = '\0';
-        return len+2;
+        return len + 2;
     }
     return len;
 }
@@ -594,17 +594,17 @@
 char *Jim_StrDup(const char *s)
 {
     int l = strlen(s);
-    char *copy = Jim_Alloc(l+1);
+    char *copy = Jim_Alloc(l + 1);
 
-    memcpy(copy, s, l+1);
+    memcpy(copy, s, l + 1);
     return copy;
 }
 
 char *Jim_StrDupLen(const char *s, int l)
 {
-    char *copy = Jim_Alloc(l+1);
+    char *copy = Jim_Alloc(l + 1);
     
-    memcpy(copy, s, l+1);
+    memcpy(copy, s, l + 1);
     copy[l] = 0;    /* Just to be sure, original could be substring */
     return copy;
 }
@@ -956,7 +956,7 @@
 static const void *JimStringCopyHTKeyDup(void *privdata, const void *key)
 {
     int len = strlen(key);
-    char *copy = Jim_Alloc(len+1);
+    char *copy = Jim_Alloc(len + 1);
     JIM_NOTUSED(privdata);
 
     memcpy(copy, key, len);
@@ -967,7 +967,7 @@
 static void *JimStringKeyValCopyHTValDup(void *privdata, const void *val)
 {
     int len = strlen(val);
-    char *copy = Jim_Alloc(len+1);
+    char *copy = Jim_Alloc(len + 1);
     JIM_NOTUSED(privdata);
 
     memcpy(copy, val, len);
@@ -1072,7 +1072,7 @@
 }
 
 void Jim_StackPush(Jim_Stack *stack, void *element) {
-    int neededLen = stack-&gt;len+1;
+    int neededLen = stack-&gt;len + 1;
     if (neededLen &gt; stack-&gt;maxlen) {
         stack-&gt;maxlen = neededLen*2;
         stack-&gt;vector = Jim_Realloc(stack-&gt;vector, sizeof(void*)*stack-&gt;maxlen);
@@ -1191,7 +1191,7 @@
         }
         switch (*(pc-&gt;p)) {
         case '\\':
-            if (*(pc-&gt;p+1) == '\n')
+            if (*(pc-&gt;p + 1) == '\n')
                 return JimParseSep(pc);
             else {
                 pc-&gt;comment = 0;
@@ -1251,7 +1251,7 @@
     pc-&gt;tstart = pc-&gt;p;
     pc-&gt;tline = pc-&gt;linenr;
     while (*pc-&gt;p == ' ' || *pc-&gt;p == '\t' || *pc-&gt;p == '\r' ||
-           (*pc-&gt;p == '\\' &amp;&amp; *(pc-&gt;p+1) == '\n')) {
+           (*pc-&gt;p == '\\' &amp;&amp; *(pc-&gt;p + 1) == '\n')) {
         if (*pc-&gt;p == '\\') {
             pc-&gt;p++; pc-&gt;len--;
             pc-&gt;linenr++;
@@ -1430,7 +1430,7 @@
         switch (*pc-&gt;p) {
         case '\\':
             if (pc-&gt;state == JIM_PS_DEF &amp;&amp;
-                *(pc-&gt;p+1) == '\n') {
+                *(pc-&gt;p + 1) == '\n') {
                 pc-&gt;tend = pc-&gt;p-1;
                 pc-&gt;tt = JIM_TT_ESC;
                 return JIM_OK;
@@ -1520,7 +1520,7 @@
     for (i = 0; i &lt; slen; i++) {
         switch (s[i]) {
         case '\\':
-            switch (s[i+1]) {
+            switch (s[i + 1]) {
             case 'a': *p++ = 0x7; i++; break;
             case 'b': *p++ = 0x8; i++; break;
             case 'f': *p++ = 0xc; i++; break;
@@ -1531,48 +1531,48 @@
             case '\0': *p++ = '\\'; i++; break;
             case '\n': *p++ = ' '; i++; break;
             default:
-                  if (s[i+1] == 'x') {
+                  if (s[i + 1] == 'x') {
                     int val = 0;
-                    int c = xdigitval(s[i+2]);
+                    int c = xdigitval(s[i + 2]);
                     if (c == -1) {
                         *p++ = 'x';
                         i++;
                         break;
                     }
                     val = c;
-                    c = xdigitval(s[i+3]);
+                    c = xdigitval(s[i + 3]);
                     if (c == -1) {
                         *p++ = val;
                         i += 2;
                         break;
                     }
-                    val = (val*16)+c;
+                    val = (val*16) + c;
                     *p++ = val;
                     i += 3;
                     break;
-                  } else if (s[i+1] &gt;= '0' &amp;&amp; s[i+1] &lt;= '7')
+                  } else if (s[i + 1] &gt;= '0' &amp;&amp; s[i + 1] &lt;= '7')
                   {
                     int val = 0;
-                    int c = odigitval(s[i+1]);
+                    int c = odigitval(s[i + 1]);
                     val = c;
-                    c = odigitval(s[i+2]);
+                    c = odigitval(s[i + 2]);
                     if (c == -1) {
                         *p++ = val;
                         i ++;
                         break;
                     }
-                    val = (val*8)+c;
-                    c = odigitval(s[i+3]);
+                    val = (val*8) + c;
+                    c = odigitval(s[i + 3]);
                     if (c == -1) {
                         *p++ = val;
                         i += 2;
                         break;
                     }
-                    val = (val*8)+c;
+                    val = (val*8) + c;
                     *p++ = val;
                     i += 3;
                   } else {
-                    *p++ = s[i+1];
+                    *p++ = s[i + 1];
                     i++;
                   }
                   break;
@@ -1625,8 +1625,8 @@
         token[0] = '\0';
         return token;
     }
-    len = (end-start)+1;
-    token = Jim_Alloc(len+1);
+    len = (end-start) + 1;
+    token = Jim_Alloc(len + 1);
     if (JimParserTtype(pc) != JIM_TT_ESC) {
         /* No escape conversion needed? Just copy it. */
         memcpy(token, start, len);
@@ -1879,7 +1879,7 @@
         objPtr-&gt;bytes = JimEmptyStringRep;
         objPtr-&gt;length = 0;
     } else {
-        objPtr-&gt;bytes = Jim_Alloc(length+1);
+        objPtr-&gt;bytes = Jim_Alloc(length + 1);
         objPtr-&gt;length = length;
         memcpy(objPtr-&gt;bytes, bytes, length);
         objPtr-&gt;bytes[length] = '\0';
@@ -1987,7 +1987,7 @@
         objPtr-&gt;bytes = JimEmptyStringRep;
         objPtr-&gt;length = 0;
     } else {
-        objPtr-&gt;bytes = Jim_Alloc(len+1);
+        objPtr-&gt;bytes = Jim_Alloc(len + 1);
         objPtr-&gt;length = len;
         memcpy(objPtr-&gt;bytes, s, len);
         objPtr-&gt;bytes[len] = '\0';
@@ -2023,14 +2023,14 @@
     if (objPtr-&gt;internalRep.strValue.maxLength &lt; needlen ||
         objPtr-&gt;internalRep.strValue.maxLength == 0) {
         if (objPtr-&gt;bytes == JimEmptyStringRep) {
-            objPtr-&gt;bytes = Jim_Alloc((needlen*2)+1);
+            objPtr-&gt;bytes = Jim_Alloc((needlen*2) + 1);
         } else {
-            objPtr-&gt;bytes = Jim_Realloc(objPtr-&gt;bytes, (needlen*2)+1);
+            objPtr-&gt;bytes = Jim_Realloc(objPtr-&gt;bytes, (needlen*2) + 1);
         }
         objPtr-&gt;internalRep.strValue.maxLength = needlen*2;
     }
     memcpy(objPtr-&gt;bytes + objPtr-&gt;length, str, len);
-    objPtr-&gt;bytes[objPtr-&gt;length+len] = '\0';
+    objPtr-&gt;bytes[objPtr-&gt;length + len] = '\0';
     objPtr-&gt;length += len;
 }
 
@@ -2163,7 +2163,7 @@
     if (first &gt; last) {
         rangeLen = 0;
     } else {
-        rangeLen = last-first+1;
+        rangeLen = last-first + 1;
         if (rangeLen) {
             if (first &lt; 0) {
                 rangeLen += first;
@@ -2196,7 +2196,7 @@
     first = JimRelToAbsIndex(len, first);
     last = JimRelToAbsIndex(len, last);
     JimRelToAbsRange(len, first, last, &amp;first, &amp;last, &amp;rangeLen);
-    return Jim_NewStringObj(interp, str+first, rangeLen);
+    return Jim_NewStringObj(interp, str + first, rangeLen);
 }
 
 static Jim_Obj *JimStringToLower(Jim_Interp *interp, Jim_Obj *strObjPtr)
@@ -2207,9 +2207,9 @@
         SetStringFromAny(interp, strObjPtr);
     }
 
-    buf = Jim_Alloc(strObjPtr-&gt;length+1);
+    buf = Jim_Alloc(strObjPtr-&gt;length + 1);
 
-    memcpy(buf, strObjPtr-&gt;bytes, strObjPtr-&gt;length+1);
+    memcpy(buf, strObjPtr-&gt;bytes, strObjPtr-&gt;length + 1);
     for (i = 0; i &lt; strObjPtr-&gt;length; i++)
         buf[i] = tolower(buf[i]);
     return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr-&gt;length);
@@ -2223,9 +2223,9 @@
         SetStringFromAny(interp, strObjPtr);
     }
 
-    buf = Jim_Alloc(strObjPtr-&gt;length+1);
+    buf = Jim_Alloc(strObjPtr-&gt;length + 1);
 
-    memcpy(buf, strObjPtr-&gt;bytes, strObjPtr-&gt;length+1);
+    memcpy(buf, strObjPtr-&gt;bytes, strObjPtr-&gt;length + 1);
     for (i = 0; i &lt; strObjPtr-&gt;length; i++)
         buf[i] = toupper(buf[i]);
     return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr-&gt;length);
@@ -2606,11 +2606,11 @@
         memcpy(tablePtrSorted, tablePtr, sizeof(char*)*count);
         qsort(tablePtrSorted, count, sizeof(char*), qsortCompareStringPointers);
         for (i = 0; i &lt; count; i++) {
-            if (i+1 == count &amp;&amp; count &gt; 1)
+            if (i + 1 == count &amp;&amp; count &gt; 1)
                 Jim_AppendString(interp, Jim_GetResult(interp), &quot;or &quot;, -1);
             Jim_AppendString(interp, Jim_GetResult(interp),
                     tablePtrSorted[i], -1);
-            if (i+1 != count)
+            if (i + 1 != count)
                 Jim_AppendString(interp, Jim_GetResult(interp), &quot;, &quot;, -1);
         }
         Jim_Free(tablePtrSorted);
@@ -2888,7 +2888,7 @@
     script-&gt;token = Jim_Realloc(script-&gt;token,
             sizeof(ScriptToken)*script-&gt;len);
     /* Initialize the new token */
-    token = script-&gt;token+(script-&gt;len-1);
+    token = script-&gt;token + (script-&gt;len-1);
     token-&gt;type = type;
     /* Every object is intially as a string, but the
      * internal type may be specialized during execution of the
@@ -3060,8 +3060,8 @@
                     token[end-1].type == JIM_TT_EOL)
             {
                 if (token[end].type == JIM_TT_STR &amp;&amp;
-                    token[end+1].type != JIM_TT_SEP &amp;&amp;
-                    token[end+1].type != JIM_TT_EOL &amp;&amp;
+                    token[end + 1].type != JIM_TT_SEP &amp;&amp;
+                    token[end + 1].type != JIM_TT_EOL &amp;&amp;
                     (!strcmp(token[end].objPtr-&gt;bytes, &quot;expand&quot;) ||
                      !strcmp(token[end].objPtr-&gt;bytes, &quot;*&quot;)))
                     expand++;
@@ -3070,7 +3070,7 @@
                 args++;
             end++;
         }
-        interpolation = !((end-start+1) == args*2);
+        interpolation = !((end-start + 1) == args*2);
         /* Add the 'number of arguments' info into cmdstruct.
          * Negative value if there is list expansion involved. */
         if (expand)
@@ -3796,15 +3796,15 @@
     str = Jim_GetString(objPtr, &amp;len);
     p = strchr(str, '(');
     p++;
-    keyLen = len-((p-str)+1);
+    keyLen = len-((p-str) + 1);
     nameLen = (p-str)-1;
     /* Create the objects with the variable name and key. */
-    t = Jim_Alloc(nameLen+1);
+    t = Jim_Alloc(nameLen + 1);
     memcpy(t, str, nameLen);
     t[nameLen] = '\0';
     varObjPtr = Jim_NewStringObjNoAlloc(interp, t, nameLen);
 
-    t = Jim_Alloc(keyLen+1);
+    t = Jim_Alloc(keyLen + 1);
     memcpy(t, p, keyLen);
     t[keyLen] = '\0';
     keyObjPtr = Jim_NewStringObjNoAlloc(interp, t, keyLen);
@@ -4078,13 +4078,13 @@
 void UpdateStringOfReference(struct Jim_Obj *objPtr)
 {
     int len;
-    char buf[JIM_REFERENCE_SPACE+1];
+    char buf[JIM_REFERENCE_SPACE + 1];
     Jim_Reference *refPtr;
 
     refPtr = objPtr-&gt;internalRep.refValue.refPtr;
     len = JimFormatReference(buf, refPtr, objPtr-&gt;internalRep.refValue.id);
-    objPtr-&gt;bytes = Jim_Alloc(len+1);
-    memcpy(objPtr-&gt;bytes, buf, len+1);
+    objPtr-&gt;bytes = Jim_Alloc(len + 1);
+    memcpy(objPtr-&gt;bytes, buf, len + 1);
     objPtr-&gt;length = len;
 }
 
@@ -4112,19 +4112,19 @@
     if (len &lt; JIM_REFERENCE_SPACE) goto badformat;
     /* Trim spaces */
     start = str;
-    end = str+len-1;
+    end = str + len-1;
     while (*start == ' ') start++;
     while (*end == ' ' &amp;&amp; end &gt; start) end--;
-    if (end-start+1 != JIM_REFERENCE_SPACE) goto badformat;
+    if (end-start + 1 != JIM_REFERENCE_SPACE) goto badformat;
     /* &lt;reference.&lt;1234567&gt;.%020&gt; */
     if (memcmp(start, &quot;&lt;reference.&lt;&quot;, 12) != 0) goto badformat;
-    if (start[12+JIM_REFERENCE_TAGLEN] != '&gt;' || end[0] != '&gt;') goto badformat;
+    if (start[12 + JIM_REFERENCE_TAGLEN] != '&gt;' || end[0] != '&gt;') goto badformat;
     /* The tag can't contain chars other than a-zA-Z0-9 + '_'. */
     for (i = 0; i &lt; JIM_REFERENCE_TAGLEN; i++) {
-        if (!isrefchar(start[12+i])) goto badformat;
+        if (!isrefchar(start[12 + i])) goto badformat;
     }
     /* Extract info from the refernece. */
-    memcpy(refId, start+14+JIM_REFERENCE_TAGLEN, 20);
+    memcpy(refId, start + 14 + JIM_REFERENCE_TAGLEN, 20);
     refId[20] = '\0';
     /* Try to convert the ID into a jim_wide */
     if (Jim_StringToWide(refId, &amp;wideValue, 10) != JIM_OK) goto badformat;
@@ -4305,7 +4305,7 @@
                     if (!isdigit((int)p[i]))
                         break;
                 /* Get the ID */
-                memcpy(buf, p+21, 20);
+                memcpy(buf, p + 21, 20);
                 buf[20] = '\0';
                 Jim_StringToWide(buf, &amp;id, 10);
 
@@ -4340,7 +4340,7 @@
              * finalizer first if registered. */
             refPtr = he-&gt;val;
             if (refPtr-&gt;finalizerCmdNamePtr) {
-                char *refstr = Jim_Alloc(JIM_REFERENCE_SPACE+1);
+                char *refstr = Jim_Alloc(JIM_REFERENCE_SPACE + 1);
                 Jim_Obj *objv[3], *oldResult;
 
                 JimFormatReference(refstr, refPtr, *refId);
@@ -4575,7 +4575,7 @@
                 return JIM_OK;
             }
 
-            level = strtol(str+1, &amp;endptr, 0);
+            level = strtol(str + 1, &amp;endptr, 0);
             if (str[1] == '\0' || endptr[0] != '\0' || level &lt; 0)
                 goto badlevel;
             /* An 'absolute' level is converted into the
@@ -4792,11 +4792,11 @@
 void UpdateStringOfInt(struct Jim_Obj *objPtr)
 {
     int len;
-    char buf[JIM_INTEGER_SPACE+1];
+    char buf[JIM_INTEGER_SPACE + 1];
 
     len = Jim_WideToString(buf, objPtr-&gt;internalRep.wideValue);
-    objPtr-&gt;bytes = Jim_Alloc(len+1);
-    memcpy(objPtr-&gt;bytes, buf, len+1);
+    objPtr-&gt;bytes = Jim_Alloc(len + 1);
+    memcpy(objPtr-&gt;bytes, buf, len + 1);
     objPtr-&gt;length = len;
 }
 
@@ -4904,11 +4904,11 @@
 void UpdateStringOfDouble(struct Jim_Obj *objPtr)
 {
     int len;
-    char buf[JIM_DOUBLE_SPACE+1];
+    char buf[JIM_DOUBLE_SPACE + 1];
 
     len = Jim_DoubleToString(buf, objPtr-&gt;internalRep.doubleValue);
-    objPtr-&gt;bytes = Jim_Alloc(len+1);
-    memcpy(objPtr-&gt;bytes, buf, len+1);
+    objPtr-&gt;bytes = Jim_Alloc(len + 1);
+    memcpy(objPtr-&gt;bytes, buf, len + 1);
     objPtr-&gt;length = len;
 }
 
@@ -5063,10 +5063,10 @@
               if (level &lt; 0) return JIM_ELESTR_QUOTE;
               break;
         case '\\':
-              if (s[i+1] == '\n')
+              if (s[i + 1] == '\n')
                   return JIM_ELESTR_QUOTE;
               else
-                  if (s[i+1] != '\0') i++;
+                  if (s[i + 1] != '\0') i++;
               break;
         }
     }
@@ -5099,7 +5099,7 @@
  * using backslash to quote special chars. */
 char *BackslashQuoteString(const char *s, int len, int *qlenPtr)
 {
-    char *q = Jim_Alloc(len*2+1), *p;
+    char *q = Jim_Alloc(len*2 + 1), *p;
 
     p = q;
     while (*s) {
@@ -5140,7 +5140,7 @@
     Jim_Obj **ele = objPtr-&gt;internalRep.listValue.ele;
 
     /* (Over) Estimate the space needed. */
-    quotingType = Jim_Alloc(sizeof(int)*objPtr-&gt;internalRep.listValue.len+1);
+    quotingType = Jim_Alloc(sizeof(int)*objPtr-&gt;internalRep.listValue.len + 1);
     bufLen = 0;
     for (i = 0; i &lt; objPtr-&gt;internalRep.listValue.len; i++) {
         int len;
@@ -5149,7 +5149,7 @@
         quotingType[i] = ListElementQuotingType(strRep, len);
         switch (quotingType[i]) {
         case JIM_ELESTR_SIMPLE: bufLen += len; break;
-        case JIM_ELESTR_BRACE: bufLen += len+2; break;
+        case JIM_ELESTR_BRACE: bufLen += len + 2; break;
         case JIM_ELESTR_QUOTE: bufLen += len*2; break;
         }
         bufLen++; /* elements separator. */
@@ -5157,7 +5157,7 @@
     bufLen++;
 
     /* Generate the string rep. */
-    p = objPtr-&gt;bytes = Jim_Alloc(bufLen+1);
+    p = objPtr-&gt;bytes = Jim_Alloc(bufLen + 1);
     realLength = 0;
     for (i = 0; i &lt; objPtr-&gt;internalRep.listValue.len; i++) {
         int len, qlen;
@@ -5175,7 +5175,7 @@
             memcpy(p, strRep, len);
             p += len;
             *p++ = '}';
-            realLength += len+2;
+            realLength += len + 2;
             break;
         case JIM_ELESTR_QUOTE:
             q = BackslashQuoteString(strRep, len, &amp;qlen);
@@ -5186,7 +5186,7 @@
             break;
         }
         /* Add a separating space */
-        if (i+1 != objPtr-&gt;internalRep.listValue.len) {
+        if (i + 1 != objPtr-&gt;internalRep.listValue.len) {
             *p++ = ' ';
             realLength ++;
         }
@@ -5365,7 +5365,7 @@
         listPtr-&gt;internalRep.listValue.maxLen = maxLen;
     }
     point = listPtr-&gt;internalRep.listValue.ele + index;
-    memmove(point+elemc, point, (currentLen-index) * sizeof(Jim_Obj*));
+    memmove(point + elemc, point, (currentLen-index) * sizeof(Jim_Obj*));
     for (i = 0; i &lt; elemc; ++i) {
         point[i] = elemVec[i];
         Jim_IncrRefCount(point[i]);
@@ -5391,7 +5391,7 @@
     }
     for (i = 0; i &lt; appendLen; i++) {
         Jim_Obj *objPtr = appendListPtr-&gt;internalRep.listValue.ele[i];
-        listPtr-&gt;internalRep.listValue.ele[oldLen+i] = objPtr;
+        listPtr-&gt;internalRep.listValue.ele[oldLen + i] = objPtr;
         Jim_IncrRefCount(objPtr);
     }
     listPtr-&gt;internalRep.listValue.len += appendLen;
@@ -5453,7 +5453,7 @@
         return JIM_ERR;
     }
     if (index &lt; 0)
-        index = listPtr-&gt;internalRep.listValue.len+index;
+        index = listPtr-&gt;internalRep.listValue.len + index;
     *objPtrPtr = listPtr-&gt;internalRep.listValue.ele[index];
     return JIM_OK;
 }
@@ -5472,7 +5472,7 @@
         return JIM_ERR;
     }
     if (index &lt; 0)
-        index = listPtr-&gt;internalRep.listValue.len+index;
+        index = listPtr-&gt;internalRep.listValue.len + index;
     Jim_DecrRefCount(interp, listPtr-&gt;internalRep.listValue.ele[index]);
     listPtr-&gt;internalRep.listValue.ele[index] = newObjPtr;
     Jim_IncrRefCount(newObjPtr);
@@ -5552,7 +5552,7 @@
         }
         if (objc) len += objc-1;
         /* Create the string rep, and a stinrg object holding it. */
-        p = bytes = Jim_Alloc(len+1);
+        p = bytes = Jim_Alloc(len + 1);
         for (i = 0; i &lt; objc; i++) {
             const char *s = Jim_GetString(objv[i], &amp;objLen);
             while (objLen &amp;&amp; (*s == ' ' || *s == '\t' || *s == '\n'))
@@ -5565,9 +5565,9 @@
             }
             memcpy(p, s, objLen);
             p += objLen;
-            if (objLen &amp;&amp; i+1 != objc) {
+            if (objLen &amp;&amp; i + 1 != objc) {
                 *p++ = ' ';
-            } else if (i+1 != objc) {
+            } else if (i + 1 != objc) {
                 /* Drop the space calcuated for this
                  * element that is instead null. */
                 len--;
@@ -5594,7 +5594,7 @@
     last = JimRelToAbsIndex(len, last);
     JimRelToAbsRange(len, first, last, &amp;first, &amp;last, &amp;rangeLen);
     return Jim_NewListObj(interp,
-            listObjPtr-&gt;internalRep.listValue.ele+first, rangeLen);
+            listObjPtr-&gt;internalRep.listValue.ele + first, rangeLen);
 }
 
 /* -----------------------------------------------------------------------------
@@ -5724,7 +5724,7 @@
         quotingType[i] = ListElementQuotingType(strRep, len);
         switch (quotingType[i]) {
         case JIM_ELESTR_SIMPLE: bufLen += len; break;
-        case JIM_ELESTR_BRACE: bufLen += len+2; break;
+        case JIM_ELESTR_BRACE: bufLen += len + 2; break;
         case JIM_ELESTR_QUOTE: bufLen += len*2; break;
         }
         bufLen++; /* elements separator. */
@@ -5732,7 +5732,7 @@
     bufLen++;
 
     /* Generate the string rep. */
-    p = objPtr-&gt;bytes = Jim_Alloc(bufLen+1);
+    p = objPtr-&gt;bytes = Jim_Alloc(bufLen + 1);
     realLength = 0;
     for (i = 0; i &lt; objc; i++) {
         int len, qlen;
@@ -5750,7 +5750,7 @@
             memcpy(p, strRep, len);
             p += len;
             *p++ = '}';
-            realLength += len+2;
+            realLength += len + 2;
             break;
         case JIM_ELESTR_QUOTE:
             q = BackslashQuoteString(strRep, len, &amp;qlen);
@@ -5761,7 +5761,7 @@
             break;
         }
         /* Add a separating space */
-        if (i+1 != objc) {
+        if (i + 1 != objc) {
             *p++ = ' ';
             realLength ++;
         }
@@ -5886,7 +5886,7 @@
     objPtr-&gt;internalRep.ptr = Jim_Alloc(sizeof(Jim_HashTable));
     Jim_InitHashTable(objPtr-&gt;internalRep.ptr, &amp;JimDictHashTableType, interp);
     for (i = 0; i &lt; len; i += 2)
-        DictAddElement(interp, objPtr, elements[i], elements[i+1]);
+        DictAddElement(interp, objPtr, elements[i], elements[i + 1]);
     return objPtr;
 }
 
@@ -6025,17 +6025,17 @@
 void UpdateStringOfIndex(struct Jim_Obj *objPtr)
 {
     int len;
-    char buf[JIM_INTEGER_SPACE+1];
+    char buf[JIM_INTEGER_SPACE + 1];
 
     if (objPtr-&gt;internalRep.indexValue &gt;= 0)
         len = sprintf(buf, &quot;%d&quot;, objPtr-&gt;internalRep.indexValue);
     else if (objPtr-&gt;internalRep.indexValue == -1)
         len = sprintf(buf, &quot;end&quot;);
     else {
-        len = sprintf(buf, &quot;end%d&quot;, objPtr-&gt;internalRep.indexValue+1);
+        len = sprintf(buf, &quot;end%d&quot;, objPtr-&gt;internalRep.indexValue + 1);
     }
-    objPtr-&gt;bytes = Jim_Alloc(len+1);
-    memcpy(objPtr-&gt;bytes, buf, len+1);
+    objPtr-&gt;bytes = Jim_Alloc(len + 1);
+    memcpy(objPtr-&gt;bytes, buf, len + 1);
     objPtr-&gt;length = len;
 }
 
@@ -6067,7 +6067,7 @@
         if (index &lt; 0)
             index = INT_MAX;
         else
-            index = -(index+1);
+            index = -(index + 1);
     } else if (!end &amp;&amp; index &lt; 0)
         index = -INT_MAX;
     /* Free the old internal repr and set the new one. */
@@ -6280,7 +6280,7 @@
           *(pc-&gt;p) == '\t' ||
           *(pc-&gt;p) == '\r' ||
           *(pc-&gt;p) == '\n' ||
-            (*(pc-&gt;p) == '\\' &amp;&amp; *(pc-&gt;p+1) == '\n')) {
+            (*(pc-&gt;p) == '\\' &amp;&amp; *(pc-&gt;p + 1) == '\n')) {
         pc-&gt;p++; pc-&gt;len--;
     }
 
@@ -6315,7 +6315,7 @@
         break;
     case '-':
         if ((pc-&gt;tt == JIM_TT_NONE || pc-&gt;tt == JIM_TT_EXPR_OPERATOR) &amp;&amp;
-            isdigit((int)*(pc-&gt;p+1)))
+            isdigit((int)*(pc-&gt;p + 1)))
             return JimParseExprNumber(pc);
         else
             return JimParseExprOperator(pc);
@@ -6366,7 +6366,7 @@
         if (*pc-&gt;p == '.')
             allowdot = 0;
         pc-&gt;p++; pc-&gt;len--;
-        if (!allowdot &amp;&amp; *pc-&gt;p == 'e' &amp;&amp; *(pc-&gt;p+1) == '-') {
+        if (!allowdot &amp;&amp; *pc-&gt;p == 'e' &amp;&amp; *(pc-&gt;p + 1) == '-') {
             pc-&gt;p += 2; pc-&gt;len -= 2;
         }
     }
@@ -6490,8 +6490,8 @@
 static void ExprObjAddInstr(Jim_Interp *interp, ExprByteCode *expr,
         int opcode, char *str, int len)
 {
-    expr-&gt;opcode = Jim_Realloc(expr-&gt;opcode, sizeof(int)*(expr-&gt;len+1));
-    expr-&gt;obj = Jim_Realloc(expr-&gt;obj, sizeof(Jim_Obj*)*(expr-&gt;len+1));
+    expr-&gt;opcode = Jim_Realloc(expr-&gt;opcode, sizeof(int)*(expr-&gt;len + 1));
+    expr-&gt;obj = Jim_Realloc(expr-&gt;obj, sizeof(Jim_Obj*)*(expr-&gt;len + 1));
     expr-&gt;opcode[expr-&gt;len] = opcode;
     expr-&gt;obj[expr-&gt;len] = Jim_NewStringObjNoAlloc(interp, str, len);
     Jim_IncrRefCount(expr-&gt;obj[expr-&gt;len]);
@@ -6644,32 +6644,32 @@
             leftindex--;
         }
         leftindex++;
-        expr-&gt;opcode = Jim_Realloc(expr-&gt;opcode, sizeof(int)*(expr-&gt;len+2));
-        expr-&gt;obj = Jim_Realloc(expr-&gt;obj, sizeof(Jim_Obj*)*(expr-&gt;len+2));
-        memmove(&amp;expr-&gt;opcode[leftindex+2], &amp;expr-&gt;opcode[leftindex],
+        expr-&gt;opcode = Jim_Realloc(expr-&gt;opcode, sizeof(int)*(expr-&gt;len + 2));
+        expr-&gt;obj = Jim_Realloc(expr-&gt;obj, sizeof(Jim_Obj*)*(expr-&gt;len + 2));
+        memmove(&amp;expr-&gt;opcode[leftindex + 2], &amp;expr-&gt;opcode[leftindex],
                 sizeof(int)*(expr-&gt;len-leftindex));
-        memmove(&amp;expr-&gt;obj[leftindex+2], &amp;expr-&gt;obj[leftindex],
+        memmove(&amp;expr-&gt;obj[leftindex + 2], &amp;expr-&gt;obj[leftindex],
                 sizeof(Jim_Obj*)*(expr-&gt;len-leftindex));
         expr-&gt;len += 2;
         index += 2;
         offset = (index-leftindex)-1;
         Jim_DecrRefCount(interp, expr-&gt;obj[index]);
         if (expr-&gt;opcode[index] == JIM_EXPROP_LOGICAND) {
-            expr-&gt;opcode[leftindex+1] = JIM_EXPROP_LOGICAND_LEFT;
+            expr-&gt;opcode[leftindex + 1] = JIM_EXPROP_LOGICAND_LEFT;
             expr-&gt;opcode[index] = JIM_EXPROP_LOGICAND_RIGHT;
-            expr-&gt;obj[leftindex+1] = Jim_NewStringObj(interp, &quot;&amp;L&quot;, -1);
+            expr-&gt;obj[leftindex + 1] = Jim_NewStringObj(interp, &quot;&amp;L&quot;, -1);
             expr-&gt;obj[index] = Jim_NewStringObj(interp, &quot;&amp;R&quot;, -1);
         } else {
-            expr-&gt;opcode[leftindex+1] = JIM_EXPROP_LOGICOR_LEFT;
+            expr-&gt;opcode[leftindex + 1] = JIM_EXPROP_LOGICOR_LEFT;
             expr-&gt;opcode[index] = JIM_EXPROP_LOGICOR_RIGHT;
-            expr-&gt;obj[leftindex+1] = Jim_NewStringObj(interp, &quot;|L&quot;, -1);
+            expr-&gt;obj[leftindex + 1] = Jim_NewStringObj(interp, &quot;|L&quot;, -1);
             expr-&gt;obj[index] = Jim_NewStringObj(interp, &quot;|R&quot;, -1);
         }
         expr-&gt;opcode[leftindex] = JIM_EXPROP_NUMBER;
         expr-&gt;obj[leftindex] = Jim_NewIntObj(interp, offset);
         Jim_IncrRefCount(expr-&gt;obj[index]);
         Jim_IncrRefCount(expr-&gt;obj[leftindex]);
-        Jim_IncrRefCount(expr-&gt;obj[leftindex+1]);
+        Jim_IncrRefCount(expr-&gt;obj[leftindex + 1]);
     }
 }
 
@@ -6950,7 +6950,7 @@
             Jim_DecrRefCount(interp, A);
             Jim_DecrRefCount(interp, B);
             switch (expr-&gt;opcode[i]) {
-            case JIM_EXPROP_ADD: wC = wA+wB; break;
+            case JIM_EXPROP_ADD: wC = wA + wB; break;
             case JIM_EXPROP_SUB: wC = wA-wB; break;
             case JIM_EXPROP_MUL: wC = wA*wB; break;
             case JIM_EXPROP_LT: wC = wA&lt;wB; break;
@@ -7055,7 +7055,7 @@
                 error = 1;
                 goto err;
                 break;
-            case JIM_EXPROP_ADD: dC = dA+dB; break;
+            case JIM_EXPROP_ADD: dC = dA + dB; break;
             case JIM_EXPROP_SUB: dC = dA-dB; break;
             case JIM_EXPROP_MUL: dC = dA*dB; break;
             case JIM_EXPROP_LT: dC = dA&lt;dB; break;
@@ -7350,7 +7350,7 @@
     memset(fmtObj, 0, approxSize);
     fmtObj-&gt;size = approxSize;
     fmtObj-&gt;maxPos = 0;
-    fmtObj-&gt;scratch = (char*)&amp;fmtObj-&gt;descr[maxCount+1];
+    fmtObj-&gt;scratch = (char*)&amp;fmtObj-&gt;descr[maxCount + 1];
     fmtObj-&gt;stringRep = fmtObj-&gt;scratch + maxFmtLen + 3 + 1;
     memcpy(fmtObj-&gt;stringRep, fmt, maxFmtLen);
     buffer = fmtObj-&gt;stringRep + maxFmtLen + 1;
@@ -7442,11 +7442,11 @@
             /* In case a range fence was given &quot;backwards&quot;, swap it */
             while (swapped) {
                 swapped = 0;
-                for (j = beg+1; j &lt; end-1; ++j) {
-                    if (buffer[j] == '-' &amp;&amp; buffer[j-1] &gt; buffer[j+1]) {
+                for (j = beg + 1; j &lt; end-1; ++j) {
+                    if (buffer[j] == '-' &amp;&amp; buffer[j-1] &gt; buffer[j + 1]) {
                         char tmp = buffer[j-1];
-                        buffer[j-1] = buffer[j+1];
-                        buffer[j+1] = tmp;
+                        buffer[j-1] = buffer[j + 1];
+                        buffer[j + 1] = tmp;
                         swapped = 1;
                     }
                 }
@@ -7525,8 +7525,8 @@
 {
     size_t i;
     Jim_Obj *result;
-    char charset[256/8+1];  /* A Charset may contain max 256 chars */
-    char *buffer = Jim_Alloc(strlen(str)+1), *anchor = buffer;
+    char charset[256/8 + 1];  /* A Charset may contain max 256 chars */
+    char *buffer = Jim_Alloc(strlen(str) + 1), *anchor = buffer;
 
     /* First init charset to nothing or all, depending if a specified
      * or an unspecified string has to be parsed */
@@ -7838,13 +7838,13 @@
     prng = interp-&gt;prngState;
     /* generates 'len' bytes of pseudo-random numbers */
     for (x = 0; x &lt; len; x++) {
-        prng-&gt;i = (prng-&gt;i+1) &amp; 0xff;
+        prng-&gt;i = (prng-&gt;i + 1) &amp; 0xff;
         si = prng-&gt;sbox[prng-&gt;i];
         prng-&gt;j = (prng-&gt;j + si) &amp; 0xff;
         sj = prng-&gt;sbox[prng-&gt;j];
         prng-&gt;sbox[prng-&gt;i] = sj;
         prng-&gt;sbox[prng-&gt;j] = si;
-        *destByte++ = prng-&gt;sbox[(si+sj)&amp;0xff];
+        *destByte++ = prng-&gt;sbox[(si + sj)&amp;0xff];
     }
 }
 
@@ -7939,7 +7939,7 @@
                     &amp;prefixObjPtr, JIM_NONE) != JIM_OK)
                 continue;
             prefix = Jim_GetString(prefixObjPtr, &amp;prefixlen);
-            if (prefixlen+strlen(pathName)+1 &gt;= JIM_PATH_LEN)
+            if (prefixlen + strlen(pathName) + 1 &gt;= JIM_PATH_LEN)
                 continue;
             if (*pathName == '/') {
                 strcpy(buf, pathName);
@@ -8000,7 +8000,7 @@
 #define JIM_PKG_ANY_VERSION -1
 
 /* Convert a string of the type &quot;1.2&quot; into an integer.
- * MAJOR.MINOR is converted as MAJOR*100+MINOR, so &quot;1.2&quot; is converted 
+ * MAJOR.MINOR is converted as MAJOR*100 + MINOR, so &quot;1.2&quot; is converted 
  * to the integer with value 102 */
 static int JimPackageVersionToInt(Jim_Interp *interp, const char *v,
         int *intPtr, int flags)
@@ -8019,12 +8019,12 @@
     if (p == NULL) goto badfmt;
     *p = '\0';
     majorStr = copy;
-    minorStr = p+1;
+    minorStr = p + 1;
 
     if (Jim_StringToWide(majorStr, &amp;major, 10) != JIM_OK ||
         Jim_StringToWide(minorStr, &amp;minor, 10) != JIM_OK)
         goto badfmt;
-    *intPtr = (int)(major*100+minor);
+    *intPtr = (int)(major*100 + minor);
     Jim_Free(copy);
     return JIM_OK;
 
@@ -8190,20 +8190,20 @@
             int fileNameLen = strlen(fileName);
 
             if (strncmp(fileName, &quot;jim-&quot;, 4) == 0 &amp;&amp;
-                strncmp(fileName+4, pkgName, pkgNameLen) == 0 &amp;&amp;
-                *(fileName+4+pkgNameLen) == '-' &amp;&amp;
+                strncmp(fileName + 4, pkgName, pkgNameLen) == 0 &amp;&amp;
+                *(fileName + 4+pkgNameLen) == '-' &amp;&amp;
                 fileNameLen &gt; 4 &amp;&amp; /* note that this is not really useful */
-                (strncmp(fileName+fileNameLen-4, &quot;.tcl&quot;, 4) == 0 ||
-                 strncmp(fileName+fileNameLen-4, &quot;.dll&quot;, 4) == 0 ||
-                 strncmp(fileName+fileNameLen-3, &quot;.so&quot;, 3) == 0))
+                (strncmp(fileName + fileNameLen-4, &quot;.tcl&quot;, 4) == 0 ||
+                 strncmp(fileName + fileNameLen-4, &quot;.dll&quot;, 4) == 0 ||
+                 strncmp(fileName + fileNameLen-3, &quot;.so&quot;, 3) == 0))
             {
                 char ver[6]; /* xx.yy&lt;nulterm&gt; */
                 char *p = strrchr(fileName, '.');
                 int verLen, fileVer;
 
-                verLen = p - (fileName+4+pkgNameLen+1);
+                verLen = p - (fileName + 4+pkgNameLen + 1);
                 if (verLen &lt; 3 || verLen &gt; 5) continue;
-                memcpy(ver, fileName+4+pkgNameLen+1, verLen);
+                memcpy(ver, fileName + 4+pkgNameLen + 1, verLen);
                 ver[verLen] = '\0';
                 if (JimPackageVersionToInt(interp, ver, &amp;fileVer, JIM_NONE)
                         != JIM_OK) continue;
@@ -8212,7 +8212,7 @@
                 {
                     bestVer = fileVer;
                     Jim_Free(bestPackage);
-                    bestPackage = Jim_Alloc(strlen(buf)+strlen(fileName)+2);
+                    bestPackage = Jim_Alloc(strlen(buf) + strlen(fileName) + 2);
                     sprintf(bestPackage, &quot;%s/%s&quot;, buf, fileName);
                 }
             }
@@ -8368,19 +8368,19 @@
      * the &quot;unknown&quot; string, it is used in order to
      * avoid to lookup the unknown command every time
      * but instread to cache the result. */
-    if (argc+1 &lt;= JIM_EVAL_SARGV_LEN)
+    if (argc + 1 &lt;= JIM_EVAL_SARGV_LEN)
         v = sv;
     else
-        v = Jim_Alloc(sizeof(Jim_Obj*)*(argc+1));
+        v = Jim_Alloc(sizeof(Jim_Obj*)*(argc + 1));
     /* Make a copy of the arguments vector, but shifted on
      * the right of one position. The command name of the
      * command will be instead the first argument of the
      * [unknonw] call. */
-    memcpy(v+1, argv, sizeof(Jim_Obj*)*argc);
+    memcpy(v + 1, argv, sizeof(Jim_Obj*)*argc);
     v[0] = interp-&gt;unknown;
     /* Call it */
     interp-&gt;unknown_called++;
-    retCode = Jim_EvalObjVector(interp, argc+1, v);
+    retCode = Jim_EvalObjVector(interp, argc + 1, v);
     interp-&gt;unknown_called--;
 
     /* Clean up */
@@ -8496,7 +8496,7 @@
      * object. */
     objPtr = Jim_NewStringObjNoAlloc(interp,
             NULL, 0);
-    s = objPtr-&gt;bytes = Jim_Alloc(totlen+1);
+    s = objPtr-&gt;bytes = Jim_Alloc(totlen + 1);
     objPtr-&gt;length = totlen;
     for (i = 0; i &lt; tokens; i++) {
         memcpy(s, intv[i]-&gt;bytes, intv[i]-&gt;length);
@@ -8527,7 +8527,7 @@
         int *argcPtr, int expand, Jim_Obj *objPtr)
 {
     if (!expand) {
-        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr)+1));
+        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr) + 1));
         /* refcount of objPtr not incremented because
          * we are actually transfering a reference from
          * the old 'argv' to the expanded one. */
@@ -8537,7 +8537,7 @@
         int len, i;
 
         Jim_ListLength(interp, objPtr, &amp;len);
-        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr)+len));
+        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr) + len));
         for (i = 0; i &lt; len; i++) {
             (*argv)[*argcPtr] = objPtr-&gt;internalRep.listValue.ele[i];
             Jim_IncrRefCount(objPtr-&gt;internalRep.listValue.ele[i]);
@@ -8668,13 +8668,13 @@
                 /* For interpolation we call an helper
                  * function doing the work for us. */
                 if ((retcode = Jim_InterpolateTokens(interp,
-                        token+i, tokens, &amp;tmpObjPtr)) != JIM_OK)
+                        token + i, tokens, &amp;tmpObjPtr)) != JIM_OK)
                 {
                     goto err;
                 }
                 argv[j] = tmpObjPtr;
                 Jim_IncrRefCount(argv[j]);
-                i += tokens+1;
+                i += tokens + 1;
             }
         }
         /* Handle {expand} expansion */
@@ -8840,7 +8840,7 @@
             Jim_ListIndex(interp, argObjPtr, 1, &amp;valueObjPtr, JIM_NONE);
         }
         else {
-            valueObjPtr = argv[i+1];
+            valueObjPtr = argv[i + 1];
         }
         Jim_SetVariable(interp, nameObjPtr, valueObjPtr);
     }
@@ -8849,7 +8849,7 @@
         Jim_Obj *listObjPtr, *objPtr;
 
         i++;
-        listObjPtr = Jim_NewListObj(interp, argv+i, argc-i);
+        listObjPtr = Jim_NewListObj(interp, argv + i, argc-i);
         Jim_ListIndex(interp, cmd-&gt;argListObjPtr, num_args, &amp;objPtr, JIM_NONE);
         Jim_SetVariable(interp, objPtr, listObjPtr);
     }
@@ -8974,12 +8974,12 @@
     buflen = 1024;
     maxlen = totread = 0;
     while (1) {
-        if (maxlen &lt; totread+buflen+1) {
-            maxlen = totread+buflen+1;
+        if (maxlen &lt; totread + buflen + 1) {
+            maxlen = totread + buflen + 1;
             prg = Jim_Realloc(prg, maxlen);
         }
 		/* do not use Jim_fread() - this is really a file */
-        if ((nread = fread(prg+totread, 1, buflen, fp)) == 0) break;
+        if ((nread = fread(prg + totread, 1, buflen, fp)) == 0) break;
         totread += nread;
     }
     prg[totread] = '\0';
@@ -9045,7 +9045,7 @@
                     pc-&gt;tt = JIM_TT_ESC;
                 if (*pc-&gt;tstart == '{') {
                     pc-&gt;tstart--;
-                    if (*(pc-&gt;tend+1))
+                    if (*(pc-&gt;tend + 1))
                         pc-&gt;tend++;
                 }
             }
@@ -9404,7 +9404,7 @@
     Jim_AppendString(interp, objPtr, &quot;wrong # args: should be \&quot;&quot;, -1);
     for (i = 0; i &lt; argc; i++) {
         Jim_AppendObj(interp, objPtr, argv[i]);
-        if (!(i+1 == argc &amp;&amp; msg[0] == '\0'))
+        if (!(i + 1 == argc &amp;&amp; msg[0] == '\0'))
             Jim_AppendString(interp, objPtr, &quot; &quot;, 1);
     }
     Jim_AppendString(interp, objPtr, msg, -1);
@@ -9723,13 +9723,13 @@
     if (Jim_GetWide(interp, intObjPtr, &amp;wideValue) != JIM_OK)
         return JIM_ERR;
     if (Jim_IsShared(intObjPtr)) {
-        intObjPtr = Jim_NewIntObj(interp, wideValue+increment);
+        intObjPtr = Jim_NewIntObj(interp, wideValue + increment);
         if (Jim_SetVariable(interp, argv[1], intObjPtr) != JIM_OK) {
             Jim_FreeNewObj(interp, intObjPtr);
             return JIM_ERR;
         }
     } else {
-        Jim_SetWide(interp, intObjPtr, wideValue+increment);
+        Jim_SetWide(interp, intObjPtr, wideValue + increment);
         /* The following step is required in order to invalidate the
          * string repr of &quot;FOO&quot; if the var name is on the form of &quot;FOO(IDX)&quot; */
         if (Jim_SetVariable(interp, argv[1], intObjPtr) != JIM_OK) {
@@ -10116,7 +10116,7 @@
                     Jim_DecrRefCount(interp, varNamePtr);
                     goto evalnext;
                 }
-                auxObjPtr = Jim_NewIntObj(interp, currentVal+1);
+                auxObjPtr = Jim_NewIntObj(interp, currentVal + 1);
                 if (Jim_SetVariable(interp, varNamePtr, auxObjPtr) == JIM_ERR) {
                     if (stopVarNamePtr)
                         Jim_DecrRefCount(interp, stopVarNamePtr);
@@ -10206,13 +10206,13 @@
     for (i = 0; i &lt; nbrOfLists*2; i += 2) {
         div_t cnt;
         int count;
-        Jim_ListLength(interp, argv[i+1], &amp;listsEnd[i]);
-        Jim_ListLength(interp, argv[i+2], &amp;listsEnd[i+1]);
+        Jim_ListLength(interp, argv[i + 1], &amp;listsEnd[i]);
+        Jim_ListLength(interp, argv[i + 2], &amp;listsEnd[i + 1]);
         if (listsEnd[i] == 0) {
             Jim_SetResultString(interp, &quot;foreach varlist is empty&quot;, -1);
             goto err;
         }
-        cnt = div(listsEnd[i+1], listsEnd[i]);
+        cnt = div(listsEnd[i + 1], listsEnd[i]);
         count = cnt.quot + (cnt.rem ? 1 : 0);
         if (count &gt; nbrOfLoops)
             nbrOfLoops = count;
@@ -10223,11 +10223,11 @@
             while (varIdx &lt; listsEnd[var]) {
                 Jim_Obj *varName, *ele;
                 int lst = i * 2 + 1;
-                if (Jim_ListIndex(interp, argv[var+1], varIdx, &amp;varName, JIM_ERRMSG)
+                if (Jim_ListIndex(interp, argv[var + 1], varIdx, &amp;varName, JIM_ERRMSG)
                         != JIM_OK)
                         goto err;
                 if (listsIdx[i] &lt; listsEnd[lst]) {
-                    if (Jim_ListIndex(interp, argv[lst+1], listsIdx[i], &amp;ele, JIM_ERRMSG)
+                    if (Jim_ListIndex(interp, argv[lst + 1], listsIdx[i], &amp;ele, JIM_ERRMSG)
                         != JIM_OK)
                         goto err;
                     if (Jim_SetVariable(interp, varName, ele) != JIM_OK) {
@@ -10379,11 +10379,11 @@
             switch (matchOpt) {
                 case SWITCH_EXACT:
                     if (Jim_StringEqObj(strObj, patObj, 0))
-                        script = caseList[i+1];
+                        script = caseList[i + 1];
                     break;
                 case SWITCH_GLOB:
                     if (Jim_StringMatchObj(patObj, strObj, 0))
-                        script = caseList[i+1];
+                        script = caseList[i + 1];
                     break;
                 case SWITCH_RE:
                     command = Jim_NewStringObj(interp, &quot;regexp&quot;, -1);
@@ -10412,7 +10412,7 @@
                         goto err;
                     }
                     if (matching)
-                        script = caseList[i+1];
+                        script = caseList[i + 1];
                     break;
                 }
                 default:
@@ -10422,12 +10422,12 @@
                     goto err;
             }
         } else {
-          script = caseList[i+1];
+          script = caseList[i + 1];
         }
     }
     for (; i &lt; patCount &amp;&amp; Jim_CompareStringImmediate(interp, script, &quot;-&quot;);
         i += 2)
-        script = caseList[i+1];
+        script = caseList[i + 1];
     if (script &amp;&amp; Jim_CompareStringImmediate(interp, script, &quot;-&quot;)) {
         Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
         Jim_AppendStrings(interp, Jim_GetResult(interp),
@@ -10454,7 +10454,7 @@
 {
     Jim_Obj *listObjPtr;
 
-    listObjPtr = Jim_NewListObj(interp, argv+1, argc-1);
+    listObjPtr = Jim_NewListObj(interp, argv + 1, argc-1);
     Jim_SetResult(interp, listObjPtr);
     return JIM_OK;
 }
@@ -10589,7 +10589,7 @@
         Jim_SetResult(interp, argv[2]);
         return JIM_OK;
     }
-    if (Jim_SetListIndex(interp, argv[1], argv+2, argc-3, argv[argc-1])
+    if (Jim_SetListIndex(interp, argv[1], argv + 2, argc-3, argv[argc-1])
             == JIM_ERR) return JIM_ERR;
     return JIM_OK;
 }
@@ -10841,7 +10841,7 @@
         Jim_Obj *objPtr;
         int retcode;
 
-        objPtr = Jim_ConcatObj(interp, argc-1, argv+1);
+        objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
         Jim_IncrRefCount(objPtr);
         retcode = Jim_EvalObj(interp, objPtr);
         Jim_DecrRefCount(interp, objPtr);
@@ -10895,7 +10895,7 @@
         if (argc == 2) {
             retcode = Jim_EvalObj(interp, argv[1]);
         } else {
-            objPtr = Jim_ConcatObj(interp, argc-1, argv+1);
+            objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
             Jim_IncrRefCount(objPtr);
             retcode = Jim_EvalObj(interp, objPtr);
             Jim_DecrRefCount(interp, objPtr);
@@ -10921,7 +10921,7 @@
     } else if (argc &gt; 2) {
         Jim_Obj *objPtr;
 
-        objPtr = Jim_ConcatObj(interp, argc-1, argv+1);
+        objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
         Jim_IncrRefCount(objPtr);
         retcode = Jim_EvalExpression(interp, objPtr, &amp;exprResultPtr);
         Jim_DecrRefCount(interp, objPtr);
@@ -10988,7 +10988,7 @@
 {
     Jim_Obj *objPtr;
 
-    objPtr = Jim_NewListObj(interp, argv+1, argc-1);
+    objPtr = Jim_NewListObj(interp, argv + 1, argc-1);
     Jim_SetResult(interp, objPtr);
     return JIM_EVAL;
 }
@@ -11005,7 +11005,7 @@
         return JIM_ERR;
     }
     Jim_ListLength(interp, argv[2], &amp;argListLen);
-    arityMin = arityMax = argListLen+1;
+    arityMin = arityMax = argListLen + 1;
 
     if (argListLen) {
         const char *str;
@@ -11045,7 +11045,7 @@
 static int Jim_ConcatCoreCommand(Jim_Interp *interp, int argc, 
         Jim_Obj *const *argv)
 {
-    Jim_SetResult(interp, Jim_ConcatObj(interp, argc-1, argv+1));
+    Jim_SetResult(interp, Jim_ConcatObj(interp, argc-1, argv + 1));
     return JIM_OK;
 }
 
@@ -11079,7 +11079,7 @@
     }
     /* Now... for every other/local couple: */
     for (i = 1; i &lt; argc; i += 2) {
-        if (Jim_SetVariableLink(interp, argv[i+1], argv[i],
+        if (Jim_SetVariableLink(interp, argv[i + 1], argv[i],
                 targetCallFrame) != JIM_OK) return JIM_ERR;
     }
     return JIM_OK;
@@ -11133,7 +11133,7 @@
 
         Jim_ListIndex(interp, mapListObjPtr, i*2, &amp;eleObjPtr, JIM_NONE);
         key[i] = Jim_GetString(eleObjPtr, &amp;keyLen[i]);
-        Jim_ListIndex(interp, mapListObjPtr, i*2+1, &amp;eleObjPtr, JIM_NONE);
+        Jim_ListIndex(interp, mapListObjPtr, i*2 + 1, &amp;eleObjPtr, JIM_NONE);
         value[i] = eleObjPtr;
     }
     str = Jim_GetString(objPtr, &amp;strLen);
@@ -11312,7 +11312,7 @@
             Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
             return JIM_OK;
         } else {
-            Jim_SetResult(interp, Jim_NewStringObj(interp, str+index, 1));
+            Jim_SetResult(interp, Jim_NewStringObj(interp, str + index, 1));
             return JIM_OK;
         }
     } else if (option == OPT_FIRST) {
@@ -11560,13 +11560,13 @@
             Jim_WrongNumArgs(interp, 2, argv, &quot;?key value ...?&quot;);
             return JIM_ERR;
         }
-        objPtr = Jim_NewDictObj(interp, argv+2, argc-2);
+        objPtr = Jim_NewDictObj(interp, argv + 2, argc-2);
         Jim_SetResult(interp, objPtr);
         return JIM_OK;
     } else if (option == OPT_GET) {
         Jim_Obj *objPtr;
 
-        if (Jim_DictKeysVector(interp, argv[2], argv+3, argc-3, &amp;objPtr,
+        if (Jim_DictKeysVector(interp, argv[2], argv + 3, argc-3, &amp;objPtr,
                 JIM_ERRMSG) != JIM_OK)
             return JIM_ERR;
         Jim_SetResult(interp, objPtr);
@@ -11576,20 +11576,20 @@
             Jim_WrongNumArgs(interp, 2, argv, &quot;varName key ?key ...? value&quot;);
             return JIM_ERR;
         }
-        return Jim_SetDictKeysVector(interp, argv[2], argv+3, argc-4,
+        return Jim_SetDictKeysVector(interp, argv[2], argv + 3, argc-4,
                     argv[argc-1]);
     } else if (option == OPT_UNSET) {
         if (argc &lt; 4) {
             Jim_WrongNumArgs(interp, 2, argv, &quot;varName key ?key ...?&quot;);
             return JIM_ERR;
         }
-        return Jim_SetDictKeysVector(interp, argv[2], argv+3, argc-3,
+        return Jim_SetDictKeysVector(interp, argv[2], argv + 3, argc-3,
                     NULL);
     } else if (option == OPT_EXIST) {
         Jim_Obj *objPtr;
         int exists;
 
-        if (Jim_DictKeysVector(interp, argv[2], argv+3, argc-3, &amp;objPtr,
+        if (Jim_DictKeysVector(interp, argv[2], argv + 3, argc-3, &amp;objPtr,
                 JIM_ERRMSG) == JIM_OK)
             exists = 1;
         else
@@ -11631,19 +11631,19 @@
     }
     i = argc-2;
     while (i--) {
-        if (Jim_CompareStringImmediate(interp, argv[i+1],
+        if (Jim_CompareStringImmediate(interp, argv[i + 1],
                     &quot;-nobackslashes&quot;))
             flags |= JIM_SUBST_NOESC;
-        else if (Jim_CompareStringImmediate(interp, argv[i+1],
+        else if (Jim_CompareStringImmediate(interp, argv[i + 1],
                     &quot;-novariables&quot;))
             flags |= JIM_SUBST_NOVAR;
-        else if (Jim_CompareStringImmediate(interp, argv[i+1],
+        else if (Jim_CompareStringImmediate(interp, argv[i + 1],
                     &quot;-nocommands&quot;))
             flags |= JIM_SUBST_NOCMD;
         else {
             Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
             Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;bad option \&quot;&quot;, Jim_GetString(argv[i+1], NULL),
+                &quot;bad option \&quot;&quot;, Jim_GetString(argv[i + 1], NULL),
                 &quot;\&quot;: must be -nobackslashes, -nocommands, or &quot;
                 &quot;-novariables&quot;, NULL);
             return JIM_ERR;
@@ -11802,7 +11802,7 @@
                     objPtr = Jim_NewStringObj(interp, noMatchStart,
                             (str-noMatchStart));
                     Jim_ListAppendElement(interp, resObjPtr, objPtr);
-                    noMatchStart = str+1;
+                    noMatchStart = str + 1;
                     break;
                 }
             }
@@ -11821,7 +11821,7 @@
             int c = u[i];
             
             if (objCache[c] == NULL)
-                objCache[c] = Jim_NewStringObj(interp, (char*)u+i, 1);
+                objCache[c] = Jim_NewStringObj(interp, (char*)u + i, 1);
             Jim_ListAppendElement(interp, resObjPtr, objCache[c]);
         }
     }
@@ -11856,7 +11856,7 @@
 
         Jim_ListIndex(interp, argv[1], i, &amp;objPtr, JIM_NONE);
         Jim_AppendObj(interp, resObjPtr, objPtr);
-        if (i+1 != listLen) {
+        if (i + 1 != listLen) {
             Jim_AppendString(interp, resObjPtr, joinStr, joinStrLen);
         }
     }
@@ -11874,7 +11874,7 @@
         Jim_WrongNumArgs(interp, 1, argv, &quot;formatString ?arg arg ...?&quot;);
         return JIM_ERR;
     }
-    objPtr = Jim_FormatString(interp, argv[1], argc-2, argv+2);
+    objPtr = Jim_FormatString(interp, argv[1], argc-2, argv + 2);
     if (objPtr == NULL)
         return JIM_ERR;
     Jim_SetResult(interp, objPtr);
@@ -11929,7 +11929,7 @@
         for (i = 0; i &lt; outc; ++i) {
             if (Jim_Length(outVec[i]) &gt; 0) {
                 ++count;
-                if (Jim_SetVariable(interp, argv[3+i], outVec[i]) != JIM_OK)
+                if (Jim_SetVariable(interp, argv[3 + i], outVec[i]) != JIM_OK)
                     goto err;
             }
         }
@@ -12107,7 +12107,7 @@
     }
     objPtr = Jim_NewListObj(interp, NULL, 0);
     for (i = 0; i &lt; len; i++)
-        ListAppendElement(objPtr, Jim_NewIntObj(interp, start+i*step));
+        ListAppendElement(objPtr, Jim_NewIntObj(interp, start + i*step));
     Jim_SetResult(interp, objPtr);
     return JIM_OK;
 }
@@ -12144,7 +12144,7 @@
         JimRandomBytes(interp, &amp;r, sizeof(jim_wide));
         if (r &lt; 0 || r &gt;= maxMul) continue;
         r = (len == 0) ? 0 : r%len;
-        Jim_SetResult(interp, Jim_NewIntObj(interp, min+r));
+        Jim_SetResult(interp, Jim_NewIntObj(interp, min + r));
         return JIM_OK;
     }
 }
@@ -12313,10 +12313,10 @@
 
         Jim_ListIndex(interp, interp-&gt;stackTrace, i, &amp;objPtr, JIM_NONE);
         proc = Jim_GetString(objPtr, NULL);
-        Jim_ListIndex(interp, interp-&gt;stackTrace, i+1, &amp;objPtr,
+        Jim_ListIndex(interp, interp-&gt;stackTrace, i + 1, &amp;objPtr,
                 JIM_NONE);
         file = Jim_GetString(objPtr, NULL);
-        Jim_ListIndex(interp, interp-&gt;stackTrace, i+2, &amp;objPtr,
+        Jim_ListIndex(interp, interp-&gt;stackTrace, i + 2, &amp;objPtr,
                 JIM_NONE);
         line = Jim_GetString(objPtr, NULL);
         if (*proc) {
@@ -12796,7 +12796,7 @@
 		const char *a;
 		const char *b;
 
-		if ( (nvp+1)-&gt;name ){
+		if ( (nvp + 1)-&gt;name ){
 			a = nvp-&gt;name;
 			b = &quot;, &quot;;
 		} else {

Modified: trunk/src/helper/jim.h
===================================================================
--- trunk/src/helper/jim.h	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/jim.h	2009-06-23 22:44:17 UTC (rev 2373)
@@ -563,7 +563,7 @@
 typedef struct Jim_Reference {
     Jim_Obj *objPtr;
     Jim_Obj *finalizerCmdNamePtr;
-    char tag[JIM_REFERENCE_TAGLEN+1];
+    char tag[JIM_REFERENCE_TAGLEN + 1];
 } Jim_Reference;
 
 /** Name Value Pairs, aka: NVP

Modified: trunk/src/helper/log.c
===================================================================
--- trunk/src/helper/log.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/log.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -103,7 +103,7 @@
 #ifdef _DEBUG_FREE_SPACE_
 					&quot; %d&quot;
 #endif
-					&quot;: %s&quot;, log_strings[level+1], count, t, file, line, function,
+					&quot;: %s&quot;, log_strings[level + 1], count, t, file, line, function,
 #ifdef _DEBUG_FREE_SPACE_
 					info.fordblks,
 #endif
@@ -117,7 +117,7 @@
 			{
 				/* print human readable output - but skip empty lines */
 				fprintf(log_output, &quot;%s%s&quot;,
-						(level &gt; LOG_LVL_USER)?log_strings[level+1]:&quot;&quot;, string);
+						(level &gt; LOG_LVL_USER)?log_strings[level + 1]:&quot;&quot;, string);
 			}
 		}
 	} else

Modified: trunk/src/helper/log.h
===================================================================
--- trunk/src/helper/log.h	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/log.h	2009-06-23 22:44:17 UTC (rev 2373)
@@ -29,7 +29,7 @@
 #include &quot;command.h&quot;
 
 /* logging priorities 
- * LOG_LVL_SILENT - turn off all output. In lieu of try+catch this can be used as a 
+ * LOG_LVL_SILENT - turn off all output. In lieu of try + catch this can be used as a 
  *                  feeble ersatz.
  * LOG_LVL_USER - user messages. Could be anything from information 
  *                to progress messags. These messages do not represent

Modified: trunk/src/helper/replacements.c
===================================================================
--- trunk/src/helper/replacements.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/helper/replacements.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -218,7 +218,7 @@
 			tvslice.tv_sec = 0;
 			tvslice.tv_usec = 100000;
 
-			retcode = select(sock_max_fd+1, &amp;aread, &amp;awrite, &amp;aexcept, &amp;tvslice);
+			retcode = select(sock_max_fd + 1, &amp;aread, &amp;awrite, &amp;aexcept, &amp;tvslice);
 		}
 		if (n_handles &gt; 0) {
 			/* check handles */

Modified: trunk/src/jtag/arm-jtag-ew.c
===================================================================
--- trunk/src/jtag/arm-jtag-ew.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/arm-jtag-ew.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -207,7 +207,7 @@
 
 
     usb_out_buffer[0] = CMD_SET_TCK_FREQUENCY;
-	buf_set_u32(usb_out_buffer+1, 0, 32, speed);
+	buf_set_u32(usb_out_buffer + 1, 0, 32, speed);
 
     result = armjtagew_usb_message(armjtagew_jtag_handle, 4, 4);
 
@@ -500,7 +500,7 @@
 
 	/* query hardware version */
 	usb_out_buffer[0] = CMD_GET_VERSION;
-	result = armjtagew_usb_message(armjtagew_jtag_handle, 1, 4+15+256);
+	result = armjtagew_usb_message(armjtagew_jtag_handle, 1, 4 + 15 + 256);
 
 	if (result != 0)
 	{
@@ -509,9 +509,9 @@
 	}
 
 
-	memcpy(sn, usb_in_buffer+4, 15);
+	memcpy(sn, usb_in_buffer + 4, 15);
 	sn[15] = '\0';
-	memcpy(auxinfo, usb_in_buffer+4+15, 256);
+	memcpy(auxinfo, usb_in_buffer + 4+15, 256);
 	auxinfo[256] = '\0';
 
 	LOG_INFO(&quot;ARM-JTAG-EW firmware version %d.%d, hardware revision %c, SN=%s, Additional info: %s&quot;, \
@@ -651,7 +651,7 @@
 		byte_length = tap_length / 8;
 
 		usb_out_buffer[0] = CMD_TAP_SHIFT;
-		buf_set_u32(usb_out_buffer+1, 0, 16, byte_length);
+		buf_set_u32(usb_out_buffer + 1, 0, 16, byte_length);
 
 		tms_offset = 3;
 		for (i = 0; i &lt; byte_length; i++)

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/ft2232.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -188,7 +188,7 @@
 static int             require_send;
 
 
-/*	<A HREF="http://urjtag.wiki.sourceforge.net/Cable+FT2232">http://urjtag.wiki.sourceforge.net/Cable+FT2232</A> says:
+/*	<A HREF="http://urjtag.wiki.sourceforge.net/Cable">http://urjtag.wiki.sourceforge.net/Cable</A> + FT2232 says:
 
 	&quot;There is a significant difference between libftdi and libftd2xx. The latter
 	one allows to schedule up to 64*64 bytes of result data while libftdi fails

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/jlink.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -50,7 +50,7 @@
 //#define JLINK_TAP_BUFFER_SIZE 384
 
 #define JLINK_IN_BUFFER_SIZE			2048
-#define JLINK_OUT_BUFFER_SIZE			2*2048+4
+#define JLINK_OUT_BUFFER_SIZE			2*2048 + 4
 #define JLINK_EMU_RESULT_BUFFER_SIZE	64
 
 /* Global USB buffers */

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/jtag.h	2009-06-23 22:44:17 UTC (rev 2373)
@@ -633,7 +633,7 @@
 int jtag_get_flush_queue_count(void);
 
 
-/* can be implemented by hw+sw */
+/* can be implemented by hw + sw */
 extern int jtag_power_dropout(int* dropout);
 extern int jtag_srst_asserted(int* srst_asserted);
 

Modified: trunk/src/jtag/presto.c
===================================================================
--- trunk/src/jtag/presto.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/presto.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -712,7 +712,7 @@
 	}
 
 	if (khz &gt;= 3000) *jtag_speed = 0;
-	else *jtag_speed = (1000+khz-1)/khz;
+	else *jtag_speed = (1000 + khz-1)/khz;
 
 	return 0;
 }

Modified: trunk/src/jtag/tcl.c
===================================================================
--- trunk/src/jtag/tcl.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/tcl.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -532,7 +532,7 @@
 
 	context = Jim_GetAssocData(interp, &quot;context&quot;);
 	/* go past the command */
-	Jim_GetOpt_Setup( &amp;goi, interp, argc-1, argv+1 );
+	Jim_GetOpt_Setup( &amp;goi, interp, argc-1, argv + 1 );
 
 	e = Jim_GetOpt_Nvp( &amp;goi, jtag_cmds, &amp;n );
 	if ( e != JIM_OK ){
@@ -1286,7 +1286,7 @@
 		}
 
 		/* Not valid.. are we at the end? */
-		if ( ((i+2) != argc) ){
+		if ( ((i + 2) != argc) ){
 			/* nope, then error */
 			return e;
 		}
@@ -1301,7 +1301,7 @@
 		/* is it the magic? */
 		if ( 0 == strcmp( &quot;-endstate&quot;, cp ) ){
 			/* is the statename valid? */
-			cp = Jim_GetString( args[i+1], NULL );
+			cp = Jim_GetString( args[i + 1], NULL );
 
 			/* see if it is a valid state name */
 			endstate = tap_state_by_name(cp);
@@ -1340,7 +1340,7 @@
 		const char *str;
 
 		Jim_GetLong(interp, args[i], &amp;bits);
-		str = Jim_GetString(args[i+1], &amp;len);
+		str = Jim_GetString(args[i + 1], &amp;len);
 
 		fields[field_count].tap = tap;
 		fields[field_count].num_bits = bits;
@@ -1387,7 +1387,7 @@
 {
 	tap_state_t states[8];
 
-	if ((argc &lt; 2) || ((size_t)argc &gt; (sizeof(states)/sizeof(*states)+1)))
+	if ((argc &lt; 2) || ((size_t)argc &gt; (sizeof(states)/sizeof(*states) + 1)))
 	{
 		Jim_WrongNumArgs(interp, 1, args, &quot;wrong arguments&quot;);
 		return JIM_ERR;
@@ -1399,7 +1399,7 @@
 	for (i = 0; i&lt;argc-1; i++)
 	{
 		const char *cp;
-		cp = Jim_GetString( args[i+1], NULL );
+		cp = Jim_GetString( args[i + 1], NULL );
 		states[i] = tap_state_by_name(cp);
 		if ( states[i] &lt; 0 )
 		{
@@ -1415,7 +1415,7 @@
 		return JIM_ERR;
 	}
 
-	jtag_add_pathmove(argc-2, states+1);
+	jtag_add_pathmove(argc-2, states + 1);
 
 	if (jtag_execute_queue()!= ERROR_OK)
 	{

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/vsllink.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -1585,7 +1585,7 @@
 
 		for (i = 0; i &lt; len_tmp; i++)
 		{
-			vsllink_tap_append_step(((len_all+i) &lt; length-1 ? 0 : 1), (buffer[(len_all+i)/8] &gt;&gt; ((len_all+i)%8)) &amp; 1);
+			vsllink_tap_append_step(((len_all + i) &lt; length-1 ? 0 : 1), (buffer[(len_all + i)/8] &gt;&gt; ((len_all + i)%8)) &amp; 1);
 		}
 
 		pending_scan_results_length++;

Modified: trunk/src/jtag/zy1000/jtag_minidriver.h
===================================================================
--- trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/zy1000/jtag_minidriver.h	2009-06-23 22:44:17 UTC (rev 2373)
@@ -40,7 +40,7 @@
 	cyg_uint32 empty;
 	do
 	{
-		ZY1000_PEEK(ZY1000_JTAG_BASE+0x10, empty);
+		ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
 	} while ((empty &amp; 0x100) == 0);
 }
 
@@ -54,7 +54,7 @@
 #if 0
 	cyg_uint32 dummy;
 	waitIdle();
-	ZY1000_PEEK(ZY1000_JTAG_BASE+0xc, dummy);
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0xc, dummy);
 #endif
 }
 
@@ -74,7 +74,7 @@
 	}
 	waitQueue();
 	sampleShiftRegister();
-	ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|a);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|a);
 
 }
 
@@ -89,7 +89,7 @@
 	b = endState;
 	waitQueue();
 	sampleShiftRegister();
-	ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0xc, value);
 #if 1
 #if TEST_MANUAL()
 	if ((state == TAP_DRSHIFT) &amp;&amp; (endState != TAP_DRSHIFT))
@@ -106,21 +106,21 @@
 			}
 			/* shift out value */
 			waitIdle();
-			ZY1000_POKE(ZY1000_JTAG_BASE+0x28, (((value &gt;&gt; i)&amp;1) &lt;&lt; 1)|tms);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, (((value &gt;&gt; i)&amp;1) &lt;&lt; 1)|tms);
 		}
 		waitIdle();
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x28, 0);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
 		waitIdle();
-		//ZY1000_POKE(ZY1000_JTAG_BASE+0x20, TAP_DRSHIFT); // set this state and things break =&gt; expected
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x20, TAP_DRPAUSE); // set this and things will work =&gt; expected. Not setting this is not sufficient to make things break.
+		//ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_DRSHIFT); // set this state and things break =&gt; expected
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_DRPAUSE); // set this and things will work =&gt; expected. Not setting this is not sufficient to make things break.
 		setCurrentState(endState);
 	} else
 	{
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
 	}
 #else
 	/* fast version */
-	ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
 #endif
 #else
 	/* maximum debug version */
@@ -131,16 +131,16 @@
 		for (i = 0; i&lt;repeat-1; i++)
 		{
 			sampleShiftRegister();
-			ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value &gt;&gt; i);
-			ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (1 &lt;&lt; 8)|(a &lt;&lt; 4)|a);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0xc, value &gt;&gt; i);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (1 &lt;&lt; 8)|(a &lt;&lt; 4)|a);
 		}
 		sampleShiftRegister();
-		ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value &gt;&gt; (repeat-1));
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (1 &lt;&lt; 8)|(a &lt;&lt; 4)|b);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0xc, value &gt;&gt; (repeat-1));
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (1 &lt;&lt; 8)|(a &lt;&lt; 4)|b);
 	} else
 	{
 		sampleShiftRegister();
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
 	}
 	sampleShiftRegister();
 #endif

Modified: trunk/src/jtag/zy1000/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/jtag/zy1000/zy1000.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -78,8 +78,8 @@
 {
 	cyg_uint32 state;
 	// sample and clear power dropout
-	HAL_WRITE_UINT32(ZY1000_JTAG_BASE+0x10, 0x80);
-	HAL_READ_UINT32(ZY1000_JTAG_BASE+0x10, state);
+	HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x10, 0x80);
+	HAL_READ_UINT32(ZY1000_JTAG_BASE + 0x10, state);
 	bool powerDropout;
 	powerDropout = (state &amp; 0x80) != 0;
 	return powerDropout;
@@ -90,8 +90,8 @@
 {
 	cyg_uint32 state;
 	// sample and clear SRST sensing
-	HAL_WRITE_UINT32(ZY1000_JTAG_BASE+0x10, 0x00000040);
-	HAL_READ_UINT32(ZY1000_JTAG_BASE+0x10, state);
+	HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x10, 0x00000040);
+	HAL_READ_UINT32(ZY1000_JTAG_BASE + 0x10, state);
 	bool srstAsserted;
 	srstAsserted = (state &amp; 0x40) != 0;
 	return srstAsserted;
@@ -129,35 +129,35 @@
 	LOG_DEBUG(&quot;zy1000 trst=%d, srst=%d&quot;, trst, srst);
 	if (!srst)
 	{
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x14, 0x00000001);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x00000001);
 	}
 	else
 	{
 		/* Danger!!! if clk != 0 when in
 		 * idle in TAP_IDLE, reset halt on str912 will fail.
 		 */
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x10, 0x00000001);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x00000001);
 	}
 
 	if (!trst)
 	{
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x14, 0x00000002);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x00000002);
 	}
 	else
 	{
 		/* assert reset */
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x10, 0x00000002);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x00000002);
 	}
 
 	if (trst||(srst &amp;&amp; (jtag_get_reset_config() &amp; RESET_SRST_PULLS_TRST)))
 	{
 		waitIdle();
 		/* we're now in the RESET state until trst is deasserted */
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x20, TAP_RESET);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_RESET);
 	} else
 	{
 		/* We'll get RCLK failure when we assert TRST, so clear any false positives here */
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x14, 0x400);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x400);
 	}
 
 	/* wait for srst to float back up */
@@ -192,7 +192,7 @@
 	{
 		/*0 means RCLK*/
 		speed = 0;
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x10, 0x100);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x100);
 		LOG_DEBUG(&quot;jtag_speed using RCLK&quot;);
 	}
 	else
@@ -204,8 +204,8 @@
 		}
 
 		LOG_USER(&quot;jtag_speed %d =&gt; JTAG clk=%f&quot;, speed, 64.0/(float)speed);
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x14, 0x100);
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x1c, speed&amp;~1);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x100);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x1c, speed&amp;~1);
 	}
 	return ERROR_OK;
 }
@@ -218,10 +218,10 @@
 	savePower = power;
 	if (power)
 	{
-		HAL_WRITE_UINT32(ZY1000_JTAG_BASE+0x14, 0x8);
+		HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x14, 0x8);
 	} else
 	{
-		HAL_WRITE_UINT32(ZY1000_JTAG_BASE+0x10, 0x8);
+		HAL_WRITE_UINT32(ZY1000_JTAG_BASE + 0x10, 0x8);
 	}
 }
 
@@ -271,7 +271,7 @@
 		if (strcmp(&quot;openocd&quot;, str) == 0)
 		{
 			int revision;
-			revision = atol(ZYLIN_OPENOCD+strlen(&quot;XRevision: &quot;));
+			revision = atol(ZYLIN_OPENOCD + strlen(&quot;XRevision: &quot;));
 			sprintf(buff, &quot;%d&quot;, revision);
 			version_str = buff;
 		}
@@ -307,7 +307,7 @@
 	}
 
 	cyg_uint32 status;
-	ZY1000_PEEK(ZY1000_JTAG_BASE+0x10, status);
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, status);
 
 	Jim_SetResult(interp, Jim_NewIntObj(interp, (status&amp;0x80) != 0));
 
@@ -334,7 +334,7 @@
 {
 	LOG_USER(&quot;%s&quot;, ZYLIN_OPENOCD_VERSION);
 
-	ZY1000_POKE(ZY1000_JTAG_BASE+0x10, 0x30); // Turn on LED1 &amp; LED2
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x10, 0x30); // Turn on LED1 &amp; LED2
 
 	setPower(true); // on by default
 
@@ -359,9 +359,9 @@
 	cyg_uint32 empty;
 
 	waitIdle();
-	ZY1000_PEEK(ZY1000_JTAG_BASE+0x10, empty);
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x10, empty);
 	/* clear JTAG error register */
-	ZY1000_POKE(ZY1000_JTAG_BASE+0x14, 0x400);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x14, 0x400);
 
 	if ((empty&amp;0x400) != 0)
 	{
@@ -382,7 +382,7 @@
 {
 	cyg_uint32 value;
 	waitIdle();
-	ZY1000_PEEK(ZY1000_JTAG_BASE+0xc, value);
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0xc, value);
 	VERBOSE(LOG_INFO(&quot;getShiftValue %08x&quot;, value));
 	return value;
 }
@@ -391,7 +391,7 @@
 {
 	cyg_uint32 value;
 	waitIdle();
-	ZY1000_PEEK(ZY1000_JTAG_BASE+0x18, value);
+	ZY1000_PEEK(ZY1000_JTAG_BASE + 0x18, value);
 	VERBOSE(LOG_INFO(&quot;getShiftValue %08x (flipped)&quot;, value));
 	return value;
 }
@@ -404,8 +404,8 @@
 	cyg_uint32 a,b;
 	a = state;
 	b = endState;
-	ZY1000_POKE(ZY1000_JTAG_BASE+0xc, value);
-	ZY1000_POKE(ZY1000_JTAG_BASE+0x8, (1 &lt;&lt; 15)|(repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0xc, value);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x8, (1 &lt;&lt; 15)|(repeat &lt;&lt; 8)|(a &lt;&lt; 4)|b);
 	VERBOSE(getShiftValueFlip());
 }
 #endif
@@ -450,14 +450,14 @@
 				pause_state = end_state;
 			}
 
-			// we have (num_bits+7)/8 bytes of bits to toggle out.
+			// we have (num_bits + 7)/8 bytes of bits to toggle out.
 			// bits are pushed out LSB to MSB
 			value = 0;
 			if (fields[i].out_value != NULL)
 			{
 				for (l = 0; l&lt;k; l += 8)
 				{
-					value|=fields[i].out_value[(j+l)/8]&lt;&lt;l;
+					value|=fields[i].out_value[(j + l)/8]&lt;&lt;l;
 				}
 			}
 			/* mask away unused bits for easier debugging */
@@ -474,7 +474,7 @@
 
 				for (l = 0; l&lt;k; l += 8)
 				{
-					inBuffer[(j+l)/8]=(value &gt;&gt; l)&amp;0xff;
+					inBuffer[(j + l)/8]=(value &gt;&gt; l)&amp;0xff;
 				}
 			}
 			j += k;
@@ -517,7 +517,7 @@
 			{
 				found = 1;
 
-				scanFields(1, fields+j, TAP_IRSHIFT, end_state);
+				scanFields(1, fields + j, TAP_IRSHIFT, end_state);
 				/* update device information */
 				buf_cpy(fields[j].out_value, tap-&gt;cur_instr, scan_size);
 
@@ -582,7 +582,7 @@
 			{
 				found = 1;
 
-				scanFields(1, fields+j, TAP_DRSHIFT, end_state);
+				scanFields(1, fields + j, TAP_DRSHIFT, end_state);
 			}
 		}
 		if (!found)
@@ -659,10 +659,10 @@
 	{
 		tms = (tms_scan &gt;&gt; i) &amp; 1;
 		waitIdle();
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x28,  tms);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28,  tms);
 	}
 	waitIdle();
-	ZY1000_POKE(ZY1000_JTAG_BASE+0x20, state);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, state);
 #endif
 
 
@@ -714,7 +714,7 @@
 		}
 
 		waitIdle();
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x28,  tms);
+		ZY1000_POKE(ZY1000_JTAG_BASE + 0x28,  tms);
 
 		cur_state = path[state_count];
 		state_count++;
@@ -722,7 +722,7 @@
 	}
 
 	waitIdle();
-	ZY1000_POKE(ZY1000_JTAG_BASE+0x20,  cur_state);
+	ZY1000_POKE(ZY1000_JTAG_BASE + 0x20,  cur_state);
 	return ERROR_OK;
 }
 

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/server/gdb_server.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -345,7 +345,7 @@
 		if ((size_t)len + 4 &lt;= sizeof(local_buffer))
 		{
 			/* performance gain on smaller packets by only a single call to gdb_write() */
-			memcpy(local_buffer+1, buffer, len++);
+			memcpy(local_buffer + 1, buffer, len++);
 			local_buffer[len++] = '#';
 			local_buffer[len++] = DIGITS[(my_checksum &gt;&gt; 4) &amp; 0xf];
 			local_buffer[len++] = DIGITS[my_checksum &amp; 0xf];
@@ -369,7 +369,7 @@
 			{
 				return retval;
 			}
-			if ((retval = gdb_write(connection, local_buffer+1, 3)) != ERROR_OK)
+			if ((retval = gdb_write(connection, local_buffer + 1, 3)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -461,7 +461,7 @@
 		 * We need to leave at least 2 bytes in the buffer to have
 		 * gdb_get_char() update various bits and bobs correctly.
 		 */
-		if ((gdb_con-&gt;buf_cnt &gt; 2) &amp;&amp; ((gdb_con-&gt;buf_cnt+count) &lt; *len))
+		if ((gdb_con-&gt;buf_cnt &gt; 2) &amp;&amp; ((gdb_con-&gt;buf_cnt + count) &lt; *len))
 		{
 			/* The compiler will struggle a bit with constant propagation and
 			 * aliasing, so we help it by showing that these values do not
@@ -651,7 +651,7 @@
 	hex_buffer[0] = 'O';
 	for (i = 0; i&lt;bin_size; i++)
 		snprintf(hex_buffer + 1 + i*2, 3, &quot;%2.2x&quot;, line[i]);
-	hex_buffer[bin_size*2+1] = 0;
+	hex_buffer[bin_size*2 + 1] = 0;
 
 	int retval = gdb_put_packet(connection, hex_buffer, bin_size*2 + 1);
 
@@ -894,7 +894,7 @@
 	{
 		int j = gdb_reg_pos(target, i, buf_len);
 		tstr[i*2]   = DIGITS[(buf[j]&gt;&gt;4) &amp; 0xf];
-		tstr[i*2+1] = DIGITS[buf[j]&amp;0xf];
+		tstr[i*2 + 1] = DIGITS[buf[j]&amp;0xf];
 	}
 }
 
@@ -926,7 +926,7 @@
 	for (i = 0; i &lt; str_len; i += 2)
 	{
 		uint8_t t = hextoint(tstr[i]) &lt;&lt; 4;
-		t |= hextoint(tstr[i+1]);
+		t |= hextoint(tstr[i + 1]);
 
 		int j = gdb_reg_pos(target, i/2, str_len/2);
 		bin[j] = t;
@@ -1182,7 +1182,7 @@
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	len = strtoul(separator+1, NULL, 16);
+	len = strtoul(separator + 1, NULL, 16);
 
 	buffer = malloc(len);
 
@@ -1256,7 +1256,7 @@
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	len = strtoul(separator+1, &amp;separator, 16);
+	len = strtoul(separator + 1, &amp;separator, 16);
 
 	if (*(separator++) != ':')
 	{
@@ -1310,7 +1310,7 @@
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	len = strtoul(separator+1, &amp;separator, 16);
+	len = strtoul(separator + 1, &amp;separator, 16);
 
 	if (*(separator++) != ':')
 	{
@@ -1408,7 +1408,7 @@
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	address = strtoul(separator+1, &amp;separator, 16);
+	address = strtoul(separator + 1, &amp;separator, 16);
 
 	if (*separator != ',')
 	{
@@ -1416,7 +1416,7 @@
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	size = strtoul(separator+1, &amp;separator, 16);
+	size = strtoul(separator + 1, &amp;separator, 16);
 
 	switch (type)
 	{
@@ -1533,7 +1533,7 @@
 	if (*separator != ',')
 		return -1;
 
-	*len = strtoul(separator+1, NULL, 16);
+	*len = strtoul(separator + 1, NULL, 16);
 
 	return 0;
 }
@@ -1736,7 +1736,7 @@
 				&quot;&lt;property name=\&quot;blocksize\&quot;&gt;0x%x&lt;/property&gt;\n&quot; \
 				&quot;&lt;/memory&gt;\n&quot;, \
 				p-&gt;base, p-&gt;size, blocksize);
-			ram_start = p-&gt;base+p-&gt;size;
+			ram_start = p-&gt;base + p-&gt;size;
 		}
 		if (ram_start != 0)
 		{

Modified: trunk/src/server/telnet_server.c
===================================================================
--- trunk/src/server/telnet_server.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/server/telnet_server.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -86,7 +86,7 @@
 		if (line_end)
 		{
 			telnet_write(connection, &quot;\r\n&quot;, 2);
-			line += len+1;
+			line += len + 1;
 		}
 		else
 		{

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/arm11.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -1399,7 +1399,7 @@
 		LOG_DEBUG(&quot;Save %zi: 0x%&quot; PRIx32 &quot;&quot;,i,context[i]);
 	}
 
-	cpsr = buf_get_u32((uint8_t*)(arm11-&gt;reg_values+ARM11_RC_CPSR),0,32);
+	cpsr = buf_get_u32((uint8_t*)(arm11-&gt;reg_values + ARM11_RC_CPSR),0,32);
 	LOG_DEBUG(&quot;Save CPSR: 0x%&quot; PRIx32 &quot;&quot;, cpsr);
 
 	for (int i = 0; i &lt; num_mem_params; i++)

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/arm7_9_common.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -2672,14 +2672,14 @@
 	dcc_count = count;
 	dcc_buffer = buffer;
 	retval = armv4_5_run_algorithm_inner(target, 0, NULL, 1, reg_params,
-			arm7_9-&gt;dcc_working_area-&gt;address, arm7_9-&gt;dcc_working_area-&gt;address+6*4, 20*1000, &amp;armv4_5_info, arm7_9_dcc_completion);
+			arm7_9-&gt;dcc_working_area-&gt;address, arm7_9-&gt;dcc_working_area-&gt;address + 6*4, 20*1000, &amp;armv4_5_info, arm7_9_dcc_completion);
 
 	if (retval == ERROR_OK)
 	{
 		uint32_t endaddress = buf_get_u32(reg_params[0].value, 0, 32);
-		if (endaddress != (address+count*4))
+		if (endaddress != (address + count*4))
 		{
-			LOG_ERROR(&quot;DCC write failed, expected end address 0x%08&quot; PRIx32 &quot; got 0x%0&quot; PRIx32 &quot;&quot;, (address+count*4), endaddress);
+			LOG_ERROR(&quot;DCC write failed, expected end address 0x%08&quot; PRIx32 &quot; got 0x%0&quot; PRIx32 &quot;&quot;, (address + count*4), endaddress);
 			retval = ERROR_FAIL;
 		}
 	}

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/arm7tdmi.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -383,7 +383,7 @@
 	for (i = 0; i &lt;= 15; i++)
 	{
 		if (mask &amp; (1 &lt;&lt; i))
-			/* nothing fetched, STM still in EXECUTE (1+i cycle) */
+			/* nothing fetched, STM still in EXECUTE (1 + i cycle) */
 			arm7tdmi_clock_data_in(jtag_info, core_regs[i]);
 	}
 }
@@ -412,7 +412,7 @@
 
 	for (i = 0; i &lt;= 15; i++)
 	{
-		/* nothing fetched, STM still in EXECUTE (1+i cycle), read databus */
+		/* nothing fetched, STM still in EXECUTE (1 + i cycle), read databus */
 		if (mask &amp; (1 &lt;&lt; i))
 		{
 			switch (size)
@@ -522,7 +522,7 @@
 	for (i = 0; i &lt;= 15; i++)
 	{
 		if (mask &amp; (1 &lt;&lt; i))
-			/* nothing fetched, LDM still in EXECUTE (1+i cycle) */
+			/* nothing fetched, LDM still in EXECUTE (1 + i cycle) */
 			arm7tdmi_clock_out_inner(jtag_info, core_regs[i], 0);
 	}
 	arm7tdmi_clock_out_inner(jtag_info, ARMV4_5_NOP, 0);

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/arm9tdmi.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -587,7 +587,7 @@
 	for (i = 0; i &lt;= 15; i++)
 	{
 		if (mask &amp; (1 &lt;&lt; i))
-			/* nothing fetched, LDM still in EXECUTE (1+i cycle) */
+			/* nothing fetched, LDM still in EXECUTE (1 + i cycle) */
 			arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, core_regs[i], NULL, 0);
 	}
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);

Modified: trunk/src/target/arm_adi_v5.c
===================================================================
--- trunk/src/target/arm_adi_v5.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/arm_adi_v5.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -1093,7 +1093,7 @@
 			if (romentry&amp;0x01)
 			{
 				uint32_t c_cid0,c_cid1,c_cid2,c_cid3,c_pid0,c_pid1,c_pid2,c_pid3,c_pid4,component_start;
-				uint32_t component_base = (uint32_t)((dbgbase&amp;0xFFFFF000)+(int)(romentry&amp;0xFFFFF000));
+				uint32_t component_base = (uint32_t)((dbgbase&amp;0xFFFFF000) + (int)(romentry&amp;0xFFFFF000));
 				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE0, &amp;c_pid0);
 				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE4, &amp;c_pid1);
 				mem_ap_read_atomic_u32(swjdp, (component_base&amp;0xFFFFF000)|0xFE8, &amp;c_pid2);

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/armv4_5.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -71,7 +71,7 @@
 };
 
 /* Hack! Yuk! allow -1 index, which simplifies codepaths elsewhere in the code */
-char** armv4_5_mode_strings = armv4_5_mode_strings_list+1;
+char** armv4_5_mode_strings = armv4_5_mode_strings_list + 1;
 
 char* armv4_5_state_strings[] =
 {

Modified: trunk/src/target/etb.c
===================================================================
--- trunk/src/target/etb.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/etb.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -204,10 +204,10 @@
 		else
 			buf_set_u32(fields[1].out_value, 0, 7, 0);
 
-		fields[0].in_value = (uint8_t *)(data+i);
+		fields[0].in_value = (uint8_t *)(data + i);
 		jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-		jtag_add_callback(etb_getbuf, (jtag_callback_data_t)(data+i));
+		jtag_add_callback(etb_getbuf, (jtag_callback_data_t)(data + i));
 	}
 
 	jtag_execute_queue();
@@ -550,32 +550,32 @@
 				etm_ctx-&gt;trace_data[j].flags |= ETMV1_TRIGGER_CYCLE;
 			}
 
-			/* trace word j+1 */
-			etm_ctx-&gt;trace_data[j+1].pipestat = (trace_data[i] &amp; 0x100) &gt;&gt; 8;
-			etm_ctx-&gt;trace_data[j+1].packet = (trace_data[i] &amp; 0x7800) &gt;&gt; 11;
-			etm_ctx-&gt;trace_data[j+1].flags = 0;
+			/* trace word j + 1 */
+			etm_ctx-&gt;trace_data[j + 1].pipestat = (trace_data[i] &amp; 0x100) &gt;&gt; 8;
+			etm_ctx-&gt;trace_data[j + 1].packet = (trace_data[i] &amp; 0x7800) &gt;&gt; 11;
+			etm_ctx-&gt;trace_data[j + 1].flags = 0;
 			if ((trace_data[i] &amp; 0x8000) &gt;&gt; 15)
 			{
-				etm_ctx-&gt;trace_data[j+1].flags |= ETMV1_TRACESYNC_CYCLE;
+				etm_ctx-&gt;trace_data[j + 1].flags |= ETMV1_TRACESYNC_CYCLE;
 			}
-			if (etm_ctx-&gt;trace_data[j+1].pipestat == STAT_TR)
+			if (etm_ctx-&gt;trace_data[j + 1].pipestat == STAT_TR)
 			{
-				etm_ctx-&gt;trace_data[j+1].pipestat = etm_ctx-&gt;trace_data[j+1].packet &amp; 0x7;
-				etm_ctx-&gt;trace_data[j+1].flags |= ETMV1_TRIGGER_CYCLE;
+				etm_ctx-&gt;trace_data[j + 1].pipestat = etm_ctx-&gt;trace_data[j + 1].packet &amp; 0x7;
+				etm_ctx-&gt;trace_data[j + 1].flags |= ETMV1_TRIGGER_CYCLE;
 			}
 
-			/* trace word j+2 */
-			etm_ctx-&gt;trace_data[j+2].pipestat = (trace_data[i] &amp; 0x10000) &gt;&gt; 16;
-			etm_ctx-&gt;trace_data[j+2].packet = (trace_data[i] &amp; 0x780000) &gt;&gt; 19;
-			etm_ctx-&gt;trace_data[j+2].flags = 0;
+			/* trace word j + 2 */
+			etm_ctx-&gt;trace_data[j + 2].pipestat = (trace_data[i] &amp; 0x10000) &gt;&gt; 16;
+			etm_ctx-&gt;trace_data[j + 2].packet = (trace_data[i] &amp; 0x780000) &gt;&gt; 19;
+			etm_ctx-&gt;trace_data[j + 2].flags = 0;
 			if ((trace_data[i] &amp; 0x800000) &gt;&gt; 23)
 			{
-				etm_ctx-&gt;trace_data[j+2].flags |= ETMV1_TRACESYNC_CYCLE;
+				etm_ctx-&gt;trace_data[j + 2].flags |= ETMV1_TRACESYNC_CYCLE;
 			}
-			if (etm_ctx-&gt;trace_data[j+2].pipestat == STAT_TR)
+			if (etm_ctx-&gt;trace_data[j + 2].pipestat == STAT_TR)
 			{
-				etm_ctx-&gt;trace_data[j+2].pipestat = etm_ctx-&gt;trace_data[j+2].packet &amp; 0x7;
-				etm_ctx-&gt;trace_data[j+2].flags |= ETMV1_TRIGGER_CYCLE;
+				etm_ctx-&gt;trace_data[j + 2].pipestat = etm_ctx-&gt;trace_data[j + 2].packet &amp; 0x7;
+				etm_ctx-&gt;trace_data[j + 2].flags |= ETMV1_TRIGGER_CYCLE;
 			}
 
 			j += 3;
@@ -596,18 +596,18 @@
 				etm_ctx-&gt;trace_data[j].flags |= ETMV1_TRIGGER_CYCLE;
 			}
 
-			/* trace word j+1 */
-			etm_ctx-&gt;trace_data[j+1].pipestat = (trace_data[i] &amp; 0x7000) &gt;&gt; 12;
-			etm_ctx-&gt;trace_data[j+1].packet = (trace_data[i] &amp; 0x7f8000) &gt;&gt; 15;
-			etm_ctx-&gt;trace_data[j+1].flags = 0;
+			/* trace word j + 1 */
+			etm_ctx-&gt;trace_data[j + 1].pipestat = (trace_data[i] &amp; 0x7000) &gt;&gt; 12;
+			etm_ctx-&gt;trace_data[j + 1].packet = (trace_data[i] &amp; 0x7f8000) &gt;&gt; 15;
+			etm_ctx-&gt;trace_data[j + 1].flags = 0;
 			if ((trace_data[i] &amp; 0x800000) &gt;&gt; 23)
 			{
-				etm_ctx-&gt;trace_data[j+1].flags |= ETMV1_TRACESYNC_CYCLE;
+				etm_ctx-&gt;trace_data[j + 1].flags |= ETMV1_TRACESYNC_CYCLE;
 			}
-			if (etm_ctx-&gt;trace_data[j+1].pipestat == STAT_TR)
+			if (etm_ctx-&gt;trace_data[j + 1].pipestat == STAT_TR)
 			{
-				etm_ctx-&gt;trace_data[j+1].pipestat = etm_ctx-&gt;trace_data[j+1].packet &amp; 0x7;
-				etm_ctx-&gt;trace_data[j+1].flags |= ETMV1_TRIGGER_CYCLE;
+				etm_ctx-&gt;trace_data[j + 1].pipestat = etm_ctx-&gt;trace_data[j + 1].packet &amp; 0x7;
+				etm_ctx-&gt;trace_data[j + 1].flags |= ETMV1_TRIGGER_CYCLE;
 			}
 
 			j += 2;

Modified: trunk/src/target/fa526.c
===================================================================
--- trunk/src/target/fa526.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/fa526.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -269,7 +269,7 @@
 	for (i = 0; i &lt;= 15; i++)
 	{
 		if (mask &amp; (1 &lt;&lt; i))
-			/* nothing fetched, LDM still in EXECUTE (1+i cycle) */
+			/* nothing fetched, LDM still in EXECUTE (1 + i cycle) */
 			arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, core_regs[i], NULL, 0);
 	}
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);

Modified: trunk/src/target/image.c
===================================================================
--- trunk/src/target/image.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/image.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -454,9 +454,9 @@
 		/* maximal size present in file for the current segment */
 		read_size = MIN(size, field32(elf,segment-&gt;p_filesz)-offset);
 		LOG_DEBUG(&quot;read elf: size = 0x%&quot; PRIx32 &quot; at 0x%&quot; PRIx32 &quot;&quot;,read_size,
-			field32(elf,segment-&gt;p_offset)+offset);
+			field32(elf,segment-&gt;p_offset) + offset);
 		/* read initialized area of the segment */
-		if ((retval = fileio_seek(&amp;elf-&gt;fileio, field32(elf,segment-&gt;p_offset)+offset)) != ERROR_OK)
+		if ((retval = fileio_seek(&amp;elf-&gt;fileio, field32(elf,segment-&gt;p_offset) + offset)) != ERROR_OK)
 		{
 			LOG_ERROR(&quot;cannot find ELF segment content, seek failed&quot;);
 			return retval;

Modified: trunk/src/target/mips32_dmaacc.c
===================================================================
--- trunk/src/target/mips32_dmaacc.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/mips32_dmaacc.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -370,7 +370,7 @@
 	int	retval;
 
 	for (i = 0; i&lt;count; i++) {
-		if ((retval = ejtag_dma_read(ejtag_info, addr+i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
+		if ((retval = ejtag_dma_read(ejtag_info, addr + i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
 			return retval;
 	}
 
@@ -383,7 +383,7 @@
 	int retval;
 
 	for (i = 0; i&lt;count; i++) {
-		if ((retval = ejtag_dma_read_h(ejtag_info, addr+i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
+		if ((retval = ejtag_dma_read_h(ejtag_info, addr + i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
 			return retval;
 	}
 
@@ -396,7 +396,7 @@
 	int retval;
 
 	for (i = 0; i&lt;count; i++) {
-		if ((retval = ejtag_dma_read_b(ejtag_info, addr+i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
+		if ((retval = ejtag_dma_read_b(ejtag_info, addr + i*sizeof(*buf), &amp;buf[i])) != ERROR_OK)
 			return retval;
 	}
 
@@ -424,7 +424,7 @@
 	int retval;
 
 	for (i = 0; i&lt;count; i++) {
-		if ((retval = ejtag_dma_write(ejtag_info, addr+i*sizeof(*buf), buf[i])) != ERROR_OK)
+		if ((retval = ejtag_dma_write(ejtag_info, addr + i*sizeof(*buf), buf[i])) != ERROR_OK)
 			return retval;
 	}
 
@@ -437,7 +437,7 @@
 	int retval;
 
 	for (i = 0; i&lt;count; i++) {
-		if ((retval = ejtag_dma_write_h(ejtag_info, addr+i*sizeof(*buf), buf[i])) != ERROR_OK)
+		if ((retval = ejtag_dma_write_h(ejtag_info, addr + i*sizeof(*buf), buf[i])) != ERROR_OK)
 			return retval;
 	}
 
@@ -450,7 +450,7 @@
 	int retval;
 
 	for (i = 0; i&lt;count; i++) {
-		if ((retval = ejtag_dma_write_b(ejtag_info, addr+i*sizeof(*buf), buf[i])) != ERROR_OK)
+		if ((retval = ejtag_dma_write_b(ejtag_info, addr + i*sizeof(*buf), buf[i])) != ERROR_OK)
 			return retval;
 	}
 

Modified: trunk/src/target/mips32_pracc.c
===================================================================
--- trunk/src/target/mips32_pracc.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/mips32_pracc.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -302,7 +302,7 @@
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8),									/* $9 = mem[$8]; read addr */
-		MIPS32_LW(10,4,8),									/* $10 = mem[$8+4]; read count */
+		MIPS32_LW(10,4,8),									/* $10 = mem[$8 + 4]; read count */
 		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)), 	/* $11 = MIPS32_PRACC_PARAM_OUT */
 		MIPS32_ORI(11,11,LOWER16(MIPS32_PRACC_PARAM_OUT)),
 		MIPS32_NOP,
@@ -410,7 +410,7 @@
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)),		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8),									/* $9 = mem[$8]; read addr */
-		MIPS32_LW(10,4,8),									/* $10 = mem[$8+4]; read count */
+		MIPS32_LW(10,4,8),									/* $10 = mem[$8 + 4]; read count */
 		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)),		/* $11 = MIPS32_PRACC_PARAM_OUT */
 		MIPS32_ORI(11,11,LOWER16(MIPS32_PRACC_PARAM_OUT)),
 		MIPS32_NOP,
@@ -489,7 +489,7 @@
 		MIPS32_LUI(8,UPPER16(MIPS32_PRACC_PARAM_IN)), 		/* $8 = MIPS32_PRACC_PARAM_IN */
 		MIPS32_ORI(8,8,LOWER16(MIPS32_PRACC_PARAM_IN)),
 		MIPS32_LW(9,0,8), 									/* $9 = mem[$8]; read addr */
-		MIPS32_LW(10,4,8), 									/* $10 = mem[$8+4]; read count */
+		MIPS32_LW(10,4,8), 									/* $10 = mem[$8 + 4]; read count */
 		MIPS32_LUI(11,UPPER16(MIPS32_PRACC_PARAM_OUT)), 	/* $11 = MIPS32_PRACC_PARAM_OUT */
 		MIPS32_ORI(11,11,LOWER16(MIPS32_PRACC_PARAM_OUT)),
 		MIPS32_NOP,
@@ -608,7 +608,7 @@
 	};
 	
 	/* TODO remove array */
-	uint32_t param_in[count+2];
+	uint32_t param_in[count + 2];
 	param_in[0] = addr;
 	param_in[1] = addr + count * sizeof(uint32_t);	//last address
     
@@ -643,7 +643,7 @@
 	};
 
 	/* TODO remove array */
-	uint32_t param_in[1+1];
+	uint32_t param_in[1 + 1];
 	param_in[0] = addr;
 	param_in[1] = *buf;
 
@@ -697,14 +697,14 @@
 	};
 	
 	/* TODO remove array */
-	uint32_t param_in[count+2];
+	uint32_t param_in[count + 2];
 	int i;
 	param_in[0] = addr;
 	param_in[1] = count;
 	
 	for (i = 0; i &lt; count; i++)
 	{
-		param_in[i+2] = buf[i];
+		param_in[i + 2] = buf[i];
 	}
 	
 	mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \
@@ -757,7 +757,7 @@
 	};
 	
 	/* TODO remove array */
-	uint32_t param_in[count+2];
+	uint32_t param_in[count + 2];
 	int retval;
 	int i;
 	param_in[0] = addr;
@@ -765,7 +765,7 @@
 	
 	for (i = 0; i &lt; count; i++)
 	{
-		param_in[i+2] = buf[i];
+		param_in[i + 2] = buf[i];
 	}
 	
 	retval = mips32_pracc_exec(ejtag_info, sizeof(code)/sizeof(code[0]), code, \

Modified: trunk/src/target/oocd_trace.c
===================================================================
--- trunk/src/target/oocd_trace.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/oocd_trace.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -197,7 +197,7 @@
 		num_frames = address;
 
 	/* read data into temporary array for unpacking
-	 * one frame from OpenOCD+trace corresponds to 16 trace cycles
+	 * one frame from OpenOCD + trace corresponds to 16 trace cycles
 	 */
 	trace_data = malloc(sizeof(uint8_t) * num_frames * 16);
 	oocd_trace_read_memory(oocd_trace, trace_data, first_frame, num_frames);
@@ -242,7 +242,7 @@
 	if (((etm_ctx-&gt;portmode &amp; ETM_PORT_MODE_MASK) != ETM_PORT_NORMAL)
 		|| ((etm_ctx-&gt;portmode &amp; ETM_PORT_WIDTH_MASK) != ETM_PORT_4BIT))
 	{
-		LOG_DEBUG(&quot;OpenOCD+trace only supports normal 4-bit ETM mode&quot;);
+		LOG_DEBUG(&quot;OpenOCD + trace only supports normal 4-bit ETM mode&quot;);
 		return ERROR_ETM_PORTMODE_NOT_SUPPORTED;
 	}
 
@@ -251,7 +251,7 @@
 		control |= 0x2;	/* half rate clock, capture at twice the clock rate */
 	}
 
-	/* OpenOCD+trace holds up to 16 million samples,
+	/* OpenOCD + trace holds up to 16 million samples,
 	 * but trigger counts is set in multiples of 16 */
 	trigger_count = (1048576 * etm_ctx-&gt;trigger_percent) / 100;
 
@@ -316,12 +316,12 @@
 		arm7_9-&gt;etm_ctx-&gt;capture_driver_priv = oocd_trace;
 		oocd_trace-&gt;etm_ctx = arm7_9-&gt;etm_ctx;
 
-		/* copy name of TTY device used to communicate with OpenOCD+trace */
+		/* copy name of TTY device used to communicate with OpenOCD + trace */
 		oocd_trace-&gt;tty = strndup(args[1], 256);
 	}
 	else
 	{
-		LOG_ERROR(&quot;target has no ETM defined, OpenOCD+trace left unconfigured&quot;);
+		LOG_ERROR(&quot;target has no ETM defined, OpenOCD + trace left unconfigured&quot;);
 	}
 
 	return ERROR_OK;
@@ -412,12 +412,12 @@
 {
 	command_t *oocd_trace_cmd;
 
-	oocd_trace_cmd = register_command(cmd_ctx, NULL, &quot;oocd_trace&quot;, NULL, COMMAND_ANY, &quot;OpenOCD+trace&quot;);
+	oocd_trace_cmd = register_command(cmd_ctx, NULL, &quot;oocd_trace&quot;, NULL, COMMAND_ANY, &quot;OpenOCD + trace&quot;);
 
 	register_command(cmd_ctx, oocd_trace_cmd, &quot;config&quot;, handle_oocd_trace_config_command, COMMAND_CONFIG, NULL);
 
-	register_command(cmd_ctx, oocd_trace_cmd, &quot;status&quot;, handle_oocd_trace_status_command, COMMAND_EXEC, &quot;display OpenOCD+trace status&quot;);
-	register_command(cmd_ctx, oocd_trace_cmd, &quot;resync&quot;, handle_oocd_trace_resync_command, COMMAND_EXEC, &quot;resync OpenOCD+trace capture clock&quot;);
+	register_command(cmd_ctx, oocd_trace_cmd, &quot;status&quot;, handle_oocd_trace_status_command, COMMAND_EXEC, &quot;display OpenOCD + trace status&quot;);
+	register_command(cmd_ctx, oocd_trace_cmd, &quot;resync&quot;, handle_oocd_trace_resync_command, COMMAND_EXEC, &quot;resync OpenOCD + trace capture clock&quot;);
 
 	return ERROR_OK;
 }

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/target.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -246,7 +246,7 @@
 	t = all_targets;
 	while ( t ){
 		if ( x &lt; t-&gt;target_number ){
-			x = (t-&gt;target_number)+1;
+			x = (t-&gt;target_number) + 1;
 		}
 		t = t-&gt;next;
 	}
@@ -268,7 +268,7 @@
 		}
 		t = t-&gt;next;
 	}
-	return x+1;
+	return x + 1;
 }
 
 static int target_continuous_poll = 1;
@@ -492,7 +492,7 @@
 }
 
 
-/* Targets that correctly implement init+examine, i.e.
+/* Targets that correctly implement init + examine, i.e.
  * no communication with target during init:
  *
  * XScale
@@ -1118,7 +1118,7 @@
 	if ((address + size - 1) &lt; address)
 	{
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR(&quot;address+size wrapped(0x%08x, 0x%08x)&quot;, 
+		LOG_ERROR(&quot;address + size wrapped(0x%08x, 0x%08x)&quot;, 
 				  (unsigned)address, 
 				  (unsigned)size);
 		return ERROR_FAIL;
@@ -1200,7 +1200,7 @@
 	if ((address + size - 1) &lt; address)
 	{
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR(&quot;address+size wrapped(0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;)&quot;, 
+		LOG_ERROR(&quot;address + size wrapped(0x%08&quot; PRIx32 &quot;, 0x%08&quot; PRIx32 &quot;)&quot;, 
 				  address, 
 				  size);
 		return ERROR_FAIL;
@@ -2279,7 +2279,7 @@
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
-		if ((image.sections[i].base_address+buf_cnt &gt;= min_address)&amp;&amp;
+		if ((image.sections[i].base_address + buf_cnt &gt;= min_address)&amp;&amp;
 				(image.sections[i].base_address&lt;max_address))
 		{
 			if (image.sections[i].base_address&lt;min_address)
@@ -2289,12 +2289,12 @@
 				length -= offset;
 			}
 
-			if (image.sections[i].base_address+buf_cnt&gt;max_address)
+			if (image.sections[i].base_address + buf_cnt&gt;max_address)
 			{
-				length -= (image.sections[i].base_address+buf_cnt)-max_address;
+				length -= (image.sections[i].base_address + buf_cnt)-max_address;
 			}
 
-			if ((retval = target_write_buffer(target, image.sections[i].base_address+offset, length, buffer+offset)) != ERROR_OK)
+			if ((retval = target_write_buffer(target, image.sections[i].base_address + offset, length, buffer + offset)) != ERROR_OK)
 			{
 				free(buffer);
 				break;
@@ -2302,7 +2302,7 @@
 			image_size += length;
 			command_print(cmd_ctx, &quot;%u byte written at address 0x%8.8&quot; PRIx32 &quot;&quot;, 
 						  (unsigned int)length, 
-						  image.sections[i].base_address+offset);
+						  image.sections[i].base_address + offset);
 		}
 
 		free(buffer);
@@ -2834,7 +2834,7 @@
 		}
 	}
 
-	int addressSpace = (max-min+1);
+	int addressSpace = (max-min + 1);
 
 	static const uint32_t maxBuckets = 256 * 1024; /* maximum buckets. */
 	uint32_t length = addressSpace;
@@ -2883,7 +2883,7 @@
 				val = 65535;
 			}
 			data[i*2]=val&amp;0xff;
-			data[i*2+1]=(val &gt;&gt; 8)&amp;0xff;
+			data[i*2 + 1]=(val &gt;&gt; 8)&amp;0xff;
 		}
 		free(buckets);
 		writeData(f, data, length * 2);
@@ -3028,7 +3028,7 @@
 		return JIM_ERR;
 	}
 
-	return 	target_mem2array(interp, target, argc-1, argv+1);
+	return 	target_mem2array(interp, target, argc-1, argv + 1);
 }
 
 static int target_mem2array(Jim_Interp *interp, target_t *target, int argc, Jim_Obj *const *argv)
@@ -3215,7 +3215,7 @@
 		return JIM_ERR;
 	}
 
-	return target_array2mem( interp,target, argc-1, argv+1 );
+	return target_array2mem( interp,target, argc-1, argv + 1 );
 }
 
 static int target_array2mem(Jim_Interp *interp, target_t *target, int argc, Jim_Obj *const *argv)
@@ -3749,7 +3749,7 @@
 	};
 
 	/* go past the &quot;command&quot; */
-	Jim_GetOpt_Setup( &amp;goi, interp, argc-1, argv+1 );
+	Jim_GetOpt_Setup( &amp;goi, interp, argc-1, argv + 1 );
 
 	target = Jim_CmdPrivData( goi.interp );
 	cmd_ctx = Jim_GetAssocData(goi.interp, &quot;context&quot;);
@@ -4141,7 +4141,7 @@
 	if ( target_types[x] == NULL ){
 		Jim_SetResult_sprintf( goi-&gt;interp, &quot;Unknown target type %s, try one of &quot;, cp );
 		for ( x = 0 ; target_types[x] ; x++ ){
-			if ( target_types[x+1] ){
+			if ( target_types[x + 1] ){
 				Jim_AppendStrings( goi-&gt;interp,
 								   Jim_GetResult(goi-&gt;interp),
 								   target_types[x]-&gt;name,
@@ -4283,7 +4283,7 @@
 
 	cmd_ctx = Jim_GetAssocData( interp, &quot;context&quot; );
 
-	Jim_GetOpt_Setup( &amp;goi, interp, argc-1, argv+1 );
+	Jim_GetOpt_Setup( &amp;goi, interp, argc-1, argv + 1 );
 
 	if ( goi.argc == 0 ){
 		Jim_WrongNumArgs(interp, 1, argv, &quot;missing: command ...&quot;);
@@ -4460,7 +4460,7 @@
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
-		if ((image.sections[i].base_address+buf_cnt &gt;= min_address)&amp;&amp;
+		if ((image.sections[i].base_address + buf_cnt &gt;= min_address)&amp;&amp;
 				(image.sections[i].base_address&lt;max_address))
 		{
 			if (image.sections[i].base_address&lt;min_address)
@@ -4470,25 +4470,25 @@
 				length -= offset;
 			}
 
-			if (image.sections[i].base_address+buf_cnt&gt;max_address)
+			if (image.sections[i].base_address + buf_cnt&gt;max_address)
 			{
-				length -= (image.sections[i].base_address+buf_cnt)-max_address;
+				length -= (image.sections[i].base_address + buf_cnt)-max_address;
 			}
 
-			fastload[i].address = image.sections[i].base_address+offset;
+			fastload[i].address = image.sections[i].base_address + offset;
 			fastload[i].data = malloc(length);
 			if (fastload[i].data == NULL)
 			{
 				free(buffer);
 				break;
 			}
-			memcpy(fastload[i].data, buffer+offset, length);
+			memcpy(fastload[i].data, buffer + offset, length);
 			fastload[i].length = length;
 
 			image_size += length;
 			command_print(cmd_ctx, &quot;%u byte written at address 0x%8.8x&quot;, 
 						  (unsigned int)length, 
-						  ((unsigned int)(image.sections[i].base_address+offset)));
+						  ((unsigned int)(image.sections[i].base_address + offset)));
 		}
 
 		free(buffer);

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/target/xscale.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -264,8 +264,8 @@
 
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-	jtag_check_value_mask(fields+0, &amp;field0_check_value, &amp;field0_check_mask);
-	jtag_check_value_mask(fields+2, &amp;field2_check_value, &amp;field2_check_mask);
+	jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
+	jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -362,11 +362,11 @@
 
 			jtag_add_pathmove(3, path);
 
-			fields[1].in_value = (uint8_t *)(field1+i);
+			fields[1].in_value = (uint8_t *)(field1 + i);
 
 			jtag_add_dr_scan_check(3, fields, jtag_set_end_state(TAP_IDLE));
 
-			jtag_add_callback(xscale_getbuf, (jtag_callback_data_t)(field1+i));
+			jtag_add_callback(xscale_getbuf, (jtag_callback_data_t)(field1 + i));
 
 			words_scheduled++;
 		}
@@ -386,8 +386,8 @@
 				int j;
 				for (j = i; j &lt; num_words - 1; j++)
 				{
-					field0[j] = field0[j+1];
-					field1[j] = field1[j+1];
+					field0[j] = field0[j + 1];
+					field1[j] = field1[j + 1];
 				}
 				words_scheduled--;
 			}
@@ -480,8 +480,8 @@
 
 		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
 
-		jtag_check_value_mask(fields+0, &amp;field0_check_value, &amp;field0_check_mask);
-		jtag_check_value_mask(fields+2, &amp;field2_check_value, &amp;field2_check_mask);
+		jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
+		jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
 
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
@@ -563,8 +563,8 @@
 	{
 		jtag_add_dr_scan(3, fields, jtag_set_end_state(TAP_IDLE));
 
-		jtag_check_value_mask(fields+0, &amp;field0_check_value, &amp;field0_check_mask);
-		jtag_check_value_mask(fields+2, &amp;field2_check_value, &amp;field2_check_mask);
+		jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
+		jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
 
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
@@ -728,8 +728,8 @@
 
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-	jtag_check_value_mask(fields+0, &amp;field0_check_value, &amp;field0_check_mask);
-	jtag_check_value_mask(fields+2, &amp;field2_check_value, &amp;field2_check_mask);
+	jtag_check_value_mask(fields + 0, &amp;field0_check_value, &amp;field0_check_mask);
+	jtag_check_value_mask(fields + 2, &amp;field2_check_value, &amp;field2_check_mask);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{

Modified: trunk/src/xsvf/xsvf.c
===================================================================
--- trunk/src/xsvf/xsvf.c	2009-06-23 22:42:54 UTC (rev 2372)
+++ trunk/src/xsvf/xsvf.c	2009-06-23 22:44:17 UTC (rev 2373)
@@ -82,7 +82,7 @@
 
 ! Set the maximum loop count to 25.
 LCOUNT	25;
-! Step to DRPAUSE give 5 clocks and wait for 1.00e+000 SEC.
+! Step to DRPAUSE give 5 clocks and wait for 1.00e + 000 SEC.
 LDELAY	DRPAUSE	5 TCK	1.00E-003 SEC;
 ! Test for the completed status. Match means pass.
 ! Loop back to LDELAY line if not match and loop count less than 25.
@@ -605,7 +605,7 @@
 					LOG_DEBUG(&quot;XSIR2 %d&quot;, bitcount);
 				}
 
-				ir_buf = malloc((bitcount+7) / 8);
+				ir_buf = malloc((bitcount + 7) / 8);
 
 				if (xsvf_read_buffer(bitcount, xsvf_fd, ir_buf) != ERROR_OK)
 					do_abort = 1;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001156.html">[Openocd-svn] r2372 - in trunk: src src/flash	src/flash/ocl/at91sam7x src/helper src/jtag	src/jtag/minidummy src/jtag/rlink src/jtag/zy1000 src/pld	src/server src/target src/xsvf testing/examples/cortex
</A></li>
	<LI>Next message: <A HREF="001158.html">[Openocd-svn] r2374 - in trunk/src: . flash flash/ocl/at91sam7x	helper jtag jtag/zy1000 target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1157">[ date ]</a>
              <a href="thread.html#1157">[ thread ]</a>
              <a href="subject.html#1157">[ subject ]</a>
              <a href="author.html#1157">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
