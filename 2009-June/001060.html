<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2276 - in trunk/src: helper jtag jtag/minidummy	jtag/rlink jtag/zy1000 pld server svf xsvf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2276%20-%20in%20trunk/src%3A%20helper%20jtag%20jtag/minidummy%0A%09jtag/rlink%20jtag/zy1000%20pld%20server%20svf%20xsvf&In-Reply-To=%3C200906180707.n5I77tUO015838%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001059.html">
   <LINK REL="Next"  HREF="001061.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2276 - in trunk/src: helper jtag jtag/minidummy	jtag/rlink jtag/zy1000 pld server svf xsvf</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2276%20-%20in%20trunk/src%3A%20helper%20jtag%20jtag/minidummy%0A%09jtag/rlink%20jtag/zy1000%20pld%20server%20svf%20xsvf&In-Reply-To=%3C200906180707.n5I77tUO015838%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2276 - in trunk/src: helper jtag jtag/minidummy	jtag/rlink jtag/zy1000 pld server svf xsvf">zwelch at mail.berlios.de
       </A><BR>
    <I>Thu Jun 18 09:07:55 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001059.html">[Openocd-svn] r2275 - trunk/src/flash
</A></li>
        <LI>Next message: <A HREF="001061.html">[Openocd-svn] r2277 - in trunk/src: flash helper jtag jtag/rlink	target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1060">[ date ]</a>
              <a href="thread.html#1060">[ thread ]</a>
              <a href="subject.html#1060">[ subject ]</a>
              <a href="author.html#1060">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-18 09:07:12 +0200 (Thu, 18 Jun 2009)
New Revision: 2276

Modified:
   trunk/src/helper/binarybuffer.c
   trunk/src/helper/binarybuffer.h
   trunk/src/helper/fileio.c
   trunk/src/helper/fileio.h
   trunk/src/helper/types.h
   trunk/src/jtag/amt_jtagaccel.c
   trunk/src/jtag/arm-jtag-ew.c
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/bitq.c
   trunk/src/jtag/commands.c
   trunk/src/jtag/commands.h
   trunk/src/jtag/core.c
   trunk/src/jtag/driver.c
   trunk/src/jtag/ep93xx.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/gw16012.c
   trunk/src/jtag/interface.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/minidriver.h
   trunk/src/jtag/minidummy/minidummy.c
   trunk/src/jtag/parport.c
   trunk/src/jtag/presto.c
   trunk/src/jtag/rlink/rlink.c
   trunk/src/jtag/rlink/rlink.h
   trunk/src/jtag/rlink/rlink_speed_table.c
   trunk/src/jtag/usbprog.c
   trunk/src/jtag/vsllink.c
   trunk/src/jtag/zy1000/zy1000.c
   trunk/src/pld/virtex2.c
   trunk/src/pld/xilinx_bit.c
   trunk/src/pld/xilinx_bit.h
   trunk/src/server/gdb_server.c
   trunk/src/svf/svf.c
   trunk/src/xsvf/xsvf.c
Log:
Transform 'u8' to 'uint8_t'
- Replace '\([^_]\)u8' with '\1uint8_t'.
- Replace '^u8' with 'uint8_t'.


Modified: trunk/src/helper/binarybuffer.c
===================================================================
--- trunk/src/helper/binarybuffer.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/helper/binarybuffer.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -48,7 +48,7 @@
 };
 
 
-u8* buf_cpy(const u8 *from, u8 *to, int size)
+uint8_t* buf_cpy(const uint8_t *from, uint8_t *to, int size)
 {
 	unsigned int num_bytes = CEIL(size, 8);
 	unsigned int i;
@@ -68,7 +68,7 @@
 	return to;
 }
 
-int buf_cmp(const u8 *buf1, const u8 *buf2, int size)
+int buf_cmp(const uint8_t *buf1, const uint8_t *buf2, int size)
 {
 	int num_bytes = CEIL(size, 8);
 	int i;
@@ -95,7 +95,7 @@
 	return 0;
 }
 
-int buf_cmp_mask(const u8 *buf1, const u8 *buf2, const u8 *mask, int size)
+int buf_cmp_mask(const uint8_t *buf1, const uint8_t *buf2, const uint8_t *mask, int size)
 {
 	int num_bytes = CEIL(size, 8);
 	int i;
@@ -120,7 +120,7 @@
 	return 0;
 }
 
-u8* buf_set_ones(u8 *buf, int count)
+uint8_t* buf_set_ones(uint8_t *buf, int count)
 {
 	int num_bytes = CEIL(count, 8);
 	int i;
@@ -138,7 +138,7 @@
 	return buf;
 }
 
-u8* buf_set_buf(const u8 *src, int src_start, u8 *dst, int dst_start, int len)
+uint8_t* buf_set_buf(const uint8_t *src, int src_start, uint8_t *dst, int dst_start, int len)
 {
 	int src_idx = src_start, dst_idx = dst_start;
 	int i;
@@ -186,7 +186,7 @@
 	return y;
 }
 
-char* buf_to_str(const u8 *buf, int buf_len, int radix)
+char* buf_to_str(const uint8_t *buf, int buf_len, int radix)
 {
 	const char *DIGITS = &quot;0123456789ABCDEF&quot;;
 	float factor;
@@ -225,7 +225,7 @@
 		for (j = str_len; j &gt; 0; j--)
 		{
 			tmp += (u32)str[j-1] * 256;
-			str[j-1] = (u8)(tmp % radix);
+			str[j-1] = (uint8_t)(tmp % radix);
 			tmp /= radix;
 		}
 	}
@@ -236,12 +236,12 @@
 	return str;
 }
 
-int str_to_buf(const char *str, int str_len, u8 *buf, int buf_len, int radix)
+int str_to_buf(const char *str, int str_len, uint8_t *buf, int buf_len, int radix)
 {
 	char *charbuf;
 	u32 tmp;
 	float factor;
-	u8 *b256_buf;
+	uint8_t *b256_buf;
 	int b256_len;
 
 	int j; /* base-256 digits */
@@ -304,7 +304,7 @@
 		for (j = 0; j &lt; b256_len; j++)
 		{
 			tmp += (u32)b256_buf[j] * radix;
-			b256_buf[j] = (u8)(tmp &amp; 0xFF);
+			b256_buf[j] = (uint8_t)(tmp &amp; 0xFF);
 			tmp &gt;&gt;= 8;
 		}
 
@@ -328,7 +328,7 @@
 	return i;
 }
 
-int buf_to_u32_handler(u8 *in_buf, void *priv, struct scan_field_s *field)
+int buf_to_u32_handler(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
 	u32 *dest = priv;
 

Modified: trunk/src/helper/binarybuffer.h
===================================================================
--- trunk/src/helper/binarybuffer.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/helper/binarybuffer.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -30,7 +30,7 @@
  */
 
 /* inlining this will help show what fn that is taking time during profiling. */
-static inline void buf_set_u32(u8* buffer, unsigned int first, unsigned int num, u32 value)
+static inline void buf_set_u32(uint8_t* buffer, unsigned int first, unsigned int num, u32 value)
 {
 	if ((num==32)&amp;&amp;(first==0))
 	{
@@ -51,7 +51,7 @@
 		}
 	}
 }
-static inline u32 buf_get_u32(const u8* buffer, unsigned int first, unsigned int num)
+static inline u32 buf_get_u32(const uint8_t* buffer, unsigned int first, unsigned int num)
 {
 	if ((num==32)&amp;&amp;(first==0))
 	{
@@ -73,23 +73,23 @@
 
 extern u32 flip_u32(u32 value, unsigned int num);
 
-extern int buf_cmp(const u8 *buf1, const u8 *buf2, int size);
-extern int buf_cmp_mask(const u8 *buf1, const u8 *buf2, const u8 *mask, int size);
-extern u8* buf_cpy(const u8 *from, u8 *to, int size);
+extern int buf_cmp(const uint8_t *buf1, const uint8_t *buf2, int size);
+extern int buf_cmp_mask(const uint8_t *buf1, const uint8_t *buf2, const uint8_t *mask, int size);
+extern uint8_t* buf_cpy(const uint8_t *from, uint8_t *to, int size);
 
-extern u8* buf_set_ones(u8 *buf, int count);
-extern u8* buf_set_buf(const u8 *src, int src_start, u8 *dst, int dst_start, int len);
+extern uint8_t* buf_set_ones(uint8_t *buf, int count);
+extern uint8_t* buf_set_buf(const uint8_t *src, int src_start, uint8_t *dst, int dst_start, int len);
 
-extern int str_to_buf(const char *str, int len, u8 *bin_buf, int buf_size, int radix);
-extern char* buf_to_str(const u8 *buf, int size, int radix);
+extern int str_to_buf(const char *str, int len, uint8_t *bin_buf, int buf_size, int radix);
+extern char* buf_to_str(const uint8_t *buf, int size, int radix);
 
 struct scan_field_s;
-extern int buf_to_u32_handler(u8 *in_buf, void *priv, struct scan_field_s *field);
+extern int buf_to_u32_handler(uint8_t *in_buf, void *priv, struct scan_field_s *field);
 
 #define CEIL(m, n)	((m + n - 1) / n)
 
 /* read a u32 from a buffer in target memory endianness */
-static inline u32 fast_target_buffer_get_u32(const u8 *buffer, int little)
+static inline u32 fast_target_buffer_get_u32(const uint8_t *buffer, int little)
 {
 	if (little)
 		return le_to_h_u32(buffer);

Modified: trunk/src/helper/fileio.c
===================================================================
--- trunk/src/helper/fileio.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/helper/fileio.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -155,21 +155,21 @@
 	return ERROR_OK;
 }
 
-static inline int fileio_local_read(fileio_t *fileio, u32 size, u8 *buffer, u32 *size_read)
+static inline int fileio_local_read(fileio_t *fileio, u32 size, uint8_t *buffer, u32 *size_read)
 {
 	*size_read = fread(buffer, 1, size, fileio-&gt;file);
 	
 	return ERROR_OK;
 }
 
-int fileio_read(fileio_t *fileio, u32 size, u8 *buffer, u32 *size_read)
+int fileio_read(fileio_t *fileio, u32 size, uint8_t *buffer, u32 *size_read)
 {
 	return fileio_local_read(fileio, size, buffer, size_read);
 }
 
 int fileio_read_u32(fileio_t *fileio, u32 *data)
 {
-	u8 buf[4];
+	uint8_t buf[4];
 	u32 size_read;
 	int retval;
 	
@@ -193,14 +193,14 @@
 	return fileio_local_fgets(fileio, size, buffer);
 }
 
-static inline int fileio_local_write(fileio_t *fileio, u32 size, const u8 *buffer, u32 *size_written)
+static inline int fileio_local_write(fileio_t *fileio, u32 size, const uint8_t *buffer, u32 *size_written)
 {
 	*size_written = fwrite(buffer, 1, size, fileio-&gt;file);
 	
 	return ERROR_OK;
 }
 
-int fileio_write(fileio_t *fileio, u32 size, const u8 *buffer, u32 *size_written)
+int fileio_write(fileio_t *fileio, u32 size, const uint8_t *buffer, u32 *size_written)
 {
 	int retval;
 	
@@ -214,7 +214,7 @@
 
 int fileio_write_u32(fileio_t *fileio, u32 data)
 {
-	u8 buf[4];
+	uint8_t buf[4];
 	u32 size_written;
 	int retval;
 	

Modified: trunk/src/helper/fileio.h
===================================================================
--- trunk/src/helper/fileio.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/helper/fileio.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -54,8 +54,8 @@
 	FILE *file;
 } fileio_t;
 
-extern int fileio_write(fileio_t *fileio, u32 size, const u8 *buffer, u32 *size_written);
-extern int fileio_read(fileio_t *fileio, u32 size, u8 *buffer, u32 *size_read);
+extern int fileio_write(fileio_t *fileio, u32 size, const uint8_t *buffer, u32 *size_written);
+extern int fileio_read(fileio_t *fileio, u32 size, uint8_t *buffer, u32 *size_read);
 extern int fileio_fgets(fileio_t *fileio, u32 size, char *buffer);
 extern int fileio_seek(fileio_t *fileio, u32 position);
 extern int fileio_close(fileio_t *fileio);

Modified: trunk/src/helper/types.h
===================================================================
--- trunk/src/helper/types.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/helper/types.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -30,8 +30,8 @@
 #include &lt;stdint.h&gt;
 #endif
 
-#ifndef u8
-typedef unsigned char u8;
+#ifndef uint8_t
+typedef unsigned char uint8_t;
 #endif
 
 #ifndef u16
@@ -88,52 +88,52 @@
  */
 
 
-static inline u32 le_to_h_u32(const u8* buf)
+static inline u32 le_to_h_u32(const uint8_t* buf)
 {
 	return (u32)(buf[0] | buf[1] &lt;&lt; 8 | buf[2] &lt;&lt; 16 | buf[3] &lt;&lt; 24);
 }
 
-static inline u16 le_to_h_u16(const u8* buf)
+static inline u16 le_to_h_u16(const uint8_t* buf)
 {
 	return (u16)(buf[0] | buf[1] &lt;&lt; 8);
 }
 
-static inline u32 be_to_h_u32(const u8* buf)
+static inline u32 be_to_h_u32(const uint8_t* buf)
 {
 	return (u32)(buf[3] | buf[2] &lt;&lt; 8 | buf[1] &lt;&lt; 16 | buf[0] &lt;&lt; 24);
 }
 
-static inline u16 be_to_h_u16(const u8* buf)
+static inline u16 be_to_h_u16(const uint8_t* buf)
 {
 	return (u16)(buf[1] | buf[0] &lt;&lt; 8);
 }
 
-static inline void h_u32_to_le(u8* buf, int val)
+static inline void h_u32_to_le(uint8_t* buf, int val)
 {
-	buf[3] = (u8) (val &gt;&gt; 24);
-	buf[2] = (u8) (val &gt;&gt; 16);
-	buf[1] = (u8) (val &gt;&gt; 8);
-	buf[0] = (u8) (val &gt;&gt; 0);
+	buf[3] = (uint8_t) (val &gt;&gt; 24);
+	buf[2] = (uint8_t) (val &gt;&gt; 16);
+	buf[1] = (uint8_t) (val &gt;&gt; 8);
+	buf[0] = (uint8_t) (val &gt;&gt; 0);
 }
 
-static inline void h_u32_to_be(u8* buf, int val)
+static inline void h_u32_to_be(uint8_t* buf, int val)
 {
-	buf[0] = (u8) (val &gt;&gt; 24);
-	buf[1] = (u8) (val &gt;&gt; 16);
-	buf[2] = (u8) (val &gt;&gt; 8);
-	buf[3] = (u8) (val &gt;&gt; 0);
+	buf[0] = (uint8_t) (val &gt;&gt; 24);
+	buf[1] = (uint8_t) (val &gt;&gt; 16);
+	buf[2] = (uint8_t) (val &gt;&gt; 8);
+	buf[3] = (uint8_t) (val &gt;&gt; 0);
 }
 
-static inline void h_u16_to_le(u8* buf, int val)
+static inline void h_u16_to_le(uint8_t* buf, int val)
 {
-	buf[1] = (u8) (val &gt;&gt; 8);
-	buf[0] = (u8) (val &gt;&gt; 0);
+	buf[1] = (uint8_t) (val &gt;&gt; 8);
+	buf[0] = (uint8_t) (val &gt;&gt; 0);
 }
 
-static inline void h_u16_to_be(u8* buf, int val)
+static inline void h_u16_to_be(uint8_t* buf, int val)
 {
-	buf[0] = (u8) (val &gt;&gt; 8);
-	buf[1] = (u8) (val &gt;&gt; 0);
+	buf[0] = (uint8_t) (val &gt;&gt; 8);
+	buf[1] = (uint8_t) (val &gt;&gt; 0);
 }
 
 #ifdef __ECOS

Modified: trunk/src/jtag/amt_jtagaccel.c
===================================================================
--- trunk/src/jtag/amt_jtagaccel.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/amt_jtagaccel.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -46,9 +46,9 @@
 
 /* interface variables
  */
-static u8 aw_control_rst = 0x00;
-static u8 aw_control_fsm = 0x10;
-static u8 aw_control_baudrate = 0x20;
+static uint8_t aw_control_rst = 0x00;
+static uint8_t aw_control_fsm = 0x10;
+static uint8_t aw_control_baudrate = 0x20;
 
 static int rtck_enabled = 0;
 
@@ -89,7 +89,7 @@
  * 4: Shift-IR
  * 5: Pause-IR
  */
-static u8 amt_jtagaccel_tap_move[6][6][2] =
+static uint8_t amt_jtagaccel_tap_move[6][6][2] =
 {
 	/*	   RESET         IDLE        DRSHIFT       DRPAUSE       IRSHIFT       IRPAUSE             */
 	{{0x1f, 0x00}, {0x0f, 0x00}, {0x8a, 0x04}, {0x0a, 0x00}, {0x06, 0x00}, {0x96, 0x00}},	/* RESET */
@@ -161,7 +161,7 @@
 static void amt_wait_scan_busy(void)
 {
 	int timeout = 4096;
-	u8 ar_status;
+	uint8_t ar_status;
 
 	AMT_AR(ar_status);
 	while (((ar_status) &amp; 0x80) &amp;&amp; (timeout-- &gt; 0))
@@ -176,8 +176,8 @@
 
 static void amt_jtagaccel_state_move(void)
 {
-	u8 aw_scan_tms_5;
-	u8 tms_scan[2];
+	uint8_t aw_scan_tms_5;
+	uint8_t tms_scan[2];
 
 	tap_state_t	cur_state = tap_get_state();
 	tap_state_t	end_state = tap_get_end_state();
@@ -205,8 +205,8 @@
 static void amt_jtagaccel_runtest(int num_cycles)
 {
 	int i = 0;
-	u8 aw_scan_tms_5;
-	u8 aw_scan_tms_1to4;
+	uint8_t aw_scan_tms_5;
+	uint8_t aw_scan_tms_1to4;
 
 	tap_state_t saved_end_state = tap_get_end_state();
 
@@ -235,16 +235,16 @@
 		amt_jtagaccel_state_move();
 }
 
-static void amt_jtagaccel_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void amt_jtagaccel_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size)
 {
 	int bits_left = scan_size;
 	int bit_count = 0;
 	tap_state_t saved_end_state = tap_get_end_state();
-	u8 aw_tdi_option;
-	u8 dw_tdi_scan;
-	u8 dr_tdo;
-	u8 aw_tms_scan;
-	u8 tms_scan[2];
+	uint8_t aw_tdi_option;
+	uint8_t dw_tdi_scan;
+	uint8_t dr_tdo;
+	uint8_t aw_tms_scan;
+	uint8_t tms_scan[2];
 	int jtag_speed = jtag_get_speed();
 
 	if (ir_scan)
@@ -323,7 +323,7 @@
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 	int retval;
 
 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
@@ -419,11 +419,11 @@
 #if PARPORT_USE_PPDEV == 1
 	char buffer[256];
 	int i = 0;
-	u8 control_port;
+	uint8_t control_port;
 #else
-	u8 status_port;
+	uint8_t status_port;
 #endif
-	u8 ar_status;
+	uint8_t ar_status;
 
 #if PARPORT_USE_PPDEV == 1
 	if (device_handle &gt; 0)

Modified: trunk/src/jtag/arm-jtag-ew.c
===================================================================
--- trunk/src/jtag/arm-jtag-ew.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/arm-jtag-ew.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -54,8 +54,8 @@
 #define CMD_TGPWR_SETUP				0x22
 
 /* Global USB buffers */
-static u8 usb_in_buffer[ARMJTAGEW_IN_BUFFER_SIZE];
-static u8 usb_out_buffer[ARMJTAGEW_OUT_BUFFER_SIZE];
+static uint8_t usb_in_buffer[ARMJTAGEW_IN_BUFFER_SIZE];
+static uint8_t usb_out_buffer[ARMJTAGEW_OUT_BUFFER_SIZE];
 
 /* External interface functions */
 static int armjtagew_execute_queue(void);
@@ -73,9 +73,9 @@
 static void armjtagew_state_move(void);
 static void armjtagew_path_move(int num_states, tap_state_t *path);
 static void armjtagew_runtest(int num_cycles);
-static void armjtagew_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void armjtagew_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command);
 static void armjtagew_reset(int trst, int srst);
-//static void armjtagew_simple_command(u8 command);
+//static void armjtagew_simple_command(uint8_t command);
 static int armjtagew_get_status(void);
 
 /* tap buffer functions */
@@ -83,7 +83,7 @@
 static int armjtagew_tap_execute(void);
 static void armjtagew_tap_ensure_space(int scans, int bits);
 static void armjtagew_tap_append_step(int tms, int tdi);
-static void armjtagew_tap_append_scan(int length, u8 *buffer, scan_command_t *command);
+static void armjtagew_tap_append_scan(int length, uint8_t *buffer, scan_command_t *command);
 
 /* ARM-JTAG-EW lowlevel functions */
 typedef struct armjtagew_jtag
@@ -101,7 +101,7 @@
 static int armjtagew_get_version_info(void);
 
 #ifdef _DEBUG_USB_COMMS_
-static void armjtagew_debug_buffer(u8 *buffer, int length);
+static void armjtagew_debug_buffer(uint8_t *buffer, int length);
 #endif
 
 static armjtagew_jtag_t* armjtagew_jtag_handle;
@@ -128,7 +128,7 @@
 	jtag_command_t *cmd = jtag_command_queue;
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 
 	while (cmd != NULL)
 	{
@@ -315,7 +315,7 @@
 {
 	int i;
 	int tms = 0;
-	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	for (i = 0; i &lt; tms_count; i++)
@@ -385,7 +385,7 @@
 	}
 }
 
-static void armjtagew_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void armjtagew_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
 
@@ -415,11 +415,11 @@
 
 static void armjtagew_reset(int trst, int srst)
 {
-	const u8 trst_mask = (1u&lt;&lt;5);
-	const u8 srst_mask = (1u&lt;&lt;6);
-	u8 val = 0;
-	u8 outp_en = 0;
-	u8 change_mask = 0;
+	const uint8_t trst_mask = (1u&lt;&lt;5);
+	const uint8_t srst_mask = (1u&lt;&lt;6);
+	uint8_t val = 0;
+	uint8_t outp_en = 0;
+	uint8_t change_mask = 0;
 	int result;
 
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
@@ -541,16 +541,16 @@
 #define ARMJTAGEW_TAP_BUFFER_SIZE 2048
 
 static int tap_length;
-static u8 tms_buffer[ARMJTAGEW_TAP_BUFFER_SIZE];
-static u8 tdi_buffer[ARMJTAGEW_TAP_BUFFER_SIZE];
-static u8 tdo_buffer[ARMJTAGEW_TAP_BUFFER_SIZE];
+static uint8_t tms_buffer[ARMJTAGEW_TAP_BUFFER_SIZE];
+static uint8_t tdi_buffer[ARMJTAGEW_TAP_BUFFER_SIZE];
+static uint8_t tdo_buffer[ARMJTAGEW_TAP_BUFFER_SIZE];
 
 typedef struct
 {
 	int first;	/* First bit position in tdo_buffer to read */
 	int length; /* Number of bits to read */
 	scan_command_t *command; /* Corresponding scan command */
-	u8 *buffer;
+	uint8_t *buffer;
 } pending_scan_result_t;
 
 #define MAX_PENDING_SCAN_RESULTS 256
@@ -585,7 +585,7 @@
 	if (index &lt; ARMJTAGEW_TAP_BUFFER_SIZE)
 	{
 		int bit_index = tap_length % 8;
-		u8 bit = 1 &lt;&lt; bit_index;
+		uint8_t bit = 1 &lt;&lt; bit_index;
 
 		if (tms)
 		{
@@ -613,7 +613,7 @@
 	}
 }
 
-void armjtagew_tap_append_scan(int length, u8 *buffer, scan_command_t *command)
+void armjtagew_tap_append_scan(int length, uint8_t *buffer, scan_command_t *command)
 {
 	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 	int i;
@@ -687,7 +687,7 @@
 			for (i = 0; i &lt; pending_scan_results_length; i++)
 			{
 				pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[i];
-				u8 *buffer = pending_scan_result-&gt;buffer;
+				uint8_t *buffer = pending_scan_result-&gt;buffer;
 				int length = pending_scan_result-&gt;length;
 				int first = pending_scan_result-&gt;first;
 				scan_command_t *command = pending_scan_result-&gt;command;
@@ -845,7 +845,7 @@
 #ifdef _DEBUG_USB_COMMS_
 #define BYTES_PER_LINE  16
 
-static void armjtagew_debug_buffer(u8 *buffer, int length)
+static void armjtagew_debug_buffer(uint8_t *buffer, int length)
 {
 	char line[81];
 	char s[4];

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/bitbang.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -77,7 +77,7 @@
 static void bitbang_state_move(int skip)
 {
 	int i=0, tms=0;
-	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	for (i = skip; i &lt; tms_count; i++)
@@ -170,7 +170,7 @@
 
 
 
-static void bitbang_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void bitbang_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 	int bit_cnt;
@@ -233,7 +233,7 @@
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 	int retval;
 
 	if (!bitbang_interface)

Modified: trunk/src/jtag/bitq.c
===================================================================
--- trunk/src/jtag/bitq.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/bitq.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -29,7 +29,7 @@
 
 static bitq_state_t      bitq_in_state;        /* state of input queue */
 
-static u8* bitq_in_buffer;                     /* buffer dynamically reallocated as needed */
+static uint8_t* bitq_in_buffer;                     /* buffer dynamically reallocated as needed */
 static int     bitq_in_bufsize = 32; /* min. buffer size */
 
 /*
@@ -40,9 +40,9 @@
 void bitq_in_proc(void)
 {
 	/* static information preserved between calls to increase performance */
-	static u8*    in_buff;  /* pointer to buffer for scanned data */
+	static uint8_t*    in_buff;  /* pointer to buffer for scanned data */
 	static int    in_idx;   /* index of byte being scanned */
-	static u8     in_mask;  /* mask of next bit to be scanned */
+	static uint8_t     in_mask;  /* mask of next bit to be scanned */
 
 	scan_field_t* field;
 	int           tdo;
@@ -150,7 +150,7 @@
 void bitq_state_move(tap_state_t new_state)
 {
 	int i = 0;
-	u8  tms_scan;
+	uint8_t  tms_scan;
 
 	if (!tap_is_state_stable(tap_get_state()) || !tap_is_state_stable(new_state))
 	{
@@ -218,8 +218,8 @@
 	int bit_cnt;
 	int tdo_req;
 
-	u8* out_ptr;
-	u8  out_mask;
+	uint8_t* out_ptr;
+	uint8_t  out_mask;
 
 	if (field-&gt;in_value)
 		tdo_req = 1;

Modified: trunk/src/jtag/commands.c
===================================================================
--- trunk/src/jtag/commands.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/commands.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -64,7 +64,7 @@
 {
 	cmd_queue_page_t **p_page = &amp;cmd_queue_pages;
 	int offset;
-	u8 *t;
+	uint8_t *t;
 
 	/*
 	 * WARNING:
@@ -117,7 +117,7 @@
 	offset = (*p_page)-&gt;used;
 	(*p_page)-&gt;used += size;
 
-	t=(u8 *)((*p_page)-&gt;address);
+	t=(uint8_t *)((*p_page)-&gt;address);
 	return t + offset;
 }
 
@@ -174,7 +174,7 @@
 	return bit_count;
 }
 
-int jtag_build_buffer(const scan_command_t *cmd, u8 **buffer)
+int jtag_build_buffer(const scan_command_t *cmd, uint8_t **buffer)
 {
 	int bit_count = 0;
 	int i;
@@ -218,7 +218,7 @@
 	return bit_count;
 }
 
-int jtag_read_buffer(u8 *buffer, const scan_command_t *cmd)
+int jtag_read_buffer(uint8_t *buffer, const scan_command_t *cmd)
 {
 	int i;
 	int bit_count = 0;
@@ -235,7 +235,7 @@
 		if (cmd-&gt;fields[i].in_value)
 		{
 			int num_bits = cmd-&gt;fields[i].num_bits;
-			u8 *captured = buf_set_buf(buffer, bit_count, malloc(CEIL(num_bits, 8)), 0, num_bits);
+			uint8_t *captured = buf_set_buf(buffer, bit_count, malloc(CEIL(num_bits, 8)), 0, num_bits);
 
 #ifdef _DEBUG_JTAG_IO_
 			char *char_buf = buf_to_str(captured, (num_bits &gt; DEBUG_JTAG_IOZ) ? DEBUG_JTAG_IOZ : num_bits, 16);

Modified: trunk/src/jtag/commands.h
===================================================================
--- trunk/src/jtag/commands.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/commands.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -156,7 +156,7 @@
 
 enum scan_type jtag_scan_type(const scan_command_t* cmd);
 int jtag_scan_size(const scan_command_t* cmd);
-int jtag_read_buffer(u8* buffer, const scan_command_t* cmd);
-int jtag_build_buffer(const scan_command_t* cmd, u8** buffer);
+int jtag_read_buffer(uint8_t* buffer, const scan_command_t* cmd);
+int jtag_build_buffer(const scan_command_t* cmd, uint8_t** buffer);
 
 #endif // JTAG_COMMANDS_H

Modified: trunk/src/jtag/core.c
===================================================================
--- trunk/src/jtag/core.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/core.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -353,23 +353,23 @@
 	jtag_set_error(retval);
 }
 
-void jtag_add_callback(jtag_callback1_t f, u8 *in)
+void jtag_add_callback(jtag_callback1_t f, uint8_t *in)
 {
 	interface_jtag_add_callback(f, in);
 }
 
-void jtag_add_callback4(jtag_callback_t f, u8 *in,
+void jtag_add_callback4(jtag_callback_t f, uint8_t *in,
 		jtag_callback_data_t data1, jtag_callback_data_t data2,
 		jtag_callback_data_t data3)
 {
 	interface_jtag_add_callback4(f, in, data1, data2, data3);
 }
 
-int jtag_check_value_inner(u8 *captured, u8 *in_check_value, u8 *in_check_mask, int num_bits);
+int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value, uint8_t *in_check_mask, int num_bits);
 
-static int jtag_check_value_mask_callback(u8 *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
+static int jtag_check_value_mask_callback(uint8_t *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
 {
-	return jtag_check_value_inner(in, (u8 *)data1, (u8 *)data2, (int)data3);
+	return jtag_check_value_inner(in, (uint8_t *)data1, (uint8_t *)data2, (int)data3);
 }
 
 static void jtag_add_scan_check(void (*jtag_add_scan)(int in_num_fields, const scan_field_t *in_fields, tap_state_t state),
@@ -693,7 +693,7 @@
 	jtag_set_error(interface_jtag_add_sleep(us));
 }
 
-int jtag_check_value_inner(u8 *captured, u8 *in_check_value, u8 *in_check_mask, int num_bits)
+int jtag_check_value_inner(uint8_t *captured, uint8_t *in_check_value, uint8_t *in_check_mask, int num_bits)
 {
 	int retval = ERROR_OK;
 
@@ -742,7 +742,7 @@
 	return retval;
 }
 
-void jtag_check_value_mask(scan_field_t *field, u8 *value, u8 *mask)
+void jtag_check_value_mask(scan_field_t *field, uint8_t *value, uint8_t *mask)
 {
 	assert(field-&gt;in_value != NULL);
 
@@ -819,7 +819,7 @@
 #define EXTRACT_PART(X) (((X) &amp; 0xffff000) &gt;&gt; 12)
 #define EXTRACT_VER(X)  (((X) &amp; 0xf0000000) &gt;&gt; 28)
 
-static int jtag_examine_chain_execute(u8 *idcode_buffer, unsigned num_idcode)
+static int jtag_examine_chain_execute(uint8_t *idcode_buffer, unsigned num_idcode)
 {
 	scan_field_t field = {
 			.tap = NULL,
@@ -836,10 +836,10 @@
 	return jtag_execute_queue();
 }
 
-static bool jtag_examine_chain_check(u8 *idcodes, unsigned count)
+static bool jtag_examine_chain_check(uint8_t *idcodes, unsigned count)
 {
-	u8 zero_check = 0x0;
-	u8 one_check = 0xff;
+	uint8_t zero_check = 0x0;
+	uint8_t one_check = 0xff;
 
 	for (unsigned i = 0; i &lt; count * 4; i++)
 	{
@@ -879,7 +879,7 @@
  * read back correctly.  This can help identify and diagnose problems
  * with the JTAG chain earlier, gives more helpful/explicit error messages.
  */
-static void jtag_examine_chain_end(u8 *idcodes, unsigned count, unsigned max)
+static void jtag_examine_chain_end(uint8_t *idcodes, unsigned count, unsigned max)
 {
 	bool triggered = false;
 	for ( ; count &lt; max - 31; count += 32)
@@ -907,7 +907,7 @@
 	}
 
 	/* Loop over the expected identification codes and test for a match */
-	u8 ii;
+	uint8_t ii;
 	for (ii = 0; ii &lt; tap-&gt;expected_ids_cnt; ii++)
 	{
 		if (tap-&gt;idcode == tap-&gt;expected_ids[ii])
@@ -937,7 +937,7 @@
  */
 int jtag_examine_chain(void)
 {
-	u8 idcode_buffer[JTAG_MAX_CHAIN_SIZE * 4];
+	uint8_t idcode_buffer[JTAG_MAX_CHAIN_SIZE * 4];
 	unsigned device_count = 0;
 
 	jtag_examine_chain_execute(idcode_buffer, JTAG_MAX_CHAIN_SIZE);
@@ -1015,7 +1015,7 @@
 {
 	jtag_tap_t *tap;
 	int total_ir_length = 0;
-	u8 *ir_test = NULL;
+	uint8_t *ir_test = NULL;
 	scan_field_t field;
 	int chain_pos = 0;
 

Modified: trunk/src/jtag/driver.c
===================================================================
--- trunk/src/jtag/driver.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/driver.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -40,7 +40,7 @@
 	struct jtag_callback_entry *next;
 
 	jtag_callback_t callback;
-	u8 *in;
+	uint8_t *in;
 	jtag_callback_data_t data1;
 	jtag_callback_data_t data2;
 	jtag_callback_data_t data3;
@@ -311,7 +311,7 @@
 
 			for (int j = 0; j &lt; in_num_fields; j++)
 			{
-				u8 out_value[4];
+				uint8_t out_value[4];
 				size_t scan_size = num_bits[j];
 				buf_set_u32(out_value, 0, scan_size, value[j]);
 
@@ -465,7 +465,7 @@
 }
 
 /* add callback to end of queue */
-void interface_jtag_add_callback4(jtag_callback_t callback, u8 *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
+void interface_jtag_add_callback4(jtag_callback_t callback, uint8_t *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
 {
 	struct jtag_callback_entry *entry=cmd_queue_alloc(sizeof(struct jtag_callback_entry));
 
@@ -507,13 +507,13 @@
 	return retval;
 }
 
-static int jtag_convert_to_callback4(u8 *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
+static int jtag_convert_to_callback4(uint8_t *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
 {
 	((jtag_callback1_t)data1)(in);
 	return ERROR_OK;
 }
 
-void interface_jtag_add_callback(jtag_callback1_t callback, u8 *in)
+void interface_jtag_add_callback(jtag_callback1_t callback, uint8_t *in)
 {
 	jtag_add_callback4(jtag_convert_to_callback4, in, (jtag_callback_data_t)callback, 0, 0);
 }

Modified: trunk/src/jtag/ep93xx.c
===================================================================
--- trunk/src/jtag/ep93xx.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/ep93xx.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -34,11 +34,11 @@
 
 #include &lt;sys/mman.h&gt;
 
-static u8 output_value = 0x0;
+static uint8_t output_value = 0x0;
 static int dev_mem_fd;
 static void *gpio_controller;
-static volatile u8 *gpio_data_register;
-static volatile u8 *gpio_data_direction_register;
+static volatile uint8_t *gpio_data_register;
+static volatile uint8_t *gpio_data_direction_register;
 
 /* low level command set
  */

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/ft2232.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -101,7 +101,7 @@
 static char*        ft2232_device_desc = NULL;
 static char*        ft2232_serial  = NULL;
 static char*        ft2232_layout  = NULL;
-static u8		ft2232_latency = 2;
+static uint8_t		ft2232_latency = 2;
 static unsigned		ft2232_max_tck = 6000;
 
 
@@ -168,13 +168,13 @@
 	{ NULL,                   NULL,                      NULL,               NULL                    },
 };
 
-static u8                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;
+static uint8_t                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;
 
 static const ft2232_layout_t *layout;
-static u8                  low_output     = 0x0;
-static u8                  low_direction  = 0x0;
-static u8                  high_output    = 0x0;
-static u8                  high_direction = 0x0;
+static uint8_t                  low_output     = 0x0;
+static uint8_t                  low_direction  = 0x0;
+static uint8_t                  high_output    = 0x0;
+static uint8_t                  high_direction = 0x0;
 
 #if BUILD_FT2232_FTD2XX == 1
 static FT_HANDLE	ftdih = NULL;
@@ -203,7 +203,7 @@
 
 #define FT2232_BUFFER_SIZE 131072
 
-static u8*             ft2232_buffer = NULL;
+static uint8_t*             ft2232_buffer = NULL;
 static int             ft2232_buffer_size  = 0;
 static int             ft2232_read_pointer = 0;
 static int             ft2232_expect_read  = 0;
@@ -213,7 +213,7 @@
  * writes a byte into the byte buffer, &quot;ft2232_buffer&quot;, which must be sent later.
  * @param val is the byte to send.
  */
-static inline void buffer_write(u8 val)
+static inline void buffer_write(uint8_t val)
 {
 	assert(ft2232_buffer);
 	assert((unsigned) ft2232_buffer_size &lt; (unsigned) FT2232_BUFFER_SIZE);
@@ -224,7 +224,7 @@
  * Function buffer_read
  * returns a byte from the byte buffer.
  */
-static inline u8 buffer_read(void)
+static inline uint8_t buffer_read(void)
 {
 	assert(ft2232_buffer);
 	assert(ft2232_read_pointer &lt; ft2232_buffer_size);
@@ -249,9 +249,9 @@
  *
  * See the MPSSE spec referenced above.
  */
-static void clock_tms(u8 mpsse_cmd, int tms_bits, int tms_count, bool tdi_bit)
+static void clock_tms(uint8_t mpsse_cmd, int tms_bits, int tms_count, bool tdi_bit)
 {
-	u8	tms_byte;
+	uint8_t	tms_byte;
 	int	i;
 	int	tms_ndx;				/* bit index into tms_byte */
 
@@ -338,7 +338,7 @@
 	.quit			= ft2232_quit,
 };
 
-static int ft2232_write(u8* buf, int size, u32* bytes_written)
+static int ft2232_write(uint8_t* buf, int size, u32* bytes_written)
 {
 #if BUILD_FT2232_FTD2XX == 1
 	FT_STATUS status;
@@ -371,7 +371,7 @@
 }
 
 
-static int ft2232_read(u8* buf, u32 size, u32* bytes_read)
+static int ft2232_read(uint8_t* buf, u32 size, u32* bytes_read)
 {
 #if BUILD_FT2232_FTD2XX == 1
 	DWORD     dw_bytes_read;
@@ -438,7 +438,7 @@
 		}
 	}
 
-	u8  buf = use_adaptive_clocking ? 0x96 : 0x97;
+	uint8_t  buf = use_adaptive_clocking ? 0x96 : 0x97;
 	LOG_DEBUG(&quot;%2.2x&quot;, buf);
 
 	u32 bytes_written;
@@ -461,7 +461,7 @@
 
 static int ft2232_speed(int speed)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	int retval;
 	u32 bytes_written;
 
@@ -569,7 +569,7 @@
 	}
 }
 
-static void ft2232_read_scan(enum scan_type type, u8* buffer, int scan_size)
+static void ft2232_read_scan(enum scan_type type, uint8_t* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
@@ -617,7 +617,7 @@
 static int ft2232_send_and_recv(jtag_command_t* first, jtag_command_t* last)
 {
 	jtag_command_t* cmd;
-	u8*             buffer;
+	uint8_t*             buffer;
 	int             scan_size;
 	enum scan_type  type;
 	int             retval;
@@ -775,7 +775,7 @@
 }
 
 
-static void ft2232_add_scan(bool ir_scan, enum scan_type type, u8* buffer, int scan_size)
+static void ft2232_add_scan(bool ir_scan, enum scan_type type, uint8_t* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
@@ -823,8 +823,8 @@
 		thisrun_bytes = (num_bytes &gt; 65537) ? 65536 : (num_bytes - 1);
 		num_bytes    -= thisrun_bytes;
 
-		buffer_write((u8) (thisrun_bytes - 1));
-		buffer_write((u8) ((thisrun_bytes - 1) &gt;&gt; 8));
+		buffer_write((uint8_t) (thisrun_bytes - 1));
+		buffer_write((uint8_t) ((thisrun_bytes - 1) &gt;&gt; 8));
 
 		if (type != SCAN_IN)
 		{
@@ -902,7 +902,7 @@
 	{
 		int tms_bits;
 		int tms_count;
-		u8	mpsse_cmd;
+		uint8_t	mpsse_cmd;
 
 		/* move from Shift-IR/DR to end state */
 		if (type != SCAN_OUT)
@@ -934,14 +934,14 @@
 }
 
 
-static int ft2232_large_scan(scan_command_t* cmd, enum scan_type type, u8* buffer, int scan_size)
+static int ft2232_large_scan(scan_command_t* cmd, enum scan_type type, uint8_t* buffer, int scan_size)
 {
 	int num_bytes = (scan_size + 7) / 8;
 	int bits_left = scan_size;
 	int cur_byte  = 0;
 	int last_bit;
-	u8* receive_buffer  = malloc(CEIL(scan_size, 8));
-	u8* receive_pointer = receive_buffer;
+	uint8_t* receive_buffer  = malloc(CEIL(scan_size, 8));
+	uint8_t* receive_pointer = receive_buffer;
 	u32 bytes_written;
 	u32 bytes_read;
 	int retval;
@@ -993,8 +993,8 @@
 		thisrun_bytes = (num_bytes &gt; 65537) ? 65536 : (num_bytes - 1);
 		thisrun_read  = thisrun_bytes;
 		num_bytes    -= thisrun_bytes;
-		buffer_write((u8) (thisrun_bytes - 1));
-		buffer_write((u8) ((thisrun_bytes - 1) &gt;&gt; 8));
+		buffer_write((uint8_t) (thisrun_bytes - 1));
+		buffer_write((uint8_t) ((thisrun_bytes - 1) &gt;&gt; 8));
 
 		if (type != SCAN_IN)
 		{
@@ -1095,7 +1095,7 @@
 	{
 		int tms_bits  = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 		int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
-		u8	mpsse_cmd;
+		uint8_t	mpsse_cmd;
 
 		/* move from Shift-IR/DR to end state */
 		if (type != SCAN_OUT)
@@ -1599,7 +1599,7 @@
 
 static int ft2232_execute_scan(jtag_command_t *cmd)
 {
-	u8*             buffer;
+	uint8_t*             buffer;
 	int             scan_size;                  /* size of IR or DR scan */
 	int             predicted_size = 0;
 	int				retval = ERROR_OK;
@@ -1788,7 +1788,7 @@
 	char		Description[64];
 	DWORD	openex_flags  = 0;
 	char*	openex_string = NULL;
-	u8	latency_timer;
+	uint8_t	latency_timer;
 
 	LOG_DEBUG(&quot;'ft2232' interface using FTD2XX with '%s' layout (%4.4x:%4.4x)&quot;, ft2232_layout, vid, pid);
 
@@ -1960,7 +1960,7 @@
 #if BUILD_FT2232_LIBFTDI == 1
 static int ft2232_init_libftdi(u16 vid, u16 pid, int more, int* try_more)
 {
-	u8 latency_timer;
+	uint8_t latency_timer;
 
 	LOG_DEBUG(&quot;'ft2232' interface using libftdi with '%s' layout (%4.4x:%4.4x)&quot;,
 			ft2232_layout, vid, pid);
@@ -2032,7 +2032,7 @@
 
 static int ft2232_init(void)
 {
-	u8  buf[1];
+	uint8_t  buf[1];
 	int retval;
 	u32 bytes_written;
 	const ft2232_layout_t* cur_layout = ft2232_layouts;
@@ -2123,7 +2123,7 @@
 
 static int usbjtag_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x08;
@@ -2199,7 +2199,7 @@
 
 static int axm0432_jtag_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x08;
@@ -2270,7 +2270,7 @@
 
 static int jtagkey_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x08;
@@ -2353,7 +2353,7 @@
 
 static int olimex_jtag_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x08;
@@ -2421,7 +2421,7 @@
 
 static int flyswatter_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x18;
@@ -2468,7 +2468,7 @@
 
 static int turtle_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x08;
@@ -2509,7 +2509,7 @@
 
 static int comstick_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x08;
@@ -2553,7 +2553,7 @@
 
 static int stm32stick_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x88;
@@ -2597,7 +2597,7 @@
 
 static int sheevaplug_init(void)
 {
-	u8 buf[3];
+	uint8_t buf[3];
 	u32 bytes_written;
 
 	low_output = 0x08;
@@ -2648,7 +2648,7 @@
 
 static int cortino_jtag_init(void)
 {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_output    = 0x08;
@@ -2884,7 +2884,7 @@
 	int retval = 0;
 
 	/* 7 bits of either ones or zeros. */
-	u8  tms = (tap_get_state() == TAP_RESET ? 0x7F : 0x00);
+	uint8_t  tms = (tap_get_state() == TAP_RESET ? 0x7F : 0x00);
 
 	while (num_cycles &gt; 0)
 	{
@@ -2949,7 +2949,7 @@
  * ADBUS7 -   GND
  */
 static int icebear_jtag_init(void) {
-	u8  buf[3];
+	uint8_t  buf[3];
 	u32 bytes_written;
 
 	low_direction	= 0x0b;	/* output: TCK TDI TMS; input: TDO */

Modified: trunk/src/jtag/gw16012.c
===================================================================
--- trunk/src/jtag/gw16012.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/gw16012.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -71,8 +71,8 @@
 
 /* interface variables
  */
-static u8 gw16012_msb = 0x0;
-static u8 gw16012_control_value = 0x0;
+static uint8_t gw16012_msb = 0x0;
+static uint8_t gw16012_control_value = 0x0;
 
 #if PARPORT_USE_PPDEV == 1
 static int device_handle;
@@ -106,7 +106,7 @@
 	return ERROR_OK;
 }
 
-static void gw16012_data(u8 value)
+static void gw16012_data(uint8_t value)
 {
 	value = (value &amp; 0x7f) | gw16012_msb;
 	gw16012_msb ^= 0x80; /* toggle MSB */
@@ -126,7 +126,7 @@
 	#endif
 }
 
-static void gw16012_control(u8 value)
+static void gw16012_control(uint8_t value)
 {
 	if (value != gw16012_control_value)
 	{
@@ -148,7 +148,7 @@
 	}
 }
 
-static void gw16012_input(u8 *value)
+static void gw16012_input(uint8_t *value)
 {
 	#if PARPORT_USE_PPDEV == 1
 		ioctl(device_handle, PPRSTATUS, value);
@@ -197,7 +197,7 @@
 static void gw16012_state_move(void)
 {
 	int i=0, tms=0;
-	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	gw16012_control(0x0); /* single-bit mode */
@@ -265,12 +265,12 @@
 		gw16012_state_move();
 }
 
-static void gw16012_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void gw16012_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size)
 {
 	int bits_left = scan_size;
 	int bit_count = 0;
 	tap_state_t saved_end_state = tap_get_end_state();
-	u8 scan_out, scan_in;
+	uint8_t scan_out, scan_in;
 
 	/* only if we're not already in the correct Shift state */
 	if (!((!ir_scan &amp;&amp; (tap_get_state() == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (tap_get_state() == TAP_IRSHIFT))))
@@ -296,7 +296,7 @@
 	gw16012_control(0x0); /* single-bit mode */
 	while (bits_left-- &gt; 0)
 	{
-		u8 tms = 0;
+		uint8_t tms = 0;
 
 		scan_out = buf_get_u32(buffer, bit_count, 1);
 
@@ -343,7 +343,7 @@
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 	int retval;
 
 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
@@ -549,7 +549,7 @@
 
 static int gw16012_init(void)
 {
-	u8 status_port;
+	uint8_t status_port;
 
 	if (gw16012_init_device() != ERROR_OK)
 		return ERROR_JTAG_INIT_FAILED;

Modified: trunk/src/jtag/interface.c
===================================================================
--- trunk/src/jtag/interface.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/interface.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -106,8 +106,8 @@
  */
 struct tms_sequences
 {
-	u8	bits;
-	u8	bit_count;
+	uint8_t	bits;
+	uint8_t	bit_count;
 
 };
 
@@ -127,7 +127,7 @@
 	+(((x) &amp; 0x0F000000LU)?(1&lt;&lt;6):0) \
 	+(((x) &amp; 0xF0000000LU)?(1&lt;&lt;7):0)
 
-#define B8(bits,count)		{ ((u8)B8__(HEX__(bits))), (count) }
+#define B8(bits,count)		{ ((uint8_t)B8__(HEX__(bits))), (count) }
 
 static const struct tms_sequences old_tms_seqs[6][6] =		/*  [from_state_ndx][to_state_ndx] */
 {
@@ -380,8 +380,8 @@
 tap_state_t jtag_debug_state_machine(const void *tms_buf, const void *tdi_buf,
 		unsigned tap_bits, tap_state_t next_state)
 {
-	const u8 *tms_buffer;
-	const u8 *tdi_buffer;
+	const uint8_t *tms_buffer;
+	const uint8_t *tdi_buffer;
 	unsigned tap_bytes;
 	unsigned cur_byte;
 	unsigned cur_bit;
@@ -396,8 +396,8 @@
 	last_state = next_state;
 	DEBUG_JTAG_IO(&quot;TAP/SM: START state: %s&quot;, tap_state_name(next_state));
 
-	tms_buffer = (const u8 *)tms_buf;
-	tdi_buffer = (const u8 *)tdi_buf;
+	tms_buffer = (const uint8_t *)tms_buf;
+	tdi_buffer = (const uint8_t *)tdi_buf;
 
 	tap_bytes = TAP_SCAN_BYTES(tap_bits);
 	DEBUG_JTAG_IO(&quot;TAP/SM: TMS bits: %u (bytes: %u)&quot;, tap_bits, tap_bytes);

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/jlink.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -54,9 +54,9 @@
 #define JLINK_EMU_RESULT_BUFFER_SIZE	64
 
 /* Global USB buffers */
-static u8 usb_in_buffer[JLINK_IN_BUFFER_SIZE];
-static u8 usb_out_buffer[JLINK_OUT_BUFFER_SIZE];
-static u8 usb_emu_result_buffer[JLINK_EMU_RESULT_BUFFER_SIZE];
+static uint8_t usb_in_buffer[JLINK_IN_BUFFER_SIZE];
+static uint8_t usb_out_buffer[JLINK_OUT_BUFFER_SIZE];
+static uint8_t usb_emu_result_buffer[JLINK_EMU_RESULT_BUFFER_SIZE];
 
 /* Constants for JLink command */
 #define EMU_CMD_VERSION		0x01
@@ -100,9 +100,9 @@
 static void jlink_state_move(void);
 static void jlink_path_move(int num_states, tap_state_t *path);
 static void jlink_runtest(int num_cycles);
-static void jlink_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command);
 static void jlink_reset(int trst, int srst);
-static void jlink_simple_command(u8 command);
+static void jlink_simple_command(uint8_t command);
 static int jlink_get_status(void);
 
 /* J-Link tap buffer functions */
@@ -110,7 +110,7 @@
 static int jlink_tap_execute(void);
 static void jlink_tap_ensure_space(int scans, int bits);
 static void jlink_tap_append_step(int tms, int tdi);
-static void jlink_tap_append_scan(int length, u8 *buffer, scan_command_t *command);
+static void jlink_tap_append_scan(int length, uint8_t *buffer, scan_command_t *command);
 
 /* Jlink lowlevel functions */
 typedef struct jlink_jtag
@@ -129,7 +129,7 @@
 static int jlink_get_version_info(void);
 
 #ifdef _DEBUG_USB_COMMS_
-static void jlink_debug_buffer(u8 *buffer, int length);
+static void jlink_debug_buffer(uint8_t *buffer, int length);
 #endif
 
 static enum tap_state jlink_last_state = TAP_RESET;
@@ -184,7 +184,7 @@
 {
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 
 	DEBUG_JTAG_IO(&quot;scan end in %s&quot;, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
 
@@ -379,8 +379,8 @@
 {
 	int i;
 	int tms = 0;
-	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
-	u8 tms_scan_bits = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan_bits = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	for (i = 0; i &lt; tms_scan_bits; i++)
 	{
@@ -447,7 +447,7 @@
 	}
 }
 
-static void jlink_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void jlink_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
 
@@ -505,7 +505,7 @@
 	}
 }
 
-static void jlink_simple_command(u8 command)
+static void jlink_simple_command(uint8_t command)
 {
 	int result;
 
@@ -670,16 +670,16 @@
 
 
 static unsigned tap_length=0;
-static u8 tms_buffer[JLINK_TAP_BUFFER_SIZE];
-static u8 tdi_buffer[JLINK_TAP_BUFFER_SIZE];
-static u8 tdo_buffer[JLINK_TAP_BUFFER_SIZE];
+static uint8_t tms_buffer[JLINK_TAP_BUFFER_SIZE];
+static uint8_t tdi_buffer[JLINK_TAP_BUFFER_SIZE];
+static uint8_t tdo_buffer[JLINK_TAP_BUFFER_SIZE];
 
 typedef struct
 {
 	int first;	/* First bit position in tdo_buffer to read */
 	int length; /* Number of bits to read */
 	scan_command_t *command; /* Corresponding scan command */
-	u8 *buffer;
+	uint8_t *buffer;
 } pending_scan_result_t;
 
 #define MAX_PENDING_SCAN_RESULTS 256
@@ -716,7 +716,7 @@
 	}
 
 	int bit_index = tap_length % 8;
-	u8 bit = 1 &lt;&lt; bit_index;
+	uint8_t bit = 1 &lt;&lt; bit_index;
 
 	// we do not pad TMS, so be sure to initialize all bits
 	if (0 == bit_index)
@@ -737,7 +737,7 @@
 	tap_length++;
 }
 
-static void jlink_tap_append_scan(int length, u8 *buffer, scan_command_t *command)
+static void jlink_tap_append_scan(int length, uint8_t *buffer, scan_command_t *command)
 {
 	pending_scan_result_t *pending_scan_result =
 		&amp;pending_scan_results_buffer[pending_scan_results_length];
@@ -802,7 +802,7 @@
 	for (i = 0; i &lt; pending_scan_results_length; i++)
 	{
 		pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[i];
-		u8 *buffer = pending_scan_result-&gt;buffer;
+		uint8_t *buffer = pending_scan_result-&gt;buffer;
 		int length = pending_scan_result-&gt;length;
 		int first = pending_scan_result-&gt;first;
 		scan_command_t *command = pending_scan_result-&gt;command;
@@ -876,7 +876,7 @@
 				struct usb_interface_descriptor *desc = iface-&gt;altsetting;
 				for (int i = 0; i &lt; desc-&gt;bNumEndpoints; i++)
 				{
-					u8 epnum = desc-&gt;endpoint[i].bEndpointAddress;
+					uint8_t epnum = desc-&gt;endpoint[i].bEndpointAddress;
 					bool is_input = epnum &amp; 0x80;
 					LOG_DEBUG(&quot;usb ep %s %02x&quot;, is_input ? &quot;in&quot; : &quot;out&quot;, epnum);
 					if (is_input)
@@ -1054,7 +1054,7 @@
 #ifdef _DEBUG_USB_COMMS_
 #define BYTES_PER_LINE  16
 
-static void jlink_debug_buffer(u8 *buffer, int length)
+static void jlink_debug_buffer(uint8_t *buffer, int length)
 {
 	char line[81];
 	char s[4];

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/jtag.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -123,21 +123,21 @@
 	/// The number of bits this field specifies (up to 32)
 	int num_bits;
 	/// A pointer to value to be scanned into the device
-	u8* out_value;
+	uint8_t* out_value;
 	/// A pointer to a 32-bit memory location for data scanned out
-	u8* in_value;
+	uint8_t* in_value;
 
 	/// The value used to check the data scanned out.
-	u8* check_value;
+	uint8_t* check_value;
 	/// The mask to go with check_value
-	u8* check_mask;
+	uint8_t* check_mask;
 
 	/// in_value has been allocated for the queue
 	int allocated;
 	/// Indicates we modified the in_value.
 	int modified;
 	/// temporary storage for performing value checks synchronously
-	u8 intmp[4];
+	uint8_t intmp[4];
 } scan_field_t;
 
 typedef struct jtag_tap_event_action_s jtag_tap_event_action_t;
@@ -157,19 +157,19 @@
 	bool enabled;
 	int ir_length; /**&lt; size of instruction register */
 	u32 ir_capture_value;
-	u8* expected; /**&lt; Capture-IR expected value */
+	uint8_t* expected; /**&lt; Capture-IR expected value */
 	u32 ir_capture_mask;
-	u8* expected_mask; /**&lt; Capture-IR expected mask */
+	uint8_t* expected_mask; /**&lt; Capture-IR expected mask */
 	u32 idcode;
 	/**&lt; device identification code */
 
 	/// Array of expected identification codes */
 	u32* expected_ids;
 	/// Number of expected identification codes
-	u8 expected_ids_cnt;
+	uint8_t expected_ids_cnt;
 
 	/// current instruction
-	u8* cur_instr;
+	uint8_t* cur_instr;
 	/// Bypass register selected
 	int bypass;
 
@@ -393,10 +393,10 @@
  * For conversion types or checks that can fail, use the more complete
  * variant: jtag_callback_t.
  */
-typedef void (*jtag_callback1_t)(u8 *in);
+typedef void (*jtag_callback1_t)(uint8_t *in);
 
 /// A simpler version of jtag_add_callback4().
-extern void jtag_add_callback(jtag_callback1_t, u8 *in);
+extern void jtag_add_callback(jtag_callback1_t, uint8_t *in);
 
 
 /**
@@ -414,7 +414,7 @@
  * @param data3 An integer big enough to use as an @c int or a pointer.
  * @returns an error code
  */
-typedef int (*jtag_callback_t)(u8 *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3);
+typedef int (*jtag_callback_t)(uint8_t *in, jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3);
 
 
 /**
@@ -445,7 +445,7 @@
  * @param data3 An integer big enough to use as an @c int or a pointer.
  *
  */
-extern void jtag_add_callback4(jtag_callback_t f, u8 *in,
+extern void jtag_add_callback4(jtag_callback_t f, uint8_t *in,
 		jtag_callback_data_t data1, jtag_callback_data_t data2,
 		jtag_callback_data_t data3);
 
@@ -646,7 +646,7 @@
  * @param mask Pointer to scan mask; may be NULL.
  * @returns Nothing, but calls jtag_set_error() on any error.
  */
-extern void jtag_check_value_mask(scan_field_t *field, u8 *value, u8 *mask);
+extern void jtag_check_value_mask(scan_field_t *field, uint8_t *value, uint8_t *mask);
 
 extern void jtag_sleep(u32 us);
 

Modified: trunk/src/jtag/minidriver.h
===================================================================
--- trunk/src/jtag/minidriver.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/minidriver.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -59,7 +59,7 @@
 	if (field-&gt;num_bits &gt; 32)
 	{
 		unsigned num_bytes = TAP_SCAN_BYTES(field-&gt;num_bits);
-		field-&gt;in_value = (u8 *)malloc(num_bytes);
+		field-&gt;in_value = (uint8_t *)malloc(num_bytes);
 		field-&gt;allocated = 1;
 	}
 	else
@@ -72,22 +72,22 @@
 
 static inline void interface_jtag_alloc_in_value32(scan_field_t *field)
 {
-	field-&gt;in_value = (u8 *)cmd_queue_alloc(4);
+	field-&gt;in_value = (uint8_t *)cmd_queue_alloc(4);
 }
 
 static inline void interface_jtag_add_scan_check_alloc(scan_field_t *field)
 {
 	unsigned num_bytes = TAP_SCAN_BYTES(field-&gt;num_bits);
-	field-&gt;in_value = (u8 *)cmd_queue_alloc(num_bytes);
+	field-&gt;in_value = (uint8_t *)cmd_queue_alloc(num_bytes);
 }
 
 extern void interface_jtag_add_dr_out(jtag_tap_t* tap,
 		int num_fields, const int* num_bits, const u32* value,
 		tap_state_t end_state);
 
-extern void interface_jtag_add_callback(jtag_callback1_t f, u8 *in);
+extern void interface_jtag_add_callback(jtag_callback1_t f, uint8_t *in);
 
-extern void interface_jtag_add_callback4(jtag_callback_t f, u8 *in,
+extern void interface_jtag_add_callback4(jtag_callback_t f, uint8_t *in,
 		jtag_callback_data_t data1, jtag_callback_data_t data2,
 		jtag_callback_data_t data3);
 

Modified: trunk/src/jtag/minidummy/minidummy.c
===================================================================
--- trunk/src/jtag/minidummy/minidummy.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/minidummy/minidummy.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -57,7 +57,7 @@
 
 
 
-extern int jtag_check_value(u8 *captured, void *priv);
+extern int jtag_check_value(uint8_t *captured, void *priv);
 
 int interface_jtag_set_end_state(tap_state_t state)
 {
@@ -178,7 +178,7 @@
 
 
 
-void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, u8 *buffer, int little, int count)
+void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, uint8_t *buffer, int little, int count)
 {
 	int i;
 	for (i = 0; i &lt; count; i++)

Modified: trunk/src/jtag/parport.c
===================================================================
--- trunk/src/jtag/parport.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/parport.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -62,17 +62,17 @@
 typedef struct cable_s
 {
 	char* name;
-	u8 TDO_MASK;	/* status port bit containing current TDO value */
-	u8 TRST_MASK;	/* data port bit for TRST */
-	u8 TMS_MASK;	/* data port bit for TMS */
-	u8 TCK_MASK;	/* data port bit for TCK */
-	u8 TDI_MASK;	/* data port bit for TDI */
-	u8 SRST_MASK;	/* data port bit for SRST */
-	u8 OUTPUT_INVERT;	/* data port bits that should be inverted */
-	u8 INPUT_INVERT;	/* status port that should be inverted */
-	u8 PORT_INIT;	/* initialize data port with this value */
-	u8 PORT_EXIT;	/* de-initialize data port with this value */
-	u8 LED_MASK;	/* data port bit for LED */
+	uint8_t TDO_MASK;	/* status port bit containing current TDO value */
+	uint8_t TRST_MASK;	/* data port bit for TRST */
+	uint8_t TMS_MASK;	/* data port bit for TMS */
+	uint8_t TCK_MASK;	/* data port bit for TCK */
+	uint8_t TDI_MASK;	/* data port bit for TDI */
+	uint8_t SRST_MASK;	/* data port bit for SRST */
+	uint8_t OUTPUT_INVERT;	/* data port bits that should be inverted */
+	uint8_t INPUT_INVERT;	/* status port that should be inverted */
+	uint8_t PORT_INIT;	/* initialize data port with this value */
+	uint8_t PORT_EXIT;	/* de-initialize data port with this value */
+	uint8_t LED_MASK;	/* data port bit for LED */
 } cable_t;
 
 static cable_t cables[] =
@@ -109,7 +109,7 @@
 /* interface variables
  */
 static cable_t* cable;
-static u8 dataport_value = 0x0;
+static uint8_t dataport_value = 0x0;
 
 #if PARPORT_USE_PPDEV == 1
 static int device_handle;
@@ -173,7 +173,7 @@
 
 static __inline__ void parport_write_data(void)
 {
-	u8 output;
+	uint8_t output;
 	output = dataport_value ^ cable-&gt;OUTPUT_INVERT;
 
 #if PARPORT_USE_PPDEV == 1

Modified: trunk/src/jtag/presto.c
===================================================================
--- trunk/src/jtag/presto.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/presto.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -98,10 +98,10 @@
 
 	char serial[FT_DEVICE_SERNUM_LEN];
 
-	u8 buff_out[BUFFER_SIZE];
+	uint8_t buff_out[BUFFER_SIZE];
 	int buff_out_pos;
 
-	u8 buff_in[BUFFER_SIZE];
+	uint8_t buff_in[BUFFER_SIZE];
 	int buff_in_exp; /* expected in buffer length */
 	int buff_in_len; /* length of data received */
 	int buff_in_pos;
@@ -123,12 +123,12 @@
 static presto_t presto_state;
 static presto_t *presto = &amp;presto_state;
 
-static u8 presto_init_seq[] =
+static uint8_t presto_init_seq[] =
 {
 	0x80, 0xA0, 0xA8, 0xB0, 0xC0, 0xE0
 };
 
-static int presto_write(u8 *buf, u32 size)
+static int presto_write(uint8_t *buf, u32 size)
 {
 #if BUILD_PRESTO_FTD2XX == 1
 	DWORD ftbytes;
@@ -157,7 +157,7 @@
 	return ERROR_OK;
 }
 
-static int presto_read(u8* buf, u32 size)
+static int presto_read(uint8_t* buf, u32 size)
 {
 #if BUILD_PRESTO_FTD2XX == 1
 	DWORD ftbytes;
@@ -332,7 +332,7 @@
 #elif BUILD_PRESTO_LIBFTDI == 1
 static int presto_open_libftdi(char *req_serial)
 {
-	u8 presto_data;
+	uint8_t presto_data;
 
 	LOG_DEBUG(&quot;searching for PRESTO using libftdi&quot;);
 
@@ -521,7 +521,7 @@
 
 	if (presto-&gt;buff_out_pos &lt; BUFFER_SIZE)
 	{
-		presto-&gt;buff_out[presto-&gt;buff_out_pos++] = (u8)data;
+		presto-&gt;buff_out[presto-&gt;buff_out_pos++] = (uint8_t)data;
 		if (((data &amp; 0xC0) == 0x40) || ((data &amp; 0xD0)== 0xD0))
 			presto-&gt;buff_in_exp++;
 	}

Modified: trunk/src/jtag/rlink/rlink.c
===================================================================
--- trunk/src/jtag/rlink/rlink.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/rlink/rlink.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -327,17 +327,17 @@
 int
 dtc_load_from_buffer(
 	usb_dev_handle	*pHDev,
-	const u8		*buffer,
+	const uint8_t		*buffer,
 	size_t			length
 ) {
 	struct header_s {
-		u8	type;
-		u8	length;
+		uint8_t	type;
+		uint8_t	length;
 	};
 
 	int				usb_err;
 	struct header_s	*header;
-	u8				lut_start = 0xc0;
+	uint8_t				lut_start = 0xc0;
 
 	dtc_entry_download = 0;
 
@@ -439,7 +439,7 @@
 int
 dtc_start_download(void) {
 	int	usb_err;
-	u8	ep2txr;
+	uint8_t	ep2txr;
 
 	/* set up for download mode and make sure EP2 is set up to transmit */
 	usb_err = ep1_generic_commandl(
@@ -497,12 +497,12 @@
 int
 dtc_run_download(
 	usb_dev_handle	*pHDev,
-	u8	*command_buffer,
+	uint8_t	*command_buffer,
 	int	command_buffer_size,
-	u8	*reply_buffer,
+	uint8_t	*reply_buffer,
 	int	reply_buffer_size
 ) {
-	u8	ep2_buffer[USB_EP2IN_SIZE];
+	uint8_t	ep2_buffer[USB_EP2IN_SIZE];
 	int	usb_err;
 	int	i;
 
@@ -582,7 +582,7 @@
 	jtag_command_t	*cmd;	/* the command that resulted in this entry */
 
 	struct {
-		u8		*buffer;	/* the scan buffer */
+		uint8_t		*buffer;	/* the scan buffer */
 		int		size;		/* size of the scan buffer in bits */
 		int		offset;		/* how many bits were already done before this? */
 		int		length;		/* how many bits are processed in this operation? */
@@ -602,7 +602,7 @@
 	dtc_reply_queue_entry_t	*rq_tail;
 	u32			cmd_index;
 	u32			reply_index;
-	u8			cmd_buffer[USB_EP2BANK_SIZE];
+	uint8_t			cmd_buffer[USB_EP2BANK_SIZE];
 } dtc_queue;
 
 
@@ -634,7 +634,7 @@
 dtc_reply_queue_entry_t *
 dtc_queue_enqueue_reply(
 	enum scan_type	type,
-	u8				*buffer,
+	uint8_t				*buffer,
 	int				size,
 	int				offset,
 	int				length,
@@ -677,9 +677,9 @@
 	int			usb_err;
 	int			bit_cnt;
 	int			x;
-	u8			*dtc_p, *tdo_p;
-	u8			dtc_mask, tdo_mask;
-	u8			reply_buffer[USB_EP2IN_SIZE];
+	uint8_t			*dtc_p, *tdo_p;
+	uint8_t			dtc_mask, tdo_mask;
+	uint8_t			reply_buffer[USB_EP2IN_SIZE];
 
 	retval = ERROR_OK;
 
@@ -827,7 +827,7 @@
 tap_state_queue_run(void) {
 	int	i;
 	int	bits;
-	u8	byte;
+	uint8_t	byte;
 	int	retval;
 
 	retval = 0;
@@ -881,7 +881,7 @@
 static
 int
 tap_state_queue_append(
-	u8	tms
+	uint8_t	tms
 ) {
 	int	retval;
 
@@ -916,7 +916,7 @@
 void rlink_state_move(void) {
 
 	int i=0, tms=0;
-	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	for (i = 0; i &lt; tms_count; i++)
@@ -994,7 +994,7 @@
 static
 void rlink_reset(int trst, int srst)
 {
-	u8			bitmap;
+	uint8_t			bitmap;
 	int			usb_err;
 
 	/* Read port A for bit op */
@@ -1093,7 +1093,7 @@
 rlink_scan(
 	jtag_command_t	*cmd,
 	enum scan_type	type,
-	u8			*buffer,
+	uint8_t			*buffer,
 	int			scan_size
 ) {
 	bool		ir_scan;
@@ -1105,8 +1105,8 @@
 	int			x;
 
 	int			tdi_bit_offset;
-	u8			tdi_mask, *tdi_p;
-	u8			dtc_mask;
+	uint8_t			tdi_mask, *tdi_p;
+	uint8_t			dtc_mask;
 
 	if(scan_size &lt; 1) {
 		LOG_ERROR(&quot;scan_size cannot be less than 1 bit\n&quot;);
@@ -1382,7 +1382,7 @@
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 	int retval, tmp_retval;
 
 	/* return ERROR_OK, unless something goes wrong */
@@ -1622,7 +1622,7 @@
 	int i, j, retries;
 	int found=0;
 	int success=0;
-	u8 reply_buffer[USB_EP1IN_SIZE];
+	uint8_t reply_buffer[USB_EP1IN_SIZE];
 
 	usb_init();
 	usb_find_busses();

Modified: trunk/src/jtag/rlink/rlink.h
===================================================================
--- trunk/src/jtag/rlink/rlink.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/rlink/rlink.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -22,10 +22,10 @@
 
 typedef
 struct rlink_speed_table_s {
-	u8 const	*dtc;
+	uint8_t const	*dtc;
 	u16			dtc_size;
 	u16			khz;
-	u8			prescaler;
+	uint8_t			prescaler;
 } rlink_speed_table_t;
 
 extern const rlink_speed_table_t	rlink_speed_table[];

Modified: trunk/src/jtag/rlink/rlink_speed_table.c
===================================================================
--- trunk/src/jtag/rlink/rlink_speed_table.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/rlink/rlink_speed_table.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -6,7 +6,7 @@
 #include &quot;rlink.h&quot;
 #include &quot;st7.h&quot;
 
-static const u8 dtc_64[] = {
+static const uint8_t dtc_64[] = {
 	0, 2, 68, 84, 67, 2, 13, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
 	191, 143, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0, 42, 42,
 	42, 73, 0, 88, 0, 160, 189, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100, 111, 119,
@@ -27,7 +27,7 @@
 	60, 97, 203, 8, 2, 36, 139, 124, 193, 151, 96
 };
 
-static const u8 dtc_11[] = {
+static const uint8_t dtc_11[] = {
 	0, 2, 68, 84, 67, 2, 13, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
 	188, 143, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0, 42, 42,
 	42, 73, 0, 88, 0, 154, 183, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100, 111, 119,
@@ -47,7 +47,7 @@
 	203, 8, 2, 36, 139, 117, 193, 151, 96
 };
 
-static const u8 dtc_8[] = {
+static const uint8_t dtc_8[] = {
 	0, 2, 68, 84, 67, 2, 13, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
 	187, 143, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0, 42, 42,
 	42, 73, 0, 88, 0, 152, 181, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100, 111, 119,
@@ -67,7 +67,7 @@
 	8, 2, 36, 139, 115, 193, 151, 96
 };
 
-static const u8 dtc_2[] = {
+static const uint8_t dtc_2[] = {
 	0, 2, 68, 84, 67, 2, 14, 160, 176, 151, 147, 182, 141, 152, 177, 129, 148,
 	186, 143, 185, 142, 5, 3, 0, 0, 0, 2, 68, 84, 67, 4, 0, 192, 5, 15, 0,
 	42, 42, 42, 73, 0, 88, 0, 149, 178, 0, 0, 0, 0, 106, 9, 1, 8, 22, 100,

Modified: trunk/src/jtag/usbprog.c
===================================================================
--- trunk/src/jtag/usbprog.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/usbprog.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -59,7 +59,7 @@
 static void usbprog_state_move(void);
 static void usbprog_path_move(pathmove_command_t *cmd);
 static void usbprog_runtest(int num_cycles);
-static void usbprog_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size);
+static void usbprog_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size);
 
 jtag_interface_t usbprog_interface =
 {
@@ -130,7 +130,7 @@
 	jtag_command_t *cmd = jtag_command_queue; /* currently processed command */
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 
 	while (cmd)
 	{
@@ -237,7 +237,7 @@
 static void usbprog_state_move(void)
 {
 	int i = 0, tms = 0;
-	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	usbprog_jtag_write_tms(usbprog_jtag_handle, (char)tms_scan);
@@ -328,7 +328,7 @@
 	*/
 }
 
-static void usbprog_scan(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size)
+static void usbprog_scan(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
 

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/vsllink.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -39,10 +39,10 @@
 
 static u16 vsllink_usb_vid;
 static u16 vsllink_usb_pid;
-static u8 vsllink_usb_bulkout;
-static u8 vsllink_usb_bulkin;
-static u8 vsllink_usb_interface;
-static u8 vsllink_mode = VSLLINK_MODE_NORMAL;
+static uint8_t vsllink_usb_bulkout;
+static uint8_t vsllink_usb_bulkin;
+static uint8_t vsllink_usb_interface;
+static uint8_t vsllink_mode = VSLLINK_MODE_NORMAL;
 static int VSLLINK_USB_TIMEOUT = 10000;
 
 static int VSLLINK_BufferSize = 1024;
@@ -50,8 +50,8 @@
 /* Global USB buffers */
 static int vsllink_usb_out_buffer_idx;
 static int vsllink_usb_in_want_length;
-static u8* vsllink_usb_in_buffer = NULL;
-static u8* vsllink_usb_out_buffer = NULL;
+static uint8_t* vsllink_usb_in_buffer = NULL;
+static uint8_t* vsllink_usb_out_buffer = NULL;
 
 /* Constants for VSLLink command */
 #define VSLLINK_CMD_CONN			0x80
@@ -94,7 +94,7 @@
  *
  * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
  */
-static u8 VSLLINK_tap_move[6][6] =
+static uint8_t VSLLINK_tap_move[6][6] =
 {
 /*	  TLR   RTI   SD    PD    SI    PI             */
 	{0xff, 0x7f, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
@@ -158,7 +158,7 @@
 	{0,		0,}},	/* PI  */
 };
 
-static u8 VSLLINK_BIT_MSK[8] =
+static uint8_t VSLLINK_BIT_MSK[8] =
 {
 	0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f
 };
@@ -168,7 +168,7 @@
 	int offset;
 	int length; /* Number of bits to read */
 	scan_command_t *command; /* Corresponding scan command */
-	u8 *buffer;
+	uint8_t *buffer;
 } pending_scan_result_t;
 
 #define MAX_PENDING_SCAN_RESULTS 256
@@ -205,11 +205,11 @@
 static void vsllink_stableclocks_dma(int num_cycles, int tms);
 static void vsllink_stableclocks_normal(int num_cycles, int tms);
 static void (*vsllink_stableclocks)(int num_cycles, int tms);
-static void vsllink_scan_dma(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
-static void vsllink_scan_normal(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
-static void (*vsllink_scan)(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+static void vsllink_scan_dma(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command);
+static void vsllink_scan_normal(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command);
+static void (*vsllink_scan)(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command);
 static void vsllink_reset(int trst, int srst);
-static void vsllink_simple_command(u8 command);
+static void vsllink_simple_command(uint8_t command);
 static int vsllink_connect(void);
 static int vsllink_disconnect(void);
 
@@ -224,8 +224,8 @@
 static void vsllink_tap_ensure_space_dma(int scans, int length);
 static void vsllink_tap_ensure_space_normal(int scans, int length);
 static void (*vsllink_tap_ensure_space)(int scans, int length);
-static void vsllink_tap_append_scan_dma(int length, u8 *buffer, scan_command_t *command);
-static void vsllink_tap_append_scan_normal(int length, u8 *buffer, scan_command_t *command, int offset);
+static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, scan_command_t *command);
+static void vsllink_tap_append_scan_normal(int length, uint8_t *buffer, scan_command_t *command, int offset);
 
 /* VSLLink lowlevel functions */
 typedef struct vsllink_jtag
@@ -240,17 +240,17 @@
 static int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag);
 
 #if defined _DEBUG_USB_COMMS_ || defined _DEBUG_JTAG_IO_
-static void vsllink_debug_buffer(u8 *buffer, int length);
+static void vsllink_debug_buffer(uint8_t *buffer, int length);
 #endif
 
 static int vsllink_tms_data_len = 0;
-static u8* vsllink_tms_cmd_pos;
+static uint8_t* vsllink_tms_cmd_pos;
 
 static int tap_length = 0;
 static int tap_buffer_size = 0;
-static u8 *tms_buffer = NULL;
-static u8 *tdi_buffer = NULL;
-static u8 *tdo_buffer = NULL;
+static uint8_t *tms_buffer = NULL;
+static uint8_t *tdi_buffer = NULL;
+static uint8_t *tdo_buffer = NULL;
 static int last_tms;
 
 static vsllink_jtag_t* vsllink_jtag_handle = NULL;
@@ -288,7 +288,7 @@
 	jtag_command_t *cmd = jtag_command_queue;
 	int scan_size;
 	enum scan_type type;
-	u8 *buffer;
+	uint8_t *buffer;
 
 	DEBUG_JTAG_IO(&quot;--------------------------------- vsllink -------------------------------------&quot;);
 
@@ -491,9 +491,9 @@
 			if (vsllink_mode == VSLLINK_MODE_DMA)
 			{
 				tap_buffer_size = (VSLLINK_BufferSize - 3) / 2;
-				tms_buffer = (u8*)malloc(tap_buffer_size);
-				tdi_buffer = (u8*)malloc(tap_buffer_size);
-				tdo_buffer = (u8*)malloc(tap_buffer_size);
+				tms_buffer = (uint8_t*)malloc(tap_buffer_size);
+				tdi_buffer = (uint8_t*)malloc(tap_buffer_size);
+				tdo_buffer = (uint8_t*)malloc(tap_buffer_size);
 				if ((tms_buffer == NULL) || (tdi_buffer == NULL) || (tdo_buffer == NULL))
 				{
 					LOG_ERROR(&quot;Not enough memory&quot;);
@@ -626,7 +626,7 @@
 // length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set, no need to set it here.
 static void vsllink_append_tms(void)
 {
-	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	u16 tms2;
 	insert_insignificant_operation_t *insert = \
 		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
@@ -691,7 +691,7 @@
 	int i, insert_length = (tap_length % 8) ? (8 - (tap_length % 8)) : 0;
 	insert_insignificant_operation_t *insert = \
 		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
-	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
+	uint8_t tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 
 	if (tap_get_state() == TAP_RESET)
 	{
@@ -980,14 +980,14 @@
 				// just add to vsllink_tms_data_len
 				// same result if tun through
 				//vsllink_tms_data_len += num_cycles;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= (u8)(tms_append_byte &amp; 0xFF);
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= (uint8_t)(tms_append_byte &amp; 0xFF);
 			}
 			else if (tms_len == 8)
 			{
 				// end last tms shift command
 				// just reduce it, and append last tms byte
 				(*vsllink_tms_cmd_pos)--;
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
 			}
 			else if (tms_len &lt; 16)
 			{
@@ -997,8 +997,8 @@
 					// there is enought tms length in the current tms shift command
 					// increase the tms byte length by 1 and set the last byte to 0
 					(*vsllink_tms_cmd_pos)++;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (u8)(tms_append_byte &gt;&gt; 8);
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (uint8_t)(tms_append_byte &gt;&gt; 8);
 				}
 				else
 				{
@@ -1008,19 +1008,19 @@
 					// first decrease byte length of last tms shift command
 					(*vsllink_tms_cmd_pos)--;
 					// append last tms byte and move the command pointer to the next empty position
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
 					// add new command(3 bytes)
 					vsllink_tap_ensure_space(0, 3);
 					vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
-					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (u8)(tms_append_byte &gt;&gt; 8);
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = (uint8_t)(tms_append_byte &gt;&gt; 8);
 				}
 			}
 			else if (tms_len == 16)
 			{
 				// end last tms shift command
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
-				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte &gt;&gt; 8);
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (uint8_t)(tms_append_byte &gt;&gt; 8);
 			}
 
 			vsllink_tms_data_len = tms_len &amp; 7;
@@ -1033,8 +1033,8 @@
 		else
 		{
 			// more shifts will be needed
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
-			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte &gt;&gt; 8);
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (uint8_t)(tms_append_byte &amp; 0xFF);
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (uint8_t)(tms_append_byte &gt;&gt; 8);
 
 			num_cycles -= 16 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
@@ -1172,10 +1172,10 @@
 	}
 }
 
-static void vsllink_scan_normal(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void vsllink_scan_normal(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
-	u8 bits_left, tms_tmp, tdi_len;
+	uint8_t bits_left, tms_tmp, tdi_len;
 	int i;
 
 	if (0 == scan_size )
@@ -1288,7 +1288,7 @@
 
 	tap_set_state(tap_get_end_state());
 }
-static void vsllink_scan_dma(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+static void vsllink_scan_dma(bool ir_scan, enum scan_type type, uint8_t *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
 
@@ -1342,7 +1342,7 @@
 	}
 }
 
-static void vsllink_simple_command(u8 command)
+static void vsllink_simple_command(uint8_t command)
 {
 	int result;
 
@@ -1505,7 +1505,7 @@
 	if (index &lt; tap_buffer_size)
 	{
 		int bit_index = tap_length % 8;
-		u8 bit = 1 &lt;&lt; bit_index;
+		uint8_t bit = 1 &lt;&lt; bit_index;
 
 		if (tms)
 		{
@@ -1533,7 +1533,7 @@
 	}
 }
 
-static void vsllink_tap_append_scan_normal(int length, u8 *buffer, scan_command_t *command, int offset)
+static void vsllink_tap_append_scan_normal(int length, uint8_t *buffer, scan_command_t *command, int offset)
 {
 	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 	int i;
@@ -1558,7 +1558,7 @@
 
 	pending_scan_results_length++;
 }
-static void vsllink_tap_append_scan_dma(int length, u8 *buffer, scan_command_t *command)
+static void vsllink_tap_append_scan_dma(int length, uint8_t *buffer, scan_command_t *command)
 {
 	pending_scan_result_t *pending_scan_result;
 	int len_tmp, len_all, i;
@@ -1639,7 +1639,7 @@
 			for (i = 0; i &lt; pending_scan_results_length; i++)
 			{
 				pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[i];
-				u8 *buffer = pending_scan_result-&gt;buffer;
+				uint8_t *buffer = pending_scan_result-&gt;buffer;
 				int length = pending_scan_result-&gt;length;
 				int offset = pending_scan_result-&gt;offset;
 				scan_command_t *command = pending_scan_result-&gt;command;
@@ -1712,7 +1712,7 @@
 			for (i = 0; i &lt; pending_scan_results_length; i++)
 			{
 				pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[i];
-				u8 *buffer = pending_scan_result-&gt;buffer;
+				uint8_t *buffer = pending_scan_result-&gt;buffer;
 				int length = pending_scan_result-&gt;length;
 				int first = pending_scan_result-&gt;offset;
 
@@ -1910,7 +1910,7 @@
 #define BYTES_PER_LINE  16
 
 #if defined _DEBUG_USB_COMMS_ || defined _DEBUG_JTAG_IO_
-static void vsllink_debug_buffer(u8 *buffer, int length)
+static void vsllink_debug_buffer(uint8_t *buffer, int length)
 {
 	char line[81];
 	char s[4];

Modified: trunk/src/jtag/zy1000/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000/zy1000.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/jtag/zy1000/zy1000.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -424,7 +424,7 @@
 }
 #endif
 
-extern int jtag_check_value(u8 *captured, void *priv);
+extern int jtag_check_value(uint8_t *captured, void *priv);
 
 static __inline void scanFields(int num_fields, scan_field_t *fields, tap_state_t shiftState, tap_state_t end_state)
 {
@@ -436,9 +436,9 @@
 	{
 		cyg_uint32 value;
 
-		static u8 *in_buff=NULL; /* pointer to buffer for scanned data */
+		static uint8_t *in_buff=NULL; /* pointer to buffer for scanned data */
 		static int in_buff_size=0;
-		u8 *inBuffer=NULL;
+		uint8_t *inBuffer=NULL;
 
 
 		// figure out where to store the input data
@@ -545,7 +545,7 @@
 		if (!found)
 		{
 			/* if a device isn't listed, set it to BYPASS */
-			u8 ones[]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
+			uint8_t ones[]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
 
 			scan_field_t tmp;
 			memset(&amp;tmp, 0, sizeof(tmp));
@@ -668,7 +668,7 @@
 	tap_state_t t=TAP_IDLE;
 	/* test manual drive code on any target */
 	int tms;
-	u8 tms_scan = tap_get_tms_path(t, state);
+	uint8_t tms_scan = tap_get_tms_path(t, state);
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
 
 	for (i = 0; i &lt; tms_count; i++)
@@ -744,7 +744,7 @@
 
 
 
-void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, u8 *buffer, int little, int count)
+void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, uint8_t *buffer, int little, int count)
 {
 //	static int const reg_addr=0x5;
 	tap_state_t end_state=jtag_get_end_state();

Modified: trunk/src/pld/virtex2.c
===================================================================
--- trunk/src/pld/virtex2.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/pld/virtex2.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -66,7 +66,7 @@
 {
 	virtex2_pld_device_t *virtex2_info = pld_device-&gt;driver_priv;
 	scan_field_t scan_field;
-	u8 *values;
+	uint8_t *values;
 	int i;
 
 	values = malloc(num_words * 4);
@@ -88,7 +88,7 @@
 	return ERROR_OK;
 }
 
-static __inline__ void virtexflip32(u8 *in)
+static __inline__ void virtexflip32(uint8_t *in)
 {
 	*((u32 *)in) = flip_u32(le_to_h_u32(in), 32);
 }
@@ -108,11 +108,11 @@
 
 	while (num_words--)
 	{
-		scan_field.in_value = (u8 *)words;
+		scan_field.in_value = (uint8_t *)words;
 
 		jtag_add_dr_scan(1, &amp;scan_field, jtag_set_end_state(TAP_DRPAUSE));
 
-		jtag_add_callback(virtexflip32, (u8 *)words);
+		jtag_add_callback(virtexflip32, (uint8_t *)words);
 
 		words++;;
 	}

Modified: trunk/src/pld/xilinx_bit.c
===================================================================
--- trunk/src/pld/xilinx_bit.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/pld/xilinx_bit.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -29,9 +29,9 @@
 
 
 static int read_section(FILE *input_file, int length_size, char section,
-		u32 *buffer_length, u8 **buffer)
+		u32 *buffer_length, uint8_t **buffer)
 {
-	u8 length_buffer[4];
+	uint8_t length_buffer[4];
 	int length;
 	char section_char;
 	int read_count;

Modified: trunk/src/pld/xilinx_bit.h
===================================================================
--- trunk/src/pld/xilinx_bit.h	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/pld/xilinx_bit.h	2009-06-18 07:07:12 UTC (rev 2276)
@@ -24,13 +24,13 @@
 
 typedef struct xilinx_bit_file_s
 {
-	u8 unknown_header[13];
-	u8 *source_file;
-	u8 *part_name;
-	u8 *date;
-	u8 *time;
+	uint8_t unknown_header[13];
+	uint8_t *source_file;
+	uint8_t *part_name;
+	uint8_t *date;
+	uint8_t *time;
 	u32 length;
-	u8 *data;
+	uint8_t *data;
 } xilinx_bit_file_t;
 
 int xilinx_read_bit_file(xilinx_bit_file_t *bit_file, char *filename);

Modified: trunk/src/server/gdb_server.c
===================================================================
--- trunk/src/server/gdb_server.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/server/gdb_server.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -844,7 +844,7 @@
 	return ERROR_OK;
 }
 
-void gdb_send_error(connection_t *connection, u8 the_error)
+void gdb_send_error(connection_t *connection, uint8_t the_error)
 {
 	char err[4];
 	snprintf(err, 4, &quot;E%2.2X&quot;, the_error );
@@ -885,7 +885,7 @@
 {
 	int i;
 
-	u8 *buf;
+	uint8_t *buf;
 	int buf_len;
 	buf = reg-&gt;value;
 	buf_len = CEIL(reg-&gt;size, 8);
@@ -914,7 +914,7 @@
 }
 
 /* copy over in register buffer */
-void gdb_target_to_reg(target_t *target, char *tstr, int str_len, u8 *bin)
+void gdb_target_to_reg(target_t *target, char *tstr, int str_len, uint8_t *bin)
 {
 	if (str_len % 2)
 	{
@@ -925,7 +925,7 @@
 	int i;
 	for (i = 0; i &lt; str_len; i+=2)
 	{
-		u8 t = hextoint(tstr[i])&lt;&lt;4;
+		uint8_t t = hextoint(tstr[i])&lt;&lt;4;
 		t |= hextoint(tstr[i+1]);
 
 		int j = gdb_reg_pos(target, i/2, str_len/2);
@@ -1013,7 +1013,7 @@
 	packet_p = packet;
 	for (i = 0; i &lt; reg_list_size; i++)
 	{
-		u8 *bin_buf;
+		uint8_t *bin_buf;
 		int chars = (CEIL(reg_list[i]-&gt;size, 8) * 2);
 
 		if (packet_p + chars &gt; packet + packet_size)
@@ -1083,7 +1083,7 @@
 int gdb_set_register_packet(connection_t *connection, target_t *target, char *packet, int packet_size)
 {
 	char *separator;
-	u8 *bin_buf;
+	uint8_t *bin_buf;
 	int reg_num = strtoul(packet + 1, &amp;separator, 16);
 	reg_t **reg_list;
 	int reg_list_size;
@@ -1166,7 +1166,7 @@
 	u32 addr = 0;
 	u32 len = 0;
 
-	u8 *buffer;
+	uint8_t *buffer;
 	char *hex_buffer;
 
 	int retval = ERROR_OK;
@@ -1215,7 +1215,7 @@
 		u32 i;
 		for (i = 0; i &lt; len; i++)
 		{
-			u8 t = buffer[i];
+			uint8_t t = buffer[i];
 			hex_buffer[2 * i] = DIGITS[(t &gt;&gt; 4) &amp; 0xf];
 			hex_buffer[2 * i + 1] = DIGITS[t &amp; 0xf];
 		}
@@ -1240,7 +1240,7 @@
 	u32 addr = 0;
 	u32 len = 0;
 
-	u8 *buffer;
+	uint8_t *buffer;
 
 	u32 i;
 	int retval;
@@ -1323,7 +1323,7 @@
 	{
 		LOG_DEBUG(&quot;addr: 0x%8.8x, len: 0x%8.8x&quot;, addr, len);
 
-		retval = target_write_buffer(target, addr, len, (u8*)separator);
+		retval = target_write_buffer(target, addr, len, (uint8_t*)separator);
 	}
 
 	if (retval == ERROR_OK)
@@ -1918,7 +1918,7 @@
 		}
 
 		/* create new section with content from packet buffer */
-		if((retval = image_add_section(gdb_connection-&gt;vflash_image, addr, length, 0x0, (u8*)parse)) != ERROR_OK)
+		if((retval = image_add_section(gdb_connection-&gt;vflash_image, addr, length, 0x0, (uint8_t*)parse)) != ERROR_OK)
 		{
 			return retval;
 		}

Modified: trunk/src/svf/svf.c
===================================================================
--- trunk/src/svf/svf.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/svf/svf.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -132,10 +132,10 @@
 {
 	int len;
 	int data_mask;
-	u8 *tdi;
-	u8 *tdo;
-	u8 *mask;
-	u8 *smask;
+	uint8_t *tdi;
+	uint8_t *tdo;
+	uint8_t *mask;
+	uint8_t *smask;
 }svf_xxr_para_t;
 
 typedef struct
@@ -197,7 +197,7 @@
 
 static int svf_read_command_from_file(int fd);
 static int svf_check_tdo(void);
-static int svf_add_check_para(u8 enabled, int buffer_offset, int bit_len);
+static int svf_add_check_para(uint8_t enabled, int buffer_offset, int bit_len);
 static int svf_run_command(struct command_context_s *cmd_ctx, char *cmd_str);
 static int handle_svf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
@@ -209,7 +209,7 @@
 static jtag_tap_t *tap = NULL;
 
 #define SVF_MAX_BUFFER_SIZE_TO_COMMIT	(4 * 1024)
-static u8 *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
+static uint8_t *svf_tdi_buffer = NULL, *svf_tdo_buffer = NULL, *svf_mask_buffer = NULL;
 static int svf_buffer_index = 0, svf_buffer_size = 0;
 static int svf_quiet = 0;
 
@@ -300,7 +300,7 @@
 static int svf_add_statemove(tap_state_t state_to)
 {
 	tap_state_t state_from = cmd_queue_cur_state;
-	u8 index;
+	uint8_t index;
 
 	for (index = 0; index &lt; dimof(svf_statemoves); index++)
 	{
@@ -390,21 +390,21 @@
 	// in case current command cannot be commited, and next command is a bit scan command
 	// here is 32K bits for this big scan command, it should be enough
 	// buffer will be reallocated if buffer size is not enough
-	svf_tdi_buffer = (u8 *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
+	svf_tdi_buffer = (uint8_t *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
 	if (NULL == svf_tdi_buffer)
 	{
 		LOG_ERROR(&quot;not enough memory&quot;);
 		ret = ERROR_FAIL;
 		goto free_all;
 	}
-	svf_tdo_buffer = (u8 *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
+	svf_tdo_buffer = (uint8_t *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
 	if (NULL == svf_tdo_buffer)
 	{
 		LOG_ERROR(&quot;not enough memory&quot;);
 		ret = ERROR_FAIL;
 		goto free_all;
 	}
-	svf_mask_buffer = (u8 *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
+	svf_mask_buffer = (uint8_t *)malloc(2 * SVF_MAX_BUFFER_SIZE_TO_COMMIT);
 	if (NULL == svf_mask_buffer)
 	{
 		LOG_ERROR(&quot;not enough memory&quot;);
@@ -631,7 +631,7 @@
 	return 0xFF;
 }
 
-static int svf_adjust_array_length(u8 **arr, int orig_bit_len, int new_bit_len)
+static int svf_adjust_array_length(uint8_t **arr, int orig_bit_len, int new_bit_len)
 {
 	int new_byte_len = (new_bit_len + 7) &gt;&gt; 3;
 
@@ -642,7 +642,7 @@
 			free(*arr);
 			*arr = NULL;
 		}
-		*arr = (u8*)malloc(new_byte_len);
+		*arr = (uint8_t*)malloc(new_byte_len);
 		if (NULL == *arr)
 		{
 			LOG_ERROR(&quot;not enough memory&quot;);
@@ -653,10 +653,10 @@
 	return ERROR_OK;
 }
 
-static int svf_copy_hexstring_to_binary(char *str, u8 **bin, int orig_bit_len, int bit_len)
+static int svf_copy_hexstring_to_binary(char *str, uint8_t **bin, int orig_bit_len, int bit_len)
 {
 	int i, str_len = strlen(str), str_byte_len = (bit_len + 3) &gt;&gt; 2, loop_cnt;
-	u8 ch, need_write = 1;
+	uint8_t ch, need_write = 1;
 
 	if (ERROR_OK != svf_adjust_array_length(bin, orig_bit_len, bit_len))
 	{
@@ -770,7 +770,7 @@
 	return ERROR_OK;
 }
 
-static int svf_add_check_para(u8 enabled, int buffer_offset, int bit_len)
+static int svf_add_check_para(uint8_t enabled, int buffer_offset, int bit_len)
 {
 	if (svf_check_tdo_para_index &gt;= SVF_CHECK_TDO_PARA_SIZE)
 	{
@@ -816,7 +816,7 @@
 	float min_time, max_time;
 	// for XXR
 	svf_xxr_para_t *xxr_para_tmp;
-	u8 **pbuffer_tmp;
+	uint8_t **pbuffer_tmp;
 	scan_field_t field;
 	// for STATE
 	tap_state_t *path = NULL, state;
@@ -1011,10 +1011,10 @@
 				LOG_ERROR(&quot;buffer is not enough, report to author&quot;);
 				return ERROR_FAIL;
 #else
-				u8 *buffer_tmp;
+				uint8_t *buffer_tmp;
 
 				// reallocate buffer
-				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
+				buffer_tmp = (uint8_t *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
 				if (NULL == buffer_tmp)
 				{
 					LOG_ERROR(&quot;not enough memory&quot;);
@@ -1025,7 +1025,7 @@
 				free(svf_tdi_buffer);
 				svf_tdi_buffer = buffer_tmp;
 
-				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
+				buffer_tmp = (uint8_t *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
 				if (NULL == buffer_tmp)
 				{
 					LOG_ERROR(&quot;not enough memory&quot;);
@@ -1036,7 +1036,7 @@
 				free(svf_tdo_buffer);
 				svf_tdo_buffer = buffer_tmp;
 
-				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
+				buffer_tmp = (uint8_t *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
 				if (NULL == buffer_tmp)
 				{
 					LOG_ERROR(&quot;not enough memory&quot;);
@@ -1106,10 +1106,10 @@
 				LOG_ERROR(&quot;buffer is not enough, report to author&quot;);
 				return ERROR_FAIL;
 #else
-				u8 *buffer_tmp;
+				uint8_t *buffer_tmp;
 
 				// reallocate buffer
-				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
+				buffer_tmp = (uint8_t *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
 				if (NULL == buffer_tmp)
 				{
 					LOG_ERROR(&quot;not enough memory&quot;);
@@ -1120,7 +1120,7 @@
 				free(svf_tdi_buffer);
 				svf_tdi_buffer = buffer_tmp;
 
-				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
+				buffer_tmp = (uint8_t *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
 				if (NULL == buffer_tmp)
 				{
 					LOG_ERROR(&quot;not enough memory&quot;);
@@ -1131,7 +1131,7 @@
 				free(svf_tdo_buffer);
 				svf_tdo_buffer = buffer_tmp;
 
-				buffer_tmp = (u8 *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
+				buffer_tmp = (uint8_t *)malloc(svf_buffer_index + ((i + 7) &gt;&gt; 3));
 				if (NULL == buffer_tmp)
 				{
 					LOG_ERROR(&quot;not enough memory&quot;);

Modified: trunk/src/xsvf/xsvf.c
===================================================================
--- trunk/src/xsvf/xsvf.c	2009-06-18 07:06:25 UTC (rev 2275)
+++ trunk/src/xsvf/xsvf.c	2009-06-18 07:07:12 UTC (rev 2276)
@@ -169,7 +169,7 @@
 	return ERROR_OK;
 }
 
-static int xsvf_read_buffer(int num_bits, int fd, u8* buf)
+static int xsvf_read_buffer(int num_bits, int fd, uint8_t* buf)
 {
 	int num_bytes;
 
@@ -186,9 +186,9 @@
 
 static int handle_xsvf_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u8 *dr_out_buf = NULL; 				/* from host to device (TDI) */
-	u8 *dr_in_buf = NULL;				/* from device to host (TDO) */
-	u8 *dr_in_mask = NULL;
+	uint8_t *dr_out_buf = NULL; 				/* from host to device (TDI) */
+	uint8_t *dr_in_buf = NULL;				/* from device to host (TDO) */
+	uint8_t *dr_in_mask = NULL;
 
 	int xsdrsize = 0;
 	int xruntest = 0;					/* number of TCK cycles OR microseconds */
@@ -197,8 +197,8 @@
 	tap_state_t	xendir = TAP_IDLE;		/* see page 8 of the SVF spec, initial xendir to be TAP_IDLE */
 	tap_state_t xenddr = TAP_IDLE;
 
-	u8  		opcode;
-	u8		uc;
+	uint8_t  		opcode;
+	uint8_t		uc;
 	long		file_offset = 0;
 
 	int		loop_count = 0;
@@ -287,7 +287,7 @@
 
 		case XRUNTEST:
 			{
-				u8	xruntest_buf[4];
+				uint8_t	xruntest_buf[4];
 
 				if (read(xsvf_fd, xruntest_buf, 4) &lt; 0)
 				{
@@ -302,7 +302,7 @@
 
 		case XREPEAT:
 			{
-				u8 myrepeat;
+				uint8_t myrepeat;
 
 				if (read(xsvf_fd, &amp;myrepeat, 1) &lt; 0)
 					do_abort = 1;
@@ -316,7 +316,7 @@
 
 		case XSDRSIZE:
 			{
-				u8	xsdrsize_buf[4];
+				uint8_t	xsdrsize_buf[4];
 
 				if (read(xsvf_fd, xsdrsize_buf, 4) &lt; 0)
 				{
@@ -488,7 +488,7 @@
 		case XSTATE:
 			{
 				tap_state_t	mystate;
-				u8			uc;
+				uint8_t			uc;
 
 				if (read(xsvf_fd, &amp;uc, 1) &lt; 0)
 				{
@@ -578,8 +578,8 @@
 		case XSIR:
 		case XSIR2:
 			{
-				u8	short_buf[2];
-				u8*	ir_buf;
+				uint8_t	short_buf[2];
+				uint8_t*	ir_buf;
 				int bitcount;
 				tap_state_t my_end_state = xruntest ? TAP_IDLE : xendir;
 
@@ -678,12 +678,12 @@
 		case XWAIT:
 			{
 				/* expected in stream:
-				   XWAIT &lt;u8 wait_state&gt; &lt;u8 end_state&gt; &lt;u32 usecs&gt;
+				   XWAIT &lt;uint8_t wait_state&gt; &lt;uint8_t end_state&gt; &lt;u32 usecs&gt;
 				*/
 
-				u8	wait;
-				u8	end;
-				u8	delay_buf[4];
+				uint8_t	wait;
+				uint8_t	end;
+				uint8_t	delay_buf[4];
 
 				tap_state_t wait_state;
 				tap_state_t end_state;
@@ -719,13 +719,13 @@
 		case XWAITSTATE:
 			{
 				/* expected in stream:
-				   XWAITSTATE &lt;u8 wait_state&gt; &lt;u8 end_state&gt; &lt;u32 clock_count&gt; &lt;u32 usecs&gt;
+				   XWAITSTATE &lt;uint8_t wait_state&gt; &lt;uint8_t end_state&gt; &lt;u32 clock_count&gt; &lt;u32 usecs&gt;
 				*/
 
-				u8  clock_buf[4];
-				u8  	usecs_buf[4];
-				u8	wait;
-				u8	end;
+				uint8_t  clock_buf[4];
+				uint8_t  	usecs_buf[4];
+				uint8_t	wait;
+				uint8_t	end;
 				tap_state_t wait_state;
 				tap_state_t end_state;
 				int clock_count;
@@ -777,7 +777,7 @@
 				/* expected in stream:
 				   LCOUNT &lt;u32 loop_count&gt;
 				*/
-				u8  count_buf[4];
+				uint8_t  count_buf[4];
 
 				if ( read(xsvf_fd, count_buf, 4) &lt; 0 )
 				{
@@ -793,11 +793,11 @@
 		case LDELAY:
 			{
 				/* expected in stream:
-				   LDELAY &lt;u8 wait_state&gt; &lt;u32 clock_count&gt; &lt;u32 usecs_to_sleep&gt;
+				   LDELAY &lt;uint8_t wait_state&gt; &lt;u32 clock_count&gt; &lt;u32 usecs_to_sleep&gt;
 				*/
-				u8	state;
-				u8  clock_buf[4];
-				u8  usecs_buf[4];
+				uint8_t	state;
+				uint8_t  clock_buf[4];
+				uint8_t  usecs_buf[4];
 
 				if ( read(xsvf_fd, &amp;state, 1) &lt; 0
 				  || read(xsvf_fd, clock_buf, 4) &lt; 0
@@ -882,7 +882,7 @@
 
 		case XTRST:
 			{
-				u8	trst_mode;
+				uint8_t	trst_mode;
 
 				if (read(xsvf_fd, &amp;trst_mode, 1) &lt; 0)
 				{


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001059.html">[Openocd-svn] r2275 - trunk/src/flash
</A></li>
	<LI>Next message: <A HREF="001061.html">[Openocd-svn] r2277 - in trunk/src: flash helper jtag jtag/rlink	target
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1060">[ date ]</a>
              <a href="thread.html#1060">[ thread ]</a>
              <a href="subject.html#1060">[ subject ]</a>
              <a href="author.html#1060">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
