<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2398 - in trunk/src: flash helper
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2398%20-%20in%20trunk/src%3A%20flash%20helper&In-Reply-To=%3C200906240938.n5O9cPMY022710%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001181.html">
   <LINK REL="Next"  HREF="001183.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2398 - in trunk/src: flash helper</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2398%20-%20in%20trunk/src%3A%20flash%20helper&In-Reply-To=%3C200906240938.n5O9cPMY022710%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2398 - in trunk/src: flash helper">zwelch at mail.berlios.de
       </A><BR>
    <I>Wed Jun 24 11:38:25 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001181.html">[Openocd-svn] r2397 - in trunk/src: flash helper
</A></li>
        <LI>Next message: <A HREF="001183.html">[Openocd-svn] r2399 - trunk/src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1182">[ date ]</a>
              <a href="thread.html#1182">[ thread ]</a>
              <a href="subject.html#1182">[ subject ]</a>
              <a href="author.html#1182">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-24 11:38:21 +0200 (Wed, 24 Jun 2009)
New Revision: 2398

Modified:
   trunk/src/flash/at91sam3.c
   trunk/src/helper/membuf.c
   trunk/src/helper/membuf.h
Log:
Remove whitespace at end of lines, step 2.
- Replace '\s*$' with ''.


Modified: trunk/src/flash/at91sam3.c
===================================================================
--- trunk/src/flash/at91sam3.c	2009-06-24 09:38:15 UTC (rev 2397)
+++ trunk/src/flash/at91sam3.c	2009-06-24 09:38:21 UTC (rev 2398)
@@ -23,7 +23,7 @@
 
 /* BEGIN ATMEL COPYRIGHT */
 /* ----------------------------------------------------------------------------
- *         ATMEL Microcontroller Software Support 
+ *         ATMEL Microcontroller Software Support
  * ----------------------------------------------------------------------------
  * Copyright (c) 2009, Atmel Corporation
  *
@@ -130,7 +130,7 @@
 	uint32_t CHIPID_EXID;
 
 #define SAM3_SUPC_CR              (0x400E1210)
-	uint32_t SUPC_CR;             
+	uint32_t SUPC_CR;
 
 #define SAM3_PMC_BASE             (0x400E0400)
 #define SAM3_PMC_SCSR             (SAM3_PMC_BASE + 0x0008)
@@ -168,13 +168,13 @@
 	int probed;
 	// DANGER: THERE ARE DRAGONS HERE..
 	// NOTE: If you add more 'ghost' pointers
-	// be aware that you must *manually* update 
+	// be aware that you must *manually* update
 	// these pointers in the function sam3_GetDetails()
 	// See the comment &quot;Here there be dragons&quot;
 
 	// so we can find the chip we belong to
 	struct sam3_chip *pChip;
-	// so we can find the orginal bank pointer 
+	// so we can find the orginal bank pointer
 	flash_bank_t *pBank;
 	unsigned bank_number;
 	uint32_t controller_address;
@@ -268,14 +268,14 @@
 		.name           = &quot;at91sam3u4e&quot;,
 		.total_flash_size     = 256 * 1024,
 		.total_sram_size      = 52 * 1024,
-		.n_gpnvms       = 3, 
+		.n_gpnvms       = 3,
 		.n_banks        = 2,
 
 		// System boots at address 0x0
 		// gpnvm[1] = selects boot code
 		//     if gpnvm[1] == 0
 		//         boot is via &quot;SAMBA&quot; (rom)
-		//     else 
+		//     else
 		//         boot is via FLASH
 		//         Selection is via gpnvm[2]
 		//     endif
@@ -286,12 +286,12 @@
 		//      else
 		//         Bank1 is the boot rom
 		//      endif
-		.bank[0] = { 
+		.bank[0] = {
 			.probed = 0,
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE, 
+			.base_address = FLASH_BANK0_BASE,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -320,23 +320,23 @@
 		.name           = &quot;at91sam3u2e&quot;,
 		.total_flash_size     = 128 * 1024,
 		.total_sram_size      =  36 * 1024,
-		.n_gpnvms       = 2, 
+		.n_gpnvms       = 2,
 		.n_banks        = 1,
 
 		// System boots at address 0x0
 		// gpnvm[1] = selects boot code
 		//     if gpnvm[1] == 0
 		//         boot is via &quot;SAMBA&quot; (rom)
-		//     else 
+		//     else
 		//         boot is via FLASH
 		//         Selection is via gpnvm[2]
 		//     endif
-		.bank[0] = { 
+		.bank[0] = {
 			.probed = 0,
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE, 
+			.base_address = FLASH_BANK0_BASE,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -356,25 +356,25 @@
 		.name           = &quot;at91sam3u1e&quot;,
 		.total_flash_size     = 64 * 1024,
 		.total_sram_size      = 20 * 1024,
-		.n_gpnvms       = 2, 
+		.n_gpnvms       = 2,
 		.n_banks        = 1,
 
 		// System boots at address 0x0
 		// gpnvm[1] = selects boot code
 		//     if gpnvm[1] == 0
 		//         boot is via &quot;SAMBA&quot; (rom)
-		//     else 
+		//     else
 		//         boot is via FLASH
 		//         Selection is via gpnvm[2]
 		//     endif
 		//
-	
-		.bank[0] = { 
+
+		.bank[0] = {
 			.probed = 0,
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE, 
+			.base_address = FLASH_BANK0_BASE,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes =  64 * 1024,
@@ -389,20 +389,20 @@
 			.bank_number = 1,
 		},
 	},
-		
+
 	{
 		.chipid_cidr    = 0x28000960,
 		.name           = &quot;at91sam3u4c&quot;,
 		.total_flash_size     = 256 * 1024,
 		.total_sram_size      = 52 * 1024,
-		.n_gpnvms       = 3, 
+		.n_gpnvms       = 3,
 		.n_banks        = 2,
 
 		// System boots at address 0x0
 		// gpnvm[1] = selects boot code
 		//     if gpnvm[1] == 0
 		//         boot is via &quot;SAMBA&quot; (rom)
-		//     else 
+		//     else
 		//         boot is via FLASH
 		//         Selection is via gpnvm[2]
 		//     endif
@@ -413,12 +413,12 @@
 		//      else
 		//         Bank1 is the boot rom
 		//      endif
-		.bank[0] = { 
+		.bank[0] = {
 			.probed = 0,
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE, 
+			.base_address = FLASH_BANK0_BASE,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -447,23 +447,23 @@
 		.name           = &quot;at91sam3u2c&quot;,
 		.total_flash_size     = 128 * 1024,
 		.total_sram_size      = 36 * 1024,
-		.n_gpnvms       = 2, 
+		.n_gpnvms       = 2,
 		.n_banks        = 1,
 
 		// System boots at address 0x0
 		// gpnvm[1] = selects boot code
 		//     if gpnvm[1] == 0
 		//         boot is via &quot;SAMBA&quot; (rom)
-		//     else 
+		//     else
 		//         boot is via FLASH
 		//         Selection is via gpnvm[2]
 		//     endif
-		.bank[0] = { 
+		.bank[0] = {
 			.probed = 0,
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE, 
+			.base_address = FLASH_BANK0_BASE,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes = 128 * 1024,
@@ -483,25 +483,25 @@
 		.name           = &quot;at91sam3u1c&quot;,
 		.total_flash_size     = 64 * 1024,
 		.total_sram_size      = 20 * 1024,
-		.n_gpnvms       = 2, 
+		.n_gpnvms       = 2,
 		.n_banks        = 1,
 
 		// System boots at address 0x0
 		// gpnvm[1] = selects boot code
 		//     if gpnvm[1] == 0
 		//         boot is via &quot;SAMBA&quot; (rom)
-		//     else 
+		//     else
 		//         boot is via FLASH
 		//         Selection is via gpnvm[2]
 		//     endif
 		//
-	
-		.bank[0] = { 
+
+		.bank[0] = {
 			.probed = 0,
 			.pChip  = NULL,
 			.pBank  = NULL,
 			.bank_number = 0,
-			.base_address = FLASH_BANK0_BASE, 
+			.base_address = FLASH_BANK0_BASE,
 			.controller_address = 0x400e0800,
 			.present = 1,
 			.size_bytes =  64 * 1024,
@@ -518,7 +518,7 @@
 	},
 
 	// terminate
-	{ 
+	{
 		.chipid_cidr	= 0,
 		.name			= NULL,
 	}
@@ -539,17 +539,17 @@
  * @param pPrivate - info about the bank
  * @param v        - result goes here
  */
-static int 
+static int
 EFC_GetStatus(struct sam3_bank_private *pPrivate, uint32_t *v)
 {
 	int r;
 	r = target_read_u32(pPrivate-&gt;pChip-&gt;target, pPrivate-&gt;controller_address + offset_EFC_FSR, v);
-	LOG_DEBUG(&quot;Status: 0x%08x (lockerror: %d, cmderror: %d, ready: %d)&quot;, 
+	LOG_DEBUG(&quot;Status: 0x%08x (lockerror: %d, cmderror: %d, ready: %d)&quot;,
 			  (unsigned int)(*v),
 			  ((unsigned int)((*v &gt;&gt; 2) &amp; 1)),
 			  ((unsigned int)((*v &gt;&gt; 1) &amp; 1)),
 			  ((unsigned int)((*v &gt;&gt; 0) &amp; 1)));
-			  
+
 	return r;
 }
 
@@ -557,7 +557,7 @@
  * @param pPrivate - info about the bank
  * @param v        - result goes here
  */
-static int 
+static int
 EFC_GetResult(struct sam3_bank_private *pPrivate, uint32_t *v)
 {
 	int r;
@@ -586,7 +586,7 @@
 
 	case AT91C_EFC_FCMD_WP:
 	case AT91C_EFC_FCMD_WPL:
-	case AT91C_EFC_FCMD_EWP: 
+	case AT91C_EFC_FCMD_EWP:
 	case AT91C_EFC_FCMD_EWPL:
 		// case AT91C_EFC_FCMD_EPL:
 		// case AT91C_EFC_FCMD_EPA:
@@ -597,15 +597,15 @@
 			LOG_ERROR(&quot;*BUG*: Embedded flash has only %u pages&quot;, (unsigned)(n));
 		}
 		break;
-		
+
 	case AT91C_EFC_FCMD_SFB:
 	case AT91C_EFC_FCMD_CFB:
 		if (argument &gt;= pPrivate-&gt;pChip-&gt;details.n_gpnvms) {
-			LOG_ERROR(&quot;*BUG*: Embedded flash has only %d GPNVMs&quot;, 
+			LOG_ERROR(&quot;*BUG*: Embedded flash has only %d GPNVMs&quot;,
 					  pPrivate-&gt;pChip-&gt;details.n_gpnvms);
 		}
 		break;
-		
+
 	case AT91C_EFC_FCMD_GETD:
 	case AT91C_EFC_FCMD_EA:
 	case AT91C_EFC_FCMD_GLB:
@@ -640,11 +640,11 @@
 				return ERROR_FAIL;
 			} else {
 				retry++;
-				LOG_ERROR(&quot;Flash controller(%d) is not ready, attempting reset&quot;, 
+				LOG_ERROR(&quot;Flash controller(%d) is not ready, attempting reset&quot;,
 						  pPrivate-&gt;bank_number);
 				// we do that by issuing the *STOP* command
 				EFC_StartCommand(pPrivate, AT91C_EFC_FCMD_SPUI, 0);
-				// above is recursive, and further recursion is blocked by 
+				// above is recursive, and further recursion is blocked by
 				// if (command == AT91C_EFC_FCMD_SPUI) above
 				goto do_retry;
 			}
@@ -653,7 +653,7 @@
 
 	v = (0x5A &lt;&lt; 24) | (argument &lt;&lt; 8) | command;
 	LOG_DEBUG(&quot;Command: 0x%08x&quot;, ((unsigned int)(v)));
-	r = target_write_u32(pPrivate-&gt;pBank-&gt;target, 
+	r = target_write_u32(pPrivate-&gt;pBank-&gt;target,
 						  pPrivate-&gt;controller_address + offset_EFC_FCR,
 						  v);
 	if (r != ERROR_OK) {
@@ -669,10 +669,10 @@
  * @param argument - Optional command argument.
  * @param status   - put command status bits here
  */
-static int 
-EFC_PerformCommand(struct sam3_bank_private *pPrivate, 
-					unsigned command, 
-					unsigned argument, 
+static int
+EFC_PerformCommand(struct sam3_bank_private *pPrivate,
+					unsigned command,
+					unsigned argument,
 					uint32_t *status)
 {
 
@@ -680,7 +680,7 @@
 	uint32_t v;
 	long long ms_now, ms_end;
 
-	// default 
+	// default
 	if (status) {
 		*status = 0;
 	}
@@ -721,7 +721,7 @@
 
 
 /** Read the unique ID.
- * 
+ *
  * \param pPrivate - info about the bank
  *
  * The unique ID is stored in the 'pPrivate' structure.
@@ -746,7 +746,7 @@
 	}
 
 	for (x = 0 ; x &lt; 4 ; x++) {
-		r = target_read_u32(pPrivate-&gt;pChip-&gt;target, 
+		r = target_read_u32(pPrivate-&gt;pChip-&gt;target,
 							 pPrivate-&gt;pBank-&gt;base + (x * 4),
 							 &amp;v);
 		if (r &lt; 0) {
@@ -757,13 +757,13 @@
 
     r = EFC_PerformCommand(pPrivate, AT91C_EFC_FCMD_SPUI, 0, NULL);
 	LOG_DEBUG(&quot;End: R=%d, id = 0x%08x, 0x%08x, 0x%08x, 0x%08x&quot;,
-			  r, 
+			  r,
 			  (unsigned int)(pPrivate-&gt;pChip-&gt;cfg.unique_id[0]),
 			  (unsigned int)(pPrivate-&gt;pChip-&gt;cfg.unique_id[1]),
 			  (unsigned int)(pPrivate-&gt;pChip-&gt;cfg.unique_id[2]),
 			  (unsigned int)(pPrivate-&gt;pChip-&gt;cfg.unique_id[3]));
 	return r;
-	
+
 }
 
 /** Erases the entire flash.
@@ -785,7 +785,7 @@
  *
  */
 //------------------------------------------------------------------------------
-static int 
+static int
 FLASHD_GetGPNVM(struct sam3_bank_private *pPrivate, unsigned gpnvm, unsigned *puthere)
 {
 	uint32_t v;
@@ -814,7 +814,7 @@
 
 	if (puthere) {
 		// Check if GPNVM is set
-		// get the bit and make it a 0/1 
+		// get the bit and make it a 0/1
 		*puthere = (v &gt;&gt; gpnvm) &amp; 1;
 	}
 
@@ -829,7 +829,7 @@
  *
  * Returns 0 if successful; otherwise returns an error code.
  */
-static int 
+static int
 FLASHD_ClrGPNVM(struct sam3_bank_private *pPrivate, unsigned gpnvm)
 {
 	int r;
@@ -863,7 +863,7 @@
  *  @param gpnvm  GPNVM index.
  *
  */
-static int 
+static int
 FLASHD_SetGPNVM(struct sam3_bank_private *pPrivate, unsigned gpnvm)
 {
 	int r;
@@ -901,7 +901,7 @@
  * \param end  End address of range.
  */
 
-static int 
+static int
 FLASHD_GetLockBits(struct sam3_bank_private *pPrivate, uint32_t *v)
 {
 	int r;
@@ -915,7 +915,7 @@
 }
 
 
-/**Unlocks all the regions in the given address range. 
+/**Unlocks all the regions in the given address range.
  *
  * \param start_sector - first sector to unlock
  * \param end_sector   - last (inclusive) to unlock
@@ -955,7 +955,7 @@
  */
 
 
-static int 
+static int
 FLASHD_Lock(struct sam3_bank_private *pPrivate,
 			 unsigned start_sector,
 			 unsigned end_sector)
@@ -966,7 +966,7 @@
 	int r;
 
 	pages_per_sector = pPrivate-&gt;sector_size / pPrivate-&gt;page_size;
-	
+
     /* Lock all pages */
     while (start_sector &lt;= end_sector) {
 		pg = start_sector * pages_per_sector;
@@ -999,8 +999,8 @@
 }
 
 // print the fieldname, the field value, in dec &amp; hex, and return field value
-static uint32_t 
-sam3_reg_fieldname(struct sam3_chip *pChip, 
+static uint32_t
+sam3_reg_fieldname(struct sam3_chip *pChip,
 					const char *regname,
 					uint32_t value,
 					unsigned shift,
@@ -1020,9 +1020,9 @@
 		hwidth = 8;
 		dwidth = 12;
 	}
-	
+
 	// show the basics
-	sam3_sprintf(pChip, &quot;\t%*s: %*d [0x%0*x] &quot;, 
+	sam3_sprintf(pChip, &quot;\t%*s: %*d [0x%0*x] &quot;,
 				  REG_NAME_WIDTH, regname,
 				  dwidth, v,
 				  hwidth, v);
@@ -1034,7 +1034,7 @@
 static const char * const eproc_names[] = {
 	_unknown,					// 0
 	&quot;arm946es&quot;,					// 1
-	&quot;arm7tdmi&quot;,					// 2 
+	&quot;arm7tdmi&quot;,					// 2
 	&quot;cortex-m3&quot;,				// 3
 	&quot;arm920t&quot;,					// 4
 	&quot;arm926ejs&quot;,				// 5
@@ -1075,13 +1075,13 @@
 	&quot;48K Bytes&quot;,				//  0
 	&quot;1K Bytes&quot;,					//  1
 	&quot;2K Bytes&quot;,					//  2
-	&quot;6K Bytes&quot;,					//  3 
+	&quot;6K Bytes&quot;,					//  3
 	&quot;112K Bytes&quot;,				//  4
 	&quot;4K Bytes&quot;,					//  5
 	&quot;80K Bytes&quot;,				//  6
 	&quot;160K Bytes&quot;,				//  7
-	&quot;8K Bytes&quot;,					//  8 
-	&quot;16K Bytes&quot;,				//  9 
+	&quot;8K Bytes&quot;,					//  8
+	&quot;16K Bytes&quot;,				//  9
 	&quot;32K Bytes&quot;,				// 10
 	&quot;64K Bytes&quot;,				// 11
 	&quot;128K Bytes&quot;,				// 12
@@ -1133,8 +1133,8 @@
 	&quot;sram emulating flash&quot;, // 4
 	_unknown, // 5
 	_unknown, // 6
-	_unknown, // 7	
-	
+	_unknown, // 7
+
 };
 
 static const char *_yes_or_no(uint32_t v)
@@ -1150,7 +1150,7 @@
 	&quot;4 MHz&quot;, &quot;8 MHz&quot;, &quot;12 MHz&quot;, &quot;reserved&quot;
 };
 
-static void 
+static void
 sam3_explain_ckgr_mor(struct sam3_chip *pChip)
 {
 	uint32_t v;
@@ -1159,7 +1159,7 @@
 	v = sam3_reg_fieldname(pChip, &quot;MOSCXTEN&quot;, pChip-&gt;cfg.CKGR_MOR, 0, 1);
 	sam3_sprintf(pChip, &quot;(main xtal enabled: %s)\n&quot;,
 				  _yes_or_no(v));
-	v = sam3_reg_fieldname(pChip, &quot;MOSCXTBY&quot;, pChip-&gt;cfg.CKGR_MOR, 1, 1); 
+	v = sam3_reg_fieldname(pChip, &quot;MOSCXTBY&quot;, pChip-&gt;cfg.CKGR_MOR, 1, 1);
 	sam3_sprintf(pChip, &quot;(main osc bypass: %s)\n&quot;,
 				  _yes_or_no(v));
 	rcen = sam3_reg_fieldname(pChip, &quot;MOSCRCEN&quot;, pChip-&gt;cfg.CKGR_MOR, 2, 1);
@@ -1192,15 +1192,15 @@
 	v = sam3_reg_fieldname(pChip, &quot;MOSCSEL&quot;, pChip-&gt;cfg.CKGR_MOR, 24, 1);
 	sam3_sprintf(pChip, &quot;(mainosc source: %s)\n&quot;,
 				  v ? &quot;external xtal&quot; : &quot;internal RC&quot;);
-	
+
 	v = sam3_reg_fieldname(pChip,&quot;CFDEN&quot;, pChip-&gt;cfg.CKGR_MOR, 25, 1);
 	sam3_sprintf(pChip, &quot;(clock failure enabled: %s)\n&quot;,
 				 _yes_or_no(v));
 }
 
-	
 
-static void 
+
+static void
 sam3_explain_chipid_cidr(struct sam3_chip *pChip)
 {
 	int x;
@@ -1212,7 +1212,7 @@
 
 	v = sam3_reg_fieldname(pChip, &quot;EPROC&quot;, pChip-&gt;cfg.CHIPID_CIDR, 5, 3);
 	sam3_sprintf(pChip, &quot;%s\n&quot;, eproc_names[v]);
-	
+
 	v = sam3_reg_fieldname(pChip, &quot;NVPSIZE&quot;, pChip-&gt;cfg.CHIPID_CIDR, 8, 4);
 	sam3_sprintf(pChip, &quot;%s\n&quot;, nvpsize[v]);
 
@@ -1230,7 +1230,7 @@
 			break;
 		}
 	}
-	
+
 	sam3_sprintf(pChip, &quot;%s\n&quot;, cp);
 
 	v = sam3_reg_fieldname(pChip, &quot;NVPTYP&quot;, pChip-&gt;cfg.CHIPID_CIDR, 28, 3);
@@ -1240,17 +1240,17 @@
 	sam3_sprintf(pChip, &quot;(exists: %s)\n&quot;, _yes_or_no(v));
 }
 
-static void 
+static void
 sam3_explain_ckgr_mcfr(struct sam3_chip *pChip)
 {
 	uint32_t v;
 
-	
+
 	v = sam3_reg_fieldname(pChip, &quot;MAINFRDY&quot;, pChip-&gt;cfg.CKGR_MCFR, 16, 1);
 	sam3_sprintf(pChip, &quot;(main ready: %s)\n&quot;, _yes_or_no(v));
 
 	v = sam3_reg_fieldname(pChip, &quot;MAINF&quot;, pChip-&gt;cfg.CKGR_MCFR, 0, 16);
-	
+
 	v = (v * pChip-&gt;cfg.slow_freq) / 16;
 	pChip-&gt;cfg.mainosc_freq = v;
 
@@ -1281,8 +1281,8 @@
 					 _tomhz(pChip-&gt;cfg.plla_freq));
 	}
 }
-		
-		
+
+
 static void
 sam3_explain_mckr(struct sam3_chip *pChip)
 {
@@ -1316,7 +1316,7 @@
 	}
 
 	sam3_sprintf(pChip, &quot;%s (%3.03f Mhz)\n&quot;,
-				  cp, 
+				  cp,
 				  _tomhz(fin));
 	pres = sam3_reg_fieldname(pChip, &quot;PRES&quot;, pChip-&gt;cfg.PMC_MCKR, 4, 3);
 	switch (pres &amp; 0x07) {
@@ -1354,7 +1354,7 @@
 	}
 	sam3_sprintf(pChip, &quot;(%s)\n&quot;, cp);
 	fin = fin / pdiv;
-	// sam3 has a *SINGLE* clock - 
+	// sam3 has a *SINGLE* clock -
 	// other at91 series parts have divisors for these.
 	pChip-&gt;cfg.cpu_freq = fin;
 	pChip-&gt;cfg.mclk_freq = fin;
@@ -1362,7 +1362,7 @@
 	sam3_sprintf(pChip, &quot;\t\tResult CPU Freq: %3.03f\n&quot;,
 				  _tomhz(fin));
 }
-	
+
 #if 0
 static struct sam3_chip *
 target2sam3(target_t *pTarget)
@@ -1388,7 +1388,7 @@
 static uint32_t *
 sam3_get_reg_ptr(struct sam3_cfg *pCfg, const struct sam3_reg_list *pList)
 {
-	// this function exists to help 
+	// this function exists to help
 	// keep funky offsetof() errors
 	// and casting from causing bugs
 
@@ -1397,8 +1397,8 @@
 
 	return ((uint32_t *)(((char *)(pCfg)) + pList-&gt;struct_offset));
 }
-	
-	
+
+
 #define SAM3_ENTRY(NAME, FUNC)  { .address = SAM3_ ## NAME, .struct_offset = offsetof(struct sam3_cfg, NAME), #NAME, FUNC }
 static const struct sam3_reg_list sam3_all_regs[] = {
 	SAM3_ENTRY(CKGR_MOR , sam3_explain_ckgr_mor),
@@ -1448,7 +1448,7 @@
 
 		// calculate where this one go..
 		// it is &quot;possibly&quot; this register.
-		
+
 		pPossible = ((uint32_t *)(((char *)(&amp;(pChip-&gt;cfg))) + pReg-&gt;struct_offset));
 
 		// well? Is it this register
@@ -1484,9 +1484,9 @@
 	}
 	return r;
 }
-		
-	
 
+
+
 static int
 sam3_ReadAllRegs(struct sam3_chip *pChip)
 {
@@ -1495,14 +1495,14 @@
 
 	pReg = &amp;(sam3_all_regs[0]);
 	while (pReg-&gt;name) {
-		r = sam3_ReadThisReg(pChip, 
+		r = sam3_ReadThisReg(pChip,
 								  sam3_get_reg_ptr(&amp;(pChip-&gt;cfg), pReg));
 		if (r != ERROR_OK) {
 			LOG_ERROR(&quot;Cannot read SAM3 registere: %s @ 0x%08x, Error: %d\n&quot;,
 					  pReg-&gt;name, ((unsigned)(pReg-&gt;address)), r);
 			return r;
 		}
-		
+
 		pReg++;
 	}
 
@@ -1524,7 +1524,7 @@
 		// display all regs
 		LOG_DEBUG(&quot;Start: %s&quot;, pReg-&gt;name);
 		regval = *sam3_get_reg_ptr(&amp;(pChip-&gt;cfg), pReg);
-		sam3_sprintf(pChip, &quot;%*s: [0x%08x] -&gt; 0x%08x\n&quot;, 
+		sam3_sprintf(pChip, &quot;%*s: [0x%08x] -&gt; 0x%08x\n&quot;,
 					 REG_NAME_WIDTH,
 					 pReg-&gt;name,
 					 pReg-&gt;address,
@@ -1539,7 +1539,7 @@
 	sam3_sprintf(pChip,&quot;  mainosc: %3.03f MHz\n&quot;, _tomhz(pChip-&gt;cfg.mainosc_freq));
 	sam3_sprintf(pChip,&quot;     plla: %3.03f MHz\n&quot;, _tomhz(pChip-&gt;cfg.plla_freq));
 	sam3_sprintf(pChip,&quot; cpu-freq: %3.03f MHz\n&quot;, _tomhz(pChip-&gt;cfg.cpu_freq));
-	sam3_sprintf(pChip,&quot;mclk-freq: %3.03f MHz\n&quot;, _tomhz(pChip-&gt;cfg.mclk_freq));	
+	sam3_sprintf(pChip,&quot;mclk-freq: %3.03f MHz\n&quot;, _tomhz(pChip-&gt;cfg.mclk_freq));
 
 
 	sam3_sprintf(pChip, &quot; UniqueId: 0x%08x 0x%08x 0x%08x 0x%08x\n&quot;,
@@ -1548,12 +1548,12 @@
 				  pChip-&gt;cfg.unique_id[2],
 				  pChip-&gt;cfg.unique_id[3]);
 
-	
+
 	return ERROR_OK;
 }
 
-	
-static int 
+
+static int
 sam3_erase_check(struct flash_bank_s *bank)
 {
 	int x;
@@ -1577,7 +1577,7 @@
 	return ERROR_OK;
 }
 
-static int 
+static int
 sam3_protect_check(struct flash_bank_s *bank)
 {
 	int r;
@@ -1599,7 +1599,7 @@
 	if (!(pPrivate-&gt;probed)) {
 		return ERROR_FLASH_BANK_NOT_PROBED;
 	}
-	
+
 	r = FLASHD_GetLockBits(pPrivate , &amp;v);
 	if (r != ERROR_OK) {
 		LOG_DEBUG(&quot;Failed: %d&quot;,r);
@@ -1613,17 +1613,17 @@
 	return ERROR_OK;
 }
 
-static int 
-sam3_flash_bank_command(struct command_context_s *cmd_ctx, 
-			    char *cmd, 
-			    char **args, 
-			    int argc, 
+static int
+sam3_flash_bank_command(struct command_context_s *cmd_ctx,
+			    char *cmd,
+			    char **args,
+			    int argc,
 			    struct flash_bank_s *bank)
 {
 	struct sam3_chip *pChip;
 
 	pChip = all_sam3_chips;
-	
+
 	// is this an existing chip?
 	while (pChip) {
 		if (pChip-&gt;target == bank-&gt;target) {
@@ -1653,7 +1653,7 @@
 			return ERROR_FAIL;
 		}
 	}
-	
+
 	switch (bank-&gt;base) {
 	default:
 		LOG_ERROR(&quot;Address 0x%08x invalid bank address (try 0x%08x or 0x%08x)&quot;,
@@ -1701,11 +1701,11 @@
 		}
 	}
 	if (pDetails-&gt;name == NULL) {
-		LOG_ERROR(&quot;SAM3 ChipID 0x%08x not found in table (perhaps you can this chip?)&quot;, 
+		LOG_ERROR(&quot;SAM3 ChipID 0x%08x not found in table (perhaps you can this chip?)&quot;,
 				  (unsigned int)(pPrivate-&gt;pChip-&gt;cfg.CHIPID_CIDR));
 		// Help the victim, print details about the chip
 		membuf_reset(pPrivate-&gt;pChip-&gt;mbuf);
-		membuf_sprintf(pPrivate-&gt;pChip-&gt;mbuf, 
+		membuf_sprintf(pPrivate-&gt;pChip-&gt;mbuf,
 						&quot;SAM3 CHIPID_CIDR: 0x%08x decodes as follows\n&quot;,
 						pPrivate-&gt;pChip-&gt;cfg.CHIPID_CIDR);
 		sam3_explain_chipid_cidr(pPrivate-&gt;pChip);
@@ -1735,8 +1735,8 @@
 	}
 
 	// Overwrite the &quot;details&quot; structure.
-	memcpy(&amp;(pPrivate-&gt;pChip-&gt;details), 
-			pDetails, 
+	memcpy(&amp;(pPrivate-&gt;pChip-&gt;details),
+			pDetails,
 			sizeof(pPrivate-&gt;pChip-&gt;details));
 
 	// now fix the ghosted pointers
@@ -1745,15 +1745,15 @@
 		pChip-&gt;details.bank[x].pBank = saved_banks[x];
 	}
 
-	// update the *BANK*SIZE* 
+	// update the *BANK*SIZE*
 
 	LOG_DEBUG(&quot;End&quot;);
 	return ERROR_OK;
-}		
-				  
+}
 
 
-static int 
+
+static int
 _sam3_probe(struct flash_bank_s *bank, int noise)
 {
 	unsigned x;
@@ -1779,7 +1779,7 @@
 		return r;
 	}
 
-	
+
 	LOG_DEBUG(&quot;Here&quot;);
 	r = sam3_GetInfo(pPrivate-&gt;pChip);
 	if (r != ERROR_OK) {
@@ -1791,7 +1791,7 @@
 		r = sam3_GetDetails(pPrivate);
 		if (r != ERROR_OK) {
 			return r;
-		}		
+		}
 	}
 
 	// update the flash bank size
@@ -1809,7 +1809,7 @@
 			return ERROR_FAIL;
 		}
 		bank-&gt;num_sectors = pPrivate-&gt;nsectors;
-			
+
 		for (x = 0 ; ((int)(x)) &lt; bank-&gt;num_sectors ; x++) {
 			bank-&gt;sectors[x].size         = pPrivate-&gt;sector_size;
 			bank-&gt;sectors[x].offset       = x * (pPrivate-&gt;sector_size);
@@ -1829,7 +1829,7 @@
 	LOG_DEBUG(&quot;Bank = %d, nbanks = %d&quot;,
 			  pPrivate-&gt;bank_number , pPrivate-&gt;pChip-&gt;details.n_banks);
 	if ((pPrivate-&gt;bank_number + 1) == pPrivate-&gt;pChip-&gt;details.n_banks) {
-		// read unique id, 
+		// read unique id,
 		// it appears to be associated with the *last* flash bank.
 		FLASHD_ReadUniqueID(pPrivate);
 	}
@@ -1837,13 +1837,13 @@
 	return r;
 }
 
-static int 
+static int
 sam3_probe(struct flash_bank_s *bank)
 {
 	return _sam3_probe(bank, 1);
 }
 
-static int 
+static int
 sam3_auto_probe(struct flash_bank_s *bank)
 {
 	return _sam3_probe(bank, 0);
@@ -1851,7 +1851,7 @@
 
 
 
-static int 
+static int
 sam3_erase(struct flash_bank_s *bank, int first, int last)
 {
 	struct sam3_bank_private *pPrivate;
@@ -1883,7 +1883,7 @@
 	return ERROR_OK;
 }
 
-static int 
+static int
 sam3_protect(struct flash_bank_s *bank, int set, int first, int last)
 {
 	struct sam3_bank_private *pPrivate;
@@ -1908,7 +1908,7 @@
 	LOG_DEBUG(&quot;End: r=%d&quot;,r);
 
 	return r;
-		
+
 }
 
 
@@ -1932,7 +1932,7 @@
 	adr = pagenum * pPrivate-&gt;page_size;
 	adr += adr + pPrivate-&gt;base_address;
 
-	r = target_read_memory(pPrivate-&gt;pChip-&gt;target, 
+	r = target_read_memory(pPrivate-&gt;pChip-&gt;target,
 							adr,
 							4, /* THIS*MUST*BE* in 32bit values */
 							pPrivate-&gt;page_size / 4,
@@ -1951,11 +1951,11 @@
 // the DAP cannot... so - we download this 28byte thing
 // Run the algorithm - (below)
 // to program the device
-// 
+//
 // ========================================
 // #include &lt;stdint.h&gt;
-// 
-// struct foo { 
+//
+// struct foo {
 //   uint32_t *dst;
 //   const uint32_t *src;
 //   int   n;
@@ -1963,7 +1963,7 @@
 //   uint32_t   cmd;
 // };
 //
-// 
+//
 // uint32_t sam3_function(struct foo *p)
 // {
 //   volatile uint32_t *v;
@@ -1971,18 +1971,18 @@
 //   const uint32_t *s;
 //   int   n;
 //   uint32_t r;
-// 
+//
 //   d = p-&gt;dst;
 //   s = p-&gt;src;
 //   n = p-&gt;n;
-// 
+//
 //   do {
 //     *d++ = *s++;
 //   } while (--n)
 //     ;
-// 
+//
 //   v = p-&gt;base;
-//   
+//
 //   v[ 1 ] = p-&gt;cmd;
 //   do {
 //     r = v[8/4];
@@ -1994,7 +1994,7 @@
 
 
 
-static const uint8_t 
+static const uint8_t
 sam3_page_write_opcodes[] = {
 	//  24 0000 0446     		mov	r4, r0
 	0x04,0x46,
@@ -2046,7 +2046,7 @@
 	adr += (adr + pPrivate-&gt;base_address);
 
 	LOG_DEBUG(&quot;Wr Page %u @ phys address: 0x%08x&quot;, pagenum, (unsigned int)(adr));
-	r = target_write_memory(pPrivate-&gt;pChip-&gt;target, 
+	r = target_write_memory(pPrivate-&gt;pChip-&gt;target,
 							 adr,
 							 4, /* THIS*MUST*BE* in 32bit values */
 							 pPrivate-&gt;page_size / 4,
@@ -2075,15 +2075,15 @@
 	}
 	return ERROR_OK;
 }
-						
-						
-						
-				  
 
-static int 
-sam3_write(struct flash_bank_s *bank, 
-		   uint8_t *buffer, 
-		   uint32_t offset, 
+
+
+
+
+static int
+sam3_write(struct flash_bank_s *bank,
+		   uint8_t *buffer,
+		   uint32_t offset,
 		   uint32_t count)
 {
 	int n;
@@ -2113,28 +2113,28 @@
 	if ((offset + count) &gt; pPrivate-&gt;size_bytes) {
 		LOG_ERROR(&quot;Flash write error - past end of bank&quot;);
 		LOG_ERROR(&quot; offset: 0x%08x, count 0x%08x, BankEnd: 0x%08x&quot;,
-				  (unsigned int)(offset), 
+				  (unsigned int)(offset),
 				  (unsigned int)(count),
 				  (unsigned int)(pPrivate-&gt;size_bytes));
 		return ERROR_FAIL;
 	}
 
 	pagebuffer = alloca(pPrivate-&gt;page_size);
-		
+
 	// what page do we start &amp; end in?
 	page_cur = offset / pPrivate-&gt;page_size;
 	page_end = (offset + count - 1) / pPrivate-&gt;page_size;
-	
+
 	LOG_DEBUG(&quot;Offset: 0x%08x, Count: 0x%08x&quot;, (unsigned int)(offset), (unsigned int)(count));
 	LOG_DEBUG(&quot;Page start: %d, Page End: %d&quot;, (int)(page_cur), (int)(page_end));
-			  
+
 	// Special case: all one page
 	//
 	// Otherwise:
 	//    (1) non-aligned start
 	//    (2) body pages
 	//    (3) non-aligned end.
-	
+
 	// Handle special case - all one page.
 	if (page_cur == page_end) {
 		LOG_DEBUG(&quot;Special case, all in one page&quot;);
@@ -2142,12 +2142,12 @@
 		if (r != ERROR_OK) {
 			return r;
 		}
-		
+
 		page_offset = (offset &amp; (pPrivate-&gt;page_size-1));
 		memcpy(pagebuffer + page_offset,
 				buffer,
 				count);
-		
+
 		r = sam3_page_write(pPrivate, page_cur, pagebuffer);
 		if (r != ERROR_OK) {
 			return r;
@@ -2170,7 +2170,7 @@
 		memcpy(pagebuffer + page_offset,
 				buffer,
 				n);
-	
+
 		r = sam3_page_write(pPrivate, page_cur, pagebuffer);
 		if (r != ERROR_OK) {
 			return r;
@@ -2183,12 +2183,12 @@
 	}
 
 	// intermediate large pages
-	// also - the final *terminal* 
+	// also - the final *terminal*
 	// if that terminal page is a full page
-	LOG_DEBUG(&quot;Full Page Loop: cur=%d, end=%d, count = 0x%08x&quot;, 
+	LOG_DEBUG(&quot;Full Page Loop: cur=%d, end=%d, count = 0x%08x&quot;,
 			  (int)page_cur, (int)page_end, (unsigned int)(count));
 
-	while ((page_cur &lt; page_end) &amp;&amp; 
+	while ((page_cur &lt; page_end) &amp;&amp;
 		   (count &gt;= pPrivate-&gt;page_size)) {
 		r = sam3_page_write(pPrivate, page_cur, buffer);
 		if (r != ERROR_OK) {
@@ -2235,13 +2235,13 @@
 	}
 
 	r = 0;
-	
+
 	// bank0 must exist before we can do anything
 	if (pChip-&gt;details.bank[0].pBank == NULL) {
 		x = 0;
 	need_define:
-		command_print(cmd_ctx, 
-					   &quot;Please define bank %d via command: flash bank %s ... &quot;, 
+		command_print(cmd_ctx,
+					   &quot;Please define bank %d via command: flash bank %s ... &quot;,
 					   x,
 					   at91sam3_flash.name);
 		return ERROR_FAIL;
@@ -2256,16 +2256,16 @@
 	}
 	// above garentees the &quot;chip details&quot; structure is valid
 	// and thus, bank private areas are valid
-	// and we have a SAM3 chip, what a concept! 
-		
+	// and we have a SAM3 chip, what a concept!
 
+
 	// auto-probe other banks, 0 done above
     for (x = 1 ; x &lt; SAM3_MAX_FLASH_BANKS ; x++) {
 		// skip banks not present
 		if (!(pChip-&gt;details.bank[x].present)) {
 			continue;
 		}
-		
+
 		if (pChip-&gt;details.bank[x].pBank == NULL) {
 			goto need_define;
 		}
@@ -2273,21 +2273,21 @@
 		if (pChip-&gt;details.bank[x].probed) {
 			continue;
 		}
-		
+
 		r = sam3_auto_probe(pChip-&gt;details.bank[x].pBank);
 		if (r != ERROR_OK) {
 			return r;
 		}
 	}
-			
 
+
 	r = sam3_GetInfo(pChip);
 	if (r != ERROR_OK) {
 		LOG_DEBUG(&quot;Sam3Info, Failed %d\n&quot;,r);
 		return r;
 	}
-	
 
+
 	// print results
 	cp = membuf_strtok(pChip-&gt;mbuf, &quot;\n&quot;, &amp;vp);
 	while (cp) {
@@ -2381,7 +2381,7 @@
 		command_print(cmd_ctx, &quot;Missing GPNVM number&quot;);
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	
+
 	if (0 == strcmp(&quot;set&quot;, argv[0])) {
 		r = FLASHD_SetGPNVM(&amp;(pChip-&gt;details.bank[0]), who);
 	} else if ((0 == strcmp(&quot;clr&quot;, argv[0])) ||
@@ -2394,7 +2394,7 @@
 	return r;
 }
 
-static int 
+static int
 sam3_handle_slowclk_command(struct command_context_s *cmd_ctx, char *cmd, char **argv, int argc)
 {
 	uint32_t v;
@@ -2422,14 +2422,14 @@
 		}
 		pChip-&gt;cfg.slow_freq = v;
 		break;
-		
+
 	default:
 		// error
 		command_print(cmd_ctx,&quot;Too many parameters&quot;);
 		return ERROR_COMMAND_SYNTAX_ERROR;
 		break;
 	}
-	command_print(cmd_ctx, &quot;Slowclk freq: %d.%03dkhz&quot;, 
+	command_print(cmd_ctx, &quot;Slowclk freq: %d.%03dkhz&quot;,
 				   (int)(pChip-&gt;cfg.slow_freq/ 1000),
 				   (int)(pChip-&gt;cfg.slow_freq% 1000));
 	return ERROR_OK;
@@ -2448,9 +2448,9 @@
 
 		pCmd = register_command(cmd_ctx, NULL, &quot;at91sam3&quot;, NULL, COMMAND_ANY, NULL);
 		register_command(cmd_ctx, pCmd,
-						  &quot;gpnvm&quot;, 
-						  sam3_handle_gpnvm_command, 
-						  COMMAND_EXEC, 
+						  &quot;gpnvm&quot;,
+						  sam3_handle_gpnvm_command,
+						  COMMAND_EXEC,
 						  &quot;at91sam3 gpnvm [action [&lt;BIT&gt;], by default 'show', otherwise set | clear BIT&quot;);
 		register_command(cmd_ctx, pCmd,
 						  &quot;info&quot;,
@@ -2471,7 +2471,7 @@
 {
 	.name						= &quot;at91sam3&quot;,
 	.register_commands			= sam3_register_commands,
-	
+
 	.flash_bank_command			= sam3_flash_bank_command,
 	.erase						= sam3_erase,
 	.protect					= sam3_protect,

Modified: trunk/src/helper/membuf.c
===================================================================
--- trunk/src/helper/membuf.c	2009-06-24 09:38:15 UTC (rev 2397)
+++ trunk/src/helper/membuf.c	2009-06-24 09:38:21 UTC (rev 2398)
@@ -29,7 +29,7 @@
     // buflen is alway &quot;+1&quot; bigger then
     // what is shown here, the +1 is for
     // the NULL string terminator
-#define DEFAULT_BUFSIZE 100    
+#define DEFAULT_BUFSIZE 100
     size_t maxlen; // allocated size
     size_t curlen; // where we are inserting at
     char *_strtoklast;
@@ -40,7 +40,7 @@
 #define space_avail(pBuf)  (pBuf-&gt;maxlen - pBuf-&gt;curlen)
 #define dataend(pBuf)      (((char *)(pBuf-&gt;buf)) + pBuf-&gt;curlen)
 
-size_t 
+size_t
 membuf_len(struct membuf *pBuf)
 {
     return pBuf-&gt;curlen;
@@ -65,9 +65,9 @@
 	return strtok_r(NULL, sep, &amp;(pBuf-&gt;_strtoklast));
     }
 }
-	
 
 
+
 struct membuf *
 membuf_new(void)
 {
@@ -161,7 +161,7 @@
 	// do work
 	r = vsnprintf(dataend(pBuf),
 		       sa,
-		       fmt, 
+		       fmt,
 		       ap);
 	if ((r &gt; 0) &amp;&amp; (((size_t)(r)) &lt; sa)) {
 	    // Success!

Modified: trunk/src/helper/membuf.h
===================================================================
--- trunk/src/helper/membuf.h	2009-06-24 09:38:15 UTC (rev 2397)
+++ trunk/src/helper/membuf.h	2009-06-24 09:38:21 UTC (rev 2398)
@@ -12,15 +12,15 @@
  * This is a simple 'string buffer' that auto-grows.
  *
  * More correctly put, this is a &quot;memory buffer&quot;
- * it may contain binary data 
- * 
+ * it may contain binary data
+ *
  * Note: Internally the buffer always has a 'null terminator'
  */
 
 /* contents of this structure are 'opaque' */
 struct membuf;
-  
 
+
 /** Create a new membuf
  * By default the memory buffer has &quot;some non-zero-size&quot;
  * (couple hundred bytes, exact amount is opaque)
@@ -34,7 +34,7 @@
 
 
 /** grow/shrink a membuf by specified amount.
- * @param pBuf   - the buffer 
+ * @param pBuf   - the buffer
  * @param amount - the amount to grow or shrink by.
  *
  * Symantics of 'realloc()' return NULL on failure
@@ -43,7 +43,7 @@
 
 /** how long is this buffer (memlen(), strlen())
  * @param pBuf - the buffer
- * 
+ *
  * @returns: length of current buffer.
  */
 size_t membuf_len(struct membuf *pBuf);
@@ -76,10 +76,10 @@
  */
 int membuf_vsprintf(struct membuf *pBuf , const char *fmt, va_list ap);
 
-/** Tokenize lines using strtok() 
+/** Tokenize lines using strtok()
  * @param pBuf - buffer to tokenize
  * @param delim - delimiter parameter for strtok_r()
- * 
+ *
  * Identical to &quot;strtok()&quot; - pass &quot;pBuff = NULL&quot; on second call
  *
  * NOTE: This call is &lt;b &gt; destructive&lt;/b&gt; to the buffer.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001181.html">[Openocd-svn] r2397 - in trunk/src: flash helper
</A></li>
	<LI>Next message: <A HREF="001183.html">[Openocd-svn] r2399 - trunk/src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1182">[ date ]</a>
              <a href="thread.html#1182">[ thread ]</a>
              <a href="subject.html#1182">[ subject ]</a>
              <a href="author.html#1182">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
