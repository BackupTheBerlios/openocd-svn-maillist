<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2280 - trunk/src/flash
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2280%20-%20trunk/src/flash&In-Reply-To=%3C200906180711.n5I7B7X5016526%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001063.html">
   <LINK REL="Next"  HREF="001065.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2280 - trunk/src/flash</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2280%20-%20trunk/src/flash&In-Reply-To=%3C200906180711.n5I7B7X5016526%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2280 - trunk/src/flash">zwelch at mail.berlios.de
       </A><BR>
    <I>Thu Jun 18 09:11:07 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001063.html">[Openocd-svn] r2279 - trunk/src/target
</A></li>
        <LI>Next message: <A HREF="001065.html">[Openocd-svn] r2281 - in trunk/src: helper jtag jtag/minidummy	jtag/rlink jtag/zy1000 pld server svf xsvf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1064">[ date ]</a>
              <a href="thread.html#1064">[ thread ]</a>
              <a href="subject.html#1064">[ subject ]</a>
              <a href="author.html#1064">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-18 09:10:25 +0200 (Thu, 18 Jun 2009)
New Revision: 2280

Modified:
   trunk/src/flash/aduc702x.c
   trunk/src/flash/at91sam7.c
   trunk/src/flash/at91sam7.h
   trunk/src/flash/avrf.c
   trunk/src/flash/cfi.c
   trunk/src/flash/cfi.h
   trunk/src/flash/davinci_nand.c
   trunk/src/flash/ecos.c
   trunk/src/flash/flash.c
   trunk/src/flash/flash.h
   trunk/src/flash/lpc2000.c
   trunk/src/flash/lpc2000.h
   trunk/src/flash/lpc288x.c
   trunk/src/flash/lpc288x.h
   trunk/src/flash/lpc3180_nand_controller.c
   trunk/src/flash/lpc3180_nand_controller.h
   trunk/src/flash/mflash.c
   trunk/src/flash/mflash.h
   trunk/src/flash/nand.c
   trunk/src/flash/nand.h
   trunk/src/flash/non_cfi.h
   trunk/src/flash/ocl.c
   trunk/src/flash/orion_nand.c
   trunk/src/flash/pic32mx.c
   trunk/src/flash/pic32mx.h
   trunk/src/flash/s3c2440_nand.c
   trunk/src/flash/s3c24xx_nand.h
   trunk/src/flash/stellaris.c
   trunk/src/flash/stellaris.h
   trunk/src/flash/stm32x.c
   trunk/src/flash/stm32x.h
   trunk/src/flash/str7x.c
   trunk/src/flash/str7x.h
   trunk/src/flash/str9x.c
   trunk/src/flash/str9x.h
   trunk/src/flash/str9xpec.c
   trunk/src/flash/str9xpec.h
   trunk/src/flash/tms470.c
   trunk/src/flash/tms470.h
Log:
Transform 'u32' to 'uint32_t' in src/flash.
- Replace '\([^_]\)u32' with '\1uint32_t'.


Modified: trunk/src/flash/aduc702x.c
===================================================================
--- trunk/src/flash/aduc702x.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/aduc702x.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -33,9 +33,9 @@
 static int aduc702x_register_commands(struct command_context_s *cmd_ctx);
 static int aduc702x_erase(struct flash_bank_s *bank, int first, int last);
 static int aduc702x_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int aduc702x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
-static int aduc702x_write_single(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
-static int aduc702x_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int aduc702x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
+static int aduc702x_write_single(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
+static int aduc702x_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int aduc702x_probe(struct flash_bank_s *bank);
 static int aduc702x_info(struct flash_bank_s *bank, char *buf, int buf_size);
 static int aduc702x_protect_check(struct flash_bank_s *bank);
@@ -54,14 +54,14 @@
 #define ADUC702x_FLASH_FEEHIDE		(7*4)
 
 typedef struct {
-	u32 feesta;
-	u32 feemod;
-	u32 feecon;
-	u32 feedat;
-	u32 feeadr;
-	u32 feesign;
-	u32 feepro;
-	u32 feehide;
+	uint32_t feesta;
+	uint32_t feemod;
+	uint32_t feecon;
+	uint32_t feedat;
+	uint32_t feeadr;
+	uint32_t feesign;
+	uint32_t feepro;
+	uint32_t feehide;
 } ADUC702x_FLASH_MMIO;
 
 typedef struct
@@ -111,7 +111,7 @@
 	//aduc7026_flash_bank_t *aduc7026_info = bank-&gt;driver_priv;
 	
         int i = 0;
-        u32 offset = 0;
+        uint32_t offset = 0;
 		
         // sector size is 512
         bank-&gt;num_sectors = bank-&gt;size / 512;
@@ -139,7 +139,7 @@
         //int res;
 	int x;
 	int count;
-	//u32 v;
+	//uint32_t v;
 	target_t *target = bank-&gt;target;
 
         aduc702x_set_write_enable(target, 1);
@@ -193,13 +193,13 @@
 	return ERROR_FLASH_OPERATION_FAILED;
 }
 
-static int aduc702x_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int aduc702x_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	aduc702x_flash_bank_t *aduc702x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 buffer_size = 7000;
+	uint32_t buffer_size = 7000;
 	working_area_t *source;
-	u32 address = bank-&gt;base + offset;
+	uint32_t address = bank-&gt;base + offset;
 	reg_param_t reg_params[6];
 	armv4_5_algorithm_t armv4_5_info;
 	int retval = ERROR_OK;
@@ -218,7 +218,7 @@
         r6 - set to 2, used to write flash command
 
         */
-        u32 aduc702x_flash_write_code[] = {
+        uint32_t aduc702x_flash_write_code[] = {
         //&lt;_start&gt;:
                 0xe3a05008,	// mov	r5, #8	; 0x8
                 0xe5845004,	// str	r5, [r4, #4]
@@ -279,7 +279,7 @@
 	
 	while (count &gt; 0)
 	{
-		u32 thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
+		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
 		
 		target_write_buffer(target, source-&gt;address, thisrun_count * 2, buffer);
 
@@ -322,9 +322,9 @@
 
 /* All-JTAG, single-access method.  Very slow.  Used only if there is no 
  * working area available. */
-static int aduc702x_write_single(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int aduc702x_write_single(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
-	u32 x;
+	uint32_t x;
         uint8_t b;
 	target_t *target = bank-&gt;target;
 	
@@ -363,7 +363,7 @@
 	return ERROR_OK;
 }
 
-int aduc702x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+int aduc702x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	int retval;
 

Modified: trunk/src/flash/at91sam7.c
===================================================================
--- trunk/src/flash/at91sam7.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/at91sam7.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -47,16 +47,16 @@
 static int at91sam7_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int at91sam7_erase(struct flash_bank_s *bank, int first, int last);
 static int at91sam7_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int at91sam7_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int at91sam7_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int at91sam7_probe(struct flash_bank_s *bank);
 //static int at91sam7_auto_probe(struct flash_bank_s *bank);
 static int at91sam7_erase_check(struct flash_bank_s *bank);
 static int at91sam7_protect_check(struct flash_bank_s *bank);
 static int at91sam7_info(struct flash_bank_s *bank, char *buf, int buf_size);
 
-static u32 at91sam7_get_flash_status(target_t *target, int bank_number);
+static uint32_t at91sam7_get_flash_status(target_t *target, int bank_number);
 static void at91sam7_set_flash_mode(flash_bank_t *bank, int mode);
-static u32 at91sam7_wait_status_busy(flash_bank_t *bank, u32 waitbits, int timeout);
+static uint32_t at91sam7_wait_status_busy(flash_bank_t *bank, uint32_t waitbits, int timeout);
 static int at91sam7_flash_command(struct flash_bank_s *bank, uint8_t cmd, uint16_t pagen); 
 static int at91sam7_handle_gpnvm_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
@@ -75,9 +75,9 @@
 	.info = at91sam7_info
 };
 
-static u32 MC_FMR[4] = { 0xFFFFFF60, 0xFFFFFF70, 0xFFFFFF80, 0xFFFFFF90 };
-static u32 MC_FCR[4] = { 0xFFFFFF64, 0xFFFFFF74, 0xFFFFFF84, 0xFFFFFF94 };
-static u32 MC_FSR[4] = { 0xFFFFFF68, 0xFFFFFF78, 0xFFFFFF88, 0xFFFFFF98 };
+static uint32_t MC_FMR[4] = { 0xFFFFFF60, 0xFFFFFF70, 0xFFFFFF80, 0xFFFFFF90 };
+static uint32_t MC_FCR[4] = { 0xFFFFFF64, 0xFFFFFF74, 0xFFFFFF84, 0xFFFFFF94 };
+static uint32_t MC_FSR[4] = { 0xFFFFFF68, 0xFFFFFF78, 0xFFFFFF88, 0xFFFFFF98 };
 
 static char * EPROC[8]= {&quot;Unknown&quot;,&quot;ARM946-E&quot;,&quot;ARM7TDMI&quot;,&quot;Unknown&quot;,&quot;ARM920T&quot;,&quot;ARM926EJ-S&quot;,&quot;Unknown&quot;,&quot;Unknown&quot;};
 
@@ -111,9 +111,9 @@
 	return ERROR_OK;
 }
 
-static u32 at91sam7_get_flash_status(target_t *target, int bank_number)
+static uint32_t at91sam7_get_flash_status(target_t *target, int bank_number)
 {
-	u32 fsr;
+	uint32_t fsr;
 	target_read_u32(target, MC_FSR[bank_number], &amp;fsr);
 
 	return fsr;
@@ -124,7 +124,7 @@
 {
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 mckr, mcfr, pllr, mor;
+	uint32_t mckr, mcfr, pllr, mor;
 	unsigned long tmp = 0, mainfreq;
 
 	/* Read Clock Generator Main Oscillator Register */
@@ -201,7 +201,7 @@
 /* Setup the timimg registers for nvbits or normal flash */
 static void at91sam7_set_flash_mode(flash_bank_t *bank, int mode)
 {
-	u32 fmr, fmcn = 0, fws = 0;
+	uint32_t fmr, fmcn = 0, fws = 0;
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
 
@@ -247,9 +247,9 @@
 	at91sam7_info-&gt;flashmode = mode;
 }
 
-static u32 at91sam7_wait_status_busy(flash_bank_t *bank, u32 waitbits, int timeout)
+static uint32_t at91sam7_wait_status_busy(flash_bank_t *bank, uint32_t waitbits, int timeout)
 {
-	u32 status;
+	uint32_t status;
 
 	while ((!((status = at91sam7_get_flash_status(bank-&gt;target, bank-&gt;bank_number)) &amp; waitbits)) &amp;&amp; (timeout-- &gt; 0))
 	{
@@ -276,7 +276,7 @@
 /* Send one command to the AT91SAM flash controller */
 static int at91sam7_flash_command(struct flash_bank_s *bank, uint8_t cmd, uint16_t pagen)
 {
-	u32 fcr;
+	uint32_t fcr;
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
 
@@ -311,15 +311,15 @@
 
 	uint16_t bnk, sec;
 	uint16_t arch;
-	u32 cidr;
+	uint32_t cidr;
 	uint8_t banks_num = 0;
 	uint16_t num_nvmbits = 0;
 	uint16_t sectors_num = 0;
 	uint16_t pages_per_sector = 0;
 	uint16_t page_size = 0;
-	u32 ext_freq;
-	u32 bank_size;
-	u32 base_address = 0;
+	uint32_t ext_freq;
+	uint32_t bank_size;
+	uint32_t base_address = 0;
 	char *target_name = &quot;Unknown&quot;;
 
 	at91sam7_info = t_bank-&gt;driver_priv;
@@ -622,7 +622,7 @@
 {
 	target_t *target = bank-&gt;target;
 	uint16_t retval;
-	u32 blank;
+	uint32_t blank;
 	uint16_t fast_check;
 	uint8_t *buffer;
 	uint16_t nSector;
@@ -687,7 +687,7 @@
 static int at91sam7_protect_check(struct flash_bank_s *bank)
 {
 	uint8_t lock_pos, gpnvm_pos;
-	u32 status;
+	uint32_t status;
 
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 
@@ -750,9 +750,9 @@
 	at91sam7_flash_bank_t *at91sam7_info;
 	target_t *target = t_bank-&gt;target;
 
-	u32 base_address;
-	u32 bank_size;
-	u32 ext_freq;
+	uint32_t base_address;
+	uint32_t bank_size;
+	uint32_t ext_freq;
 
 	int chip_width;
 	int bus_width;
@@ -860,7 +860,7 @@
 {
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 	int sec;
-	u32 nbytes, pos;
+	uint32_t nbytes, pos;
 	uint8_t *buffer;
 	uint8_t erase_all;
 
@@ -926,9 +926,9 @@
 
 static int at91sam7_protect(struct flash_bank_s *bank, int set, int first, int last)
 {
-	u32 cmd;
+	uint32_t cmd;
 	int sector;
-	u32 pagen;
+	uint32_t pagen;
 
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 
@@ -974,13 +974,13 @@
 	return ERROR_OK;
 }
 
-static int at91sam7_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int at91sam7_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	int retval;
 	at91sam7_flash_bank_t *at91sam7_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 dst_min_alignment, wcount, bytes_remaining = count;
-	u32 first_page, last_page, pagen, buffer_pos;
+	uint32_t dst_min_alignment, wcount, bytes_remaining = count;
+	uint32_t first_page, last_page, pagen, buffer_pos;
 
 	if (at91sam7_info-&gt;cidr == 0)
 	{
@@ -1128,7 +1128,7 @@
 	flash_bank_t *bank;
 	int bit;
 	uint8_t  flashcmd;
-	u32 status;
+	uint32_t status;
 	at91sam7_flash_bank_t *at91sam7_info;
 	int retval;
 

Modified: trunk/src/flash/at91sam7.h
===================================================================
--- trunk/src/flash/at91sam7.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/at91sam7.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -28,7 +28,7 @@
 typedef struct at91sam7_flash_bank_s
 {
 	/* chip id register */
-	u32 cidr;
+	uint32_t cidr;
 	uint16_t cidr_ext;
 	uint16_t cidr_nvptyp;
 	uint16_t cidr_arch;
@@ -62,10 +62,10 @@
 
 	/* main clock status */
 	uint8_t  mck_valid;
-	u32 mck_freq;
+	uint32_t mck_freq;
 
 	/* external clock frequency */
-	u32 ext_freq;
+	uint32_t ext_freq;
 
 } at91sam7_flash_bank_t;
 

Modified: trunk/src/flash/avrf.c
===================================================================
--- trunk/src/flash/avrf.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/avrf.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -60,7 +60,7 @@
 static int avrf_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int avrf_erase(struct flash_bank_s *bank, int first, int last);
 static int avrf_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int avrf_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int avrf_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int avrf_probe(struct flash_bank_s *bank);
 static int avrf_auto_probe(struct flash_bank_s *bank);
 //static int avrf_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
@@ -70,7 +70,7 @@
 static int avrf_handle_mass_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
 extern int avr_jtag_sendinstr(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out);
-extern int avr_jtag_senddat(jtag_tap_t *tap, u32 *dr_in, u32 dr_out, int len);
+extern int avr_jtag_senddat(jtag_tap_t *tap, uint32_t *dr_in, uint32_t dr_out, int len);
 
 extern int mcu_write_ir(jtag_tap_t *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
 extern int mcu_write_dr(jtag_tap_t *tap, uint8_t *ir_in, uint8_t *ir_out, int dr_len, int rti);
@@ -78,8 +78,8 @@
 extern int mcu_write_dr_u8(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out, int dr_len, int rti);
 extern int mcu_write_ir_u16(jtag_tap_t *tap, uint16_t *ir_in, uint16_t ir_out, int ir_len, int rti);
 extern int mcu_write_dr_u16(jtag_tap_t *tap, uint16_t *ir_in, uint16_t ir_out, int dr_len, int rti);
-extern int mcu_write_ir_u32(jtag_tap_t *tap, u32 *ir_in, u32 ir_out, int ir_len, int rti);
-extern int mcu_write_dr_u32(jtag_tap_t *tap, u32 *ir_in, u32 ir_out, int dr_len, int rti);
+extern int mcu_write_ir_u32(jtag_tap_t *tap, uint32_t *ir_in, uint32_t ir_out, int ir_len, int rti);
+extern int mcu_write_dr_u32(jtag_tap_t *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
 extern int mcu_execute_queue(void);
 
 flash_driver_t avr_flash =
@@ -98,7 +98,7 @@
 };
 
 /* avr program functions */
-static int avr_jtag_reset(avr_common_t *avr, u32 reset)
+static int avr_jtag_reset(avr_common_t *avr, uint32_t reset)
 {
 	avr_jtag_sendinstr(avr-&gt;jtag_info.tap, NULL, AVR_JTAG_INS_AVR_RESET);
 	avr_jtag_senddat(avr-&gt;jtag_info.tap, NULL, reset ,AVR_JTAG_REG_Reset_Len);
@@ -106,7 +106,7 @@
 	return ERROR_OK;
 }
 
-static int avr_jtag_read_jtagid(avr_common_t *avr, u32 *id)
+static int avr_jtag_read_jtagid(avr_common_t *avr, uint32_t *id)
 {
 	avr_jtag_sendinstr(avr-&gt;jtag_info.tap, NULL, AVR_JTAG_INS_IDCODE);
 	avr_jtag_senddat(avr-&gt;jtag_info.tap, id, 0, AVR_JTAG_REG_JTAGID_Len);
@@ -140,7 +140,7 @@
 
 static int avr_jtagprg_chiperase(avr_common_t *avr)
 {
-	u32 poll_value;
+	uint32_t poll_value;
 
 	avr_jtag_sendinstr(avr-&gt;jtag_info.tap, NULL, AVR_JTAG_INS_PROG_COMMANDS);
 	avr_jtag_senddat(avr-&gt;jtag_info.tap, NULL, 0x2380, AVR_JTAG_REG_ProgrammingCommand_Len);
@@ -161,9 +161,9 @@
 	return ERROR_OK;
 }
 
-static int avr_jtagprg_writeflashpage(avr_common_t *avr, uint8_t *page_buf, u32 buf_size, u32 addr, u32 page_size)
+static int avr_jtagprg_writeflashpage(avr_common_t *avr, uint8_t *page_buf, uint32_t buf_size, uint32_t addr, uint32_t page_size)
 {
-	u32 i, poll_value;
+	uint32_t i, poll_value;
 
 	avr_jtag_sendinstr(avr-&gt;jtag_info.tap, NULL, AVR_JTAG_INS_PROG_COMMANDS);
 	avr_jtag_senddat(avr-&gt;jtag_info.tap, NULL, 0x2310, AVR_JTAG_REG_ProgrammingCommand_Len);
@@ -249,11 +249,11 @@
 	return ERROR_OK;
 }
 
-static int avrf_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int avrf_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	target_t *target = bank-&gt;target;
 	avr_common_t *avr = target-&gt;arch_info;
-	u32 cur_size, cur_buffer_size, page_size;
+	uint32_t cur_size, cur_buffer_size, page_size;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -307,7 +307,7 @@
 	avr_common_t *avr = target-&gt;arch_info;
 	avrf_type_t *avr_info = NULL;
 	int i;
-	u32 device_id;
+	uint32_t device_id;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -388,7 +388,7 @@
 	avr_common_t *avr = target-&gt;arch_info;
 	avrf_type_t *avr_info = NULL;
 	int i;
-	u32 device_id;
+	uint32_t device_id;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{

Modified: trunk/src/flash/cfi.c
===================================================================
--- trunk/src/flash/cfi.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/cfi.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -33,7 +33,7 @@
 static int cfi_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int cfi_erase(struct flash_bank_s *bank, int first, int last);
 static int cfi_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int cfi_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int cfi_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int cfi_probe(struct flash_bank_s *bank);
 static int cfi_auto_probe(struct flash_bank_s *bank);
 static int cfi_protect_check(struct flash_bank_s *bank);
@@ -109,8 +109,8 @@
 	}
 }
 
-/* inline u32 flash_address(flash_bank_t *bank, int sector, u32 offset) */
-static __inline__ u32 flash_address(flash_bank_t *bank, int sector, u32 offset)
+/* inline uint32_t flash_address(flash_bank_t *bank, int sector, uint32_t offset) */
+static __inline__ uint32_t flash_address(flash_bank_t *bank, int sector, uint32_t offset)
 {
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
 
@@ -161,7 +161,7 @@
  * flash banks are expected to be made of similar chips
  * the query result should be the same for all
  */
-static uint8_t cfi_query_u8(flash_bank_t *bank, int sector, u32 offset)
+static uint8_t cfi_query_u8(flash_bank_t *bank, int sector, uint32_t offset)
 {
 	target_t *target = bank-&gt;target;
 	uint8_t data[CFI_MAX_BUS_WIDTH];
@@ -178,7 +178,7 @@
  * in case of a bank made of multiple chips,
  * the individual values are ORed
  */
-static uint8_t cfi_get_u8(flash_bank_t *bank, int sector, u32 offset)
+static uint8_t cfi_get_u8(flash_bank_t *bank, int sector, uint32_t offset)
 {
 	target_t *target = bank-&gt;target;
 	uint8_t data[CFI_MAX_BUS_WIDTH];
@@ -203,7 +203,7 @@
 	}
 }
 
-static uint16_t cfi_query_u16(flash_bank_t *bank, int sector, u32 offset)
+static uint16_t cfi_query_u16(flash_bank_t *bank, int sector, uint32_t offset)
 {
 	target_t *target = bank-&gt;target;
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
@@ -225,7 +225,7 @@
 		return data[bank-&gt;bus_width - 1] | data[(2 * bank-&gt;bus_width) - 1] &lt;&lt; 8;
 }
 
-static u32 cfi_query_u32(flash_bank_t *bank, int sector, u32 offset)
+static uint32_t cfi_query_u32(flash_bank_t *bank, int sector, uint32_t offset)
 {
 	target_t *target = bank-&gt;target;
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
@@ -979,7 +979,7 @@
 	/* NOTE:
 	 * The data to flash must not be changed in endian! We write a bytestrem in
 	 * target byte order already. Only the control and status byte lane of the flash
-	 * WSM is interpreted by the CPU in different ways, when read a uint16_t or u32
+	 * WSM is interpreted by the CPU in different ways, when read a uint16_t or uint32_t
 	 * word (data seems to be in the upper or lower byte lane for uint16_t accesses).
 	 */
 
@@ -1005,9 +1005,9 @@
 
 /* Convert code image to target endian */
 /* FIXME create general block conversion fcts in target.c?) */
-static void cfi_fix_code_endian(target_t *target, uint8_t *dest, const u32 *src, u32 count)
+static void cfi_fix_code_endian(target_t *target, uint8_t *dest, const uint32_t *src, uint32_t count)
 {
-	u32 i;
+	uint32_t i;
 	for (i=0; i&lt; count; i++)
 	{
 		target_buffer_set_u32(target, dest, *src);
@@ -1016,7 +1016,7 @@
 	}
 }
 
-static u32 cfi_command_val(flash_bank_t *bank, uint8_t cmd)
+static uint32_t cfi_command_val(flash_bank_t *bank, uint8_t cmd)
 {
 	target_t *target = bank-&gt;target;
 
@@ -1039,15 +1039,15 @@
 	}
 }
 
-static int cfi_intel_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 address, u32 count)
+static int cfi_intel_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t address, uint32_t count)
 {
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
 	reg_param_t reg_params[7];
 	armv4_5_algorithm_t armv4_5_info;
 	working_area_t *source;
-	u32 buffer_size = 32768;
-	u32 write_command_val, busy_pattern_val, error_pattern_val;
+	uint32_t buffer_size = 32768;
+	uint32_t write_command_val, busy_pattern_val, error_pattern_val;
 
 	/* algorithm register usage:
 	 * r0: source address (in RAM)
@@ -1059,7 +1059,7 @@
 	 * r6: error test pattern
 	 */
 
-	static const u32 word_32_code[] = {
+	static const uint32_t word_32_code[] = {
 		0xe4904004,   /* loop:	ldr r4, [r0], #4 */
 		0xe5813000,   /* 		str r3, [r1] */
 		0xe5814000,   /* 		str r4, [r1] */
@@ -1076,7 +1076,7 @@
 		0xeafffffe    /* done:	b -2 */
 	};
 
-	static const u32 word_16_code[] = {
+	static const uint32_t word_16_code[] = {
 		0xe0d040b2,   /* loop:	ldrh r4, [r0], #2 */
 		0xe1c130b0,   /* 		strh r3, [r1] */
 		0xe1c140b0,   /* 		strh r4, [r1] */
@@ -1093,7 +1093,7 @@
 		0xeafffffe    /* done:	b -2 */
 	};
 
-	static const u32 word_8_code[] = {
+	static const uint32_t word_8_code[] = {
 		0xe4d04001,   /* loop:	ldrb r4, [r0], #1 */
 		0xe5c13000,   /* 		strb r3, [r1] */
 		0xe5c14000,   /* 		strb r4, [r1] */
@@ -1110,8 +1110,8 @@
 		0xeafffffe    /* done:	b -2 */
 	};
 	uint8_t target_code[4*CFI_MAX_INTEL_CODESIZE];
-	const u32 *target_code_src;
-	u32 target_code_size;
+	const uint32_t *target_code_src;
+	uint32_t target_code_size;
 	int retval = ERROR_OK;
 
 
@@ -1208,8 +1208,8 @@
 	/* Programming main loop */
 	while (count &gt; 0)
 	{
-		u32 thisrun_count = (count &gt; buffer_size) ? buffer_size : count;
-		u32 wsm_error;
+		uint32_t thisrun_count = (count &gt; buffer_size) ? buffer_size : count;
+		uint32_t wsm_error;
 
 		if((retval = target_write_buffer(target, source-&gt;address, thisrun_count, buffer)) != ERROR_OK)
 		{
@@ -1229,7 +1229,7 @@
 		/* Execute algorithm, assume breakpoint for last instruction */
 		retval = target_run_algorithm(target, 0, NULL, 7, reg_params,
 			cfi_info-&gt;write_algorithm-&gt;address,
-			cfi_info-&gt;write_algorithm-&gt;address + target_code_size - sizeof(u32),
+			cfi_info-&gt;write_algorithm-&gt;address + target_code_size - sizeof(uint32_t),
 			10000, /* 10s should be enough for max. 32k of data */
 			&amp;armv4_5_info);
 
@@ -1283,7 +1283,7 @@
 	return retval;
 }
 
-static int cfi_spansion_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 address, u32 count)
+static int cfi_spansion_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t address, uint32_t count)
 {
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
 	cfi_spansion_pri_ext_t *pri_ext = cfi_info-&gt;pri_ext;
@@ -1291,8 +1291,8 @@
 	reg_param_t reg_params[10];
 	armv4_5_algorithm_t armv4_5_info;
 	working_area_t *source;
-	u32 buffer_size = 32768;
-	u32 status;
+	uint32_t buffer_size = 32768;
+	uint32_t status;
 	int retval, retvaltemp;
 	int exit_code = ERROR_OK;
 
@@ -1313,7 +1313,7 @@
 	/*  R10 = unlock2_addr */
 	/*  R11 = unlock2_cmd */
 
-	static const u32 word_32_code[] = {
+	static const uint32_t word_32_code[] = {
 						/* 00008100 &lt;sp_32_code&gt;:		*/
 		0xe4905004,		/* ldr	r5, [r0], #4			*/
 		0xe5889000, 	/* str	r9, [r8]				*/
@@ -1347,7 +1347,7 @@
 		0xeafffffe		/* b	8154 &lt;sp_32_done&gt;		*/
 		};
 
-		static const u32 word_16_code[] = {
+		static const uint32_t word_16_code[] = {
 				/* 00008158 &lt;sp_16_code&gt;:              */
 		0xe0d050b2, 	/* ldrh	r5, [r0], #2		   */
 		0xe1c890b0, 	/* strh	r9, [r8]				*/
@@ -1381,7 +1381,7 @@
 		0xeafffffe 	/* b	81ac &lt;sp_16_done&gt;              */
 		};
 
-		static const u32 word_8_code[] = {
+		static const uint32_t word_8_code[] = {
 				/* 000081b0 &lt;sp_16_code_end&gt;:          */
 		0xe4d05001, 	/* ldrb	r5, [r0], #1		       */
 		0xe5c89000, 	/* strb	r9, [r8]				*/
@@ -1424,7 +1424,7 @@
 	{
 		uint8_t *target_code;
 		int target_code_size;
-		const u32 *src;
+		const uint32_t *src;
 
 		/* convert bus-width dependent algorithm code to correct endiannes */
 		switch (bank-&gt;bus_width)
@@ -1496,7 +1496,7 @@
 
 	while (count &gt; 0)
 	{
-		u32 thisrun_count = (count &gt; buffer_size) ? buffer_size : count;
+		uint32_t thisrun_count = (count &gt; buffer_size) ? buffer_size : count;
 
 		retvaltemp = target_write_buffer(target, source-&gt;address, thisrun_count, buffer);
 
@@ -1545,7 +1545,7 @@
 	return exit_code;
 }
 
-static int cfi_intel_write_word(struct flash_bank_s *bank, uint8_t *word, u32 address)
+static int cfi_intel_write_word(struct flash_bank_s *bank, uint8_t *word, uint32_t address)
 {
 	int retval;
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
@@ -1579,7 +1579,7 @@
 	return ERROR_OK;
 }
 
-static int cfi_intel_write_words(struct flash_bank_s *bank, uint8_t *word, u32 wordcount, u32 address)
+static int cfi_intel_write_words(struct flash_bank_s *bank, uint8_t *word, uint32_t wordcount, uint32_t address)
 {
 	int retval;
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
@@ -1587,9 +1587,9 @@
 	uint8_t command[8];
 
 	/* Calculate buffer size and boundary mask */
-	u32 buffersize = (1UL &lt;&lt; cfi_info-&gt;max_buf_write_size) * (bank-&gt;bus_width / bank-&gt;chip_width);
-	u32 buffermask = buffersize-1;
-	u32 bufferwsize;
+	uint32_t buffersize = (1UL &lt;&lt; cfi_info-&gt;max_buf_write_size) * (bank-&gt;bus_width / bank-&gt;chip_width);
+	uint32_t buffermask = buffersize-1;
+	uint32_t bufferwsize;
 
 	/* Check for valid range */
 	if (address &amp; buffermask)
@@ -1671,7 +1671,7 @@
 	return ERROR_OK;
 }
 
-static int cfi_spansion_write_word(struct flash_bank_s *bank, uint8_t *word, u32 address)
+static int cfi_spansion_write_word(struct flash_bank_s *bank, uint8_t *word, uint32_t address)
 {
 	int retval;
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
@@ -1717,7 +1717,7 @@
 	return ERROR_OK;
 }
 
-static int cfi_spansion_write_words(struct flash_bank_s *bank, uint8_t *word, u32 wordcount, u32 address)
+static int cfi_spansion_write_words(struct flash_bank_s *bank, uint8_t *word, uint32_t wordcount, uint32_t address)
 {
 	int retval;
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
@@ -1726,9 +1726,9 @@
 	cfi_spansion_pri_ext_t *pri_ext = cfi_info-&gt;pri_ext;
 
 	/* Calculate buffer size and boundary mask */
-	u32 buffersize = (1UL &lt;&lt; cfi_info-&gt;max_buf_write_size) * (bank-&gt;bus_width / bank-&gt;chip_width);
-	u32 buffermask = buffersize-1;
-	u32 bufferwsize;
+	uint32_t buffersize = (1UL &lt;&lt; cfi_info-&gt;max_buf_write_size) * (bank-&gt;bus_width / bank-&gt;chip_width);
+	uint32_t buffermask = buffersize-1;
+	uint32_t bufferwsize;
 
 	/* Check for valid range */
 	if (address &amp; buffermask)
@@ -1809,7 +1809,7 @@
 	return ERROR_OK;
 }
 
-static int cfi_write_word(struct flash_bank_s *bank, uint8_t *word, u32 address)
+static int cfi_write_word(struct flash_bank_s *bank, uint8_t *word, uint32_t address)
 {
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
 
@@ -1830,7 +1830,7 @@
 	return ERROR_FLASH_OPERATION_FAILED;
 }
 
-static int cfi_write_words(struct flash_bank_s *bank, uint8_t *word, u32 wordcount, u32 address)
+static int cfi_write_words(struct flash_bank_s *bank, uint8_t *word, uint32_t wordcount, uint32_t address)
 {
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
 
@@ -1851,12 +1851,12 @@
 	return ERROR_FLASH_OPERATION_FAILED;
 }
 
-int cfi_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+int cfi_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	cfi_flash_bank_t *cfi_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 address = bank-&gt;base + offset;	/* address of first byte to be programmed */
-	u32 write_p, copy_p;
+	uint32_t address = bank-&gt;base + offset;	/* address of first byte to be programmed */
+	uint32_t write_p, copy_p;
 	int align;	/* number of unaligned bytes */
 	int blk_count; /* number of bus_width bytes for block copy */
 	uint8_t current_word[CFI_MAX_BUS_WIDTH * 4];	/* word (bus_width size) currently being programmed */
@@ -1950,9 +1950,9 @@
 		if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
 		{
 			//adjust buffersize for chip width
-			u32 buffersize = (1UL &lt;&lt; cfi_info-&gt;max_buf_write_size) * (bank-&gt;bus_width / bank-&gt;chip_width);
-			u32 buffermask = buffersize-1;
-			u32 bufferwsize;
+			uint32_t buffersize = (1UL &lt;&lt; cfi_info-&gt;max_buf_write_size) * (bank-&gt;bus_width / bank-&gt;chip_width);
+			uint32_t buffermask = buffersize-1;
+			uint32_t bufferwsize;
 
 			switch(bank-&gt;chip_width)
 			{
@@ -1967,7 +1967,7 @@
 			bufferwsize/=(bank-&gt;bus_width / bank-&gt;chip_width);
 
 			/* fall back to memory writes */
-			while (count &gt;= (u32)bank-&gt;bus_width)
+			while (count &gt;= (uint32_t)bank-&gt;bus_width)
 			{
 				int fallback;
 				if ((write_p &amp; 0xff) == 0)
@@ -2083,7 +2083,7 @@
 		for (i = 0; i &lt; cfi_info-&gt;num_erase_regions / 2; i++)
 		{
 			int j = (cfi_info-&gt;num_erase_regions - 1) - i;
-			u32 swap;
+			uint32_t swap;
 
 			swap = cfi_info-&gt;erase_region_info[i];
 			cfi_info-&gt;erase_region_info[i] = cfi_info-&gt;erase_region_info[j];
@@ -2110,8 +2110,8 @@
 	int num_sectors = 0;
 	int i;
 	int sector = 0;
-	u32 unlock1 = 0x555;
-	u32 unlock2 = 0x2aa;
+	uint32_t unlock1 = 0x555;
+	uint32_t unlock2 = 0x2aa;
 	int retval;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -2353,7 +2353,7 @@
 	}
 	else
 	{
-		u32 offset = 0;
+		uint32_t offset = 0;
 
 		for (i = 0; i &lt; cfi_info-&gt;num_erase_regions; i++)
 		{
@@ -2365,7 +2365,7 @@
 
 		for (i = 0; i &lt; cfi_info-&gt;num_erase_regions; i++)
 		{
-			u32 j;
+			uint32_t j;
 			for (j = 0; j &lt; (cfi_info-&gt;erase_region_info[i] &amp; 0xffff) + 1; j++)
 			{
 				bank-&gt;sectors[sector].offset = offset;

Modified: trunk/src/flash/cfi.h
===================================================================
--- trunk/src/flash/cfi.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/cfi.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -62,11 +62,11 @@
 	uint8_t status_poll_mask;
 
 	/* flash geometry */
-	u32 dev_size;
+	uint32_t dev_size;
 	uint16_t interface_desc;
 	uint16_t max_buf_write_size;
 	uint8_t num_erase_regions;
-	u32 *erase_region_info;
+	uint32_t *erase_region_info;
 
 	void *pri_ext;
 	void *alt_ext;
@@ -81,7 +81,7 @@
 	char pri[3];
 	uint8_t major_version;
 	uint8_t minor_version;
-	u32 feature_support;
+	uint32_t feature_support;
 	uint8_t suspend_cmd_support;
 	uint16_t blk_status_reg_mask;
 	uint8_t vcc_optimal;
@@ -113,8 +113,8 @@
 	uint8_t  VppMax;
 	uint8_t  TopBottom;
 	int _reversed_geometry;
-	u32 _unlock1;
-	u32 _unlock2;
+	uint32_t _unlock1;
+	uint32_t _unlock2;
 } cfi_spansion_pri_ext_t;
 
 /* Atmel primary extended query table as defined for and used by
@@ -138,8 +138,8 @@
 
 typedef struct cfi_unlock_addresses_s
 {
-	u32 unlock1;
-	u32 unlock2;
+	uint32_t unlock1;
+	uint32_t unlock2;
 } cfi_unlock_addresses_t;
 
 typedef struct cfi_fixup_s

Modified: trunk/src/flash/davinci_nand.c
===================================================================
--- trunk/src/flash/davinci_nand.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/davinci_nand.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -44,18 +44,18 @@
 	uint8_t		eccmode;
 
 	/* Async EMIF controller base */
-	u32		aemif;
+	uint32_t		aemif;
 
 	/* NAND chip addresses */
-	u32		data;		/* without CLE or ALE */
-	u32		cmd;		/* with CLE */
-	u32		addr;		/* with ALE */
+	uint32_t		data;		/* without CLE or ALE */
+	uint32_t		cmd;		/* with CLE */
+	uint32_t		addr;		/* with ALE */
 
 	/* page i/o for the relevant flavor of hardware ECC */
-	int (*read_page)(struct nand_device_s *nand, u32 page,
-			uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
-	int (*write_page)(struct nand_device_s *nand, u32 page,
-			uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
+	int (*read_page)(struct nand_device_s *nand, uint32_t page,
+			uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+	int (*write_page)(struct nand_device_s *nand, uint32_t page,
+			uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 };
 
 #define NANDFCR		0x60		/* flash control register */
@@ -84,7 +84,7 @@
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
-	u32 nandfcr;
+	uint32_t nandfcr;
 
 	if (!halted(target, &quot;init&quot;))
 		return ERROR_NAND_OPERATION_FAILED;
@@ -114,7 +114,7 @@
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
-	u32 nandfsr;
+	uint32_t nandfsr;
 
 	/* NOTE: return code is zero/error, else success; not ERROR_* */
 
@@ -188,8 +188,8 @@
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
-	u32 nfdata = info-&gt;data;
-	u32 tmp;
+	uint32_t nfdata = info-&gt;data;
+	uint32_t tmp;
 
 	if (!halted(target, &quot;read_block&quot;))
 		return ERROR_NAND_OPERATION_FAILED;
@@ -221,8 +221,8 @@
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
-	u32 nfdata = info-&gt;data;
-	u32 tmp;
+	uint32_t nfdata = info-&gt;data;
+	uint32_t tmp;
 
 	if (!halted(target, &quot;write_block&quot;))
 		return ERROR_NAND_OPERATION_FAILED;
@@ -245,8 +245,8 @@
 	return ERROR_OK;
 }
 
-static int davinci_write_page(struct nand_device_s *nand, u32 page,
-		uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int davinci_write_page(struct nand_device_s *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	uint8_t *ooballoc = NULL;
@@ -290,8 +290,8 @@
 	return status;
 }
 
-static int davinci_read_page(struct nand_device_s *nand, u32 page,
-		uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int davinci_read_page(struct nand_device_s *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 
@@ -303,7 +303,7 @@
 	return info-&gt;read_page(nand, page, data, data_size, oob, oob_size);
 }
 
-static void davinci_write_pagecmd(struct nand_device_s *nand, uint8_t cmd, u32 page)
+static void davinci_write_pagecmd(struct nand_device_s *nand, uint8_t cmd, uint32_t page)
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
@@ -327,7 +327,7 @@
 }
 
 static int davinci_writepage_tail(struct nand_device_s *nand,
-		uint8_t *oob, u32 oob_size)
+		uint8_t *oob, uint32_t oob_size)
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
@@ -358,15 +358,15 @@
 /*
  * All DaVinci family chips support 1-bit ECC on a per-chipselect basis.
  */
-static int davinci_write_page_ecc1(struct nand_device_s *nand, u32 page,
-		uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int davinci_write_page_ecc1(struct nand_device_s *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	unsigned oob_offset;
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
-	const u32 fcr_addr = info-&gt;aemif + NANDFCR;
-	const u32 ecc1_addr = info-&gt;aemif + NANDFECC + info-&gt;chipsel;
-	u32 fcr, ecc1;
+	const uint32_t fcr_addr = info-&gt;aemif + NANDFCR;
+	const uint32_t ecc1_addr = info-&gt;aemif + NANDFECC + info-&gt;chipsel;
+	uint32_t fcr, ecc1;
 
 	/* Write contiguous ECC bytes starting at specified offset.
 	 * NOTE: Linux reserves twice as many bytes as we need; and
@@ -425,8 +425,8 @@
  * is read first, so its ECC data can be used incrementally), but the
  * manufacturer bad block markers are safe.  Contrast:  old &quot;infix&quot; style.
  */
-static int davinci_write_page_ecc4(struct nand_device_s *nand, u32 page,
-		uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int davinci_write_page_ecc4(struct nand_device_s *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	static const uint8_t ecc512[] = {
 		0, 1, 2, 3, 4, /* 5== mfr badblock */
@@ -452,9 +452,9 @@
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	const uint8_t *l;
 	target_t *target = info-&gt;target;
-	const u32 fcr_addr = info-&gt;aemif + NANDFCR;
-	const u32 ecc4_addr = info-&gt;aemif + NAND4BITECC;
-	u32 fcr, ecc4;
+	const uint32_t fcr_addr = info-&gt;aemif + NANDFCR;
+	const uint32_t ecc4_addr = info-&gt;aemif + NAND4BITECC;
+	uint32_t fcr, ecc4;
 
 	/* Use the same ECC layout Linux uses.  For small page chips
 	 * it's a bit cramped.
@@ -485,7 +485,7 @@
 	fcr |= (1 &lt;&lt; 12) | (info-&gt;chipsel &lt;&lt; 4);
 
 	do {
-		u32 raw_ecc[4], *p;
+		uint32_t raw_ecc[4], *p;
 		int i;
 
 		/* start 4bit ecc on csX */
@@ -527,14 +527,14 @@
  * older second stage loaders (ABL/U-Boot, etc) or other system software
  * (MVL 4.x/5.x kernels, filesystems, etc) may need it more generally.
  */
-static int davinci_write_page_ecc4infix(struct nand_device_s *nand, u32 page,
-		uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int davinci_write_page_ecc4infix(struct nand_device_s *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	struct davinci_nand *info = nand-&gt;controller_priv;
 	target_t *target = info-&gt;target;
-	const u32 fcr_addr = info-&gt;aemif + NANDFCR;
-	const u32 ecc4_addr = info-&gt;aemif + NAND4BITECC;
-	u32 fcr, ecc4;
+	const uint32_t fcr_addr = info-&gt;aemif + NANDFCR;
+	const uint32_t ecc4_addr = info-&gt;aemif + NAND4BITECC;
+	uint32_t fcr, ecc4;
 
 	davinci_write_pagecmd(nand, NAND_CMD_SEQIN, page);
 
@@ -546,7 +546,7 @@
 	fcr |= (1 &lt;&lt; 12) | (info-&gt;chipsel &lt;&lt; 4);
 
 	do {
-		u32 raw_ecc[4], *p;
+		uint32_t raw_ecc[4], *p;
 		uint8_t *l;
 		int i;
 
@@ -584,8 +584,8 @@
 	return davinci_writepage_tail(nand, NULL, 0);
 }
 
-static int davinci_read_page_ecc4infix(struct nand_device_s *nand, u32 page,
-		uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int davinci_read_page_ecc4infix(struct nand_device_s *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	davinci_write_pagecmd(nand, NAND_CMD_READ0, page);
 

Modified: trunk/src/flash/ecos.c
===================================================================
--- trunk/src/flash/ecos.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/ecos.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -30,15 +30,15 @@
 static int ecosflash_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int ecosflash_erase(struct flash_bank_s *bank, int first, int last);
 static int ecosflash_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int ecosflash_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int ecosflash_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int ecosflash_probe(struct flash_bank_s *bank);
 static int ecosflash_protect_check(struct flash_bank_s *bank);
 static int ecosflash_info(struct flash_bank_s *bank, char *buf, int buf_size);
 
 #if 0
-static u32 ecosflash_get_flash_status(flash_bank_t *bank);
+static uint32_t ecosflash_get_flash_status(flash_bank_t *bank);
 static void ecosflash_set_flash_mode(flash_bank_t *bank,int mode);
-static u32 ecosflash_wait_status_busy(flash_bank_t *bank, u32 waitbits, int timeout);
+static uint32_t ecosflash_wait_status_busy(flash_bank_t *bank, uint32_t waitbits, int timeout);
 static int ecosflash_handle_gpnvm_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 #endif
 
@@ -63,7 +63,7 @@
 	working_area_t *write_algorithm;
 	working_area_t *erase_check_algorithm;
 	char *driverPath;
-	u32 start_address;
+	uint32_t start_address;
 } ecosflash_flash_bank_t;
 
 static const int sectorSize=0x10000;
@@ -152,7 +152,7 @@
 	 * driver.
 	 */
 	int i = 0;
-	u32 offset = 0;
+	uint32_t offset = 0;
 	bank-&gt;num_sectors=bank-&gt;size/sectorSize;
 	bank-&gt;sectors = malloc(sizeof(flash_sector_t) * bank-&gt;num_sectors);
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
@@ -175,8 +175,8 @@
 
 static int loadDriver(ecosflash_flash_bank_t *info)
 {
-	u32 buf_cnt;
-	u32 image_size;
+	uint32_t buf_cnt;
+	uint32_t image_size;
 	image_t image;
 
 	image.base_address_set = 0;
@@ -223,8 +223,8 @@
 static int const OFFSET_GET_WORKAREA_SIZE=0x4;
 
 static int runCode(ecosflash_flash_bank_t *info,
-		u32 codeStart, u32 codeStop, u32 r0, u32 r1, u32 r2,
-		u32 *result,
+		uint32_t codeStart, uint32_t codeStop, uint32_t r0, uint32_t r1, uint32_t r2,
+		uint32_t *result,
 		/* timeout in ms */
 		int timeout)
 {
@@ -263,7 +263,7 @@
 	return ERROR_OK;
 }
 
-static int eCosBoard_erase(ecosflash_flash_bank_t *info, u32 address, u32 len)
+static int eCosBoard_erase(ecosflash_flash_bank_t *info, uint32_t address, uint32_t len)
 {
 	int retval;
 	int timeout = (len / 20480 + 1) * 1000; /*asume 20 KB/s*/
@@ -272,7 +272,7 @@
 	if (retval!=ERROR_OK)
 		return retval;
 
-	u32 flashErr;
+	uint32_t flashErr;
 	retval=runCode(info,
 			info-&gt;start_address+OFFSET_ERASE,
 			info-&gt;start_address+OFFSET_ERASE+OFFSET_ERASE_SIZE,
@@ -294,7 +294,7 @@
 	return ERROR_OK;
 }
 
-static int eCosBoard_flash(ecosflash_flash_bank_t *info, void *data, u32 address, u32 len)
+static int eCosBoard_flash(ecosflash_flash_bank_t *info, void *data, uint32_t address, uint32_t len)
 {
 	target_t *target=info-&gt;target;
 	const int chunk=8192;
@@ -305,7 +305,7 @@
 	if (retval!=ERROR_OK)
 		return retval;
 
-	u32 buffer;
+	uint32_t buffer;
 	retval=runCode(info,
 			info-&gt;start_address+OFFSET_GET_WORKAREA,
 			info-&gt;start_address+OFFSET_GET_WORKAREA+OFFSET_GET_WORKAREA_SIZE,
@@ -318,7 +318,7 @@
 		return retval;
 
 
-	u32 i;
+	uint32_t i;
 	for (i=0; i&lt;len; i+=chunk)
 	{
 		int t=len-i;
@@ -332,7 +332,7 @@
 		if (retval != ERROR_OK)
 			return retval;
 
-		u32 flashErr;
+		uint32_t flashErr;
 		retval=runCode(info,
 				info-&gt;start_address+OFFSET_FLASH,
 				info-&gt;start_address+OFFSET_FLASH+OFFSET_FLASH_SIZE,
@@ -389,9 +389,9 @@
 #endif
 
 #if 0
-static u32 ecosflash_address(struct flash_bank_s *bank, u32 address)
+static uint32_t ecosflash_address(struct flash_bank_s *bank, uint32_t address)
 {
-	u32 retval = 0;
+	uint32_t retval = 0;
 	switch(bank-&gt;bus_width)
 	{
 		case 4:
@@ -418,7 +418,7 @@
 	return ERROR_OK;
 }
 
-static int ecosflash_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int ecosflash_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	ecosflash_flash_bank_t *info = bank-&gt;driver_priv;
 	struct flash_bank_s *c=bank;
@@ -438,7 +438,7 @@
 }
 
 #if 0
-static u32 ecosflash_get_flash_status(flash_bank_t *bank)
+static uint32_t ecosflash_get_flash_status(flash_bank_t *bank)
 {
 	return ERROR_OK;
 }
@@ -448,7 +448,7 @@
 
 }
 
-static u32 ecosflash_wait_status_busy(flash_bank_t *bank, u32 waitbits, int timeout)
+static uint32_t ecosflash_wait_status_busy(flash_bank_t *bank, uint32_t waitbits, int timeout)
 {
 	return ERROR_OK;
 }

Modified: trunk/src/flash/flash.c
===================================================================
--- trunk/src/flash/flash.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/flash.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -85,7 +85,7 @@
 static 	command_t *flash_cmd;
 
 /* wafer thin wrapper for invoking the flash driver */
-static int flash_driver_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int flash_driver_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	int retval;
 
@@ -330,7 +330,7 @@
 static int handle_flash_info_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	flash_bank_t *p;
-	u32 i = 0;
+	uint32_t i = 0;
 	int j = 0;
 	int retval;
 
@@ -624,7 +624,7 @@
 	target_t *target = get_current_target(cmd_ctx);
 
 	image_t image;
-	u32 written;
+	uint32_t written;
 
 	duration_t duration;
 	char *duration_text;
@@ -707,19 +707,19 @@
 static int handle_flash_fill_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	int err = ERROR_OK, retval;
-	u32 address;
-	u32 pattern;
-	u32 count;
+	uint32_t address;
+	uint32_t pattern;
+	uint32_t count;
 	uint8_t chunk[1024];
 	uint8_t readback[1024];
-	u32 wrote = 0;
-	u32 cur_size = 0;
-	u32 chunk_count;
+	uint32_t wrote = 0;
+	uint32_t cur_size = 0;
+	uint32_t chunk_count;
 	char *duration_text;
 	duration_t duration;
 	target_t *target = get_current_target(cmd_ctx);
-	u32 i;
-	u32 wordsize;
+	uint32_t i;
+	uint32_t wordsize;
 
 	if (argc != 3)
 	{
@@ -822,9 +822,9 @@
 
 static int handle_flash_write_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u32 offset;
+	uint32_t offset;
 	uint8_t *buffer;
-	u32 buf_cnt;
+	uint32_t buf_cnt;
 
 	fileio_t fileio;
 
@@ -901,7 +901,7 @@
 }
 
 /* lookup flash bank by address */
-flash_bank_t *get_flash_bank_by_addr(target_t *target, u32 addr)
+flash_bank_t *get_flash_bank_by_addr(target_t *target, uint32_t addr)
 {
 	flash_bank_t *c;
 
@@ -925,7 +925,7 @@
 }
 
 /* erase given flash region, selects proper bank according to target and address */
-int flash_erase_address_range(target_t *target, u32 addr, u32 length)
+int flash_erase_address_range(target_t *target, uint32_t addr, uint32_t length)
 {
 	flash_bank_t *c;
 	int first = -1;
@@ -974,12 +974,12 @@
 }
 
 /* write (optional verify) an image to flash memory of the given target */
-int flash_write(target_t *target, image_t *image, u32 *written, int erase)
+int flash_write(target_t *target, image_t *image, uint32_t *written, int erase)
 {
 	int retval=ERROR_OK;
 
 	int section;
-	u32 section_offset;
+	uint32_t section_offset;
 	flash_bank_t *c;
 	int *padding;
 
@@ -1003,12 +1003,12 @@
 	/* loop until we reach end of the image */
 	while (section &lt; image-&gt;num_sections)
 	{
-		u32 buffer_size;
+		uint32_t buffer_size;
 		uint8_t *buffer;
 		int section_first;
 		int section_last;
-		u32 run_address = image-&gt;sections[section].base_address + section_offset;
-		u32 run_size = image-&gt;sections[section].size - section_offset;
+		uint32_t run_address = image-&gt;sections[section].base_address + section_offset;
+		uint32_t run_size = image-&gt;sections[section].size - section_offset;
 		int pad_bytes = 0;
 
 		if (image-&gt;sections[section].size ==  0)
@@ -1067,7 +1067,7 @@
 		/* read sections to the buffer */
 		while (buffer_size &lt; run_size)
 		{
-			u32 size_read;
+			uint32_t size_read;
 
 			size_read = run_size - buffer_size;
 			if (size_read &gt; image-&gt;sections[section].size - section_offset)
@@ -1132,7 +1132,7 @@
 	uint8_t buffer[1024];
 	int buffer_size = sizeof(buffer);
 	int i;
-	u32 nBytes;
+	uint32_t nBytes;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -1142,12 +1142,12 @@
 
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
 	{
-		u32 j;
+		uint32_t j;
 		bank-&gt;sectors[i].is_erased = 1;
 
 		for (j = 0; j &lt; bank-&gt;sectors[i].size; j += buffer_size)
 		{
-			u32 chunk;
+			uint32_t chunk;
 			int retval;
 			chunk = buffer_size;
 			if (chunk &gt; (j - bank-&gt;sectors[i].size))
@@ -1179,7 +1179,7 @@
 	int i;
 	int retval;
 	int fast_check = 0;
-	u32 blank;
+	uint32_t blank;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -1189,8 +1189,8 @@
 
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
 	{
-		u32 address = bank-&gt;base + bank-&gt;sectors[i].offset;
-		u32 size = bank-&gt;sectors[i].size;
+		uint32_t address = bank-&gt;base + bank-&gt;sectors[i].offset;
+		uint32_t size = bank-&gt;sectors[i].size;
 
 		if ((retval = target_blank_check_memory(target, address, size, &amp;blank)) != ERROR_OK)
 		{

Modified: trunk/src/flash/flash.h
===================================================================
--- trunk/src/flash/flash.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/flash.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -41,9 +41,9 @@
 typedef struct flash_sector_s
 {
 	/// Bus offset from start of the flash chip (in bytes).
-	u32 offset;
+	uint32_t offset;
 	/// Number of bytes in this flash sector.
-	u32 size;
+	uint32_t size;
 	/**
 	 * Indication of erasure status: 0=not erased, 1=erased,
 	 * other=unknown.  Set by @c flash_driver_s::erase_check.
@@ -166,7 +166,7 @@
 	 * @param count The number of bytes to write.
 	 * @returns ERROR_OK if successful; otherwise, an error code.
 	 */
-	int (*write)(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+	int (*write)(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 
 	/** 
 	 * Probe to determine what kind of flash is present.
@@ -246,8 +246,8 @@
 	void *driver_priv; /**&lt; Private driver storage pointer */
 
 	int bank_number; /**&lt; The 'bank' (or chip number) of this instance. */
-	u32 base; /**&lt; The base address of this bank */
-	u32 size; /**&lt; The size of this chip bank, in bytes */
+	uint32_t base; /**&lt; The base address of this bank */
+	uint32_t size; /**&lt; The size of this chip bank, in bytes */
 
 	int chip_width; /**&lt; Width of the chip in bytes (1,2,4 bytes) */
 	int bus_width; /**&lt; Maximum bus width, in bytes (1,2,4 bytes) */
@@ -273,7 +273,7 @@
  * Erases @a length bytes in the @a target flash, starting at @a addr.
  * @returns ERROR_OK if successful; otherwise, an error code.
  */
-extern int flash_erase_address_range(struct target_s *target, u32 addr, u32 length);
+extern int flash_erase_address_range(struct target_s *target, uint32_t addr, uint32_t length);
 /**
  * Writes @a image into the @a target flash.  The @a written parameter
  * will contain the 
@@ -284,7 +284,7 @@
  * erase the corresponding banks or sectors before programming.
  * @returns ERROR_OK if successful; otherwise, an error code.
  */
-extern int flash_write(struct target_s *target, struct image_s *image, u32 *written, int erase);
+extern int flash_write(struct target_s *target, struct image_s *image, uint32_t *written, int erase);
 /**
  * Forces targets to re-examine their erase/protection state.
  * This routine must be called when the system may modify the status.
@@ -325,7 +325,7 @@
  * @param addr An address that is within the range of the bank.
  * @returns The flash_bank_t located at @a addr, or NULL.
  */
-extern flash_bank_t *get_flash_bank_by_addr(struct target_s *target, u32 addr);
+extern flash_bank_t *get_flash_bank_by_addr(struct target_s *target, uint32_t addr);
 
 #define ERROR_FLASH_BANK_INVALID			(-900)
 #define ERROR_FLASH_SECTOR_INVALID			(-901)

Modified: trunk/src/flash/lpc2000.c
===================================================================
--- trunk/src/flash/lpc2000.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/lpc2000.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -49,7 +49,7 @@
 static int lpc2000_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int lpc2000_erase(struct flash_bank_s *bank, int first, int last);
 static int lpc2000_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int lpc2000_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int lpc2000_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int lpc2000_probe(struct flash_bank_s *bank);
 static int lpc2000_erase_check(struct flash_bank_s *bank);
 static int lpc2000_protect_check(struct flash_bank_s *bank);
@@ -92,7 +92,7 @@
 	if (lpc2000_info-&gt;variant == 1)
 	{
 		int i = 0;
-		u32 offset = 0;
+		uint32_t offset = 0;
 
 		/* variant 1 has different layout for 128kb and 256kb flashes */
 		if (bank-&gt;size == 128 * 1024)
@@ -148,7 +148,7 @@
 	{
 		int num_sectors;
 		int i;
-		u32 offset = 0;
+		uint32_t offset = 0;
 
 		/* variant 2 has a uniform layout, only number of sectors differs */
 		switch (bank-&gt;size)
@@ -233,7 +233,7 @@
  * 0x20 to 0x2b: command result table
  * 0x2c to 0xac: stack (only 128b needed)
  */
-static int lpc2000_iap_call(flash_bank_t *bank, int code, u32 param_table[5], u32 result_table[2])
+static int lpc2000_iap_call(flash_bank_t *bank, int code, uint32_t param_table[5], uint32_t result_table[2])
 {
 	int retval;
 	lpc2000_flash_bank_t *lpc2000_info = bank-&gt;driver_priv;
@@ -241,7 +241,7 @@
 	mem_param_t mem_params[2];
 	reg_param_t reg_params[5];
 	armv4_5_algorithm_t armv4_5_info;
-	u32 status_code;
+	uint32_t status_code;
 
 	/* regrab previously allocated working_area, or allocate a new one */
 	if (!lpc2000_info-&gt;iap_working_area)
@@ -318,8 +318,8 @@
 
 static int lpc2000_iap_blank_check(struct flash_bank_s *bank, int first, int last)
 {
-	u32 param_table[5];
-	u32 result_table[2];
+	uint32_t param_table[5];
+	uint32_t result_table[2];
 	int status_code;
 	int i;
 
@@ -410,8 +410,8 @@
 static int lpc2000_erase(struct flash_bank_s *bank, int first, int last)
 {
 	lpc2000_flash_bank_t *lpc2000_info = bank-&gt;driver_priv;
-	u32 param_table[5];
-	u32 result_table[2];
+	uint32_t param_table[5];
+	uint32_t result_table[2];
 	int status_code;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -465,17 +465,17 @@
 	return ERROR_OK;
 }
 
-static int lpc2000_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int lpc2000_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	lpc2000_flash_bank_t *lpc2000_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 dst_min_alignment;
-	u32 bytes_remaining = count;
-	u32 bytes_written = 0;
+	uint32_t dst_min_alignment;
+	uint32_t bytes_remaining = count;
+	uint32_t bytes_written = 0;
 	int first_sector = 0;
 	int last_sector = 0;
-	u32 param_table[5];
-	u32 result_table[2];
+	uint32_t param_table[5];
+	uint32_t result_table[2];
 	int status_code;
 	int i;
 	working_area_t *download_area;
@@ -514,7 +514,7 @@
 	/* check if exception vectors should be flashed */
 	if ((offset == 0) &amp;&amp; (count &gt;= 0x20) &amp;&amp; lpc2000_info-&gt;calc_checksum)
 	{
-		u32 checksum = 0;
+		uint32_t checksum = 0;
 		int i = 0;
 		for (i = 0; i &lt; 8; i++)
 		{
@@ -525,7 +525,7 @@
 		checksum = 0 - checksum;
 		LOG_DEBUG(&quot;checksum: 0x%8.8x&quot;, checksum);
 
-		u32 original_value=buf_get_u32(buffer + (5 * 4), 0, 32);
+		uint32_t original_value=buf_get_u32(buffer + (5 * 4), 0, 32);
 		if (original_value!=checksum)
 		{
 			LOG_WARNING(&quot;Verification will fail since checksum in image(0x%8.8x) written to flash was different from calculated vector checksum(0x%8.8x).&quot;,
@@ -545,7 +545,7 @@
 
 	while (bytes_remaining &gt; 0)
 	{
-		u32 thisrun_bytes;
+		uint32_t thisrun_bytes;
 		if (bytes_remaining &gt;= lpc2000_info-&gt;cmd51_max_buffer)
 			thisrun_bytes = lpc2000_info-&gt;cmd51_max_buffer;
 		else if (bytes_remaining &gt;= 1024)
@@ -590,7 +590,7 @@
 		else
 		{
 			uint8_t *last_buffer = malloc(thisrun_bytes);
-			u32 i;
+			uint32_t i;
 			memcpy(last_buffer, buffer + bytes_written, bytes_remaining);
 			for (i = bytes_remaining; i &lt; thisrun_bytes; i++)
 				last_buffer[i] = 0xff;
@@ -675,8 +675,8 @@
 static int lpc2000_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	flash_bank_t *bank;
-	u32 param_table[5];
-	u32 result_table[2];
+	uint32_t param_table[5];
+	uint32_t result_table[2];
 	int status_code;
 
 	if (argc &lt; 1)

Modified: trunk/src/flash/lpc2000.h
===================================================================
--- trunk/src/flash/lpc2000.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/lpc2000.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -26,12 +26,12 @@
 {
 	int variant;
 	struct working_area_s *iap_working_area;
-	u32 cclk;
+	uint32_t cclk;
 	int cmd51_dst_boundary;
 	int cmd51_can_256b;
 	int cmd51_can_8192b;
 	int calc_checksum;
-	u32 cmd51_max_buffer;
+	uint32_t cmd51_max_buffer;
 } lpc2000_flash_bank_t;
 
 enum lpc2000_status_codes

Modified: trunk/src/flash/lpc288x.c
===================================================================
--- trunk/src/flash/lpc288x.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/lpc288x.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -88,15 +88,15 @@
 static int lpc288x_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int lpc288x_erase(struct flash_bank_s *bank, int first, int last);
 static int lpc288x_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int lpc288x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int lpc288x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int lpc288x_probe(struct flash_bank_s *bank);
 static int lpc288x_erase_check(struct flash_bank_s *bank);
 static int lpc288x_protect_check(struct flash_bank_s *bank);
 static int lpc288x_info(struct flash_bank_s *bank, char *buf, int buf_size);
-static u32 lpc288x_wait_status_busy(flash_bank_t *bank, int timeout);
+static uint32_t lpc288x_wait_status_busy(flash_bank_t *bank, int timeout);
 static void lpc288x_load_timer(int erase, struct target_s *target);
 static void lpc288x_set_flash_clk(struct flash_bank_s *bank);
-static u32 lpc288x_system_ready(struct flash_bank_s *bank);
+static uint32_t lpc288x_system_ready(struct flash_bank_s *bank);
 
 flash_driver_t lpc288x_flash =
 {
@@ -118,9 +118,9 @@
 	return ERROR_OK;
 }
 
-static u32 lpc288x_wait_status_busy(flash_bank_t *bank, int timeout)
+static uint32_t lpc288x_wait_status_busy(flash_bank_t *bank, int timeout)
 {
-	u32 status;
+	uint32_t status;
 	target_t *target = bank-&gt;target;
 	do
 	{
@@ -142,10 +142,10 @@
 {
 	lpc288x_flash_bank_t *lpc288x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 cidr;
+	uint32_t cidr;
 
 	int i = 0;
-	u32 offset;
+	uint32_t offset;
 
 	if (lpc288x_info-&gt;cidr == 0x0102100A)
 		return ERROR_OK; /* already probed, multiple probes may cause memory leak, not allowed */
@@ -221,7 +221,7 @@
  * CLK_DIV = 60 ? */
 static void lpc288x_set_flash_clk(struct flash_bank_s *bank)
 {
-	u32 clk_time;
+	uint32_t clk_time;
 	lpc288x_flash_bank_t *lpc288x_info = bank-&gt;driver_priv;
 	clk_time = (lpc288x_info-&gt;cclk / 66000) / 3;
 	target_write_u32(bank-&gt;target, F_CTRL, FC_CS | FC_WEN);
@@ -246,7 +246,7 @@
 	}
 }
 
-static u32 lpc288x_system_ready(struct flash_bank_s *bank)
+static uint32_t lpc288x_system_ready(struct flash_bank_s *bank)
 {
 	lpc288x_flash_bank_t *lpc288x_info = bank-&gt;driver_priv;
 	if (lpc288x_info-&gt;cidr == 0)
@@ -264,7 +264,7 @@
 
 static int lpc288x_erase_check(struct flash_bank_s *bank)
 {
-	u32 status = lpc288x_system_ready(bank);	/* probed? halted? */
+	uint32_t status = lpc288x_system_ready(bank);	/* probed? halted? */
 	if (status != ERROR_OK)
 	{
 		LOG_INFO(&quot;Processor not halted/not probed&quot;);
@@ -276,7 +276,7 @@
 
 static int lpc288x_erase(struct flash_bank_s *bank, int first, int last)
 {
-	u32 status;
+	uint32_t status;
 	int sector;
 	target_t *target = bank-&gt;target;
 
@@ -315,13 +315,13 @@
 	return ERROR_OK;
 }
 
-static int lpc288x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int lpc288x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	uint8_t page_buffer[FLASH_PAGE_SIZE];
-	u32 status, source_offset,dest_offset;
+	uint32_t status, source_offset,dest_offset;
 	target_t *target = bank-&gt;target;
-	u32 bytes_remaining = count;
-	u32 first_sector, last_sector, sector, page;
+	uint32_t bytes_remaining = count;
+	uint32_t first_sector, last_sector, sector, page;
 	int i;
 
 	/* probed? halted? */
@@ -463,7 +463,7 @@
 static int lpc288x_protect(struct flash_bank_s *bank, int set, int first, int last)
 {
 	int lockregion, status;
-	u32 value;
+	uint32_t value;
 	target_t *target = bank-&gt;target;
 
 	/* probed? halted? */

Modified: trunk/src/flash/lpc288x.h
===================================================================
--- trunk/src/flash/lpc288x.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/lpc288x.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -25,15 +25,15 @@
 
 typedef struct lpc288x_flash_bank_s
 {
-	u32 working_area;
-	u32 working_area_size;
+	uint32_t working_area;
+	uint32_t working_area_size;
 
 	/* chip id register */
-	u32 cidr;
+	uint32_t cidr;
 	char * target_name;
-	u32 cclk;
+	uint32_t cclk;
 
-	u32 sector_size_break;
+	uint32_t sector_size_break;
 } lpc288x_flash_bank_t;
 
 #endif /* lpc288x_H */

Modified: trunk/src/flash/lpc3180_nand_controller.c
===================================================================
--- trunk/src/flash/lpc3180_nand_controller.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/lpc3180_nand_controller.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -32,8 +32,8 @@
 static int lpc3180_address(struct nand_device_s *device, uint8_t address);
 static int lpc3180_write_data(struct nand_device_s *device, uint16_t data);
 static int lpc3180_read_data(struct nand_device_s *device, void *data);
-static int lpc3180_write_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
-static int lpc3180_read_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
+static int lpc3180_write_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+static int lpc3180_read_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 static int lpc3180_controller_ready(struct nand_device_s *device, int timeout);
 static int lpc3180_nand_ready(struct nand_device_s *device, int timeout);
 
@@ -100,7 +100,7 @@
 	return ERROR_OK;
 }
 
-static int lpc3180_pll(int fclkin, u32 pll_ctrl)
+static int lpc3180_pll(int fclkin, uint32_t pll_ctrl)
 {
 	int bypass = (pll_ctrl &amp; 0x8000) &gt;&gt; 15;
 	int direct = (pll_ctrl &amp; 0x4000) &gt;&gt; 14;
@@ -131,7 +131,7 @@
 static float lpc3180_cycle_time(lpc3180_nand_controller_t *lpc3180_info)
 {
 	target_t *target = lpc3180_info-&gt;target;
-	u32 sysclk_ctrl, pwr_ctrl, hclkdiv_ctrl, hclkpll_ctrl;
+	uint32_t sysclk_ctrl, pwr_ctrl, hclkdiv_ctrl, hclkpll_ctrl;
 	int sysclk;
 	int hclk;
 	int hclk_pll;
@@ -231,7 +231,7 @@
 
 	if (lpc3180_info-&gt;selected_controller == LPC3180_MLC_CONTROLLER)
 	{
-		u32 mlc_icr_value = 0x0;
+		uint32_t mlc_icr_value = 0x0;
 		float cycle;
 		int twp, twh, trp, treh, trhz, trbwb, tcea;
 
@@ -477,7 +477,7 @@
 	}
 	else if (lpc3180_info-&gt;selected_controller == LPC3180_SLC_CONTROLLER)
 	{
-		u32 data32;
+		uint32_t data32;
 
 		/* data = SLC_DATA, must use 32-bit access */
 		target_read_u32(target, 0x20020000, &amp;data32);
@@ -502,7 +502,7 @@
 	return ERROR_OK;
 }
 
-static int lpc3180_write_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int lpc3180_write_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
@@ -538,7 +538,7 @@
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
 		}
 
-		if (data_size &gt; (u32)device-&gt;page_size)
+		if (data_size &gt; (uint32_t)device-&gt;page_size)
 		{
 			LOG_ERROR(&quot;data size exceeds page size&quot;);
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
@@ -641,7 +641,7 @@
 	return ERROR_OK;
 }
 
-static int lpc3180_read_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int lpc3180_read_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	lpc3180_nand_controller_t *lpc3180_info = device-&gt;controller_priv;
 	target_t *target = lpc3180_info-&gt;target;
@@ -661,9 +661,9 @@
 	{
 		uint8_t *page_buffer;
 		uint8_t *oob_buffer;
-		u32 page_bytes_done = 0;
-		u32 oob_bytes_done = 0;
-		u32 mlc_isr;
+		uint32_t page_bytes_done = 0;
+		uint32_t oob_bytes_done = 0;
+		uint32_t mlc_isr;
 
 #if 0
 		if (oob &amp;&amp; (oob_size &gt; 6))
@@ -673,7 +673,7 @@
 		}
 #endif
 
-		if (data_size &gt; (u32)device-&gt;page_size)
+		if (data_size &gt; (uint32_t)device-&gt;page_size)
 		{
 			LOG_ERROR(&quot;data size exceeds page size&quot;);
 			return ERROR_NAND_OPERATION_NOT_SUPPORTED;
@@ -733,7 +733,7 @@
 			target_write_u32(target, 0x200b8000, NAND_CMD_READSTART);
 		}
 
-		while (page_bytes_done &lt; (u32)device-&gt;page_size)
+		while (page_bytes_done &lt; (uint32_t)device-&gt;page_size)
 		{
 			/* MLC_ECC_AUTO_DEC_REG = dummy */
 			target_write_u32(target, 0x200b8014, 0xaa55aa55);
@@ -847,7 +847,7 @@
 		}
 		else if (lpc3180_info-&gt;selected_controller == LPC3180_SLC_CONTROLLER)
 		{
-			u32 status = 0x0;
+			uint32_t status = 0x0;
 
 			/* Read SLC_STAT and check READY bit */
 			target_read_u32(target, 0x20020018, &amp;status);

Modified: trunk/src/flash/lpc3180_nand_controller.h
===================================================================
--- trunk/src/flash/lpc3180_nand_controller.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/lpc3180_nand_controller.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -35,8 +35,8 @@
 	int osc_freq;
 	enum lpc3180_selected_controller selected_controller;
 	int sw_write_protection;
-	u32 sw_wp_lower_bound;
-	u32 sw_wp_upper_bound;
+	uint32_t sw_wp_lower_bound;
+	uint32_t sw_wp_upper_bound;
 } lpc3180_nand_controller_t;
 
 #endif /*LPC3180_NAND_CONTROLLER_H */

Modified: trunk/src/flash/mflash.c
===================================================================
--- trunk/src/flash/mflash.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/mflash.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -66,7 +66,7 @@
 
 static int pxa270_set_gpio_to_output (mflash_gpio_num_t gpio)
 {
-	u32 addr, value, mask;
+	uint32_t addr, value, mask;
 	target_t *target = mflash_bank-&gt;target;
 	int ret;
 
@@ -103,7 +103,7 @@
 
 static int pxa270_set_gpio_output_val (mflash_gpio_num_t gpio, uint8_t val)
 {
-	u32 addr, value, mask;
+	uint32_t addr, value, mask;
 	target_t *target = mflash_bank-&gt;target;
 	int ret;
 
@@ -132,7 +132,7 @@
 
 static int s3c2440_set_gpio_to_output (mflash_gpio_num_t gpio)
 {
-	u32 data, mask, gpio_con;
+	uint32_t data, mask, gpio_con;
 	target_t *target = mflash_bank-&gt;target;
 	int ret;
 
@@ -164,7 +164,7 @@
 
 static int s3c2440_set_gpio_output_val (mflash_gpio_num_t gpio, uint8_t val)
 {
-	u32 data, mask, gpio_dat;
+	uint32_t data, mask, gpio_dat;
 	target_t *target = mflash_bank-&gt;target;
 	int ret;
 
@@ -210,11 +210,11 @@
 	return ret;
 }
 
-static int mg_dsk_wait(mg_io_type_wait wait, u32 time)
+static int mg_dsk_wait(mg_io_type_wait wait, uint32_t time)
 {
 	uint8_t status, error;
 	target_t *target = mflash_bank-&gt;target;
-	u32 mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
+	uint32_t mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
 	duration_t duration;
 	int ret;
 	long long t=0;
@@ -291,7 +291,7 @@
 static int mg_dsk_srst(uint8_t on)
 {
 	target_t *target = mflash_bank-&gt;target;
-	u32 mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
+	uint32_t mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
 	uint8_t value;
 	int ret;
 
@@ -308,10 +308,10 @@
 	return ret;
 }
 
-static int mg_dsk_io_cmd(u32 sect_num, u32 cnt, uint8_t cmd)
+static int mg_dsk_io_cmd(uint32_t sect_num, uint32_t cnt, uint8_t cmd)
 {
 	target_t *target = mflash_bank-&gt;target;
-	u32 mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
+	uint32_t mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
 	uint8_t value;
 	int ret;
 
@@ -336,7 +336,7 @@
 static int mg_dsk_drv_info(void)
 {
 	target_t *target = mflash_bank-&gt;target;
-	u32 mg_buff = mflash_bank-&gt;base + MG_BUFFER_OFFSET;
+	uint32_t mg_buff = mflash_bank-&gt;base + MG_BUFFER_OFFSET;
 	int ret;
 
 	if ((ret =  mg_dsk_io_cmd(0, 1, mg_io_cmd_identify)) != ERROR_OK)
@@ -355,7 +355,7 @@
 	if (ret != ERROR_OK)
 		return ret;
 
-	mflash_bank-&gt;drv_info-&gt;tot_sects = (u32)(mflash_bank-&gt;drv_info-&gt;drv_id.total_user_addressable_sectors_hi &lt;&lt; 16)
+	mflash_bank-&gt;drv_info-&gt;tot_sects = (uint32_t)(mflash_bank-&gt;drv_info-&gt;drv_id.total_user_addressable_sectors_hi &lt;&lt; 16)
 									+ mflash_bank-&gt;drv_info-&gt;drv_id.total_user_addressable_sectors_lo;
 
 	return target_write_u8(target, mflash_bank-&gt;base + MG_REG_OFFSET + MG_REG_COMMAND, mg_io_cmd_confirm_read);
@@ -421,9 +421,9 @@
 	return ret;
 }
 
-static int mg_mflash_do_read_sects(void *buff, u32 sect_num, u32 sect_cnt)
+static int mg_mflash_do_read_sects(void *buff, uint32_t sect_num, uint32_t sect_cnt)
 {
-	u32 i, address;
+	uint32_t i, address;
 	int ret;
 	target_t *target = mflash_bank-&gt;target;
 	uint8_t *buff_ptr = buff;
@@ -464,9 +464,9 @@
 	return mg_dsk_wait(mg_io_wait_rdy, MG_OEM_DISK_WAIT_TIME_NORMAL);
 }
 
-static int mg_mflash_read_sects(void *buff, u32 sect_num, u32 sect_cnt)
+static int mg_mflash_read_sects(void *buff, uint32_t sect_num, uint32_t sect_cnt)
 {
-	u32 quotient, residue, i;
+	uint32_t quotient, residue, i;
 	uint8_t *buff_ptr = buff;
 	int ret = ERROR_OK;
 
@@ -493,10 +493,10 @@
 	return ret;
 }
 
-static int mg_mflash_do_write_sects(void *buff, u32 sect_num, u32 sect_cnt,
+static int mg_mflash_do_write_sects(void *buff, uint32_t sect_num, uint32_t sect_cnt,
 		mg_io_type_cmd cmd)
 {
-	u32 i, address;
+	uint32_t i, address;
 	int ret;
 	target_t *target = mflash_bank-&gt;target;
 	uint8_t *buff_ptr = buff;
@@ -542,9 +542,9 @@
 	return ret;
 }
 
-static int mg_mflash_write_sects(void *buff, u32 sect_num, u32 sect_cnt)
+static int mg_mflash_write_sects(void *buff, uint32_t sect_num, uint32_t sect_cnt)
 {
-	u32 quotient, residue, i;
+	uint32_t quotient, residue, i;
 	uint8_t *buff_ptr = buff;
 	int ret = ERROR_OK;
 
@@ -571,11 +571,11 @@
 	return ret;
 }
 
-static int mg_mflash_read (u32 addr, uint8_t *buff, u32 len)
+static int mg_mflash_read (uint32_t addr, uint8_t *buff, uint32_t len)
 {
 	uint8_t *buff_ptr = buff;
 	uint8_t sect_buff[MG_MFLASH_SECTOR_SIZE];
-	u32 cur_addr, next_sec_addr, end_addr, cnt, sect_num;
+	uint32_t cur_addr, next_sec_addr, end_addr, cnt, sect_num;
 	int ret = ERROR_OK;
 
 	cnt = 0;
@@ -635,11 +635,11 @@
 	return ret;
 }
 
-static int mg_mflash_write(u32 addr, uint8_t *buff, u32 len)
+static int mg_mflash_write(uint32_t addr, uint8_t *buff, uint32_t len)
 {
 	uint8_t *buff_ptr = buff;
 	uint8_t sect_buff[MG_MFLASH_SECTOR_SIZE];
-	u32 cur_addr, next_sec_addr, end_addr, cnt, sect_num;
+	uint32_t cur_addr, next_sec_addr, end_addr, cnt, sect_num;
 	int ret = ERROR_OK;
 
 	cnt = 0;
@@ -705,7 +705,7 @@
 
 static int mg_write_cmd(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u32 address, buf_cnt, cnt, res, i;
+	uint32_t address, buf_cnt, cnt, res, i;
 	uint8_t *buffer;
 	fileio_t fileio;
 	duration_t duration;
@@ -772,7 +772,7 @@
 
 static int mg_dump_cmd(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u32 address, size_written, size, cnt, res, i;
+	uint32_t address, size_written, size, cnt, res, i;
 	uint8_t *buffer;
 	fileio_t fileio;
 	duration_t duration;
@@ -841,7 +841,7 @@
 static int mg_set_feature(mg_feature_id feature, mg_feature_val config)
 {
 	target_t *target = mflash_bank-&gt;target;
-	u32 mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
+	uint32_t mg_task_reg = mflash_bank-&gt;base + MG_REG_OFFSET;
 	int ret;
 
 	if ((ret = mg_dsk_wait(mg_io_wait_rdy_noerr, MG_OEM_DISK_WAIT_TIME_NORMAL))
@@ -958,7 +958,7 @@
 {
 	uint16_t buff[MG_MFLASH_SECTOR_SIZE &gt;&gt; 1];
 	uint16_t i, j;
-	u32 address = mflash_bank-&gt;base + MG_BUFFER_OFFSET;
+	uint32_t address = mflash_bank-&gt;base + MG_BUFFER_OFFSET;
 	target_t *target = mflash_bank-&gt;target;
 	int ret;
 
@@ -1152,7 +1152,7 @@
 	buff[0] = mg_op_mode_snd;		/* operation mode */
 	buff[1] = MG_UNLOCK_OTP_AREA;
 	buff[2] = 4;				/* boot size */
-	*((u32 *)(buff + 4)) = 0;		/* XIP size */
+	*((uint32_t *)(buff + 4)) = 0;		/* XIP size */
 
 	if ((ret = mg_mflash_do_write_sects(buff, 0, 1, mg_vcmd_update_xipinfo))
 			!= ERROR_OK)
@@ -1173,7 +1173,7 @@
 
 	memset(buff, 0xff, 512);
 	/* PLL Lock cycle and Feedback 9bit Divider */
-	memcpy(buff, &amp;pll-&gt;lock_cyc, sizeof(u32));
+	memcpy(buff, &amp;pll-&gt;lock_cyc, sizeof(uint32_t));
 	memcpy(buff + 4, &amp;pll-&gt;feedback_div, sizeof(uint16_t));
 	buff[6] = pll-&gt;input_div;		/* PLL Input 5bit Divider */
 	buff[7] = pll-&gt;output_div;		/* PLL Output Divider */
@@ -1254,7 +1254,7 @@
 
 				LOG_INFO(&quot;mflash: Fout=%u Hz, feedback=%u,&quot; 
 						&quot;indiv=%u, outdiv=%u, lock=%u&quot;,
-						(u32)fout, pll.feedback_div,
+						(uint32_t)fout, pll.feedback_div,
 						pll.input_div, pll.output_div,
 						pll.lock_cyc);
 

Modified: trunk/src/flash/mflash.h
===================================================================
--- trunk/src/flash/mflash.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/mflash.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -127,12 +127,12 @@
 
 typedef struct mg_drv_info_s {
 	mg_io_type_drv_info drv_id;
-	u32 tot_sects;
+	uint32_t tot_sects;
 } mg_drv_info_t;
 
 typedef struct mflash_bank_s
 {
-	u32 base;
+	uint32_t base;
 
 	mflash_gpio_num_t rst_pin;
 

Modified: trunk/src/flash/nand.c
===================================================================
--- trunk/src/flash/nand.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/nand.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -38,10 +38,10 @@
 
 static int handle_nand_raw_access_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-static int nand_read_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
-//static int nand_read_plain(struct nand_device_s *device, u32 address, uint8_t *data, u32 data_size);
+static int nand_read_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+//static int nand_read_plain(struct nand_device_s *device, uint32_t address, uint8_t *data, uint32_t data_size);
 
-static int nand_write_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
+static int nand_write_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 
 /* NAND flash controller
  */
@@ -339,7 +339,7 @@
 
 static int nand_build_bbt(struct nand_device_s *device, int first, int last)
 {
-	u32 page = 0x0;
+	uint32_t page = 0x0;
 	int i;
 	uint8_t oob[6];
 
@@ -638,7 +638,7 @@
 int nand_erase(struct nand_device_s *device, int first_block, int last_block)
 {
 	int i;
-	u32 page;
+	uint32_t page;
 	uint8_t status;
 	int retval;
 
@@ -721,7 +721,7 @@
 }
 
 #if 0
-static int nand_read_plain(struct nand_device_s *device, u32 address, uint8_t *data, u32 data_size)
+static int nand_read_plain(struct nand_device_s *device, uint32_t address, uint8_t *data, uint32_t data_size)
 {
 	uint8_t *page;
 
@@ -738,8 +738,8 @@
 
 	while (data_size &gt; 0 )
 	{
-		u32 thisrun_size = (data_size &gt; device-&gt;page_size) ? device-&gt;page_size : data_size;
-		u32 page_address;
+		uint32_t thisrun_size = (data_size &gt; device-&gt;page_size) ? device-&gt;page_size : data_size;
+		uint32_t page_address;
 
 
 		page_address = address / device-&gt;page_size;
@@ -758,7 +758,7 @@
 	return ERROR_OK;
 }
 
-static int nand_write_plain(struct nand_device_s *device, u32 address, uint8_t *data, u32 data_size)
+static int nand_write_plain(struct nand_device_s *device, uint32_t address, uint8_t *data, uint32_t data_size)
 {
 	uint8_t *page;
 
@@ -775,8 +775,8 @@
 
 	while (data_size &gt; 0 )
 	{
-		u32 thisrun_size = (data_size &gt; device-&gt;page_size) ? device-&gt;page_size : data_size;
-		u32 page_address;
+		uint32_t thisrun_size = (data_size &gt; device-&gt;page_size) ? device-&gt;page_size : data_size;
+		uint32_t page_address;
 
 		memset(page, 0xff, device-&gt;page_size);
 		memcpy(page, data, thisrun_size);
@@ -796,9 +796,9 @@
 }
 #endif
 
-int nand_write_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+int nand_write_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
-	u32 block;
+	uint32_t block;
 
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
@@ -813,7 +813,7 @@
 		return device-&gt;controller-&gt;write_page(device, page, data, data_size, oob, oob_size);
 }
 
-static int nand_read_page(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+static int nand_read_page(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
@@ -824,9 +824,9 @@
 		return device-&gt;controller-&gt;read_page(device, page, data, data_size, oob, oob_size);
 }
 
-int nand_read_page_raw(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+int nand_read_page_raw(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
-	u32 i;
+	uint32_t i;
 
 	if (!device-&gt;device)
 		return ERROR_NAND_DEVICE_NOT_PROBED;
@@ -938,9 +938,9 @@
 	return ERROR_OK;
 }
 
-int nand_write_page_raw(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size)
+int nand_write_page_raw(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
 {
-	u32 i;
+	uint32_t i;
 	int retval;
 	uint8_t status;
 
@@ -1310,9 +1310,9 @@
 
 static int handle_nand_write_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u32 offset;
-	u32 binary_size;
-	u32 buf_cnt;
+	uint32_t offset;
+	uint32_t binary_size;
+	uint32_t buf_cnt;
 	enum oob_formats oob_format = NAND_OOB_NONE;
 
 	fileio_t fileio;
@@ -1332,9 +1332,9 @@
 	if (p)
 	{
 		uint8_t *page = NULL;
-		u32 page_size = 0;
+		uint32_t page_size = 0;
 		uint8_t *oob = NULL;
-		u32 oob_size = 0;
+		uint32_t oob_size = 0;
 		const int *eccpos = NULL;
 
 		offset = strtoul(args[2], NULL, 0);
@@ -1398,7 +1398,7 @@
 
 		while (buf_cnt &gt; 0)
 		{
-			u32 size_read;
+			uint32_t size_read;
 
 			if (NULL != page)
 			{
@@ -1412,7 +1412,7 @@
 
 			if (oob_format &amp; NAND_OOB_SW_ECC)
 			{
-				u32 i, j;
+				uint32_t i, j;
 				uint8_t ecc[3];
 				memset(oob, 0xff, oob_size);
 				for (i = 0, j = 0; i &lt; page_size; i += 256) {
@@ -1429,7 +1429,7 @@
 				 * at the end of the OOB area.  It consists
 				 * of 10 bytes per 512-byte data block.
 				 */
-				u32 i;
+				uint32_t i;
 				uint8_t *ecc = oob + oob_size - page_size/512 * 10;
 				memset(oob, 0xff, oob_size);
 				for (i = 0; i &lt; page_size; i += 512) {
@@ -1500,12 +1500,12 @@
 			int retval;
 
 			uint8_t *page = NULL;
-			u32 page_size = 0;
+			uint32_t page_size = 0;
 			uint8_t *oob = NULL;
-			u32 oob_size = 0;
-			u32 address = strtoul(args[2], NULL, 0);
-			u32 size = strtoul(args[3], NULL, 0);
-			u32 bytes_done = 0;
+			uint32_t oob_size = 0;
+			uint32_t address = strtoul(args[2], NULL, 0);
+			uint32_t size = strtoul(args[3], NULL, 0);
+			uint32_t bytes_done = 0;
 			enum oob_formats oob_format = NAND_OOB_NONE;
 
 			if (argc &gt; 4)
@@ -1552,7 +1552,7 @@
 
 			while (size &gt; 0)
 			{
-				u32 size_written;
+				uint32_t size_written;
 				if ((retval = nand_read_page(p, address / p-&gt;page_size, page, page_size, oob, oob_size)) != ERROR_OK)
 				{
 					command_print(cmd_ctx, &quot;reading NAND flash page failed&quot;);

Modified: trunk/src/flash/nand.h
===================================================================
--- trunk/src/flash/nand.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/nand.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -42,16 +42,16 @@
 	int (*read_data)(struct nand_device_s *device, void *data);
 	int (*write_block_data)(struct nand_device_s *device, uint8_t *data, int size);
 	int (*read_block_data)(struct nand_device_s *device, uint8_t *data, int size);
-	int (*write_page)(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
-	int (*read_page)(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
+	int (*write_page)(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+	int (*read_page)(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 	int (*controller_ready)(struct nand_device_s *device, int timeout);
 	int (*nand_ready)(struct nand_device_s *device, int timeout);
 } nand_flash_controller_t;
 
 typedef struct nand_block_s
 {
-	u32 offset;
-	u32 size;
+	uint32_t offset;
+	uint32_t size;
 	int is_erased;
 	int is_bad;
 } nand_block_t;
@@ -208,8 +208,8 @@
 
 /* Function prototypes */
 extern nand_device_t *get_nand_device_by_num(int num);
-extern int nand_read_page_raw(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
-extern int nand_write_page_raw(struct nand_device_s *device, u32 page, uint8_t *data, u32 data_size, uint8_t *oob, u32 oob_size);
+extern int nand_read_page_raw(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+extern int nand_write_page_raw(struct nand_device_s *device, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 extern int nand_read_status(struct nand_device_s *device, uint8_t *status);
 extern int nand_calculate_ecc(struct nand_device_s *device, const uint8_t *dat, uint8_t *ecc_code);
 extern int nand_calculate_ecc_kw(struct nand_device_s *device, const uint8_t *dat, uint8_t *ecc_code);

Modified: trunk/src/flash/non_cfi.h
===================================================================
--- trunk/src/flash/non_cfi.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/non_cfi.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -27,11 +27,11 @@
 	uint16_t mfr;
 	uint16_t id;
 	uint16_t pri_id;
-	u32 dev_size;
+	uint32_t dev_size;
 	uint16_t interface_desc;
 	uint16_t max_buf_write_size;
 	uint8_t num_erase_regions;
-	u32 erase_region_info[6];
+	uint32_t erase_region_info[6];
 	uint8_t  status_poll_mask;
 } non_cfi_t;
 

Modified: trunk/src/flash/ocl.c
===================================================================
--- trunk/src/flash/ocl.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/ocl.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -30,7 +30,7 @@
 static int ocl_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int ocl_erase(struct flash_bank_s *bank, int first, int last);
 static int ocl_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int ocl_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int ocl_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int ocl_probe(struct flash_bank_s *bank);
 static int ocl_erase_check(struct flash_bank_s *bank);
 static int ocl_protect_check(struct flash_bank_s *bank);
@@ -103,7 +103,7 @@
 {
 	ocl_priv_t *ocl = bank-&gt;driver_priv;
 	int retval;
-	u32 dcc_buffer[3];
+	uint32_t dcc_buffer[3];
 
 	/* check preconditions */
 	if (bank-&gt;num_sectors == 0)
@@ -159,15 +159,15 @@
 	return ERROR_OK;
 }
 
-static int ocl_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int ocl_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	ocl_priv_t *ocl = bank-&gt;driver_priv;
 	int retval;
-	u32 *dcc_buffer;
-	u32 *dcc_bufptr;
+	uint32_t *dcc_buffer;
+	uint32_t *dcc_bufptr;
 	int byteofs;
 	int runlen;
-	u32 chksum;
+	uint32_t chksum;
 
 	int i;
 
@@ -182,7 +182,7 @@
 	}
 
 	/* allocate buffer for max. ocl buffer + overhead */
-	dcc_buffer = malloc(sizeof(u32)*(ocl-&gt;buflen/4+3));
+	dcc_buffer = malloc(sizeof(uint32_t)*(ocl-&gt;buflen/4+3));
 
 	while (count)
 	{
@@ -270,7 +270,7 @@
 {
 	ocl_priv_t *ocl = bank-&gt;driver_priv;
 	int retval;
-	u32 dcc_buffer[1];
+	uint32_t dcc_buffer[1];
 	int sectsize;
 	int i;
 

Modified: trunk/src/flash/orion_nand.c
===================================================================
--- trunk/src/flash/orion_nand.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/orion_nand.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -36,9 +36,9 @@
 	struct target_s	*target;
 	working_area_t *copy_area;
 
-	u32		cmd;
-	u32		addr;
-	u32		data;
+	uint32_t		cmd;
+	uint32_t		addr;
+	uint32_t		data;
 } orion_nand_controller_t;
 
 #define CHECK_HALTED \
@@ -102,10 +102,10 @@
 	target_t *target = hw-&gt;target;
 	armv4_5_algorithm_t algo;
 	reg_param_t reg_params[3];
-	u32 target_buf;
+	uint32_t target_buf;
 	int retval;
 
-	static const u32 code[] = {
+	static const uint32_t code[] = {
 		0xe4d13001,	/* ldrb	r3, [r1], #1	*/
 		0xe5c03000,	/* strb	r3, [r0]	*/
 		0xe2522001,	/* subs	r2, r2, #1	*/
@@ -194,7 +194,7 @@
 			      struct nand_device_s *device)
 {
 	orion_nand_controller_t *hw;
-	u32 base;
+	uint32_t base;
 	uint8_t ale, cle;
 
 	if (argc != 3) {

Modified: trunk/src/flash/pic32mx.c
===================================================================
--- trunk/src/flash/pic32mx.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/pic32mx.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -35,7 +35,7 @@
 struct pic32mx_devs_s {
 	uint8_t	devid;
 	char	*name;
-	u32	pfm_size;
+	uint32_t	pfm_size;
 } pic32mx_devs[] = {
 	{ 0x78, &quot;460F512L USB&quot;, 512 },
 	{ 0x74, &quot;460F256L USB&quot;, 256 },
@@ -61,9 +61,9 @@
 static int pic32mx_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int pic32mx_erase(struct flash_bank_s *bank, int first, int last);
 static int pic32mx_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int pic32mx_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
-static int pic32mx_write_row(struct flash_bank_s *bank, u32 address, u32 srcaddr);
-static int pic32mx_write_word(struct flash_bank_s *bank, u32 address, u32 word);
+static int pic32mx_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
+static int pic32mx_write_row(struct flash_bank_s *bank, uint32_t address, uint32_t srcaddr);
+static int pic32mx_write_word(struct flash_bank_s *bank, uint32_t address, uint32_t word);
 static int pic32mx_probe(struct flash_bank_s *bank);
 static int pic32mx_auto_probe(struct flash_bank_s *bank);
 //static int pic32mx_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
@@ -131,19 +131,19 @@
 	return ERROR_OK;
 }
 
-static u32 pic32mx_get_flash_status(flash_bank_t *bank)
+static uint32_t pic32mx_get_flash_status(flash_bank_t *bank)
 {
 	target_t *target = bank-&gt;target;
-	u32 status;
+	uint32_t status;
 
 	target_read_u32(target, PIC32MX_NVMCON, &amp;status);
 
 	return status;
 }
 
-static u32 pic32mx_wait_status_busy(flash_bank_t *bank, int timeout)
+static uint32_t pic32mx_wait_status_busy(flash_bank_t *bank, int timeout)
 {
-	u32 status;
+	uint32_t status;
 
 	/* wait for busy to clear */
 	while (((status = pic32mx_get_flash_status(bank)) &amp; NVMCON_NVMWR) &amp;&amp; (timeout-- &gt; 0))
@@ -157,10 +157,10 @@
 	return status;
 }
 
-static int pic32mx_nvm_exec(struct flash_bank_s *bank, u32 op, u32 timeout)
+static int pic32mx_nvm_exec(struct flash_bank_s *bank, uint32_t op, uint32_t timeout)
 {
 	target_t *target = bank-&gt;target;
-	u32 status;
+	uint32_t status;
 
 	target_write_u32(target, PIC32MX_NVMCON, NVMCON_NVMWREN|op);
 
@@ -183,7 +183,7 @@
 {
 	target_t *target = bank-&gt;target;
 
-	u32 devcfg0;
+	uint32_t devcfg0;
 	int s;
 	int num_pages;
 
@@ -217,7 +217,7 @@
 {
 	target_t *target = bank-&gt;target;
 	int i;
-	u32 status;
+	uint32_t status;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -263,7 +263,7 @@
 	uint16_t prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
 	int i, reg, bit;
 	int status;
-	u32 protection;
+	uint32_t protection;
 #endif
 
 	pic32mx_info = bank-&gt;driver_priv;
@@ -348,12 +348,12 @@
 #endif
 }
 
-static int pic32mx_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int pic32mx_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	target_t *target = bank-&gt;target;
-	u32 buffer_size = 512;
+	uint32_t buffer_size = 512;
 	working_area_t *source;
-	u32 address = bank-&gt;base + offset;
+	uint32_t address = bank-&gt;base + offset;
 	int retval = ERROR_OK;
 #if 0
 	pic32mx_flash_bank_t *pic32mx_info = bank-&gt;driver_priv;
@@ -407,7 +407,7 @@
 
 	while (count &gt;= buffer_size/4)
 	{
-		u32 status;
+		uint32_t status;
 
 		if ((retval = target_write_buffer(target, source-&gt;address, buffer_size, buffer))!=ERROR_OK) {
 			LOG_ERROR(&quot;Failed to write row buffer (%d words) to RAM&quot;, buffer_size/4);
@@ -454,10 +454,10 @@
 
 	while(count &gt; 0)
 	{
-		u32 value;
-		memcpy(&amp;value, buffer, sizeof(u32));
+		uint32_t value;
+		memcpy(&amp;value, buffer, sizeof(uint32_t));
 
-		u32 status = pic32mx_write_word(bank, address, value);
+		uint32_t status = pic32mx_write_word(bank, address, value);
 		if( status &amp; NVMCON_NVMERR ) {
 			LOG_ERROR(&quot;Flash write error NVMERR (status=0x%08x)&quot;, status);
 			retval = ERROR_FLASH_OPERATION_FAILED;
@@ -477,7 +477,7 @@
 	return retval;
 }
 
-static int pic32mx_write_word(struct flash_bank_s *bank, u32 address, u32 word)
+static int pic32mx_write_word(struct flash_bank_s *bank, uint32_t address, uint32_t word)
 {
 	target_t *target = bank-&gt;target;
 
@@ -493,7 +493,7 @@
 /*
  * Write a 128 word (512 byte) row to flash address from RAM srcaddr.
  */
-static int pic32mx_write_row(struct flash_bank_s *bank, u32 address, u32 srcaddr)
+static int pic32mx_write_row(struct flash_bank_s *bank, uint32_t address, uint32_t srcaddr)
 {
 	target_t *target = bank-&gt;target;
 
@@ -511,13 +511,13 @@
 	return pic32mx_nvm_exec(bank, NVMCON_OP_ROW_PROG, 100);
 }
 
-static int pic32mx_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int pic32mx_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
-	u32 words_remaining = (count / 4);
-	u32 bytes_remaining = (count &amp; 0x00000003);
-	u32 address = bank-&gt;base + offset;
-	u32 bytes_written = 0;
-	u32 status;
+	uint32_t words_remaining = (count / 4);
+	uint32_t bytes_remaining = (count &amp; 0x00000003);
+	uint32_t address = bank-&gt;base + offset;
+	uint32_t bytes_written = 0;
+	uint32_t status;
 	int retval;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -560,8 +560,8 @@
 
 	while (words_remaining &gt; 0)
 	{
-		u32 value;
-		memcpy(&amp;value, buffer + bytes_written, sizeof(u32));
+		uint32_t value;
+		memcpy(&amp;value, buffer + bytes_written, sizeof(uint32_t));
 
 		status = pic32mx_write_word(bank, address, value);
 		if( status &amp; NVMCON_NVMERR )
@@ -576,7 +576,7 @@
 
 	if (bytes_remaining)
 	{
-		u32 value = 0xffffffff;
+		uint32_t value = 0xffffffff;
 		memcpy(&amp;value, buffer + bytes_written, bytes_remaining);
 
 		status = pic32mx_write_word(bank, address, value);
@@ -597,7 +597,7 @@
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
 	int i;
 	uint16_t num_pages = 0;
-	u32 device_id;
+	uint32_t device_id;
 	int page_size;
 
 	pic32mx_info-&gt;probed = 0;
@@ -688,7 +688,7 @@
 	target_t *target = bank-&gt;target;
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	u32 device_id;
+	uint32_t device_id;
 	int printed = 0, i;
 
 	device_id = ejtag_info-&gt;idcode;
@@ -815,7 +815,7 @@
 {
 	target_t *target = bank-&gt;target;
 #if 0
-	u32 status;
+	uint32_t status;
 #endif
 
 	if (target-&gt;state != TARGET_HALTED)
@@ -897,7 +897,7 @@
 static int pic32mx_handle_pgm_word_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	flash_bank_t *bank;
-	u32 address, value;
+	uint32_t address, value;
 	int status, res;
 
 	if (argc != 3)

Modified: trunk/src/flash/pic32mx.h
===================================================================
--- trunk/src/flash/pic32mx.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/pic32mx.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -105,8 +105,8 @@
 #define NVMKEY2			0x556699AA
 
 typedef struct pic32mx_mem_layout_s {
-	u32 sector_start;
-	u32 sector_size;
+	uint32_t sector_start;
+	uint32_t sector_size;
 } pic32mx_mem_layout_t;
 
 #endif /* PIC32MX_H */

Modified: trunk/src/flash/s3c2440_nand.c
===================================================================
--- trunk/src/flash/s3c2440_nand.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/s3c2440_nand.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -120,8 +120,8 @@
 {
 	s3c24xx_nand_controller_t *s3c24xx_info = device-&gt;controller_priv;
 	target_t *target = s3c24xx_info-&gt;target;
-	u32 nfdata = s3c24xx_info-&gt;data;
-	u32 tmp;
+	uint32_t nfdata = s3c24xx_info-&gt;data;
+	uint32_t tmp;
 
 	LOG_INFO(&quot;%s: reading data: %p, %p, %d\n&quot;, __func__, device, data, data_size);
 
@@ -156,8 +156,8 @@
 {
 	s3c24xx_nand_controller_t *s3c24xx_info = device-&gt;controller_priv;
 	target_t *target = s3c24xx_info-&gt;target;
-	u32 nfdata = s3c24xx_info-&gt;data;
-	u32 tmp;
+	uint32_t nfdata = s3c24xx_info-&gt;data;
+	uint32_t tmp;
 
 	if (target-&gt;state != TARGET_HALTED) {
 		LOG_ERROR(&quot;target must be halted to use S3C24XX NAND flash controller&quot;);

Modified: trunk/src/flash/s3c24xx_nand.h
===================================================================
--- trunk/src/flash/s3c24xx_nand.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/s3c24xx_nand.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -32,10 +32,10 @@
 	struct target_s *target;
 
 	/* register addresses */
-	u32		 cmd;
-	u32		 addr;
-	u32		 data;
-	u32		 nfstat;
+	uint32_t		 cmd;
+	uint32_t		 addr;
+	uint32_t		 data;
+	uint32_t		 nfstat;
 } s3c24xx_nand_controller_t;
 
 /* Default to using the un-translated NAND register based address */

Modified: trunk/src/flash/stellaris.c
===================================================================
--- trunk/src/flash/stellaris.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/stellaris.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -38,16 +38,16 @@
 static int stellaris_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int stellaris_erase(struct flash_bank_s *bank, int first, int last);
 static int stellaris_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int stellaris_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int stellaris_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int stellaris_auto_probe(struct flash_bank_s *bank);
 static int stellaris_probe(struct flash_bank_s *bank);
 static int stellaris_protect_check(struct flash_bank_s *bank);
 static int stellaris_info(struct flash_bank_s *bank, char *buf, int buf_size);
 
 static int stellaris_read_part_info(struct flash_bank_s *bank);
-static u32 stellaris_get_flash_status(flash_bank_t *bank);
+static uint32_t stellaris_get_flash_status(flash_bank_t *bank);
 static void stellaris_set_flash_mode(flash_bank_t *bank,int mode);
-//static u32 stellaris_wait_status_busy(flash_bank_t *bank, u32 waitbits, int timeout);
+//static uint32_t stellaris_wait_status_busy(flash_bank_t *bank, uint32_t waitbits, int timeout);
 
 static int stellaris_handle_mass_erase_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int stellaris_mass_erase(struct flash_bank_s *bank);
@@ -68,7 +68,7 @@
 };
 
 static struct {
-	u32 partno;
+	uint32_t partno;
 	char *partname;
 }	StellarisParts[] =
 {
@@ -320,10 +320,10 @@
 *	chip identification and status                                         *
 ***************************************************************************/
 
-static u32 stellaris_get_flash_status(flash_bank_t *bank)
+static uint32_t stellaris_get_flash_status(flash_bank_t *bank)
 {
 	target_t *target = bank-&gt;target;
-	u32 fmc;
+	uint32_t fmc;
 
 	target_read_u32(target, FLASH_CONTROL_BASE|FLASH_FMC, &amp;fmc);
 
@@ -336,7 +336,7 @@
 {
 	stellaris_flash_bank_t *stellaris_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 rcc, pllcfg, sysdiv, usesysdiv, bypass, oscsrc;
+	uint32_t rcc, pllcfg, sysdiv, usesysdiv, bypass, oscsrc;
 	unsigned long mainfreq;
 
 	target_read_u32(target, SCB_BASE|RCC, &amp;rcc);
@@ -389,15 +389,15 @@
 	stellaris_flash_bank_t *stellaris_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
 
-	u32 usecrl = (stellaris_info-&gt;mck_freq/1000000ul-1);
+	uint32_t usecrl = (stellaris_info-&gt;mck_freq/1000000ul-1);
 	LOG_DEBUG(&quot;usecrl = %i&quot;,usecrl);
 	target_write_u32(target, SCB_BASE|USECRL, usecrl);
 }
 
 #if 0
-static u32 stellaris_wait_status_busy(flash_bank_t *bank, u32 waitbits, int timeout)
+static uint32_t stellaris_wait_status_busy(flash_bank_t *bank, uint32_t waitbits, int timeout)
 {
-	u32 status;
+	uint32_t status;
 
 	/* Stellaris waits for cmdbit to clear */
 	while (((status = stellaris_get_flash_status(bank)) &amp; waitbits) &amp;&amp; (timeout-- &gt; 0))
@@ -414,7 +414,7 @@
 /* Send one command to the flash controller */
 static int stellaris_flash_command(struct flash_bank_s *bank,uint8_t cmd,uint16_t pagen)
 {
-	u32 fmc;
+	uint32_t fmc;
 	target_t *target = bank-&gt;target;
 
 	fmc = FMC_WRKEY | cmd;
@@ -435,7 +435,7 @@
 {
 	stellaris_flash_bank_t *stellaris_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 did0, did1, ver, fam, status;
+	uint32_t did0, did1, ver, fam, status;
 	int i;
 
 	/* Read and parse chip identification register */
@@ -508,7 +508,7 @@
 
 static int stellaris_protect_check(struct flash_bank_s *bank)
 {
-	u32 status;
+	uint32_t status;
 
 	stellaris_flash_bank_t *stellaris_info = bank-&gt;driver_priv;
 
@@ -538,7 +538,7 @@
 static int stellaris_erase(struct flash_bank_s *bank, int first, int last)
 {
 	int banknr;
-	u32 flash_fmc, flash_cris;
+	uint32_t flash_fmc, flash_cris;
 	stellaris_flash_bank_t *stellaris_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
 
@@ -607,7 +607,7 @@
 
 static int stellaris_protect(struct flash_bank_s *bank, int set, int first, int last)
 {
-	u32 fmppe, flash_fmc, flash_cris;
+	uint32_t fmppe, flash_fmc, flash_cris;
 	int lockregion;
 
 	stellaris_flash_bank_t *stellaris_info = bank-&gt;driver_priv;
@@ -721,13 +721,13 @@
 	0x01,0x00,0x42,0xA4 	/* .word	0xA4420001 */
 };
 
-static int stellaris_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 wcount)
+static int stellaris_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t wcount)
 {
 	target_t *target = bank-&gt;target;
-	u32 buffer_size = 8192;
+	uint32_t buffer_size = 8192;
 	working_area_t *source;
 	working_area_t *write_algorithm;
-	u32 address = bank-&gt;base + offset;
+	uint32_t address = bank-&gt;base + offset;
 	reg_param_t reg_params[3];
 	armv7m_algorithm_t armv7m_info;
 	int retval = ERROR_OK;
@@ -770,7 +770,7 @@
 
 	while (wcount &gt; 0)
 	{
-		u32 thisrun_count = (wcount &gt; (buffer_size / 4)) ? (buffer_size / 4) : wcount;
+		uint32_t thisrun_count = (wcount &gt; (buffer_size / 4)) ? (buffer_size / 4) : wcount;
 
 		target_write_buffer(target, source-&gt;address, thisrun_count * 4, buffer);
 
@@ -801,15 +801,15 @@
 	return retval;
 }
 
-static int stellaris_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int stellaris_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	stellaris_flash_bank_t *stellaris_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 address = offset;
-	u32 flash_cris, flash_fmc;
-	u32 words_remaining = (count / 4);
-	u32 bytes_remaining = (count &amp; 0x00000003);
-	u32 bytes_written = 0;
+	uint32_t address = offset;
+	uint32_t flash_cris, flash_fmc;
+	uint32_t words_remaining = (count / 4);
+	uint32_t bytes_remaining = (count &amp; 0x00000003);
+	uint32_t bytes_written = 0;
 	int retval;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -964,7 +964,7 @@
 {
 	target_t *target = NULL;
 	stellaris_flash_bank_t *stellaris_info = NULL;
-	u32 flash_fmc;
+	uint32_t flash_fmc;
 
 	stellaris_info = bank-&gt;driver_priv;
 	target = bank-&gt;target;

Modified: trunk/src/flash/stellaris.h
===================================================================
--- trunk/src/flash/stellaris.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/stellaris.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -25,28 +25,28 @@
 typedef struct stellaris_flash_bank_s
 {
 	/* chip id register */
-	u32 did0;
-	u32 did1;
-	u32 dc0;
-	u32 dc1;
+	uint32_t did0;
+	uint32_t did1;
+	uint32_t dc0;
+	uint32_t dc1;
 
 	char * target_name;
 
-	u32 sramsiz;
-	u32 flshsz;
+	uint32_t sramsiz;
+	uint32_t flshsz;
 	/* flash geometry */
-	u32 num_pages;
-	u32 pagesize;
-	u32 pages_in_lockregion;
+	uint32_t num_pages;
+	uint32_t pagesize;
+	uint32_t pages_in_lockregion;
 
 	/* nv memory bits */
 	uint16_t num_lockbits;
-	u32 lockbits;
+	uint32_t lockbits;
 
 	/* main clock status */
-	u32 rcc;
+	uint32_t rcc;
 	uint8_t  mck_valid;
-	u32 mck_freq;
+	uint32_t mck_freq;
 } stellaris_flash_bank_t;
 
 /* STELLARIS control registers */

Modified: trunk/src/flash/stm32x.c
===================================================================
--- trunk/src/flash/stm32x.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/stm32x.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -33,7 +33,7 @@
 static int stm32x_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int stm32x_erase(struct flash_bank_s *bank, int first, int last);
 static int stm32x_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int stm32x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int stm32x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int stm32x_probe(struct flash_bank_s *bank);
 static int stm32x_auto_probe(struct flash_bank_s *bank);
 //static int stm32x_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
@@ -100,20 +100,20 @@
 	return ERROR_OK;
 }
 
-static u32 stm32x_get_flash_status(flash_bank_t *bank)
+static uint32_t stm32x_get_flash_status(flash_bank_t *bank)
 {
 	target_t *target = bank-&gt;target;
-	u32 status;
+	uint32_t status;
 
 	target_read_u32(target, STM32_FLASH_SR, &amp;status);
 
 	return status;
 }
 
-static u32 stm32x_wait_status_busy(flash_bank_t *bank, int timeout)
+static uint32_t stm32x_wait_status_busy(flash_bank_t *bank, int timeout)
 {
 	target_t *target = bank-&gt;target;
-	u32 status;
+	uint32_t status;
 
 	/* wait for busy to clear */
 	while (((status = stm32x_get_flash_status(bank)) &amp; FLASH_BSY) &amp;&amp; (timeout-- &gt; 0))
@@ -131,7 +131,7 @@
 
 static int stm32x_read_options(struct flash_bank_s *bank)
 {
-	u32 optiondata;
+	uint32_t optiondata;
 	stm32x_flash_bank_t *stm32x_info = NULL;
 	target_t *target = bank-&gt;target;
 
@@ -161,7 +161,7 @@
 {
 	stm32x_flash_bank_t *stm32x_info = NULL;
 	target_t *target = bank-&gt;target;
-	u32 status;
+	uint32_t status;
 
 	stm32x_info = bank-&gt;driver_priv;
 
@@ -198,7 +198,7 @@
 {
 	stm32x_flash_bank_t *stm32x_info = NULL;
 	target_t *target = bank-&gt;target;
-	u32 status;
+	uint32_t status;
 
 	stm32x_info = bank-&gt;driver_priv;
 
@@ -283,7 +283,7 @@
 	target_t *target = bank-&gt;target;
 	stm32x_flash_bank_t *stm32x_info = bank-&gt;driver_priv;
 
-	u32 protection;
+	uint32_t protection;
 	int i, s;
 	int num_bits;
 	int set;
@@ -353,7 +353,7 @@
 {
 	target_t *target = bank-&gt;target;
 	int i;
-	u32 status;
+	uint32_t status;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -397,7 +397,7 @@
 	uint16_t prot_reg[4] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};
 	int i, reg, bit;
 	int status;
-	u32 protection;
+	uint32_t protection;
 
 	stm32x_info = bank-&gt;driver_priv;
 
@@ -477,13 +477,13 @@
 	return stm32x_write_options(bank);
 }
 
-static int stm32x_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int stm32x_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	stm32x_flash_bank_t *stm32x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 buffer_size = 16384;
+	uint32_t buffer_size = 16384;
 	working_area_t *source;
-	u32 address = bank-&gt;base + offset;
+	uint32_t address = bank-&gt;base + offset;
 	reg_param_t reg_params[4];
 	armv7m_algorithm_t armv7m_info;
 	int retval = ERROR_OK;
@@ -545,7 +545,7 @@
 
 	while (count &gt; 0)
 	{
-		u32 thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
+		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
 
 		if ((retval = target_write_buffer(target, source-&gt;address, thisrun_count * 2, buffer))!=ERROR_OK)
 			break;
@@ -596,13 +596,13 @@
 	return retval;
 }
 
-static int stm32x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int stm32x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	target_t *target = bank-&gt;target;
-	u32 words_remaining = (count / 2);
-	u32 bytes_remaining = (count &amp; 0x00000001);
-	u32 address = bank-&gt;base + offset;
-	u32 bytes_written = 0;
+	uint32_t words_remaining = (count / 2);
+	uint32_t bytes_remaining = (count &amp; 0x00000001);
+	uint32_t address = bank-&gt;base + offset;
+	uint32_t bytes_written = 0;
 	uint8_t status;
 	int retval;
 
@@ -707,7 +707,7 @@
 	stm32x_flash_bank_t *stm32x_info = bank-&gt;driver_priv;
 	int i;
 	uint16_t num_pages;
-	u32 device_id;
+	uint32_t device_id;
 	int page_size;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -836,7 +836,7 @@
 static int stm32x_info(struct flash_bank_s *bank, char *buf, int buf_size)
 {
 	target_t *target = bank-&gt;target;
-	u32 device_id;
+	uint32_t device_id;
 	int printed;
 
 	/* read stm32 device id register */
@@ -1033,7 +1033,7 @@
 static int stm32x_handle_options_read_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
 	flash_bank_t *bank;
-	u32 optionbyte;
+	uint32_t optionbyte;
 	target_t *target = NULL;
 	stm32x_flash_bank_t *stm32x_info = NULL;
 
@@ -1168,7 +1168,7 @@
 static int stm32x_mass_erase(struct flash_bank_s *bank)
 {
 	target_t *target = bank-&gt;target;
-	u32 status;
+	uint32_t status;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{

Modified: trunk/src/flash/stm32x.h
===================================================================
--- trunk/src/flash/stm32x.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/stm32x.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -94,8 +94,8 @@
 #define KEY2			0xCDEF89AB
 
 typedef struct stm32x_mem_layout_s {
-	u32 sector_start;
-	u32 sector_size;
+	uint32_t sector_start;
+	uint32_t sector_size;
 } stm32x_mem_layout_t;
 
 #endif /* STM32X_H */

Modified: trunk/src/flash/str7x.c
===================================================================
--- trunk/src/flash/str7x.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/str7x.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -49,7 +49,7 @@
 static int str7x_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int str7x_erase(struct flash_bank_s *bank, int first, int last);
 static int str7x_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int str7x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int str7x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int str7x_probe(struct flash_bank_s *bank);
 //static int str7x_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int str7x_protect_check(struct flash_bank_s *bank);
@@ -82,7 +82,7 @@
 	return ERROR_OK;
 }
 
-static int str7x_get_flash_adr(struct flash_bank_s *bank, u32 reg)
+static int str7x_get_flash_adr(struct flash_bank_s *bank, uint32_t reg)
 {
 	str7x_flash_bank_t *str7x_info = bank-&gt;driver_priv;
 	return (str7x_info-&gt;register_base | reg);
@@ -119,7 +119,7 @@
 	
 	bank-&gt;num_sectors = num_sectors;
 	bank-&gt;sectors = malloc(sizeof(flash_sector_t) * num_sectors);
-	str7x_info-&gt;sector_bits = malloc(sizeof(u32) * num_sectors);
+	str7x_info-&gt;sector_bits = malloc(sizeof(uint32_t) * num_sectors);
 	
 	num_sectors = 0;
 	
@@ -191,20 +191,20 @@
 	return ERROR_OK;
 }
 
-static u32 str7x_status(struct flash_bank_s *bank)
+static uint32_t str7x_status(struct flash_bank_s *bank)
 {
 	target_t *target = bank-&gt;target;
-	u32 retval;
+	uint32_t retval;
 
 	target_read_u32(target, str7x_get_flash_adr(bank, FLASH_CR0), &amp;retval);
 
 	return retval;
 }
 
-static u32 str7x_result(struct flash_bank_s *bank)
+static uint32_t str7x_result(struct flash_bank_s *bank)
 {
 	target_t *target = bank-&gt;target;
-	u32 retval;
+	uint32_t retval;
 
 	target_read_u32(target, str7x_get_flash_adr(bank, FLASH_ER), &amp;retval);
 	
@@ -217,7 +217,7 @@
 	target_t *target = bank-&gt;target;
 	
 	int i;
-	u32 retval;
+	uint32_t retval;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -244,9 +244,9 @@
 	target_t *target = bank-&gt;target;
 	
 	int i;
-	u32 cmd;
-	u32 retval;
-	u32 sectors = 0;
+	uint32_t cmd;
+	uint32_t retval;
+	uint32_t sectors = 0;
 	
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -296,9 +296,9 @@
 	str7x_flash_bank_t *str7x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
 	int i;
-	u32 cmd;
-	u32 retval;
-	u32 protect_blocks;
+	uint32_t cmd;
+	uint32_t retval;
+	uint32_t protect_blocks;
 	
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
 	{
@@ -345,18 +345,18 @@
 	return ERROR_OK;
 }
 
-static int str7x_write_block(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int str7x_write_block(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	str7x_flash_bank_t *str7x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 buffer_size = 8192;
+	uint32_t buffer_size = 8192;
 	working_area_t *source;
-	u32 address = bank-&gt;base + offset;
+	uint32_t address = bank-&gt;base + offset;
 	reg_param_t reg_params[6];
 	armv4_5_algorithm_t armv4_5_info;
 	int retval = ERROR_OK;
 	
-	u32 str7x_flash_write_code[] = {
+	uint32_t str7x_flash_write_code[] = {
 					/* write:				*/
 		0xe3a04201, /*	mov r4, #0x10000000	*/
 		0xe5824000, /*	str r4, [r2, #0x0]	*/
@@ -419,7 +419,7 @@
 	
 	while (count &gt; 0)
 	{
-		u32 thisrun_count = (count &gt; (buffer_size / 8)) ? (buffer_size / 8) : count;
+		uint32_t thisrun_count = (count &gt; (buffer_size / 8)) ? (buffer_size / 8) : count;
 		
 		target_write_buffer(target, source-&gt;address, thisrun_count * 8, buffer);
 		
@@ -460,17 +460,17 @@
 	return retval;
 }
 
-static int str7x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int str7x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	target_t *target = bank-&gt;target;
 	str7x_flash_bank_t *str7x_info = bank-&gt;driver_priv;
-	u32 dwords_remaining = (count / 8);
-	u32 bytes_remaining = (count &amp; 0x00000007);
-	u32 address = bank-&gt;base + offset;
-	u32 bytes_written = 0;
-	u32 cmd;
+	uint32_t dwords_remaining = (count / 8);
+	uint32_t bytes_remaining = (count &amp; 0x00000007);
+	uint32_t address = bank-&gt;base + offset;
+	uint32_t bytes_written = 0;
+	uint32_t cmd;
 	int retval;
-	u32 check_address = offset;
+	uint32_t check_address = offset;
 	int i;
 	
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -487,8 +487,8 @@
 	
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
 	{
-		u32 sec_start = bank-&gt;sectors[i].offset;
-		u32 sec_end = sec_start + bank-&gt;sectors[i].size;
+		uint32_t sec_start = bank-&gt;sectors[i].offset;
+		uint32_t sec_end = sec_start + bank-&gt;sectors[i].size;
 		
 		/* check if destination falls within the current sector */
 		if ((check_address &gt;= sec_start) &amp;&amp; (check_address &lt; sec_end))
@@ -644,8 +644,8 @@
 	target_t *target = NULL;
 	str7x_flash_bank_t *str7x_info = NULL;
 	
-	u32 flash_cmd;
-	u32 retval;
+	uint32_t flash_cmd;
+	uint32_t retval;
 	uint16_t ProtectionLevel = 0;
 	uint16_t ProtectionRegs;
 	

Modified: trunk/src/flash/str7x.h
===================================================================
--- trunk/src/flash/str7x.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/str7x.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -27,10 +27,10 @@
 
 typedef struct str7x_flash_bank_s
 {
-	u32 *sector_bits;
-	u32 disable_bit;
-	u32 busy_bits;
-	u32 register_base;
+	uint32_t *sector_bits;
+	uint32_t disable_bit;
+	uint32_t busy_bits;
+	uint32_t register_base;
 	working_area_t *write_algorithm;
 } str7x_flash_bank_t;
 
@@ -102,9 +102,9 @@
 #define FLASH_ERR		0x00000001
 
 typedef struct str7x_mem_layout_s {
-	u32 sector_start;
-	u32 sector_size;
-	u32 sector_bit;
+	uint32_t sector_start;
+	uint32_t sector_size;
+	uint32_t sector_bit;
 } str7x_mem_layout_t;
 
 #endif /* STR7X_H */

Modified: trunk/src/flash/str9x.c
===================================================================
--- trunk/src/flash/str9x.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/str9x.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -31,13 +31,13 @@
 #include &quot;arm966e.h&quot;
 
 
-static u32 bank1start = 0x00080000;
+static uint32_t bank1start = 0x00080000;
 
 static int str9x_register_commands(struct command_context_s *cmd_ctx);
 static int str9x_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int str9x_erase(struct flash_bank_s *bank, int first, int last);
 static int str9x_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int str9x_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int str9x_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int str9x_probe(struct flash_bank_s *bank);
 //static int str9x_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int str9x_protect_check(struct flash_bank_s *bank);
@@ -77,7 +77,7 @@
 	int i;
 	int num_sectors;
 	int b0_sectors = 0, b1_sectors = 0;
-	u32 offset = 0;
+	uint32_t offset = 0;
 
 	/* set if we have large flash str9 */
 	str9x_info-&gt;variant = 0;
@@ -121,7 +121,7 @@
 
 	bank-&gt;num_sectors = num_sectors;
 	bank-&gt;sectors = malloc(sizeof(flash_sector_t) * num_sectors);
-	str9x_info-&gt;sector_bits = malloc(sizeof(u32) * num_sectors);
+	str9x_info-&gt;sector_bits = malloc(sizeof(uint32_t) * num_sectors);
 
 	num_sectors = 0;
 
@@ -181,8 +181,8 @@
 	target_t *target = bank-&gt;target;
 
 	int i;
-	u32 adr;
-	u32 status = 0;
+	uint32_t adr;
+	uint32_t status = 0;
 	uint16_t hstatus = 0;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -256,7 +256,7 @@
 {
 	target_t *target = bank-&gt;target;
 	int i;
-	u32 adr;
+	uint32_t adr;
 	uint8_t status;
 	uint8_t erase_cmd;
 
@@ -349,7 +349,7 @@
 {
 	target_t *target = bank-&gt;target;
 	int i;
-	u32 adr;
+	uint32_t adr;
 	uint8_t status;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -384,18 +384,18 @@
 }
 
 static int str9x_write_block(struct flash_bank_s *bank,
-		uint8_t *buffer, u32 offset, u32 count)
+		uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	str9x_flash_bank_t *str9x_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 buffer_size = 8192;
+	uint32_t buffer_size = 8192;
 	working_area_t *source;
-	u32 address = bank-&gt;base + offset;
+	uint32_t address = bank-&gt;base + offset;
 	reg_param_t reg_params[4];
 	armv4_5_algorithm_t armv4_5_info;
 	int retval = ERROR_OK;
 
-	u32 str9x_flash_write_code[] = {
+	uint32_t str9x_flash_write_code[] = {
 					/* write:				*/
 		0xe3c14003,	/*	bic	r4, r1, #3		*/
 		0xe3a03040,	/*	mov	r3, #0x40		*/
@@ -455,7 +455,7 @@
 
 	while (count &gt; 0)
 	{
-		u32 thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
+		uint32_t thisrun_count = (count &gt; (buffer_size / 2)) ? (buffer_size / 2) : count;
 
 		target_write_buffer(target, source-&gt;address, thisrun_count * 2, buffer);
 
@@ -493,17 +493,17 @@
 }
 
 static int str9x_write(struct flash_bank_s *bank,
-		uint8_t *buffer, u32 offset, u32 count)
+		uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	target_t *target = bank-&gt;target;
-	u32 words_remaining = (count / 2);
-	u32 bytes_remaining = (count &amp; 0x00000001);
-	u32 address = bank-&gt;base + offset;
-	u32 bytes_written = 0;
+	uint32_t words_remaining = (count / 2);
+	uint32_t bytes_remaining = (count &amp; 0x00000001);
+	uint32_t address = bank-&gt;base + offset;
+	uint32_t bytes_written = 0;
 	uint8_t status;
 	int retval;
-	u32 check_address = offset;
-	u32 bank_adr;
+	uint32_t check_address = offset;
+	uint32_t bank_adr;
 	int i;
 
 	if (bank-&gt;target-&gt;state != TARGET_HALTED)
@@ -520,8 +520,8 @@
 
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
 	{
-		u32 sec_start = bank-&gt;sectors[i].offset;
-		u32 sec_end = sec_start + bank-&gt;sectors[i].size;
+		uint32_t sec_start = bank-&gt;sectors[i].offset;
+		uint32_t sec_end = sec_start + bank-&gt;sectors[i].size;
 
 		/* check if destination falls within the current sector */
 		if ((check_address &gt;= sec_start) &amp;&amp; (check_address &lt; sec_end))

Modified: trunk/src/flash/str9x.h
===================================================================
--- trunk/src/flash/str9x.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/str9x.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -27,7 +27,7 @@
 
 typedef struct str9x_flash_bank_s
 {
-	u32 *sector_bits;
+	uint32_t *sector_bits;
 	int variant;
 	int bank1;
 	working_area_t *write_algorithm;

Modified: trunk/src/flash/str9xpec.c
===================================================================
--- trunk/src/flash/str9xpec.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/str9xpec.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -32,7 +32,7 @@
 static int str9xpec_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int str9xpec_erase(struct flash_bank_s *bank, int first, int last);
 static int str9xpec_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int str9xpec_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count);
+static int str9xpec_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count);
 static int str9xpec_probe(struct flash_bank_s *bank);
 static int str9xpec_handle_part_id_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int str9xpec_protect_check(struct flash_bank_s *bank);
@@ -99,7 +99,7 @@
 	return ERROR_OK;
 }
 
-int str9xpec_set_instr(jtag_tap_t *tap, u32 new_instr, tap_state_t end_state)
+int str9xpec_set_instr(jtag_tap_t *tap, uint32_t new_instr, tap_state_t end_state)
 {
 	if( tap == NULL ){
 		return ERROR_TARGET_INVALID;
@@ -240,7 +240,7 @@
 	int i;
 	int num_sectors;
 	int b0_sectors = 0, b1_sectors = 0;
-	u32 offset = 0;
+	uint32_t offset = 0;
 	int b1_size = 0x2000;
 
 	switch (bank-&gt;size)
@@ -273,7 +273,7 @@
 
 	bank-&gt;num_sectors = num_sectors;
 	bank-&gt;sectors = malloc(sizeof(flash_sector_t) * num_sectors);
-	str9xpec_info-&gt;sector_bits = malloc(sizeof(u32) * num_sectors);
+	str9xpec_info-&gt;sector_bits = malloc(sizeof(uint32_t) * num_sectors);
 
 	num_sectors = 0;
 
@@ -625,14 +625,14 @@
 	return ERROR_OK;
 }
 
-static int str9xpec_write(struct flash_bank_s *bank, uint8_t *buffer, u32 offset, u32 count)
+static int str9xpec_write(struct flash_bank_s *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
 {
 	str9xpec_flash_controller_t *str9xpec_info = bank-&gt;driver_priv;
-	u32 dwords_remaining = (count / 8);
-	u32 bytes_remaining = (count &amp; 0x00000007);
-	u32 bytes_written = 0;
+	uint32_t dwords_remaining = (count / 8);
+	uint32_t bytes_remaining = (count &amp; 0x00000007);
+	uint32_t bytes_written = 0;
 	uint8_t status;
-	u32 check_address = offset;
+	uint32_t check_address = offset;
 	jtag_tap_t *tap;
 	scan_field_t field;
 	uint8_t *scanbuf;
@@ -658,8 +658,8 @@
 
 	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
 	{
-		u32 sec_start = bank-&gt;sectors[i].offset;
-		u32 sec_end = sec_start + bank-&gt;sectors[i].size;
+		uint32_t sec_start = bank-&gt;sectors[i].offset;
+		uint32_t sec_end = sec_start + bank-&gt;sectors[i].size;
 
 		/* check if destination falls within the current sector */
 		if ((check_address &gt;= sec_start) &amp;&amp; (check_address &lt; sec_end))
@@ -799,7 +799,7 @@
 	scan_field_t field;
 	uint8_t *buffer = NULL;
 	jtag_tap_t *tap;
-	u32 idcode;
+	uint32_t idcode;
 	str9xpec_flash_controller_t *str9xpec_info = NULL;
 
 	if (argc &lt; 1)

Modified: trunk/src/flash/str9xpec.h
===================================================================
--- trunk/src/flash/str9xpec.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/str9xpec.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -29,7 +29,7 @@
 typedef struct str9xpec_flash_controller_s
 {
 	jtag_tap_t *tap;
-	u32 *sector_bits;
+	uint32_t *sector_bits;
 	int chain_pos;
 	int isc_enable;
 	uint8_t options[8];

Modified: trunk/src/flash/tms470.c
===================================================================
--- trunk/src/flash/tms470.c	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/tms470.c	2009-06-18 07:10:25 UTC (rev 2280)
@@ -28,7 +28,7 @@
 static int tms470_flash_bank_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, struct flash_bank_s *bank);
 static int tms470_erase(struct flash_bank_s *bank, int first, int last);
 static int tms470_protect(struct flash_bank_s *bank, int set, int first, int last);
-static int tms470_write(struct flash_bank_s *bank, uint8_t * buffer, u32 offset, u32 count);
+static int tms470_write(struct flash_bank_s *bank, uint8_t * buffer, uint32_t offset, uint32_t count);
 static int tms470_probe(struct flash_bank_s *bank);
 static int tms470_auto_probe(struct flash_bank_s *bank);
 static int tms470_erase_check(struct flash_bank_s *bank);
@@ -135,11 +135,11 @@
 {
 	tms470_flash_bank_t *tms470_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 device_ident_reg;
-	u32 silicon_version;
-	u32 technology_family;
-	u32 rom_flash;
-	u32 part_number;
+	uint32_t device_ident_reg;
+	uint32_t silicon_version;
+	uint32_t technology_family;
+	uint32_t rom_flash;
+	uint32_t part_number;
 	char *part_name;
 
 	/* we shall not rely on the caller in this test, this function allocates memory,
@@ -307,8 +307,8 @@
 
 /* ---------------------------------------------------------------------- */
 
-static u32 keysSet = 0;
-static u32 flashKeys[4];
+static uint32_t keysSet = 0;
+static uint32_t flashKeys[4];
 
 static int tms470_handle_flash_keyset_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
@@ -353,19 +353,19 @@
 	return ERROR_OK;
 }
 
-static const u32 FLASH_KEYS_ALL_ONES[] = { 0xFFFFFFFF, 0xFFFFFFFF,
+static const uint32_t FLASH_KEYS_ALL_ONES[] = { 0xFFFFFFFF, 0xFFFFFFFF,
 	0xFFFFFFFF, 0xFFFFFFFF,
 };
 
-static const u32 FLASH_KEYS_ALL_ZEROS[] = { 0x00000000, 0x00000000,
+static const uint32_t FLASH_KEYS_ALL_ZEROS[] = { 0x00000000, 0x00000000,
 	0x00000000, 0x00000000,
 };
 
-static const u32 FLASH_KEYS_MIX1[] = { 0xf0fff0ff, 0xf0fff0ff,
+static const uint32_t FLASH_KEYS_MIX1[] = { 0xf0fff0ff, 0xf0fff0ff,
 	0xf0fff0ff, 0xf0fff0ff
 };
 
-static const u32 FLASH_KEYS_MIX2[] = { 0x0000ffff, 0x0000ffff,
+static const uint32_t FLASH_KEYS_MIX2[] = { 0x0000ffff, 0x0000ffff,
 	0x0000ffff, 0x0000ffff
 };
 
@@ -424,7 +424,7 @@
 
 static int tms470_check_flash_unlocked(target_t * target)
 {
-	u32 fmbbusy;
+	uint32_t fmbbusy;
 
 	target_read_u32(target, 0xFFE89C08, &amp;fmbbusy);
 	LOG_INFO(&quot;tms470 fmbbusy=0x%08x -&gt; %s&quot;, fmbbusy, fmbbusy &amp; 0x8000 ? &quot;unlocked&quot; : &quot;LOCKED&quot;);
@@ -433,9 +433,9 @@
 
 /* ---------------------------------------------------------------------- */
 
-static int tms470_try_flash_keys(target_t * target, const u32 * key_set)
+static int tms470_try_flash_keys(target_t * target, const uint32_t * key_set)
 {
-	u32 glbctrl, fmmstat;
+	uint32_t glbctrl, fmmstat;
 	int retval = ERROR_FLASH_OPERATION_FAILED;
 
 	/* set GLBCTRL.4  */
@@ -447,7 +447,7 @@
 	if (!(fmmstat &amp; 0x08))
 	{
 		unsigned i;
-		u32 fmbptr, fmbac2, orig_fmregopt;
+		uint32_t fmbptr, fmbac2, orig_fmregopt;
 
 		target_write_u32(target, 0xFFE8BC04, fmmstat &amp; ~0x07);
 
@@ -469,7 +469,7 @@
 
 		for (i = 0; i &lt; 4; i++)
 		{
-			u32 tmp;
+			uint32_t tmp;
 
 			/* There is no point displaying the value of tmp, it is
 			 * filtered by the chip.  The purpose of this read is to
@@ -490,7 +490,7 @@
 			 */
 			for (i = 0; i &lt; 4; i++)
 			{
-				u32 tmp;
+				uint32_t tmp;
 
 				target_read_u32(target, 0x00001FF0 + 4 * i, &amp;tmp);
 				target_write_u32(target, 0xFFE89C0C, key_set[i]);
@@ -514,7 +514,7 @@
 static int tms470_unlock_flash(struct flash_bank_s *bank)
 {
 	target_t *target = bank-&gt;target;
-	const u32 *p_key_sets[5];
+	const uint32_t *p_key_sets[5];
 	unsigned i, key_set_count;
 
 	if (keysSet)
@@ -552,7 +552,7 @@
 
 static int tms470_flash_initialize_internal_state_machine(struct flash_bank_s *bank)
 {
-	u32 fmmac2, fmmac1, fmmaxep, k, delay, glbctrl, sysclk;
+	uint32_t fmmac2, fmmac1, fmmaxep, k, delay, glbctrl, sysclk;
 	target_t *target = bank-&gt;target;
 	tms470_flash_bank_t *tms470_info = bank-&gt;driver_priv;
 	int result = ERROR_OK;
@@ -690,7 +690,7 @@
 {
 	target_t *target = bank-&gt;target;
 	int result = ERROR_OK;
-	u32 fmmstat;
+	uint32_t fmmstat;
 
 	target_read_u32(target, 0xFFE8BC0C, &amp;fmmstat);
 	LOG_DEBUG(&quot;set fmmstat=0x%04x&quot;, fmmstat);
@@ -744,9 +744,9 @@
 
 static int tms470_erase_sector(struct flash_bank_s *bank, int sector)
 {
-	u32 glbctrl, orig_fmregopt, fmbsea, fmbseb, fmmstat;
+	uint32_t glbctrl, orig_fmregopt, fmbsea, fmbseb, fmmstat;
 	target_t *target = bank-&gt;target;
-	u32 flashAddr = bank-&gt;base + bank-&gt;sectors[sector].offset;
+	uint32_t flashAddr = bank-&gt;base + bank-&gt;sectors[sector].offset;
 	int result = ERROR_OK;
 
 	/* 
@@ -901,7 +901,7 @@
 {
 	tms470_flash_bank_t *tms470_info = bank-&gt;driver_priv;
 	target_t *target = bank-&gt;target;
-	u32 fmmac2, fmbsea, fmbseb;
+	uint32_t fmmac2, fmbsea, fmbseb;
 	int sector;
 
 	if (target-&gt;state != TARGET_HALTED)
@@ -949,12 +949,12 @@
 
 /* ---------------------------------------------------------------------- */
 
-static int tms470_write(struct flash_bank_s *bank, uint8_t * buffer, u32 offset, u32 count)
+static int tms470_write(struct flash_bank_s *bank, uint8_t * buffer, uint32_t offset, uint32_t count)
 {
 	target_t *target = bank-&gt;target;
-	u32 glbctrl, fmbac2, orig_fmregopt, fmbsea, fmbseb, fmmaxpp, fmmstat;
+	uint32_t glbctrl, fmbac2, orig_fmregopt, fmbsea, fmbseb, fmmaxpp, fmmstat;
 	int result = ERROR_OK;
-	u32 i;
+	uint32_t i;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -993,7 +993,7 @@
 
 	for (i = 0; i &lt; count; i += 2)
 	{
-		u32 addr = bank-&gt;base + offset + i;
+		uint32_t addr = bank-&gt;base + offset + i;
 		uint16_t word = (((uint16_t) buffer[i]) &lt;&lt; 8) | (uint16_t) buffer[i + 1];
 
 		if (word != 0xffff)
@@ -1074,7 +1074,7 @@
 	target_t *target = bank-&gt;target;
 	tms470_flash_bank_t *tms470_info = bank-&gt;driver_priv;
 	int sector, result = ERROR_OK;
-	u32 fmmac2, fmbac2, glbctrl, orig_fmregopt;
+	uint32_t fmmac2, fmbac2, glbctrl, orig_fmregopt;
 	static uint8_t buffer[64 * 1024];
 
 	if (target-&gt;state != TARGET_HALTED)
@@ -1119,7 +1119,7 @@
 	{
 		if (bank-&gt;sectors[sector].is_erased != 1)
 		{
-			u32 i, addr = bank-&gt;base + bank-&gt;sectors[sector].offset;
+			uint32_t i, addr = bank-&gt;base + bank-&gt;sectors[sector].offset;
 
 			LOG_INFO(&quot;checking flash bank %d sector %d&quot;, tms470_info-&gt;ordinal, sector);
 
@@ -1165,7 +1165,7 @@
 	target_t *target = bank-&gt;target;
 	tms470_flash_bank_t *tms470_info = bank-&gt;driver_priv;
 	int sector, result = ERROR_OK;
-	u32 fmmac2, fmbsea, fmbseb;
+	uint32_t fmmac2, fmbsea, fmbseb;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{

Modified: trunk/src/flash/tms470.h
===================================================================
--- trunk/src/flash/tms470.h	2009-06-18 07:09:35 UTC (rev 2279)
+++ trunk/src/flash/tms470.h	2009-06-18 07:10:25 UTC (rev 2280)
@@ -27,11 +27,11 @@
 	unsigned ordinal;
 
 	/* device identification register */
-	u32 device_ident_reg;
-	u32 silicon_version;
-	u32 technology_family;
-	u32 rom_flash;
-	u32 part_number;
+	uint32_t device_ident_reg;
+	uint32_t silicon_version;
+	uint32_t technology_family;
+	uint32_t rom_flash;
+	uint32_t part_number;
 	char * part_name;
 
 } tms470_flash_bank_t;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001063.html">[Openocd-svn] r2279 - trunk/src/target
</A></li>
	<LI>Next message: <A HREF="001065.html">[Openocd-svn] r2281 - in trunk/src: helper jtag jtag/minidummy	jtag/rlink jtag/zy1000 pld server svf xsvf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1064">[ date ]</a>
              <a href="thread.html#1064">[ thread ]</a>
              <a href="subject.html#1064">[ subject ]</a>
              <a href="author.html#1064">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
