<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2036 - trunk/src/jtag
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2036%20-%20trunk/src/jtag&In-Reply-To=%3C200906040056.n540unGL032668%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000819.html">
   <LINK REL="Next"  HREF="000821.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2036 - trunk/src/jtag</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2036%20-%20trunk/src/jtag&In-Reply-To=%3C200906040056.n540unGL032668%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2036 - trunk/src/jtag">zwelch at mail.berlios.de
       </A><BR>
    <I>Thu Jun  4 02:56:49 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000819.html">[Openocd-svn] r2035 - trunk/doc
</A></li>
        <LI>Next message: <A HREF="000821.html">[Openocd-svn] r2037 - trunk/src/jtag
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#820">[ date ]</a>
              <a href="thread.html#820">[ thread ]</a>
              <a href="subject.html#820">[ subject ]</a>
              <a href="author.html#820">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-04 02:56:41 +0200 (Thu, 04 Jun 2009)
New Revision: 2036

Modified:
   trunk/src/jtag/arm-jtag-ew.c
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/ep93xx.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/jtag.c
   trunk/src/jtag/parport.c
   trunk/src/jtag/presto.c
   trunk/src/jtag/vsllink.c
Log:
David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">david-b at pacbell.net</A>&gt;:

Remove pernicious whitespace from src/jtag/*c files; mostly
the end-of-line flavor for now, although there's more.


Modified: trunk/src/jtag/arm-jtag-ew.c
===================================================================
--- trunk/src/jtag/arm-jtag-ew.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/arm-jtag-ew.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -1,4 +1,4 @@
-// vim:ts=4 sw=4: 
+// vim:ts=4 sw=4:
 
 /***************************************************************************
  *   Copyright (C) 2009 by Dimitar Dimitrov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dinuxbg at gmail.com</A>&gt;            *
@@ -222,14 +222,14 @@
 	usb_out_buffer[0] = CMD_GET_TCK_FREQUENCY;
     result = armjtagew_usb_message(armjtagew_jtag_handle, 1, 4);
 	speed_real = (int)buf_get_u32(usb_in_buffer,0,32);
-	if(result &lt; 0) 
+	if(result &lt; 0)
 	{
         LOG_ERROR(&quot;ARM-JTAG-EW getting speed failed (%d)&quot;, result);
         return ERROR_JTAG_DEVICE_ERROR;
-	} 
+	}
 	else
 	{
-    	LOG_INFO(&quot;Requested speed %dkHz, emulator reported %dkHz.&quot;, speed, speed_real);
+	LOG_INFO(&quot;Requested speed %dkHz, emulator reported %dkHz.&quot;, speed, speed_real);
 	}
 
     return ERROR_OK;
@@ -334,7 +334,7 @@
 	for (i = 0; i &lt; num_states; i++)
 	{
 		/*
-		 * TODO: The ARM-JTAG-EW hardware delays TDI with 3 TCK cycles when in RTCK mode. 
+		 * TODO: The ARM-JTAG-EW hardware delays TDI with 3 TCK cycles when in RTCK mode.
 		 * Either handle that here, or update the documentation with examples
 		 * how to fix that in the configuration files.
 		 */
@@ -504,7 +504,7 @@
 	usb_out_buffer[0] = CMD_GET_VERSION;
 	result = armjtagew_usb_message(armjtagew_jtag_handle, 1, 4+15+256);
 
-	if (result != 0) 
+	if (result != 0)
 	{
 		LOG_ERROR(&quot;ARM-JTAG-EW command CMD_GET_VERSION failed (%d)\n&quot;, result);
 		return ERROR_JTAG_DEVICE_ERROR;
@@ -791,7 +791,7 @@
 	if (result == out_length)
 	{
 		result = armjtagew_usb_read(armjtagew_jtag, in_length);
-		if (result != in_length) 
+		if (result != in_length)
 		{
 			LOG_ERROR(&quot;usb_bulk_read failed (requested=%d, result=%d)&quot;, in_length, result);
 			return -1;

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/bitbang.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -79,7 +79,7 @@
 	int i=0, tms=0;
 	u8 tms_scan = tap_get_tms_path(tap_get_state(), tap_get_end_state());
 	int tms_count = tap_get_tms_path_len(tap_get_state(), tap_get_end_state());
-	
+
 	for (i = skip; i &lt; tms_count; i++)
 	{
 		tms = (tms_scan &gt;&gt; i) &amp; 1;

Modified: trunk/src/jtag/ep93xx.c
===================================================================
--- trunk/src/jtag/ep93xx.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/ep93xx.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -53,13 +53,13 @@
 
 struct timespec ep93xx_zzzz;
 
-jtag_interface_t ep93xx_interface = 
+jtag_interface_t ep93xx_interface =
 {
 	.name = &quot;ep93xx&quot;,
 
 	.execute_queue = bitbang_execute_queue,
 
-	.speed = ep93xx_speed,	
+	.speed = ep93xx_speed,
 	.register_commands = ep93xx_register_commands,
 	.init = ep93xx_init,
 	.quit = ep93xx_quit,
@@ -84,12 +84,12 @@
 		output_value |= TCK_BIT;
 	else
 		output_value &amp;= ~TCK_BIT;
-	
+
 	if (tms)
 		output_value |= TMS_BIT;
 	else
 		output_value &amp;= ~TMS_BIT;
-	
+
 	if (tdi)
 		output_value |= TDI_BIT;
 	else
@@ -111,7 +111,7 @@
 		output_value |= SRST_BIT;
 	else if (srst == 1)
 		output_value &amp;= ~SRST_BIT;
-	
+
 	*gpio_data_register = output_value;
 	nanosleep(&amp;ep93xx_zzzz, NULL);
 }
@@ -153,7 +153,7 @@
 {
 	int ret;
 
-	bitbang_interface = &amp;ep93xx_bitbang;	
+	bitbang_interface = &amp;ep93xx_bitbang;
 
 	ep93xx_zzzz.tv_sec = 0;
 	ep93xx_zzzz.tv_nsec = 10000000;
@@ -203,7 +203,7 @@
 	gpio_data_direction_register = gpio_controller + 0x18;
 
 	LOG_INFO(&quot;gpio_data_register      = %p\n&quot;, gpio_data_register);
-	LOG_INFO(&quot;gpio_data_direction_reg = %p\n&quot;, gpio_data_direction_register); 
+	LOG_INFO(&quot;gpio_data_direction_reg = %p\n&quot;, gpio_data_direction_register);
 	/*
 	 * Configure bit 0 (TDO) as an input, and bits 1-5 (TDI, TCK
 	 * TMS, TRST, SRST) as outputs.  Drive TDI and TCK low, and

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/jlink.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -59,24 +59,24 @@
 static u8 usb_emu_result_buffer[JLINK_EMU_RESULT_BUFFER_SIZE];
 
 /* Constants for JLink command */
-#define EMU_CMD_VERSION     		0x01
-#define EMU_CMD_SET_SPEED   		0x05
-#define EMU_CMD_GET_STATE   		0x07
+#define EMU_CMD_VERSION		0x01
+#define EMU_CMD_SET_SPEED		0x05
+#define EMU_CMD_GET_STATE		0x07
 #define EMU_CMD_HW_CLOCK			0xc8
-#define EMU_CMD_HW_TMS0 			0xc9
-#define EMU_CMD_HW_TMS1 			0xca
-#define EMU_CMD_HW_JTAG2    		0xce
-#define EMU_CMD_HW_JTAG3    		0xcf
+#define EMU_CMD_HW_TMS0			0xc9
+#define EMU_CMD_HW_TMS1			0xca
+#define EMU_CMD_HW_JTAG2		0xce
+#define EMU_CMD_HW_JTAG3		0xcf
 #define EMU_CMD_GET_MAX_MEM_BLOCK	0xd4
-#define EMU_CMD_HW_RESET0   		0xdc
-#define EMU_CMD_HW_RESET1   		0xdd
-#define EMU_CMD_HW_TRST0    		0xde
-#define EMU_CMD_HW_TRST1    		0xdf
-#define EMU_CMD_GET_CAPS    		0xe8
-#define EMU_CMD_GET_HW_VERSION  	0xf0
+#define EMU_CMD_HW_RESET0		0xdc
+#define EMU_CMD_HW_RESET1		0xdd
+#define EMU_CMD_HW_TRST0		0xde
+#define EMU_CMD_HW_TRST1		0xdf
+#define EMU_CMD_GET_CAPS		0xe8
+#define EMU_CMD_GET_HW_VERSION	0xf0
 
 /* bits return from EMU_CMD_GET_CAPS */
-#define EMU_CAP_GET_HW_VERSION 		1
+#define EMU_CAP_GET_HW_VERSION		1
 #define EMU_CAP_GET_MAX_BLOCK_SIZE	11
 
 /* max speed 12MHz v5.0 jlink */
@@ -294,7 +294,7 @@
 static int jlink_register_commands(struct command_context_s *cmd_ctx)
 {
 
-	register_command(cmd_ctx, NULL, &quot;jlink_info&quot;, 
+	register_command(cmd_ctx, NULL, &quot;jlink_info&quot;,
 		&amp;jlink_handle_jlink_info_command, COMMAND_EXEC,
 		&quot;query jlink info&quot;);
 	register_command(cmd_ctx, NULL, &quot;jlink_hw_jtag&quot;,
@@ -307,7 +307,7 @@
 {
 	int check_cnt;
 	int i;
-	
+
 	jlink_jtag_handle = jlink_usb_open();
 
 	if (jlink_jtag_handle == 0)
@@ -343,12 +343,12 @@
 	jlink_speed(jtag_speed);
 
 	/* v5/6 jlink seems to have an issue if the first tap move
-	 * is not divisible by 8, so we send a TLR on first power up */ 
+	 * is not divisible by 8, so we send a TLR on first power up */
 	for (i = 0; i &lt; 8; i++) {
 		jlink_tap_append_step(1, 0);
 	}
 	jlink_tap_execute();
-	
+
 	return ERROR_OK;
 }
 
@@ -567,7 +567,7 @@
 		LOG_ERROR(&quot;J-Link command EMU_CMD_VERSION impossible return length 0x%0x&quot;, len);
 		len = JLINK_IN_BUFFER_SIZE;
 	}
-	
+
 	result = jlink_usb_read(jlink_jtag_handle, len);
 	if (result != len)
 	{

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/jtag.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -2658,7 +2658,7 @@
 		jtag_add_pathmove(tms_count, moves);
 	}
 
-	/* 	else state must be immediately reachable in one clock cycle, and does not
+	/*	else state must be immediately reachable in one clock cycle, and does not
 		need to be a stable state.
 	*/
 	else if( tap_state_transition(cur_state, true)  == goal_state

Modified: trunk/src/jtag/parport.c
===================================================================
--- trunk/src/jtag/parport.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/parport.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -75,8 +75,8 @@
 	u8 LED_MASK;	/* data port bit for LED */
 } cable_t;
 
-static cable_t cables[] = 
-{	
+static cable_t cables[] =
+{
 	/* name					tdo   trst  tms   tck   tdi   srst  o_inv i_inv init  exit  led */
 	{ &quot;wiggler&quot;,			0x80, 0x10, 0x02, 0x04, 0x08, 0x01, 0x01, 0x80, 0x80, 0x80, 0x00 },
 	{ &quot;wiggler2&quot;,			0x80, 0x10, 0x02, 0x04, 0x08, 0x01, 0x01, 0x80, 0x80, 0x00, 0x20 },
@@ -135,13 +135,13 @@
 static int parport_handle_parport_cable_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 static int parport_handle_write_on_exit_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-jtag_interface_t parport_interface = 
+jtag_interface_t parport_interface =
 {
 	.name = &quot;parport&quot;,
-	
+
 	.execute_queue = bitbang_execute_queue,
 
-	.speed = parport_speed,	
+	.speed = parport_speed,
 	.register_commands = parport_register_commands,
 	.init = parport_init,
 	.quit = parport_quit,
@@ -158,7 +158,7 @@
 static int parport_read(void)
 {
 	int data = 0;
-	
+
 #if PARPORT_USE_PPDEV == 1
 	ioctl(device_handle, PPRSTATUS, &amp; data);
 #else
@@ -190,22 +190,22 @@
 static void parport_write(int tck, int tms, int tdi)
 {
 	int i = jtag_speed + 1;
-	
+
 	if (tck)
 		dataport_value |= cable-&gt;TCK_MASK;
 	else
 		dataport_value &amp;= ~cable-&gt;TCK_MASK;
-	
+
 	if (tms)
 		dataport_value |= cable-&gt;TMS_MASK;
 	else
 		dataport_value &amp;= ~cable-&gt;TMS_MASK;
-	
+
 	if (tdi)
 		dataport_value |= cable-&gt;TDI_MASK;
 	else
 		dataport_value &amp;= ~cable-&gt;TDI_MASK;
-		
+
 	while (i-- &gt; 0)
 		parport_write_data();
 }
@@ -224,10 +224,10 @@
 		dataport_value |= cable-&gt;SRST_MASK;
 	else if (srst == 1)
 		dataport_value &amp;= ~cable-&gt;SRST_MASK;
-	
+
 	parport_write_data();
 }
-	
+
 /* turn LED on parport adapter on (1) or off (0) */
 static void parport_led(int on)
 {
@@ -261,7 +261,7 @@
 {
 	HANDLE h;
 	OSVERSIONINFO version;
-	
+
 	version.dwOSVersionInfoSize = sizeof version;
 	if (!GetVersionEx( &amp;version )) {
 		errno = EINVAL;
@@ -269,15 +269,15 @@
 	}
 	if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
 		return 0;
-	
+
 	h = CreateFile( &quot;\\\\.\\giveio&quot;, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
 	if (h == INVALID_HANDLE_VALUE) {
 		errno = ENODEV;
 		return -1;
 	}
-	
+
 	CloseHandle( h );
-	
+
 	return 0;
 }
 #endif
@@ -289,15 +289,15 @@
 	char buffer[256];
 	int i = 0;
 #endif
-	
+
 	cur_cable = cables;
-	
+
 	if ((parport_cable == NULL) || (parport_cable[0] == 0))
 	{
 		parport_cable = &quot;wiggler&quot;;
 		LOG_WARNING(&quot;No parport cable specified, using default 'wiggler'&quot;);
 	}
-	
+
 	while (cur_cable-&gt;name)
 	{
 		if (strcmp(cur_cable-&gt;name, parport_cable) == 0)
@@ -313,9 +313,9 @@
 		LOG_ERROR(&quot;No matching cable found for %s&quot;, parport_cable);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	dataport_value = cable-&gt;PORT_INIT;
-	
+
 #if PARPORT_USE_PPDEV == 1
 	if (device_handle &gt; 0)
 	{
@@ -374,10 +374,10 @@
 		parport_port = 0x378;
 		LOG_WARNING(&quot;No parport port specified, using default '0x378' (LPT1)&quot;);
 	}
-	
+
 	dataport = parport_port;
 	statusport = parport_port + 1;
-	
+
 	LOG_DEBUG(&quot;requesting privileges for parallel port 0x%lx...&quot;, dataport);
 #if PARPORT_USE_GIVEIO == 1
 	if (parport_get_giveio_access() != 0)
@@ -389,21 +389,21 @@
 		return ERROR_JTAG_INIT_FAILED;
 	}
 	LOG_DEBUG(&quot;...privileges granted&quot;);
-	
+
 	/* make sure parallel port is in right mode (clear tristate and interrupt */
 	#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
 		outb(parport_port + 2, 0x0);
 	#else
 		outb(0x0, parport_port + 2);
 	#endif
-	
+
 #endif /* PARPORT_USE_PPDEV */
-	
+
 	parport_reset(0, 0);
 	parport_write(0, 0, 0);
 	parport_led(1);
 
-	bitbang_interface = &amp;parport_bitbang;	
+	bitbang_interface = &amp;parport_bitbang;
 
 	return ERROR_OK;
 }
@@ -417,13 +417,13 @@
 		dataport_value = cable-&gt;PORT_EXIT;
 		parport_write_data();
 	}
-	
+
 	if (parport_cable)
 	{
 		free(parport_cable);
 		parport_cable = NULL;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -461,11 +461,11 @@
 		command_print(cmd_ctx, &quot;usage: parport_write_on_exit &lt;on|off&gt;&quot;);
 		return ERROR_OK;
 	}
-	
+
 	if (strcmp(args[0], &quot;on&quot;) == 0)
 		parport_exit = 1;
 	else if (strcmp(args[0], &quot;off&quot;) == 0)
 		parport_exit = 0;
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/jtag/presto.c
===================================================================
--- trunk/src/jtag/presto.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/presto.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -117,7 +117,7 @@
 	int jtag_tdi_count;
 
 	int jtag_speed;
-	
+
 } presto_t;
 
 static presto_t presto_state;
@@ -420,7 +420,7 @@
 	presto-&gt;jtag_tdi_count=0;
 
 	presto-&gt;jtag_speed=0;
-	
+
 #if BUILD_PRESTO_FTD2XX == 1
 	return presto_open_ftd2xx(req_serial);
 #elif BUILD_PRESTO_LIBFTDI == 1
@@ -575,7 +575,7 @@
 	presto_sendbyte(presto-&gt;jtag_tdi_data);
 	presto-&gt;jtag_tdi_count = 0;
 	presto-&gt;jtag_tdi_data = 0;
-	
+
 	return 0;
 }
 
@@ -586,7 +586,7 @@
 		presto_sendbyte(0xCA);
 		presto-&gt;jtag_tck = 0;
 	}
-	
+
 	return 0;
 }
 
@@ -711,7 +711,7 @@
 
 	if (khz &gt;= 3000) *jtag_speed = 0;
 	else *jtag_speed = (1000+khz-1)/khz;
-	
+
 	return 0;
 }
 
@@ -725,26 +725,26 @@
 
 	if (speed == 0) *khz = 3000;
 	else *khz = 1000/speed;
-	
+
 	return 0;
 }
 
 static int presto_jtag_speed(int speed)
 {
 	int khz;
-	
+
 	if (presto_jtag_speed_div(speed, &amp;khz))
 	{
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
 	presto-&gt;jtag_speed = speed;
-	
+
 	if (khz%1000 == 0)
 		LOG_INFO(&quot;setting speed to %d, max. TCK freq. is %d MHz&quot;, speed, khz/1000);
 	else
 		LOG_INFO(&quot;setting speed to %d, max. TCK freq. is %d kHz&quot;, speed, khz);
-	
+
 	return 0;
 }
 

Modified: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2009-06-04 00:54:25 UTC (rev 2035)
+++ trunk/src/jtag/vsllink.c	2009-06-04 00:56:41 UTC (rev 2036)
@@ -91,7 +91,7 @@
  * 3: Pause-DR
  * 4: Shift-IR
  * 5: Pause-IR
- * 
+ *
  * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
  */
 static u8 VSLLINK_tap_move[6][6] =
@@ -300,29 +300,29 @@
 			case JTAG_RUNTEST:
 				DEBUG_JTAG_IO( &quot;runtest %i cycles, end in %s&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, \
 					tap_state_name(cmd-&gt;cmd.runtest-&gt;end_state));
-					
+
 				vsllink_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
 				vsllink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
 				break;
-				
+
 			case JTAG_STATEMOVE:
 				DEBUG_JTAG_IO(&quot;statemove end in %s&quot;, tap_state_name(cmd-&gt;cmd.statemove-&gt;end_state));
-				
+
 				vsllink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
 				vsllink_state_move();
 				break;
-				
+
 			case JTAG_PATHMOVE:
 				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %s&quot;, \
 					cmd-&gt;cmd.pathmove-&gt;num_states, \
 					tap_state_name(cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]));
-					
+
 				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path);
 				break;
-				
+
 			case JTAG_SCAN:
 				vsllink_end_state(cmd-&gt;cmd.scan-&gt;end_state);
-				
+
 				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
 				if (cmd-&gt;cmd.scan-&gt;ir_scan)
 				{
@@ -332,34 +332,34 @@
 				{
 					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %s:&quot;, scan_size, tap_state_name(cmd-&gt;cmd.scan-&gt;end_state));
 				}
-				
+
 #ifdef _DEBUG_JTAG_IO_
 				vsllink_debug_buffer(buffer, (scan_size + 7) &gt;&gt; 3);
 #endif
-				
+
 				type = jtag_scan_type(cmd-&gt;cmd.scan);
-				
+
 				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size, cmd-&gt;cmd.scan);
 				break;
-				
+
 			case JTAG_RESET:
 				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
-				
+
 				vsllink_tap_execute();
-				
+
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
 					tap_set_state(TAP_RESET);
 				}
 				vsllink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
-				
+
 			case JTAG_SLEEP:
 				DEBUG_JTAG_IO(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
 				vsllink_tap_execute();
 				jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
 				break;
-				
+
 			case JTAG_STABLECLOCKS:
 				DEBUG_JTAG_IO(&quot;add %d clocks&quot;, cmd-&gt;cmd.stableclocks-&gt;num_cycles);
 				switch(tap_get_state())
@@ -383,27 +383,27 @@
 				}
 				vsllink_stableclocks(cmd-&gt;cmd.stableclocks-&gt;num_cycles, scan_size);
 				break;
-				
+
 			default:
 				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered: %d&quot;, cmd-&gt;type);
 				exit(-1);
 		}
 		cmd = cmd-&gt;next;
 	}
-	
+
 	return vsllink_tap_execute();
 }
 
 static int vsllink_speed(int speed)
 {
 	int result;
-	
+
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_SPEED;
 	vsllink_usb_out_buffer[1] = (speed &gt;&gt; 0) &amp; 0xff;
 	vsllink_usb_out_buffer[2] = (speed &gt;&gt; 8) &amp; 0xFF;
-	
+
 	result = vsllink_usb_write(vsllink_jtag_handle, 3);
-	
+
 	if (result == 3)
 	{
 		return ERROR_OK;
@@ -413,21 +413,21 @@
 		LOG_ERROR(&quot;VSLLink setting speed failed (%d)&quot;, result);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
-	
+
 	return ERROR_OK;
 }
 
 static int vsllink_khz(int khz, int *jtag_speed)
 {
 	*jtag_speed = khz;
-	
+
 	return ERROR_OK;
 }
 
 static int vsllink_speed_div(int jtag_speed, int *khz)
 {
 	*khz = jtag_speed;
-	
+
 	return ERROR_OK;
 }
 
@@ -436,7 +436,7 @@
 	int check_cnt, to_tmp;
 	int result;
 	char version_str[100];
-	
+
 	vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
 	vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
 	if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
@@ -444,16 +444,16 @@
 		LOG_ERROR(&quot;Not enough memory&quot;);
 		exit(-1);
 	}
-	
+
 	vsllink_jtag_handle = vsllink_usb_open();
-	
+
 	if (vsllink_jtag_handle == 0)
 	{
 		LOG_ERROR(&quot;Can't find USB JTAG Interface! Please check connection and permissions.&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 	LOG_DEBUG(&quot;vsllink found on %04X:%04X&quot;, vsllink_usb_vid, vsllink_usb_pid);
-	
+
 	to_tmp = VSLLINK_USB_TIMEOUT;
 	VSLLINK_USB_TIMEOUT = 100;
 	check_cnt = 0;
@@ -461,20 +461,20 @@
 	{
 		vsllink_simple_command(0x00);
 		result = vsllink_usb_read(vsllink_jtag_handle);
-		
+
 		if (result &gt; 2)
 		{
 			vsllink_usb_in_buffer[result] = 0;
 			VSLLINK_BufferSize = vsllink_usb_in_buffer[0] + (vsllink_usb_in_buffer[1] &lt;&lt; 8);
 			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, sizeof(version_str));
 			LOG_INFO(&quot;%s&quot;, version_str);
-			
+
 			// free the pre-alloc memroy
 			free(vsllink_usb_in_buffer);
 			free(vsllink_usb_out_buffer);
 			vsllink_usb_in_buffer = NULL;
 			vsllink_usb_out_buffer = NULL;
-			
+
 			// alloc new memory
 			vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
 			vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
@@ -512,7 +512,7 @@
 		exit(-1);
 	}
 	VSLLINK_USB_TIMEOUT = to_tmp;
-	
+
 	// connect to vsllink
 	vsllink_connect();
 	// initialize function pointers
@@ -523,11 +523,11 @@
 		vsllink_path_move = vsllink_path_move_normal;
 		vsllink_stableclocks = vsllink_stableclocks_normal;
 		vsllink_scan = vsllink_scan_normal;
-		
+
 		vsllink_tap_init = vsllink_tap_init_normal;
 		vsllink_tap_execute = vsllink_tap_execute_normal;
 		vsllink_tap_ensure_space = vsllink_tap_ensure_space_normal;
-		
+
 		LOG_INFO(&quot;vsllink run in NORMAL mode&quot;);
 	}
 	else
@@ -537,14 +537,14 @@
 		vsllink_path_move = vsllink_path_move_dma;
 		vsllink_stableclocks = vsllink_stableclocks_dma;
 		vsllink_scan = vsllink_scan_dma;
-		
+
 		vsllink_tap_init = vsllink_tap_init_dma;
 		vsllink_tap_execute = vsllink_tap_execute_dma;
 		vsllink_tap_ensure_space = vsllink_tap_ensure_space_dma;
-		
+
 		LOG_INFO(&quot;vsllink run in DMA mode&quot;);
 	}
-	
+
 	// Set SRST and TRST to output, Set USR1 and USR2 to input
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
@@ -554,13 +554,13 @@
 		LOG_ERROR(&quot;VSLLink USB send data error&quot;);
 		exit(-1);
 	}
-	
+
 	vsllink_reset(0, 0);
-	
+
 	LOG_INFO(&quot;VSLLink JTAG Interface ready&quot;);
-	
+
 	vsllink_tap_init();
-	
+
 	return ERROR_OK;
 }
 
@@ -577,13 +577,13 @@
 			LOG_ERROR(&quot;VSLLink USB send data error&quot;);
 			exit(-1);
 		}
-		
+
 		// disconnect
 		vsllink_disconnect();
 		vsllink_usb_close(vsllink_jtag_handle);
 		vsllink_jtag_handle = NULL;
 	}
-	
+
 	if (vsllink_usb_in_buffer != NULL)
 	{
 		free(vsllink_usb_in_buffer);
@@ -594,7 +594,7 @@
 		free(vsllink_usb_out_buffer);
 		vsllink_usb_out_buffer = NULL;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -609,7 +609,7 @@
 static int vsllink_connect(void)
 {
 	char vsllink_str[100];
-	
+
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_CONN;
 	vsllink_usb_out_buffer[1] = vsllink_mode;
 	vsllink_usb_message(vsllink_jtag_handle, 2, 0);
@@ -618,7 +618,7 @@
 		strncpy(vsllink_str, (char *)vsllink_usb_in_buffer + 2, sizeof(vsllink_str));
 		LOG_INFO(&quot;%s&quot;, vsllink_str);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -630,7 +630,7 @@
 	u16 tms2;
 	insert_insignificant_operation_t *insert = \
 		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
-		
+
 	if (((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE)) || \
 			(vsllink_tms_data_len &lt;= 0) || (vsllink_tms_data_len &gt;= 8) || \
 			(vsllink_tms_cmd_pos == NULL))
@@ -638,7 +638,7 @@
 		LOG_ERROR(&quot;There MUST be some bugs in the driver&quot;);
 		exit(-1);
 	}
-	
+
 	tms2 = (tms_scan &amp; VSLLINK_BIT_MSK[insert-&gt;insert_position]) &lt;&lt; \
 				vsllink_tms_data_len;
 	if (insert-&gt;insert_value == 1)
@@ -648,10 +648,10 @@
 	}
 	tms2 |= (tms_scan &gt;&gt; insert-&gt;insert_position) &lt;&lt; \
 				(8 + insert-&gt;insert_position);
-				
+
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 &gt;&gt; 0) &amp; 0xff;
 	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 &gt;&gt; 8) &amp; 0xff;
-	
+
 	vsllink_tms_data_len = 0;
 	vsllink_tms_cmd_pos = NULL;
 }
@@ -679,11 +679,11 @@
 	else
 	{
 		vsllink_tap_ensure_space(0, 2);
-		
+
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 	}
-	
+
 	tap_set_state(tap_get_end_state());
 }
 static void vsllink_state_move_dma(void)
@@ -692,21 +692,21 @@
 	insert_insignificant_operation_t *insert = \
 		&amp;VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[tap_move_ndx(tap_get_state())][tap_move_ndx(tap_get_end_state())];
 	u8 tms_scan = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
-	
+
 	if (tap_get_state() == TAP_RESET)
 	{
 		vsllink_tap_ensure_space(0, 8);
-		
+
 		for (i = 0; i &lt; 8; i++)
 		{
 			vsllink_tap_append_step(1, 0);
 		}
 	}
-	
+
 	if (insert_length &gt; 0)
 	{
 		vsllink_tap_ensure_space(0, 16);
-		
+
 		for (i = 0; i &lt; insert-&gt;insert_position; i++)
 		{
 			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
@@ -723,13 +723,13 @@
 	else
 	{
 		vsllink_tap_ensure_space(0, 8);
-		
+
 		for (i = 0; i &lt; 8; i++)
 		{
 			vsllink_tap_append_step((tms_scan &gt;&gt; i) &amp; 1, 0);
 		}
 	}
-	
+
 	tap_set_state(tap_get_end_state());
 }
 
@@ -737,7 +737,7 @@
 static void vsllink_add_path(int start, int num, tap_state_t *path)
 {
 	int i;
-	
+
 	for (i = start; i &lt; (start + num); i++)
 	{
 		if ((i &amp; 7) == 0)
@@ -748,7 +748,7 @@
 			}
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 		}
-		
+
 		if (path[i - start] == tap_state_transition(tap_get_state(), true))
 		{
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 &lt;&lt; (i &amp; 7);
@@ -769,14 +769,14 @@
 		vsllink_usb_out_buffer_idx++;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
 	}
-	
+
 	tap_set_end_state(tap_get_state());
 }
 
 static void vsllink_path_move_normal(int num_states, tap_state_t *path)
 {
 	int i, tms_len, tms_cmd_pos, path_idx = 0;
-	
+
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		// there are vsllink_tms_data_len more tms bits to be shifted
@@ -827,7 +827,7 @@
 				// end last tms shift command
 				vsllink_add_path(vsllink_tms_data_len, num_states, path);
 			}
-			
+
 			vsllink_tms_data_len = (vsllink_tms_data_len + num_states) &amp; 7;
 			if (vsllink_tms_data_len == 0)
 			{
@@ -838,19 +838,19 @@
 		else
 		{
 			vsllink_add_path(vsllink_tms_data_len, 16 - vsllink_tms_data_len, path);
-			
+
 			path += 16 - vsllink_tms_data_len;
 			num_states -= 16 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
 			vsllink_tms_cmd_pos = NULL;
 		}
 	}
-	
+
 	if (num_states &gt; 0)
 	{
 		// Normal operation, don't need to append tms data
 		vsllink_tms_data_len = num_states &amp; 7;
-		
+
 		while (num_states &gt; 0)
 		{
 			if (num_states &gt; ((VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8))
@@ -865,13 +865,13 @@
 			vsllink_tap_ensure_space(0, tms_len + 2);
 			tms_cmd_pos = vsllink_usb_out_buffer_idx;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | (tms_len - 1);
-			
+
 			vsllink_add_path(0, i, path + path_idx);
-			
+
 			path_idx += i;
 			num_states -= i;
 		}
-		
+
 		if (vsllink_tms_data_len &gt; 0)
 		{
 			if (tms_len &lt; (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
@@ -882,7 +882,7 @@
 			else
 			{
 				vsllink_usb_out_buffer[tms_cmd_pos]--;
-				
+
 				tms_len = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 				vsllink_tap_ensure_space(0, 3);
 				vsllink_tms_cmd_pos = &amp;vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
@@ -895,7 +895,7 @@
 static void vsllink_path_move_dma(int num_states, tap_state_t *path)
 {
 	int i, j = 0;
-	
+
 	if (tap_length &amp; 7)
 	{
 		if ((8 - (tap_length &amp; 7)) &lt; num_states)
@@ -925,11 +925,11 @@
 		}
 		num_states -= j;
 	}
-	
+
 	if (num_states &gt; 0)
 	{
 		vsllink_tap_ensure_space(0, num_states);
-		
+
 		for (i = 0; i &lt; num_states; i++)
 		{
 			if (path[j + i] == tap_state_transition(tap_get_state(), false))
@@ -948,7 +948,7 @@
 			tap_set_state(path[j + i]);
 		}
 	}
-	
+
 	tap_set_end_state(tap_get_state());
 }
 
@@ -956,7 +956,7 @@
 {
 	int tms_len;
 	u16 tms_append_byte;
-	
+
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		// there are vsllink_tms_data_len more tms bits to be shifted
@@ -1022,7 +1022,7 @@
 				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
 				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte &gt;&gt; 8);
 			}
-			
+
 			vsllink_tms_data_len = tms_len &amp; 7;
 			if (vsllink_tms_data_len == 0)
 			{
@@ -1035,14 +1035,14 @@
 			// more shifts will be needed
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (u8)(tms_append_byte &amp; 0xFF);
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (u8)(tms_append_byte &gt;&gt; 8);
-			
+
 			num_cycles -= 16 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
 			vsllink_tms_cmd_pos = NULL;
 		}
 	}
 	// from here vsllink_tms_data_len == 0 or num_cycles == 0
-	
+
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		// num_cycles == 0
@@ -1075,17 +1075,17 @@
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 8) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 16) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms_len &gt;&gt; 24) &amp; 0xff;
-			
+
 			vsllink_usb_in_want_length += 1;
 			pending_scan_results_buffer[pending_scan_results_length].buffer = NULL;
 			pending_scan_results_length++;
-			
+
 			if (tms_len &gt; 0xFFFF)
 			{
 				vsllink_tap_execute();
 			}
 		}
-		
+
 		// post-process
 		vsllink_tms_data_len = num_cycles &amp; 7;
 		if (vsllink_tms_data_len &gt; 0)
@@ -1109,7 +1109,7 @@
 static void vsllink_stableclocks_dma(int num_cycles, int tms)
 {
 	int i, cur_cycles;
-	
+
 	if (tap_length &amp; 7)
 	{
 		if ((8 - (tap_length &amp; 7)) &lt; num_cycles)
@@ -1126,7 +1126,7 @@
 		}
 		num_cycles -= cur_cycles;
 	}
-	
+
 	while (num_cycles &gt; 0)
 	{
 		if (num_cycles &gt; 8 * tap_buffer_size)
@@ -1137,14 +1137,14 @@
 		{
 			cur_cycles = num_cycles;
 		}
-		
+
 		vsllink_tap_ensure_space(0, cur_cycles);
-		
+
 		for (i = 0; i &lt; cur_cycles; i++)
 		{
 			vsllink_tap_append_step(tms, 0);
 		}
-		
+
 		num_cycles -= cur_cycles;
 	}
 }
@@ -1152,16 +1152,16 @@
 static void vsllink_runtest(int num_cycles)
 {
 	tap_state_t saved_end_state = tap_get_end_state();
-	
+
 	if (tap_get_state() != TAP_IDLE)
 	{
 		// enter into IDLE state
 		vsllink_end_state(TAP_IDLE);
 		vsllink_state_move();
 	}
-	
+
 	vsllink_stableclocks(num_cycles, 0);
-	
+
 	// post-process
 	// set end_state
 	vsllink_end_state(saved_end_state);
@@ -1177,24 +1177,24 @@
 	tap_state_t saved_end_state;
 	u8 bits_left, tms_tmp, tdi_len;
 	int i;
-	
+
 	if (0 == scan_size )
 	{
 		return;
 	}
-	
+
 	tdi_len = ((scan_size + 7) &gt;&gt; 3);
 	if ((tdi_len + 7) &gt; VSLLINK_BufferSize)
 	{
 		LOG_ERROR(&quot;Your implementation of VSLLink has not enough buffer&quot;);
 		exit(-1);
 	}
-	
+
 	saved_end_state = tap_get_end_state();
-	
+
 	/* Move to appropriate scan state */
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
-	
+
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		if (tap_get_state() == tap_get_end_state())
@@ -1216,16 +1216,16 @@
 				tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
 				*vsllink_tms_cmd_pos -= 2;
 			}
-			
+
 			vsllink_tap_ensure_space(1, tdi_len + 7);
-			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid 
+			// VSLLINK_CMDJTAGSEQ_SCAN ored by 1 means that tms_before is valid
 			// which is merged from the last tms shift command
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 8) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = tms_tmp;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[0] &lt;&lt; (8 - vsllink_tms_data_len);
-			
+
 			for (i = 0; i &lt; tdi_len; i++)
 			{
 				buffer[i] &gt;&gt;= 8 - vsllink_tms_data_len;
@@ -1234,7 +1234,7 @@
 					buffer[i] += buffer[i + 1] &lt;&lt; vsllink_tms_data_len;
 				}
 			}
-			
+
 			vsllink_tap_append_scan_normal(scan_size - vsllink_tms_data_len, buffer, command, vsllink_tms_data_len);
 			scan_size -= 8 - vsllink_tms_data_len;
 			vsllink_tms_data_len = 0;
@@ -1243,31 +1243,31 @@
 		{
 			vsllink_state_move();
 			vsllink_tap_ensure_space(1, tdi_len + 5);
-			
+
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 0) &amp; 0xff;
 			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 8) &amp; 0xff;
-			
+
 			vsllink_tap_append_scan_normal(scan_size, buffer, command, 0);
 		}
 	}
 	else
 	{
 		vsllink_tap_ensure_space(1, tdi_len + 7);
-		
+
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)&gt;&gt; 8) &amp; 0xff;
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
-		
+
 		vsllink_tap_append_scan_normal(scan_size, buffer, command, 8);
 	}
 	vsllink_end_state(saved_end_state);
-	
+
 	bits_left = scan_size &amp; 0x07;
 	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
-	
+
 	if (bits_left &gt; 0)
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; (bits_left - 1);
@@ -1276,7 +1276,7 @@
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; 7;
 	}
-	
+
 	if (tap_get_state() != tap_get_end_state())
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(tap_get_state(), tap_get_end_state());
@@ -1285,31 +1285,31 @@
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
 	}
-	
+
 	tap_set_state(tap_get_end_state());
 }
 static void vsllink_scan_dma(bool ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
 	tap_state_t saved_end_state;
-	
+
 	saved_end_state = tap_get_end_state();
-	
+
 	/* Move to appropriate scan state */
 	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
-	
+
 	vsllink_state_move();
 	vsllink_end_state(saved_end_state);
-	
+
 	/* Scan */
 	vsllink_tap_append_scan_dma(scan_size, buffer, command);
-	
+
 	tap_set_state(ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE);
 	while (tap_length % 8 != 0)
 	{
 		// more 0s in Pause
 		vsllink_tap_append_step(0, 0);
 	}
-	
+
 	if (tap_get_state() != tap_get_end_state())
 	{
 		vsllink_state_move();
@@ -1319,9 +1319,9 @@
 static void vsllink_reset(int trst, int srst)
 {
 	int result;
-	
+
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
-	
+
 	/* Signals are active low */
 	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORT;
 	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
@@ -1334,7 +1334,7 @@
 	{
 		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_TRST;
 	}
-	
+
 	result = vsllink_usb_write(vsllink_jtag_handle, 3);
 	if (result != 3)
 	{
@@ -1345,12 +1345,12 @@
 static void vsllink_simple_command(u8 command)
 {
 	int result;
-	
+
 	DEBUG_JTAG_IO(&quot;0x%02x&quot;, command);
-	
+
 	vsllink_usb_out_buffer[0] = command;
 	result = vsllink_usb_write(vsllink_jtag_handle, 1);
-	
+
 	if (result != 1)
 	{
 		LOG_ERROR(&quot;VSLLink command 0x%02x failed (%d)&quot;, command, result);
@@ -1359,19 +1359,19 @@
 
 static int vsllink_register_commands(struct command_context_s *cmd_ctx)
 {
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;, vsllink_handle_usb_pid_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;, vsllink_handle_usb_pid_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;, vsllink_handle_usb_bulkin_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;, vsllink_handle_usb_bulkin_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;, vsllink_handle_usb_bulkout_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;, vsllink_handle_usb_bulkout_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_usb_interface&quot;, vsllink_handle_usb_interface_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_interface&quot;, vsllink_handle_usb_interface_command,
 					COMMAND_CONFIG, NULL);
-	register_command(cmd_ctx, NULL, &quot;vsllink_mode&quot;, vsllink_handle_mode_command, 
+	register_command(cmd_ctx, NULL, &quot;vsllink_mode&quot;, vsllink_handle_mode_command,
 					COMMAND_CONFIG, NULL);
-					
+
 	return ERROR_OK;
 }
 
@@ -1381,7 +1381,7 @@
 		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
 		return ERROR_FAIL;
 	}
-	
+
 	if (!strcmp(args[0], &quot;normal&quot;))
 	{
 		vsllink_mode = VSLLINK_MODE_NORMAL;
@@ -1395,7 +1395,7 @@
 		LOG_ERROR(&quot;invalid vsllink_mode: %s&quot;, args[0]);
 		return ERROR_FAIL;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1406,9 +1406,9 @@
 		LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
 		return ERROR_OK;
 	}
-	
+
 	vsllink_usb_vid = strtol(args[0], NULL, 0);
-	
+
 	return ERROR_OK;
 }
 
@@ -1419,9 +1419,9 @@
 		LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
 		return ERROR_OK;
 	}
-	
+
 	vsllink_usb_pid = strtol(args[0], NULL, 0);
-	
+
 	return ERROR_OK;
 }
 
@@ -1432,9 +1432,9 @@
 		LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN endpoint&quot;);
 		return ERROR_OK;
 	}
-	
+
 	vsllink_usb_bulkin = strtol(args[0], NULL, 0) | 0x80;
-	
+
 	return ERROR_OK;
 }
 
@@ -1445,9 +1445,9 @@
 		LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT endpoint&quot;);
 		return ERROR_OK;
 	}
-	
+
 	vsllink_usb_bulkout = strtol(args[0], NULL, 0);
-	
+
 	return ERROR_OK;
 }
 
@@ -1458,9 +1458,9 @@
 		LOG_ERROR(&quot;parameter error, should be one parameter for interface number&quot;);
 		return ERROR_OK;
 	}
-	
+
 	vsllink_usb_interface = strtol(args[0], NULL, 0);
-	
+
 	return ERROR_OK;
 }
 
@@ -1483,7 +1483,7 @@
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bytes = VSLLINK_BufferSize - vsllink_usb_out_buffer_idx;
-	
+
 	if (scans &gt; available_scans || length &gt; available_bytes)
 	{
 		vsllink_tap_execute();
@@ -1493,7 +1493,7 @@
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bytes = tap_buffer_size * 8 - tap_length;
-	
+
 	if (scans &gt; available_scans || length &gt; available_bytes)
 	{
 		vsllink_tap_execute();
@@ -1504,12 +1504,12 @@
 {
 	last_tms = tms;
 	int index = tap_length / 8;
-	
+
 	if (index &lt; tap_buffer_size)
 	{
 		int bit_index = tap_length % 8;
 		u8 bit = 1 &lt;&lt; bit_index;
-		
+
 		if (tms)
 		{
 			tms_buffer[index] |= bit;
@@ -1518,7 +1518,7 @@
 		{
 			tms_buffer[index] &amp;= ~bit;
 		}
-		
+
 		if (tdi)
 		{
 			tdi_buffer[index] |= bit;
@@ -1527,7 +1527,7 @@
 		{
 			tdi_buffer[index] &amp;= ~bit;
 		}
-		
+
 		tap_length++;
 	}
 	else
@@ -1540,7 +1540,7 @@
 {
 	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 	int i;
-	
+
 	if (offset &gt; 0)
 	{
 		vsllink_usb_in_want_length += ((length + 7) &gt;&gt; 3) + 1;
@@ -1553,19 +1553,19 @@
 	pending_scan_result-&gt;offset = offset;
 	pending_scan_result-&gt;command = command;
 	pending_scan_result-&gt;buffer = buffer;
-	
+
 	for (i = 0; i &lt; ((length + 7) &gt;&gt; 3); i++)
 	{
 		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[i];
 	}
-	
+
 	pending_scan_results_length++;
 }
 static void vsllink_tap_append_scan_dma(int length, u8 *buffer, scan_command_t *command)
 {
 	pending_scan_result_t *pending_scan_result;
 	int len_tmp, len_all, i;
-	
+
 	len_all = 0;
 	while (len_all &lt; length)
 	{
@@ -1577,20 +1577,20 @@
 		{
 			len_tmp = length - len_all;
 		}
-		
+
 		vsllink_tap_ensure_space(1, (len_tmp + 7) &amp; ~7);
-		
+
 		pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 		pending_scan_result-&gt;offset = tap_length;
 		pending_scan_result-&gt;length = len_tmp;
 		pending_scan_result-&gt;command = command;
 		pending_scan_result-&gt;buffer = buffer + len_all / 8;
-		
+
 		for (i = 0; i &lt; len_tmp; i++)
 		{
 			vsllink_tap_append_step(((len_all+i) &lt; length-1 ? 0 : 1), (buffer[(len_all+i)/8] &gt;&gt; ((len_all+i)%8)) &amp; 1);
 		}
-		
+
 		pending_scan_results_length++;
 		len_all += len_tmp;
 	}
@@ -1603,14 +1603,14 @@
 	int i;
 	int result;
 	int first = 0;
-	
+
 	if (vsllink_tms_data_len &gt; 0)
 	{
 		if((tap_get_state() != TAP_RESET) &amp;&amp; (tap_get_state() != TAP_IDLE) &amp;&amp; (tap_get_state() != TAP_IRPAUSE) &amp;&amp; (tap_get_state() != TAP_DRPAUSE))
 		{
 			LOG_WARNING(&quot;%s is not in RESET or IDLE or PAUSR state&quot;, tap_state_name(tap_get_state()));
 		}
-		
+
 		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] &amp; (1 &lt;&lt; (vsllink_tms_data_len - 1)))
 		{
 			// last tms bit is '1'
@@ -1626,7 +1626,7 @@
 			vsllink_tms_data_len = 0;
 		}
 	}
-	
+
 	if (vsllink_usb_out_buffer_idx &gt; 3)
 	{
 		if (vsllink_usb_out_buffer[0] == VSLLINK_CMD_HW_JTAGSEQCMD)
@@ -1634,9 +1634,9 @@
 			vsllink_usb_out_buffer[1] = (vsllink_usb_out_buffer_idx &gt;&gt; 0) &amp; 0xff;
 			vsllink_usb_out_buffer[2] = (vsllink_usb_out_buffer_idx &gt;&gt; 8) &amp; 0xff;
 		}
-		
+
 		result = vsllink_usb_message(vsllink_jtag_handle, vsllink_usb_out_buffer_idx, vsllink_usb_in_want_length);
-		
+
 		if (result == vsllink_usb_in_want_length)
 		{
 			for (i = 0; i &lt; pending_scan_results_length; i++)
@@ -1646,24 +1646,24 @@
 				int length = pending_scan_result-&gt;length;
 				int offset = pending_scan_result-&gt;offset;
 				scan_command_t *command = pending_scan_result-&gt;command;
-				
+
 				if (buffer != NULL)
 				{
 					// IRSHIFT or DRSHIFT
 					buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
 					first += (length + offset + 7) &gt;&gt; 3;
-					
+
 					DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits):&quot;, length);
 #ifdef _DEBUG_JTAG_IO_
 					vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
 #endif
-					
+
 					if (jtag_read_buffer(buffer, command) != ERROR_OK)
 					{
 						vsllink_tap_init();
 						return ERROR_JTAG_QUEUE_FAILED;
 					}
-					
+
 					free(pending_scan_result-&gt;buffer);
 					pending_scan_result-&gt;buffer = NULL;
 				}
@@ -1678,11 +1678,11 @@
 			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, vsllink_usb_in_want_length);
 			return ERROR_JTAG_QUEUE_FAILED;
 		}
-		
+
 		vsllink_tap_init();
 	}
 	reset_command_pointer();
-	
+
 	return ERROR_OK;
 }
 static int vsllink_tap_execute_dma(void)
@@ -1690,7 +1690,7 @@
 	int byte_length;
 	int i;
 	int result;
-	
+
 	if (tap_length &gt; 0)
 	{
 		/* Pad last byte so that tap_length is divisible by 8 */
@@ -1701,14 +1701,14 @@
 			vsllink_tap_append_step(last_tms, 0);
 		}
 		byte_length = tap_length / 8;
-		
+
 		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGRAWCMD;
 		vsllink_usb_out_buffer[1] = ((byte_length * 2 + 3) &gt;&gt; 0) &amp; 0xff;		// package size
 		vsllink_usb_out_buffer[2] = ((byte_length * 2 + 3) &gt;&gt; 8) &amp; 0xff;
-		
+
 		memcpy(&amp;vsllink_usb_out_buffer[3], tdi_buffer, byte_length);
 		memcpy(&amp;vsllink_usb_out_buffer[3 + byte_length], tms_buffer, byte_length);
-		
+
 		result = vsllink_usb_message(vsllink_jtag_handle, 3 + 2 * byte_length, byte_length);
 		if (result == byte_length)
 		{
@@ -1718,21 +1718,21 @@
 				u8 *buffer = pending_scan_result-&gt;buffer;
 				int length = pending_scan_result-&gt;length;
 				int first = pending_scan_result-&gt;offset;
-				
+
 				scan_command_t *command = pending_scan_result-&gt;command;
 				buf_set_buf(vsllink_usb_in_buffer, first, buffer, 0, length);
-				
+
 				DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits, from %d bits):&quot;, length, first);
 #ifdef _DEBUG_JTAG_IO_
 				vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
 #endif
-				
+
 				if (jtag_read_buffer(buffer, command) != ERROR_OK)
 				{
 					vsllink_tap_init();
 					return ERROR_JTAG_QUEUE_FAILED;
 				}
-				
+
 				if (pending_scan_result-&gt;buffer != NULL)
 				{
 					free(pending_scan_result-&gt;buffer);
@@ -1744,10 +1744,10 @@
 			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, byte_length);
 			return ERROR_JTAG_QUEUE_FAILED;
 		}
-		
+
 		vsllink_tap_init();
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1760,19 +1760,19 @@
 	struct usb_bus *bus;
 	struct usb_device *dev;
 	int ret;
-	
+
 	vsllink_jtag_t *result;
-	
+
 	result = (vsllink_jtag_t*) malloc(sizeof(vsllink_jtag_t));
-	
+
 	usb_init();
 	usb_find_busses();
 	usb_find_devices();
-	
+
 	busses = usb_get_busses();
-	
+
 	/* find vsllink_jtag device in usb bus */
-	
+
 	for (bus = busses; bus; bus = bus-&gt;next)
 	{
 		for (dev = bus-&gt;devices; dev; dev = dev-&gt;next)
@@ -1785,7 +1785,7 @@
 					LOG_ERROR(&quot;failed to open %04X:%04X, not enough permissions?&quot;, vsllink_usb_vid, vsllink_usb_pid);
 					exit(-1);
 				}
-				
+
 				/* usb_set_configuration required under win32 */
 				ret = usb_set_configuration(result-&gt;usb_handle, dev-&gt;config[0].bConfigurationValue);
 				if (ret != 0)
@@ -1799,19 +1799,19 @@
 					LOG_ERROR(&quot;fail to claim interface %d, %d returned&quot;, vsllink_usb_interface, ret);
 					exit(-1);
 				}
-				
+
 #if 0
-				/* 
+				/*
 				 * This makes problems under Mac OS X. And is not needed
 				 * under Windows. Hopefully this will not break a linux build
 				 */
 				usb_set_altinterface(result-&gt;usb_handle, 0);
-#endif				
+#endif
 				return result;
 			}
 		}
 	}
-	
+
 	free(result);
 	return NULL;
 }
@@ -1841,7 +1841,7 @@
 static int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length)
 {
 	int result;
-	
+
 	result = vsllink_usb_write(vsllink_jtag, out_length);
 	if (result == out_length)
 	{
@@ -1871,18 +1871,18 @@
 static int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length)
 {
 	int result;
-	
+
 	if (out_length &gt; VSLLINK_BufferSize)
 	{
 		LOG_ERROR(&quot;vsllink_jtag_write illegal out_length=%d (max=%d)&quot;, out_length, VSLLINK_BufferSize);
 		return -1;
 	}
-	
+
 	result = usb_bulk_write(vsllink_jtag-&gt;usb_handle, vsllink_usb_bulkout, \
 		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
-	
+
 	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;, out_length, result);
-	
+
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG(&quot;USB out:&quot;);
 	vsllink_debug_buffer(vsllink_usb_out_buffer, out_length);
@@ -1900,9 +1900,9 @@
 {
 	int result = usb_bulk_read(vsllink_jtag-&gt;usb_handle, vsllink_usb_bulkin, \
 		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize, VSLLINK_USB_TIMEOUT);
-		
+
 	DEBUG_JTAG_IO(&quot;vsllink_usb_read, result = %d&quot;, result);
-	
+
 #ifdef _DEBUG_USB_COMMS_
 	LOG_DEBUG(&quot;USB in:&quot;);
 	vsllink_debug_buffer(vsllink_usb_in_buffer, result);
@@ -1919,7 +1919,7 @@
 	char s[4];
 	int i;
 	int j;
-	
+
 	for (i = 0; i &lt; length; i += BYTES_PER_LINE)
 	{
 		snprintf(line, 5, &quot;%04x&quot;, i);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000819.html">[Openocd-svn] r2035 - trunk/doc
</A></li>
	<LI>Next message: <A HREF="000821.html">[Openocd-svn] r2037 - trunk/src/jtag
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#820">[ date ]</a>
              <a href="thread.html#820">[ thread ]</a>
              <a href="subject.html#820">[ subject ]</a>
              <a href="author.html#820">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
