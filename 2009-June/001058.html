<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r2274 - trunk/src/target
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2274%20-%20trunk/src/target&In-Reply-To=%3C200906180706.n5I76CTJ015687%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001057.html">
   <LINK REL="Next"  HREF="001059.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r2274 - trunk/src/target</H1>
    <B>zwelch at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r2274%20-%20trunk/src/target&In-Reply-To=%3C200906180706.n5I76CTJ015687%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r2274 - trunk/src/target">zwelch at mail.berlios.de
       </A><BR>
    <I>Thu Jun 18 09:06:12 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001057.html">[Openocd-svn] r2273 - trunk/doc
</A></li>
        <LI>Next message: <A HREF="001059.html">[Openocd-svn] r2275 - trunk/src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1058">[ date ]</a>
              <a href="thread.html#1058">[ thread ]</a>
              <a href="subject.html#1058">[ subject ]</a>
              <a href="author.html#1058">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zwelch
Date: 2009-06-18 09:04:08 +0200 (Thu, 18 Jun 2009)
New Revision: 2274

Modified:
   trunk/src/target/algorithm.h
   trunk/src/target/arm11.c
   trunk/src/target/arm11.h
   trunk/src/target/arm11_dbgtap.c
   trunk/src/target/arm720t.c
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7_9_common.h
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm920t.c
   trunk/src/target/arm926ejs.c
   trunk/src/target/arm926ejs.h
   trunk/src/target/arm966e.c
   trunk/src/target/arm9tdmi.c
   trunk/src/target/arm_adi_v5.c
   trunk/src/target/arm_adi_v5.h
   trunk/src/target/arm_disassembler.c
   trunk/src/target/arm_disassembler.h
   trunk/src/target/arm_jtag.c
   trunk/src/target/arm_jtag.h
   trunk/src/target/arm_simulator.c
   trunk/src/target/armv4_5.c
   trunk/src/target/armv4_5_mmu.c
   trunk/src/target/armv4_5_mmu.h
   trunk/src/target/armv7m.c
   trunk/src/target/avrt.c
   trunk/src/target/breakpoints.h
   trunk/src/target/cortex_a8.c
   trunk/src/target/cortex_a8.h
   trunk/src/target/cortex_m3.c
   trunk/src/target/cortex_m3.h
   trunk/src/target/embeddedice.c
   trunk/src/target/embeddedice.h
   trunk/src/target/etb.c
   trunk/src/target/etb.h
   trunk/src/target/etm.c
   trunk/src/target/etm.h
   trunk/src/target/feroceon.c
   trunk/src/target/image.c
   trunk/src/target/image.h
   trunk/src/target/mips32.c
   trunk/src/target/mips32_dmaacc.c
   trunk/src/target/mips32_dmaacc.h
   trunk/src/target/mips32_pracc.c
   trunk/src/target/mips32_pracc.h
   trunk/src/target/mips_ejtag.c
   trunk/src/target/mips_m4k.c
   trunk/src/target/mips_m4k.h
   trunk/src/target/oocd_trace.c
   trunk/src/target/register.c
   trunk/src/target/register.h
   trunk/src/target/target.c
   trunk/src/target/target.h
   trunk/src/target/target_request.c
   trunk/src/target/target_type.h
   trunk/src/target/xscale.c
   trunk/src/target/xscale.h
Log:
Transform 'u8' to 'uint8_t' in src/target
- Replace '\([^_]\)u8' with '\1uint8_t'.
- Replace '^u8' with 'uint8_t'.


Modified: trunk/src/target/algorithm.h
===================================================================
--- trunk/src/target/algorithm.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/algorithm.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -33,7 +33,7 @@
 {
 	u32 address;
 	u32 size;
-	u8 *value;
+	uint8_t *value;
 	enum param_direction direction;
 } mem_param_t; 
 
@@ -41,7 +41,7 @@
 {
 	char *reg_name;
 	u32 size;
-	u8 *value;
+	uint8_t *value;
 	enum param_direction direction;
 } reg_param_t;
 

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm11.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -288,14 +288,14 @@
 
 #define ARM11_GDB_REGISTER_COUNT	26
 
-u8 arm11_gdb_dummy_fp_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+uint8_t arm11_gdb_dummy_fp_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
 reg_t arm11_gdb_dummy_fp_reg =
 {
 	&quot;GDB dummy floating-point register&quot;, arm11_gdb_dummy_fp_value, 0, 1, 96, NULL, 0, NULL, 0
 };
 
-u8 arm11_gdb_dummy_fps_value[] = {0, 0, 0, 0};
+uint8_t arm11_gdb_dummy_fps_value[] = {0, 0, 0, 0};
 
 reg_t arm11_gdb_dummy_fps_reg =
 {
@@ -630,8 +630,8 @@
 
 		scan_field_t	chain5_fields[3];
 
-		u8			Ready		= 0;	/* ignored */
-		u8			Valid		= 0;	/* ignored */
+		uint8_t			Ready		= 0;	/* ignored */
+		uint8_t			Valid		= 0;	/* ignored */
 
 		arm11_setup_field(arm11, 32, &amp;R(RDTR),	NULL, chain5_fields + 0);
 		arm11_setup_field(arm11,  1, &amp;Ready,	NULL, chain5_fields + 1);
@@ -717,7 +717,7 @@
 }
 
 /* target request support */
-int arm11_target_request_data(struct target_s *target, u32 size, u8 *buffer)
+int arm11_target_request_data(struct target_s *target, u32 size, uint8_t *buffer)
 {
 	FNC_INFO_NOTIMPLEMENTED;
 
@@ -1090,7 +1090,7 @@
  * size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
  * count: number of items of &lt;size&gt;
  */
-int arm11_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm11_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	/** \todo TODO: check if buffer cast to u32* and u16* might cause alignment problems */
 
@@ -1173,7 +1173,7 @@
 	return ERROR_OK;
 }
 
-int arm11_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm11_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	FNC_INFO;
 
@@ -1285,7 +1285,7 @@
 
 
 /* write target memory in multiples of 4 byte, optimized for writing large quantities of data */
-int arm11_bulk_write_memory(struct target_s *target, u32 address, u32 count, u8 *buffer)
+int arm11_bulk_write_memory(struct target_s *target, u32 address, u32 count, uint8_t *buffer)
 {
 	FNC_INFO;
 
@@ -1395,11 +1395,11 @@
 	// Save regs
 	for (size_t i = 0; i &lt; 16; i++)
 	{
-		context[i] = buf_get_u32((u8*)(&amp;arm11-&gt;reg_values[i]),0,32);
+		context[i] = buf_get_u32((uint8_t*)(&amp;arm11-&gt;reg_values[i]),0,32);
 		LOG_DEBUG(&quot;Save %zi: 0x%x&quot;,i,context[i]);
 	}
 
-	cpsr = buf_get_u32((u8*)(arm11-&gt;reg_values+ARM11_RC_CPSR),0,32);
+	cpsr = buf_get_u32((uint8_t*)(arm11-&gt;reg_values+ARM11_RC_CPSR),0,32);
 	LOG_DEBUG(&quot;Save CPSR: 0x%x&quot;, cpsr);
 
 	for (int i = 0; i &lt; num_mem_params; i++)
@@ -1521,10 +1521,10 @@
 	{
 		LOG_DEBUG(&quot;restoring register %s with value 0x%8.8x&quot;,
 			 arm11-&gt;reg_list[i].name, context[i]);
-		arm11_set_reg(&amp;arm11-&gt;reg_list[i], (u8*)&amp;context[i]);
+		arm11_set_reg(&amp;arm11-&gt;reg_list[i], (uint8_t*)&amp;context[i]);
 	}
 	LOG_DEBUG(&quot;restoring CPSR with value 0x%8.8x&quot;, cpsr);
-	arm11_set_reg(&amp;arm11-&gt;reg_list[ARM11_RC_CPSR], (u8*)&amp;cpsr);
+	arm11_set_reg(&amp;arm11-&gt;reg_list[ARM11_RC_CPSR], (uint8_t*)&amp;cpsr);
 
 //	arm11-&gt;core_state = core_state;
 //	arm11-&gt;core_mode = core_mode;
@@ -1668,7 +1668,7 @@
 }
 
 /** Change a value in the register cache */
-int arm11_set_reg(reg_t *reg, u8 *buf)
+int arm11_set_reg(reg_t *reg, uint8_t *buf)
 {
 	FNC_INFO;
 
@@ -1730,7 +1730,7 @@
 
 		r-&gt;name				= rd-&gt;name;
 		r-&gt;size				= 32;
-		r-&gt;value			= (u8 *)(arm11-&gt;reg_values + i);
+		r-&gt;value			= (uint8_t *)(arm11-&gt;reg_values + i);
 		r-&gt;dirty			= 0;
 		r-&gt;valid			= 0;
 		r-&gt;bitfield_desc	= NULL;

Modified: trunk/src/target/arm11.h
===================================================================
--- trunk/src/target/arm11.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm11.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -66,7 +66,7 @@
 typedef struct arm11_register_history_s
 {
 	u32		value;
-	u8		valid;
+	uint8_t		valid;
 }arm11_register_history_t;
 
 enum arm11_debug_version
@@ -86,7 +86,7 @@
 
 	u32		device_id;		/**&lt; IDCODE readout				*/
 	u32		didr;			/**&lt; DIDR readout (debug capabilities)	*/
-	u8		implementor;	/**&lt; DIDR Implementor readout		*/
+	uint8_t		implementor;	/**&lt; DIDR Implementor readout		*/
 
 	size_t	brp;			/**&lt; Number of Breakpoint Register Pairs from DIDR	*/
 	size_t	wrp;			/**&lt; Number of Watchpoint Register Pairs from DIDR	*/
@@ -191,7 +191,7 @@
 int arm11_arch_state(struct target_s *target);
 
 /* target request support */
-int arm11_target_request_data(struct target_s *target, u32 size, u8 *buffer);
+int arm11_target_request_data(struct target_s *target, u32 size, uint8_t *buffer);
 
 /* target execution control */
 int arm11_halt(struct target_s *target);
@@ -211,11 +211,11 @@
 * size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
 * count: number of items of &lt;size&gt;
 */
-int arm11_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int arm11_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+int arm11_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm11_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 
 /* write target memory in multiples of 4 byte, optimized for writing large quantities of data */
-int arm11_bulk_write_memory(struct target_s *target, u32 address, u32 count, u8 *buffer);
+int arm11_bulk_write_memory(struct target_s *target, u32 address, u32 count, uint8_t *buffer);
 
 int arm11_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum);
 
@@ -237,7 +237,7 @@
 
 /* helpers */
 int arm11_build_reg_cache(target_t *target);
-int arm11_set_reg(reg_t *reg, u8 *buf);
+int arm11_set_reg(reg_t *reg, uint8_t *buf);
 int arm11_get_reg(reg_t *reg);
 
 void arm11_record_register_history(arm11_common_t * arm11);
@@ -246,9 +246,9 @@
 /* internals */
 
 void arm11_setup_field			(arm11_common_t * arm11, int num_bits, void * in_data, void * out_data, scan_field_t * field);
-void arm11_add_IR				(arm11_common_t * arm11, u8 instr, tap_state_t state);
-void arm11_add_debug_SCAN_N		(arm11_common_t * arm11, u8 chain, tap_state_t state);
-void arm11_add_debug_INST		(arm11_common_t * arm11, u32 inst, u8 * flag, tap_state_t state);
+void arm11_add_IR				(arm11_common_t * arm11, uint8_t instr, tap_state_t state);
+void arm11_add_debug_SCAN_N		(arm11_common_t * arm11, uint8_t chain, tap_state_t state);
+void arm11_add_debug_INST		(arm11_common_t * arm11, u32 inst, uint8_t * flag, tap_state_t state);
 int arm11_read_DSCR				(arm11_common_t * arm11, u32 *dscr);
 int arm11_write_DSCR			(arm11_common_t * arm11, u32 dscr);
 
@@ -275,7 +275,7 @@
 typedef struct arm11_sc7_action_s
 {
 	bool	write;				/**&lt; Access mode: true for write, false for read.	*/
-	u8		address;			/**&lt; Register address mode. Use enum #arm11_sc7		*/
+	uint8_t		address;			/**&lt; Register address mode. Use enum #arm11_sc7		*/
 	u32		value;				/**&lt; If write then set this to value to be written.
 									 In read mode this receives the read value when the
 									 function returns.					*/

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm11_dbgtap.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -97,7 +97,7 @@
  *
  * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
-void arm11_add_IR(arm11_common_t * arm11, u8 instr, tap_state_t state)
+void arm11_add_IR(arm11_common_t * arm11, uint8_t instr, tap_state_t state)
 {
 	jtag_tap_t *tap;
 	tap = arm11-&gt;target-&gt;tap;
@@ -122,10 +122,10 @@
  *  arm11_add_debug_SCAN_N().
  *
  */
-static void arm11_in_handler_SCAN_N(u8 *in_value)
+static void arm11_in_handler_SCAN_N(uint8_t *in_value)
 {
 	/** \todo TODO: clarify why this isnt properly masked in core.c jtag_read_buffer() */
-	u8 v = *in_value &amp; 0x1F;
+	uint8_t v = *in_value &amp; 0x1F;
 
 	if (v != 0x10)
 	{
@@ -160,7 +160,7 @@
  * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
 
-void arm11_add_debug_SCAN_N(arm11_common_t * arm11, u8 chain, tap_state_t state)
+void arm11_add_debug_SCAN_N(arm11_common_t * arm11, uint8_t chain, tap_state_t state)
 {
 	JTAG_DEBUG(&quot;SCREG &lt;= 0x%02x&quot;, chain);
 
@@ -168,7 +168,7 @@
 
 	scan_field_t		field;
 
-	u8 tmp[1];
+	uint8_t tmp[1];
 	arm11_setup_field(arm11, 5, &amp;chain, &amp;tmp, &amp;field);
 
 	arm11_add_dr_scan_vc(1, &amp;field, state == ARM11_TAP_DEFAULT ? TAP_DRPAUSE : state);
@@ -195,7 +195,7 @@
  *
  * \remarks			This adds to the JTAG command queue but does \em not execute it.
  */
-void arm11_add_debug_INST(arm11_common_t * arm11, u32 inst, u8 * flag, tap_state_t state)
+void arm11_add_debug_INST(arm11_common_t * arm11, u32 inst, uint8_t * flag, tap_state_t state)
 {
 	JTAG_DEBUG(&quot;INST &lt;= 0x%08x&quot;, inst);
 
@@ -374,7 +374,7 @@
 
 		while (1)
 		{
-			u8 flag;
+			uint8_t flag;
 
 			arm11_add_debug_INST(arm11, 0, &amp;flag, count ? TAP_IDLE : TAP_DRPAUSE);
 
@@ -426,8 +426,8 @@
 	scan_field_t	chain5_fields[3];
 
 	u32				Data;
-	u8				Ready;
-	u8				nRetry;
+	uint8_t				Ready;
+	uint8_t				nRetry;
 
 	arm11_setup_field(arm11, 32,    &amp;Data,  NULL,		chain5_fields + 0);
 	arm11_setup_field(arm11,  1,    NULL,   &amp;Ready,		chain5_fields + 1);
@@ -516,8 +516,8 @@
 	arm11_setup_field(arm11,  1,    NULL,			NULL /*&amp;Ready*/,	chain5_fields + 1);
 	arm11_setup_field(arm11,  1,    NULL,			NULL,				chain5_fields + 2);
 
-	u8			Readies[count + 1];
-	u8	*		ReadyPos			= Readies;
+	uint8_t			Readies[count + 1];
+	uint8_t	*		ReadyPos			= Readies;
 
 	while (count--)
 	{
@@ -603,8 +603,8 @@
 	scan_field_t	chain5_fields[3];
 
 	u32			Data;
-	u8			Ready;
-	u8			nRetry;
+	uint8_t			Ready;
+	uint8_t			nRetry;
 
 	arm11_setup_field(arm11, 32,    NULL,	&amp;Data,	    chain5_fields + 0);
 	arm11_setup_field(arm11,  1,    NULL,	&amp;Ready,	    chain5_fields + 1);
@@ -685,12 +685,12 @@
 
 	scan_field_t	chain7_fields[3];
 
-	u8				nRW;
+	uint8_t				nRW;
 	u32				DataOut;
-	u8				AddressOut;
-	u8				Ready;
+	uint8_t				AddressOut;
+	uint8_t				Ready;
 	u32				DataIn;
-	u8				AddressIn;
+	uint8_t				AddressIn;
 
 	arm11_setup_field(arm11,  1, &amp;nRW,			&amp;Ready,		chain7_fields + 0);
 	arm11_setup_field(arm11, 32, &amp;DataOut,		&amp;DataIn,	chain7_fields + 1);

Modified: trunk/src/target/arm720t.c
===================================================================
--- trunk/src/target/arm720t.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm720t.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -43,8 +43,8 @@
 int arm720t_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm720t_quit(void);
 int arm720t_arch_state(struct target_s *target);
-int arm720t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int arm720t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+int arm720t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm720t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 int arm720t_soft_reset_halt(struct target_s *target);
 
 target_type_t arm720t_target =
@@ -91,8 +91,8 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	scan_field_t fields[2];
-	u8 out_buf[4];
-	u8 instruction_buf = instruction;
+	uint8_t out_buf[4];
+	uint8_t instruction_buf = instruction;
 
 	buf_set_u32(out_buf, 0, 32, flip_u32(out, 32));
 
@@ -118,9 +118,9 @@
 
 	if (in)
 	{
-		fields[1].in_value = (u8 *)in;
+		fields[1].in_value = (uint8_t *)in;
 		jtag_add_dr_scan(2, fields, jtag_get_end_state());
-		jtag_add_callback(arm7flip32, (u8 *)in);
+		jtag_add_callback(arm7flip32, (uint8_t *)in);
 	} else
 	{
 		jtag_add_dr_scan(2, fields, jtag_get_end_state());
@@ -329,7 +329,7 @@
 	return ERROR_OK;
 }
 
-int arm720t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm720t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -349,7 +349,7 @@
 	return retval;
 }
 
-int arm720t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm720t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	int retval;
 

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm7_9_common.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -373,7 +373,7 @@
 		{
 			u32 current_instr;
 			/* check that user program as not modified breakpoint instruction */
-			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, (u8*)&amp;current_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -387,7 +387,7 @@
 		{
 			u16 current_instr;
 			/* check that user program as not modified breakpoint instruction */
-			if ((retval = target_read_memory(target, breakpoint-&gt;address, 2, 1, (u8*)&amp;current_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint-&gt;address, 2, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -739,7 +739,7 @@
 int arm7_9_execute_fast_sys_speed(struct target_s *target)
 {
 	static int set=0;
-	static u8 check_value[4], check_mask[4];
+	static uint8_t check_value[4], check_mask[4];
 
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -781,7 +781,7 @@
  * @param buffer Pointer to the buffer that will hold the data
  * @return The result of receiving data from the Embedded ICE unit
  */
-int arm7_9_target_request_data(target_t *target, u32 size, u8 *buffer)
+int arm7_9_target_request_data(target_t *target, u32 size, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -2208,7 +2208,7 @@
 	return jtag_execute_queue();
 }
 
-int arm7_9_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm7_9_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -2384,7 +2384,7 @@
 	return ERROR_OK;
 }
 
-int arm7_9_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm7_9_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -2568,7 +2568,7 @@
 }
 
 static int dcc_count;
-static u8 *dcc_buffer;
+static uint8_t *dcc_buffer;
 
 static int arm7_9_dcc_completion(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info)
 {
@@ -2581,7 +2581,7 @@
 
 	int little=target-&gt;endianness==TARGET_LITTLE_ENDIAN;
 	int count=dcc_count;
-	u8 *buffer=dcc_buffer;
+	uint8_t *buffer=dcc_buffer;
 	if (count&gt;2)
 	{
 		/* Handle first &amp; last using standard embeddedice_write_reg and the middle ones w/the
@@ -2590,7 +2590,7 @@
 		buffer+=4;
 
 		embeddedice_reg_t *ice_reg = arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA].arch_info;
-		u8 reg_addr = ice_reg-&gt;addr &amp; 0x1f;
+		uint8_t reg_addr = ice_reg-&gt;addr &amp; 0x1f;
 		jtag_tap_t *tap;
 		tap = ice_reg-&gt;jtag_info-&gt;tap;
 
@@ -2623,7 +2623,7 @@
 
 int armv4_5_run_algorithm_inner(struct target_s *target, int num_mem_params, mem_param_t *mem_params, int num_reg_params, reg_param_t *reg_params, u32 entry_point, u32 exit_point, int timeout_ms, void *arch_info, int (*run_it)(struct target_s *target, u32 exit_point, int timeout_ms, void *arch_info));
 
-int arm7_9_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer)
+int arm7_9_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -2636,7 +2636,7 @@
 	/* regrab previously allocated working_area, or allocate a new one */
 	if (!arm7_9-&gt;dcc_working_area)
 	{
-		u8 dcc_code_buf[6 * 4];
+		uint8_t dcc_code_buf[6 * 4];
 
 		/* make sure we have a working area */
 		if (target_alloc_working_area(target, 24, &amp;arm7_9-&gt;dcc_working_area) != ERROR_OK)

Modified: trunk/src/target/arm7_9_common.h
===================================================================
--- trunk/src/target/arm7_9_common.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm7_9_common.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -80,7 +80,7 @@
 	void (*read_xpsr)(target_t *target, u32 *xpsr, int spsr); /**&lt; Function for reading CPSR or SPSR */
 
 	void (*write_xpsr)(target_t *target, u32 xpsr, int spsr); /**&lt; Function for writing to CPSR or SPSR */
-	void (*write_xpsr_im8)(target_t *target, u8 xpsr_im, int rot, int spsr); /**&lt; Function for writing an immediate value to CPSR or SPSR */
+	void (*write_xpsr_im8)(target_t *target, uint8_t xpsr_im, int rot, int spsr); /**&lt; Function for writing an immediate value to CPSR or SPSR */
 	void (*write_core_regs)(target_t *target, u32 mask, u32 core_regs[16]);
 
 	void (*load_word_regs)(target_t *target, u32 mask);
@@ -115,7 +115,7 @@
 
 int arm7_9_poll(target_t *target);
 
-int arm7_9_target_request_data(target_t *target, u32 size, u8 *buffer);
+int arm7_9_target_request_data(target_t *target, u32 size, uint8_t *buffer);
 
 int arm7_9_setup(target_t *target);
 int arm7_9_assert_reset(target_t *target);
@@ -131,9 +131,9 @@
 int arm7_9_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
 int arm7_9_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
 int arm7_9_read_core_reg(struct target_s *target, int num, enum armv4_5_mode mode);
-int arm7_9_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int arm7_9_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int arm7_9_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer);
+int arm7_9_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm7_9_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm7_9_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
 int arm7_9_checksum_memory(struct target_s *target, u32 address, u32 count, u32* checksum);
 int arm7_9_blank_check_memory(struct target_s *target, u32 address, u32 count, u32* blank);
 

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm7tdmi.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -95,8 +95,8 @@
 			&amp;&amp; (target-&gt;debug_reason != DBG_REASON_SINGLESTEP))
 	{
 		scan_field_t fields[2];
-		u8 databus[4];
-		u8 breakpoint;
+		uint8_t databus[4];
+		uint8_t breakpoint;
 
 		jtag_set_end_state(TAP_DRPAUSE);
 
@@ -185,11 +185,11 @@
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
-	fields[1].in_value = (u8 *)in;
+	fields[1].in_value = (uint8_t *)in;
 
 	jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
-	jtag_add_callback(arm7flip32, (u8 *)in);
+	jtag_add_callback(arm7flip32, (uint8_t *)in);
 
 	jtag_add_runtest(0, jtag_get_end_state());
 
@@ -214,7 +214,7 @@
 	return ERROR_OK;
 }
 
-void arm_endianness(u8 *tmp, void *in, int size, int be, int flip)
+void arm_endianness(uint8_t *tmp, void *in, int size, int be, int flip)
 {
 	u32 readback=le_to_h_u32(tmp);
 	if (flip)
@@ -224,30 +224,30 @@
 		case 4:
 			if (be)
 			{
-				h_u32_to_be(((u8*)in), readback);
+				h_u32_to_be(((uint8_t*)in), readback);
 			} else
 			{
-				 h_u32_to_le(((u8*)in), readback);
+				 h_u32_to_le(((uint8_t*)in), readback);
 			}
 			break;
 		case 2:
 			if (be)
 			{
-				h_u16_to_be(((u8*)in), readback &amp; 0xffff);
+				h_u16_to_be(((uint8_t*)in), readback &amp; 0xffff);
 			} else
 			{
-				h_u16_to_le(((u8*)in), readback &amp; 0xffff);
+				h_u16_to_le(((uint8_t*)in), readback &amp; 0xffff);
 			}
 			break;
 		case 1:
-			*((u8 *)in)= readback &amp; 0xff;
+			*((uint8_t *)in)= readback &amp; 0xff;
 			break;
 	}
 }
 
-static int arm7endianness(u8 *in, jtag_callback_data_t size, jtag_callback_data_t be, jtag_callback_data_t captured)
+static int arm7endianness(uint8_t *in, jtag_callback_data_t size, jtag_callback_data_t be, jtag_callback_data_t captured)
 {
-	arm_endianness((u8 *)captured, in, (int)size, (int)be, 1);
+	arm_endianness((uint8_t *)captured, in, (int)size, (int)be, 1);
 	return ERROR_OK;
 }
 
@@ -397,7 +397,7 @@
 	int be = (target-&gt;endianness == TARGET_BIG_ENDIAN) ? 1 : 0;
 	u32 *buf_u32 = buffer;
 	u16 *buf_u16 = buffer;
-	u8 *buf_u8 = buffer;
+	uint8_t *buf_u8 = buffer;
 
 	/* STMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
@@ -481,7 +481,7 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 }
 
-void arm7tdmi_write_xpsr_im8(target_t *target, u8 xpsr_im, int rot, int spsr)
+void arm7tdmi_write_xpsr_im8(target_t *target, uint8_t xpsr_im, int rot, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;

Modified: trunk/src/target/arm920t.c
===================================================================
--- trunk/src/target/arm920t.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm920t.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -48,8 +48,8 @@
 int arm920t_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm920t_quit(void);
 int arm920t_arch_state(struct target_s *target);
-int arm920t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int arm920t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+int arm920t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int arm920t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 int arm920t_soft_reset_halt(struct target_s *target);
 
 #define ARM920T_CP15_PHYS_ADDR(x, y, z) ((x &lt;&lt; 5) | (y &lt;&lt; 1) &lt;&lt; (z))
@@ -99,9 +99,9 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	scan_field_t fields[4];
-	u8 access_type_buf = 1;
-	u8 reg_addr_buf = reg_addr &amp; 0x3f;
-	u8 nr_w_buf = 0;
+	uint8_t access_type_buf = 1;
+	uint8_t reg_addr_buf = reg_addr &amp; 0x3f;
+	uint8_t nr_w_buf = 0;
 
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf);
@@ -129,11 +129,11 @@
 
 	jtag_add_dr_scan(4, fields, jtag_get_end_state());
 
-	fields[1].in_value = (u8 *)value;
+	fields[1].in_value = (uint8_t *)value;
 
 	jtag_add_dr_scan(4, fields, jtag_get_end_state());
 
-	jtag_add_callback(arm_le_to_h_u32, (u8 *)value);
+	jtag_add_callback(arm_le_to_h_u32, (uint8_t *)value);
 
 	#ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	jtag_execute_queue();
@@ -149,10 +149,10 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	scan_field_t fields[4];
-	u8 access_type_buf = 1;
-	u8 reg_addr_buf = reg_addr &amp; 0x3f;
-	u8 nr_w_buf = 1;
-	u8 value_buf[4];
+	uint8_t access_type_buf = 1;
+	uint8_t reg_addr_buf = reg_addr &amp; 0x3f;
+	uint8_t nr_w_buf = 1;
+	uint8_t value_buf[4];
 
 	buf_set_u32(value_buf, 0, 32, value);
 
@@ -196,10 +196,10 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	scan_field_t fields[4];
-	u8 access_type_buf = 0;		/* interpreted access */
-	u8 reg_addr_buf = 0x0;
-	u8 nr_w_buf = 0;
-	u8 cp15_opcode_buf[4];
+	uint8_t access_type_buf = 0;		/* interpreted access */
+	uint8_t reg_addr_buf = 0x0;
+	uint8_t nr_w_buf = 0;
+	uint8_t cp15_opcode_buf[4];
 
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf);
@@ -518,7 +518,7 @@
 	return ERROR_OK;
 }
 
-int arm920t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm920t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	int retval;
 
@@ -527,7 +527,7 @@
 	return retval;
 }
 
-int arm920t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm920t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;

Modified: trunk/src/target/arm926ejs.c
===================================================================
--- trunk/src/target/arm926ejs.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm926ejs.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -45,7 +45,7 @@
 int arm926ejs_target_create(struct target_s *target, Jim_Interp *interp);
 int arm926ejs_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm926ejs_quit(void);
-int arm926ejs_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+int arm926ejs_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 
 static int arm926ejs_virt2phys(struct target_s *target, u32 virtual, u32 *physical);
 static int arm926ejs_mmu(struct target_s *target, int *enabled);
@@ -91,15 +91,15 @@
 	.mmu = arm926ejs_mmu
 };
 
-int arm926ejs_catch_broken_irscan(u8 *captured, void *priv, scan_field_t *field)
+int arm926ejs_catch_broken_irscan(uint8_t *captured, void *priv, scan_field_t *field)
 {
 	/* FIX!!!! this code should be reenabled. For now it does not check
 	 * the queue...*/
 	return 0;
 #if 0
 	/* The ARM926EJ-S' instruction register is 4 bits wide */
-	u8 t = *captured &amp; 0xf;
-	u8 t2 = *field-&gt;in_check_value &amp; 0xf;
+	uint8_t t = *captured &amp; 0xf;
+	uint8_t t2 = *field-&gt;in_check_value &amp; 0xf;
 	if (t == t2)
 	{
 		return ERROR_OK;
@@ -123,9 +123,9 @@
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	u32 address = ARM926EJS_CP15_ADDR(op1, op2, CRn, CRm);
 	scan_field_t fields[4];
-	u8 address_buf[2];
-	u8 nr_w_buf = 0;
-	u8 access = 1;
+	uint8_t address_buf[2];
+	uint8_t nr_w_buf = 0;
+	uint8_t access = 1;
 
 	buf_set_u32(address_buf, 0, 14, address);
 
@@ -139,7 +139,7 @@
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
-	fields[0].in_value = (u8 *)value;
+	fields[0].in_value = (uint8_t *)value;
 
 
 	fields[1].tap = jtag_info-&gt;tap;
@@ -167,7 +167,7 @@
 		nr_w_buf = 0;
 		jtag_add_dr_scan(4, fields, jtag_get_end_state());
 
-		jtag_add_callback(arm_le_to_h_u32, (u8 *)value);
+		jtag_add_callback(arm_le_to_h_u32, (uint8_t *)value);
 
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
@@ -192,10 +192,10 @@
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	u32 address = ARM926EJS_CP15_ADDR(op1, op2, CRn, CRm);
 	scan_field_t fields[4];
-	u8 value_buf[4];
-	u8 address_buf[2];
-	u8 nr_w_buf = 1;
-	u8 access = 1;
+	uint8_t value_buf[4];
+	uint8_t address_buf[2];
+	uint8_t nr_w_buf = 1;
+	uint8_t access = 1;
 
 	buf_set_u32(address_buf, 0, 14, address);
 	buf_set_u32(value_buf, 0, 32, value);
@@ -625,7 +625,7 @@
 	return target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 }
 
-int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;

Modified: trunk/src/target/arm926ejs.h
===================================================================
--- trunk/src/target/arm926ejs.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm926ejs.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -41,7 +41,7 @@
 extern int arm926ejs_init_arch_info(target_t *target, arm926ejs_common_t *arm926ejs, jtag_tap_t *tap);
 extern int arm926ejs_register_commands(struct command_context_s *cmd_ctx); 
 extern int arm926ejs_arch_state(struct target_s *target); 
-extern int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer); 
+extern int arm926ejs_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer); 
 extern int arm926ejs_soft_reset_halt(struct target_s *target);
 
 #endif /* ARM926EJS_H */

Modified: trunk/src/target/arm966e.c
===================================================================
--- trunk/src/target/arm966e.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm966e.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -164,8 +164,8 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	scan_field_t fields[3];
-	u8 reg_addr_buf = reg_addr &amp; 0x3f;
-	u8 nr_w_buf = 0;
+	uint8_t reg_addr_buf = reg_addr &amp; 0x3f;
+	uint8_t nr_w_buf = 0;
 
 	jtag_set_end_state(TAP_IDLE);
 	if ((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
@@ -191,11 +191,11 @@
 
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-	fields[1].in_value = (u8 *)value;
+	fields[1].in_value = (uint8_t *)value;
 
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-	jtag_add_callback(arm_le_to_h_u32, (u8 *)value);
+	jtag_add_callback(arm_le_to_h_u32, (uint8_t *)value);
 
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
@@ -216,9 +216,9 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	scan_field_t fields[3];
-	u8 reg_addr_buf = reg_addr &amp; 0x3f;
-	u8 nr_w_buf = 1;
-	u8 value_buf[4];
+	uint8_t reg_addr_buf = reg_addr &amp; 0x3f;
+	uint8_t nr_w_buf = 1;
+	uint8_t value_buf[4];
 
 	buf_set_u32(value_buf, 0, 32, value);
 

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm9tdmi.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -107,9 +107,9 @@
 			&amp;&amp; (target-&gt;debug_reason != DBG_REASON_SINGLESTEP))
 	{
 		scan_field_t fields[3];
-		u8 databus[4];
-		u8 instructionbus[4];
-		u8 debug_reason;
+		uint8_t databus[4];
+		uint8_t instructionbus[4];
+		uint8_t debug_reason;
 
 		jtag_set_end_state(TAP_DRPAUSE);
 
@@ -166,9 +166,9 @@
 {
 	int retval = ERROR_OK;
 	scan_field_t fields[3];
-	u8 out_buf[4];
-	u8 instr_buf[4];
-	u8 sysspeed_buf = 0x0;
+	uint8_t out_buf[4];
+	uint8_t instr_buf[4];
+	uint8_t sysspeed_buf = 0x0;
 
 	/* prepare buffer */
 	buf_set_u32(out_buf, 0, 32, out);
@@ -203,10 +203,10 @@
 
 	if (in)
 	{
-		fields[0].in_value=(u8 *)in;
+		fields[0].in_value=(uint8_t *)in;
 		jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-		jtag_add_callback(arm_le_to_h_u32, (u8 *)in);
+		jtag_add_callback(arm_le_to_h_u32, (uint8_t *)in);
 	}
 	else
 	{
@@ -251,7 +251,7 @@
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
-	fields[0].in_value = (u8 *)in;
+	fields[0].in_value = (uint8_t *)in;
 
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
@@ -265,7 +265,7 @@
 
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-	jtag_add_callback(arm_le_to_h_u32, (u8 *)in);
+	jtag_add_callback(arm_le_to_h_u32, (uint8_t *)in);
 
 	jtag_add_runtest(0, jtag_get_end_state());
 
@@ -290,11 +290,11 @@
 	return ERROR_OK;
 }
 
-extern void arm_endianness(u8 *tmp, void *in, int size, int be, int flip);
+extern void arm_endianness(uint8_t *tmp, void *in, int size, int be, int flip);
 
-static int arm9endianness(u8 *in, jtag_callback_data_t size, jtag_callback_data_t be, jtag_callback_data_t captured)
+static int arm9endianness(uint8_t *in, jtag_callback_data_t size, jtag_callback_data_t be, jtag_callback_data_t captured)
 {
-	arm_endianness((u8 *)captured, in, (int)size, (int)be, 0);
+	arm_endianness((uint8_t *)captured, in, (int)size, (int)be, 0);
 	return ERROR_OK;
 }
 
@@ -448,7 +448,7 @@
 	int be = (target-&gt;endianness == TARGET_BIG_ENDIAN) ? 1 : 0;
 	u32 *buf_u32 = buffer;
 	u16 *buf_u16 = buffer;
-	u8 *buf_u8 = buffer;
+	uint8_t *buf_u8 = buffer;
 
 	/* STMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
@@ -539,7 +539,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void arm9tdmi_write_xpsr_im8(target_t *target, u8 xpsr_im, int rot, int spsr)
+void arm9tdmi_write_xpsr_im8(target_t *target, uint8_t xpsr_im, int rot, int spsr)
 {
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;

Modified: trunk/src/target/arm_adi_v5.c
===================================================================
--- trunk/src/target/arm_adi_v5.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm_adi_v5.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -70,12 +70,12 @@
  *                                                                         *
 ***************************************************************************/
 
-/* Scan out and in from target ordered u8 buffers */
-int adi_jtag_dp_scan(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u8 *outvalue, u8 *invalue, u8 *ack)
+/* Scan out and in from target ordered uint8_t buffers */
+int adi_jtag_dp_scan(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
 {
 	arm_jtag_t *jtag_info = swjdp-&gt;jtag_info;
 	scan_field_t fields[2];
-	u8 out_addr_buf;
+	uint8_t out_addr_buf;
 
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, instr, NULL);
@@ -101,12 +101,12 @@
 }
 
 /* Scan out and in from host ordered u32 variables */
-int adi_jtag_dp_scan_u32(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u32 outvalue, u32 *invalue, u8 *ack)
+int adi_jtag_dp_scan_u32(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, u32 outvalue, u32 *invalue, uint8_t *ack)
 {
 	arm_jtag_t *jtag_info = swjdp-&gt;jtag_info;
 	scan_field_t fields[2];
-	u8 out_value_buf[4];
-	u8 out_addr_buf;
+	uint8_t out_value_buf[4];
+	uint8_t out_addr_buf;
 
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, instr, NULL);
@@ -129,10 +129,10 @@
 
 	if (invalue)
 	{
-		fields[1].in_value = (u8 *)invalue;
+		fields[1].in_value = (uint8_t *)invalue;
 		jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
-		jtag_add_callback(arm_le_to_h_u32, (u8 *)invalue);
+		jtag_add_callback(arm_le_to_h_u32, (uint8_t *)invalue);
 	} else
 	{
 
@@ -143,7 +143,7 @@
 }
 
 /* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */
-int scan_inout_check(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u8 *outvalue, u8 *invalue)
+int scan_inout_check(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, uint8_t *outvalue, uint8_t *invalue)
 {
 	adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
@@ -161,7 +161,7 @@
 	return ERROR_OK;
 }
 
-int scan_inout_check_u32(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u32 outvalue, u32 *invalue)
+int scan_inout_check_u32(swjdp_common_t *swjdp, uint8_t instr, uint8_t reg_addr, uint8_t RnW, u32 outvalue, u32 *invalue)
 {
 	adi_jtag_dp_scan_u32(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
 
@@ -287,17 +287,17 @@
  *                                                                         *
 ***************************************************************************/
 
-int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, u8 reg_addr)
+int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, uint8_t reg_addr)
 {
 	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_WRITE, value, NULL);
 }
 
-int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, u8 reg_addr)
+int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, uint8_t reg_addr)
 {
 	return scan_inout_check_u32(swjdp, DAP_IR_DPACC, reg_addr, DPAP_READ, 0, value);
 }
 
-int dap_ap_select(swjdp_common_t *swjdp,u8 apsel)
+int dap_ap_select(swjdp_common_t *swjdp,uint8_t apsel)
 {
 	u32 select;
 	select = (apsel&lt;&lt;24) &amp; 0xFF000000;
@@ -328,7 +328,7 @@
 	return ERROR_OK;
 }
 
-int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, u8* out_value_buf)
+int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t* out_value_buf)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
@@ -336,7 +336,7 @@
 	return ERROR_OK;
 }
 
-int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, u8 *in_value_buf)
+int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t *in_value_buf)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, DAP_IR_APACC, reg_addr, DPAP_READ, 0, in_value_buf);
@@ -345,7 +345,7 @@
 }
 int dap_ap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value)
 {
-	u8 out_value_buf[4];
+	uint8_t out_value_buf[4];
 
 	buf_set_u32(out_value_buf, 0, 32, value);
 	dap_dp_bankselect(swjdp, reg_addr);
@@ -442,16 +442,16 @@
 
 /*****************************************************************************
 *                                                                            *
-* mem_ap_write_buf(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address) *
+* mem_ap_write_buf(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address) *
 *                                                                            *
 * Write a buffer in target order (little endian)                             *
 *                                                                            *
 *****************************************************************************/
-int mem_ap_write_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_write_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
 	u32 adr = address;
-	u8* pBuffer = buffer;
+	uint8_t* pBuffer = buffer;
 
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
 
@@ -469,7 +469,7 @@
 
 			for (i = 0; i &lt; 4; i++ )
 			{
-				*((u8*)pBuffer + (adr &amp; 0x3)) = outvalue;
+				*((uint8_t*)pBuffer + (adr &amp; 0x3)) = outvalue;
 				outvalue &gt;&gt;= 8;
 				adr++;
 			}
@@ -516,7 +516,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_packed_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_write_buf_packed_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -563,7 +563,7 @@
 
 				for (i = 0; i &lt; nbytes; i++ )
 				{
-					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
+					*((uint8_t*)buffer + (address &amp; 0x3)) = outvalue;
 					outvalue &gt;&gt;= 8;
 					address++;
 				}
@@ -587,7 +587,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_write_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	int retval = ERROR_OK;
 
@@ -612,7 +612,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_packed_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_write_buf_packed_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
@@ -655,7 +655,7 @@
 
 				for (i = 0; i &lt; nbytes; i++ )
 				{
-					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
+					*((uint8_t*)buffer + (address &amp; 0x3)) = outvalue;
 					outvalue &gt;&gt;= 8;
 					address++;
 				}
@@ -679,7 +679,7 @@
 	return retval;
 }
 
-int mem_ap_write_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_write_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	int retval = ERROR_OK;
 
@@ -704,16 +704,16 @@
 
 /*********************************************************************************
 *                                                                                *
-* mem_ap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)  *
+* mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)  *
 *                                                                                *
 * Read block fast in target order (little endian) into a buffer                  *
 *                                                                                *
 **********************************************************************************/
-int mem_ap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
 	u32 adr = address;
-	u8* pBuffer = buffer;
+	uint8_t* pBuffer = buffer;
 
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
 
@@ -772,7 +772,7 @@
 
 			for (i = 0; i &lt; 4; i++ )
 			{
-				*((u8*)pBuffer) = (data &gt;&gt; 8 * (adr &amp; 0x3));
+				*((uint8_t*)pBuffer) = (data &gt;&gt; 8 * (adr &amp; 0x3));
 				pBuffer++;
 				adr++;
 			}
@@ -782,7 +782,7 @@
 	return retval;
 }
 
-int mem_ap_read_buf_packed_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_read_buf_packed_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	u32 invalue;
 	int retval = ERROR_OK;
@@ -821,7 +821,7 @@
 
 			for (i = 0; i &lt; nbytes; i++ )
 			{
-				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
 				buffer++;
 				address++;
 			}
@@ -834,7 +834,7 @@
 	return retval;
 }
 
-int mem_ap_read_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_read_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	u32 invalue, i;
 	int retval = ERROR_OK;
@@ -853,7 +853,7 @@
 		{
 			for (i = 0; i &lt; 2; i++ )
 			{
-				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
 				buffer++;
 				address++;
 			}
@@ -877,7 +877,7 @@
  * The solution is to arrange for a large out/in scan in this loop and
  * and convert data afterwards.
  */
-int mem_ap_read_buf_packed_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_read_buf_packed_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	u32 invalue;
 	int retval = ERROR_OK;
@@ -913,7 +913,7 @@
 
 			for (i = 0; i &lt; nbytes; i++ )
 			{
-				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+				*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
 				buffer++;
 				address++;
 			}
@@ -926,7 +926,7 @@
 	return retval;
 }
 
-int mem_ap_read_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address)
+int mem_ap_read_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address)
 {
 	u32 invalue;
 	int retval = ERROR_OK;
@@ -941,7 +941,7 @@
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
 		dap_ap_read_reg_u32(swjdp, AP_REG_DRW, &amp;invalue );
 		retval = swjdp_transaction_endcheck(swjdp);
-		*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
+		*((uint8_t*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
 		count--;
 		address++;
 		buffer++;
@@ -1018,7 +1018,7 @@
 
 	u32 dbgbase,apid;
 	int romtable_present = 0;
-	u8 mem_ap;
+	uint8_t mem_ap;
 	u32 apselold;
 
 	apselold = swjdp-&gt;apsel;

Modified: trunk/src/target/arm_adi_v5.h
===================================================================
--- trunk/src/target/arm_adi_v5.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm_adi_v5.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -94,9 +94,9 @@
 	u32 ap_csw_value;
 	u32 ap_tar_value;
 	/* information about current pending SWjDP-AHBAP transaction */
-	u8  trans_mode;
-	u8  trans_rw;
-	u8  ack;
+	uint8_t  trans_mode;
+	uint8_t  trans_rw;
+	uint8_t  ack;
 	/* extra tck clocks for memory bus access */
 	u32	memaccess_tck;
 	/* Size of TAR autoincrement block, ARM ADI Specification requires at least 10 bits */
@@ -105,22 +105,22 @@
 } swjdp_common_t;
 
 /* Accessor function for currently selected DAP-AP number */ 
-static inline u8 dap_ap_get_select(swjdp_common_t *swjdp)
+static inline uint8_t dap_ap_get_select(swjdp_common_t *swjdp)
 {
-	return (u8)( swjdp -&gt;apsel &gt;&gt; 24);
+	return (uint8_t)( swjdp -&gt;apsel &gt;&gt; 24);
 }
 
 /* Internal functions used in the module, partial transactions, use with caution */
-extern int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, u8 reg_addr);
-/* extern int swjdp_write_apacc(swjdp_common_t *swjdp, u32 value, u8 reg_addr); */
-extern int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, u8 reg_addr);
-/* extern int swjdp_read_apacc(swjdp_common_t *swjdp, u32 *value, u8 reg_addr); */
+extern int dap_dp_write_reg(swjdp_common_t *swjdp, u32 value, uint8_t reg_addr);
+/* extern int swjdp_write_apacc(swjdp_common_t *swjdp, u32 value, uint8_t reg_addr); */
+extern int dap_dp_read_reg(swjdp_common_t *swjdp, u32 *value, uint8_t reg_addr);
+/* extern int swjdp_read_apacc(swjdp_common_t *swjdp, u32 *value, uint8_t reg_addr); */
 extern int dap_setup_accessport(swjdp_common_t *swjdp, u32 csw, u32 tar);
-extern int dap_ap_select(swjdp_common_t *swjdp,u8 apsel);
+extern int dap_ap_select(swjdp_common_t *swjdp,uint8_t apsel);
 
-extern int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, u8* out_value_buf);
+extern int dap_ap_write_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t* out_value_buf);
 extern int dap_ap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value);
-extern int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, u8 *in_value_buf);
+extern int dap_ap_read_reg(swjdp_common_t *swjdp, u32 reg_addr, uint8_t *in_value_buf);
 extern int dap_ap_read_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 *value);
 
 /* External interface, partial operations must be completed with swjdp_transaction_endcheck() */
@@ -135,12 +135,12 @@
 extern int mem_ap_write_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value);
 
 /* MEM-AP memory mapped bus block transfers */
-extern int mem_ap_read_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int mem_ap_read_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int mem_ap_read_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int mem_ap_write_buf_u8(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int mem_ap_write_buf_u16(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
-extern int mem_ap_write_buf_u32(swjdp_common_t *swjdp, u8 *buffer, int count, u32 address);
+extern int mem_ap_read_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
+extern int mem_ap_read_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
+extern int mem_ap_read_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
+extern int mem_ap_write_buf_u8(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
+extern int mem_ap_write_buf_u16(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
+extern int mem_ap_write_buf_u32(swjdp_common_t *swjdp, uint8_t *buffer, int count, u32 address);
 
 /* Initialisation of the debug system, power domains and registers */
 extern int ahbap_debugport_init(swjdp_common_t *swjdp);

Modified: trunk/src/target/arm_disassembler.c
===================================================================
--- trunk/src/target/arm_disassembler.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm_disassembler.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -102,7 +102,7 @@
 
 int evaluate_b_bl(u32 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 L;
+	uint8_t L;
 	u32 immediate;
 	int offset;
 	u32 target_address;
@@ -139,12 +139,12 @@
 /* both normal and extended instruction space (condition field b1111) */
 int evaluate_ldc_stc_mcrr_mrrc(u32 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 cp_num = (opcode &amp; 0xf00) &gt;&gt; 8;
+	uint8_t cp_num = (opcode &amp; 0xf00) &gt;&gt; 8;
 	
 	/* MCRR or MRRC */
 	if (((opcode &amp; 0x0ff00000) == 0x0c400000) || ((opcode &amp; 0x0ff00000) == 0x0c400000))
 	{
-		u8 cp_opcode, Rd, Rn, CRm;
+		uint8_t cp_opcode, Rd, Rn, CRm;
 		char *mnemonic;
 		
 		cp_opcode = (opcode &amp; 0xf0) &gt;&gt; 4;
@@ -171,8 +171,8 @@
 	}
 	else /* LDC or STC */
 	{
-		u8 CRd, Rn, offset;
-		u8 U, N;
+		uint8_t CRd, Rn, offset;
+		uint8_t U, N;
 		char *mnemonic;
 		char addressing_mode[32];
 		
@@ -221,7 +221,7 @@
 {
 	char* cond;
 	char* mnemonic;
-	u8 cp_num, opcode_1, CRd_Rd, CRn, CRm, opcode_2;
+	uint8_t cp_num, opcode_1, CRd_Rd, CRn, CRm, opcode_2;
 	
 	cond = ((opcode &amp; 0xf0000000) == 0xf0000000) ? &quot;2&quot; : COND(opcode);
 	cp_num = (opcode &amp; 0xf00) &gt;&gt; 8;
@@ -268,8 +268,8 @@
 /* Load/store instructions */
 int evaluate_load_store(u32 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 I, P, U, B, W, L;
-	u8 Rn, Rd;
+	uint8_t I, P, U, B, W, L;
+	uint8_t Rn, Rd;
 	char *operation; /* &quot;LDR&quot; or &quot;STR&quot; */
 	char *suffix; /* &quot;&quot;, &quot;B&quot;, &quot;T&quot;, &quot;BT&quot; */
 	char offset[32];
@@ -351,8 +351,8 @@
 	}
 	else /* either +-&lt;Rm&gt; or +-&lt;Rm&gt;, &lt;shift&gt;, #&lt;shift_imm&gt; */
 	{
-		u8 shift_imm, shift;
-		u8 Rm;
+		uint8_t shift_imm, shift;
+		uint8_t Rm;
 		
 		shift_imm = (opcode &amp; 0xf80) &gt;&gt; 7;
 		shift = (opcode &amp; 0x60) &gt;&gt; 5;
@@ -436,8 +436,8 @@
 /* Miscellaneous load/store instructions */
 int evaluate_misc_load_store(u32 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 P, U, I, W, L, S, H;
-	u8 Rn, Rd;
+	uint8_t P, U, I, W, L, S, H;
+	uint8_t Rn, Rd;
 	char *operation; /* &quot;LDR&quot; or &quot;STR&quot; */
 	char *suffix; /* &quot;H&quot;, &quot;SB&quot;, &quot;SH&quot;, &quot;D&quot; */
 	char offset[32];
@@ -519,7 +519,7 @@
 	}
 	else /* Register offset/index (+-&lt;Rm&gt;) */
 	{
-		u8 Rm;
+		uint8_t Rm;
 		Rm = (opcode &amp; 0xf);
 		snprintf(offset, 32, &quot;%sr%i&quot;, (U) ? &quot;&quot; : &quot;-&quot;, Rm);
 		
@@ -563,7 +563,7 @@
 /* Load/store multiples instructions */
 int evaluate_ldm_stm(u32 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 P, U, S, W, L, Rn;
+	uint8_t P, U, S, W, L, Rn;
 	u32 register_list;
 	char *addressing_mode;
 	char *mnemonic;
@@ -656,7 +656,7 @@
 		/* Multiply (accumulate) */
 		if ((opcode &amp; 0x0f800000) == 0x00000000)
 		{
-			u8 Rm, Rs, Rn, Rd, S;
+			uint8_t Rm, Rs, Rn, Rd, S;
 			Rm = opcode &amp; 0xf;
 			Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
 			Rn = (opcode &amp; 0xf000) &gt;&gt; 12;
@@ -684,7 +684,7 @@
 		if ((opcode &amp; 0x0f800000) == 0x00800000)
 		{
 			char* mnemonic = NULL;
-			u8 Rm, Rs, RdHi, RdLow, S;
+			uint8_t Rm, Rs, RdHi, RdLow, S;
 			Rm = opcode &amp; 0xf;
 			Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
 			RdHi = (opcode &amp; 0xf000) &gt;&gt; 12;
@@ -721,7 +721,7 @@
 		/* Swap/swap byte */
 		if ((opcode &amp; 0x0f800000) == 0x01000000)
 		{
-			u8 Rm, Rd, Rn;
+			uint8_t Rm, Rd, Rn;
 			Rm = opcode &amp; 0xf;
 			Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
 			Rn = (opcode &amp; 0xf0000) &gt;&gt; 16;
@@ -752,8 +752,8 @@
 		/* immediate variant */
 		if (opcode &amp; 0x02000000)
 		{
-			u8 immediate = (opcode &amp; 0xff);
-			u8 rotate = (opcode &amp; 0xf00);
+			uint8_t immediate = (opcode &amp; 0xff);
+			uint8_t rotate = (opcode &amp; 0xf00);
 			
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8x\t0x%8.8x\tMSR%s %s_%s%s%s%s, 0x%8.8x&quot;,
 					 address, opcode, COND(opcode), PSR,
@@ -766,7 +766,7 @@
 		}
 		else /* register variant */
 		{
-			u8 Rm = opcode &amp; 0xf;
+			uint8_t Rm = opcode &amp; 0xf;
 			snprintf(instruction-&gt;text, 128, &quot;0x%8.8x\t0x%8.8x\tMSR%s %s_%s%s%s%s, r%i&quot;,
 					 address, opcode, COND(opcode), PSR,
 					 (opcode &amp; 0x10000) ? &quot;c&quot; : &quot;&quot;,
@@ -780,7 +780,7 @@
 	}
 	else /* Move status register to register (MRS) */
 	{
-		u8 Rd;
+		uint8_t Rd;
 		
 		instruction-&gt;type = ARM_MRS;
 		Rd = (opcode &amp; 0x0000f000) &gt;&gt; 12;
@@ -804,7 +804,7 @@
 	/* BX */
 	if ((opcode &amp; 0x006000f0) == 0x00200010)
 	{
-		u8 Rm;
+		uint8_t Rm;
 		instruction-&gt;type = ARM_BX;
 		Rm = opcode &amp; 0xf;
 		
@@ -818,7 +818,7 @@
 	/* CLZ */
 	if ((opcode &amp; 0x006000f0) == 0x00600010)
 	{
-		u8 Rm, Rd;
+		uint8_t Rm, Rd;
 		instruction-&gt;type = ARM_CLZ;
 		Rm = opcode &amp; 0xf;
 		Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
@@ -830,7 +830,7 @@
 	/* BLX(2) */
 	if ((opcode &amp; 0x006000f0) == 0x00200030)
 	{
-		u8 Rm;
+		uint8_t Rm;
 		instruction-&gt;type = ARM_BLX;
 		Rm = opcode &amp; 0xf;
 		
@@ -844,7 +844,7 @@
 	/* Enhanced DSP add/subtracts */
 	if ((opcode &amp; 0x0000000f0) == 0x00000050)
 	{
-		u8 Rm, Rd, Rn;
+		uint8_t Rm, Rd, Rn;
 		char *mnemonic = NULL;
 		Rm = opcode &amp; 0xf;
 		Rd = (opcode &amp; 0xf000) &gt;&gt; 12;
@@ -894,7 +894,7 @@
 		/* SMLA&lt;x&gt;&lt;y&gt; */
 		if ((opcode &amp; 0x00600000) == 0x00000000)
 		{
-			u8 Rd, Rm, Rs, Rn;
+			uint8_t Rd, Rm, Rs, Rn;
 			instruction-&gt;type = ARM_SMLAxy;
 			Rd = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			Rm = (opcode &amp; 0xf);
@@ -909,7 +909,7 @@
 		/* SMLAL&lt;x&gt;&lt;y&gt; */
 		if ((opcode &amp; 0x00600000) == 0x00400000)
 		{
-			u8 RdLow, RdHi, Rm, Rs;
+			uint8_t RdLow, RdHi, Rm, Rs;
 			instruction-&gt;type = ARM_SMLAxy;
 			RdHi = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			RdLow = (opcode &amp; 0xf000) &gt;&gt; 12;
@@ -924,7 +924,7 @@
 		/* SMLAW&lt;y&gt; */
 		if (((opcode &amp; 0x00600000) == 0x00100000) &amp;&amp; (x == 0))
 		{
-			u8 Rd, Rm, Rs, Rn;
+			uint8_t Rd, Rm, Rs, Rn;
 			instruction-&gt;type = ARM_SMLAWy;
 			Rd = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			Rm = (opcode &amp; 0xf);
@@ -939,7 +939,7 @@
 		/* SMUL&lt;x&gt;&lt;y&gt; */
 		if ((opcode &amp; 0x00600000) == 0x00300000)
 		{
-			u8 Rd, Rm, Rs;
+			uint8_t Rd, Rm, Rs;
 			instruction-&gt;type = ARM_SMULxy;
 			Rd = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			Rm = (opcode &amp; 0xf);
@@ -953,7 +953,7 @@
 		/* SMULW&lt;y&gt; */
 		if (((opcode &amp; 0x00600000) == 0x00100000) &amp;&amp; (x == 1))
 		{
-			u8 Rd, Rm, Rs;
+			uint8_t Rd, Rm, Rs;
 			instruction-&gt;type = ARM_SMULWy;
 			Rd = (opcode &amp; 0xf0000) &gt;&gt; 16;
 			Rm = (opcode &amp; 0xf);
@@ -970,7 +970,7 @@
 
 int evaluate_data_proc(u32 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 I, op, S, Rn, Rd;
+	uint8_t I, op, S, Rn, Rd;
 	char *mnemonic = NULL;
 	char shifter_operand[32];
 	
@@ -1055,8 +1055,8 @@
 	
 	if (I) /* immediate shifter operand (#&lt;immediate&gt;)*/
 	{
-		u8 immed_8 = opcode &amp; 0xff;
-		u8 rotate_imm = (opcode &amp; 0xf00) &gt;&gt; 8;
+		uint8_t immed_8 = opcode &amp; 0xff;
+		uint8_t rotate_imm = (opcode &amp; 0xf00) &gt;&gt; 8;
 		u32 immediate;
 		
 		immediate = ror(immed_8, rotate_imm * 2);
@@ -1068,13 +1068,13 @@
 	}
 	else /* register-based shifter operand */
 	{
-		u8 shift, Rm;
+		uint8_t shift, Rm;
 		shift = (opcode &amp; 0x60) &gt;&gt; 5;
 		Rm = (opcode &amp; 0xf);
 		
 		if ((opcode &amp; 0x10) != 0x10) /* Immediate shifts (&quot;&lt;Rm&gt;&quot; or &quot;&lt;Rm&gt;, &lt;shift&gt; #&lt;shift_immediate&gt;&quot;) */
 		{
-			u8 shift_imm;
+			uint8_t shift_imm;
 			shift_imm = (opcode &amp; 0xf80) &gt;&gt; 7;
 
 			instruction-&gt;info.data_proc.variant = 1;
@@ -1124,7 +1124,7 @@
 		}
 		else /* Register shifts (&quot;&lt;Rm&gt;, &lt;shift&gt; &lt;Rs&gt;&quot;) */
 		{
-			u8 Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
+			uint8_t Rs = (opcode &amp; 0xf00) &gt;&gt; 8;
 			
 			instruction-&gt;info.data_proc.variant = 2;
 			instruction-&gt;info.data_proc.shifter_operand.register_shift.Rm = Rm;
@@ -1368,9 +1368,9 @@
 
 int evaluate_add_sub_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 Rd = (opcode &gt;&gt; 0) &amp; 0x7;
-	u8 Rn = (opcode &gt;&gt; 3) &amp; 0x7;
-	u8 Rm_imm = (opcode &gt;&gt; 6) &amp; 0x7;
+	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7;
+	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7;
+	uint8_t Rm_imm = (opcode &gt;&gt; 6) &amp; 0x7;
 	u32 opc = opcode &amp; (1&lt;&lt;9);
 	u32 reg_imm  = opcode &amp; (1&lt;&lt;10);
 	char *mnemonic;
@@ -1410,10 +1410,10 @@
 
 int evaluate_shift_imm_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 Rd = (opcode &gt;&gt; 0) &amp; 0x7;
-	u8 Rm = (opcode &gt;&gt; 3) &amp; 0x7;
-	u8 imm = (opcode &gt;&gt; 6) &amp; 0x1f;
-	u8 opc = (opcode &gt;&gt; 11) &amp; 0x3;
+	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7;
+	uint8_t Rm = (opcode &gt;&gt; 3) &amp; 0x7;
+	uint8_t imm = (opcode &gt;&gt; 6) &amp; 0x1f;
+	uint8_t opc = (opcode &gt;&gt; 11) &amp; 0x3;
 	char *mnemonic = NULL;
 	
 	switch(opc)
@@ -1454,8 +1454,8 @@
 
 int evaluate_data_proc_imm_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 imm = opcode &amp; 0xff;
-	u8 Rd = (opcode &gt;&gt; 8) &amp; 0x7;
+	uint8_t imm = opcode &amp; 0xff;
+	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7;
 	u32 opc = (opcode &gt;&gt; 11) &amp; 0x3;
 	char *mnemonic = NULL;
 	
@@ -1495,7 +1495,7 @@
 
 int evaluate_data_proc_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 high_reg, op, Rm, Rd,H1,H2;
+	uint8_t high_reg, op, Rm, Rd,H1,H2;
 	char *mnemonic = NULL;
 	
 	high_reg = (opcode &amp; 0x0400) &gt;&gt; 10;
@@ -1655,7 +1655,7 @@
 int evaluate_load_literal_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
 	u32 immediate;
-	u8 Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
 
 	instruction-&gt;type = ARM_LDR;
 	immediate = opcode &amp; 0x000000ff;
@@ -1673,10 +1673,10 @@
 
 int evaluate_load_store_reg_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
-	u8 Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
-	u8 Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
-	u8 Rm = (opcode &gt;&gt; 6) &amp; 0x7; 
-	u8 opc = (opcode &gt;&gt; 9) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
+	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
+	uint8_t Rm = (opcode &gt;&gt; 6) &amp; 0x7; 
+	uint8_t opc = (opcode &gt;&gt; 9) &amp; 0x7; 
 	char *mnemonic = NULL;
 
 	switch(opc)
@@ -1729,8 +1729,8 @@
 int evaluate_load_store_imm_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
 	u32 offset = (opcode &gt;&gt; 6) &amp; 0x1f;
-	u8 Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
-	u8 Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 0) &amp; 0x7; 
+	uint8_t Rn = (opcode &gt;&gt; 3) &amp; 0x7; 
 	u32 L = opcode &amp; (1&lt;&lt;11);
 	u32 B = opcode &amp; (1&lt;&lt;12);
 	char *mnemonic;
@@ -1773,7 +1773,7 @@
 int evaluate_load_store_stack_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
 	u32 offset = opcode  &amp; 0xff;
-	u8 Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
+	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
 	u32 L = opcode &amp; (1&lt;&lt;11);
 	char *mnemonic;
 
@@ -1802,8 +1802,8 @@
 int evaluate_add_sp_pc_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
 	u32 imm = opcode  &amp; 0xff;
-	u8 Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
-	u8 Rn;
+	uint8_t Rd = (opcode &gt;&gt; 8) &amp; 0x7; 
+	uint8_t Rn;
 	u32 SP = opcode &amp; (1&lt;&lt;11);
 	char *reg_name;
 
@@ -1833,7 +1833,7 @@
 int evaluate_adjust_stack_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
 	u32 imm = opcode  &amp; 0x7f;
-	u8 opc = opcode &amp; (1&lt;&lt;7);
+	uint8_t opc = opcode &amp; (1&lt;&lt;7);
 	char *mnemonic;
 
 	
@@ -1874,8 +1874,8 @@
 	u32 reg_list = opcode  &amp; 0xff;
 	u32 L = opcode &amp; (1&lt;&lt;11);
 	u32 R = opcode &amp; (1&lt;&lt;8);
-	u8 Rn = (opcode &gt;&gt; 8) &amp; 7;
-	u8 addr_mode = 0 /* IA */;
+	uint8_t Rn = (opcode &gt;&gt; 8) &amp; 7;
+	uint8_t addr_mode = 0 /* IA */;
 	char reg_names[40];
 	char *reg_names_p;
 	char *mnemonic;
@@ -1939,7 +1939,7 @@
 int evaluate_cond_branch_thumb(u16 opcode, u32 address, arm_instruction_t *instruction)
 {
 	u32 offset = opcode  &amp; 0xff;
-	u8 cond = (opcode &gt;&gt; 8) &amp; 0xf;
+	uint8_t cond = (opcode &gt;&gt; 8) &amp; 0xf;
 	u32 target_address;
 
 	if (cond == 0xf)

Modified: trunk/src/target/arm_disassembler.h
===================================================================
--- trunk/src/target/arm_disassembler.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm_disassembler.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -132,51 +132,51 @@
 		u32 immediate;
 	} immediate;
 	struct {
-		u8 Rm;
-		u8 shift; /* 0: LSL, 1: LSR, 2: ASR, 3: ROR, 4: RRX */
-		u8 shift_imm;
+		uint8_t Rm;
+		uint8_t shift; /* 0: LSL, 1: LSR, 2: ASR, 3: ROR, 4: RRX */
+		uint8_t shift_imm;
 	} immediate_shift;
 	struct {
-		u8 Rm;
-		u8 shift;
-		u8 Rs;
+		uint8_t Rm;
+		uint8_t shift;
+		uint8_t Rs;
 	} register_shift;
 };
 
 typedef struct arm_data_proc_instr_s
 {
 	int variant; /* 0: immediate, 1: immediate_shift, 2: register_shift */
-	u8 S;
-	u8 Rn;
-	u8 Rd;
+	uint8_t S;
+	uint8_t Rn;
+	uint8_t Rd;
 	union arm_shifter_operand shifter_operand;
 } arm_data_proc_instr_t;
 
 typedef struct arm_load_store_instr_s
 {
-	u8 Rd;
-	u8 Rn;
-	u8 U;
+	uint8_t Rd;
+	uint8_t Rn;
+	uint8_t U;
 	int index_mode; /* 0: offset, 1: pre-indexed, 2: post-indexed */
 	int offset_mode; /* 0: immediate, 1: (scaled) register */
 	union
 	{
 		u32 offset;
 		struct {
-			u8 Rm;
-			u8 shift; /* 0: LSL, 1: LSR, 2: ASR, 3: ROR, 4: RRX */
-			u8 shift_imm;
+			uint8_t Rm;
+			uint8_t shift; /* 0: LSL, 1: LSR, 2: ASR, 3: ROR, 4: RRX */
+			uint8_t shift_imm;
 		} reg;
 	} offset;
 } arm_load_store_instr_t;
 
 typedef struct arm_load_store_multiple_instr_s
 {
-	u8 Rn;
+	uint8_t Rn;
 	u32 register_list;
-	u8 addressing_mode; /* 0: IA, 1: IB, 2: DA, 3: DB */
-	u8 S;
-	u8 W;
+	uint8_t addressing_mode; /* 0: IA, 1: IB, 2: DA, 3: DB */
+	uint8_t S;
+	uint8_t W;
 } arm_load_store_multiple_instr_t;
 
 typedef struct arm_instruction_s

Modified: trunk/src/target/arm_jtag.c
===================================================================
--- trunk/src/target/arm_jtag.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm_jtag.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -41,7 +41,7 @@
 	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != new_instr)
 	{
 		scan_field_t field;
-		u8 t[4];
+		uint8_t t[4];
 
 		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
@@ -116,7 +116,7 @@
 }
 
 /* read JTAG buffer into host-endian u32, flipping bit-order */
-int arm_jtag_buf_to_u32_flip(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_u32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
 	u32 *dest = priv;
 	*dest = flip_u32(le_to_h_u32(in_buf), 32);
@@ -124,44 +124,44 @@
 }
 
 /* read JTAG buffer into little-endian u32, flipping bit-order */
-int arm_jtag_buf_to_le32_flip(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_le32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u32_to_le(((u8*)priv), flip_u32(le_to_h_u32(in_buf), 32));
+	h_u32_to_le(((uint8_t*)priv), flip_u32(le_to_h_u32(in_buf), 32));
 	return ERROR_OK;
 }
 
 /* read JTAG buffer into little-endian u16, flipping bit-order */
-int arm_jtag_buf_to_le16_flip(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_le16_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u16_to_le(((u8*)priv), flip_u32(le_to_h_u32(in_buf), 32) &amp; 0xffff);
+	h_u16_to_le(((uint8_t*)priv), flip_u32(le_to_h_u32(in_buf), 32) &amp; 0xffff);
 	return ERROR_OK;
 }
 
 /* read JTAG buffer into big-endian u32, flipping bit-order */
-int arm_jtag_buf_to_be32_flip(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_be32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u32_to_be(((u8*)priv), flip_u32(le_to_h_u32(in_buf), 32));
+	h_u32_to_be(((uint8_t*)priv), flip_u32(le_to_h_u32(in_buf), 32));
 	return ERROR_OK;
 }
 
 /* read JTAG buffer into big-endian u16, flipping bit-order */
-int arm_jtag_buf_to_be16_flip(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_be16_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u16_to_be(((u8*)priv), flip_u32(le_to_h_u32(in_buf), 32) &amp; 0xffff);
+	h_u16_to_be(((uint8_t*)priv), flip_u32(le_to_h_u32(in_buf), 32) &amp; 0xffff);
 	return ERROR_OK;
 }
 
-/* read JTAG buffer into u8, flipping bit-order */
-int arm_jtag_buf_to_8_flip(u8 *in_buf, void *priv, struct scan_field_s *field)
+/* read JTAG buffer into uint8_t, flipping bit-order */
+int arm_jtag_buf_to_8_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	u8 *dest = priv;
+	uint8_t *dest = priv;
 	*dest = flip_u32(le_to_h_u32(in_buf), 32) &amp; 0xff;
 	return ERROR_OK;
 }
 
 /* not-flipping variants */
 /* read JTAG buffer into host-endian u32 */
-int arm_jtag_buf_to_u32(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_u32(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
 	u32 *dest = priv;
 	*dest = le_to_h_u32(in_buf);
@@ -169,37 +169,37 @@
 }
 
 /* read JTAG buffer into little-endian u32 */
-int arm_jtag_buf_to_le32(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_le32(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u32_to_le(((u8*)priv), le_to_h_u32(in_buf));
+	h_u32_to_le(((uint8_t*)priv), le_to_h_u32(in_buf));
 	return ERROR_OK;
 }
 
 /* read JTAG buffer into little-endian u16 */
-int arm_jtag_buf_to_le16(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_le16(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u16_to_le(((u8*)priv), le_to_h_u32(in_buf) &amp; 0xffff);
+	h_u16_to_le(((uint8_t*)priv), le_to_h_u32(in_buf) &amp; 0xffff);
 	return ERROR_OK;
 }
 
 /* read JTAG buffer into big-endian u32 */
-int arm_jtag_buf_to_be32(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_be32(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u32_to_be(((u8*)priv), le_to_h_u32(in_buf));
+	h_u32_to_be(((uint8_t*)priv), le_to_h_u32(in_buf));
 	return ERROR_OK;
 }
 
 /* read JTAG buffer into big-endian u16 */
-int arm_jtag_buf_to_be16(u8 *in_buf, void *priv, struct scan_field_s *field)
+int arm_jtag_buf_to_be16(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	h_u16_to_be(((u8*)priv), le_to_h_u32(in_buf) &amp; 0xffff);
+	h_u16_to_be(((uint8_t*)priv), le_to_h_u32(in_buf) &amp; 0xffff);
 	return ERROR_OK;
 }
 
-/* read JTAG buffer into u8 */
-int arm_jtag_buf_to_8(u8 *in_buf, void *priv, struct scan_field_s *field)
+/* read JTAG buffer into uint8_t */
+int arm_jtag_buf_to_8(uint8_t *in_buf, void *priv, struct scan_field_s *field)
 {
-	u8 *dest = priv;
+	uint8_t *dest = priv;
 	*dest = le_to_h_u32(in_buf) &amp; 0xff;
 	return ERROR_OK;
 }

Modified: trunk/src/target/arm_jtag.h
===================================================================
--- trunk/src/target/arm_jtag.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm_jtag.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -41,29 +41,29 @@
 extern int arm_jtag_setup_connection(arm_jtag_t *jtag_info);
 
 /* JTAG buffers to host, be and le buffers, flipping variants */
-int arm_jtag_buf_to_u32_flip(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_le32_flip(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_le16_flip(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_be32_flip(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_be16_flip(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_8_flip(u8 *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_u32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_le32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_le16_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_be32_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_be16_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_8_flip(uint8_t *in_buf, void *priv, struct scan_field_s *field);
 
 /* JTAG buffers to host, be and le buffers */
-int arm_jtag_buf_to_u32(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_le32(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_le16(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_be32(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_be16(u8 *in_buf, void *priv, struct scan_field_s *field);
-int arm_jtag_buf_to_8(u8 *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_u32(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_le32(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_le16(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_be32(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_be16(uint8_t *in_buf, void *priv, struct scan_field_s *field);
+int arm_jtag_buf_to_8(uint8_t *in_buf, void *priv, struct scan_field_s *field);
 
 
 /* use this as a static so we can inline it in -O3 and refer to it via a pointer  */
-static __inline__ void arm7flip32(u8 *in)
+static __inline__ void arm7flip32(uint8_t *in)
 {
 	*((u32 *)in)=flip_u32(le_to_h_u32(in), 32);
 }
 
-static __inline__ void arm_le_to_h_u32(u8 *in)
+static __inline__ void arm_le_to_h_u32(uint8_t *in)
 {
 	*((u32 *)in)=le_to_h_u32(in);
 }

Modified: trunk/src/target/arm_simulator.c
===================================================================
--- trunk/src/target/arm_simulator.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/arm_simulator.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -31,7 +31,7 @@
 #include &quot;binarybuffer.h&quot;
 
 
-u32 arm_shift(u8 shift, u32 Rm, u32 shift_amount, u8 *carry)
+u32 arm_shift(uint8_t shift, u32 Rm, u32 shift_amount, uint8_t *carry)
 {
 	u32 return_value = 0;
 	shift_amount &amp;= 0xff;
@@ -122,7 +122,7 @@
 	return return_value;
 }
 
-u32 arm_shifter_operand(armv4_5_common_t *armv4_5, int variant, union arm_shifter_operand shifter_operand, u8 *shifter_carry_out)
+u32 arm_shifter_operand(armv4_5_common_t *armv4_5, int variant, union arm_shifter_operand shifter_operand, uint8_t *shifter_carry_out)
 {
 	u32 return_value;
 	int instruction_size;
@@ -409,8 +409,8 @@
 			|| ((instruction.type &gt;= ARM_ORR) &amp;&amp; (instruction.type &lt;= ARM_MVN)))
 	{
 		u32 Rd, Rn, shifter_operand;
-		u8 C = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
-		u8 carry_out;
+		uint8_t C = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
+		uint8_t carry_out;
 		
 		Rd = 0x0;
 		/* ARM_MOV and ARM_MVN does not use Rn */
@@ -509,9 +509,9 @@
 		{
 			u32 offset;
 			u32 Rm = buf_get_u32(ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, instruction.info.load_store.offset.reg.Rm).value, 0, 32);
-			u8 shift = instruction.info.load_store.offset.reg.shift;
-			u8 shift_imm = instruction.info.load_store.offset.reg.shift_imm;
-			u8 carry = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
+			uint8_t shift = instruction.info.load_store.offset.reg.shift;
+			uint8_t shift_imm = instruction.info.load_store.offset.reg.shift_imm;
+			uint8_t carry = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 29, 1);
 			
 			offset = arm_shift(shift, Rm, shift_imm, &amp;carry);
 			

Modified: trunk/src/target/armv4_5.c
===================================================================
--- trunk/src/target/armv4_5.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/armv4_5.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -153,14 +153,14 @@
 	}
 };
 
-u8 armv4_5_gdb_dummy_fp_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+uint8_t armv4_5_gdb_dummy_fp_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
 reg_t armv4_5_gdb_dummy_fp_reg =
 {
 	&quot;GDB dummy floating-point register&quot;, armv4_5_gdb_dummy_fp_value, 0, 1, 96, NULL, 0, NULL, 0
 };
 
-u8 armv4_5_gdb_dummy_fps_value[] = {0, 0, 0, 0};
+uint8_t armv4_5_gdb_dummy_fps_value[] = {0, 0, 0, 0};
 
 reg_t armv4_5_gdb_dummy_fps_reg =
 {
@@ -185,7 +185,7 @@
 	return retval;
 }
 
-int armv4_5_set_core_reg(reg_t *reg, u8 *buf)
+int armv4_5_set_core_reg(reg_t *reg, uint8_t *buf)
 {
 	armv4_5_core_reg_t *armv4_5 = reg-&gt;arch_info;
 	target_t *target = armv4_5-&gt;target;

Modified: trunk/src/target/armv4_5_mmu.c
===================================================================
--- trunk/src/target/armv4_5_mmu.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/armv4_5_mmu.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -40,8 +40,8 @@
 
 	armv4_5_mmu_read_physical(target, armv4_5_mmu,
 		(ttb &amp; 0xffffc000) | ((va &amp; 0xfff00000) &gt;&gt; 18),
-		4, 1, (u8*)&amp;first_lvl_descriptor);
-	first_lvl_descriptor = target_buffer_get_u32(target, (u8*)&amp;first_lvl_descriptor);
+		4, 1, (uint8_t*)&amp;first_lvl_descriptor);
+	first_lvl_descriptor = target_buffer_get_u32(target, (uint8_t*)&amp;first_lvl_descriptor);
 
 	LOG_DEBUG(&quot;1st lvl desc: %8.8x&quot;, first_lvl_descriptor);
 
@@ -76,17 +76,17 @@
 		/* coarse page table */
 		armv4_5_mmu_read_physical(target, armv4_5_mmu,
 			(first_lvl_descriptor &amp; 0xfffffc00) | ((va &amp; 0x000ff000) &gt;&gt; 10),
-			4, 1, (u8*)&amp;second_lvl_descriptor);
+			4, 1, (uint8_t*)&amp;second_lvl_descriptor);
 	}
 	else if ((first_lvl_descriptor &amp; 0x3) == 3)
 	{
 		/* fine page table */
 		armv4_5_mmu_read_physical(target, armv4_5_mmu,
 			(first_lvl_descriptor &amp; 0xfffff000) | ((va &amp; 0x000ffc00) &gt;&gt; 8),
-			4, 1, (u8*)&amp;second_lvl_descriptor);
+			4, 1, (uint8_t*)&amp;second_lvl_descriptor);
 	}
 
-	second_lvl_descriptor = target_buffer_get_u32(target, (u8*)&amp;second_lvl_descriptor);
+	second_lvl_descriptor = target_buffer_get_u32(target, (uint8_t*)&amp;second_lvl_descriptor);
 
 	LOG_DEBUG(&quot;2nd lvl desc: %8.8x&quot;, second_lvl_descriptor);
 
@@ -130,7 +130,7 @@
 	return ERROR_TARGET_TRANSLATION_FAULT;
 }
 
-int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, u8 *buffer)
+int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	int retval;
 
@@ -150,7 +150,7 @@
 	return retval;
 }
 
-int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, u8 *buffer)
+int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	int retval;
 
@@ -227,7 +227,7 @@
 
 	int retval;
 
-	u8 *buffer;
+	uint8_t *buffer;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -314,7 +314,7 @@
 	u32 address = 0;
 	u32 value = 0;
 	int retval;
-	u8 value_buf[4];
+	uint8_t value_buf[4];
 
 	if (target-&gt;state != TARGET_HALTED)
 	{

Modified: trunk/src/target/armv4_5_mmu.h
===================================================================
--- trunk/src/target/armv4_5_mmu.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/armv4_5_mmu.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -26,8 +26,8 @@
 typedef struct armv4_5_mmu_common_s
 {
 	u32 (*get_ttb)(target_t *target);
-	int (*read_memory)(target_t *target, u32 address, u32 size, u32 count, u8 *buffer);
-	int (*write_memory)(target_t *target, u32 address, u32 size, u32 count, u8 *buffer);
+	int (*read_memory)(target_t *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+	int (*write_memory)(target_t *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 	void (*disable_mmu_caches)(target_t *target, int mmu, int d_u_cache, int i_cache);
 	void (*enable_mmu_caches)(target_t *target, int mmu, int d_u_cache, int i_cache);
 	armv4_5_cache_common_t armv4_5_cache;
@@ -43,8 +43,8 @@
 extern char* armv4_5_page_type_names[];
 
 extern u32 armv4_5_mmu_translate_va(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 va, int *type, u32 *cb, int *domain, u32 *ap);
-extern int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, u8 *buffer);
-extern int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, u8 *buffer);
+extern int armv4_5_mmu_read_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer);
+extern int armv4_5_mmu_write_physical(target_t *target, armv4_5_mmu_common_t *armv4_5_mmu, u32 address, u32 size, u32 count, uint8_t *buffer);
 
 extern int armv4_5_mmu_handle_virt2phys_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, target_t *target, armv4_5_mmu_common_t *armv4_5_mmu);
 extern int armv4_5_mmu_handle_md_phys_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, target_t *target, armv4_5_mmu_common_t *armv4_5_mmu);

Modified: trunk/src/target/armv7m.c
===================================================================
--- trunk/src/target/armv7m.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/armv7m.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -58,14 +58,14 @@
 	&quot;primask&quot;, &quot;basepri&quot;, &quot;faultmask&quot;, &quot;control&quot;
 };
 
-u8 armv7m_gdb_dummy_fp_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+uint8_t armv7m_gdb_dummy_fp_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
 reg_t armv7m_gdb_dummy_fp_reg =
 {
 	&quot;GDB dummy floating-point register&quot;, armv7m_gdb_dummy_fp_value, 0, 1, 96, NULL, 0, NULL, 0
 };
 
-u8 armv7m_gdb_dummy_fps_value[] = {0, 0, 0, 0};
+uint8_t armv7m_gdb_dummy_fps_value[] = {0, 0, 0, 0};
 
 reg_t armv7m_gdb_dummy_fps_reg =
 {
@@ -73,7 +73,7 @@
 };
 
 #ifdef ARMV7_GDB_HACKS
-u8 armv7m_gdb_dummy_cpsr_value[] = {0, 0, 0, 0};
+uint8_t armv7m_gdb_dummy_cpsr_value[] = {0, 0, 0, 0};
 
 reg_t armv7m_gdb_dummy_cpsr_reg =
 {
@@ -171,7 +171,7 @@
 	return retval;
 }
 
-int armv7m_set_core_reg(reg_t *reg, u8 *buf)
+int armv7m_set_core_reg(reg_t *reg, uint8_t *buf)
 {
 	armv7m_core_reg_t *armv7m_reg = reg-&gt;arch_info;
 	target_t *target = armv7m_reg-&gt;target;

Modified: trunk/src/target/avrt.c
===================================================================
--- trunk/src/target/avrt.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/avrt.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -47,13 +47,13 @@
 int avr_soft_reset_halt(struct target_s *target);
 
 /* IR and DR functions */
-int avr_jtag_sendinstr(jtag_tap_t *tap, u8 *ir_in, u8 ir_out);
+int avr_jtag_sendinstr(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out);
 int avr_jtag_senddat(jtag_tap_t *tap, u32 *dr_in, u32 dr_out, int len);
 
-int mcu_write_ir(jtag_tap_t *tap, u8 *ir_in, u8 *ir_out, int ir_len, int rti);
-int mcu_write_dr(jtag_tap_t *tap, u8 *dr_in, u8 *dr_out, int dr_len, int rti);
-int mcu_write_ir_u8(jtag_tap_t *tap, u8 *ir_in, u8 ir_out, int ir_len, int rti);
-int mcu_write_dr_u8(jtag_tap_t *tap, u8 *ir_in, u8 ir_out, int dr_len, int rti);
+int mcu_write_ir(jtag_tap_t *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti);
+int mcu_write_dr(jtag_tap_t *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti);
+int mcu_write_ir_u8(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti);
+int mcu_write_dr_u8(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out, int dr_len, int rti);
 int mcu_write_ir_u16(jtag_tap_t *tap, u16 *ir_in, u16 ir_out, int ir_len, int rti);
 int mcu_write_dr_u16(jtag_tap_t *tap, u16 *ir_in, u16 ir_out, int dr_len, int rti);
 int mcu_write_ir_u32(jtag_tap_t *tap, u32 *ir_in, u32 ir_out, int ir_len, int rti);
@@ -192,13 +192,13 @@
 	return mcu_write_dr_u32(tap, dr_in, dr_out, len, 1);
 }
 
-int avr_jtag_sendinstr(jtag_tap_t *tap, u8 *ir_in, u8 ir_out)
+int avr_jtag_sendinstr(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out)
 {
 	return mcu_write_ir_u8(tap, ir_in, ir_out, AVR_JTAG_INS_LEN, 1);
 }
 
 /* IR and DR functions */
-int mcu_write_ir(jtag_tap_t *tap, u8 *ir_in, u8 *ir_out, int ir_len, int rti)
+int mcu_write_ir(jtag_tap_t *tap, uint8_t *ir_in, uint8_t *ir_out, int ir_len, int rti)
 {
 	if (NULL == tap)
 	{
@@ -224,7 +224,7 @@
 	return ERROR_OK;
 }
 
-int mcu_write_dr(jtag_tap_t *tap, u8 *dr_in, u8 *dr_out, int dr_len, int rti)
+int mcu_write_dr(jtag_tap_t *tap, uint8_t *dr_in, uint8_t *dr_out, int dr_len, int rti)
 {
 	if (NULL == tap)
 	{
@@ -245,7 +245,7 @@
 	return ERROR_OK;
 }
 
-int mcu_write_ir_u8(jtag_tap_t *tap, u8 *ir_in, u8 ir_out, int ir_len, int rti)
+int mcu_write_ir_u8(jtag_tap_t *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti)
 {
 	if (ir_len &gt; 8)
 	{
@@ -258,7 +258,7 @@
 	return ERROR_OK;
 }
 
-int mcu_write_dr_u8(jtag_tap_t *tap, u8 *dr_in, u8 dr_out, int dr_len, int rti)
+int mcu_write_dr_u8(jtag_tap_t *tap, uint8_t *dr_in, uint8_t dr_out, int dr_len, int rti)
 {
 	if (dr_len &gt; 8)
 	{
@@ -279,7 +279,7 @@
 		return ERROR_FAIL;
 	}
 
-	mcu_write_ir(tap, (u8*)ir_in, (u8*)&amp;ir_out, ir_len, rti);
+	mcu_write_ir(tap, (uint8_t*)ir_in, (uint8_t*)&amp;ir_out, ir_len, rti);
 
 	return ERROR_OK;
 }
@@ -292,7 +292,7 @@
 		return ERROR_FAIL;
 	}
 
-	mcu_write_dr(tap, (u8*)dr_in, (u8*)&amp;dr_out, dr_len, rti);
+	mcu_write_dr(tap, (uint8_t*)dr_in, (uint8_t*)&amp;dr_out, dr_len, rti);
 
 	return ERROR_OK;
 }
@@ -305,7 +305,7 @@
 		return ERROR_FAIL;
 	}
 
-	mcu_write_ir(tap, (u8*)ir_in, (u8*)&amp;ir_out, ir_len, rti);
+	mcu_write_ir(tap, (uint8_t*)ir_in, (uint8_t*)&amp;ir_out, ir_len, rti);
 
 	return ERROR_OK;
 }
@@ -318,7 +318,7 @@
 		return ERROR_FAIL;
 	}
 
-	mcu_write_dr(tap, (u8*)dr_in, (u8*)&amp;dr_out, dr_len, rti);
+	mcu_write_dr(tap, (uint8_t*)dr_in, (uint8_t*)&amp;dr_out, dr_len, rti);
 
 	return ERROR_OK;
 }

Modified: trunk/src/target/breakpoints.h
===================================================================
--- trunk/src/target/breakpoints.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/breakpoints.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -41,7 +41,7 @@
 	int length;
 	enum breakpoint_type type;
 	int set;
-	u8 *orig_instr;
+	uint8_t *orig_instr;
 	struct breakpoint_s *next;
 } breakpoint_t;
 

Modified: trunk/src/target/cortex_a8.c
===================================================================
--- trunk/src/target/cortex_a8.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/cortex_a8.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -83,13 +83,13 @@
 	.quit = NULL
 };
 
-int cortex_a8_dcc_read(swjdp_common_t *swjdp, u8 *value, u8 *ctrl)
+int cortex_a8_dcc_read(swjdp_common_t *swjdp, uint8_t *value, uint8_t *ctrl)
 {
 	u16 dcrdr;
 
-	mem_ap_read_buf_u16( swjdp, (u8*)&amp;dcrdr, 1, DCB_DCRDR);
-	*ctrl = (u8)dcrdr;
-	*value = (u8)(dcrdr &gt;&gt; 8);
+	mem_ap_read_buf_u16( swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
+	*ctrl = (uint8_t)dcrdr;
+	*value = (uint8_t)(dcrdr &gt;&gt; 8);
 
 	LOG_DEBUG(&quot;data 0x%x ctrl 0x%x&quot;, *value, *ctrl);
 
@@ -98,13 +98,13 @@
 	if (dcrdr &amp; (1 &lt;&lt; 0))
 	{
 		dcrdr = 0;
-		mem_ap_write_buf_u16( swjdp, (u8*)&amp;dcrdr, 1, DCB_DCRDR);
+		mem_ap_write_buf_u16( swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
 	}
 
 	return ERROR_OK;
 }
 
-int cortex_a8_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int cortex_a8_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -136,7 +136,7 @@
 	return retval;
 }
 
-int cortex_a8_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int cortex_a8_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -179,8 +179,8 @@
 
 	if (target-&gt;state == TARGET_RUNNING)
 	{
-		u8 data;
-		u8 ctrl;
+		uint8_t data;
+		uint8_t ctrl;
 
 		cortex_a8_dcc_read(swjdp, &amp;data, &amp;ctrl);
 

Modified: trunk/src/target/cortex_a8.h
===================================================================
--- trunk/src/target/cortex_a8.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/cortex_a8.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -93,7 +93,7 @@
 } cortex_a8_common_t;
 
 extern int cortex_a8_init_arch_info(target_t *target, cortex_a8_common_t *cortex_a8, jtag_tap_t *tap);
-int cortex_a8_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int cortex_a8_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+int cortex_a8_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int cortex_a8_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 
 #endif /* CORTEX_A8_H */

Modified: trunk/src/target/cortex_m3.c
===================================================================
--- trunk/src/target/cortex_m3.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/cortex_m3.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -48,11 +48,11 @@
 int cortex_m3_quit(void);
 int cortex_m3_load_core_reg_u32(target_t *target, enum armv7m_regtype type, u32 num, u32 *value);
 int cortex_m3_store_core_reg_u32(target_t *target, enum armv7m_regtype type, u32 num, u32 value);
-int cortex_m3_target_request_data(target_t *target, u32 size, u8 *buffer);
+int cortex_m3_target_request_data(target_t *target, u32 size, uint8_t *buffer);
 int cortex_m3_examine(struct target_s *target);
 
 #ifdef ARMV7_GDB_HACKS
-extern u8 armv7m_gdb_dummy_cpsr_value[];
+extern uint8_t armv7m_gdb_dummy_cpsr_value[];
 extern reg_t armv7m_gdb_dummy_cpsr_reg;
 #endif
 
@@ -930,7 +930,7 @@
 	}
 	else if (breakpoint-&gt;type == BKPT_SOFT)
 	{
-		u8 code[4];
+		uint8_t code[4];
 		buf_set_u32(code, 0, 32, ARMV7M_T_BKPT(0x11));
 		if((retval = target_read_memory(target, breakpoint-&gt;address &amp; 0xFFFFFFFE, breakpoint-&gt;length, 1, breakpoint-&gt;orig_instr)) != ERROR_OK)
 		{
@@ -1245,19 +1245,19 @@
 		switch (num)
 		{
 			case 19:
-				*value = buf_get_u32((u8*)value, 0, 8);
+				*value = buf_get_u32((uint8_t*)value, 0, 8);
 				break;
 
 			case 20:
-				*value = buf_get_u32((u8*)value, 8, 8);
+				*value = buf_get_u32((uint8_t*)value, 8, 8);
 				break;
 
 			case 21:
-				*value = buf_get_u32((u8*)value, 16, 8);
+				*value = buf_get_u32((uint8_t*)value, 16, 8);
 				break;
 
 			case 22:
-				*value = buf_get_u32((u8*)value, 24, 8);
+				*value = buf_get_u32((uint8_t*)value, 24, 8);
 				break;
 		}
 
@@ -1311,19 +1311,19 @@
 		switch (num)
 		{
 			case 19:
-				buf_set_u32((u8*)&amp;reg, 0, 8, value);
+				buf_set_u32((uint8_t*)&amp;reg, 0, 8, value);
 				break;
 
 			case 20:
-				buf_set_u32((u8*)&amp;reg, 8, 8, value);
+				buf_set_u32((uint8_t*)&amp;reg, 8, 8, value);
 				break;
 
 			case 21:
-				buf_set_u32((u8*)&amp;reg, 16, 8, value);
+				buf_set_u32((uint8_t*)&amp;reg, 16, 8, value);
 				break;
 
 			case 22:
-				buf_set_u32((u8*)&amp;reg, 24, 8, value);
+				buf_set_u32((uint8_t*)&amp;reg, 24, 8, value);
 				break;
 		}
 
@@ -1339,7 +1339,7 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int cortex_m3_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -1371,7 +1371,7 @@
 	return retval;
 }
 
-int cortex_m3_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int cortex_m3_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	/* get pointers to arch-specific information */
 	armv7m_common_t *armv7m = target-&gt;arch_info;
@@ -1401,7 +1401,7 @@
 	return retval;
 }
 
-int cortex_m3_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer)
+int cortex_m3_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
 {
 	return cortex_m3_write_memory(target, address, 4, count, buffer);
 }
@@ -1487,13 +1487,13 @@
 	return ERROR_OK;
 }
 
-int cortex_m3_dcc_read(swjdp_common_t *swjdp, u8 *value, u8 *ctrl)
+int cortex_m3_dcc_read(swjdp_common_t *swjdp, uint8_t *value, uint8_t *ctrl)
 {
 	u16 dcrdr;
 
-	mem_ap_read_buf_u16( swjdp, (u8*)&amp;dcrdr, 1, DCB_DCRDR);
-	*ctrl = (u8)dcrdr;
-	*value = (u8)(dcrdr &gt;&gt; 8);
+	mem_ap_read_buf_u16( swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
+	*ctrl = (uint8_t)dcrdr;
+	*value = (uint8_t)(dcrdr &gt;&gt; 8);
 
 	LOG_DEBUG(&quot;data 0x%x ctrl 0x%x&quot;, *value, *ctrl);
 
@@ -1502,18 +1502,18 @@
 	if (dcrdr &amp; (1 &lt;&lt; 0))
 	{
 		dcrdr = 0;
-		mem_ap_write_buf_u16( swjdp, (u8*)&amp;dcrdr, 1, DCB_DCRDR);
+		mem_ap_write_buf_u16( swjdp, (uint8_t*)&amp;dcrdr, 1, DCB_DCRDR);
 	}
 
 	return ERROR_OK;
 }
 
-int cortex_m3_target_request_data(target_t *target, u32 size, u8 *buffer)
+int cortex_m3_target_request_data(target_t *target, u32 size, uint8_t *buffer)
 {
 	armv7m_common_t *armv7m = target-&gt;arch_info;
 	swjdp_common_t *swjdp = &amp;armv7m-&gt;swjdp_info;
-	u8 data;
-	u8 ctrl;
+	uint8_t data;
+	uint8_t ctrl;
 	u32 i;
 
 	for (i = 0; i &lt; (size * 4); i++)
@@ -1538,8 +1538,8 @@
 
 	if (target-&gt;state == TARGET_RUNNING)
 	{
-		u8 data;
-		u8 ctrl;
+		uint8_t data;
+		uint8_t ctrl;
 
 		cortex_m3_dcc_read(swjdp, &amp;data, &amp;ctrl);
 

Modified: trunk/src/target/cortex_m3.h
===================================================================
--- trunk/src/target/cortex_m3.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/cortex_m3.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -177,9 +177,9 @@
 int cortex_m3_deassert_reset(target_t *target);
 int cortex_m3_soft_reset_halt(struct target_s *target);
 
-int cortex_m3_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int cortex_m3_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int cortex_m3_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer);
+int cortex_m3_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int cortex_m3_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int cortex_m3_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
 
 int cortex_m3_set_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
 int cortex_m3_unset_breakpoint(struct target_s *target, breakpoint_t *breakpoint);

Modified: trunk/src/target/embeddedice.c
===================================================================
--- trunk/src/target/embeddedice.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/embeddedice.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -230,13 +230,13 @@
 	return ERROR_OK;
 }
 
-int embeddedice_read_reg_w_check(reg_t *reg, u8* check_value, u8* check_mask)
+int embeddedice_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask)
 {
 	embeddedice_reg_t *ice_reg = reg-&gt;arch_info;
-	u8 reg_addr = ice_reg-&gt;addr &amp; 0x1f;
+	uint8_t reg_addr = ice_reg-&gt;addr &amp; 0x1f;
 	scan_field_t fields[3];
-	u8 field1_out[1];
-	u8 field2_out[1];
+	uint8_t field1_out[1];
+	uint8_t field2_out[1];
 
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(ice_reg-&gt;jtag_info, 0x2);
@@ -290,8 +290,8 @@
 int embeddedice_receive(arm_jtag_t *jtag_info, u32 *data, u32 size)
 {
 	scan_field_t fields[3];
-	u8 field1_out[1];
-	u8 field2_out[1];
+	uint8_t field1_out[1];
+	uint8_t field2_out[1];
 
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2);
@@ -324,9 +324,9 @@
 		if (size == 1)
 			buf_set_u32(fields[1].out_value, 0, 5, embeddedice_reg_arch_info[EICE_COMMS_CTRL]);
 
-		fields[0].in_value = (u8 *)data;
+		fields[0].in_value = (uint8_t *)data;
 		jtag_add_dr_scan(3, fields, jtag_get_end_state());
-		jtag_add_callback(arm_le_to_h_u32, (u8 *)data);
+		jtag_add_callback(arm_le_to_h_u32, (uint8_t *)data);
 
 		data++;
 		size--;
@@ -350,7 +350,7 @@
 
 }
 
-int embeddedice_set_reg_w_exec(reg_t *reg, u8 *buf)
+int embeddedice_set_reg_w_exec(reg_t *reg, uint8_t *buf)
 {
 	int retval;
 	embeddedice_set_reg(reg, buf_get_u32(buf, 0, reg-&gt;size));
@@ -374,7 +374,7 @@
 
 	arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL);
 
-	u8 reg_addr = ice_reg-&gt;addr &amp; 0x1f;
+	uint8_t reg_addr = ice_reg-&gt;addr &amp; 0x1f;
 	embeddedice_write_reg_inner(ice_reg-&gt;jtag_info-&gt;tap, reg_addr, value);
 
 }
@@ -391,9 +391,9 @@
 int embeddedice_send(arm_jtag_t *jtag_info, u32 *data, u32 size)
 {
 	scan_field_t fields[3];
-	u8 field0_out[4];
-	u8 field1_out[1];
-	u8 field2_out[1];
+	uint8_t field0_out[4];
+	uint8_t field1_out[1];
+	uint8_t field2_out[1];
 
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2);
@@ -435,9 +435,9 @@
 int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, u32 timeout)
 {
 	scan_field_t fields[3];
-	u8 field0_in[4];
-	u8 field1_out[1];
-	u8 field2_out[1];
+	uint8_t field0_in[4];
+	uint8_t field1_out[1];
+	uint8_t field2_out[1];
 	int retval;
 	u32 hsact;
 	struct timeval lap;
@@ -491,7 +491,7 @@
 
 #ifndef HAVE_JTAG_MINIDRIVER_H
 /* this is the inner loop of the open loop DCC write of data to target */
-void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, u8 *buffer, int little, int count)
+void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, uint8_t *buffer, int little, int count)
 {
 	int i;
 	for (i = 0; i &lt; count; i++)

Modified: trunk/src/target/embeddedice.h
===================================================================
--- trunk/src/target/embeddedice.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/embeddedice.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -97,10 +97,10 @@
 extern int embeddedice_setup(target_t *target);
 extern int embeddedice_read_reg(reg_t *reg);
 extern void embeddedice_write_reg(reg_t *reg, u32 value);
-extern int embeddedice_read_reg_w_check(reg_t *reg, u8* check_value, u8* check_mask);
+extern int embeddedice_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
 extern void embeddedice_store_reg(reg_t *reg);
 extern void embeddedice_set_reg(reg_t *reg, u32 value);
-extern int embeddedice_set_reg_w_exec(reg_t *reg, u8 *buf);
+extern int embeddedice_set_reg_w_exec(reg_t *reg, uint8_t *buf);
 extern int embeddedice_receive(arm_jtag_t *jtag_info, u32 *data, u32 size);
 extern int embeddedice_send(arm_jtag_t *jtag_info, u32 *data, u32 size);
 extern int embeddedice_handshake(arm_jtag_t *jtag_info, int hsbit, u32 timeout);
@@ -124,6 +124,6 @@
 			jtag_get_end_state());
 }
 
-void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, u8 *buffer, int little, int count);
+void embeddedice_write_dcc(jtag_tap_t *tap, int reg_addr, uint8_t *buffer, int little, int count);
 
 #endif /* EMBEDDED_ICE_H */

Modified: trunk/src/target/etb.c
===================================================================
--- trunk/src/target/etb.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/etb.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -158,7 +158,7 @@
 }
 
 
-static void etb_getbuf(u8 *in)
+static void etb_getbuf(uint8_t *in)
 {
 	*((u32 *)in)=buf_get_u32(in, 0, 32);
 }
@@ -203,10 +203,10 @@
 		else
 			buf_set_u32(fields[1].out_value, 0, 7, 0);
 
-		fields[0].in_value = (u8 *)(data+i);
+		fields[0].in_value = (uint8_t *)(data+i);
 		jtag_add_dr_scan(3, fields, jtag_get_end_state());
 
-		jtag_add_callback(etb_getbuf, (u8 *)(data+i));
+		jtag_add_callback(etb_getbuf, (uint8_t *)(data+i));
 	}
 
 	jtag_execute_queue();
@@ -217,10 +217,10 @@
 	return ERROR_OK;
 }
 
-int etb_read_reg_w_check(reg_t *reg, u8* check_value, u8* check_mask)
+int etb_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask)
 {
 	etb_reg_t *etb_reg = reg-&gt;arch_info;
-	u8 reg_addr = etb_reg-&gt;addr &amp; 0x7f;
+	uint8_t reg_addr = etb_reg-&gt;addr &amp; 0x7f;
 	scan_field_t fields[3];
 
 	LOG_DEBUG(&quot;%i&quot;, etb_reg-&gt;addr);
@@ -292,7 +292,7 @@
 	return ERROR_OK;
 }
 
-int etb_set_reg_w_exec(reg_t *reg, u8 *buf)
+int etb_set_reg_w_exec(reg_t *reg, uint8_t *buf)
 {
 	int retval;
 
@@ -309,7 +309,7 @@
 int etb_write_reg(reg_t *reg, u32 value)
 {
 	etb_reg_t *etb_reg = reg-&gt;arch_info;
-	u8 reg_addr = etb_reg-&gt;addr &amp; 0x7f;
+	uint8_t reg_addr = etb_reg-&gt;addr &amp; 0x7f;
 	scan_field_t fields[3];
 
 	LOG_DEBUG(&quot;%i: 0x%8.8x&quot;, etb_reg-&gt;addr, value);

Modified: trunk/src/target/etb.h
===================================================================
--- trunk/src/target/etb.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/etb.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -59,9 +59,9 @@
 extern reg_cache_t* etb_build_reg_cache(etb_t *etb);
 extern int etb_read_reg(reg_t *reg);
 extern int etb_write_reg(reg_t *reg, u32 value);
-extern int etb_read_reg_w_check(reg_t *reg, u8* check_value, u8* check_mask);
+extern int etb_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
 extern int etb_store_reg(reg_t *reg);
 extern int etb_set_reg(reg_t *reg, u32 value);
-extern int etb_set_reg_w_exec(reg_t *reg, u8 *buf);
+extern int etb_set_reg_w_exec(reg_t *reg, uint8_t *buf);
 
 #endif /* ETB_H */

Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/etm.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -312,10 +312,10 @@
 	return ERROR_OK;
 }
 
-int etm_read_reg_w_check(reg_t *reg, u8* check_value, u8* check_mask)
+int etm_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask)
 {
 	etm_reg_t *etm_reg = reg-&gt;arch_info;
-	u8 reg_addr = etm_reg-&gt;addr &amp; 0x7f;
+	uint8_t reg_addr = etm_reg-&gt;addr &amp; 0x7f;
 	scan_field_t fields[3];
 
 	LOG_DEBUG(&quot;%i&quot;, etm_reg-&gt;addr);
@@ -383,7 +383,7 @@
 	return ERROR_OK;
 }
 
-int etm_set_reg_w_exec(reg_t *reg, u8 *buf)
+int etm_set_reg_w_exec(reg_t *reg, uint8_t *buf)
 {
 	int retval;
 
@@ -400,7 +400,7 @@
 int etm_write_reg(reg_t *reg, u32 value)
 {
 	etm_reg_t *etm_reg = reg-&gt;arch_info;
-	u8 reg_addr = etm_reg-&gt;addr &amp; 0x7f;
+	uint8_t reg_addr = etm_reg-&gt;addr &amp; 0x7f;
 	scan_field_t fields[3];
 
 	LOG_DEBUG(&quot;%i: 0x%8.8x&quot;, etm_reg-&gt;addr, value);
@@ -411,21 +411,21 @@
 
 	fields[0].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
-	u8 tmp1[4];
+	uint8_t tmp1[4];
 	fields[0].out_value = tmp1;
 	buf_set_u32(fields[0].out_value, 0, 32, value);
 	fields[0].in_value = NULL;
 
 	fields[1].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[1].num_bits = 7;
-	u8 tmp2;
+	uint8_t tmp2;
 	fields[1].out_value = &amp;tmp2;
 	buf_set_u32(fields[1].out_value, 0, 7, reg_addr);
 	fields[1].in_value = NULL;
 
 	fields[2].tap = etm_reg-&gt;jtag_info-&gt;tap;
 	fields[2].num_bits = 1;
-	u8 tmp3;
+	uint8_t tmp3;
 	fields[2].out_value = &amp;tmp3;
 	buf_set_u32(fields[2].out_value, 0, 1, 1);
 	fields[2].in_value = NULL;
@@ -500,7 +500,7 @@
 
 	if (ctx-&gt;core_state == ARMV4_5_STATE_ARM)
 	{
-		u8 buf[4];
+		uint8_t buf[4];
 		if ((retval = image_read_section(ctx-&gt;image, section,
 			ctx-&gt;current_pc - ctx-&gt;image-&gt;sections[section].base_address,
 			4, buf, &amp;size_read)) != ERROR_OK)
@@ -513,7 +513,7 @@
 	}
 	else if (ctx-&gt;core_state == ARMV4_5_STATE_THUMB)
 	{
-		u8 buf[2];
+		uint8_t buf[2];
 		if ((retval = image_read_section(ctx-&gt;image, section,
 			ctx-&gt;current_pc - ctx-&gt;image-&gt;sections[section].base_address,
 			2, buf, &amp;size_read)) != ERROR_OK)
@@ -538,7 +538,7 @@
 	return ERROR_OK;
 }
 
-static int etmv1_next_packet(etm_context_t *ctx, u8 *packet, int apo)
+static int etmv1_next_packet(etm_context_t *ctx, uint8_t *packet, int apo)
 {
 	while (ctx-&gt;data_index &lt; ctx-&gt;trace_depth)
 	{
@@ -606,7 +606,7 @@
 static int etmv1_branch_address(etm_context_t *ctx)
 {
 	int retval;
-	u8 packet;
+	uint8_t packet;
 	int shift = 0;
 	int apo;
 	u32 i;
@@ -692,7 +692,7 @@
 static int etmv1_data(etm_context_t *ctx, int size, u32 *data)
 {
 	int j;
-	u8 buf[4];
+	uint8_t buf[4];
 	int retval;
 
 	for (j = 0; j &lt; size; j++)
@@ -738,7 +738,7 @@
 
 	while (ctx-&gt;pipe_index &lt; ctx-&gt;trace_depth)
 	{
-		u8 pipestat = ctx-&gt;trace_data[ctx-&gt;pipe_index].pipestat;
+		uint8_t pipestat = ctx-&gt;trace_data[ctx-&gt;pipe_index].pipestat;
 		u32 next_pc = ctx-&gt;current_pc;
 		u32 old_data_index = ctx-&gt;data_index;
 		u32 old_data_half = ctx-&gt;data_half;
@@ -901,7 +901,7 @@
 
 			if (ctx-&gt;tracemode &amp; ETMV1_TRACE_ADDR)
 			{
-				u8 packet;
+				uint8_t packet;
 				int shift = 0;
 
 				do {

Modified: trunk/src/target/etm.h
===================================================================
--- trunk/src/target/etm.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/etm.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -127,7 +127,7 @@
 
 typedef struct etmv1_trace_data_s
 {
-	u8 pipestat;	/* bits 0-2 pipeline status */
+	uint8_t pipestat;	/* bits 0-2 pipeline status */
 	u16 packet;		/* packet data (4, 8 or 16 bit) */
 	int flags;		/* ETMV1_TRACESYNC_CYCLE, ETMV1_TRIGGER_CYCLE */
 } etmv1_trace_data_t;
@@ -195,10 +195,10 @@
 extern reg_cache_t* etm_build_reg_cache(target_t *target, arm_jtag_t *jtag_info, etm_context_t *etm_ctx);
 extern int etm_read_reg(reg_t *reg);
 extern int etm_write_reg(reg_t *reg, u32 value);
-extern int etm_read_reg_w_check(reg_t *reg, u8* check_value, u8* check_mask);
+extern int etm_read_reg_w_check(reg_t *reg, uint8_t* check_value, uint8_t* check_mask);
 extern int etm_store_reg(reg_t *reg);
 extern int etm_set_reg(reg_t *reg, u32 value);
-extern int etm_set_reg_w_exec(reg_t *reg, u8 *buf);
+extern int etm_set_reg_w_exec(reg_t *reg, uint8_t *buf);
 extern int etm_setup(target_t *target);
 
 int etm_register_commands(struct command_context_s *cmd_ctx);

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/feroceon.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -55,7 +55,7 @@
 
 int feroceon_examine(struct target_s *target);
 int feroceon_target_create(struct target_s *target, Jim_Interp *interp);
-int feroceon_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer);
+int feroceon_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
 int feroceon_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int feroceon_quit(void);
 
@@ -115,9 +115,9 @@
 int feroceon_dummy_clock_out(arm_jtag_t *jtag_info, u32 instr)
 {
 	scan_field_t fields[3];
-	u8 out_buf[4];
-	u8 instr_buf[4];
-	u8 sysspeed_buf = 0x0;
+	uint8_t out_buf[4];
+	uint8_t instr_buf[4];
+	uint8_t sysspeed_buf = 0x0;
 
 	/* prepare buffer */
 	buf_set_u32(out_buf, 0, 32, 0);
@@ -240,7 +240,7 @@
 	int be = (target-&gt;endianness == TARGET_BIG_ENDIAN) ? 1 : 0;
 	u32 *buf_u32 = buffer;
 	u16 *buf_u16 = buffer;
-	u8 *buf_u8 = buffer;
+	uint8_t *buf_u8 = buffer;
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_STMIA(0, mask &amp; 0xffff, 0, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -332,7 +332,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 }
 
-void feroceon_write_xpsr_im8(target_t *target, u8 xpsr_im, int rot, int spsr)
+void feroceon_write_xpsr_im8(target_t *target, uint8_t xpsr_im, int rot, int spsr)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -507,7 +507,7 @@
 	return ERROR_OK;
 }
 
-int feroceon_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer)
+int feroceon_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
 {
 	int retval;
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
@@ -552,7 +552,7 @@
 	/* regrab previously allocated working_area, or allocate a new one */
 	if (!arm7_9-&gt;dcc_working_area)
 	{
-		u8 dcc_code_buf[dcc_size];
+		uint8_t dcc_code_buf[dcc_size];
 
 		/* make sure we have a working area */
 		if (target_alloc_working_area(target, dcc_size, &amp;arm7_9-&gt;dcc_working_area) != ERROR_OK)

Modified: trunk/src/target/image.c
===================================================================
--- trunk/src/target/image.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/image.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -35,18 +35,18 @@
 /* convert ELF header field to host endianness */
 #define field16(elf,field)\
 	((elf-&gt;endianness==ELFDATA2LSB)? \
-		le_to_h_u16((u8*)&amp;field):be_to_h_u16((u8*)&amp;field))
+		le_to_h_u16((uint8_t*)&amp;field):be_to_h_u16((uint8_t*)&amp;field))
 
 #define field32(elf,field)\
 	((elf-&gt;endianness==ELFDATA2LSB)? \
-		le_to_h_u32((u8*)&amp;field):be_to_h_u32((u8*)&amp;field))
+		le_to_h_u32((uint8_t*)&amp;field):be_to_h_u32((uint8_t*)&amp;field))
 
 static int autodetect_image_type(image_t *image, char *url)
 {
 	int retval;
 	fileio_t fileio;
 	u32 read_bytes;
-	u8 buffer[9];
+	uint8_t buffer[9];
 
 	/* read the first 4 bytes of image */
 	if ((retval = fileio_open(&amp;fileio, url, FILEIO_READ, FILEIO_BINARY)) != ERROR_OK)
@@ -171,7 +171,7 @@
 		u32 address;
 		u32 record_type;
 		u32 checksum;
-		u8 cal_checksum = 0;
+		uint8_t cal_checksum = 0;
 		u32 bytes_read = 0;
 
 		if (sscanf(&amp;lpszLine[bytes_read], &quot;:%2x%4x%2x&quot;, &amp;count, &amp;address, &amp;record_type) != 3)
@@ -180,10 +180,10 @@
 		}
 		bytes_read += 9;
 
-		cal_checksum += (u8)count;
-		cal_checksum += (u8)(address &gt;&gt; 8);
-		cal_checksum += (u8)address;
-		cal_checksum += (u8)record_type;
+		cal_checksum += (uint8_t)count;
+		cal_checksum += (uint8_t)(address &gt;&gt; 8);
+		cal_checksum += (uint8_t)address;
+		cal_checksum += (uint8_t)record_type;
 
 		if (record_type == 0) /* Data Record */
 		{
@@ -209,8 +209,8 @@
 			{
 				unsigned value;
 				sscanf(&amp;lpszLine[bytes_read], &quot;%2x&quot;, &amp;value);
-				ihex-&gt;buffer[cooked_bytes] = (u8)value;
-				cal_checksum += (u8)ihex-&gt;buffer[cooked_bytes];
+				ihex-&gt;buffer[cooked_bytes] = (uint8_t)value;
+				cal_checksum += (uint8_t)ihex-&gt;buffer[cooked_bytes];
 				bytes_read += 2;
 				cooked_bytes += 1;
 				section[image-&gt;num_sections].size += 1;
@@ -239,8 +239,8 @@
 			u16 upper_address;
 
 			sscanf(&amp;lpszLine[bytes_read], &quot;%4hx&quot;, &amp;upper_address);
-			cal_checksum += (u8)(upper_address &gt;&gt; 8);
-			cal_checksum += (u8)upper_address;
+			cal_checksum += (uint8_t)(upper_address &gt;&gt; 8);
+			cal_checksum += (uint8_t)upper_address;
 			bytes_read += 4;
 
 			if ((full_address &gt;&gt; 4) != upper_address)
@@ -270,7 +270,7 @@
 			while (count-- &gt; 0)
 			{
 				sscanf(&amp;lpszLine[bytes_read], &quot;%2x&quot;, &amp;dummy);
-				cal_checksum += (u8)dummy;
+				cal_checksum += (uint8_t)dummy;
 				bytes_read += 2;
 			}
 		}
@@ -279,8 +279,8 @@
 			u16 upper_address;
 
 			sscanf(&amp;lpszLine[bytes_read], &quot;%4hx&quot;, &amp;upper_address);
-			cal_checksum += (u8)(upper_address &gt;&gt; 8);
-			cal_checksum += (u8)upper_address;
+			cal_checksum += (uint8_t)(upper_address &gt;&gt; 8);
+			cal_checksum += (uint8_t)upper_address;
 			bytes_read += 4;
 
 			if ((full_address &gt;&gt; 16) != upper_address)
@@ -306,14 +306,14 @@
 			u32 start_address;
 
 			sscanf(&amp;lpszLine[bytes_read], &quot;%8x&quot;, &amp;start_address);
-			cal_checksum += (u8)(start_address &gt;&gt; 24);
-			cal_checksum += (u8)(start_address &gt;&gt; 16);
-			cal_checksum += (u8)(start_address &gt;&gt; 8);
-			cal_checksum += (u8)start_address;
+			cal_checksum += (uint8_t)(start_address &gt;&gt; 24);
+			cal_checksum += (uint8_t)(start_address &gt;&gt; 16);
+			cal_checksum += (uint8_t)(start_address &gt;&gt; 8);
+			cal_checksum += (uint8_t)start_address;
 			bytes_read += 8;
 
 			image-&gt;start_address_set = 1;
-			image-&gt;start_address = be_to_h_u32((u8*)&amp;start_address);
+			image-&gt;start_address = be_to_h_u32((uint8_t*)&amp;start_address);
 		}
 		else
 		{
@@ -324,7 +324,7 @@
 		sscanf(&amp;lpszLine[bytes_read], &quot;%2x&quot;, &amp;checksum);
 		bytes_read += 2;
 
-		if ((u8)checksum != (u8)(~cal_checksum + 1))
+		if ((uint8_t)checksum != (uint8_t)(~cal_checksum + 1))
 		{
 			/* checksum failed */
 			LOG_ERROR(&quot;incorrect record checksum found in IHEX file&quot;);
@@ -351,7 +351,7 @@
 		return ERROR_FILEIO_OPERATION_FAILED;
 	}
 
-	if ((retval = fileio_read(&amp;elf-&gt;fileio, sizeof(Elf32_Ehdr), (u8*)elf-&gt;header, &amp;read_bytes)) != ERROR_OK)
+	if ((retval = fileio_read(&amp;elf-&gt;fileio, sizeof(Elf32_Ehdr), (uint8_t*)elf-&gt;header, &amp;read_bytes)) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;cannot read ELF file header, read failed&quot;);
 		return ERROR_FILEIO_OPERATION_FAILED;
@@ -401,7 +401,7 @@
 		return ERROR_FILEIO_OPERATION_FAILED;
 	}
 
-	if ((retval = fileio_read(&amp;elf-&gt;fileio, elf-&gt;segment_count*sizeof(Elf32_Phdr), (u8*)elf-&gt;segments, &amp;read_bytes)) != ERROR_OK)
+	if ((retval = fileio_read(&amp;elf-&gt;fileio, elf-&gt;segment_count*sizeof(Elf32_Phdr), (uint8_t*)elf-&gt;segments, &amp;read_bytes)) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;cannot read ELF segment headers, read failed&quot;);
 		return retval;
@@ -437,7 +437,7 @@
 	return ERROR_OK;
 }
 
-static int image_elf_read_section(image_t *image, int section, u32 offset, u32 size, u8 *buffer, u32 *size_read)
+static int image_elf_read_section(image_t *image, int section, u32 offset, u32 size, uint8_t *buffer, u32 *size_read)
 {
 	image_elf_t *elf = image-&gt;type_private;
 	Elf32_Phdr *segment = (Elf32_Phdr *)image-&gt;sections[section].private;
@@ -505,7 +505,7 @@
 		u32 address;
 		u32 record_type;
 		u32 checksum;
-		u8 cal_checksum = 0;
+		uint8_t cal_checksum = 0;
 		u32 bytes_read = 0;
 
 		/* get record type and record length */
@@ -515,7 +515,7 @@
 		}
 
 		bytes_read += 4;
-		cal_checksum += (u8)count;
+		cal_checksum += (uint8_t)count;
 
 		/* skip checksum byte */
 		count -=1;
@@ -527,7 +527,7 @@
 
 			while (count-- &gt; 0) {
 				sscanf(&amp;lpszLine[bytes_read], &quot;%2x&quot;, &amp;iValue);
-				cal_checksum += (u8)iValue;
+				cal_checksum += (uint8_t)iValue;
 				bytes_read += 2;
 			}
 		}
@@ -538,8 +538,8 @@
 				case 1:
 					/* S1 - 16 bit address data record */
 					sscanf(&amp;lpszLine[bytes_read], &quot;%4x&quot;, &amp;address);
-					cal_checksum += (u8)(address &gt;&gt; 8);
-					cal_checksum += (u8)address;
+					cal_checksum += (uint8_t)(address &gt;&gt; 8);
+					cal_checksum += (uint8_t)address;
 					bytes_read += 4;
 					count -=2;
 					break;
@@ -547,9 +547,9 @@
 				case 2:
 					/* S2 - 24 bit address data record */
 					sscanf(&amp;lpszLine[bytes_read], &quot;%6x&quot;, &amp;address);
-					cal_checksum += (u8)(address &gt;&gt; 16);
-					cal_checksum += (u8)(address &gt;&gt; 8);
-					cal_checksum += (u8)address;
+					cal_checksum += (uint8_t)(address &gt;&gt; 16);
+					cal_checksum += (uint8_t)(address &gt;&gt; 8);
+					cal_checksum += (uint8_t)address;
 					bytes_read += 6;
 					count -=3;
 					break;
@@ -557,10 +557,10 @@
 				case 3:
 					/* S3 - 32 bit address data record */
 					sscanf(&amp;lpszLine[bytes_read], &quot;%8x&quot;, &amp;address);
-					cal_checksum += (u8)(address &gt;&gt; 24);
-					cal_checksum += (u8)(address &gt;&gt; 16);
-					cal_checksum += (u8)(address &gt;&gt; 8);
-					cal_checksum += (u8)address;
+					cal_checksum += (uint8_t)(address &gt;&gt; 24);
+					cal_checksum += (uint8_t)(address &gt;&gt; 16);
+					cal_checksum += (uint8_t)(address &gt;&gt; 8);
+					cal_checksum += (uint8_t)address;
 					bytes_read += 8;
 					count -=4;
 					break;
@@ -588,8 +588,8 @@
 			{
 				unsigned value;
 				sscanf(&amp;lpszLine[bytes_read], &quot;%2x&quot;, &amp;value);
-				mot-&gt;buffer[cooked_bytes] = (u8)value;
-				cal_checksum += (u8)mot-&gt;buffer[cooked_bytes];
+				mot-&gt;buffer[cooked_bytes] = (uint8_t)value;
+				cal_checksum += (uint8_t)mot-&gt;buffer[cooked_bytes];
 				bytes_read += 2;
 				cooked_bytes += 1;
 				section[image-&gt;num_sections].size += 1;
@@ -604,7 +604,7 @@
 			while (count-- &gt; 0)
 			{
 				sscanf(&amp;lpszLine[bytes_read], &quot;%2x&quot;, &amp;dummy);
-				cal_checksum += (u8)dummy;
+				cal_checksum += (uint8_t)dummy;
 				bytes_read += 2;
 			}
 		}
@@ -633,7 +633,7 @@
 
 		/* account for checksum, will always be 0xFF */
 		sscanf(&amp;lpszLine[bytes_read], &quot;%2x&quot;, &amp;checksum);
-		cal_checksum += (u8)checksum;
+		cal_checksum += (uint8_t)checksum;
 		bytes_read += 2;
 
 		if( cal_checksum != 0xFF )
@@ -776,7 +776,7 @@
 	return retval;
 };
 
-int image_read_section(image_t *image, int section, u32 offset, u32 size, u8 *buffer, u32 *size_read)
+int image_read_section(image_t *image, int section, u32 offset, u32 size, uint8_t *buffer, u32 *size_read)
 {
 	int retval;
 
@@ -810,7 +810,7 @@
 	}
 	else if (image-&gt;type == IMAGE_IHEX)
 	{
-		memcpy(buffer, (u8*)image-&gt;sections[section].private + offset, size);
+		memcpy(buffer, (uint8_t*)image-&gt;sections[section].private + offset, size);
 		*size_read = size;
 
 		return ERROR_OK;
@@ -860,14 +860,14 @@
 	}
 	else if (image-&gt;type == IMAGE_SRECORD)
 	{
-		memcpy(buffer, (u8*)image-&gt;sections[section].private + offset, size);
+		memcpy(buffer, (uint8_t*)image-&gt;sections[section].private + offset, size);
 		*size_read = size;
 
 		return ERROR_OK;
 	}
 	else if (image-&gt;type == IMAGE_BUILDER)
 	{
-		memcpy(buffer, (u8*)image-&gt;sections[section].private + offset, size);
+		memcpy(buffer, (uint8_t*)image-&gt;sections[section].private + offset, size);
 		*size_read = size;
 
 		return ERROR_OK;
@@ -876,7 +876,7 @@
 	return ERROR_OK;
 }
 
-int image_add_section(image_t *image, u32 base, u32 size, int flags, u8 *data)
+int image_add_section(image_t *image, u32 base, u32 size, int flags, uint8_t *data)
 {
 	image_section_t *section;
 
@@ -894,7 +894,7 @@
 		if (((section-&gt;base_address + section-&gt;size) == base) &amp;&amp; (section-&gt;flags == flags))
 		{
 			section-&gt;private = realloc(section-&gt;private, section-&gt;size + size);
-			memcpy((u8*)section-&gt;private + section-&gt;size, data, size);
+			memcpy((uint8_t*)section-&gt;private + section-&gt;size, data, size);
 			section-&gt;size += size;
 			return ERROR_OK;
 		}
@@ -907,8 +907,8 @@
 	section-&gt;base_address = base;
 	section-&gt;size = size;
 	section-&gt;flags = flags;
-	section-&gt;private = malloc(sizeof(u8) * size);
-	memcpy((u8*)section-&gt;private, data, size);
+	section-&gt;private = malloc(sizeof(uint8_t) * size);
+	memcpy((uint8_t*)section-&gt;private, data, size);
 
 	return ERROR_OK;
 }
@@ -997,7 +997,7 @@
 	}
 }
 
-int image_calculate_checksum(u8* buffer, u32 nbytes, u32* checksum)
+int image_calculate_checksum(uint8_t* buffer, u32 nbytes, u32* checksum)
 {
 	u32 crc = 0xffffffff;
 	LOG_DEBUG(&quot;Calculating checksum&quot;);

Modified: trunk/src/target/image.h
===================================================================
--- trunk/src/target/image.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/image.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -75,13 +75,13 @@
 typedef struct image_ihex_s
 {
 	fileio_t fileio;
-	u8 *buffer;
+	uint8_t *buffer;
 } image_ihex_t;
 
 typedef struct image_memory_s
 {
 	struct target_s *target;
-	u8 *cache;
+	uint8_t *cache;
 	u32 cache_address;
 } image_memory_t;
 
@@ -91,21 +91,21 @@
 	Elf32_Ehdr *header;
 	Elf32_Phdr *segments;
 	u32 segment_count;
-	u8 endianness;
+	uint8_t endianness;
 } image_elf_t;
 
 typedef struct image_mot_s
 {
 	fileio_t fileio;
-	u8 *buffer;
+	uint8_t *buffer;
 } image_mot_t;
 
 extern int image_open(image_t *image, char *url, char *type_string);
-extern int image_read_section(image_t *image, int section, u32 offset, u32 size, u8 *buffer, u32 *size_read);
+extern int image_read_section(image_t *image, int section, u32 offset, u32 size, uint8_t *buffer, u32 *size_read);
 extern void image_close(image_t *image);
-extern int image_add_section(image_t *image, u32 base, u32 size, int flags, u8 *data);
+extern int image_add_section(image_t *image, u32 base, u32 size, int flags, uint8_t *data);
 
-extern int image_calculate_checksum(u8* buffer, u32 nbytes, u32* checksum);
+extern int image_calculate_checksum(uint8_t* buffer, u32 nbytes, u32* checksum);
 
 #define ERROR_IMAGE_FORMAT_ERROR	(-1400)
 #define ERROR_IMAGE_TYPE_UNKNOWN	(-1401)

Modified: trunk/src/target/mips32.c
===================================================================
--- trunk/src/target/mips32.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips32.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -86,7 +86,7 @@
 
 #define MIPS32NUMFPREGS 34 + 18
 
-u8 mips32_gdb_dummy_fp_value[] = {0, 0, 0, 0};
+uint8_t mips32_gdb_dummy_fp_value[] = {0, 0, 0, 0};
 
 reg_t mips32_gdb_dummy_fp_reg =
 {
@@ -112,7 +112,7 @@
 	return retval;
 }
 
-int mips32_set_core_reg(reg_t *reg, u8 *buf)
+int mips32_set_core_reg(reg_t *reg, uint8_t *buf)
 {
 	mips32_core_reg_t *mips32_reg = reg-&gt;arch_info;
 	target_t *target = mips32_reg-&gt;target;

Modified: trunk/src/target/mips32_dmaacc.c
===================================================================
--- trunk/src/target/mips32_dmaacc.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips32_dmaacc.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -137,7 +137,7 @@
 	return ERROR_OK;
 }
 
-static int ejtag_dma_read_b(mips_ejtag_t *ejtag_info, u32 addr, u8 *data)
+static int ejtag_dma_read_b(mips_ejtag_t *ejtag_info, u32 addr, uint8_t *data)
 {
 	u32 v;
 	u32 ejtag_ctrl;
@@ -354,7 +354,7 @@
 	switch (size)
 	{
 		case 1:
-			return mips32_dmaacc_read_mem8(ejtag_info, addr, count, (u8*)buf);
+			return mips32_dmaacc_read_mem8(ejtag_info, addr, count, (uint8_t*)buf);
 		case 2:
 			return mips32_dmaacc_read_mem16(ejtag_info, addr, count, (u16*)buf);
 		case 4:
@@ -390,7 +390,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf)
+int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
 {
 	int i;
 	int retval;
@@ -408,7 +408,7 @@
 	switch (size)
 	{
 		case 1:
-			return mips32_dmaacc_write_mem8(ejtag_info, addr, count, (u8*)buf);
+			return mips32_dmaacc_write_mem8(ejtag_info, addr, count, (uint8_t*)buf);
 		case 2:
 			return mips32_dmaacc_write_mem16(ejtag_info, addr, count,(u16*)buf);
 		case 4:
@@ -444,7 +444,7 @@
 	return ERROR_OK;
 }
 
-int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf)
+int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
 {
 	int i;
 	int retval;

Modified: trunk/src/target/mips32_dmaacc.h
===================================================================
--- trunk/src/target/mips32_dmaacc.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips32_dmaacc.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -37,11 +37,11 @@
 extern int mips32_dmaacc_read_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
 extern int mips32_dmaacc_write_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
 
-extern int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
+extern int mips32_dmaacc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
 extern int mips32_dmaacc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_dmaacc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
 
-extern int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
+extern int mips32_dmaacc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
 extern int mips32_dmaacc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_dmaacc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
 

Modified: trunk/src/target/mips32_pracc.c
===================================================================
--- trunk/src/target/mips32_pracc.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips32_pracc.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -274,7 +274,7 @@
 	switch (size)
 	{
 		case 1:
-			return mips32_pracc_read_mem8(ejtag_info, addr, count, (u8*)buf);
+			return mips32_pracc_read_mem8(ejtag_info, addr, count, (uint8_t*)buf);
 		case 2:
 			return mips32_pracc_read_mem16(ejtag_info, addr, count, (u16*)buf);
 		case 4:
@@ -474,7 +474,7 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf)
+int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
 {
 	u32 code[] = {
 															/* start: */
@@ -558,7 +558,7 @@
 	switch (size)
 	{
 		case 1:
-			return mips32_pracc_write_mem8(ejtag_info, addr, count, (u8*)buf);
+			return mips32_pracc_write_mem8(ejtag_info, addr, count, (uint8_t*)buf);
 		case 2:
 			return mips32_pracc_write_mem16(ejtag_info, addr, count,(u16*)buf);
 		case 4:
@@ -713,7 +713,7 @@
 	return ERROR_OK;
 }
 
-int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf)
+int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf)
 {
 	u32 code[] = {
 															/* start: */

Modified: trunk/src/target/mips32_pracc.h
===================================================================
--- trunk/src/target/mips32_pracc.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips32_pracc.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -40,12 +40,12 @@
 extern int mips32_pracc_read_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
 extern int mips32_pracc_write_mem(mips_ejtag_t *ejtag_info, u32 addr, int size, int count, void *buf);
 
-extern int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
+extern int mips32_pracc_read_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
 extern int mips32_pracc_read_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_pracc_read_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
 extern int mips32_pracc_read_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);
 
-extern int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, u8 *buf);
+extern int mips32_pracc_write_mem8(mips_ejtag_t *ejtag_info, u32 addr, int count, uint8_t *buf);
 extern int mips32_pracc_write_mem16(mips_ejtag_t *ejtag_info, u32 addr, int count, u16 *buf);
 extern int mips32_pracc_write_mem32(mips_ejtag_t *ejtag_info, u32 addr, int count, u32 *buf);
 extern int mips32_pracc_write_u32(mips_ejtag_t *ejtag_info, u32 addr, u32 *buf);

Modified: trunk/src/target/mips_ejtag.c
===================================================================
--- trunk/src/target/mips_ejtag.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips_ejtag.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -38,7 +38,7 @@
 	if (buf_get_u32(tap-&gt;cur_instr, 0, tap-&gt;ir_length) != (u32)new_instr)
 	{
 		scan_field_t field;
-		u8 t[4];
+		uint8_t t[4];
 
 		field.tap = tap;
 		field.num_bits = tap-&gt;ir_length;
@@ -118,7 +118,7 @@
 	if (tap==NULL)
 		return ERROR_FAIL;
 	scan_field_t field;
-	u8 t[4], r[4];
+	uint8_t t[4], r[4];
 	int retval;
 
 	field.tap = tap;

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips_m4k.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -37,8 +37,8 @@
 int mips_m4k_soft_reset_halt(struct target_s *target);
 int mips_m4k_resume(struct target_s *target, int current, u32 address, int handle_breakpoints, int debug_execution);
 int mips_m4k_step(struct target_s *target, int current, u32 address, int handle_breakpoints);
-int mips_m4k_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int mips_m4k_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+int mips_m4k_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int mips_m4k_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 int mips_m4k_register_commands(struct command_context_s *cmd_ctx);
 int mips_m4k_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int mips_m4k_quit(void);
@@ -613,7 +613,7 @@
 			u32 current_instr;
 			
 			/* check that user program has not modified breakpoint instruction */
-			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, (u8*)&amp;current_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint-&gt;address, 4, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -630,7 +630,7 @@
 			u16 current_instr;
 			
 			/* check that user program has not modified breakpoint instruction */
-			if ((retval = target_read_memory(target, breakpoint-&gt;address, 2, 1, (u8*)&amp;current_instr)) != ERROR_OK)
+			if ((retval = target_read_memory(target, breakpoint-&gt;address, 2, 1, (uint8_t*)&amp;current_instr)) != ERROR_OK)
 			{
 				return retval;
 			}
@@ -728,7 +728,7 @@
 	}
 }
 
-int mips_m4k_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int mips_m4k_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
@@ -782,7 +782,7 @@
 	return ERROR_OK;
 }
 
-int mips_m4k_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int mips_m4k_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
@@ -904,7 +904,7 @@
 	return ERROR_OK;
 }
 
-int mips_m4k_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer)
+int mips_m4k_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
 {
 	return mips_m4k_write_memory(target, address, 4, count, buffer);
 }

Modified: trunk/src/target/mips_m4k.h
===================================================================
--- trunk/src/target/mips_m4k.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/mips_m4k.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -35,7 +35,7 @@
 	mips32_common_t mips32_common;
 } mips_m4k_common_t;
 
-extern int mips_m4k_bulk_write_memory(struct target_s *target, u32 address, u32 count, u8 *buffer);
+extern int mips_m4k_bulk_write_memory(struct target_s *target, u32 address, u32 count, uint8_t *buffer);
 
 extern void mips_m4k_enable_breakpoints(struct target_s *target);
 extern int mips_m4k_set_breakpoint(struct target_s *target, breakpoint_t *breakpoint);

Modified: trunk/src/target/oocd_trace.c
===================================================================
--- trunk/src/target/oocd_trace.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/oocd_trace.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -35,7 +35,7 @@
 static int oocd_trace_read_reg(oocd_trace_t *oocd_trace, int reg, u32 *value)
 {
 	size_t bytes_written, bytes_read, bytes_to_read;
-	u8 cmd;
+	uint8_t cmd;
 
 	cmd = 0x10 | (reg &amp; 0x7);
 	bytes_written = write(oocd_trace-&gt;tty_fd, &amp;cmd, 1);
@@ -43,7 +43,7 @@
 	bytes_to_read = 4;
 	while (bytes_to_read &gt; 0)
 	{
-		bytes_read = read(oocd_trace-&gt;tty_fd, ((u8*)value) + 4 - bytes_to_read, bytes_to_read);
+		bytes_read = read(oocd_trace-&gt;tty_fd, ((uint8_t*)value) + 4 - bytes_to_read, bytes_to_read);
 		bytes_to_read -= bytes_read;
 	}
 
@@ -55,7 +55,7 @@
 static int oocd_trace_write_reg(oocd_trace_t *oocd_trace, int reg, u32 value)
 {
 	size_t bytes_written;
-	u8 data[5];
+	uint8_t data[5];
 
 	data[0] = 0x18 | (reg &amp; 0x7);
 	data[1] = value &amp; 0xff;
@@ -69,11 +69,11 @@
 	return ERROR_OK;
 }
 
-static int oocd_trace_read_memory(oocd_trace_t *oocd_trace, u8 *data, u32 address, u32 size)
+static int oocd_trace_read_memory(oocd_trace_t *oocd_trace, uint8_t *data, u32 address, u32 size)
 {
 	size_t bytes_written, bytes_to_read;
 	ssize_t bytes_read;
-	u8 cmd;
+	uint8_t cmd;
 
 	oocd_trace_write_reg(oocd_trace, OOCD_TRACE_ADDRESS, address);
 	oocd_trace_write_reg(oocd_trace, OOCD_TRACE_SDRAM_COUNTER, size);
@@ -85,7 +85,7 @@
 	while (bytes_to_read &gt; 0)
 	{
 		if ((bytes_read = read(oocd_trace-&gt;tty_fd,
-				((u8*)data) + (size * 16) - bytes_to_read, bytes_to_read)) &lt; 0)
+				((uint8_t*)data) + (size * 16) - bytes_to_read, bytes_to_read)) &lt; 0)
 		{
 			LOG_DEBUG(&quot;read() returned %zi (%s)&quot;, bytes_read, strerror(errno));
 		}
@@ -98,7 +98,7 @@
 
 static int oocd_trace_init(etm_context_t *etm_ctx)
 {
-	u8 trash[256];
+	uint8_t trash[256];
 	oocd_trace_t *oocd_trace = etm_ctx-&gt;capture_driver_priv;
 	size_t bytes_read;
 
@@ -181,7 +181,7 @@
 	u32 status, address;
 	u32 first_frame = 0x0;
 	u32 num_frames = 1048576;
-	u8 *trace_data;
+	uint8_t *trace_data;
 	u32 i;
 
 	oocd_trace_read_reg(oocd_trace, OOCD_TRACE_STATUS, &amp;status);
@@ -199,7 +199,7 @@
 	/* read data into temporary array for unpacking
 	 * one frame from OpenOCD+trace corresponds to 16 trace cycles
 	 */
-	trace_data = malloc(sizeof(u8) * num_frames * 16);
+	trace_data = malloc(sizeof(uint8_t) * num_frames * 16);
 	oocd_trace_read_memory(oocd_trace, trace_data, first_frame, num_frames);
 
 	if (etm_ctx-&gt;trace_depth &gt; 0)
@@ -374,7 +374,7 @@
 	arm7_9_common_t *arm7_9;
 	oocd_trace_t *oocd_trace;
 	size_t bytes_written;
-	u8 cmd_array[1];
+	uint8_t cmd_array[1];
 
 	target = get_current_target(cmd_ctx);
 

Modified: trunk/src/target/register.c
===================================================================
--- trunk/src/target/register.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/register.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -65,7 +65,7 @@
 	return cache_p;
 }
 
-int register_reg_arch_type(int (*get)(reg_t *reg), int (*set)(reg_t *reg, u8 *buf))
+int register_reg_arch_type(int (*get)(reg_t *reg), int (*set)(reg_t *reg, uint8_t *buf))
 {
 	reg_arch_type_t** arch_type_p = &amp;reg_arch_types;
 	int id = 0;
@@ -108,7 +108,7 @@
 	return ERROR_OK;
 }
 
-static int register_set_dummy_core_reg(reg_t *reg, u8 *buf)
+static int register_set_dummy_core_reg(reg_t *reg, uint8_t *buf)
 {
 	reg-&gt;dirty = 1;
 	reg-&gt;valid = 1;

Modified: trunk/src/target/register.h
===================================================================
--- trunk/src/target/register.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/register.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -58,13 +58,13 @@
 {
 	int id;
 	int (*get)(reg_t *reg);
-	int (*set)(reg_t *reg, u8 *buf);
+	int (*set)(reg_t *reg, uint8_t *buf);
 	struct reg_arch_type_s *next;
 } reg_arch_type_t;
 
 extern reg_t* register_get_by_name(reg_cache_t *first, char *name, int search_all);
 extern reg_cache_t** register_get_last_cache_p(reg_cache_t **first);
-extern int register_reg_arch_type(int (*get)(reg_t *reg), int (*set)(reg_t *reg, u8 *buf));
+extern int register_reg_arch_type(int (*get)(reg_t *reg), int (*set)(reg_t *reg, uint8_t *buf));
 extern reg_arch_type_t* register_get_arch_type(int id);
 extern void register_init_dummy(reg_t *reg);
 

Modified: trunk/src/target/target.c
===================================================================
--- trunk/src/target/target.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/target.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -272,7 +272,7 @@
 static int target_continuous_poll = 1;
 
 /* read a u32 from a buffer in target memory endianness */
-u32 target_buffer_get_u32(target_t *target, const u8 *buffer)
+u32 target_buffer_get_u32(target_t *target, const uint8_t *buffer)
 {
 	if (target-&gt;endianness == TARGET_LITTLE_ENDIAN)
 		return le_to_h_u32(buffer);
@@ -281,7 +281,7 @@
 }
 
 /* read a u16 from a buffer in target memory endianness */
-u16 target_buffer_get_u16(target_t *target, const u8 *buffer)
+u16 target_buffer_get_u16(target_t *target, const uint8_t *buffer)
 {
 	if (target-&gt;endianness == TARGET_LITTLE_ENDIAN)
 		return le_to_h_u16(buffer);
@@ -289,14 +289,14 @@
 		return be_to_h_u16(buffer);
 }
 
-/* read a u8 from a buffer in target memory endianness */
-u8 target_buffer_get_u8(target_t *target, const u8 *buffer)
+/* read a uint8_t from a buffer in target memory endianness */
+uint8_t target_buffer_get_u8(target_t *target, const uint8_t *buffer)
 {
 	return *buffer &amp; 0x0ff;
 }
 
 /* write a u32 to a buffer in target memory endianness */
-void target_buffer_set_u32(target_t *target, u8 *buffer, u32 value)
+void target_buffer_set_u32(target_t *target, uint8_t *buffer, u32 value)
 {
 	if (target-&gt;endianness == TARGET_LITTLE_ENDIAN)
 		h_u32_to_le(buffer, value);
@@ -305,7 +305,7 @@
 }
 
 /* write a u16 to a buffer in target memory endianness */
-void target_buffer_set_u16(target_t *target, u8 *buffer, u16 value)
+void target_buffer_set_u16(target_t *target, uint8_t *buffer, u16 value)
 {
 	if (target-&gt;endianness == TARGET_LITTLE_ENDIAN)
 		h_u16_to_le(buffer, value);
@@ -313,8 +313,8 @@
 		h_u16_to_be(buffer, value);
 }
 
-/* write a u8 to a buffer in target memory endianness */
-void target_buffer_set_u8(target_t *target, u8 *buffer, u8 value)
+/* write a uint8_t to a buffer in target memory endianness */
+void target_buffer_set_u8(target_t *target, uint8_t *buffer, uint8_t value)
 {
 	*buffer = value;
 }
@@ -518,7 +518,7 @@
 	return target-&gt;type-&gt;name;
 }
 
-static int target_write_memory_imp(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+static int target_write_memory_imp(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	if (!target_was_examined(target))
 	{
@@ -528,7 +528,7 @@
 	return target-&gt;type-&gt;write_memory_imp(target, address, size, count, buffer);
 }
 
-static int target_read_memory_imp(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+static int target_read_memory_imp(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	if (!target_was_examined(target))
 	{
@@ -559,18 +559,18 @@
 }
 
 int target_read_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, u8 *buffer)
+		u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	return target-&gt;type-&gt;read_memory(target, address, size, count, buffer);
 }
 
 int target_write_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, u8 *buffer)
+		u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	return target-&gt;type-&gt;write_memory(target, address, size, count, buffer);
 }
 int target_bulk_write_memory(struct target_s *target,
-		u32 address, u32 count, u8 *buffer)
+		u32 address, u32 count, uint8_t *buffer)
 {
 	return target-&gt;type-&gt;bulk_write_memory(target, address, count, buffer);
 }
@@ -1096,7 +1096,7 @@
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_write_buffer(struct target_s *target, u32 address, u32 size, u8 *buffer)
+int target_write_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer)
 {
 	int retval;
 	LOG_DEBUG(&quot;writing buffer of %i byte at 0x%8.8x&quot;, size, address);
@@ -1175,7 +1175,7 @@
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_read_buffer(struct target_s *target, u32 address, u32 size, u8 *buffer)
+int target_read_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer)
 {
 	int retval;
 	LOG_DEBUG(&quot;reading buffer of %i byte at 0x%8.8x&quot;, size, address);
@@ -1243,7 +1243,7 @@
 
 int target_checksum_memory(struct target_s *target, u32 address, u32 size, u32* crc)
 {
-	u8 *buffer;
+	uint8_t *buffer;
 	int retval;
 	u32 i;
 	u32 checksum = 0;
@@ -1305,7 +1305,7 @@
 
 int target_read_u32(struct target_s *target, u32 address, u32 *value)
 {
-	u8 value_buf[4];
+	uint8_t value_buf[4];
 	if (!target_was_examined(target))
 	{
 		LOG_ERROR(&quot;Target not examined yet&quot;);
@@ -1330,7 +1330,7 @@
 
 int target_read_u16(struct target_s *target, u32 address, u16 *value)
 {
-	u8 value_buf[2];
+	uint8_t value_buf[2];
 	if (!target_was_examined(target))
 	{
 		LOG_ERROR(&quot;Target not examined yet&quot;);
@@ -1353,7 +1353,7 @@
 	return retval;
 }
 
-int target_read_u8(struct target_s *target, u32 address, u8 *value)
+int target_read_u8(struct target_s *target, u32 address, uint8_t *value)
 {
 	int retval = target_read_memory(target, address, 1, 1, value);
 	if (!target_was_examined(target))
@@ -1378,7 +1378,7 @@
 int target_write_u32(struct target_s *target, u32 address, u32 value)
 {
 	int retval;
-	u8 value_buf[4];
+	uint8_t value_buf[4];
 	if (!target_was_examined(target))
 	{
 		LOG_ERROR(&quot;Target not examined yet&quot;);
@@ -1399,7 +1399,7 @@
 int target_write_u16(struct target_s *target, u32 address, u16 value)
 {
 	int retval;
-	u8 value_buf[2];
+	uint8_t value_buf[2];
 	if (!target_was_examined(target))
 	{
 		LOG_ERROR(&quot;Target not examined yet&quot;);
@@ -1417,7 +1417,7 @@
 	return retval;
 }
 
-int target_write_u8(struct target_s *target, u32 address, u8 value)
+int target_write_u8(struct target_s *target, u32 address, uint8_t value)
 {
 	int retval;
 	if (!target_was_examined(target))
@@ -1782,7 +1782,7 @@
 	/* set register value */
 	if (argc == 2)
 	{
-		u8 *buf = malloc(CEIL(reg-&gt;size, 8));
+		uint8_t *buf = malloc(CEIL(reg-&gt;size, 8));
 		str_to_buf(args[1], strlen(args[1]), buf, reg-&gt;size, 0);
 
 		reg_arch_type_t *arch_type = register_get_arch_type(reg-&gt;arch_type);
@@ -2011,7 +2011,7 @@
 
 static void handle_md_output(struct command_context_s *cmd_ctx,
 		struct target_s *target, u32 address, unsigned size,
-		unsigned count, const u8 *buffer)
+		unsigned count, const uint8_t *buffer)
 {
 	const unsigned line_bytecnt = 32;
 	unsigned line_modulo = line_bytecnt / size;
@@ -2039,7 +2039,7 @@
 		}
 
 		u32 value=0;
-		const u8 *value_ptr = buffer + i * size;
+		const uint8_t *value_ptr = buffer + i * size;
 		switch (size) {
 		case 4: value = target_buffer_get_u32(target, value_ptr); break;
 		case 2: value = target_buffer_get_u16(target, value_ptr); break;
@@ -2083,7 +2083,7 @@
 			return retval;
 	}
 
-	u8 *buffer = calloc(count, size);
+	uint8_t *buffer = calloc(count, size);
 
 	target_t *target = get_current_target(cmd_ctx);
 	retval = target_read_memory(target,
@@ -2121,7 +2121,7 @@
 
 	target_t *target = get_current_target(cmd_ctx);
 	unsigned wordsize;
-	u8 value_buf[4];
+	uint8_t value_buf[4];
 	switch (cmd[2])
 	{
 		case 'w':
@@ -2197,7 +2197,7 @@
 
 static int handle_load_image_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u8 *buffer;
+	uint8_t *buffer;
 	u32 buf_cnt;
 	u32 image_size;
 	u32 min_address = 0;
@@ -2294,7 +2294,7 @@
 {
 	fileio_t fileio;
 
-	u8 buffer[560];
+	uint8_t buffer[560];
 	int retvaltemp;
 
 	duration_t duration;
@@ -2364,7 +2364,7 @@
 
 static int handle_verify_image_command_internal(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc, int verify)
 {
-	u8 *buffer;
+	uint8_t *buffer;
 	u32 buf_cnt;
 	u32 image_size;
 	int i;
@@ -2445,11 +2445,11 @@
 			if( checksum != mem_checksum )
 			{
 				/* failed crc checksum, fall back to a binary compare */
-				u8 *data;
+				uint8_t *data;
 
 				command_print(cmd_ctx, &quot;checksum mismatch - attempting binary compare&quot;);
 
-				data = (u8*)malloc(buf_cnt);
+				data = (uint8_t*)malloc(buf_cnt);
 
 				/* Can we use 32bit word accesses? */
 				int size = 1;
@@ -2760,7 +2760,7 @@
 	writeLong(f, 0); /* padding */
 	writeLong(f, 0); /* padding */
 
-	u8 zero = 0;  /* GMON_TAG_TIME_HIST */
+	uint8_t zero = 0;  /* GMON_TAG_TIME_HIST */
 	writeData(f, &amp;zero, 1);
 
 	/* figure out bucket size */
@@ -2984,7 +2984,7 @@
 	u32 count;
 	u32 v;
 	const char *varname;
-	u8 buffer[4096];
+	uint8_t buffer[4096];
 	int  n, e, retval;
 	u32 i;
 
@@ -3166,7 +3166,7 @@
 	u32 count;
 	u32 v;
 	const char *varname;
-	u8 buffer[4096];
+	uint8_t buffer[4096];
 	int  n, e, retval;
 	u32 i;
 
@@ -3634,7 +3634,7 @@
 	Jim_GetOptInfo goi;
 	jim_wide a,b,c;
 	int x,y,z;
-	u8  target_buf[32];
+	uint8_t  target_buf[32];
 	Jim_Nvp *n;
 	target_t *target;
 	struct command_context_s *cmd_ctx;
@@ -4310,7 +4310,7 @@
 struct FastLoad
 {
 	u32 address;
-	u8 *data;
+	uint8_t *data;
 	int length;
 
 };
@@ -4338,7 +4338,7 @@
 
 static int handle_fast_load_image_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
 {
-	u8 *buffer;
+	uint8_t *buffer;
 	u32 buf_cnt;
 	u32 image_size;
 	u32 min_address=0;

Modified: trunk/src/target/target.h
===================================================================
--- trunk/src/target/target.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/target.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -100,7 +100,7 @@
 	u32 address;
 	u32 size;
 	int free;
-	u8 *backup;
+	uint8_t *backup;
 	struct working_area_s **user;
 	struct working_area_s *next;
 } working_area_t;
@@ -331,7 +331,7 @@
  * This routine is a wrapper for target-&gt;type-&gt;read_memory.
  */
 extern int target_read_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, u8 *buffer);
+		u32 address, u32 size, u32 count, uint8_t *buffer);
 /**
  * Write @a count items of @a size bytes to the memory of @a target at
  * the @a address given.
@@ -339,7 +339,7 @@
  * This routine is wrapper for target-&gt;type-&gt;write_memory.
  */
 extern int target_write_memory(struct target_s *target,
-		u32 address, u32 size, u32 count, u8 *buffer);
+		u32 address, u32 size, u32 count, uint8_t *buffer);
 
 /**
  * Write @a count items of 4 bytes to the memory of @a target at
@@ -349,10 +349,10 @@
  * This routine is wrapper for target-&gt;type-&gt;bulk_write_memory.
  */
 extern int target_bulk_write_memory(struct target_s *target,
-		u32 address, u32 count, u8 *buffer);
+		u32 address, u32 count, uint8_t *buffer);
 
-extern int target_write_buffer(struct target_s *target, u32 address, u32 size, u8 *buffer);
-extern int target_read_buffer(struct target_s *target, u32 address, u32 size, u8 *buffer);
+extern int target_write_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer);
+extern int target_read_buffer(struct target_s *target, u32 address, u32 size, uint8_t *buffer);
 extern int target_checksum_memory(struct target_s *target, u32 address, u32 size, u32* crc);
 extern int target_blank_check_memory(struct target_s *target, u32 address, u32 size, u32* blank);
 extern int target_wait_state(target_t *target, enum target_state state, int ms);
@@ -379,19 +379,19 @@
 extern target_event_callback_t *target_event_callbacks;
 extern target_timer_callback_t *target_timer_callbacks;
 
-extern u32 target_buffer_get_u32(target_t *target, const u8 *buffer);
-extern u16 target_buffer_get_u16(target_t *target, const u8 *buffer);
-extern u8  target_buffer_get_u8 (target_t *target, const u8 *buffer);
-extern void target_buffer_set_u32(target_t *target, u8 *buffer, u32 value);
-extern void target_buffer_set_u16(target_t *target, u8 *buffer, u16 value);
-extern void target_buffer_set_u8 (target_t *target, u8 *buffer, u8  value);
+extern u32 target_buffer_get_u32(target_t *target, const uint8_t *buffer);
+extern u16 target_buffer_get_u16(target_t *target, const uint8_t *buffer);
+extern uint8_t  target_buffer_get_u8 (target_t *target, const uint8_t *buffer);
+extern void target_buffer_set_u32(target_t *target, uint8_t *buffer, u32 value);
+extern void target_buffer_set_u16(target_t *target, uint8_t *buffer, u16 value);
+extern void target_buffer_set_u8 (target_t *target, uint8_t *buffer, uint8_t  value);
 
 int target_read_u32(struct target_s *target, u32 address, u32 *value);
 int target_read_u16(struct target_s *target, u32 address, u16 *value);
-int target_read_u8(struct target_s *target, u32 address, u8 *value);
+int target_read_u8(struct target_s *target, u32 address, uint8_t *value);
 int target_write_u32(struct target_s *target, u32 address, u32 value);
 int target_write_u16(struct target_s *target, u32 address, u16 value);
-int target_write_u8(struct target_s *target, u32 address, u8 value);
+int target_write_u8(struct target_s *target, u32 address, uint8_t value);
 
 /* Issues USER() statements with target state information */
 int target_arch_state(struct target_s *target);

Modified: trunk/src/target/target_request.c
===================================================================
--- trunk/src/target/target_request.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/target_request.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -42,7 +42,7 @@
 	char *msg = malloc(CEIL(length + 1, 4) * 4);
 	debug_msg_receiver_t *c = target-&gt;dbgmsg;
 
-	target-&gt;type-&gt;target_request_data(target, CEIL(length, 4), (u8*)msg);
+	target-&gt;type-&gt;target_request_data(target, CEIL(length, 4), (uint8_t*)msg);
 	msg[length] = 0;
 
 	LOG_DEBUG(&quot;%s&quot;, msg);
@@ -56,7 +56,7 @@
 	return ERROR_OK;
 }
 
-static int target_charmsg(target_t *target, u8 msg)
+static int target_charmsg(target_t *target, uint8_t msg)
 {
 	LOG_USER_N(&quot;%c&quot;, msg);
 
@@ -65,7 +65,7 @@
 
 static int target_hexmsg(target_t *target, int size, u32 length)
 {
-	u8 *data = malloc(CEIL(length * size, 4) * 4);
+	uint8_t *data = malloc(CEIL(length * size, 4) * 4);
 	char line[128];
 	int line_len;
 	debug_msg_receiver_t *c = target-&gt;dbgmsg;
@@ -73,7 +73,7 @@
 
 	LOG_DEBUG(&quot;size: %i, length: %i&quot;, size, length);
 
-	target-&gt;type-&gt;target_request_data(target, CEIL(length * size, 4), (u8*)data);
+	target-&gt;type-&gt;target_request_data(target, CEIL(length * size, 4), (uint8_t*)data);
 
 	line_len = 0;
 	for (i = 0; i &lt; length; i++)

Modified: trunk/src/target/target_type.h
===================================================================
--- trunk/src/target/target_type.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/target_type.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -28,7 +28,7 @@
 	int (*arch_state)(struct target_s *target);
 
 	/* target request support */
-	int (*target_request_data)(struct target_s *target, u32 size, u8 *buffer);
+	int (*target_request_data)(struct target_s *target, u32 size, uint8_t *buffer);
 
 	/* halt will log a warning, but return ERROR_OK if the target is already halted. */
 	int (*halt)(struct target_s *target);
@@ -72,25 +72,25 @@
 	* size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
 	* count: number of items of &lt;size&gt;
 	*/
-	int (*read_memory_imp)(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+	int (*read_memory_imp)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 	/**
 	 * Target memory read callback.  Do @b not call this function
 	 * directly, use target_read_memory() instead.
 	 */
-	int (*read_memory)(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-	int (*write_memory_imp)(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+	int (*read_memory)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+	int (*write_memory_imp)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 	/**
 	 * Target memory write callback.  Do @b not call this function
 	 * directly, use target_write_memory() instead.
 	 */
-	int (*write_memory)(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
+	int (*write_memory)(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
 
 	/**
 	 * Write target memory in multiples of 4 bytes, optimized for
 	 * writing large quantities of data.  Do @b not call this
 	 * function directly, use target_bulk_write_memory() instead.
 	 */
-	int (*bulk_write_memory)(struct target_s *target, u32 address, u32 count, u8 *buffer);
+	int (*bulk_write_memory)(struct target_s *target, u32 address, u32 count, uint8_t *buffer);
 
 	int (*checksum_memory)(struct target_s *target, u32 address, u32 count, u32* checksum);
 	int (*blank_check_memory)(struct target_s *target, u32 address, u32 count, u32* blank);

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/xscale.c	2009-06-18 07:04:08 UTC (rev 2274)
@@ -57,9 +57,9 @@
 int xscale_read_core_reg(struct target_s *target, int num, enum armv4_5_mode mode);
 int xscale_write_core_reg(struct target_s *target, int num, enum armv4_5_mode mode, u32 value);
 
-int xscale_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int xscale_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer);
-int xscale_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer);
+int xscale_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int xscale_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer);
+int xscale_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer);
 
 int xscale_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
 int xscale_remove_breakpoint(struct target_s *target, breakpoint_t *breakpoint);
@@ -170,7 +170,7 @@
 int xscale_reg_arch_type = -1;
 
 int xscale_get_reg(reg_t *reg);
-int xscale_set_reg(reg_t *reg, u8 *buf);
+int xscale_set_reg(reg_t *reg, uint8_t *buf);
 
 int xscale_get_arch_pointers(target_t *target, armv4_5_common_t **armv4_5_p, xscale_common_t **xscale_p)
 {
@@ -209,7 +209,7 @@
 		field.out_value = calloc(CEIL(field.num_bits, 8), 1);
 		buf_set_u32(field.out_value, 0, field.num_bits, new_instr);
 
-		u8 tmp[4];
+		uint8_t tmp[4];
 		field.in_value = tmp;
 
 		jtag_add_ir_scan(1, &amp;field, jtag_get_end_state());
@@ -231,12 +231,12 @@
 	int retval;
 
 	scan_field_t fields[3];
-	u8 field0 = 0x0;
-	u8 field0_check_value = 0x2;
-	u8 field0_check_mask = 0x7;
-	u8 field2 = 0x0;
-	u8 field2_check_value = 0x0;
-	u8 field2_check_mask = 0x1;
+	uint8_t field0 = 0x0;
+	uint8_t field0_check_value = 0x2;
+	uint8_t field0_check_mask = 0x7;
+	uint8_t field2 = 0x0;
+	uint8_t field2_check_value = 0x0;
+	uint8_t field2_check_mask = 0x1;
 
 	jtag_set_end_state(TAP_DRPAUSE);
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dcsr);
@@ -247,7 +247,7 @@
 	fields[0].tap = xscale-&gt;jtag_info.tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &amp;field0;
-	u8 tmp;
+	uint8_t tmp;
 	fields[0].in_value = &tmp;
 
 	fields[1].tap = xscale-&gt;jtag_info.tap;
@@ -259,7 +259,7 @@
 	fields[2].tap = xscale-&gt;jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;field2;
-	u8 tmp2;
+	uint8_t tmp2;
 	fields[2].in_value = &amp;tmp2;
 
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
@@ -293,7 +293,7 @@
 }
 
 
-static void xscale_getbuf(u8 *in)
+static void xscale_getbuf(uint8_t *in)
 {
 	*((u32 *)in)=buf_get_u32(in, 0, 32);
 }
@@ -310,12 +310,12 @@
 	tap_state_t path[3];
 	scan_field_t fields[3];
 
-	u8 *field0 = malloc(num_words * 1);
-	u8 field0_check_value = 0x2;
-	u8 field0_check_mask = 0x6;
+	uint8_t *field0 = malloc(num_words * 1);
+	uint8_t field0_check_value = 0x2;
+	uint8_t field0_check_mask = 0x6;
 	u32 *field1 = malloc(num_words * 4);
-	u8 field2_check_value = 0x0;
-	u8 field2_check_mask = 0x1;
+	uint8_t field2_check_value = 0x0;
+	uint8_t field2_check_mask = 0x1;
 	int words_done = 0;
 	int words_scheduled = 0;
 
@@ -361,11 +361,11 @@
 
 			jtag_add_pathmove(3, path);
 
-			fields[1].in_value = (u8 *)(field1+i);
+			fields[1].in_value = (uint8_t *)(field1+i);
 
 			jtag_add_dr_scan_check(3, fields, jtag_set_end_state(TAP_IDLE));
 
-			jtag_add_callback(xscale_getbuf, (u8 *)(field1+i));
+			jtag_add_callback(xscale_getbuf, (uint8_t *)(field1+i));
 
 			words_scheduled++;
 		}
@@ -405,7 +405,7 @@
 	}
 
 	for (i = 0; i &lt; num_words; i++)
-		*(buffer++) = buf_get_u32((u8*)&amp;field1[i], 0, 32);
+		*(buffer++) = buf_get_u32((uint8_t*)&amp;field1[i], 0, 32);
 
 	free(field1);
 
@@ -423,11 +423,11 @@
 	struct timeval timeout, now;
 
 	scan_field_t fields[3];
-	u8 field0_in = 0x0;
-	u8 field0_check_value = 0x2;
-	u8 field0_check_mask = 0x6;
-	u8 field2_check_value = 0x0;
-	u8 field2_check_mask = 0x1;
+	uint8_t field0_in = 0x0;
+	uint8_t field0_check_value = 0x2;
+	uint8_t field0_check_mask = 0x6;
+	uint8_t field2_check_value = 0x0;
+	uint8_t field2_check_mask = 0x1;
 
 	jtag_set_end_state(TAP_IDLE);
 
@@ -458,7 +458,7 @@
 	fields[2].tap = xscale-&gt;jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = NULL;
-	u8 tmp;
+	uint8_t tmp;
 	fields[2].in_value = &tmp;
 
 	gettimeofday(&amp;timeout, NULL);
@@ -524,13 +524,13 @@
 	struct timeval timeout, now;
 
 	scan_field_t fields[3];
-	u8 field0_out = 0x0;
-	u8 field0_in = 0x0;
-	u8 field0_check_value = 0x2;
-	u8 field0_check_mask = 0x6;
-	u8 field2 = 0x0;
-	u8 field2_check_value = 0x0;
-	u8 field2_check_mask = 0x1;
+	uint8_t field0_out = 0x0;
+	uint8_t field0_in = 0x0;
+	uint8_t field0_check_value = 0x2;
+	uint8_t field0_check_mask = 0x6;
+	uint8_t field2 = 0x0;
+	uint8_t field2_check_value = 0x0;
+	uint8_t field2_check_mask = 0x1;
 
 	jtag_set_end_state(TAP_IDLE);
 
@@ -550,7 +550,7 @@
 	fields[2].tap = xscale-&gt;jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;field2;
-	u8 tmp;
+	uint8_t tmp;
 	fields[2].in_value = &tmp;
 
 	gettimeofday(&amp;timeout, NULL);
@@ -604,7 +604,7 @@
 }
 
 /* send count elements of size byte to the debug handler */
-int xscale_send(target_t *target, u8 *buffer, int count, int size)
+int xscale_send(target_t *target, uint8_t *buffer, int count, int size)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
@@ -688,12 +688,12 @@
 	int retval;
 
 	scan_field_t fields[3];
-	u8 field0 = 0x0;
-	u8 field0_check_value = 0x2;
-	u8 field0_check_mask = 0x7;
-	u8 field2 = 0x0;
-	u8 field2_check_value = 0x0;
-	u8 field2_check_mask = 0x1;
+	uint8_t field0 = 0x0;
+	uint8_t field0_check_value = 0x2;
+	uint8_t field0_check_mask = 0x7;
+	uint8_t field2 = 0x0;
+	uint8_t field2_check_value = 0x0;
+	uint8_t field2_check_mask = 0x1;
 
 	if (hold_rst != -1)
 		xscale-&gt;hold_rst = hold_rst;
@@ -710,7 +710,7 @@
 	fields[0].tap = xscale-&gt;jtag_info.tap;
 	fields[0].num_bits = 3;
 	fields[0].out_value = &amp;field0;
-	u8 tmp;
+	uint8_t tmp;
 	fields[0].in_value = &tmp;
 
 	fields[1].tap = xscale-&gt;jtag_info.tap;
@@ -722,7 +722,7 @@
 	fields[2].tap = xscale-&gt;jtag_info.tap;
 	fields[2].num_bits = 1;
 	fields[2].out_value = &amp;field2;
-	u8 tmp2;
+	uint8_t tmp2;
 	fields[2].in_value = &amp;tmp2;
 
 	jtag_add_dr_scan(3, fields, jtag_get_end_state());
@@ -758,8 +758,8 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u8 packet[4];
-	u8 cmd;
+	uint8_t packet[4];
+	uint8_t cmd;
 	int word;
 
 	scan_field_t fields[2];
@@ -828,8 +828,8 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u8 packet[4];
-	u8 cmd;
+	uint8_t packet[4];
+	uint8_t cmd;
 
 	scan_field_t fields[2];
 
@@ -1678,7 +1678,7 @@
 		while (binary_size &gt; 0)
 		{
 			u32 cache_line[8];
-			u8 buffer[32];
+			uint8_t buffer[32];
 
 			if ((retval = fileio_read(&amp;debug_handler, 32, buffer, &amp;buf_cnt)) != ERROR_OK)
 			{
@@ -1905,7 +1905,7 @@
 	return ERROR_OK;
 }
 
-int xscale_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int xscale_read_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
@@ -1984,7 +1984,7 @@
 	return ERROR_OK;
 }
 
-int xscale_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
+int xscale_write_memory(struct target_s *target, u32 address, u32 size, u32 count, uint8_t *buffer)
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
@@ -2062,7 +2062,7 @@
 	return ERROR_OK;
 }
 
-int xscale_bulk_write_memory(target_t *target, u32 address, u32 count, u8 *buffer)
+int xscale_bulk_write_memory(target_t *target, u32 address, u32 count, uint8_t *buffer)
 {
 	return xscale_write_memory(target, address, 4, count, buffer);
 }
@@ -2329,7 +2329,7 @@
 {
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	xscale_common_t *xscale = armv4_5-&gt;arch_info;
-	u8 enable=0;
+	uint8_t enable=0;
 	reg_t *dbcon = &amp;xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DBCON];
 	u32 dbcon_value = buf_get_u32(dbcon-&gt;value, 0, 32);
 
@@ -2535,7 +2535,7 @@
 	return ERROR_OK;
 }
 
-int xscale_set_reg(reg_t *reg, u8* buf)
+int xscale_set_reg(reg_t *reg, uint8_t* buf)
 {
 	xscale_reg_t *arch_info = reg-&gt;arch_info;
 	target_t *target = arch_info-&gt;target;
@@ -2583,7 +2583,7 @@
 /* convenience wrapper to access XScale specific registers */
 int xscale_set_reg_u32(reg_t *reg, u32 value)
 {
-	u8 buf[4];
+	uint8_t buf[4];
 
 	buf_set_u32(buf, 0, 32, value);
 
@@ -2723,7 +2723,7 @@
 
 	if (xscale-&gt;trace.core_state == ARMV4_5_STATE_ARM)
 	{
-		u8 buf[4];
+		uint8_t buf[4];
 		if ((retval = image_read_section(xscale-&gt;trace.image, section,
 			xscale-&gt;trace.current_pc - xscale-&gt;trace.image-&gt;sections[section].base_address,
 			4, buf, &amp;size_read)) != ERROR_OK)
@@ -2736,7 +2736,7 @@
 	}
 	else if (xscale-&gt;trace.core_state == ARMV4_5_STATE_THUMB)
 	{
-		u8 buf[2];
+		uint8_t buf[2];
 		if ((retval = image_read_section(xscale-&gt;trace.image, section,
 			xscale-&gt;trace.current_pc - xscale-&gt;trace.image-&gt;sections[section].base_address,
 			2, buf, &amp;size_read)) != ERROR_OK)

Modified: trunk/src/target/xscale.h
===================================================================
--- trunk/src/target/xscale.h	2009-06-18 04:08:51 UTC (rev 2273)
+++ trunk/src/target/xscale.h	2009-06-18 07:04:08 UTC (rev 2274)
@@ -57,7 +57,7 @@
 
 typedef struct xscale_trace_entry_s
 {
-	u8 data;
+	uint8_t data;
 	enum xscale_trace_entry_type type;
 } xscale_trace_entry_t;
 
@@ -105,8 +105,8 @@
 	u32 high_vectors[8];
 	
 	/* static low vectors */
-	u8 static_low_vectors_set;	/* bit field with static vectors set by the user */
-	u8 static_high_vectors_set; /* bit field with static vectors set by the user */
+	uint8_t static_low_vectors_set;	/* bit field with static vectors set by the user */
+	uint8_t static_high_vectors_set; /* bit field with static vectors set by the user */
 	u32 static_low_vectors[8];
 	u32 static_high_vectors[8];
 
@@ -127,7 +127,7 @@
 	u32 arm_bkpt;
 	u16 thumb_bkpt;
 	
-	u8 vector_catch;
+	uint8_t vector_catch;
 
 	xscale_trace_t trace;
 	


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001057.html">[Openocd-svn] r2273 - trunk/doc
</A></li>
	<LI>Next message: <A HREF="001059.html">[Openocd-svn] r2275 - trunk/src/flash
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1058">[ date ]</a>
              <a href="thread.html#1058">[ thread ]</a>
              <a href="subject.html#1058">[ subject ]</a>
              <a href="author.html#1058">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
