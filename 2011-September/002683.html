<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-76-g48e8d2d
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2011-September/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-76-g48e8d2d&In-Reply-To=%3Cmailman.168.1331736157.7625.openocd-svn%40lists.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002682.html">
   <LINK REL="Next"  HREF="002684.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-76-g48e8d2d</H1>
    <B>&#195;&#152;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.5.0-76-g48e8d2d&In-Reply-To=%3Cmailman.168.1331736157.7625.openocd-svn%40lists.berlios.de%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-76-g48e8d2d">gowinex at users.sourceforge.net
       </A><BR>
    <I>Thu Sep  1 07:03:45 CEST 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002682.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-73-g355f183
</A></li>
        <LI>Next message: <A HREF="002684.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-77-g1411ad1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2683">[ date ]</a>
              <a href="thread.html#2683">[ thread ]</a>
              <a href="subject.html#2683">[ subject ]</a>
              <a href="author.html#2683">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  48e8d2d21c2f7c19a7d6616115f06fef99203d7e (commit)
       via  70d9d808e523a056257308acb4402d6a4465001d (commit)
       via  ea7c87e5e79db7103f886d8c7d1deaad6b1c0fe0 (commit)
      from  355f183adbefaf6455bcefd52ae680ed8968ae2b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 48e8d2d21c2f7c19a7d6616115f06fef99203d7e
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Wed Aug 31 17:22:21 2011 +0200

    ULINK driver: Remove typedefs in ulink.c
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 2657eea..73f1523 100644
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -148,23 +148,21 @@ struct ulink_cmd {
   struct ulink_cmd *next;     ///&lt; Pointer to next command (linked list)
 };
 
-typedef struct ulink_cmd ulink_cmd_t;
-
 /** Describes one driver instance */
 struct ulink
 {
   struct usb_dev_handle *usb_handle;
   enum ulink_type type;
 
-  int delay_scan_in;         ///&lt; Delay value for SCAN_IN commands
-  int delay_scan_out;        ///&lt; Delay value for SCAN_OUT commands
-  int delay_scan_io;         ///&lt; Delay value for SCAN_IO commands
-  int delay_clock_tck;       ///&lt; Delay value for CLOCK_TMS commands
-  int delay_clock_tms;       ///&lt; Delay value for CLOCK_TCK commands
+  int delay_scan_in;             ///&lt; Delay value for SCAN_IN commands
+  int delay_scan_out;            ///&lt; Delay value for SCAN_OUT commands
+  int delay_scan_io;             ///&lt; Delay value for SCAN_IO commands
+  int delay_clock_tck;           ///&lt; Delay value for CLOCK_TMS commands
+  int delay_clock_tms;           ///&lt; Delay value for CLOCK_TCK commands
 
-  int commands_in_queue;     ///&lt; Number of commands in queue
-  ulink_cmd_t *queue_start;  ///&lt; Pointer to first command in queue
-  ulink_cmd_t *queue_end;    ///&lt; Pointer to last command in queue
+  int commands_in_queue;         ///&lt; Number of commands in queue
+  struct ulink_cmd *queue_start; ///&lt; Pointer to first command in queue
+  struct ulink_cmd *queue_end;   ///&lt; Pointer to last command in queue
 };
 
 /**************************** Function Prototypes *****************************/
@@ -185,19 +183,19 @@ int ulink_write_firmware_section(struct ulink *device,
 void ulink_print_signal_states(uint8_t input_signals, uint8_t output_signals);
 
 /* OpenULINK command generation helper functions */
-int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
+int ulink_allocate_payload(struct ulink_cmd *ulink_cmd, int size,
     enum ulink_payload_direction direction);
 
 /* OpenULINK command queue helper functions */
 int ulink_get_queue_size(struct ulink *device,
     enum ulink_payload_direction direction);
 void ulink_clear_queue(struct ulink *device);
-int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd);
+int ulink_append_queue(struct ulink *device, struct ulink_cmd *ulink_cmd);
 int ulink_execute_queued_commands(struct ulink *device, int timeout);
 
 #ifdef _DEBUG_JTAG_IO_
 const char * ulink_cmd_id_string(uint8_t id);
-void ulink_print_command(ulink_cmd_t *ulink_cmd);
+void ulink_print_command(struct ulink_cmd *ulink_cmd);
 void ulink_print_queue(struct ulink *device);
 #endif
 
@@ -233,7 +231,7 @@ int ulink_queue_pathmove(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_sleep(struct ulink *device, struct jtag_command *cmd);
 int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd);
 
-int ulink_post_process_scan(ulink_cmd_t *ulink_cmd);
+int ulink_post_process_scan(struct ulink_cmd *ulink_cmd);
 int ulink_post_process_queue(struct ulink *device);
 
 /* JTAG driver functions (registered in struct jtag_interface) */
@@ -523,7 +521,7 @@ void ulink_print_signal_states(uint8_t input_signals, uint8_t output_signals)
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
+int ulink_allocate_payload(struct ulink_cmd *ulink_cmd, int size,
     enum ulink_payload_direction direction)
 {
   uint8_t *payload;
@@ -580,7 +578,7 @@ int ulink_allocate_payload(ulink_cmd_t *ulink_cmd, int size,
 int ulink_get_queue_size(struct ulink *device,
     enum ulink_payload_direction direction)
 {
-  ulink_cmd_t *current = device-&gt;queue_start;
+  struct ulink_cmd *current = device-&gt;queue_start;
   int sum = 0;
 
   while (current != NULL) {
@@ -608,8 +606,8 @@ int ulink_get_queue_size(struct ulink *device,
  */
 void ulink_clear_queue(struct ulink *device)
 {
-  ulink_cmd_t *current = device-&gt;queue_start;
-  ulink_cmd_t *next = NULL;
+  struct ulink_cmd *current = device-&gt;queue_start;
+  struct ulink_cmd *next = NULL;
 
   while (current != NULL) {
     /* Save pointer to next element */
@@ -648,7 +646,7 @@ void ulink_clear_queue(struct ulink *device)
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd)
+int ulink_append_queue(struct ulink *device, struct ulink_cmd *ulink_cmd)
 {
   int newsize_out, newsize_in;
   int ret;
@@ -703,7 +701,7 @@ int ulink_append_queue(struct ulink *device, ulink_cmd_t *ulink_cmd)
  */
 int ulink_execute_queued_commands(struct ulink *device, int timeout)
 {
-  ulink_cmd_t *current;
+  struct ulink_cmd *current;
   int ret, i, index_out, index_in, count_out, count_in;
   uint8_t buffer[64];
 
@@ -836,17 +834,18 @@ const char * ulink_cmd_id_string(uint8_t id)
  *
  * @param ulink_cmd pointer to OpenULINK command.
  */
-void ulink_print_command(ulink_cmd_t *ulink_cmd)
+void ulink_print_command(struct ulink_cmd *ulink_cmd)
 {
   int i;
 
-  printf(&quot;  %-22s | OUT size = %i, bytes = 0x&quot;, ulink_cmd_id_string(ulink_cmd-&gt;id),
-      ulink_cmd-&gt;payload_out_size);
+  printf(&quot;  %-22s | OUT size = %i, bytes = 0x&quot;,
+      ulink_cmd_id_string(ulink_cmd-&gt;id), ulink_cmd-&gt;payload_out_size);
 
   for (i = 0; i &lt; ulink_cmd-&gt;payload_out_size; i++) {
     printf(&quot;%02X &quot;, ulink_cmd-&gt;payload_out[i]);
   }
-  printf(&quot;\n                         | IN size  = %i\n&quot;, ulink_cmd-&gt;payload_in_size);
+  printf(&quot;\n                         | IN size  = %i\n&quot;,
+      ulink_cmd-&gt;payload_in_size);
 }
 
 /**
@@ -856,7 +855,7 @@ void ulink_print_command(ulink_cmd_t *ulink_cmd)
  */
 void ulink_print_queue(struct ulink *device)
 {
-  ulink_cmd_t *current;
+  struct ulink_cmd *current;
 
   printf(&quot;OpenULINK command queue:\n&quot;);
 
@@ -902,7 +901,7 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
     uint8_t tms_count_start, uint8_t tms_sequence_start, uint8_t tms_count_end,
     uint8_t tms_sequence_end, struct jtag_command *origin, bool postprocess)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret, i, scan_size_bytes;
   uint8_t bits_last_byte;
 
@@ -1008,7 +1007,7 @@ int ulink_append_scan_cmd(struct ulink *device, enum scan_type scan_type,
 int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
     uint8_t sequence)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1046,7 +1045,7 @@ int ulink_append_clock_tms_cmd(struct ulink *device, uint8_t count,
  */
 int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1081,7 +1080,7 @@ int ulink_append_clock_tck_cmd(struct ulink *device, uint16_t count)
  */
 int ulink_append_get_signals_cmd(struct ulink *device)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1121,7 +1120,7 @@ int ulink_append_get_signals_cmd(struct ulink *device)
 int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
     uint8_t high)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1153,7 +1152,7 @@ int ulink_append_set_signals_cmd(struct ulink *device, uint8_t low,
  */
 int ulink_append_sleep_cmd(struct ulink *device, uint32_t us)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1190,7 +1189,7 @@ int ulink_append_sleep_cmd(struct ulink *device, uint32_t us)
 int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
     int delay_scan_out, int delay_scan_io, int delay_tck, int delay_tms)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1261,7 +1260,7 @@ int ulink_append_configure_tck_cmd(struct ulink *device, int delay_scan_in,
  */
 int ulink_append_led_cmd(struct ulink *device, uint8_t led_state)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1291,7 +1290,7 @@ int ulink_append_led_cmd(struct ulink *device, uint8_t led_state)
  */
 int ulink_append_test_cmd(struct ulink *device)
 {
-  ulink_cmd_t *cmd = calloc(1, sizeof(ulink_cmd_t));
+  struct ulink_cmd *cmd = calloc(1, sizeof(struct ulink_cmd));
   int ret;
 
   if (cmd == NULL) {
@@ -1897,7 +1896,7 @@ int ulink_queue_stableclocks(struct ulink *device, struct jtag_command *cmd)
  * @return on success: ERROR_OK
  * @return on failure: ERROR_FAIL
  */
-int ulink_post_process_scan(ulink_cmd_t *ulink_cmd)
+int ulink_post_process_scan(struct ulink_cmd *ulink_cmd)
 {
   struct jtag_command *cmd = ulink_cmd-&gt;cmd_origin;
   int ret;
@@ -1930,7 +1929,7 @@ int ulink_post_process_scan(ulink_cmd_t *ulink_cmd)
  */
 int ulink_post_process_queue(struct ulink *device)
 {
-  ulink_cmd_t *current;
+  struct ulink_cmd *current;
   struct jtag_command *openocd_cmd;
   int ret;
 

commit 70d9d808e523a056257308acb4402d6a4465001d
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Wed Aug 31 16:51:41 2011 +0200

    ULINK driver: Remove typedefs in OpenULINK firmware: Use typedefs from stdint.h (uint8_t, uint16_t) instead of custom typedefs in shorttypes.h (u8, u16, ...)
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/OpenULINK/Makefile b/src/jtag/drivers/OpenULINK/Makefile
index c0e3435..ff2b172 100644
--- a/src/jtag/drivers/OpenULINK/Makefile
+++ b/src/jtag/drivers/OpenULINK/Makefile
@@ -61,8 +61,7 @@ HEADERS = $(INCLUDE_DIR)/main.h         \
           $(INCLUDE_DIR)/delay.h        \
           $(INCLUDE_DIR)/reg_ezusb.h    \
           $(INCLUDE_DIR)/io.h           \
-          $(INCLUDE_DIR)/msgtypes.h     \
-          $(INCLUDE_DIR)/shorttypes.h
+          $(INCLUDE_DIR)/msgtypes.h
 
 # Disable all built-in rules.
 .SUFFIXES:
diff --git a/src/jtag/drivers/OpenULINK/include/delay.h b/src/jtag/drivers/OpenULINK/include/delay.h
index 3dfaf35..5c36b1d 100644
--- a/src/jtag/drivers/OpenULINK/include/delay.h
+++ b/src/jtag/drivers/OpenULINK/include/delay.h
@@ -21,14 +21,14 @@
 #ifndef __DELAY_H
 #define __DELAY_H
 
-#include &quot;shorttypes.h&quot;
+#include &lt;stdint.h&gt;
 
 #define NOP  {__asm nop __endasm;}
 
 void delay_5us(void);
 void delay_1ms(void);
 
-void delay_us(u16 delay);
-void delay_ms(u16 delay);
+void delay_us(uint16_t delay);
+void delay_ms(uint16_t delay);
 
 #endif
diff --git a/src/jtag/drivers/OpenULINK/include/jtag.h b/src/jtag/drivers/OpenULINK/include/jtag.h
index cef5f42..ca86671 100644
--- a/src/jtag/drivers/OpenULINK/include/jtag.h
+++ b/src/jtag/drivers/OpenULINK/include/jtag.h
@@ -21,28 +21,28 @@
 #ifndef __JTAG_H
 #define __JTAG_H
 
-#include &quot;shorttypes.h&quot;
+#include &lt;stdint.h&gt;
 
 #define NOP {__asm nop __endasm;}
 
-void jtag_scan_in(u8 out_offset, u8 in_offset);
-void jtag_slow_scan_in(u8 out_offset, u8 in_offset);
+void jtag_scan_in(uint8_t out_offset, uint8_t in_offset);
+void jtag_slow_scan_in(uint8_t out_offset, uint8_t in_offset);
 
-void jtag_scan_out(u8 out_offset);
-void jtag_slow_scan_out(u8 out_offset);
+void jtag_scan_out(uint8_t out_offset);
+void jtag_slow_scan_out(uint8_t out_offset);
 
-void jtag_scan_io(u8 out_offset, u8 in_offset);
-void jtag_slow_scan_io(u8 out_offset, u8 in_offset);
+void jtag_scan_io(uint8_t out_offset, uint8_t in_offset);
+void jtag_slow_scan_io(uint8_t out_offset, uint8_t in_offset);
 
-void jtag_clock_tck(u16 count);
-void jtag_slow_clock_tck(u16 count);
-void jtag_clock_tms(u8 count, u8 sequence);
-void jtag_slow_clock_tms(u8 count, u8 sequence);
+void jtag_clock_tck(uint16_t count);
+void jtag_slow_clock_tck(uint16_t count);
+void jtag_clock_tms(uint8_t count, uint8_t sequence);
+void jtag_slow_clock_tms(uint8_t count, uint8_t sequence);
 
-u16  jtag_get_signals(void);
-void jtag_set_signals(u8 low, u8 high);
+uint16_t  jtag_get_signals(void);
+void jtag_set_signals(uint8_t low, uint8_t high);
 
-void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
-    u8 tms);
+void jtag_configure_tck_delay(uint8_t scan_in, uint8_t scan_out,
+    uint8_t scan_io, uint8_t tck, uint8_t tms);
 
 #endif
diff --git a/src/jtag/drivers/OpenULINK/include/protocol.h b/src/jtag/drivers/OpenULINK/include/protocol.h
index 2129fc8..49e881c 100644
--- a/src/jtag/drivers/OpenULINK/include/protocol.h
+++ b/src/jtag/drivers/OpenULINK/include/protocol.h
@@ -21,7 +21,6 @@
 #ifndef __PROTOCOL_H
 #define __PROTOCOL_H
 
-#include &quot;shorttypes.h&quot;
 #include &quot;common.h&quot;
 #include &lt;stdbool.h&gt;
 
diff --git a/src/jtag/drivers/OpenULINK/include/shorttypes.h b/src/jtag/drivers/OpenULINK/include/shorttypes.h
deleted file mode 100644
index 60b37df..0000000
--- a/src/jtag/drivers/OpenULINK/include/shorttypes.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2011 by Martin Schmoelzer                               *
- *   &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;                              *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-
-#ifndef __SHORTTYPES_H
-#define __SHORTTYPES_H
-
-#include &lt;stdint.h&gt;
-
-/**
- * @file Integer type definitions for shorter code (easier to stay within 80
- * character maximum line length).
- */
-
-/* Signed integers */
-typedef int8_t   s8;
-typedef int16_t  s16;
-typedef int32_t  s32;
-
-/* Unsigned integers */
-typedef uint8_t  u8;
-typedef uint16_t u16;
-typedef uint32_t u32;
-
-#endif
diff --git a/src/jtag/drivers/OpenULINK/include/usb.h b/src/jtag/drivers/OpenULINK/include/usb.h
index a507c9e..811d6bf 100644
--- a/src/jtag/drivers/OpenULINK/include/usb.h
+++ b/src/jtag/drivers/OpenULINK/include/usb.h
@@ -21,16 +21,16 @@
 #ifndef __USB_H
 #define __USB_H
 
-#include &quot;shorttypes.h&quot;
 #include &quot;reg_ezusb.h&quot;
 
+#include &lt;stdint.h&gt;
 #include &lt;stdbool.h&gt;
 
 #define NULL        (void*)0;
 
-/* High and Low byte of a word (u16) */
-#define HI8(word)   (u8)(((u16)word &gt;&gt; 8) &amp; 0xff)
-#define LO8(word)   (u8)((u16)word &amp; 0xff)
+/* High and Low byte of a word (uint16_t) */
+#define HI8(word)   (uint8_t)(((uint16_t)word &gt;&gt; 8) &amp; 0xff)
+#define LO8(word)   (uint8_t)((uint16_t)word &amp; 0xff)
 
 /* Convenience functions */
 #define STALL_EP0()   EP0CS |= EP0STALL
@@ -49,80 +49,80 @@
 
 /** USB Device Descriptor. See USB 1.1 spec, pp. 196 - 198 */
 struct usb_device_descriptor {
-  u8  bLength;             ///&lt; Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///&lt; DEVICE Descriptor Type.
-  u16 bcdUSB;              ///&lt; USB specification release number (BCD).
-  u8  bDeviceClass;        ///&lt; Class code.
-  u8  bDeviceSubClass;     ///&lt; Subclass code.
-  u8  bDeviceProtocol;     ///&lt; Protocol code.
-  u8  bMaxPacketSize0;     ///&lt; Maximum packet size for EP0 (8, 16, 32, 64).
-  u16 idVendor;            ///&lt; USB Vendor ID.
-  u16 idProduct;           ///&lt; USB Product ID.
-  u16 bcdDevice;           ///&lt; Device Release Number (BCD).
-  u8  iManufacturer;       ///&lt; Index of manufacturer string descriptor.
-  u8  iProduct;            ///&lt; Index of product string descriptor.
-  u8  iSerialNumber;       ///&lt; Index of string descriptor containing serial #.
-  u8  bNumConfigurations;  ///&lt; Number of possible configurations.
+  uint8_t  bLength;            ///&lt; Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///&lt; DEVICE Descriptor Type.
+  uint16_t bcdUSB;             ///&lt; USB specification release number (BCD).
+  uint8_t  bDeviceClass;       ///&lt; Class code.
+  uint8_t  bDeviceSubClass;    ///&lt; Subclass code.
+  uint8_t  bDeviceProtocol;    ///&lt; Protocol code.
+  uint8_t  bMaxPacketSize0;    ///&lt; Maximum packet size for EP0 (8, 16, 32, 64).
+  uint16_t idVendor;           ///&lt; USB Vendor ID.
+  uint16_t idProduct;          ///&lt; USB Product ID.
+  uint16_t bcdDevice;          ///&lt; Device Release Number (BCD).
+  uint8_t  iManufacturer;      ///&lt; Index of manufacturer string descriptor.
+  uint8_t  iProduct;           ///&lt; Index of product string descriptor.
+  uint8_t  iSerialNumber;      ///&lt; Index of string descriptor containing serial #.
+  uint8_t  bNumConfigurations; ///&lt; Number of possible configurations.
 };
 
 /** USB Configuration Descriptor. See USB 1.1 spec, pp. 199 - 200 */
 struct usb_config_descriptor {
-  u8  bLength;             ///&lt; Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///&lt; CONFIGURATION descriptor type.
-  u16 wTotalLength;        ///&lt; Combined total length of all descriptors.
-  u8  bNumInterfaces;      ///&lt; Number of interfaces in this configuration.
-  u8  bConfigurationValue; ///&lt; Value used to select this configuration.
-  u8  iConfiguration;      ///&lt; Index of configuration string descriptor.
-  u8  bmAttributes;        ///&lt; Configuration characteristics.
-  u8  MaxPower;            ///&lt; Maximum power consumption in 2 mA units.
+  uint8_t  bLength;            ///&lt; Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///&lt; CONFIGURATION descriptor type.
+  uint16_t wTotalLength;       ///&lt; Combined total length of all descriptors.
+  uint8_t  bNumInterfaces;     ///&lt; Number of interfaces in this configuration.
+  uint8_t  bConfigurationValue;///&lt; Value used to select this configuration.
+  uint8_t  iConfiguration;     ///&lt; Index of configuration string descriptor.
+  uint8_t  bmAttributes;       ///&lt; Configuration characteristics.
+  uint8_t  MaxPower;           ///&lt; Maximum power consumption in 2 mA units.
 };
 
 /** USB Interface Descriptor. See USB 1.1 spec, pp. 201 - 203 */
 struct usb_interface_descriptor {
-  u8  bLength;             ///&lt; Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///&lt; INTERFACE descriptor type.
-  u8  bInterfaceNumber;    ///&lt; Interface number.
-  u8  bAlternateSetting;   ///&lt; Value used to select alternate setting.
-  u8  bNumEndpoints;       ///&lt; Number of endpoints used by this interface.
-  u8  bInterfaceClass;     ///&lt; Class code.
-  u8  bInterfaceSubclass;  ///&lt; Subclass code.
-  u8  bInterfaceProtocol;  ///&lt; Protocol code.
-  u8  iInterface;          ///&lt; Index of interface string descriptor.
+  uint8_t  bLength;            ///&lt; Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///&lt; INTERFACE descriptor type.
+  uint8_t  bInterfaceNumber;   ///&lt; Interface number.
+  uint8_t  bAlternateSetting;  ///&lt; Value used to select alternate setting.
+  uint8_t  bNumEndpoints;      ///&lt; Number of endpoints used by this interface.
+  uint8_t  bInterfaceClass;    ///&lt; Class code.
+  uint8_t  bInterfaceSubclass; ///&lt; Subclass code.
+  uint8_t  bInterfaceProtocol; ///&lt; Protocol code.
+  uint8_t  iInterface;         ///&lt; Index of interface string descriptor.
 };
 
 /** USB Endpoint Descriptor. See USB 1.1 spec, pp. 203 - 204 */
 struct usb_endpoint_descriptor {
-  u8  bLength;             ///&lt; Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///&lt; ENDPOINT descriptor type.
-  u8  bEndpointAddress;    ///&lt; Endpoint Address: USB 1.1 spec, table 9-10.
-  u8  bmAttributes;        ///&lt; Endpoint Attributes: USB 1.1 spec, table 9-10.
-  u16 wMaxPacketSize;      ///&lt; Maximum packet size for this endpoint.
-  u8  bInterval;           ///&lt; Polling interval (in ms) for this endpoint.
+  uint8_t  bLength;            ///&lt; Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///&lt; ENDPOINT descriptor type.
+  uint8_t  bEndpointAddress;   ///&lt; Endpoint Address: USB 1.1 spec, table 9-10.
+  uint8_t  bmAttributes;       ///&lt; Endpoint Attributes: USB 1.1 spec, table 9-10.
+  uint16_t wMaxPacketSize;     ///&lt; Maximum packet size for this endpoint.
+  uint8_t  bInterval;          ///&lt; Polling interval (in ms) for this endpoint.
 };
 
 /** USB Language Descriptor. See USB 1.1 spec, pp. 204 - 205 */
 struct usb_language_descriptor {
-  u8  bLength;             ///&lt; Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///&lt; STRING descriptor type.
-  u16 wLANGID[];           ///&lt; LANGID codes.
+  uint8_t  bLength;            ///&lt; Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///&lt; STRING descriptor type.
+  uint16_t wLANGID[];          ///&lt; LANGID codes.
 };
 
 /** USB String Descriptor. See USB 1.1 spec, pp. 204 - 205 */
 struct usb_string_descriptor {
-  u8  bLength;             ///&lt; Size of this descriptor in bytes.
-  u8  bDescriptorType;     ///&lt; STRING descriptor type.
-  u16 bString[];           ///&lt; UNICODE encoded string.
+  uint8_t  bLength;            ///&lt; Size of this descriptor in bytes.
+  uint8_t  bDescriptorType;    ///&lt; STRING descriptor type.
+  uint16_t bString[];          ///&lt; UNICODE encoded string.
 };
 
 /********************** USB Control Endpoint 0 related *********************/
 
 /** USB Control Setup Data. See USB 1.1 spec, pp. 183 - 185 */
 struct setup_data {
-  u8  bmRequestType;       ///&lt; Characteristics of a request.
-  u8  bRequest;            ///&lt; Specific request.
-  u16 wValue;              ///&lt; Field that varies according to request.
-  u16 wIndex;              ///&lt; Field that varies according to request.
-  u16 wLength;             ///&lt; Number of bytes to transfer in data stage.
+  uint8_t  bmRequestType;      ///&lt; Characteristics of a request.
+  uint8_t  bRequest;           ///&lt; Specific request.
+  uint16_t wValue;             ///&lt; Field that varies according to request.
+  uint16_t wIndex;             ///&lt; Field that varies according to request.
+  uint16_t wLength;            ///&lt; Number of bytes to transfer in data stage.
 };
 
 /* External declarations for variables that need to be accessed outside of
@@ -252,8 +252,8 @@ enum usb_isr {
 
 /*************************** Function Prototypes ***************************/
 
-__xdata u8* usb_get_endpoint_cs_reg(u8 ep);
-void usb_reset_data_toggle(u8 ep);
+__xdata uint8_t* usb_get_endpoint_cs_reg(uint8_t ep);
+void usb_reset_data_toggle(uint8_t ep);
 
 bool usb_handle_get_status(void);
 bool usb_handle_clear_feature(void);
diff --git a/src/jtag/drivers/OpenULINK/src/delay.c b/src/jtag/drivers/OpenULINK/src/delay.c
index 5b7d0eb..086633a 100644
--- a/src/jtag/drivers/OpenULINK/src/delay.c
+++ b/src/jtag/drivers/OpenULINK/src/delay.c
@@ -26,24 +26,24 @@ void delay_5us(void)
 }
 
 void delay_1ms(void) {
-  u16 i;
+  uint16_t i;
 
   for (i = 0; i &lt; 598; i++);
 }
 
-void delay_us(u16 delay)
+void delay_us(uint16_t delay)
 {
-  u16 i;
-  u16 maxcount = (delay / 5);
+  uint16_t i;
+  uint16_t maxcount = (delay / 5);
 
   for (i = 0; i &lt; maxcount; i++) {
     delay_5us();
   }
 }
 
-void delay_ms(u16 delay)
+void delay_ms(uint16_t delay)
 {
-  u16 i;
+  uint16_t i;
 
   for (i = 0; i &lt; delay; i++) {
     delay_1ms();
diff --git a/src/jtag/drivers/OpenULINK/src/jtag.c b/src/jtag/drivers/OpenULINK/src/jtag.c
index 812d4f7..3c2fea2 100644
--- a/src/jtag/drivers/OpenULINK/src/jtag.c
+++ b/src/jtag/drivers/OpenULINK/src/jtag.c
@@ -27,19 +27,19 @@
 #include &lt;stdbool.h&gt;
 
 /** Delay value for SCAN_IN operations with less than maximum TCK frequency */
-u8 delay_scan_in = 0;
+uint8_t delay_scan_in = 0;
 
 /** Delay value for SCAN_OUT operations with less than maximum TCK frequency */
-u8 delay_scan_out = 0;
+uint8_t delay_scan_out = 0;
 
 /** Delay value for SCAN_IO operations with less than maximum TCK frequency */
-u8 delay_scan_io = 0;
+uint8_t delay_scan_io = 0;
 
 /** Delay value for CLOCK_TCK operations with less than maximum frequency */
-u8 delay_tck = 0;
+uint8_t delay_tck = 0;
 
 /** Delay value for CLOCK_TMS operations with less than maximum frequency */
-u8 delay_tms = 0;
+uint8_t delay_tms = 0;
 
 /**
  * Perform JTAG SCAN-IN operation at maximum TCK frequency.
@@ -51,14 +51,14 @@ u8 delay_tms = 0;
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_scan_in(u8 out_offset, u8 in_offset)
+void jtag_scan_in(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdo_data, i, j;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdo_data, i, j;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -132,14 +132,14 @@ void jtag_scan_in(u8 out_offset, u8 in_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_slow_scan_in(u8 out_offset, u8 in_offset)
+void jtag_slow_scan_in(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdo_data, i, j, k;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdo_data, i, j, k;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -220,14 +220,14 @@ void jtag_slow_scan_in(u8 out_offset, u8 in_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_scan_out(u8 out_offset)
+void jtag_scan_out(uint8_t out_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, i, j;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, i, j;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -301,14 +301,14 @@ void jtag_scan_out(u8 out_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_slow_scan_out(u8 out_offset)
+void jtag_slow_scan_out(uint8_t out_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, i, j, k;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, i, j, k;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -388,14 +388,14 @@ void jtag_slow_scan_out(u8 out_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_scan_io(u8 out_offset, u8 in_offset)
+void jtag_scan_io(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, tdo_data, i, j;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, tdo_data, i, j;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -488,14 +488,14 @@ void jtag_scan_io(u8 out_offset, u8 in_offset)
  *
  * @param out_offset offset in OUT2BUF where payload data starts
  */
-void jtag_slow_scan_io(u8 out_offset, u8 in_offset)
+void jtag_slow_scan_io(uint8_t out_offset, uint8_t in_offset)
 {
-  u8 scan_size_bytes, bits_last_byte;
-  u8 tms_count_start, tms_count_end;
-  u8 tms_sequence_start, tms_sequence_end;
-  u8 tdi_data, tdo_data, i, j, k;
+  uint8_t scan_size_bytes, bits_last_byte;
+  uint8_t tms_count_start, tms_count_end;
+  uint8_t tms_sequence_start, tms_sequence_end;
+  uint8_t tdi_data, tdo_data, i, j, k;
 
-  u8 outb_buffer;
+  uint8_t outb_buffer;
 
   /* Get parameters from OUT2BUF */
   scan_size_bytes = OUT2BUF[out_offset];
@@ -590,10 +590,10 @@ void jtag_slow_scan_io(u8 out_offset, u8 in_offset)
  *
  * @param count number of TCK clock cyclces to generate.
  */
-void jtag_clock_tck(u16 count)
+void jtag_clock_tck(uint16_t count)
 {
-  u16 i;
-  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
+  uint16_t i;
+  uint8_t outb_buffer = OUTB &amp; ~(PIN_TCK);
 
   for ( i = 0; i &lt; count; i++ ) {
     OUTB = outb_buffer;
@@ -608,11 +608,11 @@ void jtag_clock_tck(u16 count)
  *
  * @param count number of TCK clock cyclces to generate.
  */
-void jtag_slow_clock_tck(u16 count)
+void jtag_slow_clock_tck(uint16_t count)
 {
-  u16 i;
-  u8 j;
-  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
+  uint16_t i;
+  uint8_t j;
+  uint8_t outb_buffer = OUTB &amp; ~(PIN_TCK);
 
   for ( i = 0; i &lt; count; i++ ) {
     OUTB = outb_buffer;
@@ -631,10 +631,10 @@ void jtag_slow_clock_tck(u16 count)
  * @param sequence the TMS pin levels for each state transition, starting with
  *  the least-significant bit.
  */
-void jtag_clock_tms(u8 count, u8 sequence)
+void jtag_clock_tms(uint8_t count, uint8_t sequence)
 {
-  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
-  u8 i;
+  uint8_t outb_buffer = OUTB &amp; ~(PIN_TCK);
+  uint8_t i;
 
   for ( i = 0; i &lt; count; i++ ) {
     /* Set TMS pin according to sequence parameter */
@@ -660,10 +660,10 @@ void jtag_clock_tms(u8 count, u8 sequence)
  * @param sequence the TMS pin levels for each state transition, starting with
  *  the least-significant bit.
  */
-void jtag_slow_clock_tms(u8 count, u8 sequence)
+void jtag_slow_clock_tms(uint8_t count, uint8_t sequence)
 {
-  u8 outb_buffer = OUTB &amp; ~(PIN_TCK);
-  u8 i, j;
+  uint8_t outb_buffer = OUTB &amp; ~(PIN_TCK);
+  uint8_t i, j;
 
   for (i = 0; i &lt; count; i++) {
     /* Set TMS pin according to sequence parameter */
@@ -689,9 +689,9 @@ void jtag_slow_clock_tms(u8 count, u8 sequence)
  *  of the JTAG input signals and the least-significant byte cotains the state
  *  of the JTAG output signals.
  */
-u16 jtag_get_signals(void)
+uint16_t jtag_get_signals(void)
 {
-  u8 input_signal_state, output_signal_state;
+  uint8_t input_signal_state, output_signal_state;
 
   input_signal_state = 0;
   output_signal_state = 0;
@@ -715,7 +715,7 @@ u16 jtag_get_signals(void)
   /* Get states of output pins */
   output_signal_state = PINSB &amp; MASK_PORTB_DIRECTION_OUT;
 
-  return ((u16)input_signal_state &lt;&lt; 8) | ((u16)output_signal_state);
+  return ((uint16_t)input_signal_state &lt;&lt; 8) | ((uint16_t)output_signal_state);
 }
 
 /**
@@ -724,7 +724,7 @@ u16 jtag_get_signals(void)
  * @param low signals which should be de-asserted.
  * @param high signals which should be asserted.
  */
-void jtag_set_signals(u8 low, u8 high)
+void jtag_set_signals(uint8_t low, uint8_t high)
 {
   OUTB &amp;= ~(low &amp; MASK_PORTB_DIRECTION_OUT);
   OUTB |= (high &amp; MASK_PORTB_DIRECTION_OUT);
@@ -739,8 +739,8 @@ void jtag_set_signals(u8 low, u8 high)
  * @param tck number of delay cycles in clock_tck operations.
  * @param tms number of delay cycles in clock_tms operations.
  */
-void jtag_configure_tck_delay(u8 scan_in, u8 scan_out, u8 scan_io, u8 tck,
-    u8 tms)
+void jtag_configure_tck_delay(uint8_t scan_in, uint8_t scan_out,
+    uint8_t scan_io, uint8_t tck, uint8_t tms)
 {
   delay_scan_in = scan_in;
   delay_scan_out = scan_out;
diff --git a/src/jtag/drivers/OpenULINK/src/main.c b/src/jtag/drivers/OpenULINK/src/main.c
index 3ea3fff..067393b 100644
--- a/src/jtag/drivers/OpenULINK/src/main.c
+++ b/src/jtag/drivers/OpenULINK/src/main.c
@@ -20,7 +20,6 @@
 
 #include &quot;main.h&quot;
 
-#include &quot;shorttypes.h&quot;
 #include &quot;io.h&quot;
 #include &quot;usb.h&quot;
 #include &quot;protocol.h&quot;
diff --git a/src/jtag/drivers/OpenULINK/src/protocol.c b/src/jtag/drivers/OpenULINK/src/protocol.c
index 6e33ec7..ae63604 100644
--- a/src/jtag/drivers/OpenULINK/src/protocol.c
+++ b/src/jtag/drivers/OpenULINK/src/protocol.c
@@ -47,17 +47,17 @@
  */
 
 /** Index in EP2 Bulk-OUT data buffer that contains the current command ID */
-volatile u8 cmd_id_index;
+volatile uint8_t cmd_id_index;
 
 /** Number of data bytes already in EP2 Bulk-IN buffer */
-volatile u8 payload_index_in;
+volatile uint8_t payload_index_in;
 
 /**
  * Execute a SET_LEDS command.
  */
 void execute_set_led_command(void)
 {
-  u8 led_state = OUT2BUF[cmd_id_index + 1];
+  uint8_t led_state = OUT2BUF[cmd_id_index + 1];
 
   if (led_state &amp; RUN_LED_ON) {
     SET_RUN_LED();
@@ -87,9 +87,9 @@ void execute_set_led_command(void)
  */
 bool execute_command(void)
 {
-  u8 usb_out_bytecount, usb_in_bytecount;
-  u16 signal_state;
-  u16 count;
+  uint8_t usb_out_bytecount, usb_in_bytecount;
+  uint16_t signal_state;
+  uint16_t count;
 
   /* Most commands do not transfer IN data. To save code space, we write 0 to
    * usb_in_bytecount here, then modify it in the switch statement below where
@@ -117,8 +117,8 @@ bool execute_command(void)
     break;
   case CMD_CLOCK_TCK:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
     jtag_clock_tck(count);
     break;
   case CMD_SLOW_SCAN_IN:
@@ -141,20 +141,20 @@ bool execute_command(void)
     break;
   case CMD_SLOW_CLOCK_TCK:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
     jtag_slow_clock_tck(count);
     break;
   case CMD_SLEEP_US:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
     delay_us(count);
     break;
   case CMD_SLEEP_MS:
     usb_out_bytecount = 2;
-    count = (u16)OUT2BUF[cmd_id_index + 1];
-    count |= ((u16)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
+    count = (uint16_t)OUT2BUF[cmd_id_index + 1];
+    count |= ((uint16_t)OUT2BUF[cmd_id_index + 2]) &lt;&lt; 8;
     delay_ms(count);
     break;
   case CMD_GET_SIGNALS:
diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
index aa001f9..7a84d2a 100644
--- a/src/jtag/drivers/OpenULINK/src/usb.c
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -205,10 +205,10 @@ void ep7out_isr(void)   __interrupt EP7OUT_ISR   { }
  *  specified in \a ep
  * @return on failure: NULL
  */
-__xdata u8* usb_get_endpoint_cs_reg(u8 ep)
+__xdata uint8_t* usb_get_endpoint_cs_reg(uint8_t ep)
 {
   /* Mask direction bit */
-  u8 ep_num = ep &amp; 0x7F;
+  uint8_t ep_num = ep &amp; 0x7F;
 
   switch (ep_num) {
   case 0:
@@ -240,7 +240,7 @@ __xdata u8* usb_get_endpoint_cs_reg(u8 ep)
   return NULL;
 }
 
-void usb_reset_data_toggle(u8 ep)
+void usb_reset_data_toggle(uint8_t ep)
 {
   /* TOGCTL register:
      +----+-----+-----+------+-----+-------+-------+-------+
@@ -251,7 +251,7 @@ void usb_reset_data_toggle(u8 ep)
      to the IO bit and the endpoint number to the EP2..EP0 bits. Then, in a
      separate write cycle, the R bit needs to be set.
   */
-  u8 togctl_value = (ep &amp; 0x80 &gt;&gt; 3) | (ep &amp; 0x7);
+  uint8_t togctl_value = (ep &amp; 0x80 &gt;&gt; 3) | (ep &amp; 0x7);
 
   /* First step: Write EP number and direction bit */
   TOGCTL = togctl_value;
@@ -269,7 +269,7 @@ void usb_reset_data_toggle(u8 ep)
  */
 bool usb_handle_get_status(void)
 {
-  u8 *ep_cs;
+  uint8_t *ep_cs;
 
   switch (setup_data.bmRequestType) {
   case GS_DEVICE:
@@ -322,7 +322,7 @@ bool usb_handle_get_status(void)
  */
 bool usb_handle_clear_feature(void)
 {
-  __xdata u8 *ep_cs;
+  __xdata uint8_t *ep_cs;
 
   switch (setup_data.bmRequestType) {
   case CF_DEVICE:
@@ -358,7 +358,7 @@ bool usb_handle_clear_feature(void)
  */
 bool usb_handle_set_feature(void)
 {
-  __xdata u8 *ep_cs;
+  __xdata uint8_t *ep_cs;
 
   switch (setup_data.bmRequestType) {
   case SF_DEVICE:
@@ -396,8 +396,8 @@ bool usb_handle_set_feature(void)
  */
 bool usb_handle_get_descriptor(void)
 {
-  __xdata u8 descriptor_type;
-  __xdata u8 descriptor_index;
+  __xdata uint8_t descriptor_type;
+  __xdata uint8_t descriptor_index;
 
   descriptor_type = (setup_data.wValue &amp; 0xff00) &gt;&gt; 8;
   descriptor_index = setup_data.wValue &amp; 0x00ff;

commit ea7c87e5e79db7103f886d8c7d1deaad6b1c0fe0
Author: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;
Date:   Wed Aug 31 00:20:35 2011 +0200

    ULINK driver: Remove typedefs in OpenULINK firmware USB descriptor structures
    
    Signed-off-by: Martin Schm&#195;&#182;lzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">martin.schmoelzer at student.tuwien.ac.at</A>&gt;

diff --git a/src/jtag/drivers/OpenULINK/include/usb.h b/src/jtag/drivers/OpenULINK/include/usb.h
index f70819e..a507c9e 100644
--- a/src/jtag/drivers/OpenULINK/include/usb.h
+++ b/src/jtag/drivers/OpenULINK/include/usb.h
@@ -48,7 +48,7 @@
 #define STR_DESCR(len,...) { len*2+2, DESCRIPTOR_TYPE_STRING, { __VA_ARGS__ } }
 
 /** USB Device Descriptor. See USB 1.1 spec, pp. 196 - 198 */
-typedef struct {
+struct usb_device_descriptor {
   u8  bLength;             ///&lt; Size of this descriptor in bytes.
   u8  bDescriptorType;     ///&lt; DEVICE Descriptor Type.
   u16 bcdUSB;              ///&lt; USB specification release number (BCD).
@@ -63,10 +63,10 @@ typedef struct {
   u8  iProduct;            ///&lt; Index of product string descriptor.
   u8  iSerialNumber;       ///&lt; Index of string descriptor containing serial #.
   u8  bNumConfigurations;  ///&lt; Number of possible configurations.
-} usb_device_descriptor_t;
+};
 
 /** USB Configuration Descriptor. See USB 1.1 spec, pp. 199 - 200 */
-typedef struct {
+struct usb_config_descriptor {
   u8  bLength;             ///&lt; Size of this descriptor in bytes.
   u8  bDescriptorType;     ///&lt; CONFIGURATION descriptor type.
   u16 wTotalLength;        ///&lt; Combined total length of all descriptors.
@@ -75,10 +75,10 @@ typedef struct {
   u8  iConfiguration;      ///&lt; Index of configuration string descriptor.
   u8  bmAttributes;        ///&lt; Configuration characteristics.
   u8  MaxPower;            ///&lt; Maximum power consumption in 2 mA units.
-} usb_config_descriptor_t;
+};
 
 /** USB Interface Descriptor. See USB 1.1 spec, pp. 201 - 203 */
-typedef struct {
+struct usb_interface_descriptor {
   u8  bLength;             ///&lt; Size of this descriptor in bytes.
   u8  bDescriptorType;     ///&lt; INTERFACE descriptor type.
   u8  bInterfaceNumber;    ///&lt; Interface number.
@@ -88,48 +88,48 @@ typedef struct {
   u8  bInterfaceSubclass;  ///&lt; Subclass code.
   u8  bInterfaceProtocol;  ///&lt; Protocol code.
   u8  iInterface;          ///&lt; Index of interface string descriptor.
-} usb_interface_descriptor_t;
+};
 
 /** USB Endpoint Descriptor. See USB 1.1 spec, pp. 203 - 204 */
-typedef struct {
+struct usb_endpoint_descriptor {
   u8  bLength;             ///&lt; Size of this descriptor in bytes.
   u8  bDescriptorType;     ///&lt; ENDPOINT descriptor type.
   u8  bEndpointAddress;    ///&lt; Endpoint Address: USB 1.1 spec, table 9-10.
   u8  bmAttributes;        ///&lt; Endpoint Attributes: USB 1.1 spec, table 9-10.
   u16 wMaxPacketSize;      ///&lt; Maximum packet size for this endpoint.
   u8  bInterval;           ///&lt; Polling interval (in ms) for this endpoint.
-} usb_endpoint_descriptor_t;
+};
 
 /** USB Language Descriptor. See USB 1.1 spec, pp. 204 - 205 */
-typedef struct {
+struct usb_language_descriptor {
   u8  bLength;             ///&lt; Size of this descriptor in bytes.
   u8  bDescriptorType;     ///&lt; STRING descriptor type.
   u16 wLANGID[];           ///&lt; LANGID codes.
-} usb_language_descriptor_t;
+};
 
 /** USB String Descriptor. See USB 1.1 spec, pp. 204 - 205 */
-typedef struct {
+struct usb_string_descriptor {
   u8  bLength;             ///&lt; Size of this descriptor in bytes.
   u8  bDescriptorType;     ///&lt; STRING descriptor type.
   u16 bString[];           ///&lt; UNICODE encoded string.
-} usb_string_descriptor_t;
+};
 
 /********************** USB Control Endpoint 0 related *********************/
 
 /** USB Control Setup Data. See USB 1.1 spec, pp. 183 - 185 */
-typedef struct {
+struct setup_data {
   u8  bmRequestType;       ///&lt; Characteristics of a request.
   u8  bRequest;            ///&lt; Specific request.
   u16 wValue;              ///&lt; Field that varies according to request.
   u16 wIndex;              ///&lt; Field that varies according to request.
   u16 wLength;             ///&lt; Number of bytes to transfer in data stage.
-} setup_data_t;
+};
 
 /* External declarations for variables that need to be accessed outside of
  * the USB module */
 extern volatile bool EP2_out;
 extern volatile bool EP2_in;
-extern volatile __xdata __at 0x7FE8 setup_data_t setup_data;
+extern volatile __xdata __at 0x7FE8 struct setup_data setup_data;
 
 /*
  * USB Request Types (bmRequestType): See USB 1.1 spec, page 183, table 9-2
@@ -225,7 +225,7 @@ extern volatile __xdata __at 0x7FE8 setup_data_t setup_data;
 /************************** EZ-USB specific stuff **************************/
 
 /** USB Interrupts. See AN2131-TRM, page 9-4 for details */
-typedef enum {
+enum usb_isr {
   SUDAV_ISR = 13,
   SOF_ISR,
   SUTOK_ISR,
@@ -248,7 +248,7 @@ typedef enum {
   EP6OUT_ISR,
   EP7IN_ISR,
   EP7OUT_ISR
-} USB_ISR;
+};
 
 /*************************** Function Prototypes ***************************/
 
diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
index 042addf..aa001f9 100644
--- a/src/jtag/drivers/OpenULINK/src/usb.c
+++ b/src/jtag/drivers/OpenULINK/src/usb.c
@@ -36,7 +36,7 @@
 volatile bool EP2_out = 0;
 volatile bool EP2_in  = 0;
 
-volatile __xdata __at 0x7FE8 setup_data_t setup_data;
+volatile __xdata __at 0x7FE8 struct setup_data setup_data;
 
 /* Define number of endpoints (except Control Endpoint 0) in a central place.
  * Be sure to include the neccessary endpoint descriptors! */
@@ -56,8 +56,8 @@ volatile __xdata __at 0x7FE8 setup_data_t setup_data;
  * old-fashioned way...
  */
 
-__code usb_device_descriptor_t device_descriptor = {
-  /* .bLength = */             sizeof(usb_device_descriptor_t),
+__code struct usb_device_descriptor device_descriptor = {
+  /* .bLength = */             sizeof(struct usb_device_descriptor),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_DEVICE,
   /* .bcdUSB = */              0x0110, /* BCD: 01.00 (Version 1.0 USB spec) */
   /* .bDeviceClass = */        0xFF,   /* 0xFF = vendor-specific */
@@ -75,12 +75,13 @@ __code usb_device_descriptor_t device_descriptor = {
 
 /* WARNING: ALL config, interface and endpoint descriptors MUST be adjacent! */
 
-__code usb_config_descriptor_t config_descriptor = {
-  /* .bLength = */             sizeof(usb_config_descriptor_t),
+__code struct usb_config_descriptor config_descriptor = {
+  /* .bLength = */             sizeof(struct usb_config_descriptor),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_CONFIGURATION,
-  /* .wTotalLength = */        sizeof(usb_config_descriptor_t) +
-                               sizeof(usb_interface_descriptor_t) + 
-                               NUM_ENDPOINTS * sizeof(usb_endpoint_descriptor_t),
+  /* .wTotalLength = */        sizeof(struct usb_config_descriptor) +
+                               sizeof(struct usb_interface_descriptor) +
+                               (NUM_ENDPOINTS *
+                               sizeof(struct usb_endpoint_descriptor)),
   /* .bNumInterfaces = */      1,
   /* .bConfigurationValue = */ 1,
   /* .iConfiguration = */      4,     /* String describing this configuration */
@@ -88,8 +89,8 @@ __code usb_config_descriptor_t config_descriptor = {
   /* .MaxPower = */            50     /* 100 mA */
 };
 
-__code usb_interface_descriptor_t interface_descriptor00 = {
-  /* .bLength = */             sizeof(usb_interface_descriptor_t),
+__code struct usb_interface_descriptor interface_descriptor00 = {
+  /* .bLength = */             sizeof(struct usb_interface_descriptor),
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_INTERFACE,
   /* .bInterfaceNumber = */    0,
   /* .bAlternateSetting = */   0,
@@ -100,8 +101,8 @@ __code usb_interface_descriptor_t interface_descriptor00 = {
   /* .iInterface = */          0
 };
 
-__code usb_endpoint_descriptor_t Bulk_EP2_IN_Endpoint_Descriptor = {
-  /* .bLength = */             sizeof(usb_endpoint_descriptor_t),
+__code struct usb_endpoint_descriptor Bulk_EP2_IN_Endpoint_Descriptor = {
+  /* .bLength = */             sizeof(struct usb_endpoint_descriptor),
   /* .bDescriptorType = */     0x05,
   /* .bEndpointAddress = */    2 | USB_DIR_IN,
   /* .bmAttributes = */        0x02,
@@ -109,8 +110,8 @@ __code usb_endpoint_descriptor_t Bulk_EP2_IN_Endpoint_Descriptor = {
   /* .bInterval = */           0
 };
 
-__code usb_endpoint_descriptor_t Bulk_EP2_OUT_Endpoint_Descriptor = {
-  /* .bLength = */             sizeof(usb_endpoint_descriptor_t),
+__code struct usb_endpoint_descriptor Bulk_EP2_OUT_Endpoint_Descriptor = {
+  /* .bLength = */             sizeof(struct usb_endpoint_descriptor),
   /* .bDescriptorType = */     0x05,
   /* .bEndpointAddress = */    2 | USB_DIR_OUT,
   /* .bmAttributes = */        0x02,
@@ -118,19 +119,26 @@ __code usb_endpoint_descriptor_t Bulk_EP2_OUT_Endpoint_Descriptor = {
   /* .bInterval = */           0
 };
 
-__code usb_language_descriptor_t language_descriptor = {
+__code struct usb_language_descriptor language_descriptor = {
   /* .bLength =  */            4,
   /* .bDescriptorType = */     DESCRIPTOR_TYPE_STRING,
   /* .wLANGID = */             {0x0409 /* US English */}
 };
 
-__code usb_string_descriptor_t strManufacturer = STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
-__code usb_string_descriptor_t strProduct      = STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
-__code usb_string_descriptor_t strSerialNumber = STR_DESCR(6, '0','0','0','0','0','1');
-__code usb_string_descriptor_t strConfigDescr  = STR_DESCR(12, 'J','T','A','G',' ','A','d','a','p','t','e','r');
+__code struct usb_string_descriptor strManufacturer =
+    STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
+
+__code struct usb_string_descriptor strProduct      =
+    STR_DESCR(9,'O','p','e','n','U','L','I','N','K');
+
+__code struct usb_string_descriptor strSerialNumber =
+    STR_DESCR(6, '0','0','0','0','0','1');
+
+__code struct usb_string_descriptor strConfigDescr  =
+    STR_DESCR(12, 'J','T','A','G',' ','A','d','a','p','t','e','r');
 
 /* Table containing pointers to string descriptors */
-__code usb_string_descriptor_t* __code en_string_descriptors[4] = {
+__code struct usb_string_descriptor* __code en_string_descriptors[4] = {
   &amp;strManufacturer,
   &amp;strProduct,
   &amp;strSerialNumber,

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/OpenULINK/Makefile             |    3 +-
 src/jtag/drivers/OpenULINK/include/delay.h      |    6 +-
 src/jtag/drivers/OpenULINK/include/jtag.h       |   30 +++---
 src/jtag/drivers/OpenULINK/include/protocol.h   |    1 -
 src/jtag/drivers/OpenULINK/include/shorttypes.h |   41 -------
 src/jtag/drivers/OpenULINK/include/usb.h        |  142 +++++++++++-----------
 src/jtag/drivers/OpenULINK/src/delay.c          |   12 +-
 src/jtag/drivers/OpenULINK/src/jtag.c           |  120 ++++++++++----------
 src/jtag/drivers/OpenULINK/src/main.c           |    1 -
 src/jtag/drivers/OpenULINK/src/protocol.c       |   28 +++---
 src/jtag/drivers/OpenULINK/src/usb.c            |   66 ++++++-----
 src/jtag/drivers/ulink.c                        |   71 ++++++------
 12 files changed, 242 insertions(+), 279 deletions(-)
 delete mode 100644 src/jtag/drivers/OpenULINK/include/shorttypes.h


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002682.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-73-g355f183
</A></li>
	<LI>Next message: <A HREF="002684.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.5.0-77-g1411ad1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2683">[ date ]</a>
              <a href="thread.html#2683">[ thread ]</a>
              <a href="subject.html#2683">[ subject ]</a>
              <a href="author.html#2683">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
