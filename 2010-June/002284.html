<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-329-gf1ce4fe
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2010-June/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-329-gf1ce4fe&In-Reply-To=%3CE1OOeFV-0005IS-79%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002283.html">
   <LINK REL="Next"  HREF="002285.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-329-gf1ce4fe</H1>
    <B>&#216;yvind Harboe</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.4.0-329-gf1ce4fe&In-Reply-To=%3CE1OOeFV-0005IS-79%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-329-gf1ce4fe">gowinex at users.sourceforge.net
       </A><BR>
    <I>Wed Jun 16 00:04:47 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002283.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-328-g8022940
</A></li>
        <LI>Next message: <A HREF="002285.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-332-g72d227c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2284">[ date ]</a>
              <a href="thread.html#2284">[ thread ]</a>
              <a href="subject.html#2284">[ subject ]</a>
              <a href="author.html#2284">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  f1ce4fe288dc3a2682b8335177a2800980316ce3 (commit)
      from  8022940c5c3a12ecdbc8f8866351ee0ef5de1d35 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f1ce4fe288dc3a2682b8335177a2800980316ce3
Author: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;
Date:   Wed Jun 16 00:04:23 2010 +0200

    oops... backup file snuck in, remove it.
    
    Signed-off-by: &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;

diff --git a/src/helper/#jim.c# b/src/helper/#jim.c#
deleted file mode 100644
index c8583de..0000000
--- a/src/helper/#jim.c#
+++ /dev/null
@@ -1,12823 +0,0 @@
-/* Jim - A small embeddable Tcl interpreter
- *
- * Copyright 2005 Salvatore Sanfilippo &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">antirez at invece.org</A>&gt;
- * Copyright 2005 Clemens Hintze &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">c.hintze at gmx.net</A>&gt;
- * Copyright 2005 patthoyts - Pat Thoyts &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">patthoyts at users.sf.net</A>&gt;
- * Copyright 2008,2009 oharboe - &#129;&#216;yvind Harboe - <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>
- * Copyright 2008 Andrew Lunn &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">andrew at lunn.ch</A>&gt;
- * Copyright 2008 Duane Ellis &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">openocd at duaneellis.com</A>&gt;
- * Copyright 2008 Uwe Klein &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">uklein at klein-messgeraete.de</A>&gt;
- * Copyright 2008 Steve Bennett &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">steveb at workware.net.au</A>&gt;
- * Copyright 2009 Nico Coesel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">ncoesel at dealogic.nl</A>&gt;
- * Copyright 2009 Zachary T Welch <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>
- * Copyright 2009 David Brownell
- *
- * The FreeBSD license
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above
- *    copyright notice, this list of conditions and the following
- *    disclaimer in the documentation and/or other materials
- *    provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE JIM TCL PROJECT ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * JIM TCL PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
- * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
- * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- * The views and conclusions contained in the software and documentation
- * are those of the authors and should not be interpreted as representing
- * official policies, either expressed or implied, of the Jim Tcl Project.
- **/
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#define __JIM_CORE__
-#define JIM_OPTIMIZATION /* comment to avoid optimizations and reduce size */
-
-#ifdef __ECOS
-#include &lt;pkgconf/jimtcl.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-typedef CYG_ADDRWORD intptr_t;
-
-#include &lt;string.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;limits.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;time.h&gt;
-#endif
-#ifndef JIM_ANSIC
-#define JIM_DYNLIB      /* Dynamic library support for UNIX and WIN32 */
-#endif /* JIM_ANSIC */
-
-#include &lt;stdarg.h&gt;
-#include &lt;limits.h&gt;
-
-/* Include the platform dependent libraries for
- * dynamic loading of libraries. */
-#ifdef JIM_DYNLIB
-#if defined(_WIN32) || defined(WIN32)
-#ifndef WIN32
-#define WIN32 1
-#endif
-#ifndef STRICT
-#define STRICT
-#endif
-#define WIN32_LEAN_AND_MEAN
-#include &lt;windows.h&gt;
-#if _MSC_VER &gt;= 1000
-#pragma warning(disable:4146)
-#endif /* _MSC_VER */
-#else
-#include &lt;dlfcn.h&gt;
-#endif /* WIN32 */
-#endif /* JIM_DYNLIB */
-
-#ifdef __ECOS
-#include &lt;cyg/jimtcl/jim.h&gt;
-#else
-#include &quot;jim.h&quot;
-#endif
-
-#ifdef HAVE_BACKTRACE
-#include &lt;execinfo.h&gt;
-#endif
-
-/* -----------------------------------------------------------------------------
- * Global variables
- * ---------------------------------------------------------------------------*/
-
-/* A shared empty string for the objects string representation.
- * Jim_InvalidateStringRep knows about it and don't try to free. */
-static char *JimEmptyStringRep = (char*) &quot;&quot;;
-
-/* -----------------------------------------------------------------------------
- * Required prototypes of not exported functions
- * ---------------------------------------------------------------------------*/
-static void JimChangeCallFrameId(Jim_Interp *interp, Jim_CallFrame *cf);
-static void JimFreeCallFrame(Jim_Interp *interp, Jim_CallFrame *cf, int flags);
-static void JimRegisterCoreApi(Jim_Interp *interp);
-
-static Jim_HashTableType *getJimVariablesHashTableType(void);
-
-/* -----------------------------------------------------------------------------
- * Utility functions
- * ---------------------------------------------------------------------------*/
-
-static char *
-jim_vasprintf(const char *fmt, va_list ap)
-{
-#ifndef HAVE_VASPRINTF
-	/* yucky way */
-static char buf[2048];
-	vsnprintf(buf, sizeof(buf), fmt, ap);
-	/* garentee termination */
-	buf[sizeof(buf)-1] = 0;
-#else
-	char *buf;
-	int result;
-	result = vasprintf(&amp;buf, fmt, ap);
-	if (result &lt; 0) exit(-1);
-#endif
-	return buf;
-}
-
-static void
-jim_vasprintf_done(void *buf)
-{
-#ifndef HAVE_VASPRINTF
-	(void)(buf);
-#else
-	free(buf);
-#endif
-}
-
-
-/*
- * Convert a string to a jim_wide INTEGER.
- * This function originates from BSD.
- *
- * Ignores `locale' stuff.  Assumes that the upper and lower case
- * alphabets and digits are each contiguous.
- */
-#ifdef HAVE_LONG_LONG_INT
-#define JimIsAscii(c) (((c) &amp; ~0x7f) == 0)
-static jim_wide JimStrtoll(const char *nptr, char **endptr, register int base)
-{
-    register const char *s;
-    register unsigned jim_wide acc;
-    register unsigned char c;
-    register unsigned jim_wide qbase, cutoff;
-    register int neg, any, cutlim;
-
-    /*
-     * Skip white space and pick up leading +/- sign if any.
-     * If base is 0, allow 0x for hex and 0 for octal, else
-     * assume decimal; if base is already 16, allow 0x.
-     */
-    s = nptr;
-    do {
-        c = *s++;
-    } while (isspace(c));
-    if (c == '-') {
-        neg = 1;
-        c = *s++;
-    } else {
-        neg = 0;
-        if (c == '+')
-            c = *s++;
-    }
-    if ((base == 0 || base == 16) &amp;&amp;
-        c == '0' &amp;&amp; (*s == 'x' || *s == 'X')) {
-        c = s[1];
-        s += 2;
-        base = 16;
-    }
-    if (base == 0)
-        base = c == '0' ? 8 : 10;
-
-    /*
-     * Compute the cutoff value between legal numbers and illegal
-     * numbers.  That is the largest legal value, divided by the
-     * base.  An input number that is greater than this value, if
-     * followed by a legal input character, is too big.  One that
-     * is equal to this value may be valid or not; the limit
-     * between valid and invalid numbers is then based on the last
-     * digit.  For instance, if the range for quads is
-     * [-9223372036854775808..9223372036854775807] and the input base
-     * is 10, cutoff will be set to 922337203685477580 and cutlim to
-     * either 7 (neg == 0) or 8 (neg == 1), meaning that if we have
-     * accumulated a value &gt; 922337203685477580, or equal but the
-     * next digit is &gt; 7 (or 8), the number is too big, and we will
-     * return a range error.
-     *
-     * Set any if any `digits' consumed; make it negative to indicate
-     * overflow.
-     */
-    qbase = (unsigned)base;
-    cutoff = neg ? (unsigned jim_wide)-(LLONG_MIN + LLONG_MAX) + LLONG_MAX
-        : LLONG_MAX;
-    cutlim = (int)(cutoff % qbase);
-    cutoff /= qbase;
-    for (acc = 0, any = 0;; c = *s++) {
-        if (!JimIsAscii(c))
-            break;
-        if (isdigit(c))
-            c -= '0';
-        else if (isalpha(c))
-            c -= isupper(c) ? 'A' - 10 : 'a' - 10;
-        else
-            break;
-        if (c &gt;= base)
-            break;
-        if (any &lt; 0 || acc &gt; cutoff || (acc == cutoff &amp;&amp; c &gt; cutlim))
-            any = -1;
-        else {
-            any = 1;
-            acc *= qbase;
-            acc += c;
-        }
-    }
-    if (any &lt; 0) {
-        acc = neg ? LLONG_MIN : LLONG_MAX;
-        errno = ERANGE;
-    } else if (neg)
-        acc = -acc;
-    if (endptr != 0)
-        *endptr = (char *)(any ? s - 1 : nptr);
-    return (acc);
-}
-#endif
-
-/* Glob-style pattern matching. */
-static int JimStringMatch(const char *pattern, int patternLen,
-        const char *string, int stringLen, int nocase)
-{
-    while (patternLen) {
-        switch (pattern[0]) {
-        case '*':
-            while (pattern[1] == '*') {
-                pattern++;
-                patternLen--;
-            }
-            if (patternLen == 1)
-                return 1; /* match */
-            while (stringLen) {
-                if (JimStringMatch(pattern + 1, patternLen-1,
-                            string, stringLen, nocase))
-                    return 1; /* match */
-                string++;
-                stringLen--;
-            }
-            return 0; /* no match */
-            break;
-        case '?':
-            if (stringLen == 0)
-                return 0; /* no match */
-            string++;
-            stringLen--;
-            break;
-        case '[':
-        {
-            int not, match;
-
-            pattern++;
-            patternLen--;
-            not = pattern[0] == '^';
-            if (not) {
-                pattern++;
-                patternLen--;
-            }
-            match = 0;
-            while (1) {
-                if (pattern[0] == '\\') {
-                    pattern++;
-                    patternLen--;
-                    if (pattern[0] == string[0])
-                        match = 1;
-                } else if (pattern[0] == ']') {
-                    break;
-                } else if (patternLen == 0) {
-                    pattern--;
-                    patternLen++;
-                    break;
-                } else if (pattern[1] == '-' &amp;&amp; patternLen &gt;= 3) {
-                    int start = pattern[0];
-                    int end = pattern[2];
-                    int c = string[0];
-                    if (start &gt; end) {
-                        int t = start;
-                        start = end;
-                        end = t;
-                    }
-                    if (nocase) {
-                        start = tolower(start);
-                        end = tolower(end);
-                        c = tolower(c);
-                    }
-                    pattern += 2;
-                    patternLen -= 2;
-                    if (c &gt;= start &amp;&amp; c &lt;= end)
-                        match = 1;
-                } else {
-                    if (!nocase) {
-                        if (pattern[0] == string[0])
-                            match = 1;
-                    } else {
-                        if (tolower((int)pattern[0]) == tolower((int)string[0]))
-                            match = 1;
-                    }
-                }
-                pattern++;
-                patternLen--;
-            }
-            if (not)
-                match = !match;
-            if (!match)
-                return 0; /* no match */
-            string++;
-            stringLen--;
-            break;
-        }
-        case '\\':
-            if (patternLen &gt;= 2) {
-                pattern++;
-                patternLen--;
-            }
-            /* fall through */
-        default:
-            if (!nocase) {
-                if (pattern[0] != string[0])
-                    return 0; /* no match */
-            } else {
-                if (tolower((int)pattern[0]) != tolower((int)string[0]))
-                    return 0; /* no match */
-            }
-            string++;
-            stringLen--;
-            break;
-        }
-        pattern++;
-        patternLen--;
-        if (stringLen == 0) {
-            while (*pattern == '*') {
-                pattern++;
-                patternLen--;
-            }
-            break;
-        }
-    }
-    if (patternLen == 0 &amp;&amp; stringLen == 0)
-        return 1;
-    return 0;
-}
-
-int JimStringCompare(const char *s1, int l1, const char *s2, int l2,
-        int nocase)
-{
-    unsigned char *u1 = (unsigned char*) s1, *u2 = (unsigned char*) s2;
-
-    if (nocase == 0) {
-        while (l1 &amp;&amp; l2) {
-            if (*u1 != *u2)
-                return (int)*u1-*u2;
-            u1++; u2++; l1--; l2--;
-        }
-        if (!l1 &amp;&amp; !l2) return 0;
-        return l1-l2;
-    } else {
-        while (l1 &amp;&amp; l2) {
-            if (tolower((int)*u1) != tolower((int)*u2))
-                return tolower((int)*u1)-tolower((int)*u2);
-            u1++; u2++; l1--; l2--;
-        }
-        if (!l1 &amp;&amp; !l2) return 0;
-        return l1-l2;
-    }
-}
-
-/* Search 's1' inside 's2', starting to search from char 'index' of 's2'.
- * The index of the first occurrence of s1 in s2 is returned.
- * If s1 is not found inside s2, -1 is returned. */
-int JimStringFirst(const char *s1, int l1, const char *s2, int l2, int index_t)
-{
-    int i;
-
-    if (!l1 || !l2 || l1 &gt; l2) return -1;
-    if (index_t &lt; 0) index_t = 0;
-    s2 += index_t;
-    for (i = index_t; i &lt;= l2-l1; i++) {
-        if (memcmp(s2, s1, l1) == 0)
-            return i;
-        s2++;
-    }
-    return -1;
-}
-
-int Jim_WideToString(char *buf, jim_wide wideValue)
-{
-    const char *fmt = &quot;%&quot; JIM_WIDE_MODIFIER;
-    return sprintf(buf, fmt, wideValue);
-}
-
-int Jim_StringToWide(const char *str, jim_wide *widePtr, int base)
-{
-    char *endptr;
-
-#ifdef HAVE_LONG_LONG_INT
-    *widePtr = JimStrtoll(str, &amp;endptr, base);
-#else
-    *widePtr = strtol(str, &amp;endptr, base);
-#endif
-    if ((str[0] == '\0') || (str == endptr))
-        return JIM_ERR;
-    if (endptr[0] != '\0') {
-        while (*endptr) {
-            if (!isspace((int)*endptr))
-                return JIM_ERR;
-            endptr++;
-        }
-    }
-    return JIM_OK;
-}
-
-int Jim_StringToIndex(const char *str, int *intPtr)
-{
-    char *endptr;
-
-    *intPtr = strtol(str, &amp;endptr, 10);
-    if ((str[0] == '\0') || (str == endptr))
-        return JIM_ERR;
-    if (endptr[0] != '\0') {
-        while (*endptr) {
-            if (!isspace((int)*endptr))
-                return JIM_ERR;
-            endptr++;
-        }
-    }
-    return JIM_OK;
-}
-
-/* The string representation of references has two features in order
- * to make the GC faster. The first is that every reference starts
- * with a non common character '~', in order to make the string matching
- * fater. The second is that the reference string rep his 32 characters
- * in length, this allows to avoid to check every object with a string
- * repr &lt; 32, and usually there are many of this objects. */
-
-#define JIM_REFERENCE_SPACE (35 + JIM_REFERENCE_TAGLEN)
-
-static int JimFormatReference(char *buf, Jim_Reference *refPtr, jim_wide id)
-{
-    const char *fmt = &quot;&lt;reference.&lt;%s&gt;.%020&quot; JIM_WIDE_MODIFIER &quot;&gt;&quot;;
-    sprintf(buf, fmt, refPtr-&gt;tag, id);
-    return JIM_REFERENCE_SPACE;
-}
-
-int Jim_DoubleToString(char *buf, double doubleValue)
-{
-    char *s;
-    int len;
-
-    len = sprintf(buf, &quot;%.17g&quot;, doubleValue);
-    s = buf;
-    while (*s) {
-        if (*s == '.') return len;
-        s++;
-    }
-    /* Add a final &quot;.0&quot; if it's a number. But not
-     * for NaN or InF */
-    if (isdigit((int)buf[0])
-        || ((buf[0] == '-' || buf[0] == '+')
-            &amp;&amp; isdigit((int)buf[1]))) {
-        s[0] = '.';
-        s[1] = '0';
-        s[2] = '\0';
-        return len + 2;
-    }
-    return len;
-}
-
-int Jim_StringToDouble(const char *str, double *doublePtr)
-{
-    char *endptr;
-
-    *doublePtr = strtod(str, &amp;endptr);
-    if (str[0] == '\0' || endptr[0] != '\0' || (str == endptr))
-        return JIM_ERR;
-    return JIM_OK;
-}
-
-static jim_wide JimPowWide(jim_wide b, jim_wide e)
-{
-    jim_wide i, res = 1;
-    if ((b == 0 &amp;&amp; e != 0) || (e &lt; 0)) return 0;
-    for (i = 0; i &lt; e; i++) {res *= b;}
-    return res;
-}
-
-/* -----------------------------------------------------------------------------
- * Special functions
- * ---------------------------------------------------------------------------*/
-
-/* Note that 'interp' may be NULL if not available in the
- * context of the panic. It's only useful to get the error
- * file descriptor, it will default to stderr otherwise. */
-void Jim_Panic(Jim_Interp *interp, const char *fmt, ...)
-{
-    va_list ap;
-
-    va_start(ap, fmt);
-	/*
-	 * Send it here first.. Assuming STDIO still works
-	 */
-    fprintf(stderr, JIM_NL &quot;JIM INTERPRETER PANIC: &quot;);
-    vfprintf(stderr, fmt, ap);
-    fprintf(stderr, JIM_NL JIM_NL);
-    va_end(ap);
-
-#ifdef HAVE_BACKTRACE
-    {
-        void *array[40];
-        int size, i;
-        char **strings;
-
-        size = backtrace(array, 40);
-        strings = backtrace_symbols(array, size);
-        for (i = 0; i &lt; size; i++)
-            fprintf(fp,&quot;[backtrace] %s&quot; JIM_NL, strings[i]);
-        fprintf(fp,&quot;[backtrace] Include the above lines and the output&quot; JIM_NL);
-        fprintf(fp,&quot;[backtrace] of 'nm &lt;executable&gt;' in the bug report.&quot; JIM_NL);
-    }
-#endif
-
-	/* This may actually crash... we do it last */
-	if (interp &amp;&amp; interp-&gt;cookie_stderr) {
-		Jim_fprintf(interp, interp-&gt;cookie_stderr, JIM_NL &quot;JIM INTERPRETER PANIC: &quot;);
-		Jim_vfprintf(interp, interp-&gt;cookie_stderr, fmt, ap);
-		Jim_fprintf(interp, interp-&gt;cookie_stderr, JIM_NL JIM_NL);
-	}
-    abort();
-}
-
-/* -----------------------------------------------------------------------------
- * Memory allocation
- * ---------------------------------------------------------------------------*/
-
-/* Macro used for memory debugging.
- * In order for they to work you have to rename Jim_Alloc into _Jim_Alloc
- * and similary for Jim_Realloc and Jim_Free */
-#if 0
-#define Jim_Alloc(s) (printf(&quot;%s %d: Jim_Alloc(%d)\n&quot;,__FILE__,__LINE__,s),_Jim_Alloc(s))
-#define Jim_Free(p) (printf(&quot;%s %d: Jim_Free(%p)\n&quot;,__FILE__,__LINE__,p),_Jim_Free(p))
-#define Jim_Realloc(p,s) (printf(&quot;%s %d: Jim_Realloc(%p,%d)\n&quot;,__FILE__,__LINE__,p,s),_Jim_Realloc(p,s))
-#endif
-
-void *Jim_Alloc(int size)
-{
-	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
-	if (size == 0)
-		size = 1;
-    void *p = malloc(size);
-    if (p == NULL)
-        Jim_Panic(NULL,&quot;malloc: Out of memory&quot;);
-    return p;
-}
-
-void Jim_Free(void *ptr) {
-    free(ptr);
-}
-
-void *Jim_Realloc(void *ptr, int size)
-{
-	/* We allocate zero length arrayes, etc. to use a single orthogonal codepath */
-	if (size == 0)
-		size = 1;
-    void *p = realloc(ptr, size);
-    if (p == NULL)
-        Jim_Panic(NULL,&quot;realloc: Out of memory&quot;);
-    return p;
-}
-
-char *Jim_StrDup(const char *s)
-{
-    int l = strlen(s);
-    char *copy = Jim_Alloc(l + 1);
-
-    memcpy(copy, s, l + 1);
-    return copy;
-}
-
-char *Jim_StrDupLen(const char *s, int l)
-{
-    char *copy = Jim_Alloc(l + 1);
-
-    memcpy(copy, s, l + 1);
-    copy[l] = 0;    /* Just to be sure, original could be substring */
-    return copy;
-}
-
-/* -----------------------------------------------------------------------------
- * Time related functions
- * ---------------------------------------------------------------------------*/
-/* Returns microseconds of CPU used since start. */
-static jim_wide JimClock(void)
-{
-#if (defined WIN32) &amp;&amp; !(defined JIM_ANSIC)
-    LARGE_INTEGER t, f;
-    QueryPerformanceFrequency(&amp;f);
-    QueryPerformanceCounter(&amp;t);
-    return (long)((t.QuadPart * 1000000) / f.QuadPart);
-#else /* !WIN32 */
-    clock_t clocks = clock();
-
-    return (long)(clocks*(1000000/CLOCKS_PER_SEC));
-#endif /* WIN32 */
-}
-
-/* -----------------------------------------------------------------------------
- * Hash Tables
- * ---------------------------------------------------------------------------*/
-
-/* -------------------------- private prototypes ---------------------------- */
-static int JimExpandHashTableIfNeeded(Jim_HashTable *ht);
-static unsigned int JimHashTableNextPower(unsigned int size);
-static int JimInsertHashEntry(Jim_HashTable *ht, const void *key);
-
-/* -------------------------- hash functions -------------------------------- */
-
-/* Thomas Wang's 32 bit Mix Function */
-unsigned int Jim_IntHashFunction(unsigned int key)
-{
-    key += ~(key &lt;&lt; 15);
-    key ^=  (key &gt;&gt; 10);
-    key +=  (key &lt;&lt; 3);
-    key ^=  (key &gt;&gt; 6);
-    key += ~(key &lt;&lt; 11);
-    key ^=  (key &gt;&gt; 16);
-    return key;
-}
-
-/* Identity hash function for integer keys */
-unsigned int Jim_IdentityHashFunction(unsigned int key)
-{
-    return key;
-}
-
-/* Generic hash function (we are using to multiply by 9 and add the byte
- * as Tcl) */
-unsigned int Jim_GenHashFunction(const unsigned char *buf, int len)
-{
-    unsigned int h = 0;
-    while (len--)
-        h += (h &lt;&lt; 3)+*buf++;
-    return h;
-}
-
-/* ----------------------------- API implementation ------------------------- */
-/* reset an hashtable already initialized with ht_init().
- * NOTE: This function should only called by ht_destroy(). */
-static void JimResetHashTable(Jim_HashTable *ht)
-{
-    ht-&gt;table = NULL;
-    ht-&gt;size = 0;
-    ht-&gt;sizemask = 0;
-    ht-&gt;used = 0;
-    ht-&gt;collisions = 0;
-}
-
-/* Initialize the hash table */
-int Jim_InitHashTable(Jim_HashTable *ht, Jim_HashTableType *type,
-        void *privDataPtr)
-{
-    JimResetHashTable(ht);
-    ht-&gt;type = type;
-    ht-&gt;privdata = privDataPtr;
-    return JIM_OK;
-}
-
-/* Resize the table to the minimal size that contains all the elements,
- * but with the invariant of a USER/BUCKETS ration near to &lt;= 1 */
-int Jim_ResizeHashTable(Jim_HashTable *ht)
-{
-    int minimal = ht-&gt;used;
-
-    if (minimal &lt; JIM_HT_INITIAL_SIZE)
-        minimal = JIM_HT_INITIAL_SIZE;
-    return Jim_ExpandHashTable(ht, minimal);
-}
-
-/* Expand or create the hashtable */
-int Jim_ExpandHashTable(Jim_HashTable *ht, unsigned int size)
-{
-    Jim_HashTable n; /* the new hashtable */
-    unsigned int realsize = JimHashTableNextPower(size), i;
-
-    /* the size is invalid if it is smaller than the number of
-     * elements already inside the hashtable */
-    if (ht-&gt;used &gt;= size)
-        return JIM_ERR;
-
-    Jim_InitHashTable(&amp;n, ht-&gt;type, ht-&gt;privdata);
-    n.size = realsize;
-    n.sizemask = realsize-1;
-    n.table = Jim_Alloc(realsize*sizeof(Jim_HashEntry*));
-
-    /* Initialize all the pointers to NULL */
-    memset(n.table, 0, realsize*sizeof(Jim_HashEntry*));
-
-    /* Copy all the elements from the old to the new table:
-     * note that if the old hash table is empty ht-&gt;size is zero,
-     * so Jim_ExpandHashTable just creates an hash table. */
-    n.used = ht-&gt;used;
-    for (i = 0; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; 0; i++) {
-        Jim_HashEntry *he, *nextHe;
-
-        if (ht-&gt;table[i] == NULL) continue;
-
-        /* For each hash entry on this slot... */
-        he = ht-&gt;table[i];
-        while (he) {
-            unsigned int h;
-
-            nextHe = he-&gt;next;
-            /* Get the new element index */
-            h = Jim_HashKey(ht, he-&gt;key) &amp; n.sizemask;
-            he-&gt;next = n.table[h];
-            n.table[h] = he;
-            ht-&gt;used--;
-            /* Pass to the next element */
-            he = nextHe;
-        }
-    }
-    assert(ht-&gt;used == 0);
-    Jim_Free(ht-&gt;table);
-
-    /* Remap the new hashtable in the old */
-    *ht = n;
-    return JIM_OK;
-}
-
-/* Add an element to the target hash table */
-int Jim_AddHashEntry(Jim_HashTable *ht, const void *key, void *val)
-{
-    int index_t;
-    Jim_HashEntry *entry;
-
-    /* Get the index of the new element, or -1 if
-     * the element already exists. */
-    if ((index_t = JimInsertHashEntry(ht, key)) == -1)
-        return JIM_ERR;
-
-    /* Allocates the memory and stores key */
-    entry = Jim_Alloc(sizeof(*entry));
-    entry-&gt;next = ht-&gt;table[index_t];
-    ht-&gt;table[index_t] = entry;
-
-    /* Set the hash entry fields. */
-    Jim_SetHashKey(ht, entry, key);
-    Jim_SetHashVal(ht, entry, val);
-    ht-&gt;used++;
-    return JIM_OK;
-}
-
-/* Add an element, discarding the old if the key already exists */
-int Jim_ReplaceHashEntry(Jim_HashTable *ht, const void *key, void *val)
-{
-    Jim_HashEntry *entry;
-
-    /* Try to add the element. If the key
-     * does not exists Jim_AddHashEntry will suceed. */
-    if (Jim_AddHashEntry(ht, key, val) == JIM_OK)
-        return JIM_OK;
-    /* It already exists, get the entry */
-    entry = Jim_FindHashEntry(ht, key);
-    /* Free the old value and set the new one */
-    Jim_FreeEntryVal(ht, entry);
-    Jim_SetHashVal(ht, entry, val);
-    return JIM_OK;
-}
-
-/* Search and remove an element */
-int Jim_DeleteHashEntry(Jim_HashTable *ht, const void *key)
-{
-    unsigned int h;
-    Jim_HashEntry *he, *prevHe;
-
-    if (ht-&gt;size == 0)
-        return JIM_ERR;
-    h = Jim_HashKey(ht, key) &amp; ht-&gt;sizemask;
-    he = ht-&gt;table[h];
-
-    prevHe = NULL;
-    while (he) {
-        if (Jim_CompareHashKeys(ht, key, he-&gt;key)) {
-            /* Unlink the element from the list */
-            if (prevHe)
-                prevHe-&gt;next = he-&gt;next;
-            else
-                ht-&gt;table[h] = he-&gt;next;
-            Jim_FreeEntryKey(ht, he);
-            Jim_FreeEntryVal(ht, he);
-            Jim_Free(he);
-            ht-&gt;used--;
-            return JIM_OK;
-        }
-        prevHe = he;
-        he = he-&gt;next;
-    }
-    return JIM_ERR; /* not found */
-}
-
-/* Destroy an entire hash table */
-int Jim_FreeHashTable(Jim_HashTable *ht)
-{
-    unsigned int i;
-
-    /* Free all the elements */
-    for (i = 0; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; 0; i++) {
-        Jim_HashEntry *he, *nextHe;
-
-        if ((he = ht-&gt;table[i]) == NULL) continue;
-        while (he) {
-            nextHe = he-&gt;next;
-            Jim_FreeEntryKey(ht, he);
-            Jim_FreeEntryVal(ht, he);
-            Jim_Free(he);
-            ht-&gt;used--;
-            he = nextHe;
-        }
-    }
-    /* Free the table and the allocated cache structure */
-    Jim_Free(ht-&gt;table);
-    /* Re-initialize the table */
-    JimResetHashTable(ht);
-    return JIM_OK; /* never fails */
-}
-
-Jim_HashEntry *Jim_FindHashEntry(Jim_HashTable *ht, const void *key)
-{
-    Jim_HashEntry *he;
-    unsigned int h;
-
-    if (ht-&gt;size == 0) return NULL;
-    h = Jim_HashKey(ht, key) &amp; ht-&gt;sizemask;
-    he = ht-&gt;table[h];
-    while (he) {
-        if (Jim_CompareHashKeys(ht, key, he-&gt;key))
-            return he;
-        he = he-&gt;next;
-    }
-    return NULL;
-}
-
-Jim_HashTableIterator *Jim_GetHashTableIterator(Jim_HashTable *ht)
-{
-    Jim_HashTableIterator *iter = Jim_Alloc(sizeof(*iter));
-
-    iter-&gt;ht = ht;
-    iter-&gt;index = -1;
-    iter-&gt;entry = NULL;
-    iter-&gt;nextEntry = NULL;
-    return iter;
-}
-
-Jim_HashEntry *Jim_NextHashEntry(Jim_HashTableIterator *iter)
-{
-    while (1) {
-        if (iter-&gt;entry == NULL) {
-            iter-&gt;index++;
-            if (iter-&gt;index &gt;=
-                    (signed)iter-&gt;ht-&gt;size) break;
-            iter-&gt;entry = iter-&gt;ht-&gt;table[iter-&gt;index];
-        } else {
-            iter-&gt;entry = iter-&gt;nextEntry;
-        }
-        if (iter-&gt;entry) {
-            /* We need to save the 'next' here, the iterator user
-             * may delete the entry we are returning. */
-            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;
-            return iter-&gt;entry;
-        }
-    }
-    return NULL;
-}
-
-/* ------------------------- private functions ------------------------------ */
-
-/* Expand the hash table if needed */
-static int JimExpandHashTableIfNeeded(Jim_HashTable *ht)
-{
-    /* If the hash table is empty expand it to the intial size,
-     * if the table is &quot;full&quot; dobule its size. */
-    if (ht-&gt;size == 0)
-        return Jim_ExpandHashTable(ht, JIM_HT_INITIAL_SIZE);
-    if (ht-&gt;size == ht-&gt;used)
-        return Jim_ExpandHashTable(ht, ht-&gt;size*2);
-    return JIM_OK;
-}
-
-/* Our hash table capability is a power of two */
-static unsigned int JimHashTableNextPower(unsigned int size)
-{
-    unsigned int i = JIM_HT_INITIAL_SIZE;
-
-    if (size &gt;= 2147483648U)
-        return 2147483648U;
-    while (1) {
-        if (i &gt;= size)
-            return i;
-        i *= 2;
-    }
-}
-
-/* Returns the index of a free slot that can be populated with
- * an hash entry for the given 'key'.
- * If the key already exists, -1 is returned. */
-static int JimInsertHashEntry(Jim_HashTable *ht, const void *key)
-{
-    unsigned int h;
-    Jim_HashEntry *he;
-
-    /* Expand the hashtable if needed */
-    if (JimExpandHashTableIfNeeded(ht) == JIM_ERR)
-        return -1;
-    /* Compute the key hash value */
-    h = Jim_HashKey(ht, key) &amp; ht-&gt;sizemask;
-    /* Search if this slot does not already contain the given key */
-    he = ht-&gt;table[h];
-    while (he) {
-        if (Jim_CompareHashKeys(ht, key, he-&gt;key))
-            return -1;
-        he = he-&gt;next;
-    }
-    return h;
-}
-
-/* ----------------------- StringCopy Hash Table Type ------------------------*/
-
-static unsigned int JimStringCopyHTHashFunction(const void *key)
-{
-    return Jim_GenHashFunction(key, strlen(key));
-}
-
-static const void *JimStringCopyHTKeyDup(void *privdata, const void *key)
-{
-    int len = strlen(key);
-    char *copy = Jim_Alloc(len + 1);
-    JIM_NOTUSED(privdata);
-
-    memcpy(copy, key, len);
-    copy[len] = '\0';
-    return copy;
-}
-
-static void *JimStringKeyValCopyHTValDup(void *privdata, const void *val)
-{
-    int len = strlen(val);
-    char *copy = Jim_Alloc(len + 1);
-    JIM_NOTUSED(privdata);
-
-    memcpy(copy, val, len);
-    copy[len] = '\0';
-    return copy;
-}
-
-static int JimStringCopyHTKeyCompare(void *privdata, const void *key1,
-        const void *key2)
-{
-    JIM_NOTUSED(privdata);
-
-    return strcmp(key1, key2) == 0;
-}
-
-static void JimStringCopyHTKeyDestructor(void *privdata, const void *key)
-{
-    JIM_NOTUSED(privdata);
-
-    Jim_Free((void*)key); /* ATTENTION: const cast */
-}
-
-static void JimStringKeyValCopyHTValDestructor(void *privdata, void *val)
-{
-    JIM_NOTUSED(privdata);
-
-    Jim_Free((void*)val); /* ATTENTION: const cast */
-}
-
-static Jim_HashTableType JimStringCopyHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,              /* key dup */
-    NULL,                               /* val dup */
-    JimStringCopyHTKeyCompare,          /* key compare */
-    JimStringCopyHTKeyDestructor,       /* key destructor */
-    NULL                                /* val destructor */
-};
-
-/* This is like StringCopy but does not auto-duplicate the key.
- * It's used for intepreter's shared strings. */
-static Jim_HashTableType JimSharedStringsHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    NULL,                               /* key dup */
-    NULL,                               /* val dup */
-    JimStringCopyHTKeyCompare,          /* key compare */
-    JimStringCopyHTKeyDestructor,       /* key destructor */
-    NULL                                /* val destructor */
-};
-
-/* This is like StringCopy but also automatically handle dynamic
- * allocated C strings as values. */
-static Jim_HashTableType JimStringKeyValCopyHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,              /* key dup */
-    JimStringKeyValCopyHTValDup,        /* val dup */
-    JimStringCopyHTKeyCompare,          /* key compare */
-    JimStringCopyHTKeyDestructor,       /* key destructor */
-    JimStringKeyValCopyHTValDestructor, /* val destructor */
-};
-
-typedef struct AssocDataValue {
-    Jim_InterpDeleteProc *delProc;
-    void *data;
-} AssocDataValue;
-
-static void JimAssocDataHashTableValueDestructor(void *privdata, void *data)
-{
-    AssocDataValue *assocPtr = (AssocDataValue *)data;
-    if (assocPtr-&gt;delProc != NULL)
-        assocPtr-&gt;delProc((Jim_Interp *)privdata, assocPtr-&gt;data);
-    Jim_Free(data);
-}
-
-static Jim_HashTableType JimAssocDataHashTableType = {
-    JimStringCopyHTHashFunction,         /* hash function */
-    JimStringCopyHTKeyDup,               /* key dup */
-    NULL,                                /* val dup */
-    JimStringCopyHTKeyCompare,           /* key compare */
-    JimStringCopyHTKeyDestructor,        /* key destructor */
-    JimAssocDataHashTableValueDestructor /* val destructor */
-};
-
-/* -----------------------------------------------------------------------------
- * Stack - This is a simple generic stack implementation. It is used for
- * example in the 'expr' expression compiler.
- * ---------------------------------------------------------------------------*/
-void Jim_InitStack(Jim_Stack *stack)
-{
-    stack-&gt;len = 0;
-    stack-&gt;maxlen = 0;
-    stack-&gt;vector = NULL;
-}
-
-void Jim_FreeStack(Jim_Stack *stack)
-{
-    Jim_Free(stack-&gt;vector);
-}
-
-int Jim_StackLen(Jim_Stack *stack)
-{
-    return stack-&gt;len;
-}
-
-void Jim_StackPush(Jim_Stack *stack, void *element) {
-    int neededLen = stack-&gt;len + 1;
-    if (neededLen &gt; stack-&gt;maxlen) {
-        stack-&gt;maxlen = neededLen*2;
-        stack-&gt;vector = Jim_Realloc(stack-&gt;vector, sizeof(void*)*stack-&gt;maxlen);
-    }
-    stack-&gt;vector[stack-&gt;len] = element;
-    stack-&gt;len++;
-}
-
-void *Jim_StackPop(Jim_Stack *stack)
-{
-    if (stack-&gt;len == 0) return NULL;
-    stack-&gt;len--;
-    return stack-&gt;vector[stack-&gt;len];
-}
-
-void *Jim_StackPeek(Jim_Stack *stack)
-{
-    if (stack-&gt;len == 0) return NULL;
-    return stack-&gt;vector[stack-&gt;len-1];
-}
-
-void Jim_FreeStackElements(Jim_Stack *stack, void (*freeFunc)(void *ptr))
-{
-    int i;
-
-    for (i = 0; i &lt; stack-&gt;len; i++)
-        freeFunc(stack-&gt;vector[i]);
-}
-
-/* -----------------------------------------------------------------------------
- * Parser
- * ---------------------------------------------------------------------------*/
-
-/* Token types */
-#define JIM_TT_NONE -1        /* No token returned */
-#define JIM_TT_STR 0        /* simple string */
-#define JIM_TT_ESC 1        /* string that needs escape chars conversion */
-#define JIM_TT_VAR 2        /* var substitution */
-#define JIM_TT_DICTSUGAR 3    /* Syntax sugar for [dict get], $foo(bar) */
-#define JIM_TT_CMD 4        /* command substitution */
-#define JIM_TT_SEP 5        /* word separator */
-#define JIM_TT_EOL 6        /* line separator */
-
-/* Additional token types needed for expressions */
-#define JIM_TT_SUBEXPR_START 7
-#define JIM_TT_SUBEXPR_END 8
-#define JIM_TT_EXPR_NUMBER 9
-#define JIM_TT_EXPR_OPERATOR 10
-
-/* Parser states */
-#define JIM_PS_DEF 0        /* Default state */
-#define JIM_PS_QUOTE 1        /* Inside &quot;&quot; */
-
-/* Parser context structure. The same context is used both to parse
- * Tcl scripts and lists. */
-struct JimParserCtx {
-    const char *prg;     /* Program text */
-    const char *p;       /* Pointer to the point of the program we are parsing */
-    int len;             /* Left length of 'prg' */
-    int linenr;          /* Current line number */
-    const char *tstart;
-    const char *tend;    /* Returned token is at tstart-tend in 'prg'. */
-    int tline;           /* Line number of the returned token */
-    int tt;              /* Token type */
-    int eof;             /* Non zero if EOF condition is true. */
-    int state;           /* Parser state */
-    int comment;         /* Non zero if the next chars may be a comment. */
-};
-
-#define JimParserEof(c) ((c)-&gt;eof)
-#define JimParserTstart(c) ((c)-&gt;tstart)
-#define JimParserTend(c) ((c)-&gt;tend)
-#define JimParserTtype(c) ((c)-&gt;tt)
-#define JimParserTline(c) ((c)-&gt;tline)
-
-static int JimParseScript(struct JimParserCtx *pc);
-static int JimParseSep(struct JimParserCtx *pc);
-static int JimParseEol(struct JimParserCtx *pc);
-static int JimParseCmd(struct JimParserCtx *pc);
-static int JimParseVar(struct JimParserCtx *pc);
-static int JimParseBrace(struct JimParserCtx *pc);
-static int JimParseStr(struct JimParserCtx *pc);
-static int JimParseComment(struct JimParserCtx *pc);
-static char *JimParserGetToken(struct JimParserCtx *pc,
-        int *lenPtr, int *typePtr, int *linePtr);
-
-/* Initialize a parser context.
- * 'prg' is a pointer to the program text, linenr is the line
- * number of the first line contained in the program. */
-void JimParserInit(struct JimParserCtx *pc, const char *prg,
-        int len, int linenr)
-{
-    pc-&gt;prg = prg;
-    pc-&gt;p = prg;
-    pc-&gt;len = len;
-    pc-&gt;tstart = NULL;
-    pc-&gt;tend = NULL;
-    pc-&gt;tline = 0;
-    pc-&gt;tt = JIM_TT_NONE;
-    pc-&gt;eof = 0;
-    pc-&gt;state = JIM_PS_DEF;
-    pc-&gt;linenr = linenr;
-    pc-&gt;comment = 1;
-}
-
-int JimParseScript(struct JimParserCtx *pc)
-{
-    while (1) { /* the while is used to reiterate with continue if needed */
-        if (!pc-&gt;len) {
-            pc-&gt;tstart = pc-&gt;p;
-            pc-&gt;tend = pc-&gt;p-1;
-            pc-&gt;tline = pc-&gt;linenr;
-            pc-&gt;tt = JIM_TT_EOL;
-            pc-&gt;eof = 1;
-            return JIM_OK;
-        }
-        switch (*(pc-&gt;p)) {
-        case '\\':
-            if (*(pc-&gt;p + 1) == '\n')
-                return JimParseSep(pc);
-            else {
-                pc-&gt;comment = 0;
-                return JimParseStr(pc);
-            }
-            break;
-        case ' ':
-        case '\t':
-        case '\r':
-            if (pc-&gt;state == JIM_PS_DEF)
-                return JimParseSep(pc);
-            else {
-                pc-&gt;comment = 0;
-                return JimParseStr(pc);
-            }
-            break;
-        case '\n':
-        case ';':
-            pc-&gt;comment = 1;
-            if (pc-&gt;state == JIM_PS_DEF)
-                return JimParseEol(pc);
-            else
-                return JimParseStr(pc);
-            break;
-        case '[':
-            pc-&gt;comment = 0;
-            return JimParseCmd(pc);
-            break;
-        case '$':
-            pc-&gt;comment = 0;
-            if (JimParseVar(pc) == JIM_ERR) {
-                pc-&gt;tstart = pc-&gt;tend = pc-&gt;p++; pc-&gt;len--;
-                pc-&gt;tline = pc-&gt;linenr;
-                pc-&gt;tt = JIM_TT_STR;
-                return JIM_OK;
-            } else
-                return JIM_OK;
-            break;
-        case '#':
-            if (pc-&gt;comment) {
-                JimParseComment(pc);
-                continue;
-            } else {
-                return JimParseStr(pc);
-            }
-        default:
-            pc-&gt;comment = 0;
-            return JimParseStr(pc);
-            break;
-        }
-        return JIM_OK;
-    }
-}
-
-int JimParseSep(struct JimParserCtx *pc)
-{
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (*pc-&gt;p == ' ' || *pc-&gt;p == '\t' || *pc-&gt;p == '\r' ||
-           (*pc-&gt;p == '\\' &amp;&amp; *(pc-&gt;p + 1) == '\n')) {
-        if (*pc-&gt;p == '\\') {
-            pc-&gt;p++; pc-&gt;len--;
-            pc-&gt;linenr++;
-        }
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    pc-&gt;tend = pc-&gt;p-1;
-    pc-&gt;tt = JIM_TT_SEP;
-    return JIM_OK;
-}
-
-int JimParseEol(struct JimParserCtx *pc)
-{
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (*pc-&gt;p == ' ' || *pc-&gt;p == '\n' ||
-           *pc-&gt;p == '\t' || *pc-&gt;p == '\r' || *pc-&gt;p == ';') {
-        if (*pc-&gt;p == '\n')
-            pc-&gt;linenr++;
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    pc-&gt;tend = pc-&gt;p-1;
-    pc-&gt;tt = JIM_TT_EOL;
-    return JIM_OK;
-}
-
-/* Todo. Don't stop if ']' appears inside {} or quoted.
- * Also should handle the case of puts [string length &quot;]&quot;] */
-int JimParseCmd(struct JimParserCtx *pc)
-{
-    int level = 1;
-    int blevel = 0;
-
-    pc-&gt;tstart = ++pc-&gt;p; pc-&gt;len--;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (1) {
-        if (pc-&gt;len == 0) {
-            break;
-        } else if (*pc-&gt;p == '[' &amp;&amp; blevel == 0) {
-            level++;
-        } else if (*pc-&gt;p == ']' &amp;&amp; blevel == 0) {
-            level--;
-            if (!level) break;
-        } else if (*pc-&gt;p == '\\') {
-            pc-&gt;p++; pc-&gt;len--;
-        } else if (*pc-&gt;p == '{') {
-            blevel++;
-        } else if (*pc-&gt;p == '}') {
-            if (blevel != 0)
-                blevel--;
-        } else if (*pc-&gt;p == '\n')
-            pc-&gt;linenr++;
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    pc-&gt;tend = pc-&gt;p-1;
-    pc-&gt;tt = JIM_TT_CMD;
-    if (*pc-&gt;p == ']') {
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    return JIM_OK;
-}
-
-int JimParseVar(struct JimParserCtx *pc)
-{
-    int brace = 0, stop = 0, ttype = JIM_TT_VAR;
-
-    pc-&gt;tstart = ++pc-&gt;p; pc-&gt;len--; /* skip the $ */
-    pc-&gt;tline = pc-&gt;linenr;
-    if (*pc-&gt;p == '{') {
-        pc-&gt;tstart = ++pc-&gt;p; pc-&gt;len--;
-        brace = 1;
-    }
-    if (brace) {
-        while (!stop) {
-            if (*pc-&gt;p == '}' || pc-&gt;len == 0) {
-                pc-&gt;tend = pc-&gt;p-1;
-                stop = 1;
-                if (pc-&gt;len == 0)
-                    break;
-            }
-            else if (*pc-&gt;p == '\n')
-                pc-&gt;linenr++;
-            pc-&gt;p++; pc-&gt;len--;
-        }
-    } else {
-        /* Include leading colons */
-        while (*pc-&gt;p == ':') {
-            pc-&gt;p++;
-            pc-&gt;len--;
-        }
-        while (!stop) {
-            if (!((*pc-&gt;p &gt;= 'a' &amp;&amp; *pc-&gt;p &lt;= 'z') ||
-                (*pc-&gt;p &gt;= 'A' &amp;&amp; *pc-&gt;p &lt;= 'Z') ||
-                (*pc-&gt;p &gt;= '0' &amp;&amp; *pc-&gt;p &lt;= '9') || *pc-&gt;p == '_'))
-                stop = 1;
-            else {
-                pc-&gt;p++; pc-&gt;len--;
-            }
-        }
-        /* Parse [dict get] syntax sugar. */
-        if (*pc-&gt;p == '(') {
-            while (*pc-&gt;p != ')' &amp;&amp; pc-&gt;len) {
-                pc-&gt;p++; pc-&gt;len--;
-                if (*pc-&gt;p == '\\' &amp;&amp; pc-&gt;len &gt;= 2) {
-                    pc-&gt;p += 2; pc-&gt;len -= 2;
-                }
-            }
-            if (*pc-&gt;p != '\0') {
-                pc-&gt;p++; pc-&gt;len--;
-            }
-            ttype = JIM_TT_DICTSUGAR;
-        }
-        pc-&gt;tend = pc-&gt;p-1;
-    }
-    /* Check if we parsed just the '$' character.
-     * That's not a variable so an error is returned
-     * to tell the state machine to consider this '$' just
-     * a string. */
-    if (pc-&gt;tstart == pc-&gt;p) {
-        pc-&gt;p--; pc-&gt;len++;
-        return JIM_ERR;
-    }
-    pc-&gt;tt = ttype;
-    return JIM_OK;
-}
-
-int JimParseBrace(struct JimParserCtx *pc)
-{
-    int level = 1;
-
-    pc-&gt;tstart = ++pc-&gt;p; pc-&gt;len--;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (1) {
-        if (*pc-&gt;p == '\\' &amp;&amp; pc-&gt;len &gt;= 2) {
-            pc-&gt;p++; pc-&gt;len--;
-            if (*pc-&gt;p == '\n')
-                pc-&gt;linenr++;
-        } else if (*pc-&gt;p == '{') {
-            level++;
-        } else if (pc-&gt;len == 0 || *pc-&gt;p == '}') {
-            level--;
-            if (pc-&gt;len == 0 || level == 0) {
-                pc-&gt;tend = pc-&gt;p-1;
-                if (pc-&gt;len != 0) {
-                    pc-&gt;p++; pc-&gt;len--;
-                }
-                pc-&gt;tt = JIM_TT_STR;
-                return JIM_OK;
-            }
-        } else if (*pc-&gt;p == '\n') {
-            pc-&gt;linenr++;
-        }
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    return JIM_OK; /* unreached */
-}
-
-int JimParseStr(struct JimParserCtx *pc)
-{
-    int newword = (pc-&gt;tt == JIM_TT_SEP || pc-&gt;tt == JIM_TT_EOL ||
-            pc-&gt;tt == JIM_TT_NONE || pc-&gt;tt == JIM_TT_STR);
-    if (newword &amp;&amp; *pc-&gt;p == '{') {
-        return JimParseBrace(pc);
-    } else if (newword &amp;&amp; *pc-&gt;p == '&quot;') {
-        pc-&gt;state = JIM_PS_QUOTE;
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (1) {
-        if (pc-&gt;len == 0) {
-            pc-&gt;tend = pc-&gt;p-1;
-            pc-&gt;tt = JIM_TT_ESC;
-            return JIM_OK;
-        }
-        switch (*pc-&gt;p) {
-        case '\\':
-            if (pc-&gt;state == JIM_PS_DEF &amp;&amp;
-                *(pc-&gt;p + 1) == '\n') {
-                pc-&gt;tend = pc-&gt;p-1;
-                pc-&gt;tt = JIM_TT_ESC;
-                return JIM_OK;
-            }
-            if (pc-&gt;len &gt;= 2) {
-                pc-&gt;p++; pc-&gt;len--;
-            }
-            break;
-        case '$':
-        case '[':
-            pc-&gt;tend = pc-&gt;p-1;
-            pc-&gt;tt = JIM_TT_ESC;
-            return JIM_OK;
-        case ' ':
-        case '\t':
-        case '\n':
-        case '\r':
-        case ';':
-            if (pc-&gt;state == JIM_PS_DEF) {
-                pc-&gt;tend = pc-&gt;p-1;
-                pc-&gt;tt = JIM_TT_ESC;
-                return JIM_OK;
-            } else if (*pc-&gt;p == '\n') {
-                pc-&gt;linenr++;
-            }
-            break;
-        case '&quot;':
-            if (pc-&gt;state == JIM_PS_QUOTE) {
-                pc-&gt;tend = pc-&gt;p-1;
-                pc-&gt;tt = JIM_TT_ESC;
-                pc-&gt;p++; pc-&gt;len--;
-                pc-&gt;state = JIM_PS_DEF;
-                return JIM_OK;
-            }
-            break;
-        }
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    return JIM_OK; /* unreached */
-}
-
-int JimParseComment(struct JimParserCtx *pc)
-{
-    while (*pc-&gt;p) {
-        if (*pc-&gt;p == '\n') {
-            pc-&gt;linenr++;
-            if (*(pc-&gt;p-1) != '\\') {
-                pc-&gt;p++; pc-&gt;len--;
-                return JIM_OK;
-            }
-        }
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    return JIM_OK;
-}
-
-/* xdigitval and odigitval are helper functions for JimParserGetToken() */
-static int xdigitval(int c)
-{
-    if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c-'0';
-    if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') return c-'a'+10;
-    if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') return c-'A'+10;
-    return -1;
-}
-
-static int odigitval(int c)
-{
-    if (c &gt;= '0' &amp;&amp; c &lt;= '7') return c-'0';
-    return -1;
-}
-
-/* Perform Tcl escape substitution of 's', storing the result
- * string into 'dest'. The escaped string is guaranteed to
- * be the same length or shorted than the source string.
- * Slen is the length of the string at 's', if it's -1 the string
- * length will be calculated by the function.
- *
- * The function returns the length of the resulting string. */
-static int JimEscape(char *dest, const char *s, int slen)
-{
-    char *p = dest;
-    int i, len;
-
-    if (slen == -1)
-        slen = strlen(s);
-
-    for (i = 0; i &lt; slen; i++) {
-        switch (s[i]) {
-        case '\\':
-            switch (s[i + 1]) {
-            case 'a': *p++ = 0x7; i++; break;
-            case 'b': *p++ = 0x8; i++; break;
-            case 'f': *p++ = 0xc; i++; break;
-            case 'n': *p++ = 0xa; i++; break;
-            case 'r': *p++ = 0xd; i++; break;
-            case 't': *p++ = 0x9; i++; break;
-            case 'v': *p++ = 0xb; i++; break;
-            case '\0': *p++ = '\\'; i++; break;
-            case '\n': *p++ = ' '; i++; break;
-            default:
-                  if (s[i + 1] == 'x') {
-                    int val = 0;
-                    int c = xdigitval(s[i + 2]);
-                    if (c == -1) {
-                        *p++ = 'x';
-                        i++;
-                        break;
-                    }
-                    val = c;
-                    c = xdigitval(s[i + 3]);
-                    if (c == -1) {
-                        *p++ = val;
-                        i += 2;
-                        break;
-                    }
-                    val = (val*16) + c;
-                    *p++ = val;
-                    i += 3;
-                    break;
-                  } else if (s[i + 1] &gt;= '0' &amp;&amp; s[i + 1] &lt;= '7')
-                  {
-                    int val = 0;
-                    int c = odigitval(s[i + 1]);
-                    val = c;
-                    c = odigitval(s[i + 2]);
-                    if (c == -1) {
-                        *p++ = val;
-                        i ++;
-                        break;
-                    }
-                    val = (val*8) + c;
-                    c = odigitval(s[i + 3]);
-                    if (c == -1) {
-                        *p++ = val;
-                        i += 2;
-                        break;
-                    }
-                    val = (val*8) + c;
-                    *p++ = val;
-                    i += 3;
-                  } else {
-                    *p++ = s[i + 1];
-                    i++;
-                  }
-                  break;
-            }
-            break;
-        default:
-            *p++ = s[i];
-            break;
-        }
-    }
-    len = p-dest;
-    *p++ = '\0';
-    return len;
-}
-
-/* Returns a dynamically allocated copy of the current token in the
- * parser context. The function perform conversion of escapes if
- * the token is of type JIM_TT_ESC.
- *
- * Note that after the conversion, tokens that are grouped with
- * braces in the source code, are always recognizable from the
- * identical string obtained in a different way from the type.
- *
- * For exmple the string:
- *
- * {expand}$a
- *
- * will return as first token &quot;expand&quot;, of type JIM_TT_STR
- *
- * While the string:
- *
- * expand$a
- *
- * will return as first token &quot;expand&quot;, of type JIM_TT_ESC
- */
-char *JimParserGetToken(struct JimParserCtx *pc,
-        int *lenPtr, int *typePtr, int *linePtr)
-{
-    const char *start, *end;
-    char *token;
-    int len;
-
-    start = JimParserTstart(pc);
-    end = JimParserTend(pc);
-    if (start &gt; end) {
-        if (lenPtr) *lenPtr = 0;
-        if (typePtr) *typePtr = JimParserTtype(pc);
-        if (linePtr) *linePtr = JimParserTline(pc);
-        token = Jim_Alloc(1);
-        token[0] = '\0';
-        return token;
-    }
-    len = (end-start) + 1;
-    token = Jim_Alloc(len + 1);
-    if (JimParserTtype(pc) != JIM_TT_ESC) {
-        /* No escape conversion needed? Just copy it. */
-        memcpy(token, start, len);
-        token[len] = '\0';
-    } else {
-        /* Else convert the escape chars. */
-        len = JimEscape(token, start, len);
-    }
-    if (lenPtr) *lenPtr = len;
-    if (typePtr) *typePtr = JimParserTtype(pc);
-    if (linePtr) *linePtr = JimParserTline(pc);
-    return token;
-}
-
-/* The following functin is not really part of the parsing engine of Jim,
- * but it somewhat related. Given an string and its length, it tries
- * to guess if the script is complete or there are instead &quot; &quot; or { }
- * open and not completed. This is useful for interactive shells
- * implementation and for [info complete].
- *
- * If 'stateCharPtr' != NULL, the function stores ' ' on complete script,
- * '{' on scripts incomplete missing one or more '}' to be balanced.
- * '&quot;' on scripts incomplete missing a '&quot;' char.
- *
- * If the script is complete, 1 is returned, otherwise 0. */
-int Jim_ScriptIsComplete(const char *s, int len, char *stateCharPtr)
-{
-    int level = 0;
-    int state = ' ';
-
-    while (len) {
-        switch (*s) {
-            case '\\':
-                if (len &gt; 1)
-                    s++;
-                break;
-            case '&quot;':
-                if (state == ' ') {
-                    state = '&quot;';
-                } else if (state == '&quot;') {
-                    state = ' ';
-                }
-                break;
-            case '{':
-                if (state == '{') {
-                    level++;
-                } else if (state == ' ') {
-                    state = '{';
-                    level++;
-                }
-                break;
-            case '}':
-                if (state == '{') {
-                    level--;
-                    if (level == 0)
-                        state = ' ';
-                }
-                break;
-        }
-        s++;
-        len--;
-    }
-    if (stateCharPtr)
-        *stateCharPtr = state;
-    return state == ' ';
-}
-
-/* -----------------------------------------------------------------------------
- * Tcl Lists parsing
- * ---------------------------------------------------------------------------*/
-static int JimParseListSep(struct JimParserCtx *pc);
-static int JimParseListStr(struct JimParserCtx *pc);
-
-int JimParseList(struct JimParserCtx *pc)
-{
-    if (pc-&gt;len == 0) {
-        pc-&gt;tstart = pc-&gt;tend = pc-&gt;p;
-        pc-&gt;tline = pc-&gt;linenr;
-        pc-&gt;tt = JIM_TT_EOL;
-        pc-&gt;eof = 1;
-        return JIM_OK;
-    }
-    switch (*pc-&gt;p) {
-    case ' ':
-    case '\n':
-    case '\t':
-    case '\r':
-        if (pc-&gt;state == JIM_PS_DEF)
-            return JimParseListSep(pc);
-        else
-            return JimParseListStr(pc);
-        break;
-    default:
-        return JimParseListStr(pc);
-        break;
-    }
-    return JIM_OK;
-}
-
-int JimParseListSep(struct JimParserCtx *pc)
-{
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (*pc-&gt;p == ' ' || *pc-&gt;p == '\t' || *pc-&gt;p == '\r' || *pc-&gt;p == '\n')
-    {
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    pc-&gt;tend = pc-&gt;p-1;
-    pc-&gt;tt = JIM_TT_SEP;
-    return JIM_OK;
-}
-
-int JimParseListStr(struct JimParserCtx *pc)
-{
-    int newword = (pc-&gt;tt == JIM_TT_SEP || pc-&gt;tt == JIM_TT_EOL ||
-            pc-&gt;tt == JIM_TT_NONE);
-    if (newword &amp;&amp; *pc-&gt;p == '{') {
-        return JimParseBrace(pc);
-    } else if (newword &amp;&amp; *pc-&gt;p == '&quot;') {
-        pc-&gt;state = JIM_PS_QUOTE;
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (1) {
-        if (pc-&gt;len == 0) {
-            pc-&gt;tend = pc-&gt;p-1;
-            pc-&gt;tt = JIM_TT_ESC;
-            return JIM_OK;
-        }
-        switch (*pc-&gt;p) {
-        case '\\':
-            pc-&gt;p++; pc-&gt;len--;
-            break;
-        case ' ':
-        case '\t':
-        case '\n':
-        case '\r':
-            if (pc-&gt;state == JIM_PS_DEF) {
-                pc-&gt;tend = pc-&gt;p-1;
-                pc-&gt;tt = JIM_TT_ESC;
-                return JIM_OK;
-            } else if (*pc-&gt;p == '\n') {
-                pc-&gt;linenr++;
-            }
-            break;
-        case '&quot;':
-            if (pc-&gt;state == JIM_PS_QUOTE) {
-                pc-&gt;tend = pc-&gt;p-1;
-                pc-&gt;tt = JIM_TT_ESC;
-                pc-&gt;p++; pc-&gt;len--;
-                pc-&gt;state = JIM_PS_DEF;
-                return JIM_OK;
-            }
-            break;
-        }
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    return JIM_OK; /* unreached */
-}
-
-/* -----------------------------------------------------------------------------
- * Jim_Obj related functions
- * ---------------------------------------------------------------------------*/
-
-/* Return a new initialized object. */
-Jim_Obj *Jim_NewObj(Jim_Interp *interp)
-{
-    Jim_Obj *objPtr;
-
-    /* -- Check if there are objects in the free list -- */
-    if (interp-&gt;freeList != NULL) {
-        /* -- Unlink the object from the free list -- */
-        objPtr = interp-&gt;freeList;
-        interp-&gt;freeList = objPtr-&gt;nextObjPtr;
-    } else {
-        /* -- No ready to use objects: allocate a new one -- */
-        objPtr = Jim_Alloc(sizeof(*objPtr));
-    }
-
-    /* Object is returned with refCount of 0. Every
-     * kind of GC implemented should take care to don't try
-     * to scan objects with refCount == 0. */
-    objPtr-&gt;refCount = 0;
-    /* All the other fields are left not initialized to save time.
-     * The caller will probably want set they to the right
-     * value anyway. */
-
-    /* -- Put the object into the live list -- */
-    objPtr-&gt;prevObjPtr = NULL;
-    objPtr-&gt;nextObjPtr = interp-&gt;liveList;
-    if (interp-&gt;liveList)
-        interp-&gt;liveList-&gt;prevObjPtr = objPtr;
-    interp-&gt;liveList = objPtr;
-
-    return objPtr;
-}
-
-/* Free an object. Actually objects are never freed, but
- * just moved to the free objects list, where they will be
- * reused by Jim_NewObj(). */
-void Jim_FreeObj(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    /* Check if the object was already freed, panic. */
-    if (objPtr-&gt;refCount != 0)  {
-        Jim_Panic(interp,&quot;!!!Object %p freed with bad refcount %d&quot;, objPtr,
-                objPtr-&gt;refCount);
-    }
-    /* Free the internal representation */
-    Jim_FreeIntRep(interp, objPtr);
-    /* Free the string representation */
-    if (objPtr-&gt;bytes != NULL) {
-        if (objPtr-&gt;bytes != JimEmptyStringRep)
-            Jim_Free(objPtr-&gt;bytes);
-    }
-    /* Unlink the object from the live objects list */
-    if (objPtr-&gt;prevObjPtr)
-        objPtr-&gt;prevObjPtr-&gt;nextObjPtr = objPtr-&gt;nextObjPtr;
-    if (objPtr-&gt;nextObjPtr)
-        objPtr-&gt;nextObjPtr-&gt;prevObjPtr = objPtr-&gt;prevObjPtr;
-    if (interp-&gt;liveList == objPtr)
-        interp-&gt;liveList = objPtr-&gt;nextObjPtr;
-    /* Link the object into the free objects list */
-    objPtr-&gt;prevObjPtr = NULL;
-    objPtr-&gt;nextObjPtr = interp-&gt;freeList;
-    if (interp-&gt;freeList)
-        interp-&gt;freeList-&gt;prevObjPtr = objPtr;
-    interp-&gt;freeList = objPtr;
-    objPtr-&gt;refCount = -1;
-}
-
-/* Invalidate the string representation of an object. */
-void Jim_InvalidateStringRep(Jim_Obj *objPtr)
-{
-    if (objPtr-&gt;bytes != NULL) {
-        if (objPtr-&gt;bytes != JimEmptyStringRep)
-            Jim_Free(objPtr-&gt;bytes);
-    }
-    objPtr-&gt;bytes = NULL;
-}
-
-#define Jim_SetStringRep(o, b, l) \
-    do { (o)-&gt;bytes = b; (o)-&gt;length = l; } while (0)
-
-/* Set the initial string representation for an object.
- * Does not try to free an old one. */
-void Jim_InitStringRep(Jim_Obj *objPtr, const char *bytes, int length)
-{
-    if (length == 0) {
-        objPtr-&gt;bytes = JimEmptyStringRep;
-        objPtr-&gt;length = 0;
-    } else {
-        objPtr-&gt;bytes = Jim_Alloc(length + 1);
-        objPtr-&gt;length = length;
-        memcpy(objPtr-&gt;bytes, bytes, length);
-        objPtr-&gt;bytes[length] = '\0';
-    }
-}
-
-/* Duplicate an object. The returned object has refcount = 0. */
-Jim_Obj *Jim_DuplicateObj(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_Obj *dupPtr;
-
-    dupPtr = Jim_NewObj(interp);
-    if (objPtr-&gt;bytes == NULL) {
-        /* Object does not have a valid string representation. */
-        dupPtr-&gt;bytes = NULL;
-    } else {
-        Jim_InitStringRep(dupPtr, objPtr-&gt;bytes, objPtr-&gt;length);
-    }
-    if (objPtr-&gt;typePtr != NULL) {
-        if (objPtr-&gt;typePtr-&gt;dupIntRepProc == NULL) {
-            dupPtr-&gt;internalRep = objPtr-&gt;internalRep;
-        } else {
-            objPtr-&gt;typePtr-&gt;dupIntRepProc(interp, objPtr, dupPtr);
-        }
-        dupPtr-&gt;typePtr = objPtr-&gt;typePtr;
-    } else {
-        dupPtr-&gt;typePtr = NULL;
-    }
-    return dupPtr;
-}
-
-/* Return the string representation for objPtr. If the object
- * string representation is invalid, calls the method to create
- * a new one starting from the internal representation of the object. */
-const char *Jim_GetString(Jim_Obj *objPtr, int *lenPtr)
-{
-    if (objPtr-&gt;bytes == NULL) {
-        /* Invalid string repr. Generate it. */
-        if (objPtr-&gt;typePtr-&gt;updateStringProc == NULL) {
-            Jim_Panic(NULL,&quot;UpdataStringProc called against '%s' type.&quot;,
-                objPtr-&gt;typePtr-&gt;name);
-        }
-        objPtr-&gt;typePtr-&gt;updateStringProc(objPtr);
-    }
-    if (lenPtr)
-        *lenPtr = objPtr-&gt;length;
-    return objPtr-&gt;bytes;
-}
-
-/* Just returns the length of the object's string rep */
-int Jim_Length(Jim_Obj *objPtr)
-{
-    int len;
-
-    Jim_GetString(objPtr, &amp;len);
-    return len;
-}
-
-/* -----------------------------------------------------------------------------
- * String Object
- * ---------------------------------------------------------------------------*/
-static void DupStringInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static int SetStringFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType stringObjType = {
-    &quot;string&quot;,
-    NULL,
-    DupStringInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-void DupStringInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-
-    /* This is a bit subtle: the only caller of this function
-     * should be Jim_DuplicateObj(), that will copy the
-     * string representaion. After the copy, the duplicated
-     * object will not have more room in teh buffer than
-     * srcPtr-&gt;length bytes. So we just set it to length. */
-    dupPtr-&gt;internalRep.strValue.maxLength = srcPtr-&gt;length;
-}
-
-int SetStringFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    /* Get a fresh string representation. */
-    (void) Jim_GetString(objPtr, NULL);
-    /* Free any other internal representation. */
-    Jim_FreeIntRep(interp, objPtr);
-    /* Set it as string, i.e. just set the maxLength field. */
-    objPtr-&gt;typePtr = &stringObjType;
-    objPtr-&gt;internalRep.strValue.maxLength = objPtr-&gt;length;
-    return JIM_OK;
-}
-
-Jim_Obj *Jim_NewStringObj(Jim_Interp *interp, const char *s, int len)
-{
-    Jim_Obj *objPtr = Jim_NewObj(interp);
-
-    if (len == -1)
-        len = strlen(s);
-    /* Alloc/Set the string rep. */
-    if (len == 0) {
-        objPtr-&gt;bytes = JimEmptyStringRep;
-        objPtr-&gt;length = 0;
-    } else {
-        objPtr-&gt;bytes = Jim_Alloc(len + 1);
-        objPtr-&gt;length = len;
-        memcpy(objPtr-&gt;bytes, s, len);
-        objPtr-&gt;bytes[len] = '\0';
-    }
-
-    /* No typePtr field for the vanilla string object. */
-    objPtr-&gt;typePtr = NULL;
-    return objPtr;
-}
-
-/* This version does not try to duplicate the 's' pointer, but
- * use it directly. */
-Jim_Obj *Jim_NewStringObjNoAlloc(Jim_Interp *interp, char *s, int len)
-{
-    Jim_Obj *objPtr = Jim_NewObj(interp);
-
-    if (len == -1)
-        len = strlen(s);
-    Jim_SetStringRep(objPtr, s, len);
-    objPtr-&gt;typePtr = NULL;
-    return objPtr;
-}
-
-/* Low-level string append. Use it only against objects
- * of type &quot;string&quot;. */
-void StringAppendString(Jim_Obj *objPtr, const char *str, int len)
-{
-    int needlen;
-
-    if (len == -1)
-        len = strlen(str);
-    needlen = objPtr-&gt;length + len;
-    if (objPtr-&gt;internalRep.strValue.maxLength &lt; needlen ||
-        objPtr-&gt;internalRep.strValue.maxLength == 0) {
-        if (objPtr-&gt;bytes == JimEmptyStringRep) {
-            objPtr-&gt;bytes = Jim_Alloc((needlen*2) + 1);
-        } else {
-            objPtr-&gt;bytes = Jim_Realloc(objPtr-&gt;bytes, (needlen*2) + 1);
-        }
-        objPtr-&gt;internalRep.strValue.maxLength = needlen*2;
-    }
-    memcpy(objPtr-&gt;bytes + objPtr-&gt;length, str, len);
-    objPtr-&gt;bytes[objPtr-&gt;length + len] = '\0';
-    objPtr-&gt;length += len;
-}
-
-/* Low-level wrapper to append an object. */
-void StringAppendObj(Jim_Obj *objPtr, Jim_Obj *appendObjPtr)
-{
-    int len;
-    const char *str;
-
-    str = Jim_GetString(appendObjPtr, &amp;len);
-    StringAppendString(objPtr, str, len);
-}
-
-/* Higher level API to append strings to objects. */
-void Jim_AppendString(Jim_Interp *interp, Jim_Obj *objPtr, const char *str,
-        int len)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,&quot;Jim_AppendString called with shared object&quot;);
-    if (objPtr-&gt;typePtr != &amp;stringObjType)
-        SetStringFromAny(interp, objPtr);
-    StringAppendString(objPtr, str, len);
-}
-
-void Jim_AppendString_sprintf(Jim_Interp *interp, Jim_Obj *objPtr, const char *fmt, ...)
-{
-	char *buf;
-	va_list ap;
-
-	va_start(ap, fmt);
-	buf = jim_vasprintf(fmt, ap);
-	va_end(ap);
-
-	if (buf) {
-		Jim_AppendString(interp, objPtr, buf, -1);
-		jim_vasprintf_done(buf);
-	}
-}
-
-
-void Jim_AppendObj(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *appendObjPtr)
-{
-    int len;
-    const char *str;
-
-    str = Jim_GetString(appendObjPtr, &amp;len);
-    Jim_AppendString(interp, objPtr, str, len);
-}
-
-void Jim_AppendStrings(Jim_Interp *interp, Jim_Obj *objPtr, ...)
-{
-    va_list ap;
-
-    if (objPtr-&gt;typePtr != &amp;stringObjType)
-        SetStringFromAny(interp, objPtr);
-    va_start(ap, objPtr);
-    while (1) {
-        char *s = va_arg(ap, char*);
-
-        if (s == NULL) break;
-        Jim_AppendString(interp, objPtr, s, -1);
-    }
-    va_end(ap);
-}
-
-int Jim_StringEqObj(Jim_Obj *aObjPtr, Jim_Obj *bObjPtr, int nocase)
-{
-    const char *aStr, *bStr;
-    int aLen, bLen, i;
-
-    if (aObjPtr == bObjPtr) return 1;
-    aStr = Jim_GetString(aObjPtr, &amp;aLen);
-    bStr = Jim_GetString(bObjPtr, &amp;bLen);
-    if (aLen != bLen) return 0;
-    if (nocase == 0)
-        return memcmp(aStr, bStr, aLen) == 0;
-    for (i = 0; i &lt; aLen; i++) {
-        if (tolower((int)aStr[i]) != tolower((int)bStr[i]))
-            return 0;
-    }
-    return 1;
-}
-
-int Jim_StringMatchObj(Jim_Obj *patternObjPtr, Jim_Obj *objPtr,
-        int nocase)
-{
-    const char *pattern, *string;
-    int patternLen, stringLen;
-
-    pattern = Jim_GetString(patternObjPtr, &amp;patternLen);
-    string = Jim_GetString(objPtr, &amp;stringLen);
-    return JimStringMatch(pattern, patternLen, string, stringLen, nocase);
-}
-
-int Jim_StringCompareObj(Jim_Obj *firstObjPtr,
-        Jim_Obj *secondObjPtr, int nocase)
-{
-    const char *s1, *s2;
-    int l1, l2;
-
-    s1 = Jim_GetString(firstObjPtr, &amp;l1);
-    s2 = Jim_GetString(secondObjPtr, &amp;l2);
-    return JimStringCompare(s1, l1, s2, l2, nocase);
-}
-
-/* Convert a range, as returned by Jim_GetRange(), into
- * an absolute index into an object of the specified length.
- * This function may return negative values, or values
- * bigger or equal to the length of the list if the index
- * is out of range. */
-static int JimRelToAbsIndex(int len, int index_t)
-{
-    if (index_t &lt; 0)
-        return len + index_t;
-    return index_t;
-}
-
-/* Convert a pair of index as normalize by JimRelToAbsIndex(),
- * into a range stored in *firstPtr, *lastPtr, *rangeLenPtr, suitable
- * for implementation of commands like [string range] and [lrange].
- *
- * The resulting range is guaranteed to address valid elements of
- * the structure. */
-static void JimRelToAbsRange(int len, int first, int last,
-        int *firstPtr, int *lastPtr, int *rangeLenPtr)
-{
-    int rangeLen;
-
-    if (first &gt; last) {
-        rangeLen = 0;
-    } else {
-        rangeLen = last-first + 1;
-        if (rangeLen) {
-            if (first &lt; 0) {
-                rangeLen += first;
-                first = 0;
-            }
-            if (last &gt;= len) {
-                rangeLen -= (last-(len-1));
-                last = len-1;
-            }
-        }
-    }
-    if (rangeLen &lt; 0) rangeLen = 0;
-
-    *firstPtr = first;
-    *lastPtr = last;
-    *rangeLenPtr = rangeLen;
-}
-
-Jim_Obj *Jim_StringRangeObj(Jim_Interp *interp,
-        Jim_Obj *strObjPtr, Jim_Obj *firstObjPtr, Jim_Obj *lastObjPtr)
-{
-    int first, last;
-    const char *str;
-    int len, rangeLen;
-
-    if (Jim_GetIndex(interp, firstObjPtr, &amp;first) != JIM_OK ||
-        Jim_GetIndex(interp, lastObjPtr, &amp;last) != JIM_OK)
-        return NULL;
-    str = Jim_GetString(strObjPtr, &amp;len);
-    first = JimRelToAbsIndex(len, first);
-    last = JimRelToAbsIndex(len, last);
-    JimRelToAbsRange(len, first, last, &amp;first, &amp;last, &amp;rangeLen);
-    return Jim_NewStringObj(interp, str + first, rangeLen);
-}
-
-static Jim_Obj *JimStringToLower(Jim_Interp *interp, Jim_Obj *strObjPtr)
-{
-    char *buf;
-    int i;
-    if (strObjPtr-&gt;typePtr != &amp;stringObjType) {
-        SetStringFromAny(interp, strObjPtr);
-    }
-
-    buf = Jim_Alloc(strObjPtr-&gt;length + 1);
-
-    memcpy(buf, strObjPtr-&gt;bytes, strObjPtr-&gt;length + 1);
-    for (i = 0; i &lt; strObjPtr-&gt;length; i++)
-        buf[i] = tolower((unsigned)buf[i]);
-    return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr-&gt;length);
-}
-
-static Jim_Obj *JimStringToUpper(Jim_Interp *interp, Jim_Obj *strObjPtr)
-{
-    char *buf;
-    int i;
-    if (strObjPtr-&gt;typePtr != &amp;stringObjType) {
-        SetStringFromAny(interp, strObjPtr);
-    }
-
-    buf = Jim_Alloc(strObjPtr-&gt;length + 1);
-
-    memcpy(buf, strObjPtr-&gt;bytes, strObjPtr-&gt;length + 1);
-    for (i = 0; i &lt; strObjPtr-&gt;length; i++)
-        buf[i] = toupper((unsigned)buf[i]);
-    return Jim_NewStringObjNoAlloc(interp, buf, strObjPtr-&gt;length);
-}
-
-/* This is the core of the [format] command.
- * TODO: Lots of things work - via a hack
- *       However, no format item can be &gt;= JIM_MAX_FMT
- */
-#define JIM_MAX_FMT 2048
-static Jim_Obj *Jim_FormatString_Inner(Jim_Interp *interp, Jim_Obj *fmtObjPtr,
-        int objc, Jim_Obj *const *objv, char *sprintf_buf)
-{
-    const char *fmt, *_fmt;
-    int fmtLen;
-    Jim_Obj *resObjPtr;
-
-
-    fmt = Jim_GetString(fmtObjPtr, &amp;fmtLen);
-	_fmt = fmt;
-    resObjPtr = Jim_NewStringObj(interp, &quot;&quot;, 0);
-    while (fmtLen) {
-        const char *p = fmt;
-        char spec[2], c;
-        jim_wide wideValue;
-		double doubleValue;
-		/* we cheat and use Sprintf()! */
-		char fmt_str[100];
-		char *cp;
-		int width;
-		int ljust;
-		int zpad;
-		int spad;
-		int altfm;
-		int forceplus;
-		int prec;
-		int inprec;
-		int haveprec;
-		int accum;
-
-        while (*fmt != '%' &amp;&amp; fmtLen) {
-            fmt++; fmtLen--;
-        }
-        Jim_AppendString(interp, resObjPtr, p, fmt-p);
-        if (fmtLen == 0)
-            break;
-        fmt++; fmtLen--; /* skip '%' */
-		zpad = 0;
-		spad = 0;
-		width = -1;
-		ljust = 0;
-		altfm = 0;
-		forceplus = 0;
-		inprec = 0;
-		haveprec = 0;
-		prec = -1; /* not found yet */
-    next_fmt:
-		if (fmtLen &lt;= 0) {
-			break;
-		}
-		switch (*fmt) {
-			/* terminals */
-        case 'b': /* binary - not all printfs() do this */
-		case 's': /* string */
-		case 'i': /* integer */
-		case 'd': /* decimal */
-		case 'x': /* hex */
-		case 'X': /* CAP hex */
-		case 'c': /* char */
-		case 'o': /* octal */
-		case 'u': /* unsigned */
-		case 'f': /* float */
-			break;
-
-			/* non-terminals */
-		case '0': /* zero pad */
-			zpad = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case '+':
-			forceplus = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case ' ': /* sign space */
-			spad = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case '-':
-			ljust = 1;
-			fmt++;  fmtLen--;
-			goto next_fmt;
-			break;
-		case '#':
-			altfm = 1;
-			fmt++; fmtLen--;
- 			goto next_fmt;
-
-		case '.':
-			inprec = 1;
-			fmt++; fmtLen--;
- 			goto next_fmt;
-			break;
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		case '8':
-		case '9':
-			accum = 0;
-			while (isdigit((unsigned)*fmt) &amp;&amp; (fmtLen &gt; 0)) {
-				accum = (accum * 10) + (*fmt - '0');
-				fmt++;  fmtLen--;
-			}
-			if (inprec) {
-				haveprec = 1;
-				prec = accum;
-			} else {
-				width = accum;
-			}
-			goto next_fmt;
-		case '*':
-			/* suck up the next item as an integer */
-			fmt++;  fmtLen--;
-			objc--;
-			if (objc &lt;= 0) {
-				goto not_enough_args;
-			}
-			if (Jim_GetWide(interp,objv[0],&amp;wideValue)== JIM_ERR) {
-				Jim_FreeNewObj(interp, resObjPtr);
-				return NULL;
-			}
-			if (inprec) {
-				haveprec = 1;
-				prec = wideValue;
-				if (prec &lt; 0) {
-					/* man 3 printf says */
-					/* if prec is negative, it is zero */
-					prec = 0;
-				}
-			} else {
-			width = wideValue;
-			if (width &lt; 0) {
-				ljust = 1;
-				width = -width;
-			}
-			}
-			objv++;
-			goto next_fmt;
-			break;
-		}
-
-
-		if (*fmt != '%') {
-            if (objc == 0) {
-			not_enough_args:
-                Jim_FreeNewObj(interp, resObjPtr);
-                Jim_SetResultString(interp,
-									&quot;not enough arguments for all format specifiers&quot;, -1);
-                return NULL;
-            } else {
-                objc--;
-            }
-        }
-
-		/*
-		 * Create the formatter
-		 * cause we cheat and use sprintf()
-		 */
-		cp = fmt_str;
-		*cp++ = '%';
-		if (altfm) {
-			*cp++ = '#';
-		}
-		if (forceplus) {
-			*cp++ = '+';
-		} else if (spad) {
-			/* PLUS overrides */
-			*cp++ = ' ';
-		}
-		if (ljust) {
-			*cp++ = '-';
-		}
-		if (zpad) {
-			*cp++ = '0';
-		}
-		if (width &gt; 0) {
-			sprintf(cp, &quot;%d&quot;, width);
-			/* skip ahead */
-			cp = strchr(cp,0);
-		}
-		/* did we find a period? */
-		if (inprec) {
-			/* then add it */
-			*cp++ = '.';
-			/* did something occur after the period? */
-			if (haveprec) {
-				sprintf(cp, &quot;%d&quot;, prec);
-			}
-			cp = strchr(cp,0);
-		}
-		*cp = 0;
-
-		/* here we do the work */
-		/* actually - we make sprintf() do it for us */
-        switch (*fmt) {
-        case 's':
-			*cp++ = 's';
-			*cp   = 0;
-			/* BUG: we do not handled embeded NULLs */
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, Jim_GetString(objv[0], NULL));
-            break;
-        case 'c':
-			*cp++ = 'c';
-			*cp   = 0;
-            if (Jim_GetWide(interp, objv[0], &amp;wideValue) == JIM_ERR) {
-                Jim_FreeNewObj(interp, resObjPtr);
-                return NULL;
-            }
-            c = (char) wideValue;
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, c);
-            break;
-		case 'f':
-		case 'F':
-		case 'g':
-		case 'G':
-		case 'e':
-		case 'E':
-			*cp++ = *fmt;
-			*cp   = 0;
-			if (Jim_GetDouble(interp, objv[0], &amp;doubleValue) == JIM_ERR) {
-				Jim_FreeNewObj(interp, resObjPtr);
-				return NULL;
-			}
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, doubleValue);
-			break;
-        case 'b':
-        case 'd':
-        case 'o':
-		case 'i':
-		case 'u':
-		case 'x':
-		case 'X':
-			/* jim widevaluse are 64bit */
-			if (sizeof(jim_wide) == sizeof(long long)) {
-				*cp++ = 'l';
-				*cp++ = 'l';
-			} else {
-				*cp++ = 'l';
-			}
-			*cp++ = *fmt;
-			*cp   = 0;
-            if (Jim_GetWide(interp, objv[0], &amp;wideValue) == JIM_ERR) {
-                Jim_FreeNewObj(interp, resObjPtr);
-                return NULL;
-            }
-			snprintf(sprintf_buf, JIM_MAX_FMT, fmt_str, wideValue);
-            break;
-        case '%':
-			sprintf_buf[0] = '%';
-			sprintf_buf[1] = 0;
-			objv--; /* undo the objv++ below */
-            break;
-        default:
-            spec[0] = *fmt; spec[1] = '\0';
-            Jim_FreeNewObj(interp, resObjPtr);
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    &quot;bad field specifier \&quot;&quot;,  spec, &quot;\&quot;&quot;, NULL);
-            return NULL;
-        }
-		/* force terminate */
-#if 0
-		printf(&quot;FMT was: %s\n&quot;, fmt_str);
-		printf(&quot;RES was: |%s|\n&quot;, sprintf_buf);
-#endif
-
-		sprintf_buf[ JIM_MAX_FMT - 1] = 0;
-		Jim_AppendString(interp, resObjPtr, sprintf_buf, strlen(sprintf_buf));
-		/* next obj */
-		objv++;
-        fmt++;
-        fmtLen--;
-    }
-    return resObjPtr;
-}
-
-Jim_Obj *Jim_FormatString(Jim_Interp *interp, Jim_Obj *fmtObjPtr,
-        int objc, Jim_Obj *const *objv)
-{
-	char *sprintf_buf = malloc(JIM_MAX_FMT);
-	Jim_Obj *t = Jim_FormatString_Inner(interp, fmtObjPtr, objc, objv, sprintf_buf);
-	free(sprintf_buf);
-	return t;
-}
-
-/* -----------------------------------------------------------------------------
- * Compared String Object
- * ---------------------------------------------------------------------------*/
-
-/* This is strange object that allows to compare a C literal string
- * with a Jim object in very short time if the same comparison is done
- * multiple times. For example every time the [if] command is executed,
- * Jim has to check if a given argument is &quot;else&quot;. This comparions if
- * the code has no errors are true most of the times, so we can cache
- * inside the object the pointer of the string of the last matching
- * comparison. Because most C compilers perform literal sharing,
- * so that: char *x = &quot;foo&quot;, char *y = &quot;foo&quot;, will lead to x == y,
- * this works pretty well even if comparisons are at different places
- * inside the C code. */
-
-static Jim_ObjType comparedStringObjType = {
-    &quot;compared-string&quot;,
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* The only way this object is exposed to the API is via the following
- * function. Returns true if the string and the object string repr.
- * are the same, otherwise zero is returned.
- *
- * Note: this isn't binary safe, but it hardly needs to be.*/
-int Jim_CompareStringImmediate(Jim_Interp *interp, Jim_Obj *objPtr,
-        const char *str)
-{
-    if (objPtr-&gt;typePtr == &amp;comparedStringObjType &amp;&amp;
-        objPtr-&gt;internalRep.ptr == str)
-        return 1;
-    else {
-        const char *objStr = Jim_GetString(objPtr, NULL);
-        if (strcmp(str, objStr) != 0) return 0;
-        if (objPtr-&gt;typePtr != &amp;comparedStringObjType) {
-            Jim_FreeIntRep(interp, objPtr);
-            objPtr-&gt;typePtr = &comparedStringObjType;
-        }
-        objPtr-&gt;internalRep.ptr = (char*)str; /*ATTENTION: const cast */
-        return 1;
-    }
-}
-
-int qsortCompareStringPointers(const void *a, const void *b)
-{
-    char * const *sa = (char * const *)a;
-    char * const *sb = (char * const *)b;
-    return strcmp(*sa, *sb);
-}
-
-int Jim_GetEnum(Jim_Interp *interp, Jim_Obj *objPtr,
-        const char * const *tablePtr, int *indexPtr, const char *name, int flags)
-{
-    const char * const *entryPtr = NULL;
-    char **tablePtrSorted;
-    int i, count = 0;
-
-    *indexPtr = -1;
-    for (entryPtr = tablePtr, i = 0; *entryPtr != NULL; entryPtr++, i++) {
-        if (Jim_CompareStringImmediate(interp, objPtr, *entryPtr)) {
-            *indexPtr = i;
-            return JIM_OK;
-        }
-        count++; /* If nothing matches, this will reach the len of tablePtr */
-    }
-    if (flags &amp; JIM_ERRMSG) {
-        if (name == NULL)
-            name = &quot;option&quot;;
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;bad &quot;, name, &quot; \&quot;&quot;, Jim_GetString(objPtr, NULL), &quot;\&quot;: must be one of &quot;,
-            NULL);
-        tablePtrSorted = Jim_Alloc(sizeof(char*)*count);
-        memcpy(tablePtrSorted, tablePtr, sizeof(char*)*count);
-        qsort(tablePtrSorted, count, sizeof(char*), qsortCompareStringPointers);
-        for (i = 0; i &lt; count; i++) {
-            if (i + 1 == count &amp;&amp; count &gt; 1)
-                Jim_AppendString(interp, Jim_GetResult(interp), &quot;or &quot;, -1);
-            Jim_AppendString(interp, Jim_GetResult(interp),
-                    tablePtrSorted[i], -1);
-            if (i + 1 != count)
-                Jim_AppendString(interp, Jim_GetResult(interp), &quot;, &quot;, -1);
-        }
-        Jim_Free(tablePtrSorted);
-    }
-    return JIM_ERR;
-}
-
-int Jim_GetNvp(Jim_Interp *interp,
-			   Jim_Obj *objPtr,
-			   const Jim_Nvp *nvp_table,
-			   const Jim_Nvp ** result)
-{
-	Jim_Nvp *n;
-	int e;
-
-	e = Jim_Nvp_name2value_obj(interp, nvp_table, objPtr, &amp;n);
-	if (e == JIM_ERR) {
-		return e;
-	}
-
-	/* Success? found? */
-	if (n-&gt;name) {
-		/* remove const */
-		*result = (Jim_Nvp *)n;
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-/* -----------------------------------------------------------------------------
- * Source Object
- *
- * This object is just a string from the language point of view, but
- * in the internal representation it contains the filename and line number
- * where this given token was read. This information is used by
- * Jim_EvalObj() if the object passed happens to be of type &quot;source&quot;.
- *
- * This allows to propagate the information about line numbers and file
- * names and give error messages with absolute line numbers.
- *
- * Note that this object uses shared strings for filenames, and the
- * pointer to the filename together with the line number is taken into
- * the space for the &quot;inline&quot; internal represenation of the Jim_Object,
- * so there is almost memory zero-overhead.
- *
- * Also the object will be converted to something else if the given
- * token it represents in the source file is not something to be
- * evaluated (not a script), and will be specialized in some other way,
- * so the time overhead is alzo null.
- * ---------------------------------------------------------------------------*/
-
-static void FreeSourceInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupSourceInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-
-static Jim_ObjType sourceObjType = {
-    &quot;source&quot;,
-    FreeSourceInternalRep,
-    DupSourceInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-void FreeSourceInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_ReleaseSharedString(interp,
-            objPtr-&gt;internalRep.sourceValue.fileName);
-}
-
-void DupSourceInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    dupPtr-&gt;internalRep.sourceValue.fileName =
-        Jim_GetSharedString(interp,
-                srcPtr-&gt;internalRep.sourceValue.fileName);
-    dupPtr-&gt;internalRep.sourceValue.lineNumber =
-        dupPtr-&gt;internalRep.sourceValue.lineNumber;
-    dupPtr-&gt;typePtr = &sourceObjType;
-}
-
-static void JimSetSourceInfo(Jim_Interp *interp, Jim_Obj *objPtr,
-        const char *fileName, int lineNumber)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,&quot;JimSetSourceInfo called with shared object&quot;);
-    if (objPtr-&gt;typePtr != NULL)
-        Jim_Panic(interp,&quot;JimSetSourceInfo called with typePtr != NULL&quot;);
-    objPtr-&gt;internalRep.sourceValue.fileName =
-        Jim_GetSharedString(interp, fileName);
-    objPtr-&gt;internalRep.sourceValue.lineNumber = lineNumber;
-    objPtr-&gt;typePtr = &sourceObjType;
-}
-
-/* -----------------------------------------------------------------------------
- * Script Object
- * ---------------------------------------------------------------------------*/
-
-#define JIM_CMDSTRUCT_EXPAND -1
-
-static void FreeScriptInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupScriptInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static int SetScriptFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType scriptObjType = {
-    &quot;script&quot;,
-    FreeScriptInternalRep,
-    DupScriptInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* The ScriptToken structure represents every token into a scriptObj.
- * Every token contains an associated Jim_Obj that can be specialized
- * by commands operating on it. */
-typedef struct ScriptToken {
-    int type;
-    Jim_Obj *objPtr;
-    int linenr;
-} ScriptToken;
-
-/* This is the script object internal representation. An array of
- * ScriptToken structures, with an associated command structure array.
- * The command structure is a pre-computed representation of the
- * command length and arguments structure as a simple liner array
- * of integers.
- *
- * For example the script:
- *
- * puts hello
- * set $i $x$y [foo]BAR
- *
- * will produce a ScriptObj with the following Tokens:
- *
- * ESC puts
- * SEP
- * ESC hello
- * EOL
- * ESC set
- * EOL
- * VAR i
- * SEP
- * VAR x
- * VAR y
- * SEP
- * CMD foo
- * ESC BAR
- * EOL
- *
- * This is a description of the tokens, separators, and of lines.
- * The command structure instead represents the number of arguments
- * of every command, followed by the tokens of which every argument
- * is composed. So for the example script, the cmdstruct array will
- * contain:
- *
- * 2 1 1 4 1 1 2 2
- *
- * Because &quot;puts hello&quot; has two args (2), composed of single tokens (1 1)
- * While &quot;set $i $x$y [foo]BAR&quot; has four (4) args, the first two
- * composed of single tokens (1 1) and the last two of double tokens
- * (2 2).
- *
- * The precomputation of the command structure makes Jim_Eval() faster,
- * and simpler because there aren't dynamic lengths / allocations.
- *
- * -- {expand} handling --
- *
- * Expand is handled in a special way. When a command
- * contains at least an argument with the {expand} prefix,
- * the command structure presents a -1 before the integer
- * describing the number of arguments. This is used in order
- * to send the command exection to a different path in case
- * of {expand} and guarantee a fast path for the more common
- * case. Also, the integers describing the number of tokens
- * are expressed with negative sign, to allow for fast check
- * of what's an {expand}-prefixed argument and what not.
- *
- * For example the command:
- *
- * list {expand}{1 2}
- *
- * Will produce the following cmdstruct array:
- *
- * -1 2 1 -2
- *
- * -- the substFlags field of the structure --
- *
- * The scriptObj structure is used to represent both &quot;script&quot; objects
- * and &quot;subst&quot; objects. In the second case, the cmdStruct related
- * fields are not used at all, but there is an additional field used
- * that is 'substFlags': this represents the flags used to turn
- * the string into the intenral representation used to perform the
- * substitution. If this flags are not what the application requires
- * the scriptObj is created again. For example the script:
- *
- * subst -nocommands $string
- * subst -novariables $string
- *
- * Will recreate the internal representation of the $string object
- * two times.
- */
-typedef struct ScriptObj {
-    int len; /* Length as number of tokens. */
-    int commands; /* number of top-level commands in script. */
-    ScriptToken *token; /* Tokens array. */
-    int *cmdStruct; /* commands structure */
-    int csLen; /* length of the cmdStruct array. */
-    int substFlags; /* flags used for the compilation of &quot;subst&quot; objects */
-    int inUse; /* Used to share a ScriptObj. Currently
-              only used by Jim_EvalObj() as protection against
-              shimmering of the currently evaluated object. */
-    char *fileName;
-} ScriptObj;
-
-void FreeScriptInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int i;
-    struct ScriptObj *script = (void*) objPtr-&gt;internalRep.ptr;
-
-    if (!script)
-	    return;
-
-    script-&gt;inUse--;
-    if (script-&gt;inUse != 0) return;
-    for (i = 0; i &lt; script-&gt;len; i++) {
-        if (script-&gt;token[i].objPtr != NULL)
-            Jim_DecrRefCount(interp, script-&gt;token[i].objPtr);
-    }
-    Jim_Free(script-&gt;token);
-    Jim_Free(script-&gt;cmdStruct);
-    Jim_Free(script-&gt;fileName);
-    Jim_Free(script);
-}
-
-void DupScriptInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(srcPtr);
-
-    /* Just returns an simple string. */
-    dupPtr-&gt;typePtr = NULL;
-}
-
-/* Add a new token to the internal repr of a script object */
-static void ScriptObjAddToken(Jim_Interp *interp, struct ScriptObj *script,
-        char *strtoken, int len, int type, char *filename, int linenr)
-{
-    int prevtype;
-    struct ScriptToken *token;
-
-    prevtype = (script-&gt;len == 0) ? JIM_TT_EOL : \
-        script-&gt;token[script-&gt;len-1].type;
-    /* Skip tokens without meaning, like words separators
-     * following a word separator or an end of command and
-     * so on. */
-    if (prevtype == JIM_TT_EOL) {
-        if (type == JIM_TT_EOL || type == JIM_TT_SEP) {
-            Jim_Free(strtoken);
-            return;
-        }
-    } else if (prevtype == JIM_TT_SEP) {
-        if (type == JIM_TT_SEP) {
-            Jim_Free(strtoken);
-            return;
-        } else if (type == JIM_TT_EOL) {
-            /* If an EOL is following by a SEP, drop the previous
-             * separator. */
-            script-&gt;len--;
-            Jim_DecrRefCount(interp, script-&gt;token[script-&gt;len].objPtr);
-        }
-    } else if (prevtype != JIM_TT_EOL &amp;&amp; prevtype != JIM_TT_SEP &amp;&amp;
-            type == JIM_TT_ESC &amp;&amp; len == 0)
-    {
-        /* Don't add empty tokens used in interpolation */
-        Jim_Free(strtoken);
-        return;
-    }
-    /* Make space for a new istruction */
-    script-&gt;len++;
-    script-&gt;token = Jim_Realloc(script-&gt;token,
-            sizeof(ScriptToken)*script-&gt;len);
-    /* Initialize the new token */
-    token = script-&gt;token + (script-&gt;len-1);
-    token-&gt;type = type;
-    /* Every object is intially as a string, but the
-     * internal type may be specialized during execution of the
-     * script. */
-    token-&gt;objPtr = Jim_NewStringObjNoAlloc(interp, strtoken, len);
-    /* To add source info to SEP and EOL tokens is useless because
-     * they will never by called as arguments of Jim_EvalObj(). */
-    if (filename &amp;&amp; type != JIM_TT_SEP &amp;&amp; type != JIM_TT_EOL)
-        JimSetSourceInfo(interp, token-&gt;objPtr, filename, linenr);
-    Jim_IncrRefCount(token-&gt;objPtr);
-    token-&gt;linenr = linenr;
-}
-
-/* Add an integer into the command structure field of the script object. */
-static void ScriptObjAddInt(struct ScriptObj *script, int val)
-{
-    script-&gt;csLen++;
-    script-&gt;cmdStruct = Jim_Realloc(script-&gt;cmdStruct,
-                    sizeof(int)*script-&gt;csLen);
-    script-&gt;cmdStruct[script-&gt;csLen-1] = val;
-}
-
-/* Search a Jim_Obj contained in 'script' with the same stinrg repr.
- * of objPtr. Search nested script objects recursively. */
-static Jim_Obj *ScriptSearchLiteral(Jim_Interp *interp, ScriptObj *script,
-        ScriptObj *scriptBarrier, Jim_Obj *objPtr)
-{
-    int i;
-
-    for (i = 0; i &lt; script-&gt;len; i++) {
-        if (script-&gt;token[i].objPtr != objPtr &amp;&amp;
-            Jim_StringEqObj(script-&gt;token[i].objPtr, objPtr, 0)) {
-            return script-&gt;token[i].objPtr;
-        }
-        /* Enter recursively on scripts only if the object
-         * is not the same as the one we are searching for
-         * shared occurrences. */
-        if (script-&gt;token[i].objPtr-&gt;typePtr == &amp;scriptObjType &amp;&amp;
-            script-&gt;token[i].objPtr != objPtr) {
-            Jim_Obj *foundObjPtr;
-
-            ScriptObj *subScript =
-                script-&gt;token[i].objPtr-&gt;internalRep.ptr;
-            /* Don't recursively enter the script we are trying
-             * to make shared to avoid circular references. */
-            if (subScript == scriptBarrier) continue;
-            if (subScript != script) {
-                foundObjPtr =
-                    ScriptSearchLiteral(interp, subScript,
-                            scriptBarrier, objPtr);
-                if (foundObjPtr != NULL)
-                    return foundObjPtr;
-            }
-        }
-    }
-    return NULL;
-}
-
-/* Share literals of a script recursively sharing sub-scripts literals. */
-static void ScriptShareLiterals(Jim_Interp *interp, ScriptObj *script,
-        ScriptObj *topLevelScript)
-{
-    int i, j;
-
-    return;
-    /* Try to share with toplevel object. */
-    if (topLevelScript != NULL) {
-        for (i = 0; i &lt; script-&gt;len; i++) {
-            Jim_Obj *foundObjPtr;
-            char *str = script-&gt;token[i].objPtr-&gt;bytes;
-
-            if (script-&gt;token[i].objPtr-&gt;refCount != 1) continue;
-            if (script-&gt;token[i].objPtr-&gt;typePtr == &amp;scriptObjType) continue;
-            if (strchr(str, ' ') || strchr(str, '\n')) continue;
-            foundObjPtr = ScriptSearchLiteral(interp,
-                    topLevelScript,
-                    script, /* barrier */
-                    script-&gt;token[i].objPtr);
-            if (foundObjPtr != NULL) {
-                Jim_IncrRefCount(foundObjPtr);
-                Jim_DecrRefCount(interp,
-                        script-&gt;token[i].objPtr);
-                script-&gt;token[i].objPtr = foundObjPtr;
-            }
-        }
-    }
-    /* Try to share locally */
-    for (i = 0; i &lt; script-&gt;len; i++) {
-        char *str = script-&gt;token[i].objPtr-&gt;bytes;
-
-        if (script-&gt;token[i].objPtr-&gt;refCount != 1) continue;
-        if (strchr(str, ' ') || strchr(str, '\n')) continue;
-        for (j = 0; j &lt; script-&gt;len; j++) {
-            if (script-&gt;token[i].objPtr !=
-                    script-&gt;token[j].objPtr &amp;&amp;
-                Jim_StringEqObj(script-&gt;token[i].objPtr,
-                            script-&gt;token[j].objPtr, 0))
-            {
-                Jim_IncrRefCount(script-&gt;token[j].objPtr);
-                Jim_DecrRefCount(interp,
-                        script-&gt;token[i].objPtr);
-                script-&gt;token[i].objPtr =
-                    script-&gt;token[j].objPtr;
-            }
-        }
-    }
-}
-
-/* This method takes the string representation of an object
- * as a Tcl script, and generates the pre-parsed internal representation
- * of the script. */
-int SetScriptFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    int scriptTextLen;
-    const char *scriptText = Jim_GetString(objPtr, &amp;scriptTextLen);
-    struct JimParserCtx parser;
-    struct ScriptObj *script = Jim_Alloc(sizeof(*script));
-    ScriptToken *token;
-    int args, tokens, start, end, i;
-    int initialLineNumber;
-    int propagateSourceInfo = 0;
-
-    script-&gt;len = 0;
-    script-&gt;csLen = 0;
-    script-&gt;commands = 0;
-    script-&gt;token = NULL;
-    script-&gt;cmdStruct = NULL;
-    script-&gt;inUse = 1;
-    /* Try to get information about filename / line number */
-    if (objPtr-&gt;typePtr == &amp;sourceObjType) {
-        script-&gt;fileName =
-            Jim_StrDup(objPtr-&gt;internalRep.sourceValue.fileName);
-        initialLineNumber = objPtr-&gt;internalRep.sourceValue.lineNumber;
-        propagateSourceInfo = 1;
-    } else {
-        script-&gt;fileName = Jim_StrDup(&quot;&quot;);
-        initialLineNumber = 1;
-    }
-
-    JimParserInit(&amp;parser, scriptText, scriptTextLen, initialLineNumber);
-    while (!JimParserEof(&amp;parser)) {
-        char *token_t;
-        int len, type, linenr;
-
-        JimParseScript(&amp;parser);
-        token_t = JimParserGetToken(&amp;parser, &amp;len, &amp;type, &amp;linenr);
-        ScriptObjAddToken(interp, script, token_t, len, type,
-                propagateSourceInfo ? script-&gt;fileName : NULL,
-                linenr);
-    }
-    token = script-&gt;token;
-
-    /* Compute the command structure array
-     * (see the ScriptObj struct definition for more info) */
-    start = 0; /* Current command start token index */
-    end = -1; /* Current command end token index */
-    while (1) {
-        int expand = 0; /* expand flag. set to 1 on {expand} form. */
-        int interpolation = 0; /* set to 1 if there is at least one
-                      argument of the command obtained via
-                      interpolation of more tokens. */
-        /* Search for the end of command, while
-         * count the number of args. */
-        start = ++end;
-        if (start &gt;= script-&gt;len) break;
-        args = 1; /* Number of args in current command */
-        while (token[end].type != JIM_TT_EOL) {
-            if (end == 0 || token[end-1].type == JIM_TT_SEP ||
-                    token[end-1].type == JIM_TT_EOL)
-            {
-                if (token[end].type == JIM_TT_STR &amp;&amp;
-                    token[end + 1].type != JIM_TT_SEP &amp;&amp;
-                    token[end + 1].type != JIM_TT_EOL &amp;&amp;
-                    (!strcmp(token[end].objPtr-&gt;bytes, &quot;expand&quot;) ||
-                     !strcmp(token[end].objPtr-&gt;bytes, &quot;*&quot;)))
-                    expand++;
-            }
-            if (token[end].type == JIM_TT_SEP)
-                args++;
-            end++;
-        }
-        interpolation = !((end-start + 1) == args*2);
-        /* Add the 'number of arguments' info into cmdstruct.
-         * Negative value if there is list expansion involved. */
-        if (expand)
-            ScriptObjAddInt(script, -1);
-        ScriptObjAddInt(script, args);
-        /* Now add info about the number of tokens. */
-        tokens = 0; /* Number of tokens in current argument. */
-        expand = 0;
-        for (i = start; i &lt;= end; i++) {
-            if (token[i].type == JIM_TT_SEP ||
-                token[i].type == JIM_TT_EOL)
-            {
-                if (tokens == 1 &amp;&amp; expand)
-                    expand = 0;
-                ScriptObjAddInt(script,
-                        expand ? -tokens : tokens);
-
-                expand = 0;
-                tokens = 0;
-                continue;
-            } else if (tokens == 0 &amp;&amp; token[i].type == JIM_TT_STR &amp;&amp;
-                   (!strcmp(token[i].objPtr-&gt;bytes, &quot;expand&quot;) ||
-                    !strcmp(token[i].objPtr-&gt;bytes, &quot;*&quot;)))
-            {
-                expand++;
-            }
-            tokens++;
-        }
-    }
-    /* Perform literal sharing, but only for objects that appear
-     * to be scripts written as literals inside the source code,
-     * and not computed at runtime. Literal sharing is a costly
-     * operation that should be done only against objects that
-     * are likely to require compilation only the first time, and
-     * then are executed multiple times. */
-    if (propagateSourceInfo &amp;&amp; interp-&gt;framePtr-&gt;procBodyObjPtr) {
-        Jim_Obj *bodyObjPtr = interp-&gt;framePtr-&gt;procBodyObjPtr;
-        if (bodyObjPtr-&gt;typePtr == &amp;scriptObjType) {
-            ScriptObj *bodyScript =
-                bodyObjPtr-&gt;internalRep.ptr;
-            ScriptShareLiterals(interp, script, bodyScript);
-        }
-    } else if (propagateSourceInfo) {
-        ScriptShareLiterals(interp, script, NULL);
-    }
-    /* Free the old internal rep and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    Jim_SetIntRepPtr(objPtr, script);
-    objPtr-&gt;typePtr = &scriptObjType;
-    return JIM_OK;
-}
-
-ScriptObj *Jim_GetScript(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    if (objPtr-&gt;typePtr != &amp;scriptObjType) {
-        SetScriptFromAny(interp, objPtr);
-    }
-    return (ScriptObj*) Jim_GetIntRepPtr(objPtr);
-}
-
-/* -----------------------------------------------------------------------------
- * Commands
- * ---------------------------------------------------------------------------*/
-
-/* Commands HashTable Type.
- *
- * Keys are dynamic allocated strings, Values are Jim_Cmd structures. */
-static void Jim_CommandsHT_ValDestructor(void *interp, void *val)
-{
-    Jim_Cmd *cmdPtr = (void*) val;
-
-    if (cmdPtr-&gt;cmdProc == NULL) {
-        Jim_DecrRefCount(interp, cmdPtr-&gt;argListObjPtr);
-        Jim_DecrRefCount(interp, cmdPtr-&gt;bodyObjPtr);
-        if (cmdPtr-&gt;staticVars) {
-            Jim_FreeHashTable(cmdPtr-&gt;staticVars);
-            Jim_Free(cmdPtr-&gt;staticVars);
-        }
-    } else if (cmdPtr-&gt;delProc != NULL) {
-            /* If it was a C coded command, call the delProc if any */
-            cmdPtr-&gt;delProc(interp, cmdPtr-&gt;privData);
-    }
-    Jim_Free(val);
-}
-
-static Jim_HashTableType JimCommandsHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,        /* key dup */
-    NULL,                    /* val dup */
-    JimStringCopyHTKeyCompare,        /* key compare */
-    JimStringCopyHTKeyDestructor,        /* key destructor */
-    Jim_CommandsHT_ValDestructor        /* val destructor */
-};
-
-/* ------------------------- Commands related functions --------------------- */
-
-int Jim_CreateCommand(Jim_Interp *interp, const char *cmdName,
-        Jim_CmdProc cmdProc, void *privData, Jim_DelCmdProc delProc)
-{
-    Jim_HashEntry *he;
-    Jim_Cmd *cmdPtr;
-
-    he = Jim_FindHashEntry(&amp;interp-&gt;commands, cmdName);
-    if (he == NULL) { /* New command to create */
-        cmdPtr = Jim_Alloc(sizeof(*cmdPtr));
-        Jim_AddHashEntry(&amp;interp-&gt;commands, cmdName, cmdPtr);
-    } else {
-        Jim_InterpIncrProcEpoch(interp);
-        /* Free the arglist/body objects if it was a Tcl procedure */
-        cmdPtr = he-&gt;val;
-        if (cmdPtr-&gt;cmdProc == NULL) {
-            Jim_DecrRefCount(interp, cmdPtr-&gt;argListObjPtr);
-            Jim_DecrRefCount(interp, cmdPtr-&gt;bodyObjPtr);
-            if (cmdPtr-&gt;staticVars) {
-                Jim_FreeHashTable(cmdPtr-&gt;staticVars);
-                Jim_Free(cmdPtr-&gt;staticVars);
-            }
-            cmdPtr-&gt;staticVars = NULL;
-        } else if (cmdPtr-&gt;delProc != NULL) {
-            /* If it was a C coded command, call the delProc if any */
-            cmdPtr-&gt;delProc(interp, cmdPtr-&gt;privData);
-        }
-    }
-
-    /* Store the new details for this proc */
-    cmdPtr-&gt;delProc = delProc;
-    cmdPtr-&gt;cmdProc = cmdProc;
-    cmdPtr-&gt;privData = privData;
-
-    /* There is no need to increment the 'proc epoch' because
-     * creation of a new procedure can never affect existing
-     * cached commands. We don't do negative caching. */
-    return JIM_OK;
-}
-
-int Jim_CreateProcedure(Jim_Interp *interp, const char *cmdName,
-        Jim_Obj *argListObjPtr, Jim_Obj *staticsListObjPtr, Jim_Obj *bodyObjPtr,
-        int arityMin, int arityMax)
-{
-    Jim_Cmd *cmdPtr;
-
-    cmdPtr = Jim_Alloc(sizeof(*cmdPtr));
-    cmdPtr-&gt;cmdProc = NULL; /* Not a C coded command */
-    cmdPtr-&gt;argListObjPtr = argListObjPtr;
-    cmdPtr-&gt;bodyObjPtr = bodyObjPtr;
-    Jim_IncrRefCount(argListObjPtr);
-    Jim_IncrRefCount(bodyObjPtr);
-    cmdPtr-&gt;arityMin = arityMin;
-    cmdPtr-&gt;arityMax = arityMax;
-    cmdPtr-&gt;staticVars = NULL;
-
-    /* Create the statics hash table. */
-    if (staticsListObjPtr) {
-        int len, i;
-
-        Jim_ListLength(interp, staticsListObjPtr, &amp;len);
-        if (len != 0) {
-            cmdPtr-&gt;staticVars = Jim_Alloc(sizeof(Jim_HashTable));
-            Jim_InitHashTable(cmdPtr-&gt;staticVars, getJimVariablesHashTableType(),
-                    interp);
-            for (i = 0; i &lt; len; i++) {
-                Jim_Obj *objPtr=NULL, *initObjPtr=NULL, *nameObjPtr=NULL;
-                Jim_Var *varPtr;
-                int subLen;
-
-                Jim_ListIndex(interp, staticsListObjPtr, i, &amp;objPtr, JIM_NONE);
-                /* Check if it's composed of two elements. */
-                Jim_ListLength(interp, objPtr, &amp;subLen);
-                if (subLen == 1 || subLen == 2) {
-                    /* Try to get the variable value from the current
-                     * environment. */
-                    Jim_ListIndex(interp, objPtr, 0, &amp;nameObjPtr, JIM_NONE);
-                    if (subLen == 1) {
-                        initObjPtr = Jim_GetVariable(interp, nameObjPtr,
-                                JIM_NONE);
-                        if (initObjPtr == NULL) {
-                            Jim_SetResult(interp,
-                                    Jim_NewEmptyStringObj(interp));
-                            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                                &quot;variable for initialization of static \&quot;&quot;,
-                                Jim_GetString(nameObjPtr, NULL),
-                                &quot;\&quot; not found in the local context&quot;,
-                                NULL);
-                            goto err;
-                        }
-                    } else {
-                        Jim_ListIndex(interp, objPtr, 1, &amp;initObjPtr, JIM_NONE);
-                    }
-                    varPtr = Jim_Alloc(sizeof(*varPtr));
-                    varPtr-&gt;objPtr = initObjPtr;
-                    Jim_IncrRefCount(initObjPtr);
-                    varPtr-&gt;linkFramePtr = NULL;
-                    if (Jim_AddHashEntry(cmdPtr-&gt;staticVars,
-                            Jim_GetString(nameObjPtr, NULL),
-                            varPtr) != JIM_OK)
-                    {
-                        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-                        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                            &quot;static variable name \&quot;&quot;,
-                            Jim_GetString(objPtr, NULL), &quot;\&quot;&quot;,
-                            &quot; duplicated in statics list&quot;, NULL);
-                        Jim_DecrRefCount(interp, initObjPtr);
-                        Jim_Free(varPtr);
-                        goto err;
-                    }
-                } else {
-                    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-                    Jim_AppendStrings(interp, Jim_GetResult(interp),
-                        &quot;too many fields in static specifier \&quot;&quot;,
-                        objPtr, &quot;\&quot;&quot;, NULL);
-                    goto err;
-                }
-            }
-        }
-    }
-
-    /* Add the new command */
-
-    /* it may already exist, so we try to delete the old one */
-    if (Jim_DeleteHashEntry(&amp;interp-&gt;commands, cmdName) != JIM_ERR) {
-        /* There was an old procedure with the same name, this requires
-         * a 'proc epoch' update. */
-        Jim_InterpIncrProcEpoch(interp);
-    }
-    /* If a procedure with the same name didn't existed there is no need
-     * to increment the 'proc epoch' because creation of a new procedure
-     * can never affect existing cached commands. We don't do
-     * negative caching. */
-    Jim_AddHashEntry(&amp;interp-&gt;commands, cmdName, cmdPtr);
-    return JIM_OK;
-
-err:
-    Jim_FreeHashTable(cmdPtr-&gt;staticVars);
-    Jim_Free(cmdPtr-&gt;staticVars);
-    Jim_DecrRefCount(interp, argListObjPtr);
-    Jim_DecrRefCount(interp, bodyObjPtr);
-    Jim_Free(cmdPtr);
-    return JIM_ERR;
-}
-
-int Jim_DeleteCommand(Jim_Interp *interp, const char *cmdName)
-{
-    if (Jim_DeleteHashEntry(&amp;interp-&gt;commands, cmdName) == JIM_ERR)
-        return JIM_ERR;
-    Jim_InterpIncrProcEpoch(interp);
-    return JIM_OK;
-}
-
-int Jim_RenameCommand(Jim_Interp *interp, const char *oldName,
-        const char *newName)
-{
-    Jim_Cmd *cmdPtr;
-    Jim_HashEntry *he;
-    Jim_Cmd *copyCmdPtr;
-
-    if (newName[0] == '\0') /* Delete! */
-        return Jim_DeleteCommand(interp, oldName);
-    /* Rename */
-    he = Jim_FindHashEntry(&amp;interp-&gt;commands, oldName);
-    if (he == NULL)
-        return JIM_ERR; /* Invalid command name */
-    cmdPtr = he-&gt;val;
-    copyCmdPtr = Jim_Alloc(sizeof(Jim_Cmd));
-    *copyCmdPtr = *cmdPtr;
-    /* In order to avoid that a procedure will get arglist/body/statics
-     * freed by the hash table methods, fake a C-coded command
-     * setting cmdPtr-&gt;cmdProc as not NULL */
-    cmdPtr-&gt;cmdProc = (void*)1;
-    /* Also make sure delProc is NULL. */
-    cmdPtr-&gt;delProc = NULL;
-    /* Destroy the old command, and make sure the new is freed
-     * as well. */
-    Jim_DeleteHashEntry(&amp;interp-&gt;commands, oldName);
-    Jim_DeleteHashEntry(&amp;interp-&gt;commands, newName);
-    /* Now the new command. We are sure it can't fail because
-     * the target name was already freed. */
-    Jim_AddHashEntry(&amp;interp-&gt;commands, newName, copyCmdPtr);
-    /* Increment the epoch */
-    Jim_InterpIncrProcEpoch(interp);
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Command object
- * ---------------------------------------------------------------------------*/
-
-static int SetCommandFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType commandObjType = {
-    &quot;command&quot;,
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-int SetCommandFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_HashEntry *he;
-    const char *cmdName;
-
-    /* Get the string representation */
-    cmdName = Jim_GetString(objPtr, NULL);
-    /* Lookup this name into the commands hash table */
-    he = Jim_FindHashEntry(&amp;interp-&gt;commands, cmdName);
-    if (he == NULL)
-        return JIM_ERR;
-
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &commandObjType;
-    objPtr-&gt;internalRep.cmdValue.procEpoch = interp-&gt;procEpoch;
-    objPtr-&gt;internalRep.cmdValue.cmdPtr = (void*)he-&gt;val;
-    return JIM_OK;
-}
-
-/* This function returns the command structure for the command name
- * stored in objPtr. It tries to specialize the objPtr to contain
- * a cached info instead to perform the lookup into the hash table
- * every time. The information cached may not be uptodate, in such
- * a case the lookup is performed and the cache updated. */
-Jim_Cmd *Jim_GetCommand(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
-{
-    if ((objPtr-&gt;typePtr != &amp;commandObjType ||
-        objPtr-&gt;internalRep.cmdValue.procEpoch != interp-&gt;procEpoch) &amp;&amp;
-        SetCommandFromAny(interp, objPtr) == JIM_ERR) {
-        if (flags &amp; JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;invalid command name \&quot;&quot;, objPtr-&gt;bytes, &quot;\&quot;&quot;,
-                NULL);
-        }
-        return NULL;
-    }
-    return objPtr-&gt;internalRep.cmdValue.cmdPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * Variables
- * ---------------------------------------------------------------------------*/
-
-/* Variables HashTable Type.
- *
- * Keys are dynamic allocated strings, Values are Jim_Var structures. */
-static void JimVariablesHTValDestructor(void *interp, void *val)
-{
-    Jim_Var *varPtr = (void*) val;
-
-    Jim_DecrRefCount(interp, varPtr-&gt;objPtr);
-    Jim_Free(val);
-}
-
-static Jim_HashTableType JimVariablesHashTableType = {
-    JimStringCopyHTHashFunction,        /* hash function */
-    JimStringCopyHTKeyDup,              /* key dup */
-    NULL,                               /* val dup */
-    JimStringCopyHTKeyCompare,        /* key compare */
-    JimStringCopyHTKeyDestructor,     /* key destructor */
-    JimVariablesHTValDestructor       /* val destructor */
-};
-
-static Jim_HashTableType *getJimVariablesHashTableType(void)
-{
-	return &JimVariablesHashTableType;
-}
-
-/* -----------------------------------------------------------------------------
- * Variable object
- * ---------------------------------------------------------------------------*/
-
-#define JIM_DICT_SUGAR 100 /* Only returned by SetVariableFromAny() */
-
-static int SetVariableFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType variableObjType = {
-    &quot;variable&quot;,
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* Return true if the string &quot;str&quot; looks like syntax sugar for [dict]. I.e.
- * is in the form &quot;varname(key)&quot;. */
-static int Jim_NameIsDictSugar(const char *str, int len)
-{
-    if (len == -1)
-        len = strlen(str);
-    if (len &amp;&amp; str[len-1] == ')' &amp;&amp; strchr(str, '(') != NULL)
-        return 1;
-    return 0;
-}
-
-/* This method should be called only by the variable API.
- * It returns JIM_OK on success (variable already exists),
- * JIM_ERR if it does not exists, JIM_DICT_GLUE if it's not
- * a variable name, but syntax glue for [dict] i.e. the last
- * character is ')' */
-int SetVariableFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    Jim_HashEntry *he;
-    const char *varName;
-    int len;
-
-    /* Check if the object is already an uptodate variable */
-    if (objPtr-&gt;typePtr == &amp;variableObjType &amp;&amp;
-        objPtr-&gt;internalRep.varValue.callFrameId == interp-&gt;framePtr-&gt;id)
-        return JIM_OK; /* nothing to do */
-    /* Get the string representation */
-    varName = Jim_GetString(objPtr, &amp;len);
-    /* Make sure it's not syntax glue to get/set dict. */
-    if (Jim_NameIsDictSugar(varName, len))
-            return JIM_DICT_SUGAR;
-    if (varName[0] == ':' &amp;&amp; varName[1] == ':') {
-        he = Jim_FindHashEntry(&amp;interp-&gt;topFramePtr-&gt;vars, varName + 2);
-        if (he == NULL) {
-            return JIM_ERR;
-        }
-    }
-    else {
-        /* Lookup this name into the variables hash table */
-        he = Jim_FindHashEntry(&amp;interp-&gt;framePtr-&gt;vars, varName);
-        if (he == NULL) {
-            /* Try with static vars. */
-            if (interp-&gt;framePtr-&gt;staticVars == NULL)
-                return JIM_ERR;
-            if (!(he = Jim_FindHashEntry(interp-&gt;framePtr-&gt;staticVars, varName)))
-                return JIM_ERR;
-        }
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &variableObjType;
-    objPtr-&gt;internalRep.varValue.callFrameId = interp-&gt;framePtr-&gt;id;
-    objPtr-&gt;internalRep.varValue.varPtr = (void*)he-&gt;val;
-    return JIM_OK;
-}
-
-/* -------------------- Variables related functions ------------------------- */
-static int JimDictSugarSet(Jim_Interp *interp, Jim_Obj *ObjPtr,
-        Jim_Obj *valObjPtr);
-static Jim_Obj *JimDictSugarGet(Jim_Interp *interp, Jim_Obj *ObjPtr);
-
-/* For now that's dummy. Variables lookup should be optimized
- * in many ways, with caching of lookups, and possibly with
- * a table of pre-allocated vars in every CallFrame for local vars.
- * All the caching should also have an 'epoch' mechanism similar
- * to the one used by Tcl for procedures lookup caching. */
-
-int Jim_SetVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr, Jim_Obj *valObjPtr)
-{
-    const char *name;
-    Jim_Var *var;
-    int err;
-
-    if ((err = SetVariableFromAny(interp, nameObjPtr)) != JIM_OK) {
-        /* Check for [dict] syntax sugar. */
-        if (err == JIM_DICT_SUGAR)
-            return JimDictSugarSet(interp, nameObjPtr, valObjPtr);
-        /* New variable to create */
-        name = Jim_GetString(nameObjPtr, NULL);
-
-        var = Jim_Alloc(sizeof(*var));
-        var-&gt;objPtr = valObjPtr;
-        Jim_IncrRefCount(valObjPtr);
-        var-&gt;linkFramePtr = NULL;
-        /* Insert the new variable */
-        if (name[0] == ':' &amp;&amp; name[1] == ':') {
-            /* Into to the top evel frame */
-            Jim_AddHashEntry(&amp;interp-&gt;topFramePtr-&gt;vars, name + 2, var);
-        }
-        else {
-            Jim_AddHashEntry(&amp;interp-&gt;framePtr-&gt;vars, name, var);
-        }
-        /* Make the object int rep a variable */
-        Jim_FreeIntRep(interp, nameObjPtr);
-        nameObjPtr-&gt;typePtr = &variableObjType;
-        nameObjPtr-&gt;internalRep.varValue.callFrameId =
-            interp-&gt;framePtr-&gt;id;
-        nameObjPtr-&gt;internalRep.varValue.varPtr = var;
-    } else {
-        var = nameObjPtr-&gt;internalRep.varValue.varPtr;
-        if (var-&gt;linkFramePtr == NULL) {
-            Jim_IncrRefCount(valObjPtr);
-            Jim_DecrRefCount(interp, var-&gt;objPtr);
-            var-&gt;objPtr = valObjPtr;
-        } else { /* Else handle the link */
-            Jim_CallFrame *savedCallFrame;
-
-            savedCallFrame = interp-&gt;framePtr;
-            interp-&gt;framePtr = var-&gt;linkFramePtr;
-            err = Jim_SetVariable(interp, var-&gt;objPtr, valObjPtr);
-            interp-&gt;framePtr = savedCallFrame;
-            if (err != JIM_OK)
-                return err;
-        }
-    }
-    return JIM_OK;
-}
-
-int Jim_SetVariableStr(Jim_Interp *interp, const char *name, Jim_Obj *objPtr)
-{
-    Jim_Obj *nameObjPtr;
-    int result;
-
-    nameObjPtr = Jim_NewStringObj(interp, name, -1);
-    Jim_IncrRefCount(nameObjPtr);
-    result = Jim_SetVariable(interp, nameObjPtr, objPtr);
-    Jim_DecrRefCount(interp, nameObjPtr);
-    return result;
-}
-
-int Jim_SetGlobalVariableStr(Jim_Interp *interp, const char *name, Jim_Obj *objPtr)
-{
-    Jim_CallFrame *savedFramePtr;
-    int result;
-
-    savedFramePtr = interp-&gt;framePtr;
-    interp-&gt;framePtr = interp-&gt;topFramePtr;
-    result = Jim_SetVariableStr(interp, name, objPtr);
-    interp-&gt;framePtr = savedFramePtr;
-    return result;
-}
-
-int Jim_SetVariableStrWithStr(Jim_Interp *interp, const char *name, const char *val)
-{
-    Jim_Obj *nameObjPtr, *valObjPtr;
-    int result;
-
-    nameObjPtr = Jim_NewStringObj(interp, name, -1);
-    valObjPtr = Jim_NewStringObj(interp, val, -1);
-    Jim_IncrRefCount(nameObjPtr);
-    Jim_IncrRefCount(valObjPtr);
-    result = Jim_SetVariable(interp, nameObjPtr, valObjPtr);
-    Jim_DecrRefCount(interp, nameObjPtr);
-    Jim_DecrRefCount(interp, valObjPtr);
-    return result;
-}
-
-int Jim_SetVariableLink(Jim_Interp *interp, Jim_Obj *nameObjPtr,
-        Jim_Obj *targetNameObjPtr, Jim_CallFrame *targetCallFrame)
-{
-    const char *varName;
-    int len;
-
-    /* Check for cycles. */
-    if (interp-&gt;framePtr == targetCallFrame) {
-        Jim_Obj *objPtr = targetNameObjPtr;
-        Jim_Var *varPtr;
-        /* Cycles are only possible with 'uplevel 0' */
-        while (1) {
-            if (Jim_StringEqObj(objPtr, nameObjPtr, 0)) {
-                Jim_SetResultString(interp,
-                    &quot;can't upvar from variable to itself&quot;, -1);
-                return JIM_ERR;
-            }
-            if (SetVariableFromAny(interp, objPtr) != JIM_OK)
-                break;
-            varPtr = objPtr-&gt;internalRep.varValue.varPtr;
-            if (varPtr-&gt;linkFramePtr != targetCallFrame) break;
-            objPtr = varPtr-&gt;objPtr;
-        }
-    }
-    varName = Jim_GetString(nameObjPtr, &amp;len);
-    if (Jim_NameIsDictSugar(varName, len)) {
-        Jim_SetResultString(interp,
-            &quot;Dict key syntax invalid as link source&quot;, -1);
-        return JIM_ERR;
-    }
-    /* Perform the binding */
-    Jim_SetVariable(interp, nameObjPtr, targetNameObjPtr);
-    /* We are now sure 'nameObjPtr' type is variableObjType */
-    nameObjPtr-&gt;internalRep.varValue.varPtr-&gt;linkFramePtr = targetCallFrame;
-    return JIM_OK;
-}
-
-/* Return the Jim_Obj pointer associated with a variable name,
- * or NULL if the variable was not found in the current context.
- * The same optimization discussed in the comment to the
- * 'SetVariable' function should apply here. */
-Jim_Obj *Jim_GetVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr, int flags)
-{
-    int err;
-
-    /* All the rest is handled here */
-    if ((err = SetVariableFromAny(interp, nameObjPtr)) != JIM_OK) {
-        /* Check for [dict] syntax sugar. */
-        if (err == JIM_DICT_SUGAR)
-            return JimDictSugarGet(interp, nameObjPtr);
-        if (flags &amp; JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;can't read \&quot;&quot;, nameObjPtr-&gt;bytes,
-                &quot;\&quot;: no such variable&quot;, NULL);
-        }
-        return NULL;
-    } else {
-        Jim_Var *varPtr;
-        Jim_Obj *objPtr;
-        Jim_CallFrame *savedCallFrame;
-
-        varPtr = nameObjPtr-&gt;internalRep.varValue.varPtr;
-        if (varPtr-&gt;linkFramePtr == NULL)
-            return varPtr-&gt;objPtr;
-        /* The variable is a link? Resolve it. */
-        savedCallFrame = interp-&gt;framePtr;
-        interp-&gt;framePtr = varPtr-&gt;linkFramePtr;
-        objPtr = Jim_GetVariable(interp, varPtr-&gt;objPtr, JIM_NONE);
-        if (objPtr == NULL &amp;&amp; flags &amp; JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;can't read \&quot;&quot;, nameObjPtr-&gt;bytes,
-                &quot;\&quot;: no such variable&quot;, NULL);
-        }
-        interp-&gt;framePtr = savedCallFrame;
-        return objPtr;
-    }
-}
-
-Jim_Obj *Jim_GetGlobalVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr,
-        int flags)
-{
-    Jim_CallFrame *savedFramePtr;
-    Jim_Obj *objPtr;
-
-    savedFramePtr = interp-&gt;framePtr;
-    interp-&gt;framePtr = interp-&gt;topFramePtr;
-    objPtr = Jim_GetVariable(interp, nameObjPtr, flags);
-    interp-&gt;framePtr = savedFramePtr;
-
-    return objPtr;
-}
-
-Jim_Obj *Jim_GetVariableStr(Jim_Interp *interp, const char *name, int flags)
-{
-    Jim_Obj *nameObjPtr, *varObjPtr;
-
-    nameObjPtr = Jim_NewStringObj(interp, name, -1);
-    Jim_IncrRefCount(nameObjPtr);
-    varObjPtr = Jim_GetVariable(interp, nameObjPtr, flags);
-    Jim_DecrRefCount(interp, nameObjPtr);
-    return varObjPtr;
-}
-
-Jim_Obj *Jim_GetGlobalVariableStr(Jim_Interp *interp, const char *name,
-        int flags)
-{
-    Jim_CallFrame *savedFramePtr;
-    Jim_Obj *objPtr;
-
-    savedFramePtr = interp-&gt;framePtr;
-    interp-&gt;framePtr = interp-&gt;topFramePtr;
-    objPtr = Jim_GetVariableStr(interp, name, flags);
-    interp-&gt;framePtr = savedFramePtr;
-
-    return objPtr;
-}
-
-/* Unset a variable.
- * Note: On success unset invalidates all the variable objects created
- * in the current call frame incrementing. */
-int Jim_UnsetVariable(Jim_Interp *interp, Jim_Obj *nameObjPtr, int flags)
-{
-    const char *name;
-    Jim_Var *varPtr;
-    int err;
-
-    if ((err = SetVariableFromAny(interp, nameObjPtr)) != JIM_OK) {
-        /* Check for [dict] syntax sugar. */
-        if (err == JIM_DICT_SUGAR)
-            return JimDictSugarSet(interp, nameObjPtr, NULL);
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;can't unset \&quot;&quot;, nameObjPtr-&gt;bytes,
-            &quot;\&quot;: no such variable&quot;, NULL);
-        return JIM_ERR; /* var not found */
-    }
-    varPtr = nameObjPtr-&gt;internalRep.varValue.varPtr;
-    /* If it's a link call UnsetVariable recursively */
-    if (varPtr-&gt;linkFramePtr) {
-        int retval;
-
-        Jim_CallFrame *savedCallFrame;
-
-        savedCallFrame = interp-&gt;framePtr;
-        interp-&gt;framePtr = varPtr-&gt;linkFramePtr;
-        retval = Jim_UnsetVariable(interp, varPtr-&gt;objPtr, JIM_NONE);
-        interp-&gt;framePtr = savedCallFrame;
-        if (retval != JIM_OK &amp;&amp; flags &amp; JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;can't unset \&quot;&quot;, nameObjPtr-&gt;bytes,
-                &quot;\&quot;: no such variable&quot;, NULL);
-        }
-        return retval;
-    } else {
-        name = Jim_GetString(nameObjPtr, NULL);
-        if (Jim_DeleteHashEntry(&amp;interp-&gt;framePtr-&gt;vars, name)
-                != JIM_OK) return JIM_ERR;
-        /* Change the callframe id, invalidating var lookup caching */
-        JimChangeCallFrameId(interp, interp-&gt;framePtr);
-        return JIM_OK;
-    }
-}
-
-/* ----------  Dict syntax sugar (similar to array Tcl syntax) -------------- */
-
-/* Given a variable name for [dict] operation syntax sugar,
- * this function returns two objects, the first with the name
- * of the variable to set, and the second with the rispective key.
- * For example &quot;foo(bar)&quot; will return objects with string repr. of
- * &quot;foo&quot; and &quot;bar&quot;.
- *
- * The returned objects have refcount = 1. The function can't fail. */
-static void JimDictSugarParseVarKey(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj **varPtrPtr, Jim_Obj **keyPtrPtr)
-{
-    const char *str, *p;
-    char *t;
-    int len, keyLen, nameLen;
-    Jim_Obj *varObjPtr, *keyObjPtr;
-
-    str = Jim_GetString(objPtr, &amp;len);
-    p = strchr(str, '(');
-    p++;
-    keyLen = len-((p-str) + 1);
-    nameLen = (p-str)-1;
-    /* Create the objects with the variable name and key. */
-    t = Jim_Alloc(nameLen + 1);
-    memcpy(t, str, nameLen);
-    t[nameLen] = '\0';
-    varObjPtr = Jim_NewStringObjNoAlloc(interp, t, nameLen);
-
-    t = Jim_Alloc(keyLen + 1);
-    memcpy(t, p, keyLen);
-    t[keyLen] = '\0';
-    keyObjPtr = Jim_NewStringObjNoAlloc(interp, t, keyLen);
-
-    Jim_IncrRefCount(varObjPtr);
-    Jim_IncrRefCount(keyObjPtr);
-    *varPtrPtr = varObjPtr;
-    *keyPtrPtr = keyObjPtr;
-}
-
-/* Helper of Jim_SetVariable() to deal with dict-syntax variable names.
- * Also used by Jim_UnsetVariable() with valObjPtr = NULL. */
-static int JimDictSugarSet(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *valObjPtr)
-{
-    Jim_Obj *varObjPtr, *keyObjPtr;
-    int err = JIM_OK;
-
-    JimDictSugarParseVarKey(interp, objPtr, &amp;varObjPtr, &amp;keyObjPtr);
-    err = Jim_SetDictKeysVector(interp, varObjPtr, &amp;keyObjPtr, 1,
-            valObjPtr);
-    Jim_DecrRefCount(interp, varObjPtr);
-    Jim_DecrRefCount(interp, keyObjPtr);
-    return err;
-}
-
-/* Helper of Jim_GetVariable() to deal with dict-syntax variable names */
-static Jim_Obj *JimDictSugarGet(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_Obj *varObjPtr, *keyObjPtr, *dictObjPtr, *resObjPtr;
-
-    JimDictSugarParseVarKey(interp, objPtr, &amp;varObjPtr, &amp;keyObjPtr);
-    dictObjPtr = Jim_GetVariable(interp, varObjPtr, JIM_ERRMSG);
-    if (!dictObjPtr) {
-        resObjPtr = NULL;
-        goto err;
-    }
-    if (Jim_DictKey(interp, dictObjPtr, keyObjPtr, &amp;resObjPtr, JIM_ERRMSG)
-            != JIM_OK) {
-        resObjPtr = NULL;
-    }
-err:
-    Jim_DecrRefCount(interp, varObjPtr);
-    Jim_DecrRefCount(interp, keyObjPtr);
-    return resObjPtr;
-}
-
-/* --------- $var(INDEX) substitution, using a specialized object ----------- */
-
-static void FreeDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr,
-        Jim_Obj *dupPtr);
-
-static Jim_ObjType dictSubstObjType = {
-    &quot;dict-substitution&quot;,
-    FreeDictSubstInternalRep,
-    DupDictSubstInternalRep,
-    NULL,
-    JIM_TYPE_NONE,
-};
-
-void FreeDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_DecrRefCount(interp, objPtr-&gt;internalRep.dictSubstValue.varNameObjPtr);
-    Jim_DecrRefCount(interp, objPtr-&gt;internalRep.dictSubstValue.indexObjPtr);
-}
-
-void DupDictSubstInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr,
-        Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-
-    dupPtr-&gt;internalRep.dictSubstValue.varNameObjPtr =
-        srcPtr-&gt;internalRep.dictSubstValue.varNameObjPtr;
-    dupPtr-&gt;internalRep.dictSubstValue.indexObjPtr =
-        srcPtr-&gt;internalRep.dictSubstValue.indexObjPtr;
-    dupPtr-&gt;typePtr = &dictSubstObjType;
-}
-
-/* This function is used to expand [dict get] sugar in the form
- * of $var(INDEX). The function is mainly used by Jim_EvalObj()
- * to deal with tokens of type JIM_TT_DICTSUGAR. objPtr points to an
- * object that is *guaranteed* to be in the form VARNAME(INDEX).
- * The 'index' part is [subst]ituted, and is used to lookup a key inside
- * the [dict]ionary contained in variable VARNAME. */
-Jim_Obj *Jim_ExpandDictSugar(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    Jim_Obj *varObjPtr, *keyObjPtr, *dictObjPtr, *resObjPtr;
-    Jim_Obj *substKeyObjPtr = NULL;
-
-    if (objPtr-&gt;typePtr != &amp;dictSubstObjType) {
-        JimDictSugarParseVarKey(interp, objPtr, &amp;varObjPtr, &amp;keyObjPtr);
-        Jim_FreeIntRep(interp, objPtr);
-        objPtr-&gt;typePtr = &dictSubstObjType;
-        objPtr-&gt;internalRep.dictSubstValue.varNameObjPtr = varObjPtr;
-        objPtr-&gt;internalRep.dictSubstValue.indexObjPtr = keyObjPtr;
-    }
-    if (Jim_SubstObj(interp, objPtr-&gt;internalRep.dictSubstValue.indexObjPtr,
-                &amp;substKeyObjPtr, JIM_NONE)
-            != JIM_OK) {
-        substKeyObjPtr = NULL;
-        goto err;
-    }
-    Jim_IncrRefCount(substKeyObjPtr);
-    dictObjPtr = Jim_GetVariable(interp,
-            objPtr-&gt;internalRep.dictSubstValue.varNameObjPtr, JIM_ERRMSG);
-    if (!dictObjPtr) {
-        resObjPtr = NULL;
-        goto err;
-    }
-    if (Jim_DictKey(interp, dictObjPtr, substKeyObjPtr, &amp;resObjPtr, JIM_ERRMSG)
-            != JIM_OK) {
-        resObjPtr = NULL;
-        goto err;
-    }
-err:
-    if (substKeyObjPtr) Jim_DecrRefCount(interp, substKeyObjPtr);
-    return resObjPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * CallFrame
- * ---------------------------------------------------------------------------*/
-
-static Jim_CallFrame *JimCreateCallFrame(Jim_Interp *interp)
-{
-    Jim_CallFrame *cf;
-    if (interp-&gt;freeFramesList) {
-        cf = interp-&gt;freeFramesList;
-        interp-&gt;freeFramesList = cf-&gt;nextFramePtr;
-    } else {
-        cf = Jim_Alloc(sizeof(*cf));
-        cf-&gt;vars.table = NULL;
-    }
-
-    cf-&gt;id = interp-&gt;callFrameEpoch++;
-    cf-&gt;parentCallFrame = NULL;
-    cf-&gt;argv = NULL;
-    cf-&gt;argc = 0;
-    cf-&gt;procArgsObjPtr = NULL;
-    cf-&gt;procBodyObjPtr = NULL;
-    cf-&gt;nextFramePtr = NULL;
-    cf-&gt;staticVars = NULL;
-    if (cf-&gt;vars.table == NULL)
-        Jim_InitHashTable(&amp;cf-&gt;vars, &amp;JimVariablesHashTableType, interp);
-    return cf;
-}
-
-/* Used to invalidate every caching related to callframe stability. */
-static void JimChangeCallFrameId(Jim_Interp *interp, Jim_CallFrame *cf)
-{
-    cf-&gt;id = interp-&gt;callFrameEpoch++;
-}
-
-#define JIM_FCF_NONE 0 /* no flags */
-#define JIM_FCF_NOHT 1 /* don't free the hash table */
-static void JimFreeCallFrame(Jim_Interp *interp, Jim_CallFrame *cf,
-        int flags)
-{
-    if (cf-&gt;procArgsObjPtr) Jim_DecrRefCount(interp, cf-&gt;procArgsObjPtr);
-    if (cf-&gt;procBodyObjPtr) Jim_DecrRefCount(interp, cf-&gt;procBodyObjPtr);
-    if (!(flags &amp; JIM_FCF_NOHT))
-        Jim_FreeHashTable(&amp;cf-&gt;vars);
-    else {
-        int i;
-        Jim_HashEntry **table = cf-&gt;vars.table, *he;
-
-        for (i = 0; i &lt; JIM_HT_INITIAL_SIZE; i++) {
-            he = table[i];
-            while (he != NULL) {
-                Jim_HashEntry *nextEntry = he-&gt;next;
-                Jim_Var *varPtr = (void*) he-&gt;val;
-
-                Jim_DecrRefCount(interp, varPtr-&gt;objPtr);
-                Jim_Free(he-&gt;val);
-                Jim_Free((void*)he-&gt;key); /* ATTENTION: const cast */
-                Jim_Free(he);
-                table[i] = NULL;
-                he = nextEntry;
-            }
-        }
-        cf-&gt;vars.used = 0;
-    }
-    cf-&gt;nextFramePtr = interp-&gt;freeFramesList;
-    interp-&gt;freeFramesList = cf;
-}
-
-/* -----------------------------------------------------------------------------
- * References
- * ---------------------------------------------------------------------------*/
-
-/* References HashTable Type.
- *
- * Keys are jim_wide integers, dynamically allocated for now but in the
- * future it's worth to cache this 8 bytes objects. Values are poitners
- * to Jim_References. */
-static void JimReferencesHTValDestructor(void *interp, void *val)
-{
-    Jim_Reference *refPtr = (void*) val;
-
-    Jim_DecrRefCount(interp, refPtr-&gt;objPtr);
-    if (refPtr-&gt;finalizerCmdNamePtr != NULL) {
-        Jim_DecrRefCount(interp, refPtr-&gt;finalizerCmdNamePtr);
-    }
-    Jim_Free(val);
-}
-
-unsigned int JimReferencesHTHashFunction(const void *key)
-{
-    /* Only the least significant bits are used. */
-    const jim_wide *widePtr = key;
-    unsigned int intValue = (unsigned int) *widePtr;
-    return Jim_IntHashFunction(intValue);
-}
-
-unsigned int JimReferencesHTDoubleHashFunction(const void *key)
-{
-    /* Only the least significant bits are used. */
-    const jim_wide *widePtr = key;
-    unsigned int intValue = (unsigned int) *widePtr;
-    return intValue; /* identity function. */
-}
-
-const void *JimReferencesHTKeyDup(void *privdata, const void *key)
-{
-    void *copy = Jim_Alloc(sizeof(jim_wide));
-    JIM_NOTUSED(privdata);
-
-    memcpy(copy, key, sizeof(jim_wide));
-    return copy;
-}
-
-int JimReferencesHTKeyCompare(void *privdata, const void *key1,
-        const void *key2)
-{
-    JIM_NOTUSED(privdata);
-
-    return memcmp(key1, key2, sizeof(jim_wide)) == 0;
-}
-
-void JimReferencesHTKeyDestructor(void *privdata, const void *key)
-{
-    JIM_NOTUSED(privdata);
-
-    Jim_Free((void*)key);
-}
-
-static Jim_HashTableType JimReferencesHashTableType = {
-    JimReferencesHTHashFunction,    /* hash function */
-    JimReferencesHTKeyDup,          /* key dup */
-    NULL,                           /* val dup */
-    JimReferencesHTKeyCompare,      /* key compare */
-    JimReferencesHTKeyDestructor,   /* key destructor */
-    JimReferencesHTValDestructor    /* val destructor */
-};
-
-/* -----------------------------------------------------------------------------
- * Reference object type and References API
- * ---------------------------------------------------------------------------*/
-
-static void UpdateStringOfReference(struct Jim_Obj *objPtr);
-
-static Jim_ObjType referenceObjType = {
-    &quot;reference&quot;,
-    NULL,
-    NULL,
-    UpdateStringOfReference,
-    JIM_TYPE_REFERENCES,
-};
-
-void UpdateStringOfReference(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_REFERENCE_SPACE + 1];
-    Jim_Reference *refPtr;
-
-    refPtr = objPtr-&gt;internalRep.refValue.refPtr;
-    len = JimFormatReference(buf, refPtr, objPtr-&gt;internalRep.refValue.id);
-    objPtr-&gt;bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr-&gt;bytes, buf, len + 1);
-    objPtr-&gt;length = len;
-}
-
-/* returns true if 'c' is a valid reference tag character.
- * i.e. inside the range [_a-zA-Z0-9] */
-static int isrefchar(int c)
-{
-    if (c == '_' || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ||
-        (c &gt;= '0' &amp;&amp; c &lt;= '9')) return 1;
-    return 0;
-}
-
-int SetReferenceFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    jim_wide wideValue;
-    int i, len;
-    const char *str, *start, *end;
-    char refId[21];
-    Jim_Reference *refPtr;
-    Jim_HashEntry *he;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &amp;len);
-    /* Check if it looks like a reference */
-    if (len &lt; JIM_REFERENCE_SPACE) goto badformat;
-    /* Trim spaces */
-    start = str;
-    end = str + len-1;
-    while (*start == ' ') start++;
-    while (*end == ' ' &amp;&amp; end &gt; start) end--;
-    if (end-start + 1 != JIM_REFERENCE_SPACE) goto badformat;
-    /* &lt;reference.&lt;1234567&gt;.%020&gt; */
-    if (memcmp(start, &quot;&lt;reference.&lt;&quot;, 12) != 0) goto badformat;
-    if (start[12 + JIM_REFERENCE_TAGLEN] != '&gt;' || end[0] != '&gt;') goto badformat;
-    /* The tag can't contain chars other than a-zA-Z0-9 + '_'. */
-    for (i = 0; i &lt; JIM_REFERENCE_TAGLEN; i++) {
-        if (!isrefchar(start[12 + i])) goto badformat;
-    }
-    /* Extract info from the refernece. */
-    memcpy(refId, start + 14 + JIM_REFERENCE_TAGLEN, 20);
-    refId[20] = '\0';
-    /* Try to convert the ID into a jim_wide */
-    if (Jim_StringToWide(refId, &amp;wideValue, 10) != JIM_OK) goto badformat;
-    /* Check if the reference really exists! */
-    he = Jim_FindHashEntry(&amp;interp-&gt;references, &amp;wideValue);
-    if (he == NULL) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;Invalid reference ID \&quot;&quot;, str, &quot;\&quot;&quot;, NULL);
-        return JIM_ERR;
-    }
-    refPtr = he-&gt;val;
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &referenceObjType;
-    objPtr-&gt;internalRep.refValue.id = wideValue;
-    objPtr-&gt;internalRep.refValue.refPtr = refPtr;
-    return JIM_OK;
-
-badformat:
-    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-    Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;expected reference but got \&quot;&quot;, str, &quot;\&quot;&quot;, NULL);
-    return JIM_ERR;
-}
-
-/* Returns a new reference pointing to objPtr, having cmdNamePtr
- * as finalizer command (or NULL if there is no finalizer).
- * The returned reference object has refcount = 0. */
-Jim_Obj *Jim_NewReference(Jim_Interp *interp, Jim_Obj *objPtr, Jim_Obj *tagPtr,
-        Jim_Obj *cmdNamePtr)
-{
-    struct Jim_Reference *refPtr;
-    jim_wide wideValue = interp-&gt;referenceNextId;
-    Jim_Obj *refObjPtr;
-    const char *tag;
-    int tagLen, i;
-
-    /* Perform the Garbage Collection if needed. */
-    Jim_CollectIfNeeded(interp);
-
-    refPtr = Jim_Alloc(sizeof(*refPtr));
-    refPtr-&gt;objPtr = objPtr;
-    Jim_IncrRefCount(objPtr);
-    refPtr-&gt;finalizerCmdNamePtr = cmdNamePtr;
-    if (cmdNamePtr)
-        Jim_IncrRefCount(cmdNamePtr);
-    Jim_AddHashEntry(&amp;interp-&gt;references, &amp;wideValue, refPtr);
-    refObjPtr = Jim_NewObj(interp);
-    refObjPtr-&gt;typePtr = &referenceObjType;
-    refObjPtr-&gt;bytes = NULL;
-    refObjPtr-&gt;internalRep.refValue.id = interp-&gt;referenceNextId;
-    refObjPtr-&gt;internalRep.refValue.refPtr = refPtr;
-    interp-&gt;referenceNextId++;
-    /* Set the tag. Trimmered at JIM_REFERENCE_TAGLEN. Everything
-     * that does not pass the 'isrefchar' test is replaced with '_' */
-    tag = Jim_GetString(tagPtr, &amp;tagLen);
-    if (tagLen &gt; JIM_REFERENCE_TAGLEN)
-        tagLen = JIM_REFERENCE_TAGLEN;
-    for (i = 0; i &lt; JIM_REFERENCE_TAGLEN; i++) {
-        if (i &lt; tagLen)
-            refPtr-&gt;tag[i] = tag[i];
-        else
-            refPtr-&gt;tag[i] = '_';
-    }
-    refPtr-&gt;tag[JIM_REFERENCE_TAGLEN] = '\0';
-    return refObjPtr;
-}
-
-Jim_Reference *Jim_GetReference(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    if (objPtr-&gt;typePtr != &amp;referenceObjType &amp;&amp;
-        SetReferenceFromAny(interp, objPtr) == JIM_ERR)
-        return NULL;
-    return objPtr-&gt;internalRep.refValue.refPtr;
-}
-
-int Jim_SetFinalizer(Jim_Interp *interp, Jim_Obj *objPtr, Jim_Obj *cmdNamePtr)
-{
-    Jim_Reference *refPtr;
-
-    if ((refPtr = Jim_GetReference(interp, objPtr)) == NULL)
-        return JIM_ERR;
-    Jim_IncrRefCount(cmdNamePtr);
-    if (refPtr-&gt;finalizerCmdNamePtr)
-        Jim_DecrRefCount(interp, refPtr-&gt;finalizerCmdNamePtr);
-    refPtr-&gt;finalizerCmdNamePtr = cmdNamePtr;
-    return JIM_OK;
-}
-
-int Jim_GetFinalizer(Jim_Interp *interp, Jim_Obj *objPtr, Jim_Obj **cmdNamePtrPtr)
-{
-    Jim_Reference *refPtr;
-
-    if ((refPtr = Jim_GetReference(interp, objPtr)) == NULL)
-        return JIM_ERR;
-    *cmdNamePtrPtr = refPtr-&gt;finalizerCmdNamePtr;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * References Garbage Collection
- * ---------------------------------------------------------------------------*/
-
-/* This the hash table type for the &quot;MARK&quot; phase of the GC */
-static Jim_HashTableType JimRefMarkHashTableType = {
-    JimReferencesHTHashFunction,    /* hash function */
-    JimReferencesHTKeyDup,          /* key dup */
-    NULL,                           /* val dup */
-    JimReferencesHTKeyCompare,      /* key compare */
-    JimReferencesHTKeyDestructor,   /* key destructor */
-    NULL                            /* val destructor */
-};
-
-/* #define JIM_DEBUG_GC 1 */
-
-/* Performs the garbage collection. */
-int Jim_Collect(Jim_Interp *interp)
-{
-    Jim_HashTable marks;
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj *objPtr;
-    int collected = 0;
-
-    /* Avoid recursive calls */
-    if (interp-&gt;lastCollectId == -1) {
-        /* Jim_Collect() already running. Return just now. */
-        return 0;
-    }
-    interp-&gt;lastCollectId = -1;
-
-    /* Mark all the references found into the 'mark' hash table.
-     * The references are searched in every live object that
-     * is of a type that can contain references. */
-    Jim_InitHashTable(&amp;marks, &amp;JimRefMarkHashTableType, NULL);
-    objPtr = interp-&gt;liveList;
-    while (objPtr) {
-        if (objPtr-&gt;typePtr == NULL ||
-            objPtr-&gt;typePtr-&gt;flags &amp; JIM_TYPE_REFERENCES) {
-            const char *str, *p;
-            int len;
-
-            /* If the object is of type reference, to get the
-             * Id is simple... */
-            if (objPtr-&gt;typePtr == &amp;referenceObjType) {
-                Jim_AddHashEntry(&amp;marks,
-                    &amp;objPtr-&gt;internalRep.refValue.id, NULL);
-#ifdef JIM_DEBUG_GC
-                Jim_fprintf(interp,interp-&gt;cookie_stdout,
-                    &quot;MARK (reference): %d refcount: %d&quot; JIM_NL,
-                    (int) objPtr-&gt;internalRep.refValue.id,
-                    objPtr-&gt;refCount);
-#endif
-                objPtr = objPtr-&gt;nextObjPtr;
-                continue;
-            }
-            /* Get the string repr of the object we want
-             * to scan for references. */
-            p = str = Jim_GetString(objPtr, &amp;len);
-            /* Skip objects too little to contain references. */
-            if (len &lt; JIM_REFERENCE_SPACE) {
-                objPtr = objPtr-&gt;nextObjPtr;
-                continue;
-            }
-            /* Extract references from the object string repr. */
-            while (1) {
-                int i;
-                jim_wide id;
-                char buf[21];
-
-                if ((p = strstr(p, &quot;&lt;reference.&lt;&quot;)) == NULL)
-                    break;
-                /* Check if it's a valid reference. */
-                if (len-(p-str) &lt; JIM_REFERENCE_SPACE) break;
-                if (p[41] != '&gt;' || p[19] != '&gt;' || p[20] != '.') break;
-                for (i = 21; i &lt;= 40; i++)
-                    if (!isdigit((int)p[i]))
-                        break;
-                /* Get the ID */
-                memcpy(buf, p + 21, 20);
-                buf[20] = '\0';
-                Jim_StringToWide(buf, &amp;id, 10);
-
-                /* Ok, a reference for the given ID
-                 * was found. Mark it. */
-                Jim_AddHashEntry(&amp;marks, &amp;id, NULL);
-#ifdef JIM_DEBUG_GC
-                Jim_fprintf(interp,interp-&gt;cookie_stdout,&quot;MARK: %d&quot; JIM_NL, (int)id);
-#endif
-                p += JIM_REFERENCE_SPACE;
-            }
-        }
-        objPtr = objPtr-&gt;nextObjPtr;
-    }
-
-    /* Run the references hash table to destroy every reference that
-     * is not referenced outside (not present in the mark HT). */
-    htiter = Jim_GetHashTableIterator(&amp;interp-&gt;references);
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        const jim_wide *refId;
-        Jim_Reference *refPtr;
-
-        refId = he-&gt;key;
-        /* Check if in the mark phase we encountered
-         * this reference. */
-        if (Jim_FindHashEntry(&amp;marks, refId) == NULL) {
-#ifdef JIM_DEBUG_GC
-            Jim_fprintf(interp,interp-&gt;cookie_stdout,&quot;COLLECTING %d&quot; JIM_NL, (int)*refId);
-#endif
-            collected++;
-            /* Drop the reference, but call the
-             * finalizer first if registered. */
-            refPtr = he-&gt;val;
-            if (refPtr-&gt;finalizerCmdNamePtr) {
-                char *refstr = Jim_Alloc(JIM_REFERENCE_SPACE + 1);
-                Jim_Obj *objv[3], *oldResult;
-
-                JimFormatReference(refstr, refPtr, *refId);
-
-                objv[0] = refPtr-&gt;finalizerCmdNamePtr;
-                objv[1] = Jim_NewStringObjNoAlloc(interp,
-                        refstr, 32);
-                objv[2] = refPtr-&gt;objPtr;
-                Jim_IncrRefCount(objv[0]);
-                Jim_IncrRefCount(objv[1]);
-                Jim_IncrRefCount(objv[2]);
-
-                /* Drop the reference itself */
-                Jim_DeleteHashEntry(&amp;interp-&gt;references, refId);
-
-                /* Call the finalizer. Errors ignored. */
-                oldResult = interp-&gt;result;
-                Jim_IncrRefCount(oldResult);
-                Jim_EvalObjVector(interp, 3, objv);
-                Jim_SetResult(interp, oldResult);
-                Jim_DecrRefCount(interp, oldResult);
-
-                Jim_DecrRefCount(interp, objv[0]);
-                Jim_DecrRefCount(interp, objv[1]);
-                Jim_DecrRefCount(interp, objv[2]);
-            } else {
-                Jim_DeleteHashEntry(&amp;interp-&gt;references, refId);
-            }
-        }
-    }
-    Jim_FreeHashTableIterator(htiter);
-    Jim_FreeHashTable(&amp;marks);
-    interp-&gt;lastCollectId = interp-&gt;referenceNextId;
-    interp-&gt;lastCollectTime = time(NULL);
-    return collected;
-}
-
-#define JIM_COLLECT_ID_PERIOD 5000
-#define JIM_COLLECT_TIME_PERIOD 300
-
-void Jim_CollectIfNeeded(Jim_Interp *interp)
-{
-    jim_wide elapsedId;
-    int elapsedTime;
-
-    elapsedId = interp-&gt;referenceNextId - interp-&gt;lastCollectId;
-    elapsedTime = time(NULL) - interp-&gt;lastCollectTime;
-
-
-    if (elapsedId &gt; JIM_COLLECT_ID_PERIOD ||
-        elapsedTime &gt; JIM_COLLECT_TIME_PERIOD) {
-        Jim_Collect(interp);
-    }
-}
-
-/* -----------------------------------------------------------------------------
- * Interpreter related functions
- * ---------------------------------------------------------------------------*/
-
-Jim_Interp *Jim_CreateInterp(void)
-{
-    Jim_Interp *i = Jim_Alloc(sizeof(*i));
-    Jim_Obj *pathPtr;
-
-    i-&gt;errorLine = 0;
-    i-&gt;errorFileName = Jim_StrDup(&quot;&quot;);
-    i-&gt;numLevels = 0;
-    i-&gt;maxNestingDepth = JIM_MAX_NESTING_DEPTH;
-    i-&gt;returnCode = JIM_OK;
-    i-&gt;exitCode = 0;
-    i-&gt;procEpoch = 0;
-    i-&gt;callFrameEpoch = 0;
-    i-&gt;liveList = i-&gt;freeList = NULL;
-    i-&gt;scriptFileName = Jim_StrDup(&quot;&quot;);
-    i-&gt;referenceNextId = 0;
-    i-&gt;lastCollectId = 0;
-    i-&gt;lastCollectTime = time(NULL);
-    i-&gt;freeFramesList = NULL;
-    i-&gt;prngState = NULL;
-    i-&gt;evalRetcodeLevel = -1;
-    i-&gt;cookie_stdin = stdin;
-    i-&gt;cookie_stdout = stdout;
-    i-&gt;cookie_stderr = stderr;
-	i-&gt;cb_fwrite   = ((size_t (*)(const void *, size_t, size_t, void *))(fwrite));
-	i-&gt;cb_fread    = ((size_t (*)(void *, size_t, size_t, void *))(fread));
-	i-&gt;cb_vfprintf = ((int    (*)(void *, const char *fmt, va_list))(vfprintf));
-	i-&gt;cb_fflush   = ((int    (*)(void *))(fflush));
-	i-&gt;cb_fgets    = ((char * (*)(char *, int, void *))(fgets));
-
-    /* Note that we can create objects only after the
-     * interpreter liveList and freeList pointers are
-     * initialized to NULL. */
-    Jim_InitHashTable(&amp;i-&gt;commands, &amp;JimCommandsHashTableType, i);
-    Jim_InitHashTable(&amp;i-&gt;references, &amp;JimReferencesHashTableType, i);
-    Jim_InitHashTable(&amp;i-&gt;sharedStrings, &amp;JimSharedStringsHashTableType,
-            NULL);
-    Jim_InitHashTable(&amp;i-&gt;stub, &amp;JimStringCopyHashTableType, NULL);
-    Jim_InitHashTable(&amp;i-&gt;assocData, &amp;JimAssocDataHashTableType, i);
-    Jim_InitHashTable(&amp;i-&gt;packages, &amp;JimStringKeyValCopyHashTableType, NULL);
-    i-&gt;framePtr = i-&gt;topFramePtr = JimCreateCallFrame(i);
-    i-&gt;emptyObj = Jim_NewEmptyStringObj(i);
-    i-&gt;result = i-&gt;emptyObj;
-    i-&gt;stackTrace = Jim_NewListObj(i, NULL, 0);
-    i-&gt;unknown = Jim_NewStringObj(i, &quot;unknown&quot;, -1);
-    i-&gt;unknown_called = 0;
-    Jim_IncrRefCount(i-&gt;emptyObj);
-    Jim_IncrRefCount(i-&gt;result);
-    Jim_IncrRefCount(i-&gt;stackTrace);
-    Jim_IncrRefCount(i-&gt;unknown);
-
-    /* Initialize key variables every interpreter should contain */
-    pathPtr = Jim_NewStringObj(i, &quot;./&quot;, -1);
-    Jim_SetVariableStr(i, &quot;jim_libpath&quot;, pathPtr);
-    Jim_SetVariableStrWithStr(i, &quot;jim_interactive&quot;, &quot;0&quot;);
-
-    /* Export the core API to extensions */
-    JimRegisterCoreApi(i);
-    return i;
-}
-
-/* This is the only function Jim exports directly without
- * to use the STUB system. It is only used by embedders
- * in order to get an interpreter with the Jim API pointers
- * registered. */
-Jim_Interp *ExportedJimCreateInterp(void)
-{
-    return Jim_CreateInterp();
-}
-
-void Jim_FreeInterp(Jim_Interp *i)
-{
-    Jim_CallFrame *cf = i-&gt;framePtr, *prevcf, *nextcf;
-    Jim_Obj *objPtr, *nextObjPtr;
-
-    Jim_DecrRefCount(i, i-&gt;emptyObj);
-    Jim_DecrRefCount(i, i-&gt;result);
-    Jim_DecrRefCount(i, i-&gt;stackTrace);
-    Jim_DecrRefCount(i, i-&gt;unknown);
-    Jim_Free((void*)i-&gt;errorFileName);
-    Jim_Free((void*)i-&gt;scriptFileName);
-    Jim_FreeHashTable(&amp;i-&gt;commands);
-    Jim_FreeHashTable(&amp;i-&gt;references);
-    Jim_FreeHashTable(&amp;i-&gt;stub);
-    Jim_FreeHashTable(&amp;i-&gt;assocData);
-    Jim_FreeHashTable(&amp;i-&gt;packages);
-    Jim_Free(i-&gt;prngState);
-    /* Free the call frames list */
-    while (cf) {
-        prevcf = cf-&gt;parentCallFrame;
-        JimFreeCallFrame(i, cf, JIM_FCF_NONE);
-        cf = prevcf;
-    }
-    /* Check that the live object list is empty, otherwise
-     * there is a memory leak. */
-    if (i-&gt;liveList != NULL) {
-        objPtr = i-&gt;liveList;
-
-        Jim_fprintf(i, i-&gt;cookie_stdout,JIM_NL &quot;-------------------------------------&quot; JIM_NL);
-        Jim_fprintf(i, i-&gt;cookie_stdout,&quot;Objects still in the free list:&quot; JIM_NL);
-        while (objPtr) {
-            const char *type = objPtr-&gt;typePtr ?
-                objPtr-&gt;typePtr-&gt;name : &quot;&quot;;
-            Jim_fprintf(i, i-&gt;cookie_stdout,&quot;%p \&quot;%-10s\&quot;: '%.20s' (refCount: %d)&quot; JIM_NL,
-                    objPtr, type,
-                    objPtr-&gt;bytes ? objPtr-&gt;bytes
-                    : &quot;(null)&quot;, objPtr-&gt;refCount);
-            if (objPtr-&gt;typePtr == &amp;sourceObjType) {
-                Jim_fprintf(i, i-&gt;cookie_stdout, &quot;FILE %s LINE %d&quot; JIM_NL,
-                objPtr-&gt;internalRep.sourceValue.fileName,
-                objPtr-&gt;internalRep.sourceValue.lineNumber);
-            }
-            objPtr = objPtr-&gt;nextObjPtr;
-        }
-        Jim_fprintf(i, i-&gt;cookie_stdout, &quot;-------------------------------------&quot; JIM_NL JIM_NL);
-        Jim_Panic(i,&quot;Live list non empty freeing the interpreter! Leak?&quot;);
-    }
-    /* Free all the freed objects. */
-    objPtr = i-&gt;freeList;
-    while (objPtr) {
-        nextObjPtr = objPtr-&gt;nextObjPtr;
-        Jim_Free(objPtr);
-        objPtr = nextObjPtr;
-    }
-    /* Free cached CallFrame structures */
-    cf = i-&gt;freeFramesList;
-    while (cf) {
-        nextcf = cf-&gt;nextFramePtr;
-        if (cf-&gt;vars.table != NULL)
-            Jim_Free(cf-&gt;vars.table);
-        Jim_Free(cf);
-        cf = nextcf;
-    }
-    /* Free the sharedString hash table. Make sure to free it
-     * after every other Jim_Object was freed. */
-    Jim_FreeHashTable(&amp;i-&gt;sharedStrings);
-    /* Free the interpreter structure. */
-    Jim_Free(i);
-}
-
-/* Store the call frame relative to the level represented by
- * levelObjPtr into *framePtrPtr. If levelObjPtr == NULL, the
- * level is assumed to be '1'.
- *
- * If a newLevelptr int pointer is specified, the function stores
- * the absolute level integer value of the new target callframe into
- * *newLevelPtr. (this is used to adjust interp-&gt;numLevels
- * in the implementation of [uplevel], so that [info level] will
- * return a correct information).
- *
- * This function accepts the 'level' argument in the form
- * of the commands [uplevel] and [upvar].
- *
- * For a function accepting a relative integer as level suitable
- * for implementation of [info level ?level?] check the
- * GetCallFrameByInteger() function. */
-int Jim_GetCallFrameByLevel(Jim_Interp *interp, Jim_Obj *levelObjPtr,
-        Jim_CallFrame **framePtrPtr, int *newLevelPtr)
-{
-    long level;
-    const char *str;
-    Jim_CallFrame *framePtr;
-
-    if (newLevelPtr) *newLevelPtr = interp-&gt;numLevels;
-    if (levelObjPtr) {
-        str = Jim_GetString(levelObjPtr, NULL);
-        if (str[0] == '#') {
-            char *endptr;
-            /* speedup for the toplevel (level #0) */
-            if (str[1] == '0' &amp;&amp; str[2] == '\0') {
-                if (newLevelPtr) *newLevelPtr = 0;
-                *framePtrPtr = interp-&gt;topFramePtr;
-                return JIM_OK;
-            }
-
-            level = strtol(str + 1, &amp;endptr, 0);
-            if (str[1] == '\0' || endptr[0] != '\0' || level &lt; 0)
-                goto badlevel;
-            /* An 'absolute' level is converted into the
-             * 'number of levels to go back' format. */
-            level = interp-&gt;numLevels - level;
-            if (level &lt; 0) goto badlevel;
-        } else {
-            if (Jim_GetLong(interp, levelObjPtr, &amp;level) != JIM_OK || level &lt; 0)
-                goto badlevel;
-        }
-    } else {
-        str = &quot;1&quot;; /* Needed to format the error message. */
-        level = 1;
-    }
-    /* Lookup */
-    framePtr = interp-&gt;framePtr;
-    if (newLevelPtr) *newLevelPtr = (*newLevelPtr)-level;
-    while (level--) {
-        framePtr = framePtr-&gt;parentCallFrame;
-        if (framePtr == NULL) goto badlevel;
-    }
-    *framePtrPtr = framePtr;
-    return JIM_OK;
-badlevel:
-    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-    Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;bad level \&quot;&quot;, str, &quot;\&quot;&quot;, NULL);
-    return JIM_ERR;
-}
-
-/* Similar to Jim_GetCallFrameByLevel() but the level is specified
- * as a relative integer like in the [info level ?level?] command. */
-static int JimGetCallFrameByInteger(Jim_Interp *interp, Jim_Obj *levelObjPtr,
-        Jim_CallFrame **framePtrPtr)
-{
-    jim_wide level;
-    jim_wide relLevel; /* level relative to the current one. */
-    Jim_CallFrame *framePtr;
-
-    if (Jim_GetWide(interp, levelObjPtr, &amp;level) != JIM_OK)
-        goto badlevel;
-    if (level &gt; 0) {
-        /* An 'absolute' level is converted into the
-         * 'number of levels to go back' format. */
-        relLevel = interp-&gt;numLevels - level;
-    } else {
-        relLevel = -level;
-    }
-    /* Lookup */
-    framePtr = interp-&gt;framePtr;
-    while (relLevel--) {
-        framePtr = framePtr-&gt;parentCallFrame;
-        if (framePtr == NULL) goto badlevel;
-    }
-    *framePtrPtr = framePtr;
-    return JIM_OK;
-badlevel:
-    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-    Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;bad level \&quot;&quot;, Jim_GetString(levelObjPtr, NULL), &quot;\&quot;&quot;, NULL);
-    return JIM_ERR;
-}
-
-static void JimSetErrorFileName(Jim_Interp *interp, char *filename)
-{
-    Jim_Free((void*)interp-&gt;errorFileName);
-    interp-&gt;errorFileName = Jim_StrDup(filename);
-}
-
-static void JimSetErrorLineNumber(Jim_Interp *interp, int linenr)
-{
-    interp-&gt;errorLine = linenr;
-}
-
-static void JimResetStackTrace(Jim_Interp *interp)
-{
-    Jim_DecrRefCount(interp, interp-&gt;stackTrace);
-    interp-&gt;stackTrace = Jim_NewListObj(interp, NULL, 0);
-    Jim_IncrRefCount(interp-&gt;stackTrace);
-}
-
-static void JimAppendStackTrace(Jim_Interp *interp, const char *procname,
-        const char *filename, int linenr)
-{
-    /* No need to add this dummy entry to the stack trace */
-    if (strcmp(procname, &quot;unknown&quot;) == 0) {
-        return;
-    }
-
-    if (Jim_IsShared(interp-&gt;stackTrace)) {
-        interp-&gt;stackTrace =
-            Jim_DuplicateObj(interp, interp-&gt;stackTrace);
-        Jim_IncrRefCount(interp-&gt;stackTrace);
-    }
-    Jim_ListAppendElement(interp, interp-&gt;stackTrace,
-            Jim_NewStringObj(interp, procname, -1));
-    Jim_ListAppendElement(interp, interp-&gt;stackTrace,
-            Jim_NewStringObj(interp, filename, -1));
-    Jim_ListAppendElement(interp, interp-&gt;stackTrace,
-            Jim_NewIntObj(interp, linenr));
-}
-
-int Jim_SetAssocData(Jim_Interp *interp, const char *key, Jim_InterpDeleteProc *delProc, void *data)
-{
-    AssocDataValue *assocEntryPtr = (AssocDataValue *)Jim_Alloc(sizeof(AssocDataValue));
-    assocEntryPtr-&gt;delProc = delProc;
-    assocEntryPtr-&gt;data = data;
-    return Jim_AddHashEntry(&amp;interp-&gt;assocData, key, assocEntryPtr);
-}
-
-void *Jim_GetAssocData(Jim_Interp *interp, const char *key)
-{
-    Jim_HashEntry *entryPtr = Jim_FindHashEntry(&amp;interp-&gt;assocData, key);
-    if (entryPtr != NULL) {
-        AssocDataValue *assocEntryPtr = (AssocDataValue *)entryPtr-&gt;val;
-        return assocEntryPtr-&gt;data;
-    }
-    return NULL;
-}
-
-int Jim_DeleteAssocData(Jim_Interp *interp, const char *key)
-{
-    return Jim_DeleteHashEntry(&amp;interp-&gt;assocData, key);
-}
-
-int Jim_GetExitCode(Jim_Interp *interp) {
-    return interp-&gt;exitCode;
-}
-
-void *Jim_SetStdin(Jim_Interp *interp, void *fp)
-{
-    if (fp != NULL) interp-&gt;cookie_stdin = fp;
-    return interp-&gt;cookie_stdin;
-}
-
-void *Jim_SetStdout(Jim_Interp *interp, void *fp)
-{
-    if (fp != NULL) interp-&gt;cookie_stdout = fp;
-    return interp-&gt;cookie_stdout;
-}
-
-void *Jim_SetStderr(Jim_Interp *interp, void  *fp)
-{
-    if (fp != NULL) interp-&gt;cookie_stderr = fp;
-    return interp-&gt;cookie_stderr;
-}
-
-/* -----------------------------------------------------------------------------
- * Shared strings.
- * Every interpreter has an hash table where to put shared dynamically
- * allocate strings that are likely to be used a lot of times.
- * For example, in the 'source' object type, there is a pointer to
- * the filename associated with that object. Every script has a lot
- * of this objects with the identical file name, so it is wise to share
- * this info.
- *
- * The API is trivial: Jim_GetSharedString(interp, &quot;foobar&quot;)
- * returns the pointer to the shared string. Every time a reference
- * to the string is no longer used, the user should call
- * Jim_ReleaseSharedString(interp, stringPointer). Once no one is using
- * a given string, it is removed from the hash table.
- * ---------------------------------------------------------------------------*/
-const char *Jim_GetSharedString(Jim_Interp *interp, const char *str)
-{
-    Jim_HashEntry *he = Jim_FindHashEntry(&amp;interp-&gt;sharedStrings, str);
-
-    if (he == NULL) {
-        char *strCopy = Jim_StrDup(str);
-
-        Jim_AddHashEntry(&amp;interp-&gt;sharedStrings, strCopy, (void*)1);
-        return strCopy;
-    } else {
-        intptr_t refCount = (intptr_t) he-&gt;val;
-
-        refCount++;
-        he-&gt;val = (void*) refCount;
-        return he-&gt;key;
-    }
-}
-
-void Jim_ReleaseSharedString(Jim_Interp *interp, const char *str)
-{
-    intptr_t refCount;
-    Jim_HashEntry *he = Jim_FindHashEntry(&amp;interp-&gt;sharedStrings, str);
-
-    if (he == NULL)
-        Jim_Panic(interp,&quot;Jim_ReleaseSharedString called with &quot;
-              &quot;unknown shared string '%s'&quot;, str);
-    refCount = (intptr_t) he-&gt;val;
-    refCount--;
-    if (refCount == 0) {
-        Jim_DeleteHashEntry(&amp;interp-&gt;sharedStrings, str);
-    } else {
-        he-&gt;val = (void*) refCount;
-    }
-}
-
-/* -----------------------------------------------------------------------------
- * Integer object
- * ---------------------------------------------------------------------------*/
-#define JIM_INTEGER_SPACE 24
-
-static void UpdateStringOfInt(struct Jim_Obj *objPtr);
-static int SetIntFromAny(Jim_Interp *interp, Jim_Obj *objPtr, int flags);
-
-static Jim_ObjType intObjType = {
-    &quot;int&quot;,
-    NULL,
-    NULL,
-    UpdateStringOfInt,
-    JIM_TYPE_NONE,
-};
-
-void UpdateStringOfInt(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_INTEGER_SPACE + 1];
-
-    len = Jim_WideToString(buf, objPtr-&gt;internalRep.wideValue);
-    objPtr-&gt;bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr-&gt;bytes, buf, len + 1);
-    objPtr-&gt;length = len;
-}
-
-int SetIntFromAny(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
-{
-    jim_wide wideValue;
-    const char *str;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, NULL);
-    /* Try to convert into a jim_wide */
-    if (Jim_StringToWide(str, &amp;wideValue, 0) != JIM_OK) {
-        if (flags &amp; JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    &quot;expected integer but got \&quot;&quot;, str, &quot;\&quot;&quot;, NULL);
-        }
-        return JIM_ERR;
-    }
-    if ((wideValue == JIM_WIDE_MIN || wideValue == JIM_WIDE_MAX) &amp;&amp;
-        errno == ERANGE) {
-        Jim_SetResultString(interp,
-            &quot;Integer value too big to be represented&quot;, -1);
-        return JIM_ERR;
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &intObjType;
-    objPtr-&gt;internalRep.wideValue = wideValue;
-    return JIM_OK;
-}
-
-int Jim_GetWide(Jim_Interp *interp, Jim_Obj *objPtr, jim_wide *widePtr)
-{
-    if (objPtr-&gt;typePtr != &amp;intObjType &amp;&amp;
-        SetIntFromAny(interp, objPtr, JIM_ERRMSG) == JIM_ERR)
-        return JIM_ERR;
-    *widePtr = objPtr-&gt;internalRep.wideValue;
-    return JIM_OK;
-}
-
-/* Get a wide but does not set an error if the format is bad. */
-static int JimGetWideNoErr(Jim_Interp *interp, Jim_Obj *objPtr,
-        jim_wide *widePtr)
-{
-    if (objPtr-&gt;typePtr != &amp;intObjType &amp;&amp;
-        SetIntFromAny(interp, objPtr, JIM_NONE) == JIM_ERR)
-        return JIM_ERR;
-    *widePtr = objPtr-&gt;internalRep.wideValue;
-    return JIM_OK;
-}
-
-int Jim_GetLong(Jim_Interp *interp, Jim_Obj *objPtr, long *longPtr)
-{
-    jim_wide wideValue;
-    int retval;
-
-    retval = Jim_GetWide(interp, objPtr, &amp;wideValue);
-    if (retval == JIM_OK) {
-        *longPtr = (long) wideValue;
-        return JIM_OK;
-    }
-    return JIM_ERR;
-}
-
-void Jim_SetWide(Jim_Interp *interp, Jim_Obj *objPtr, jim_wide wideValue)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,&quot;Jim_SetWide called with shared object&quot;);
-    if (objPtr-&gt;typePtr != &amp;intObjType) {
-        Jim_FreeIntRep(interp, objPtr);
-        objPtr-&gt;typePtr = &intObjType;
-    }
-    Jim_InvalidateStringRep(objPtr);
-    objPtr-&gt;internalRep.wideValue = wideValue;
-}
-
-Jim_Obj *Jim_NewIntObj(Jim_Interp *interp, jim_wide wideValue)
-{
-    Jim_Obj *objPtr;
-
-    objPtr = Jim_NewObj(interp);
-    objPtr-&gt;typePtr = &intObjType;
-    objPtr-&gt;bytes = NULL;
-    objPtr-&gt;internalRep.wideValue = wideValue;
-    return objPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * Double object
- * ---------------------------------------------------------------------------*/
-#define JIM_DOUBLE_SPACE 30
-
-static void UpdateStringOfDouble(struct Jim_Obj *objPtr);
-static int SetDoubleFromAny(Jim_Interp *interp, Jim_Obj *objPtr);
-
-static Jim_ObjType doubleObjType = {
-    &quot;double&quot;,
-    NULL,
-    NULL,
-    UpdateStringOfDouble,
-    JIM_TYPE_NONE,
-};
-
-void UpdateStringOfDouble(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_DOUBLE_SPACE + 1];
-
-    len = Jim_DoubleToString(buf, objPtr-&gt;internalRep.doubleValue);
-    objPtr-&gt;bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr-&gt;bytes, buf, len + 1);
-    objPtr-&gt;length = len;
-}
-
-int SetDoubleFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    double doubleValue;
-    const char *str;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, NULL);
-    /* Try to convert into a double */
-    if (Jim_StringToDouble(str, &amp;doubleValue) != JIM_OK) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;expected number but got '&quot;, str, &quot;'&quot;, NULL);
-        return JIM_ERR;
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &doubleObjType;
-    objPtr-&gt;internalRep.doubleValue = doubleValue;
-    return JIM_OK;
-}
-
-int Jim_GetDouble(Jim_Interp *interp, Jim_Obj *objPtr, double *doublePtr)
-{
-    if (objPtr-&gt;typePtr != &amp;doubleObjType &amp;&amp;
-        SetDoubleFromAny(interp, objPtr) == JIM_ERR)
-        return JIM_ERR;
-    *doublePtr = objPtr-&gt;internalRep.doubleValue;
-    return JIM_OK;
-}
-
-void Jim_SetDouble(Jim_Interp *interp, Jim_Obj *objPtr, double doubleValue)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,&quot;Jim_SetDouble called with shared object&quot;);
-    if (objPtr-&gt;typePtr != &amp;doubleObjType) {
-        Jim_FreeIntRep(interp, objPtr);
-        objPtr-&gt;typePtr = &doubleObjType;
-    }
-    Jim_InvalidateStringRep(objPtr);
-    objPtr-&gt;internalRep.doubleValue = doubleValue;
-}
-
-Jim_Obj *Jim_NewDoubleObj(Jim_Interp *interp, double doubleValue)
-{
-    Jim_Obj *objPtr;
-
-    objPtr = Jim_NewObj(interp);
-    objPtr-&gt;typePtr = &doubleObjType;
-    objPtr-&gt;bytes = NULL;
-    objPtr-&gt;internalRep.doubleValue = doubleValue;
-    return objPtr;
-}
-
-/* -----------------------------------------------------------------------------
- * List object
- * ---------------------------------------------------------------------------*/
-static void ListAppendElement(Jim_Obj *listPtr, Jim_Obj *objPtr);
-static void FreeListInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupListInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static void UpdateStringOfList(struct Jim_Obj *objPtr);
-static int SetListFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-/* Note that while the elements of the list may contain references,
- * the list object itself can't. This basically means that the
- * list object string representation as a whole can't contain references
- * that are not presents in the single elements. */
-static Jim_ObjType listObjType = {
-    &quot;list&quot;,
-    FreeListInternalRep,
-    DupListInternalRep,
-    UpdateStringOfList,
-    JIM_TYPE_NONE,
-};
-
-void FreeListInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int i;
-
-    for (i = 0; i &lt; objPtr-&gt;internalRep.listValue.len; i++) {
-        Jim_DecrRefCount(interp, objPtr-&gt;internalRep.listValue.ele[i]);
-    }
-    Jim_Free(objPtr-&gt;internalRep.listValue.ele);
-}
-
-void DupListInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    int i;
-    JIM_NOTUSED(interp);
-
-    dupPtr-&gt;internalRep.listValue.len = srcPtr-&gt;internalRep.listValue.len;
-    dupPtr-&gt;internalRep.listValue.maxLen = srcPtr-&gt;internalRep.listValue.maxLen;
-    dupPtr-&gt;internalRep.listValue.ele =
-        Jim_Alloc(sizeof(Jim_Obj*)*srcPtr-&gt;internalRep.listValue.maxLen);
-    memcpy(dupPtr-&gt;internalRep.listValue.ele, srcPtr-&gt;internalRep.listValue.ele,
-            sizeof(Jim_Obj*)*srcPtr-&gt;internalRep.listValue.len);
-    for (i = 0; i &lt; dupPtr-&gt;internalRep.listValue.len; i++) {
-        Jim_IncrRefCount(dupPtr-&gt;internalRep.listValue.ele[i]);
-    }
-    dupPtr-&gt;typePtr = &listObjType;
-}
-
-/* The following function checks if a given string can be encoded
- * into a list element without any kind of quoting, surrounded by braces,
- * or using escapes to quote. */
-#define JIM_ELESTR_SIMPLE 0
-#define JIM_ELESTR_BRACE 1
-#define JIM_ELESTR_QUOTE 2
-static int ListElementQuotingType(const char *s, int len)
-{
-    int i, level, trySimple = 1;
-
-    /* Try with the SIMPLE case */
-    if (len == 0) return JIM_ELESTR_BRACE;
-    if (s[0] == '&quot;' || s[0] == '{') {
-        trySimple = 0;
-        goto testbrace;
-    }
-    for (i = 0; i &lt; len; i++) {
-        switch (s[i]) {
-        case ' ':
-        case '$':
-        case '&quot;':
-        case '[':
-        case ']':
-        case ';':
-        case '\\':
-        case '\r':
-        case '\n':
-        case '\t':
-        case '\f':
-        case '\v':
-            trySimple = 0;
-        case '{':
-        case '}':
-            goto testbrace;
-        }
-    }
-    return JIM_ELESTR_SIMPLE;
-
-testbrace:
-    /* Test if it's possible to do with braces */
-    if (s[len-1] == '\\' ||
-        s[len-1] == ']') return JIM_ELESTR_QUOTE;
-    level = 0;
-    for (i = 0; i &lt; len; i++) {
-        switch (s[i]) {
-        case '{': level++; break;
-        case '}': level--;
-              if (level &lt; 0) return JIM_ELESTR_QUOTE;
-              break;
-        case '\\':
-              if (s[i + 1] == '\n')
-                  return JIM_ELESTR_QUOTE;
-              else
-                  if (s[i + 1] != '\0') i++;
-              break;
-        }
-    }
-    if (level == 0) {
-        if (!trySimple) return JIM_ELESTR_BRACE;
-        for (i = 0; i &lt; len; i++) {
-            switch (s[i]) {
-            case ' ':
-            case '$':
-            case '&quot;':
-            case '[':
-            case ']':
-            case ';':
-            case '\\':
-            case '\r':
-            case '\n':
-            case '\t':
-            case '\f':
-            case '\v':
-                return JIM_ELESTR_BRACE;
-                break;
-            }
-        }
-        return JIM_ELESTR_SIMPLE;
-    }
-    return JIM_ELESTR_QUOTE;
-}
-
-/* Returns the malloc-ed representation of a string
- * using backslash to quote special chars. */
-char *BackslashQuoteString(const char *s, int len, int *qlenPtr)
-{
-    char *q = Jim_Alloc(len*2 + 1), *p;
-
-    p = q;
-    while (*s) {
-        switch (*s) {
-        case ' ':
-        case '$':
-        case '&quot;':
-        case '[':
-        case ']':
-        case '{':
-        case '}':
-        case ';':
-        case '\\':
-            *p++ = '\\';
-            *p++ = *s++;
-            break;
-        case '\n': *p++ = '\\'; *p++ = 'n'; s++; break;
-        case '\r': *p++ = '\\'; *p++ = 'r'; s++; break;
-        case '\t': *p++ = '\\'; *p++ = 't'; s++; break;
-        case '\f': *p++ = '\\'; *p++ = 'f'; s++; break;
-        case '\v': *p++ = '\\'; *p++ = 'v'; s++; break;
-        default:
-            *p++ = *s++;
-            break;
-        }
-    }
-    *p = '\0';
-    *qlenPtr = p-q;
-    return q;
-}
-
-void UpdateStringOfList(struct Jim_Obj *objPtr)
-{
-    int i, bufLen, realLength;
-    const char *strRep;
-    char *p;
-    int *quotingType;
-    Jim_Obj **ele = objPtr-&gt;internalRep.listValue.ele;
-
-    /* (Over) Estimate the space needed. */
-    quotingType = Jim_Alloc(sizeof(int)*objPtr-&gt;internalRep.listValue.len + 1);
-    bufLen = 0;
-    for (i = 0; i &lt; objPtr-&gt;internalRep.listValue.len; i++) {
-        int len;
-
-        strRep = Jim_GetString(ele[i], &amp;len);
-        quotingType[i] = ListElementQuotingType(strRep, len);
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE: bufLen += len; break;
-        case JIM_ELESTR_BRACE: bufLen += len + 2; break;
-        case JIM_ELESTR_QUOTE: bufLen += len*2; break;
-        }
-        bufLen++; /* elements separator. */
-    }
-    bufLen++;
-
-    /* Generate the string rep. */
-    p = objPtr-&gt;bytes = Jim_Alloc(bufLen + 1);
-    realLength = 0;
-    for (i = 0; i &lt; objPtr-&gt;internalRep.listValue.len; i++) {
-        int len, qlen;
-        strRep = Jim_GetString(ele[i], &amp;len);
-        char *q;
-
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE:
-            memcpy(p, strRep, len);
-            p += len;
-            realLength += len;
-            break;
-        case JIM_ELESTR_BRACE:
-            *p++ = '{';
-            memcpy(p, strRep, len);
-            p += len;
-            *p++ = '}';
-            realLength += len + 2;
-            break;
-        case JIM_ELESTR_QUOTE:
-            q = BackslashQuoteString(strRep, len, &amp;qlen);
-            memcpy(p, q, qlen);
-            Jim_Free(q);
-            p += qlen;
-            realLength += qlen;
-            break;
-        }
-        /* Add a separating space */
-        if (i + 1 != objPtr-&gt;internalRep.listValue.len) {
-            *p++ = ' ';
-            realLength ++;
-        }
-    }
-    *p = '\0'; /* nul term. */
-    objPtr-&gt;length = realLength;
-    Jim_Free(quotingType);
-}
-
-int SetListFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    struct JimParserCtx parser;
-    const char *str;
-    int strLen;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &amp;strLen);
-
-    /* Free the old internal repr just now and initialize the
-     * new one just now. The string-&gt;list conversion can't fail. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &listObjType;
-    objPtr-&gt;internalRep.listValue.len = 0;
-    objPtr-&gt;internalRep.listValue.maxLen = 0;
-    objPtr-&gt;internalRep.listValue.ele = NULL;
-
-    /* Convert into a list */
-    JimParserInit(&amp;parser, str, strLen, 1);
-    while (!JimParserEof(&amp;parser)) {
-        char *token;
-        int tokenLen, type;
-        Jim_Obj *elementPtr;
-
-        JimParseList(&amp;parser);
-        if (JimParserTtype(&amp;parser) != JIM_TT_STR &amp;&amp;
-            JimParserTtype(&amp;parser) != JIM_TT_ESC)
-            continue;
-        token = JimParserGetToken(&amp;parser, &amp;tokenLen, &amp;type, NULL);
-        elementPtr = Jim_NewStringObjNoAlloc(interp, token, tokenLen);
-        ListAppendElement(objPtr, elementPtr);
-    }
-    return JIM_OK;
-}
-
-Jim_Obj *Jim_NewListObj(Jim_Interp *interp, Jim_Obj *const *elements,
-        int len)
-{
-    Jim_Obj *objPtr;
-    int i;
-
-    objPtr = Jim_NewObj(interp);
-    objPtr-&gt;typePtr = &listObjType;
-    objPtr-&gt;bytes = NULL;
-    objPtr-&gt;internalRep.listValue.ele = NULL;
-    objPtr-&gt;internalRep.listValue.len = 0;
-    objPtr-&gt;internalRep.listValue.maxLen = 0;
-    for (i = 0; i &lt; len; i++) {
-        ListAppendElement(objPtr, elements[i]);
-    }
-    return objPtr;
-}
-
-/* Return a vector of Jim_Obj with the elements of a Jim list, and the
- * length of the vector. Note that the user of this function should make
- * sure that the list object can't shimmer while the vector returned
- * is in use, this vector is the one stored inside the internal representation
- * of the list object. This function is not exported, extensions should
- * always access to the List object elements using Jim_ListIndex(). */
-static void JimListGetElements(Jim_Interp *interp, Jim_Obj *listObj, int *argc,
-        Jim_Obj ***listVec)
-{
-    Jim_ListLength(interp, listObj, argc);
-    assert(listObj-&gt;typePtr == &amp;listObjType);
-    *listVec = listObj-&gt;internalRep.listValue.ele;
-}
-
-/* ListSortElements type values */
-enum {JIM_LSORT_ASCII, JIM_LSORT_NOCASE, JIM_LSORT_ASCII_DECR,
-      JIM_LSORT_NOCASE_DECR};
-
-/* Sort the internal rep of a list. */
-static int ListSortString(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 0);
-}
-
-static int ListSortStringDecr(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 0) * -1;
-}
-
-static int ListSortStringNoCase(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 1);
-}
-
-static int ListSortStringNoCaseDecr(Jim_Obj **lhsObj, Jim_Obj **rhsObj)
-{
-    return Jim_StringCompareObj(*lhsObj, *rhsObj, 1) * -1;
-}
-
-/* Sort a list *in place*. MUST be called with non-shared objects. */
-static void ListSortElements(Jim_Interp *interp, Jim_Obj *listObjPtr, int type)
-{
-    typedef int (qsort_comparator)(const void *, const void *);
-    int (*fn)(Jim_Obj**, Jim_Obj**);
-    Jim_Obj **vector;
-    int len;
-
-    if (Jim_IsShared(listObjPtr))
-        Jim_Panic(interp,&quot;Jim_ListSortElements called with shared object&quot;);
-    if (listObjPtr-&gt;typePtr != &amp;listObjType)
-        SetListFromAny(interp, listObjPtr);
-
-    vector = listObjPtr-&gt;internalRep.listValue.ele;
-    len = listObjPtr-&gt;internalRep.listValue.len;
-    switch (type) {
-        case JIM_LSORT_ASCII: fn = ListSortString;  break;
-        case JIM_LSORT_NOCASE: fn = ListSortStringNoCase;  break;
-        case JIM_LSORT_ASCII_DECR: fn = ListSortStringDecr;  break;
-        case JIM_LSORT_NOCASE_DECR: fn = ListSortStringNoCaseDecr;  break;
-        default:
-            fn = NULL; /* avoid warning */
-            Jim_Panic(interp,&quot;ListSort called with invalid sort type&quot;);
-    }
-    qsort(vector, len, sizeof(Jim_Obj *), (qsort_comparator *)fn);
-    Jim_InvalidateStringRep(listObjPtr);
-}
-
-/* This is the low-level function to append an element to a list.
- * The higher-level Jim_ListAppendElement() performs shared object
- * check and invalidate the string repr. This version is used
- * in the internals of the List Object and is not exported.
- *
- * NOTE: this function can be called only against objects
- * with internal type of List. */
-void ListAppendElement(Jim_Obj *listPtr, Jim_Obj *objPtr)
-{
-    int requiredLen = listPtr-&gt;internalRep.listValue.len + 1;
-
-    if (requiredLen &gt; listPtr-&gt;internalRep.listValue.maxLen) {
-        int maxLen = requiredLen * 2;
-
-        listPtr-&gt;internalRep.listValue.ele =
-            Jim_Realloc(listPtr-&gt;internalRep.listValue.ele,
-                    sizeof(Jim_Obj*)*maxLen);
-        listPtr-&gt;internalRep.listValue.maxLen = maxLen;
-    }
-    listPtr-&gt;internalRep.listValue.ele[listPtr-&gt;internalRep.listValue.len] =
-        objPtr;
-    listPtr-&gt;internalRep.listValue.len ++;
-    Jim_IncrRefCount(objPtr);
-}
-
-/* This is the low-level function to insert elements into a list.
- * The higher-level Jim_ListInsertElements() performs shared object
- * check and invalidate the string repr. This version is used
- * in the internals of the List Object and is not exported.
- *
- * NOTE: this function can be called only against objects
- * with internal type of List. */
-void ListInsertElements(Jim_Obj *listPtr, int index_t, int elemc,
-        Jim_Obj *const *elemVec)
-{
-    int currentLen = listPtr-&gt;internalRep.listValue.len;
-    int requiredLen = currentLen + elemc;
-    int i;
-    Jim_Obj **point;
-
-    if (requiredLen &gt; listPtr-&gt;internalRep.listValue.maxLen) {
-        int maxLen = requiredLen * 2;
-
-        listPtr-&gt;internalRep.listValue.ele =
-            Jim_Realloc(listPtr-&gt;internalRep.listValue.ele,
-                    sizeof(Jim_Obj*)*maxLen);
-        listPtr-&gt;internalRep.listValue.maxLen = maxLen;
-    }
-    point = listPtr-&gt;internalRep.listValue.ele + index_t;
-    memmove(point + elemc, point, (currentLen-index_t) * sizeof(Jim_Obj*));
-    for (i = 0; i &lt; elemc; ++i) {
-        point[i] = elemVec[i];
-        Jim_IncrRefCount(point[i]);
-    }
-    listPtr-&gt;internalRep.listValue.len += elemc;
-}
-
-/* Appends every element of appendListPtr into listPtr.
- * Both have to be of the list type. */
-void ListAppendList(Jim_Obj *listPtr, Jim_Obj *appendListPtr)
-{
-    int i, oldLen = listPtr-&gt;internalRep.listValue.len;
-    int appendLen = appendListPtr-&gt;internalRep.listValue.len;
-    int requiredLen = oldLen + appendLen;
-
-    if (requiredLen &gt; listPtr-&gt;internalRep.listValue.maxLen) {
-        int maxLen = requiredLen * 2;
-
-        listPtr-&gt;internalRep.listValue.ele =
-            Jim_Realloc(listPtr-&gt;internalRep.listValue.ele,
-                    sizeof(Jim_Obj*)*maxLen);
-        listPtr-&gt;internalRep.listValue.maxLen = maxLen;
-    }
-    for (i = 0; i &lt; appendLen; i++) {
-        Jim_Obj *objPtr = appendListPtr-&gt;internalRep.listValue.ele[i];
-        listPtr-&gt;internalRep.listValue.ele[oldLen + i] = objPtr;
-        Jim_IncrRefCount(objPtr);
-    }
-    listPtr-&gt;internalRep.listValue.len += appendLen;
-}
-
-void Jim_ListAppendElement(Jim_Interp *interp, Jim_Obj *listPtr, Jim_Obj *objPtr)
-{
-    if (Jim_IsShared(listPtr))
-        Jim_Panic(interp,&quot;Jim_ListAppendElement called with shared object&quot;);
-    if (listPtr-&gt;typePtr != &amp;listObjType)
-        SetListFromAny(interp, listPtr);
-    Jim_InvalidateStringRep(listPtr);
-    ListAppendElement(listPtr, objPtr);
-}
-
-void Jim_ListAppendList(Jim_Interp *interp, Jim_Obj *listPtr, Jim_Obj *appendListPtr)
-{
-    if (Jim_IsShared(listPtr))
-        Jim_Panic(interp,&quot;Jim_ListAppendList called with shared object&quot;);
-    if (listPtr-&gt;typePtr != &amp;listObjType)
-        SetListFromAny(interp, listPtr);
-    Jim_InvalidateStringRep(listPtr);
-    ListAppendList(listPtr, appendListPtr);
-}
-
-void Jim_ListLength(Jim_Interp *interp, Jim_Obj *listPtr, int *intPtr)
-{
-    if (listPtr-&gt;typePtr != &amp;listObjType)
-        SetListFromAny(interp, listPtr);
-    *intPtr = listPtr-&gt;internalRep.listValue.len;
-}
-
-void Jim_ListInsertElements(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
-        int objc, Jim_Obj *const *objVec)
-{
-    if (Jim_IsShared(listPtr))
-        Jim_Panic(interp,&quot;Jim_ListInsertElement called with shared object&quot;);
-    if (listPtr-&gt;typePtr != &amp;listObjType)
-        SetListFromAny(interp, listPtr);
-    if (index_t &gt;= 0 &amp;&amp; index_t &gt; listPtr-&gt;internalRep.listValue.len)
-        index_t = listPtr-&gt;internalRep.listValue.len;
-    else if (index_t &lt; 0)
-        index_t = 0;
-    Jim_InvalidateStringRep(listPtr);
-    ListInsertElements(listPtr, index_t, objc, objVec);
-}
-
-int Jim_ListIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
-        Jim_Obj **objPtrPtr, int flags)
-{
-    if (listPtr-&gt;typePtr != &amp;listObjType)
-        SetListFromAny(interp, listPtr);
-    if ((index_t &gt;= 0 &amp;&amp; index_t &gt;= listPtr-&gt;internalRep.listValue.len) ||
-        (index_t &lt; 0 &amp;&amp; (-index_t-1) &gt;= listPtr-&gt;internalRep.listValue.len)) {
-        if (flags &amp; JIM_ERRMSG) {
-            Jim_SetResultString(interp,
-                &quot;list index out of range&quot;, -1);
-        }
-        return JIM_ERR;
-    }
-    if (index_t &lt; 0)
-        index_t = listPtr-&gt;internalRep.listValue.len + index_t;
-    *objPtrPtr = listPtr-&gt;internalRep.listValue.ele[index_t];
-    return JIM_OK;
-}
-
-static int ListSetIndex(Jim_Interp *interp, Jim_Obj *listPtr, int index_t,
-        Jim_Obj *newObjPtr, int flags)
-{
-    if (listPtr-&gt;typePtr != &amp;listObjType)
-        SetListFromAny(interp, listPtr);
-    if ((index_t &gt;= 0 &amp;&amp; index_t &gt;= listPtr-&gt;internalRep.listValue.len) ||
-        (index_t &lt; 0 &amp;&amp; (-index_t-1) &gt;= listPtr-&gt;internalRep.listValue.len)) {
-        if (flags &amp; JIM_ERRMSG) {
-            Jim_SetResultString(interp,
-                &quot;list index_t out of range&quot;, -1);
-        }
-        return JIM_ERR;
-    }
-    if (index_t &lt; 0)
-        index_t = listPtr-&gt;internalRep.listValue.len + index_t;
-    Jim_DecrRefCount(interp, listPtr-&gt;internalRep.listValue.ele[index_t]);
-    listPtr-&gt;internalRep.listValue.ele[index_t] = newObjPtr;
-    Jim_IncrRefCount(newObjPtr);
-    return JIM_OK;
-}
-
-/* Modify the list stored into the variable named 'varNamePtr'
- * setting the element specified by the 'indexc' indexes objects in 'indexv',
- * with the new element 'newObjptr'. */
-int Jim_SetListIndex(Jim_Interp *interp, Jim_Obj *varNamePtr,
-        Jim_Obj *const *indexv, int indexc, Jim_Obj *newObjPtr)
-{
-    Jim_Obj *varObjPtr, *objPtr, *listObjPtr;
-    int shared, i, index_t;
-
-    varObjPtr = objPtr = Jim_GetVariable(interp, varNamePtr, JIM_ERRMSG);
-    if (objPtr == NULL)
-        return JIM_ERR;
-    if ((shared = Jim_IsShared(objPtr)))
-        varObjPtr = objPtr = Jim_DuplicateObj(interp, objPtr);
-    for (i = 0; i &lt; indexc-1; i++) {
-        listObjPtr = objPtr;
-        if (Jim_GetIndex(interp, indexv[i], &amp;index_t) != JIM_OK)
-            goto err;
-        if (Jim_ListIndex(interp, listObjPtr, index_t, &amp;objPtr,
-                    JIM_ERRMSG) != JIM_OK) {
-            goto err;
-        }
-        if (Jim_IsShared(objPtr)) {
-            objPtr = Jim_DuplicateObj(interp, objPtr);
-            ListSetIndex(interp, listObjPtr, index_t, objPtr, JIM_NONE);
-        }
-        Jim_InvalidateStringRep(listObjPtr);
-    }
-    if (Jim_GetIndex(interp, indexv[indexc-1], &amp;index_t) != JIM_OK)
-        goto err;
-    if (ListSetIndex(interp, objPtr, index_t, newObjPtr, JIM_ERRMSG) == JIM_ERR)
-        goto err;
-    Jim_InvalidateStringRep(objPtr);
-    Jim_InvalidateStringRep(varObjPtr);
-    if (Jim_SetVariable(interp, varNamePtr, varObjPtr) != JIM_OK)
-        goto err;
-    Jim_SetResult(interp, varObjPtr);
-    return JIM_OK;
-err:
-    if (shared) {
-        Jim_FreeNewObj(interp, varObjPtr);
-    }
-    return JIM_ERR;
-}
-
-Jim_Obj *Jim_ConcatObj(Jim_Interp *interp, int objc, Jim_Obj *const *objv)
-{
-    int i;
-
-    /* If all the objects in objv are lists without string rep.
-     * it's possible to return a list as result, that's the
-     * concatenation of all the lists. */
-    for (i = 0; i &lt; objc; i++) {
-        if (objv[i]-&gt;typePtr != &amp;listObjType || objv[i]-&gt;bytes)
-            break;
-    }
-    if (i == objc) {
-        Jim_Obj *objPtr = Jim_NewListObj(interp, NULL, 0);
-        for (i = 0; i &lt; objc; i++)
-            Jim_ListAppendList(interp, objPtr, objv[i]);
-        return objPtr;
-    } else {
-        /* Else... we have to glue strings together */
-        int len = 0, objLen;
-        char *bytes, *p;
-
-        /* Compute the length */
-        for (i = 0; i &lt; objc; i++) {
-            Jim_GetString(objv[i], &amp;objLen);
-            len += objLen;
-        }
-        if (objc) len += objc-1;
-        /* Create the string rep, and a stinrg object holding it. */
-        p = bytes = Jim_Alloc(len + 1);
-        for (i = 0; i &lt; objc; i++) {
-            const char *s = Jim_GetString(objv[i], &amp;objLen);
-            while (objLen &amp;&amp; (*s == ' ' || *s == '\t' || *s == '\n'))
-            {
-                s++; objLen--; len--;
-            }
-            while (objLen &amp;&amp; (s[objLen-1] == ' ' ||
-                s[objLen-1] == '\n' || s[objLen-1] == '\t')) {
-                objLen--; len--;
-            }
-            memcpy(p, s, objLen);
-            p += objLen;
-            if (objLen &amp;&amp; i + 1 != objc) {
-                *p++ = ' ';
-            } else if (i + 1 != objc) {
-                /* Drop the space calcuated for this
-                 * element that is instead null. */
-                len--;
-            }
-        }
-        *p = '\0';
-        return Jim_NewStringObjNoAlloc(interp, bytes, len);
-    }
-}
-
-/* Returns a list composed of the elements in the specified range.
- * first and start are directly accepted as Jim_Objects and
- * processed for the end?-index? case. */
-Jim_Obj *Jim_ListRange(Jim_Interp *interp, Jim_Obj *listObjPtr, Jim_Obj *firstObjPtr, Jim_Obj *lastObjPtr)
-{
-    int first, last;
-    int len, rangeLen;
-
-    if (Jim_GetIndex(interp, firstObjPtr, &amp;first) != JIM_OK ||
-        Jim_GetIndex(interp, lastObjPtr, &amp;last) != JIM_OK)
-        return NULL;
-    Jim_ListLength(interp, listObjPtr, &amp;len); /* will convert into list */
-    first = JimRelToAbsIndex(len, first);
-    last = JimRelToAbsIndex(len, last);
-    JimRelToAbsRange(len, first, last, &amp;first, &amp;last, &amp;rangeLen);
-    return Jim_NewListObj(interp,
-            listObjPtr-&gt;internalRep.listValue.ele + first, rangeLen);
-}
-
-/* -----------------------------------------------------------------------------
- * Dict object
- * ---------------------------------------------------------------------------*/
-static void FreeDictInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupDictInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static void UpdateStringOfDict(struct Jim_Obj *objPtr);
-static int SetDictFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-/* Dict HashTable Type.
- *
- * Keys and Values are Jim objects. */
-
-unsigned int JimObjectHTHashFunction(const void *key)
-{
-    const char *str;
-    Jim_Obj *objPtr = (Jim_Obj*) key;
-    int len, h;
-
-    str = Jim_GetString(objPtr, &amp;len);
-    h = Jim_GenHashFunction((unsigned char*)str, len);
-    return h;
-}
-
-int JimObjectHTKeyCompare(void *privdata, const void *key1, const void *key2)
-{
-    JIM_NOTUSED(privdata);
-
-    return Jim_StringEqObj((Jim_Obj*)key1, (Jim_Obj*)key2, 0);
-}
-
-static void JimObjectHTKeyValDestructor(void *interp, void *val)
-{
-    Jim_Obj *objPtr = val;
-
-    Jim_DecrRefCount(interp, objPtr);
-}
-
-static Jim_HashTableType JimDictHashTableType = {
-    JimObjectHTHashFunction,            /* hash function */
-    NULL,                               /* key dup */
-    NULL,                               /* val dup */
-    JimObjectHTKeyCompare,              /* key compare */
-    (void(*)(void*, const void*))       /* ATTENTION: const cast */
-        JimObjectHTKeyValDestructor,    /* key destructor */
-    JimObjectHTKeyValDestructor         /* val destructor */
-};
-
-/* Note that while the elements of the dict may contain references,
- * the list object itself can't. This basically means that the
- * dict object string representation as a whole can't contain references
- * that are not presents in the single elements. */
-static Jim_ObjType dictObjType = {
-    &quot;dict&quot;,
-    FreeDictInternalRep,
-    DupDictInternalRep,
-    UpdateStringOfDict,
-    JIM_TYPE_NONE,
-};
-
-void FreeDictInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    JIM_NOTUSED(interp);
-
-    Jim_FreeHashTable(objPtr-&gt;internalRep.ptr);
-    Jim_Free(objPtr-&gt;internalRep.ptr);
-}
-
-void DupDictInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    Jim_HashTable *ht, *dupHt;
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-
-    /* Create a new hash table */
-    ht = srcPtr-&gt;internalRep.ptr;
-    dupHt = Jim_Alloc(sizeof(*dupHt));
-    Jim_InitHashTable(dupHt, &amp;JimDictHashTableType, interp);
-    if (ht-&gt;size != 0)
-        Jim_ExpandHashTable(dupHt, ht-&gt;size);
-    /* Copy every element from the source to the dup hash table */
-    htiter = Jim_GetHashTableIterator(ht);
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        const Jim_Obj *keyObjPtr = he-&gt;key;
-        Jim_Obj *valObjPtr = he-&gt;val;
-
-        Jim_IncrRefCount((Jim_Obj*)keyObjPtr);  /* ATTENTION: const cast */
-        Jim_IncrRefCount(valObjPtr);
-        Jim_AddHashEntry(dupHt, keyObjPtr, valObjPtr);
-    }
-    Jim_FreeHashTableIterator(htiter);
-
-    dupPtr-&gt;internalRep.ptr = dupHt;
-    dupPtr-&gt;typePtr = &dictObjType;
-}
-
-void UpdateStringOfDict(struct Jim_Obj *objPtr)
-{
-    int i, bufLen, realLength;
-    const char *strRep;
-    char *p;
-    int *quotingType, objc;
-    Jim_HashTable *ht;
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj **objv;
-
-    /* Trun the hash table into a flat vector of Jim_Objects. */
-    ht = objPtr-&gt;internalRep.ptr;
-    objc = ht-&gt;used*2;
-    objv = Jim_Alloc(objc*sizeof(Jim_Obj*));
-    htiter = Jim_GetHashTableIterator(ht);
-    i = 0;
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        objv[i++] = (Jim_Obj*)he-&gt;key;  /* ATTENTION: const cast */
-        objv[i++] = he-&gt;val;
-    }
-    Jim_FreeHashTableIterator(htiter);
-    /* (Over) Estimate the space needed. */
-    quotingType = Jim_Alloc(sizeof(int)*objc);
-    bufLen = 0;
-    for (i = 0; i &lt; objc; i++) {
-        int len;
-
-        strRep = Jim_GetString(objv[i], &amp;len);
-        quotingType[i] = ListElementQuotingType(strRep, len);
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE: bufLen += len; break;
-        case JIM_ELESTR_BRACE: bufLen += len + 2; break;
-        case JIM_ELESTR_QUOTE: bufLen += len*2; break;
-        }
-        bufLen++; /* elements separator. */
-    }
-    bufLen++;
-
-    /* Generate the string rep. */
-    p = objPtr-&gt;bytes = Jim_Alloc(bufLen + 1);
-    realLength = 0;
-    for (i = 0; i &lt; objc; i++) {
-        int len, qlen;
-        strRep = Jim_GetString(objv[i], &amp;len);
-        char *q;
-
-        switch (quotingType[i]) {
-        case JIM_ELESTR_SIMPLE:
-            memcpy(p, strRep, len);
-            p += len;
-            realLength += len;
-            break;
-        case JIM_ELESTR_BRACE:
-            *p++ = '{';
-            memcpy(p, strRep, len);
-            p += len;
-            *p++ = '}';
-            realLength += len + 2;
-            break;
-        case JIM_ELESTR_QUOTE:
-            q = BackslashQuoteString(strRep, len, &amp;qlen);
-            memcpy(p, q, qlen);
-            Jim_Free(q);
-            p += qlen;
-            realLength += qlen;
-            break;
-        }
-        /* Add a separating space */
-        if (i + 1 != objc) {
-            *p++ = ' ';
-            realLength ++;
-        }
-    }
-    *p = '\0'; /* nul term. */
-    objPtr-&gt;length = realLength;
-    Jim_Free(quotingType);
-    Jim_Free(objv);
-}
-
-int SetDictFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    struct JimParserCtx parser;
-    Jim_HashTable *ht;
-    Jim_Obj *objv[2];
-    const char *str;
-    int i, strLen;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &amp;strLen);
-
-    /* Free the old internal repr just now and initialize the
-     * new one just now. The string-&gt;list conversion can't fail. */
-    Jim_FreeIntRep(interp, objPtr);
-    ht = Jim_Alloc(sizeof(*ht));
-    Jim_InitHashTable(ht, &amp;JimDictHashTableType, interp);
-    objPtr-&gt;typePtr = &dictObjType;
-    objPtr-&gt;internalRep.ptr = ht;
-
-    /* Convert into a dict */
-    JimParserInit(&amp;parser, str, strLen, 1);
-    i = 0;
-    while (!JimParserEof(&amp;parser)) {
-        char *token;
-        int tokenLen, type;
-
-        JimParseList(&amp;parser);
-        if (JimParserTtype(&amp;parser) != JIM_TT_STR &amp;&amp;
-            JimParserTtype(&amp;parser) != JIM_TT_ESC)
-            continue;
-        token = JimParserGetToken(&amp;parser, &amp;tokenLen, &amp;type, NULL);
-        objv[i++] = Jim_NewStringObjNoAlloc(interp, token, tokenLen);
-        if (i == 2) {
-            i = 0;
-            Jim_IncrRefCount(objv[0]);
-            Jim_IncrRefCount(objv[1]);
-            if (Jim_AddHashEntry(ht, objv[0], objv[1]) != JIM_OK) {
-                Jim_HashEntry *he;
-                he = Jim_FindHashEntry(ht, objv[0]);
-                Jim_DecrRefCount(interp, objv[0]);
-                /* ATTENTION: const cast */
-                Jim_DecrRefCount(interp, (Jim_Obj*)he-&gt;val);
-                he-&gt;val = objv[1];
-            }
-        }
-    }
-    if (i) {
-        Jim_FreeNewObj(interp, objv[0]);
-        objPtr-&gt;typePtr = NULL;
-        Jim_FreeHashTable(ht);
-        Jim_SetResultString(interp, &quot;invalid dictionary value: must be a list with an even number of elements&quot;, -1);
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* Dict object API */
-
-/* Add an element to a dict. objPtr must be of the &quot;dict&quot; type.
- * The higer-level exported function is Jim_DictAddElement().
- * If an element with the specified key already exists, the value
- * associated is replaced with the new one.
- *
- * if valueObjPtr == NULL, the key is instead removed if it exists. */
-static void DictAddElement(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *keyObjPtr, Jim_Obj *valueObjPtr)
-{
-    Jim_HashTable *ht = objPtr-&gt;internalRep.ptr;
-
-    if (valueObjPtr == NULL) { /* unset */
-        Jim_DeleteHashEntry(ht, keyObjPtr);
-        return;
-    }
-    Jim_IncrRefCount(keyObjPtr);
-    Jim_IncrRefCount(valueObjPtr);
-    if (Jim_AddHashEntry(ht, keyObjPtr, valueObjPtr) != JIM_OK) {
-        Jim_HashEntry *he = Jim_FindHashEntry(ht, keyObjPtr);
-        Jim_DecrRefCount(interp, keyObjPtr);
-        /* ATTENTION: const cast */
-        Jim_DecrRefCount(interp, (Jim_Obj*)he-&gt;val);
-        he-&gt;val = valueObjPtr;
-    }
-}
-
-/* Add an element, higher-level interface for DictAddElement().
- * If valueObjPtr == NULL, the key is removed if it exists. */
-int Jim_DictAddElement(Jim_Interp *interp, Jim_Obj *objPtr,
-        Jim_Obj *keyObjPtr, Jim_Obj *valueObjPtr)
-{
-    if (Jim_IsShared(objPtr))
-        Jim_Panic(interp,&quot;Jim_DictAddElement called with shared object&quot;);
-    if (objPtr-&gt;typePtr != &amp;dictObjType) {
-        if (SetDictFromAny(interp, objPtr) != JIM_OK)
-            return JIM_ERR;
-    }
-    DictAddElement(interp, objPtr, keyObjPtr, valueObjPtr);
-    Jim_InvalidateStringRep(objPtr);
-    return JIM_OK;
-}
-
-Jim_Obj *Jim_NewDictObj(Jim_Interp *interp, Jim_Obj *const *elements, int len)
-{
-    Jim_Obj *objPtr;
-    int i;
-
-    if (len % 2)
-        Jim_Panic(interp,&quot;Jim_NewDicObj() 'len' argument must be even&quot;);
-
-    objPtr = Jim_NewObj(interp);
-    objPtr-&gt;typePtr = &dictObjType;
-    objPtr-&gt;bytes = NULL;
-    objPtr-&gt;internalRep.ptr = Jim_Alloc(sizeof(Jim_HashTable));
-    Jim_InitHashTable(objPtr-&gt;internalRep.ptr, &amp;JimDictHashTableType, interp);
-    for (i = 0; i &lt; len; i += 2)
-        DictAddElement(interp, objPtr, elements[i], elements[i + 1]);
-    return objPtr;
-}
-
-/* Return the value associated to the specified dict key */
-int Jim_DictKey(Jim_Interp *interp, Jim_Obj *dictPtr, Jim_Obj *keyPtr,
-        Jim_Obj **objPtrPtr, int flags)
-{
-    Jim_HashEntry *he;
-    Jim_HashTable *ht;
-
-    if (dictPtr-&gt;typePtr != &amp;dictObjType) {
-        if (SetDictFromAny(interp, dictPtr) != JIM_OK)
-            return JIM_ERR;
-    }
-    ht = dictPtr-&gt;internalRep.ptr;
-    if ((he = Jim_FindHashEntry(ht, keyPtr)) == NULL) {
-        if (flags &amp; JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    &quot;key \&quot;&quot;, Jim_GetString(keyPtr, NULL),
-                    &quot;\&quot; not found in dictionary&quot;, NULL);
-        }
-        return JIM_ERR;
-    }
-    *objPtrPtr = he-&gt;val;
-    return JIM_OK;
-}
-
-/* Return the value associated to the specified dict keys */
-int Jim_DictKeysVector(Jim_Interp *interp, Jim_Obj *dictPtr,
-        Jim_Obj *const *keyv, int keyc, Jim_Obj **objPtrPtr, int flags)
-{
-    Jim_Obj *objPtr = NULL;
-    int i;
-
-    if (keyc == 0) {
-        *objPtrPtr = dictPtr;
-        return JIM_OK;
-    }
-
-    for (i = 0; i &lt; keyc; i++) {
-        if (Jim_DictKey(interp, dictPtr, keyv[i], &amp;objPtr, flags)
-                != JIM_OK)
-            return JIM_ERR;
-        dictPtr = objPtr;
-    }
-    *objPtrPtr = objPtr;
-    return JIM_OK;
-}
-
-/* Modify the dict stored into the variable named 'varNamePtr'
- * setting the element specified by the 'keyc' keys objects in 'keyv',
- * with the new value of the element 'newObjPtr'.
- *
- * If newObjPtr == NULL the operation is to remove the given key
- * from the dictionary. */
-int Jim_SetDictKeysVector(Jim_Interp *interp, Jim_Obj *varNamePtr,
-        Jim_Obj *const *keyv, int keyc, Jim_Obj *newObjPtr)
-{
-    Jim_Obj *varObjPtr, *objPtr, *dictObjPtr;
-    int shared, i;
-
-    varObjPtr = objPtr = Jim_GetVariable(interp, varNamePtr, JIM_ERRMSG);
-    if (objPtr == NULL) {
-        if (newObjPtr == NULL) /* Cannot remove a key from non existing var */
-            return JIM_ERR;
-        varObjPtr = objPtr = Jim_NewDictObj(interp, NULL, 0);
-        if (Jim_SetVariable(interp, varNamePtr, objPtr) != JIM_OK) {
-            Jim_FreeNewObj(interp, varObjPtr);
-            return JIM_ERR;
-        }
-    }
-    if ((shared = Jim_IsShared(objPtr)))
-        varObjPtr = objPtr = Jim_DuplicateObj(interp, objPtr);
-    for (i = 0; i &lt; keyc-1; i++) {
-        dictObjPtr = objPtr;
-
-        /* Check if it's a valid dictionary */
-        if (dictObjPtr-&gt;typePtr != &amp;dictObjType) {
-            if (SetDictFromAny(interp, dictObjPtr) != JIM_OK)
-                goto err;
-        }
-        /* Check if the given key exists. */
-        Jim_InvalidateStringRep(dictObjPtr);
-        if (Jim_DictKey(interp, dictObjPtr, keyv[i], &amp;objPtr,
-            newObjPtr ? JIM_NONE : JIM_ERRMSG) == JIM_OK)
-        {
-            /* This key exists at the current level.
-             * Make sure it's not shared!. */
-            if (Jim_IsShared(objPtr)) {
-                objPtr = Jim_DuplicateObj(interp, objPtr);
-                DictAddElement(interp, dictObjPtr, keyv[i], objPtr);
-            }
-        } else {
-            /* Key not found. If it's an [unset] operation
-             * this is an error. Only the last key may not
-             * exist. */
-            if (newObjPtr == NULL)
-                goto err;
-            /* Otherwise set an empty dictionary
-             * as key's value. */
-            objPtr = Jim_NewDictObj(interp, NULL, 0);
-            DictAddElement(interp, dictObjPtr, keyv[i], objPtr);
-        }
-    }
-    if (Jim_DictAddElement(interp, objPtr, keyv[keyc-1], newObjPtr)
-            != JIM_OK)
-        goto err;
-    Jim_InvalidateStringRep(objPtr);
-    Jim_InvalidateStringRep(varObjPtr);
-    if (Jim_SetVariable(interp, varNamePtr, varObjPtr) != JIM_OK)
-        goto err;
-    Jim_SetResult(interp, varObjPtr);
-    return JIM_OK;
-err:
-    if (shared) {
-        Jim_FreeNewObj(interp, varObjPtr);
-    }
-    return JIM_ERR;
-}
-
-/* -----------------------------------------------------------------------------
- * Index object
- * ---------------------------------------------------------------------------*/
-static void UpdateStringOfIndex(struct Jim_Obj *objPtr);
-static int SetIndexFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType indexObjType = {
-    &quot;index&quot;,
-    NULL,
-    NULL,
-    UpdateStringOfIndex,
-    JIM_TYPE_NONE,
-};
-
-void UpdateStringOfIndex(struct Jim_Obj *objPtr)
-{
-    int len;
-    char buf[JIM_INTEGER_SPACE + 1];
-
-    if (objPtr-&gt;internalRep.indexValue &gt;= 0)
-        len = sprintf(buf, &quot;%d&quot;, objPtr-&gt;internalRep.indexValue);
-    else if (objPtr-&gt;internalRep.indexValue == -1)
-        len = sprintf(buf, &quot;end&quot;);
-    else {
-        len = sprintf(buf, &quot;end%d&quot;, objPtr-&gt;internalRep.indexValue + 1);
-    }
-    objPtr-&gt;bytes = Jim_Alloc(len + 1);
-    memcpy(objPtr-&gt;bytes, buf, len + 1);
-    objPtr-&gt;length = len;
-}
-
-int SetIndexFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int index_t, end = 0;
-    const char *str;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, NULL);
-    /* Try to convert into an index */
-    if (!strcmp(str, &quot;end&quot;)) {
-        index_t = 0;
-        end = 1;
-    } else {
-        if (!strncmp(str, &quot;end-&quot;, 4)) {
-            str += 4;
-            end = 1;
-        }
-        if (Jim_StringToIndex(str, &amp;index_t) != JIM_OK) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    &quot;bad index \&quot;&quot;, Jim_GetString(objPtr, NULL), &quot;\&quot;: &quot;
-                    &quot;must be integer or end?-integer?&quot;, NULL);
-            return JIM_ERR;
-        }
-    }
-    if (end) {
-        if (index_t &lt; 0)
-            index_t = INT_MAX;
-        else
-            index_t = -(index_t + 1);
-    } else if (index_t &lt; 0)
-        index_t = -INT_MAX;
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &indexObjType;
-    objPtr-&gt;internalRep.indexValue = index_t;
-    return JIM_OK;
-}
-
-int Jim_GetIndex(Jim_Interp *interp, Jim_Obj *objPtr, int *indexPtr)
-{
-    /* Avoid shimmering if the object is an integer. */
-    if (objPtr-&gt;typePtr == &amp;intObjType) {
-        jim_wide val = objPtr-&gt;internalRep.wideValue;
-        if (!(val &lt; LONG_MIN) &amp;&amp; !(val &gt; LONG_MAX)) {
-            *indexPtr = (val &lt; 0) ? -INT_MAX : (long)val;;
-            return JIM_OK;
-        }
-    }
-    if (objPtr-&gt;typePtr != &amp;indexObjType &amp;&amp;
-        SetIndexFromAny(interp, objPtr) == JIM_ERR)
-        return JIM_ERR;
-    *indexPtr = objPtr-&gt;internalRep.indexValue;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Return Code Object.
- * ---------------------------------------------------------------------------*/
-
-static int SetReturnCodeFromAny(Jim_Interp *interp, Jim_Obj *objPtr);
-
-static Jim_ObjType returnCodeObjType = {
-    &quot;return-code&quot;,
-    NULL,
-    NULL,
-    NULL,
-    JIM_TYPE_NONE,
-};
-
-int SetReturnCodeFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    const char *str;
-    int strLen, returnCode;
-    jim_wide wideValue;
-
-    /* Get the string representation */
-    str = Jim_GetString(objPtr, &amp;strLen);
-    /* Try to convert into an integer */
-    if (JimGetWideNoErr(interp, objPtr, &amp;wideValue) != JIM_ERR)
-        returnCode = (int) wideValue;
-    else if (!JimStringCompare(str, strLen, &quot;ok&quot;, 2, JIM_NOCASE))
-        returnCode = JIM_OK;
-    else if (!JimStringCompare(str, strLen, &quot;error&quot;, 5, JIM_NOCASE))
-        returnCode = JIM_ERR;
-    else if (!JimStringCompare(str, strLen, &quot;return&quot;, 6, JIM_NOCASE))
-        returnCode = JIM_RETURN;
-    else if (!JimStringCompare(str, strLen, &quot;break&quot;, 5, JIM_NOCASE))
-        returnCode = JIM_BREAK;
-    else if (!JimStringCompare(str, strLen, &quot;continue&quot;, 8, JIM_NOCASE))
-        returnCode = JIM_CONTINUE;
-    else if (!JimStringCompare(str, strLen, &quot;eval&quot;, 4, JIM_NOCASE))
-        returnCode = JIM_EVAL;
-    else if (!JimStringCompare(str, strLen, &quot;exit&quot;, 4, JIM_NOCASE))
-        returnCode = JIM_EXIT;
-    else {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;expected return code but got '&quot;, str, &quot;'&quot;,
-                NULL);
-        return JIM_ERR;
-    }
-    /* Free the old internal repr and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    objPtr-&gt;typePtr = &returnCodeObjType;
-    objPtr-&gt;internalRep.returnCode = returnCode;
-    return JIM_OK;
-}
-
-int Jim_GetReturnCode(Jim_Interp *interp, Jim_Obj *objPtr, int *intPtr)
-{
-    if (objPtr-&gt;typePtr != &amp;returnCodeObjType &amp;&amp;
-        SetReturnCodeFromAny(interp, objPtr) == JIM_ERR)
-        return JIM_ERR;
-    *intPtr = objPtr-&gt;internalRep.returnCode;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Expression Parsing
- * ---------------------------------------------------------------------------*/
-static int JimParseExprOperator(struct JimParserCtx *pc);
-static int JimParseExprNumber(struct JimParserCtx *pc);
-static int JimParseExprIrrational(struct JimParserCtx *pc);
-
-/* Exrp's Stack machine operators opcodes. */
-
-/* Binary operators (numbers) */
-#define JIM_EXPROP_BINARY_NUM_FIRST 0 /* first */
-#define JIM_EXPROP_MUL 0
-#define JIM_EXPROP_DIV 1
-#define JIM_EXPROP_MOD 2
-#define JIM_EXPROP_SUB 3
-#define JIM_EXPROP_ADD 4
-#define JIM_EXPROP_LSHIFT 5
-#define JIM_EXPROP_RSHIFT 6
-#define JIM_EXPROP_ROTL 7
-#define JIM_EXPROP_ROTR 8
-#define JIM_EXPROP_LT 9
-#define JIM_EXPROP_GT 10
-#define JIM_EXPROP_LTE 11
-#define JIM_EXPROP_GTE 12
-#define JIM_EXPROP_NUMEQ 13
-#define JIM_EXPROP_NUMNE 14
-#define JIM_EXPROP_BITAND 15
-#define JIM_EXPROP_BITXOR 16
-#define JIM_EXPROP_BITOR 17
-#define JIM_EXPROP_LOGICAND 18
-#define JIM_EXPROP_LOGICOR 19
-#define JIM_EXPROP_LOGICAND_LEFT 20
-#define JIM_EXPROP_LOGICOR_LEFT 21
-#define JIM_EXPROP_POW 22
-#define JIM_EXPROP_BINARY_NUM_LAST 22 /* last */
-
-/* Binary operators (strings) */
-#define JIM_EXPROP_STREQ 23
-#define JIM_EXPROP_STRNE 24
-
-/* Unary operators (numbers) */
-#define JIM_EXPROP_NOT 25
-#define JIM_EXPROP_BITNOT 26
-#define JIM_EXPROP_UNARYMINUS 27
-#define JIM_EXPROP_UNARYPLUS 28
-#define JIM_EXPROP_LOGICAND_RIGHT 29
-#define JIM_EXPROP_LOGICOR_RIGHT 30
-
-/* Ternary operators */
-#define JIM_EXPROP_TERNARY 31
-
-/* Operands */
-#define JIM_EXPROP_NUMBER 32
-#define JIM_EXPROP_COMMAND 33
-#define JIM_EXPROP_VARIABLE 34
-#define JIM_EXPROP_DICTSUGAR 35
-#define JIM_EXPROP_SUBST 36
-#define JIM_EXPROP_STRING 37
-
-/* Operators table */
-typedef struct Jim_ExprOperator {
-    const char *name;
-    int precedence;
-    int arity;
-    int opcode;
-} Jim_ExprOperator;
-
-/* name - precedence - arity - opcode */
-static struct Jim_ExprOperator Jim_ExprOperators[] = {
-    {&quot;!&quot;, 300, 1, JIM_EXPROP_NOT},
-    {&quot;~&quot;, 300, 1, JIM_EXPROP_BITNOT},
-    {&quot;unarymin&quot;, 300, 1, JIM_EXPROP_UNARYMINUS},
-    {&quot;unaryplus&quot;, 300, 1, JIM_EXPROP_UNARYPLUS},
-
-    {&quot;**&quot;, 250, 2, JIM_EXPROP_POW},
-
-    {&quot;*&quot;, 200, 2, JIM_EXPROP_MUL},
-    {&quot;/&quot;, 200, 2, JIM_EXPROP_DIV},
-    {&quot;%&quot;, 200, 2, JIM_EXPROP_MOD},
-
-    {&quot;-&quot;, 100, 2, JIM_EXPROP_SUB},
-    {&quot;+&quot;, 100, 2, JIM_EXPROP_ADD},
-
-    {&quot;&lt;&lt;&lt;&quot;, 90, 3, JIM_EXPROP_ROTL},
-    {&quot;&gt;&gt;&gt;&quot;, 90, 3, JIM_EXPROP_ROTR},
-    {&quot;&lt;&lt;&quot;, 90, 2, JIM_EXPROP_LSHIFT},
-    {&quot;&gt;&gt;&quot;, 90, 2, JIM_EXPROP_RSHIFT},
-
-    {&quot;&lt;&quot;,  80, 2, JIM_EXPROP_LT},
-    {&quot;&gt;&quot;,  80, 2, JIM_EXPROP_GT},
-    {&quot;&lt;=&quot;, 80, 2, JIM_EXPROP_LTE},
-    {&quot;&gt;=&quot;, 80, 2, JIM_EXPROP_GTE},
-
-    {&quot;==&quot;, 70, 2, JIM_EXPROP_NUMEQ},
-    {&quot;!=&quot;, 70, 2, JIM_EXPROP_NUMNE},
-
-    {&quot;eq&quot;, 60, 2, JIM_EXPROP_STREQ},
-    {&quot;ne&quot;, 60, 2, JIM_EXPROP_STRNE},
-
-    {&quot;&amp;&quot;, 50, 2, JIM_EXPROP_BITAND},
-    {&quot;^&quot;, 49, 2, JIM_EXPROP_BITXOR},
-    {&quot;|&quot;, 48, 2, JIM_EXPROP_BITOR},
-
-    {&quot;&amp;&amp;&quot;, 10, 2, JIM_EXPROP_LOGICAND},
-    {&quot;||&quot;, 10, 2, JIM_EXPROP_LOGICOR},
-
-    {&quot;?&quot;, 5, 3, JIM_EXPROP_TERNARY},
-    /* private operators */
-    {NULL, 10, 2, JIM_EXPROP_LOGICAND_LEFT},
-    {NULL, 10, 1, JIM_EXPROP_LOGICAND_RIGHT},
-    {NULL, 10, 2, JIM_EXPROP_LOGICOR_LEFT},
-    {NULL, 10, 1, JIM_EXPROP_LOGICOR_RIGHT},
-};
-
-#define JIM_EXPR_OPERATORS_NUM \
-    (sizeof(Jim_ExprOperators)/sizeof(struct Jim_ExprOperator))
-
-int JimParseExpression(struct JimParserCtx *pc)
-{
-    /* Discard spaces and quoted newline */
-    while (*(pc-&gt;p) == ' ' ||
-          *(pc-&gt;p) == '\t' ||
-          *(pc-&gt;p) == '\r' ||
-          *(pc-&gt;p) == '\n' ||
-            (*(pc-&gt;p) == '\\' &amp;&amp; *(pc-&gt;p + 1) == '\n')) {
-        pc-&gt;p++; pc-&gt;len--;
-    }
-
-    if (pc-&gt;len == 0) {
-        pc-&gt;tstart = pc-&gt;tend = pc-&gt;p;
-        pc-&gt;tline = pc-&gt;linenr;
-        pc-&gt;tt = JIM_TT_EOL;
-        pc-&gt;eof = 1;
-        return JIM_OK;
-    }
-    switch (*(pc-&gt;p)) {
-    case '(':
-        pc-&gt;tstart = pc-&gt;tend = pc-&gt;p;
-        pc-&gt;tline = pc-&gt;linenr;
-        pc-&gt;tt = JIM_TT_SUBEXPR_START;
-        pc-&gt;p++; pc-&gt;len--;
-        break;
-    case ')':
-        pc-&gt;tstart = pc-&gt;tend = pc-&gt;p;
-        pc-&gt;tline = pc-&gt;linenr;
-        pc-&gt;tt = JIM_TT_SUBEXPR_END;
-        pc-&gt;p++; pc-&gt;len--;
-        break;
-    case '[':
-        return JimParseCmd(pc);
-        break;
-    case '$':
-        if (JimParseVar(pc) == JIM_ERR)
-            return JimParseExprOperator(pc);
-        else
-            return JIM_OK;
-        break;
-    case '-':
-        if ((pc-&gt;tt == JIM_TT_NONE || pc-&gt;tt == JIM_TT_EXPR_OPERATOR) &amp;&amp;
-            isdigit((int)*(pc-&gt;p + 1)))
-            return JimParseExprNumber(pc);
-        else
-            return JimParseExprOperator(pc);
-        break;
-    case '0': case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8': case '9': case '.':
-        return JimParseExprNumber(pc);
-        break;
-    case '&quot;':
-    case '{':
-        /* Here it's possible to reuse the List String parsing. */
-        pc-&gt;tt = JIM_TT_NONE; /* Make sure it's sensed as a new word. */
-        return JimParseListStr(pc);
-        break;
-    case 'N': case 'I':
-    case 'n': case 'i':
-        if (JimParseExprIrrational(pc) == JIM_ERR)
-            return JimParseExprOperator(pc);
-        break;
-    default:
-        return JimParseExprOperator(pc);
-        break;
-    }
-    return JIM_OK;
-}
-
-int JimParseExprNumber(struct JimParserCtx *pc)
-{
-    int allowdot = 1;
-    int allowhex = 0;
-
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tline = pc-&gt;linenr;
-    if (*pc-&gt;p == '-') {
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    while (isdigit((int)*pc-&gt;p)
-          || (allowhex &amp;&amp; isxdigit((int)*pc-&gt;p))
-          || (allowdot &amp;&amp; *pc-&gt;p == '.')
-          || (pc-&gt;p-pc-&gt;tstart == 1 &amp;&amp; *pc-&gt;tstart == '0' &amp;&amp;
-              (*pc-&gt;p == 'x' || *pc-&gt;p == 'X'))
-)
-    {
-        if ((*pc-&gt;p == 'x') || (*pc-&gt;p == 'X')) {
-            allowhex = 1;
-            allowdot = 0;
-		}
-        if (*pc-&gt;p == '.')
-            allowdot = 0;
-        pc-&gt;p++; pc-&gt;len--;
-        if (!allowdot &amp;&amp; *pc-&gt;p == 'e' &amp;&amp; *(pc-&gt;p + 1) == '-') {
-            pc-&gt;p += 2; pc-&gt;len -= 2;
-        }
-    }
-    pc-&gt;tend = pc-&gt;p-1;
-    pc-&gt;tt = JIM_TT_EXPR_NUMBER;
-    return JIM_OK;
-}
-
-int JimParseExprIrrational(struct JimParserCtx *pc)
-{
-    const char *Tokens[] = {&quot;NaN&quot;, &quot;nan&quot;, &quot;NAN&quot;, &quot;Inf&quot;, &quot;inf&quot;, &quot;INF&quot;, NULL};
-    const char **token;
-    for (token = Tokens; *token != NULL; token++) {
-        int len = strlen(*token);
-        if (strncmp(*token, pc-&gt;p, len) == 0) {
-            pc-&gt;tstart = pc-&gt;p;
-            pc-&gt;tend = pc-&gt;p + len - 1;
-            pc-&gt;p += len; pc-&gt;len -= len;
-            pc-&gt;tline = pc-&gt;linenr;
-            pc-&gt;tt = JIM_TT_EXPR_NUMBER;
-            return JIM_OK;
-        }
-    }
-    return JIM_ERR;
-}
-
-int JimParseExprOperator(struct JimParserCtx *pc)
-{
-    int i;
-    int bestIdx = -1, bestLen = 0;
-
-    /* Try to get the longest match. */
-    for (i = 0; i &lt; (signed)JIM_EXPR_OPERATORS_NUM; i++) {
-        const char *opname;
-        int oplen;
-
-        opname = Jim_ExprOperators[i].name;
-        if (opname == NULL) continue;
-        oplen = strlen(opname);
-
-        if (strncmp(opname, pc-&gt;p, oplen) == 0 &amp;&amp; oplen &gt; bestLen) {
-            bestIdx = i;
-            bestLen = oplen;
-        }
-    }
-    if (bestIdx == -1) return JIM_ERR;
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tend = pc-&gt;p + bestLen - 1;
-    pc-&gt;p += bestLen; pc-&gt;len -= bestLen;
-    pc-&gt;tline = pc-&gt;linenr;
-    pc-&gt;tt = JIM_TT_EXPR_OPERATOR;
-    return JIM_OK;
-}
-
-struct Jim_ExprOperator *JimExprOperatorInfo(const char *opname)
-{
-    int i;
-    for (i = 0; i &lt; (signed)JIM_EXPR_OPERATORS_NUM; i++)
-        if (Jim_ExprOperators[i].name &amp;&amp;
-            strcmp(opname, Jim_ExprOperators[i].name) == 0)
-            return &amp;Jim_ExprOperators[i];
-    return NULL;
-}
-
-struct Jim_ExprOperator *JimExprOperatorInfoByOpcode(int opcode)
-{
-    int i;
-    for (i = 0; i &lt; (signed)JIM_EXPR_OPERATORS_NUM; i++)
-        if (Jim_ExprOperators[i].opcode == opcode)
-            return &amp;Jim_ExprOperators[i];
-    return NULL;
-}
-
-/* -----------------------------------------------------------------------------
- * Expression Object
- * ---------------------------------------------------------------------------*/
-static void FreeExprInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupExprInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static int SetExprFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr);
-
-static Jim_ObjType exprObjType = {
-    &quot;expression&quot;,
-    FreeExprInternalRep,
-    DupExprInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* Expr bytecode structure */
-typedef struct ExprByteCode {
-    int *opcode;        /* Integer array of opcodes. */
-    Jim_Obj **obj;      /* Array of associated Jim Objects. */
-    int len;            /* Bytecode length */
-    int inUse;          /* Used for sharing. */
-} ExprByteCode;
-
-void FreeExprInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    int i;
-    ExprByteCode *expr = (void*) objPtr-&gt;internalRep.ptr;
-
-    expr-&gt;inUse--;
-    if (expr-&gt;inUse != 0) return;
-    for (i = 0; i &lt; expr-&gt;len; i++)
-        Jim_DecrRefCount(interp, expr-&gt;obj[i]);
-    Jim_Free(expr-&gt;opcode);
-    Jim_Free(expr-&gt;obj);
-    Jim_Free(expr);
-}
-
-void DupExprInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(srcPtr);
-
-    /* Just returns an simple string. */
-    dupPtr-&gt;typePtr = NULL;
-}
-
-/* Add a new instruction to an expression bytecode structure. */
-static void ExprObjAddInstr(Jim_Interp *interp, ExprByteCode *expr,
-        int opcode, char *str, int len)
-{
-    expr-&gt;opcode = Jim_Realloc(expr-&gt;opcode, sizeof(int)*(expr-&gt;len + 1));
-    expr-&gt;obj = Jim_Realloc(expr-&gt;obj, sizeof(Jim_Obj*)*(expr-&gt;len + 1));
-    expr-&gt;opcode[expr-&gt;len] = opcode;
-    expr-&gt;obj[expr-&gt;len] = Jim_NewStringObjNoAlloc(interp, str, len);
-    Jim_IncrRefCount(expr-&gt;obj[expr-&gt;len]);
-    expr-&gt;len++;
-}
-
-/* Check if an expr program looks correct. */
-static int ExprCheckCorrectness(ExprByteCode *expr)
-{
-    int i;
-    int stacklen = 0;
-
-    /* Try to check if there are stack underflows,
-     * and make sure at the end of the program there is
-     * a single result on the stack. */
-    for (i = 0; i &lt; expr-&gt;len; i++) {
-        switch (expr-&gt;opcode[i]) {
-        case JIM_EXPROP_NUMBER:
-        case JIM_EXPROP_STRING:
-        case JIM_EXPROP_SUBST:
-        case JIM_EXPROP_VARIABLE:
-        case JIM_EXPROP_DICTSUGAR:
-        case JIM_EXPROP_COMMAND:
-            stacklen++;
-            break;
-        case JIM_EXPROP_NOT:
-        case JIM_EXPROP_BITNOT:
-        case JIM_EXPROP_UNARYMINUS:
-        case JIM_EXPROP_UNARYPLUS:
-            /* Unary operations */
-            if (stacklen &lt; 1) return JIM_ERR;
-            break;
-        case JIM_EXPROP_ADD:
-        case JIM_EXPROP_SUB:
-        case JIM_EXPROP_MUL:
-        case JIM_EXPROP_DIV:
-        case JIM_EXPROP_MOD:
-        case JIM_EXPROP_LT:
-        case JIM_EXPROP_GT:
-        case JIM_EXPROP_LTE:
-        case JIM_EXPROP_GTE:
-        case JIM_EXPROP_ROTL:
-        case JIM_EXPROP_ROTR:
-        case JIM_EXPROP_LSHIFT:
-        case JIM_EXPROP_RSHIFT:
-        case JIM_EXPROP_NUMEQ:
-        case JIM_EXPROP_NUMNE:
-        case JIM_EXPROP_STREQ:
-        case JIM_EXPROP_STRNE:
-        case JIM_EXPROP_BITAND:
-        case JIM_EXPROP_BITXOR:
-        case JIM_EXPROP_BITOR:
-        case JIM_EXPROP_LOGICAND:
-        case JIM_EXPROP_LOGICOR:
-        case JIM_EXPROP_POW:
-            /* binary operations */
-            if (stacklen &lt; 2) return JIM_ERR;
-            stacklen--;
-            break;
-        default:
-            Jim_Panic(NULL,&quot;Default opcode reached ExprCheckCorrectness&quot;);
-            break;
-        }
-    }
-    if (stacklen != 1) return JIM_ERR;
-    return JIM_OK;
-}
-
-static void ExprShareLiterals(Jim_Interp *interp, ExprByteCode *expr,
-        ScriptObj *topLevelScript)
-{
-    int i;
-
-    return;
-    for (i = 0; i &lt; expr-&gt;len; i++) {
-        Jim_Obj *foundObjPtr;
-
-        if (expr-&gt;obj[i] == NULL) continue;
-        foundObjPtr = ScriptSearchLiteral(interp, topLevelScript,
-                NULL, expr-&gt;obj[i]);
-        if (foundObjPtr != NULL) {
-            Jim_IncrRefCount(foundObjPtr);
-            Jim_DecrRefCount(interp, expr-&gt;obj[i]);
-            expr-&gt;obj[i] = foundObjPtr;
-        }
-    }
-}
-
-/* This procedure converts every occurrence of || and &amp;&amp; opereators
- * in lazy unary versions.
- *
- * a b || is converted into:
- *
- * a &lt;offset&gt; |L b |R
- *
- * a b &amp;&amp; is converted into:
- *
- * a &lt;offset&gt; &amp;L b &amp;R
- *
- * &quot;|L&quot; checks if 'a' is true:
- *   1) if it is true pushes 1 and skips &lt;offset&gt; istructions to reach
- *      the opcode just after |R.
- *   2) if it is false does nothing.
- * &quot;|R&quot; checks if 'b' is true:
- *   1) if it is true pushes 1, otherwise pushes 0.
- *
- * &quot;&amp;L&quot; checks if 'a' is true:
- *   1) if it is true does nothing.
- *   2) If it is false pushes 0 and skips &lt;offset&gt; istructions to reach
- *      the opcode just after &amp;R
- * &quot;&amp;R&quot; checks if 'a' is true:
- *      if it is true pushes 1, otherwise pushes 0.
- */
-static void ExprMakeLazy(Jim_Interp *interp, ExprByteCode *expr)
-{
-    while (1) {
-        int index_t = -1, leftindex, arity, i, offset;
-        Jim_ExprOperator *op;
-
-        /* Search for || or &amp;&amp; */
-        for (i = 0; i &lt; expr-&gt;len; i++) {
-            if (expr-&gt;opcode[i] == JIM_EXPROP_LOGICAND ||
-                expr-&gt;opcode[i] == JIM_EXPROP_LOGICOR) {
-                index_t = i;
-                break;
-            }
-        }
-        if (index_t == -1) return;
-        /* Search for the end of the first operator */
-        leftindex = index_t-1;
-        arity = 1;
-        while (arity) {
-            switch (expr-&gt;opcode[leftindex]) {
-            case JIM_EXPROP_NUMBER:
-            case JIM_EXPROP_COMMAND:
-            case JIM_EXPROP_VARIABLE:
-            case JIM_EXPROP_DICTSUGAR:
-            case JIM_EXPROP_SUBST:
-            case JIM_EXPROP_STRING:
-                break;
-            default:
-                op = JimExprOperatorInfoByOpcode(expr-&gt;opcode[leftindex]);
-                if (op == NULL) {
-                    Jim_Panic(interp,&quot;Default reached in ExprMakeLazy()&quot;);
-                }
-                arity += op-&gt;arity;
-                break;
-            }
-            arity--;
-            leftindex--;
-        }
-        leftindex++;
-        expr-&gt;opcode = Jim_Realloc(expr-&gt;opcode, sizeof(int)*(expr-&gt;len + 2));
-        expr-&gt;obj = Jim_Realloc(expr-&gt;obj, sizeof(Jim_Obj*)*(expr-&gt;len + 2));
-        memmove(&amp;expr-&gt;opcode[leftindex + 2], &amp;expr-&gt;opcode[leftindex],
-                sizeof(int)*(expr-&gt;len-leftindex));
-        memmove(&amp;expr-&gt;obj[leftindex + 2], &amp;expr-&gt;obj[leftindex],
-                sizeof(Jim_Obj*)*(expr-&gt;len-leftindex));
-        expr-&gt;len += 2;
-        index_t += 2;
-        offset = (index_t-leftindex)-1;
-        Jim_DecrRefCount(interp, expr-&gt;obj[index_t]);
-        if (expr-&gt;opcode[index_t] == JIM_EXPROP_LOGICAND) {
-            expr-&gt;opcode[leftindex + 1] = JIM_EXPROP_LOGICAND_LEFT;
-            expr-&gt;opcode[index_t] = JIM_EXPROP_LOGICAND_RIGHT;
-            expr-&gt;obj[leftindex + 1] = Jim_NewStringObj(interp, &quot;&amp;L&quot;, -1);
-            expr-&gt;obj[index_t] = Jim_NewStringObj(interp, &quot;&amp;R&quot;, -1);
-        } else {
-            expr-&gt;opcode[leftindex + 1] = JIM_EXPROP_LOGICOR_LEFT;
-            expr-&gt;opcode[index_t] = JIM_EXPROP_LOGICOR_RIGHT;
-            expr-&gt;obj[leftindex + 1] = Jim_NewStringObj(interp, &quot;|L&quot;, -1);
-            expr-&gt;obj[index_t] = Jim_NewStringObj(interp, &quot;|R&quot;, -1);
-        }
-        expr-&gt;opcode[leftindex] = JIM_EXPROP_NUMBER;
-        expr-&gt;obj[leftindex] = Jim_NewIntObj(interp, offset);
-        Jim_IncrRefCount(expr-&gt;obj[index_t]);
-        Jim_IncrRefCount(expr-&gt;obj[leftindex]);
-        Jim_IncrRefCount(expr-&gt;obj[leftindex + 1]);
-    }
-}
-
-/* This method takes the string representation of an expression
- * and generates a program for the Expr's stack-based VM. */
-int SetExprFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr)
-{
-    int exprTextLen;
-    const char *exprText = Jim_GetString(objPtr, &amp;exprTextLen);
-    struct JimParserCtx parser;
-    int i, shareLiterals;
-    ExprByteCode *expr = Jim_Alloc(sizeof(*expr));
-    Jim_Stack stack;
-    Jim_ExprOperator *op;
-
-    /* Perform literal sharing with the current procedure
-     * running only if this expression appears to be not generated
-     * at runtime. */
-    shareLiterals = objPtr-&gt;typePtr == &sourceObjType;
-
-    expr-&gt;opcode = NULL;
-    expr-&gt;obj = NULL;
-    expr-&gt;len = 0;
-    expr-&gt;inUse = 1;
-
-    Jim_InitStack(&amp;stack);
-    JimParserInit(&amp;parser, exprText, exprTextLen, 1);
-    while (!JimParserEof(&amp;parser)) {
-        char *token;
-        int len, type;
-
-        if (JimParseExpression(&amp;parser) != JIM_OK) {
-            Jim_SetResultString(interp, &quot;Syntax error in expression&quot;, -1);
-            goto err;
-        }
-        token = JimParserGetToken(&amp;parser, &amp;len, &amp;type, NULL);
-        if (type == JIM_TT_EOL) {
-            Jim_Free(token);
-            break;
-        }
-        switch (type) {
-        case JIM_TT_STR:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_STRING, token, len);
-            break;
-        case JIM_TT_ESC:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_SUBST, token, len);
-            break;
-        case JIM_TT_VAR:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_VARIABLE, token, len);
-            break;
-        case JIM_TT_DICTSUGAR:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_DICTSUGAR, token, len);
-            break;
-        case JIM_TT_CMD:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_COMMAND, token, len);
-            break;
-        case JIM_TT_EXPR_NUMBER:
-            ExprObjAddInstr(interp, expr, JIM_EXPROP_NUMBER, token, len);
-            break;
-        case JIM_TT_EXPR_OPERATOR:
-            op = JimExprOperatorInfo(token);
-            while (1) {
-                Jim_ExprOperator *stackTopOp;
-
-                if (Jim_StackPeek(&amp;stack) != NULL) {
-                    stackTopOp = JimExprOperatorInfo(Jim_StackPeek(&amp;stack));
-                } else {
-                    stackTopOp = NULL;
-                }
-                if (Jim_StackLen(&amp;stack) &amp;&amp; op-&gt;arity != 1 &amp;&amp;
-                    stackTopOp &amp;&amp; stackTopOp-&gt;precedence &gt;= op-&gt;precedence)
-                {
-                    ExprObjAddInstr(interp, expr, stackTopOp-&gt;opcode,
-                        Jim_StackPeek(&amp;stack), -1);
-                    Jim_StackPop(&amp;stack);
-                } else {
-                    break;
-                }
-            }
-            Jim_StackPush(&amp;stack, token);
-            break;
-        case JIM_TT_SUBEXPR_START:
-            Jim_StackPush(&amp;stack, Jim_StrDup(&quot;(&quot;));
-            Jim_Free(token);
-            break;
-        case JIM_TT_SUBEXPR_END:
-            {
-                int found = 0;
-                while (Jim_StackLen(&amp;stack)) {
-                    char *opstr = Jim_StackPop(&amp;stack);
-                    if (!strcmp(opstr, &quot;(&quot;)) {
-                        Jim_Free(opstr);
-                        found = 1;
-                        break;
-                    }
-                    op = JimExprOperatorInfo(opstr);
-                    ExprObjAddInstr(interp, expr, op-&gt;opcode, opstr, -1);
-                }
-                if (!found) {
-                    Jim_SetResultString(interp,
-                        &quot;Unexpected close parenthesis&quot;, -1);
-                    goto err;
-                }
-            }
-            Jim_Free(token);
-            break;
-        default:
-            Jim_Panic(interp,&quot;Default reached in SetExprFromAny()&quot;);
-            break;
-        }
-    }
-    while (Jim_StackLen(&amp;stack)) {
-        char *opstr = Jim_StackPop(&amp;stack);
-        op = JimExprOperatorInfo(opstr);
-        if (op == NULL &amp;&amp; !strcmp(opstr, &quot;(&quot;)) {
-            Jim_Free(opstr);
-            Jim_SetResultString(interp, &quot;Missing close parenthesis&quot;, -1);
-            goto err;
-        }
-        ExprObjAddInstr(interp, expr, op-&gt;opcode, opstr, -1);
-    }
-    /* Check program correctness. */
-    if (ExprCheckCorrectness(expr) != JIM_OK) {
-        Jim_SetResultString(interp, &quot;Invalid expression&quot;, -1);
-        goto err;
-    }
-
-    /* Free the stack used for the compilation. */
-    Jim_FreeStackElements(&amp;stack, Jim_Free);
-    Jim_FreeStack(&amp;stack);
-
-    /* Convert || and &amp;&amp; operators in unary |L |R and &amp;L &amp;R for lazyness */
-    ExprMakeLazy(interp, expr);
-
-    /* Perform literal sharing */
-    if (shareLiterals &amp;&amp; interp-&gt;framePtr-&gt;procBodyObjPtr) {
-        Jim_Obj *bodyObjPtr = interp-&gt;framePtr-&gt;procBodyObjPtr;
-        if (bodyObjPtr-&gt;typePtr == &amp;scriptObjType) {
-            ScriptObj *bodyScript = bodyObjPtr-&gt;internalRep.ptr;
-            ExprShareLiterals(interp, expr, bodyScript);
-        }
-    }
-
-    /* Free the old internal rep and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    Jim_SetIntRepPtr(objPtr, expr);
-    objPtr-&gt;typePtr = &exprObjType;
-    return JIM_OK;
-
-err:    /* we jump here on syntax/compile errors. */
-    Jim_FreeStackElements(&amp;stack, Jim_Free);
-    Jim_FreeStack(&amp;stack);
-    Jim_Free(expr-&gt;opcode);
-    for (i = 0; i &lt; expr-&gt;len; i++) {
-        Jim_DecrRefCount(interp,expr-&gt;obj[i]);
-    }
-    Jim_Free(expr-&gt;obj);
-    Jim_Free(expr);
-    return JIM_ERR;
-}
-
-ExprByteCode *Jim_GetExpression(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    if (objPtr-&gt;typePtr != &amp;exprObjType) {
-        if (SetExprFromAny(interp, objPtr) != JIM_OK)
-            return NULL;
-    }
-    return (ExprByteCode*) Jim_GetIntRepPtr(objPtr);
-}
-
-/* -----------------------------------------------------------------------------
- * Expressions evaluation.
- * Jim uses a specialized stack-based virtual machine for expressions,
- * that takes advantage of the fact that expr's operators
- * can't be redefined.
- *
- * Jim_EvalExpression() uses the bytecode compiled by
- * SetExprFromAny() method of the &quot;expression&quot; object.
- *
- * On success a Tcl Object containing the result of the evaluation
- * is stored into expResultPtrPtr (having refcount of 1), and JIM_OK is
- * returned.
- * On error the function returns a retcode != to JIM_OK and set a suitable
- * error on the interp.
- * ---------------------------------------------------------------------------*/
-#define JIM_EE_STATICSTACK_LEN 10
-
-int Jim_EvalExpression(Jim_Interp *interp, Jim_Obj *exprObjPtr,
-        Jim_Obj **exprResultPtrPtr)
-{
-    ExprByteCode *expr;
-    Jim_Obj **stack, *staticStack[JIM_EE_STATICSTACK_LEN];
-    int stacklen = 0, i, error = 0, errRetCode = JIM_ERR;
-
-    Jim_IncrRefCount(exprObjPtr);
-    expr = Jim_GetExpression(interp, exprObjPtr);
-    if (!expr) {
-        Jim_DecrRefCount(interp, exprObjPtr);
-        return JIM_ERR; /* error in expression. */
-    }
-    /* In order to avoid that the internal repr gets freed due to
-     * shimmering of the exprObjPtr's object, we make the internal rep
-     * shared. */
-    expr-&gt;inUse++;
-
-    /* The stack-based expr VM itself */
-
-    /* Stack allocation. Expr programs have the feature that
-     * a program of length N can't require a stack longer than
-     * N. */
-    if (expr-&gt;len &gt; JIM_EE_STATICSTACK_LEN)
-        stack = Jim_Alloc(sizeof(Jim_Obj*)*expr-&gt;len);
-    else
-        stack = staticStack;
-
-    /* Execute every istruction */
-    for (i = 0; i &lt; expr-&gt;len; i++) {
-        Jim_Obj *A, *B, *objPtr;
-        jim_wide wA, wB, wC;
-        double dA, dB, dC;
-        const char *sA, *sB;
-        int Alen, Blen, retcode;
-        int opcode = expr-&gt;opcode[i];
-
-        if (opcode == JIM_EXPROP_NUMBER || opcode == JIM_EXPROP_STRING) {
-            stack[stacklen++] = expr-&gt;obj[i];
-            Jim_IncrRefCount(expr-&gt;obj[i]);
-        } else if (opcode == JIM_EXPROP_VARIABLE) {
-            objPtr = Jim_GetVariable(interp, expr-&gt;obj[i], JIM_ERRMSG);
-            if (objPtr == NULL) {
-                error = 1;
-                goto err;
-            }
-            stack[stacklen++] = objPtr;
-            Jim_IncrRefCount(objPtr);
-        } else if (opcode == JIM_EXPROP_SUBST) {
-            if ((retcode = Jim_SubstObj(interp, expr-&gt;obj[i],
-                        &amp;objPtr, JIM_NONE)) != JIM_OK)
-            {
-                error = 1;
-                errRetCode = retcode;
-                goto err;
-            }
-            stack[stacklen++] = objPtr;
-            Jim_IncrRefCount(objPtr);
-        } else if (opcode == JIM_EXPROP_DICTSUGAR) {
-            objPtr = Jim_ExpandDictSugar(interp, expr-&gt;obj[i]);
-            if (objPtr == NULL) {
-                error = 1;
-                goto err;
-            }
-            stack[stacklen++] = objPtr;
-            Jim_IncrRefCount(objPtr);
-        } else if (opcode == JIM_EXPROP_COMMAND) {
-            if ((retcode = Jim_EvalObj(interp, expr-&gt;obj[i])) != JIM_OK) {
-                error = 1;
-                errRetCode = retcode;
-                goto err;
-            }
-            stack[stacklen++] = interp-&gt;result;
-            Jim_IncrRefCount(interp-&gt;result);
-        } else if (opcode &gt;= JIM_EXPROP_BINARY_NUM_FIRST &amp;&amp;
-                   opcode &lt;= JIM_EXPROP_BINARY_NUM_LAST)
-        {
-            /* Note that there isn't to increment the
-             * refcount of objects. the references are moved
-             * from stack to A and B. */
-            B = stack[--stacklen];
-            A = stack[--stacklen];
-
-            /* --- Integer --- */
-            if ((A-&gt;typePtr == &amp;doubleObjType &amp;&amp; !A-&gt;bytes) ||
-                (B-&gt;typePtr == &amp;doubleObjType &amp;&amp; !B-&gt;bytes) ||
-                JimGetWideNoErr(interp, A, &amp;wA) != JIM_OK ||
-                JimGetWideNoErr(interp, B, &amp;wB) != JIM_OK) {
-                goto trydouble;
-            }
-            Jim_DecrRefCount(interp, A);
-            Jim_DecrRefCount(interp, B);
-            switch (expr-&gt;opcode[i]) {
-            case JIM_EXPROP_ADD: wC = wA + wB; break;
-            case JIM_EXPROP_SUB: wC = wA-wB; break;
-            case JIM_EXPROP_MUL: wC = wA*wB; break;
-            case JIM_EXPROP_LT: wC = wA &lt; wB; break;
-            case JIM_EXPROP_GT: wC = wA &gt; wB; break;
-            case JIM_EXPROP_LTE: wC = wA &lt;= wB; break;
-            case JIM_EXPROP_GTE: wC = wA &gt;= wB; break;
-            case JIM_EXPROP_LSHIFT: wC = wA &lt;&lt; wB; break;
-            case JIM_EXPROP_RSHIFT: wC = wA &gt;&gt; wB; break;
-            case JIM_EXPROP_NUMEQ: wC = wA == wB; break;
-            case JIM_EXPROP_NUMNE: wC = wA != wB; break;
-            case JIM_EXPROP_BITAND: wC = wA&wB; break;
-            case JIM_EXPROP_BITXOR: wC = wA^wB; break;
-            case JIM_EXPROP_BITOR: wC = wA | wB; break;
-            case JIM_EXPROP_POW: wC = JimPowWide(wA,wB); break;
-            case JIM_EXPROP_LOGICAND_LEFT:
-                if (wA == 0) {
-                    i += (int)wB;
-                    wC = 0;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_LOGICOR_LEFT:
-                if (wA != 0) {
-                    i += (int)wB;
-                    wC = 1;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_DIV:
-                if (wB == 0) goto divbyzero;
-                wC = wA/wB;
-                break;
-            case JIM_EXPROP_MOD:
-                if (wB == 0) goto divbyzero;
-                wC = wA%wB;
-                break;
-            case JIM_EXPROP_ROTL: {
-                /* uint32_t would be better. But not everyone has inttypes.h?*/
-                unsigned long uA = (unsigned long)wA;
-#ifdef _MSC_VER
-                wC = _rotl(uA,(unsigned long)wB);
-#else
-                const unsigned int S = sizeof(unsigned long) * 8;
-                wC = (unsigned long)((uA &lt;&lt; wB) | (uA &gt;&gt; (S-wB)));
-#endif
-                break;
-            }
-            case JIM_EXPROP_ROTR: {
-                unsigned long uA = (unsigned long)wA;
-#ifdef _MSC_VER
-                wC = _rotr(uA,(unsigned long)wB);
-#else
-                const unsigned int S = sizeof(unsigned long) * 8;
-                wC = (unsigned long)((uA &gt;&gt; wB) | (uA &lt;&lt; (S-wB)));
-#endif
-                break;
-            }
-
-            default:
-                wC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewIntObj(interp, wC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-            continue;
-trydouble:
-            /* --- Double --- */
-            if (Jim_GetDouble(interp, A, &amp;dA) != JIM_OK ||
-                Jim_GetDouble(interp, B, &amp;dB) != JIM_OK) {
-
-                /* Hmmm! For compatibility, maybe convert != and == into ne and eq */
-                if (expr-&gt;opcode[i] == JIM_EXPROP_NUMNE) {
-                    opcode = JIM_EXPROP_STRNE;
-                    goto retry_as_string;
-                }
-                else if (expr-&gt;opcode[i] == JIM_EXPROP_NUMEQ) {
-                    opcode = JIM_EXPROP_STREQ;
-                    goto retry_as_string;
-                }
-                Jim_DecrRefCount(interp, A);
-                Jim_DecrRefCount(interp, B);
-                error = 1;
-                goto err;
-            }
-            Jim_DecrRefCount(interp, A);
-            Jim_DecrRefCount(interp, B);
-            switch (expr-&gt;opcode[i]) {
-            case JIM_EXPROP_ROTL:
-            case JIM_EXPROP_ROTR:
-            case JIM_EXPROP_LSHIFT:
-            case JIM_EXPROP_RSHIFT:
-            case JIM_EXPROP_BITAND:
-            case JIM_EXPROP_BITXOR:
-            case JIM_EXPROP_BITOR:
-            case JIM_EXPROP_MOD:
-            case JIM_EXPROP_POW:
-                Jim_SetResultString(interp,
-                    &quot;Got floating-point value where integer was expected&quot;, -1);
-                error = 1;
-                goto err;
-            case JIM_EXPROP_ADD: dC = dA + dB; break;
-            case JIM_EXPROP_SUB: dC = dA-dB; break;
-            case JIM_EXPROP_MUL: dC = dA*dB; break;
-            case JIM_EXPROP_LT: dC = dA &lt; dB; break;
-            case JIM_EXPROP_GT: dC = dA &gt; dB; break;
-            case JIM_EXPROP_LTE: dC = dA &lt;= dB; break;
-            case JIM_EXPROP_GTE: dC = dA &gt;= dB; break;
-	    /* FIXME comparing floats for equality/inequality is bad juju */
-            case JIM_EXPROP_NUMEQ: dC = dA == dB; break;
-            case JIM_EXPROP_NUMNE: dC = dA != dB; break;
-            case JIM_EXPROP_LOGICAND_LEFT:
-                if (dA == 0) {
-                    i += (int)dB;
-                    dC = 0;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_LOGICOR_LEFT:
-                if (dA != 0) {
-                    i += (int)dB;
-                    dC = 1;
-                } else {
-                    continue;
-                }
-                break;
-            case JIM_EXPROP_DIV:
-                if (dB == 0) goto divbyzero;
-                dC = dA/dB;
-                break;
-            default:
-                dC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewDoubleObj(interp, dC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-        } else if (opcode == JIM_EXPROP_STREQ || opcode == JIM_EXPROP_STRNE) {
-            B = stack[--stacklen];
-            A = stack[--stacklen];
-retry_as_string:
-            sA = Jim_GetString(A, &amp;Alen);
-            sB = Jim_GetString(B, &amp;Blen);
-            switch (opcode) {
-            case JIM_EXPROP_STREQ:
-                if (Alen == Blen &amp;&amp; memcmp(sA, sB, Alen) ==0)
-                    wC = 1;
-                else
-                    wC = 0;
-                break;
-            case JIM_EXPROP_STRNE:
-                if (Alen != Blen || memcmp(sA, sB, Alen) != 0)
-                    wC = 1;
-                else
-                    wC = 0;
-                break;
-            default:
-                wC = 0; /* avoid gcc warning */
-                break;
-            }
-            Jim_DecrRefCount(interp, A);
-            Jim_DecrRefCount(interp, B);
-            stack[stacklen] = Jim_NewIntObj(interp, wC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-        } else if (opcode == JIM_EXPROP_NOT ||
-                   opcode == JIM_EXPROP_BITNOT ||
-                   opcode == JIM_EXPROP_LOGICAND_RIGHT ||
-                   opcode == JIM_EXPROP_LOGICOR_RIGHT) {
-            /* Note that there isn't to increment the
-             * refcount of objects. the references are moved
-             * from stack to A and B. */
-            A = stack[--stacklen];
-
-            /* --- Integer --- */
-            if ((A-&gt;typePtr == &amp;doubleObjType &amp;&amp; !A-&gt;bytes) ||
-                JimGetWideNoErr(interp, A, &amp;wA) != JIM_OK) {
-                goto trydouble_unary;
-            }
-            Jim_DecrRefCount(interp, A);
-            switch (expr-&gt;opcode[i]) {
-            case JIM_EXPROP_NOT: wC = !wA; break;
-            case JIM_EXPROP_BITNOT: wC = ~wA; break;
-            case JIM_EXPROP_LOGICAND_RIGHT:
-            case JIM_EXPROP_LOGICOR_RIGHT: wC = (wA != 0); break;
-            default:
-                wC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewIntObj(interp, wC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-            continue;
-trydouble_unary:
-            /* --- Double --- */
-            if (Jim_GetDouble(interp, A, &amp;dA) != JIM_OK) {
-                Jim_DecrRefCount(interp, A);
-                error = 1;
-                goto err;
-            }
-            Jim_DecrRefCount(interp, A);
-            switch (expr-&gt;opcode[i]) {
-            case JIM_EXPROP_NOT: dC = !dA; break;
-            case JIM_EXPROP_LOGICAND_RIGHT:
-            case JIM_EXPROP_LOGICOR_RIGHT: dC = (dA != 0); break;
-            case JIM_EXPROP_BITNOT:
-                Jim_SetResultString(interp,
-                    &quot;Got floating-point value where integer was expected&quot;, -1);
-                error = 1;
-                goto err;
-                break;
-            default:
-                dC = 0; /* avoid gcc warning */
-                break;
-            }
-            stack[stacklen] = Jim_NewDoubleObj(interp, dC);
-            Jim_IncrRefCount(stack[stacklen]);
-            stacklen++;
-        } else {
-            Jim_Panic(interp,&quot;Unknown opcode in Jim_EvalExpression&quot;);
-        }
-    }
-err:
-    /* There is no need to decerement the inUse field because
-     * this reference is transfered back into the exprObjPtr. */
-    Jim_FreeIntRep(interp, exprObjPtr);
-    exprObjPtr-&gt;typePtr = &exprObjType;
-    Jim_SetIntRepPtr(exprObjPtr, expr);
-    Jim_DecrRefCount(interp, exprObjPtr);
-    if (!error) {
-        *exprResultPtrPtr = stack[0];
-        Jim_IncrRefCount(stack[0]);
-        errRetCode = JIM_OK;
-    }
-    for (i = 0; i &lt; stacklen; i++) {
-        Jim_DecrRefCount(interp, stack[i]);
-    }
-    if (stack != staticStack)
-        Jim_Free(stack);
-    return errRetCode;
-divbyzero:
-    error = 1;
-    Jim_SetResultString(interp, &quot;Division by zero&quot;, -1);
-    goto err;
-}
-
-int Jim_GetBoolFromExpr(Jim_Interp *interp, Jim_Obj *exprObjPtr, int *boolPtr)
-{
-    int retcode;
-    jim_wide wideValue;
-    double doubleValue;
-    Jim_Obj *exprResultPtr;
-
-    retcode = Jim_EvalExpression(interp, exprObjPtr, &amp;exprResultPtr);
-    if (retcode != JIM_OK)
-        return retcode;
-    if (JimGetWideNoErr(interp, exprResultPtr, &amp;wideValue) != JIM_OK) {
-        if (Jim_GetDouble(interp, exprResultPtr, &amp;doubleValue) != JIM_OK)
-        {
-            Jim_DecrRefCount(interp, exprResultPtr);
-            return JIM_ERR;
-        } else {
-            Jim_DecrRefCount(interp, exprResultPtr);
-            *boolPtr = doubleValue != 0;
-            return JIM_OK;
-        }
-    }
-    Jim_DecrRefCount(interp, exprResultPtr);
-    *boolPtr = wideValue != 0;
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * ScanFormat String Object
- * ---------------------------------------------------------------------------*/
-
-/* This Jim_Obj will held a parsed representation of a format string passed to
- * the Jim_ScanString command. For error diagnostics, the scanformat string has
- * to be parsed in its entirely first and then, if correct, can be used for
- * scanning. To avoid endless re-parsing, the parsed representation will be
- * stored in an internal representation and re-used for performance reason. */
-
-/* A ScanFmtPartDescr will held the information of /one/ part of the whole
- * scanformat string. This part will later be used to extract information
- * out from the string to be parsed by Jim_ScanString */
-
-typedef struct ScanFmtPartDescr {
-    char type;         /* Type of conversion (e.g. c, d, f) */
-    char modifier;     /* Modify type (e.g. l - long, h - short */
-    size_t  width;     /* Maximal width of input to be converted */
-    int  pos;          /* -1 - no assign, 0 - natural pos, &gt;0 - XPG3 pos */
-    char *arg;         /* Specification of a CHARSET conversion */
-    char *prefix;      /* Prefix to be scanned literally before conversion */
-} ScanFmtPartDescr;
-
-/* The ScanFmtStringObj will held the internal representation of a scanformat
- * string parsed and separated in part descriptions. Furthermore it contains
- * the original string representation of the scanformat string to allow for
- * fast update of the Jim_Obj's string representation part.
- *
- * As add-on the internal object representation add some scratch pad area
- * for usage by Jim_ScanString to avoid endless allocating and freeing of
- * memory for purpose of string scanning.
- *
- * The error member points to a static allocated string in case of a mal-
- * formed scanformat string or it contains '0' (NULL) in case of a valid
- * parse representation.
- *
- * The whole memory of the internal representation is allocated as a single
- * area of memory that will be internally separated. So freeing and duplicating
- * of such an object is cheap */
-
-typedef struct ScanFmtStringObj {
-    jim_wide        size;         /* Size of internal repr in bytes */
-    char            *stringRep;   /* Original string representation */
-    size_t          count;        /* Number of ScanFmtPartDescr contained */
-    size_t          convCount;    /* Number of conversions that will assign */
-    size_t          maxPos;       /* Max position index if XPG3 is used */
-    const char      *error;       /* Ptr to error text (NULL if no error */
-    char            *scratch;     /* Some scratch pad used by Jim_ScanString */
-    ScanFmtPartDescr descr[1];    /* The vector of partial descriptions */
-} ScanFmtStringObj;
-
-
-static void FreeScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *objPtr);
-static void DupScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr);
-static void UpdateStringOfScanFmt(Jim_Obj *objPtr);
-
-static Jim_ObjType scanFmtStringObjType = {
-    &quot;scanformatstring&quot;,
-    FreeScanFmtInternalRep,
-    DupScanFmtInternalRep,
-    UpdateStringOfScanFmt,
-    JIM_TYPE_NONE,
-};
-
-void FreeScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    JIM_NOTUSED(interp);
-    Jim_Free((char*)objPtr-&gt;internalRep.ptr);
-    objPtr-&gt;internalRep.ptr = 0;
-}
-
-void DupScanFmtInternalRep(Jim_Interp *interp, Jim_Obj *srcPtr, Jim_Obj *dupPtr)
-{
-    size_t size = (size_t)((ScanFmtStringObj*)srcPtr-&gt;internalRep.ptr)-&gt;size;
-    ScanFmtStringObj *newVec = (ScanFmtStringObj*)Jim_Alloc(size);
-
-    JIM_NOTUSED(interp);
-    memcpy(newVec, srcPtr-&gt;internalRep.ptr, size);
-    dupPtr-&gt;internalRep.ptr = newVec;
-    dupPtr-&gt;typePtr = &scanFmtStringObjType;
-}
-
-void UpdateStringOfScanFmt(Jim_Obj *objPtr)
-{
-    char *bytes = ((ScanFmtStringObj*)objPtr-&gt;internalRep.ptr)-&gt;stringRep;
-
-    objPtr-&gt;bytes = Jim_StrDup(bytes);
-    objPtr-&gt;length = strlen(bytes);
-}
-
-/* SetScanFmtFromAny will parse a given string and create the internal
- * representation of the format specification. In case of an error
- * the error data member of the internal representation will be set
- * to an descriptive error text and the function will be left with
- * JIM_ERR to indicate unsucessful parsing (aka. malformed scanformat
- * specification */
-
-static int SetScanFmtFromAny(Jim_Interp *interp, Jim_Obj *objPtr)
-{
-    ScanFmtStringObj *fmtObj;
-    char *buffer;
-    int maxCount, i, approxSize, lastPos = -1;
-    const char *fmt = objPtr-&gt;bytes;
-    int maxFmtLen = objPtr-&gt;length;
-    const char *fmtEnd = fmt + maxFmtLen;
-    int curr;
-
-    Jim_FreeIntRep(interp, objPtr);
-    /* Count how many conversions could take place maximally */
-    for (i = 0, maxCount = 0; i &lt; maxFmtLen; ++i)
-        if (fmt[i] == '%')
-            ++maxCount;
-    /* Calculate an approximation of the memory necessary */
-    approxSize = sizeof(ScanFmtStringObj)           /* Size of the container */
-        + (maxCount + 1) * sizeof(ScanFmtPartDescr) /* Size of all partials */
-        + maxFmtLen * sizeof(char) + 3 + 1          /* Scratch + &quot;%n&quot; + '\0' */
-        + maxFmtLen * sizeof(char) + 1              /* Original stringrep */
-        + maxFmtLen * sizeof(char)                  /* Arg for CHARSETs */
-        + (maxCount +1) * sizeof(char)              /* '\0' for every partial */
-        + 1;                                        /* safety byte */
-    fmtObj = (ScanFmtStringObj*)Jim_Alloc(approxSize);
-    memset(fmtObj, 0, approxSize);
-    fmtObj-&gt;size = approxSize;
-    fmtObj-&gt;maxPos = 0;
-    fmtObj-&gt;scratch = (char*)&amp;fmtObj-&gt;descr[maxCount + 1];
-    fmtObj-&gt;stringRep = fmtObj-&gt;scratch + maxFmtLen + 3 + 1;
-    memcpy(fmtObj-&gt;stringRep, fmt, maxFmtLen);
-    buffer = fmtObj-&gt;stringRep + maxFmtLen + 1;
-    objPtr-&gt;internalRep.ptr = fmtObj;
-    objPtr-&gt;typePtr = &scanFmtStringObjType;
-    for (i = 0, curr = 0; fmt &lt; fmtEnd; ++fmt) {
-        int width = 0, skip;
-        ScanFmtPartDescr *descr = &amp;fmtObj-&gt;descr[curr];
-        fmtObj-&gt;count++;
-        descr-&gt;width = 0;                   /* Assume width unspecified */
-        /* Overread and store any &quot;literal&quot; prefix */
-        if (*fmt != '%' || fmt[1] == '%') {
-            descr-&gt;type = 0;
-            descr-&gt;prefix = &amp;buffer[i];
-            for (; fmt &lt; fmtEnd; ++fmt) {
-                if (*fmt == '%') {
-                    if (fmt[1] != '%') break;
-                    ++fmt;
-                }
-                buffer[i++] = *fmt;
-            }
-            buffer[i++] = 0;
-        }
-        /* Skip the conversion introducing '%' sign */
-        ++fmt;
-        /* End reached due to non-conversion literal only? */
-        if (fmt &gt;= fmtEnd)
-            goto done;
-        descr-&gt;pos = 0;                     /* Assume &quot;natural&quot; positioning */
-        if (*fmt == '*') {
-            descr-&gt;pos = -1;       /* Okay, conversion will not be assigned */
-            ++fmt;
-        } else
-            fmtObj-&gt;convCount++;    /* Otherwise count as assign-conversion */
-        /* Check if next token is a number (could be width or pos */
-        if (sscanf(fmt, &quot;%d%n&quot;, &amp;width, &amp;skip) == 1) {
-            fmt += skip;
-            /* Was the number a XPG3 position specifier? */
-            if (descr-&gt;pos != -1 &amp;&amp; *fmt == '$') {
-                int prev;
-                ++fmt;
-                descr-&gt;pos = width;
-                width = 0;
-                /* Look if &quot;natural&quot; postioning and XPG3 one was mixed */
-                if ((lastPos == 0 &amp;&amp; descr-&gt;pos &gt; 0)
-                        || (lastPos &gt; 0 &amp;&amp; descr-&gt;pos == 0)) {
-                    fmtObj-&gt;error = &quot;cannot mix \&quot;%\&quot; and \&quot;%n$\&quot; conversion specifiers&quot;;
-                    return JIM_ERR;
-                }
-                /* Look if this position was already used */
-                for (prev = 0; prev &lt; curr; ++prev) {
-                    if (fmtObj-&gt;descr[prev].pos == -1) continue;
-                    if (fmtObj-&gt;descr[prev].pos == descr-&gt;pos) {
-                        fmtObj-&gt;error = &quot;same \&quot;%n$\&quot; conversion specifier &quot;
-                            &quot;used more than once&quot;;
-                        return JIM_ERR;
-                    }
-                }
-                /* Try to find a width after the XPG3 specifier */
-                if (sscanf(fmt, &quot;%d%n&quot;, &amp;width, &amp;skip) == 1) {
-                    descr-&gt;width = width;
-                    fmt += skip;
-                }
-                if (descr-&gt;pos &gt; 0 &amp;&amp; (size_t)descr-&gt;pos &gt; fmtObj-&gt;maxPos)
-                    fmtObj-&gt;maxPos = descr-&gt;pos;
-            } else {
-                /* Number was not a XPG3, so it has to be a width */
-                descr-&gt;width = width;
-            }
-        }
-        /* If positioning mode was undetermined yet, fix this */
-        if (lastPos == -1)
-            lastPos = descr-&gt;pos;
-        /* Handle CHARSET conversion type ... */
-        if (*fmt == '[') {
-            int swapped = 1, beg = i, end, j;
-            descr-&gt;type = '[';
-            descr-&gt;arg = &amp;buffer[i];
-            ++fmt;
-            if (*fmt == '^') buffer[i++] = *fmt++;
-            if (*fmt == ']') buffer[i++] = *fmt++;
-            while (*fmt &amp;&amp; *fmt != ']') buffer[i++] = *fmt++;
-            if (*fmt != ']') {
-                fmtObj-&gt;error = &quot;unmatched [ in format string&quot;;
-                return JIM_ERR;
-            }
-            end = i;
-            buffer[i++] = 0;
-            /* In case a range fence was given &quot;backwards&quot;, swap it */
-            while (swapped) {
-                swapped = 0;
-                for (j = beg + 1; j &lt; end-1; ++j) {
-                    if (buffer[j] == '-' &amp;&amp; buffer[j-1] &gt; buffer[j + 1]) {
-                        char tmp = buffer[j-1];
-                        buffer[j-1] = buffer[j + 1];
-                        buffer[j + 1] = tmp;
-                        swapped = 1;
-                    }
-                }
-            }
-        } else {
-            /* Remember any valid modifier if given */
-            if (strchr(&quot;hlL&quot;, *fmt) != 0)
-                descr-&gt;modifier = tolower((int)*fmt++);
-
-            descr-&gt;type = *fmt;
-            if (strchr(&quot;efgcsndoxui&quot;, *fmt) == 0) {
-                fmtObj-&gt;error = &quot;bad scan conversion character&quot;;
-                return JIM_ERR;
-            } else if (*fmt == 'c' &amp;&amp; descr-&gt;width != 0) {
-                fmtObj-&gt;error = &quot;field width may not be specified in %c &quot;
-                    &quot;conversion&quot;;
-                return JIM_ERR;
-            } else if (*fmt == 'u' &amp;&amp; descr-&gt;modifier == 'l') {
-                fmtObj-&gt;error = &quot;unsigned wide not supported&quot;;
-                return JIM_ERR;
-            }
-        }
-        curr++;
-    }
-done:
-    if (fmtObj-&gt;convCount == 0) {
-        fmtObj-&gt;error = &quot;no any conversion specifier given&quot;;
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* Some accessor macros to allow lowlevel access to fields of internal repr */
-
-#define FormatGetCnvCount(_fo_) \
-    ((ScanFmtStringObj*)((_fo_)-&gt;internalRep.ptr))-&gt;convCount
-#define FormatGetMaxPos(_fo_) \
-    ((ScanFmtStringObj*)((_fo_)-&gt;internalRep.ptr))-&gt;maxPos
-#define FormatGetError(_fo_) \
-    ((ScanFmtStringObj*)((_fo_)-&gt;internalRep.ptr))-&gt;error
-
-/* Some Bit testing/setting/cleaning routines. For now only used in handling
- * charsets ([a-z123]) within scanning. Later on perhaps a base for a
- * bitvector implementation in Jim? */
-
-static int JimTestBit(const char *bitvec, char ch)
-{
-    div_t pos = div(ch-1, 8);
-    return bitvec[pos.quot] &amp; (1 &lt;&lt; pos.rem);
-}
-
-static void JimSetBit(char *bitvec, char ch)
-{
-    div_t pos = div(ch-1, 8);
-    bitvec[pos.quot] |= (1 &lt;&lt; pos.rem);
-}
-
-#if 0 /* currently not used */
-static void JimClearBit(char *bitvec, char ch)
-{
-    div_t pos = div(ch-1, 8);
-    bitvec[pos.quot] &amp;= ~(1 &lt;&lt; pos.rem);
-}
-#endif
-
-/* JimScanAString is used to scan an unspecified string that ends with
- * next WS, or a string that is specified via a charset. The charset
- * is currently implemented in a way to only allow for usage with
- * ASCII. Whenever we will switch to UNICODE, another idea has to
- * be born :-/
- *
- * FIXME: Works only with ASCII */
-
-static Jim_Obj *
-JimScanAString(Jim_Interp *interp, const char *sdescr, const char *str)
-{
-    size_t i;
-    Jim_Obj *result;
-    char charset[256/8 + 1];  /* A Charset may contain max 256 chars */
-    char *buffer = Jim_Alloc(strlen(str) + 1), *anchor = buffer;
-
-    /* First init charset to nothing or all, depending if a specified
-     * or an unspecified string has to be parsed */
-    memset(charset, (sdescr ? 0 : 255), sizeof(charset));
-    if (sdescr) {
-        /* There was a set description given, that means we are parsing
-         * a specified string. So we have to build a corresponding
-         * charset reflecting the description */
-        int notFlag = 0;
-        /* Should the set be negated at the end? */
-        if (*sdescr == '^') {
-            notFlag = 1;
-            ++sdescr;
-        }
-        /* Here '-' is meant literally and not to define a range */
-        if (*sdescr == '-') {
-            JimSetBit(charset, '-');
-            ++sdescr;
-        }
-        while (*sdescr) {
-            if (sdescr[1] == '-' &amp;&amp; sdescr[2] != 0) {
-                /* Handle range definitions */
-                int i_t;
-                for (i_t = sdescr[0]; i_t &lt;= sdescr[2]; ++i_t)
-                    JimSetBit(charset, (char)i_t);
-                sdescr += 3;
-            } else {
-                /* Handle verbatim character definitions */
-                JimSetBit(charset, *sdescr++);
-            }
-        }
-        /* Negate the charset if there was a NOT given */
-        for (i = 0; notFlag &amp;&amp; i &lt; sizeof(charset); ++i)
-            charset[i] = ~charset[i];
-    }
-    /* And after all the mess above, the real work begin ... */
-    while (str &amp;&amp; *str) {
-        if (!sdescr &amp;&amp; isspace((int)*str))
-            break; /* EOS via WS if unspecified */
-        if (JimTestBit(charset, *str)) *buffer++ = *str++;
-        else break;             /* EOS via mismatch if specified scanning */
-    }
-    *buffer = 0;                /* Close the string properly ... */
-    result = Jim_NewStringObj(interp, anchor, -1);
-    Jim_Free(anchor);           /* ... and free it afer usage */
-    return result;
-}
-
-/* ScanOneEntry will scan one entry out of the string passed as argument.
- * It use the sscanf() function for this task. After extracting and
- * converting of the value, the count of scanned characters will be
- * returned of -1 in case of no conversion tool place and string was
- * already scanned thru */
-
-static int ScanOneEntry(Jim_Interp *interp, const char *str, long pos,
-        ScanFmtStringObj *fmtObj, long index_t, Jim_Obj **valObjPtr)
-{
-#   define MAX_SIZE (sizeof(jim_wide) &gt; sizeof(double) \
-        ? sizeof(jim_wide)                             \
-        : sizeof(double))
-    char buffer[MAX_SIZE];
-    char *value = buffer;
-    const char *tok;
-    const ScanFmtPartDescr *descr = &amp;fmtObj-&gt;descr[index_t];
-    size_t sLen = strlen(&amp;str[pos]), scanned = 0;
-    size_t anchor = pos;
-    int i;
-
-    /* First pessimiticly assume, we will not scan anything :-) */
-    *valObjPtr = 0;
-    if (descr-&gt;prefix) {
-        /* There was a prefix given before the conversion, skip it and adjust
-         * the string-to-be-parsed accordingly */
-        for (i = 0; str[pos] &amp;&amp; descr-&gt;prefix[i]; ++i) {
-            /* If prefix require, skip WS */
-            if (isspace((int)descr-&gt;prefix[i]))
-                while (str[pos] &amp;&amp; isspace((int)str[pos])) ++pos;
-            else if (descr-&gt;prefix[i] != str[pos])
-                break;  /* Prefix do not match here, leave the loop */
-            else
-                ++pos;  /* Prefix matched so far, next round */
-        }
-        if (str[pos] == 0)
-            return -1;  /* All of str consumed: EOF condition */
-        else if (descr-&gt;prefix[i] != 0)
-            return 0;   /* Not whole prefix consumed, no conversion possible */
-    }
-    /* For all but following conversion, skip leading WS */
-    if (descr-&gt;type != 'c' &amp;&amp; descr-&gt;type != '[' &amp;&amp; descr-&gt;type != 'n')
-        while (isspace((int)str[pos])) ++pos;
-    /* Determine how much skipped/scanned so far */
-    scanned = pos - anchor;
-    if (descr-&gt;type == 'n') {
-        /* Return pseudo conversion means: how much scanned so far? */
-        *valObjPtr = Jim_NewIntObj(interp, anchor + scanned);
-    } else if (str[pos] == 0) {
-        /* Cannot scan anything, as str is totally consumed */
-        return -1;
-    } else {
-        /* Processing of conversions follows ... */
-        if (descr-&gt;width &gt; 0) {
-            /* Do not try to scan as fas as possible but only the given width.
-             * To ensure this, we copy the part that should be scanned. */
-            size_t tLen = descr-&gt;width &gt; sLen ? sLen : descr-&gt;width;
-            tok = Jim_StrDupLen(&amp;str[pos], tLen);
-        } else {
-            /* As no width was given, simply refer to the original string */
-            tok = &amp;str[pos];
-        }
-        switch (descr-&gt;type) {
-            case 'c':
-                *valObjPtr = Jim_NewIntObj(interp, *tok);
-                scanned += 1;
-                break;
-            case 'd': case 'o': case 'x': case 'u': case 'i': {
-                jim_wide jwvalue = 0;
-                long lvalue = 0;
-                char *endp;  /* Position where the number finished */
-                int base = descr-&gt;type == 'o' ? 8
-                    : descr-&gt;type == 'x' ? 16
-                    : descr-&gt;type == 'i' ? 0
-                    : 10;
-
-                do {
-                    /* Try to scan a number with the given base */
-                    if (descr-&gt;modifier == 'l')
-                    {
-#ifdef HAVE_LONG_LONG_INT
-                        jwvalue = JimStrtoll(tok, &amp;endp, base),
-#else
-                        jwvalue = strtol(tok, &amp;endp, base),
-#endif
-                        memcpy(value, &amp;jwvalue, sizeof(jim_wide));
-                    }
-                    else
-                    {
-                      if (descr-&gt;type == 'u')
-                        lvalue = strtoul(tok, &amp;endp, base);
-                      else
-                        lvalue = strtol(tok, &amp;endp, base);
-                      memcpy(value, &amp;lvalue, sizeof(lvalue));
-                    }
-                    /* If scanning failed, and base was undetermined, simply
-                     * put it to 10 and try once more. This should catch the
-                     * case where %i begin to parse a number prefix (e.g.
-                     * '0x' but no further digits follows. This will be
-                     * handled as a ZERO followed by a char 'x' by Tcl */
-                    if (endp == tok &amp;&amp; base == 0) base = 10;
-                    else break;
-                } while (1);
-                if (endp != tok) {
-                    /* There was some number sucessfully scanned! */
-                    if (descr-&gt;modifier == 'l')
-                        *valObjPtr = Jim_NewIntObj(interp, jwvalue);
-                    else
-                        *valObjPtr = Jim_NewIntObj(interp, lvalue);
-                    /* Adjust the number-of-chars scanned so far */
-                    scanned += endp - tok;
-                } else {
-                    /* Nothing was scanned. We have to determine if this
-                     * happened due to e.g. prefix mismatch or input str
-                     * exhausted */
-                    scanned = *tok ? 0 : -1;
-                }
-                break;
-            }
-            case 's': case '[': {
-                *valObjPtr = JimScanAString(interp, descr-&gt;arg, tok);
-                scanned += Jim_Length(*valObjPtr);
-                break;
-            }
-            case 'e': case 'f': case 'g': {
-                char *endp;
-
-                double dvalue = strtod(tok, &amp;endp);
-                memcpy(value, &amp;dvalue, sizeof(double));
-                if (endp != tok) {
-                    /* There was some number sucessfully scanned! */
-                    *valObjPtr = Jim_NewDoubleObj(interp, dvalue);
-                    /* Adjust the number-of-chars scanned so far */
-                    scanned += endp - tok;
-                } else {
-                    /* Nothing was scanned. We have to determine if this
-                     * happened due to e.g. prefix mismatch or input str
-                     * exhausted */
-                    scanned = *tok ? 0 : -1;
-                }
-                break;
-            }
-        }
-        /* If a substring was allocated (due to pre-defined width) do not
-         * forget to free it */
-        if (tok != &amp;str[pos])
-            Jim_Free((char*)tok);
-    }
-    return scanned;
-}
-
-/* Jim_ScanString is the workhorse of string scanning. It will scan a given
- * string and returns all converted (and not ignored) values in a list back
- * to the caller. If an error occured, a NULL pointer will be returned */
-
-Jim_Obj *Jim_ScanString(Jim_Interp *interp, Jim_Obj *strObjPtr,
-        Jim_Obj *fmtObjPtr, int flags)
-{
-    size_t i, pos;
-    int scanned = 1;
-    const char *str = Jim_GetString(strObjPtr, 0);
-    Jim_Obj *resultList = 0;
-    Jim_Obj **resultVec =NULL;
-    int resultc;
-    Jim_Obj *emptyStr = 0;
-    ScanFmtStringObj *fmtObj;
-
-    /* If format specification is not an object, convert it! */
-    if (fmtObjPtr-&gt;typePtr != &amp;scanFmtStringObjType)
-        SetScanFmtFromAny(interp, fmtObjPtr);
-    fmtObj = (ScanFmtStringObj*)fmtObjPtr-&gt;internalRep.ptr;
-    /* Check if format specification was valid */
-    if (fmtObj-&gt;error != 0) {
-        if (flags &amp; JIM_ERRMSG)
-            Jim_SetResultString(interp, fmtObj-&gt;error, -1);
-        return 0;
-    }
-    /* Allocate a new &quot;shared&quot; empty string for all unassigned conversions */
-    emptyStr = Jim_NewEmptyStringObj(interp);
-    Jim_IncrRefCount(emptyStr);
-    /* Create a list and fill it with empty strings up to max specified XPG3 */
-    resultList = Jim_NewListObj(interp, 0, 0);
-    if (fmtObj-&gt;maxPos &gt; 0) {
-        for (i = 0; i &lt; fmtObj-&gt;maxPos; ++i)
-            Jim_ListAppendElement(interp, resultList, emptyStr);
-        JimListGetElements(interp, resultList, &amp;resultc, &amp;resultVec);
-    }
-    /* Now handle every partial format description */
-    for (i = 0, pos = 0; i &lt; fmtObj-&gt;count; ++i) {
-        ScanFmtPartDescr *descr = &amp;(fmtObj-&gt;descr[i]);
-        Jim_Obj *value = 0;
-        /* Only last type may be &quot;literal&quot; w/o conversion - skip it! */
-        if (descr-&gt;type == 0) continue;
-        /* As long as any conversion could be done, we will proceed */
-        if (scanned &gt; 0)
-            scanned = ScanOneEntry(interp, str, pos, fmtObj, i, &amp;value);
-        /* In case our first try results in EOF, we will leave */
-        if (scanned == -1 &amp;&amp; i == 0)
-            goto eof;
-        /* Advance next pos-to-be-scanned for the amount scanned already */
-        pos += scanned;
-        /* value == 0 means no conversion took place so take empty string */
-        if (value == 0)
-            value = Jim_NewEmptyStringObj(interp);
-        /* If value is a non-assignable one, skip it */
-        if (descr-&gt;pos == -1) {
-            Jim_FreeNewObj(interp, value);
-        } else if (descr-&gt;pos == 0)
-            /* Otherwise append it to the result list if no XPG3 was given */
-            Jim_ListAppendElement(interp, resultList, value);
-        else if (resultVec[descr-&gt;pos-1] == emptyStr) {
-            /* But due to given XPG3, put the value into the corr. slot */
-            Jim_DecrRefCount(interp, resultVec[descr-&gt;pos-1]);
-            Jim_IncrRefCount(value);
-            resultVec[descr-&gt;pos-1] = value;
-        } else {
-            /* Otherwise, the slot was already used - free obj and ERROR */
-            Jim_FreeNewObj(interp, value);
-            goto err;
-        }
-    }
-    Jim_DecrRefCount(interp, emptyStr);
-    return resultList;
-eof:
-    Jim_DecrRefCount(interp, emptyStr);
-    Jim_FreeNewObj(interp, resultList);
-    return (Jim_Obj*)EOF;
-err:
-    Jim_DecrRefCount(interp, emptyStr);
-    Jim_FreeNewObj(interp, resultList);
-    return 0;
-}
-
-/* -----------------------------------------------------------------------------
- * Pseudo Random Number Generation
- * ---------------------------------------------------------------------------*/
-static void JimPrngSeed(Jim_Interp *interp, const unsigned char *seed,
-        int seedLen);
-
-/* Initialize the sbox with the numbers from 0 to 255 */
-static void JimPrngInit(Jim_Interp *interp)
-{
-    int i;
-    unsigned int seed[256];
-
-    interp-&gt;prngState = Jim_Alloc(sizeof(Jim_PrngState));
-    for (i = 0; i &lt; 256; i++)
-        seed[i] = (rand() ^ time(NULL) ^ clock());
-    JimPrngSeed(interp, (unsigned char*) seed, sizeof(int)*256);
-}
-
-/* Generates N bytes of random data */
-static void JimRandomBytes(Jim_Interp *interp, void *dest, unsigned int len)
-{
-    Jim_PrngState *prng;
-    unsigned char *destByte = (unsigned char*) dest;
-    unsigned int si, sj, x;
-
-    /* initialization, only needed the first time */
-    if (interp-&gt;prngState == NULL)
-        JimPrngInit(interp);
-    prng = interp-&gt;prngState;
-    /* generates 'len' bytes of pseudo-random numbers */
-    for (x = 0; x &lt; len; x++) {
-        prng-&gt;i = (prng-&gt;i + 1) &amp; 0xff;
-        si = prng-&gt;sbox[prng-&gt;i];
-        prng-&gt;j = (prng-&gt;j + si) &amp; 0xff;
-        sj = prng-&gt;sbox[prng-&gt;j];
-        prng-&gt;sbox[prng-&gt;i] = sj;
-        prng-&gt;sbox[prng-&gt;j] = si;
-        *destByte++ = prng-&gt;sbox[(si + sj)&amp;0xff];
-    }
-}
-
-/* Re-seed the generator with user-provided bytes */
-static void JimPrngSeed(Jim_Interp *interp, const unsigned char *seed,
-        int seedLen)
-{
-    int i;
-    unsigned char buf[256];
-    Jim_PrngState *prng;
-
-    /* initialization, only needed the first time */
-    if (interp-&gt;prngState == NULL)
-        JimPrngInit(interp);
-    prng = interp-&gt;prngState;
-
-    /* Set the sbox[i] with i */
-    for (i = 0; i &lt; 256; i++)
-        prng-&gt;sbox[i] = i;
-    /* Now use the seed to perform a random permutation of the sbox */
-    for (i = 0; i &lt; seedLen; i++) {
-        unsigned char t;
-
-        t = prng-&gt;sbox[i&amp;0xFF];
-        prng-&gt;sbox[i&amp;0xFF] = prng-&gt;sbox[seed[i]];
-        prng-&gt;sbox[seed[i]] = t;
-    }
-    prng-&gt;i = prng-&gt;j = 0;
-    /* discard the first 256 bytes of stream. */
-    JimRandomBytes(interp, buf, 256);
-}
-
-/* -----------------------------------------------------------------------------
- * Dynamic libraries support (WIN32 not supported)
- * ---------------------------------------------------------------------------*/
-
-#ifdef JIM_DYNLIB
-#ifdef WIN32
-#define RTLD_LAZY 0
-void * dlopen(const char *path, int mode)
-{
-    JIM_NOTUSED(mode);
-
-    return (void *)LoadLibraryA(path);
-}
-int dlclose(void *handle)
-{
-    FreeLibrary((HANDLE)handle);
-    return 0;
-}
-void *dlsym(void *handle, const char *symbol)
-{
-    return GetProcAddress((HMODULE)handle, symbol);
-}
-static char win32_dlerror_string[121];
-const char *dlerror(void)
-{
-    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
-                   LANG_NEUTRAL, win32_dlerror_string, 120, NULL);
-    return win32_dlerror_string;
-}
-#endif /* WIN32 */
-
-int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
-{
-    Jim_Obj *libPathObjPtr;
-    int prefixc, i;
-    void *handle;
-    int (*onload)(Jim_Interp *interp);
-
-    libPathObjPtr = Jim_GetGlobalVariableStr(interp, &quot;jim_libpath&quot;, JIM_NONE);
-    if (libPathObjPtr == NULL) {
-        prefixc = 0;
-        libPathObjPtr = NULL;
-    } else {
-        Jim_IncrRefCount(libPathObjPtr);
-        Jim_ListLength(interp, libPathObjPtr, &amp;prefixc);
-    }
-
-    for (i = -1; i &lt; prefixc; i++) {
-        if (i &lt; 0) {
-            handle = dlopen(pathName, RTLD_LAZY);
-        } else {
-            FILE *fp;
-            char buf[JIM_PATH_LEN];
-            const char *prefix;
-            int prefixlen;
-            Jim_Obj *prefixObjPtr;
-
-            buf[0] = '\0';
-            if (Jim_ListIndex(interp, libPathObjPtr, i,
-                    &amp;prefixObjPtr, JIM_NONE) != JIM_OK)
-                continue;
-            prefix = Jim_GetString(prefixObjPtr, &amp;prefixlen);
-            if (prefixlen + strlen(pathName) + 1 &gt;= JIM_PATH_LEN)
-                continue;
-            if (*pathName == '/') {
-                strcpy(buf, pathName);
-            }
-            else if (prefixlen &amp;&amp; prefix[prefixlen-1] == '/')
-                sprintf(buf, &quot;%s%s&quot;, prefix, pathName);
-            else
-                sprintf(buf, &quot;%s/%s&quot;, prefix, pathName);
-            fp = fopen(buf, &quot;r&quot;);
-            if (fp == NULL)
-                continue;
-            fclose(fp);
-            handle = dlopen(buf, RTLD_LAZY);
-        }
-        if (handle == NULL) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;error loading extension \&quot;&quot;, pathName,
-                &quot;\&quot;: &quot;, dlerror(), NULL);
-            if (i &lt; 0)
-                continue;
-            goto err;
-        }
-        if ((onload = dlsym(handle, &quot;Jim_OnLoad&quot;)) == NULL) {
-            Jim_SetResultString(interp,
-                    &quot;No Jim_OnLoad symbol found on extension&quot;, -1);
-            goto err;
-        }
-        if (onload(interp) == JIM_ERR) {
-            dlclose(handle);
-            goto err;
-        }
-        Jim_SetEmptyResult(interp);
-        if (libPathObjPtr != NULL)
-            Jim_DecrRefCount(interp, libPathObjPtr);
-        return JIM_OK;
-    }
-err:
-    if (libPathObjPtr != NULL)
-        Jim_DecrRefCount(interp, libPathObjPtr);
-    return JIM_ERR;
-}
-#else /* JIM_DYNLIB */
-int Jim_LoadLibrary(Jim_Interp *interp, const char *pathName)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(pathName);
-
-    Jim_SetResultString(interp, &quot;the Jim binary has no support for [load]&quot;, -1);
-    return JIM_ERR;
-}
-#endif/* JIM_DYNLIB */
-
-/* -----------------------------------------------------------------------------
- * Packages handling
- * ---------------------------------------------------------------------------*/
-
-#define JIM_PKG_ANY_VERSION -1
-
-/* Convert a string of the type &quot;1.2&quot; into an integer.
- * MAJOR.MINOR is converted as MAJOR*100 + MINOR, so &quot;1.2&quot; is converted
- * to the integer with value 102 */
-static int JimPackageVersionToInt(Jim_Interp *interp, const char *v,
-        int *intPtr, int flags)
-{
-    char *copy;
-    jim_wide major, minor;
-    char *majorStr, *minorStr, *p;
-
-    if (v[0] == '\0') {
-        *intPtr = JIM_PKG_ANY_VERSION;
-        return JIM_OK;
-    }
-
-    copy = Jim_StrDup(v);
-    p = strchr(copy, '.');
-    if (p == NULL) goto badfmt;
-    *p = '\0';
-    majorStr = copy;
-    minorStr = p + 1;
-
-    if (Jim_StringToWide(majorStr, &amp;major, 10) != JIM_OK ||
-        Jim_StringToWide(minorStr, &amp;minor, 10) != JIM_OK)
-        goto badfmt;
-    *intPtr = (int)(major*100 + minor);
-    Jim_Free(copy);
-    return JIM_OK;
-
-badfmt:
-    Jim_Free(copy);
-    if (flags &amp; JIM_ERRMSG) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;invalid package version '&quot;, v, &quot;'&quot;, NULL);
-    }
-    return JIM_ERR;
-}
-
-#define JIM_MATCHVER_EXACT (1 &lt;&lt; JIM_PRIV_FLAG_SHIFT)
-static int JimPackageMatchVersion(int needed, int actual, int flags)
-{
-    if (needed == JIM_PKG_ANY_VERSION) return 1;
-    if (flags &amp; JIM_MATCHVER_EXACT) {
-        return needed == actual;
-    } else {
-        return needed/100 == actual/100 &amp;&amp; (needed &lt;= actual);
-    }
-}
-
-int Jim_PackageProvide(Jim_Interp *interp, const char *name, const char *ver,
-        int flags)
-{
-    int intVersion;
-    /* Check if the version format is ok */
-    if (JimPackageVersionToInt(interp, ver, &amp;intVersion, JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-    /* If the package was already provided returns an error. */
-    if (Jim_FindHashEntry(&amp;interp-&gt;packages, name) != NULL) {
-        if (flags &amp; JIM_ERRMSG) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    &quot;package '&quot;, name, &quot;' was already provided&quot;, NULL);
-        }
-        return JIM_ERR;
-    }
-    Jim_AddHashEntry(&amp;interp-&gt;packages, name, (char*) ver);
-    return JIM_OK;
-}
-
-#ifndef JIM_ANSIC
-
-#ifndef WIN32
-# include &lt;sys/types.h&gt;
-# include &lt;dirent.h&gt;
-#else
-# include &lt;io.h&gt;
-/* Posix dirent.h compatiblity layer for WIN32.
- * Copyright Kevlin Henney, 1997, 2003. All rights reserved.
- * Copyright Salvatore Sanfilippo ,2005.
- *
- * Permission to use, copy, modify, and distribute this software and its
- * documentation for any purpose is hereby granted without fee, provided
- * that this copyright and permissions notice appear in all copies and
- * derivatives.
- *
- * This software is supplied &quot;as is&quot; without express or implied warranty.
- * This software was modified by Salvatore Sanfilippo for the Jim Interpreter.
- */
-
-struct dirent {
-    char *d_name;
-};
-
-typedef struct DIR {
-    long                handle; /* -1 for failed rewind */
-    struct _finddata_t  info;
-    struct dirent       result; /* d_name null iff first time */
-    char                *name;  /* null-terminated char string */
-} DIR;
-
-DIR *opendir(const char *name)
-{
-    DIR *dir = 0;
-
-    if (name &amp;&amp; name[0]) {
-        size_t base_length = strlen(name);
-        const char *all = /* search pattern must end with suitable wildcard */
-            strchr(&quot;/\\&quot;, name[base_length - 1]) ? &quot;*&quot; : &quot;/*&quot;;
-
-        if ((dir = (DIR *) Jim_Alloc(sizeof *dir)) != 0 &amp;&amp;
-           (dir-&gt;name = (char *) Jim_Alloc(base_length + strlen(all) + 1)) != 0)
-        {
-            strcat(strcpy(dir-&gt;name, name), all);
-
-            if ((dir-&gt;handle = (long) _findfirst(dir-&gt;name, &amp;dir-&gt;info)) != -1)
-                dir-&gt;result.d_name = 0;
-            else { /* rollback */
-                Jim_Free(dir-&gt;name);
-                Jim_Free(dir);
-                dir = 0;
-            }
-        } else { /* rollback */
-            Jim_Free(dir);
-            dir   = 0;
-            errno = ENOMEM;
-        }
-    } else {
-        errno = EINVAL;
-    }
-    return dir;
-}
-
-int closedir(DIR *dir)
-{
-    int result = -1;
-
-    if (dir) {
-        if (dir-&gt;handle != -1)
-            result = _findclose(dir-&gt;handle);
-        Jim_Free(dir-&gt;name);
-        Jim_Free(dir);
-    }
-    if (result == -1) /* map all errors to EBADF */
-        errno = EBADF;
-    return result;
-}
-
-struct dirent *readdir(DIR *dir)
-{
-    struct dirent *result = 0;
-
-    if (dir &amp;&amp; dir-&gt;handle != -1) {
-        if (!dir-&gt;result.d_name || _findnext(dir-&gt;handle, &amp;dir-&gt;info) != -1) {
-            result         = &amp;dir-&gt;result;
-            result-&gt;d_name = dir-&gt;info.name;
-        }
-    } else {
-        errno = EBADF;
-    }
-    return result;
-}
-
-#endif /* WIN32 */
-
-static char *JimFindBestPackage(Jim_Interp *interp, char **prefixes,
-        int prefixc, const char *pkgName, int pkgVer, int flags)
-{
-    int bestVer = -1, i;
-    int pkgNameLen = strlen(pkgName);
-    char *bestPackage = NULL;
-    struct dirent *de;
-
-    for (i = 0; i &lt; prefixc; i++) {
-        DIR *dir;
-        char buf[JIM_PATH_LEN];
-        int prefixLen;
-
-        if (prefixes[i] == NULL) continue;
-        strncpy(buf, prefixes[i], JIM_PATH_LEN);
-        buf[JIM_PATH_LEN-1] = '\0';
-        prefixLen = strlen(buf);
-        if (prefixLen &amp;&amp; buf[prefixLen-1] == '/')
-            buf[prefixLen-1] = '\0';
-
-        if ((dir = opendir(buf)) == NULL) continue;
-        while ((de = readdir(dir)) != NULL) {
-            char *fileName = de-&gt;d_name;
-            int fileNameLen = strlen(fileName);
-
-            if (strncmp(fileName, &quot;jim-&quot;, 4) == 0 &amp;&amp;
-                strncmp(fileName + 4, pkgName, pkgNameLen) == 0 &amp;&amp;
-                *(fileName + 4+pkgNameLen) == '-' &amp;&amp;
-                fileNameLen &gt; 4 &amp;&amp; /* note that this is not really useful */
-                (strncmp(fileName + fileNameLen-4, &quot;.tcl&quot;, 4) == 0 ||
-                 strncmp(fileName + fileNameLen-4, &quot;.dll&quot;, 4) == 0 ||
-                 strncmp(fileName + fileNameLen-3, &quot;.so&quot;, 3) == 0))
-            {
-                char ver[6]; /* xx.yy &lt; nulterm&gt; */
-                char *p = strrchr(fileName, '.');
-                int verLen, fileVer;
-
-                verLen = p - (fileName + 4+pkgNameLen + 1);
-                if (verLen &lt; 3 || verLen &gt; 5) continue;
-                memcpy(ver, fileName + 4+pkgNameLen + 1, verLen);
-                ver[verLen] = '\0';
-                if (JimPackageVersionToInt(interp, ver, &amp;fileVer, JIM_NONE)
-                        != JIM_OK) continue;
-                if (JimPackageMatchVersion(pkgVer, fileVer, flags) &amp;&amp;
-                    (bestVer == -1 || bestVer &lt; fileVer))
-                {
-                    bestVer = fileVer;
-                    Jim_Free(bestPackage);
-                    bestPackage = Jim_Alloc(strlen(buf) + strlen(fileName) + 2);
-                    sprintf(bestPackage, &quot;%s/%s&quot;, buf, fileName);
-                }
-            }
-        }
-        closedir(dir);
-    }
-    return bestPackage;
-}
-
-#else /* JIM_ANSIC */
-
-static char *JimFindBestPackage(Jim_Interp *interp, char **prefixes,
-        int prefixc, const char *pkgName, int pkgVer, int flags)
-{
-    JIM_NOTUSED(interp);
-    JIM_NOTUSED(prefixes);
-    JIM_NOTUSED(prefixc);
-    JIM_NOTUSED(pkgName);
-    JIM_NOTUSED(pkgVer);
-    JIM_NOTUSED(flags);
-    return NULL;
-}
-
-#endif /* JIM_ANSIC */
-
-/* Search for a suitable package under every dir specified by jim_libpath
- * and load it if possible. If a suitable package was loaded with success
- * JIM_OK is returned, otherwise JIM_ERR is returned. */
-static int JimLoadPackage(Jim_Interp *interp, const char *name, int ver,
-        int flags)
-{
-    Jim_Obj *libPathObjPtr;
-    char **prefixes, *best;
-    int prefixc, i, retCode = JIM_OK;
-
-    libPathObjPtr = Jim_GetGlobalVariableStr(interp, &quot;jim_libpath&quot;, JIM_NONE);
-    if (libPathObjPtr == NULL) {
-        prefixc = 0;
-        libPathObjPtr = NULL;
-    } else {
-        Jim_IncrRefCount(libPathObjPtr);
-        Jim_ListLength(interp, libPathObjPtr, &amp;prefixc);
-    }
-
-    prefixes = Jim_Alloc(sizeof(char*)*prefixc);
-    for (i = 0; i &lt; prefixc; i++) {
-            Jim_Obj *prefixObjPtr;
-            if (Jim_ListIndex(interp, libPathObjPtr, i,
-                    &amp;prefixObjPtr, JIM_NONE) != JIM_OK)
-            {
-                prefixes[i] = NULL;
-                continue;
-            }
-            prefixes[i] = Jim_StrDup(Jim_GetString(prefixObjPtr, NULL));
-    }
-    /* Scan every directory to find the &quot;best&quot; package. */
-    best = JimFindBestPackage(interp, prefixes, prefixc, name, ver, flags);
-    if (best != NULL) {
-        char *p = strrchr(best, '.');
-        /* Try to load/source it */
-        if (p &amp;&amp; strcmp(p, &quot;.tcl&quot;) == 0) {
-            retCode = Jim_EvalFile(interp, best);
-        } else {
-            retCode = Jim_LoadLibrary(interp, best);
-        }
-    } else {
-        retCode = JIM_ERR;
-    }
-    Jim_Free(best);
-    for (i = 0; i &lt; prefixc; i++)
-        Jim_Free(prefixes[i]);
-    Jim_Free(prefixes);
-    if (libPathObjPtr)
-        Jim_DecrRefCount(interp, libPathObjPtr);
-    return retCode;
-}
-
-const char *Jim_PackageRequire(Jim_Interp *interp, const char *name,
-        const char *ver, int flags)
-{
-    Jim_HashEntry *he;
-    int requiredVer;
-
-    /* Start with an empty error string */
-    Jim_SetResultString(interp, &quot;&quot;, 0);
-
-    if (JimPackageVersionToInt(interp, ver, &amp;requiredVer, JIM_ERRMSG) != JIM_OK)
-        return NULL;
-    he = Jim_FindHashEntry(&amp;interp-&gt;packages, name);
-    if (he == NULL) {
-        /* Try to load the package. */
-        if (JimLoadPackage(interp, name, requiredVer, flags) == JIM_OK) {
-            he = Jim_FindHashEntry(&amp;interp-&gt;packages, name);
-            if (he == NULL) {
-                return &quot;?&quot;;
-            }
-            return he-&gt;val;
-        }
-        /* No way... return an error. */
-        if (flags &amp; JIM_ERRMSG) {
-            int len;
-            Jim_GetString(Jim_GetResult(interp), &amp;len);
-            Jim_AppendStrings(interp, Jim_GetResult(interp), len ? &quot;\n&quot; : &quot;&quot;,
-                    &quot;Can't find package '&quot;, name, &quot;'&quot;, NULL);
-        }
-        return NULL;
-    } else {
-        int actualVer;
-        if (JimPackageVersionToInt(interp, he-&gt;val, &amp;actualVer, JIM_ERRMSG)
-                != JIM_OK)
-        {
-            return NULL;
-        }
-        /* Check if version matches. */
-        if (JimPackageMatchVersion(requiredVer, actualVer, flags) == 0) {
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                    &quot;Package '&quot;, name, &quot;' already loaded, but with version &quot;,
-                    he-&gt;val, NULL);
-            return NULL;
-        }
-        return he-&gt;val;
-    }
-}
-
-/* -----------------------------------------------------------------------------
- * Eval
- * ---------------------------------------------------------------------------*/
-#define JIM_EVAL_SARGV_LEN 8 /* static arguments vector length */
-#define JIM_EVAL_SINTV_LEN 8 /* static interpolation vector length */
-
-static int JimCallProcedure(Jim_Interp *interp, Jim_Cmd *cmd, int argc,
-        Jim_Obj *const *argv);
-
-/* Handle calls to the [unknown] command */
-static int JimUnknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-    Jim_Obj **v, *sv[JIM_EVAL_SARGV_LEN];
-    int retCode;
-
-    /* If JimUnknown() is recursively called (e.g. error in the unknown proc,
-     * done here
-     */
-    if (interp-&gt;unknown_called) {
-        return JIM_ERR;
-    }
-
-    /* If the [unknown] command does not exists returns
-     * just now */
-    if (Jim_GetCommand(interp, interp-&gt;unknown, JIM_NONE) == NULL)
-        return JIM_ERR;
-
-    /* The object interp-&gt;unknown just contains
-     * the &quot;unknown&quot; string, it is used in order to
-     * avoid to lookup the unknown command every time
-     * but instread to cache the result. */
-    if (argc + 1 &lt;= JIM_EVAL_SARGV_LEN)
-        v = sv;
-    else
-        v = Jim_Alloc(sizeof(Jim_Obj*)*(argc + 1));
-    /* Make a copy of the arguments vector, but shifted on
-     * the right of one position. The command name of the
-     * command will be instead the first argument of the
-     * [unknonw] call. */
-    memcpy(v + 1, argv, sizeof(Jim_Obj*)*argc);
-    v[0] = interp-&gt;unknown;
-    /* Call it */
-    interp-&gt;unknown_called++;
-    retCode = Jim_EvalObjVector(interp, argc + 1, v);
-    interp-&gt;unknown_called--;
-
-    /* Clean up */
-    if (v != sv)
-        Jim_Free(v);
-    return retCode;
-}
-
-/* Eval the object vector 'objv' composed of 'objc' elements.
- * Every element is used as single argument.
- * Jim_EvalObj() will call this function every time its object
- * argument is of &quot;list&quot; type, with no string representation.
- *
- * This is possible because the string representation of a
- * list object generated by the UpdateStringOfList is made
- * in a way that ensures that every list element is a different
- * command argument. */
-int Jim_EvalObjVector(Jim_Interp *interp, int objc, Jim_Obj *const *objv)
-{
-    int i, retcode;
-    Jim_Cmd *cmdPtr;
-
-    /* Incr refcount of arguments. */
-    for (i = 0; i &lt; objc; i++)
-        Jim_IncrRefCount(objv[i]);
-    /* Command lookup */
-    cmdPtr = Jim_GetCommand(interp, objv[0], JIM_ERRMSG);
-    if (cmdPtr == NULL) {
-        retcode = JimUnknown(interp, objc, objv);
-    } else {
-        /* Call it -- Make sure result is an empty object. */
-        Jim_SetEmptyResult(interp);
-        if (cmdPtr-&gt;cmdProc) {
-            interp-&gt;cmdPrivData = cmdPtr-&gt;privData;
-            retcode = cmdPtr-&gt;cmdProc(interp, objc, objv);
-            if (retcode == JIM_ERR_ADDSTACK) {
-                //JimAppendStackTrace(interp, &quot;&quot;, script-&gt;fileName, token[i-argc*2].linenr);
-                retcode = JIM_ERR;
-            }
-        } else {
-            retcode = JimCallProcedure(interp, cmdPtr, objc, objv);
-            if (retcode == JIM_ERR) {
-                JimAppendStackTrace(interp,
-                    Jim_GetString(objv[0], NULL), &quot;&quot;, 1);
-            }
-        }
-    }
-    /* Decr refcount of arguments and return the retcode */
-    for (i = 0; i &lt; objc; i++)
-        Jim_DecrRefCount(interp, objv[i]);
-    return retcode;
-}
-
-/* Interpolate the given tokens into a unique Jim_Obj returned by reference
- * via *objPtrPtr. This function is only called by Jim_EvalObj().
- * The returned object has refcount = 0. */
-int Jim_InterpolateTokens(Jim_Interp *interp, ScriptToken *token,
-        int tokens, Jim_Obj **objPtrPtr)
-{
-    int totlen = 0, i, retcode;
-    Jim_Obj **intv;
-    Jim_Obj *sintv[JIM_EVAL_SINTV_LEN];
-    Jim_Obj *objPtr;
-    char *s;
-
-    if (tokens &lt;= JIM_EVAL_SINTV_LEN)
-        intv = sintv;
-    else
-        intv = Jim_Alloc(sizeof(Jim_Obj*)*
-                tokens);
-    /* Compute every token forming the argument
-     * in the intv objects vector. */
-    for (i = 0; i &lt; tokens; i++) {
-        switch (token[i].type) {
-        case JIM_TT_ESC:
-        case JIM_TT_STR:
-            intv[i] = token[i].objPtr;
-            break;
-        case JIM_TT_VAR:
-            intv[i] = Jim_GetVariable(interp, token[i].objPtr, JIM_ERRMSG);
-            if (!intv[i]) {
-                retcode = JIM_ERR;
-                goto err;
-            }
-            break;
-        case JIM_TT_DICTSUGAR:
-            intv[i] = Jim_ExpandDictSugar(interp, token[i].objPtr);
-            if (!intv[i]) {
-                retcode = JIM_ERR;
-                goto err;
-            }
-            break;
-        case JIM_TT_CMD:
-            retcode = Jim_EvalObj(interp, token[i].objPtr);
-            if (retcode != JIM_OK)
-                goto err;
-            intv[i] = Jim_GetResult(interp);
-            break;
-        default:
-            Jim_Panic(interp,
-              &quot;default token type reached &quot;
-              &quot;in Jim_InterpolateTokens().&quot;);
-            break;
-        }
-        Jim_IncrRefCount(intv[i]);
-        /* Make sure there is a valid
-         * string rep, and add the string
-         * length to the total legnth. */
-        Jim_GetString(intv[i], NULL);
-        totlen += intv[i]-&gt;length;
-    }
-    /* Concatenate every token in an unique
-     * object. */
-    objPtr = Jim_NewStringObjNoAlloc(interp,
-            NULL, 0);
-    s = objPtr-&gt;bytes = Jim_Alloc(totlen + 1);
-    objPtr-&gt;length = totlen;
-    for (i = 0; i &lt; tokens; i++) {
-        memcpy(s, intv[i]-&gt;bytes, intv[i]-&gt;length);
-        s += intv[i]-&gt;length;
-        Jim_DecrRefCount(interp, intv[i]);
-    }
-    objPtr-&gt;bytes[totlen] = '\0';
-    /* Free the intv vector if not static. */
-    if (tokens &gt; JIM_EVAL_SINTV_LEN)
-        Jim_Free(intv);
-    *objPtrPtr = objPtr;
-    return JIM_OK;
-err:
-    i--;
-    for (; i &gt;= 0; i--)
-        Jim_DecrRefCount(interp, intv[i]);
-    if (tokens &gt; JIM_EVAL_SINTV_LEN)
-        Jim_Free(intv);
-    return retcode;
-}
-
-/* Helper of Jim_EvalObj() to perform argument expansion.
- * Basically this function append an argument to 'argv'
- * (and increments argc by reference accordingly), performing
- * expansion of the list object if 'expand' is non-zero, or
- * just adding objPtr to argv if 'expand' is zero. */
-void Jim_ExpandArgument(Jim_Interp *interp, Jim_Obj ***argv,
-        int *argcPtr, int expand, Jim_Obj *objPtr)
-{
-    if (!expand) {
-        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr) + 1));
-        /* refcount of objPtr not incremented because
-         * we are actually transfering a reference from
-         * the old 'argv' to the expanded one. */
-        (*argv)[*argcPtr] = objPtr;
-        (*argcPtr)++;
-    } else {
-        int len, i;
-
-        Jim_ListLength(interp, objPtr, &amp;len);
-        (*argv) = Jim_Realloc(*argv, sizeof(Jim_Obj*)*((*argcPtr) + len));
-        for (i = 0; i &lt; len; i++) {
-            (*argv)[*argcPtr] = objPtr-&gt;internalRep.listValue.ele[i];
-            Jim_IncrRefCount(objPtr-&gt;internalRep.listValue.ele[i]);
-            (*argcPtr)++;
-        }
-        /* The original object reference is no longer needed,
-         * after the expansion it is no longer present on
-         * the argument vector, but the single elements are
-         * in its place. */
-        Jim_DecrRefCount(interp, objPtr);
-    }
-}
-
-int Jim_EvalObj(Jim_Interp *interp, Jim_Obj *scriptObjPtr)
-{
-    int i, j = 0, len;
-    ScriptObj *script;
-    ScriptToken *token;
-    int *cs; /* command structure array */
-    int retcode = JIM_OK;
-    Jim_Obj *sargv[JIM_EVAL_SARGV_LEN], **argv = NULL, *tmpObjPtr;
-
-    interp-&gt;errorFlag = 0;
-
-    /* If the object is of type &quot;list&quot; and there is no
-     * string representation for this object, we can call
-     * a specialized version of Jim_EvalObj() */
-    if (scriptObjPtr-&gt;typePtr == &amp;listObjType &amp;&amp;
-        scriptObjPtr-&gt;internalRep.listValue.len &amp;&amp;
-        scriptObjPtr-&gt;bytes == NULL) {
-        Jim_IncrRefCount(scriptObjPtr);
-        retcode = Jim_EvalObjVector(interp,
-                scriptObjPtr-&gt;internalRep.listValue.len,
-                scriptObjPtr-&gt;internalRep.listValue.ele);
-        Jim_DecrRefCount(interp, scriptObjPtr);
-        return retcode;
-    }
-
-    Jim_IncrRefCount(scriptObjPtr); /* Make sure it's shared. */
-    script = Jim_GetScript(interp, scriptObjPtr);
-    /* Now we have to make sure the internal repr will not be
-     * freed on shimmering.
-     *
-     * Think for example to this:
-     *
-     * set x {llength $x; ... some more code ...}; eval $x
-     *
-     * In order to preserve the internal rep, we increment the
-     * inUse field of the script internal rep structure. */
-    script-&gt;inUse++;
-
-    token = script-&gt;token;
-    len = script-&gt;len;
-    cs = script-&gt;cmdStruct;
-    i = 0; /* 'i' is the current token index. */
-
-    /* Reset the interpreter result. This is useful to
-     * return the emtpy result in the case of empty program. */
-    Jim_SetEmptyResult(interp);
-
-    /* Execute every command sequentially, returns on
-     * error (i.e. if a command does not return JIM_OK) */
-    while (i &lt; len) {
-        int expand = 0;
-        int argc = *cs++; /* Get the number of arguments */
-        Jim_Cmd *cmd;
-
-        /* Set the expand flag if needed. */
-        if (argc == -1) {
-            expand++;
-            argc = *cs++;
-        }
-        /* Allocate the arguments vector */
-        if (argc &lt;= JIM_EVAL_SARGV_LEN)
-            argv = sargv;
-        else
-            argv = Jim_Alloc(sizeof(Jim_Obj*)*argc);
-        /* Populate the arguments objects. */
-        for (j = 0; j &lt; argc; j++) {
-            int tokens = *cs++;
-
-            /* tokens is negative if expansion is needed.
-             * for this argument. */
-            if (tokens &lt; 0) {
-                tokens = (-tokens)-1;
-                i++;
-            }
-            if (tokens == 1) {
-                /* Fast path if the token does not
-                 * need interpolation */
-                switch (token[i].type) {
-                case JIM_TT_ESC:
-                case JIM_TT_STR:
-                    argv[j] = token[i].objPtr;
-                    break;
-                case JIM_TT_VAR:
-                    tmpObjPtr = Jim_GetVariable(interp, token[i].objPtr,
-                            JIM_ERRMSG);
-                    if (!tmpObjPtr) {
-                        retcode = JIM_ERR;
-                        goto err;
-                    }
-                    argv[j] = tmpObjPtr;
-                    break;
-                case JIM_TT_DICTSUGAR:
-                    tmpObjPtr = Jim_ExpandDictSugar(interp, token[i].objPtr);
-                    if (!tmpObjPtr) {
-                        retcode = JIM_ERR;
-                        goto err;
-                    }
-                    argv[j] = tmpObjPtr;
-                    break;
-                case JIM_TT_CMD:
-                    retcode = Jim_EvalObj(interp, token[i].objPtr);
-                    if (retcode != JIM_OK)
-                        goto err;
-                    argv[j] = Jim_GetResult(interp);
-                    break;
-                default:
-                    Jim_Panic(interp,
-                      &quot;default token type reached &quot;
-                      &quot;in Jim_EvalObj().&quot;);
-                    break;
-                }
-                Jim_IncrRefCount(argv[j]);
-                i += 2;
-            } else {
-                /* For interpolation we call an helper
-                 * function doing the work for us. */
-                if ((retcode = Jim_InterpolateTokens(interp,
-                        token + i, tokens, &amp;tmpObjPtr)) != JIM_OK)
-                {
-                    goto err;
-                }
-                argv[j] = tmpObjPtr;
-                Jim_IncrRefCount(argv[j]);
-                i += tokens + 1;
-            }
-        }
-        /* Handle {expand} expansion */
-        if (expand) {
-            int *ecs = cs - argc;
-            int eargc = 0;
-            Jim_Obj **eargv = NULL;
-
-            for (j = 0; j &lt; argc; j++) {
-                Jim_ExpandArgument(interp, &amp;eargv, &amp;eargc,
-                        ecs[j] &lt; 0, argv[j]);
-            }
-            if (argv != sargv)
-                Jim_Free(argv);
-            argc = eargc;
-            argv = eargv;
-            j = argc;
-            if (argc == 0) {
-                /* Nothing to do with zero args. */
-                Jim_Free(eargv);
-                continue;
-            }
-        }
-        /* Lookup the command to call */
-        cmd = Jim_GetCommand(interp, argv[0], JIM_ERRMSG);
-        if (cmd != NULL) {
-            /* Call it -- Make sure result is an empty object. */
-            Jim_SetEmptyResult(interp);
-            if (cmd-&gt;cmdProc) {
-                interp-&gt;cmdPrivData = cmd-&gt;privData;
-                retcode = cmd-&gt;cmdProc(interp, argc, argv);
-                if ((retcode == JIM_ERR)||(retcode == JIM_ERR_ADDSTACK)) {
-                    JimAppendStackTrace(interp, &quot;&quot;, script-&gt;fileName, token[i-argc*2].linenr);
-                    retcode = JIM_ERR;
-                }
-            } else {
-                retcode = JimCallProcedure(interp, cmd, argc, argv);
-                if (retcode == JIM_ERR) {
-                    JimAppendStackTrace(interp,
-                        Jim_GetString(argv[0], NULL), script-&gt;fileName,
-                        token[i-argc*2].linenr);
-                }
-            }
-        } else {
-            /* Call [unknown] */
-            retcode = JimUnknown(interp, argc, argv);
-            if (retcode == JIM_ERR) {
-                JimAppendStackTrace(interp,
-                    &quot;&quot;, script-&gt;fileName,
-                    token[i-argc*2].linenr);
-            }
-        }
-        if (retcode != JIM_OK) {
-            i -= argc*2; /* point to the command name. */
-            goto err;
-        }
-        /* Decrement the arguments count */
-        for (j = 0; j &lt; argc; j++) {
-            Jim_DecrRefCount(interp, argv[j]);
-        }
-
-        if (argv != sargv) {
-            Jim_Free(argv);
-            argv = NULL;
-        }
-    }
-    /* Note that we don't have to decrement inUse, because the
-     * following code transfers our use of the reference again to
-     * the script object. */
-    j = 0; /* on normal termination, the argv array is already
-          Jim_DecrRefCount-ed. */
-err:
-    /* Handle errors. */
-    if (retcode == JIM_ERR &amp;&amp; !interp-&gt;errorFlag) {
-        interp-&gt;errorFlag = 1;
-        JimSetErrorFileName(interp, script-&gt;fileName);
-        JimSetErrorLineNumber(interp, token[i].linenr);
-        JimResetStackTrace(interp);
-    }
-    Jim_FreeIntRep(interp, scriptObjPtr);
-    scriptObjPtr-&gt;typePtr = &scriptObjType;
-    Jim_SetIntRepPtr(scriptObjPtr, script);
-    Jim_DecrRefCount(interp, scriptObjPtr);
-    for (i = 0; i &lt; j; i++) {
-        Jim_DecrRefCount(interp, argv[i]);
-    }
-    if (argv != sargv)
-        Jim_Free(argv);
-    return retcode;
-}
-
-/* Call a procedure implemented in Tcl.
- * It's possible to speed-up a lot this function, currently
- * the callframes are not cached, but allocated and
- * destroied every time. What is expecially costly is
- * to create/destroy the local vars hash table every time.
- *
- * This can be fixed just implementing callframes caching
- * in JimCreateCallFrame() and JimFreeCallFrame(). */
-int JimCallProcedure(Jim_Interp *interp, Jim_Cmd *cmd, int argc,
-        Jim_Obj *const *argv)
-{
-    int i, retcode;
-    Jim_CallFrame *callFramePtr;
-    int num_args;
-
-    /* Check arity */
-    if (argc &lt; cmd-&gt;arityMin || (cmd-&gt;arityMax != -1 &amp;&amp;
-        argc &gt; cmd-&gt;arityMax)) {
-        Jim_Obj *objPtr = Jim_NewEmptyStringObj(interp);
-        Jim_AppendStrings(interp, objPtr,
-            &quot;wrong # args: should be \&quot;&quot;, Jim_GetString(argv[0], NULL),
-            (cmd-&gt;arityMin &gt; 1) ? &quot; &quot; : &quot;&quot;,
-            Jim_GetString(cmd-&gt;argListObjPtr, NULL), &quot;\&quot;&quot;, NULL);
-        Jim_SetResult(interp, objPtr);
-        return JIM_ERR;
-    }
-    /* Check if there are too nested calls */
-    if (interp-&gt;numLevels == interp-&gt;maxNestingDepth) {
-        Jim_SetResultString(interp,
-            &quot;Too many nested calls. Infinite recursion?&quot;, -1);
-        return JIM_ERR;
-    }
-    /* Create a new callframe */
-    callFramePtr = JimCreateCallFrame(interp);
-    callFramePtr-&gt;parentCallFrame = interp-&gt;framePtr;
-    callFramePtr-&gt;argv = argv;
-    callFramePtr-&gt;argc = argc;
-    callFramePtr-&gt;procArgsObjPtr = cmd-&gt;argListObjPtr;
-    callFramePtr-&gt;procBodyObjPtr = cmd-&gt;bodyObjPtr;
-    callFramePtr-&gt;staticVars = cmd-&gt;staticVars;
-    Jim_IncrRefCount(cmd-&gt;argListObjPtr);
-    Jim_IncrRefCount(cmd-&gt;bodyObjPtr);
-    interp-&gt;framePtr = callFramePtr;
-    interp-&gt;numLevels ++;
-
-    /* Set arguments */
-    Jim_ListLength(interp, cmd-&gt;argListObjPtr, &amp;num_args);
-
-    /* If last argument is 'args', don't set it here */
-    if (cmd-&gt;arityMax == -1) {
-        num_args--;
-    }
-
-    for (i = 0; i &lt; num_args; i++) {
-        Jim_Obj *argObjPtr=NULL;
-        Jim_Obj *nameObjPtr=NULL;
-        Jim_Obj *valueObjPtr=NULL;
-
-        Jim_ListIndex(interp, cmd-&gt;argListObjPtr, i, &amp;argObjPtr, JIM_NONE);
-        if (i + 1 &gt;= cmd-&gt;arityMin) {
-            /* The name is the first element of the list */
-            Jim_ListIndex(interp, argObjPtr, 0, &amp;nameObjPtr, JIM_NONE);
-        }
-        else {
-            /* The element arg is the name */
-            nameObjPtr = argObjPtr;
-        }
-
-        if (i + 1 &gt;= argc) {
-            /* No more values, so use default */
-            /* The value is the second element of the list */
-            Jim_ListIndex(interp, argObjPtr, 1, &amp;valueObjPtr, JIM_NONE);
-        }
-        else {
-            valueObjPtr = argv[i + 1];
-        }
-        Jim_SetVariable(interp, nameObjPtr, valueObjPtr);
-    }
-    /* Set optional arguments */
-    if (cmd-&gt;arityMax == -1) {
-        Jim_Obj *listObjPtr=NULL, *objPtr=NULL;
-
-        i++;
-        listObjPtr = Jim_NewListObj(interp, argv + i, argc-i);
-        Jim_ListIndex(interp, cmd-&gt;argListObjPtr, num_args, &amp;objPtr, JIM_NONE);
-        Jim_SetVariable(interp, objPtr, listObjPtr);
-    }
-    /* Eval the body */
-    retcode = Jim_EvalObj(interp, cmd-&gt;bodyObjPtr);
-
-    /* Destroy the callframe */
-    interp-&gt;numLevels --;
-    interp-&gt;framePtr = interp-&gt;framePtr-&gt;parentCallFrame;
-    if (callFramePtr-&gt;vars.size != JIM_HT_INITIAL_SIZE) {
-        JimFreeCallFrame(interp, callFramePtr, JIM_FCF_NONE);
-    } else {
-        JimFreeCallFrame(interp, callFramePtr, JIM_FCF_NOHT);
-    }
-    /* Handle the JIM_EVAL return code */
-    if (retcode == JIM_EVAL &amp;&amp; interp-&gt;evalRetcodeLevel != interp-&gt;numLevels) {
-        int savedLevel = interp-&gt;evalRetcodeLevel;
-
-        interp-&gt;evalRetcodeLevel = interp-&gt;numLevels;
-        while (retcode == JIM_EVAL) {
-            Jim_Obj *resultScriptObjPtr = Jim_GetResult(interp);
-            Jim_IncrRefCount(resultScriptObjPtr);
-            retcode = Jim_EvalObj(interp, resultScriptObjPtr);
-            Jim_DecrRefCount(interp, resultScriptObjPtr);
-        }
-        interp-&gt;evalRetcodeLevel = savedLevel;
-    }
-    /* Handle the JIM_RETURN return code */
-    if (retcode == JIM_RETURN) {
-        retcode = interp-&gt;returnCode;
-        interp-&gt;returnCode = JIM_OK;
-    }
-    return retcode;
-}
-
-int Jim_Eval_Named(Jim_Interp *interp, const char *script, const char *filename, int lineno)
-{
-    int retval;
-    Jim_Obj *scriptObjPtr;
-
-	scriptObjPtr = Jim_NewStringObj(interp, script, -1);
-    Jim_IncrRefCount(scriptObjPtr);
-
-
-	if (filename) {
-		JimSetSourceInfo(interp, scriptObjPtr, filename, lineno);
-	}
-
-    retval = Jim_EvalObj(interp, scriptObjPtr);
-    Jim_DecrRefCount(interp, scriptObjPtr);
-    return retval;
-}
-
-int Jim_Eval(Jim_Interp *interp, const char *script)
-{
-	return Jim_Eval_Named(interp, script, NULL, 0);
-}
-
-
-
-/* Execute script in the scope of the global level */
-int Jim_EvalGlobal(Jim_Interp *interp, const char *script)
-{
-    Jim_CallFrame *savedFramePtr;
-    int retval;
-
-    savedFramePtr = interp-&gt;framePtr;
-    interp-&gt;framePtr = interp-&gt;topFramePtr;
-    retval = Jim_Eval(interp, script);
-    interp-&gt;framePtr = savedFramePtr;
-    return retval;
-}
-
-int Jim_EvalObjBackground(Jim_Interp *interp, Jim_Obj *scriptObjPtr)
-{
-    Jim_CallFrame *savedFramePtr;
-    int retval;
-
-    savedFramePtr = interp-&gt;framePtr;
-    interp-&gt;framePtr = interp-&gt;topFramePtr;
-    retval = Jim_EvalObj(interp, scriptObjPtr);
-    interp-&gt;framePtr = savedFramePtr;
-    /* Try to report the error (if any) via the bgerror proc */
-    if (retval != JIM_OK) {
-        Jim_Obj *objv[2];
-
-        objv[0] = Jim_NewStringObj(interp, &quot;bgerror&quot;, -1);
-        objv[1] = Jim_GetResult(interp);
-        Jim_IncrRefCount(objv[0]);
-        Jim_IncrRefCount(objv[1]);
-        if (Jim_EvalObjVector(interp, 2, objv) != JIM_OK) {
-            /* Report the error to stderr. */
-            Jim_fprintf(interp, interp-&gt;cookie_stderr, &quot;Background error:&quot; JIM_NL);
-            Jim_PrintErrorMessage(interp);
-        }
-        Jim_DecrRefCount(interp, objv[0]);
-        Jim_DecrRefCount(interp, objv[1]);
-    }
-    return retval;
-}
-
-int Jim_EvalFile(Jim_Interp *interp, const char *filename)
-{
-    char *prg = NULL;
-    FILE *fp;
-    int nread, totread, maxlen, buflen;
-    int retval;
-    Jim_Obj *scriptObjPtr;
-
-    if ((fp = fopen(filename, &quot;r&quot;)) == NULL) {
-    	const int cwd_len = 2048;
-		char *cwd = malloc(cwd_len);
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-	if (!getcwd(cwd, cwd_len)) strcpy(cwd, &quot;unknown&quot;);
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-	&quot;Error loading script \&quot;&quot;, filename, &quot;\&quot;&quot;,
-	    &quot; cwd: &quot;, cwd,
-	    &quot; err: &quot;, strerror(errno), NULL);
-	    free(cwd);
-        return JIM_ERR;
-    }
-    buflen = 1024;
-    maxlen = totread = 0;
-    while (1) {
-        if (maxlen &lt; totread + buflen + 1) {
-            maxlen = totread + buflen + 1;
-            prg = Jim_Realloc(prg, maxlen);
-        }
-		/* do not use Jim_fread() - this is really a file */
-        if ((nread = fread(prg + totread, 1, buflen, fp)) == 0) break;
-        totread += nread;
-    }
-    prg[totread] = '\0';
-	/* do not use Jim_fclose() - this is really a file */
-    fclose(fp);
-
-    scriptObjPtr = Jim_NewStringObjNoAlloc(interp, prg, totread);
-    JimSetSourceInfo(interp, scriptObjPtr, filename, 1);
-    Jim_IncrRefCount(scriptObjPtr);
-    retval = Jim_EvalObj(interp, scriptObjPtr);
-    Jim_DecrRefCount(interp, scriptObjPtr);
-    return retval;
-}
-
-/* -----------------------------------------------------------------------------
- * Subst
- * ---------------------------------------------------------------------------*/
-static int JimParseSubstStr(struct JimParserCtx *pc)
-{
-    pc-&gt;tstart = pc-&gt;p;
-    pc-&gt;tline = pc-&gt;linenr;
-    while (*pc-&gt;p &amp;&amp; *pc-&gt;p != '$' &amp;&amp; *pc-&gt;p != '[') {
-        pc-&gt;p++; pc-&gt;len--;
-    }
-    pc-&gt;tend = pc-&gt;p-1;
-    pc-&gt;tt = JIM_TT_ESC;
-    return JIM_OK;
-}
-
-static int JimParseSubst(struct JimParserCtx *pc, int flags)
-{
-    int retval;
-
-    if (pc-&gt;len == 0) {
-        pc-&gt;tstart = pc-&gt;tend = pc-&gt;p;
-        pc-&gt;tline = pc-&gt;linenr;
-        pc-&gt;tt = JIM_TT_EOL;
-        pc-&gt;eof = 1;
-        return JIM_OK;
-    }
-    switch (*pc-&gt;p) {
-    case '[':
-        retval = JimParseCmd(pc);
-        if (flags &amp; JIM_SUBST_NOCMD) {
-            pc-&gt;tstart--;
-            pc-&gt;tend++;
-            pc-&gt;tt = (flags &amp; JIM_SUBST_NOESC) ?
-                JIM_TT_STR : JIM_TT_ESC;
-        }
-        return retval;
-        break;
-    case '$':
-        if (JimParseVar(pc) == JIM_ERR) {
-            pc-&gt;tstart = pc-&gt;tend = pc-&gt;p++; pc-&gt;len--;
-            pc-&gt;tline = pc-&gt;linenr;
-            pc-&gt;tt = JIM_TT_STR;
-        } else {
-            if (flags &amp; JIM_SUBST_NOVAR) {
-                pc-&gt;tstart--;
-                if (flags &amp; JIM_SUBST_NOESC)
-                    pc-&gt;tt = JIM_TT_STR;
-                else
-                    pc-&gt;tt = JIM_TT_ESC;
-                if (*pc-&gt;tstart == '{') {
-                    pc-&gt;tstart--;
-                    if (*(pc-&gt;tend + 1))
-                        pc-&gt;tend++;
-                }
-            }
-        }
-        break;
-    default:
-        retval = JimParseSubstStr(pc);
-        if (flags &amp; JIM_SUBST_NOESC)
-            pc-&gt;tt = JIM_TT_STR;
-        return retval;
-        break;
-    }
-    return JIM_OK;
-}
-
-/* The subst object type reuses most of the data structures and functions
- * of the script object. Script's data structures are a bit more complex
- * for what is needed for [subst]itution tasks, but the reuse helps to
- * deal with a single data structure at the cost of some more memory
- * usage for substitutions. */
-static Jim_ObjType substObjType = {
-    &quot;subst&quot;,
-    FreeScriptInternalRep,
-    DupScriptInternalRep,
-    NULL,
-    JIM_TYPE_REFERENCES,
-};
-
-/* This method takes the string representation of an object
- * as a Tcl string where to perform [subst]itution, and generates
- * the pre-parsed internal representation. */
-int SetSubstFromAny(Jim_Interp *interp, struct Jim_Obj *objPtr, int flags)
-{
-    int scriptTextLen;
-    const char *scriptText = Jim_GetString(objPtr, &amp;scriptTextLen);
-    struct JimParserCtx parser;
-    struct ScriptObj *script = Jim_Alloc(sizeof(*script));
-
-    script-&gt;len = 0;
-    script-&gt;csLen = 0;
-    script-&gt;commands = 0;
-    script-&gt;token = NULL;
-    script-&gt;cmdStruct = NULL;
-    script-&gt;inUse = 1;
-    script-&gt;substFlags = flags;
-    script-&gt;fileName = NULL;
-
-    JimParserInit(&amp;parser, scriptText, scriptTextLen, 1);
-    while (1) {
-        char *token;
-        int len, type, linenr;
-
-        JimParseSubst(&amp;parser, flags);
-        if (JimParserEof(&amp;parser)) break;
-        token = JimParserGetToken(&amp;parser, &amp;len, &amp;type, &amp;linenr);
-        ScriptObjAddToken(interp, script, token, len, type,
-                NULL, linenr);
-    }
-    /* Free the old internal rep and set the new one. */
-    Jim_FreeIntRep(interp, objPtr);
-    Jim_SetIntRepPtr(objPtr, script);
-    objPtr-&gt;typePtr = &scriptObjType;
-    return JIM_OK;
-}
-
-ScriptObj *Jim_GetSubst(Jim_Interp *interp, Jim_Obj *objPtr, int flags)
-{
-    struct ScriptObj *script = Jim_GetIntRepPtr(objPtr);
-
-    if (objPtr-&gt;typePtr != &amp;substObjType || script-&gt;substFlags != flags)
-        SetSubstFromAny(interp, objPtr, flags);
-    return (ScriptObj*) Jim_GetIntRepPtr(objPtr);
-}
-
-/* Performs commands,variables,blackslashes substitution,
- * storing the result object (with refcount 0) into
- * resObjPtrPtr. */
-int Jim_SubstObj(Jim_Interp *interp, Jim_Obj *substObjPtr,
-        Jim_Obj **resObjPtrPtr, int flags)
-{
-    ScriptObj *script;
-    ScriptToken *token;
-    int i, len, retcode = JIM_OK;
-    Jim_Obj *resObjPtr, *savedResultObjPtr;
-
-    script = Jim_GetSubst(interp, substObjPtr, flags);
-#ifdef JIM_OPTIMIZATION
-    /* Fast path for a very common case with array-alike syntax,
-     * that's: $foo($bar) */
-    if (script-&gt;len == 1 &amp;&amp; script-&gt;token[0].type == JIM_TT_VAR) {
-        Jim_Obj *varObjPtr = script-&gt;token[0].objPtr;
-
-        Jim_IncrRefCount(varObjPtr);
-        resObjPtr = Jim_GetVariable(interp, varObjPtr, JIM_ERRMSG);
-        if (resObjPtr == NULL) {
-            Jim_DecrRefCount(interp, varObjPtr);
-            return JIM_ERR;
-        }
-        Jim_DecrRefCount(interp, varObjPtr);
-        *resObjPtrPtr = resObjPtr;
-        return JIM_OK;
-    }
-#endif
-
-    Jim_IncrRefCount(substObjPtr); /* Make sure it's shared. */
-    /* In order to preserve the internal rep, we increment the
-     * inUse field of the script internal rep structure. */
-    script-&gt;inUse++;
-
-    token = script-&gt;token;
-    len = script-&gt;len;
-
-    /* Save the interp old result, to set it again before
-     * to return. */
-    savedResultObjPtr = interp-&gt;result;
-    Jim_IncrRefCount(savedResultObjPtr);
-
-    /* Perform the substitution. Starts with an empty object
-     * and adds every token (performing the appropriate
-     * var/command/escape substitution). */
-    resObjPtr = Jim_NewStringObj(interp, &quot;&quot;, 0);
-    for (i = 0; i &lt; len; i++) {
-        Jim_Obj *objPtr;
-
-        switch (token[i].type) {
-        case JIM_TT_STR:
-        case JIM_TT_ESC:
-            Jim_AppendObj(interp, resObjPtr, token[i].objPtr);
-            break;
-        case JIM_TT_VAR:
-            objPtr = Jim_GetVariable(interp, token[i].objPtr, JIM_ERRMSG);
-            if (objPtr == NULL) goto err;
-            Jim_IncrRefCount(objPtr);
-            Jim_AppendObj(interp, resObjPtr, objPtr);
-            Jim_DecrRefCount(interp, objPtr);
-            break;
-        case JIM_TT_DICTSUGAR:
-            objPtr = Jim_ExpandDictSugar(interp, token[i].objPtr);
-            if (!objPtr) {
-                retcode = JIM_ERR;
-                goto err;
-            }
-            break;
-        case JIM_TT_CMD:
-            if (Jim_EvalObj(interp, token[i].objPtr) != JIM_OK)
-                goto err;
-            Jim_AppendObj(interp, resObjPtr, interp-&gt;result);
-            break;
-        default:
-            Jim_Panic(interp,
-              &quot;default token type (%d) reached &quot;
-              &quot;in Jim_SubstObj().&quot;, token[i].type);
-            break;
-        }
-    }
-ok:
-    if (retcode == JIM_OK)
-        Jim_SetResult(interp, savedResultObjPtr);
-    Jim_DecrRefCount(interp, savedResultObjPtr);
-    /* Note that we don't have to decrement inUse, because the
-     * following code transfers our use of the reference again to
-     * the script object. */
-    Jim_FreeIntRep(interp, substObjPtr);
-    substObjPtr-&gt;typePtr = &scriptObjType;
-    Jim_SetIntRepPtr(substObjPtr, script);
-    Jim_DecrRefCount(interp, substObjPtr);
-    *resObjPtrPtr = resObjPtr;
-    return retcode;
-err:
-    Jim_FreeNewObj(interp, resObjPtr);
-    retcode = JIM_ERR;
-    goto ok;
-}
-
-/* -----------------------------------------------------------------------------
- * API Input/Export functions
- * ---------------------------------------------------------------------------*/
-
-int Jim_GetApi(Jim_Interp *interp, const char *funcname, void *targetPtrPtr)
-{
-    Jim_HashEntry *he;
-
-    he = Jim_FindHashEntry(&amp;interp-&gt;stub, funcname);
-    if (!he)
-        return JIM_ERR;
-    memcpy(targetPtrPtr, &amp;he-&gt;val, sizeof(void*));
-    return JIM_OK;
-}
-
-int Jim_RegisterApi(Jim_Interp *interp, const char *funcname, void *funcptr)
-{
-    return Jim_AddHashEntry(&amp;interp-&gt;stub, funcname, funcptr);
-}
-
-#define JIM_REGISTER_API(name) \
-    Jim_RegisterApi(interp, &quot;Jim_&quot; #name, (void *)Jim_ ## name)
-
-void JimRegisterCoreApi(Jim_Interp *interp)
-{
-  interp-&gt;getApiFuncPtr = Jim_GetApi;
-  JIM_REGISTER_API(Alloc);
-  JIM_REGISTER_API(Free);
-  JIM_REGISTER_API(Eval);
-  JIM_REGISTER_API(Eval_Named);
-  JIM_REGISTER_API(EvalGlobal);
-  JIM_REGISTER_API(EvalFile);
-  JIM_REGISTER_API(EvalObj);
-  JIM_REGISTER_API(EvalObjBackground);
-  JIM_REGISTER_API(EvalObjVector);
-  JIM_REGISTER_API(InitHashTable);
-  JIM_REGISTER_API(ExpandHashTable);
-  JIM_REGISTER_API(AddHashEntry);
-  JIM_REGISTER_API(ReplaceHashEntry);
-  JIM_REGISTER_API(DeleteHashEntry);
-  JIM_REGISTER_API(FreeHashTable);
-  JIM_REGISTER_API(FindHashEntry);
-  JIM_REGISTER_API(ResizeHashTable);
-  JIM_REGISTER_API(GetHashTableIterator);
-  JIM_REGISTER_API(NextHashEntry);
-  JIM_REGISTER_API(NewObj);
-  JIM_REGISTER_API(FreeObj);
-  JIM_REGISTER_API(InvalidateStringRep);
-  JIM_REGISTER_API(InitStringRep);
-  JIM_REGISTER_API(DuplicateObj);
-  JIM_REGISTER_API(GetString);
-  JIM_REGISTER_API(Length);
-  JIM_REGISTER_API(InvalidateStringRep);
-  JIM_REGISTER_API(NewStringObj);
-  JIM_REGISTER_API(NewStringObjNoAlloc);
-  JIM_REGISTER_API(AppendString);
-  JIM_REGISTER_API(AppendString_sprintf);
-  JIM_REGISTER_API(AppendObj);
-  JIM_REGISTER_API(AppendStrings);
-  JIM_REGISTER_API(StringEqObj);
-  JIM_REGISTER_API(StringMatchObj);
-  JIM_REGISTER_API(StringRangeObj);
-  JIM_REGISTER_API(FormatString);
-  JIM_REGISTER_API(CompareStringImmediate);
-  JIM_REGISTER_API(NewReference);
-  JIM_REGISTER_API(GetReference);
-  JIM_REGISTER_API(SetFinalizer);
-  JIM_REGISTER_API(GetFinalizer);
-  JIM_REGISTER_API(CreateInterp);
-  JIM_REGISTER_API(FreeInterp);
-  JIM_REGISTER_API(GetExitCode);
-  JIM_REGISTER_API(SetStdin);
-  JIM_REGISTER_API(SetStdout);
-  JIM_REGISTER_API(SetStderr);
-  JIM_REGISTER_API(CreateCommand);
-  JIM_REGISTER_API(CreateProcedure);
-  JIM_REGISTER_API(DeleteCommand);
-  JIM_REGISTER_API(RenameCommand);
-  JIM_REGISTER_API(GetCommand);
-  JIM_REGISTER_API(SetVariable);
-  JIM_REGISTER_API(SetVariableStr);
-  JIM_REGISTER_API(SetGlobalVariableStr);
-  JIM_REGISTER_API(SetVariableStrWithStr);
-  JIM_REGISTER_API(SetVariableLink);
-  JIM_REGISTER_API(GetVariable);
-  JIM_REGISTER_API(GetCallFrameByLevel);
-  JIM_REGISTER_API(Collect);
-  JIM_REGISTER_API(CollectIfNeeded);
-  JIM_REGISTER_API(GetIndex);
-  JIM_REGISTER_API(NewListObj);
-  JIM_REGISTER_API(ListAppendElement);
-  JIM_REGISTER_API(ListAppendList);
-  JIM_REGISTER_API(ListLength);
-  JIM_REGISTER_API(ListIndex);
-  JIM_REGISTER_API(SetListIndex);
-  JIM_REGISTER_API(ConcatObj);
-  JIM_REGISTER_API(NewDictObj);
-  JIM_REGISTER_API(DictKey);
-  JIM_REGISTER_API(DictKeysVector);
-  JIM_REGISTER_API(GetIndex);
-  JIM_REGISTER_API(GetReturnCode);
-  JIM_REGISTER_API(EvalExpression);
-  JIM_REGISTER_API(GetBoolFromExpr);
-  JIM_REGISTER_API(GetWide);
-  JIM_REGISTER_API(GetLong);
-  JIM_REGISTER_API(SetWide);
-  JIM_REGISTER_API(NewIntObj);
-  JIM_REGISTER_API(GetDouble);
-  JIM_REGISTER_API(SetDouble);
-  JIM_REGISTER_API(NewDoubleObj);
-  JIM_REGISTER_API(WrongNumArgs);
-  JIM_REGISTER_API(SetDictKeysVector);
-  JIM_REGISTER_API(SubstObj);
-  JIM_REGISTER_API(RegisterApi);
-  JIM_REGISTER_API(PrintErrorMessage);
-  JIM_REGISTER_API(InteractivePrompt);
-  JIM_REGISTER_API(RegisterCoreCommands);
-  JIM_REGISTER_API(GetSharedString);
-  JIM_REGISTER_API(ReleaseSharedString);
-  JIM_REGISTER_API(Panic);
-  JIM_REGISTER_API(StrDup);
-  JIM_REGISTER_API(UnsetVariable);
-  JIM_REGISTER_API(GetVariableStr);
-  JIM_REGISTER_API(GetGlobalVariable);
-  JIM_REGISTER_API(GetGlobalVariableStr);
-  JIM_REGISTER_API(GetAssocData);
-  JIM_REGISTER_API(SetAssocData);
-  JIM_REGISTER_API(DeleteAssocData);
-  JIM_REGISTER_API(GetEnum);
-  JIM_REGISTER_API(ScriptIsComplete);
-  JIM_REGISTER_API(PackageRequire);
-  JIM_REGISTER_API(PackageProvide);
-  JIM_REGISTER_API(InitStack);
-  JIM_REGISTER_API(FreeStack);
-  JIM_REGISTER_API(StackLen);
-  JIM_REGISTER_API(StackPush);
-  JIM_REGISTER_API(StackPop);
-  JIM_REGISTER_API(StackPeek);
-  JIM_REGISTER_API(FreeStackElements);
-  JIM_REGISTER_API(fprintf);
-  JIM_REGISTER_API(vfprintf);
-  JIM_REGISTER_API(fwrite);
-  JIM_REGISTER_API(fread);
-  JIM_REGISTER_API(fflush);
-  JIM_REGISTER_API(fgets);
-  JIM_REGISTER_API(GetNvp);
-  JIM_REGISTER_API(Nvp_name2value);
-  JIM_REGISTER_API(Nvp_name2value_simple);
-  JIM_REGISTER_API(Nvp_name2value_obj);
-  JIM_REGISTER_API(Nvp_name2value_nocase);
-  JIM_REGISTER_API(Nvp_name2value_obj_nocase);
-
-  JIM_REGISTER_API(Nvp_value2name);
-  JIM_REGISTER_API(Nvp_value2name_simple);
-  JIM_REGISTER_API(Nvp_value2name_obj);
-
-  JIM_REGISTER_API(GetOpt_Setup);
-  JIM_REGISTER_API(GetOpt_Debug);
-  JIM_REGISTER_API(GetOpt_Obj);
-  JIM_REGISTER_API(GetOpt_String);
-  JIM_REGISTER_API(GetOpt_Double);
-  JIM_REGISTER_API(GetOpt_Wide);
-  JIM_REGISTER_API(GetOpt_Nvp);
-  JIM_REGISTER_API(GetOpt_NvpUnknown);
-  JIM_REGISTER_API(GetOpt_Enum);
-
-  JIM_REGISTER_API(Debug_ArgvString);
-  JIM_REGISTER_API(SetResult_sprintf);
-  JIM_REGISTER_API(SetResult_NvpUnknown);
-
-}
-
-/* -----------------------------------------------------------------------------
- * Core commands utility functions
- * ---------------------------------------------------------------------------*/
-void Jim_WrongNumArgs(Jim_Interp *interp, int argc, Jim_Obj *const *argv,
-        const char *msg)
-{
-    int i;
-    Jim_Obj *objPtr = Jim_NewEmptyStringObj(interp);
-
-    Jim_AppendString(interp, objPtr, &quot;wrong # args: should be \&quot;&quot;, -1);
-    for (i = 0; i &lt; argc; i++) {
-        Jim_AppendObj(interp, objPtr, argv[i]);
-        if (!(i + 1 == argc &amp;&amp; msg[0] == '\0'))
-            Jim_AppendString(interp, objPtr, &quot; &quot;, 1);
-    }
-    Jim_AppendString(interp, objPtr, msg, -1);
-    Jim_AppendString(interp, objPtr, &quot;\&quot;&quot;, 1);
-    Jim_SetResult(interp, objPtr);
-}
-
-static Jim_Obj *JimCommandsList(Jim_Interp *interp, Jim_Obj *patternObjPtr)
-{
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
-    const char *pattern;
-    int patternLen=0;
-
-    pattern = patternObjPtr ? Jim_GetString(patternObjPtr, &amp;patternLen) : NULL;
-    htiter = Jim_GetHashTableIterator(&amp;interp-&gt;commands);
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        if (pattern &amp;&amp; !JimStringMatch(pattern, patternLen, he-&gt;key,
-                    strlen((const char*)he-&gt;key), 0))
-            continue;
-        Jim_ListAppendElement(interp, listObjPtr,
-                Jim_NewStringObj(interp, he-&gt;key, -1));
-    }
-    Jim_FreeHashTableIterator(htiter);
-    return listObjPtr;
-}
-
-#define JIM_VARLIST_GLOBALS 0
-#define JIM_VARLIST_LOCALS 1
-#define JIM_VARLIST_VARS 2
-
-static Jim_Obj *JimVariablesList(Jim_Interp *interp, Jim_Obj *patternObjPtr,
-        int mode)
-{
-    Jim_HashTableIterator *htiter;
-    Jim_HashEntry *he;
-    Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
-    const char *pattern;
-    int patternLen=0;
-
-    pattern = patternObjPtr ? Jim_GetString(patternObjPtr, &amp;patternLen) : NULL;
-    if (mode == JIM_VARLIST_GLOBALS) {
-        htiter = Jim_GetHashTableIterator(&amp;interp-&gt;topFramePtr-&gt;vars);
-    } else {
-        /* For [info locals], if we are at top level an emtpy list
-         * is returned. I don't agree, but we aim at compatibility (SS) */
-        if (mode == JIM_VARLIST_LOCALS &amp;&amp;
-            interp-&gt;framePtr == interp-&gt;topFramePtr)
-            return listObjPtr;
-        htiter = Jim_GetHashTableIterator(&amp;interp-&gt;framePtr-&gt;vars);
-    }
-    while ((he = Jim_NextHashEntry(htiter)) != NULL) {
-        Jim_Var *varPtr = (Jim_Var*) he-&gt;val;
-        if (mode == JIM_VARLIST_LOCALS) {
-            if (varPtr-&gt;linkFramePtr != NULL)
-                continue;
-        }
-        if (pattern &amp;&amp; !JimStringMatch(pattern, patternLen, he-&gt;key,
-                    strlen((const char*)he-&gt;key), 0))
-            continue;
-        Jim_ListAppendElement(interp, listObjPtr,
-                Jim_NewStringObj(interp, he-&gt;key, -1));
-    }
-    Jim_FreeHashTableIterator(htiter);
-    return listObjPtr;
-}
-
-static int JimInfoLevel(Jim_Interp *interp, Jim_Obj *levelObjPtr,
-        Jim_Obj **objPtrPtr)
-{
-    Jim_CallFrame *targetCallFrame;
-
-    if (JimGetCallFrameByInteger(interp, levelObjPtr, &amp;targetCallFrame)
-            != JIM_OK)
-        return JIM_ERR;
-    /* No proc call at toplevel callframe */
-    if (targetCallFrame == interp-&gt;topFramePtr) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;bad level \&quot;&quot;,
-                Jim_GetString(levelObjPtr, NULL), &quot;\&quot;&quot;, NULL);
-        return JIM_ERR;
-    }
-    *objPtrPtr = Jim_NewListObj(interp,
-            targetCallFrame-&gt;argv,
-            targetCallFrame-&gt;argc);
-    return JIM_OK;
-}
-
-/* -----------------------------------------------------------------------------
- * Core commands
- * ---------------------------------------------------------------------------*/
-
-/* fake [puts] -- not the real puts, just for debugging. */
-static int Jim_PutsCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *str;
-    int len, nonewline = 0;
-
-    if (argc != 2 &amp;&amp; argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;-nonewline string&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        if (!Jim_CompareStringImmediate(interp, argv[1], &quot;-nonewline&quot;))
-        {
-            Jim_SetResultString(interp, &quot;The second argument must &quot;
-                    &quot;be -nonewline&quot;, -1);
-            return JIM_OK;
-        } else {
-            nonewline = 1;
-            argv++;
-        }
-    }
-    str = Jim_GetString(argv[1], &amp;len);
-    Jim_fwrite(interp, str, 1, len, interp-&gt;cookie_stdout);
-    if (!nonewline) Jim_fprintf(interp, interp-&gt;cookie_stdout, JIM_NL);
-    return JIM_OK;
-}
-
-/* Helper for [+] and [*] */
-static int Jim_AddMulHelper(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv, int op)
-{
-    jim_wide wideValue, res;
-    double doubleValue, doubleRes;
-    int i;
-
-    res = (op == JIM_EXPROP_ADD) ? 0 : 1;
-
-    for (i = 1; i &lt; argc; i++) {
-        if (Jim_GetWide(interp, argv[i], &amp;wideValue) != JIM_OK)
-            goto trydouble;
-        if (op == JIM_EXPROP_ADD)
-            res += wideValue;
-        else
-            res *= wideValue;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, res));
-    return JIM_OK;
-trydouble:
-    doubleRes = (double) res;
-    for (;i &lt; argc; i++) {
-        if (Jim_GetDouble(interp, argv[i], &amp;doubleValue) != JIM_OK)
-            return JIM_ERR;
-        if (op == JIM_EXPROP_ADD)
-            doubleRes += doubleValue;
-        else
-            doubleRes *= doubleValue;
-    }
-    Jim_SetResult(interp, Jim_NewDoubleObj(interp, doubleRes));
-    return JIM_OK;
-}
-
-/* Helper for [-] and [/] */
-static int Jim_SubDivHelper(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv, int op)
-{
-    jim_wide wideValue, res = 0;
-    double doubleValue, doubleRes = 0;
-    int i = 2;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;number ?number ... number?&quot;);
-        return JIM_ERR;
-    } else if (argc == 2) {
-        /* The arity = 2 case is different. For [- x] returns -x,
-         * while [/ x] returns 1/x. */
-        if (Jim_GetWide(interp, argv[1], &amp;wideValue) != JIM_OK) {
-            if (Jim_GetDouble(interp, argv[1], &amp;doubleValue) !=
-                    JIM_OK)
-            {
-                return JIM_ERR;
-            } else {
-                if (op == JIM_EXPROP_SUB)
-                    doubleRes = -doubleValue;
-                else
-                    doubleRes = 1.0/doubleValue;
-                Jim_SetResult(interp, Jim_NewDoubleObj(interp,
-                            doubleRes));
-                return JIM_OK;
-            }
-        }
-        if (op == JIM_EXPROP_SUB) {
-            res = -wideValue;
-            Jim_SetResult(interp, Jim_NewIntObj(interp, res));
-        } else {
-            doubleRes = 1.0/wideValue;
-            Jim_SetResult(interp, Jim_NewDoubleObj(interp,
-                        doubleRes));
-        }
-        return JIM_OK;
-    } else {
-        if (Jim_GetWide(interp, argv[1], &amp;res) != JIM_OK) {
-            if (Jim_GetDouble(interp, argv[1], &amp;doubleRes)
-                    != JIM_OK) {
-                return JIM_ERR;
-            } else {
-                goto trydouble;
-            }
-        }
-    }
-    for (i = 2; i &lt; argc; i++) {
-        if (Jim_GetWide(interp, argv[i], &amp;wideValue) != JIM_OK) {
-            doubleRes = (double) res;
-            goto trydouble;
-        }
-        if (op == JIM_EXPROP_SUB)
-            res -= wideValue;
-        else
-            res /= wideValue;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, res));
-    return JIM_OK;
-trydouble:
-    for (;i &lt; argc; i++) {
-        if (Jim_GetDouble(interp, argv[i], &amp;doubleValue) != JIM_OK)
-            return JIM_ERR;
-        if (op == JIM_EXPROP_SUB)
-            doubleRes -= doubleValue;
-        else
-            doubleRes /= doubleValue;
-    }
-    Jim_SetResult(interp, Jim_NewDoubleObj(interp, doubleRes));
-    return JIM_OK;
-}
-
-
-/* [+] */
-static int Jim_AddCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_AddMulHelper(interp, argc, argv, JIM_EXPROP_ADD);
-}
-
-/* [*] */
-static int Jim_MulCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_AddMulHelper(interp, argc, argv, JIM_EXPROP_MUL);
-}
-
-/* [-] */
-static int Jim_SubCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_SubDivHelper(interp, argc, argv, JIM_EXPROP_SUB);
-}
-
-/* [/] */
-static int Jim_DivCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return Jim_SubDivHelper(interp, argc, argv, JIM_EXPROP_DIV);
-}
-
-/* [set] */
-static int Jim_SetCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 2 &amp;&amp; argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varName ?newValue?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        Jim_Obj *objPtr;
-        objPtr = Jim_GetVariable(interp, argv[1], JIM_ERRMSG);
-        if (!objPtr)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    }
-    /* argc == 3 case. */
-    if (Jim_SetVariable(interp, argv[1], argv[2]) != JIM_OK)
-        return JIM_ERR;
-    Jim_SetResult(interp, argv[2]);
-    return JIM_OK;
-}
-
-/* [unset] */
-static int Jim_UnsetCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int i;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varName ?varName ...?&quot;);
-        return JIM_ERR;
-    }
-    for (i = 1; i &lt; argc; i++) {
-        if (Jim_UnsetVariable(interp, argv[i], JIM_ERRMSG) != JIM_OK)
-            return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [incr] */
-static int Jim_IncrCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    jim_wide wideValue, increment = 1;
-    Jim_Obj *intObjPtr;
-
-    if (argc != 2 &amp;&amp; argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varName ?increment?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        if (Jim_GetWide(interp, argv[2], &amp;increment) != JIM_OK)
-            return JIM_ERR;
-    }
-    intObjPtr = Jim_GetVariable(interp, argv[1], JIM_ERRMSG);
-    if (!intObjPtr) return JIM_ERR;
-    if (Jim_GetWide(interp, intObjPtr, &amp;wideValue) != JIM_OK)
-        return JIM_ERR;
-    if (Jim_IsShared(intObjPtr)) {
-        intObjPtr = Jim_NewIntObj(interp, wideValue + increment);
-        if (Jim_SetVariable(interp, argv[1], intObjPtr) != JIM_OK) {
-            Jim_FreeNewObj(interp, intObjPtr);
-            return JIM_ERR;
-        }
-    } else {
-        Jim_SetWide(interp, intObjPtr, wideValue + increment);
-        /* The following step is required in order to invalidate the
-         * string repr of &quot;FOO&quot; if the var name is on the form of &quot;FOO(IDX)&quot; */
-        if (Jim_SetVariable(interp, argv[1], intObjPtr) != JIM_OK) {
-            return JIM_ERR;
-        }
-    }
-    Jim_SetResult(interp, intObjPtr);
-    return JIM_OK;
-}
-
-/* [while] */
-static int Jim_WhileCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;condition body&quot;);
-        return JIM_ERR;
-    }
-    /* Try to run a specialized version of while if the expression
-     * is in one of the following forms:
-     *
-     *   $a &lt; CONST, $a &lt; $b
-     *   $a &lt;= CONST, $a &lt;= $b
-     *   $a &gt; CONST, $a &gt; $b
-     *   $a &gt;= CONST, $a &gt;= $b
-     *   $a != CONST, $a != $b
-     *   $a == CONST, $a == $b
-     *   $a
-     *   !$a
-     *   CONST
-     */
-
-#ifdef JIM_OPTIMIZATION
-    {
-        ExprByteCode *expr;
-        Jim_Obj *varAObjPtr = NULL, *varBObjPtr = NULL, *objPtr;
-        int exprLen, retval;
-
-        /* STEP 1 -- Check if there are the conditions to run the specialized
-         * version of while */
-
-        if ((expr = Jim_GetExpression(interp, argv[1])) == NULL) goto noopt;
-        if (expr-&gt;len &lt;= 0 || expr-&gt;len &gt; 3) goto noopt;
-        switch (expr-&gt;len) {
-        case 1:
-            if (expr-&gt;opcode[0] != JIM_EXPROP_VARIABLE &amp;&amp;
-                expr-&gt;opcode[0] != JIM_EXPROP_NUMBER)
-                goto noopt;
-            break;
-        case 2:
-            if (expr-&gt;opcode[1] != JIM_EXPROP_NOT ||
-                expr-&gt;opcode[0] != JIM_EXPROP_VARIABLE)
-                goto noopt;
-            break;
-        case 3:
-            if (expr-&gt;opcode[0] != JIM_EXPROP_VARIABLE ||
-                (expr-&gt;opcode[1] != JIM_EXPROP_NUMBER &amp;&amp;
-                 expr-&gt;opcode[1] != JIM_EXPROP_VARIABLE))
-                goto noopt;
-            switch (expr-&gt;opcode[2]) {
-            case JIM_EXPROP_LT:
-            case JIM_EXPROP_LTE:
-            case JIM_EXPROP_GT:
-            case JIM_EXPROP_GTE:
-            case JIM_EXPROP_NUMEQ:
-            case JIM_EXPROP_NUMNE:
-                /* nothing to do */
-                break;
-            default:
-                goto noopt;
-            }
-            break;
-        default:
-            Jim_Panic(interp,
-                &quot;Unexpected default reached in Jim_WhileCoreCommand()&quot;);
-            break;
-        }
-
-        /* STEP 2 -- conditions meet. Initialization. Take different
-         * branches for different expression lengths. */
-        exprLen = expr-&gt;len;
-
-        if (exprLen == 1) {
-            jim_wide wideValue=0;
-
-            if (expr-&gt;opcode[0] == JIM_EXPROP_VARIABLE) {
-                varAObjPtr = expr-&gt;obj[0];
-                Jim_IncrRefCount(varAObjPtr);
-            } else {
-                if (Jim_GetWide(interp, expr-&gt;obj[0], &amp;wideValue) != JIM_OK)
-                    goto noopt;
-            }
-            while (1) {
-                if (varAObjPtr) {
-                    if (!(objPtr =
-                               Jim_GetVariable(interp, varAObjPtr, JIM_NONE)) ||
-                        Jim_GetWide(interp, objPtr, &amp;wideValue) != JIM_OK)
-                    {
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        goto noopt;
-                    }
-                }
-                if (!wideValue) break;
-                if ((retval = Jim_EvalObj(interp, argv[2])) != JIM_OK) {
-                    switch (retval) {
-                    case JIM_BREAK:
-                        if (varAObjPtr)
-                            Jim_DecrRefCount(interp, varAObjPtr);
-                        goto out;
-                        break;
-                    case JIM_CONTINUE:
-                        continue;
-                        break;
-                    default:
-                        if (varAObjPtr)
-                            Jim_DecrRefCount(interp, varAObjPtr);
-                        return retval;
-                    }
-                }
-            }
-            if (varAObjPtr)
-                Jim_DecrRefCount(interp, varAObjPtr);
-        } else if (exprLen == 3) {
-            jim_wide wideValueA, wideValueB=0, cmpRes = 0;
-            int cmpType = expr-&gt;opcode[2];
-
-            varAObjPtr = expr-&gt;obj[0];
-            Jim_IncrRefCount(varAObjPtr);
-            if (expr-&gt;opcode[1] == JIM_EXPROP_VARIABLE) {
-                varBObjPtr = expr-&gt;obj[1];
-                Jim_IncrRefCount(varBObjPtr);
-            } else {
-                if (Jim_GetWide(interp, expr-&gt;obj[1], &amp;wideValueB) != JIM_OK)
-                    goto noopt;
-            }
-            while (1) {
-                if (!(objPtr = Jim_GetVariable(interp, varAObjPtr, JIM_NONE)) ||
-                    Jim_GetWide(interp, objPtr, &amp;wideValueA) != JIM_OK)
-                {
-                    Jim_DecrRefCount(interp, varAObjPtr);
-                    if (varBObjPtr)
-                        Jim_DecrRefCount(interp, varBObjPtr);
-                    goto noopt;
-                }
-                if (varBObjPtr) {
-                    if (!(objPtr =
-                               Jim_GetVariable(interp, varBObjPtr, JIM_NONE)) ||
-                        Jim_GetWide(interp, objPtr, &amp;wideValueB) != JIM_OK)
-                    {
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        Jim_DecrRefCount(interp, varBObjPtr);
-                        goto noopt;
-                    }
-                }
-                switch (cmpType) {
-                case JIM_EXPROP_LT:
-                    cmpRes = wideValueA &lt; wideValueB; break;
-                case JIM_EXPROP_LTE:
-                    cmpRes = wideValueA &lt;= wideValueB; break;
-                case JIM_EXPROP_GT:
-                    cmpRes = wideValueA &gt; wideValueB; break;
-                case JIM_EXPROP_GTE:
-                    cmpRes = wideValueA &gt;= wideValueB; break;
-                case JIM_EXPROP_NUMEQ:
-                    cmpRes = wideValueA == wideValueB; break;
-                case JIM_EXPROP_NUMNE:
-                    cmpRes = wideValueA != wideValueB; break;
-                }
-                if (!cmpRes) break;
-                if ((retval = Jim_EvalObj(interp, argv[2])) != JIM_OK) {
-                    switch (retval) {
-                    case JIM_BREAK:
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        if (varBObjPtr)
-                            Jim_DecrRefCount(interp, varBObjPtr);
-                        goto out;
-                        break;
-                    case JIM_CONTINUE:
-                        continue;
-                        break;
-                    default:
-                        Jim_DecrRefCount(interp, varAObjPtr);
-                        if (varBObjPtr)
-                            Jim_DecrRefCount(interp, varBObjPtr);
-                        return retval;
-                    }
-                }
-            }
-            Jim_DecrRefCount(interp, varAObjPtr);
-            if (varBObjPtr)
-                Jim_DecrRefCount(interp, varBObjPtr);
-        } else {
-            /* TODO: case for len == 2 */
-            goto noopt;
-        }
-        Jim_SetEmptyResult(interp);
-        return JIM_OK;
-    }
-noopt:
-#endif
-
-    /* The general purpose implementation of while starts here */
-    while (1) {
-        int boolean, retval;
-
-        if ((retval = Jim_GetBoolFromExpr(interp, argv[1],
-                        &amp;boolean)) != JIM_OK)
-            return retval;
-        if (!boolean) break;
-        if ((retval = Jim_EvalObj(interp, argv[2])) != JIM_OK) {
-            switch (retval) {
-            case JIM_BREAK:
-                goto out;
-                break;
-            case JIM_CONTINUE:
-                continue;
-                break;
-            default:
-                return retval;
-            }
-        }
-    }
-out:
-    Jim_SetEmptyResult(interp);
-    return JIM_OK;
-}
-
-/* [for] */
-static int Jim_ForCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int retval;
-
-    if (argc != 5) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;start test next body&quot;);
-        return JIM_ERR;
-    }
-    /* Check if the for is on the form:
-     *      for {set i CONST} {$i &lt; CONST} {incr i}
-     *      for {set i CONST} {$i &lt; $j} {incr i}
-     *      for {set i CONST} {$i &lt;= CONST} {incr i}
-     *      for {set i CONST} {$i &lt;= $j} {incr i}
-     * XXX: NOTE: if variable traces are implemented, this optimization
-     * need to be modified to check for the proc epoch at every variable
-     * update. */
-#ifdef JIM_OPTIMIZATION
-    {
-        ScriptObj *initScript, *incrScript;
-        ExprByteCode *expr;
-        jim_wide start, stop=0, currentVal;
-        unsigned jim_wide procEpoch = interp-&gt;procEpoch;
-        Jim_Obj *varNamePtr, *stopVarNamePtr = NULL, *objPtr;
-        int cmpType;
-        struct Jim_Cmd *cmdPtr;
-
-        /* Do it only if there aren't shared arguments */
-        if (argv[1] == argv[2] || argv[2] == argv[3] || argv[1] == argv[3])
-            goto evalstart;
-        initScript = Jim_GetScript(interp, argv[1]);
-        expr = Jim_GetExpression(interp, argv[2]);
-        incrScript = Jim_GetScript(interp, argv[3]);
-
-        /* Ensure proper lengths to start */
-        if (initScript-&gt;len != 6) goto evalstart;
-        if (incrScript-&gt;len != 4) goto evalstart;
-        if (expr-&gt;len != 3) goto evalstart;
-        /* Ensure proper token types. */
-        if (initScript-&gt;token[2].type != JIM_TT_ESC ||
-            initScript-&gt;token[4].type != JIM_TT_ESC ||
-            incrScript-&gt;token[2].type != JIM_TT_ESC ||
-            expr-&gt;opcode[0] != JIM_EXPROP_VARIABLE ||
-            (expr-&gt;opcode[1] != JIM_EXPROP_NUMBER &amp;&amp;
-             expr-&gt;opcode[1] != JIM_EXPROP_VARIABLE) ||
-            (expr-&gt;opcode[2] != JIM_EXPROP_LT &amp;&amp;
-             expr-&gt;opcode[2] != JIM_EXPROP_LTE))
-            goto evalstart;
-        cmpType = expr-&gt;opcode[2];
-        /* Initialization command must be [set] */
-        cmdPtr = Jim_GetCommand(interp, initScript-&gt;token[0].objPtr, JIM_NONE);
-        if (cmdPtr == NULL || cmdPtr-&gt;cmdProc != Jim_SetCoreCommand)
-            goto evalstart;
-        /* Update command must be incr */
-        cmdPtr = Jim_GetCommand(interp, incrScript-&gt;token[0].objPtr, JIM_NONE);
-        if (cmdPtr == NULL || cmdPtr-&gt;cmdProc != Jim_IncrCoreCommand)
-            goto evalstart;
-        /* set, incr, expression must be about the same variable */
-        if (!Jim_StringEqObj(initScript-&gt;token[2].objPtr,
-                            incrScript-&gt;token[2].objPtr, 0))
-            goto evalstart;
-        if (!Jim_StringEqObj(initScript-&gt;token[2].objPtr,
-                            expr-&gt;obj[0], 0))
-            goto evalstart;
-        /* Check that the initialization and comparison are valid integers */
-        if (Jim_GetWide(interp, initScript-&gt;token[4].objPtr, &amp;start) == JIM_ERR)
-            goto evalstart;
-        if (expr-&gt;opcode[1] == JIM_EXPROP_NUMBER &amp;&amp;
-            Jim_GetWide(interp, expr-&gt;obj[1], &amp;stop) == JIM_ERR)
-        {
-            goto evalstart;
-        }
-
-        /* Initialization */
-        varNamePtr = expr-&gt;obj[0];
-        if (expr-&gt;opcode[1] == JIM_EXPROP_VARIABLE) {
-            stopVarNamePtr = expr-&gt;obj[1];
-            Jim_IncrRefCount(stopVarNamePtr);
-        }
-        Jim_IncrRefCount(varNamePtr);
-
-        /* --- OPTIMIZED FOR --- */
-        /* Start to loop */
-        objPtr = Jim_NewIntObj(interp, start);
-        if (Jim_SetVariable(interp, varNamePtr, objPtr) != JIM_OK) {
-            Jim_DecrRefCount(interp, varNamePtr);
-            if (stopVarNamePtr) Jim_DecrRefCount(interp, stopVarNamePtr);
-            Jim_FreeNewObj(interp, objPtr);
-            goto evalstart;
-        }
-        while (1) {
-            /* === Check condition === */
-            /* Common code: */
-            objPtr = Jim_GetVariable(interp, varNamePtr, JIM_NONE);
-            if (objPtr == NULL ||
-                Jim_GetWide(interp, objPtr, &amp;currentVal) != JIM_OK)
-            {
-                Jim_DecrRefCount(interp, varNamePtr);
-                if (stopVarNamePtr) Jim_DecrRefCount(interp, stopVarNamePtr);
-                goto testcond;
-            }
-            /* Immediate or Variable? get the 'stop' value if the latter. */
-            if (stopVarNamePtr) {
-                objPtr = Jim_GetVariable(interp, stopVarNamePtr, JIM_NONE);
-                if (objPtr == NULL ||
-                    Jim_GetWide(interp, objPtr, &amp;stop) != JIM_OK)
-                {
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    Jim_DecrRefCount(interp, stopVarNamePtr);
-                    goto testcond;
-                }
-            }
-            if (cmpType == JIM_EXPROP_LT) {
-                if (currentVal &gt;= stop) break;
-            } else {
-                if (currentVal &gt; stop) break;
-            }
-            /* Eval body */
-            if ((retval = Jim_EvalObj(interp, argv[4])) != JIM_OK) {
-                switch (retval) {
-                case JIM_BREAK:
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    goto out;
-                case JIM_CONTINUE:
-                    /* nothing to do */
-                    break;
-                default:
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    return retval;
-                }
-            }
-            /* If there was a change in procedures/command continue
-             * with the usual [for] command implementation */
-            if (procEpoch != interp-&gt;procEpoch) {
-                if (stopVarNamePtr)
-                    Jim_DecrRefCount(interp, stopVarNamePtr);
-                Jim_DecrRefCount(interp, varNamePtr);
-                goto evalnext;
-            }
-            /* Increment */
-            objPtr = Jim_GetVariable(interp, varNamePtr, JIM_ERRMSG);
-            if (objPtr-&gt;refCount == 1 &amp;&amp; objPtr-&gt;typePtr == &amp;intObjType) {
-                objPtr-&gt;internalRep.wideValue ++;
-                Jim_InvalidateStringRep(objPtr);
-            } else {
-                Jim_Obj *auxObjPtr;
-
-                if (Jim_GetWide(interp, objPtr, &amp;currentVal) == JIM_ERR) {
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    goto evalnext;
-                }
-                auxObjPtr = Jim_NewIntObj(interp, currentVal + 1);
-                if (Jim_SetVariable(interp, varNamePtr, auxObjPtr) == JIM_ERR) {
-                    if (stopVarNamePtr)
-                        Jim_DecrRefCount(interp, stopVarNamePtr);
-                    Jim_DecrRefCount(interp, varNamePtr);
-                    Jim_FreeNewObj(interp, auxObjPtr);
-                    goto evalnext;
-                }
-            }
-        }
-        if (stopVarNamePtr)
-            Jim_DecrRefCount(interp, stopVarNamePtr);
-        Jim_DecrRefCount(interp, varNamePtr);
-        Jim_SetEmptyResult(interp);
-        return JIM_OK;
-    }
-#endif
-evalstart:
-    /* Eval start */
-    if ((retval = Jim_EvalObj(interp, argv[1])) != JIM_OK)
-        return retval;
-    while (1) {
-        int boolean;
-testcond:
-        /* Test the condition */
-        if ((retval = Jim_GetBoolFromExpr(interp, argv[2], &amp;boolean))
-                != JIM_OK)
-            return retval;
-        if (!boolean) break;
-        /* Eval body */
-        if ((retval = Jim_EvalObj(interp, argv[4])) != JIM_OK) {
-            switch (retval) {
-            case JIM_BREAK:
-                goto out;
-                break;
-            case JIM_CONTINUE:
-                /* Nothing to do */
-                break;
-            default:
-                return retval;
-            }
-        }
-evalnext:
-        /* Eval next */
-        if ((retval = Jim_EvalObj(interp, argv[3])) != JIM_OK) {
-            switch (retval) {
-            case JIM_BREAK:
-                goto out;
-                break;
-            case JIM_CONTINUE:
-                continue;
-                break;
-            default:
-                return retval;
-            }
-        }
-    }
-out:
-    Jim_SetEmptyResult(interp);
-    return JIM_OK;
-}
-
-/* foreach + lmap implementation. */
-static int JimForeachMapHelper(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv, int doMap)
-{
-    int result = JIM_ERR, i, nbrOfLists, *listsIdx, *listsEnd;
-    int nbrOfLoops = 0;
-    Jim_Obj *emptyStr, *script, *mapRes = NULL;
-
-    if (argc &lt; 4 || argc % 2 != 0) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varList list ?varList list ...? script&quot;);
-        return JIM_ERR;
-    }
-    if (doMap) {
-        mapRes = Jim_NewListObj(interp, NULL, 0);
-        Jim_IncrRefCount(mapRes);
-    }
-    emptyStr = Jim_NewEmptyStringObj(interp);
-    Jim_IncrRefCount(emptyStr);
-    script = argv[argc-1];            /* Last argument is a script */
-    nbrOfLists = (argc - 1 - 1) / 2;  /* argc - 'foreach' - script */
-    listsIdx = (int*)Jim_Alloc(nbrOfLists * sizeof(int));
-    listsEnd = (int*)Jim_Alloc(nbrOfLists*2 * sizeof(int));
-    /* Initialize iterators and remember max nbr elements each list */
-    memset(listsIdx, 0, nbrOfLists * sizeof(int));
-    /* Remember lengths of all lists and calculate how much rounds to loop */
-    for (i = 0; i &lt; nbrOfLists*2; i += 2) {
-        div_t cnt;
-        int count;
-        Jim_ListLength(interp, argv[i + 1], &amp;listsEnd[i]);
-        Jim_ListLength(interp, argv[i + 2], &amp;listsEnd[i + 1]);
-        if (listsEnd[i] == 0) {
-            Jim_SetResultString(interp, &quot;foreach varlist is empty&quot;, -1);
-            goto err;
-        }
-        cnt = div(listsEnd[i + 1], listsEnd[i]);
-        count = cnt.quot + (cnt.rem ? 1 : 0);
-        if (count &gt; nbrOfLoops)
-            nbrOfLoops = count;
-    }
-    for (; nbrOfLoops-- &gt; 0;) {
-        for (i = 0; i &lt; nbrOfLists; ++i) {
-            int varIdx = 0, var = i * 2;
-            while (varIdx &lt; listsEnd[var]) {
-                Jim_Obj *varName, *ele;
-                int lst = i * 2 + 1;
-                if (Jim_ListIndex(interp, argv[var + 1], varIdx, &amp;varName, JIM_ERRMSG)
-                        != JIM_OK)
-                        goto err;
-                if (listsIdx[i] &lt; listsEnd[lst]) {
-                    if (Jim_ListIndex(interp, argv[lst + 1], listsIdx[i], &amp;ele, JIM_ERRMSG)
-                        != JIM_OK)
-                        goto err;
-                    if (Jim_SetVariable(interp, varName, ele) != JIM_OK) {
-                        Jim_SetResultString(interp, &quot;couldn't set loop variable: &quot;, -1);
-                        goto err;
-                    }
-                    ++listsIdx[i];  /* Remember next iterator of current list */
-                } else if (Jim_SetVariable(interp, varName, emptyStr) != JIM_OK) {
-                    Jim_SetResultString(interp, &quot;couldn't set loop variable: &quot;, -1);
-                    goto err;
-                }
-                ++varIdx;  /* Next variable */
-            }
-        }
-        switch (result = Jim_EvalObj(interp, script)) {
-            case JIM_OK:
-                if (doMap)
-                    Jim_ListAppendElement(interp, mapRes, interp-&gt;result);
-                break;
-            case JIM_CONTINUE:
-                break;
-            case JIM_BREAK:
-                goto out;
-                break;
-            default:
-                goto err;
-        }
-    }
-out:
-    result = JIM_OK;
-    if (doMap)
-        Jim_SetResult(interp, mapRes);
-    else
-        Jim_SetEmptyResult(interp);
-err:
-    if (doMap)
-        Jim_DecrRefCount(interp, mapRes);
-    Jim_DecrRefCount(interp, emptyStr);
-    Jim_Free(listsIdx);
-    Jim_Free(listsEnd);
-    return result;
-}
-
-/* [foreach] */
-static int Jim_ForeachCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return JimForeachMapHelper(interp, argc, argv, 0);
-}
-
-/* [lmap] */
-static int Jim_LmapCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    return JimForeachMapHelper(interp, argc, argv, 1);
-}
-
-/* [if] */
-static int Jim_IfCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int boolean, retval, current = 1, falsebody = 0;
-    if (argc &gt;= 3) {
-        while (1) {
-            /* Far not enough arguments given! */
-            if (current &gt;= argc) goto err;
-            if ((retval = Jim_GetBoolFromExpr(interp,
-                        argv[current++], &amp;boolean))
-                    != JIM_OK)
-                return retval;
-            /* There lacks something, isn't it? */
-            if (current &gt;= argc) goto err;
-            if (Jim_CompareStringImmediate(interp, argv[current],
-                        &quot;then&quot;)) current++;
-            /* Tsk tsk, no then-clause? */
-            if (current &gt;= argc) goto err;
-            if (boolean)
-                return Jim_EvalObj(interp, argv[current]);
-             /* Ok: no else-clause follows */
-            if (++current &gt;= argc) {
-            	Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            	return JIM_OK;
-            }
-            falsebody = current++;
-            if (Jim_CompareStringImmediate(interp, argv[falsebody],
-                        &quot;else&quot;)) {
-                /* IIICKS - else-clause isn't last cmd? */
-                if (current != argc-1) goto err;
-                return Jim_EvalObj(interp, argv[current]);
-            } else if (Jim_CompareStringImmediate(interp,
-                        argv[falsebody], &quot;elseif&quot;))
-                /* Ok: elseif follows meaning all the stuff
-                 * again (how boring...) */
-                continue;
-            /* OOPS - else-clause is not last cmd?*/
-            else if (falsebody != argc-1)
-                goto err;
-            return Jim_EvalObj(interp, argv[falsebody]);
-        }
-        return JIM_OK;
-    }
-err:
-    Jim_WrongNumArgs(interp, 1, argv, &quot;condition ?then? trueBody ?elseif ...? ?else? falseBody&quot;);
-    return JIM_ERR;
-}
-
-enum {SWITCH_EXACT, SWITCH_GLOB, SWITCH_RE, SWITCH_CMD, SWITCH_UNKNOWN};
-
-/* [switch] */
-static int Jim_SwitchCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int retcode = JIM_ERR, matchOpt = SWITCH_EXACT, opt = 1, patCount, i;
-    Jim_Obj *command = 0, *const *caseList = 0, *strObj;
-    Jim_Obj *script = 0;
-    if (argc &lt; 3) goto wrongnumargs;
-    for (opt = 1; opt &lt; argc; ++opt) {
-        const char *option = Jim_GetString(argv[opt], 0);
-        if (*option != '-') break;
-        else if (strncmp(option, &quot;--&quot;, 2) == 0) { ++opt; break; }
-        else if (strncmp(option, &quot;-exact&quot;, 2) == 0) matchOpt = SWITCH_EXACT;
-        else if (strncmp(option, &quot;-glob&quot;, 2) == 0) matchOpt = SWITCH_GLOB;
-        else if (strncmp(option, &quot;-regexp&quot;, 2) == 0) matchOpt = SWITCH_RE;
-        else if (strncmp(option, &quot;-command&quot;, 2) == 0) { matchOpt = SWITCH_CMD;
-            if ((argc - opt) &lt; 2) goto wrongnumargs;
-            command = argv[++opt];
-        } else {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;bad option \&quot;&quot;, option, &quot;\&quot;: must be -exact, -glob, &quot;
-                &quot;-regexp, -command procname or --&quot;, 0);
-            goto err;
-        }
-        if ((argc - opt) &lt; 2) goto wrongnumargs;
-    }
-    strObj = argv[opt++];
-    patCount = argc - opt;
-    if (patCount == 1) {
-        Jim_Obj **vector;
-        JimListGetElements(interp, argv[opt], &amp;patCount, &amp;vector);
-        caseList = vector;
-    } else
-        caseList = &amp;argv[opt];
-    if (patCount == 0 || patCount % 2 != 0) goto wrongnumargs;
-    for (i = 0; script == 0 &amp;&amp; i &lt; patCount; i += 2) {
-        Jim_Obj *patObj = caseList[i];
-        if (!Jim_CompareStringImmediate(interp, patObj, &quot;default&quot;)
-            || i &lt; (patCount-2)) {
-            switch (matchOpt) {
-                case SWITCH_EXACT:
-                    if (Jim_StringEqObj(strObj, patObj, 0))
-                        script = caseList[i + 1];
-                    break;
-                case SWITCH_GLOB:
-                    if (Jim_StringMatchObj(patObj, strObj, 0))
-                        script = caseList[i + 1];
-                    break;
-                case SWITCH_RE:
-                    command = Jim_NewStringObj(interp, &quot;regexp&quot;, -1);
-                    /* Fall thru intentionally */
-                case SWITCH_CMD: {
-                    Jim_Obj *parms[] = {command, patObj, strObj};
-                    int rc = Jim_EvalObjVector(interp, 3, parms);
-                    long matching;
-                    /* After the execution of a command we need to
-                     * make sure to reconvert the object into a list
-                     * again. Only for the single-list style [switch]. */
-                    if (argc-opt == 1) {
-                        Jim_Obj **vector;
-                        JimListGetElements(interp, argv[opt], &amp;patCount,
-                                &amp;vector);
-                        caseList = vector;
-                    }
-                    /* command is here already decref'd */
-                    if (rc != JIM_OK) {
-                        retcode = rc;
-                        goto err;
-                    }
-                    rc = Jim_GetLong(interp, Jim_GetResult(interp), &amp;matching);
-                    if (rc != JIM_OK) {
-                        retcode = rc;
-                        goto err;
-                    }
-                    if (matching)
-                        script = caseList[i + 1];
-                    break;
-                }
-                default:
-                    Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-                    Jim_AppendStrings(interp, Jim_GetResult(interp),
-                        &quot;internal error: no such option implemented&quot;, 0);
-                    goto err;
-            }
-        } else {
-          script = caseList[i + 1];
-        }
-    }
-    for (; i &lt; patCount &amp;&amp; Jim_CompareStringImmediate(interp, script, &quot;-&quot;);
-        i += 2)
-        script = caseList[i + 1];
-    if (script &amp;&amp; Jim_CompareStringImmediate(interp, script, &quot;-&quot;)) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;no body specified for pattern \&quot;&quot;,
-            Jim_GetString(caseList[i-2], 0), &quot;\&quot;&quot;, 0);
-        goto err;
-    }
-    retcode = JIM_OK;
-    Jim_SetEmptyResult(interp);
-    if (script != 0)
-        retcode = Jim_EvalObj(interp, script);
-    return retcode;
-wrongnumargs:
-    Jim_WrongNumArgs(interp, 1, argv, &quot;?options? string &quot;
-        &quot;pattern body ... ?default body?   or   &quot;
-        &quot;{pattern body ?pattern body ...?}&quot;);
-err:
-    return retcode;
-}
-
-/* [list] */
-static int Jim_ListCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *listObjPtr;
-
-    listObjPtr = Jim_NewListObj(interp, argv + 1, argc-1);
-    Jim_SetResult(interp, listObjPtr);
-    return JIM_OK;
-}
-
-/* [lindex] */
-static int Jim_LindexCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr, *listObjPtr;
-    int i;
-    int index_t;
-
-    if (argc &lt; 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;list index ?...?&quot;);
-        return JIM_ERR;
-    }
-    objPtr = argv[1];
-    Jim_IncrRefCount(objPtr);
-    for (i = 2; i &lt; argc; i++) {
-        listObjPtr = objPtr;
-        if (Jim_GetIndex(interp, argv[i], &amp;index_t) != JIM_OK) {
-            Jim_DecrRefCount(interp, listObjPtr);
-            return JIM_ERR;
-        }
-        if (Jim_ListIndex(interp, listObjPtr, index_t, &amp;objPtr,
-                    JIM_NONE) != JIM_OK) {
-            /* Returns an empty object if the index
-             * is out of range. */
-            Jim_DecrRefCount(interp, listObjPtr);
-            Jim_SetEmptyResult(interp);
-            return JIM_OK;
-        }
-        Jim_IncrRefCount(objPtr);
-        Jim_DecrRefCount(interp, listObjPtr);
-    }
-    Jim_SetResult(interp, objPtr);
-    Jim_DecrRefCount(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [llength] */
-static int Jim_LlengthCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int len;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;list&quot;);
-        return JIM_ERR;
-    }
-    Jim_ListLength(interp, argv[1], &amp;len);
-    Jim_SetResult(interp, Jim_NewIntObj(interp, len));
-    return JIM_OK;
-}
-
-/* [lappend] */
-static int Jim_LappendCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *listObjPtr;
-    int shared, i;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varName ?value value ...?&quot;);
-        return JIM_ERR;
-    }
-    listObjPtr = Jim_GetVariable(interp, argv[1], JIM_NONE);
-    if (!listObjPtr) {
-        /* Create the list if it does not exists */
-        listObjPtr = Jim_NewListObj(interp, NULL, 0);
-        if (Jim_SetVariable(interp, argv[1], listObjPtr) != JIM_OK) {
-            Jim_FreeNewObj(interp, listObjPtr);
-            return JIM_ERR;
-        }
-    }
-    shared = Jim_IsShared(listObjPtr);
-    if (shared)
-        listObjPtr = Jim_DuplicateObj(interp, listObjPtr);
-    for (i = 2; i &lt; argc; i++)
-        Jim_ListAppendElement(interp, listObjPtr, argv[i]);
-    if (Jim_SetVariable(interp, argv[1], listObjPtr) != JIM_OK) {
-        if (shared)
-            Jim_FreeNewObj(interp, listObjPtr);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, listObjPtr);
-    return JIM_OK;
-}
-
-/* [linsert] */
-static int Jim_LinsertCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int index_t, len;
-    Jim_Obj *listPtr;
-
-    if (argc &lt; 4) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;list index element &quot;
-            &quot;?element ...?&quot;);
-        return JIM_ERR;
-    }
-    listPtr = argv[1];
-    if (Jim_IsShared(listPtr))
-        listPtr = Jim_DuplicateObj(interp, listPtr);
-    if (Jim_GetIndex(interp, argv[2], &amp;index_t) != JIM_OK)
-        goto err;
-    Jim_ListLength(interp, listPtr, &amp;len);
-    if (index_t &gt;= len)
-        index_t = len;
-    else if (index_t &lt; 0)
-        index_t = len + index_t + 1;
-    Jim_ListInsertElements(interp, listPtr, index_t, argc-3, &amp;argv[3]);
-    Jim_SetResult(interp, listPtr);
-    return JIM_OK;
-err:
-    if (listPtr != argv[1]) {
-        Jim_FreeNewObj(interp, listPtr);
-    }
-    return JIM_ERR;
-}
-
-/* [lset] */
-static int Jim_LsetCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc &lt; 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;listVar ?index...? newVal&quot;);
-        return JIM_ERR;
-    } else if (argc == 3) {
-        if (Jim_SetVariable(interp, argv[1], argv[2]) != JIM_OK)
-            return JIM_ERR;
-        Jim_SetResult(interp, argv[2]);
-        return JIM_OK;
-    }
-    if (Jim_SetListIndex(interp, argv[1], argv + 2, argc-3, argv[argc-1])
-            == JIM_ERR) return JIM_ERR;
-    return JIM_OK;
-}
-
-/* [lsort] */
-static int Jim_LsortCoreCommand(Jim_Interp *interp, int argc, Jim_Obj *const argv[])
-{
-    const char *options[] = {
-        &quot;-ascii&quot;, &quot;-nocase&quot;, &quot;-increasing&quot;, &quot;-decreasing&quot;, NULL
-    };
-    enum {OPT_ASCII, OPT_NOCASE, OPT_INCREASING, OPT_DECREASING};
-    Jim_Obj *resObj;
-    int i, lsortType = JIM_LSORT_ASCII; /* default sort type */
-    int decreasing = 0;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;?options? list&quot;);
-        return JIM_ERR;
-    }
-    for (i = 1; i &lt; (argc-1); i++) {
-        int option;
-
-        if (Jim_GetEnum(interp, argv[i], options, &amp;option, &quot;option&quot;, JIM_ERRMSG)
-                != JIM_OK)
-            return JIM_ERR;
-        switch (option) {
-        case OPT_ASCII: lsortType = JIM_LSORT_ASCII; break;
-        case OPT_NOCASE: lsortType = JIM_LSORT_NOCASE; break;
-        case OPT_INCREASING: decreasing = 0; break;
-        case OPT_DECREASING: decreasing = 1; break;
-        }
-    }
-    if (decreasing) {
-        switch (lsortType) {
-        case JIM_LSORT_ASCII: lsortType = JIM_LSORT_ASCII_DECR; break;
-        case JIM_LSORT_NOCASE: lsortType = JIM_LSORT_NOCASE_DECR; break;
-        }
-    }
-    resObj = Jim_DuplicateObj(interp, argv[argc-1]);
-    ListSortElements(interp, resObj, lsortType);
-    Jim_SetResult(interp, resObj);
-    return JIM_OK;
-}
-
-/* [append] */
-static int Jim_AppendCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *stringObjPtr;
-    int shared, i;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varName ?value value ...?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        stringObjPtr = Jim_GetVariable(interp, argv[1], JIM_ERRMSG);
-        if (!stringObjPtr) return JIM_ERR;
-    } else {
-        stringObjPtr = Jim_GetVariable(interp, argv[1], JIM_NONE);
-        if (!stringObjPtr) {
-            /* Create the string if it does not exists */
-            stringObjPtr = Jim_NewEmptyStringObj(interp);
-            if (Jim_SetVariable(interp, argv[1], stringObjPtr)
-                    != JIM_OK) {
-                Jim_FreeNewObj(interp, stringObjPtr);
-                return JIM_ERR;
-            }
-        }
-    }
-    shared = Jim_IsShared(stringObjPtr);
-    if (shared)
-        stringObjPtr = Jim_DuplicateObj(interp, stringObjPtr);
-    for (i = 2; i &lt; argc; i++)
-        Jim_AppendObj(interp, stringObjPtr, argv[i]);
-    if (Jim_SetVariable(interp, argv[1], stringObjPtr) != JIM_OK) {
-        if (shared)
-            Jim_FreeNewObj(interp, stringObjPtr);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, stringObjPtr);
-    return JIM_OK;
-}
-
-/* [debug] */
-static int Jim_DebugCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *options[] = {
-        &quot;refcount&quot;, &quot;objcount&quot;, &quot;objects&quot;, &quot;invstr&quot;, &quot;scriptlen&quot;, &quot;exprlen&quot;,
-        &quot;exprbc&quot;,
-        NULL
-    };
-    enum {
-        OPT_REFCOUNT, OPT_OBJCOUNT, OPT_OBJECTS, OPT_INVSTR, OPT_SCRIPTLEN,
-        OPT_EXPRLEN, OPT_EXPRBC
-    };
-    int option;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;option ?...?&quot;);
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], options, &amp;option, &quot;option&quot;,
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-    if (option == OPT_REFCOUNT) {
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;object&quot;);
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp, Jim_NewIntObj(interp, argv[2]-&gt;refCount));
-        return JIM_OK;
-    } else if (option == OPT_OBJCOUNT) {
-        int freeobj = 0, liveobj = 0;
-        char buf[256];
-        Jim_Obj *objPtr;
-
-        if (argc != 2) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;&quot;);
-            return JIM_ERR;
-        }
-        /* Count the number of free objects. */
-        objPtr = interp-&gt;freeList;
-        while (objPtr) {
-            freeobj++;
-            objPtr = objPtr-&gt;nextObjPtr;
-        }
-        /* Count the number of live objects. */
-        objPtr = interp-&gt;liveList;
-        while (objPtr) {
-            liveobj++;
-            objPtr = objPtr-&gt;nextObjPtr;
-        }
-        /* Set the result string and return. */
-        sprintf(buf, &quot;free %d used %d&quot;, freeobj, liveobj);
-        Jim_SetResultString(interp, buf, -1);
-        return JIM_OK;
-    } else if (option == OPT_OBJECTS) {
-        Jim_Obj *objPtr, *listObjPtr, *subListObjPtr;
-        /* Count the number of live objects. */
-        objPtr = interp-&gt;liveList;
-        listObjPtr = Jim_NewListObj(interp, NULL, 0);
-        while (objPtr) {
-            char buf[128];
-            const char *type = objPtr-&gt;typePtr ?
-                objPtr-&gt;typePtr-&gt;name : &quot;&quot;;
-            subListObjPtr = Jim_NewListObj(interp, NULL, 0);
-            sprintf(buf, &quot;%p&quot;, objPtr);
-            Jim_ListAppendElement(interp, subListObjPtr,
-                Jim_NewStringObj(interp, buf, -1));
-            Jim_ListAppendElement(interp, subListObjPtr,
-                Jim_NewStringObj(interp, type, -1));
-            Jim_ListAppendElement(interp, subListObjPtr,
-                Jim_NewIntObj(interp, objPtr-&gt;refCount));
-            Jim_ListAppendElement(interp, subListObjPtr, objPtr);
-            Jim_ListAppendElement(interp, listObjPtr, subListObjPtr);
-            objPtr = objPtr-&gt;nextObjPtr;
-        }
-        Jim_SetResult(interp, listObjPtr);
-        return JIM_OK;
-    } else if (option == OPT_INVSTR) {
-        Jim_Obj *objPtr;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;object&quot;);
-            return JIM_ERR;
-        }
-        objPtr = argv[2];
-        if (objPtr-&gt;typePtr != NULL)
-            Jim_InvalidateStringRep(objPtr);
-        Jim_SetEmptyResult(interp);
-        return JIM_OK;
-    } else if (option == OPT_SCRIPTLEN) {
-        ScriptObj *script;
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;script&quot;);
-            return JIM_ERR;
-        }
-        script = Jim_GetScript(interp, argv[2]);
-        Jim_SetResult(interp, Jim_NewIntObj(interp, script-&gt;len));
-        return JIM_OK;
-    } else if (option == OPT_EXPRLEN) {
-        ExprByteCode *expr;
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;expression&quot;);
-            return JIM_ERR;
-        }
-        expr = Jim_GetExpression(interp, argv[2]);
-        if (expr == NULL)
-            return JIM_ERR;
-        Jim_SetResult(interp, Jim_NewIntObj(interp, expr-&gt;len));
-        return JIM_OK;
-    } else if (option == OPT_EXPRBC) {
-        Jim_Obj *objPtr;
-        ExprByteCode *expr;
-        int i;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;expression&quot;);
-            return JIM_ERR;
-        }
-        expr = Jim_GetExpression(interp, argv[2]);
-        if (expr == NULL)
-            return JIM_ERR;
-        objPtr = Jim_NewListObj(interp, NULL, 0);
-        for (i = 0; i &lt; expr-&gt;len; i++) {
-            const char *type;
-            Jim_ExprOperator *op;
-
-            switch (expr-&gt;opcode[i]) {
-            case JIM_EXPROP_NUMBER: type = &quot;number&quot;; break;
-            case JIM_EXPROP_COMMAND: type = &quot;command&quot;; break;
-            case JIM_EXPROP_VARIABLE: type = &quot;variable&quot;; break;
-            case JIM_EXPROP_DICTSUGAR: type = &quot;dictsugar&quot;; break;
-            case JIM_EXPROP_SUBST: type = &quot;subst&quot;; break;
-            case JIM_EXPROP_STRING: type = &quot;string&quot;; break;
-            default:
-                op = JimExprOperatorInfo(Jim_GetString(expr-&gt;obj[i], NULL));
-                if (op == NULL) {
-                    type = &quot;private&quot;;
-                } else {
-                    type = &quot;operator&quot;;
-                }
-                break;
-            }
-            Jim_ListAppendElement(interp, objPtr,
-                    Jim_NewStringObj(interp, type, -1));
-            Jim_ListAppendElement(interp, objPtr, expr-&gt;obj[i]);
-        }
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else {
-        Jim_SetResultString(interp,
-            &quot;bad option. Valid options are refcount, &quot;
-            &quot;objcount, objects, invstr&quot;, -1);
-        return JIM_ERR;
-    }
-    return JIM_OK; /* unreached */
-}
-
-/* [eval] */
-static int Jim_EvalCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc == 2) {
-        return Jim_EvalObj(interp, argv[1]);
-    } else if (argc &gt; 2) {
-        Jim_Obj *objPtr;
-        int retcode;
-
-        objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
-        Jim_IncrRefCount(objPtr);
-        retcode = Jim_EvalObj(interp, objPtr);
-        Jim_DecrRefCount(interp, objPtr);
-        return retcode;
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;script ?...?&quot;);
-        return JIM_ERR;
-    }
-}
-
-/* [uplevel] */
-static int Jim_UplevelCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc &gt;= 2) {
-        int retcode, newLevel, oldLevel;
-        Jim_CallFrame *savedCallFrame, *targetCallFrame;
-        Jim_Obj *objPtr;
-        const char *str;
-
-        /* Save the old callframe pointer */
-        savedCallFrame = interp-&gt;framePtr;
-
-        /* Lookup the target frame pointer */
-        str = Jim_GetString(argv[1], NULL);
-        if ((str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') || str[0] == '#')
-        {
-            if (Jim_GetCallFrameByLevel(interp, argv[1],
-                        &amp;targetCallFrame,
-                        &amp;newLevel) != JIM_OK)
-                return JIM_ERR;
-            argc--;
-            argv++;
-        } else {
-            if (Jim_GetCallFrameByLevel(interp, NULL,
-                        &amp;targetCallFrame,
-                        &amp;newLevel) != JIM_OK)
-                return JIM_ERR;
-        }
-        if (argc &lt; 2) {
-            argc++;
-            argv--;
-            Jim_WrongNumArgs(interp, 1, argv,
-                    &quot;?level? command ?arg ...?&quot;);
-            return JIM_ERR;
-        }
-        /* Eval the code in the target callframe. */
-        interp-&gt;framePtr = targetCallFrame;
-        oldLevel = interp-&gt;numLevels;
-        interp-&gt;numLevels = newLevel;
-        if (argc == 2) {
-            retcode = Jim_EvalObj(interp, argv[1]);
-        } else {
-            objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
-            Jim_IncrRefCount(objPtr);
-            retcode = Jim_EvalObj(interp, objPtr);
-            Jim_DecrRefCount(interp, objPtr);
-        }
-        interp-&gt;numLevels = oldLevel;
-        interp-&gt;framePtr = savedCallFrame;
-        return retcode;
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;?level? command ?arg ...?&quot;);
-        return JIM_ERR;
-    }
-}
-
-/* [expr] */
-static int Jim_ExprCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *exprResultPtr;
-    int retcode;
-
-    if (argc == 2) {
-        retcode = Jim_EvalExpression(interp, argv[1], &amp;exprResultPtr);
-    } else if (argc &gt; 2) {
-        Jim_Obj *objPtr;
-
-        objPtr = Jim_ConcatObj(interp, argc-1, argv + 1);
-        Jim_IncrRefCount(objPtr);
-        retcode = Jim_EvalExpression(interp, objPtr, &amp;exprResultPtr);
-        Jim_DecrRefCount(interp, objPtr);
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;expression ?...?&quot;);
-        return JIM_ERR;
-    }
-    if (retcode != JIM_OK) return retcode;
-    Jim_SetResult(interp, exprResultPtr);
-    Jim_DecrRefCount(interp, exprResultPtr);
-    return JIM_OK;
-}
-
-/* [break] */
-static int Jim_BreakCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 1) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;&quot;);
-        return JIM_ERR;
-    }
-    return JIM_BREAK;
-}
-
-/* [continue] */
-static int Jim_ContinueCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 1) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;&quot;);
-        return JIM_ERR;
-    }
-    return JIM_CONTINUE;
-}
-
-/* [return] */
-static int Jim_ReturnCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc == 1) {
-        return JIM_RETURN;
-    } else if (argc == 2) {
-        Jim_SetResult(interp, argv[1]);
-        interp-&gt;returnCode = JIM_OK;
-        return JIM_RETURN;
-    } else if (argc == 3 || argc == 4) {
-        int returnCode;
-        if (Jim_GetReturnCode(interp, argv[2], &amp;returnCode) == JIM_ERR)
-            return JIM_ERR;
-        interp-&gt;returnCode = returnCode;
-        if (argc == 4)
-            Jim_SetResult(interp, argv[3]);
-        return JIM_RETURN;
-    } else {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;?-code code? ?result?&quot;);
-        return JIM_ERR;
-    }
-    return JIM_RETURN; /* unreached */
-}
-
-/* [tailcall] */
-static int Jim_TailcallCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr;
-
-    objPtr = Jim_NewListObj(interp, argv + 1, argc-1);
-    Jim_SetResult(interp, objPtr);
-    return JIM_EVAL;
-}
-
-/* [proc] */
-static int Jim_ProcCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int argListLen;
-    int arityMin, arityMax;
-
-    if (argc != 4 &amp;&amp; argc != 5) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;name arglist ?statics? body&quot;);
-        return JIM_ERR;
-    }
-    Jim_ListLength(interp, argv[2], &amp;argListLen);
-    arityMin = arityMax = argListLen + 1;
-
-    if (argListLen) {
-        const char *str;
-        int len;
-        Jim_Obj *argPtr=NULL;
-
-        /* Check for 'args' and adjust arityMin and arityMax if necessary */
-        Jim_ListIndex(interp, argv[2], argListLen-1, &amp;argPtr, JIM_NONE);
-        str = Jim_GetString(argPtr, &amp;len);
-        if (len == 4 &amp;&amp; memcmp(str, &quot;args&quot;, 4) == 0) {
-            arityMin--;
-            arityMax = -1;
-        }
-
-        /* Check for default arguments and reduce arityMin if necessary */
-        while (arityMin &gt; 1) {
-            Jim_ListIndex(interp, argv[2], arityMin - 2, &amp;argPtr, JIM_NONE);
-            Jim_ListLength(interp, argPtr, &amp;len);
-            if (len != 2) {
-                /* No default argument */
-                break;
-            }
-            arityMin--;
-        }
-    }
-    if (argc == 4) {
-        return Jim_CreateProcedure(interp, Jim_GetString(argv[1], NULL),
-                argv[2], NULL, argv[3], arityMin, arityMax);
-    } else {
-        return Jim_CreateProcedure(interp, Jim_GetString(argv[1], NULL),
-                argv[2], argv[3], argv[4], arityMin, arityMax);
-    }
-}
-
-/* [concat] */
-static int Jim_ConcatCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_SetResult(interp, Jim_ConcatObj(interp, argc-1, argv + 1));
-    return JIM_OK;
-}
-
-/* [upvar] */
-static int Jim_UpvarCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *str;
-    int i;
-    Jim_CallFrame *targetCallFrame;
-
-    /* Lookup the target frame pointer */
-    str = Jim_GetString(argv[1], NULL);
-    if (argc &gt; 3 &amp;&amp;
-        ((str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') || str[0] == '#'))
-    {
-        if (Jim_GetCallFrameByLevel(interp, argv[1],
-                    &amp;targetCallFrame, NULL) != JIM_OK)
-            return JIM_ERR;
-        argc--;
-        argv++;
-    } else {
-        if (Jim_GetCallFrameByLevel(interp, NULL,
-                    &amp;targetCallFrame, NULL) != JIM_OK)
-            return JIM_ERR;
-    }
-    /* Check for arity */
-    if (argc &lt; 3 || ((argc-1)%2) != 0) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;?level? otherVar localVar ?otherVar localVar ...?&quot;);
-        return JIM_ERR;
-    }
-    /* Now... for every other/local couple: */
-    for (i = 1; i &lt; argc; i += 2) {
-        if (Jim_SetVariableLink(interp, argv[i + 1], argv[i],
-                targetCallFrame) != JIM_OK) return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [global] */
-static int Jim_GlobalCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int i;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varName ?varName ...?&quot;);
-        return JIM_ERR;
-    }
-    /* Link every var to the toplevel having the same name */
-    if (interp-&gt;numLevels == 0) return JIM_OK; /* global at toplevel... */
-    for (i = 1; i &lt; argc; i++) {
-        if (Jim_SetVariableLink(interp, argv[i], argv[i],
-                interp-&gt;topFramePtr) != JIM_OK) return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* does the [string map] operation. On error NULL is returned,
- * otherwise a new string object with the result, having refcount = 0,
- * is returned. */
-static Jim_Obj *JimStringMap(Jim_Interp *interp, Jim_Obj *mapListObjPtr,
-        Jim_Obj *objPtr, int nocase)
-{
-    int numMaps;
-    const char **key, *str, *noMatchStart = NULL;
-    Jim_Obj **value;
-    int *keyLen, strLen, i;
-    Jim_Obj *resultObjPtr;
-
-    Jim_ListLength(interp, mapListObjPtr, &amp;numMaps);
-    if (numMaps % 2) {
-        Jim_SetResultString(interp,
-                &quot;list must contain an even number of elements&quot;, -1);
-        return NULL;
-    }
-    /* Initialization */
-    numMaps /= 2;
-    key = Jim_Alloc(sizeof(char*)*numMaps);
-    keyLen = Jim_Alloc(sizeof(int)*numMaps);
-    value = Jim_Alloc(sizeof(Jim_Obj*)*numMaps);
-    resultObjPtr = Jim_NewStringObj(interp, &quot;&quot;, 0);
-    for (i = 0; i &lt; numMaps; i++) {
-        Jim_Obj *eleObjPtr=NULL;
-
-        Jim_ListIndex(interp, mapListObjPtr, i*2, &amp;eleObjPtr, JIM_NONE);
-        key[i] = Jim_GetString(eleObjPtr, &amp;keyLen[i]);
-        Jim_ListIndex(interp, mapListObjPtr, i*2 + 1, &amp;eleObjPtr, JIM_NONE);
-        value[i] = eleObjPtr;
-    }
-    str = Jim_GetString(objPtr, &amp;strLen);
-    /* Map it */
-    while (strLen) {
-        for (i = 0; i &lt; numMaps; i++) {
-            if (strLen &gt;= keyLen[i] &amp;&amp; keyLen[i]) {
-                if (!JimStringCompare(str, keyLen[i], key[i], keyLen[i],
-                            nocase))
-                {
-                    if (noMatchStart) {
-                        Jim_AppendString(interp, resultObjPtr,
-                                noMatchStart, str-noMatchStart);
-                        noMatchStart = NULL;
-                    }
-                    Jim_AppendObj(interp, resultObjPtr, value[i]);
-                    str += keyLen[i];
-                    strLen -= keyLen[i];
-                    break;
-                }
-            }
-        }
-        if (i == numMaps) { /* no match */
-            if (noMatchStart == NULL)
-                noMatchStart = str;
-            str ++;
-            strLen --;
-        }
-    }
-    if (noMatchStart) {
-        Jim_AppendString(interp, resultObjPtr,
-            noMatchStart, str-noMatchStart);
-    }
-    Jim_Free((void*)key);
-    Jim_Free(keyLen);
-    Jim_Free(value);
-    return resultObjPtr;
-}
-
-/* [string] */
-static int Jim_StringCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int option;
-    const char *options[] = {
-        &quot;length&quot;, &quot;compare&quot;, &quot;match&quot;, &quot;equal&quot;, &quot;range&quot;, &quot;map&quot;, &quot;repeat&quot;,
-        &quot;index&quot;, &quot;first&quot;, &quot;tolower&quot;, &quot;toupper&quot;, NULL
-    };
-    enum {
-        OPT_LENGTH, OPT_COMPARE, OPT_MATCH, OPT_EQUAL, OPT_RANGE,
-        OPT_MAP, OPT_REPEAT, OPT_INDEX, OPT_FIRST, OPT_TOLOWER, OPT_TOUPPER
-    };
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;option ?arguments ...?&quot;);
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], options, &amp;option, &quot;option&quot;,
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-
-    if (option == OPT_LENGTH) {
-        int len;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string&quot;);
-            return JIM_ERR;
-        }
-        Jim_GetString(argv[2], &amp;len);
-        Jim_SetResult(interp, Jim_NewIntObj(interp, len));
-        return JIM_OK;
-    } else if (option == OPT_COMPARE) {
-        int nocase = 0;
-        if ((argc != 4 &amp;&amp; argc != 5) ||
-            (argc == 5 &amp;&amp; Jim_CompareStringImmediate(interp,
-                argv[2], &quot;-nocase&quot;) == 0)) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string1 string2&quot;);
-            return JIM_ERR;
-        }
-        if (argc == 5) {
-            nocase = 1;
-            argv++;
-        }
-        Jim_SetResult(interp, Jim_NewIntObj(interp,
-                    Jim_StringCompareObj(argv[2],
-                            argv[3], nocase)));
-        return JIM_OK;
-    } else if (option == OPT_MATCH) {
-        int nocase = 0;
-        if ((argc != 4 &amp;&amp; argc != 5) ||
-            (argc == 5 &amp;&amp; Jim_CompareStringImmediate(interp,
-                argv[2], &quot;-nocase&quot;) == 0)) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;?-nocase? pattern &quot;
-                    &quot;string&quot;);
-            return JIM_ERR;
-        }
-        if (argc == 5) {
-            nocase = 1;
-            argv++;
-        }
-        Jim_SetResult(interp,
-            Jim_NewIntObj(interp, Jim_StringMatchObj(argv[2],
-                    argv[3], nocase)));
-        return JIM_OK;
-    } else if (option == OPT_EQUAL) {
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string1 string2&quot;);
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp,
-            Jim_NewIntObj(interp, Jim_StringEqObj(argv[2],
-                    argv[3], 0)));
-        return JIM_OK;
-    } else if (option == OPT_RANGE) {
-        Jim_Obj *objPtr;
-
-        if (argc != 5) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string first last&quot;);
-            return JIM_ERR;
-        }
-        objPtr = Jim_StringRangeObj(interp, argv[2], argv[3], argv[4]);
-        if (objPtr == NULL)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_MAP) {
-        int nocase = 0;
-        Jim_Obj *objPtr;
-
-        if ((argc != 4 &amp;&amp; argc != 5) ||
-            (argc == 5 &amp;&amp; Jim_CompareStringImmediate(interp,
-                argv[2], &quot;-nocase&quot;) == 0)) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;?-nocase? mapList &quot;
-                    &quot;string&quot;);
-            return JIM_ERR;
-        }
-        if (argc == 5) {
-            nocase = 1;
-            argv++;
-        }
-        objPtr = JimStringMap(interp, argv[2], argv[3], nocase);
-        if (objPtr == NULL)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_REPEAT) {
-        Jim_Obj *objPtr;
-        jim_wide count;
-
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string count&quot;);
-            return JIM_ERR;
-        }
-        if (Jim_GetWide(interp, argv[3], &amp;count) != JIM_OK)
-            return JIM_ERR;
-        objPtr = Jim_NewStringObj(interp, &quot;&quot;, 0);
-        while (count--) {
-            Jim_AppendObj(interp, objPtr, argv[2]);
-        }
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_INDEX) {
-        int index_t, len;
-        const char *str;
-
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string index&quot;);
-            return JIM_ERR;
-        }
-        if (Jim_GetIndex(interp, argv[3], &amp;index_t) != JIM_OK)
-            return JIM_ERR;
-        str = Jim_GetString(argv[2], &amp;len);
-        if (index_t != INT_MIN &amp;&amp; index_t != INT_MAX)
-            index_t = JimRelToAbsIndex(len, index_t);
-        if (index_t &lt; 0 || index_t &gt;= len) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            return JIM_OK;
-        } else {
-            Jim_SetResult(interp, Jim_NewStringObj(interp, str + index_t, 1));
-            return JIM_OK;
-        }
-    } else if (option == OPT_FIRST) {
-        int index_t = 0, l1, l2;
-        const char *s1, *s2;
-
-        if (argc != 4 &amp;&amp; argc != 5) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;subString string ?startIndex?&quot;);
-            return JIM_ERR;
-        }
-        s1 = Jim_GetString(argv[2], &amp;l1);
-        s2 = Jim_GetString(argv[3], &amp;l2);
-        if (argc == 5) {
-            if (Jim_GetIndex(interp, argv[4], &amp;index_t) != JIM_OK)
-                return JIM_ERR;
-            index_t = JimRelToAbsIndex(l2, index_t);
-        }
-        Jim_SetResult(interp, Jim_NewIntObj(interp,
-                    JimStringFirst(s1, l1, s2, l2, index_t)));
-        return JIM_OK;
-    } else if (option == OPT_TOLOWER) {
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string&quot;);
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp, JimStringToLower(interp, argv[2]));
-    } else if (option == OPT_TOUPPER) {
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;string&quot;);
-            return JIM_ERR;
-        }
-        Jim_SetResult(interp, JimStringToUpper(interp, argv[2]));
-    }
-    return JIM_OK;
-}
-
-/* [time] */
-static int Jim_TimeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    long i, count = 1;
-    jim_wide start, elapsed;
-    char buf [256];
-    const char *fmt = &quot;%&quot; JIM_WIDE_MODIFIER &quot; microseconds per iteration&quot;;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;script ?count?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        if (Jim_GetLong(interp, argv[2], &amp;count) != JIM_OK)
-            return JIM_ERR;
-    }
-    if (count &lt; 0)
-        return JIM_OK;
-    i = count;
-    start = JimClock();
-    while (i-- &gt; 0) {
-        int retval;
-
-        if ((retval = Jim_EvalObj(interp, argv[1])) != JIM_OK)
-            return retval;
-    }
-    elapsed = JimClock() - start;
-    sprintf(buf, fmt, elapsed/count);
-    Jim_SetResultString(interp, buf, -1);
-    return JIM_OK;
-}
-
-/* [exit] */
-static int Jim_ExitCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    long exitCode = 0;
-
-    if (argc &gt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;?exitCode?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        if (Jim_GetLong(interp, argv[1], &amp;exitCode) != JIM_OK)
-            return JIM_ERR;
-    }
-    interp-&gt;exitCode = exitCode;
-    return JIM_EXIT;
-}
-
-/* [catch] */
-static int Jim_CatchCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int exitCode = 0;
-
-    if (argc != 2 &amp;&amp; argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;script ?varName?&quot;);
-        return JIM_ERR;
-    }
-    exitCode = Jim_EvalObj(interp, argv[1]);
-    if (argc == 3) {
-        if (Jim_SetVariable(interp, argv[2], Jim_GetResult(interp))
-                != JIM_OK)
-            return JIM_ERR;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, exitCode));
-    return JIM_OK;
-}
-
-/* [ref] */
-static int Jim_RefCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 3 &amp;&amp; argc != 4) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;string tag ?finalizer?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 3) {
-        Jim_SetResult(interp, Jim_NewReference(interp, argv[1], argv[2], NULL));
-    } else {
-        Jim_SetResult(interp, Jim_NewReference(interp, argv[1], argv[2],
-                    argv[3]));
-    }
-    return JIM_OK;
-}
-
-/* [getref] */
-static int Jim_GetrefCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Reference *refPtr;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;reference&quot;);
-        return JIM_ERR;
-    }
-    if ((refPtr = Jim_GetReference(interp, argv[1])) == NULL)
-        return JIM_ERR;
-    Jim_SetResult(interp, refPtr-&gt;objPtr);
-    return JIM_OK;
-}
-
-/* [setref] */
-static int Jim_SetrefCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Reference *refPtr;
-
-    if (argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;reference newValue&quot;);
-        return JIM_ERR;
-    }
-    if ((refPtr = Jim_GetReference(interp, argv[1])) == NULL)
-        return JIM_ERR;
-    Jim_IncrRefCount(argv[2]);
-    Jim_DecrRefCount(interp, refPtr-&gt;objPtr);
-    refPtr-&gt;objPtr = argv[2];
-    Jim_SetResult(interp, argv[2]);
-    return JIM_OK;
-}
-
-/* [collect] */
-static int Jim_CollectCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 1) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;&quot;);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, Jim_NewIntObj(interp, Jim_Collect(interp)));
-    return JIM_OK;
-}
-
-/* [finalize] reference ?newValue? */
-static int Jim_FinalizeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 2 &amp;&amp; argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;reference ?finalizerProc?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        Jim_Obj *cmdNamePtr;
-
-        if (Jim_GetFinalizer(interp, argv[1], &amp;cmdNamePtr) != JIM_OK)
-            return JIM_ERR;
-        if (cmdNamePtr != NULL) /* otherwise the null string is returned. */
-            Jim_SetResult(interp, cmdNamePtr);
-    } else {
-        if (Jim_SetFinalizer(interp, argv[1], argv[2]) != JIM_OK)
-            return JIM_ERR;
-        Jim_SetResult(interp, argv[2]);
-    }
-    return JIM_OK;
-}
-
-/* TODO */
-/* [info references] (list of all the references/finalizers) */
-
-/* [rename] */
-static int Jim_RenameCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *oldName, *newName;
-
-    if (argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;oldName newName&quot;);
-        return JIM_ERR;
-    }
-    oldName = Jim_GetString(argv[1], NULL);
-    newName = Jim_GetString(argv[2], NULL);
-    if (Jim_RenameCommand(interp, oldName, newName) != JIM_OK) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;can't rename \&quot;&quot;, oldName, &quot;\&quot;: &quot;,
-            &quot;command doesn't exist&quot;, NULL);
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [dict] */
-static int Jim_DictCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int option;
-    const char *options[] = {
-        &quot;create&quot;, &quot;get&quot;, &quot;set&quot;, &quot;unset&quot;, &quot;exists&quot;, NULL
-    };
-    enum {
-        OPT_CREATE, OPT_GET, OPT_SET, OPT_UNSET, OPT_EXIST
-    };
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;option ?arguments ...?&quot;);
-        return JIM_ERR;
-    }
-
-    if (Jim_GetEnum(interp, argv[1], options, &amp;option, &quot;option&quot;,
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-
-    if (option == OPT_CREATE) {
-        Jim_Obj *objPtr;
-
-        if (argc % 2) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;?key value ...?&quot;);
-            return JIM_ERR;
-        }
-        objPtr = Jim_NewDictObj(interp, argv + 2, argc-2);
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_GET) {
-        Jim_Obj *objPtr;
-
-        if (Jim_DictKeysVector(interp, argv[2], argv + 3, argc-3, &amp;objPtr,
-                JIM_ERRMSG) != JIM_OK)
-            return JIM_ERR;
-        Jim_SetResult(interp, objPtr);
-        return JIM_OK;
-    } else if (option == OPT_SET) {
-        if (argc &lt; 5) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;varName key ?key ...? value&quot;);
-            return JIM_ERR;
-        }
-        return Jim_SetDictKeysVector(interp, argv[2], argv + 3, argc-4,
-                    argv[argc-1]);
-    } else if (option == OPT_UNSET) {
-        if (argc &lt; 4) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;varName key ?key ...?&quot;);
-            return JIM_ERR;
-        }
-        return Jim_SetDictKeysVector(interp, argv[2], argv + 3, argc-3,
-                    NULL);
-    } else if (option == OPT_EXIST) {
-        Jim_Obj *objPtr;
-        int exists;
-
-        if (Jim_DictKeysVector(interp, argv[2], argv + 3, argc-3, &amp;objPtr,
-                JIM_ERRMSG) == JIM_OK)
-            exists = 1;
-        else
-            exists = 0;
-        Jim_SetResult(interp, Jim_NewIntObj(interp, exists));
-        return JIM_OK;
-    } else {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-            &quot;bad option \&quot;&quot;, Jim_GetString(argv[1], NULL), &quot;\&quot;:&quot;,
-            &quot; must be create, get, set&quot;, NULL);
-        return JIM_ERR;
-    }
-    return JIM_OK;
-}
-
-/* [load] */
-static int Jim_LoadCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;libaryFile&quot;);
-        return JIM_ERR;
-    }
-    return Jim_LoadLibrary(interp, Jim_GetString(argv[1], NULL));
-}
-
-/* [subst] */
-static int Jim_SubstCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int i, flags = 0;
-    Jim_Obj *objPtr;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv,
-            &quot;?-nobackslashes? ?-nocommands? ?-novariables? string&quot;);
-        return JIM_ERR;
-    }
-    i = argc-2;
-    while (i--) {
-        if (Jim_CompareStringImmediate(interp, argv[i + 1],
-                    &quot;-nobackslashes&quot;))
-            flags |= JIM_SUBST_NOESC;
-        else if (Jim_CompareStringImmediate(interp, argv[i + 1],
-                    &quot;-novariables&quot;))
-            flags |= JIM_SUBST_NOVAR;
-        else if (Jim_CompareStringImmediate(interp, argv[i + 1],
-                    &quot;-nocommands&quot;))
-            flags |= JIM_SUBST_NOCMD;
-        else {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;bad option \&quot;&quot;, Jim_GetString(argv[i + 1], NULL),
-                &quot;\&quot;: must be -nobackslashes, -nocommands, or &quot;
-                &quot;-novariables&quot;, NULL);
-            return JIM_ERR;
-        }
-    }
-    if (Jim_SubstObj(interp, argv[argc-1], &amp;objPtr, flags) != JIM_OK)
-        return JIM_ERR;
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [info] */
-static int Jim_InfoCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int cmd, result = JIM_OK;
-    static const char *commands[] = {
-        &quot;body&quot;, &quot;commands&quot;, &quot;exists&quot;, &quot;globals&quot;, &quot;level&quot;, &quot;locals&quot;,
-        &quot;vars&quot;, &quot;version&quot;, &quot;complete&quot;, &quot;args&quot;, &quot;hostname&quot;, NULL
-    };
-    enum {INFO_BODY, INFO_COMMANDS, INFO_EXISTS, INFO_GLOBALS, INFO_LEVEL,
-          INFO_LOCALS, INFO_VARS, INFO_VERSION, INFO_COMPLETE, INFO_ARGS, INFO_HOSTNAME};
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;command ?args ...?&quot;);
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], commands, &amp;cmd, &quot;command&quot;, JIM_ERRMSG)
-        != JIM_OK) {
-        return JIM_ERR;
-    }
-
-    if (cmd == INFO_COMMANDS) {
-        if (argc != 2 &amp;&amp; argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;?pattern?&quot;);
-            return JIM_ERR;
-        }
-        if (argc == 3)
-            Jim_SetResult(interp,JimCommandsList(interp, argv[2]));
-        else
-            Jim_SetResult(interp, JimCommandsList(interp, NULL));
-    } else if (cmd == INFO_EXISTS) {
-        Jim_Obj *exists;
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;varName&quot;);
-            return JIM_ERR;
-        }
-        exists = Jim_GetVariable(interp, argv[2], 0);
-        Jim_SetResult(interp, Jim_NewIntObj(interp, exists != 0));
-    } else if (cmd == INFO_GLOBALS || cmd == INFO_LOCALS || cmd == INFO_VARS) {
-        int mode;
-        switch (cmd) {
-            case INFO_GLOBALS: mode = JIM_VARLIST_GLOBALS; break;
-            case INFO_LOCALS:  mode = JIM_VARLIST_LOCALS; break;
-            case INFO_VARS:    mode = JIM_VARLIST_VARS; break;
-            default: mode = 0; /* avoid warning */; break;
-        }
-        if (argc != 2 &amp;&amp; argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;?pattern?&quot;);
-            return JIM_ERR;
-        }
-        if (argc == 3)
-            Jim_SetResult(interp,JimVariablesList(interp, argv[2], mode));
-        else
-            Jim_SetResult(interp, JimVariablesList(interp, NULL, mode));
-    } else if (cmd == INFO_LEVEL) {
-        Jim_Obj *objPtr;
-        switch (argc) {
-            case 2:
-                Jim_SetResult(interp,
-                              Jim_NewIntObj(interp, interp-&gt;numLevels));
-                break;
-            case 3:
-                if (JimInfoLevel(interp, argv[2], &amp;objPtr) != JIM_OK)
-                    return JIM_ERR;
-                Jim_SetResult(interp, objPtr);
-                break;
-            default:
-                Jim_WrongNumArgs(interp, 2, argv, &quot;?levelNum?&quot;);
-                return JIM_ERR;
-        }
-    } else if (cmd == INFO_BODY || cmd == INFO_ARGS) {
-        Jim_Cmd *cmdPtr;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;procname&quot;);
-            return JIM_ERR;
-        }
-        if ((cmdPtr = Jim_GetCommand(interp, argv[2], JIM_ERRMSG)) == NULL)
-            return JIM_ERR;
-        if (cmdPtr-&gt;cmdProc != NULL) {
-            Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-            Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;command \&quot;&quot;, Jim_GetString(argv[2], NULL),
-                &quot;\&quot; is not a procedure&quot;, NULL);
-            return JIM_ERR;
-        }
-        if (cmd == INFO_BODY)
-            Jim_SetResult(interp, cmdPtr-&gt;bodyObjPtr);
-        else
-            Jim_SetResult(interp, cmdPtr-&gt;argListObjPtr);
-    } else if (cmd == INFO_VERSION) {
-        char buf[(JIM_INTEGER_SPACE * 2) + 1];
-        sprintf(buf, &quot;%d.%d&quot;,
-                JIM_VERSION / 100, JIM_VERSION % 100);
-        Jim_SetResultString(interp, buf, -1);
-    } else if (cmd == INFO_COMPLETE) {
-        const char *s;
-        int len;
-
-        if (argc != 3) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;script&quot;);
-            return JIM_ERR;
-        }
-        s = Jim_GetString(argv[2], &amp;len);
-        Jim_SetResult(interp,
-                Jim_NewIntObj(interp, Jim_ScriptIsComplete(s, len, NULL)));
-    } else if (cmd == INFO_HOSTNAME) {
-        /* Redirect to os.hostname if it exists */
-        Jim_Obj *command = Jim_NewStringObj(interp, &quot;os.gethostname&quot;, -1);
-        result = Jim_EvalObjVector(interp, 1, &amp;command);
-    }
-    return result;
-}
-
-/* [split] */
-static int Jim_SplitCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *str, *splitChars, *noMatchStart;
-    int splitLen, strLen, i;
-    Jim_Obj *resObjPtr;
-
-    if (argc != 2 &amp;&amp; argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;string ?splitChars?&quot;);
-        return JIM_ERR;
-    }
-    /* Init */
-    if (argc == 2) {
-        splitChars = &quot; \n\t\r&quot;;
-        splitLen = 4;
-    } else {
-        splitChars = Jim_GetString(argv[2], &amp;splitLen);
-    }
-    str = Jim_GetString(argv[1], &amp;strLen);
-    if (!strLen) return JIM_OK;
-    noMatchStart = str;
-    resObjPtr = Jim_NewListObj(interp, NULL, 0);
-    /* Split */
-    if (splitLen) {
-        while (strLen) {
-            for (i = 0; i &lt; splitLen; i++) {
-                if (*str == splitChars[i]) {
-                    Jim_Obj *objPtr;
-
-                    objPtr = Jim_NewStringObj(interp, noMatchStart,
-                            (str-noMatchStart));
-                    Jim_ListAppendElement(interp, resObjPtr, objPtr);
-                    noMatchStart = str + 1;
-                    break;
-                }
-            }
-            str ++;
-            strLen --;
-        }
-        Jim_ListAppendElement(interp, resObjPtr,
-                Jim_NewStringObj(interp, noMatchStart, (str-noMatchStart)));
-    } else {
-        /* This handles the special case of splitchars eq {}. This
-         * is trivial but we want to perform object sharing as Tcl does. */
-        Jim_Obj *objCache[256];
-        const unsigned char *u = (unsigned char*) str;
-        memset(objCache, 0, sizeof(objCache));
-        for (i = 0; i &lt; strLen; i++) {
-            int c = u[i];
-
-            if (objCache[c] == NULL)
-                objCache[c] = Jim_NewStringObj(interp, (char*)u + i, 1);
-            Jim_ListAppendElement(interp, resObjPtr, objCache[c]);
-        }
-    }
-    Jim_SetResult(interp, resObjPtr);
-    return JIM_OK;
-}
-
-/* [join] */
-static int Jim_JoinCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *joinStr;
-    int joinStrLen, i, listLen;
-    Jim_Obj *resObjPtr;
-
-    if (argc != 2 &amp;&amp; argc != 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;list ?joinString?&quot;);
-        return JIM_ERR;
-    }
-    /* Init */
-    if (argc == 2) {
-        joinStr = &quot; &quot;;
-        joinStrLen = 1;
-    } else {
-        joinStr = Jim_GetString(argv[2], &amp;joinStrLen);
-    }
-    Jim_ListLength(interp, argv[1], &amp;listLen);
-    resObjPtr = Jim_NewStringObj(interp, NULL, 0);
-    /* Split */
-    for (i = 0; i &lt; listLen; i++) {
-        Jim_Obj *objPtr=NULL;
-
-        Jim_ListIndex(interp, argv[1], i, &amp;objPtr, JIM_NONE);
-        Jim_AppendObj(interp, resObjPtr, objPtr);
-        if (i + 1 != listLen) {
-            Jim_AppendString(interp, resObjPtr, joinStr, joinStrLen);
-        }
-    }
-    Jim_SetResult(interp, resObjPtr);
-    return JIM_OK;
-}
-
-/* [format] */
-static int Jim_FormatCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr;
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;formatString ?arg arg ...?&quot;);
-        return JIM_ERR;
-    }
-    objPtr = Jim_FormatString(interp, argv[1], argc-2, argv + 2);
-    if (objPtr == NULL)
-        return JIM_ERR;
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [scan] */
-static int Jim_ScanCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *listPtr, **outVec;
-    int outc, i, count = 0;
-
-    if (argc &lt; 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;string formatString ?varName ...?&quot;);
-        return JIM_ERR;
-    }
-    if (argv[2]-&gt;typePtr != &amp;scanFmtStringObjType)
-        SetScanFmtFromAny(interp, argv[2]);
-    if (FormatGetError(argv[2]) != 0) {
-        Jim_SetResultString(interp, FormatGetError(argv[2]), -1);
-        return JIM_ERR;
-    }
-    if (argc &gt; 3) {
-        int maxPos = FormatGetMaxPos(argv[2]);
-        int arg_count = FormatGetCnvCount(argv[2]);
-        if (maxPos &gt; argc-3) {
-            Jim_SetResultString(interp, &quot;\&quot;%n$\&quot; argument index out of range&quot;, -1);
-            return JIM_ERR;
-        } else if (arg_count != 0 &amp;&amp; arg_count &lt; argc-3) {
-            Jim_SetResultString(interp, &quot;variable is not assigned by any &quot;
-                &quot;conversion specifiers&quot;, -1);
-            return JIM_ERR;
-        } else if (arg_count &gt; argc-3) {
-            Jim_SetResultString(interp, &quot;different numbers of variable names and &quot;
-                &quot;field specifiers&quot;, -1);
-            return JIM_ERR;
-        }
-    }
-    listPtr = Jim_ScanString(interp, argv[1], argv[2], JIM_ERRMSG);
-    if (listPtr == 0)
-        return JIM_ERR;
-    if (argc &gt; 3) {
-        int len = 0;
-        if (listPtr != 0 &amp;&amp; listPtr != (Jim_Obj*)EOF)
-            Jim_ListLength(interp, listPtr, &amp;len);
-        if (listPtr == (Jim_Obj*)EOF || len == 0) { // XXX
-            Jim_SetResult(interp, Jim_NewIntObj(interp, -1));
-            return JIM_OK;
-        }
-        JimListGetElements(interp, listPtr, &amp;outc, &amp;outVec);
-        for (i = 0; i &lt; outc; ++i) {
-            if (Jim_Len
-
-/* [error] */
-static int Jim_ErrorCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;message&quot;);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, argv[1]);
-    return JIM_ERR;
-}
-
-/* [lrange] */
-static int Jim_LrangeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *objPtr;
-
-    if (argc != 4) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;list first last&quot;);
-        return JIM_ERR;
-    }
-    if ((objPtr = Jim_ListRange(interp, argv[1], argv[2], argv[3])) == NULL)
-        return JIM_ERR;
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [env] */
-static int Jim_EnvCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    const char *key;
-    char *val;
-
-    if (argc == 1) {
-
-#ifdef NEED_ENVIRON_EXTERN
-        extern char **environ;
-#endif
-
-        int i;
-        Jim_Obj *listObjPtr = Jim_NewListObj(interp, NULL, 0);
-
-        for (i = 0; environ[i]; i++) {
-            const char *equals = strchr(environ[i], '=');
-            if (equals) {
-                Jim_ListAppendElement(interp, listObjPtr, Jim_NewStringObj(interp, environ[i], equals - environ[i]));
-                Jim_ListAppendElement(interp, listObjPtr, Jim_NewStringObj(interp, equals + 1, -1));
-            }
-        }
-
-        Jim_SetResult(interp, listObjPtr);
-        return JIM_OK;
-    }
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;varName&quot;);
-        return JIM_ERR;
-    }
-    key = Jim_GetString(argv[1], NULL);
-    val = getenv(key);
-    if (val == NULL) {
-        Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-        Jim_AppendStrings(interp, Jim_GetResult(interp),
-                &quot;environment variable \&quot;&quot;,
-                key, &quot;\&quot; does not exist&quot;, NULL);
-        return JIM_ERR;
-    }
-    Jim_SetResult(interp, Jim_NewStringObj(interp, val, -1));
-    return JIM_OK;
-}
-
-/* [source] */
-static int Jim_SourceCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int retval;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;fileName&quot;);
-        return JIM_ERR;
-    }
-    retval = Jim_EvalFile(interp, Jim_GetString(argv[1], NULL));
-    if (retval == JIM_ERR) {
-        return JIM_ERR_ADDSTACK;
-    }
-    if (retval == JIM_RETURN)
-        return JIM_OK;
-    return retval;
-}
-
-/* [lreverse] */
-static int Jim_LreverseCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    Jim_Obj *revObjPtr, **ele;
-    int len;
-
-    if (argc != 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;list&quot;);
-        return JIM_ERR;
-    }
-    JimListGetElements(interp, argv[1], &amp;len, &amp;ele);
-    len--;
-    revObjPtr = Jim_NewListObj(interp, NULL, 0);
-    while (len &gt;= 0)
-        ListAppendElement(revObjPtr, ele[len--]);
-    Jim_SetResult(interp, revObjPtr);
-    return JIM_OK;
-}
-
-static int JimRangeLen(jim_wide start, jim_wide end, jim_wide step)
-{
-    jim_wide len;
-
-    if (step == 0) return -1;
-    if (start == end) return 0;
-    else if (step &gt; 0 &amp;&amp; start &gt; end) return -1;
-    else if (step &lt; 0 &amp;&amp; end &gt; start) return -1;
-    len = end-start;
-    if (len &lt; 0) len = -len; /* abs(len) */
-    if (step &lt; 0) step = -step; /* abs(step) */
-    len = 1 + ((len-1)/step);
-    /* We can truncate safely to INT_MAX, the range command
-     * will always return an error for a such long range
-     * because Tcl lists can't be so long. */
-    if (len &gt; INT_MAX) len = INT_MAX;
-    return (int)((len &lt; 0) ? -1 : len);
-}
-
-/* [range] */
-static int Jim_RangeCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    jim_wide start = 0, end, step = 1;
-    int len, i;
-    Jim_Obj *objPtr;
-
-    if (argc &lt; 2 || argc &gt; 4) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;?start? end ?step?&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 2) {
-        if (Jim_GetWide(interp, argv[1], &amp;end) != JIM_OK)
-            return JIM_ERR;
-    } else {
-        if (Jim_GetWide(interp, argv[1], &amp;start) != JIM_OK ||
-            Jim_GetWide(interp, argv[2], &amp;end) != JIM_OK)
-            return JIM_ERR;
-        if (argc == 4 &amp;&amp; Jim_GetWide(interp, argv[3], &amp;step) != JIM_OK)
-            return JIM_ERR;
-    }
-    if ((len = JimRangeLen(start, end, step)) == -1) {
-        Jim_SetResultString(interp, &quot;Invalid (infinite?) range specified&quot;, -1);
-        return JIM_ERR;
-    }
-    objPtr = Jim_NewListObj(interp, NULL, 0);
-    for (i = 0; i &lt; len; i++)
-        ListAppendElement(objPtr, Jim_NewIntObj(interp, start + i*step));
-    Jim_SetResult(interp, objPtr);
-    return JIM_OK;
-}
-
-/* [rand] */
-static int Jim_RandCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    jim_wide min = 0, max =0, len, maxMul;
-
-    if (argc &lt; 1 || argc &gt; 3) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;?min? max&quot;);
-        return JIM_ERR;
-    }
-    if (argc == 1) {
-        max = JIM_WIDE_MAX;
-    } else if (argc == 2) {
-        if (Jim_GetWide(interp, argv[1], &amp;max) != JIM_OK)
-            return JIM_ERR;
-    } else if (argc == 3) {
-        if (Jim_GetWide(interp, argv[1], &amp;min) != JIM_OK ||
-            Jim_GetWide(interp, argv[2], &amp;max) != JIM_OK)
-            return JIM_ERR;
-    }
-    len = max-min;
-    if (len &lt; 0) {
-        Jim_SetResultString(interp, &quot;Invalid arguments (max &lt; min)&quot;, -1);
-        return JIM_ERR;
-    }
-    maxMul = JIM_WIDE_MAX - (len ? (JIM_WIDE_MAX%len) : 0);
-    while (1) {
-        jim_wide r;
-
-        JimRandomBytes(interp, &amp;r, sizeof(jim_wide));
-        if (r &lt; 0 || r &gt;= maxMul) continue;
-        r = (len == 0) ? 0 : r%len;
-        Jim_SetResult(interp, Jim_NewIntObj(interp, min + r));
-        return JIM_OK;
-    }
-}
-
-/* [package] */
-static int Jim_PackageCoreCommand(Jim_Interp *interp, int argc,
-        Jim_Obj *const *argv)
-{
-    int option;
-    const char *options[] = {
-        &quot;require&quot;, &quot;provide&quot;, NULL
-    };
-    enum {OPT_REQUIRE, OPT_PROVIDE};
-
-    if (argc &lt; 2) {
-        Jim_WrongNumArgs(interp, 1, argv, &quot;option ?arguments ...?&quot;);
-        return JIM_ERR;
-    }
-    if (Jim_GetEnum(interp, argv[1], options, &amp;option, &quot;option&quot;,
-                JIM_ERRMSG) != JIM_OK)
-        return JIM_ERR;
-
-    if (option == OPT_REQUIRE) {
-        int exact = 0;
-        const char *ver;
-
-        if (Jim_CompareStringImmediate(interp, argv[2], &quot;-exact&quot;)) {
-            exact = 1;
-            argv++;
-            argc--;
-        }
-        if (argc != 3 &amp;&amp; argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;?-exact? package ?version?&quot;);
-            return JIM_ERR;
-        }
-        ver = Jim_PackageRequire(interp, Jim_GetString(argv[2], NULL),
-                argc == 4 ? Jim_GetString(argv[3], NULL) : &quot;&quot;,
-                JIM_ERRMSG);
-        if (ver == NULL)
-            return JIM_ERR_ADDSTACK;
-        Jim_SetResultString(interp, ver, -1);
-    } else if (option == OPT_PROVIDE) {
-        if (argc != 4) {
-            Jim_WrongNumArgs(interp, 2, argv, &quot;package version&quot;);
-            return JIM_ERR;
-        }
-        return Jim_PackageProvide(interp, Jim_GetString(argv[2], NULL),
-                    Jim_GetString(argv[3], NULL), JIM_ERRMSG);
-    }
-    return JIM_OK;
-}
-
-static struct {
-    const char *name;
-    Jim_CmdProc cmdProc;
-} Jim_CoreCommandsTable[] = {
-    {&quot;set&quot;, Jim_SetCoreCommand},
-    {&quot;unset&quot;, Jim_UnsetCoreCommand},
-    {&quot;puts&quot;, Jim_PutsCoreCommand},
-    {&quot;+&quot;, Jim_AddCoreCommand},
-    {&quot;*&quot;, Jim_MulCoreCommand},
-    {&quot;-&quot;, Jim_SubCoreCommand},
-    {&quot;/&quot;, Jim_DivCoreCommand},
-    {&quot;incr&quot;, Jim_IncrCoreCommand},
-    {&quot;while&quot;, Jim_WhileCoreCommand},
-    {&quot;for&quot;, Jim_ForCoreCommand},
-    {&quot;foreach&quot;, Jim_ForeachCoreCommand},
-    {&quot;lmap&quot;, Jim_LmapCoreCommand},
-    {&quot;if&quot;, Jim_IfCoreCommand},
-    {&quot;switch&quot;, Jim_SwitchCoreCommand},
-    {&quot;list&quot;, Jim_ListCoreCommand},
-    {&quot;lindex&quot;, Jim_LindexCoreCommand},
-    {&quot;lset&quot;, Jim_LsetCoreCommand},
-    {&quot;llength&quot;, Jim_LlengthCoreCommand},
-    {&quot;lappend&quot;, Jim_LappendCoreCommand},
-    {&quot;linsert&quot;, Jim_LinsertCoreCommand},
-    {&quot;lsort&quot;, Jim_LsortCoreCommand},
-    {&quot;append&quot;, Jim_AppendCoreCommand},
-    {&quot;debug&quot;, Jim_DebugCoreCommand},
-    {&quot;eval&quot;, Jim_EvalCoreCommand},
-    {&quot;uplevel&quot;, Jim_UplevelCoreCommand},
-    {&quot;expr&quot;, Jim_ExprCoreCommand},
-    {&quot;break&quot;, Jim_BreakCoreCommand},
-    {&quot;continue&quot;, Jim_ContinueCoreCommand},
-    {&quot;proc&quot;, Jim_ProcCoreCommand},
-    {&quot;concat&quot;, Jim_ConcatCoreCommand},
-    {&quot;return&quot;, Jim_ReturnCoreCommand},
-    {&quot;upvar&quot;, Jim_UpvarCoreCommand},
-    {&quot;global&quot;, Jim_GlobalCoreCommand},
-    {&quot;string&quot;, Jim_StringCoreCommand},
-    {&quot;time&quot;, Jim_TimeCoreCommand},
-    {&quot;exit&quot;, Jim_ExitCoreCommand},
-    {&quot;catch&quot;, Jim_CatchCoreCommand},
-    {&quot;ref&quot;, Jim_RefCoreCommand},
-    {&quot;getref&quot;, Jim_GetrefCoreCommand},
-    {&quot;setref&quot;, Jim_SetrefCoreCommand},
-    {&quot;finalize&quot;, Jim_FinalizeCoreCommand},
-    {&quot;collect&quot;, Jim_CollectCoreCommand},
-    {&quot;rename&quot;, Jim_RenameCoreCommand},
-    {&quot;dict&quot;, Jim_DictCoreCommand},
-    {&quot;load&quot;, Jim_LoadCoreCommand},
-    {&quot;subst&quot;, Jim_SubstCoreCommand},
-    {&quot;info&quot;, Jim_InfoCoreCommand},
-    {&quot;split&quot;, Jim_SplitCoreCommand},
-    {&quot;join&quot;, Jim_JoinCoreCommand},
-    {&quot;format&quot;, Jim_FormatCoreCommand},
-    {&quot;scan&quot;, Jim_ScanCoreCommand},
-    {&quot;error&quot;, Jim_ErrorCoreCommand},
-    {&quot;lrange&quot;, Jim_LrangeCoreCommand},
-    {&quot;env&quot;, Jim_EnvCoreCommand},
-    {&quot;source&quot;, Jim_SourceCoreCommand},
-    {&quot;lreverse&quot;, Jim_LreverseCoreCommand},
-    {&quot;range&quot;, Jim_RangeCoreCommand},
-    {&quot;rand&quot;, Jim_RandCoreCommand},
-    {&quot;package&quot;, Jim_PackageCoreCommand},
-    {&quot;tailcall&quot;, Jim_TailcallCoreCommand},
-    {NULL, NULL},
-};
-
-/* Some Jim core command is actually a procedure written in Jim itself. */
-static void Jim_RegisterCoreProcedures(Jim_Interp *interp)
-{
-    Jim_Eval(interp, (char*)
-&quot;proc lambda {arglist args} {\n&quot;
-&quot;    set name [ref {} function lambdaFinalizer]\n&quot;
-&quot;    uplevel 1 [list proc $name $arglist {expand}$args]\n&quot;
-&quot;    return $name\n&quot;
-&quot;}\n&quot;
-&quot;proc lambdaFinalizer {name val} {\n&quot;
-&quot;    rename $name {}\n&quot;
-&quot;}\n&quot;
-);
-}
-
-void Jim_RegisterCoreCommands(Jim_Interp *interp)
-{
-    int i = 0;
-
-    while (Jim_CoreCommandsTable[i].name != NULL) {
-        Jim_CreateCommand(interp,
-                Jim_CoreCommandsTable[i].name,
-                Jim_CoreCommandsTable[i].cmdProc,
-                NULL, NULL);
-        i++;
-    }
-    Jim_RegisterCoreProcedures(interp);
-}
-
-/* -----------------------------------------------------------------------------
- * Interactive prompt
- * ---------------------------------------------------------------------------*/
-void Jim_PrintErrorMessage(Jim_Interp *interp)
-{
-    int len, i;
-
-    if (*interp-&gt;errorFileName) {
-        Jim_fprintf(interp, interp-&gt;cookie_stderr, &quot;Runtime error, file \&quot;%s\&quot;, line %d:&quot; JIM_NL &quot;    &quot;,
-                                    interp-&gt;errorFileName, interp-&gt;errorLine);
-    }
-    Jim_fprintf(interp,interp-&gt;cookie_stderr, &quot;%s&quot; JIM_NL,
-            Jim_GetString(interp-&gt;result, NULL));
-    Jim_ListLength(interp, interp-&gt;stackTrace, &amp;len);
-    for (i = len-3; i &gt;= 0; i-= 3) {
-        Jim_Obj *objPtr=NULL;
-        const char *proc, *file, *line;
-
-        Jim_ListIndex(interp, interp-&gt;stackTrace, i, &amp;objPtr, JIM_NONE);
-        proc = Jim_GetString(objPtr, NULL);
-        Jim_ListIndex(interp, interp-&gt;stackTrace, i + 1, &amp;objPtr,
-                JIM_NONE);
-        file = Jim_GetString(objPtr, NULL);
-        Jim_ListIndex(interp, interp-&gt;stackTrace, i + 2, &amp;objPtr,
-                JIM_NONE);
-        line = Jim_GetString(objPtr, NULL);
-        if (*proc) {
-            Jim_fprintf(interp, interp-&gt;cookie_stderr,
-                    &quot;in procedure '%s' &quot;, proc);
-        }
-        if (*file) {
-            Jim_fprintf(interp, interp-&gt;cookie_stderr,
-                    &quot;called at file \&quot;%s\&quot;, line %s&quot;,
-                    file, line);
-        }
-        if (*file || *proc) {
-            Jim_fprintf(interp, interp-&gt;cookie_stderr, JIM_NL);
-        }
-    }
-}
-
-int Jim_InteractivePrompt(Jim_Interp *interp)
-{
-    int retcode = JIM_OK;
-    Jim_Obj *scriptObjPtr;
-
-    Jim_fprintf(interp,interp-&gt;cookie_stdout, &quot;Welcome to Jim version %d.%d, &quot;
-           &quot;Copyright (c) 2005-8 Salvatore Sanfilippo&quot; JIM_NL,
-           JIM_VERSION / 100, JIM_VERSION % 100);
-     Jim_SetVariableStrWithStr(interp, &quot;jim_interactive&quot;, &quot;1&quot;);
-    while (1) {
-        char buf[1024];
-        const char *result;
-        const char *retcodestr[] = {
-            &quot;ok&quot;, &quot;error&quot;, &quot;return&quot;, &quot;break&quot;, &quot;continue&quot;, &quot;eval&quot;, &quot;exit&quot;
-        };
-        int reslen;
-
-        if (retcode != 0) {
-            if (retcode &gt;= 2 &amp;&amp; retcode &lt;= 6)
-                Jim_fprintf(interp,interp-&gt;cookie_stdout, &quot;[%s] . &quot;, retcodestr[retcode]);
-            else
-                Jim_fprintf(interp,interp-&gt;cookie_stdout, &quot;[%d] . &quot;, retcode);
-        } else
-            Jim_fprintf(interp, interp-&gt;cookie_stdout, &quot;. &quot;);
-        Jim_fflush(interp, interp-&gt;cookie_stdout);
-        scriptObjPtr = Jim_NewStringObj(interp, &quot;&quot;, 0);
-        Jim_IncrRefCount(scriptObjPtr);
-        while (1) {
-            const char *str;
-            char state;
-            int len;
-
-            if (Jim_fgets(interp, buf, 1024, interp-&gt;cookie_stdin) == NULL) {
-                Jim_DecrRefCount(interp, scriptObjPtr);
-                goto out;
-            }
-            Jim_AppendString(interp, scriptObjPtr, buf, -1);
-            str = Jim_GetString(scriptObjPtr, &amp;len);
-            if (Jim_ScriptIsComplete(str, len, &amp;state))
-                break;
-            Jim_fprintf(interp, interp-&gt;cookie_stdout, &quot;%c&gt; &quot;, state);
-            Jim_fflush(interp, interp-&gt;cookie_stdout);
-        }
-        retcode = Jim_EvalObj(interp, scriptObjPtr);
-        Jim_DecrRefCount(interp, scriptObjPtr);
-        result = Jim_GetString(Jim_GetResult(interp), &amp;reslen);
-        if (retcode == JIM_ERR) {
-            Jim_PrintErrorMessage(interp);
-        } else if (retcode == JIM_EXIT) {
-            exit(Jim_GetExitCode(interp));
-        } else {
-            if (reslen) {
-				Jim_fwrite(interp, result, 1, reslen, interp-&gt;cookie_stdout);
-				Jim_fprintf(interp,interp-&gt;cookie_stdout, JIM_NL);
-            }
-        }
-    }
-out:
-    return 0;
-}
-
-/* -----------------------------------------------------------------------------
- * Jim's idea of STDIO..
- * ---------------------------------------------------------------------------*/
-
-int Jim_fprintf(Jim_Interp *interp, void *cookie, const char *fmt, ...)
-{
-	int r;
-
-	va_list ap;
-	va_start(ap,fmt);
-	r = Jim_vfprintf(interp, cookie, fmt,ap);
-	va_end(ap);
-	return r;
-}
-
-int Jim_vfprintf(Jim_Interp *interp, void *cookie, const char *fmt, va_list ap)
-{
-	if ((interp == NULL) || (interp-&gt;cb_vfprintf == NULL)) {
-		errno = ENOTSUP;
-		return -1;
-	}
-	return (*(interp-&gt;cb_vfprintf))(cookie, fmt, ap);
-}
-
-size_t Jim_fwrite(Jim_Interp *interp, const void *ptr, size_t size, size_t n, void *cookie)
-{
-	if ((interp == NULL) || (interp-&gt;cb_fwrite == NULL)) {
-		errno = ENOTSUP;
-		return 0;
-	}
-	return (*(interp-&gt;cb_fwrite))(ptr, size, n, cookie);
-}
-
-size_t Jim_fread(Jim_Interp *interp, void *ptr, size_t size, size_t n, void *cookie)
-{
-	if ((interp == NULL) || (interp-&gt;cb_fread == NULL)) {
-		errno = ENOTSUP;
-		return 0;
-	}
-	return (*(interp-&gt;cb_fread))(ptr, size, n, cookie);
-}
-
-int Jim_fflush(Jim_Interp *interp, void *cookie)
-{
-	if ((interp == NULL) || (interp-&gt;cb_fflush == NULL)) {
-		/* pretend all is well */
-		return 0;
-	}
-	return (*(interp-&gt;cb_fflush))(cookie);
-}
-
-char* Jim_fgets(Jim_Interp *interp, char *s, int size, void *cookie)
-{
-	if ((interp == NULL) || (interp-&gt;cb_fgets == NULL)) {
-		errno = ENOTSUP;
-		return NULL;
-	}
-	return (*(interp-&gt;cb_fgets))(s, size, cookie);
-}
-Jim_Nvp *
-Jim_Nvp_name2value_simple(const Jim_Nvp *p, const char *name)
-{
-	while (p-&gt;name) {
-		if (0 == strcmp(name, p-&gt;name)) {
-			break;
-		}
-		p++;
-	}
-	return ((Jim_Nvp *)(p));
-}
-
-Jim_Nvp *
-Jim_Nvp_name2value_nocase_simple(const Jim_Nvp *p, const char *name)
-{
-	while (p-&gt;name) {
-		if (0 == strcasecmp(name, p-&gt;name)) {
-			break;
-		}
-		p++;
-	}
-	return ((Jim_Nvp *)(p));
-}
-
-int
-Jim_Nvp_name2value_obj(Jim_Interp *interp,
-						const Jim_Nvp *p,
-						Jim_Obj *o,
-						Jim_Nvp **result)
-{
-	return Jim_Nvp_name2value(interp, p, Jim_GetString(o, NULL), result);
-}
-
-
-int
-Jim_Nvp_name2value(Jim_Interp *interp,
-					const Jim_Nvp *_p,
-					const char *name,
-					Jim_Nvp **result)
-{
-	const Jim_Nvp *p;
-
-	p = Jim_Nvp_name2value_simple(_p, name);
-
-	/* result */
-	if (result) {
-		*result = (Jim_Nvp *)(p);
-	}
-
-	/* found? */
-	if (p-&gt;name) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-int
-Jim_Nvp_name2value_obj_nocase(Jim_Interp *interp, const Jim_Nvp *p, Jim_Obj *o, Jim_Nvp **puthere)
-{
-	return Jim_Nvp_name2value_nocase(interp, p, Jim_GetString(o, NULL), puthere);
-}
-
-int
-Jim_Nvp_name2value_nocase(Jim_Interp *interp, const Jim_Nvp *_p, const char *name, Jim_Nvp **puthere)
-{
-	const Jim_Nvp *p;
-
-	p = Jim_Nvp_name2value_nocase_simple(_p, name);
-
-	if (puthere) {
-		*puthere = (Jim_Nvp *)(p);
-	}
-	/* found */
-	if (p-&gt;name) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-
-int
-Jim_Nvp_value2name_obj(Jim_Interp *interp, const Jim_Nvp *p, Jim_Obj *o, Jim_Nvp **result)
-{
-	int e;;
-	jim_wide w;
-
-	e = Jim_GetWide(interp, o, &amp;w);
-	if (e != JIM_OK) {
-		return e;
-	}
-
-	return Jim_Nvp_value2name(interp, p, w, result);
-}
-
-Jim_Nvp *
-Jim_Nvp_value2name_simple(const Jim_Nvp *p, int value)
-{
-	while (p-&gt;name) {
-		if (value == p-&gt;value) {
-			break;
-		}
-		p++;
-	}
-	return ((Jim_Nvp *)(p));
-}
-
-
-int
-Jim_Nvp_value2name(Jim_Interp *interp, const Jim_Nvp *_p, int value, Jim_Nvp **result)
-{
-	const Jim_Nvp *p;
-
-	p = Jim_Nvp_value2name_simple(_p, value);
-
-	if (result) {
-		*result = (Jim_Nvp *)(p);
-	}
-
-	if (p-&gt;name) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-
-int
-Jim_GetOpt_Setup(Jim_GetOptInfo *p, Jim_Interp *interp, int argc, Jim_Obj * const *  argv)
-{
-	memset(p, 0, sizeof(*p));
-	p-&gt;interp = interp;
-	p-&gt;argc   = argc;
-	p-&gt;argv   = argv;
-
-	return JIM_OK;
-}
-
-void
-Jim_GetOpt_Debug(Jim_GetOptInfo *p)
-{
-	int x;
-
-	Jim_fprintf(p-&gt;interp, p-&gt;interp-&gt;cookie_stderr, &quot;---args---\n&quot;);
-	for (x = 0 ; x &lt; p-&gt;argc ; x++) {
-		Jim_fprintf(p-&gt;interp, p-&gt;interp-&gt;cookie_stderr,
-					 &quot;%2d) %s\n&quot;,
-					 x,
-					 Jim_GetString(p-&gt;argv[x], NULL));
-	}
-	Jim_fprintf(p-&gt;interp, p-&gt;interp-&gt;cookie_stderr, &quot;-------\n&quot;);
-}
-
-
-int
-Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere)
-{
-	Jim_Obj *o;
-
-	o = NULL; // failure
-	if (goi-&gt;argc) {
-		// success
-		o = goi-&gt;argv[0];
-		goi-&gt;argc -= 1;
-		goi-&gt;argv += 1;
-	}
-	if (puthere) {
-		*puthere = o;
-	}
-	if (o != NULL) {
-		return JIM_OK;
-	} else {
-		return JIM_ERR;
-	}
-}
-
-int
-Jim_GetOpt_String(Jim_GetOptInfo *goi, char **puthere, int *len)
-{
-	int r;
-	Jim_Obj *o;
-	const char *cp;
-
-
-	r = Jim_GetOpt_Obj(goi, &amp;o);
-	if (r == JIM_OK) {
-		cp = Jim_GetString(o, len);
-		if (puthere) {
-			/* remove const */
-			*puthere = (char *)(cp);
-		}
-	}
-	return r;
-}
-
-int
-Jim_GetOpt_Double(Jim_GetOptInfo *goi, double *puthere)
-{
-	int r;
-	Jim_Obj *o;
-	double _safe;
-
-	if (puthere == NULL) {
-		puthere = &amp;_safe;
-	}
-
-	r = Jim_GetOpt_Obj(goi, &amp;o);
-	if (r == JIM_OK) {
-		r = Jim_GetDouble(goi-&gt;interp, o, puthere);
-		if (r != JIM_OK) {
-			Jim_SetResult_sprintf(goi-&gt;interp,
-								   &quot;not a number: %s&quot;,
-								   Jim_GetString(o, NULL));
-		}
-	}
-	return r;
-}
-
-int
-Jim_GetOpt_Wide(Jim_GetOptInfo *goi, jim_wide *puthere)
-{
-	int r;
-	Jim_Obj *o;
-	jim_wide _safe;
-
-	if (puthere == NULL) {
-		puthere = &amp;_safe;
-	}
-
-	r = Jim_GetOpt_Obj(goi, &amp;o);
-	if (r == JIM_OK) {
-		r = Jim_GetWide(goi-&gt;interp, o, puthere);
-	}
-	return r;
-}
-
-int Jim_GetOpt_Nvp(Jim_GetOptInfo *goi,
-					const Jim_Nvp *nvp,
-					Jim_Nvp **puthere)
-{
-	Jim_Nvp *_safe;
-	Jim_Obj *o;
-	int e;
-
-	if (puthere == NULL) {
-		puthere = &amp;_safe;
-	}
-
-	e = Jim_GetOpt_Obj(goi, &amp;o);
-	if (e == JIM_OK) {
-		e = Jim_Nvp_name2value_obj(goi-&gt;interp,
-									nvp,
-									o,
-									puthere);
-	}
-
-	return e;
-}
-
-void
-Jim_GetOpt_NvpUnknown(Jim_GetOptInfo *goi,
-					   const Jim_Nvp *nvptable,
-					   int hadprefix)
-{
-	if (hadprefix) {
-		Jim_SetResult_NvpUnknown(goi-&gt;interp,
-								  goi-&gt;argv[-2],
-								  goi-&gt;argv[-1],
-								  nvptable);
-	} else {
-		Jim_SetResult_NvpUnknown(goi-&gt;interp,
-								  NULL,
-								  goi-&gt;argv[-1],
-								  nvptable);
-	}
-}
-
-
-int
-Jim_GetOpt_Enum(Jim_GetOptInfo *goi,
-				 const char * const *  lookup,
-				 int *puthere)
-{
-	int _safe;
-	Jim_Obj *o;
-	int e;
-
-	if (puthere == NULL) {
-		puthere = &amp;_safe;
-	}
-	e = Jim_GetOpt_Obj(goi, &amp;o);
-	if (e == JIM_OK) {
-		e = Jim_GetEnum(goi-&gt;interp,
-						 o,
-						 lookup,
-						 puthere,
-						 &quot;option&quot;,
-						 JIM_ERRMSG);
-	}
-	return e;
-}
-
-
-
-int
-Jim_SetResult_sprintf(Jim_Interp *interp, const char *fmt,...)
-{
-	va_list ap;
-	char *buf;
-
-	va_start(ap,fmt);
-	buf = jim_vasprintf(fmt, ap);
-	va_end(ap);
-	if (buf) {
-		Jim_SetResultString(interp, buf, -1);
-		jim_vasprintf_done(buf);
-	}
-	return JIM_OK;
-}
-
-
-void
-Jim_SetResult_NvpUnknown(Jim_Interp *interp,
-						  Jim_Obj *param_name,
-						  Jim_Obj *param_value,
-						  const Jim_Nvp *nvp)
-{
-	if (param_name) {
-		Jim_SetResult_sprintf(interp,
-							   &quot;%s: Unknown: %s, try one of: &quot;,
-							   Jim_GetString(param_name, NULL),
-							   Jim_GetString(param_value, NULL));
-	} else {
-		Jim_SetResult_sprintf(interp,
-							   &quot;Unknown param: %s, try one of: &quot;,
-							   Jim_GetString(param_value, NULL));
-	}
-	while (nvp-&gt;name) {
-		const char *a;
-		const char *b;
-
-		if ((nvp + 1)-&gt;name) {
-			a = nvp-&gt;name;
-			b = &quot;, &quot;;
-		} else {
-			a = &quot;or &quot;;
-			b = nvp-&gt;name;
-		}
-		Jim_AppendStrings(interp,
-						   Jim_GetResult(interp),
-						   a, b, NULL);
-		nvp++;
-	}
-}
-
-
-static Jim_Obj *debug_string_obj;
-
-const char *
-Jim_Debug_ArgvString(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	int x;
-
-	if (debug_string_obj) {
-		Jim_FreeObj(interp, debug_string_obj);
-	}
-
-	debug_string_obj = Jim_NewEmptyStringObj(interp);
-	for (x = 0 ; x &lt; argc ; x++) {
-		Jim_AppendStrings(interp,
-						   debug_string_obj,
-						   Jim_GetString(argv[x], NULL),
-						   &quot; &quot;,
-						   NULL);
-	}
-
-	return Jim_GetString(debug_string_obj, NULL);
-}

-----------------------------------------------------------------------

Summary of changes:
 src/helper/#jim.c# |12823 ----------------------------------------------------
 1 files changed, 0 insertions(+), 12823 deletions(-)
 delete mode 100644 src/helper/#jim.c#


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002283.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-328-g8022940
</A></li>
	<LI>Next message: <A HREF="002285.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.4.0-332-g72d227c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2284">[ date ]</a>
              <a href="thread.html#2284">[ thread ]</a>
              <a href="subject.html#2284">[ subject ]</a>
              <a href="author.html#2284">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
