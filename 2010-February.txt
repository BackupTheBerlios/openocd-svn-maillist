From dbrownell at users.sourceforge.net  Mon Feb  1 01:55:23 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon,  1 Feb 2010 00:55:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-168-g82f2492
Message-ID: <E1NbkZZ-0000Qr-Kc@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  82f2492138e053d5e3577e83b80cab8d41c0d08b (commit)
      from  02731cf78b3663739e3755295a4239f2658a3fdc (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 82f2492138e053d5e3577e83b80cab8d41c0d08b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Jan 31 14:16:53 2010 -0800

    ADIv5: more messaging cleanup, docs
    
    When the TAR cache was explicitly invalidated, don't bother
    printing it; the actual hardware status is more informative.
    
    Provide some doxygen for the MEM-AP setup routine.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index bfa5cb4..4089567 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -334,7 +334,10 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 		{
 			uint32_t mem_ap_csw, mem_ap_tar;
 
-			/* Maybe print information about last MEM-AP access */
+			/* Maybe print information about last intended
+			 * MEM-AP access; but not if autoincrementing.
+			 * *Real* CSW and TAR values are always shown.
+			 */
 			if (swjdp->ap_tar_value != (uint32_t) -1)
 				LOG_DEBUG("MEM-AP Cached values: "
 					"ap_bank 0x%" PRIx32
@@ -343,8 +346,6 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 					swjdp->dp_select_value,
 					swjdp->ap_csw_value,
 					swjdp->ap_tar_value);
-			else
-				LOG_ERROR("Invalid MEM-AP TAR cache!");
 
 			if (ctrlstat & SSTICKYORUN)
 				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
@@ -463,12 +464,21 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t
 	return ERROR_OK;
 }
 
-/***************************************************************************
- *                                                                         *
- * AHB-AP access to memory and system registers on AHB bus                 *
- *                                                                         *
-***************************************************************************/
-
+/**
+ * Set up transfer parameters for the currently selected MEM-AP.
+ * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
+ * initiate data reads or writes using memory or peripheral addresses.
+ * If the CSW is configured for it, the TAR may be automatically
+ * incremented after each transfer.
+ *
+ * @todo Rename to reflect it being specifically a MEM-AP function.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param csw MEM-AP Control/Status Word (CSW) register to assign.  If this
+ *	matches the cached value, the register is not changed.
+ * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
+ *	matches the cached address, the register is not changed.
+ */
 int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 {
 	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
@@ -484,11 +494,9 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 		dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar);
 		swjdp->ap_tar_value = tar;
 	}
+	/* Disable TAR cache when autoincrementing */
 	if (csw & CSW_ADDRINC_MASK)
-	{
-		/* Do not cache TAR value when autoincrementing */
 		swjdp->ap_tar_value = -1;
-	}
 	return ERROR_OK;
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   32 ++++++++++++++++++++------------
 1 files changed, 20 insertions(+), 12 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb  1 13:44:17 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  1 Feb 2010 12:44:17 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-169-g91e3268
Message-ID: <E1Nbvdt-0002mU-8e@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  91e3268737b578a182cb661d60551657f799ab3c (commit)
      from  82f2492138e053d5e3577e83b80cab8d41c0d08b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 91e3268737b578a182cb661d60551657f799ab3c
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Sun Jan 31 21:02:06 2010 +0100

    gdb: restore behavior from 0.3.1 for srst_asserted and power_restore
    
    srst_asserted and power_restore can now be overriden to do
    nothing. By default they will "reset init" the targets and
    halt gdb.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/startup.tcl b/src/jtag/startup.tcl
index ab215ba..4e6d5fc 100644
--- a/src/jtag/startup.tcl
+++ b/src/jtag/startup.tcl
@@ -30,8 +30,18 @@ proc init_reset { mode } {
 # documented nor supported except on ZY1000.
 
 proc power_restore {} {
-	puts "Sensed power restore."
+	puts "Sensed power restore, running reset init and halting GDB."
 	reset init
+	
+	# Halt GDB so user can deal with a detected power restore.
+	#
+	# After GDB is halted, then output is no longer forwarded
+	# to the GDB console.
+	set targets [target names]	
+	foreach t $targets {
+		# New event script.
+		$t invoke-event arp_halt_gdb
+	}	
 }
 
 add_help_text power_restore "Overridable procedure run when power restore is detected. Runs 'reset init' by default."
@@ -46,9 +56,20 @@ proc power_dropout {} {
 # documented nor supported except on ZY1000.
 
 proc srst_deasserted {} {
-	puts "Sensed nSRST deasserted."
+	puts "Sensed nSRST deasserted, running reset init and halting GDB."
 	reset init
+
+	# Halt GDB so user can deal with a detected reset.
+	#
+	# After GDB is halted, then output is no longer forwarded
+	# to the GDB console.
+	set targets [target names]	
+	foreach t $targets {
+		# New event script.
+		$t invoke-event arp_halt_gdb
+	}		
 }
+
 add_help_text srst_deasserted "Overridable procedure run when srst deassert is detected. Runs 'reset init' by default."
 
 proc srst_asserted {} {
diff --git a/src/target/target.c b/src/target/target.c
index 1eb65a6..2522408 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1739,15 +1739,6 @@ static int sense_handler(void)
 	return ERROR_OK;
 }
 
-static void target_call_event_callbacks_all(enum target_event e) {
-	struct target *target;
-	target = all_targets;
-	while (target) {
-		target_call_event_callbacks(target, e);
-		target = target->next;
-	}
-}
-
 /* process target state changes */
 static int handle_target(void *priv)
 {
@@ -1767,8 +1758,7 @@ static int handle_target(void *priv)
 		int did_something = 0;
 		if (runSrstAsserted)
 		{
-			LOG_INFO("Waking up GDB, srst asserted detected.");
-			target_call_event_callbacks_all(TARGET_EVENT_GDB_HALT);
+			LOG_INFO("srst asserted detected, running srst_asserted proc.");
 			Jim_Eval(interp, "srst_asserted");
 			did_something = 1;
 		}
@@ -1779,8 +1769,7 @@ static int handle_target(void *priv)
 		}
 		if (runPowerDropout)
 		{
-			LOG_INFO("Waking up GDB, power dropout detected.");
-			target_call_event_callbacks_all(TARGET_EVENT_GDB_HALT);
+			LOG_INFO("Power dropout detected, running power_dropout proc.");
 			Jim_Eval(interp, "power_dropout");
 			did_something = 1;
 		}
@@ -4065,6 +4054,21 @@ static int jim_target_examine(Jim_Interp *interp, int argc, Jim_Obj *const *argv
 	return JIM_OK;
 }
 
+static int jim_target_halt_gdb(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	if (argc != 1)
+	{
+		Jim_WrongNumArgs(interp, 1, argv, "[no parameters]");
+		return JIM_ERR;
+	}
+	struct target *target = Jim_CmdPrivData(interp);
+
+	if (target_call_event_callbacks(target, TARGET_EVENT_GDB_HALT) != ERROR_OK)
+		return JIM_ERR;
+
+	return JIM_OK;
+}
+
 static int jim_target_poll(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	if (argc != 1)
@@ -4346,6 +4350,12 @@ static const struct command_registration target_instance_command_handlers[] = {
 		.help = "used internally for reset processing",
 	},
 	{
+		.name = "arp_halt_gdb",
+		.mode = COMMAND_EXEC,
+		.jim_handler = jim_target_halt_gdb,
+		.help = "used internally for reset processing to halt GDB",
+	},
+	{
 		.name = "arp_poll",
 		.mode = COMMAND_EXEC,
 		.jim_handler = jim_target_poll,

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/startup.tcl |   25 +++++++++++++++++++++++--
 src/target/target.c  |   36 +++++++++++++++++++++++-------------
 2 files changed, 46 insertions(+), 15 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb  1 15:43:24 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon,  1 Feb 2010 14:43:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-170-gbef37ce
Message-ID: <E1NbxUt-0003sw-K1@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bef37ceba2bde6a34d003762bced007bed894bc7 (commit)
      from  91e3268737b578a182cb661d60551657f799ab3c (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bef37ceba2bde6a34d003762bced007bed894bc7
Author: Edgar Grimberg <edgar.grimberg at zylin.com>
Date:   Fri Jan 29 09:46:11 2010 +0100

    Test cases ran on v0.4.0-rc1
    
    Test cases ran on v0.4.0-rc1 for a number of targets:
    AT91FR40162
    LPC2148
    SAM7
    STR710
    STR912
    
    The goal of the testing session was to prove basic functionality of OpenOCD for different targets.
    
    Signed-off-by: Edgar Grimberg <edgar.grimberg at zylin.com>

diff --git a/testing/results/v0.4.0-rc1/AT91FR40162.html b/testing/results/v0.4.0-rc1/AT91FR40162.html
new file mode 100755
index 0000000..0baa31e
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/AT91FR40162.html
@@ -0,0 +1,856 @@
+<html>
+<head>
+<title>Test results for revision 1.62</title>
+</head>
+
+<body>
+
+<H1>SAM7</H1>
+
+<H2>Connectivity</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="CON001"/>CON001</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Telnet connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On console, type<br><code>telnet ip port</code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="CON002"/>CON002</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>GDB server connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On GDB console, type<br><code>target remote ip:port</code></td>
+		<td><code>Remote debugging using 10.0.0.73:3333</code></td>
+		<td><code>
+			(gdb) tar remo 10.0.0.138:3333<br>
+			Remote debugging using 10.0.0.138:3333<br>
+			0x000155b8 in ?? ()<br>
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Reset</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RES001"/>RES001</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				> mdw  0x01000000 32<br>                    
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				> reset halt<br>
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0x600000d3 pc: 0x00008a70<br>
+				> <br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES002"/>RES002</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Reset init on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset init</code></td>
+		<td>Reset should return without error and the output should contain <br><code>executing reset script 'name_of_the_script'</code></td>
+		<td>
+			<code>
+				> reset init<br>
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0x600000d3 pc: 0x00008ea4<br>
+				> <br>
+			</code>
+		</td>
+		<td>PASS<br>
+		NOTE! Even if there is no message, the reset script is being executed (proved by side effects)</td>	
+	</tr>
+	<tr>
+		<td><a name="RES003"/>RES003</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Reset after a power cycle of the target</td>
+		<td>Reset the target then power cycle the target</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code> after the power was detected</td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				Sensed nSRST asserted<br>
+				Sensed power dropout.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0xd5dff7e6<br>
+				Sensed power restore.<br>
+				Sensed nSRST deasserted<br>
+				> reset halt<br>
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0x0000072c<br>
+				><br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES004"/>RES004</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target where reset halt is supported</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted<br>pc = 0</code></td>
+		<td>
+			> reset halt<br>
+			JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in ARM state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0xf00000d3 pc: 0x00008b38<br>
+			> <br>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES005"/>RES005</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target using return clock</td>
+		<td>Erase all the content of the flash, set the configuration script to use RCLK</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				N/A, At91EB40A does <bold>NOT</bold> have support for RCLK
+			</code>	
+		</td>
+		<td>N/A</td>	
+	</tr>
+</table>
+
+<H2>JTAG Speed</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>ZY1000</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="SPD001"/>SPD001</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>16MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> reset halt<br>
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0x00008ae8<br>
+				> jtag_khz 16000  <br>
+				jtag_speed 4 => JTAG clk=16.000000<br>
+				16000 kHz<br>
+				> mdw 0 32   <br>   
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD002"/>SPD002</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>8MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> reset halt    <br>
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0x00008c14<br>
+				> jtag_khz 8000 <br>
+				jtag_speed 8 => JTAG clk=8.000000<br>
+				8000 kHz<br>
+				> mdw 0 32  <br>   
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				> <br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD003"/>SPD003</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>4MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> reset halt   <br>
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0x00008bc4<br>
+				> jtag_khz 4000<br>
+				jtag_speed 16 => JTAG clk=4.000000<br>
+				4000 kHz<br>
+				> mdw 0 32  <br>   
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				> <br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD004"/>SPD004</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>2MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> reset halt<br>
+				JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0x00009678<br>
+				> jtag_khz 2000<br>
+				jtag_speed 32 => JTAG clk=2.000000<br>
+				2000 kHz<br>
+				> mdw 0 32     <br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				> <br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD005"/>SPD005</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>RCLK on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 0<br>
+				RCLK - adaptive<br>
+				RCLK timeout<br>
+			</code>
+			N/A for this target
+		</td>
+		<td>N/A for this target</td>	
+	</tr>
+</table>
+
+<H2>Debugging</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="DBG001"/>DBG001</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Load is working</td>
+		<td>Reset init is working, RAM is accesible, GDB server is started</td>
+		<td>On the console of the OS: <br>
+			<code>$ arm-none-eabi-gdb redboot_ram.elf</code><br>
+			<code>(gdb) target remote ip:port</code><br>
+			<code>(gdb) load</load>
+		</td>
+		<td>Load should return without error, typical output looks like:<br>
+			<code>
+				Loading section .text, size 0x14c lma 0x0<br>
+				Start address 0x40, load size 332<br>
+				Transfer rate: 180 bytes/sec, 332 bytes/write.<br>
+			</code>
+		</td>
+		<td><code>
+			(gdb) load<br>
+			Loading section .rom_vectors, size 0x40 lma 0xc000<br>
+			Loading section .text, size 0x103e8 lma 0xc040<br>
+			Loading section .rodata, size 0x1a84 lma 0x1c428<br>
+			Loading section .data, size 0x3ec lma 0x1deac<br>
+			Start address 0xc040, load size 74392<br>
+			Transfer rate: 572 KB/sec, 9299 bytes/write.<br>
+			(gdb)
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	
+	<tr>
+		<td><a name="DBG002"/>DBG002</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Software breakpoint</td>
+		<td>Load the redboot_ram.elf application, use instructions from GDB001</td>
+		<td>In the GDB console:<br>
+			<code>
+				(gdb) monitor arm7_9 dbgrq enable<br>
+				software breakpoints enabled<br>
+				(gdb) break cyg_start<br>
+				Breakpoint 1 at 0xec: file src/main.c, line 71.<br>
+				(gdb) continue<br>
+				Continuing.
+			</code>
+		</td>
+		<td>The software breakpoint should be reached, a typical output looks like:<br>
+			<code>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69	  DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) monitor arm7_9 dbgrq enable<br>
+				use of EmbeddedICE dbgrq instead of breakpoint for target halt enabled<br>
+				(gdb) break cyg_start<br>
+				<br>
+				Breakpoint 1 at 0x155b8: file /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c, line 264.<br>
+				(gdb) continue<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, cyg_start ()<br>
+				    at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264<br>
+				264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);<br>
+				(gdb) <br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="DBG003"/>DBG003</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Single step in a RAM application</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>(gdb) step</code></td>
+		<td>The next instruction should be reached, typical output:<br>
+			<code>
+				(gdb) step<br>
+				70	  DWORD b = 2;
+
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) step<br>
+				266	    CYGACC_CALL_IF_MONITOR_RETURN_SET(return_to_redboot);<br>
+				(gdb)<br>
+			</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG004"/>DBG004</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Software break points are working after a reset</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>
+			(gdb) monitor reset init<br>
+			(gdb) load<br>
+			(gdb) continue<br>
+			</code></td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69	  DWORD a = 1;
+			</code>
+		</td>
+		<td><code>
+			(gdb) moni reset init<br>
+			JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in ARM state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0x600000d3 pc: 0x00008ae8<br>
+			(gdb) load<br>
+			Loading section .rom_vectors, size 0x40 lma 0xc000<br>
+			Loading section .text, size 0x103e8 lma 0xc040<br>
+			Loading section .rodata, size 0x1a84 lma 0x1c428<br>
+			Loading section .data, size 0x3ec lma 0x1deac<br>
+			Start address 0xc040, load size 74392<br>
+			Transfer rate: 576 KB/sec, 9299 bytes/write.<br>
+			(gdb) c<br>
+			Continuing.<br>
+			<br>
+			Breakpoint 1, cyg_start ()<br>
+			    at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264<br>
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);<br>
+			(gdb) <br>
+		</code></td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG005"/>DBG005</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint</td>
+		<td>Flash the redboot_rom.elf application. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset init<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor arm7_9  force_hw_bkpts enable<br>
+				force hardware breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+			(gdb) load<br>
+			Loading section .rom_vectors, size 0x40 lma 0x1000000<br>
+			Loading section .text, size 0x10638 lma 0x1000040<br>
+			Loading section .rodata, size 0x1a84 lma 0x1010678<br>
+			Loading section .data, size 0x428 lma 0x10120fc<br>
+			Start address 0x1000040, load size 75044<br>
+			Transfer rate: 33 KB/sec, 9380 bytes/write.<br>
+			(gdb) break cyg_start<br>
+			Breakpoint 1 at 0x100979c: file /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c, line 264.<br>
+			(gdb) c<br>
+			Continuing.<br>
+			Note: automatically using hardware breakpoints for read-only addresses.<br>
+			<br>
+			Breakpoint 1, cyg_start () at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264<br>
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);<br>
+			(gdb) <br>
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG006"/>DBG006</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint is set after a reset</td>
+		<td>Follow the instructions to flash and insert a hardware breakpoint from DBG005</td>
+		<td>In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) monitor reg pc 0x100000<br>
+				pc (/32): 0x00100000<br>
+				(gdb) continue
+			</code><br>
+			where the value inserted in PC is the start address of the application
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+			(gdb) moni reset init<br>
+			JTAG tap: zy1000.cpu tap/device found: 0x1f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x1)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in ARM state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0x200000d3 pc: 0x01000200<br>
+			(gdb) moni reg pc 0x1000000<br>
+			pc (/32): 0x01000000<br>
+			(gdb) c<br>
+			Continuing.<br>
+			<br>
+			Breakpoint 1, cyg_start () at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264<br>
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);<br>
+			(gdb) <br>
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG007"/>DBG007</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Single step in ROM</td>
+		<td>Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor arm7_9  force_hw_bkpts enable<br>
+				force hardware breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+				(gdb) step
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Supervisor<br>
+				cpsr: 0x60000013 pc: 0x0010013c<br>
+				70        DWORD b = 2;<br>
+			</code>
+		</td>
+		<td><code>
+			Breakpoint 1, cyg_start () at /home/edgar/temp/ecosboard/packages/redboot/current/src/main.c:264<br>
+			264	    CYGACC_CALL_IF_MONITOR_VERSION_SET(RedBoot_version);<br>
+			(gdb) step<br>
+			266	    CYGACC_CALL_IF_MONITOR_RETURN_SET(return_to_redboot);<br>
+		</code></td>
+		<td>PASS</td>
+	</tr>
+</table>
+
+<H2>RAM access</H2>
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RAM001"/>RAM001</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>32 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mww ram_address 0xdeadbeef 16<br>
+					> mdw ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.<br>
+			<code>
+				> mww 0x0 0xdeadbeef 16<br>
+				> mdw 0x0 32<br>
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388<br>
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388<br>
+			</code>
+		</td>
+		<td><code>
+			> mww 0 0xdeadbeef 16<br>
+			> mdw 0x0 32         <br>
+			0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+			0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef <br>
+			0x00000040: 15aadc6d 425b6f33 e789f955 d390dcc2 00080017 010067b4 010067b4 010067b4 <br>
+			0x00000060: 010067b4 00006e74 00006e74 010067b4 010067b4 010067b4 010067b4 010067b4 <br>
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM002"/>RAM002</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>16 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwh ram_address 0xbeef 16<br>
+					> mdh ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.<br>
+			<code>
+				> mwh 0x0 0xbeef 16<br>
+				> mdh 0x0 32<br>
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br>
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000<br>
+				>
+			</code>
+		</td>
+		<td><code>
+				> mwh 0 0xbeef 16<br>    
+				> mdh 0x0 32<br>
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br> 
+				0x00000020:   00   00   00   00   00   00   00   00   00   00   00   00   00   00   00   00 <br>
+			</code></td>
+		<td>PASS<br>There is a problem with the formatting of the output</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM003"/>RAM003</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>8 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwb ram_address 0xab 16<br>
+					> mdb ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.<br>
+			<code>
+				> mwb ram_address 0xab 16<br>
+				> mdb ram_address 32<br>
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>
+				>
+			</code>
+		</td>
+		<td><code>
+			> mwb 0x0 0xab 16<br>
+			> mdb 0x0 32     <br>
+			0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br> 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+
+
+<H2>Flash access</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="FLA001"/>FLA001</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Flash probe</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface:<br>
+			<code>	> flash probe 0</code>
+		</td>
+		<td>The command should execute without error. The output should state the name of the flash and the starting address. An example of output:<br>
+			<code>flash 'ecosflash' found at 0x01000000</code>
+		</td>
+		<td>
+		<code>
+			> flash probe 0
+			flash 'ecosflash' found at 0x01000000
+		</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA002"/>FLA002</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>flash fillw</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	> flash fillw 0x100000 0xdeadbeef 16
+			</code>
+		</td>
+		<td>The commands should execute without error. The output looks like:<br>
+			<code>
+				wrote 64 bytes to 0x0100000 in 11.610000s (0.091516 kb/s)
+			</code><br>
+			To verify the contents of the flash:<br>
+			<code>
+				> mdw 0x100000 32<br>
+				0x0100000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x0100020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+				> flash fillw 0x01000000 0xdeadbeef 16 <br>  
+				wrote 64 bytes to 0x01000000 in 0.010000s (6.250 kb/s)<br>
+				> mdw 0x1000000 32<br>
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef <br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+				>
+			</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA003"/>FLA003</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Flash erase</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	>  flash erase_address 0x100000 0x2000
+			</code>
+		</td>
+		<td>The commands should execute without error.<br>
+			<code>
+				erased address 0x0100000 length 8192 in 4.970000s
+			</code>
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			<code>
+				> mdw 0x100000 32<br>
+				0x0100000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+			> flash erase_address 0x1000000 0x10000<br>
+			erased address 0x01000000 (length 65536) in 0.840000s (76.190 kb/s)<br>
+			> mdw 0x1000000 32                     <br>
+			0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+			0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+			0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+			0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff <br>
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA004"/>FLA004</td>
+		<td>AT91FR40162</td>
+		<td>ZY1000</td>
+		<td>Loading to flash from GDB</td>
+		<td>Reset init is working, flash is probed, connectivity to GDB server is working</td>
+		<td>Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. <br>
+				<code>
+					(gdb) target remote ip:port<br>
+					(gdb) monitor reset halt<br>
+					(gdb) load<br>
+					Loading section .text, size 0x194 lma 0x100000<br>
+					Start address 0x100040, load size 404<br>
+					Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+					(gdb) monitor verify_image path_to_elf_file		
+				</code>
+		</td>
+		<td>The output should look like:<br>
+			<code>
+				verified 404 bytes in 5.060000s
+			</code><br>
+			The failure message is something like:<br>
+			<code>Verify operation failed address 0x00200000. Was 0x00 instead of 0x18</code>
+		</td>
+		<td>
+			<code>
+				(gdb) load<br>
+				Loading section .rom_vectors, size 0x40 lma 0x1000000<br>
+				Loading section .text, size 0x10638 lma 0x1000040<br>
+				Loading section .rodata, size 0x1a84 lma 0x1010678<br>
+				Loading section .data, size 0x428 lma 0x10120fc<br>
+				Start address 0x1000040, load size 75044<br>
+				Transfer rate: 34 KB/sec, 9380 bytes/write.<br>
+				(gdb) moni verify_image /tftp/10.0.0.190/redboot_rom.elf<br>
+				keep_alive() was not invoked in the 1000ms timelimit. GDB alive packet not sent! (1820). Workaround: increase "set remotetimeout" in GDB<br>
+				verified 75044 bytes in 1.960000s (37.390 kb/s)<br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>	
+</table>
+
+</body>
+</html>
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/LPC2148.html b/testing/results/v0.4.0-rc1/LPC2148.html
new file mode 100755
index 0000000..425b524
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/LPC2148.html
@@ -0,0 +1,933 @@
+<html>
+<head>
+<title>Test results for revision 1.62</title>
+</head>
+
+<body>
+
+<H1>LPC2148</H1>
+
+<H2>Connectivity</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="CON001"/>CON001</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Telnet connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On console, type<br><code>telnet ip port</code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="CON002"/>CON002</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>GDB server connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On GDB console, type<br><code>target remote ip:port</code></td>
+		<td><code>Remote debugging using 10.0.0.73:3333</code></td>
+		<td><code>
+			(gdb) tar remo 10.0.0.73:3333<br>
+			Remote debugging using 10.0.0.73:3333<br>
+			0x00000000 in ?? ()<br>
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Reset</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RES001"/>RES001</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				> mdw 0 32<br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				> reset halt<br>
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xa00000f3 pc: 0x7fffd2d6<br>
+				> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES002"/>RES002</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Reset init on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset init</code></td>
+		<td>Reset should return without error and the output should contain <br><code>executing reset script 'name_of_the_script'</code></td>
+		<td>
+			<code>
+				> reset init<br>
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xa00000f3 pc: 0x7fffd2da<br>
+				core state: ARM<br>
+				>
+			</code>
+		</td>
+		<td>PASS<br>
+		NOTE! Even if there is no message, the reset script is being executed (proved by side effects)</td>	
+	</tr>
+	<tr>
+		<td><a name="RES003"/>RES003</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Reset after a power cycle of the target</td>
+		<td>Reset the target then power cycle the target</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code> after the power was detected</td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				nsed nSRST asserted.<br>
+				nsed power dropout.<br>
+				nsed power restore.<br>
+				SRST took 186ms to deassert<br>
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xa00000f3 pc: 0x7fffd2d6<br>
+				core state: ARM<br>
+				> reset halt<br>
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xa00000f3 pc: 0x7fffd2d6<br>
+				>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES004"/>RES004</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target where reset halt is supported</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted<br>pc = 0</code></td>
+		<td>
+			<code>
+			> reset halt<br>
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0xa00000f3 pc: 0x7fffd2d6<br>
+			> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES005"/>RES005</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target using return clock</td>
+		<td>Erase all the content of the flash, set the configuration script to use RCLK</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+			> jtag_khz 0<br>
+			RCLK - adaptive<br>
+			> reset init<br>
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0xa00000f3 pc: 0x7fffd2d6<br>
+			core state: ARM<br>
+			> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>JTAG Speed</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>ZY1000</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="SPD001"/>SPD001</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>16MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 16000<br>
+				jtag_speed 4 => JTAG clk=16.000000<br>
+				16000 kHz<br>
+				> reset halt<br>    
+				JTAG scan chain interrogation failed: all zeroes<br>
+				Check JTAG interface, timings, target power, etc.<br>
+				error: -100<br>
+				Command handler execution failed<br>
+				in procedure 'reset' called at file "command.c", line 638<br>
+				called at file "/home/laurentiu/workspace/zy1000/build/../openocd/src/helper/command.c", line 352<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				ThumbEE -- incomplete support<br>
+				target state: halted<br>
+				target halted in ThumbEE state due to debug-request, current mode: System<br>
+				cpsr: 0x1fffffff pc: 0xfffffffa<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				target state: halted<br>
+				target halted in Thumb state due to debug-request, current mode: System<br>
+				cpsr: 0xc00003ff pc: 0xfffffff0<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				ThumbEE -- incomplete support<br>
+				target state: halted<br>
+				target halted in ThumbEE state due to debug-request, current mode: System<br>
+				cpsr: 0xffffffff pc: 0xfffffffa<br>
+				>
+			</code>
+		</td>
+		<td><font color=red><b>FAIL</b></font></td>	
+	</tr>
+	<tr>
+		<td><a name="SPD002"/>SPD002</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>8MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 8000<br> 
+				jtag_speed 8 => JTAG clk=8.000000<br>
+				8000 kHz<br>
+				> reset halt<br>   
+				JTAG scan chain interrogation failed: all zeroes<br>
+				Check JTAG interface, timings, target power, etc.<br>
+				error: -100<br>
+				Command handler execution failed<br>
+				in procedure 'reset' called at file "command.c", line 638<br>
+				called at file "/home/laurentiu/workspace/zy1000/build/../openocd/src/helper/command.c", line 352<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				invalid mode value encountered 0<br>
+				cpsr contains invalid mode value - communication failure<br>
+				>
+			</code>
+		</td>
+		<td><font color=red><b>FAIL</b></font></td>	
+	</tr>
+	<tr>
+		<td><a name="SPD003"/>SPD003</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>4MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 4000<br>
+				jtag_speed 16 => JTAG clk=4.000000<br>
+				4000 kHz<br>
+				> reset halt<br>   
+				JTAG tap: lpc2148.cpu tap/device found: 0xc79f0f87 (mfg: 0x7c3, part: 0x79f0, ver: 0xc)<br>
+				JTAG tap: lpc2148.cpu       UNEXPECTED: 0xc79f0f87 (mfg: 0x7c3, part: 0x79f0, ver: 0xc)<br>
+				JTAG tap: lpc2148.cpu  expected 1 of 1: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+				Unexpected idcode after end of chain: 64 0x0000007f<br>
+				Unexpected idcode after end of chain: 160 0x0000007f<br>
+				Unexpected idcode after end of chain: 192 0x0000007f<br>
+				Unexpected idcode after end of chain: 320 0x0000007f<br>
+				Unexpected idcode after end of chain: 352 0x0000007f<br>
+				Unexpected idcode after end of chain: 384 0x0000007f<br>
+				Unexpected idcode after end of chain: 480 0x0000007f<br>
+				Unexpected idcode after end of chain: 512 0x0000007f<br>
+				Unexpected idcode after end of chain: 544 0x0000007f<br>
+				double-check your JTAG setup (interface, speed, missing TAPs, ...)<br>
+				error: -100<br>
+				Command handler execution failed<br>
+				in procedure 'reset' called at file "command.c", line 638<br>
+				called at file "/home/laurentiu/workspace/zy1000/build/../openocd/src/helper/command.c", line 352<br>
+				> 
+			</code>
+		</td>
+		<td><font color=red><b>FAIL</b></font></td>	
+	</tr>
+	<tr>
+		<td><a name="SPD004"/>SPD004</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>2MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 2000<br>
+				jtag_speed 32 => JTAG clk=2.000000<br>
+				2000 kHz<br>
+				> reset halt<br>
+				JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+				cpsr: 0xa00000f3 pc: 0x7fffd2da<br>
+				> mdw 0 32<br>
+				0x00000000: e59f4034 e3a05002 e5845000 e3a05003 e5845004 e59f201c e3a03000 e1020093<br> 
+				0x00000020: e2822028 e1021093 e3c03007 e5023028 e51ff004 7fffd1c4 e002c014 e01fc000<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD005"/>SPD005</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>RCLK on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 0<br>
+				RCLK - adaptive<br>
+				> mdw 0 32<br>
+				0x00000000: e59f4034 e3a05002 e5845000 e3a05003 e5845004 e59f201c e3a03000 e1020093<br> 
+				0x00000020: e2822028 e1021093 e3c03007 e5023028 e51ff004 7fffd1c4 e002c014 e01fc000<br> 
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Debugging</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="DBG001"/>DBG001</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Load is working</td>
+		<td>Reset init is working, RAM is accesible, GDB server is started</td>
+		<td>On the console of the OS: <br>
+			<code>arm-elf-gdb test_ram.elf</code><br>
+			<code>(gdb) target remote ip:port</code><br>
+			<code>(gdb) load</load>
+		</td>
+		<td>Load should return without error, typical output looks like:<br>
+			<code>
+				Loading section .text, size 0x14c lma 0x0<br>
+				Start address 0x40, load size 332<br>
+				Transfer rate: 180 bytes/sec, 332 bytes/write.<br>
+			</code>
+		</td>
+		<td><code>
+			(gdb) load<br>
+			Loading section .text, size 0x16c lma 0x40000000<br>
+			Start address 0x40000040, load size 364<br>
+			Transfer rate: 32 KB/sec, 364 bytes/write.<br>
+			(gdb) 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	
+	<tr>
+		<td><a name="DBG002"/>DBG002</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Software breakpoint</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001</td>
+		<td>In the GDB console:<br>
+			<code>
+				(gdb) monitor gdb_breakpoint_override soft<br>
+				software breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0xec: file src/main.c, line 71.<br>
+				(gdb) continue<br>
+				Continuing.
+			</code>
+		</td>
+		<td>The software breakpoint should be reached, a typical output looks like:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+				cpsr: 0x000000d3 pc: 0x000000ec<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71        DWORD a = 1;
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) monitor gdb_breakpoint_override soft<br>
+				force soft breakpoints<br>
+				Current language:  auto<br>
+				The current source language is "auto; currently asm".<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x4000010c: file src/main.c, line 71.<br>
+				(gdb) c<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71	  DWORD a = 1;<br>
+				Current language:  auto<br>
+				The current source language is "auto; currently c".<br>
+				(gdb) 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="DBG003"/>DBG003</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Single step in a RAM application</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>(gdb) step</code></td>
+		<td>The next instruction should be reached, typical output:<br>
+			<code>
+				(gdb) step<br>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Abort<br>
+				cpsr: 0x20000097 pc: 0x000000f0<br>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Abort<br>
+				cpsr: 0x20000097 pc: 0x000000f4<br>
+				72        DWORD b = 2;
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) step<br>
+				72	  DWORD b = 2;<br>
+				(gdb) 
+			</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG004"/>DBG004</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Software break points are working after a reset</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>
+			(gdb) monitor reset init<br>
+			(gdb) load<br>
+			(gdb) continue<br>
+			</code></td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+				cpsr: 0x000000d3 pc: 0x000000ec<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71        DWORD a = 1;
+			</code>
+		</td>
+		<td><code>
+			(gdb) moni reset init<br>
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in Thumb state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0xa00000f3 pc: 0x7fffd2d6<br>
+			core state: ARM<br>
+			(gdb) load<br>
+			Loading section .text, size 0x16c lma 0x40000000<br>
+			Start address 0x40000040, load size 364<br>
+			Transfer rate: 27 KB/sec, 364 bytes/write.<br>
+			(gdb) c<br>
+			Continuing.<br>
+			<br>
+			Breakpoint 1, main () at src/main.c:71<br>
+			71	  DWORD a = 1;<br>
+			(gdb) 
+		</code></td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG005"/>DBG005</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint</td>
+		<td>Flash the test_rom.elf application. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset init<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor gdb_breakpoint_override hard<br>
+				force hard breakpoints<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+			(gdb) monitor gdb_breakpoint_override hard<br>
+			force hard breakpoints<br>
+			(gdb) break main<br>
+			Breakpoint 1 at 0x10c: file src/main.c, line 71.<br>
+			(gdb) continue<br>
+			Continuing.<br>
+			Note: automatically using hardware breakpoints for read-only addresses.<br>
+			<br>
+			Breakpoint 1, main () at src/main.c:71<br>
+			71	  DWORD a = 1;<br>
+			Current language:  auto<br>
+			The current source language is "auto; currently c".<br>
+			(gdb) 
+		</code>
+		</td>
+		<td>PASS <font color=red>NOTE: This test is failing from time to time, not able to describe a cause</font></td>
+	</tr>
+	<tr>
+		<td><a name="DBG006"/>DBG006</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint is set after a reset</td>
+		<td>Follow the instructions to flash and insert a hardware breakpoint from DBG005</td>
+		<td>In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) monitor reg pc 0x100000<br>
+				pc (/32): 0x00100000<br>
+				(gdb) continue
+			</code><br>
+			where the value inserted in PC is the start address of the application
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+			(gdb) monitor reset init<br>
+			JTAG tap: lpc2148.cpu tap/device found: 0x4f1f0f0f (mfg: 0x787, part: 0xf1f0, ver: 0x4)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in ARM state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0x60000013 pc: 0x00000160<br>
+			core state: ARM<br>
+			(gdb) monitor reg pc 0x40<br>
+			pc (/32): 0x00000040<br>
+			(gdb) continue<br>
+			Continuing.<br>
+			<br>
+			Breakpoint 1, main () at src/main.c:71<br>
+			71	  DWORD a = 1;<br>
+			(gdb) 
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG007"/>DBG007</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Single step in ROM</td>
+		<td>Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor gdb_breakpoint_override hard<br>
+				force hard breakpoints<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+				(gdb) step
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Supervisor<br>
+				cpsr: 0x60000013 pc: 0x0010013c<br>
+				70        DWORD b = 2;<br>
+			</code>
+		</td>
+		<td><code>
+				(gdb) load<br>
+				Loading section .text, size 0x16c lma 0x0<br>
+				Start address 0x40, load size 364<br>
+				Transfer rate: 637 bytes/sec, 364 bytes/write.<br>
+				(gdb)  monitor gdb_breakpoint_override hard<br>
+				force hard breakpoints<br>
+				Current language:  auto<br>
+				The current source language is "auto; currently asm".<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x10c: file src/main.c, line 71.<br>
+				(gdb) continue<br>
+				Continuing.<br>
+				Note: automatically using hardware breakpoints for read-only addresses.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71	  DWORD a = 1;<br>
+				Current language:  auto<br>
+				The current source language is "auto; currently c".<br>
+				(gdb) step<br>
+				72	  DWORD b = 2;<br>
+				(gdb)
+			
+		</code></td>
+		<td>PASS</td>
+	</tr>
+</table>
+
+<H2>RAM access</H2>
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RAM001"/>RAM001</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>32 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mww ram_address 0xdeadbeef 16<br>
+					> mdw ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.<br>
+			<code>
+				> mww 0x0 0xdeadbeef 16<br>
+				> mdw 0x0 32<br>
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388<br>
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388<br>
+			</code>
+		</td>
+		<td><code>
+			> mww 0x40000000 0xdeadbeef 16<br>
+			> mdw 0x40000000 32<br>
+			0x40000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+			0x40000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+			0x40000040: e1a00000 e1a00000 e1a00000 e1a00000 e1a00000 e1a00000 e1a00000 e1a00000<br> 
+			0x40000060: e321f0db e59fd07c e321f0d7 e59fd078 e321f0d1 e59fd074 e321f0d2 e59fd070<br> 
+			> 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM002"/>RAM002</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>16 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwh ram_address 0xbeef 16<br>
+					> mdh ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.<br>
+			<code>
+				> mwh 0x0 0xbeef 16<br>
+				> mdh 0x0 32<br>
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br>
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000<br>
+				>
+			</code>
+		</td>
+		<td><code>
+			> mwh 0x40000000 0xbeef 16<br>
+			> mdh 0x40000000 32<br>       
+			0x40000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br> 
+			0x40000020: beef dead beef dead beef dead beef dead beef dead beef dead beef dead beef dead<br> 
+			> 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM003"/>RAM003</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>8 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwb ram_address 0xab 16<br>
+					> mdb ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.<br>
+			<code>
+				> mwb ram_address 0xab 16<br>
+				> mdb ram_address 32<br>
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>
+				>
+			</code>
+		</td>
+		<td><code>
+			> mwb 0x40000000 0xab 16
+			> mdb 0x40000000 32     
+			0x40000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ef be ef be ef be ef be ef be ef be ef be ef be 
+			>
+
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+
+
+<H2>Flash access</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="FLA001"/>FLA001</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Flash probe</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface:<br>
+			<code>	> flash probe 0</code>
+		</td>
+		<td>The command should execute without error. The output should state the name of the flash and the starting address. An example of output:<br>
+			<code>flash 'ecosflash' found at 0x01000000</code>
+		</td>
+		<td>
+		<code>
+			> flash probe 0<br>
+			flash 'lpc2000' found at 0x00000000
+		</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA002"/>FLA002</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>flash fillw</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	> flash fillw 0x1000000 0xdeadbeef 16
+			</code>
+		</td>
+		<td>The commands should execute without error. The output looks like:<br>
+			<code>
+				wrote 64 bytes to 0x01000000 in 11.610000s (0.091516 kb/s)
+			</code><br>
+			To verify the contents of the flash:<br>
+			<code>
+				> mdw 0x1000000 32<br>
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+				> flash fillw 0x0 0xdeadbeef 16<br>
+				Verification will fail since checksum in image (0xdeadbeef) to be written to flash is different from calculated vector checksum (0xe93fc777).<br>
+				To remove this warning modify build tools on developer PC to inject correct LPC vector checksum.<br>
+				wrote 64 bytes to 0x00000000 in 0.040000s (1.563 kb/s)<br>
+				> mdw 0 32<br>
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef e93fc777 deadbeef deadbeef<br> 
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				> 
+			</code></td>
+		<td><font color=red>FAIL</font></td>	
+	</tr>
+	<tr>
+		<td><a name="FLA003"/>FLA003</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Flash erase</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	>  flash erase_address 0x1000000 0x2000
+			</code>
+		</td>
+		<td>The commands should execute without error.<br>
+			<code>
+				erased address 0x01000000 length 8192 in 4.970000s
+			</code>
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			<code>
+				> mdw 0x1000000 32<br>
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+			> flash erase_address 0 0x2000<br>
+			erased address 0x00000000 (length 8192) in 0.510000s (15.686 kb/s)<br>
+			> mdw 0 32<br>
+			0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+			0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+			0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+			0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+			> 
+		</code></td>				
+		<td>PASS</td>
+
+	</tr>
+	<tr>
+		<td><a name="FLA004"/>FLA004</td>
+		<td>LPC2148</td>
+		<td>ZY1000</td>
+		<td>Loading to flash from GDB</td>
+		<td>Reset init is working, flash is probed, connectivity to GDB server is working</td>
+		<td>Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. <br>
+				<code>
+					(gdb) target remote ip:port<br>
+					(gdb) monitor reset<br>
+					(gdb) load<br>
+					Loading section .text, size 0x194 lma 0x100000<br>
+					Start address 0x100040, load size 404<br>
+					Transfer rate: 179 bytes/sec, 404 bytes/write.
+					(gdb) monitor verify_image path_to_elf_file		
+				</code>
+		</td>
+		<td>The output should look like:<br>
+			<code>
+				verified 404 bytes in 5.060000s
+			</code><br>
+			The failure message is something like:<br>
+			<code>Verify operation failed address 0x00200000. Was 0x00 instead of 0x18</code>
+		</td>
+		<td>
+			<code>
+				(gdb) moni verify_image /tftp/10.0.0.194/test_rom.elf<br>
+				checksum mismatch - attempting binary compare<br>
+				Verify operation failed address 0x00000014. Was 0x58 instead of 0x60<br>
+				<br>
+				Command handler execution failed<br>
+				in procedure 'verify_image' called at file "command.c", line 647<br>
+				called at file "command.c", line 361<br>
+				(gdb) 
+			</code>
+		</td>
+		<td><font color=red>FAIL</font></td>
+	</tr>	
+</table>
+
+</body>
+</html>
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/SAM7.html b/testing/results/v0.4.0-rc1/SAM7.html
new file mode 100755
index 0000000..a400a47
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/SAM7.html
@@ -0,0 +1,853 @@
+<html>
+<head>
+<title>Test results for revision 1.62</title>
+</head>
+
+<body>
+
+<H1>SAM7</H1>
+
+<H2>Connectivity</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="CON001"/>CON001</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Telnet connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On console, type<br><code>telnet ip port</code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="CON002"/>CON002</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>GDB server connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On GDB console, type<br><code>target remote ip:port</code></td>
+		<td><code>Remote debugging using 10.0.0.73:3333</code></td>
+		<td><code>
+			(gdb) tar remo 10.0.0.73:3333<br>
+			Remote debugging using 10.0.0.73:3333<br>
+			0x00100174 in ?? ()<br>
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Reset</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RES001"/>RES001</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				> mdw 0 32<br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				> reset halt<br>
+				SRST took 2ms to deassert<br>
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0x600000d3 pc: 0x000003c4<br>
+				>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES002"/>RES002</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Reset init on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset init</code></td>
+		<td>Reset should return without error and the output should contain <br><code>executing reset script 'name_of_the_script'</code></td>
+		<td>
+			<code>
+				> reset init<br>
+				SRST took 2ms to deassert<br>
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0x600000d3 pc: 0x000003c0<br>
+				>
+			</code>
+		</td>
+		<td>PASS<br>
+		NOTE! Even if there is no message, the reset script is being executed (proved by side effects)</td>	
+	</tr>
+	<tr>
+		<td><a name="RES003"/>RES003</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Reset after a power cycle of the target</td>
+		<td>Reset the target then power cycle the target</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code> after the power was detected</td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				Sensed nSRST asserted<br>
+				Sensed power dropout.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0xd5dff7e6<br>
+				Sensed power restore.<br>
+				Sensed nSRST deasserted<br>
+				> reset halt<br>
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0xf00000d3 pc: 0x0000072c<br>
+				>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES004"/>RES004</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target where reset halt is supported</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted<br>pc = 0</code></td>
+		<td>
+			<code>
+				> reset halt<br>
+				SRST took 2ms to deassert<br>
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0x300000d3 pc: 0x000003c0
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES005"/>RES005</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target using return clock</td>
+		<td>Erase all the content of the flash, set the configuration script to use RCLK</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+				> jtag_khz 0<br>
+				jtag_khz: 0<br>
+				> reset init<br>
+				SRST took 2ms to deassert<br>
+				JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)<br>
+				srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+				target state: halted<br>
+				target halted in ARM state due to debug request, current mode: Supervisor<br>
+				cpsr: 0x300000d3 pc: 0x000003c0<br>
+				executing event/sam7s256_reset.script<br>
+				>
+			</code>	
+		</td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>JTAG Speed</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>ZY1000</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="SPD001"/>SPD001</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>16MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 16000<br>
+				jtag_speed 4 => JTAG clk=16.000000<br>
+				jtag_khz: 16000<br>
+				> mdw 0 32<br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD002"/>SPD002</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>8MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 8000<br>
+				jtag_speed 8 => JTAG clk=8.000000<br>
+				jtag_khz: 8000<br>
+				> mdw 0 32<br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD003"/>SPD003</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>4MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 4000<br>
+				jtag_speed 16 => JTAG clk=4.000000<br>
+				jtag_khz: 4000<br>
+				> mdw 0 32<br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD004"/>SPD004</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>2MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 2000<br>
+				jtag_speed 32 => JTAG clk=2.000000<br>
+				jtag_khz: 2000<br>
+				> mdw 0 32<br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD005"/>SPD005</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>RCLK on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+				> jtag_khz 0<br>
+				jtag_khz: 0<br>
+				> mdw 0 32<br>
+				0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Debugging</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="DBG001"/>DBG001</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Load is working</td>
+		<td>Reset init is working, RAM is accesible, GDB server is started</td>
+		<td>On the console of the OS: <br>
+			<code>arm-elf-gdb test_ram.elf</code><br>
+			<code>(gdb) target remote ip:port</code><br>
+			<code>(gdb) load</load>
+		</td>
+		<td>Load should return without error, typical output looks like:<br>
+			<code>
+				Loading section .text, size 0x14c lma 0x0<br>
+				Start address 0x40, load size 332<br>
+				Transfer rate: 180 bytes/sec, 332 bytes/write.<br>
+			</code>
+		</td>
+		<td><code>
+			(gdb) load<br>
+			Loading section .text, size 0x194 lma 0x200000<br>
+			Start address 0x200040, load size 404<br>
+			Transfer rate: 443 bytes/sec, 404 bytes/write.<br>
+			(gdb)
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	
+	<tr>
+		<td><a name="DBG002"/>DBG002</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Software breakpoint</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001</td>
+		<td>In the GDB console:<br>
+			<code>
+				(gdb) monitor arm7_9 dbgrq enable<br>
+				software breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0xec: file src/main.c, line 71.<br>
+				(gdb) continue<br>
+				Continuing.
+			</code>
+		</td>
+		<td>The software breakpoint should be reached, a typical output looks like:<br>
+			<code>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69	  DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) monitor arm7_9 dbgrq enable<br>
+				use of EmbeddedICE dbgrq instead of breakpoint for target halt enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x200134: file src/main.c, line 69.<br>
+				(gdb) c<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69	  DWORD a = 1;<br>
+				Current language:  auto<br>
+				The current source language is "auto; currently c".<br>				
+				(gdb)
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="DBG003"/>DBG003</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Single step in a RAM application</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>(gdb) step</code></td>
+		<td>The next instruction should be reached, typical output:<br>
+			<code>
+				(gdb) step<br>
+				70	  DWORD b = 2;
+
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) step<br>
+				70	  DWORD b = 2;
+				(gdb)
+			</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG004"/>DBG004</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Software break points are working after a reset</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>
+			(gdb) monitor reset init<br>
+			(gdb) load<br>
+			(gdb) continue<br>
+			</code></td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69	  DWORD a = 1;
+			</code>
+		</td>
+		<td><code>
+			(gdb) monitor reset init<br>
+			JTAG tap: sam7x256.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in ARM state due to debug-request, current mode: Supervisor<br>
+			cpsr: 0x600000d3 pc: 0x0000031c<br>
+			(gdb) load<br>
+			Loading section .text, size 0x194 lma 0x200000<br>
+			Start address 0x200040, load size 404<br>
+			Transfer rate: 26 KB/sec, 404 bytes/write.<br>
+			(gdb) continue<br>
+			Continuing.<br>
+			<br>
+			Breakpoint 1, main () at src/main.c:69<br>
+			69	  DWORD a = 1;<br>
+			(gdb)
+		</code></td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG005"/>DBG005</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint</td>
+		<td>Flash the test_rom.elf application. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset init<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor arm7_9  force_hw_bkpts enable<br>
+				force hardware breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+			(gdb) monitor arm7_9  force_hw_bkpts enable<br>
+			force hardware breakpoints enabled<br>
+			(gdb) break main<br>
+			Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+			(gdb) continue<br>
+			Continuing.<br>
+			Note: automatically using hardware breakpoints for read-only addresses.<br>
+			target state: halted<br>
+			target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+			cpsr: 0x60000013 pc: 0x00100134<br>
+<br>
+			Breakpoint 1, main () at src/main.c:69<br>
+			69        DWORD a = 1;<br>
+			(gdb)
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG006"/>DBG006</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint is set after a reset</td>
+		<td>Follow the instructions to flash and insert a hardware breakpoint from DBG005</td>
+		<td>In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) monitor reg pc 0x100000<br>
+				pc (/32): 0x00100000<br>
+				(gdb) continue
+			</code><br>
+			where the value inserted in PC is the start address of the application
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+			(gdb) monitor reset init<br>
+			SRST took 3ms to deassert<br>
+			JTAG device found: 0x3f0f0f0f (Manufacturer: 0x787, Part: 0xf0f0, Version: 0x3)<br>
+			srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+			target state: halted<br>
+			target halted in ARM state due to debug request, current mode: Supervisor<br>
+			cpsr: 0x60000013 pc: 0x00100168<br>
+			executing event/sam7s256_reset.script<br>
+			(gdb) monitor reg pc 0x100000<br>
+			pc (/32): 0x00100000<br>
+			(gdb) continue<br>
+			Continuing.<br>
+			target state: halted<br>
+			target halted in ARM state due to single step, current mode: Supervisor<br>
+			cpsr: 0x60000013 pc: 0x00100040<br>
+			target state: halted<br>
+			target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+			cpsr: 0x60000013 pc: 0x00100134<br>
+<br>
+			Breakpoint 1, main () at src/main.c:69<br>
+			69        DWORD a = 1;<br>
+			(gdb)
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG007"/>DBG007</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Single step in ROM</td>
+		<td>Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor arm7_9  force_hw_bkpts enable<br>
+				force hardware breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+				(gdb) step
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Supervisor<br>
+				cpsr: 0x60000013 pc: 0x0010013c<br>
+				70        DWORD b = 2;<br>
+			</code>
+		</td>
+		<td><code>
+			Breakpoint 1, main () at src/main.c:69<br>
+			69        DWORD a = 1;<br>
+			(gdb) step<br>
+			target state: halted<br>
+			target halted in ARM state due to single step, current mode: Supervisor<br>
+			cpsr: 0x60000013 pc: 0x00100138<br>
+			target state: halted<br>
+			target halted in ARM state due to single step, current mode: Supervisor<br>
+			cpsr: 0x60000013 pc: 0x0010013c<br>
+			70        DWORD b = 2;<br>
+			(gdb)
+		</code></td>
+		<td>PASS</td>
+	</tr>
+</table>
+
+<H2>RAM access</H2>
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RAM001"/>RAM001</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>32 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mww ram_address 0xdeadbeef 16<br>
+					> mdw ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.<br>
+			<code>
+				> mww 0x0 0xdeadbeef 16<br>
+				> mdw 0x0 32<br>
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388<br>
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388<br>
+			</code>
+		</td>
+		<td><code>
+			> mww 0x00200000 0xdeadbeef 16<br>
+			> mdw 0x00200000 32<br>
+			0x00200000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+			0x00200020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+			0x00200040: e59f10b4 e3a00902 e5810004 e59f00ac e59f10ac e5810000 e3e010ff e59f00a4<br>
+			0x00200060: e5810060 e59f10a0 e3e00000 e5810130 e5810124 e321f0db e59fd090 e321f0d7
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM002"/>RAM002</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>16 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwh ram_address 0xbeef 16<br>
+					> mdh ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.<br>
+			<code>
+				> mwh 0x0 0xbeef 16<br>
+				> mdh 0x0 32<br>
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br>
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000<br>
+				>
+			</code>
+		</td>
+		<td><code>
+			> mwh 0x00200000 0xbeef 16<br>
+			> mdh 0x00200000 32<br>
+			0x00200000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br>
+			0x00200020: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM003"/>RAM003</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>8 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwb ram_address 0xab 16<br>
+					> mdb ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.<br>
+			<code>
+				> mwb ram_address 0xab 16<br>
+				> mdb ram_address 32<br>
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>
+				>
+			</code>
+		</td>
+		<td><code>
+			>  mwb 0x00200000 0xab 16<br>
+			> mdb 0x00200000 32<br>
+			0x00200000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+
+
+<H2>Flash access</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="FLA001"/>FLA001</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Flash probe</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface:<br>
+			<code>	> flash probe 0</code>
+		</td>
+		<td>The command should execute without error. The output should state the name of the flash and the starting address. An example of output:<br>
+			<code>flash 'ecosflash' found at 0x01000000</code>
+		</td>
+		<td>
+		<code>
+			> flash probe 0<br>
+			flash 'at91sam7' found at 0x00100000
+		</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA002"/>FLA002</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>flash fillw</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	> flash fillw 0x100000 0xdeadbeef 16
+			</code>
+		</td>
+		<td>The commands should execute without error. The output looks like:<br>
+			<code>
+				wrote 64 bytes to 0x0100000 in 11.610000s (0.091516 kb/s)
+			</code><br>
+			To verify the contents of the flash:<br>
+			<code>
+				> mdw 0x100000 32<br>
+				0x0100000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x0100020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+				> flash fillw 0x100000 0xdeadbeef 16<br>
+				wrote 64 bytes to 0x00100000 in 0.040000s (26.562500 kb/s)<br>
+				> mdw 0x100000 32<br>
+				0x00100000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00100020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x00100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				>
+			</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA003"/>FLA003</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Flash erase</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	>  flash erase_address 0x100000 0x2000
+			</code>
+		</td>
+		<td>The commands should execute without error.<br>
+			<code>
+				erased address 0x0100000 length 8192 in 4.970000s
+			</code>
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			<code>
+				> mdw 0x100000 32<br>
+				0x0100000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x0100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+			> flash erase_address 0x100000 0x2000<br>
+			erased address 0x00100000 length 8192 in 0.020000s<br>
+			> mdw 0x100000 32<br>
+			0x00100000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+			0x00100020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+			0x00100040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+			0x00100060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+			>
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA004"/>FLA004</td>
+		<td>SAM7S64</td>
+		<td>ZY1000</td>
+		<td>Loading to flash from GDB</td>
+		<td>Reset init is working, flash is probed, connectivity to GDB server is working</td>
+		<td>Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. <br>
+				<code>
+					(gdb) target remote ip:port<br>
+					(gdb) monitor reset halt<br>
+					(gdb) load<br>
+					Loading section .text, size 0x194 lma 0x100000<br>
+					Start address 0x100040, load size 404<br>
+					Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+					(gdb) monitor verify_image path_to_elf_file		
+				</code>
+		</td>
+		<td>The output should look like:<br>
+			<code>
+				verified 404 bytes in 5.060000s
+			</code><br>
+			The failure message is something like:<br>
+			<code>Verify operation failed address 0x00200000. Was 0x00 instead of 0x18</code>
+		</td>
+		<td>
+			<code>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 4 KB/sec, 404 bytes/write.<br>
+				(gdb) moni verify_image /tftp/10.0.0.9/c:/temp/testing/examples/SAM7S256Test/test_rom.elf<br>
+				verified 404 bytes in 0.570000s
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>	
+</table>
+
+</body>
+</html>
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/STR710.html b/testing/results/v0.4.0-rc1/STR710.html
new file mode 100755
index 0000000..1a18ad0
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/STR710.html
@@ -0,0 +1,907 @@
+<html>
+<head>
+<title>Test results for version 1.62</title>
+</head>
+
+<body>
+
+<H1>STR710</H1>
+
+<H2>Connectivity</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="CON001"/>CON001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Telnet connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On console, type<br><code>telnet ip port</code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td><code>> telnet 10.0.0.142<br>
+					Trying 10.0.0.142...<br>
+					Connected to 10.0.0.142.<br>
+					Escape character is '^]'.<br>
+					Open On-Chip Debugger<br>
+					>
+</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="CON002"/>CON002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>GDB server connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On GDB console, type<br><code>target remote ip:port</code></td>
+		<td><code>Remote debugging using 10.0.0.73:3333</code></td>
+		<td><code>
+			(gdb) tar remo 10.0.0.142:3333<br>
+			Remote debugging using 10.0.0.142:3333<br>
+			0x00016434 in ?? ()<br>
+			(gdb)
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Reset</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RES001"/>RES001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+> mdw 0 32<br>
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e<br> 
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292<br> 
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18<br>
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8<br>
+> reset<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+><br>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES002"/>RES002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset init on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset init</code></td>
+		<td>Reset should return without error and the output should contain <br><code>executing reset script 'name_of_the_script'</code></td>
+		<td>
+			<code>
+> reset init<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Undefined instruction<br>
+cpsr: 0xf00000db pc: 0x00000004<br>
+jtag_speed 10 => JTAG clk=6.400000<br>
+6400 kHz
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES003"/>RES003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset after a power cycle of the target</td>
+		<td>Reset the target then power cycle the target</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code> after the power was detected</td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+  nsed power dropout.<br>
+  nsed power dropout.<br>
+  nsed nSRST deasserted.<br>
+  invalid mode value encountered 0<br>
+cpsr contains invalid mode value - communication failure<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x100000d3 pc: 0x0000001c<br>
+jtag_speed 10 => JTAG clk=6.400000<br>
+6400 kHz<br>
+  nsed power restore.<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x500000d3 pc: 0x00000000<br>
+jtag_speed 10 => JTAG clk=6.400000<br>
+6400 kHz<br>
+> reset init<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x500000d3 pc: 0x00000000<br>
+jtag_speed 10 => JTAG clk=6.400000<br>
+6400 kHz<br>
+>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES004"/>RES004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target where reset halt is supported</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+> reset halt<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x200000d3 pc: 0xfe50cba4<br>
+>
+</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES005"/>RES005</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target using return clock</td>
+		<td>Erase all the content of the flash, set the configuration script to use RCLK</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+			> jtag_khz 0<br>
+RCLK - adaptive<br>
+RCLK timeout<br>
+RCLK timeout<br>
+RCLK timeout<br>
+			> reset halt<br>
+ RCLK timeout<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x200000d3 pc: 0xfe50cb50<br>
+			</code>
+		</td>
+		<td><font color=red><b>FAIL</b></font></td>	
+	</tr>
+</table>
+
+<H2>JTAG Speed</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>ZY1000</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="SPD001"/>SPD001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>16MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 16000<br>
+jtag_speed 4 => JTAG clk=16.000000<br>
+16000 kHz<br>
+> mdw 0 32<br>
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e<br> 
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292<br> 
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18<br> 
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8<br> 
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD002"/>SPD002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>8MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 8000<br>  
+jtag_speed 8 => JTAG clk=8.000000<br> 
+8000 kHz<br> 
+> mdw 0 32<br>      
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e<br>  
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292<br>  
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18<br>  
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8<br>  
+>
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD003"/>SPD003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>4MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 4000<br> 
+jtag_speed 16 => JTAG clk=4.000000<br> 
+4000 kHz<br> 
+> mdw 0 32<br>      
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e<br>  
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292<br>  
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18<br>  
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8<br>  
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD004"/>SPD004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>2MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> > jtag_khz 2000<br> 
+jtag_speed 32 => JTAG clk=2.000000<br>
+2000 kHz<br>
+> mdw 0 32<br>     
+0x00000000: 75755000 8a930104 65696f65 939a3e98 214751f1 fa0edb9b 6664686d 931a989e<br> 
+0x00000020: 676c65e4 9a0a0982 25653445 da02ba90 c4ed3165 9b9a8a9a 65676365 01981292<br> 
+0x00000040: 212e0982 82ba3f8b 34674765 96ba1a9a 6175e7e5 9b9ab91a 0789644d 120a9a18<br> 
+0x00000060: 65446167 80d20982 6d6d6565 187090ca 65277d65 9a9a0b81 6960416c 9ffe88b8<br> 
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD005"/>SPD005</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>RCLK on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 0<br>   
+RCLK - adaptive<br>
+RCLK timeout<br>
+RCLK timeout<br>
+RCLK timeout
+			</code>
+		</td>
+		<td><font color=red><b>FAIL</b></font></td>	
+	</tr>
+</table>
+
+<H2>Debugging</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="DBG001"/>DBG001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Load is working</td>
+		<td>Reset init is working, RAM is accesible, GDB server is started</td>
+		<td>On the console of the OS: <br>
+			<code>arm-elf-gdb test_ram.elf</code><br>
+			<code>(gdb) target remote ip:port</code><br>
+			<code>(gdb) load</load>
+		</td>
+		<td>Load should return without error, typical output looks like:<br>
+			<code>
+				Loading section .text, size 0x14c lma 0x0<br>
+				Start address 0x40, load size 332<br>
+				Transfer rate: 180 bytes/sec, 332 bytes/write.<br>
+			</code>
+		</td>
+		<td><code>
+(gdb) load<br>
+Loading section .text, size 0x1cc lma 0x20000000<br>
+Loading section .vectors, size 0x40 lma 0x200001cc<br>
+Loading section .rodata, size 0x4 lma 0x2000020c<br>
+Start address 0x20000000, load size 528<br>
+Transfer rate: 64 KB/sec, 176 bytes/write.<br>
+(gdb) 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	
+	<tr>
+		<td><a name="DBG002"/>DBG002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Software breakpoint</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001</td>
+		<td>In the GDB console:<br>
+			<code>
+				(gdb) monitor gdb_breakpoint_override soft<br>
+				force soft breakpoints<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0xec: file src/main.c, line 71.<br>
+				(gdb) continue<br>
+				Continuing.
+			</code>
+		</td>
+		<td>The software breakpoint should be reached, a typical output looks like:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+				cpsr: 0x000000d3 pc: 0x000000ec<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71        DWORD a = 1;
+			</code>
+		</td>
+		<td>
+			<code>
+(gdb) monitor gdb_breakpoint_override soft<br>
+force soft breakpoints<br>
+Current language:  auto<br>
+The current source language is "auto; currently asm".<br>
+(gdb) break main<br>
+Breakpoint 1 at 0x20000170: file src/main.c, line 69.<br>
+(gdb) c<br>
+Continuing.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+Current language:  auto<br>
+The current source language is "auto; currently c".<br>
+(gdb) 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="DBG003"/>DBG003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Single step in a RAM application</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>(gdb) step</code></td>
+		<td>The next instruction should be reached, typical output:<br>
+			<code>
+				(gdb) step<br>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Abort<br>
+				cpsr: 0x20000097 pc: 0x000000f0<br>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Abort<br>
+				cpsr: 0x20000097 pc: 0x000000f4<br>
+				72        DWORD b = 2;
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) step<br>
+				70        DWORD b = 2;<br>
+				(gdb)
+			</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG004"/>DBG004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Software break points are working after a reset</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>
+			(gdb) monitor reset init<br>
+			(gdb) load<br>
+			(gdb) continue<br>
+			</code></td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+				cpsr: 0x000000d3 pc: 0x000000ec<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71        DWORD a = 1;
+			</code>
+		</td>
+		<td><code>
+((gdb) monitor reset init<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x60000013 pc: 0x200001bc<br>
+jtag_speed 10 => JTAG clk=6.400000<br>
+6400 kHz<br>
+(gdb) load<br>
+Loading section .text, size 0x1cc lma 0x20000000<br>
+Loading section .vectors, size 0x40 lma 0x200001cc<br>
+Loading section .rodata, size 0x4 lma 0x2000020c<br>
+Start address 0x20000000, load size 528<br>
+Transfer rate: 64 KB/sec, 176 bytes/write.<br>
+(gdb) c<br>
+Continuing.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+(gdb)
+		</code></td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG005"/>DBG005</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint</td>
+		<td>Flash the test_rom.elf application. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset init<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor gdb_breakpoint_override hard<br>
+				force hard breakpoints<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+(gdb) monitor gdb_breakpoint_override hard<br>
+force hard breakpoints<br>
+(gdb) break main<br>
+Breakpoint 1 at 0x40000170: file src/main.c, line 69.<br>
+(gdb) c<br>
+Continuing.<br>
+Note: automatically using hardware breakpoints for read-only addresses.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+Current language:  auto<br>
+The current source language is "auto; currently c".<br>
+(gdb) 
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG006"/>DBG006</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint is set after a reset</td>
+		<td>Follow the instructions to flash and insert a hardware breakpoint from DBG005</td>
+		<td>In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) monitor reg pc 0x100000<br>
+				pc (/32): 0x00100000<br>
+				(gdb) continue
+			</code><br>
+			where the value inserted in PC is the start address of the application
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+(gdb) monitor reset init<br>
+jtag_speed 6400 => JTAG clk=0.010000<br>
+10 kHz<br>
+JTAG tap: str710.cpu tap/device found: 0x3f0f0f0f (mfg: 0x787, part: 0xf0f0, ver: 0x3)<br>
+srst pulls trst - can not reset into halted mode. Issuing halt after reset.<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Undefined instruction<br>
+cpsr: 0x400000db pc: 0x010aea80<br>
+jtag_speed 10 => JTAG clk=6.400000<br>
+6400 kHz<br>
+(gdb) monitor reg pc 0x40000000<br>
+pc (/32): 0x40000000<br>
+(gdb) c<br>
+Continuing.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+Current language:  auto<br>
+The current source language is "auto; currently c".<br>
+(gdb)
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG007"/>DBG007</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Single step in ROM</td>
+		<td>Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor arm7_9  force_hw_bkpts enable<br>
+				force hardware breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+				(gdb) step
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Supervisor<br>
+				cpsr: 0x60000013 pc: 0x0010013c<br>
+				70        DWORD b = 2;<br>
+			</code>
+		</td>
+		<td><code>
+Breakpoint 2, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+Current language:  auto<br>
+The current source language is "auto; currently c".<br>
+(gdb) step<br>
+70	  DWORD b = 2;<br>
+(gdb) 
+		</code></td>
+		<td>PASS</td>
+	</tr>
+</table>
+
+<H2>RAM access</H2>
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RAM001"/>RAM001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>32 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mww ram_address 0xdeadbeef 16<br>
+					> mdw ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.<br>
+			<code>
+				> mww 0x0 0xdeadbeef 16<br>
+				> mdw 0x0 32<br>
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388<br>
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388<br>
+			</code>
+		</td>
+		<td><code>
+> mww 0x20000000 0xdeadbeef 16<br>
+> mdw 0x20000000 32<br>
+0x20000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+0x20000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+0x20000040: e3a0020a e3a01073 e5801018 e5901008 e3110002 0afffffc e3a0020a e59f10d0<br> 
+0x20000060: e5801008 e321f0db e59fd0c8 e321f0d7 e59fd0c4 e321f0d1 e59fd0c0 e321f0d2<br> 
+> 
+</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM002"/>RAM002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>16 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwh ram_address 0xbeef 16<br>
+					> mdh ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.<br>
+			<code>
+				> mwh 0x0 0xbeef 16<br>
+				> mdh 0x0 32<br>
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br>
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000<br>
+				>
+			</code>
+		</td>
+		<td><code>
+> mwh 0x20000000 0xbeef 16<br>
+> mdh 0x20000000 32<br>       
+0x20000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br> 
+0x20000020: beef dead beef dead beef dead beef dead beef dead beef dead beef dead beef dead<br> 
+> 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM003"/>RAM003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>8 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwb ram_address 0xab 16<br>
+					> mdb ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.<br>
+			<code>
+				> mwb ram_address 0xab 16<br>
+				> mdb ram_address 32<br>
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>
+				>
+			</code>
+		</td>
+		<td><code>
+> mwb 0x20000000 0xab 16<br>  
+> mdb 0x20000000 32<br>     
+0x20000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ef be ef be ef be ef be ef be ef be ef be ef be<br> 
+> 
+ 		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+
+
+<H2>Flash access</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="FLA001"/>FLA001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Flash probe</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface:<br>
+			<code>	> flash probe 0</code>
+		</td>
+		<td>The command should execute without error. The output should state the name of the flash and the starting address. An example of output:<br>
+			<code>flash 'ecosflash' found at 0x01000000</code>
+		</td>
+		<td>
+		<code>
+			> flash probe 0<br>
+			flash 'str7x' found at 0x40000000<br>
+			> 
+		</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA002"/>FLA002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>flash fillw</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	> flash fillw 0x1000000 0xdeadbeef 16
+			</code>
+		</td>
+		<td>The commands should execute without error. The output looks like:<br>
+			<code>
+				wrote 64 bytes to 0x01000000 in 11.610000s (0.091516 kb/s)
+			</code><br>
+			To verify the contents of the flash:<br>
+			<code>
+				> mdw 0x1000000 32<br>
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+				> flash fillw 0x40000000 0xdeadbeef 16<br>
+				wrote 64 bytes to 0x40000000 in 0.000000s (inf kb/s)<br>
+				> mdw 0x40000000 32<br>
+				0x40000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+				0x40000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+				0x40000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				0x40000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+				> 
+			</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA003"/>FLA003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Flash erase</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	>  flash erase_address 0x1000000 0x2000
+			</code>
+		</td>
+		<td>The commands should execute without error.<br>
+			<code>
+				erased address 0x01000000 length 8192 in 4.970000s
+			</code>
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff. 
+			<code>
+				> mdw 0x1000000 32<br>
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+> flash erase_address 0x40000000 0x2000<br>
+erased address 0x40000000 (length 8192) in 0.270000s (29.630 kb/s)<br>
+> mdw 0x40000000 32                    <br>
+0x40000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x40000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x40000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x40000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+> 
+</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA004"/>FLA004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Loading to flash from GDB</td>
+		<td>Reset init is working, flash is probed, connectivity to GDB server is working</td>
+		<td>Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. <br>
+				<code>
+					(gdb) target remote ip:port<br>
+					(gdb) monitor reset<br>
+					(gdb) load<br>
+					Loading section .text, size 0x194 lma 0x100000<br>
+					Start address 0x100040, load size 404<br>
+					Transfer rate: 179 bytes/sec, 404 bytes/write.
+					(gdb) monitor verify_image path_to_elf_file		
+				</code>
+		</td>
+		<td>The output should look like:<br>
+			<code>
+				verified 404 bytes in 5.060000s
+			</code><br>
+			The failure message is something like:<br>
+			<code>Verify operation failed address 0x00200000. Was 0x00 instead of 0x18</code>
+		</td>
+		<td>
+			<code>
+(gdb) load<br>
+Loading section .text, size 0x1cc lma 0x40000000<br>
+Loading section .vectors, size 0x40 lma 0x400001cc<br>
+Loading section .rodata, size 0x4 lma 0x4000020c<br>
+Start address 0x40000000, load size 528<br>
+Transfer rate: 53 bytes/sec, 176 bytes/write.<br>
+(gdb) monitor verify_image /tftp/10.0.0.194/test_rom.elf<br>
+verified 528 bytes in 4.760000s (0.108 kb/s)<br>
+Current language:  auto<br>
+The current source language is "auto; currently asm".<br>
+(gdb) 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>	
+</table>
+
+</body>
+</html>
\ No newline at end of file
diff --git a/testing/results/v0.4.0-rc1/STR912.html b/testing/results/v0.4.0-rc1/STR912.html
new file mode 100755
index 0000000..c8df034
--- /dev/null
+++ b/testing/results/v0.4.0-rc1/STR912.html
@@ -0,0 +1,1008 @@
+<html>
+<head>
+<title>Test results for version 1.62</title>
+</head>
+
+<body>
+
+<H1>STR912</H1>
+
+<H2>Connectivity</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="CON001"/>CON001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Telnet connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On console, type<br><code>telnet ip port</code></td>
+		<td><code>Open On-Chip Debugger<br>></code></td>
+		<td><code>> telnet 10.0.0.142<br>
+					Trying 10.0.0.142...<br>
+					Connected to 10.0.0.142.<br>
+					Escape character is '^]'.<br>
+					Open On-Chip Debugger<br>
+					>
+</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="CON002"/>CON002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>GDB server connection</td>
+		<td>Power on, jtag target attached</td>
+		<td>On GDB console, type<br><code>target remote ip:port</code></td>
+		<td><code>Remote debugging using 10.0.0.73:3333</code></td>
+		<td><code>
+			(gdb) tar remo 10.0.0.142:3333<br>
+			Remote debugging using 10.0.0.142:3333<br>
+			0x00016434 in ?? ()<br>
+			(gdb)
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Reset</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RES001"/>RES001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+> reset halt<br>
+RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES002"/>RES002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset init on a blank target</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset init</code></td>
+		<td>Reset should return without error and the output should contain <br><code>executing reset script 'name_of_the_script'</code></td>
+		<td>
+			<code>
+> reset init<br>
+RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+cleared protection for sectors 0 through 7 on flash bank 0<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES003"/>RES003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset after a power cycle of the target</td>
+		<td>Reset the target then power cycle the target</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code> after the power was detected</td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+      nsed nSRST asserted.<br>
+  nsed power dropout.<br>
+  nsed power restore.<br>
+RCLK - adaptive<br>
+SRST took 85ms to deassert<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+cleared protection for sectors 0 through 7 on flash bank 0<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+> reset halt<br>
+RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES004"/>RES004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target where reset halt is supported</td>
+		<td>Erase all the content of the flash</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted<br>pc = 0</code></td>
+		<td>
+			<code>
+> reset halt<br>
+ RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (Manufacturer: 0x020, Part: 0x4570, Version: 0x0)<br>
+JTAG Tap/device matched<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (Manufacturer: 0x020, Part: 0x5966, Version: 0x2)<br>
+JTAG Tap/device matched<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (Manufacturer: 0x020, Part: 0x457f, Version: 0x2)<br>
+JTAG Tap/device matched<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RES005"/>RES005</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Reset halt on a blank target using return clock</td>
+		<td>Erase all the content of the flash, set the configuration script to use RCLK</td>
+		<td>Connect via the telnet interface and type <br><code>reset halt</code></td>
+		<td>Reset should return without error and the output should contain<br><code>target state: halted</code></td>
+		<td>
+			<code>
+			> reset halt<br>
+RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>JTAG Speed</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>ZY1000</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="SPD001"/>SPD001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>16MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 16000<br>
+jtag_speed 4 => JTAG clk=16.000000<br>
+16000 kHz<br>
+ThumbEE -- incomplete support<br>
+target state: halted<br>
+target halted in ThumbEE state due to debug-request, current mode: System<br>
+cpsr: 0xfdfdffff pc: 0xfdfdfff9<br>
+> mdw 0 32      <br>
+0x00000000: 00000000 00000000 ffffffff ffffffff 00000001 ffffffff 00000001 ffffffff<br> 
+0x00000020: 00000001 00000001 00000001 00000001 00000001 fffffffe fffffffe 00000001<br> 
+0x00000040: fffffffe 00000000 00000000 00000000 00000000 00000000 00000000 00000000<br> 
+0x00000060: 00000000 00000000 00000000 00000000 ffffffff ffffffff 00000001 00000000<br> 
+invalid mode value encountered 0<br>
+cpsr contains invalid mode value - communication failure<br>
+ThumbEE -- incomplete support<br>
+target state: halted<br>
+target halted in ThumbEE state due to debug-request, current mode: System<br>
+cpsr: 0xffffffff pc: 0xfffffff8<br>
+> 
+			</code>
+		</td>
+		<td><font color=red><b>FAIL</b></font></td>	
+	</tr>
+	<tr>
+		<td><a name="SPD002"/>SPD002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>8MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 8000<br>
+jtag_speed 8 => JTAG clk=8.000000<br>
+8000 kHz<br>
+> halt      <br>   
+invalid mode value encountered 0<br>
+cpsr contains invalid mode value - communication failure<br>
+Command handler execution failed<br>
+in procedure 'halt' called at file "command.c", line 647<br>
+called at file "command.c", line 361<br>
+Halt timed out, wake up GDB.<br>
+> 
+			</code>
+		</td>
+		<td><font color=red><b>FAIL</b></font></td>	
+	</tr>
+	<tr>
+		<td><a name="SPD003"/>SPD003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>4MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 4000<br>
+jtag_speed 16 => JTAG clk=4.000000<br>
+4000 kHz<br>
+> halt      <br>   
+> mdw 0 32     <br>
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+> 
+			</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="SPD004"/>SPD004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>2MHz on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 2000<br>
+jtag_speed 32 => JTAG clk=2.000000<br>
+2000 kHz<br>
+> halt<br>
+> mdw 0 32<br>     
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="SPD005"/>SPD005</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>RCLK on normal operation</td>
+		<td>Reset init the target according to RES002 </td>
+		<td>Change speed and exercise a memory access over the JTAG, for example <br><code>mdw 0x0 32</code></td>
+		<td>The command should run without any errors. If any JTAG checking errors happen, the test failed</td>
+		<td>
+			<code>
+> jtag_khz 0<br>   
+RCLK - adaptive<br>
+> halt      <br>
+> mdw 0 32  <br>
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+> 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+<H2>Debugging</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="DBG001"/>DBG001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Load is working</td>
+		<td>Reset init is working, RAM is accesible, GDB server is started</td>
+		<td>On the console of the OS: <br>
+			<code>arm-elf-gdb test_ram.elf</code><br>
+			<code>(gdb) target remote ip:port</code><br>
+			<code>(gdb) load</load>
+		</td>
+		<td>Load should return without error, typical output looks like:<br>
+			<code>
+				Loading section .text, size 0x14c lma 0x0<br>
+				Start address 0x40, load size 332<br>
+				Transfer rate: 180 bytes/sec, 332 bytes/write.<br>
+			</code>
+		</td>
+		<td><code>
+(gdb) load<br>
+Loading section .text, size 0x1a0 lma 0x4000000<br>
+Loading section .rodata, size 0x4 lma 0x40001a0<br>
+Start address 0x4000000, load size 420<br>
+Transfer rate: 29 KB/sec, 210 bytes/write.<br>
+(gdb) 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	
+	<tr>
+		<td><a name="DBG002"/>DBG002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Software breakpoint</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001</td>
+		<td>In the GDB console:<br>
+			<code>
+				(gdb) monitor gdb_breakpoint_override soft<br>
+				force soft breakpoints<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0xec: file src/main.c, line 71.<br>
+				(gdb) continue<br>
+				Continuing.
+			</code>
+		</td>
+		<td>The software breakpoint should be reached, a typical output looks like:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+				cpsr: 0x000000d3 pc: 0x000000ec<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71        DWORD a = 1;
+			</code>
+		</td>
+		<td>
+			<code>
+(gdb) monitor gdb_breakpoint_override soft<br>
+force soft breakpoints<br>
+Current language:  auto<br>
+The current source language is "auto; currently asm".<br>
+(gdb) break main<br>
+Breakpoint 1 at 0x4000144: file src/main.c, line 69.<br>
+(gdb) c<br>
+Continuing.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+warning: Source file is more recent than executable.<br>
+69	  DWORD a = 1;<br>
+Current language:  auto<br>
+The current source language is "auto; currently c".<br>
+(gdb) 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="DBG003"/>DBG003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Single step in a RAM application</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>(gdb) step</code></td>
+		<td>The next instruction should be reached, typical output:<br>
+			<code>
+				(gdb) step<br>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Abort<br>
+				cpsr: 0x20000097 pc: 0x000000f0<br>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Abort<br>
+				cpsr: 0x20000097 pc: 0x000000f4<br>
+				72        DWORD b = 2;
+			</code>
+		</td>
+		<td>
+			<code>
+				(gdb) step<br>
+				70	  DWORD b = 2;<br>
+				(gdb)<br>
+			</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG004"/>DBG004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Software break points are working after a reset</td>
+		<td>Load the test_ram.elf application, use instructions from GDB001, break in main using the instructions from GDB002</td>
+		<td>In GDB, type <br><code>
+			(gdb) monitor reset init<br>
+			(gdb) load<br>
+			(gdb) continue<br>
+			</code></td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to breakpoint, current mode: Supervisor<br>
+				cpsr: 0x000000d3 pc: 0x000000ec<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:71<br>
+				71        DWORD a = 1;
+			</code>
+		</td>
+		<td><code>
+(gdb) monitor reset init<br>
+RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+cleared protection for sectors 0 through 7 on flash bank 0<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+(gdb) load<br>
+Loading section .text, size 0x1a0 lma 0x4000000<br>
+Loading section .rodata, size 0x4 lma 0x40001a0<br>
+Start address 0x4000000, load size 420<br>
+Transfer rate: 25 KB/sec, 210 bytes/write.<br>
+(gdb) c<br>
+Continuing.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+(gdb)
+		</code></td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG005"/>DBG005</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint</td>
+		<td>Flash the test_rom.elf application. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset init<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor gdb_breakpoint_override hard<br>
+				force hard breakpoints<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+(gdb) monitor reset init<br>
+RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+cleared protection for sectors 0 through 7 on flash bank 0<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+(gdb) load<br>
+Loading section .text, size 0x1a0 lma 0x0<br>
+Loading section .rodata, size 0x4 lma 0x1a0<br>
+Start address 0x0, load size 420<br>
+Transfer rate: 426 bytes/sec, 210 bytes/write.<br>
+(gdb) monitor gdb_breakpoint_override hard<br>
+force hard breakpoints<br>
+(gdb) break main<br>
+Breakpoint 1 at 0x144: file src/main.c, line 69.<br>
+(gdb) continue<br>
+Continuing.<br>
+Note: automatically using hardware breakpoints for read-only addresses.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+warning: Source file is more recent than executable.<br>
+69	  DWORD a = 1;<br>
+Current language:  auto<br>
+The current source language is "auto; currently c".<br>
+(gdb) 
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG006"/>DBG006</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Hardware breakpoint is set after a reset</td>
+		<td>Follow the instructions to flash and insert a hardware breakpoint from DBG005</td>
+		<td>In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) monitor reg pc 0x100000<br>
+				pc (/32): 0x00100000<br>
+				(gdb) continue
+			</code><br>
+			where the value inserted in PC is the start address of the application
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+			</code>
+		</td>
+		<td>
+		<code>
+(gdb) monitor reset init<br>
+RCLK - adaptive<br>
+SRST took 2ms to deassert<br>
+JTAG tap: str912.flash tap/device found: 0x04570041 (mfg: 0x020, part: 0x4570, ver: 0x0)<br>
+JTAG tap: str912.cpu tap/device found: 0x25966041 (mfg: 0x020, part: 0x5966, ver: 0x2)<br>
+JTAG tap: str912.bs tap/device found: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs       UNEXPECTED: 0x2457f041 (mfg: 0x020, part: 0x457f, ver: 0x2)<br>
+JTAG tap: str912.bs  expected 1 of 1: 0x1457f041 (mfg: 0x020, part: 0x457f, ver: 0x1)<br>
+Trying to use configured scan chain anyway...<br>
+Bypassing JTAG setup events due to errors<br>
+SRST took 2ms to deassert<br>
+target state: halted<br>
+target halted in ARM state due to debug-request, current mode: Supervisor<br>
+cpsr: 0x000000d3 pc: 0x00000000<br>
+cleared protection for sectors 0 through 7 on flash bank 0<br>
+NOTE! DCC downloads have not been enabled, defaulting to slow memory writes. Type 'help dcc'.<br>
+(gdb) c<br>
+Continuing.<br>
+<br>
+Breakpoint 1, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+(gdb)
+		</code>
+		</td>
+		<td>PASS</td>
+	</tr>
+	<tr>
+		<td><a name="DBG007"/>DBG007</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Single step in ROM</td>
+		<td>Flash the test_rom.elf application and set a breakpoint in main, use DBG005. Make this test after FLA004 has passed</td>
+		<td>Be sure that <code>gdb_memory_map</code> and <code>gdb_flash_program</code> are enabled. In GDB, type <br>
+			<code>
+				(gdb) monitor reset<br>
+				(gdb) load<br>
+				Loading section .text, size 0x194 lma 0x100000<br>
+				Start address 0x100040, load size 404<br>
+				Transfer rate: 179 bytes/sec, 404 bytes/write.<br>
+				(gdb) monitor arm7_9  force_hw_bkpts enable<br>
+				force hardware breakpoints enabled<br>
+				(gdb) break main<br>
+				Breakpoint 1 at 0x100134: file src/main.c, line 69.<br>
+				(gdb) continue<br>
+				Continuing.<br>
+				<br>
+				Breakpoint 1, main () at src/main.c:69<br>
+				69        DWORD a = 1;<br>
+				(gdb) step
+			</code>
+		</td>
+		<td>The breakpoint should be reached, typical output:<br>
+			<code>
+				target state: halted<br>
+				target halted in ARM state due to single step, current mode: Supervisor<br>
+				cpsr: 0x60000013 pc: 0x0010013c<br>
+				70        DWORD b = 2;<br>
+			</code>
+		</td>
+		<td><code>
+			(gdb) c<br>
+Continuing.<br>
+<br>
+Breakpoint 2, main () at src/main.c:69<br>
+69	  DWORD a = 1;<br>
+Current language:  auto<br>
+The current source language is "auto; currently c".<br>
+(gdb) step<br>
+70	  DWORD b = 2;<br>
+(gdb) 
+		</code></td>
+		<td>PASS</td>
+	</tr>
+</table>
+
+<H2>RAM access</H2>
+Note: these tests are not designed to test/debug the target, but to test functionalities!
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="RAM001"/>RAM001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>32 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mww ram_address 0xdeadbeef 16<br>
+					> mdw ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 32bit long containing 0xdeadbeef.<br>
+			<code>
+				> mww 0x0 0xdeadbeef 16<br>
+				> mdw 0x0 32<br>
+				0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x00000040: e1a00000 e59fa51c e59f051c e04aa000 00080017 00009388 00009388 00009388<br>
+				0x00000060: 00009388 0002c2c0 0002c2c0 000094f8 000094f4 00009388 00009388 00009388<br>
+			</code>
+		</td>
+		<td><code>
+> mww 0x4000000 0xdeadbeef 16<br>
+> mdw 0x4000000 32            <br>
+0x04000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+0x04000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+0x04000040: e580100c e3a01802 e5801010 e3a01018 e5801018 e59f00a8 e59f10a8 e5801000<br> 
+0x04000060: e3a00806 ee2f0f11 e321f0d7 e59fd098 e321f0db e59fd094 e321f0d3 e59fd090<br> 
+> 
+</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM002"/>RAM002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>16 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwh ram_address 0xbeef 16<br>
+					> mdh ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 16bit long containing 0xbeef.<br>
+			<code>
+				> mwh 0x0 0xbeef 16<br>
+				> mdh 0x0 32<br>
+				0x00000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br>
+				0x00000020: 00e0 0000 021c 0000 0240 0000 026c 0000 0288 0000 0000 0000 0388 0000 0350 0000<br>
+				>
+			</code>
+		</td>
+		<td><code>
+> mwh 0x4000000 0xbeef 16<br>    
+> mdh 0x4000000 32<br>           
+0x04000000: beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef beef<br> 
+0x04000020: beef dead beef dead beef dead beef dead beef dead beef dead beef dead beef dead<br> 
+> 
+		</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="RAM003"/>RAM003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>8 bit Write/read RAM</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface<br>
+			<code>	> mwb ram_address 0xab 16<br>
+					> mdb ram_address 32
+			</code>
+		</td>
+		<td>The commands should execute without error. A clear failure is a memory access exception. The result of running the commands should be a list of 16 locations 8bit long containing 0xab.<br>
+			<code>
+				> mwb ram_address 0xab 16<br>
+				> mdb ram_address 32<br>
+				0x00000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00<br>
+				>
+			</code>
+		</td>
+		<td><code>
+> mwb 0x4000000 0xab 16<br>  
+> mdb 0x4000000 32<br>     
+0x04000000: ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ef be ef be ef be ef be ef be ef be ef be ef be<br> 
+> 
+ 		</code></td>
+		<td>PASS</td>	
+	</tr>
+</table>
+
+
+
+<H2>Flash access</H2>
+<table border=1>
+	<tr>
+		<td>ID</td>
+		<td>Target</td>
+		<td>Interface</td>
+		<td>Description</td>
+		<td>Initial state</td>
+		<td>Input</td>
+		<td>Expected output</td>
+		<td>Actual output</td>
+		<td>Pass/Fail</td>
+	</tr>
+	<tr>
+		<td><a name="FLA001"/>FLA001</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Flash probe</td>
+		<td>Reset init is working</td>
+		<td>On the telnet interface:<br>
+			<code>	> flash probe 0</code>
+		</td>
+		<td>The command should execute without error. The output should state the name of the flash and the starting address. An example of output:<br>
+			<code>flash 'ecosflash' found at 0x01000000</code>
+		</td>
+		<td>
+		<code>
+			> flash probe 0<br>
+			flash 'str9x' found at 0x00000000<br>
+			> 
+		</code>
+		</td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA002"/>FLA002</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>flash fillw</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	> flash fillw 0x1000000 0xdeadbeef 16
+			</code>
+		</td>
+		<td>The commands should execute without error. The output looks like:<br>
+			<code>
+				wrote 64 bytes to 0x01000000 in 11.610000s (0.091516 kb/s)
+			</code><br>
+			To verify the contents of the flash:<br>
+			<code>
+				> mdw 0x1000000 32<br>
+				0x01000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x01000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+> flash fillw 0x0 0xdeadbeef 16 <br>    
+wrote 64 bytes to 0x00000000 in 0.020000s (3.125 kb/s)<br>
+> mdw 0 32<br>
+0x00000000: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+0x00000020: deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef deadbeef<br> 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+> 
+			</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA003"/>FLA003</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Flash erase</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	>  flash erase_address 0x1000000 0x20000
+			</code>
+		</td>
+		<td>The commands should execute without error.<br>
+			<code>
+				erased address 0x01000000 length 131072 in 4.970000s<br>
+			</code>
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff.<br> 
+			<code>
+				> mdw 0x1000000 32<br>
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+> flash erase_address 0 0x20000<br>
+erased address 0x00000000 (length 131072) in 1.970000s (64.975 kb/s)<br>
+> mdw 0 32<br>
+0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br> 
+> 
+</code></td>
+		<td>PASS</td>	
+	</tr>
+		<tr>
+		<td><a name="FLA004"/>FLA004</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Entire flash erase</td>
+		<td>Reset init is working, flash is probed</td>
+		<td>On the telnet interface<br>
+			<code>	>  flash erase_address 0x0 0x80000
+			</code>
+		</td>
+		<td>The commands should execute without error.<br>
+			<code>
+				erased address 0x01000000 length 8192 in 4.970000s<br>
+			</code>
+			To check that the flash has been erased, read at different addresses. The result should always be 0xff.<br> 
+			<code>
+				> mdw 0x1000000 32<br>
+				0x01000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+				0x01000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+			</code>
+		</td>
+		<td><code>
+> flash erase_address 0 0x80000<br>
+ erased address 0x00000000 length 524288 in 1.020000s<br>
+<br>
+> mdw 0 32<br>
+ 0x00000000: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+0x00000020: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+0x00000040: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff<br>
+0x00000060: ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
+</code></td>
+		<td>PASS</td>	
+	</tr>
+	<tr>
+		<td><a name="FLA005"/>FLA005</td>
+		<td>STR912</td>
+		<td>ZY1000</td>
+		<td>Loading to flash from GDB</td>
+		<td>Reset init is working, flash is probed, connectivity to GDB server is working</td>
+		<td>Start GDB using a ROM elf image, eg: arm-elf-gdb test_rom.elf. <br>
+				<code>
+					(gdb) target remote ip:port<br>
+					(gdb) monitor reset<br>
+					(gdb) load<br>
+					Loading section .text, size 0x194 lma 0x100000<br>
+					Start address 0x100040, load size 404<br>
+					Transfer rate: 179 bytes/sec, 404 bytes/write.
+					(gdb) monitor verify_image path_to_elf_file		
+				</code>
+		</td>
+		<td>The output should look like:<br>
+			<code>
+				verified 404 bytes in 5.060000s
+			</code><br>
+			The failure message is something like:<br>
+			<code>Verify operation failed address 0x00200000. Was 0x00 instead of 0x18</code>
+		</td>
+		<td>
+			<code>
+(gdb) load<br>
+Loading section .text, size 0x1a0 lma 0x0<br>
+Loading section .rodata, size 0x4 lma 0x1a0<br>
+Start address 0x0, load size 420<br>
+Transfer rate: 425 bytes/sec, 210 bytes/write.<br>
+(gdb) moni verify_image /tftp/10.0.0.194/test_rom.elf<br>
+verified 420 bytes in 0.350000s (1.172 kb/s)<br>
+(gdb) 
+			</code>
+		</td>
+		<td>PASS</td>	
+	</tr>	
+</table>
+
+</body>
+</html>
\ No newline at end of file

-----------------------------------------------------------------------

Summary of changes:
 testing/results/v0.4.0-rc1/AT91FR40162.html |  856 +++++++++++++++++++++++
 testing/results/v0.4.0-rc1/LPC2148.html     |  933 +++++++++++++++++++++++++
 testing/results/v0.4.0-rc1/SAM7.html        |  853 ++++++++++++++++++++++
 testing/results/v0.4.0-rc1/STR710.html      |  907 ++++++++++++++++++++++++
 testing/results/v0.4.0-rc1/STR912.html      | 1008 +++++++++++++++++++++++++++
 5 files changed, 4557 insertions(+), 0 deletions(-)
 create mode 100755 testing/results/v0.4.0-rc1/AT91FR40162.html
 create mode 100755 testing/results/v0.4.0-rc1/LPC2148.html
 create mode 100755 testing/results/v0.4.0-rc1/SAM7.html
 create mode 100755 testing/results/v0.4.0-rc1/STR710.html
 create mode 100755 testing/results/v0.4.0-rc1/STR912.html


hooks/post-receive
-- 
Main OpenOCD repository


From npitre at users.sourceforge.net  Tue Feb  2 06:12:12 2010
From: npitre at users.sourceforge.net (Nicolas Pitre)
Date: Tue,  2 Feb 2010 05:12:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-171-g3d2d5dc
Message-ID: <E1NcB3d-0004mz-Gn@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3d2d5dcc9c27b84dc2e5e9ed53be0f784a450042 (commit)
      from  bef37ceba2bde6a34d003762bced007bed894bc7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3d2d5dcc9c27b84dc2e5e9ed53be0f784a450042
Author: Nicolas Pitre <nico at fluxnic.net>
Date:   Tue Feb 2 00:05:42 2010 -0500

    ARM semihosting: fix EOF handling with SYS_READ
    
    The semihosting interface has a strange convention for read/write where
    the unused amount of buffer must be returned.  We failed to return the
    total buffer size when the local read() call returned 0.
    
    Signed-off-by: Nicolas Pitre <nico at marvell.com>

diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index c41c5a0..9b853d9 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -190,7 +190,7 @@ static int do_semihosting(struct target *target)
 			} else {
 				result = read(fd, buf, l);
 				armv4_5->semihosting_errno = errno;
-				if (result > 0) {
+				if (result >= 0) {
 					retval = target_write_buffer(target, a, result, buf);
 					if (retval != ERROR_OK) {
 						free(buf);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_semihosting.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Feb  2 18:31:13 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  2 Feb 2010 17:31:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-173-gcc440ca
Message-ID: <E1NcMao-0006Vk-P6@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  cc440ca1d44f0aaaf34daa365966b7b092126913 (commit)
       via  503f6139c7ed05339daea8c4984d32840d795222 (commit)
      from  3d2d5dcc9c27b84dc2e5e9ed53be0f784a450042 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit cc440ca1d44f0aaaf34daa365966b7b092126913
Author: Edgar Grimberg <edgar.grimberg at zylin.com>
Date:   Tue Feb 2 13:17:26 2010 +0100

    tcl/str7x: Reset init unlocks the flash
    
    For STR7x flash, the device cannot be queried for the protect status.
    The solution is to remove the protection on reset init. The driver
    also initialises the sector protect field to unprotected.
    
    [dbrownell at users.sourceforge.net: line length shrinkage]
    
    Signed-off-by: Edgar Grimberg <edgar.grimberg at zylin.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/target/str730.cfg b/tcl/target/str730.cfg
index 381fa5f..cab2338 100644
--- a/tcl/target/str730.cfg
+++ b/tcl/target/str730.cfg
@@ -34,7 +34,14 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
 
 $_TARGETNAME configure -event reset-start { jtag_khz 10 }
-$_TARGETNAME configure -event reset-init { jtag_khz 3000 }
+$_TARGETNAME configure -event reset-init {
+	jtag_khz 3000
+
+# Because the hardware cannot be interrogated for the protection state
+# of sectors, initialize all the sectors to be unprotected. The initial
+# state is reflected by the driver, too.
+	flash protect 0 0 last off
+}
 $_TARGETNAME configure -event gdb-flash-erase-start {
 	flash protect 0 0 7 off
 }
diff --git a/tcl/target/str750.cfg b/tcl/target/str750.cfg
index 5df968b..c467ae2 100644
--- a/tcl/target/str750.cfg
+++ b/tcl/target/str750.cfg
@@ -36,7 +36,15 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian little -chain-position 0 -variant arm7tdmi
 
 $_TARGETNAME configure -event reset-start  { jtag_khz 10 }
-$_TARGETNAME configure -event reset-init { jtag_khz 3000 }
+$_TARGETNAME configure -event reset-init {
+	jtag_khz 3000
+
+# Because the hardware cannot be interrogated for the protection state
+# of sectors, initialize all the sectors to be unprotected. The initial
+# state is reflected by the driver, too.
+	flash protect 0 0 last off
+	flash protect 1 0 last off
+}
 $_TARGETNAME configure -event gdb-flash-erase-start {
 	flash protect 0 0 7 off
 	flash protect 1 0 1 off

commit 503f6139c7ed05339daea8c4984d32840d795222
Author: Edgar Grimberg <edgar.grimberg at zylin.com>
Date:   Tue Feb 2 10:39:52 2010 +0100

    flash/str7x: After reset init the flash is unlocked
    
    The default state of the STR7 flash after a reset init is unlocked.
    The information in the flash driver now reflects this.
    
    The information about the lock status cannot be read from the
    flash chip, so the user is informed that flash info might not
    contain accurate information.
    
    [dbrownell at users.sourceforge.net: line length shrinkage]
    
    Signed-off-by: Edgar Grimberg <edgar.grimberg at zylin.com>
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index a2e27da..3bf07c9 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -93,7 +93,10 @@ static int str7x_build_block_list(struct flash_bank *bank)
 		bank->sectors[num_sectors].offset = mem_layout_str7bank0[i].sector_start;
 		bank->sectors[num_sectors].size = mem_layout_str7bank0[i].sector_size;
 		bank->sectors[num_sectors].is_erased = -1;
-		bank->sectors[num_sectors].is_protected = 1;
+		/* the reset_init handler marks all the sectors unprotected,
+		 * matching hardware after reset; keep the driver in sync
+		 */
+		bank->sectors[num_sectors].is_protected = 0;
 		str7x_info->sector_bits[num_sectors++] = mem_layout_str7bank0[i].sector_bit;
 	}
 
@@ -102,7 +105,10 @@ static int str7x_build_block_list(struct flash_bank *bank)
 		bank->sectors[num_sectors].offset = mem_layout_str7bank1[i].sector_start;
 		bank->sectors[num_sectors].size = mem_layout_str7bank1[i].sector_size;
 		bank->sectors[num_sectors].is_erased = -1;
-		bank->sectors[num_sectors].is_protected = 1;
+		/* the reset_init handler marks all the sectors unprotected,
+		 * matching hardware after reset; keep the driver in sync
+		 */
+		bank->sectors[num_sectors].is_protected = 0;
 		str7x_info->sector_bits[num_sectors++] = mem_layout_str7bank1[i].sector_bit;
 	}
 
@@ -600,6 +606,12 @@ COMMAND_HANDLER(str7x_handle_part_id_command)
 static int str7x_info(struct flash_bank *bank, char *buf, int buf_size)
 {
 	snprintf(buf, buf_size, "str7x flash driver info");
+	/* STR7x flash doesn't support sector protection interrogation.
+	 * FLASH_NVWPAR acts as a write only register; its read value
+	 * doesn't reflect the actual protection state of the sectors.
+	 */
+	LOG_WARNING("STR7x flash lock information might not be correct "
+			"due to hardware limitations.");
 	return ERROR_OK;
 }
 
diff --git a/tcl/target/str710.cfg b/tcl/target/str710.cfg
index 9da69ac..028c604 100644
--- a/tcl/target/str710.cfg
+++ b/tcl/target/str710.cfg
@@ -30,7 +30,15 @@ set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
 
 $_TARGETNAME configure -event reset-start { jtag_khz 10 }
-$_TARGETNAME configure -event reset-init { jtag_khz 6000 }
+$_TARGETNAME configure -event reset-init {
+	jtag_khz 6000
+
+# Because the hardware cannot be interrogated for the protection state
+# of sectors, initialize all the sectors to be unprotected. The initial
+# state is reflected by the driver, too.
+	flash protect 0 0 last off
+	flash protect 1 0 last off
+}
 $_TARGETNAME configure -event gdb-flash-erase-start {
 	flash protect 0 0 7 off
 	flash protect 1 0 1 off

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/str7x.c |   16 ++++++++++++++--
 tcl/target/str710.cfg |   10 +++++++++-
 tcl/target/str730.cfg |    9 ++++++++-
 tcl/target/str750.cfg |   10 +++++++++-
 4 files changed, 40 insertions(+), 5 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Feb  2 19:53:22 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  2 Feb 2010 18:53:22 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-174-g5750e89
Message-ID: <E1NcNsJ-00047J-KW@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  5750e899e03aa3312202be3ff217645c5f69304d (commit)
      from  cc440ca1d44f0aaaf34daa365966b7b092126913 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 5750e899e03aa3312202be3ff217645c5f69304d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Feb 2 10:53:13 2010 -0800

    NOR: User's Guide updates
    
    Remove long-obsolete text about "erase_check" affecting "flash info" output.
    Move parts of that text to "protect_check", where it's still relevant; and
    update the "flash info" description to mention the issue.
    
    (This is still awkward.  It might be best to make "protect_check" mirror
    "erase_check" by dumping what it finds, so "flash info" doesn't dump any
    potentially-stale cache info.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index 38fa92f..957c79c 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4033,17 +4033,14 @@ it has been removed by the @option{unlock} flag.
 Check erase state of sectors in flash bank @var{num},
 and display that status.
 The @var{num} parameter is a value shown by @command{flash banks}.
-This is the only operation that
-updates the erase state information displayed by @option{flash info}. That means you have
-to issue a @command{flash erase_check} command after erasing or programming the device
-to get updated information.
-(Code execution may have invalidated any state records kept by OpenOCD.)
 @end deffn
 
 @deffn Command {flash info} num
 Print info about flash bank @var{num}
 The @var{num} parameter is a value shown by @command{flash banks}.
-The information includes per-sector protect status.
+The information includes per-sector protect status, which may be
+incorrect (outdated) unless you first issue a
+ at command{flash protect_check num} command.
 @end deffn
 
 @anchor{flash protect}
@@ -4060,6 +4057,8 @@ The @var{num} parameter is a value shown by @command{flash banks}.
 Check protection state of sectors in flash bank @var{num}.
 The @var{num} parameter is a value shown by @command{flash banks}.
 @comment @option{flash erase_sector} using the same syntax.
+This updates the protection information displayed by @option{flash info}.
+(Code execution may have invalidated any state records kept by OpenOCD.)
 @end deffn
 
 @anchor{Flash Driver List}

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |   11 +++++------
 1 files changed, 5 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Tue Feb  2 20:10:11 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Tue,  2 Feb 2010 19:10:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-175-g1896946
Message-ID: <E1NcO8e-00081R-DZ@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  18969466c91e75102f76be60d00a11cb93ed329d (commit)
      from  5750e899e03aa3312202be3ff217645c5f69304d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 18969466c91e75102f76be60d00a11cb93ed329d
Author: Harald Kipp <harald.kipp at egnite.de>
Date:   Tue Feb 2 11:09:53 2010 -0800

    AT91R40008/Ethernut 3 configuration
    
    Moved board specific settings from target/at91r40008.cfg to a new
    file board/ethernut3.cfg.
    
    Set correct CPUTAPID.  Reset delay increased, see MIC2775 data sheet.
    Increased work area size from 16k to 128k.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/ethernut3.cfg b/tcl/board/ethernut3.cfg
new file mode 100644
index 0000000..f22e688
--- /dev/null
+++ b/tcl/board/ethernut3.cfg
@@ -0,0 +1,86 @@
+#
+# Ethernut 3 board configuration file
+#
+# http://www.ethernut.de/en/hardware/enut3/
+
+
+# AT91R40008-66AU ARM7TDMI Microcontroller
+# 256kB internal RAM
+source [find target/at91r40008.cfg]
+
+
+# AT49BV322A-70TU NOR Flash
+# 2M x 16 mode at address 0x10000000
+# Common flash interface supported
+#
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME cfi 0x10000000 0x400000 2 2 $_TARGETNAME
+
+
+# Micrel MIC2775-29YM5 Supervisor
+# Reset output will remain active for 280ms (maximum)
+#
+jtag_nsrst_delay 300
+jtag_ntrst_delay 300
+
+
+arm7_9 fast_memory_access enable
+arm7_9 dcc_downloads enable
+jtag_khz 16000
+
+
+# Target events
+#
+$_TARGETNAME configure -event reset-init { board_init }
+
+# Initialize board hardware
+#
+proc board_init { } {
+	board_remap
+	flash probe 0
+}
+
+# Memory remap
+#
+proc board_remap {{VERBOSE 0}} {
+	# CS0: NOR flash
+	#      16MB @ 0x10000000
+	#      16-bit data bus
+	#      4 wait states
+	#
+	mww 0xffe00000 0x1000212d
+
+	# CS1: Ethernet controller
+	#      1MB @ 0x20000000
+	#      16-bit data bus
+	#      2 wait states
+	#      Byte select access
+	#
+	mww 0xffe00004 0x20003025
+
+	# CS2: CPLD registers
+	#      1MB @ 0x21000000
+	#      8-bit data bus
+	#      2 wait states
+	#
+	mww 0xffe00008 0x21002026
+
+	# CS3: Expansion bus
+	#      1MB @ 0x22000000
+	#      8-bit data bus
+	#      8 wait states
+	#
+	mww 0xffe00010 0x22002e3e
+
+	# Remap command
+	#
+	mww 0xffe00020 0x00000001
+
+	if {$VERBOSE != 0} {
+		puts "0x00000000 RAM"
+		puts "0x10000000 Flash"
+		puts "0x20000000 Ethernet"
+		puts "0x21000000 CPLD"
+		puts "0x22000000 Expansion"
+	}
+}
diff --git a/tcl/target/at91r40008.cfg b/tcl/target/at91r40008.cfg
index 9069ae5..9c0c483 100644
--- a/tcl/target/at91r40008.cfg
+++ b/tcl/target/at91r40008.cfg
@@ -1,9 +1,13 @@
+# AT91R40008 target configuration file
+
+# TRST is tied to SRST on the AT91X40 family.
+reset_config srst_only srst_pulls_trst
 
 
-if { [info exists CHIPNAME] } {
+if {[info exists CHIPNAME]} {
    set  _CHIPNAME $CHIPNAME
 } else {
-   set  _CHIPNAME at9r40008
+   set  _CHIPNAME at91r40008
 }
 
 if { [info exists ENDIAN] } {
@@ -12,41 +16,14 @@ if { [info exists ENDIAN] } {
    set  _ENDIAN little
 }
 
+# Setup the JTAG scan chain.
 if { [info exists CPUTAPID ] } {
    set _CPUTAPID $CPUTAPID
 } else {
-  # force an error till we get a good number
-   set _CPUTAPID 0xffffffff
+   set _CPUTAPID 0x1f0f0f0f
 }
-
-jtag_nsrst_delay 200
-jtag_ntrst_delay 200
-
-#use combined on interfaces or targets that can't set TRST/SRST separately
-reset_config srst_only srst_pulls_trst
-
-#jtag scan chain
-#format L IRC IRCM IDCODE (Length, IR Capture, IR Capture Mask, IDCODE)
 jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
 
 set _TARGETNAME $_CHIPNAME.cpu
 target create $_TARGETNAME arm7tdmi -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm7tdmi
-
-
-$_TARGETNAME configure -event gdb-flash-erase-start {
-	wait_halt
-	sleep 10
-	poll
-	# Ethernut 3 remapping is required to access external flash memory.
-	mww 0xffe00000 0x1000213d
-	mww 0xffe00004 0x20003e3d
-	mww 0xffe00020 0x00000001
-}
-
-$_TARGETNAME configure -work-area-phys 0x3C000 -work-area-size 0x4000 -work-area-backup 0
-
-set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME cfi 0x10000000 0x400000 2 2 $_TARGETNAME
-
-# For more information about the configuration files, take a look at:
-# openocd.texi
+$_TARGETNAME configure -work-area-phys 0x20000 -work-area-size 0x20000 -work-area-backup 0

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/ethernut3.cfg   |   86 +++++++++++++++++++++++++++++++++++++++++++++
 tcl/target/at91r40008.cfg |   41 +++++-----------------
 2 files changed, 95 insertions(+), 32 deletions(-)
 create mode 100644 tcl/board/ethernut3.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Wed Feb  3 14:09:58 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Wed,  3 Feb 2010 13:09:58 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-176-g95ed9c4
Message-ID: <E1NcezY-0007Yv-Fb@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  95ed9c43936d0d41c5b298fc4efaba4dc2e20f18 (commit)
      from  18969466c91e75102f76be60d00a11cb93ed329d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 95ed9c43936d0d41c5b298fc4efaba4dc2e20f18
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Wed Feb 3 13:08:42 2010 +0000

    JTAG: fix bug when no interface connected
    
     - fix coredump when OpenOCD is started without a jtag interface connected.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/jtag/core.c b/src/jtag/core.c
index 8a580e9..4f517c0 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -1623,6 +1623,13 @@ bool jtag_will_verify_capture_ir()
 
 int jtag_power_dropout(int *dropout)
 {
+	if (jtag == NULL)
+	{
+		/* TODO: as the jtag interface is not valid all
+		 * we can do at the moment is exit OpenOCD */
+		LOG_ERROR("No Valid JTAG Interface Configured.");
+		exit(-1);
+	}
 	return jtag->power_dropout(dropout);
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/core.c |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb  4 10:24:41 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu,  4 Feb 2010 09:24:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-177-g8b049fd
Message-ID: <E1Ncxx4-0007WI-S7@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  8b049fdba52459d54f63d39ae7b30abeef911e2b (commit)
      from  95ed9c43936d0d41c5b298fc4efaba4dc2e20f18 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 8b049fdba52459d54f63d39ae7b30abeef911e2b
Author: Ethan Eade <ethan at evolution.com>
Date:   Thu Feb 4 10:25:44 2010 +0100

    scripts: Phytec/LPC2350 config scripts
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/phytec_lpc3250.cfg b/tcl/board/phytec_lpc3250.cfg
new file mode 100644
index 0000000..78cb90d
--- /dev/null
+++ b/tcl/board/phytec_lpc3250.cfg
@@ -0,0 +1,88 @@
+source [find target/lpc3250.cfg]
+
+jtag_nsrst_delay 200
+jtag_ntrst_delay 1
+jtag_khz 200
+reset_config trst_and_srst separate
+
+arm7_9 dcc_downloads enable
+
+$_TARGETNAME configure -event gdb-attach { reset init }
+
+$_TARGETNAME configure -event reset-start {
+             arm7_9 fast_memory_access disable
+             jtag_khz 200
+}
+
+$_TARGETNAME configure -event reset-end {
+             jtag_khz 6000
+             arm7_9 fast_memory_access enable
+}
+
+$_TARGETNAME configure -event reset-init { phytec_lpc3250_init }
+
+# Bare-bones initialization of core clocks and SDRAM
+proc phytec_lpc3250_init { } {
+        # Set clock dividers 
+        #   ARMCLK = 266.5 MHz
+        #   HCLK   = 133.25 MHz
+        #   PERIPHCLK = 13.325 MHz
+        mww 0x400040BC 0
+        mww 0x40004050 0x140        
+        mww 0x40004040 0x4D
+        mww 0x40004058 0x16250
+
+        # Init PLLs
+        mww 0x40004044 0x006
+        sleep 1 busy
+        mww 0x40004044 0x106
+        sleep 1 busy
+        mww 0x40004044 0x006        
+        sleep 1 busy
+        mww 0x40004048 0x2
+
+        # Init SDRAM with 133 MHz timings
+        mww 0x40028134 0x00FFFFFF
+        mww 0x4002802C 0x00000008
+
+        mww 0x31080000 1
+        mww 0x31080008 0
+        mww 0x40004068 0x1C000
+        mww 0x31080028 0x11
+        
+        mww 0x31080400 0
+        mww 0x31080440 0
+        mww 0x31080460 0
+        mww 0x31080480 0
+
+        # Delays
+        mww 0x31080030 1
+        mww 0x31080034 6
+        mww 0x31080038 10
+        mww 0x31080044 1
+        mww 0x31080048 9
+        mww 0x3108004C 12
+        mww 0x31080050 10
+        mww 0x31080054 1
+        mww 0x31080058 1
+        mww 0x3108005C 0
+        
+        mww 0x31080100 0x5680
+        mww 0x31080104 0x302
+
+        # Init sequence
+        mww 0x31080020 0x193
+        sleep 1 busy
+        mww 0x31080024 1
+        mww 0x31080020 0x113
+        sleep 1 busy
+        mww 0x31080020 0x013
+        sleep 1 busy
+        mww 0x31080024 65
+        mww 0x31080020 0x093
+        mdw 0x80020000
+        mww 0x31080020 0x013
+
+        # SYS_CTRL remapping
+        mww 0x40004014 1
+}
diff --git a/tcl/target/lpc3250.cfg b/tcl/target/lpc3250.cfg
new file mode 100644
index 0000000..e902fb4
--- /dev/null
+++ b/tcl/target/lpc3250.cfg
@@ -0,0 +1,36 @@
+# lpc3250 config
+#
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME lpc3250
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+   set _CPUTAPID 0x17900f0f
+}
+
+if { [info exists SJCTAPID ] } {
+   set _SJCTAPID $SJCTAPID
+} else {
+   set _SJCTAPID 0x1b900f0f
+}
+
+jtag newtap $_CHIPNAME sjc -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_SJCTAPID
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm926ejs -endian little -chain-position $_TARGETNAME -work-area-phys 0x00000000 -work-area-size 0x7d0000 -work-area-backup 0
+
+proc power_restore {} { puts "Sensed power restore. No action." }
+proc srst_deasserted {} { puts "Sensed nSRST deasserted. No action." }

-----------------------------------------------------------------------

Summary of changes:
 tcl/board/phytec_lpc3250.cfg |   88 ++++++++++++++++++++++++++++++++++++++++++
 tcl/target/lpc3250.cfg       |   36 +++++++++++++++++
 2 files changed, 124 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/phytec_lpc3250.cfg
 create mode 100644 tcl/target/lpc3250.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Thu Feb  4 12:14:40 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Thu,  4 Feb 2010 11:14:40 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-178-g709f08f
Message-ID: <E1NczfV-0000ah-N8@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  709f08f17ad5128b86966365510dbe8f67736304 (commit)
      from  8b049fdba52459d54f63d39ae7b30abeef911e2b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 709f08f17ad5128b86966365510dbe8f67736304
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Feb 4 10:33:33 2010 +0000

    CMD: duplicate cmd error msg
    
    When registering cmds we report duplicate attempts to register a cmd
    as a LOG_ERROR.
    Some situations need this, such as when registering dual flash banks.
    http://www.mail-archive.com/openocd-development at lists.berlios.de/msg11152.html
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/helper/command.c b/src/helper/command.c
index ebd9aa6..3625508 100644
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -375,7 +375,10 @@ struct command* register_command(struct command_context *context,
 	struct command *c = command_find(*head, name);
 	if (NULL != c)
 	{
-		LOG_ERROR("command '%s' is already registered in '%s' context",
+		/* TODO: originally we treated attempting to register a cmd twice as an error
+		 * Sometimes we need this behaviour, such as with flash banks.
+		 * http://www.mail-archive.com/openocd-development at lists.berlios.de/msg11152.html */
+		LOG_DEBUG("command '%s' is already registered in '%s' context",
 				name, parent ? parent->name : "<global>");
 		return c;
 	}

-----------------------------------------------------------------------

Summary of changes:
 src/helper/command.c |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Feb  4 20:11:26 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu,  4 Feb 2010 19:11:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-180-g3ea9e62
Message-ID: <E1Nd76w-0008Ve-6W@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3ea9e62189205cfa84a04ec6955aaf1f5184a937 (commit)
       via  e380930478a45cc78de6b807dc6f17d0a61298b4 (commit)
      from  709f08f17ad5128b86966365510dbe8f67736304 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3ea9e62189205cfa84a04ec6955aaf1f5184a937
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Feb 4 11:10:15 2010 -0800

    Documentation: mention bug database
    
    Have the User's Guide and BUG handling notes both reference
    the fact that we now have a bug database at SourceForge.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/BUGS b/BUGS
index 36a7da3..5e640e7 100644
--- a/BUGS
+++ b/BUGS
@@ -6,6 +6,12 @@ posting a message with your report:
 
 	openocd-development at lists.berlios.de
 
+Also, please check the Trac bug database to see if a ticket for
+the bug has already been opened.  You might be asked to open
+such a ticket, or to update an existing ticket with more data.
+
+	https://sourceforge.net/apps/trac/openocd/
+
 To minimize work for OpenOCD developers, you should try to include
 all of the information listed below.  If you feel that some of the
 items below are unnecessary for a clear bug report, you may leave
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 957c79c..d4e60a8 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -60,7 +60,7 @@ Free Documentation License''.
 
 @menu
 * About::                            About OpenOCD
-* Developers::                       OpenOCD Developers
+* Developers::                       OpenOCD Developer Resources
 * JTAG Hardware Dongles::            JTAG Hardware Dongles
 * About JIM-Tcl::                    About JIM-Tcl
 * Running::                          Running OpenOCD
@@ -226,6 +226,13 @@ Discuss and submit patches to this list.
 The @file{PATCHES.txt} file contains basic information about how
 to prepare patches.
 
+ at section OpenOCD Bug Database
+
+During the 0.4.x release cycle the OpenOCD project team began
+using Trac for its bug database:
+
+ at uref{https://sourceforge.net/apps/trac/openocd}
+
 
 @node JTAG Hardware Dongles
 @chapter JTAG Hardware Dongles

commit e380930478a45cc78de6b807dc6f17d0a61298b4
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Feb 4 10:50:24 2010 -0800

    JLink: reference protocol documentation
    
    Segger publishes some documentation on this protocol;
    reference it, so future maintainers can know it exists.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 6596849..f22ad7c 100644
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -29,6 +29,10 @@
 #include <jtag/commands.h>
 #include "usb_common.h"
 
+/* See Segger's public documentation:
+ *	Reference manual for J-Link USB Protocol
+ *	Document RM08001-R6 Date: June 16, 2009
+ */
 
 #define VID 0x1366
 #define PID 0x0101

-----------------------------------------------------------------------

Summary of changes:
 BUGS                     |    6 ++++++
 doc/openocd.texi         |    9 ++++++++-
 src/jtag/drivers/jlink.c |    4 ++++
 3 files changed, 18 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Fri Feb  5 01:47:51 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Fri,  5 Feb 2010 00:47:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-181-gff5deee
Message-ID: <E1NdCMU-0000bd-Qn@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ff5deeeeaa4f394931e3c5ccfb4cfd33beda0743 (commit)
      from  3ea9e62189205cfa84a04ec6955aaf1f5184a937 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ff5deeeeaa4f394931e3c5ccfb4cfd33beda0743
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Thu Feb 4 14:39:51 2010 -0800

    ARMv7-M: make DAP commands verify target is an ARMv7-M
    
    Init the ARMv7-M magic number.  Define predicate verifying it.
    Use it to resolve a lurking bug/FIXME:  make sure the ARMv7-M
    specific DAP ops reject non-ARMv7-M targets.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index edfcdf9..9fe705a 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -538,7 +538,7 @@ struct reg_cache *armv7m_build_reg_cache(struct target *target)
 /** Sets up target as a generic ARMv7-M core */
 int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m)
 {
-	/* register arch-specific functions */
+	armv7m->common_magic = ARMV7M_COMMON_MAGIC;
 
 	target->arch_info = armv7m;
 	armv7m->read_core_reg = armv7m_read_core_reg;
@@ -737,8 +737,6 @@ int armv7m_maybe_skip_bkpt_inst(struct target *target, bool *inst_found)
 /*
  * Only stuff below this line should need to verify that its target
  * is an ARMv7-M node.
- *
- * FIXME yet none of it _does_ verify target types yet!
  */
 
 
@@ -752,6 +750,11 @@ COMMAND_HANDLER(handle_dap_baseaddr_command)
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 
+	if (!is_armv7m(armv7m)) {
+		command_print(CMD_CTX, "current target isn't an ARM7-M");
+		return ERROR_TARGET_INVALID;
+	}
+
 	return CALL_COMMAND_HANDLER(dap_baseaddr_command, swjdp);
 }
 
@@ -765,6 +768,11 @@ COMMAND_HANDLER(handle_dap_apid_command)
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 
+	if (!is_armv7m(armv7m)) {
+		command_print(CMD_CTX, "current target isn't an ARM7-M");
+		return ERROR_TARGET_INVALID;
+	}
+
 	return CALL_COMMAND_HANDLER(dap_apid_command, swjdp);
 }
 
@@ -774,6 +782,11 @@ COMMAND_HANDLER(handle_dap_apsel_command)
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 
+	if (!is_armv7m(armv7m)) {
+		command_print(CMD_CTX, "current target isn't an ARM7-M");
+		return ERROR_TARGET_INVALID;
+	}
+
 	return CALL_COMMAND_HANDLER(dap_apsel_command, swjdp);
 }
 
@@ -783,6 +796,11 @@ COMMAND_HANDLER(handle_dap_memaccess_command)
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 
+	if (!is_armv7m(armv7m)) {
+		command_print(CMD_CTX, "current target isn't an ARM7-M");
+		return ERROR_TARGET_INVALID;
+	}
+
 	return CALL_COMMAND_HANDLER(dap_memaccess_command, swjdp);
 }
 
@@ -794,6 +812,11 @@ COMMAND_HANDLER(handle_dap_info_command)
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 	uint32_t apsel;
 
+	if (!is_armv7m(armv7m)) {
+		command_print(CMD_CTX, "current target isn't an ARM7-M");
+		return ERROR_TARGET_INVALID;
+	}
+
 	switch (CMD_ARGC) {
 	case 0:
 		apsel = swjdp->apsel;
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 9787e30..b6be1d2 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -131,6 +131,11 @@ target_to_armv7m(struct target *target)
 	return target->arch_info;
 }
 
+static inline bool is_armv7m(struct armv7m_common *armv7m)
+{
+	return armv7m->common_magic == ARMV7M_COMMON_MAGIC;
+}
+
 struct armv7m_algorithm
 {
 	int common_magic;

-----------------------------------------------------------------------

Summary of changes:
 src/target/armv7m.c |   29 ++++++++++++++++++++++++++---
 src/target/armv7m.h |    5 +++++
 2 files changed, 31 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb  5 14:37:23 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri,  5 Feb 2010 13:37:23 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-182-g41d0901
Message-ID: <E1NdONA-0001xE-N6@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  41d0901115903cb02b42249690b33cf616e133b5 (commit)
      from  ff5deeeeaa4f394931e3c5ccfb4cfd33beda0743 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 41d0901115903cb02b42249690b33cf616e133b5
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Feb 5 14:38:26 2010 +0100

    zy1000: complete zy1000_uart to jim command switch
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/ecosboard.c b/src/ecosboard.c
index 2e73585..f752354 100644
--- a/src/ecosboard.c
+++ b/src/ecosboard.c
@@ -847,7 +847,7 @@ static int zylinjtag_Jim_Command_uart(Jim_Interp *interp, int argc,
 	static int current_baud = 38400;
 	if (argc == 1)
 	{
-		command_print(cmd_ctx, "%d", current_baud);
+		Jim_SetResult(interp, Jim_NewIntObj(interp, current_baud));
 		return JIM_OK;
 	}
 	else if (argc != 2)
@@ -883,8 +883,8 @@ static int zylinjtag_Jim_Command_uart(Jim_Interp *interp, int argc,
 		baud = CYGNUM_SERIAL_BAUD_230400;
 		break;
 	default:
-		command_print(cmd_ctx, "unsupported baudrate");
-		return ERROR_INVALID_ARGUMENTS;
+		Jim_SetResult(interp, Jim_NewStringObj(interp, "unsupported baudrate", -1));
+		return JIM_ERR;
 	}
 
 	cyg_serial_info_t buf;
@@ -897,7 +897,7 @@ static int zylinjtag_Jim_Command_uart(Jim_Interp *interp, int argc,
 	err = cyg_io_lookup(ZY1000_SER_DEV, &serial_handle);
 	if (err != ENOERR)
 	{
-		LOG_ERROR("Could not open serial port\n");
+		Jim_SetResult(interp, Jim_NewStringObj(interp, "Could not open serial port", -1));
 		return JIM_ERR;
 	}
 
@@ -907,7 +907,7 @@ static int zylinjtag_Jim_Command_uart(Jim_Interp *interp, int argc,
 			&len);
 	if (err != ENOERR)
 	{
-		LOG_ERROR("Failed to get serial port settings %d", err);
+		Jim_SetResult(interp, Jim_NewStringObj(interp, "Failed to get serial port settings", -1));
 		return JIM_ERR;
 	}
 	buf.baud = baud;
@@ -916,7 +916,7 @@ static int zylinjtag_Jim_Command_uart(Jim_Interp *interp, int argc,
 			&len);
 	if (err != ENOERR)
 	{
-		LOG_ERROR("Failed to set serial port settings %d", err);
+		Jim_SetResult(interp, Jim_NewStringObj(interp, "Failed to set serial port settings", -1));
 		return JIM_ERR;
 	}
 

-----------------------------------------------------------------------

Summary of changes:
 src/ecosboard.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb  7 05:00:34 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun,  7 Feb 2010 04:00:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-184-g885a2f5
Message-ID: <E1NdyK4-0006QK-J3@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  885a2f5b96697e3aca9a5b9deb855d6d025c5021 (commit)
       via  6f262b69f407e5982be9858d66b5dda6835a2e28 (commit)
      from  41d0901115903cb02b42249690b33cf616e133b5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 885a2f5b96697e3aca9a5b9deb855d6d025c5021
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 6 19:19:25 2010 -0800

    Re-title Developer's Guide
    
    The Doxygen output was previously titled "OpenOCD Reference Manual",
    which was quite misleading ... the User's Guide is the reference
    manual which folk should consult about how to use the software.
    
    Just rename it to match how it's been discussed previously, and to
    bring out its intended audience:  developers of this software.  As a
    rule, Doxygen is only for folk who work with the code it documents.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/manual/main.txt b/doc/manual/main.txt
index 8e76464..2b6e7e1 100644
--- a/doc/manual/main.txt
+++ b/doc/manual/main.txt
@@ -1,6 +1,6 @@
-/** @mainpage OpenOCD Reference Manual
+/** @mainpage OpenOCD Developer's Guide
 
-Welcome to the OpenOCD Reference Manual -- the developer's resource for
+Welcome to the OpenOCD Developer's Guide -- the developer's resource for
 learning about the internal architecture of the OpenOCD project. @par
 
 In addition, this document contains the tactical and strategic plans

commit 6f262b69f407e5982be9858d66b5dda6835a2e28
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 6 19:16:21 2010 -0800

    ADIv5: doxygen
    
    Provide doxygen for many of the public ADIv5 interfaces (i.e. the ones
    called from Cortex core support code).
    
    Add FIXMEs (and a TODO) to help resolve implementation issues which
    became more apparent when trying to document this code:
    
     - Error-prone context-sensitivity (queued/nonqueued) in many procedures.
    
     - Procedures that lie by ignoring errors and wrongly claiming success.
    
    Also, there was no point in a return from dap_ap_select(); it can't fail,
    and no caller checks its return status.  Clean that up, make it void.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 4089567..94c8ed8 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -42,6 +42,12 @@
  * use either SWD or JTAG, and is called SWJ-DP.  The most common type of AP
  * is used to access memory mapped resources and is called a MEM-AP.  Also a
  * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
+ *
+ * @todo Remove modality (queued/nonqueued, via DAP trans_mode) from all
+ * procedure interfaces.  Modal programming interfaces are very error prone.
+ * Procedures should be either queued, or synchronous.  Otherwise input
+ * and output constraints are context-sensitive, and it's hard to know
+ * what a block of code will do just by reading it.
  */
 
 /*
@@ -402,7 +408,16 @@ static int dap_dp_read_reg(struct swjdp_common *swjdp,
 			reg_addr, DPAP_READ, 0, value);
 }
 
-int dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
+/**
+ * Select one of the APs connected to the specified DAP.  The
+ * selection is implicitly used with future AP transactions.
+ * This is a NOP if the specified AP is already selected.
+ *
+ * @param swjdp The DAP
+ * @param apsel Number of the AP to (implicitly) use with further
+ *	transactions.  This normally identifies a MEM-AP.
+ */
+void dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
 {
 	uint32_t select;
 	select = (apsel << 24) & 0xFF000000;
@@ -415,8 +430,6 @@ int dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
 		swjdp->ap_csw_value = -1;
 		swjdp->ap_tar_value = -1;
 	}
-
-	return ERROR_OK;
 }
 
 static int dap_dp_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
@@ -430,6 +443,7 @@ static int dap_dp_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 		swjdp->dp_select_value = select;
 	}
 
+	/* FIXME return any fault code from write() call */
 	return ERROR_OK;
 }
 
@@ -440,10 +454,25 @@ static int dap_ap_write_reg(struct swjdp_common *swjdp,
 	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_WRITE, out_value_buf, NULL);
 
+	/* FIXME return fault code from above calls */
 	return ERROR_OK;
 }
 
-int dap_ap_write_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t value)
+/**
+ * Write an AP register value.
+ * This is synchronous iff the mode is set to ATOMIC, in which
+ * case any queued transactions are flushed.
+ *
+ * @param swjdp The DAP whose currently selected AP will be written.
+ * @param reg_addr Eight bit AP register address.
+ * @param value Word to be written at reg_addr
+ *
+ * @return In synchronous mode: ERROR_OK for success, and the register holds
+ * the specified value; else a fault code.  In asynchronous mode, a status
+ * code reflecting whether the transaction was properly queued.
+ */
+int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
+		uint32_t reg_addr, uint32_t value)
 {
 	uint8_t out_value_buf[4];
 
@@ -452,20 +481,39 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t
 	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_WRITE, out_value_buf, NULL);
 
+	/* FIXME return any fault code from above calls */
 	return ERROR_OK;
 }
 
-int dap_ap_read_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t *value)
+/**
+ * Read an AP register value.
+ * This is synchronous iff the mode is set to ATOMIC, in which
+ * case any queued transactions are flushed.
+ *
+ * @param swjdp The DAP whose currently selected AP will be read.
+ * @param reg_addr Eight bit AP register address.
+ * @param value Points to where the 32-bit (little-endian) word will be stored.
+ *
+ * @return In synchronous mode: ERROR_OK for success, and *value holds
+ * the specified value; else a fault code.  In asynchronous mode, a status
+ * code reflecting whether the transaction was properly queued.
+ */
+int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
+		uint32_t reg_addr, uint32_t *value)
 {
 	dap_dp_bankselect(swjdp, reg_addr);
 	scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_READ, 0, value);
 
+	/* FIXME return any fault code from above calls */
 	return ERROR_OK;
 }
 
 /**
  * Set up transfer parameters for the currently selected MEM-AP.
+ * This is synchronous iff the mode is set to ATOMIC, in which
+ * case any queued transactions are flushed.
+ *
  * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
  * initiate data reads or writes using memory or peripheral addresses.
  * If the CSW is configured for it, the TAR may be automatically
@@ -478,6 +526,10 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp, uint32_t reg_addr, uint32_t
  *	matches the cached value, the register is not changed.
  * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
  *	matches the cached address, the register is not changed.
+ *
+ * @return In synchronous mode: ERROR_OK for success, and the AP is set
+ * up as requested else a fault code.  In asynchronous mode, a status
+ * code reflecting whether the transaction was properly queued.
  */
 int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 {
@@ -485,12 +537,14 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 	if (csw != swjdp->ap_csw_value)
 	{
 		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
+		/* FIXME if this call fails, fail this procedure! */
 		dap_ap_write_reg_u32(swjdp, AP_REG_CSW, csw);
 		swjdp->ap_csw_value = csw;
 	}
 	if (tar != swjdp->ap_tar_value)
 	{
 		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
+		/* FIXME if this call fails, fail this procedure! */
 		dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar);
 		swjdp->ap_tar_value = tar;
 	}
@@ -500,51 +554,97 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 	return ERROR_OK;
 }
 
-/*****************************************************************************
-*                                                                            *
-* mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t *value)      *
-*                                                                            *
-* Read a uint32_t value from memory or system register                            *
-* Functionally equivalent to target_read_u32(target, address, uint32_t *value),   *
-* but with less overhead                                                     *
-*****************************************************************************/
-int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t *value)
+/**
+ * Asynchronous (queued) read of a word from memory or a system register.
+ *
+ * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param address Address of the 32-bit word to read; it must be
+ *	readable by the currently selected MEM-AP.
+ * @param value points to where the word will be stored when the
+ *	transaction queue is flushed (assuming no errors).
+ *
+ * @return ERROR_OK for success.  Otherwise a fault code.
+ */
+int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
+		uint32_t *value)
 {
 	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
 
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, address & 0xFFFFFFF0);
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when reading several consecutive addresses.
+	 */
+	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+			address & 0xFFFFFFF0);
 	dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC), value);
 
+	/* FIXME return any fault code from above calls */
 	return ERROR_OK;
 }
 
-int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t *value)
+/**
+ * Synchronous read of a word from memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param swjdp The DAP connected to the MEM-AP performing the read.
+ * @param address Address of the 32-bit word to read; it must be
+ *	readable by the currently selected MEM-AP.
+ * @param value points to where the result will be stored.
+ *
+ * @return ERROR_OK for success; *value holds the result.
+ * Otherwise a fault code.
+ */
+int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
+		uint32_t *value)
 {
 	mem_ap_read_u32(swjdp, address, value);
+	/* FIXME return any fault code from above call */
 
 	return jtagdp_transaction_endcheck(swjdp);
 }
 
-/*****************************************************************************
-*                                                                            *
-* mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t value)      *
-*                                                                            *
-* Write a uint32_t value to memory or memory mapped register                              *
-*                                                                            *
-*****************************************************************************/
-int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t value)
+/**
+ * Asynchronous (queued) write of a word to memory or a system register.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param address Address to be written; it must be writable by
+ *	the currently selected MEM-AP.
+ * @param value Word that will be written to the address when transaction
+ *	queue is flushed (assuming no errors).
+ *
+ * @return ERROR_OK for success.  Otherwise a fault code.
+ */
+int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
+		uint32_t value)
 {
 	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
 
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, address & 0xFFFFFFF0);
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when writing several consecutive addresses.
+	 */
+	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+			address & 0xFFFFFFF0);
 	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC), value);
 
+	/* FIXME return any fault code from above calls */
 	return ERROR_OK;
 }
 
-int mem_ap_write_atomic_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t value)
+/**
+ * Synchronous write of a word to memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param address Address to be written; it must be writable by
+ *	the currently selected MEM-AP.
+ * @param value Word that will be written.
+ *
+ * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
+ */
+int mem_ap_write_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
+		uint32_t value)
 {
 	mem_ap_write_u32(swjdp, address, value);
+	/* FIXME return any fault code from above call */
 
 	return jtagdp_transaction_endcheck(swjdp);
 }
@@ -1083,7 +1183,11 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, u
 }
 
 /**
- * Initialize a DAP.
+ * Initialize a DAP.  This sets up the power domains, prepares the DP
+ * for further use, and arranges to use AP #0 for all AP operations
+ * until dap_ap-select() changes that policy.
+ *
+ * @param swjdp The DAP being initialized.
  *
  * @todo Rename this.  We also need an initialization scheme which account
  * for SWD transports not just JTAG; that will need to address differences
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index a807027..759f233 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -155,16 +155,18 @@ struct swjdp_common
 
 };
 
-/* Accessor function for currently selected DAP-AP number */
+/** Accessor for currently selected DAP-AP number (0..255) */
 static inline uint8_t dap_ap_get_select(struct swjdp_common *swjdp)
 {
 	return (uint8_t)(swjdp ->apsel >> 24);
 }
 
-/* Queued transactions -- use with care */
+/* AP selection applies to future AP transactions */
+void dap_ap_select(struct swjdp_common *dap,uint8_t apsel);
+
+/* AP transactions ... synchronous given TRANS_MODE_ATOMIC */
 int dap_setup_accessport(struct swjdp_common *swjdp,
 		uint32_t csw, uint32_t tar);
-int dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel);
 int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 		uint32_t addr, uint32_t value);
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
@@ -173,11 +175,11 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 /* Queued JTAG ops must be completed with jtagdp_transaction_endcheck() */
 int jtagdp_transaction_endcheck(struct swjdp_common *swjdp);
 
-/* MEM-AP memory mapped bus single uint32_t register transfers, without endcheck */
+/* Queued MEM-AP memory mapped single word transfers */
 int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t *value);
 int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address, uint32_t value);
 
-/* MEM-AP memory mapped bus transfers, single registers, complete transactions */
+/* Synchronous MEM-AP memory mapped single word transfers */
 int mem_ap_read_atomic_u32(struct swjdp_common *swjdp,
 		uint32_t address, uint32_t *value);
 int mem_ap_write_atomic_u32(struct swjdp_common *swjdp,

-----------------------------------------------------------------------

Summary of changes:
 doc/manual/main.txt     |    4 +-
 src/target/arm_adi_v5.c |  158 +++++++++++++++++++++++++++++++++++++++--------
 src/target/arm_adi_v5.h |   12 ++--
 3 files changed, 140 insertions(+), 34 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Tue Feb  9 16:08:08 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Tue,  9 Feb 2010 15:08:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-185-gf899c2a
Message-ID: <E1NerhD-0008He-CO@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f899c2aa9767ba7bf731e6c6c1af2c437af97dac (commit)
      from  885a2f5b96697e3aca9a5b9deb855d6d025c5021 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f899c2aa9767ba7bf731e6c6c1af2c437af97dac
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Tue Feb 9 14:49:47 2010 +0000

    str730.cfg: fix incorrect mem regions
    
     - update str73x mem regions to correct values.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/tcl/target/str730.cfg b/tcl/target/str730.cfg
index cab2338..0917953 100644
--- a/tcl/target/str730.cfg
+++ b/tcl/target/str730.cfg
@@ -46,9 +46,9 @@ $_TARGETNAME configure -event gdb-flash-erase-start {
 	flash protect 0 0 7 off
 }
 
-$_TARGETNAME configure -work-area-phys 0x40000000 -work-area-size 0x4000 -work-area-backup 0
+$_TARGETNAME configure -work-area-phys 0xA0000000 -work-area-size 0x4000 -work-area-backup 0
 
 #flash bank <driver> <base> <size> <chip_width> <bus_width>
 set _FLASHNAME $_CHIPNAME.flash
-flash bank $_FLASHNAME str7x 0x20000000 0x00040000 0 0 $_TARGETNAME STR3x
+flash bank $_FLASHNAME str7x 0x80000000 0x00040000 0 0 $_TARGETNAME STR3x
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/str730.cfg |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Tue Feb  9 21:58:06 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Tue,  9 Feb 2010 20:58:06 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-186-gc646b76
Message-ID: <E1Nex9r-0005Z1-W7@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c646b767971f5750b32f0bc8290a2eea351cb514 (commit)
      from  f899c2aa9767ba7bf731e6c6c1af2c437af97dac (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c646b767971f5750b32f0bc8290a2eea351cb514
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Feb 9 21:54:55 2010 +0100

    target: add todo in target_write_memory() about alignment
    
    target_write_buffer() does not align "buffer" in host
    memory passed to target_write_memory().
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/target.h b/src/target/target.h
index da91d46..7400b7e 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -2,7 +2,7 @@
  *   Copyright (C) 2005 by Dominic Rath                                    *
  *   Dominic.Rath at gmx.de                                                   *
  *                                                                         *
- *   Copyright (C) 2007-9 ??yvind Harboe                                    *
+ *   Copyright (C) 2007-2010 ??yvind Harboe                                 *
  *   oyvind.harboe at zylin.com                                               *
  *                                                                         *
  *   Copyright (C) 2008 by Spencer Oliver                                  *
@@ -371,7 +371,18 @@ int target_read_memory(struct target *target,
 		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 /**
  * Write @a count items of @a size bytes to the memory of @a target at
- * the @a address given.
+ * the @a address given. @a address must be aligned to @a size
+ * in target memory.
+ *
+ * The endianness is the same in the host and target memory for this
+ * function.
+ *
+ * \todo TODO:
+ * Really @a buffer should have been defined as "const void *" and
+ * @a buffer should have been aligned to @a size in the host memory.
+ *
+ * This is not enforced via e.g. assert's today and e.g. the
+ * target_write_buffer fn breaks this assumption.
  *
  * This routine is wrapper for target->type->write_memory.
  */

-----------------------------------------------------------------------

Summary of changes:
 src/target/target.h |   15 +++++++++++++--
 1 files changed, 13 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Feb 10 20:30:20 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 10 Feb 2010 19:30:20 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-187-g84ac6bb
Message-ID: <E1NfIGT-0005kN-BB@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  84ac6bb0d99275ccf7ff15691ffa1b22127d7339 (commit)
      from  c646b767971f5750b32f0bc8290a2eea351cb514 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 84ac6bb0d99275ccf7ff15691ffa1b22127d7339
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Feb 10 11:27:48 2010 -0800

    User's Guide: clarify jtag_rclk advice
    
    Not all cores and boards support adaptive clocking, so qualify
    all advice to use it to depend on core and board support.
    
    It's primarily ARM cores which support this; and many of the
    newer ones (like Cortex-M series) don't.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index d4e60a8..c1c49a8 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -1447,7 +1447,8 @@ Adaptive clocking provides a partial workaround, but a more complete
 solution just avoids using that instruction with JTAG debuggers.
 @end quotation
 
-If the board supports adaptive clocking, use the @command{jtag_rclk}
+If both the chip and the board support adaptive clocking,
+use the @command{jtag_rclk}
 command, in case your board is used with JTAG adapter which
 also supports it.  Otherwise use @command{jtag_khz}.
 Set the slow rate at the beginning of the reset sequence,
@@ -2387,7 +2388,8 @@ However, it introduces delays to synchronize clocks; so it
 may not be the fastest solution.
 
 @b{NOTE:} Script writers should consider using @command{jtag_rclk}
-instead of @command{jtag_khz}.
+instead of @command{jtag_khz}, but only for (ARM) cores and boards
+which support adaptive clocking.
 
 @deffn {Command} jtag_khz max_speed_kHz
 A non-zero speed is in KHZ. Hence: 3000 is 3mhz.

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |    6 ++++--
 1 files changed, 4 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Wed Feb 10 22:55:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Wed, 10 Feb 2010 21:55:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-188-g65cc81d
Message-ID: <E1NfKX9-0000oC-7k@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  65cc81ddb609456707c2ba47cfe8540192c6dce7 (commit)
      from  84ac6bb0d99275ccf7ff15691ffa1b22127d7339 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 65cc81ddb609456707c2ba47cfe8540192c6dce7
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Wed Feb 10 20:04:00 2010 +0100

    arm11: fix another infinite loop bug
    
    reset init would get stuck in an infinite loop when
    e.g. khz was too high. Added timeout. This is a copy
    of paste of a number of such bugfixes in the arm11
    code.
    
    Arm11 code reviewed for further such infinite loop bugs
    and I couldn't find any more. Xing fingers it's the last
    one...
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 088981f..6d132a7 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -854,7 +854,9 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 			AddressOut	= 0;
 		}
 
-		do
+		/* Timeout here so we don't get stuck. */
+		int i = 0;
+		while (1)
 		{
 			JTAG_DEBUG("SC7 <= c%-3d Data %08x %s",
 					(unsigned) AddressOut,
@@ -866,10 +868,27 @@ int arm11_sc7_run(struct arm11_common * arm11, struct arm11_sc7_action * actions
 
 			CHECK_RETVAL(jtag_execute_queue());
 
-			if (!Ready)
-				JTAG_DEBUG("SC7 => !ready");
+			/* 'nRW' is 'Ready' on read out */
+			if (Ready)
+				break;
+
+			long long then = 0;
+
+			if (i == 1000)
+			{
+				then = timeval_ms();
+			}
+			if (i >= 1000)
+			{
+				if ((timeval_ms()-then) > 1000)
+				{
+					LOG_WARNING("Timeout (1000ms) waiting for instructions to complete");
+					return ERROR_FAIL;
+				}
+			}
+
+			i++;
 		}
-		while (!Ready); /* 'nRW' is 'Ready' on read out */
 
 		if (!nRW)
 			JTAG_DEBUG("SC7 => Data %08x", (unsigned) DataIn);

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11_dbgtap.c |   27 +++++++++++++++++++++++----
 1 files changed, 23 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Feb 11 01:54:35 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 11 Feb 2010 00:54:35 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-189-g527e073
Message-ID: <E1NfNKI-0005cM-PB@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  527e073bba3145235534a9273e85a714bf87f330 (commit)
      from  65cc81ddb609456707c2ba47cfe8540192c6dce7 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 527e073bba3145235534a9273e85a714bf87f330
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Feb 10 16:42:37 2010 -0800

    User's Guide: "#" in filesystems names is bad
    
    Sometimes MS-Windows users try to use filesystem names which include
    the "#" character.  That's generally unwise, since it begins Tcl
    comments.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index c1c49a8..63b6ab0 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -539,6 +539,11 @@ Configuration files and scripts are searched for in
 @end enumerate
 The first found file with a matching file name will be used.
 
+ at quotation Note
+Don't try to use configuration script names or paths which
+include the "#" character.  That character begins Tcl comments.  
+ at end quotation
+
 @section Simple setup, no customization
 
 In the best case, you can use two scripts from one of the script
@@ -7633,12 +7638,15 @@ in the same basic way.
 @* Example: @b{ source [find FILENAME] }
 @*Remember the parsing rules
 @enumerate
- at item The FIND command is in square brackets.
-@* The FIND command is executed with the parameter FILENAME. It should
-find the full path to the named file. The RESULT is a string, which is
-substituted on the orginal command line.
- at item The command source is executed with the resulting filename.
-@* SOURCE reads a file and executes as a script.
+ at item The @command{find} command is in square brackets,
+and is executed with the parameter FILENAME. It should find and return
+the full path to a file with that name; it uses an internal search path.
+The RESULT is a string, which is substituted into the command line in
+place of the bracketed @command{find} command.
+(Don't try to use a FILENAME which includes the "#" character.
+That character begins Tcl comments.)
+ at item The @command{source} command is executed with the resulting filename;
+it reads a file and executes as a script.
 @end enumerate
 @subsection format command
 @b{Where:} Generally occurs in numerous places.

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi |   20 ++++++++++++++------
 1 files changed, 14 insertions(+), 6 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Thu Feb 11 21:11:14 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Thu, 11 Feb 2010 20:11:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-190-g32188c5
Message-ID: <E1NffNd-0003pM-1X@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  32188c500468c117d2a79106ba9ae41d61ce1897 (commit)
      from  527e073bba3145235534a9273e85a714bf87f330 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 32188c500468c117d2a79106ba9ae41d61ce1897
Author: Viktar Palstsiuk <viktar.palstsiuk at promwad.com>
Date:   Thu Feb 11 21:09:21 2010 +0100

    target library: configuration files for openocd tested with Atmel SAM-ICE V6 JTAG.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/tcl/board/atmel_at91sam9rl-ek.cfg b/tcl/board/atmel_at91sam9rl-ek.cfg
new file mode 100644
index 0000000..3b932bf
--- /dev/null
+++ b/tcl/board/atmel_at91sam9rl-ek.cfg
@@ -0,0 +1,75 @@
+################################################################################
+#
+# Generated for Atmel AT91SAM9RL-EK evaluation board using Atmel SAM-ICE (J-Link) V6
+#
+# Atmel AT91SAM9RL : PLL = 200 MHz, MCK = 100 MHz
+#                     OSCSEL configured for external 32.768 kHz crystal
+#
+# 32-bit SDRAM : 2 x Micron MT48LC16M16A2, 4M x 16Bit x 4 Banks
+#
+################################################################################
+
+# We add to the minimal configuration.
+source [find target/at91sam9rl.cfg]
+
+$_TARGETNAME configure -event reset-start {
+        # At reset CPU runs at 32.768 kHz.
+        # JTAG Frequency must be 6 times slower if RCLK is not supported.
+        jtag_rclk 5
+        halt
+        # RSTC_MR : enable user reset, MMU may be enabled... use physical address
+        mww phys 0xfffffd08 0xa5000501
+}
+
+$_TARGETNAME configure -event reset-init {
+        mww 0xfffffd44 0x00008000         # WDT_MR : disable watchdog
+
+	mww 0xfffffc20 0x00004001         # CKGR_MOR : enable the main oscillator
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000001         # PMC_MCKR : switch to main oscillator
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc28 0x2031bf03         # CKGR_PLLR: Set PLL Register for 200 MHz
+        sleep 20                          # wait 20 ms
+        mww 0xfffffc30 0x00000101         # PMC_MCKR : Select prescaler (divide by 2)
+        sleep 10                          # wait 10 ms
+        mww 0xfffffc30 0x00000102         # PMC_MCKR : Clock from PLL is selected (100 MHz)
+        sleep 10                          # wait 10 ms
+
+	# Increase JTAG Speed to 6 MHz if RCLK is not supported
+        jtag_rclk 6000
+
+	arm7_9 dcc_downloads enable       # Enable faster DCC downloads
+
+	mww 0xfffff670 0xffff0000         # PIO_ASR  : Select peripheral function for D16..D31 (PIOB)
+        mww 0xfffff604 0xffff0000         # PIO_PDR  : Disable PIO function for D16..D31 (PIOB)
+
+        mww 0xffffef20 0x00010002         # EBI_CSA  : Assign EBI Chip Select 1 to SDRAM, VDDIOMSEL set for +3V3 memory
+
+	mww 0xffffea08 0x85227259         # SDRAMC_CR : Configure SDRAM (2 x Micron MT48LC16M16A2 : 4M x 16Bit x 4 Banks)
+
+	mww 0xffffea00 0x1                # SDRAMC_MR : issue a NOP command
+	mww 0x20000000 0
+	mww 0xffffea00 0x2                # SDRAMC_MR : issue an 'All Banks Precharge' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4                # SDRAMC_MR : issue 8 x 'Auto-Refresh' Command
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x4
+	mww 0x20000000 0
+	mww 0xffffea00 0x3                # SDRAMC_MR : issue a 'Load Mode Register' command
+	mww 0x20000000 0
+	mww 0xffffea00 0x0                # SDRAMC_MR : normal mode
+	mww 0x20000000 0
+	mww 0xffffea04 0x2b6              # SDRAMC_TR : Set refresh timer count to 7us
+}
diff --git a/tcl/target/at91sam9rl.cfg b/tcl/target/at91sam9rl.cfg
new file mode 100644
index 0000000..6db1826
--- /dev/null
+++ b/tcl/target/at91sam9rl.cfg
@@ -0,0 +1,44 @@
+######################################
+# Target:    Atmel AT91SAM9RL
+######################################
+
+if { [info exists CHIPNAME] } {
+   set  _CHIPNAME $CHIPNAME
+} else {
+   set  _CHIPNAME at91sam9rl
+}
+
+if { [info exists ENDIAN] } {
+   set  _ENDIAN $ENDIAN
+} else {
+   set  _ENDIAN little
+}
+
+if { [info exists CPUTAPID ] } {
+   set _CPUTAPID $CPUTAPID
+} else {
+  # force an error till we get a good number
+   set _CPUTAPID 0x0792603f
+}
+
+reset_config trst_and_srst separate trst_push_pull srst_open_drain
+
+#
+jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
+
+jtag_nsrst_delay 300
+jtag_ntrst_delay 200
+
+jtag_rclk 3
+
+######################
+# Target configuration
+######################
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME -variant arm926ejs
+
+# Internal sram1 memory
+$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x10000 -work-area-backup 1
+
+

-----------------------------------------------------------------------

Summary of changes:
 ..._at91sam9260-ek.cfg => atmel_at91sam9rl-ek.cfg} |   22 +++++++------------
 tcl/target/{at91sam9260.cfg => at91sam9rl.cfg}     |    6 ++--
 2 files changed, 11 insertions(+), 17 deletions(-)
 copy tcl/board/{atmel_at91sam9260-ek.cfg => atmel_at91sam9rl-ek.cfg} (76%)
 copy tcl/target/{at91sam9260.cfg => at91sam9rl.cfg} (90%)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb 12 08:30:26 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 12 Feb 2010 07:30:26 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-191-gff404da
Message-ID: <E1Nfpyv-0005Ti-8G@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  ff404da1558f0dcc5d92b18caa1706b9edf067d1 (commit)
      from  32188c500468c117d2a79106ba9ae41d61ce1897 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit ff404da1558f0dcc5d92b18caa1706b9edf067d1
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Fri Feb 12 08:23:44 2010 +0100

    arm920: add virt2phys fn
    
    Copy of the 926ejs function. I have tested it only using
    my rtems application (where virtual address mapping == physical).
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index e0b1c70..e04d9fc 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -472,9 +472,19 @@ static int arm920_mmu(struct target *target, int *enabled)
 static int arm920_virt2phys(struct target *target,
 		uint32_t virt, uint32_t *phys)
 {
-	/** @todo Implement this!  */
-	LOG_ERROR("%s: not implemented", __func__);
-	return ERROR_FAIL;
+	int type;
+	uint32_t cb;
+	int domain;
+	uint32_t ap;
+	struct arm920t_common *arm920t = target_to_arm920(target);
+
+	uint32_t ret = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu, virt, &type, &cb, &domain, &ap);
+	if (type == -1)
+	{
+		return ret;
+	}
+	*phys = ret;
+	return ERROR_OK;
 }
 
 /** Reads a buffer, in the specified word size, with current MMU settings. */

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm920t.c |   16 +++++++++++++---
 1 files changed, 13 insertions(+), 3 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb 12 09:26:11 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 12 Feb 2010 08:26:11 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-192-gd4d4b11
Message-ID: <E1Nfqqt-00061v-5c@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d4d4b11a778c169a23a99f03e9d61f6bf21002c2 (commit)
      from  ff404da1558f0dcc5d92b18caa1706b9edf067d1 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d4d4b11a778c169a23a99f03e9d61f6bf21002c2
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Fri Feb 12 08:39:56 2010 +0100

    arm720t: virt2phys callback added
    
    This is a copy and paste of arm926ejs. Not tested, but
    ready for testing at least. There is a good chance that
    it will work if the generic armv4_5 fn's are robust enough...
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index a5dde2c..efafa5e 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -255,11 +255,21 @@ static int arm720_mmu(struct target *target, int *enabled)
 }
 
 static int arm720_virt2phys(struct target *target,
-		uint32_t virt, uint32_t *phys)
+		uint32_t virtual, uint32_t *physical)
 {
-	/** @todo Implement this!  */
-	LOG_ERROR("%s: not implemented", __func__);
-	return ERROR_FAIL;
+	int type;
+	uint32_t cb;
+	int domain;
+	uint32_t ap;
+	struct arm720t_common *arm720t = target_to_arm720(target);
+
+	uint32_t ret = armv4_5_mmu_translate_va(target, &arm720t->armv4_5_mmu, virtual, &type, &cb, &domain, &ap);
+	if (type == -1)
+	{
+		return ret;
+	}
+	*physical = ret;
+	return ERROR_OK;
 }
 
 static int arm720t_read_memory(struct target *target,

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm720t.c |   18 ++++++++++++++----
 1 files changed, 14 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From ntfreak at users.sourceforge.net  Fri Feb 12 11:49:50 2010
From: ntfreak at users.sourceforge.net (Spencer Oliver)
Date: Fri, 12 Feb 2010 10:49:50 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc1-194-gf7a6e62
Message-ID: <E1Nft5r-0007C8-B7@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  f7a6e6277681f6e2702bb9d3e0176000bd09a402 (commit)
       via  747a607aef6572dad8740b76596f2b72036b8685 (commit)
      from  d4d4b11a778c169a23a99f03e9d61f6bf21002c2 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit f7a6e6277681f6e2702bb9d3e0176000bd09a402
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Feb 11 20:56:32 2010 +0000

    STR9xpec: issue warning when unlocking device
    
    Issue warning to user when unlocking or writing the option bytes.
    The new settings will not take effect until a target reset.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index f0e11a5..243336a 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -915,6 +915,10 @@ COMMAND_HANDLER(str9xpec_handle_flash_options_write_command)
 	if ((status & ISC_STATUS_ERROR) != STR9XPEC_ISC_SUCCESS)
 		return ERROR_FLASH_OPERATION_FAILED;
 
+	command_print(CMD_CTX, "str9xpec write options complete.\n"
+			"INFO: a reset or power cycle is required "
+			"for the new settings to take effect.");
+
 	return ERROR_OK;
 }
 
@@ -1077,6 +1081,10 @@ COMMAND_HANDLER(str9xpec_handle_flash_unlock_command)
 	if ((status & ISC_STATUS_ERROR) != STR9XPEC_ISC_SUCCESS)
 		return ERROR_FLASH_OPERATION_FAILED;
 
+	command_print(CMD_CTX, "str9xpec unlocked.\n"
+			"INFO: a reset or power cycle is required "
+			"for the new settings to take effect.");
+
 	return ERROR_OK;
 }
 

commit 747a607aef6572dad8740b76596f2b72036b8685
Author: Spencer Oliver <ntfreak at users.sourceforge.net>
Date:   Thu Feb 11 20:55:31 2010 +0000

    STM32x: issue warning when unlocking device (bug #16)
    
    Issue warning to user when unlocking or writing the option bytes.
    The new settings will not take effect until a target reset.
    
    Signed-off-by: Spencer Oliver <ntfreak at users.sourceforge.net>

diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index eaa3a0e..bfdd3cd 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -978,7 +978,9 @@ COMMAND_HANDLER(stm32x_handle_unlock_command)
 		return ERROR_OK;
 	}
 
-	command_print(CMD_CTX, "stm32x unlocked");
+	command_print(CMD_CTX, "stm32x unlocked.\n"
+			"INFO: a reset or power cycle is required "
+			"for the new settings to take effect.");
 
 	return ERROR_OK;
 }
@@ -1114,7 +1116,9 @@ COMMAND_HANDLER(stm32x_handle_options_write_command)
 		return ERROR_OK;
 	}
 
-	command_print(CMD_CTX, "stm32x write options complete");
+	command_print(CMD_CTX, "stm32x write options complete.\n"
+				"INFO: a reset or power cycle is required "
+				"for the new settings to take effect.");
 
 	return ERROR_OK;
 }

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/stm32x.c   |    8 ++++++--
 src/flash/nor/str9xpec.c |    8 ++++++++
 2 files changed, 14 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 14 00:29:20 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 13 Feb 2010 23:29:20 +0000
Subject: [openocd-svn] Main OpenOCD repository annotated tag, v0.4.0-rc2,
	created. v0.4.0-rc2
Message-ID: <E1NgRQP-0001ic-NN@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The annotated tag, v0.4.0-rc2 has been created
        at  a17bd2f476f831ac7ab737e5c2f9b52a8175dc42 (tag)
   tagging  a0a1be5cd69a412c55af14be6c6250cb85b652cd (commit)
  replaces  v0.4.0-rc1
 tagged by  David Brownell
        on  Sat Feb 13 14:48:37 2010 -0800

- Log -----------------------------------------------------------------
RC2 -- hope this is a brief cycle

Alex Austin (1):
      Clang buildfixes

Andreas Fritiofson (1):
      update win32 script search path

Antonio Borneo (6):
      PARPORT code cleanup:
      Fix parport_dcl5 config file.
      ARM9TDMI: Fix segfault.
      whitespace cleanup, mostly for docs
      ARM7_9: Fix segfaults
      Added ST FlashLINK interface config file.

Catalin Patulea (1):
      Driver for USB-JTAG, Altera USB-Blaster and compatibles

David Brownell (104):
      Restore "-dev" version suffix
      cygwin 1.7 build fixes
      NOR: Allocate the right amount of memory
      NOR: messaging fix
      User's Guide: update GDB info
      ARM: add comment re register exports
      NOR: make flash_write_unlock() pad to sector end
      create tcl/board/dm365evm.cfg
      Fix Luminary FT2232 layout docs/configs
      User's Guide: warn about the forum
      streamline and document helptext mode displays
      Cortex-M3: minor breakpoint cleanup
      ARM: ADIv5 symbol and comment cleanup
      ARM: ADIv5 export cleanup
      ARM: dap info fix + tweaks
      ARM: ADIv5 JTAG symbol cleanup
      JTAG/drivers: amt_jtagaccel fixes + cleanup
      JTAG/drivers: cleanup jtag_interface structs
      JTAG: Amontec JTAG accelerater "rtck" is back
      JTAG/Drivers: Amontec JTAG accelerator fixes
      JTAG/drivers: ft2232 docs
      FT2232: fix doc typo
      ARMv7-M:  use AP_REG_* symbol
      ARM: add comments re DAP assumptions
      ARM: add #defines for JTAG ack codes
      don't require 'openocd.cfg' to start
      buildfix with -DNDEBUG
      XScale: help/usage updates
      target misc: help/usage updates
      ARM ETM/ETB/trace: help/usage updates
      ARMv7: help/usage updates
      ARM7/ARM9: help/usage updates
      ARM11: help/usage updates
      ARM720: help/usage updates
      ARM720: help/usage updates
      Xscale: User's Guide updates
      ARM966: help/usage updates
      misc ARM help/usage updates
      NOR: add FIXMEs for writing ones
      Coexist with quilt: rename PATCHES --> PATCHES.txt
      MFLASH: help/usage updates
      *SVF: help/usage updates
      Doc/examples: clarify usage messages
      NAND: help/usage/doc updates
      PLD: usage/help updates
      src/server: usage/help/doc updates
      src/flash/nor: usage/help/doc updates
      src/helper: usage/help updates
      parport (mostly) doc fixes
      jtag/gw16012 usage/help updates
      jtag: presto, parport help/usage updates
      ZY1000 help/usage fixups
      jtag/tcl help/usage fixups
      Presto: doxygen fix
      FreeBSD build fixes
      Doxygen file comments
      ARM: bugfix for "movt" disassembly
      Cortex-M3: improved core exception handling
      NOR: add optional "flash erase_address" sector padding
      User's Guide updates
      ARM7/9 minor cleanups
      ARM7/ARM9: improved reset support
      ARM ADIv5: add comments
      jtag.h whitespace/comment cleanup
      NEWS: include s3c64xx NAND driver
      ARM DPM: disable some nyet-ready breakpoint code
      ADIv5 improved diagnostic
      vsllink -- add comment
      NOR: fix diagnostic
      gdb_server -- symbol cleanup
      gdb_server -- subroutinize memory map logic
      User's guide: mention lpc2000 checksum issue
      gdb_server: correctly report flash sector sizes
      board configs -- unique names for flash chips
      Cortex-M3 vector_catch testing support
      ADIv5 header cleanup (+ #defines)
      User's Guide secton on target hardware setup
      Various doc/comment updates
      ARM11: fix breakpoints with GDB
      NEWS updates
      EmbeddedICE - fix Feroceon/Dragonite message
      cygwin buildfix
      various: don't mention wiki
      Cortex-A8: debug messaging tweaks
      ARM ADIv5: messaging tweaks
      Cortex-M3: report lockup, and recover
      ARM: reference DPM defn from v6/v7 arch spec
      doc clarifications for server flags
      NOR: cleanup driver decls
      ARMv7-M: use command handler for "dap baseaddr".
      ADIv5: cleanup, rename swjdp_transaction_endcheck()
      ARM ADIv5: fix diagnostics for block writes
      ADIv5 error checking for Tcl commands
      Subject: ADIv5: fix more diagnostics
      ADIv5: more messaging cleanup, docs
      NOR: User's Guide updates
      JLink: reference protocol documentation
      Documentation: mention bug database
      ARMv7-M: make DAP commands verify target is an ARMv7-M
      ADIv5: doxygen
      Re-title Developer's Guide
      User's Guide: clarify jtag_rclk advice
      User's Guide: "#" in filesystems names is bad
      v4.0-rc2 milestone

David Claffey (1):
      MIPS: merge mips fast_data patch from David N. Claffey

Dean Glazeski (4):
      Olimex SAM9-L9260 board configuration update.
      Remove some more Eclipse stuff from Git's eyes.
      Add the current command to the command information
      Fix usage/help search for subcommands.

Edgar Grimberg (6):
      target: Fixed format problem for mdh
      interface: Changed parport address to LPT1
      core arm11: Silence logs at level 3 if there is no activity
      Test cases ran on v0.4.0-rc1
      flash/str7x: After reset init the flash is unlocked
      tcl/str7x: Reset init unlocks the flash

Ethan Eade (1):
      scripts: Phytec/LPC2350 config scripts

Freddie Chopin (2):
      stm32x commands get "usage"
      MinGW build fixes

Harald Kipp (1):
      AT91R40008/Ethernut 3 configuration

Johannes Stezenbach (1):
      update udev rules for new udev version

Laurentiu Cocanu (1):
      str9x.c: remove optimization when erasing the whole bank

Marc Pignat (1):
      arm920: add virt2phys fn

Masaki Muranaka (1):
      buildfix on MacOS

Michael Grzeschik (1):
      tcl/target/at91sam3u4e.cfg: changed case in dependent file

Nicolas Pitre (1):
      ARM semihosting: fix EOF handling with SYS_READ

Peter Korsgaard (1):
      nand flash support for s3c64xx

Piotr Esden-Tempski (3):
      NOR: last_addr also needs correction when checking alignment
      Added floss-jtag interface config file.
      Added Open-BLDC board config file.

Spencer Oliver (19):
      parport: output port as hex rather than dec
      MIPS: optimize pracc access
      PIC32: enable ram execution
      MIPS: pracc access tweaks
      MIPS: fastdata bulk write fallback
      MIPS: whitespace cleanup
      MIPS: change bulk_write_memory fallback msg to LOG_DEBUG
      MIPS: update arch_info access to match other targets
      build: doxygen build
      GDB: change gdb_breakpoint_override to COMMAND_ANY
      ARMV7M: handle bkpt instruction on resume/step
      BUILD: remove cygwin gcc 3.4.4 build warnings
      ARM semihosting: fix writing to stdout
      ARM semihosting: win32 and cygwin fixes
      JTAG: fix bug when no interface connected
      CMD: duplicate cmd error msg
      str730.cfg: fix incorrect mem regions
      STM32x: issue warning when unlocking device (bug #16)
      STR9xpec: issue warning when unlocking device

Viktar Palstsiuk (1):
      target library: configuration files for openocd tested with Atmel SAM-ICE V6 JTAG.

Vladimir Zapolskiy (1):
      Added Openmoko USB JTAG interface config file.

richard vegh (1):
      NAND: lpc3180 crashes on LPC3250

simon qian (3):
      read target voltage first in vsllink
      SVF: insert space before '(' and after ')'
      SVF: all content between parentheses is one parameter

??yvind Harboe (32):
      zy1000: less warnings
      zy1000: firmware upgrade fixes for revc
      zy1000: reconfigure FPGA upon reset instead of just the CPU
      zy1000: unlock flash upon startup for revc
      zy1000: add zy1000_ prefix to uart command
      gdb: fix regression in gdb_port command
      shutdown: more graceful shutdown
      zy1000: reset bugfix
      commands: make error messages a bit more terse
      reset: better error messages
      target: return JIM_OK instead of ERROR_OK
      debug: make logging of commands terser
      gdbserver: fix typo that broke read/write watchpoint
      target: add check_reset hook
      arm7/9: add fn to check if dcc downloads have been enabled
      arm7/9: enable check that DCC downloads have been enabled
      commands: allow scan_chain command to be executed during config
      flash: add error messages upon incorrect arguments to flash iteration
      zy1000: print out PCB revision upon boot
      zy1000: flush jtag buffer before changing speed
      arm7/9: add nags upon reset about options to improve performance
      testing: fix str710 test case now builds
      ecos: add missing PRId8 definition
      gdb_server: handle stepi/continue packet while target is running with more grace
      target: print reason why GDB halts
      telnet: fix strage blank spaces at beginning of telnet lines
      build: fix problems with "struct stat" not being defined under eCos
      gdb: restore behavior from 0.3.1 for srst_asserted and power_restore
      zy1000: complete zy1000_uart to jim command switch
      target: add todo in target_write_memory() about alignment
      arm11: fix another infinite loop bug
      arm720t: virt2phys callback added

-----------------------------------------------------------------------


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 14 00:32:08 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 13 Feb 2010 23:32:08 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-1-g4c4ec09
Message-ID: <E1NgRT7-0003Dv-4p@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4c4ec09110db0cb89a6692093aa6579a85fc3552 (commit)
       via  a0a1be5cd69a412c55af14be6c6250cb85b652cd (commit)
      from  f7a6e6277681f6e2702bb9d3e0176000bd09a402 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4c4ec09110db0cb89a6692093aa6579a85fc3552
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 13 15:28:05 2010 -0800

    Restore "-dev" version suffix (0.4.0-rc2-dev)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/configure.in b/configure.in
index a08085b..65d7369 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.4.0-rc2],
+AC_INIT([openocd], [0.4.0-rc2-dev],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

commit a0a1be5cd69a412c55af14be6c6250cb85b652cd
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 13 14:47:17 2010 -0800

    v4.0-rc2 milestone
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/configure.in b/configure.in
index ecc9c6d..a08085b 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.4.0-rc1-dev],
+AC_INIT([openocd], [0.4.0-rc2],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

-----------------------------------------------------------------------

Summary of changes:
 configure.in |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 14 05:15:07 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 14 Feb 2010 04:15:07 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-2-ga2ce3a5
Message-ID: <E1NgVt2-0002ql-8X@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  a2ce3a51dfbc9760e7a4e3f5d5806a1de019721d (commit)
      from  4c4ec09110db0cb89a6692093aa6579a85fc3552 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit a2ce3a51dfbc9760e7a4e3f5d5806a1de019721d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 13 20:14:49 2010 -0800

    NEWS: mention removal of obsolete commands
    
    Removed remaining support for various commands, like advice for
    migrating old-style TAP declarations.
    
    The documentation no longer describes them either ... so if users have
    been delaying config updates, they may need to consult older releases.
    
    ALL this stuff has been clearly marked as "do not use" for at least a
    year now, so anyone still using it hasn't been holding up their end.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index f7bf1d3..cbd5526 100644
--- a/NEWS
+++ b/NEWS
@@ -11,6 +11,8 @@ Boundary Scan:
 
 Target Layer:
 	General
+		- Removed commands which have been obsolete for at least
+		  a year (from both documentation and, sometimes, code).
 		- new "reset-assert" event, for systems without SRST
 	ARM
 		- supports "reset-assert" event (except on Cortex-M3)

-----------------------------------------------------------------------

Summary of changes:
 NEWS |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 14 21:59:27 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 14 Feb 2010 20:59:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-3-g52d4ba3
Message-ID: <E1NglYu-000804-4p@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  52d4ba3467134a1489583dbb6d6de3002f0f76fa (commit)
      from  a2ce3a51dfbc9760e7a4e3f5d5806a1de019721d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 52d4ba3467134a1489583dbb6d6de3002f0f76fa
Author: Mathias Kuester <mkdorg at users.sourceforge.net>
Date:   Sun Feb 14 12:59:10 2010 -0800

    fix crash with DSP563XX
    
    When a DSP563xx-aware GDB asks OpenOCD for target registers,
    the result should be a GDB with register data ... not an
    OpenOCD crash.
    
    (Note that mainline GDB doesn't currently support this core,
    so for now, this requires a GDB with FreeScale patches.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
index 9e2f609..049ee1a 100644
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -246,6 +246,29 @@ static const struct
 	/* *INDENT-ON* */
 };
 
+static int dsp563xx_get_gdb_reg_list(struct target *target, struct reg **reg_list[],
+			      int *reg_list_size)
+{
+	struct dsp563xx_common *dsp563xx = target_to_dsp563xx(target);
+	int i;
+
+	if (target->state != TARGET_HALTED)
+	{
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	*reg_list_size = DSP563XX_NUMCOREREGS;
+	*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
+
+	for (i = 0; i < DSP563XX_NUMCOREREGS; i++)
+	{
+		(*reg_list)[i] = &dsp563xx->core_cache->reg_list[i];
+	}
+
+	return ERROR_OK;
+
+}
+
 int dsp563xx_read_core_reg(struct target *target, int num)
 {
 	uint32_t reg_value;
@@ -974,6 +997,8 @@ struct target_type dsp563xx_target = {
 
 	.target_request_data = NULL,
 
+	.get_gdb_reg_list = dsp563xx_get_gdb_reg_list,
+
 	.halt = dsp563xx_halt,
 	.resume = dsp563xx_resume,
 	.step = dsp563xx_step,

-----------------------------------------------------------------------

Summary of changes:
 src/target/dsp563xx.c |   25 +++++++++++++++++++++++++
 1 files changed, 25 insertions(+), 0 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Feb 15 22:40:54 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 15 Feb 2010 21:40:54 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-4-g5869992
Message-ID: <E1Nh8gZ-0005PF-M2@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  58699923148fa1e0bc3eee4308e351cedecf296a (commit)
      from  52d4ba3467134a1489583dbb6d6de3002f0f76fa (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 58699923148fa1e0bc3eee4308e351cedecf296a
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Mon Feb 15 13:39:16 2010 -0800

    LPC1768.cfg -- partial fixes for bogus reset-init handler
    
    Cortex-M targets don't support ARM instructions.
    
    Leave the NVIC.VTOR setup alone, but comment how the whole
    routine looks like one big bug...
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/target/lpc1768.cfg b/tcl/target/lpc1768.cfg
index 9a813f5..f0093ad 100644
--- a/tcl/target/lpc1768.cfg
+++ b/tcl/target/lpc1768.cfg
@@ -33,11 +33,11 @@ target create $_TARGETNAME cortex_m3 -endian $_ENDIAN -chain-position $_TARGETNA
 # LPC1768 has 32kB of SRAM on its main system bus (so-called Local On-Chip SRAM)
 $_TARGETNAME configure -work-area-phys 0x10000000 -work-area-size 0x8000 -work-area-backup 0
 
+# REVISIT is there any good reason to have this reset-init event handler??
+# Normally they should set up (board-specific) clocking then probe the flash...
 $_TARGETNAME configure -event reset-init {
-	# Force target into ARM state
-	arm core_state arm
-	#do not remap 0x0000-0x0020 to anything but the flash
-#	mwb 0xE01FC040 0x01
+	# Force NVIC.VTOR to point to flash at 0 ...
+	# WHY?  This is it's reset value; we run right after reset!!
 	mwb 0xE000ED08 0x00
 }
 

-----------------------------------------------------------------------

Summary of changes:
 tcl/target/lpc1768.cfg |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb 15 22:59:34 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 15 Feb 2010 21:59:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-5-gfa1cfc2
Message-ID: <E1Nh8yd-0000Y1-Ra@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  fa1cfc2d4da808f752518d3221619bc2e1ea628b (commit)
      from  58699923148fa1e0bc3eee4308e351cedecf296a (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit fa1cfc2d4da808f752518d3221619bc2e1ea628b
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Feb 15 13:41:08 2010 +0100

    gpl: fix GPL startup message
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/helper/options.c b/src/helper/options.c
index 63c5b05..3a95df4 100644
--- a/src/helper/options.c
+++ b/src/helper/options.c
@@ -190,7 +190,7 @@ int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 
 	if (help_flag)
 	{
-		LOG_OUTPUT("Open On-Chip Debugger\n(c) 2005-2008 by Dominic Rath\n\n");
+		LOG_OUTPUT("Open On-Chip Debugger\nLicensed under GNU GPL v2\n");
 		LOG_OUTPUT("--help       | -h\tdisplay this help\n");
 		LOG_OUTPUT("--version    | -v\tdisplay OpenOCD version\n");
 		LOG_OUTPUT("--file       | -f\tuse configuration file <name>\n");
diff --git a/src/openocd.c b/src/openocd.c
index 1105d2a..a689d59 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -228,7 +228,8 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 	}
 	LOG_DEBUG("command registration: complete");
 
-	LOG_OUTPUT(OPENOCD_VERSION "\n");
+	LOG_OUTPUT(OPENOCD_VERSION "\n"
+			"Licensed under GNU GPL v2\n");
 
 	global_cmd_ctx = cmd_ctx;
 

-----------------------------------------------------------------------

Summary of changes:
 src/helper/options.c |    2 +-
 src/openocd.c        |    3 ++-
 2 files changed, 3 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Feb 17 03:58:55 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 17 Feb 2010 02:58:55 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-6-gaa8db98
Message-ID: <E1Nha7s-0000sd-3G@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  aa8db989b90766f4aefe72f96c1c0a37d27d1369 (commit)
      from  fa1cfc2d4da808f752518d3221619bc2e1ea628b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit aa8db989b90766f4aefe72f96c1c0a37d27d1369
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Feb 16 18:50:16 2010 -0800

    ARM920T scanchain 15 comments/cleanup
    
    For folk who don't know the ARM920 JTAG interface very well, the
    two modes of scan chain 15 access to CP15 are confusing.
    
    Make those parts of the ARM920 code less opaque, by:
    
     - Adding comments referencing the relevant parts of the TRM,
       catching up to similar updates in the User's Guide.
    
     - Replacing magic numbers in physical access clients with
       symbolic equivalents.
    
    No functional change.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index e04d9fc..3b75ca9 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -42,7 +42,8 @@
  *   6 ... ETM9
  *   15 ... access coprocessor 15, "physical" or "interpreted" modes
  *	"interpreted" works with a few actual MRC/MCR instructions
- *	"physical" provides register-like behaviors.
+ *	"physical" provides register-like behaviors.  Section 9.6.7
+ *	covers these details.
  *
  * The ARM922T is similar, but with smaller caches (8K each, vs 16K).
  */
@@ -51,8 +52,33 @@
 #define _DEBUG_INSTRUCTION_EXECUTION_
 #endif
 
+/* Table 9-8 shows scan chain 15 format during physical access mode, using a
+ * dedicated 6-bit address space (encoded in bits 33:38).  Writes use one
+ * JTAG scan, while reads use two.
+ *
+ * Table 9-9 lists the thirteen registers which support physical access.
+ * ARM920T_CP15_PHYS_ADDR() constructs the 6-bit reg_addr parameter passed
+ * to arm920t_read_cp15_physical() and arm920t_write_cp15_physical().
+ *
+ *  x == bit[38]
+ *  y == bits[37:34]
+ *  z == bit[33]
+ */
 #define ARM920T_CP15_PHYS_ADDR(x, y, z) ((x << 5) | (y << 1) << (z))
 
+/* Registers supporting physical Read access (from table 9-9) */
+#define CP15PHYS_CACHETYPE	ARM920T_CP15_PHYS_ADDR(0, 0x0, 1)
+#define CP15PHYS_ICACHE_IDX	ARM920T_CP15_PHYS_ADDR(1, 0xd, 1)
+#define CP15PHYS_DCACHE_IDX	ARM920T_CP15_PHYS_ADDR(1, 0xe, 1)
+/* NOTE: several more registers support only physical read access */
+
+/* Registers supporting physical Read/Write access (from table 9-9) */
+#define CP15PHYS_CTRL		ARM920T_CP15_PHYS_ADDR(0, 0x1, 0)
+#define CP15PHYS_PID		ARM920T_CP15_PHYS_ADDR(0, 0xd, 0)
+#define CP15PHYS_TESTSTATE	ARM920T_CP15_PHYS_ADDR(0, 0xf, 0)
+#define CP15PHYS_ICACHE		ARM920T_CP15_PHYS_ADDR(1, 0x1, 1)
+#define CP15PHYS_DCACHE		ARM920T_CP15_PHYS_ADDR(1, 0x2, 1)
+
 static int arm920t_read_cp15_physical(struct target *target,
 		int reg_addr, uint32_t *value)
 {
@@ -153,6 +179,13 @@ static int arm920t_write_cp15_physical(struct target *target,
 	return ERROR_OK;
 }
 
+/* See table 9-10 for scan chain 15 format during interpreted access mode.
+ * If the TESTSTATE register is set for interpreted access, certain CP15
+ * MRC and MCR instructions may be executed through scan chain 15.
+ *
+ * Tables 9-11, 9-12, and 9-13 show which MRC and MCR instructions can be
+ * executed using scan chain 15 interpreted mode.
+ */
 static int arm920t_execute_cp15(struct target *target, uint32_t cp15_opcode,
 		uint32_t arm_opcode)
 {
@@ -225,17 +258,17 @@ static int arm920t_read_cp15_interpreted(struct target *target,
 
 	/* read-modify-write CP15 test state register
 	* to enable interpreted access mode */
-	arm920t_read_cp15_physical(target, 0x1e, &cp15c15);
+	arm920t_read_cp15_physical(target, CP15PHYS_TESTSTATE, &cp15c15);
 	jtag_execute_queue();
 	cp15c15 |= 1;	/* set interpret mode */
-	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* execute CP15 instruction and ARM load (reading from coprocessor) */
 	arm920t_execute_cp15(target, cp15_opcode, ARMV4_5_LDR(0, 1));
 
 	/* disable interpreted access mode */
 	cp15c15 &= ~1U;	/* clear interpret mode */
-	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* retrieve value from R0 */
 	regs_p[0] = value;
@@ -271,17 +304,17 @@ int arm920t_write_cp15_interpreted(struct target *target,
 
 	/* read-modify-write CP15 test state register
 	* to enable interpreted access mode */
-	arm920t_read_cp15_physical(target, 0x1e, &cp15c15);
+	arm920t_read_cp15_physical(target, CP15PHYS_TESTSTATE, &cp15c15);
 	jtag_execute_queue();
 	cp15c15 |= 1;	/* set interpret mode */
-	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* execute CP15 instruction and ARM store (writing to coprocessor) */
 	arm920t_execute_cp15(target, cp15_opcode, ARMV4_5_STR(0, 1));
 
 	/* disable interpreted access mode */
 	cp15c15 &= ~1U;	/* set interpret mode */
-	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG("cp15_opcode: %8.8x, value: %8.8x, address: %8.8x", cp15_opcode, value, address);
@@ -314,7 +347,7 @@ void arm920t_disable_mmu_caches(struct target *target, int mmu, int d_u_cache, i
 	uint32_t cp15_control;
 
 	/* read cp15 control register */
-	arm920t_read_cp15_physical(target, 0x2, &cp15_control);
+	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_control);
 	jtag_execute_queue();
 
 	if (mmu)
@@ -326,7 +359,7 @@ void arm920t_disable_mmu_caches(struct target *target, int mmu, int d_u_cache, i
 	if (i_cache)
 		cp15_control &= ~0x1000U;
 
-	arm920t_write_cp15_physical(target, 0x2, cp15_control);
+	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
 }
 
 // EXPORTED to FA256
@@ -335,7 +368,7 @@ void arm920t_enable_mmu_caches(struct target *target, int mmu, int d_u_cache, in
 	uint32_t cp15_control;
 
 	/* read cp15 control register */
-	arm920t_read_cp15_physical(target, 0x2, &cp15_control);
+	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_control);
 	jtag_execute_queue();
 
 	if (mmu)
@@ -347,7 +380,7 @@ void arm920t_enable_mmu_caches(struct target *target, int mmu, int d_u_cache, in
 	if (i_cache)
 		cp15_control |= 0x1000U;
 
-	arm920t_write_cp15_physical(target, 0x2, cp15_control);
+	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_control);
 }
 
 // EXPORTED to FA256
@@ -357,7 +390,8 @@ void arm920t_post_debug_entry(struct target *target)
 	struct arm920t_common *arm920t = target_to_arm920(target);
 
 	/* examine cp15 control reg */
-	arm920t_read_cp15_physical(target, 0x2, &arm920t->cp15_control_reg);
+	arm920t_read_cp15_physical(target,
+			CP15PHYS_CTRL, &arm920t->cp15_control_reg);
 	jtag_execute_queue();
 	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32 "", arm920t->cp15_control_reg);
 
@@ -365,7 +399,8 @@ void arm920t_post_debug_entry(struct target *target)
 	{
 		uint32_t cache_type_reg;
 		/* identify caches */
-		arm920t_read_cp15_physical(target, 0x1, &cache_type_reg);
+		arm920t_read_cp15_physical(target,
+				CP15PHYS_CACHETYPE, &cache_type_reg);
 		jtag_execute_queue();
 		armv4_5_identify_cache(cache_type_reg, &arm920t->armv4_5_mmu.armv4_5_cache);
 	}
@@ -387,10 +422,12 @@ void arm920t_post_debug_entry(struct target *target)
 	{
 		/* read-modify-write CP15 test state register
 		 * to disable I/D-cache linefills */
-		arm920t_read_cp15_physical(target, 0x1e, &cp15c15);
+		arm920t_read_cp15_physical(target,
+				CP15PHYS_TESTSTATE, &cp15c15);
 		jtag_execute_queue();
 		cp15c15 |= 0x600;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 	}
 }
 
@@ -410,10 +447,12 @@ void arm920t_pre_restore_context(struct target *target)
 	* to reenable I/D-cache linefills */
 	if (arm920t->preserve_cache)
 	{
-		arm920t_read_cp15_physical(target, 0x1e, &cp15c15);
+		arm920t_read_cp15_physical(target,
+				CP15PHYS_TESTSTATE, &cp15c15);
 		jtag_execute_queue();
 		cp15c15 &= ~0x600U;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 	}
 }
 
@@ -720,17 +759,17 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 		regs_p[i] = &regs[i];
 
 	/* disable MMU and Caches */
-	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), &cp15_ctrl);
+	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_ctrl);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		return retval;
 	}
 	cp15_ctrl_saved = cp15_ctrl;
 	cp15_ctrl &= ~(ARMV4_5_MMU_ENABLED | ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
-	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl);
+	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl);
 
 	/* read CP15 test state register */
-	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), &cp15c15);
+	arm920t_read_cp15_physical(target, CP15PHYS_TESTSTATE, &cp15c15);
 	jtag_execute_queue();
 
 	/* read DCache content */
@@ -747,17 +786,20 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* D CAM Read, loads current victim into C15.C.D.Ind */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,6,2), ARMV4_5_LDR(1, 0));
 
 		/* read current victim */
-		arm920t_read_cp15_physical(target, 0x3d, &C15_C_D_Ind);
+		arm920t_read_cp15_physical(target,
+				CP15PHYS_DCACHE_IDX, &C15_C_D_Ind);
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		for (index = 0; index < 64; index++)
 		{
@@ -767,7 +809,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			/* set interpret mode */
 			cp15c15 |= 0x1;
-			arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+			arm920t_write_cp15_physical(target,
+					CP15PHYS_TESTSTATE, cp15c15);
 
 			/* Write DCache victim */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
@@ -780,7 +823,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			/* clear interpret mode */
 			cp15c15 &= ~0x1;
-			arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+			arm920t_write_cp15_physical(target,
+					CP15PHYS_TESTSTATE, cp15c15);
 
 			/* read D RAM and CAM content */
 			arm9tdmi_read_core_regs(target, 0x3fe, regs_p);
@@ -809,14 +853,16 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write DCache victim */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 	}
 
 	/* read ICache content */
@@ -833,17 +879,20 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* I CAM Read, loads current victim into C15.C.I.Ind */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,5,2), ARMV4_5_LDR(1, 0));
 
 		/* read current victim */
-		arm920t_read_cp15_physical(target, 0x3b, &C15_C_I_Ind);
+		arm920t_read_cp15_physical(target, CP15PHYS_ICACHE_IDX,
+				&C15_C_I_Ind);
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		for (index = 0; index < 64; index++)
 		{
@@ -853,7 +902,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			/* set interpret mode */
 			cp15c15 |= 0x1;
-			arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+			arm920t_write_cp15_physical(target,
+					CP15PHYS_TESTSTATE, cp15c15);
 
 			/* Write ICache victim */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
@@ -866,7 +916,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			/* clear interpret mode */
 			cp15c15 &= ~0x1;
-			arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+			arm920t_write_cp15_physical(target,
+					CP15PHYS_TESTSTATE, cp15c15);
 
 			/* read I RAM and CAM content */
 			arm9tdmi_read_core_regs(target, 0x3fe, regs_p);
@@ -894,18 +945,20 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write ICache victim */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 	}
 
 	/* restore CP15 MMU and Cache settings */
-	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl_saved);
+	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl_saved);
 
 	command_print(CMD_CTX, "cache content successfully output to %s", CMD_ARGV[0]);
 
@@ -972,17 +1025,17 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 		regs_p[i] = &regs[i];
 
 	/* disable MMU and Caches */
-	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), &cp15_ctrl);
+	arm920t_read_cp15_physical(target, CP15PHYS_CTRL, &cp15_ctrl);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		return retval;
 	}
 	cp15_ctrl_saved = cp15_ctrl;
 	cp15_ctrl &= ~(ARMV4_5_MMU_ENABLED | ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
-	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl);
+	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl);
 
 	/* read CP15 test state register */
-	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), &cp15c15);
+	arm920t_read_cp15_physical(target, CP15PHYS_TESTSTATE, &cp15c15);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		return retval;
@@ -993,14 +1046,14 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 	/* set interpret mode */
 	cp15c15 |= 0x1;
-	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* Read D TLB lockdown */
 	arm920t_execute_cp15(target, ARMV4_5_MRC(15,0,0,10,0,0), ARMV4_5_LDR(1, 0));
 
 	/* clear interpret mode */
 	cp15c15 &= ~0x1;
-	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* read D TLB lockdown stored to r1 */
 	arm9tdmi_read_core_regs(target, 0x2, regs_p);
@@ -1019,7 +1072,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write D TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
@@ -1029,7 +1083,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* read D TLB CAM content stored to r2-r9 */
 		arm9tdmi_read_core_regs(target, 0x3fc, regs_p);
@@ -1051,7 +1106,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write D TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
@@ -1064,7 +1120,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* read D TLB RAM content stored to r2 and r3 */
 		arm9tdmi_read_core_regs(target, 0xc, regs_p);
@@ -1089,14 +1146,14 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 	/* set interpret mode */
 	cp15c15 |= 0x1;
-	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* Read I TLB lockdown */
 	arm920t_execute_cp15(target, ARMV4_5_MRC(15,0,0,10,0,1), ARMV4_5_LDR(1, 0));
 
 	/* clear interpret mode */
 	cp15c15 &= ~0x1;
-	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* read I TLB lockdown stored to r1 */
 	arm9tdmi_read_core_regs(target, 0x2, regs_p);
@@ -1115,7 +1172,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write I TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
@@ -1125,7 +1183,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* read I TLB CAM content stored to r2-r9 */
 		arm9tdmi_read_core_regs(target, 0x3fc, regs_p);
@@ -1147,7 +1206,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* set interpret mode */
 		cp15c15 |= 0x1;
-		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write I TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
@@ -1160,7 +1220,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
-		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
+		arm920t_write_cp15_physical(target,
+				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* read I TLB RAM content stored to r2 and r3 */
 		arm9tdmi_read_core_regs(target, 0xc, regs_p);
@@ -1181,7 +1242,7 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
 
 	/* restore CP15 MMU and Cache settings */
-	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl_saved);
+	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl_saved);
 
 	/* output data to file */
 	fprintf(output, "D TLB content:\n");

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm920t.c |  163 ++++++++++++++++++++++++++++++++++----------------
 1 files changed, 112 insertions(+), 51 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Fri Feb 19 08:17:57 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Fri, 19 Feb 2010 07:17:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-7-g3f30563
Message-ID: <E1NiN7e-0004Xa-EF@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  3f30563c88fcf02a8a8e671d817299adfda628ec (commit)
      from  aa8db989b90766f4aefe72f96c1c0a37d27d1369 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 3f30563c88fcf02a8a8e671d817299adfda628ec
Author: Marc Pignat <marc.pignat at hevs.ch>
Date:   Tue Feb 16 10:08:18 2010 +0100

    atm920t : fix breakpoints and data cache handling
    
    Breakpoints did not work because the data cache was not flushed
    properly.
    
    As a bonus add capability to write to memory marked as read only
    by the MMU, which allows software breakpoints in such memory
    regions.

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 3b75ca9..7cc228d 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -559,34 +559,120 @@ static int arm920t_write_phys_memory(struct target *target,
 
 
 /** Writes a buffer, in the specified word size, with current MMU settings. */
-int arm920t_write_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+int arm920t_write_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
+	const uint32_t cache_mask = ~0x1f; /* cache line size : 32 byte */
+	struct arm920t_common *arm920t = target_to_arm920(target);
 
-	if ((retval = arm7_9_write_memory(target, address, size, count, buffer)) != ERROR_OK)
-		return retval;
-
-	/* This fn is used to write breakpoints, so we need to make sure
-	 * that the data cache is flushed and the instruction cache is
-	 * invalidated
-	 */
-	if (((size == 4) || (size == 2)) && (count == 1))
+	/* FIX!!!! this should be cleaned up and made much more general. The
+	 * plan is to write up and test on arm920t specifically and
+	 * then generalize and clean up afterwards. */
+	if (arm920t->armv4_5_mmu.mmu_enabled && (count == 1) && ((size==2) || (size==4)))
 	{
-		struct arm920t_common *arm920t = target_to_arm920(target);
+		/* special case the handling of single word writes to bypass MMU
+		 * to allow implementation of breakpoints in memory marked read only
+		 * by MMU */
+		int type;
+		uint32_t cb;
+		int domain;
+		uint32_t ap;
+		uint32_t pa;
+
+		/*
+		 * We need physical address and cb
+		 */
+		pa = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu, address, &type, &cb, &domain, &ap);
+		if (type == -1)
+		{
+			return pa;
+		}
 
 		if (arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		{
-			LOG_DEBUG("D-Cache enabled, flush and invalidate cache line");
-			/* MCR p15,0,Rd,c7,c10,2 */
-			retval = arm920t_write_cp15_interpreted(target, 0xee070f5e, 0x0, address);
-			if (retval != ERROR_OK)
-				return retval;
+			if (cb & 0x1)
+			{
+				LOG_DEBUG("D-Cache buffered, drain write buffer");
+				/*
+				 * Buffered ?
+				 * Drain write buffer - MCR p15,0,Rd,c7,c10,4
+				 */
+
+				retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 10, 4), 0x0, 0);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+
+			if (cb == 0x3)
+			{
+				/*
+				 * Write back memory ? -> clean cache
+				 *
+				 * There is no way for cleaning a data cache line using
+				 * cp15 scan chain, so copy the full cache line from
+				 * cache to physical memory.
+				 */
+				uint8_t data[32];
+
+				LOG_DEBUG("D-Cache in 'write back' mode, flush cache line");
+
+				retval = target_read_memory(target, address & cache_mask, 1, sizeof(data), &data[0]);
+				if (retval != ERROR_OK)
+					return retval;
+
+				retval = armv4_5_mmu_write_physical(target, &arm920t->armv4_5_mmu, pa & cache_mask, 1, sizeof(data), &data[0]);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+
+			/* Cached ? */
+			if (cb & 0x2)
+			{
+				/*
+				 * Cached ? -> Invalidate data cache using MVA
+				 *
+				 * MCR p15,0,Rd,c7,c6,1
+				 */
+				LOG_DEBUG("D-Cache enabled, invalidate cache line");
+
+				retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 6, 1), 0x0, address & cache_mask);
+				if (retval != ERROR_OK)
+					return retval;
+			}
 		}
 
-		if (arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
+		/* write directly to physical memory bypassing any read only MMU bits, etc. */
+		retval = armv4_5_mmu_write_physical(target, &arm920t->armv4_5_mmu, pa, size, count, buffer);
+		if (retval != ERROR_OK)
+			return retval;
+	} else
+	{
+		if ((retval = arm7_9_write_memory(target, address, size, count, buffer)) != ERROR_OK)
+			return retval;
+	}
+
+	/* If ICache is enabled, we have to invalidate affected ICache lines
+	 * the DCache is forced to write-through, so we don't have to clean it here
+	 */
+	if (arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
+	{
+		if (count <= 1)
 		{
+			/* invalidate ICache single entry with MVA
+			 * 	ee070f35 	mcr	15, 0, r0, cr7, cr5, {1}
+			 */
 			LOG_DEBUG("I-Cache enabled, invalidating affected I-Cache line");
-			retval = arm920t_write_cp15_interpreted(target, 0xee070f35, 0x0, address);
+			retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 5, 1), 0x0, address & cache_mask);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+		else
+		{
+			/* invalidate ICache
+			 *   8:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
+			 * */
+			retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 5, 0), 0x0, 0x0);
 			if (retval != ERROR_OK)
 				return retval;
 		}

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm920t.c |  120 +++++++++++++++++++++++++++++++++++++++++++-------
 1 files changed, 103 insertions(+), 17 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Feb 20 20:11:57 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 20 Feb 2010 19:11:57 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-8-gd2a2c14
Message-ID: <E1NiukA-00041g-ML@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  d2a2c14d202da736e2c820c26d6deceee4e1e530 (commit)
      from  3f30563c88fcf02a8a8e671d817299adfda628ec (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d2a2c14d202da736e2c820c26d6deceee4e1e530
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 20 11:11:43 2010 -0800

    FreeBSD buildfix
    
    Fix an unused variable warning seen when building the parport driver
    under FreeBSD.
    
    Using information from Xiaofan Chen <xiaofanc at gmail.com>
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
index a38ccfd..fa3373b 100644
--- a/src/jtag/drivers/parport.c
+++ b/src/jtag/drivers/parport.c
@@ -265,7 +265,6 @@ static int parport_init(void)
 	struct cable *cur_cable;
 #if PARPORT_USE_PPDEV == 1
 	char buffer[256];
-	int i = 0;
 #endif
 
 	cur_cable = cables;
@@ -323,7 +322,8 @@ static int parport_init(void)
 	LOG_DEBUG("...open");
 
 #if !defined(__FreeBSD__) && !defined(__FreeBSD_kernel__)
-	i = ioctl(device_handle, PPCLAIM);
+	int i = ioctl(device_handle, PPCLAIM);
+
 	if (i < 0)
 	{
 		LOG_ERROR("cannot claim device");

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/drivers/parport.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 21 05:53:09 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 21 Feb 2010 04:53:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-10-gbb4cb79
Message-ID: <E1Nj3oc-000500-3q@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  bb4cb7935e8c4eb41e1d68ac2c43f6a1caec1ae5 (commit)
       via  57d5673dea2111d68a5266f23f6b6bacec38014e (commit)
      from  d2a2c14d202da736e2c820c26d6deceee4e1e530 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit bb4cb7935e8c4eb41e1d68ac2c43f6a1caec1ae5
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 20 20:47:38 2010 -0800

    arm920t line length cleanup
    
    The recent patch to fixbreakpoints and dcache handling added
    a bunch of overlong lines (80+ chars) ... shrink them, and do
    the same to a few lines which were already overlong.
    
    Also add a few FIXME comments to nudge (a) replacement of some
    magic numbers with opcode macros, which will be much better at
    showing what's actually going on, and (b) correct return codes.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 7cc228d..3e61545 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -276,7 +276,8 @@ static int arm920t_read_cp15_interpreted(struct target *target,
 	jtag_execute_queue();
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
-	LOG_DEBUG("cp15_opcode: %8.8x, address: %8.8x, value: %8.8x", cp15_opcode, address, *value);
+	LOG_DEBUG("cp15_opcode: %8.8x, address: %8.8x, value: %8.8x",
+			cp15_opcode, address, *value);
 #endif
 
 	if (!is_arm_mode(armv4_5->core_mode))
@@ -317,7 +318,8 @@ int arm920t_write_cp15_interpreted(struct target *target,
 	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
-	LOG_DEBUG("cp15_opcode: %8.8x, value: %8.8x, address: %8.8x", cp15_opcode, value, address);
+	LOG_DEBUG("cp15_opcode: %8.8x, value: %8.8x, address: %8.8x",
+			cp15_opcode, value, address);
 #endif
 
 	if (!is_arm_mode(armv4_5->core_mode))
@@ -335,14 +337,17 @@ uint32_t arm920t_get_ttb(struct target *target)
 	int retval;
 	uint32_t ttb = 0x0;
 
-	if ((retval = arm920t_read_cp15_interpreted(target, 0xeebf0f51, 0x0, &ttb)) != ERROR_OK)
+	if ((retval = arm920t_read_cp15_interpreted(target,
+			/* FIXME use opcode macro */
+			0xeebf0f51, 0x0, &ttb)) != ERROR_OK)
 		return retval;
 
 	return ttb;
 }
 
 // EXPORTED to FA256
-void arm920t_disable_mmu_caches(struct target *target, int mmu, int d_u_cache, int i_cache)
+void arm920t_disable_mmu_caches(struct target *target, int mmu,
+		int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
 
@@ -363,7 +368,8 @@ void arm920t_disable_mmu_caches(struct target *target, int mmu, int d_u_cache, i
 }
 
 // EXPORTED to FA256
-void arm920t_enable_mmu_caches(struct target *target, int mmu, int d_u_cache, int i_cache)
+void arm920t_enable_mmu_caches(struct target *target, int mmu,
+		int d_u_cache, int i_cache)
 {
 	uint32_t cp15_control;
 
@@ -393,7 +399,7 @@ void arm920t_post_debug_entry(struct target *target)
 	arm920t_read_cp15_physical(target,
 			CP15PHYS_CTRL, &arm920t->cp15_control_reg);
 	jtag_execute_queue();
-	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32 "", arm920t->cp15_control_reg);
+	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, arm920t->cp15_control_reg);
 
 	if (arm920t->armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
@@ -402,20 +408,26 @@ void arm920t_post_debug_entry(struct target *target)
 		arm920t_read_cp15_physical(target,
 				CP15PHYS_CACHETYPE, &cache_type_reg);
 		jtag_execute_queue();
-		armv4_5_identify_cache(cache_type_reg, &arm920t->armv4_5_mmu.armv4_5_cache);
+		armv4_5_identify_cache(cache_type_reg,
+				&arm920t->armv4_5_mmu.armv4_5_cache);
 	}
 
-	arm920t->armv4_5_mmu.mmu_enabled = (arm920t->cp15_control_reg & 0x1U) ? 1 : 0;
-	arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = (arm920t->cp15_control_reg & 0x4U) ? 1 : 0;
-	arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled = (arm920t->cp15_control_reg & 0x1000U) ? 1 : 0;
+	arm920t->armv4_5_mmu.mmu_enabled =
+			(arm920t->cp15_control_reg & 0x1U) ? 1 : 0;
+	arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled =
+			(arm920t->cp15_control_reg & 0x4U) ? 1 : 0;
+	arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled =
+			(arm920t->cp15_control_reg & 0x1000U) ? 1 : 0;
 
 	/* save i/d fault status and address register */
+			/* FIXME use opcode macros */
 	arm920t_read_cp15_interpreted(target, 0xee150f10, 0x0, &arm920t->d_fsr);
 	arm920t_read_cp15_interpreted(target, 0xee150f30, 0x0, &arm920t->i_fsr);
 	arm920t_read_cp15_interpreted(target, 0xee160f10, 0x0, &arm920t->d_far);
 	arm920t_read_cp15_interpreted(target, 0xee160f30, 0x0, &arm920t->i_far);
 
-	LOG_DEBUG("D FSR: 0x%8.8" PRIx32 ", D FAR: 0x%8.8" PRIx32 ", I FSR: 0x%8.8" PRIx32 ", I FAR: 0x%8.8" PRIx32 "",
+	LOG_DEBUG("D FSR: 0x%8.8" PRIx32 ", D FAR: 0x%8.8" PRIx32
+		", I FSR: 0x%8.8" PRIx32 ", I FAR: 0x%8.8" PRIx32,
 		arm920t->d_fsr, arm920t->d_far, arm920t->i_fsr, arm920t->i_far);
 
 	if (arm920t->preserve_cache)
@@ -490,9 +502,9 @@ int arm920t_arch_state(struct target *target)
 
 	arm_arch_state(target);
 	LOG_USER("MMU: %s, D-Cache: %s, I-Cache: %s",
-			 state[arm920t->armv4_5_mmu.mmu_enabled],
-			 state[arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
-			 state[arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
+		 state[arm920t->armv4_5_mmu.mmu_enabled],
+		 state[arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
+		 state[arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
 
 	return ERROR_OK;
 }
@@ -517,7 +529,8 @@ static int arm920_virt2phys(struct target *target,
 	uint32_t ap;
 	struct arm920t_common *arm920t = target_to_arm920(target);
 
-	uint32_t ret = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu, virt, &type, &cb, &domain, &ap);
+	uint32_t ret = armv4_5_mmu_translate_va(target,
+			&arm920t->armv4_5_mmu, virt, &type, &cb, &domain, &ap);
 	if (type == -1)
 	{
 		return ret;
@@ -527,7 +540,8 @@ static int arm920_virt2phys(struct target *target,
 }
 
 /** Reads a buffer, in the specified word size, with current MMU settings. */
-int arm920t_read_memory(struct target *target, uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+int arm920t_read_memory(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	int retval;
 
@@ -569,11 +583,14 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 	/* FIX!!!! this should be cleaned up and made much more general. The
 	 * plan is to write up and test on arm920t specifically and
 	 * then generalize and clean up afterwards. */
-	if (arm920t->armv4_5_mmu.mmu_enabled && (count == 1) && ((size==2) || (size==4)))
+	if (arm920t->armv4_5_mmu.mmu_enabled && (count == 1) &&
+			((size==2) || (size==4)))
 	{
-		/* special case the handling of single word writes to bypass MMU
-		 * to allow implementation of breakpoints in memory marked read only
-		 * by MMU */
+		/* special case the handling of single word writes to
+		 * bypass MMU, to allow implementation of breakpoints
+		 * in memory marked read only
+		 * by MMU
+		 */
 		int type;
 		uint32_t cb;
 		int domain;
@@ -583,23 +600,25 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 		/*
 		 * We need physical address and cb
 		 */
-		pa = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu, address, &type, &cb, &domain, &ap);
+		pa = armv4_5_mmu_translate_va(target, &arm920t->armv4_5_mmu,
+				address, &type, &cb, &domain, &ap);
 		if (type == -1)
-		{
 			return pa;
-		}
 
 		if (arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		{
 			if (cb & 0x1)
 			{
-				LOG_DEBUG("D-Cache buffered, drain write buffer");
+				LOG_DEBUG("D-Cache buffered, "
+						"drain write buffer");
 				/*
 				 * Buffered ?
 				 * Drain write buffer - MCR p15,0,Rd,c7,c10,4
 				 */
 
-				retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 10, 4), 0x0, 0);
+				retval = arm920t_write_cp15_interpreted(target,
+					ARMV4_5_MCR(15, 0, 0, 7, 10, 4),
+					0x0, 0);
 				if (retval != ERROR_OK)
 					return retval;
 			}
@@ -609,19 +628,25 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 				/*
 				 * Write back memory ? -> clean cache
 				 *
-				 * There is no way for cleaning a data cache line using
-				 * cp15 scan chain, so copy the full cache line from
-				 * cache to physical memory.
+				 * There is no way to clean cache lines using
+				 * cp15 scan chain, so copy the full cache
+				 * line from cache to physical memory.
 				 */
 				uint8_t data[32];
 
-				LOG_DEBUG("D-Cache in 'write back' mode, flush cache line");
+				LOG_DEBUG("D-Cache in 'write back' mode, "
+						"flush cache line");
 
-				retval = target_read_memory(target, address & cache_mask, 1, sizeof(data), &data[0]);
+				retval = target_read_memory(target,
+						address & cache_mask, 1,
+						sizeof(data), &data[0]);
 				if (retval != ERROR_OK)
 					return retval;
 
-				retval = armv4_5_mmu_write_physical(target, &arm920t->armv4_5_mmu, pa & cache_mask, 1, sizeof(data), &data[0]);
+				retval = armv4_5_mmu_write_physical(target,
+						&arm920t->armv4_5_mmu,
+						pa & cache_mask, 1,
+						sizeof(data), &data[0]);
 				if (retval != ERROR_OK)
 					return retval;
 			}
@@ -634,45 +659,59 @@ int arm920t_write_memory(struct target *target, uint32_t address,
 				 *
 				 * MCR p15,0,Rd,c7,c6,1
 				 */
-				LOG_DEBUG("D-Cache enabled, invalidate cache line");
+				LOG_DEBUG("D-Cache enabled, "
+					"invalidate cache line");
 
-				retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 6, 1), 0x0, address & cache_mask);
+				retval = arm920t_write_cp15_interpreted(target,
+					ARMV4_5_MCR(15, 0, 0, 7, 6, 1), 0x0,
+					address & cache_mask);
 				if (retval != ERROR_OK)
 					return retval;
 			}
 		}
 
-		/* write directly to physical memory bypassing any read only MMU bits, etc. */
-		retval = armv4_5_mmu_write_physical(target, &arm920t->armv4_5_mmu, pa, size, count, buffer);
+		/* write directly to physical memory,
+		 * bypassing any read only MMU bits, etc.
+		 */
+		retval = armv4_5_mmu_write_physical(target,
+				&arm920t->armv4_5_mmu, pa, size,
+				count, buffer);
 		if (retval != ERROR_OK)
 			return retval;
 	} else
 	{
-		if ((retval = arm7_9_write_memory(target, address, size, count, buffer)) != ERROR_OK)
+		if ((retval = arm7_9_write_memory(target, address,
+					size, count, buffer)) != ERROR_OK)
 			return retval;
 	}
 
 	/* If ICache is enabled, we have to invalidate affected ICache lines
-	 * the DCache is forced to write-through, so we don't have to clean it here
+	 * the DCache is forced to write-through,
+	 * so we don't have to clean it here
 	 */
 	if (arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled)
 	{
 		if (count <= 1)
 		{
 			/* invalidate ICache single entry with MVA
-			 * 	ee070f35 	mcr	15, 0, r0, cr7, cr5, {1}
+			 *   mcr	15, 0, r0, cr7, cr5, {1}
 			 */
-			LOG_DEBUG("I-Cache enabled, invalidating affected I-Cache line");
-			retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 5, 1), 0x0, address & cache_mask);
+			LOG_DEBUG("I-Cache enabled, "
+				"invalidating affected I-Cache line");
+			retval = arm920t_write_cp15_interpreted(target,
+					ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+					0x0, address & cache_mask);
 			if (retval != ERROR_OK)
 				return retval;
 		}
 		else
 		{
 			/* invalidate ICache
-			 *   8:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
-			 * */
-			retval = arm920t_write_cp15_interpreted(target, ARMV4_5_MCR(15, 0, 0, 7, 5, 0), 0x0, 0x0);
+			 *  mcr	15, 0, r0, cr7, cr5, {0}
+			 */
+			retval = arm920t_write_cp15_interpreted(target,
+					ARMV4_5_MCR(15, 0, 0, 7, 5, 0),
+					0x0, 0x0);
 			if (retval != ERROR_OK)
 				return retval;
 		}
@@ -699,7 +738,8 @@ int arm920t_soft_reset_halt(struct target *target)
 	int timeout;
 	while (!(timeout = ((timeval_ms()-then) > 1000)))
 	{
-		if (buf_get_u32(dbg_stat->value, EICE_DBG_STATUS_DBGACK, 1) == 0)
+		if (buf_get_u32(dbg_stat->value, EICE_DBG_STATUS_DBGACK, 1)
+				== 0)
 		{
 			embeddedice_read_reg(dbg_stat);
 			if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -746,12 +786,7 @@ int arm920t_soft_reset_halt(struct target *target)
 	arm920t->armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
 	arm920t->armv4_5_mmu.armv4_5_cache.i_cache_enabled = 0;
 
-	if ((retval = target_call_event_callbacks(target, TARGET_EVENT_HALTED)) != ERROR_OK)
-	{
-		return retval;
-	}
-
-	return ERROR_OK;
+	return target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 }
 
 /* FIXME remove forward decls */
@@ -764,7 +799,8 @@ static int arm920t_mcr(struct target *target, int cpnum,
 		uint32_t CRn, uint32_t CRm,
 		uint32_t value);
 
-int arm920t_init_arch_info(struct target *target, struct arm920t_common *arm920t, struct jtag_tap *tap)
+int arm920t_init_arch_info(struct target *target,
+		struct arm920t_common *arm920t, struct jtag_tap *tap)
 {
 	struct arm7_9_common *arm7_9 = &arm920t->arm7_9_common;
 
@@ -802,8 +838,9 @@ int arm920t_init_arch_info(struct target *target, struct arm920t_common *arm920t
 
 static int arm920t_target_create(struct target *target, Jim_Interp *interp)
 {
-	struct arm920t_common *arm920t = calloc(1,sizeof(struct arm920t_common));
+	struct arm920t_common *arm920t;
 
+	arm920t = calloc(1,sizeof(struct arm920t_common));
 	return arm920t_init_arch_info(target, arm920t, target->tap);
 }
 
@@ -851,7 +888,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 		return retval;
 	}
 	cp15_ctrl_saved = cp15_ctrl;
-	cp15_ctrl &= ~(ARMV4_5_MMU_ENABLED | ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
+	cp15_ctrl &= ~(ARMV4_5_MMU_ENABLED
+		| ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
 	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl);
 
 	/* read CP15 test state register */
@@ -862,7 +900,9 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 	fprintf(output, "DCache:\n");
 
 	/* go through segments 0 to nsets (8 on ARM920T, 4 on ARM922T) */
-	for (segment = 0; segment < arm920t->armv4_5_mmu.armv4_5_cache.d_u_size.nsets; segment++)
+	for (segment = 0;
+		segment < arm920t->armv4_5_mmu.armv4_5_cache.d_u_size.nsets;
+		segment++)
 	{
 		fprintf(output, "\nsegment: %i\n----------", segment);
 
@@ -876,7 +916,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* D CAM Read, loads current victim into C15.C.D.Ind */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,6,2), ARMV4_5_LDR(1, 0));
+		arm920t_execute_cp15(target,
+			ARMV4_5_MCR(15,2,0,15,6,2), ARMV4_5_LDR(1, 0));
 
 		/* read current victim */
 		arm920t_read_cp15_physical(target,
@@ -889,7 +930,9 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 		for (index = 0; index < 64; index++)
 		{
-			/* Ra: r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0) */
+			/* Ra:
+			 * r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0)
+			 */
 			regs[0] = 0x0 | (segment << 5) | (index << 26);
 			arm9tdmi_write_core_regs(target, 0x1, regs);
 
@@ -899,13 +942,18 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 					CP15PHYS_TESTSTATE, cp15c15);
 
 			/* Write DCache victim */
-			arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
+			arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
 
 			/* Read D RAM */
-			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,10,2), ARMV4_5_LDMIA(0, 0x1fe, 0, 0));
+			arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,2,0,15,10,2),
+				ARMV4_5_LDMIA(0, 0x1fe, 0, 0));
 
 			/* Read D CAM */
-			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,6,2), ARMV4_5_LDR(9, 0));
+			arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,2,0,15,6,2),
+				ARMV4_5_LDR(9, 0));
 
 			/* clear interpret mode */
 			cp15c15 &= ~0x1;
@@ -923,12 +971,16 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			/* mask LFSR[6] */
 			regs[9] &= 0xfffffffe;
-			fprintf(output, "\nsegment: %i, index: %i, CAM: 0x%8.8" PRIx32 ", content (%s):\n", segment, index, regs[9], (regs[9] & 0x10) ? "valid" : "invalid");
+			fprintf(output, "\nsegment: %i, index: %i, CAM: 0x%8.8"
+				PRIx32 ", content (%s):\n",
+				segment, index, regs[9],
+				(regs[9] & 0x10) ? "valid" : "invalid");
 
 			for (i = 1; i < 9; i++)
 			{
 				 d_cache[segment][index].data[i] = regs[i];
-				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n", i-1, regs[i]);
+				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n",
+						i-1, regs[i]);
 			}
 
 		}
@@ -943,7 +995,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write DCache victim */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
@@ -955,7 +1008,9 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 	fprintf(output, "ICache:\n");
 
 	/* go through segments 0 to nsets (8 on ARM920T, 4 on ARM922T) */
-	for (segment = 0; segment < arm920t->armv4_5_mmu.armv4_5_cache.d_u_size.nsets; segment++)
+	for (segment = 0;
+		segment < arm920t->armv4_5_mmu.armv4_5_cache.d_u_size.nsets;
+		segment++)
 	{
 		fprintf(output, "segment: %i\n----------", segment);
 
@@ -969,7 +1024,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* I CAM Read, loads current victim into C15.C.I.Ind */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,5,2), ARMV4_5_LDR(1, 0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,2,0,15,5,2), ARMV4_5_LDR(1, 0));
 
 		/* read current victim */
 		arm920t_read_cp15_physical(target, CP15PHYS_ICACHE_IDX,
@@ -982,7 +1038,9 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 		for (index = 0; index < 64; index++)
 		{
-			/* Ra: r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0) */
+			/* Ra:
+			 * r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0)
+			 */
 			regs[0] = 0x0 | (segment << 5) | (index << 26);
 			arm9tdmi_write_core_regs(target, 0x1, regs);
 
@@ -992,13 +1050,18 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 					CP15PHYS_TESTSTATE, cp15c15);
 
 			/* Write ICache victim */
-			arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
+			arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
 
 			/* Read I RAM */
-			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,9,2), ARMV4_5_LDMIA(0, 0x1fe, 0, 0));
+			arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,2,0,15,9,2),
+				ARMV4_5_LDMIA(0, 0x1fe, 0, 0));
 
 			/* Read I CAM */
-			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,5,2), ARMV4_5_LDR(9, 0));
+			arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,2,0,15,5,2),
+				ARMV4_5_LDR(9, 0));
 
 			/* clear interpret mode */
 			cp15c15 &= ~0x1;
@@ -1016,12 +1079,16 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 
 			/* mask LFSR[6] */
 			regs[9] &= 0xfffffffe;
-			fprintf(output, "\nsegment: %i, index: %i, CAM: 0x%8.8" PRIx32 ", content (%s):\n", segment, index, regs[9], (regs[9] & 0x10) ? "valid" : "invalid");
+			fprintf(output, "\nsegment: %i, index: %i, "
+				"CAM: 0x%8.8" PRIx32 ", content (%s):\n",
+				segment, index, regs[9],
+				(regs[9] & 0x10) ? "valid" : "invalid");
 
 			for (i = 1; i < 9; i++)
 			{
 				 i_cache[segment][index].data[i] = regs[i];
-				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n", i-1, regs[i]);
+				 fprintf(output, "%i: 0x%8.8" PRIx32 "\n",
+						i-1, regs[i]);
 			}
 		}
 
@@ -1035,7 +1102,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write ICache victim */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
@@ -1046,7 +1114,8 @@ COMMAND_HANDLER(arm920t_handle_read_cache_command)
 	/* restore CP15 MMU and Cache settings */
 	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl_saved);
 
-	command_print(CMD_CTX, "cache content successfully output to %s", CMD_ARGV[0]);
+	command_print(CMD_CTX, "cache content successfully output to %s",
+			CMD_ARGV[0]);
 
 	fclose(output);
 
@@ -1117,7 +1186,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 		return retval;
 	}
 	cp15_ctrl_saved = cp15_ctrl;
-	cp15_ctrl &= ~(ARMV4_5_MMU_ENABLED | ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
+	cp15_ctrl &= ~(ARMV4_5_MMU_ENABLED
+			| ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
 	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl);
 
 	/* read CP15 test state register */
@@ -1135,7 +1205,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* Read D TLB lockdown */
-	arm920t_execute_cp15(target, ARMV4_5_MRC(15,0,0,10,0,0), ARMV4_5_LDR(1, 0));
+	arm920t_execute_cp15(target,
+			ARMV4_5_MRC(15,0,0,10,0,0), ARMV4_5_LDR(1, 0));
 
 	/* clear interpret mode */
 	cp15c15 &= ~0x1;
@@ -1152,7 +1223,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	for (victim = 0; victim < 64; victim += 8)
 	{
 		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
-		 * base remains unchanged, victim goes through entries 0 to 63 */
+		 * base remains unchanged, victim goes through entries 0 to 63
+		 */
 		regs[1] = (Dlockdown & 0xfc000000) | (victim << 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
 
@@ -1162,10 +1234,14 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write D TLB lockdown */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
+		arm920t_execute_cp15(target,
+			ARMV4_5_MCR(15,0,0,10,0,0),
+			ARMV4_5_STR(1, 0));
 
 		/* Read D TLB CAM */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,6,4), ARMV4_5_LDMIA(0, 0x3fc, 0, 0));
+		arm920t_execute_cp15(target,
+			ARMV4_5_MCR(15,4,0,15,6,4),
+			ARMV4_5_LDMIA(0, 0x3fc, 0, 0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
@@ -1186,7 +1262,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	for (victim = 0; victim < 64; victim++)
 	{
 		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
-		 * base remains unchanged, victim goes through entries 0 to 63 */
+		 * base remains unchanged, victim goes through entries 0 to 63
+		 */
 		regs[1] = (Dlockdown & 0xfc000000) | (victim << 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
 
@@ -1196,13 +1273,16 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write D TLB lockdown */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
 
 		/* Read D TLB RAM1 */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,10,4), ARMV4_5_LDR(2,0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,4,0,15,10,4), ARMV4_5_LDR(2,0));
 
 		/* Read D TLB RAM2 */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,2,5), ARMV4_5_LDR(3,0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,4,0,15,2,5), ARMV4_5_LDR(3,0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
@@ -1225,7 +1305,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	arm9tdmi_write_core_regs(target, 0x2, regs);
 
 	/* Write D TLB lockdown */
-	arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
+	arm920t_execute_cp15(target,
+			ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
 
 	/* prepare reading I TLB content
 	 * */
@@ -1235,7 +1316,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	arm920t_write_cp15_physical(target, CP15PHYS_TESTSTATE, cp15c15);
 
 	/* Read I TLB lockdown */
-	arm920t_execute_cp15(target, ARMV4_5_MRC(15,0,0,10,0,1), ARMV4_5_LDR(1, 0));
+	arm920t_execute_cp15(target,
+			ARMV4_5_MRC(15,0,0,10,0,1), ARMV4_5_LDR(1, 0));
 
 	/* clear interpret mode */
 	cp15c15 &= ~0x1;
@@ -1252,7 +1334,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	for (victim = 0; victim < 64; victim += 8)
 	{
 		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
-		 * base remains unchanged, victim goes through entries 0 to 63 */
+		 * base remains unchanged, victim goes through entries 0 to 63
+		 */
 		regs[1] = (Ilockdown & 0xfc000000) | (victim << 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
 
@@ -1262,10 +1345,14 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write I TLB lockdown */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,0,0,10,0,1),
+				ARMV4_5_STR(1, 0));
 
 		/* Read I TLB CAM */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,5,4), ARMV4_5_LDMIA(0, 0x3fc, 0, 0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,4,0,15,5,4),
+				ARMV4_5_LDMIA(0, 0x3fc, 0, 0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
@@ -1286,7 +1373,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	for (victim = 0; victim < 64; victim++)
 	{
 		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
-		 * base remains unchanged, victim goes through entries 0 to 63 */
+		 * base remains unchanged, victim goes through entries 0 to 63
+		 */
 		regs[1] = (Dlockdown & 0xfc000000) | (victim << 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
 
@@ -1296,13 +1384,16 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 				CP15PHYS_TESTSTATE, cp15c15);
 
 		/* Write I TLB lockdown */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
 
 		/* Read I TLB RAM1 */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,9,4), ARMV4_5_LDR(2,0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,4,0,15,9,4), ARMV4_5_LDR(2,0));
 
 		/* Read I TLB RAM2 */
-		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,1,5), ARMV4_5_LDR(3,0));
+		arm920t_execute_cp15(target,
+				ARMV4_5_MCR(15,4,0,15,1,5), ARMV4_5_LDR(3,0));
 
 		/* clear interpret mode */
 		cp15c15 &= ~0x1;
@@ -1325,7 +1416,8 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	arm9tdmi_write_core_regs(target, 0x2, regs);
 
 	/* Write I TLB lockdown */
-	arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
+	arm920t_execute_cp15(target,
+			ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
 
 	/* restore CP15 MMU and Cache settings */
 	arm920t_write_cp15_physical(target, CP15PHYS_CTRL, cp15_ctrl_saved);
@@ -1334,16 +1426,23 @@ COMMAND_HANDLER(arm920t_handle_read_mmu_command)
 	fprintf(output, "D TLB content:\n");
 	for (i = 0; i < 64; i++)
 	{
-		fprintf(output, "%i: 0x%8.8" PRIx32 " 0x%8.8" PRIx32 " 0x%8.8" PRIx32 " %s\n", i, d_tlb[i].cam, d_tlb[i].ram1, d_tlb[i].ram2, (d_tlb[i].cam & 0x20) ? "(valid)" : "(invalid)");
+		fprintf(output, "%i: 0x%8.8" PRIx32 " 0x%8.8" PRIx32
+			" 0x%8.8" PRIx32 " %s\n",
+			i, d_tlb[i].cam, d_tlb[i].ram1, d_tlb[i].ram2,
+			(d_tlb[i].cam & 0x20) ? "(valid)" : "(invalid)");
 	}
 
 	fprintf(output, "\n\nI TLB content:\n");
 	for (i = 0; i < 64; i++)
 	{
-		fprintf(output, "%i: 0x%8.8" PRIx32 " 0x%8.8" PRIx32 " 0x%8.8" PRIx32 " %s\n", i, i_tlb[i].cam, i_tlb[i].ram1, i_tlb[i].ram2, (i_tlb[i].cam & 0x20) ? "(valid)" : "(invalid)");
+		fprintf(output, "%i: 0x%8.8" PRIx32 " 0x%8.8" PRIx32
+			" 0x%8.8" PRIx32 " %s\n",
+			i, i_tlb[i].cam, i_tlb[i].ram1, i_tlb[i].ram2,
+			(i_tlb[i].cam & 0x20) ? "(valid)" : "(invalid)");
 	}
 
-	command_print(CMD_CTX, "mmu content successfully output to %s", CMD_ARGV[0]);
+	command_print(CMD_CTX, "mmu content successfully output to %s",
+			CMD_ARGV[0]);
 
 	fclose(output);
 
@@ -1382,11 +1481,14 @@ COMMAND_HANDLER(arm920t_handle_cp15_command)
 
 	if (target->state != TARGET_HALTED)
 	{
-		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		command_print(CMD_CTX, "target must be stopped for "
+			"\"%s\" command", CMD_NAME);
 		return ERROR_OK;
 	}
 
-	/* one or more argument, access a single register (write if second argument is given */
+	/* one argument, read a register.
+	 * two arguments, write it.
+	 */
 	if (CMD_ARGC >= 1)
 	{
 		int address;
@@ -1395,9 +1497,11 @@ COMMAND_HANDLER(arm920t_handle_cp15_command)
 		if (CMD_ARGC == 1)
 		{
 			uint32_t value;
-			if ((retval = arm920t_read_cp15_physical(target, address, &value)) != ERROR_OK)
+			if ((retval = arm920t_read_cp15_physical(target,
+					address, &value)) != ERROR_OK)
 			{
-				command_print(CMD_CTX, "couldn't access reg %i", address);
+				command_print(CMD_CTX,
+					"couldn't access reg %i", address);
 				return ERROR_OK;
 			}
 			if ((retval = jtag_execute_queue()) != ERROR_OK)
@@ -1405,18 +1509,24 @@ COMMAND_HANDLER(arm920t_handle_cp15_command)
 				return retval;
 			}
 
-			command_print(CMD_CTX, "%i: %8.8" PRIx32 "", address, value);
+			command_print(CMD_CTX, "%i: %8.8" PRIx32,
+					address, value);
 		}
 		else if (CMD_ARGC == 2)
 		{
 			uint32_t value;
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
-			if ((retval = arm920t_write_cp15_physical(target, address, value)) != ERROR_OK)
+			retval = arm920t_write_cp15_physical(target,
+					address, value);
+			if (retval != ERROR_OK)
 			{
-				command_print(CMD_CTX, "couldn't access reg %i", address);
+				command_print(CMD_CTX,
+					"couldn't access reg %i", address);
+				/* REVISIT why lie? "return retval"? */
 				return ERROR_OK;
 			}
-			command_print(CMD_CTX, "%i: %8.8" PRIx32 "", address, value);
+			command_print(CMD_CTX, "%i: %8.8" PRIx32,
+					address, value);
 		}
 	}
 
@@ -1436,11 +1546,14 @@ COMMAND_HANDLER(arm920t_handle_cp15i_command)
 
 	if (target->state != TARGET_HALTED)
 	{
-		command_print(CMD_CTX, "target must be stopped for \"%s\" command", CMD_NAME);
+		command_print(CMD_CTX, "target must be stopped for "
+				"\"%s\" command", CMD_NAME);
 		return ERROR_OK;
 	}
 
-	/* one or more argument, access a single register (write if second argument is given */
+	/* one argument, read a register.
+	 * two arguments, write it.
+	 */
 	if (CMD_ARGC >= 1)
 	{
 		uint32_t opcode;
@@ -1449,24 +1562,36 @@ COMMAND_HANDLER(arm920t_handle_cp15i_command)
 		if (CMD_ARGC == 1)
 		{
 			uint32_t value;
-			if ((retval = arm920t_read_cp15_interpreted(target, opcode, 0x0, &value)) != ERROR_OK)
+			retval = arm920t_read_cp15_interpreted(target,
+					opcode, 0x0, &value);
+			if (retval != ERROR_OK)
 			{
-				command_print(CMD_CTX, "couldn't execute %8.8" PRIx32 "", opcode);
+				command_print(CMD_CTX,
+					"couldn't execute %8.8" PRIx32,
+					opcode);
+				/* REVISIT why lie? "return retval"? */
 				return ERROR_OK;
 			}
 
-			command_print(CMD_CTX, "%8.8" PRIx32 ": %8.8" PRIx32 "", opcode, value);
+			command_print(CMD_CTX, "%8.8" PRIx32 ": %8.8" PRIx32,
+					opcode, value);
 		}
 		else if (CMD_ARGC == 2)
 		{
 			uint32_t value;
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
-			if ((retval = arm920t_write_cp15_interpreted(target, opcode, value, 0)) != ERROR_OK)
+			retval = arm920t_write_cp15_interpreted(target,
+					opcode, value, 0);
+			if (retval != ERROR_OK)
 			{
-				command_print(CMD_CTX, "couldn't execute %8.8" PRIx32 "", opcode);
+				command_print(CMD_CTX,
+					"couldn't execute %8.8" PRIx32,
+					opcode);
+				/* REVISIT why lie? "return retval"? */
 				return ERROR_OK;
 			}
-			command_print(CMD_CTX, "%8.8" PRIx32 ": %8.8" PRIx32 "", opcode, value);
+			command_print(CMD_CTX, "%8.8" PRIx32 ": %8.8" PRIx32,
+					opcode, value);
 		}
 		else if (CMD_ARGC == 3)
 		{
@@ -1474,17 +1599,23 @@ COMMAND_HANDLER(arm920t_handle_cp15i_command)
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
 			uint32_t address;
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], address);
-			if ((retval = arm920t_write_cp15_interpreted(target, opcode, value, address)) != ERROR_OK)
+			retval = arm920t_write_cp15_interpreted(target,
+					opcode, value, address);
+			if (retval != ERROR_OK)
 			{
-				command_print(CMD_CTX, "couldn't execute %8.8" PRIx32 "", opcode);
+				command_print(CMD_CTX,
+					"couldn't execute %8.8" PRIx32, opcode);
+				/* REVISIT why lie? "return retval"? */
 				return ERROR_OK;
 			}
-			command_print(CMD_CTX, "%8.8" PRIx32 ": %8.8" PRIx32 " %8.8" PRIx32 "", opcode, value, address);
+			command_print(CMD_CTX, "%8.8" PRIx32 ": %8.8" PRIx32
+					" %8.8" PRIx32, opcode, value, address);
 		}
 	}
 	else
 	{
-		command_print(CMD_CTX, "usage: arm920t cp15i <opcode> [value] [address]");
+		command_print(CMD_CTX,
+			"usage: arm920t cp15i <opcode> [value] [address]");
 	}
 
 	return ERROR_OK;
@@ -1500,7 +1631,8 @@ COMMAND_HANDLER(arm920t_handle_cache_info_command)
 	if (retval != ERROR_OK)
 		return retval;
 
-	return armv4_5_handle_cache_info_command(CMD_CTX, &arm920t->armv4_5_mmu.armv4_5_cache);
+	return armv4_5_handle_cache_info_command(CMD_CTX,
+			&arm920t->armv4_5_mmu.armv4_5_cache);
 }
 
 

commit 57d5673dea2111d68a5266f23f6b6bacec38014e
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 20 20:47:38 2010 -0800

    CSB337 board cleanup (quasi-regression)
    
    Get rid of new nasty warning:
    
    NOTE! Severe performance degradation without fast memory access enabled...
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/board/csb337.cfg b/tcl/board/csb337.cfg
index de19660..b7bce48 100644
--- a/tcl/board/csb337.cfg
+++ b/tcl/board/csb337.cfg
@@ -113,3 +113,5 @@ proc csb337_reset_init { } {
 }
 
 $_TARGETNAME configure -event reset-init {csb337_reset_init}
+
+arm7_9 fast_memory_access enable

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm920t.c |  362 ++++++++++++++++++++++++++++++++++----------------
 tcl/board/csb337.cfg |    2 +
 2 files changed, 249 insertions(+), 115 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 21 18:29:34 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 21 Feb 2010 17:29:34 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-11-g4aa0a4d
Message-ID: <E1NjFcd-0001hp-Qw@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4aa0a4d8111772c526ba84e3502b2f73ca06d603 (commit)
      from  bb4cb7935e8c4eb41e1d68ac2c43f6a1caec1ae5 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4aa0a4d8111772c526ba84e3502b2f73ca06d603
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 09:29:24 2010 -0800

    User's Guide mentions OS-specific installation
    
    Specifically the Linux issue of needing "udev" rules, and MS-Windows
    needing driver configuration.
    
    Also, update the existing udev note to use the correct name of that
    rules file in the source tree.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/README b/README
index 35118da..b69a69a 100644
--- a/README
+++ b/README
@@ -64,8 +64,8 @@ you can build the in-tree documentation.
 Installing OpenOCD
 ==================
 
-On Linux, you may have permissions problems to address.  The best
-way to do this is to use the contrib/udev.rules file.  It probably
+On Linux, you may have permissions problems to address.  The best way
+to do this is to use the contrib/openocd.udev rules file.  It probably
 belongs somewhere in /etc/udev/rules.d, but consult your operating
 system documentation to be sure.  In particular, make sure that it
 matches the syntax used by your operating system's version of udev.
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 63b6ab0..61e39b2 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -506,6 +506,14 @@ as Tcl scripts, from a @file{startup.tcl} file internal to the server.
 @cindex logfile
 @cindex directory search
 
+Properly installing OpenOCD sets up your operating system to grant it access
+to the JTAG adapters.  On Linux, this usually involves installing a file
+in @file{/etc/udev/rules.d,} so OpenOCD has permissions.  MS-Windows needs
+complex and confusing driver configuration for every peripheral.  Such issues
+are unique to each operating system, and are not detailed in this User's Guide.
+
+Then later you will invoke the OpenOCD server, with various options to
+tell it how each debug session should work.
 The @option{--help} option shows:
 @verbatim
 bash$ openocd --help
@@ -1984,6 +1992,10 @@ MMU: disabled, D-Cache: disabled, I-Cache: enabled
 @cindex config file, interface
 @cindex interface config file
 
+Correctly installing OpenOCD includes making your operating system give
+OpenOCD access to JTAG adapters.  Once that has been done, Tcl commands
+are used to select which one is used, and to configure how it is used.
+
 JTAG Adapters/Interfaces/Dongles are normally configured
 through commands in an interface configuration
 file which is sourced by your @file{openocd.cfg} file, or

-----------------------------------------------------------------------

Summary of changes:
 README           |    4 ++--
 doc/openocd.texi |   12 ++++++++++++
 2 files changed, 14 insertions(+), 2 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 21 22:16:42 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 21 Feb 2010 21:16:42 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-rc2-12-g56e7490
Message-ID: <E1NjJAR-0007ms-Ol@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  56e74908d17d740db0a376f354c21e6608e8af8d (commit)
      from  4aa0a4d8111772c526ba84e3502b2f73ca06d603 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 56e74908d17d740db0a376f354c21e6608e8af8d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 12:20:13 2010 -0800

    Label builds as OpenOCD v0.4.0
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/configure.in b/configure.in
index 65d7369..4681aeb 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.4.0-rc2-dev],
+AC_INIT([openocd], [0.4.0],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

-----------------------------------------------------------------------

Summary of changes:
 configure.in |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 21 22:16:57 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 21 Feb 2010 21:16:57 +0000
Subject: [openocd-svn] Main OpenOCD repository annotated tag, v0.4.0,
	created. v0.4.0
Message-ID: <E1NjJAg-0007oN-5N@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The annotated tag, v0.4.0 has been created
        at  ed703c7f7189338cb60beef75d83fe85ccd8296c (tag)
   tagging  56e74908d17d740db0a376f354c21e6608e8af8d (commit)
  replaces  v0.4.0-rc2
 tagged by  David Brownell
        on  Sun Feb 21 12:22:31 2010 -0800

- Log -----------------------------------------------------------------
The OpenOCD 0.4.0 release

David Brownell (9):
      Restore "-dev" version suffix (0.4.0-rc2-dev)
      NEWS: mention removal of obsolete commands
      LPC1768.cfg -- partial fixes for bogus reset-init handler
      ARM920T scanchain 15 comments/cleanup
      FreeBSD buildfix
      CSB337 board cleanup (quasi-regression)
      arm920t line length cleanup
      User's Guide mentions OS-specific installation
      Label builds as OpenOCD v0.4.0

Marc Pignat (1):
      atm920t : fix breakpoints and data cache handling

Mathias Kuester (1):
      fix crash with DSP563XX

??yvind Harboe (1):
      gpl: fix GPL startup message

-----------------------------------------------------------------------


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 21 23:20:13 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 21 Feb 2010 22:20:13 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-1-gb853b9d
Message-ID: <E1NjK9u-0008BA-DH@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  b853b9dbc0ba3d68a501d8badc4491f8108cd11b (commit)
      from  56e74908d17d740db0a376f354c21e6608e8af8d (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit b853b9dbc0ba3d68a501d8badc4491f8108cd11b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 13:27:37 2010 -0800

    Open the merge window for the 0.5.0 release cycle.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index cbd5526..b39b3a8 100644
--- a/NEWS
+++ b/NEWS
@@ -1,90 +1,23 @@
 This file includes highlights of the changes made in the
-OpenOCD 0.4.0 source archive release.  See the repository
+OpenOCD 0.5.0 source archive release.  See the repository
 history for details about what changed, including bugfixes
 and other issues not mentioned here.
 
 JTAG Layer:
-	Support KT-Link JTAG adapter.
-	Support USB-JTAG, Altera USB-Blaster and compatibles.
 
 Boundary Scan:
 
 Target Layer:
-	General
-		- Removed commands which have been obsolete for at least
-		  a year (from both documentation and, sometimes, code).
-		- new "reset-assert" event, for systems without SRST
-	ARM
-		- supports "reset-assert" event (except on Cortex-M3)
-		- renamed "armv4_5" command prefix as "arm"
-		- recognize TrustZone "Secure Monitor" mode
-		- "arm regs" command output changed
-		- register names use "sp" not "r13"
-		- add top-level "mcr" and "mrc" commands, replacing
-		  various core-specific operations
-		- basic semihosting support (ARM7/ARM9 only, for now)
-	ARM11
-		- Should act much more like other ARM cores:
-		   * Preliminary ETM and ETB hookup
-		   * accelerated "flash erase_check"
-		   * accelerated GDB memory checksum
-		   * support "arm regs" command
-		   * can access all core modes and registers
-		   * watchpoint support
-		- Shares some core debug code with Cortex-A8
-	Cortex-A8
-		- Should act much more like other ARM cores:
-		   * support "arm regs" command
-		   * can access all core modes and registers
-		   * watchpoint support
-		- Shares some core debug code with ARM11
-	Cortex-M3
-		- Exposed DWT registers like cycle counter
-		- vector_catch settings not clobbered by resets
-		- no longer interferes with firmware's fault handling
-	ETM, ETB
-		- "trigger_percent" command moved ETM --> ETB
-		- "etm trigger_debug" command added
-	MIPS
-		- use fastdata writes
-	Freescale DSP563xx cores (partial support)
 
 Flash Layer:
-	'flash bank' and 'nand device' take <bank_name> as first argument.
-	With this, flash/NAND commands allow referencing banks by name:
-		- <bank_name>: reference the bank with its defined name
-		- <driver_name>[.N]: reference the driver's Nth bank
-	New 'nand verify' command to check bank against an image file.
-	The "flash erase_address" command now rejects partial sectors;
-		previously it would silently erase extra data.  If you
-		want to erase the rest of the first and/or last sectors
-		instead of failing, you must pass an explicit "pad" flag.
-	New at91sam9 NAND controller driver.
-	New s3c64xx NAND controller driver.
 
 Board, Target, and Interface Configuration Scripts:
-	ARM9
-		- ETM and ETB hookup for iMX2* targets
-	Add $HOME/.openocd to the search path.
-	Handle Rev C of LM3S811 eval boards.
-		- use "luminary-lm3s811.cfg" for older boards
-		- use "luminary.cfg" for RevC and newer
 
 Core Jim/TCL Scripting:
-	New 'usage' command to provide terse command help.
-	Improved command 'help' command output (sorted and indented).
-	Improved command handling:
-		- Most boolean settings now accept any of the following:
-		  on/off, enable/disable, true/false, yes/no, 1/0
-		- More error checking and reporting.
 
 Documentation:
-	New built-in command development documentation and primer.
 
 Build and Release:
-	Use --enable-doxygen-pdf to build PDF developer documentation.
-	Consider upgrading to libftdi 0.17 if you use that library; it
-		includes bugfixes which improve FT2232H support.
 
 For more details about what has changed since the last release,
 see the git repository history.  With gitweb, you can browse that
@@ -96,3 +29,4 @@ For older NEWS, see the NEWS files associated with each release
 For more information about contributing test reports, bug fixes, or new
 features and device support, please read the new Developer Manual (or
 the BUGS and PATCHES.txt files in the source archive).
+
diff --git a/NEWS b/NEWS-0.4.0
similarity index 100%
copy from NEWS
copy to NEWS-0.4.0
diff --git a/configure.in b/configure.in
index 4681aeb..3b0a06d 100644
--- a/configure.in
+++ b/configure.in
@@ -1,5 +1,5 @@
 AC_PREREQ(2.60)
-AC_INIT([openocd], [0.4.0],
+AC_INIT([openocd], [0.5.0-dev],
   [OpenOCD Mailing List <openocd-development at lists.berlios.de>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 

-----------------------------------------------------------------------

Summary of changes:
 NEWS               |   70 +--------------------------------------------------
 NEWS => NEWS-0.4.0 |    0
 configure.in       |    2 +-
 3 files changed, 3 insertions(+), 69 deletions(-)
 copy NEWS => NEWS-0.4.0 (100%)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Mon Feb 22 02:21:51 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Mon, 22 Feb 2010 01:21:51 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-13-gc21c740
Message-ID: <E1NjMzg-0003QI-4P@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  c21c740a895438832ed7e945ee4943da3eb733f9 (commit)
       via  dc342f45f6c8ec02431495863687b3638f1646d5 (commit)
       via  c8ea748dc22660dad934537384d35903dfcc492e (commit)
       via  3b68a708c2b039d9b091608eccb2206725742a47 (commit)
       via  ecff73043c1ddcc97d4d1ea1c87f251a850b22d4 (commit)
       via  39cfe6279616a69b858ddd3493d61ed7133ff081 (commit)
       via  a97bb67543eacde38f093610982812f714e7a050 (commit)
       via  249263d29da11b0ec981c2e0d520cd7dcf08939b (commit)
       via  1aac72d24339380f6e98c50dec4c96ab30537749 (commit)
       via  a299371a9ec109da3851cb43aed3e9157d095358 (commit)
       via  27c068c1f82423a2492899d1632caaa6f8261810 (commit)
       via  ce1feaa7322affd3b979c9fe93dd8f7462ea9eca (commit)
      from  b853b9dbc0ba3d68a501d8badc4491f8108cd11b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit c21c740a895438832ed7e945ee4943da3eb733f9
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 17:19:08 2010 -0800

    ft2232 table init cleanup
    
    Use labeled initializers in the table of layouts instead of
    positional ones.  This ls cleaner and less error prone, plus
    it simplifies patches which add members to these structure.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 82132d3..5042a22 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -185,25 +185,84 @@ static void ktlink_blink(void);
 
 static const struct ft2232_layout  ft2232_layouts[] =
 {
-	{ "usbjtag",              usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ "jtagkey",              jtagkey_init,              jtagkey_reset,      NULL                    },
-	{ "jtagkey_prototype_v1", jtagkey_init,              jtagkey_reset,      NULL                    },
-	{ "oocdlink",             jtagkey_init,              jtagkey_reset,      NULL                    },
-	{ "signalyzer",           usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ "evb_lm3s811",          usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ "luminary_icdi",        usbjtag_init,              usbjtag_reset,      NULL                    },
-	{ "olimex-jtag",          olimex_jtag_init,          olimex_jtag_reset,  olimex_jtag_blink       },
-	{ "flyswatter",           flyswatter_init,           flyswatter_reset,   flyswatter_jtag_blink   },
-	{ "turtelizer2",          turtle_init,               turtle_reset,       turtle_jtag_blink       },
-	{ "comstick",             comstick_init,             comstick_reset,     NULL                    },
-	{ "stm32stick",           stm32stick_init,           stm32stick_reset,   NULL                    },
-	{ "axm0432_jtag",         axm0432_jtag_init,         axm0432_jtag_reset, NULL                    },
-	{ "sheevaplug",           sheevaplug_init,           sheevaplug_reset,   NULL                    },
-	{ "icebear",              icebear_jtag_init,         icebear_jtag_reset, NULL                    },
-	{ "cortino",              cortino_jtag_init,         comstick_reset, NULL                        },
-	{ "signalyzer-h",         signalyzer_h_init,         signalyzer_h_reset, signalyzer_h_blink      },
-	{ "ktlink",               ktlink_init,               ktlink_reset,       ktlink_blink            },
-	{ NULL,                   NULL,                      NULL,               NULL                    },
+	{ .name = "usbjtag",
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = "jtagkey",
+		.init = jtagkey_init,
+		.reset = jtagkey_reset,
+	},
+	{ .name = "jtagkey_prototype_v1",
+		.init = jtagkey_init,
+		.reset = jtagkey_reset,
+	},
+	{ .name = "oocdlink",
+		.init = jtagkey_init,
+		.reset = jtagkey_reset,
+	},
+	{ .name = "signalyzer",
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = "evb_lm3s811",
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = "luminary_icdi",
+		.init = usbjtag_init,
+		.reset = usbjtag_reset,
+	},
+	{ .name = "olimex-jtag",
+		.init = olimex_jtag_init,
+		.reset = olimex_jtag_reset,
+		.blink = olimex_jtag_blink
+	},
+	{ .name = "flyswatter",
+		.init = flyswatter_init,
+		.reset = flyswatter_reset,
+		.blink = flyswatter_jtag_blink
+	},
+	{ .name = "turtelizer2",
+		.init = turtle_init,
+		.reset = turtle_reset,
+		.blink = turtle_jtag_blink
+	},
+	{ .name = "comstick",
+		.init = comstick_init,
+		.reset = comstick_reset,
+	},
+	{ .name = "stm32stick",
+		.init = stm32stick_init,
+		.reset = stm32stick_reset,
+	},
+	{ .name = "axm0432_jtag",
+		.init = axm0432_jtag_init,
+		.reset = axm0432_jtag_reset,
+	},
+	{ .name = "sheevaplug",
+		.init = sheevaplug_init,
+		.reset = sheevaplug_reset,
+	},
+	{ .name = "icebear",
+		.init = icebear_jtag_init,
+		.reset = icebear_jtag_reset,
+	},
+	{ .name = "cortino",
+		.init = cortino_jtag_init,
+		.reset = comstick_reset,
+	},
+	{ .name = "signalyzer-h",
+		.init = signalyzer_h_init,
+		.reset = signalyzer_h_reset,
+		.blink = signalyzer_h_blink
+	},
+	{ .name = "ktlink",
+		.init = ktlink_init,
+		.reset = ktlink_reset,
+		.blink = ktlink_blink
+	},
+	{ .name = NULL, /* END OF TABLE */ },
 };
 
 static uint8_t                  nTRST, nTRSTnOE, nSRST, nSRSTnOE;

commit dc342f45f6c8ec02431495863687b3638f1646d5
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 16:55:17 2010 -0800

    Developer's Guide: refresh release procedures
    
    Be a closer match to what I've actually done for the past few cycles.
    
    In particular, hold off pushing repository updates until after the
    packages are published, as part of opening the merge window, and
    mention the utility commands which actually create the archives.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/manual/release.txt b/doc/manual/release.txt
index 70a22ff..056628e 100644
--- a/doc/manual/release.txt
+++ b/doc/manual/release.txt
@@ -84,8 +84,8 @@ the minor version will @a also be zero (<code>y = 0, z = 0</code>).
 After these required numeric components, release version strings
 may contain tags such as as <em>-rc1</em> or <em>-rc2</em>.
 These 'rc' tags indicate "release candidate" versions of the package.
-Like the major/minor/micro numbers, these tags will be manipulated
-by the automated release process.
+Like major/minor/micro numbers, these are updated
+as part of the release process.
 
 The release process includes version number manipulations to the tree
 being released, ensuring that all numbers are incremented (or rolled
@@ -277,22 +277,34 @@ support; the Release Manager isn't the only participant.
 
 The following steps should be followed to produce each release:
 
--# Produce final patches to mainline (or a release branch).  Nobody
-   except the RM should be committing anything.
-  -# Finalize @c NEWS file to describe the changes in the release
+-# Produce final patches using a local clone of mainline.  Nobody
+   except the RM should be committing anything.  <em>Everyone with commit
+   privileges needs to know and agree to this in advance!</em>  Even the RM
+   only commits a handful of updates as part of the release process
+   itself ... to files which are part of the version identification scheme
+   or release process; and to create the version tag; and then to open the
+   merge window for the next release cycle.
+  -# Finalize @c the NEWS file to describe the changes in the release
     - This file is used to automatically post "blurbs" about the project.
-    - This material should be produced during the development cycle.
-    - Add a new item for each @c NEWS-worthy contribution, when committed.
+    - This material should have been produced during the development cycle,
+      by adding items for each @c NEWS-worthy contribution, when committed
+      during the merge window.  (One part of closing the merge window, by
+      opening the RC phase of the release, is the commitment to hold all
+      further such contributions until the next merge window opens.)
+    - The RM should make sure nothing important was omitted, as part of
+      the RC1 cycle.  From then on, no more updates to NEWS content should
+      be needed (except to seed the process for the next release, or maybe
+      if a significant and longstanding bug is fixed late in the RC phase).
   -# Bump library version if our API changed (not yet required)
   -# Update and commit the final package version in @c configure.in:
-     <code>tools/release/version.sh</code> may help ensure the versions
-     are named consistently:
+     (The <code>tools/release/version.sh</code> script might help ensure
+     the versions are named properly.):
     -# Remove @c -dev tag.
-    -# Update the @c -rc tag:
+    -# Update any @c -rc tag:
       - If producing the final release from an -rc series, remove it
       - If producing the first RC in a series, add rc1
       - If producing the next RC in a series, bump the rc number
-    -# Commit that version change.
+    -# Commit that version change, with a good descriptive comment.
   -# Create a git tag for the final commit, with a tag name matching
      the version string in <code>configure.in</code> (including <em>-rcN</em>
      where relevant):
@@ -301,49 +313,92 @@ PACKAGE_VERSION="x.y.z"
 PACKAGE_TAG="v${PACKAGE_VERSION}"
 git tag -m "The openocd-${PACKAGE_VERSION} release." "${PACKAGE_TAG}"
 @endverbatim
--# Prepare to resume normal development on mainline (major or minor release)
-  - Update the version label
-     - Restore @c -dev version tag.
-     - For a new minor release cycle, increment the release's minor number
-     - For a new major release cycle, increment the release's major number
-       and zero its minor number
-  - Archive @c NEWS file as "<code>doc/news/NEWS-${PACKAGE_VERSION}</code>".
-  - Create a new @c NEWS file for the next release
-  - Commit those changes, and push the commit and the release tag
-    to mainline.
--# Produce the package source archives:
-  -# <em>Start with a new clone of the source tree</em>, with the
-     release's tag.  This is used only for producing these packages.
-  -# Checkout the appropriate tag:
-<code>git checkout "${PACKAGE_VERSION}"</code>
-  -# @c bootstrap, @c configure, and @c make the package.
-  -# Run <code>make distcheck</code> to produce the distribution archives.
-  -# Run <code>make maintainer-clean</code> verify the repository is empty.
-  -# Create signature files using @c md5sum, @c sha1sum, etc.
--# Publish documentation for the release:
-  - Allow users to access the documentation for each of our releases.
-  - Place static copies of the following files on the project website:
-    - @c NEWS: to provide a blurb for each release
-    - User's Guide, Developer Manual: to allow easy on-line viewing
+  -# Do not push those changes to mainline yet; only builds using the
+     source archives you will be creating should ever be labeled as
+     official releases (with no "-dev" suffix).  Since mainline is a
+     development tree, these will be pushed later, as part of opening
+     the merge window for the next release cycle (restoring the "-dev"
+     suffix for that next release.)  Those version and tag updates are
+     the last ones to be included in the release being made.
+-# Produce the release files, using the local clone of the source
+  tree which holds the release's tag and updated version in
+  @c configure.in ... this is used only to produce the release, and
+  all files should already be properly checked out.
+  -# Run <code>tools/release.sh package</code> to produce the
+	source archives.  This automatically bootstraps and
+	configures the process.
+  -# Run <code>tools/release.sh stage</code> to create an @c archives
+	directory with the release data, including MD5 and SHA1
+	checksum files (which are used with Berlios).
+  -# Sanity check at least one of those archives, by extracting and
+     configuring its contents, using them to build a copy of OpenOCD,
+     and verifying that the result prints the correct release version
+     in its startup banner.  (For example,
+     "configure --enable-ft2232_libftdi --enable-parport"
+     then "make" and run "src/openocd -v" as a sanity check.)
+  -# Run <code>make docs</code> to create the
+     documentation which will be published.
 -# Upload packages and post announcements of their availability:
   -# Release packages into files section of project sites:
     - SF.net:
-     -# Create a new folder named "${PACKAGE_VERSION}"
-     -# Select new folder as the target for uploads.
-     -# Upload files via Web interface into new
-     -# Set platform types for each archive:
+     -# Under "Project Admin", use the "File Manager"
+     -# Create a new folder under "openocd" named "${PACKAGE_VERSION}"
+     -# Upload the @c NEWS file and mark it as the release notes.
+     -# Upload the three source archive files, using the Web interface,
+     	into that folder.  Verify the upload worked OK by checking the
+	MD5 and SHA1 checksums computed by SourceForge against the
+	versions created as part of staging the release.
+     -# Also upload doc/openocd.pdf (the User's Guide) so the version
+        matching each release will be easily available.
+     -# Select each file in the release, and use the property panel
+        to set its type and select the right release notes.
        - .tar.bz2: Linux, Mac
        - .tar.gz: BSD, Solaris, Others
        - .zip: Windows
+       - For openocd.pdf just associate it with the right release notes.
+     -# Create an SF.net project news update.
     - Berlios:
-     -# Create the new release for the new version.
      -# Provide @c NEWS file, as requested.
-     -# Upload files via FTP to ftp://ftp.berlios.de/incoming/
-     -# Edit descriptions for each file.
+     -# Upload the release files via FTP to ftp://ftp.berlios.de/incoming/
+     -# Edit descriptions for each file (one at a time)  Note that Berlios
+	does not automatically checksum files, and it uses a very old
+	version of the SourceForge code with user interface issues.
      -# Click button to send E-mail Release Notice.
+  -# Depending on how paranoid you're feeling today, verify the images by
+     downloading them from the websites and making sure there are no
+     differences between the downloaded copies and your originals.
+  -# Publish User's and Developer's Guides to the project web sites:
+     -# Use SCP to update the SF.net web site with PDF and HTML for the
+          User's Guide, and HTML for the developer's guide ... you can
+	  instantiate a shell.sourceforge.net instance and set up symlinks
+	  from your home directory, to simplify this process.
+     -# (How to update the Berlios web site with the same data?)
   -# Post announcement e-mail to the openocd-development list.
-  -# Announce updates on freshmeat.net and other trackers.
-  -# Submit big updates to news feeds (e.g. Digg, Reddit, etc.).
+  -# optionally:
+     -# Post an update on the Berlios blog (if it lets you)
+     -# Announce updates on freshmeat.net and other trackers.
+     -# Submit updates to news feeds (e.g. Digg, Reddit, etc.).
+-# Resume normal development on mainline, by opening the merge window for
+  the next major or minor release cycle.  (You might want to do this
+  before all the release bits are fully published.)
+  - Update the version label in the @c configure.in file:
+     - Restore @c -dev version tag.
+     - For a new minor release cycle, increment the release's minor number
+     - For a new major release cycle, increment the release's major number
+       and zero its minor number
+  - Archive @c NEWS file as "<code>doc/news/NEWS-${PACKAGE_VERSION}</code>".
+  - Create a new @c NEWS file for the next release
+  - Commit those changes.
+  - Push all the updates to mainline.
+     - Last updates for the release, including the release tag (you
+       will need to "git push --tags").
+     - Updates opening the merge window
+  - At this point, it's OK for commiters to start pushing changes
+    which have been held off until the next release.  (Any bugfixes to
+    this release will be against a bug-fix release branch starting from
+    the commit you tagged as this release, not mainline.)
+  - Announce to the openocd-development list.  Ideally, you will also
+    be able to say who is managing the next release cycle.
 
 To start a bug-fix release branch:
 -# Create a new branch, starting from a major or

commit c8ea748dc22660dad934537384d35903dfcc492e
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:58:16 2010 -0800

    ADIv5: relocate memacess_tck cycles
    
    When using an AP to access a memory (or a memory-mapped register),
    some extra TCK (assuming JTAG) cycles should be added to ensure
    the AP has enugh time to complete that access before trying to
    collect the response.
    
    The previous code was adding these cycles *before* trying to
    access (read or write) data to that address, not *after*.  Fix
    by putting the delays in the right location.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 819dd29..d30dd50 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -119,18 +119,6 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
 	jtag_set_end_state(TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, instr, NULL);
 
-	/* Add specified number of tck clocks before accessing memory bus */
-
-	/* REVISIT these TCK cycles should be *AFTER*  updating APACC, since
-	 * they provide more time for the (MEM) AP to complete the read ...
-	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&& ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr & 0xF0) == AP_REG_BD0))
-			&& (swjdp->memaccess_tck != 0))
-		jtag_add_runtest(swjdp->memaccess_tck, jtag_set_end_state(TAP_IDLE));
-
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
 	 */
@@ -152,6 +140,18 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
 
 	jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
+	/* Add specified number of tck clocks after starting memory bus
+	 * access, giving the hardware time to complete the access.
+	 * They provide more time for the (MEM) AP to complete the read ...
+	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
+	 */
+	if ((instr == JTAG_DP_APACC)
+			&& ((reg_addr == AP_REG_DRW)
+				|| ((reg_addr & 0xF0) == AP_REG_BD0))
+			&& (swjdp->memaccess_tck != 0))
+		jtag_add_runtest(swjdp->memaccess_tck,
+				jtag_set_end_state(TAP_IDLE));
+
 	return jtag_get_error();
 }
 

commit 3b68a708c2b039d9b091608eccb2206725742a47
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:56:56 2010 -0800

    ADIv5: remove ATOMIC/COMPOSITE interface mode
    
    This removes context-sensitivity from the programming interface and makes
    it possible to know what a block of code does without needing to know the
    previous history (specifically, the DAP's "trans_mode" setting).
    
    The mode was only set to ATOMIC briefly after DAP initialization, making
    this patch be primarily cleanup; almost everything depends on COMPOSITE.
    The transactions which shouldn't have been queued were already properly
    flushing the queue.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 66b947e..819dd29 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -43,11 +43,16 @@
  * is used to access memory mapped resources and is called a MEM-AP.  Also a
  * JTAG-AP is also defined, bridging to JTAG resources; those are uncommon.
  *
- * @todo Remove modality (queued/nonqueued, via DAP trans_mode) from all
- * procedure interfaces.  Modal programming interfaces are very error prone.
- * Procedures should be either queued, or synchronous.  Otherwise input
- * and output constraints are context-sensitive, and it's hard to know
- * what a block of code will do just by reading it.
+ * This programming interface allows DAP pipelined operations through a
+ * transaction queue.  This primarily affects AP operations (such as using
+ * a MEM-AP to access memory or registers).  If the current transaction has
+ * not finished by the time the next one must begin, and the ORUNDETECT bit
+ * is set in the DP_CTRL_STAT register, the SSTICKYORUN status is set and
+ * further AP operations will fail.  There are two basic methods to avoid
+ * such overrun errors.  One involves polling for status instead of using
+ * transaction piplining.  The other involves adding delays to ensure the
+ * AP has enough time to complete one operation before starting the next
+ * one.  (For JTAG these delays are controlled by memaccess_tck.)
  */
 
 /*
@@ -67,17 +72,6 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
-/*
- * Transaction Mode:
- * swjdp->trans_mode = TRANS_MODE_COMPOSITE;
- * Uses Overrun checking mode and does not do actual JTAG send/receive or transaction
- * result checking until swjdp_end_transaction()
- * This must be done before using or deallocating any return variables.
- * swjdp->trans_mode == TRANS_MODE_ATOMIC
- * All reads and writes to the AHB bus are checked for valid completion, and return values
- * are immediatley available.
-*/
-
 
 /* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
 
@@ -191,47 +185,32 @@ static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 /**
  * Utility to write AP registers.
  */
-static int ap_write_check(struct swjdp_common *dap,
+static inline int ap_write_check(struct swjdp_common *dap,
 		uint8_t reg_addr, uint8_t *outvalue)
 {
-	adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
+	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
 			outvalue, NULL, NULL);
-
-	/* REVISIT except in dap_setup_accessport() almost all call paths
-	 * set up COMPOSITE.  Probably worth just inlining the scan...
-	 */
-
-	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
-	 * ack = OK/FAULT and the check CTRL_STAT
-	 */
-	if (dap->trans_mode == TRANS_MODE_ATOMIC)
-		return jtagdp_transaction_endcheck(dap);
-
-	return ERROR_OK;
 }
 
 static int scan_inout_check_u32(struct swjdp_common *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue)
 {
+	int retval;
+
 	/* Issue the read or write */
-	adi_jtag_dp_scan_u32(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
+	retval = adi_jtag_dp_scan_u32(swjdp, instr, reg_addr,
+			RnW, outvalue, NULL, NULL);
+	if (retval != ERROR_OK)
+		return retval;
 
 	/* For reads,  collect posted value; RDBUFF has no other effect.
 	 * Assumes read gets acked with OK/FAULT, and CTRL_STAT says "OK".
 	 */
 	if ((RnW == DPAP_READ) && (invalue != NULL))
-		adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
+		retval = adi_jtag_dp_scan_u32(swjdp, JTAG_DP_DPACC,
 				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
-
-	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
-	 * ack = OK/FAULT and then check CTRL_STAT
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&& (swjdp->trans_mode == TRANS_MODE_ATOMIC))
-		return jtagdp_transaction_endcheck(swjdp);
-
-	return ERROR_OK;
+	return retval;
 }
 
 int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
@@ -437,17 +416,13 @@ static int dap_ap_write_reg(struct swjdp_common *swjdp,
 }
 
 /**
- * Write an AP register value.
- * This is synchronous iff the mode is set to ATOMIC, in which
- * case any queued transactions are flushed.
+ * Asynchronous (queued) AP register write.
  *
  * @param swjdp The DAP whose currently selected AP will be written.
  * @param reg_addr Eight bit AP register address.
  * @param value Word to be written at reg_addr
  *
- * @return In synchronous mode: ERROR_OK for success, and the register holds
- * the specified value; else a fault code.  In asynchronous mode, a status
- * code reflecting whether the transaction was properly queued.
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
 int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t value)
@@ -460,17 +435,13 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 }
 
 /**
- * Read an AP register value.
- * This is synchronous iff the mode is set to ATOMIC, in which
- * case any queued transactions are flushed.
+ * Asynchronous (queued) AP register eread.
  *
  * @param swjdp The DAP whose currently selected AP will be read.
  * @param reg_addr Eight bit AP register address.
  * @param value Points to where the 32-bit (little-endian) word will be stored.
  *
- * @return In synchronous mode: ERROR_OK for success, and *value holds
- * the specified value; else a fault code.  In asynchronous mode, a status
- * code reflecting whether the transaction was properly queued.
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t *value)
@@ -486,9 +457,8 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 }
 
 /**
- * Set up transfer parameters for the currently selected MEM-AP.
- * This is synchronous iff the mode is set to ATOMIC, in which
- * case any queued transactions are flushed.
+ * Queue transactions setting up transfer parameters for the
+ * currently selected MEM-AP.
  *
  * Subsequent transfers using registers like AP_REG_DRW or AP_REG_BD2
  * initiate data reads or writes using memory or peripheral addresses.
@@ -503,9 +473,7 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
  * @param tar MEM-AP Transfer Address Register (TAR) to assign.  If this
  *	matches the cached address, the register is not changed.
  *
- * @return In synchronous mode: ERROR_OK for success, and the AP is set
- * up as requested else a fault code.  In asynchronous mode, a status
- * code reflecting whether the transaction was properly queued.
+ * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
 int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 {
@@ -550,8 +518,6 @@ int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
 {
 	int retval;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
@@ -603,8 +569,6 @@ int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
 {
 	int retval;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
@@ -652,8 +616,6 @@ int mem_ap_write_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	uint32_t adr = address;
 	uint8_t* pBuffer = buffer;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	count >>= 2;
 	wcount = count;
 
@@ -721,8 +683,6 @@ static int mem_ap_write_buf_packed_u16(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count >> 1;
 
 	while (wcount > 0)
@@ -799,8 +759,6 @@ int mem_ap_write_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	if (count >= 4)
 		return mem_ap_write_buf_packed_u16(swjdp, buffer, count, address);
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count > 0)
 	{
 		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
@@ -823,8 +781,6 @@ static int mem_ap_write_buf_packed_u8(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count;
 
 	while (wcount > 0)
@@ -896,8 +852,6 @@ int mem_ap_write_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	if (count >= 4)
 		return mem_ap_write_buf_packed_u8(swjdp, buffer, count, address);
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count > 0)
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
@@ -925,8 +879,6 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	uint32_t adr = address;
 	uint8_t* pBuffer = buffer;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	count >>= 2;
 	wcount = count;
 
@@ -1009,8 +961,6 @@ static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count >> 1;
 
 	while (wcount > 0)
@@ -1063,8 +1013,6 @@ int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	if (count >= 4)
 		return mem_ap_read_buf_packed_u16(swjdp, buffer, count, address);
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count > 0)
 	{
 		dap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
@@ -1105,8 +1053,6 @@ static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	wcount = count;
 
 	while (wcount > 0)
@@ -1156,8 +1102,6 @@ int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, u
 	if (count >= 4)
 		return mem_ap_read_buf_packed_u8(swjdp, buffer, count, address);
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	while (count > 0)
 	{
 		dap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
@@ -1203,7 +1147,6 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	dap_ap_select(swjdp, 0);
 
 	/* DP initialization */
-	swjdp->trans_mode = TRANS_MODE_ATOMIC;
 	dap_dp_read_reg(swjdp, &dummy, DP_CTRL_STAT);
 	dap_dp_write_reg(swjdp, SSTICKYERR, DP_CTRL_STAT);
 	dap_dp_read_reg(swjdp, &dummy, DP_CTRL_STAT);
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 746f1cb..316701e 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -118,13 +118,6 @@
 #define CSW_MASTER_DEBUG	(1 << 29)		/* ? */
 #define CSW_DBGSWENABLE		(1 << 31)
 
-/* transaction mode */
-#define TRANS_MODE_NONE			0
-/* Transaction waits for previous to complete */
-#define TRANS_MODE_ATOMIC		1
-/* Freerunning transactions with delays and overrun checking */
-#define TRANS_MODE_COMPOSITE	2
-
 /**
  * This represents an ARM Debug Interface (v5) Debug Access Port (DAP).
  * A DAP has two types of component:  one Debug Port (DP), which is a
@@ -170,9 +163,8 @@ struct swjdp_common
 	uint32_t ap_tar_value;
 
 	/* information about current pending SWjDP-AHBAP transaction */
-	uint8_t  trans_mode;
-	uint8_t  trans_rw;
 	uint8_t  ack;
+
 	/**
 	 * Configures how many extra tck clocks are added after starting a
 	 * MEM-AP access before we try to read its status (and/or result).
@@ -192,7 +184,7 @@ static inline uint8_t dap_ap_get_select(struct swjdp_common *swjdp)
 /* AP selection applies to future AP transactions */
 void dap_ap_select(struct swjdp_common *dap,uint8_t apsel);
 
-/* AP transactions ... synchronous given TRANS_MODE_ATOMIC */
+/* Queued AP transactions */
 int dap_setup_accessport(struct swjdp_common *swjdp,
 		uint32_t csw, uint32_t tar);
 int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 3dd9468..3ebc34a 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -70,8 +70,6 @@ static int cortexm3_dap_read_coreregister_u32(struct swjdp_common *swjdp,
 
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* mem_ap_write_u32(swjdp, DCB_DCRSR, regnum); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR & 0xFFFFFFF0);
 	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRSR & 0xC), regnum);
@@ -101,8 +99,6 @@ static int cortexm3_dap_write_coreregister_u32(struct swjdp_common *swjdp,
 
 	mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
 
-	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
-
 	/* mem_ap_write_u32(swjdp, DCB_DCRDR, core_regs[i]); */
 	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR & 0xFFFFFFF0);
 	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (DCB_DCRDR & 0xC), value);

commit ecff73043c1ddcc97d4d1ea1c87f251a850b22d4
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:54:54 2010 -0800

    ARM: ADIv5, deadcode cleanup
    
    I have no idea what the scan_inout_check() was *expecting* to achieve by
    issuing a read of the DP_RDBUFF register.  But in any case, that code was
    clearly never being called ("invalue" always NULL) ... so remove it, and
    the associated comment.
    
    Also rename it as ap_write_check(), facilitating a cleanup of its single
    call site by removing constant parameters.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index d7afb58..66b947e 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -188,23 +188,24 @@ static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 	return retval;
 }
 
-/* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */
-static int scan_inout_check(struct swjdp_common *swjdp,
-		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
-		uint8_t *outvalue, uint8_t *invalue)
+/**
+ * Utility to write AP registers.
+ */
+static int ap_write_check(struct swjdp_common *dap,
+		uint8_t reg_addr, uint8_t *outvalue)
 {
-	adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW, outvalue, NULL, NULL);
+	adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
+			outvalue, NULL, NULL);
 
-	if ((RnW == DPAP_READ) && (invalue != NULL))
-		adi_jtag_dp_scan(swjdp, JTAG_DP_DPACC,
-				DP_RDBUFF, DPAP_READ, 0, invalue, &swjdp->ack);
+	/* REVISIT except in dap_setup_accessport() almost all call paths
+	 * set up COMPOSITE.  Probably worth just inlining the scan...
+	 */
 
 	/* In TRANS_MODE_ATOMIC all JTAG_DP_APACC transactions wait for
 	 * ack = OK/FAULT and the check CTRL_STAT
 	 */
-	if ((instr == JTAG_DP_APACC)
-			&& (swjdp->trans_mode == TRANS_MODE_ATOMIC))
-		return jtagdp_transaction_endcheck(swjdp);
+	if (dap->trans_mode == TRANS_MODE_ATOMIC)
+		return jtagdp_transaction_endcheck(dap);
 
 	return ERROR_OK;
 }
@@ -432,8 +433,7 @@ static int dap_ap_write_reg(struct swjdp_common *swjdp,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_WRITE, out_value_buf, NULL);
+	return ap_write_check(swjdp, reg_addr, out_value_buf);
 }
 
 /**

commit 39cfe6279616a69b858ddd3493d61ed7133ff081
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:53:15 2010 -0800

    ARM: ADIv5 code shrinkage, cleanup
    
    adi_jtag_dp_scan_u32() now wraps adi_jtag_dp_scan(), removing
    code duplication.  Include doxygen for the former.  Comment
    some particularly relevant points.  Minor fault handling fixes
    for both routines:  don't register a callback that can't run,
    or return ERROR_OK after an error.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 1eff335..d7afb58 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -158,58 +158,34 @@ static int adi_jtag_dp_scan(struct swjdp_common *swjdp,
 
 	jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
-	return ERROR_OK;
+	return jtag_get_error();
 }
 
-/* Scan out and in from host ordered uint32_t variables */
+/**
+ * Scan DPACC or APACC out and in from host ordered uint32_t buffers.
+ * This is exactly like adi_jtag_dp_scan(), except that endianness
+ * conversions are performed (so the types of invalue and outvalue
+ * must be different).
+ */
 static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue, uint8_t *ack)
 {
-	struct arm_jtag *jtag_info = swjdp->jtag_info;
-	struct scan_field fields[2];
 	uint8_t out_value_buf[4];
-	uint8_t out_addr_buf;
-
-	jtag_set_end_state(TAP_IDLE);
-	arm_jtag_set_instr(jtag_info, instr, NULL);
-
-	/* Add specified number of tck clocks before accessing memory bus */
-
-	/* REVISIT these TCK cycles should be *AFTER*  updating APACC, since
-	 * they provide more time for the (MEM) AP to complete the read ...
-	 */
-	if ((instr == JTAG_DP_APACC)
-			&& ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr & 0xF0) == AP_REG_BD0))
-			&& (swjdp->memaccess_tck != 0))
-		jtag_add_runtest(swjdp->memaccess_tck, jtag_set_end_state(TAP_IDLE));
-
-	fields[0].tap = jtag_info->tap;
-	fields[0].num_bits = 3;
-	buf_set_u32(&out_addr_buf, 0, 3, ((reg_addr >> 1) & 0x6) | (RnW & 0x1));
-	fields[0].out_value = &out_addr_buf;
-	fields[0].in_value = ack;
+	int retval;
 
-	fields[1].tap = jtag_info->tap;
-	fields[1].num_bits = 32;
 	buf_set_u32(out_value_buf, 0, 32, outvalue);
-	fields[1].out_value = out_value_buf;
-	fields[1].in_value = NULL;
-
-	if (invalue)
-	{
-		fields[1].in_value = (uint8_t *)invalue;
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
 
-		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t) invalue);
-	} else
-	{
+	retval = adi_jtag_dp_scan(swjdp, instr, reg_addr, RnW,
+			out_value_buf, (uint8_t *)invalue, ack);
+	if (retval != ERROR_OK)
+		return retval;
 
-		jtag_add_dr_scan(2, fields, jtag_get_end_state());
-	}
+	if (invalue)
+		jtag_add_callback(arm_le_to_h_u32,
+				(jtag_callback_data_t) invalue);
 
-	return ERROR_OK;
+	return retval;
 }
 
 /* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */

commit a97bb67543eacde38f093610982812f714e7a050
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:51:19 2010 -0800

    ADIv5 clean up AP fault handling
    
    Pass up fault codes from various routines, so their callers
    can clean up after failures, and remove the FIXME comments
    highlighting those previously goofy code paths.
    
     dap_ap_{read,write}_reg_u32()
     dap_ap_write_reg()
     mem_ap_{read,write}_u32()
     mem_ap_{read,write}_atomic_u32()
     dap_setup_accessport()
    
    Make dap_ap_write_reg_u32() just wrap dap_ap_write_reg(),
    instead of cloning its core code (and broken fault handling).
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 2e3dafb..1eff335 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -450,12 +450,14 @@ static int dap_ap_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 static int dap_ap_write_reg(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint8_t *out_value_buf)
 {
-	dap_ap_bankselect(swjdp, reg_addr);
-	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_WRITE, out_value_buf, NULL);
+	int retval;
 
-	/* FIXME return fault code from above calls */
-	return ERROR_OK;
+	retval = dap_ap_bankselect(swjdp, reg_addr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
+			DPAP_WRITE, out_value_buf, NULL);
 }
 
 /**
@@ -477,12 +479,8 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 	uint8_t out_value_buf[4];
 
 	buf_set_u32(out_value_buf, 0, 32, value);
-	dap_ap_bankselect(swjdp, reg_addr);
-	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_WRITE, out_value_buf, NULL);
-
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	return dap_ap_write_reg(swjdp,
+			reg_addr, out_value_buf);
 }
 
 /**
@@ -501,12 +499,14 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t *value)
 {
-	dap_ap_bankselect(swjdp, reg_addr);
-	scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
-			DPAP_READ, 0, value);
+	int retval;
 
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	retval = dap_ap_bankselect(swjdp, reg_addr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
+			DPAP_READ, 0, value);
 }
 
 /**
@@ -533,19 +533,23 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
  */
 int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 {
+	int retval;
+
 	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT;
 	if (csw != swjdp->ap_csw_value)
 	{
 		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
-		/* FIXME if this call fails, fail this procedure! */
-		dap_ap_write_reg_u32(swjdp, AP_REG_CSW, csw);
+		retval = dap_ap_write_reg_u32(swjdp, AP_REG_CSW, csw);
+		if (retval != ERROR_OK)
+			return retval;
 		swjdp->ap_csw_value = csw;
 	}
 	if (tar != swjdp->ap_tar_value)
 	{
 		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
-		/* FIXME if this call fails, fail this procedure! */
-		dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar);
+		retval = dap_ap_write_reg_u32(swjdp, AP_REG_TAR, tar);
+		if (retval != ERROR_OK)
+			return retval;
 		swjdp->ap_tar_value = tar;
 	}
 	/* Disable TAR cache when autoincrementing */
@@ -568,17 +572,19 @@ int dap_setup_accessport(struct swjdp_common *swjdp, uint32_t csw, uint32_t tar)
 int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t *value)
 {
+	int retval;
+
 	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
 
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
 			address & 0xFFFFFFF0);
-	dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC), value);
+	if (retval != ERROR_OK)
+		return retval;
 
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	return dap_ap_read_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC), value);
 }
 
 /**
@@ -596,8 +602,11 @@ int mem_ap_read_u32(struct swjdp_common *swjdp, uint32_t address,
 int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t *value)
 {
-	mem_ap_read_u32(swjdp, address, value);
-	/* FIXME return any fault code from above call */
+	int retval;
+
+	retval = mem_ap_read_u32(swjdp, address, value);
+	if (retval != ERROR_OK)
+		return retval;
 
 	return jtagdp_transaction_endcheck(swjdp);
 }
@@ -616,17 +625,20 @@ int mem_ap_read_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t value)
 {
+	int retval;
+
 	swjdp->trans_mode = TRANS_MODE_COMPOSITE;
 
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
-	dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
+	retval = dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF,
 			address & 0xFFFFFFF0);
-	dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC), value);
+	if (retval != ERROR_OK)
+		return retval;
 
-	/* FIXME return any fault code from above calls */
-	return ERROR_OK;
+	return dap_ap_write_reg_u32(swjdp, AP_REG_BD0 | (address & 0xC),
+			value);
 }
 
 /**
@@ -643,8 +655,10 @@ int mem_ap_write_u32(struct swjdp_common *swjdp, uint32_t address,
 int mem_ap_write_atomic_u32(struct swjdp_common *swjdp, uint32_t address,
 		uint32_t value)
 {
-	mem_ap_write_u32(swjdp, address, value);
-	/* FIXME return any fault code from above call */
+	int retval = mem_ap_write_u32(swjdp, address, value);
+
+	if (retval != ERROR_OK)
+		return retval;
 
 	return jtagdp_transaction_endcheck(swjdp);
 }

commit 249263d29da11b0ec981c2e0d520cd7dcf08939b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:48:04 2010 -0800

    ADIv5 clean up AP selection and register caching
    
    Handling of AP (and AP register bank) selection, and cached AP
    registers, is pretty loose ... start tightening it:
    
     - It's "AP bank" select support ... there are no DP banks.  Rename.
       + dap_dp_bankselect() becomes dap_ap_bankselect()
       + "dp_select_value" struct field becomes "ap_bank_value"
    
     - Remove duplicate AP cache init paths ... only use dap_ap_select(),
     and don't make Cortex (A8 or M3) cores roll their own code.
    
     - For dap_ap_bankselect(), pass up any fault code from writing
     the SELECT register.  (Nothing yet checks those codes.)
    
     - Add various bits of Doxygen
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 94c8ed8..2e3dafb 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -349,7 +349,7 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 					"ap_bank 0x%" PRIx32
 					", ap_csw 0x%" PRIx32
 					", ap_tar 0x%" PRIx32,
-					swjdp->dp_select_value,
+					swjdp->ap_bank_value,
 					swjdp->ap_csw_value,
 					swjdp->ap_tar_value);
 
@@ -419,38 +419,38 @@ static int dap_dp_read_reg(struct swjdp_common *swjdp,
  */
 void dap_ap_select(struct swjdp_common *swjdp,uint8_t apsel)
 {
-	uint32_t select;
-	select = (apsel << 24) & 0xFF000000;
+	uint32_t select = (apsel << 24) & 0xFF000000;
 
 	if (select != swjdp->apsel)
 	{
 		swjdp->apsel = select;
-		/* Switching AP invalidates cached values */
-		swjdp->dp_select_value = -1;
+		/* Switching AP invalidates cached values.
+		 * Values MUST BE UPDATED BEFORE AP ACCESS.
+		 */
+		swjdp->ap_bank_value = -1;
 		swjdp->ap_csw_value = -1;
 		swjdp->ap_tar_value = -1;
 	}
 }
 
-static int dap_dp_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
+/** Select the AP register bank matching bits 7:4 of ap_reg. */
+static int dap_ap_bankselect(struct swjdp_common *swjdp, uint32_t ap_reg)
 {
-	uint32_t select;
-	select = (ap_reg & 0x000000F0);
+	uint32_t select = (ap_reg & 0x000000F0);
 
-	if (select != swjdp->dp_select_value)
+	if (select != swjdp->ap_bank_value)
 	{
-		dap_dp_write_reg(swjdp, select | swjdp->apsel, DP_SELECT);
-		swjdp->dp_select_value = select;
-	}
-
-	/* FIXME return any fault code from write() call */
-	return ERROR_OK;
+		swjdp->ap_bank_value = select;
+		select |= swjdp->apsel;
+		return dap_dp_write_reg(swjdp, select, DP_SELECT);
+	} else
+		return ERROR_OK;
 }
 
 static int dap_ap_write_reg(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint8_t *out_value_buf)
 {
-	dap_dp_bankselect(swjdp, reg_addr);
+	dap_ap_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_WRITE, out_value_buf, NULL);
 
@@ -477,7 +477,7 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 	uint8_t out_value_buf[4];
 
 	buf_set_u32(out_value_buf, 0, 32, value);
-	dap_dp_bankselect(swjdp, reg_addr);
+	dap_ap_bankselect(swjdp, reg_addr);
 	scan_inout_check(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_WRITE, out_value_buf, NULL);
 
@@ -501,7 +501,7 @@ int dap_ap_write_reg_u32(struct swjdp_common *swjdp,
 int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 		uint32_t reg_addr, uint32_t *value)
 {
-	dap_dp_bankselect(swjdp, reg_addr);
+	dap_ap_bankselect(swjdp, reg_addr);
 	scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_READ, 0, value);
 
@@ -1206,12 +1206,11 @@ int ahbap_debugport_init(struct swjdp_common *swjdp)
 	/* Default MEM-AP setup.
 	 *
 	 * REVISIT AP #0 may be an inappropriate default for this.
-	 * Should we probe, or receve a hint from the caller?
+	 * Should we probe, or take a hint from the caller?
 	 * Presumably we can ignore the possibility of multiple APs.
 	 */
-	swjdp->apsel = 0;
-	swjdp->ap_csw_value = -1;
-	swjdp->ap_tar_value = -1;
+	swjdp->apsel = !0;
+	dap_ap_select(swjdp, 0);
 
 	/* DP initialization */
 	swjdp->trans_mode = TRANS_MODE_ATOMIC;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 759f233..746f1cb 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -138,17 +138,45 @@ struct swjdp_common
 	struct arm_jtag *jtag_info;
 	/* Control config */
 	uint32_t dp_ctrl_stat;
-	/* Support for several AP's in one DAP */
+
+	/**
+	 * Cache for DP_SELECT bits identifying the current AP.  A DAP may
+	 * connect to multiple APs, such as one MEM-AP for general access,
+	 * another reserved for accessing debug modules, and a JTAG-DP.
+	 * "-1" indicates no cached value.
+	 */
 	uint32_t apsel;
-	/* Register select cache */
-	uint32_t dp_select_value;
+
+	/**
+	 * Cache for DP_SELECT bits identifying the current four-word AP
+	 * register bank.  This caches AP register addresss bits 7:4; JTAG
+	 * and SWD access primitves pass address bits 3:2; bits 1:0 are zero.
+	 * "-1" indicates no cached value.
+	 */
+	uint32_t ap_bank_value;
+
+	/**
+	 * Cache for (MEM-AP) AP_REG_CSW register value.  This is written to
+	 * configure an access mode, such as autoincrementing AP_REG_TAR during
+	 * word access.  "-1" indicates no cached value.
+	 */
 	uint32_t ap_csw_value;
+
+	/**
+	 * Cache for (MEM-AP) AP_REG_TAR register value This is written to
+	 * configure the address being read or written
+	 * "-1" indicates no cached value.
+	 */
 	uint32_t ap_tar_value;
+
 	/* information about current pending SWjDP-AHBAP transaction */
 	uint8_t  trans_mode;
 	uint8_t  trans_rw;
 	uint8_t  ack;
-	/* extra tck clocks for memory bus access */
+	/**
+	 * Configures how many extra tck clocks are added after starting a
+	 * MEM-AP access before we try to read its status (and/or result).
+	 */
 	uint32_t	memaccess_tck;
 	/* Size of TAR autoincrement block, ARM ADI Specification requires at least 10 bits */
 	uint32_t tar_autoincr_block;
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 050238c..f4818f8 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -53,7 +53,9 @@ static int cortex_a8_dap_write_coreregister_u32(struct target *target,
 		uint32_t value, int regnum);
 /*
  * FIXME do topology discovery using the ROM; don't
- * assume this is an OMAP3.
+ * assume this is an OMAP3.   Also, allow for multiple ARMv7-A
+ * cores, with different AP numbering ... don't use a #define
+ * for these numbers, use per-core armv7a state.
  */
 #define swjdp_memoryap 0
 #define swjdp_debugap 1
@@ -1570,9 +1572,7 @@ static int cortex_a8_init_arch_info(struct target *target,
 	cortex_a8->jtag_info.tap = tap;
 	cortex_a8->jtag_info.scann_size = 4;
 
-	swjdp->dp_select_value = -1;
-	swjdp->ap_csw_value = -1;
-	swjdp->ap_tar_value = -1;
+	/* Leave (only) generic DAP stuff for debugport_init() */
 	swjdp->jtag_info = &cortex_a8->jtag_info;
 	swjdp->memaccess_tck = 80;
 
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index a3b3d42..3dd9468 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -1848,12 +1848,11 @@ static int cortex_m3_init_arch_info(struct target *target,
 	cortex_m3->jtag_info.tap = tap;
 	cortex_m3->jtag_info.scann_size = 4;
 
-	armv7m->swjdp_info.dp_select_value = -1;
-	armv7m->swjdp_info.ap_csw_value = -1;
-	armv7m->swjdp_info.ap_tar_value = -1;
+	/* Leave (only) generic DAP stuff for debugport_init(); */
 	armv7m->swjdp_info.jtag_info = &cortex_m3->jtag_info;
 	armv7m->swjdp_info.memaccess_tck = 8;
-	armv7m->swjdp_info.tar_autoincr_block = (1 << 12);	/* Cortex-M3 has 4096 bytes autoincrement range */
+	/* Cortex-M3 has 4096 bytes autoincrement range */
+	armv7m->swjdp_info.tar_autoincr_block = (1 << 12);
 
 	/* register arch-specific functions */
 	armv7m->examine_debug_reason = cortex_m3_examine_debug_reason;

commit 1aac72d24339380f6e98c50dec4c96ab30537749
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:34:33 2010 -0800

    ARM: keep a handle to the PC
    
    Keep a handle to the PC in "struct arm", and use it.
    This register is used a fair amount, so this is a net
    minor code shrink (other than some line length fixes),
    but mostly it's to make things more readable.
    
    For XScale, fix a dodgy sequence while stepping.  It
    was initializing a variable to a non-NULL value, then
    updating it to handle the step-over-active-breakpoint
    case, and then later testing for non-NULL to see if
    it should reverse that step-over-active logic.  It
    should have done like ARM7/ARM9 does: init to NULL.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm.h b/src/target/arm.h
index c72b194..6b304e9 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -95,6 +95,9 @@ struct arm {
 	int common_magic;
 	struct reg_cache *core_cache;
 
+	/** Handle to the PC; valid in all core modes. */
+	struct reg *pc;
+
 	/** Handle to the CPSR; valid in all core modes. */
 	struct reg *cpsr;
 
diff --git a/src/target/arm11.c b/src/target/arm11.c
index 678d8ac..51be701 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -451,7 +451,7 @@ static int arm11_halt(struct target *target)
 static uint32_t
 arm11_nextpc(struct arm11_common *arm11, int current, uint32_t address)
 {
-	void *value = arm11->arm.core_cache->reg_list[15].value;
+	void *value = arm11->arm.pc->value;
 
 	if (!current)
 		buf_set_u32(value, 0, 32, address);
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index efafa5e..2275935 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -361,9 +361,9 @@ static int arm720t_soft_reset_halt(struct target *target)
 	armv4_5->cpsr->dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, 0x0);
-	armv4_5->core_cache->reg_list[15].dirty = 1;
-	armv4_5->core_cache->reg_list[15].valid = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, 0x0);
+	armv4_5->pc->dirty = 1;
+	armv4_5->pc->valid = 1;
 
 	arm720t_disable_mmu_caches(target, 1, 1, 1);
 	arm720t->armv4_5_mmu.mmu_enabled = 0;
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 509e91e..2176729 100644
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -1235,9 +1235,9 @@ int arm7_9_soft_reset_halt(struct target *target)
 	armv4_5->cpsr->dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, 0x0);
-	armv4_5->core_cache->reg_list[15].dirty = 1;
-	armv4_5->core_cache->reg_list[15].valid = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, 0x0);
+	armv4_5->pc->dirty = 1;
+	armv4_5->pc->valid = 1;
 
 	/* reset registers */
 	for (i = 0; i <= 14; i++)
@@ -1721,9 +1721,10 @@ int arm7_9_restore_context(struct target *target)
 	}
 
 	/* restore PC */
-	LOG_DEBUG("writing PC with value 0x%8.8" PRIx32 "", buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
-	arm7_9->write_pc(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
-	armv4_5->core_cache->reg_list[15].dirty = 0;
+	LOG_DEBUG("writing PC with value 0x%8.8" PRIx32,
+			buf_get_u32(armv4_5->pc->value, 0, 32));
+	arm7_9->write_pc(target, buf_get_u32(armv4_5->pc->value, 0, 32));
+	armv4_5->pc->dirty = 0;
 
 	if (arm7_9->post_restore_context)
 		arm7_9->post_restore_context(target);
@@ -1815,15 +1816,17 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current)
-		buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5->pc->value, 0, 32, address);
 
 	uint32_t current_pc;
-	current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
 	{
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32))))
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(armv4_5->pc->value, 0, 32));
+		if (breakpoint != NULL)
 		{
 			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (id: %d)", breakpoint->address, breakpoint->unique_id );
 			if ((retval = arm7_9_unset_breakpoint(target, breakpoint)) != ERROR_OK)
@@ -1881,7 +1884,8 @@ int arm7_9_resume(struct target *target, int current, uint32_t address, int hand
 			}
 
 			arm7_9_debug_entry(target);
-			LOG_DEBUG("new PC after step: 0x%8.8" PRIx32 "", buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
+			LOG_DEBUG("new PC after step: 0x%8.8" PRIx32,
+					buf_get_u32(armv4_5->pc->value, 0, 32));
 
 			LOG_DEBUG("set breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
 			if ((retval = arm7_9_set_breakpoint(target, breakpoint)) != ERROR_OK)
@@ -1957,7 +1961,7 @@ void arm7_9_enable_eice_step(struct target *target, uint32_t next_pc)
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	struct arm *armv4_5 = &arm7_9->armv4_5_common;
 	uint32_t current_pc;
-	current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	if (next_pc != current_pc)
 	{
@@ -2019,18 +2023,18 @@ int arm7_9_step(struct target *target, int current, uint32_t address, int handle
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current)
-		buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5->pc->value, 0, 32, address);
 
-	uint32_t current_pc;
-	current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	uint32_t current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32))))
-			if ((retval = arm7_9_unset_breakpoint(target, breakpoint)) != ERROR_OK)
-			{
-				return retval;
-			}
+		breakpoint = breakpoint_find(target, current_pc);
+	if (breakpoint != NULL) {
+		retval = arm7_9_unset_breakpoint(target, breakpoint);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	target->debug_reason = DBG_REASON_SINGLESTEP;
 
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 16f16b0..530a675 100644
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -598,7 +598,8 @@ static void arm7tdmi_branch_resume_thumb(struct target *target)
 	/* fetch NOP, LDM in EXECUTE stage (1st cycle) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (2nd cycle) */
-	arm7tdmi_clock_out(jtag_info, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32) | 1, NULL, 0);
+	arm7tdmi_clock_out(jtag_info,
+			buf_get_u32(armv4_5->pc->value, 0, 32) | 1, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (3rd cycle) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index 3e61545..152edcf 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -777,9 +777,9 @@ int arm920t_soft_reset_halt(struct target *target)
 	armv4_5->cpsr->dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, 0x0);
-	armv4_5->core_cache->reg_list[15].dirty = 1;
-	armv4_5->core_cache->reg_list[15].valid = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, 0x0);
+	armv4_5->pc->dirty = 1;
+	armv4_5->pc->valid = 1;
 
 	arm920t_disable_mmu_caches(target, 1, 1, 1);
 	arm920t->armv4_5_mmu.mmu_enabled = 0;
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 32ecf72..d811196 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -569,9 +569,9 @@ int arm926ejs_soft_reset_halt(struct target *target)
 	armv4_5->cpsr->dirty = 1;
 
 	/* start fetching from 0x0 */
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, 0x0);
-	armv4_5->core_cache->reg_list[15].dirty = 1;
-	armv4_5->core_cache->reg_list[15].valid = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, 0x0);
+	armv4_5->pc->dirty = 1;
+	armv4_5->pc->valid = 1;
 
 	arm926ejs_disable_mmu_caches(target, 1, 1, 1);
 	arm926ejs->armv4_5_mmu.mmu_enabled = 0;
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 761e7cf..77b01b1 100644
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -677,7 +677,8 @@ static void arm9tdmi_branch_resume_thumb(struct target *target)
 	/* fetch NOP, LDM in EXECUTE stage (1st cycle) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (2nd cycle) */
-	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32) | 1, NULL, 0);
+	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP,
+			buf_get_u32(armv4_5->pc->value, 0, 32) | 1, NULL, 0);
 	/* nothing fetched, LDM in EXECUTE stage (3rd cycle) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 0b5e255..8e8cc17 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -453,8 +453,8 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	retval = dpm_modeswitch(dpm, ARM_MODE_ANY);
 	arm->cpsr->dirty = false;
 
-	retval = dpm_write_reg(dpm, &cache->reg_list[15], 15);
-	cache->reg_list[15].dirty = false;
+	retval = dpm_write_reg(dpm, arm->pc, 15);
+	arm->pc->dirty = false;
 
 	/* flush R0 -- it's *very* dirty by now */
 	retval = dpm_write_reg(dpm, &cache->reg_list[0], 0);
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 9b853d9..24a4de5 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -393,8 +393,8 @@ static int do_semihosting(struct target *target)
 	armv4_5->core_cache->reg_list[0].dirty = 1;
 
 	/* LR --> PC */
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, lr);
-	armv4_5->core_cache->reg_list[15].dirty = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, lr);
+	armv4_5->pc->dirty = 1;
 
 	/* saved PSR --> current PSR */
 	buf_set_u32(armv4_5->cpsr->value, 0, 32, spsr);
@@ -429,7 +429,7 @@ int arm_semihosting(struct target *target, int *retval)
 		return 0;
 
 	/* Check for PC == 0x00000008 or 0xffff0008: Supervisor Call vector. */
-	r = arm->core_cache->reg_list + 15;
+	r = arm->pc;
 	pc = buf_get_u32(r->value, 0, 32);
 	if (pc != 0x00000008 && pc != 0xffff0008)
 		return 0;
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index 8d3a891..a4a15b4 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -577,6 +577,7 @@ struct reg_cache *arm_build_reg_cache(struct target *target, struct arm *arm)
 		cache->num_regs++;
 	}
 
+	arm->pc = reg_list + 15;
 	arm->cpsr = reg_list + ARMV4_5_CPSR;
 	arm->core_cache = cache;
 	return cache;
@@ -598,8 +599,7 @@ int arm_arch_state(struct target *target)
 			debug_reason_name(target),
 			arm_mode_name(armv4_5->core_mode),
 			buf_get_u32(armv4_5->cpsr->value, 0, 32),
-			buf_get_u32(armv4_5->core_cache->reg_list[15].value,
-					0, 32),
+			buf_get_u32(armv4_5->pc->value, 0, 32),
 			armv4_5->is_semihosting ? ", semihosting" : "");
 
 	return ERROR_OK;
@@ -1018,11 +1018,10 @@ static int armv4_5_run_algorithm_completion(struct target *target, uint32_t exit
 	}
 
 	/* fast exit: ARMv5+ code can use BKPT */
-	if (exit_point && buf_get_u32(armv4_5->core_cache->reg_list[15].value,
-				0, 32) != exit_point)
+	if (exit_point && buf_get_u32(armv4_5->pc->value, 0, 32) != exit_point)
 	{
 		LOG_WARNING("target reentered debug state, but not at the desired exit point: 0x%4.4" PRIx32 "",
-			buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
+			buf_get_u32(armv4_5->pc->value, 0, 32));
 		return ERROR_TARGET_TIMEOUT;
 	}
 
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index faa886b..466c0b2 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -282,7 +282,7 @@ int armv7m_get_gdb_reg_list(struct target *target, struct reg **reg_list[], int
 
 	/* ARMV7M is always in thumb mode, try to make GDB understand this
 	 * if it does not support this arch */
-	*((char*)armv7m->core_cache->reg_list[15].value) |= 1;
+	*((char*)armv7m->arm.pc->value) |= 1;
 #else
 	(*reg_list)[25] = &armv7m->core_cache->reg_list[ARMV7M_xPSR];
 #endif
@@ -485,7 +485,7 @@ int armv7m_arch_state(struct target *target)
 		armv7m_mode_strings[armv7m->core_mode],
 		armv7m_exception_string(armv7m->exception_number),
 		buf_get_u32(arm->cpsr->value, 0, 32),
-		buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_PC].value, 0, 32),
+		buf_get_u32(arm->pc->value, 0, 32),
 		(ctrl & 0x02) ? 'p' : 'm',
 		sp);
 
@@ -535,6 +535,7 @@ struct reg_cache *armv7m_build_reg_cache(struct target *target)
 	}
 
 	arm->cpsr = reg_list + ARMV7M_xPSR;
+	arm->pc = reg_list + ARMV7M_PC;
 	arm->core_cache = cache;
 	return cache;
 }
@@ -708,7 +709,7 @@ int armv7m_blank_check_memory(struct target *target,
 int armv7m_maybe_skip_bkpt_inst(struct target *target, bool *inst_found)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct reg *r = armv7m->core_cache->reg_list + 15;
+	struct reg *r = armv7m->arm.pc;
 	bool result = false;
 
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index bcdb526..050238c 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -695,9 +695,7 @@ static int cortex_a8_resume(struct target *target, int current,
 #endif
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
-	resume_pc = buf_get_u32(
-			armv4_5->core_cache->reg_list[15].value,
-			0, 32);
+	resume_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 	if (!current)
 		resume_pc = address;
 
@@ -721,10 +719,9 @@ static int cortex_a8_resume(struct target *target, int current,
 		return ERROR_FAIL;
 	}
 	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value,
-			0, 32, resume_pc);
-	armv4_5->core_cache->reg_list[15].dirty = 1;
-	armv4_5->core_cache->reg_list[15].valid = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, resume_pc);
+	armv4_5->pc->dirty = 1;
+	armv4_5->pc->valid = 1;
 
 	cortex_a8_restore_context(target, handle_breakpoints);
 
@@ -869,7 +866,7 @@ static int cortex_a8_debug_entry(struct target *target)
 			regfile[ARM_PC] -= 8;
 		}
 
-		reg = armv4_5->core_cache->reg_list + 15;
+		reg = armv4_5->pc;
 		buf_set_u32(reg->value, 0, 32, regfile[ARM_PC]);
 		reg->dirty = reg->valid;
 	}
@@ -952,7 +949,7 @@ static int cortex_a8_step(struct target *target, int current, uint32_t address,
 	}
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
-	r = armv4_5->core_cache->reg_list + 15;
+	r = armv4_5->pc;
 	if (!current)
 	{
 		buf_set_u32(r->value, 0, 32, address);
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index fbc879f..a3b3d42 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -427,7 +427,7 @@ static int cortex_m3_debug_entry(struct target *target)
 
 	LOG_DEBUG("entered debug state in core mode: %s at PC 0x%" PRIx32 ", target->state: %s",
 		armv7m_mode_strings[armv7m->core_mode],
-		*(uint32_t*)(armv7m->core_cache->reg_list[15].value),
+		*(uint32_t*)(arm->pc->value),
 		target_state_name(target));
 
 	if (armv7m->post_debug_entry)
@@ -680,7 +680,7 @@ static int cortex_m3_resume(struct target *target, int current,
 	}
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
-	r = armv7m->core_cache->reg_list + 15;
+	r = armv7m->arm.pc;
 	if (!current)
 	{
 		buf_set_u32(r->value, 0, 32, address);
@@ -749,7 +749,7 @@ static int cortex_m3_step(struct target *target, int current,
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 	struct breakpoint *breakpoint = NULL;
-	struct reg *pc = armv7m->core_cache->reg_list + 15;
+	struct reg *pc = armv7m->arm.pc;
 	bool bkpt_inst_found = false;
 
 	if (target->state != TARGET_HALTED)
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
index 19ed0cd..e0c3c39 100644
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -337,7 +337,7 @@ void feroceon_branch_resume_thumb(struct target *target)
 	struct arm7_9_common *arm7_9 = armv4_5->arch_info;
 	struct arm_jtag *jtag_info = &arm7_9->jtag_info;
 	uint32_t r0 = buf_get_u32(armv4_5->core_cache->reg_list[0].value, 0, 32);
-	uint32_t pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	uint32_t pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -519,7 +519,7 @@ int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 	/* backup clobbered processor state */
 	for (i = 0; i <= 5; i++)
 		save[i] = buf_get_u32(armv4_5->core_cache->reg_list[i].value, 0, 32);
-	save[i] = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	save[i] = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	/* set up target address in r0 */
 	buf_set_u32(armv4_5->core_cache->reg_list[0].value, 0, 32, address);
@@ -572,9 +572,9 @@ int feroceon_bulk_write_memory(struct target *target, uint32_t address, uint32_t
 		armv4_5->core_cache->reg_list[i].valid = 1;
 		armv4_5->core_cache->reg_list[i].dirty = 1;
 	}
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, save[i]);
-	armv4_5->core_cache->reg_list[15].valid = 1;
-	armv4_5->core_cache->reg_list[15].dirty = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, save[i]);
+	armv4_5->pc->valid = 1;
+	armv4_5->pc->dirty = 1;
 	armv4_5->core_state = core_state;
 
 	return retval;
diff --git a/src/target/xscale.c b/src/target/xscale.c
index fc71ea3..48dbc47 100644
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -941,9 +941,9 @@ static int xscale_debug_entry(struct target *target)
 	LOG_DEBUG("r0: 0x%8.8" PRIx32 "", buffer[0]);
 
 	/* move pc from buffer to register cache */
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, buffer[1]);
-	armv4_5->core_cache->reg_list[15].dirty = 1;
-	armv4_5->core_cache->reg_list[15].valid = 1;
+	buf_set_u32(armv4_5->pc->value, 0, 32, buffer[1]);
+	armv4_5->pc->dirty = 1;
+	armv4_5->pc->valid = 1;
 	LOG_DEBUG("pc: 0x%8.8" PRIx32 "", buffer[1]);
 
 	/* move data from buffer to register cache */
@@ -995,7 +995,7 @@ static int xscale_debug_entry(struct target *target)
 	moe = buf_get_u32(xscale->reg_cache->reg_list[XSCALE_DCSR].value, 2, 3);
 
 	/* stored PC (for calculating fixup) */
-	pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	switch (moe)
 	{
@@ -1042,7 +1042,7 @@ static int xscale_debug_entry(struct target *target)
 	}
 
 	/* apply PC fixup */
-	buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, pc);
+	buf_set_u32(armv4_5->pc->value, 0, 32, pc);
 
 	/* on the first debug entry, identify cache type */
 	if (xscale->armv4_5_mmu.armv4_5_cache.ctype == -1)
@@ -1212,21 +1212,23 @@ static int xscale_resume(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current)
-		buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5->pc->value, 0, 32, address);
 
-	current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	/* if we're at the reset vector, we have to simulate the branch */
 	if (current_pc == 0x0)
 	{
 		arm_simulate_step(target, NULL);
-		current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+		current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 	}
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
 	{
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32))))
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(armv4_5->pc->value, 0, 32));
+		if (breakpoint != NULL)
 		{
 			uint32_t next_pc;
 
@@ -1272,8 +1274,10 @@ static int xscale_resume(struct target *target, int current,
 			}
 
 			/* send PC */
-			xscale_send_u32(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
-			LOG_DEBUG("writing PC with value 0x%8.8" PRIx32 "", buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
+			xscale_send_u32(target,
+					buf_get_u32(armv4_5->pc->value, 0, 32));
+			LOG_DEBUG("writing PC with value 0x%8.8" PRIx32,
+					buf_get_u32(armv4_5->pc->value, 0, 32));
 
 			/* wait for and process debug entry */
 			xscale_debug_entry(target);
@@ -1316,8 +1320,9 @@ static int xscale_resume(struct target *target, int current,
 	}
 
 	/* send PC */
-	xscale_send_u32(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
-	LOG_DEBUG("writing PC with value 0x%8.8" PRIx32 "", buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
+	xscale_send_u32(target, buf_get_u32(armv4_5->pc->value, 0, 32));
+	LOG_DEBUG("wrote PC with value 0x%8.8" PRIx32,
+			buf_get_u32(armv4_5->pc->value, 0, 32));
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
 
@@ -1354,7 +1359,7 @@ static int xscale_step_inner(struct target *target, int current,
 	if ((retval = arm_simulate_step(target, &next_pc)) != ERROR_OK)
 	{
 		uint32_t current_opcode, current_pc;
-		current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+		current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 		target_read_u32(target, current_pc, &current_opcode);
 		LOG_ERROR("BUG: couldn't calculate PC of next instruction, current opcode was 0x%8.8" PRIx32 "", current_opcode);
@@ -1399,9 +1404,12 @@ static int xscale_step_inner(struct target *target, int current,
 	}
 
 	/* send PC */
-	if ((retval = xscale_send_u32(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32))) != ERROR_OK)
+	retval = xscale_send_u32(target,
+			buf_get_u32(armv4_5->pc->value, 0, 32));
+	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG("writing PC with value 0x%8.8" PRIx32, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32));
+	LOG_DEBUG("wrote PC with value 0x%8.8" PRIx32,
+			buf_get_u32(armv4_5->pc->value, 0, 32));
 
 	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 
@@ -1425,7 +1433,7 @@ static int xscale_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints)
 {
 	struct arm *armv4_5 = target_to_arm(target);
-	struct breakpoint *breakpoint = target->breakpoints;
+	struct breakpoint *breakpoint = NULL;
 
 	uint32_t current_pc;
 	int retval;
@@ -1438,16 +1446,16 @@ static int xscale_step(struct target *target, int current,
 
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	if (!current)
-		buf_set_u32(armv4_5->core_cache->reg_list[15].value, 0, 32, address);
+		buf_set_u32(armv4_5->pc->value, 0, 32, address);
 
-	current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 	/* if we're at the reset vector, we have to simulate the step */
 	if (current_pc == 0x0)
 	{
 		if ((retval = arm_simulate_step(target, NULL)) != ERROR_OK)
 			return retval;
-		current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+		current_pc = buf_get_u32(armv4_5->pc->value, 0, 32);
 
 		target->debug_reason = DBG_REASON_SINGLESTEP;
 		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
@@ -1457,11 +1465,13 @@ static int xscale_step(struct target *target, int current,
 
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
-		if ((breakpoint = breakpoint_find(target, buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32))))
-		{
-			if ((retval = xscale_unset_breakpoint(target, breakpoint)) != ERROR_OK)
-				return retval;
-		}
+		breakpoint = breakpoint_find(target,
+				buf_get_u32(armv4_5->pc->value, 0, 32));
+	if (breakpoint != NULL) {
+		retval = xscale_unset_breakpoint(target, breakpoint);
+		if (retval != ERROR_OK)
+			return retval;
+	}
 
 	retval = xscale_step_inner(target, current, address, handle_breakpoints);
 
@@ -2568,7 +2578,8 @@ static int xscale_read_trace(struct target *target)
 	(*trace_data_p)->next = NULL;
 	(*trace_data_p)->chkpt0 = trace_buffer[256];
 	(*trace_data_p)->chkpt1 = trace_buffer[257];
-	(*trace_data_p)->last_instruction = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+	(*trace_data_p)->last_instruction =
+			buf_get_u32(armv4_5->pc->value, 0, 32);
 	(*trace_data_p)->entries = malloc(sizeof(struct xscale_trace_entry) * (256 - j));
 	(*trace_data_p)->depth = 256 - j;
 
@@ -3375,7 +3386,8 @@ COMMAND_HANDLER(xscale_handle_trace_buffer_command)
 		/* if we enable the trace buffer in fill-once
 		 * mode we know the address of the first instruction */
 		xscale->trace.pc_ok = 1;
-		xscale->trace.current_pc = buf_get_u32(armv4_5->core_cache->reg_list[15].value, 0, 32);
+		xscale->trace.current_pc =
+				buf_get_u32(armv4_5->pc->value, 0, 32);
 	}
 	else
 	{

commit a299371a9ec109da3851cb43aed3e9157d095358
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:32:34 2010 -0800

    ARM DPM: support adding/removing HW breakpoints
    
    Generalize the core of watchpoint setup so that it can handle
    breakpoints too.  Create breakpoint add/remove routines which
    will use that, and hook them up to target types which don't
    provide their own breakpoint support (nothing, yet).
    
    This suffices for hardware-only breakpoint support.  The ARM11
    code will be able to switch over to this without much trouble,
    since it doesn't yet handle software breakpoints.  Switching
    Cortex-A8 will be a bit more involved.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 3c18e63..0b5e255 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -320,14 +320,17 @@ static int dpm_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
 				xp->address, xp->control);
 
 	if (retval != ERROR_OK)
-		LOG_ERROR("%s: can't %s HW bp/wp %d",
+		LOG_ERROR("%s: can't %s HW %spoint %d",
 				disable ? "disable" : "enable",
 				target_name(dpm->arm->target),
-				xp->number);
+				(xp->number < 16) ? "break" : "watch",
+				xp->number & 0xf);
 done:
 	return retval;
 }
 
+static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp);
+
 /**
  * Writes all modified core registers for all processor modes.  In normal
  * operation this is called on exit from halting debug state.
@@ -354,7 +357,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * we should be able to assume we handle them; but until then,
 	 * cope with the hand-crafted breakpoint code.
 	 */
-	if (0) {
+	if (arm->target->type->add_breakpoint == dpm_add_breakpoint) {
 		for (unsigned i = 0; i < dpm->nbp; i++) {
 			struct dpm_bp *dbp = dpm->dbp + i;
 			struct breakpoint *bp = dbp->bp;
@@ -665,43 +668,26 @@ done:
  * fact isn't currently leveraged.
  */
 
-static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
-		struct watchpoint *wp)
+static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
+		uint32_t addr, uint32_t length)
 {
-	uint32_t addr = wp->address;
 	uint32_t control;
 
-	/* this hardware doesn't support data value matching or masking */
-	if (wp->value || wp->mask != ~(uint32_t)0) {
-		LOG_DEBUG("watchpoint values and masking not supported");
-		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
-	}
-
 	control = (1 << 0)	/* enable */
 		| (3 << 1);	/* both user and privileged access */
 
-	switch (wp->rw) {
-	case WPT_READ:
-		control |= 1 << 3;
-		break;
-	case WPT_WRITE:
-		control |= 2 << 3;
-		break;
-	case WPT_ACCESS:
-		control |= 3 << 3;
-		break;
-	}
-
 	/* Match 1, 2, or all 4 byte addresses in this word.
 	 *
-	 * FIXME:  v7 hardware allows lengths up to 2 GB, and has eight
-	 * byte address select bits.  Support larger wp->length, if addr
-	 * is suitably aligned.
+	 * FIXME:  v7 hardware allows lengths up to 2 GB for BP and WP.
+	 * Support larger length, when addr is suitably aligned.  In
+	 * particular, allow watchpoints on 8 byte "double" values.
+	 *
+	 * REVISIT allow watchpoints on unaligned 2-bit values; and on
+	 * v7 hardware, unaligned 4-byte ones too.
 	 */
-	switch (wp->length) {
+	switch (length) {
 	case 1:
 		control |= (1 << (addr & 3)) << 5;
-		addr &= ~3;
 		break;
 	case 2:
 		/* require 2-byte alignment */
@@ -718,26 +704,110 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
 		}
 		/* FALL THROUGH */
 	default:
-		LOG_DEBUG("bad watchpoint length or alignment");
+		LOG_ERROR("unsupported {break,watch}point length/alignment");
 		return ERROR_INVALID_ARGUMENTS;
 	}
 
-	/* other control bits:
-	 * bits 9:12 == 0 ... only checking up to four byte addresses (v7 only)
+	/* other shared control bits:
 	 * bits 15:14 == 0 ... both secure and nonsecure states (v6.1+ only)
 	 * bit 20 == 0 ... not linked to a context ID
 	 * bit 28:24 == 0 ... not ignoring N LSBs (v7 only)
 	 */
 
-	dpm->dwp[index].wp = wp;
-	dpm->dwp[index].bpwp.address = addr & ~3;
-	dpm->dwp[index].bpwp.control = control;
-	dpm->dwp[index].bpwp.dirty = true;
+	xp->address = addr & ~3;
+	xp->control = control;
+	xp->dirty = true;
+
+	LOG_DEBUG("BPWP: addr %8.8x, control %x, number %d",
+			xp->address, control, xp->number);
 
 	/* hardware is updated in write_dirty_registers() */
 	return ERROR_OK;
 }
 
+static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
+	if (bp->length < 2)
+		return ERROR_INVALID_ARGUMENTS;
+	if (!dpm->bpwp_enable)
+		return retval;
+
+	/* FIXME we need a generic solution for software breakpoints. */
+	if (bp->type == BKPT_SOFT)
+		LOG_DEBUG("using HW bkpt, not SW...");
+
+	for (unsigned i = 0; i < dpm->nbp; i++) {
+		if (!dpm->dbp[i].bp) {
+			retval = dpm_bpwp_setup(dpm, &dpm->dbp[i].bpwp,
+					bp->address, bp->length);
+			if (retval == ERROR_OK)
+				dpm->dbp[i].bp = bp;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_remove_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_INVALID_ARGUMENTS;
+
+	for (unsigned i = 0; i < dpm->nbp; i++) {
+		if (dpm->dbp[i].bp == bp) {
+			dpm->dbp[i].bp = NULL;
+			dpm->dbp[i].bpwp.dirty = true;
+
+			/* hardware is updated in write_dirty_registers() */
+			retval = ERROR_OK;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index,
+		struct watchpoint *wp)
+{
+	int retval;
+	struct dpm_wp *dwp = dpm->dwp + index;
+	uint32_t control;
+
+	/* this hardware doesn't support data value matching or masking */
+	if (wp->value || wp->mask != ~(uint32_t)0) {
+		LOG_DEBUG("watchpoint values and masking not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	retval = dpm_bpwp_setup(dpm, &dwp->bpwp, wp->address, wp->length);
+	if (retval != ERROR_OK)
+		return retval;
+
+	control = dwp->bpwp.control;
+	switch (wp->rw) {
+	case WPT_READ:
+		control |= 1 << 3;
+		break;
+	case WPT_WRITE:
+		control |= 2 << 3;
+		break;
+	case WPT_ACCESS:
+		control |= 3 << 3;
+		break;
+	}
+	dwp->bpwp.control = control;
+
+	dpm->dwp[index].wp = wp;
+
+	return retval;
+}
 
 static int dpm_add_watchpoint(struct target *target, struct watchpoint *wp)
 {
@@ -865,11 +935,16 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 	arm->mrc = dpm_mrc;
 	arm->mcr = dpm_mcr;
 
-	/* breakpoint and watchpoint setup */
+	/* breakpoint setup -- optional until it works everywhere */
+	if (!target->type->add_breakpoint) {
+		target->type->add_breakpoint = dpm_add_breakpoint;
+		target->type->remove_breakpoint = dpm_remove_breakpoint;
+	}
+
+	/* watchpoint setup */
 	target->type->add_watchpoint = dpm_add_watchpoint;
 	target->type->remove_watchpoint = dpm_remove_watchpoint;
 
-	/* FIXME add breakpoint support */
 	/* FIXME add vector catch support */
 
 	dpm->nbp = 1 + ((dpm->didr >> 24) & 0xf);

commit 27c068c1f82423a2492899d1632caaa6f8261810
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:30:27 2010 -0800

    ARM11: per-core options should not be global
    
    Address some FIXME comments by getting rid of globals, moving
    per-core parameters in the existing per-core data structure.
    
    This will matter most whenever there are multiple ARM11 cores,
    e.g. ARM11 MPcore chips, but in general is just cleanup.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 671943f..678d8ac 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -44,15 +44,6 @@
 #endif
 
 
-/* FIXME none of these flags should be global to all ARM11 cores!
- * Most of them shouldn't exist at all, once the code works...
- */
-static bool arm11_config_memwrite_burst = true;
-static bool arm11_config_memwrite_error_fatal = true;
-static uint32_t arm11_vcr = 0;
-static bool arm11_config_step_irq_enable = false;
-static bool arm11_config_hardware_step = false;
-
 static int arm11_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints);
 
@@ -537,8 +528,8 @@ static int arm11_resume(struct target *target, int current,
 			brp_num++;
 		}
 
-		if (arm11_vcr)
-			arm11_sc7_set_vcr(arm11, arm11_vcr);
+		if (arm11->vcr)
+			arm11_sc7_set_vcr(arm11, arm11->vcr);
 	}
 
 	/* activate all watchpoints and breakpoints */
@@ -646,7 +637,7 @@ static int arm11_step(struct target *target, int current,
 		brp[1].write	= 1;
 		brp[1].address	= ARM11_SC7_BCR0;
 
-		if (arm11_config_hardware_step)
+		if (arm11->hardware_step)
 		{
 			/* Hardware single stepping ("instruction address
 			 * mismatch") is used if enabled.  It's not quite
@@ -690,7 +681,7 @@ static int arm11_step(struct target *target, int current,
 		/* resume */
 
 
-		if (arm11_config_step_irq_enable)
+		if (arm11->step_irq_enable)
 			/* this disable should be redundant ... */
 			arm11->dscr &= ~DSCR_INT_DIS;
 		else
@@ -756,8 +747,8 @@ static int arm11_assert_reset(struct target *target)
 	struct arm11_common *arm11 = target_to_arm11(target);
 
 	/* optionally catch reset vector */
-	if (target->reset_halt && !(arm11_vcr & 1))
-		arm11_sc7_set_vcr(arm11, arm11_vcr | 1);
+	if (target->reset_halt && !(arm11->vcr & 1))
+		arm11_sc7_set_vcr(arm11, arm11->vcr | 1);
 
 	/* Issue some kind of warm reset. */
 	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT)) {
@@ -816,8 +807,8 @@ static int arm11_deassert_reset(struct target *target)
 	}
 
 	/* maybe restore vector catch config */
-	if (target->reset_halt && !(arm11_vcr & 1))
-		arm11_sc7_set_vcr(arm11, arm11_vcr);
+	if (target->reset_halt && !(arm11->vcr & 1))
+		arm11_sc7_set_vcr(arm11, arm11->vcr);
 
 	return ERROR_OK;
 }
@@ -966,7 +957,7 @@ static int arm11_write_memory_inner(struct target *target,
 	 * now exercise both burst and non-burst code paths with the
 	 * default settings, increasing code coverage.
 	 */
-	bool burst = arm11_config_memwrite_burst && (count > 1);
+	bool burst = arm11->memwrite_burst && (count > 1);
 
 	switch (size)
 	{
@@ -1071,7 +1062,7 @@ static int arm11_write_memory_inner(struct target *target,
 			if (burst)
 				LOG_ERROR("use 'arm11 memwrite burst disable' to disable fast burst mode");
 
-			if (arm11_config_memwrite_error_fatal)
+			if (arm11->memwrite_error_fatal)
 				return ERROR_FAIL;
 		}
 	}
@@ -1171,6 +1162,9 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 	arm11->jtag_info.cur_scan_chain = ~0;	/* invalid/unknown */
 	arm11->jtag_info.intest_instr = ARM11_INTEST;
 
+	arm11->memwrite_burst = true;
+	arm11->memwrite_error_fatal = true;
+
 	return ERROR_OK;
 }
 
@@ -1231,6 +1225,7 @@ static int arm11_examine(struct target *target)
 		break;
 	case 0x7B76:
 		arm11->arm.core_type = ARM_MODE_MON;
+		/* NOTE: could default arm11->hardware_step to true */
 		type = "ARM1176";
 		break;
 	default:
@@ -1286,38 +1281,41 @@ static int arm11_examine(struct target *target)
 }
 
 
-/* FIXME all these BOOL_WRAPPER things should be modifying
- * per-instance state, not shared state; ditto the vector
- * catch register support.  Scan chains with multiple cores
- * should be able to say "work with this core like this,
- * that core like that".  Example, ARM11 MPCore ...
- */
-
 #define ARM11_BOOL_WRAPPER(name, print_name)	\
-		COMMAND_HANDLER(arm11_handle_bool_##name) \
-		{ \
-			return CALL_COMMAND_HANDLER(handle_command_parse_bool, \
-					&arm11_config_##name, print_name); \
-		}
+	COMMAND_HANDLER(arm11_handle_bool_##name) \
+	{ \
+		struct target *target = get_current_target(CMD_CTX); \
+		struct arm11_common *arm11 = target_to_arm11(target); \
+		\
+		return CALL_COMMAND_HANDLER(handle_command_parse_bool, \
+				&arm11->name, print_name); \
+	}
 
 ARM11_BOOL_WRAPPER(memwrite_burst, "memory write burst mode")
 ARM11_BOOL_WRAPPER(memwrite_error_fatal, "fatal error mode for memory writes")
 ARM11_BOOL_WRAPPER(step_irq_enable, "IRQs while stepping")
 ARM11_BOOL_WRAPPER(hardware_step, "hardware single step")
 
+/* REVISIT handle the VCR bits like other ARMs:  use symbols for
+ * input and output values.
+ */
+
 COMMAND_HANDLER(arm11_handle_vcr)
 {
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm11_common *arm11 = target_to_arm11(target);
+
 	switch (CMD_ARGC) {
 	case 0:
 		break;
 	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], arm11_vcr);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], arm11->vcr);
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	LOG_INFO("VCR 0x%08" PRIx32 "", arm11_vcr);
+	LOG_INFO("VCR 0x%08" PRIx32 "", arm11->vcr);
 	return ERROR_OK;
 }
 
@@ -1376,6 +1374,7 @@ static const struct command_registration arm11_any_command_handlers[] = {
 	},
 	COMMAND_REGISTRATION_DONE
 };
+
 static const struct command_registration arm11_command_handlers[] = {
 	{
 		.chain = arm_command_handlers,
diff --git a/src/target/arm11.h b/src/target/arm11.h
index dd2f3a2..9edadee 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -69,6 +69,18 @@ struct arm11_common
 
 	bool	simulate_reset_on_next_halt;	/**< Perform cleanups of the ARM state on next halt */
 
+	/* Per-core configurable options.
+	 * NOTE that several of these boolean options should not exist
+	 * once the relevant code is known to work correctly.
+	 */
+	bool memwrite_burst;
+	bool memwrite_error_fatal;
+	bool step_irq_enable;
+	bool hardware_step;
+
+	/** Configured Vector Catch Register settings. */
+	uint32_t vcr;
+
 	struct arm_jtag jtag_info;
 };
 

commit ce1feaa7322affd3b979c9fe93dd8f7462ea9eca
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sun Feb 21 14:28:53 2010 -0800

    ARMv7-M: start using "struct arm"
    
    This sets up a few of the core "struct arm" data structures so they
    can be used with ARMv7-M cores.  Specifically, it:
    
     - defines new ARM core_modes to match the microcontroller modes
       (e.g. HANDLER not IRQ, and two types of thread mode);
    
     - Establishes a new microcontroller "core_type", which can be
       used to make sure v7-M (and v6-M) cores are handled right;
    
     - adds "struct arm" to "struct armv7m" and arranges for the
       target_to_armv7m() converter to use it;
    
     - sets up the arm.core_cache and arm.cpsr values
    
     - makes the Cortex-M3 code maintain arm.map and arm.core_mode.
    
    This is currently set up as a parallel data structure, primarily to
    minimize special cases for the semihosting support with microcontroller
    profile cores.
    
    Later patches can rip out the duplicative ARMv7-M support and start
    reusing core ARM code.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm.h b/src/target/arm.h
index 988266e..c72b194 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -40,9 +40,17 @@
  */
 
 /**
- * These numbers match the five low bits of the *PSR registers on
+ * Represent state of an ARM core.
+ *
+ * Most numbers match the five low bits of the *PSR registers on
  * "classic ARM" processors, which build on the ARMv4 processor
  * modes and register set.
+ *
+ * ARM_MODE_ANY is a magic value, often used as a wildcard.
+ *
+ * Only the microcontroller cores (ARMv6-M, ARMv7-M) support ARM_MODE_THREAD,
+ * ARM_MODE_USER_THREAD, and ARM_MODE_HANDLER.  Those are the only modes
+ * they support.
  */
 enum arm_mode {
 	ARM_MODE_USR = 16,
@@ -53,6 +61,11 @@ enum arm_mode {
 	ARM_MODE_MON = 26,
 	ARM_MODE_UND = 27,
 	ARM_MODE_SYS = 31,
+
+	ARM_MODE_THREAD,
+	ARM_MODE_USER_THREAD,
+	ARM_MODE_HANDLER,
+
 	ARM_MODE_ANY = -1
 };
 
@@ -96,6 +109,8 @@ struct arm {
 	 * ARM_MODE_ANY indicates the standard set of 37 registers,
 	 * seen on for example ARM7TDMI cores.  ARM_MODE_MON indicates three
 	 * more registers are shadowed, for "Secure Monitor" mode.
+	 * ARM_MODE_THREAD indicates a microcontroller profile core,
+	 * which only shadows SP.
 	 */
 	enum arm_mode core_type;
 
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index c7b7367..8d3a891 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -1426,10 +1426,12 @@ int arm_init_arch_info(struct target *target, struct arm *armv4_5)
 	armv4_5->target = target;
 
 	armv4_5->common_magic = ARM_COMMON_MAGIC;
-	arm_set_cpsr(armv4_5, ARM_MODE_USR);
 
 	/* core_type may be overridden by subtype logic */
-	armv4_5->core_type = ARM_MODE_ANY;
+	if (armv4_5->core_type != ARM_MODE_THREAD) {
+		armv4_5->core_type = ARM_MODE_ANY;
+		arm_set_cpsr(armv4_5, ARM_MODE_USR);
+	}
 
 	/* default full_context() has no core-specific optimizations */
 	if (!armv4_5->full_context && armv4_5->read_core_reg)
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 9fe705a..faa886b 100644
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -473,6 +473,7 @@ int armv7m_run_algorithm(struct target *target,
 int armv7m_arch_state(struct target *target)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
+	struct arm *arm = &armv7m->arm;
 	uint32_t ctrl, sp;
 
 	ctrl = buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_CONTROL].value, 0, 32);
@@ -483,7 +484,7 @@ int armv7m_arch_state(struct target *target)
 		debug_reason_name(target),
 		armv7m_mode_strings[armv7m->core_mode],
 		armv7m_exception_string(armv7m->exception_number),
-		buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32),
+		buf_get_u32(arm->cpsr->value, 0, 32),
 		buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_PC].value, 0, 32),
 		(ctrl & 0x02) ? 'p' : 'm',
 		sp);
@@ -499,6 +500,7 @@ static const struct reg_arch_type armv7m_reg_type = {
 struct reg_cache *armv7m_build_reg_cache(struct target *target)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
+	struct arm *arm = &armv7m->arm;
 	int num_regs = ARMV7M_NUM_REGS;
 	struct reg_cache **cache_p = register_get_last_cache_p(&target->reg_cache);
 	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
@@ -532,19 +534,28 @@ struct reg_cache *armv7m_build_reg_cache(struct target *target)
 		reg_list[i].arch_info = &arch_info[i];
 	}
 
+	arm->cpsr = reg_list + ARMV7M_xPSR;
+	arm->core_cache = cache;
 	return cache;
 }
 
 /** Sets up target as a generic ARMv7-M core */
 int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m)
 {
+	struct arm *arm = &armv7m->arm;
+
 	armv7m->common_magic = ARMV7M_COMMON_MAGIC;
 
-	target->arch_info = armv7m;
+	arm->core_type = ARM_MODE_THREAD;
+	arm->arch_info = armv7m;
+
+	/* FIXME remove v7m-specific r/w core_reg functions;
+	 * use the generic ARM core support..
+	 */
 	armv7m->read_core_reg = armv7m_read_core_reg;
 	armv7m->write_core_reg = armv7m_write_core_reg;
 
-	return ERROR_OK;
+	return arm_init_arch_info(target, arm);
 }
 
 /** Generates a CRC32 checksum of a memory region. */
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index b6be1d2..89c5064 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -100,6 +100,8 @@ enum
 
 struct armv7m_common
 {
+	struct arm	arm;
+
 	int common_magic;
 	struct reg_cache *core_cache;
 	enum armv7m_mode core_mode;
@@ -128,7 +130,7 @@ struct armv7m_common
 static inline struct armv7m_common *
 target_to_armv7m(struct target *target)
 {
-	return target->arch_info;
+	return container_of(target->arch_info, struct armv7m_common, arm);
 }
 
 static inline bool is_armv7m(struct armv7m_common *armv7m)
diff --git a/src/target/cortex_m3.c b/src/target/cortex_m3.c
index 3f34769..fbc879f 100644
--- a/src/target/cortex_m3.c
+++ b/src/target/cortex_m3.c
@@ -323,6 +323,24 @@ static int cortex_m3_examine_exception_reason(struct target *target)
 	return ERROR_OK;
 }
 
+/* PSP is used in some thread modes */
+static const int armv7m_psp_reg_map[17] = {
+	ARMV7M_R0, ARMV7M_R1, ARMV7M_R2, ARMV7M_R3,
+	ARMV7M_R4, ARMV7M_R5, ARMV7M_R6, ARMV7M_R7,
+	ARMV7M_R8, ARMV7M_R9, ARMV7M_R10, ARMV7M_R11,
+	ARMV7M_R12, ARMV7M_PSP, ARMV7M_R14, ARMV7M_PC,
+	ARMV7M_xPSR,
+};
+
+/* MSP is used in handler and some thread modes */
+static const int armv7m_msp_reg_map[17] = {
+	ARMV7M_R0, ARMV7M_R1, ARMV7M_R2, ARMV7M_R3,
+	ARMV7M_R4, ARMV7M_R5, ARMV7M_R6, ARMV7M_R7,
+	ARMV7M_R8, ARMV7M_R9, ARMV7M_R10, ARMV7M_R11,
+	ARMV7M_R12, ARMV7M_MSP, ARMV7M_R14, ARMV7M_PC,
+	ARMV7M_xPSR,
+};
+
 static int cortex_m3_debug_entry(struct target *target)
 {
 	int i;
@@ -330,6 +348,7 @@ static int cortex_m3_debug_entry(struct target *target)
 	int retval;
 	struct cortex_m3_common *cortex_m3 = target_to_cm3(target);
 	struct armv7m_common *armv7m = &cortex_m3->armv7m;
+	struct arm *arm = &armv7m->arm;
 	struct swjdp_common *swjdp = &armv7m->swjdp_info;
 	struct reg *r;
 
@@ -377,11 +396,27 @@ static int cortex_m3_debug_entry(struct target *target)
 	{
 		armv7m->core_mode = ARMV7M_MODE_HANDLER;
 		armv7m->exception_number = (xPSR & 0x1FF);
+
+		arm->core_mode = ARM_MODE_HANDLER;
+		arm->map = armv7m_msp_reg_map;
 	}
 	else
 	{
-		armv7m->core_mode = buf_get_u32(armv7m->core_cache
-				->reg_list[ARMV7M_CONTROL].value, 0, 1);
+		unsigned control = buf_get_u32(armv7m->core_cache
+				->reg_list[ARMV7M_CONTROL].value, 0, 2);
+
+		/* is this thread privileged? */
+		armv7m->core_mode = control & 1;
+		arm->core_mode = armv7m->core_mode
+				? ARM_MODE_USER_THREAD
+				: ARM_MODE_THREAD;
+
+		/* which stack is it using? */
+		if (control & 2)
+			arm->map = armv7m_psp_reg_map;
+		else
+			arm->map = armv7m_msp_reg_map;
+
 		armv7m->exception_number = 0;
 	}
 

-----------------------------------------------------------------------

Summary of changes:
 doc/manual/release.txt       |  143 ++++++++++++++------
 src/jtag/drivers/ft2232.c    |   97 +++++++++++---
 src/target/arm.h             |   20 +++-
 src/target/arm11.c           |   67 +++++-----
 src/target/arm11.h           |   12 ++
 src/target/arm720t.c         |    6 +-
 src/target/arm7_9_common.c   |   42 +++---
 src/target/arm7tdmi.c        |    3 +-
 src/target/arm920t.c         |    6 +-
 src/target/arm926ejs.c       |    6 +-
 src/target/arm9tdmi.c        |    3 +-
 src/target/arm_adi_v5.c      |  310 ++++++++++++++++-------------------------
 src/target/arm_adi_v5.h      |   48 +++++--
 src/target/arm_dpm.c         |  155 ++++++++++++++++------
 src/target/arm_semihosting.c |    6 +-
 src/target/armv4_5.c         |   15 +-
 src/target/armv7m.c          |   24 +++-
 src/target/armv7m.h          |    4 +-
 src/target/cortex_a8.c       |   23 ++--
 src/target/cortex_m3.c       |   56 ++++++--
 src/target/feroceon.c        |   10 +-
 src/target/xscale.c          |   66 ++++++----
 22 files changed, 676 insertions(+), 446 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb 22 08:00:27 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 22 Feb 2010 07:00:27 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-14-g90efc40
Message-ID: <E1NjSHM-0008Cm-4H@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  90efc404f3cb9c3f6e7fdb8a2c22fb3e72e9072f (commit)
      from  c21c740a895438832ed7e945ee4943da3eb733f9 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 90efc404f3cb9c3f6e7fdb8a2c22fb3e72e9072f
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Mon Feb 8 15:40:53 2010 +0100

    zy1000: jtag_add_dr_scan() performance improvement
    
    Reduce overhead in jtag_add_dr_scan() a bit.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 2c205b7..ef4f482 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -650,22 +650,29 @@ int interface_jtag_add_dr_scan(int num_fields, const struct scan_field *fields,
 
 		for (j = 0; j < num_fields; j++)
 		{
+			/* Find a range of fields to write to this tap */
 			if (tap == fields[j].tap)
 			{
 				found = 1;
+				int i;
+				for (i = j + 1; i < num_fields; i++)
+				{
+					if (tap != fields[j].tap)
+					{
+						break;
+					}
+				}
+
+				scanFields(i - j, fields + j, TAP_DRSHIFT, pause);
 
-				scanFields(1, fields+j, TAP_DRSHIFT, pause);
+				j = i;
 			}
 		}
+
 		if (!found)
 		{
-			struct scan_field tmp;
-			/* program the scan field to 1 bit length, and ignore it's value */
-			tmp.num_bits = 1;
-			tmp.out_value = NULL;
-			tmp.in_value = NULL;
-
-			scanFields(1, &tmp, TAP_DRSHIFT, pause);
+			/* Shift out a 0 for disabled tap's */
+			shiftValueInner(TAP_DRSHIFT, pause?TAP_DRPAUSE:TAP_DRSHIFT, 1, 0);
 		}
 		else
 		{

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c |   23 +++++++++++++++--------
 1 files changed, 15 insertions(+), 8 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From gowinex at users.sourceforge.net  Mon Feb 22 10:31:09 2010
From: gowinex at users.sourceforge.net (Øyvind Harboe)
Date: Mon, 22 Feb 2010 09:31:09 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-16-gfaef631
Message-ID: <E1NjUdC-0006wc-6w@sfp-scmshell-1.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  faef631a4d1429f48c34da13d446dcd64d1523bf (commit)
       via  1f5883ea56cb058221f5731359da3d66838077e0 (commit)
      from  90efc404f3cb9c3f6e7fdb8a2c22fb3e72e9072f (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit faef631a4d1429f48c34da13d446dcd64d1523bf
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Feb 9 14:26:57 2010 +0100

    arm11: improve performance using minidriver hook
    
    zy1000 performance for GDB load went from 100kBytes/s
    to 300kBytes/s @ 8 MHz by implementing the inner loop
    of unack arm11 memory writes directly on top of the hw
    fifo.
    
    Profiling info:
    
     78.57      0.77     0.77                             arm11_run_instr_data_to_core_noack_inner
      5.10      0.82     0.05                             memcpy
      4.08      0.86     0.04                             jtag_tap_next_enabled
      3.06      0.89     0.03                             gdb_input
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index da5aa36..d920c30 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -845,11 +845,73 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 }
 
 
-int arm11_run_instr_data_to_core_noack_inner_default(struct arm11_common * arm11, uint32_t opcode, uint32_t * data, size_t count);
 
-int arm11_run_instr_data_to_core_noack_inner(struct arm11_common * arm11, uint32_t opcode, uint32_t * data, size_t count)
+int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count)
 {
-	return arm11_run_instr_data_to_core_noack_inner_default(arm11, opcode, data, count);
+#if 0
+	int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count);
+	return arm11_run_instr_data_to_core_noack_inner_default(tap, opcode, data, count);
+#else
+	static const int bits[] = {32, 2};
+	uint32_t values[] = {0, 0};
+
+	/* FIX!!!!!! the target_write_memory() API started this nasty problem
+	 * with unaligned uint32_t * pointers... */
+	const uint8_t *t = (const uint8_t *)data;
+
+	while (count--)
+	{
+		values[0] = *t++;
+		values[0] |= (*t++<<8);
+		values[0] |= (*t++<<16);
+		values[0] |= (*t++<<24);
+
+		if (count > 0)
+		{
+			jtag_add_dr_out(tap,
+				2,
+				bits,
+				values,
+				TAP_DRPAUSE);
+
+#if 1
+			/* copy & paste from arm11_dbgtap.c */
+			//TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+
+			waitIdle();
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 1);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x28, 0);
+			waitIdle();
+			ZY1000_POKE(ZY1000_JTAG_BASE + 0x20, TAP_DRSHIFT);
+#else
+			static const tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
+			{
+				TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
+			};
+
+			jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
+				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
+#endif
+		} else
+		{
+			/* This will happen on the last iteration updating the current tap state
+			 * so we don't have to track it during the common code path */
+			jtag_add_dr_out(tap,
+				2,
+				bits,
+				values,
+				TAP_IDLE);
+		}
+	}
+
+	return jtag_execute_queue();
+#endif
 }
 
 

commit 1f5883ea56cb058221f5731359da3d66838077e0
Author: ??yvind Harboe <oyvind.harboe at zylin.com>
Date:   Tue Feb 9 09:55:56 2010 +0100

    arm11: allow minidrivers to implement inner loop of memory writes
    
    This allows minidrivers to e.g. hardware accelerate memory
    writes.
    
    Same trick as is used for arm7/9 dcc writes.
    
    Added error propagation for memory transfer failures in
    code rearrangement.
    
    Also the JTAG end state is not updated until after
    the memory write run is complete.
    
    Signed-off-by: ??yvind Harboe <oyvind.harboe at zylin.com>

diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index ef4f482..da5aa36 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -845,6 +845,14 @@ void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer,
 }
 
 
+int arm11_run_instr_data_to_core_noack_inner_default(struct arm11_common * arm11, uint32_t opcode, uint32_t * data, size_t count);
+
+int arm11_run_instr_data_to_core_noack_inner(struct arm11_common * arm11, uint32_t opcode, uint32_t * data, size_t count)
+{
+	return arm11_run_instr_data_to_core_noack_inner_default(arm11, opcode, data, count);
+}
+
+
 static const struct command_registration zy1000_commands[] = {
 	{
 		.name = "power",
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 6d132a7..b8388c8 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -569,43 +569,31 @@ static const tap_state_t arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay[] =
 	TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };
 
-
-
-/** Execute one instruction via ITR repeatedly while
- *  passing data to the core via DTR on each execution.
- *
- * Caller guarantees that processor is in debug state, that DSCR_ITR_EN
- * is set, the ITR Ready flag is set (as seen on the previous entry to
- * TAP_DRCAPTURE), and the DSCR sticky abort flag is clear.
- *
- *  No Ready check during transmission.
- *
- *  The executed instruction \em must read data from DTR.
- *
- * \pre arm11_run_instr_data_prepare() /  arm11_run_instr_data_finish() block
- *
- * \param arm11		Target state variable.
- * \param opcode	ARM opcode
- * \param data		Pointer to the data words to be passed to the core
- * \param count		Number of data words and instruction repetitions
- *
+/* This inner loop can be implemented by the minidriver, oftentimes in hardware... The
+ * minidriver can call the default implementation as a fallback or implement it
+ * from scratch.
  */
-int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opcode, uint32_t * data, size_t count)
+int arm11_run_instr_data_to_core_noack_inner_default(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count)
 {
-	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
+	struct scan_field	chain5_fields[3];
 
-	arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
+	chain5_fields[0].tap			= tap;
+	chain5_fields[0].num_bits		= 32;
+	chain5_fields[0].out_value		= NULL; /*&Data*/
+	chain5_fields[0].in_value		= NULL;
 
-	arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
+	chain5_fields[1].tap			= tap;
+	chain5_fields[1].num_bits		= 1;
+	chain5_fields[1].out_value		= NULL;
+	chain5_fields[1].in_value		= NULL; /*&Ready*/
 
-	struct scan_field	chain5_fields[3];
-
-	arm11_setup_field(arm11, 32,    NULL/*&Data*/,  NULL,				chain5_fields + 0);
-	arm11_setup_field(arm11,  1,    NULL,			NULL /*&Ready*/,	chain5_fields + 1);
-	arm11_setup_field(arm11,  1,    NULL,			NULL,				chain5_fields + 2);
+	chain5_fields[2].tap			= tap;
+	chain5_fields[2].num_bits		= 1;
+	chain5_fields[2].out_value		= NULL;
+	chain5_fields[2].in_value		= NULL;
 
 	uint8_t			*Readies;
-	unsigned readiesNum = count + 1;
+	unsigned readiesNum = count;
 	unsigned bytes = sizeof(*Readies)*readiesNum;
 
 	Readies = (uint8_t *) malloc(bytes);
@@ -616,31 +604,22 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opc
 	}
 
 	uint8_t	*		ReadyPos			= Readies;
-
 	while (count--)
 	{
 		chain5_fields[0].out_value	= (void *)(data++);
 		chain5_fields[1].in_value	= ReadyPos++;
 
-		if (count)
+		if (count > 0)
 		{
-			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_DRPAUSE));
+			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 			jtag_add_pathmove(ARRAY_SIZE(arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay),
 				arm11_MOVE_DRPAUSE_IDLE_DRPAUSE_with_delay);
-		}
-		else
+		} else
 		{
-			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, jtag_set_end_state(TAP_IDLE));
+			jtag_add_dr_scan(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_IDLE);
 		}
 	}
 
-	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
-
-	chain5_fields[0].out_value	= 0;
-	chain5_fields[1].in_value   = ReadyPos++;
-
-	arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
-
 	int retval = jtag_execute_queue();
 	if (retval == ERROR_OK)
 	{
@@ -655,16 +634,84 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opc
 		}
 
 		if (error_count > 0 )
+		{
 			LOG_ERROR("%u words out of %u not transferred",
 				error_count, readiesNum);
-
+			retval = ERROR_FAIL;
+		}
 	}
-
 	free(Readies);
 
 	return retval;
 }
 
+int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count);
+
+#ifndef HAVE_JTAG_MINIDRIVER_H
+int arm11_run_instr_data_to_core_noack_inner(struct jtag_tap * tap, uint32_t opcode, uint32_t * data, size_t count)
+{
+	return arm11_run_instr_data_to_core_noack_inner_default(tap, opcode, data, count);
+}
+#endif
+
+/** Execute one instruction via ITR repeatedly while
+ *  passing data to the core via DTR on each execution.
+ *
+ * Caller guarantees that processor is in debug state, that DSCR_ITR_EN
+ * is set, the ITR Ready flag is set (as seen on the previous entry to
+ * TAP_DRCAPTURE), and the DSCR sticky abort flag is clear.
+ *
+ *  No Ready check during transmission.
+ *
+ *  The executed instruction \em must read data from DTR.
+ *
+ * \pre arm11_run_instr_data_prepare() /  arm11_run_instr_data_finish() block
+ *
+ * \param arm11		Target state variable.
+ * \param opcode	ARM opcode
+ * \param data		Pointer to the data words to be passed to the core
+ * \param count		Number of data words and instruction repetitions
+ *
+ */
+int arm11_run_instr_data_to_core_noack(struct arm11_common * arm11, uint32_t opcode, uint32_t * data, size_t count)
+{
+	arm11_add_IR(arm11, ARM11_ITRSEL, ARM11_TAP_DEFAULT);
+
+	arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
+
+	arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
+
+	int retval = arm11_run_instr_data_to_core_noack_inner(arm11->arm.target->tap, opcode, data, count);
+
+	if (retval != ERROR_FAIL)
+		return retval;
+
+	arm11_add_IR(arm11, ARM11_INTEST, ARM11_TAP_DEFAULT);
+
+	struct scan_field	chain5_fields[3];
+
+	arm11_setup_field(arm11, 32,    NULL/*&Data*/,  NULL,				chain5_fields + 0);
+	arm11_setup_field(arm11,  1,    NULL,			NULL /*&Ready*/,	chain5_fields + 1);
+	arm11_setup_field(arm11,  1,    NULL,			NULL,				chain5_fields + 2);
+
+	uint8_t ready_flag;
+	chain5_fields[1].in_value   = &ready_flag;
+
+	arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+
+	retval = jtag_execute_queue();
+	if (retval == ERROR_OK)
+	{
+		if (ready_flag != 1)
+		{
+			LOG_ERROR("last word not transferred");
+			retval = ERROR_FAIL;
+		}
+	}
+
+	return retval;
+}
+
 
 /** Execute an instruction via ITR while handing data into the core via DTR.
  *

-----------------------------------------------------------------------

Summary of changes:
 src/jtag/zy1000/zy1000.c  |   70 +++++++++++++++++++++++
 src/target/arm11_dbgtap.c |  137 ++++++++++++++++++++++++++++++---------------
 2 files changed, 162 insertions(+), 45 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Wed Feb 24 09:55:14 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Wed, 24 Feb 2010 08:55:14 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-17-g75067c4
Message-ID: <E1NkD1X-0002Ro-DY@sfp-scmshell-2.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  75067c40424f0e3349f445ed4ec43476a89973da (commit)
      from  faef631a4d1429f48c34da13d446dcd64d1523bf (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 75067c40424f0e3349f445ed4ec43476a89973da
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Tue Feb 23 23:36:42 2010 -0800

    ARM ADIv5: rename more JTAG-specific routines
    
    Highlight more of the internal JTAG-specific utilities, so it's
    easier to identify code needing changes to become transport-neutral.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index d30dd50..435d659 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -185,14 +185,14 @@ static int adi_jtag_dp_scan_u32(struct swjdp_common *swjdp,
 /**
  * Utility to write AP registers.
  */
-static inline int ap_write_check(struct swjdp_common *dap,
+static inline int adi_jtag_ap_write_check(struct swjdp_common *dap,
 		uint8_t reg_addr, uint8_t *outvalue)
 {
 	return adi_jtag_dp_scan(dap, JTAG_DP_APACC, reg_addr, DPAP_WRITE,
 			outvalue, NULL, NULL);
 }
 
-static int scan_inout_check_u32(struct swjdp_common *swjdp,
+static int adi_jtag_scan_inout_check_u32(struct swjdp_common *swjdp,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue)
 {
@@ -222,7 +222,7 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 
 #if 0
 	/* Danger!!!! BROKEN!!!! */
-	scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
 	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
 	R956 introduced the check on return value here and now Michael Schwingen reports
@@ -240,7 +240,7 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 	/* Post CTRL/STAT read; discard any previous posted read value
 	 * but collect its ACK status.
 	 */
-	scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
@@ -275,7 +275,7 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
-			scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
 			if ((retval = jtag_execute_queue()) != ERROR_OK)
 				return retval;
@@ -317,11 +317,11 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 				LOG_ERROR("JTAG-DP STICKY ERROR");
 
 			/* Clear Sticky Error Bits */
-			scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_WRITE,
 					swjdp->dp_ctrl_stat | SSTICKYORUN
 						| SSTICKYERR, NULL);
-			scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+			adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
 			if ((retval = jtag_execute_queue()) != ERROR_OK)
 				return retval;
@@ -353,14 +353,14 @@ int jtagdp_transaction_endcheck(struct swjdp_common *swjdp)
 static int dap_dp_write_reg(struct swjdp_common *swjdp,
 		uint32_t value, uint8_t reg_addr)
 {
-	return scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	return adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 			reg_addr, DPAP_WRITE, value, NULL);
 }
 
 static int dap_dp_read_reg(struct swjdp_common *swjdp,
 		uint32_t *value, uint8_t reg_addr)
 {
-	return scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
+	return adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_DPACC,
 			reg_addr, DPAP_READ, 0, value);
 }
 
@@ -412,7 +412,7 @@ static int dap_ap_write_reg(struct swjdp_common *swjdp,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return ap_write_check(swjdp, reg_addr, out_value_buf);
+	return adi_jtag_ap_write_check(swjdp, reg_addr, out_value_buf);
 }
 
 /**
@@ -452,7 +452,7 @@ int dap_ap_read_reg_u32(struct swjdp_common *swjdp,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
+	return adi_jtag_scan_inout_check_u32(swjdp, JTAG_DP_APACC, reg_addr,
 			DPAP_READ, 0, value);
 }
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm_adi_v5.c |   22 +++++++++++-----------
 1 files changed, 11 insertions(+), 11 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Thu Feb 25 09:14:12 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Thu, 25 Feb 2010 08:14:12 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-20-g4a64820
Message-ID: <E1NkYrO-0002n5-6e@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  4a64820f230a267b1f2e36d4be567074e5b8cb76 (commit)
       via  79010bf3dfad01ff11b37a9a6c79452a604c596d (commit)
       via  7abe9f38b2321b00b240fb7901dc408106fb07f8 (commit)
      from  75067c40424f0e3349f445ed4ec43476a89973da (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 4a64820f230a267b1f2e36d4be567074e5b8cb76
Author: Mariano Alvira <mar at devl.org>
Date:   Thu Feb 25 00:01:55 2010 -0800

    ft2232: add a mechanism to specify channel in layout structs
    
    FT2232-family chips have two or more MPSSE modules.   FTDI documentation
    calls these channels.  JTAG adapter drivers thus need to be able to choose
    which channel to use.  (For example, one channel may connect to a board's
    microcontroller, while another connects to a CPLD.)
    
    Since each channel has its own USB interface, libftdi (somewhat confusingly)
    identifies channels using INTERFACE_* symbols.  Most boards use INTERFACE_A
    for JTAG, which is the default in OpenOCD.  But some wire up a different one.
    
    Note that there are two facets of what makes a wiring "layout":
    
     - The mapping between debug signals map and channel signals ... embedded
       in C functions.
    
     - Label used in Tcl configuration scripts ... part of the "layout" structure.
    
    By letting the channel be part of the layout struct, we permit sharing the C
    functions between Tcl-visible layouts, when those signal mappings are reused.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 5042a22..4b84fa8 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -145,6 +145,7 @@ struct ft2232_layout {
 	int (*init)(void);
 	void (*reset)(int trst, int srst);
 	void (*blink)(void);
+	int channel;
 };
 
 /* init procedures for supported layouts */
@@ -2062,7 +2063,7 @@ static int ft2232_purge_ftd2xx(void)
 #endif /* BUILD_FT2232_FTD2XX == 1 */
 
 #if BUILD_FT2232_LIBFTDI == 1
-static int ft2232_init_libftdi(uint16_t vid, uint16_t pid, int more, int* try_more)
+static int ft2232_init_libftdi(uint16_t vid, uint16_t pid, int more, int* try_more, int channel)
 {
 	uint8_t latency_timer;
 
@@ -2072,7 +2073,10 @@ static int ft2232_init_libftdi(uint16_t vid, uint16_t pid, int more, int* try_mo
 	if (ftdi_init(&ftdic) < 0)
 		return ERROR_JTAG_INIT_FAILED;
 
-	if (ftdi_set_interface(&ftdic, INTERFACE_A) < 0)
+	/* default to INTERFACE_A */
+	if(channel == INTERFACE_ANY) { channel = INTERFACE_A; }
+
+	if (ftdi_set_interface(&ftdic, channel) < 0)
 	{
 		LOG_ERROR("unable to select FT2232 channel A: %s", ftdic.error_str);
 		return ERROR_JTAG_INIT_FAILED;
@@ -2197,7 +2201,7 @@ static int ft2232_init(void)
 				more, &try_more);
 #elif BUILD_FT2232_LIBFTDI == 1
 		retval = ft2232_init_libftdi(ft2232_vid[i], ft2232_pid[i],
-				more, &try_more);
+					     more, &try_more, cur_layout->channel);
 #endif
 		if (retval >= 0)
 			break;

commit 79010bf3dfad01ff11b37a9a6c79452a604c596d
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Wed Feb 24 23:46:46 2010 -0800

    ARM ADIv5 doxygen and cleanup
    
    Add doxygen for mem_ap_read_buf_u{8,16,32}() calls,
    and shrink a few overlong lines.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 435d659..41f00ec 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -866,14 +866,16 @@ int mem_ap_write_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 	return retval;
 }
 
-/*********************************************************************************
-*                                                                                *
-* mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)  *
-*                                                                                *
-* Read block fast in target order (little endian) into a buffer                  *
-*                                                                                *
-**********************************************************************************/
-int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+/**
+ * Synchronously read a block of 32-bit words into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the words will be stored (in host byte order).
+ * @param count How many words to read.
+ * @param address Memory address from which to read words; all the
+ *	words must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
 {
 	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
 	uint32_t adr = address;
@@ -884,8 +886,12 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 
 	while (wcount > 0)
 	{
-		/* Adjust to read blocks within boundaries aligned to the TAR autoincremnent size*/
-		blocksize = max_tar_block_size(swjdp->tar_autoincr_block, address);
+		/* Adjust to read blocks within boundaries aligned to the
+		 * TAR autoincrement size (at least 2^10).  Autoincrement
+		 * mode avoids an extra per-word roundtrip to update TAR.
+		 */
+		blocksize = max_tar_block_size(swjdp->tar_autoincr_block,
+				address);
 		if (wcount < blocksize)
 			blocksize = wcount;
 
@@ -893,7 +899,8 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 		if (blocksize == 0)
 			blocksize = 1;
 
-		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
+		dap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE,
+				address);
 
 		/* Scan out first read */
 		adi_jtag_dp_scan(swjdp, JTAG_DP_APACC, AP_REG_DRW,
@@ -928,7 +935,8 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 
 		if (errorcount > 1)
 		{
-			LOG_WARNING("Block read error address 0x%" PRIx32 ", count 0x%x", address, count);
+			LOG_WARNING("Block read error address 0x%" PRIx32
+				", count 0x%x", address, count);
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
@@ -944,7 +952,8 @@ int mem_ap_read_buf_u32(struct swjdp_common *swjdp, uint8_t *buffer, int count,
 
 			for (i = 0; i < 4; i++)
 			{
-				*((uint8_t*)pBuffer) = (data >> 8 * (adr & 0x3));
+				*((uint8_t*)pBuffer) =
+						(data >> 8 * (adr & 0x3));
 				pBuffer++;
 				adr++;
 			}
@@ -1005,7 +1014,16 @@ static int mem_ap_read_buf_packed_u16(struct swjdp_common *swjdp,
 	return retval;
 }
 
-int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+/**
+ * Synchronously read a block of 16-bit halfwords into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the halfwords will be stored (in host byte order).
+ * @param count How many halfwords to read.
+ * @param address Memory address from which to read words; all the
+ *	words must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u16(struct swjdp_common *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
 {
 	uint32_t invalue, i;
 	int retval = ERROR_OK;
@@ -1094,7 +1112,16 @@ static int mem_ap_read_buf_packed_u8(struct swjdp_common *swjdp,
 	return retval;
 }
 
-int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer, int count, uint32_t address)
+/**
+ * Synchronously read a block of bytes into a buffer
+ * @param swjdp The DAP connected to the MEM-AP.
+ * @param buffer where the bytes will be stored.
+ * @param count How many bytes to read.
+ * @param address Memory address from which to read data; all the
+ *	data must be readable by the currently selected MEM-AP.
+ */
+int mem_ap_read_buf_u8(struct swjdp_common *swjdp, uint8_t *buffer,
+		int count, uint32_t address)
 {
 	uint32_t invalue;
 	int retval = ERROR_OK;

commit 7abe9f38b2321b00b240fb7901dc408106fb07f8
Author: Hans Peter Mortensn <hp000 at space.aau.dk>
Date:   Wed Feb 24 23:35:12 2010 -0800

    AVR flash: handle AT90CAN128 chips
    
    I have successfully programmed the AT90CAN128, based on the mega128 ??
    with some small modifications.
    
    [ dbrownell at users.sourceforge.net: patch cleanup ]
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index c072419..5b40ad7 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -52,8 +52,11 @@
 
 struct avrf_type avft_chips_info[] =
 {
-//	 name,			chip_id,	flash_page_size,	flash_page_num,	eeprom_page_size,	eeprom_page_num
-	{"atmega128",	0x9702,		256,				512,			8,					512},
+/*	name, chip_id,	flash_page_size, flash_page_num,
+ *			eeprom_page_size, eeprom_page_num
+ */
+	{"atmega128",	0x9702, 256, 512, 8, 512},
+	{"at90can128",	0x9781, 256, 512, 8, 512},
 };
 
 int avr_jtag_sendinstr(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out);
@@ -200,8 +203,27 @@ FLASH_BANK_COMMAND_HANDLER(avrf_flash_bank_command)
 
 static int avrf_erase(struct flash_bank *bank, int first, int last)
 {
-	LOG_INFO("%s", __FUNCTION__);
-	return ERROR_OK;
+	struct target *target = bank->target;
+	struct avr_common *avr = target->arch_info;
+	int status;
+
+	LOG_DEBUG("%s", __FUNCTION__);
+
+	if (target->state != TARGET_HALTED)
+	{
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	status = avr_jtagprg_enterprogmode(avr);
+	if (status != ERROR_OK)
+		return status;
+
+	status = avr_jtagprg_chiperase(avr);
+	if (status != ERROR_OK)
+		return status;
+
+	return avr_jtagprg_leaveprogmode(avr);
 }
 
 static int avrf_protect(struct flash_bank *bank, int set, int first, int last)

-----------------------------------------------------------------------

Summary of changes:
 src/flash/nor/avrf.c      |   30 ++++++++++++++++++++---
 src/jtag/drivers/ft2232.c |   10 +++++--
 src/target/arm_adi_v5.c   |   57 +++++++++++++++++++++++++++++++++------------
 3 files changed, 75 insertions(+), 22 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sat Feb 27 09:52:24 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sat, 27 Feb 2010 08:52:24 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-24-ge70d42a
Message-ID: <E1NlIPR-0004m0-Ae@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  e70d42a727bebc5ae0ce0b1386620d30ea00b05b (commit)
       via  3ef9beb52cd0ed57ae6d28f7858001bfb68d7e86 (commit)
       via  8c9b52e8b615198252ab53e1b5c7cf5f314c5ca1 (commit)
       via  a3245bd7cdd2d8c3740c5e8f31efcd78de67837a (commit)
      from  4a64820f230a267b1f2e36d4be567074e5b8cb76 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit e70d42a727bebc5ae0ce0b1386620d30ea00b05b
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 27 00:31:35 2010 -0800

    new "stellaris recover" command
    
    Stellaris chips have a procedure for restoring the chip to
    what's effectively the "as-manufactured" state, with all the
    non-volatile memory erased.  That includes all flash memory,
    plus things like the flash protection bits and various control
    words which can for example disable debugger access.  clearly,
    this can be useful during development.
    
    Luminary/TI provides an MS-Windows utility to perform this
    procedure along with its Stellaris developer kits.  Now OpenOCD
    users will no longer need to use that MS-Windows utility.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/NEWS b/NEWS
index b39b3a8..56c697f 100644
--- a/NEWS
+++ b/NEWS
@@ -10,6 +10,12 @@ Boundary Scan:
 Target Layer:
 
 Flash Layer:
+	New "stellaris recover" command, implements the procedure
+		to recover locked devices (restoring non-volatile
+		state to the factory defaults, including erasing
+		the flash and its protection bits, and possibly
+		re-enabling hardware debugging).
+
 
 Board, Target, and Interface Configuration Scripts:
 
diff --git a/doc/openocd.texi b/doc/openocd.texi
index 61e39b2..aa8bed1 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -4497,6 +4497,21 @@ flash bank stellaris 0 0 0 0 $_TARGETNAME
 @end example
 @end deffn
 
+ at deffn Command {stellaris recover bank_id}
+Performs the @emph{Recovering a "Locked" Device} procedure to
+restore the flash specified by @var{bank_id} and its associated
+nonvolatile registers to their factory default values (erased).
+This is the only way to remove flash protection or re-enable
+debugging if that capability has been disabled.
+
+Note that the final "power cycle the chip" step in this procedure
+must be performed by hand, since OpenOCD can't do it.
+ at quotation Warning
+if more than one Stellaris chip is connected, the procedure is
+applied to all of them.
+ at end quotation
+ at end deffn
+
 @deffn {Flash Driver} stm32x
 All members of the STM32 microcontroller family from ST Microelectronics
 include internal flash and use ARM Cortex M3 cores.
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index 107b1c6..21a0cff 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -1170,13 +1170,79 @@ COMMAND_HANDLER(stellaris_handle_mass_erase_command)
 	return ERROR_OK;
 }
 
+/**
+ * Perform the Stellaris "Recovering a 'Locked' Device procedure.
+ * This performs a mass erase and then restores all nonvolatile registers
+ * (including USER_* registers and flash lock bits) to their defaults.
+ * Accordingly, flash can be reprogrammed, and JTAG can be used.
+ *
+ * NOTE that DustDevil parts (at least rev A0 silicon) have errata which
+ * can affect this operation if flash protection has been enabled.
+ */
+COMMAND_HANDLER(stellaris_handle_recover_command)
+{
+	struct flash_bank *bank;
+	int retval;
+
+	retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &bank);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* REVISIT ... it may be worth sanity checking that the AP is
+	 * inactive before we start.  ARM documents that switching a DP's
+	 * mode while it's active can cause fault modes that need a power
+	 * cycle to recover.
+	 */
+
+	/* assert SRST */
+	if (!(jtag_get_reset_config() & RESET_HAS_SRST)) {
+		LOG_ERROR("Can't recover Stellaris flash without SRST");
+		return ERROR_FAIL;
+	}
+	jtag_add_reset(0, 1);
+
+	for (int i = 0; i < 5; i++) {
+		retval = dap_to_swd(bank->target);
+		if (retval != ERROR_OK)
+			goto done;
+
+		retval = dap_to_jtag(bank->target);
+		if (retval != ERROR_OK)
+			goto done;
+	}
+
+	/* de-assert SRST */
+	jtag_add_reset(0, 0);
+	retval = jtag_execute_queue();
+
+	/* wait 400+ msec ... OK, "1+ second" is simpler */
+	sleep(1);
+
+	/* USER INTERVENTION required for the power cycle
+	 * Restarting OpenOCD is likely needed because of mode switching.
+	 */
+	LOG_INFO("USER ACTION:  "
+		"power cycle Stellaris chip, then restart OpenOCD.");
+
+done:
+	return retval;
+}
+
 static const struct command_registration stellaris_exec_command_handlers[] = {
 	{
 		.name = "mass_erase",
 		.handler = stellaris_handle_mass_erase_command,
 		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
 		.help = "erase entire device",
 	},
+	{
+		.name = "recover",
+		.handler = stellaris_handle_recover_command,
+		.mode = COMMAND_EXEC,
+		.usage = "bank_id",
+		.help = "recover locked device",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration stellaris_command_handlers[] = {

commit 3ef9beb52cd0ed57ae6d28f7858001bfb68d7e86
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 27 00:31:35 2010 -0800

    ADIv5 DAP ops switching to JTAG or SWD modes
    
    Define two new DAP operations which use the new jtag_add_tms_seq()
    calls to put the DAP's transport into either SWD or JTAG mode, when
    the hardware allows.
    
    Tested with the Stellaris 'Recovering a "Locked" Device' procedure,
    which loops five times over both of these.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 41f00ec..6be60af 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1716,3 +1716,116 @@ DAP_COMMAND_HANDLER(dap_apid_command)
 
 	return retval;
 }
+
+/*
+ * This represents the bits which must be sent out on TMS/SWDIO to
+ * switch a DAP implemented using an SWJ-DP module into SWD mode.
+ * These bits are stored (and transmitted) LSB-first.
+ *
+ * See the DAP-Lite specification, section 2.2.5 for information
+ * about making the debug link select SWD or JTAG.  (Similar info
+ * is in a few other ARM documents.)
+ */
+static const uint8_t jtag2swd_bitseq[] = {
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* Switching sequence enables SWD and disables JTAG
+	 * NOTE: bits in the DP's IDCODE may expose the need for
+	 * an old/deprecated sequence (0xb6 0xed).
+	 */
+	0x9e, 0xe7,
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+
+/**
+ * Put the debug link into SWD mode, if the target supports it.
+ * The link's initial mode may be either JTAG (for example,
+ * with SWJ-DP after reset) or SWD.
+ *
+ * @param target Enters SWD mode (if possible).
+ *
+ * Note that targets using the JTAG-DP do not support SWD, and that
+ * some targets which could otherwise support it may have have been
+ * configured to disable SWD signaling
+ *
+ * @return ERROR_OK or else a fault code.
+ */
+int dap_to_swd(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG("Enter SWD mode");
+
+	/* REVISIT it's nasty to need to make calls to a "jtag"
+	 * subsystem if the link isn't in JTAG mode...
+	 */
+
+	retval =  jtag_add_tms_seq(8 * sizeof(jtag2swd_bitseq),
+			jtag2swd_bitseq, TAP_INVALID);
+	if (retval == ERROR_OK)
+		retval = jtag_execute_queue();
+
+	/* REVISIT set up the DAP's ops vector for SWD mode. */
+
+	return retval;
+}
+
+/**
+ * This represents the bits which must be sent out on TMS/SWDIO to
+ * switch a DAP implemented using an SWJ-DP module into JTAG mode.
+ * These bits are stored (and transmitted) LSB-first.
+ *
+ * These bits are stored (and transmitted) LSB-first.
+ */
+static const uint8_t swd2jtag_bitseq[] = {
+	/* More than 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* Switching equence disables SWD and enables JTAG
+	 * NOTE: bits in the DP's IDCODE can expose the need for
+	 * the old/deprecated sequence (0xae 0xde).
+	 */
+	0x3c, 0xe7,
+	/* At least 50 TCK/SWCLK cycles with TMS/SWDIO high,
+	 * putting both JTAG and SWD logic into reset state.
+	 * NOTE:  some docs say "at least 5".
+	 */
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+};
+
+/** Put the debug link into JTAG mode, if the target supports it.
+ * The link's initial mode may be either SWD or JTAG.
+ *
+ * @param target Enters JTAG mode (if possible).
+ *
+ * Note that targets implemented with SW-DP do not support JTAG, and
+ * that some targets which could otherwise support it may have been
+ * configured to disable JTAG signaling
+ *
+ * @return ERROR_OK or else a fault code.
+ */
+int dap_to_jtag(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG("Enter JTAG mode");
+
+	/* REVISIT it's nasty to need to make calls to a "jtag"
+	 * subsystem if the link isn't in JTAG mode...
+	 */
+
+	retval = jtag_add_tms_seq(8 * sizeof(swd2jtag_bitseq),
+			swd2jtag_bitseq, TAP_RESET);
+	if (retval == ERROR_OK)
+		retval = jtag_execute_queue();
+
+	/* REVISIT set up the DAP's ops vector for JTAG mode. */
+
+	return retval;
+}
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 316701e..5c5ca4f 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -235,4 +235,12 @@ DAP_COMMAND_HANDLER(dap_memaccess_command);
 DAP_COMMAND_HANDLER(dap_apsel_command);
 DAP_COMMAND_HANDLER(dap_apid_command);
 
+struct target;
+
+/* Put debug link into SWD mode */
+int dap_to_swd(struct target *target);
+
+/* Put debug link into JTAG mode */
+int dap_to_jtag(struct target *target);
+
 #endif

commit 8c9b52e8b615198252ab53e1b5c7cf5f314c5ca1
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 27 00:12:38 2010 -0800

    ft2232: implement TMS sequence command
    
    Implement the new TMS_SEQ command on FT2232 hardware.
    Also, swap a bogus exit() call with a clean failure return.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 4b84fa8..5c6b655 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -1678,6 +1678,72 @@ static int ft2232_execute_statemove(struct jtag_command *cmd)
 	return retval;
 }
 
+/**
+ * Clock a bunch of TMS (or SWDIO) transitions, to change the JTAG
+ * (or SWD) state machine.
+ */
+static int ft2232_execute_tms(struct jtag_command *cmd)
+{
+	int		retval = ERROR_OK;
+	unsigned	num_bits = cmd->cmd.tms->num_bits;
+	const uint8_t	*bits = cmd->cmd.tms->bits;
+	unsigned	count;
+
+	DEBUG_JTAG_IO("TMS: %d bits", num_bits);
+
+	/* only send the maximum buffer size that FT2232C can handle */
+	count = 3 * DIV_ROUND_UP(num_bits, 4);
+	if (ft2232_buffer_size + 3*count + 1 > FT2232_BUFFER_SIZE) {
+		if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
+			retval = ERROR_JTAG_QUEUE_FAILED;
+
+		require_send = 0;
+		first_unsent = cmd;
+	}
+
+	/* Shift out in batches of at most 6 bits; there's a report of an
+	 * FT2232 bug in this area, where shifting exactly 7 bits can make
+	 * problems with TMS signaling for the last clock cycle:
+	 *
+	 *    http://developer.intra2net.com/mailarchive/html/
+	 *		libftdi/2009/msg00292.html
+	 *
+	 * Command 0x4b is: "Clock Data to TMS/CS Pin (no Read)"
+	 *
+	 * Note that pathmoves in JTAG are not often seven bits, so that
+	 * isn't a particularly likely situation outside of "special"
+	 * signaling such as switching between JTAG and SWD modes.
+	 */
+	while (num_bits) {
+		if (num_bits <= 6) {
+			buffer_write(0x4b);
+			buffer_write(num_bits - 1);
+			buffer_write(*bits & 0x3f);
+			break;
+		}
+
+		/* Yes, this is lazy ... we COULD shift out more data
+		 * bits per operation, but doing it in nybbles is easy
+		 */
+		buffer_write(0x4b);
+		buffer_write(3);
+		buffer_write(*bits & 0xf);
+		num_bits -= 4;
+
+		count  = (num_bits > 4) ? 4 : num_bits;
+
+		buffer_write(0x4b);
+		buffer_write(count - 1);
+		buffer_write((*bits >> 4) & 0xf);
+		num_bits -= count;
+
+		bits++;
+	}
+
+	require_send = 1;
+	return retval;
+}
+
 static int ft2232_execute_pathmove(struct jtag_command *cmd)
 {
 	int	predicted_size = 0;
@@ -1830,7 +1896,6 @@ static int ft2232_execute_stableclocks(struct jtag_command *cmd)
 static int ft2232_execute_command(struct jtag_command *cmd)
 {
 	int retval;
-	retval = ERROR_OK;
 
 	switch (cmd->type)
 	{
@@ -1841,9 +1906,13 @@ static int ft2232_execute_command(struct jtag_command *cmd)
 	case JTAG_SCAN:		retval = ft2232_execute_scan(cmd); break;
 	case JTAG_SLEEP:	retval = ft2232_execute_sleep(cmd); break;
 	case JTAG_STABLECLOCKS:	retval = ft2232_execute_stableclocks(cmd); break;
+	case JTAG_TMS:
+		retval = ft2232_execute_tms(cmd);
+		break;
 	default:
 		LOG_ERROR("BUG: unknown JTAG command type encountered");
-		exit(-1);
+		retval = ERROR_JTAG_QUEUE_FAILED;
+		break;
 	}
 	return retval;
 }
@@ -4108,6 +4177,7 @@ static const struct command_registration ft2232_command_handlers[] = {
 
 struct jtag_interface ft2232_interface = {
 	.name = "ft2232",
+	.supported = DEBUG_CAP_TMS_SEQ,
 	.commands = ft2232_command_handlers,
 
 	.init = ft2232_init,

commit a3245bd7cdd2d8c3740c5e8f31efcd78de67837a
Author: David Brownell <dbrownell at users.sourceforge.net>
Date:   Sat Feb 27 00:12:38 2010 -0800

    interface: define TMS sequence command
    
    For support of SWD we need to be able to clock out special bit
    sequences over TMS or SWDIO.  Create this as a generic operation,
    not yet called by anything, which is split as usual into:
    
     - upper level abstraction ... here, jtag_add_tms_seq();
     - midlayer implementation logic hooking that to the lowlevel code;
     - lowlevel minidriver operation ... here, interface_add_tms_seq();
     - message type for request queue, here JTAG_TMS.
    
    This is done slightly differently than other operations: there's a flag
    saying whether the interface driver supports this request.  (In fact a
    flag *word* so upper layers can learn about other capabilities too ...
    for example, supporting SWD operations.)
    
    That approach (flag) lets this method *eventually* be used to eliminate
    pathmove() and statemove() support from most adapter drivers, by moving
    all that logic into the mid-layer and increasing uniformity between the
    various drivers.  (Which will in turn reduce subtle bugginess.)
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/src/jtag/commands.h b/src/jtag/commands.h
index b10b545..692eee4 100644
--- a/src/jtag/commands.h
+++ b/src/jtag/commands.h
@@ -99,18 +99,38 @@ struct sleep_command {
 };
 
 /**
+ * Encapsulates a series of bits to be clocked out, affecting state
+ * and mode of the interface.
+ *
+ * In JTAG mode these are clocked out on TMS, using TCK.  They may be
+ * used for link resets, transitioning between JTAG and SWD modes, or
+ * to implement JTAG state machine transitions (implementing pathmove
+ * or statemove operations).
+ *
+ * In SWD mode these are clocked out on SWDIO, using SWCLK, and are
+ * used for link resets and transitioning between SWD and JTAG modes.
+ */
+struct tms_command {
+	/** How many bits should be clocked out. */
+	unsigned	num_bits;
+	/** The bits to clock out; the LSB is bit 0 of bits[0].  */
+	const uint8_t		*bits;
+};
+
+/**
  * Defines a container type that hold a pointer to a JTAG command
  * structure of any defined type.
  */
 union jtag_command_container {
-	struct scan_command*         scan;
-	struct statemove_command*    statemove;
-	struct pathmove_command*     pathmove;
-	struct runtest_command*      runtest;
-	struct stableclocks_command* stableclocks;
-	struct reset_command*        reset;
-	struct end_state_command*    end_state;
-	struct sleep_command* sleep;
+	struct scan_command		*scan;
+	struct statemove_command	*statemove;
+	struct pathmove_command		*pathmove;
+	struct runtest_command		*runtest;
+	struct stableclocks_command	*stableclocks;
+	struct reset_command		*reset;
+	struct end_state_command	*end_state;
+	struct sleep_command		*sleep;
+	struct tms_command		*tms;
 };
 
 /**
@@ -124,7 +144,8 @@ enum jtag_command_type {
 	JTAG_RESET        = 4,
 	JTAG_PATHMOVE     = 6,
 	JTAG_SLEEP        = 7,
-	JTAG_STABLECLOCKS = 8
+	JTAG_STABLECLOCKS = 8,
+	JTAG_TMS          = 9,
 };
 
 struct jtag_command {
diff --git a/src/jtag/core.c b/src/jtag/core.c
index 4f517c0..7f417b7 100644
--- a/src/jtag/core.c
+++ b/src/jtag/core.c
@@ -488,6 +488,35 @@ void jtag_add_tlr(void)
 	jtag_notify_event(JTAG_TRST_ASSERTED);
 }
 
+/**
+ * If supported by the underlying adapter, this clocks a raw bit sequence
+ * onto TMS for switching betwen JTAG and SWD modes.
+ *
+ * DO NOT use this to bypass the integrity checks and logging provided
+ * by the jtag_add_pathmove() and jtag_add_statemove() calls.
+ *
+ * @param nbits How many bits to clock out.
+ * @param seq The bit sequence.  The LSB is bit 0 of seq[0].
+ * @param state The JTAG tap state to record on completion.  Use
+ *	TAP_INVALID to represent being in in SWD mode.
+ *
+ * @todo Update naming conventions to stop assuming everything is JTAG.
+ */
+int jtag_add_tms_seq(unsigned nbits, const uint8_t *seq, enum tap_state state)
+{
+	int retval;
+
+	if (!(jtag->supported & DEBUG_CAP_TMS_SEQ))
+		return ERROR_JTAG_NOT_IMPLEMENTED;
+
+	jtag_checks();
+	cmd_queue_cur_state = state;
+
+	retval = interface_add_tms_seq(nbits, seq);
+	jtag_set_error(retval);
+	return retval;
+}
+
 void jtag_add_pathmove(int num_states, const tap_state_t *path)
 {
 	tap_state_t cur_state = cmd_queue_cur_state;
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 45c5d10..14efe96 100644
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -388,6 +388,31 @@ int interface_jtag_add_tlr(void)
 	return ERROR_OK;
 }
 
+int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq)
+{
+	struct jtag_command *cmd;
+
+	cmd = cmd_queue_alloc(sizeof(struct jtag_command));
+	if (cmd == NULL)
+		return ERROR_FAIL;
+
+	cmd->type = JTAG_TMS;
+	cmd->cmd.tms = cmd_queue_alloc(sizeof(*cmd->cmd.tms));
+	if (!cmd->cmd.tms)
+		return ERROR_FAIL;
+
+	/* copy the bits; our caller doesn't guarantee they'll persist */
+	cmd->cmd.tms->num_bits = num_bits;
+	cmd->cmd.tms->bits = buf_cpy(seq,
+			cmd_queue_alloc(DIV_ROUND_UP(num_bits, 8)), num_bits);
+	if (!cmd->cmd.tms->bits)
+		return ERROR_FAIL;
+
+	jtag_queue_command(cmd);
+
+	return ERROR_OK;
+}
+
 int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 {
 	/* allocate memory for a new list member */
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
index a264d69..0d47404 100644
--- a/src/jtag/interface.h
+++ b/src/jtag/interface.h
@@ -184,11 +184,29 @@ static inline tap_state_t jtag_debug_state_machine(const void *tms_buf,
 }
 #endif // _DEBUG_JTAG_IO_
 
+/**
+ * Represents a driver for a debugging interface.
+ *
+ * @todo Rename; perhaps "debug_driver".  This isn't an interface,
+ * it's a driver!  Also, not all drivers support JTAG.
+ *
+ * @todo We need a per-instance structure too, and changes to pass
+ * that structure to the driver.  Instances can for example be in
+ * either SWD or JTAG modes.  This will help remove globals, and
+ * eventually to cope with systems which have more than one such
+ * debugging interface.
+ */
 struct jtag_interface {
 	/// The name of the JTAG interface driver.
 	char* name;
 
 	/**
+	 * Bit vector listing capabilities exposed by this driver.
+	 */
+	unsigned supported;
+#define DEBUG_CAP_TMS_SEQ	(1 << 0)
+
+	/**
 	 * Execute queued commands.
 	 * @returns ERROR_OK on success, or an error code on failure.
 	 */
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 0555754..7e5dc10 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -575,6 +575,8 @@ tap_state_t jtag_get_end_state(void);
 
 void jtag_add_sleep(uint32_t us);
 
+int jtag_add_tms_seq(unsigned nbits, const uint8_t *seq, enum tap_state t);
+
 /**
  * Function jtag_add_clocks
  * first checks that the state in which the clocks are to be issued is
@@ -693,7 +695,7 @@ int jtag_error_clear(void);
 /**
  * Return true if it's safe for a background polling task to access the
  * JTAG scan chain.  Polling may be explicitly disallowed, and is also
- * unsafe while nTRST is active or the JTAG clock is gated off.,
+ * unsafe while nTRST is active or the JTAG clock is gated off.
  */
 bool is_jtag_poll_safe(void);
 
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 2109c75..5caec58 100644
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -67,6 +67,8 @@ int interface_jtag_add_tlr(void);
 int interface_jtag_add_pathmove(int num_states, const tap_state_t* path);
 int interface_jtag_add_runtest(int num_cycles, tap_state_t endstate);
 
+int interface_add_tms_seq(unsigned num_bits, const uint8_t *bits);
+
 /**
  * This drives the actual srst and trst pins. srst will always be 0
  * if jtag_reset_config & RESET_SRST_PULLS_TRST != 0 and ditto for
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
index 9c608cd..6410c2d 100644
--- a/src/jtag/minidummy/minidummy.c
+++ b/src/jtag/minidummy/minidummy.c
@@ -147,6 +147,13 @@ int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 	return ERROR_OK;
 }
 
+int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq)
+{
+	/* synchronously do the operation here */
+
+	return ERROR_OK;
+}
+
 void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
 {
 	int i;
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index d920c30..e21104c 100644
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -804,7 +804,16 @@ int interface_jtag_add_pathmove(int num_states, const tap_state_t *path)
 	return ERROR_OK;
 }
 
-
+int interface_add_tms_seq(unsigned num_bits, const uint8_t *seq)
+{
+	/* FIXME just implement this, like pathmove but without
+	 * JTAG-specific state transition checking.  Then update
+	 * zy1000_interface to report that it's supported.
+	 *
+	 * Eventually interface_jtag_add_pathmove() could vanish.
+	 */
+	return ERROR_JTAG_NOT_IMPLEMENTED;
+}
 
 void embeddedice_write_dcc(struct jtag_tap *tap, int reg_addr, uint8_t *buffer, int little, int count)
 {

-----------------------------------------------------------------------

Summary of changes:
 NEWS                           |    6 ++
 doc/openocd.texi               |   15 +++++
 src/flash/nor/stellaris.c      |   66 +++++++++++++++++++++++
 src/jtag/commands.h            |   39 +++++++++++---
 src/jtag/core.c                |   29 ++++++++++
 src/jtag/drivers/driver.c      |   25 +++++++++
 src/jtag/drivers/ft2232.c      |   74 +++++++++++++++++++++++++-
 src/jtag/interface.h           |   18 ++++++
 src/jtag/jtag.h                |    4 +-
 src/jtag/minidriver.h          |    2 +
 src/jtag/minidummy/minidummy.c |    7 +++
 src/jtag/zy1000/zy1000.c       |   11 ++++-
 src/target/arm_adi_v5.c        |  113 ++++++++++++++++++++++++++++++++++++++++
 src/target/arm_adi_v5.h        |    8 +++
 14 files changed, 404 insertions(+), 13 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 28 07:54:44 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 28 Feb 2010 06:54:44 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-26-g6376334
Message-ID: <E1Nld37-0004Ua-Pk@sfp-scmshell-4.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  63763345d94b11f106c832c23e8ad730a4485723 (commit)
       via  e4a40d257d6c8fa393929cda50c0a1d777787da2 (commit)
      from  e70d42a727bebc5ae0ce0b1386620d30ea00b05b (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 63763345d94b11f106c832c23e8ad730a4485723
Author: Mariano Alvira <mar at devl.org>
Date:   Sat Feb 27 22:52:34 2010 -0800

    add board/redbee-econotag.cfg and JTAG support
    
    The Redbee Econotag is an open hardware development kit from
    Redwire, LLC (www.redwirellc.com/store), for the Freescale
    MC13224V ARM7TDMI + 802.15.4 radio.
    
    It includes both an MC13224V and an FT2232H (for JTAG and UART
    support).  It has flexible power supply options.
    
    Additional features are:
    
      - inverted-F pcb antenna
      - 36 GPIO brought out to 0.1" pin header
        (includes all peripheral pins)
      - Reset button
      - Two push buttons (on kbi1-5 and kbi0-4)
      - USB-A connector, powered from USB
      - up to 16V external input
      - pads for optional buck inductor
      - pads for optional 32.768kHz crystal
      - 2x LEDS on TX_ON and RX_ON
    
    [ dbrownell at users.sourceforge.net: shrink lines; texi ]
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index aa8bed1..c6113ab 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2130,6 +2130,7 @@ to debug some other target.  It can support the SWO trace mechanism.
 @item @b{olimex-jtag} Olimex ARM-USB-OCD and ARM-USB-Tiny
 @item @b{oocdlink} OOCDLink
 @c oocdlink ~= jtagkey_prototype_v1
+ at item @b{redbee-econotag} Integrated with a Redbee development board.
 @item @b{sheevaplug} Marvell Sheevaplug development kit
 @item @b{signalyzer} Xverve Signalyzer
 @item @b{stm32stick} Hitex STM32 Performance Stick
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index 5c6b655..d2e96d0 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -162,6 +162,7 @@ static int icebear_jtag_init(void);
 static int cortino_jtag_init(void);
 static int signalyzer_h_init(void);
 static int ktlink_init(void);
+static int redbee_init(void);
 
 /* reset procedures for supported layouts */
 static void usbjtag_reset(int trst, int srst);
@@ -176,6 +177,7 @@ static void sheevaplug_reset(int trst, int srst);
 static void icebear_jtag_reset(int trst, int srst);
 static void signalyzer_h_reset(int trst, int srst);
 static void ktlink_reset(int trst, int srst);
+static void redbee_reset(int trst, int srst);
 
 /* blink procedures for layouts that support a blinking led */
 static void olimex_jtag_blink(void);
@@ -263,6 +265,10 @@ static const struct ft2232_layout  ft2232_layouts[] =
 		.reset = ktlink_reset,
 		.blink = ktlink_blink
 	},
+	{ .name = "redbee-econotag",
+		.init = redbee_init,
+		.reset = redbee_reset,
+	},
 	{ .name = NULL, /* END OF TABLE */ },
 };
 
@@ -1577,6 +1583,36 @@ static void sheevaplug_reset(int trst, int srst)
 	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, high_direction: 0x%2.2x", trst, srst, high_output, high_direction);
 }
 
+static void redbee_reset(int trst, int srst)
+{
+	if (trst == 1)
+	{
+		tap_set_state(TAP_RESET);
+		high_output &= ~nTRST;
+	}
+	else if (trst == 0)
+	{
+		high_output |= nTRST;
+	}
+
+	if (srst == 1)
+	{
+		high_output &= ~nSRST;
+	}
+	else if (srst == 0)
+	{
+		high_output |= nSRST;
+	}
+
+	/* command "set data bits low byte" */
+	buffer_write(0x82);
+	buffer_write(high_output);
+	buffer_write(high_direction);
+	LOG_DEBUG("trst: %i, srst: %i, high_output: 0x%2.2x, "
+			"high_direction: 0x%2.2x", trst, srst, high_output,
+			high_direction);
+}
+
 static int ft2232_execute_runtest(struct jtag_command *cmd)
 {
 	int retval;
@@ -2478,6 +2514,73 @@ static int axm0432_jtag_init(void)
 	return ERROR_OK;
 }
 
+static int redbee_init(void)
+{
+	uint8_t  buf[3];
+	uint32_t bytes_written;
+
+	low_output    = 0x08;
+	low_direction = 0x2b;
+
+	/* initialize low byte for jtag */
+	/* command "set data bits low byte" */
+	buf[0] = 0x80;
+	/* value (TMS = 1,TCK = 0, TDI = 0, nOE = 0) */
+	buf[2] = low_direction;
+	/* dir (output = 1), TCK/TDI/TMS = out, TDO = in, nOE = out */
+	buf[1] = low_output;
+	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
+
+	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK)
+			|| (bytes_written != 3))
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'redbee' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	nTRST    = 0x08;
+	nTRSTnOE = 0x0;     /* No output enable for TRST*/
+	nSRST    = 0x04;
+	nSRSTnOE = 0x0;     /* No output enable for SRST*/
+
+	high_output    = 0x0;
+	high_direction = 0x0c;
+
+	enum reset_types jtag_reset_config = jtag_get_reset_config();
+	if (jtag_reset_config & RESET_TRST_OPEN_DRAIN)
+	{
+		LOG_ERROR("can't set nTRSTOE to push-pull on redbee");
+	}
+	else
+	{
+		high_output |= nTRST;
+	}
+
+	if (jtag_reset_config & RESET_SRST_PUSH_PULL)
+	{
+		LOG_ERROR("can't set nSRST to push-pull on redbee");
+	}
+	else
+	{
+		high_output |= nSRST;
+	}
+
+	/* initialize high port */
+	buf[0] = 0x82;              /* command "set data bits high byte" */
+	buf[1] = high_output;       /* value */
+	buf[2] = high_direction;    /* all outputs (xRST and xRSTnOE) */
+	LOG_DEBUG("%2.2x %2.2x %2.2x", buf[0], buf[1], buf[2]);
+
+	if (((ft2232_write(buf, 3, &bytes_written)) != ERROR_OK)
+			|| (bytes_written != 3))
+	{
+		LOG_ERROR("couldn't initialize FT2232 with 'redbee' layout");
+		return ERROR_JTAG_INIT_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
 static int jtagkey_init(void)
 {
 	uint8_t  buf[3];
diff --git a/tcl/board/redbee-econotag.cfg b/tcl/board/redbee-econotag.cfg
new file mode 100644
index 0000000..7a02ce0
--- /dev/null
+++ b/tcl/board/redbee-econotag.cfg
@@ -0,0 +1,8 @@
+source [find target/mc13224v.cfg]
+
+# The redbee-econotag has an onboard ft2232h with channel A wired
+# to the JTAG pins on the mc13224v
+# channel B is wired to UART1
+interface ft2232
+ft2232_layout redbee-econotag
+ft2232_vid_pid 0x0403 0x6010

commit e4a40d257d6c8fa393929cda50c0a1d777787da2
Author: Mariano Alvira <mar at devl.org>
Date:   Sat Feb 27 22:51:41 2010 -0800

    Add target/mc13224v.cfg
    
    The MC13224V is a FreeScale ARM7TDMI based IEEE802.15.4 platform for
    Zigbee and similar low-power wireless applications. Using PIP
    (Platform In Package) technology, it integrates: an RF balun and
    matching network; a buck converter (only an external inductor is
    necessary); 96KB of SRAM; and 128KB of non-volatile memory.
    
    It has an integrated bootloader and can boot from a variety of sources:
    external SPI or I2C non-volatile memory, an image loaded over UART1,
    or the internal non-volatile memory. The image loaded from one of these
    sources is executed directly from SRAM starting at location 0x00400000.
    
    Open source development code at http://mc1322x.devl.org
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/tcl/target/mc13224v.cfg b/tcl/target/mc13224v.cfg
new file mode 100644
index 0000000..497e376
--- /dev/null
+++ b/tcl/target/mc13224v.cfg
@@ -0,0 +1,54 @@
+source [find bitsbytes.tcl]
+source [find cpu/arm/arm7tdmi.tcl]
+source [find memory.tcl]
+source [find mmr_helpers.tcl]
+
+set CHIP_MAKER  freescale
+set CHIP_FAMILY mc1322x
+set CHIP_NAME  mc13224
+set N_RAM 1
+set RAM(0,BASE)  0x00400000
+set RAM(0,LEN)   0x18000
+set RAM(0,HUMAN) "internal SRAM"
+set RAM(0,TYPE)            "ram"
+set RAM(0,RWX)             $RWX_RWX
+set RAM(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY
+
+# I AM LAZY... I create 1 region for all MMRs.
+set N_MMREGS    1
+set MMREGS(0,CHIPSELECT)      -1
+set MMREGS(0,BASE)            0x80000000
+set MMREGS(0,LEN)             0x00030000
+set MMREGS(0,HUMAN)           "mm-regs"
+set MMREGS(0,TYPE)            "mmr"
+set MMREGS(0,RWX)             $RWX_RW
+set MMREGS(0,ACCESS_WIDTH)    $ACCESS_WIDTH_ANY
+
+set N_XMEM 0
+
+set _CHIPNAME mc13224v
+set _CPUTAPID 0x1f1f001d
+
+jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_CPUTAPID
+
+reset_config srst_only
+jtag_ntrst_delay 200
+
+# rclk hasn't been working well. This maybe the mc13224v or something else.
+#jtag_rclk 2000
+jtag_khz 2000
+
+######################
+# Target configuration
+######################
+
+set _TARGETNAME $_CHIPNAME.cpu
+target create $_TARGETNAME arm7tdmi -chain-position $_TARGETNAME
+
+# Internal sram memory
+$_TARGETNAME configure -work-area-phys 0x00408000 \
+                       -work-area-size 0x1000     \
+                       -work-area-backup 1
+
+# flash support is pending (should be straightforward to implement)
+#flash bank mc1322x 0 0 0 0 $_TARGETNAME

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi              |    1 +
 src/jtag/drivers/ft2232.c     |  103 +++++++++++++++++++++++++++++++++++++++++
 tcl/board/redbee-econotag.cfg |    8 +++
 tcl/target/mc13224v.cfg       |   54 +++++++++++++++++++++
 4 files changed, 166 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/redbee-econotag.cfg
 create mode 100644 tcl/target/mc13224v.cfg


hooks/post-receive
-- 
Main OpenOCD repository


From dbrownell at users.sourceforge.net  Sun Feb 28 19:34:41 2010
From: dbrownell at users.sourceforge.net (David Brownell)
Date: Sun, 28 Feb 2010 18:34:41 +0000
Subject: [openocd-svn] Main OpenOCD repository branch, master,
	updated. v0.4.0-27-g0324eb2
Message-ID: <E1NlnyV-0001NW-2d@sfp-scmshell-3.v30.ch3.sourceforge.com>

This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project "Main OpenOCD repository".

The branch, master has been updated
       via  0324eb24967088f753bc2fd997b4c18f4ea988c8 (commit)
      from  63763345d94b11f106c832c23e8ad730a4485723 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 0324eb24967088f753bc2fd997b4c18f4ea988c8
Author: Mariano Alvira <mar at devl.org>
Date:   Sun Feb 28 10:33:46 2010 -0800

    Add board/redbee-usb.cfg
    
    The Redbee USB is a small form-factor usb stick from Redwire, LLC
    (www.redwirellc.com/store), built around a Freescale MC13224V
    ARM7TDMI + 802.15.4 radio (plus antenna).
    
    It includes an FT2232H for debugging, with Channel B connected to the
    mc13224v's JTAG interface (unusual) and Channel A connected to UART1.
    
    Signed-off-by: David Brownell <dbrownell at users.sourceforge.net>

diff --git a/doc/openocd.texi b/doc/openocd.texi
index c6113ab..9da2977 100644
--- a/doc/openocd.texi
+++ b/doc/openocd.texi
@@ -2131,6 +2131,7 @@ to debug some other target.  It can support the SWO trace mechanism.
 @item @b{oocdlink} OOCDLink
 @c oocdlink ~= jtagkey_prototype_v1
 @item @b{redbee-econotag} Integrated with a Redbee development board.
+ at item @b{redbee-usb} Integrated with a Redbee USB-stick development board.
 @item @b{sheevaplug} Marvell Sheevaplug development kit
 @item @b{signalyzer} Xverve Signalyzer
 @item @b{stm32stick} Hitex STM32 Performance Stick
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
index d2e96d0..43e7b9f 100644
--- a/src/jtag/drivers/ft2232.c
+++ b/src/jtag/drivers/ft2232.c
@@ -269,6 +269,11 @@ static const struct ft2232_layout  ft2232_layouts[] =
 		.init = redbee_init,
 		.reset = redbee_reset,
 	},
+	{ .name = "redbee-usb",
+		.init = redbee_init,
+	        .reset = redbee_reset,
+    	        .channel = INTERFACE_B,
+	},
 	{ .name = NULL, /* END OF TABLE */ },
 };
 
diff --git a/tcl/board/redbee-usb.cfg b/tcl/board/redbee-usb.cfg
new file mode 100644
index 0000000..3aa68c1
--- /dev/null
+++ b/tcl/board/redbee-usb.cfg
@@ -0,0 +1,8 @@
+source [find target/mc13224v.cfg]
+
+# The redbee-econotag has an onboard ft2232h with
+# channel B wired to the JTAG pins on the mc13224v
+# channel A is wired to UART1 on the mc13224v
+interface ft2232
+ft2232_layout redbee-usb
+ft2232_vid_pid 0x0403 0x6010

-----------------------------------------------------------------------

Summary of changes:
 doc/openocd.texi          |    1 +
 src/jtag/drivers/ft2232.c |    5 +++++
 tcl/board/redbee-usb.cfg  |    8 ++++++++
 3 files changed, 14 insertions(+), 0 deletions(-)
 create mode 100644 tcl/board/redbee-usb.cfg


hooks/post-receive
-- 
Main OpenOCD repository


