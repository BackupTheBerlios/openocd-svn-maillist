<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-736-g63dc352
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-736-g63dc352&In-Reply-To=%3CE1NFOR2-0004xA-VG%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001894.html">
   <LINK REL="Next"  HREF="001896.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-736-g63dc352</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-736-g63dc352&In-Reply-To=%3CE1NFOR2-0004xA-VG%40sfp-scmshell-4.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-736-g63dc352">dbrownell at users.sourceforge.net
       </A><BR>
    <I>Tue Dec  1 09:50:10 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001894.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-730-g51e9b25
</A></li>
        <LI>Next message: <A HREF="001896.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-738-g445da54
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1895">[ date ]</a>
              <a href="thread.html#1895">[ thread ]</a>
              <a href="subject.html#1895">[ subject ]</a>
              <a href="author.html#1895">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  63dc352876259562948b5d814de197ba534897b9 (commit)
       via  5949a3b3a55d987008b63b80af42c08601babb75 (commit)
       via  563d937c3c6a7080998baa2313d66ae184b820ac (commit)
       via  177bbd8891ae737ea7f8c0791a6236f72cedee40 (commit)
       via  209a0197f0c79442a2314199170a957c36c0ddb6 (commit)
       via  fb984a477d526b742855bfe0ab07f4dced3b9323 (commit)
      from  51e9b25c9ae3478989940f925a36d78364d88764 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 63dc352876259562948b5d814de197ba534897b9
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Tue Dec 1 00:49:16 2009 -0800

    ARM11: remove previous mcr()/mrc() methods
    
    We don't need this code, now that the DPM code handles it.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 30dbedb..fd9b465 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -1219,13 +1219,6 @@ static int arm11_remove_watchpoint(struct target *target,
 	return ERROR_FAIL;
 }
 
-static int arm11_mrc(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2,
-		uint32_t CRn, uint32_t CRm, uint32_t *value);
-static int arm11_mcr(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn,
-		uint32_t CRm, uint32_t value);
-
 static int arm11_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct arm11_common *arm11;
@@ -1245,9 +1238,6 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 
 	armv4_5_init_arch_info(target, &amp;arm11-&gt;arm);
 
-	arm11-&gt;arm.mrc = arm11_mrc;
-	arm11-&gt;arm.mcr = arm11_mcr;
-
 	arm11-&gt;target = target;
 
 	arm11-&gt;jtag_info.tap = target-&gt;tap;
@@ -1520,71 +1510,6 @@ COMMAND_HANDLER(arm11_handle_vcr)
 	return ERROR_OK;
 }
 
-static const uint32_t arm11_coproc_instruction_limits[] =
-{
-	15,				/* coprocessor */
-	7,				/* opcode 1 */
-	15,				/* CRn */
-	15,				/* CRm */
-	7,				/* opcode 2 */
-	0xFFFFFFFF,		/* value */
-};
-
-static int arm11_mrc_inner(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
-		uint32_t *value, bool read)
-{
-	int retval;
-	struct arm11_common *arm11 = target_to_arm11(target);
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_FAIL;
-	}
-
-	uint32_t instr = 0xEE000010	|
-		(cpnum &lt;&lt;  8) |
-		(op1 &lt;&lt; 21) |
-		(CRn &lt;&lt; 16) |
-		(CRm &lt;&lt;  0) |
-		(op2 &lt;&lt;  5);
-
-	if (read)
-		instr |= 0x00100000;
-
-	retval = arm11_run_instr_data_prepare(arm11);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (read)
-	{
-		retval = arm11_run_instr_data_from_core_via_r0(arm11, instr, value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-	else
-	{
-		retval = arm11_run_instr_data_to_core_via_r0(arm11, instr, *value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	return arm11_run_instr_data_finish(arm11);
-}
-
-static int arm11_mrc(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	return arm11_mrc_inner(target, cpnum, op1, op2, CRn, CRm, value, true);
-}
-
-static int arm11_mcr(struct target *target, int cpnum,
-		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	return arm11_mrc_inner(target, cpnum, op1, op2, CRn, CRm, &amp;value, false);
-}
-
 static const struct command_registration arm11_mw_command_handlers[] = {
 	{
 		.name = &quot;burst&quot;,

commit 5949a3b3a55d987008b63b80af42c08601babb75
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Tue Dec 1 00:49:11 2009 -0800

    Cortex-A8: remove previous mcr()/mrc() methods
    
    We don't need this code, now that the DPM code handles it.
    Neither do we need the ARMv7-A CP15 operations; remove their
    remnants too.  And disable a mostly-needless diagnostic.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index f843f03..ee0d2ac 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -62,13 +62,6 @@ struct armv7a_common
 	/* Cache and Memory Management Unit */
 	struct armv4_5_mmu_common armv4_5_mmu;
 
-	int (*read_cp15)(struct target *target,
-			uint32_t op1, uint32_t op2,
-			uint32_t CRn, uint32_t CRm, uint32_t *value);
-	int (*write_cp15)(struct target *target,
-			uint32_t op1, uint32_t op2,
-			uint32_t CRn, uint32_t CRm, uint32_t value);
-
 	int (*examine_debug_reason)(struct target *target);
 	void (*post_debug_entry)(struct target *target);
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 9ce6b2b..e312e54 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -159,97 +159,6 @@ static int cortex_a8_read_regs_through_mem(struct target *target, uint32_t addre
 	return retval;
 }
 
-static int cortex_a8_read_cp(struct target *target, uint32_t *value, uint8_t CP,
-		uint8_t op1, uint8_t CRn, uint8_t CRm, uint8_t op2)
-{
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &amp;armv7a-&gt;swjdp_info;
-	uint32_t dscr = 0;
-
-	/* MRC(...) to read coprocessor register into r0 */
-	cortex_a8_exec_opcode(target, ARMV4_5_MRC(CP, op1, 0, CRn, CRm, op2),
-			&amp;dscr);
-
-	/* Move R0 to DTRTX */
-	cortex_a8_exec_opcode(target, ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-			&amp;dscr);
-
-	/* Read DCCTX */
-	retval = mem_ap_read_atomic_u32(swjdp,
-			armv7a-&gt;debug_base + CPUDBG_DTRTX, value);
-
-	return retval;
-}
-
-static int cortex_a8_write_cp(struct target *target, uint32_t value,
-	uint8_t CP, uint8_t op1, uint8_t CRn, uint8_t CRm, uint8_t op2)
-{
-	int retval;
-	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct swjdp_common *swjdp = &amp;armv7a-&gt;swjdp_info;
-
-	LOG_DEBUG(&quot;CP%i, CRn %i, value 0x%08&quot; PRIx32, CP, CRn, value);
-
-	/* Check that DCCRX is not full */
-	retval = mem_ap_read_atomic_u32(swjdp,
-				armv7a-&gt;debug_base + CPUDBG_DSCR, &amp;dscr);
-	if (dscr &amp; (1 &lt;&lt; DSCR_DTR_RX_FULL))
-	{
-		LOG_ERROR(&quot;DSCR_DTR_RX_FULL, dscr 0x%08&quot; PRIx32, dscr);
-		/* Clear DCCRX with MCR(p14, 0, Rd, c0, c5, 0), opcode  0xEE000E15 */
-		cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&amp;dscr);
-	}
-
-	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
-	retval = mem_ap_write_u32(swjdp,
-			armv7a-&gt;debug_base + CPUDBG_DTRRX, value);
-
-	/* Move DTRRX to r0 */
-	cortex_a8_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &amp;dscr);
-
-	/* MCR(...) to write r0 to coprocessor */
-	return cortex_a8_exec_opcode(target,
-			ARMV4_5_MCR(CP, op1, 0, CRn, CRm, op2),
-			&amp;dscr);
-}
-
-static int cortex_a8_read_cp15(struct target *target, uint32_t op1, uint32_t op2,
-		uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	return cortex_a8_read_cp(target, value, 15, op1, CRn, CRm, op2);
-}
-
-static int cortex_a8_write_cp15(struct target *target, uint32_t op1, uint32_t op2,
-		uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	return cortex_a8_write_cp(target, value, 15, op1, CRn, CRm, op2);
-}
-
-static int cortex_a8_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	if (cpnum!=15)
-	{
-		LOG_ERROR(&quot;Only cp15 is supported&quot;);
-		return ERROR_FAIL;
-	}
-	return cortex_a8_read_cp15(target, op1, op2, CRn, CRm, value);
-}
-
-static int cortex_a8_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	if (cpnum!=15)
-	{
-		LOG_ERROR(&quot;Only cp15 is supported&quot;);
-		return ERROR_FAIL;
-	}
-	return cortex_a8_write_cp15(target, op1, op2, CRn, CRm, value);
-}
-
-
-
 static int cortex_a8_dap_read_coreregister_u32(struct target *target,
 		uint32_t *value, int regnum)
 {
@@ -421,7 +330,7 @@ static int cortex_a8_read_dcc(struct cortex_a8_common *a8, uint32_t *data,
 
 	retval = mem_ap_read_atomic_u32(swjdp,
 			a8-&gt;armv7a_common.debug_base + CPUDBG_DTRTX, data);
-	LOG_DEBUG(&quot;read DCC 0x%08&quot; PRIx32, *data);
+	//LOG_DEBUG(&quot;read DCC 0x%08&quot; PRIx32, *data);
 
 	if (dscr_p)
 		*dscr_p = dscr;
@@ -1612,9 +1521,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 	cortex_a8-&gt;common_magic = CORTEX_A8_COMMON_MAGIC;
 	armv4_5-&gt;arch_info = armv7a;
 
-	armv4_5-&gt;mrc = cortex_a8_mrc,
-	armv4_5-&gt;mcr = cortex_a8_mcr,
-
 	/* prepare JTAG information for the new target */
 	cortex_a8-&gt;jtag_info.tap = tap;
 	cortex_a8-&gt;jtag_info.scann_size = 4;
@@ -1645,8 +1551,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 //	armv7a-&gt;armv4_5_mmu.enable_mmu_caches = armv7a_enable_mmu_caches;
 	armv7a-&gt;armv4_5_mmu.has_tiny_pages = 1;
 	armv7a-&gt;armv4_5_mmu.mmu_enabled = 0;
-	armv7a-&gt;read_cp15 = cortex_a8_read_cp15;
-	armv7a-&gt;write_cp15 = cortex_a8_write_cp15;
 
 
 //	arm7_9-&gt;handle_target_request = cortex_a8_handle_target_request;

commit 563d937c3c6a7080998baa2313d66ae184b820ac
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Tue Dec 1 00:49:04 2009 -0800

    ARM: implement mrc()/mcr() as DPM ops
    
    Instead of having separate ARM11 and Cortex-A8 implementations of
    this code, have one shared implementation which just builds on the
    existing &quot;run instruction via R0&quot; support.
    
    This enables followup patches to remove that now-unused code from
    those two drivers.  (Patches to move the &quot;mrc&quot; and &quot;mcr&quot; code into
    &quot;struct arm&quot; are due too ... MIPS and other cores do not support
    those ARM-specific concepts.)
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index b8107d7..127f87b 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -34,6 +34,61 @@
  * implementation differences between cores like ARM1136 and Cortex-A8.
  */
 
+/*
+ * Coprocessor support
+ */
+
+/* Read coprocessor */
+static int dpm_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+		uint32_t *value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm-&gt;dpm;
+	int retval;
+
+	retval = dpm-&gt;prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG(&quot;MRC p%d, %d, r0, c%d, c%d, %d&quot;, cpnum, op1, CRn, CRm, op2);
+
+	/* read coprocessor register into R0; return via DCC */
+	retval = dpm-&gt;instr_read_data_r0(dpm,
+			ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm-&gt;finish(dpm);
+	return retval;
+}
+
+static int dpm_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+		uint32_t value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm-&gt;dpm;
+	int retval;
+
+	retval = dpm-&gt;prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG(&quot;MCR p%d, %d, r0, c%d, c%d, %d&quot;, cpnum, op1, CRn, CRm, op2);
+
+	/* read DCC into r0; then write coprocessor register from R0 */
+	retval = dpm-&gt;instr_write_data_r0(dpm,
+			ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm-&gt;finish(dpm);
+	return retval;
+}
+
+/*
+ * Register access utilities
+ */
+
 /* Toggles between recorded core mode (USR, SVC, etc) and a temporary one.
  * Routines *must* restore the original mode before returning!!
  */
@@ -510,6 +565,10 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 		return ERROR_FAIL;
 
 	*register_get_last_cache_p(&amp;target-&gt;reg_cache) = cache;
+
+	arm-&gt;mrc = dpm_mrc;
+	arm-&gt;mcr = dpm_mcr;
+
 	return ERROR_OK;
 }
 

commit 177bbd8891ae737ea7f8c0791a6236f72cedee40
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Tue Dec 1 00:48:53 2009 -0800

    target: &quot;mcr&quot; and &quot;mrc&quot; are ARM-specific
    
    Switch &quot;mrc&quot; and &quot;mcr&quot; commands to be toplevel ARM operations,
    as they should initially have been.
    
    Correct the usage message for both commands:  it matches ARM
    documentation (as one wants!) instead of reordering them to
    match the funky mrc() and mcr() method usage (sigh).
    
    For Cortex-A8: restore a line that got accidentally dropped,
    so the secure monitor mode shadow registers will show again.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/arm11.c b/src/target/arm11.c
index daba3b8..30dbedb 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -1219,6 +1219,13 @@ static int arm11_remove_watchpoint(struct target *target,
 	return ERROR_FAIL;
 }
 
+static int arm11_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm, uint32_t *value);
+static int arm11_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2, uint32_t CRn,
+		uint32_t CRm, uint32_t value);
+
 static int arm11_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct arm11_common *arm11;
@@ -1238,6 +1245,9 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 
 	armv4_5_init_arch_info(target, &amp;arm11-&gt;arm);
 
+	arm11-&gt;arm.mrc = arm11_mrc;
+	arm11-&gt;arm.mcr = arm11_mcr;
+
 	arm11-&gt;target = target;
 
 	arm11-&gt;jtag_info.tap = target-&gt;tap;
@@ -1679,7 +1689,4 @@ struct target_type arm11_target = {
 	.target_create =	arm11_target_create,
 	.init_target =		arm11_init_target,
 	.examine =		arm11_examine,
-
-	.mrc =			arm11_mrc,
-	.mcr =			arm11_mcr,
 };
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index bae2561..d900d8a 100644
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -378,11 +378,24 @@ static int arm720t_init_target(struct command_context *cmd_ctx, struct target *t
 	return arm7tdmi_init_target(cmd_ctx, target);
 }
 
+/* FIXME remove forward decls */
+static int arm720t_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value);
+static int arm720t_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value);
+
 static int arm720t_init_arch_info(struct target *target,
 		struct arm720t_common *arm720t, struct jtag_tap *tap)
 {
 	struct arm7_9_common *arm7_9 = &amp;arm720t-&gt;arm7_9_common;
 
+	arm7_9-&gt;armv4_5_common.mrc = arm720t_mrc;
+	arm7_9-&gt;armv4_5_common.mcr = arm720t_mcr;
+
 	arm7tdmi_init_arch_info(target, arm7_9, tap);
 
 	arm720t-&gt;common_magic = ARM720T_COMMON_MAGIC;
@@ -556,6 +569,4 @@ struct target_type arm720t_target =
 	.target_create = arm720t_target_create,
 	.init_target = arm720t_init_target,
 	.examine = arm7_9_examine,
-	.mrc = arm720t_mrc,
-	.mcr = arm720t_mcr,
 };
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index e6c2eed..17e7a55 100644
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -624,10 +624,23 @@ int arm920t_soft_reset_halt(struct target *target)
 	return ERROR_OK;
 }
 
+/* FIXME remove forward decls */
+static int arm920t_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value);
+static int arm920t_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value);
+
 int arm920t_init_arch_info(struct target *target, struct arm920t_common *arm920t, struct jtag_tap *tap)
 {
 	struct arm7_9_common *arm7_9 = &amp;arm920t-&gt;arm7_9_common;
 
+	arm7_9-&gt;armv4_5_common.mrc = arm920t_mrc;
+	arm7_9-&gt;armv4_5_common.mcr = arm920t_mcr;
+
 	/* initialize arm7/arm9 specific info (including armv4_5) */
 	arm9tdmi_init_arch_info(target, arm7_9, tap);
 
@@ -1452,6 +1465,4 @@ struct target_type arm920t_target =
 	.target_create = arm920t_target_create,
 	.init_target = arm9tdmi_init_target,
 	.examine = arm7_9_examine,
-	.mrc = arm920t_mrc,
-	.mcr = arm920t_mcr,
 };
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index 408ede9..ca420aa 100644
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -673,6 +673,9 @@ int arm926ejs_init_arch_info(struct target *target, struct arm926ejs_common *arm
 {
 	struct arm7_9_common *arm7_9 = &amp;arm926ejs-&gt;arm7_9_common;
 
+	arm7_9-&gt;armv4_5_common.mrc = arm926ejs_mrc;
+	arm7_9-&gt;armv4_5_common.mcr = arm926ejs_mcr;
+
 	/* initialize arm7/arm9 specific info (including armv4_5) */
 	arm9tdmi_init_arch_info(target, arm7_9, tap);
 
@@ -822,6 +825,4 @@ struct target_type arm926ejs_target =
 
 	.read_phys_memory = arm926ejs_read_phys_memory,
 	.write_phys_memory = arm926ejs_write_phys_memory,
-	.mrc = arm926ejs_mrc,
-	.mcr = arm926ejs_mcr,
 };
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index b5e33ff..d047b1b 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -790,6 +790,137 @@ usage:
 	return retval;
 }
 
+static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	struct command_context *context;
+	struct target *target;
+	struct arm *arm;
+	int retval;
+
+	context = Jim_GetAssocData(interp, &quot;context&quot;);
+	if (context == NULL) {
+		LOG_ERROR(&quot;%s: no command context&quot;, __func__);
+		return JIM_ERR;
+	}
+	target = get_current_target(context);
+	if (target == NULL) {
+		LOG_ERROR(&quot;%s: no current target&quot;, __func__);
+		return JIM_ERR;
+	}
+	if (!target_was_examined(target)) {
+		LOG_ERROR(&quot;%s: not yet examined&quot;, target_name(target));
+		return JIM_ERR;
+	}
+	arm = target_to_arm(target);
+	if (!is_arm(arm)) {
+		LOG_ERROR(&quot;%s: not an ARM&quot;, target_name(target));
+		return JIM_ERR;
+	}
+
+	if ((argc &lt; 6) || (argc &gt; 7)) {
+		/* FIXME use the command name to verify # params... */
+		LOG_ERROR(&quot;%s: wrong number of arguments&quot;, __func__);
+		return JIM_ERR;
+	}
+
+	int cpnum;
+	uint32_t op1;
+	uint32_t op2;
+	uint32_t CRn;
+	uint32_t CRm;
+	uint32_t value;
+	long l;
+
+	/* NOTE:  parameter sequence matches ARM instruction set usage:
+	 *	MCR	pNUM, op1, rX, CRn, CRm, op2	; write CP from rX
+	 *	MRC	pNUM, op1, rX, CRn, CRm, op2	; read CP into rX
+	 * The &quot;rX&quot; is necessarily omitted; it uses Tcl mechanisms.
+	 */
+	retval = Jim_GetLong(interp, argv[1], &amp;l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l &amp; ~0xf) {
+		LOG_ERROR(&quot;%s: %s %d out of range&quot;, __func__,
+				&quot;coprocessor&quot;, (int) l);
+		return JIM_ERR;
+	}
+	cpnum = l;
+
+	retval = Jim_GetLong(interp, argv[2], &amp;l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l &amp; ~0x7) {
+		LOG_ERROR(&quot;%s: %s %d out of range&quot;, __func__,
+				&quot;op1&quot;, (int) l);
+		return JIM_ERR;
+	}
+	op1 = l;
+
+	retval = Jim_GetLong(interp, argv[3], &amp;l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l &amp; ~0xf) {
+		LOG_ERROR(&quot;%s: %s %d out of range&quot;, __func__,
+				&quot;CRn&quot;, (int) l);
+		return JIM_ERR;
+	}
+	CRn = l;
+
+	retval = Jim_GetLong(interp, argv[4], &amp;l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l &amp; ~0xf) {
+		LOG_ERROR(&quot;%s: %s %d out of range&quot;, __func__,
+				&quot;CRm&quot;, (int) l);
+		return JIM_ERR;
+	}
+	CRm = l;
+
+	retval = Jim_GetLong(interp, argv[5], &amp;l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l &amp; ~0x7) {
+		LOG_ERROR(&quot;%s: %s %d out of range&quot;, __func__,
+				&quot;op2&quot;, (int) l);
+		return JIM_ERR;
+	}
+	op2 = l;
+
+	value = 0;
+
+	/* FIXME don't assume &quot;mrc&quot; vs &quot;mcr&quot; from the number of params;
+	 * that could easily be a typo!  Check both...
+	 *
+	 * FIXME change the call syntax here ... simplest to just pass
+	 * the MRC() or MCR() instruction to be executed.  That will also
+	 * let us support the &quot;mrc2&quot; and &quot;mcr2&quot; opcodes (toggling one bit)
+	 * if that's ever needed.
+	 */
+	if (argc == 7) {
+		retval = Jim_GetLong(interp, argv[6], &amp;l);
+		if (retval != JIM_OK) {
+			return retval;
+		}
+		value = l;
+
+		/* NOTE: parameters reordered! */
+		// ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2)
+		retval = arm-&gt;mcr(target, cpnum, op1, op2, CRn, CRm, value);
+		if (retval != ERROR_OK)
+			return JIM_ERR;
+	} else {
+		/* NOTE: parameters reordered! */
+		// ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2)
+		retval = arm-&gt;mrc(target, cpnum, op1, op2, CRn, CRm, &amp;value);
+		if (retval != ERROR_OK)
+			return JIM_ERR;
+
+		Jim_SetResult(interp, Jim_NewIntObj(interp, value));
+	}
+
+	return JIM_OK;
+}
+
 static const struct command_registration arm_exec_command_handlers[] = {
 	{
 		.name = &quot;reg&quot;,
@@ -811,6 +942,20 @@ static const struct command_registration arm_exec_command_handlers[] = {
 		.usage = &quot;&lt;address&gt; [&lt;count&gt; ['thumb']]&quot;,
 		.help = &quot;disassemble instructions &quot;,
 	},
+	{
+		.name = &quot;mcr&quot;,
+		.mode = COMMAND_EXEC,
+		.jim_handler = &amp;jim_mcrmrc,
+		.help = &quot;write coprocessor register&quot;,
+		.usage = &quot;cpnum op1 CRn op2 CRm value&quot;,
+	},
+	{
+		.name = &quot;mrc&quot;,
+		.jim_handler = &amp;jim_mcrmrc,
+		.help = &quot;read coprocessor register&quot;,
+		.usage = &quot;cpnum op1 CRn op2 CRm&quot;,
+	},
+
 	COMMAND_REGISTRATION_DONE
 };
 const struct command_registration arm_command_handlers[] = {
@@ -1252,6 +1397,24 @@ static int arm_full_context(struct target *target)
 	return retval;
 }
 
+static int arm_default_mrc(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t *value)
+{
+	LOG_ERROR(&quot;%s doesn't implement MRC&quot;, target_type_name(target));
+	return ERROR_FAIL;
+}
+
+static int arm_default_mcr(struct target *target, int cpnum,
+		uint32_t op1, uint32_t op2,
+		uint32_t CRn, uint32_t CRm,
+		uint32_t value)
+{
+	LOG_ERROR(&quot;%s doesn't implement MCR&quot;, target_type_name(target));
+	return ERROR_FAIL;
+}
+
 int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 {
 	target-&gt;arch_info = armv4_5;
@@ -1267,5 +1430,10 @@ int armv4_5_init_arch_info(struct target *target, struct arm *armv4_5)
 	if (!armv4_5-&gt;full_context &amp;&amp; armv4_5-&gt;read_core_reg)
 		armv4_5-&gt;full_context = arm_full_context;
 
+	if (!armv4_5-&gt;mrc)
+		armv4_5-&gt;mrc = arm_default_mrc;
+	if (!armv4_5-&gt;mcr)
+		armv4_5-&gt;mcr = arm_default_mcr;
+
 	return ERROR_OK;
 }
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
index 822d143..7229a6c 100644
--- a/src/target/armv4_5.h
+++ b/src/target/armv4_5.h
@@ -112,11 +112,26 @@ struct arm
 	/** Handle for the Embedded Trace Module, if one is present. */
 	struct etm_context *etm;
 
+	/* FIXME all these methods should take &quot;struct arm *&quot; not target */
+
 	int (*full_context)(struct target *target);
 	int (*read_core_reg)(struct target *target, struct reg *reg,
 			int num, enum armv4_5_mode mode);
 	int (*write_core_reg)(struct target *target, struct reg *reg,
 			int num, enum armv4_5_mode mode, uint32_t value);
+
+	/** Read coprocessor register.  */
+	int (*mrc)(struct target *target, int cpnum,
+			uint32_t op1, uint32_t op2,
+			uint32_t CRn, uint32_t CRm,
+			uint32_t *value);
+
+	/* Write coprocessor register.  */
+	int (*mcr)(struct target *target, int cpnum,
+			uint32_t op1, uint32_t op2,
+			uint32_t CRn, uint32_t CRm,
+			uint32_t value);
+
 	void *arch_info;
 };
 
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 652efa9..9ce6b2b 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -936,7 +936,7 @@ static void cortex_a8_post_debug_entry(struct target *target)
 	int retval;
 
 	/* MRC p15,0,&lt;Rt&gt;,c1,c0,0 ; Read CP15 System Control Register */
-	retval = target-&gt;type-&gt;mrc(target, 15,
+	retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
 			0, 0,	/* op1, op2 */
 			1, 0,	/* CRn, CRm */
 			&amp;cortex_a8-&gt;cp15_control_reg);
@@ -947,7 +947,7 @@ static void cortex_a8_post_debug_entry(struct target *target)
 		uint32_t cache_type_reg;
 
 		/* MRC p15,0,&lt;Rt&gt;,c0,c0,1 ; Read CP15 Cache Type Register */
-		retval = target-&gt;type-&gt;mrc(target, 15,
+		retval = armv7a-&gt;armv4_5_common.mrc(target, 15,
 				0, 1,	/* op1, op2 */
 				0, 0,	/* CRn, CRm */
 				&amp;cache_type_reg);
@@ -1535,6 +1535,7 @@ static int cortex_a8_examine_first(struct target *target)
 	LOG_DEBUG(&quot;ttypr = 0x%08&quot; PRIx32, ttypr);
 	LOG_DEBUG(&quot;didr = 0x%08&quot; PRIx32, didr);
 
+	armv7a-&gt;armv4_5_common.core_type = ARM_MODE_MON;
 	cortex_a8_dpm_setup(cortex_a8, didr);
 
 	/* Setup Breakpoint Register Pairs */
@@ -1611,6 +1612,9 @@ static int cortex_a8_init_arch_info(struct target *target,
 	cortex_a8-&gt;common_magic = CORTEX_A8_COMMON_MAGIC;
 	armv4_5-&gt;arch_info = armv7a;
 
+	armv4_5-&gt;mrc = cortex_a8_mrc,
+	armv4_5-&gt;mcr = cortex_a8_mcr,
+
 	/* prepare JTAG information for the new target */
 	cortex_a8-&gt;jtag_info.tap = tap;
 	cortex_a8-&gt;jtag_info.scann_size = 4;
@@ -1626,7 +1630,6 @@ static int cortex_a8_init_arch_info(struct target *target,
 
 	cortex_a8-&gt;fast_reg_read = 0;
 
-
 	/* register arch-specific functions */
 	armv7a-&gt;examine_debug_reason = NULL;
 
@@ -1752,6 +1755,4 @@ struct target_type cortexa8_target = {
 	.target_create = cortex_a8_target_create,
 	.init_target = cortex_a8_init_target,
 	.examine = cortex_a8_examine,
-	.mrc = cortex_a8_mrc,
-	.mcr = cortex_a8_mcr,
 };
diff --git a/src/target/target.c b/src/target/target.c
index 31734b8..88931b5 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -44,8 +44,6 @@
 #include &quot;jtag.h&quot;
 
 
-static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv);
-
 static int target_array2mem(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv);
 static int target_mem2array(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv);
 
@@ -665,84 +663,6 @@ static void target_reset_examined(struct target *target)
 	target-&gt;examined = false;
 }
 
-
-
-static int default_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	LOG_ERROR(&quot;Not implemented: %s&quot;, __func__);
-	return ERROR_FAIL;
-}
-
-static int default_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	LOG_ERROR(&quot;Not implemented: %s&quot;, __func__);
-	return ERROR_FAIL;
-}
-
-static int arm_cp_check(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm)
-{
-	/* basic check */
-	if (!target_was_examined(target))
-	{
-		LOG_ERROR(&quot;Target not examined yet&quot;);
-		return ERROR_FAIL;
-	}
-
-	if ((cpnum &lt;0) || (cpnum &gt; 15))
-	{
-		LOG_ERROR(&quot;Illegal co-processor %d&quot;, cpnum);
-		return ERROR_FAIL;
-	}
-
-	if (op1 &gt; 7)
-	{
-		LOG_ERROR(&quot;Illegal op1&quot;);
-		return ERROR_FAIL;
-	}
-
-	if (op2 &gt; 7)
-	{
-		LOG_ERROR(&quot;Illegal op2&quot;);
-		return ERROR_FAIL;
-	}
-
-	if (CRn &gt; 15)
-	{
-		LOG_ERROR(&quot;Illegal CRn&quot;);
-		return ERROR_FAIL;
-	}
-
-	if (CRm &gt; 15)
-	{
-		LOG_ERROR(&quot;Illegal CRm&quot;);
-		return ERROR_FAIL;
-	}
-
-	return ERROR_OK;
-}
-
-int target_mrc(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value)
-{
-	int retval;
-
-	retval = arm_cp_check(target, cpnum, op1, op2, CRn, CRm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return target-&gt;type-&gt;mrc(target, cpnum, op1, op2, CRn, CRm, value);
-}
-
-int target_mcr(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value)
-{
-	int retval;
-
-	retval = arm_cp_check(target, cpnum, op1, op2, CRn, CRm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	return target-&gt;type-&gt;mcr(target, cpnum, op1, op2, CRn, CRm, value);
-}
-
 static int
 err_read_phys_memory(struct target *target, uint32_t address,
 		uint32_t size, uint32_t count, uint8_t *buffer)
@@ -781,39 +701,6 @@ int target_init(struct command_context *cmd_ctx)
 			return retval;
 		}
 
-		/**
-		 * @todo MCR/MRC are ARM-specific; don't require them in
-		 * all targets, or for ARMs without coprocessors.
-		 */
-		if (target-&gt;type-&gt;mcr == NULL)
-		{
-			target-&gt;type-&gt;mcr = default_mcr;
-		} else
-		{
-			const struct command_registration mcr_cmd = {
-				.name = &quot;mcr&quot;,
-				.mode = COMMAND_EXEC,
-				.jim_handler = &amp;jim_mcrmrc,
-				.help = &quot;write coprocessor&quot;,
-				.usage = &quot;&lt;cpnum&gt; &lt;op1&gt; &lt;op2&gt; &lt;CRn&gt; &lt;CRm&gt; &lt;value&gt;&quot;,
-			};
-			register_command(cmd_ctx, NULL, &amp;mcr_cmd);
-		}
-
-		if (target-&gt;type-&gt;mrc == NULL)
-		{
-			target-&gt;type-&gt;mrc = default_mrc;
-		} else
-		{
-			const struct command_registration mrc_cmd = {
-				.name = &quot;mrc&quot;,
-				.jim_handler = &amp;jim_mcrmrc,
-				.help = &quot;read coprocessor&quot;,
-				.usage = &quot;&lt;cpnum&gt; &lt;op1&gt; &lt;op2&gt; &lt;CRn&gt; &lt;CRm&gt;&quot;,
-			};
-			register_command(cmd_ctx, NULL, &amp;mrc_cmd);
-		}
-
 
 		/**
 		 * @todo get rid of those *memory_imp() methods, now that all
@@ -4883,92 +4770,6 @@ COMMAND_HANDLER(handle_fast_load_command)
 	return retval;
 }
 
-static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
-{
-	struct command_context *context;
-	struct target *target;
-	int retval;
-
-	context = Jim_GetAssocData(interp, &quot;context&quot;);
-	if (context == NULL) {
-		LOG_ERROR(&quot;array2mem: no command context&quot;);
-		return JIM_ERR;
-	}
-	target = get_current_target(context);
-	if (target == NULL) {
-		LOG_ERROR(&quot;array2mem: no current target&quot;);
-		return JIM_ERR;
-	}
-
-	if ((argc &lt; 6) || (argc &gt; 7))
-	{
-		return JIM_ERR;
-	}
-
-	int cpnum;
-	uint32_t op1;
-	uint32_t op2;
-	uint32_t CRn;
-	uint32_t CRm;
-	uint32_t value;
-
-	int e;
-	long l;
-	e = Jim_GetLong(interp, argv[1], &amp;l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	cpnum = l;
-
-	e = Jim_GetLong(interp, argv[2], &amp;l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	op1 = l;
-
-	e = Jim_GetLong(interp, argv[3], &amp;l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	CRn = l;
-
-	e = Jim_GetLong(interp, argv[4], &amp;l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	CRm = l;
-
-	e = Jim_GetLong(interp, argv[5], &amp;l);
-	if (e != JIM_OK) {
-		return e;
-	}
-	op2 = l;
-
-	value = 0;
-
-	if (argc == 7)
-	{
-		e = Jim_GetLong(interp, argv[6], &amp;l);
-		if (e != JIM_OK) {
-			return e;
-		}
-		value = l;
-
-		retval = target_mcr(target, cpnum, op1, op2, CRn, CRm, value);
-		if (retval != ERROR_OK)
-			return JIM_ERR;
-	} else
-	{
-		retval = target_mrc(target, cpnum, op1, op2, CRn, CRm, &amp;value);
-		if (retval != ERROR_OK)
-			return JIM_ERR;
-
-		Jim_SetResult(interp, Jim_NewIntObj(interp, value));
-	}
-
-	return JIM_OK;
-}
-
 static const struct command_registration target_command_handlers[] = {
 	{
 		.name = &quot;targets&quot;,
diff --git a/src/target/target_type.h b/src/target/target_type.h
index d141608..15cf66b 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -213,11 +213,6 @@ struct target_type
 
 	int (*mmu)(struct target *target, int *enabled);
 
-	/* Read coprocessor - arm specific. Default implementation returns error. */
-	int (*mrc)(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t *value);
-
-	/* Write coprocessor. Default implementation returns error.  */
-	int (*mcr)(struct target *target, int cpnum, uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm, uint32_t value);
 };
 
 #endif // TARGET_TYPE_H

commit 209a0197f0c79442a2314199170a957c36c0ddb6
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Tue Dec 1 00:48:40 2009 -0800

    ARMv7-A: stop using CP15 ops
    
    The ARMv7-A code uses read_cp15() to access fault registers.
    Instead, use DPM operations directly, passing in the relevant
    MRC instructions.
    
    This eliminates per-operation overhead (though it'll be hard
    to observe, this is uncommon) and helps eliminate read_cp15().
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index 3d94329..e23208f 100644
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -38,17 +38,48 @@ static void armv7a_show_fault_registers(struct target *target)
 {
 	uint32_t dfsr, ifsr, dfar, ifar;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	armv7a-&gt;read_cp15(target, 0, 0, 5, 0, &amp;dfsr);
-	armv7a-&gt;read_cp15(target, 0, 1, 5, 0, &amp;ifsr);
-	armv7a-&gt;read_cp15(target, 0, 0, 6, 0, &amp;dfar);
-	armv7a-&gt;read_cp15(target, 0, 2, 6, 0, &amp;ifar);
+	struct arm_dpm *dpm = armv7a-&gt;armv4_5_common.dpm;
+	int retval;
+
+	retval = dpm-&gt;prepare(dpm);
+	if (retval != ERROR_OK)
+		return;
+
+	/* ARMV4_5_MRC(cpnum, op1, r0, CRn, CRm, op2) */
+
+	/* c5/c0 - {data, instruction} fault status registers */
+	retval = dpm-&gt;instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 5, 0, 0),
+			&amp;dfsr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm-&gt;instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 5, 0, 1),
+			&amp;ifsr);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* c6/c0 - {data, instruction} fault address registers */
+	retval = dpm-&gt;instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 6, 0, 0),
+			&amp;dfar);
+	if (retval != ERROR_OK)
+		goto done;
+
+	retval = dpm-&gt;instr_read_data_r0(dpm,
+			ARMV4_5_MRC(15, 0, 0, 6, 0, 2),
+			&amp;ifar);
+	if (retval != ERROR_OK)
+		goto done;
 
 	LOG_USER(&quot;Data fault registers        DFSR: %8.8&quot; PRIx32
 			&quot;, DFAR: %8.8&quot; PRIx32, dfsr, dfar);
 	LOG_USER(&quot;Instruction fault registers IFSR: %8.8&quot; PRIx32
 			&quot;, IFAR: %8.8&quot; PRIx32, ifsr, ifar);
 
+done:
+	/* (void) */ dpm-&gt;finish(dpm);
 }
 
 int armv7a_arch_state(struct target *target)

commit fb984a477d526b742855bfe0ab07f4dced3b9323
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Tue Dec 1 00:48:40 2009 -0800

    Cortex-A8: stop using CP15 ops
    
    There were two chunks of Cortex-A8 code which called the
    ARMv7-A CP15 operations; get rid of them, helping prepare
    to remove those methods completely:
    
     - post_debug_entry() can use the mrc() method to read
       its two registers.
    
     - write_memory() can use dpm-&gt;instr_write_data_r0() to
       flush the ICache and DCache ... doing it this way is
       actually faster since it reduces per-write overhead.
    
    Note that the mrc() method parameters are re-ordered with
    respect to the ARM instruction documentation, so that part
    can be confusing.
    
    Cleaned up the layout and comments in those areas a bit.
    
    Signed-off-by: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;

diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 8402081..652efa9 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -933,19 +933,26 @@ static void cortex_a8_post_debug_entry(struct target *target)
 {
 	struct cortex_a8_common *cortex_a8 = target_to_cortex_a8(target);
 	struct armv7a_common *armv7a = &amp;cortex_a8-&gt;armv7a_common;
+	int retval;
 
-//	cortex_a8_read_cp(target, &amp;cp15_control_register, 15, 0, 1, 0, 0);
-	/* examine cp15 control reg */
-	armv7a-&gt;read_cp15(target, 0, 0, 1, 0, &amp;cortex_a8-&gt;cp15_control_reg);
-	jtag_execute_queue();
+	/* MRC p15,0,&lt;Rt&gt;,c1,c0,0 ; Read CP15 System Control Register */
+	retval = target-&gt;type-&gt;mrc(target, 15,
+			0, 0,	/* op1, op2 */
+			1, 0,	/* CRn, CRm */
+			&amp;cortex_a8-&gt;cp15_control_reg);
 	LOG_DEBUG(&quot;cp15_control_reg: %8.8&quot; PRIx32, cortex_a8-&gt;cp15_control_reg);
 
 	if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.ctype == -1)
 	{
 		uint32_t cache_type_reg;
-		/* identify caches */
-		armv7a-&gt;read_cp15(target, 0, 1, 0, 0, &amp;cache_type_reg);
-		jtag_execute_queue();
+
+		/* MRC p15,0,&lt;Rt&gt;,c0,c0,1 ; Read CP15 Cache Type Register */
+		retval = target-&gt;type-&gt;mrc(target, 15,
+				0, 1,	/* op1, op2 */
+				0, 0,	/* CRn, CRm */
+				&amp;cache_type_reg);
+		LOG_DEBUG(&quot;cp15 cache type: %8.8x&quot;, (unsigned) cache_type_reg);
+
 		/* FIXME the armv4_4 cache info DOES NOT APPLY to Cortex-A8 */
 		armv4_5_identify_cache(cache_type_reg,
 				&amp;armv7a-&gt;armv4_5_mmu.armv4_5_cache);
@@ -1350,25 +1357,55 @@ static int cortex_a8_write_memory(struct target *target, uint32_t address,
 		}
 	}
 
+	/* REVISIT this op is generic ARMv7-A/R stuff */
 	if (retval == ERROR_OK &amp;&amp; target-&gt;state == TARGET_HALTED)
 	{
-		/* The Cache handling will NOT work with MMU active, the wrong addresses will be invalidated */
+		struct arm_dpm *dpm = armv7a-&gt;armv4_5_common.dpm;
+
+		retval = dpm-&gt;prepare(dpm);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* The Cache handling will NOT work with MMU active, the
+		 * wrong addresses will be invalidated!
+		 *
+		 * For both ICache and DCache, walk all cache lines in the
+		 * address range. Cortex-A8 has fixed 64 byte line length.
+		 */
+
 		/* invalidate I-Cache */
 		if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled)
 		{
-			/* Invalidate ICache single entry with MVA, repeat this for all cache
-			   lines in the address range, Cortex-A8 has fixed 64 byte line length */
-			/* Invalidate Cache single entry with MVA to PoU */
-			for (uint32_t cacheline=address; cacheline&lt;address+size*count; cacheline+=64)
-				armv7a-&gt;write_cp15(target, 0, 1, 7, 5, cacheline); /* I-Cache to PoU */
+			/* ICIMVAU - Invalidate Cache single entry
+			 * with MVA to PoU
+			 *	MCR p15, 0, r0, c7, c5, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline &lt; address + size * count;
+					cacheline += 64) {
+				retval = dpm-&gt;instr_write_data_r0(dpm,
+					ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+					cacheline);
+			}
 		}
+
 		/* invalidate D-Cache */
 		if (armv7a-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		{
-			/* Invalidate Cache single entry with MVA to PoC */
-			for (uint32_t cacheline=address; cacheline&lt;address+size*count; cacheline+=64)
-				armv7a-&gt;write_cp15(target, 0, 1, 7, 6, cacheline); /* U/D cache to PoC */
+			/* DCIMVAC - Invalidate data Cache line
+			 * with MVA to PoC
+			 *	MCR p15, 0, r0, c7, c6, 1
+			 */
+			for (uint32_t cacheline = address;
+					cacheline &lt; address + size * count;
+					cacheline += 64) {
+				retval = dpm-&gt;instr_write_data_r0(dpm,
+					ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
+					cacheline);
+			}
 		}
+
+		/* (void) */ dpm-&gt;finish(dpm);
 	}
 
 	return retval;

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c       |   68 ----------------
 src/target/arm720t.c     |   15 +++-
 src/target/arm920t.c     |   15 +++-
 src/target/arm926ejs.c   |    5 +-
 src/target/arm_dpm.c     |   59 ++++++++++++++
 src/target/armv4_5.c     |  168 ++++++++++++++++++++++++++++++++++++++
 src/target/armv4_5.h     |   15 ++++
 src/target/armv7a.c      |   39 ++++++++-
 src/target/armv7a.h      |    7 --
 src/target/cortex_a8.c   |  168 +++++++++++++--------------------------
 src/target/target.c      |  199 ----------------------------------------------
 src/target/target_type.h |    5 -
 12 files changed, 361 insertions(+), 402 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001894.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-730-g51e9b25
</A></li>
	<LI>Next message: <A HREF="001896.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-738-g445da54
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1895">[ date ]</a>
              <a href="thread.html#1895">[ thread ]</a>
              <a href="subject.html#1895">[ subject ]</a>
              <a href="author.html#1895">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
