<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-864-g87a0119
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-864-g87a0119&In-Reply-To=%3CE1NGjM5-0002os-SN%40sfp-scmshell-1.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001924.html">
   <LINK REL="Next"  HREF="001926.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-864-g87a0119</H1>
    <B>Zach Welch</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-864-g87a0119&In-Reply-To=%3CE1NGjM5-0002os-SN%40sfp-scmshell-1.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-864-g87a0119">zwelch at users.sourceforge.net
       </A><BR>
    <I>Sat Dec  5 02:22:36 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001924.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-856-g32f961d
</A></li>
        <LI>Next message: <A HREF="001926.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-867-gf67f6fe
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1925">[ date ]</a>
              <a href="thread.html#1925">[ thread ]</a>
              <a href="subject.html#1925">[ subject ]</a>
              <a href="author.html#1925">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  87a0119fa24fe0fc904dcf2e6569cc0b9cb580ed (commit)
       via  f3e6f584f12dbde9ba9806ed4a412db0524d438c (commit)
       via  ae6374e25dae7b02636e440549b87040d03cc5aa (commit)
       via  d9dc604a4d790f557a7ba502babdabffa27eaa17 (commit)
       via  1527272fb21beee7839335ea5587e879163d2ed1 (commit)
       via  5fdee60fd4d38e59c7b5f7aca5ad50b90e7d61ee (commit)
       via  c90702eaa7e7c4e7dd6d1efea61387a62748cfad (commit)
       via  04ee41de52065f648752c13652b3428260f1ac2a (commit)
      from  32f961daba1301ac22ed53c9bc0822effff168cf (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 87a0119fa24fe0fc904dcf2e6569cc0b9cb580ed
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 04:42:38 2009 -0800

    reorder build order of src directory
    
    Descend into the library modules in order, from bottom-to-top.

diff --git a/src/Makefile.am b/src/Makefile.am
index e6462c1..ea753bb 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,4 +1,12 @@
-SUBDIRS = helper jtag xsvf svf target server flash pld
+SUBDIRS = \
+	helper \
+	jtag \
+	target \
+	flash \
+	svf \
+	xsvf \
+	pld \
+	server
 
 lib_LTLIBRARIES = libopenocd.la
 bin_PROGRAMS = openocd

commit f3e6f584f12dbde9ba9806ed4a412db0524d438c
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 16:40:19 2009 -0800

    remove flash.h from tree
    
    Remove the now vestigial &lt;flash/flash.h&gt; header from the tree,
    replacing a few references with &lt;flash/nor/core.h&gt;

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index b5cd526..ba44adb 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -22,7 +22,6 @@ libflash_la_LIBADD = \
 noinst_HEADERS = \
 	arm_nandio.h \
 	common.h \
-	flash.h \
 	mflash.h \
 	nand.h
 
diff --git a/src/flash/flash.h b/src/flash/flash.h
deleted file mode 100644
index 056e1ae..0000000
--- a/src/flash/flash.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe                                 *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifndef FLASH_H
-#define FLASH_H
-
-// this file will be removed
-
-#include &lt;flash/nor/core.h&gt;
-
-#endif /* FLASH_H */
diff --git a/src/flash/nor/at91sam7.h b/src/flash/nor/at91sam7.h
index 8077879..eb35433 100644
--- a/src/flash/nor/at91sam7.h
+++ b/src/flash/nor/at91sam7.h
@@ -23,8 +23,6 @@
 #ifndef AT91SAM7_H
 #define AT91SAM7_H
 
-#include &lt;flash/flash.h&gt;
-
 struct at91sam7_flash_bank
 {
 	/* chip id register */
diff --git a/src/flash/nor/avrf.h b/src/flash/nor/avrf.h
index 0f270e6..1a69e86 100644
--- a/src/flash/nor/avrf.h
+++ b/src/flash/nor/avrf.h
@@ -20,8 +20,6 @@
 #ifndef AVRF_H
 #define AVRF_H
 
-#include &lt;helper/types.h&gt;
-
 struct avrf_type
 {
 	char name[15];
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
index 565a2b6..fa717dc 100644
--- a/src/flash/nor/cfi.h
+++ b/src/flash/nor/cfi.h
@@ -20,8 +20,6 @@
 #ifndef CFI_H
 #define CFI_H
 
-#include &lt;flash/flash.h&gt;
-
 #define CFI_STATUS_POLL_MASK_DQ5_DQ6_DQ7 0xE0 /* DQ5..DQ7 */
 #define CFI_STATUS_POLL_MASK_DQ6_DQ7     0xC0 /* DQ6..DQ7 */
 
diff --git a/src/flash/nor/lpc2000.h b/src/flash/nor/lpc2000.h
index 30be304..f1f90e7 100644
--- a/src/flash/nor/lpc2000.h
+++ b/src/flash/nor/lpc2000.h
@@ -23,8 +23,6 @@
 #ifndef LPC2000_H
 #define LPC2000_H
 
-#include &lt;flash/flash.h&gt;
-
 typedef enum
 {
 	lpc2000_v1,
diff --git a/src/flash/nor/lpc288x.h b/src/flash/nor/lpc288x.h
index 06f634a..cd5fb73 100644
--- a/src/flash/nor/lpc288x.h
+++ b/src/flash/nor/lpc288x.h
@@ -21,8 +21,6 @@
 #ifndef lpc288x_H
 #define lpc288x_H
 
-#include &lt;flash/flash.h&gt;
-
 struct lpc288x_flash_bank
 {
 	uint32_t working_area;
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
index f98b108..7e73afa 100644
--- a/src/flash/nor/non_cfi.c
+++ b/src/flash/nor/non_cfi.c
@@ -23,8 +23,9 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &quot;non_cfi.h&quot;
+#include &quot;imp.h&quot;
 #include &quot;cfi.h&quot;
+#include &quot;non_cfi.h&quot;
 
 
 #define KB 1024
diff --git a/src/flash/nor/non_cfi.h b/src/flash/nor/non_cfi.h
index cc6004e..0219333 100644
--- a/src/flash/nor/non_cfi.h
+++ b/src/flash/nor/non_cfi.h
@@ -20,8 +20,6 @@
 #ifndef NON_CFI_H
 #define NON_CFI_H
 
-#include &lt;flash/flash.h&gt;
-
 struct non_cfi
 {
 	uint16_t mfr;
diff --git a/src/flash/nor/pic32mx.h b/src/flash/nor/pic32mx.h
index b33e831..b3bdad2 100644
--- a/src/flash/nor/pic32mx.h
+++ b/src/flash/nor/pic32mx.h
@@ -26,8 +26,6 @@
 #ifndef PIC32MX_H
 #define PIC32MX_H
 
-#include &lt;flash/flash.h&gt;
-
 struct pic32mx_flash_bank
 {
 	struct working_area *write_algorithm;
diff --git a/src/flash/nor/stellaris.h b/src/flash/nor/stellaris.h
index 85b709c..a5f04e4 100644
--- a/src/flash/nor/stellaris.h
+++ b/src/flash/nor/stellaris.h
@@ -20,8 +20,6 @@
 #ifndef STELLARIS_FLASH_H
 #define STELLARIS_FLASH_H
 
-#include &lt;flash/flash.h&gt;
-
 struct stellaris_flash_bank
 {
 	/* chip id register */
diff --git a/src/flash/nor/stm32x.h b/src/flash/nor/stm32x.h
index b6e00ed..fcf895c 100644
--- a/src/flash/nor/stm32x.h
+++ b/src/flash/nor/stm32x.h
@@ -23,8 +23,6 @@
 #ifndef STM32X_H
 #define STM32X_H
 
-#include &lt;flash/flash.h&gt;
-
 struct stm32x_options
 {
 	uint16_t RDP;
diff --git a/src/flash/nor/str7x.h b/src/flash/nor/str7x.h
index 4daafb7..77dfee6 100644
--- a/src/flash/nor/str7x.h
+++ b/src/flash/nor/str7x.h
@@ -23,8 +23,6 @@
 #ifndef STR7X_H
 #define STR7X_H
 
-#include &lt;flash/flash.h&gt;
-
 struct str7x_flash_bank
 {
 	uint32_t *sector_bits;
diff --git a/src/flash/nor/str9x.h b/src/flash/nor/str9x.h
index 29adecf..ba5386f 100644
--- a/src/flash/nor/str9x.h
+++ b/src/flash/nor/str9x.h
@@ -23,8 +23,6 @@
 #ifndef STR9X_H
 #define STR9X_H
 
-#include &lt;flash/flash.h&gt;
-
 struct str9x_flash_bank
 {
 	uint32_t *sector_bits;
diff --git a/src/flash/nor/str9xpec.h b/src/flash/nor/str9xpec.h
index cb2ac78..6eecd8a 100644
--- a/src/flash/nor/str9xpec.h
+++ b/src/flash/nor/str9xpec.h
@@ -23,8 +23,6 @@
 #ifndef STR9XPEC_H
 #define STR9XPEC_H
 
-#include &lt;flash/flash.h&gt;
-#include &lt;jtag/jtag.h&gt;
 
 struct str9xpec_flash_controller
 {
diff --git a/src/flash/nor/tms470.h b/src/flash/nor/tms470.h
index b2fea1b..ecbfad8 100644
--- a/src/flash/nor/tms470.h
+++ b/src/flash/nor/tms470.h
@@ -20,8 +20,6 @@
 #ifndef TMS470_DOT_H
 #define TMS470_DOT_H
 
-#include &lt;flash/flash.h&gt;
-
 struct tms470_flash_bank
 {
 	unsigned ordinal;
diff --git a/src/openocd.c b/src/openocd.c
index b6dc010..e500ba6 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -34,7 +34,7 @@
 #include &lt;helper/configuration.h&gt;
 #include &lt;xsvf/xsvf.h&gt;
 #include &lt;svf/svf.h&gt;
-#include &lt;flash/flash.h&gt;
+#include &lt;flash/nor/core.h&gt;
 #include &lt;flash/nand.h&gt;
 #include &lt;pld/pld.h&gt;
 #include &lt;flash/mflash.h&gt;
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 21cd0fe..f9cca99 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -31,7 +31,7 @@
 #include &lt;target/target_request.h&gt;
 #include &lt;target/register.h&gt;
 #include &quot;server.h&quot;
-#include &lt;flash/flash.h&gt;
+#include &lt;flash/nor/core.h&gt;
 #include &quot;gdb_server.h&quot;
 #include &lt;target/image.h&gt;
 #include &lt;jtag/jtag.h&gt;

commit ae6374e25dae7b02636e440549b87040d03cc5aa
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 16:07:47 2009 -0800

    split flash.h into into flash/nor/*.h
    
    Move the bulk of the flash.h file into flash/nor/core.h, leaving an
    empty husk that will be removed in the next patch.
    
    The NOR driver structure is an implementation detail, so move it into
    its own private header file &lt;flash/nor/driver.h&gt; along with helper
    declaration for finding them by name.

diff --git a/src/flash/flash.h b/src/flash/flash.h
index 8cd50f6..056e1ae 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -26,326 +26,8 @@
 #ifndef FLASH_H
 #define FLASH_H
 
-#include &lt;flash/common.h&gt;
+// this file will be removed
 
-struct image;
-
-#define FLASH_MAX_ERROR_STR	(128)
-
-/**
- * Describes the geometry and status of a single flash sector
- * within a flash bank.  A single bank typically consists of multiple
- * sectors, each of which can be erased and protected independently.
- */
-struct flash_sector
-{
-	/// Bus offset from start of the flash chip (in bytes).
-	uint32_t offset;
-	/// Number of bytes in this flash sector.
-	uint32_t size;
-	/**
-	 * Indication of erasure status: 0 = not erased, 1 = erased,
-	 * other = unknown.  Set by @c flash_driver_s::erase_check.
-	 */
-	int is_erased;
-	/**
-	 * Indication of protection status: 0 = unprotected/unlocked,
-	 * 1 = protected/locked, other = unknown.  Set by
-	 * @c flash_driver_s::protect_check.
-	 */
-	int is_protected;
-};
-
-struct flash_bank;
-
-#define __FLASH_BANK_COMMAND(name) \
-		COMMAND_HELPER(name, struct flash_bank *bank)
-
-/**
- * @brief Provides the implementation-independent structure that defines
- * all of the callbacks required by OpenOCD flash drivers.
- *
- * Driver authors must implement the routines defined here, providing an
- * instance with the fields filled out.  After that, the instance must
- * be registered in flash.c, so it can be used by the driver lookup system.
- *
- * Specifically, the user can issue the command: @par
- * @code
- * flash bank DRIVERNAME ...parameters...
- * @endcode
- *
- * OpenOCD will search for the driver with a @c flash_driver_s::name
- * that matches @c DRIVERNAME.
- *
- * The flash subsystem calls some of the other drivers routines a using
- * corresponding static &lt;code&gt;flash_driver_&lt;i&gt;callback&lt;/i&gt;()&lt;/code&gt;
- * routine in flash.c.
- */
-struct flash_driver
-{
-	/**
-	 * Gives a human-readable name of this flash driver,
-	 * This field is used to select and initialize the driver.
-	 */
-	char *name;
-
-	/**
-	 * An array of driver-specific commands to register.  When called
-	 * during the &quot;flash bank&quot; command, the driver can register addition
-	 * commands to support new flash chip functions.
-	 */
-	const struct command_registration *commands;
-
-	/**
-	 * Finish the &quot;flash bank&quot; command for @a bank.  The
-	 * @a bank parameter will have been filled in by the core flash
-	 * layer when this routine is called, and the driver can store
-	 * additional information in its struct flash_bank::driver_priv field.
-	 *
-	 * The CMD_ARGV are: @par
-	 * @code
-	 * CMD_ARGV[0] = bank
-	 * CMD_ARGV[1] = drivername {name above}
-	 * CMD_ARGV[2] = baseaddress
-	 * CMD_ARGV[3] = lengthbytes
-	 * CMD_ARGV[4] = chip_width_in bytes
-	 * CMD_ARGV[5] = bus_width_bytes
-	 * CMD_ARGV[6] = driver-specific parameters
-	 * @endcode
-	 *
-	 * For example, CMD_ARGV[4] = 16 bit flash, CMD_ARGV[5] = 32bit bus.
-	 *
-	 * If extra arguments are provided (@a CMD_ARGC &gt; 6), they will
-	 * start in @a CMD_ARGV[6].  These can be used to implement
-	 * driver-specific extensions.
-	 *
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	__FLASH_BANK_COMMAND((*flash_bank_command));
-
-	/**
-	 * Bank/sector erase routine (target-specific).  When
-	 * called, the flash driver should erase the specified sectors
-	 * using whatever means are at its disposal.
-	 *
-	 * @param bank The bank of flash to be erased.
-	 * @param first The number of the first sector to erase, typically 0.
-	 * @param last The number of the last sector to erase, typically N-1.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*erase)(struct flash_bank *bank, int first, int last);
-
-	/**
-	 * Bank/sector protection routine (target-specific).
-	 * When called, the driver should disable 'flash write' bits (or
-	 * enable 'erase protection' bits) for the given @a bank and @a
-	 * sectors.
-	 *
-	 * @param bank The bank to protect or unprotect.
-	 * @param set If non-zero, enable protection; if 0, disable it.
-	 * @param first The first sector to (un)protect, typicaly 0.
-	 * @param last The last sector to (un)project, typically N-1.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*protect)(struct flash_bank *bank, int set, int first, int last);
-
-	/**
-	 * Program data into the flash.  Note CPU address will be
-	 * &quot;bank-&gt;base + offset&quot;, while the physical address is
-	 * dependent upon current target MMU mappings.
-	 *
-	 * @param bank The bank to program
-	 * @param buffer The data bytes to write.
-	 * @param offset The offset into the chip to program.
-	 * @param count The number of bytes to write.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*write)(struct flash_bank *bank,
-			uint8_t *buffer, uint32_t offset, uint32_t count);
-
-	/**
-	 * Probe to determine what kind of flash is present.
-	 * This is invoked by the &quot;probe&quot; script command.
-	 *
-	 * @param bank The bank to probe
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*probe)(struct flash_bank *bank);
-
-	/**
-	 * Check the erasure status of a flash bank.
-	 * When called, the driver routine must perform the required
-	 * checks and then set the @c flash_sector_s::is_erased field
-	 * for each of the flash banks's sectors.
-	 *
-	 * @param bank The bank to check
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*erase_check)(struct flash_bank *bank);
-
-	/**
-	 * Determine if the specific bank is &quot;protected&quot; or not.
-	 * When called, the driver routine must must perform the
-	 * required protection check(s) and then set the @c
-	 * flash_sector_s::is_protected field for each of the flash
-	 * bank's sectors.
-	 *
-	 * @param bank - the bank to check
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*protect_check)(struct flash_bank *bank);
-
-	/**
-	 * Display human-readable information about the flash
-	 * bank into the given buffer.  Drivers must be careful to avoid
-	 * overflowing the buffer.
-	 *
-	 * @param bank - the bank to get info about
-	 * @param char - where to put the text for the human to read
-	 * @param buf_size - the size of the human buffer.
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*info)(struct flash_bank *bank, char *buf, int buf_size);
-
-	/**
-	 * A more gentle flavor of filash_driver_s::probe, performing
-	 * setup with less noise.  Generally, driver routines should test
-	 * to seee if the bank has already been probed; if it has, the
-	 * driver probably should not perform its probe a second time.
-	 *
-	 * This callback is often called from the inside of other
-	 * routines (e.g. GDB flash downloads) to autoprobe the flash as
-	 * it is programing the flash.
-	 *
-	 * @param bank - the bank to probe
-	 * @returns ERROR_OK if successful; otherwise, an error code.
-	 */
-	int (*auto_probe)(struct flash_bank *bank);
-};
-
-#define FLASH_BANK_COMMAND_HANDLER(name) static __FLASH_BANK_COMMAND(name)
-
-/**
- * Provides details of a flash bank, available either on-chip or through
- * a major interface.
- *
- * This structure will be passed as a parameter to the callbacks in the
- * flash_driver_s structure, some of which may modify the contents of
- * this structure of the area of flash that it defines.  Driver writers
- * may use the @c driver_priv member to store additional data on a
- * per-bank basis, if required.
- */
-struct flash_bank
-{
-	char *name;
-
-	struct target *target; /**&lt; Target to which this bank belongs. */
-
-	struct flash_driver *driver; /**&lt; Driver for this bank. */
-	void *driver_priv; /**&lt; Private driver storage pointer */
-
-	int bank_number; /**&lt; The 'bank' (or chip number) of this instance. */
-	uint32_t base; /**&lt; The base address of this bank */
-	uint32_t size; /**&lt; The size of this chip bank, in bytes */
-
-	int chip_width; /**&lt; Width of the chip in bytes (1,2,4 bytes) */
-	int bus_width; /**&lt; Maximum bus width, in bytes (1,2,4 bytes) */
-
-	/**
-	 * The number of sectors on this chip.  This value will
-	 * be set intially to 0, and the flash driver must set this to
-	 * some non-zero value during &quot;probe()&quot; or &quot;auto_probe()&quot;.
-	 */
-	int num_sectors;
-	/// Array of sectors, allocated and initilized by the flash driver
-	struct flash_sector *sectors;
-
-	struct flash_bank *next; /**&lt; The next flash bank on this chip */
-};
-
-/// Registers the 'flash' subsystem commands
-int flash_register_commands(struct command_context *cmd_ctx);
-/// Initializes the 'flash' subsystem drivers
-int flash_init_drivers(struct command_context *cmd_ctx);
-
-/**
- * Erases @a length bytes in the @a target flash, starting at @a addr.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int flash_erase_address_range(struct target *target,
-		uint32_t addr, uint32_t length);
-/**
- * Writes @a image into the @a target flash.  The @a written parameter
- * will contain the
- * @param target The target with the flash to be programmed.
- * @param image The image that will be programmed to flash.
- * @param written On return, contains the number of bytes written.
- * @param erase If non-zero, indicates the flash driver should first
- * erase the corresponding banks or sectors before programming.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int flash_write(struct target *target,
-		struct image *image, uint32_t *written, int erase);
-/**
- * Forces targets to re-examine their erase/protection state.
- * This routine must be called when the system may modify the status.
- */
-void flash_set_dirty(void);
-/// @returns The number of flash banks currently defined.
-int flash_get_bank_count(void);
-/**
- * Provides default erased-bank check handling. Checks to see if
- * the flash driver knows they are erased; if things look uncertain,
- * this routine will call default_flash_mem_blank_check() to confirm.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int default_flash_blank_check(struct flash_bank *bank);
-/**
- * Provides a default blank flash memory check.  Ensures the contents
- * of the given bank have truly been erased.
- * @param bank The flash bank.
- * @returns ERROR_OK if successful; otherwise, an error code.
- */
-int default_flash_mem_blank_check(struct flash_bank *bank);
-
-/**
- * Returns the flash bank specified by @a name, which matches the
- * driver name and a suffix (option) specify the driver-specific
- * bank number. The suffix consists of the '.' and the driver-specific
- * bank number: when two str9x banks are defined, then 'str9x.1' refers
- * to the second.
- */
-struct flash_bank *get_flash_bank_by_name(const char *name);
-/**
- * Returns a flash bank by the specified flash_bank_s bank_number, @a num.
- * @param num The flash bank number.
- * @returns A struct flash_bank for flash bank @a num, or NULL
- */
-struct flash_bank *get_flash_bank_by_num(int num);
-/**
- * Retreives @a bank from a command argument, reporting errors parsing
- * the bank identifier or retreiving the specified bank.  The bank
- * may be identified by its bank number or by @c name.instance, where
- * @a instance is driver-specific.
- * @param name_index The index to the string in args containing the
- * bank identifier.
- * @param bank On output, contians a pointer to the bank or NULL.
- * @returns ERROR_OK on success, or an error indicating the problem.
- */
-COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
-		struct flash_bank **bank);
-/**
- * Returns the flash bank like get_flash_bank_by_num(), without probing.
- * @param num The flash bank number.
- * @returns A struct flash_bank for flash bank @a num, or NULL.
- */
-struct flash_bank *get_flash_bank_by_num_noprobe(int num);
-/**
- * Returns the flash bank located at a specified address.
- * @param target The target, presumed to contain one or more banks.
- * @param addr An address that is within the range of the bank.
- * @returns The struct flash_bank located at @a addr, or NULL.
- */
-struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr);
+#include &lt;flash/nor/core.h&gt;
 
 #endif /* FLASH_H */
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index bafe424..f185081 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -34,6 +34,7 @@ noinst_HEADERS = \
 	avrf.h \
 	core.h \
 	cfi.h \
+	driver.h \
 	imp.h \
 	lpc2000.h \
 	lpc288x.h \
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
index 0c6a804..c1e26cd 100644
--- a/src/flash/nor/core.h
+++ b/src/flash/nor/core.h
@@ -1,4 +1,7 @@
 /***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;       *
+ *   Copyright (C) 2008 by Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;           *
  *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -19,13 +22,157 @@
 #ifndef FLASH_NOR_CORE_H
 #define FLASH_NOR_CORE_H
 
-#include &lt;flash/flash.h&gt;
+#include &lt;flash/common.h&gt;
 
+struct image;
+
+#define FLASH_MAX_ERROR_STR	(128)
+
+/**
+ * Describes the geometry and status of a single flash sector
+ * within a flash bank.  A single bank typically consists of multiple
+ * sectors, each of which can be erased and protected independently.
+ */
+struct flash_sector
+{
+	/// Bus offset from start of the flash chip (in bytes).
+	uint32_t offset;
+	/// Number of bytes in this flash sector.
+	uint32_t size;
+	/**
+	 * Indication of erasure status: 0 = not erased, 1 = erased,
+	 * other = unknown.  Set by @c flash_driver_s::erase_check.
+	 */
+	int is_erased;
+	/**
+	 * Indication of protection status: 0 = unprotected/unlocked,
+	 * 1 = protected/locked, other = unknown.  Set by
+	 * @c flash_driver_s::protect_check.
+	 */
+	int is_protected;
+};
+
+/**
+ * Provides details of a flash bank, available either on-chip or through
+ * a major interface.
+ *
+ * This structure will be passed as a parameter to the callbacks in the
+ * flash_driver_s structure, some of which may modify the contents of
+ * this structure of the area of flash that it defines.  Driver writers
+ * may use the @c driver_priv member to store additional data on a
+ * per-bank basis, if required.
+ */
+struct flash_bank
+{
+	char *name;
+
+	struct target *target; /**&lt; Target to which this bank belongs. */
+
+	struct flash_driver *driver; /**&lt; Driver for this bank. */
+	void *driver_priv; /**&lt; Private driver storage pointer */
+
+	int bank_number; /**&lt; The 'bank' (or chip number) of this instance. */
+	uint32_t base; /**&lt; The base address of this bank */
+	uint32_t size; /**&lt; The size of this chip bank, in bytes */
+
+	int chip_width; /**&lt; Width of the chip in bytes (1,2,4 bytes) */
+	int bus_width; /**&lt; Maximum bus width, in bytes (1,2,4 bytes) */
+
+	/**
+	 * The number of sectors on this chip.  This value will
+	 * be set intially to 0, and the flash driver must set this to
+	 * some non-zero value during &quot;probe()&quot; or &quot;auto_probe()&quot;.
+	 */
+	int num_sectors;
+	/// Array of sectors, allocated and initilized by the flash driver
+	struct flash_sector *sectors;
+
+	struct flash_bank *next; /**&lt; The next flash bank on this chip */
+};
+
+/// Registers the 'flash' subsystem commands
+int flash_register_commands(struct command_context *cmd_ctx);
+/// Initializes the 'flash' subsystem drivers
+int flash_init_drivers(struct command_context *cmd_ctx);
+
+/**
+ * Erases @a length bytes in the @a target flash, starting at @a addr.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int flash_erase_address_range(struct target *target,
+		uint32_t addr, uint32_t length);
+/**
+ * Writes @a image into the @a target flash.  The @a written parameter
+ * will contain the
+ * @param target The target with the flash to be programmed.
+ * @param image The image that will be programmed to flash.
+ * @param written On return, contains the number of bytes written.
+ * @param erase If non-zero, indicates the flash driver should first
+ * erase the corresponding banks or sectors before programming.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int flash_write(struct target *target,
+		struct image *image, uint32_t *written, int erase);
+/**
+ * Forces targets to re-examine their erase/protection state.
+ * This routine must be called when the system may modify the status.
+ */
+void flash_set_dirty(void);
+/// @returns The number of flash banks currently defined.
+int flash_get_bank_count(void);
+/**
+ * Provides default erased-bank check handling. Checks to see if
+ * the flash driver knows they are erased; if things look uncertain,
+ * this routine will call default_flash_mem_blank_check() to confirm.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int default_flash_blank_check(struct flash_bank *bank);
+/**
+ * Provides a default blank flash memory check.  Ensures the contents
+ * of the given bank have truly been erased.
+ * @param bank The flash bank.
+ * @returns ERROR_OK if successful; otherwise, an error code.
+ */
+int default_flash_mem_blank_check(struct flash_bank *bank);
+
+/**
+ * Returns the flash bank specified by @a name, which matches the
+ * driver name and a suffix (option) specify the driver-specific
+ * bank number. The suffix consists of the '.' and the driver-specific
+ * bank number: when two str9x banks are defined, then 'str9x.1' refers
+ * to the second.
+ */
+struct flash_bank *get_flash_bank_by_name(const char *name);
+/**
+ * Returns a flash bank by the specified flash_bank_s bank_number, @a num.
+ * @param num The flash bank number.
+ * @returns A struct flash_bank for flash bank @a num, or NULL
+ */
+struct flash_bank *get_flash_bank_by_num(int num);
+/**
+ * Retreives @a bank from a command argument, reporting errors parsing
+ * the bank identifier or retreiving the specified bank.  The bank
+ * may be identified by its bank number or by @c name.instance, where
+ * @a instance is driver-specific.
+ * @param name_index The index to the string in args containing the
+ * bank identifier.
+ * @param bank On output, contians a pointer to the bank or NULL.
+ * @returns ERROR_OK on success, or an error indicating the problem.
+ */
+COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
+		struct flash_bank **bank);
+/**
+ * Returns the flash bank like get_flash_bank_by_num(), without probing.
+ * @param num The flash bank number.
+ * @returns A struct flash_bank for flash bank @a num, or NULL.
+ */
+struct flash_bank *get_flash_bank_by_num_noprobe(int num);
 /**
- * Find a NOR flash driver by its name.
- * @param name The name of the requested driver.
- * @returns The flash_driver called @c name, or NULL if not found.
+ * Returns the flash bank located at a specified address.
+ * @param target The target, presumed to contain one or more banks.
+ * @param addr An address that is within the range of the bank.
+ * @returns The struct flash_bank located at @a addr, or NULL.
  */
-struct flash_driver *flash_driver_find_by_name(const char *name);
+struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr);
 
 #endif // FLASH_NOR_CORE_H
diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
new file mode 100644
index 0000000..de71a39
--- /dev/null
+++ b/src/flash/nor/driver.h
@@ -0,0 +1,201 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;       *
+ *   Copyright (C) 2008 by Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;           *
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NOR_DRIVER_H
+#define FLASH_NOR_DRIVER_H
+
+struct flash_bank;
+
+#define __FLASH_BANK_COMMAND(name) \
+		COMMAND_HELPER(name, struct flash_bank *bank)
+
+/**
+ * @brief Provides the implementation-independent structure that defines
+ * all of the callbacks required by OpenOCD flash drivers.
+ *
+ * Driver authors must implement the routines defined here, providing an
+ * instance with the fields filled out.  After that, the instance must
+ * be registered in flash.c, so it can be used by the driver lookup system.
+ *
+ * Specifically, the user can issue the command: @par
+ * @code
+ * flash bank DRIVERNAME ...parameters...
+ * @endcode
+ *
+ * OpenOCD will search for the driver with a @c flash_driver_s::name
+ * that matches @c DRIVERNAME.
+ *
+ * The flash subsystem calls some of the other drivers routines a using
+ * corresponding static &lt;code&gt;flash_driver_&lt;i&gt;callback&lt;/i&gt;()&lt;/code&gt;
+ * routine in flash.c.
+ */
+struct flash_driver
+{
+	/**
+	 * Gives a human-readable name of this flash driver,
+	 * This field is used to select and initialize the driver.
+	 */
+	char *name;
+
+	/**
+	 * An array of driver-specific commands to register.  When called
+	 * during the &quot;flash bank&quot; command, the driver can register addition
+	 * commands to support new flash chip functions.
+	 */
+	const struct command_registration *commands;
+
+	/**
+	 * Finish the &quot;flash bank&quot; command for @a bank.  The
+	 * @a bank parameter will have been filled in by the core flash
+	 * layer when this routine is called, and the driver can store
+	 * additional information in its struct flash_bank::driver_priv field.
+	 *
+	 * The CMD_ARGV are: @par
+	 * @code
+	 * CMD_ARGV[0] = bank
+	 * CMD_ARGV[1] = drivername {name above}
+	 * CMD_ARGV[2] = baseaddress
+	 * CMD_ARGV[3] = lengthbytes
+	 * CMD_ARGV[4] = chip_width_in bytes
+	 * CMD_ARGV[5] = bus_width_bytes
+	 * CMD_ARGV[6] = driver-specific parameters
+	 * @endcode
+	 *
+	 * For example, CMD_ARGV[4] = 16 bit flash, CMD_ARGV[5] = 32bit bus.
+	 *
+	 * If extra arguments are provided (@a CMD_ARGC &gt; 6), they will
+	 * start in @a CMD_ARGV[6].  These can be used to implement
+	 * driver-specific extensions.
+	 *
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	__FLASH_BANK_COMMAND((*flash_bank_command));
+
+	/**
+	 * Bank/sector erase routine (target-specific).  When
+	 * called, the flash driver should erase the specified sectors
+	 * using whatever means are at its disposal.
+	 *
+	 * @param bank The bank of flash to be erased.
+	 * @param first The number of the first sector to erase, typically 0.
+	 * @param last The number of the last sector to erase, typically N-1.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*erase)(struct flash_bank *bank, int first, int last);
+
+	/**
+	 * Bank/sector protection routine (target-specific).
+	 * When called, the driver should disable 'flash write' bits (or
+	 * enable 'erase protection' bits) for the given @a bank and @a
+	 * sectors.
+	 *
+	 * @param bank The bank to protect or unprotect.
+	 * @param set If non-zero, enable protection; if 0, disable it.
+	 * @param first The first sector to (un)protect, typicaly 0.
+	 * @param last The last sector to (un)project, typically N-1.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*protect)(struct flash_bank *bank, int set, int first, int last);
+
+	/**
+	 * Program data into the flash.  Note CPU address will be
+	 * &quot;bank-&gt;base + offset&quot;, while the physical address is
+	 * dependent upon current target MMU mappings.
+	 *
+	 * @param bank The bank to program
+	 * @param buffer The data bytes to write.
+	 * @param offset The offset into the chip to program.
+	 * @param count The number of bytes to write.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*write)(struct flash_bank *bank,
+			uint8_t *buffer, uint32_t offset, uint32_t count);
+
+	/**
+	 * Probe to determine what kind of flash is present.
+	 * This is invoked by the &quot;probe&quot; script command.
+	 *
+	 * @param bank The bank to probe
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*probe)(struct flash_bank *bank);
+
+	/**
+	 * Check the erasure status of a flash bank.
+	 * When called, the driver routine must perform the required
+	 * checks and then set the @c flash_sector_s::is_erased field
+	 * for each of the flash banks's sectors.
+	 *
+	 * @param bank The bank to check
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*erase_check)(struct flash_bank *bank);
+
+	/**
+	 * Determine if the specific bank is &quot;protected&quot; or not.
+	 * When called, the driver routine must must perform the
+	 * required protection check(s) and then set the @c
+	 * flash_sector_s::is_protected field for each of the flash
+	 * bank's sectors.
+	 *
+	 * @param bank - the bank to check
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*protect_check)(struct flash_bank *bank);
+
+	/**
+	 * Display human-readable information about the flash
+	 * bank into the given buffer.  Drivers must be careful to avoid
+	 * overflowing the buffer.
+	 *
+	 * @param bank - the bank to get info about
+	 * @param char - where to put the text for the human to read
+	 * @param buf_size - the size of the human buffer.
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*info)(struct flash_bank *bank, char *buf, int buf_size);
+
+	/**
+	 * A more gentle flavor of filash_driver_s::probe, performing
+	 * setup with less noise.  Generally, driver routines should test
+	 * to seee if the bank has already been probed; if it has, the
+	 * driver probably should not perform its probe a second time.
+	 *
+	 * This callback is often called from the inside of other
+	 * routines (e.g. GDB flash downloads) to autoprobe the flash as
+	 * it is programing the flash.
+	 *
+	 * @param bank - the bank to probe
+	 * @returns ERROR_OK if successful; otherwise, an error code.
+	 */
+	int (*auto_probe)(struct flash_bank *bank);
+};
+
+#define FLASH_BANK_COMMAND_HANDLER(name) static __FLASH_BANK_COMMAND(name)
+
+/**
+ * Find a NOR flash driver by its name.
+ * @param name The name of the requested driver.
+ * @returns The flash_driver called @c name, or NULL if not found.
+ */
+struct flash_driver *flash_driver_find_by_name(const char *name);
+
+#endif // FLASH_NOR_DRIVER_H
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
index be72b5c..7f71d83 100644
--- a/src/flash/nor/drivers.c
+++ b/src/flash/nor/drivers.c
@@ -19,7 +19,7 @@
 #ifdef HAVE_CONFIG_H
 #include &quot;config.h&quot;
 #endif
-#include &lt;flash/nor/core.h&gt;
+#include &quot;imp.h&quot;
 
 extern struct flash_driver lpc2000_flash;
 extern struct flash_driver lpc288x_flash;
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 84ef871..4c849fe 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -21,6 +21,7 @@
 
 // this is an internal header
 #include &quot;core.h&quot;
+#include &quot;driver.h&quot;
 // common flash internals
 #include &lt;flash/common.h&gt;
 // almost all drivers will need this file

commit d9dc604a4d790f557a7ba502babdabffa27eaa17
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 14:06:20 2009 -0800

    remove target.h from flash.h
    
    The flash.h header does not require the target.h header file, but
    its implementation source files do.  Move it to flash/nor/imp.h.

diff --git a/src/flash/flash.h b/src/flash/flash.h
index 1e1be85..8cd50f6 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -27,7 +27,6 @@
 #define FLASH_H
 
 #include &lt;flash/common.h&gt;
-#include &lt;target/target.h&gt;
 
 struct image;
 
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
index 6696912..1b9f5c0 100644
--- a/src/flash/nor/aduc702x.c
+++ b/src/flash/nor/aduc702x.c
@@ -23,11 +23,11 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/flash.h&gt;
-#include &lt;target/armv4_5.h&gt;
+#include &quot;imp.h&quot;
 #include &lt;helper/binarybuffer.h&gt;
 #include &lt;helper/time_support.h&gt;
 #include &lt;target/algorithm.h&gt;
+#include &lt;target/armv4_5.h&gt;
 
 
 static int aduc702x_build_sector_list(struct flash_bank *bank);
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
index dd4f347..1194e25 100644
--- a/src/flash/nor/at91sam3.c
+++ b/src/flash/nor/at91sam3.c
@@ -57,13 +57,9 @@
 #endif
 
 
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stddef.h&gt;
-#include &lt;helper/types.h&gt;
-#include &lt;flash/flash.h&gt;
-#include &lt;helper/membuf.h&gt;
+#include &quot;imp.h&quot;
 #include &quot;at91sam3.h&quot;
+#include &lt;helper/membuf.h&gt;
 #include &lt;helper/time_support.h&gt;
 
 #define REG_NAME_WIDTH  (12)
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
index 3201737..97d6b56 100644
--- a/src/flash/nor/at91sam7.c
+++ b/src/flash/nor/at91sam7.c
@@ -49,6 +49,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;at91sam7.h&quot;
 #include &lt;helper/binarybuffer.h&gt;
 
diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
index fbc9277..6c2d17f 100644
--- a/src/flash/nor/avrf.c
+++ b/src/flash/nor/avrf.c
@@ -21,9 +21,9 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;avrf.h&quot;
 #include &lt;target/avrt.h&gt;
-#include &lt;flash/flash.h&gt;
 
 
 /* AVR_JTAG_Instructions */
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index 61b5d4c..c00d65f 100644
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -23,6 +23,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;cfi.h&quot;
 #include &quot;non_cfi.h&quot;
 #include &lt;target/armv4_5.h&gt;
diff --git a/src/flash/nor/ecos.c b/src/flash/nor/ecos.c
index 8f8f746..799015e 100644
--- a/src/flash/nor/ecos.c
+++ b/src/flash/nor/ecos.c
@@ -21,10 +21,10 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/flash.h&gt;
+#include &quot;imp.h&quot;
 #include &lt;target/embeddedice.h&gt;
-#include &lt;target/image.h&gt;
 #include &lt;target/algorithm.h&gt;
+#include &lt;target/image.h&gt;
 
 
 #if 0
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
index c996522..948f305 100644
--- a/src/flash/nor/faux.c
+++ b/src/flash/nor/faux.c
@@ -21,7 +21,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/flash.h&gt;
+#include &quot;imp.h&quot;
 #include &lt;target/image.h&gt;
 #include &quot;hello.h&quot;
 
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index ade7297..84ef871 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -21,6 +21,10 @@
 
 // this is an internal header
 #include &quot;core.h&quot;
+// common flash internals
+#include &lt;flash/common.h&gt;
+// almost all drivers will need this file
+#include &lt;target/target.h&gt;
 
 /**
  * Adds a new NOR bank to the global list of banks.
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 295e3e7..d824c37 100644
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -25,10 +25,11 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;lpc2000.h&quot;
-#include &lt;target/armv7m.h&gt;
 #include &lt;helper/binarybuffer.h&gt;
 #include &lt;target/algorithm.h&gt;
+#include &lt;target/armv7m.h&gt;
 
 
 /* flash programming support for NXP LPC17xx and LPC2xxx devices
diff --git a/src/flash/nor/lpc288x.c b/src/flash/nor/lpc288x.c
index 252a813..5cb36d0 100644
--- a/src/flash/nor/lpc288x.c
+++ b/src/flash/nor/lpc288x.c
@@ -31,6 +31,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;lpc288x.h&quot;
 #include &lt;helper/binarybuffer.h&gt;
 
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index dc466f8..0b42d48 100644
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -23,11 +23,11 @@
 #endif
 
 
-#include &lt;target/image.h&gt;
-#include &lt;flash/flash.h&gt;
+#include &quot;imp.h&quot;
 #include &lt;helper/binarybuffer.h&gt;
-#include &lt;target/armv4_5.h&gt;
 #include &lt;target/algorithm.h&gt;
+#include &lt;target/armv4_5.h&gt;
+#include &lt;target/image.h&gt;
 
 
 /* 1024 bytes */
diff --git a/src/flash/nor/ocl.c b/src/flash/nor/ocl.c
index 6e3ad1c..961537e 100644
--- a/src/flash/nor/ocl.c
+++ b/src/flash/nor/ocl.c
@@ -21,8 +21,8 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;ocl.h&quot;
-#include &lt;flash/flash.h&gt;
 #include &lt;target/embeddedice.h&gt;
 
 
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
index d2289b2..7d98af3 100644
--- a/src/flash/nor/pic32mx.c
+++ b/src/flash/nor/pic32mx.c
@@ -27,6 +27,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;pic32mx.h&quot;
 #include &lt;target/mips32.h&gt;
 
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index f0028ea..3988542 100644
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -28,10 +28,11 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;stellaris.h&quot;
-#include &lt;target/armv7m.h&gt;
 #include &lt;helper/binarybuffer.h&gt;
 #include &lt;target/algorithm.h&gt;
+#include &lt;target/armv7m.h&gt;
 
 
 #define DID0_VER(did0) ((did0 &gt;&gt; 28)&amp;0x07)
diff --git a/src/flash/nor/stm32x.c b/src/flash/nor/stm32x.c
index 3792547..9e761f9 100644
--- a/src/flash/nor/stm32x.c
+++ b/src/flash/nor/stm32x.c
@@ -24,10 +24,11 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;stm32x.h&quot;
-#include &lt;target/armv7m.h&gt;
 #include &lt;helper/binarybuffer.h&gt;
 #include &lt;target/algorithm.h&gt;
+#include &lt;target/armv7m.h&gt;
 
 
 static int stm32x_mass_erase(struct flash_bank *bank);
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
index c5a1c34..4f93ec9 100644
--- a/src/flash/nor/str7x.c
+++ b/src/flash/nor/str7x.c
@@ -24,6 +24,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;str7x.h&quot;
 #include &lt;target/armv4_5.h&gt;
 #include &lt;helper/binarybuffer.h&gt;
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
index 045ab20..36096ff 100644
--- a/src/flash/nor/str9x.c
+++ b/src/flash/nor/str9x.c
@@ -27,6 +27,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;str9x.h&quot;
 #include &lt;target/arm966e.h&gt;
 #include &lt;target/algorithm.h&gt;
diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
index 87a4b06..734f2d1 100644
--- a/src/flash/nor/str9xpec.c
+++ b/src/flash/nor/str9xpec.c
@@ -24,6 +24,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;str9xpec.h&quot;
 #include &lt;target/arm7_9_common.h&gt;
 
diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
index 5965934..7efcbd4 100644
--- a/src/flash/nor/tms470.c
+++ b/src/flash/nor/tms470.c
@@ -22,6 +22,7 @@
 #endif
 
 #include &quot;tms470.h&quot;
+#include &quot;imp.h&quot;
 
 
 /* ----------------------------------------------------------------------
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
index 0414975..05666a5 100644
--- a/src/server/gdb_server.h
+++ b/src/server/gdb_server.h
@@ -27,6 +27,7 @@
 #define GDB_SERVER_H
 
 struct image;
+#include &lt;target/target.h&gt;
 
 #define GDB_BUFFER_SIZE	16384
 

commit 1527272fb21beee7839335ea5587e879163d2ed1
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 13:42:09 2009 -0800

    split NOR and NAND flash headers
    
    Moves common flash errors to &lt;flash/common.h&gt; to decouple these two
    mostly unrelated trees of code.

diff --git a/src/flash/common.h b/src/flash/common.h
index e0dcdb3..4098873 100644
--- a/src/flash/common.h
+++ b/src/flash/common.h
@@ -19,7 +19,7 @@
 #ifndef FLASH_COMMON_H
 #define FLASH_COMMON_H
 
-#include &lt;helper/types.h&gt;
+#include &lt;helper/log.h&gt;
 
 /**
  * Parses the optional '.index' portion of a flash bank identifier.
@@ -36,4 +36,13 @@ unsigned get_flash_name_index(const char *name);
  */
 bool flash_driver_name_matches(const char *name, const char *expected);
 
+#define ERROR_FLASH_BANK_INVALID -900
+#define ERROR_FLASH_SECTOR_INVALID -901
+#define ERROR_FLASH_OPERATION_FAILED -902
+#define ERROR_FLASH_DST_OUT_OF_BANK -903
+#define ERROR_FLASH_DST_BREAKS_ALIGNMENT -904
+#define ERROR_FLASH_BUSY -905
+#define ERROR_FLASH_SECTOR_NOT_ERASED -906
+#define ERROR_FLASH_BANK_NOT_PROBED -907
+
 #endif // FLASH_COMMON_H
diff --git a/src/flash/flash.h b/src/flash/flash.h
index 5e31c48..1e1be85 100644
--- a/src/flash/flash.h
+++ b/src/flash/flash.h
@@ -26,8 +26,8 @@
 #ifndef FLASH_H
 #define FLASH_H
 
+#include &lt;flash/common.h&gt;
 #include &lt;target/target.h&gt;
-#include &lt;helper/log.h&gt;
 
 struct image;
 
@@ -349,13 +349,4 @@ struct flash_bank *get_flash_bank_by_num_noprobe(int num);
  */
 struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr);
 
-#define ERROR_FLASH_BANK_INVALID			(-900)
-#define ERROR_FLASH_SECTOR_INVALID			(-901)
-#define ERROR_FLASH_OPERATION_FAILED		(-902)
-#define ERROR_FLASH_DST_OUT_OF_BANK			(-903)
-#define ERROR_FLASH_DST_BREAKS_ALIGNMENT	(-904)
-#define ERROR_FLASH_BUSY					(-905)
-#define ERROR_FLASH_SECTOR_NOT_ERASED		(-906)
-#define ERROR_FLASH_BANK_NOT_PROBED			(-907)
-
 #endif /* FLASH_H */
diff --git a/src/flash/nand.h b/src/flash/nand.h
index 230cf50..f91deda 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand.h
@@ -25,7 +25,9 @@
 #ifndef NAND_H
 #define NAND_H
 
-#include &lt;flash/flash.h&gt;
+#include &lt;flash/common.h&gt;
+// to be removed later
+#include &lt;target/target.h&gt;
 
 struct nand_device;
 
diff --git a/src/openocd.c b/src/openocd.c
index 0ae0d19..b6dc010 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -34,6 +34,7 @@
 #include &lt;helper/configuration.h&gt;
 #include &lt;xsvf/xsvf.h&gt;
 #include &lt;svf/svf.h&gt;
+#include &lt;flash/flash.h&gt;
 #include &lt;flash/nand.h&gt;
 #include &lt;pld/pld.h&gt;
 #include &lt;flash/mflash.h&gt;

commit 5fdee60fd4d38e59c7b5f7aca5ad50b90e7d61ee
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 04:37:27 2009 -0800

    eliminate src/flash/flash.c
    
    Move remaining NOR flash implemenation into flash/nor/core.c
    Removes flash.c from the build, leaving only its header to split.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index cda59e4..b5cd526 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -9,7 +9,6 @@ METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
 libflash_la_SOURCES = \
 	common.c \
-	flash.c \
 	arm_nandio.c \
 	nand_ecc.c \
 	nand_ecc_kw.c \
diff --git a/src/flash/flash.c b/src/flash/flash.c
deleted file mode 100644
index dfeea5b..0000000
--- a/src/flash/flash.c
+++ /dev/null
@@ -1,216 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2005 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe                                 *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>                                               *
- *                                                                         *
- *   Copyright (C) 2008 by Spencer Oliver                                  *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>                                                  *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;flash.h&quot;
-#include &quot;common.h&quot;
-#include &lt;target/image.h&gt;
-#include &lt;helper/time_support.h&gt;
-
-struct flash_bank *flash_banks;
-
-struct flash_bank *get_flash_bank_by_num_noprobe(int num)
-{
-	struct flash_bank *p;
-	int i = 0;
-
-	for (p = flash_banks; p; p = p-&gt;next)
-	{
-		if (i++ == num)
-		{
-			return p;
-		}
-	}
-	LOG_ERROR(&quot;flash bank %d does not exist&quot;, num);
-	return NULL;
-}
-
-int flash_get_bank_count(void)
-{
-	struct flash_bank *p;
-	int i = 0;
-	for (p = flash_banks; p; p = p-&gt;next)
-	{
-		i++;
-	}
-	return i;
-}
-
-struct flash_bank *get_flash_bank_by_name(const char *name)
-{
-	unsigned requested = get_flash_name_index(name);
-	unsigned found = 0;
-
-	struct flash_bank *bank;
-	for (bank = flash_banks; NULL != bank; bank = bank-&gt;next)
-	{
-		if (strcmp(bank-&gt;name, name) == 0)
-			return bank;
-		if (!flash_driver_name_matches(bank-&gt;driver-&gt;name, name))
-			continue;
-		if (++found &lt; requested)
-			continue;
-		return bank;
-	}
-	return NULL;
-}
-
-struct flash_bank *get_flash_bank_by_num(int num)
-{
-	struct flash_bank *p = get_flash_bank_by_num_noprobe(num);
-	int retval;
-
-	if (p == NULL)
-		return NULL;
-
-	retval = p-&gt;driver-&gt;auto_probe(p);
-
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR(&quot;auto_probe failed %d\n&quot;, retval);
-		return NULL;
-	}
-	return p;
-}
-
-/* lookup flash bank by address */
-struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
-{
-	struct flash_bank *c;
-
-	/* cycle through bank list */
-	for (c = flash_banks; c; c = c-&gt;next)
-	{
-		int retval;
-		retval = c-&gt;driver-&gt;auto_probe(c);
-
-		if (retval != ERROR_OK)
-		{
-			LOG_ERROR(&quot;auto_probe failed %d\n&quot;, retval);
-			return NULL;
-		}
-		/* check whether address belongs to this flash bank */
-		if ((addr &gt;= c-&gt;base) &amp;&amp; (addr &lt;= c-&gt;base + (c-&gt;size - 1)) &amp;&amp; target == c-&gt;target)
-			return c;
-	}
-	LOG_ERROR(&quot;No flash at address 0x%08&quot; PRIx32 &quot;\n&quot;, addr);
-	return NULL;
-}
-
-int default_flash_mem_blank_check(struct flash_bank *bank)
-{
-	struct target *target = bank-&gt;target;
-	const int buffer_size = 1024;
-	int i;
-	uint32_t nBytes;
-	int retval = ERROR_OK;
-
-	if (bank-&gt;target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	uint8_t *buffer = malloc(buffer_size);
-
-	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
-	{
-		uint32_t j;
-		bank-&gt;sectors[i].is_erased = 1;
-
-		for (j = 0; j &lt; bank-&gt;sectors[i].size; j += buffer_size)
-		{
-			uint32_t chunk;
-			chunk = buffer_size;
-			if (chunk &gt; (j - bank-&gt;sectors[i].size))
-			{
-				chunk = (j - bank-&gt;sectors[i].size);
-			}
-
-			retval = target_read_memory(target, bank-&gt;base + bank-&gt;sectors[i].offset + j, 4, chunk/4, buffer);
-			if (retval != ERROR_OK)
-			{
-				goto done;
-			}
-
-			for (nBytes = 0; nBytes &lt; chunk; nBytes++)
-			{
-				if (buffer[nBytes] != 0xFF)
-				{
-					bank-&gt;sectors[i].is_erased = 0;
-					break;
-				}
-			}
-		}
-	}
-
-	done:
-	free(buffer);
-
-	return retval;
-}
-
-int default_flash_blank_check(struct flash_bank *bank)
-{
-	struct target *target = bank-&gt;target;
-	int i;
-	int retval;
-	int fast_check = 0;
-	uint32_t blank;
-
-	if (bank-&gt;target-&gt;state != TARGET_HALTED)
-	{
-		LOG_ERROR(&quot;Target not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
-	{
-		uint32_t address = bank-&gt;base + bank-&gt;sectors[i].offset;
-		uint32_t size = bank-&gt;sectors[i].size;
-
-		if ((retval = target_blank_check_memory(target, address, size, &amp;blank)) != ERROR_OK)
-		{
-			fast_check = 0;
-			break;
-		}
-		if (blank == 0xFF)
-			bank-&gt;sectors[i].is_erased = 1;
-		else
-			bank-&gt;sectors[i].is_erased = 0;
-		fast_check = 1;
-	}
-
-	if (!fast_check)
-	{
-		LOG_USER(&quot;Running slow fallback erase check - add working memory&quot;);
-		return default_flash_mem_blank_check(bank);
-	}
-
-	return ERROR_OK;
-}
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 0fff8ef..c2ea134 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -1,4 +1,7 @@
 /***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;       *
+ *   Copyright (C) 2008 by Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;           *
  *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -20,12 +23,13 @@
 #ifdef HAVE_CONFIG_H
 #include &lt;config.h&gt;
 #endif
-#include &lt;flash/flash.h&gt;
+#include &lt;flash/common.h&gt;
+#include &lt;flash/nor/core.h&gt;
 #include &lt;flash/nor/imp.h&gt;
 #include &lt;target/image.h&gt;
 
-// in flash.c, to be moved here
-extern struct flash_bank *flash_banks;
+
+struct flash_bank *flash_banks;
 
 int flash_driver_erase(struct flash_bank *bank, int first, int last)
 {
@@ -68,7 +72,6 @@ int flash_driver_write(struct flash_bank *bank,
 	return retval;
 }
 
-
 void flash_bank_add(struct flash_bank *bank)
 {
 	/* put flash bank in linked list */
@@ -96,6 +99,186 @@ struct flash_bank *flash_bank_list(void)
 	return flash_banks;
 }
 
+struct flash_bank *get_flash_bank_by_num_noprobe(int num)
+{
+	struct flash_bank *p;
+	int i = 0;
+
+	for (p = flash_banks; p; p = p-&gt;next)
+	{
+		if (i++ == num)
+		{
+			return p;
+		}
+	}
+	LOG_ERROR(&quot;flash bank %d does not exist&quot;, num);
+	return NULL;
+}
+
+int flash_get_bank_count(void)
+{
+	struct flash_bank *p;
+	int i = 0;
+	for (p = flash_banks; p; p = p-&gt;next)
+	{
+		i++;
+	}
+	return i;
+}
+
+struct flash_bank *get_flash_bank_by_name(const char *name)
+{
+	unsigned requested = get_flash_name_index(name);
+	unsigned found = 0;
+
+	struct flash_bank *bank;
+	for (bank = flash_banks; NULL != bank; bank = bank-&gt;next)
+	{
+		if (strcmp(bank-&gt;name, name) == 0)
+			return bank;
+		if (!flash_driver_name_matches(bank-&gt;driver-&gt;name, name))
+			continue;
+		if (++found &lt; requested)
+			continue;
+		return bank;
+	}
+	return NULL;
+}
+
+struct flash_bank *get_flash_bank_by_num(int num)
+{
+	struct flash_bank *p = get_flash_bank_by_num_noprobe(num);
+	int retval;
+
+	if (p == NULL)
+		return NULL;
+
+	retval = p-&gt;driver-&gt;auto_probe(p);
+
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR(&quot;auto_probe failed %d\n&quot;, retval);
+		return NULL;
+	}
+	return p;
+}
+
+/* lookup flash bank by address */
+struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
+{
+	struct flash_bank *c;
+
+	/* cycle through bank list */
+	for (c = flash_banks; c; c = c-&gt;next)
+	{
+		int retval;
+		retval = c-&gt;driver-&gt;auto_probe(c);
+
+		if (retval != ERROR_OK)
+		{
+			LOG_ERROR(&quot;auto_probe failed %d\n&quot;, retval);
+			return NULL;
+		}
+		/* check whether address belongs to this flash bank */
+		if ((addr &gt;= c-&gt;base) &amp;&amp; (addr &lt;= c-&gt;base + (c-&gt;size - 1)) &amp;&amp; target == c-&gt;target)
+			return c;
+	}
+	LOG_ERROR(&quot;No flash at address 0x%08&quot; PRIx32 &quot;\n&quot;, addr);
+	return NULL;
+}
+
+int default_flash_mem_blank_check(struct flash_bank *bank)
+{
+	struct target *target = bank-&gt;target;
+	const int buffer_size = 1024;
+	int i;
+	uint32_t nBytes;
+	int retval = ERROR_OK;
+
+	if (bank-&gt;target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	uint8_t *buffer = malloc(buffer_size);
+
+	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
+	{
+		uint32_t j;
+		bank-&gt;sectors[i].is_erased = 1;
+
+		for (j = 0; j &lt; bank-&gt;sectors[i].size; j += buffer_size)
+		{
+			uint32_t chunk;
+			chunk = buffer_size;
+			if (chunk &gt; (j - bank-&gt;sectors[i].size))
+			{
+				chunk = (j - bank-&gt;sectors[i].size);
+			}
+
+			retval = target_read_memory(target, bank-&gt;base + bank-&gt;sectors[i].offset + j, 4, chunk/4, buffer);
+			if (retval != ERROR_OK)
+			{
+				goto done;
+			}
+
+			for (nBytes = 0; nBytes &lt; chunk; nBytes++)
+			{
+				if (buffer[nBytes] != 0xFF)
+				{
+					bank-&gt;sectors[i].is_erased = 0;
+					break;
+				}
+			}
+		}
+	}
+
+	done:
+	free(buffer);
+
+	return retval;
+}
+
+int default_flash_blank_check(struct flash_bank *bank)
+{
+	struct target *target = bank-&gt;target;
+	int i;
+	int retval;
+	int fast_check = 0;
+	uint32_t blank;
+
+	if (bank-&gt;target-&gt;state != TARGET_HALTED)
+	{
+		LOG_ERROR(&quot;Target not halted&quot;);
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	for (i = 0; i &lt; bank-&gt;num_sectors; i++)
+	{
+		uint32_t address = bank-&gt;base + bank-&gt;sectors[i].offset;
+		uint32_t size = bank-&gt;sectors[i].size;
+
+		if ((retval = target_blank_check_memory(target, address, size, &amp;blank)) != ERROR_OK)
+		{
+			fast_check = 0;
+			break;
+		}
+		if (blank == 0xFF)
+			bank-&gt;sectors[i].is_erased = 1;
+		else
+			bank-&gt;sectors[i].is_erased = 0;
+		fast_check = 1;
+	}
+
+	if (!fast_check)
+	{
+		LOG_USER(&quot;Running slow fallback erase check - add working memory&quot;);
+		return default_flash_mem_blank_check(bank);
+	}
+
+	return ERROR_OK;
+}
 /* erase given flash region, selects proper bank according to target and address */
 static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
 		int (*callback)(struct flash_bank *bank, int first, int last))

commit c90702eaa7e7c4e7dd6d1efea61387a62748cfad
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 04:10:42 2009 -0800

    add flash/nor/drivers.c
    
    Encapsulates access to the flash_drivers array, providing a base
    of operations for future dynamic driver module loading features.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index 2cf56ed..dfeea5b 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -32,49 +32,6 @@
 #include &lt;target/image.h&gt;
 #include &lt;helper/time_support.h&gt;
 
-/* flash drivers
- */
-extern struct flash_driver lpc2000_flash;
-extern struct flash_driver lpc288x_flash;
-extern struct flash_driver lpc2900_flash;
-extern struct flash_driver cfi_flash;
-extern struct flash_driver at91sam3_flash;
-extern struct flash_driver at91sam7_flash;
-extern struct flash_driver str7x_flash;
-extern struct flash_driver str9x_flash;
-extern struct flash_driver aduc702x_flash;
-extern struct flash_driver stellaris_flash;
-extern struct flash_driver str9xpec_flash;
-extern struct flash_driver stm32x_flash;
-extern struct flash_driver tms470_flash;
-extern struct flash_driver ecosflash_flash;
-extern struct flash_driver ocl_flash;
-extern struct flash_driver pic32mx_flash;
-extern struct flash_driver avr_flash;
-extern struct flash_driver faux_flash;
-
-struct flash_driver *flash_drivers[] = {
-	&amp;lpc2000_flash,
-	&amp;lpc288x_flash,
-	&amp;lpc2900_flash,
-	&amp;cfi_flash,
-	&amp;at91sam7_flash,
-	&amp;at91sam3_flash,
-	&amp;str7x_flash,
-	&amp;str9x_flash,
-	&amp;aduc702x_flash,
-	&amp;stellaris_flash,
-	&amp;str9xpec_flash,
-	&amp;stm32x_flash,
-	&amp;tms470_flash,
-	&amp;ecosflash_flash,
-	&amp;ocl_flash,
-	&amp;pic32mx_flash,
-	&amp;avr_flash,
-	&amp;faux_flash,
-	NULL,
-};
-
 struct flash_bank *flash_banks;
 
 struct flash_bank *get_flash_bank_by_num_noprobe(int num)
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 67a5e55..bafe424 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -4,7 +4,8 @@ noinst_LTLIBRARIES = libocdflashnor.la
 libocdflashnor_la_SOURCES = \
 	core.c \
 	tcl.c \
-	$(NOR_DRIVERS)
+	$(NOR_DRIVERS) \
+	drivers.c
 
 NOR_DRIVERS = \
 	aduc702x.c \
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index 2dbf114..0fff8ef 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -25,19 +25,8 @@
 #include &lt;target/image.h&gt;
 
 // in flash.c, to be moved here
-extern struct flash_driver *flash_drivers[];
 extern struct flash_bank *flash_banks;
 
-struct flash_driver *flash_driver_find_by_name(const char *name)
-{
-	for (unsigned i = 0; flash_drivers[i]; i++)
-	{
-		if (strcmp(name, flash_drivers[i]-&gt;name) == 0)
-			return flash_drivers[i];
-	}
-	return NULL;
-}
-
 int flash_driver_erase(struct flash_bank *bank, int first, int last)
 {
 	int retval;
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
new file mode 100644
index 0000000..be72b5c
--- /dev/null
+++ b/src/flash/nor/drivers.c
@@ -0,0 +1,77 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+#include &lt;flash/nor/core.h&gt;
+
+extern struct flash_driver lpc2000_flash;
+extern struct flash_driver lpc288x_flash;
+extern struct flash_driver lpc2900_flash;
+extern struct flash_driver cfi_flash;
+extern struct flash_driver at91sam3_flash;
+extern struct flash_driver at91sam7_flash;
+extern struct flash_driver str7x_flash;
+extern struct flash_driver str9x_flash;
+extern struct flash_driver aduc702x_flash;
+extern struct flash_driver stellaris_flash;
+extern struct flash_driver str9xpec_flash;
+extern struct flash_driver stm32x_flash;
+extern struct flash_driver tms470_flash;
+extern struct flash_driver ecosflash_flash;
+extern struct flash_driver ocl_flash;
+extern struct flash_driver pic32mx_flash;
+extern struct flash_driver avr_flash;
+extern struct flash_driver faux_flash;
+
+/**
+ * The list of built-in flash drivers.
+ * @todo Make this dynamically extendable with loadable modules.
+ */
+struct flash_driver *flash_drivers[] = {
+	&amp;lpc2000_flash,
+	&amp;lpc288x_flash,
+	&amp;lpc2900_flash,
+	&amp;cfi_flash,
+	&amp;at91sam7_flash,
+	&amp;at91sam3_flash,
+	&amp;str7x_flash,
+	&amp;str9x_flash,
+	&amp;aduc702x_flash,
+	&amp;stellaris_flash,
+	&amp;str9xpec_flash,
+	&amp;stm32x_flash,
+	&amp;tms470_flash,
+	&amp;ecosflash_flash,
+	&amp;ocl_flash,
+	&amp;pic32mx_flash,
+	&amp;avr_flash,
+	&amp;faux_flash,
+	NULL,
+};
+
+struct flash_driver *flash_driver_find_by_name(const char *name)
+{
+	for (unsigned i = 0; flash_drivers[i]; i++)
+	{
+		if (strcmp(name, flash_drivers[i]-&gt;name) == 0)
+			return flash_drivers[i];
+	}
+	return NULL;
+}

commit 04ee41de52065f648752c13652b3428260f1ac2a
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 04:01:45 2009 -0800

    move more nor flash implementation details
    
    Splits the exec mode commands out of flash.c into the flash/nor/ files.
    The routines used by these high-level commands are moved into nor/core.c,
    with their internal declarations placed in nor/imp.h.
    
    Fixes distribution of &lt;flash/nor/core.h&gt; header.

diff --git a/src/flash/flash.c b/src/flash/flash.c
index b21838c..2cf56ed 100644
--- a/src/flash/flash.c
+++ b/src/flash/flash.c
@@ -32,8 +32,6 @@
 #include &lt;target/image.h&gt;
 #include &lt;helper/time_support.h&gt;
 
-static int flash_write_unlock(struct target *target, struct image *image, uint32_t *written, int erase, bool unlock);
-
 /* flash drivers
  */
 extern struct flash_driver lpc2000_flash;
@@ -79,47 +77,6 @@ struct flash_driver *flash_drivers[] = {
 
 struct flash_bank *flash_banks;
 
-/* wafer thin wrapper for invoking the flash driver */
-static int flash_driver_write(struct flash_bank *bank, uint8_t *buffer, uint32_t offset, uint32_t count)
-{
-	int retval;
-
-	retval = bank-&gt;driver-&gt;write(bank, buffer, offset, count);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR(&quot;error writing to flash at address 0x%08&quot; PRIx32 &quot; at offset 0x%8.8&quot; PRIx32 &quot; (%d)&quot;,
-			  bank-&gt;base, offset, retval);
-	}
-
-	return retval;
-}
-
-static int flash_driver_erase(struct flash_bank *bank, int first, int last)
-{
-	int retval;
-
-	retval = bank-&gt;driver-&gt;erase(bank, first, last);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR(&quot;failed erasing sectors %d to %d (%d)&quot;, first, last, retval);
-	}
-
-	return retval;
-}
-
-int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
-{
-	int retval;
-
-	retval = bank-&gt;driver-&gt;protect(bank, set, first, last);
-	if (retval != ERROR_OK)
-	{
-		LOG_ERROR(&quot;failed setting protection for areas %d to %d (%d)&quot;, first, last, retval);
-	}
-
-	return retval;
-}
-
 struct flash_bank *get_flash_bank_by_num_noprobe(int num)
 {
 	struct flash_bank *p;
@@ -184,629 +141,6 @@ struct flash_bank *get_flash_bank_by_num(int num)
 	return p;
 }
 
-COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
-		struct flash_bank **bank)
-{
-	const char *name = CMD_ARGV[name_index];
-	*bank = get_flash_bank_by_name(name);
-	if (*bank)
-		return ERROR_OK;
-
-	unsigned bank_num;
-	COMMAND_PARSE_NUMBER(uint, name, bank_num);
-
-	*bank = get_flash_bank_by_num(bank_num);
-	if (!*bank)
-	{
-		command_print(CMD_CTX, &quot;flash bank '%s' not found&quot;, name);
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	return ERROR_OK;
-}
-
-
-COMMAND_HANDLER(handle_flash_info_command)
-{
-	struct flash_bank *p;
-	uint32_t i = 0;
-	int j = 0;
-	int retval;
-
-	if (CMD_ARGC != 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	unsigned bank_nr;
-	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
-
-	for (p = flash_banks; p; p = p-&gt;next, i++)
-	{
-		if (i != bank_nr)
-			continue;
-
-		char buf[1024];
-
-		/* attempt auto probe */
-		if ((retval = p-&gt;driver-&gt;auto_probe(p)) != ERROR_OK)
-			return retval;
-
-		command_print(CMD_CTX,
-			      &quot;#%&quot; PRIi32 &quot; : %s at 0x%8.8&quot; PRIx32 &quot;, size 0x%8.8&quot; PRIx32 &quot;, buswidth %i, chipwidth %i&quot;,
-			      i,
-			      p-&gt;driver-&gt;name,
-			      p-&gt;base,
-			      p-&gt;size,
-			      p-&gt;bus_width,
-			      p-&gt;chip_width);
-		for (j = 0; j &lt; p-&gt;num_sectors; j++)
-		{
-			char *protect_state;
-
-			if (p-&gt;sectors[j].is_protected == 0)
-				protect_state = &quot;not protected&quot;;
-			else if (p-&gt;sectors[j].is_protected == 1)
-				protect_state = &quot;protected&quot;;
-			else
-				protect_state = &quot;protection state unknown&quot;;
-
-			command_print(CMD_CTX,
-				      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
-				      j,
-				      p-&gt;sectors[j].offset,
-				      p-&gt;sectors[j].size,
-				      p-&gt;sectors[j].size &gt;&gt; 10,
-				      protect_state);
-		}
-
-		*buf = '\0'; /* initialize buffer, otherwise it migh contain garbage if driver function fails */
-		retval = p-&gt;driver-&gt;info(p, buf, sizeof(buf));
-		command_print(CMD_CTX, &quot;%s&quot;, buf);
-		if (retval != ERROR_OK)
-			LOG_ERROR(&quot;error retrieving flash info (%d)&quot;, retval);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_probe_command)
-{
-	int retval;
-
-	if (CMD_ARGC != 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	unsigned bank_nr;
-	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num_noprobe(bank_nr);
-	if (p)
-	{
-		if ((retval = p-&gt;driver-&gt;probe(p)) == ERROR_OK)
-		{
-			command_print(CMD_CTX, &quot;flash '%s' found at 0x%8.8&quot; PRIx32, p-&gt;driver-&gt;name, p-&gt;base);
-		}
-		else if (retval == ERROR_FLASH_BANK_INVALID)
-		{
-			command_print(CMD_CTX, &quot;probing failed for flash bank '#%s' at 0x%8.8&quot; PRIx32,
-						  CMD_ARGV[0], p-&gt;base);
-		}
-		else
-		{
-			command_print(CMD_CTX, &quot;unknown error when probing flash bank '#%s' at 0x%8.8&quot; PRIx32,
-						  CMD_ARGV[0], p-&gt;base);
-		}
-	}
-	else
-	{
-		command_print(CMD_CTX, &quot;flash bank '#%s' is out of bounds&quot;, CMD_ARGV[0]);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_erase_check_command)
-{
-	if (CMD_ARGC != 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct flash_bank *p;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	int j;
-	if ((retval = p-&gt;driver-&gt;erase_check(p)) == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;successfully checked erase state&quot;);
-	}
-	else
-	{
-		command_print(CMD_CTX, &quot;unknown error when checking erase state of flash bank #%s at 0x%8.8&quot; PRIx32,
-			CMD_ARGV[0], p-&gt;base);
-	}
-
-	for (j = 0; j &lt; p-&gt;num_sectors; j++)
-	{
-		char *erase_state;
-
-		if (p-&gt;sectors[j].is_erased == 0)
-			erase_state = &quot;not erased&quot;;
-		else if (p-&gt;sectors[j].is_erased == 1)
-			erase_state = &quot;erased&quot;;
-		else
-			erase_state = &quot;erase state unknown&quot;;
-
-		command_print(CMD_CTX,
-			      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
-			      j,
-			      p-&gt;sectors[j].offset,
-			      p-&gt;sectors[j].size,
-			      p-&gt;sectors[j].size &gt;&gt; 10,
-			      erase_state);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_erase_address_command)
-{
-	struct flash_bank *p;
-	int retval;
-	int address;
-	int length;
-
-	struct target *target = get_current_target(CMD_CTX);
-
-	if (CMD_ARGC != 2)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], address);
-	COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], length);
-	if (length &lt;= 0)
-	{
-		command_print(CMD_CTX, &quot;Length must be &gt;0&quot;);
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	p = get_flash_bank_by_addr(target, address);
-	if (p == NULL)
-	{
-		return ERROR_FAIL;
-	}
-
-	/* We can't know if we did a resume + halt, in which case we no longer know the erased state */
-	flash_set_dirty();
-
-	struct duration bench;
-	duration_start(&amp;bench);
-
-	retval = flash_erase_address_range(target, address, length);
-
-	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, &quot;erased address 0x%8.8x (length %i)&quot;
-				&quot; in %fs (%0.3f kb/s)&quot;, address, length,
-				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, length));
-	}
-
-	return retval;
-}
-
-COMMAND_HANDLER(handle_flash_protect_check_command)
-{
-	if (CMD_ARGC != 1)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	struct flash_bank *p;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if ((retval = p-&gt;driver-&gt;protect_check(p)) == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;successfully checked protect state&quot;);
-	}
-	else if (retval == ERROR_FLASH_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, &quot;checking protection state failed (possibly unsupported) by flash #%s at 0x%8.8&quot; PRIx32, CMD_ARGV[0], p-&gt;base);
-	}
-	else
-	{
-		command_print(CMD_CTX, &quot;unknown error when checking protection state of flash bank '#%s' at 0x%8.8&quot; PRIx32, CMD_ARGV[0], p-&gt;base);
-	}
-
-	return ERROR_OK;
-}
-
-static int flash_check_sector_parameters(struct command_context *cmd_ctx,
-		uint32_t first, uint32_t last, uint32_t num_sectors)
-{
-	if (!(first &lt;= last)) {
-		command_print(cmd_ctx, &quot;ERROR: &quot;
-				&quot;first sector must be &lt;= last sector&quot;);
-		return ERROR_FAIL;
-	}
-
-	if (!(last &lt;= (num_sectors - 1))) {
-		command_print(cmd_ctx, &quot;ERROR: last sector must be &lt;= %d&quot;,
-				(int) num_sectors - 1);
-		return ERROR_FAIL;
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_erase_command)
-{
-	if (CMD_ARGC != 3)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	uint32_t bank_nr;
-	uint32_t first;
-	uint32_t last;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
-	if (!p)
-		return ERROR_OK;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
-	if (strcmp(CMD_ARGV[2], &quot;last&quot;) == 0)
-		last = p-&gt;num_sectors - 1;
-	else
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
-
-	int retval;
-	if ((retval = flash_check_sector_parameters(CMD_CTX,
-			first, last, p-&gt;num_sectors)) != ERROR_OK)
-		return retval;
-
-	struct duration bench;
-	duration_start(&amp;bench);
-
-	retval = flash_driver_erase(p, first, last);
-
-	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, &quot;erased sectors %&quot; PRIu32 &quot; &quot;
-				&quot;through %&quot; PRIu32&quot; on flash bank %&quot; PRIu32 &quot; &quot;
-				&quot;in %fs&quot;, first, last, bank_nr, duration_elapsed(&amp;bench));
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_protect_command)
-{
-	if (CMD_ARGC != 4)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	uint32_t bank_nr;
-	uint32_t first;
-	uint32_t last;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
-	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
-	if (!p)
-		return ERROR_OK;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
-	if (strcmp(CMD_ARGV[2], &quot;last&quot;) == 0)
-		last = p-&gt;num_sectors - 1;
-	else
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
-
-	bool set;
-	COMMAND_PARSE_ON_OFF(CMD_ARGV[3], set);
-
-	int retval;
-	if ((retval = flash_check_sector_parameters(CMD_CTX,
-			first, last, p-&gt;num_sectors)) != ERROR_OK)
-		return retval;
-
-	retval = flash_driver_protect(p, set, first, last);
-	if (retval == ERROR_OK) {
-		command_print(CMD_CTX, &quot;%s protection for sectors %i &quot;
-				&quot;through %i on flash bank %i&quot;,
-			(set) ? &quot;set&quot; : &quot;cleared&quot;, (int) first,
-			(int) last, (int) bank_nr);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_flash_write_image_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-
-	struct image image;
-	uint32_t written;
-
-	int retval;
-
-	if (CMD_ARGC &lt; 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	/* flash auto-erase is disabled by default*/
-	int auto_erase = 0;
-	bool auto_unlock = false;
-
-	for (;;)
-	{
-		if (strcmp(CMD_ARGV[0], &quot;erase&quot;) == 0)
-		{
-			auto_erase = 1;
-			CMD_ARGV++;
-			CMD_ARGC--;
-			command_print(CMD_CTX, &quot;auto erase enabled&quot;);
-		} else if (strcmp(CMD_ARGV[0], &quot;unlock&quot;) == 0)
-		{
-			auto_unlock = true;
-			CMD_ARGV++;
-			CMD_ARGC--;
-			command_print(CMD_CTX, &quot;auto unlock enabled&quot;);
-		} else
-		{
-			break;
-		}
-	}
-
-	if (CMD_ARGC &lt; 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (!target)
-	{
-		LOG_ERROR(&quot;no target selected&quot;);
-		return ERROR_FAIL;
-	}
-
-	struct duration bench;
-	duration_start(&amp;bench);
-
-	if (CMD_ARGC &gt;= 2)
-	{
-		image.base_address_set = 1;
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], image.base_address);
-	}
-	else
-	{
-		image.base_address_set = 0;
-		image.base_address = 0x0;
-	}
-
-	image.start_address_set = 0;
-
-	retval = image_open(&amp;image, CMD_ARGV[0], (CMD_ARGC == 3) ? CMD_ARGV[2] : NULL);
-	if (retval != ERROR_OK)
-	{
-		return retval;
-	}
-
-	retval = flash_write_unlock(target, &amp;image, &amp;written, auto_erase, auto_unlock);
-	if (retval != ERROR_OK)
-	{
-		image_close(&amp;image);
-		return retval;
-	}
-
-	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, &quot;wrote %&quot; PRIu32 &quot; byte from file %s &quot;
-				&quot;in %fs (%0.3f kb/s)&quot;, written, CMD_ARGV[0],
-				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, written));
-	}
-
-	image_close(&amp;image);
-
-	return retval;
-}
-
-COMMAND_HANDLER(handle_flash_fill_command)
-{
-	int err = ERROR_OK;
-	uint32_t address;
-	uint32_t pattern;
-	uint32_t count;
-	uint32_t wrote = 0;
-	uint32_t cur_size = 0;
-	uint32_t chunk_count;
-	struct target *target = get_current_target(CMD_CTX);
-	uint32_t i;
-	uint32_t wordsize;
-	int retval = ERROR_OK;
-
-	static size_t const chunksize = 1024;
-	uint8_t *chunk = malloc(chunksize);
-	if (chunk == NULL)
-		return ERROR_FAIL;
-
-	uint8_t *readback = malloc(chunksize);
-	if (readback == NULL)
-	{
-		free(chunk);
-		return ERROR_FAIL;
-	}
-
-
-	if (CMD_ARGC != 3)
-	{
-		retval = ERROR_COMMAND_SYNTAX_ERROR;
-		goto done;
-	}
-
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], pattern);
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], count);
-
-	if (count == 0)
-		goto done;
-
-	switch (CMD_NAME[4])
-	{
-	case 'w':
-		wordsize = 4;
-		break;
-	case 'h':
-		wordsize = 2;
-		break;
-	case 'b':
-		wordsize = 1;
-		break;
-	default:
-		retval = ERROR_COMMAND_SYNTAX_ERROR;
-		goto done;
-	}
-
-	chunk_count = MIN(count, (chunksize / wordsize));
-	switch (wordsize)
-	{
-	case 4:
-		for (i = 0; i &lt; chunk_count; i++)
-		{
-			target_buffer_set_u32(target, chunk + i * wordsize, pattern);
-		}
-		break;
-	case 2:
-		for (i = 0; i &lt; chunk_count; i++)
-		{
-			target_buffer_set_u16(target, chunk + i * wordsize, pattern);
-		}
-		break;
-	case 1:
-		memset(chunk, pattern, chunk_count);
-		break;
-	default:
-		LOG_ERROR(&quot;BUG: can't happen&quot;);
-		exit(-1);
-	}
-
-	struct duration bench;
-	duration_start(&amp;bench);
-
-	for (wrote = 0; wrote &lt; (count*wordsize); wrote += cur_size)
-	{
-		cur_size = MIN((count*wordsize - wrote), sizeof(chunk));
-		struct flash_bank *bank;
-		bank = get_flash_bank_by_addr(target, address);
-		if (bank == NULL)
-		{
-			retval = ERROR_FAIL;
-			goto done;
-		}
-		err = flash_driver_write(bank, chunk, address - bank-&gt;base + wrote, cur_size);
-		if (err != ERROR_OK)
-		{
-			retval = err;
-			goto done;
-		}
-
-		err = target_read_buffer(target, address + wrote, cur_size, readback);
-		if (err != ERROR_OK)
-		{
-			retval = err;
-			goto done;
-		}
-
-		unsigned i;
-		for (i = 0; i &lt; cur_size; i++)
-		{
-			if (readback[i]!=chunk[i])
-			{
-				LOG_ERROR(&quot;Verfication error address 0x%08&quot; PRIx32 &quot;, read back 0x%02x, expected 0x%02x&quot;,
-						  address + wrote + i, readback[i], chunk[i]);
-				retval = ERROR_FAIL;
-				goto done;
-			}
-		}
-	}
-
-	if (duration_measure(&amp;bench) == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;wrote %&quot; PRIu32 &quot; bytes to 0x%8.8&quot; PRIx32
-				&quot; in %fs (%0.3f kb/s)&quot;, wrote, address,
-				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, wrote));
-	}
-
-	done:
-	free(readback);
-	free(chunk);
-
-	return retval;
-}
-
-COMMAND_HANDLER(handle_flash_write_bank_command)
-{
-	uint32_t offset;
-	uint8_t *buffer;
-	struct fileio fileio;
-
-	if (CMD_ARGC != 3)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	struct duration bench;
-	duration_start(&amp;bench);
-
-	struct flash_bank *p;
-	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
-
-	if (fileio_open(&amp;fileio, CMD_ARGV[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
-	{
-		return ERROR_OK;
-	}
-
-	buffer = malloc(fileio.size);
-	size_t buf_cnt;
-	if (fileio_read(&amp;fileio, fileio.size, buffer, &amp;buf_cnt) != ERROR_OK)
-	{
-		free(buffer);
-		fileio_close(&amp;fileio);
-		return ERROR_OK;
-	}
-
-	retval = flash_driver_write(p, buffer, offset, buf_cnt);
-
-	free(buffer);
-	buffer = NULL;
-
-	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
-	{
-		command_print(CMD_CTX, &quot;wrote %zu byte from file %s to flash bank %u&quot;
-				&quot; at offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
-				fileio.size, CMD_ARGV[1], p-&gt;bank_number, offset,
-				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, fileio.size));
-	}
-
-	fileio_close(&amp;fileio);
-
-	return retval;
-}
-
-void flash_set_dirty(void)
-{
-	struct flash_bank *c;
-	int i;
-
-	/* set all flash to require erasing */
-	for (c = flash_banks; c; c = c-&gt;next)
-	{
-		for (i = 0; i &lt; c-&gt;num_sectors; i++)
-		{
-			c-&gt;sectors[i].is_erased = 0;
-		}
-	}
-}
-
 /* lookup flash bank by address */
 struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
 {
@@ -831,239 +165,6 @@ struct flash_bank *get_flash_bank_by_addr(struct target *target, uint32_t addr)
 	return NULL;
 }
 
-/* erase given flash region, selects proper bank according to target and address */
-static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
-		int (*callback)(struct flash_bank *bank, int first, int last))
-{
-	struct flash_bank *c;
-	int first = -1;
-	int last = -1;
-	int i;
-
-	if ((c = get_flash_bank_by_addr(target, addr)) == NULL)
-		return ERROR_FLASH_DST_OUT_OF_BANK; /* no corresponding bank found */
-
-	if (c-&gt;size == 0 || c-&gt;num_sectors == 0)
-	{
-		LOG_ERROR(&quot;Bank is invalid&quot;);
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	if (length == 0)
-	{
-		/* special case, erase whole bank when length is zero */
-		if (addr != c-&gt;base)
-			return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-
-		return callback(c, 0, c-&gt;num_sectors - 1);
-	}
-
-	/* check whether it fits */
-	if (addr + length - 1 &gt; c-&gt;base + c-&gt;size - 1)
-		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
-
-	addr -= c-&gt;base;
-
-	for (i = 0; i &lt; c-&gt;num_sectors; i++)
-	{
-		/* check whether sector overlaps with the given range and is not yet erased */
-		if (addr &lt; c-&gt;sectors[i].offset + c-&gt;sectors[i].size &amp;&amp; addr + length &gt; c-&gt;sectors[i].offset &amp;&amp; c-&gt;sectors[i].is_erased != 1) {
-			/* if first is not set yet then this is the first sector */
-			if (first == -1)
-				first = i;
-			last = i; /* and it is the last one so far in any case */
-		}
-	}
-
-	if (first == -1 || last == -1)
-		return ERROR_OK;
-
-	return callback(c, first, last);
-}
-
-
-
-int flash_erase_address_range(struct target *target, uint32_t addr, uint32_t length)
-{
-	return flash_iterate_address_range(target, addr, length, &amp;flash_driver_erase);
-}
-
-static int flash_driver_unprotect(struct flash_bank *bank, int first, int last)
-{
-	return flash_driver_protect(bank, 0, first, last);
-}
-
-static int flash_unlock_address_range(struct target *target, uint32_t addr, uint32_t length)
-{
-	return flash_iterate_address_range(target, addr, length, &amp;flash_driver_unprotect);
-}
-
-
-/* write (optional verify) an image to flash memory of the given target */
-static int flash_write_unlock(struct target *target, struct image *image, uint32_t *written, int erase, bool unlock)
-{
-	int retval = ERROR_OK;
-
-	int section;
-	uint32_t section_offset;
-	struct flash_bank *c;
-	int *padding;
-
-	section = 0;
-	section_offset = 0;
-
-	if (written)
-		*written = 0;
-
-	if (erase)
-	{
-		/* assume all sectors need erasing - stops any problems
-		 * when flash_write is called multiple times */
-
-		flash_set_dirty();
-	}
-
-	/* allocate padding array */
-	padding = malloc(image-&gt;num_sections * sizeof(padding));
-
-	/* loop until we reach end of the image */
-	while (section &lt; image-&gt;num_sections)
-	{
-		uint32_t buffer_size;
-		uint8_t *buffer;
-		int section_first;
-		int section_last;
-		uint32_t run_address = image-&gt;sections[section].base_address + section_offset;
-		uint32_t run_size = image-&gt;sections[section].size - section_offset;
-		int pad_bytes = 0;
-
-		if (image-&gt;sections[section].size ==  0)
-		{
-			LOG_WARNING(&quot;empty section %d&quot;, section);
-			section++;
-			section_offset = 0;
-			continue;
-		}
-
-		/* find the corresponding flash bank */
-		if ((c = get_flash_bank_by_addr(target, run_address)) == NULL)
-		{
-			section++; /* and skip it */
-			section_offset = 0;
-			continue;
-		}
-
-		/* collect consecutive sections which fall into the same bank */
-		section_first = section;
-		section_last = section;
-		padding[section] = 0;
-		while ((run_address + run_size - 1 &lt; c-&gt;base + c-&gt;size - 1)
-				&amp;&amp; (section_last + 1 &lt; image-&gt;num_sections))
-		{
-			if (image-&gt;sections[section_last + 1].base_address &lt; (run_address + run_size))
-			{
-				LOG_DEBUG(&quot;section %d out of order(very slightly surprising, but supported)&quot;, section_last + 1);
-				break;
-			}
-			/* if we have multiple sections within our image, flash programming could fail due to alignment issues
-			 * attempt to rebuild a consecutive buffer for the flash loader */
-			pad_bytes = (image-&gt;sections[section_last + 1].base_address) - (run_address + run_size);
-			if ((run_address + run_size + pad_bytes) &gt; (c-&gt;base + c-&gt;size))
-				break;
-			padding[section_last] = pad_bytes;
-			run_size += image-&gt;sections[++section_last].size;
-			run_size += pad_bytes;
-			padding[section_last] = 0;
-
-			LOG_INFO(&quot;Padding image section %d with %d bytes&quot;, section_last-1, pad_bytes);
-		}
-
-		/* fit the run into bank constraints */
-		if (run_address + run_size - 1 &gt; c-&gt;base + c-&gt;size - 1)
-		{
-			LOG_WARNING(&quot;writing %d bytes only - as image section is %d bytes and bank is only %d bytes&quot;, \
-				    (int)(c-&gt;base + c-&gt;size - run_address), (int)(run_size), (int)(c-&gt;size));
-			run_size = c-&gt;base + c-&gt;size - run_address;
-		}
-
-		/* allocate buffer */
-		buffer = malloc(run_size);
-		buffer_size = 0;
-
-		/* read sections to the buffer */
-		while (buffer_size &lt; run_size)
-		{
-			size_t size_read;
-
-			size_read = run_size - buffer_size;
-			if (size_read &gt; image-&gt;sections[section].size - section_offset)
-			    size_read = image-&gt;sections[section].size - section_offset;
-
-			if ((retval = image_read_section(image, section, section_offset,
-					size_read, buffer + buffer_size, &amp;size_read)) != ERROR_OK || size_read == 0)
-			{
-				free(buffer);
-				free(padding);
-				return retval;
-			}
-
-			/* see if we need to pad the section */
-			while (padding[section]--)
-				 (buffer + buffer_size)[size_read++] = 0xff;
-
-			buffer_size += size_read;
-			section_offset += size_read;
-
-			if (section_offset &gt;= image-&gt;sections[section].size)
-			{
-				section++;
-				section_offset = 0;
-			}
-		}
-
-		retval = ERROR_OK;
-
-		if (unlock)
-		{
-			retval = flash_unlock_address_range(target, run_address, run_size);
-		}
-		if (retval == ERROR_OK)
-		{
-			if (erase)
-			{
-				/* calculate and erase sectors */
-				retval = flash_erase_address_range(target, run_address, run_size);
-			}
-		}
-
-		if (retval == ERROR_OK)
-		{
-			/* write flash sectors */
-			retval = flash_driver_write(c, buffer, run_address - c-&gt;base, run_size);
-		}
-
-		free(buffer);
-
-		if (retval != ERROR_OK)
-		{
-			free(padding);
-			return retval; /* abort operation */
-		}
-
-		if (written != NULL)
-			*written += run_size; /* add run size to total written counter */
-	}
-
-	free(padding);
-
-	return retval;
-}
-
-int flash_write(struct target *target, struct image *image, uint32_t *written, int erase)
-{
-	return flash_write_unlock(target, image, written, erase, false);
-}
-
 int default_flash_mem_blank_check(struct flash_bank *bank)
 {
 	struct target *target = bank-&gt;target;
@@ -1156,103 +257,3 @@ int default_flash_blank_check(struct flash_bank *bank)
 
 	return ERROR_OK;
 }
-
-static const struct command_registration flash_exec_command_handlers[] = {
-	{
-		.name = &quot;probe&quot;,
-		.handler = &amp;handle_flash_probe_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt;&quot;,
-		.help = &quot;identify flash bank&quot;,
-	},
-	{
-		.name = &quot;info&quot;,
-		.handler = &amp;handle_flash_info_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt;&quot;,
-		.help = &quot;print bank information&quot;,
-	},
-	{
-		.name = &quot;erase_check&quot;,
-		.handler = &amp;handle_flash_erase_check_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt;&quot;,
-		.help = &quot;check erase state of sectors&quot;,
-	},
-	{
-		.name = &quot;protect_check&quot;,
-		.handler = &amp;handle_flash_protect_check_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt;&quot;,
-		.help = &quot;check protection state of sectors&quot;,
-	},
-	{
-		.name = &quot;erase_sector&quot;,
-		.handler = &amp;handle_flash_erase_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;first&gt; &lt;last&gt;&quot;,
-		.help = &quot;erase sectors&quot;,
-	},
-	{
-		.name = &quot;erase_address&quot;,
-		.handler = &amp;handle_flash_erase_address_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;address&gt; &lt;length&gt;&quot;,
-		.help = &quot;erase address range&quot;,
-
-	},
-	{
-		.name = &quot;fillw&quot;,
-		.handler = &amp;handle_flash_fill_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;address&gt; &lt;word_pattern&gt; &lt;count&gt;&quot;,
-		.help = &quot;fill with pattern (no autoerase)&quot;,
-	},
-	{
-		.name = &quot;fillh&quot;,
-		.handler = &amp;handle_flash_fill_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;address&gt; &lt;halfword_pattern&gt; &lt;count&gt;&quot;,
-		.help = &quot;fill with pattern&quot;,
-	},
-	{
-		.name = &quot;fillb&quot;,
-		.handler = &amp;handle_flash_fill_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;address&gt; &lt;byte_pattern&gt; &lt;count&gt;&quot;,
-		.help = &quot;fill with pattern&quot;,
-
-	},
-	{
-		.name = &quot;write_bank&quot;,
-		.handler = &amp;handle_flash_write_bank_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;file&gt; &lt;offset&gt;&quot;,
-		.help = &quot;write binary data&quot;,
-	},
-	{
-		.name = &quot;write_image&quot;,
-		.handler = &amp;handle_flash_write_image_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; [erase] [unlock] &lt;file&gt; [offset] [type]&quot;,
-		.help = &quot;write an image to flash&quot;
-	},
-	{
-		.name = &quot;protect&quot;,
-		.handler = &amp;handle_flash_protect_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;first&gt; &lt;last&gt; &lt;on | off&gt;&quot;,
-		.help = &quot;set protection of sectors&quot;,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-int flash_init_drivers(struct command_context *cmd_ctx)
-{
-	if (!flash_banks)
-		return ERROR_OK;
-
-	struct command *parent = command_find_in_context(cmd_ctx, &quot;flash&quot;);
-	return register_commands(cmd_ctx, parent, flash_exec_command_handlers);
-}
-
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
index 499ebfa..67a5e55 100644
--- a/src/flash/nor/Makefile.am
+++ b/src/flash/nor/Makefile.am
@@ -31,6 +31,7 @@ noinst_HEADERS = \
 	at91sam7.h \
 	at91sam3.h \
 	avrf.h \
+	core.h \
 	cfi.h \
 	imp.h \
 	lpc2000.h \
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
index a69c3f4..2dbf114 100644
--- a/src/flash/nor/core.c
+++ b/src/flash/nor/core.c
@@ -22,6 +22,7 @@
 #endif
 #include &lt;flash/flash.h&gt;
 #include &lt;flash/nor/imp.h&gt;
+#include &lt;target/image.h&gt;
 
 // in flash.c, to be moved here
 extern struct flash_driver *flash_drivers[];
@@ -37,6 +38,48 @@ struct flash_driver *flash_driver_find_by_name(const char *name)
 	return NULL;
 }
 
+int flash_driver_erase(struct flash_bank *bank, int first, int last)
+{
+	int retval;
+
+	retval = bank-&gt;driver-&gt;erase(bank, first, last);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR(&quot;failed erasing sectors %d to %d (%d)&quot;, first, last, retval);
+	}
+
+	return retval;
+}
+
+int flash_driver_protect(struct flash_bank *bank, int set, int first, int last)
+{
+	int retval;
+
+	retval = bank-&gt;driver-&gt;protect(bank, set, first, last);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR(&quot;failed setting protection for areas %d to %d (%d)&quot;, first, last, retval);
+	}
+
+	return retval;
+}
+
+int flash_driver_write(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count)
+{
+	int retval;
+
+	retval = bank-&gt;driver-&gt;write(bank, buffer, offset, count);
+	if (retval != ERROR_OK)
+	{
+		LOG_ERROR(&quot;error writing to flash at address 0x%08&quot; PRIx32 &quot; at offset 0x%8.8&quot; PRIx32 &quot; (%d)&quot;,
+			  bank-&gt;base, offset, retval);
+	}
+
+	return retval;
+}
+
+
 void flash_bank_add(struct flash_bank *bank)
 {
 	/* put flash bank in linked list */
@@ -63,3 +106,236 @@ struct flash_bank *flash_bank_list(void)
 {
 	return flash_banks;
 }
+
+/* erase given flash region, selects proper bank according to target and address */
+static int flash_iterate_address_range(struct target *target, uint32_t addr, uint32_t length,
+		int (*callback)(struct flash_bank *bank, int first, int last))
+{
+	struct flash_bank *c;
+	int first = -1;
+	int last = -1;
+	int i;
+
+	if ((c = get_flash_bank_by_addr(target, addr)) == NULL)
+		return ERROR_FLASH_DST_OUT_OF_BANK; /* no corresponding bank found */
+
+	if (c-&gt;size == 0 || c-&gt;num_sectors == 0)
+	{
+		LOG_ERROR(&quot;Bank is invalid&quot;);
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	if (length == 0)
+	{
+		/* special case, erase whole bank when length is zero */
+		if (addr != c-&gt;base)
+			return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+
+		return callback(c, 0, c-&gt;num_sectors - 1);
+	}
+
+	/* check whether it fits */
+	if (addr + length - 1 &gt; c-&gt;base + c-&gt;size - 1)
+		return ERROR_FLASH_DST_BREAKS_ALIGNMENT;
+
+	addr -= c-&gt;base;
+
+	for (i = 0; i &lt; c-&gt;num_sectors; i++)
+	{
+		/* check whether sector overlaps with the given range and is not yet erased */
+		if (addr &lt; c-&gt;sectors[i].offset + c-&gt;sectors[i].size &amp;&amp; addr + length &gt; c-&gt;sectors[i].offset &amp;&amp; c-&gt;sectors[i].is_erased != 1) {
+			/* if first is not set yet then this is the first sector */
+			if (first == -1)
+				first = i;
+			last = i; /* and it is the last one so far in any case */
+		}
+	}
+
+	if (first == -1 || last == -1)
+		return ERROR_OK;
+
+	return callback(c, first, last);
+}
+
+int flash_erase_address_range(struct target *target, uint32_t addr, uint32_t length)
+{
+	return flash_iterate_address_range(target,
+			addr, length, &amp;flash_driver_erase);
+}
+
+static int flash_driver_unprotect(struct flash_bank *bank, int first, int last)
+{
+	return flash_driver_protect(bank, 0, first, last);
+}
+
+static int flash_unlock_address_range(struct target *target, uint32_t addr, uint32_t length)
+{
+	return flash_iterate_address_range(target,
+			addr, length, &amp;flash_driver_unprotect);
+}
+
+int flash_write_unlock(struct target *target, struct image *image,
+		uint32_t *written, int erase, bool unlock)
+{
+	int retval = ERROR_OK;
+
+	int section;
+	uint32_t section_offset;
+	struct flash_bank *c;
+	int *padding;
+
+	section = 0;
+	section_offset = 0;
+
+	if (written)
+		*written = 0;
+
+	if (erase)
+	{
+		/* assume all sectors need erasing - stops any problems
+		 * when flash_write is called multiple times */
+
+		flash_set_dirty();
+	}
+
+	/* allocate padding array */
+	padding = malloc(image-&gt;num_sections * sizeof(padding));
+
+	/* loop until we reach end of the image */
+	while (section &lt; image-&gt;num_sections)
+	{
+		uint32_t buffer_size;
+		uint8_t *buffer;
+		int section_first;
+		int section_last;
+		uint32_t run_address = image-&gt;sections[section].base_address + section_offset;
+		uint32_t run_size = image-&gt;sections[section].size - section_offset;
+		int pad_bytes = 0;
+
+		if (image-&gt;sections[section].size ==  0)
+		{
+			LOG_WARNING(&quot;empty section %d&quot;, section);
+			section++;
+			section_offset = 0;
+			continue;
+		}
+
+		/* find the corresponding flash bank */
+		if ((c = get_flash_bank_by_addr(target, run_address)) == NULL)
+		{
+			section++; /* and skip it */
+			section_offset = 0;
+			continue;
+		}
+
+		/* collect consecutive sections which fall into the same bank */
+		section_first = section;
+		section_last = section;
+		padding[section] = 0;
+		while ((run_address + run_size - 1 &lt; c-&gt;base + c-&gt;size - 1)
+				&amp;&amp; (section_last + 1 &lt; image-&gt;num_sections))
+		{
+			if (image-&gt;sections[section_last + 1].base_address &lt; (run_address + run_size))
+			{
+				LOG_DEBUG(&quot;section %d out of order(very slightly surprising, but supported)&quot;, section_last + 1);
+				break;
+			}
+			/* if we have multiple sections within our image, flash programming could fail due to alignment issues
+			 * attempt to rebuild a consecutive buffer for the flash loader */
+			pad_bytes = (image-&gt;sections[section_last + 1].base_address) - (run_address + run_size);
+			if ((run_address + run_size + pad_bytes) &gt; (c-&gt;base + c-&gt;size))
+				break;
+			padding[section_last] = pad_bytes;
+			run_size += image-&gt;sections[++section_last].size;
+			run_size += pad_bytes;
+			padding[section_last] = 0;
+
+			LOG_INFO(&quot;Padding image section %d with %d bytes&quot;, section_last-1, pad_bytes);
+		}
+
+		/* fit the run into bank constraints */
+		if (run_address + run_size - 1 &gt; c-&gt;base + c-&gt;size - 1)
+		{
+			LOG_WARNING(&quot;writing %d bytes only - as image section is %d bytes and bank is only %d bytes&quot;, \
+				    (int)(c-&gt;base + c-&gt;size - run_address), (int)(run_size), (int)(c-&gt;size));
+			run_size = c-&gt;base + c-&gt;size - run_address;
+		}
+
+		/* allocate buffer */
+		buffer = malloc(run_size);
+		buffer_size = 0;
+
+		/* read sections to the buffer */
+		while (buffer_size &lt; run_size)
+		{
+			size_t size_read;
+
+			size_read = run_size - buffer_size;
+			if (size_read &gt; image-&gt;sections[section].size - section_offset)
+			    size_read = image-&gt;sections[section].size - section_offset;
+
+			if ((retval = image_read_section(image, section, section_offset,
+					size_read, buffer + buffer_size, &amp;size_read)) != ERROR_OK || size_read == 0)
+			{
+				free(buffer);
+				free(padding);
+				return retval;
+			}
+
+			/* see if we need to pad the section */
+			while (padding[section]--)
+				 (buffer + buffer_size)[size_read++] = 0xff;
+
+			buffer_size += size_read;
+			section_offset += size_read;
+
+			if (section_offset &gt;= image-&gt;sections[section].size)
+			{
+				section++;
+				section_offset = 0;
+			}
+		}
+
+		retval = ERROR_OK;
+
+		if (unlock)
+		{
+			retval = flash_unlock_address_range(target, run_address, run_size);
+		}
+		if (retval == ERROR_OK)
+		{
+			if (erase)
+			{
+				/* calculate and erase sectors */
+				retval = flash_erase_address_range(target, run_address, run_size);
+			}
+		}
+
+		if (retval == ERROR_OK)
+		{
+			/* write flash sectors */
+			retval = flash_driver_write(c, buffer, run_address - c-&gt;base, run_size);
+		}
+
+		free(buffer);
+
+		if (retval != ERROR_OK)
+		{
+			free(padding);
+			return retval; /* abort operation */
+		}
+
+		if (written != NULL)
+			*written += run_size; /* add run size to total written counter */
+	}
+
+	free(padding);
+
+	return retval;
+}
+
+int flash_write(struct target *target, struct image *image,
+		uint32_t *written, int erase)
+{
+	return flash_write_unlock(target, image, written, erase, false);
+}
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
index 23ac476..ade7297 100644
--- a/src/flash/nor/imp.h
+++ b/src/flash/nor/imp.h
@@ -33,4 +33,13 @@ void flash_bank_add(struct flash_bank *bank);
  */
 struct flash_bank *flash_bank_list(void);
 
+int flash_driver_erase(struct flash_bank *bank, int first, int last);
+int flash_driver_protect(struct flash_bank *bank, int set, int first, int last);
+int flash_driver_write(struct flash_bank *bank,
+		uint8_t *buffer, uint32_t offset, uint32_t count);
+
+/* write (optional verify) an image to flash memory of the given target */
+int flash_write_unlock(struct target *target, struct image *image,
+		uint32_t *written, int erase, bool unlock);
+
 #endif // FLASH_NOR_IMP_H
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index b00516d..6598652 100644
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -23,6 +23,731 @@
 #include &quot;config.h&quot;
 #endif
 #include &quot;imp.h&quot;
+#include &lt;helper/time_support.h&gt;
+#include &lt;target/image.h&gt;
+
+COMMAND_HELPER(flash_command_get_bank, unsigned name_index,
+		struct flash_bank **bank)
+{
+	const char *name = CMD_ARGV[name_index];
+	*bank = get_flash_bank_by_name(name);
+	if (*bank)
+		return ERROR_OK;
+
+	unsigned bank_num;
+	COMMAND_PARSE_NUMBER(uint, name, bank_num);
+
+	*bank = get_flash_bank_by_num(bank_num);
+	if (!*bank)
+	{
+		command_print(CMD_CTX, &quot;flash bank '%s' not found&quot;, name);
+		return ERROR_INVALID_ARGUMENTS;
+	}
+	return ERROR_OK;
+}
+
+
+COMMAND_HANDLER(handle_flash_info_command)
+{
+	struct flash_bank *p;
+	uint32_t i = 0;
+	int j = 0;
+	int retval;
+
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	unsigned bank_nr;
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
+
+	for (p = flash_bank_list(); p; p = p-&gt;next, i++)
+	{
+		if (i != bank_nr)
+			continue;
+
+		char buf[1024];
+
+		/* attempt auto probe */
+		if ((retval = p-&gt;driver-&gt;auto_probe(p)) != ERROR_OK)
+			return retval;
+
+		command_print(CMD_CTX,
+			      &quot;#%&quot; PRIi32 &quot; : %s at 0x%8.8&quot; PRIx32 &quot;, size 0x%8.8&quot; PRIx32 &quot;, buswidth %i, chipwidth %i&quot;,
+			      i,
+			      p-&gt;driver-&gt;name,
+			      p-&gt;base,
+			      p-&gt;size,
+			      p-&gt;bus_width,
+			      p-&gt;chip_width);
+		for (j = 0; j &lt; p-&gt;num_sectors; j++)
+		{
+			char *protect_state;
+
+			if (p-&gt;sectors[j].is_protected == 0)
+				protect_state = &quot;not protected&quot;;
+			else if (p-&gt;sectors[j].is_protected == 1)
+				protect_state = &quot;protected&quot;;
+			else
+				protect_state = &quot;protection state unknown&quot;;
+
+			command_print(CMD_CTX,
+				      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
+				      j,
+				      p-&gt;sectors[j].offset,
+				      p-&gt;sectors[j].size,
+				      p-&gt;sectors[j].size &gt;&gt; 10,
+				      protect_state);
+		}
+
+		*buf = '\0'; /* initialize buffer, otherwise it migh contain garbage if driver function fails */
+		retval = p-&gt;driver-&gt;info(p, buf, sizeof(buf));
+		command_print(CMD_CTX, &quot;%s&quot;, buf);
+		if (retval != ERROR_OK)
+			LOG_ERROR(&quot;error retrieving flash info (%d)&quot;, retval);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_probe_command)
+{
+	int retval;
+
+	if (CMD_ARGC != 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	unsigned bank_nr;
+	COMMAND_PARSE_NUMBER(uint, CMD_ARGV[0], bank_nr);
+	struct flash_bank *p = get_flash_bank_by_num_noprobe(bank_nr);
+	if (p)
+	{
+		if ((retval = p-&gt;driver-&gt;probe(p)) == ERROR_OK)
+		{
+			command_print(CMD_CTX, &quot;flash '%s' found at 0x%8.8&quot; PRIx32, p-&gt;driver-&gt;name, p-&gt;base);
+		}
+		else if (retval == ERROR_FLASH_BANK_INVALID)
+		{
+			command_print(CMD_CTX, &quot;probing failed for flash bank '#%s' at 0x%8.8&quot; PRIx32,
+						  CMD_ARGV[0], p-&gt;base);
+		}
+		else
+		{
+			command_print(CMD_CTX, &quot;unknown error when probing flash bank '#%s' at 0x%8.8&quot; PRIx32,
+						  CMD_ARGV[0], p-&gt;base);
+		}
+	}
+	else
+	{
+		command_print(CMD_CTX, &quot;flash bank '#%s' is out of bounds&quot;, CMD_ARGV[0]);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_erase_check_command)
+{
+	if (CMD_ARGC != 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	struct flash_bank *p;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	int j;
+	if ((retval = p-&gt;driver-&gt;erase_check(p)) == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;successfully checked erase state&quot;);
+	}
+	else
+	{
+		command_print(CMD_CTX, &quot;unknown error when checking erase state of flash bank #%s at 0x%8.8&quot; PRIx32,
+			CMD_ARGV[0], p-&gt;base);
+	}
+
+	for (j = 0; j &lt; p-&gt;num_sectors; j++)
+	{
+		char *erase_state;
+
+		if (p-&gt;sectors[j].is_erased == 0)
+			erase_state = &quot;not erased&quot;;
+		else if (p-&gt;sectors[j].is_erased == 1)
+			erase_state = &quot;erased&quot;;
+		else
+			erase_state = &quot;erase state unknown&quot;;
+
+		command_print(CMD_CTX,
+			      &quot;\t#%3i: 0x%8.8&quot; PRIx32 &quot; (0x%&quot; PRIx32 &quot; %&quot; PRIi32 &quot;kB) %s&quot;,
+			      j,
+			      p-&gt;sectors[j].offset,
+			      p-&gt;sectors[j].size,
+			      p-&gt;sectors[j].size &gt;&gt; 10,
+			      erase_state);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_erase_address_command)
+{
+	struct flash_bank *p;
+	int retval;
+	int address;
+	int length;
+
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (CMD_ARGC != 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], length);
+	if (length &lt;= 0)
+	{
+		command_print(CMD_CTX, &quot;Length must be &gt;0&quot;);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	p = get_flash_bank_by_addr(target, address);
+	if (p == NULL)
+	{
+		return ERROR_FAIL;
+	}
+
+	/* We can't know if we did a resume + halt, in which case we no longer know the erased state */
+	flash_set_dirty();
+
+	struct duration bench;
+	duration_start(&amp;bench);
+
+	retval = flash_erase_address_range(target, address, length);
+
+	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, &quot;erased address 0x%8.8x (length %i)&quot;
+				&quot; in %fs (%0.3f kb/s)&quot;, address, length,
+				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, length));
+	}
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_flash_protect_check_command)
+{
+	if (CMD_ARGC != 1)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct flash_bank *p;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if ((retval = p-&gt;driver-&gt;protect_check(p)) == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;successfully checked protect state&quot;);
+	}
+	else if (retval == ERROR_FLASH_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, &quot;checking protection state failed (possibly unsupported) by flash #%s at 0x%8.8&quot; PRIx32, CMD_ARGV[0], p-&gt;base);
+	}
+	else
+	{
+		command_print(CMD_CTX, &quot;unknown error when checking protection state of flash bank '#%s' at 0x%8.8&quot; PRIx32, CMD_ARGV[0], p-&gt;base);
+	}
+
+	return ERROR_OK;
+}
+
+static int flash_check_sector_parameters(struct command_context *cmd_ctx,
+		uint32_t first, uint32_t last, uint32_t num_sectors)
+{
+	if (!(first &lt;= last)) {
+		command_print(cmd_ctx, &quot;ERROR: &quot;
+				&quot;first sector must be &lt;= last sector&quot;);
+		return ERROR_FAIL;
+	}
+
+	if (!(last &lt;= (num_sectors - 1))) {
+		command_print(cmd_ctx, &quot;ERROR: last sector must be &lt;= %d&quot;,
+				(int) num_sectors - 1);
+		return ERROR_FAIL;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_erase_command)
+{
+	if (CMD_ARGC != 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	uint32_t bank_nr;
+	uint32_t first;
+	uint32_t last;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
+	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
+	if (!p)
+		return ERROR_OK;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
+	if (strcmp(CMD_ARGV[2], &quot;last&quot;) == 0)
+		last = p-&gt;num_sectors - 1;
+	else
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
+
+	int retval;
+	if ((retval = flash_check_sector_parameters(CMD_CTX,
+			first, last, p-&gt;num_sectors)) != ERROR_OK)
+		return retval;
+
+	struct duration bench;
+	duration_start(&amp;bench);
+
+	retval = flash_driver_erase(p, first, last);
+
+	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, &quot;erased sectors %&quot; PRIu32 &quot; &quot;
+				&quot;through %&quot; PRIu32&quot; on flash bank %&quot; PRIu32 &quot; &quot;
+				&quot;in %fs&quot;, first, last, bank_nr, duration_elapsed(&amp;bench));
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_protect_command)
+{
+	if (CMD_ARGC != 4)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	uint32_t bank_nr;
+	uint32_t first;
+	uint32_t last;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], bank_nr);
+	struct flash_bank *p = get_flash_bank_by_num(bank_nr);
+	if (!p)
+		return ERROR_OK;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], first);
+	if (strcmp(CMD_ARGV[2], &quot;last&quot;) == 0)
+		last = p-&gt;num_sectors - 1;
+	else
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], last);
+
+	bool set;
+	COMMAND_PARSE_ON_OFF(CMD_ARGV[3], set);
+
+	int retval;
+	if ((retval = flash_check_sector_parameters(CMD_CTX,
+			first, last, p-&gt;num_sectors)) != ERROR_OK)
+		return retval;
+
+	retval = flash_driver_protect(p, set, first, last);
+	if (retval == ERROR_OK) {
+		command_print(CMD_CTX, &quot;%s protection for sectors %i &quot;
+				&quot;through %i on flash bank %i&quot;,
+			(set) ? &quot;set&quot; : &quot;cleared&quot;, (int) first,
+			(int) last, (int) bank_nr);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_flash_write_image_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+
+	struct image image;
+	uint32_t written;
+
+	int retval;
+
+	if (CMD_ARGC &lt; 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* flash auto-erase is disabled by default*/
+	int auto_erase = 0;
+	bool auto_unlock = false;
+
+	for (;;)
+	{
+		if (strcmp(CMD_ARGV[0], &quot;erase&quot;) == 0)
+		{
+			auto_erase = 1;
+			CMD_ARGV++;
+			CMD_ARGC--;
+			command_print(CMD_CTX, &quot;auto erase enabled&quot;);
+		} else if (strcmp(CMD_ARGV[0], &quot;unlock&quot;) == 0)
+		{
+			auto_unlock = true;
+			CMD_ARGV++;
+			CMD_ARGC--;
+			command_print(CMD_CTX, &quot;auto unlock enabled&quot;);
+		} else
+		{
+			break;
+		}
+	}
+
+	if (CMD_ARGC &lt; 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (!target)
+	{
+		LOG_ERROR(&quot;no target selected&quot;);
+		return ERROR_FAIL;
+	}
+
+	struct duration bench;
+	duration_start(&amp;bench);
+
+	if (CMD_ARGC &gt;= 2)
+	{
+		image.base_address_set = 1;
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], image.base_address);
+	}
+	else
+	{
+		image.base_address_set = 0;
+		image.base_address = 0x0;
+	}
+
+	image.start_address_set = 0;
+
+	retval = image_open(&amp;image, CMD_ARGV[0], (CMD_ARGC == 3) ? CMD_ARGV[2] : NULL);
+	if (retval != ERROR_OK)
+	{
+		return retval;
+	}
+
+	retval = flash_write_unlock(target, &amp;image, &amp;written, auto_erase, auto_unlock);
+	if (retval != ERROR_OK)
+	{
+		image_close(&amp;image);
+		return retval;
+	}
+
+	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, &quot;wrote %&quot; PRIu32 &quot; byte from file %s &quot;
+				&quot;in %fs (%0.3f kb/s)&quot;, written, CMD_ARGV[0],
+				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, written));
+	}
+
+	image_close(&amp;image);
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_flash_fill_command)
+{
+	int err = ERROR_OK;
+	uint32_t address;
+	uint32_t pattern;
+	uint32_t count;
+	uint32_t wrote = 0;
+	uint32_t cur_size = 0;
+	uint32_t chunk_count;
+	struct target *target = get_current_target(CMD_CTX);
+	uint32_t i;
+	uint32_t wordsize;
+	int retval = ERROR_OK;
+
+	static size_t const chunksize = 1024;
+	uint8_t *chunk = malloc(chunksize);
+	if (chunk == NULL)
+		return ERROR_FAIL;
+
+	uint8_t *readback = malloc(chunksize);
+	if (readback == NULL)
+	{
+		free(chunk);
+		return ERROR_FAIL;
+	}
+
+
+	if (CMD_ARGC != 3)
+	{
+		retval = ERROR_COMMAND_SYNTAX_ERROR;
+		goto done;
+	}
+
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], pattern);
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], count);
+
+	if (count == 0)
+		goto done;
+
+	switch (CMD_NAME[4])
+	{
+	case 'w':
+		wordsize = 4;
+		break;
+	case 'h':
+		wordsize = 2;
+		break;
+	case 'b':
+		wordsize = 1;
+		break;
+	default:
+		retval = ERROR_COMMAND_SYNTAX_ERROR;
+		goto done;
+	}
+
+	chunk_count = MIN(count, (chunksize / wordsize));
+	switch (wordsize)
+	{
+	case 4:
+		for (i = 0; i &lt; chunk_count; i++)
+		{
+			target_buffer_set_u32(target, chunk + i * wordsize, pattern);
+		}
+		break;
+	case 2:
+		for (i = 0; i &lt; chunk_count; i++)
+		{
+			target_buffer_set_u16(target, chunk + i * wordsize, pattern);
+		}
+		break;
+	case 1:
+		memset(chunk, pattern, chunk_count);
+		break;
+	default:
+		LOG_ERROR(&quot;BUG: can't happen&quot;);
+		exit(-1);
+	}
+
+	struct duration bench;
+	duration_start(&amp;bench);
+
+	for (wrote = 0; wrote &lt; (count*wordsize); wrote += cur_size)
+	{
+		cur_size = MIN((count*wordsize - wrote), sizeof(chunk));
+		struct flash_bank *bank;
+		bank = get_flash_bank_by_addr(target, address);
+		if (bank == NULL)
+		{
+			retval = ERROR_FAIL;
+			goto done;
+		}
+		err = flash_driver_write(bank, chunk, address - bank-&gt;base + wrote, cur_size);
+		if (err != ERROR_OK)
+		{
+			retval = err;
+			goto done;
+		}
+
+		err = target_read_buffer(target, address + wrote, cur_size, readback);
+		if (err != ERROR_OK)
+		{
+			retval = err;
+			goto done;
+		}
+
+		unsigned i;
+		for (i = 0; i &lt; cur_size; i++)
+		{
+			if (readback[i]!=chunk[i])
+			{
+				LOG_ERROR(&quot;Verfication error address 0x%08&quot; PRIx32 &quot;, read back 0x%02x, expected 0x%02x&quot;,
+						  address + wrote + i, readback[i], chunk[i]);
+				retval = ERROR_FAIL;
+				goto done;
+			}
+		}
+	}
+
+	if (duration_measure(&amp;bench) == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;wrote %&quot; PRIu32 &quot; bytes to 0x%8.8&quot; PRIx32
+				&quot; in %fs (%0.3f kb/s)&quot;, wrote, address,
+				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, wrote));
+	}
+
+	done:
+	free(readback);
+	free(chunk);
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_flash_write_bank_command)
+{
+	uint32_t offset;
+	uint8_t *buffer;
+	struct fileio fileio;
+
+	if (CMD_ARGC != 3)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct duration bench;
+	duration_start(&amp;bench);
+
+	struct flash_bank *p;
+	int retval = CALL_COMMAND_HANDLER(flash_command_get_bank, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], offset);
+
+	if (fileio_open(&amp;fileio, CMD_ARGV[1], FILEIO_READ, FILEIO_BINARY) != ERROR_OK)
+	{
+		return ERROR_OK;
+	}
+
+	buffer = malloc(fileio.size);
+	size_t buf_cnt;
+	if (fileio_read(&amp;fileio, fileio.size, buffer, &amp;buf_cnt) != ERROR_OK)
+	{
+		free(buffer);
+		fileio_close(&amp;fileio);
+		return ERROR_OK;
+	}
+
+	retval = flash_driver_write(p, buffer, offset, buf_cnt);
+
+	free(buffer);
+	buffer = NULL;
+
+	if ((ERROR_OK == retval) &amp;&amp; (duration_measure(&amp;bench) == ERROR_OK))
+	{
+		command_print(CMD_CTX, &quot;wrote %zu byte from file %s to flash bank %u&quot;
+				&quot; at offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
+				fileio.size, CMD_ARGV[1], p-&gt;bank_number, offset,
+				duration_elapsed(&amp;bench), duration_kbps(&amp;bench, fileio.size));
+	}
+
+	fileio_close(&amp;fileio);
+
+	return retval;
+}
+
+void flash_set_dirty(void)
+{
+	struct flash_bank *c;
+	int i;
+
+	/* set all flash to require erasing */
+	for (c = flash_bank_list(); c; c = c-&gt;next)
+	{
+		for (i = 0; i &lt; c-&gt;num_sectors; i++)
+		{
+			c-&gt;sectors[i].is_erased = 0;
+		}
+	}
+}
+
+static const struct command_registration flash_exec_command_handlers[] = {
+	{
+		.name = &quot;probe&quot;,
+		.handler = &amp;handle_flash_probe_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt;&quot;,
+		.help = &quot;identify flash bank&quot;,
+	},
+	{
+		.name = &quot;info&quot;,
+		.handler = &amp;handle_flash_info_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt;&quot;,
+		.help = &quot;print bank information&quot;,
+	},
+	{
+		.name = &quot;erase_check&quot;,
+		.handler = &amp;handle_flash_erase_check_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt;&quot;,
+		.help = &quot;check erase state of sectors&quot;,
+	},
+	{
+		.name = &quot;protect_check&quot;,
+		.handler = &amp;handle_flash_protect_check_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt;&quot;,
+		.help = &quot;check protection state of sectors&quot;,
+	},
+	{
+		.name = &quot;erase_sector&quot;,
+		.handler = &amp;handle_flash_erase_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;first&gt; &lt;last&gt;&quot;,
+		.help = &quot;erase sectors&quot;,
+	},
+	{
+		.name = &quot;erase_address&quot;,
+		.handler = &amp;handle_flash_erase_address_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;address&gt; &lt;length&gt;&quot;,
+		.help = &quot;erase address range&quot;,
+
+	},
+	{
+		.name = &quot;fillw&quot;,
+		.handler = &amp;handle_flash_fill_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;address&gt; &lt;word_pattern&gt; &lt;count&gt;&quot;,
+		.help = &quot;fill with pattern (no autoerase)&quot;,
+	},
+	{
+		.name = &quot;fillh&quot;,
+		.handler = &amp;handle_flash_fill_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;address&gt; &lt;halfword_pattern&gt; &lt;count&gt;&quot;,
+		.help = &quot;fill with pattern&quot;,
+	},
+	{
+		.name = &quot;fillb&quot;,
+		.handler = &amp;handle_flash_fill_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;address&gt; &lt;byte_pattern&gt; &lt;count&gt;&quot;,
+		.help = &quot;fill with pattern&quot;,
+
+	},
+	{
+		.name = &quot;write_bank&quot;,
+		.handler = &amp;handle_flash_write_bank_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;file&gt; &lt;offset&gt;&quot;,
+		.help = &quot;write binary data&quot;,
+	},
+	{
+		.name = &quot;write_image&quot;,
+		.handler = &amp;handle_flash_write_image_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; [erase] [unlock] &lt;file&gt; [offset] [type]&quot;,
+		.help = &quot;write an image to flash&quot;
+	},
+	{
+		.name = &quot;protect&quot;,
+		.handler = &amp;handle_flash_protect_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;first&gt; &lt;last&gt; &lt;on | off&gt;&quot;,
+		.help = &quot;set protection of sectors&quot;,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int flash_init_drivers(struct command_context *cmd_ctx)
+{
+	if (!flash_bank_list())
+		return ERROR_OK;
+
+	struct command *parent = command_find_in_context(cmd_ctx, &quot;flash&quot;);
+	return register_commands(cmd_ctx, parent, flash_exec_command_handlers);
+}
+
 
 COMMAND_HANDLER(handle_flash_bank_command)
 {

-----------------------------------------------------------------------

Summary of changes:
 src/Makefile.am                     |   10 +-
 src/flash/Makefile.am               |    2 -
 src/flash/common.h                  |   11 +-
 src/flash/flash.c                   | 1258 -----------------------------------
 src/flash/flash.h                   |  361 ----------
 src/flash/nand.h                    |    4 +-
 src/flash/nor/Makefile.am           |    5 +-
 src/flash/nor/aduc702x.c            |    4 +-
 src/flash/nor/at91sam3.c            |    8 +-
 src/flash/nor/at91sam7.c            |    1 +
 src/flash/nor/at91sam7.h            |    2 -
 src/flash/nor/avrf.c                |    2 +-
 src/flash/nor/avrf.h                |    2 -
 src/flash/nor/cfi.c                 |    1 +
 src/flash/nor/cfi.h                 |    2 -
 src/flash/nor/core.c                |  466 +++++++++++++-
 src/flash/nor/core.h                |  157 +++++-
 src/flash/nor/driver.h              |  201 ++++++
 src/flash/nor/{core.c =&gt; drivers.c} |   80 ++-
 src/flash/nor/ecos.c                |    4 +-
 src/flash/nor/faux.c                |    2 +-
 src/flash/nor/imp.h                 |   14 +
 src/flash/nor/lpc2000.c             |    3 +-
 src/flash/nor/lpc2000.h             |    2 -
 src/flash/nor/lpc288x.c             |    1 +
 src/flash/nor/lpc288x.h             |    2 -
 src/flash/nor/lpc2900.c             |    6 +-
 src/flash/nor/non_cfi.c             |    3 +-
 src/flash/nor/non_cfi.h             |    2 -
 src/flash/nor/ocl.c                 |    2 +-
 src/flash/nor/pic32mx.c             |    1 +
 src/flash/nor/pic32mx.h             |    2 -
 src/flash/nor/stellaris.c           |    3 +-
 src/flash/nor/stellaris.h           |    2 -
 src/flash/nor/stm32x.c              |    3 +-
 src/flash/nor/stm32x.h              |    2 -
 src/flash/nor/str7x.c               |    1 +
 src/flash/nor/str7x.h               |    2 -
 src/flash/nor/str9x.c               |    1 +
 src/flash/nor/str9x.h               |    2 -
 src/flash/nor/str9xpec.c            |    1 +
 src/flash/nor/str9xpec.h            |    2 -
 src/flash/nor/tcl.c                 |  725 ++++++++++++++++++++
 src/flash/nor/tms470.c              |    1 +
 src/flash/nor/tms470.h              |    2 -
 src/openocd.c                       |    1 +
 src/server/gdb_server.c             |    2 +-
 src/server/gdb_server.h             |    1 +
 48 files changed, 1652 insertions(+), 1720 deletions(-)
 delete mode 100644 src/flash/flash.c
 delete mode 100644 src/flash/flash.h
 create mode 100644 src/flash/nor/driver.h
 copy src/flash/nor/{core.c =&gt; drivers.c} (56%)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001924.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-856-g32f961d
</A></li>
	<LI>Next message: <A HREF="001926.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-867-gf67f6fe
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1925">[ date ]</a>
              <a href="thread.html#1925">[ thread ]</a>
              <a href="subject.html#1925">[ subject ]</a>
              <a href="author.html#1925">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
