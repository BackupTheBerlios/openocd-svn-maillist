<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-767-gd5e4e23
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-767-gd5e4e23&In-Reply-To=%3CE1NG5oJ-0004Eh-Jq%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001907.html">
   <LINK REL="Next"  HREF="001909.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-767-gd5e4e23</H1>
    <B>David Brownell</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-767-gd5e4e23&In-Reply-To=%3CE1NG5oJ-0004Eh-Jq%40sfp-scmshell-2.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-767-gd5e4e23">dbrownell at users.sourceforge.net
       </A><BR>
    <I>Thu Dec  3 08:09:06 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001907.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-760-gb123fd3
</A></li>
        <LI>Next message: <A HREF="001909.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-771-g879a04c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1908">[ date ]</a>
              <a href="thread.html#1908">[ thread ]</a>
              <a href="subject.html#1908">[ subject ]</a>
              <a href="author.html#1908">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  d5e4e23f9a5b1074cd298d5386e638a9fa78b1ad (commit)
       via  f0c3e7011f9a829b518770247d143b1ac612f0f1 (commit)
       via  62dd15d78f57d56310bb3cb1bfc9b8995cb69668 (commit)
       via  7e18d96d03e39ef55c0b1d420b53247a29fef24b (commit)
       via  6ec5b9c674489b4bd257c41142f100401c8d2025 (commit)
       via  1d29440a9c6a7ceb933a4aa407387cc7d9f8bdb2 (commit)
       via  c2af99d4717837761b6df750e1fe75797c910b23 (commit)
      from  b123fd3cd9a11b2dfb79025fb137696135f5f898 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit d5e4e23f9a5b1074cd298d5386e638a9fa78b1ad
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Wed Dec 2 22:57:08 2009 -0800

    ARM11: don't expose DSCR
    
    Remove the remaining extra copy of DSCR, and the register cache
    of which it was a part.  That cache wasn't a very safe, or even
    necessary, idea; it was essentialy letting debugger-private state
    be manipulated by Tcl code that couldn't know how to do it right.
    
    This makes the &quot;reg&quot; output of an ARM11 resemble what most other
    ARM cores produce ... forward motion in the &quot;make ARM11 work like
    the rest of the ARM cores&quot; Jihad!

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 5bbf465..44c9ad3 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -46,41 +46,8 @@ static uint32_t arm11_vcr = 0;
 static bool arm11_config_step_irq_enable = false;
 static bool arm11_config_hardware_step = false;
 
-enum arm11_regtype
-{
-	/* debug regs */
-	ARM11_REGISTER_DSCR,
-};
-
-
-struct arm11_reg_defs
-{
-	char *					name;
-	uint32_t						num;
-	int						gdb_num;
-	enum arm11_regtype		type;
-};
-
-/* update arm11_regcache_ids when changing this */
-static const struct arm11_reg_defs arm11_reg_defs[] =
-{
-	/* Debug Registers */
-	{&quot;dscr&quot;,	0,	-1,	ARM11_REGISTER_DSCR},
-};
-
-enum arm11_regcache_ids
-{
-	ARM11_RC_DSCR,
-
-	ARM11_RC_MAX,
-};
-
 static int arm11_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints);
-/* helpers */
-static int arm11_build_reg_cache(struct target *target);
-static int arm11_set_reg(struct reg *reg, uint8_t *buf);
-static int arm11_get_reg(struct reg *reg);
 
 
 /** Check and if necessary take control of the system
@@ -127,11 +94,6 @@ static int arm11_check_init(struct arm11_common *arm11)
 	return ERROR_OK;
 }
 
-
-
-#define R(x) \
-	(arm11-&gt;reg_values[ARM11_RC_##x])
-
 /**
  * Save processor state.  This is called after a HALT instruction
  * succeeds, and on other occasions the processor enters debug mode
@@ -148,17 +110,8 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 	/* REVISIT entire cache should already be invalid !!! */
 	register_cache_invalidate(arm11-&gt;arm.core_cache);
 
-	for (size_t i = 0; i &lt; ARRAY_SIZE(arm11-&gt;reg_values); i++)
-	{
-		arm11-&gt;reg_list[i].valid	= 1;
-		arm11-&gt;reg_list[i].dirty	= 0;
-	}
-
 	/* See e.g. ARM1136 TRM, &quot;14.8.4 Entering Debug state&quot; */
 
-	/* Save DSCR */
-	R(DSCR) = arm11-&gt;dscr;
-
 	/* maybe save wDTR (pending DCC write to debug SW, e.g. libdcc) */
 	arm11-&gt;is_wdtr_saved = !!(arm11-&gt;dscr &amp; ARM11_DSCR_WDTR_FULL);
 	if (arm11-&gt;is_wdtr_saved)
@@ -336,11 +289,9 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	register_cache_invalidate(arm11-&gt;arm.core_cache);
 
 	/* restore DSCR */
-
-	arm11_write_DSCR(arm11, R(DSCR));
+	arm11_write_DSCR(arm11, arm11-&gt;dscr);
 
 	/* maybe restore rDTR */
-
 	if (arm11-&gt;is_rdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
@@ -722,9 +673,10 @@ static int arm11_step(struct target *target, int current,
 
 
 		if (arm11_config_step_irq_enable)
-			R(DSCR) &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;		/* should be redundant */
+			/* this disable should be redundant ... */
+			arm11-&gt;dscr &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;
 		else
-			R(DSCR) |= ARM11_DSCR_INTERRUPTS_DISABLE;
+			arm11-&gt;dscr |= ARM11_DSCR_INTERRUPTS_DISABLE;
 
 
 		CHECK_RETVAL(arm11_leave_debug_state(arm11, handle_breakpoints));
@@ -769,8 +721,8 @@ static int arm11_step(struct target *target, int current,
 		/* save state */
 		CHECK_RETVAL(arm11_debug_entry(arm11));
 
-	    /* restore default state */
-		R(DSCR) &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;
+		/* restore default state */
+		arm11-&gt;dscr &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;
 
 	}
 
@@ -1199,12 +1151,7 @@ static int arm11_init_target(struct command_context *cmd_ctx,
 		struct target *target)
 {
 	/* Initialize anything we can set up without talking to the target */
-
-	/* REVISIT do we really want such a debug-registers-only cache?
-	 * If we do, it should probably be handled purely by the DPM code,
-	 * so it works identically on the v7a/v7r cores.
-	 */
-	return arm11_build_reg_cache(target);
+	return ERROR_OK;
 }
 
 /* talk to the target and set things up */
@@ -1309,117 +1256,6 @@ static int arm11_examine(struct target *target)
 }
 
 
-/** Load a register that is marked !valid in the register cache */
-static int arm11_get_reg(struct reg *reg)
-{
-	struct arm11_reg_state *r = reg-&gt;arch_info;
-	struct target *target = r-&gt;target;
-
-	if (target-&gt;state != TARGET_HALTED)
-	{
-		LOG_WARNING(&quot;target was not halted&quot;);
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	/** \todo TODO: Check this. We assume that all registers are fetched at debug entry. */
-
-#if 0
-	struct arm11_common *arm11 = target_to_arm11(target);
-	const struct arm11_reg_defs *arm11_reg_info = arm11_reg_defs + ((struct arm11_reg_state *)reg-&gt;arch_info)-&gt;def_index;
-#endif
-
-	return ERROR_OK;
-}
-
-/** Change a value in the register cache */
-static int arm11_set_reg(struct reg *reg, uint8_t *buf)
-{
-	struct arm11_reg_state *r = reg-&gt;arch_info;
-	struct target *target = r-&gt;target;
-	struct arm11_common *arm11 = target_to_arm11(target);
-//	const struct arm11_reg_defs *arm11_reg_info = arm11_reg_defs + ((struct arm11_reg_state *)reg-&gt;arch_info)-&gt;def_index;
-
-	arm11-&gt;reg_values[((struct arm11_reg_state *)reg-&gt;arch_info)-&gt;def_index] = buf_get_u32(buf, 0, 32);
-	reg-&gt;valid	= 1;
-	reg-&gt;dirty	= 1;
-
-	return ERROR_OK;
-}
-
-static const struct reg_arch_type arm11_reg_type = {
-	.get = arm11_get_reg,
-	.set = arm11_set_reg,
-};
-
-static int arm11_build_reg_cache(struct target *target)
-{
-	struct arm11_common *arm11 = target_to_arm11(target);
-	struct reg_cache *cache;
-	struct reg *reg_list;
-	struct arm11_reg_state *arm11_reg_states;
-
-	cache = calloc(1, sizeof *cache);
-	reg_list = calloc(ARM11_REGCACHE_COUNT, sizeof *reg_list);
-	arm11_reg_states = calloc(ARM11_REGCACHE_COUNT,
-			sizeof *arm11_reg_states);
-	if (!cache || !reg_list || !arm11_reg_states) {
-		free(cache);
-		free(reg_list);
-		free(arm11_reg_states);
-		return ERROR_FAIL;
-	}
-
-	arm11-&gt;reg_list	= reg_list;
-
-	/* build cache for some of the debug registers */
-	cache-&gt;name = &quot;arm11 debug registers&quot;;
-	cache-&gt;reg_list	= reg_list;
-	cache-&gt;num_regs	= ARM11_REGCACHE_COUNT;
-
-	struct reg_cache **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
-	(*cache_p) = cache;
-
-	arm11-&gt;core_cache = cache;
-
-	size_t i;
-
-	/* Not very elegant assertion */
-	if (ARM11_REGCACHE_COUNT != ARRAY_SIZE(arm11-&gt;reg_values) ||
-		ARM11_REGCACHE_COUNT != ARRAY_SIZE(arm11_reg_defs) ||
-		ARM11_REGCACHE_COUNT != ARM11_RC_MAX)
-	{
-		LOG_ERROR(&quot;BUG: arm11-&gt;reg_values inconsistent (%d %u %u %d)&quot;,
-				ARM11_REGCACHE_COUNT,
-				(unsigned) ARRAY_SIZE(arm11-&gt;reg_values),
-				(unsigned) ARRAY_SIZE(arm11_reg_defs),
-				ARM11_RC_MAX);
-		/* FIXME minimally, use a build_bug_on(X) mechanism;
-		 * runtime exit() here is bad!
-		 */
-		exit(-1);
-	}
-
-	for (i = 0; i &lt; ARM11_REGCACHE_COUNT; i++)
-	{
-		struct reg *						r	= reg_list			+ i;
-		const struct arm11_reg_defs *	rd	= arm11_reg_defs	+ i;
-		struct arm11_reg_state *			rs	= arm11_reg_states	+ i;
-
-		r-&gt;name				= rd-&gt;name;
-		r-&gt;size				= 32;
-		r-&gt;value			= (uint8_t *)(arm11-&gt;reg_values + i);
-		r-&gt;dirty			= 0;
-		r-&gt;valid			= 0;
-		r-&gt;type = &amp;arm11_reg_type;
-		r-&gt;arch_info		= rs;
-
-		rs-&gt;def_index		= i;
-		rs-&gt;target			= target;
-	}
-
-	return ERROR_OK;
-}
-
 /* FIXME all these BOOL_WRAPPER things should be modifying
  * per-instance state, not shared state; ditto the vector
  * catch register support.  Scan chains with multiple cores
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 1cc09e1..cd52896 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -26,8 +26,6 @@
 #include &quot;armv4_5.h&quot;
 #include &quot;arm_dpm.h&quot;
 
-#define ARM11_REGCACHE_COUNT		1
-
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
 #define CHECK_RETVAL(action)			\
@@ -69,18 +67,6 @@ struct arm11_common
 
 	bool	simulate_reset_on_next_halt;	/**&lt; Perform cleanups of the ARM state on next halt */
 
-	/** \name Shadow registers to save debug state */
-	/*@{*/
-
-	struct reg *	reg_list;							/**&lt; target register list */
-	uint32_t		reg_values[ARM11_REGCACHE_COUNT];	/**&lt; data for registers */
-
-	/*@}*/
-
-
-	// GA
-	struct reg_cache *core_cache;
-
 	struct arm_jtag jtag_info;
 };
 

commit f0c3e7011f9a829b518770247d143b1ac612f0f1
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Wed Dec 2 22:57:08 2009 -0800

    ARM11: store a clean copy of DSCR
    
    Just store a clean copy of DSCR in the per-CPU struct, so we
    trivially pass a pointer to a recent copy.  This replaces the
    previous &quot;last_dscr&quot; and cleans up most of the related calling
    conventions ... but it doesn't remove the other DSCR copy.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 6080086..5bbf465 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -86,33 +86,24 @@ static int arm11_get_reg(struct reg *reg);
 /** Check and if necessary take control of the system
  *
  * \param arm11		Target state variable.
- * \param dscr		If the current DSCR content is
- *					available a pointer to a word holding the
- *					DSCR can be passed. Otherwise use NULL.
  */
-static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
+static int arm11_check_init(struct arm11_common *arm11)
 {
-	uint32_t			dscr_local_tmp_copy;
+	CHECK_RETVAL(arm11_read_DSCR(arm11));
+	LOG_DEBUG(&quot;DSCR %08x&quot;, (unsigned) arm11-&gt;dscr);
 
-	if (!dscr)
-	{
-		dscr = &amp;dscr_local_tmp_copy;
-
-		CHECK_RETVAL(arm11_read_DSCR(arm11, dscr));
-	}
-
-	if (!(*dscr &amp; ARM11_DSCR_MODE_SELECT))
+	if (!(arm11-&gt;dscr &amp; ARM11_DSCR_MODE_SELECT))
 	{
 		LOG_DEBUG(&quot;Bringing target into debug mode&quot;);
 
-		*dscr |= ARM11_DSCR_MODE_SELECT;		/* Halt debug-mode */
-		arm11_write_DSCR(arm11, *dscr);
+		arm11-&gt;dscr |= ARM11_DSCR_MODE_SELECT;		/* Halt debug-mode */
+		arm11_write_DSCR(arm11, arm11-&gt;dscr);
 
 		/* add further reset initialization here */
 
 		arm11-&gt;simulate_reset_on_next_halt = true;
 
-		if (*dscr &amp; ARM11_DSCR_CORE_HALTED)
+		if (arm11-&gt;dscr &amp; ARM11_DSCR_CORE_HALTED)
 		{
 			/** \todo TODO: this needs further scrutiny because
 			  * arm11_debug_entry() never gets called.  (WHY NOT?)
@@ -122,7 +113,7 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 
 			arm11-&gt;arm.target-&gt;state = TARGET_HALTED;
 			arm11-&gt;arm.target-&gt;debug_reason =
-					arm11_get_DSCR_debug_reason(*dscr);
+					arm11_get_DSCR_debug_reason(arm11-&gt;dscr);
 		}
 		else
 		{
@@ -144,14 +135,15 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 /**
  * Save processor state.  This is called after a HALT instruction
  * succeeds, and on other occasions the processor enters debug mode
- * (breakpoint, watchpoint, etc).
+ * (breakpoint, watchpoint, etc).  Caller has updated arm11-&gt;dscr.
  */
-static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
+static int arm11_debug_entry(struct arm11_common *arm11)
 {
 	int retval;
 
 	arm11-&gt;arm.target-&gt;state = TARGET_HALTED;
-	arm11-&gt;arm.target-&gt;debug_reason = arm11_get_DSCR_debug_reason(dscr);
+	arm11-&gt;arm.target-&gt;debug_reason =
+			arm11_get_DSCR_debug_reason(arm11-&gt;dscr);
 
 	/* REVISIT entire cache should already be invalid !!! */
 	register_cache_invalidate(arm11-&gt;arm.core_cache);
@@ -165,10 +157,10 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	/* See e.g. ARM1136 TRM, &quot;14.8.4 Entering Debug state&quot; */
 
 	/* Save DSCR */
-	R(DSCR) = dscr;
+	R(DSCR) = arm11-&gt;dscr;
 
-	/* Save wDTR */
-	arm11-&gt;is_wdtr_saved = !!(dscr &amp; ARM11_DSCR_WDTR_FULL);
+	/* maybe save wDTR (pending DCC write to debug SW, e.g. libdcc) */
+	arm11-&gt;is_wdtr_saved = !!(arm11-&gt;dscr &amp; ARM11_DSCR_WDTR_FULL);
 	if (arm11-&gt;is_wdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
@@ -183,6 +175,7 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 2);
 
 		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
+
 	}
 
 	/* DSCR: set ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
@@ -191,11 +184,9 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	 * but not to issue ITRs. ARM1136 seems to require this to issue
 	 * ITR's as well...
 	 */
-	uint32_t new_dscr = dscr | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
 
-	/* this executes JTAG queue: */
-
-	arm11_write_DSCR(arm11, new_dscr);
+	arm11_write_DSCR(arm11, ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
+				| arm11-&gt;dscr);
 
 
 	/* From the spec:
@@ -243,8 +234,8 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	if (retval != ERROR_OK)
 		return retval;
 
-	/* maybe save rDTR */
-	arm11-&gt;is_rdtr_saved = !!(dscr &amp; ARM11_DSCR_RDTR_FULL);
+	/* maybe save rDTR (pending DCC read from debug SW, e.g. libdcc) */
+	arm11-&gt;is_rdtr_saved = !!(arm11-&gt;dscr &amp; ARM11_DSCR_RDTR_FULL);
 	if (arm11-&gt;is_rdtr_saved)
 	{
 		/* MRC p14,0,R0,c0,c5,0 (move rDTR -&gt; r0 (-&gt; wDTR -&gt; local var)) */
@@ -302,11 +293,9 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	/* spec says clear wDTR and rDTR; we assume they are clear as
 	   otherwise our programming would be sloppy */
 	{
-		uint32_t DSCR;
-
-		CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;DSCR));
+		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		if (DSCR &amp; (ARM11_DSCR_RDTR_FULL | ARM11_DSCR_WDTR_FULL))
+		if (arm11-&gt;dscr &amp; (ARM11_DSCR_RDTR_FULL | ARM11_DSCR_WDTR_FULL))
 		{
 			/*
 			The wDTR/rDTR two registers that are used to send/receive data to/from
@@ -315,7 +304,8 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 			registers hold data that was written by one side (CPU or JTAG) and not
 			read out by the other side.
 			*/
-			LOG_ERROR(&quot;wDTR/rDTR inconsistent (DSCR %08&quot; PRIx32 &quot;)&quot;, DSCR);
+			LOG_ERROR(&quot;wDTR/rDTR inconsistent (DSCR %08x)&quot;,
+					(unsigned) arm11-&gt;dscr);
 			return ERROR_FAIL;
 		}
 	}
@@ -380,22 +370,17 @@ static int arm11_poll(struct target *target)
 {
 	int retval;
 	struct arm11_common *arm11 = target_to_arm11(target);
-	uint32_t	dscr;
-
-	CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
 
-	LOG_DEBUG(&quot;DSCR %08&quot; PRIx32 &quot;&quot;, dscr);
+	CHECK_RETVAL(arm11_check_init(arm11));
 
-	CHECK_RETVAL(arm11_check_init(arm11, &amp;dscr));
-
-	if (dscr &amp; ARM11_DSCR_CORE_HALTED)
+	if (arm11-&gt;dscr &amp; ARM11_DSCR_CORE_HALTED)
 	{
 		if (target-&gt;state != TARGET_HALTED)
 		{
 			enum target_state old_state = target-&gt;state;
 
 			LOG_DEBUG(&quot;enter TARGET_HALTED&quot;);
-			retval = arm11_debug_entry(arm11, dscr);
+			retval = arm11_debug_entry(arm11);
 			if (retval != ERROR_OK)
 				return retval;
 
@@ -459,14 +444,13 @@ static int arm11_halt(struct target *target)
 
 	CHECK_RETVAL(jtag_execute_queue());
 
-	uint32_t dscr;
 	int i = 0;
 
 	while (1)
 	{
-		CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
+		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		if (dscr &amp; ARM11_DSCR_CORE_HALTED)
+		if (arm11-&gt;dscr &amp; ARM11_DSCR_CORE_HALTED)
 			break;
 
 
@@ -488,7 +472,7 @@ static int arm11_halt(struct target *target)
 
 	enum target_state old_state	= target-&gt;state;
 
-	arm11_debug_entry(arm11, dscr);
+	arm11_debug_entry(arm11);
 
 	CHECK_RETVAL(
 		target_call_event_callbacks(target,
@@ -590,13 +574,11 @@ static int arm11_resume(struct target *target, int current,
 	int i = 0;
 	while (1)
 	{
-		uint32_t dscr;
-
-		CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
+		CHECK_RETVAL(arm11_read_DSCR(arm11));
 
-		LOG_DEBUG(&quot;DSCR %08&quot; PRIx32 &quot;&quot;, dscr);
+		LOG_DEBUG(&quot;DSCR %08x&quot;, (unsigned) arm11-&gt;dscr);
 
-		if (dscr &amp; ARM11_DSCR_CORE_RESTARTED)
+		if (arm11-&gt;dscr &amp; ARM11_DSCR_CORE_RESTARTED)
 			break;
 
 
@@ -753,16 +735,16 @@ static int arm11_step(struct target *target, int current,
 
 		/* wait for halt */
 		int i = 0;
-		uint32_t dscr;
 
 		while (1)
 		{
-			CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
+			const uint32_t mask = ARM11_DSCR_CORE_RESTARTED
+					| ARM11_DSCR_CORE_HALTED;
 
-			LOG_DEBUG(&quot;DSCR %08&quot; PRIx32 &quot;e&quot;, dscr);
+			CHECK_RETVAL(arm11_read_DSCR(arm11));
+			LOG_DEBUG(&quot;DSCR %08x e&quot;, (unsigned) arm11-&gt;dscr);
 
-			if ((dscr &amp; (ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED)) ==
-				(ARM11_DSCR_CORE_RESTARTED | ARM11_DSCR_CORE_HALTED))
+			if ((arm11-&gt;dscr &amp; mask) == mask)
 				break;
 
 			long long then = 0;
@@ -785,7 +767,7 @@ static int arm11_step(struct target *target, int current,
 		arm11_sc7_clear_vbw(arm11);
 
 		/* save state */
-		CHECK_RETVAL(arm11_debug_entry(arm11, dscr));
+		CHECK_RETVAL(arm11_debug_entry(arm11));
 
 	    /* restore default state */
 		R(DSCR) &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;
@@ -804,7 +786,7 @@ static int arm11_assert_reset(struct target *target)
 	int retval;
 	struct arm11_common *arm11 = target_to_arm11(target);
 
-	retval = arm11_check_init(arm11, NULL);
+	retval = arm11_check_init(arm11);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1303,7 +1285,7 @@ static int arm11_examine(struct target *target)
 	 * as suggested by the spec.
 	 */
 
-	retval = arm11_check_init(arm11, NULL);
+	retval = arm11_check_init(arm11);
 	if (retval != ERROR_OK)
 		return retval;
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index 56feb2e..1cc09e1 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -59,8 +59,7 @@ struct arm11_common
 	size_t	wrp;			/**&lt; Number of Watchpoint Register Pairs from DIDR	*/
 	size_t	free_brps;		/**&lt; Number of breakpoints allocated */
 
-	uint32_t		last_dscr;		/**&lt; Last retrieved DSCR value;
-							     Use only for debug message generation		*/
+	uint32_t dscr;			/**&lt; Last retrieved DSCR value. */
 
 	uint32_t saved_rdtr;
 	uint32_t saved_wdtr;
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 7fd5e3a..7e1e9cb 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -214,19 +214,20 @@ static void arm11_add_debug_INST(struct arm11_common * arm11,
 	arm11_add_dr_scan_vc(ARRAY_SIZE(itr), itr, state == ARM11_TAP_DEFAULT ? TAP_IDLE : state);
 }
 
-/** Read the Debug Status and Control Register (DSCR)
- *
- * same as CP14 c1
+/**
+ * Read and save the Debug Status and Control Register (DSCR).
  *
  * \param arm11		Target state variable.
- * \param value		DSCR content
- * \return			Error status
+ * \return Error status; arm11-&gt;dscr is updated on success.
  *
- * \remarks			This is a stand-alone function that executes the JTAG command queue.
+ * \remarks This is a stand-alone function that executes the JTAG
+ * command queue.  It does not require the ARM11 debug TAP to be
+ * in any particular state.
  */
-int arm11_read_DSCR(struct arm11_common * arm11, uint32_t *value)
+int arm11_read_DSCR(struct arm11_common *arm11)
 {
 	int retval;
+
 	retval = arm11_add_debug_SCAN_N(arm11, 0x01, ARM11_TAP_DEFAULT);
 	if (retval != ERROR_OK)
 		return retval;
@@ -242,14 +243,12 @@ int arm11_read_DSCR(struct arm11_common * arm11, uint32_t *value)
 
 	CHECK_RETVAL(jtag_execute_queue());
 
-	if (arm11-&gt;last_dscr != dscr)
+	if (arm11-&gt;dscr != dscr)
 		JTAG_DEBUG(&quot;DSCR  = %08x (OLD %08x)&quot;,
 				(unsigned) dscr,
-				(unsigned) arm11-&gt;last_dscr);
-
-	arm11-&gt;last_dscr = dscr;
+				(unsigned) arm11-&gt;dscr);
 
-	*value = dscr;
+	arm11-&gt;dscr = dscr;
 
 	return ERROR_OK;
 }
@@ -282,9 +281,9 @@ int arm11_write_DSCR(struct arm11_common * arm11, uint32_t dscr)
 
 	JTAG_DEBUG(&quot;DSCR &lt;= %08x (OLD %08x)&quot;,
 			(unsigned) dscr,
-			(unsigned) arm11-&gt;last_dscr);
+			(unsigned) arm11-&gt;dscr);
 
-	arm11-&gt;last_dscr = dscr;
+	arm11-&gt;dscr = dscr;
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 2203361..fa19744 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -11,7 +11,7 @@ void arm11_add_IR(struct arm11_common *arm11,
 		uint8_t instr, tap_state_t state);
 int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 		uint8_t chain, tap_state_t state);
-int arm11_read_DSCR(struct arm11_common *arm11, uint32_t *dscr);
+int arm11_read_DSCR(struct arm11_common *arm11);
 int arm11_write_DSCR(struct arm11_common *arm11, uint32_t dscr);
 
 enum target_debug_reason arm11_get_DSCR_debug_reason(uint32_t dscr);

commit 62dd15d78f57d56310bb3cb1bfc9b8995cb69668
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: don't expose WDTR
    
    Don't expose the WDTR register through the register cache any
    more.  If anyone wants Tcl scripts to be able to use DCC based
    communication with app code in the target, this wouldn't do it.
    
    Bugfix:  don't trust the Tcl-accessible version of DSCR to
    flag whether WDTR needs to be restored when resuming.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index d08911e..6080086 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -50,7 +50,6 @@ enum arm11_regtype
 {
 	/* debug regs */
 	ARM11_REGISTER_DSCR,
-	ARM11_REGISTER_WDTR,
 };
 
 
@@ -67,13 +66,11 @@ static const struct arm11_reg_defs arm11_reg_defs[] =
 {
 	/* Debug Registers */
 	{&quot;dscr&quot;,	0,	-1,	ARM11_REGISTER_DSCR},
-	{&quot;wdtr&quot;,	0,	-1,	ARM11_REGISTER_WDTR},
 };
 
 enum arm11_regcache_ids
 {
 	ARM11_RC_DSCR,
-	ARM11_RC_WDTR,
 
 	ARM11_RC_MAX,
 };
@@ -171,8 +168,8 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 	R(DSCR) = dscr;
 
 	/* Save wDTR */
-
-	if (dscr &amp; ARM11_DSCR_WDTR_FULL)
+	arm11-&gt;is_wdtr_saved = !!(dscr &amp; ARM11_DSCR_WDTR_FULL);
+	if (arm11-&gt;is_wdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
@@ -180,17 +177,13 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 
 		struct scan_field	chain5_fields[3];
 
-		arm11_setup_field(arm11, 32, NULL, &amp;R(WDTR),	chain5_fields + 0);
+		arm11_setup_field(arm11, 32, NULL,
+				&amp;arm11-&gt;saved_wdtr, chain5_fields + 0);
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 1);
 		arm11_setup_field(arm11,  1, NULL, NULL,		chain5_fields + 2);
 
 		arm11_add_dr_scan_vc(ARRAY_SIZE(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
-	else
-	{
-		arm11-&gt;reg_list[ARM11_RC_WDTR].valid	= 0;
-	}
-
 
 	/* DSCR: set ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE
 	 *
@@ -328,14 +321,15 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 	}
 
 	/* maybe restore original wDTR */
-	if ((R(DSCR) &amp; ARM11_DSCR_WDTR_FULL) || arm11-&gt;reg_list[ARM11_RC_WDTR].dirty)
+	if (arm11-&gt;is_wdtr_saved)
 	{
 		retval = arm11_run_instr_data_prepare(arm11);
 		if (retval != ERROR_OK)
 			return retval;
 
 		/* MCR p14,0,R0,c0,c5,0 */
-		retval = arm11_run_instr_data_to_core_via_r0(arm11, 0xee000e15, R(WDTR));
+		retval = arm11_run_instr_data_to_core_via_r0(arm11,
+				0xee000e15, arm11-&gt;saved_wdtr);
 		if (retval != ERROR_OK)
 			return retval;
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index cde6c78..56feb2e 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -26,7 +26,7 @@
 #include &quot;armv4_5.h&quot;
 #include &quot;arm_dpm.h&quot;
 
-#define ARM11_REGCACHE_COUNT		2
+#define ARM11_REGCACHE_COUNT		1
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
@@ -63,8 +63,11 @@ struct arm11_common
 							     Use only for debug message generation		*/
 
 	uint32_t saved_rdtr;
+	uint32_t saved_wdtr;
 
 	bool is_rdtr_saved;
+	bool is_wdtr_saved;
+
 	bool	simulate_reset_on_next_halt;	/**&lt; Perform cleanups of the ARM state on next halt */
 
 	/** \name Shadow registers to save debug state */

commit 7e18d96d03e39ef55c0b1d420b53247a29fef24b
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: don't expose RDTR
    
    Don't expose the RDTR register through the register cache any
    more.  If anyone wants Tcl scripts to be able to use DCC based
    communication with app code in the target, this wouldn't do it.
    
    Bugfix:  don't trust the Tcl-accessible version of DSCR to
    flag whether RDTR needs to be restored when resuming.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 65ec47f..d08911e 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -51,7 +51,6 @@ enum arm11_regtype
 	/* debug regs */
 	ARM11_REGISTER_DSCR,
 	ARM11_REGISTER_WDTR,
-	ARM11_REGISTER_RDTR,
 };
 
 
@@ -69,14 +68,12 @@ static const struct arm11_reg_defs arm11_reg_defs[] =
 	/* Debug Registers */
 	{&quot;dscr&quot;,	0,	-1,	ARM11_REGISTER_DSCR},
 	{&quot;wdtr&quot;,	0,	-1,	ARM11_REGISTER_WDTR},
-	{&quot;rdtr&quot;,	0,	-1,	ARM11_REGISTER_RDTR},
 };
 
 enum arm11_regcache_ids
 {
 	ARM11_RC_DSCR,
 	ARM11_RC_WDTR,
-	ARM11_RC_RDTR,
 
 	ARM11_RC_MAX,
 };
@@ -254,20 +251,15 @@ static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 		return retval;
 
 	/* maybe save rDTR */
-
-	/* check rDTRfull in DSCR */
-
-	if (dscr &amp; ARM11_DSCR_RDTR_FULL)
+	arm11-&gt;is_rdtr_saved = !!(dscr &amp; ARM11_DSCR_RDTR_FULL);
+	if (arm11-&gt;is_rdtr_saved)
 	{
 		/* MRC p14,0,R0,c0,c5,0 (move rDTR -&gt; r0 (-&gt; wDTR -&gt; local var)) */
-		retval = arm11_run_instr_data_from_core_via_r0(arm11, 0xEE100E15, &amp;R(RDTR));
+		retval = arm11_run_instr_data_from_core_via_r0(arm11,
+				0xEE100E15, &amp;arm11-&gt;saved_rdtr);
 		if (retval != ERROR_OK)
 			return retval;
 	}
-	else
-	{
-		arm11-&gt;reg_list[ARM11_RC_RDTR].valid	= 0;
-	}
 
 	/* REVISIT Now that we've saved core state, there's may also
 	 * be MMU and cache state to care about ...
@@ -365,7 +357,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 
 	/* maybe restore rDTR */
 
-	if (R(DSCR) &amp; ARM11_DSCR_RDTR_FULL || arm11-&gt;reg_list[ARM11_RC_RDTR].dirty)
+	if (arm11-&gt;is_rdtr_saved)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
@@ -376,7 +368,8 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 		uint8_t			Ready		= 0;	/* ignored */
 		uint8_t			Valid		= 0;	/* ignored */
 
-		arm11_setup_field(arm11, 32, &amp;R(RDTR),	NULL, chain5_fields + 0);
+		arm11_setup_field(arm11, 32, &amp;arm11-&gt;saved_rdtr,
+				NULL, chain5_fields + 0);
 		arm11_setup_field(arm11,  1, &amp;Ready,	NULL, chain5_fields + 1);
 		arm11_setup_field(arm11,  1, &amp;Valid,	NULL, chain5_fields + 2);
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index e5c92de..cde6c78 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -26,7 +26,7 @@
 #include &quot;armv4_5.h&quot;
 #include &quot;arm_dpm.h&quot;
 
-#define ARM11_REGCACHE_COUNT		3
+#define ARM11_REGCACHE_COUNT		2
 
 #define ARM11_TAP_DEFAULT			TAP_INVALID
 
@@ -62,6 +62,9 @@ struct arm11_common
 	uint32_t		last_dscr;		/**&lt; Last retrieved DSCR value;
 							     Use only for debug message generation		*/
 
+	uint32_t saved_rdtr;
+
+	bool is_rdtr_saved;
 	bool	simulate_reset_on_next_halt;	/**&lt; Perform cleanups of the ARM state on next halt */
 
 	/** \name Shadow registers to save debug state */

commit 6ec5b9c674489b4bd257c41142f100401c8d2025
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: streamline debug entry
    
    Streamline arm11_on_enter_debug_state() entry:
    
     - It should handle the standard updates:
        * target-&gt;debug_reason
        * target-&gt;state
    
     - Don't waste time re-reading DSCR; just pass it in
    
    Also rename the routine to &quot;arm11_debug_entry()&quot;, matching the
    convention used elsewhere in OpenOCD.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 1a3e979..65ec47f 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -81,7 +81,6 @@ enum arm11_regcache_ids
 	ARM11_RC_MAX,
 };
 
-static int arm11_on_enter_debug_state(struct arm11_common *arm11);
 static int arm11_step(struct target *target, int current,
 		uint32_t address, int handle_breakpoints);
 /* helpers */
@@ -122,7 +121,7 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 		if (*dscr &amp; ARM11_DSCR_CORE_HALTED)
 		{
 			/** \todo TODO: this needs further scrutiny because
-			  * arm11_on_enter_debug_state() never gets properly called.
+			  * arm11_debug_entry() never gets called.  (WHY NOT?)
 			  * As a result we don't read the actual register states from
 			  * the target.
 			  */
@@ -148,16 +147,18 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 #define R(x) \
 	(arm11-&gt;reg_values[ARM11_RC_##x])
 
-/** Save processor state.
-  *
-  * This is called when the HALT instruction has succeeded
-  * or on other occasions that stop the processor.
-  *
-  */
-static int arm11_on_enter_debug_state(struct arm11_common *arm11)
+/**
+ * Save processor state.  This is called after a HALT instruction
+ * succeeds, and on other occasions the processor enters debug mode
+ * (breakpoint, watchpoint, etc).
+ */
+static int arm11_debug_entry(struct arm11_common *arm11, uint32_t dscr)
 {
 	int retval;
 
+	arm11-&gt;arm.target-&gt;state = TARGET_HALTED;
+	arm11-&gt;arm.target-&gt;debug_reason = arm11_get_DSCR_debug_reason(dscr);
+
 	/* REVISIT entire cache should already be invalid !!! */
 	register_cache_invalidate(arm11-&gt;arm.core_cache);
 
@@ -170,11 +171,11 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 	/* See e.g. ARM1136 TRM, &quot;14.8.4 Entering Debug state&quot; */
 
 	/* Save DSCR */
-	CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;R(DSCR)));
+	R(DSCR) = dscr;
 
 	/* Save wDTR */
 
-	if (R(DSCR) &amp; ARM11_DSCR_WDTR_FULL)
+	if (dscr &amp; ARM11_DSCR_WDTR_FULL)
 	{
 		arm11_add_debug_SCAN_N(arm11, 0x05, ARM11_TAP_DEFAULT);
 
@@ -200,7 +201,7 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 	 * but not to issue ITRs. ARM1136 seems to require this to issue
 	 * ITR's as well...
 	 */
-	uint32_t new_dscr = R(DSCR) | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
+	uint32_t new_dscr = dscr | ARM11_DSCR_EXECUTE_ARM_INSTRUCTION_ENABLE;
 
 	/* this executes JTAG queue: */
 
@@ -256,7 +257,7 @@ static int arm11_on_enter_debug_state(struct arm11_common *arm11)
 
 	/* check rDTRfull in DSCR */
 
-	if (R(DSCR) &amp; ARM11_DSCR_RDTR_FULL)
+	if (dscr &amp; ARM11_DSCR_RDTR_FULL)
 	{
 		/* MRC p14,0,R0,c0,c5,0 (move rDTR -&gt; r0 (-&gt; wDTR -&gt; local var)) */
 		retval = arm11_run_instr_data_from_core_via_r0(arm11, 0xEE100E15, &amp;R(RDTR));
@@ -407,9 +408,7 @@ static int arm11_poll(struct target *target)
 			enum target_state old_state = target-&gt;state;
 
 			LOG_DEBUG(&quot;enter TARGET_HALTED&quot;);
-			target-&gt;state			= TARGET_HALTED;
-			target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(dscr);
-			retval = arm11_on_enter_debug_state(arm11);
+			retval = arm11_debug_entry(arm11, dscr);
 			if (retval != ERROR_OK)
 				return retval;
 
@@ -474,8 +473,8 @@ static int arm11_halt(struct target *target)
 	CHECK_RETVAL(jtag_execute_queue());
 
 	uint32_t dscr;
-
 	int i = 0;
+
 	while (1)
 	{
 		CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
@@ -500,12 +499,9 @@ static int arm11_halt(struct target *target)
 		i++;
 	}
 
-	arm11_on_enter_debug_state(arm11);
-
 	enum target_state old_state	= target-&gt;state;
 
-	target-&gt;state		= TARGET_HALTED;
-	target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(dscr);
+	arm11_debug_entry(arm11, dscr);
 
 	CHECK_RETVAL(
 		target_call_event_callbacks(target,
@@ -770,10 +766,10 @@ static int arm11_step(struct target *target, int current,
 
 		/* wait for halt */
 		int i = 0;
+		uint32_t dscr;
+
 		while (1)
 		{
-			uint32_t dscr;
-
 			CHECK_RETVAL(arm11_read_DSCR(arm11, &amp;dscr));
 
 			LOG_DEBUG(&quot;DSCR %08&quot; PRIx32 &quot;e&quot;, dscr);
@@ -802,14 +798,13 @@ static int arm11_step(struct target *target, int current,
 		arm11_sc7_clear_vbw(arm11);
 
 		/* save state */
-		CHECK_RETVAL(arm11_on_enter_debug_state(arm11));
+		CHECK_RETVAL(arm11_debug_entry(arm11, dscr));
 
 	    /* restore default state */
 		R(DSCR) &amp;= ~ARM11_DSCR_INTERRUPTS_DISABLE;
 
 	}
 
-	//	  target-&gt;state		= TARGET_HALTED;
 	target-&gt;debug_reason	= DBG_REASON_SINGLESTEP;
 
 	CHECK_RETVAL(target_call_event_callbacks(target, TARGET_EVENT_HALTED));

commit 1d29440a9c6a7ceb933a4aa407387cc7d9f8bdb2
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM11: remove arm11-&gt;target
    
    Don't need/want arm11-&gt;target; we have arm11-&gt;arm.target instead.
    Also remove some unused watchpoint stuff.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 5053414..1a3e979 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -127,13 +127,14 @@ static int arm11_check_init(struct arm11_common *arm11, uint32_t *dscr)
 			  * the target.
 			  */
 
-			arm11-&gt;target-&gt;state	= TARGET_HALTED;
-			arm11-&gt;target-&gt;debug_reason	= arm11_get_DSCR_debug_reason(*dscr);
+			arm11-&gt;arm.target-&gt;state = TARGET_HALTED;
+			arm11-&gt;arm.target-&gt;debug_reason =
+					arm11_get_DSCR_debug_reason(*dscr);
 		}
 		else
 		{
-			arm11-&gt;target-&gt;state	= TARGET_RUNNING;
-			arm11-&gt;target-&gt;debug_reason	= DBG_REASON_NOTHALTED;
+			arm11-&gt;arm.target-&gt;state = TARGET_RUNNING;
+			arm11-&gt;arm.target-&gt;debug_reason = DBG_REASON_NOTHALTED;
 		}
 
 		arm11_sc7_clear_vbw(arm11);
@@ -1221,8 +1222,6 @@ static int arm11_target_create(struct target *target, Jim_Interp *interp)
 
 	armv4_5_init_arch_info(target, &amp;arm11-&gt;arm);
 
-	arm11-&gt;target = target;
-
 	arm11-&gt;jtag_info.tap = target-&gt;tap;
 	arm11-&gt;jtag_info.scann_size = 5;
 	arm11-&gt;jtag_info.scann_instr = ARM11_SCAN_N;
@@ -1313,7 +1312,6 @@ static int arm11_examine(struct target *target)
 
 	/** \todo TODO: reserve one brp slot if we allow breakpoints during step */
 	arm11-&gt;free_brps = arm11-&gt;brp;
-	arm11-&gt;free_wrps = arm11-&gt;wrp;
 
 	LOG_DEBUG(&quot;IDCODE %08&quot; PRIx32 &quot; IMPLEMENTOR %02x DIDR %08&quot; PRIx32,
 			device_id, implementor, didr);
@@ -1350,7 +1348,8 @@ static int arm11_examine(struct target *target)
 /** Load a register that is marked !valid in the register cache */
 static int arm11_get_reg(struct reg *reg)
 {
-	struct target * target = ((struct arm11_reg_state *)reg-&gt;arch_info)-&gt;target;
+	struct arm11_reg_state *r = reg-&gt;arch_info;
+	struct target *target = r-&gt;target;
 
 	if (target-&gt;state != TARGET_HALTED)
 	{
@@ -1371,7 +1370,8 @@ static int arm11_get_reg(struct reg *reg)
 /** Change a value in the register cache */
 static int arm11_set_reg(struct reg *reg, uint8_t *buf)
 {
-	struct target *target = ((struct arm11_reg_state *)reg-&gt;arch_info)-&gt;target;
+	struct arm11_reg_state *r = reg-&gt;arch_info;
+	struct target *target = r-&gt;target;
 	struct arm11_common *arm11 = target_to_arm11(target);
 //	const struct arm11_reg_defs *arm11_reg_info = arm11_reg_defs + ((struct arm11_reg_state *)reg-&gt;arch_info)-&gt;def_index;
 
diff --git a/src/target/arm11.h b/src/target/arm11.h
index c3f4e86..e5c92de 100644
--- a/src/target/arm11.h
+++ b/src/target/arm11.h
@@ -51,18 +51,13 @@ enum arm11_debug_version
 struct arm11_common
 {
 	struct arm	arm;
-	struct target *	target;		/**&lt; Reference back to the owner */
 
 	/** Debug module state. */
 	struct arm_dpm dpm;
 
-	/** \name Processor type detection */
-	/*@{*/
-
 	size_t	brp;			/**&lt; Number of Breakpoint Register Pairs from DIDR	*/
 	size_t	wrp;			/**&lt; Number of Watchpoint Register Pairs from DIDR	*/
-
-	/*@}*/
+	size_t	free_brps;		/**&lt; Number of breakpoints allocated */
 
 	uint32_t		last_dscr;		/**&lt; Last retrieved DSCR value;
 							     Use only for debug message generation		*/
@@ -77,8 +72,6 @@ struct arm11_common
 
 	/*@}*/
 
-	size_t	free_brps;				/**&lt; keep track of breakpoints allocated by arm11_add_breakpoint() */
-	size_t	free_wrps;				/**&lt; keep track of breakpoints allocated by arm11_add_watchpoint() */
 
 	// GA
 	struct reg_cache *core_cache;
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 6ce308e..7fd5e3a 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -85,7 +85,7 @@ int arm11_add_dr_scan_vc(int num_fields, struct scan_field *fields, tap_state_t
  */
 void arm11_setup_field(struct arm11_common * arm11, int num_bits, void * out_data, void * in_data, struct scan_field * field)
 {
-	field-&gt;tap   			= arm11-&gt;target-&gt;tap;
+	field-&gt;tap			= arm11-&gt;arm.target-&gt;tap;
 	field-&gt;num_bits			= num_bits;
 	field-&gt;out_value		= out_data;
 	field-&gt;in_value			= in_data;
@@ -102,8 +102,7 @@ void arm11_setup_field(struct arm11_common * arm11, int num_bits, void * out_dat
  */
 void arm11_add_IR(struct arm11_common * arm11, uint8_t instr, tap_state_t state)
 {
-	struct jtag_tap *tap;
-	tap = arm11-&gt;target-&gt;tap;
+	struct jtag_tap *tap = arm11-&gt;arm.target-&gt;tap;
 
 	if (buf_get_u32(tap-&gt;cur_instr, 0, 5) == instr)
 	{

commit c2af99d4717837761b6df750e1fe75797c910b23
Author: David Brownell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dbrownell at users.sourceforge.net</A>&gt;
Date:   Wed Dec 2 22:57:07 2009 -0800

    ARM DPM: tweak initialization
    
    Move the initial breakpoint/watchpoint disable calls to
    arm_dpm_initialize(), and start using that routine.  This
    split helps with arm11 support.

diff --git a/src/target/arm11.c b/src/target/arm11.c
index 605e741..5053414 100644
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -1330,10 +1330,8 @@ static int arm11_examine(struct target *target)
 	/* Build register cache &quot;late&quot;, after target_init(), since we
 	 * want to know if this core supports Secure Monitor mode.
 	 */
-	if (!target_was_examined(target)) {
-		arm11_dpm_init(arm11, didr);
-		retval = arm_dpm_setup(&amp;arm11-&gt;dpm);
-	}
+	if (!target_was_examined(target))
+		retval = arm11_dpm_init(arm11, didr);
 
 	/* ETM on ARM11 still uses original scanchain 6 access mode */
 	if (arm11-&gt;arm.etm &amp;&amp; !target_was_examined(target)) {
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index cfcb5bf..6ce308e 100644
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -1022,10 +1022,11 @@ static int arm11_dpm_instr_read_data_r0(struct arm_dpm *dpm,
 			opcode, data);
 }
 
-
-void arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
+/** Set up high-level debug module utilities */
+int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
 {
 	struct arm_dpm *dpm = &amp;arm11-&gt;dpm;
+	int retval;
 
 	dpm-&gt;arm = &amp;arm11-&gt;arm;
 
@@ -1039,4 +1040,12 @@ void arm11_dpm_init(struct arm11_common *arm11, uint32_t didr)
 
 	dpm-&gt;instr_read_data_dcc = arm11_dpm_instr_read_data_dcc;
 	dpm-&gt;instr_read_data_r0 = arm11_dpm_instr_read_data_r0;
+
+	retval = arm_dpm_setup(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = arm_dpm_initialize(dpm);
+
+	return retval;
 }
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
index 8b6a206..2203361 100644
--- a/src/target/arm11_dbgtap.h
+++ b/src/target/arm11_dbgtap.h
@@ -60,7 +60,6 @@ void arm11_sc7_set_vcr(struct arm11_common *arm11, uint32_t value);
 int arm11_read_memory_word(struct arm11_common *arm11,
 		uint32_t address, uint32_t *result);
 
-/* Set up high-level debug module utilities */
-void arm11_dpm_init(struct arm11_common *arm11, uint32_t didr);
+int arm11_dpm_init(struct arm11_common *arm11, uint32_t didr);
 
 #endif // ARM11_DBGTAP_H
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 7c09e06..434c63e 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -807,18 +807,6 @@ int arm_dpm_setup(struct arm_dpm *dpm)
 		return ERROR_FAIL;
 	}
 
-	/* Disable all breakpoints and watchpoints at startup. */
-	if (dpm-&gt;bpwp_disable) {
-		unsigned i;
-
-		for (i = 0; i &lt; dpm-&gt;nbp; i++)
-			(void) dpm-&gt;bpwp_disable(dpm, i);
-		for (i = 0; i &lt; dpm-&gt;nwp; i++)
-			(void) dpm-&gt;bpwp_disable(dpm, 16 + i);
-	} else
-		LOG_WARNING(&quot;%s: can't disable breakpoints and watchpoints&quot;,
-			target_name(target));
-
 	LOG_INFO(&quot;%s: hardware has %d breakpoints, %d watchpoints&quot;,
 			target_name(target), dpm-&gt;nbp, dpm-&gt;nwp);
 
@@ -835,6 +823,17 @@ int arm_dpm_setup(struct arm_dpm *dpm)
  */
 int arm_dpm_initialize(struct arm_dpm *dpm)
 {
-	/* FIXME -- nothing yet */
+	/* Disable all breakpoints and watchpoints at startup. */
+	if (dpm-&gt;bpwp_disable) {
+		unsigned i;
+
+		for (i = 0; i &lt; dpm-&gt;nbp; i++)
+			(void) dpm-&gt;bpwp_disable(dpm, i);
+		for (i = 0; i &lt; dpm-&gt;nwp; i++)
+			(void) dpm-&gt;bpwp_disable(dpm, 16 + i);
+	} else
+		LOG_WARNING(&quot;%s: can't disable breakpoints and watchpoints&quot;,
+			target_name(dpm-&gt;arm-&gt;target));
+
 	return ERROR_OK;
 }
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 191f465..c284144 100644
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -129,7 +129,7 @@ struct arm_dpm {
 };
 
 int arm_dpm_setup(struct arm_dpm *dpm);
-int arm_dpm_reinitialize(struct arm_dpm *dpm);
+int arm_dpm_initialize(struct arm_dpm *dpm);
 
 int arm_dpm_read_current_registers(struct arm_dpm *);
 int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
diff --git a/src/target/cortex_a8.c b/src/target/cortex_a8.c
index 5f2de76..9ca072e 100644
--- a/src/target/cortex_a8.c
+++ b/src/target/cortex_a8.c
@@ -523,6 +523,7 @@ static int cortex_a8_bpwp_disable(struct arm_dpm *dpm, unsigned index)
 static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 {
 	struct arm_dpm *dpm = &amp;a8-&gt;armv7a_common.dpm;
+	int retval;
 
 	dpm-&gt;arm = &amp;a8-&gt;armv7a_common.armv4_5_common;
 	dpm-&gt;didr = didr;
@@ -540,7 +541,11 @@ static int cortex_a8_dpm_setup(struct cortex_a8_common *a8, uint32_t didr)
 	dpm-&gt;bpwp_enable = cortex_a8_bpwp_enable;
 	dpm-&gt;bpwp_disable = cortex_a8_bpwp_disable;
 
-	return arm_dpm_setup(dpm);
+	retval = arm_dpm_setup(dpm);
+	if (retval == ERROR_OK)
+		retval = arm_dpm_initialize(dpm);
+
+	return retval;
 }
 
 

-----------------------------------------------------------------------

Summary of changes:
 src/target/arm11.c        |  350 ++++++++++-----------------------------------
 src/target/arm11.h        |   30 +---
 src/target/arm11_dbgtap.c |   45 ++++---
 src/target/arm11_dbgtap.h |    5 +-
 src/target/arm_dpm.c      |   25 ++--
 src/target/arm_dpm.h      |    2 +-
 src/target/cortex_a8.c    |    7 +-
 7 files changed, 128 insertions(+), 336 deletions(-)


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001907.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-760-gb123fd3
</A></li>
	<LI>Next message: <A HREF="001909.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-771-g879a04c
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1908">[ date ]</a>
              <a href="thread.html#1908">[ thread ]</a>
              <a href="subject.html#1908">[ subject ]</a>
              <a href="author.html#1908">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
