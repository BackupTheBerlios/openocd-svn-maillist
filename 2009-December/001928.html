<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-881-g899c997
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-881-g899c997&In-Reply-To=%3CE1NGoOE-00006X-UE%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001927.html">
   <LINK REL="Next"  HREF="001929.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-881-g899c997</H1>
    <B>Zach Welch</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5Bopenocd-svn%5D%20Main%20OpenOCD%20repository%20branch%2C%20master%2C%0A%09updated.%20v0.3.0-881-g899c997&In-Reply-To=%3CE1NGoOE-00006X-UE%40sfp-scmshell-3.v30.ch3.sourceforge.com%3E"
       TITLE="[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-881-g899c997">zwelch at users.sourceforge.net
       </A><BR>
    <I>Sat Dec  5 07:45:09 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001927.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-877-gaf1d759
</A></li>
        <LI>Next message: <A HREF="001929.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-883-gec8c3b5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1928">[ date ]</a>
              <a href="thread.html#1928">[ thread ]</a>
              <a href="subject.html#1928">[ subject ]</a>
              <a href="author.html#1928">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>This is an automated email from the git hooks/post-receive script. It was
generated because a ref change was pushed to the repository containing
the project &quot;Main OpenOCD repository&quot;.

The branch, master has been updated
       via  899c9975e750ff0144d4a4f63e0f2a619c0b0e58 (commit)
       via  da3bcb392e852214b0dda878f6161c8f1e8d15f3 (commit)
       via  747d6f22868dd87cb54341cc22d9eb3687039735 (commit)
       via  a7fd30c07fb9c2b7662ffaa48287b1997dc60796 (commit)
      from  af1d7590edf04077aa8f22fba9097e0c68431f68 (commit)

Those revisions listed above that are new to this repository have
not appeared on any other notification email; so we list those
revisions in full, below.

- Log -----------------------------------------------------------------
commit 899c9975e750ff0144d4a4f63e0f2a619c0b0e58
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 22:04:37 2009 -0800

    rename nand.h to flash//nand/core.h
    
    Rename nand.h as flash/nand/core.h, chase consumers.  The public APIs
    need to be sorted out with imp.h, but this allows other changes to
    begin improving the separation between policy and mechanism.
    
    Moves #include &lt;target/target.h&gt; and #include &quot;driver.h&quot; into the
    internal headers or source files, removing it from &lt;flash/nand/core.h&gt;.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index f8d7088..646889e 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -17,8 +17,7 @@ libflash_la_LIBADD = \
 
 noinst_HEADERS = \
 	common.h \
-	mflash.h \
-	nand.h
+	mflash.h
 
 EXTRA_DIST = startup.tcl
 
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 667ef8f..a48b726 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -26,6 +26,7 @@ NAND_DRIVERS = \
 
 noinst_HEADERS = \
 	arm_io.h \
+	core.h \
 	lpc3180.h \
 	driver.h \
 	mx3.h \
diff --git a/src/flash/nand/arm_io.c b/src/flash/nand/arm_io.c
index cc565dc..4c74675 100644
--- a/src/flash/nand/arm_io.c
+++ b/src/flash/nand/arm_io.c
@@ -24,10 +24,13 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;core.h&quot;
 #include &quot;arm_io.h&quot;
+#include &lt;helper/binarybuffer.h&gt;
 #include &lt;target/armv4_5.h&gt;
 #include &lt;target/algorithm.h&gt;
 
+
 /**
  * Copies code to a working area.  This will allocate room for the code plus the
  * additional amount requested if the working area pointer is null.
diff --git a/src/flash/nand/arm_io.h b/src/flash/nand/arm_io.h
index d3504f4..2e825bf 100644
--- a/src/flash/nand/arm_io.h
+++ b/src/flash/nand/arm_io.h
@@ -19,9 +19,6 @@
 #ifndef __ARM_NANDIO_H
 #define __ARM_NANDIO_H
 
-#include &lt;flash/nand.h&gt;
-#include &lt;helper/binarybuffer.h&gt;
-
 /**
  * Available operational states the arm_nand_data struct can be in.
  */
diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
index 46f5454..d52cf5d 100644
--- a/src/flash/nand/core.c
+++ b/src/flash/nand/core.c
@@ -24,8 +24,6 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/nand.h&gt;
-#include &lt;flash/common.h&gt;
 #include &quot;imp.h&quot;
 
 /* configured NAND devices and NAND Flash command handler */
diff --git a/src/flash/nand.h b/src/flash/nand/core.h
similarity index 96%
rename from src/flash/nand.h
rename to src/flash/nand/core.h
index d675b29..b8dc01c 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand/core.h
@@ -1,6 +1,6 @@
 /***************************************************************************
- *   Copyright (C) 2007 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
+ *   Copyright (C) 2007 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
  *                                                                         *
  *   Partially based on linux/include/linux/mtd/nand.h                     *
  *   Copyright (C) 2000 David Woodhouse &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dwmw2 at mvhi.com</A>&gt;                   *
@@ -22,14 +22,10 @@
  *   Free Software Foundation, Inc.,                                       *
  *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
  ***************************************************************************/
-#ifndef NAND_H
-#define NAND_H
+#ifndef FLASH_NAND_CORE_H
+#define FLASH_NAND_CORE_H
 
 #include &lt;flash/common.h&gt;
-// to be removed later
-#include &lt;target/target.h&gt;
-// to be removed later
-#include &lt;flash/nand/driver.h&gt;
 
 /**
  * Representation of a single NAND block in a NAND device.
@@ -243,4 +239,5 @@ COMMAND_HELPER(nand_command_get_device, unsigned name_index,
 #define		ERROR_NAND_ERROR_CORRECTION_FAILED	(-1105)
 #define		ERROR_NAND_NO_BUFFER			(-1106)
 
-#endif /* NAND_H */
+#endif // FLASH_NAND_CORE_H
+
diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 0152b4d..96cbfea 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -28,8 +28,9 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;arm_io.h&quot;
-
+#include &lt;target/target.h&gt;
 
 enum ecc {
 	HWECC1,		/* all controllers support 1-bit ECC */
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
index 717f5aa..1ccc4f4 100644
--- a/src/flash/nand/driver.c
+++ b/src/flash/nand/driver.c
@@ -23,7 +23,7 @@
 #ifdef HAVE_CONFIG_H
 #include &lt;config.h&gt;
 #endif
-#include &lt;flash/nand.h&gt;
+#include &quot;core.h&quot;
 #include &quot;driver.h&quot;
 
 /* NAND flash controller
diff --git a/src/flash/nand/ecc.c b/src/flash/nand/ecc.c
index 1e103d0..2de12d4 100644
--- a/src/flash/nand/ecc.c
+++ b/src/flash/nand/ecc.c
@@ -41,7 +41,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/nand.h&gt;
+#include &quot;core.h&quot;
 
 /*
  * Pre-calculated 256-way 1 byte column parity
diff --git a/src/flash/nand/ecc_kw.c b/src/flash/nand/ecc_kw.c
index 55273c5..1c1a8ea 100644
--- a/src/flash/nand/ecc_kw.c
+++ b/src/flash/nand/ecc_kw.c
@@ -20,7 +20,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/nand.h&gt;
+#include &quot;core.h&quot;
 
 /*****************************************************************************
  * Arithmetic in GF(2^10) (&quot;F&quot;) modulo x^10 + x^3 + 1.
diff --git a/src/flash/nand/fileio.c b/src/flash/nand/fileio.c
index fbaa8b4..3e397eb 100644
--- a/src/flash/nand/fileio.c
+++ b/src/flash/nand/fileio.c
@@ -24,7 +24,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/nand.h&gt;
+#include &quot;core.h&quot;
 #include &quot;fileio.h&quot;
 
 static struct nand_ecclayout nand_oob_16 = {
diff --git a/src/flash/nand/imp.h b/src/flash/nand/imp.h
index b381b53..e0d411f 100644
--- a/src/flash/nand/imp.h
+++ b/src/flash/nand/imp.h
@@ -19,6 +19,9 @@
 #ifndef FLASH_NAND_IMP_H
 #define FLASH_NAND_IMP_H
 
+#include &quot;core.h&quot;
+#include &quot;driver.h&quot;
+
 int nand_write_page(struct nand_device *nand,
 		uint32_t page, uint8_t *data, uint32_t data_size,
 		uint8_t *oob, uint32_t oob_size);
diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
index 80284cc..4268b66 100644
--- a/src/flash/nand/lpc3180.c
+++ b/src/flash/nand/lpc3180.c
@@ -21,8 +21,10 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;lpc3180.h&quot;
-#include &lt;flash/nand.h&gt;
+#include &lt;target/target.h&gt;
+
 
 static int lpc3180_reset(struct nand_device *nand);
 static int lpc3180_controller_ready(struct nand_device *nand, int timeout);
diff --git a/src/flash/nand/mx3.c b/src/flash/nand/mx3.c
index 21577a6..4823534 100644
--- a/src/flash/nand/mx3.c
+++ b/src/flash/nand/mx3.c
@@ -35,7 +35,9 @@ get_next_halfword_from_sram_buffer() not tested
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;mx3.h&quot;
+#include &lt;target/target.h&gt;
 
 static const char target_not_halted_err_msg[] =
 	&quot;target must be halted to use mx3 NAND flash controller&quot;;
diff --git a/src/flash/nand/mx3.h b/src/flash/nand/mx3.h
index 94dbf0c..f37fc32 100644
--- a/src/flash/nand/mx3.h
+++ b/src/flash/nand/mx3.h
@@ -25,7 +25,6 @@
  *
  * Many thanks to Ben Dooks for writing s3c24xx driver.
  */
-#include &lt;flash/nand.h&gt;
 
 #define		MX3_NF_BASE_ADDR		0xb8000000
 #define		MX3_NF_BUFSIZ			(MX3_NF_BASE_ADDR + 0xe00)
diff --git a/src/flash/nand/nonce.c b/src/flash/nand/nonce.c
index 8d15040..ab490ae 100644
--- a/src/flash/nand/nonce.c
+++ b/src/flash/nand/nonce.c
@@ -20,7 +20,8 @@
 #ifdef HAVE_CONFIG_H
 #include &quot;config.h&quot;
 #endif
-#include &lt;flash/nand.h&gt;
+
+#include &quot;imp.h&quot;
 #include &quot;hello.h&quot;
 
 
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index 4b174da..01d4a08 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -26,6 +26,7 @@
 #include &quot;config.h&quot;
 #endif
 
+#include &quot;imp.h&quot;
 #include &quot;arm_io.h&quot;
 #include &lt;target/armv4_5.h&gt;
 
diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
index f89bf6e..9424cb3 100644
--- a/src/flash/nand/s3c24xx.h
+++ b/src/flash/nand/s3c24xx.h
@@ -27,8 +27,9 @@
  * Many thanks to Simtec Electronics for sponsoring this work.
  */
 
-#include &lt;flash/nand.h&gt;
-#include &lt;flash/nand/s3c24xx_regs.h&gt;
+#include &quot;imp.h&quot;
+#include &quot;s3c24xx_regs.h&quot;
+#include &lt;target/target.h&gt;
 
 struct s3c24xx_nand_controller
 {
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
index 75a416f..e69882b 100644
--- a/src/flash/nand/tcl.c
+++ b/src/flash/nand/tcl.c
@@ -24,7 +24,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/nand.h&gt;
+#include &quot;core.h&quot;
 #include &quot;imp.h&quot;
 #include &quot;fileio.h&quot;
 
diff --git a/src/openocd.c b/src/openocd.c
index e500ba6..8cb8674 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -35,7 +35,7 @@
 #include &lt;xsvf/xsvf.h&gt;
 #include &lt;svf/svf.h&gt;
 #include &lt;flash/nor/core.h&gt;
-#include &lt;flash/nand.h&gt;
+#include &lt;flash/nand/core.h&gt;
 #include &lt;pld/pld.h&gt;
 #include &lt;flash/mflash.h&gt;
 

commit da3bcb392e852214b0dda878f6161c8f1e8d15f3
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 21:38:13 2009 -0800

    move remaining nand helper files
    
    Move remaining NAND implementation files into src/flash/nand/.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index 2144ff2..f8d7088 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -9,9 +9,6 @@ METASOURCES = AUTO
 noinst_LTLIBRARIES = libflash.la
 libflash_la_SOURCES = \
 	common.c \
-	arm_nandio.c \
-	nand_ecc.c \
-	nand_ecc_kw.c \
 	mflash.c
 
 libflash_la_LIBADD = \
@@ -19,7 +16,6 @@ libflash_la_LIBADD = \
 	$(top_builddir)/src/flash/nand/libocdflashnand.la
 
 noinst_HEADERS = \
-	arm_nandio.h \
 	common.h \
 	mflash.h \
 	nand.h
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 3885a7b..667ef8f 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -3,9 +3,12 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 noinst_LTLIBRARIES = libocdflashnand.la
 
 libocdflashnand_la_SOURCES = \
+	ecc.c \
+	ecc_kw.c \
 	core.c \
 	fileio.c \
 	tcl.c \
+	arm_io.c \
 	$(NAND_DRIVERS) \
 	driver.c
 
@@ -22,6 +25,7 @@ NAND_DRIVERS = \
 	s3c2443.c
 
 noinst_HEADERS = \
+	arm_io.h \
 	lpc3180.h \
 	driver.h \
 	mx3.h \
diff --git a/src/flash/arm_nandio.c b/src/flash/nand/arm_io.c
similarity index 99%
rename from src/flash/arm_nandio.c
rename to src/flash/nand/arm_io.c
index 67619d5..cc565dc 100644
--- a/src/flash/arm_nandio.c
+++ b/src/flash/nand/arm_io.c
@@ -24,7 +24,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &quot;arm_nandio.h&quot;
+#include &quot;arm_io.h&quot;
 #include &lt;target/armv4_5.h&gt;
 #include &lt;target/algorithm.h&gt;
 
diff --git a/src/flash/arm_nandio.h b/src/flash/nand/arm_io.h
similarity index 100%
rename from src/flash/arm_nandio.h
rename to src/flash/nand/arm_io.h
diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
index 6677073..0152b4d 100644
--- a/src/flash/nand/davinci.c
+++ b/src/flash/nand/davinci.c
@@ -28,7 +28,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/arm_nandio.h&gt;
+#include &quot;arm_io.h&quot;
 
 
 enum ecc {
diff --git a/src/flash/nand_ecc.c b/src/flash/nand/ecc.c
similarity index 99%
rename from src/flash/nand_ecc.c
rename to src/flash/nand/ecc.c
index 7aa1519..1e103d0 100644
--- a/src/flash/nand_ecc.c
+++ b/src/flash/nand/ecc.c
@@ -41,7 +41,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &quot;nand.h&quot;
+#include &lt;flash/nand.h&gt;
 
 /*
  * Pre-calculated 256-way 1 byte column parity
diff --git a/src/flash/nand_ecc_kw.c b/src/flash/nand/ecc_kw.c
similarity index 99%
rename from src/flash/nand_ecc_kw.c
rename to src/flash/nand/ecc_kw.c
index a809b32..55273c5 100644
--- a/src/flash/nand_ecc_kw.c
+++ b/src/flash/nand/ecc_kw.c
@@ -20,9 +20,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;sys/types.h&gt;
-#include &quot;nand.h&quot;
-
+#include &lt;flash/nand.h&gt;
 
 /*****************************************************************************
  * Arithmetic in GF(2^10) (&quot;F&quot;) modulo x^10 + x^3 + 1.
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
index b124dee..4b174da 100644
--- a/src/flash/nand/orion.c
+++ b/src/flash/nand/orion.c
@@ -26,7 +26,7 @@
 #include &quot;config.h&quot;
 #endif
 
-#include &lt;flash/arm_nandio.h&gt;
+#include &quot;arm_io.h&quot;
 #include &lt;target/armv4_5.h&gt;
 
 

commit 747d6f22868dd87cb54341cc22d9eb3687039735
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 19:28:18 2009 -0800

    split nand.c into nand/{core,fileio,tcl}.c
    
    Moves commands into nand/tcl.c and core implementation to 'nand/core.c'
    and 'nand/fileio.c'.  Eliminates 'flash/nand.c'.
    
    Adds 'nand/imp.h' to share routines between TCL commands and core.

diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
index ba44adb..2144ff2 100644
--- a/src/flash/Makefile.am
+++ b/src/flash/Makefile.am
@@ -12,7 +12,6 @@ libflash_la_SOURCES = \
 	arm_nandio.c \
 	nand_ecc.c \
 	nand_ecc_kw.c \
-	nand.c \
 	mflash.c
 
 libflash_la_LIBADD = \
diff --git a/src/flash/nand.c b/src/flash/nand.c
deleted file mode 100644
index 9a220d2..0000000
--- a/src/flash/nand.c
+++ /dev/null
@@ -1,1766 +0,0 @@
-/***************************************************************************
- *   Copyright (C) 2007 by Dominic Rath                                    *
- *   <A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>                                                   *
- *                                                                         *
- *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
- *   Copyright (C) 2002 Thomas Gleixner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">tglx at linutronix.de</A>&gt;               *
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- *   This program is distributed in the hope that it will be useful,       *
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                          *
- *                                                                         *
- *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                         *
- *   Free Software Foundation, Inc.,                                       *
- *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;nand.h&quot;
-#include &quot;common.h&quot;
-#include &lt;helper/time_support.h&gt;
-#include &lt;helper/fileio.h&gt;
-
-static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-//static int nand_read_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size);
-
-static int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-
-/* configured NAND devices and NAND Flash command handler */
-static struct nand_device *nand_devices = NULL;
-
-/*	Chip ID list
- *
- *	Name, ID code, pagesize, chipsize in MegaByte, eraseblock size,
- *	options
- *
- *	Pagesize; 0, 256, 512
- *	0	get this information from the extended chip ID
- *	256	256 Byte page size
- *	512	512 Byte page size
- */
-static struct nand_info nand_flash_ids[] =
-{
-	/* start &quot;museum&quot; IDs */
-	{&quot;NAND 1MiB 5V 8-bit&quot;,		0x6e, 256, 1, 0x1000, 0},
-	{&quot;NAND 2MiB 5V 8-bit&quot;,		0x64, 256, 2, 0x1000, 0},
-	{&quot;NAND 4MiB 5V 8-bit&quot;,		0x6b, 512, 4, 0x2000, 0},
-	{&quot;NAND 1MiB 3,3V 8-bit&quot;,	0xe8, 256, 1, 0x1000, 0},
-	{&quot;NAND 1MiB 3,3V 8-bit&quot;,	0xec, 256, 1, 0x1000, 0},
-	{&quot;NAND 2MiB 3,3V 8-bit&quot;,	0xea, 256, 2, 0x1000, 0},
-	{&quot;NAND 4MiB 3,3V 8-bit&quot;,	0xd5, 512, 4, 0x2000, 0},
-	{&quot;NAND 4MiB 3,3V 8-bit&quot;,	0xe3, 512, 4, 0x2000, 0},
-	{&quot;NAND 4MiB 3,3V 8-bit&quot;,	0xe5, 512, 4, 0x2000, 0},
-	{&quot;NAND 8MiB 3,3V 8-bit&quot;,	0xd6, 512, 8, 0x2000, 0},
-
-	{&quot;NAND 8MiB 1,8V 8-bit&quot;,	0x39, 512, 8, 0x2000, 0},
-	{&quot;NAND 8MiB 3,3V 8-bit&quot;,	0xe6, 512, 8, 0x2000, 0},
-	{&quot;NAND 8MiB 1,8V 16-bit&quot;,	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
-	{&quot;NAND 8MiB 3,3V 16-bit&quot;,	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
-	/* end &quot;museum&quot; IDs */
-
-	{&quot;NAND 16MiB 1,8V 8-bit&quot;,	0x33, 512, 16, 0x4000, 0},
-	{&quot;NAND 16MiB 3,3V 8-bit&quot;,	0x73, 512, 16, 0x4000, 0},
-	{&quot;NAND 16MiB 1,8V 16-bit&quot;,	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-	{&quot;NAND 16MiB 3,3V 16-bit&quot;,	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
-
-	{&quot;NAND 32MiB 1,8V 8-bit&quot;,	0x35, 512, 32, 0x4000, 0},
-	{&quot;NAND 32MiB 3,3V 8-bit&quot;,	0x75, 512, 32, 0x4000, 0},
-	{&quot;NAND 32MiB 1,8V 16-bit&quot;,	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-	{&quot;NAND 32MiB 3,3V 16-bit&quot;,	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
-
-	{&quot;NAND 64MiB 1,8V 8-bit&quot;,	0x36, 512, 64, 0x4000, 0},
-	{&quot;NAND 64MiB 3,3V 8-bit&quot;,	0x76, 512, 64, 0x4000, 0},
-	{&quot;NAND 64MiB 1,8V 16-bit&quot;,	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-	{&quot;NAND 64MiB 3,3V 16-bit&quot;,	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
-
-	{&quot;NAND 128MiB 1,8V 8-bit&quot;,	0x78, 512, 128, 0x4000, 0},
-	{&quot;NAND 128MiB 1,8V 8-bit&quot;,	0x39, 512, 128, 0x4000, 0},
-	{&quot;NAND 128MiB 3,3V 8-bit&quot;,	0x79, 512, 128, 0x4000, 0},
-	{&quot;NAND 128MiB 1,8V 16-bit&quot;,	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{&quot;NAND 128MiB 1,8V 16-bit&quot;,	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{&quot;NAND 128MiB 3,3V 16-bit&quot;,	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-	{&quot;NAND 128MiB 3,3V 16-bit&quot;,	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
-
-	{&quot;NAND 256MiB 3,3V 8-bit&quot;,	0x71, 512, 256, 0x4000, 0},
-
-	{&quot;NAND 64MiB 1,8V 8-bit&quot;,	0xA2, 0,  64, 0, LP_OPTIONS},
-	{&quot;NAND 64MiB 3,3V 8-bit&quot;,	0xF2, 0,  64, 0, LP_OPTIONS},
-	{&quot;NAND 64MiB 1,8V 16-bit&quot;,	0xB2, 0,  64, 0, LP_OPTIONS16},
-	{&quot;NAND 64MiB 3,3V 16-bit&quot;,	0xC2, 0,  64, 0, LP_OPTIONS16},
-
-	{&quot;NAND 128MiB 1,8V 8-bit&quot;,	0xA1, 0, 128, 0, LP_OPTIONS},
-	{&quot;NAND 128MiB 3,3V 8-bit&quot;,	0xF1, 0, 128, 0, LP_OPTIONS},
-	{&quot;NAND 128MiB 1,8V 16-bit&quot;,	0xB1, 0, 128, 0, LP_OPTIONS16},
-	{&quot;NAND 128MiB 3,3V 16-bit&quot;,	0xC1, 0, 128, 0, LP_OPTIONS16},
-
-	{&quot;NAND 256MiB 1,8V 8-bit&quot;,	0xAA, 0, 256, 0, LP_OPTIONS},
-	{&quot;NAND 256MiB 3,3V 8-bit&quot;,	0xDA, 0, 256, 0, LP_OPTIONS},
-	{&quot;NAND 256MiB 1,8V 16-bit&quot;,	0xBA, 0, 256, 0, LP_OPTIONS16},
-	{&quot;NAND 256MiB 3,3V 16-bit&quot;,	0xCA, 0, 256, 0, LP_OPTIONS16},
-
-	{&quot;NAND 512MiB 1,8V 8-bit&quot;,	0xAC, 0, 512, 0, LP_OPTIONS},
-	{&quot;NAND 512MiB 3,3V 8-bit&quot;,	0xDC, 0, 512, 0, LP_OPTIONS},
-	{&quot;NAND 512MiB 1,8V 16-bit&quot;,	0xBC, 0, 512, 0, LP_OPTIONS16},
-	{&quot;NAND 512MiB 3,3V 16-bit&quot;,	0xCC, 0, 512, 0, LP_OPTIONS16},
-
-	{&quot;NAND 1GiB 1,8V 8-bit&quot;,	0xA3, 0, 1024, 0, LP_OPTIONS},
-	{&quot;NAND 1GiB 3,3V 8-bit&quot;,	0xD3, 0, 1024, 0, LP_OPTIONS},
-	{&quot;NAND 1GiB 1,8V 16-bit&quot;,	0xB3, 0, 1024, 0, LP_OPTIONS16},
-	{&quot;NAND 1GiB 3,3V 16-bit&quot;,	0xC3, 0, 1024, 0, LP_OPTIONS16},
-
-	{&quot;NAND 2GiB 1,8V 8-bit&quot;,	0xA5, 0, 2048, 0, LP_OPTIONS},
-	{&quot;NAND 2GiB 3,3V 8-bit&quot;,	0xD5, 0, 2048, 0, LP_OPTIONS},
-	{&quot;NAND 2GiB 1,8V 16-bit&quot;,	0xB5, 0, 2048, 0, LP_OPTIONS16},
-	{&quot;NAND 2GiB 3,3V 16-bit&quot;,	0xC5, 0, 2048, 0, LP_OPTIONS16},
-
-	{NULL, 0, 0, 0, 0, 0 }
-};
-
-/* Manufacturer ID list
- */
-static struct nand_manufacturer nand_manuf_ids[] =
-{
-	{0x0, &quot;unknown&quot;},
-	{NAND_MFR_TOSHIBA, &quot;Toshiba&quot;},
-	{NAND_MFR_SAMSUNG, &quot;Samsung&quot;},
-	{NAND_MFR_FUJITSU, &quot;Fujitsu&quot;},
-	{NAND_MFR_NATIONAL, &quot;National&quot;},
-	{NAND_MFR_RENESAS, &quot;Renesas&quot;},
-	{NAND_MFR_STMICRO, &quot;ST Micro&quot;},
-	{NAND_MFR_HYNIX, &quot;Hynix&quot;},
-	{NAND_MFR_MICRON, &quot;Micron&quot;},
-	{0x0, NULL},
-};
-
-/*
- * Define default oob placement schemes for large and small page devices
- */
-
-#if 0
-static struct nand_ecclayout nand_oob_8 = {
-	.eccbytes = 3,
-	.eccpos = {0, 1, 2},
-	.oobfree = {
-		{.offset = 3,
-		 .length = 2},
-		{.offset = 6,
-		 .length = 2}}
-};
-#endif
-
-static struct nand_ecclayout nand_oob_16 = {
-	.eccbytes = 6,
-	.eccpos = {0, 1, 2, 3, 6, 7},
-	.oobfree = {
-		{.offset = 8,
-		 . length = 8}}
-};
-
-static struct nand_ecclayout nand_oob_64 = {
-	.eccbytes = 24,
-	.eccpos = {
-		   40, 41, 42, 43, 44, 45, 46, 47,
-		   48, 49, 50, 51, 52, 53, 54, 55,
-		   56, 57, 58, 59, 60, 61, 62, 63},
-	.oobfree = {
-		{.offset = 2,
-		 .length = 38}}
-};
-
-int nand_list_walker(struct nand_flash_controller *c, void *x)
-{
-	struct command_context *cmd_ctx = (struct command_context *)x;
-	command_print(cmd_ctx, &quot;  %s&quot;, c-&gt;name);
-	return ERROR_OK;
-}
-COMMAND_HANDLER(handle_nand_list_drivers)
-{
-	command_print(CMD_CTX, &quot;Available NAND flash controller drivers:&quot;);
-	return nand_driver_walk(&amp;nand_list_walker, CMD_CTX);
-}
-
-static COMMAND_HELPER(create_nand_device, const char *bank_name,
-		struct nand_flash_controller *controller)
-{
-	if (NULL != controller-&gt;commands)
-	{
-		int retval = register_commands(CMD_CTX, NULL,
-				controller-&gt;commands);
-		if (ERROR_OK != retval)
-			return retval;
-	}
-	struct nand_device *c = malloc(sizeof(struct nand_device));
-
-	c-&gt;name = strdup(bank_name);
-	c-&gt;controller = controller;
-	c-&gt;controller_priv = NULL;
-	c-&gt;manufacturer = NULL;
-	c-&gt;device = NULL;
-	c-&gt;bus_width = 0;
-	c-&gt;address_cycles = 0;
-	c-&gt;page_size = 0;
-	c-&gt;use_raw = 0;
-	c-&gt;next = NULL;
-
-	int retval = CALL_COMMAND_HANDLER(controller-&gt;nand_device_command, c);
-	if (ERROR_OK != retval)
-	{
-		LOG_ERROR(&quot;'%s' driver rejected nand flash&quot;, controller-&gt;name);
-		free(c);
-		return ERROR_OK;
-	}
-
-	if (nand_devices) {
-		struct nand_device *p = nand_devices;
-		while (p &amp;&amp; p-&gt;next) p = p-&gt;next;
-		p-&gt;next = c;
-	} else
-		nand_devices = c;
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_device_command)
-{
-	if (CMD_ARGC &lt; 1)
-	{
-		LOG_ERROR(&quot;incomplete nand device configuration&quot;);
-		return ERROR_FLASH_BANK_INVALID;
-	}
-
-	// save name and increment (for compatibility) with drivers
-	const char *bank_name = *CMD_ARGV++;
-	CMD_ARGC--;
-
-	const char *driver_name = CMD_ARGV[0];
-	struct nand_flash_controller *controller;
-	controller = nand_driver_find_by_name(CMD_ARGV[0]);
-	if (NULL == controller)
-	{
-		LOG_ERROR(&quot;No valid NAND flash driver found (%s)&quot;, driver_name);
-		return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
-	}
-	return CALL_COMMAND_HANDLER(create_nand_device, bank_name, controller);
-}
-
-
-COMMAND_HANDLER(handle_nand_init_command);
-
-static const struct command_registration nand_config_command_handlers[] = {
-	{
-		.name = &quot;device&quot;,
-		.handler = &amp;handle_nand_device_command,
-		.mode = COMMAND_CONFIG,
-		.help = &quot;defines a new NAND bank&quot;,
-	},
-	{
-		.name = &quot;drivers&quot;,
-		.handler = &amp;handle_nand_list_drivers,
-		.mode = COMMAND_ANY,
-		.help = &quot;lists available NAND drivers&quot;,
-	},
-	{
-		.name = &quot;init&quot;,
-		.mode = COMMAND_CONFIG,
-		.handler = &amp;handle_nand_init_command,
-		.help = &quot;initialize NAND devices&quot;,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-static const struct command_registration nand_command_handlers[] = {
-	{
-		.name = &quot;nand&quot;,
-		.mode = COMMAND_ANY,
-		.help = &quot;NAND flash command group&quot;,
-		.chain = nand_config_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-int nand_register_commands(struct command_context *cmd_ctx)
-{
-	return register_commands(cmd_ctx, NULL, nand_command_handlers);
-}
-
-struct nand_device *get_nand_device_by_name(const char *name)
-{
-	unsigned requested = get_flash_name_index(name);
-	unsigned found = 0;
-
-	struct nand_device *nand;
-	for (nand = nand_devices; NULL != nand; nand = nand-&gt;next)
-	{
-		if (strcmp(nand-&gt;name, name) == 0)
-			return nand;
-		if (!flash_driver_name_matches(nand-&gt;controller-&gt;name, name))
-			continue;
-		if (++found &lt; requested)
-			continue;
-		return nand;
-	}
-	return NULL;
-}
-
-struct nand_device *get_nand_device_by_num(int num)
-{
-	struct nand_device *p;
-	int i = 0;
-
-	for (p = nand_devices; p; p = p-&gt;next)
-	{
-		if (i++ == num)
-		{
-			return p;
-		}
-	}
-
-	return NULL;
-}
-
-COMMAND_HELPER(nand_command_get_device, unsigned name_index,
-		struct nand_device **nand)
-{
-	const char *str = CMD_ARGV[name_index];
-	*nand = get_nand_device_by_name(str);
-	if (*nand)
-		return ERROR_OK;
-
-	unsigned num;
-	COMMAND_PARSE_NUMBER(uint, str, num);
-	*nand = get_nand_device_by_num(num);
-	if (!*nand) {
-		command_print(CMD_CTX, &quot;NAND flash device '%s' not found&quot;, str);
-		return ERROR_INVALID_ARGUMENTS;
-	}
-	return ERROR_OK;
-}
-
-static int nand_build_bbt(struct nand_device *nand, int first, int last)
-{
-	uint32_t page = 0x0;
-	int i;
-	uint8_t oob[6];
-
-	if ((first &lt; 0) || (first &gt;= nand-&gt;num_blocks))
-		first = 0;
-
-	if ((last &gt;= nand-&gt;num_blocks) || (last == -1))
-		last = nand-&gt;num_blocks - 1;
-
-	for (i = first; i &lt; last; i++)
-	{
-		nand_read_page(nand, page, NULL, 0, oob, 6);
-
-		if (((nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16) &amp;&amp; ((oob[0] &amp; oob[1]) != 0xff))
-			|| (((nand-&gt;page_size == 512) &amp;&amp; (oob[5] != 0xff)) ||
-				((nand-&gt;page_size == 2048) &amp;&amp; (oob[0] != 0xff))))
-		{
-			LOG_WARNING(&quot;bad block: %i&quot;, i);
-			nand-&gt;blocks[i].is_bad = 1;
-		}
-		else
-		{
-			nand-&gt;blocks[i].is_bad = 0;
-		}
-
-		page += (nand-&gt;erase_size / nand-&gt;page_size);
-	}
-
-	return ERROR_OK;
-}
-
-int nand_read_status(struct nand_device *nand, uint8_t *status)
-{
-	if (!nand-&gt;device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	/* Send read status command */
-	nand-&gt;controller-&gt;command(nand, NAND_CMD_STATUS);
-
-	alive_sleep(1);
-
-	/* read status */
-	if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
-	{
-		uint16_t data;
-		nand-&gt;controller-&gt;read_data(nand, &amp;data);
-		*status = data &amp; 0xff;
-	}
-	else
-	{
-		nand-&gt;controller-&gt;read_data(nand, status);
-	}
-
-	return ERROR_OK;
-}
-
-static int nand_poll_ready(struct nand_device *nand, int timeout)
-{
-	uint8_t status;
-
-	nand-&gt;controller-&gt;command(nand, NAND_CMD_STATUS);
-	do {
-		if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16) {
-			uint16_t data;
-			nand-&gt;controller-&gt;read_data(nand, &amp;data);
-			status = data &amp; 0xff;
-		} else {
-			nand-&gt;controller-&gt;read_data(nand, &amp;status);
-		}
-		if (status &amp; NAND_STATUS_READY)
-			break;
-		alive_sleep(1);
-	} while (timeout--);
-
-	return (status &amp; NAND_STATUS_READY) != 0;
-}
-
-int nand_probe(struct nand_device *nand)
-{
-	uint8_t manufacturer_id, device_id;
-	uint8_t id_buff[6];
-	int retval;
-	int i;
-
-	/* clear device data */
-	nand-&gt;device = NULL;
-	nand-&gt;manufacturer = NULL;
-
-	/* clear device parameters */
-	nand-&gt;bus_width = 0;
-	nand-&gt;address_cycles = 0;
-	nand-&gt;page_size = 0;
-	nand-&gt;erase_size = 0;
-
-	/* initialize controller (device parameters are zero, use controller default) */
-	if ((retval = nand-&gt;controller-&gt;init(nand) != ERROR_OK))
-	{
-		switch (retval)
-		{
-			case ERROR_NAND_OPERATION_FAILED:
-				LOG_DEBUG(&quot;controller initialization failed&quot;);
-				return ERROR_NAND_OPERATION_FAILED;
-			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
-				LOG_ERROR(&quot;BUG: controller reported that it doesn't support default parameters&quot;);
-				return ERROR_NAND_OPERATION_FAILED;
-			default:
-				LOG_ERROR(&quot;BUG: unknown controller initialization failure&quot;);
-				return ERROR_NAND_OPERATION_FAILED;
-		}
-	}
-
-	nand-&gt;controller-&gt;command(nand, NAND_CMD_RESET);
-	nand-&gt;controller-&gt;reset(nand);
-
-	nand-&gt;controller-&gt;command(nand, NAND_CMD_READID);
-	nand-&gt;controller-&gt;address(nand, 0x0);
-
-	if (nand-&gt;bus_width == 8)
-	{
-		nand-&gt;controller-&gt;read_data(nand, &amp;manufacturer_id);
-		nand-&gt;controller-&gt;read_data(nand, &amp;device_id);
-	}
-	else
-	{
-		uint16_t data_buf;
-		nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
-		manufacturer_id = data_buf &amp; 0xff;
-		nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
-		device_id = data_buf &amp; 0xff;
-	}
-
-	for (i = 0; nand_flash_ids[i].name; i++)
-	{
-		if (nand_flash_ids[i].id == device_id)
-		{
-			nand-&gt;device = &amp;nand_flash_ids[i];
-			break;
-		}
-	}
-
-	for (i = 0; nand_manuf_ids[i].name; i++)
-	{
-		if (nand_manuf_ids[i].id == manufacturer_id)
-		{
-			nand-&gt;manufacturer = &amp;nand_manuf_ids[i];
-			break;
-		}
-	}
-
-	if (!nand-&gt;manufacturer)
-	{
-		nand-&gt;manufacturer = &amp;nand_manuf_ids[0];
-		nand-&gt;manufacturer-&gt;id = manufacturer_id;
-	}
-
-	if (!nand-&gt;device)
-	{
-		LOG_ERROR(&quot;unknown NAND flash device found, manufacturer id: 0x%2.2x device id: 0x%2.2x&quot;,
-			manufacturer_id, device_id);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	LOG_DEBUG(&quot;found %s (%s)&quot;, nand-&gt;device-&gt;name, nand-&gt;manufacturer-&gt;name);
-
-	/* initialize device parameters */
-
-	/* bus width */
-	if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
-		nand-&gt;bus_width = 16;
-	else
-		nand-&gt;bus_width = 8;
-
-	/* Do we need extended device probe information? */
-	if (nand-&gt;device-&gt;page_size == 0 ||
-	    nand-&gt;device-&gt;erase_size == 0)
-	{
-		if (nand-&gt;bus_width == 8)
-		{
-			nand-&gt;controller-&gt;read_data(nand, id_buff + 3);
-			nand-&gt;controller-&gt;read_data(nand, id_buff + 4);
-			nand-&gt;controller-&gt;read_data(nand, id_buff + 5);
-		}
-		else
-		{
-			uint16_t data_buf;
-
-			nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
-			id_buff[3] = data_buf;
-
-			nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
-			id_buff[4] = data_buf;
-
-			nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
-			id_buff[5] = data_buf &gt;&gt; 8;
-		}
-	}
-
-	/* page size */
-	if (nand-&gt;device-&gt;page_size == 0)
-	{
-		nand-&gt;page_size = 1 &lt;&lt; (10 + (id_buff[4] &amp; 3));
-	}
-	else if (nand-&gt;device-&gt;page_size == 256)
-	{
-		LOG_ERROR(&quot;NAND flashes with 256 byte pagesize are not supported&quot;);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-	else
-	{
-		nand-&gt;page_size = nand-&gt;device-&gt;page_size;
-	}
-
-	/* number of address cycles */
-	if (nand-&gt;page_size &lt;= 512)
-	{
-		/* small page devices */
-		if (nand-&gt;device-&gt;chip_size &lt;= 32)
-			nand-&gt;address_cycles = 3;
-		else if (nand-&gt;device-&gt;chip_size &lt;= 8*1024)
-			nand-&gt;address_cycles = 4;
-		else
-		{
-			LOG_ERROR(&quot;BUG: small page NAND device with more than 8 GiB encountered&quot;);
-			nand-&gt;address_cycles = 5;
-		}
-	}
-	else
-	{
-		/* large page devices */
-		if (nand-&gt;device-&gt;chip_size &lt;= 128)
-			nand-&gt;address_cycles = 4;
-		else if (nand-&gt;device-&gt;chip_size &lt;= 32*1024)
-			nand-&gt;address_cycles = 5;
-		else
-		{
-			LOG_ERROR(&quot;BUG: large page NAND device with more than 32 GiB encountered&quot;);
-			nand-&gt;address_cycles = 6;
-		}
-	}
-
-	/* erase size */
-	if (nand-&gt;device-&gt;erase_size == 0)
-	{
-		switch ((id_buff[4] &gt;&gt; 4) &amp; 3) {
-		case 0:
-			nand-&gt;erase_size = 64 &lt;&lt; 10;
-			break;
-		case 1:
-			nand-&gt;erase_size = 128 &lt;&lt; 10;
-			break;
-		case 2:
-			nand-&gt;erase_size = 256 &lt;&lt; 10;
-			break;
-		case 3:
-			nand-&gt;erase_size =512 &lt;&lt; 10;
-			break;
-		}
-	}
-	else
-	{
-		nand-&gt;erase_size = nand-&gt;device-&gt;erase_size;
-	}
-
-	/* initialize controller, but leave parameters at the controllers default */
-	if ((retval = nand-&gt;controller-&gt;init(nand) != ERROR_OK))
-	{
-		switch (retval)
-		{
-			case ERROR_NAND_OPERATION_FAILED:
-				LOG_DEBUG(&quot;controller initialization failed&quot;);
-				return ERROR_NAND_OPERATION_FAILED;
-			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
-				LOG_ERROR(&quot;controller doesn't support requested parameters (buswidth: %i, address cycles: %i, page size: %i)&quot;,
-					nand-&gt;bus_width, nand-&gt;address_cycles, nand-&gt;page_size);
-				return ERROR_NAND_OPERATION_FAILED;
-			default:
-				LOG_ERROR(&quot;BUG: unknown controller initialization failure&quot;);
-				return ERROR_NAND_OPERATION_FAILED;
-		}
-	}
-
-	nand-&gt;num_blocks = (nand-&gt;device-&gt;chip_size * 1024) / (nand-&gt;erase_size / 1024);
-	nand-&gt;blocks = malloc(sizeof(struct nand_block) * nand-&gt;num_blocks);
-
-	for (i = 0; i &lt; nand-&gt;num_blocks; i++)
-	{
-		nand-&gt;blocks[i].size = nand-&gt;erase_size;
-		nand-&gt;blocks[i].offset = i * nand-&gt;erase_size;
-		nand-&gt;blocks[i].is_erased = -1;
-		nand-&gt;blocks[i].is_bad = -1;
-	}
-
-	return ERROR_OK;
-}
-
-static int nand_erase(struct nand_device *nand, int first_block, int last_block)
-{
-	int i;
-	uint32_t page;
-	uint8_t status;
-	int retval;
-
-	if (!nand-&gt;device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if ((first_block &lt; 0) || (last_block &gt; nand-&gt;num_blocks))
-		return ERROR_INVALID_ARGUMENTS;
-
-	/* make sure we know if a block is bad before erasing it */
-	for (i = first_block; i &lt;= last_block; i++)
-	{
-		if (nand-&gt;blocks[i].is_bad == -1)
-		{
-			nand_build_bbt(nand, i, last_block);
-			break;
-		}
-	}
-
-	for (i = first_block; i &lt;= last_block; i++)
-	{
-		/* Send erase setup command */
-		nand-&gt;controller-&gt;command(nand, NAND_CMD_ERASE1);
-
-		page = i * (nand-&gt;erase_size / nand-&gt;page_size);
-
-		/* Send page address */
-		if (nand-&gt;page_size &lt;= 512)
-		{
-			/* row */
-			nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
-			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
-
-			/* 3rd cycle only on devices with more than 32 MiB */
-			if (nand-&gt;address_cycles &gt;= 4)
-				nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
-
-			/* 4th cycle only on devices with more than 8 GiB */
-			if (nand-&gt;address_cycles &gt;= 5)
-				nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 24) &amp; 0xff);
-		}
-		else
-		{
-			/* row */
-			nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
-			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
-
-			/* 3rd cycle only on devices with more than 128 MiB */
-			if (nand-&gt;address_cycles &gt;= 5)
-				nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
-		}
-
-		/* Send erase confirm command */
-		nand-&gt;controller-&gt;command(nand, NAND_CMD_ERASE2);
-
-		retval = nand-&gt;controller-&gt;nand_ready ?
-				nand-&gt;controller-&gt;nand_ready(nand, 1000) :
-				nand_poll_ready(nand, 1000);
-		if (!retval) {
-			LOG_ERROR(&quot;timeout waiting for NAND flash block erase to complete&quot;);
-			return ERROR_NAND_OPERATION_TIMEOUT;
-		}
-
-		if ((retval = nand_read_status(nand, &amp;status)) != ERROR_OK)
-		{
-			LOG_ERROR(&quot;couldn't read status&quot;);
-			return ERROR_NAND_OPERATION_FAILED;
-		}
-
-		if (status &amp; 0x1)
-		{
-			LOG_ERROR(&quot;didn't erase %sblock %d; status: 0x%2.2x&quot;,
-					(nand-&gt;blocks[i].is_bad == 1)
-						? &quot;bad &quot; : &quot;&quot;,
-					i, status);
-			/* continue; other blocks might still be erasable */
-		}
-
-		nand-&gt;blocks[i].is_erased = 1;
-	}
-
-	return ERROR_OK;
-}
-
-#if 0
-static int nand_read_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
-{
-	uint8_t *page;
-
-	if (!nand-&gt;device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (address % nand-&gt;page_size)
-	{
-		LOG_ERROR(&quot;reads need to be page aligned&quot;);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	page = malloc(nand-&gt;page_size);
-
-	while (data_size &gt; 0)
-	{
-		uint32_t thisrun_size = (data_size &gt; nand-&gt;page_size) ? nand-&gt;page_size : data_size;
-		uint32_t page_address;
-
-
-		page_address = address / nand-&gt;page_size;
-
-		nand_read_page(nand, page_address, page, nand-&gt;page_size, NULL, 0);
-
-		memcpy(data, page, thisrun_size);
-
-		address += thisrun_size;
-		data += thisrun_size;
-		data_size -= thisrun_size;
-	}
-
-	free(page);
-
-	return ERROR_OK;
-}
-
-static int nand_write_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
-{
-	uint8_t *page;
-
-	if (!nand-&gt;device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (address % nand-&gt;page_size)
-	{
-		LOG_ERROR(&quot;writes need to be page aligned&quot;);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	page = malloc(nand-&gt;page_size);
-
-	while (data_size &gt; 0)
-	{
-		uint32_t thisrun_size = (data_size &gt; nand-&gt;page_size) ? nand-&gt;page_size : data_size;
-		uint32_t page_address;
-
-		memset(page, 0xff, nand-&gt;page_size);
-		memcpy(page, data, thisrun_size);
-
-		page_address = address / nand-&gt;page_size;
-
-		nand_write_page(nand, page_address, page, nand-&gt;page_size, NULL, 0);
-
-		address += thisrun_size;
-		data += thisrun_size;
-		data_size -= thisrun_size;
-	}
-
-	free(page);
-
-	return ERROR_OK;
-}
-#endif
-
-int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
-{
-	uint32_t block;
-
-	if (!nand-&gt;device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	block = page / (nand-&gt;erase_size / nand-&gt;page_size);
-	if (nand-&gt;blocks[block].is_erased == 1)
-		nand-&gt;blocks[block].is_erased = 0;
-
-	if (nand-&gt;use_raw || nand-&gt;controller-&gt;write_page == NULL)
-		return nand_write_page_raw(nand, page, data, data_size, oob, oob_size);
-	else
-		return nand-&gt;controller-&gt;write_page(nand, page, data, data_size, oob, oob_size);
-}
-
-static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
-{
-	if (!nand-&gt;device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (nand-&gt;use_raw || nand-&gt;controller-&gt;read_page == NULL)
-		return nand_read_page_raw(nand, page, data, data_size, oob, oob_size);
-	else
-		return nand-&gt;controller-&gt;read_page(nand, page, data, data_size, oob, oob_size);
-}
-
-int nand_page_command(struct nand_device *nand, uint32_t page,
-		uint8_t cmd, bool oob_only)
-{
-	if (!nand-&gt;device)
-		return ERROR_NAND_DEVICE_NOT_PROBED;
-
-	if (oob_only &amp;&amp; NAND_CMD_READ0 == cmd &amp;&amp; nand-&gt;page_size &lt;= 512)
-		cmd = NAND_CMD_READOOB;
-
-	nand-&gt;controller-&gt;command(nand, cmd);
-
-	if (nand-&gt;page_size &lt;= 512) {
-		/* small page device */
-
-		/* column (always 0, we start at the beginning of a page/OOB area) */
-		nand-&gt;controller-&gt;address(nand, 0x0);
-
-		/* row */
-		nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
-		nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
-
-		/* 4th cycle only on devices with more than 32 MiB */
-		if (nand-&gt;address_cycles &gt;= 4)
-			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
-
-		/* 5th cycle only on devices with more than 8 GiB */
-		if (nand-&gt;address_cycles &gt;= 5)
-			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 24) &amp; 0xff);
-	} else {
-		/* large page device */
-
-		/* column (0 when we start at the beginning of a page,
-		 * or 2048 for the beginning of OOB area)
-		 */
-		nand-&gt;controller-&gt;address(nand, 0x0);
-		if (oob_only)
-			nand-&gt;controller-&gt;address(nand, 0x8);
-		else
-			nand-&gt;controller-&gt;address(nand, 0x0);
-
-		/* row */
-		nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
-		nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
-
-		/* 5th cycle only on devices with more than 128 MiB */
-		if (nand-&gt;address_cycles &gt;= 5)
-			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
-
-		/* large page devices need a start command if reading */
-		if (NAND_CMD_READ0 == cmd)
-			nand-&gt;controller-&gt;command(nand, NAND_CMD_READSTART);
-	}
-
-	if (nand-&gt;controller-&gt;nand_ready) {
-		if (!nand-&gt;controller-&gt;nand_ready(nand, 100))
-			return ERROR_NAND_OPERATION_TIMEOUT;
-	} else {
-		alive_sleep(1);
-	}
-
-	return ERROR_OK;
-}
-
-int nand_read_page_raw(struct nand_device *nand, uint32_t page,
-		uint8_t *data, uint32_t data_size,
-		uint8_t *oob, uint32_t oob_size)
-{
-	uint32_t i;
-	int retval;
-
-	retval = nand_page_command(nand, page, NAND_CMD_READ0, !data);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (data)
-	{
-		if (nand-&gt;controller-&gt;read_block_data != NULL)
-			(nand-&gt;controller-&gt;read_block_data)(nand, data, data_size);
-		else
-		{
-			for (i = 0; i &lt; data_size;)
-			{
-				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
-				{
-					nand-&gt;controller-&gt;read_data(nand, data);
-					data += 2;
-					i += 2;
-				}
-				else
-				{
-					nand-&gt;controller-&gt;read_data(nand, data);
-					data += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	if (oob)
-	{
-		if (nand-&gt;controller-&gt;read_block_data != NULL)
-			(nand-&gt;controller-&gt;read_block_data)(nand, oob, oob_size);
-		else
-		{
-			for (i = 0; i &lt; oob_size;)
-			{
-				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
-				{
-					nand-&gt;controller-&gt;read_data(nand, oob);
-					oob += 2;
-					i += 2;
-				}
-				else
-				{
-					nand-&gt;controller-&gt;read_data(nand, oob);
-					oob += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	return ERROR_OK;
-}
-
-int nand_write_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
-{
-	uint32_t i;
-	int retval;
-	uint8_t status;
-
-	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (data)
-	{
-		if (nand-&gt;controller-&gt;write_block_data != NULL)
-			(nand-&gt;controller-&gt;write_block_data)(nand, data, data_size);
-		else
-		{
-			for (i = 0; i &lt; data_size;)
-			{
-				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
-				{
-					uint16_t data_buf = le_to_h_u16(data);
-					nand-&gt;controller-&gt;write_data(nand, data_buf);
-					data += 2;
-					i += 2;
-				}
-				else
-				{
-					nand-&gt;controller-&gt;write_data(nand, *data);
-					data += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	if (oob)
-	{
-		if (nand-&gt;controller-&gt;write_block_data != NULL)
-			(nand-&gt;controller-&gt;write_block_data)(nand, oob, oob_size);
-		else
-		{
-			for (i = 0; i &lt; oob_size;)
-			{
-				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
-				{
-					uint16_t oob_buf = le_to_h_u16(data);
-					nand-&gt;controller-&gt;write_data(nand, oob_buf);
-					oob += 2;
-					i += 2;
-				}
-				else
-				{
-					nand-&gt;controller-&gt;write_data(nand, *oob);
-					oob += 1;
-					i += 1;
-				}
-			}
-		}
-	}
-
-	nand-&gt;controller-&gt;command(nand, NAND_CMD_PAGEPROG);
-
-	retval = nand-&gt;controller-&gt;nand_ready ?
-			nand-&gt;controller-&gt;nand_ready(nand, 100) :
-			nand_poll_ready(nand, 100);
-	if (!retval)
-		return ERROR_NAND_OPERATION_TIMEOUT;
-
-	if ((retval = nand_read_status(nand, &amp;status)) != ERROR_OK)
-	{
-		LOG_ERROR(&quot;couldn't read status&quot;);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	if (status &amp; NAND_STATUS_FAIL)
-	{
-		LOG_ERROR(&quot;write operation didn't pass, status: 0x%2.2x&quot;, status);
-		return ERROR_NAND_OPERATION_FAILED;
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_list_command)
-{
-	struct nand_device *p;
-	int i;
-
-	if (!nand_devices)
-	{
-		command_print(CMD_CTX, &quot;no NAND flash devices configured&quot;);
-		return ERROR_OK;
-	}
-
-	for (p = nand_devices, i = 0; p; p = p-&gt;next, i++)
-	{
-		if (p-&gt;device)
-			command_print(CMD_CTX, &quot;#%i: %s (%s) &quot;
-				&quot;pagesize: %i, buswidth: %i,\n\t&quot;
-				&quot;blocksize: %i, blocks: %i&quot;,
-				i, p-&gt;device-&gt;name, p-&gt;manufacturer-&gt;name,
-				p-&gt;page_size, p-&gt;bus_width,
-				p-&gt;erase_size, p-&gt;num_blocks);
-		else
-			command_print(CMD_CTX, &quot;#%i: not probed&quot;, i);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_info_command)
-{
-	int i = 0;
-	int j = 0;
-	int first = -1;
-	int last = -1;
-
-	switch (CMD_ARGC) {
-	default:
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	case 1:
-		first = 0;
-		last = INT32_MAX;
-		break;
-	case 2:
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], i);
-		first = last = i;
-		i = 0;
-		break;
-	case 3:
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], first);
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], last);
-		break;
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (NULL == p-&gt;device)
-	{
-		command_print(CMD_CTX, &quot;#%s: not probed&quot;, CMD_ARGV[0]);
-		return ERROR_OK;
-	}
-
-	if (first &gt;= p-&gt;num_blocks)
-		first = p-&gt;num_blocks - 1;
-
-	if (last &gt;= p-&gt;num_blocks)
-		last = p-&gt;num_blocks - 1;
-
-	command_print(CMD_CTX, &quot;#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i&quot;,
-		i++, p-&gt;device-&gt;name, p-&gt;manufacturer-&gt;name, p-&gt;page_size, p-&gt;bus_width, p-&gt;erase_size);
-
-	for (j = first; j &lt;= last; j++)
-	{
-		char *erase_state, *bad_state;
-
-		if (p-&gt;blocks[j].is_erased == 0)
-			erase_state = &quot;not erased&quot;;
-		else if (p-&gt;blocks[j].is_erased == 1)
-			erase_state = &quot;erased&quot;;
-		else
-			erase_state = &quot;erase state unknown&quot;;
-
-		if (p-&gt;blocks[j].is_bad == 0)
-			bad_state = &quot;&quot;;
-		else if (p-&gt;blocks[j].is_bad == 1)
-			bad_state = &quot; (marked bad)&quot;;
-		else
-			bad_state = &quot; (block condition unknown)&quot;;
-
-		command_print(CMD_CTX,
-			      &quot;\t#%i: 0x%8.8&quot; PRIx32 &quot; (%&quot; PRId32 &quot;kB) %s%s&quot;,
-			      j,
-			      p-&gt;blocks[j].offset,
-			      p-&gt;blocks[j].size / 1024,
-			      erase_state,
-			      bad_state);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_probe_command)
-{
-	if (CMD_ARGC != 1)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if ((retval = nand_probe(p)) == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;NAND flash device '%s' found&quot;, p-&gt;device-&gt;name);
-	}
-	else if (retval == ERROR_NAND_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, &quot;probing failed for NAND flash device&quot;);
-	}
-	else
-	{
-		command_print(CMD_CTX, &quot;unknown error when probing NAND flash device&quot;);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_erase_command)
-{
-	if (CMD_ARGC != 1 &amp;&amp; CMD_ARGC != 3)
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	unsigned long offset;
-	unsigned long length;
-
-	/* erase specified part of the chip; or else everything */
-	if (CMD_ARGC == 3) {
-		unsigned long size = p-&gt;erase_size * p-&gt;num_blocks;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
-		if ((offset % p-&gt;erase_size) != 0 || offset &gt;= size)
-			return ERROR_INVALID_ARGUMENTS;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
-		if ((length == 0) || (length % p-&gt;erase_size) != 0
-				|| (length + offset) &gt; size)
-			return ERROR_INVALID_ARGUMENTS;
-
-		offset /= p-&gt;erase_size;
-		length /= p-&gt;erase_size;
-	} else {
-		offset = 0;
-		length = p-&gt;num_blocks;
-	}
-
-	retval = nand_erase(p, offset, offset + length - 1);
-	if (retval == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;erased blocks %lu to %lu &quot;
-				&quot;on NAND flash device #%s '%s'&quot;,
-				offset, offset + length,
-				CMD_ARGV[0], p-&gt;device-&gt;name);
-	}
-	else if (retval == ERROR_NAND_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, &quot;erase failed&quot;);
-	}
-	else
-	{
-		command_print(CMD_CTX, &quot;unknown error when erasing NAND flash device&quot;);
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_check_bad_blocks_command)
-{
-	int first = -1;
-	int last = -1;
-
-	if ((CMD_ARGC &lt; 1) || (CMD_ARGC &gt; 3) || (CMD_ARGC == 2))
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (CMD_ARGC == 3)
-	{
-		unsigned long offset;
-		unsigned long length;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
-		if (offset % p-&gt;erase_size)
-			return ERROR_INVALID_ARGUMENTS;
-		offset /= p-&gt;erase_size;
-
-		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
-		if (length % p-&gt;erase_size)
-			return ERROR_INVALID_ARGUMENTS;
-
-		length -= 1;
-		length /= p-&gt;erase_size;
-
-		first = offset;
-		last = offset + length;
-	}
-
-	retval = nand_build_bbt(p, first, last);
-	if (retval == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;checked NAND flash device for bad blocks, &quot;
-				&quot;use \&quot;nand info\&quot; command to list blocks&quot;);
-	}
-	else if (retval == ERROR_NAND_OPERATION_FAILED)
-	{
-		command_print(CMD_CTX, &quot;error when checking for bad blocks on &quot;
-				&quot;NAND flash device&quot;);
-	}
-	else
-	{
-		command_print(CMD_CTX, &quot;unknown error when checking for bad &quot;
-				&quot;blocks on NAND flash device&quot;);
-	}
-
-	return ERROR_OK;
-}
-
-struct nand_fileio_state {
-	uint32_t address;
-	uint32_t size;
-
-	uint8_t *page;
-	uint32_t page_size;
-
-	enum oob_formats oob_format;
-	uint8_t *oob;
-	uint32_t oob_size;
-
-	const int *eccpos;
-
-	bool file_opened;
-	struct fileio fileio;
-
-	struct duration bench;
-};
-
-static void nand_fileio_init(struct nand_fileio_state *state)
-{
-	memset(state, 0, sizeof(*state));
-	state-&gt;oob_format = NAND_OOB_NONE;
-}
-
-static int nand_fileio_start(struct command_context *cmd_ctx,
-		struct nand_device *nand, const char *filename, int filemode,
-		struct nand_fileio_state *state)
-{
-	if (state-&gt;address % nand-&gt;page_size)
-	{
-		command_print(cmd_ctx, &quot;only page-aligned addresses are supported&quot;);
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	duration_start(&amp;state-&gt;bench);
-
-	if (NULL != filename)
-	{
-		int retval = fileio_open(&amp;state-&gt;fileio, filename, filemode, FILEIO_BINARY);
-		if (ERROR_OK != retval)
-		{
-			const char *msg = (FILEIO_READ == filemode) ? &quot;read&quot; : &quot;write&quot;;
-			command_print(cmd_ctx, &quot;failed to open '%s' for %s access&quot;,
-					filename, msg);
-			return retval;
-		}
-		state-&gt;file_opened = true;
-	}
-
-	if (!(state-&gt;oob_format &amp; NAND_OOB_ONLY))
-	{
-		state-&gt;page_size = nand-&gt;page_size;
-		state-&gt;page = malloc(nand-&gt;page_size);
-	}
-
-	if (state-&gt;oob_format &amp; (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
-	{
-		if (nand-&gt;page_size == 512)
-		{
-			state-&gt;oob_size = 16;
-			state-&gt;eccpos = nand_oob_16.eccpos;
-		}
-		else if (nand-&gt;page_size == 2048)
-		{
-			state-&gt;oob_size = 64;
-			state-&gt;eccpos = nand_oob_64.eccpos;
-		}
-		state-&gt;oob = malloc(state-&gt;oob_size);
-	}
-
-	return ERROR_OK;
-}
-static int nand_fileio_cleanup(struct nand_fileio_state *state)
-{
-	if (state-&gt;file_opened)
-		fileio_close(&amp;state-&gt;fileio);
-
-	if (state-&gt;oob)
-	{
-		free(state-&gt;oob);
-		state-&gt;oob = NULL;
-	}
-	if (state-&gt;page)
-	{
-		free(state-&gt;page);
-		state-&gt;page = NULL;
-	}
-	return ERROR_OK;
-}
-static int nand_fileio_finish(struct nand_fileio_state *state)
-{
-	nand_fileio_cleanup(state);
-	return duration_measure(&amp;state-&gt;bench);
-}
-
-static COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
-		struct nand_device **dev, enum fileio_access filemode,
-		bool need_size, bool sw_ecc)
-{
-	nand_fileio_init(state);
-
-	unsigned minargs = need_size ? 4 : 3;
-	if (CMD_ARGC &lt; minargs)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	struct nand_device *nand;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;nand);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (NULL == nand-&gt;device)
-	{
-		command_print(CMD_CTX, &quot;#%s: not probed&quot;, CMD_ARGV[0]);
-		return ERROR_OK;
-	}
-
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], state-&gt;address);
-	if (need_size)
-	{
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], state-&gt;size);
-			if (state-&gt;size % nand-&gt;page_size)
-			{
-				command_print(CMD_CTX, &quot;only page-aligned sizes are supported&quot;);
-				return ERROR_COMMAND_SYNTAX_ERROR;
-			}
-	}
-
-	if (CMD_ARGC &gt; minargs)
-	{
-		for (unsigned i = minargs; i &lt; CMD_ARGC; i++)
-		{
-			if (!strcmp(CMD_ARGV[i], &quot;oob_raw&quot;))
-				state-&gt;oob_format |= NAND_OOB_RAW;
-			else if (!strcmp(CMD_ARGV[i], &quot;oob_only&quot;))
-				state-&gt;oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
-			else if (sw_ecc &amp;&amp; !strcmp(CMD_ARGV[i], &quot;oob_softecc&quot;))
-				state-&gt;oob_format |= NAND_OOB_SW_ECC;
-			else if (sw_ecc &amp;&amp; !strcmp(CMD_ARGV[i], &quot;oob_softecc_kw&quot;))
-				state-&gt;oob_format |= NAND_OOB_SW_ECC_KW;
-			else
-			{
-				command_print(CMD_CTX, &quot;unknown option: %s&quot;, CMD_ARGV[i]);
-				return ERROR_COMMAND_SYNTAX_ERROR;
-			}
-		}
-	}
-
-	retval = nand_fileio_start(CMD_CTX, nand, CMD_ARGV[1], filemode, state);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (!need_size)
-		state-&gt;size = state-&gt;fileio.size;
-
-	*dev = nand;
-
-	return ERROR_OK;
-}
-
-/**
- * @returns If no error occurred, returns number of bytes consumed;
- * otherwise, returns a negative error code.)
- */
-static int nand_fileio_read(struct nand_device *nand,
-		struct nand_fileio_state *s)
-{
-	size_t total_read = 0;
-	size_t one_read;
-
-	if (NULL != s-&gt;page)
-	{
-		fileio_read(&amp;s-&gt;fileio, s-&gt;page_size, s-&gt;page, &amp;one_read);
-		if (one_read &lt; s-&gt;page_size)
-			memset(s-&gt;page + one_read, 0xff, s-&gt;page_size - one_read);
-		total_read += one_read;
-	}
-
-	if (s-&gt;oob_format &amp; NAND_OOB_SW_ECC)
-	{
-		uint8_t ecc[3];
-		memset(s-&gt;oob, 0xff, s-&gt;oob_size);
-		for (uint32_t i = 0, j = 0; i &lt; s-&gt;page_size; i += 256)
-		{
-			nand_calculate_ecc(nand, s-&gt;page + i, ecc);
-			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[0];
-			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[1];
-			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[2];
-		}
-	}
-	else if (s-&gt;oob_format &amp; NAND_OOB_SW_ECC_KW)
-	{
-		/*
-		 * In this case eccpos is not used as
-		 * the ECC data is always stored contigously
-		 * at the end of the OOB area.  It consists
-		 * of 10 bytes per 512-byte data block.
-		 */
-		uint8_t *ecc = s-&gt;oob + s-&gt;oob_size - s-&gt;page_size / 512 * 10;
-		memset(s-&gt;oob, 0xff, s-&gt;oob_size);
-		for (uint32_t i = 0; i &lt; s-&gt;page_size; i += 512)
-		{
-			nand_calculate_ecc_kw(nand, s-&gt;page + i, ecc);
-			ecc += 10;
-		}
-	}
-	else if (NULL != s-&gt;oob)
-	{
-		fileio_read(&amp;s-&gt;fileio, s-&gt;oob_size, s-&gt;oob, &amp;one_read);
-		if (one_read &lt; s-&gt;oob_size)
-			memset(s-&gt;oob + one_read, 0xff, s-&gt;oob_size - one_read);
-		total_read += one_read;
-	}
-	return total_read;
-}
-
-COMMAND_HANDLER(handle_nand_write_command)
-{
-	struct nand_device *nand = NULL;
-	struct nand_fileio_state s;
-	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
-			&amp;s, &amp;nand, FILEIO_READ, false, true);
-	if (ERROR_OK != retval)
-		return retval;
-
-	uint32_t total_bytes = s.size;
-	while (s.size &gt; 0)
-	{
-		int bytes_read = nand_fileio_read(nand, &amp;s);
-		if (bytes_read &lt;= 0)
-		{
-			command_print(CMD_CTX, &quot;error while reading file&quot;);
-			return nand_fileio_cleanup(&amp;s);
-		}
-		s.size -= bytes_read;
-
-		retval = nand_write_page(nand, s.address / nand-&gt;page_size,
-				s.page, s.page_size, s.oob, s.oob_size);
-		if (ERROR_OK != retval)
-		{
-			command_print(CMD_CTX, &quot;failed writing file %s &quot;
-				&quot;to NAND flash %s at offset 0x%8.8&quot; PRIx32,
-				CMD_ARGV[1], CMD_ARGV[0], s.address);
-			return nand_fileio_cleanup(&amp;s);
-		}
-		s.address += s.page_size;
-	}
-
-	if (nand_fileio_finish(&amp;s))
-	{
-		command_print(CMD_CTX, &quot;wrote file %s to NAND flash %s up to &quot;
-				&quot;offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
-				CMD_ARGV[1], CMD_ARGV[0], s.address, duration_elapsed(&amp;s.bench),
-				duration_kbps(&amp;s.bench, total_bytes));
-	}
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_verify_command)
-{
-	struct nand_device *nand = NULL;
-	struct nand_fileio_state file;
-	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
-			&amp;file, &amp;nand, FILEIO_READ, false, true);
-	if (ERROR_OK != retval)
-		return retval;
-
-	struct nand_fileio_state dev;
-	nand_fileio_init(&amp;dev);
-	dev.address = file.address;
-	dev.size = file.size;
-	dev.oob_format = file.oob_format;
-	retval = nand_fileio_start(CMD_CTX, nand, NULL, FILEIO_NONE, &amp;dev);
-	if (ERROR_OK != retval)
-		return retval;
-
-	while (file.size &gt; 0)
-	{
-		int retval = nand_read_page(nand, dev.address / dev.page_size,
-				dev.page, dev.page_size, dev.oob, dev.oob_size);
-		if (ERROR_OK != retval)
-		{
-			command_print(CMD_CTX, &quot;reading NAND flash page failed&quot;);
-			nand_fileio_cleanup(&amp;dev);
-			return nand_fileio_cleanup(&amp;file);
-		}
-
-		int bytes_read = nand_fileio_read(nand, &amp;file);
-		if (bytes_read &lt;= 0)
-		{
-			command_print(CMD_CTX, &quot;error while reading file&quot;);
-			nand_fileio_cleanup(&amp;dev);
-			return nand_fileio_cleanup(&amp;file);
-		}
-
-		if ((dev.page &amp;&amp; memcmp(dev.page, file.page, dev.page_size)) ||
-		    (dev.oob &amp;&amp; memcmp(dev.oob, file.oob, dev.oob_size)) )
-		{
-			command_print(CMD_CTX, &quot;NAND flash contents differ &quot;
-						&quot;at 0x%8.8&quot; PRIx32, dev.address);
-			nand_fileio_cleanup(&amp;dev);
-			return nand_fileio_cleanup(&amp;file);
-		}
-
-		file.size -= bytes_read;
-		dev.address += nand-&gt;page_size;
-	}
-
-	if (nand_fileio_finish(&amp;file) == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;verified file %s in NAND flash %s &quot;
-				&quot;up to offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
-				CMD_ARGV[1], CMD_ARGV[0], dev.address, duration_elapsed(&amp;file.bench),
-				duration_kbps(&amp;file.bench, dev.size));
-	}
-
-	return nand_fileio_cleanup(&amp;dev);
-}
-
-COMMAND_HANDLER(handle_nand_dump_command)
-{
-	struct nand_device *nand = NULL;
-	struct nand_fileio_state s;
-	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
-			&amp;s, &amp;nand, FILEIO_WRITE, true, false);
-	if (ERROR_OK != retval)
-		return retval;
-
-	while (s.size &gt; 0)
-	{
-		size_t size_written;
-		int retval = nand_read_page(nand, s.address / nand-&gt;page_size,
-				s.page, s.page_size, s.oob, s.oob_size);
-		if (ERROR_OK != retval)
-		{
-			command_print(CMD_CTX, &quot;reading NAND flash page failed&quot;);
-			return nand_fileio_cleanup(&amp;s);
-		}
-
-		if (NULL != s.page)
-			fileio_write(&amp;s.fileio, s.page_size, s.page, &amp;size_written);
-
-		if (NULL != s.oob)
-			fileio_write(&amp;s.fileio, s.oob_size, s.oob, &amp;size_written);
-
-		s.size -= nand-&gt;page_size;
-		s.address += nand-&gt;page_size;
-	}
-
-	if (nand_fileio_finish(&amp;s) == ERROR_OK)
-	{
-		command_print(CMD_CTX, &quot;dumped %zu bytes in %fs (%0.3f kb/s)&quot;, 
-				s.fileio.size, duration_elapsed(&amp;s.bench),
-				duration_kbps(&amp;s.bench, s.fileio.size));
-	}
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_nand_raw_access_command)
-{
-	if ((CMD_ARGC &lt; 1) || (CMD_ARGC &gt; 2))
-	{
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	struct nand_device *p;
-	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
-	if (ERROR_OK != retval)
-		return retval;
-
-	if (NULL == p-&gt;device)
-	{
-		command_print(CMD_CTX, &quot;#%s: not probed&quot;, CMD_ARGV[0]);
-		return ERROR_OK;
-	}
-
-	if (CMD_ARGC == 2)
-		COMMAND_PARSE_ENABLE(CMD_ARGV[1], p-&gt;use_raw);
-
-	const char *msg = p-&gt;use_raw ? &quot;enabled&quot; : &quot;disabled&quot;;
-	command_print(CMD_CTX, &quot;raw access is %s&quot;, msg);
-
-	return ERROR_OK;
-}
-
-static const struct command_registration nand_exec_command_handlers[] = {
-	{
-		.name = &quot;list&quot;,
-		.handler = &amp;handle_nand_list_command,
-		.mode = COMMAND_EXEC,
-		.help = &quot;list configured NAND flash devices&quot;,
-	},
-	{
-		.name = &quot;info&quot;,
-		.handler = &amp;handle_nand_info_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt;&quot;,
-		.help = &quot;print info about a NAND flash device&quot;,
-	},
-	{
-		.name = &quot;probe&quot;,
-		.handler = &amp;handle_nand_probe_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt;&quot;,
-		.help = &quot;identify NAND flash device &lt;num&gt;&quot;,
-
-	},
-	{
-		.name = &quot;check_bad_blocks&quot;,
-		.handler = &amp;handle_nand_check_bad_blocks_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; [&lt;offset&gt; &lt;length&gt;]&quot;,
-		.help = &quot;check NAND flash device &lt;num&gt; for bad blocks&quot;,
-	},
-	{
-		.name = &quot;erase&quot;,
-		.handler = &amp;handle_nand_erase_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; [&lt;offset&gt; &lt;length&gt;]&quot;,
-		.help = &quot;erase blocks on NAND flash device&quot;,
-	},
-	{
-		.name = &quot;dump&quot;,
-		.handler = &amp;handle_nand_dump_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;filename&gt; &lt;offset&gt; &lt;length&gt; &quot;
-			&quot;[oob_raw | oob_only]&quot;,
-		.help = &quot;dump from NAND flash device&quot;,
-	},
-	{
-		.name = &quot;verify&quot;,
-		.handler = &amp;handle_nand_verify_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;filename&gt; &lt;offset&gt; &quot;
-			&quot;[oob_raw | oob_only | oob_softecc | oob_softecc_kw]&quot;,
-		.help = &quot;verify NAND flash device&quot;,
-	},
-	{
-		.name = &quot;write&quot;,
-		.handler = &amp;handle_nand_write_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;bank&gt; &lt;filename&gt; &lt;offset&gt; &quot;
-			&quot;[oob_raw | oob_only | oob_softecc | oob_softecc_kw]&quot;,
-		.help = &quot;write to NAND flash device&quot;,
-	},
-	{
-		.name = &quot;raw_access&quot;,
-		.handler = &amp;handle_nand_raw_access_command,
-		.mode = COMMAND_EXEC,
-		.usage = &quot;&lt;num&gt; ['enable'|'disable']&quot;,
-		.help = &quot;raw access to NAND flash device&quot;,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-
-int nand_init(struct command_context *cmd_ctx)
-{
-	if (!nand_devices)
-		return ERROR_OK;
-	struct command *parent = command_find_in_context(cmd_ctx, &quot;nand&quot;);
-	return register_commands(cmd_ctx, parent, nand_exec_command_handlers);
-}
-
-COMMAND_HANDLER(handle_nand_init_command)
-{
-	if (CMD_ARGC != 0)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	static bool nand_initialized = false;
-	if (nand_initialized)
-	{
-		LOG_INFO(&quot;'nand init' has already been called&quot;);
-		return ERROR_OK;
-	}
-	nand_initialized = true;
-
-	LOG_DEBUG(&quot;Initializing NAND devices...&quot;);
-	return nand_init(CMD_CTX);
-}
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 7d250f6..3885a7b 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -3,6 +3,9 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 noinst_LTLIBRARIES = libocdflashnand.la
 
 libocdflashnand_la_SOURCES = \
+	core.c \
+	fileio.c \
+	tcl.c \
 	$(NAND_DRIVERS) \
 	driver.c
 
diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
new file mode 100644
index 0000000..46f5454
--- /dev/null
+++ b/src/flash/nand/core.c
@@ -0,0 +1,917 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2002 Thomas Gleixner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">tglx at linutronix.de</A>&gt;               *
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &lt;flash/nand.h&gt;
+#include &lt;flash/common.h&gt;
+#include &quot;imp.h&quot;
+
+/* configured NAND devices and NAND Flash command handler */
+struct nand_device *nand_devices = NULL;
+
+void nand_device_add(struct nand_device *c)
+{
+	if (nand_devices) {
+		struct nand_device *p = nand_devices;
+		while (p &amp;&amp; p-&gt;next) p = p-&gt;next;
+		p-&gt;next = c;
+	} else
+		nand_devices = c;
+}
+
+
+/*	Chip ID list
+ *
+ *	Name, ID code, pagesize, chipsize in MegaByte, eraseblock size,
+ *	options
+ *
+ *	Pagesize; 0, 256, 512
+ *	0	get this information from the extended chip ID
+ *	256	256 Byte page size
+ *	512	512 Byte page size
+ */
+static struct nand_info nand_flash_ids[] =
+{
+	/* start &quot;museum&quot; IDs */
+	{&quot;NAND 1MiB 5V 8-bit&quot;,		0x6e, 256, 1, 0x1000, 0},
+	{&quot;NAND 2MiB 5V 8-bit&quot;,		0x64, 256, 2, 0x1000, 0},
+	{&quot;NAND 4MiB 5V 8-bit&quot;,		0x6b, 512, 4, 0x2000, 0},
+	{&quot;NAND 1MiB 3,3V 8-bit&quot;,	0xe8, 256, 1, 0x1000, 0},
+	{&quot;NAND 1MiB 3,3V 8-bit&quot;,	0xec, 256, 1, 0x1000, 0},
+	{&quot;NAND 2MiB 3,3V 8-bit&quot;,	0xea, 256, 2, 0x1000, 0},
+	{&quot;NAND 4MiB 3,3V 8-bit&quot;,	0xd5, 512, 4, 0x2000, 0},
+	{&quot;NAND 4MiB 3,3V 8-bit&quot;,	0xe3, 512, 4, 0x2000, 0},
+	{&quot;NAND 4MiB 3,3V 8-bit&quot;,	0xe5, 512, 4, 0x2000, 0},
+	{&quot;NAND 8MiB 3,3V 8-bit&quot;,	0xd6, 512, 8, 0x2000, 0},
+
+	{&quot;NAND 8MiB 1,8V 8-bit&quot;,	0x39, 512, 8, 0x2000, 0},
+	{&quot;NAND 8MiB 3,3V 8-bit&quot;,	0xe6, 512, 8, 0x2000, 0},
+	{&quot;NAND 8MiB 1,8V 16-bit&quot;,	0x49, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+	{&quot;NAND 8MiB 3,3V 16-bit&quot;,	0x59, 512, 8, 0x2000, NAND_BUSWIDTH_16},
+	/* end &quot;museum&quot; IDs */
+
+	{&quot;NAND 16MiB 1,8V 8-bit&quot;,	0x33, 512, 16, 0x4000, 0},
+	{&quot;NAND 16MiB 3,3V 8-bit&quot;,	0x73, 512, 16, 0x4000, 0},
+	{&quot;NAND 16MiB 1,8V 16-bit&quot;,	0x43, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+	{&quot;NAND 16MiB 3,3V 16-bit&quot;,	0x53, 512, 16, 0x4000, NAND_BUSWIDTH_16},
+
+	{&quot;NAND 32MiB 1,8V 8-bit&quot;,	0x35, 512, 32, 0x4000, 0},
+	{&quot;NAND 32MiB 3,3V 8-bit&quot;,	0x75, 512, 32, 0x4000, 0},
+	{&quot;NAND 32MiB 1,8V 16-bit&quot;,	0x45, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+	{&quot;NAND 32MiB 3,3V 16-bit&quot;,	0x55, 512, 32, 0x4000, NAND_BUSWIDTH_16},
+
+	{&quot;NAND 64MiB 1,8V 8-bit&quot;,	0x36, 512, 64, 0x4000, 0},
+	{&quot;NAND 64MiB 3,3V 8-bit&quot;,	0x76, 512, 64, 0x4000, 0},
+	{&quot;NAND 64MiB 1,8V 16-bit&quot;,	0x46, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+	{&quot;NAND 64MiB 3,3V 16-bit&quot;,	0x56, 512, 64, 0x4000, NAND_BUSWIDTH_16},
+
+	{&quot;NAND 128MiB 1,8V 8-bit&quot;,	0x78, 512, 128, 0x4000, 0},
+	{&quot;NAND 128MiB 1,8V 8-bit&quot;,	0x39, 512, 128, 0x4000, 0},
+	{&quot;NAND 128MiB 3,3V 8-bit&quot;,	0x79, 512, 128, 0x4000, 0},
+	{&quot;NAND 128MiB 1,8V 16-bit&quot;,	0x72, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{&quot;NAND 128MiB 1,8V 16-bit&quot;,	0x49, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{&quot;NAND 128MiB 3,3V 16-bit&quot;,	0x74, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+	{&quot;NAND 128MiB 3,3V 16-bit&quot;,	0x59, 512, 128, 0x4000, NAND_BUSWIDTH_16},
+
+	{&quot;NAND 256MiB 3,3V 8-bit&quot;,	0x71, 512, 256, 0x4000, 0},
+
+	{&quot;NAND 64MiB 1,8V 8-bit&quot;,	0xA2, 0,  64, 0, LP_OPTIONS},
+	{&quot;NAND 64MiB 3,3V 8-bit&quot;,	0xF2, 0,  64, 0, LP_OPTIONS},
+	{&quot;NAND 64MiB 1,8V 16-bit&quot;,	0xB2, 0,  64, 0, LP_OPTIONS16},
+	{&quot;NAND 64MiB 3,3V 16-bit&quot;,	0xC2, 0,  64, 0, LP_OPTIONS16},
+
+	{&quot;NAND 128MiB 1,8V 8-bit&quot;,	0xA1, 0, 128, 0, LP_OPTIONS},
+	{&quot;NAND 128MiB 3,3V 8-bit&quot;,	0xF1, 0, 128, 0, LP_OPTIONS},
+	{&quot;NAND 128MiB 1,8V 16-bit&quot;,	0xB1, 0, 128, 0, LP_OPTIONS16},
+	{&quot;NAND 128MiB 3,3V 16-bit&quot;,	0xC1, 0, 128, 0, LP_OPTIONS16},
+
+	{&quot;NAND 256MiB 1,8V 8-bit&quot;,	0xAA, 0, 256, 0, LP_OPTIONS},
+	{&quot;NAND 256MiB 3,3V 8-bit&quot;,	0xDA, 0, 256, 0, LP_OPTIONS},
+	{&quot;NAND 256MiB 1,8V 16-bit&quot;,	0xBA, 0, 256, 0, LP_OPTIONS16},
+	{&quot;NAND 256MiB 3,3V 16-bit&quot;,	0xCA, 0, 256, 0, LP_OPTIONS16},
+
+	{&quot;NAND 512MiB 1,8V 8-bit&quot;,	0xAC, 0, 512, 0, LP_OPTIONS},
+	{&quot;NAND 512MiB 3,3V 8-bit&quot;,	0xDC, 0, 512, 0, LP_OPTIONS},
+	{&quot;NAND 512MiB 1,8V 16-bit&quot;,	0xBC, 0, 512, 0, LP_OPTIONS16},
+	{&quot;NAND 512MiB 3,3V 16-bit&quot;,	0xCC, 0, 512, 0, LP_OPTIONS16},
+
+	{&quot;NAND 1GiB 1,8V 8-bit&quot;,	0xA3, 0, 1024, 0, LP_OPTIONS},
+	{&quot;NAND 1GiB 3,3V 8-bit&quot;,	0xD3, 0, 1024, 0, LP_OPTIONS},
+	{&quot;NAND 1GiB 1,8V 16-bit&quot;,	0xB3, 0, 1024, 0, LP_OPTIONS16},
+	{&quot;NAND 1GiB 3,3V 16-bit&quot;,	0xC3, 0, 1024, 0, LP_OPTIONS16},
+
+	{&quot;NAND 2GiB 1,8V 8-bit&quot;,	0xA5, 0, 2048, 0, LP_OPTIONS},
+	{&quot;NAND 2GiB 3,3V 8-bit&quot;,	0xD5, 0, 2048, 0, LP_OPTIONS},
+	{&quot;NAND 2GiB 1,8V 16-bit&quot;,	0xB5, 0, 2048, 0, LP_OPTIONS16},
+	{&quot;NAND 2GiB 3,3V 16-bit&quot;,	0xC5, 0, 2048, 0, LP_OPTIONS16},
+
+	{NULL, 0, 0, 0, 0, 0 }
+};
+
+/* Manufacturer ID list
+ */
+static struct nand_manufacturer nand_manuf_ids[] =
+{
+	{0x0, &quot;unknown&quot;},
+	{NAND_MFR_TOSHIBA, &quot;Toshiba&quot;},
+	{NAND_MFR_SAMSUNG, &quot;Samsung&quot;},
+	{NAND_MFR_FUJITSU, &quot;Fujitsu&quot;},
+	{NAND_MFR_NATIONAL, &quot;National&quot;},
+	{NAND_MFR_RENESAS, &quot;Renesas&quot;},
+	{NAND_MFR_STMICRO, &quot;ST Micro&quot;},
+	{NAND_MFR_HYNIX, &quot;Hynix&quot;},
+	{NAND_MFR_MICRON, &quot;Micron&quot;},
+	{0x0, NULL},
+};
+
+/*
+ * Define default oob placement schemes for large and small page devices
+ */
+
+#if 0
+static struct nand_ecclayout nand_oob_8 = {
+	.eccbytes = 3,
+	.eccpos = {0, 1, 2},
+	.oobfree = {
+		{.offset = 3,
+		 .length = 2},
+		{.offset = 6,
+		 .length = 2}}
+};
+#endif
+
+struct nand_device *get_nand_device_by_name(const char *name)
+{
+	unsigned requested = get_flash_name_index(name);
+	unsigned found = 0;
+
+	struct nand_device *nand;
+	for (nand = nand_devices; NULL != nand; nand = nand-&gt;next)
+	{
+		if (strcmp(nand-&gt;name, name) == 0)
+			return nand;
+		if (!flash_driver_name_matches(nand-&gt;controller-&gt;name, name))
+			continue;
+		if (++found &lt; requested)
+			continue;
+		return nand;
+	}
+	return NULL;
+}
+
+struct nand_device *get_nand_device_by_num(int num)
+{
+	struct nand_device *p;
+	int i = 0;
+
+	for (p = nand_devices; p; p = p-&gt;next)
+	{
+		if (i++ == num)
+		{
+			return p;
+		}
+	}
+
+	return NULL;
+}
+
+COMMAND_HELPER(nand_command_get_device, unsigned name_index,
+		struct nand_device **nand)
+{
+	const char *str = CMD_ARGV[name_index];
+	*nand = get_nand_device_by_name(str);
+	if (*nand)
+		return ERROR_OK;
+
+	unsigned num;
+	COMMAND_PARSE_NUMBER(uint, str, num);
+	*nand = get_nand_device_by_num(num);
+	if (!*nand) {
+		command_print(CMD_CTX, &quot;NAND flash device '%s' not found&quot;, str);
+		return ERROR_INVALID_ARGUMENTS;
+	}
+	return ERROR_OK;
+}
+
+int nand_build_bbt(struct nand_device *nand, int first, int last)
+{
+	uint32_t page = 0x0;
+	int i;
+	uint8_t oob[6];
+
+	if ((first &lt; 0) || (first &gt;= nand-&gt;num_blocks))
+		first = 0;
+
+	if ((last &gt;= nand-&gt;num_blocks) || (last == -1))
+		last = nand-&gt;num_blocks - 1;
+
+	for (i = first; i &lt; last; i++)
+	{
+		nand_read_page(nand, page, NULL, 0, oob, 6);
+
+		if (((nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16) &amp;&amp; ((oob[0] &amp; oob[1]) != 0xff))
+			|| (((nand-&gt;page_size == 512) &amp;&amp; (oob[5] != 0xff)) ||
+				((nand-&gt;page_size == 2048) &amp;&amp; (oob[0] != 0xff))))
+		{
+			LOG_WARNING(&quot;bad block: %i&quot;, i);
+			nand-&gt;blocks[i].is_bad = 1;
+		}
+		else
+		{
+			nand-&gt;blocks[i].is_bad = 0;
+		}
+
+		page += (nand-&gt;erase_size / nand-&gt;page_size);
+	}
+
+	return ERROR_OK;
+}
+
+int nand_read_status(struct nand_device *nand, uint8_t *status)
+{
+	if (!nand-&gt;device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	/* Send read status command */
+	nand-&gt;controller-&gt;command(nand, NAND_CMD_STATUS);
+
+	alive_sleep(1);
+
+	/* read status */
+	if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
+	{
+		uint16_t data;
+		nand-&gt;controller-&gt;read_data(nand, &amp;data);
+		*status = data &amp; 0xff;
+	}
+	else
+	{
+		nand-&gt;controller-&gt;read_data(nand, status);
+	}
+
+	return ERROR_OK;
+}
+
+static int nand_poll_ready(struct nand_device *nand, int timeout)
+{
+	uint8_t status;
+
+	nand-&gt;controller-&gt;command(nand, NAND_CMD_STATUS);
+	do {
+		if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16) {
+			uint16_t data;
+			nand-&gt;controller-&gt;read_data(nand, &amp;data);
+			status = data &amp; 0xff;
+		} else {
+			nand-&gt;controller-&gt;read_data(nand, &amp;status);
+		}
+		if (status &amp; NAND_STATUS_READY)
+			break;
+		alive_sleep(1);
+	} while (timeout--);
+
+	return (status &amp; NAND_STATUS_READY) != 0;
+}
+
+int nand_probe(struct nand_device *nand)
+{
+	uint8_t manufacturer_id, device_id;
+	uint8_t id_buff[6];
+	int retval;
+	int i;
+
+	/* clear device data */
+	nand-&gt;device = NULL;
+	nand-&gt;manufacturer = NULL;
+
+	/* clear device parameters */
+	nand-&gt;bus_width = 0;
+	nand-&gt;address_cycles = 0;
+	nand-&gt;page_size = 0;
+	nand-&gt;erase_size = 0;
+
+	/* initialize controller (device parameters are zero, use controller default) */
+	if ((retval = nand-&gt;controller-&gt;init(nand) != ERROR_OK))
+	{
+		switch (retval)
+		{
+			case ERROR_NAND_OPERATION_FAILED:
+				LOG_DEBUG(&quot;controller initialization failed&quot;);
+				return ERROR_NAND_OPERATION_FAILED;
+			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
+				LOG_ERROR(&quot;BUG: controller reported that it doesn't support default parameters&quot;);
+				return ERROR_NAND_OPERATION_FAILED;
+			default:
+				LOG_ERROR(&quot;BUG: unknown controller initialization failure&quot;);
+				return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	nand-&gt;controller-&gt;command(nand, NAND_CMD_RESET);
+	nand-&gt;controller-&gt;reset(nand);
+
+	nand-&gt;controller-&gt;command(nand, NAND_CMD_READID);
+	nand-&gt;controller-&gt;address(nand, 0x0);
+
+	if (nand-&gt;bus_width == 8)
+	{
+		nand-&gt;controller-&gt;read_data(nand, &amp;manufacturer_id);
+		nand-&gt;controller-&gt;read_data(nand, &amp;device_id);
+	}
+	else
+	{
+		uint16_t data_buf;
+		nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
+		manufacturer_id = data_buf &amp; 0xff;
+		nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
+		device_id = data_buf &amp; 0xff;
+	}
+
+	for (i = 0; nand_flash_ids[i].name; i++)
+	{
+		if (nand_flash_ids[i].id == device_id)
+		{
+			nand-&gt;device = &amp;nand_flash_ids[i];
+			break;
+		}
+	}
+
+	for (i = 0; nand_manuf_ids[i].name; i++)
+	{
+		if (nand_manuf_ids[i].id == manufacturer_id)
+		{
+			nand-&gt;manufacturer = &amp;nand_manuf_ids[i];
+			break;
+		}
+	}
+
+	if (!nand-&gt;manufacturer)
+	{
+		nand-&gt;manufacturer = &amp;nand_manuf_ids[0];
+		nand-&gt;manufacturer-&gt;id = manufacturer_id;
+	}
+
+	if (!nand-&gt;device)
+	{
+		LOG_ERROR(&quot;unknown NAND flash device found, manufacturer id: 0x%2.2x device id: 0x%2.2x&quot;,
+			manufacturer_id, device_id);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	LOG_DEBUG(&quot;found %s (%s)&quot;, nand-&gt;device-&gt;name, nand-&gt;manufacturer-&gt;name);
+
+	/* initialize device parameters */
+
+	/* bus width */
+	if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
+		nand-&gt;bus_width = 16;
+	else
+		nand-&gt;bus_width = 8;
+
+	/* Do we need extended device probe information? */
+	if (nand-&gt;device-&gt;page_size == 0 ||
+	    nand-&gt;device-&gt;erase_size == 0)
+	{
+		if (nand-&gt;bus_width == 8)
+		{
+			nand-&gt;controller-&gt;read_data(nand, id_buff + 3);
+			nand-&gt;controller-&gt;read_data(nand, id_buff + 4);
+			nand-&gt;controller-&gt;read_data(nand, id_buff + 5);
+		}
+		else
+		{
+			uint16_t data_buf;
+
+			nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
+			id_buff[3] = data_buf;
+
+			nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
+			id_buff[4] = data_buf;
+
+			nand-&gt;controller-&gt;read_data(nand, &amp;data_buf);
+			id_buff[5] = data_buf &gt;&gt; 8;
+		}
+	}
+
+	/* page size */
+	if (nand-&gt;device-&gt;page_size == 0)
+	{
+		nand-&gt;page_size = 1 &lt;&lt; (10 + (id_buff[4] &amp; 3));
+	}
+	else if (nand-&gt;device-&gt;page_size == 256)
+	{
+		LOG_ERROR(&quot;NAND flashes with 256 byte pagesize are not supported&quot;);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+	else
+	{
+		nand-&gt;page_size = nand-&gt;device-&gt;page_size;
+	}
+
+	/* number of address cycles */
+	if (nand-&gt;page_size &lt;= 512)
+	{
+		/* small page devices */
+		if (nand-&gt;device-&gt;chip_size &lt;= 32)
+			nand-&gt;address_cycles = 3;
+		else if (nand-&gt;device-&gt;chip_size &lt;= 8*1024)
+			nand-&gt;address_cycles = 4;
+		else
+		{
+			LOG_ERROR(&quot;BUG: small page NAND device with more than 8 GiB encountered&quot;);
+			nand-&gt;address_cycles = 5;
+		}
+	}
+	else
+	{
+		/* large page devices */
+		if (nand-&gt;device-&gt;chip_size &lt;= 128)
+			nand-&gt;address_cycles = 4;
+		else if (nand-&gt;device-&gt;chip_size &lt;= 32*1024)
+			nand-&gt;address_cycles = 5;
+		else
+		{
+			LOG_ERROR(&quot;BUG: large page NAND device with more than 32 GiB encountered&quot;);
+			nand-&gt;address_cycles = 6;
+		}
+	}
+
+	/* erase size */
+	if (nand-&gt;device-&gt;erase_size == 0)
+	{
+		switch ((id_buff[4] &gt;&gt; 4) &amp; 3) {
+		case 0:
+			nand-&gt;erase_size = 64 &lt;&lt; 10;
+			break;
+		case 1:
+			nand-&gt;erase_size = 128 &lt;&lt; 10;
+			break;
+		case 2:
+			nand-&gt;erase_size = 256 &lt;&lt; 10;
+			break;
+		case 3:
+			nand-&gt;erase_size =512 &lt;&lt; 10;
+			break;
+		}
+	}
+	else
+	{
+		nand-&gt;erase_size = nand-&gt;device-&gt;erase_size;
+	}
+
+	/* initialize controller, but leave parameters at the controllers default */
+	if ((retval = nand-&gt;controller-&gt;init(nand) != ERROR_OK))
+	{
+		switch (retval)
+		{
+			case ERROR_NAND_OPERATION_FAILED:
+				LOG_DEBUG(&quot;controller initialization failed&quot;);
+				return ERROR_NAND_OPERATION_FAILED;
+			case ERROR_NAND_OPERATION_NOT_SUPPORTED:
+				LOG_ERROR(&quot;controller doesn't support requested parameters (buswidth: %i, address cycles: %i, page size: %i)&quot;,
+					nand-&gt;bus_width, nand-&gt;address_cycles, nand-&gt;page_size);
+				return ERROR_NAND_OPERATION_FAILED;
+			default:
+				LOG_ERROR(&quot;BUG: unknown controller initialization failure&quot;);
+				return ERROR_NAND_OPERATION_FAILED;
+		}
+	}
+
+	nand-&gt;num_blocks = (nand-&gt;device-&gt;chip_size * 1024) / (nand-&gt;erase_size / 1024);
+	nand-&gt;blocks = malloc(sizeof(struct nand_block) * nand-&gt;num_blocks);
+
+	for (i = 0; i &lt; nand-&gt;num_blocks; i++)
+	{
+		nand-&gt;blocks[i].size = nand-&gt;erase_size;
+		nand-&gt;blocks[i].offset = i * nand-&gt;erase_size;
+		nand-&gt;blocks[i].is_erased = -1;
+		nand-&gt;blocks[i].is_bad = -1;
+	}
+
+	return ERROR_OK;
+}
+
+int nand_erase(struct nand_device *nand, int first_block, int last_block)
+{
+	int i;
+	uint32_t page;
+	uint8_t status;
+	int retval;
+
+	if (!nand-&gt;device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if ((first_block &lt; 0) || (last_block &gt; nand-&gt;num_blocks))
+		return ERROR_INVALID_ARGUMENTS;
+
+	/* make sure we know if a block is bad before erasing it */
+	for (i = first_block; i &lt;= last_block; i++)
+	{
+		if (nand-&gt;blocks[i].is_bad == -1)
+		{
+			nand_build_bbt(nand, i, last_block);
+			break;
+		}
+	}
+
+	for (i = first_block; i &lt;= last_block; i++)
+	{
+		/* Send erase setup command */
+		nand-&gt;controller-&gt;command(nand, NAND_CMD_ERASE1);
+
+		page = i * (nand-&gt;erase_size / nand-&gt;page_size);
+
+		/* Send page address */
+		if (nand-&gt;page_size &lt;= 512)
+		{
+			/* row */
+			nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
+			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
+
+			/* 3rd cycle only on devices with more than 32 MiB */
+			if (nand-&gt;address_cycles &gt;= 4)
+				nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
+
+			/* 4th cycle only on devices with more than 8 GiB */
+			if (nand-&gt;address_cycles &gt;= 5)
+				nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 24) &amp; 0xff);
+		}
+		else
+		{
+			/* row */
+			nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
+			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
+
+			/* 3rd cycle only on devices with more than 128 MiB */
+			if (nand-&gt;address_cycles &gt;= 5)
+				nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
+		}
+
+		/* Send erase confirm command */
+		nand-&gt;controller-&gt;command(nand, NAND_CMD_ERASE2);
+
+		retval = nand-&gt;controller-&gt;nand_ready ?
+				nand-&gt;controller-&gt;nand_ready(nand, 1000) :
+				nand_poll_ready(nand, 1000);
+		if (!retval) {
+			LOG_ERROR(&quot;timeout waiting for NAND flash block erase to complete&quot;);
+			return ERROR_NAND_OPERATION_TIMEOUT;
+		}
+
+		if ((retval = nand_read_status(nand, &amp;status)) != ERROR_OK)
+		{
+			LOG_ERROR(&quot;couldn't read status&quot;);
+			return ERROR_NAND_OPERATION_FAILED;
+		}
+
+		if (status &amp; 0x1)
+		{
+			LOG_ERROR(&quot;didn't erase %sblock %d; status: 0x%2.2x&quot;,
+					(nand-&gt;blocks[i].is_bad == 1)
+						? &quot;bad &quot; : &quot;&quot;,
+					i, status);
+			/* continue; other blocks might still be erasable */
+		}
+
+		nand-&gt;blocks[i].is_erased = 1;
+	}
+
+	return ERROR_OK;
+}
+
+#if 0
+static int nand_read_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
+{
+	uint8_t *page;
+
+	if (!nand-&gt;device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (address % nand-&gt;page_size)
+	{
+		LOG_ERROR(&quot;reads need to be page aligned&quot;);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	page = malloc(nand-&gt;page_size);
+
+	while (data_size &gt; 0)
+	{
+		uint32_t thisrun_size = (data_size &gt; nand-&gt;page_size) ? nand-&gt;page_size : data_size;
+		uint32_t page_address;
+
+
+		page_address = address / nand-&gt;page_size;
+
+		nand_read_page(nand, page_address, page, nand-&gt;page_size, NULL, 0);
+
+		memcpy(data, page, thisrun_size);
+
+		address += thisrun_size;
+		data += thisrun_size;
+		data_size -= thisrun_size;
+	}
+
+	free(page);
+
+	return ERROR_OK;
+}
+
+static int nand_write_plain(struct nand_device *nand, uint32_t address, uint8_t *data, uint32_t data_size)
+{
+	uint8_t *page;
+
+	if (!nand-&gt;device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (address % nand-&gt;page_size)
+	{
+		LOG_ERROR(&quot;writes need to be page aligned&quot;);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	page = malloc(nand-&gt;page_size);
+
+	while (data_size &gt; 0)
+	{
+		uint32_t thisrun_size = (data_size &gt; nand-&gt;page_size) ? nand-&gt;page_size : data_size;
+		uint32_t page_address;
+
+		memset(page, 0xff, nand-&gt;page_size);
+		memcpy(page, data, thisrun_size);
+
+		page_address = address / nand-&gt;page_size;
+
+		nand_write_page(nand, page_address, page, nand-&gt;page_size, NULL, 0);
+
+		address += thisrun_size;
+		data += thisrun_size;
+		data_size -= thisrun_size;
+	}
+
+	free(page);
+
+	return ERROR_OK;
+}
+#endif
+
+int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+{
+	uint32_t block;
+
+	if (!nand-&gt;device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	block = page / (nand-&gt;erase_size / nand-&gt;page_size);
+	if (nand-&gt;blocks[block].is_erased == 1)
+		nand-&gt;blocks[block].is_erased = 0;
+
+	if (nand-&gt;use_raw || nand-&gt;controller-&gt;write_page == NULL)
+		return nand_write_page_raw(nand, page, data, data_size, oob, oob_size);
+	else
+		return nand-&gt;controller-&gt;write_page(nand, page, data, data_size, oob, oob_size);
+}
+
+int nand_read_page(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size)
+{
+	if (!nand-&gt;device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (nand-&gt;use_raw || nand-&gt;controller-&gt;read_page == NULL)
+		return nand_read_page_raw(nand, page, data, data_size, oob, oob_size);
+	else
+		return nand-&gt;controller-&gt;read_page(nand, page, data, data_size, oob, oob_size);
+}
+
+int nand_page_command(struct nand_device *nand, uint32_t page,
+		uint8_t cmd, bool oob_only)
+{
+	if (!nand-&gt;device)
+		return ERROR_NAND_DEVICE_NOT_PROBED;
+
+	if (oob_only &amp;&amp; NAND_CMD_READ0 == cmd &amp;&amp; nand-&gt;page_size &lt;= 512)
+		cmd = NAND_CMD_READOOB;
+
+	nand-&gt;controller-&gt;command(nand, cmd);
+
+	if (nand-&gt;page_size &lt;= 512) {
+		/* small page device */
+
+		/* column (always 0, we start at the beginning of a page/OOB area) */
+		nand-&gt;controller-&gt;address(nand, 0x0);
+
+		/* row */
+		nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
+		nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
+
+		/* 4th cycle only on devices with more than 32 MiB */
+		if (nand-&gt;address_cycles &gt;= 4)
+			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
+
+		/* 5th cycle only on devices with more than 8 GiB */
+		if (nand-&gt;address_cycles &gt;= 5)
+			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 24) &amp; 0xff);
+	} else {
+		/* large page device */
+
+		/* column (0 when we start at the beginning of a page,
+		 * or 2048 for the beginning of OOB area)
+		 */
+		nand-&gt;controller-&gt;address(nand, 0x0);
+		if (oob_only)
+			nand-&gt;controller-&gt;address(nand, 0x8);
+		else
+			nand-&gt;controller-&gt;address(nand, 0x0);
+
+		/* row */
+		nand-&gt;controller-&gt;address(nand, page &amp; 0xff);
+		nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 8) &amp; 0xff);
+
+		/* 5th cycle only on devices with more than 128 MiB */
+		if (nand-&gt;address_cycles &gt;= 5)
+			nand-&gt;controller-&gt;address(nand, (page &gt;&gt; 16) &amp; 0xff);
+
+		/* large page devices need a start command if reading */
+		if (NAND_CMD_READ0 == cmd)
+			nand-&gt;controller-&gt;command(nand, NAND_CMD_READSTART);
+	}
+
+	if (nand-&gt;controller-&gt;nand_ready) {
+		if (!nand-&gt;controller-&gt;nand_ready(nand, 100))
+			return ERROR_NAND_OPERATION_TIMEOUT;
+	} else {
+		alive_sleep(1);
+	}
+
+	return ERROR_OK;
+}
+
+int nand_read_page_raw(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size)
+{
+	uint32_t i;
+	int retval;
+
+	retval = nand_page_command(nand, page, NAND_CMD_READ0, !data);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (data)
+	{
+		if (nand-&gt;controller-&gt;read_block_data != NULL)
+			(nand-&gt;controller-&gt;read_block_data)(nand, data, data_size);
+		else
+		{
+			for (i = 0; i &lt; data_size;)
+			{
+				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
+				{
+					nand-&gt;controller-&gt;read_data(nand, data);
+					data += 2;
+					i += 2;
+				}
+				else
+				{
+					nand-&gt;controller-&gt;read_data(nand, data);
+					data += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	if (oob)
+	{
+		if (nand-&gt;controller-&gt;read_block_data != NULL)
+			(nand-&gt;controller-&gt;read_block_data)(nand, oob, oob_size);
+		else
+		{
+			for (i = 0; i &lt; oob_size;)
+			{
+				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
+				{
+					nand-&gt;controller-&gt;read_data(nand, oob);
+					oob += 2;
+					i += 2;
+				}
+				else
+				{
+					nand-&gt;controller-&gt;read_data(nand, oob);
+					oob += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+int nand_write_page_raw(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size)
+{
+	uint32_t i;
+	int retval;
+	uint8_t status;
+
+	retval = nand_page_command(nand, page, NAND_CMD_SEQIN, !data);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (data)
+	{
+		if (nand-&gt;controller-&gt;write_block_data != NULL)
+			(nand-&gt;controller-&gt;write_block_data)(nand, data, data_size);
+		else
+		{
+			for (i = 0; i &lt; data_size;)
+			{
+				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
+				{
+					uint16_t data_buf = le_to_h_u16(data);
+					nand-&gt;controller-&gt;write_data(nand, data_buf);
+					data += 2;
+					i += 2;
+				}
+				else
+				{
+					nand-&gt;controller-&gt;write_data(nand, *data);
+					data += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	if (oob)
+	{
+		if (nand-&gt;controller-&gt;write_block_data != NULL)
+			(nand-&gt;controller-&gt;write_block_data)(nand, oob, oob_size);
+		else
+		{
+			for (i = 0; i &lt; oob_size;)
+			{
+				if (nand-&gt;device-&gt;options &amp; NAND_BUSWIDTH_16)
+				{
+					uint16_t oob_buf = le_to_h_u16(data);
+					nand-&gt;controller-&gt;write_data(nand, oob_buf);
+					oob += 2;
+					i += 2;
+				}
+				else
+				{
+					nand-&gt;controller-&gt;write_data(nand, *oob);
+					oob += 1;
+					i += 1;
+				}
+			}
+		}
+	}
+
+	nand-&gt;controller-&gt;command(nand, NAND_CMD_PAGEPROG);
+
+	retval = nand-&gt;controller-&gt;nand_ready ?
+			nand-&gt;controller-&gt;nand_ready(nand, 100) :
+			nand_poll_ready(nand, 100);
+	if (!retval)
+		return ERROR_NAND_OPERATION_TIMEOUT;
+
+	if ((retval = nand_read_status(nand, &amp;status)) != ERROR_OK)
+	{
+		LOG_ERROR(&quot;couldn't read status&quot;);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	if (status &amp; NAND_STATUS_FAIL)
+	{
+		LOG_ERROR(&quot;write operation didn't pass, status: 0x%2.2x&quot;, status);
+		return ERROR_NAND_OPERATION_FAILED;
+	}
+
+	return ERROR_OK;
+}
+
diff --git a/src/flash/nand/fileio.c b/src/flash/nand/fileio.c
new file mode 100644
index 0000000..fbaa8b4
--- /dev/null
+++ b/src/flash/nand/fileio.c
@@ -0,0 +1,244 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2002 Thomas Gleixner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">tglx at linutronix.de</A>&gt;               *
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &lt;flash/nand.h&gt;
+#include &quot;fileio.h&quot;
+
+static struct nand_ecclayout nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {0, 1, 2, 3, 6, 7},
+	.oobfree = {
+		{.offset = 8,
+		 . length = 8}}
+};
+
+static struct nand_ecclayout nand_oob_64 = {
+	.eccbytes = 24,
+	.eccpos = {
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		 .length = 38}}
+};
+
+void nand_fileio_init(struct nand_fileio_state *state)
+{
+	memset(state, 0, sizeof(*state));
+	state-&gt;oob_format = NAND_OOB_NONE;
+}
+
+int nand_fileio_start(struct command_context *cmd_ctx,
+		struct nand_device *nand, const char *filename, int filemode,
+		struct nand_fileio_state *state)
+{
+	if (state-&gt;address % nand-&gt;page_size)
+	{
+		command_print(cmd_ctx, &quot;only page-aligned addresses are supported&quot;);
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	duration_start(&amp;state-&gt;bench);
+
+	if (NULL != filename)
+	{
+		int retval = fileio_open(&amp;state-&gt;fileio, filename, filemode, FILEIO_BINARY);
+		if (ERROR_OK != retval)
+		{
+			const char *msg = (FILEIO_READ == filemode) ? &quot;read&quot; : &quot;write&quot;;
+			command_print(cmd_ctx, &quot;failed to open '%s' for %s access&quot;,
+					filename, msg);
+			return retval;
+		}
+		state-&gt;file_opened = true;
+	}
+
+	if (!(state-&gt;oob_format &amp; NAND_OOB_ONLY))
+	{
+		state-&gt;page_size = nand-&gt;page_size;
+		state-&gt;page = malloc(nand-&gt;page_size);
+	}
+
+	if (state-&gt;oob_format &amp; (NAND_OOB_RAW | NAND_OOB_SW_ECC | NAND_OOB_SW_ECC_KW))
+	{
+		if (nand-&gt;page_size == 512)
+		{
+			state-&gt;oob_size = 16;
+			state-&gt;eccpos = nand_oob_16.eccpos;
+		}
+		else if (nand-&gt;page_size == 2048)
+		{
+			state-&gt;oob_size = 64;
+			state-&gt;eccpos = nand_oob_64.eccpos;
+		}
+		state-&gt;oob = malloc(state-&gt;oob_size);
+	}
+
+	return ERROR_OK;
+}
+int nand_fileio_cleanup(struct nand_fileio_state *state)
+{
+	if (state-&gt;file_opened)
+		fileio_close(&amp;state-&gt;fileio);
+
+	if (state-&gt;oob)
+	{
+		free(state-&gt;oob);
+		state-&gt;oob = NULL;
+	}
+	if (state-&gt;page)
+	{
+		free(state-&gt;page);
+		state-&gt;page = NULL;
+	}
+	return ERROR_OK;
+}
+int nand_fileio_finish(struct nand_fileio_state *state)
+{
+	nand_fileio_cleanup(state);
+	return duration_measure(&amp;state-&gt;bench);
+}
+
+COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
+		struct nand_device **dev, enum fileio_access filemode,
+		bool need_size, bool sw_ecc)
+{
+	nand_fileio_init(state);
+
+	unsigned minargs = need_size ? 4 : 3;
+	if (CMD_ARGC &lt; minargs)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	struct nand_device *nand;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;nand);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (NULL == nand-&gt;device)
+	{
+		command_print(CMD_CTX, &quot;#%s: not probed&quot;, CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], state-&gt;address);
+	if (need_size)
+	{
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], state-&gt;size);
+			if (state-&gt;size % nand-&gt;page_size)
+			{
+				command_print(CMD_CTX, &quot;only page-aligned sizes are supported&quot;);
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+	}
+
+	if (CMD_ARGC &gt; minargs)
+	{
+		for (unsigned i = minargs; i &lt; CMD_ARGC; i++)
+		{
+			if (!strcmp(CMD_ARGV[i], &quot;oob_raw&quot;))
+				state-&gt;oob_format |= NAND_OOB_RAW;
+			else if (!strcmp(CMD_ARGV[i], &quot;oob_only&quot;))
+				state-&gt;oob_format |= NAND_OOB_RAW | NAND_OOB_ONLY;
+			else if (sw_ecc &amp;&amp; !strcmp(CMD_ARGV[i], &quot;oob_softecc&quot;))
+				state-&gt;oob_format |= NAND_OOB_SW_ECC;
+			else if (sw_ecc &amp;&amp; !strcmp(CMD_ARGV[i], &quot;oob_softecc_kw&quot;))
+				state-&gt;oob_format |= NAND_OOB_SW_ECC_KW;
+			else
+			{
+				command_print(CMD_CTX, &quot;unknown option: %s&quot;, CMD_ARGV[i]);
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+		}
+	}
+
+	retval = nand_fileio_start(CMD_CTX, nand, CMD_ARGV[1], filemode, state);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (!need_size)
+		state-&gt;size = state-&gt;fileio.size;
+
+	*dev = nand;
+
+	return ERROR_OK;
+}
+
+/**
+ * @returns If no error occurred, returns number of bytes consumed;
+ * otherwise, returns a negative error code.)
+ */
+int nand_fileio_read(struct nand_device *nand, struct nand_fileio_state *s)
+{
+	size_t total_read = 0;
+	size_t one_read;
+
+	if (NULL != s-&gt;page)
+	{
+		fileio_read(&amp;s-&gt;fileio, s-&gt;page_size, s-&gt;page, &amp;one_read);
+		if (one_read &lt; s-&gt;page_size)
+			memset(s-&gt;page + one_read, 0xff, s-&gt;page_size - one_read);
+		total_read += one_read;
+	}
+
+	if (s-&gt;oob_format &amp; NAND_OOB_SW_ECC)
+	{
+		uint8_t ecc[3];
+		memset(s-&gt;oob, 0xff, s-&gt;oob_size);
+		for (uint32_t i = 0, j = 0; i &lt; s-&gt;page_size; i += 256)
+		{
+			nand_calculate_ecc(nand, s-&gt;page + i, ecc);
+			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[0];
+			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[1];
+			s-&gt;oob[s-&gt;eccpos[j++]] = ecc[2];
+		}
+	}
+	else if (s-&gt;oob_format &amp; NAND_OOB_SW_ECC_KW)
+	{
+		/*
+		 * In this case eccpos is not used as
+		 * the ECC data is always stored contigously
+		 * at the end of the OOB area.  It consists
+		 * of 10 bytes per 512-byte data block.
+		 */
+		uint8_t *ecc = s-&gt;oob + s-&gt;oob_size - s-&gt;page_size / 512 * 10;
+		memset(s-&gt;oob, 0xff, s-&gt;oob_size);
+		for (uint32_t i = 0; i &lt; s-&gt;page_size; i += 512)
+		{
+			nand_calculate_ecc_kw(nand, s-&gt;page + i, ecc);
+			ecc += 10;
+		}
+	}
+	else if (NULL != s-&gt;oob)
+	{
+		fileio_read(&amp;s-&gt;fileio, s-&gt;oob_size, s-&gt;oob, &amp;one_read);
+		if (one_read &lt; s-&gt;oob_size)
+			memset(s-&gt;oob + one_read, 0xff, s-&gt;oob_size - one_read);
+		total_read += one_read;
+	}
+	return total_read;
+}
+
diff --git a/src/flash/nand/fileio.h b/src/flash/nand/fileio.h
new file mode 100644
index 0000000..7855431
--- /dev/null
+++ b/src/flash/nand/fileio.h
@@ -0,0 +1,57 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NAND_FILEIO_H
+#define FLASH_NAND_FILEIO_H
+
+#include &lt;helper/time_support.h&gt;
+#include &lt;helper/fileio.h&gt;
+
+struct nand_fileio_state {
+	uint32_t address;
+	uint32_t size;
+
+	uint8_t *page;
+	uint32_t page_size;
+
+	enum oob_formats oob_format;
+	uint8_t *oob;
+	uint32_t oob_size;
+
+	const int *eccpos;
+
+	bool file_opened;
+	struct fileio fileio;
+
+	struct duration bench;
+};
+
+void nand_fileio_init(struct nand_fileio_state *state);
+int nand_fileio_start(struct command_context *cmd_ctx,
+		struct nand_device *nand, const char *filename, int filemode,
+		struct nand_fileio_state *state);
+int nand_fileio_cleanup(struct nand_fileio_state *state);
+int nand_fileio_finish(struct nand_fileio_state *state);
+
+COMMAND_HELPER(nand_fileio_parse_args, struct nand_fileio_state *state,
+		struct nand_device **dev, enum fileio_access filemode,
+		bool need_size, bool sw_ecc);
+
+int nand_fileio_read(struct nand_device *nand, struct nand_fileio_state *s);
+
+#endif // FLASH_NAND_FILEIO_H
diff --git a/src/flash/nand/imp.h b/src/flash/nand/imp.h
new file mode 100644
index 0000000..b381b53
--- /dev/null
+++ b/src/flash/nand/imp.h
@@ -0,0 +1,34 @@
+/***************************************************************************
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NAND_IMP_H
+#define FLASH_NAND_IMP_H
+
+int nand_write_page(struct nand_device *nand,
+		uint32_t page, uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size);
+
+int nand_read_page(struct nand_device *nand, uint32_t page,
+		uint8_t *data, uint32_t data_size,
+		uint8_t *oob, uint32_t oob_size);
+
+int nand_probe(struct nand_device *nand);
+int nand_erase(struct nand_device *nand, int first_block, int last_block);
+int nand_build_bbt(struct nand_device *nand, int first, int last);
+
+#endif // FLASH_NAND_IMP_H
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
new file mode 100644
index 0000000..75a416f
--- /dev/null
+++ b/src/flash/nand/tcl.c
@@ -0,0 +1,645 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2002 Thomas Gleixner &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">tglx at linutronix.de</A>&gt;               *
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   Partially based on drivers/mtd/nand_ids.c from Linux.                 *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &lt;flash/nand.h&gt;
+#include &quot;imp.h&quot;
+#include &quot;fileio.h&quot;
+
+// to be removed
+extern struct nand_device *nand_devices;
+
+COMMAND_HANDLER(handle_nand_list_command)
+{
+	struct nand_device *p;
+	int i;
+
+	if (!nand_devices)
+	{
+		command_print(CMD_CTX, &quot;no NAND flash devices configured&quot;);
+		return ERROR_OK;
+	}
+
+	for (p = nand_devices, i = 0; p; p = p-&gt;next, i++)
+	{
+		if (p-&gt;device)
+			command_print(CMD_CTX, &quot;#%i: %s (%s) &quot;
+				&quot;pagesize: %i, buswidth: %i,\n\t&quot;
+				&quot;blocksize: %i, blocks: %i&quot;,
+				i, p-&gt;device-&gt;name, p-&gt;manufacturer-&gt;name,
+				p-&gt;page_size, p-&gt;bus_width,
+				p-&gt;erase_size, p-&gt;num_blocks);
+		else
+			command_print(CMD_CTX, &quot;#%i: not probed&quot;, i);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_info_command)
+{
+	int i = 0;
+	int j = 0;
+	int first = -1;
+	int last = -1;
+
+	switch (CMD_ARGC) {
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	case 1:
+		first = 0;
+		last = INT32_MAX;
+		break;
+	case 2:
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], i);
+		first = last = i;
+		i = 0;
+		break;
+	case 3:
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], first);
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[2], last);
+		break;
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (NULL == p-&gt;device)
+	{
+		command_print(CMD_CTX, &quot;#%s: not probed&quot;, CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	if (first &gt;= p-&gt;num_blocks)
+		first = p-&gt;num_blocks - 1;
+
+	if (last &gt;= p-&gt;num_blocks)
+		last = p-&gt;num_blocks - 1;
+
+	command_print(CMD_CTX, &quot;#%i: %s (%s) pagesize: %i, buswidth: %i, erasesize: %i&quot;,
+		i++, p-&gt;device-&gt;name, p-&gt;manufacturer-&gt;name, p-&gt;page_size, p-&gt;bus_width, p-&gt;erase_size);
+
+	for (j = first; j &lt;= last; j++)
+	{
+		char *erase_state, *bad_state;
+
+		if (p-&gt;blocks[j].is_erased == 0)
+			erase_state = &quot;not erased&quot;;
+		else if (p-&gt;blocks[j].is_erased == 1)
+			erase_state = &quot;erased&quot;;
+		else
+			erase_state = &quot;erase state unknown&quot;;
+
+		if (p-&gt;blocks[j].is_bad == 0)
+			bad_state = &quot;&quot;;
+		else if (p-&gt;blocks[j].is_bad == 1)
+			bad_state = &quot; (marked bad)&quot;;
+		else
+			bad_state = &quot; (block condition unknown)&quot;;
+
+		command_print(CMD_CTX,
+			      &quot;\t#%i: 0x%8.8&quot; PRIx32 &quot; (%&quot; PRId32 &quot;kB) %s%s&quot;,
+			      j,
+			      p-&gt;blocks[j].offset,
+			      p-&gt;blocks[j].size / 1024,
+			      erase_state,
+			      bad_state);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_probe_command)
+{
+	if (CMD_ARGC != 1)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if ((retval = nand_probe(p)) == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;NAND flash device '%s' found&quot;, p-&gt;device-&gt;name);
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, &quot;probing failed for NAND flash device&quot;);
+	}
+	else
+	{
+		command_print(CMD_CTX, &quot;unknown error when probing NAND flash device&quot;);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_erase_command)
+{
+	if (CMD_ARGC != 1 &amp;&amp; CMD_ARGC != 3)
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	unsigned long offset;
+	unsigned long length;
+
+	/* erase specified part of the chip; or else everything */
+	if (CMD_ARGC == 3) {
+		unsigned long size = p-&gt;erase_size * p-&gt;num_blocks;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
+		if ((offset % p-&gt;erase_size) != 0 || offset &gt;= size)
+			return ERROR_INVALID_ARGUMENTS;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
+		if ((length == 0) || (length % p-&gt;erase_size) != 0
+				|| (length + offset) &gt; size)
+			return ERROR_INVALID_ARGUMENTS;
+
+		offset /= p-&gt;erase_size;
+		length /= p-&gt;erase_size;
+	} else {
+		offset = 0;
+		length = p-&gt;num_blocks;
+	}
+
+	retval = nand_erase(p, offset, offset + length - 1);
+	if (retval == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;erased blocks %lu to %lu &quot;
+				&quot;on NAND flash device #%s '%s'&quot;,
+				offset, offset + length,
+				CMD_ARGV[0], p-&gt;device-&gt;name);
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, &quot;erase failed&quot;);
+	}
+	else
+	{
+		command_print(CMD_CTX, &quot;unknown error when erasing NAND flash device&quot;);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_check_bad_blocks_command)
+{
+	int first = -1;
+	int last = -1;
+
+	if ((CMD_ARGC &lt; 1) || (CMD_ARGC &gt; 3) || (CMD_ARGC == 2))
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (CMD_ARGC == 3)
+	{
+		unsigned long offset;
+		unsigned long length;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[1], offset);
+		if (offset % p-&gt;erase_size)
+			return ERROR_INVALID_ARGUMENTS;
+		offset /= p-&gt;erase_size;
+
+		COMMAND_PARSE_NUMBER(ulong, CMD_ARGV[2], length);
+		if (length % p-&gt;erase_size)
+			return ERROR_INVALID_ARGUMENTS;
+
+		length -= 1;
+		length /= p-&gt;erase_size;
+
+		first = offset;
+		last = offset + length;
+	}
+
+	retval = nand_build_bbt(p, first, last);
+	if (retval == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;checked NAND flash device for bad blocks, &quot;
+				&quot;use \&quot;nand info\&quot; command to list blocks&quot;);
+	}
+	else if (retval == ERROR_NAND_OPERATION_FAILED)
+	{
+		command_print(CMD_CTX, &quot;error when checking for bad blocks on &quot;
+				&quot;NAND flash device&quot;);
+	}
+	else
+	{
+		command_print(CMD_CTX, &quot;unknown error when checking for bad &quot;
+				&quot;blocks on NAND flash device&quot;);
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_write_command)
+{
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state s;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&amp;s, &amp;nand, FILEIO_READ, false, true);
+	if (ERROR_OK != retval)
+		return retval;
+
+	uint32_t total_bytes = s.size;
+	while (s.size &gt; 0)
+	{
+		int bytes_read = nand_fileio_read(nand, &amp;s);
+		if (bytes_read &lt;= 0)
+		{
+			command_print(CMD_CTX, &quot;error while reading file&quot;);
+			return nand_fileio_cleanup(&amp;s);
+		}
+		s.size -= bytes_read;
+
+		retval = nand_write_page(nand, s.address / nand-&gt;page_size,
+				s.page, s.page_size, s.oob, s.oob_size);
+		if (ERROR_OK != retval)
+		{
+			command_print(CMD_CTX, &quot;failed writing file %s &quot;
+				&quot;to NAND flash %s at offset 0x%8.8&quot; PRIx32,
+				CMD_ARGV[1], CMD_ARGV[0], s.address);
+			return nand_fileio_cleanup(&amp;s);
+		}
+		s.address += s.page_size;
+	}
+
+	if (nand_fileio_finish(&amp;s))
+	{
+		command_print(CMD_CTX, &quot;wrote file %s to NAND flash %s up to &quot;
+				&quot;offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
+				CMD_ARGV[1], CMD_ARGV[0], s.address, duration_elapsed(&amp;s.bench),
+				duration_kbps(&amp;s.bench, total_bytes));
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_verify_command)
+{
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state file;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&amp;file, &amp;nand, FILEIO_READ, false, true);
+	if (ERROR_OK != retval)
+		return retval;
+
+	struct nand_fileio_state dev;
+	nand_fileio_init(&amp;dev);
+	dev.address = file.address;
+	dev.size = file.size;
+	dev.oob_format = file.oob_format;
+	retval = nand_fileio_start(CMD_CTX, nand, NULL, FILEIO_NONE, &amp;dev);
+	if (ERROR_OK != retval)
+		return retval;
+
+	while (file.size &gt; 0)
+	{
+		int retval = nand_read_page(nand, dev.address / dev.page_size,
+				dev.page, dev.page_size, dev.oob, dev.oob_size);
+		if (ERROR_OK != retval)
+		{
+			command_print(CMD_CTX, &quot;reading NAND flash page failed&quot;);
+			nand_fileio_cleanup(&amp;dev);
+			return nand_fileio_cleanup(&amp;file);
+		}
+
+		int bytes_read = nand_fileio_read(nand, &amp;file);
+		if (bytes_read &lt;= 0)
+		{
+			command_print(CMD_CTX, &quot;error while reading file&quot;);
+			nand_fileio_cleanup(&amp;dev);
+			return nand_fileio_cleanup(&amp;file);
+		}
+
+		if ((dev.page &amp;&amp; memcmp(dev.page, file.page, dev.page_size)) ||
+		    (dev.oob &amp;&amp; memcmp(dev.oob, file.oob, dev.oob_size)) )
+		{
+			command_print(CMD_CTX, &quot;NAND flash contents differ &quot;
+						&quot;at 0x%8.8&quot; PRIx32, dev.address);
+			nand_fileio_cleanup(&amp;dev);
+			return nand_fileio_cleanup(&amp;file);
+		}
+
+		file.size -= bytes_read;
+		dev.address += nand-&gt;page_size;
+	}
+
+	if (nand_fileio_finish(&amp;file) == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;verified file %s in NAND flash %s &quot;
+				&quot;up to offset 0x%8.8&quot; PRIx32 &quot; in %fs (%0.3f kb/s)&quot;,
+				CMD_ARGV[1], CMD_ARGV[0], dev.address, duration_elapsed(&amp;file.bench),
+				duration_kbps(&amp;file.bench, dev.size));
+	}
+
+	return nand_fileio_cleanup(&amp;dev);
+}
+
+COMMAND_HANDLER(handle_nand_dump_command)
+{
+	struct nand_device *nand = NULL;
+	struct nand_fileio_state s;
+	int retval = CALL_COMMAND_HANDLER(nand_fileio_parse_args,
+			&amp;s, &amp;nand, FILEIO_WRITE, true, false);
+	if (ERROR_OK != retval)
+		return retval;
+
+	while (s.size &gt; 0)
+	{
+		size_t size_written;
+		int retval = nand_read_page(nand, s.address / nand-&gt;page_size,
+				s.page, s.page_size, s.oob, s.oob_size);
+		if (ERROR_OK != retval)
+		{
+			command_print(CMD_CTX, &quot;reading NAND flash page failed&quot;);
+			return nand_fileio_cleanup(&amp;s);
+		}
+
+		if (NULL != s.page)
+			fileio_write(&amp;s.fileio, s.page_size, s.page, &amp;size_written);
+
+		if (NULL != s.oob)
+			fileio_write(&amp;s.fileio, s.oob_size, s.oob, &amp;size_written);
+
+		s.size -= nand-&gt;page_size;
+		s.address += nand-&gt;page_size;
+	}
+
+	if (nand_fileio_finish(&amp;s) == ERROR_OK)
+	{
+		command_print(CMD_CTX, &quot;dumped %zu bytes in %fs (%0.3f kb/s)&quot;, 
+				s.fileio.size, duration_elapsed(&amp;s.bench),
+				duration_kbps(&amp;s.bench, s.fileio.size));
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_raw_access_command)
+{
+	if ((CMD_ARGC &lt; 1) || (CMD_ARGC &gt; 2))
+	{
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	struct nand_device *p;
+	int retval = CALL_COMMAND_HANDLER(nand_command_get_device, 0, &amp;p);
+	if (ERROR_OK != retval)
+		return retval;
+
+	if (NULL == p-&gt;device)
+	{
+		command_print(CMD_CTX, &quot;#%s: not probed&quot;, CMD_ARGV[0]);
+		return ERROR_OK;
+	}
+
+	if (CMD_ARGC == 2)
+		COMMAND_PARSE_ENABLE(CMD_ARGV[1], p-&gt;use_raw);
+
+	const char *msg = p-&gt;use_raw ? &quot;enabled&quot; : &quot;disabled&quot;;
+	command_print(CMD_CTX, &quot;raw access is %s&quot;, msg);
+
+	return ERROR_OK;
+}
+
+static const struct command_registration nand_exec_command_handlers[] = {
+	{
+		.name = &quot;list&quot;,
+		.handler = &amp;handle_nand_list_command,
+		.mode = COMMAND_EXEC,
+		.help = &quot;list configured NAND flash devices&quot;,
+	},
+	{
+		.name = &quot;info&quot;,
+		.handler = &amp;handle_nand_info_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt;&quot;,
+		.help = &quot;print info about a NAND flash device&quot;,
+	},
+	{
+		.name = &quot;probe&quot;,
+		.handler = &amp;handle_nand_probe_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt;&quot;,
+		.help = &quot;identify NAND flash device &lt;num&gt;&quot;,
+
+	},
+	{
+		.name = &quot;check_bad_blocks&quot;,
+		.handler = &amp;handle_nand_check_bad_blocks_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; [&lt;offset&gt; &lt;length&gt;]&quot;,
+		.help = &quot;check NAND flash device &lt;num&gt; for bad blocks&quot;,
+	},
+	{
+		.name = &quot;erase&quot;,
+		.handler = &amp;handle_nand_erase_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; [&lt;offset&gt; &lt;length&gt;]&quot;,
+		.help = &quot;erase blocks on NAND flash device&quot;,
+	},
+	{
+		.name = &quot;dump&quot;,
+		.handler = &amp;handle_nand_dump_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;filename&gt; &lt;offset&gt; &lt;length&gt; &quot;
+			&quot;[oob_raw | oob_only]&quot;,
+		.help = &quot;dump from NAND flash device&quot;,
+	},
+	{
+		.name = &quot;verify&quot;,
+		.handler = &amp;handle_nand_verify_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;filename&gt; &lt;offset&gt; &quot;
+			&quot;[oob_raw | oob_only | oob_softecc | oob_softecc_kw]&quot;,
+		.help = &quot;verify NAND flash device&quot;,
+	},
+	{
+		.name = &quot;write&quot;,
+		.handler = &amp;handle_nand_write_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;bank&gt; &lt;filename&gt; &lt;offset&gt; &quot;
+			&quot;[oob_raw | oob_only | oob_softecc | oob_softecc_kw]&quot;,
+		.help = &quot;write to NAND flash device&quot;,
+	},
+	{
+		.name = &quot;raw_access&quot;,
+		.handler = &amp;handle_nand_raw_access_command,
+		.mode = COMMAND_EXEC,
+		.usage = &quot;&lt;num&gt; ['enable'|'disable']&quot;,
+		.help = &quot;raw access to NAND flash device&quot;,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int nand_init(struct command_context *cmd_ctx)
+{
+	if (!nand_devices)
+		return ERROR_OK;
+	struct command *parent = command_find_in_context(cmd_ctx, &quot;nand&quot;);
+	return register_commands(cmd_ctx, parent, nand_exec_command_handlers);
+}
+
+COMMAND_HANDLER(handle_nand_init_command)
+{
+	if (CMD_ARGC != 0)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	static bool nand_initialized = false;
+	if (nand_initialized)
+	{
+		LOG_INFO(&quot;'nand init' has already been called&quot;);
+		return ERROR_OK;
+	}
+	nand_initialized = true;
+
+	LOG_DEBUG(&quot;Initializing NAND devices...&quot;);
+	return nand_init(CMD_CTX);
+}
+int nand_list_walker(struct nand_flash_controller *c, void *x)
+{
+	struct command_context *cmd_ctx = (struct command_context *)x;
+	command_print(cmd_ctx, &quot;  %s&quot;, c-&gt;name);
+	return ERROR_OK;
+}
+COMMAND_HANDLER(handle_nand_list_drivers)
+{
+	command_print(CMD_CTX, &quot;Available NAND flash controller drivers:&quot;);
+	return nand_driver_walk(&amp;nand_list_walker, CMD_CTX);
+}
+
+static COMMAND_HELPER(create_nand_device, const char *bank_name,
+		struct nand_flash_controller *controller)
+{
+	if (NULL != controller-&gt;commands)
+	{
+		int retval = register_commands(CMD_CTX, NULL,
+				controller-&gt;commands);
+		if (ERROR_OK != retval)
+			return retval;
+	}
+	struct nand_device *c = malloc(sizeof(struct nand_device));
+
+	c-&gt;name = strdup(bank_name);
+	c-&gt;controller = controller;
+	c-&gt;controller_priv = NULL;
+	c-&gt;manufacturer = NULL;
+	c-&gt;device = NULL;
+	c-&gt;bus_width = 0;
+	c-&gt;address_cycles = 0;
+	c-&gt;page_size = 0;
+	c-&gt;use_raw = 0;
+	c-&gt;next = NULL;
+
+	int retval = CALL_COMMAND_HANDLER(controller-&gt;nand_device_command, c);
+	if (ERROR_OK != retval)
+	{
+		LOG_ERROR(&quot;'%s' driver rejected nand flash&quot;, controller-&gt;name);
+		free(c);
+		return ERROR_OK;
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_nand_device_command)
+{
+	if (CMD_ARGC &lt; 1)
+	{
+		LOG_ERROR(&quot;incomplete nand device configuration&quot;);
+		return ERROR_FLASH_BANK_INVALID;
+	}
+
+	// save name and increment (for compatibility) with drivers
+	const char *bank_name = *CMD_ARGV++;
+	CMD_ARGC--;
+
+	const char *driver_name = CMD_ARGV[0];
+	struct nand_flash_controller *controller;
+	controller = nand_driver_find_by_name(CMD_ARGV[0]);
+	if (NULL == controller)
+	{
+		LOG_ERROR(&quot;No valid NAND flash driver found (%s)&quot;, driver_name);
+		return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
+	}
+	return CALL_COMMAND_HANDLER(create_nand_device, bank_name, controller);
+}
+
+static const struct command_registration nand_config_command_handlers[] = {
+	{
+		.name = &quot;device&quot;,
+		.handler = &amp;handle_nand_device_command,
+		.mode = COMMAND_CONFIG,
+		.help = &quot;defines a new NAND bank&quot;,
+	},
+	{
+		.name = &quot;drivers&quot;,
+		.handler = &amp;handle_nand_list_drivers,
+		.mode = COMMAND_ANY,
+		.help = &quot;lists available NAND drivers&quot;,
+	},
+	{
+		.name = &quot;init&quot;,
+		.mode = COMMAND_CONFIG,
+		.handler = &amp;handle_nand_init_command,
+		.help = &quot;initialize NAND devices&quot;,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration nand_command_handlers[] = {
+	{
+		.name = &quot;nand&quot;,
+		.mode = COMMAND_ANY,
+		.help = &quot;NAND flash command group&quot;,
+		.chain = nand_config_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int nand_register_commands(struct command_context *cmd_ctx)
+{
+	return register_commands(cmd_ctx, NULL, nand_command_handlers);
+}
+
+

commit a7fd30c07fb9c2b7662ffaa48287b1997dc60796
Author: Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;
Date:   Fri Dec 4 18:24:14 2009 -0800

    split NAND driver handling into nand/driver.[ch]
    
    This work parallels the NOR directory, encapsulating the NAND drivers
    into a separate file.  This takes an extra step by encapsulating the
    type of data structure used to manage the drivers, allowing it to be
    changed from an array to a dynamic list in the future.

diff --git a/src/flash/nand.c b/src/flash/nand.c
index 2f0f503..9a220d2 100644
--- a/src/flash/nand.c
+++ b/src/flash/nand.c
@@ -34,35 +34,6 @@ static int nand_read_page(struct nand_device *nand, uint32_t page, uint8_t *data
 
 static int nand_write_page(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
 
-/* NAND flash controller
- */
-extern struct nand_flash_controller nonce_nand_controller;
-extern struct nand_flash_controller davinci_nand_controller;
-extern struct nand_flash_controller lpc3180_nand_controller;
-extern struct nand_flash_controller orion_nand_controller;
-extern struct nand_flash_controller s3c2410_nand_controller;
-extern struct nand_flash_controller s3c2412_nand_controller;
-extern struct nand_flash_controller s3c2440_nand_controller;
-extern struct nand_flash_controller s3c2443_nand_controller;
-extern struct nand_flash_controller imx31_nand_flash_controller;
-
-/* extern struct nand_flash_controller boundary_scan_nand_controller; */
-
-static struct nand_flash_controller *nand_flash_controllers[] =
-{
-	&amp;nonce_nand_controller,
-	&amp;davinci_nand_controller,
-	&amp;lpc3180_nand_controller,
-	&amp;orion_nand_controller,
-	&amp;s3c2410_nand_controller,
-	&amp;s3c2412_nand_controller,
-	&amp;s3c2440_nand_controller,
-	&amp;s3c2443_nand_controller,
- 	&amp;imx31_nand_flash_controller,
-/*	&amp;boundary_scan_nand_controller, */
-	NULL
-};
-
 /* configured NAND devices and NAND Flash command handler */
 static struct nand_device *nand_devices = NULL;
 
@@ -205,12 +176,16 @@ static struct nand_ecclayout nand_oob_64 = {
 		 .length = 38}}
 };
 
+int nand_list_walker(struct nand_flash_controller *c, void *x)
+{
+	struct command_context *cmd_ctx = (struct command_context *)x;
+	command_print(cmd_ctx, &quot;  %s&quot;, c-&gt;name);
+	return ERROR_OK;
+}
 COMMAND_HANDLER(handle_nand_list_drivers)
 {
 	command_print(CMD_CTX, &quot;Available NAND flash controller drivers:&quot;);
-	for (unsigned i = 0; nand_flash_controllers[i]; i++)
-		command_print(CMD_CTX, &quot;  %s&quot;, nand_flash_controllers[i]-&gt;name);
-	return ERROR_OK;
+	return nand_driver_walk(&amp;nand_list_walker, CMD_CTX);
 }
 
 static COMMAND_HELPER(create_nand_device, const char *bank_name,
@@ -267,18 +242,14 @@ COMMAND_HANDLER(handle_nand_device_command)
 	CMD_ARGC--;
 
 	const char *driver_name = CMD_ARGV[0];
-	for (unsigned i = 0; nand_flash_controllers[i]; i++)
+	struct nand_flash_controller *controller;
+	controller = nand_driver_find_by_name(CMD_ARGV[0]);
+	if (NULL == controller)
 	{
-		struct nand_flash_controller *controller = nand_flash_controllers[i];
-		if (strcmp(driver_name, controller-&gt;name) != 0)
-			continue;
-
-		return CALL_COMMAND_HANDLER(create_nand_device,
-				bank_name, controller);
+		LOG_ERROR(&quot;No valid NAND flash driver found (%s)&quot;, driver_name);
+		return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
 	}
-
-	LOG_ERROR(&quot;No valid NAND flash driver found (%s)&quot;, driver_name);
-	return CALL_COMMAND_HANDLER(handle_nand_list_drivers);
+	return CALL_COMMAND_HANDLER(create_nand_device, bank_name, controller);
 }
 
 
diff --git a/src/flash/nand.h b/src/flash/nand.h
index f91deda..d675b29 100644
--- a/src/flash/nand.h
+++ b/src/flash/nand.h
@@ -28,68 +28,8 @@
 #include &lt;flash/common.h&gt;
 // to be removed later
 #include &lt;target/target.h&gt;
-
-struct nand_device;
-
-#define __NAND_DEVICE_COMMAND(name) \
-		COMMAND_HELPER(name, struct nand_device *nand)
-
-/**
- * Interface for NAND flash controllers.  Not all of these functions are
- * required for full functionality of the NAND driver, but better performance
- * can be achieved by implementing each function.
- */
-struct nand_flash_controller
-{
-	/** Driver name that is used to select it from configuration files. */
-	char *name;
-
-    const struct command_registration *commands;
-
-	/** NAND device command called when driver is instantiated during configuration. */
-	__NAND_DEVICE_COMMAND((*nand_device_command));
-
-	/** Register controller specific commands as a TCL interface to the driver. */
-	int (*register_commands)(struct command_context *cmd_ctx);
-
-	/** Initialize the NAND device. */
-	int (*init)(struct nand_device *nand);
-
-	/** Reset the NAND device. */
-	int (*reset)(struct nand_device *nand);
-
-	/** Issue a command to the NAND device. */
-	int (*command)(struct nand_device *nand, uint8_t command);
-
-	/** Write an address to the NAND device. */
-	int (*address)(struct nand_device *nand, uint8_t address);
-
-	/** Write word of data to the NAND device. */
-	int (*write_data)(struct nand_device *nand, uint16_t data);
-
-	/** Read word of data from the NAND device. */
-	int (*read_data)(struct nand_device *nand, void *data);
-
-	/** Write a block of data to the NAND device. */
-	int (*write_block_data)(struct nand_device *nand, uint8_t *data, int size);
-
-	/** Read a block of data from the NAND device. */
-	int (*read_block_data)(struct nand_device *nand, uint8_t *data, int size);
-
-	/** Write a page to the NAND device. */
-	int (*write_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-
-	/** Read a page from the NAND device. */
-	int (*read_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
-
-	/** Check if the controller is ready for more instructions with timeout. */
-	int (*controller_ready)(struct nand_device *nand, int timeout);
-
-	/** Check if the NAND device is ready for more instructions with timeout. */
-	int (*nand_ready)(struct nand_device *nand, int timeout);
-};
-
-#define NAND_DEVICE_COMMAND_HANDLER(name) static __NAND_DEVICE_COMMAND(name)
+// to be removed later
+#include &lt;flash/nand/driver.h&gt;
 
 /**
  * Representation of a single NAND block in a NAND device.
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
index 34947b6..7d250f6 100644
--- a/src/flash/nand/Makefile.am
+++ b/src/flash/nand/Makefile.am
@@ -3,6 +3,10 @@ AM_CPPFLAGS = -I$(top_srcdir)/src
 noinst_LTLIBRARIES = libocdflashnand.la
 
 libocdflashnand_la_SOURCES = \
+	$(NAND_DRIVERS) \
+	driver.c
+
+NAND_DRIVERS = \
 	nonce.c \
 	davinci.c \
 	lpc3180.c \
@@ -16,6 +20,7 @@ libocdflashnand_la_SOURCES = \
 
 noinst_HEADERS = \
 	lpc3180.h \
+	driver.h \
 	mx3.h \
 	s3c24xx.h \
 	s3c24xx_regs.h
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
new file mode 100644
index 0000000..717f5aa
--- /dev/null
+++ b/src/flash/nand/driver.c
@@ -0,0 +1,79 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;       *
+ *   Copyright (C) 2008 by Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;           *
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include &lt;config.h&gt;
+#endif
+#include &lt;flash/nand.h&gt;
+#include &quot;driver.h&quot;
+
+/* NAND flash controller
+ */
+extern struct nand_flash_controller nonce_nand_controller;
+extern struct nand_flash_controller davinci_nand_controller;
+extern struct nand_flash_controller lpc3180_nand_controller;
+extern struct nand_flash_controller orion_nand_controller;
+extern struct nand_flash_controller s3c2410_nand_controller;
+extern struct nand_flash_controller s3c2412_nand_controller;
+extern struct nand_flash_controller s3c2440_nand_controller;
+extern struct nand_flash_controller s3c2443_nand_controller;
+extern struct nand_flash_controller imx31_nand_flash_controller;
+
+/* extern struct nand_flash_controller boundary_scan_nand_controller; */
+
+static struct nand_flash_controller *nand_flash_controllers[] =
+{
+	&amp;nonce_nand_controller,
+	&amp;davinci_nand_controller,
+	&amp;lpc3180_nand_controller,
+	&amp;orion_nand_controller,
+	&amp;s3c2410_nand_controller,
+	&amp;s3c2412_nand_controller,
+	&amp;s3c2440_nand_controller,
+	&amp;s3c2443_nand_controller,
+	&amp;imx31_nand_flash_controller,
+/*	&amp;boundary_scan_nand_controller, */
+	NULL
+};
+
+struct nand_flash_controller *nand_driver_find_by_name(const char *name)
+{
+	for (unsigned i = 0; nand_flash_controllers[i]; i++)
+	{
+		struct nand_flash_controller *controller = nand_flash_controllers[i];
+		if (strcmp(name, controller-&gt;name) == 0)
+			return controller;
+	}
+	return NULL;
+}
+int nand_driver_walk(nand_driver_walker_t f, void *x)
+{
+	for (unsigned i = 0; nand_flash_controllers[i]; i++)
+	{
+		int retval = (*f)(nand_flash_controllers[i], x);
+		if (ERROR_OK != retval)
+			return retval;
+	}
+	return ERROR_OK;
+}
+
+
diff --git a/src/flash/nand/driver.h b/src/flash/nand/driver.h
new file mode 100644
index 0000000..545a731
--- /dev/null
+++ b/src/flash/nand/driver.h
@@ -0,0 +1,106 @@
+/***************************************************************************
+ *   Copyright (C) 2005 by Dominic Rath &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">Dominic.Rath at gmx.de</A>&gt;              *
+ *   Copyright (C) 2007,2008 &#195;&#152;yvind Harboe &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">oyvind.harboe at zylin.com</A>&gt;       *
+ *   Copyright (C) 2008 by Spencer Oliver &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">spen at spen-soft.co.uk</A>&gt;           *
+ *   Copyright (C) 2009 Zachary T Welch &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">zw at superlucidity.net</A>&gt;             *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#ifndef FLASH_NAND_DRIVER_H
+#define FLASH_NAND_DRIVER_H
+
+struct nand_device;
+
+#define __NAND_DEVICE_COMMAND(name) \
+		COMMAND_HELPER(name, struct nand_device *nand)
+
+/**
+ * Interface for NAND flash controllers.  Not all of these functions are
+ * required for full functionality of the NAND driver, but better performance
+ * can be achieved by implementing each function.
+ */
+struct nand_flash_controller
+{
+	/** Driver name that is used to select it from configuration files. */
+	char *name;
+
+    const struct command_registration *commands;
+
+	/** NAND device command called when driver is instantiated during configuration. */
+	__NAND_DEVICE_COMMAND((*nand_device_command));
+
+	/** Register controller specific commands as a TCL interface to the driver. */
+	int (*register_commands)(struct command_context *cmd_ctx);
+
+	/** Initialize the NAND device. */
+	int (*init)(struct nand_device *nand);
+
+	/** Reset the NAND device. */
+	int (*reset)(struct nand_device *nand);
+
+	/** Issue a command to the NAND device. */
+	int (*command)(struct nand_device *nand, uint8_t command);
+
+	/** Write an address to the NAND device. */
+	int (*address)(struct nand_device *nand, uint8_t address);
+
+	/** Write word of data to the NAND device. */
+	int (*write_data)(struct nand_device *nand, uint16_t data);
+
+	/** Read word of data from the NAND device. */
+	int (*read_data)(struct nand_device *nand, void *data);
+
+	/** Write a block of data to the NAND device. */
+	int (*write_block_data)(struct nand_device *nand, uint8_t *data, int size);
+
+	/** Read a block of data from the NAND device. */
+	int (*read_block_data)(struct nand_device *nand, uint8_t *data, int size);
+
+	/** Write a page to the NAND device. */
+	int (*write_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+
+	/** Read a page from the NAND device. */
+	int (*read_page)(struct nand_device *nand, uint32_t page, uint8_t *data, uint32_t data_size, uint8_t *oob, uint32_t oob_size);
+
+	/** Check if the controller is ready for more instructions with timeout. */
+	int (*controller_ready)(struct nand_device *nand, int timeout);
+
+	/** Check if the NAND device is ready for more instructions with timeout. */
+	int (*nand_ready)(struct nand_device *nand, int timeout);
+};
+
+#define NAND_DEVICE_COMMAND_HANDLER(name) static __NAND_DEVICE_COMMAND(name)
+
+/**
+ * Find a NAND flash controller by name.
+ * @param The name of the NAND controller to find.
+ * @returns The nand_flash_controller named @c name, or NULL if not found.
+ */
+struct nand_flash_controller *nand_driver_find_by_name(const char *name);
+
+/// Signature for callback functions passed to nand_driver_walk
+typedef int (*nand_driver_walker_t)(struct nand_flash_controller *c, void*);
+/**
+ * Walk the list of drivers, encapsulating the data structure type.
+ * Application state/context can be passed through the @c x pointer.
+ * @param f The callback function to invoke for each function.
+ * @param x For use as private data storate, passed directly to @c f.
+ * @returns ERROR_OK if successful, or the non-zero return value of @c f.
+ * This allows a walker to terminate the loop early.
+ */
+int nand_driver_walk(nand_driver_walker_t f, void *x);
+
+#endif // FLASH_NAND_DRIVER_H

-----------------------------------------------------------------------

Summary of changes:
 src/flash/Makefile.am                      |    8 +-
 src/flash/nand.c                           | 1795 ----------------------------
 src/flash/nand/Makefile.am                 |   13 +
 src/flash/{arm_nandio.c =&gt; nand/arm_io.c}  |    5 +-
 src/flash/{arm_nandio.h =&gt; nand/arm_io.h}  |    3 -
 src/flash/nand/core.c                      |  915 ++++++++++++++
 src/flash/{nand.h =&gt; nand/core.h}          |   75 +--
 src/flash/nand/davinci.c                   |    5 +-
 src/flash/nand/driver.c                    |   79 ++
 src/flash/nand/driver.h                    |  106 ++
 src/flash/{nand_ecc.c =&gt; nand/ecc.c}       |    2 +-
 src/flash/{nand_ecc_kw.c =&gt; nand/ecc_kw.c} |    4 +-
 src/flash/nand/fileio.c                    |  244 ++++
 src/flash/{nor/imp.h =&gt; nand/fileio.h}     |   71 +-
 src/{hello.h =&gt; flash/nand/imp.h}          |   26 +-
 src/flash/nand/lpc3180.c                   |    4 +-
 src/flash/nand/mx3.c                       |    2 +
 src/flash/nand/mx3.h                       |    1 -
 src/flash/nand/nonce.c                     |    3 +-
 src/flash/nand/orion.c                     |    3 +-
 src/flash/nand/s3c24xx.h                   |    5 +-
 src/flash/nand/tcl.c                       |  645 ++++++++++
 src/openocd.c                              |    2 +-
 23 files changed, 2084 insertions(+), 1932 deletions(-)
 delete mode 100644 src/flash/nand.c
 rename src/flash/{arm_nandio.c =&gt; nand/arm_io.c} (99%)
 rename src/flash/{arm_nandio.h =&gt; nand/arm_io.h} (96%)
 create mode 100644 src/flash/nand/core.c
 rename src/flash/{nand.h =&gt; nand/core.h} (74%)
 create mode 100644 src/flash/nand/driver.c
 create mode 100644 src/flash/nand/driver.h
 rename src/flash/{nand_ecc.c =&gt; nand/ecc.c} (99%)
 rename src/flash/{nand_ecc_kw.c =&gt; nand/ecc_kw.c} (99%)
 create mode 100644 src/flash/nand/fileio.c
 copy src/flash/{nor/imp.h =&gt; nand/fileio.h} (59%)
 copy src/{hello.h =&gt; flash/nand/imp.h} (71%)
 create mode 100644 src/flash/nand/tcl.c


hooks/post-receive
-- 
Main OpenOCD repository

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001927.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-877-gaf1d759
</A></li>
	<LI>Next message: <A HREF="001929.html">[openocd-svn] Main OpenOCD repository branch, master,	updated. v0.3.0-883-gec8c3b5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1928">[ date ]</a>
              <a href="thread.html#1928">[ thread ]</a>
              <a href="subject.html#1928">[ subject ]</a>
              <a href="author.html#1928">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
