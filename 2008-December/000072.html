<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1288 - trunk/src/jtag
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1288%20-%20trunk/src/jtag&In-Reply-To=%3C200812272240.mBRMerOG007164%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000071.html">
   <LINK REL="Next"  HREF="000073.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1288 - trunk/src/jtag</H1>
    <B>duane at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1288%20-%20trunk/src/jtag&In-Reply-To=%3C200812272240.mBRMerOG007164%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1288 - trunk/src/jtag">duane at mail.berlios.de
       </A><BR>
    <I>Sat Dec 27 23:40:53 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000071.html">[Openocd-svn] r1287 - in trunk/src/jtag: . rlink
</A></li>
        <LI>Next message: <A HREF="000073.html">[Openocd-svn] r1289 - trunk/src/jtag
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#72">[ date ]</a>
              <a href="thread.html#72">[ thread ]</a>
              <a href="subject.html#72">[ subject ]</a>
              <a href="author.html#72">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: duane
Date: 2008-12-27 23:40:51 +0100 (Sat, 27 Dec 2008)
New Revision: 1288

Added:
   trunk/src/jtag/vsllink.c
Log:
Missed the svn add on earlier commit, duh

Added: trunk/src/jtag/vsllink.c
===================================================================
--- trunk/src/jtag/vsllink.c	2008-12-27 22:35:35 UTC (rev 1287)
+++ trunk/src/jtag/vsllink.c	2008-12-27 22:40:51 UTC (rev 1288)
@@ -0,0 +1,1334 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by Simon Qian &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">SimonQian at SimonQian.com</A>&gt;            *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+/* Versaloon is a programming tool for multiple MCUs.
+ * OpenOCD and MSP430 supports are distributed under GPLv2.
+ * You can find it at <A HREF="http://www.SimonQian.com/en/Versaloon.">http://www.SimonQian.com/en/Versaloon.</A>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;replacements.h&quot;
+
+#include &quot;jtag.h&quot;
+
+#include &lt;usb.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;log.h&quot;
+
+//#define _VSLLINK_IN_DEBUG_MODE_
+
+/* enable this to view USB communication
+ */
+#if 0
+#define _DEBUG_USB_COMMS_
+#endif
+
+#ifdef _DEBUG_JTAG_IO_
+#define DEBUG_JTAG_IO(expr ...)	LOG_DEBUG(expr)
+#else
+#define DEBUG_JTAG_IO(expr ...)
+#endif
+
+#define VID							0x03EB
+#define PID							0x2103
+#define VSLLINK_WRITE_ENDPOINT		0x02
+#define VSLLINK_READ_ENDPOINT		0x82
+
+u16 vsllink_vid = VID;
+u16 vsllink_pid = PID;
+u8 vsllink_bulkout = VSLLINK_WRITE_ENDPOINT;
+u8 vsllink_bulkin = VSLLINK_READ_ENDPOINT;
+
+#define VSLLINK_USB_TIMEOUT			1000
+
+static int VSLLINK_BufferSize = 1024;
+
+/* Global USB buffers */
+static int vsllink_usb_out_buffer_idx;
+static int vsllink_usb_in_want_length;
+static u8* vsllink_usb_in_buffer = NULL;
+static u8* vsllink_usb_out_buffer = NULL;
+
+/* Constants for VSLLink command */
+#define VSLLINK_CMD_CONN			0x80
+#define VSLLINK_CMD_DISCONN			0x81
+#define VSLLINK_CMD_SET_SPEED		0x82
+#define VSLLINK_CMD_SET_PORT		0x90
+#define VSLLINK_CMD_GET_PORT		0x91
+#define VSLLINK_CMD_SET_PORTDIR		0x92
+#define VSLLINK_CMD_HW_JTAGSEQCMD	0xA0
+
+#define VSLLINK_CMDJTAGSEQ_TMSBYTE	0x00
+#define VSLLINK_CMDJTAGSEQ_SCAN		0x80
+
+#define VSLLINK_CMDJTAGSEQ_CMDMSK	0xC0
+#define VSLLINK_CMDJTAGSEQ_LENMSK	0x3F
+
+#define JTAG_PINMSK_SRST			(1 &lt;&lt; 0)
+#define JTAG_PINMSK_TRST			(1 &lt;&lt; 1)
+#define JTAG_PINMSK_USR1			(1 &lt;&lt; 2)
+#define JTAG_PINMSK_USR2			(1 &lt;&lt; 3)
+#define JTAG_PINMSK_TCK				(1 &lt;&lt; 4)
+#define JTAG_PINMSK_TMS				(1 &lt;&lt; 5)
+#define JTAG_PINMSK_TDI				(1 &lt;&lt; 6)
+#define JTAG_PINMSK_TDO				(1 &lt;&lt; 7)
+
+
+#define VSLLINK_TAP_MOVE(from, to) VSLLINK_tap_move[tap_move_map[from]][tap_move_map[to]]
+
+/* VSLLINK_tap_move[i][j]: tap movement command to go from state i to state j
+ * 0: Test-Logic-Reset
+ * 1: Run-Test/Idle
+ * 2: Shift-DR
+ * 3: Pause-DR
+ * 4: Shift-IR
+ * 5: Pause-IR
+ * 
+ * SD-&gt;SD and SI-&gt;SI have to be caught in interface specific code
+ */
+u8 VSLLINK_tap_move[6][6] =
+{
+/*	  TLR   RTI   SD    PD    SI    PI             */
+	{0xff, 0x00, 0x2f, 0x0a, 0x37, 0x16},	/* TLR */
+	{0xff, 0x00, 0x45, 0x05, 0x4b, 0x0b},	/* RTI */
+	{0xff, 0x61, 0x00, 0x01, 0x0f, 0x2f},	/* SD  */
+	{0xff, 0x60, 0x40, 0x17, 0x3c, 0x2f},	/* PD  */
+	{0xff, 0x61, 0x07, 0x17, 0x00, 0x01},	/* SI  */
+	{0xff, 0x60, 0x38, 0x17, 0x40, 0x2f}	/* PI  */
+};
+
+u8 VSLLINK_TAP_MOVE_FROM_E1[6] =
+{
+//	TLR		RTI		SD		PD		SI		PI
+	0xff,	0x60,	0x38,	0x5c,	0x3c,	0x5E
+};
+
+u8 VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[7][6][2] =
+{
+/*	 stuff	offset   */
+	{/*	TLR	*/
+	{1,		0,},	/* TLR */
+	{1,		0,},	/* RTI */
+	{1,		0,},	/* SD  */
+	{1,		0,},	/* PD  */
+	{1,		0,},	/* SI  */
+	{1,		0,}},	/* PI  */
+	{/*	RTI	*/
+	{1,		0,},	/* TLR */
+	{0,		0,},	/* RTI */
+	{0,		4,},	/* SD  */
+	{0,		7,},	/* PD  */
+	{0,		5,},	/* SI  */
+	{0,		7,}},	/* PI  */
+	{/*	SD	*/
+	{0,		0,},	/* TLR */
+	{0,		0,},	/* RTI */
+	{0,		0,},	/* SD  */
+	{0,		0,},	/* PD  */
+	{0,		0,},	/* SI  */
+	{0,		0,}},	/* PI  */
+	{/*	PD	*/
+	{0,		0,},	/* TLR */
+	{0,		0,},	/* RTI */
+	{0,		0,},	/* SD  */
+	{0,		0,},	/* PD  */
+	{0,		0,},	/* SI  */
+	{0,		0,}},	/* PI  */
+	{/*	SI	*/
+	{0,		0,},	/* TLR */
+	{0,		0,},	/* RTI */
+	{0,		0,},	/* SD  */
+	{0,		0,},	/* PD  */
+	{0,		0,},	/* SI  */
+	{0,		0,}},	/* PI  */
+	{/*	PI	*/
+	{0,		0,},	/* TLR */
+	{0,		0,},	/* RTI */
+	{0,		0,},	/* SD  */
+	{0,		0,},	/* PD  */
+	{0,		0,},	/* SI  */
+	{0,		0,}},	/* PI  */
+};
+
+u8 VSLLINK_BIT_MSK[8] =
+{
+	0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f
+};
+
+/* External interface functions */
+int vsllink_execute_queue(void);
+int vsllink_speed(int speed);
+int vsllink_khz(int khz, int *jtag_speed);
+int vsllink_speed_div(int jtag_speed, int *khz);
+int vsllink_register_commands(struct command_context_s *cmd_ctx);
+int vsllink_init(void);
+int vsllink_quit(void);
+
+/* CLI command handler functions */
+int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
+
+/* Queue command functions */
+void vsllink_end_state(enum tap_state state);
+void vsllink_state_move(void);
+void vsllink_path_move(int num_states, enum tap_state *path);
+void vsllink_runtest(int num_cycles);
+void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command);
+void vsllink_reset(int trst, int srst);
+void vsllink_simple_command(u8 command);
+
+/* VSLLink tap buffer functions */
+void vsllink_tap_init();
+int vsllink_tap_execute();
+void vsllink_tap_ensure_space(int scans, int bytes);
+void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset);
+
+/* VSLLink lowlevel functions */
+typedef struct vsllink_jtag
+{
+	struct usb_dev_handle* usb_handle;
+} vsllink_jtag_t;
+
+vsllink_jtag_t *vsllink_usb_open(void);
+void vsllink_usb_close(vsllink_jtag_t *vsllink_jtag);
+int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length);
+int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length);
+int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag);
+
+void vsllink_debug_buffer(u8 *buffer, int length);
+
+int vsllink_tms_data_len = 0;
+u8* vsllink_tms_cmd_pos;
+
+vsllink_jtag_t* vsllink_jtag_handle;
+
+/***************************************************************************/
+/* External interface implementation */
+
+jtag_interface_t vsllink_interface =
+{
+	.name = &quot;vsllink&quot;,
+	.execute_queue = vsllink_execute_queue,
+	.speed = vsllink_speed,
+	.khz = vsllink_khz,
+	.speed_div = vsllink_speed_div,
+	.register_commands = vsllink_register_commands,
+	.init = vsllink_init,
+	.quit = vsllink_quit
+};
+
+int vsllink_execute_queue(void)
+{
+	jtag_command_t *cmd = jtag_command_queue;
+	int scan_size;
+	enum scan_type type;
+	u8 *buffer;
+
+	DEBUG_JTAG_IO(&quot;--------------------------------------------------------------------------------&quot;);
+
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
+	vsllink_usb_out_buffer_idx = 3;
+	while (cmd != NULL)
+	{
+		switch (cmd-&gt;type)
+		{
+			case JTAG_END_STATE:
+				DEBUG_JTAG_IO(&quot;end_state: %i&quot;, cmd-&gt;cmd.end_state-&gt;end_state);
+			
+				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
+				{
+					vsllink_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
+				}
+				break;
+	
+			case JTAG_RUNTEST:
+				DEBUG_JTAG_IO( &quot;runtest %i cycles, end in %i&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, \
+					cmd-&gt;cmd.runtest-&gt;end_state);
+				
+				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
+				{
+					vsllink_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
+				}
+				vsllink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
+				break;
+	
+			case JTAG_STATEMOVE:
+				DEBUG_JTAG_IO(&quot;statemove end in %i&quot;, cmd-&gt;cmd.statemove-&gt;end_state);
+			
+				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
+				{
+					vsllink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
+				}
+				vsllink_state_move();
+				break;
+	
+			case JTAG_PATHMOVE:
+				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %i&quot;, \
+					cmd-&gt;cmd.pathmove-&gt;num_states, \
+					cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]);
+			
+				vsllink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path);
+				break;
+	
+			case JTAG_SCAN:
+				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
+				{
+					vsllink_end_state(cmd-&gt;cmd.scan-&gt;end_state);
+				}
+			
+				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
+				if (cmd-&gt;cmd.scan-&gt;ir_scan)
+				{
+					DEBUG_JTAG_IO(&quot;JTAG Scan write IR(%d bits), end in %d:&quot;, scan_size, cmd-&gt;cmd.scan-&gt;end_state);
+				}
+				else
+				{
+					DEBUG_JTAG_IO(&quot;JTAG Scan write DR(%d bits), end in %d:&quot;, scan_size, cmd-&gt;cmd.scan-&gt;end_state);
+				}
+
+#ifdef _DEBUG_JTAG_IO_
+				vsllink_debug_buffer(buffer, (scan_size + 7) &gt;&gt; 3);
+#endif
+
+				type = jtag_scan_type(cmd-&gt;cmd.scan);
+
+				vsllink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size, cmd-&gt;cmd.scan);
+				break;
+	
+			case JTAG_RESET:
+				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+
+				vsllink_tap_execute();
+			
+				if (cmd-&gt;cmd.reset-&gt;trst == 1)
+				{
+					cur_state = TAP_RESET;
+				}
+				vsllink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
+
+				vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
+				vsllink_usb_out_buffer_idx = 3;
+				break;
+	
+			case JTAG_SLEEP:
+				DEBUG_JTAG_IO(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
+				vsllink_tap_execute();
+				jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
+				break;
+	
+			default:
+				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
+				exit(-1);
+		}
+		cmd = cmd-&gt;next;
+	}
+	
+	return vsllink_tap_execute();
+}
+
+int vsllink_speed(int speed)
+{
+	int result;
+
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_SPEED;
+	vsllink_usb_out_buffer[1] = (speed &gt;&gt; 0) &amp; 0xff;
+	vsllink_usb_out_buffer[2] = (speed &gt;&gt; 8) &amp; 0xFF;
+		
+	result = vsllink_usb_write(vsllink_jtag_handle, 3);
+		
+	if (result == 3)
+	{
+		return ERROR_OK;
+	}
+	else
+	{
+		LOG_ERROR(&quot;VSLLink setting speed failed (%d)&quot;, result);
+		return ERROR_JTAG_DEVICE_ERROR;
+	}
+	
+	return ERROR_OK;
+}
+
+int vsllink_khz(int khz, int *jtag_speed)
+{
+	*jtag_speed = khz;
+	
+	return ERROR_OK;
+}
+
+int vsllink_speed_div(int jtag_speed, int *khz)
+{
+	*khz = jtag_speed;
+
+	return ERROR_OK;
+}
+
+int vsllink_register_commands(struct command_context_s *cmd_ctx)
+{
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_vid&quot;, vsllink_handle_usb_vid_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_pid&quot;, vsllink_handle_usb_pid_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkin&quot;, vsllink_handle_usb_bulkin_command, 
+					COMMAND_CONFIG, NULL);
+	register_command(cmd_ctx, NULL, &quot;vsllink_usb_bulkout&quot;, vsllink_handle_usb_bulkout_command, 
+					COMMAND_CONFIG, NULL);
+
+	return ERROR_OK;
+}
+
+int vsllink_init(void)
+{
+	int check_cnt;  
+	int result;
+	char version_str[100];
+
+	vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
+	vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
+	if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
+	{
+		LOG_ERROR(&quot;Not enough memory&quot;);
+		exit(-1);
+	}
+
+	vsllink_jtag_handle = vsllink_usb_open();
+	
+	if (vsllink_jtag_handle == 0)
+	{
+		LOG_ERROR(&quot;Can't find USB JTAG Interface! Please check connection and permissions.&quot;);
+		return ERROR_JTAG_INIT_FAILED;
+	}
+		
+	check_cnt = 0;
+	while (check_cnt &lt; 3)
+	{
+		vsllink_simple_command(VSLLINK_CMD_CONN);
+		result = vsllink_usb_read(vsllink_jtag_handle);
+
+		if (result &gt; 2)
+		{
+			vsllink_usb_in_buffer[result] = 0;
+			VSLLINK_BufferSize = vsllink_usb_in_buffer[0] + (vsllink_usb_in_buffer[1] &lt;&lt; 8);
+			strncpy(version_str, (char *)vsllink_usb_in_buffer + 2, sizeof(version_str));
+			LOG_INFO(version_str);
+
+			// free the pre-alloc memroy
+			free(vsllink_usb_in_buffer);
+			free(vsllink_usb_out_buffer);
+			vsllink_usb_in_buffer = NULL;
+			vsllink_usb_out_buffer = NULL;
+
+			// alloc new memory
+			vsllink_usb_in_buffer = malloc(VSLLINK_BufferSize);
+			vsllink_usb_out_buffer = malloc(VSLLINK_BufferSize);
+			if ((vsllink_usb_in_buffer == NULL) || (vsllink_usb_out_buffer == NULL))
+			{
+				LOG_ERROR(&quot;Not enough memory&quot;);
+				exit(-1);
+			}
+			else
+			{
+				LOG_INFO(&quot;buffer size for USB is %d bytes&quot;, VSLLINK_BufferSize);
+			}
+			break;
+		}
+		vsllink_simple_command(VSLLINK_CMD_DISCONN);
+
+		check_cnt++;
+	}
+
+	if (check_cnt == 3)
+	{
+		// It's dangerout to proced
+		LOG_ERROR(&quot;VSLLink initial failed&quot;);
+		exit(-1);
+	}
+
+	// Set SRST and TRST to output, Set USR1 and USR2 to input
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORTDIR;
+	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST | JTAG_PINMSK_USR1 | JTAG_PINMSK_USR2;
+	vsllink_usb_out_buffer[2] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
+	result = vsllink_usb_write(vsllink_jtag_handle, 3);
+	if (result != 3)
+	{
+		LOG_ERROR(&quot;VSLLink USB send data error&quot;);
+		exit(-1);
+	}
+
+	vsllink_reset(0, 0);
+
+	LOG_INFO(&quot;VSLLink JTAG Interface ready&quot;);
+
+	vsllink_tap_init();
+	
+	return ERROR_OK;
+}
+
+int vsllink_quit(void)
+{
+	if ((vsllink_usb_in_buffer != NULL) &amp;&amp; (vsllink_usb_out_buffer != NULL))
+	{
+		vsllink_simple_command(VSLLINK_CMD_DISCONN);
+		vsllink_usb_close(vsllink_jtag_handle);
+	}
+
+	if (vsllink_usb_in_buffer != NULL)
+	{
+		free(vsllink_usb_in_buffer);
+	}
+	if (vsllink_usb_out_buffer != NULL)
+	{
+		free(vsllink_usb_out_buffer);
+	}
+	return ERROR_OK;
+}
+
+// when vsllink_tms_data_len &gt; 0, vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] is the byte that need to be appended.
+// length of VSLLINK_CMDJTAGSEQ_TMSBYTE has been set.
+void VSLLINK_add_tms_from_RTI(enum tap_state state)
+{
+	u8 tms_scan = VSLLINK_TAP_MOVE(TAP_IDLE, state);
+	u16 tms2;
+
+	if ((cur_state != TAP_IDLE) || (state == TAP_IDLE) || (vsllink_tms_data_len &lt;= 0) || (vsllink_tms_data_len &gt;= 8) || (vsllink_tms_cmd_pos == NULL))
+	{
+		LOG_ERROR(&quot;There MUST be some bugs in the driver&quot;);
+		exit(-1);
+	}
+
+	tms2 = (tms_scan &amp; VSLLINK_BIT_MSK[VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]]) &lt;&lt; vsllink_tms_data_len;
+	if (VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][0] == 1)
+	{
+		tms2 |= VSLLINK_BIT_MSK[8 - vsllink_tms_data_len] &lt;&lt; (vsllink_tms_data_len + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]);
+	}
+	tms2 |= (tms_scan &gt;&gt; VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]) &lt;&lt; (8 + VSLLINK_TAP_MOVE_INSERT_INSIGNIFICANT[1][tap_move_map[state]][1]);
+
+	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] |= (tms2 &gt;&gt; 0) &amp; 0xff;
+	vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tms2 &gt;&gt; 8) &amp; 0xff;
+
+	vsllink_tms_data_len = 0;
+	vsllink_tms_cmd_pos = NULL;
+}
+
+/***************************************************************************/
+/* Queue command implementations */
+
+void vsllink_end_state(enum tap_state state)
+{
+	if (tap_move_map[state] != -1)
+	{
+		end_state = state;
+	}
+	else
+	{
+		LOG_ERROR(&quot;BUG: %i is not a valid end state&quot;, state);
+		exit(-1);
+	}
+}
+
+/* Goes to the end state. */
+void vsllink_state_move(void)
+{
+	if (vsllink_tms_data_len &gt; 0)
+	{
+		VSLLINK_add_tms_from_RTI(end_state);
+	}
+	else
+	{
+		vsllink_tap_ensure_space(0, 2);
+
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
+	}
+
+	cur_state = end_state;
+}
+
+// write tms from current vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx]
+void vsllink_add_path(int start, int num, enum tap_state *path)
+{
+	int i;
+
+	for (i = start; i &lt; (start + num); i++)
+	{
+		if ((i &amp; 7) == 0)
+		{
+			if (i &gt; 0)
+			{
+				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+			}
+			else
+			{
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = 0;
+			}
+		}
+
+		if (path[i - start] == tap_transitions[cur_state].high)
+		{
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] |= 1 &lt;&lt; (i &amp; 7);
+		}
+		else
+		{
+			LOG_ERROR(&quot;BUG: %d -&gt; %d isn't a valid TAP transition&quot;, cur_state, path[i]);
+			exit(-1);
+		}
+
+		cur_state = path[i];
+	}
+	end_state = cur_state;
+}
+
+void vsllink_path_move(int num_states, enum tap_state *path)
+{
+	int i, tms_len, tms_cmd_pos, path_idx = 0;
+
+	if (vsllink_tms_data_len &gt; 0)
+	{
+		if ((vsllink_tms_data_len + num_states) &lt; 8)
+		{
+			vsllink_add_path(vsllink_tms_data_len, num_states, path);
+			num_states = 0;
+		}
+		else if ((vsllink_tms_data_len + num_states) &lt; 16)
+		{
+			if ((*vsllink_tms_cmd_pos &amp; VSLLINK_CMDJTAGSEQ_LENMSK) \
+					&lt; VSLLINK_CMDJTAGSEQ_LENMSK)
+			{
+				*vsllink_tms_cmd_pos++;
+				vsllink_add_path(vsllink_tms_data_len, num_states, path);
+			}
+			else
+			{
+				// need a new VSLLINK_CMDJTAGSEQ_TMSBYTE command
+				// if vsllink_tms_data_len &gt; 0, length of VSLLINK_CMDJTAGSEQ_TMSBYTE MUST be &gt; 1(tms_len &gt; 2)
+				*vsllink_tms_cmd_pos--;
+				vsllink_add_path(vsllink_tms_data_len, 8 - vsllink_tms_data_len, path);
+				vsllink_usb_out_buffer_idx++;
+				vsllink_tap_ensure_space(0, 3);
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
+				vsllink_tms_cmd_pos = vsllink_usb_out_buffer + vsllink_usb_out_buffer_idx;
+				vsllink_add_path(vsllink_tms_data_len, num_states + vsllink_tms_data_len - 8, path + 8 - vsllink_tms_data_len);
+			}
+			vsllink_tms_data_len = (vsllink_tms_data_len + num_states) &amp; 7;
+			num_states = 0;
+		}
+		else
+		{
+			vsllink_add_path(vsllink_tms_data_len, 16 - vsllink_tms_data_len, path);
+			path_idx = 16 - vsllink_tms_data_len;
+			vsllink_usb_out_buffer_idx++;
+
+			num_states -= 16 - vsllink_tms_data_len;
+			path += 16 - vsllink_tms_data_len;
+			vsllink_tms_data_len = 0;
+			vsllink_tms_cmd_pos = NULL;
+		}
+	}
+
+	if (num_states &gt; 0)
+	{
+		// Normal operation, don't need to append tms data
+		vsllink_tms_data_len = num_states &amp; 7;
+
+		while (num_states &gt; 0)
+		{
+			if (num_states &gt; ((VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8))
+			{
+				i = (VSLLINK_CMDJTAGSEQ_LENMSK + 1) * 8;
+			}
+			else
+			{
+				i = num_states;
+			}
+			tms_len = (i + 7) &gt;&gt; 3;
+			vsllink_tap_ensure_space(0, tms_len + 2);
+			tms_cmd_pos = vsllink_usb_out_buffer_idx;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | (tms_len - 1);
+
+			vsllink_add_path(0, i, path + path_idx);
+
+			path_idx += i;
+			num_states -= i;
+		}
+
+		if (vsllink_tms_data_len &gt; 0)
+		{
+			if (tms_len &lt; (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
+			{
+				vsllink_usb_out_buffer[tms_cmd_pos]++;
+				vsllink_usb_out_buffer = vsllink_usb_out_buffer + tms_cmd_pos;
+			}
+			else
+			{
+				vsllink_usb_out_buffer[tms_cmd_pos]--;
+				tms_len = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+				vsllink_tap_ensure_space(0, 3);
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] = tms_len;
+			}
+		}
+	}
+}
+
+void vsllink_runtest(int num_cycles)
+{
+	int i, j;
+	int tms_len, first_tms = 0, tms_cmd_pos;
+	enum tap_state saved_end_state = end_state;
+
+	if (cur_state != TAP_IDLE)
+	{
+		vsllink_end_state(TAP_IDLE);
+
+		if (vsllink_tms_data_len &gt; 0)
+		{
+			VSLLINK_add_tms_from_RTI(end_state);
+		}
+		else
+		{
+			first_tms = 1;
+		}
+	}
+
+	if (vsllink_tms_data_len &gt; 0)
+	{
+		// cur_state == TAP_IDLE
+		if ((vsllink_tms_data_len + num_cycles) &lt; 8)
+		{
+			vsllink_tms_data_len += num_cycles;
+			num_cycles = 0;
+		}
+		else if ((vsllink_tms_data_len + num_cycles) &lt; 16)
+		{
+			if ((*vsllink_tms_cmd_pos &amp; VSLLINK_CMDJTAGSEQ_LENMSK) \
+					&lt; VSLLINK_CMDJTAGSEQ_LENMSK)
+			{
+				*vsllink_tms_cmd_pos++;
+				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+			}
+			else
+			{
+				// need a new VSLLINK_CMDJTAGSEQ_TMSBYTE command
+				// if vsllink_tms_data_len &gt; 0, length of VSLLINK_CMDJTAGSEQ_TMSBYTE MUST be &gt; 1(tms_len &gt; 2)
+				*vsllink_tms_cmd_pos--;
+				vsllink_tap_ensure_space(0, 3);
+				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = VSLLINK_CMDJTAGSEQ_TMSBYTE | 1;
+				vsllink_tms_cmd_pos = vsllink_usb_out_buffer + vsllink_usb_out_buffer_idx;
+				vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+			}
+			vsllink_tms_data_len = (vsllink_tms_data_len + num_cycles) &amp; 7;
+			num_cycles = 0;
+		}
+		else
+		{
+			vsllink_usb_out_buffer[++vsllink_usb_out_buffer_idx] = 0;
+			vsllink_usb_out_buffer_idx++;
+
+			num_cycles -= 16 - vsllink_tms_data_len;
+			vsllink_tms_data_len = 0;
+			vsllink_tms_cmd_pos = NULL;
+		}
+	}
+
+	tms_len = ((num_cycles + 7) &gt;&gt; 3) + first_tms;
+	if (tms_len &gt; 0)
+	{
+		// Normal operation, don't need to append tms data
+		vsllink_tms_data_len = num_cycles &amp; 7;
+
+		if (vsllink_tms_data_len &gt; 0)
+		{
+			tms_len += 1;
+		}
+		// tms_len includes the length of tms byte to append
+
+		// Make sure there is enough space
+		// 1 more byte maybe needed for the last tms move
+		vsllink_tap_ensure_space(0, (tms_len / VSLLINK_CMDJTAGSEQ_LENMSK) + tms_len + 1);
+
+		while(tms_len &gt; 0)
+		{
+			if (tms_len &gt; (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
+			{
+				i = VSLLINK_CMDJTAGSEQ_LENMSK + 1;
+			}
+			else
+			{
+				i = tms_len;
+			}
+
+			tms_cmd_pos = vsllink_usb_out_buffer_idx;
+
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE | (i - 1);
+
+			if (first_tms)
+			{
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
+				first_tms = 0;
+				j = i - 1;
+			}
+			else
+			{
+				j = i;
+			}
+
+			while (j-- &gt; 0)
+			{
+				vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+			}
+
+			tms_len -= i;
+		}
+
+		// post process vsllink_usb_out_buffer_idx
+		if (vsllink_tms_data_len &gt; 0)
+		{
+			vsllink_usb_out_buffer_idx -= 2;
+		}
+
+		// Set end_state
+		vsllink_end_state(saved_end_state);
+		cur_state = TAP_IDLE;
+		if (saved_end_state != TAP_IDLE)
+		{
+			if (vsllink_tms_data_len &gt; 0)
+			{
+				VSLLINK_add_tms_from_RTI(end_state);
+			}
+			else
+			{
+				if (i &lt; (VSLLINK_CMDJTAGSEQ_LENMSK + 1))
+				{
+					vsllink_usb_out_buffer[tms_cmd_pos]++;
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(TAP_IDLE, end_state);
+				}
+				else
+				{
+					vsllink_tap_ensure_space(0, 2);
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
+					vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(TAP_IDLE, end_state);
+				}
+			}
+			cur_state = saved_end_state;
+		}
+
+		if (vsllink_tms_data_len &gt; 0)
+		{
+			vsllink_tms_cmd_pos = vsllink_usb_out_buffer + tms_cmd_pos;
+		}
+	}
+	else
+	{
+		// Set end_state if no RTI shifts
+		vsllink_end_state(saved_end_state);
+		cur_state = TAP_IDLE;
+		if (saved_end_state != TAP_IDLE)
+		{
+			vsllink_tap_ensure_space(0, 2);
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_TMSBYTE;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(TAP_IDLE, end_state);
+
+			cur_state = saved_end_state;
+		}
+	}
+}
+
+void vsllink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
+{
+	enum tap_state saved_end_state;
+	u8 bits_left, tms_tmp, tdi_len;
+	int i;
+
+	tdi_len = ((scan_size + 7) &gt;&gt; 3);
+	if ((tdi_len + 7) &gt; VSLLINK_BufferSize)
+	{
+		LOG_ERROR(&quot;Your implementation of VSLLink has not enough buffer&quot;);
+		exit(-1);
+	}
+	
+	saved_end_state = end_state;
+	
+	/* Move to appropriate scan state */
+	vsllink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
+
+	if (vsllink_tms_data_len &gt; 0)
+	{
+		if (cur_state == end_state)
+		{
+			*vsllink_tms_cmd_pos--;
+			tms_tmp = vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx];
+			vsllink_tap_ensure_space(1, tdi_len + 7);
+
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)&gt;&gt; 8) &amp; 0xff;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = tms_tmp;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[0] &lt;&lt; (8 - vsllink_tms_data_len);
+
+			for (i = 0; i &lt; tdi_len; i++)
+			{
+				buffer[i] &gt;&gt;= 8 - vsllink_tms_data_len;
+				if (i != tdi_len)
+				{
+					buffer[i] += buffer[i + 1] &lt;&lt; vsllink_tms_data_len;
+				}
+			}
+
+			vsllink_tap_append_scan(scan_size - vsllink_tms_data_len, buffer, command, vsllink_tms_data_len);
+			scan_size -= 8 - vsllink_tms_data_len;
+		}
+		else
+		{
+			VSLLINK_add_tms_from_RTI(end_state);
+			vsllink_tap_ensure_space(1, tdi_len + 5);
+
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 0) &amp; 0xff;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = (tdi_len &gt;&gt; 8) &amp; 0xff;
+
+			vsllink_tap_append_scan(scan_size, buffer, command, 0);
+		}
+	}
+	else
+	{
+		vsllink_tap_ensure_space(1, tdi_len + 7);
+
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_CMDJTAGSEQ_SCAN | 1;
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1) &gt;&gt; 0) &amp; 0xff;
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = ((tdi_len + 1)&gt;&gt; 8) &amp; 0xff;
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE(cur_state, end_state);
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+
+		vsllink_tap_append_scan(scan_size, buffer, command, 8);
+	}
+	vsllink_end_state(saved_end_state);
+
+	bits_left = scan_size &amp; 0x07;
+	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
+
+	if (bits_left &gt; 0)
+	{
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; (bits_left - 1);
+	}
+	else
+	{
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 1 &lt;&lt; 7;
+	}
+
+	if (cur_state != end_state)
+	{
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = VSLLINK_TAP_MOVE_FROM_E1[tap_move_map[end_state]];
+	}
+	else
+	{
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+	}
+
+	cur_state = end_state;
+}
+
+void vsllink_reset(int trst, int srst)
+{
+	int result;
+
+	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
+	
+	/* Signals are active low */
+	vsllink_usb_out_buffer[0] = VSLLINK_CMD_SET_PORT;
+	vsllink_usb_out_buffer[1] = JTAG_PINMSK_SRST | JTAG_PINMSK_TRST;
+	vsllink_usb_out_buffer[2] = 0;
+	if (srst == 0)
+	{
+		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_SRST;
+	}
+	if (trst == 0)
+	{
+		vsllink_usb_out_buffer[2] |= JTAG_PINMSK_TRST;
+	}
+
+	result = vsllink_usb_write(vsllink_jtag_handle, 3);
+	if (result != 3)
+	{
+		LOG_ERROR(&quot;VSLLink command VSLLINK_CMD_SET_PORT failed (%d)&quot;);
+	}
+}
+
+void vsllink_simple_command(u8 command)
+{
+	int result;
+	
+	DEBUG_JTAG_IO(&quot;0x%02x&quot;, command);
+	
+	vsllink_usb_out_buffer[0] = command;
+	result = vsllink_usb_write(vsllink_jtag_handle, 1);
+	
+	if (result != 1)
+	{
+		LOG_ERROR(&quot;VSLLink command 0x%02x failed (%d)&quot;, command, result);
+	}
+}
+
+int vsllink_handle_usb_vid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc != 1) {
+	    LOG_ERROR(&quot;parameter error, should be one parameter for VID&quot;);
+		return ERROR_OK;
+	}
+
+	vsllink_vid = strtol(args[0], NULL, 0);
+
+	return ERROR_OK;
+}
+
+int vsllink_handle_usb_pid_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc != 1) {
+	    LOG_ERROR(&quot;parameter error, should be one parameter for PID&quot;);
+		return ERROR_OK;
+	}
+
+	vsllink_pid = strtol(args[0], NULL, 0);
+
+	return ERROR_OK;
+}
+
+int vsllink_handle_usb_bulkin_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc != 1) {
+	    LOG_ERROR(&quot;parameter error, should be one parameter for BULKIN endpoint&quot;);
+		return ERROR_OK;
+	}
+
+	vsllink_bulkin = strtol(args[0], NULL, 0) | 0x80;
+
+	return ERROR_OK;
+}
+
+int vsllink_handle_usb_bulkout_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
+{
+	if (argc != 1) {
+	    LOG_ERROR(&quot;parameter error, should be one parameter for BULKOUT endpoint&quot;);
+		return ERROR_OK;
+	}
+
+	vsllink_bulkout = strtol(args[0], NULL, 0);
+
+	return ERROR_OK;
+}
+
+/***************************************************************************/
+/* VSLLink tap functions */
+
+typedef struct
+{
+	int length; /* Number of bits to read */
+	int offset;
+	scan_command_t *command; /* Corresponding scan command */
+	u8 *buffer;
+} pending_scan_result_t;
+
+#define MAX_PENDING_SCAN_RESULTS 256
+
+static int pending_scan_results_length;
+static pending_scan_result_t pending_scan_results_buffer[MAX_PENDING_SCAN_RESULTS];
+
+static int last_tms;
+
+void vsllink_tap_init()
+{
+	vsllink_usb_out_buffer_idx = 0;
+	vsllink_usb_in_want_length = 0;
+	pending_scan_results_length = 0;
+}
+
+void vsllink_tap_ensure_space(int scans, int bytes)
+{
+	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
+	int available_bytes = VSLLINK_BufferSize - vsllink_usb_out_buffer_idx;
+	
+	if (scans &gt; available_scans || bytes &gt; available_bytes)
+	{
+		vsllink_tap_execute();
+		vsllink_usb_out_buffer[0] = VSLLINK_CMD_HW_JTAGSEQCMD;
+		vsllink_usb_out_buffer_idx = 3;
+	}
+}
+
+void vsllink_tap_append_scan(int length, u8 *buffer, scan_command_t *command, int offset)
+{
+	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
+	int i;
+
+	if (offset &gt; 0)
+	{
+		vsllink_usb_in_want_length += ((length + 7) &gt;&gt; 3) + 1;
+	}
+	else
+	{
+		vsllink_usb_in_want_length += (length + 7) &gt;&gt; 3;
+	}
+	pending_scan_result-&gt;length = length;
+	pending_scan_result-&gt;offset = offset;
+	pending_scan_result-&gt;command = command;
+	pending_scan_result-&gt;buffer = buffer;
+
+	for (i = 0; i &lt; ((length + 7) &gt;&gt; 3); i++)
+	{
+		vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = buffer[i];
+	}
+
+	pending_scan_results_length++;
+}
+
+/* Pad and send a tap sequence to the device, and receive the answer.
+ * For the purpose of padding we assume that we are in idle or pause state. */
+int vsllink_tap_execute()
+{
+	int i, j;
+	int result;
+	int first = 0;
+
+	if (vsllink_tms_data_len &gt; 0)
+	{
+		if (vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx] &amp; (1 &lt;&lt; (vsllink_tms_data_len - 1)))
+		{
+			// last tms bit is '1'
+			// the only possible state is TLR, no need to control the number of shifts in RLT
+			// There MUST be some errors in the code
+			LOG_ERROR(&quot;last tms bit is '1'&quot;);
+			exit(-1);
+		}
+		else
+		{
+			// last tms bit is '0'
+			vsllink_usb_out_buffer_idx++;
+			vsllink_usb_out_buffer[vsllink_usb_out_buffer_idx++] = 0;
+			vsllink_tms_data_len = 0;
+		}
+	}
+	
+	if (vsllink_usb_out_buffer_idx &gt; 3)
+	{
+		if (vsllink_usb_out_buffer[0] == VSLLINK_CMD_HW_JTAGSEQCMD)
+		{
+			vsllink_usb_out_buffer[1] = (vsllink_usb_out_buffer_idx &gt;&gt; 0) &amp; 0xff;
+			vsllink_usb_out_buffer[2] = (vsllink_usb_out_buffer_idx &gt;&gt; 8) &amp; 0xff;
+		}
+
+		result = vsllink_usb_message(vsllink_jtag_handle, vsllink_usb_out_buffer_idx, vsllink_usb_in_want_length);
+	
+		if (result == vsllink_usb_in_want_length)
+		{
+			for (i = 0; i &lt; pending_scan_results_length; i++)
+			{
+				pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[i];
+				u8 *buffer = pending_scan_result-&gt;buffer;
+				int length = pending_scan_result-&gt;length;
+				int offset = pending_scan_result-&gt;offset;
+				scan_command_t *command = pending_scan_result-&gt;command;
+	
+				/* Copy to buffer */
+				buf_set_buf(vsllink_usb_in_buffer, first * 8 + offset, buffer, 0, length);
+				first += (length + offset + 7) &gt;&gt; 3;
+	
+				DEBUG_JTAG_IO(&quot;JTAG scan read(%d bits):&quot;, length);
+#ifdef _DEBUG_JTAG_IO_
+				vsllink_debug_buffer(buffer, (length + 7) &gt;&gt; 3);
+#endif
+
+				if (jtag_read_buffer(buffer, command) != ERROR_OK)
+				{
+					vsllink_tap_init();
+					return ERROR_JTAG_QUEUE_FAILED;
+				}
+		
+				if (pending_scan_result-&gt;buffer != NULL)
+				{
+					free(pending_scan_result-&gt;buffer);
+					pending_scan_result-&gt;buffer = NULL;
+				}
+			}
+		}
+		else
+		{
+			LOG_ERROR(&quot;vsllink_tap_execute, wrong result %d, expected %d&quot;, result, vsllink_usb_in_want_length);
+			return ERROR_JTAG_QUEUE_FAILED;
+		}
+		
+		vsllink_tap_init();
+	}
+	
+	return ERROR_OK;
+}
+
+/*****************************************************************************/
+/* VSLLink USB low-level functions */
+
+vsllink_jtag_t* vsllink_usb_open()
+{
+	struct usb_bus *busses;
+	struct usb_bus *bus;
+	struct usb_device *dev;
+	
+	vsllink_jtag_t *result;
+	
+	result = (vsllink_jtag_t*) malloc(sizeof(vsllink_jtag_t));
+	
+	usb_init();
+	usb_find_busses();
+	usb_find_devices();
+	
+	busses = usb_get_busses();
+	
+	/* find vsllink_jtag device in usb bus */
+	
+	for (bus = busses; bus; bus = bus-&gt;next)
+	{
+		for (dev = bus-&gt;devices; dev; dev = dev-&gt;next)
+		{
+			if ((dev-&gt;descriptor.idVendor == vsllink_vid) &amp;&amp; (dev-&gt;descriptor.idProduct == vsllink_pid))
+			{
+				result-&gt;usb_handle = usb_open(dev);
+				
+				/* usb_set_configuration required under win32 */
+				usb_set_configuration(result-&gt;usb_handle, dev-&gt;config[0].bConfigurationValue);
+				usb_claim_interface(result-&gt;usb_handle, 0);
+				
+#if 0
+				/* 
+				 * This makes problems under Mac OS X. And is not needed
+				 * under Windows. Hopefully this will not break a linux build
+				 */
+				usb_set_altinterface(result-&gt;usb_handle, 0);
+#endif				
+				return result;
+			}
+		}
+	}
+	
+	free(result);
+	return NULL;
+}
+
+void vsllink_usb_close(vsllink_jtag_t *vsllink_jtag)
+{
+	usb_close(vsllink_jtag-&gt;usb_handle);
+	free(vsllink_jtag);
+}
+
+/* Send a message and receive the reply. */
+int vsllink_usb_message(vsllink_jtag_t *vsllink_jtag, int out_length, int in_length)
+{
+	int result;
+	int result2;
+	
+	result = vsllink_usb_write(vsllink_jtag, out_length);
+	if (result == out_length)
+	{
+		if (in_length &gt; 0)
+		{
+			result = vsllink_usb_read(vsllink_jtag);
+			if (result == in_length )
+			{
+				return result;
+			}
+			else
+			{
+				LOG_ERROR(&quot;usb_bulk_read failed (requested=%d, result=%d)&quot;, in_length, result);
+				return -1;
+			}
+		}
+		return 0;
+	}
+	else
+	{
+		LOG_ERROR(&quot;usb_bulk_write failed (requested=%d, result=%d)&quot;, out_length, result);
+		return -1;
+	}
+}
+
+/* Write data from out_buffer to USB. */
+int vsllink_usb_write(vsllink_jtag_t *vsllink_jtag, int out_length)
+{
+	int result;
+	
+	if (out_length &gt; VSLLINK_BufferSize)
+	{
+		LOG_ERROR(&quot;vsllink_jtag_write illegal out_length=%d (max=%d)&quot;, out_length, VSLLINK_BufferSize);
+		return -1;
+	}
+	
+	result = usb_bulk_write(vsllink_jtag-&gt;usb_handle, vsllink_bulkout, \
+		(char *)vsllink_usb_out_buffer, out_length, VSLLINK_USB_TIMEOUT);
+	
+	DEBUG_JTAG_IO(&quot;vsllink_usb_write, out_length = %d, result = %d&quot;, out_length, result);
+	
+#ifdef _DEBUG_USB_COMMS_
+	LOG_DEBUG(&quot;USB out:&quot;);
+	vsllink_debug_buffer(vsllink_usb_out_buffer, out_length);
+#endif
+
+#ifdef _VSLLINK_IN_DEBUG_MODE_
+	usleep(100000);
+#endif
+
+	return result;
+}
+
+/* Read data from USB into in_buffer. */
+int vsllink_usb_read(vsllink_jtag_t *vsllink_jtag)
+{
+	int result = usb_bulk_read(vsllink_jtag-&gt;usb_handle, vsllink_bulkin, \
+		(char *)vsllink_usb_in_buffer, VSLLINK_BufferSize, VSLLINK_USB_TIMEOUT);
+
+	DEBUG_JTAG_IO(&quot;vsllink_usb_read, result = %d&quot;, result);
+	
+#ifdef _DEBUG_USB_COMMS_
+	LOG_DEBUG(&quot;USB in:&quot;);
+	vsllink_debug_buffer(vsllink_usb_in_buffer, result);
+#endif
+	return result;
+}
+
+#define BYTES_PER_LINE  16
+
+void vsllink_debug_buffer(u8 *buffer, int length)
+{
+	char line[81];
+	char s[4];
+	int i;
+	int j;
+	
+	for (i = 0; i &lt; length; i += BYTES_PER_LINE)
+	{
+		snprintf(line, 5, &quot;%04x&quot;, i);
+		for (j = i; j &lt; i + BYTES_PER_LINE &amp;&amp; j &lt; length; j++)
+		{
+			snprintf(s, 4, &quot; %02x&quot;, buffer[j]);
+			strcat(line, s);
+		}
+		LOG_DEBUG(line);
+	}
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000071.html">[Openocd-svn] r1287 - in trunk/src/jtag: . rlink
</A></li>
	<LI>Next message: <A HREF="000073.html">[Openocd-svn] r1289 - trunk/src/jtag
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#72">[ date ]</a>
              <a href="thread.html#72">[ thread ]</a>
              <a href="subject.html#72">[ subject ]</a>
              <a href="author.html#72">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
