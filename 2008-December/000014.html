<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Openocd-svn] r1232 - in trunk/src: flash jtag pld target xsvf
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openocd-svn/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1232%20-%20in%20trunk/src%3A%20flash%20jtag%20pld%20target%20xsvf&In-Reply-To=%3C200812130626.mBD6QDfp008761%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000013.html">
   <LINK REL="Next"  HREF="000015.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Openocd-svn] r1232 - in trunk/src: flash jtag pld target xsvf</H1>
    <B>kc8apf at mail.berlios.de</B> 
    <A HREF="mailto:openocd-svn%40lists.berlios.de?Subject=Re%3A%20%5BOpenocd-svn%5D%20r1232%20-%20in%20trunk/src%3A%20flash%20jtag%20pld%20target%20xsvf&In-Reply-To=%3C200812130626.mBD6QDfp008761%40sheep.berlios.de%3E"
       TITLE="[Openocd-svn] r1232 - in trunk/src: flash jtag pld target xsvf">kc8apf at mail.berlios.de
       </A><BR>
    <I>Sat Dec 13 07:26:13 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000013.html">[Openocd-svn] r1231 - trunk/src/target
</A></li>
        <LI>Next message: <A HREF="000015.html">[Openocd-svn] r1233 - /
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kc8apf
Date: 2008-12-13 07:25:50 +0100 (Sat, 13 Dec 2008)
New Revision: 1232

Modified:
   trunk/src/flash/str9xpec.c
   trunk/src/jtag/amt_jtagaccel.c
   trunk/src/jtag/bitbang.c
   trunk/src/jtag/bitq.c
   trunk/src/jtag/ft2232.c
   trunk/src/jtag/gw16012.c
   trunk/src/jtag/jlink.c
   trunk/src/jtag/jtag.c
   trunk/src/jtag/jtag.h
   trunk/src/jtag/usbprog.c
   trunk/src/jtag/zy1000.c
   trunk/src/pld/virtex2.c
   trunk/src/target/arm11.c
   trunk/src/target/arm11_dbgtap.c
   trunk/src/target/arm720t.c
   trunk/src/target/arm7_9_common.c
   trunk/src/target/arm7tdmi.c
   trunk/src/target/arm920t.c
   trunk/src/target/arm926ejs.c
   trunk/src/target/arm966e.c
   trunk/src/target/arm9tdmi.c
   trunk/src/target/cortex_swjdp.c
   trunk/src/target/embeddedice.c
   trunk/src/target/etb.c
   trunk/src/target/etm.c
   trunk/src/target/feroceon.c
   trunk/src/target/mips_ejtag.c
   trunk/src/target/mips_m4k.c
   trunk/src/target/xscale.c
   trunk/src/xsvf/xsvf.c
Log:
Change tap_state naming to be consistent with SVF documentation.

Courtesy of Dick Hollenbeck &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/openocd-svn">dick at softplc.com</A>&gt;


Modified: trunk/src/flash/str9xpec.c
===================================================================
--- trunk/src/flash/str9xpec.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/flash/str9xpec.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -145,7 +145,7 @@
 	scan_field_t field;
 	u8 status;
 
-	if (str9xpec_set_instr(tap, ISC_NOOP, TAP_PI) != ERROR_OK)
+	if (str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE) != ERROR_OK)
 		return ISC_STATUS_ERROR;
 
 	field.tap = tap;
@@ -158,7 +158,7 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+	jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 	jtag_execute_queue();
 
 	LOG_DEBUG(&quot;status: 0x%2.2x&quot;, status);
@@ -181,7 +181,7 @@
 		return ERROR_OK;
 
 	/* enter isc mode */
-	if (str9xpec_set_instr(tap, ISC_ENABLE, TAP_RTI) != ERROR_OK)
+	if (str9xpec_set_instr(tap, ISC_ENABLE, TAP_IDLE) != ERROR_OK)
 		return ERROR_TARGET_INVALID;
 
 	/* check ISC status */
@@ -207,7 +207,7 @@
 	if (!str9xpec_info-&gt;isc_enable)
 		return ERROR_OK;
 
-	if (str9xpec_set_instr(tap, ISC_DISABLE, TAP_RTI) != ERROR_OK)
+	if (str9xpec_set_instr(tap, ISC_DISABLE, TAP_IDLE) != ERROR_OK)
 		return ERROR_TARGET_INVALID;
 
 	/* delay to handle aborts */
@@ -238,7 +238,7 @@
 	LOG_DEBUG(&quot;ISC_CONFIGURATION&quot;);
 
 	/* execute ISC_CONFIGURATION command */
-	str9xpec_set_instr(tap, ISC_CONFIGURATION, TAP_PI);
+	str9xpec_set_instr(tap, ISC_CONFIGURATION, TAP_IRPAUSE);
 
 	field.tap = tap;
 	field.num_bits = 64;
@@ -250,7 +250,7 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+	jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 	jtag_execute_queue();
 
 	status = str9xpec_isc_status(tap);
@@ -349,10 +349,10 @@
 	armv4_5 = bank-&gt;target-&gt;arch_info;
 	arm7_9 = armv4_5-&gt;arch_info;
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	str9xpec_info-&gt;tap = jtag_TapByAbsPosition( jtag_info-&gt;tap-&gt;abs_chain_position - 1);
 	str9xpec_info-&gt;isc_enable = 0;
-	
+
 	str9xpec_build_block_list(bank);
 
 	/* clear option byte register */
@@ -390,7 +390,7 @@
 	}
 
 	/* execute ISC_BLANK_CHECK command */
-	str9xpec_set_instr(tap, ISC_BLANK_CHECK, TAP_PI);
+	str9xpec_set_instr(tap, ISC_BLANK_CHECK, TAP_IRPAUSE);
 
 	field.tap = tap;
 	field.num_bits = 64;
@@ -402,7 +402,7 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+	jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 	jtag_add_sleep(40000);
 
 	/* read blank check result */
@@ -416,7 +416,7 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_PI);
+	jtag_add_dr_scan(1, &amp;field, TAP_IRPAUSE);
 	jtag_execute_queue();
 
 	status = str9xpec_isc_status(tap);
@@ -506,7 +506,7 @@
 	LOG_DEBUG(&quot;ISC_ERASE&quot;);
 
 	/* execute ISC_ERASE command */
-	str9xpec_set_instr(tap, ISC_ERASE, TAP_PI);
+	str9xpec_set_instr(tap, ISC_ERASE, TAP_IRPAUSE);
 
 	field.tap = tap;
 	field.num_bits = 64;
@@ -518,7 +518,7 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+	jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 	jtag_execute_queue();
 
 	jtag_add_sleep(10);
@@ -569,9 +569,9 @@
 	str9xpec_set_address(bank, 0x80);
 
 	/* execute ISC_PROGRAM command */
-	str9xpec_set_instr(tap, ISC_PROGRAM_SECURITY, TAP_RTI);
+	str9xpec_set_instr(tap, ISC_PROGRAM_SECURITY, TAP_IDLE);
 
-	str9xpec_set_instr(tap, ISC_NOOP, TAP_PI);
+	str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 	do {
 		field.tap = tap;
@@ -658,7 +658,7 @@
 	tap = str9xpec_info-&gt;tap;
 
 	/* set flash controller address */
-	str9xpec_set_instr(tap, ISC_ADDRESS_SHIFT, TAP_PI);
+	str9xpec_set_instr(tap, ISC_ADDRESS_SHIFT, TAP_IRPAUSE);
 
 	field.tap = tap;
 	field.num_bits = 8;
@@ -747,7 +747,7 @@
 
 		while (dwords_remaining &gt; 0)
 		{
-			str9xpec_set_instr(tap, ISC_PROGRAM, TAP_PI);
+			str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
 			field.tap = tap;
 			field.num_bits = 64;
@@ -759,12 +759,12 @@
 			field.in_handler = NULL;
 			field.in_handler_priv = NULL;
 
-			jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+			jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 
 			/* small delay before polling */
 			jtag_add_sleep(50);
 
-			str9xpec_set_instr(tap, ISC_NOOP, TAP_PI);
+			str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 			do {
 				field.tap = tap;
@@ -807,7 +807,7 @@
 			bytes_written++;
 		}
 
-		str9xpec_set_instr(tap, ISC_PROGRAM, TAP_PI);
+		str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
 		field.tap = tap;
 		field.num_bits = 64;
@@ -819,12 +819,12 @@
 		field.in_handler = NULL;
 		field.in_handler_priv = NULL;
 
-		jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+		jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 
 		/* small delay before polling */
 		jtag_add_sleep(50);
 
-		str9xpec_set_instr(tap, ISC_NOOP, TAP_PI);
+		str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 		do {
 			field.tap = tap;
@@ -889,7 +889,7 @@
 
 	buffer = calloc(CEIL(32, 8), 1);
 
-	str9xpec_set_instr(tap, ISC_IDCODE, TAP_PI);
+	str9xpec_set_instr(tap, ISC_IDCODE, TAP_IRPAUSE);
 
 	field.tap = tap;
 	field.num_bits = 32;
@@ -901,7 +901,7 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+	jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 	jtag_execute_queue();
 
 	idcode = buf_get_u32(buffer, 0, 32);
@@ -1014,7 +1014,7 @@
 	str9xpec_set_address(bank, 0x50);
 
 	/* execute ISC_PROGRAM command */
-	str9xpec_set_instr(tap, ISC_PROGRAM, TAP_PI);
+	str9xpec_set_instr(tap, ISC_PROGRAM, TAP_IRPAUSE);
 
 	field.tap = tap;
 	field.num_bits = 64;
@@ -1026,12 +1026,12 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_RTI);
+	jtag_add_dr_scan(1, &amp;field, TAP_IDLE);
 
 	/* small delay before polling */
 	jtag_add_sleep(50);
 
-	str9xpec_set_instr(tap, ISC_NOOP, TAP_PI);
+	str9xpec_set_instr(tap, ISC_NOOP, TAP_IRPAUSE);
 
 	do {
 		field.tap = tap;
@@ -1303,13 +1303,13 @@
 	}
 
 	/* enable turbo mode - TURBO-PROG-ENABLE */
-	str9xpec_set_instr(tap2, 0xD, TAP_RTI);
+	str9xpec_set_instr(tap2, 0xD, TAP_IDLE);
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 		return retval;
 
 	/* modify scan chain - str9 core has been removed */
 	tap1-&gt;enabled = 0;
-	
+
 	return ERROR_OK;
 }
 
@@ -1337,11 +1337,11 @@
 
 	if (tap == NULL)
 		return ERROR_FAIL;
-	
+
 	/* exit turbo mode via TLR */
-	str9xpec_set_instr(tap, ISC_NOOP, TAP_TLR);
+	str9xpec_set_instr(tap, ISC_NOOP, TAP_RESET);
 	jtag_execute_queue();
-	
+
 	/* restore previous scan chain */
 	if (tap-&gt;next_tap) {
 		tap-&gt;next_tap-&gt;enabled = 1;

Modified: trunk/src/jtag/amt_jtagaccel.c
===================================================================
--- trunk/src/jtag/amt_jtagaccel.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/amt_jtagaccel.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -109,13 +109,13 @@
 	{{0x1f, 0x00}, {0x0c, 0x00}, {0x07, 0x00}, {0x97, 0x00}, {0x08, 0x00}, {0x00, 0x00}},	/* PI  */
 };
 
-jtag_interface_t amt_jtagaccel_interface = 
+jtag_interface_t amt_jtagaccel_interface =
 {
 	.name = &quot;amt_jtagaccel&quot;,
-	
+
 	.execute_queue = amt_jtagaccel_execute_queue,
 
-	.speed = amt_jtagaccel_speed,	
+	.speed = amt_jtagaccel_speed,
 	.register_commands = amt_jtagaccel_register_commands,
 	.init = amt_jtagaccel_init,
 	.quit = amt_jtagaccel_quit,
@@ -127,7 +127,7 @@
 					 COMMAND_CONFIG, NULL);
 	register_command(cmd_ctx, NULL, &quot;rtck&quot;, amt_jtagaccel_handle_rtck_command,
 					 COMMAND_CONFIG, NULL);
-	
+
 	return ERROR_OK;
 }
 
@@ -142,7 +142,7 @@
 		aw_control_rst |= 0x1;
 	else if (srst == 0)
 		aw_control_rst &amp;= ~0x1;
-	
+
 	AMT_AW(aw_control_rst);
 }
 
@@ -151,7 +151,7 @@
 	aw_control_baudrate &amp;= 0xf0;
 	aw_control_baudrate |= speed &amp; 0x0f;
 	AMT_AW(aw_control_baudrate);
-	
+
 	return ERROR_OK;
 }
 
@@ -170,11 +170,11 @@
 {
 	int timeout = 4096;
 	u8 ar_status;
-	
+
 	AMT_AR(ar_status);
 	while (((ar_status) &amp; 0x80) &amp;&amp; (timeout-- &gt; 0))
 		AMT_AR(ar_status);
-	
+
 	if (ar_status &amp; 0x80)
 	{
 		LOG_ERROR(&quot;amt_jtagaccel timed out while waiting for end of scan, rtck was %s, last AR_STATUS: 0x%2.2x&quot;, (rtck_enabled) ? &quot;enabled&quot; : &quot;disabled&quot;, ar_status);
@@ -186,15 +186,15 @@
 {
 	u8 aw_scan_tms_5;
 	u8 tms_scan[2];
-	 
+
 	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][0];
 	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][1];
-	
+
 	aw_scan_tms_5 = 0x40 | (tms_scan[0] &amp; 0x1f);
 	AMT_AW(aw_scan_tms_5);
 	if (jtag_speed &gt; 3 || rtck_enabled)
 		amt_wait_scan_busy();
-		
+
 	if (tms_scan[0] &amp; 0x80)
 	{
 		aw_scan_tms_5 = 0x40 | (tms_scan[1] &amp; 0x1f);
@@ -202,7 +202,7 @@
 		if (jtag_speed &gt; 3 || rtck_enabled)
 			amt_wait_scan_busy();
 	}
-	
+
 	cur_state = end_state;
 }
 
@@ -213,27 +213,27 @@
 	u8 aw_scan_tms_1to4;
 
 	enum tap_state saved_end_state = end_state;
-	
+
 	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_RTI)
+	if (cur_state != TAP_IDLE)
 	{
-		amt_jtagaccel_end_state(TAP_RTI);
+		amt_jtagaccel_end_state(TAP_IDLE);
 		amt_jtagaccel_state_move();
 	}
-	
+
 	while (num_cycles - i &gt;= 5)
 	{
 		aw_scan_tms_5 = 0x40;
 		AMT_AW(aw_scan_tms_5);
 		i += 5;
 	}
-	
+
 	if (num_cycles - i &gt; 0)
 	{
 		aw_scan_tms_1to4 = 0x80 | ((num_cycles - i - 1) &amp; 0x3) &lt;&lt; 4;
 		AMT_AW(aw_scan_tms_1to4);
 	}
-	
+
 	amt_jtagaccel_end_state(saved_end_state);
 	if (cur_state != end_state)
 		amt_jtagaccel_state_move();
@@ -251,9 +251,9 @@
 	u8 tms_scan[2];
 
 	if (ir_scan)
-		amt_jtagaccel_end_state(TAP_SI);
+		amt_jtagaccel_end_state(TAP_IRSHIFT);
 	else
-		amt_jtagaccel_end_state(TAP_SD);
+		amt_jtagaccel_end_state(TAP_DRSHIFT);
 
 	amt_jtagaccel_state_move();
 	amt_jtagaccel_end_state(saved_end_state);
@@ -263,7 +263,7 @@
 	{
 		aw_tdi_option = 0x30 | (((scan_size - 1) % 8) - 1);
 		AMT_AW(aw_tdi_option);
-		
+
 		dw_tdi_scan = buf_get_u32(buffer, bit_count, (scan_size - 1) % 8) &amp; 0xff;
 		AMT_DW(dw_tdi_scan);
 		if (jtag_speed &gt; 3 || rtck_enabled)
@@ -275,11 +275,11 @@
 			dr_tdo = dr_tdo &gt;&gt; (8 - ((scan_size - 1) % 8));
 			buf_set_u32(buffer, bit_count, (scan_size - 1) % 8, dr_tdo);
 		}
-		
+
 		bit_count += (scan_size - 1) % 8;
 		bits_left -= (scan_size - 1) % 8;
 	}
-	
+
 	while (bits_left - 1 &gt;= 8)
 	{
 		dw_tdi_scan = buf_get_u32(buffer, bit_count, 8) &amp; 0xff;
@@ -292,11 +292,11 @@
 			AMT_DR(dr_tdo);
 			buf_set_u32(buffer, bit_count, 8, dr_tdo);
 		}
-				
+
 		bit_count += 8;
 		bits_left -= 8;
 	}
-		
+
 	tms_scan[0] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][0];
 	tms_scan[1] = amt_jtagaccel_tap_move[tap_move_map[cur_state]][tap_move_map[end_state]][1];
 	aw_tms_scan = 0x40 | (tms_scan[0] &amp; 0x1f) | (buf_get_u32(buffer, bit_count, 1) &lt;&lt; 5);
@@ -310,7 +310,7 @@
 		dr_tdo = dr_tdo &gt;&gt; 7;
 		buf_set_u32(buffer, bit_count, 1, dr_tdo);
 	}
-	
+
 	if (tms_scan[0] &amp; 0x80)
 	{
 		aw_tms_scan = 0x40 | (tms_scan[1] &amp; 0x1f);
@@ -328,12 +328,12 @@
 	enum scan_type type;
 	u8 *buffer;
 	int retval;
-	
+
 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
 	 * that wasn't handled by a caller-provided error handler
-	 */ 
+	 */
 	retval = ERROR_OK;
-		
+
 	while (cmd)
 	{
 		switch (cmd-&gt;type)
@@ -351,7 +351,7 @@
 #endif
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_TLR;
+					cur_state = TAP_RESET;
 				}
 				amt_jtagaccel_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -397,7 +397,7 @@
 		}
 		cmd = cmd-&gt;next;
 	}
-	
+
 	return retval;
 }
 
@@ -409,16 +409,16 @@
 
     version.dwOSVersionInfoSize = sizeof version;
     if (!GetVersionEx( &amp;version )) {
-        errno = EINVAL;
-        return -1;
+	errno = EINVAL;
+	return -1;
     }
     if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
-        return 0;
+	return 0;
 
     h = CreateFile( &quot;\\\\.\\giveio&quot;, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
     if (h == INVALID_HANDLE_VALUE) {
-        errno = ENODEV;
-        return -1;
+	errno = ENODEV;
+	return -1;
     }
 
     CloseHandle( h );
@@ -437,7 +437,7 @@
 	u8 status_port;
 #endif
 	u8 ar_status;
-	
+
 #if PARPORT_USE_PPDEV == 1
 	if (device_handle &gt; 0)
 	{
@@ -447,7 +447,7 @@
 
 	snprintf(buffer, 256, &quot;/dev/parport%d&quot;, amt_jtagaccel_port);
 	device_handle = open(buffer, O_RDWR);
-	
+
 	if (device_handle &lt; 0)
 	{
 		LOG_ERROR(&quot;cannot open device. check it exists and that user read and write rights are set&quot;);
@@ -468,7 +468,7 @@
 		LOG_ERROR(&quot; cannot set compatible mode to device&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	control_port = 0x00;
 	i = ioctl(device_handle, PPWCONTROL, &amp;control_port);
 
@@ -484,57 +484,57 @@
 
 #if PARPORT_USE_GIVEIO == 1
 	if (amt_jtagaccel_get_giveio_access() != 0) {
-#else /* PARPORT_USE_GIVEIO */	
+#else /* PARPORT_USE_GIVEIO */
 	if (ioperm(amt_jtagaccel_port, 5, 1) != 0) {
 #endif /* PARPORT_USE_GIVEIO */
 		LOG_ERROR(&quot;missing privileges for direct i/o&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	/* prepare epp port */
 	/* clear timeout */
 	status_port = inb(amt_jtagaccel_port + 1);
 	outb(status_port | 0x1, amt_jtagaccel_port + 1);
-	
+
 	/* reset epp port */
 	outb(0x00, amt_jtagaccel_port + 2);
 	outb(0x04, amt_jtagaccel_port + 2);
 #endif
-	
+
 	if (rtck_enabled)
-	{	
+	{
 		/* set RTCK enable bit */
 		aw_control_fsm |= 0x02;
 	}
-	
+
 	/* enable JTAG port */
 	aw_control_fsm |= 0x04;
 	AMT_AW(aw_control_fsm);
-	
+
 	amt_jtagaccel_speed(jtag_speed);
-	
+
 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
 		aw_control_rst &amp;= ~0x8;
 	else
 		aw_control_rst |= 0x8;
-	
+
 	if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
 		aw_control_rst &amp;= ~0x2;
 	else
 		aw_control_rst |= 0x2;
-	
+
 	amt_jtagaccel_reset(0, 0);
-	
+
 	/* read status register */
 	AMT_AR(ar_status);
 	LOG_DEBUG(&quot;AR_STATUS: 0x%2.2x&quot;, ar_status);
-	
+
 	return ERROR_OK;
 }
 
 int amt_jtagaccel_quit(void)
 {
-	
+
 	return ERROR_OK;
 }
 
@@ -568,6 +568,6 @@
 			rtck_enabled = 0;
 		}
 	}
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/jtag/bitbang.c
===================================================================
--- trunk/src/jtag/bitbang.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/bitbang.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -41,24 +41,24 @@
 
 
 /* DANGER!!!! clock absolutely *MUST* be 0 in idle or reset won't work!
- * 
+ *
  * Set this to 1 and str912 reset halt will fail.
- * 
+ *
  * If someone can submit a patch with an explanation it will be greatly
  * appreciated, but as far as I can tell (&#216;H) DCLK is generated upon
- * clk=0 in TAP_RTI. Good luck deducing that from the ARM documentation!
- * The ARM documentation uses the term &quot;DCLK is asserted while in the TAP_RTI 
+ * clk=0 in TAP_IDLE. Good luck deducing that from the ARM documentation!
+ * The ARM documentation uses the term &quot;DCLK is asserted while in the TAP_IDLE
  * state&quot;. With hardware there is no such thing as *while* in a state. There
  * are only edges. So clk =&gt; 0 is in fact a very subtle state transition that
- * happens *while* in the TAP_RTI state. &quot;#&amp;&#164;&quot;#&#164;&amp;&quot;#&amp;&quot;#&amp;
- * 
+ * happens *while* in the TAP_IDLE state. &quot;#&amp;&#164;&quot;#&#164;&amp;&quot;#&amp;&quot;#&amp;
+ *
  * For &quot;reset halt&quot; the last thing that happens before srst is asserted
  * is that the breakpoint is set up. If DCLK is not wiggled one last
  * time before the reset, then the breakpoint is not set up and
  * &quot;reset halt&quot; will fail to halt.
- * 
+ *
  */
-#define CLOCK_IDLE() 0 
+#define CLOCK_IDLE() 0
 
 int bitbang_execute_queue(void);
 
@@ -76,10 +76,10 @@
 }
 
 void bitbang_state_move(void) {
-	
+
 	int i=0, tms=0;
 	u8 tms_scan = TAP_MOVE(cur_state, end_state);
-	
+
 	for (i = 0; i &lt; 7; i++)
 	{
 		tms = (tms_scan &gt;&gt; i) &amp; 1;
@@ -87,7 +87,7 @@
 		bitbang_interface-&gt;write(1, tms, 0);
 	}
 	bitbang_interface-&gt;write(CLOCK_IDLE(), tms, 0);
-	
+
 	cur_state = end_state;
 }
 
@@ -113,7 +113,7 @@
 			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_strings[cur_state], tap_state_strings[cmd-&gt;path[state_count]]);
 			exit(-1);
 		}
-		
+
 		bitbang_interface-&gt;write(0, tms, 0);
 		bitbang_interface-&gt;write(1, tms, 0);
 
@@ -121,7 +121,7 @@
 		state_count++;
 		num_states--;
 	}
-	
+
 	bitbang_interface-&gt;write(CLOCK_IDLE(), tms, 0);
 
 	end_state = cur_state;
@@ -130,16 +130,16 @@
 void bitbang_runtest(int num_cycles)
 {
 	int i;
-	
+
 	enum tap_state saved_end_state = end_state;
-	
+
 	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_RTI)
+	if (cur_state != TAP_IDLE)
 	{
-		bitbang_end_state(TAP_RTI);
+		bitbang_end_state(TAP_IDLE);
 		bitbang_state_move();
 	}
-	
+
 	/* execute num_cycles */
 	for (i = 0; i &lt; num_cycles; i++)
 	{
@@ -147,7 +147,7 @@
 		bitbang_interface-&gt;write(1, 0, 0);
 	}
 	bitbang_interface-&gt;write(CLOCK_IDLE(), 0, 0);
-	
+
 	/* finish in end_state */
 	bitbang_end_state(saved_end_state);
 	if (cur_state != end_state)
@@ -158,13 +158,13 @@
 {
 	enum tap_state saved_end_state = end_state;
 	int bit_cnt;
-	
-	if (!((!ir_scan &amp;&amp; (cur_state == TAP_SD)) || (ir_scan &amp;&amp; (cur_state == TAP_SI))))
+
+	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))))
 	{
 		if (ir_scan)
-			bitbang_end_state(TAP_SI);
+			bitbang_end_state(TAP_IRSHIFT);
 		else
-			bitbang_end_state(TAP_SD);
+			bitbang_end_state(TAP_DRSHIFT);
 
 		bitbang_state_move();
 		bitbang_end_state(saved_end_state);
@@ -181,7 +181,7 @@
 		/* if we're just reading the scan, but don't care about the output
 		 * default to outputting 'low', this also makes valgrind traces more readable,
 		 * as it removes the dependency on an uninitialised value
-		 */ 
+		 */
 		tdi=0;
 		if ((type != SCAN_IN) &amp;&amp; (buffer[bytec] &amp; bcval))
 			tdi=1;
@@ -192,7 +192,7 @@
 			val=bitbang_interface-&gt;read();
 
 		bitbang_interface-&gt;write(1, tms, tdi);
-		
+
 		if (type != SCAN_OUT)
 		{
 			if (val)
@@ -201,21 +201,21 @@
 				buffer[bytec] &amp;= ~bcval;
 		}
 	}
-	
-	/* TAP_SD &amp; TAP_SI are illegal end states, so we always transition to the pause
+
+	/* TAP_DRSHIFT &amp; TAP_IRSHIFT are illegal end states, so we always transition to the pause
 	 * state which is a legal stable state from which statemove will work.
-	 *  
-	 * Exit1 -&gt; Pause 
+	 *
+	 * Exit1 -&gt; Pause
 	 */
 	bitbang_interface-&gt;write(0, 0, 0);
 	bitbang_interface-&gt;write(1, 0, 0);
 	bitbang_interface-&gt;write(CLOCK_IDLE(), 0, 0);
-	
+
 	if (ir_scan)
-		cur_state = TAP_PI;
+		cur_state = TAP_IRPAUSE;
 	else
-		cur_state = TAP_PD;
-	
+		cur_state = TAP_DRPAUSE;
+
 	if (cur_state != end_state)
 		bitbang_state_move();
 }
@@ -227,18 +227,18 @@
 	enum scan_type type;
 	u8 *buffer;
 	int retval;
-	
+
 	if (!bitbang_interface)
 	{
 		LOG_ERROR(&quot;BUG: Bitbang interface called, but not yet initialized&quot;);
 		exit(-1);
 	}
-	
+
 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
 	 * that wasn't handled by a caller-provided error handler
-	 */ 
+	 */
 	retval = ERROR_OK;
-		
+
 	if(bitbang_interface-&gt;blink)
 		bitbang_interface-&gt;blink(1);
 
@@ -259,7 +259,7 @@
 #endif
 				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
 				{
-					cur_state = TAP_TLR;
+					cur_state = TAP_RESET;
 				}
 				bitbang_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -313,7 +313,7 @@
 	}
 	if(bitbang_interface-&gt;blink)
 		bitbang_interface-&gt;blink(0);
-	
+
 	return retval;
 }
 

Modified: trunk/src/jtag/bitq.c
===================================================================
--- trunk/src/jtag/bitq.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/bitq.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -195,7 +195,7 @@
 	int i;
 
 	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_RTI) bitq_state_move(TAP_RTI);
+	if (cur_state != TAP_IDLE) bitq_state_move(TAP_IDLE);
 
 	/* execute num_cycles */
 	for (i = 0; i &lt; num_cycles; i++)
@@ -240,8 +240,8 @@
 
 	if (pause) {
 		bitq_io(0,0,0);
-		if (cur_state==TAP_SI) cur_state=TAP_PI;
-		else if (cur_state==TAP_SD) cur_state=TAP_PD;
+		if (cur_state==TAP_IRSHIFT) cur_state=TAP_IRPAUSE;
+		else if (cur_state==TAP_DRSHIFT) cur_state=TAP_DRPAUSE;
 	}
 }
 
@@ -250,8 +250,8 @@
 {
 	int i;
 
-	if (cmd-&gt;ir_scan) bitq_state_move(TAP_SI);
-	else bitq_state_move(TAP_SD);
+	if (cmd-&gt;ir_scan) bitq_state_move(TAP_IRSHIFT);
+	else bitq_state_move(TAP_DRSHIFT);
 
 	for (i=0; i &lt; cmd-&gt;num_fields-1; i++)
 		bitq_scan_field(&amp;cmd-&gt;fields[i], 0);
@@ -285,7 +285,7 @@
 #endif
 				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
 				{
-					cur_state = TAP_TLR;
+					cur_state = TAP_RESET;
 				}
 				bitq_interface-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				if (bitq_interface-&gt;in_rdy()) bitq_in_proc();

Modified: trunk/src/jtag/ft2232.c
===================================================================
--- trunk/src/jtag/ft2232.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/ft2232.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -157,13 +157,13 @@
 #define BUFFER_ADD ft2232_buffer[ft2232_buffer_size++]
 #define BUFFER_READ ft2232_buffer[ft2232_read_pointer++]
 
-jtag_interface_t ft2232_interface = 
+jtag_interface_t ft2232_interface =
 {
 	.name = &quot;ft2232&quot;,
 	.execute_queue = ft2232_execute_queue,
 	.speed = ft2232_speed,
 	.speed_div = ft2232_speed_div,
-	.khz = ft2232_khz, 
+	.khz = ft2232_khz,
 	.register_commands = ft2232_register_commands,
 	.init = ft2232_init,
 	.quit = ft2232_quit,
@@ -183,7 +183,7 @@
 	else
 	{
 		*bytes_written = dw_bytes_written;
-		return ERROR_OK;	
+		return ERROR_OK;
 	}
 #elif BUILD_FT2232_LIBFTDI == 1
 	int retval;
@@ -196,7 +196,7 @@
 	else
 	{
 		*bytes_written = retval;
-		return ERROR_OK;	
+		return ERROR_OK;
 	}
 #endif
 }
@@ -211,20 +211,20 @@
 
 	while ((*bytes_read &lt; size) &amp;&amp; timeout--)
 	{
-		if ((status = FT_Read(ftdih, buf + *bytes_read, size - 
-			*bytes_read, &amp;dw_bytes_read)) != FT_OK)		
+		if ((status = FT_Read(ftdih, buf + *bytes_read, size -
+			*bytes_read, &amp;dw_bytes_read)) != FT_OK)
 		{
-			*bytes_read = 0; 
+			*bytes_read = 0;
 			LOG_ERROR(&quot;FT_Read returned: %lu&quot;, status);
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
-		*bytes_read += dw_bytes_read; 
+		*bytes_read += dw_bytes_read;
 	}
 #elif BUILD_FT2232_LIBFTDI == 1
 	int retval;
 	int timeout = 100;
 	*bytes_read = 0;
-	
+
 	while ((*bytes_read &lt; size) &amp;&amp; timeout--)
 	{
 		if ((retval = ftdi_read_data(&amp;ftdic, buf + *bytes_read, size - *bytes_read)) &lt; 0)
@@ -242,7 +242,7 @@
 		LOG_ERROR(&quot;couldn't read the requested number of bytes from FT2232 device (%i &lt; %i)&quot;, *bytes_read, size);
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -255,7 +255,7 @@
 	buf[0] = 0x86; /* command &quot;set divisor&quot; */
 	buf[1] = speed &amp; 0xff; /* valueL (0=6MHz, 1=3MHz, 2=2.0MHz, ...*/
 	buf[2] = (speed &gt;&gt; 8) &amp; 0xff; /* valueH */
-	
+
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
 	if (((retval = ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
@@ -268,12 +268,12 @@
 
 int ft2232_speed_div(int speed, int *khz)
 {
-	/* Take a look in the FT2232 manual, 
+	/* Take a look in the FT2232 manual,
 	 * AN2232C-01 Command Processor for
 	 * MPSSE and MCU Host Bus. Chapter 3.8 */
-	
+
 	*khz = 6000 / (1+speed);
-	
+
 	return ERROR_OK;
 }
 
@@ -284,35 +284,35 @@
 		LOG_ERROR(&quot;RCLK not supported&quot;);
 		return ERROR_FAIL;
 	}
-	/* Take a look in the FT2232 manual, 
+	/* Take a look in the FT2232 manual,
 	 * AN2232C-01 Command Processor for
 	 * MPSSE and MCU Host Bus. Chapter 3.8
-	 * 
+	 *
 	 * We will calc here with a multiplier
 	 * of 10 for better rounding later. */
-	
+
 	/* Calc speed, (6000 / khz) - 1 */
 	/* Use 65000 for better rounding */
 	*jtag_speed = (60000 / khz) - 10;
-	
+
 	/* Add 0.9 for rounding */
 	*jtag_speed += 9;
-	
+
 	/* Calc real speed */
 	*jtag_speed = *jtag_speed / 10;
-	
+
 	/* Check if speed is greater than 0 */
 	if (*jtag_speed &lt; 0)
 	{
 		*jtag_speed = 0;
 	}
-	
+
 	/* Check max value */
 	if (*jtag_speed &gt; 0xFFFF)
 	{
 		*jtag_speed = 0xFFFF;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -371,7 +371,7 @@
 	int i;
 	char line[256];
 	char *line_p = line;
-	
+
 	for (i = 0; i &lt; ft2232_buffer_size; i++)
 	{
 		line_p += snprintf(line_p, 256 - (line_p - line), &quot;%2.2x &quot;, ft2232_buffer[i]);
@@ -381,7 +381,7 @@
 			line_p = line;
 		}
 	}
-	
+
 	if (line_p != line)
 		LOG_DEBUG(&quot;%s&quot;, line);
 }
@@ -395,7 +395,7 @@
 	int retval;
 	u32 bytes_written;
 	u32 bytes_read;
-	
+
 #ifdef _DEBUG_USB_IO_
 	struct timeval start, inter, inter2, end;
 	struct timeval d_inter, d_inter2, d_end;
@@ -407,7 +407,7 @@
 #endif
 
 #ifdef _DEBUG_USB_IO_
-	gettimeofday(&amp;start, NULL);	
+	gettimeofday(&amp;start, NULL);
 #endif
 
 	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written)) != ERROR_OK)
@@ -415,28 +415,28 @@
 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
 		return retval;
 	}
-	
+
 #ifdef _DEBUG_USB_IO_
-	gettimeofday(&amp;inter, NULL);	
+	gettimeofday(&amp;inter, NULL);
 #endif
-	
+
 	if (ft2232_expect_read)
 	{
 		int timeout = 100;
 		ft2232_buffer_size = 0;
-		
+
 #ifdef _DEBUG_USB_IO_
-		gettimeofday(&amp;inter2, NULL);	
+		gettimeofday(&amp;inter2, NULL);
 #endif
-		
+
 		if ((retval = ft2232_read(ft2232_buffer, ft2232_expect_read, &amp;bytes_read)) != ERROR_OK)
 		{
 			LOG_ERROR(&quot;couldn't read from FT2232&quot;);
 			return retval;
 		}
-		
+
 #ifdef _DEBUG_USB_IO_
-		gettimeofday(&amp;end, NULL);	
+		gettimeofday(&amp;end, NULL);
 
 		timeval_subtract(&amp;d_inter, &amp;inter, &amp;start);
 		timeval_subtract(&amp;d_inter2, &amp;inter2, &amp;start);
@@ -444,14 +444,14 @@
 
 		LOG_INFO(&quot;inter: %i.%i, inter2: %i.%i end: %i.%i&quot;, d_inter.tv_sec, d_inter.tv_usec, d_inter2.tv_sec, d_inter2.tv_usec, d_end.tv_sec, d_end.tv_usec);
 #endif
-	
-		
+
+
 		ft2232_buffer_size = bytes_read;
-		
+
 		if (ft2232_expect_read != ft2232_buffer_size)
 		{
 			LOG_ERROR(&quot;ft2232_expect_read (%i) != ft2232_buffer_size (%i) (%i retries)&quot;, ft2232_expect_read, ft2232_buffer_size, 100 - timeout);
-			ft2232_debug_dump_buffer();	
+			ft2232_debug_dump_buffer();
 
 			exit(-1);
 		}
@@ -464,12 +464,12 @@
 
 	ft2232_expect_read = 0;
 	ft2232_read_pointer = 0;
-	
+
 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
 	 * that wasn't handled by a caller-provided error handler
-	 */ 
+	 */
 	retval = ERROR_OK;
-	
+
 	cmd = first;
 	while (cmd != last)
 	{
@@ -492,7 +492,7 @@
 		}
 		cmd = cmd-&gt;next;
 	}
-	
+
 	ft2232_buffer_size = 0;
 
 	return retval;
@@ -508,7 +508,7 @@
 	while (num_states)
 	{
 		int bit_count = 0;
-		
+
 		int num_states_batch = num_states &gt; 7 ? 7 : num_states;
 
 		tms_byte = 0x0;
@@ -516,7 +516,7 @@
 		BUFFER_ADD = 0x4b;
 		/* number of states remaining */
 		BUFFER_ADD = num_states_batch - 1;
-		
+
 		while (num_states_batch--)
 		{
 			if (tap_transitions[cur_state].low == cmd-&gt;path[state_count])
@@ -533,10 +533,10 @@
 			state_count++;
 			num_states--;
 		}
-		
+
 		BUFFER_ADD = tms_byte;
 	}
-	
+
 	end_state = cur_state;
 }
 
@@ -547,7 +547,7 @@
 	int cur_byte = 0;
 	int last_bit;
 
-	if (!((!ir_scan &amp;&amp; (cur_state == TAP_SD)) || (ir_scan &amp;&amp; (cur_state == TAP_SI))))
+	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))))
 	{
 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
 		BUFFER_ADD = 0x4b;
@@ -556,17 +556,17 @@
 		/* TMS data bits */
 		if (ir_scan)
 		{
-			BUFFER_ADD = TAP_MOVE(cur_state, TAP_SI);
-			cur_state = TAP_SI;
+			BUFFER_ADD = TAP_MOVE(cur_state, TAP_IRSHIFT);
+			cur_state = TAP_IRSHIFT;
 		}
 		else
 		{
-			BUFFER_ADD = TAP_MOVE(cur_state, TAP_SD);
-			cur_state = TAP_SD;
+			BUFFER_ADD = TAP_MOVE(cur_state, TAP_DRSHIFT);
+			cur_state = TAP_DRSHIFT;
 		}
 		/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
 	}
-	
+
 	/* add command for complete bytes */
 	while (num_bytes &gt; 1)
 	{
@@ -608,7 +608,7 @@
 			bits_left -= 8 * (thisrun_bytes);
 		}
 	}
-	
+
 	/* the most signifcant bit is scanned during TAP movement */
 	if (type != SCAN_IN)
 		last_bit = (buffer[cur_byte] &gt;&gt; (bits_left - 1)) &amp; 0x1;
@@ -641,8 +641,8 @@
 			BUFFER_ADD = buffer[cur_byte];
 	}
 
-	if ((ir_scan &amp;&amp; (end_state == TAP_SI)) ||
-		(!ir_scan &amp;&amp; (end_state == TAP_SD)))
+	if ((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT)) ||
+		(!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT)))
 	{
 		if (type == SCAN_IO)
 		{
@@ -698,24 +698,24 @@
 	u32 bytes_read;
 	int retval;
 	int thisrun_read = 0;
-	
+
 	if (cmd-&gt;ir_scan)
 	{
 		LOG_ERROR(&quot;BUG: large IR scans are not supported&quot;);
 		exit(-1);
 	}
 
-	if (cur_state != TAP_SD)
+	if (cur_state != TAP_DRSHIFT)
 	{
 		/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
 		BUFFER_ADD = 0x4b;
 		/* scan 7 bit */
 		BUFFER_ADD = 0x6;
 		/* TMS data bits */
-		BUFFER_ADD = TAP_MOVE(cur_state, TAP_SD);
-		cur_state = TAP_SD;
+		BUFFER_ADD = TAP_MOVE(cur_state, TAP_DRSHIFT);
+		cur_state = TAP_DRSHIFT;
 	}
-	
+
 	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written)) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
@@ -723,12 +723,12 @@
 	}
 	LOG_DEBUG(&quot;ft2232_buffer_size: %i, bytes_written: %i&quot;, ft2232_buffer_size, bytes_written);
 	ft2232_buffer_size = 0;
-	
+
 	/* add command for complete bytes */
 	while (num_bytes &gt; 1)
 	{
 		int thisrun_bytes;
-		
+
 		if (type == SCAN_IO)
 		{
 			/* Clock Data Bytes In and Out LSB First */
@@ -774,7 +774,7 @@
 		}
 		LOG_DEBUG(&quot;ft2232_buffer_size: %i, bytes_written: %i&quot;, ft2232_buffer_size, bytes_written);
 		ft2232_buffer_size = 0;
-		
+
 		if (type != SCAN_OUT)
 		{
 			if ((retval = ft2232_read(receive_pointer, thisrun_read, &amp;bytes_read)) != ERROR_OK)
@@ -786,9 +786,9 @@
 			receive_pointer += bytes_read;
 		}
 	}
-	
+
 	thisrun_read = 0;
-	
+
 	/* the most signifcant bit is scanned during TAP movement */
 	if (type != SCAN_IN)
 		last_bit = (buffer[cur_byte] &gt;&gt; (bits_left - 1)) &amp; 0x1;
@@ -819,12 +819,12 @@
 		BUFFER_ADD = bits_left - 2;
 		if (type != SCAN_IN)
 			BUFFER_ADD = buffer[cur_byte];
-			
+
 		if (type != SCAN_OUT)
 			thisrun_read += 2;
 	}
 
-	if (end_state == TAP_SD)
+	if (end_state == TAP_DRSHIFT)
 	{
 		if (type == SCAN_IO)
 		{
@@ -866,10 +866,10 @@
 		BUFFER_ADD = TAP_MOVE(cur_state, end_state) | (last_bit &lt;&lt; 7);
 		cur_state = end_state;
 	}
-	
+
 	if (type != SCAN_OUT)
 		thisrun_read += 1;
-	
+
 	if ((retval = ft2232_write(ft2232_buffer, ft2232_buffer_size, &amp;bytes_written)) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;couldn't write MPSSE commands to FT2232&quot;);
@@ -877,7 +877,7 @@
 	}
 	LOG_DEBUG(&quot;ft2232_buffer_size: %i, bytes_written: %i&quot;, ft2232_buffer_size, bytes_written);
 	ft2232_buffer_size = 0;
-	
+
 	if (type != SCAN_OUT)
 	{
 		if ((retval = ft2232_read(receive_pointer, thisrun_read, &amp;bytes_read)) != ERROR_OK)
@@ -888,7 +888,7 @@
 		LOG_DEBUG(&quot;thisrun_read: %i, bytes_read: %i&quot;, thisrun_read, bytes_read);
 		receive_pointer += bytes_read;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -896,10 +896,10 @@
 {
 	int predicted_size = 3;
 	int num_bytes = (scan_size - 1) / 8;
-	
-	if (cur_state != TAP_SD)
+
+	if (cur_state != TAP_DRSHIFT)
 		predicted_size += 3;
-	
+
 	if (type == SCAN_IN)	/* only from device to host */
 	{
 		/* complete bytes */
@@ -921,7 +921,7 @@
 int ft2232_predict_scan_in(int scan_size, enum scan_type type)
 {
 	int predicted_size = 0;
-	
+
 	if (type != SCAN_OUT)
 	{
 		/* complete bytes */
@@ -931,7 +931,7 @@
 		/* last bit (from TMS scan) */
 		predicted_size += 1;
 	}
-	
+
 	/* LOG_DEBUG(&quot;scan_size: %i, predicted_size: %i&quot;, scan_size, predicted_size); */
 
 	return predicted_size;
@@ -968,7 +968,7 @@
 		else
 			low_direction &amp;= ~nSRSTnOE;	/* switch to input pin (high-Z) */
 	}
-	
+
 	/* command &quot;set data bits low byte&quot; */
 	BUFFER_ADD = 0x80;
 	BUFFER_ADD = low_output;
@@ -1007,7 +1007,7 @@
 		else
 			high_output |= nSRSTnOE;
 	}
-	
+
 	/* command &quot;set data bits high byte&quot; */
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
@@ -1052,7 +1052,7 @@
 {
 	if (trst == 1)
 	{
-		cur_state = TAP_TLR;
+		cur_state = TAP_RESET;
 		high_output &amp;= ~nTRST;
 	}
 	else if (trst == 0)
@@ -1106,7 +1106,7 @@
 void turtle_reset(int trst, int srst)
 {
 	trst = trst;
-	
+
 	if (srst == 1)
 	{
 		low_output |= nSRST;
@@ -1115,7 +1115,7 @@
 	{
 		low_output &amp;= ~nSRST;
 	}
-	
+
 	/* command &quot;set data bits low byte&quot; */
 	BUFFER_ADD = 0x80;
 	BUFFER_ADD = low_output;
@@ -1142,7 +1142,7 @@
 	{
 		high_output |= nSRST;
 	}
-	
+
 	/* command &quot;set data bits high byte&quot; */
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
@@ -1169,12 +1169,12 @@
 	{
 		low_output |= nSRST;
 	}
-	
+
 	/* command &quot;set data bits low byte&quot; */
 	BUFFER_ADD = 0x80;
 	BUFFER_ADD = low_output;
 	BUFFER_ADD = low_direction;
-	
+
 	/* command &quot;set data bits high byte&quot; */
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
@@ -1193,15 +1193,15 @@
 	int predicted_size = 0;
 	int require_send = 0;
 	int retval;
-	
+
 	/* return ERROR_OK, unless ft2232_send_and_recv reports a failed check
 	 * that wasn't handled by a caller-provided error handler
-	 */ 
+	 */
 	retval = ERROR_OK;
 
 	ft2232_buffer_size = 0;
 	ft2232_expect_read = 0;
-	
+
 	/* blink, if the current layout has that feature */
 	if (layout-&gt;blink)
 		layout-&gt;blink();
@@ -1227,24 +1227,24 @@
 
 				if ((cmd-&gt;cmd.reset-&gt;trst == 1) || (cmd-&gt;cmd.reset-&gt;srst &amp;&amp; (jtag_reset_config &amp; RESET_SRST_PULLS_TRST)))
 				{
-					cur_state = TAP_TLR;
+					cur_state = TAP_RESET;
 				}
 				layout-&gt;reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				require_send = 1;
-				
-#ifdef _DEBUG_JTAG_IO_				
+
+#ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 #endif
 				break;
 			case JTAG_RUNTEST:
 				/* only send the maximum buffer size that FT2232C can handle */
 				predicted_size = 0;
-				if (cur_state != TAP_RTI)
+				if (cur_state != TAP_IDLE)
 					predicted_size += 3;
 				predicted_size += 3 * CEIL(cmd-&gt;cmd.runtest-&gt;num_cycles, 7);
-				if ((cmd-&gt;cmd.runtest-&gt;end_state != -1) &amp;&amp; (cmd-&gt;cmd.runtest-&gt;end_state != TAP_RTI))
+				if ((cmd-&gt;cmd.runtest-&gt;end_state != -1) &amp;&amp; (cmd-&gt;cmd.runtest-&gt;end_state != TAP_IDLE))
 					predicted_size += 3;
-				if ((cmd-&gt;cmd.runtest-&gt;end_state == -1) &amp;&amp; (end_state != TAP_RTI))
+				if ((cmd-&gt;cmd.runtest-&gt;end_state == -1) &amp;&amp; (end_state != TAP_IDLE))
 					predicted_size += 3;
 				if (ft2232_buffer_size + predicted_size + 1 &gt; FT2232_BUFFER_SIZE)
 				{
@@ -1253,15 +1253,15 @@
 					require_send = 0;
 					first_unsent = cmd;
 				}
-				if (cur_state != TAP_RTI)
+				if (cur_state != TAP_IDLE)
 				{
 					/* command &quot;Clock Data to TMS/CS Pin (no Read)&quot; */
 					BUFFER_ADD = 0x4b;
 					/* scan 7 bit */
 					BUFFER_ADD = 0x6;
 					/* TMS data bits */
-					BUFFER_ADD = TAP_MOVE(cur_state, TAP_RTI);
-					cur_state = TAP_RTI;
+					BUFFER_ADD = TAP_MOVE(cur_state, TAP_IDLE);
+					cur_state = TAP_IDLE;
 					require_send = 1;
 				}
 				i = cmd-&gt;cmd.runtest-&gt;num_cycles;
@@ -1273,7 +1273,7 @@
 					BUFFER_ADD = (i &gt; 7) ? 6 : (i - 1);
 					/* TMS data bits */
 					BUFFER_ADD = 0x0;
-					cur_state = TAP_RTI;
+					cur_state = TAP_IDLE;
 					i -= (i &gt; 7) ? 7 : i;
 					/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
 				}
@@ -1291,7 +1291,7 @@
 					/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
 				}
 				require_send = 1;
-#ifdef _DEBUG_JTAG_IO_				
+#ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG(&quot;runtest: %i, end in %i&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, end_state);
 #endif
 				break;
@@ -1316,7 +1316,7 @@
 				/* LOG_DEBUG(&quot;added TMS scan (no read)&quot;); */
 				cur_state = end_state;
 				require_send = 1;
-#ifdef _DEBUG_JTAG_IO_				
+#ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG(&quot;statemove: %i&quot;, end_state);
 #endif
 				break;
@@ -1332,7 +1332,7 @@
 				}
 				ft2232_add_pathmove(cmd-&gt;cmd.pathmove);
 				require_send = 1;
-#ifdef _DEBUG_JTAG_IO_				
+#ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG(&quot;pathmove: %i states, end in %i&quot;, cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]);
 #endif
 				break;
@@ -1347,7 +1347,7 @@
 					if (first_unsent != cmd)
 						if (ft2232_send_and_recv(first_unsent, cmd) != ERROR_OK)
 							retval = ERROR_JTAG_QUEUE_FAILED;
-					
+
 					/* current command */
 					if (cmd-&gt;cmd.scan-&gt;end_state != -1)
 						ft2232_end_state(cmd-&gt;cmd.scan-&gt;end_state);
@@ -1374,7 +1374,7 @@
 				require_send = 1;
 				if (buffer)
 					free(buffer);
-#ifdef _DEBUG_JTAG_IO_				
+#ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG(&quot;%s scan, %i bit, end in %i&quot;, (cmd-&gt;cmd.scan-&gt;ir_scan) ? &quot;IR&quot; : &quot;DR&quot;, scan_size, end_state);
 #endif
 				break;
@@ -1383,7 +1383,7 @@
 					retval = ERROR_JTAG_QUEUE_FAILED;
 				first_unsent = cmd-&gt;next;
 				jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
-#ifdef _DEBUG_JTAG_IO_				
+#ifdef _DEBUG_JTAG_IO_
 				LOG_DEBUG(&quot;sleep %i usec&quot;, cmd-&gt;cmd.sleep-&gt;us);
 #endif
 				break;
@@ -1424,7 +1424,7 @@
 		LOG_WARNING(&quot;can't open by device description and serial number, giving precedence to serial&quot;);
 		ft2232_device_desc = NULL;
 	}
-	
+
 	if (ft2232_device_desc)
 	{
 		openex_string = ft2232_device_desc;
@@ -1439,14 +1439,14 @@
 	{
 		LOG_ERROR(&quot;neither device description nor serial number specified&quot;);
 		LOG_ERROR(&quot;please add \&quot;ft2232_device_desc &lt;string&gt;\&quot; or \&quot;ft2232_serial &lt;string&gt;\&quot; to your .cfg file&quot;);
-		
-		return ERROR_JTAG_INIT_FAILED;	
+
+		return ERROR_JTAG_INIT_FAILED;
 	}
 
 	if ((status = FT_OpenEx(openex_string, openex_flags, &amp;ftdih)) != FT_OK)
 	{
 		DWORD num_devices;
-		
+
 		if (more) {
 			LOG_WARNING(&quot;unable to open ftdi device (trying more): %lu&quot;, status);
 			*try_more = 1;
@@ -1471,7 +1471,7 @@
 				for (i = 0; i &lt; num_devices; i++)
 					LOG_ERROR(&quot;%i: %s&quot;, i, desc_array[i]);
 			}
-			
+
 			for (i = 0; i &lt; num_devices; i++)
 				free(desc_array[i]);
 			free(desc_array);
@@ -1488,7 +1488,7 @@
 		LOG_ERROR(&quot;unable to set latency timer: %lu&quot;, status);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	if ((status = FT_GetLatencyTimer(ftdih, &amp;latency_timer)) != FT_OK)
 	{
 		LOG_ERROR(&quot;unable to get latency timer: %lu&quot;, status);
@@ -1498,7 +1498,7 @@
 	{
 		LOG_DEBUG(&quot;current latency timer: %i&quot;, latency_timer);
 	}
-	
+
 	if ((status = FT_SetTimeouts(ftdih, 5000, 5000)) != FT_OK)
 	{
 		LOG_ERROR(&quot;unable to set timeouts: %lu&quot;, status);
@@ -1568,7 +1568,7 @@
 		LOG_ERROR(&quot;unable to set latency timer&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	if (ftdi_get_latency_timer(&amp;ftdic, &amp;latency_timer) &lt; 0)
 	{
 		LOG_ERROR(&quot;unable to get latency timer&quot;);
@@ -1603,13 +1603,13 @@
 	u32 bytes_written;
 	ft2232_layout_t *cur_layout = ft2232_layouts;
 	int i;
-	
+
 	if ((ft2232_layout == NULL) || (ft2232_layout[0] == 0))
 	{
 		ft2232_layout = &quot;usbjtag&quot;;
 		LOG_WARNING(&quot;No ft2232 layout specified, using default 'usbjtag'&quot;);
 	}
-	
+
 	while (cur_layout-&gt;name)
 	{
 		if (strcmp(cur_layout-&gt;name, ft2232_layout) == 0)
@@ -1625,7 +1625,7 @@
 		LOG_ERROR(&quot;No matching layout found for %s&quot;, ft2232_layout);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	for (i = 0; 1; i++) {
 		/*
 		 * &quot;more indicates that there are more IDs to try, so we should
@@ -1645,7 +1645,7 @@
 #elif BUILD_FT2232_LIBFTDI == 1
 		retval = ft2232_init_libftdi(ft2232_vid[i], ft2232_pid[i],
 			more, &amp;try_more);
-#endif	
+#endif
 		if (retval &gt;= 0)
 			break;
 		if (!more || !try_more)
@@ -1671,7 +1671,7 @@
 	return ft2232_purge_ftd2xx();
 #elif BUILD_FT2232_LIBFTDI == 1
 	return ft2232_purge_libftdi();
-#endif	
+#endif
 
 	return ERROR_OK;
 }
@@ -1680,10 +1680,10 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x08;
 	low_direction = 0x0b;
-	
+
 	if (strcmp(ft2232_layout, &quot;usbjtag&quot;) == 0)
 	{
 		nTRST = 0x10;
@@ -1710,9 +1710,9 @@
 	else
 	{
 		LOG_ERROR(&quot;BUG: usbjtag_init called for unknown layout '%s'&quot;, ft2232_layout);
-		return ERROR_JTAG_INIT_FAILED;	
+		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	if (jtag_reset_config &amp; RESET_TRST_OPEN_DRAIN)
 	{
 		low_direction &amp;= ~nTRSTnOE; /* nTRST input */
@@ -1723,7 +1723,7 @@
 		low_direction |= nTRSTnOE; /* nTRST output */
 		low_output |= nTRST; /* nTRST = 1 */
 	}
-	
+
 	if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
 	{
 		low_direction |= nSRSTnOE; /* nSRST output */
@@ -1734,16 +1734,16 @@
 		low_direction &amp;= ~nSRSTnOE; /* nSRST input */
 		low_output &amp;= ~nSRST; /* nSRST = 0 */
 	}
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, xRST high) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'USBJTAG' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'USBJTAG' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
@@ -1754,19 +1754,19 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x08;
 	low_direction = 0x2b;
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
 
@@ -1775,14 +1775,14 @@
 		nTRST = 0x08;
 		nTRSTnOE = 0x0;  /* No output enable for TRST*/
 		nSRST = 0x04;
-		nSRSTnOE = 0x0;  /* No output enable for SRST*/ 
+		nSRSTnOE = 0x0;  /* No output enable for SRST*/
 	}
 	else
 	{
 		LOG_ERROR(&quot;BUG: axm0432_jtag_init called for non axm0432 layout&quot;);
 		exit(-1);
 	}
-	
+
 	high_output = 0x0;
 	high_direction = 0x0c;
 
@@ -1803,19 +1803,19 @@
 	{
 		high_output |= nSRST;
 	}
-	
+
 	/* initialize high port */
 	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
 	buf[1] = high_output; /* value */
 	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'Dicarlo' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'Dicarlo' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1823,22 +1823,22 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x08;
 	low_direction = 0x1b;
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	if (strcmp(layout-&gt;name, &quot;jtagkey&quot;) == 0)
 	{
 		nTRST = 0x01;
@@ -1859,7 +1859,7 @@
 		LOG_ERROR(&quot;BUG: jtagkey_init called for non jtagkey layout&quot;);
 		exit(-1);
 	}
-	
+
 	high_output = 0x0;
 	high_direction = 0x0f;
 
@@ -1873,7 +1873,7 @@
 		high_output &amp;= ~nTRSTnOE;
 		high_output |= nTRST;
 	}
-	
+
 	if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
 	{
 		high_output &amp;= ~nSRSTnOE;
@@ -1884,19 +1884,19 @@
 		high_output |= nSRSTnOE;
 		high_output &amp;= ~nSRST;
 	}
-	
+
 	/* initialize high port */
 	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
 	buf[1] = high_output; /* value */
 	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1904,22 +1904,22 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x08;
 	low_direction = 0x1b;
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	nTRST = 0x01;
 	nTRSTnOE = 0x4;
 	nSRST = 0x02;
@@ -1938,7 +1938,7 @@
 		high_output &amp;= ~nTRSTnOE;
 		high_output |= nTRST;
 	}
-	
+
 	if (jtag_reset_config &amp; RESET_SRST_PUSH_PULL)
 	{
 		LOG_ERROR(&quot;can't set nSRST to push-pull on the Olimex ARM-USB-OCD&quot;);
@@ -1947,22 +1947,22 @@
 	{
 		high_output &amp;= ~nSRST;
 	}
-	
+
 	/* turn red LED on */
 	high_output |= 0x08;
-	
+
 	/* initialize high port */
 	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
 	buf[1] = high_output; /* value */
 	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'JTAGkey' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -1970,22 +1970,22 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x18;
 	low_direction = 0xfb;
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE[12]=out, n[ST]srst=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	nTRST = 0x10;
 	nTRSTnOE = 0x0; /* not output enable for nTRST */
 	nSRST = 0x20;
@@ -1996,19 +1996,19 @@
 
 	/* turn red LED1 on, LED2 off */
 	high_output |= 0x08;
-	
+
 	/* initialize high port */
 	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
 	buf[1] = high_output; /* value */
 	buf[2] = high_direction;   /* all outputs (xRST and xRSTnOE) */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'flyswatter' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -2016,39 +2016,39 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x08;
 	low_direction = 0x5b;
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	nSRST = 0x40;
-	
+
 	high_output = 0x00;
 	high_direction = 0x0C;
-	
+
 	/* initialize high port */
 	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
 	buf[1] = high_output;
 	buf[2] = high_direction;
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'turtelizer2' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -2056,42 +2056,42 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x08;
 	low_direction = 0x0b;
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	nTRST = 0x01;
 	nTRSTnOE = 0x00; /* no output enable for nTRST */
 	nSRST = 0x02;
 	nSRSTnOE = 0x00; /* no output enable for nSRST */
-	
+
 	high_output = 0x03;
 	high_direction = 0x03;
-	
+
 	/* initialize high port */
 	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
 	buf[1] = high_output;
 	buf[2] = high_direction;
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'comstick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -2099,42 +2099,42 @@
 {
 	u8 buf[3];
 	u32 bytes_written;
-	
+
 	low_output = 0x88;
 	low_direction = 0x8b;
-	
+
 	/* initialize low byte for jtag */
 	buf[0] = 0x80; /* command &quot;set data bits low byte&quot; */
 	buf[1] = low_output; /* value (TMS=1,TCK=0, TDI=0, nOE=0) */
 	buf[2] = low_direction; /* dir (output=1), TCK/TDI/TMS=out, TDO=in, nOE=out */
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-		
+
 	nTRST = 0x01;
 	nTRSTnOE = 0x00; /* no output enable for nTRST */
 	nSRST = 0x80;
 	nSRSTnOE = 0x00; /* no output enable for nSRST */
-	
+
 	high_output = 0x01;
 	high_direction = 0x03;
-	
+
 	/* initialize high port */
 	buf[0] = 0x82; /* command &quot;set data bits high byte&quot; */
 	buf[1] = high_output;
 	buf[2] = high_direction;
 	LOG_DEBUG(&quot;%2.2x %2.2x %2.2x&quot;, buf[0], buf[1], buf[2]);
-	
+
 	if (((ft2232_write(buf, 3, &amp;bytes_written)) != ERROR_OK) || (bytes_written != 3))
 	{
-		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;); 
+		LOG_ERROR(&quot;couldn't initialize FT2232 with 'stm32stick' layout&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -2153,7 +2153,7 @@
 		/* set port pin low */
 		high_output |= 0x08;
 	}
-	
+
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
 	BUFFER_ADD = high_direction;
@@ -2161,7 +2161,7 @@
 
 void turtle_jtag_blink(void)
 {
-	/* 
+	/*
    * Turtelizer2 has two LEDs connected to ACBUS2 and ACBUS3
 	 */
 	if (high_output &amp; 0x08)
@@ -2172,7 +2172,7 @@
 	{
 		high_output = 0x08;
 	}
-	
+
 	BUFFER_ADD = 0x82;
 	BUFFER_ADD = high_output;
 	BUFFER_ADD = high_direction;
@@ -2186,9 +2186,9 @@
 	status = FT_Close(ftdih);
 #elif BUILD_FT2232_LIBFTDI == 1
 	ftdi_disable_bitbang(&amp;ftdic);
-	
+
 	ftdi_usb_close(&amp;ftdic);
-	
+
 	ftdi_deinit(&amp;ftdic);
 #endif
 
@@ -2208,7 +2208,7 @@
 	{
 		LOG_ERROR(&quot;expected exactly one argument to ft2232_device_desc &lt;description&gt;&quot;);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -2222,7 +2222,7 @@
 	{
 		LOG_ERROR(&quot;expected exactly one argument to ft2232_serial &lt;serial-number&gt;&quot;);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -2276,6 +2276,6 @@
 	{
 		LOG_ERROR(&quot;expected exactly one argument to ft2232_latency &lt;ms&gt;&quot;);
 	}
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/jtag/gw16012.c
===================================================================
--- trunk/src/jtag/gw16012.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/gw16012.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -97,13 +97,13 @@
 
 int gw16012_handle_parport_port_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc);
 
-jtag_interface_t gw16012_interface = 
+jtag_interface_t gw16012_interface =
 {
 	.name = &quot;gw16012&quot;,
-	
+
 	.execute_queue = gw16012_execute_queue,
 
-	.speed = gw16012_speed,	
+	.speed = gw16012_speed,
 	.register_commands = gw16012_register_commands,
 	.init = gw16012_init,
 	.quit = gw16012_quit,
@@ -113,7 +113,7 @@
 {
 	register_command(cmd_ctx, NULL, &quot;parport_port&quot;, gw16012_handle_parport_port_command,
 					 COMMAND_CONFIG, NULL);
-	
+
 	return ERROR_OK;
 }
 
@@ -125,7 +125,7 @@
 #ifdef _DEBUG_GW16012_IO_
 	LOG_DEBUG(&quot;%2.2x&quot;, value);
 #endif
-	
+
 	#if PARPORT_USE_PPDEV == 1
 		ioctl(device_handle, PPWDATA, &amp;value);
 	#else
@@ -134,7 +134,7 @@
 		#else
 			outb(value, gw16012_port);
 		#endif
-	#endif	
+	#endif
 }
 
 void gw16012_control(u8 value)
@@ -209,15 +209,15 @@
 {
 	int i=0, tms=0;
 	u8 tms_scan = TAP_MOVE(cur_state, end_state);
-	
+
 	gw16012_control(0x0); /* single-bit mode */
-	
+
 	for (i = 0; i &lt; 7; i++)
 	{
 		tms = (tms_scan &gt;&gt; i) &amp; 1;
 		gw16012_data(tms &lt;&lt; 1); /* output next TMS bit */
 	}
-	
+
 	cur_state = end_state;
 }
 
@@ -243,12 +243,12 @@
 			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_strings[cur_state], tap_state_strings[cmd-&gt;path[state_count]]);
 			exit(-1);
 		}
-		
+
 		cur_state = cmd-&gt;path[state_count];
 		state_count++;
 		num_states--;
 	}
-	
+
 	end_state = cur_state;
 }
 
@@ -256,20 +256,20 @@
 {
 	enum tap_state saved_end_state = end_state;
 	int i;
-	
+
 	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_RTI)
+	if (cur_state != TAP_IDLE)
 	{
-		gw16012_end_state(TAP_RTI);
+		gw16012_end_state(TAP_IDLE);
 		gw16012_state_move();
 	}
-	
+
 	for (i = 0; i &lt; num_cycles; i++)
 	{
 		gw16012_control(0x0); /* single-bit mode */
 		gw16012_data(0x0); /* TMS cycle with TMS low */
 	}
-	
+
 	gw16012_end_state(saved_end_state);
 	if (cur_state != end_state)
 		gw16012_state_move();
@@ -283,12 +283,12 @@
 	u8 scan_out, scan_in;
 
 	/* only if we're not already in the correct Shift state */
-	if (!((!ir_scan &amp;&amp; (cur_state == TAP_SD)) || (ir_scan &amp;&amp; (cur_state == TAP_SI))))
+	if (!((!ir_scan &amp;&amp; (cur_state == TAP_DRSHIFT)) || (ir_scan &amp;&amp; (cur_state == TAP_IRSHIFT))))
 	{
 		if (ir_scan)
-			gw16012_end_state(TAP_SI);
+			gw16012_end_state(TAP_IRSHIFT);
 		else
-			gw16012_end_state(TAP_SD);
+			gw16012_end_state(TAP_DRSHIFT);
 
 		gw16012_state_move();
 		gw16012_end_state(saved_end_state);
@@ -302,20 +302,20 @@
 		bit_count += 7;
 		bits_left -= 7;
 	}
-	
+
 	gw16012_control(0x0); /* single-bit mode */
 	while (bits_left-- &gt; 0)
 	{
 		u8 tms = 0;
-		
+
 		scan_out = buf_get_u32(buffer, bit_count, 1);
-		
+
 		if (bits_left == 0) /* last bit */
 		{
-			if ((ir_scan &amp;&amp; (end_state == TAP_SI))
-				|| (!ir_scan &amp;&amp; (end_state == TAP_SD)))
+			if ((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT))
+				|| (!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT)))
 			{
-				tms = 0; 
+				tms = 0;
 			}
 			else
 			{
@@ -329,20 +329,20 @@
 		{
 			gw16012_input(&amp;scan_in);
 			buf_set_u32(buffer, bit_count, 1, ((scan_in &amp; 0x08) &gt;&gt; 3));
-		}		
+		}
 
 		bit_count++;
 	}
 
-	if (!((ir_scan &amp;&amp; (end_state == TAP_SI)) ||
-		(!ir_scan &amp;&amp; (end_state == TAP_SD))))
+	if (!((ir_scan &amp;&amp; (end_state == TAP_IRSHIFT)) ||
+		(!ir_scan &amp;&amp; (end_state == TAP_DRSHIFT))))
 	{
 		gw16012_data(0x0);
 		if (ir_scan)
-			cur_state = TAP_PI;
+			cur_state = TAP_IRPAUSE;
 		else
-			cur_state = TAP_PD;
-			
+			cur_state = TAP_DRPAUSE;
+
 		if (cur_state != end_state)
 			gw16012_state_move();
 	}
@@ -355,12 +355,12 @@
 	enum scan_type type;
 	u8 *buffer;
 	int retval;
-	
+
 	/* return ERROR_OK, unless a jtag_read_buffer returns a failed check
 	 * that wasn't handled by a caller-provided error handler
-	 */ 
+	 */
 	retval = ERROR_OK;
-		
+
 	while (cmd)
 	{
 		switch (cmd-&gt;type)
@@ -378,7 +378,7 @@
 #endif
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_TLR;
+					cur_state = TAP_RESET;
 				}
 				gw16012_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -410,7 +410,7 @@
 				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
 				type = jtag_scan_type(cmd-&gt;cmd.scan);
 #ifdef _DEBUG_JTAG_IO_
-				LOG_DEBUG(&quot;%s scan (%i) %i bit end in %i&quot;, (cmd-&gt;cmd.scan-&gt;ir_scan) ? &quot;ir&quot; : &quot;dr&quot;, 
+				LOG_DEBUG(&quot;%s scan (%i) %i bit end in %i&quot;, (cmd-&gt;cmd.scan-&gt;ir_scan) ? &quot;ir&quot; : &quot;dr&quot;,
 					type, scan_size, cmd-&gt;cmd.scan-&gt;end_state);
 #endif
 				gw16012_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size);
@@ -431,7 +431,7 @@
 		}
 		cmd = cmd-&gt;next;
 	}
-	
+
 	return retval;
 }
 
@@ -443,16 +443,16 @@
 
     version.dwOSVersionInfoSize = sizeof version;
     if (!GetVersionEx( &amp;version )) {
-        errno = EINVAL;
-        return -1;
+	errno = EINVAL;
+	return -1;
     }
     if (version.dwPlatformId != VER_PLATFORM_WIN32_NT)
-        return 0;
+	return 0;
 
     h = CreateFile( &quot;\\\\.\\giveio&quot;, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
     if (h == INVALID_HANDLE_VALUE) {
-        errno = ENODEV;
-        return -1;
+	errno = ENODEV;
+	return -1;
     }
 
     CloseHandle( h );
@@ -468,7 +468,7 @@
 	int i = 0;
 #endif
 	u8 status_port;
-	
+
 #if PARPORT_USE_PPDEV == 1
 	if (device_handle&gt;0)
 	{
@@ -486,7 +486,7 @@
 
 	snprintf(buffer, 256, &quot;/dev/parport%d&quot;, gw16012_port);
 	device_handle = open(buffer, O_WRONLY);
-#endif	
+#endif
 	if (device_handle&lt;0)
 	{
 		LOG_ERROR(&quot;cannot open device. check it exists and that user read and write rights are set&quot;);
@@ -525,7 +525,7 @@
 		gw16012_port = 0x378;
 		LOG_WARNING(&quot;No gw16012 port specified, using default '0x378' (LPT1)&quot;);
 	}
-	
+
 	LOG_DEBUG(&quot;requesting privileges for parallel port 0x%lx...&quot;, (long unsigned)(gw16012_port) );
 #if PARPORT_USE_GIVEIO == 1
 	if (gw16012_get_giveio_access() != 0)
@@ -545,19 +545,19 @@
 	outb(0x0, gw16012_port + 2);
 #endif
 #endif /* PARPORT_USE_PPDEV */
-	
+
 	gw16012_input(&amp;status_port);
 	gw16012_msb = (status_port &amp; 0x80) ^ 0x80;
-	
+
 	gw16012_speed(jtag_speed);
 	gw16012_reset(0, 0);
-	
+
 	return ERROR_OK;
 }
 
 int gw16012_quit(void)
 {
-	
+
 	return ERROR_OK;
 }
 

Modified: trunk/src/jtag/jlink.c
===================================================================
--- trunk/src/jtag/jlink.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/jlink.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -146,92 +146,92 @@
 	int scan_size;
 	enum scan_type type;
 	u8 *buffer;
-	
+
 	while (cmd != NULL)
 	{
 		switch (cmd-&gt;type)
 		{
 			case JTAG_END_STATE:
 				DEBUG_JTAG_IO(&quot;end_state: %i&quot;, cmd-&gt;cmd.end_state-&gt;end_state);
-			
+
 				if (cmd-&gt;cmd.end_state-&gt;end_state != -1)
 				{
 					jlink_end_state(cmd-&gt;cmd.end_state-&gt;end_state);
 				}
 				break;
-	
+
 			case JTAG_RUNTEST:
 				DEBUG_JTAG_IO( &quot;runtest %i cycles, end in %i&quot;, cmd-&gt;cmd.runtest-&gt;num_cycles, \
 					cmd-&gt;cmd.runtest-&gt;end_state);
-				
+
 				if (cmd-&gt;cmd.runtest-&gt;end_state != -1)
 				{
 					jlink_end_state(cmd-&gt;cmd.runtest-&gt;end_state);
 				}
 				jlink_runtest(cmd-&gt;cmd.runtest-&gt;num_cycles);
 				break;
-	
+
 			case JTAG_STATEMOVE:
 				DEBUG_JTAG_IO(&quot;statemove end in %i&quot;, cmd-&gt;cmd.statemove-&gt;end_state);
-			
+
 				if (cmd-&gt;cmd.statemove-&gt;end_state != -1)
 				{
 					jlink_end_state(cmd-&gt;cmd.statemove-&gt;end_state);
 				}
 				jlink_state_move();
 				break;
-	
+
 			case JTAG_PATHMOVE:
 				DEBUG_JTAG_IO(&quot;pathmove: %i states, end in %i&quot;, \
 					cmd-&gt;cmd.pathmove-&gt;num_states, \
 					cmd-&gt;cmd.pathmove-&gt;path[cmd-&gt;cmd.pathmove-&gt;num_states - 1]);
-			
+
 				jlink_path_move(cmd-&gt;cmd.pathmove-&gt;num_states, cmd-&gt;cmd.pathmove-&gt;path);
 				break;
-	
+
 			case JTAG_SCAN:
 				DEBUG_JTAG_IO(&quot;scan end in %i&quot;, cmd-&gt;cmd.scan-&gt;end_state);
-			
+
 				if (cmd-&gt;cmd.scan-&gt;end_state != -1)
 				{
 					jlink_end_state(cmd-&gt;cmd.scan-&gt;end_state);
 				}
-			
+
 				scan_size = jtag_build_buffer(cmd-&gt;cmd.scan, &amp;buffer);
 				DEBUG_JTAG_IO(&quot;scan input, length = %d&quot;, scan_size);
-				
+
 #ifdef _DEBUG_USB_COMMS_
 				jlink_debug_buffer(buffer, (scan_size + 7) / 8);
 #endif
 				type = jtag_scan_type(cmd-&gt;cmd.scan);
 				jlink_scan(cmd-&gt;cmd.scan-&gt;ir_scan, type, buffer, scan_size, cmd-&gt;cmd.scan);
 				break;
-	
+
 			case JTAG_RESET:
 				DEBUG_JTAG_IO(&quot;reset trst: %i srst %i&quot;, cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
-			
+
 				jlink_tap_execute();
-			
+
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_TLR;
+					cur_state = TAP_RESET;
 				}
 				jlink_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
-	
+
 			case JTAG_SLEEP:
 				DEBUG_JTAG_IO(&quot;sleep %i&quot;, cmd-&gt;cmd.sleep-&gt;us);
 				jlink_tap_execute();
 				jtag_sleep(cmd-&gt;cmd.sleep-&gt;us);
 				break;
-	
+
 			default:
 				LOG_ERROR(&quot;BUG: unknown JTAG command type encountered&quot;);
 				exit(-1);
 		}
 		cmd = cmd-&gt;next;
 	}
-	
+
 	return jlink_tap_execute();
 }
 
@@ -239,19 +239,19 @@
 int jlink_speed(int speed)
 {
 	int result;
-	
+
 	if (speed &lt;= JLINK_MAX_SPEED)
 	{
 		/* check for RTCK setting */
 		if (speed == 0)
 			speed = -1;
-		
+
 		usb_out_buffer[0] = EMU_CMD_SET_SPEED;
 		usb_out_buffer[1] = (speed &gt;&gt; 0) &amp; 0xff;
 		usb_out_buffer[2] = (speed &gt;&gt; 8) &amp; 0xff;
-		
+
 		result = jlink_usb_write(jlink_jtag_handle, 3);
-		
+
 		if (result == 3)
 		{
 			return ERROR_OK;
@@ -266,14 +266,14 @@
 	{
 		LOG_INFO(&quot;Requested speed %dkHz exceeds maximum of %dkHz, ignored&quot;, speed, JLINK_MAX_SPEED);
 	}
-	
+
 	return ERROR_OK;
 }
 
 int jlink_khz(int khz, int *jtag_speed)
 {
 	*jtag_speed = khz;
-	
+
 	return ERROR_OK;
 }
 
@@ -286,16 +286,16 @@
 
 int jlink_init(void)
 {
-	int check_cnt;  
-	
+	int check_cnt;
+
 	jlink_jtag_handle = jlink_usb_open();
-	
+
 	if (jlink_jtag_handle == 0)
 	{
 		LOG_ERROR(&quot;Cannot find jlink Interface! Please check connection and permissions.&quot;);
 		return ERROR_JTAG_INIT_FAILED;
 	}
-		
+
 	check_cnt = 0;
 	while (check_cnt &lt; 3)
 	{
@@ -305,7 +305,7 @@
 			jlink_get_status();
 			break;
 		}
-		
+
 		check_cnt++;
 	}
 
@@ -313,12 +313,12 @@
 	{
 		LOG_INFO(&quot;J-Link initial read failed, don't worry&quot;);
 	}
-	
+
 	LOG_INFO(&quot;J-Link JTAG Interface ready&quot;);
-	
+
 	jlink_reset(0, 0);
 	jlink_tap_init();
-	
+
 	return ERROR_OK;
 }
 
@@ -350,20 +350,20 @@
 	int i;
 	int tms = 0;
 	u8 tms_scan = TAP_MOVE(cur_state, end_state);
-	
+
 	for (i = 0; i &lt; 7; i++)
 	{
 		tms = (tms_scan &gt;&gt; i) &amp; 1;
 		jlink_tap_append_step(tms, 0);
 	}
-	
+
 	cur_state = end_state;
 }
 
 void jlink_path_move(int num_states, enum tap_state *path)
 {
 	int i;
-	
+
 	for (i = 0; i &lt; num_states; i++)
 	{
 		if (path[i] == tap_transitions[cur_state].low)
@@ -379,32 +379,32 @@
 			LOG_ERROR(&quot;BUG: %s -&gt; %s isn't a valid TAP transition&quot;, tap_state_strings[cur_state], tap_state_strings[path[i]]);
 			exit(-1);
 		}
-		
+
 		cur_state = path[i];
 	}
-	
+
 	end_state = cur_state;
 }
 
 void jlink_runtest(int num_cycles)
 {
 	int i;
-	
+
 	enum tap_state saved_end_state = end_state;
-	
+
 	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_RTI)
+	if (cur_state != TAP_IDLE)
 	{
-		jlink_end_state(TAP_RTI);
+		jlink_end_state(TAP_IDLE);
 		jlink_state_move();
 	}
-	
+
 	/* execute num_cycles */
 	for (i = 0; i &lt; num_cycles; i++)
 	{
 		jlink_tap_append_step(0, 0);
 	}
-	
+
 	/* finish in end_state */
 	jlink_end_state(saved_end_state);
 	if (cur_state != end_state)
@@ -416,25 +416,25 @@
 void jlink_scan(int ir_scan, enum scan_type type, u8 *buffer, int scan_size, scan_command_t *command)
 {
 	enum tap_state saved_end_state;
-	
+
 	jlink_tap_ensure_space(1, scan_size + 8);
-	
+
 	saved_end_state = end_state;
-	
+
 	/* Move to appropriate scan state */
-	jlink_end_state(ir_scan ? TAP_SI : TAP_SD);
-	
+	jlink_end_state(ir_scan ? TAP_IRSHIFT : TAP_DRSHIFT);
+
 	jlink_state_move();
 	jlink_end_state(saved_end_state);
-	
+
 	/* Scan */
 	jlink_tap_append_scan(scan_size, buffer, command);
-	
+
 	/* We are in Exit1, go to Pause */
 	jlink_tap_append_step(0, 0);
-	
-	cur_state = ir_scan ? TAP_PI : TAP_PD;
-	
+
+	cur_state = ir_scan ? TAP_IRPAUSE : TAP_DRPAUSE;
+
 	if (cur_state != end_state)
 	{
 		jlink_state_move();
@@ -444,7 +444,7 @@
 void jlink_reset(int trst, int srst)
 {
 	LOG_DEBUG(&quot;trst: %i, srst: %i&quot;, trst, srst);
-	
+
 	/* Signals are active low */
 	if (srst == 0)
 	{
@@ -454,7 +454,7 @@
 	{
 		jlink_simple_command(EMU_CMD_HW_RESET0);
 	}
-	
+
 	if (trst == 0)
 	{
 		jlink_simple_command(EMU_CMD_HW_TRST1);
@@ -468,12 +468,12 @@
 void jlink_simple_command(u8 command)
 {
 	int result;
-	
+
 	DEBUG_JTAG_IO(&quot;0x%02x&quot;, command);
-	
+
 	usb_out_buffer[0] = command;
 	result = jlink_usb_write(jlink_jtag_handle, 1);
-	
+
 	if (result != 1)
 	{
 		LOG_ERROR(&quot;J-Link command 0x%02x failed (%d)&quot;, command, result);
@@ -483,10 +483,10 @@
 int jlink_get_status(void)
 {
 	int result;
-	
+
 	jlink_simple_command(EMU_CMD_GET_STATE);
 	result = jlink_usb_read(jlink_jtag_handle);
-	
+
 	if (result == 8)
 	{
 		int vref = usb_in_buffer[0] + (usb_in_buffer[1] &lt;&lt; 8);
@@ -494,7 +494,7 @@
 			vref / 1000, vref % 1000, \
 			usb_in_buffer[2], usb_in_buffer[3], usb_in_buffer[4], \
 			usb_in_buffer[5], usb_in_buffer[6], usb_in_buffer[7]);
-		
+
 		if (vref &lt; 1500)
 		{
 			LOG_ERROR(&quot;Vref too low. Check Target Power\n&quot;);
@@ -504,7 +504,7 @@
 	{
 		LOG_ERROR(&quot;J-Link command EMU_CMD_GET_STATE failed (%d)\n&quot;, result);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -512,16 +512,16 @@
 {
 	int result;
 	int len = 0;
-	
+
 	/* query hardware version */
 	jlink_simple_command(EMU_CMD_VERSION);
 	result = jlink_usb_read(jlink_jtag_handle);
-	
+
 	if (result == 2)
 	{
 		len = buf_get_u32(usb_in_buffer, 0, 16);
 		result = jlink_usb_read(jlink_jtag_handle);
-		
+
 		if (result == len)
 		{
 			usb_in_buffer[result] = 0;
@@ -529,7 +529,7 @@
 			return ERROR_OK;
 		}
 	}
-	
+
 	LOG_ERROR(&quot;J-Link command EMU_CMD_VERSION failed (%d)\n&quot;, result);
 	return ERROR_JTAG_DEVICE_ERROR;
 }
@@ -541,7 +541,7 @@
 		/* attempt to get status */
 		jlink_get_status();
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -581,7 +581,7 @@
 {
 	int available_scans = MAX_PENDING_SCAN_RESULTS - pending_scan_results_length;
 	int available_bits = JLINK_TAP_BUFFER_SIZE * 8 - tap_length;
-	
+
 	if (scans &gt; available_scans || bits &gt; available_bits)
 	{
 		jlink_tap_execute();
@@ -592,12 +592,12 @@
 {
 	last_tms = tms;
 	int index = tap_length / 8;
-	
+
 	if (index &lt; JLINK_TAP_BUFFER_SIZE)
 	{
 		int bit_index = tap_length % 8;
 		u8 bit = 1 &lt;&lt; bit_index;
-		
+
 		if (tms)
 		{
 			tms_buffer[index] |= bit;
@@ -606,7 +606,7 @@
 		{
 			tms_buffer[index] &amp;= ~bit;
 		}
-		
+
 		if (tdi)
 		{
 			tdi_buffer[index] |= bit;
@@ -615,7 +615,7 @@
 		{
 			tdi_buffer[index] &amp;= ~bit;
 		}
-		
+
 		tap_length++;
 	}
 	else
@@ -628,12 +628,12 @@
 {
 	pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[pending_scan_results_length];
 	int i;
-	
+
 	pending_scan_result-&gt;first = tap_length;
 	pending_scan_result-&gt;length = length;
 	pending_scan_result-&gt;command = command;
 	pending_scan_result-&gt;buffer = buffer;
-	
+
 	for (i = 0; i &lt; length; i++)
 	{
 		jlink_tap_append_step((i &lt; length-1 ? 0 : 1), (buffer[i/8] &gt;&gt; (i%8)) &amp; 1);
@@ -650,7 +650,7 @@
 	int tdi_offset;
 	int i;
 	int result;
-	
+
 	if (tap_length &gt; 0)
 	{
 		/* Pad last byte so that tap_length is divisible by 8 */
@@ -660,35 +660,35 @@
 			 * analogous to free-running JTAG interfaces. */
 			jlink_tap_append_step(last_tms, 0);
 		}
-	
+
 		byte_length = tap_length / 8;
-	
+
 		usb_out_buffer[0] = EMU_CMD_HW_JTAG3;
 		usb_out_buffer[1] = 0;
 		usb_out_buffer[2] = (tap_length &gt;&gt; 0) &amp; 0xff;
 		usb_out_buffer[3] = (tap_length &gt;&gt; 8) &amp; 0xff;
-	
+
 		tms_offset = 4;
 		for (i = 0; i &lt; byte_length; i++)
 		{
 			usb_out_buffer[tms_offset + i] = tms_buffer[i];
 		}
-		
+
 		tdi_offset = tms_offset + byte_length;
 		for (i = 0; i &lt; byte_length; i++)
 		{
 			usb_out_buffer[tdi_offset + i] = tdi_buffer[i];
 		}
-	
+
 		result = jlink_usb_message(jlink_jtag_handle, 4 + 2 * byte_length, byte_length);
-	
+
 		if (result == byte_length)
 		{
 			for (i = 0; i &lt; byte_length; i++)
 			{
 				tdo_buffer[i] = usb_in_buffer[i];
 			}
-			
+
 			for (i = 0; i &lt; pending_scan_results_length; i++)
 			{
 				pending_scan_result_t *pending_scan_result = &amp;pending_scan_results_buffer[i];
@@ -696,22 +696,22 @@
 				int length = pending_scan_result-&gt;length;
 				int first = pending_scan_result-&gt;first;
 				scan_command_t *command = pending_scan_result-&gt;command;
-	
+
 				/* Copy to buffer */
 				buf_set_buf(tdo_buffer, first, buffer, 0, length);
-	
+
 				DEBUG_JTAG_IO(&quot;pending scan result, length = %d&quot;, length);
-				
+
 #ifdef _DEBUG_USB_COMMS_
 				jlink_debug_buffer(buffer, byte_length);
 #endif
-	
+
 				if (jtag_read_buffer(buffer, command) != ERROR_OK)
 				{
 					jlink_tap_init();
 					return ERROR_JTAG_QUEUE_FAILED;
 				}
-		
+
 				if (pending_scan_result-&gt;buffer != NULL)
 				{
 					free(pending_scan_result-&gt;buffer);
@@ -723,10 +723,10 @@
 			LOG_ERROR(&quot;jlink_tap_execute, wrong result %d, expected %d&quot;, result, byte_length);
 			return ERROR_JTAG_QUEUE_FAILED;
 		}
-		
+
 		jlink_tap_init();
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -738,19 +738,19 @@
 	struct usb_bus *busses;
 	struct usb_bus *bus;
 	struct usb_device *dev;
-	
+
 	jlink_jtag_t *result;
-	
+
 	result = (jlink_jtag_t*) malloc(sizeof(jlink_jtag_t));
-	
+
 	usb_init();
 	usb_find_busses();
 	usb_find_devices();
-	
+
 	busses = usb_get_busses();
-	
+
 	/* find jlink_jtag device in usb bus */
-	
+
 	for (bus = busses; bus; bus = bus-&gt;next)
 	{
 		for (dev = bus-&gt;devices; dev; dev = dev-&gt;next)
@@ -758,23 +758,23 @@
 			if ((dev-&gt;descriptor.idVendor == VID) &amp;&amp; (dev-&gt;descriptor.idProduct == PID))
 			{
 				result-&gt;usb_handle = usb_open(dev);
-				
+
 				/* usb_set_configuration required under win32 */
 				usb_set_configuration(result-&gt;usb_handle, dev-&gt;config[0].bConfigurationValue);
 				usb_claim_interface(result-&gt;usb_handle, 0);
-				
+
 #if 0
-				/* 
+				/*
 				 * This makes problems under Mac OS X. And is not needed
 				 * under Windows. Hopefully this will not break a linux build
 				 */
 				usb_set_altinterface(result-&gt;usb_handle, 0);
-#endif				
+#endif
 				return result;
 			}
 		}
 	}
-	
+
 	free(result);
 	return NULL;
 }
@@ -790,7 +790,7 @@
 {
 	int result;
 	int result2;
-	
+
 	result = jlink_usb_write(jlink_jtag, out_length);
 	if (result == out_length)
 	{
@@ -811,7 +811,7 @@
 					else
 					{
 						LOG_ERROR(&quot;jlink_usb_read_emu_result (requested=0, result=%d)&quot;, usb_emu_result_buffer[0]);
-						return -1;				
+						return -1;
 					}
 				}
 				else
@@ -830,7 +830,7 @@
 				else
 				{
 					LOG_ERROR(&quot;jlink_usb_read_emu_result (requested=0, result=%d)&quot;, usb_in_buffer[result]);
-					return -1;				
+					return -1;
 				}
 			}
 		}
@@ -851,18 +851,18 @@
 int jlink_usb_write(jlink_jtag_t *jlink_jtag, int out_length)
 {
 	int result;
-	
+
 	if (out_length &gt; JLINK_OUT_BUFFER_SIZE)
 	{
 		LOG_ERROR(&quot;jlink_jtag_write illegal out_length=%d (max=%d)&quot;, out_length, JLINK_OUT_BUFFER_SIZE);
 		return -1;
 	}
-	
+
 	result = usb_bulk_write(jlink_jtag-&gt;usb_handle, JLINK_WRITE_ENDPOINT, \
 		usb_out_buffer, out_length, JLINK_USB_TIMEOUT);
-	
+
 	DEBUG_JTAG_IO(&quot;jlink_usb_write, out_length = %d, result = %d&quot;, out_length, result);
-	
+
 #ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(usb_out_buffer, out_length);
 #endif
@@ -876,7 +876,7 @@
 		usb_in_buffer, JLINK_IN_BUFFER_SIZE, JLINK_USB_TIMEOUT);
 
 	DEBUG_JTAG_IO(&quot;jlink_usb_read, result = %d&quot;, result);
-	
+
 #ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(usb_in_buffer, result);
 #endif
@@ -890,7 +890,7 @@
 		usb_emu_result_buffer, JLINK_EMU_RESULT_BUFFER_SIZE, JLINK_USB_TIMEOUT);
 
 	DEBUG_JTAG_IO(&quot;jlink_usb_read_result, result = %d&quot;, result);
-	
+
 #ifdef _DEBUG_USB_COMMS_
 	jlink_debug_buffer(usb_emu_result_buffer, result);
 #endif
@@ -906,7 +906,7 @@
 	char s[4];
 	int i;
 	int j;
-	
+
 	for (i = 0; i &lt; length; i += BYTES_PER_LINE)
 	{
 		snprintf(line, 5, &quot;%04x&quot;, i);

Modified: trunk/src/jtag/jtag.c
===================================================================
--- trunk/src/jtag/jtag.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/jtag.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -87,22 +87,22 @@
 
 tap_transition_t tap_transitions[16] =
 {
-	{TAP_TLR, TAP_RTI},		/* TLR */
-	{TAP_SIS, TAP_CD},		/* SDS */
-	{TAP_E1D, TAP_SD},		/* CD  */
-	{TAP_E1D, TAP_SD},		/* SD  */
-	{TAP_UD,  TAP_PD}, 		/* E1D */
-	{TAP_E2D, TAP_PD},		/* PD  */
-	{TAP_UD,  TAP_SD},		/* E2D */
-	{TAP_SDS, TAP_RTI},		/* UD  */
-	{TAP_SDS, TAP_RTI},		/* RTI */
-	{TAP_TLR, TAP_CI},		/* SIS */
-	{TAP_E1I, TAP_SI},		/* CI  */
-	{TAP_E1I, TAP_SI},		/* SI  */
-	{TAP_UI,  TAP_PI}, 		/* E1I */
-	{TAP_E2I, TAP_PI},		/* PI  */
-	{TAP_UI,  TAP_SI},		/* E2I */
-	{TAP_SDS, TAP_RTI}		/* UI  */
+	{TAP_RESET, TAP_IDLE},		/* TLR */
+	{TAP_IRSELECT, TAP_DRCAPTURE},		/* SDS */
+	{TAP_DREXIT1, TAP_DRSHIFT},		/* CD  */
+	{TAP_DREXIT1, TAP_DRSHIFT},		/* SD  */
+	{TAP_DRUPDATE,  TAP_DRPAUSE}, 		/* E1D */
+	{TAP_DREXIT2, TAP_DRPAUSE},		/* PD  */
+	{TAP_DRUPDATE,  TAP_DRSHIFT},		/* E2D */
+	{TAP_DRSELECT, TAP_IDLE},		/* UD  */
+	{TAP_DRSELECT, TAP_IDLE},		/* RTI */
+	{TAP_RESET, TAP_IRCAPTURE},		/* SIS */
+	{TAP_IREXIT1, TAP_IRSHIFT},		/* CI  */
+	{TAP_IREXIT1, TAP_IRSHIFT},		/* SI  */
+	{TAP_IRUPDATE,  TAP_IRPAUSE}, 		/* E1I */
+	{TAP_IREXIT2, TAP_IRPAUSE},		/* PI  */
+	{TAP_IRUPDATE,  TAP_IRSHIFT},		/* E2I */
+	{TAP_DRSELECT, TAP_IDLE}		/* UI  */
 };
 
 char* jtag_event_strings[] =
@@ -115,8 +115,8 @@
  * inside the drivers, but we don't want to break
  * linking the drivers!!!!
  */
-enum tap_state end_state = TAP_TLR;
-enum tap_state cur_state = TAP_TLR;
+enum tap_state end_state = TAP_RESET;
+enum tap_state cur_state = TAP_RESET;
 int jtag_trst = 0;
 int jtag_srst = 0;
 
@@ -125,8 +125,8 @@
 static jtag_tap_t *jtag_all_taps = NULL;
 
 enum reset_types jtag_reset_config = RESET_NONE;
-enum tap_state cmd_queue_end_state = TAP_TLR;
-enum tap_state cmd_queue_cur_state = TAP_TLR;
+enum tap_state cmd_queue_end_state = TAP_RESET;
+enum tap_state cmd_queue_cur_state = TAP_RESET;
 
 int jtag_verify_capture_ir = 1;
 
@@ -477,7 +477,7 @@
 	 * alignment.
 	 *
 	 * What I do not/have is a reasonable portable means
-	 * to align by... 
+	 * to align by...
 	 *
 	 * The solution here, is based on these suggestions.
 	 * <A HREF="http://gcc.gnu.org/ml/gcc-help/2008-12/msg00041.html">http://gcc.gnu.org/ml/gcc-help/2008-12/msg00041.html</A>
@@ -493,9 +493,9 @@
 
 	// The alignment process.
 	size = (size + ALIGN_SIZE -1) &amp; (~(ALIGN_SIZE-1));
-	// Done... 
-	
+	// Done...
 
+
 	if (*p_page)
 	{
 		while ((*p_page)-&gt;next)
@@ -543,7 +543,7 @@
 		return;
 	}
 
-	if (cmd_queue_end_state == TAP_TLR)
+	if (cmd_queue_end_state == TAP_RESET)
 		jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
 }
 
@@ -959,7 +959,7 @@
 
 void jtag_add_tlr(void)
 {
-	jtag_prelude(TAP_TLR);
+	jtag_prelude(TAP_RESET);
 
 	int retval;
 	retval=interface_jtag_add_tlr();
@@ -969,7 +969,7 @@
 
 int MINIDRIVER(interface_jtag_add_tlr)()
 {
-	enum tap_state state = TAP_TLR;
+	enum tap_state state = TAP_RESET;
 	jtag_command_t **last_cmd = jtag_get_last_command_p();
 
 	/* allocate memory for a new list member */
@@ -1000,9 +1000,9 @@
 
 	for (i=0; i&lt;num_states; i++)
 	{
-		if (path[i] == TAP_TLR)
+		if (path[i] == TAP_RESET)
 		{
-			LOG_ERROR(&quot;BUG: TAP_TLR is not a valid state for pathmove sequences&quot;);
+			LOG_ERROR(&quot;BUG: TAP_RESET is not a valid state for pathmove sequences&quot;);
 			exit(-1);
 		}
 		if ((tap_transitions[cur_state].low != path[i])&amp;&amp;
@@ -1154,7 +1154,7 @@
 	if (trst_with_tlr)
 	{
 		LOG_DEBUG(&quot;JTAG reset with TLR instead of TRST&quot;);
-		jtag_add_end_state(TAP_TLR);
+		jtag_add_end_state(TAP_RESET);
 		jtag_add_tlr();
 		jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
 		return;
@@ -1166,7 +1166,7 @@
 		 * and inform possible listeners about this
 		 */
 		LOG_DEBUG(&quot;TRST line asserted&quot;);
-		cmd_queue_cur_state = TAP_TLR;
+		cmd_queue_cur_state = TAP_RESET;
 		jtag_call_event_callbacks(JTAG_TRST_ASSERTED);
 	}
 	else
@@ -1196,9 +1196,9 @@
 void jtag_add_end_state(enum tap_state state)
 {
 	cmd_queue_end_state = state;
-	if ((cmd_queue_end_state == TAP_SD)||(cmd_queue_end_state == TAP_SI))
+	if ((cmd_queue_end_state == TAP_DRSHIFT)||(cmd_queue_end_state == TAP_IRSHIFT))
 	{
-		LOG_ERROR(&quot;BUG: TAP_SD/SI can't be end state. Calling code should use a larger scan field&quot;);
+		LOG_ERROR(&quot;BUG: TAP_DRSHIFT/SI can't be end state. Calling code should use a larger scan field&quot;);
 	}
 }
 
@@ -1491,7 +1491,7 @@
 		buf_set_u32(idcode_buffer, i * 32, 32, 0x000000FF);
 	}
 
-	jtag_add_plain_dr_scan(1, &amp;field, TAP_TLR);
+	jtag_add_plain_dr_scan(1, &amp;field, TAP_RESET);
 	jtag_execute_queue();
 
 	for (i = 0; i &lt; JTAG_MAX_CHAIN_SIZE * 4; i++)
@@ -1583,7 +1583,7 @@
 						break;
 					}
 				}
-			
+
 				/* If none of the expected ids matched, log an error */
 				if (ii == tap-&gt;expected_ids_cnt) {
 					LOG_ERROR(&quot;JTAG tap: %s             got: 0x%08x (mfg: 0x%3.3x, part: 0x%4.4x, ver: 0x%1.1x)&quot;,
@@ -1662,7 +1662,7 @@
 	field.in_handler = NULL;
 	field.in_handler_priv = NULL;
 
-	jtag_add_plain_ir_scan(1, &amp;field, TAP_TLR);
+	jtag_add_plain_ir_scan(1, &amp;field, TAP_RESET);
 	jtag_execute_queue();
 
 	tap = NULL;
@@ -1801,8 +1801,8 @@
 			memcpy(new_expected_ids, pTap-&gt;expected_ids, sizeof(u32) * pTap-&gt;expected_ids_cnt);
 
 			new_expected_ids[pTap-&gt;expected_ids_cnt] = w;
-		
-			free(pTap-&gt;expected_ids);	
+
+			free(pTap-&gt;expected_ids);
 			pTap-&gt;expected_ids = new_expected_ids;
 			pTap-&gt;expected_ids_cnt++;
 			break;

Modified: trunk/src/jtag/jtag.h
===================================================================
--- trunk/src/jtag/jtag.h	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/jtag.h	2008-12-13 06:25:50 UTC (rev 1232)
@@ -33,20 +33,15 @@
 #define _DEBUG_JTAG_IO_
 #endif
 
-/* Tap States
- * TLR - Test-Logic-Reset, RTI - Run-Test/Idle,
- * SDS - Select-DR-Scan, CD - Capture-DR, SD - Shift-DR, E1D - Exit1-DR,
- * PD - Pause-DR, E2D - Exit2-DR, UD - Update-DR,
- * SIS - Select-IR-Scan, CI - Capture-IR, SI - Shift-IR, E1I - Exit1-IR,
- * PI - Pause-IR, E2I - Exit2-IR, UI - Update-IR
+/* 16 Tap States, from page 21 of ASSET InterTech, Inc.'s svf.pdf
  */
 enum tap_state
 {
-	TAP_TLR = 0x0, TAP_RTI = 0x8,
-	TAP_SDS = 0x1, TAP_CD = 0x2, TAP_SD = 0x3, TAP_E1D = 0x4,
-	TAP_PD = 0x5, TAP_E2D = 0x6, TAP_UD = 0x7,
-	TAP_SIS = 0x9, TAP_CI = 0xa, TAP_SI = 0xb, TAP_E1I = 0xc,
-	TAP_PI = 0xd, TAP_E2I = 0xe, TAP_UI = 0xf
+	TAP_RESET = 0x0, TAP_IDLE = 0x8,
+	TAP_DRSELECT = 0x1, TAP_DRCAPTURE = 0x2, TAP_DRSHIFT = 0x3, TAP_DREXIT1 = 0x4,
+	TAP_DRPAUSE = 0x5, TAP_DREXIT2 = 0x6, TAP_DRUPDATE = 0x7,
+	TAP_IRSELECT = 0x9, TAP_IRCAPTURE = 0xa, TAP_IRSHIFT = 0xb, TAP_IREXIT1 = 0xc,
+	TAP_IRPAUSE = 0xd, TAP_IREXIT2 = 0xe, TAP_IRUPDATE = 0xf
 };
 
 typedef struct tap_transition_s
@@ -325,7 +320,7 @@
 
 /* JTAG interface, can be implemented with a software or hardware fifo
  *
- * TAP_SD and TAP_SI are illegal end states. TAP_SD/SI as end states
+ * TAP_DRSHIFT and TAP_IRSHIFT are illegal end states. TAP_DRSHIFT/SI as end states
  * can be emulated by using a larger scan.
  *
  * Code that is relatively insensitive to the path(as long
@@ -343,7 +338,7 @@
 extern int interface_jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
 extern void jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
 extern int interface_jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, enum tap_state endstate);
-/* run a TAP_TLR reset. End state is TAP_TLR, regardless
+/* run a TAP_RESET reset. End state is TAP_RESET, regardless
  * of start state.
  */
 extern void jtag_add_tlr(void);
@@ -364,7 +359,7 @@
  * all drivers can support this, but it is required for e.g.
  * XScale and Xilinx support
  *
- * Note! TAP_TLR must not be used in the path!
+ * Note! TAP_RESET must not be used in the path!
  *
  * Note that the first on the list must be reachable
  * via a single transition from the current state.
@@ -380,12 +375,12 @@
  */
 extern void jtag_add_pathmove(int num_states, enum tap_state *path);
 extern int interface_jtag_add_pathmove(int num_states, enum tap_state *path);
-/* go to TAP_RTI, if we're not already there and cycle
- * precisely num_cycles in the TAP_RTI after which move
- * to the end state, if it is != TAP_RTI
+/* go to TAP_IDLE, if we're not already there and cycle
+ * precisely num_cycles in the TAP_IDLE after which move
+ * to the end state, if it is != TAP_IDLE
  *
  * nb! num_cycles can be 0, in which case the fn will navigate
- * to endstate via TAP_RTI
+ * to endstate via TAP_IDLE
  */
 extern void jtag_add_runtest(int num_cycles, enum tap_state endstate);
 extern int interface_jtag_add_runtest(int num_cycles, enum tap_state endstate);
@@ -488,7 +483,7 @@
 #define MINIDRIVER(a) a
 /* jtag_add_dr_out() is a faster version of jtag_add_dr_scan()
  *
- * Current or end_state can not be TAP_TLR. end_state can be -1
+ * Current or end_state can not be TAP_RESET. end_state can be -1
  *
  * num_bits[i] is the number of bits to clock out from value[i] LSB first.
  *

Modified: trunk/src/jtag/usbprog.c
===================================================================
--- trunk/src/jtag/usbprog.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/usbprog.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -151,7 +151,7 @@
 #endif
 				if (cmd-&gt;cmd.reset-&gt;trst == 1)
 				{
-					cur_state = TAP_TLR;
+					cur_state = TAP_RESET;
 				}
 				usbprog_reset(cmd-&gt;cmd.reset-&gt;trst, cmd-&gt;cmd.reset-&gt;srst);
 				break;
@@ -299,9 +299,9 @@
 	int i;
 
 	/* only do a state_move when we're not already in RTI */
-	if (cur_state != TAP_RTI)
+	if (cur_state != TAP_IDLE)
 	{
-		usbprog_end_state(TAP_RTI);
+		usbprog_end_state(TAP_IDLE);
 		usbprog_state_move();
 	}
 
@@ -336,9 +336,9 @@
 	enum tap_state saved_end_state = end_state;
 
 	if (ir_scan)
-		usbprog_end_state(TAP_SI);
+		usbprog_end_state(TAP_IRSHIFT);
 	else
-		usbprog_end_state(TAP_SD);
+		usbprog_end_state(TAP_DRSHIFT);
 
 	/* usbprog_jtag_tms_send(usbprog_jtag_handle); */
 
@@ -361,9 +361,9 @@
 	}
 
 	if (ir_scan)
-		cur_state = TAP_PI;
+		cur_state = TAP_IRPAUSE;
 	else
-		cur_state = TAP_PD;
+		cur_state = TAP_DRPAUSE;
 
 	if (cur_state != end_state)
 		usbprog_state_move();

Modified: trunk/src/jtag/zy1000.c
===================================================================
--- trunk/src/jtag/zy1000.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/jtag/zy1000.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -158,7 +158,7 @@
 	else
 	{
 		/* Danger!!! if clk!=0 when in
-		 * idle in TAP_RTI, reset halt on str912 will fail.
+		 * idle in TAP_IDLE, reset halt on str912 will fail.
 		 */
 		ZY1000_POKE(ZY1000_JTAG_BASE+0x10, 0x00000001);
 	}
@@ -177,7 +177,7 @@
 	{
 		waitIdle();
 		/* we're now in the TLR state until trst is deasserted */
-		ZY1000_POKE(ZY1000_JTAG_BASE+0x20, TAP_TLR);
+		ZY1000_POKE(ZY1000_JTAG_BASE+0x20, TAP_RESET);
 	} else
 	{
 		/* We'll get RCLK failure when we assert TRST, so clear any false positives here */
@@ -303,7 +303,7 @@
     if (fread(*data, 1, *len, pFile)!=*len)
     {
 		fclose(pFile);
-    	free(*data);
+	free(*data);
 		LOG_ERROR(&quot;Can't open %s\n&quot;, fileName);
 		return ERROR_JTAG_DEVICE_ERROR;
     }
@@ -429,7 +429,7 @@
 			enum tap_state pause_state;
 			int l;
 			k=num_bits-j;
-			pause_state=(shiftState==TAP_SD)?TAP_SD:TAP_SI;
+			pause_state=(shiftState==TAP_DRSHIFT)?TAP_DRSHIFT:TAP_IRSHIFT;
 			if (k&gt;32)
 			{
 				k=32;
@@ -437,7 +437,7 @@
 			} else if (pause&amp;&amp;(i == num_fields-1))
 			{
 				/* this was the last to shift out this time */
-				pause_state=(shiftState==TAP_SD)?TAP_PD:TAP_PI;
+				pause_state=(shiftState==TAP_DRSHIFT)?TAP_DRPAUSE:TAP_IRPAUSE;
 			}
 
 			// we have (num_bits+7)/8 bytes of bits to toggle out.
@@ -520,7 +520,7 @@
 					fields[j].in_check_mask = tap-&gt;expected_mask;
 				}
 
-				scanFields(1, fields+j, TAP_SI, pause);
+				scanFields(1, fields+j, TAP_IRSHIFT, pause);
 				/* update device information */
 				buf_cpy(fields[j].out_value, tap-&gt;cur_instr, scan_size);
 
@@ -538,7 +538,7 @@
 			memset(&amp;tmp, 0, sizeof(tmp));
 			tmp.out_value = ones;
 			tmp.num_bits = scan_size;
-			scanFields(1, &amp;tmp, TAP_SI, pause);
+			scanFields(1, &amp;tmp, TAP_IRSHIFT, pause);
 			/* update device information */
 			buf_cpy(tmp.out_value, tap-&gt;cur_instr, scan_size);
 			tap-&gt;bypass = 1;
@@ -555,7 +555,7 @@
 
 int interface_jtag_add_plain_ir_scan(int num_fields, scan_field_t *fields, enum tap_state state)
 {
-	scanFields(num_fields, fields, TAP_SI, 1);
+	scanFields(num_fields, fields, TAP_IRSHIFT, 1);
 	gotoEndState();
 
 	return ERROR_OK;
@@ -580,7 +580,7 @@
 			{
 				found = 1;
 
-				scanFields(1, fields+j, TAP_SD, pause);
+				scanFields(1, fields+j, TAP_DRSHIFT, pause);
 			}
 		}
 		if (!found)
@@ -596,7 +596,7 @@
 			tmp.in_handler = NULL;
 			tmp.in_handler_priv = NULL;
 
-			scanFields(1, &amp;tmp, TAP_SD, pause);
+			scanFields(1, &amp;tmp, TAP_DRSHIFT, pause);
 		}
 		else
 		{
@@ -608,7 +608,7 @@
 
 int interface_jtag_add_plain_dr_scan(int num_fields, scan_field_t *fields, enum tap_state state)
 {
-	scanFields(num_fields, fields, TAP_SD, 1);
+	scanFields(num_fields, fields, TAP_DRSHIFT, 1);
 	gotoEndState();
 	return ERROR_OK;
 }
@@ -616,7 +616,7 @@
 
 int interface_jtag_add_tlr()
 {
-	setCurrentState(TAP_TLR);
+	setCurrentState(TAP_RESET);
 	return ERROR_OK;
 }
 
@@ -635,7 +635,7 @@
 int interface_jtag_add_runtest(int num_cycles, enum tap_state state)
 {
 	/* num_cycles can be 0 */
-	setCurrentState(TAP_RTI);
+	setCurrentState(TAP_IDLE);
 
 	/* execute num_cycles, 32 at the time. */
 	int i;
@@ -647,14 +647,14 @@
 		{
 			num=num_cycles-i;
 		}
-		shiftValueInner(TAP_RTI, TAP_RTI, num, 0);
+		shiftValueInner(TAP_IDLE, TAP_IDLE, num, 0);
 	}
 
 #if !TEST_MANUAL()
 	/* finish in end_state */
 	setCurrentState(state);
 #else
-	enum tap_state t=TAP_RTI;
+	enum tap_state t=TAP_IDLE;
 	/* test manual drive code on any target */
 	int tms;
 	u8 tms_scan = TAP_MOVE(t, state);
@@ -734,8 +734,8 @@
 			int i;
 			for (i = 0; i &lt; count; i++)
 			{
-				shiftValueInner(TAP_SD, TAP_SD, 32, fast_target_buffer_get_u32(buffer, 1));
-				shiftValueInner(TAP_SD, end_state, 6, reg_addr|(1&lt;&lt;5));
+				shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, 1));
+				shiftValueInner(TAP_DRSHIFT, end_state, 6, reg_addr|(1&lt;&lt;5));
 				buffer+=4;
 			}
 		} else
@@ -743,8 +743,8 @@
 			int i;
 			for (i = 0; i &lt; count; i++)
 			{
-				shiftValueInner(TAP_SD, TAP_SD, 32, fast_target_buffer_get_u32(buffer, 0));
-				shiftValueInner(TAP_SD, end_state, 6, reg_addr|(1&lt;&lt;5));
+				shiftValueInner(TAP_DRSHIFT, TAP_DRSHIFT, 32, fast_target_buffer_get_u32(buffer, 0));
+				shiftValueInner(TAP_DRSHIFT, end_state, 6, reg_addr|(1&lt;&lt;5));
 				buffer+=4;
 			}
 		}

Modified: trunk/src/pld/virtex2.c
===================================================================
--- trunk/src/pld/virtex2.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/pld/virtex2.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -63,7 +63,7 @@
 		field.in_handler = NULL;
 		field.in_handler_priv = NULL;
 
-		jtag_add_ir_scan(1, &amp;field, TAP_RTI);
+		jtag_add_ir_scan(1, &amp;field, TAP_IDLE);
 
 		free(field.out_value);
 	}
@@ -95,7 +95,7 @@
 
 	virtex2_set_instr(virtex2_info-&gt;tap, 0x5); /* CFG_IN */
 
-	jtag_add_dr_scan(1, &amp;scan_field, TAP_PD);
+	jtag_add_dr_scan(1, &amp;scan_field, TAP_DRPAUSE);
 
 	free(values);
 
@@ -128,7 +128,7 @@
 	while (num_words--)
 	{
 		scan_field.in_handler_priv = words++;
-		jtag_add_dr_scan(1, &amp;scan_field, TAP_PD);
+		jtag_add_dr_scan(1, &amp;scan_field, TAP_DRPAUSE);
 	}
 
 	return ERROR_OK;
@@ -176,7 +176,7 @@
 	if ((retval = xilinx_read_bit_file(&amp;bit_file, filename)) != ERROR_OK)
 		return retval;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	virtex2_set_instr(virtex2_info-&gt;tap, 0xb); /* JPROG_B */
 	jtag_execute_queue();
 	jtag_add_sleep(1000);
@@ -190,18 +190,18 @@
 	field.num_bits = bit_file.length * 8;
 	field.out_value = bit_file.data;
 
-	jtag_add_dr_scan(1, &amp;field, TAP_PD);
+	jtag_add_dr_scan(1, &amp;field, TAP_DRPAUSE);
 	jtag_execute_queue();
 
 	jtag_add_tlr();
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	virtex2_set_instr(virtex2_info-&gt;tap, 0xc); /* JSTART */
-	jtag_add_runtest(13, TAP_RTI);
+	jtag_add_runtest(13, TAP_IDLE);
 	virtex2_set_instr(virtex2_info-&gt;tap, 0x3f); /* BYPASS */
 	virtex2_set_instr(virtex2_info-&gt;tap, 0x3f); /* BYPASS */
 	virtex2_set_instr(virtex2_info-&gt;tap, 0xc); /* JSTART */
-	jtag_add_runtest(13, TAP_RTI);
+	jtag_add_runtest(13, TAP_IDLE);
 	virtex2_set_instr(virtex2_info-&gt;tap, 0x3f); /* BYPASS */
 	jtag_execute_queue();
 

Modified: trunk/src/target/arm11.c
===================================================================
--- trunk/src/target/arm11.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm11.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -393,7 +393,7 @@
 	arm11_setup_field(arm11,  1, NULL, NULL,	chain5_fields + 1);
 	arm11_setup_field(arm11,  1, NULL, NULL,	chain5_fields + 2);
 
-	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_PD);
+	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 	else
 	{
@@ -627,7 +627,7 @@
 	arm11_setup_field(arm11,  1, &amp;Ready,	NULL, chain5_fields + 1);
 	arm11_setup_field(arm11,  1, &amp;Valid,	NULL, chain5_fields + 2);
 
-	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_PD);
+	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 
 	arm11_record_register_history(arm11);
@@ -735,7 +735,7 @@
 	return ERROR_OK;
 	}
 
-	arm11_add_IR(arm11, ARM11_HALT, TAP_RTI);
+	arm11_add_IR(arm11, ARM11_HALT, TAP_IDLE);
 
 	if((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -841,7 +841,7 @@
 
 	arm11_leave_debug_state(arm11);
 
-	arm11_add_IR(arm11, ARM11_RESTART, TAP_RTI);
+	arm11_add_IR(arm11, ARM11_RESTART, TAP_IDLE);
 
 	if((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -956,7 +956,7 @@
 
 	arm11_leave_debug_state(arm11);
 
-	arm11_add_IR(arm11, ARM11_RESTART, TAP_RTI);
+	arm11_add_IR(arm11, ARM11_RESTART, TAP_IDLE);
 
 	if((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -1571,7 +1571,7 @@
 
 	arm11_setup_field(arm11, 32, NULL, &amp;arm11-&gt;device_id, &amp;idcode_field);
 
-	arm11_add_dr_scan_vc(1, &amp;idcode_field, TAP_PD);
+	arm11_add_dr_scan_vc(1, &amp;idcode_field, TAP_DRPAUSE);
 
 	/* check DIDR */
 
@@ -1584,7 +1584,7 @@
 	arm11_setup_field(arm11, 32, NULL,	&amp;arm11-&gt;didr,		chain0_fields + 0);
 	arm11_setup_field(arm11,  8, NULL,	&amp;arm11-&gt;implementor,	chain0_fields + 1);
 
-	arm11_add_dr_scan_vc(asizeof(chain0_fields), chain0_fields, TAP_RTI);
+	arm11_add_dr_scan_vc(asizeof(chain0_fields), chain0_fields, TAP_IDLE);
 
 	if ((retval=jtag_execute_queue())!=ERROR_OK)
 		return retval;
@@ -1832,7 +1832,7 @@
 {
 	jtag_tap_t *tap;
 	target_t * t;
-	
+
 	tap = jtag_TapByString( arg );
 	if( !tap ){
 		return NULL;

Modified: trunk/src/target/arm11_dbgtap.c
===================================================================
--- trunk/src/target/arm11_dbgtap.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm11_dbgtap.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -38,13 +38,13 @@
 
 enum tap_state arm11_move_pi_to_si_via_ci[] =
 {
-    TAP_E2I, TAP_UI, TAP_SDS, TAP_SIS, TAP_CI, TAP_SI
+    TAP_IREXIT2, TAP_IRUPDATE, TAP_DRSELECT, TAP_IRSELECT, TAP_IRCAPTURE, TAP_IRSHIFT
 };
 
 
 int arm11_add_ir_scan_vc(int num_fields, scan_field_t *fields, enum tap_state state)
 {
-    if (cmd_queue_cur_state == TAP_PI)
+    if (cmd_queue_cur_state == TAP_IRPAUSE)
 	jtag_add_pathmove(asizeof(arm11_move_pi_to_si_via_ci), arm11_move_pi_to_si_via_ci);
 
     jtag_add_ir_scan(num_fields, fields, state);
@@ -53,12 +53,12 @@
 
 enum tap_state arm11_move_pd_to_sd_via_cd[] =
 {
-    TAP_E2D, TAP_UD, TAP_SDS, TAP_CD, TAP_SD
+    TAP_DREXIT2, TAP_DRUPDATE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };
 
 int arm11_add_dr_scan_vc(int num_fields, scan_field_t *fields, enum tap_state state)
 {
-    if (cmd_queue_cur_state == TAP_PD)
+    if (cmd_queue_cur_state == TAP_DRPAUSE)
 	jtag_add_pathmove(asizeof(arm11_move_pd_to_sd_via_cd), arm11_move_pd_to_sd_via_cd);
 
     jtag_add_dr_scan(num_fields, fields, state);
@@ -104,7 +104,7 @@
 	jtag_tap_t *tap;
 	tap = arm11-&gt;jtag_info.tap;
 	if(  tap == NULL ){
-    	/* FIX!!!! error is logged, but not propagated back up the call stack... */
+	/* FIX!!!! error is logged, but not propagated back up the call stack... */
 		LOG_ERROR( &quot;tap is null here! This is bad!&quot;);
 		return;
     }
@@ -120,7 +120,7 @@
 
     arm11_setup_field(arm11, 5, &amp;instr, NULL, &amp;field);
 
-    arm11_add_ir_scan_vc(1, &amp;field, state == -1 ? TAP_PI : state);
+    arm11_add_ir_scan_vc(1, &amp;field, state == -1 ? TAP_IRPAUSE : state);
 }
 
 /** Verify shifted out data from Scan Chain Register (SCREG)
@@ -135,8 +135,8 @@
 
     if (v != 0x10)
     {
-        LOG_ERROR(&quot;'arm11 target' JTAG communication error SCREG SCAN OUT 0x%02x (expected 0x10)&quot;, v);
-        return ERROR_FAIL;
+	LOG_ERROR(&quot;'arm11 target' JTAG communication error SCREG SCAN OUT 0x%02x (expected 0x10)&quot;, v);
+	return ERROR_FAIL;
     }
 
     JTAG_DEBUG(&quot;SCREG SCAN OUT 0x%02x&quot;, v);
@@ -179,7 +179,7 @@
 
     field.in_handler = arm11_in_handler_SCAN_N;
 
-    arm11_add_dr_scan_vc(1, &amp;field, state == -1 ? TAP_PD : state);
+    arm11_add_dr_scan_vc(1, &amp;field, state == -1 ? TAP_DRPAUSE : state);
 }
 
 /** Write an instruction into the ITR register
@@ -194,7 +194,7 @@
  * \remarks By default this ends with Run-Test/Idle state
  * and causes the instruction to be executed. If
  * a subsequent write to DTR is needed before
- * executing the instruction then TAP_PD should be
+ * executing the instruction then TAP_DRPAUSE should be
  * passed to \p state.
  *
  * \remarks This adds to the JTAG command queue but does \em not execute it.
@@ -208,7 +208,7 @@
     arm11_setup_field(arm11, 32,    &amp;inst,	NULL, itr + 0);
     arm11_setup_field(arm11, 1,	    NULL,	flag, itr + 1);
 
-    arm11_add_dr_scan_vc(asizeof(itr), itr, state == -1 ? TAP_RTI : state);
+    arm11_add_dr_scan_vc(asizeof(itr), itr, state == -1 ? TAP_IDLE : state);
 }
 
 /** Read the Debug Status and Control Register (DSCR)
@@ -231,12 +231,12 @@
 
     arm11_setup_field(arm11, 32, NULL, &amp;dscr, &amp;chain1_field);
 
-    arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_PD);
+    arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
 
     jtag_execute_queue();
 
     if (arm11-&gt;last_dscr != dscr)
-        JTAG_DEBUG(&quot;DSCR  = %08x (OLD %08x)&quot;, dscr, arm11-&gt;last_dscr);
+	JTAG_DEBUG(&quot;DSCR  = %08x (OLD %08x)&quot;, dscr, arm11-&gt;last_dscr);
 
     arm11-&gt;last_dscr = dscr;
 
@@ -262,7 +262,7 @@
 
     arm11_setup_field(arm11, 32, &amp;dscr, NULL, &amp;chain1_field);
 
-    arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_PD);
+    arm11_add_dr_scan_vc(1, &amp;chain1_field, TAP_DRPAUSE);
 
     jtag_execute_queue();
 
@@ -369,13 +369,13 @@
 
     while (count--)
     {
-	arm11_add_debug_INST(arm11, *opcode++, NULL, TAP_RTI);
+	arm11_add_debug_INST(arm11, *opcode++, NULL, TAP_IDLE);
 
 	while (1)
 	{
 	    u8 flag;
 
-	    arm11_add_debug_INST(arm11, 0, &amp;flag, count ? TAP_RTI : TAP_PD);
+	    arm11_add_debug_INST(arm11, 0, &amp;flag, count ? TAP_IDLE : TAP_DRPAUSE);
 
 	    jtag_execute_queue();
 
@@ -416,7 +416,7 @@
 {
     arm11_add_IR(arm11, ARM11_ITRSEL, -1);
 
-    arm11_add_debug_INST(arm11, opcode, NULL, TAP_PD);
+    arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
 
     arm11_add_IR(arm11, ARM11_EXTEST, -1);
 
@@ -436,7 +436,7 @@
 	{
 	    Data	    = *data;
 
-	    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_RTI);
+	    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_IDLE);
 	    jtag_execute_queue();
 
 	    JTAG_DEBUG(&quot;DTR  Ready %d  nRetry %d&quot;, Ready, nRetry);
@@ -452,7 +452,7 @@
     {
 	Data	    = 0;
 
-	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_PD);
+	arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	jtag_execute_queue();
 
 	JTAG_DEBUG(&quot;DTR  Data %08x  Ready %d  nRetry %d&quot;, Data, Ready, nRetry);
@@ -462,18 +462,18 @@
 
 /** JTAG path for arm11_run_instr_data_to_core_noack
  *
- *  The repeated TAP_RTI's do not cause a repeated execution
+ *  The repeated TAP_IDLE's do not cause a repeated execution
  *  if passed without leaving the state.
  *
  *  Since this is more than 7 bits (adjustable via adding more
- *  TAP_RTI's) it produces an artificial delay in the lower
+ *  TAP_IDLE's) it produces an artificial delay in the lower
  *  layer (FT2232) that is long enough to finish execution on
  *  the core but still shorter than any manually inducible delays.
  *
  */
 enum tap_state arm11_MOVE_PD_RTI_PD_with_delay[] =
 {
-    TAP_E2D, TAP_UD, TAP_RTI, TAP_RTI, TAP_RTI, TAP_SDS, TAP_CD, TAP_SD
+    TAP_DREXIT2, TAP_DRUPDATE, TAP_IDLE, TAP_IDLE, TAP_IDLE, TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT
 };
 
 
@@ -497,7 +497,7 @@
 {
     arm11_add_IR(arm11, ARM11_ITRSEL, -1);
 
-    arm11_add_debug_INST(arm11, opcode, NULL, TAP_PD);
+    arm11_add_debug_INST(arm11, opcode, NULL, TAP_DRPAUSE);
 
     arm11_add_IR(arm11, ARM11_EXTEST, -1);
 
@@ -517,13 +517,13 @@
 
 	if (count)
 	{
-	    jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_PD);
+	    jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 	    jtag_add_pathmove(asizeof(arm11_MOVE_PD_RTI_PD_with_delay),
 		arm11_MOVE_PD_RTI_PD_with_delay);
 	}
 	else
 	{
-	    jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_RTI);
+	    jtag_add_dr_scan(asizeof(chain5_fields), chain5_fields, TAP_IDLE);
 	}
     }
 
@@ -532,7 +532,7 @@
     chain5_fields[0].out_value	= 0;
     chain5_fields[1].in_value   = ReadyPos++;
 
-    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_PD);
+    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, TAP_DRPAUSE);
 
     jtag_execute_queue();
 
@@ -586,7 +586,7 @@
 {
     arm11_add_IR(arm11, ARM11_ITRSEL, -1);
 
-    arm11_add_debug_INST(arm11, opcode, NULL, TAP_RTI);
+    arm11_add_debug_INST(arm11, opcode, NULL, TAP_IDLE);
 
     arm11_add_IR(arm11, ARM11_INTEST, -1);
 
@@ -604,7 +604,7 @@
     {
 	do
 	{
-	    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, count ? TAP_RTI : TAP_PD);
+	    arm11_add_dr_scan_vc(asizeof(chain5_fields), chain5_fields, count ? TAP_IDLE : TAP_DRPAUSE);
 	    jtag_execute_queue();
 
 	    JTAG_DEBUG(&quot;DTR  Data %08x  Ready %d  nRetry %d&quot;, Data, Ready, nRetry);
@@ -699,11 +699,11 @@
 	    AddressOut	= 0;
 	}
 
-        do
+	do
 	{
 	    JTAG_DEBUG(&quot;SC7 &lt;= Address %02x  Data %08x    nRW %d&quot;, AddressOut, DataOut, nRW);
 
-	    arm11_add_dr_scan_vc(asizeof(chain7_fields), chain7_fields, TAP_PD);
+	    arm11_add_dr_scan_vc(asizeof(chain7_fields), chain7_fields, TAP_DRPAUSE);
 	    jtag_execute_queue();
 
 	    JTAG_DEBUG(&quot;SC7 =&gt; Address %02x  Data %08x  Ready %d&quot;, AddressIn, DataIn, Ready);

Modified: trunk/src/target/arm720t.c
===================================================================
--- trunk/src/target/arm720t.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm720t.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -64,7 +64,7 @@
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm720t_soft_reset_halt,
-	
+
 	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
 
 	.read_memory = arm720t_read_memory,
@@ -72,7 +72,7 @@
 	.bulk_write_memory = arm7_9_bulk_write_memory,
 	.checksum_memory = arm7_9_checksum_memory,
 	.blank_check_memory = arm7_9_blank_check_memory,
-	
+
 	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
@@ -96,10 +96,10 @@
 	scan_field_t fields[2];
 	u8 out_buf[4];
 	u8 instruction_buf = instruction;
-	
+
 	buf_set_u32(out_buf, 0, 32, flip_u32(out, 32));
-	
-	jtag_add_end_state(TAP_PD);
+
+	jtag_add_end_state(TAP_DRPAUSE);
 	if((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
 	{
 		return retval;
@@ -108,7 +108,7 @@
 	{
 		return retval;
 	}
-		
+
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = &amp;instruction_buf;
@@ -135,7 +135,7 @@
 	}
 	fields[1].in_check_value = NULL;
 	fields[1].in_check_mask = NULL;
-	
+
 	jtag_add_dr_scan(2, fields, -1);
 
 	if (clock)
@@ -171,7 +171,7 @@
 	arm720t_scan_cp15(target, 0x0, NULL, 0, 1);
 	/* &quot;EXECUTE&quot; stage (3), CDATA is read */
 	arm720t_scan_cp15(target, ARMV4_5_NOP, value, 1, 1);
-	
+
 	return ERROR_OK;
 }
 
@@ -197,9 +197,9 @@
 
 	arm720t_read_cp15(target, 0xee120f10, &amp;ttb);
 	jtag_execute_queue();
-	
+
 	ttb &amp;= 0xffffc000;
-	
+
 	return ttb;
 }
 
@@ -210,10 +210,10 @@
 	/* read cp15 control register */
 	arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
 	jtag_execute_queue();
-		
+
 	if (mmu)
 		cp15_control &amp;= ~0x1U;
-	
+
 	if (d_u_cache || i_cache)
 		cp15_control &amp;= ~0x4U;
 
@@ -227,13 +227,13 @@
 	/* read cp15 control register */
 	arm720t_read_cp15(target, 0xee110f10, &amp;cp15_control);
 	jtag_execute_queue();
-		
+
 	if (mmu)
 		cp15_control |= 0x1U;
-	
+
 	if (d_u_cache || i_cache)
 		cp15_control |= 0x4U;
-	
+
 	arm720t_write_cp15(target, 0xee010f10, cp15_control);
 }
 
@@ -243,7 +243,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm7tdmi_common_t *arm7tdmi = arm7_9-&gt;arch_info;
 	arm720t_common_t *arm720t = arm7tdmi-&gt;arch_info;
-	
+
 	/* examine cp15 control reg */
 	arm720t_read_cp15(target, 0xee110f10, &amp;arm720t-&gt;cp15_control_reg);
 	jtag_execute_queue();
@@ -265,7 +265,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm7tdmi_common_t *arm7tdmi = arm7_9-&gt;arch_info;
 	arm720t_common_t *arm720t = arm7tdmi-&gt;arch_info;
-	
+
 	/* restore i/d fault status and address register */
 	arm720t_write_cp15(target, 0xee050f10, arm720t-&gt;fsr_reg);
 	arm720t_write_cp15(target, 0xee060f10, arm720t-&gt;far_reg);
@@ -277,35 +277,35 @@
 	arm7_9_common_t *arm7_9;
 	arm7tdmi_common_t *arm7tdmi;
 	arm720t_common_t *arm720t;
-	
+
 	if (armv4_5-&gt;common_magic != ARMV4_5_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm7_9 = armv4_5-&gt;arch_info;
 	if (arm7_9-&gt;common_magic != ARM7_9_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm7tdmi = arm7_9-&gt;arch_info;
 	if (arm7tdmi-&gt;common_magic != ARM7TDMI_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm720t = arm7tdmi-&gt;arch_info;
 	if (arm720t-&gt;common_magic != ARM720T_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	*armv4_5_p = armv4_5;
 	*arm7_9_p = arm7_9;
 	*arm7tdmi_p = arm7tdmi;
 	*arm720t_p = arm720t;
-	
+
 	return ERROR_OK;
 }
 
@@ -315,18 +315,18 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm7tdmi_common_t *arm7tdmi = arm7_9-&gt;arch_info;
 	arm720t_common_t *arm720t = arm7tdmi-&gt;arch_info;
-	
-	char *state[] = 
+
+	char *state[] =
 	{
 		&quot;disabled&quot;, &quot;enabled&quot;
 	};
-	
+
 	if (armv4_5-&gt;common_magic != ARMV4_5_COMMON_MAGIC)
 	{
 		LOG_ERROR(&quot;BUG: called for a non-ARMv4/5 target&quot;);
 		exit(-1);
 	}
-	
+
 	LOG_USER(&quot;target halted in %s state due to %s, current mode: %s\n&quot;
 			&quot;cpsr: 0x%8.8x pc: 0x%8.8x\n&quot;
 			&quot;MMU: %s, Cache: %s&quot;,
@@ -337,7 +337,7 @@
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32),
 			 state[arm720t-&gt;armv4_5_mmu.mmu_enabled],
 			 state[arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled]);
-	
+
 	return ERROR_OK;
 }
 
@@ -348,23 +348,23 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm7tdmi_common_t *arm7tdmi = arm7_9-&gt;arch_info;
 	arm720t_common_t *arm720t = arm7tdmi-&gt;arch_info;
-	
+
 	/* disable cache, but leave MMU enabled */
 	if (arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		arm720t_disable_mmu_caches(target, 0, 1, 0);
-	
+
 	retval = arm7_9_read_memory(target, address, size, count, buffer);
-	
+
 	if (arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled)
 		arm720t_enable_mmu_caches(target, 0, 1, 0);
-	
+
 	return retval;
 }
 
 int arm720t_write_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
 {
 	int retval;
-	
+
 	if ((retval = arm7_9_write_memory(target, address, size, count, buffer)) != ERROR_OK)
 		return retval;
 
@@ -379,12 +379,12 @@
 	arm7tdmi_common_t *arm7tdmi = arm7_9-&gt;arch_info;
 	arm720t_common_t *arm720t = arm7tdmi-&gt;arch_info;
 	reg_t *dbg_stat = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_STAT];
-	
+
 	if ((retval = target_halt(target)) != ERROR_OK)
 	{
 		return retval;
 	}
-	
+
 	long long then=timeval_ms();
 	int timeout;
 	while (!(timeout=((timeval_ms()-then)&gt;1000)))
@@ -413,22 +413,22 @@
 		LOG_ERROR(&quot;Failed to halt CPU after 1 sec&quot;);
 		return ERROR_TARGET_TIMEOUT;
 	}
-	
+
 	target-&gt;state = TARGET_HALTED;
-	
+
 	/* SVC, ARM state, IRQ and FIQ disabled */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8, 0xd3);
 	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
-	
+
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
 	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
-	
+
 	armv4_5-&gt;core_mode = ARMV4_5_MODE_SVC;
 	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-	
+
 	arm720t_disable_mmu_caches(target, 1, 1, 1);
 	arm720t-&gt;armv4_5_mmu.mmu_enabled = 0;
 	arm720t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
@@ -438,21 +438,21 @@
 	{
 		return retval;
 	}
-	
+
 	return ERROR_OK;
 }
 
 int arm720t_init_target(struct command_context_s *cmd_ctx, struct target_s *target)
 {
 	arm7tdmi_init_target(cmd_ctx, target);
-		
+
 	return ERROR_OK;
-	
+
 }
 
 int arm720t_quit(void)
 {
-	
+
 	return ERROR_OK;
 }
 
@@ -460,15 +460,15 @@
 {
 	arm7tdmi_common_t *arm7tdmi = &amp;arm720t-&gt;arm7tdmi_common;
 	arm7_9_common_t *arm7_9 = &amp;arm7tdmi-&gt;arm7_9_common;
-	
+
 	arm7tdmi_init_arch_info(target, arm7tdmi, tap, variant);
 
 	arm7tdmi-&gt;arch_info = arm720t;
 	arm720t-&gt;common_magic = ARM720T_COMMON_MAGIC;
-	
+
 	arm7_9-&gt;post_debug_entry = arm720t_post_debug_entry;
 	arm7_9-&gt;pre_restore_context = arm720t_pre_restore_context;
-	
+
 	arm720t-&gt;armv4_5_mmu.armv4_5_cache.ctype = -1;
 	arm720t-&gt;armv4_5_mmu.get_ttb = arm720t_get_ttb;
 	arm720t-&gt;armv4_5_mmu.read_memory = arm7_9_read_memory;
@@ -477,14 +477,14 @@
 	arm720t-&gt;armv4_5_mmu.enable_mmu_caches = arm720t_enable_mmu_caches;
 	arm720t-&gt;armv4_5_mmu.has_tiny_pages = 0;
 	arm720t-&gt;armv4_5_mmu.mmu_enabled = 0;
-	
+
 	return ERROR_OK;
 }
 
 int arm720t_target_create(struct target_s *target, Jim_Interp *interp)
 {
 	arm720t_common_t *arm720t = calloc(1,sizeof(arm720t_common_t));
-	
+
 	arm720t_init_arch_info(target, arm720t, target-&gt;tap, target-&gt;variant);
 
 	return ERROR_OK;
@@ -494,10 +494,10 @@
 {
 	int retval;
 	command_t *arm720t_cmd;
-	
-		
+
+
 	retval = arm7tdmi_register_commands(cmd_ctx);
-	
+
 	arm720t_cmd = register_command(cmd_ctx, NULL, &quot;arm720t&quot;, NULL, COMMAND_ANY, &quot;arm720t specific commands&quot;);
 
 	register_command(cmd_ctx, arm720t_cmd, &quot;cp15&quot;, arm720t_handle_cp15_command, COMMAND_EXEC, &quot;display/modify cp15 register &lt;opcode&gt; [value]&quot;);
@@ -510,7 +510,7 @@
 	register_command(cmd_ctx, arm720t_cmd, &quot;mww_phys&quot;, arm720t_handle_mw_phys_command, COMMAND_EXEC, &quot;write memory word &lt;physical addr&gt; &lt;value&gt;&quot;);
 	register_command(cmd_ctx, arm720t_cmd, &quot;mwh_phys&quot;, arm720t_handle_mw_phys_command, COMMAND_EXEC, &quot;write memory half-word &lt;physical addr&gt; &lt;value&gt;&quot;);
 	register_command(cmd_ctx, arm720t_cmd, &quot;mwb_phys&quot;, arm720t_handle_mw_phys_command, COMMAND_EXEC, &quot;write memory byte &lt;physical addr&gt; &lt;value&gt;&quot;);
-	
+
 	return ERROR_OK;
 }
 
@@ -529,9 +529,9 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM720t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
@@ -556,7 +556,7 @@
 			{
 				return retval;
 			}
-			
+
 			command_print(cmd_ctx, &quot;0x%8.8x: 0x%8.8x&quot;, opcode, value);
 		}
 		else if (argc == 2)
@@ -575,7 +575,7 @@
 }
 
 int arm720t_handle_virt2phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
-{	
+{
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -588,20 +588,20 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM720t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
 		return ERROR_OK;
 	}
-		
+
 	return armv4_5_mmu_handle_virt2phys_command(cmd_ctx, cmd, args, argc, target, &amp;arm720t-&gt;armv4_5_mmu);
 }
 
 int arm720t_handle_md_phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
-{	
+{
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -614,20 +614,20 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM720t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
 		return ERROR_OK;
 	}
-	
+
 	return armv4_5_mmu_handle_md_phys_command(cmd_ctx, cmd, args, argc, target, &amp;arm720t-&gt;armv4_5_mmu);
 }
 
 int arm720t_handle_mw_phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
-{	
+{
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -640,14 +640,14 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM720t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
 		return ERROR_OK;
 	}
-	
+
 	return armv4_5_mmu_handle_mw_phys_command(cmd_ctx, cmd, args, argc, target, &amp;arm720t-&gt;armv4_5_mmu);
 }

Modified: trunk/src/target/arm7_9_common.c
===================================================================
--- trunk/src/target/arm7_9_common.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm7_9_common.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -584,7 +584,7 @@
 	reg_t *dbg_stat = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_STAT];
 
 	/* set RESTART instruction */
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	if (arm7_9-&gt;need_bypass_before_restart) {
 		arm7_9-&gt;need_bypass_before_restart = 0;
 		arm_jtag_set_instr(jtag_info, 0xf, NULL);
@@ -630,7 +630,7 @@
 	reg_t *dbg_stat = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_STAT];
 
 	/* set RESTART instruction */
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	if (arm7_9-&gt;need_bypass_before_restart) {
 		arm7_9-&gt;need_bypass_before_restart = 0;
 		arm_jtag_set_instr(jtag_info, 0xf, NULL);
@@ -1492,14 +1492,14 @@
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 
 	/* set RESTART instruction */
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	if (arm7_9-&gt;need_bypass_before_restart) {
 		arm7_9-&gt;need_bypass_before_restart = 0;
 		arm_jtag_set_instr(jtag_info, 0xf, NULL);
 	}
 	arm_jtag_set_instr(jtag_info, 0x4, NULL);
 
-	jtag_add_runtest(1, TAP_RTI);
+	jtag_add_runtest(1, TAP_IDLE);
 	return jtag_execute_queue();
 }
 

Modified: trunk/src/target/arm7tdmi.c
===================================================================
--- trunk/src/target/arm7tdmi.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm7tdmi.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -55,7 +55,7 @@
 /* target function declarations */
 int arm7tdmi_poll(struct target_s *target);
 int arm7tdmi_halt(target_t *target);
-		
+
 target_type_t arm7tdmi_target =
 {
 	.name = &quot;arm7tdmi&quot;,
@@ -74,15 +74,15 @@
 	.soft_reset_halt = arm7_9_soft_reset_halt,
 
 	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
-	
+
 	.read_memory = arm7_9_read_memory,
 	.write_memory = arm7_9_write_memory,
 	.bulk_write_memory = arm7_9_bulk_write_memory,
 	.checksum_memory = arm7_9_checksum_memory,
 	.blank_check_memory = arm7_9_blank_check_memory,
-	
+
 	.run_algorithm = armv4_5_run_algorithm,
-	
+
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
 	.add_watchpoint = arm7_9_add_watchpoint,
@@ -101,7 +101,7 @@
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
-	
+
 	/* only check the debug reason if we don't know it already */
 	if ((target-&gt;debug_reason != DBG_REASON_DBGRQ)
 			&amp;&amp; (target-&gt;debug_reason != DBG_REASON_SINGLESTEP))
@@ -109,9 +109,9 @@
 		scan_field_t fields[2];
 		u8 databus[4];
 		u8 breakpoint;
-		
-		jtag_add_end_state(TAP_PD);
 
+		jtag_add_end_state(TAP_DRPAUSE);
+
 		fields[0].tap = arm7_9-&gt;jtag_info.tap;
 		fields[0].num_bits = 1;
 		fields[0].out_value = NULL;
@@ -121,7 +121,7 @@
 		fields[0].in_check_mask = NULL;
 		fields[0].in_handler = NULL;
 		fields[0].in_handler_priv = NULL;
-		
+
 		fields[1].tap = arm7_9-&gt;jtag_info.tap;
 		fields[1].num_bits = 32;
 		fields[1].out_value = NULL;
@@ -131,30 +131,30 @@
 		fields[1].in_check_mask = NULL;
 		fields[1].in_handler = NULL;
 		fields[1].in_handler_priv = NULL;
-		
+
 		if((retval = arm_jtag_scann(&amp;arm7_9-&gt;jtag_info, 0x1)) != ERROR_OK)
 		{
 			return retval;
 		}
 		arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(2, fields, TAP_PD);
+		jtag_add_dr_scan(2, fields, TAP_DRPAUSE);
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		fields[0].in_value = NULL;
 		fields[0].out_value = &breakpoint;
 		fields[1].in_value = NULL;
 		fields[1].out_value = databus;
-		
-		jtag_add_dr_scan(2, fields, TAP_PD);
 
+		jtag_add_dr_scan(2, fields, TAP_DRPAUSE);
+
 		if (breakpoint &amp; 1)
-			target-&gt;debug_reason = DBG_REASON_WATCHPOINT; 
+			target-&gt;debug_reason = DBG_REASON_WATCHPOINT;
 		else
-			target-&gt;debug_reason = DBG_REASON_BREAKPOINT; 
+			target-&gt;debug_reason = DBG_REASON_BREAKPOINT;
 	}
 
 	return ERROR_OK;
@@ -164,13 +164,13 @@
 static __inline int arm7tdmi_clock_out_inner(arm_jtag_t *jtag_info, u32 out, int breakpoint)
 {
 	u32 values[2]={breakpoint, flip_u32(out, 32)};
-			
+
 	jtag_add_dr_out(jtag_info-&gt;tap,
 			2,
 			arm7tdmi_num_bits,
 			values,
 			-1);
-			
+
 	jtag_add_runtest(0, -1);
 
 	return ERROR_OK;
@@ -179,10 +179,10 @@
 /* put an instruction in the ARM7TDMI pipeline or write the data bus, and optionally read data */
 static __inline int arm7tdmi_clock_out(arm_jtag_t *jtag_info, u32 out, u32 *deprecated, int breakpoint)
 {
-	jtag_add_end_state(TAP_PD);
+	jtag_add_end_state(TAP_DRPAUSE);
 	arm_jtag_scann(jtag_info, 0x1);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-	
+
 	return arm7tdmi_clock_out_inner(jtag_info, out, breakpoint);
 }
 
@@ -192,13 +192,13 @@
 	int retval = ERROR_OK;
 	scan_field_t fields[2];
 
-	jtag_add_end_state(TAP_PD);
+	jtag_add_end_state(TAP_DRPAUSE);
 	if((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
 	{
 		return retval;
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-	
+
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
@@ -208,7 +208,7 @@
 	fields[0].in_check_mask = NULL;
 	fields[0].in_handler = NULL;
 	fields[0].in_handler_priv = NULL;
-		
+
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
@@ -222,14 +222,14 @@
 	jtag_add_dr_scan(2, fields, -1);
 
 	jtag_add_runtest(0, -1);
-	
+
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 {
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-			
+
 		if (in)
 		{
 			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *in);
@@ -247,19 +247,19 @@
 /* clock the target, and read the databus
  * the *in pointer points to a buffer where elements of 'size' bytes
  * are stored in big (be==1) or little (be==0) endianness
- */ 
+ */
 int arm7tdmi_clock_data_in_endianness(arm_jtag_t *jtag_info, void *in, int size, int be)
 {
 	int retval = ERROR_OK;
 	scan_field_t fields[2];
 
-	jtag_add_end_state(TAP_PD);
+	jtag_add_end_state(TAP_DRPAUSE);
 	if((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
 	{
 		return retval;
 	}
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-	
+
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 1;
 	fields[0].out_value = NULL;
@@ -269,7 +269,7 @@
 	fields[0].in_check_mask = NULL;
 	fields[0].in_handler = NULL;
 	fields[0].in_handler_priv = NULL;
-		
+
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 32;
 	fields[1].out_value = NULL;
@@ -294,14 +294,14 @@
 	jtag_add_dr_scan(2, fields, -1);
 
 	jtag_add_runtest(0, -1);
-	
+
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 {
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-			
+
 		if (in)
 		{
 			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *(u32*)in);
@@ -322,10 +322,10 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
-	/* save r0 before using it and put system in ARM state 
+
+	/* save r0 before using it and put system in ARM state
 	 * to allow common handling of ARM and THUMB debugging */
-	
+
 	/* fetch STR r0, [r0] */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_STR(0, 0), NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
@@ -333,7 +333,7 @@
 	/* nothing fetched, STR r0, [r0] in Execute (2) */
 	arm7tdmi_clock_data_in(jtag_info, r0);
 
-	/* MOV r0, r15 fetched, STR in Decode */	
+	/* MOV r0, r15 fetched, STR in Decode */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_MOV(0, 15), NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_STR(0, 0), NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
@@ -349,22 +349,22 @@
 	arm7tdmi_clock_out(jtag_info, 0x0, NULL, 0);
 	/* nothing fetched, data from previous cycle is written to register */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
-	
+
 	/* fetch BX */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_BX(0), NULL, 0);
 	/* NOP fetched, BX in Decode, MOV in Execute */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
 	/* NOP fetched, BX in Execute (1) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
-	
+
 	jtag_execute_queue();
-	
+
 	/* fix program counter:
 	 * MOV r0, r15 was the 4th instruction (+6)
 	 * reading PC in Thumb state gives address of instruction + 4
 	 */
 	*pc -= 0xa;
-	
+
 }
 
 void arm7tdmi_read_core_regs(target_t *target, u32 mask, u32* core_regs[16])
@@ -374,7 +374,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	/* STMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
 	 */
@@ -405,7 +405,7 @@
 	u32 *buf_u32 = buffer;
 	u16 *buf_u16 = buffer;
 	u8 *buf_u8 = buffer;
-		
+
 	/* STMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
 	 */
@@ -435,7 +435,7 @@
 			}
 		}
 	}
-	
+
 }
 
 void arm7tdmi_read_xpsr(target_t *target, u32 *xpsr, int spsr)
@@ -444,10 +444,10 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	/* MRS r0, cpsr */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_MRS(0, spsr &amp; 1), NULL, 0);
-	
+
 	/* STR r0, [r15] */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_STR(0, 15), NULL, 0);
 	/* fetch NOP, STR in DECODE stage */
@@ -465,7 +465,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	LOG_DEBUG(&quot;xpsr: %8.8x, spsr: %i&quot;, xpsr, spsr);
 
 	/* MSR1 fetched */
@@ -496,9 +496,9 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	LOG_DEBUG(&quot;xpsr_im: %2.2x, rot: %i, spsr: %i&quot;, xpsr_im, rot, spsr);
-	
+
 	/* MSR fetched */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_MSR_IM(xpsr_im, rot, 1, spsr), NULL, 0);
 	/* NOP fetched, MSR in DECODE */
@@ -507,7 +507,7 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	/* nothing fetched, MSR in EXECUTE (2) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
-	
+
 }
 
 void arm7tdmi_write_core_regs(target_t *target, u32 mask, u32 core_regs[16])
@@ -517,7 +517,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	/* LDMIA r0-15, [r0] at debug speed
 	* register values will start to appear on 4th DCLK
 	*/
@@ -535,7 +535,7 @@
 			arm7tdmi_clock_out_inner(jtag_info, core_regs[i], 0);
 	}
 	arm7tdmi_clock_out_inner(jtag_info, ARMV4_5_NOP, 0);
-	
+
 }
 
 void arm7tdmi_load_word_regs(target_t *target, u32 mask)
@@ -558,7 +558,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	/* put system-speed load half-word into the pipeline */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
@@ -591,7 +591,7 @@
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_STMIA(0, mask, 0, 1), NULL, 0);
-	
+
 }
 
 void arm7tdmi_store_hword_reg(target_t *target, int num)
@@ -628,7 +628,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	/* LDMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
 	 */
@@ -655,7 +655,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 1);
 	arm7tdmi_clock_out_inner(jtag_info, ARMV4_5_B(0xfffffa, 0), 0);
 
@@ -664,7 +664,7 @@
 void arm7tdmi_branch_resume_thumb(target_t *target)
 {
 	LOG_DEBUG(&quot;-&quot;);
-	
+
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -687,15 +687,15 @@
 
 	/* Branch and eXchange */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_BX(0), NULL, 0);
-	
+
 	embeddedice_read_reg(dbg_stat);
-	
+
 	/* fetch NOP, BX in DECODE stage */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
-	
+
 	/* target is now in Thumb state */
 	embeddedice_read_reg(dbg_stat);
-	
+
 	/* fetch NOP, BX in EXECUTE stage (1st cycle) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_NOP, NULL, 0);
 
@@ -712,17 +712,17 @@
 	arm7tdmi_clock_out(jtag_info, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[0].value, 0, 32), NULL, 0);
 	/* nothing fetched, LDR in EXECUTE stage (3rd cycle) */
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
-	
+
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 0);
 
 	embeddedice_read_reg(dbg_stat);
-	
+
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, NULL, 1);
 	arm7tdmi_clock_out(jtag_info, ARMV4_5_T_B(0x7f8), NULL, 0);
 
 }
-		
+
 void arm7tdmi_build_reg_cache(target_t *target)
 {
 	reg_cache_t **cache_p = register_get_last_cache_p(&amp;target-&gt;reg_cache);
@@ -745,10 +745,10 @@
 		reg_cache_t *t=embeddedice_build_reg_cache(target, arm7_9);
 		if (t==NULL)
 			return ERROR_FAIL;
-		
+
 		(*cache_p) = t;
 		arm7_9-&gt;eice_cache = (*cache_p);
-		
+
 		if (arm7_9-&gt;etm_ctx)
 		{
 			arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
@@ -771,16 +771,16 @@
 
 int arm7tdmi_init_target(struct command_context_s *cmd_ctx, struct target_s *target)
 {
-	
+
 	arm7tdmi_build_reg_cache(target);
-	
+
 	return ERROR_OK;
-	
+
 }
 
 int arm7tdmi_quit(void)
 {
-	
+
 	return ERROR_OK;
 }
 
@@ -788,56 +788,56 @@
 {
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
-	
+
 	arm7_9 = &amp;arm7tdmi-&gt;arm7_9_common;
 	armv4_5 = &amp;arm7_9-&gt;armv4_5_common;
-	
+
 	/* prepare JTAG information for the new target */
 	arm7_9-&gt;jtag_info.tap = tap;
 	arm7_9-&gt;jtag_info.scann_size = 4;
-	
+
 	/* register arch-specific functions */
 	arm7_9-&gt;examine_debug_reason = arm7tdmi_examine_debug_reason;
 	arm7_9-&gt;change_to_arm = arm7tdmi_change_to_arm;
 	arm7_9-&gt;read_core_regs = arm7tdmi_read_core_regs;
 	arm7_9-&gt;read_core_regs_target_buffer = arm7tdmi_read_core_regs_target_buffer;
 	arm7_9-&gt;read_xpsr = arm7tdmi_read_xpsr;
-	
+
 	arm7_9-&gt;write_xpsr = arm7tdmi_write_xpsr;
 	arm7_9-&gt;write_xpsr_im8 = arm7tdmi_write_xpsr_im8;
 	arm7_9-&gt;write_core_regs = arm7tdmi_write_core_regs;
-	
+
 	arm7_9-&gt;load_word_regs = arm7tdmi_load_word_regs;
 	arm7_9-&gt;load_hword_reg = arm7tdmi_load_hword_reg;
 	arm7_9-&gt;load_byte_reg = arm7tdmi_load_byte_reg;
-	
+
 	arm7_9-&gt;store_word_regs = arm7tdmi_store_word_regs;
 	arm7_9-&gt;store_hword_reg = arm7tdmi_store_hword_reg;
 	arm7_9-&gt;store_byte_reg = arm7tdmi_store_byte_reg;
-	
+
 	arm7_9-&gt;write_pc = arm7tdmi_write_pc;
 	arm7_9-&gt;branch_resume = arm7tdmi_branch_resume;
 	arm7_9-&gt;branch_resume_thumb = arm7tdmi_branch_resume_thumb;
-	
+
 	arm7_9-&gt;enable_single_step = arm7_9_enable_eice_step;
 	arm7_9-&gt;disable_single_step = arm7_9_disable_eice_step;
-		
+
 	arm7_9-&gt;pre_debug_entry = NULL;
 	arm7_9-&gt;post_debug_entry = NULL;
-	
+
 	arm7_9-&gt;pre_restore_context = NULL;
 	arm7_9-&gt;post_restore_context = NULL;
-	
+
 	/* initialize arch-specific breakpoint handling */
 	arm7_9-&gt;arm_bkpt = 0xdeeedeee;
 	arm7_9-&gt;thumb_bkpt = 0xdeee;
-	
+
 	arm7_9-&gt;dbgreq_adjust_pc = 2;
 	arm7_9-&gt;arch_info = arm7tdmi;
 
 	arm7tdmi-&gt;arch_info = NULL;
 	arm7tdmi-&gt;common_magic = ARM7TDMI_COMMON_MAGIC;
-	
+
 	if (variant)
 	{
 		arm7tdmi-&gt;variant = strdup(variant);
@@ -846,7 +846,7 @@
 	{
 		arm7tdmi-&gt;variant = strdup(&quot;&quot;);
 	}
-	
+
 	arm7_9_init_arch_info(target, arm7_9);
 
 	return ERROR_OK;
@@ -857,11 +857,11 @@
 int arm7tdmi_target_create( struct target_s *target, Jim_Interp *interp )
 {
 	arm7tdmi_common_t *arm7tdmi;
-	
+
 	arm7tdmi = calloc(1,sizeof(arm7tdmi_common_t));
-	
+
 	arm7tdmi_init_arch_info(target, arm7tdmi, target-&gt;tap, target-&gt;variant);
-	
+
 	return ERROR_OK;
 }
 
@@ -869,9 +869,9 @@
 int arm7tdmi_register_commands(struct command_context_s *cmd_ctx)
 {
 	int retval;
-	
+
 	retval = arm7_9_register_commands(cmd_ctx);
-	
+
 	return retval;
 
 }

Modified: trunk/src/target/arm920t.c
===================================================================
--- trunk/src/target/arm920t.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm920t.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -73,7 +73,7 @@
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm920t_soft_reset_halt,
-	
+
 	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
 
 	.read_memory = arm920t_read_memory,
@@ -81,7 +81,7 @@
 	.bulk_write_memory = arm7_9_bulk_write_memory,
 	.checksum_memory = arm7_9_checksum_memory,
 	.blank_check_memory = arm7_9_blank_check_memory,
-	
+
 	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
@@ -105,8 +105,8 @@
 	u8 access_type_buf = 1;
 	u8 reg_addr_buf = reg_addr &amp; 0x3f;
 	u8 nr_w_buf = 0;
-	
-	jtag_add_end_state(TAP_RTI);
+
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
@@ -149,7 +149,7 @@
 	fields[3].in_check_mask = NULL;
 	fields[3].in_handler = NULL;
 	fields[3].in_handler_priv = NULL;
-	
+
 	jtag_add_dr_scan(4, fields, -1);
 
 	fields[1].in_handler_priv = value;
@@ -175,10 +175,10 @@
 	u8 reg_addr_buf = reg_addr &amp; 0x3f;
 	u8 nr_w_buf = 1;
 	u8 value_buf[4];
-	
+
 	buf_set_u32(value_buf, 0, 32, value);
-	
-	jtag_add_end_state(TAP_RTI);
+
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
@@ -221,7 +221,7 @@
 	fields[3].in_check_mask = NULL;
 	fields[3].in_handler = NULL;
 	fields[3].in_handler_priv = NULL;
-	
+
 	jtag_add_dr_scan(4, fields, -1);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
@@ -242,11 +242,11 @@
 	u8 reg_addr_buf = 0x0;
 	u8 nr_w_buf = 0;
 	u8 cp15_opcode_buf[4];
-	
-	jtag_add_end_state(TAP_RTI);
+
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0xf);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-	
+
 	buf_set_u32(cp15_opcode_buf, 0, 32, cp15_opcode);
 
 	fields[0].tap = jtag_info-&gt;tap;
@@ -296,13 +296,13 @@
 	retval = arm7_9_execute_sys_speed(target);
 	if (retval != ERROR_OK)
 		return retval;
-	
+
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		LOG_ERROR(&quot;failed executing JTAG queue, exiting&quot;);
 		return retval;
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -315,18 +315,18 @@
 
 	/* load address into R1 */
 	regs[1] = address;
-	arm9tdmi_write_core_regs(target, 0x2, regs); 
-	
-	/* read-modify-write CP15 test state register 
+	arm9tdmi_write_core_regs(target, 0x2, regs);
+
+	/* read-modify-write CP15 test state register
 	* to enable interpreted access mode */
-	arm920t_read_cp15_physical(target, 0x1e, &amp;cp15c15);	
+	arm920t_read_cp15_physical(target, 0x1e, &amp;cp15c15);
 	jtag_execute_queue();
 	cp15c15 |= 1;	/* set interpret mode */
 	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
 
 	/* execute CP15 instruction and ARM load (reading from coprocessor) */
 	arm920t_execute_cp15(target, cp15_opcode, ARMV4_5_LDR(0, 1));
-	
+
 	/* disable interpreted access mode */
 	cp15c15 &amp;= ~1U;	/* clear interpret mode */
 	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
@@ -335,7 +335,7 @@
 	regs_p[0] = value;
 	arm9tdmi_read_core_regs(target, 0x1, regs_p);
 	jtag_execute_queue();
-	
+
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG(&quot;cp15_opcode: %8.8x, address: %8.8x, value: %8.8x&quot;, cp15_opcode, address, *value);
 #endif
@@ -360,7 +360,7 @@
 	regs[1] = address;
 	arm9tdmi_write_core_regs(target, 0x3, regs);
 
-	/* read-modify-write CP15 test state register 
+	/* read-modify-write CP15 test state register
 	* to enable interpreted access mode */
 	arm920t_read_cp15_physical(target, 0x1e, &amp;cp15c15);
 	jtag_execute_queue();
@@ -380,10 +380,10 @@
 
 	if (armv4_5_mode_to_number(armv4_5-&gt;core_mode)==-1)
 		return ERROR_FAIL;
-	
+
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 0).dirty = 1;
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 1).dirty = 1;
-	
+
 	return ERROR_OK;
 }
 
@@ -405,13 +405,13 @@
 	/* read cp15 control register */
 	arm920t_read_cp15_physical(target, 0x2, &amp;cp15_control);
 	jtag_execute_queue();
-		
+
 	if (mmu)
 		cp15_control &amp;= ~0x1U;
-	
+
 	if (d_u_cache)
 		cp15_control &amp;= ~0x4U;
-	
+
 	if (i_cache)
 		cp15_control &amp;= ~0x1000U;
 
@@ -425,16 +425,16 @@
 	/* read cp15 control register */
 	arm920t_read_cp15_physical(target, 0x2, &amp;cp15_control);
 	jtag_execute_queue();
-		
+
 	if (mmu)
 		cp15_control |= 0x1U;
-	
+
 	if (d_u_cache)
 		cp15_control |= 0x4U;
-	
+
 	if (i_cache)
 		cp15_control |= 0x1000U;
-	
+
 	arm920t_write_cp15_physical(target, 0x2, cp15_control);
 }
 
@@ -445,7 +445,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm920t_common_t *arm920t = arm9tdmi-&gt;arch_info;
-	
+
 	/* examine cp15 control reg */
 	arm920t_read_cp15_physical(target, 0x2, &amp;arm920t-&gt;cp15_control_reg);
 	jtag_execute_queue();
@@ -469,13 +469,13 @@
 	arm920t_read_cp15_interpreted(target, 0xee150f30, 0x0, &amp;arm920t-&gt;i_fsr);
 	arm920t_read_cp15_interpreted(target, 0xee160f10, 0x0, &amp;arm920t-&gt;d_far);
 	arm920t_read_cp15_interpreted(target, 0xee160f30, 0x0, &amp;arm920t-&gt;i_far);
-	
+
 	LOG_DEBUG(&quot;D FSR: 0x%8.8x, D FAR: 0x%8.8x, I FSR: 0x%8.8x, I FAR: 0x%8.8x&quot;,
-		arm920t-&gt;d_fsr, arm920t-&gt;d_far, arm920t-&gt;i_fsr, arm920t-&gt;i_far);  
+		arm920t-&gt;d_fsr, arm920t-&gt;d_far, arm920t-&gt;i_fsr, arm920t-&gt;i_far);
 
 	if (arm920t-&gt;preserve_cache)
 	{
-		/* read-modify-write CP15 test state register 
+		/* read-modify-write CP15 test state register
 		 * to disable I/D-cache linefills */
 		arm920t_read_cp15_physical(target, 0x1e, &amp;cp15c15);
 		jtag_execute_queue();
@@ -491,14 +491,14 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm920t_common_t *arm920t = arm9tdmi-&gt;arch_info;
-	
+
 	/* restore i/d fault status and address register */
 	arm920t_write_cp15_interpreted(target, 0xee050f10, arm920t-&gt;d_fsr, 0x0);
 	arm920t_write_cp15_interpreted(target, 0xee050f30, arm920t-&gt;i_fsr, 0x0);
 	arm920t_write_cp15_interpreted(target, 0xee060f10, arm920t-&gt;d_far, 0x0);
 	arm920t_write_cp15_interpreted(target, 0xee060f30, arm920t-&gt;i_far, 0x0);
-	
-	/* read-modify-write CP15 test state register 
+
+	/* read-modify-write CP15 test state register
 	* to reenable I/D-cache linefills */
 	if (arm920t-&gt;preserve_cache)
 	{
@@ -515,35 +515,35 @@
 	arm7_9_common_t *arm7_9;
 	arm9tdmi_common_t *arm9tdmi;
 	arm920t_common_t *arm920t;
-	
+
 	if (armv4_5-&gt;common_magic != ARMV4_5_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm7_9 = armv4_5-&gt;arch_info;
 	if (arm7_9-&gt;common_magic != ARM7_9_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm9tdmi = arm7_9-&gt;arch_info;
 	if (arm9tdmi-&gt;common_magic != ARM9TDMI_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm920t = arm9tdmi-&gt;arch_info;
 	if (arm920t-&gt;common_magic != ARM920T_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	*armv4_5_p = armv4_5;
 	*arm7_9_p = arm7_9;
 	*arm9tdmi_p = arm9tdmi;
 	*arm920t_p = arm920t;
-	
+
 	return ERROR_OK;
 }
 
@@ -553,18 +553,18 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm920t_common_t *arm920t = arm9tdmi-&gt;arch_info;
-	
-	char *state[] = 
+
+	char *state[] =
 	{
 		&quot;disabled&quot;, &quot;enabled&quot;
 	};
-	
+
 	if (armv4_5-&gt;common_magic != ARMV4_5_COMMON_MAGIC)
 	{
 		LOG_ERROR(&quot;BUG: called for a non-ARMv4/5 target&quot;);
 		exit(-1);
 	}
-	
+
 	LOG_USER(	&quot;target halted in %s state due to %s, current mode: %s\n&quot;
 			&quot;cpsr: 0x%8.8x pc: 0x%8.8x\n&quot;
 			&quot;MMU: %s, D-Cache: %s, I-Cache: %s&quot;,
@@ -574,18 +574,18 @@
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 32),
 			 buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32),
 			 state[arm920t-&gt;armv4_5_mmu.mmu_enabled],
-			 state[arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled], 
+			 state[arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled],
 			 state[arm920t-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled]);
-	
+
 	return ERROR_OK;
 }
 
 int arm920t_read_memory(struct target_s *target, u32 address, u32 size, u32 count, u8 *buffer)
 {
 	int retval;
-	
+
 	retval = arm7_9_read_memory(target, address, size, count, buffer);
-	
+
 	return retval;
 }
 
@@ -596,7 +596,7 @@
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm920t_common_t *arm920t = arm9tdmi-&gt;arch_info;
-	
+
 	if ((retval = arm7_9_write_memory(target, address, size, count, buffer)) != ERROR_OK)
 		return retval;
 
@@ -615,7 +615,7 @@
 			if (cb == 3)
 				armv4_5_mmu_write_physical(target, &amp;arm920t-&gt;armv4_5_mmu, pa, size, count, buffer);
 		}
-		
+
 		if (arm920t-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled)
 		{
 			LOG_DEBUG(&quot;I-Cache enabled, invalidating affected I-Cache line&quot;);
@@ -634,12 +634,12 @@
 	arm9tdmi_common_t *arm9tdmi = arm7_9-&gt;arch_info;
 	arm920t_common_t *arm920t = arm9tdmi-&gt;arch_info;
 	reg_t *dbg_stat = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_STAT];
-	
+
 	if((retval = target_halt(target)) != ERROR_OK)
 	{
 		return retval;
 	}
-	
+
 	long long then=timeval_ms();
 	int timeout;
 	while (!(timeout=((timeval_ms()-then)&gt;1000)))
@@ -669,22 +669,22 @@
 		LOG_ERROR(&quot;Failed to halt CPU after 1 sec&quot;);
 		return ERROR_TARGET_TIMEOUT;
 	}
-	
+
 	target-&gt;state = TARGET_HALTED;
-	
+
 	/* SVC, ARM state, IRQ and FIQ disabled */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].value, 0, 8, 0xd3);
 	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[ARMV4_5_CPSR].valid = 1;
-	
+
 	/* start fetching from 0x0 */
 	buf_set_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32, 0x0);
 	armv4_5-&gt;core_cache-&gt;reg_list[15].dirty = 1;
 	armv4_5-&gt;core_cache-&gt;reg_list[15].valid = 1;
-	
+
 	armv4_5-&gt;core_mode = ARMV4_5_MODE_SVC;
 	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
-	
+
 	arm920t_disable_mmu_caches(target, 1, 1, 1);
 	arm920t-&gt;armv4_5_mmu.mmu_enabled = 0;
 	arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled = 0;
@@ -694,21 +694,21 @@
 	{
 		return retval;
 	}
-	
+
 	return ERROR_OK;
 }
 
 int arm920t_init_target(struct command_context_s *cmd_ctx, struct target_s *target)
 {
 	arm9tdmi_init_target(cmd_ctx, target);
-		
+
 	return ERROR_OK;
-	
+
 }
 
 int arm920t_quit(void)
 {
-	
+
 	return ERROR_OK;
 }
 
@@ -716,17 +716,17 @@
 {
 	arm9tdmi_common_t *arm9tdmi = &amp;arm920t-&gt;arm9tdmi_common;
 	arm7_9_common_t *arm7_9 = &amp;arm9tdmi-&gt;arm7_9_common;
-	
+
 	/* initialize arm9tdmi specific info (including arm7_9 and armv4_5)
 	 */
 	arm9tdmi_init_arch_info(target, arm9tdmi, tap, variant);
 
 	arm9tdmi-&gt;arch_info = arm920t;
 	arm920t-&gt;common_magic = ARM920T_COMMON_MAGIC;
-	
+
 	arm7_9-&gt;post_debug_entry = arm920t_post_debug_entry;
 	arm7_9-&gt;pre_restore_context = arm920t_pre_restore_context;
-	
+
 	arm920t-&gt;armv4_5_mmu.armv4_5_cache.ctype = -1;
 	arm920t-&gt;armv4_5_mmu.get_ttb = arm920t_get_ttb;
 	arm920t-&gt;armv4_5_mmu.read_memory = arm7_9_read_memory;
@@ -735,23 +735,23 @@
 	arm920t-&gt;armv4_5_mmu.enable_mmu_caches = arm920t_enable_mmu_caches;
 	arm920t-&gt;armv4_5_mmu.has_tiny_pages = 1;
 	arm920t-&gt;armv4_5_mmu.mmu_enabled = 0;
-	
+
 	/* disabling linefills leads to lockups, so keep them enabled for now
 	 * this doesn't affect correctness, but might affect timing issues, if
 	 * important data is evicted from the cache during the debug session
 	 * */
 	arm920t-&gt;preserve_cache = 0;
-	
+
 	/* override hw single-step capability from ARM9TDMI */
 	arm7_9-&gt;has_single_step = 1;
-	
+
 	return ERROR_OK;
 }
 
 int arm920t_target_create(struct target_s *target, Jim_Interp *interp)
 {
 	arm920t_common_t *arm920t = calloc(1,sizeof(arm920t_common_t));
-	
+
 	arm920t_init_arch_info(target, arm920t, target-&gt;tap, target-&gt;variant);
 
 	return ERROR_OK;
@@ -761,10 +761,10 @@
 {
 	int retval;
 	command_t *arm920t_cmd;
-	
-		
+
+
 	retval = arm9tdmi_register_commands(cmd_ctx);
-	
+
 	arm920t_cmd = register_command(cmd_ctx, NULL, &quot;arm920t&quot;, NULL, COMMAND_ANY, &quot;arm920t specific commands&quot;);
 
 	register_command(cmd_ctx, arm920t_cmd, &quot;cp15&quot;, arm920t_handle_cp15_command, COMMAND_EXEC, &quot;display/modify cp15 register &lt;num&gt; [value]&quot;);
@@ -804,30 +804,30 @@
 	FILE *output;
 	arm920t_cache_line_t d_cache[8][64], i_cache[8][64];
 	int segment, index;
-	
+
 	if (argc != 1)
 	{
 		command_print(cmd_ctx, &quot;usage: arm920t read_cache &lt;filename&gt;&quot;);
 		return ERROR_OK;
 	}
-	
+
 	if ((output = fopen(args[0], &quot;w&quot;)) == NULL)
 	{
 		LOG_DEBUG(&quot;error opening cache content file&quot;);
 		return ERROR_OK;
 	}
-	
+
 	for (i = 0; i &lt; 16; i++)
 		regs_p[i] = &amp;regs[i];
-		
+
 	if (arm920t_get_arch_pointers(target, &amp;armv4_5, &amp;arm7_9, &amp;arm9tdmi, &amp;arm920t) != ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	/* disable MMU and Caches */
 	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), &amp;cp15_ctrl);
 	if((retval = jtag_execute_queue()) != ERROR_OK)
@@ -838,29 +838,29 @@
 	cp15_ctrl &amp;= ~(ARMV4_5_MMU_ENABLED | ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
 	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl);
 
-	/* read CP15 test state register */ 
+	/* read CP15 test state register */
 	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), &amp;cp15c15);
 	jtag_execute_queue();
-	
+
 	/* read DCache content */
 	fprintf(output, &quot;DCache:\n&quot;);
-	
-	/* go through segments 0 to nsets (8 on ARM920T, 4 on ARM922T) */ 
+
+	/* go through segments 0 to nsets (8 on ARM920T, 4 on ARM922T) */
 	for (segment = 0; segment &lt; arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_size.nsets; segment++)
 	{
 		fprintf(output, &quot;\nsegment: %i\n----------&quot;, segment);
-		
+
 		/* Ra: r0 = SBZ(31:8):segment(7:5):SBZ(4:0) */
 		regs[0] = 0x0 | (segment &lt;&lt; 5);
 		arm9tdmi_write_core_regs(target, 0x1, regs);
-		
+
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-		
+
 		/* D CAM Read, loads current victim into C15.C.D.Ind */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,6,2), ARMV4_5_LDR(1, 0));
-	
+
 		/* read current victim */
 		arm920t_read_cp15_physical(target, 0x3d, &amp;C15_C_D_Ind);
 
@@ -877,16 +877,16 @@
 			/* set interpret mode */
 			cp15c15 |= 0x1;
 			arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-	
+
 			/* Write DCache victim */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
-	
+
 			/* Read D RAM */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,10,2), ARMV4_5_LDMIA(0, 0x1fe, 0, 0));
-			
+
 			/* Read D CAM */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,6,2), ARMV4_5_LDR(9, 0));
-			
+
 			/* clear interpret mode */
 			cp15c15 &amp;= ~0x1;
 			arm920t_write_cp15_physical(target, 0x1e, cp15c15);
@@ -899,19 +899,19 @@
 			}
 
 			d_cache[segment][index].cam = regs[9];
-			
+
 			/* mask LFSR[6] */
 			regs[9] &amp;= 0xfffffffe;
 			fprintf(output, &quot;\nsegment: %i, index: %i, CAM: 0x%8.8x, content (%s):\n&quot;, segment, index, regs[9], (regs[9] &amp; 0x10) ? &quot;valid&quot; : &quot;invalid&quot;);
-			
+
 			for (i = 1; i &lt; 9; i++)
 			{
 				 d_cache[segment][index].data[i] = regs[i];
 				 fprintf(output, &quot;%i: 0x%8.8x\n&quot;, i-1, regs[i]);
 			}
-	
+
 		}
-		
+
 		/* Ra: r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0) */
 		regs[0] = 0x0 | (segment &lt;&lt; 5) | (C15_C_D_Ind &lt;&lt; 26);
 		arm9tdmi_write_core_regs(target, 0x1, regs);
@@ -919,10 +919,10 @@
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-	
+
 		/* Write DCache victim */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,0), ARMV4_5_LDR(1, 0));
-	
+
 		/* clear interpret mode */
 		cp15c15 &amp;= ~0x1;
 		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
@@ -930,23 +930,23 @@
 
 	/* read ICache content */
 	fprintf(output, &quot;ICache:\n&quot;);
-	
-	/* go through segments 0 to nsets (8 on ARM920T, 4 on ARM922T) */ 
+
+	/* go through segments 0 to nsets (8 on ARM920T, 4 on ARM922T) */
 	for (segment = 0; segment &lt; arm920t-&gt;armv4_5_mmu.armv4_5_cache.d_u_size.nsets; segment++)
 	{
 		fprintf(output, &quot;segment: %i\n----------&quot;, segment);
-		
+
 		/* Ra: r0 = SBZ(31:8):segment(7:5):SBZ(4:0) */
 		regs[0] = 0x0 | (segment &lt;&lt; 5);
 		arm9tdmi_write_core_regs(target, 0x1, regs);
-		
+
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-		
+
 		/* I CAM Read, loads current victim into C15.C.I.Ind */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,5,2), ARMV4_5_LDR(1, 0));
-	
+
 		/* read current victim */
 		arm920t_read_cp15_physical(target, 0x3b, &amp;C15_C_I_Ind);
 
@@ -963,16 +963,16 @@
 			/* set interpret mode */
 			cp15c15 |= 0x1;
 			arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-	
+
 			/* Write ICache victim */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
-	
+
 			/* Read I RAM */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,9,2), ARMV4_5_LDMIA(0, 0x1fe, 0, 0));
-			
+
 			/* Read I CAM */
 			arm920t_execute_cp15(target, ARMV4_5_MCR(15,2,0,15,5,2), ARMV4_5_LDR(9, 0));
-			
+
 			/* clear interpret mode */
 			cp15c15 &amp;= ~0x1;
 			arm920t_write_cp15_physical(target, 0x1e, cp15c15);
@@ -985,20 +985,20 @@
 			}
 
 			i_cache[segment][index].cam = regs[9];
-			
+
 			/* mask LFSR[6] */
 			regs[9] &amp;= 0xfffffffe;
 			fprintf(output, &quot;\nsegment: %i, index: %i, CAM: 0x%8.8x, content (%s):\n&quot;, segment, index, regs[9], (regs[9] &amp; 0x10) ? &quot;valid&quot; : &quot;invalid&quot;);
-			
+
 			for (i = 1; i &lt; 9; i++)
 			{
 				 i_cache[segment][index].data[i] = regs[i];
 				 fprintf(output, &quot;%i: 0x%8.8x\n&quot;, i-1, regs[i]);
 			}
-	
+
 		}
-		
-	
+
+
 		/* Ra: r0 = index(31:26):SBZ(25:8):segment(7:5):SBZ(4:0) */
 		regs[0] = 0x0 | (segment &lt;&lt; 5) | (C15_C_D_Ind &lt;&lt; 26);
 		arm9tdmi_write_core_regs(target, 0x1, regs);
@@ -1006,22 +1006,22 @@
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-	
+
 		/* Write ICache victim */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,9,1,1), ARMV4_5_LDR(1, 0));
-	
+
 		/* clear interpret mode */
 		cp15c15 &amp;= ~0x1;
 		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
 	}
-	
+
 	/* restore CP15 MMU and Cache settings */
 	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl_saved);
-	
+
 	command_print(cmd_ctx, &quot;cache content successfully output to %s&quot;, args[0]);
-	
+
 	fclose(output);
-	
+
 	if (armv4_5_mode_to_number(armv4_5-&gt;core_mode)==-1)
 		return ERROR_FAIL;
 
@@ -1036,7 +1036,7 @@
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 7).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 7).valid;
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 8).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 8).valid;
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 9).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 9).valid;
-	
+
 	return ERROR_OK;
 }
 
@@ -1058,30 +1058,30 @@
 	u32 Dlockdown, Ilockdown;
 	arm920t_tlb_entry_t d_tlb[64], i_tlb[64];
 	int victim;
-	
+
 	if (argc != 1)
 	{
 		command_print(cmd_ctx, &quot;usage: arm920t read_mmu &lt;filename&gt;&quot;);
 		return ERROR_OK;
 	}
-	
+
 	if ((output = fopen(args[0], &quot;w&quot;)) == NULL)
 	{
 		LOG_DEBUG(&quot;error opening mmu content file&quot;);
 		return ERROR_OK;
 	}
-	
+
 	for (i = 0; i &lt; 16; i++)
 		regs_p[i] = &amp;regs[i];
-		
+
 	if (arm920t_get_arch_pointers(target, &amp;armv4_5, &amp;arm7_9, &amp;arm9tdmi, &amp;arm920t) != ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	/* disable MMU and Caches */
 	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), &amp;cp15_ctrl);
 	if((retval = jtag_execute_queue()) != ERROR_OK)
@@ -1092,27 +1092,27 @@
 	cp15_ctrl &amp;= ~(ARMV4_5_MMU_ENABLED | ARMV4_5_D_U_CACHE_ENABLED | ARMV4_5_I_CACHE_ENABLED);
 	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl);
 
-	/* read CP15 test state register */ 
+	/* read CP15 test state register */
 	arm920t_read_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), &amp;cp15c15);
 	if((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		return retval;
 	}
 
-	/* prepare reading D TLB content 
+	/* prepare reading D TLB content
 	 * */
-	
+
 	/* set interpret mode */
 	cp15c15 |= 0x1;
 	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-	
+
 	/* Read D TLB lockdown */
 	arm920t_execute_cp15(target, ARMV4_5_MRC(15,0,0,10,0,0), ARMV4_5_LDR(1, 0));
-	
+
 	/* clear interpret mode */
 	cp15c15 &amp;= ~0x1;
 	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
-	
+
 	/* read D TLB lockdown stored to r1 */
 	arm9tdmi_read_core_regs(target, 0x2, regs_p);
 	if((retval = jtag_execute_queue()) != ERROR_OK)
@@ -1120,63 +1120,63 @@
 		return retval;
 	}
 	Dlockdown = regs[1];
-	
+
 	for (victim = 0; victim &lt; 64; victim += 8)
 	{
-		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0] 
+		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
 		 * base remains unchanged, victim goes through entries 0 to 63 */
 		regs[1] = (Dlockdown &amp; 0xfc000000) | (victim &lt;&lt; 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
-		
+
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-		
+
 		/* Write D TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
-	
+
 		/* Read D TLB CAM */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,6,4), ARMV4_5_LDMIA(0, 0x3fc, 0, 0));
-		
+
 		/* clear interpret mode */
 		cp15c15 &amp;= ~0x1;
 		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
-		
+
 		/* read D TLB CAM content stored to r2-r9 */
 		arm9tdmi_read_core_regs(target, 0x3fc, regs_p);
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		for (i = 0; i &lt; 8; i++)
-			d_tlb[victim + i].cam = regs[i + 2]; 
+			d_tlb[victim + i].cam = regs[i + 2];
 	}
 
 	for (victim = 0; victim &lt; 64; victim++)
 	{
-		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0] 
+		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
 		 * base remains unchanged, victim goes through entries 0 to 63 */
 		regs[1] = (Dlockdown &amp; 0xfc000000) | (victim &lt;&lt; 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
-		
+
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-		
+
 		/* Write D TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
-	
+
 		/* Read D TLB RAM1 */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,10,4), ARMV4_5_LDR(2,0));
 
 		/* Read D TLB RAM2 */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,2,5), ARMV4_5_LDR(3,0));
-		
+
 		/* clear interpret mode */
 		cp15c15 &amp;= ~0x1;
 		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
-		
+
 		/* read D TLB RAM content stored to r2 and r3 */
 		arm9tdmi_read_core_regs(target, 0xc, regs_p);
 		if((retval = jtag_execute_queue()) != ERROR_OK)
@@ -1184,31 +1184,31 @@
 			return retval;
 		}
 
-		d_tlb[victim].ram1 = regs[2]; 
-		d_tlb[victim].ram2 = regs[3]; 
+		d_tlb[victim].ram1 = regs[2];
+		d_tlb[victim].ram2 = regs[3];
 	}
-		
+
 	/* restore D TLB lockdown */
 	regs[1] = Dlockdown;
 	arm9tdmi_write_core_regs(target, 0x2, regs);
-	
+
 	/* Write D TLB lockdown */
 	arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,0), ARMV4_5_STR(1, 0));
 
-	/* prepare reading I TLB content 
+	/* prepare reading I TLB content
 	 * */
-	
+
 	/* set interpret mode */
 	cp15c15 |= 0x1;
 	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-	
+
 	/* Read I TLB lockdown */
 	arm920t_execute_cp15(target, ARMV4_5_MRC(15,0,0,10,0,1), ARMV4_5_LDR(1, 0));
-	
+
 	/* clear interpret mode */
 	cp15c15 &amp;= ~0x1;
 	arm920t_write_cp15_physical(target, 0x1e, cp15c15);
-	
+
 	/* read I TLB lockdown stored to r1 */
 	arm9tdmi_read_core_regs(target, 0x2, regs_p);
 	if((retval = jtag_execute_queue()) != ERROR_OK)
@@ -1216,63 +1216,63 @@
 		return retval;
 	}
 	Ilockdown = regs[1];
-	
+
 	for (victim = 0; victim &lt; 64; victim += 8)
 	{
-		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0] 
+		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
 		 * base remains unchanged, victim goes through entries 0 to 63 */
 		regs[1] = (Ilockdown &amp; 0xfc000000) | (victim &lt;&lt; 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
-		
+
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-		
+
 		/* Write I TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
-	
+
 		/* Read I TLB CAM */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,5,4), ARMV4_5_LDMIA(0, 0x3fc, 0, 0));
-		
+
 		/* clear interpret mode */
 		cp15c15 &amp;= ~0x1;
 		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
-		
+
 		/* read I TLB CAM content stored to r2-r9 */
 		arm9tdmi_read_core_regs(target, 0x3fc, regs_p);
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		for (i = 0; i &lt; 8; i++)
-			i_tlb[i + victim].cam = regs[i + 2]; 
+			i_tlb[i + victim].cam = regs[i + 2];
 	}
 
 	for (victim = 0; victim &lt; 64; victim++)
 	{
-		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0] 
+		/* new lockdown value: base[31:26]:victim[25:20]:SBZ[19:1]:p[0]
 		 * base remains unchanged, victim goes through entries 0 to 63 */
 		regs[1] = (Dlockdown &amp; 0xfc000000) | (victim &lt;&lt; 20);
 		arm9tdmi_write_core_regs(target, 0x2, regs);
-		
+
 		/* set interpret mode */
 		cp15c15 |= 0x1;
 		arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0xf, 0), cp15c15);
-		
+
 		/* Write I TLB lockdown */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
-	
+
 		/* Read I TLB RAM1 */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,9,4), ARMV4_5_LDR(2,0));
 
 		/* Read I TLB RAM2 */
 		arm920t_execute_cp15(target, ARMV4_5_MCR(15,4,0,15,1,5), ARMV4_5_LDR(3,0));
-		
+
 		/* clear interpret mode */
 		cp15c15 &amp;= ~0x1;
 		arm920t_write_cp15_physical(target, 0x1e, cp15c15);
-		
+
 		/* read I TLB RAM content stored to r2 and r3 */
 		arm9tdmi_read_core_regs(target, 0xc, regs_p);
 		if((retval = jtag_execute_queue()) != ERROR_OK)
@@ -1280,21 +1280,21 @@
 			return retval;
 		}
 
-		i_tlb[victim].ram1 = regs[2]; 
-		i_tlb[victim].ram2 = regs[3]; 
+		i_tlb[victim].ram1 = regs[2];
+		i_tlb[victim].ram2 = regs[3];
 	}
-		
+
 	/* restore I TLB lockdown */
 	regs[1] = Ilockdown;
 	arm9tdmi_write_core_regs(target, 0x2, regs);
-	
+
 	/* Write I TLB lockdown */
 	arm920t_execute_cp15(target, ARMV4_5_MCR(15,0,0,10,0,1), ARMV4_5_STR(1, 0));
-	
+
 	/* restore CP15 MMU and Cache settings */
 	arm920t_write_cp15_physical(target, ARM920T_CP15_PHYS_ADDR(0, 0x1, 0), cp15_ctrl_saved);
 
-	/* output data to file */	
+	/* output data to file */
 	fprintf(output, &quot;D TLB content:\n&quot;);
 	for (i = 0; i &lt; 64; i++)
 	{
@@ -1306,11 +1306,11 @@
 	{
 		fprintf(output, &quot;%i: 0x%8.8x 0x%8.8x 0x%8.8x %s\n&quot;, i, i_tlb[i].cam, i_tlb[i].ram1, i_tlb[i].ram2, (i_tlb[i].cam &amp; 0x20) ? &quot;(valid)&quot; : &quot;(invalid)&quot;);
 	}
-	
+
 	command_print(cmd_ctx, &quot;mmu content successfully output to %s&quot;, args[0]);
-	
+
 	fclose(output);
-	
+
 	if (armv4_5_mode_to_number(armv4_5-&gt;core_mode)==-1)
 		return ERROR_FAIL;
 
@@ -1325,7 +1325,7 @@
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 7).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 7).valid;
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 8).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 8).valid;
 	ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 9).dirty = ARMV4_5_CORE_REG_MODE(armv4_5-&gt;core_cache, armv4_5-&gt;core_mode, 9).valid;
-	
+
 	return ERROR_OK;
 }
 int arm920t_handle_cp15_command(struct command_context_s *cmd_ctx, char *cmd, char **args, int argc)
@@ -1343,9 +1343,9 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
@@ -1369,7 +1369,7 @@
 			{
 				return retval;
 			}
-			
+
 			command_print(cmd_ctx, &quot;%i: %8.8x&quot;, address, value);
 		}
 		else if (argc == 2)
@@ -1402,9 +1402,9 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
@@ -1424,7 +1424,7 @@
 				command_print(cmd_ctx, &quot;couldn't execute %8.8x&quot;, opcode);
 				return ERROR_OK;
 			}
-			
+
 			command_print(cmd_ctx, &quot;%8.8x: %8.8x&quot;, opcode, value);
 		}
 		else if (argc == 2)
@@ -1464,18 +1464,18 @@
 	arm7_9_common_t *arm7_9;
 	arm9tdmi_common_t *arm9tdmi;
 	arm920t_common_t *arm920t;
-	
+
 	if (arm920t_get_arch_pointers(target, &amp;armv4_5, &amp;arm7_9, &amp;arm9tdmi, &amp;arm920t) != ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	return armv4_5_handle_cache_info_command(cmd_ctx, &amp;arm920t-&gt;armv4_5_mmu.armv4_5_cache);
 }
 
 int arm920t_handle_virt2phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
-{	
+{
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -1488,20 +1488,20 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
 		return ERROR_OK;
 	}
-		
+
 	return armv4_5_mmu_handle_virt2phys_command(cmd_ctx, cmd, args, argc, target, &amp;arm920t-&gt;armv4_5_mmu);
 }
 
 int arm920t_handle_md_phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
-{	
+{
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -1514,20 +1514,20 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
 		return ERROR_OK;
 	}
-	
+
 	return armv4_5_mmu_handle_md_phys_command(cmd_ctx, cmd, args, argc, target, &amp;arm920t-&gt;armv4_5_mmu);
 }
 
 int arm920t_handle_mw_phys_command(command_context_t *cmd_ctx, char *cmd, char **args, int argc)
-{	
+{
 	target_t *target = get_current_target(cmd_ctx);
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
@@ -1540,14 +1540,14 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM920t target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
 		return ERROR_OK;
 	}
-	
+
 	return armv4_5_mmu_handle_mw_phys_command(cmd_ctx, cmd, args, argc, target, &amp;arm920t-&gt;armv4_5_mmu);
 }

Modified: trunk/src/target/arm926ejs.c
===================================================================
--- trunk/src/target/arm926ejs.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm926ejs.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -132,7 +132,7 @@
 
 	buf_set_u32(address_buf, 0, 14, address);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	if((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
 	{
 		return retval;
@@ -222,7 +222,7 @@
 	buf_set_u32(address_buf, 0, 14, address);
 	buf_set_u32(value_buf, 0, 32, value);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	if((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
 	{
 		return retval;
@@ -366,7 +366,7 @@
 		default:
 			LOG_ERROR(&quot;BUG: unknown debug reason: 0x%x&quot;, debug_reason);
 			target-&gt;debug_reason = DBG_REASON_DBGRQ;
-			/* if we fail here, we won't talk to the target and it will 
+			/* if we fail here, we won't talk to the target and it will
 			 * be reported to be in the halted state */
 			retval = ERROR_TARGET_FAILURE;
 			break;

Modified: trunk/src/target/arm966e.c
===================================================================
--- trunk/src/target/arm966e.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm966e.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -74,9 +74,9 @@
 	.bulk_write_memory = arm7_9_bulk_write_memory,
 	.checksum_memory = arm7_9_checksum_memory,
 	.blank_check_memory = arm7_9_blank_check_memory,
-	
+
 	.run_algorithm = armv4_5_run_algorithm,
-	
+
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
 	.add_watchpoint = arm7_9_add_watchpoint,
@@ -92,13 +92,13 @@
 int arm966e_init_target(struct command_context_s *cmd_ctx, struct target_s *target)
 {
 	arm9tdmi_init_target(cmd_ctx, target);
-		
+
 	return ERROR_OK;
 }
 
 int arm966e_quit(void)
 {
-	
+
 	return ERROR_OK;
 }
 
@@ -106,25 +106,25 @@
 {
 	arm9tdmi_common_t *arm9tdmi = &amp;arm966e-&gt;arm9tdmi_common;
 	arm7_9_common_t *arm7_9 = &amp;arm9tdmi-&gt;arm7_9_common;
-	
+
 	arm9tdmi_init_arch_info(target, arm9tdmi, tap, variant);
 
 	arm9tdmi-&gt;arch_info = arm966e;
 	arm966e-&gt;common_magic = ARM966E_COMMON_MAGIC;
-	
+
 	/* The ARM966E-S implements the ARMv5TE architecture which
 	 * has the BKPT instruction, so we don't have to use a watchpoint comparator
 	 */
 	arm7_9-&gt;arm_bkpt = ARMV5_BKPT(0x0);
 	arm7_9-&gt;thumb_bkpt = ARMV5_T_BKPT(0x0) &amp; 0xffff;
-	
+
 	return ERROR_OK;
 }
 
 int arm966e_target_create( struct target_s *target, Jim_Interp *interp )
 {
 	arm966e_common_t *arm966e = calloc(1,sizeof(arm966e_common_t));
-	
+
 	arm966e_init_arch_info(target, arm966e, target-&gt;tap, target-&gt;variant);
 
 	return ERROR_OK;
@@ -136,35 +136,35 @@
 	arm7_9_common_t *arm7_9;
 	arm9tdmi_common_t *arm9tdmi;
 	arm966e_common_t *arm966e;
-	
+
 	if (armv4_5-&gt;common_magic != ARMV4_5_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm7_9 = armv4_5-&gt;arch_info;
 	if (arm7_9-&gt;common_magic != ARM7_9_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm9tdmi = arm7_9-&gt;arch_info;
 	if (arm9tdmi-&gt;common_magic != ARM9TDMI_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm966e = arm9tdmi-&gt;arch_info;
 	if (arm966e-&gt;common_magic != ARM966E_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	*armv4_5_p = armv4_5;
 	*arm7_9_p = arm7_9;
 	*arm9tdmi_p = arm9tdmi;
 	*arm966e_p = arm966e;
-	
+
 	return ERROR_OK;
 }
 
@@ -177,8 +177,8 @@
 	scan_field_t fields[3];
 	u8 reg_addr_buf = reg_addr &amp; 0x3f;
 	u8 nr_w_buf = 0;
-	
-	jtag_add_end_state(TAP_RTI);
+
+	jtag_add_end_state(TAP_IDLE);
 	if((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
 	{
 		return retval;
@@ -214,7 +214,7 @@
 	fields[2].in_check_mask = NULL;
 	fields[2].in_handler = NULL;
 	fields[2].in_handler_priv = NULL;
-	
+
 	jtag_add_dr_scan(3, fields, -1);
 
 	fields[0].in_handler_priv = value;
@@ -243,10 +243,10 @@
 	u8 reg_addr_buf = reg_addr &amp; 0x3f;
 	u8 nr_w_buf = 1;
 	u8 value_buf[4];
-	
+
 	buf_set_u32(value_buf, 0, 32, value);
-	
-	jtag_add_end_state(TAP_RTI);
+
+	jtag_add_end_state(TAP_IDLE);
 	if((retval = arm_jtag_scann(jtag_info, 0xf)) != ERROR_OK)
 	{
 		return retval;
@@ -282,7 +282,7 @@
 	fields[2].in_check_mask = NULL;
 	fields[2].in_handler = NULL;
 	fields[2].in_handler_priv = NULL;
-	
+
 	jtag_add_dr_scan(3, fields, -1);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
@@ -307,9 +307,9 @@
 		command_print(cmd_ctx, &quot;current target isn't an ARM966e target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		command_print(cmd_ctx, &quot;target must be stopped for \&quot;%s\&quot; command&quot;, cmd);
@@ -333,7 +333,7 @@
 			{
 				return retval;
 			}
-			
+
 			command_print(cmd_ctx, &quot;%i: %8.8x&quot;, address, value);
 		}
 		else if (argc == 2)
@@ -355,10 +355,10 @@
 {
 	int retval;
 	command_t *arm966e_cmd;
-	
+
 	retval = arm9tdmi_register_commands(cmd_ctx);
 	arm966e_cmd = register_command(cmd_ctx, NULL, &quot;arm966e&quot;, NULL, COMMAND_ANY, &quot;arm966e specific commands&quot;);
 	register_command(cmd_ctx, arm966e_cmd, &quot;cp15&quot;, arm966e_handle_cp15_command, COMMAND_EXEC, &quot;display/modify cp15 register &lt;num&gt; [value]&quot;);
-	
+
 	return retval;
 }

Modified: trunk/src/target/arm9tdmi.c
===================================================================
--- trunk/src/target/arm9tdmi.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/arm9tdmi.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -56,7 +56,7 @@
 
 int arm9tdmi_init_target(struct command_context_s *cmd_ctx, struct target_s *target);
 int arm9tdmi_quit(void);
-		
+
 target_type_t arm9tdmi_target =
 {
 	.name = &quot;arm9tdmi&quot;,
@@ -81,9 +81,9 @@
 	.bulk_write_memory = arm7_9_bulk_write_memory,
 	.checksum_memory = arm7_9_checksum_memory,
 	.blank_check_memory = arm7_9_blank_check_memory,
-	
+
 	.run_algorithm = armv4_5_run_algorithm,
-	
+
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
 	.add_watchpoint = arm7_9_add_watchpoint,
@@ -115,7 +115,7 @@
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
-	
+
 	/* only check the debug reason if we don't know it already */
 	if ((target-&gt;debug_reason != DBG_REASON_DBGRQ)
 			&amp;&amp; (target-&gt;debug_reason != DBG_REASON_SINGLESTEP))
@@ -125,7 +125,7 @@
 		u8 instructionbus[4];
 		u8 debug_reason;
 
-		jtag_add_end_state(TAP_PD);
+		jtag_add_end_state(TAP_DRPAUSE);
 
 		fields[0].tap = arm7_9-&gt;jtag_info.tap;
 		fields[0].num_bits = 32;
@@ -136,7 +136,7 @@
 		fields[0].in_check_mask = NULL;
 		fields[0].in_handler = NULL;
 		fields[0].in_handler_priv = NULL;
-		
+
 		fields[1].tap = arm7_9-&gt;jtag_info.tap;
 		fields[1].num_bits = 3;
 		fields[1].out_value = NULL;
@@ -146,7 +146,7 @@
 		fields[1].in_check_mask = NULL;
 		fields[1].in_handler = NULL;
 		fields[1].in_handler_priv = NULL;
-		
+
 		fields[2].tap = arm7_9-&gt;jtag_info.tap;
 		fields[2].num_bits = 32;
 		fields[2].out_value = NULL;
@@ -156,28 +156,28 @@
 		fields[2].in_check_mask = NULL;
 		fields[2].in_handler = NULL;
 		fields[2].in_handler_priv = NULL;
-		
+
 		if((retval = arm_jtag_scann(&amp;arm7_9-&gt;jtag_info, 0x1)) != ERROR_OK)
 		{
 			return retval;
 		}
 		arm_jtag_set_instr(&amp;arm7_9-&gt;jtag_info, arm7_9-&gt;jtag_info.intest_instr, NULL);
 
-		jtag_add_dr_scan(3, fields, TAP_PD);
+		jtag_add_dr_scan(3, fields, TAP_DRPAUSE);
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		fields[0].in_value = NULL;
 		fields[0].out_value = databus;
 		fields[1].in_value = NULL;
 		fields[1].out_value = &amp;debug_reason;
 		fields[2].in_value = NULL;
 		fields[2].out_value = instructionbus;
-		
-		jtag_add_dr_scan(3, fields, TAP_PD);
 
+		jtag_add_dr_scan(3, fields, TAP_DRPAUSE);
+
 		if (debug_reason &amp; 0x4)
 			if (debug_reason &amp; 0x2)
 				target-&gt;debug_reason = DBG_REASON_WPTANDBKPT;
@@ -198,23 +198,23 @@
 	u8 out_buf[4];
 	u8 instr_buf[4];
 	u8 sysspeed_buf = 0x0;
-	
+
 	/* prepare buffer */
 	buf_set_u32(out_buf, 0, 32, out);
-	
+
 	buf_set_u32(instr_buf, 0, 32, flip_u32(instr, 32));
-	
+
 	if (sysspeed)
 		buf_set_u32(&amp;sysspeed_buf, 2, 1, 1);
-	
-	jtag_add_end_state(TAP_PD);
+
+	jtag_add_end_state(TAP_DRPAUSE);
 	if((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
 	{
 		return retval;
 	}
-	
+
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-		
+
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
@@ -232,7 +232,7 @@
 	}
 	fields[0].in_check_value = NULL;
 	fields[0].in_check_mask = NULL;
-	
+
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = &amp;sysspeed_buf;
@@ -242,7 +242,7 @@
 	fields[1].in_check_mask = NULL;
 	fields[1].in_handler = NULL;
 	fields[1].in_handler_priv = NULL;
-		
+
 	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = instr_buf;
@@ -256,14 +256,14 @@
 	jtag_add_dr_scan(3, fields, -1);
 
 	jtag_add_runtest(0, -1);
-	
+
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	{
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		if (in)
 		{
 			LOG_DEBUG(&quot;instr: 0x%8.8x, out: 0x%8.8x, in: 0x%8.8x&quot;, instr, out, *in);
@@ -282,14 +282,14 @@
 	int retval = ERROR_OK;;
 	scan_field_t fields[3];
 
-	jtag_add_end_state(TAP_PD);
+	jtag_add_end_state(TAP_DRPAUSE);
 	if((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
 	{
 		return retval;
 	}
-	
+
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-		
+
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -299,7 +299,7 @@
 	fields[0].in_handler_priv = in;
 	fields[0].in_check_value = NULL;
 	fields[0].in_check_mask = NULL;
-	
+
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = NULL;
@@ -319,18 +319,18 @@
 	fields[2].in_check_mask = NULL;
 	fields[2].in_handler = NULL;
 	fields[2].in_handler_priv = NULL;
-	
+
 	jtag_add_dr_scan(3, fields, -1);
 
 	jtag_add_runtest(0, -1);
-	
+
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	{
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		if (in)
 		{
 			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *in);
@@ -353,15 +353,15 @@
 {
 	int retval = ERROR_OK;
 	scan_field_t fields[3];
-	
-	jtag_add_end_state(TAP_PD);
+
+	jtag_add_end_state(TAP_DRPAUSE);
 	if((retval = arm_jtag_scann(jtag_info, 0x1)) != ERROR_OK)
 	{
 		return retval;
 	}
-	
+
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-		
+
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = NULL;
@@ -382,7 +382,7 @@
 	fields[0].in_handler_priv = in;
 	fields[0].in_check_value = NULL;
 	fields[0].in_check_mask = NULL;
-	
+
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = NULL;
@@ -402,18 +402,18 @@
 	fields[2].in_check_mask = NULL;
 	fields[2].in_handler = NULL;
 	fields[2].in_handler_priv = NULL;
-	
+
 	jtag_add_dr_scan(3, fields, -1);
 
 	jtag_add_runtest(0, -1);
-	
+
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	{
 		if((retval = jtag_execute_queue()) != ERROR_OK)
 		{
 			return retval;
 		}
-		
+
 		if (in)
 		{
 			LOG_DEBUG(&quot;in: 0x%8.8x&quot;, *(u32*)in);
@@ -435,10 +435,10 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
-	/* save r0 before using it and put system in ARM state 
+
+	/* save r0 before using it and put system in ARM state
 	 * to allow common handling of ARM and THUMB debugging */
-	
+
 	/* fetch STR r0, [r0] */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_STR(0, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
@@ -446,7 +446,7 @@
 	/* STR r0, [r0] in Memory */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, r0, 0);
 
-	/* MOV r0, r15 fetched, STR in Decode */	
+	/* MOV r0, r15 fetched, STR in Decode */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_MOV(0, 15), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_STR(0, 0), 0, NULL, 0);
@@ -470,12 +470,12 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 	/* NOP fetched, BX in Execute (1) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
-	
+
 	if((retval = jtag_execute_queue()) != ERROR_OK)
 	{
 		return;
 	}
-	
+
 	/* fix program counter:
 	 * MOV r0, r15 was the 5th instruction (+8)
 	 * reading PC in Thumb state gives address of instruction + 4
@@ -490,7 +490,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	/* STMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
 	 */
@@ -521,7 +521,7 @@
 	u32 *buf_u32 = buffer;
 	u16 *buf_u16 = buffer;
 	u8 *buf_u8 = buffer;
-	
+
 	/* STMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
 	 */
@@ -558,7 +558,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	/* MRS r0, cpsr */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_MRS(0, spsr &amp; 1), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -583,7 +583,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	LOG_DEBUG(&quot;xpsr: %8.8x, spsr: %i&quot;, xpsr, spsr);
 
 	/* MSR1 fetched */
@@ -619,16 +619,16 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	LOG_DEBUG(&quot;xpsr_im: %2.2x, rot: %i, spsr: %i&quot;, xpsr_im, rot, spsr);
-	
+
 	/* MSR fetched */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_MSR_IM(xpsr_im, rot, 1, spsr), 0, NULL, 0);
 	/* NOP fetched, MSR in DECODE */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	/* NOP fetched, MSR in EXECUTE (1) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
-	
+
 	/* rot == 4 writes flags, which takes only one cycle */
 	if (rot != 4)
 	{
@@ -646,7 +646,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	/* LDMIA r0-15, [r0] at debug speed
 	* register values will start to appear on 4th DCLK
 	*/
@@ -664,7 +664,7 @@
 			arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, core_regs[i], NULL, 0);
 	}
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
-	
+
 }
 
 void arm9tdmi_load_word_regs(target_t *target, u32 mask)
@@ -686,7 +686,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	/* put system-speed load half-word into the pipeline */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_LDRH_IP(num, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
@@ -750,7 +750,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	/* LDMIA r0-15, [r0] at debug speed
 	 * register values will start to appear on 4th DCLK
 	 */
@@ -777,7 +777,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_B(0xfffffc, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 1);
 
@@ -786,7 +786,7 @@
 void arm9tdmi_branch_resume_thumb(target_t *target)
 {
 	LOG_DEBUG(&quot;-&quot;);
-	
+
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
@@ -809,14 +809,14 @@
 
 	/* Branch and eXchange */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_BX(0), 0, NULL, 0);
-	
+
 	embeddedice_read_reg(dbg_stat);
-	
+
 	/* fetch NOP, BX in DECODE stage */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
-	
+
 	embeddedice_read_reg(dbg_stat);
-	
+
 	/* fetch NOP, BX in EXECUTE stage (1st cycle) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 
@@ -833,12 +833,12 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[0].value, 0, 32), NULL, 0);
 	/* nothing fetched, LDR in EXECUTE stage (3rd cycle) */
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
-	
+
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 
 	embeddedice_read_reg(dbg_stat);
-	
+
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_B(0x7f7), 0, NULL, 1);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 
@@ -849,7 +849,7 @@
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
-	
+
 	if (arm7_9-&gt;has_single_step)
 	{
 		buf_set_u32(arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL].value, 3, 1, 1);
@@ -866,7 +866,7 @@
 	/* get pointers to arch-specific information */
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
-	
+
 	if (arm7_9-&gt;has_single_step)
 	{
 		buf_set_u32(arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL].value, 3, 1, 0);
@@ -905,7 +905,7 @@
 			return ERROR_FAIL;
 		(*cache_p) = t;
 		arm7_9-&gt;eice_cache = (*cache_p);
-	
+
 		if (arm7_9-&gt;etm_ctx)
 		{
 			arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
@@ -928,16 +928,16 @@
 
 int arm9tdmi_init_target(struct command_context_s *cmd_ctx, struct target_s *target)
 {
-	
+
 	arm9tdmi_build_reg_cache(target);
-	
+
 	return ERROR_OK;
-	
+
 }
 
 int arm9tdmi_quit(void)
 {
-	
+
 	return ERROR_OK;
 }
 
@@ -945,53 +945,53 @@
 {
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
-	
+
 	arm7_9 = &amp;arm9tdmi-&gt;arm7_9_common;
 	armv4_5 = &amp;arm7_9-&gt;armv4_5_common;
-	
+
 	/* prepare JTAG information for the new target */
 	arm7_9-&gt;jtag_info.tap = tap;
 	arm7_9-&gt;jtag_info.scann_size = 5;
-	
+
 	/* register arch-specific functions */
 	arm7_9-&gt;examine_debug_reason = arm9tdmi_examine_debug_reason;
 	arm7_9-&gt;change_to_arm = arm9tdmi_change_to_arm;
 	arm7_9-&gt;read_core_regs = arm9tdmi_read_core_regs;
 	arm7_9-&gt;read_core_regs_target_buffer = arm9tdmi_read_core_regs_target_buffer;
 	arm7_9-&gt;read_xpsr = arm9tdmi_read_xpsr;
-	
+
 	arm7_9-&gt;write_xpsr = arm9tdmi_write_xpsr;
 	arm7_9-&gt;write_xpsr_im8 = arm9tdmi_write_xpsr_im8;
 	arm7_9-&gt;write_core_regs = arm9tdmi_write_core_regs;
-	
+
 	arm7_9-&gt;load_word_regs = arm9tdmi_load_word_regs;
 	arm7_9-&gt;load_hword_reg = arm9tdmi_load_hword_reg;
 	arm7_9-&gt;load_byte_reg = arm9tdmi_load_byte_reg;
-	
+
 	arm7_9-&gt;store_word_regs = arm9tdmi_store_word_regs;
 	arm7_9-&gt;store_hword_reg = arm9tdmi_store_hword_reg;
 	arm7_9-&gt;store_byte_reg = arm9tdmi_store_byte_reg;
-	
+
 	arm7_9-&gt;write_pc = arm9tdmi_write_pc;
 	arm7_9-&gt;branch_resume = arm9tdmi_branch_resume;
 	arm7_9-&gt;branch_resume_thumb = arm9tdmi_branch_resume_thumb;
 
 	arm7_9-&gt;enable_single_step = arm9tdmi_enable_single_step;
 	arm7_9-&gt;disable_single_step = arm9tdmi_disable_single_step;
-	
+
 	arm7_9-&gt;pre_debug_entry = NULL;
 	arm7_9-&gt;post_debug_entry = NULL;
-	
+
 	arm7_9-&gt;pre_restore_context = NULL;
 	arm7_9-&gt;post_restore_context = NULL;
 
 	/* initialize arch-specific breakpoint handling */
 	arm7_9-&gt;arm_bkpt = 0xdeeedeee;
 	arm7_9-&gt;thumb_bkpt = 0xdeee;
-	
+
 	arm7_9-&gt;dbgreq_adjust_pc = 3;
 	arm7_9-&gt;arch_info = arm9tdmi;
-	
+
 	arm9tdmi-&gt;common_magic = ARM9TDMI_COMMON_MAGIC;
 	arm9tdmi-&gt;arch_info = NULL;
 
@@ -1003,7 +1003,7 @@
 	{
 		arm9tdmi-&gt;variant = strdup(&quot;&quot;);
 	}
-	
+
 	arm7_9_init_arch_info(target, arm7_9);
 
 	/* override use of DBGRQ, this is safe on ARM9TDMI */
@@ -1011,7 +1011,7 @@
 
 	/* all ARM9s have the vector catch register */
 	arm7_9-&gt;has_vector_catch = 1;
-	
+
 	return ERROR_OK;
 }
 
@@ -1020,28 +1020,28 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9;
 	arm9tdmi_common_t *arm9tdmi;
-	
+
 	if (armv4_5-&gt;common_magic != ARMV4_5_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm7_9 = armv4_5-&gt;arch_info;
 	if (arm7_9-&gt;common_magic != ARM7_9_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	arm9tdmi = arm7_9-&gt;arch_info;
 	if (arm9tdmi-&gt;common_magic != ARM9TDMI_COMMON_MAGIC)
 	{
 		return -1;
 	}
-	
+
 	*armv4_5_p = armv4_5;
 	*arm7_9_p = arm7_9;
 	*arm9tdmi_p = arm9tdmi;
-	
+
 	return ERROR_OK;
 }
 
@@ -1052,24 +1052,24 @@
 	arm9tdmi_common_t *arm9tdmi = calloc(1,sizeof(arm9tdmi_common_t));
 
 	arm9tdmi_init_arch_info(target, arm9tdmi, target-&gt;tap, target-&gt;variant);
-	
+
 	return ERROR_OK;
 }
 
 int arm9tdmi_register_commands(struct command_context_s *cmd_ctx)
 {
 	int retval;
-	
+
 	command_t *arm9tdmi_cmd;
-	
-		
+
+
 	retval = arm7_9_register_commands(cmd_ctx);
-	
+
 	arm9tdmi_cmd = register_command(cmd_ctx, NULL, &quot;arm9tdmi&quot;, NULL, COMMAND_ANY, &quot;arm9tdmi specific commands&quot;);
 
 	register_command(cmd_ctx, arm9tdmi_cmd, &quot;vector_catch&quot;, handle_arm9tdmi_catch_vectors_command, COMMAND_EXEC, &quot;catch arm920t vectors ['all'|'none'|'&lt;vec1 vec2 ...&gt;']&quot;);
-	
-	
+
+
 	return retval;
 
 }
@@ -1083,22 +1083,22 @@
 	reg_t *vector_catch;
 	u32 vector_catch_value;
 	int i, j;
-	
+
 	if (arm9tdmi_get_arch_pointers(target, &amp;armv4_5, &amp;arm7_9, &amp;arm9tdmi) != ERROR_OK)
 	{
 		command_print(cmd_ctx, &quot;current target isn't an ARM9TDMI based target&quot;);
 		return ERROR_OK;
 	}
-	
+
 	vector_catch = &amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_VEC_CATCH];
-	
+
 	/* read the vector catch register if necessary */
 	if (!vector_catch-&gt;valid)
 		embeddedice_read_reg(vector_catch);
-	
+
 	/* get the current setting */
 	vector_catch_value = buf_get_u32(vector_catch-&gt;value, 0, 32);
-	
+
 	if (argc &gt; 0)
 	{
 		vector_catch_value = 0x0;
@@ -1123,25 +1123,25 @@
 						break;
 					}
 				}
-				
+
 				/* complain if vector wasn't found */
 				if (!arm9tdmi_vectors[j].name)
 				{
 					command_print(cmd_ctx, &quot;vector '%s' not found, leaving current setting unchanged&quot;, args[i]);
-					
+
 					/* reread current setting */
 					vector_catch_value = buf_get_u32(vector_catch-&gt;value, 0, 32);
-					
+
 					break;
 				}
 			}
 		}
-		
+
 		/* store new settings */
 		buf_set_u32(vector_catch-&gt;value, 0, 32, vector_catch_value);
 		embeddedice_store_reg(vector_catch);
 	}
-		
+
 	/* output current settings (skip RESERVED vector) */
 	for (i = 0; i &lt; 8; i++)
 	{
@@ -1149,7 +1149,7 @@
 		{
 			command_print(cmd_ctx, &quot;%s: %s&quot;, arm9tdmi_vectors[i].name,
 				(vector_catch_value &amp; (1 &lt;&lt; i)) ? &quot;catch&quot; : &quot;don't catch&quot;);
-		}  
+		}
 	}
 
 	return ERROR_OK;

Modified: trunk/src/target/cortex_swjdp.c
===================================================================
--- trunk/src/target/cortex_swjdp.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/cortex_swjdp.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -44,7 +44,7 @@
 /*
  * Transaction Mode:
  * swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
- * Uses Overrun checking mode and does not do actual JTAG send/receive or transaction 
+ * Uses Overrun checking mode and does not do actual JTAG send/receive or transaction
  * result checking until swjdp_end_transaction()
  * This must be done before using or deallocating any return variables.
  * swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC
@@ -63,8 +63,8 @@
 {
 	scan_field_t fields[2];
 	u8 out_addr_buf;
-	
-	jtag_add_end_state(TAP_RTI);
+
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, instr, NULL);
 
 	fields[0].tap = jtag_info-&gt;tap;
@@ -99,8 +99,8 @@
 	scan_field_t fields[2];
 	u8 out_value_buf[4];
 	u8 out_addr_buf;
-	
-	jtag_add_end_state(TAP_RTI);
+
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_set_instr(jtag_info, instr, NULL);
 
 	fields[0].tap = jtag_info-&gt;tap;
@@ -138,7 +138,7 @@
 	return ERROR_OK;
 }
 
-/* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */ 
+/* scan_inout_check adds one extra inscan for DPAP_READ commands to read variables */
 int scan_inout_check(swjdp_common_t *swjdp, u8 instr, u8 reg_addr, u8 RnW, u8 *outvalue, u8 *invalue)
 {
 	swjdp_scan(swjdp-&gt;jtag_info, instr, reg_addr, RnW, outvalue, NULL, NULL);
@@ -146,7 +146,7 @@
 	{
 		swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
 	}
-	
+
 	/* In TRANS_MODE_ATOMIC all SWJDP_IR_APACC transactions wait for ack=OK/FAULT and the check CTRL_STAT */
 	if ((instr == SWJDP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
 	{
@@ -163,7 +163,7 @@
 	{
 		swjdp_scan_u32(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, invalue, &amp;swjdp-&gt;ack);
 	}
-	
+
 	/* In TRANS_MODE_ATOMIC all SWJDP_IR_APACC transactions wait for ack=OK/FAULT and then check CTRL_STAT */
 	if ((instr == SWJDP_IR_APACC) &amp;&amp; (swjdp-&gt;trans_mode == TRANS_MODE_ATOMIC))
 	{
@@ -179,10 +179,10 @@
 	u32 ctrlstat;
 
 	keep_alive();
-	
+
 	/* Danger!!!! BROKEN!!!! */
 	scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
-	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here???? 
+	/* Danger!!!! BROKEN!!!! Why will jtag_execute_queue() fail here????
 	R956 introduced the check on return value here and now Michael Schwingen reports
 	that this code no longer works....
 
@@ -196,9 +196,9 @@
 	scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
 	if ((retval=jtag_execute_queue())!=ERROR_OK)
 		return retval;
-	
+
 	swjdp-&gt;ack = swjdp-&gt;ack &amp; 0x7;
-	
+
 	long long then=timeval_ms();
 	while (swjdp-&gt;ack != 2)
 	{
@@ -234,13 +234,13 @@
 		else
 		{
 			u32 dcb_dhcsr,nvic_shcsr, nvic_bfar, nvic_cfsr;
-			
+
 			if (ctrlstat &amp; SSTICKYORUN)
 				LOG_ERROR(&quot;SWJ-DP OVERRUN - check clock or reduce jtag speed&quot;);
-			
+
 			if (ctrlstat &amp; SSTICKYERR)
 				LOG_ERROR(&quot;SWJ-DP STICKY ERROR&quot;);
-			
+
 			/* Clear Sticky Error Bits */
 			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_WRITE, swjdp-&gt;dp_ctrl_stat | SSTICKYORUN | SSTICKYERR, NULL);
 			scan_inout_check_u32(swjdp, SWJDP_IR_DPACC, DP_CTRL_STAT, DPAP_READ, 0, &amp;ctrlstat);
@@ -248,8 +248,8 @@
 				return retval;
 
 			LOG_DEBUG(&quot;swjdp: status 0x%x&quot;, ctrlstat);
-			
-			/* Can we find out the reason for the error ?? */			
+
+			/* Can we find out the reason for the error ?? */
 			ahbap_read_system_atomic_u32(swjdp, DCB_DHCSR, &amp;dcb_dhcsr);
 			ahbap_read_system_atomic_u32(swjdp, NVIC_SHCSR, &amp;nvic_shcsr);
 			ahbap_read_system_atomic_u32(swjdp, NVIC_CFSR, &amp;nvic_cfsr);
@@ -312,7 +312,7 @@
 int ahbap_write_reg_u32(swjdp_common_t *swjdp, u32 reg_addr, u32 value)
 {
 	u8 out_value_buf[4];
-	
+
 	buf_set_u32(out_value_buf, 0, 32, value);
 	swjdp_bankselect_apacc(swjdp, reg_addr);
 	scan_inout_check(swjdp, SWJDP_IR_APACC, reg_addr, DPAP_WRITE, out_value_buf, NULL);
@@ -350,7 +350,7 @@
 		swjdp-&gt;ap_tar_value = tar;
 	}
 	if (csw &amp; CSW_ADDRINC_MASK)
-	{ 	
+	{
 		/* Do not cache TAR value when autoincrementing */
 		swjdp-&gt;ap_tar_value = -1;
 	}
@@ -371,14 +371,14 @@
 
 	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, address &amp; 0xFFFFFFF0);
 	ahbap_read_reg_u32(swjdp, AHBAP_BD0 | (address &amp; 0xC), value );
-	
+
 	return ERROR_OK;
 }
 
 int ahbap_read_system_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 *value)
 {
 	ahbap_read_system_u32(swjdp, address, value);
-	
+
 	return swjdp_transaction_endcheck(swjdp);
 }
 
@@ -402,7 +402,7 @@
 int ahbap_write_system_atomic_u32(swjdp_common_t *swjdp, u32 address, u32 value)
 {
 	ahbap_write_system_u32(swjdp, address, value);
-	
+
 	return swjdp_transaction_endcheck(swjdp);
 }
 
@@ -419,12 +419,12 @@
 	int wcount, blocksize, writecount, errorcount = 0, retval = ERROR_OK;
 	u32 adr = address;
 	u8* pBuffer = buffer;
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	count &gt;&gt;= 2;
 	wcount = count;
-	
+
 	/* if we have an unaligned access - reorder data */
 	if (adr &amp; 0x3u)
 	{
@@ -432,7 +432,7 @@
 		{
 			int i;
 			outvalue = *((u32*)pBuffer);
-			
+
 			for (i = 0; i &lt; 4; i++ )
 			{
 				*((u8*)pBuffer + (adr &amp; 0x3)) = outvalue;
@@ -442,25 +442,25 @@
 			pBuffer += 4;
 		}
 	}
-	
+
 	while (wcount &gt; 0)
 	{
 		/* Adjust to write blocks within 4K aligned boundaries */
 		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 2;
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
-		
+
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
 			blocksize = 1;
-			
+
 		ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-		
+
 		for (writecount = 0; writecount &lt; blocksize; writecount++)
 		{
 			ahbap_write_reg(swjdp, AHBAP_DRW, buffer + 4 * writecount );
 		}
-		
+
 		if (swjdp_transaction_endcheck(swjdp) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
@@ -471,14 +471,14 @@
 		{
 			errorcount++;
 		}
-		
+
 		if (errorcount &gt; 1)
 		{
 			LOG_WARNING(&quot;Block write error address 0x%x, wcount 0x%x&quot;, address, wcount);
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
-	
+
 	return retval;
 }
 
@@ -487,32 +487,32 @@
 	u32 outvalue;
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-		
+
 	wcount = count &gt;&gt; 1;
-	
+
 	while (wcount &gt; 0)
 	{
 		int nbytes;
-		
+
 		/* Adjust to read within 4K block boundaries */
 		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 1;
-		
+
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
-		
+
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
 			blocksize = 1;
-		
+
 		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
 		writecount = blocksize;
-		
+
 		do
 		{
 			nbytes = MIN((writecount &lt;&lt; 1), 4);
-			
+
 			if (nbytes &lt; 4 )
 			{
 				if (ahbap_write_buf_u16(swjdp, buffer, nbytes, address) != ERROR_OK)
@@ -520,20 +520,20 @@
 					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
-				
+
 				address += nbytes &gt;&gt; 1;
 			}
 			else
 			{
 				outvalue = *((u32*)buffer);
-				
+
 				for (i = 0; i &lt; nbytes; i++ )
 				{
 					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
 					outvalue &gt;&gt;= 8;
 					address++;
 				}
-				
+
 				outvalue = *((u32*)buffer);
 				ahbap_write_reg_u32(swjdp, AHBAP_DRW, outvalue);
 				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
@@ -542,14 +542,14 @@
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
 			}
-			
+
 			buffer += nbytes &gt;&gt; 1;
 			writecount -= nbytes &gt;&gt; 1;
-			
+
 		} while (writecount);
 		wcount -= blocksize;
 	}
-	
+
 	return retval;
 }
 
@@ -557,12 +557,12 @@
 {
 	u32 outvalue;
 	int retval = ERROR_OK;
-	
+
 	if (count &gt;= 4)
 		return ahbap_write_buf_packed_u16(swjdp, buffer, count, address);
-		
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	while (count &gt; 0)
 	{
 		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
@@ -582,28 +582,28 @@
 	u32 outvalue;
 	int retval = ERROR_OK;
 	int wcount, blocksize, writecount, i;
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	wcount = count;
-	
+
 	while (wcount &gt; 0)
 	{
 		int nbytes;
-		
+
 		/* Adjust to read within 4K block boundaries */
 		blocksize = (0x1000 - (0xFFF &amp; address));
-		
+
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
-				
+
 		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
 		writecount = blocksize;
-		
+
 		do
 		{
 			nbytes = MIN(writecount, 4);
-			
+
 			if (nbytes &lt; 4 )
 			{
 				if (ahbap_write_buf_u8(swjdp, buffer, nbytes, address) != ERROR_OK)
@@ -611,20 +611,20 @@
 					LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
-				
+
 				address += nbytes;
 			}
 			else
 			{
 				outvalue = *((u32*)buffer);
-				
+
 				for (i = 0; i &lt; nbytes; i++ )
 				{
 					*((u8*)buffer + (address &amp; 0x3)) = outvalue;
 					outvalue &gt;&gt;= 8;
 					address++;
 				}
-				
+
 				outvalue = *((u32*)buffer);
 				ahbap_write_reg_u32(swjdp, AHBAP_DRW, outvalue);
 				if (swjdp_transaction_endcheck(swjdp) != ERROR_OK)
@@ -633,14 +633,14 @@
 					return ERROR_JTAG_DEVICE_ERROR;
 				}
 			}
-			
+
 			buffer += nbytes;
 			writecount -= nbytes;
-			
+
 		} while (writecount);
 		wcount -= blocksize;
 	}
-	
+
 	return retval;
 }
 
@@ -648,12 +648,12 @@
 {
 	u32 outvalue;
 	int retval = ERROR_OK;
-	
+
 	if (count &gt;= 4)
 		return ahbap_write_buf_packed_u8(swjdp, buffer, count, address);
-		
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	while (count &gt; 0)
 	{
 		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
@@ -664,7 +664,7 @@
 		address++;
 		buffer++;
 	}
-	
+
 	return retval;
 }
 
@@ -680,25 +680,25 @@
 	int wcount, blocksize, readcount, errorcount = 0, retval = ERROR_OK;
 	u32 adr = address;
 	u8* pBuffer = buffer;
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	count &gt;&gt;= 2;
 	wcount = count;
-	
+
 	while (wcount &gt; 0)
 	{
 		/* Adjust to read within 4K block boundaries */
 		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 2;
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
-		
+
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
 			blocksize = 1;
-		
+
 		ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_SINGLE, address);
-		
+
 		/* Scan out first read */
 		swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_APACC, AHBAP_DRW, DPAP_READ, 0, NULL, NULL);
 		for (readcount = 0; readcount &lt; blocksize - 1; readcount++)
@@ -706,27 +706,27 @@
 			/* Scan out read instruction and scan in previous value */
 			swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_APACC, AHBAP_DRW, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
 		}
-		
+
 		/* Scan in last value */
 		swjdp_scan(swjdp-&gt;jtag_info, SWJDP_IR_DPACC, DP_RDBUFF, DPAP_READ, 0, buffer + 4 * readcount, &amp;swjdp-&gt;ack);
 		if (swjdp_transaction_endcheck(swjdp) == ERROR_OK)
 		{
 			wcount = wcount - blocksize;
 			address += 4 * blocksize;
-			buffer += 4 * blocksize; 
+			buffer += 4 * blocksize;
 		}
 		else
 		{
 			errorcount++;
 		}
-		
+
 		if (errorcount &gt; 1)
 		{
 			LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
 			return ERROR_JTAG_DEVICE_ERROR;
 		}
 	}
-	
+
 	/* if we have an unaligned access - reorder data */
 	if (adr &amp; 0x3u)
 	{
@@ -734,7 +734,7 @@
 		{
 			int i;
 			u32 data = *((u32*)pBuffer);
-			
+
 			for (i = 0; i &lt; 4; i++ )
 			{
 				*((u8*)pBuffer) = (data &gt;&gt; 8 * (adr &amp; 0x3));
@@ -743,7 +743,7 @@
 			}
 		}
 	}
-	
+
 	return retval;
 }
 
@@ -752,27 +752,27 @@
 	u32 invalue;
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	wcount = count &gt;&gt; 1;
-	
+
 	while (wcount &gt; 0)
 	{
 		int nbytes;
-		
+
 		/* Adjust to read within 4K block boundaries */
 		blocksize = (0x1000 - (0xFFF &amp; address)) &gt;&gt; 1;
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
-				
+
 		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_PACKED, address);
-		
+
 		/* handle unaligned data at 4k boundary */
 		if (blocksize == 0)
 			blocksize = 1;
 		readcount = blocksize;
-		
+
 		do
 		{
 			ahbap_read_reg_u32(swjdp, AHBAP_DRW, &amp;invalue );
@@ -781,21 +781,21 @@
 				LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
-			
+
 			nbytes = MIN((readcount &lt;&lt; 1), 4);
-			
+
 			for (i = 0; i &lt; nbytes; i++ )
 			{
 				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
 				buffer++;
 				address++;
 			}
-			
+
 			readcount -= (nbytes &gt;&gt; 1);
 		} while (readcount);
 		wcount -= blocksize;
 	}
-	
+
 	return retval;
 }
 
@@ -803,12 +803,12 @@
 {
 	u32 invalue, i;
 	int retval = ERROR_OK;
-	
+
 	if (count &gt;= 4)
 		return ahbap_read_buf_packed_u16(swjdp, buffer, count, address);
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	while (count &gt; 0)
 	{
 		ahbap_setup_accessport(swjdp, CSW_16BIT | CSW_ADDRINC_SINGLE, address);
@@ -840,24 +840,24 @@
 	u32 invalue;
 	int retval = ERROR_OK;
 	int wcount, blocksize, readcount, i;
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	wcount = count;
-	
+
 	while (wcount &gt; 0)
 	{
 		int nbytes;
-		
+
 		/* Adjust to read within 4K block boundaries */
 		blocksize = (0x1000 - (0xFFF &amp; address));
-		
+
 		if (wcount &lt; blocksize)
 			blocksize = wcount;
-				
+
 		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_PACKED, address);
 		readcount = blocksize;
-		
+
 		do
 		{
 			ahbap_read_reg_u32(swjdp, AHBAP_DRW, &amp;invalue );
@@ -866,21 +866,21 @@
 				LOG_WARNING(&quot;Block read error address 0x%x, count 0x%x&quot;, address, count);
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
-			
+
 			nbytes = MIN(readcount, 4);
-			
+
 			for (i = 0; i &lt; nbytes; i++ )
 			{
 				*((u8*)buffer) = (invalue &gt;&gt; 8 * (address &amp; 0x3));
 				buffer++;
 				address++;
 			}
-			
+
 			readcount -= nbytes;
 		} while (readcount);
 		wcount -= blocksize;
 	}
-	
+
 	return retval;
 }
 
@@ -888,12 +888,12 @@
 {
 	u32 invalue;
 	int retval = ERROR_OK;
-	
+
 	if (count &gt;= 4)
 		return ahbap_read_buf_packed_u8(swjdp, buffer, count, address);
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	while (count &gt; 0)
 	{
 		ahbap_setup_accessport(swjdp, CSW_8BIT | CSW_ADDRINC_SINGLE, address);
@@ -912,12 +912,12 @@
 {
 	int retval;
 	u32 dcrdr;
-	
+
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we gave to save/restore the DCB_DCRDR when used */
-	
+
 	ahbap_read_system_atomic_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
 
 	/* ahbap_write_system_u32(swjdp, DCB_DCRSR, regnum); */
@@ -927,7 +927,7 @@
 	/* ahbap_read_system_u32(swjdp, DCB_DCRDR, value); */
 	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
 	ahbap_read_reg_u32(swjdp, AHBAP_BD0 | (DCB_DCRDR &amp; 0xC), value );
-	
+
 	retval = swjdp_transaction_endcheck(swjdp);
 	ahbap_write_system_atomic_u32(swjdp, DCB_DCRDR, dcrdr);
 	return retval;
@@ -937,14 +937,14 @@
 {
 	int retval;
 	u32 dcrdr;
-	
+
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we gave to save/restore the DCB_DCRDR when used */
-	 
+
 	ahbap_read_system_atomic_u32(swjdp, DCB_DCRDR, &amp;dcrdr);
-	
+
 	swjdp-&gt;trans_mode = TRANS_MODE_COMPOSITE;
-	
+
 	/* ahbap_write_system_u32(swjdp, DCB_DCRDR, core_regs[i]); */
 	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRDR &amp; 0xFFFFFFF0);
 	ahbap_write_reg_u32(swjdp, AHBAP_BD0 | (DCB_DCRDR &amp; 0xC), value );
@@ -952,7 +952,7 @@
 	/* ahbap_write_system_u32(swjdp, DCB_DCRSR, i | DCRSR_WnR	); */
 	ahbap_setup_accessport(swjdp, CSW_32BIT | CSW_ADDRINC_OFF, DCB_DCRSR &amp; 0xFFFFFFF0);
 	ahbap_write_reg_u32(swjdp, AHBAP_BD0 | (DCB_DCRSR &amp; 0xC), regnum | DCRSR_WnR );
-	
+
 	retval = swjdp_transaction_endcheck(swjdp);
 	ahbap_write_system_atomic_u32(swjdp, DCB_DCRDR, dcrdr);
 	return retval;
@@ -964,16 +964,16 @@
 	u32 ctrlstat;
 	int cnt = 0;
 	int retval;
-	
+
 	LOG_DEBUG(&quot; &quot;);
-	
+
 	swjdp-&gt;ap_csw_value = -1;
 	swjdp-&gt;ap_tar_value = -1;
 	swjdp-&gt;trans_mode = TRANS_MODE_ATOMIC;
 	swjdp_read_dpacc(swjdp, &amp;dummy, DP_CTRL_STAT);
 	swjdp_write_dpacc(swjdp, SSTICKYERR, DP_CTRL_STAT);
 	swjdp_read_dpacc(swjdp, &amp;dummy, DP_CTRL_STAT);
-	
+
 	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
 
 	swjdp_write_dpacc(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
@@ -1005,11 +1005,11 @@
 	swjdp-&gt;dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
 	swjdp_write_dpacc(swjdp, swjdp-&gt;dp_ctrl_stat, DP_CTRL_STAT);
 	swjdp_read_dpacc(swjdp, &amp;dummy, DP_CTRL_STAT);
-	
+
 	ahbap_read_reg_u32(swjdp, 0xFC, &amp;idreg);
 	ahbap_read_reg_u32(swjdp, 0xF8, &amp;romaddr);
-	
+
 	LOG_DEBUG(&quot;AHB-AP ID Register 0x%x, Debug ROM Address 0x%x&quot;, idreg, romaddr);
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/target/embeddedice.c
===================================================================
--- trunk/src/target/embeddedice.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/embeddedice.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -246,7 +246,7 @@
 	u8 field1_out[1];
 	u8 field2_out[1];
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(ice_reg-&gt;jtag_info, 0x2);
 
 	arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL);
@@ -309,7 +309,7 @@
 	u8 field1_out[1];
 	u8 field2_out[1];
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
@@ -400,7 +400,7 @@
 
 	LOG_DEBUG(&quot;%i: 0x%8.8x&quot;, ice_reg-&gt;addr, value);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(ice_reg-&gt;jtag_info, 0x2);
 
 	arm_jtag_set_instr(ice_reg-&gt;jtag_info, ice_reg-&gt;jtag_info-&gt;intest_instr, NULL);
@@ -426,7 +426,7 @@
 	u8 field1_out[1];
 	u8 field2_out[1];
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 
@@ -495,7 +495,7 @@
 	else
 		return ERROR_INVALID_ARGUMENTS;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(jtag_info, 0x2);
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
 

Modified: trunk/src/target/etb.c
===================================================================
--- trunk/src/target/etb.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/etb.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -184,7 +184,7 @@
 	scan_field_t fields[3];
 	int i;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	etb_scann(etb, 0x0);
 	etb_set_instr(etb, 0xc);
 
@@ -255,7 +255,7 @@
 
 	LOG_DEBUG(&quot;%i&quot;, etb_reg-&gt;addr);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	etb_scann(etb_reg-&gt;etb, 0x0);
 	etb_set_instr(etb_reg-&gt;etb, 0xc);
 
@@ -351,7 +351,7 @@
 
 	LOG_DEBUG(&quot;%i: 0x%8.8x&quot;, etb_reg-&gt;addr, value);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	etb_scann(etb_reg-&gt;etb, 0x0);
 	etb_set_instr(etb_reg-&gt;etb, 0xc);
 

Modified: trunk/src/target/etm.c
===================================================================
--- trunk/src/target/etm.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/etm.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -335,7 +335,7 @@
 
 	LOG_DEBUG(&quot;%i&quot;, etm_reg-&gt;addr);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(etm_reg-&gt;jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL);
 
@@ -426,7 +426,7 @@
 
 	LOG_DEBUG(&quot;%i: 0x%8.8x&quot;, etm_reg-&gt;addr, value);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	arm_jtag_scann(etm_reg-&gt;jtag_info, 0x6);
 	arm_jtag_set_instr(etm_reg-&gt;jtag_info, etm_reg-&gt;jtag_info-&gt;intest_instr, NULL);
 

Modified: trunk/src/target/feroceon.c
===================================================================
--- trunk/src/target/feroceon.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/feroceon.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -91,7 +91,7 @@
 	.assert_reset = feroceon_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm926ejs_soft_reset_halt,
-	
+
 	.get_gdb_reg_list = armv4_5_get_gdb_reg_list,
 
 	.read_memory = arm7_9_read_memory,
@@ -99,7 +99,7 @@
 	.bulk_write_memory = feroceon_bulk_write_memory,
 	.checksum_memory = arm7_9_checksum_memory,
 	.blank_check_memory = arm7_9_blank_check_memory,
-	
+
 	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
@@ -121,17 +121,17 @@
 	u8 out_buf[4];
 	u8 instr_buf[4];
 	u8 sysspeed_buf = 0x0;
-	
+
 	/* prepare buffer */
 	buf_set_u32(out_buf, 0, 32, 0);
-	
+
 	buf_set_u32(instr_buf, 0, 32, flip_u32(instr, 32));
-	
-	jtag_add_end_state(TAP_PD);
+
+	jtag_add_end_state(TAP_DRPAUSE);
 	arm_jtag_scann(jtag_info, 0x1);
-	
+
 	arm_jtag_set_instr(jtag_info, jtag_info-&gt;intest_instr, NULL);
-		
+
 	fields[0].tap = jtag_info-&gt;tap;
 	fields[0].num_bits = 32;
 	fields[0].out_value = out_buf;
@@ -141,7 +141,7 @@
 	fields[0].in_handler_priv = NULL;
 	fields[0].in_check_value = NULL;
 	fields[0].in_check_mask = NULL;
-	
+
 	fields[1].tap = jtag_info-&gt;tap;
 	fields[1].num_bits = 3;
 	fields[1].out_value = &amp;sysspeed_buf;
@@ -151,7 +151,7 @@
 	fields[1].in_check_mask = NULL;
 	fields[1].in_handler = NULL;
 	fields[1].in_handler_priv = NULL;
-		
+
 	fields[2].tap = jtag_info-&gt;tap;
 	fields[2].num_bits = 32;
 	fields[2].out_value = instr_buf;
@@ -165,7 +165,7 @@
 	jtag_add_dr_scan(3, fields, -1);
 
 	/* no jtag_add_runtest(0, -1) here */
-	
+
 	return ERROR_OK;
 }
 
@@ -174,9 +174,9 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-	
+
 	/*
-	 * save r0 before using it and put system in ARM state 
+	 * save r0 before using it and put system in ARM state
 	 * to allow common handling of ARM and THUMB debugging
 	 */
 
@@ -221,7 +221,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_STMIA(0, mask &amp; 0xffff, 0, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -276,7 +276,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_MRS(0, spsr &amp; 1), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -299,7 +299,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	LOG_DEBUG(&quot;xpsr: %8.8x, spsr: %i&quot;, xpsr, spsr);
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_MSR_IM(xpsr &amp; 0xff, 0, 1, spsr), 0, NULL, 0);
@@ -358,7 +358,7 @@
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
-		
+
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_LDMIA(0, mask &amp; 0xffff, 0, 0), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -390,13 +390,13 @@
 void feroceon_branch_resume_thumb(target_t *target)
 {
 	LOG_DEBUG(&quot;-&quot;);
-	
+
 	armv4_5_common_t *armv4_5 = target-&gt;arch_info;
 	arm7_9_common_t *arm7_9 = armv4_5-&gt;arch_info;
 	arm_jtag_t *jtag_info = &amp;arm7_9-&gt;jtag_info;
 	u32 r0 = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[0].value, 0, 32);
 	u32 pc = buf_get_u32(armv4_5-&gt;core_cache-&gt;reg_list[15].value, 0, 32);
-	(void)(r0); // use R0... 
+	(void)(r0); // use R0...
 
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_NOP, 0, NULL, 0);
@@ -411,7 +411,7 @@
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_LDMIA(0, 0x1), 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
- 
+
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, pc, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
 	arm9tdmi_clock_out(jtag_info, ARMV4_5_T_NOP, 0, NULL, 0);
@@ -523,7 +523,7 @@
 	 * We can't use the dcc flow control bits, so let's transfer data
 	 * with 31 bits and flip the MSB each time a new data word is sent.
 	 */
-	static u32 dcc_code[] = 
+	static u32 dcc_code[] =
 	{
 		0xee115e10,	/* 3:	mrc	p14, 0, r5, c1, c0, 0	*/
 		0xe3a0301e,	/* 1:	mov	r3, #30			*/
@@ -586,7 +586,7 @@
 	armv4_5-&gt;core_cache-&gt;reg_list[0].dirty = 1;
 	armv4_5-&gt;core_state = ARMV4_5_STATE_ARM;
 
-	embeddedice_write_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA], 0); 
+	embeddedice_write_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA], 0);
 	arm7_9_resume(target, 0, arm7_9-&gt;dcc_working_area-&gt;address, 1, 1);
 
 	/* send data over */
@@ -597,12 +597,12 @@
 	{
 		u32 y = target_buffer_get_u32(target, buffer);
 		u32 z = (x &gt;&gt; 1) | (y &gt;&gt; shift) | (flip ^= 0x80000000);
-		embeddedice_write_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA], z); 
+		embeddedice_write_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA], z);
 		x = y &lt;&lt; (32 - shift);
 		if (++shift &gt;= 32 || i + 1 &gt;= count)
 		{
 			z = (x &gt;&gt; 1) | (flip ^= 0x80000000);
-			embeddedice_write_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA], z); 
+			embeddedice_write_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_DATA], z);
 			x = 0;
 			shift = 1;
 		}
@@ -644,7 +644,7 @@
 	armv4_5_common_t *armv4_5;
 	arm7_9_common_t *arm7_9;
 	arm926ejs_common_t *arm926ejs = calloc(1,sizeof(arm926ejs_common_t));
-  
+
 	arm926ejs_init_arch_info(target, arm926ejs, target-&gt;tap, target-&gt;variant);
 
 	armv4_5 = target-&gt;arch_info;
@@ -678,8 +678,8 @@
 	arm7_9-&gt;set_special_dbgrq = feroceon_set_dbgrq;
 
 	/* only one working comparator */
-	arm7_9-&gt;wp_available_max = 1; 
-	arm7_9-&gt;wp1_used_default = -1; 
+	arm7_9-&gt;wp_available_max = 1;
+	arm7_9-&gt;wp1_used_default = -1;
 
 	return ERROR_OK;
 }
@@ -694,27 +694,27 @@
 	retval = arm9tdmi_examine(target);
 	if (retval!=ERROR_OK)
 		return retval;
-			
+
 	armv4_5 = target-&gt;arch_info;
 	arm7_9 = armv4_5-&gt;arch_info;
-	
+
 	/* the COMMS_CTRL bits are all contiguous */
 	if (buf_get_u32(arm7_9-&gt;eice_cache-&gt;reg_list[EICE_COMMS_CTRL].value, 2, 4) != 6)
 		LOG_ERROR(&quot;unexpected Feroceon EICE version signature&quot;);
-	
-	arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL].size = 6; 
-	arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_STAT].size = 5; 
+
+	arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL].size = 6;
+	arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_STAT].size = 5;
 	arm7_9-&gt;has_monitor_mode = 1;
-	
+
 	/* vector catch reg is not initialized on reset */
 	embeddedice_set_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_VEC_CATCH], 0);
-	
+
 	/* clear monitor mode, enable comparators */
 	embeddedice_read_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL]);
-	jtag_execute_queue(); 
+	jtag_execute_queue();
 	buf_set_u32(arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL].value, 4, 1, 0);
-	buf_set_u32(arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL].value, 5, 1, 0); 
+	buf_set_u32(arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL].value, 5, 1, 0);
 	embeddedice_store_reg(&amp;arm7_9-&gt;eice_cache-&gt;reg_list[EICE_DBG_CTRL]);
-	
+
 	return ERROR_OK;
 }

Modified: trunk/src/target/mips_ejtag.c
===================================================================
--- trunk/src/target/mips_ejtag.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/mips_ejtag.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -65,7 +65,7 @@
 {
 	scan_field_t field;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IDCODE, NULL);
 
@@ -92,7 +92,7 @@
 {
 	scan_field_t field;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_IMPCODE, NULL);
 
@@ -202,7 +202,7 @@
 int mips_ejtag_enter_debug(mips_ejtag_t *ejtag_info)
 {
 	u32 ejtag_ctrl;
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
 
 	/* set debug break bit */

Modified: trunk/src/target/mips_m4k.c
===================================================================
--- trunk/src/target/mips_m4k.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/mips_m4k.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -67,7 +67,7 @@
 	.assert_reset = mips_m4k_assert_reset,
 	.deassert_reset = mips_m4k_deassert_reset,
 	.soft_reset_halt = mips_m4k_soft_reset_halt,
-	
+
 	.get_gdb_reg_list = mips32_get_gdb_reg_list,
 
 	.read_memory = mips_m4k_read_memory,
@@ -75,7 +75,7 @@
 	.bulk_write_memory = mips_m4k_bulk_write_memory,
 	.checksum_memory = NULL,
 	.blank_check_memory = NULL,
-	
+
 	.run_algorithm = mips32_run_algorithm,
 
 	.add_breakpoint = mips_m4k_add_breakpoint,
@@ -91,10 +91,10 @@
 };
 
 int mips_m4k_examine_debug_reason(target_t *target)
-{	
+{
 	int break_status;
 	int retval;
-	
+
 	if ((target-&gt;debug_reason != DBG_REASON_DBGRQ)
 		&amp;&amp; (target-&gt;debug_reason != DBG_REASON_SINGLESTEP))
 	{
@@ -108,7 +108,7 @@
 				return retval;
 			target-&gt;debug_reason = DBG_REASON_BREAKPOINT;
 		}
-		
+
 		/* get info about data breakpoint support */
 		if ((retval = target_read_u32(target, 0xFF302000, &amp;break_status)) != ERROR_OK)
 			return retval;
@@ -120,7 +120,7 @@
 			target-&gt;debug_reason = DBG_REASON_WATCHPOINT;
 		}
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -129,29 +129,29 @@
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
 	u32 debug_reg;
-	
+
 	/* read debug register */
 	mips_ejtag_read_debug(ejtag_info, &amp;debug_reg);
-	
+
 	/* make sure break uit configured */
 	mips32_configure_break_unit(target);
-	
+
 	/* attempt to find halt reason */
 	mips_m4k_examine_debug_reason(target);
-	
+
 	/* clear single step if active */
 	if (debug_reg &amp; EJTAG_DEBUG_DSS)
 	{
 		/* stopped due to single step - clear step bit */
 		mips_ejtag_config_step(ejtag_info, 0);
 	}
-	
+
 	mips32_save_context(target);
-	
-	LOG_DEBUG(&quot;entered debug state at PC 0x%x, target-&gt;state: %s&quot;, 
-		*(u32*)(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value), 
+
+	LOG_DEBUG(&quot;entered debug state at PC 0x%x, target-&gt;state: %s&quot;,
+		*(u32*)(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value),
 		  Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name);
-	
+
 	return ERROR_OK;
 }
 
@@ -161,48 +161,48 @@
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
 	u32 ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl;
-	
+
 	/* read ejtag control reg */
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
 	mips_ejtag_drscan_32(ejtag_info, &amp;ejtag_ctrl);
-	
+
 	/* clear this bit before handling polling
 	 * as after reset registers will read zero */
 	if (ejtag_ctrl &amp; EJTAG_CTRL_ROCC)
 	{
 		/* we have detected a reset, clear flag
 		 * otherwise ejtag will not work */
-		jtag_add_end_state(TAP_RTI);
+		jtag_add_end_state(TAP_IDLE);
 		ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl &amp; ~EJTAG_CTRL_ROCC;
-		
+
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_CONTROL, NULL);
 		mips_ejtag_drscan_32(ejtag_info, &amp;ejtag_ctrl);
 		LOG_DEBUG(&quot;Reset Detected&quot;);
 	}
-	
+
 	/* check for processor halted */
 	if (ejtag_ctrl &amp; EJTAG_CTRL_BRKST)
 	{
 		if ((target-&gt;state == TARGET_RUNNING) || (target-&gt;state == TARGET_RESET))
 		{
-			jtag_add_end_state(TAP_RTI);
+			jtag_add_end_state(TAP_IDLE);
 			mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT, NULL);
-			
+
 			target-&gt;state = TARGET_HALTED;
-			
+
 			if ((retval = mips_m4k_debug_entry(target)) != ERROR_OK)
 				return retval;
-			
+
 			target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 		}
 		else if (target-&gt;state == TARGET_DEBUG_RUNNING)
 		{
 			target-&gt;state = TARGET_HALTED;
-			
+
 			if ((retval = mips_m4k_debug_entry(target)) != ERROR_OK)
 				return retval;
-			
+
 			target_call_event_callbacks(target, TARGET_EVENT_DEBUG_HALTED);
 		}
 	}
@@ -210,9 +210,9 @@
 	{
 		target-&gt;state = TARGET_RUNNING;
 	}
-	
+
 //	LOG_DEBUG(&quot;ctrl=0x%08X&quot;, ejtag_ctrl);
-	
+
 	return ERROR_OK;
 }
 
@@ -220,22 +220,22 @@
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	
-	LOG_DEBUG(&quot;target-&gt;state: %s&quot;, 
+
+	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
 		  Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name);
-	
+
 	if (target-&gt;state == TARGET_HALTED)
 	{
 		LOG_DEBUG(&quot;target was already halted&quot;);
 		return ERROR_OK;
 	}
-	
+
 	if (target-&gt;state == TARGET_UNKNOWN)
 	{
 		LOG_WARNING(&quot;target was in unknown state when halt was requested&quot;);
 	}
-	
-	if (target-&gt;state == TARGET_RESET) 
+
+	if (target-&gt;state == TARGET_RESET)
 	{
 		if ((jtag_reset_config &amp; RESET_SRST_PULLS_TRST) &amp;&amp; jtag_srst)
 		{
@@ -248,16 +248,16 @@
 			 * debug entry was already prepared in mips32_prepare_reset_halt()
 			 */
 			target-&gt;debug_reason = DBG_REASON_DBGRQ;
-			
+
 			return ERROR_OK;
 		}
 	}
-	
+
 	/* break processor */
 	mips_ejtag_enter_debug(ejtag_info);
-	
+
 	target-&gt;debug_reason = DBG_REASON_DBGRQ;
-	
+
 	return ERROR_OK;
 }
 
@@ -266,28 +266,28 @@
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
 	mips_m4k_common_t *mips_m4k = mips32-&gt;arch_info;
-	
-	LOG_DEBUG(&quot;target-&gt;state: %s&quot;, 
+
+	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
 		Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name);
-	
+
 	if (!(jtag_reset_config &amp; RESET_HAS_SRST))
 	{
 		LOG_ERROR(&quot;Can't assert SRST&quot;);
 		return ERROR_FAIL;
 	}
-	
+
 	if (target-&gt;reset_halt)
 	{
 		/* use hardware to catch reset */
-		jtag_add_end_state(TAP_RTI);
+		jtag_add_end_state(TAP_IDLE);
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_EJTAGBOOT, NULL);
 	}
 	else
 	{
-		jtag_add_end_state(TAP_RTI);
+		jtag_add_end_state(TAP_IDLE);
 		mips_ejtag_set_instr(ejtag_info, EJTAG_INST_NORMALBOOT, NULL);
 	}
-	
+
 	if (strcmp(mips_m4k-&gt;variant, &quot;ejtag_srst&quot;) == 0)
 	{
 		u32 ejtag_ctrl = ejtag_info-&gt;ejtag_ctrl | EJTAG_CTRL_PRRST | EJTAG_CTRL_PERRST;
@@ -307,7 +307,7 @@
 			jtag_add_reset(0, 1);
 		}
 	}
-	
+
 	target-&gt;state = TARGET_RESET;
 	jtag_add_sleep(50000);
 
@@ -319,18 +319,18 @@
 		if ((retval = target_halt(target))!=ERROR_OK)
 			return retval;
 	}
-	
+
 	return ERROR_OK;
 }
 
 int mips_m4k_deassert_reset(target_t *target)
 {
-	LOG_DEBUG(&quot;target-&gt;state: %s&quot;, 
+	LOG_DEBUG(&quot;target-&gt;state: %s&quot;,
 		Jim_Nvp_value2name_simple( nvp_target_state, target-&gt;state )-&gt;name);
-	
+
 	/* deassert reset lines */
 	jtag_add_reset(0, 0);
-	
+
 	return ERROR_OK;
 }
 
@@ -344,15 +344,15 @@
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	
+
 	/* configure single step mode */
 	mips_ejtag_config_step(ejtag_info, 1);
-	
+
 	/* exit debug mode */
 	mips_ejtag_exit_debug(ejtag_info, 1);
-	
+
 	mips_m4k_debug_entry(target);
-	
+
 	return ERROR_OK;
 }
 
@@ -362,20 +362,20 @@
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
 	breakpoint_t *breakpoint = NULL;
 	u32 resume_pc;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_WARNING(&quot;target not halted&quot;);
 		return ERROR_TARGET_NOT_HALTED;
 	}
-	
+
 	if (!debug_execution)
 	{
 		target_free_all_working_areas(target);
 		mips_m4k_enable_breakpoints(target);
 		mips_m4k_enable_watchpoints(target);
 	}
-	
+
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
 	if (!current)
 	{
@@ -383,11 +383,11 @@
 		mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].dirty = 1;
 		mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].valid = 1;
 	}
-	
+
 	resume_pc = buf_get_u32(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value, 0, 32);
-	
+
 	mips32_restore_context(target);
-	
+
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
 	{
@@ -400,14 +400,14 @@
 			mips_m4k_set_breakpoint(target, breakpoint);
 		}
 	}
-	
+
 	/* exit debug mode - enable interrupts if required */
 	mips_ejtag_exit_debug(ejtag_info, !debug_execution);
 	target-&gt;debug_reason = DBG_REASON_NOTHALTED;
-	
+
 	/* registers are now invalid */
 	mips32_invalidate_core_regs(target);
-	
+
 	if (!debug_execution)
 	{
 		target-&gt;state = TARGET_RUNNING;
@@ -420,7 +420,7 @@
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
 		LOG_DEBUG(&quot;target debug resumed at 0x%x&quot;, resume_pc);
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -440,43 +440,43 @@
 	/* current = 1: continue on current pc, otherwise continue at &lt;address&gt; */
 	if (!current)
 		buf_set_u32(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value, 0, 32, address);
-	
+
 	/* the front-end may request us not to handle breakpoints */
 	if (handle_breakpoints)
 		if ((breakpoint = breakpoint_find(target, buf_get_u32(mips32-&gt;core_cache-&gt;reg_list[MIPS32_PC].value, 0, 32))))
 			mips_m4k_unset_breakpoint(target, breakpoint);
-	
+
 	/* restore context */
 	mips32_restore_context(target);
-	
+
 	/* configure single step mode */
 	mips_ejtag_config_step(ejtag_info, 1);
-	
+
 	target-&gt;debug_reason = DBG_REASON_SINGLESTEP;
-	
+
 	target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-	
+
 	/* exit debug mode */
 	mips_ejtag_exit_debug(ejtag_info, 1);
-	
+
 	/* registers are now invalid */
 	mips32_invalidate_core_regs(target);
-	
+
 	if (breakpoint)
 		mips_m4k_set_breakpoint(target, breakpoint);
 
 	LOG_DEBUG(&quot;target stepped &quot;);
-	
+
 	mips_m4k_debug_entry(target);
 	target_call_event_callbacks(target, TARGET_EVENT_HALTED);
-	
+
 	return ERROR_OK;
 }
 
 void mips_m4k_enable_breakpoints(struct target_s *target)
 {
 	breakpoint_t *breakpoint = target-&gt;breakpoints;
-	
+
 	/* set any pending breakpoints */
 	while (breakpoint)
 	{
@@ -490,17 +490,17 @@
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips32_comparator_t * comparator_list = mips32-&gt;inst_break_list;
-	
+
 	if (breakpoint-&gt;set)
 	{
 		LOG_WARNING(&quot;breakpoint already set&quot;);
 		return ERROR_OK;
 	}
-	
+
 	if (breakpoint-&gt;type == BKPT_HARD)
 	{
 		int bp_num = 0;
-		
+
 		while(comparator_list[bp_num].used &amp;&amp; (bp_num &lt; mips32-&gt;num_inst_bpoints))
 			bp_num++;
 		if (bp_num &gt;= mips32-&gt;num_inst_bpoints)
@@ -521,7 +521,7 @@
 	{
 
 	}
-	
+
 	return ERROR_OK;
 }
 
@@ -536,7 +536,7 @@
 		LOG_WARNING(&quot;breakpoint not set&quot;);
 		return ERROR_OK;
 	}
-	
+
 	if (breakpoint-&gt;type == BKPT_HARD)
 	{
 		int bp_num = breakpoint-&gt;set - 1;
@@ -554,26 +554,26 @@
 
 	}
 	breakpoint-&gt;set = 0;
-	
+
 	return ERROR_OK;
 }
 
 int mips_m4k_add_breakpoint(struct target_s *target, breakpoint_t *breakpoint)
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
-	
+
 	if (mips32-&gt;num_inst_bpoints_avail &lt; 1)
 	{
 		LOG_INFO(&quot;no hardware breakpoint available&quot;);
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
-	
+
 	/* default to hardware for now */
 	breakpoint-&gt;type = BKPT_HARD;
-	
+
 	mips32-&gt;num_inst_bpoints_avail--;
 	mips_m4k_set_breakpoint(target, breakpoint);
-	
+
 	return ERROR_OK;
 }
 
@@ -581,21 +581,21 @@
 {
 	/* get pointers to arch-specific information */
 	mips32_common_t *mips32 = target-&gt;arch_info;
-	
+
 	if (target-&gt;state != TARGET_HALTED)
 	{
 		LOG_WARNING(&quot;target not halted&quot;);
 		return ERROR_TARGET_NOT_HALTED;
 	}
-	
+
 	if (breakpoint-&gt;set)
 	{
 		mips_m4k_unset_breakpoint(target, breakpoint);
 	}
-	
+
 	if (breakpoint-&gt;type == BKPT_HARD)
 		mips32-&gt;num_inst_bpoints_avail++;
-	
+
 	return ERROR_OK;
 }
 
@@ -626,7 +626,7 @@
 void mips_m4k_enable_watchpoints(struct target_s *target)
 {
 	watchpoint_t *watchpoint = target-&gt;watchpoints;
-	
+
 	/* set any pending watchpoints */
 	while (watchpoint)
 	{
@@ -640,7 +640,7 @@
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	
+
 	LOG_DEBUG(&quot;address: 0x%8.8x, size: 0x%8.8x, count: 0x%8.8x&quot;, address, size, count);
 
 	if (target-&gt;state != TARGET_HALTED)
@@ -655,7 +655,7 @@
 
 	if (((size == 4) &amp;&amp; (address &amp; 0x3u)) || ((size == 2) &amp;&amp; (address &amp; 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
-	
+
 	switch (size)
 	{
 		case 4:
@@ -679,7 +679,7 @@
 {
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
-	
+
 	LOG_DEBUG(&quot;address: 0x%8.8x, size: 0x%8.8x, count: 0x%8.8x&quot;, address, size, count);
 
 	if (target-&gt;state != TARGET_HALTED)
@@ -694,7 +694,7 @@
 
 	if (((size == 4) &amp;&amp; (address &amp; 0x3u)) || ((size == 2) &amp;&amp; (address &amp; 0x1u)))
 		return ERROR_TARGET_UNALIGNED_ACCESS;
-	
+
 	switch (size)
 	{
 		case 4:
@@ -711,14 +711,14 @@
 			exit(-1);
 			break;
 	}
-	
+
 	return ERROR_OK;
 }
 
 int mips_m4k_register_commands(struct command_context_s *cmd_ctx)
 {
 	int retval;
-	
+
 	retval = mips32_register_commands(cmd_ctx);
 	return retval;
 }
@@ -726,7 +726,7 @@
 int mips_m4k_init_target(struct command_context_s *cmd_ctx, struct target_s *target)
 {
 	mips32_build_reg_cache(target);
-	
+
 	return ERROR_OK;
 }
 
@@ -738,7 +738,7 @@
 int mips_m4k_init_arch_info(target_t *target, mips_m4k_common_t *mips_m4k, jtag_tap_t *tap, const char *variant)
 {
 	mips32_common_t *mips32 = &amp;mips_m4k-&gt;mips32_common;
-	
+
 	if (variant)
 	{
 		mips_m4k-&gt;variant = strdup(variant);
@@ -747,22 +747,22 @@
 	{
 		mips_m4k-&gt;variant = strdup(&quot;&quot;);
 	}
-	
+
 	mips_m4k-&gt;common_magic = MIPSM4K_COMMON_MAGIC;
-	
+
 	/* initialize mips4k specific info */
 	mips32_init_arch_info(target, mips32, tap, variant);
 	mips32-&gt;arch_info = mips_m4k;
-	
+
 	return ERROR_OK;
 }
 
 int mips_m4k_target_create(struct target_s *target, Jim_Interp *interp)
 {
 	mips_m4k_common_t *mips_m4k = calloc(1,sizeof(mips_m4k_common_t));
-	
+
 	mips_m4k_init_arch_info(target, mips_m4k, target-&gt;tap, target-&gt;variant);
-	
+
 	return ERROR_OK;
 }
 
@@ -772,11 +772,11 @@
 	mips32_common_t *mips32 = target-&gt;arch_info;
 	mips_ejtag_t *ejtag_info = &amp;mips32-&gt;ejtag_info;
 	u32 idcode = 0;
-	
+
 	if (!target-&gt;type-&gt;examined)
 	{
 		mips_ejtag_get_idcode(ejtag_info, &amp;idcode, NULL);
-		
+
 		if (((idcode &gt;&gt; 1) &amp; 0x7FF) == 0x29)
 		{
 			/* we are using a pic32mx so select ejtag port
@@ -785,14 +785,14 @@
 			LOG_DEBUG(&quot;PIC32MX Detected - using EJTAG Interface&quot;);
 		}
 	}
-	
+
 	/* init rest of ejtag interface */
 	if ((retval = mips_ejtag_init(ejtag_info)) != ERROR_OK)
 		return retval;
-	
+
 	if ((retval = mips32_examine(target)) != ERROR_OK)
 		return retval;
-	
+
 	return ERROR_OK;
 }
 

Modified: trunk/src/target/xscale.c
===================================================================
--- trunk/src/target/xscale.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/target/xscale.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -252,7 +252,7 @@
 	u8 field2_check_value = 0x0;
 	u8 field2_check_mask = 0x1;
 
-	jtag_add_end_state(TAP_PD);
+	jtag_add_end_state(TAP_DRPAUSE);
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dcsr);
 
 	buf_set_u32(&amp;field0, 1, 1, xscale-&gt;hold_rst);
@@ -300,7 +300,7 @@
 	fields[1].out_value = xscale-&gt;reg_cache-&gt;reg_list[XSCALE_DCSR].value;
 	fields[1].in_value = NULL;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 
 	jtag_add_dr_scan(3, fields, -1);
 
@@ -332,9 +332,9 @@
 
 	int i;
 
-	path[0] = TAP_SDS;
-	path[1] = TAP_CD;
-	path[2] = TAP_SD;
+	path[0] = TAP_DRSELECT;
+	path[1] = TAP_DRCAPTURE;
+	path[2] = TAP_DRSHIFT;
 
 	fields[0].tap = xscale-&gt;jtag_info.tap;
 	fields[0].num_bits = 3;
@@ -362,9 +362,9 @@
 	fields[2].in_value = NULL;
 	jtag_set_check_value(fields+2, &amp;field2_check_value, &amp;field2_check_mask, NULL);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dbgtx);
-	jtag_add_runtest(1, -1); /* ensures that we're in the TAP_RTI state as the above could be a no-op */
+	jtag_add_runtest(1, -1); /* ensures that we're in the TAP_IDLE state as the above could be a no-op */
 
 	/* repeat until all words have been collected */
 	int attempts=0;
@@ -379,7 +379,7 @@
 			fields[1].in_handler_priv = (u8*)&amp;field1[i];
 
 			jtag_add_pathmove(3, path);
-			jtag_add_dr_scan(3, fields, TAP_RTI);
+			jtag_add_dr_scan(3, fields, TAP_IDLE);
 			words_scheduled++;
 		}
 
@@ -442,20 +442,20 @@
 	u8 field2_check_value = 0x0;
 	u8 field2_check_mask = 0x1;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dbgtx);
 
-	path[0] = TAP_SDS;
-	path[1] = TAP_CD;
-	path[2] = TAP_SD;
+	path[0] = TAP_DRSELECT;
+	path[1] = TAP_DRCAPTURE;
+	path[2] = TAP_DRSHIFT;
 
-	noconsume_path[0] = TAP_SDS;
-	noconsume_path[1] = TAP_CD;
-	noconsume_path[2] = TAP_E1D;
-	noconsume_path[3] = TAP_PD;
-	noconsume_path[4] = TAP_E2D;
-	noconsume_path[5] = TAP_SD;
+	noconsume_path[0] = TAP_DRSELECT;
+	noconsume_path[1] = TAP_DRCAPTURE;
+	noconsume_path[2] = TAP_DREXIT1;
+	noconsume_path[3] = TAP_DRPAUSE;
+	noconsume_path[4] = TAP_DREXIT2;
+	noconsume_path[5] = TAP_DRSHIFT;
 
 	fields[0].tap = xscale-&gt;jtag_info.tap;
 	fields[0].num_bits = 3;
@@ -499,7 +499,7 @@
 			jtag_add_pathmove(sizeof(noconsume_path)/sizeof(*noconsume_path), noconsume_path);
 		}
 
-		jtag_add_dr_scan(3, fields, TAP_RTI);
+		jtag_add_dr_scan(3, fields, TAP_IDLE);
 
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
@@ -551,7 +551,7 @@
 	u8 field2_check_value = 0x0;
 	u8 field2_check_mask = 0x1;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dbgrx);
 
@@ -588,7 +588,7 @@
 	LOG_DEBUG(&quot;polling RX&quot;);
 	for (;;)
 	{
-		jtag_add_dr_scan(3, fields, TAP_RTI);
+		jtag_add_dr_scan(3, fields, TAP_IDLE);
 
 		if ((retval = jtag_execute_queue()) != ERROR_OK)
 		{
@@ -617,7 +617,7 @@
 
 	/* set rx_valid */
 	field2 = 0x1;
-	jtag_add_dr_scan(3, fields, TAP_RTI);
+	jtag_add_dr_scan(3, fields, TAP_IDLE);
 
 	if ((retval = jtag_execute_queue()) != ERROR_OK)
 	{
@@ -640,7 +640,7 @@
 
 	int done_count = 0;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dbgrx);
 
@@ -683,7 +683,7 @@
 				3,
 				bits,
 				t,
-				TAP_RTI);
+				TAP_IDLE);
 		buffer += size;
 	}
 
@@ -726,7 +726,7 @@
 	if (ext_dbg_brk != -1)
 		xscale-&gt;external_debug_break = ext_dbg_brk;
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dcsr);
 
 	buf_set_u32(&amp;field0, 1, 1, xscale-&gt;hold_rst);
@@ -796,7 +796,7 @@
 
 	LOG_DEBUG(&quot;loading miniIC at 0x%8.8x&quot;, va);
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.ldic); /* LDIC */
 
 	/* CMD is b010 for Main IC and b011 for Mini IC */
@@ -859,7 +859,7 @@
 
 	scan_field_t fields[2];
 
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.ldic); /* LDIC */
 
 	/* CMD for invalidate IC line b000, bits [6:4] b000 */
@@ -1597,7 +1597,7 @@
 	/* select DCSR instruction (set endstate to R-T-I to ensure we don't
 	 * end up in T-L-R, which would reset JTAG
 	 */
-	jtag_add_end_state(TAP_RTI);
+	jtag_add_end_state(TAP_IDLE);
 	xscale_jtag_set_instr(xscale-&gt;jtag_info.tap, xscale-&gt;jtag_info.dcsr);
 
 	/* set Hold reset, Halt mode and Trap Reset */
@@ -1620,7 +1620,7 @@
 
     if (target-&gt;reset_halt)
     {
-    	int retval;
+	int retval;
 		if ((retval = target_halt(target))!=ERROR_OK)
 			return retval;
     }
@@ -1671,7 +1671,7 @@
 		/* wait 300ms; 150 and 100ms were not enough */
 		jtag_add_sleep(300*1000);
 
-		jtag_add_runtest(2030, TAP_RTI);
+		jtag_add_runtest(2030, TAP_IDLE);
 		jtag_execute_queue();
 
 		/* set Hold reset, Halt mode and Trap Reset */
@@ -1734,7 +1734,7 @@
 		xscale_load_ic(target, 1, 0x0, xscale-&gt;low_vectors);
 		xscale_load_ic(target, 1, 0xffff0000, xscale-&gt;high_vectors);
 
-		jtag_add_runtest(30, TAP_RTI);
+		jtag_add_runtest(30, TAP_IDLE);
 
 		jtag_add_sleep(100000);
 
@@ -3381,7 +3381,7 @@
 		command_print(cmd_ctx, &quot;icache %s&quot;, (xscale-&gt;armv4_5_mmu.armv4_5_cache.i_cache_enabled) ? &quot;enabled&quot; : &quot;disabled&quot;);
 
 	if (dcache)
-	 	command_print(cmd_ctx, &quot;dcache %s&quot;, (xscale-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled) ? &quot;enabled&quot; : &quot;disabled&quot;);
+		command_print(cmd_ctx, &quot;dcache %s&quot;, (xscale-&gt;armv4_5_mmu.armv4_5_cache.d_u_cache_enabled) ? &quot;enabled&quot; : &quot;disabled&quot;);
 
 	return ERROR_OK;
 }

Modified: trunk/src/xsvf/xsvf.c
===================================================================
--- trunk/src/xsvf/xsvf.c	2008-12-12 22:14:21 UTC (rev 1231)
+++ trunk/src/xsvf/xsvf.c	2008-12-13 06:25:50 UTC (rev 1232)
@@ -62,9 +62,9 @@
 
 enum tap_state xsvf_to_tap[] =
 {
-	TAP_TLR, TAP_RTI,
-	TAP_SDS, TAP_CD, TAP_SD, TAP_E1D, TAP_PD, TAP_E2D, TAP_UD,
-	TAP_SIS, TAP_CI, TAP_SI, TAP_E1I, TAP_PI, TAP_E2I, TAP_UI,
+	TAP_RESET, TAP_IDLE,
+	TAP_DRSELECT, TAP_DRCAPTURE, TAP_DRSHIFT, TAP_DREXIT1, TAP_DRPAUSE, TAP_DREXIT2, TAP_DRUPDATE,
+	TAP_IRSELECT, TAP_IRCAPTURE, TAP_IRSHIFT, TAP_IREXIT1, TAP_IRPAUSE, TAP_IREXIT2, TAP_IRUPDATE,
 };
 
 int tap_to_xsvf[] =
@@ -76,23 +76,23 @@
 /* xsvf has it's own definition of a statemove. This needs
  * to be handled according to the specs, which has nothing
  * to do with the JTAG spec or OpenOCD as such.
- * 
+ *
  * Implemented via jtag_add_pathmove().
  */
 void xsvf_add_statemove(enum tap_state state)
 {
 	enum tap_state moves[7]; /* max # of transitions */
-	int i; 
+	int i;
 	enum tap_state curstate = cmd_queue_cur_state;
 	u8 move = TAP_MOVE(cmd_queue_cur_state, state);
-	
-	if ((state != TAP_TLR) &amp;&amp; (state == cmd_queue_cur_state))
+
+	if ((state != TAP_RESET) &amp;&amp; (state == cmd_queue_cur_state))
 		return;
 
-	if(state==TAP_TLR) 
+	if(state==TAP_RESET)
 	{
-		jtag_add_tlr(); 
-		return; 
+		jtag_add_tlr();
+		return;
 	}
 	for (i=0; i&lt;7; i++)
 	{
@@ -135,7 +135,7 @@
 {
 	char c;
 	unsigned char uc;
-	
+
 	while ((read(fd, &amp;c, 1) &gt; 0) &amp;&amp; (c == 0x12))
 	{
 		if (*path_len &gt; max_path)
@@ -149,9 +149,9 @@
 		}
 		path[(*path_len)++] = xsvf_to_tap[uc];
 	}
-	
+
 	lseek(fd, -1, SEEK_CUR);
-	
+
 	return ERROR_OK;
 }
 
@@ -166,9 +166,9 @@
 	int do_abort = 0;
 	int unsupported = 0;
 	int tdo_mismatch = 0;
-	
+
 	int runtest_requires_tck = 0;
-	
+
 	jtag_tap_t *tap = NULL;
 	/* use NULL to indicate a &quot;plain&quot; xsvf file which accounts for
 	   additional devices in the scan chain, otherwise the device
@@ -194,7 +194,7 @@
 		command_print(cmd_ctx, &quot;file %s not found&quot;, args[0]);
 		return ERROR_OK;
 	}
-	
+
 	if ((argc &gt; 2) &amp;&amp; (strcmp(args[2], &quot;virt2&quot;) == 0))
 	{
 		runtest_requires_tck = 1;
@@ -209,7 +209,7 @@
 				if (jtag_execute_queue() != ERROR_OK)
 				{
 					tdo_mismatch = 1;
-					break;	
+					break;
 				}
 				break;
 			case 0x01:	/* XTDOMASK */
@@ -239,9 +239,9 @@
 						field.in_handler = NULL;
 						field.in_handler_priv = NULL;
 						if (tap == NULL)
-							jtag_add_plain_ir_scan(1, &amp;field, TAP_PI);
+							jtag_add_plain_ir_scan(1, &amp;field, TAP_IRPAUSE);
 						else
-							jtag_add_ir_scan(1, &amp;field, TAP_PI);
+							jtag_add_ir_scan(1, &amp;field, TAP_IRPAUSE);
 						if (jtag_execute_queue() != ERROR_OK)
 						{
 							tdo_mismatch = 1;
@@ -254,7 +254,7 @@
 								jtag_add_runtest(xruntest, xsvf_to_tap[xendir]);
 							else
 							{
-								xsvf_add_statemove(TAP_RTI);
+								xsvf_add_statemove(TAP_IDLE);
 								jtag_add_sleep(xruntest);
 								xsvf_add_statemove(xsvf_to_tap[xendir]);
 							}
@@ -279,13 +279,13 @@
 					field.in_value = NULL;
 					jtag_set_check_value(&amp;field, dr_in_buf, dr_in_mask, NULL);
 					if (tap == NULL)
-						jtag_add_plain_dr_scan(1, &amp;field, TAP_PD);
+						jtag_add_plain_dr_scan(1, &amp;field, TAP_DRPAUSE);
 					else
-						jtag_add_dr_scan(1, &amp;field, TAP_PD);
+						jtag_add_dr_scan(1, &amp;field, TAP_DRPAUSE);
 					if (jtag_execute_queue() != ERROR_OK)
 					{
 						tdo_mismatch = 1;
-						break;	
+						break;
 					}
 					if (xruntest)
 					{
@@ -293,7 +293,7 @@
 							jtag_add_runtest(xruntest, xsvf_to_tap[xenddr]);
 						else
 						{
-							xsvf_add_statemove(TAP_RTI);
+							xsvf_add_statemove(TAP_IDLE);
 							jtag_add_sleep(xruntest);
 							xsvf_add_statemove(xsvf_to_tap[xenddr]);
 						}
@@ -353,13 +353,13 @@
 						field.in_value = NULL;
 						jtag_set_check_value(&amp;field, dr_in_buf, dr_in_mask, NULL);
 						if (tap == NULL)
-							jtag_add_plain_dr_scan(1, &amp;field, TAP_PD);
+							jtag_add_plain_dr_scan(1, &amp;field, TAP_DRPAUSE);
 						else
-							jtag_add_dr_scan(1, &amp;field, TAP_PD);
+							jtag_add_dr_scan(1, &amp;field, TAP_DRPAUSE);
 						if (jtag_execute_queue() != ERROR_OK)
 						{
 							tdo_mismatch = 1;
-							break;	
+							break;
 						}
 						if (xruntest)
 						{
@@ -367,7 +367,7 @@
 								jtag_add_runtest(xruntest, xsvf_to_tap[xenddr]);
 							else
 							{
-								xsvf_add_statemove(TAP_RTI);
+								xsvf_add_statemove(TAP_IDLE);
 								jtag_add_sleep(xruntest);
 								xsvf_add_statemove(xsvf_to_tap[xenddr]);
 							}
@@ -418,14 +418,14 @@
 					{
 						int i,lasti;
 						/* here the trick is that jtag_add_pathmove() must end in a stable
-						state, so we must only invoke jtag_add_tlr() when we absolutely 
+						state, so we must only invoke jtag_add_tlr() when we absolutely
 						have to
 						*/
-						for(i=0,lasti=0;i&lt;path_len;i++) 
+						for(i=0,lasti=0;i&lt;path_len;i++)
 						{
-							if(path[i]==TAP_TLR) 
+							if(path[i]==TAP_RESET)
 							{
-								if(i&gt;lasti)  
+								if(i&gt;lasti)
 								{
 									jtag_add_pathmove(i-lasti,path+lasti);
 								}
@@ -433,7 +433,7 @@
 								jtag_add_tlr();
 							}
 						}
-						if(i&gt;=lasti) 
+						if(i&gt;=lasti)
 						{
 							jtag_add_pathmove(i-lasti, path+lasti);
 						}
@@ -536,7 +536,7 @@
 		if (do_abort || unsupported || tdo_mismatch)
 			break;
 	}
-	
+
 	if (tdo_mismatch)
 	{
 		command_print(cmd_ctx, &quot;TDO mismatch, aborting&quot;);
@@ -554,18 +554,18 @@
 		command_print(cmd_ctx, &quot;premature end detected, aborting&quot;);
 		return ERROR_OK;
 	}
-	
+
 	if (dr_out_buf)
 		free(dr_out_buf);
-	
+
 	if (dr_in_buf)
 		free(dr_in_buf);
-	
+
 	if (dr_in_mask)
 		free(dr_in_mask);
 
 	close(xsvf_fd);
-	
+
 	command_print(cmd_ctx, &quot;XSVF file programmed successfully&quot;);
 
 	return ERROR_OK;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000013.html">[Openocd-svn] r1231 - trunk/src/target
</A></li>
	<LI>Next message: <A HREF="000015.html">[Openocd-svn] r1233 - /
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14">[ date ]</a>
              <a href="thread.html#14">[ thread ]</a>
              <a href="subject.html#14">[ subject ]</a>
              <a href="author.html#14">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openocd-svn">More information about the openocd-svn
mailing list</a><br>
</body></html>
